00:06:45 <LLckfan> Can some1 tell me why in Google Chrome it sometimes will not go to the address I type in but if I click a link somewhere it goes to that address with an issue
00:08:37 <bitonic> LLckfan: this is a channel about Haskell, the programming language
00:23:38 * hackagebot sscgi 0.3.0 - Simple SCGI Library  http://hackage.haskell.org/package/sscgi-0.3.0 (ChrisForno)
00:23:40 * hackagebot templatepg 0.2.6 - A PostgreSQL access library with compile-time SQL type inference  http://hackage.haskell.org/package/templatepg-0.2.6 (ChrisForno)
00:24:36 <Jookia> Are FRP programs hard to test?
00:50:04 <sillyfoo> hello people from haskell. 'readProcess' from (System.Process) is throwing me a 'fd:5, hGetContents: invalid argument (invalid byte sequence). thread blocked indefinitely in an MVar operation. 'echo $LANG' : en_GB.UTF-8. I recall solving a similar problem with hSetEncoding stdin utf8 >>, but alas, that was for a different library (System.IO). After searching the net, I am a bit at loss. What...
00:50:05 <sillyfoo> ...should I do?
00:50:48 <shachaf> Perhaps not use readProcess but whatever thing it's based on?
00:51:09 <shachaf> And then hSetEncoding the Handle.
00:52:40 <_emm_1> I'd display the command line you used, launch it in a shell and redirect its output to a file, and look at the file
00:53:15 <shachaf> ?!
00:53:15 <kappabot> Maybe you meant: . ? @ v
00:53:21 <shachaf> A shell? A file? Why?
00:53:59 <sillyfoo> _emm_1: it' s a simple cat somefile. It works when launched from a shell (or you mean: look at the file encoding?)
00:56:01 <_emm_1> sillyfoo: yes, to see if you have some funky caracter
00:56:35 <_emm_1> sillyfoo: I'm not sure why you would want to use readProcess if all you want is read the content of a file, though? Unless you're experimenting
00:57:09 <_emm_1> sillyfoo: you can try "file -i $MYFILE"
00:57:17 <sillyfoo> _emm_1: because I am a naive person who is prone to ducttape solutions. Which function should I use instead?
00:58:35 <sillyfoo> charset=iso-8859-1
01:00:00 <shachaf> _emm_1: If you want to read a file, why not use readFile?
01:00:17 <_emm_1> sillyfoo: http://hackage.haskell.org/packages/archive/text/0.7/doc/html/Data-Text-IO.html for instance
01:00:33 <_emm_1> assuming you're a sensible person who uses Data.Text
01:01:41 <sillyfoo>  /s/sensible/naive /s/uses/heard-from-the-first-time-of :P
01:01:45 * sillyfoo studies
01:02:31 <shachaf> You should also understand how Unicode works at least at a high level, e.g. what UTF-8 means and the difference between String/Text and ByteString.
01:02:41 <_emm_1> I see you have an hSetEncoding function, which sounds like what you need
01:02:53 <_emm_1> open handle, set encoding, read file, close handle
01:15:33 <sillyfoo> aaand it worked gents. Thank you both, _emm_1 and shachaf . I will educate myself on encoding matters now.
01:20:44 <_emm_1> sillyfoo: you're welcome
01:22:22 <osa1> can anyone help me with this : http://hpaste.org/87991 when I run my REPL with runhaskell, prompt is printed after input is read, but it works correct under ghci
01:23:57 <shachaf> You didn't @paste your code so I have no idea what's really going on, but it's probably a buffering issue.
01:24:09 <shachaf> Try flushing after printing the prompt.
01:24:27 <shachaf> (Or disabling buffering, but that's probably a bad idea for non-toys for things like this.)
01:25:53 <osa1> shachaf: ok, flushing worked
01:35:51 <bambam> could someone help me understand call/cc
01:37:08 <johnw> sure, what's the question?
01:37:35 <johnw> bambam: let me know if this helps: https://www.fpcomplete.com/content#/tutorial/understanding-continuations
01:38:42 <johnw> that might not be the public link, try:
01:38:43 <johnw> https://www.fpcomplete.com/user/jwiegley/understanding-continuations
02:18:43 * hackagebot hist-pl-lexicon 0.4.0 - A binary representation of the historical dictionary of Polish  http://hackage.haskell.org/package/hist-pl-lexicon-0.4.0 (JakubWaszczuk)
02:23:43 * hackagebot hist-pl-fusion 0.4.0 - Merging historical dictionary with PoliMorf  http://hackage.haskell.org/package/hist-pl-fusion-0.4.0 (JakubWaszczuk)
02:23:45 * hackagebot hist-pl 0.1.0 - Umbrella package for the historical dictionary of Polish  http://hackage.haskell.org/package/hist-pl-0.1.0 (JakubWaszczuk)
02:40:46 <tomboy64> is there somebody awake here who could help me with a small syntax problem regarding xmonad's config?
02:41:50 <tomboy64> i am trying this here http://bpaste.net/show/99002/ in my manage hooks; but upon compilations it's telling me it Couldn't match expected type `Query Bool' with actual type `Bool'    for <&&>
02:42:16 <tomboy64> please look at the second occurence of className =? "Claws-mail"
02:43:44 * hackagebot io-choice 0.0.4 - Choice for IO and lifted IO  http://hackage.haskell.org/package/io-choice-0.0.4 (KazuYamamoto)
02:45:01 <tomboy64> hah. solved it!
02:56:15 <fruitFly> hi
02:57:04 <fruitFly> what do you think is an efficient way to make sure a string contains only hex chars?
02:58:38 <Kinnison> foostr:find("[^A-Fa-f0-9]")
02:58:39 <Kinnison> ?
02:58:46 <johnw> fruitFly: what do you mean by efficient?  it's going to be O(n) unless you move it into the type system
02:59:05 <circle> what are the curly braces in haskell for?
02:59:09 <circle> I seemed to have missed it
02:59:09 <Kinnison> gah, sorry, I thought this was #lua for a moment
02:59:12 <Kinnison> I need more tea :-)
02:59:15 <johnw> circle: it's an alternative to whitespace layout
02:59:23 <circle> like Data Example {Durr, Durrrrrr, nurrrurudurdurr}
02:59:37 <johnw> can you show a fuller example?
02:59:45 <johnw> you could be talking about something to do with records
03:00:02 <fruitFly> johnw: I just want to test if a string is valid hex... i don't need the most efficient implementation possible, but I'm thinking of different ways and am curious as to what you think
03:00:10 <circle> Data Test {Score :: Int, Names :: [Char]}
03:00:53 <johnw> fruitFly: isJust . find (\c -> c `notElem` ['a' .. 'f'] || c `notElem` [0..9])
03:00:55 <fruitFly> johnw: Kinnison what about filtering a string with the function isHex and then testing to see if false is in it?
03:01:02 <johnw> oh, I keep doing that
03:01:27 <XexonixXexillion> data Test {score :: Int, names :: [Char]}, capitalisation is important
03:01:46 <johnw> fruitFly: any (\c -> c `notElem` ['a' .. 'f'] || c `notElem` [0..9])
03:01:47 <XexonixXexillion> circle: it's record syntax
03:02:12 <johnw> :t isHex
03:02:12 <kappabot> Not in scope: `isHex'
03:02:29 <johnw> fruitFly: all isHexDigit
03:02:31 <fruitFly> johnw: ok thanks... I will take a look at that... there is a func for testing for hex.. soon tell you
03:02:44 <fruitFly> johnw: all?
03:02:50 <fruitFly> call
03:02:54 <fruitFly> ?
03:03:05 <fruitFly> @src isHexDigit
03:03:05 <kappabot> Source not found. This mission is too important for me to allow you to jeopardize it.
03:03:13 <johnw> isHexDigit says if a character is hex
03:03:13 <XexonixXexillion> :t all
03:03:13 <fruitFly> heh
03:03:14 <kappabot> forall a. (a -> Bool) -> [a] -> Bool
03:03:24 <johnw> all returns True if all list members fulfill the predicate
03:03:40 <XexonixXexillion> when did lambdabot become kappabot?
03:03:46 * hackagebot egison 3.0.3 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-3.0.3 (SatoshiEgi)
03:03:49 <johnw> XexonixXexillion: this week
03:04:16 <circle> XexonixXexillion: interesting
03:04:25 <circle> XexonixXexillion: book doesn't mention records at all.
03:04:40 <fruitFly> johnw: thanks.. that sounds like a useful func :).. all
03:04:42 <fruitFly> :)
03:04:53 <circle> how do I use these records?
03:05:03 <johnw> fruitFly: there's also 'any'
03:05:33 <fruitFly> johnw: ok
03:24:53 <Scabe> test
03:25:07 <johnw> consider us tested
03:26:30 <Scabe> http://hpaste.org/87999
03:26:42 <Michael_> What's the best/fastest way to get to the bottom of a tree?
03:26:43 <Scabe> ^I have a problem, this doesn't seem to work on my test_case
03:28:23 --- mode: ChanServ set +o mauke
03:28:23 --- mode: mauke set +q $a:LLckfan
03:30:23 --- mode: mauke set -o mauke
03:30:58 <blaenk> I think I found a bug in a package, how can I go about building it and using it to test if my fix works?
03:31:07 <blaenk> I know of cabal-dev but I'm not sure how it fits into the picture
03:32:56 <supki> Scabe: "doesn't seem to work" is not a description of "problem"
03:33:05 <merijn> Is there a way to get the haddocks for a package without having to build it?
03:33:44 <merijn> blaenk: "cabal unpack package-name" cd into the directory, patch the code, then run "cabal install" or "cabal build" in that directory
03:34:25 <blaenk> merijn: thank you! but this won't clash with the package that's already installed?
03:34:41 <supki> merijn: cabal haddock
03:34:44 <merijn> blaenk: It will if you install, it won't if you only build
03:35:03 <blaenk> merijn: alright I got it, my question is, how can I then use this library to test if it works
03:35:08 <merijn> supki: That requires me to configure the package (and also build?), which I can't because I'm missing C dependencies
03:35:17 <blaenk> as in, how would I import it, by absolute/relative path?
03:35:20 <supki> oh, yes, you need to configure
03:35:44 <merijn> bollocks :\
03:35:58 <merijn> Hackage doesn't seem to have build haddocks for the package either
03:36:03 <quchen> Scabe: "Doesn't work" is not a good error description. (I also annotated your code, have a look at it.)
03:41:40 <Scabe> :quchen thanks!
03:43:48 * hackagebot hist-pl-transliter 0.1.0 - A simple EDSL for transliteration rules  http://hackage.haskell.org/package/hist-pl-transliter-0.1.0 (JakubWaszczuk)
04:00:32 <adimit> is there a combinator such as (Functor f, Monad m) => (a -> m b) -> f a-> m (f b)? fmap only gives me f (m b) in the end, but I'd like it the other way around.
04:02:05 <adimit> the closest thing I've found is traverse,
04:09:11 <merijn> :t traverse
04:09:12 <kappabot>     Not in scope: `traverse'
04:09:12 <kappabot>     Perhaps you meant one of these:
04:09:12 <kappabot>       `Data.Traversable.traverse' (imported from Data.Traversable),
04:09:20 <merijn> :t Data.Traversable.traverse
04:09:21 <kappabot> forall (t :: * -> *) (f :: * -> *) a b. (Applicative f, Data.Traversable.Traversable t) => (a -> f b) -> t a -> f (t b)
04:09:50 <merijn> adimit: Isn't traverse exactly what you want, though?
04:13:22 <dEPy> hi ho
04:13:30 <ocharles> Well, Traversable requires his/her f be traversable, but he/she only said Functor
04:14:03 <ocharles> I don't think it can be done for Functor though, that's why you need something more powerful (Traversable)
04:16:22 <merijn> It can't be done in Functor, which is why Traversable exists
04:20:01 <fruitFly> I'm learning how to use Maybe ... what's wrong with this?
04:20:01 <fruitFly> http://ideone.com/auWC73
04:20:45 <merijn> fruitFly: Did you read the error?
04:21:34 <fruitFly> merijn: yes... it wants maybe string instead of string
04:21:43 <dwcook> fruitFly, I suspect returning a Bool would be more appropriate for that function
04:22:01 <dwcook> but you're missing a data constructor
04:22:02 <merijn> fruitFly: Right, so if you look at line 20 like it mentions
04:22:15 <merijn> What's the type you're returning
04:22:16 <fruitFly> dwcook: possibly.. I'll def look at it soon
04:22:43 <fruitFly> merijn: oh.. so I must return Just hexA?
04:23:20 <merijn> fruitFly: Yes
04:23:44 <fruitFly> ok
04:24:29 <fruitFly> merijn: why dooes maybe work like that and not just return String? isn't it annoying to have to parse the just out later?
04:24:41 <merijn> fruitFly: How else would it work?
04:24:42 <fruitFly> merijn: not annoying... but excess? what's the functionallity of jusT?
04:25:07 <merijn> How would you pattern match without a constructor?
04:25:12 <fruitFly> merijn: ^ ??
04:25:13 <fruitFly> Maybe String returns either Nothing or a String
04:25:18 <merijn> No
04:25:28 <no-n> @src Maybe
04:25:28 <kappabot> data Maybe a = Nothing | Just a
04:25:29 <merijn> Maybe String is a value that may or may not contain a string
04:25:39 <merijn> The only way to check is to pattern match
04:25:54 <Floris> does someone know how to fix this? :     `IO' is applied to too many type arguments
04:25:55 <Floris>     In an expression type signature: IO String a => [(Int, a)]
04:25:56 <Floris>     In the expression: (reads readLn :: IO String a => [(Int, a)])
04:25:58 <Floris>     In the expression:
04:25:58 <Floris>       case (reads readLn :: IO String a => [(Int, a)]) of {
04:25:59 <Floris>         [(n, s)] -> n }
04:26:27 <merijn> Floris: Hold on "reads readLn" makes no sense
04:26:28 <dwcook> Floris, you're applying IO to String then a
04:26:33 <hpc> that's a new one
04:26:38 <dwcook> Oh woops
04:27:28 <dwcook> Yeah, I'm not sure what you mean by IO String a, but IO just takes one thing
04:28:05 <dwcook> You're also using it as a constraint, but IO isn't one of those either
04:28:13 <dwcook> It's a type constructor, not a typeclass
04:28:16 <fruitFly> merijn: ok thanks
04:28:30 <no-n> fruitFly, why not any (`notElem` ['0'..'9']++['a'..'f']) hexa = Nothing
04:28:52 <Floris> ah that might work :)
04:29:06 <merijn> More fundamentally, you're applying "reads :: Read a => String -> [(a, String)]" to "readLn :: Read a => IO a"
04:29:18 <fruitFly> no-n: yeah Thanks :)
04:29:24 <merijn> There are a great many things wrong with that example line
04:30:30 <Floris> is there an easy way to only read an int from the terminal?
04:30:37 <merijn> Probably you wanted something more like "do { val <- getLine; case reads val of [(x, "")] -> {- something -} }" or just "readLn"
04:30:59 <merijn> Floris: readLn already does that (but throws an exception if the parse fails)
04:31:07 <merijn> :t readLn
04:31:08 <kappabot> forall a. Read a => IO a
04:31:12 <merijn> :t readLn :: IO Int
04:31:13 <kappabot> IO Int
04:33:02 <Floris> it will give me an error if there is an NaN input
04:34:18 <merijn> There is no NaN for Int...
04:34:47 <Floris> if i type 34ys there is an error
04:35:05 <Floris> Main: user error (Prelude.readIO: no parse)
04:35:28 <merijn> Yes, because 34ys is not a number. What are you trying to do?
04:36:21 <Floris> i want to get a number but i want it not to fail if there is a character as input
04:36:40 <Floris> that it just takes 34
04:36:57 <merijn> Hmm, if I want to use State/Reader for internal things of my library and still compose with State/Reader usage of my users I guess I'll have to implement my own versions of State/Reader with a different name?
04:38:03 <merijn> :t read . takeWhile isDigit `fmap` getLine :: IO Int
04:38:04 <kappabot>     Precedence parsing error
04:38:04 <kappabot>         cannot mix `.' [infixr 9] and `fmap' [infixl 9] in the same infix expression
04:38:30 <merijn> :t (read . takeWhile isDigit) `fmap` getLine :: IO Int
04:38:31 <kappabot> IO Int
04:39:05 <merijn> > read (takeWhile isDigit "34ys") :: Int
04:39:06 <kappabot>   34
04:39:38 <no-n> oh, that's a good idea
04:39:41 <no-n> is that what reads does?
04:39:52 <merijn> :t reads
04:39:53 <kappabot> forall a. Read a => ReadS a
04:39:55 <Floris> that only works with a string
04:40:04 <no-n> forall I haven't learnt that one yet :3
04:40:08 <no-n> :t forall
04:40:09 <kappabot>     Not in scope: `forall'
04:40:09 <kappabot>     Perhaps you meant `forAll' (imported from Test.QuickCheck)
04:40:16 <no-n> hrm
04:40:25 <merijn> no-n: Forall is not a function, it's part of type signatures
04:40:34 <no-n> oh
04:40:41 <merijn> no-n: It's implicit by default, unless you enable some extensions
04:41:01 <merijn> i.e. "foo :: [a] -> [a]" is really "foo :: forall a . [a] -> [a]"
04:41:07 <no-n> oh, I see
04:41:27 <no-n> "forall a's", or "forall a's in Eq", etc?
04:45:01 <no-n> @src (->)
04:45:01 <kappabot> Source not found. My brain just exploded
04:49:22 <Aetherspawn> @src (.)
04:49:23 <kappabot> (f . g) x = f (g x)
04:49:23 <kappabot> NB: In lambdabot,  (.) = fmap
04:49:39 <Aetherspawn> @src (,)
04:49:40 <kappabot> Source not found. I am sorry.
04:49:44 <Aetherspawn> @src (,,)
04:49:45 <kappabot> Source not found. You speak an infinite deal of nothing
04:49:56 <Aetherspawn> I cried.
04:51:41 <no-n> repeat Nothing -- me too!
04:52:27 <byorgey> Aetherspawn: (,) and (,,) are built-in primitive syntax, they don't really have definitions
04:52:48 <byorgey> though you could say e.g.  (,,) = \x y z -> (x,y,z)
04:58:51 * hackagebot polyparse 1.9 - A variety of alternative parser combinator libraries.  http://hackage.haskell.org/package/polyparse-1.9 (MalcolmWallace)
05:03:51 * hackagebot HaXml 1.24 - Utilities for manipulating XML documents  http://hackage.haskell.org/package/HaXml-1.24 (MalcolmWallace)
05:11:37 <Floris> how do i use this?: number <- [(_,(a:_))] = input in a
05:11:38 <Floris> where input is something like [(123,"hallo")]
05:12:30 <Floris> i ment [(a,(_:_))]
05:13:13 <ketil> Floris, do you mean something like:   case input of [(a,(_:_))] -> -- do something with 'a'
05:13:54 <Aetherspawn> lol'd at no-n's comment
05:14:19 <Floris> can i store a into another variable?
05:15:39 <hiptobecubic> Hey type theory wizards, can you give an example where Haskell infers a Sum type? Is it possible to do so? If not, why not?
05:15:57 <Floris> i'm getting mad.. is there no normal way to get the numbers out of an IO String?
05:16:01 <merijn> no-n: Had to run for lunch. In my example it basically means that "forall types a, foo is a function of type [a] -> [a]"
05:16:05 <Eduard_Munteanu> hiptobecubic: what do you mean "Sum type"?
05:16:12 <mauke> Floris: an IO String is not a container
05:16:16 <merijn> Floris: What's wrong withmy code from earlier?
05:16:34 <Eduard_Munteanu> @quote shachaf.*bin.ls
05:16:35 <kappabot> No quotes match. You type like i drive.
05:16:42 <Floris> no the rest of my code is no right.. :(
05:16:42 <Eduard_Munteanu> @quote bin.ls
05:16:43 <kappabot> No quotes match.
05:16:45 <merijn> @quote shachaf bin/ls
05:16:46 <kappabot> No quotes match. The more you drive -- the dumber you get.
05:16:47 <Eduard_Munteanu> :(
05:16:49 <merijn> @quote shachaf ls
05:16:49 <kappabot> No quotes match.
05:16:52 <merijn> aww
05:17:00 <Eduard_Munteanu> No quotes at all, I'd guess.
05:17:01 <merijn> I guess kappabot has not quotes file
05:17:02 <Eduard_Munteanu> @quote
05:17:02 <kappabot> User_4574 says: I like Tinned_Tuna
05:17:20 <mauke> preflex: quote shachaf ls
05:17:20 <preflex>  no quotes found for shachaf
05:17:24 <mauke> ow well
05:18:38 <rgrinberg> how do i get rid of my habit of wasting time defending FP against fud on reddit
05:18:42 <danr> @hoogle f (a -> b) -> a -> f b
05:18:42 <kappabot> A Hoogle error occurred.
05:18:51 * hackagebot snap-blaze-clay 0.1.0.0 - blaze-html-clay integration for Snap  http://hackage.haskell.org/package/snap-blaze-clay-0.1.0.0 (DecebalPopa)
05:19:22 <hiptobecubic> There is a post by the ever popular Harrop on SO where he compares type inference in ocaml and f#. It's not his usual "F# is great and everything else is for ridiculous ideologues", I don't know enough to know what he's referring to here. http://stackoverflow.com/questions/3162387/why-is-fs-type-inference-so-fickle/3162832#3162832
05:19:26 <hiptobecubic> Eduard_Munteanu, ^
05:19:40 <merijn> rgrinberg: http://bumblebeesystems.dyndns.org/wastenotime/ block reddit
05:19:42 <hiptobecubic> ", but I don't... *
05:19:43 <typoclass> Floris: have you tried "n <- getLine" or similar? it works inside of 'do' blocks
05:20:11 <Floris> typoclass: yes but then i get characters as well
05:20:18 <rfw> @pl \fn -> length . words <$> readFile fn
05:20:18 <kappabot> (length . words <$>) . readFile
05:20:31 <eikke> :t read `fmap` getLine :: IO Int
05:20:32 <kappabot> IO Int
05:20:43 <mauke> Floris: so call read on it
05:20:56 <merijn> Floris: I mentioned "(read . takeWhile isDigit) `fmap` getLine" likes 30 minutes back
05:22:01 <Floris> merijn: i did'n saw that :( maybe it works. trying to get this right for a day now
05:22:17 <rgrinberg> merijn: but there is still some useful content there
05:22:47 <Floris> Not in scope: `isDigit'
05:23:27 <Floris> where is the dot for after read?
05:23:49 <mauke> @index isDigit
05:23:50 <kappabot> Data.Char
05:25:05 <Floris> do i have to inport Data.Char?
05:25:06 <typoclass> merijn: hm ... couldn't he just use 'reads'?
05:25:23 <mr-> Floris: yes
05:25:33 <mr-> Floris: and the dot is function composition
05:25:45 <mr-> :t (.)
05:25:46 <kappabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
05:25:56 <eikke> hiptobecubic: inference of sum types. interesting.
05:26:24 <hiptobecubic> eikke, is it? I have no idea what it actually means.
05:26:30 <eikke> me neither :)
05:26:39 <typoclass> Floris: hello, i didn't catch the start of the conversation, but have you tried the 'reads' function?
05:26:41 <typoclass> > reads "123abc" :: [(Int, String)]
05:26:42 <hiptobecubic> I know what a sum type is, assuming we're just talking about Either a b, for example
05:26:42 <kappabot>   [(123,"abc")]
05:26:56 <hiptobecubic> but what's so hard about inferring that?
05:27:01 <hiptobecubic> :t Right 4
05:27:02 <kappabot> forall a b. Num b => Either a b
05:27:10 <hiptobecubic> There. Looks good to me
05:27:21 <Floris> typoclass: yes but i won't work with IO String
05:27:42 <eikke> hiptobecubic: to me it sounds like "Let's throw some words together most people reading this will have to Google, but will be too lazy, so I can sound smart, then say something which makes no sense at all"
05:27:58 <eikke> Floris: fmap it
05:28:05 <hiptobecubic> eikke, well that's his usual approach. But it's not fair to throw it out immediately. Maybe there's some sense there
05:28:06 <typoclass> Floris: that's true. inside a 'do' block, try "x <- getLine" and then "reads x ..."
05:28:38 <typoclass> Floris: (or alternatively, use fmap. but in my opinion you should learn it the plain way first)
05:28:43 <Eduard_Munteanu> IIRC they're something like A + B  ~  A or B. Basically Either but not pattern-matchy.
05:28:55 <Floris> typoclass: oh i will try that if merijn's code won't work for me
05:29:04 * Eduard_Munteanu could be wrong though
05:29:16 <Eduard_Munteanu> But then again a lot of that stuff is morally wrong too. :P
05:29:19 <typoclass> Floris: if you get stuck, feel free to put your code on hpaste.org so we can look at it :-)
05:29:28 <eikke> Eduard_Munteanu: you mean the `A and `B stuff in OCaml?
05:29:49 <Eduard_Munteanu> eikke: err, dunno much about OCaml
05:30:18 <Floris> typoclass: ole i didn't know that site
05:30:19 <hiptobecubic> I don't know anything about OCaml really. Just a few complaints and perks people have mentioned
05:30:30 <Eduard_Munteanu> hiptobecubic: anyway, we don't have those in Haskell, so your statement is true (even if vacuously :P).
05:30:54 <Eduard_Munteanu> @faq Can Haskell infer sum types?
05:30:55 <kappabot> The answer is: Yes! Haskell can do that.
05:30:56 <eikke> Eduard_Munteanu, hiptobecubic: http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual006.html#htoc41
05:31:36 <Eduard_Munteanu> Looks like I wasn't far off, yeah.
05:31:56 <hiptobecubic> Well in reading about algebra over types, Either was directly called a sum type, ( (,) was product ) so what are you actually talking about? A type which is one of two types but has no information about which one it is?
05:32:04 <eikke> it's indeed sum-type-like-without-definition-of-the-sum-type-as-a-datatype
05:32:37 <eikke> (I dislike it :-P we're not using it in our ocaml code, luckily)
05:33:04 <rgrinberg> i do think that polymorphic variants have some cool uses
05:33:11 <Eduard_Munteanu> Well, I don't think it allows types to be ambiguous.
05:33:43 <Eduard_Munteanu> Anyway, if Either is a disjoint union, sum types are actual unions, I guess.
05:34:03 <eikke> it does allow for "Oh, we have some new case? let's choose some new variant"-type coding, which results in an explosion of the cases
05:34:26 <Floris> http://hpaste.org/88002
05:34:37 <rgrinberg> its useful for breaking circular dependencies sometimes in OCaml
05:34:43 <rgrinberg> which are extremely annoying
05:34:48 <Eduard_Munteanu> I wonder how erasure works, or how they justify it.
05:35:02 <eikke> rgrinberg: true
05:35:04 <Eduard_Munteanu> In Haskell you keep the constructor.
05:35:57 <rgrinberg> they also act like "labels" on a return type
05:36:15 <typoclass> Floris: which line is the problem? i suspect it's line 13?
05:36:16 <rgrinberg> for example janestreet uses an int tagged with `pid to show that the int being returned is a process id
05:36:48 <Floris> typoclass: yes that function must return an number
05:37:28 <Floris> typoclass: as you may can see, i'm really new to haskell
05:37:56 <eikke> Floris: you can't get 'a number' (e.g. something of type Int) out of an 'IO String'. All you can get is an 'IO Int'
05:38:06 <mr-> Floris:         let (n,_):_ = reads x :: [(Int,String)]
05:38:07 <typoclass> Floris: sure :-) don't worry. try "let number = reads x ...". for functions that give "IO Something", use "<-". for pure functions, use "let ... = ..."
05:38:46 <mr-> Floris: you "returned" a [(Int,String)], while you wanted just the first Int from the list (I guess)
05:38:56 <Floris> ah IO Int is oke to i think
05:39:12 <Floris> mr-: true
05:39:49 <typoclass> Floris: and yes, mr- is right. you need some more pattern matching there :-) but pattern matching can be done in "let ... ="
05:40:04 <mr-> Floris: http://hpaste.org/88002
05:40:07 <hiptobecubic> eikke, so how does it work in practice? You have a chunk of data and you know it's an int or a float but you don't know which?
05:40:24 <eikke> hiptobecubic: uh?
05:40:41 <hiptobecubic> eikke, these polymorphic variants
05:40:47 <hiptobecubic> eikke, i'm looking at your link
05:41:03 <eikke> hiptobecubic: ah. You can pattern-match on the tag
05:41:16 <mr-> Floris: so, the lessons are: let number = .. and more pattern matching ;-)
05:41:53 <hiptobecubic> eikke, how is that different from pattern matching on the constructor to an Either a b type?
05:42:01 <Floris> mr-: i did't know i needed let for pattern matching now i do :)
05:42:27 <mr-> Floris: it is not the pattern matching, it is the non-monadic function to the right of the =
05:42:29 <Floris> thanks for the help
05:42:41 <eikke> hiptobecubic: you can just invent new tags without extending any data type
05:42:50 <Eduard_Munteanu> Err, you can?
05:42:52 <hiptobecubic> > let f (Right x) = show x; f (Left x) = "ARGH"; y = Right 3 in f y
05:42:53 <kappabot>   "3"
05:43:16 <hiptobecubic> eikke, you can extend the data type with new tags at any time?
05:43:32 <eikke> there is no real datatype
05:43:33 <Eduard_Munteanu> Whatever you're calling "tags" looks fixed when you spell the type.
05:43:40 <sopvop> :t (<$)
05:43:41 <kappabot> forall (f :: * -> *) a b. Functor f => a -> f b -> f a
05:43:49 <hiptobecubic> like Either a b c = Right a | Center b | Left c
05:43:53 * hackagebot llvm-tf 3.0.0.0.1 - Bindings to the LLVM compiler toolkit using type families.  http://hackage.haskell.org/package/llvm-tf-3.0.0.0.1 (HenningThielemann)
05:44:01 <hiptobecubic> maybe I should just ask #ocaml :D
05:44:16 <Eduard_Munteanu> Also, perhaps not tags? AFAIU, it's something like   x : A + B => x : A or x : B
05:44:21 <Eduard_Munteanu> e.g...\
05:44:25 <hiptobecubic> or not... is there an #ocaml?
05:44:39 <Eduard_Munteanu> Bool + Int will let you match on False, True, 0, 1, 2 ...
05:44:50 <sopvop> :t \x -> fmap (const x)
05:44:51 <kappabot> forall (f :: * -> *) a b. Functor f => b -> f a -> f b
05:45:07 <mr-> Floris: also, print x = putStrLn ( show x ), btw
05:45:15 <Eduard_Munteanu> So if matching works on the underlying types, you get it in the sum type too.
05:45:21 <hiptobecubic> Eduard_Munteanu, I see...
05:45:26 <eikke> yes, something like that
05:45:46 <hiptobecubic> So you just skip the wrapping up and unwrapping
05:46:02 <eikke> hiptobecubic: # let f a = match a with `A -> 1 | `B -> 2;;
05:46:02 <eikke> val f : [< `A | `B ] -> int = <fun>
05:46:03 <Eduard_Munteanu> I guess so.
05:46:25 <Floris> mr-: is that just the same?
05:46:28 <hiptobecubic> Because it seems pretty clear that this is the same as having a type S a b c d .... with as many constructors as you need and then matching them
05:46:46 <eikke> hiptobecubic: yes, except there is no explicit 'listing' of the variants in any datatype
05:46:49 <hiptobecubic> Just without explicitly making that type
05:46:50 <hiptobecubic> right
05:47:14 <eikke> and variants aren't bound to a specific set of 'constructors'
05:47:20 <hiptobecubic> eikke, i don't know how to read that snippet you gve
05:47:22 <hiptobecubic> gave*
05:47:42 <hiptobecubic> f is a function with type   "[< `A | `B] -> int"    ?
05:48:11 <hiptobecubic> What's "[<"  and why are ` needed? Just to signify polymorphic type variables?
05:48:13 <eikke> yes, where [< `A | `B] means "variant `A or `B" (think of those as constructors without any argument)
05:48:46 <eikke> let f a = match a with `A (_ : int) -> 1 | `B -> 2 has type val f : [< `A of int | `B ] -> int
05:49:12 <hiptobecubic> eikke, in your example then, *what* is `A ?
05:49:28 <eikke> a tag
05:49:35 <hiptobecubic> For example in "Maybe a", "a" is a type variable
05:49:49 <hiptobecubic> a taggggg.... hmmmm
05:49:56 <hiptobecubic> What is it tagging?
05:49:58 <mr-> Floris: It's just that when x already is a string, putStrLn x is enough, no need to "show" it anymore ;-)
05:50:00 <hiptobecubic> the value?
05:50:06 <hiptobecubic> that f will be applied t?
05:50:07 <hiptobecubic> to*
05:50:15 <eikke> hiptobecubic: `A is just
05:50:28 <Floris> mr-: oke
05:50:45 <eikke> "tag `A without anything more", whilst "`A 1" would be "1 tagged with `A"
05:51:32 <hiptobecubic> eikke, I suppose I don't see how tags differ from my constructors example then
05:51:58 <Eduard_Munteanu> I'm not sure either... even if you don't tag, the resulting code must track types somehow.
05:52:00 <eikke> hiptobecubic: but there's no way to "hide" tags (so any code can unpack a tagged value without access to any 'constructor')
05:52:11 <hiptobecubic> data Tag = JustA | A Int
05:52:38 <hiptobecubic> eikke, when would you use this feature? Maybe that will help
05:53:10 <eikke> hiptobecubic: in your example Tag, there's a link between JustA and A, they're constructors of the same datatype Tag, whilst there's never any link between `A and `B
05:53:10 <hiptobecubic> eikke, and further, why have normal data types and constuctors at all?
05:53:19 <Eduard_Munteanu> I wonder if you can define recursive types that way.
05:53:39 <Eduard_Munteanu> (how about equirecursive?)
05:53:48 * Eduard_Munteanu stops the craziness
05:53:54 <hiptobecubic> eikke, well they're linked by the type of f, which is "(A+B)"
05:54:26 <hiptobecubic> data TypeOfF = JustA | A Int | B Whatever
05:54:32 <Eduard_Munteanu> Haskell makes it explicit at the data level, sum types make it implicit.
05:54:35 <eikke> hiptobecubic: but you can easily also define some 'g' which takes (`B + `C), without any link between `A and `C
05:54:58 <eikke> I think of those tags as atoms in Erlang
05:55:49 <hiptobecubic> hmm
05:56:43 <hiptobecubic> eikke, so what is the type of the thing f is being applied to? Also (`A + `B) or one of `A or `B and it doesn't matter which?
05:57:04 <hiptobecubic> because erlang solves this problem by throwing all the types in the toilet
05:57:13 <eikke> [< `A | `B]
05:58:58 <hiptobecubic> which means which of the two things i said ? :D
05:59:26 <hiptobecubic> For example, can you give an example value of something that f could be applied to?
05:59:33 <hiptobecubic> for any suitable f and value
05:59:49 <merijn> If you want to have two Reader/State monads available you either just have to merge your state using something like a tuple, or provide a reimplementation of Reader/State with different names, right?
06:00:14 <hiptobecubic> or stack them and then gouge your eyes out
06:00:20 <eikke> hiptobecubic: # let f x = match x with `A a -> a in f (`A 1) -> 1 (: int)
06:00:25 <merijn> Stacking is bad, mmmkay :p
06:00:45 <hiptobecubic> merijn, I'd use a tuple, but then... I'm just a guy trying to have a good time
06:00:54 <eikke> merijn: or use RWS and disregard the W part
06:01:10 <merijn> eikke: No, I mean 2 Readers and 2 State's, i.e. double RWS
06:01:13 <hiptobecubic> eikke, that doesn't give you two readers or two states
06:01:20 <eikke> oh, misread
06:01:39 <hiptobecubic> merijn, You want the product of two states, so just use a tuple, no?
06:01:51 <merijn> hiptobecubic, eikke: I'd use a tuple if it was just my code, but in this case I want my library to wrap a users State/Reader with my own and want to give the use access to both
06:02:00 <tdammers> ReaderT a ReaderT b StateT c StateT d IO () -- barf
06:02:23 <hiptobecubic> IO too?
06:02:26 <eikke> tdammers: no need to restrict to IO ;)
06:02:52 <hiptobecubic> merijn, make a type that houses their state and your state and give them that
06:02:53 <eikke> merijn: I'd use transformers somewhat like tdammers said
06:03:12 <hiptobecubic> eikke, tdammers is that supposed to make it *easier* for the user? or what?
06:03:14 <eikke> and some utility actions wrapping get/set/ask
06:03:35 <eikke> including lift where required
06:04:00 <merijn> eikke: Yeah, I was just trying to decide between tdammers example + lift or just providing my own stuff. But I guess I could just type alias one reader/state to something else
06:04:16 <merijn> hiptobecubic: If I did that I'd have to reimplement all State combinators for the user
06:04:26 <hiptobecubic> hmm
06:05:06 <dmwit> merijn: Correct. But there's only like... four combinators.
06:05:27 <eikke> merijn: some newtypes, some deriving & some utility functions and you're all set
06:05:39 <hiptobecubic> you mean get,set,modify....?
06:05:52 <dmwit> get, gets, put, modify, yep
06:06:04 <eikke> all lens utilities working in MonadState!
06:06:05 <merijn> hmmm
06:06:11 <hiptobecubic> Well hopefully you were planning on wrapping those anyway
06:06:43 <dmwit> Strange. Last night my laptop could ping my desktop but not ssh in; today my laptop can ssh in but not ping it.
06:07:03 <merijn> I was thinking just "type AppConfig = StateT Foo; StateT s AppConfig m ()" so the user can do whatever he/she like in State, but maybe I should just newtype it
06:07:17 <hiptobecubic> unless you think "lift lift lift lift lift ... " isn't going to be error prone.
06:08:20 <dmwit> merijn: Wait, isn't that the solution we've been discussing here that involves re-implementing the state combinators?
06:08:43 <dmwit> Like, you're still going to have to do that if you want them to be able to muck about with your AppConfig.
06:09:14 <hiptobecubic> right
06:09:40 <merijn> dmwit: I guess, hmm. blah...
06:27:32 <jo_> G'morning #haskell.
06:27:40 <typoclass> jo_: hi
06:29:17 <scooty-puff> i am having trouble finding i bug for this on ghc trac, but it appears that type family operators are not being exported from a module (or not imported in another one, anyways) - i can do import Type.Nat ((+)) without error, but cannot use (+)
06:29:57 <scooty-puff> i am currently working around it by defining type Add a b = a + b in the exporting module
06:38:47 <merijn> @pl \x f -> WS $ x >>= runWS . f
06:38:48 <kappabot> (WS .) . (. (runWS .)) . (>>=)
06:38:51 <merijn> hmmm
06:38:57 <merijn> That doesn't help much :p
06:51:29 <Fuuzetsu> :t sort
06:51:30 <kappabot> forall a. Ord a => [a] -> [a]
06:56:10 <ramses_> what happened to lambdabot? Did I miss something?
06:57:07 <Kinnison> It has been unwell for a while
06:57:24 <typoclass> Kinnison: please don't refer to her as 'it'
06:57:42 <Kinnison> Ve has been unwell for a while
06:57:56 <Eduard_Munteanu> @vixen Say hi to ramses_
06:57:56 <kappabot> hiya
06:57:59 <ramses_> so this kappabot is a rewrite then?
06:58:25 <Eduard_Munteanu> @vixen Are you a rewrite? What nerve. :P
06:58:25 <kappabot> let's don't talk about that
06:58:50 <typoclass> ramses_: i guess that just someone else is running the same lambdabot program, with the name kappabot
06:59:14 <quchen> I think Kappabot is shachaf.
06:59:24 <ramses_> ah, okay :) nothing new and shiny then
06:59:32 <Eduard_Munteanu> @vixen How do you feel about shachaf?
06:59:32 <kappabot> i do occassionally, i guess
06:59:46 * Eduard_Munteanu stops :)
06:59:51 <quchen> Well, Lambdabot doesn't break. It's the environment that does. It kept generating evaluation errors etc.
07:00:06 <EtnaRosso> hi all
07:00:20 <Eduard_Munteanu> EtnaRosso: hi
07:01:13 <EtnaRosso> Eduard_Munteanu, where are you from?
07:01:29 <Eduard_Munteanu> EtnaRosso: Romania
07:01:38 <EtnaRosso> ah nice
07:02:03 <EtnaRosso> I'm looking for information about MathML
07:02:30 <Eduard_Munteanu> Sure, if related to Haskell somehow. :)
07:03:17 <EtnaRosso> yes I found a library for parsing MathML, written in haskell
07:03:37 <EtnaRosso> cmathml3
07:04:17 <EtnaRosso> have you never heard about it?
07:05:17 <EtnaRosso> or about some other package for treating MathML
07:07:08 <Eduard_Munteanu> EtnaRosso: might be better to ask a more specific question, e.g. you had trouble doing X with it and don't know how to proceed
07:08:12 <circle> just gettibg back to haskell, I have af unction which takes has to spit out "1" on an input of 1. I have f 1 = 1. the function profile is f :: Num a => a -> a. I get an error. why?
07:09:01 <quchen> "An error"?
07:09:37 <circle> quchen
07:09:39 <circle>    Could not deduce (Eq a) arising from the literal `1'
07:09:39 <circle>     from the context (Num a)
07:10:46 <quchen> Num doesn't require Eq anymore in newer versions of GHC.
07:11:03 <circle> why would it ever require eq?
07:11:19 <quchen> Pattern matching against numbers is special that way.
07:11:29 <circle> hmm, alright
07:11:31 <quchen> 1 isn't a data constructor for integers
07:12:02 <quchen> It's basically syntactic sugar for a "fromInteger" expression.
07:12:41 <quchen> "f 1 = 1" is better thought of as "f n | n == fromIntegral 1 = 1
07:12:45 <quchen> "
07:13:18 <quchen> The reason for this oddity is that using number literals in patterns is just too convenient to change the behavior
07:13:39 <quchen> When stuff like this happens, it's in general a good idea to delete the type signature and ask GHCi what it infers
07:13:47 <quchen> @ty let f 1 = 1 in f
07:13:47 <kappabot> forall a a1. (Eq a, Num a, Num a1) => a -> a1
07:14:20 <quchen> You can also see a "Num a1" constraint here, that's because the right hand side of "f 1 = 1" isn't simply "1", but "fromIntegral 1".
07:14:52 <quchen> Integer literals like 1, 2 etc are always implicitly prefixed with a "fromInteger".
07:16:14 <quchen> This is really just a special case of integer literals. For example, True is a real data constructor for the Bool type. Rewriting your function for Bool won't require Eq (or any other unexpected things):
07:16:22 <quchen> :t let f True = True in f
07:16:22 <kappabot> Bool -> Bool
07:17:57 <notdan> How can I set a prompt in GHCi not to show me the list of modules but the information from the debugger? I didn't find the info in the user guide
07:18:59 * hackagebot llvm-tf 3.0.0.0.2 - Bindings to the LLVM compiler toolkit using type families.  http://hackage.haskell.org/package/llvm-tf-3.0.0.0.2 (HenningThielemann)
07:20:16 <quchen> notdan: As far as I know, %s is the only special symbol supported by :set prompt.
07:20:18 <quchen> cf http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-commands.html
07:20:30 <notdan> yeah
07:20:44 <notdan> but with %s my prompt is unreadable from all the modules I've imported :(
07:20:53 <notdan> yet I want to know some vital debugger information
07:33:59 * hackagebot hmemdb 0.3.1.1 - In-memory relational database  http://hackage.haskell.org/package/hmemdb-0.3.1.1 (MiguelMitrofanov)
07:44:23 <paullik> Hi. I'm fairly new to functional programming and haskell and I read lyah.com up to the Modules chapter, Data.Char section, and I implemented a Sieve of Eratosthenes, now can somebody please tell me if there is a better way to do it, a cleaner way maybe? Consider this homework, it isn't, but I want to learn.
07:44:29 <paullik> http://hpaste.org/88009
07:45:07 <paullik> Hmm, the implementation is pasted above, apparently the bot didn't notify the channel about a new paste
07:46:06 <paullik> What bothers me is that I used a list as the accumulator and the fact that I repeat [2..n] in the soe function
07:46:23 <armlesshobo> paullik: no worries about calling things multiple times
07:46:28 <armlesshobo> it only gets evaluated once
07:46:34 <armlesshobo> and the result is memoized
07:46:44 <paullik> yeah, haskell is lazy :)
07:46:50 <simpson> paullik: Somebody silenced hpaste because of spammers.
07:47:23 <simpson> Also, no, [2..n] right there does *not* get memoized, because it's not guaranteed to get CSE'd.
07:47:38 <paullik> CSE'd?
07:47:41 <paullik> english please?
07:47:46 <simpson> If you wanted to do that, then you really should consider ... where ns = [2 .. n]
07:48:07 <simpson> paullik: Common Subexpression Elimination. Compiler tool for isolating reuseable code automatically.
07:48:15 <simpson> Doesn't work in Haskell like people are used to in C.
07:48:54 <simpson> > nubBy (\x y -> gcd x y > 1) [2 ..]
07:48:56 <kappabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
07:49:39 <simpson> I don't remember where this adorable little expression comes from.
07:50:22 <paullik> ok, another thing I think is not optimal is that I don't think haskell can optimize out the call to mul 5 in soe 5 for example... in imperative programming I'd check if I;m at the end of the list, here I do the list difference anyway when in fact it isn;t needed
07:50:29 <paullik> what about that?
07:50:50 <paullik> omg, I need to look up gcd
07:51:08 <simpson> Well, you know what GCD is, right? Just the Greatest Common Denominator.
07:51:23 <paullik> oh
07:51:30 <paullik> abbreviation...
07:52:53 <paullik> ok, so what you posted there checks all elements  against all elements and removes the ones that have a GCD higher than 1 (meaning they can be divided)
07:53:03 <paullik> did I got it right?
07:53:08 <simpson> Right.
07:53:13 <simpson> @src nubBy
07:53:13 <kappabot> nubBy eq []             =  []
07:53:13 <kappabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
07:53:15 <paullik> so simple
07:53:36 <simpson> The trick is that it carefully does so in a way that is constantly yielding items that are in the list.
07:54:38 <simpson> Each time it yields a new item, it stacks up a filter that will remove items further down the list.
07:55:18 <simpson> So you could see here that 2 is immediately okay, but all multiples of two are filtered out. And then 3, but all of its multiples are filtered out...
07:56:13 <paullik> yeah...
07:58:15 <simpson> @src gcd
07:58:16 <kappabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
07:58:16 <kappabot> gcd x y = gcd' (abs x) (abs y)
07:58:16 <kappabot>    where gcd' a 0  =  a
07:58:16 <kappabot>          gcd' a b  =  gcd' b (a `rem` b)
07:58:24 <simpson> Oh my.
07:58:49 <simpson> > nubBy (\x y -> y `mod` x == 0) [2 ..]
07:58:50 <kappabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
07:58:59 <simpson> > nubBy (\x y -> y `mod` x \= 0) [2 ..]
07:59:00 <kappabot>   Not in scope: `\='
07:59:12 <simpson> > nubBy (\x y -> y `mod` x /= 0) [2 ..] -- Don't write code first thing in the morning!
07:59:16 <kappabot>   mueval-core: Time limit exceeded
07:59:26 <paullik> :))
08:02:06 <paullik> ok, so, simpson and armlesshobo thank you both for your help
08:02:17 <simpson> paullik: Sure.
08:02:36 <armlesshobo> paullik: the bill is in the mail :P
08:02:37 <armlesshobo> ;)
08:02:43 <paullik> :D
08:04:05 <paullik> also it's interesting how nubBy is implemented
08:04:07 <simpson> > nubBy (\x y -> y `mod` x == 0) [2 ..] -- Why doesn't this work?
08:04:08 <kappabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
08:05:27 <paullik> > nubBy (\x y -> x `mod` y == 0) [2 ..]
08:05:28 <kappabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
08:09:44 <acube> if I have a class Foo f a where foo :: f (Int -> a), is there a f for which an instance would have to method foo :: Int -> a ?
08:10:08 <Taneb> Identity-ish?
08:10:22 <acube> yes, but without that Identity wrapper
08:10:30 <Taneb> Then no
08:10:41 <simpson> paullik: Nice.
08:11:04 <simpson> paullik: I was just thinking that gcd doesn't appear very efficient; it uses Euclid's algorithm, which gets slower as numbers get larger.
08:11:30 <paullik> yep, I recognized that too
08:11:30 <acube> > gcd 13234 123413
08:11:31 <kappabot>   1
08:11:33 <acube> > gcd 13234 1234133
08:11:34 <kappabot>   1
08:11:50 <paullik> the algorithm, not the efficiency
08:11:57 <acube> > gcd 13234 (12324 * 2413435)
08:11:57 <kappabot>   26
08:13:28 <simpson> > let x = 91927341971928374981; y = 71234871 in x `gcd` y
08:13:29 <kappabot>   1
08:13:38 <simpson> > let x = 91927341971928374981; y = 71234871 in x `mod` y
08:13:38 <kappabot>   49376132
08:13:47 <simpson> Okay, not terrible.
08:13:58 * simpson notices that kappabot is a lot quicker than lambdabot
08:14:22 <geekosaur> how much of that is due to the linode?
08:14:26 <oio> > 1+2
08:14:27 <kappabot>   3
08:14:38 <simpson> geekosaur: Is it on the same Linode? I thought that somebody else was running it.
08:15:05 <geekosaur> (noting that it's compiling a program to do @run, and ghc is known to not like small VMs very much)
08:15:24 <simpson> Oh, it's compiling? I thought that it used hint.
08:15:27 <geekosaur> simpson, I have no idea. I don't know where kappabot lives, but lambdabot is/was on linode
08:15:34 <acube> @run
08:15:35 <kappabot>   not an expression: `'
08:15:45 <acube> lambdabot: @run 1+1
08:16:10 <geekosaur> that's still compiling and linking, just bytecode instead of machine code
08:16:30 <geekosaur> doesn't change the fact that compiling is fairly expensive
08:17:06 <geekosaur> and bytecode linking is, while not quite as heavyweight as gnu ld, still pretty heavy
08:18:04 <simpson> He ain't heavy, he's my bytecode.
08:18:15 <oio> groupBy (\x y -> y /= '\n') get this warning   Warning: Defined but not used: `x'
08:18:27 <oio> how can i get rid of it
08:18:45 <geekosaur> \_ y -> ...
08:19:13 <geekosaur> also that somehow does not sound like a sane use of groupBy
08:20:08 <simpson> oio: I think that you want `lines`.
08:20:15 <merijn> oio: \_ y
08:20:34 <simpson> > lines "Hi there!\nJust a bunch of lines.\nJust some lines passing through."
08:20:35 <kappabot>   ["Hi there!","Just a bunch of lines.","Just some lines passing through."]
08:20:49 <merijn> Incidentally that's the same as "groupBy (/= '\n')"
08:21:14 <merijn> > groupBy (/= '\n') "Hi there!\nJust a bunch of lines.\nJust some lines passing through."
08:21:15 <kappabot>   Couldn't match expected type `a0 -> GHC.Bool.Bool'
08:21:15 <kappabot>              with actual...
08:21:35 <merijn> ...
08:21:47 <merijn> :t groupBy (/= '\n')
08:21:48 <kappabot>     Couldn't match expected type `a0 -> Bool' with actual type `Bool'
08:21:48 <kappabot>     Expected type: a0 -> a0 -> Bool
08:21:48 <kappabot>       Actual type: a0 -> Bool
08:22:05 <merijn> oh, duh
08:22:12 <merijn> I'm failing at logic
08:22:31 <oio> loll
08:41:25 <Floris> how do i make an executable on my mac that someone else can run?
08:46:16 <Floris> it is so silent over here..
08:46:19 <Botje_> statically link your program
08:46:36 <Floris> how do i do that?
08:46:40 <glguy> Floris: the default is static linking, so you shouldn't have to do anything special
08:47:06 <Floris> but how do i compile ? ghc sourcefil -o name ???
08:47:15 <Botje_> Floris: that should be enough, yes.
08:47:43 <Floris> my friend has an hackingtosh and it won't work..
08:48:17 <Botje_> Floris: check with otool -L which libraries your binary needs.
08:48:35 <glguy> Floris: How did you install GHC
08:48:44 <glguy> MacPorts? Haskell Platform?
08:48:56 <Botje_> also, what do you mean by "it won't work"
08:49:12 <paullik> is there a way I can inspect the call stack when I run a function? I want to execute some code step by step
08:49:15 <Botje_> do you get a a linker error? illegal instruction? wrong architecture? crash?
08:49:33 <glguy> paullik: GHCi has a debugger with stepping
08:50:12 <paullik> how can I use it, where do I start, I'll figure out the rest
08:50:19 <glguy> http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/ghci-debugger.html
08:50:23 <plhk> Floris: ghc --make file.hs
08:50:29 <paullik> glguy, thanks
08:51:15 <Floris> glguy: i don't know, but it works on my machine
08:52:09 <Floris> Botje_: not he said the "cannot execute binary"
08:52:25 <glguy> Floris: lacking any details I don't know why it isn't working, but it is possible
08:53:05 <Floris> tool gave me :	/usr/lib/libiconv.2.dylib (compatibility version 7.0.0, current version 7.0.0)
08:53:06 <Floris> 	/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 169.3.0)
08:53:26 <Botje_> Floris: those are standard libraries. so it should run.
08:53:50 <Floris> can the problem be he uses an hackingtosh?
08:53:59 <geekosaur> possibly
08:54:42 <geekosaur> 'cannot execute binary file' if that is the actual error then it's something like trying to run a ppc executable on intel or vice versa, or maybe an x86_64 executable on a core 1-class cpu
08:56:16 <Floris> i have i7 and i don't know what he has but it is intel
08:56:25 <geekosaur> if this other user invokes file on your program, what output do they get?
09:00:32 <Floris> geekosaur: cannot execute binary
09:01:59 <geekosaur> er, you misundertood
09:02:41 <geekosaur> Floris: there is a command called "file", if you run it on some file (or list of files) it tells you what kind of file(s) the system thinks it is
09:03:11 <geekosaur> if they actually got "cannot execute binary file" from running the "file" command then they have a very broken hackintosh
09:06:11 <geekosaur> pyanfar:590418 Z$ file .bin/HsColour
09:06:11 <geekosaur> .bin/HsColour: Mach-O 64-bit x86_64 executable
09:06:19 <geekosaur> (example output)
09:07:53 <Floris> geekosaur: ah i will ask
09:09:00 <Floris> geekosaur: at my computer it gives: Mach-O 64-bit executable x86_64
09:09:01 <Floris> i have not heard jet wat het gets
09:14:02 <Floris> and who do i make a windows executable?
09:14:21 <glguy> Floris: You do the same thing, but on a Windows computer
09:14:53 <Floris> glguy: so you can't make an cross platform executable?
09:15:13 <Floris> hm. someone is called cross..
09:15:33 <geekosaur> -fllvm can do limited cross platform
09:15:46 <geekosaur> I doubt it includes windows though
09:15:55 <glguy> limited enough that Floris can safely ignore it
09:16:15 <Floris> huh?
09:18:13 <geekosaur> if that went over your head, you have no business trying to cross-compile anyway...
09:19:26 <Floris> geekosaur: oh oke
09:21:30 <geekosaur> cross compiling is far from trivial even when the target is the same OS as the source; it's a nightmare when the target is some other OS, especially unixlike <-> windows
09:31:50 <acube> @src [] traverse
09:31:50 <kappabot> Source not found. My mind is going. I can feel it.
09:36:34 <Kaidelong> perhaps I'm just paranoid but I don't trust pngload or JuicyPixels to be able to handle indexed PNGs, based on their documentation
09:51:12 <osa1> let's say I have a `func :: Either MyError ReturnType`, I need a function for this to be used in `MonadError MyError`, how can I do that?
09:52:09 <fizbin> Is there an Error instance for MyError ?
09:52:19 <paullik> Hi. Again I have trouble understanding in which call to nubBy (\x y -> x `mod` y == 0) [2,4] is 4 ruled out
09:52:24 <paullik> according to:
09:52:27 <paullik> @src nubBy
09:52:27 <kappabot> nubBy eq []             =  []
09:52:27 <kappabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
09:52:39 <osa1> fizbin: yes
09:52:56 <glguy> :t either throwError return
09:52:57 <kappabot> forall a (m :: * -> *) a1. MonadError a m => Either a a1 -> m a1
09:53:12 <dmwit> > nubBy (\x y -> x `mod` y == 0) [2, 4]
09:53:13 <kappabot>   [2]
09:53:20 <glguy> :m
09:53:22 <paullik> so according to that: 2:nubBy eq (... [4]) should be: 2:[4]
09:53:27 <fizbin> osa1: Then (Either MyError) already has a MonadError instance.
09:53:29 <paullik> wich translated back to [2,4]
09:53:38 <paullik> which translates*
09:53:44 <glguy> osa1: the code above was for you
09:53:56 <dmwit> > not (\x y -> 2 `mod` 4 == 0)
09:53:57 <kappabot>   The lambda expression `\ x y
09:53:58 <kappabot>                           -> 2 `GHC.Real.mod` ...
09:54:06 <dmwit> > not (2 `mod` 4 == 0)
09:54:06 <kappabot>   True
09:54:14 <osa1> glguy: thanks
09:54:17 <paullik> I tried running it on paper and with the debugger, I cannot get it
09:54:29 <dmwit> paullik: I, too, am surprised.
09:54:30 <FreeFull> What does the | in class Monad m => MonadError e m | m -> e  mean?
09:54:47 <elliott> paullik: sounds like a bug
09:55:05 <elliott> though, actually, maybe the predicate you pass to nubBy violates its precondition
09:55:09 <dmwit> paullik: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#nubBy gives the definition GHC actually uses, if you're interested
09:56:11 <fizbin> osa1: So you should be able to just throwError and catchError already. To chain it into something else, you can do what glguy suggested or you can do something like:
09:56:31 <Adeon> FreeFull: it's a functional dependency. it says for each m, there is only one e
09:56:56 <fizbin> retval <- func `catchError` throwError
09:57:01 <paullik> elliott, I don't understand what you just said, I know what the predicate is, but what's the precondition?
09:57:22 <elliott> paullik: the argument to nubBy has to be an equivalence relation
09:57:29 <glguy> paullik: nubBy takes an equality predicate and you've given it something that isn't an equivalence relation
09:57:45 <glguy> > 4 `mod` 2 == 0
09:57:46 <kappabot>   True
09:57:50 <elliott> though all the other functions I know of work "the expected way" in GHC even if you violate that precondition
09:57:53 <elliott> so this may still be considered a bug
09:57:56 <dmwit> paullik: I will also note that the Haskell Report does not specify the behavior of nubBy very specifically.
09:57:59 <elliott> even if your program is incorrect according to the Report
09:58:11 <dmwit> I don't think this behavior is outlawed by the Report.
09:58:26 <elliott> I mean, what is outlawed is paullik's expression
09:58:33 <elliott> (and hence the implementation can do whatever, presumably)
09:58:34 <fizbin> > nubBy (\x y -> x `mod` y == 0) [2,4]
09:58:35 <kappabot>   [2]
09:58:52 <glguy> 4 `mod` 2 == 0, so 4 is ruled out
09:58:52 <fizbin> > nubBy (\x y -> x `mod` y == 0) [2,3,4,5,6,7,8,9]
09:58:53 <kappabot>   [2,3,5,7]
09:58:55 <acube> > 2 `mod` 2
09:58:56 <kappabot>   0
09:59:32 <dmwit> The H98 report is much more specific about nubBy's behavior.
09:59:51 <dmwit> So if this function still misbehaves with -XHaskell98, then it is a bug in GHC. =)
09:59:58 <fizbin> > (\x y -> x `mod` y == 0) 2 4
09:59:58 <kappabot>   False
10:00:14 <fizbin> > (\x y -> x `mod` y == 0) 4 2
10:00:15 <kappabot>   True
10:00:21 <fizbin> @src nubBy
10:00:21 <kappabot> nubBy eq []             =  []
10:00:21 <kappabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
10:00:28 <glguy> dmwit: the H98 says "the predicate is assumed to define an equivalence"
10:00:59 <glguy> and only that " the function nub could be defined as follows"
10:01:01 <fizbin> > nubBy (\y x -> x `mod` y == 0) [2,4]
10:01:02 <kappabot>   [2,4]
10:01:04 <paullik> so what I understand from this, is that using a predicate that is not commutative in nubBy is wrong?
10:01:07 <dmwit> glguy: It does say that; however, it also gives source for nubBy.
10:01:17 <glguy> dmwit: and it says that that is a possible implementation
10:01:37 <elliott> dmwit: you mean H2010 got less specific about nubBy?
10:01:48 <dmwit> glguy: Oh, does it? I guess I missed that.
10:01:51 <dmwit> elliott: I do mean that.
10:02:03 <elliott> bizarre
10:02:07 <acube> > nubBy (\y x -> x `mod` y == 0) [2,4] -- I don't understand this
10:02:08 <kappabot>   [2,4]
10:02:09 <fizbin> paullik: I think it's not so much "wrong" as "implementation defined", and that the function's arguments might be called in any direction.
10:02:49 <paullik> fizbin, yeah, in this case they are called reversed, otherwise I cannot explain the behaviour...
10:02:50 <glguy> and it should be transitive too, there's no guarantee that the first element of the set will be used for comparisons for the set
10:03:41 <fizbin> let nubBy' eq [] = []; nubBy' eq (x:xs) = x : nubBy' eq (filter (\y -> not (eq x y)) xs) in nubBy' (\x y -> x `mod` y == 0) [2,4]
10:03:46 <Floris> what is the different between "$ghc --Make file.sh" and "$ghc main.sh -o name"?
10:03:52 <dmwit> And reflexive! The implementation might choose to compare the first element of the list with itself before keeping it.
10:04:11 <fizbin> > let nubBy' eq [] = []; nubBy' eq (x:xs) = x : nubBy' eq (filter (\y -> not (eq x y)) xs) in nubBy' (\x y -> x `mod` y == 0) [2,4]
10:04:12 <kappabot>   [2,4]
10:04:19 <dmwit> Floris: Starting in GHC 7, --make is default. The "-o name" picks the name of the executable to generate.
10:04:25 <fizbin> nubBy (\x y -> x `mod` y == 0) [2,4]
10:04:32 <fizbin> > nubBy (\x y -> x `mod` y == 0) [2,4]
10:04:33 <kappabot>   [2]
10:04:47 <fizbin> Well, that settles it. @src lies.
10:04:49 <Floris> dmwit: so the output is the same?
10:05:00 <glguy> dmwit: perhaps it could alternate the order of the arguments at each use for good measure
10:05:09 <dmwit> Floris: Also, you should be ashamed of yourself, naming your Haskell files with a .sh extension. =P
10:05:29 <dmwit> glguy: My personal implementation consults an oracle (it emails me!) before deciding which comparisons to do.
10:05:45 <Floris> dmwit: ah that was a typing error :(
10:05:52 <dmwit> Floris: I figured.
10:06:10 <fizbin> > let nubBy' eq [] = []; nubBy' eq (x:xs) = x : nubBy' eq (filter (\y -> not (eq x y)) xs) in (nubBy' (\x y -> x `mod` y == 0) [2,4], nubBy (\x y -> x `mod` y == 0) [2,4])
10:06:11 <kappabot>   ([2,4],[2])
10:06:16 <dmwit> Floris: As for whether the output is the same, I'm not sure. But why not ask diff instead of me?
10:06:22 <elliott> glguy: it could even check an element against itself and then return [undefined,xs!!0,undefined,error "boom",xs!!7] if the result is False, presumably
10:06:44 <elliott> I wonder if the compiler is allowed to check your predicate's equivalenceness at compile time and error out if it can prove you've violated the precondition
10:07:14 <Floris> dmwit: i asked it to everybody
10:07:33 <geekosaur> fizbin, it's not at all unusual for ghc to use a different definition from that of the standard Prelude
10:07:34 <dmwit> Floris: Incorrect. You asked it to me. Just look back! =)
10:07:38 <fizbin> @djinn (a1 -> a2 -> a3) -> (a1 -> a2 -> b3) -> a1 -> a2 -> (a3, b3)
10:07:38 <kappabot> No output from Djinn; installed?
10:07:54 <dmwit> ?get-shachaf
10:07:54 <kappabot> Unknown command, try @list
10:08:21 <FreeFull> lambdabot, there is an impostor!
10:08:23 <glguy> Don't hassle him about kappabot , we're lucky to have any level of functionality while lambdabot is on the fritz
10:08:29 <Floris> dmwit: ah that was because you answerd me ;)
10:08:31 <dmwit> fizbin: (...and I linked the actual source GHC uses not long after the question was asked.)
10:08:35 <FreeFull> > 3
10:08:36 <kappabot>   3
10:09:13 <dmwit> glguy: Yep, I intentionally chose something which I figured would not highlight him.
10:09:23 <Floris> how hard jobs can kappabot handle?
10:09:34 <dmwit> ?help eval
10:09:34 <kappabot> eval. Do nothing (perversely)
10:09:38 <dmwit> ?help run
10:09:38 <kappabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
10:09:45 <FreeFull> :t _1
10:09:46 <kappabot> Not in scope: `_1'
10:09:51 <paullik> fizbin, yeah, now that I look closer on the code dmwit linked there is a line: elem_by eq y (x:xs)     =  y `eq` x || elem_by eq y xs
10:09:52 <FreeFull> Seems it doesn't have lens
10:10:39 <paullik> so why the two implementations with swapped arguments for eq?
10:10:45 <fizbin> I'll note though that in that case the code comments lie.
10:11:11 <fizbin> The code comments clearly state "Note that we keep the call to `eq` with arguments in the same order as in the reference implementation"
10:11:16 <glguy> paullik: by using both argument orders you ensure that people don't start to expect one behavior
10:11:16 <newb_> I have a problem with hlint, it is not showing any suggestions or errors on files that have very obvious error
10:11:20 <fizbin> And yet they don't.
10:11:23 <elliott> that is a bug then
10:11:28 <elliott> whether in the comments or the code
10:12:19 * dmwit nominates paullik to complain on GHC's Trac
10:12:23 <paullik> wtf is the reference implementation? the one where USE_REPORT_PRELUDE is defined?
10:12:28 <acube> Are there multi parameter type families?
10:12:37 <dmwit> acube: yes
10:12:47 <shachaf> hi dmwit
10:12:48 <fizbin> acube: with the appropriate -X extension, yes.
10:12:49 <shachaf> No djinn.
10:13:03 <dmwit> k
10:13:27 <dmwit> (Multi-parameter type families don't require any more extensions than single-parameter type families.)
10:13:36 <shachaf> It's installed, so I don't know what's wrong.
10:13:42 * dmwit shrugs
10:13:42 <shachaf> But it would be a bunch of trouble figuring it out.
10:13:48 <dmwit> right
10:14:54 <dmwit> Should I try turning djinn on in goodfellow?
10:16:50 <acube> < (1,2) ^. _1
10:16:54 <goodfellow>   mueval-core: Time limit exceeded
10:16:58 <acube> :/
10:17:37 <acube> type family i o :: * gives Malformed head of type or class declaration: i o. What's the correct syntax?
10:17:52 <acube> Ah, I figured: I forgot the type family name
10:18:03 <shachaf> dmwit: Gopher it. Did you get a prefix working?
10:18:23 <dmwit> < (1,2) ^. _1
10:18:27 <goodfellow>   mueval-core: Time limit exceeded
10:18:33 <dmwit> shachaf: Don't recall. If I do anything, it'll be tonight.
10:18:37 <dmwit> < (1, 2) ^. _1
10:18:39 <goodfellow>   1
10:18:48 * dmwit pats goodfellow's head
10:18:53 <dmwit> takes a little while to warm up
10:19:08 <acube> > (1,2) ^. _1
10:19:09 <kappabot>   Not in scope: `_1'Not in scope: `^.'
10:19:26 <paullik> hmm, ok I'll create a bug report, but I'd like to know where the reference implementation for nubBy is so I can be clear in the bug report
10:19:42 <dmwit> Yes, the USE_REPORT_PRELUDE code is the reference implementation.
10:19:48 <paullik> :)
10:19:50 <paullik> ok, thanks
10:19:52 <dmwit> It is also available in the H98 report, in the section on the List module.
10:20:32 <paullik> http://www.haskell.org/onlinereport/list.html this one?
10:24:15 <shachaf> I hope lambdabot gets fixed or we decide on something.
10:24:35 <shachaf> kappabot was meant to be very temporary
10:26:20 <elliott> I thought lispy / Cale were working on \bot
10:32:49 <otters> what's wrong with lambdabot
10:33:30 <fizbin> Ops should add a "lambdabot is sick" announcement to the channel msg.
10:38:53 --- mode: ChanServ set +o byorgey
10:39:24 --- topic: set to '["lambdabot is sick =(","Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.3 http://v.gd/wie445 ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D ","If Hackage is down,try: http://hdiff.luite.com "]' by byorgey
10:39:30 --- mode: byorgey set -o byorgey
10:39:35 <mel-> oh my
10:39:52 <mel-> i hope he/she is getting better soon!
10:40:09 <elliott> byorgey: did you know lambdabot has comamnds that automatically maintain a topic in the list-of-strings format #haskell has? unfortunately it would only work if lambdabot had ops.
10:40:20 <byorgey> elliott: I was aware of that, yes
10:40:24 <elliott> obscure lambdabot trivia of the day
10:40:35 <byorgey> it also doesn't work very well when the thing you want to add is an announcement that lambdabot does not work.
10:40:47 <geekosaur> :)
10:40:49 <elliott> yes. it should be fixed so that it works even when it's broken.
10:41:03 <byorgey> that would be most excellent.
10:41:19 <byorgey> how about if lambdabot auto-detects when it is broken and adds it to the topic.
10:41:26 * geekosaur wonders if there isn't some chanserv access level that is less than ops but allows changing topic
10:41:49 <elliott> lambdabot having ops would be exciting. suddenly the sandboxing gets that much more interesting
10:42:03 <Hafydd> Hahah.
10:43:20 <geekosaur> it's already pretty interesting unless someone hacked checking with nickserv into it
10:49:12 <doomlord> can any of haskell's polymorphic mechanisms make a tuple accesor that is independant of the tuple size, e.g. "mySecond (a,b,c)= c" "mySecond (a,b,c,d) = b"  etc..
10:49:29 <simon> doomlord, you'd need templates.
10:49:32 <mauke> inb4 lenses
10:49:34 <bitonic> doomlord: yes, see lenses
10:49:36 <otters> doomlord: typeclasses
10:49:38 <bitonic> awwww mauke
10:50:05 <fizruk> hi! is there a library with (:+:) from 'Data types a la carte' paper?
10:50:15 <paullik> I created the bug report: http://hackage.haskell.org/trac/ghc/ticket/7913
10:50:23 <simon> or typeclasses up to some supported tuple size.
10:50:41 <glguy> fizruk: I'm going to guess Data.Functor.Coproduct without remember exactly what :+: was
10:50:53 <doomlord> does that mean you'd make a typeclass "MySecond" with a method "mySecond", then instance that for every type you want it to work on
10:51:04 <simon> doomlord, yes.
10:52:10 <simon> alternatively I'd just make fst', snd', thrd' and use them for my three-tuples if I had a lot of those.
10:53:20 <fizruk> glguy: thanks! and there was also a typeclass (kind of f :<: g) to state that f is somewhere in g, is there such a type class
10:54:38 <Hafydd> thrd?
10:54:40 <fizruk> glguy: that typeclass has an inject method which automatically chooses left or right
10:54:44 <Hafydd> Don't you think there's something wrong with that?
10:54:51 <shergill> i'm trying to understand the code at http://joyoftypes.blogspot.ca/2012/08/generalizednewtypederiving-is.html. in the second example (with GADTs) am i correct in believing that the source of the problem is that in the line 'newtype Tagged a b = Tagged b deriving IsoUnit' the typechecker doesn't infer the constraint 'IsoUnit b'?
10:55:10 <taylanub> Just stumbled upon this on Wikipedia and it seems like the phrase "strong typing" should be replaced with "static typing", can someone confirm ?  "A restriction of System F known as "HindleyMilner", or simply "HM", does have an easy type inference algorithm and is used for many strongly typed functional programming languages such as Haskell 98 and ML."
10:56:26 <fizruk> taylanub: strong static? no expert :)
10:57:00 <taylanub> At least in Wikipedia's terminology (and the text "strongly typed" does link to the Wikipedia page on "strong typing"), strong/weak is orthogonal to static/dynamic.  E.g. C is static and weak, Scheme is dynamic but strong ...
10:57:01 <lightquake> taylanub: haskell's type system is *definitely* static, but i'd say it's strong as well
10:57:37 <elliott> taylanub: how about "and is used in Haskell and ML"?
10:57:40 <taylanub> Yeah, it's static and strong from my understanding, but it seems to me like that isn't relevant in that article ..  (Weak typing seems mathematically totally dirty anyway, isn't it ?)
10:57:49 <elliott> nobody is really helped by these terms, because nobody knows what they mean
10:57:57 <taylanub> Yeah. :\
10:58:47 <taylanub> I find Wikipedia's definitions sensible, but some people (credible ones too) seem to disagree.
10:59:21 <glguy> fizruk: You'll probably be interested in this package http://hackage.haskell.org/package/syntactic-1.6.1
10:59:26 <shergill> http://hpaste.org/88022
11:00:51 <shergill> in the code above , am i correct in believing that the source of the problem is that in the line 'newtype Tagged a b = Tagged b deriving IsoUnit' the typechecker doesn't infer the constraint 'IsoUnit b'?
11:03:11 <fizruk> glguy: thanks for the link, can be helpful!
11:06:26 <byorgey> shergill: no, it infers a precondition of IsoUnit b.  That's how generalized newtype deriving works.
11:07:12 <byorgey> shergill: the problem is probably that it does not know how to automatically convert from e.g.  SameType b c   to  SameType (Tagged a b) c  .
11:07:52 <byorgey> indeed, I don't even know how to convert between those.  It does not look possible.
11:08:09 <byorgey> the whole point is that a newtype gives you a *different* type.
11:10:15 <ptek> Sorry for the dumb question, but when I am trying to do this `split '\n' "a\nb\nc"` as in the example http://hackage.haskell.org/packages/archive/bytestring/0.10.2.0/doc/html/Data-ByteString-Lazy.html#g:14 I get an error saying: Couldn't match expected type `GHC.Word.Word8' with actual type `Char'
11:10:21 <ptek> is there any trick to it?
11:11:11 <byorgey> ptek: the trick is that if you want to use a string literal like "a\nb\nc" as a ByteString, you have to enable the OverloadedStrings extension
11:11:15 <shergill> byorgey: hmm when i do ':t Tagged 2' i get 'Tagged 2 :: Num b => Tagged a b' the 'IsoUnit b' seems to be missing
11:11:35 <geekosaur> um? that looks like it wants ord for the Char literal actually?
11:11:40 <ptek> byorgey: I did that actually. It complains on the '\n' literal
11:11:48 <byorgey> oh, you're right, my bad
11:12:12 <shergill> byorgey: or rather if what you say is true, it shouldn't be possible to create 'Tagged 2' or am i misunderstanding something?
11:12:13 <byorgey> I don't know of any way to have '\n' be interpreted as a Word8 automatically
11:12:32 <byorgey> maybe the example is just hand-wavy and not actual code
11:13:00 <ptek> byorgey: i see thats a pity :(
11:13:26 <acube> http://hackage.haskell.org/packages/archive/bytestring/0.10.2.0/doc/html/Data-ByteString-Char8.html#g:13 There is also Data.ByteString.Char8
11:13:59 <byorgey> shergill: you are misunderstanding.  Simply using the Tagged constructor never incurs an IsoUnit constraint, whether you have a derived IsoUnit instance or not.
11:14:20 <ptek> acube: Char8 is really problematic when working with unicode I will probably have to use Data.Text in the end...
11:15:07 <byorgey> shergill: 'deriving IsoUnit' just means that it will try to derive an instance of the form  'instance IsoUnit b => IsoUnit (Tagged a b)'
11:15:23 <shergill> byorgey: ah ok, thanks
11:15:25 <byorgey> and I don't think it is possible to write such an instance
11:16:31 <acube> ptek: But doesn't Word8 have to same problems?
11:16:59 <Eelis> if i have    x = y :: Double   at toplevel in a module, will ghc attempt to compute y if it doesn't use things like unsafePerformIO ?
11:17:14 <byorgey> ptek: if you are working with Unicode text, you shouldn't be using ByteString.
11:17:36 <byorgey> it is not intended for working with Unicode text, unless you want to manage all the encoding etc. yourself.
11:18:25 <ptek> byorgey, yes. Makes sense as I think of it now
11:19:19 <byorgey> shergill: oh, I didn't notice the context of that post!  So you *can* derive the instance but it actually leads to breakage.  Makes sense.
11:19:41 <shergill> right
11:20:01 <byorgey> shergill: this whole time I just thought it was some code you coudln't get to compile
11:20:48 <byorgey> anyway, the source of the problem is that it implements the instance basically with an 'unsafeCoerce', and doesn't take into account that the parameter of Tagged is not used parametrically
11:20:52 <shergill> ah no. sorry, when i posted earlier i linked to the original post/context
11:21:04 <byorgey> shergill: right, so you did, I just missed it =P
11:22:33 <shergill> byorgey: so it's the use of unsafeCoerce within GeneralizedNewtypeDeriving which is to blame, correct?
11:23:23 <byorgey> shergill: well... the use of unsafeCoerce would be fine, IF there were some restrictions in place on what sorts of things you could use GND with
11:24:11 <byorgey> so in one sense you could say the unsafeCoerce is to blame, but in another sense that is a very unsatisfying answer
11:24:23 <byorgey> it would be like saying cars are to blame for accidents, so we should just get rid of cars
11:29:33 <shergill> byorgey: true. i guess i said that coz it feels like you shouldn't have to need unsafeCoerce to implement GND, but i'm still trying to get a better sense of what's going on here and i may be mistaken
11:29:53 <DMcGill> So I've downloaded the precompiled SFML and CSFML and am trying to install HSFML. The error I get is "missing (or bad) header file: SFML/System/ClockWrapper.h". In my include dir is "SFML/System/Clock.h". Is this just a verson mismatch or something?
11:30:36 <lambdazerocool> Does anyone have experience with the conduit library? I'm having trouble finding docs or examples for using the monad instance of Sink to combine multiple Sinks together.
11:31:45 <Clint> lambdazerocool: what do you mean by "combine"
11:32:36 <lambdazerocool> Clint: that's exactly what I'm trying to find - what I'd like to do is combine multiple socket sinks on a server into a single sink so i can effectively do a multicast. i'm not sure if this is the right avenue for my goals.
11:33:14 <Clint> so you want to feed both sinks the same data at the same time
11:33:22 <byorgey> shergill: right, you don't need unsafeCoerce to implement GND.
11:33:26 <lambdazerocool> Clint: correct.
11:33:58 <byorgey> shergill: it's just that in all cases that should work, you end up converting between values with different types but whose runtime representations are guaranteed to be exactly identical
11:34:41 <byorgey> shergill: so it's very useful (and efficient) to be able to use unsafeCoerce to do that conversion, instead of having to traverse some entire structure (which is difficult to optimize away)
11:35:29 <byorgey> but if we did know how to easily optimize away such identity traversals that would be another way to solve it, since writing out the traversal explicitly would not type check in cases like the example you pasted
11:36:14 <lambdazerocool> Clint: the implementation idea I had before (i iz network programs nub) was to have a TVar containing a list of all sockets (as handles), and mapM_ hPutStrLn it through
11:36:50 <lambdazerocool> Clint: where here a TVar is used because different threads will want to add or remove sockets
11:38:07 <Clint> lambdazerocool: have you tried zipSinks?
11:39:14 * hackagebot heist 0.12.0 - An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.12.0 (DougBeardsley)
11:39:50 <lambdazerocool> Clint: i have not - zipSinks looks good - with one minor issue - what happens if one of my socket sinks closes? will the combined sink error out when i try to dump data down it?
11:42:31 <lambdazerocool> Clint: i believe i should be fine - from a comment in the source: "The new sink will complete when both input sinks have
11:42:45 <lambdazerocool> completed."
11:42:54 <lambdazerocool> Clint: thanks!
11:44:14 * hackagebot slice-cpp-gen 0.2.1.0 - Generate C++ skeletons from slice files  http://hackage.haskell.org/package/slice-cpp-gen-0.2.1.0 (PaulKoerbitz)
11:44:17 * hackagebot snap 0.12.0 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.12.0 (DougBeardsley)
11:54:15 * hackagebot charade 0.1 - Rapid prototyping websites with Snap and Heist  http://hackage.haskell.org/package/charade-0.1 (DougBeardsley)
11:55:21 <lambdazerocool> Also, if I'm just running a server where I have a few people persistently connected, sending an occasional message to the server, and the server broadcasts responses to everyone, is going through the hoops to adapt everything to the conduit library worth it? it seems rather simple with just straight up sockets
11:55:44 <mstksg> \join #mstksg
11:55:53 <luite> > (realToFrac (0/0::Double)) :: Double
11:55:54 <kappabot>   -Infinity
11:55:58 <luite> why is this -Infinity?
11:56:37 <shachaf> Presumably because Rational can't represent NaN.
11:56:41 <supki> > toRational (0/0)
11:56:41 <kappabot>   (-2696539702293473861593957786183537100426965468413459859101451217365990137...
11:57:31 <fizbin> :t realToFrac
11:57:33 <kappabot> forall a b. (Fractional b, Real a) => a -> b
11:57:48 <luite> oh hm, right, default implementdation is fromRational . toRational or something
11:57:51 <shachaf> @src realToFrac
11:57:51 <kappabot> realToFrac = fromRational . toRational
11:58:06 <shachaf> It's not the "default" implementation. It's the only implementation.
11:58:10 <shachaf> It's not a method.
11:58:19 <fizbin> > (0/0::Double)
11:58:19 <kappabot>   NaN
11:58:32 <luite> i know, but it's sort of default only if no rules fire :)
11:59:53 <luite> if you compile with optimization, you get NaN out
12:00:15 <luite> (just checked to be sure)
12:00:44 <shachaf> Oh.
12:00:50 <shachaf> That's kind of terrible.
12:02:46 <envogue> can someone give me a good example of a livelock situation?
12:02:59 <envogue> a programming example and not 2 people stuck in a corridor
12:03:37 <zomg> 2 bits stuck in a 1 bit wide intertube?
12:03:38 <zomg> ;)
12:03:53 <luite> also GHC apparently has both positive and negative NaN values that can be distinguished by decoding the double
12:04:15 * hackagebot snaplet-persistent 0.2 - persistent snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-persistent-0.2 (DougBeardsley)
12:04:26 <luite> > (decodeFloat (0/0::Double), decodeFloat (-0/0::Double))
12:04:26 <kappabot>   ((-6755399441055744,972),(6755399441055744,972))
12:05:57 <chrisdone> any emacs users in the house?
12:06:08 <acube> > decodeFloat (-0 :: Double)
12:06:09 <kappabot>   (0,0)
12:06:09 <adimit> yes here :-)
12:06:12 <acube> > decodeFloat (0 :: Double)
12:06:12 <kappabot>   (0,0)
12:06:31 <doomlord> i'm an emacs user, bbut haent used haskell mode in emacs
12:06:46 <envogue> chrisdone: i can perhaps help with simple things
12:07:09 <adimit> haskell-mode needs some work :-\ I can't get it to run.
12:07:18 <luite> acube: it's more common that you can tell 0 and -0 apart
12:07:49 <luite> > (1 / -0, 1 / 0) :: (Double,Double)
12:07:50 <kappabot>   Precedence parsing error
12:07:50 <kappabot>      cannot mix `GHC.Real./' [infixl 7] and prefix...
12:07:57 <luite> > (1 / (-0), 1 / 0) :: (Double,Double)
12:07:58 <kappabot>   (-Infinity,Infinity)
12:08:46 <acube> > (decodeFloat ( (-0) / (-0)))
12:08:47 <kappabot>   (-6755399441055744,972)
12:08:50 <chrisdone> envogue: i think we emacs using haskellers should get together regularly and share awesomeness
12:08:59 <chrisdone> adimit: what doesn't work?
12:09:15 * hackagebot haxr 3000.9.2.1 - XML-RPC client and server library.  http://hackage.haskell.org/package/haxr-3000.9.2.1 (BrentYorgey)
12:09:18 * acube uses hdevtools with flycheck
12:09:19 <adimit> chrisdone: interactive mode. see my bug report on the issue tracker.
12:09:24 <luite> oh i also use emacs of course
12:09:30 <doomlord> i'm curious to know if theres a text editor written in haskel..
12:09:37 <adimit> chrisdone: I couldn't agree more on getting together an sharing awesome stuff.
12:09:39 <chrisdone> yi is an editor written in haskell
12:09:44 <acube> Are you using ghc-mod or hdevtools (or neither?)
12:09:46 <chrisdone> adimit: i'll look
12:09:53 <adimit> doomlord: yi, but it's somewhat experimental.
12:10:06 <adimit> chrisdone: 144. https://github.com/haskell/haskell-mode/issues/144
12:10:34 <doomlord> anyone written a 3d modeller in it? (... isn't wings3d in erlang which is also quite functional..)
12:10:58 <chrisdone> adimit: in that demo, where's your .cabal file?
12:11:12 <adimit> chrisdone: that'd be the root directory, so ~/var/tmp/test
12:11:37 <chrisdone> acube: i've tried ghc-mod, had trouble getting hsdevtools to accept a package conf for cabal-dev, but i might try it again with hsenv
12:11:59 <chrisdone> adimit: ok so that's what you need to enter for the Cabal dir prompt
12:12:19 <adimit> chrisdone: that's what I do enter :-(
12:12:36 <chrisdone> adimit: from your issue it says ~/var/tmp/test/src/Data ?
12:13:21 <adimit> chrisdone: it doesn't matter either way. I just tried it again.
12:13:22 <doomlord> i seem to remember wings3d uses some sort of pure-functional datastructure tracking modifications to do its  undo-system... does haskell already have somethign like that
12:13:23 <chrisdone> acube: i might've heard from johnw that hsdevtools is faster than ghc-mod
12:13:51 <chrisdone> adimit: so you set ~/project as cabal and ~/project/src as the current dir?
12:13:56 <adimit> chrisdone: yes.
12:13:59 <chrisdone> adimit: what's the output?
12:14:37 <adimit> chrisdone: same as on the issue: Couldn't find module Data.Test1, because it's hidden etc. I've reproduced the full log there.
12:14:48 <chrisdone> adimit: you get that immediately or when loading a file?
12:14:56 <adimit> yes.
12:15:10 <chrisdone> which?
12:15:19 <adimit> Data/Test2.hs
12:15:30 <adimit> (I tried loading the other first, but same result.)
12:15:54 <acube> chrisdone: I use hdevtools (because as you said , ghc-mod is a lot slower), but with a very ugly helper script (that counts the number of dots in the module name and goes up so many directories before invoking hdevtools), and it also some thinks that don't work nicely (for example, when I have a seperate tests/ directory, it doesn't find the includes from the src/ dir)
12:16:38 <chrisdone> adimit: i think in your log i can see it's cd'ing again to the wrong place. can you check in your current version? if the load command is like :load Data/Test2.hs, that's good. if it's an absolute path, it probably cd'd to the wrong place
12:17:15 <chrisdone> acube: can you specify -i to hsdevtools? iirc there's a -ghc-opt or similar command
12:17:18 <shergill> chrisdone: an emacser here
12:17:36 <chrisdone> hey! =)
12:17:50 <shergill> :)
12:18:54 <chrisdone> adimit: i wrote this interactive mode, so i can help resolve this if you let me know what you're seeing
12:19:20 <adimit> chrisdone: trying out a few things right now. Thanks very much for your help :-) (and for interactive-mode, it's helpful when it does work)
12:19:26 <acube> chrisdone: How would I customize that on a per-project basis?
12:19:35 <shachaf> chrisdone: I +qed hpaste again, for what it's worth.
12:20:29 <chrisdone> acube: without writing any elisp? i don't know of a way
12:20:53 <chrisdone> shachaf: yeah best to keep it +qed until i've added a nick filter
12:21:00 <adimit> chrisdone: so in my current version I removed the /src/, since I figured that might be causing trouble. Prompted cabal dir is now: test/Data/ (which I correct to test/), and current dir is test/. I accept both defaults, no dice. Log say :cd  test/Data/ with an absolute path.
12:21:16 <acube> is inferior-haskell-load-file from haskell-mode?
12:21:36 <micol> hi!
12:21:41 <micol> !list
12:21:41 <monochrom> micol: http://hackage.haskell.org/packages/archive/pkg-list.html
12:21:43 <adimit> chrisdone: http://hpaste.org/88026 
12:21:45 <chrisdone> adimit: it seems a familiar bug (need to fix). you can run M-x haskell-process-cd and enter the right path. it *should* stick after that
12:21:51 <chrisdone> acube: yeah that's haskell-mode
12:22:11 <chrisdone> monochrom: haha
12:22:20 <adimit> chrisdone: thanks, that did indeed fix the problem.
12:22:33 <joeyh> my, the lack of setEnv on Windows is annoying..
12:22:55 <chrisdone> adimit: okies. yeah, gotta fix this. that first prompt seems to just ignore what you say
12:23:25 <monochrom> \/
12:23:26 <neurocyte> joeyh, hi! did you try building an android cross-compiler with TH support yet?
12:23:39 <joeyh> neurocyte: it sounds stunning, but I am in Windows world at the moment
12:23:41 <chrisdone> monochrom: looks like a death metaller
12:23:47 <adimit> chrisdone: well, I'm glad it's working again :-)
12:24:11 <adimit> chrisdone: I've been wanting to hack up some features for haskell-interactive-mode anyway (ESS-like search history from input for example.)
12:24:12 <joeyh> I plan to rebuild everything and hopefully lose my hacks eventually
12:24:12 <neurocyte> joeyh, poor you
12:24:19 <adimit> I'll see if I can get to some hacking this weekend.
12:24:36 <chrisdone> adimit: yeah we need some history magic. what's ess?
12:25:07 <adimit> chrisdone: emacs speaks statistics. It's an R/S environment for emacs, which is pretty dandy and has a very nice REPL interaction.
12:25:15 <joeyh> neurocyte: how did you make it work?
12:25:25 <adimit> complete with run-region, etc.
12:25:38 <acube> Oh, 735 lines of errors :/
12:25:42 <joeyh> native + cross compile of everything, or some other method?
12:25:50 <acube> Is there a flag like -fmax-errors=1 for ghc?
12:26:08 <mauke> | head -n1
12:26:30 <acube> that only gives the first line of the first error message, doesn't it?
12:26:31 <chrisdone> adimit: cool =) speaking of history i've been wanted to store the repl history to a file
12:26:52 <mauke> yes :-(
12:27:12 <neurocyte> joeyh, I just enabled TH in the stage1 compiler
12:27:24 <adimit> chrisdone: since emacs can read what the repl says, that should be possible. I wouldn't know how (never done elisp on serious scales before.)
12:27:25 <joeyh> huh. I tried several times to do that
12:27:38 <joeyh> could not seem to make the setting do anything
12:28:06 <neurocyte> I also added a stage0 compile build, so the cross-compiler is effectively a stage3 compiler now
12:28:07 <chrisdone> adimit: indeed
12:28:12 <joeyh> ahah
12:28:34 <chrisdone> luite: i made some structural navigation functions for haskell-mode :>
12:28:40 <neurocyte> joeyh, you can check the patch that enables th in stage1 if you want, there was not really much to it
12:28:55 <luite> chrisdone: cool
12:29:19 <adimit> I think a general haskell-editors mailing list might not be a bad idea, as a place for people to get inspired by people to add support for features for their own editors, etc.
12:29:33 <chrisdone> there is a haskell-emacs mailing list but it's quite quiet
12:29:43 <adimit> I've been thinking that something similar to paredit might be possible for haskell-mode, but that's pretty sophisticated.
12:29:46 <chrisdone> http://projects.haskell.org/cgi-bin/mailman/listinfo/haskellmode-emacs
12:30:04 <chrisdone> adimit: then you're gonna love what i've been doing the past couple days =p
12:30:20 <neurocyte> joeyh, https://github.com/neurocyte/ghc-android/blob/master/patches/ghc-enable-stage1-th.patch
12:30:49 <adimit> chrisdone: impatiently waiting :-)
12:31:33 <shergill> chrisdone: are you talking about the browser-based editor i've seen glimpses of?
12:32:54 <ReinH> What is the current state-of-the-art for FRP (esp. game dev) in Haskell? The haskellwiki article looks like it was last updated on Aug, 2012? Anything new since then?
12:33:00 <chrisdone> shergill: actually similar to that, but just a kind of layer ontop of haskell-mode like paredit
12:33:09 * chrisdone uploads a video
12:33:09 <ReinH> Sorry, 16 Nov 2012 http://www.haskell.org/haskellwiki/Functional_Reactive_Programming
12:33:30 <ReinH> chrisdone: "structural navigation"? go on.
12:33:42 <ReinH> I use vim but I'm always interested in new editing tools
12:34:19 <shergill> chrisdone: i'd be all for that!
12:35:20 <chrisdone> so my screen recording software is not very good, it seems not to show some changes on the screen, but here's a vid: http://chrisdone.com/structured-haskell-mode.ogv
12:36:00 <adimit> ReinH: i've made the transition from vim to emacs recently. Evil-mode is a damn good vim emulator :-)
12:36:16 <chrisdone> so i'm using C-M-f/C-M-b to go to the end and start of nodes, and C-M-u/C-M-d to go up/down nodes. and C-M-k to cut a node
12:36:26 <ReinH> adimit: I spent a few months using emacs for Erlang and it never quite clicked.
12:36:42 <ReinH> even though erlang-mode was quite good
12:37:22 <ReinH> I think my muscle memory is too petrified now... I've been using vim for over a decade...
12:37:26 <lispy> ReinH: you might ask in #haskell-game
12:37:32 <chrisdone> the dark background represents the current node. lisp has explicit parens, so this kind of code nav/editing is very easy. haskell has tonnes of implicit parens, so we have to pretend they're there
12:37:38 <ReinH> lispy: TIL of #haskell-game. Thanks!
12:37:40 <^|{`-}^{> !list
12:37:40 <monochrom> ^|{`-}^{: http://hpaste.org
12:37:58 <lispy> ReinH: jmcarthur and some others are trying to build a coherent package of libraries for Haskell game dev
12:38:17 <shergill> chrisdone: LOVE it
12:38:24 <chrisdone> shergill: :D
12:38:41 <adimit> chrisdone: same here. looks nice. Will definitely need some evil keybindings for that :-)
12:39:22 <ReinH> lispy: thanks v. much
12:39:24 <chrisdone> adimit: i've been meaning to try evil mode at some point!
12:39:27 <adimit> ReinH: i've been using vim for 6 years, and also have pretty petrified muscle memory (and no standard vim either, I did funny things like remapping : and stuff.) But evil allows you to keep your vim ways for the most part.
12:39:38 <ReinH> adimit: remapping : o_O
12:39:45 <lispy> ReinH: I haven't taken the time to properly learn FRP. I can't tell if the ideas are mature and the implementations immature or if the ideas themselves need more time. If you're interested in FRP, you might try Elm. My understanding is that it's a language for compiling to javascript that supports FRP at the language level.
12:40:24 <shergill> chrisdone: you'll be getting a beer from me for that when/if we meet. or do you take donations? i'd be willing to show my appreciation that way
12:40:32 <adimit> ReinH: I hate modifier keys, and pressing shift to access ex was a no-go :-)
12:40:54 <ReinH> adimit: so did you just map ; : ?
12:41:04 <chrisdone> shergill: haha beer sounds good =p
12:41:08 <adimit> ReinH: yeah, among other things.
12:41:12 <ReinH> That's more normal. I thought you meant changing the mapping of :
12:41:17 <ReinH> I swap ` and ', f.e.
12:41:27 <adimit> yeah, that's a good one, too.
12:41:34 <adimit> and of course putting escape on caps lock.
12:41:37 <ReinH> adimit: you hate modifier keys but you... switched to emacs? Does not compute.
12:41:47 <adimit> ReinH: yes, evil is that good :-)
12:41:57 <ReinH> heh :)
12:42:22 <adimit> I don't use more CTRL than i did in my vim days. Though Meta is somewhat more frequent, since I didn't remap M-x.
12:42:31 <neurocyte> chrisdone, that looks freaking awesome
12:42:40 <neurocyte> chrisdone, have you published it yet?
12:42:41 <chrisdone> shergill: the one remaining thing is indentation. now, i THINK it should be waaay easier to write an accurate indentation function because we have information like "who's my parent" already as paredit does
12:43:33 <chrisdone> neurocyte: i'm still trialing it and smoothing rough edges but i'll put it online soon!
12:43:42 <klugez> chrisdone: Sorry for being superficial, but what's the color scheme?
12:43:51 <chrisdone> klugez: zenburn =)
12:44:34 <shergill> chrisdone: you're trying to fix/improve the current indentations schemes you mean?
12:44:38 <akegalj> chrisdone: is it for vim or emacs? didnt folow conversation
12:44:46 <chrisdone> shergill: i intend to replace them actually
12:44:56 <ReinH> akegalj: for emacs
12:45:05 <shergill> yeah i feel it should be easier, provided you do have accurate ast parent information
12:45:07 <akegalj> ReinH: k, tnx
12:45:08 <chrisdone> akegalj: that's emacs. though i think the same approach could be taken for vim if vimscript is able
12:45:28 <ReinH> chrisdone: omg use // for multiline strings :p
12:45:39 <shergill> chrisdone: i for one wouldn't miss the old ones, they're kinda kludgy
12:45:47 <neurocyte> zenburn FTW!
12:45:51 <chrisdone> ReinH: tell that to the hasktags author =p
12:45:59 <klugez> The structured editing looks really cool too and makes me happy that I'm trying out evil+emacs right now.
12:46:07 <ReinH> don't you hate it when tools get in the way of "correct" programming?
12:46:37 <ReinH> vim actually has some vaguely similar tools
12:46:37 <chrisdone> shergill: yeah i think they spend most of their time trying to guess what node you're in, here we know it
12:46:42 <ReinH> that let you work with expressions as text objects
12:46:45 <chrisdone> klugez: cool!
12:47:33 <adimit> ReinH: yeah, but indentation and syntax highlighing for vim is a giant unstructured regex clusterfuck. I mean, I've tried it several times :-|
12:47:55 <ReinH> adimit: it's pretty good now.
12:47:56 <chrisdone> pretty much what haskell-mode is like too
12:48:21 <ReinH> adimit: this is pretty damn cool https://github.com/dag/vim2hs
12:48:24 <adimit> ReinH: I wasn't content with it last time I used vim. And it was pretty bad at doing literate haskell.
12:48:39 <adimit> ReinH: yeah, I was using it. Agree, it's really good.
12:48:57 <ReinH> also the unicode support is pretty darn cool
12:49:05 <ReinH> agree that emacs is probably the better haskell editor
12:49:08 <fizruk> ReinH: wow, thanks for bringing it in!
12:49:17 <ReinH> fizruk: ?
12:49:22 <adimit> nowadays, I prefer to just use {-# LANGUAGE UnicodeSyntax #-}
12:49:45 <fizruk> Reinh: vim2hs, never heard before
12:49:49 <rgrinberg> is vim2hs a collection of different vim haskell plugins?
12:49:54 <rgrinberg> or a fork of them
12:50:10 <chrisdone> donri: they're talking about your stuff =)
12:50:46 <donri> rgrinberg: it's its own thing from scratch
12:50:48 <donri> chrisdone: \o/
12:51:54 <chrisdone> haha
12:52:25 <ReinH> rgrinberg: I believe it's from scratch
12:52:38 <ReinH> donri: :)
12:53:02 <ReinH> donri: vim2hs is yours?
12:53:12 <donri> it is
12:53:31 <donri> it's also insane and needs a complete do over ;)
12:53:52 <jesyspa> This comment raises some issues with traverse, but can anyone explain what makes them surprising?  I don't see why two filters + two modifications should be equal to one filter + two modifications composed. http://www.reddit.com/r/haskell/comments/1dpk2b/haskell_for_all_program_imperatively_using/c9solfz
12:54:01 <adimit> how did you not go crazy writing that amount of vimScript, donri?
12:54:18 <ReinH> donri: hah
12:54:20 <donri> adimit: easy: i was already crazy
12:54:50 <ReinH> adimit: step 1: be tpope
12:54:53 <ReinH> step 2: don't not be tpope
12:55:00 * donri is hacking on a different vim script as we speak
12:55:18 <ReinH> although to be fair, tpope is crazy in his own right
12:55:30 <chrisdone> donri: add something like this while you're at it: http://chrisdone.com/structured-haskell-mode.ogv
12:55:36 <adimit> yeah, tpope is bloody awesome. I still prefer fugitive over anything magit has to offer and usually do my commits in vim.
12:55:50 <chrisdone> =o
12:56:02 <chrisdone> i'll not hear a bad word said against magit! =o
12:56:05 <rgrinberg> tpope is the oleg of vimscript
12:56:09 <chrisdone> haha
12:56:25 <donri> chrisdone: https://github.com/bitc/vim-hdevtools/issues/11
12:56:27 <adimit> chrisdone: magit is not bad. it's just not as good as fugitive in doing incremental commits.
12:56:28 <ReinH> adimit: I worked with him back in 2008-2009. Pairing him was a constant stream of "wait, how did you do that?"
12:56:30 <chrisdone> tpope already did it, in the vimscript
12:56:48 <ReinH> and I thought I was already pretty good at vim at the time
12:56:49 <ReinH> I was wrong.
12:56:52 <donri> nah tpope is the dons or something. kana is the oleg
12:57:04 <chrisdone> donri: ooo =)
12:57:05 <rgrinberg> i want this for ghci: https://github.com/tpope/vim-fireplace
12:57:12 <ReinH> I'm pretty sure tpope is the tpope of vimscript :p
12:57:28 <donri> chrisdone: (not implemented, it's an idea. but vim-hdevtools already basically does this for type inspection)
12:57:57 <donri> no actually kana is the edwardk :D
12:57:57 <ReinH> rgrinberg: yeah, just figure out wtf is going on in here https://github.com/tpope/vim-fireplace/blob/master/autoload/nrepl/fireplace_connection.vim
12:58:00 <ReinH> and you're basically there
12:58:32 <chrisdone> donri: there's also low-hanging fruit for indentation
12:58:32 <Garyuutensei> Hello, I posted my program on codreview.stackexchange to have it reviewed (it is my first program) and I didn't understand one point someone made on the structure. Maybe someone could enlighten me :) .
12:58:32 <donri> https://github.com/kana?tab=repositories filter by "vim" :p
12:58:54 * chrisdone reads "Japan"
12:58:59 * chrisdone sees picture of anime doll
12:59:00 * chrisdone nods
12:59:05 <chrisdone> looks legit
12:59:06 <Fuuzetsu> Garyuutensei: You should probably post the relevant URL.
12:59:09 <donri> chrisdone: oh right. that linked idea would only do editing, not indenting
12:59:58 <Garyuutensei> The link is the following: http://codereview.stackexchange.com/questions/26081/haskell-particle-simulation/26118?noredirect=1#comment40476_26118
13:00:09 <chrisdone> donri: wanna hangout?
13:00:35 <donri> haha maybe i should just get a mic/cam
13:00:45 <chrisdone> =p
13:00:55 * donri shy
13:01:36 <Fuuzetsu> Garyuutensei: How are you making these awesome graphs?
13:02:40 <Garyuutensei> Fuuzetsu: I just use hp2ps -c on the space profiling output
13:02:57 <Garyuutensei> then I use photoshop to open the ps file :S
13:03:27 <ReinH> Garyuutensei: which comment do you have a question about?
13:03:46 <Ben1> Hello, I am just curious, does anybody know of ghci working on ARM?
13:03:54 <Garyuutensei> it is about the following point of the person's answer,
13:04:04 <Garyuutensei> you already have a monad, but aren't using it as an encapsulation tool - your core simulation code still uses put directly. Try to find out what "verbs" you are really using, then define some simple wrappers for those (say increaseParticleMoves?). After you have eliminated all direct access, you can then export the monad and all actions to its own module, newtype-wrap it and stop exporting ...
13:04:17 <Garyuutensei> Having this sort of infrastructure would for example make the switch to ST much easier.
13:04:35 <quchen> Ben1: I think GHCi support was added in 7.6. Raspbian still has 7.4.
13:06:33 <int_index> What is the best way to write an event-based web-server for a game?
13:06:35 <ReinH> Garyuutensei: look at, f.e., https://github.com/Grieverheart/hPartSim/blob/master/main.hs#L76
13:06:39 <int_index> Is netwire suitable?
13:07:47 <ReinH> Garyuutensei: the idea is that you can encapsulate this state transformation and hide the use of put, which reduces coupling and allows you to hide the monad implementation behind your own newtype definition
13:09:21 * hackagebot Rasenschach 0.1 - Soccer simulation  http://hackage.haskell.org/package/Rasenschach-0.1 (MartinWoehrle)
13:09:42 <Garyuutensei> ReinH: Ah, I understand now...but is this a good practice even if you're not building a library/framework?
13:09:57 <ReinH> Garyuutensei: encapsulation, data hiding, and decreased coupling are always valuable
13:10:34 <ReinH> Garyuutensei: `updateParticles` carries more information than `put`, as does your own monad versus StateT or etc.
13:10:38 <chrisdotcode_> hi everyone :)
13:10:56 <Garyuutensei> ReinH: Yes, although I'm having a hard time understanding encapsulation in Haskell comapared to e.g. C++
13:11:23 <ReinH> Garyuutensei: start by extracting an `updateParticles` method in place, then consider how you can extract the entire monad
13:11:37 <adimit> no wonder. the two languages conceptualise their data structures in an entirely different way
13:13:04 <ReinH> Garyuutensei: updateParticles particles` cll` is less noisy and more intention revealing than the put statement and allows you more flexibility in how SimState is implemented
13:13:58 <ReinH> Garyuutensei: later on you can lift it into your Eval monad
13:14:27 <ReinH> Garyuutensei: does that make sense?
13:14:32 <Garyuutensei> ReinH: Yes, I'm trying to think how I would do this...isn't there a performance penalty if I use put multiple times, once for each variable in the state I need to update?
13:14:49 <dolio> donri: I've been thinking about vim indenting....
13:15:16 <ReinH> Garyuutensei: first, you shouldn't need to do that. Second, ghci may be able to optimize that. Third, t's not a performance problem until you measure it.
13:15:37 <adimit> emacs users: is there a way to run hlint automatically? (i remember doing it in vim, but don't know how to in emacs.)
13:15:46 <ReinH> Garyuutensei: considering how performant lenses have proven to be, I shouldn't expect ghci to have much trouble
13:16:09 <dolio> I was wondering if the best way to do it might not be to use vim to grab up the current definition up to where you are, and then hand it out to a program written in Haskell that can actually do parsing reasonably.
13:16:27 <ReinH> Garyuutensei: basically you want to extend your monad to support the verbs that model the effects you need
13:16:28 <dolio> Which is kind of how it's done in emacs, except all in elisp.
13:16:41 <Garyuutensei> ReinH: So if I understand correctly, you're suggesting for starters to have a function 'updateState' which is passed all the state variables?
13:17:04 <dolio> But elisp is a little better for parsing than viml, I think.
13:17:05 <ReinH> Garyuutensei: no, I'm suggesting separate functions for each effect
13:17:19 <ReinH> Garyuutensei: updateParticles, increaseVolume, etc
13:17:36 <Garyuutensei> ok
13:18:07 <ReinH> where each one has one responsibility
13:18:18 <ReinH> they can then be composed into more complex effects
13:18:25 <ReinH> which ghci may be able to optimize, or which may not need optimization
13:19:02 <ReinH> Garyuutensei: if your monad is there to model computation / effects, you can enrich it by giving it verbs that more closely describe what kind of computations/effects it models
13:19:15 <ReinH> rather than using generic ones like 'put' everywhere
13:20:21 <Garyuutensei> ReinH: so as an example: incrementVol state = put $ state{_nVol = nvol + 1} ?
13:20:52 <mightybyte> How often does hackage rebuild docs these days?
13:21:08 <simpson> mightybyte: Probably still a fifteen-minute cron job.
13:21:09 <ReinH> Garyuutensei: exactly, and that can be composed of incrementVol = increaseVol 1 where increaseVol n state = put $ state{_nVol = nvol + n} and so on
13:21:30 <ReinH> Garyuutensei: however granular you need
13:21:47 <Garyuutensei> ok, I see
13:21:50 <mightybyte> simpson: A package uploaded yesterday still doesn't have docs yet.
13:21:56 <simpson> mightybyte: Dunno. :c
13:22:14 <ReinH> Garyuutensei: and then you can build up via composition to more complex effects and lean on ghc to optimize them until you profile an actually hotspot
13:22:22 <ReinH> s/actually/actual
13:22:23 <simpson> Garyuutensei: This is part of why lens is awesome: increaseVol x = nVol += x
13:22:31 <Garyuutensei> ReinH: Can I do something to hide gets and asks or should I just wrap with custom names?
13:22:36 <ReinH> simpson: indeed, but one thing at a time :p
13:22:43 <DMcGill> so what does "missing C libraries:" mean? I have a bunch of .so files and have pointed to them with --extra-lib-dirs
13:22:49 <neurocyte> adimit, yes, my emacs runs hlint automatically, with flymake
13:22:49 <ReinH> Garyuutensei: that's the second part of the advice
13:23:02 <ReinH> Garyuutensei: export your own monad via newtype declaration that hides get, put, etc
13:23:34 <neurocyte> adimit, Im not sure which package does it though, probably haskell-mode or ghc-mod
13:23:37 <Garyuutensei> simpson: Yes, I'm intending to use lenses at some point :)
13:24:08 <ReinH> Garyuutensei: lenses are great and this is a case for them. Lens composition is super useful.
13:24:16 <ReinH> *a great case for them
13:25:11 <neurocyte> adimit, its ghc-mod that runs hlint
13:25:24 <adimit> neurocyte: thanks!
13:25:30 <adimit> I should have it, but I don't have flymake.
13:25:43 <Garyuutensei> ReinH: Ok, one more question :P . Do I understand correctly that I could use the ST monad instead of State to have a truely mutable state? Is this recommended?
13:26:13 <DMcGill> Garyuutensei: only if you actually need it, i.e. need things done in place or have heavy array usage
13:26:19 <DMcGill> ST is a pain, but sometimes you need it
13:26:26 <DMcGill> see the Vector and MutableVector types
13:28:07 <ReinH> Garyuutensei: yes, but I would focus on other optimizations (unboxing, inlining, etc) first.
13:28:35 <Garyuutensei> Ok, so for example my State is composed of large arrays (although I do update these in place using mutable vectors), would I benefit from using ST to update it instead of StateT?
13:29:16 <ReinH> Garyuutensei: btw once your monad is encapsulated and its implementation is hidden it will be much easier to switch from State to ST ;)
13:29:28 <ReinH> Garyuutensei: maybe.
13:29:50 <Garyuutensei> ReinH: Yes, I have been doing this, although sometimes it's hard to reason about strictness and the core is unreadable to me >_<
13:30:54 <Garyuutensei> ReinH: That's what the poster on codereview.stackexchange told me, although I don't yet understand why this is the case
13:31:44 <Garyuutensei> ReinH: Anyway, I have some food for thought for now, thanks for helping me
13:32:17 <DMcGill> with cabal, how do you have multiple include dirs?
13:32:36 <ReinH> Garyuutensei: because if your impl is hidden then you won't type coupling everywhere and changing StateT to ST only needs to happen in one or two places.
13:32:38 <DMcGill> multiple arguments of --extra-include-dirs, or the arguments seperated by commas or something?
13:32:59 <ReinH> DMcGill: comma-separated iirc
13:33:05 <ReinH> Garyuutensei: np
13:33:45 <ReinH> Garyuutensei: since you'll be writing incrementVolume and etc in terms of your top-level monad, Eval, and hiding its internal impl.
13:35:21 <Garyuutensei> ReinH: Yes, I see, so then you will have only a few changes in the generic update functions
13:39:32 <ReinH> Garyuutensei: right
13:42:08 <ReinH> Garyuutensei: basically: create some internal functions that allow you to address different monads in the stack, then use those to build the top-level functions that you export. Then you only need to change those internal functions when the internal structure changes.
13:52:07 <t3nsor> Is anyone else having trouble installing lambdabot with cabal?
13:53:20 <t3nsor> http://hpaste.org/88030
13:54:01 <Taneb> t3nsor, I'm pretty sure that's a thing that is a thing
13:54:13 <Taneb> By  which I mean a lot of people have that problem
13:54:15 <hpc> you might have luck with a newer ghc
13:54:28 <hpc> you appear to be older than 7, which is quite old indeed
13:54:43 <t3nsor> hmm, okay, I'll try that
13:54:53 <t3nsor> although the page on hackage still says it requires version 6.10 or something
13:55:55 <hpc> t3nsor: the documentation is even worse-maintained than the code ;)
13:56:12 <t3nsor> for something as difficult to build as lambdabot
13:56:18 <t3nsor> I'm surprised nobody's offering binaries
13:56:33 <hpc> it has a lot of external depends
13:56:38 <hpc> mueval, etc
13:57:59 <hpc> a while back i was able to get it mostly working with 7.4.1
13:58:27 <hpc> a lot of binary depends were not installed and so didn't work
13:58:33 <hpc> and iirc djinn would fail for no reason
14:00:06 <int_index> aren't GHC compilers back compatible except for extensions?
14:01:23 <hpc> in theory, maybe?
14:01:32 <hpc> they surely aren't forward-compatible
14:01:36 <hpc> which is what's needed here
14:02:08 <Clint> t3nsor: it's in debian and ubuntu
14:03:09 <dmwit> Okay, functions are Traversable now!
14:03:27 <shergill> wait what?
14:03:51 <c_wraith> :t traverse
14:03:52 <kappabot>     Not in scope: `traverse'
14:03:52 <kappabot>     Perhaps you meant one of these:
14:03:52 <kappabot>       `Data.Traversable.traverse' (imported from Data.Traversable),
14:04:00 <c_wraith> :t Data.Traversable.traverse
14:04:01 <kappabot> forall (t :: * -> *) (f :: * -> *) a b. (Applicative f, Data.Traversable.Traversable t) => (a -> f b) -> t a -> f (t b)
14:04:15 <c_wraith> ok, yeah, that makes sense.
14:04:24 * hackagebot universe 0.4 - Classes for types where we know all the values  http://hackage.haskell.org/package/universe-0.4 (DanielWagner)
14:07:19 <dmwit> < traverse (\x -> guard (even x || odd x) >> return (x^2)) :: Maybe (Word8 -> Word8)
14:07:20 <goodfellow>   Couldn't match expected type `Data.Maybe.Maybe
14:07:21 <goodfellow>                             ...
14:08:10 <dmwit> < sequenceA (\x -> guard (even x || odd x) >> return (x^2)) :: Maybe (Word8 -> Word8)
14:08:11 <goodfellow>   Not in scope: `sequenceA'
14:08:11 <goodfellow>  Perhaps you meant one of these:
14:08:11 <goodfellow>    `Data.Travers...
14:08:21 <dmwit> < Data.Traversable.sequenceA (\x -> guard (even x || odd x) >> return (x^2)) :: Maybe (Word8 -> Word8)
14:08:22 <goodfellow>   Just [(0,0),(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10...
14:08:48 <dmwit> Turn your possibly-failing functions into certainly succeeding ones (or an error)!
14:08:51 <dmwit> neato
14:09:10 <c_wraith> replacing failure with a list of successes?
14:09:10 <byorgey> dmwit++
14:09:25 <dmwit> c_wraith: no lists in that type!
14:09:36 <dmwit> (it just looks like a list because of my lazy Show instance)
14:10:12 <dmwit> < case Data.Traversable.sequenceA (\x -> guard (even x || odd x) >> return (x^2)) of Nothing -> "ack"; Just f -> show (f 5)
14:10:14 <goodfellow>   Ambiguous type variable `a0' in the constraints:
14:10:14 <goodfellow>    (GHC.Real.Integral a0)
14:10:14 <goodfellow> ...
14:10:22 <dmwit> < case Data.Traversable.sequenceA (\x -> guard (even x || odd x) >> return (x^2)) of Nothing -> "ack"; Just f -> show (f (5 :: Word8))
14:10:23 <goodfellow>   "25"
14:12:07 <no-n> > 1
14:12:08 <kappabot>   1
14:12:10 <no-n> < 1
14:12:12 <goodfellow>   1
14:12:39 <simpson> How many bots are going to be in here?
14:12:47 <no-n> > (concat . replicate 3) [1,2,3]
14:12:48 <kappabot>   [1,2,3,1,2,3,1,2,3]
14:12:48 <t3nsor> Clint: yep, but it turns out mueval is annoying to build too
14:13:00 <FireFly> And why doesn't lambdabot react on '>'?
14:13:20 <geekosaur> lambdabot is +q right now, I believe
14:13:22 <Fuuzetsu> FireFly: lambdabot is ill
14:13:26 <FireFly> Oh
14:13:32 <Fuuzetsu> RIP
14:13:32 <otters> hi FireFly
14:13:38 <geekosaur> so it is reacting but we don't see it. because its reaction is that mueval throws an internal error for unknown reasons
14:18:20 <Zenol> Hi, i'v a question, a bit "theorical". I'm writing a tutorial for a raytracer, and I made the choce to make functions with type Scene -> Something (So that I can use them as smth -> m something). Is it a bad / good idea and why? Also, Are there something for types defined in diferente files (Object need scene type, Scene type need objet type. Light type need Sceene type and Scene type need light type. But I can't write ech type in Obje
14:19:23 <ReinH> donri: ping
14:19:29 <donri> hi
14:19:38 <Fuuzetsu> Zenol: You're the author of the tutorial. You should have been thinking about whether something  m something is a good or bad idea in the context.
14:19:51 <Fuuzetsu> There isn't really a universal answer for this. If that's what you need, then sure.
14:20:17 <ReinH> donri: I was going to ask you how to get vim2hs's collapse chars to work in iTerm but I think it's an encoding setting buried somewhere
14:20:55 <Fuuzetsu> I'm not sure I understand the second part of your question. Your types are defined at top-level and you can freely use them together.
14:21:21 <donri> ReinH: no idea about iterm. use gvim myself ;)
14:21:35 <ReinH> donri: it totes works in mvim but I spend more time in tmux. I'll figure it out.
14:22:56 <Zenol> Fuuzetsu> Well, it's more a "what are the pro/cons than are related to". I thought it was good idea since it show a point of view of solving this problem that I like.
14:23:47 <donri> ReinH: does it work in iterm without tmux?
14:23:53 <Fuuzetsu> Zenol: Well, there's no need to have a  m a everywhere just for the sake of it but if you need such functions and m is a monad then you get all the nice monadic things from it.
14:24:12 <Fuuzetsu> Then again, if m is the Identity monad then what's the point?
14:24:34 <Zenol> Fuuzetsu> Hum, a better example : module A (TypeA) where data TypeA = TypeA TypeB, and module B (TypeB) whre data TypeB = TypeB TypeA. Are there a way to do something like that?
14:24:36 <Fuuzetsu> The cons of having a  m a everywhere instead of a  a is that you have to deal with the monadic stuff.
14:25:40 <ReinH> donri: nope
14:25:41 <Fuuzetsu> Zenol: I'm pretty sure that's possible although I can't tell you how to do it (I don't know). IIRC there's some meddling you have to do with it.
14:25:44 <Zenol> Fuuzetsu> I have only a -> m b (not a -> m a)  when it meens that b depend from the context (ie b value depend of the Scene state)
14:25:55 <ReinH> donri: interesting. iterm is set to utf-8, encoding and fileencoding in vim are set to utf-8
14:25:59 <ReinH> maybe it's my TERM value?
14:26:08 <Fuuzetsu> Zenol: Here's a link to read http://stackoverflow.com/questions/8650297/haskell-recursive-circular-module-definitions
14:27:18 <Fuuzetsu> Zenol: Sure, if you have a  m b and you need it that way then go for it. Mind that of course you can't compose such functions with a simple >>= unless a  b
14:27:24 <donri> ReinH: do you have vim 7.3 btw
14:27:32 <donri> but i think you'd get errors otherwise
14:27:33 <Fuuzetsu> a = b rather
14:27:36 <ReinH> yep
14:27:43 <ReinH> donri: how does vim2hs check for unicode support / doe sit?
14:28:29 <donri> ReinH: don't think it does :D
14:28:49 <donri> i think it just assumes you have support for everything it wants
14:29:14 <Zenol> Fuuzetsu> Wow, the boot thing is a bit ugly...
14:29:34 <Zenol> Fuuzetsu> And merge all types in a "Type.hs" file was already what I was thinking about :(
14:29:46 <dmwit> Yes, that's the easiest and most common way to handle this.
14:32:20 <t3nsor> so I upgraded my installation of ghc to 7.4.1
14:32:29 <t3nsor> now I'm getting this error with show-0.5 failing to build
14:32:40 <mami_> hey
14:32:43 <donri> ReinH: so what is the problem anyway, how does it present itself?
14:32:59 <ReinH> donri: as normal with :: and ->
14:33:00 <mami_> does anyone by any chance know some good intros into game (as in chess) AI?
14:33:07 <t3nsor> http://hpaste.org/88031
14:33:11 <acowley> I don't think big changes to Prelude are going to happen, but I wish they could
14:33:23 <ReinH> donri: so I thought it was doing some sort of check to see if there was unicode support
14:33:27 <donri> ReinH: well you need to enable those
14:33:32 <ReinH> donri: I did. It works in mvim.
14:33:47 <donri> ReinH: the default only conceals single-characters like . and \ to not mess with alignment
14:33:52 <donri> oh
14:34:15 <donri> and you didn't do it in .gvimrc or something like that? :D
14:34:24 <adimit> yeah, conceal gets really annoying when it starts messing with alignment (hence my preference for -XUnicodeSyntax)
14:34:29 <acowley> Does anyone have any experience using general-prelude? It looks reasonable.
14:34:40 <ReinH> donri: nope :D and it doesn't conceal . either
14:34:43 <johnw> acowley: thanks, acowley
14:34:54 <dmwit> t3nsor: Strange, show-0.5 builds on GHC 7.4.1 fine here.
14:34:55 <acowley> johnw: Do you use it much yourself?
14:34:56 <Zenol> dmwit, Fuuzetsu> Wouldn't it be possible for ghc to, in some way, just merge code from A.hs with the B.hs, and just don't import A.hs from B.hs if you come from A.hs? Ore is it hard from the way module support is writen in GHC?
14:34:59 <donri> ReinH: what is :set conceallevel?
14:35:16 <johnw> acowley: I don't use it as much now that I do a lot in the neighborhood of yesod; I've been using ClassyPrelude more now
14:35:24 <ReinH> donri: uh... that's not a supported option?
14:35:34 <donri> ReinH: ok there you have it then
14:35:55 <donri> ReinH: your vim is compiled with -conceal
14:36:01 <acowley> johnw: convince the yesod community to use general-prelude instead of ClassyPrelude :)
14:36:14 <dmwit> Zenol: A big goal of GHC is separate compilation: that each .hs file can be processed without processing any other .hs files. It doesn't quite get there -- it needs to process .hi files from other modules -- but it gets close. To achieve this, it must be able to topologically sort the modules' dependency graph.
14:36:14 <t3nsor> dmwit: maybe it has something to do with the fact that I installed the generic binary package
14:36:19 <dmwit> Cycles defeat topological sorts.
14:36:28 <ReinH> donri: oh facepalm
14:36:29 <t3nsor> (when I tried to install it from the repository I got errors about missing documentation)
14:37:01 <donri> you'd think vim would error loading vim2hs
14:37:34 <johnw> acowley: I think general-prelude should use Control.Exception.Lifted though, I use that a lot more these days
14:37:42 <johnw> (since it's more "general")
14:37:52 <dmwit> t3nsor: I suspect it's much more likely that we just have different versions of QuickCheck installed.
14:38:16 <dmwit> t3nsor: (And that show's dependency on QuickCheck is too lax.)
14:38:34 <dmwit> t3nsor: You might try restricting it to QuickCheck 2.4 or 2.5.
14:38:59 <dmwit> gotta run, but good luck
14:39:07 <ReinH> donri: os x vim is compiled stupidly, apparently.
14:39:08 <johnw> acowley: you don't like Classy?
14:39:19 <donri> ReinH: heh. maybe brew it or something?
14:39:26 * donri no osx
14:40:03 <acowley> johnw: I really haven't looked at it closely. When it was initially presented, I thought the criticisms seemed valid, and found the arguments in the other direction unconvincing.
14:40:06 <donri> my OS has like four different vims compiled with differing levels of features enabled
14:40:13 <geekosaur> os x emacs is no better, emacs-app macport is one of the first things I install
14:40:18 <donri> vi vim vimx gvim :D
14:40:52 <acowley> johnw: I really just want to not have to import the usual suspects in every module, and I'd rather if the short names were given to the useful abstractions.
14:40:53 <ReinH> donri: yeah, brewing it now. Just complaining.
14:41:03 <ReinH> donri: also, woah: https://github.com/Twinside/vim-haskellConceal
14:41:27 <donri> yeah there are others still i think
14:41:32 <donri> and one that doesn't use conceals
14:41:40 <donri> so maybe try that one
14:42:21 <donri> ReinH: https://github.com/frerich/unicode-haskell
14:42:35 <ReinH> donri: yeah, looks like brew vim compiles with huge
14:43:10 * geekosaur wonders if it's newlines (eq won't match in that case, probably)
14:43:29 <ReinH> donri: better than haskellConceal then?
14:43:57 <donri> ReinH: no clue. but might work without conceals
14:44:07 * geekosaur oops, channel
14:44:11 <geekosaur> (how did I do that?)
14:44:22 <ReinH> donri: oh I have conceals now.
14:44:43 <ReinH> and if it doesn't use conceals then it's doing it wrong :p
14:49:38 * hackagebot atto-lisp 0.2.1.2 - Efficient parsing and serialisation of S-Expressions.  http://hackage.haskell.org/package/atto-lisp-0.2.1.2 (ThomasSchilling)
14:49:40 * hackagebot snaplet-persistent 0.2.0.1 - persistent snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-persistent-0.2.0.1 (DougBeardsley)
14:51:22 <Zenol> dmwit> I think I can't understand unless I learn what ghc is doing to files and why he need to proceed other .hi files.
14:52:15 <Fuuzetsu> Zenol: The easiest approach would be to just create a .Types module. I believe this is what quite a few packages out there are doing.
14:53:12 <donri> ReinH: yeah. i think it might predate conceals
14:53:39 <johnw> acowley: well, that's exactly the aim of general-prelude, but not quite the aim of ClassyPrelude, so I think it might serve you better.  Patches welcome, btw
14:54:05 <hpc> clearly what you need is Prelude.PHP
14:54:40 * hackagebot snaplet-actionlog 0.2 - Generic action log snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-actionlog-0.2 (DougBeardsley)
14:55:05 <acowley> johnw: These efforts benefit a lot by having a community behind them. If I'm on my own, I'd worry I'm just making my code confusing for everyone else.
14:56:36 <acowley> I suppose I'd accept a language pragma that swapped in an "Advanced" Prelude and maybe turned on a few extensions. This gets back to my idea from the other day of wanting language pragma definitions in .cabal files.
14:56:56 <otters> I just want a prelude with (++) = mappend
14:57:05 <tikhonjelvis> isn't that sort of what the old -fglasgow-exts flag did?
14:57:19 <acowley> That way any individual source file could still have a pragma indicating it's not straight Haskell2010, but I won't have dozens of pragmas and imports in every file.
14:57:21 <tikhonjelvis> however it's spelled
14:57:23 <acowley> tikhonjelvis: Yeah
14:57:30 * cmccann has a replacement prelude that includes (++) = mappend and imports it automatically in his .ghci file
14:57:36 <tikhonjelvis> otters: I actually like <> for mappend more than ++
14:57:57 <otters> well, let's kill ++ then
14:58:08 <tikhonjelvis> Personally, I particularly hate importing Control.Applicative and Data.List everywhere
14:58:09 <acowley> tikhonjelvis: Having just one definition for such a thing leads to infinite bike shedding, so I'm floating the idea of having effectively a custom -fglasgow-exts defined in a .cabal file.
14:58:23 <acowley> I like <> more than ++, too
14:58:23 <cmccann> acowley: clearly we need -XPragmaSynonyms so we can define our own composite pragmas
14:58:33 <tikhonjelvis> endless bikeshedding sounds fun though
14:58:44 <acowley> tikhonjelvis: We have an aptitude for it
14:59:10 <acowley> cmccann: It will also require some new imports in every module to support the composite pragma definition.
14:59:11 <int-e> who's shadding bikes and why?
14:59:20 <int-e> *shedding.
14:59:22 <cmccann> acowley: of course
14:59:26 <thoughtpolice> i still can't get over how much lambda-case was bikeshedded.
14:59:26 <Zenol> Fuuzetsu> Don't worry, I'll do that ;)
14:59:34 <thoughtpolice> it blew my mind a little.
14:59:56 <cmccann> at least it wasn't lexical syntax of comments
14:59:57 <tikhonjelvis> heh
15:00:05 <acowley> thoughtpolice: At least now everyone agrees it's wonderful!
15:00:08 <int-e> thoughtpolice: but did anybody suggest  case \ of  ? ;-)
15:00:10 <tikhonjelvis> hah!
15:00:17 <thoughtpolice> :)
15:00:22 <int-e> (not that I remember)
15:01:37 <tikhonjelvis> what exactly was the question with comments?
15:01:51 <tikhonjelvis> was it about using -- as the delimiter?
15:01:55 <cmccann> tikhonjelvis: http://www.haskell.org/haskellwiki/Wadlers_Law
15:02:20 <tikhonjelvis> ah
15:02:29 <tikhonjelvis> to be fair, Haskell has a bunch of lexical quirks
15:02:39 <tikhonjelvis> > [True..False]
15:02:39 <kappabot>   A section must be enclosed in parentheses thus: (`True..` False)Not in scop...
15:02:47 <acowley> I use ~~ to indicate comments, then run all my code through a pre-processor triggered by a custom cabal build.
15:02:53 <thoughtpolice> well, Haskell is a pretty crowded language lexically/syntactically i think
15:03:10 <hpc> for a while, the expression 0xford would evaluate to 15 in lambdabot
15:03:11 <tikhonjelvis> what we need is to dump all the cruft and add a nice macro system
15:03:11 <acowley> thoughtpolice: But there are so many flavors of unicode whitespace left untapped!
15:03:14 <simpson> Really? I think it's pretty sparse.
15:03:16 <rgrinberg> it's worth it though
15:03:21 <rgrinberg> it looks much better than ocaml
15:03:25 <rgrinberg> at least
15:03:31 <tikhonjelvis> rgrinberg: high standards, eh?
15:03:34 <mauke> > 0xford
15:03:34 <kappabot>   Overlapping instances for GHC.Show.Show
15:03:35 <kappabot>                              ((GHC....
15:03:43 <tikhonjelvis> and hey, OCaml had the lambda-case problem solved for years
15:03:46 <hpc> mauke: parses as (0xf) ord
15:03:49 <mauke> I know
15:03:58 <tikhonjelvis> sort of
15:04:12 <tikhonjelvis> does lambda case support multiple arguments?
15:04:17 <thoughtpolice> acowley: heh, reminds me of someone suggesting an @agda-faq for lambdabot answering "Yes! Agda can do that with a lot of unicode"
15:04:18 <acowley> I'm always slightly embarrassed that I originally passed over OCaml years ago because I couldn't believe the ;; syntax
15:04:22 <int-e> tikhonjelvis: but ocaml lacks a sane syntax ;)
15:04:47 <tikhonjelvis> yeah, it's a little annoying
15:04:52 <tikhonjelvis> but then Camlp4 is pretty cool
15:04:52 <acowley> thoughtpolice: I think I was in that conversation. I am nothing if not consistent in what I find funny.
15:04:56 <rgrinberg> ocaml has a "saner" syntax
15:05:01 <rgrinberg> which is the revised syntax
15:05:13 <tikhonjelvis> oh, I don't think anybody uses that
15:05:22 <rgrinberg> apparently it's better to have 1 bad syntax over 2 incompatible ones
15:05:25 <rgrinberg> ;)
15:05:43 <int-e> (it's like it's been designed to trap Haskell users. : vs ::, and [1,2,3] being a singleton list, those I still haven't got used to.)
15:05:45 <tikhonjelvis> the revised syntax doesn't seem that great either
15:05:54 <tikhonjelvis> actually, that's entirely Haskell's fault
15:06:03 <tikhonjelvis> the rest of the civilized world also uses : for types
15:06:04 <rgrinberg> thre's also ocaml-twt
15:06:16 <acowley> Yeah the spaces around commas are a great introduction to the language
15:06:19 <rgrinberg> but it looks too magical for me
15:06:20 <int-e> tikhonjelvis: I know :)
15:06:39 <tikhonjelvis> I like having just one character in front of my types, personally
15:06:49 <tikhonjelvis> I guess I can take solace in 
15:07:22 <int-e> tikhonjelvis: the ,; thing trips me far more often. :)
15:07:25 <Fuuzetsu> int-e: Agda's  for cons and : for types confuses me so much ;(
15:07:38 <tikhonjelvis> oh yeah, the semi-colons have gotten me multiple times
15:07:46 <tikhonjelvis> they even messed up my OCaml-liking professor
15:07:58 <johnw> i don't really mind :: for types, but I don't think I care either
15:08:00 <acowley> How about | vs |
15:08:11 <cmccann> I prefer : for types
15:08:27 <tikhonjelvis> cmccann: yes!
15:08:35 <johnw> my editor displays , so it still looks like one char
15:08:37 <cmccann> I write type annotations more often than I write the list constructor by name anyway
15:08:42 <enthropy> strange thing that http://www.haskell.org/haskellwiki/Haskell has "This page was last modified 21:01, 22 July 2011", yet mentions events in 2013 as "Recent Events"
15:08:53 <tikhonjelvis> also, type annotations tend to be more sparse than code that pattern matches on lists
15:08:56 <Nisstyre-laptop> enthropy: haskell.org has a TARDIS
15:09:00 <acowley> enthropy: It was a very forward-looking edit
15:09:00 <johnw> enthropy: that was forward thinking on their part
15:09:07 <acowley> hah
15:09:29 <tikhonjelvis> well, we do have http://hackage.haskell.org/packages/archive/tardis/0.3.0.0/doc/html/Control-Monad-Tardis.html
15:09:55 <tikhonjelvis> johnw: do you use Emacs?
15:10:14 <johnw> tikhonjelvis: heavily
15:10:27 <tikhonjelvis> good, good
15:10:31 <Nisstyre-laptop> @faq Can haskell travel through time?
15:10:31 <kappabot> The answer is: Yes! Haskell can do that.
15:10:36 <johnw> i am actively rewriting my DNA in Emacs Lisp, to be more customizable
15:10:52 <tikhonjelvis> I currently use font-lock-symbols
15:11:02 <rgrinberg> johnw: too ez, try vimscript
15:11:06 <tikhonjelvis> but I'm considering chaning it to actually insert those symbols
15:11:11 <tikhonjelvis> changing**
15:11:12 <johnw> tikhonjelvis: i just use font-lock-keywords
15:11:17 <johnw> tikhonjelvis: you mean UnicodeSyntax?
15:11:21 <tikhonjelvis> yeah!
15:11:22 <johnw> people will just LOVE you for that
15:11:28 <tikhonjelvis> I want to export the Unicode goodness
15:11:32 <lambdazerocool> how do you guys avoid emacs pinky?
15:11:39 <tikhonjelvis> caps lock
15:11:42 <johnw> lambdazerocool: yeah
15:11:54 <lambdazerocool> i have that now but it still bugs me to hit capslock that many times
15:11:55 <tikhonjelvis> I already use Unicode characters in my variable names
15:11:58 <johnw> lambdazerocool: i grafted Arnold Schwarzenegger's pinky onto my hand
15:11:58 <lambdazerocool> as such i'm still confined to the vim world
15:12:07 <tikhonjelvis> you can always use Evil
15:12:10 <lambdazerocool> johnw is that why he only has a right pinky?
15:12:14 <johnw> indeed
15:12:50 <simpson> lambdazerocool: I lift up my entire left hand and use my middle/ring finger on my left hand to hit Esc.
15:13:14 <acowley> I still use Ctrl in emacs like a plebe.
15:13:17 <tikhonjelvis> unfortunately, Emacs indentation breaks when I have variables named x
15:13:22 <tikhonjelvis> I should fix that some time :/
15:13:26 <lambdazerocool> simpson: i use my ring finger for backspace
15:13:30 <scriptor_> remapping caps lock to esc is useful outside of vim, too
15:13:41 <simpson> "EMACS users *hate* him! Check out this one cool trick for hitting Esc."
15:13:43 <acowley> The spacing with unicode syntax is too much of a hassle
15:13:50 <simpson> lambdazerocool: The secret is that I'm a vim user. :3
15:13:57 <tikhonjelvis> what's different about the spacing?
15:13:59 <acowley> simpson: I think it's more weird than cool
15:14:01 <johnw> we suddenly devolved into #emacs
15:14:21 <tikhonjelvis> to be fair, #emacs tends to devolve into #haskell or #ocaml once in a while
15:14:26 <Fuuzetsu> johnw: That must be a 4th time within last two hours.
15:14:27 <johnw> true enough
15:14:29 <lambdazerocool> simpson: :D i'm looking at Evil right now, and i might get into that. vim has superior text editing by far, but emacs has all the integration
15:14:43 <simpson> lambdazerocool: viper-mode, etc.
15:14:55 <lambdazerocool> simpson: right. evil is to viper as vim is to vi :D
15:14:56 <tikhonjelvis> hmm, everybody recommends Evil over viper mode
15:15:19 <lambdazerocool> tikhonjelvis: it has visual block and @*#%. aka awesome.
15:15:21 * simpson doesn't particularly know which is preferable
15:15:58 <lambdazerocool> simpson: how extensive is your experience with conduit? i was looking at it earlier and it looks like it'll actually get a lot of redundant work out of the way for me in setting up my application, but there are a few things i'm still missing before i string it all together
15:16:30 <johnw> lambdazerocool: I use conduit
15:16:37 <simpson> lambdazerocool: I started porting a large Python project (Bravo) to Haskell, and chose conduit.
15:18:04 <simpson> lambdazerocool: My experience was that conduit is most of what one would want, and most of the problems are around the edges with other package bindings.
15:18:17 <simpson> network-conduit is pretty cool, cereal-conduit works well enough.
15:19:34 <lambdazerocool> simpson: right on. i'm currently looking at network-conduit, and i'm not sure that i can get away with the default TCP application server and client interfaces
15:19:51 <simpson> lambdazerocool: Why not?
15:20:15 <chrisdone> omg emacs talking #haskell and i missed it
15:20:29 <johnw> haha
15:20:42 <chrisdone> :D
15:22:01 <lambdazerocool> simpson: when a client connects to the server, i want to fork off a thread to handle incoming communication, and add the socket (even if wrapped in a sink) to a list of active sockets. when the connection is closed, i want to go back in and remove that socket from the list. Could I bundle all that functionality in the single "Application" that I run?
15:23:06 <simpson> lambdazerocool: So you want to have clients chatting with each other?
15:23:50 <lambdazerocool> simpson: slightly more general, but that's the idea. clients send a message to the server, the server formulates an appropriate message to broadcast to all active clients. the server can also broadcast without input.
15:24:26 <tikhonjelvis> chrisdone: are you familiar with the internals of haskell-mode?
15:24:37 <tikhonjelvis> or didn't you write your own version?
15:24:42 <t3nsor> I got this when I tried to evaluate something on lambdabot: "Could not find module `ShowIO'"
15:24:51 <t3nsor> Anyone know how to fix this?
15:25:14 <simpson> lambdazerocool: https://github.com/MostAwesomeDude/baskerville/blob/master/Baskerville/Beta/Session.hs
15:26:43 <simpson> lambdazerocool: Basically, using IO as the base monad for Conduit, you can break off a channel each time you accept a new connection.
15:27:09 <simpson> lambdazerocool: I apologize for the cruddy code; this was all experimental stuff that got thrown out.
15:29:53 <lambdazerocool> no worries, i'm peaking through it a bit
15:29:57 <otters> how do you uninstall GHC?
15:30:01 <otters> there's no uninstall target
15:32:41 <lambdazerocool> simpson: what is your ssBroadcast?
15:34:37 <simpson> lambdazerocool: Oh, that's from a lens; it corresponds to the _ssBroadcast member of SessionState.
15:36:19 <lambdazerocool> has anyone here googled "TChan" without including the word "haskell" in their search? =.=
15:37:53 <bitonic> when did this <http://www.reddit.com/r/haskell/comments/1eelao/understanding_the_yoneda_lemma/c9zj1ee> start to happen?  (the bit in the quote)
15:38:22 <bitonic> I mean what is the source of the you need category theory to understand Haskell idea?
15:42:59 <bitonic> because its quite an effective way to scare people off
15:43:15 <bitonic> (and also, not true)
15:43:49 <simpson> bitonic: I think that it comes from the requirement of using IO as a Monad.
15:44:03 <lambdazerocool> simpson: i don't have much experience with lenses, so i think i'm going to go ahead and dive into those for a bit - i'm not sure whether i'll get what's going on a little better after :-P
15:44:05 <bitonic> simpson: you dont need CT to understand Haskells Monad typeclass.
15:44:22 <simpson> lambdazerocool: lens is pretty straightforward; best of luck.
15:44:42 <simpson> bitonic: That is your opinion. The opinion of people who don't use Haskell is obviously somewhat different. :3
15:44:52 <lambdazerocool> simpson: thanks xD. at the moment i am just not understanding where or how people join your session, or what happens when they leave >.>
15:45:11 <bitonic> simpson: how can people who dont know about Monad or category theory make such a judgement?  because blog posts like that one exist.
15:45:12 <lambdazerocool> bitonic: you don't actually need to understand category theory. that said, you probably need the capacity to understand category theory.
15:45:19 <simpson> lambdazerocool: Ah, yes. That's what happens in event-driven code; you don't always get to have control of every little bit of things.
15:45:21 <bitonic> lambdazerocool: that doesnt mean anything
15:45:33 <acowley> "lens is pretty straightforward"
15:46:00 <simpson> acowley: Functor f => (s -> f t) -> a -> f b; what's not to get? :3
15:46:12 <cmccann> to use Haskell you need to understand the special case of "things relevant to Haskell" for the category theory concepts Haskell borrows
15:46:32 <cmccann> whether someone makes any attempt to learn those in the context of category theory is mostly irrelevant
15:46:36 <bitonic> lambdazerocool: the capacity of understanding CT is something so vague that its useless to talk about it.  as far as Im concerned everyone has the capacity to learn Haskell
15:47:17 <acowley> simpson: That type is fine, and wonderful. Lens is a zygohistopreprobazillion things beyond it, though.
15:47:42 <bitonic> cmccann: but the thing is, there are things to study if you want a deep understanding of Haskell, but CT is not that important and certainly not a requirement!  I mean here people will probably suggest TaPL as a first resource, which is much more sensible
15:47:47 <bitonic> well which worked with me anyway :P
15:48:01 <simpson> acowley: Most of which are dedicated to making that simple type more practical. :3
15:48:26 <cmccann> bitonic: the majority of those things that are important lend themselves very well to a category theory perspective
15:48:35 <cmccann> that does not mean that using category theory is mandatory
15:48:50 <bitonic> cmccann: well a myriad of things lend themselves to CTisnt that the point of CT?
15:48:51 <acowley> simpson: Sure, but I think telling someone that lens is mostly straightforward is a more effective way to scare people off than what bitonic is complaining about
15:48:54 <lambdazerocool> bitonic: people need to be able to think in (the haskell versions of) functors, applicatives, monoids, and monads in order to do basic things. a lot of people at my university find this daunting and gave up on haskell right after PL class ended.
15:49:13 <bitonic> cmccann: but they dont teach you CT before teaching you type theory/abstract algebra/topology/...
15:49:13 <cmccann> bitonic: it is indeed
15:49:18 <cmccann> yes
15:49:49 <cmccann> category theory is useless for learning Haskell, this is pretty obvious
15:50:06 <bitonic> so I dont get how can people come to the conclusion that CT is a requirement for Haskell.  and I dont like Haskell having this hard mathsy reputation, thats all
15:50:26 <cmccann> people come to that conclusion because it gives them an excuse to not try.
15:50:33 <cmccann> it's not a real reason. it's a rationalization.
15:50:50 <lambdazerocool> bitonic: it doesn't need CT, that's clear. however, it's certainly more mathsy than the go-to beginner imperative langs
15:51:02 <bitonic> cmccann: if somebody told me that CT is a requirement to understand Haskell it would have put me off
15:51:15 <zenware> Also since haskell has a bit of an unfamiliar syntax it can look totally foreign to some developers, giving it the impression of being complex and mathematical.
15:51:31 <cmccann> anyone who can program at all--and I'm excluding a lot of "professional" "programmers" here--is fully capable of learning haskell with or without category theory being involved.
15:51:43 <lambdazerocool> i think another big issue is the amount you need to understand before cranking out useful complete "standalone" programs, and this discourages beginners.
15:51:45 <zenware> It's similar to the reasoning non-programmers assume all programming is complex and mathematical.
15:51:57 <djahandarie> Knowing CT and/or Type Theory is needed to be considered a Haskell expert, I'd say.
15:52:01 <lambdazerocool> zenware: fully agree
15:52:02 <_malicious> I'm still learning haskell, I consider it rather mathsy, I think CT is more important the more I learn, and it doesn't put me off. It just gives me more to learn.
15:52:02 <acowley> bitonic: You're focusing on a reasonable but negative interpretation. The Haskell community's efforts at rigor are a huge asset. Many members push each other at leveraging theory to come up with useful abstractions, and it's a great thing.
15:52:34 <bitonic> lambdazerocool: but that has little to do with maths.  it has to do with the fact that Haskell programmers really like nice abstractions
15:52:42 <djahandarie> Not because you need CT or Type Theory to do Haskell, but because you need them to come up with cool new ideas in Haskell, and that's what being an expert is all about.
15:52:47 <_malicious> Feeling like CT is really important in Haskell makes me *want* to learn CT
15:52:47 <cmccann> djahandarie: I don't think it's necessary beyond the extent that it is inevitable anyway.
15:52:53 <bitonic> acowley: of course its a great thing.  Im saying that saying its a *requirement* is absurd
15:52:59 <acowley> djahandarie: Among some people, but there is a generation of folks who hardly reference CT at all (e.g. dons, bos, tibbe).
15:53:07 <eikke> indeed
15:53:15 <djahandarie> Oh, yeah, true. There's also the performance angle.
15:53:24 <cmccann> _malicious: that's the only reason most haskell programmers learn any CT, I think.
15:53:25 <lambdazerocool> bitonic: yes, but don't the abstractions kind of feel mathematical? i mean, i enjoy them, and they feel kind of mathy to me.
15:53:32 <eikke> there are the theoretical/math/... types and the 'engineering' types, and both are equally important (and strengthen each other) for the community
15:53:35 <cmccann> very few people already knew any CT before learning Haskell.
15:53:45 <bitonic> acowley: with the added irony that even if you wanted to cite theories that are useful, CT wouldnt be at the top, or second, or third (imo eh)
15:54:24 <bitonic> lambdazerocool: well again, saying that abstractions are mathsy is too vague.  its very precise statements like you need to know CT that scare off people
15:54:31 <eikke> you don't need much CT to implement a parallel & efficient IO-manager. That's mostly engineering-only. But it is important to get done.
15:54:34 <_malicious> I knew some very basic abstract algebra concepts before haskell, but had never heard of CT until haskell. I wanted to learn more advanced mathematics anyways, and haskell has just given me a reason to do so.
15:54:37 <acowley> Well, being pedantic about naming branches of mathematics isn't productive. Haskellers use CT as a catch-all because it seems to have some fitting sensibilities.
15:55:08 <acowley> bitonic: The quote you're referring to specifically says you don't need to know CT to program in Haskell.
15:55:32 <lambdazerocool> i think something that people forget, too, is that once upon a time, imperative programming was probably challenging at some point, too. i remember when pointers seemed difficult or foreign, once upon a time >.>
15:55:34 <acowley> bitonic: Don't get carried away with excerpting it.
15:55:37 <bitonic> acowley: eh?  I dont understand the pedantic and fitting sensibilities partIm saying that itd be more useful to cite other fields for people that want to go deeper
15:55:53 <bitonic> acowley: if you want to understand the theory behind Haskell or contribute to its development, some familiarity with category theory is a prerequisite.
15:55:59 <cmccann> bitonic: anyway, I suppose I'm just not that concerned about the weird impressions people might form about haskell because they listened to the opinions of people who had no idea what they're talking about.
15:56:04 <bitonic> acowley: this is blatantly false, agreed?
15:56:10 <cmccann> there's really no way to prevent that anyway.
15:56:52 <bitonic> cmccann: oh well, of course.  Im just wondering how this started because 5 hrs ago on #emacs I realised that a large fraction of people thinks that Haskell is about CT.
15:57:07 <acowley> bitonic: I know, I"m looking at that, you keep ignoring the preceding sentence. Even though the second sentence is stated too strongly, the first is completely against your excerpting of "you need to know CT" as something that scares off new Haskellers.
15:58:01 <bitonic> acowley: the sentence as a whole makes even less sense.  first it says that you dont need CT to use Haskell as a programming language.  BUT you need it to understand it?
15:58:12 <cmccann> also, category theory is prevalent enough as a language for talking about things that yes, it is required for understanding the theory and research behind Haskell.
15:58:29 <cmccann> but it's not that hard to pick up as you go.
15:58:36 <bitonic> 1. how else are you going to use Haskell? it is a programming language.  2. to use a programming language proficiently, you need to understand it
15:59:05 <cmccann> basically nobody in the real world understands the programming language(s) they use to the degree that knowing CT is relevant to understand haskell.
15:59:09 <acowley> bitonic: Why do you keep leaving out parts of the quote? It's bad enough on its own merits, you don't need to spin it so aggressively. Newcomers afraid of theory probably aren't looking at understanding the theory behind Haskell or contribute to the language as their first projects.
15:59:21 <bitonic> cmccann: no.  to understand how every piece of the type system works, you dont need CT.  to understand its semantics, you dont need CT.  to understand how to implement it, you dont need CT.
15:59:44 <cmccann> bitonic: to understand what people are saying about those things, you'll need to know what the CT jargon is.
15:59:52 <cmccann> it's about communication, not concepts.
15:59:54 <bitonic> cmccann: no, thats not true
15:59:59 <cmccann> and anyway, this is stupid. who cares?
16:00:22 <bitonic> the material available regarding Haskells type system/semantics/implementation doesnt even mention CT
16:00:22 <cmccann> if people are scared off because omg math then it's their loss.
16:00:40 <lambdazerocool> bitonic is in full nerd rage when the first sentence in the quote is "You don't need to know anything about category theory to use Haskell as a programming language."
16:00:49 <acowley> I'm with cmccann. Just blame shachaf if there's a problem.
16:00:51 <bitonic> acowley: yes, you are rightI got a bit worked up because people often bash on Haskell on the basis of this kind of thing
16:01:18 <bitonic> and I think its a pity, thats all.  since Haskell is extremely accessible
16:01:31 <cmccann> bitonic: those people would use whatever reason they had to bash it.
16:01:46 <cmccann> the causal relationship is in the opposite direction of what you seem to think.
16:01:50 <bitonic> cmccann: as a curiosity, what material are you referring to that explains Haskell and uses CT related jargon?
16:02:16 <bitonic> I read most of the papers regarding GHCs type system, for example, and CT never features.
16:02:37 <adnap> Hi
16:02:42 <bitonic> TaPL: no CT.  STG: no CT.  Hinley milner: no CT.
16:02:43 <cmccann> bitonic: CT jargon is very common in research papers
16:02:59 <cmccann> anyway, I don't care.
16:03:03 <cmccann> this discussion is stupid, I'm done.
16:03:19 <sacundim> hi everybody.  i need to ask a question i don't quite understand.
16:03:21 <bitonic> cmccann: can you give a concrete example?  Im actually curious now since I read a lot of this kind of papers
16:03:42 <simpson> sacundim: Well, ask the question, and we'll help you understand what you asked. :3
16:03:45 <sacundim> is the category of relations cartesian closed, and if not, why not?
16:03:51 <sacundim> http://ncatlab.org/nlab/show/Rel
16:04:09 * _malicious cant understand why anyone cares if people are scared of CT
16:04:24 <adnap> Does a C function which takes a struct pointer and uses it to modify the struct have side effects? I wonder if I could make this a side-effect-free Foo -> Foo function using the FFI.
16:04:35 <bitonic> _malicious: Id like people to embrace Haskell more, thats all
16:04:56 <bitonic> and I feel like a lot of them think its difficult and mysterious etc etc
16:05:16 <bitonic> like, all the time.  thats the response you get when you name Haskell
16:05:46 <_malicious> bitonic: if people are scared of CT, their loss. haskell community win: the community doesnt have to deal with people that don't like to learn or think
16:05:53 <eikke> main objections I hear are about "that can't be performant"
16:06:27 <bitonic> _malicious: thats not how it works.  there are excellent programmers that have no interest in CT whatsoever
16:06:35 <_malicious> I'd like haskell to get more respect and attention, but I'd like it to get respect and attention from people who are worth being around
16:06:53 <Iceland_jack> _malicious: And only people interested in picking up CT are worth being around? bs
16:06:59 <bitonic> in fact Id say most programmers that actually go and build useful tools have no interest in CT whatsoever :P
16:07:00 <_malicious> no
16:07:04 <_malicious> not at all.
16:07:15 <lambdazerocool> i think the quote you cited earlier would agree, bitonic. :D
16:07:43 <_malicious> people who find the first "obscure" detail of a language as an excuse to ignore it aren't worth programming with.
16:07:43 <Saizan> it's not about having an interest in CT, it's about not being afraid of new concepts along the way of picking up a new language and community
16:07:45 <lambdazerocool> in fact, it would agree even when they use haskell. especially when they use haskell, in fact.
16:07:51 <eikke> that way of thinking has a major drawback: what about engineers willing to learn/use/invest time in Haskell, but less-tech-savvy/educated/... 'manager' types don't 'get' it, and it's up to them to decide?
16:08:02 <enthropy> adnap: yes it has side-effects. You could pass in a copy of the original Foo, then return that copy to make it pure
16:08:09 <sacundim> i'm not interested in picking up CT for its own sake.  a lot of it is rather useful if you're trying to do denotational design, however.
16:08:58 <bitonic> Saizan: the thing that annoys me is that I see so many great people that just turn away because they predict a theoretical burden that *is not there*!
16:09:07 <eikke> those decission makers are the ones who decide after an hour of Google'ing around, and if they see lots of comments about "this is complicated", it's a no-go, despite of the pro's
16:09:39 <lambdazerocool> eikke: it can be even worse than that. someone once told me they like python because when you follow rigorous code standards, you can write really readable code in python.
16:09:57 <lambdazerocool> eikke: this was my manager on a project. we used python.
16:10:31 <eikke> lambdazerocool: well, actually you can IMO :-P
16:10:44 <simpson> bitonic: this is very much like looking at Python ten years ago.
16:11:08 <Saizan> bitonic: yeah, and i'd say they are right, if they are afraid of a potential theoretical burden why should they learn a language that has a learning curve even for "Hello world"?
16:11:12 <bitonic> simpson: when did Python have this impenetrability aura?
16:11:14 <simpson> bitonic: Because there is a *perceived* barrier to entry, the only people doing it are people whose curiosity and thirst for knowledge overcomes that.
16:11:20 <simpson> bitonic: Like I said, a decade ago.
16:11:26 <lambdazerocool> eikke: and this sets python apart *how* ? :-P
16:11:55 <simpson> bitonic: The point is that somebody who does Haskell right now says, "Yes, I *like* programming and improving my programming skills."
16:12:10 <simpson> Python was that marker; right now, Haskell and Clojure are those markers.
16:12:12 <bitonic> Saizan: wait wait: here were talking about a learning curve which is imaginary, since people imagine that very high level maths (read: category theory) is needed if you want to understand Haskell in depth.
16:12:20 <eikke> lambdazerocool: goh... it might be easier to get some Java/C#/whatever stuff to "work OK'ish" when multiple authors are using somewhat different coding practices, but that bytes a lot more in Python
16:12:36 <adnap> enthropy: I don't think I understand. Can you describe an unexpected result of trying to make a function, which modifies the struct referenced by the pointer argument, pure?
16:13:16 <Saizan> bitonic: but there's a very real learning curve too, and if you are afraid of the imaginary one i don't see you handling the real one well
16:13:21 <bitonic> simpson: Im not talking about that.  Im talking about Haskells reputation of having high level theoretical requirements if you want to do great work in it while its not true
16:14:11 <elliott> having big arguments like this supports that reputation
16:14:11 <bitonic> Saizan: I think thats a weak argument.  if Haskell did need CT, I would respect the choice of not learning ityou need to prioritise.
16:14:19 <eikke> that's what I liked about RWH: there aren't many books (even ones requiring some prior programming experience) where you write a barcode scanner in chapter... what is it, 8 or somethihgn? after writing your own image format parser library, that is :-)
16:14:20 <adnap> This argument is dumb. Anyway, I had a professor in college who introduced us undergrads to Haskell
16:14:39 <bitonic> elliott: I guess youre right I was just irritated by many other arguments regarding this.  I might go to bed :P
16:14:51 <chrisdone> my learning of haskell was: ooo concepts  oh more concepts  ok enough already i want to write code  ok i can write code  oo concepts  oooo
16:15:07 <Saizan> bitonic: you need CT for big parts of the community, and you need even more mind bending stuff to just code in it
16:15:14 <elliott> code is boring anyway. who writes programs?
16:15:29 <chrisdone> go back to #agda!
16:15:31 <mstksg> when learning haskell you honestly have to relearn a lot of how you appraoched any programming problems.  A good chunk of everything you've been trained to do (for loops, etc.) has to be thrown out the window.  everyone "approaches" a problem a certain way.  ask someone to write pseudocode for anything and you'll see how they work.  haskell forces you to completely re-learn almost all of this
16:15:49 <bitonic> Saizan: what do you mean you need CT for big parts of the community?  again, there are high profile programmers who shaped the Haskell community that never did CT-related work
16:15:52 <lambdazerocool> "Haskell's greatest strength stems from the fact that it derives all of its design patterns from mathematics, specifically category theory." -the lens tutorial i'm reading, in the spirit of this discussion. =D
16:16:12 <Saizan> bitonic: and there are high profile programmers which do
16:16:12 <lambdazerocool> mstksg: for sure =)  for me, that's part of the fun. for many, it hurts.
16:16:19 <eikke> mstksg: actually, wrt for-loops, I tend to let people write explicit recursion stuff first (e.g. to implement a for-loop), only later show higher-level combinators
16:16:34 <mstksg> lambdazerocool: true, but this is a real "barrier of entry"
16:16:46 <adnap> Can we talk about my very important question? :)
16:16:54 <simpson> I don't even know what's going on in here.
16:16:55 <bitonic> Saizan: of course.  given that situation, how is it reasonable to give the impression that you need CT to do good work (even research) in Haskell?
16:16:56 <elliott> lambdazerocool: that sentence is complete nonsense
16:17:07 <elliott> the one you quoted, I mean
16:17:12 <bitonic> agree with elliott...
16:17:12 <sacundim> i think the problem is that there aren't enough friendly, practical learning materials that bridge between the Learn You a Haskell level and the RankNTypes curry-howard denotational design category theoretical world.
16:17:19 <adnap> It has to do with Haskell and not people using Haskell
16:17:24 <elliott> whoever wrote it is in denial of the existence of Num
16:17:32 <cmccann> adnap: you can't fight in here, this is the war room!
16:17:34 <cmccann> er.
16:17:37 <Saizan> bitonic: let's put it like this: it's needed if you want to understand a lot of what the community talks about
16:17:43 <sacundim> people would learn that better if there was more material that gave them a feel for the concepts before the definitional infodump was thrown on them
16:17:46 <eikke> sacundim: RWH
16:17:50 <chrisdone> simpson: people blowing steam about how their shed is painted on the inside and how other people's new sheds should get the right kind of paint
16:17:54 <lambdazerocool> elliott: i suppose i should find a new lens tutorial? >.>
16:17:59 <sacundim> eikke: that's not it either.
16:18:00 <Saizan> bitonic: if you want you can ignore those parts
16:18:14 <mstksg> eikke: you use explicit recursion as a tool to move people to idiomatic haskell, but the fact that ther eis a bridge needed means that people have to readjust almost everything they know
16:18:19 <sacundim> eikke, I'm thinking things like "Rank 2 Types for Dummies!" material
16:18:45 <cmccann> lambdazerocool: just take the overenthusiasm about CT with a grain of salt
16:18:46 <sacundim> (fictional name)
16:18:59 <Saizan> bitonic: and anyhow, it's simpler stuff than the basic concepts you need for a bare understanding of haskell
16:19:01 <bitonic> Saizan: Id disagree with, but maybe your a lot is different.  and it still doesnt justify CT as a requirement.  there is a part of the community with edwardk/Tekmo leading that is doing great work with CT, but then there are many other areas
16:19:03 <lambdazerocool> cmccann: in both this discussion and the tutorial =D
16:19:12 <adnap> sacundim: That sounds good. I'm still a bit confused by Rank 2 types
16:19:19 <eikke> sacundim: http://research.microsoft.com/en-us/um/people/simonpj/papers/constraints/jfp-outsidein.pdf is pretty good
16:19:33 <eikke> sacundim: often the GHC docs about 'language extensions' do contain useful information & samples
16:19:37 <elliott> bitonic: I find that (your?) reddit comment ironic, btw, given that denotational semantics uses a fair chunk of category theory
16:19:40 <cmccann> sacundim: how about "Second Rank Types for Second Rate Programmers" instead. the "for dummies" thing just isn't insulting enough anymore. too watered down from use.
16:20:09 <enthropy> adnap: it means if you write  (impureFun x `seq` impureFun x), that might have a different value than   impureFun x
16:20:28 <adnap> What?
16:20:38 <bitonic> elliott: Im sure you can abstract a lot of stuff with CT in denotational semantics too, but again the material I read about denotational semantics never mentioned CT
16:20:42 <lambdazerocool> simpson: as far as i can tell, a lens is just a convenient way of having "getters" and "setters" in records?
16:20:48 <Nisstyre-laptop> Okay, so Data.Attoparsec.Binary doesn't have a parser for 8 bit words, probably because the normal Attoparsec library comes with that, but I'm wondering if the one in the normal library will parse BE or LE?
16:20:49 <chrisdone> cmccann: Monads for Morons?
16:20:53 <simpson> lambdazerocool: Yes, but it goes beyond records.
16:21:01 <enthropy> adnap: with pure functions the results are supposed to be the same
16:21:07 <plhk> Nisstyre-laptop: Binary?
16:21:07 <elliott> bitonic: you didn't read anything about recursive domain equations?
16:21:08 <lambdazerocool> simpson: yeah, anything that has (a -> b) and (b -> a -> a)
16:21:15 <bitonic> elliott: which part of Haskells semantics require CT to be understood?
16:21:19 <elliott> bitonic: they are necessary for giving e.g. a semantics to the untyped lambda calculus
16:21:20 <simpson> > M.empty & at 0 .~ 'a'
16:21:21 <kappabot>   Not in scope: `at'Not in scope: `&'Not in scope: `.~'
16:21:25 <simpson> Aw. :c
16:21:27 <elliott> I know of no published denotational semantics for Haskell
16:21:30 <cmccann> chrisdone: I always preferred the old-school internet meme reference of "Monads and Strife".
16:21:30 <simpson> < M.empty & at 0 .~ 'a'
16:21:37 <Nisstyre-laptop> plhk: http://hackage.haskell.org/packages/archive/attoparsec-binary/
16:21:42 <adnap> :t seq
16:21:43 <kappabot> forall a b. a -> b -> b
16:21:46 <Saizan> bitonic: that's roughly like saying you can calculate tangents with just algebra, that's true but calculus is a real help
16:22:08 <bitonic> elliott: I meant the denotational semantics that is useful to get insights regarding Haskell
16:22:25 <adnap> > seq 2 3
16:22:26 <kappabot>   3
16:22:34 <adnap> > const 2 3
16:22:35 <kappabot>   2
16:22:41 <plhk> Nisstyre-laptop: i meant this binary -> http://hackage.haskell.org/packages/archive/data-binary-ieee754/0.4.3/doc/html/Data-Binary-IEEE754.html
16:22:41 <chrisdone> cmccann: i just googled gonads and strife  that took me bad. early flash video days
16:22:43 <bitonic> Saizan: I dont think its quite the same.  Ive said this several times now, but the research material on Haskell barely mentions CT
16:22:51 <cmccann> chrisdone: it's a classic.
16:23:01 <bitonic> Saizan: e.g. the papers put out by the GHC people
16:23:01 <eikke> > newIORef 0
16:23:02 <kappabot>   Not in scope: `newIORef'
16:23:15 <Saizan> bitonic: yeah, but take wadler for example
16:23:18 <cmccann> chrisdone: back when everything on the internet looked like crap, so making things even crappier was entertaining.
16:23:48 <Nisstyre-laptop> plhk: oh, that has a parser?
16:24:18 <bitonic> Saizan: sure, but then you can go outwards in so many directions.  please keep in mind that Im just saying that we should not make beginners believe that if they want to do good work in Haskell theyll better learn CT, because thats going to scare them off
16:24:20 <olarf> hello guys, i've got a quick question: I want to implement a function to calculate the distance between a point and a plane. I dont really get started. I thought i could do it easyly because i am not new to programming but haskell is really kind of different.
16:24:28 <chrisdone> cmccann: haha, yeah. now these kids with their HD and lack of Buffering. makes me sick
16:24:36 <olarf> could someone have a quick look at my 10 lines of code?
16:24:39 <olarf> http://hpaste.org/88033
16:24:43 <cmccann> chrisdone: I know right
16:24:48 <enthropy> > (flip const undefined 1, seq undefined 1)
16:24:49 <kappabot>   (1,*Exception: Prelude.undefined
16:24:50 <Saizan> bitonic: i'm saying we shouldn't care because if so little scares them than Haskell itself will scare them more
16:24:56 <bitonic> Saizan: Im all for going on and about and learn about esoteric stuff, as you might have noticed :)
16:25:00 <cmccann> uphill over dial-up both ways blah blah
16:25:05 <enthropy> adnap: ^^ that's what's special about seq
16:25:07 <Saizan> bitonic: and wadler isn't exactly tangential wrt haskell
16:25:13 <olarf> and push me towards a solution
16:25:28 <plhk> Nisstyre-laptop: yes. http://hackage.haskell.org/packages/archive/binary/0.7.1.0/doc/html/Data-Binary-Get.html
16:25:32 <adnap> Okay, I think I understand. I'm going to think a while to formulate my next questions regarding the FFI
16:25:42 <bitonic> Saizan: I think that lets weed people out logic is not convenient.  people can be insecure at the beginning
16:25:53 <bitonic> but you can start by doing silly things and then ramp up
16:26:04 <cmccann> olarf: I think you're getting bitten by the DMR here
16:26:07 <elliott> is this avoiding success at all costs?
16:26:16 <dwcook> olarf, GHCi defaulted the types of those numbers to Integer in the absence of any type information.
16:26:22 <elliott> plenty of people want to learn haskell anyway. I don't think we have a major PR problem
16:26:22 <cmccann> olarf: try writing 0.0 and/or using explicit type annotations
16:26:24 <cmccann> then try again
16:26:28 <eikke> requiring your target audience to read and understand TaPL before being able to use your language, you bvetter close the books
16:26:29 <dwcook> One thing you can do is make it all one expression using letin
16:26:37 <dwcook> That will assign the types the way you want them
16:26:47 <dwcook> You can also explicitly mention the types
16:27:05 <bitonic> elliott: oh OK, I think we do :P.  not particularly concerned, Im just a bit tired to explain to people yes you are smart enough to learn Haskell
16:27:07 <chrisdone> eikke: i felt a little like that approaching Ur, but apparently you can learn it without having a degree in type theory
16:27:14 <dwcook> let planeXY = ((0,0,0),(0,0,1)) in distance (1,2,3) planeXY
16:27:22 <olarf> when i use 0.0 it's the same error with double and not integer
16:27:30 <cmccann> oh right
16:27:34 <dwcook> let planeXY = ((0,0,0),(0,0,1)) :: ((Float,Float,Float),(Float,Float,Float))
16:27:53 <cmccann> use explicit types I guess. or define planeXY in the file.
16:27:59 <dwcook> Right, so then it defaults to Double since Double is the default Fractional
16:28:30 <cmccann> olarf: the issue is that ambiguous types get assigned to their "most general" defaults give or take, otherwise you'd get ambiguity errors everywhere due to numeric literals
16:28:33 <bitonic> elliott: I dont know if you talk to programmers but there are very good programmers who actually think they are not smart enough for Haskell, or something like that.  which is ridiculous.
16:29:00 <cmccann> olarf: but it's a pain in cases like this where you just want to define something without having it defaulted to Integer or Double
16:29:12 <simpson> bitonic: It's because you can't code in anger.
16:29:16 <elliott> bitonic: i suspect that's more due to people who aren't really in the community
16:29:21 <olarf> ehm so what should i do?
16:29:24 <simpson> bitonic: And that is a *large* part of getting things done in many programming circles.
16:29:25 <elliott> just like the whole "monads are scary" nonsense
16:29:49 <bitonic> elliott: well yeah, but people dont get closer and thus dont get in the community because of that :)
16:29:55 <elliott> also, I don't think it's a CT-specific thing. type theory and denotational semantics are scary too!
16:30:04 <dwcook> olarf, write it in the file or take one of my suggestions
16:30:08 <cmccann> elliott: you're scary too.
16:30:18 <chrisdone> yeah, elliott is scary
16:30:21 <Nisstyre-laptop> plhk: sorry my connection died
16:30:22 <sacundim> actually, I think CT is scarier than either type theory or denotational semantics...
16:30:45 <plhk> Nisstyre-laptop: see http://hackage.haskell.org/packages/archive/binary/0.7.1.0/doc/html/Data-Binary-Get.html
16:30:46 <chrisdone> really?
16:30:49 <elliott> sacundim: ok, but for someone who knows nothing about any of them, the relative difference in scariness is irrelevant
16:30:52 <elliott> they're all scary
16:31:07 <sacundim> i'm finding it hard to assume that perspective
16:31:11 <chrisdone> everything i read about CT is like giving names to things i've already seen in haskell
16:31:22 <olarf> dwcook: thanks, i have overlooked your suggestions
16:31:29 <sacundim> particularly since i've had way more success understanding denotational and types than CT
16:31:30 <bitonic> elliott: yes, mine were really two points 1. you dont need anything special to create great software in Haskell 2. if you want to highlight things to study, dont insist so much on CT.  and now Ill go to bed :P
16:31:31 <olarf> dwcook: i will try this now
16:31:39 <Nisstyre-laptop> plhk: so basically I'd construct my own attoparsec parser with this right?
16:32:07 <plhk> Nisstyre-laptop: do you need attoparsec? actually, can you tell what are you trying to do?
16:32:09 <sacundim> basically, if you can do basic mathematical logic you can do denotational semantics and type theory without too much difficultyit only gets hard when you get ordered domains and such
16:32:17 <Nisstyre-laptop> plhk: writing a BSON parser
16:32:24 <sacundim> whereas CT just seems to assume all the time that you know a lot of math
16:32:47 <Nisstyre-laptop> I'm aware there's one on hackage
16:32:53 <Nisstyre-laptop> this is just for educational purposes
16:34:35 <plhk> Nisstyre-laptop: you can use binary's Get monad for that
16:34:55 <Nisstyre-laptop> plhk: okay I'll try that I guess
16:35:49 <olarf> ok thanks that solved my problem :)
16:43:20 <acowley> Can someone provide -XLocalInstances, please?
16:43:48 <adnap> So, if I can't make a pure fuction which changes the value of a memory location (i.e. a struct), but must instead make a copy, does this copying represent a fundamental time cost incurred by pure functions?
16:44:38 <tikhonjelvis> depends on what you mean by *fundamental*
16:44:45 <acowley> It's usually not much of a copy
16:44:47 <johnw> and if you mean C structs by "struct"
16:44:52 <adnap> I do
16:44:56 <tikhonjelvis> also, while the semantics may involve copying, the implementation does not have to
16:45:20 <johnw> to preserve correct semantics in C, you must copy
16:45:24 <adnap> By fundamental, I mean "for all"
16:45:45 <tikhonjelvis> oh, are we talking about C?
16:45:57 <tikhonjelvis> or just about programming in general?
16:45:58 <adnap> Sort of. Haskell and the FFI
16:46:09 <adnap> And core
16:46:10 <tikhonjelvis> ah
16:46:15 <tikhonjelvis> I thought this was more of a theoretical question
16:46:37 <johnw> adnap: pure functions are pure, you can't change the original C struct and still retain purity
16:46:50 <johnw> if you need efficiency, put your mutation function in IO
16:46:52 <adnap> How can you say "usually not much of a copy"? What if the struct takes up a lot of memory?
16:46:55 <c_wraith> adnap: in some cases, there's no performance difference. In some cases, there's a constant factor. It's been proven it's never worse than a factor of O(log n).  I don't believe it's proven that it ever has to be worse than a constant factor, but there are well-known problems no one knows how to do with only a constant-factor penality.
16:47:00 <Saizan> adnap: well, you can't do destructive updates in pure functions, unless you manage to seal the mutability inside something like ST
16:47:34 <c_wraith> Oh, by the way, you *can* hook FFI functions to an ST interface, if memory is all they modify
16:47:35 <tikhonjelvis> The O(logn) factor is a bit of a canard: it only exists because we conventionally assume that memory access is O(1)
16:47:49 <c_wraith> well, that's true
16:48:05 <tikhonjelvis> so it's one of those problems that only exists in practice, not in theory
16:48:47 <Saizan> adnap: i think acowley was referring to tree-like structures in haskell, where you can tipically share most of the old one with the new, "copying" only a path from the root to whatever you've modified
16:48:49 <cmccann> c_wraith: the log N slowdown is sometimes unavoidable with strict evaluation
16:49:04 <c_wraith> In fact, there are a bunch of native libs for which an ST interface would make a lot of sense.
16:49:15 <cmccann> c_wraith: afaik it's an open question with lazy evaluation (which is effectively a form of controlled mutation, to be fair)
16:49:28 <acowley> adnap: Yes, I was referring to what Saizan said.
16:50:36 <DanBurton> There was a blog post a few months ago about how types are "unit tests" or something like that. Anyone remember where that is?
16:52:05 <tikhonjelvis> honestly, that sounds like a pretty suspect blog post
16:52:12 <sacundim> DanBurton: just one?  I see similar points made very often
16:52:17 <sacundim> any more detail?
16:52:26 <DanBurton> it was an appeal to TDD people to use type systems
16:52:38 <adnap> Does n in the O(log n) cost refer to memory usage?
16:52:46 <tikhonjelvis> no, just running time
16:53:04 <DanBurton> sacundim: no more detail that I can remember. It might have been about dependent types... not sure.
16:53:08 <sacundim> DanBurton: vaguely rings a bell, but no, i can't retrieve it
16:53:09 <adnap> I don't get it...
16:53:12 <tikhonjelvis> I think the difference in memory usage is constant
16:53:21 <sacundim> was it on the pragmatic programmer site?
16:53:30 <sacundim> they did a series on dependent types
16:53:33 <DanBurton> possibly
16:53:45 <cmccann> tikhonjelvis: more opportunities for sharing may allow immutable data to use less memory, actually
16:54:01 <sipa> adnap: typically asymptotic complexity is given in function of input size
16:54:05 <tikhonjelvis> the basic idea is that you can replace mutable memory with a tree structure in functional programming
16:54:20 <sipa> (haven't followed exactly here)
16:54:21 <DanBurton> well the point is, my company had a tech talk where it was asserted that dynamic languages are "easier to test." I wasn't present at the talk but I'd like to participate in the aftermath emails by pointing out this idea
16:54:37 <cmccann> DanBurton: the pragprog articles sound relevant
16:54:39 <elliott> quickcheck sounds like a better response
16:54:41 <cmccann> even if not what you're thinking of
16:54:45 <c_wraith> ...  If by "test" you mean "mock objects", then that's true.
16:54:54 <tikhonjelvis> DanBurton: it sounds like they were conflating "static typing" with "Java"
16:54:59 <tikhonjelvis> which is an eternal curse on the entire field
16:55:10 <c_wraith> But mocking objects isn't a very good form of testing.
16:55:33 <mm_freak> could anyone recommend a LaTeX package for typesetting (commutative) diagrams?
16:55:34 * cmccann suggests with tongue in cheek that dynamic languages are easier to test because they result in more bugs that tests can find
16:55:47 <DanBurton> lol
16:56:04 <sipa> cmccann: duh, the compiler tests everything for you, right?
16:56:14 <sipa> at least if you encode all assumptions in the type system
16:56:35 <cmccann> sipa: no, the Haskell way to is to statically ensure that only really complex, devious bugs exist
16:57:05 <cmccann> and then to complain a lot and gaze longingly at agda
16:57:09 <mm_freak> sipa: i can fulfill every assumption using theGreatMotherValue
16:57:17 <mm_freak> theGreatMotherValue = theGreatMotherValue
16:57:19 <tikhonjelvis> fix id
16:57:25 <cmccann> > fix error
16:57:26 <kappabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
16:57:27 <DanBurton> fix myProgram
16:57:54 <elliott> mocking cmccann, on the other hand, is a very good form of testing.
16:58:43 <cmccann> whereas mocking elliott can be proven correct using agda.
16:58:45 <copumpkin> > fix show
16:58:46 <kappabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
17:00:14 <mm_freak> > fix$(0:).scanl(+)1
17:00:15 <kappabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:00:19 <mm_freak> perlskell
17:00:29 <cmccann> heh
17:00:56 <tikhonjelvis> the lesson is that the fix function exists to "fix" any type problems you may encounter
17:01:08 <sipa> :t break
17:01:09 <kappabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
17:01:11 <mm_freak> lol
17:01:23 <mm_freak> @remember tikhonjelvis the lesson is that the fix function exists to "fix" any type problems you may encounter
17:01:23 <kappabot> Done.
17:01:26 <acowley> :t \f -> improve (fix f)
17:01:27 <kappabot> Not in scope: `improve'
17:01:29 <acowley> darn
17:01:38 <acowley> I thought I'd covered debugging and optimizing
17:02:29 <sipa> > fix $ fst . break (const True)
17:02:33 <kappabot>   mueval-core: Time limit exceeded
17:02:34 <cmccann> > fix irc
17:02:36 <kappabot>   Sorry, it's hopeless
17:02:41 <sipa> :t irc
17:02:41 <kappabot> forall b. b -> Doc
17:02:56 * cmccann coughs
17:03:08 <no-n> > ir
17:03:08 <tikhonjelvis> > irc ()
17:03:09 <kappabot>   Not in scope: `ir'
17:03:09 <kappabot>   Sorry, it's hopeless
17:03:11 <sipa> so irc can turn anything into text
17:03:12 <no-n> > irc
17:03:13 <kappabot>   Overlapping instances for GHC.Show.Show
17:03:13 <kappabot>                              (b0 ->...
17:03:33 <cmccann> it's (const $ text "Sorry, it's hopeless") fyi
17:03:47 <tikhonjelvis> yeah, I managed to guess that :P
17:04:18 <no-n> what does const do?
17:04:26 <cmccann> ignores its second argument
17:04:33 <cmccann> @src const
17:04:33 <kappabot> const x _ = x
17:04:42 <no-n> ah
17:05:58 <acowley> I keep forgetting kappabot is a bot
17:06:40 <tikhonjelvis> perhaps you should not participate in any Turing tests then :P
17:06:50 <sacundim> huh, i'd never thought of fix show
17:09:05 <sacundim> so, i think when I get home I'm going to try and prove whether the category of relations is cartesian closed.  the problem is i know almost no category theories.  Any useful suggestions?
17:09:35 <adnap> So, a pure fuction will incur O(log n) extra time cost, where n is the running time of the impure fuction
17:09:42 <adnap> maximum...
17:09:49 <adnap> or worst case
17:09:58 <cmccann> adnap: that's more a matter of working only with immutable data
17:10:08 <adnap> What?
17:10:41 <adnap> Also, how can the time cost not depend on the memory usage? It takes longer to copy more memory
17:10:55 <cmccann> the same penalty applies to impure code if all values are immutable.
17:11:59 <c_wraith> adnap: it depends on the amount of memory that would be mutated, which is obviously at most O(running time)
17:12:01 <johnw> adnap: this isn't really about pure vs. pure, but about trying to use pure functions with non-persistent data
17:12:04 <johnw> vs. non-pure*
17:12:05 <adnap> That doesn't make sense. Why would you have immutable values in impure code. It's already impure
17:12:21 <cmccann> adnap: because immutable values are better, all else equal.
17:12:25 <acowley> Think const
17:12:28 <c_wraith> adnap: clojure and early are impure languages that default to immutable values
17:12:30 <cmccann> this is widely accepted in even mainstream languages.
17:12:32 <johnw> Haskell's pure functions, when used with persistent (aka immutable) data, are very efficient
17:12:32 <c_wraith> *erlang
17:12:33 <c_wraith> wtf
17:12:34 <adnap> The comparison I am making is between mutating and copying
17:12:44 <adnap> anyway
17:12:45 <sacundim> adnap, are you seeing "impure" as a disjoin set of "pure," or as a superset?
17:12:53 <adnap> wat
17:13:32 <johnw> it feels like adnap is saying "pure functions are slow because using pure functions with mutable data involves a lot of copying", which is confounding several separate ideas
17:13:34 <cmccann> adnap: keep in mind that you can always copy as shallowly as possible with immutable values.
17:13:50 <cmccann> because there's no harm in sharing pieces of a structure.
17:14:11 <sacundim> adnap: you seem to be saying that if a piece of code is impure it would not have immutable values
17:14:21 <adnap> no i'm not
17:14:25 <sacundim> oh, ok
17:14:39 <adnap> it's just that that is beside the point of the comparison I am making
17:14:42 <cmccann> the only time that copying would be any sort of issue is when dealing with immutable arrays, for which ST can often be used.
17:14:43 * hackagebot Extra 1.46.1 - A grab bag of modules.  http://hackage.haskell.org/package/Extra-1.46.1 (DavidFox)
17:22:00 <lambdazerocool> yesodweb is down. sure makes a great case for haskell for networking applications =D
17:28:38 <hiptobecubic> lambdazerocool, maybe the server went down?  :|
17:28:57 <acowley> I can't backtic expressions to make them infix?
17:29:31 <hiptobecubic> acowley, example?
17:29:33 <enthropy> nope
17:29:41 <acowley> foo `f x` bar
17:29:50 <DanBurton> lambdazerocool: I mentioned it on #yesod
17:30:06 <DanBurton> that channel is usually pretty quiet though
17:31:22 <DanBurton> acowley: correct, that is not valid Haskell
17:31:41 <acowley> DanBurton: Correct, perhaps, but disappointed.
17:31:57 <acowley> Well, slightly.
17:32:00 <acowley> It's pretty ugly
17:32:21 <DanBurton> I think there's something on the Haskell wiki about it
17:32:47 * applicative_ would be disappointed if backticks weren't so hideous anyway
17:33:10 <cmccann> acowley: I think the consensus is that it sounds tempting but it mucks the syntax and is ugly and not really worth it.
17:33:37 <acowley> Yeah, I just stumbled into a case where it was almost nice
17:33:44 <cmccann> most people have
17:33:51 <Liskni_si> For the record, I always wanted it.
17:33:53 <cmccann> but not often enough to justify it
17:34:14 <johnw> let is never very far away, in any case
17:34:16 <cmccann> if memory serves me it complicates a lot of other stuff in the grammar and/or creates a lot of weird syntactic special cases
17:34:30 <cmccann> which nobody likes without good justification
17:34:31 <johnw> cmccann: like foo `f `g x`` bar
17:34:54 <cmccann> johnw: right, the fact that anyone who wrote that should be slapped doesn't let GHC pretend it won't happen
17:36:16 <applicative_> the labor would be better spent on some really cool syntactic advance ... like uh ... I dont know which
17:36:22 <tikhonjelvis> mixfix!
17:36:32 <cmccann> oh god
17:36:46 <RoboTeddy> anyone have a recommendation for stuff to read on haskell after reading LYAH? or should I go try to write a program?
17:36:55 <cmccann> go forth and code
17:37:00 <applicative_> let tikhon x jelvis = x + 1
17:37:00 <tikhonjelvis> oh, you should *definitely* go write a program
17:37:15 <RoboTeddy> tikhonjelvis, cmccann: ok, cool, thanks.
17:37:32 <cmccann> RoboTeddy: you'll probably get stuck at some point. that's when you ask for help and/or look for more things to read.
17:37:36 <applicative_> what kind of program do you like RoboTeddy
17:37:47 <applicative_> just don't dont answer, quadruple shooter ....
17:39:17 <applicative_> the type checker doesnt let violent games pass
17:39:25 <RoboTeddy> I might try to write an evolutionary simulation or something. any tips on how to draw onto a surface of some sort in order to show what's happening inside the sim?
17:39:42 <RoboTeddy> or I could just go google; I'll ask here if I get stuck. thanks everyone
17:39:52 <cmccann> hm, is that something gloss would work for?
17:39:56 <enthropy> depends what kind of data you have
17:39:57 <tikhonjelvis> you could take a look at the diagrams package
17:40:08 <tikhonjelvis> that might not be ideal for animations though
17:40:09 <cmccann> yeah, see if gloss or diagrams does what you want first I think
17:40:11 <enthropy> also Chart isn't bad
17:40:17 <dmwit> RoboTeddy: diagrams, or just cairo if that's your cup of tea
17:40:39 <dmwit> cairo is pretty beautiful, for C
17:40:48 <RoboTeddy> sweet. lots of options! I now have +4 browser tabs
17:40:49 <cmccann> dmwit: oh btw the organization I put on the hac phi registration email may be very slightly fake and not real
17:40:56 <applicative_> gloss is one of the simpler ways to draw something moving. Its deliberately somewhat stripped down.
17:40:56 <cmccann> dmwit: just in case you were wondering
17:40:58 <dmwit> I noticed. =)
17:41:05 <dmwit> I also smiled a lot, and laughed at the joke on your website.
17:41:22 <cmccann> which joke was that again? I can't even recall.
17:41:32 <dmwit> uptoisomorphism.net; it's just not quite the same
17:41:32 <acowley> I've used gloss for simulation vis before
17:41:35 <cmccann> oh, is it the "not quite the same" thing?
17:41:36 <cmccann> yeah
17:41:40 <acowley> a lot, actually
17:41:50 <tikhonjelvis> is hac phi coming up soon?
17:41:56 <dmwit> Yes, just three weeks away!
17:42:00 <djahandarie> Oh god. :(
17:42:00 <dmwit> You should register. =)
17:42:02 <tikhonjelvis> in June then?
17:42:06 <dmwit> June 7-9
17:42:06 <alireza> I have a question
17:42:08 <tikhonjelvis> ooh
17:42:09 <luite> too soon!
17:42:11 <dmwit> I have an answer!
17:42:13 <tikhonjelvis> then I actually might
17:42:15 <alireza> can I just post it here?
17:42:17 <djahandarie> I don't think I'll be able to make it this time.
17:42:19 <dmwit> ?where justask
17:42:20 <kappabot> I know nothing about justask.
17:42:22 <cmccann> tikhonjelvis: doooooooo iiiiiiiit
17:42:23 <tikhonjelvis> I mean, that's sort of close to New York, isn't it?
17:42:33 <cmccann> djahandarie: :[
17:42:33 <dmwit> alireza: ...yes, don't ask to ask, just ask
17:42:33 <acowley> alireza: Yes!
17:42:51 <tikhonjelvis> I know it's on the East coast, but I think everything east of the Rockies is the East coast
17:42:51 <dmwit> tikhonjelvis: Just a few hours by bus, even less by other modes!
17:43:03 <djahandarie> There's a possibility I might be starting a job on June 10th, which would make that some incredibly difficult timing.
17:43:16 <dmwit> djahandarie: ah, bummer
17:43:17 <alireza> what is the meaning of this operator "=<<" in haskell?
17:43:17 <applicative_> RoboTeddy: there are some simple to not so simple examples in http://hackage.haskell.org/package/gloss-examples
17:43:25 <cmccann> djahandarie: ok yeah that's  a good excuse :[
17:43:25 <applicative_> flip >>=
17:43:27 <tikhonjelvis> it's >>= backwards
17:43:27 <dmwit> djahandarie: Still, even if you can only come for the 7th and 8th, we'd love to have you.
17:43:28 <RoboTeddy> applicative_: thank you!
17:43:35 <dmwit> ?src (=<<)
17:43:35 <kappabot> f =<< x = x >>= f
17:43:37 <acowley> djahandarie: Let me know if finding a bed is still an issue
17:43:48 <juliohm> Oh the Haskell land, i want to be in there someday.
17:43:57 <djahandarie> acowley, will do, thanks!
17:44:09 <acowley> djahandarie: I can probably find you a lab floor where you'll have an espresso machine right next to you if NJ is too much of a hassle
17:44:18 <djahandarie> Hahaha.
17:44:19 <alireza> what does  f =<< x = x >>= f  mean?
17:44:27 <cmccann> acowley: that sounds like excellent lodging
17:44:28 <tikhonjelvis> it defines a function called (=<<)
17:44:28 <Viaken> Could I get a quick comment for a noob? http://hpaste.org/88035
17:44:33 <tikhonjelvis> taking two arguments
17:44:34 * djahandarie doesn't drink caffeine
17:44:37 <tikhonjelvis> with a body of x >>= f
17:44:41 <acowley> cmccann: A guy I work with sleeps there sometimes, but he's out of town
17:44:44 * hackagebot BlogLiterately 0.6.0.2 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.6.0.2 (BrentYorgey)
17:44:55 <juliohm> Wow, #haskell already has more participants than #python!
17:45:06 <Fuuzetsu> Rightfully so~
17:45:07 <juliohm> That's extraordinary fact
17:45:08 <acowley> cmccann: graduate students are a hardy bunch
17:45:19 <acowley> djahandarie: There's also a water cooler
17:45:26 <alireza> i dont understand. .... can you explain more?
17:45:26 <acowley> djahandarie: And a giant robot
17:45:37 <djahandarie> Giant robot? Sold.
17:45:43 <djahandarie> Does it have a cockpit?
17:45:51 <alireza> can you explain more about f =<< x
17:45:53 <cmccann> Viaken: Haskell doesn't do implicit numeric conversions
17:45:57 <acowley> djahandarie: It's not that giant. And it hit me in the head several times yesterday.
17:46:07 <alireza> in f =<<x , is f a function and x an input?
17:46:14 <cmccann> Viaken: you claim to return a Double, and arithmetic operates on single types
17:46:28 <acowley> alireza: It is defining the (=<<) function that takes two arguments, f and x.
17:46:33 <djahandarie> alireza, wherever you see the expression "f =<< x", just replace it with "x >>= f".
17:46:36 <applicative_> alireza: sort of
17:46:41 <cmccann> Viaken: so it complaints that you tell it something is polymorphic when it thinks it should be a Double
17:46:46 <djahandarie> If your question is what the second expression does, then that's another question. :)
17:46:59 <applicative_> djahandarie: so when I see x >>= f , does that mean, f is a function and x is an input?
17:47:09 <Viaken> cmccann: Ok. So what should I claim to return?
17:47:36 <cmccann> Viaken: just remove the type signature, load the file in GHCi, and then use :t distance_2d
17:47:41 <cmccann> that will show you the inferred type
17:47:49 <cmccann> which will be the most generic one that makes sense
17:47:55 <Viaken> oh ok
17:48:08 <cmccann> alternatively, you could make it work only with Double if you wanted that for some reason
17:48:36 <cmccann> but unless you have a specific reason to do something else, the inferred type will probably be best here
17:49:32 <applicative_> alireza: something like readFile applies to a string, so readFile "x.txt" is the action of looking at the contents of x.txt, considered as a String. but readFile =<< getLine is the action of looking at the contents of the file the user names
17:49:34 <Viaken> No specific reason. I'm just working on understanding the type declaration.
17:49:49 <Fuuzetsu> cmccann: You landed more quotes than shachaf in HWN this week again.
17:49:52 <applicative_> String is being used too many places in that sentence
17:50:06 <Fuuzetsu> week's*
17:50:11 <cmccann> Fuuzetsu: how embarrassing
17:50:22 <acowley> Fuuzetsu: Were his quotes at least burns directed at shachaf?
17:51:26 <cmccann> one was about the HWN quotes being mostly shachaf.
17:51:29 <cmccann> the irony is staggering.
17:52:25 <cmccann> acowley: anyway, there's three of yours in there, so ha.
17:52:30 <applicative_> the HN quotes section has gone very much meta
17:52:37 <applicative_> HWN
17:52:41 <acowley> What?
17:52:50 <cmccann> acowley: http://contemplatecode.blogspot.com/2013/05/haskell-weekly-news-issue-267.html
17:53:43 * applicative_ is worried alireza hasnt found a proper elucidation
17:53:47 <acowley> Hm.
17:54:14 * Fuuzetsu has never made it into HWN
17:54:17 <applicative_> the culinary one is a little opaque
17:54:22 <alireza> i am trying to parse your sentence
17:54:23 <Fuuzetsu> I feel kind of good about it.
17:54:26 <alireza> :)
17:54:41 <tikhonjelvis> applicative_: probably missing some context
17:54:41 <acowley> applicative_: It is. I remember it being funny, so there's that.
17:55:12 <alireza> so I am applying a function called readFile on x
17:55:26 <alireza> readFile :: String -> String?
17:55:32 <acowley> :t readFile
17:55:33 <kappabot> FilePath -> IO String
17:55:35 <alireza> is this a possible type for readFile?
17:55:36 <applicative_> alireza: right, the argument, x is a String, or equivalently FilePath
17:55:37 <alireza> OK
17:55:38 <alireza> OK
17:55:48 <applicative_> but it is not String -> String , but String -> IO String
17:55:48 <alireza> so readFile gives me a sort of String.
17:56:06 <applicative_> alireza: no, it maps FilePaths to actions
17:56:21 <applicative_> operations, things that might be done, etc
17:56:28 <alireza> OK, actions are the programs which do the IO
17:56:34 <applicative_> but that 'return a string' as they say
17:56:44 <alireza> I know what an action is
17:56:54 <alireza> it is one of those things do blocks
17:57:00 <alireza> it is one of those things "do" blocks
17:57:08 <alireza> I understand up to this bit.
17:57:23 <BMeph> ...or DO you?!? Hmm?? ;
17:57:37 <Entroacceptor> it's not actually that way
17:57:43 <alireza> So now what this : readFile =<< getLine
17:57:47 <alireza> again?
17:57:53 <acowley> I want to +1 the suggestion go move Foldable and Traversable (and Applicative) to the Prelude, but someone needs to try to quantify how much will break and I don't want to be that person.
17:58:03 <applicative_> an IO a is an 'action that returns an a', as digging carrots is an action that returns carrots
17:58:29 <alireza> i see.
17:58:40 <applicative_> similarly putChar 'a' ought to be understood literally as the sort of thing you do when you write the letter 'a'; fortunately a computer can do it for you
17:58:44 <tikhonjelvis> applicative_: that's an interesting choice of an example
17:58:46 <alireza> so what is the "readFile x =<< getLine "
17:58:57 <alireza> I see
17:58:57 <enthropy> acowley: probably too much. Even small stuff like removing the useless catch broke tons of stuff
17:59:12 <applicative_> it would be readFile =<< getLine
17:59:18 <acowley> enthropy: Yeah, I think it would cause too much chaos, but I'm really saddened by that.
17:59:24 <tikhonjelvis> It would be nice to just bite the bullet and break lots of stuff one of these days
17:59:33 <tikhonjelvis> of course, I say this because I don't have to maintain any legacy code :P
17:59:38 <applicative_> it is the action of reading whatever file that the user names
17:59:40 <alireza> applicative_  how do you read it in English.
17:59:50 <alireza> ?
17:59:53 <johnw> things have been broken before, people survived
17:59:58 <applicative_> 'read the file that the user inputs'
18:00:17 <acowley> I'd be fine with an easy-to-use opt-in mechanism for Haskell2013 or something.
18:00:44 <applicative_> as I read getLine >>= readFile as 'find out file the user is naming and read that file'
18:00:49 <tikhonjelvis> I think opt-out would be fine too, as long as you could just mark old code with a single pragma per file or something
18:01:23 <alireza> getLine is a function which is of type "IO String"
18:01:30 <alireza> OK.
18:01:50 <applicative_> like dig carrots >>= boil is digging carrots and then boiling the ones you come up with, as boil theCarrots is boiling whichever carrots theseCarrots are
18:01:50 <alireza> So I could say: "nameOfTheFile <- getLine "
18:01:58 <acowley> tikhonjelvis: I'd be fine with that, too.
18:02:00 <applicative_> alireza: yes exactly
18:02:32 <applicative_> then the next line could be filecontents <- readFile nameOfTheFile
18:02:41 <alireza> yes
18:02:42 <alireza> yes
18:02:57 <alireza> are you saying all those steps are done by just this "=<<"
18:02:58 <alireza> 
18:03:04 <alireza> ?
18:03:29 <applicative_> then if the next line is putStrLn filecontents, the whole thing is sort of like a 'cat' operation
18:03:52 <dwcook> alireza, x >>= y is sort of like "do x then give its output to y"
18:04:16 <dwcook> (and =<< is just the flip of that)
18:04:22 <applicative_> well , a complete operation, a 'file printer' action would be putStrLn =<< readFile =<< getLine
18:04:39 <alireza> i see
18:04:54 <cmccann> putStrLn "can haz cheezburger???" -- 'cat' operation
18:04:54 <alireza> so it is again a syntax sugar
18:04:59 <applicative_> this is a little more intelligible in 'do notation' I guess.
18:05:10 <applicative_> cmccann: yeah, sort of in that sense
18:05:18 <alireza> i see
18:05:20 <Mortomes> do notation is syntactic sugar for >>=
18:05:28 <no-n> oh
18:05:29 <applicative_> alireza: do notation is supposed to be the 'sugar'
18:05:48 <alireza> applicative. you were amazing. thanks.
18:06:01 <cmccann> "do" is the sugar, (>>=) is the bitter plate of steamed broccoli.
18:06:08 <no-n> hehe
18:06:10 <dwcook> s/bitter/delicious/
18:06:13 <dwcook> :)
18:06:20 <no-n> I like steamed broccoli!
18:06:28 <cmccann> bitter and delicious are not mutually exclusive!
18:06:34 <Hermit> specially with noodles
18:06:34 <Mortomes> do notation considered harmful to teeth
18:06:37 <no-n> omg, I've grown up! NO!
18:06:38 <dwcook> Sure, you just emphasize different traits
18:06:43 <johnw> mmm coffee
18:06:45 * cmccann likes his beer very hoppy, for one thing
18:06:47 <dwcook> no-n, I hate it when that happens.
18:07:06 <alireza> guys, this is my first experience with IRC. is there any way two people can directly chat without seeing the flood of all messages?
18:07:17 <dwcook> alireza, /msg whoever message
18:07:19 <Hermit> /quote nick
18:07:24 <Hermit> err
18:07:25 <no-n> /query nick
18:07:26 <Hermit> /query nick
18:07:37 * Hermit is just too used to /q nick
18:07:55 <Entroacceptor> but be warned, a lot of people don't like if you do that out of the blue
18:07:57 <elliott> alireza: note that it's generally considered impolite to message people out of the blue
18:08:00 <cmccann> yeah
18:08:11 <cmccann> the purpose of IRC is group chat
18:08:17 <elliott> and that generally help should be done in public, since it benefits everyone (people reading at the time, and the channel's searchable public logs)
18:08:24 <dwcook> As a general rule, if you find someone in a channel for a particular topic, don't message them about that topic unless they say it's okay
18:08:32 <alireza> i see.
18:08:42 <Entroacceptor> and I love reading how the understanding gradually enters the mind
18:08:57 <johnw> plus, sometimes one's answers deserve correction by the larger group
18:09:05 <tikhonjelvis> yes
18:09:12 <tikhonjelvis> like the nonsense claims about brocolli!
18:09:13 <no-n> ya
18:09:50 <dwcook> Indeed, I find comfort in being able to be corrected by the channel at large
18:09:55 <dwcook> I don't like accidentally misleading people
18:10:06 <johnw> or joy when you finally answer a question and don't get corrected by everyone :)
18:10:13 <dwcook> (only intentionally doing it)
18:10:15 <cmccann> yeah, saying something stupid in front of 1000 other people is nothing to worry about it ;]
18:10:16 <dwcook> (:P)
18:10:19 <meiji11> i'm trying to install ghc-heap-view with cabal, and am having some issues with bytestring-0.10.0.2. it says the package is hidden. I've tried 'ghc-pkg expose bytestring'.. to no avail.
18:10:21 <elliott> the feeling is mutual: pedantic wiseguys like me find comfort in correcting others!
18:10:34 <dwcook> Yeah, I play both ends of the spectrum depending
18:10:46 <Hermit> alireza: >>= is very nice when making chains where you don't want to name every single output like you would in do notation. You can mix them as you see fit though. I tend to stay away from do, unless I need one of it's redeeming properties: let and monads' fail method call on pattern match errors
18:10:47 <dwcook> Find me in ##javascript and I'll pedantry your pants off
18:10:53 <dwcook> Not literally, oh god not literally
18:11:04 * elliott is surprised at the implication that there are objective truths about javascript
18:11:12 <tikhonjelvis> also, you can't have a good bike shedding without involving the whole group
18:11:16 <cmccann> dwcook: I should hope not, I mean really? javascript? ew.
18:11:17 <dwcook> elliott, one must simply look to the spec
18:11:32 <dwcook> cmccann, hey, some people are pretty excited by JS
18:11:33 <elliott> dwcook: good one. we haskellers have that joke too
18:11:40 <tikhonjelvis> well, except when browser fail to implement the spec properly
18:11:42 * applicative_ doesn't mind being corrected except when it's blather about bottom
18:11:45 <acowley> dwcook: You really need to think of a better way to say that
18:11:52 <applicative_> there's no bore quite like a domain theory bore
18:11:53 <elliott> though mostly for reasons of incompleteness than being disobeyed...
18:12:00 <dwcook> acowley, who said I didn't intend to say it that badly?
18:12:17 <elliott> applicative_: poor conal :p
18:12:18 * acowley makes a note to be wary of ##javascript
18:12:45 <tikhonjelvis> I used to like JavaScript, but then I found that I could just compile OCaml to JS instead
18:12:46 * applicative_ makes a special exception for conal, it's a religious thing in his case
18:13:04 <tikhonjelvis> unfortunately, the Haskell  JS solutions have not been very satisfying though
18:13:22 <dwcook> applicative_, why are people making remarks about your bottom?
18:13:27 <alireza> just out of curiosity, if this place i s for talking Haskell, then why are there so much discussions about non-Haskell? is it something normal?
18:13:46 <tikhonjelvis> most of the discussions are at least *tangentially* related to Haskell
18:13:48 <alireza> just asking.
18:13:52 <alireza> :)
18:13:54 <alireza> haha
18:13:55 <cmccann> alireza: conversation tends to drift until someone complains and/or says something on-topic
18:13:55 <applicative_> > snd (error "dwcook", 3)
18:13:56 <kappabot>   3
18:14:03 <alireza> i see
18:14:13 <cmccann> and by "someone complains" I mean shachaf says to stop talking.
18:14:21 <acowley> alireza: The conversation wanders when there's nothing more pertinent on the table. If it's a problem, people are encouraged to take off-topic topics to #haskell-blah
18:14:35 <alireza> so I can hope that when next time I come here desperate to ask a haskel question, then people care enough about answering my question. Thats Fab
18:14:35 <applicative_> alireza: people just wait for questions like yours, don't let other blather impede you; the place can handle 5 - 10 conversations at onc
18:14:49 <pdxleif> You can also compile idris to javascript
18:14:57 <elliott> applicative_: it can? :P
18:15:01 <pdxleif> and roy, links, opa, fay, yadda yadda...
18:15:16 <applicative_> alireza: occasionally they are too excited by their blather to notice the question of course
18:15:18 <tikhonjelvis> the *place* can: I'm not sure any given person can though
18:15:22 <acowley> Why does lens export the Traversable type but not Foldable?
18:15:30 <cmccann> alireza: unless you walk into the middle of a stupid argument over something on which many people have a surplus of opinions and a surfeit of brevity, you should be fine.
18:15:32 <tikhonjelvis> hmm, I'm not convinced by Opa and Fay doesn't have enough features yet
18:15:45 <johnw> acowley: why would it, if it doesn't have to?
18:15:53 <tikhonjelvis> Roy is neat, but I don't see too many reasons to use it over OCaml
18:15:57 <tikhonjelvis> and a bunch not to
18:15:58 <elliott> cmccann: wow, you just described IRC perfectly.
18:16:06 <jmcarthur> hi tikhonjelvis!
18:16:14 <tikhonjelvis> hello
18:16:19 <Mortomes> > Nothing >>= (return . repeat)
18:16:20 <acowley> johnw: lens is about absolutely crushing your namespace in the name of edwardk's convenience. I expected Foldable to be part of that.
18:16:20 <kappabot>   Nothing
18:16:21 <cmccann> elliott: no, only IRC when people are talking.
18:16:29 <tikhonjelvis> also, I remember a paper about compiling Agda down to HTML5, which seems very promising
18:16:38 <applicative_> alireza: StackOverflow gives prompt answers as well, but they need suitable focus and so on.
18:16:50 <alireza> i see. thanks
18:16:54 <jmcarthur> tikhonjelvis: i'll be seeing you again pretty soon i guess
18:16:56 <alireza> good to know
18:17:18 <tikhonjelvis> yep
18:17:27 <tikhonjelvis> coincidentally, do you know if anybody is planning to go down to Hac Phi?
18:17:34 <Cale> Let's try unmuting lambdabot for a bit
18:17:46 <jmcarthur> i'm considering, since cmccann just reminded me of its existence today...
18:18:03 <tikhonjelvis> it seems interesting, but I have no idea of how to get there
18:18:09 <Cale> > 2^5
18:18:10 <kappabot>   32
18:18:15 <byorgey> tikhonjelvis: where do you live?
18:18:18 <jmcarthur> from nyc you can take amtrak easily
18:18:23 <tikhonjelvis> I'll be in New York
18:18:33 <tikhonjelvis> right now I'm in the Bay Area, which is maybe a tad less practical
18:18:35 <byorgey> yes, amtrak is quite convenient
18:18:38 * cmccann is actually doing the amtrak thing as well, it ended up being the easiest way
18:18:43 --- mode: ChanServ set +o Cale
18:18:44 --- mode: Cale set -q lambdabot!*@*
18:18:49 <tikhonjelvis> luckily, Bay Hac is this week :)
18:18:53 <Cale> > 2^5
18:18:53 <kappabot>   32
18:18:56 <lambdabot>   32
18:19:00 <acowley> !
18:19:01 <byorgey> \o/
18:19:04 <cmccann> bot stereo
18:19:06 <Cale> Still a bit slow, but maybe it'll work for now?
18:19:07 <Mortomes> > Nothing >>= (return . repeat)
18:19:08 <kappabot>   Nothing
18:19:09 <lambdabot>   Nothing
18:19:16 <cmccann> > fix error
18:19:17 <kappabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
18:19:18 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
18:19:20 <jmcarthur> ugh
18:19:21 <djahandarie> > x^x
18:19:23 <Mortomes> hahaha
18:19:24 <kappabot>   mueval-core: Time limit exceeded
18:19:25 <jmcarthur> stop it stop it
18:19:26 <lambdabot>   mueval: ExitFailure 1
18:19:26 <lambdabot>  mueval: Prelude.undefined
18:19:29 <djahandarie> > 3
18:19:30 <kappabot>   3
18:19:31 <lambdabot>   3
18:19:33 <jmcarthur> STOP
18:19:44 --- mode: Cale set +q kappabot!*@*
18:19:48 <jmcarthur> :)
18:19:51 <hiptobecubic> poor kappabot :(
18:19:52 * djahandarie was just testing what seemed to screw up lambdabot last time.
18:19:55 <elliott> kappabot: @part
18:19:58 <elliott> hm.
18:20:00 <elliott> kappabot: @part #haskell
18:20:05 <cmccann> well, everyone missed lambdabot :[
18:20:11 <cmccann> kappabot just wasn't the same.
18:20:21 <cmccann> I blame shachaf, obviously.
18:20:28 <Hermit> Mortomes: those parens are redundant
18:20:41 <byorgey> tikhonjelvis: anyway, you should definitely come, it is always a ton of fun =)
18:20:49 <Cale> shachaf's machine is faster or better connected to the internet than lispy's linode apparently
18:21:01 <hpc> i blame linode
18:21:03 <wagle> anyone know why haskellers and yesodweb are down?  (or bring them back up?)
18:21:06 <djahandarie> It is fun!
18:21:07 <elliott> > let test = () in tst
18:21:07 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
18:21:08 --- mode: Cale set -o Cale
18:21:08 <cmccann> byorgey: I'm actually like officially going and stuff now. I sent an email to dmwit and everything!
18:21:12 <elliott> awwww.
18:21:15 <elliott> my trick revealed.
18:21:25 <hiptobecubic> haskellers too?
18:21:25 --- mode: ChanServ set +o elliott
18:21:28 <Cale> hpc: I do too, I can't see anything in particular which is wrong with lambdabot or mueval
18:21:28 --- mode: elliott set -q kappabot!*@*
18:21:33 <elliott> in case it's needed again lter.
18:21:34 <elliott> a
18:21:36 --- mode: elliott set -o elliott
18:21:37 <byorgey> cmccann: sweet!
18:21:45 <hpc> Cale: anything that doesn't let you own the hardware i don't trust
18:21:46 <Cale> hpc: It was just randomly dying well before the timeout
18:22:00 <elliott> maybe the system clock was off or something.
18:22:00 <Cale> Now it seems... okay
18:22:03 <djahandarie> Cale, did you check if it was the OOM killer? (Via dmesg)
18:22:04 <Cale> But I haven't done much
18:22:07 <hpc> put a box in a colo, but virtual hosting..
18:22:19 <djahandarie> (You confusingly don't always need to be OOM to hit the OOM killer.)
18:22:23 <byorgey> cmccann: wait, have you been before?  I don't recall meeting you
18:22:24 <Cale> hmm
18:22:27 <lambdazerocool> i was afk forever, but i'm glad roboteddy took a look at LYAH =D. I told him to check it out yesterday
18:22:31 <cmccann> byorgey: nope
18:22:34 <Cale> Well, if it happens again, I'll check that
18:22:39 <lambdazerocool> LYAH is probably my favorite n00b resource
18:22:44 <byorgey> cmccann: excellent, it will be great to meet you
18:23:09 <lambdazerocool> (it is how i became a n00b myself :D)
18:23:16 <byorgey> lambdazerocool: =)
18:23:21 <cmccann> byorgey: I was in boston for an interview and met a few people there, which maybe gave you the impression I'd shown up to an actual event of some sort :P
18:23:52 <elliott> cmccann has never been anywhere before. bayhac will mark the first time his spiritual essence takes physical form.
18:23:59 <byorgey> hahaha
18:24:02 <johnw> lol
18:24:05 <cmccann> yes, that sounds plausible.
18:24:07 <johnw> cmccann: coming to ICFP?
18:24:22 <elliott> he may materialise in the middle of the room. do not be alarmed.
18:24:24 <pdxleif> wagle: maybe they're not stateful and dynamic enough?
18:24:33 <lispy> Cale: oh no!
18:24:50 <lispy> Cale: I think having swap turned on has been a bad idea
18:24:59 <cmccann> johnw: no, hac phi is enough of a public appearance to last me for a year or so I think.
18:25:02 <acowley> I want to think of an intelligent costate question to ask of cmccann at HacPhi, perhaps relating to his materializing out of nowhere.
18:25:18 * djahandarie would like to go to ICFP but has no idea how that even works
18:25:23 <byorgey> it takes a lot of energy to physically manifest
18:25:34 <cmccann> yes, it is very tiring.
18:25:51 <byorgey> djahandarie: you sign up.  then you pay a lot of money (less for students).  then you go.
18:25:58 <wagle> m = ec^2
18:26:04 <wagle> oops
18:26:08 <wagle> nm
18:26:19 <wagle> jokes over, nothing to see here
18:26:39 <cmccann> the money thing may also be involved in why I'm not going to ICFP. :P
18:27:11 <elliott> djahandarie: byorgey forgot to mention the goat sacrifices. those are important too
18:27:18 <djahandarie> wagle, those are some fat electrons
18:27:42 <cmccann> I am pleased that sclv's terrible galois joke is in HWN.
18:27:45 <djahandarie> Like 7000 kgm^4/s^4 fat!
18:27:50 <cmccann> so that other people can feel guilty for laughing at it too.
18:28:08 <djahandarie> byorgey, hmmm. :(
18:30:09 <lispy> looks like they stopped updating the website version? http://sequence.complete.org/hwn
18:30:14 <cmccann> byorgey: anyway yes. just look for a guy with a beard wearing glasses and jeans, then try to guess who out of that half of the people present is me.
18:30:37 <byorgey> cmccann: sounds straightfoward
18:30:38 <elliott> cmccann has a beard? weird.
18:30:41 <elliott> beird.
18:30:50 * fryguybob makes a note to not wear jeans.
18:30:51 <byorgey> lispy: that hasn't been updated in a loooooong time.
18:31:00 <elliott> lispy: it's at, uh, some other url.
18:31:10 <byorgey> lispy: http://contemplatecode.blogspot.com/
18:31:14 <lispy> maybe we should fix that?
18:31:24 <byorgey> not really worth it.
18:31:47 <cmccann> elliott: it's really more a stubble buffer that gets mostly emptied every week or three.
18:32:59 <wagle> djahandarie: yeah well
18:33:03 <byorgey> djahandarie: oh! I forgot, if you volunteer at the conference (helping run the registration desk or doing A/V or whatever) for 50% of the time you get free registration
18:33:15 <byorgey> djahandarie: so that's a pretty good option
18:33:30 <wagle> i cant find registration info for icfp..  it full or something?
18:33:38 <byorgey> wagle: registration isn't open yet
18:33:43 <byorgey> it's not until September
18:35:47 <johnw> there is also ##icfp, for those of us going
18:36:58 <wagle> how much is it?
18:37:19 <johnw> i don't know ye
18:37:20 <johnw> t
18:37:43 <djahandarie> What does one even do at those things? Just sit and listen to presentations and stuff?
18:37:43 <byorgey> last year it was $500, or $300 for students
18:37:55 <tikhonjelvis> oh, that's not too bad
18:38:00 <byorgey> and each day of extra workshops etc. was about $100
18:38:04 <wagle> listen to presentations, talk to people
18:38:06 <johnw> djahandarie: your point being? :)
18:38:13 <djahandarie> johnw, none. Question.
18:38:13 <tikhonjelvis> I thought it was significantly more expensive, but I must have been counting the cost of getting to Copenhagen too :P
18:38:38 <byorgey> djahandarie: listen to presentations, eat snacks, talk to people during breaks, skip presentations to talk to people, go out for dinner, etc.
18:38:47 <acowley> djahandarie: You will also usually get a few snacks in a crowded space.
18:38:52 <wagle> byorgey's got it down
18:39:31 <byorgey> before my first conference I got some great advice from my advisor: "remember that the purpose of conferences is to skip talks and hang out with people"
18:39:35 <fryguybob> djahandarie: I went a couple of years ago and met byorgey, need I say more?
18:40:04 <cmccann> byorgey: that sounds like excellent advice.
18:40:30 <cmccann> can always read up on whatever the talks were about later.
18:40:43 <cmears> and then people wonder why no one bothers to prepare well for their presentations (:
18:40:45 <tikhonjelvis> that's why it's called a "conference"
18:41:00 <byorgey> indeed.  though of course I have also heard some really great talks (and some not so great ones)
18:41:12 <wagle> listen to talks during breaks
18:41:17 <johnw> haha
18:41:26 <johnw> yeah, I'm going to for the people mainly
18:41:33 <johnw> i wonder how many IRCers will be there
18:41:38 <acowley> Short talks are actually a pretty great way to figure out what you should be reading
18:42:20 <djahandarie> I already know what I should be reading: everything!
18:43:29 <cmccann> read all the things!
18:44:10 <acowley> A researcher often packs a lot into a paper, or buries the lede under esoterica, which forces you to dig only to find you don't care. But when the author packs their result into a sales pitch, if they don't have a good punchline, there likely isn't one.
18:56:42 <wagle> acowley: technically the sales pitch (talk) is supposed to convince you to read the paper, giving it all away might be counterproductive (but what do I know?)
18:57:28 <cmccann> I think the most important part of getting people to read a paper is lots of silly puns.
18:57:39 <cmears> especially in the title
18:57:44 <cmccann> yes
18:57:57 <cmears> or even better, a silly subtitle
18:57:58 <acowley> wagle: I don't think there's any incentive for the author to save things for the paper. If the person likes your presentation, they'll cite your paper. If your presentation is vague and lame, nobody will read the paper.
18:58:27 <wagle> acowley: yeah, i was thinking that out
18:58:47 <acowley> wagle: Of course there are details that you leave in the paper because they don't translate well to a presentation, so I'm not saying you should have your entire paper on your slides.
18:59:23 <wagle> yeah, takes at least an hour to give a paper a good hard skim
18:59:32 <acowley> The other great thing about a presentation is that sometimes the author will make their work sound amazing, and it just takes one person to raise their hand at the end and ask if it actually works to save you a lot of time in reading :)
18:59:47 <cmccann> pf, implementation details.
19:00:16 <acowley> Exactly! Now you know you don't need to read cmccann's paper if you're an applied person.
19:00:18 <sclv> if you have silly puns in your title/presentation, then odds are you'll also have silly puns in your also have lots of silly puns in your paper
19:00:26 <sclv> which guarantees that i'll read it!
19:00:44 <elliott> sclv: that was almost a sentence
19:01:02 <wagle> hahaha..  someone gave a talk on superturing machines..  she encoded real numbers on elements..  i asked if she'd constructed such a machine..  her answer was "yes!"..  shut me up
19:01:03 <acowley> The concept of "sentence" couldn't contain it
19:01:37 <cmccann> acowley: to be fair, when I care about practical application, I'd probably be more likely to write a program instead of a paper :P
19:02:48 <sclv> my thoughts are too powerful for your puny 'grammar'
19:03:07 <acowley> cmccann: Sure, but that's my point! If you didn't write a program to go with your paper, I'm probably not going to get as much out of the paper as something else that someone tested against reality. Different people have different expectations, of course.
19:03:47 <elliott> cmccann: say, about writing programs...
19:04:18 <cmccann> elliott: oh, did you implement your toy language? cool.
19:04:23 <cmccann> glad to hear it.
19:05:24 <cmccann> acowley: yeah. glib IRC jokes aside I'm firmly in the "give me something that at least compiles" camp, actually.
19:05:30 <elliott> cmccann: if by me you mean you, and by my you mean your, and by yes you mean I bet not you slacker, then yes.
19:06:01 <elliott> any questions?
19:06:04 <cmccann> elliott: if by cmccann you mean elliott then ok, sounds good.
19:07:14 <sclv> elliott: are you trying to write as clearly as me?
19:07:27 <cmccann> elliott transcends clarity.
19:07:28 <sclv> if by yes you mean you mean if by yes you mean then yes
19:07:59 <sclv> that's positively joycean
19:08:14 <cmccann> sclv: oh, did you see the latest HWN?
19:08:23 <sclv> yeah, quote made it :-)
19:08:33 <cmccann> yes, I was happy to see that.
19:08:50 <sclv> i told it to a coworker who was left speechless for a good minute
19:08:58 <cmccann> also there's some quote about quotes in HWN that probably sets a new low for quality.
19:09:08 <cmccann> sclv: haha yes good
19:09:13 <cmccann> where by good I mean that's terrible
19:09:41 <blaenk> anyone ever experience the issue where a package shadows another? is there a way to resolve that? like remove the underlying package or something?
19:09:56 <cmccann> I remembered that joke for so long even when you'd forgotten, I want everyone else to feel guilty about thinking it's funny too.
19:09:58 <sclv> ghc-pkg hide this-is-the-package-i-am-hiding
19:10:25 <Shou> (\f g h x -> if f x then g x else h x)
19:11:43 <blaenk> sclv: thank you! so I'm getting: package-a is being shadowed by package-b, the stuff I need requires package-a, how can I hide package-b? just ghc-pkg hide package-b?
19:11:57 <blaenk> or better yet can I just remove it?
19:11:57 <sclv> yep
19:12:04 <cmccann> that will hide it from GHC(i), which is fine.
19:12:05 <sclv> don't remove it -- something else might depend on it
19:12:12 <blaenk> alright thanks
19:12:17 <cmccann> cabal handles visibility itself, so don't worry about that.
19:12:30 <blaenk> cool
19:12:40 <Cale> http://www.reddit.com/r/programming/comments/1ef7o9/btrees_with_gadts_in_haskell/ -- this deserves some upvotes, I think :)
19:13:03 <elliott> cmccann: I read that as cobol.
19:13:15 <cmccann> elliott: wow, what is wrong with you.
19:13:37 <elliott> cmccann: I'm tired!
19:13:44 <blaenk> sclv cmccann: I'm not sure how to qualify the package. they're both named the same thing, they just have a -very-long-hash attached to the end. but when I do ghc-pkg list, it just shows both of them, named the same
19:13:52 <blaenk> should I include the hash?
19:13:52 <cmccann> well, stop being that then.
19:14:17 <blaenk> oh okay I think so
19:14:20 <blaenk> I think that's the pkg-id
19:14:36 <elliott> cmccann: ok. it might take me 8 hours though.
19:14:58 <cmccann> elliott: eight! madness.
19:15:03 <cmccann> I'll give you three.
19:15:23 <elliott> cmccann: ok. your language will be done by then too right?
19:15:40 <cmccann> if by done you mean not done then yes.
19:17:04 <wagle> if by inverting everything people say means that A Bot Must Be Written, then no
19:18:00 <elliott> cmccann: if by if you mean whence and by done you mean upon the hills and by yes you mean only on thursdays and by you you mean mean and by and you mean by and by too you mean yes then okay.
19:18:33 <cmccann> ok, I don't think that even means anything anymore.
19:18:36 <cmccann> this is incredibly silly.
19:18:37 * wagle bows to the master
19:20:20 <blaenk> sclv cmccann: I just did ghc-pkg hide package-id-that-is-shadowing-the-other but ghc -v still says the shadowing is occuring. any ideas?
19:21:08 <wagle> paste the code snippets and the error message, as per the /topic
19:21:16 <wagle> got me curious now
19:21:18 <cmccann> blaenk: I got nothin', sorry.
19:21:22 <blaenk> no worries
19:21:34 <blaenk> I think I'm going to attempt to start from scratch with my packages. I think I hosed them heh
19:21:53 <cmccann> nuke it from orbit.
19:21:56 <blaenk> what is the course of action? aside from uninstalling ghc from my package manager. which dirs should I remove? ~/.ghc and ~/.cabal?
19:22:13 <cmccann> GHC should be fine unless you really, really hosed things.
19:22:37 <wagle> blaenk: paste the code snippets and the error message, to the place in the /topic
19:23:14 <johnw> blaenk: ~/.ghc and ~/.cabal/lib
19:23:21 <johnw> don't wipe out ~/.cabal/bin
19:23:25 <johnw> or ~/.cabal/share
19:23:30 <cmccann> good call
19:24:00 <blaenk> what happened was I installed xmonad from pacman at first (distro's package manager), then for some reason I was afraid of distro/cabal package collisions so I switched to cabal installed xmonad. but then I realized I wouldn't have an easy way to update xmonad (i think), so I ghc-pkg unregister'ed xmonad and xmonad-contrib and then re-installed from pacman
19:24:11 <elliott> I like wiping out everything. it feels reassuringly destructive
19:24:17 <blaenk> and now it seems I have two X11 packages, because ghc says that one id (same version) is shadowing the other
19:24:27 <elliott> blaenk: you may be interested in www.vex.net/~trebla/haskell/sicp.xhtml
19:24:29 <blaenk> I'll paste, was in tty since can't get into xmonad, but I'll get into another DE/WM
19:24:36 <elliott> in particular http://www.vex.net/~trebla/haskell/sicp.xhtml#unsafeInterleave
19:24:37 <cmccann> blaenk: right so about being afraid of distro/cabal conflicts
19:24:37 <wagle> deeestroy!
19:24:38 <cmccann> :P
19:25:00 <blaenk> wagle: so is that a vote for starting from scratch?
19:25:14 <blaenk> johnw: why not remove ~/.cabal? I don't mind reinstalling it, I can install cabal-install from the package manager
19:25:16 <wagle> yeah, it sounds hosed
19:25:18 <johnw> blaenk: I have two scripts called "cabal-reset.sh" and "cabal-bootstrap.sh".  I use them often
19:25:33 <johnw> blaenk: if you blow away ~/.cabal, you'll lose cabal :)
19:25:45 <johnw> although, on some systems that may not be a true statement always
19:25:45 <wagle> johnw: github them!
19:25:48 <blaenk> I can install it from my package manager, if what you mean is having to go through bootstrapping and all of that
19:26:08 <johnw> wagle: ok, one sec
19:26:22 <blaenk> I'd rather start completely from scratch, is that okay? I mean, there shouldn't be any problems right. I can just install whatever I need again
19:26:29 <blaenk> which isn't much, to begin with
19:26:40 <wagle> just takes a little while
19:26:42 <blaenk> but to recap, what should I remove then. ~/.ghc and ~/.cabal?
19:26:45 <blaenk> oh, I see
19:26:58 <blaenk> yeah I'm not worried about that, I'd rather be sure I've fixed the problem
19:27:08 <cmccann> if you haven't installed much with cabal anyway you'd not be losing much.
19:27:18 <blaenk> yeah, that's why I'm not worried
19:27:26 <cmccann> I think it would take like three hours for me to recompile everything I have installed.
19:27:36 <cmccann> if not longer.
19:27:55 <blaenk> aside from those two directories, does ghc install packages in some system level directories? should I remove ghc as well? (I could just re-install the binary through my package manager)
19:28:02 <johnw> wagle: https://github.com/jwiegley/cabal-reset
19:28:12 <wagle> blaenk: ^^^
19:28:22 <blaenk> I'll check that out
19:28:44 <cmccann> blaenk: ghc-pkg will tell you which packages are global vs. user
19:28:48 <johnw> i doubt cabal-bootstrap.sh will be that interesting to you
19:29:06 <cmccann> if you only hosed things installed as user then leave GHC alone, it's fine.
19:29:12 <shachaf> Cale: lambdabot is fixed?
19:29:20 <shachaf> And kappabot is +q. :-(
19:29:21 <johnw> > putStrLn "yes"
19:29:25 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
19:29:25 <lambdabot>    arising from a use of ...
19:29:26 <Cale> shachaf: yeah, "fixed"
19:29:34 <cmccann> > text "Yes!"
19:29:37 <lambdabot>   Yes!
19:29:39 <Cale> shachaf: I didn't do much... but it seems like it's working again.
19:29:47 <blaenk> cmccann: that's what I'm unsure of. I think the hosing was done by package manager, which I think installs globally
19:29:59 <cmccann> blaenk: also, read that link elliott mentioned, it explains many things.
19:30:11 <blaenk> yeah will do
19:30:23 <elliott> shachaf: kappabot isn't +q.
19:30:28 <elliott> but it is /part.
19:30:36 <wagle> johnw: thanks, got them squirrelled away for the next time I need them
19:31:17 <shachaf> elliott: Oh, you fixed it. Thanks.
19:32:21 <blaenk> anyone use archlinux? should I install ghc + cabal-install, or haskell-platform?
19:32:49 <blaenk> I think ghc is fine
19:33:28 <shachaf> Cale: If lambdabot works better on my machine, I could possibly run it.
19:33:34 <wagle> oh, the package manager for ubuntu installs cabal globabally, but cabal then installs locally..  at least 2-3 years ago, I think
19:33:49 <Cale> shachaf: Well, it certainly responds a bit more quickly every time
19:33:55 <wagle> s/globab/glob/
19:33:59 <Cale> shachaf: Possibly you're loading fewer modules though
19:34:09 <Cale> People keep asking me to add moar packages
19:34:13 <shachaf> Probably. I just have the default Pristine.hs.
19:34:17 <cmccann> or maybe shachaf is using a faster machine. like an old 386 or something.
19:34:35 <shachaf> mikeplus64 has a very fast Haskell evaluator, much faster than mueval.
19:34:39 <wagle> blaenk: if its not fine, you can deeeestroy it later
19:34:46 <shachaf> And it even has an IRC bot!
19:34:54 <blaenk> wagle: haha yeah
19:34:57 <shachaf> mikeplus64: How's that whole thing going?
19:35:15 <cmccann> shachaf: I have an extremely fast evaluator, but it only supports a subset of Haskell.
19:35:53 <cmccann> that subset being ().
19:36:02 <cmccann> it's really quite speedy at evaluating () though.
19:36:03 <wagle> () . ()
19:36:06 <elliott> I guessed the subset!
19:36:20 <elliott> well, I also guessed that it might be empty.
19:36:27 <cmccann> elliott: good work. I would give you the prize, but I am out of totally legit moneys right now.
19:36:29 <elliott> then it could be fast and slow simultaneously.
19:36:42 <elliott> cmccann: did you spend them all on going to BayHac?
19:37:00 <shachaf> elliott: I'm afraid only cool people go to BayHac.
19:37:05 <shachaf> cmccann isn't going. :-(
19:37:06 <wagle> main = _exit(0)
19:37:11 <wagle> oops
19:37:26 <cmccann> shachaf was going to buy a plane ticket for me, but then I talked him out of it because it would be expensive.
19:37:32 <shachaf> cmccann should really be cooler one of these days.
19:37:47 * wagle wagle's been doing too much c and perl lately
19:38:07 <cmccann> shachaf: apparently it was decided earlier that I am in fact intangible, and thus cannot attend events due to lack of corporeal form.
19:38:26 <cmccann> manifesting long enough for hac phi is clearly all I can manage for a while.
19:38:42 <cmccann> I was not aware of this, but it sounded plausible so I will go with it.
19:40:15 <wagle> you are one of those phantom types?
19:40:16 <elliott> oh, not bayhac. well, same thing.
19:40:20 <blaenk> johnw: you're the one that posted cabal-reset right?
19:40:23 <elliott> all these places, with people in them.
19:40:32 <blaenk> what yours does is only get rid of packages installed by cabal? leaves global alone?
19:40:33 <cmccann> elliott: which are you going to?
19:40:34 <elliott> it's getting totally out of hand.
19:40:49 <cmccann> elliott: if anything is clear from recent discussion, it's that attending either bayhac or hac phi is required.
19:41:03 <wagle> blaenk: which os you running?
19:41:09 <blaenk> wagle: arch linux
19:41:09 <elliott> cmccann: I'm boycotting the whole thing by not doing anything.
19:41:23 <blaenk> I think I know what the problem is
19:41:34 <blaenk> a while back I made a program that depended on X11 bindings
19:41:48 <blaenk> so I installed that indirectly as a dependency to sdl or something perhaps
19:41:57 <wagle> i think you need to uninstall all the cabal packages installed globally
19:41:59 <blaenk> but now when I install xmonad using the package manager it installs X11, same version, but different id
19:42:08 <cmccann> elliott: I'm boycotting your boycott by having you do things anyway.
19:42:09 <blaenk> but the newly installed one is shadowed by the previously installed one
19:42:23 <copumpkin> okay, it's golfing time
19:42:51 <wagle> cabal has a --global option or somesuch, but that blew my foot off 3-4 years ago
19:42:57 <cmccann> copumpkin: what's par
19:43:11 <blaenk> haha
19:43:17 <copumpkin> (3, [1..10]) -> [[1], [1,2], [1,2,3], [2,3,4], [3,4,5], [4,5,6], [5,6,7], [6,7,8], [7,8,9], [8,9,10], [9,10], [10]]
19:43:23 <cmccann> wagle: don't forget the joy of cabal --upgrade. that was the best cabal command.
19:43:46 <copumpkin> cmccann: number of golf strokes isn't it?
19:43:57 <wagle> cmccann: thats how i learn about deeeestroying .cabal and .ghc
19:44:27 <cmccann> copumpkin: right, as in, what's the target amount of golfing here.
19:44:35 <copumpkin> oh
19:44:40 <zRecursive> cmccann: seems there is no 'cabal --upgrade' ?
19:44:59 <wagle> zRecursive: feet were lost!
19:45:02 <copumpkin> cmccann: I just want something readable and not conceptually ugly (no indices or crap like that)
19:45:11 <cmccann> zRecursive: it was removed because it was too powerful, and threatened the balance of forces that maintain all reality.
19:45:11 <copumpkin> that fits into one moderately long line :)
19:45:54 <copumpkin> I can write an explicitly recursive one that uses take recursively to get the suffix starting at [1,2,3] fairly cleanly
19:46:02 <copumpkin> but adding the "lead-in" makes it ugly
19:46:10 <wagle> worlds shortest haskell program..  (I came up with main = main, but that's no longer shortest, but I forgot what is)
19:46:16 <sclv> can we ignore efficiency here?
19:46:22 <copumpkin> within reason, sure
19:46:30 <copumpkin> I was thinking of using Cale's favorite function
19:46:41 <copumpkin> for enumerating "zippers" of a list
19:46:45 <copumpkin> whatever he calls it
19:46:47 <copumpkin> select?
19:46:49 <copumpkin> :t select
19:46:53 <lambdabot>     Not in scope: `select'
19:46:53 <lambdabot>     Perhaps you meant `reflect' (imported from Control.Monad.Logic)
19:46:56 <copumpkin> hmm
19:47:07 <wagle> @hoogle select
19:47:08 <lambdabot> Graphics.Rendering.OpenGL.GL.Selection module Graphics.Rendering.OpenGL.GL.Selection
19:47:08 <lambdabot> Graphics.Rendering.OpenGL.GL.Selection Select :: RenderMode
19:47:08 <lambdabot> Text.Html select :: Html -> Html
19:47:15 <copumpkin> it's not standard anywhere
19:47:21 <wagle> umm, not helpful, sorry
19:47:23 <copumpkin> it picks a focus and gives you the two other lists
19:47:40 <copumpkin> in that case, my function is just picking half from either side and smushing them together
19:47:52 <copumpkin> but it still feels a little ugly needing to do math on the n
19:47:57 <Cale> copumpkin: yeah, select :)
19:48:11 <blaenk> I solved my problem!
19:48:18 <jmcarthur> > map (take 3) . transpose . tails $ [1..10]  -- close, but not quite there
19:48:19 <copumpkin> > tails [1..10]
19:48:24 <lambdabot>   mueval: ExitFailure 1
19:48:24 <lambdabot>  mueval: Prelude.undefined
19:48:24 <lambdabot>   mueval: ExitFailure 1
19:48:24 <lambdabot>  mueval: Prelude.undefined
19:48:35 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in select [1,2,3,4]
19:48:35 <blaenk> just rm'ed ~.ghc and ~.cabal and then installed xmonad through package manager, all is fine (so far lol)
19:48:35 <jmcarthur> > map (take 3) . transpose . tails $ [1..10]
19:48:38 <copumpkin> jmcarthur: yeah, that seems like a promising direction
19:48:40 <lambdabot>   [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
19:48:40 <lambdabot>   can't find file: L.hs
19:48:45 <jmcarthur> > map (take 3) . transpose . tails $ [1..10]
19:48:48 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10],[1...
19:48:54 <wagle> zRecursive: --upgrade got confused and made messes a lot for newbies
19:48:57 <copumpkin> Cale: oh, I was thinking of the two halves version
19:49:00 <jmcarthur> it only lacks the first two
19:49:05 <Cale> oh, sure, there's that one too
19:49:05 <wagle> <- newbie
19:49:15 <copumpkin> jmcarthur: yeah, those are what make it ugly for me :(
19:49:20 <copumpkin> I like yours though
19:49:43 <copumpkin> > map (take 3) . transpose . tails $ [1..]
19:49:47 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10,11]...
19:49:50 <copumpkin> nice and lazy, too
19:50:09 <wagle> :t transpose
19:50:17 <zRecursive> wagle: sure
19:50:21 <lambdabot> [[a]] -> [[a]]
19:50:36 <jmcarthur> > transpose [[1,2,3],[4,5,6],[7,8,9]]
19:50:40 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
19:50:57 <wagle> yeah, i misread the code above
19:51:02 <copumpkin> > transpose . tails $ [1..10]
19:51:07 <lambdabot>   mueval: ExitFailure 1
19:51:08 <lambdabot>  mueval: Prelude.undefined
19:51:11 <copumpkin> oh come on lambdabot
19:51:15 <copumpkin> > transpose . tails $ [1..10]
19:51:17 <jmcarthur> hah, you can drop the transpose and get something similar, even
19:51:21 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,...
19:51:26 <jmcarthur> map (take 3) . tails $ [1..10]
19:51:26 <copumpkin> lol
19:51:28 <jmcarthur> > map (take 3) . tails $ [1..10]
19:51:28 <sclv> can't you just add inits
19:51:33 <lambdabot>   mueval: ExitFailure 1
19:51:33 <lambdabot>  mueval: Prelude.undefined
19:51:37 <jmcarthur> fug!
19:51:38 <sclv> to get the initial bit
19:51:39 <copumpkin> Cale: what's wrong with her?
19:51:42 <sclv> its a nice parallel construction
19:52:01 <Cale> copumpkin: sigh, I thought it magically went away, but apparently not
19:52:16 <copumpkin> sclv: maybe? :)
19:52:24 <Cale> copumpkin: I'm not sure what's causing that behaviour, but it's not the timeout.
19:52:45 <wagle> not getting rid of the previous timeout?
19:52:45 <copumpkin> > map (take 3) . inits $ [1..10] -- will give me the other side but not both
19:52:48 <Cale> (and it happens with mueval on the commandline)
19:52:51 <lambdabot>   mueval: ExitFailure 1
19:52:51 <lambdabot>  mueval: Prelude.undefined
19:53:07 <sclv> \ len xs -> (take len . drop 1 . inits $ xs) ++ (map (take len) . tails $ xs)
19:53:09 <copumpkin> grep undefined :P
19:53:12 <sclv> or the like
19:53:37 <sclv> easy to pl that too
19:53:45 <copumpkin> hmm, I'd like it to be linear in its use of xs ideally, but that isn't too bad
19:53:50 <sclv> or eta reduce at least
19:54:01 <copumpkin> I can @pl that in my head!
19:54:04 <copumpkin> liftA2 :P
19:54:13 <copumpkin> except for the len part which is ugly
19:54:26 <shachaf> > liftA2 (++) inits tails [1,2,3]
19:54:27 <sclv> uncurry (++) . (take len . drop 1 . inits) &&& (map (take len) . tails)
19:54:29 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3],[2,3],[3],[]]
19:54:57 <copumpkin> > liftA2 (++) (init . inits) tails [1..10]
19:55:00 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[...
19:55:04 <copumpkin> see, not quite
19:55:43 <cmccann> > (\n xs -> (\n' -> drop (n' - n - 1) $ take n' xs) <$> zipWith const [1..] (replicate n undefined ++ xs)) 4 [2..9]
19:55:44 <sclv> a man a plan warsaw was raw nal panama
19:55:48 <lambdabot>   mueval: ExitFailure 1
19:55:48 <lambdabot>  mueval: Prelude.undefined
19:55:49 <cmccann> > (\n xs -> (\n' -> drop (n' - n - 1) $ take n' xs) <$> zipWith const [1..] (replicate n undefined ++ xs)) 4 [2..9]
19:55:54 <lambdabot>   mueval: ExitFailure 1
19:55:54 <lambdabot>  mueval: Prelude.undefined
19:55:58 <cmccann> dammit lambdabot
19:55:59 <cmccann> > (\n xs -> (\n' -> drop (n' - n - 1) $ take n' xs) <$> zipWith const [1..] (replicate n undefined ++ xs)) 4 [2..9]
19:56:02 <lambdabot>   [[2],[2,3],[2,3,4],[2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9...
19:56:10 <cmccann> hm not quite
19:56:30 <cmccann> > (\n xs -> (\n' -> drop (n' - n - 1) $ take (n' - 1) xs) <$> zipWith const [1..] (replicate n undefined ++ xs)) 4 [2..9]
19:56:34 <lambdabot>   [[],[2],[2,3],[2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7],[5,6,7,8],[6,7,8,9],[7,...
19:56:40 <cmccann> argh whatever
19:56:43 <cmccann> stupid off by one errors
19:56:52 <copumpkin> math >:(
19:56:59 <sclv> btw i've asked on some other channels, but if anyone's familiar with Day convolution and has some pointers i'd be curious
19:57:01 <cmccann> math is hard
19:57:10 <sclv> let's go shopping!
19:57:19 <copumpkin> shopping is hard!
19:57:22 <shachaf> Fleet Admiral Inits
19:57:31 <cmccann> > (\n xs -> (\n' -> drop (n' - n) $ take n' xs) <$> zipWith const [1..] (replicate (n - 1) undefined ++ xs)) 3 [2..9]
19:57:32 <wagle> lets go programming!
19:57:33 <jmcarthur> > map (catMaybes . take 3) . tails . (replicate 3 Nothing ++) . map Just $ [1..10]
19:57:36 <lambdabot>   mueval: ExitFailure 1
19:57:36 <lambdabot>  mueval: Prelude.undefined
19:57:38 <lambdabot>   mueval: ExitFailure 1
19:57:39 <lambdabot>  mueval: Prelude.undefined
19:57:40 <jmcarthur> > map (catMaybes . take 3) . tails . (replicate 3 Nothing ++) . map Just $ [1..10]
19:57:45 <lambdabot>   mueval: ExitFailure 1
19:57:45 <lambdabot>  mueval: Prelude.undefined
19:57:46 <jmcarthur> > map (catMaybes . take 3) . tails . (replicate 3 Nothing ++) . map Just $ [1..10]
19:57:46 <cmccann> > (\n xs -> (\n' -> drop (n' - n) $ take n' xs) <$> zipWith const [1..] (replicate (n - 1) undefined ++ xs)) 3 [2..9]
19:57:51 <lambdabot>   mueval: ExitFailure 1
19:57:51 <lambdabot>  mueval: Prelude.undefined
19:57:52 <lambdabot>   mueval: ExitFailure 1
19:57:52 <lambdabot>  mueval: Prelude.undefined
19:57:52 <cmccann> this is not going well.
19:57:54 <copumpkin> okay, this is ridiculous
19:57:55 <jmcarthur> > map (catMaybes . take 3) . tails . (replicate 3 Nothing ++) . map Just $ [1..10]
19:57:57 <sclv> shopping is hard, let's go shopping! error.. error.. paradox.. paradox...
19:58:00 <lambdabot>   mueval: ExitFailure 1
19:58:00 <lambdabot>  mueval: Prelude.undefined
19:58:01 <copumpkin> might as well just decomission lambdabot
19:58:03 <copumpkin> mm
19:58:03 <Fuuzetsu> > 1
19:58:06 <jmcarthur> [[],[1],[1,2],[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10],[10],[]]
19:58:08 <lambdabot>   mueval: ExitFailure 1
19:58:08 <lambdabot>  mueval: Prelude.undefined
19:58:11 <Fuuzetsu> ;;
19:58:12 <cmccann> mueval is hard
19:58:14 <Cale> okay, this is kinda interesting. When it gets killed, it gets killed after exactly 5 seconds, even though the timeout is explicitly set to 10
19:58:19 <wagle> what IS the mueval failure #1?
19:58:22 <copumpkin> jmcarthur: hah, cute
19:58:32 <copumpkin> Cale: search for undefined maybe? are there a lot of them?
19:58:36 <Shou> rip in peace lambdabot
19:58:57 <Cale> Shou: piece, rip in piece
19:59:02 <sclv> jmcarthur -- looks nice. maybe moving from maybe to list golfs it a bit?
19:59:06 <cmccann> copumpkin: anyway my atrocious version works modulo my failure at arithmetic
19:59:18 <cmccann> but jmcarthur seems to have a better way
19:59:22 <jmcarthur> sclv: ah i was thinking token golf rather than character golf
19:59:41 <sclv> yeah then maybe is better.
19:59:42 <copumpkin> yeah, not so interested in characters
19:59:44 <Fuuzetsu> @pl (\f g h x -> if f x then g x else h x)
19:59:44 <lambdabot> (ap .) . liftM2 if'
19:59:49 <copumpkin> I want to squeeze the essence out of that thing :P
20:00:19 <Shou> :t select
20:00:34 <lambdabot> thread killed
20:00:48 <sclv> cmccann: can't believe you're replicating undefined in yr solution.
20:00:48 <wagle> :t undefined
20:00:52 --- mode: ChanServ set +o lambdabot
20:00:58 <lambdabot> a
20:00:58 <copumpkin> lambdabot: feel better now?
20:01:06 <shachaf> Uh oh.
20:01:14 <sclv> not only is it atrocious, its somewhat horrifying
20:01:16 <cmccann> lambdabot is gonna take over
20:01:22 <jmcarthur> > map (catMaybes . take 3) . tails . (replicate 3 Nothing ++) . map Just $ [1..10]
20:01:27 <shachaf> lambdabot: @topic-tail
20:01:27 <lambdabot> Plugin `topic' failed with: Prelude.last: empty list
20:01:27 <lambdabot>   mueval: ExitFailure 1
20:01:28 <lambdabot>  mueval: Prelude.undefined
20:01:30 <jmcarthur> not better
20:01:34 <Cale> I'm building stuff, so performance will be worse for a bit
20:01:40 <cmccann> it can get worse?
20:01:42 --- mode: ChanServ set -o lambdabot
20:01:43 <Cale> heh
20:01:49 <Cale> well, it is worse right now :)
20:02:09 <copumpkin> Cale: what changed to break it?
20:02:37 <cmccann> sclv: in case it wasn't clear that's just doing some peano arithmetic and the list elements get ignored :]
20:02:54 <Cale> copumpkin: No idea.
20:03:08 <sclv> maybe its more than one of us playing with it at once
20:03:10 <cmccann> I blame shachaf for running a competing bot, and hurting lambdabot's feelings.
20:03:12 <Cale> Nothing as far as I know. I've been messing around with stuff trying to get things to work for the last couple days
20:03:24 <cmccann> I'm quite certain that's the correct direction of causality here.
20:03:24 <Cale> No, the reason he was running that bot was this very problem
20:03:30 <shachaf> The trouble with peano arithmetic is that it stops at 88.
20:03:42 <johnw> argh
20:03:45 <tikhonjelvis> that's a great line to return to
20:03:53 <cmccann> shachaf: magnificent
20:04:04 <sclv> @remember shachaf The trouble with peano arithmetic is that it stops at 88.
20:04:04 <lambdabot> Good to know.
20:04:16 <johnw> really, that was deserving of remembrance?
20:04:25 <jmcarthur> deserving of groans at least
20:04:34 <wagle> dont forget the foot pedals
20:04:34 <cmccann> shachaf: would you say that piano puns are your forte?
20:04:35 <sclv> the best things to remember are puns
20:04:40 <sclv> oh no
20:05:20 <wagle> 91?
20:05:20 <jmcarthur> cmccann: your jokes are striking a chord in me
20:05:40 <wagle> no, its a black and hite issue
20:05:42 <jmcarthur> that wasn't punny
20:05:46 <wagle> no, its a black and white issue
20:05:47 <jmcarthur> that was just a saying
20:05:48 <tikhonjelvis> reminds me of a short story by Asimov about the origins of humor
20:05:49 <jmcarthur> i'm dumb
20:06:24 <coppro> w/in 4
20:06:35 <cmccann> jmcarthur: having treble making puns?
20:06:39 <tikhonjelvis> worth a read if you've got nothing better to do: http://www.ippt.gov.pl/~vkoval/fantasy.html
20:06:41 <jmcarthur> i fail to golf this thing any further, copumpkin
20:06:47 <sclv> yeah, the tempo has slowed noticeably.
20:06:49 <copumpkin> that wasn't bad, thanks :)
20:06:56 <Cale> aha
20:07:05 <copumpkin> aha!
20:07:05 <Cale> 5 seconds is mueval's *default* timelimit
20:07:08 <wagle> isnt that just grand?
20:07:28 <wagle> aha!
20:07:30 <Cale> Currently it takes very close to 5 seconds to actually evaluate anything
20:07:39 <copumpkin> aha!
20:07:41 <Cale> The ones which succeed are taking like 4.8 or so
20:07:45 <copumpkin> and the timeout action is undefined?
20:07:56 <Cale> My guess is that mueval's argument parsing is going wrong somehow
20:08:25 <wagle> change the hardwired default?
20:08:33 <Cale> let's set the default to 10 and see what happens
20:08:42 <wagle> (baling wire!  chewing gum!)
20:08:50 <copumpkin> > mapAccumL (curry (first (+1))) 0 [0..]
20:09:20 <cmccann> copumpkin: you should go to hac phi, btw.
20:09:26 <wagle> tick
20:09:32 <shachaf> copumpkin will be too busy at bay hac
20:09:33 <copumpkin> not gonna be able to make it, forgot a friend was coming to visit that weekend :/
20:09:38 <cmccann> :[
20:09:54 <Cale> w... t... f...
20:10:03 <Cale> time "mueval" "-XImplicitParams" "-XTypeFamilies" "-XScopedTypeVariables" "-XUnboxedTuples" "-XFlexibleContexts" "-XMagicHash" "-XPatternGuards" "-XRankNTypes" "-XTypeOperators" "-XBangPatterns" "-XNoMonomorphismRestriction" "-XViewPatterns" "-XConstraintKinds" "--no-imports" "-l" "State/L.hs" "--expression=map (take 3) . inits $ [1..10]"
20:10:03 <Cale> mueval: ExitFailure 1
20:10:03 <Cale> mueval: Prelude.undefined
20:10:03 <Cale> real	0m5.028s
20:10:04 <Cale> user	0m4.345s
20:10:06 <Cale> sys	0m0.711s
20:10:11 <cmccann> haha
20:10:14 <Cale> this is with the new mueval I just built
20:10:26 <shachaf> What if you clean up L.hs a bit?
20:10:32 <copumpkin> > snd . mapAccumL (curry (first (+1))) 0 $ [0..]
20:10:33 <shachaf> By which I mean empty it.
20:10:59 <cmccann> it seems lambdabot is pining for the fjords.
20:14:10 <copumpkin> hmm
20:14:13 <copumpkin> interesting
20:14:19 <jmcarthur> more ddosing?
20:14:31 <copumpkin> they look like real nicks and such
20:14:35 <Cale> okay, things are going to be weird for a moment, I should probably take lb down...
20:14:57 <copumpkin> lb is already gone
20:15:08 <copumpkin> due to the "event" that just happened
20:15:40 <Cale> heh, well enough
20:18:03 <wagle> took everyone to the fjords with him?  (her?)
20:18:31 <Cale> okay, it's definitely parsing the arguments correctly, and I've removed the rlimits code it wasn't using entirely, so it's not that
20:20:52 <wagle> unsafePerformIO "hi, I'm down here in the bowels, and I think the timeout is " ++ (show timeoutARG)
20:21:30 <Cale> It's all IO code anyway, I don't need the unsafePerformIO :)
20:21:43 <wagle> not that I ever use unsafe
20:21:55 <shachaf> I,I (return . unsafePerformIO)
20:21:58 <Cale> I noticed something fishy though...
20:22:45 <copumpkin> was it a fish?
20:22:54 <wagle> a ghoti
20:22:59 <tikhonjelvis> probably just a red herring
20:23:38 <wagle> you flound a bug?
20:24:18 <Cale> There's a stupid comment
20:24:19 <blackdog> wagle: this isn't the plaice for that sort of humour
20:24:25 <Cale> the code is of the form:
20:24:37 <Cale> do _ <- forkIO $ do ...
20:24:47 <copumpkin> wat
20:24:48 <Cale>    return () -- Never reached.
20:25:03 <Cale> which is obviously false
20:27:33 <Cale> shachaf: if you could bring kappabot back for a little while, it'd be good
20:28:20 <cmccann> that sounds like a kappatal idea.
20:28:24 <kappabot> yawg
20:28:55 <copumpkin> yawg!
20:29:02 <tikhonjelvis> yawg?
20:29:05 <copumpkin> does lambdabot/kappabot have fingertree in scope btw?
20:30:07 <wagle> > `yawg`
20:30:08 <kappabot>   <hint>:1:1: parse error on input ``'
20:30:33 <wagle> oops, where's that > come from?
20:31:00 <wagle> :t fingertree
20:31:01 <kappabot> Not in scope: `fingertree'
20:31:15 <wagle> guess'
20:31:19 <shachaf> copumpkin: No.
20:31:24 <shachaf> I'm just running with the default configuration.
20:31:53 <shachaf> I'm having trouble installing any packages.
20:32:00 <shachaf> This GHC installation is kind of messed up.
20:32:54 <shachaf> @undefine
20:33:36 <shachaf> @ty FT.viewl
20:33:37 <kappabot> Couldn't find qualified module.
20:33:41 <shachaf> Hmm.
20:34:00 <shachaf> > FT.empty
20:34:01 <kappabot>   Ambiguous type variables `v0', `a0' in the constraint:
20:34:01 <kappabot>    (Data.FingerTree....
20:34:09 <shachaf> Odd.
20:34:10 <shachaf> @undefine
20:34:12 <shachaf> > FT.empty
20:34:12 <kappabot>   Ambiguous type variables `v0', `a0' in the constraint:
20:34:13 <kappabot>    (Data.FingerTree....
20:34:40 <shachaf> @ty FT.empty
20:34:41 <kappabot> Couldn't find qualified module.
20:34:50 <shachaf> I wonder why that's not working.
20:34:59 <shachaf> Oh, I know.
20:35:02 <wagle> @hoogle FT
20:35:02 <kappabot> A Hoogle error occurred.
20:35:08 <shachaf> @ty FT.empty
20:35:09 <kappabot> forall v a. FT.Measured v a => FT.FingerTree v a
20:35:09 <wagle> yow
20:35:19 <shachaf> So @ty uses a different version of GHC from @run
20:38:50 <wagle> i wonder why
20:39:08 <shachaf> I don't.
20:39:35 <sclv> ty can just plugin directly
20:39:35 <kappabot> sclv: You have 1 new message. '/msg kappabot @messages' to read it.
20:39:41 <sclv> run runs untrusted code, so...
20:40:05 <shachaf> ty runs ghci and prints your line preceded with ":t " into it.
20:40:08 <shachaf> It's kind of awful.
20:40:18 <sclv> ahahaah kappbot just gave me a three year old message!
20:40:20 <cmccann> shachaf: you're kind of awful, oh snap.
20:40:26 <cmccann> that's amazing.
20:40:32 <cmccann> good work, kappabot.
20:40:41 <shachaf> It does a little bit of sanitizing which is probably broken.
20:40:55 <shachaf> cmccann: You're kind of great and your presence in the channel is valued by everyone, hth.
20:41:10 <dolio> @messages
20:41:10 <kappabot> You don't have any new messages.
20:41:16 * shachaf refuses to play the insult game.
20:41:37 <dolio> I used to have a really old message in the default lambdabot database.
20:41:37 <cmccann> shachaf: pf.
20:41:41 <dolio> I forget what it was about.
20:42:40 <cmccann> dolio: probably the secret to making mueval not crash all the time. now it is lost forever.
20:42:50 <dolio> Definitely wasn't that.
20:43:12 <dolio> There is no such secret, obviously. :)
20:43:19 <Fuuzetsu> It is still lost forever.
20:43:51 <Fuuzetsu> data SecretToMuEval
20:44:55 <cmccann> Fuuzetsu: definitely uninhabited, yes
20:45:16 <shachaf> Lots of good messages in the kappabot database.
20:46:04 <Fuuzetsu> cmccann: I'm sure we could unsafeCoerce something into it
20:47:05 <copumpkin> okay, more golf time
20:47:18 <shachaf> molf time
20:47:27 <copumpkin> actually, fingertrees aren't very golfable
20:47:32 <copumpkin> since they have almost no helper functions
20:47:56 <copumpkin> this is the basic idea though: sliding n xs = let (h, t) = splitAt n xs in snd $ mapAccumL (\acc x -> let n = drop1 acc |> x in (n, measure n)) (fromList h) t
20:48:26 * djahandarie wants to know what data copumpkin is working with that he only has a monoid and not a group
20:50:24 <wagle> Monoid of Dreams?
20:50:37 <copumpkin> djahandarie: seeing how general I can get, really
20:50:47 <copumpkin> also came across a special algorithm for sliding minimum
20:51:28 <copumpkin> which can be done magically by this thing
20:52:53 <shachaf> I'm afraid you can only get colonel.
20:53:10 <copumpkin> oh well
20:53:12 <shachaf> Or maybe lonel.
20:53:26 <shachaf> Is a colonel colonely?
20:53:51 <copumpkin> djahandarie: all I really need is a semigroup, which allows Min nicely
20:54:16 <shachaf> Do finger trees need monoids or just semigroups?
20:54:29 <copumpkin> if we had a non-empty fingertree, we'd just need a semigroup
20:54:32 <copumpkin> I happen to have one
20:54:40 <shachaf> I guess they can be empty.
20:54:44 <shachaf> But only at the root?
20:56:06 <copumpkin> not sure actually if they end up using the Empty thing further down
20:56:11 <copumpkin> but in principle at least I don't think they'd need to
20:57:18 <shachaf> Finger trees are weird.
20:57:46 <copumpkin> very
20:58:01 <shachaf> Is there a way to have e.g. the "complete binary tree" thing that encodes the size of the tree in a more reasonable way than unary?
20:58:06 <djahandarie> They are built purely out of human fingers
20:58:14 <shachaf> (I mean, the logBase 2 of the size of the tree. But still.)
20:58:31 <copumpkin> shachaf: you mean through that nested type thingy?
20:59:06 <shachaf> I mean the Tree a = Leaf a | More (Tree (a,a)) thing.
20:59:10 <copumpkin> yeah
20:59:25 <shachaf> Finger trees use a vaguely similar trick.
20:59:32 <copumpkin> it's more than vaguely similar
20:59:39 <shachaf> OK, the same trick.
20:59:56 <shachaf> Anyway it seems like it has kind of terrible constant factors since you have to follow so many pointers.
21:00:14 <shachaf> ...Though often the people writing this sort of code don't care about constant factors.
21:00:15 <copumpkin> yeah
21:00:23 <shachaf> But people who use Data.Sequence do!
21:00:41 <copumpkin> I actually do, but I still want my generality and sliding windows over arbitrary monoids
21:01:30 <copumpkin> djahandarie: did that code help btw?
21:01:56 <djahandarie> What code? The line you just pasted in here a second ago?
21:02:31 <copumpkin> about 15 minutes ago, yep
21:09:14 <mikeplus64> shachaf it is on my github but atm i have no time to work on it
21:09:44 <mikeplus64> its fatafl flaw atm is that you can't limit memory usage
21:09:55 <shachaf> falafel flaw
21:10:24 <mikeplus64> phone tyoing is hard
21:11:30 <mikeplus64> it shouldnt be too hard to make a small server for it, i think i started on that
21:12:03 <mikeplus64> (to limit mem use without blowing the whole program up)
21:13:04 <mikeplus64> and, i supoose, security if you were to emgm allow IO
21:13:11 <mikeplus64> some security
21:15:52 <copumpkin> perhaps I'll stick to scanl instead of mapAccumL
21:17:28 <NetBat> people: what algorithm does `Data.List.sort' use?
21:17:51 <copumpkin> mergesort iirc
21:17:55 <copumpkin> a particularly lazy one
21:18:26 <NetBat> copumpkin: cheers. Can you point me to the code, please?
21:18:34 <u_> Graphics.Google.Chart is outdated and incomplete :(
21:18:37 <u_> back to the drawing board
21:18:42 <copumpkin> @pl (\acc x -> drop1 acc |> x)
21:18:43 <kappabot> (|>) . drop1
21:18:45 <arkeet> NetBat: look on, say, hackage for the Data.List documentation
21:18:48 <arkeet> NetBat: there's a "source" link
21:18:53 <copumpkin> NetBat: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#sort
21:18:56 <arkeet> like that.
21:26:52 <copumpkin> okay
21:26:54 <copumpkin> ((map measure . (uncurry (scanl ((|>) . drop1) . fromList))) .) . splitAt
21:27:59 <djahandarie> . soup
21:28:18 <copumpkin> that's my sliding window algo, basically
21:28:32 <copumpkin> minus the drop1 definition
21:39:29 <monochrom> w00t haskell weekly news!
21:45:11 <copumpkin> let d(viewl->_:<t)=t;d(viewl->_)=empty; in((map measure.(uncurry(scanl((|>).d).fromList))).).splitAt
21:45:15 <copumpkin> there, that's the final beast
21:45:44 <shachaf> What's the space for?
21:45:55 <copumpkin> whoops, unnecessary :)
21:46:22 <NetBat> People: What's `NoImplicitPrelude' ?
21:46:35 <wagle> need a space checker
21:46:45 <monochrom> let dr(viewl->_:<tl)=tl;dr(viewl->_)=empty;in((map measure.(uncurry(scanl((|>).dr).fromList))).).splitAt
21:46:57 <monochrom> I do that just to embed "tl;dr"
21:47:05 <djahandarie> Haha.
21:47:13 <wagle> monochrom++
21:47:16 <copumpkin> lol
21:47:32 <copumpkin> but that wastes characters for my tweet
21:47:48 <monochrom> yeah, but it's a tl;dr anyway :)
21:47:49 <wagle> honorable mention
21:47:58 <shachaf> copumpkin: That's something I never do.
21:48:09 <copumpkin> I've noticed
21:48:27 <djahandarie> copumpkin, wait, its o(n)??
21:48:39 <copumpkin> I think so?
21:48:52 <djahandarie> What happened to the lg?
21:48:59 <copumpkin> was wrong
21:49:05 <zRecursive> :t scanl
21:49:06 <kappabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
21:49:23 <shachaf> fmap :: Functor f => f a -> Yoneda f a
21:49:32 <shachaf> fmap :: Functor f => CoYoneda f a -> f a
21:51:36 <zRecursive> Is lambdabot dead ?
21:52:50 <wagle> kappabot is her understudy
21:53:36 <zRecursive> wagle: thx
21:53:59 <wagle> lambdabot down for repairs or something
21:58:16 <otters> so I see view patterns are like a replacement for case in some situations
22:00:06 <johnw> they make it easy to pattern match on the result of a function applied to an argument
22:01:47 <johnw> you can also say they are a replacement for let in some situations
22:09:58 * hackagebot hermit 0.1.8.0 - Haskell Equational Reasoning Model-to-Implementation Tunnel  http://hackage.haskell.org/package/hermit-0.1.8.0 (AndrewFarmer)
22:43:40 <otters> ok hermit looks absolutely out of my league of understanding
22:48:00 <NetBat> people : What's the difference between `concatMap' and `map' ? They would appear to be identical.
22:48:54 <shachaf> The type and the behavior.
22:49:00 <shachaf> Did you look at the type/documentation?
22:49:06 <shachaf> @where hoogle is a good way to find it.
22:49:06 <kappabot> http://haskell.org/hoogle
22:49:47 <leroux> NetBat: map returns a list with the function f applies to all elements of xs...
22:50:08 <leroux> concatMap does some concating...
22:50:11 <leroux> http://zvon.org/other/haskell/Outputprelude/concatMap_f.html
22:50:50 <shachaf> zvon.org :-(
22:51:36 <leroux> Sorry, just googled...instead of hoogle...
22:51:51 <leroux> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:concatMap
22:52:05 <shachaf> Google works too.
22:53:21 <wagle> > concatMap (\x -> [1..x]) [1..4]
22:53:21 <kappabot>   [1,1,2,1,2,3,1,2,3,4]
22:54:20 <Kneiva> :t concatMap
22:54:21 <kappabot> forall a b. (a -> [b]) -> [a] -> [b]
22:54:29 <wagle> :t map
22:54:30 <kappabot> forall a b. (a -> b) -> [a] -> [b]
22:54:36 <wagle> slightly different
22:55:29 <wagle> :t works in ghci too
22:55:30 <kappabot> parse error on input `in'
22:55:41 <wagle> oops
22:55:41 <Kneiva> =)
23:03:11 <otters> so view patterns just save you typing out the name of whatever variable you provide to the function
23:03:19 <otters> but if you have to write out the function name itself multiple times for different patterns
23:03:23 <otters> it doesn't save much time does it
23:03:33 <tikhonjelvis> it also looks better, I think
23:03:36 <tikhonjelvis> which is important
23:03:52 <tikhonjelvis> your intentions are clearer
23:04:17 <otters> and they do recursion and stuff, but
23:04:39 <otters> so does case heh
23:05:27 <c_wraith> well, view patterns can also make some matches more succinct
23:05:56 <c_wraith> Because stuff that doesn't match the view pattern falls through to the next case
23:06:12 <otters> but that happens in case too
23:06:39 <c_wraith> otters: not if it's a case inside a single equation for a function with multiple equations with different pattern matches
23:06:49 <c_wraith> otters: you can't fall through to one of the other equations
23:07:43 <c_wraith> otters: but if you use a view pattern, the failure to match happens at the equation scope, so it falls through to the next equation
23:08:47 <otters> I see
23:09:32 <c_wraith> That's probably not a huge help most of the time
23:09:36 <c_wraith> but occasionally it will make things simpler
23:11:44 * wagle studies the http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns page and wishes it gave before and after pictures of each example
23:12:11 <mura> exit
23:14:23 <Saizan> can i get the effect of -auto-all but only for some modules?
23:14:30 <wagle> oh, i finally "get it"
23:15:22 <wagle> view hide info about the underlying datastructure
23:15:30 <wagle> views hide info about the underlying datastructure
23:22:09 <hrookie> I'm trying to use Data.Serialize, and the docs say i can just derive Generic -- I'm not sure where to find this typeclass, a little help?
23:25:56 <cmears> hrookie: this one?  http://hackage.haskell.org/packages/archive/syb/0.4.0/doc/html/Data-Generics-Aliases.html#g:2
23:26:48 <cmears> ah, no
23:27:02 <cmears> it's this one: http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/GHC-Generics.html#t:Generic
23:27:19 <cmears> since the first one is not even a type class (:
23:28:40 <hrookie> cmears: are you familiar with what i'm trying to find?
23:30:00 <cmears> hrookie, you are looking for the Generic mentioned in http://hackage.haskell.org/packages/archive/cereal/0.3.5.2/doc/html/Data-Serialize.html ?
23:36:04 <hrookie> cmears: yes, i eam
23:36:49 <cmears> Then I think the typeclass in GHC.Generics is what you're looking for
23:38:07 <hrookie> cmears: why thanks! will this automatically serialize for me, now that i've derived it, or do i still need to supply serialization instructions?
23:39:21 <cmears> I haven't used Serialize much, but once you have derived Generic and added "instance Serialize XXX" for your type XXX, you should be able to use encode/decode
23:40:18 <hrookie> awesome, thanks!
23:40:34 <cmears> You're welcome, I hope it works (:
23:40:37 <hrookie> yeah, i'm trying to get my stuff serializable for network transmission. next is cereal-conduit and network-conduit
23:41:06 <cmears> Good luck; I keep thinking I should try those conduits one day...
23:41:22 <hrookie> :D
23:41:58 <hrookie> so there are a few cool things, but the functionality i'm looking for still isn't exactly native, so i think i'm going to use the conduits themselves, but not the TCP client/server interface the conduit library provides
23:42:19 <mikeplus64> cmears: the Generic class is in GHC.Generics
23:42:50 <hrookie> specifically, cereal-conduit + network-conduit should (hopefully) allow me to just listen forever for incoming data structures on the network
23:43:17 <hrookie> however, there isn't a great "broadcast to all these channels in unison" interface in the default TCP server application format
23:43:28 <hrookie> it's mostly a "you can concurrently handle any number of independent TCP connections independently"
23:43:34 <hrookie> (insofar as i can tell)
23:46:16 <Rileld> I'm trying to convert a ByteString to Text, and I see Data.Text.Encoding has functions for that. But they all require that you already know the encoding, which I don't think I know. How do I do this in Haskell?
23:50:40 <Tene> That's not really possible in any language.
23:50:58 <Tene> If you don't know the encoding, then you don't have text; you just have a blob of bytes.
23:51:10 <hrookie> Rileld: do you know the data type, but not how it's encoded? e.g., if it's got methods through the Data.Serialize library, you could dig those up
23:51:41 <Rileld> I'm getting the ByteString from Network.Curl.Download
23:52:43 <Rileld> Is the encoding something I can figure out by digging through the source?
23:53:20 <hrookie> what are you downloading?
23:53:29 <Rileld> Or maybe just trying each encoding, and the one that doesn't error is the encoding. Then I can just use that one everywhere?
23:53:33 <Cale> Rileld: The encoding is a property of the thing you're downloading.
23:53:52 <hrookie> the Network.Curl.Download library has useful defaults for a few common things, but not for everything
23:54:12 <Cale> Rileld: That's basically what web browsers try to do when the web server doesn't provide encoding information.
23:54:15 <Tene> Rileld: check the Content-Type http header; that sometimes has an encoding in it
23:54:25 <Tene> For example, Content-Type: text/html; charset=ISO-8859-1
23:54:39 <zRecursive> It seems UTF8 has fixed byte sequence at the beginning of data ?
23:54:50 <Cale> zRecursive: Optionally, sometimes.
23:54:54 <Tene> There might be a BOM, but there might not.
23:55:00 <Cale> (usually not, really)
23:55:24 <Rileld> So the encoding here is determined by the website I'm downloading from, and can change from one to the next?
23:55:31 <Cale> Rileld: yes
23:55:33 <Tene> Rileld: Yes, that's the case.
23:55:45 <Cale> Rileld: which is awful, but that's how things are in the world right now
23:56:26 <Tene> Rileld: In practice, most programs just assume whatever encoding works for their test cases and don't bother further.  Some smaller set of programs do heuristic tests to try to guess the encoding, and try to notice when they get it wrong.
23:57:10 <Cale> Rileld: The Japanese have a word for the problems created by this "mojibake"
23:57:42 <wagle> anyone here maintain http://hackage.haskell.org/trac/ghc/wiki ?
23:58:05 <wagle> i just reverted some spam left by the same guy
23:59:31 <Rileld> Is there no library function that does the heuristic for me? If not I guess I'll just assume everything is utf8 and see if anything breaks.
