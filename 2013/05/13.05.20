00:27:58 <tomejaguar> Suppose I have a structure B with two substructures M and M', and the relevant lenses.  Is there a lens function for combining them to get a lens from B into (M, M')?  (I guess there would have to be an assumption the M and M' don't overlap).
00:28:42 <shachaf> I don't think so.
00:31:02 <hoyang> haskell is best or just for research? can i use to build an website? it's possible? aha.
00:31:27 <johnw> yes, quite possible
00:31:35 <johnw> see fpcomplete.com: entirely written in Haskell
00:31:55 <hoyang> pure haskell?
00:31:56 <zRecursive> hoyang: of course you can. yesod, snap ,etc.
00:31:58 <DarkFox> Can anyone here confirm that blender can work with haskell? (Or at least be able to export to something that can be easily imported using some existing library in hackage)
00:32:02 <johnw> hoyang: yes
00:32:14 <johnw> even our Javascript is translated from Haskell
00:33:19 <DarkFox> johnw: I don't think that fpcomplete.com is hosted on a haskell os ;)
00:33:24 <zRecursive> johnw: how about its performance ?
00:33:28 <johnw> well, you have me there
00:33:30 <hoyang> Haskell os?
00:33:33 <johnw> zRecursive: performance is quite good
00:33:46 <johnw> HaskOS!
00:33:48 <hoyang> like lisp machine?
00:33:56 <akamaus> is there a library which is like FilePath but for url manipulation?
00:35:24 <JoeyA> Too bad we don't have Windows-style URLs
00:35:50 <hoyang> i cant find HaskOS official website.
00:36:07 <zRecursive> What's Windows-style URLs? Isnot URLs general ?
00:36:41 <johnw> hoyang: it doesn't exist, I was just hoping
00:36:45 <macron> hoyang: that was a joke. There has been a Haskell OS in the past though: it's called House.
00:36:46 <JoeyA> zRecursive: I'm kidding.  One problem FilePath has to deal with is \ on Windows vs / on more standard OSes.
00:37:01 <hoyang> Windows-style is First/Character/Must/Be/Upper.Aspx
00:37:02 <hoyang> aha.
00:37:12 <JoeyA> Moar spaces
00:37:41 <zRecursive> Ugly and slow to type :)
00:37:42 <JoeyA> First\Character In The Path\Must\Be\Upper.Exe
00:37:51 <hoyang> Aha!
00:38:10 <JoeyA> First/Character<tab><tab><tab>.... left pinkie breaks
00:38:22 <hoyang> First\Character\Must\Upper And \r\n\r\n\r\n\r\n............
00:39:13 <zRecursive> @hoogle FilePath
00:39:15 <lambdabot> Prelude type FilePath = String
00:39:15 <lambdabot> System.IO type FilePath = String
00:39:15 <lambdabot> System.FilePath.Windows type FilePath = String
01:26:59 <johnw> can anyone help me understand what Haskellers mean when they use the word "reify"?  I've seen it used many times in channel, but haven't been able to glean exactly what the speakers mean by it in each case.  A simple example of proper use would be great.
01:29:45 <shachaf> johnw: Beyond e.g. the stackoverflow.com answer on it?
01:30:09 <pygmalion> Is there an idiomatic way to do something like (a, IO b) -> IO (a, b)
01:30:28 <johnw> shachaf: link?
01:30:32 <shachaf> @google reify haskell
01:30:33 <lambdabot> http://stackoverflow.com/questions/5314884/what-do-reify-and-reification-mean-in-the-context-of-functional-programmi
01:30:33 <lambdabot> Title: haskell - What do "reify" and "reification" mean in the context of (functional?) ...
01:30:35 <johnw> thanks
01:30:54 <shachaf> pygmalion: The operation is called "strength". But it's not really in any standard library.
01:31:27 <shachaf> @ty (\(x,y) -> fmap ((,) x) y)
01:31:31 <lambdabot> Functor f => (a1, f a) -> f (a1, a)
01:32:25 <pygmalion> Ah! I always forget that (,) is an operator. Awesome, thanks.
01:33:01 <aristid> johnw: the first time i came across the word "reification" was funnily enough in the context of taking RDF triples and making something like [ subject: X; verb: V; object: Y ] out of them
01:33:05 <johnw> shachaf: is the operation called strength, or does "strength" indicate that the operation is available for a given Functor?
01:33:30 <shachaf> johnw: It isn't really in any standard library, so who can say what it's "called"?
01:33:34 <johnw> could I say that your instance above reifies strength for Haskell functors?
01:33:39 <shachaf> johnw: Anyway, it's available for all Functor instances in Haskell.
01:33:50 <johnw> yes, because all Haskell functors are "strong"
01:34:03 <shachaf> I know.
01:34:07 <shachaf> Anyway, I've seen this function called "strength" in other places.
01:34:38 <johnw> it's just seems odd to see a verbal noun used for a verb
01:34:48 <johnw> or no, just a noun
01:34:57 <johnw> an adjectival noun?
01:35:05 <shachaf> > length [1,2,3,4]
01:35:07 <lambdabot>   4
01:35:16 <johnw> :)
01:35:30 <johnw> length asks for the attribute of a value
01:35:33 <aristid> > product [1,2,3,4]
01:35:34 <lambdabot>   24
01:35:47 <johnw> ah, good example
01:36:16 <shachaf> Function names should generally not be verbs.
01:36:24 <johnw> print?
01:36:46 <shachaf> print is special because (print 5) is an IO action.
01:36:54 <johnw> why shouldn't they be verbs?
01:37:06 <pygmalion> johnw: It's more natural for IO actions to be imperative I think.
01:37:27 <johnw> so function names ought to be descriptive of the result obtained?
01:37:58 <shachaf> Right.
01:38:04 <johnw> makes sense
01:38:40 <shachaf> Verbs in the imperative are suitable for IO, of course. :-)
01:39:16 <johnw> so, the strength of a Functor is given by its ability to translate (a, f b) to f (a, b), so the value you are obtaining is a functorial value which witnesses the strength of the Functor
01:39:23 <shachaf> But note that putStrLn is still "descriptive of the result obtained". It's just that the result obtained is putting a string.
01:39:33 <shachaf> I say we abandon this "strength" thing.
01:39:42 <johnw> I say we don't yet
01:40:01 <shachaf> OK, then I rename this operation "blahblue"
01:40:27 <johnw> The description I just gave I think is a compelling reason to call the function 'strength'
01:40:55 <johnw> "if you can't show strength, the functor isn't strong"
01:42:33 <Saizan> the strength is in the trasformation, not in the result, though
01:42:59 <johnw> the result is just a proof of the transaformation
01:43:06 <Saizan> there're many ways to get a f (a,b)
02:08:33 <kmels> morning, Monads don't compose well but could Applicative style expressions improve my code readability here? http://hpaste.org/88235
02:13:44 <Saulzar> Newbie distributed process erorrs... leave something out of the remotetable (unClosure stalls forever), send something of the wrong type (expect waits forever for the correct type...)
02:14:40 <Ralith> m/win 28
02:14:43 <Ralith> wups
02:38:34 * hackagebot tfp 0.7 - Type-level integers, booleans, lists using type families  http://hackage.haskell.org/package/tfp-0.7 (HenningThielemann)
02:43:34 * hackagebot hcube 0.1.1 - Virtual Rubik's cube of arbitrary size.  http://hackage.haskell.org/package/hcube-0.1.1 (ToddWegner)
02:49:58 <Aetherspawn> @pl runReaderT startServer $ SessionReader prop
02:49:59 <lambdabot> runReaderT startServer (SessionReader prop)
02:50:22 <Aetherspawn> And then I remembered it had no arguments..
02:50:47 <Aetherspawn> @pl (\x -> evalStateT x defaultSessionState)
02:50:48 <lambdabot> flip evalStateT defaultSessionState
02:51:18 <ocharles> kmels: you'll have to be more specifci
02:51:23 <ocharles> what exactly are you looking for advice on?
02:54:12 <Aetherspawn> @pl (\x -> runReaderT startServer $ SessionReader x)
02:54:12 <lambdabot> runReaderT startServer . SessionReader
02:55:39 <Aetherspawn> @pl (\x -> show . lookupVersionSimple $ protocolVersion x)
02:55:39 <lambdabot> show . lookupVersionSimple . protocolVersion
03:19:33 <hoyang> http://zh.wikibooks.org/wiki/Haskell i find this.
03:19:39 <hoyang> it's so good.
03:28:35 * hackagebot ghc-datasize 0.1.1 - Determine the size of data structures in GHC's memory  http://hackage.haskell.org/package/ghc-datasize-0.1.1 (DennisFelsing)
03:32:18 <testeree> is there a way to read the source of a function in ghci using commands similar to :i and :t?
03:32:34 <supki> no
04:01:44 <schoppenhauer> hello. I am trying to use a DiffArray, but haskell claims "Could not find module `Data.Array.Diff'"
04:01:55 <schoppenhauer> However, Data.Array, etc., are there.
04:02:58 <Philonous> schoppenhauer:  have you installed the diffarray package?
04:03:25 <schoppenhauer> Philonous: no. hm. i just tried to do it using cabal, but I get error messages.
04:03:44 <zRecursive> @hoogle Data.Array.Diff
04:03:44 <lambdabot> package Diff
04:03:44 <lambdabot> package diffarray
04:03:44 <lambdabot> package diffcabal
04:04:09 <zRecursive> @package diffarray
04:04:09 <lambdabot> http://hackage.haskell.org/package/diffarray
04:04:12 <schoppenhauer> http://paste.debian.net/5308/
04:04:25 <Philonous> schoppenhauer:  Yeah, diffarray doesn't build for me either. So you have to either fix it yourself or ask the maintainer to do it
04:04:55 <schoppenhauer> m(
04:06:06 <schoppenhauer> Philonous: I am not a haskell-geek, I just wanted to do a few benchmarks. And the monadic arrays gave me headaches ... is there any other non-monadic dictionary-structure with incremental updates (like a heap or tree or something)
04:07:48 <schoppenhauer> not that I couldn't write one myself, but I guess there are predefined ones.
04:08:14 <yitz> schoppenhauer: Data.Map, from the containers package, is the most commonly used.
04:08:31 <Philonous> schoppenhauer:  Well, there's Data.Map from Containers and Data.HasMap.* from unordered-containers
04:08:50 <Philonous> Data.HashMap even
04:08:51 * zRecursive In fact some packages in hackage is NOT good quality ...
04:08:51 <lambdabot> zRecursive: You have 1 new message. '/msg lambdabot @messages' to read it.
04:13:49 <schoppenhauer> hm, // is not defined for maps, it seems.
04:15:16 <schoppenhauer> ok, unions can probably be used
04:18:25 <schoppenhauer> or insert
04:22:20 <quchen> Filter too
05:28:55 <Garyuutensei> Hello, I want to install repa on windows and get the following message: "cabal: The following packages are likely to be broken by the reinstalls" where several packages are listed. What should I do?
05:32:16 <supki> Garyuutensei: depends on what packages are listed
05:32:29 <supki> @hpaste
05:32:29 <lambdabot> Haskell pastebin: http://hpaste.org/
05:34:08 <Garyuutensei> btw, how do i use the hpaste bot? :S
05:34:50 <Kinnison> Just use hpaste.org
05:35:56 <Garyuutensei> supki: Here are the packages that were listed http://hpaste.org/88244
05:37:24 <applicative_tmp> hm, this isnt good I think.  some come with the haskell platform.
05:38:01 <applicative_tmp> I wonder who needs  a new haskell98-2.0.0.1
05:38:37 * hackagebot SQLDeps 0.1 - Calculate db-data dependencies of functions  http://hackage.haskell.org/package/SQLDeps-0.1 (AlexanderThiemann)
05:38:37 <applicative_tmp> the previous version of repa Garyuutensei ?
05:39:37 <Garyuutensei> there is a version called 3.2.2.201204.1, maybe I should try that one?
05:39:56 <Garyuutensei> 2012.04 is the platform I have anyway
05:39:59 <supki> If you break directory you break haskell98
05:40:07 <applicative_tmp> ah I see
05:40:13 <supki> Garyuutensei: either that or 3.2.1.1
05:40:42 <applicative_tmp> supki: Garyuutensei that was the number that was seeming right to me too
05:40:55 <Garyuutensei> The new haskell platform is not out yet, right?
05:41:08 <applicative_tmp> Garyuutensei: it should be any time
05:41:40 <applicative_tmp> Garyuutensei: your problem is basically that the last version of the platform is being outrun by hackage
05:42:01 <applicative_tmp> so this wouldnt be happening in a couple weeks
05:42:39 <applicative_tmp> but does cabal install repa-3.2.1.1 --dry-run look bad?
05:43:11 <Garyuutensei> let me check
05:46:23 <jpcooper> hello
05:46:30 <applicative_tmp> hello jpcooper !
05:46:49 <jpcooper> can someone suggest to me a simple matrix operations library?
05:52:01 <Garyuutensei> pplicative_tmp: repa-3.2.1.1 installed fine. I couldn't install 3.2.2.201204.1 though, strange :S
05:54:16 <greeny> i have a short question, why did i get in my little code a parse error in the last line ? http://hpaste.org/88246
05:54:18 <applicative_tmp> Garyuutensei: it requires a new version of bytestring though the version of base seems to have been made consistent with the platform
05:54:45 <applicative_tmp> Garyuutensei: I'm not sure
05:55:12 <Garyuutensei> no problem, hopefully the new platform will be out soon :)
05:55:25 <applicative_tmp> greeny: it looks like the where block should be indented another column
05:56:01 <applicative_tmp> greeny: it is a where block for something in 'result'
05:56:34 <greeny> thanks
05:56:43 <applicative_tmp> hm no one had wisdom for jpcooper on matrix libraries...
06:10:56 <allsystemsarego> Hi all, is it possible to write a pure function that picks a random element from a list, by wrapping the side-effecting code in a lambda?
06:11:50 <twanvl_> allsystemsarego: a pure function always produces the same result when called with the same arguments
06:12:02 <allsystemsarego> ok
06:12:54 <allsystemsarego> I'm thinking...
06:13:06 <allsystemsarego> let me relax the requirements
06:14:01 <allsystemsarego> I want the function to not necessarily be pure, but I want its signature to not be "decorated" with IO
06:14:32 <twanvl_> you can define another monad for randomness
06:14:44 <twanvl_> or pass in a random generator manually
06:14:57 <allsystemsarego> so there's no canonical answer to my question?
06:15:03 <adinapoli_> …or you can make the god of FP angry calling unsafePerformIO
06:15:06 <adinapoli_> :D
06:15:53 <twanvl_> there is the MonadRandom package, which defines the Rand monad
06:16:02 <merijn> allsystemsarego: The canonical answer is, you can do it without IO, but then you end up using something like the Rand monad
06:16:27 <allsystemsarego> yes, the Rand monad looks like what I'm after
06:16:28 <adinapoli_> I think he wants to actually "escape" from the monadic context
06:16:33 <adinapoli_> or not?
06:16:49 <allsystemsarego> I want to escape the IO context
06:17:08 <merijn> allsystemsarego: You can't, that's kinda the point
06:17:23 <merijn> allsystemsarego: Also, you probably don't want that. What are you trying to do?
06:17:24 <Chousuke> you can, but not without breaking things
06:17:26 <adinapoli_> that's why I joked about the fact of using unsafePerformIO
06:18:35 <allsystemsarego> Here's what I'm trying to do: I want to use a random generator deep inside a pure function
06:18:45 <Chousuke> allsystemsarego: that's not a good idea
06:19:06 <merijn> s/not a good idea/a terrible idea/
06:19:06 <Chousuke> allsystemsarego: have the pure function take an input parameter instead and feed it something from a random generator
06:19:14 <applicative_tmp> allsystemsarego: if you have a generator as a parameter its okay,
06:19:27 <applicative_tmp> as Chousuke is saying
06:19:53 <lewis1711> "let s = show" why is the type of s "() -> String" ?
06:20:07 <merijn> lewis1711: Dread Monomorphism Restriction
06:20:13 <merijn> @where DMR
06:20:13 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
06:20:15 <applicative_tmp> lewis1711: its defaulting in ghci
06:20:16 <allsystemsarego> It's a game, I'm inside the endless loop I would need to generate an unspecified number of random picks upfront - that would make no sense to me
06:20:27 <Chousuke> allsystemsarego: just do that then
06:20:32 <Chousuke> generate an infinite list of random picks
06:20:48 <Chousuke> and pass that to the pure function
06:20:48 <applicative_tmp> lewis1711: if you do :set -XNoMonomorphismRestriction on a line in ghci , it will be more reasonable
06:20:59 <merijn> lewis1711: Well, a combination of DMR and defaulting, I think
06:21:02 <allsystemsarego> ok, I'll think about that
06:21:13 <allsystemsarego> thanks
06:21:20 <lewis1711> thanks for the feedback. the more haskell I learn the less I know
06:21:21 <applicative_tmp> merijn: yes, it could hardly come up with () without defaulting
06:21:33 <merijn> lewis1711: Basically, ghci tries to be aggressively un-polymorphic
06:21:43 <merijn> lewis1711: Manually providing a type signature would also fix it
06:21:54 <lewis1711> seems like the sanest solution
06:21:55 <applicative_tmp> lewis1711: the monomorphism thing is a little rough.  it's mostly when youre inside ghci that confusing things occur
06:22:04 <merijn> i.e. "let s :: Show a => a -> String; s = show"
06:22:24 <Chousuke> allsystemsarego: generally writing things in Haskell takes a bit more thought beforehand if you want to keep things pure and easy to reason about, but it's almost always worth the effort.
06:22:29 <applicative_tmp> lewis1711: remember ghci isn't like an .hs file, youre basically inside a long IO do block
06:22:34 <merijn> lewis1711: Explicit signatures will stop ghci from defaulting to something that's less polymorphic than what you want
06:23:02 <Chousuke> allsystemsarego: the basic strategy is to write pure functions, and then use them in a bit of impure code that handles user input, randomness, and other such things.
06:23:03 <applicative_tmp> lewis1711: you can also put :set -XNoMonomorphismRestriction inside your .ghci file
06:23:05 <merijn> I think that "let s x = show x" would also work? Lemme test
06:23:23 <applicative_tmp> lewis1711: but this occasionally shows its own down side
06:23:32 <merijn> lewis1711: Yeah, having an explicit argument also works
06:24:16 <merijn> lewis1711: Anyway, the wiki page should explain the why and where and how to get rid of the DMR
06:24:53 <nejucomo> I often want to express "here's a class C, and btw, any instance of B is also an instance of C with this definition: ..."
06:25:02 * supki never saw -XNoMonomorphismRestriction downsides
06:25:05 <merijn> nejucomo: There's no good way of doing that
06:25:23 <merijn> supki: Can blow up your memory and remove sharing, this making your code slower
06:25:28 <applicative_tmp> supki: oh I've been driven mad by them
06:25:36 <supki> merijn: well, in theory yes
06:25:43 <applicative_tmp> supki: they remove sharing as merijn says
06:26:02 <nejucomo> merijn: What about: newtype WrapB t = MkWrapB t \n instance B t => C (WrapB t) where ...
06:26:03 <nejucomo> ?
06:26:20 <applicative_tmp> supki: most recently it was totally trivial; I was trying to follow the examples in simon marlowes manuscript
06:26:36 <nejucomo> I haven't tried this yet, but I was pondering how convenient / inconvenient it would be.
06:27:25 <applicative_tmp> supki: http://ofps.oreilly.com/titles/9781449335946/sec_par-eval.html the use of the debugger fails totally if you have the MR off
06:27:46 <andrea__> hello guys,i have problems to find the correct type signature for a function ( i am beginner)
06:27:59 <applicative_tmp> it's obvious it would be so, but only on reflection, supki ...
06:28:31 <applicative_tmp> andrea__: does ghci give you a rough draft on the signature, if you put it in a file?
06:28:59 <andrea__> applicative_tmp, ghci doesnt accept this
06:29:24 <applicative_tmp> andrea__: unless you have fancy extensions working, it should be able to infer the type
06:29:34 <applicative_tmp> you can paste the source on hpaste.org
06:29:39 <Chousuke> unless its type won't make sense, of course
06:29:54 <applicative_tmp> like Chousuke says
06:30:13 <andrea__> this works :    mysqrt ::  Float -> Float -> Either String Float
06:30:34 <supki> applicative_tmp: hmm, I see. I always try to have signatures for top-level definitions though
06:30:40 <andrea__> but i want this mysort :: (Num a) => a -> a -> ?
06:31:00 <Aetherspawn> yay
06:31:05 <Aetherspawn> finally got monad hell working
06:31:21 <applicative_tmp> Aetherspawn: you mean the paradise of the monads surely.
06:31:23 <Chousuke> andrea__: the last one would be Either String a
06:31:29 <Aetherspawn> a beginners brain explodes when you have to wrap a monad around a ReaderT StateT around another monad :P
06:31:40 <Chousuke> andrea__: but I think the Num constraint won't cut it for a sqrt function
06:31:41 <applicative_tmp> No one shall drive us from the paradise that Moggi and Wadler have created for us
06:32:27 <Chousuke> andrea__: what happens if you wrtie it without a type signaturre
06:32:28 <applicative_tmp> to paraphrase D. Hilbert ...
06:32:29 <Chousuke> ?
06:32:34 <andrea__> Chousuke,  this dosn't work
06:32:51 <Chousuke> can you paste the code?
06:33:40 <applicative_tmp> Aetherspawn: a pile of transformers is admittedly a strain
06:33:42 <andrea__> mysqrt :: (Num a) => a -> a -> Either String a mysqrt a b  | a < 0     = Left "negativ"  | b == 0    = Left "division null"   | otherwise = Right (sqrt a / b )
06:33:48 <passiveobserver> how to manually update ghc from 7.6.2 to 7.6.3 I have platform windows
06:34:19 <applicative_tmp> passiveobserver: isn't the platform using ghc-7.4 still?
06:34:22 <Aetherspawn> Transformers; typecheck hell in disguise
06:34:26 <Aetherspawn> :C
06:34:31 <byorgey> passiveobserver: you install 7.6.3 in the same way you installed 7.6.2.
06:34:42 <byorgey> passiveobserver: note you will have to reinstall any packages you have installed with cabal.
06:34:45 <greeny> has someone a good explanantion for when using the function composition . instead of $
06:34:49 <andrea__> Chousuke, without type signature it works fine, but i want learn haskell
06:35:01 <passiveobserver> byorgey: i installed haskell platform 2012.4 it installed 7.6.2 rerun haskell platform setup?
06:35:06 <Chousuke> andrea__: the Num constraint isn't enough because you use /
06:35:23 <Chousuke> you need Fractional a
06:35:34 <byorgey> passiveobserver: I don't believe you.  HP 2012.4 comes with GHC 7.4.2.
06:35:54 <byorgey> passiveobserver: are you sure you have 7.6.2 ?
06:36:07 <passiveobserver> byorgey: yes it's 7.4.2
06:36:11 <passiveobserver> byorgey: my mistake
06:36:24 <byorgey> passiveobserver: ok, no problem.  And why do you want to upgrade GHC?
06:36:25 <passiveobserver> byorgey: is there a way to update
06:36:36 <andrea__> Chousuke,  without the "Either" it works with "Num"
06:36:46 <applicative_tmp> passiveobserver: I think you should wait for the new platform though.
06:37:01 <byorgey> yes, a new Haskell Platform will be out imminently
06:37:02 <dario> greeny: (.) is funciton composition, ($) is actually function application, just with very low priority
06:37:07 <byorgey> which will include GHC 7.6.3
06:37:18 <aristid> byorgey: woohoo
06:37:22 <applicative_tmp> passiveobserver: apparantly the windows expert is still working on a release candidate but it will be soon
06:37:31 <passiveobserver> byorgey, applicative_tmp: ok so I'll resort to ghc 7.4.2 manual though
06:37:55 <Aetherspawn> When can we expect the shiny GHC with iOS support? :o
06:38:47 <passiveobserver> then*
06:39:01 <Chousuke> andrea__: hmm.
06:39:03 <Jaak> hey, does anyone have experience with using alex (3.0.3) with monad-bytestring wrapper? i'm having issue with undefined "alexEOF" and "ignorePendingBytes"
06:39:16 <Jaak> i can define them myself, but that's not documented anywhere
06:39:28 <andrea__> Chousuke, i 'm unsure , must I  use Fractional ?
06:39:41 <Chousuke> andrea__: well, Fractional defines the / operator
06:40:02 <Chousuke> andrea__: what does ghci say is the type of that function?
06:40:05 <merijn> byorgey: Bah, it seems everytime platform upgrades I have already jumped to a newer GHC version because of killer feature X :<
06:40:12 <Chousuke> ghci is usually correct. :P
06:40:36 <byorgey> merijn: why is that a problem?  That's how it's supposed to work.
06:40:47 <merijn> byorgey: Because then I still can't use platform :(
06:40:58 <merijn> Actually, I guess I should whine at the GHC guys for updating to fast...
06:41:06 <andrea__> mysqrt :: (Fractional a) => a -> a -> Either String a
06:41:07 <adinapoli_> where can I read more about the work-in-progress iOS support?
06:41:09 <byorgey> people who want killer feature X are expected to be using newer GHC versions.  Conversely the Platform is supposed to include a stable well-tested version.
06:41:19 <andrea__>     Could not deduce (Floating a) arising from a use of `sqrt'
06:41:19 <andrea__>     from the context (Fractional a)
06:41:19 <andrea__>       bound by the type signature for
06:41:19 <andrea__>                  mysqrt :: Fractional a => a -> a -> Either String a
06:41:19 <andrea__>       at /home/andrea/Dokumente/prog/haskell/learn.hs:(3,1)-(6,35)
06:41:20 <andrea__>     Possible fix:
06:41:21 <andrea__>       add (Floating a) to the context of
06:41:23 <andrea__>         the type signature for
06:41:25 <andrea__>           mysqrt :: Fractional a => a -> a -> Either String a
06:41:27 <andrea__>     In the first argument of `(/)', namely `sqrt a'
06:41:29 <andrea__>     In the first argument of `Right', namely `(sqrt a / b)'
06:41:31 <andrea__>     In the expression: Right (sqrt a / b)
06:41:34 <byorgey> andrea__: please don't paste in the channel
06:41:36 <quchen> andrea__: Please use hpaste for stuff like this.
06:41:39 <quchen> @where hpaste
06:41:39 <lambdabot> http://hpaste.org/
06:42:32 <andrea__> sorry
06:42:37 <Chousuke> oh, sqrt requires Floating
06:42:42 <andrea__> i don't know this
06:43:19 <byorgey> andrea__: the numeric type classes can be a bit confusing at first. (In fact I still can't keep them straight).
06:43:34 <Chousuke> so basically ghc is already telling you what the solution is :P
06:43:49 <byorgey> andrea__: unless you have a specific reason for wanting your function to be polymorphic I suggest giving it a more monomorphic type signature, like   Double -> Double -> Either String Double
06:44:13 <Philonous> byorgey:  imminently = real soon nowâ„¢ ?
06:44:17 <byorgey> Philonous: yep
06:44:35 <Chousuke> you specified the type signature to be too general, and ghc won't accept the code because it doesn't match your specified type
06:44:45 <passiveobserver> so I'm trying to use this: http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/win32-dlls.html I've followed example with adder.hs, startend.c, and I don't get adder_stub.o, only adder_stub.h
06:44:52 <passiveobserver> what am I doing wrong?
06:45:04 <adinapoli_> even though I heard that the new platform will ship ghc 7.6.3, whilst iOS support was something on the cards in GHC 7.8, am I correct?
06:45:12 <byorgey> Philonous: in particular all the versions are fixed, there are release candidates, I think there are just a few issues still being worked out with some of the installers
06:45:49 <byorgey> adinapoli_: the Platform will ship with 7.6.3, yes
06:45:54 <andrea__> how does hpaste work ?
06:45:58 <byorgey> (I don't know anything about iOS support)
06:46:14 <byorgey> andrea__: are you asking how you use it?  Or how it is implemented?
06:46:32 <Eduard_Munteanu> andrea__: paste your error message and/or code and submit. Then give us a link to it.
06:46:34 <andrea__> byorgey, how to use it
06:47:06 <allsystemsarego> andrea__, visit hpaste.org, follow instructions
06:47:06 <Chousuke> andrea__: just go there, put your code in the text field, select #haskell as the channel and submit
06:48:26 <andrea__> i had done it
06:49:29 <Chousuke> you probably forgot to select the channel then. just copy the URL to the finished paste here
06:49:46 <Chousuke> http://hpaste.org/88247 it'll look like this
06:49:52 <byorgey> I don't see a paste by andrea__ though
06:50:00 <andrea__> http://hpaste.org/88248
06:50:06 <andrea__> is this ok ?
06:50:21 <mithsv> is there anything like glm (http://glm.g-truc.net/) for haskell?
06:50:25 <merijn> No, hpastebot appears to be broken since saturday
06:50:30 <merijn> So it's not announcing
06:50:51 <andrea__> http://hpaste.org/88249
06:50:51 <merijn> mithsv: "Error 102 (net::ERR_CONNECTION_REFUSED): The server refused the connection."
06:51:13 <mithsv> it works here?
06:51:25 <mithsv> it's a graphics math library aimed at opengl
06:51:35 <passiveobserver> ok tried to compile without adder_stub.o and it creates the dll...
06:52:17 <Chousuke> andrea__: so yeah, the problem is still the constraint
06:52:56 <Chousuke> andrea__: Num is too restrictive since it doesn't allow using /, and Fractional is too restrictive since it doesn't allow sqrt
06:53:04 <Chousuke> or actually
06:53:09 <Chousuke> not restrictive enough, I should say
06:53:21 <Chousuke> type-wise. :P
06:57:15 <andrea__> re
06:57:40 <Aetherspawn> I still get much better performance all around the board with llvm than the ncg :\
06:58:45 <merijn> Aetherspawn: It depends a lot on the type of code
06:59:10 <merijn> I think llvm is much better at really numerical code
07:00:55 <Fuco> so, enumFromTo... is there enumDownFromTo?
07:01:30 <Aetherspawn> merijn, I wrote a monad heavy parser and llvm was able to consistently get 30-40% better parse times
07:01:54 <Aetherspawn> Admittently, my code was not /the best/. There were a lot of optimization issues, as I'm just a noob.
07:03:14 <Aetherspawn> /s/Admittently/Admittedly/
07:03:22 <byorgey> Fuco: no, there is enumFromThen and enumFromThenTo
07:03:48 <byorgey> > enumFromThenTo 10 9 1
07:03:48 <k0ral_> Hello, I have a linker error when using Path_myprogram.version, while I filled the "Version:" field correctly in the .cabal file; any clue ?
07:03:49 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
07:03:57 <k0ral_> Paths_myprogram*
07:03:59 <Fuco> ah, right
07:04:23 <Aetherspawn> > enumFromThenTo 1000 800 0
07:04:25 <lambdabot>   [1000,800,600,400,200,0]
07:04:25 <k0ral_> it says "undefined reference to `immzm0zi5zi1zi0_Pathszuimm_version1_closure'"
07:04:28 <byorgey> k0ral_: did you list  Path_myprogram  in the  other-modules:  field?
07:04:36 <Aetherspawn> Thaaat's really cool.
07:04:36 <k0ral_> byorgey: ah, right !
07:05:28 <k0ral_> byorgey: thank you
07:05:38 <byorgey> glad to help
07:05:46 <gerryy78> http://xemilyratajkowski.blogspot.com/2013/05/emily-ratajkowski-hot-photo-collection.html
07:06:43 <t7> is that safe for work?
07:07:01 <Aetherspawn> Don't bother its just spam
07:07:14 <aristid> wait why did i click that.
07:07:22 * aristid feels stupid
07:07:32 <Aetherspawn> I clicked it when he asked whether it was safe for work :P
07:07:36 <Aetherspawn> to check for him
07:07:44 <dario> because the natural instinct is to click all links in a channel you assume sane
07:08:43 <Philonous> dario:  There's not much reason to click on links in here that aren't paste bins
07:08:55 <byorgey> automatically clicking any and all links is part of internet addiction.  It's a conditioned response.
07:08:55 <dcoutts_> dario: especially when they come from users who exit with (K-Lined)
07:09:13 * byorgey recommends installing a browser plugin which puts a five-second delay on opening all new tabs
07:09:33 <t7> dcoutts_: yeah show part messages?
07:09:44 <Philonous> byorgey:  That one comes preinstalled with firefox
07:09:47 <t7> on a channel with >100 people
07:09:51 <byorgey> Philonous: hahahaha
07:09:58 <t7> lol
07:10:21 <merijn> dcoutts_: Many people (like me) don;t have joins/parts enabled so don't see klines
07:10:26 <dcoutts_> t7: it makes netsplits more fun
07:10:54 <merijn> Philonous: I dunno, there's many interesting paper/SO links here
07:11:19 <Philonous> merijn:  But people usually announce them beforehand.
07:11:38 <dcoutts_> merijn: aye, I forget that
07:11:52 <osfameron> they also don't have urls that contain "hot-photo-collection.html"
07:12:24 <dcoutts_> t7: when doing Op things you need to be able to see join/part stuff
07:12:55 <byorgey> osfameron: I add the suffix "hot-photo-collection.html" to all my papers
07:12:58 <byorgey> really helps the citation count
07:13:01 <dcoutts_> :-)
07:13:08 <osfameron> hehe
07:14:14 <dcoutts_> byorgey: species-functors-types-hot-photo-collection.html?search=
07:14:32 <byorgey> hehehe
07:15:07 <Kneiva> I'm having trouble combinin Maybe and State, here is my code and question: http://hpaste.org/88250
07:15:42 <t7> Kneiva: StateT ?
07:16:23 <t7> i didnt read the question
07:16:39 <Kneiva> t7: Yeah, that's my guess too. Didn't try it yet though. Wanted to ask here first.
07:17:51 <supki> @unmtl MaybeT (State s) a
07:17:51 <lambdabot> s -> (Maybe a, s)
07:17:55 <supki> @unmtl StateT s Maybe a
07:17:55 <lambdabot> s -> Maybe (a, s)
07:21:10 <Kneiva> StateT s Maybe a seems wrong too, I don't get anything if some part returns Nothing?
07:21:25 <supki> Kneiva: I think you want Writer
07:21:36 <supki> Kneiva: yeah, StateT is wrong
07:23:12 <Kneiva> yeah, I should use Writer here.
07:23:59 <Kneiva> but that probably doesn't change the behavior when using it in filter like I do
07:24:18 <Kneiva> ack, gotta go now. bbl
07:27:11 <supki> Kneiva: no, you don't want MaybeT semantics for the whole computation
07:27:27 <supki> by Writer I mean Writer :)
07:29:47 <nejucomo> I have a question / problem with flexible instance: http://hpaste.org/88251
07:30:12 <nejucomo> I have: instance C t => C [t]  -as wll as: instance C String
07:30:20 <nejucomo> However, there is *no* instance C Char
07:30:33 <nejucomo> -yet I get an overlapping instances error.  Why?
07:31:07 <Eduard_Munteanu> nejucomo: if anyone defines a Char instance they will overlap, that's the idea
07:31:13 <supki> instance selection does not look at contraints
07:31:16 <geekosaur> nothing precludes such an instance being added later (open world)
07:31:47 <nejucomo> Hrmph.
07:32:12 <nejucomo> Since orphan instances are frowned upon, I wish I could rely on the impossibility of orphan instances.  (Not open world.)
07:33:21 <nejucomo> Is there any technical problem preventing a language extension that forbids orphan instances for classes in a given module?
07:33:42 <nejucomo> Ah well, since I have instances for Text I guess I don't need String as much.
07:35:48 <geekosaur> there's a technical proboem with checking modules that may not have been written yet for conformity, yes :)
07:35:57 <elliott> nejucomo: you could have: instance C' t => C [t], where C' provides either a witness of C or a witness of ~ Char
07:36:00 <elliott> or something.
07:36:06 <geekosaur> I believe that ConstraintKinds is aiming toward providing a closed world version though
07:36:47 <Eduard_Munteanu> Well, if you're aiming for closed-world assumptions you don't really need typeclasses at all.
07:38:59 <nejucomo> Hm, maybe I wasn't accurate when I said closed-world.  I meant: Every instance is defined either in the same module as the class *or* the instance type definition; but constraints usage can live in any dependent module of the class module.
07:39:27 <nejucomo> It seems like typeclasses are still very useful with those constraints (and arguable more useful if those constraints can be assumed).
07:43:06 <nejucomo> Even if I accept the status quo, there's one other troubling aspect of that error:  It seems to be raised when I *used* the type class with ambiguous types, but not when I *defined* the overlapping instances.
07:43:42 <nejucomo> If I removed that use, would the error still appear?
07:43:43 * nejucomo tests.
07:45:18 <nejucomo> It does indeed look that way.  In fact, I have a very similar situation with a different class and an instance for [t] as well as String and there's no overlapping instances error.
07:46:03 <nejucomo> Unless I'm missing something, this is a horrible gotcha that could go unnoticed by a library author but would affect library consumers.
07:46:23 <nejucomo> -or else there's still something I don't understand about overlapping instances.
07:49:11 <nejucomo> Indeed, when I add a use: blah :: T \n blah = myMethod "a string" â€” then I get the overlapping instances error.  Without that, the problem still exists but is unannounced during an error free compile.
07:49:38 <nejucomo> This seems like a GHC bug, or is there some reason the compiler cannot detect all possible overlapping instances without concrete uses?
07:50:44 <geekosaur> how much longer would you like your compiel to take while it checks instances that you neither know nor care about?
07:53:39 * hackagebot hunit-rematch 0.1.0.1 - HUnit support for rematch  http://hackage.haskell.org/package/hunit-rematch-0.1.0.1 (TomCrayford)
07:55:27 <Sculptor> yo
07:58:55 <Kneiva> supki: thanks, I'll try with your suggestions
08:06:16 <klrr> what's the opposite of (show) function=
08:06:16 <klrr> ?
08:06:23 <klrr> i want to turn "2" into 2
08:06:30 <shanse> read
08:06:34 <klrr> thanks!
08:06:47 <klrr> > read "2" :: Int
08:06:49 <lambdabot>   2
08:07:05 <nejucomo> geekosaur: My case is: instance C t => C [t]  â€” and â€” instance C [Char]   â€” I'm not sure why detecting overlapping instances here requires checking any instances per se.  Can't an algorithm determine that for any possible t, the type [t] overlaps with [Char] in a practical time bound?
08:07:54 <nejucomo> -or is my specific case not general enough for all overlapping instances?
08:10:02 <merijn> nejucomo: Any parameterised type like [] can be nested any number of times (even with other parameterised types), detecting overlap means checking all these infinite combinations. If you're smart you can probably eliminate a lot of cases, but with a large number of datatypes you get a huge explosion in the number of things to check...
08:12:26 <nejucomo> I see.
08:13:00 <ntelford> if I have a function that returns an IO (Maybe a), would I be better off using MaybeT? quite new to monad transformers so trying to get my head around them
08:13:37 <atp> hello all, a question about the implementation of GHC's IO subsystem on Linux/POSIX. I understand that in multi-threaded mode GHC multiplexes on file descriptors auto-magically using select or epoll or similar. I presume when one issues threadWaitRead or threadWaitWrite from GHC.Conc on a raw file descriptor, this is handled automatically? or must I do something more exotic if I'm dealing with raw file descriptors?
08:13:46 <merijn> ntelford: It depends, if you have a lot of IO (Maybe a)'s and functions that create them, then yes. If you have only one or two, probably not
08:14:30 <merijn> atp: threadWaitRead and threadWaitWrite hand the file descriptor over to the runtime event loop, which will wake up your thread when the state changes
08:14:57 <merijn> atp: iow, no there's nothing else to do
08:15:00 <ntelford> merijn, ok - I'll start without MaybeT and see how things go, cheers
08:15:17 <atp> merijn: on posix, not all file descriptors are created equal -- non-blocking read/write on files for example is not supported. does the IO subsystem know how to handle this issue?
08:15:43 <atp> merijn: i'm asking because i'm planning to read raw data from a device file
08:15:54 <merijn> atp: What do you mean non-blocking read/writes are not supported on files?
08:16:17 <geekosaur> merijn: select()/poll() will never show a disk file as unready
08:16:27 <atp> merijn: exactly that. fds connected to filesystem objects (and not, say sockets) behave differently
08:16:28 <geekosaur> (even over a network filesystem that may be inaccessible, sigh.)
08:16:50 <atp> geekosaur: the bane of my existance -- possibly the only thing ms got right was overlapped i/o
08:16:56 <merijn> atp: That's more of a question to ask the implementor of your device driver
08:17:11 <atp> merijn: hm, i suppose i could just look at the code myself
08:17:29 <atp> merijn: but at least now i know threadWaitRead and such are the entry point from the haskell side
08:17:30 <merijn> atp: I have worked on my own linux device driver and that one supported non-blocking reads just fine in terms of select
08:18:04 <merijn> atp: So the real answer is that haskell just behaves how the underlying OS behaves in terms of allowing blocking/non-blocking reads/writes
08:18:14 <atp> merijn: ok, that's good to know. in this case i'm looking at evdev and i seem to remember reading on lkml that a poll-based interface did exist
08:18:29 <atp> merijn: thanks a lot for your help
08:18:37 <atp> geekosaur: and thanks for yours too
08:18:40 * hackagebot imm 0.5.1.0 - Retrieve RSS/Atom feeds and write one mail per new item in a maildir.  http://hackage.haskell.org/package/imm-0.5.1.0 (koral)
08:21:43 <neutrino> hello
08:21:54 <neutrino> is Applicative => Monad?
08:22:10 <neutrino> I'm not sure where to find docs that confirm that
08:22:15 <neutrino> i'm looking incorrectly
08:22:35 <neutrino> *must be looking incorrectly
08:22:45 <merijn> neutrino: Nope
08:22:51 <merijn> It should be, but isn't
08:22:56 <neutrino> why should it be?
08:23:10 <neutrino> oh right it's that old story about it not being in the standard?
08:23:14 <merijn> Because all monads are applicatives
08:23:38 <theorbtwo> But not all greeks are aristotle?
08:23:39 <neutrino> so why aren't they?
08:23:41 <neutrino> i forgot
08:24:42 <neutrino> actually, i think i gtg
08:28:33 <geekosaur> they're not because nobody has found a good way to do it that doesn't break existing code that adds its own instances *and* does not so relax things that that is permitted but other overlaps are not also inadvertently permitted
08:38:40 * hackagebot esqueleto 1.2.2 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.2.2 (FelipeLessa)
08:51:26 <andrea__> Chousuke: i had fond the solution, instead of Fractional  RealFloat
08:52:25 <Chousuke> andrea__: Floating should be enough though
08:52:32 <Chousuke> like ghc said
08:52:49 <andrea__> Chousuke, floating didn't work
08:53:01 <andrea__> i tried it
08:53:40 * hackagebot Plot-ho-matic 0.2.0.0 - Real-time line plotter for protobuf-like data  http://hackage.haskell.org/package/Plot-ho-matic-0.2.0.0 (GregHorn)
08:53:43 <andrea__> floating  has no Eq
08:53:52 <Chousuke> ah
08:58:32 <int_index> Where can I read about parser combinators shipped with GHC? (in the Text module). Are they distinct from Parsec?
09:02:40 <otters> people that put packages on hackage and give them no documentation confuse me
09:15:53 <byorgey> int_index: yes, they are distinct from Parsec.
09:16:08 <byorgey> int_index: not sure where you can read about them.
09:16:11 <int_index> How do I choose between them?
09:17:11 <byorgey> int_index: oh, don't use the parser combinators that ship with GHC.  They are quite simplistic.
09:17:23 <int_index> Isn't that a good thing?
09:18:41 <byorgey> well, I guess that depends on your point of view.
09:18:49 <byorgey> and what you want to use them for.
09:18:56 <int_index> I'm currently using my own parser combinator library that is quite simple too. I just want to reuse code, so I consider switching to either Parsec or those standard combinators
09:19:01 <byorgey> anyway, you can read about them here: http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-ParserCombinators-ReadP.html
09:20:11 <elliott> I think the stock ones are also slow
09:20:34 <int_index> They can work in parallel, can't they?
09:20:37 <byorgey> int_index: switching to ReadP will probably be easier.  But they are limited in what they can accomplish, and as elliott mentions they are probably also unoptimized.
09:21:08 <byorgey> int_index: no, "in parallel" just means that it abstractly parses all possibilities at once without backtracking.
09:21:17 <byorgey> it does not actually refer to parallelism in the implementation
09:22:02 <int_index> So I don't get a significant boost if I compile it as -threaded -with-rtsopts "-N"
09:22:17 <byorgey> no, you get no boost at all
09:22:21 <elliott> int_index: that is not what it means by parallel
09:22:29 <int_index> Okay.
09:22:42 <byorgey> int_index: really, the only reason ReadP is still there is because various core components (GHC, Cabal) need to do parsing, and since they are core infrastructure they can't depend on big external parsing libraries
09:23:09 <int_index> I see. Then Parsec is a reasonable choice?
09:23:17 <byorgey> yes
09:23:32 <int_index> Thanks.
09:23:38 <byorgey> the only gotcha with Parsec is that it does not backtrack unless you insert explicit calls to "try"
09:23:57 <byorgey> just something to be aware of, to avoid frustration
09:25:03 <int_index> And... do I get a magical boost in speed with Parsec compiling my program threaded?
09:25:32 <byorgey> no
09:25:55 <int_index> And do I ever get it that way?
09:26:01 <ocharles> not often
09:26:28 <byorgey> I am not aware of any parser combinator libraries that give a magical speedup when compiled with -threaded.
09:26:32 <int_index> But I thought that because of purity Haskell can effectively add parallelism to the program.
09:26:44 <byorgey> oh, wait, maybe trifecta can, I'm not sure
09:27:16 <geekosaur> int_index, that might be described as a holy grail that a great many knights are still pursuing
09:27:24 <byorgey> int_index: Haskell never *automatically* adds parallelism.  You still have to give some annotations/hints to say where parallelism is possible.
09:27:46 <geekosaur> turns out it's much harder in practice to do it in a way that doesn;t actually pessimize in many cases
09:27:54 <byorgey> and most parser combinator libraries are not structured in a way that would make it easy to add parallelism.
09:27:59 <elliott> ReadP could do actual parallelism, I think.
09:28:01 <elliott> but it doesn't
09:28:32 <FreeFull> The problem with automatic parallelism is knowing where to stop
09:29:26 <tromp> a haskell implementation is free to evaluate multiple arguments that a function is strict in, in parallel
09:35:31 <dav> I made a very small change to some code and now I get a parse error that I can't figure out, could someone give me a pointer ? => http://paste.debian.net/5376/
09:36:06 <dav> error is: parse error on input `return' (referencing the very last return statement)
09:39:52 <int_index> I'm not sure if you can use 'where' inside the 'do' notation
09:40:49 <monochrom> "where" cannot be attached to "do". "where" is attached to "=".
09:43:41 * hackagebot tfp 0.8 - Type-level integers, booleans, lists using type families  http://hackage.haskell.org/package/tfp-0.8 (HenningThielemann)
09:46:19 <dav> monochrom: what do you mean? I thought if I put all where/do/etc. at the end of line and "tabbed" things by multiple of 4 chars things would work out?
09:49:10 <geekosaur> dav: "where" is not attached to expressions; it is attached to bindings
09:51:44 <monochrom> try it. "main = do" "x<-getLine" "return ()" "where y=x" add layout as you see fit. suppose "where" were attached to "do", then "x" would be available to "where y=x". is it true in reality?
09:53:17 <daniel_w> Hi, I have a bit of a tricky problem. I'm using DataKinds, I have a type "data Tag = T1 | T2" and another type "data Ref : Tag -> * where Ref :: ByteString -> Ref t" and finally "data Data :: Tag -> * where A :: Int -> Data T1; B :: String -> Data T2". I'm trying to write a function with the type Ref t -> Data t, but to do that I need to pattern match on the type, is there anyway that I can do that?
09:53:41 * hackagebot llvm-tf 3.0.0.1 - Bindings to the LLVM compiler toolkit using type families.  http://hackage.haskell.org/package/llvm-tf-3.0.0.1 (HenningThielemann)
09:53:43 * hackagebot tfp-th 0.8 - Template-Haskell code for tfp  http://hackage.haskell.org/package/tfp-th-0.8 (HenningThielemann)
09:53:54 <dav> I'm very confused. I have a binding right after my where clause no?
09:54:30 <dav> Is there *some* indentation that will make my code parse correctly or is there a flaw in the actual content?
09:56:42 <monochrom> I don't see wrong layout there
09:57:00 <byorgey> daniel_w: you need a singleton type, something like   data STag :: Tag -> * where  ST1 :: STag T1; ST2 :: STag T2
09:57:10 <monochrom> oh, I see. this is even worse.
09:57:20 <byorgey> daniel_w: then change  Ref  to   data Ref :: Tag -> * where Ref :: ByteString -> STag t -> Ref t
09:57:36 <monochrom> but I have to go
09:57:37 <byorgey> daniel_w: then you get to pattern-match on the STag value which also determines the type t
09:57:39 <elliott> isn't there a module with standard singleton machinery?
09:58:02 <byorgey> yes, singletons
09:58:10 <byorgey> it might be overkill for this though
09:58:40 <Chousuke> dav: a where clause can't go where you put it :P
09:59:01 <dav> Chousuke: so I must use a lambda or is there something i can do?
09:59:27 <Chousuke> dav: you can do let process name = do ... outside the paths <- expression
09:59:36 <Chousuke> or you can even make it a top-level definition
09:59:40 <daniel_w> byorgey, I hoped there was a way around that. It allows me to write that function, but I'm also trying to create a Serialize (Data t) instance.
10:00:18 <Chousuke> dav: I think the lambda is fine though
10:00:42 <tromp> dav: you can do let process name = do ... before the paths <- line
10:00:59 <daniel_w> Actually I can write Data t -> STag t. So it works, thanks
10:01:02 <dav> Chousuke/tromp - thanks.
10:03:04 <dav> Chousuke/tromp - that worked. I'm not getting why the where clause didn't work but I'm just a beginner :)
10:04:00 <Chousuke> as geekosaur said, a where clause is attached to bindings, not arbitrary expressions
10:05:13 <viller> if I type a tab in a string I get "lexical error in string/character literal at character '\t'". Can't I put tabs in strings in source code?
10:05:54 <dav> Chousuke: you mean a binding must be to its left (as opposed to to its right?)
10:06:00 <geekosaur> dav - if you look closely at the language, "where" is only ever used with things that are declaration-like. "module ... where", "top_level name = ... where", "data Foo where" (GADT extension), "class Foo where", "instance Foo Bar where", etc.
10:06:02 <Chousuke> viller: use \t instead
10:06:14 <geekosaur> also "let foo = ... where"
10:06:29 <daniel_w> byorgey, I've got another problem, is it possible to create a function (X -> Data t) where I can't get a singleton instance from X?
10:06:33 <geekosaur> although that one is not often useful since let is already recursive
10:06:50 <Chousuke> geekosaur: I suppose you could say it's only used for definitions
10:07:18 <viller> Chousuke: heh. I tried \n and thought why does ghci print out "\n" but of course I had to use putStr again
10:07:37 <viller> thanks
10:09:13 <dav> geekosaur: thanks I think I'm starting to get it. Appreciate the help.
10:13:42 * hackagebot llvm-extra 0.4.1.1 - Utility functions for the llvm interface  http://hackage.haskell.org/package/llvm-extra-0.4.1.1 (HenningThielemann)
10:18:42 * hackagebot synthesizer-llvm 0.5.0.2 - Efficient signal processing using runtime compilation  http://hackage.haskell.org/package/synthesizer-llvm-0.5.0.2 (HenningThielemann)
10:24:00 <Garyuutensei> Hi, could some tell me why 'type Vec2 = (# Double#, Double# #)' is illegal and if there's a workaround?
10:25:32 <FreeFull> Garyuutensei: Might only work with data rather than type
10:25:41 <c_wraith> What's the error message say?
10:25:48 <glguy_> You need: UnboxedTuples and MagicHash
10:25:57 <Garyuutensei> Kind mis-match Expected kind `ArgKind', but `Position' has kind `(#)' In the type `Position' In the definition of data constructor `Robot' In the data type declaration for `Robot'
10:26:05 <glguy_> and then you'll get a (Vec2 :: #)
10:26:12 <Garyuutensei> wrong message, sec :P
10:27:22 <Garyuutensei> Yes, so I don't get an error mesage about the Vec2 but about other data using Vec2
10:28:53 <c_wraith> So..  Yeah, the kind of Vec2 is #
10:29:03 <c_wraith> You can only use it in places where that kind is allowed
10:29:17 <c_wraith> and that kind isn't allowed as an argument to most type constructors
10:29:37 <c_wraith> @kind (->)
10:29:39 <lambdabot> * -> * -> *
10:29:53 <c_wraith> hmm.  That's not really the kind of (->).  Odd.
10:30:23 <c_wraith> anyway, so far as I know, you can only use unboxed tuples in the return value of a function.
10:30:54 <glguy_> c_wraith: That restriction may have been lifted recently
10:31:30 <Garyuutensei> c_wraith: Indeed, the ghc docs say " The typical use of unboxed tuples is simply to return multiple values, binding those multiple results with a case expression..."
10:31:44 <c_wraith> it'd be cool if that restriction has been loosened
10:31:56 <glguy_> It looks like the commit for that was in March 2012
10:32:08 <c_wraith> But the error message pasted clearly shows that there are still some places you can't use that kind.
10:32:25 <c_wraith> I suppose allowing them to be used more often is related to the datakinds stuff
10:32:29 <glguy_> Garyuutensei: What problem are you trying to solve?
10:32:35 <c_wraith> if you're allowing data kinds, you might as well allow primitive kinds
10:32:43 <Garyuutensei> glguy: I'm using ghc 7.4.2
10:32:50 <glguy_> Garyuutensei: This is the kind of thing that if you have to ask how to use it you don't need it
10:32:56 <glguy_> at least typically)
10:33:08 <Garyuutensei> glguy_: I'm just trying to make an efficient 2d
10:33:28 <Garyuutensei> ..vector
10:33:43 <c_wraith> the thing is, unboxed tuples have no memory representation
10:33:57 <c_wraith> That makes them not play nicely with the garbage collector
10:34:12 <glguy_> Garyuutensei: Is the point to have a 2D vector or to make one? If you just want one, use: http://hackage.haskell.org/packages/archive/linear/1.1.2/doc/html/Linear-V2.html
10:34:38 <c_wraith> If you need a type that will cooperate with the garbage collector, you can't use unboxed tuples
10:34:51 <byorgey> daniel_w: Perhaps you need to create an existential type   data Data' :: *  where  ExData :: Data t -> Data'
10:34:57 <byorgey> daniel_w: then you can write  X -> Data'
10:35:37 <daniel_w> But I can't write Data' -> Data t
10:35:38 <byorgey> this should work fine because you can always recover t by pattern matching on the value of type Data t
10:36:09 <byorgey> right, you can't, but you *can* write   Data' -> (Data t -> r) -> r
10:36:11 <Garyuutensei> ok, so it's best I make a custom type then
10:36:23 <byorgey> and you can use that everywhere that you wanted   Data' -> Data t
10:38:00 <daniel_w> I'll think about it.
10:38:17 <daniel_w> Thanks for your help
10:54:11 <arnsholt> In "someIO >>= (return . myFunction) >>= moreIO", is there a more idiomatic way to spell "return . myFunction"?
10:54:42 <notdan> arnsholt: liftM myfunction ?
10:54:46 <notdan> @ty liftM
10:54:47 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
10:56:25 <arnsholt> No, I don't think so (GHC didn't like it, at any rate)
10:56:37 <viller> I can't use where in monads?
10:56:41 <arnsholt> >>= wants an a -> m b
10:56:47 <byorgey> well, you would have to write something like   liftM myfunction someIO >>= moreIO
10:57:05 <byorgey> which kind of destroys the nice pipeliney aspect
10:57:18 <arnsholt> Oh, of course. That's why
10:57:37 <arnsholt> My GHC-error-fu isn't all that good yet =)
10:58:12 <viller> I have "do foo <- bar ... where x = someFun foo" and ghci says foo is not in scope
10:58:20 <viller> let works though
10:59:22 <arnsholt> byorgey: At least now I know how to do it. But you're right, the emphasis on the pipeline is lost a bit. I'll have to decide which is more important to my sense of aesthetics =)
10:59:35 <geekosaur> viller, where is part of declaration syntax
10:59:44 <geekosaur> do is not a declaration
11:00:17 <viller> oh so I can't use where in arbitrary expressions like let?
11:00:34 <orzo> I'm looking for a page to read about in more detail "Variable occurs more often in a constraint than in the instance head"
11:01:02 <orzo> What exactly is that telling me, and what should i do abou tit apart from blindly adding Undecidable instances?
11:03:13 <typoclass> orzo: could the problem be that you used a variable in "(Num x) =>", but didn't use x on the right side of "=>"?
11:05:00 <orzo> this is where I say no and you request code
11:05:45 <supki> orzo: it means you have instance declaration similar to  instance C a a => D a where
11:05:55 <viller> geekosaur: thanks anyway
11:07:49 <orzo> maybe C (D a) a => E a counts?
11:08:44 <supki> yes
11:09:33 <orzo> what's the fix for C a a => D a ?
11:10:19 <mm_freak> all those look like undecidable instances to me
11:10:55 <orzo> right so, how would you rewrite C a a => D a and make it decidable, with a newtype i figure
11:11:10 <orzo> what do i wrap in newtype?
11:11:17 <orzo> or is it just not really possible
11:12:24 <mm_freak> orzo: a newtype is fine
11:12:56 <mm_freak> newtype WrappedD a = WrappedD { unwrapD :: a }
11:13:03 <mm_freak> C a a => D (WrappedD a)
11:13:31 <mm_freak> but i wonder why you would need such a class D
11:14:56 <otters> :t (&&& id)
11:14:57 <lambdabot> (c' -> c) -> c' -> (c, c')
11:15:48 <orzo> http://hpaste.org/88257
11:15:57 <orzo> The PiecewiseOrd constraint is the problem
11:16:07 <daniel_w> byorgey: I think I can do it with a typeclass. class TagClass t where tag :: STag t . Then TagClass t => X -> Data t . I can get the tag via the typeclass and continue as normal.
11:16:09 <orzo> I already have a newtype H
11:18:07 <orzo> mm_freak: can you decipher what I should do to resolve the Undecidable from my paste?
11:19:31 <byorgey> daniel_w: that doesn't sound quite right to me.  That type says "given a value of type X, I can give you a value of type Data t *for whatever type t you want*, as long as that type t is an instance of TagClass
11:19:40 <byorgey> my understanding was that t may depend on X.
11:20:06 <daniel_w> no, the t is given by the caller
11:20:18 <byorgey> ohhhh, OK, that was my misunderstanding
11:20:27 <byorgey> yes, I see now, the TagClass should work
11:21:14 <byorgey> explicitly, it would be like doing   X -> STag t -> Data t, where the caller has to explicitly provide a singleton for t
11:21:25 <byorgey> but of course given t there is only one possible STag t they can provide
11:21:38 <byorgey> so the typeclass solution makes the compiler fill in that argument so the caller doesn't have to bother
11:23:21 <daniel_w> yes
11:23:40 <daniel_w> The reason I need that is because I'm implementing a typeclass and so I can't change the signature.
11:33:15 <kennyd> #haskell is the most popular programming channel on freenode at the moment, beating #python by 11 users.
11:33:28 <otters> it's also a lot less terrible than python
11:33:41 <monochrom> yikes
11:33:56 <exicer> Hey guys - why can't I do the following: http://hpaste.org/88258 ?
11:34:04 <exicer> Specifically, the zip won't work.
11:34:17 <ocharles> urgh, I don't get crypto-api. finalize gives you back some d, but there doesn't seem to be a way to go from d -> ByteString
11:34:19 <monochrom> "under the iron wrist of shapr, #haskell is on par with #python, and will likely surpass" :)
11:34:37 <ocharles> presumably that's up to the author of whoever is providing 'd', and crypto-hash has no way to get the data out :(
11:35:15 <byorgey> exicer: what do you want the type of digits to be?
11:35:27 <ski> exicer : just guessing here, did you mean `digits 0 = [(0,0)]' ?
11:35:30 <exicer> Integer I guess
11:35:31 <ocharles> ffs, PureMD5 too!?
11:35:55 <exicer> ski: This is just an intermediate step - so at the end I won't want that
11:36:13 <byorgey> exicer: well, [0] does not have type Integer, nor does  zip blah blah
11:36:26 <exicer> Oh man.. right
11:36:27 <elliott> ocharles: wel, it's in the fundep
11:36:30 <elliott> "d" that is
11:36:45 <exicer> I am not used to having such a strict type system :S
11:36:49 <exicer> Cheers guys!
11:37:15 <ocharles> elliott: eh?
11:37:23 <ocharles> the fundep doesn't help me turn the d into a ByteString
11:37:29 <ski> exicer : usually, when the type system wells at you, there's something in the code which would work correctly if it would have been allowed to run, so you should fix it anyway
11:37:37 <ski> s/wells/yells/
11:37:39 <elliott> ocharles: well, presumably you should constrain d in your signature?
11:37:46 <elliott> ski: s/correct/incorrect/? :)
11:37:48 <ocharles> I have constrained it to MD5
11:37:54 <ski> elliott : and thatÂ¸ yes :)
11:37:55 <ocharles> but I can't turn an MD5 value into... anything except a string
11:38:11 <supki> ocharles: MD5Digest in pureMD5 has both Serialize and Binary instances
11:38:14 <ocharles> and that's via Show
11:38:31 <ocharles> supki: oh, so I can serialize it to a bytestring
11:38:31 <supki> I guess that should be enough to get ByteString
11:39:12 <Fuuzetsu> I don't have fond memories of the last time I tried to use any hashing libraries in Haskellâ€¦
11:39:17 <ski> elliott : if you don't care to think about what to put in the `digits 0' case atm, you could say `digits 0 = undefined' (or `digits 0 = error "todo", or something like that), to make the type checker happy about it, while you're pondering other parts of the code
11:39:24 <ski> exicer : ^
11:39:34 <elliott> ski is mixed up today :)
11:39:37 <applicat2ve_tmp> digits 0 = [(0,0)]
11:39:47 <applicat2ve_tmp> as ski sats
11:40:20 <ocharles> supki: that worked, thanks
11:40:23 <applicat2ve_tmp> as ski says, rather
11:42:40 <applicat2ve_tmp> the behavior of irssi is really opaque.
11:48:17 <exicer> ski: It is taking some getting used to, but I shall perservere
11:48:43 * hackagebot unordered-containers-rematch 0.1.0.0 - Rematch support for unordered containers  http://hackage.haskell.org/package/unordered-containers-rematch-0.1.0.0 (TomCrayford)
11:49:03 <nejucomo> I vaguely recall a template haskell library that had something like undefined, except the error message would include the source location.  I can't find it with hoogle.  Any leads?
11:49:13 <ski> exicer : imo, it's worth it
11:49:25 <ski> exicer : ooc, which languages are you used to ?
11:49:44 <exicer> ski: Mostly Python, but also mathematica (kinda) and javascript(kinda)
11:49:54 <ski> ok
11:50:25 <exicer> I'm still at the stage where I have trouble working out what the error messages I receive mean :)
11:51:55 <nejucomo> This looks like a start: http://hackage.haskell.org/package/file-location-0.4.5.2
11:52:17 <applicat2ve_tmp> exicer: I find that the part that gives the line and column number is frequently the most helpful, maybe not too surprisingly.
11:52:21 <ski> exicer : if you can't figure it out, we're usually happy to try to help
11:53:02 <exicer> ski: So what does "No instance for (Integral [a0])" mean ?
11:53:23 <exicer> This is when I haven't tried to declare any type myself
11:53:25 <ski> exicer : if it says it can't match a type with `->' in it with a type without it, then it probably means you have one too few/many arguments somewhere (or possibly in wrong order)
11:53:37 <geekosaur> exicer, you're using a list as a number
11:53:51 <ski> exicer : looks like you're somewhere using a list instead of a number, or vice versa
11:53:57 <exicer> Ahh, yes that makes sense
11:54:05 <exicer> Right I see
11:54:17 <exicer> Thanks :)
11:54:38 <ski> exicer : i find it often helps to add type signatures for the top-level definitions (and sometimes also for (relevant) internal ones)
11:55:23 <exicer> ski: Even when you are still working out what to do ?
11:55:27 <ski> exicer : that often makes type errors more explicit (because it gives the type checker more info about what you intended, so it an often better explain how it differs from what your code actually tried to do)
11:55:34 <beaky> hello
11:55:36 <ski> exicer : depends, but often, yes
11:55:36 <mizu_no_oto> exicer: You either want to perform an operation on each element of the list (e.g. map (+ 5) xs) or reduce the list to a summary value (e.g. sum xs)
11:55:36 <lambdabot> mizu_no_oto: You have 1 new message. '/msg lambdabot @messages' to read it.
11:56:06 <beaky> is there a function that replaces all the commas in a list like [1,2,3,4,5] with some binary function?
11:56:20 <ski> exicer : however, different people prefer different development styles -- one of the creators of Haskell prefer coding with few type signatures, e.g.
11:56:27 <beaky> e.g. replacing the commas with + gets the sum of the list
11:56:43 <tromp> :t foldl1
11:56:45 <lambdabot> (a -> a -> a) -> [a] -> a
11:56:49 <arnsholt> beaky: There's sum, for summing. In the general cases, you want the fold functions
11:56:49 <ski> (John Hughes, fwiw)
11:57:01 <beaky> > foldl1 (+) [1..10]
11:57:02 <lambdabot>   55
11:57:08 <beaky> hmm what does the 1 stand for?
11:57:13 <beaky> in foldl1
11:57:24 <ski> beaky : it means the list must have at least one element
11:57:25 <applicat2ve_tmp> > foldr (+) 0 [1..10]
11:57:27 <lambdabot>   55
11:57:31 <tromp> start with 1st element
11:57:32 <ski> > foldl1 (+) []
11:57:34 <lambdabot>   *Exception: Prelude.foldl1: empty list
11:57:37 <applicat2ve_tmp> beaky: it's shabby, use foldr and foldl'
11:57:41 <beaky> ah thanks
11:57:54 <beaky> so foldl1 = foldl 0 ?
11:58:06 <applicat2ve_tmp> no
11:58:13 <ski> @src foldl1
11:58:13 <lambdabot> foldl1 f (x:xs) = foldl f x xs
11:58:14 <lambdabot> foldl1 _ []     = undefined
11:58:23 <applicat2ve_tmp> foldl1 op xs = foldl op (head xs) (tail xs)
11:58:35 <applicat2ve_tmp> so xs had better have a head
11:58:40 <beaky> ah
11:58:58 <ski> > foldl1 (\_ _ -> ()) [] `seq` ()  -- hmm ?
11:59:01 <lambdabot>   *Exception: Prelude.foldl1: empty list
11:59:10 <beaky> when should I use foldr over foldl?
11:59:15 <tromp> > foldr [] (:) [a,b,c]
11:59:17 <lambdabot>   Couldn't match expected type `a0 -> b0 -> b0'
11:59:17 <lambdabot>              with actual type...
11:59:24 <tromp> > foldr  (:) []  [a,b,c]
11:59:25 <lambdabot>   [a,b,c]
11:59:26 <applicat2ve_tmp> never use foldl, use foldl'
11:59:30 <ski> you should usually use  foldl'  instead of  foldl
11:59:36 <applicat2ve_tmp> the standard function is foldr
11:59:56 <beaky> @src foldr
11:59:57 <lambdabot> foldr f z []     = z
11:59:57 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:59:57 <applicat2ve_tmp> foldl' is for strict operations, thus for that sum definition its not too bad
12:00:12 <applicat2ve_tmp> @src foldl'
12:00:13 <lambdabot> foldl' f a []     = a
12:00:13 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
12:00:13 <ski> use it to summarize a list of info into a small amount of information
12:00:17 <applicat2ve_tmp> @src foldl
12:00:17 <lambdabot> foldl f z []     = z
12:00:17 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:00:21 <tromp> > foldr  f z  [a,b,c]
12:00:24 <lambdabot>   f a (f b (f c z))
12:00:26 <beaky> foldr seems to be a backwards foldl
12:00:40 <beaky> or am I mistaken? :D
12:00:48 <ski> `foldr' is for infinite lists, and for computing large, lazy results
12:01:00 <applicat2ve_tmp> beaky: yes, but the main point is that it is 'tail recursive' as they say. under suitable circumstances the compiler can make something of this
12:01:05 <beaky> ah
12:01:06 * ski would rather say `foldl' is a backwards `foldr' ;)
12:01:23 <beaky> foldr makes f the focus of the function, while foldl recurses on the result of f
12:02:35 <ski> > foldr (\n _ -> n) (error "unused") [0 ..]
12:02:37 <lambdabot>   0
12:02:42 <ski> > foldl (\_ n -> n) (error "unused") [0 ..]
12:02:53 <applicat2ve_tmp> where suitable strictness conditions aren't mate, foldl (no ') is a disaster
12:02:54 <lambdabot>  Terminated
12:03:17 <applicat2ve_tmp> arent met, rather
12:03:38 <applicat2ve_tmp> I decided to call my editor in the middle of that sentence, for some reason...
12:05:20 <applicat2ve_tmp> theres a pretty good discussion of foldl foldr and what is more important, the underlying forms of recursive definition they encapsulate in
12:05:30 <beaky> ah
12:05:32 <applicat2ve_tmp> http://www.slideshare.net/tibbe/highperformance-haskell around pp 8 - 30
12:05:46 <beaky> foldl reminds me of std::accumulate from C++
12:06:10 <Fuuzetsu> Should be the other way around :P
12:06:43 <applicat2ve_tmp> foldl' ideally acts to accumulate, yes.  I somehow feel one does better to do the recursion explicitly when you want a foldl'
12:09:14 <beaky> so foldl' is for tail recursion, and foldr is for laziness?
12:11:59 <applicat2ve_tmp> the definitions of foldl and foldl' are syntactically speaking tail recursive
12:12:23 <applicat2ve_tmp> but whether you get something good from that in haskell is another question
12:12:36 <beaky> I like how haskell lets you define general functions like foldl
12:13:40 <applicat2ve_tmp> yes, that's the point of it, I'd say
12:14:05 <applicat2ve_tmp> foldl itself is not the best example of this though.
12:14:49 <applicat2ve_tmp> foldr is the best example....
12:14:58 <beaky> ah
12:16:12 <Eduard_Munteanu> Not many people know foldr actually stands for "folding the right way(tm)"
12:16:16 <Eduard_Munteanu> :P
12:16:23 <beaky> lol
12:16:48 <Eduard_Munteanu> Well, it's the morally correct fold for non-strict languages, if you can choose.
12:17:12 <applicat2ve_tmp> foldl means folding the loony way
12:17:27 <Eduard_Munteanu> Yeah, like the imperative loons :)
12:17:33 <applicat2ve_tmp> foldl' means, folding the way that vaguely suggests you might better be using another language...
12:17:44 <satvikchauhan> I am having problem in writing a generator (for quickcheck) which generates a list of given size but with unique elements.
12:18:10 <applicat2ve_tmp> does it have an instance for Data.Set things?
12:18:44 * hackagebot persistent-mysql 1.2.1 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-1.2.1 (FelipeLessa)
12:19:47 <beaky> is there a way to write foldr in terms of map?
12:19:58 <beaky> or map in terms of foldr
12:20:00 <satvikchauhan> applicat2ve_tmp: I am not using Data.Set. But does it have an arbitray instance? If yes I can use that too. It is that my Data structure has a part which requires list of unique elements
12:20:01 <Eduard_Munteanu> beaky: no, but you can do it the other way around
12:20:53 <applicat2ve_tmp> satvikchauhan: that's what I was thinking that you might go via Set, which would give uniqueness, but then theres the fixed size...
12:23:22 <beaky> wow I didn't know map can be defined from foldr
12:23:28 <exicer> Is there a straightforward way of creating a program that I can import into ghci, but also run from the command line? Eg it has a main loop, but the functions called in main can be imported.
12:25:11 <arkeet> beaky: anything that consumes a list can be defined using foldr.
12:25:24 <Eduard_Munteanu> > foldr ((:) . succ) [] [1,2,3,4]
12:25:26 <lambdabot>   [2,3,4,5]
12:25:35 <Eduard_Munteanu> > map succ [1,2,3,4]
12:25:36 <beaky> > let concatenateStrings = foldr (++) "" in concatenateStrings ["h", "e", "l", "l"]
12:25:38 <lambdabot>   mueval-core: NotAllowed "These modules have not been loaded:\nL\n"
12:25:39 <lambdabot>   "hell"
12:25:45 <Eduard_Munteanu> Huh?
12:25:47 <Eduard_Munteanu> > map succ [1,2,3,4]
12:25:49 <lambdabot>   [2,3,4,5]
12:25:51 <arkeet> :t \f -> foldr ((:) . f) []
12:25:52 <lambdabot> (a -> b) -> [a] -> [b]
12:26:32 <Fuuzetsu> is lambdabot having mueval issues again?
12:26:33 <Eduard_Munteanu> @src map
12:26:33 <lambdabot> map _ []     = []
12:26:34 <lambdabot> map f (x:xs) = f x : map f xs
12:26:45 <Fuuzetsu> I'm sure Cale would love to hear that.
12:26:49 <mm_freak> exicer: just turn it into a cabal package and install it
12:26:54 <Eduard_Munteanu> They look like race conditions or something. :/
12:27:01 <mm_freak> exicer: then you can use :m/import in GHCi as well as install a command line program
12:27:45 <applicat2ve_tmp> exicer: I don't know if there's a straightforward way.  you can use '--main-is' or whatever that ghc flag is, when compiling, but call main meredith or something.
12:27:50 <beaky> I didn't know foldr was such a general function
12:29:49 <applicat2ve_tmp> exicer: oh I think I misunderstood the question
12:30:49 <beaky> > let findAnElementAccordingToATrueFalseFunction predicate = foldr (\x xs -> if predicate x then x : xs else xs) [] in findAnElementAccordingToATrueFalseFunction (< 6) [1..10]
12:30:52 <lambdabot>   [1,2,3,4,5]
12:31:16 <monochrom> findAnElementAccordingToATrueFalseFunction is why both camel case and "meaningful" names are wrong
12:31:34 <dmwit> But the name is wrong.
12:31:46 <beaky> yeah in every other programming language I prefer all lowercase names and underscore_between_words
12:31:49 <monochrom> yes, that's part of the game of "meaningful" names
12:31:50 <applicat2ve_tmp> monochrom: I think beaky need only apply a little more imagination
12:32:24 <beaky> but in Haskell somehow my naming style feels "out of place"; because the stdlib uses camelCase and the language itself requires PascalCase for typenames
12:32:24 <dmwit> I don't see why it shows that meaningful names are bad. It just needs to be balanced with "concision is the soul of wit".
12:32:29 <mm_freak> > let safeLast = foldr (const Just) Nothing in safeLast [1..5]
12:32:32 <lambdabot>   Occurs check: cannot construct the infinite type:
12:32:32 <lambdabot>    a0 = Data.Maybe.Maybe a0
12:32:49 <monochrom> part of the game of "meaningful" names is choosing wrong "meaning"s
12:32:55 <dmwit> =)
12:33:03 <beaky> ah I forgot about const and that other function
12:33:21 <beaky> iirc const is the 'k' in the ski
12:33:25 <dmwit> :t foldr (const . Just) Nothing
12:33:27 <lambdabot> [a] -> Maybe a
12:33:53 <dmwit> but even better is
12:33:55 <dmwit> :t reverse
12:33:56 <lambdabot> [a] -> [a]
12:33:59 <dmwit> ;-)
12:34:16 <mm_freak> d'oh
12:34:29 * applicat2ve_tmp recommends 'declaw' for findAnElementAccordingToATrueFalseFunction 
12:34:33 <beaky> > let reverseMyList = foldr const [] in reverseMyList [1..10]
12:34:35 <lambdabot>   No instances for (GHC.Enum.Enum [a0], GHC.Num.Num [a0])
12:34:35 <lambdabot>    arising from a u...
12:34:43 <applicat2ve_tmp> or maybe 'filter' or something
12:35:14 <dmwit> :t foldr (\x xs -> xs ++ [x]) [] -- but don't do this with foldr
12:35:16 <lambdabot> [a] -> [a]
12:35:16 <applicat2ve_tmp> corrugate
12:35:25 <mm_freak> > let safeLast = foldr (\x y -> const y <|> Just x) Nothing in safeLast [1..5]
12:35:26 <lambdabot>   Couldn't match expected type `b0 -> a0'
12:35:26 <lambdabot>              with actual type `Data...
12:35:31 <mm_freak> > let safeLast = foldr (\x y -> y <|> Just x) Nothing in safeLast [1..5]
12:35:33 <lambdabot>   Just 5
12:35:54 <Fuuzetsu> :t (<|>)
12:35:56 <lambdabot> Alternative f => f a -> f a -> f a
12:36:19 <Fuuzetsu> ?index (<|>)
12:36:19 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
12:36:26 <dmwit> ew
12:36:34 <mm_freak> safeHead is easier
12:36:36 <dmwit> ?hoogle (<|>)
12:36:37 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
12:36:38 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
12:36:38 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
12:36:40 <dmwit> safeHead = id
12:36:45 <quchen> Fuuzetsu: <|> is from Alternative, which is to Applicative what MonadPlus is to Monad.
12:36:58 <quchen> Think of it as <|> = mplus, empty = mzero.
12:37:24 <mm_freak> > let safeHead = foldr (const . Just) Nothing in safeHead [1..5]
12:37:26 <lambdabot>   Just 1
12:37:32 <Fuuzetsu> It's just that I saw it most used as the Parsec operator so it surprised me there
12:37:37 <dmwit> > let safeHead = id in safeHead [1..5]
12:37:39 <lambdabot>   [1,2,3,4,5]
12:37:43 <dmwit> > let safeLast = reverse in safeLast [1..5]
12:37:45 <lambdabot>   [5,4,3,2,1]
12:37:47 <monochrom> Alternative is inspired by Parsec
12:37:48 <mm_freak> Fuuzetsu: parsec's (<|>) is just a special case of Alternative's (<|>)
12:37:52 <beaky> so monads are just a special case of foldr?
12:38:00 <dmwit> beaky: wat
12:38:01 <mm_freak> beaky: what?
12:38:02 <ion> â€¦
12:38:04 <Fuuzetsu> hue
12:38:05 <quchen> NO
12:38:06 <quchen> .
12:38:07 <quchen> :-)
12:38:19 <monochrom> yes
12:38:21 <beaky> since you can define list comps using foldr, and monads are list comprehensions
12:38:27 <monochrom> yes
12:38:44 * hackagebot prizm 0.1.0.2 - A haskell library for computing with colors  http://hackage.haskell.org/package/prizm-0.1.0.2 (ParnellSpringmeyer)
12:38:44 <quchen> Monads are list comprehensions - "yes"?
12:38:45 <dmwit> Monads are list comprehensions?
12:38:46 <Fuuzetsu> Since when are monads list comprehensions? Am I missing something?
12:39:06 <mm_freak> beaky: what?!  you may be confusing "monads" with "the list monad" =)
12:39:08 <beaky> oops I meant the other way: lists are monads
12:39:11 <dmwit> There are monad comprehensions. But they can't be done with foldr.
12:39:11 * monochrom decides to just say yes to end the "discussion"
12:39:28 <quchen> Devious.
12:39:29 <beaky> and a monad is just a foldr
12:39:33 <quchen> No.
12:39:33 <dmwit> no
12:39:36 <beaky> ah :(
12:40:00 <djahandarie> beaky, where'd you learn that?
12:40:29 <dmwit> beaky: Your failed syllogism goes like this: "You can define list comprehensions using foldr. Lists are monads. Therefore list comprehensions are monads." There's so many mistakes embodied there it's hard to know where to start.
12:40:43 <ion> djahandarie: In troll academy.
12:41:06 <dmwit> "foldr is not a list" is probably the easiest place to start.
12:41:35 <Fuuzetsu> > repeat [foldr]
12:41:37 <lambdabot>   [*Exception: showList: No overloading for function
12:41:54 <beaky> I guess foldr is more general than a list
12:42:00 <beaky> it's like a data constructor
12:42:00 <quchen> No.
12:42:17 <dmwit> < repeat [id]
12:42:18 <goodfellow>   [[[((),())]],[[((),())]],[[((),())]],[[((),())]],[[((),())]],[[((),())]],[[...
12:42:18 <Fuuzetsu> foldr is just a function
12:42:23 <mm_freak> beaky: foldr is a fold, specific to the list type
12:42:26 <Fuuzetsu> < repeat [foldr]
12:42:27 <goodfellow>   No instance for (Data.Universe.Class.Finite [a0])
12:42:27 <goodfellow>    arising from a use of ...
12:42:32 <mm_freak> it has little to do with monads, although both can be captured categorically
12:42:35 <lispy> the concept of a foldr is very general. Prelude.foldr is specific to lists.
12:42:49 <dmwit> Fuuzetsu: I've been considering adding an Empty type class so you could write instance Empty a => Finite [a], but...
12:42:51 <elliott> lispy: s/r//?
12:42:57 <djahandarie> (BTW, beaky, I hope you realize that everything you're saying makes very little sense. It's like your sampling random words out of a haskell guide and forming gramatically-valid sentences out of them.)
12:42:58 <dmwit> Haven't seen a need for it in real code yet. So.
12:43:25 <mm_freak> beaky: start with the following premise:  monads are type constructors
12:43:32 <mm_freak> that invalidates about everything you said about monads so far =)
12:43:36 <beaky> ah
12:43:45 <mm_freak> so [] is a monad, Maybe is a monad
12:43:49 <mm_freak> Maybe Int is not a monad
12:43:54 <mm_freak> much less any value
12:43:59 <beaky> maybe Int is a monad instance?
12:44:02 <lispy> elliott: right associative fold is very general.
12:44:07 <mm_freak> beaky: no, it's just a type
12:44:14 <beaky> ah
12:44:24 <beaky> oops meant Maybe Int
12:44:33 <mm_freak> i assumed that =)
12:44:42 <beaky> or is Maybe the monad
12:44:44 * djahandarie is not sure why everyone wants to teach beaky the One True Way rather than figure out how he confused himself to this degree -- maybe he's using a really bad resource like a monad burrito tutorial
12:44:51 <mm_freak> beaky: yes, Maybe is a monad
12:45:01 <mm_freak> (note: /a/ monad, not /the/ monad)
12:45:24 <Fuuzetsu> djahandarie: I actually haven't encountered that tutorial yet.
12:45:31 <Fuuzetsu> Maybe I should finally go and look for it.
12:45:45 <elliott> lispy: well, it's not obvious how to generalise foldl... I would say it's fold that's very general, since the "r" part of "foldr" just arises naturally because lists are defined right-associatively
12:45:49 <elliott> but perhaps I am missing something
12:46:12 <shachaf> @ty Data.Foldable.foldl -- hth
12:46:13 <lambdabot> Foldable t => (a -> b -> a) -> a -> t b -> a
12:46:52 <mm_freak> elliott: no, i agree thereâ€¦  foldl is not a fold in the sense of bananas, lenses and barbed wire
12:47:01 <dmwit> I think associativity is a funny word to use for a binary operation which is not of type (a -> a -> a).
12:48:29 <dmwit> > foldl f z [w,x,y]
12:48:31 <lambdabot>   f (f (f z w) x) y
12:48:38 <mm_freak> dmwit: associativity is a law, while "right/left-associativity" is just a notation rule
12:48:39 <dmwit> > foldr (flip f) z (reverse [w,x,y])
12:48:40 <lambdabot>   f (f (f z w) x) y
12:48:44 * hackagebot clay 0.7 - CSS preprocessor as embedded Haskell.  http://hackage.haskell.org/package/clay-0.7 (SebastiaanVisser)
12:48:51 <mm_freak> so it's fine to say that (:) is "right-associative"
12:48:58 <quchen> dmwit: My naive answer would be that it doesn't make sense for a non-aaa-operation, but then I stopped being surprised in here a long time ago ;-)
12:49:08 <beaky> in what places is functional programming inappropriate?
12:49:22 <dmwit> Everywhere. NEXT
12:49:32 <companion_cube> embedded systems?
12:49:35 <dmwit> Show us some broken code or something.
12:49:38 <mm_freak> beaky: which nails can't you hammer with a good hammer?
12:49:47 <mm_freak> companion_cube: disagreed
12:49:52 <beaky> hmm I want to use functional reactive programming in embedde dsystems
12:50:04 <companion_cube> well, unless you have a functional system with predictible memory usage
12:50:08 <beaky> because embedded systems are quite reactive?
12:50:11 <Fuuzetsu> make sure to use agile enterprise methods
12:50:13 <companion_cube> (synchronous languages, perhaps)
12:50:38 <mm_freak> companion_cube: functional programming is a styleâ€¦  you can do it in C
12:50:50 <Fuuzetsu> Please don't try though.
12:50:54 <companion_cube> if you just mean "programming using functions", then yes
12:50:57 <mm_freak> Fuuzetsu: why not?
12:51:31 <mm_freak> imperative style:  fopen; fwrite; fclose
12:51:35 <Fuuzetsu> Passing functions around and implementing everything so it works and doesn't leak memory is hard and looks horrible.
12:51:39 <mm_freak> functional style:  withFile fwrite
12:51:50 <mm_freak> that's a good style and you should use it in C
12:52:18 <beaky> I guess a barebones haskell would be nice for embedded development, with all the type checking
12:53:26 <companion_cube> mm_freak: looks tough without a GC nor closures
12:53:33 <Zeev> every software needs less bugs (as little as possible). Slower speed can usually be countered with more optimised hardware but bugs are intolerable on everyone
12:53:35 <mm_freak> companion_cube: you don't need either
12:53:42 <companion_cube> (the fwrite is probably a closure)
12:53:53 <companion_cube> (if you give it to withFile)
12:54:05 <Fuuzetsu> You can emulate closures but rather poorly.
12:54:11 <mm_freak> companion_cube: http://ertes.de/techblog/2009-02-19-1-continuations-for-secure-code.html
12:54:13 <companion_cube> on embedded systems, you can also try to prove your code
12:54:17 <Zeev> even, (and especially) in embedded
12:54:18 <companion_cube> (even in C)
12:54:20 <mm_freak> you don't need closures at all for this
12:54:23 <doomlord__> efficient software.. energy is always an issue. energy use of software matters for consumers (eg batteries in cellphones) and datacentrres (massive electricity bills)
12:54:36 <mm_freak> and "closure" doesn't really make much sense in C anyway
12:54:42 <companion_cube> mm_freak: that's the problem
12:54:46 <doomlord__> its better to talk about efficiency than speed.. you can make anything fast by wasting energy
12:55:05 <companion_cube> well, withFile would take a function pointer, a void* as a closure context, and give the pointed function both the void* and the FILE*
12:56:20 <mm_freak> companion_cube: the void * is anything you want it to be
12:56:34 <companion_cube> yeah, it's the standard way of replacing closures in C
12:56:39 <mm_freak> right
12:56:49 <carter> dmwit lemme know what you find out on the discount info
12:56:50 <companion_cube> but still, I'm not sure it's a better style
12:58:03 <beaky> haskell would be a perfect fit for embedded systems
12:58:21 <companion_cube> beaky: you need to prove you have no space leak
12:58:38 <ski> conceptually, using a context/environment `void *' to emulate closures, is using existentials
12:58:40 <beaky> yeah that's probably what's holding haskell back; the nondeterminism and stuff :(
12:59:12 <mm_freak> companion_cube: haskell's memory model is actually very predictable, if you follow a few basic rules
12:59:20 <monochrom> I prove I have no space leak all the time. Haskell or C.
12:59:20 <mm_freak> well, GHC's
12:59:49 <companion_cube> I mean, on many embedded systems in C or Ada, they don't even use malloc() (or the Ada equivalent)
13:00:13 <mm_freak> you don't really use malloc() in haskell either, unless you use Foreign.* modules
13:00:24 <companion_cube> you know what I mean
13:00:27 <companion_cube> dynamic allocation
13:00:32 <beaky> yes GHC is sufficiently smart to make everything go on the stack
13:00:43 <companion_cube> really? oO
13:00:54 <mm_freak> companion_cube: yes, but there is an important difference:  what the RTS does i would call "micro allocations" and "micro GC"
13:01:05 <elliott> that's news to me :P
13:01:07 <companion_cube> on the stack?
13:01:09 <doomlord__> i'd have thought haskells execution model is heavy on pointer chasing and allocations
13:01:12 <companion_cube> that sounds quite impressive
13:01:18 <mm_freak> beaky: huh?  GHC's RTS doesn't even use a stack except for pattern matching
13:01:30 <doomlord__> 'cactus stacks' ,arent' those inherently more pointer-based..
13:01:31 <beaky> oh right I'm mistaken
13:01:42 <monochrom> beaky, you seem to be very misinformed overall. please don't opine until you find out more.
13:01:48 <mm_freak> doomlord__: that's true, but the underlying operations are very lightweightâ€¦  otherwise GHC haskell wouldn't be that fast
13:02:01 <companion_cube> well, that's generational GC, I guess
13:02:11 <companion_cube> you still need a heap and a GC
13:02:17 <mm_freak> i assert that an allocation in GHC's RTS isn't much slower than allocating a stack frame
13:02:59 <companion_cube> but it's less predictible
13:03:07 <doomlord__> horses for courses... i dont think anything can hope to be as fast as c without having its pain. convinience/speed tradeoff. c allows speedups where you reason about allocation at the algorithmic level
13:03:10 <companion_cube> predicable*
13:03:35 <companion_cube> Ada is a good fit for embedded systems
13:03:45 <doomlord__> anyone here into rust ?
13:04:05 <mm_freak> doomlord__: my number theory code (Integer in GHC-haskell) generally outperforms C (GMP's mpz_*), so i can't agree there
13:04:16 <Chousuke> doomlord__: I don't a language needs to be like C to be fast.
13:04:27 <dario> *think ?
13:04:31 <Chousuke> yeah
13:04:36 <Chousuke> C is just very small
13:04:39 <Fuuzetsu> not fastest doesn't automatically make it slow
13:04:41 <monochrom> @quote monochrom einstein
13:04:41 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
13:04:45 <Chousuke> and people have had a lot of time to make it go fast.
13:04:45 <beaky> C++ is one of those languages that can achieve the speed of C (and perhaps even greater than C) with no pain and more elegance; std::sort vs qsort is a nice example
13:05:26 <mm_freak> doomlord__: C's insistence on a call stack disallows a varierty of optimization opportunities GHC usesâ€¦  for example in C "f(); g();" works by "call f, f returns, call g, g returns"
13:05:36 <mm_freak> in GHC-haskell f is more likely to jump to g directly
13:05:56 <mm_freak> what is fast in C is number crunching on Doubles or machine integers
13:06:08 <companion_cube> anyway, on critical embedded systems most optimizations are disabled
13:06:09 <mm_freak> haskell has some room for improvement there
13:06:38 <Chousuke> Ada is a pretty neat language by the way
13:06:56 <Chousuke> Though it felt a bit verbose the one time I actually had to use it.
13:07:16 <Chousuke> not as bad as Java, but still
13:08:43 <Chousuke> There's something about Java that makes people abstract things so much that everything becomes extremely verbose
13:09:03 <mm_freak> Chousuke: the syntax?
13:09:04 <pantsman> java is extremely verbose anyway
13:09:05 <c_wraith> that "something" is better known as "the standard libraries"
13:09:18 <Chousuke> in Haskell it seems to be the exact opposite. The more you abstract, the denser code becomes
13:09:18 <c_wraith> The standard libraries are stuffed full of overabstraction
13:09:35 <mm_freak> i dislike any language that has a "null" value
13:09:37 <beaky> the java philosophy is to shoehorn design patterns and enterprise software development methodologies everywhere
13:09:48 <mm_freak> not sure if ada has that, but java certainly does
13:10:16 <pantsman> java libraries tend to underabstract, that is why it is so verbose to use them
13:10:47 <Chousuke> pantsman: one reason might be that they can't express the abstractions that are actually needed
13:11:27 <Chousuke> just today I saw a bit of example code that implemented an interface and all the 10+ method implementations did was proxy to a delegate.
13:11:40 <Chousuke> 30 lines of code that did nothing
13:11:41 <pantsman> Chousuke, I'd say so
13:12:23 * elliott wonders the relevance to haskell
13:12:28 <beaky> and also, the object-oriented philosophy of having a getter and a setter for every private member variable (which kinda defeats the point of OOP and undermines information hiding)
13:12:35 <beaky> yeah this is all off-topic :(
13:13:03 <Fuuzetsu> Chousuke: FactoryFactoryFactory
13:13:13 <pantsman> that is not so much "OO philosophy" as "the java bean specification"
13:14:20 <monochrom> clearly, you don't even know how getters and setters relate to the private variables
13:14:54 <monochrom> I mean general "you", and I mean for some hidden code I would write.
13:16:03 <Chousuke> Fuuzetsu: "Fix Factory" should make the enterprise types happy.
13:16:12 <monochrom> for example, I may give you "set size" and "get size", but my implementation may be not using one single variable for "size", it may be more complex than you think.
13:16:38 <Fuuzetsu> Chousuke: always related https://github.com/Mikkeren/FizzBuzzEnterpriseEdition
13:16:55 <shachaf> The joke is that some Java code is verbose!
13:17:08 <Fuuzetsu> â€¦some, right
13:18:45 * hackagebot pipes-safe 1.2.0 - Safety for the pipes ecosystem  http://hackage.haskell.org/package/pipes-safe-1.2.0 (GabrielGonzalez)
13:19:39 <scooty-puff> are there any prebuilt binaries of ghc that come with debug symbols?
13:19:59 <c_wraith> in GHC itself?
13:20:06 <Cale> https://github.com/gpc/grails-searchable/blob/master/src/java/grails/plugin/searchable/internal/compass/config/mapping/SearchableClassPropertySearchableGrailsDomainClassMappingConfigurator.java
13:20:17 <scooty-puff> yes - or whatever is required to use -debug, etc., anyways
13:21:22 <Fuuzetsu> Quality naming scheme, as always.
13:22:19 <scooty-puff> (i am attempting to follow http://hackage.haskell.org/trac/ghc/wiki/Debugging/CompiledCode)
13:22:51 <nejucomo> I'm playing around with template haskell for the first time.  When I use TupE in ghci, it believes the result is an unboxed tuple.
13:23:11 <nejucomo> This causes a segfault in ghci: $( return $ UnboxedTupE [] )
13:23:41 <nejucomo> Has anyone experienced this?
13:23:45 * hackagebot snaplet-mongodb-minimalistic 0.0.6.9 - Minimalistic MongoDB Snaplet.  http://hackage.haskell.org/package/snaplet-mongodb-minimalistic-0.0.6.9 (PetrPilar)
13:25:26 <byorgey> Cale, wat
13:25:39 <dmwit> carter: Just went to talk to Cheryl, but she's not in just now.
13:25:51 <Cale> nejucomo: I just get a kind error
13:25:59 <dmwit> carter: /join #haskell-hacphi!
13:26:10 <Cale> nejucomo: Which ghc? I'm on 7.6.2 at the moment
13:26:10 <shachaf> dmwit: /join #bayhac!
13:26:11 <carter> dmwit thanks. I called and somehow was talking to someone else and they gave me the upenn discount
13:26:19 <dmwit> shachaf: bayhac is OVER (isn't it?)
13:26:28 <dmwit> carter: eeeexcellent
13:26:35 <shachaf> dmwit: But #bayhac isn't!
13:27:04 <Cale> nejucomo: It makes sense that it would be a kind error, because return is polymorphic, so there's no hope of it working on unboxed stuff.
13:27:06 <nejucomo> carter: 7.4.1
13:27:14 <carter> nejucomo huh?
13:27:20 <Cale> oh, no, not return
13:27:25 <Cale> print is polymorphic :)
13:28:04 <Cale> case $( return $ UnboxedTupE [] ) of (# #) -> 0
13:28:08 <Cale> should work
13:28:16 <mstksg> can someone explain to me the best way to get ad-hoc polymorphism?  like if i want to define foldr for my arbitrary container and have it be a different implementation, what do i have to do?
13:28:27 <scooty-puff> do direct ByteArray# or MutableByteArray#s need to be touched (by whatever means) at the end of a set of operations when used directly?
13:28:37 <dmwit> mstksg: Make your type an instance of Foldable
13:28:48 <scooty-puff> or rather the data type that points to them
13:28:55 <dmwit> mstksg: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Foldable.html
13:29:09 <shachaf> The best way is to not have ad-hoc polymorphism.
13:29:29 <shachaf> By the way, if you make a Foldable instance, *please* define foldMap! It's much more important than foldr.
13:29:32 <nejucomo> Cale: I completely understand that.  However, I am using *TupE*, not UnboxedTupE, yet it still claims the type is (##)
13:29:33 <dmwit> Why? Ad-hoc polymorphism is great. We love it here in Haskell land.
13:29:33 <Cale> mstksg: You have a few options: 1) Name your function something else. (Often overlooked, but quite reasonable.)  2) Put your implementation in a separate module and import the Prelude hiding foldr inside your module.
13:29:43 <Cale> mstksg: 3) Make an instance of Foldable.
13:30:00 <dmwit> Type classes are wonderful!
13:30:14 <Cale> nejucomo: This works for me:  case $( return $ TupE [] ) of () -> 0
13:30:43 <Cale> dmwit: Type classes aren't really ad-hoc polymorphism though
13:31:11 <Cale> Despite the paper introducing them mentioning ad-hoc polymorphism a lot
13:31:21 <Cale> It's really something quite a bit different and more powerful.
13:31:46 <Cale> Specifically, it's more powerful because you can define type class polymorphic things just by making use of other type class polymorphic things.
13:32:24 <Cale> while you can't really do that with ad-hoc polymorphism, which tends to require knowing the type exactly in order to pick an implementation wherever you make use of something ad-hoc polymorphic
13:32:35 <nejucomo> Cale: observe: http://hpaste.org/88262
13:32:46 <Cale> nejucomo: Get newer ghc
13:32:59 <nejucomo> Ok.
13:33:06 <Cale> ghci> :t $( return $ TupE [] )
13:33:06 <Cale> $( return $ TupE [] ) :: ()
13:33:14 <nejucomo> I don't suppose I can cabal install â€”upgrade my ghc?
13:33:16 <Cale> That is really weird though
13:33:22 <Cale> nope :/
13:33:46 <Cale> If you're on linux, just grabbing the binary package from the ghc website should do though
13:33:47 <nejucomo> Well, I'm glad someone agrees it is also weird, thus enabling me to preserve some sanity.
13:33:53 <nejucomo> I like to build from source.  ;-)
13:34:03 <Cale> Building from source is kind of pointless.
13:34:21 <Cale> (Unless you're making changes)
13:35:16 <scooty-puff> the linux binary package i have for 7.6.3 did not come with debug versions of the rts, is this true in general?
13:35:18 <Cale> You always need a working GHC to compile GHC, and while you have a working GHC installed, it'll take a lot more time and waste heat to compile than it would take just to replace your existing binary GHC with the new one.
13:35:33 <Cale> scooty-puff: What did you download?
13:35:34 <nejucomo> I like to be able to dig into source code after the fact and know that the binary was generated from a process I control.
13:35:42 <Cale> scooty-puff: I don't think that's normal...
13:36:01 <nejucomo> Although, I'm not sure it's worth the waste heat.  It's just a bit of obsession.
13:36:37 <Cale> nejucomo: But ehehe, someone early on in GHC's life could have put code into the compiler which gets added whenever you build a new GHC and which doesn't appear in the source code.
13:37:05 <scooty-puff> Cale: it may be that i got ghc 7.6.3 right after it was released, or other random things - i will reinstall it
13:37:17 <Cale> If you can't trust the GHC binary, then you can't trust GHC to compile GHC :)
13:37:20 <nejucomo> cale: Sure, I can be pwned.  I also run cabal all the time, and AFAICT there's no encryption or signatures.  My goal is learning / exploration, not security.
13:37:45 <Cale> nejucomo: You could also just download the source version like I do, just to have the source handy.
13:37:52 <Cale> and install from binary :P
13:37:55 <nejucomo> -but I'm going with your suggestion this time simply out of impatience.  ;-)
13:38:06 <nejucomo> Yeah, that seems far more practical.
13:38:28 <Cale> scooty-puff: I don't have 7.6.3 at the moment, but *usually* I think they come with profiling libraries.
13:38:57 <Cale> Unless someone messed up generating the package, or they decided for some reason they were going to make it hard for people to profile anything.
13:39:05 <c_wraith> as far as I know, only distros like debian don't include profiling libs
13:39:31 <Cale> Ah, yeah, debian likes to chop GHC into a million tiny packages for some reason
13:39:44 <doomlord__> "C++ is one of those languages that can achieve the speed of C (and perhaps even greater than C) " <<<
13:40:06 <doomlord__> you can get as fast as C for fewer lines of code, but what would let C++ get faster than C ?
13:40:06 <Cale> doomlord__: That statement is about as true for Haskell as it is for C++
13:40:22 <scooty-puff> Cale: its not the profiling libraries i'm looking for - it def has those - its the debug ones
13:40:51 <acube> doomlord__: Maybe expression templates?
13:40:52 <doomlord__> i dont thikn C++ can do anything C can't. it can just do it more elegantly. and idiomatic C++ is heavier on dynamic allocations.
13:40:58 <Cale> scooty-puff: Oh, those are separate from the profiling ones now? Interesting.
13:41:13 <doomlord__> what does "expression templates" mean in low level terms
13:41:19 <Cale> doomlord__: It depends on what you mean by "doing things that C can't"
13:41:30 <doomlord__> r.e. specifically, beating C for speed
13:41:43 <doomlord__> only ASM can do that i think
13:41:47 <Cale> doomlord__: It's important to realise in discussions like this that languages don't have speeds.
13:42:09 <Cale> doomlord__: Language implementations produce better or worse machine code for given source inputs.
13:42:18 <doomlord__> sure
13:42:29 <doomlord__> but the langauge paradigm dictates the limits
13:42:34 <Cale> doomlord__: and often it's not easy to compare, because you can't even give the same source to two compilers for different languages.
13:42:51 <doomlord__> of course theres the idea that a higher level language gives the compiler more information to work with..
13:42:58 <Cale> yes
13:43:06 <acube> doomlord__: Expression templates can help the compiler to do better optimizations for math-heavy programs as far as I understand.
13:43:08 <doomlord__> .. but in C you do the optimizations manually. the expense is programmer time
13:43:12 <Cale> But it's also more work for the compiler to generate code.
13:43:23 <acube> There is a wikipedia site: http://en.wikipedia.org/wiki/Expression_templates
13:43:28 <Cale> You can do the optimisations manually in C++ and Haskell as well.
13:43:39 <doomlord__> i think of C++ as a macro system for C really
13:44:28 <Cale> You could think of everything as a macro system for <insert platform-specific assembly language here>
13:45:22 <doomlord__> i think C's status is well earned, the amount of low level techniques you can control, whilst still being fairly portable
13:45:34 <doomlord__> i wouldn't expect haskell & c to compete
13:45:41 <Cale> The job of a compiler is just to translate one language into another, after all. The more time people have put into making it do a good job of this, the faster the code will run in the end.
13:45:41 <doomlord__> different goals really
13:47:17 <Cale> C is at a very awkward position at this point IMO
13:47:32 <doomlord__> i would like to see C live on even if C++ dies
13:47:44 <Cale> It's too high level for most of the low-level uses you might want to use it for -- LLVM beats it in many cases there.
13:47:52 <Cale> and too low level for everyday stuff
13:48:05 <tromp> the IOCCC must live on
13:48:18 <doomlord__> C is way more useable than LLVM source ...
13:48:31 <Cale> I mean, in cases where you're generating source.
13:48:41 <doomlord__> and C provides a nice interface between languages. C FFI
13:48:44 <Cale> Generating C can be quite awkward for a number of reasons.
13:49:23 <Cale> That's true, the FFI aspect of it is perhaps a main point where it still has kind of a monopoly.
13:49:39 <doomlord__> rust is my favourite language at the minute but its alpha :)
13:49:50 <doomlord__> and i'm still not sure i want it to replace C
13:50:32 <doomlord__> i still want a language at C's level in the world; something portable, capable of writing programs, but without committing to a specific OOP system (like C++ or ObjC do ) or whatever.
13:51:07 <doomlord__> "^capable of writing programs" i know that sounds vague. but you can read & write programs in C much more easily than in LLVM source :)
13:51:23 <Cale> Well, that's the sort of thing people were excited about Go for. But I think Go is really really boring.
13:51:25 <doomlord__> i hope rust catches on
13:51:40 <doomlord__> Go can't replace C because it uses GC
13:51:44 <Cale> lol
13:51:49 <scooty-puff> i hope that this is a very simple question, but does readIntArray# read bytes located at the given argument index to 8 bytes greater for most x86_64 systems?
13:52:08 <doomlord__> as someone else here has pointed out - C is used in contexts where you dont even have dynamic alloctaion, let alone GC
13:52:14 <scooty-puff> (and does writeIntArray# write at the index to 8 bytes, etc.?)
13:53:02 <scooty-puff> i'm having some real trouble with a segmentation fault - i allocate a newByteArray# of 40 bytes, then use readIntArray#/writeIntArray# at 0, 8, 16, and 32
13:53:04 <doomlord__> over on the Go channel - when i was looking into it - i was told, "if you're l ooking for a C++ replacement... you will be dissapointed". Rust however has the smartpointers of C++ with unique ownership, so you can write code without any sort of GC overhead
13:53:18 <Cale> doomlord__: I think in most cases where I was programming something that low-level, like for microcontrollers, I'd probably end up using Haskell as some sort of metalanguage to generate low-level microcontroller code, a la Atom or something.
13:53:41 <doomlord__> i would be interested to see if you could translate haskell into C to reason about what its doing
13:53:45 <scooty-puff> at during one of these reads or writes (i believe - this is stepping through with ghci - though i have trouble using the debugger with ghci)
13:53:55 <Cale> doomlord__: In the past (almost a decade ago now...), I've worked on a compiler for a special purpose language for signal processing applications in Haskell.
13:53:57 <doomlord__> when doing low level work in C, some people analyze the asm output.
13:54:00 <scooty-puff> *using the debugger with unboxed types
13:54:38 <doomlord__> whats interesting is the same algorithm could have many implementations r.e. memory use.
13:54:47 <scooty-puff> i can post the core output (the actual code is much more high level and would prob mask the problem)
13:54:54 <doomlord__> so could you take your haskell program and ask it to ,say, compile a size or speed optimized version...
13:55:30 <Cale> doomlord__: and my part of that was compiling very efficient PPC/Altivec SIMD loops which made effective use of the CPU units, and in doing that, I realised that writing efficient low-level code by hand is much much harder for people than it is for machines now.
13:56:06 <doomlord__> the one thing about that is data layout is very important, i think thats hard to automate
13:56:17 <Cale> doomlord__: In the old days, it was easy to tell how long it would take to run a program written in assembly, because each instruction would take a certain specific number of cycles and there was no overlap between them.
13:56:21 <doomlord__> and yes, its a pain in C
13:56:41 <doomlord__> this is what i'm talkijng about with "analyze the asm output.."
13:57:03 <Cale> But now the CPUs will run certain instructions which are next to each other and operate on independent registers in parallel.
13:57:11 <doomlord__> doing PPC/SIMD code on consoles, it was commoin to reason about the pipeline, which basically means using C/intrinsics as a macro languaeg for ASM, and reasoning in ASM
13:57:37 <meh`> hello, I'm very new to Haskell and I'm getting a weird linking error (http://sprunge.us/SWSA), the code is here (https://github.com/meh/crepuscolo) and lol.hs is here (http://sprunge.us/dKOg), what am I doing wrong?
13:57:43 <doomlord__> from the tricks done there, i would have been very skeptical especially r.e. data-layout that any high level language existed capable of it
13:58:02 <doomlord__> but that is what got me interested in FP :)
13:58:19 <Cale> But yeah, this sort of thing matters in cases where either your program is running many many times per second, or will be run once over the course of a month (and so you can spend lots of time compiling it)
13:58:28 <doomlord__> i could certainly see that 'map' etc is a nice way to think about programs, from paralleizing (for SIMD, for ILP, for threading)
13:58:44 <orzo> when i declare an algebraic data type, i may use ! on argument positions to cause the constructor to be strict in those arguments.  Is there analog to that when i declare my cunstructors using GADT syntax?
13:59:01 <tomejaguar> Has anyone written a comparison of Haskell commandline processing APIs?  So far I know of optparse-applicative, cmdtheline and cmdargs.
13:59:18 <doomlord__> sony's Cell processor would have needed a radically different language to get the most out of it. the language never appeared, and they ditched it :)
13:59:22 <Cale> meh`: Check that this crepuscolo package is installed properly
13:59:28 <Cale> meh`: ghc-pkg check
13:59:30 <doomlord__> (to get the most out  of it practically)
13:59:36 <Cale> meh`: and  ghc-pkg list crepuscolo
13:59:56 <Cale> doomlord__: Right, our project *really* liked the look of the Cell
14:00:02 <glguy_> orzo: You still put !s on types to make them strict in GADT syntax
14:00:05 <glguy_> http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt
14:00:09 <Cale> (though I left before the Cell was even commercially available)
14:00:21 <doomlord__> i think that sort of research is still very relevant to GPGPU
14:00:26 <conal> what are some favorite techniques for having multiple ghc versions and switching between them?
14:00:28 <Cale> doomlord__: Managing the caches manually would have been really great for us :)
14:00:37 <meh`> Cale, http://sprunge.us/NfRA
14:01:12 <doomlord__> I've never liked GC, but one thing that  intruiged me was that the cell could relocate data while traversing it for free, because everything was DMA.. so some sort of compacting GC might have been ok.
14:01:13 <orzo> glguy_: oh thanks
14:01:23 <Cale> meh`: hmm...
14:01:35 <doomlord__> but no such practical language existed to my knowledge
14:01:45 <Cale> meh`: Try putting lol.hs in a different directory
14:01:59 <Cale> meh`: I think it might be confused because you're building out of the crepuscolo package directory?
14:02:01 <meh`> Cale, same
14:02:08 <meh`> it was happening in ghci too
14:02:39 <Cale> doomlord__: I think in practice, GC doesn't seem like such a big deal these days, and even does a much better job than humans *usually* do by hand.
14:03:04 <doomlord__> i know for most programming work its ok... but somewhere there is key work thats better with manual memory
14:03:27 <Cale> doomlord__: But for cases where you really need to control when GC happens, there are usually workarounds which can be done while keeping most of your code GCed.
14:03:52 <doomlord__> rust is the first language with GC i might actually use... because you can explicitely avoid it with ~
14:04:15 <Cale> doomlord__: For instance, I worked for a while at a startup where we were writing an action roleplaying game in Haskell for iPhones.
14:04:44 <doomlord__> game *scripting* or game *engine* :)
14:05:17 <doomlord__> game scripting is done in all sorts... eg lua. but with underlying C/C++ engine. unity "uses C#" ... but the underlying engine is C++
14:05:20 <sm> conal: just install them all and invoke all but the most recent as ghc-X.Y (and cabal -w ghc-X.Y)
14:05:27 <Cale> engine in Haskell, *possibly* with some tiny bit of code for throwing bits on the screen in C++
14:05:49 <Cale> doomlord__: That C++ code was looking less and less necessary by the time we were running out of funds though.
14:05:50 <doomlord__> eventually you need to reason about vertex buffers :)
14:06:13 <conal> sm: thanks.
14:06:33 <dmwit> conal: sm's method is my favorite, too. I know of at least one person who uses stow (byorgey).
14:06:51 <conal> dmwit: ah -- stow. that's what i was trying to remember. thanks.
14:06:53 <Cale> doomlord__: We had a Haskell version of all the OpenGL stuff as well, which actually worked about as well as the C++ code did. We were initially worried because the older iPhones could spend upwards of 300ms on a major GC (every 5 minutes or so)
14:06:56 <doomlord__> i dealt with a streaming system on consoles. custom memory management, drive DMA, multiple decompression worker threads , and GPU acessing resources. thats the sort of thing where i can't see C/C+= being beat.
14:07:03 <Cale> doomlord__: But things are getting better and better
14:07:12 <Cale> On a desktop machine, we wouldn't even worry about it.
14:07:32 <Cale> btw, do you know about Accelerate?
14:07:36 <shachaf> It seems that this offtopic discussion has gotten long enough that it's drowning out actualy Haskell questions.
14:07:50 <byorgey> sm's method is certainly simplest, but I find it annoying to have to remember to pass -w arguments all the time
14:07:54 <Cale> shachaf: This is at least partly about Haskell :)
14:08:03 <shachaf> Cale: OK. Then maybe it should go to #haskell-overflow.
14:08:06 <mm_freak> Cale: "worked"?  past tense?
14:08:09 <sm> bah shachaf
14:08:19 <Cale> mm_freak: I'm working for the same guy at a different company now :)
14:08:26 <mm_freak> i see =)
14:08:51 <Cale> (Working on a new backend for skedge.me in Haskell)
14:09:05 <dontdoMDMA> anyone here good with writing thesises? i have written most of my Method part explaining how i test(TDD/unittesting, memory leak testing, etc). But where do i describe my implementation(with flowcharts etc)? In Method or Results?
14:09:09 <Cale> doomlord__: http://hackage.haskell.org/package/accelerate
14:09:11 <byorgey> conal: you can read about how I use stow on my blog: http://byorgey.wordpress.com/2012/11/01/using-multiple-versions-of-ghc-in-parallel-with-gnu-stow/
14:09:24 <conal> byorgey: sweet. thx. :)
14:09:32 <Cale> doomlord__: see also http://hackage.haskell.org/package/atom
14:09:46 <byorgey> conal: there are also some other options described in the comments on that post
14:09:57 <conal> wonderful
14:09:58 <Cale> (very different sort of applications are targeted by those, but the common theme is using Haskell as a metalanguage for writing low-level code)
14:10:38 <mm_freak> ok, we have a conal and an elliott hereâ€¦  is there an actual conal elliott here? =)
14:10:48 <Cale> That would be conal.
14:11:03 <mm_freak> ok =)
14:12:31 <elliott> I am half of Conal Elliott. conal is the other half. don't tell anyone, it's a secret.
14:12:40 <quchen> Elliott is Conal Elliott? Oh.
14:12:50 <elliott> no, conal is :P
14:12:54 <quchen> That explains why he knows.
14:12:59 <shachaf> elliott is the operational half
14:13:02 <quchen> Things. He knows *things*.
14:13:33 <quchen> Conal is the guy maintaining the blog, Elliott is the IRC bot? :-)
14:13:43 <Cale> doomlord__: On the front of using GPU hardware more effectively for its intended purpose, I hope to see lots more development in the direction of http://hackage.haskell.org/package/GPipe-1.4.1
14:13:57 <aristid> elliott: quote conal
14:14:05 <doomlord__> Cale, ok interesting. i'm a C/C++ person ultimately but i like the idea of writing pure algorithms and compiling it.. just like C/C++ are used as an assist for writing asm, even if you're thinking about the asm
14:14:19 <elliott> aristid: hey now, you have to pay me.
14:14:27 <elliott> I don't go around bottin' for just anyone.
14:14:34 <aristid> elliott: BOO irc bots are supposed to be free as in love
14:15:18 <monochrom> freedom is slavery
14:15:28 <shachaf> @@ (@quote conal). quonal.
14:15:28 <lambdabot>  conal says: so i'm wondering if the claim of referential transparency is pure make-believe.. quonal.
14:16:13 <Cale> doomlord__: The idea is that Haskell makes a really good language in which to write special purpose compilers for various purposes, which can be exposed as libraries. You write your code in a language embedded in Haskell, and various bits of the library compiles that code to whatever target you have in mind, either at what you'd normally think of as runtime, or prior to that, generating some static output which you can
14:16:13 <Cale>  use in your real program.
14:16:43 <nejucomo> (Upgrading to 7.6.3 fixed the strange type mismatches in tuples in template haskell.  Thanks for the help, folks!)
14:16:51 <Cale> nejucomo: great!
14:17:37 <mm_freak> let me also state that i've used accelerate with CUDA and it works very well
14:17:49 <Cale> mm_freak: Oh cool!
14:17:52 <Cale> What did you compute?
14:18:20 <mm_freak> nothing much, just a bunch of matrix stuff
14:18:32 <mm_freak> but you need to get the repository versions of accelerate/accelerate-cuda
14:18:37 <mm_freak> the hackage versions seem quite outdated
14:18:46 <mm_freak> they didn't even compile for me
14:19:03 <nejucomo> So the "splicing" site in template haskell is always where $( â€¦ ) is found textually, correct?  It's not possible to have an expansion site without LANGUAGE TemplateHaskell ?
14:19:06 <Cale> huh, that's interesting. They compiled on 7.6 for hackage.
14:19:16 <Cale> (haven't tried locally)
14:19:20 <hvr> http://i.imgur.com/2ircJH5.png I'm just gonna leave this here
14:19:31 <Cale> oh, the cuda one didn't though
14:19:58 <Cale> (because cuda didn't)
14:21:46 <Cale> hvr: One could also make the joke that they did, and someone used unsafePerformIO and that's what caused the catastrophe.
14:21:48 <scooty-puff> naming bindings of unboxed kind with a trailing # is just a convention, right?
14:22:00 <scooty-puff> (no affect on how the compiler may treat them)
14:22:03 <Cale> hvr: You're not hvr from Path of Exile, are you?
14:22:12 <hvr> Cale: I'm not :)
14:22:43 <hvr> (I even had to google that)
14:22:56 <Cale> Dude just got world first level 100 :)
14:24:17 <hvr> I'm actually more interested in gaining level 100 at Haskell :)
14:24:23 <Cale> :)
14:24:56 <Cale> scooty-puff: Yeah, for the most part
14:25:15 <Cale> scooty-puff: Names like that require an extension to use
14:25:22 <Cale> scooty-puff: (MagicHash)
14:25:48 <Cale> scooty-puff: and the syntax of unboxed tuples also uses # and the kind # is also built in.
14:29:34 <merijn> hvr: The problem with becoming level 100 at haskell is that you need to try to write something really hard before your skill thunk gets forced :D
14:30:50 <Guest318> does the module System not exist under ghc ?
14:30:53 <Eduard_Munteanu> It's also useful to reset a few stats and skills such as "imperative looping" and redistribute points.
14:32:00 <geekosaur> Andrea__, sounds like old code. there is no simple System module any more, it's been subdivided. you can maybe switch on haskell98 mode, or find out what new module(s) you need
14:32:57 <Andrea__> first i need only System.system "clear"
14:33:18 <monochrom> that's System.Process
14:33:21 <acube> ?index clear
14:33:21 <lambdabot> Graphics.Rendering.OpenGL.GL.Framebuffer, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT, Text.Html
14:33:28 <acube> ?index system
14:33:28 <lambdabot> System.Cmd
14:33:46 * hackagebot Hach 0.1.1 - Simple chat  http://hackage.haskell.org/package/Hach-0.1.1 (DmitryMalikov)
14:33:52 <monochrom> oh, Cmd, darn, sorry
14:34:25 * ski . o O ( <http://www.haskell.org/ghc/docs/latest/html/libraries/haskell98-2.0.0.2/System.html> )
14:34:39 <acube> Seems like it's both in System.Process and System.Cmd
14:34:41 <monochrom> err, both have it
14:34:45 <monochrom> good good
14:35:52 <BackwardSpy> Hey guys, I started learning Haskell today, and I'm a little bit stuck about typeclasses. I see that it is good practice to put a type declaration on my functions. If I have a function that takes a number that is comparable, is it (Ord a), (Num a), both? I'm not sure how this works.
14:36:30 <BackwardSpy> If I just use one or the other, I get an error about not being able to deduce (Ord a) from my use of '>', and vice-versa.
14:36:33 <Andrea__> i cannot install this module , cabal dosn't find System
14:36:43 <BackwardSpy> Which makes sense, but is there another type class that handles this, or should I define both?
14:37:01 <geekosaur> Andrea__, you'll need to edit the cabal file
14:37:14 <acube> BackwardSpy: When you only need (>), then you should only put Ord on
14:37:22 <geekosaur> also send a note to the package maintainer that they should either mark it as haskell98 or upgrade it to haskell2010
14:37:37 <elliott> BackwardSpy: (Num a, Ord a) is fine. it does what it says on the tin :)
14:37:48 <geekosaur> (you may also take this as a warning that the package you're trying to install is rather old)
14:37:50 <Andrea__> geekosaur, thx, oh its' difficult , i think
14:38:24 <dontdoMDMA> anyone here good with writing thesises? i have written most of my Method part explaining how i test(TDD/unittesting, memory leak testing, etc). But where do i describe my implementation(with flowcharts etc)? In Method or Results?
14:38:27 <BackwardSpy> Okay. In the function in question, I am multiplying the value as well so if I omit Num then it will complain about that. I just wasn't sure if there was perhaps a typeclass that just covers a numeric type that can be compared, among other things
14:38:48 <BackwardSpy> If (Num a, Ord a) is the way to do it, then that is how I shall do it. :D
14:40:22 <dmwit> dontdoMDMA: This may sound a bit stupid, but... why not have an "Implementation" part?
14:41:17 <dmwit> Problem: neither "Method" nor "Results" covers this information that really should be in my report. Solution: neither "Method" nor "Results" is the heading for this information in the report. =)
14:46:44 <scooty-puff> Cale: k - thanks
14:46:47 <hnsz> I want to have a datatype XP with several constructors NP, VP, DP; and a few more. They all look like this (DP XP String XP)  is there a way I can define the pattern once for all ?
14:48:06 <elliott> hnsz: you can do: data XP = XP Tag XP String XP; data Tag = NP | VP | DP
14:48:16 <elliott> or data Q = Q XP String XP; data XP = NP Q | VP Q | DP Q
14:48:20 <hnsz> elliott: Ah fair enough
14:48:24 <elliott> (pick a better name than Q :))
14:48:31 <hnsz> thanks :)
14:48:52 <hnsz> I shall call it POS for part of speech :D
14:53:07 <Cale> augur seems like he ought to be able to chime in on something like that :)
14:53:19 <Cale> (if he's around)
14:54:32 <merijn> dontdoMDMA: Method sounds like part of a Chemistry/Biology thesis, usually for CS stuff it tends to go "intro, background, implementation, performance/benchmarks/measurements, analysis (optional?), conclusion"
14:56:17 <petantik> dontdoMDMA: perhaps you mean methodolody?
14:59:24 <Shamar> hi any Debianist can suggest me the better way to start developing in Haskell with debian? I'm using wheezy, but I'd like to install the latest cabal packages from hackage
15:00:18 <Shamar> should I use Debian's cabal package or compiling from scratch a development environment in opt is a better way?
15:03:04 <Andrea__> Shamar, I installed the debian packages under ubuntu , i 'm new to haskell
15:03:51 <merijn> Shamar: The best option is to install Haskell Platform for your distro
15:04:11 <merijn> Shamar: The comes with most of the important libraries and is tested whether they play together nicely
15:04:42 <elliott> you can install haskell-platform from debian
15:04:49 <elliott> but then don't install any more debian haskell packages, use cabal install for the rest.
15:05:35 <Andrea__> under windows the System.system works with hugs but under ubuntu ghc doesn't find System.system. Cabal doesn't know this module
15:07:33 <augur> Cale: hey hi sup
15:11:35 <Shamar> thanks... let's give a look to haskel-install
15:11:39 <geekosaur> Andrea__, I take it you ignored what I told you before?
15:11:47 <geekosaur> you are working with an ancient package
15:11:48 <Shamar> haskell platform
15:12:03 <geekosaur> hugs will work with it because hugs also is ancient
15:12:20 <Andrea__> geekosaur, i din't understan what i should edit
15:12:23 <geekosaur> (and long unmaintained, as it seems this package you want is also long unmaintained)
15:12:35 <geekosaur> cabal unpack thepackage
15:12:52 <geekosaur> you will get a directory with the package contents, including a packagename.cabal file
15:13:08 <geekosaur> although, no, that's not what you want to change, you need to change the source
15:13:21 <geekosaur> unless you want to alter the cabal file to force haskell98 mode
15:13:27 <ixmatus> I need help with writing my own instances for a color based data-type; I can't quite figure out the error - I'm hpasting the code and error
15:13:38 <ixmatus> http://hpaste.org/88265
15:14:41 * Shamar complains about Hugs being the only Haskell compiler for Plan9...
15:14:49 <Andrea__> geekosaur, i didn't understat what i must do
15:14:53 <Andrea__> understand
15:14:55 <Shamar> interpreter...
15:15:11 <Andrea__> sorry i must go to bed
15:15:21 <Andrea__> thank , geekosaur
15:15:26 <Andrea__> bye
15:15:42 <geekosaur> I suggest what you really want to do is find a more up to date package
15:16:14 <ixmatus> any chance I can get help on my above issue? I think the solution is pretty silly/simple but I've been unable to wring it out over the last two hours
15:16:21 <Shamar> I give a read to the Control.Proxy.Tutorial... looks that the code you write becomes tightly coupled with the package... am I right?
15:17:00 <Shamar> or actually I can write pure functional code and plug it into pipes?
15:17:17 <Doug201> Shamar: You can write pure functional code using pipes.
15:18:11 <Shamar> Doug201, pure ok, but how much I can keep it decoupled from pipes them selves?
15:18:56 <Eduard_Munteanu> ixmatus: what's the type of toXYZ / toLAB?
15:19:04 <Shamar> I mean: I can design the code functionally, ignoring that it will run with pipes and then plug them into pipes?
15:19:12 <Doug201> Shamar: I can't say, it depends on how you use the pipes.
15:19:20 <ixmatus> Eduard_Munteanu toLAB :: CIE Double -> CIE Double
15:19:26 <ixmatus> Eduard_Munteanu toXYZ :: CIE Double -> CIE Double
15:19:41 <Doug201> Shamar: Again, perhaps. It depends on how you structure your code and what you are using the pipes for.
15:19:49 <madjestic> any qtHaskell users here?
15:19:53 <Eduard_Munteanu> ixmatus: well, then you can't apply them to arbitrary 'CIE a's
15:20:15 <Shamar> Doug201, any good sample to suggest?
15:20:35 <ixmatus> hmmm, I built an instance for my RGB type which is similar - it just doesn't have the XYZ | LAB branch
15:20:46 <ixmatus> what am I missing?
15:21:02 <Doug201> Shamar: I don't have any good ones to suggest now. (I'm working on writing a good example, but it probably won't be ready for a few weeks.)
15:21:02 <dmwit> ixmatus: You are missing that you can't convert between the two branches for arbitrary types.
15:21:08 <ixmatus> ahh
15:21:18 <ixmatus> so I would have to have separate types for them
15:21:21 <dmwit> ixmatus: (...but need to be able to do that to implement Applicative in this way.)
15:21:21 <Doug201> Shamar: You can always ask the author, he's very helpful.
15:21:26 <dmwit> ixmatus: yes
15:21:28 <dontdoMDMA> jag ahr typ 10 rader diskussion
15:21:29 <dmwit> ixmatus: See also:
15:21:31 <dmwit> ?hackage colour
15:21:31 <lambdabot> http://hackage.haskell.org/package/colour
15:22:01 <ixmatus> yes I used that lib for some help on my types, guess I should be looking deeper :)
15:22:05 <Eduard_Munteanu> dontdoMDMA: English?
15:22:07 <ixmatus> thank you dmwit and Eduard_Munteanu
15:23:29 <ski> ixmatus : minor point, you could say `XYZ f1 f2 f3 <*> XYZ x y z = XYZ (f1 x) (f2 y) (f3 z)' instead of `(XYZ f1 f2 f3) <*> (XYZ x y z) = (XYZ (f1 x) (f2 y) (f3 z))'
15:24:02 <ski> Eduard_Munteanu : "i ahve like 10 rows of discussion"
15:24:21 <ski> (hm, s/rows/lines/)
15:24:26 <ixmatus> yeah I know I had lots of redunant brackets - I was trying to keep it all ordered right since there were so many pattern expansions going on
15:24:29 <ixmatus> thanks :)
15:25:42 <ski> ixmatus : anyway .. i'm not clear on what you want to do here
15:26:16 <ixmatus> ski my question has been answered, thank you though :)
15:26:36 <ixmatus> what it's doing is converting between CIE XYZ tristimulus and CIE L*a*b* color representations
15:26:55 <ixmatus> I wanted Applicative instances for it since it makes doing calculations on the color values MUCH cleaner
15:27:09 <ixmatus> then pattern expanding all of them and manually applying the same function over all three then rebuilding it
15:28:23 <ixmatus> dmwit redoing the types actually seems to make the API cleaner too
15:28:40 <ixmatus> before that with the function defs I had to have a pattern that matched the other branch too which felt very "Erlang"
15:28:43 <satshabad> I am trying to understand this function composition: (take . (+ 1)) . So say that take is f(x, y) and (+1) is g(x). Then the resulting function is f(g(x), y)? Does that mean all functions to the right of a . must only take 1 argument, and the one to the left can take a few? Or is it f(g(x)) which is a partial waiting for another argument?
15:29:30 <Eduard_Munteanu> satshabad: it's easier if you look at curried functions
15:29:33 <Eduard_Munteanu> :t take
15:29:35 <lambdabot> Int -> [a] -> [a]
15:29:40 <Eduard_Munteanu> :t (+1)
15:29:42 <lambdabot> Num a => a -> a
15:30:10 <Eduard_Munteanu> take :: Int -> [a] -> [a]
15:30:16 <Botje> take . (+ 1) = \x -> take (x + 1) = \x y -> take (x + 1) y
15:30:17 <Eduard_Munteanu> take :: Int -> ([a] -> [a])
15:30:17 <quchen> satshabad: If you have trouble understanding pointfree functions, add the argument! (take . (+1)) x = take ((+1) x) = take (x+1)
15:30:28 <Eduard_Munteanu> Now each of those takes exactly one argument.
15:30:52 <ski> satshabad : `f . g' is `\x -> f (g x)', so `take . (+ 1)' is `\n -> take ((+1) n)' which is `\n -> take (n + 1)', which by eta-expansion is the same as `\n as -> take (n + 1) as'
15:31:31 <ski> (eta-expansion meaning that `f' (above `take (n + 1)') is equal to `\x -> f x')
15:31:45 <Doug201> @run (take . (+1)) 1 [1..1-]
15:31:47 <lambdabot>   <hint>:1:23: parse error on input `]'
15:31:52 <Doug201> @run (take . (+1)) 1 [1..10]
15:31:54 <lambdabot>   [1,2]
15:32:07 <satshabad> OK, haha let me think about a bit more
15:32:16 <satshabad> I think I'm getting it
15:32:26 <merijn> > f . g $ a b
15:32:27 <lambdabot>   The function `Debug.SimpleReflect.Vars.a'
15:32:27 <lambdabot>  is applied to one argument,
15:32:28 <lambdabot>  but...
15:32:39 <acube> > f . g $ a
15:32:40 <lambdabot>   Ambiguous type variable `b0' in the constraints:
15:32:40 <lambdabot>    (GHC.Show.Show b0)
15:32:40 <lambdabot>     ...
15:32:48 <merijn> > (f . g $ a) b :: Expr
15:32:49 <lambdabot>   Ambiguous type variable `b0' in the constraints:
15:32:50 <lambdabot>    (GHC.Show.Show b0)
15:32:50 <lambdabot>     ...
15:32:53 <merijn> bah
15:33:02 <ski> satshabad : another angle which might be helpful : `f (g x y)' is `f ((g x) y)' is `(f . g x) y'
15:33:12 <quchen> merijn: I think SimpleReflect has a special type for functions
15:35:00 <thorsten`> > take ((+1) 1 [1..10])
15:35:08 <lambdabot>   can't find file: L.hs
15:35:30 <thorsten`> @run (take ((+1) 1 [1..10]))
15:35:34 <lambdabot>   *Exception: show: No overloading for function
15:35:57 <ski> @type take ((+1) 1 [1..10])
15:36:02 <lambdabot> [a] -> [a]
15:36:15 <ski> @type take ((+1) 1) [1..10]
15:36:17 <lambdabot> (Enum a, Num a) => [a]
15:36:20 <ixmatus> I know what Instance orphans are
15:36:23 <ski> > take ((+1) 1) [1..10]
15:36:24 <lambdabot>   [1,2]
15:36:30 <ixmatus> but is it considered *bad practice* to have them?
15:36:37 <elliott> yes
15:36:43 <quchen> Wait, how does that typecheck - @type take ((+1) 1 [1..10])
15:36:47 <ixmatus> okay
15:36:53 <quchen> It's applying "2" to a list, isn't it?
15:37:02 <ski> quchen : `instance Num n => Num (rho -> n)'
15:37:02 <elliott> :t 2 []
15:37:03 <lambdabot> Num t => t
15:37:29 <quchen> Huh? When did this happen :s
15:37:41 <elliott> since NumInstances
15:37:45 <hpc> omg! it's back!
15:37:47 <hpc> > 0xford
15:37:49 <lambdabot>   15
15:37:51 <hpc> :D :D :D
15:37:52 <quchen> Ah.
15:38:47 * hackagebot traverse-with-class 0.1.1 - Generic applicative traversals  http://hackage.haskell.org/package/traverse-with-class-0.1.1 (RomanCheplyaka)
15:39:13 <quchen> That's odd, the package looks like an implementation of this funny StackOverflow post where they, well, define Num for functions and then calculate "2 3 4".
15:39:44 <hpc> > 2 `3` 4
15:39:46 <lambdabot>   <hint>:1:4: parse error on input `3'
15:39:51 <hpc> nooooooo!
15:39:57 <acube> > 3 2 4
15:39:59 <lambdabot>   3
15:40:06 <quchen> This is madness.
15:40:27 <acube> > (+3) + subtract 4 $ 7
15:40:29 <lambdabot>   13
15:40:30 <satshabad> OK pretty sure I know what is going on with that . Now for the second part. What is the (last .) part of this expression? (last .) . take . (+ 1)
15:40:37 <scriptor> > take ((+1) 1 [1..10])
15:40:40 <lambdabot>   *Exception: show: No overloading for function
15:40:46 <hpc> :t (last .)
15:40:49 <lambdabot> (a -> [c]) -> a -> c
15:40:56 <acube> <  take ((+1) 1 [1..10])
15:41:01 <goodfellow>   mueval-core: Time limit exceeded
15:41:03 <satshabad> ah, that's useful
15:41:11 <satshabad> :t last
15:41:11 <Fuuzetsu> > 1 2 3
15:41:12 <lambdabot> [a] -> a
15:41:13 <lambdabot>   1
15:41:15 <Fuuzetsu> why
15:41:19 <Fuuzetsu> @src 1
15:41:20 <lambdabot> Source not found.
15:41:22 <Fuuzetsu> :t 1
15:41:24 <lambdabot> Num a => a
15:41:25 <ixmatus> elliott would it be considered okay to have orphan instances in my test case code where I define instances for "Arbitrary" ?
15:41:28 <hpc> Fuuzetsu: because we can :D
15:41:31 <quchen> satshabad: That part is crossing the line in pointfree style. ;-)
15:41:32 <Fuuzetsu> but WHY
15:41:36 <Fuuzetsu> you're evil
15:41:37 <ski> > map (cos ^ 2 + sin ^ 2) [0,pi/4,pi/3,pi/2]
15:41:39 <lambdabot>   [1.0,1.0,1.0,1.0]
15:41:47 <hpc> it's for dealing with vectors
15:41:50 <Fuuzetsu> That's going to really confuse someone when they try out some code
15:41:54 <satshabad> crossing the line? Like it's gone too far?
15:42:14 <quchen> satshabad: Yes.
15:42:17 <quchen> @unpl (last .) . take . (+ 1)
15:42:17 <lambdabot> (\ e k -> last (take (e + 1) k))
15:42:24 <quchen> Which one is easier to read?
15:42:30 <satshabad> haha well it's takin from this
15:42:30 <satshabad> http://www.haskell.org/haskellwiki/99_questions/Solutions/3
15:42:45 <conal> byorgey: do you use stow with haskell platform installations, and if so, how?
15:43:06 <Shamar> guys what's the best place for a module's unit tests? Leksah create a testMain in the Main module, but I can't figure how to call tests from other modules without exporting them
15:43:13 <ski> satshabad :  f (g a b)  =  (f . g a) b  =  (f .) (g a) b  =  ((f .) g) a b
15:43:34 <ski> satshabad : er, the last step should be :  ((f .) . g) a b
15:43:39 <Shamar> and btw, do you write unit tests with Haskell? And do you use Leksah? :-)
15:43:54 <acube> @quickcheck 3 + 3 == 6
15:43:54 <lambdabot> Unknown command, try @list
15:43:55 <Fuuzetsu> @hoogle CoAxiom
15:43:55 <lambdabot> No results found
15:44:02 <quchen> satshabad: Whenever you see something like (foo .), it's a pretty safe bet there's too much pointfree-ness in there.
15:44:02 <acube> @check 3 + 3 == 6
15:44:04 <lambdabot>   Not in scope: `myquickcheck'
15:44:14 <acube> @ty quickcheck
15:44:15 <lambdabot> Not in scope: `quickcheck'
15:44:16 <pygmalion> Is there a version of the (,) operator for triples as opposed to tuples?
15:44:23 <quchen> pygmalion: (,,)
15:44:24 <acube> pygmalion: (,,)
15:44:24 <hpc> :t (,,)
15:44:25 <lambdabot> a -> b -> c -> (a, b, c)
15:44:40 <ski> (.. as opposed to pairs)
15:44:41 <pygmalion> acube, hpc: makes too much sense, thanks!
15:44:42 <hpc> :t (,,,,,,,,,,,,,,,,,,,,) -- it gets rather ridiculous
15:44:44 <lambdabot> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u)
15:44:55 <quchen> hpc: Look at the source of GHC.Tuple for ridiculous :-D
15:44:56 <scriptor> hmm, that solution kind of makes sense once you know what ti's supposed to do
15:45:08 <hpc> quchen: i have
15:45:10 <acube> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
15:45:12 <lambdabot> (Functor f3, Functor f2, Functor f1, Functor f) => f (f1 (f2 (a -> b))) -> f (f1 (f2 (f3 a -> f3 b)))
15:45:19 <scriptor> take the last element after a take with an offset of 1
15:46:10 <scriptor> why couldn't you just do last $ take . (+ 1) ?
15:46:34 <acube> :t fmap (fmap last) $ take . (+1)
15:46:35 <lambdabot> Int -> [b] -> b
15:48:01 <satshabad> so (last .) is a function that takes a function g and an argument a and then applies g to a and then takes the last element of the result?
15:48:37 <acube> satshabad: yes
15:48:45 <acube> @unpl (last .)
15:48:45 <lambdabot> (\ a d -> last (a d))
15:48:48 * hackagebot prizm 0.1.0.3 - A haskell library for computing with colors  http://hackage.haskell.org/package/prizm-0.1.0.3 (ParnellSpringmeyer)
15:49:38 <Shamar> :t (last .)
15:49:40 <lambdabot> (a -> [c]) -> a -> c
15:49:58 <acube> @djinn (a -> [c]) -> a -> c
15:49:59 <lambdabot> Error: Undefined type []
15:50:46 <satshabad> :t ((f .) . g) a b
15:50:48 <lambdabot>     Ambiguous type variable `b0' in the constraints:
15:50:48 <lambdabot>       (Show b0) arising from a use of `f' at <interactive>:1:3
15:50:48 <lambdabot>       (FromExpr b0) arising from a use of `g' at <interactive>:1:10
15:51:42 <acube> @free (a -> [c]) -> a -> c
15:51:42 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:21-35
15:51:58 <satshabad> OK thanks guys!
15:52:06 <ski> yw
15:52:35 <matt____> test
15:52:41 <Shamar> :t fmap(fmap last)
15:52:43 <lambdabot> (Functor f1, Functor f) => f (f1 [b]) -> f (f1 b)
15:52:50 <ski> untest
15:53:53 <Shamar> btw, no one write unit tests in haskell? just proof? :-)
15:53:58 <matt____> Hi guys, I am trying to compile fay with shared object support, but I get the dreaded /usr/bin/ld: /home/sean/.cache/haskell/ghc-7.6.3-package-build-files/fay/build/Fay/Compiler/ModuleScope.dyn_o: relocation R_X86_64_PC32 against undefined symbol `fayzm0zi14zi5zi0_FayziCompilerziGADT_convertGADTzuconvertFunc_info' can not be used when making a shared object; recompile with -fPIC error
15:55:39 <ski> Shamar : <http://www.haskell.org/haskellwiki/Development_Libraries_and_Tools#Testing_Frameworks> perhaps ?
15:56:57 <Shamar> despite some broken links, I know that page... but I haven't see enough real world haskell samples using unit tests
15:58:01 <Shamar> for example here http://batterseapower.github.io/test-framework/
15:58:16 <Shamar> tests are in the main package
15:59:02 <Shamar> but I can't figure out how to test code inside a package
15:59:13 <Shamar> without exporting tests
15:59:25 <scooty-puff> i noticed with cpphs, you need to --hashes argument to get ## to work
15:59:39 <scooty-puff> however, it looks like cabal is use a different cpp
16:00:18 <scooty-puff> though now it complains that read ## Int is not valid haskell..
16:00:47 <scooty-puff> is there anything special required to get cabal to allow these?  it doesn't do anything (default arguments, etc.) to disallow them, right?
16:03:37 <merijn> Shamar: Have you looked at QuickCheck/HUnit?
16:03:48 * hackagebot network-bitcoin 1.2.2 - An interface to bitcoind.  http://hackage.haskell.org/package/network-bitcoin-1.2.2 (ClarkGaebel)
16:06:49 <Shamar> merijn, yes...
16:07:19 <Shamar> but I wasn't able to understand where to place testing code
16:08:01 <Shamar> I read some suggestions about using a dedicated module to test another module
16:08:19 <Shamar> but this limits tests to the "public" surface...
16:09:08 * Shamar thinks he missed something obvious...
16:11:22 <Shamar> http://hackage.haskell.org/packages/archive/HTF/latest/doc/html/Test-Framework-Tutorial.html
16:12:08 <Shamar> here I've found something useful in the section "Test definitions in multiple modules " but exporting tests look weird
16:12:21 <cmccann> " Couldn't match type `0 + 1' with `1' "
16:12:22 <cmccann> thanks GHC
16:12:24 <cmccann> you're a helper
16:12:58 <Eduard_Munteanu> cmccann: clearly you only know that 1 = 1 + 0
16:13:11 <otters> (1 = 1) + 0 doesn't typecheck
16:13:15 <otters> there's no Num instance for Bool
16:13:42 <cmccann> otters: these are types, not values
16:13:49 <otters> bah humbug
16:13:53 <cmccann> Eduard_Munteanu: tried that, 1 + 0 didn't work either
16:14:20 <cmccann> is there supposed to be an arithmetic solver that actually does anything yet? or is that still a future GHC thing.
16:14:22 * Eduard_Munteanu runs back in Agda's arms then :P
16:14:30 <elliott> cmccann: it's a future thing aiui
16:14:58 <cmccann> I thought there was a minimal one already
16:15:00 <cmccann> but if so
16:15:05 <cmccann> that's really god damn minimal
16:15:11 <cmccann> oh well
16:15:32 <Eduard_Munteanu> refl FTW
16:15:58 <elliott> cmccann: I read that as mineral.
16:16:11 <Eduard_Munteanu> Not enough minerals.
16:16:25 <cmccann> well it would also a mineral one, as in being dumb as a box of rocks.
16:16:40 <cmccann> you're probably right that it is a future thing.
16:16:44 <cmccann> stupid future hogging the nice toys.
16:17:01 <Demos> hey I am using hint to read in a config structure from a config file and I need to make the config type (Config as it happens) and instance of Typeable
16:17:06 <Demos> how do I go about that
16:17:33 <Demos> I know I need typeOf but I am confused about what the hell it is suppose to actually return
16:17:49 <cmccann> you use deriving (Typeable)
16:18:42 <c_wraith> Is the next version of GHC going to get rid of manual Typeable instances entirely? I know that's in the plans at some future point.
16:18:53 <cmccann> I think so.
16:19:03 <Demos> GHC says I need a language extension, I suppose that will no longer be true
16:19:18 <c_wraith> So enable the language extension.
16:19:29 <Demos> supposing I were to do it myself what would I do? just out of curiousity
16:19:39 <eikke> there will be a flag to derive Typeable for every datatype you define, without need for adding a deriving clause
16:20:49 <c_wraith> Demos: it's actually really ugly, for reasons you don't want to think about. That's why the ability to do it manually is being removed
16:21:11 <cmccann> also because doing it wrong makes bad things happen.
16:22:14 <Demos> OK fine, I will just let ghc deal with it
16:22:23 <cmccann> wise choice
16:23:33 <eikke> I'm somewhat concerned about the removal of Typeable2 etc
16:24:03 <eikke> will require quite some CPP for packages wanting to maintain compat with pre-7.8 GHCs
16:24:28 <Demos> err it says that the extension XDataDeriveTypeable is not supported by 7.6 ghc, how is my ghc so old
16:24:41 <cmccann> perhaps you misspelled it?
16:24:50 <c_wraith> swap Data and Derive
16:24:50 <shachaf> The extesion is called DataDeriveTypeable
16:24:55 <shachaf> Er.
16:24:57 <shachaf> Right.
16:25:03 <Demos> oh
16:25:03 <cmccann> shachaf: good work
16:25:07 <c_wraith> haha
16:25:07 <shachaf> Anyway there's no X.
16:25:09 <Demos> OK
16:25:16 <Demos> still 7.6 is a tad old is it not
16:25:21 <eikke> I thought it was DeriveDataTypeable
16:25:22 <c_wraith> no
16:25:29 <c_wraith> 7.6 is the current line
16:25:34 <c_wraith> 7.8 is due later this year
16:25:42 <c_wraith> (.odd versions are development versions)
16:26:27 <otters> ooh what'll be in 7.8
16:26:40 <c_wraith> Tons
16:26:41 <eikke> tons of goodies
16:26:56 <cmccann> a free pony for everyone
16:27:15 <c_wraith> What kind of pony? Does it have wings or horns?
16:27:16 <eikke> see eg http://hackage.haskell.org/trac/ghc/wiki/Status/May13
16:27:29 <cmccann> whatever kind you want I guess
16:28:05 <otters> 7.8 will have type holes?
16:28:06 <otters> neato
16:28:13 <otters> and overloaded lists, too
16:28:15 <c_wraith> @hackage pony
16:28:16 <lambdabot> http://hackage.haskell.org/package/pony
16:28:21 <eikke> :t pony :: (WithWings p, WithHorns p, PonyLike p) => p
16:28:23 <lambdabot> Not in scope: `pony'
16:28:23 <lambdabot>     Not in scope: type constructor or class `WithWings'
16:28:23 <lambdabot>     Not in scope: type constructor or class `WithHorns'
16:28:34 <otters> so a IsList instance of Set or Map
16:28:36 <otters> that sounds awesome
16:28:55 <eikke> otters: theres a page about that feature in trac somewhere with more examples
16:47:49 <Aetherspawn> :t use
16:47:52 <lambdabot> MonadState s m => Getting a s a -> m a
16:51:18 <Aetherspawn> What are the actual applications of a TChan?
16:51:48 <dmwit> < 2 `asAppliedTo` 3 4
16:51:52 <goodfellow>   mueval-core: Time limit exceeded
16:51:54 <dmwit> bah
16:52:23 <dmwit> < 2 `asAppliedTo` ()
16:52:27 <goodfellow>   [((),2)]
16:53:47 <c_wraith> Aetherspawn: Any time you need a concurrent queue and to either interact with other STM bits, or to avoid the deadlocks in Chan
16:54:15 <Aetherspawn> Hmm, so it's just a concurrent data structure interface?
16:54:25 <c_wraith> Well, yes
16:54:35 <c_wraith> That's what all the STM structures are
16:54:40 <Aetherspawn> OK :) thanks
16:56:05 <dmwit> It's a concurrent queue interface, but it's nicer than in some ways (namely, the ways STM is nicer than lock-based concurrency).
16:56:36 <dmwit> *it's nicer than Chan
16:56:56 <hpc> i like Chan
16:57:26 <dmwit> Namely: it's composable. For example, if you have thread A which can handle messages from channels X and Y, and thread B, which can handle messages from Y and Z... with Chan you're sort of hosed, but with STM it's easy.
16:58:03 * Aetherspawn finally understands what's going on in this server
17:03:51 <Aetherspawn> so, is there a "TChan" that requires all the members who read it to deplete the data put into it on their own
17:04:05 <Aetherspawn> ie: if Thread A pushes in numbers 1, 2, 3 and 4
17:04:30 <Aetherspawn> then threads B and C both now have 1..4 and must process it, rather than Thread B taking 1,3 and Thread C taking 2,4
17:15:39 <naz_> Hi, could anybody explain to me why ## not . elem 'x' "x" ## is not allowed but ## not $ elem 'x' "x" ## is ?
17:16:34 <sipa> he first is \x -> not (elem 'x' "x" x)
17:19:38 <naz_> Thank you, I guess I have to look at lambdas and point notation again :)
17:20:29 <Aetherspawn> TChain/dupTChain is so amazingly cool
17:20:54 <Aetherspawn> If I dupe a channel once, will it always recieve the input messages from the original from that point onwards?
17:24:43 <Fuuzetsu> :t fromJust
17:24:44 <lambdabot> Maybe a -> a
17:24:52 <Fuuzetsu> @src fromJust
17:24:52 <lambdabot> fromJust Nothing  = undefined
17:24:53 <lambdabot> fromJust (Just x) = x
17:25:22 <ski> please don't use `fromJust', apart from throwaway code, like interactive tests e.g.
17:25:57 <ski> @type fromMaybe (error "file `Foo.hs' : `Nothing' encountered")
17:25:58 <lambdabot> Maybe a -> a
17:26:18 <shachaf> > let Just x = lookup 'a' [] in x
17:26:19 <lambdabot>   *Exception: <interactive>:3:5-26: Irrefutable pattern failed for pattern Da...
17:28:48 <Aetherspawn> Does anyone know if Im using conduit and my thread dies from an exception if garbage collecting on the broadcasting TChan with the said thread having a copy via dupTChan will mess up
17:29:08 <Aetherspawn> or is that something I have to carefully implement with ResourceT?
17:32:13 <c_wraith> mess up in what sense?
17:32:54 <c_wraith> threads that complete are no longer GC roots (though they are still considered reachable if something else holds their ThreadId)
17:33:51 <c_wraith> If that thread was holding a dup'd TChan, it won't be considered reachable anymore, and will be GC'd
17:39:48 <lispy> fromJust :: ProofOfJust -> Maybe a -> a
17:39:59 <lispy> too bad we can't write that
17:40:24 <Aetherspawn> c_wraith, hmm
17:40:26 <dmwit> Aetherspawn: You can duplicate a channel, and there are multicast channels.
17:40:37 <Aetherspawn> so as long as the threads die, I should be fine resource-wise
17:40:44 <dmwit> Oh, I see you already discovered that. Apologies.
17:40:47 <Aetherspawn> dmwit, I discovered newBroadcastTChanIO :)
17:40:49 <Aetherspawn> Its incredible.
17:40:57 * Aetherspawn hugs Haskell
17:41:19 <Fuuzetsu> I'm having issues building Haddock with --enable-tests. It builds fine without the flag, but with it I get http://hpaste.org/88271
17:41:28 <Fuuzetsu> Running git GHC, compiled few hours ago
17:41:32 <Fuuzetsu> Any ideas?
17:41:34 <Demos> what is the hint equivalent of :m + ...
17:42:08 <amphigory> So, I'm trying to use Leksah, and didn't get a response on the Leksah channel.  Short form: I created a workspace and a package, but everytime I try to add a module, it says "Not a valid module name", no matter what I name it.  I'm on Windows, for what it's worth.  Suggestions?
17:42:25 <elliott> what names have you tried?
17:42:31 <elliott> perhaps they're not as valid as you expect
17:43:10 <amphigory> "model" was the one I wanted.  Wait, has to be uppercase, doesn't it?
17:43:35 <amphigory> sorry, brand new to Haskell.
17:44:56 <monochrom> yes, uppercase. Model. MODEL. MoDeL. etc.
17:45:03 <monochrom> just not mODEL :)
17:45:23 <amphigory> Yeah, that did it.
17:55:44 <lispy> Oh, sounds like the error message should be more clear about what makes a valid module name
18:03:39 <Cale> Who highlighted me earlier?
18:03:50 * hackagebot inspection-proxy 0.1.0.0 - A simple proxy for debugging plaintext protocols communication  http://hackage.haskell.org/package/inspection-proxy-0.1.0.0 (MariusGhita)
18:04:02 <Cale> not in scrollback, oh well :)
18:04:51 <geekosaur> may have been: [20 15:25] <lambdabot>   mueval-core: NotAllowed "These modules have not been loaded:\nL\n"
18:04:59 <geekosaur> (reaction thereto)
18:05:50 <Ndit> Spinach and Cale salad, yummm
18:06:38 <Cale> geekosaur: Yeah, that's a weird message, not quite sure what caused that
18:08:50 * hackagebot ghc-mod 2.0.0 - Happy Haskell programming on Emacs/Vim  http://hackage.haskell.org/package/ghc-mod-2.0.0 (KazuYamamoto)
18:23:01 <dmwit> mauke: copyindent is awesome, thanks. It also made me discover preserveindent, which is also awesome.
18:33:50 * hackagebot aws 0.7.6.4 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.7.6.4 (JohnWiegley)
18:37:34 <lispy> Cale: have you seen the stuff about the new lambdabot? Does 'safe' actually mean safe for arbitrary command execusion over IRC? I'm a bit skeptical.
18:38:27 <cmccann> pretty sure that doesn't protect against DoS via "fix id" or such, if nothing else.
18:39:01 <c_wraith> safe means whatever the package author claims it means
18:39:18 <c_wraith> using safe haskell puts the onus on the compiler to make visible only packages they trust
18:39:38 <c_wraith> err, by "compiler" I meant "person doing the compiling"
18:39:42 <c_wraith> rather than the piece of software
18:39:58 <geekosaur> I thought safe haskell meant only that the package couldn't be used to derive unsafeCoerce
18:40:07 <c_wraith> nope
18:40:11 <c_wraith> Doesn't mean that at all
18:40:28 <c_wraith> you can easily mark a package that exports unsafeCoerce as Trusted
18:40:53 <c_wraith> You have to actually make sure that you trust the package you're installing for safe haskell to do anything
18:40:54 <geekosaur> you can explicitly defeat it, yes
18:41:06 <geekosaur> so at this point I am led to understand that it means nothing whatsoever
18:41:20 <Demos> so I want to install darcs on my windows computer via cabal-install, says I need curl, I downloaded the dll and headers for libcurl-mingw32 and stuck them in Haskell Platform\version\include but it is not seeing them
18:41:26 <geekosaur> because there was a long list thread which boiled down to the only kind of safety they cared about was type safety
18:41:31 <geekosaur> and you have just denied that
18:41:45 <geekosaur> which leaves nothing whatsoever for it to mean
18:42:12 <lispy> Demos: you need to pass a flag to cabal-install but I forgot what the flag is. You might try asking #darcs.
18:42:56 <Demos> there is a param that tells it to look in other places but I would think that the include dir of haskell platform would be in the default path
18:43:13 <geekosaur> (in particular they explicitly and categorically denied all possibility of it relating to the kind of safety you'd want in lambdabot)
18:43:33 <lispy> geekosaur: yeah, that kind of rings a bell
18:44:38 <cmccann> note that in security parlance, "trusted" means "if it goes wrong, everything is fucked"
18:45:55 <geekosaur> and my recollection was that they explained it as meaning you can't derive unsafeCoerce from use of the module, but now I am being told it's "not that at all"
18:46:04 <geekosaur> so what is Safe Haskell, take 45 or so?
18:46:29 <cmccann> well, you can explicitly trust any package and module you want. if you don't want unsafeCoerce, then don't trust a package/module that exports it.
18:47:23 <c_wraith> geekosaur: it allows you to have the compiler check that code you're compiling uses only code you have decided to trust.
18:47:30 <geekosaur> never mind, I;'ll just remember that nobody ever agrees what it means iand it is meaningless
18:47:33 <cmccann> but a module that's "safe" instead of "trusted" won't do anything fishy behind your back
18:47:51 <c_wraith> geekosaur: with a finer granularity than just the package system
18:48:10 <jmcarthur> cmccann: can't a module be "safe" even if it depends on "trusted" modules?
18:48:14 <geekosaur> because if nobody's agreeing what they mean when they say something is Safe or Trusted then in fact it is not Safe or Trusted at all
18:48:14 <c_wraith> geekosaur: so you can declare that some modules in base are trustworthy, and others aren't
18:48:32 <RichyB> It's "you mark as trusted the IO-using packages that you think contain no undefined behaviour or type violations as trusted, and then Safe Haskell marks modules as safe if they depend only on trusted modules or other safe modules."
18:48:45 <RichyB> er, redundant "as trusted" in there.
18:48:54 <lispy> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/safe-haskell.html
18:49:01 <geekosaur> in fact it's even less safe to use them because it's advertising an undefined Safe/Trusted-ness that does not extend beyond itself because some other package decided to use it to mean something else
18:49:07 <lispy> 7.23.4.4. Trustworthy Requirements
18:49:08 <lispy> Module authors using the -XTrustworthy language extension for a module M should ensure that M's public API (the symbols exposed by its export list) can't be used in an unsafe manner. This mean that symbols exported should respect type safety and referential transparency.
18:49:25 <geekosaur> that's what I thought
18:49:39 <lispy> so it could do anything internally, but it's expected (trusted) to not expose that crazy
18:49:47 <geekosaur> [20 21:40] <c_wraith> Doesn't mean that at all
18:50:14 <RichyB> IMHO I don't see any use for it whatsoever because I believe that it is *exceedingly* unlikely, given the size of the attack surface involved, that there will not turn out to be exploitable undefined behaviours in a) pretty much any useful trusted modules and b) the compiler and runtime itself.
18:50:48 <jmcarthur> the promise isn't about whether there are security bugs
18:50:50 <geekosaur> if people are not paying attention to that and using it to mean random other things then it is worse than meaningless
18:51:00 <RichyB> That's just guessing based on the fact that reliable sandboxing with a big attack surface is really, really hard (e.g. see Java, which keeps getting broken despite having Sun/Oracle's army of programmers behind it).
18:51:34 <RichyB> jmcarthur: it's supposed to be helping you avoid accidental undefined behaviour rather than deliberate undefined behaviour, then?
18:51:39 <cmccann> if people are not paying attention to what a security feature means and explicitly trusting anything that politely says it will behave they have bigger problems.
18:51:41 <geekosaur> RichyB, are you working under the false belief that it has to do with security still? Despite having just been told what it does mean (which, you may note, has nothing to do with security)?
18:51:44 <lispy> RichyB: but as geekosaur and others are pointing out, it's not about security. It's about type safety
18:51:49 <RichyB> That makes a reasonable amount of sense.
18:52:12 <jmcarthur> RichyB: it'
18:52:13 <elliott> the intention is clearly to use that type safety to create security, I think.
18:52:13 <jmcarthur> oops
18:52:19 <RichyB> geekosaur: because I have only just learned what the purpose was supposed to be.
18:52:24 <elliott> by e.g. exposing a restricted IO monad to the code and compiling it with Safe Haskell.
18:52:35 <elliott> that way you know the interface it uses is restricted and it doesn't do any unsafePerformIO funny business behind your back.
18:52:48 <jmcarthur> it's really just a way for somebody to make claims about the trustworthiness of their code. it's not really a great way to *enforce* anything
18:52:54 <cmccann> I can't speak to what the intended use cases are. it's clearly not a general security mechanism and never was intended to be.
18:53:31 <cmccann> it's about ensuring that code either does only what its types claim it does, or that you've explicitly trusted it to behave properly.
18:53:55 <jmcarthur> e.g. copumpking is unlikely to declare Control.Spoon to be trustworthy
18:54:01 <jmcarthur> *copumpkin
18:54:04 <cmccann> a module being "Trustworthy" just means that it isn't trivially safe but the author thinks allowing it is reasonable.
18:54:11 <copumpkin> oh good idea
18:54:14 * copumpkin makes it trustworthy
18:54:15 <jmcarthur> ugh
18:54:18 <cmccann> haha
18:54:36 <cmccann> actually spoon is a reasonable example of something that could reasonably be "Trustworthy"
18:54:46 <shachaf> What about lens?
18:54:46 <jmcarthur> cmccann: i disagree
18:54:50 <lispy> bytestring is another example
18:55:01 <lispy> IIRC it doesn't infer as Safe, does it?
18:55:04 <jmcarthur> cmccann: i would say something is worthy of "trustworthy" when it's implementation isn't necessarily pure but its interface is
18:55:14 <jmcarthur> cmccann: spoon is not a pure interface
18:55:21 <jmcarthur> *its
18:55:32 <cmccann> jmcarthur: so you don't include it in the packages you trust
18:55:50 <jmcarthur> sure. i just mean, i thought this was kind of the most accepted standard of what it means
18:56:12 <jmcarthur> lispy: i would be surprised if bytestring inferred as safe, yeah
18:56:22 <shachaf> copumpkin: Can you rename teaspoon to spoon and spoon to tablespoon? hth
18:56:30 <copumpkin> you can
18:56:34 <copumpkin> but I advise against breaking the API
18:56:42 <shachaf> OK, and can I push it to Hackage?
18:56:56 <shachaf> The fact that "spoon" uses NFData is sad.
18:57:03 <geekosaur> I don't think bytestring could be automatically inferred as safe? it uses FFI calls, which it's hard to make automated promises about
18:57:21 <cmccann> I think FFI calls are allowed if they're in IO
18:57:27 <jmcarthur> right
18:57:37 <jmcarthur> but unsafePerformIO is not allowed
18:57:44 <shachaf> Fortunately bytestring uses inlinePerformIO.
18:57:47 <arkeet> shachaf: hence teaspoon.
18:57:48 <jmcarthur> ha
18:58:05 <shachaf> arkeet: Yes, but people will use spoon by default.
18:58:11 <shachaf> Because it has the better name.
18:58:14 <arkeet> true.
18:58:25 <arkeet> I wouldn't want to use a spoon without knowing what kind of spoon it was.
18:58:25 <shachaf> People already like NFData way too much.
18:58:36 <jmcarthur> wait, who likes NFData?
18:58:45 <lispy> I kind of wish we had the agda feature of renaming things with an import (it makes reading code harder, so that's a trade off)
18:58:48 <cmccann> copumpkin: you should add a multi-threaded version of spoon, because then you could call it "spork".
18:58:51 * hackagebot postgresql-simple 0.3.2.0 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.3.2.0 (LeonSmith)
18:58:52 <copumpkin> lol
18:58:54 <arkeet> lol
18:59:04 <copumpkin> please go ahead and improve it for me
18:59:06 <copumpkin> both of you!
18:59:39 <liyang> inb4 spoonWithHandle
18:59:47 <shachaf> Aha! We can take inspiration from an old joke.
19:00:21 <liyang> (srsly...)
19:00:25 <shachaf> Oh, that was about glasses, not spoons?
19:02:41 <shachaf> Two people are at a restaurant and ask for drinks. A: "I'll have orange juice." B: "I'll have orange juice too -- make sure the glass is clean, please!"
19:02:50 <shachaf> The waiter goes away for a while and then comes back with two glasses of orange juice and asks "Which one of you wanted the clean glass?"
19:03:03 <shachaf> So call teaspoon cleanSpoon.
19:03:22 <arkeet> I don't get it.
19:03:30 <cmccann> it's not a very funny joke.
19:03:31 <liyang> They're both clean.
19:03:46 <arkeet> ok, it's not a very funny joke.
19:03:47 <liyang> (One would hope.)
19:04:08 * copumpkin hugs shachaf 
19:04:11 <cmccann> shachaf: imo you should stick to puns instead of other jokes hth
19:04:33 <arkeet> I expect a certain standard of terribleness from shachaf. this joke does not meet it.
19:04:53 <shachaf> I told this joke not for its humor value but as inspiration for API design.
19:04:58 <cmccann> jokes are clearly sclv's department.
19:05:38 <cmccann> @quote sclv Q
19:05:38 <lambdabot> sclv says: Q: Why are the adjunctions of Galois connections backwards? A: He never got the hang of duals.
19:05:51 <copumpkin> oh god
19:05:56 <cmccann> hahahaha
19:06:29 <johnw> i don't get why that one is funny
19:06:42 <liyang> Galois died in a duel.
19:06:47 <johnw> ah
19:07:03 <liyang> At 21-ish. :-/
19:07:06 <shachaf> @quote shachaf galois
19:07:06 <lambdabot> shachaf says: It is a sobering thought that by the time Galois was my age, he had been dead for almost two months.
19:08:15 <shachaf> But, really, it's over a year.
19:08:42 <copumpkin> :)
19:09:42 <cmccann> by the time Galois was shachaf's age, that quote had been out of date for months.
19:13:51 * hackagebot ghc-mod 2.0.1 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-2.0.1 (KazuYamamoto)
19:16:39 <tonsofquestion> what does a type name followed by a '#' mean?
19:17:28 <byorgey> tonsofquestion: usually that indicates some sort of primitive/low level/unboxed type
19:17:43 <tonsofquestion> thx
19:18:27 <byorgey> note the # is just a naming convention, it has no special meaning on its own
19:18:58 <cmccann> # means a corridor in the dungeons of doom
19:19:06 <byorgey> though it is a bit special since in order to use names ending with # you have to turn on the MagicHash extension
19:19:11 <byorgey> haha
19:19:26 <byorgey> that is an apt description even in the context of GHC.
19:19:32 <cmccann> :D
19:20:20 <shachaf> 5# has a special meaning on its own.
19:21:37 <tonsofquestion> oh, thank you, before u told me, i was confused that # is a symbol which should not be a part of a type name as language report says
19:22:06 <cmccann> yeah, that's why it generally means "GHC internals, don't touch (unless you know what you're doing)"
19:22:29 <shachaf> I like to add "(or you're shachaf)" after that.
19:22:47 <cmccann> shachaf: no that's about blaming you, not being you.
19:22:48 <tonsofquestion> i just want to understand how mvar works
19:22:49 <elliott> aren't we all shachaf?
19:23:00 <applicative_> > I# (5# +# 3#)
19:23:02 <lambdabot>   Not in scope: data constructor `I#'
19:23:02 <lambdabot>  Perhaps you meant `In' (line 124)Not i...
19:23:06 <applicative_> :(
19:23:08 <shachaf> elliott: I thought I was the only one!
19:23:23 <tonsofquestion> yeah, it has the module name GHC.MVar, I should notice that
19:23:24 <cmccann> every time you make a bad pun, a little piece of shachaf's spirit lives in your heart.
19:23:57 <monochrom> "the universal property of shachaf"
19:24:22 <cmccann> shachaf is the terminal object in the category of people making bad puns.
19:24:29 <shachaf> I think cmccann is uniquely isomorphic to me.
19:24:37 <elliott> shachaf is dying?
19:24:40 <tikhonjelvis> by your description, he's more like the *initial* object
19:25:24 <shachaf> No one said anything about which way the arrows go!
19:25:29 <cmccann> tikhonjelvis: true, it makes more sense for the arrows to go that way.
19:26:41 <cmccann> shachaf: I'm one email address away from being isomorphic to anyone I want!
19:31:26 <liyang> Spork away! https://github.com/liyang/spoon
19:31:53 <monochrom> "that is only logical" :)
19:32:39 <shachaf> Can you use teaspoonWithHandles to implement upon?
19:32:47 <monochrom> "if all you have is a spork, everything looks like meatball"
19:32:52 <shachaf> > set (upon (!!5)) 'x' "blah blah blah"
19:32:54 <lambdabot>   "blah xlah blah"
19:32:57 <shachaf> > set (upon last) 'x' "blah blah blah"
19:32:58 <lambdabot>   "blah blah blax"
19:34:13 <liyang> shachaf: I've no idea. It's just that I said to copumpkin I wanted to add handles to spoon a while ago, but never got around to it. Then today people were talking about adding sporks.
19:34:55 <shachaf> Oh, I thought "Spork away" meant "feel free to fork spoon".
19:35:01 <cmccann> I suppose spork would do the deepseq in a new thread or something.
19:35:07 <liyang> shachaf: that too!
19:35:21 <liyang> cmccann: I think that was the gist of it, yeah.
19:35:42 <cmccann> I don't think there was a gist of it. I just wanted to suggest "spork".
19:36:02 <cmccann> what it would actually do was not the point.
19:36:17 <shachaf> That is the cmccann way.
19:36:19 <liyang> Likewise with the handles. :3
19:37:41 <elliott> why is it called spoon anyway
19:38:06 <cmccann> not sure what the best way to write spork would be. need to make sure no exceptions leak into the "main" thread but avoid doing the actual work on that thread.
19:38:17 <cmccann> maybe some hackery with an MVar or something, I dunno.
19:38:33 <cmccann> horrendously unsafe crap involving threading isn't really my forte.
19:38:57 <cmccann> elliott: perhaps that's copumpkin's battle cry.
19:39:40 <elliott> cmccann: get real, horrendously unsafe crap is definitely your forte.
19:39:58 <cmccann> what no
19:40:07 <cmccann> baroque and horrendously unusable stuff sure
19:40:37 <elliott> my rule is, if it's terrible, it's cmccann's forte and shachaf will help out a bit too.
19:40:52 <cmccann> I think you are confusing me with you.
19:41:04 <elliott> if by you you mean me...
19:41:05 <cmccann> also, shachaf doesn't actually do anything, that's silly.
19:41:33 <cmccann> if by if by you mean you mean let's don't start this again
19:42:07 <shachaf> I think you can do an if-by-of-if-by optimization on that.
19:43:21 <cmccann> shachaf: with -O11 it compiles down to a "stfu elliott" primop.
19:43:34 <cmccann> shachaf: also I think this is where you complain being off topic.
19:43:49 <shachaf> cmccann: Complaints about being offtopic are offtopic. hth
19:43:56 <cmccann> you're off topic.
19:45:43 <Demos_> when I putStr "\r" from ghci it moves the cursor to the beginning of the line but when that gets called from a executable it starts a new line
19:47:50 <Demos_> wait never mind
19:48:02 <c_wraith> output buffering problem?
19:48:09 <c_wraith> (it's always an output buffering problem)
19:48:33 <cmccann> elliott: say, you should go to hac phi.
19:48:40 <cmccann> I'm sure that's entirely practical for you.
19:50:05 <elliott> cmccann: unlike you, I don't materialise for such trivialities
19:50:40 <cmccann> elliott: yes, but shachaf isn't going, so you're missing a great opportunity to not-meet him IRL.
20:01:10 <carter> acfoltzer, btw, at some point this summer i'd like to pick your brain about numa for ghc
20:01:30 <carter> I may have commercial incentives to get that into ghc
20:09:30 <copumpkin> dragostea din tei
20:10:08 <cmccann> copumpkin: I think I have an MP3 of that somewhere.
20:10:11 <cmccann> it's unnecessarily catchy.
20:16:53 <shachaf> Great libraries@ discussion we have going.
20:18:58 <cmccann> shachaf: does it involve people agreeing to make actual improvements?
20:19:32 <shachaf> cmccann: There's been one serious proposal to fork Haskell already.
20:20:20 <cmccann> what about sporking?
20:21:37 <shachaf> sporks = forks
20:21:47 <cmccann> heresy!
20:23:30 <geekosaur> people agreeing that some changes should be made but also agreeing that they won't be made in the current environment, basically. (although I would like to see the attempt at least; get enough people pushing for them and face down the language committee)
20:25:57 <cmccann> it's weird to read discussions like that because I always forget how much basic stuff isn't actually in Prelude.
20:45:45 <cmccann> man. that libraries@ discussion really reminds me why I started using an alternate Prelude in the first place.
20:46:22 <cmccann> so much obvious everyday stuff not being imported by default is silly. not to mention all the useless monomorphic crap.
20:46:35 <cmears> is it hard to set up GHC to use an alternate prelude by default (so you don't have to give command line options all the time) ?
20:46:52 <laozhizi> hello everyone!
20:47:09 <cmccann> cmears: I just "import Prelude (); import Overture" at the top of every module and similar in my .ghci
20:47:17 <laozhizi> æˆ‘åœ¨è¿™é‡Œï¼Œè¿˜æœ‰æ²¡æœ‰chinese?
20:47:35 <shachaf> laozhizi: Maybe try #haskell-cn ?
20:47:37 <cmccann> and then get confused every time I somehow end up in GHCi with only Prelude because nothing is in scope anymore
20:47:38 <cmears> cmccann, ah, that's not so bad
20:47:58 <shachaf> cmccann: My .ghci imports ~100 modules.
20:48:15 <cmccann> shachaf: Overture reexports Control.Lens soooooooo...
20:48:16 <shachaf> It takes ~1s to start up, unfortunately.
20:50:12 <cmccann> but yeah like I think Prelude doesn't even have Applicative or Monoid? annoying.
20:50:40 <shachaf> It doesn't even have Semigroup.
20:51:23 <liyang> Never mind zygoHistoPrepromorphism.
20:51:48 <edwardk> cmccann: i'm willing to prod the community every couple of years to remind them that the status quo is crap, but i'm not about to start a war over it ;)
20:51:59 <cmccann> hm I don't think Overture exports Semigroup now that you mention it
20:52:05 <cmccann> I should add that
20:52:50 <cmccann> edwardk: I'm happier living in my own little world where saner things are imported by default
20:53:30 * edwardk had a small Prelude replacement a few years ago named abstract that maybe i should polish up and throw into the arena of these things. i just can't bring myself to use one
20:53:34 <cmccann> re-exporting all of lens is probably a bit much though.
20:54:19 <cmccann> edwardk: I pretty much reflexively type the two lines to use Overture every time I create a module at this point
20:54:28 <cmccann> and it's in my .ghci so I barely notice it anymore
20:54:42 <liyang> McCannskell.
20:54:58 <cmccann> at some point I really should finish cleaning that up and make it something usable by not-me people.
20:55:10 <johnw> well, there's a reason it's not called Finale, apparently
20:55:26 <cmccann> hm
20:56:16 <cmccann> "Crescendo" would be a good name for an "everything plus the kitchen sink" Prelude replacement.
20:56:25 <liyang> Foreword, Prologue?
20:56:35 <johnw> makes me think of Foundation
20:56:42 <liyang> Yesod!
20:57:01 <cmccann> liyang: Malkuth, surely.
20:57:24 <edwardk> anyways prelude replacements can't fix the Applicative m => Monad m issue. they can't add methods to classes, etc. so they are just a bandaid
20:57:29 <cmccann> yeah.
20:57:40 <cmccann> I tried making more drastic changes like that
20:57:43 <cmccann> wasn't worth the headaches
20:57:47 <cmccann> too much incompatibility.
20:58:01 <edwardk> e.g. I'd kill for a 'null' and 'length' in Foldable.
20:58:02 <shachaf> A Prelude replacement for doing logic should obviously be called Quodlibet.
20:58:09 <cmccann> also, replacing any of the classes with defaulting behavior is Not Fun To Use even beyond compatibility.
20:58:22 <edwardk> it'd never happen, but i'd really really like them
20:58:32 <johnw> edwardk: why would it never happen?
20:58:48 <edwardk> johnw: break too much code, and the monomorphism police
20:58:58 <johnw> these police need to be overthrown
20:59:21 <cmccann> edwardk: the annoying thing about the monomorphism police is that they're always the same.
20:59:26 <edwardk> i mostly just try to point out the absurdity of the present situation from time to time
20:59:50 <edwardk> then i go write something they'll never use and never annoy me about =P
20:59:51 <johnw> cmccann: they're type is fixed for a given argument, and shall always be so
21:00:11 <elliott> edwardk: you want to make Foldable *bigger*?!
21:00:27 <edwardk> elliott: yes
21:02:35 <cmccann> it would be nice if there was a combined wishlist for "Prelude for sane people" features.
21:03:32 <shachaf> "sane" meaning "similar to cmccann"
21:04:02 <cmccann> shachaf: no that wouldn't help because I want ideas for what to change in Overture.
21:04:12 <carter> cmccann would your ghci load faster with ghc 7.7?
21:04:18 <carter> or am i missing the point?
21:05:27 <cmccann> carter: my only point is that I complain a lot about standard libraries
21:07:12 <carter> ah
21:07:14 <carter> well
21:07:22 <carter> you should vote on the haskell-libraries list
21:08:05 <shachaf> I should start making legitimate-seeming sockpuppets in order to influence libraries@
21:08:17 <cmccann> probably. I don't think I'd be very good at persuading anyone beyond that though.
21:08:46 <johnw> sometimes I want a 64pt font for the "+1"
21:09:03 <elliott> shachaf: like cmccann?
21:09:16 <shachaf> Just do it Henning-style and vote more than one point at a time.
21:09:22 <cmccann> I'm not really legitimate-looking.
21:09:27 <johnw> when edwardk proposed integrating Foldable and Traversable, a part of my cheered, and a part of me sighed
21:09:47 <edwardk> i put it out there just to test the weather ;)
21:10:12 <cmccann> I dunno, it's hard to find the motivation to participate.
21:10:15 <johnw> i created general-prelude mainly just because I was tired of importing those two and then having to hide everything from Prelude that conflicted
21:10:20 <carter> shachaf his votes can logit(vote)-1
21:10:24 <cmccann> the status quo is obviously stupid and I'm already doing things my own way
21:10:33 <edwardk> cmccann: i mostly try to keep my head down and hope that the changes won't be too terrible for me.
21:10:52 <edwardk> whenever someone proposes something of mine get standardized i actually wince.
21:11:07 <carter> edwardk i'm here to poke my head around the corner and dodge all the bullets and capture the flag and then do the harlem shake somehow
21:11:35 <carter> possibly in a different order because of lazy evaluation
21:11:48 <elliott> edwardk: I'm going to propose adding lens to Prelude on libraries@. wish me luck.
21:11:54 <carter> elliott DO IT
21:11:55 <cmccann> hahaha
21:12:00 <edwardk> elliott: that'll end well ;)
21:12:04 <carter> that'll help us sneak in fixing everything else
21:12:12 <carter> i'm going to reply to the bridge burning
21:12:12 <shachaf> elliott: Start with upon.
21:12:14 <elliott> i have a secret weapon
21:12:18 <elliott> i'm going to get shachaf to vote +1000
21:12:19 <carter> with foldable bridgees
21:12:21 <edwardk> elliott: it'd bring foldMap and traverse into the Prelude. sounds good ;)
21:12:39 <cmccann> elliott: ok new plan, you and I start suggesting crazy extreme stuff on a weekly basis. then sensible ideas will seem more acceptable in comparison.
21:12:39 <carter> the army uses foldable bridges, why not haskell
21:12:49 <carter> YES
21:13:25 <elliott> cmccann: i don't think the overton window works as well when you're not sure the people on the list are reasonable enough to vote against your outlandish stuff
21:13:28 <johnw> edwardk: and sequenceA!
21:13:34 <carter> it will then be "learn category theory and HoTT or you won't be able to tell if sclv is trolling list"
21:13:37 <shachaf> cmccann: Where do I fit into this plan?
21:13:45 * cmccann considers proposing a single change of renaming "fmap" to "map".
21:13:48 <shachaf> johnw: sequenceA will be gone when Applicative m => Monad m
21:14:02 <carter> shachaf did that one get enough votes?
21:14:02 <shachaf> cmccann: Like Haskell 1.4, you mean.
21:14:08 <cmccann> shachaf: yes.
21:14:10 <johnw> cmccann: I'd vote for that one
21:14:13 <shachaf> carter: That one hasn't been proposed yet.
21:14:14 <carter> yeah
21:14:17 <cmccann> shachaf: for backwards compatibility obv
21:14:19 <Demos_> hm turns out that static linking all of GHCi into my executable inflates the size a bit
21:14:22 <edwardk> carter: it is safe to assume sclv is always trolling
21:14:24 <elliott> haskell 1.4 was great.
21:14:27 <shachaf> cmccann: No need to put it into the Prelude.
21:14:29 <coppro> elliott: can we also get Data.Bikeshed?
21:14:33 <elliott> I forget what haskell 98 actually improved.
21:14:34 <carter> edwardk i'ms tarting to realize that
21:14:36 <elliott> I remember someone giving me a list.
21:15:00 <shachaf> elliott: error messages hth
21:15:19 <elliott> shachaf: have you *seen* GHC's error messages these days?
21:15:21 <elliott> all the ~s.
21:15:33 <carter> all the libs listed as being subject to libraries voting http://www.haskell.org/haskellwiki/Library_submissions are one we can sway people to ok
21:18:09 <elliott> edwardk should just take over the committee and replace everyone with him, and then steer the haskell mothership into the fiery blistering inferno of doom, wreaking endless havoc and armageddon in his wake. that would be comforting.
21:18:33 <edwardk> sounds good. i look forward to my appointment as dictator. make it so
21:18:38 <cmccann> elliott: +1 to that
21:19:04 <carter> shachaf OMG, i remember when error messages were bad
21:19:20 <carter> Ensign elliott , fire upre the representatable functors
21:19:24 <carter> Ensign elliott , fire up the representatable functors
21:19:29 <Ghoul_> @pl (\x->err = errorM "Progress" $  "Error generating the encryption key: " ++ x)
21:19:30 <lambdabot> (line 1, column 11):
21:19:30 <lambdabot> unexpected " "
21:19:30 <lambdabot> expecting operator
21:19:44 <Ghoul_> @pl (\x -> errorM "Progress" $  "Error generating the encryption key: " ++ x)
21:19:44 <lambdabot> errorM "Progress" . ("Error generating the encryption key: " ++)
21:20:07 <elliott> edwardk: my only question is how big the explosions will be.
21:20:43 <carter> elliott depends on how HoTT it gets
21:20:57 <no-n> how's Carmack's port coming along? is there anywhere we can see progress yet?
21:21:01 <no-n> or any news at all?
21:21:13 <no-n> (since it waas announced that he was going to do it)
21:21:16 <jmcarthur> it's probably going to be mostly quiet until it's basically done
21:21:17 <carter> no-n seems like its his own private code
21:21:24 <no-n> aww
21:21:55 <no-n> well, I guess I'm not surprised. I wonder if the source code will be released when it's done.
21:21:58 <jmcarthur> let the man learn on his own already :)
21:22:10 <no-n> yeah, I know ;)
21:27:46 <cmccann> ok I just subscribed to libraries@
21:27:50 <cmccann> this will probably end poorly
21:28:48 <coppro> we should totally decompose the IO monad into the I and O monads
21:28:56 <elliott> we'll miss you, cmccann.
21:29:53 <cmccann> elliott: did you propose adding lens to Prelude yet hurry up so I can +1 it
21:29:59 <Demos_> is there a way to get literal strings in haskell, like c#'s @"" syntax?
21:30:14 <shachaf> You can use a quasiquote thing.
21:30:22 <Demos_> go oooonnnnn
21:30:43 <lispy> http://www.haskell.org/haskellwiki/Quasiquotation
21:30:48 <carter> cmccann i'm about to post to the list about foldable combustible bridges
21:30:48 <lispy> Demos_: ^^ first link on gogole
21:30:52 <lispy> google even
21:30:58 <carter> with asbestos
21:31:08 <Demos_> sorry, thought it was something arcane :D
21:31:27 <lispy> it is arcane
21:31:30 <lispy> and those examples are bad
21:31:33 <lispy> (overly complex)
21:31:43 <lispy> But there is very little good documentation on the topic
21:31:44 <shachaf> Well, it's certainly not divine.
21:31:44 <cmccann> carter: ok godspeed
21:31:51 <carter> cmccann indeed
21:33:09 <Demos_> OK yeah that is not really wat I wanted
21:33:28 <lispy> the thing on the libraries list about making disruptive changes could be made slightly less painful by getting more people to use the cabal feature where you specify the language revision
21:33:51 <lispy> Demos_: try some of the other hits on google? ;) Or maybe explain the @"" syntax?
21:34:03 <lispy> I've never used that feature of C#
21:34:27 <cmccann> @quote glguy libraries
21:34:27 <lambdabot> glguy says: libraries@ serves an important role of stopping changes from being introduced to the libraries
21:34:48 <shachaf> imo haskell should borrow c++11's new string syntax
21:34:57 <carter> eh?
21:35:10 <carter> fuck, sounds like we need to burn the list
21:35:13 <carter> i kid
21:35:18 <carter> whats in cpp11 strings?
21:35:19 <lispy> Demos_: I tried to google for the @ syntax of C# but I'm not finding it.
21:35:29 <Demos_> just being able to right say @"\n" for example and get a string with a \ and an n in it
21:35:33 <shachaf> (When I say something that starts with "imo" it's usually the opposite of my opinion. Or sometimes it's my opinion.)
21:35:43 <shachaf> Demos_: Is the quasiquotation thing not satisfactory?
21:35:47 <cmccann> shachaf: imo it's always your opinion.
21:36:01 <shachaf> The syntax would be something like [blah|\n|], for some value of blah.
21:36:26 <cmccann> (when I say something that starts with "imo" it's usually to harass shachaf somehow)
21:36:28 <Demos_> I dont know what the hell the QQ thing even is, and template haskell is really not something I need to deal with, OK what would [blah|\n|] get me?
21:36:44 <elliott> it is something you need to deal with, if you want this functionality.
21:36:55 <lispy> for a suitable blah it would give you ['\\','n']
21:37:00 <shachaf> (when i say something it's usually to harass cmccann somehow)
21:37:34 <cmccann> shachaf: we probably don't spend enough time harassing elliott.
21:37:41 <shachaf> Demos_: It would get you what you asked for. Please try to be a bit nicer.
21:37:52 <pqmodn> lispy: http://www.dotnetperls.com/string-literal
21:38:06 <shachaf> Demos_: This is the only mechanism GHC has for this. Otherwise it doesn't have it. Sorry.
21:38:07 * ski . o O ( "The `O' monad" <http://web.archive.org/web/20070221203145/http://www.math.chalmers.se/~nordland/ohaskell/survey.html#sect6> )
21:38:24 <Demos_> sorry, did not mean to bark at you :D
21:38:36 <lispy> pqmodn: thanks
21:40:42 <ski> coppro : .. like that ?
21:41:44 <carter> yesss, i now have a nice ticket on ghc trac to fix the ghc compilation driver
21:42:06 <cmccann> clearly I and O should be adjoint functors that give rise to IO when composed.
21:43:03 <shachaf> Obviously O would be left adjoint to I.
21:43:08 <shachaf> So it should be called OI.
21:44:21 <carter> shelf o i seeeeee
21:44:29 <carter> damn auto correc
21:44:32 <coppro> ski: nope
21:44:33 <carter> i mean shachaf
21:44:37 <coppro> the O monad is output actions only
21:44:41 <coppro> the I monad is input only
21:44:43 <cmccann> shachaf: I suppose O would be (RealWorld,) and I would be (RealWorld ->)
21:44:57 <cmccann> that is clearly sensible.
21:45:37 <shachaf> cmccann: Well, not necessarily RealWorld, but that was the idea.
21:45:51 <johnw> we can call it the alimentary adjunction
21:45:51 <elliott> shachaf doesn't live in the RealWorld.
21:46:02 <coppro> shachaf causes serious international side effects
21:46:04 <cmccann> while we're at it, we can redefine (IORef a) as (Lens' RealWorld a).
21:46:06 <cmccann> that's legit, right?
21:46:55 <ski> istr seeing some O'Haskell (or Timber ?) snippet saying roughly "The `O' monad is what remains when we remove the evil `I' (for \"Input\") from the `IO' monad" -- but can't seem to find it atm
21:47:46 <ski> cmccann : Lens' ?
21:48:20 <shachaf> ski: Lens' s a = Lens s s a a
21:48:29 <shachaf> For a lens that doesn't change types.
21:48:43 <ski> ok
21:49:00 <shachaf> (Weren't you in #haskell-lens? Or was that someone else?)
21:49:21 <ski> i was, but forgot to rejoin
21:49:31 <elliott> ski: http://web.archive.org/web/20070221203358/http://www.math.chalmers.se/~nordland/ohaskell/index.html has your cite
21:50:05 <edwardk> ski: we adopted the ' convention because it was a lot more terse than the 'Simple Lens s a' convention we used to use and read well
21:50:10 <carter> cmccann shachaf  should i attached a "CHANGE" poster jpeg to the email?
21:50:12 <ski> oh, right, should have looked at the intro page
21:50:18 <edwardk> also it doesn't require LiberalTypeSynonyms
21:50:30 <carter> this is me getting a bit unprofessional
21:50:33 <shachaf> carter: You shouldn't *actually* spam libraries@ with jokes.
21:50:35 <carter> ok
21:50:45 <carter> shachaf ok i wont
21:50:59 <shachaf> It's meant to be kept reasonably on-topic.
21:51:04 <carter> but the rest of the email is just saying : nothing will break, prelude will be more uniform, lets just do it
21:51:07 <ski> hm .. `Lens2'
21:51:17 <cmccann> shachaf: except +1 votes in favor of monomorphic functions, those jokes are acceptable apparently
21:51:44 <shachaf> cmccann: I say map :: (Int -> Int) -> [Int] -> [Int]
21:51:47 <carter> i actually had a friend totally confused why the minimum :: ord a=> [a]-> a existed
21:52:03 <shachaf> Because it ought to be :: Ord a => [a] -> Maybe a, obviously.
21:52:26 <elliott> it ought to be (Ord a, MinBounded a) => [a] -> a
21:52:30 <elliott> er.
21:52:31 <elliott> *MaxBounded
21:52:38 <cmccann> Ord a => NonEmpty a -> a
21:52:41 <cmccann> problem solved.
21:52:45 <carter> ja
21:52:52 <shachaf> elliott: No, because [] still has no minimum.
21:53:03 <elliott> minimum [] = maxBound, obviously.
21:53:10 <elliott> next you'll be saying product [] shold be Nothing.
21:53:39 <lispy> > maxBound ()
21:53:41 <lambdabot>   No instance for (GHC.Enum.Bounded (() -> a0))
21:53:41 <lambdabot>    arising from a use of `e_1...
21:53:43 <shachaf> Yes, if you're talking about monoids.
21:53:48 <shachaf> Er, semigroups.
21:53:52 <cmccann> > maxBound :: ()
21:53:53 <lambdabot>   ()
21:53:54 <shachaf> But we're talking about monoids with product.
21:54:03 <lispy> cmccann: ta
21:54:11 <cmccann> > succ ()
21:54:13 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
21:54:14 <elliott> you're just trying to make this so easy, shachaf.
21:54:23 <ski> > [() .. ()]
21:54:25 <lambdabot>   [()]
21:54:26 <cmccann> that remains one of the stupidest instances in the standard libraries
21:54:29 <lispy> cmccann: of course you can't succ it, it's already maxbound...
21:54:34 <shachaf> > [(),()..()]
21:54:36 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
21:54:37 * lispy hates that instance of ()
21:54:39 <ski> > [() ..]
21:54:40 <lambdabot>   [()]
21:54:43 <lispy> s/of/for
21:55:01 <ski> lispy : whyfore ?
21:55:32 <lispy> ski: It it throws exceptions for pretty much everything in the class, why did we bother to write it?
21:55:52 <lispy> > pred ()
21:55:54 <lambdabot>   *Exception: Prelude.Enum.().pred: bad argument
21:55:54 * cmccann hates Enum in general for being an atrocious crime against all that is right and true 
21:56:18 <johnw> but not against all that is Right and True
21:56:40 <ski> > pred "False"
21:56:42 <lambdabot>   No instance for (GHC.Enum.Enum [GHC.Types.Char])
21:56:42 <lambdabot>    arising from a use of `...
21:56:42 <carter> Bool on you
21:56:47 <cmccann> now that I'm on libraries@ I should start sending proposals to fix all the partial Prelude functions.
21:56:53 <ski> er, without quotes
21:56:54 <cmccann> starting with fromJust.
21:56:55 <ski> > pred False
21:56:56 <lambdabot>   *Exception: Prelude.Enum.Bool.pred: bad argument
21:57:15 <elliott> cmccann: Maybe a -> [a]
21:57:27 <lispy> ski: yeah, it's really obnoxious :)
21:58:00 <cmccann> actually I'm tempted to propose removing fromJust as a serious legit proposal.
21:58:02 <cmccann> what does that even exist?
21:58:04 <cmccann> it is terrible.
21:58:12 <johnw> cmccann: agreed
21:58:20 <lispy> cmccann: it's nice for inside ghci
21:58:33 <cmccann> it's not even vaguely justified like head and tail are, since sometimes you know a list is of some minimum length.
21:58:38 <lispy> as someone on libraries@ recently pointed out, just try to keep it out of "production"
21:59:04 <elliott> cmccann: well, sometimes you know a Just is Just.
21:59:17 <elliott> there are programs that nobody knows how to write without fromJust or a fancier type system, I think.
21:59:40 <cmccann> and those few programs can write their inexhaustive patterns by hand
21:59:42 <shachaf> elliott: What are you thinking of?
21:59:53 <shachaf> Yes, let Just x = ... is much better than let x = fromJust ...
22:00:10 <cmccann> fromJust being a thing that exists mostly encourages newbies to use it.
22:00:12 <elliott> shachaf: lens stuff.
22:00:17 <elliott> that program roconnor wrote and similar things.
22:00:17 <ski> cmccann : you should suggest adding `type Predicate a = a -> Bool',`type Orderer a = a -> a -> Bool' and `type Comparator a = a -> a -> Ordering', and using those in type signatures where appropriate while you're at it
22:00:43 <cmccann> I mean, I would propose removing or Maybe-ing most partial functions in base but I doubt most would fly
22:00:49 <cmccann> but fromJust is just awful.
22:01:00 <elliott> cmccann: anyway I'm sort of of the opinion that it's pointless to make more functions total without a more expressive type system that lets them be total in the way they really want to be.
22:01:07 <shachaf> elliott: Ah, hmm.
22:01:12 <elliott> dealing with a billion Maybes is kind of annoying.
22:01:16 <elliott> even if some of them are justified.
22:01:32 <elliott> there are some cases where it should be fixed though.
22:01:46 <elliott> I guess s/more/lots of/
22:01:56 <lispy> there are some quite reasonable combinators in Data.Maybe
22:02:04 <lispy> (if everything is giving you Maybes)
22:02:12 <elliott> yes, of course. it's not insurmountable
22:02:25 <elliott> but for something like minimum/maximum I sort of question whether it's worth the bother presently.
22:02:29 <cmccann> elliott: most of the common scenarios could be fixed by having better types that are not fancy at all
22:02:45 <cmccann> like using non-empty lists or such where that makes sense.
22:03:01 <elliott> well, I think NonEmpty is kind of a pain too.
22:03:05 * ski . o O ( refinement types )
22:03:22 <lispy> Actually though, I tend to move my Maybes to one extreme or the other when I can. Sort of like separating out IO. Either everything you're doing is in IO right now or you just need IO to load some data and the rest of the program is pure (or in a special monad)
22:04:05 <cmccann> I tend to make liberal use of default values via an infix version of fromMaybe or propagating more detailed errors.
22:04:25 <lispy> infix version of fromMaybe?
22:04:44 <cmccann> or, obviously, making functions have real outputs for all inputs in general...
22:04:55 <cmccann> lispy: (??) = flip fromMaybe
22:05:11 <lispy> I haven't seen that before
22:05:20 <cmccann> so x ?? y = x if Just, y otherwise.
22:05:26 <cmccann> fixity to chain in the obvious way.
22:05:28 <lispy> yeah
22:05:29 <ski> @type (??)
22:05:30 <cmccann> it's handy.
22:05:30 <lambdabot> Functor f => f (a -> b) -> a -> f b
22:05:36 <elliott> x ?? y = fromJust (x <|> Just y) -- to upset cmccann
22:05:58 <johnw> except that now I'm used to ?? from lens
22:06:02 <cmccann> yeah I think there's a (??) in lens now or something I have to hide.
22:06:13 <cmccann> that has annoyed me since it was added.
22:06:19 <johnw> maybe the fromMaybe one should be ?!
22:06:30 <lispy> is it strict?
22:06:40 <cmccann> (fwiw ?? is an operator in C# that does the same thing)
22:06:40 <johnw> for "maybe value on the left", "actual value on the right"
22:06:45 <lispy> ?'
22:06:46 <lambdabot> Maybe you meant: . ? @ v
22:07:02 <johnw> hmm.. it's not strict, that's a good point
22:07:10 <johnw> ???
22:07:11 <ski> @type let (â€½) = flip fromMaybe in (â€½)
22:07:11 <lambdabot> fd:9: commitBuffer: invalid argument (invalid character)
22:07:26 <lispy> unicode, how does that work?
22:07:36 <cmccann> lispy: it doesn't, clearly
22:07:37 * lispy wags a finger at lambdabot 
22:08:52 <elliott> cmccann: lens's (??) is ski flip!
22:09:25 <carter> night all
22:09:35 <edwardk> cmccann: if it makes you feel better i wanted (?) but was overruled
22:09:37 <edwardk> blame elliott
22:09:39 <edwardk> and shachaf
22:09:42 <lispy> johnw: We don't have a great way to say "this function is strict". It seems we use ' for normal functions and ! when it's an operator.
22:09:45 <elliott> cmccann already blames shachaf
22:09:48 <cmccann> yes
22:10:06 <shachaf> @quote blame
22:10:06 <lambdabot> ivanm says: yeah, blame dcoutts... with his gtk2hs hat, he blames his c2hs hat for not playing nicely with his cabal hat
22:10:16 <lispy> edwardk: oh, circa the (#) thread on @libraries?
22:10:25 <shachaf> Hmm, blame dcoutts. That's a new one.
22:10:27 <shachaf> @quote blame
22:10:27 <lambdabot> copumpkin says: when in doubt, blame ski
22:10:30 <cmccann> anyway I'm not really sold on several of the misc operators in lens that aren't part of the metalanguage style.
22:10:40 <cmccann> but oh well :P
22:10:52 <shachaf> There should be Control.Lens.Noperators for people to import.
22:11:10 <lispy> Nope-rators?
22:11:12 <cmccann> I just hide (??) from lens along with all the other stuff I hate, like monomorphic Prelude functions. :P
22:11:16 <edwardk> shachaf: i offered to accept such a patch
22:11:22 <shachaf> Nadirer would surely use that.
22:11:36 <applicative_> what's wrong with ?? ?
22:11:38 <cmccann> Control.Lens.Nope.Rators
22:11:48 <edwardk> shachaf: Control.Lens.Operators.Nope.Nope.Nope
22:11:49 <applicative_> except that it has nothing much to do with lenses?
22:12:10 * lispy likes the idea of having "Nope" module for packages that has all the things you could define, except they are just wrong.
22:12:15 <edwardk> applicative_: (??) exists because I was beseiged with requests from people for flipped versions of just about every lens combinator.
22:12:21 <edwardk> :t set
22:12:22 <lambdabot> ASetter s t a b -> b -> s -> t
22:12:27 <cmccann> lispy: good idea
22:12:42 <shachaf> lens forces a way of life on you.
22:12:43 <applicative_> edwardk: yes, I'm much in favor of it
22:12:49 <lispy> import Prelude.Nope to get all the partial functions
22:12:50 <shachaf> Some people don't yet appreciated this way of life.
22:12:50 <cmccann> (??) isn't even a good name for that function, meh.
22:12:55 <shachaf> It will pass.
22:13:02 <shachaf> s/ted/te/
22:13:04 <edwardk> @ty flip . set
22:13:05 <lambdabot> ASetter b c a1 a -> b -> a -> c
22:13:16 * applicative_ imports Control.Lens just to get (??), he keeps forgetting the lens combinators ;)
22:13:26 <edwardk> cmccann: you put the ?? in place of the operator it replaces when used for a binary function.
22:13:52 * ski . o O ( "A Setter stabs a BST" )
22:13:53 <edwardk> :t set _1 ?? foo $ baz    = set _1 baz foo
22:13:54 <shachaf> > (set _1 ?? (5,10)) "hello"
22:13:55 <lambdabot> parse error on input `='
22:13:56 <lambdabot>   ("hello",10)
22:14:00 <edwardk> er sans the :t
22:14:12 <cmccann> yes that was a convincing example :P
22:14:14 <edwardk> the ?? goes where the final arg gets put
22:14:33 <edwardk> > set _1 ?? (1,2) $ 3
22:14:33 <elliott> > [succ, pred, id] ?? 123
22:14:34 <lambdabot>   can't find file: L.hs
22:14:34 <lambdabot>   (3,2)
22:14:37 <elliott> cmccann: you know it's cool.
22:14:38 <elliott> > [succ, pred, id] ?? 123
22:14:40 <lambdabot>   [124,122,123]
22:14:40 <edwardk> > set _1 3 (1,2)
22:14:42 <lambdabot>   (3,2)
22:14:55 <mkscrg> hi all. i find myself looking for a library function that's "like <$> but composition". e.g. (\f g -> return . g <=< f) is this not a common one?
22:15:03 <edwardk> the ?? was chosen so it would look 'kind of like a hole'
22:15:12 <edwardk> (the original choice of ? would have been more obvious)
22:15:17 <cmccann> yeah I get the idea
22:15:19 <lispy> ?pl \f g -> return . g <=< f
22:15:19 <lambdabot> (line 1, column 24):
22:15:20 <lambdabot> unexpected "f"
22:15:20 <lambdabot> expecting space
22:15:20 <lambdabot> ambiguous use of a left associative operator
22:15:22 <shachaf> @ty (\f g -> return . g <=< f) -- who cares about the implementation -- what's the type?
22:15:24 <lambdabot> Monad m => (a -> m b) -> (b -> c) -> a -> m c
22:15:30 <applicative_> @type (\f g -> return . g <=< f)
22:15:31 <cmccann> just don't really see the appeal
22:15:32 <lambdabot> Monad m => (a -> m b) -> (b -> c) -> a -> m c
22:16:09 <applicative_> @pl let op f g  =  return . g <=< f)
22:16:10 <lambdabot> (line 1, column 31):
22:16:10 <lambdabot> unexpected "f"
22:16:10 <lambdabot> expecting space
22:16:10 <lambdabot> ambiguous use of a left associative operator
22:16:12 <edwardk> we had literally a dozen people come in channel asking if some operator could be flipped around to support some niche usecase.
22:16:14 <applicative_> blah
22:16:26 <edwardk> the (??) thing means we take one name, not 50
22:16:27 <ski> @type (^>>)
22:16:29 <lambdabot> Arrow a => (b -> c) -> a c d -> a b d
22:16:34 <cmccann> edwardk: right yes I see the appeal of getting people to stop demanding stuff I don't see the appeal of
22:16:40 <applicative_> well obviously .~ and ~., ^. and .^ and so on
22:16:53 <edwardk> cmccann: =P
22:17:49 <ski> @type (runKleisli .) . (. Kleisli) . (^>>)
22:17:50 <lambdabot> Monad m => (a -> a1) -> (a1 -> m b) -> a -> m b
22:18:00 <applicative_> it surprises me that the simple (??) = flip never occurred to anyone before
22:18:25 <cmccann> anyway I use my (??) a lot more often than I'd want the lens one so bah
22:18:27 <applicative_> or (?) = flip or whatever; it's too excellent.
22:18:46 <applicative_> what is your '??' ?
22:18:54 <cmccann> applicative_: flip fromMaybe
22:19:01 <ski> applicative_ : well, i've used `flip' infix before, if it counts ..
22:19:09 <applicative_> @type flip fromMaybe
22:19:10 <lambdabot> Maybe c -> c -> c
22:19:16 <cmccann> applicative_: so x ?? y = x if Just, y otherwise
22:19:27 <applicative_> hm, yes
22:19:31 <cmccann> i.e. for supplying a default value with a Maybe
22:19:33 <tikhonjelvis> it's like C#'s null-coalescing operator
22:19:37 <ski> @type runContT `flip` return
22:19:38 <lambdabot> Monad m => ContT r m r -> m r
22:19:40 <cmccann> tikhonjelvis: hence the name, yes
22:19:43 <tikhonjelvis> I may not have spelled that correctly
22:19:47 <applicative_> ski, me too, it's just the ?? or ? that was inspired
22:19:51 <mkscrg> @ski nice, thanks. time to go deeper on arrows i guess
22:19:51 <lambdabot> Maybe you meant: ask src wiki
22:19:53 <tikhonjelvis> I've always thought it was a very intimidating name for a very simple concept
22:19:54 <ski> @type (`runContT` return)  -- aka
22:19:55 <lambdabot> Monad m => ContT r m r -> m r
22:20:03 <ski> applicative_ : ok
22:20:24 <tikhonjelvis> erm, what exactly is the appeal of (??) for flip?
22:20:35 <otters> it's like a placeholder
22:20:42 <otters> f ?? x $ y == f y x
22:20:49 <tikhonjelvis> ah
22:20:54 <tikhonjelvis> yeah, with $ is makes sense
22:21:17 <shachaf> > (set _1 ?? (1,2)) 'x'
22:21:19 <lambdabot>   ('x',2)
22:21:24 <tikhonjelvis> there's no way to make an operator bind more tightly than function application in Haskell, is there?
22:21:34 <shachaf> There is not.
22:21:44 <shachaf> Though there are a couple of things that bind more tightly. But not operators.
22:21:53 <tikhonjelvis> I found it useful in my own language, but I guess it could be confusing
22:22:05 <cmccann> unless your operator is somehow based on record syntax probably not.
22:22:20 <tikhonjelvis> or module syntax?
22:23:03 <shachaf> Module syntax?
22:23:10 <shachaf> Oh, you mean Foo.bar?
22:23:16 <tikhonjelvis> yes
22:23:20 <shachaf> I think of that as one identifier, not really precedence.
22:23:30 <tikhonjelvis> I've always found the difference between Foo.bar and Foo . bar annoying
22:23:36 <lispy> > Prelude. map (+1) [1..3]
22:23:37 <lambdabot>   Not in scope: data constructor `Prelude'
22:23:42 <shachaf> That's because it is annoying.
22:23:52 <tikhonjelvis> yes
22:24:22 <tikhonjelvis> happily, I have it set up to look like Foo.bar and Foo âˆ˜ bar, so the difference is more obvious
22:25:06 <shachaf> What do you do for lens composition?
22:25:32 <tikhonjelvis> right now I just surround that with spaces too
22:25:48 <tikhonjelvis> but I haven't used lenses enough to care much one way or the other
22:25:49 <shachaf> Ah, the heuristic is just whether there are spaces around it?
22:25:53 <tikhonjelvis> yes
22:26:00 <tikhonjelvis> it's just the default haskell-mode thing
22:26:05 <cmccann> edwardk: you should rename ?? to __ and tell people to use backticks. that looks more like a blank space and is clearly superior.
22:26:15 <tikhonjelvis> `__`
22:26:28 <tikhonjelvis> like an ant smiley face or something
22:26:32 <otters> we should go the emoticon route
22:26:34 <otters> *_*
22:26:34 <kludgy> Hi would anyone happen to have experience getting gloss-examples installed on Windows, haskell platform 2012.4?  I get into dependency hell on Windows, but not on debian for what is presumably the same haskell platform version.
22:26:43 <lispy> yeah, but what about people that define let __ = undefined
22:26:54 <tikhonjelvis> let âŠ¥ = undefined
22:27:07 <cmccann> I think that needs to be (âŠ¥)
22:27:11 <lispy> tikhonjelvis: show off ;)
22:27:12 <tikhonjelvis> yeah, probably
22:27:17 <otters> "I love you"; "from the heart of my âŠ¥"
22:27:30 <shachaf> > over (partsOf (each.both.each)) reverse [("lenses","prisms"),("traversals","folds")]
22:27:32 <lambdabot>   [("sdlofs","lasrev"),("artsmsirps","esnel")]
22:28:29 <tikhonjelvis> that and âˆž are punctuation symbols :(
22:28:42 <shachaf> What would you make âˆž be anyway?
22:28:49 <tikhonjelvis> 1/0
22:28:50 <lispy> maxBound
22:29:06 <tikhonjelvis> because we don't have a literal Infinity
22:29:06 <lispy> [1 .. âˆž]
22:29:07 <cmccann> speaking of which, why doesn't Float have a Bounded instance?
22:29:08 <shachaf> Ugh.
22:29:27 <tikhonjelvis> or maybe let (âˆž) = succ (âˆž)
22:29:30 <ski> the other day i was pondering a syntax for record selector functions, where you write `book # author' instead of `author book', and where `action # runState s' parses as `(action # runState) s' (and using a section `(# author)' would give you the selector function itself)
22:30:04 <tikhonjelvis> that's sort of what I did for my own language
22:30:28 <ski> (`#' would be special syntax, like `@' -- perhaps you'd prefer a different symbol. i just used `#' because of `#author' in SML for field accessor functions)
22:30:57 <tikhonjelvis> wouldn't it be enough to add a new precedence level tighter than function application?
22:30:58 <shachaf> ski: If author is a lens, # is ^. !
22:30:58 <ski> this would be nice to use together with message-dispatching syntax
22:31:30 <cmccann> anyway, personally I use (â˜ƒ) = undefined
22:31:51 <shachaf> cmccann: I thought you used (â˜ƒ) = unsafeCoerce.
22:31:52 <tikhonjelvis> I just have undefined look like âŠ¥ in the same way as . looks like âˆ˜
22:32:06 <tikhonjelvis> this even lets me get away with Î» for \
22:32:09 <johnw> you live in a world of snowmen with undefined behavior?  hmm
22:32:15 <ski> (because the name of the thing to be defined would occur as the first thing in the definition clause)
22:32:20 <johnw> for me, snowmen are extremely well-defined
22:32:21 <cmccann> shachaf: oh hm that's right, I think I did.
22:32:25 <tikhonjelvis> ooh, I want to do id = unsafeCoerce :)
22:32:32 <tikhonjelvis> living on the edge, so to speak
22:32:38 <shachaf> Someone should implement the (\x\y\z x z (y z)) lambda syntax.
22:32:43 <shachaf> That's obviously better than having an arrow.
22:32:44 <tikhonjelvis> after all, id is just unsafeCoerce with the type specialized
22:33:09 <ski> shachaf : why not `x\ y\ z\ x z (y z)' ?
22:33:27 <applicative_> the arrow is revolting. \x y z . x z (y z) -- whats wrong with that, except suddenly . is stolen
22:33:28 <shachaf> ski: Seems a bit bizarre. Why \ after the pattern?
22:33:33 <ski> (aka "why you hate lambdaProlog ?")
22:33:39 <cmccann> we should just use Î» for lambdas, because clearly nobody would use it as an actual letter or anything.
22:34:14 <tikhonjelvis> Whenever I implement the Î» calculus, I always want to use Î» as a constructor
22:34:17 <ski> applicative_ : `â†¦'
22:34:19 <johnw> cmccann: and then the greek Haskell users would hunt you down
22:34:21 <tikhonjelvis> but I'm forced to do Î› instead :(
22:34:30 <tikhonjelvis> that's a good case for the tagless approach, right there
22:34:32 <applicative_> well, or if they want use 'Î»' as a Char they have to do {-##LANGUAGE Greek-}
22:34:40 <applicative_> well, or if they want use 'Î»' as a Char they have to do {-#LANGUAGE Greek#-}
22:34:50 <cmccann> applicative_: currently (\x . foo) is a parse error so I'm not sure it'd actual be ambiguous to use . there
22:35:09 <applicative_> I was inventing a new language
22:35:18 <applicative_> same as the old language
22:35:21 <shachaf> Why not! (.) has already been stolen by a few other extensions.
22:35:26 <cmccann> yes.
22:35:28 <tikhonjelvis> and the module system
22:35:36 <cmccann> abuse (.) more, it is used to it.
22:35:58 <shachaf> "." for forall is kind of silly.
22:36:08 <johnw> it used to amuse me that "point"-free notation has a lot more (.) in it
22:36:09 <applicative_> the real menace is that unicode non-breaking space cant be an operator.
22:36:10 <shachaf> But a good precedent for more abuse, I suppose.
22:36:14 <tikhonjelvis> maybe we should just pull an Agda and force everyone to use special Unicode symbols
22:36:14 <cmccann> "." not for lambdas is kind of silly.
22:36:22 <tikhonjelvis> then . can be in the language and âˆ˜ can be composition
22:36:34 <cmccann> applicative_: or other unicode whitespace.
22:36:36 <shachaf> Â· for composition!
22:36:51 <cmccann> did you know there's a code point for "whitespace meaning multiplication"?
22:36:55 <tikhonjelvis> Â· for monoids, maybe
22:36:56 <shachaf> Yes!
22:37:00 <applicative_> hah, oh really
22:37:09 <cmccann> applicative_: it's a lexical error in Haskell sadly.
22:37:10 <tikhonjelvis> see, that's actually perfect
22:37:13 <shachaf> @quote INVISIBLE.TIMES
22:37:13 <lambdabot> No quotes match. Are you on drugs?
22:37:16 <shachaf> Hmm, wrong channel.
22:37:30 <tikhonjelvis> well, come to think of it, you can make a Num instance for functions
22:37:32 <ski> a slightly related idea is to let `<expr 0> @\ <expr-pat> -> <expr 1>' desugar to `<expr 0> <expr-pat> (\ <expr-pat> -> <expr 1>)' -- for those pesky `blah x (\x -> ...)' things
22:37:32 <tikhonjelvis> and do 2x
22:37:38 <shachaf> <fizzie> "May you live in INVISIBLE TIMES." --Old Chinese proverb. (It can look confusing when written with the proper Unicode.)
22:37:45 <applicative_> what about a character for immediate juxtaposition meaning multiplication x(yz)
22:37:48 <ski> (or `$\' instead of `@\', mayhaps)
22:38:13 <shachaf> cmccann: There is also one for function application and for plus.
22:38:18 <ski> (where `<expr-pat>' should both be valid as an expression and as a pattern)
22:38:22 <shachaf> And there's INVISIBLE SEPARATOR. For, uh, separating things.
22:38:33 <Nisstyre-laptop> what about â‹† for monoids?
22:38:50 <cmccann> shachaf: separating them without visible separation, of course.
22:39:04 <tikhonjelvis> Nisstyre-laptop: it would be a nice symbol for them
22:39:05 <applicative_> <> is fine. I demand that o i and e together replace mempty
22:39:09 <ski> Nisstyre-laptop : not for the kind of concrete types ?
22:39:34 <tikhonjelvis> or how about making 0 and 1 special
22:39:42 <tikhonjelvis> so that we could use them beyond just Num
22:40:00 <tikhonjelvis> for like semi-rings and stuff
22:40:16 <applicative_> I wonder if that has occurred to anyone
22:40:21 <shachaf> Unfortunately many Nums aren't semirings!
22:40:22 <applicative_> I mean before
22:40:45 <shachaf> That comes as part of a Num hierarchy reÃ¶rganization.
22:40:49 <shachaf> I.e., that doesn't come.
22:40:54 <tikhonjelvis> right
22:41:07 <tikhonjelvis> one day!
22:41:24 <tikhonjelvis> but yeah, there are plenty of things that form semi-rings without being too much like numbers
22:41:32 <tikhonjelvis> e.g. where fromInteger wouldn't really make sense
22:41:54 <shachaf> It's not so bad for 0 to be a different type from 5.
22:42:02 <shachaf> I mean, it's already a different type from 0.0
22:42:19 <shachaf> (Unless you use http://hackage.haskell.org/trac/ghc/ticket/7266 !)
22:42:41 <shachaf> Assuming that class is a superclass of Num, of course.
22:43:01 <shachaf> My favourite class in the Num hierarchy is Real, of course.
22:43:03 <shachaf> @src Real
22:43:03 <lambdabot> class  (Num a, Ord a) => Real a  where
22:43:04 <lambdabot>     toRational      ::  a -> Rational
22:43:08 <tikhonjelvis> that's also how it works with CSS units: 0 is special
22:43:33 <tikhonjelvis> e.g. you don't have to specify whether it's 0px or 0em
22:43:40 <tikhonjelvis> maybe I've been doing too much CSS lately :/
22:43:45 <cmccann> shachaf: what, you don't think Real is the right name for "types that are subsets of the rational numbers"?
22:43:46 <shachaf> 0 celsius or 0 fahrenheit
22:44:06 <tikhonjelvis> CSS does not support temperature at the moment :P
22:44:26 <shachaf> It'll happen!
22:44:39 <shachaf> I bet some phones already have both thermometers and browsers in them.
22:45:07 <tikhonjelvis> with CSS, it'd have to be the opposite: you'd have to be able to affect the temperature, not read it
22:45:11 <shachaf> Mine has a barometer.
22:46:30 <cmccann> btw, U+2062 is the code point for INVISIBLE TIMES if anyone was wondering
22:46:42 <c_wraith> I don't even know what INVISIBLE TIMES means
22:47:00 <tikhonjelvis> exactly what it says on the tin
22:47:03 <cmccann> it's the code point for the multiplication operator that you don't write.
22:47:06 <shachaf> cmccann: It's a juxtaposition operator that hints that two things are being multiplied.
22:47:06 <tikhonjelvis> Ã— that's invisible
22:47:20 <cmccann> like the "" in "5y" that means multiplication.
22:47:32 <shachaf> > length "5y"
22:47:33 <lambdabot>   2
22:47:35 <shachaf> cmccann: Disappointing.
22:47:36 <ski> where is the invisible composition operator ?
22:47:44 <cmccann> hahaha
22:47:47 <ski> (not to mention the invisible application operator)
22:47:48 <lispy> "WHERE IS YOUR INVISIBLE TIMES NOW??"
22:48:17 <shachaf> 29D4   TIMES WITH LEFT HALF BLACK     [â§”]
22:48:24 <tikhonjelvis> â¢> length ""
22:48:39 <shachaf> lambdabot's Unicode support is broken. :-(
22:48:40 <tikhonjelvis> > length "â¢"
22:48:41 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
22:48:47 <tikhonjelvis> yes
22:48:55 * hackagebot DrIFT-cabalized 2.2.4 - Program to derive type class instances  http://hackage.haskell.org/package/DrIFT-cabalized-2.2.4 (KiwamuOkabe)
22:48:58 <tikhonjelvis> 2â¢3
22:49:19 <shachaf> kappabot: > length "â¢"
22:49:31 <shachaf> Oh, right.
22:49:33 <shachaf> kappabot: @run length "â¢"
22:49:36 <kappabot>   mueval-core: Enum.toEnum{Word8}: tag (8290) is outside of bounds (0,255)
22:49:43 <shachaf> ?
22:49:45 <tikhonjelvis> woah
22:49:47 <shachaf> kappabot: @run 1
22:49:49 <kappabot>   1
22:49:54 <shachaf> kappabot: @run let Î± = 5 in Î±
22:49:55 <kappabot>   mueval-core: Enum.toEnum{Word8}: tag (945) is outside of bounds (0,255)
22:50:04 <shachaf> > let Î± = 5 in Î±
22:50:04 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
22:50:05 <kappabot>   mueval-core: Enum.toEnum{Word8}: tag (945) is outside of bounds (0,255)
22:50:10 <tikhonjelvis> I think it's not happy with Unicode either
22:50:17 <shachaf> It was, uh, working the other day.
22:50:23 <tikhonjelvis> of course
22:50:30 * shachaf sighs
22:50:32 <shachaf> lambdabot is such a mess
22:50:44 <lispy> shachaf: join the cause to make a better one
22:50:47 <cmccann> kappabot: length "5â¢y"
22:50:55 <cmccann> pf.
22:50:58 <shachaf> lispy: I complain about it a lot. Does that count?
22:51:07 <lispy> I don't want to run the new one here yet. It doesn't have proper sandboxing, AFAICT
22:51:09 <shachaf> kappabot: @run length "Î±"
22:51:10 <kappabot>   mueval-core: Enum.toEnum{Word8}: tag (945) is outside of bounds (0,255)
22:51:12 <shachaf> kappabot: @type length "Î±"
22:51:13 <kappabot> Int
22:51:17 <shachaf> lambdabot: @type length "Î±"
22:51:17 <lambdabot> fd:9: commitBuffer: invalid argument (invalid character)
22:51:17 <cmccann> > length "5â¢y"
22:51:18 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
22:51:18 <kappabot>   mueval-core: Enum.toEnum{Word8}: tag (8290) is outside of bounds (0,255)
22:51:26 <lispy> shachaf: lambdabot would be so pretty if it used lens internally.
22:51:26 <shachaf> OK, it least it can handle @type.
22:51:33 <tikhonjelvis> hmm, I could imagine doing some horrible and yet awesome things if we could use INVISIBLE TIMES for monoids
22:51:47 <shachaf> I, too, can imagine you doing some horrible things.
22:51:54 <shachaf> Fortunately we cannot.
22:52:05 <tikhonjelvis> time to hack together a preprocessor
22:52:11 <tikhonjelvis> that's what all the cool kids are doing anyhow
22:52:26 <shachaf> 205F   MEDIUM MATHEMATICAL SPACE     [âŸ]
22:52:38 <tikhonjelvis> oh, that's a fun character in a monospace font, no doubt
22:52:48 <shachaf> Unicode has such great characters.
22:52:52 <tikhonjelvis> just like â€“ vs â€”
22:52:58 <shachaf> Though this is getting a bit #-blahy.
22:53:01 <tikhonjelvis> can't tell the difference at all on my end
22:53:08 <shachaf> kappabot: @quit in shame
22:53:19 <tikhonjelvis> using unicode to make Haskell code prettier is certainly on topic
22:53:24 <nicoo> tikhonjelvis: In â€œâ€“ vs â€”â€ I actually see a difference
22:53:24 <shachaf> The other day kappabot would show a quit message, too.
22:53:42 <tikhonjelvis> all I want is invisible monoid operators in the middle of things that look like long identifiers
22:53:48 <cmccann> tikhonjelvis: here you go "xâ¢y = mappend x y"
22:53:52 <cmccann> sadly it doesn't work
22:54:08 <mauke> shachaf: how long had it been online before?
22:54:22 <tikhonjelvis> it would make some of the code I'm working on right now look closer to the documentation I'm basing it on
22:54:51 <shachaf> mauke: kappabot? I'm not sure. More than a few minutes and less than a few days. Why?
22:54:51 <cmccann> wow, GHC doesn't even like INVISIBLE TIMES being in a string literal.
22:54:54 <cmccann> lame.
22:55:03 <tikhonjelvis> interesting
22:55:37 <mauke> shachaf: because freenode may block quit messages if you just connect and disconnect shortly after
22:55:44 <cmccann> tikhonjelvis: "â¢" if you want to try
22:55:48 <shachaf> mauke: Oh, quit messages, right.
22:55:53 <shachaf> mauke: I thought you meant the Unicode.
22:55:55 <tikhonjelvis> I memorized its number :P
22:55:59 <cmccann> heh
22:56:20 <cmccann> tikhonjelvis: there's also U+2064.
22:56:24 <tikhonjelvis> although switching between TeX and ucs mode is a bit annoying
22:56:29 <cmccann> which is INVISIBLE PLUS.
22:56:39 <tikhonjelvis> hmm
22:56:44 <shachaf> GHC's Char supports '\xD800' :-(
22:56:51 <tikhonjelvis> unicode should totally just have a combining character for making anything invisible
22:56:59 <cmccann> hahaha yes good
22:57:04 <tikhonjelvis> although GHC's support for combining characters also sucks
22:57:08 <mauke> http://mauke.hopto.org/stuff/javascript/unicode.html?q=invisible
22:57:33 <tikhonjelvis> as I learned when I wanted to use âŒ£Ìˆ as an operator
22:57:46 <mauke> ãƒ„
22:57:54 <c_wraith> that's a letter, not a symbol
22:57:56 <shachaf> mauke: There are also
22:57:57 <shachaf> 2060   WORD JOINER     [<U+2060>]
22:57:57 <shachaf> 2061   FUNCTION APPLICATION     [<U+2061>]
22:59:32 <evincar> I think I'm looking for some kind of backtracking monad...
23:00:15 <evincar> In a tree structure, allowing a subtree to say "revisit me, but replace me with all of these several possibilities".
23:00:47 <evincar> And, for instance, choose whichever one "works" (using Alternative or some such).
23:01:07 <evincar> Ringing any bells?
23:02:14 <evincar> It could be hacked with Parsec, but. :/
23:04:30 <ski> tell us more ?
23:07:19 <evincar> Well, it stemmed from a practical problem in a compiler, but now I'm just curious.
23:07:52 <evincar> When typechecking a program with overloaded functions, I want to choose the unique overload that typechecks.
23:08:33 <evincar> It'd be nice if I could say "go up a scope and try all possible overloads of the terms in that scope".
23:08:53 <evincar> Discarding the ones that fail, and reporting an ambiguity if there's ultimately more than one success.
23:09:38 <evincar> Suppose I could use continuations to refer up the call stack, as it were.
23:10:11 <c_wraith> it seems like you could restructure the logic, such that things return a list of matches
23:10:32 <c_wraith> That has potential combinatorial explosions, of course
23:10:39 <c_wraith> But I think anything doing this does
23:11:21 <evincar> Yeah, what I have now is a list of possibilities at the call sites of overloaded functions.
23:11:24 <evincar> That just gets culled.
23:11:43 <evincar> But I was thinking it might be prettier to talk about it sort of inside-out.
23:12:12 <evincar> Just some food for thought. :)
23:12:16 <c_wraith> dunno. Doesn't seem prettier if you have to replace your current node of the parse tree with a bunch of alternatives
23:13:07 <ski> not sure where the "inside-out" bit enters (though it sounds like something continuations could be useful for)
23:15:26 <evincar> Instead of having expressions of sets of possibilities and just culling the sets,
23:15:38 <evincar> you transform expressions of sets of possibilities into sets of expressions of possibilities.
23:15:56 <evincar> So all calls become non-overloaded, you just now have a bunch of expressions. :P
23:16:10 <evincar> It's hard to talk about succinctly...
23:17:28 <ski> > liftM2 (++) ["fooA ","fooB "] ["barA","barB","barC"]
23:17:29 <lambdabot>   ["fooA barA","fooA barB","fooA barC","fooB barA","fooB barB","fooB barC"]
23:18:07 <dolio> I think it's just having non-determinism in your type checking monad, so to speak.
23:18:19 <dolio> Which could be done in a lot of ways.
23:18:23 <dav> is there a good indenter that people recommand?
23:19:12 <johnw> dav: just the TAB key in, say, Emacs
23:19:29 <dav> johnw: I'm afraid I use vim
23:19:39 <pqmodn> tab key in vim works too
23:19:46 <johnw> there is no command-line pretty printer for whole Haskell programs, I'm afraid
23:19:48 <dav> good point
23:19:55 <dav> johnw: that's too bad :(
23:19:56 <dolio> I'm working on better indenting for vim.
23:20:18 <dav> dolio: that's good to hear. do you own one of the vim haskell modes?
23:20:24 <dolio> No.
23:21:02 <dolio> Just running a program and getting indented code isn't going to work, though, unless you don't use any layout in the first place.
23:21:33 <dolio> Because it'd have to be appropriately indented already to get the right parse for it to be indented.
23:21:41 <dolio> You could only switch between styles.
23:21:54 <dav> dolio: I'd love to have something that fixes style
23:22:09 <dav> dolio: especially given that I'm a beginner and I don't know what's the recommanded style..
23:24:10 <dolio> There's no one style that everyone agrees on, really. There are several.
23:24:11 <ski> you shouldn't use any actual tab chars for indenting, unless you *only* use tab chars for indenting, and also break line after layout-introducing keywords followed by multi-line blocks
23:24:30 <dolio> Yeah, beyond not using tabs.
23:24:38 <ski> most people don't bother with tabs
23:25:05 <dolio> I guess not everyone even agrees on not using tabs, really.
23:28:37 <blackdog> every time i have to import Control.Applicative it makes me a little sad inside
23:29:00 <ski> several people like putting type signatures on most top-level declarations
23:29:07 <ski> @wiki Type signatures as good style
23:29:07 <lambdabot> http://www.haskell.org/haskellwiki/Type_signatures_as_good_style
23:29:12 <blackdog> feels like that incantation you do in perl that amounts to "please give me a sane language"
23:29:26 <tikhonjelvis> "use strict"?
23:29:49 <ski> also i think "declaration style" is usually more readable than "expression style", when there's a choice
23:29:49 <edwardk> blackdog: likewise
23:29:52 <dav> lol
23:29:59 <blackdog> tikhonjelvis: there's a bunch more than "use strict"
23:30:00 <ski> @wiki Declaration vs. expression style
23:30:00 <lambdabot> http://www.haskell.org/haskellwiki/Declaration_vs._expression_style
23:30:25 <blackdog> use warnings, for instance. and then something for using Moose, i think? mercifully forgotten now.
23:30:50 <ski> dav ^
23:30:54 <tikhonjelvis> Bah, I never used warnings in Perl. I also avoided objects most of the time.
23:31:10 <dav> ski: you mean this link was for me?
23:31:16 <ski> yes, both of them
23:31:17 <tikhonjelvis> but yeah, I think Control.Applicative is my main import too
23:31:23 <blackdog> tikhonjelvis: i wasn't smart enough to write perl without all the help i could get :)
23:31:38 <tikhonjelvis> also Data.List, Data.Maybe and Control.Monad
23:31:49 <tikhonjelvis> but that probably says more about my programming style than about those modules
23:32:06 <dav> ski: thanks!
23:32:53 <blackdog> tikhonjelvis: it's funny, there's a bunch of stuff you don't particularly want in the prelude (like lines, lookup) and a bunch of stuff you really wish was there like Applicative
23:33:12 <blackdog> still, this is in "milla jovovich has ugly feet" territory.
23:33:16 <ski> dav : i usually use two-space indentation steps (except when i want to align something)
23:33:23 <tikhonjelvis> amusingly, I actually use lines quite often :P
23:33:35 <otters> same
23:33:37 <otters> and lookup
23:34:29 <blackdog> tikhonjelvis: i use it a lot, but usually the version in bytestring.
23:34:35 <ski> dav : if i'm finding my definiens drifting towards the right margin, i sometimes lift all (or most) of it to line(s) following the definiendum :
23:34:35 <tikhonjelvis> ah yes
23:34:40 <ski>   foo = ...
23:34:43 <blackdog> which means "import Prelude hiding( ...)" dances. or prefixing everything.
23:34:43 <ski>         ...
23:34:45 <ski> becomes
23:34:50 <ski>   foo =
23:34:52 <tikhonjelvis> that's one of the things that annoys me about the Prelude: insufficiently polymorphic
23:34:54 <ski>     ...
23:34:54 <ski>     ...
23:35:03 <tikhonjelvis> every time I use genericLength, I die a little inside
23:35:05 <ski> or sometimes
23:35:09 <ski>   foo = blah
23:35:11 <ski>     ...
23:35:11 <blackdog> tikhonjelvis: the classy prelude was meant to fix that to some extent
23:35:12 <ski>     ...
23:35:26 <dav> I hear ya
23:35:26 <tikhonjelvis> I've heard bad things about it though
23:35:31 <dav> I'm also trying http://www.haskell.org/haskellwiki/Indent#Use_Language.Haskell
23:35:37 <dolio> No, classy prelude does not fix that.
23:35:44 <ski> where `blah' is commonly of shape `frob . mumble $ \x ->', or `case bork of' or somesuch
23:35:49 <dolio> It explicitly does not fix it.
23:35:55 <dav> seems to run, but it's not all that pretty. it might be a good first pass..
23:36:06 <blackdog> dolio: doesn't it? huh. perhaps i got my wires crossed: what does it do?
23:36:24 <dolio> It overloads length differently for each container type.
23:36:28 <dolio> Or whatever.
23:36:41 <dolio> But it length of a list is always an Int still.
23:36:50 <dolio> There's a fundep enforcing it.
23:37:14 <blackdog> dolio: oh - i meant insufficiently polymorphic, not the genericLength thing.
23:37:46 <ski> many people seem to have `where' trailing on a line, with following block on the next line -- i typically do it like
23:37:51 <ski>   ...
23:37:53 <ski>     where
23:37:58 <ski>     ...
23:38:00 <johnw> same here
23:38:05 <ski> instead (even for `module')
23:38:12 <johnw> where at the end of a line makes for more compact slides, though
23:38:17 <dolio> I do one space wheres.
23:41:30 <ski> dav : also, when breaking tuples and lists and record constructions/updates (and record constructor specifications) over several lines, i tend to put `,' at the front instead of at the end
23:41:50 <ski> (also for module import and export lists)
23:42:13 <ski>   module Foo
23:42:18 <ski>     ( blah :: ...
23:42:24 <ski>     , ...
23:42:27 <ski>     ) where
23:42:38 <ski>   import Bar
23:42:45 <ski>   blah :: ...
23:42:49 <ski>   blah x = ..x..
23:43:39 <ski> (er, except that all lines from the `import' line is indented two spaces (except if i comment out code))
23:49:23 <otters> you indent entire modules?
23:53:37 <gaze__> hey, how do I print out the structure of a template haskell Q [exp]
23:53:50 <gaze__> since apparently it isn't an instance of Show
23:53:56 * hackagebot hse-cpp 0.1 - Preprocess+parse haskell code  http://hackage.haskell.org/package/hse-cpp-0.1 (RomanCheplyaka)
23:54:20 <otters> gaze__: haha, good luck
23:54:29 <shachaf> You run it, presumably, and then print that?
23:54:49 <otters> yeah maybe -ddump-splices?
23:54:57 <shachaf> otters: ?
23:55:12 <shachaf> @ty Language.Haskell.TH.runQ
23:55:13 <otters> splice it and see what dump-splices says?
23:55:13 <lambdabot> Language.Haskell.TH.Syntax.Quasi m => Language.Haskell.TH.Syntax.Q a -> m a
23:55:18 <otters> oh, or maybe not
23:55:32 <shachaf> gaze__: Q [Exp] isn't a list of expressions.
23:55:40 <shachaf> Just like getLine isn't a String.
23:55:41 <gaze__> ahhh right it's a monad!
23:55:54 <shachaf> Even if it wasn't a monad this idea would apply!
23:56:23 <gaze__> sorry, still coming from an imperative background
23:56:51 <tdammers> this isn't really related to imperative vs. functional
23:56:55 <shachaf> Being a monad doesn't really have to do with this. :-)
23:57:15 <shachaf> Well, I suppose in one sense it could be related...
23:57:15 <tdammers> Q [Exp] is a Q of a list of Exp's, which is not the same as just a list of Exp's.
23:57:36 <tdammers> well, yes, it is related, but not in a way that matters a lot right now
23:57:37 <shachaf> What are you using TH for?
23:57:37 <ski> otters : yes
23:57:41 <gaze__> yeah I mean I just think of every type as some datastructure.
23:57:52 <gaze__> which is wrong here
23:58:33 <gaze__> I want to do reflection on a record that the user provides
23:58:44 <gaze__> I've already done it using data.typable
23:59:03 <gaze__> well, a very limited class of records
23:59:03 <edwardk> > (1,2) & upon snd  .~ 3
23:59:05 <lambdabot>   (1,3)
23:59:16 <tdammers> Q<List<Exp>> is not the same as Q<Exp>, in Java-ish terms
23:59:21 <tdammers> eh, I mean
23:59:26 <tdammers> Q<List<Exp>> is not the same as List<Exp>, in Java-ish terms
