00:00:10 <hrookie> Aetherspawn_: fusing two sources how? what are you trying to accomplish?
00:00:21 <hrookie> johnw: looking into it now - thanks! this looks like just what i'm after~~
00:00:24 <Aetherspawn_> I have a TMChan which I turn into a source through a helper
00:00:30 <Aetherspawn_> and a network-conduit
00:00:56 <hrookie> Aetherspawn_: ah. i never got through to cereal and network :-P
00:01:02 <Aetherspawn_> I want to fuse the tmchan producing (plus a helper translator) and the network one (plus a helper handler) to the same socket output
00:01:58 <hrookie> are they running in the same thread?
00:03:24 <Aetherspawn_> hrookie, yes
00:03:49 <Aetherspawn_> Well, the TMChan is duplicated from a broadcasting one, so it recieves new items ocassionally
00:04:25 <Aetherspawn_> One solution was to wait for the network conduit to be reached and then empty the TChan, but that disadvantage of that is that a packet has to come in before the TChan gets emptied
00:04:40 <Aetherspawn_> thus giving the channel a medium induced latency it doesn't need to have..
00:05:26 <hrookie> yeah. hmmm... well, i'm not quite sure, perhaps someone else with more conduit experience knows? =\ (as my name suggests, i'm a rookie :D)
00:06:37 <dmwit> What's in a name?
00:07:13 <johnw> dmwit: letters, sometimes punctuation
00:07:37 <dmwit> The artist formerly known as Prince might have a word to say about that. =P
00:07:46 <johnw> in his name in Unicode yet?
00:07:57 <dmwit> don't think so
00:09:01 <Hafydd> Also anybody whose name is in a language that lacks a writing system.
00:09:26 <johnw> I could change my name to â˜ƒ
00:09:45 <hrookie> I don't see what all the fuss is about. I mean, that which we call a rose by any other name would smell as sweet.
00:09:58 <Hafydd> The user formerly known as johnw.
00:10:27 <johnw> exactly
00:22:32 * hackagebot certificate 1.3.8 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-1.3.8 (VincentHanquez)
00:33:25 <hrookie> johnw: do you use hdevtools with extensions? mine just yells about -XDeriveGeneric, which i definitely use at compile time xD
00:33:53 <johnw> you'll need to make check -g -XDeriveGeneric ...
00:34:01 <johnw> s/make/pass
00:35:26 <hrookie> hm. i will just go through a more extensive tutorial later >.> :-P
00:41:41 <augur> ski: :O
00:42:09 <hrookie> not gonna lie, auto-paren-close sounds great in theory, but i always find it to be awful in practice
01:37:17 <dv-> drawLine :: Integer -> Integer -> Int -> t -> Update (). what's the meaning of 't' here?
01:37:27 <mauke> it's a variable
01:37:50 <mauke> and unless this is from a class definition, I don't think this makes sense
01:38:09 <typoclass> dv-: it's a type variable. in this case it can stand for any type
01:38:37 <dv-> is this a recent thing? i've never seen it written like that before
01:38:42 <mauke> ???
01:38:45 <shachaf> "any" as in caller-chooses.
01:38:53 <shachaf> But listen to mauke.
01:38:58 <mauke> dv-: this is #haskell
01:39:17 <typoclass> dv-: if you had for example "drawLine :: (Num t) => ... -> t -> Update ()", then it'd be constrained to "any t for which we have an instance of typeclass Num". but in your case it's not constrained
01:39:20 <pqmodn> dv-: it's shorthand for "forall t. Integer -> Integer -> Int -> t -> Update ()"
01:39:36 <dv-> oh right
01:39:37 <typoclass> dv-: no, it's not recent. it's been part of haskell since pretty much always
01:40:12 <shachaf> typoclass: Note that that type is not very useful.
01:40:33 <typoclass> shachaf: yes it's weird. who knows what that is
01:40:54 <shachaf> I mean, with the Num constraint you added.
01:40:56 <dv-> it used to be 'a' i think
01:41:20 <Shou> dv-, it can be anything
01:41:32 <Shou> as long as it's lower capitalisation
01:47:47 <SrPx> Is it possible to program the GPU with Haskell? What is used?
01:48:00 <SrPx> Note: just reading a paper about obsidian
01:49:21 <vazakl> greeting yall
01:49:27 <typoclass> vazakl: hello
01:51:02 <Cale> SrPx: http://hackage.haskell.org/package/accelerate
01:51:14 <Taneb> Is newtype Bikleisli w m a b = Bikleisli (w a -> m b) a Category for comonad w and monad b?
01:51:18 <SrPx> vazakl: hello
01:51:26 <SrPx> Cale: thanks
01:51:32 <edwardk> Taneb: you need a distributive law for w over m
01:51:37 <edwardk> Taneb: at which point, yes
01:51:54 <Taneb> Distributive law?
01:52:04 <edwardk> Taneb: its also pretty horrible performance wise in practice
01:52:14 <edwardk> Taneb: sigfpe has an article on using it
01:52:43 <edwardk> uustalu and vene also concocted it in 'the essence of the iterator pattern'
01:53:19 <edwardk> my personal preference is to rather work with comonads over some base kleisli category or monads over a cokleisli category, which gives you that same signature for the arrows, but very different semantics
01:54:56 <johnw> Taneb: I think he means you need some w (m a) -> m (w a)
01:56:25 <edwardk> Taneb: by distributive law you need o turn w (m a) -> m (w a) for it to work. http://blog.sigfpe.com/2008/03/transforming-comonad-with-monad.html
01:56:37 <Taneb> Thanks
01:57:34 * hackagebot strings 1.1 - Functions for working with strings, including Text, ByteString, etc.  http://hackage.haskell.org/package/strings-1.1 (JulianFleischer)
01:57:59 <edwardk> Taneb: you can alternatively do the monad (comonad) over a cokleisli (kleisli) category construction, which gives you the same signature, but where you don't wind up duplicating monadic calculations over and over and over and can actually get some sharing
02:14:39 <bad_alloc> Hi, I'm trying to pass an empty list to a function that expects a list of a certain type, however this fails, as shown here: http://cxg.de/_f22e3c.htm. Is it actually possible pass the empty list?
02:15:20 <mauke> the function doesn't expect a list
02:15:29 <mauke> it expects a BinTree
02:15:40 <ChongLi> and splitleftmost is just calling itself
02:17:42 <typoclass> bad_alloc: hello. in haskell, a BinTree is different from list of BinTrees ('Bintree a' vs. '[Bintree a]'). note that your error message refers to splitleftmost, not to splitleftmost'
02:17:52 <bad_alloc> ChongLi: Ah, that might be the issue. Thanks for pointing that out.
02:18:03 * bad_alloc seems to need glasses
02:18:21 <mauke> * is your friend (in vim)
02:18:30 <mauke> together with hlsearch
02:18:34 <ChongLi> what is splitleftmost supposed to do?
02:18:54 <ChongLi> cause this seems suspiciously like a good case for lens
02:19:53 <bad_alloc> ChongLi: I'm supposed to write an end-recursive function that takes a binary tree and returns a tuple (a, BinTree a), where fst is the leftmost leaf and snd is the rest of the tree without fst.
02:20:19 <ChongLi> ahh, okay
02:20:24 <ChongLi> so this is an assignment
02:20:33 <ChongLi> using lens would be cheating :)
02:20:34 <bad_alloc> ChongLi: yep.
02:23:57 <edwardk> bad_alloc: well, split your code into two cases. you are given a Node a (t:ts) or Node a [] what do you do for each?
02:24:13 <bad_alloc> ChongLi, typoclass: it works now, thanks again for mentioning the '
02:24:25 <ChongLi> glad to help :)
02:24:40 <edwardk> also consider what does it mean to return a tree without its left leaf when you have the base case (Node a []) ?
02:24:50 <ChongLi> I think he already had all the other code written
02:24:54 <edwardk> oh, BinTree, not Data.Tree tree
02:24:54 <valaris> Ugh...why am I not smart enough to learn haskell? :)  You guys amaze me.  Figure I'd hang in here and try and steal some knowledge.
02:24:55 <ChongLi> it was just that one typo
02:25:09 <edwardk> ChongLi: ah just found the link =)
02:25:34 <ChongLi> valaris: I think anyone's smart enough
02:25:40 <ChongLi> it just takes time
02:25:54 <ChongLi> you gotta keep re-molding your brain until it fits
02:26:02 <valaris> Well...I've been writing c++ for about 10 years now and other imperative languages...but yah...huge challenge so far for me :)
02:26:02 * typoclass purrs
02:26:04 <valaris> Interesting though!
02:26:08 <typoclass> ChongLi: if i fits i sits
02:26:23 <ChongLi> you should watch edward's video on lenses
02:26:27 <ChongLi> it's fantastic!
02:26:31 <bad_alloc> edwardk: It works: from a node (Node l a r) I set l to empty and store it an a accumulator list. Then, when I bottom out I've got my "a" and reconstruct the tree above from the accumulator list. It currently only fails for (Node Empty a Empty) Here's my (probably ugly) solution so far: http://cxg.de/_8f979c.htm
02:26:51 <ChongLi> http://youtu.be/cefnmjtAolY?hd=1
02:26:54 <edwardk> bad_alloc: k
02:28:05 <edwardk> valaris: it is definitely worth it to bull through the learning curve though. Haskell is the only language in the last 20 years or so to seriously challenge the way I think about programming.
02:28:27 <edwardk> I feel like I'm a much better programmer for having learned the language.
02:28:39 <valaris> Yah...its been seriously challenging me :)  I've been working through learnyouahaskell mostly.
02:28:50 <ChongLi> I think what really helped me to learn things like Functors, Applicatives, Monoids and Monads is to ignore all the analogies people write
02:28:57 <ChongLi> and just focus on the laws and the combinators
02:29:04 <ChongLi> it's really that simple
02:29:18 <adnap> I have a function f :: m a -> IO () and I want to call http://hackage.haskell.org/packages/archive/hint/0.3.3.6/doc/html/Language-Haskell-Interpreter.html#v:interpret on "f [bla]", but [bla] is a huge do block. I assume it's possible to put the entire do block in a String, but this just seems so ugly
02:29:52 <typoclass> bad_alloc: doesn't look very ugly to me at first glance :-) if you wish, you can replace (x:[]) with [x] in line 13
02:30:24 <bad_alloc> typoclass: *applyingÜ
02:30:45 <Taneb> Is there an (==)-like function for comparing Doubles to within a certain precision?
02:31:07 <mauke> (< Îµ) . abs .: (-)
02:31:20 <adnap> Oh, wait...
02:31:24 <bad_alloc> edwardk: I might be preaching to the wrong crowd here, but regarding the "challenging the way you thing": have you ever looked at lisp?
02:31:44 <typoclass> bad_alloc: how do you mean? i was talking about changing "reconstructTree (x:[]) = x" to "reconstructTree [x] = x". a little less symbols
02:31:50 <mauke> lisp was very underwhelming
02:32:07 <adnap> interpret doesn't care if I do "let bla = do ..." and "f bla"
02:32:12 <bad_alloc> typoclass: Erm, in the sense of "applying your suggestion to the code" (worng idiom?)
02:32:16 <edwardk> bad_alloc: yes. though i confess i tend to prefer scheme for that 'challenging the way you think' aspect about parenthesized languages. i think the power of proper tail calls provided for by scheme really makes that family of languages palatable.
02:32:35 <ChongLi> homoiconicity is nice but I like types too!
02:33:43 <ChongLi> bodil wrote an interesting language that seeks to combine the two
02:34:03 <ChongLi> but it
02:34:08 <ChongLi> it's still really early days for her
02:34:09 <mauke> is it qi?
02:34:13 <ChongLi> https://github.com/bodil/BODOL
02:34:27 <bad_alloc> hm, okay. Since starting with haskell at university I've always percieved it as lisp where parentheses have been violently removed (see the $ and . operators). (Our teacher hates them)
02:34:33 <adnap> Oh, crap
02:34:45 <ChongLi> bad_alloc: it's more than that
02:35:00 <ChongLi> it's laziness and currying everywhere
02:35:28 <edwardk> The main problem I have with the scheme/lisp family is that they tend to ignore the fact that they really do have syntax. They just split the language into two levels: a Dyck-language like set of balanced parens surrounding a concatenative term structure. The choice between things like (defun (foo (bar baz)) â€¦)  vs (defun (foo bar baz)) â€¦) vs. (defun foo bar baz â€¦) for a macro is syntax, after all ;)
02:36:00 <mauke> that, and Common Lisp has a fuckton of other syntax
02:36:24 <mauke> vector literals and stuff
02:36:32 <ChongLi> multiple return values!
02:36:44 <mauke> perl does that too
02:37:14 <ChongLi> and separate namespaces for functions and regular values!
02:37:19 <mauke> perl does that too
02:37:19 <ChongLi> just weird stuff if you ask me
02:37:28 <Ralith> common lisp has vectors?
02:37:30 <neutrino_> hi
02:37:31 <Ralith> I didn't know that
02:37:33 <bad_alloc> okay, I see :D just a question: does haskell have anything analogue to lisp macros somewhere? (or am I doing it wrong if i need them?) I really miss them.
02:37:41 <mauke> (spoilers: perl is lisp)
02:37:42 <ChongLi> common lisp has everything, it's pretty huge
02:37:45 <bad_alloc> Ralith: #(1 2 3) is a vector
02:37:50 <neutrino_> can i have a value which is monadic but also has the enum interface?
02:37:50 <ChongLi> haskell has template haskell
02:38:08 <mauke> bad_alloc: template haskell, cpp
02:38:12 <Ralith> bad_alloc: oh, right
02:38:14 <bad_alloc> mauke: according to Let Over Lambda every language is lisp minus macros.
02:38:16 <Ralith> it's been a long time
02:38:28 <mauke> bad_alloc: lisp is blub
02:38:32 <aristid> mauke: perl has separate namespaces for associative maps and integer-indexed arrays...
02:38:41 <edwardk> bad_alloc: There is a more fundamental difference between Haskell and Lisp than just the violent removal of parentheses. It has to do with whether you construct a lambda calculus 'a la Curry' or 'a la Church'. In one the types are part of the terms and an expression makes no sense without its types, in the other, the types are something you can derive from the term and are just informing well-formedness. Adding typeclasses to a
02:38:41 <edwardk>  language makes it so that the types change meaning
02:38:45 <typoclass> bad_alloc: do you have an example or two for when you wanted macros? sometimes you don't actually need them in haskell
02:39:00 <Ralith> mauke: anyway, that's a reader macro invocation.
02:39:06 <Ralith> not really the same thing as syntax
02:39:16 <mauke> Ralith: what's the difference?
02:39:20 <shachaf> "Lisp most powerful language conceivable", reports Lisp programmer.
02:39:31 <ChongLi> TH is great for constructing boilerplate such as making lenses :)
02:39:31 <neutrino_> edwardk: which is haskell?
02:39:45 <capisce> TH seems a bit verbose to me
02:39:51 <neutrino_> i'm thinking "curry"
02:39:52 <mauke> capisce: very
02:39:57 <Ralith> mauke: primitivity, I suppose
02:40:06 <capisce> that's where lisp has an advantage I guess
02:40:07 <aristid> shachaf: they are so foolish, why can't they see that Haskell is the most powerful language conceivable
02:40:09 <bad_alloc> typoclass: for implementing an ulam spiral you have to "step" (advance n pixels into your direction) twice. in lisp I cpuld write ma macro twice and go (twice (step)) in haskell i actually wrote the code twice.
02:40:18 <Ralith> capisce: CL macros can be very verbose
02:40:18 <ChongLi> most of the use cases for macros are covered by laziness in Haskell
02:40:31 <mauke> bad_alloc: why not write a function?
02:40:44 <typoclass> "every language is just lisp minus macros" ~ "every language is just assembly plus a compiler. hence assembly is better and moar powerful"
02:40:46 <capisce> Ralith: they don't have to be
02:40:48 <ChongLi> and here's one real advantage Haskell has:
02:40:48 <neutrino_> mauke: because lisp has macros!
02:40:54 <ChongLi> functions are more powerful than macros!
02:40:54 <Ralith> ChongLi: funny, that's not how I used macros
02:40:56 <neutrino_> mauke: why use functions if you can use macros?
02:40:59 <ChongLi> since they are first class
02:41:04 <mauke> bad_alloc: twice x = do { x; x }
02:41:05 <bad_alloc> mauke: I still have to invoke it twice. Sure lisp does that too but it made the code more readable IMHO
02:41:09 <neutrino_> mauke: in fact, why use functions if you can use goto?
02:41:13 <mauke> bad_alloc: twice (putStrLn "hello")
02:41:16 <edwardk> bad_alloc: re macros, we have template-haskell, but we don't use it nearly as much as scheme/lisp use their macros. This is in part due to the fact that we're in a lazy language, so we don't need it for control flow reasons. we can write 'if'-like combinators in the language directly, and we can use lambdas to write binders so we feel the need for custom binding forms a lot less, and can use infix operators to make things less
02:41:16 <edwardk>  awkward, etc.
02:41:49 <bad_alloc> mauke: That I did not know. Thanks :)
02:41:50 <ChongLi> nothing more annoying in lisp than trying to map a macro over something and finding you can't
02:42:00 <edwardk> bad_alloc: but TH helps fill that code-generation niche that isn't covered by laziness. so for the 10% of the remaining cases where macros get used you need to use it. and there we pay the price for the richer syntax of haskell.
02:42:00 <ChongLi> since macros don't exist at runtime
02:42:09 <Cale> Or perhaps: twice x = replicateM 2 x
02:42:12 <edwardk> thats part of why template haskell is so frustratingly complicated
02:42:17 <typoclass> bad_alloc: i guess i'd need to see the code to be sure, but it doesn't sound to me like this is something that absolutely requires macros
02:42:30 <neutrino_> i like cale's code better
02:42:34 <Ralith> capisce: with gensyms and such they're prone to it, though
02:42:34 <neutrino_> replicateM is cool
02:42:43 <mauke> neutrino_: different return value
02:42:44 <capisce> Ralith: nope, that can be abstracted away
02:42:51 <Ralith> yes, with boilerplate
02:42:52 <Ralith> :P
02:43:02 <capisce> which you write once and use over and over again
02:43:11 <capisce> edwardk: couldn't a better macro language be made for haskell?
02:43:18 <ChongLi> typed TH
02:43:18 <ChongLi> !
02:43:23 <ChongLi> which is coming :)
02:43:24 <Ralith> the boilerplate is the with-gensyms call, not its implementation
02:43:28 <edwardk> neutrino_: the easiest way to remember it is that Haskell is named after Curry, but is a language a la Church. =)
02:43:33 <capisce> ChongLi: will it be less verbose? :)
02:43:43 <capisce> Ralith: you don't need with-gensyms either
02:43:45 <ChongLi> not sure, I only heard it mentioned
02:43:49 <edwardk> capisce: typed TH is in the wings, hopefully it'll help out. not holding my breath though.
02:44:01 <Ralith> in fact you don't need anything but turing completeness :P
02:44:08 <edwardk> capisce: same general verbosity level, now with more types
02:44:20 <ChongLi> I kind of avoid template haskell and I find I don't need it much
02:44:22 <neutrino_> edwardk: lol, that's not easy at all :))
02:44:24 <Ralith> typed metaprogramming \o/
02:44:45 <typoclass> bad_alloc: i have some smallish suggestions for your code, but it's no big deal http://hpaste.org/diff/88587/88588
02:44:47 <ChongLi> some people love it though
02:44:52 <capisce> Ralith: you can make a convention for variable naming of gensym variables
02:44:56 <capisce> (defmacro! square (o!x) `(* ,g!x ,g!x))
02:45:01 <ChongLi> such as the yesod folks!
02:45:09 <capisce> Ralith: http://letoverlambda.com/index.cl/guest/chap3.html
02:45:22 <ChongLi> how many different quasiquoters do they use?
02:45:26 <ChongLi> it's a lot
02:45:48 <typoclass> bad_alloc: in "foo abc = 42", since you're not using the name abc inside the function, it might be clearer to just write "foo _ = 42"
02:45:53 <typoclass> bad_alloc: that's about it
02:45:55 <neutrino_> edwardk: my team has started a project with scala just before i joined. it uses an ugly, badly-written callback-based web framework. they've learnt quite a bit scala in the past month. how can i convince them to switch to haskell? the project is broken up into services, so we could just keep the code we've written already.
02:46:00 <bad_alloc> typoclass: Thanks, the main issue I have learning haskell is that I don't know what "the Right Thing" is for a given situation. so thanks for that imput :)
02:46:25 <edwardk> neutrino_: good question. it was a fair bit of effort to get us to switch from scala to haskell here ;)
02:46:28 <mauke> > map (* 2) [0 ..]
02:46:30 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
02:46:37 <neutrino_> edwardk: what was the effort based on?
02:46:39 <ChongLi> neutrino_: perhaps write a small example?
02:46:47 <aristid> edwardk: wait you actually succeeded in that? :P
02:47:04 <Ralith> capisce: getting into LoL territory starts to raise questions concerning the distinction between 'can' and 'should' :P
02:47:19 <edwardk> neutrino_: in my case it was more that we had a compiler written in scala and most of our productivity was going into fighting with the host language rather than implementing the target language
02:47:34 <Ralith> shutt's approach makes things much cleaner really
02:47:45 <Ralith> I'd like to try integrating that with types sometime
02:48:04 <edwardk> capisce: or you can just use syntax-rules and side-step the whole thing ;)
02:48:14 <capisce> Ralith: shutt's approach?
02:48:44 <edwardk> neutrino_: fortunately for me the entire team around me preferred haskell. scala was initially chosen for business reasons.
02:49:08 <mauke> ... I think I need to learn scheme macros
02:49:13 <Ralith> capisce: http://www.wpi.edu/Pubs/ETD/Available/etd-090110-124904/unrestricted/jshutt.pdf
02:49:32 <neutrino_> edwardk: the only real code we have produced in scala so far is a service which does little more than look up an id in mysql and echo "ok" or "not ok". it also registers with some sort of service registry and does "config management" via implicits (we can't directly use Reader with this framework). we've also written a monad instance for the Future type they're using there.
02:49:55 <capisce> Ralith: right, I remember reading a little bit about fexprs at one point
02:50:06 <neutrino_> oh, and it talks to memcache and does reporting into something that hooks into opentsdb
02:50:11 <Ralith> shutt fexprs are distinct from classical fexprs
02:50:48 <capisce> Ralith: but to me it seems the positives outweigh the negatives when it comes to the defmacro! abstraction proposed in LoL
02:50:49 <neutrino_> edwardk: i've been teaching people about functional programming etc (when I came in there was exactly 0 knowledge about this, after I joined that changed, but not sure in which direction)
02:51:11 <typoclass> neutrino_: hehe :-)
02:51:19 <hvr> neutrino_: fwiw, I showed my colleagues http://www.infoq.com/news/2011/11/yammer-scala which had just started looking at scala... and well, they reconsidered :-)
02:51:39 <neutrino_> now because we see we absolutely have to use scalaz or we'll die in callback hell i'm gonna have everyone read the scalaz book, which refers to LYAH a lot, and has inline haskell examples, so that should expose them a bit
02:51:44 <typoclass> @remember neutrino i've been teaching people about functional programming etc (when I came in there was exactly 0 knowledge about this, after I joined that changed, but not sure in which direction)
02:51:45 <lambdabot> I will remember.
02:51:46 <Ralith> capisce: sadly, objective judgement on such things is not easily had.
02:51:54 <neutrino_> hvr: funny, we use yammer here.
02:52:21 <capisce> Ralith: that's the beauty of lisp, a lot of power to the individual programmer
02:52:36 <Ralith> some would say that's the curse
02:53:02 <capisce> for managers of large teams who want predictability perhaps :)
02:53:03 <neutrino_> btw, wasn't there someone from typesafe in the channel here?
02:53:51 <Ralith> anyway, nobody's levered kernel into CL yet
02:54:02 <dibblego> hvr: that post is deceptive and dishonest â€” there are actual reasons not to use scala, but that post covers zero of them
02:54:31 <capisce> Ralith: shutt's language? how would that be levered in? :)
02:54:40 <hvr> dibblego: actually I sent them the original leaked-email from yammer
02:54:58 <dibblego> hvr: that is just as bad
02:55:20 <hvr> dibblego: what's so misleading about the experience-report email?
02:55:55 <dibblego> hvr: I don't know where to start answering that question, but probably not here
02:56:15 <hvr> :-)
02:56:20 <Ralith> capisce: that's the question, isn't it
02:57:26 <capisce> Ralith: the reluctancy toward giving power to the individual programmer in many languages is why I fear I'll have to make my own :)
02:57:32 <adnap> How can I work around this? http://hpaste.org/88589
02:58:03 <Ralith> capisce: you should come work on idris instead!
02:58:39 <Ralith> capisce: the reflection stuff could definitely use more work by suitably motivated people
02:58:45 <hvr> dibblego: ...is there maybe a blog-post covering part of the problem with that email you can recommend?
02:59:08 <nomeata> Hi. Is there any way to trick cabal-install to use a different global package db?
02:59:26 <dibblego> hvr: no, maybe IRC logs if anything â€” the small group at yammer have a reputation for being dishonest
02:59:45 <neutrino_> dibblego: what are the "real" reasons not to use scala?
02:59:47 <capisce> Ralith: right, dependent types can go a way in filling some of the use cases where TH is needed I guess
03:00:24 <dibblego> neutrino_: this is probably not the channel, nor is #scala â€” I am sure edwardk and I could help you out with that one in an appropriate forum
03:00:27 <Ralith> capisce: and there's lots of opportunity to do interesting things with metaprogramming, typed and un, too
03:01:00 <adnap> Is the only solution to put "g" in another module?
03:01:05 <typoclass> capisce: i think the "power to the individual programmer" opinion is a bit dangerous because by that logic, assembly should be used everywhere.
03:01:06 <neutrino_> dibblego: /j #codez
03:01:49 <capisce> typoclass: power of molding the language and creating abstractions is what I'm talking about
03:01:54 <capisce> typoclass: the kind of power you have in lisp
03:02:09 <aristid> typoclass: if by power you mean tedious manual work
03:02:25 <capisce> assembly is not a pleasant language to use in the long run
03:02:43 <adnap> #haskell has been so stupid lately. Maybe it's just the time of day I am on
03:02:44 <capisce> or rather, it limits the kind of solutions you can think of, since you're so mired in low level details
03:03:33 <adnap> It's like 30% Haskell and 70% politics
03:03:59 <neutrino_> and 10% "This FTP site"
03:04:10 <capisce> there's ##pldesign for ones who want to discuss benefits and drawbacks of different languages actually
03:04:44 <neutrino_> this isn't really about language design, it's also about business reasons
03:05:00 <typoclass> capisce: yes, but i'd argue lisp is also unpleasant in the long run. it's hard to read and maintain because anything could have been "molded" to mean anything. in the extreme, any particular thing could have been expressed a myriad ways
03:05:10 <capisce> neutrino_: what is about business reasons?
03:05:12 <Ralith> capisce: oh hey, you're that guy who was insisting C++ had dependent types
03:05:38 <alcatraz63> comonad.com working for anyone?
03:05:46 <capisce> typoclass: but it gives a lot of power to the individual programmer if he can maintain some discipline and consistency
03:05:50 <Ralith> typoclass: real-world experience seems to suggest that that doesn't actually happen.
03:06:09 <capisce> typoclass: not saying I wouldn't like a language with lisp's meta-programming abilities but with static typing and a richer syntax
03:06:10 <neutrino_> capisce: my issue with my workplace using scala..
03:07:45 <ChongLi> capisce: would you prefer first-class currying or first-class variadic functions?
03:08:29 * neutrino_ is wondering if dibblego got upset and left :(
03:08:30 <ChongLi> yeah, I'm aware of the type hackery with printf :)
03:08:44 <typoclass> capisce: right, but that discipline is an issue. discipline is also the reason why i find c terrible. i'd rather have a compiler ensure something 100% of the time, than my own discipline ensuring it 98% of the time, making mistakes the other 2%. it doesn't matter if it's for any particular programmer 98% or 95% or 99%, the point is that at some point you'll accidentally put 'null' where there should be a string. which can't happen with 
03:08:53 <neutrino_> ChongLi: what are first-class variadic functions?
03:09:10 <ChongLi> neutrino_: pattern matching on arity, basically
03:09:17 <ChongLi> is that a good way to describe it?
03:09:23 <typoclass> capisce: anyway, i feel we're more or less agreeing anyway
03:09:45 <neutrino_> ChongLi: ah.
03:10:22 <neutrino_> ChongLi: I don't think those are necessarily disjoint.. if you use something like type synonyms or tagged types.
03:10:49 <neutrino_> for example one could easily imagine a situation where you can make a distinction between f : Int -> Int and f: Double -> Double -> Double
03:10:59 <neutrino_> even if only the first parameter has been applied
03:11:42 <neutrino_> and being able to pass in different types really is the reason why you might want multiple definitions for a function
03:11:57 <ChongLi> hmmm
03:12:49 <neutrino_> it's just that until the compiler figures out which one of N function definitions you're using, it likely has to compile N copies of the program :)
03:13:26 <ChongLi> yeah, and what about rest args?
03:13:37 <neutrino_> well that's the thing
03:13:57 <neutrino_> you can't really have unapplied functions in a running program..
03:14:48 <ChongLi> so say I had a function foo
03:14:49 <neutrino_> so if you don't tell the compiler the types, and the connection it needs for inference is very far away, it's likely to become slower until it can rectify the decision
03:15:03 <ChongLi> which took 1 2 or 3 args
03:15:16 <ChongLi> and each case returned a function
03:15:32 <ChongLi> and then I called it with foo a b c
03:15:50 <ChongLi> conceivably each of the 3 cases should be valid?
03:15:51 <neutrino_> a function which returns a function is just that function
03:16:48 <ChongLi> yeah I don't see how it'd work
03:16:57 <neutrino_> if you have a function of two parameters which returns a function of 1 parameter which returns a value, then the type looks like this:   f :: a -> b -> (type of g) === f :: a -> b -> (c -> d) === f :: a -> b -> c -> d
03:17:03 <neutrino_> it's just a function of 4 parameters
03:17:33 <neutrino_> and you're forgetting what i said earlier - we're talking about a situation where the types are specified, rather than fully polymorphic
03:17:46 <ChongLi> right
03:17:55 <neutrino_> so what you have is in fact the distinction between f :: Int -> whatever and f :: Double -> whatever
03:17:58 <ChongLi> so foo of arity 1 would have a different type from foo of arity 2
03:17:59 <neutrino_> and that's simple
03:18:09 <neutrino_> no it's not about that
03:18:26 <neutrino_> it's about being able to distinguish between e.g. foo :: Int -> Bool and foo :: Double -> Bool
03:18:31 <neutrino_> which is very simple
03:18:42 <neutrino_> if you tell the compiler the types
03:18:48 <ChongLi> what about:
03:18:53 <ChongLi> foo :: Int -> Bool
03:18:56 <neutrino_> it's less simple but probably doable if you let the compiler figure types out
03:19:02 <ChongLi> foo :: Double -> Double -> Bool
03:19:25 <neutrino_> yeah when you've found the first parameter you know whether it's an Int or Double, so you make the decision
03:19:46 <neutrino_> unless you need to infer that as well
03:19:50 <neutrino_> then you look somewhere else
03:20:03 <ChongLi> I guess you can do what printf does and parameterise on the return type?
03:20:25 <ChongLi> so Bool and (Double -> Bool) could be in the same class or something
03:20:38 <ChongLi> I guess that doesn't work
03:20:39 <neutrino_> no, that's not even what i'm talking about
03:21:05 <ChongLi> hmmm
03:21:09 <neutrino_> i could just copy-paste the things you've missed?
03:21:26 <neutrino_> 12:18 < neutrino_> it's about being able to distinguish between e.g. foo :: Int -> Bool and foo :: Double -> Bool
03:21:36 <ChongLi> yeah, but those are of the same arity
03:21:50 <neutrino_> i'm not about to start pressing up and enter
03:22:21 <neutrino_> think about it a little longer
03:22:30 <neutrino_> i'm going to go do my invoices
03:22:33 <neutrino_> bbl
03:27:35 * hackagebot multimap 1.0 - A multimap.  http://hackage.haskell.org/package/multimap-1.0 (JulianFleischer)
03:29:45 <Saizan> even Java can tell foo :: Int -> Bool and foo :: Double -> Bool apart wrt overloading btw
03:30:09 <ChongLi> yeah
03:30:52 <Saizan> but it does compile them to separate functions
03:32:03 <ChongLi> hmm, I guess my whole variadic question was much ado about nothing
03:32:21 <ChongLi> since we have it with typeclasses and we don't usually need it
03:33:44 <Saizan> yeah, a problem with it is that it tends to create too much ambiguity for type inference to work well
03:34:23 <Saizan> but also that there's isn't that much craving for e.g. zipN
03:34:41 <ChongLi> if we really need zipN
03:34:47 <ChongLi> we can use Applicative right?
03:36:06 <Saizan> more stuff to specify, but yeah
03:36:36 <ChongLi> with the ZipList newtype that is
03:36:51 <Andrea_> can someone explain a beginner how to use random numbers, perhaps without IO monad ?
03:37:17 <ChongLi> you can't get a random number without doing IO
03:37:34 <osfameron> you can't make an omelette without doing IO
03:37:36 <Saizan> you can pass the generator around without IO though
03:38:00 <ChongLi> yeah, which just hides the plumbing for managing the seeds
03:38:10 <ChongLi> but you need IO to get the first random seed
03:38:24 <Saizan> sure
03:38:24 <ChongLi> unless you're going to provide it yourself as a literal
03:38:31 <ChongLi> but then you'll always get the same sequence
03:38:47 <typoclass> Andrea_: hello. i suggest you get a random number in your main function. "r <- randomIO ; print (foo r)". foo can then be a pure function (without IO)
03:39:22 <Saizan> Andrea_: do you have some starting point? or some particular problem? explaining System.Random on irc from scratch is not so ideal :)
03:40:02 <Andrea_> i have no starting point
03:40:39 <Andrea_> i want know , is it possible to use random numbers in a different function from main
03:40:40 <ChongLi> > randomIO >>= print
03:40:42 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
03:40:42 <lambdabot>    arising from a use of ...
03:40:51 <ChongLi> hmmm
03:40:58 <ChongLi> oh of course
03:41:02 <ChongLi> not in the IO monad :)
03:41:10 <Saizan> Andrea_: sure, http://www.haskell.org/haskellwiki/Examples/Random_list <- here they are used in randomlist
03:41:55 <Andrea_> Saizan, thanks, i will look to this
03:42:18 <typoclass> Andrea_: here is a minimal example http://hpaste.org/88591
03:42:46 <Saizan> Andrea_: any function taking a StdGen can generate random numbers, and if you need to pass the new seeds around you might want to look into MonadRandom on hackage
03:42:47 <Andrea_> thanks typoclass
03:44:04 <Andrea_> but all versions use the main function, the main function will grow
03:44:33 <Saizan> Andrea_: they use main because they are small examples, and to run a haskell program you need a main function
03:44:42 <mauke> "function"
03:44:43 <Saizan> Andrea_: but there's no need to keep the code in there
03:44:46 <ChongLi> Andrea_: think of the main function as "an interpreter"
03:44:59 <Saizan> yeah, it's not a function
03:45:14 <ChongLi> all of your other functions simply serve to build a "blob" of stuff that the main function then runs
03:45:17 <Saizan> it's a value of type IO X, for some X
03:46:12 <Andrea_> i thougt it mus be in main function becaus the main function use the IO
03:46:13 <shachaf> main is usually not a function.
03:46:25 <mauke> shachaf: :-)
03:46:45 <ChongLi> yeah, it's just an IO action
03:46:51 <elliott> shachaf++
03:47:07 <mauke> http://mauke.hopto.org/stuff/c/hell.c
03:47:31 <Aetherspawn_> mauke, I lol'd
03:47:34 <Aetherspawn_> as a C programmer
03:50:12 <Aetherspawn_> :t cycle
03:50:14 <lambdabot> [a] -> [a]
03:50:14 <shachaf> mauke: Courtesy of Jafet: http://codu.org/projects/hackbot/fshg/index.cgi/raw-file/tip/paste/paste.29668
03:50:19 <Aetherspawn_> > cycle "a/b"
03:50:20 <typoclass> Andrea_: here's another example that uses a list of 100 random numbers http://hpaste.org/88591
03:50:20 <lambdabot>   "a/ba/ba/ba/ba/ba/ba/ba/ba/ba/ba/ba/ba/ba/ba/ba/ba/ba/ba/ba/ba/ba/ba/ba/ba/...
03:50:53 <Aetherspawn_> > cycle :t intersparse
03:50:54 <lambdabot>   Not in scope: `intersparse'
03:50:54 <lambdabot>  Perhaps you meant one of these:
03:50:54 <lambdabot>    `interspers...
03:50:58 <Aetherspawn_> :t intersparse
03:50:59 <lambdabot>     Not in scope: `intersparse'
03:50:59 <lambdabot>     Perhaps you meant one of these:
03:50:59 <lambdabot>       `intersperse' (imported from Data.List),
03:51:46 <Andrea_> i read in a book that it is possible to use StdGen withot io, but i don't understand this
03:52:36 * hackagebot named-records 0.4 - Flexible records with named fields.  http://hackage.haskell.org/package/named-records-0.4 (JulianFleischer)
03:52:53 <Aetherspawn_> Andrea_, you could probably do it without IO if you had another monad I think
03:53:02 <Aetherspawn_> But I'm not sure..
03:53:09 <ChongLi> Andrea_: once you have a StdGen you can use it
03:53:26 <ChongLi> with functions like random
03:53:29 <ChongLi> :t random
03:53:30 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
03:53:33 <elliott> :t mkStdGen
03:53:34 <lambdabot> Int -> StdGen
03:53:36 <Andrea_> ok im must set a new start value , i think
03:53:37 <elliott> you can even make a generator outside of IO
03:53:38 <ChongLi> see, no IO
03:53:41 <elliott> it'll just be a predefined one
03:53:46 <elliott> > randoms (mkStdGen 12387123)
03:53:47 <elliott> > randoms (mkStdGen 12387123)
03:53:47 <lambdabot>   [-4906539705106868053,-1669100043590870430,5566779868511592945,-22654971385...
03:53:48 <lambdabot>   [-4906539705106868053,-1669100043590870430,5566779868511592945,-22654971385...
03:53:50 <elliott> > randoms (mkStdGen 12387124)
03:53:51 <lambdabot>   [3128574264824321508,6167878479649781828,6969108792153625119,45796069290444...
03:54:10 <Aetherspawn_> not so "random"
03:54:25 <ChongLi> if you think about it
03:54:35 <neutrino_> better than LFSR.
03:54:44 <ChongLi> a computer random number generator is just a big cycle of numbers
03:54:47 <Aetherspawn_> It's the chicken egg problem. You can make a pure random number if you have a random number to generate the gen from
03:54:49 <Aetherspawn_> <_<
03:54:56 <ChongLi> and the seed is just a start point
03:54:58 <ChongLi> in that cycle
03:55:15 <neutrino_> that's not true
03:55:27 <ChongLi> neutrino_: how so?
03:55:34 <Andrea_> pseudo random numbers are good enough for me
03:55:37 <Aetherspawn_> I thought most random number gens were just based on digits of pi
03:55:42 <Aetherspawn_> with some maths added
03:55:49 <neutrino_> if two numbers come after one another under one seed, they most likely won't in another.
03:56:21 <ChongLi> so each seed gives a different cycle then?
03:56:30 <neutrino_> yes. it would be useless otherwise.
03:56:40 <fosskers> @src sum
03:56:40 <lambdabot> sum = foldl (+) 0
03:56:53 <Aetherspawn_> I'm so very sorry for failing w/ the mailing list about a week back ;__;
03:56:54 <neutrino_> you're thinking of LFSR, where any number is a seed, and just defines the offset into the static cycle.
03:56:55 <fosskers> @src Data.Foldable.sum
03:56:55 <lambdabot> Source not found. I feel much better now.
03:56:55 <zRecursive> random example: http://hpaste.org/88594
03:57:05 <typoclass> Andrea_: in main you can do "g <- getStdGen" or "g <- newStdGen". here's an example how you would do that. it's not very different from the other two. you do "<-" in main, then you pass it into a pure function. http://hpaste.org/88591
03:57:13 <ChongLi> neutrino_: yes, you're probably right
03:57:37 <neutrino_> look up lfsr's. Very nice things with lots of fun properties.
03:58:10 <Aetherspawn_> haskell.org is so old
03:58:16 <Aetherspawn_> its probably too dated to run the current exploits
03:58:25 <neutrino_> widely used in electronics to ensure data stream integrity.
03:58:43 <fosskers> Just learned about Foldable, and I'm impressed.
03:59:07 <ChongLi> fosskers: if that impresses you, check out lens!
03:59:11 <vazakl> foldable rulez
03:59:16 <shachaf> Aetherspawn_: ?
03:59:20 <fosskers> ChongLi: One day. Maybe after Arrows?
03:59:24 <ChongLi> http://hackage.haskell.org/package/lens
03:59:35 <fosskers> I'm just working my way through typeclassopedia
03:59:43 <ChongLi> http://youtu.be/cefnmjtAolY?hd=1
03:59:53 <ChongLi> this video goes a LONG way to helping out
04:00:03 <ChongLi> cause staring at that UML diagram will just make your eyes bleed :)
04:00:14 <Aetherspawn_> shachaf, 2 major versions behind :P
04:00:45 <fosskers> ChongLi: thanks. I'll watch that when I have two hours, haha
04:00:49 <ChongLi> lens generalises all of these getters, folds, isomorphisms, traversals, setters and lenses
04:00:50 <vazakl> cool
04:00:57 <ChongLi> it's pretty crazy
04:00:57 <fosskers> ChongLi: whoa
04:01:22 <ChongLi> and it allows you to make use of it without even depending on it!
04:01:32 <zRecursive> lens seems complicate
04:01:33 <edwardk> fosskers: Arrows are largely a historical accident and are basically skippable
04:01:47 <fosskers> edwardk: Do explain
04:02:06 <fosskers> edwardk: Monadz 4 life kinda thing?
04:02:36 <edwardk> fosskers: Arrows were invented to cover a kind of parser that Swierstra and Duponcheel came up with. However, that parser is much better expressed using Applicative, a much simpler and weaker structure than Arrow.
04:02:48 <edwardk> fosskers: Applicative just didn't exist at the time.
04:03:01 <ChongLi> that's pretty amazing to think about
04:03:05 <Andrea_> if i want mix a list to try a sorting algorithm i must put the whole mixing in the main function ?
04:03:15 <ChongLi> since now when you learn Applicative it seems self-evident
04:03:30 <alcatraz63> edwardk: is comonad.com down? (i hope you are the right edwardk)
04:03:31 <edwardk> fosskers: Applicative nicely captures something like a 'context-free' grammar, while Monad captures the notion of context sensitivity. Arrows occupy a very uncomfortable middle ground.
04:04:01 <tom39291_> I am using a typeclass C. I am writing a new typeclass, D. When a type becomes part of D, I also want it to be part of C. (I can implement all of C's functions using D's functions.). What language feature am I looking for?
04:04:19 <edwardk> alcatraz63: Yeah. The box was rooted. I've moved everything to new hardware, but I need to get a few things installed when I can find the time
04:04:41 <ChongLi> what is the middle ground between context-free and context-sensitive?
04:04:45 <typoclass> Andrea_: i would use 'permutations':
04:04:48 <typoclass> > permutations "cat"
04:04:49 <lambdabot>   ["cat","act","tac","atc","tca","cta"]
04:05:01 <edwardk> ChongLi: thats the problem. hence why it is an uncomfortable middle ground =)
04:05:02 <Aetherspawn_> That's awesome.
04:05:04 <ChongLi> a superposition of context-sensitivity?
04:05:15 <Aetherspawn_> > permutations [1..5]
04:05:17 <lambdabot>   [[1,2,3,4,5],[2,1,3,4,5],[3,2,1,4,5],[2,3,1,4,5],[3,1,2,4,5],[1,3,2,4,5],[4...
04:05:37 <ChongLi> SchrÃ¶dinger's parser
04:05:39 <ChongLi> or something
04:05:47 <edwardk> ChongLi: i say 'something-like' context-free because due to the fact that you can make infinite grammars even using applicative due to laziness, applicative still captures a context-sensitive grammar so long as the alphabet is finite.
04:06:08 <beaky> hello
04:06:19 <zRecursive> Aetherspawn_: are there corresponding combination ?
04:06:30 <Saizan> Andrea_: no, you just need a StdGen argument
04:06:33 <Aetherspawn_> I have no idea.
04:06:46 <zRecursive> besided permutations
04:06:52 <fosskers> edwardk: Yeah, I've got a good sense of the differences between Applicative and Monad using Parsec
04:06:54 <alcatraz63> edwardk: eta maybe?
04:07:06 <fosskers> edwardk: And Arrows are just awkward?
04:07:30 <typoclass> Andrea_: in main, get one number from a random-number generator as you've seen in the example. then do something like "(permutations yourList) !! r". be sure to watch the list length (if a list has only 10 elements, you can't use "list !! 11")
04:07:30 <beaky> How do I fold a fuction on a list to get a function that is f  of the first x, composed with f of the second, composed with f of the third element... etc?
04:07:38 <Andrea_> Saizan, how looks a call of it
04:07:43 <elliott> arrows don't let you do a lot of what you'd want them for because they restrict their instances too much (mainly because of arr)
04:07:48 <elliott> and they're also awkward to use
04:07:54 <elliott> kind of a lose-lose situation
04:07:55 <edwardk> alcatraz63: hopefully by hac phi? =)
04:08:07 <shachaf> Oh, that's "ETA".
04:08:23 * shachaf was wondering what the Î· was doing there.
04:08:24 <ChongLi> edwardk: do you have a good explanation of Prisms for a lens newbie like me?
04:08:38 <fosskers> elliott: haha well at least I'll give them a read in typeclassopedia
04:08:44 <elliott> beaky: map f turns [x1, x2, x3, ...] into [f x1, f x2, f x3, ...]. foldr (.) id turns [f1, f2, f3, ...] into (f1 . f2 . f3 . ...)
04:09:19 <edwardk> alcatraz63: i need to put together some kind of slide deck on my semiparsing/analytics project, and i'm also investigating moving comonad.com entirely to something like octopress+disqus and hosting it off github to avoid the need for the current comonad.com hosting situation entirely
04:09:30 <Andrea_> in java i wrote : http://hpaste.org/88596
04:09:48 <Andrea_> i hava no idea to do this in haskell
04:10:03 <timbod> I
04:10:06 <beaky> ah thanks
04:10:33 <timbod> I'm seeing some typeclass oddness here: http://hpaste.org/88597 - any ideas what is going on?
04:11:01 <beaky> I came up with this and it works!   foldr (\c f -> myFunction c . f) (myFunction 'a') "1235678"
04:11:17 <beaky> but it is not as elegant as foldr (.) id
04:11:19 <ChongLi> Andrea_: hard to say without knowing what repaint does
04:11:38 <ChongLi> or what values is
04:11:42 <edwardk> fosskers: the problem with arrows is they are simultaneously too loose and too restricted. they are too loose in the sense that they give you a lot of freedom for breaking commutativity, while being too restricted in requiring 'arr' which is an enormous constraint on your implementations and all the sugar uses it, so if your 'arr' can't be efficient, then your arrow can't. I find a CCC to be a more principled basis for something
04:11:42 <edwardk>  like an Arrow, and that I just never have anything that actually needs to be an Arrow after I've made my Applicatives Applicative.
04:11:46 <alcatraz63> edwardk: ill read from google cache i guess :)
04:12:13 <mauke> timbod: that makes sense
04:12:14 <ChongLi> Andrea_: it seems like you're just shuffling values based on some random indices
04:12:15 <Andrea_> ChongLi, the repaint doesn't matter for mix ( it repaints the elements on the sceen)
04:12:22 <edwardk> alcatraz63: probably best for now. it is definitely on my mind that i need to fix it =)
04:12:36 * hackagebot named-records 0.5 - Flexible records with named fields.  http://hackage.haskell.org/package/named-records-0.5 (JulianFleischer)
04:12:41 <mauke> timbod: it doesn't know which type to use for defaultv
04:12:45 <timbod> mauke:  Why does it work if I specify either field, but give the error if I specify both?
04:12:56 <timbod> ie v1 and v2 are ok, v3 is not.
04:13:13 <mauke> timbod: in the other two cases the type is known: XY Int
04:13:21 <ChongLi> Andrea_: so is that what you want help with?
04:13:24 <ChongLi> a shuffle function?
04:13:43 <timbod> mauke:  What other type could v3 have other than XY Int ?
04:13:51 <typoclass> Andrea_: have you seen my messages from the last few minutes? :-)
04:13:55 <mauke> timbod: anything
04:14:04 <mauke> timbod: XY t0 for any t0
04:14:21 <timbod> How? I'm passing Int's to the field values?
04:14:23 <Andrea_> yes and no together, if i am able to generate random numbers i can shuffle, but i want not learn to shuffle, i want lern to use random numbers
04:14:26 <mauke> timbod: er, not v3. the defaultv in the definition of v3
04:14:27 <elliott> actually, I don't understand timbod's error at all
04:14:33 <elliott> v3 has a type signature just like v1 and v2
04:14:40 <mauke> timbod: v3 itself is XY Int
04:14:46 <typoclass> elliott: it's odd isn't it
04:14:55 <ChongLi> Andrea_: define your shuffle function not in terms of random numbers
04:15:04 <ChongLi> but just in terms of numbers
04:15:09 <elliott> in particular, if v3 errors then I believe v1 and v2 should error by the same logic. so either I am missing something (likely) or it is a bug
04:15:11 <ChongLi> or pairs of numbers, or whatever
04:15:26 <elliott> timbod: are you sure you don't get an error for v2 or v1 if you comment out v3?
04:15:29 <beaky> @pl h''' = foldr (\c f -> makeGuess c . f) (makeGuess 'a') "1235678" $ h
04:15:29 <timbod> It works if I write: v3 = (defaultv :: XY Int) {xv=x,yv=y}, but I don't understand why it needs this?
04:15:29 <lambdabot> h''' = foldr ((.) . makeGuess) (makeGuess 'a') "1235678" h
04:15:36 <timbod> elliott: yest
04:15:37 <mauke> elliott: you're missing the obvious
04:16:00 <Zariel> Is there a shortcut for doing, do { x <- func; x } ?
04:16:03 <mauke> timbod: how does the compiler know what type defaultv should have?
04:16:10 <mauke> Zariel: join
04:16:11 <elliott> Zariel: join func
04:16:15 <Zariel> danke
04:16:26 <Andrea_> typoclass,  your last hpaste entry ?
04:16:35 <elliott> mauke: well, I think it plausible that all of v1,v2,v3 would fail to type
04:16:38 <timbod> mauke: It knows what type v2 has. Why is v3 different?
04:16:41 <mauke> elliott: why?
04:16:49 <mauke> timbod: how does the compiler know what type defaultv should have?
04:17:12 <timbod> Well. It must be XY t, because of the field names.
04:17:15 <mauke> yes
04:17:18 <elliott> mauke: because of ambiguity in the use of "defaultv". I also think it plausible that they would all succeed to type because the field names disambiguates it; what I cannot see is how v1,v2 would type but not v3.
04:17:30 <timbod> And we are passing an Int , so it should be XY Int ??
04:17:44 <mauke> timbod: in which line?
04:17:59 <timbod> Line 23
04:18:17 <mauke> that's not enough
04:18:20 <shachaf> elliott: v3 can change the type.
04:18:29 <elliott> oh
04:18:44 <typoclass> Andrea_: yes the hpaste entry. later, i also described how you could use the 'permutations' function. i suggest you try that
04:18:59 <beaky> How does the list monad work? what is >>= for lists?
04:19:01 <mauke> timbod: {yv=y} determines the result type but not (directly) the input type of defaultv
04:19:06 <beaky> I think >>= is concatMap
04:19:10 <mauke> beaky: yes
04:19:14 <shachaf> flip concatMap
04:19:22 <beaky> ah
04:19:27 <timbod> shachaf:  I can see that if I assign to both fields, then the type can change. But given we know the type being assigned, what other type could the result be?
04:19:28 <Andrea_> typoclass, perhaps my question was no clean, sorry for my poor english
04:19:43 <beaky> I finally understand monads! monads are so intuitive now
04:19:45 <shachaf> timbod: Look at what mauke said.
04:19:46 <mauke> timbod: defaultv is not the result
04:19:51 <ChongLi> beaky: yay!
04:19:55 <elliott> timbod: the thing is that the defaultv it is changing the type of by replacing the fields could be XY Char or whatever
04:19:55 <mauke> timbod: defaultv is the input
04:19:59 <ChongLi> it's like leveling up in an RPG!
04:20:00 <Andrea_> i want know how to use the random gen ( without IO)
04:20:19 <ChongLi> seriously, that's what it feels like
04:20:28 <Andrea_> the permutations are the second step ( after using the random numbers)
04:20:33 <mauke> timbod: try ':t \foo -> foo{ xv = 0 :: Int, yv = 0 :: Int}'
04:20:43 <beaky> so what does >>= for the IO Monad do?
04:20:50 <mauke> timbod: try ':t \foo -> foo{ xv = 0 :: Int }'
04:20:51 <ChongLi> Andrea_: use a random number to index into the permutations!
04:20:51 <timbod> elliott: Thank you. It's not the result type that is ambiguous, but rather the type of defaultv being used in the expression.
04:21:31 <aNdReA_> brb
04:21:40 <fosskers> edwardk: thanks for the arrow explanation
04:21:49 <edwardk> np
04:23:12 <Zariel> Whats the presedence when doing x <- a where a is of type IO [s]? Do you get a [s] ?
04:23:13 <edwardk> fosskers: don't get me wrong, there may be a use for arrows for some things like the causal commutative arrow trick, etc. but they are very skippable =)
04:23:40 <edwardk> Zariel: <- is syntax, not an operator, so you can consider it above the whole precedence system
04:23:42 <neutrino_> still waiting for someone to come up with a non-crappy ado
04:23:59 <tom39291_> Hi. The following code compiles and works as expected. http://hpaste.org/88598 . Is it possible to write it without expliciting making MyFoo part of Bar (line 15). I'm looking for instance inhertiance, or something similar.
04:24:24 <timbod> mauke: Your two ":t ..." suggestions are insightful also. Thanks.
04:25:29 <fosskers> beaky: Depends on compiler implementation
04:25:43 <beaky> ah
04:25:55 <typoclass> Zariel: and yes. you'll get a [s] in x
04:26:18 <fosskers> (i think) it's the only bind operator that is slightly magic. please somebody shoot me down on this one
04:27:04 <aristid> fosskers: it isn't magic either.
04:27:11 <beaky> all it does it consult IO?
04:27:35 <solirc> beaky: Think of it as a state monad with the "real world" as state ;)
04:27:38 <elliott> tom39291_: I don't understand the purpose of the two classes with identical methods. I realise it's a toy example, but fleshing it out to not have this flaw would make it easier to see what you're getting at and help you model it in a Haskell-ish way
04:27:40 <luite> aristid: unless you count MagicHash as magic ;)
04:27:44 <beaky> ah that isn't so magical then :D
04:28:01 <tom39291_> elliott: I did wonder whether that'd be a problem. I'll flesh it out. :)
04:28:19 <aristid> luite: is MagicHash an IO implementation detail in GHC?</dumbquestion>
04:28:25 <elliott> tom39291_: otherwise my suggestion would just be to drop the extra class :P
04:28:52 <luite> aristid: not really, you just need it because it uses type names with a #, and unboxed tuples
04:29:18 <aristid> luite: ah, because of RealWorld# then?
04:29:27 <luite> aristid: also State#
04:29:31 <aristid> oh and unboxed tuples but isn't that another extension?
04:29:37 <luite> i'm not sure if RealWorld has a hach
04:29:41 <luite> hash
04:29:47 <aristid> heh
04:30:10 <aristid> luite: well i don't think it would change the semantics too much if all these types were boxed, would it?
04:30:17 <aristid> just be a lot slower
04:30:18 <ChongLi> Andrea_: did you solve your problem?
04:30:29 <ChongLi> I just came up with a silly bogoshuffle
04:30:32 <Andrea_> ChongLi, sorry, no
04:30:36 <luite> aristid: right, it would just have to tuple up every result
04:30:49 <ChongLi> indexing into permutations via a random number
04:30:56 <typoclass> Andrea_: does the function 'permutations' make sense to you?
04:31:00 <typoclass> > permutations "cat"
04:31:01 <Andrea_> i want write a function which gives me a random number
04:31:01 <lambdabot>   ["cat","act","tac","atc","tca","cta"]
04:31:30 <ChongLi> f str = randomRIO (0,length str) >>= return $ \i -> (permutations str) !! i
04:31:38 <Andrea_> typoclass, i didn' understand this, can you paste this ?
04:31:38 <aristid> luite:  in a semi-related note i find the analogy of IO as "State RealWorld" not the most intuitive
04:31:58 <elliott> it's unintuitive because it's wrong
04:32:03 <fosskers> haha
04:32:14 <Andrea_> i want call it from an other function
04:32:24 <fosskers> i'm all ears (eyes?) either way
04:32:39 <luite> aristid: in the implementation it's still somewhat magic due to the handling of State# a as a zero-size representation, so running an IO (or ST, STM..) action still looks a bit different
04:32:42 <typoclass> Andrea_: lambdabot just executed the code Â«permutations "cat"Â» and printed the result. just 2 minutes ago
04:33:01 <typoclass> > 4+2 -- here is an example of how lambdabot works
04:33:02 <lambdabot>   6
04:33:52 <Andrea_> 5+1
04:33:58 <Andrea_> hmm
04:34:00 <elliott> > 5+1
04:34:02 <lambdabot>   6
04:34:02 <ChongLi> no you have to prefix with >
04:34:17 <aristid> elliott: the intuition i prefer (i don't want to make a tutorial out of it though, don't worry) is that you build an "action" value that describes all your program does, with every bind allowing the value to react to an input
04:34:17 <luite> aristid: i tend to think of it more as an impementation detail than as an analogy :p
04:34:38 <Andrea_> > 5+1
04:34:40 <lambdabot>   6
04:34:43 <aristid> luite: hence the semi-related, because it's also often proposed as an analogy in tutorials
04:34:44 <Andrea_> ahh
04:35:07 <ChongLi> > let str = "cat" in permutations str
04:35:08 <elliott> aristid: sure. I just think of IO as a free monad that just so happens to violate the language semantics because it's the best we can think about it as it stands
04:35:09 <lambdabot>   ["cat","act","tac","atc","tca","cta"]
04:35:20 <luite> yeah it's tempting to use it
04:35:31 <shachaf> elliott: How do you account for forkIO and exceptions and such?
04:35:48 <Andrea_> this generates all permutations
04:35:52 * elliott thinks GHC should change the name of the whole State# RealWorld thing so people aren't so mislead by it
04:35:57 <elliott> or switch to edwardk's IO representation.
04:36:08 <neutrino_> IOLens
04:36:17 <elliott> shachaf: exceptions are handled under the violating the language semantics part. forkIO I try not to think about
04:36:39 <typoclass> > (permutations "cat") !! 4
04:36:41 <lambdabot>   "tca"
04:36:49 <Andrea_> >permutation "123"
04:37:00 <ChongLi> > let str = "cat" in (permutations str) !! randomR (0,length str) (mkStdGen 123)
04:37:01 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
04:37:01 <lambdabot>              with actual type ...
04:37:06 <neutrino_> just imagine: "foo.txt" ^. unlines ^* permute ^* putStrLn
04:37:11 <ChongLi> oh, right
04:37:12 <typoclass> Andrea_: i suggest you use code like i just showed, but instead of "4", you use a random number. be sure to pay attention to the list length
04:37:20 <ChongLi> > let str = "cat" in (permutations str) !! fst $ randomR (0,length str) (mkStdGen 123)
04:37:22 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
04:37:22 <lambdabot>              with actual type ...
04:37:24 <ChongLi> gah
04:37:35 <ChongLi> > let str = "cat" in (permutations str) !! (fst $ randomR (0,length str) (mkStdGen 123))let str = "cat" in (permutations str) !! (fst $ randomR (0,length str) (mkStdGen 123))
04:37:37 <lambdabot>   <hint>:1:87: parse error on input `let'
04:37:49 <typoclass> ChongLi: close, but note that length str /= length (permutations str). also, try "/query lambdabot" ;-)
04:38:04 <ChongLi> yeah sorry
04:38:09 <ChongLi> I have ghci open in another pane
04:38:15 <chaoslynx> hi, i am trying to install vector and get the error Data/Vector/Generic.hs:197:24: Module â€›Data.Typeableâ€™ does not export â€›Typeable1â€™
04:38:17 <ChongLi> just miss-pasted
04:38:25 <ChongLi> let str = "cat" in (permutations str) !! (fst $ randomR (0,length str) (mkStdGen 123))
04:38:28 <ChongLi> >let str = "cat" in (permutations str) !! (fst $ randomR (0,length str) (mkStdGen 123))
04:38:44 <ChongLi> forget it :)
04:38:53 <Andrea_> > permutations "123"
04:38:53 <chaoslynx> i think it is because i have base-4.7
04:38:54 <lambdabot>   ["123","213","321","231","312","132"]
04:38:56 <elliott> chaoslynx: perhaps you are using a prerelase GHC or something?
04:39:14 <chaoslynx> elliott: yes, i am
04:39:16 <elliott> the Typeable change will require changes to packages to accomodate it. you'll have to patch them yourself in the interim if you want to test the unstable GHC
04:39:19 <shachaf> GHC HEAD changed Typeable. Typeable1 no longer exists.
04:39:26 <Andrea_> this is not that what i want to use
04:39:26 <ChongLi> Andrea_: one thing to keep in mind is that this is not a fast way to get only one permutation if that's all you want
04:39:39 <shachaf> Maybe try HEAD vector.
04:39:49 <elliott> as a rule of thumb you can just remove all the Typeable instances you see. if it's using Typeable1 then try changing it to Typeable. but, I disrecommend porting code to unreleased versions of GHC without understanding the changes :)
04:39:50 <Zariel> I have type as this, String -> IO [Nzb], join should return [Nzb] but it gives me Expected type: IO (IO Nzb)
04:39:53 <ChongLi> Andrea_: you want one permutation, a random one, right?
04:39:55 <shachaf> On the other hand probably HEAD vector doesn't have it.
04:39:59 <Andrea_> i want not search for all possible permutations, i want shuffle a list
04:39:59 <elliott> shachaf's suggestion is a good one.
04:40:10 <chaoslynx> shachaf, ok i will try that
04:40:14 <Andrea_> ChongLi, yes
04:40:31 <ChongLi> http://hackage.haskell.org/packages/archive/random-shuffle/0.0.4/doc/html/System-Random-Shuffle.html
04:40:36 <ChongLi> here is one example
04:40:44 <mauke> Zariel: no
04:40:59 <Andrea_> i want only a function that give me a random number
04:41:07 <typoclass> Zariel: "String -> IO [Nzb]" means that this is a function that you give a String, and it'll produce an IO [Nzb]. have you given it a String?
04:41:10 <ChongLi> Andrea_: oh
04:41:22 <ChongLi> then you just want randomIO
04:41:28 <Zariel> typoclass: yes i gave it a string, i included the full signature for completness
04:41:33 <ChongLi> but it's not a function :(
04:42:03 <Andrea_> ChongLi, i want call this from an other function outside of "main"
04:42:09 <merijn> Zariel: Why should join gie you [Nzb]?
04:42:13 <merijn> :t join
04:42:15 <lambdabot> Monad m => m (m a) -> m a
04:42:20 <ChongLi> Andrea_: sure
04:42:28 <typoclass> Zariel: ok, could you paste the code that you're using? please use hpaste.org if it's > 1 line
04:42:39 <merijn> Zariel: Join means you can turn "IO (IO [Nzb])" into "IO [Nzb]"
04:44:39 <Andrea_> > 3 StdGen
04:44:40 <lambdabot>   Not in scope: data constructor `StdGen'
04:45:16 <adnap> The newest versions of packages never make the first result on Google; it's always some old version and I have to click "Contents" and then the newest version
04:45:23 <adnap> :/
04:45:35 <ChongLi> http://hpaste.org/88600
04:45:48 <ChongLi> Andrea_: see that
04:46:29 <Andrea_> ChongLi, thanks , i will try this in ghci, moment please
04:46:45 <typoclass> Andrea_: here is an example of shuffling a list. http://hpaste.org/88601
04:46:59 <Zariel> typoclass: Here http://hpaste.org/88602
04:47:55 <typoclass> Zariel: ok. when you call parseNzb, you need to be in IO. (for example in main)
04:48:16 <Zariel> typoclass: yep its called from main
04:48:57 <typoclass> Zariel: ok, then there shouldn't be a problem
04:49:19 <Andrea_> thx typoclass, i will try it
04:49:32 <ChongLi> Andrea_: keep in mind that it is slow
04:50:20 <ChongLi> since indexing into a list is linear
04:50:24 <tazjin> there's also "the perfect shuffle" from random-shuffle, as described on http://okmij.org/ftp/Haskell/perfect-shuffle.txt
04:50:49 <ChongLi> yeah I linked random-shuffle earlier
04:51:01 <tazjin> Oh sorry, I joined after that ;)
04:51:42 <Zariel> typoclass: im trying to get the IO [ Nzb ] to return a Nzb instead, though do { nzb <- runX ..; nzb } would return a [Nzb] but it wont
04:52:15 <elliott> there is no IO a -> a. it doesn't work like that
04:52:21 <Andrea_> thanks for your help, i must go
04:52:23 <Andrea_> bye
04:52:30 <ChongLi> unsafePerformIO
04:52:31 <ChongLi> !
04:52:32 <elliott> you do: do { nzb <- blah; ... } and in ... you have nzb :: Nzb
04:52:34 <elliott> and you can use it
04:52:42 <shachaf> ChongLi: Please don't do that.
04:52:48 <ChongLi> haha :)
04:53:05 <ChongLi> yeah, it's usually just a sign that your approach is wrong
04:53:23 <typoclass> ChongLi: beginners often can't tell what's a joke and what isn't. it'll just be confusing, in this case dangerously confusing
04:53:24 <elliott> Zariel: I recommend you read this short introduction: http://www.haskell.org/haskellwiki/Introduction_to_IO
04:53:33 <elliott> Zariel: it will likely help you see how to structure code that uses IO
04:53:35 <shachaf> Not so ":)". Someone is confused about how IO and you're telling them about unsafe functions.
04:53:48 <ChongLi> I understand the temptation though; when you are thinking imperatively you feel "trapped in the monad"
04:53:52 <neutrino_> Zariel: make your function accept [Nzb], and then lift it to IO.
04:54:24 <shachaf> ChongLi: Which is why it's all the worse to tell people to do it.
04:54:35 <neutrino_> "trapped in the monad" sounds like a great name for a psychodrama.
04:54:44 <ChongLi> shachaf: it was sarcasm, I didn't mean it seriously
04:54:52 <shachaf> Right, I know.
04:55:00 <typoclass> ChongLi: to repeat, beginners don't know that
04:55:05 <ChongLi> I think Zariel will see by this reaction that unsafePerformIO is very bad
04:55:06 <shachaf> But the person you're talking to doesn't know that.
04:55:15 <edwardk> unsafePerformIO is never the answer until long after the person doesn't need to ask the question and knows the small handful of places it is applicable.
04:55:42 <shachaf> Whom is the joke addressed at? Regulars have heard it so often that it stopped being funny a long time ago. Beginners don't need to know about it. :-)
04:55:47 <neutrino_> ChongLi: i believe the issue is that we had to go through the ritual of having this reaction to signal this.
04:56:06 <ChongLi> yeah, sorry
04:56:19 <typoclass> ChongLi: rule of thumb, if you want to say unsafePerformIO, instead say ceiling cat
04:56:50 <typoclass> Zariel: one principle in haskell is that you can't call "IO something" in a pure function. it's not possible to have a function "parseNzb :: String -> [Nzb]" if parseNzb calls IO actions. you'll have to structure your program a little differently, but that's usually not a big problem
04:57:41 <ChongLi> what specifically does parseNzb need to do IO for?
04:57:53 <edwardk> shachaf: Its the circle of Haskell, someone asks about getting out of IO, someone mentions unsafePerformIO, because it is technically correct, which is the best kind of correct, and the entire channel reacts saying don't do that and someone learns not to make that suggestion again ;)
04:58:07 <typoclass> ChongLi: beats me :-) i think it's because of runX or something, which i'm not familiar with
04:58:31 <neutrino_> edwardk: hakuna matata :)
04:58:47 <edwardk> neutrino_: clearly i should have tried to make that fit the meter ;)
04:59:02 <edwardk> hasa diga eebowai
04:59:04 <typoclass> edwardk: yes it's all a treadmill! it's all pointless! why even live anymore
04:59:06 <typoclass> =)
04:59:08 <neutrino_> thank you, eltonk :)
05:00:00 <tom39291_> elliott: Compiler errors guided me to the solution: FlexibleInstances and UndecidableInstances. :) http://hpaste.org/88604 is the fleshed out example, fwiw.
05:00:08 <tom39291_> Now to learn what those extensions do!
05:00:16 <elliott> if the solution is UndecidableInstances, your problem might be wrong
05:00:24 <elliott> (not always. it's not nearly as bad as OverlappingInstances or such. but it can be bad.)
05:00:38 <ChongLi> is Zariel still here? I hope he/she didn't get scared
05:00:55 <elliott> tom39291_: note that you cannot declare any other Cipher instances with that instance.
05:01:14 <elliott> it will overlap with them all
05:01:22 <elliott> so I suspect you will find this solution useless in practice
05:01:27 <tom39291_> elliott: Ah... I presume it's undecideable, but can decide if there is only one.
05:01:42 <elliott> it's because only the instance head is looked at for resolution
05:01:45 <elliott> not your constraint
05:01:49 <elliott> compiler just sees "Cipher k" for any k
05:02:27 <elliott> anyway, without changing Cipher I don't think there is any way to achieve your goals of avoiding the "instance Cipher Foo where foo = bar" boilerplate; the correct solution almost certainly involves changing Cipher somehow. maybe Template Haskell could automate your boilerplate writing, though.
05:07:37 * hackagebot wai-extra 1.3.4.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.3.4.2 (MichaelSnoyman)
05:10:01 <beaky> I have finally come up with an appropriate analogy for the IO Monad: The IO Monad is like a magician's hat carried, and on every >>= Haskell performs magic tricks with this hat, pulling stuff out of nowhere and then putting the results back into the hat
05:10:34 <beaky> inside this hat, haskell has superpowers to do things like read files and print stuff
05:10:40 <hpc> beaky: just give up on finding an analogy
05:10:48 <ChongLi> haha
05:10:56 <beaky> yeah, nothing compares to monads :(
05:11:04 <ChongLi> yeah monads defy analogies :)
05:11:04 <typoclass> hpc: "it's all magic" honestly seems like one of the better analogies
05:13:45 <viran> Hey, given a graph G and n nodes  marked from 1 to n. i'd like to find the shortest path from node i to j that does not go through any nodes that are bigger than j (i dont mean the weight of the node, i mean it's node number) could i simply remove the edges from those nodes, and run dijkstra on the graph?
05:14:08 <hpc> viran: yes
05:14:38 <tom39291_> elliott: Thank you. I'll stick with boilerplate for now, and if it becomes so tedious I'll resort to TH. :)
05:14:45 <hpc> viran: if your graph implementation is something like [(node, connecting node)], you can just delete all connections to/from large nodes
05:14:55 <acube> @hoogle (Ord a) => [a] -> a
05:14:55 <lambdabot> Prelude maximum :: Ord a => [a] -> a
05:14:56 <lambdabot> Data.List maximum :: Ord a => [a] -> a
05:14:56 <lambdabot> Prelude minimum :: Ord a => [a] -> a
05:15:03 <amosr> I thought it was like a banana you can unpeel, but the type system stops you from dropping the peel and slipping on it
05:17:03 <hpc> syntactically, (>>=) is used in CPS-style
05:17:09 <hpc> action >>= continuation
05:17:25 <acube> @hoogle (Ord b) => (a -> b) -> [a] -> b
05:17:25 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
05:17:26 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
05:17:26 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
05:17:29 <viran> thanks hpc
05:17:39 <elliott> tom39291_: sorry there's no easy answer :P
05:17:43 <hpc> semantically, it's closer to transforming the continuation from (a -> m b) to (m a -> m b)
05:18:28 <hpc> so ultimately you are writing "your program so far" >>= "the rest of the program"
05:18:35 <hpc> and (>>=) lifts the remainder of your program
05:18:37 <beaky> ah
05:18:50 <beaky> so monads are just the dual of continuations?
05:18:50 <hpc> in the same way that fmap "lifts" an ordinary function
05:18:58 <hpc> no
05:19:28 <shachaf> I should figure out what the intuitive join perspective is, and then start espousing it instead of >>= .
05:19:41 <shachaf> Mainly because it generalized to Applicative more nicely.
05:20:46 <tom39291_> elliott: It feels like that should be possible. Am I missing something, or is it something that isn't worth the possible complexity, given it doesn't save the programmer much (1 line of boilerplate isn't so bad!)?
05:21:08 <elliott> tom39291_: it's just one of the tradeoffs the typeclass system makes, basically
05:21:10 <hpc> shachaf: it's easy to explain, but it doesn't provide an intuitive understanding of do-notation
05:21:19 <elliott> if you were in control of the Cipher class things would be simpler
05:21:26 <chaoslynx> so, i am trying to modify vector to not use Typecast1, but without much success now i get this long error: http://hpaste.org/88605
05:21:29 <elliott> barring that, maybe you can avoid making your additional class entirely or such
05:21:37 <shachaf> hpc: I say: there's an intuitive understand of join hiding somewhere.
05:21:45 <acube> shachaf: how does join generalize to applicative?
05:21:49 <shachaf> I haven't found it quite yet, though.
05:22:12 <shachaf> do { x <- m; y <- n; f x y } becomes join (f <$> m <*> n)
05:22:31 <acube> ah ok, looks nice :P
05:22:34 <shachaf> "join" is the expensive part of Monad's API, vs. Applicative's.
05:22:35 <Hafydd> < hpc> syntactically, (>>=) is used in CPS-style
05:22:43 <shachaf> So if you can minimize joins you're better off.
05:22:50 <Hafydd> Continuation Passing Style style?
05:22:56 <shachaf> Note: I might be wrong.
05:23:08 <hpc> Hafydd: of course!
05:23:12 <shachaf> @localtime
05:23:15 <lambdabot> Local time for shachaf is Sun May 26 05:23:05 2013
05:23:23 <AtKaaZ> hi, i see this on the wiki: "To maintain the friendly, open culture, the following is required: Low to zero tolerance for ridiculing questions. Insulting new users is unacceptable. New Haskell users should feel entirely comfortable asking questions." so I have to ask, shouldn't it be high tolerance for ridiculing questions instead of low/zero tolerance? or what am I missing?
05:23:50 <shachaf> AtKaaZ: "ridiculing" meaning "making fun of"
05:23:58 <hpc> AtKaaZ: ridiculing (v) questions (n)
05:24:05 <Hafydd> High tolerance for ridiculous questions.
05:24:12 <chaoslynx> ok i think i found a patch in ghc Typeable changes to vector while waiting for the upstream to update
05:24:30 <ChongLi> ridiculing questions does seem like an odd phrase
05:24:33 <AtKaaZ> oh, i get it now, if ridiculing is verb yes
05:24:34 <hpc> AtKaaZ: though, if a question is doing the ridiculing we don't want that either ;)
05:24:42 <ChongLi> why not "Low tolerance for ridicule."?
05:24:57 <elliott> AtKaaZ: what a ridiculing question :P
05:25:06 <AtKaaZ> xD
05:25:19 <AtKaaZ> elliott: that's what I thought it meant
05:26:19 <hpc> beaky: anyhoo, the most important part is that you write "your program so far" >>= "the rest of the program" and what (>>=) does is lift "the rest of the program" from (a -> m b) to (m a -> m b)
05:26:48 <AtKaaZ> thanks guys.
05:27:11 <beaky> so >>= is like a burrito
05:27:21 <beaky> I mean, wrapping a thing inside a burrito
05:27:26 <ChongLi> the key thing to realize about (>>=) is that it does different things depending on the monad
05:27:29 <acube> no, wrapping return
05:27:33 <hpc> beaky: exactly what i said, nothing more or less
05:27:35 <acube> wrapping is*
05:27:40 <beaky> ah\
05:28:44 <ChongLi> beaky: it takes a bunch of different, seemingly unrelated things and ties them together based on a pattern
05:30:43 <AtKaaZ> @:t 'a'
05:30:45 <lambdabot> Done.
05:31:07 <AtKaaZ> lol? shouldn't it tell me?
05:31:14 <ChongLi> :t 'a'
05:31:15 <lambdabot> Char
05:31:21 <AtKaaZ> thx
05:32:03 <AtKaaZ> ChongLi, why do I remember your nick from somewhere?
05:32:21 <ChongLi> AtKaaZ: I think I remember yours
05:32:21 <simukis_> does haskell have multiline string literals (like python's '''str''')?
05:32:37 <hpc> simukis_: you escape newlines
05:32:44 <hpc> long = "abcdefg\
05:32:55 <hpc>        \hijklm"
05:32:57 <AtKaaZ> ChongLi, maybe last time I was here, deciding to go with clojure or haskell, and I decided clojure at the time because I wanted on jvm, but now not anymore
05:33:07 <acube> I think the monad's join operator is easier to understand than the >>=
05:33:14 <simukis_> hpc: awesome!
05:33:26 <ChongLi> AtKaaZ: ahh that's it
05:33:32 <no-n> > "a\        \b"
05:33:34 <lambdabot>   "ab"
05:33:37 <ChongLi> I am in #clojure as well
05:34:00 <AtKaaZ> cool
05:34:02 <no-n> ah. that's actually a lot nicer than python's system. because indenting it doesn't screw it up.
05:34:18 <ChongLi> yeah, it's a small world
05:34:27 <ChongLi> I see some people here in other channels I'm on as well
05:34:27 <acube> What does the second \ do?
05:34:33 <acube> mark the end?
05:34:37 <simukis_> > "a\ can you write anything between them? \b"
05:34:39 <lambdabot>   <hint>:1:5:
05:34:39 <lambdabot>      lexical error in string/character literal at character 'c'
05:34:42 <simukis_> ohâ€¦
05:34:48 <shachaf> Any whitespace.
05:35:03 <no-n> > "a\\n\n\n\\b"
05:35:04 <lambdabot>   "a\\n\n\n\\b"
05:35:16 <acube> \\ is just \
05:35:25 <acube> > "a\ \n\n  \b"
05:35:25 <no-n> oh yea
05:35:26 <lambdabot>   "an\n  \b"
05:35:27 <simukis_> shachaf: Yeah, I figured. Was worth trying anyway.
05:35:28 <acube> :O
05:35:46 <no-n> I guess \n is just \n?
05:35:48 <acube> Right, the second \ ends it's
05:35:57 <no-n> oh yea
05:36:48 <ChongLi> the "any whitespace" makes it useful for allowing you to indent your multiline strings into a block
05:37:06 <no-n> *nod*
05:37:10 <ChongLi> without that indentation showing up in the strings
05:38:02 <beaky> what happened to the  Miranda(r) language after haskell became successful?
05:39:19 <ChongLi> as far as I know Haskell cannibalised all the other non-strict languages
05:39:25 <ChongLi> in terms of popularity, anyway :)
05:39:41 <AtKaaZ> so, I am here now: http://book.realworldhaskell.org/read/getting-started.html
05:40:01 <ChongLi> AtKaaZ: ah, so you haven't installed Haskell yet?
05:40:10 <AtKaaZ> ChongLi, I have
05:40:13 <ChongLi> oh good
05:40:23 <AtKaaZ> ChongLi, but I don't know anything xD I did the tryhaskell.org though
05:40:42 <ChongLi> do you have a console window running ghci
05:40:43 <ChongLi> ?
05:40:47 <AtKaaZ> yes
05:40:55 <AtKaaZ> on windows btw
05:41:00 <ChongLi> yeah, so cmd.exe
05:41:17 <AtKaaZ> sort of, apparently it doesn't use it
05:41:26 <AtKaaZ> but it looks the same yes
05:41:41 <ChongLi> scroll down on the web page to the part "Simple arithmetic"
05:41:55 <ChongLi> that's where you actually start writing haskell code :)
05:42:14 <AtKaaZ> Prelude> 2+2
05:42:18 <AtKaaZ> is my prompt:)
05:42:32 <ChongLi> you can also do it in here like this:
05:42:38 <ChongLi> > 2+2
05:42:40 <lambdabot>   4
05:42:43 <AtKaaZ> awesome
05:42:59 <AtKaaZ> 2*(3+2)
05:43:01 <AtKaaZ> > 2*(3+2)
05:43:02 <lambdabot>   10
05:43:13 <ChongLi> > 313 ^ 15
05:43:13 <Aetherspawn_> I recommend learnyouahaskell
05:43:14 <lambdabot>   27112218957718876716220410905036741257
05:43:18 <Aetherspawn_> more than RWH for beginning
05:43:26 <Aetherspawn_> I couldn't understand RWH
05:43:28 <Aetherspawn_> and I still can't.
05:43:31 <tom39291_> elliott: Looks like http://hackage.haskell.org/trac/ghc/wiki/DefaultSuperclassInstances is what I'm after (if it ever gets implemented)
05:43:42 <AtKaaZ> Aetherspawn_, ok thanks, I'll google that
05:44:02 <elliott> tom39291_: I'm not fond of that proposal for various reasons. it's true it would give your desired behaviour in the cases you've shown though
05:44:12 <ChongLi> yeah it's probably better to go through RWH after you feel totally comfortable with everything in LYAH
05:44:50 <Aetherspawn_> @where lyah
05:44:50 <lambdabot> http://www.learnyouahaskell.com/
05:44:53 <AtKaaZ> cool
05:44:55 <Aetherspawn_> AtKaaZ, ^
05:45:00 <AtKaaZ> yep got it
05:45:11 <AtKaaZ> thanks, this info will prove useful
05:45:29 <AtKaaZ> I'll do them in that order
05:45:47 <ChongLi> and it's really only scratching the surface
05:45:58 <ChongLi> it's actually pretty staggering how deep the rabbit hole goes :)
05:46:13 <ChongLi> but there's nothing scary about it
05:46:46 <ChongLi> once you learn to read ghc's error messages, you'll find that the compiler is your friend
05:47:04 <AtKaaZ> sweet
05:47:07 <ChongLi> many times it will tell you things you didn't know!
05:47:28 <mauke> "my brain just exploded"
05:47:36 <ChongLi> it starts to become like piecing together a jigsaw puzzle
05:47:44 <ChongLi> fitting the types together, that is
05:48:17 <ChongLi> although sometimes those puzzle pieces may be recursive
05:48:25 <ChongLi> so don't stare at them or you'll go cross-eyed :)
05:49:44 <shachaf> It's easy to explode GHC's brain.
05:50:18 <beaky> I love ghc
05:50:26 <beaky> it is so easy
05:50:55 <beaky> (but I have never used another haskell implementation)
05:51:24 <AtKaaZ> when I saw it's 40meg exe I was a little amazed
05:51:58 <Botje> every program you can ever write is in there, just with excellent compression.
05:52:23 <ChongLi> except those programs which are not well typed :)
05:52:30 <ChongLi> but you don't want to write those!
05:52:51 <Botje> unless you're a dirty dynamic programming hippie person!
05:53:04 <AtKaaZ> yep, i want to write correct programs xD
05:54:03 <beaky> is it possible to write a memoize function in haskell?
05:54:11 <ChongLi> beaky: yep
05:54:13 <beaky> that takes a function and returns a memoized version of it?
05:54:20 <no-n> LYAH is scratching the surface?
05:54:24 <ChongLi> it can even be a pure function
05:54:27 <beaky> ah\
05:54:36 <beaky> using the ST monad?
05:54:59 <ChongLi> no, unsafePerformIO
05:55:13 * ChongLi ducks
05:55:45 <ChongLi> http://hackage.haskell.org/packages/archive/uglymemo/0.1.0.1/doc/html/src/Data-MemoUgly.html#memo
05:55:56 <ChongLi> here's the code
05:56:21 <elliott> you can write a properly pure memoiser that doesn't use unsafePerformIO.
05:56:26 <beaky> ah :(
05:56:31 <elliott> see e.g. the data-memocombinators package
05:56:48 <beaky> so why is it hard to write a pure one that is elegant?
05:56:59 <Aetherspawn_> because pure means the result never changes
05:57:03 <Aetherspawn_> ;__;
05:57:06 <beaky> ah
05:57:22 <elliott> it's not. you can read the data-memocombinators package yourself. it is elegant
05:57:27 <elliott> it is also not as fast as uglymemo
05:57:34 <beaky> but what if the result doesn't change, but can be computed in a faster way thanks to memoization?
05:57:37 <beaky> ah
05:57:56 <ChongLi> GHC does some of this automatically, by the way
05:58:06 <Aetherspawn_> Wait, I actually misinterpreted that
05:58:08 <Aetherspawn_> forget what I said
05:58:29 <Aetherspawn_> when you said memoization I thought you guys were talking about vars, but now I realise you're talking about the memo stuff (which I read a blog about a couple days ago)
05:59:16 <ChongLi> lazy evaluation could be seen as an optimization of normal order evaluation
05:59:32 <AtKaaZ> i like it a lot
05:59:35 <ChongLi> by memoizing the arguments to functions so that they aren't computed more than once
06:00:15 <ChongLi> AtKaaZ: you like haskell a lot? :)
06:00:42 <AtKaaZ> lazy evaluation I mean:) I don't know haskell yet to say, but from what I'm reading so far I like it a lot too
06:00:50 <beaky> I like functional programming because it can elegantly express other paradigms
06:01:23 <ChongLi> I like it because pure functions feel so warm and fuzzy
06:01:35 <ChongLi> you can reason about them so much more easily
06:01:36 <AtKaaZ> can you use + for two non numbers?
06:01:50 <ChongLi> :t (+)
06:01:52 <lambdabot> Num a => a -> a -> a
06:01:52 <AtKaaZ> yes I like that pure functions idea so far
06:01:57 <ChongLi> nope :(
06:02:06 <ChongLi> there are other functions though
06:02:16 <ChongLi> :t (<>)
06:02:17 <lambdabot> Monoid m => m -> m -> m
06:02:18 <AtKaaZ>  If a function you make takes two parameters and adds them together and you don't explicitly state their type, the function will work on any two parameters that act like numbers.
06:02:24 <AtKaaZ> that "act like numbers" made me ask that
06:02:30 <ChongLi> <> is what you want
06:02:45 <AtKaaZ> ok, i'll get there eventually i guess , still reading
06:02:46 <ChongLi> "act like numbers" you probably mean a Monoid
06:02:58 <AtKaaZ> it's a quote from http://learnyouahaskell.com/introduction#about-this-tutorial
06:03:07 <elliott> LYAH means any type that is an instance of Num.
06:03:19 <elliott> which just means any type that has been given implementations of some basic numeric operations
06:03:29 <elliott> you can read "act like a number" as "is a number", really.
06:03:36 <AtKaaZ> yeah I figured maybe you can override the meaning of + somehow, for other(than Num) types
06:03:57 <AtKaaZ> roger that, ty:)
06:03:58 <elliott> Num isn't a type, it's a typeclass (more like a set of types that implement a common interface) -- but this is getting somewhat ahead :)
06:04:16 <AtKaaZ> yeah too ahead for me at this time :)
06:04:24 <beaky> num is like a family of types
06:04:35 <ChongLi> > "abc" <> "def"
06:04:36 <lambdabot>   "abcdef"
06:04:56 <AtKaaZ> > 1 <> 2
06:04:57 <lambdabot>   Ambiguous type variable `a0' in the constraints:
06:04:57 <lambdabot>    (GHC.Num.Num a0)
06:04:57 <lambdabot>      a...
06:04:57 <no-n> :info Num
06:05:01 <ChongLi> > getSum (Sum 3 <> Sum 4)
06:05:01 <hpc> beaky: a class of types, as it were
06:05:02 <lambdabot>   7
06:05:05 <beaky> ah
06:05:18 <ChongLi> > getProduct (Product 3 <> Product 4)
06:05:19 <lambdabot>   12
06:05:25 <AtKaaZ> interesting
06:05:36 <ChongLi> you see, there are different ways of combining 2 numbers with a monoid
06:05:54 <ChongLi> but with other types (such as lists) there is only one
06:06:05 <elliott> and this is way beyond ahead :P
06:06:11 <AtKaaZ> lol
06:06:13 <beaky> @pl   f (x, y) = if x == c then (x, True) else (x, y)
06:06:14 <lambdabot> f = uncurry (ap ((.) . liftM2 if' (c ==) (flip (,) True)) (,))
06:06:20 <ChongLi> yeah, back to your regularly scheduled reading :)
06:06:25 <AtKaaZ> yeah I'll go back to reading, teasing as that is
06:07:41 <AtKaaZ> btw, what text editors (for haskell code) do you guys use/recommend?
06:07:50 <ChongLi> I use vim
06:07:53 <ChongLi> a lot of others use emacs
06:08:12 <elliott> just about any editor will work
06:08:22 <elliott> sticking with your preferred one is fine
06:08:31 <Philippa> anything you can make do tolerable syntax highlighting and that does indenting/dedenting a space at a time well
06:08:31 <elliott> there is also leksah, an IDE, that you may be interested in
06:08:36 <ChongLi> yeah, just make sure you indent with spaces and not tabs :)
06:09:38 <AtKaaZ> yes ide sounds better, checking that
06:09:59 <ChongLi> don't try to learn a new IDE and a new language at the same time :)
06:10:33 <ChongLi> AtKaaZ: what is your current editor?
06:10:55 <AtKaaZ> like notepad++ or vim
06:10:58 <AtKaaZ> gvim*
06:11:05 <elliott> notepad++ is just fine, lots of people use it, vim too
06:11:17 <AtKaaZ> but notepad++ i use rarely and it does put tabs (but probably easy to make it put tabs from options)
06:11:34 <AtKaaZ> ok so I should postone the ide for later?
06:11:38 <ChongLi> yeah
06:11:47 <AtKaaZ> alrighty:)
06:11:48 <simukis_> Does anyone know something similar? (AnyIOTypeclass) m => m a -> (a -> m b) -> m a
06:12:12 <elliott> simukis_: I don't quite understand your question, could you clarify?
06:12:38 <Aetherspawn_> (MonadIO m) => m a -> (a -> m b) -> m a
06:12:42 <Aetherspawn_> What's the point of that?
06:12:54 <Aetherspawn_> mapM_ .. maybe?
06:12:58 <ChongLi> it allows you to embed IO computations in another monad
06:12:59 <Aetherspawn_> :t mapM_
06:13:01 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
06:13:15 <simukis_> well I have such a pattern $ do a <- some_action; something a; return a
06:13:31 <simukis_> I wondered if I could simplify itâ€¦
06:13:39 <elliott> ah, I see
06:13:51 <elliott> there is (<*), which is like what you said but for (>>)
06:14:05 <elliott> but no, I don't think it is defined anywhere standard
06:14:31 <ChongLi> :t (<*)
06:14:32 <lambdabot> Applicative f => f a -> f b -> f a
06:15:54 <ChongLi> (<*) is like flip (>>)
06:16:04 <no-n> all this crazy <* <> <$> <*> stuff I haven't covered yet lol
06:16:17 <no-n> I just know >>=
06:16:32 <elliott> ChongLi: nope
06:16:46 <ChongLi> is like, not the same :)
06:16:49 <elliott> it is like m <* n = do { x <- m; n; return x }
06:17:01 <ChongLi> oh, hmm
06:17:38 <ChongLi> no-n: have you covered fmap?
06:17:38 * hackagebot sundown 0.5.2 - Bindings to the sundown markdown library  http://hackage.haskell.org/package/sundown-0.5.2 (FrancescoMazzoli)
06:17:40 <acube> no-n: <$> is just fmap.
06:17:50 * Philippa likes <$ - surprisingly fun when doing logic programming
06:18:12 <Philippa> (where you can pronounce it "given")
06:18:20 * acube likes \a p -> a <$ guard (p a)
06:18:45 <Philippa> acube: right, that's a mildly degenerate case of mine :-)
06:18:47 <no-n> > (*2) <$> Just 12
06:18:48 <lambdabot>   Just 24
06:18:51 <acube> @pl (\a p -> a <$ guard (p a))
06:18:51 <lambdabot> liftM2 (.) (<$) ((guard .) . flip id)
06:18:58 <acube> :O
06:18:59 <acube> nice
06:19:11 <acube> flip id ... lol
06:19:13 <no-n> what's <$
06:19:20 <acube> (<$) = fmap const
06:19:25 <acube> it replaces the value in the functor
06:19:28 <acube> @ty (<$)
06:19:29 <lambdabot> Functor f => a -> f b -> f a
06:19:33 <elliott> fmap . const
06:19:35 <acube> > 3 <$ Nothing
06:19:36 <lambdabot>   Nothing
06:19:43 <acube> > 3 <$ Just 10
06:19:44 <lambdabot>   Just 3
06:19:46 <acube> > 3 <$ Just ()
06:19:47 <Philippa> acube: while still performing the effects on the RHS
06:19:48 <lambdabot>   Just 3
06:19:54 <Philippa> that's the important bit!
06:19:55 <ChongLi> > (*) <$> Just 5 <*> Just 10
06:19:56 <lambdabot>   Just 50
06:20:07 <no-n> ah
06:20:22 <Philippa> (so it's good for [constraint] logic programming because asserting constraints - eg equality constraints - is an effect)
06:20:42 <Aetherspawn_> :t flip . id
06:20:43 <lambdabot> (a -> b -> c) -> b -> a -> c
06:20:53 <Philippa> withVar (\x -> x <$ x `eqConstraint` 42)
06:20:55 <AtKaaZ> so 5/2 is stored as 2.5 not as 5/2 right? (unlike in clojure)
06:21:02 <acube> :t flip id `asAppliedTo` (+3)
06:21:04 <lambdabot> Num a => (a -> a) -> ((a -> a) -> c) -> c
06:21:10 <ivanm> > 5%2 -- AtKaaZ
06:21:11 <lambdabot>   Not in scope: `%'
06:21:11 <acube> :t flip id
06:21:11 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
06:21:13 <lambdabot> b -> (b -> c) -> c
06:21:15 <elliott> Philippa: it would be very convenient if it had the effect of making the proposition you're asserting true
06:21:20 <ivanm> > 5 R.% 2 -- AtKaaZ
06:21:21 <lambdabot>   5 % 2
06:21:24 <elliott> I could save so much time in arguments!
06:21:41 <no-n> :}
06:21:54 <Philippa> elliott: a suitable applicative will /either/ do that or blow the world it inhabits up, good enough? :p
06:22:34 <Philippa> hi edwardk - I'm just explaining why I pronounce <$ as "given"
06:23:09 <elliott> Philippa: works for me. who would want to live in a world where I'm wrong?
06:23:44 <Philippa> we can settle for the one where you're vacuously correct!
06:24:22 <beaky> http://hpaste.org/88608 why is the output of my program out of order?
06:24:31 <beaky> it prints the hangman twice every turn, for example
06:24:39 <AtKaaZ> ivanm: http://hpaste.org/88607
06:26:21 <AtKaaZ> ChongLi: I remembered there's winghci which looks better(colors) than just ghci(console version)
06:26:43 <acube> beaky: How does your output look like?
06:27:15 <ChongLi> > getZipList $ (,) <$> ZipList [1,2,3] <*> ZipList "abc"
06:27:16 <lambdabot>   [(1,'a'),(2,'b'),(3,'c')]
06:27:26 <acube> beaky: Everything duplicated?
06:27:28 <AtKaaZ> ivanm: i'll take that as it's possible, and I'll probably get to it later, thanks
06:27:49 <acube> beaky: Maybe you're reading the \n char with getChar?
06:27:55 <ivanm> AtKaaZ: yeah, the R. bit is just for lambdabot
06:27:59 <ivanm> @hoogle (%)
06:27:59 <lambdabot> Data.Ratio (%) :: Integral a => a -> a -> Ratio a
06:28:10 <ivanm> AtKaaZ: ^^ import Data.Ratio
06:28:32 <AtKaaZ> awesome!
06:28:55 <beaky> acube: aha that's why
06:29:06 <beaky> is there a version of getchar that doesn't read the newline?
06:29:10 <beaky> maybe I should use reads
06:29:44 <beaky> :t reads
06:29:46 <lambdabot> Read a => ReadS a
06:29:57 <acube> beaky: You could use getLine and then take the head of that string
06:30:04 <acube> @ty head <$> getLine
06:30:05 <lambdabot> IO Char
06:30:11 <ChongLi> or turn off buffering?
06:30:18 <acube> or that :P
06:30:19 <elliott> (note that that will make your program crash if you enter an empty line)
06:30:22 <acube> yes
06:30:32 <elliott> yes, hSetBuffering stdin NoBuffering will cause keys to be processed immediately without the newline
06:30:55 <beaky> ah thanks
06:30:57 <acube> that's probably the best solution
06:32:34 <ChongLi> how do you make the program crash?
06:32:49 <ChongLi> getChar just returns '\n' if I hit enter with buffering off
06:33:02 <elliott> oh, right.
06:33:08 <elliott> wait, no
06:33:12 <elliott> getLine returns empty string on empty line, I'm pretty sure
06:33:16 <elliott> so head <$> getLine will error out
06:33:23 <ChongLi> yeah
06:33:31 <ChongLi> use a safe version of head :)
06:33:34 <beaky> yay my hangman game is don :D
06:33:39 <beaky> done**
06:33:39 <elliott> well, i was replying to acube
06:33:47 <ChongLi> ohhh
06:33:56 <beaky> it is even more efficient than my C++ version
06:34:08 <beaky> but it looks very inelegant :(
06:34:50 <ChongLi> beaky: that's ok!
06:35:55 <fruitFly> what's wrong with this? http://ideone.com/jhbFrU I'VE gotten this function to work with word8 already?
06:36:19 <ChongLi> beaky: you may see ways to make it more elegant in the future
06:36:24 <ChongLi> for example, with lenses :)
06:36:43 <Botje> :t shiftR
06:36:45 <lambdabot> Bits a => a -> Int -> a
06:36:50 <beaky> @pl f >>= \h -> g h >> i h
06:36:51 <lambdabot> liftM2 (>>) g i =<< f
06:37:29 <Botje> fruitFly: shiftR x 2 will produce a Word8 again.
06:37:56 <Botje> you'll need a fromIntegral call there :[
06:38:00 <fruitFly> Botje: aaaaah ... woops.. ok i c... :D... thanks
06:38:42 <Botje> fruitFly: also, shiftL x 6 / 4 looks fishy
06:39:08 <Botje> also also, consider adding parentheses to the stuff between the :
06:39:35 <fruitFly> Botje: doe I need to add parens between the cons?
06:39:44 <Botje> you don't need to
06:40:18 <Botje> but it makes it a bit more readable
06:41:02 <fruitFly> Botje:  isn't shiftL x 6 / 4  the same as (shiftL x 6) / 4
06:41:52 <Botje> fruitFly: yes.
06:42:34 <Botje> under Int that would be the same as shiftL x 4
06:42:45 <Botje> but under Word8 it's indeed different :)
06:44:10 <Botje> so nevermind, just tripped me up
06:46:33 <fruitFly> how do I divide a word8? I know it will still be a non fractional word8?
06:46:33 <fruitFly> http://ideone.com/jhbFrU
06:50:24 <Botje> use the div function instead
06:50:45 <Botje> or shiftR.
06:51:48 <fruitFly> Botje: actually that's a good idea
06:52:07 <beaky> does haaskell have bits?
06:52:21 <beaky> like unsigned 8-bit ints and bitshifting and bitwise ops?
06:52:32 <fruitFly> data.bits
06:52:32 <fruitFly> beaky: yes
06:52:32 <fruitFly> data.bits
06:52:42 <beaky> ah thansks
06:53:00 <beaky> :t data.bits.bits
06:53:02 <lambdabot> parse error on input `data'
06:53:26 <beaky> wow this is awesome
06:53:27 <alcatraz63> Data.Bits is a package
06:53:40 <beaky> can you use haskell to porgram arduino?
06:54:43 <elliott> alcatraz63: no, it's a module inside the base package
06:55:50 <Botje> beaky: you can generate C code with the atom package
06:56:06 <beaky> ah
06:56:16 <geekosaur> http://hackage.haskell.org/package/hArduino
06:56:43 <geekosaur> hm, actually not fr programming it, sorry
06:58:01 <elliott> I should find an excuse to play with atom sometime
06:58:20 <alcatraz63> elliot: yeah, wrong language, package as in scala/java, guess my brain is still stuck there
06:58:21 <Peaker> Why does showsPrec send the outer precedence in, rather than returning a precedence out?
06:58:49 <beaky> @pl \(x, y) -> if y then x else 'X'
06:58:49 <lambdabot> uncurry (flip flip 'X' . flip if')
06:59:05 <beaky> :t if'
06:59:06 <lambdabot>     Not in scope: if'
06:59:06 <lambdabot>     Perhaps you meant f' (imported from Debug.SimpleReflect)
06:59:22 <Peaker> if' :: Bool -> a -> a -> a
07:00:06 <beaky> @pl \x y z -> if x then y else z
07:00:07 <lambdabot> if'
07:00:30 <beaky> @djinn Bool -> a -> a -> a
07:00:30 <lambdabot> f a b c =
07:00:30 <lambdabot>     case a of
07:00:30 <lambdabot>     False -> c
07:00:30 <lambdabot>     True -> b
07:00:36 <beaky> wow
07:00:43 <geekosaur> if' is a lie :)
07:02:42 <beaky> is there a version of <*> that applies thigs element by element?
07:05:46 <ChongLi> beaky: not sure what you mean
07:06:05 <yitz> beaky: <*> is a member of a type class. so there can be only one implementation of it for any given type.
07:07:10 <beaky> ah
07:07:19 <ChongLi> :t (+) <$> [1,2,3]
07:07:21 <lambdabot> Num a => [a -> a]
07:07:24 <beaky> oh there are *> and <* too
07:07:29 <ChongLi> this gives us a list of functions
07:07:52 <ChongLi> with <*> we can apply it to a list of values
07:08:03 <beaky> > (,) <$> [1..10] <*> [False]
07:08:04 <lambdabot>   [(1,False),(2,False),(3,False),(4,False),(5,False),(6,False),(7,False),(8,F...
07:08:10 <beaky> is there a better way of doing this?
07:08:26 <ChongLi> better how?
07:08:27 <beaky> > [(i, False) | i <- [1..10]]
07:08:29 <lambdabot>   [(1,False),(2,False),(3,False),(4,False),(5,False),(6,False),(7,False),(8,F...
07:08:34 <beaky> neater
07:09:15 <acube> Are there alternatives to stylish-haskell that don't use haskell-src-exts for parsing? Because that fails for some TH declaration quotes and for DefaultSignatures
07:09:52 <yitz> > map (flip (,) False) [1..10]
07:09:53 <lambdabot>   [(1,False),(2,False),(3,False),(4,False),(5,False),(6,False),(7,False),(8,F...
07:10:31 <simukis_> :q
07:10:33 <simukis_> eh :D
07:10:36 <ChongLi> > map (,False) [1..10]
07:10:38 <lambdabot>   Illegal tuple section: use -XTupleSections
07:10:45 <beaky> aww I wish you can do that
07:10:46 <ChongLi> yeah, there you go
07:10:55 <ChongLi> you can, just use -XTupleSections
07:11:03 <ChongLi> lambdabot doesn't use it though
07:11:13 <beaky> is it bad to use haskell extensions?
07:11:28 <ChongLi> it is if you want to be portable to non-GHC compilers
07:11:37 <acube> Who wants that?
07:11:56 <beaky> I thought ghc was the only haskell compiler in existence
07:12:02 <ChongLi> nope :)
07:12:14 <beaky> so much that haskell is defined as "the language that GHC accepts"
07:12:48 <ChongLi> Hugs, NHC, YhC, UHC
07:12:51 <geekosaur> there are other compilers, but mostly not as complete
07:12:53 <geekosaur> jhc
07:13:11 <ChongLi> GHC is by far the most popular
07:13:33 <acube> A lot of packages use a lot of GHC extensions
07:17:34 <beaky> so the GNU Haskell compiler is based on GCC?
07:18:03 <Peaker> nope
07:18:24 <ChongLi> ghc is not GNU
07:18:27 <beaky> ah
07:18:31 <beaky> I thought g stood for gnu
07:18:36 <hpc> beaky: i suggest looking it up
07:18:36 <ChongLi> the g stands for Glasgow
07:18:54 <simukis_> Glorious Glasgow Haskell Compiler, isn't it?
07:19:07 <hpc> glorious glasgow haskell compilation system
07:19:18 <hamid> GNU Haskell compiler is fun to hear of, btw
07:19:58 <beaky> so ghc is the smartest compiler in the universe?
07:20:08 <acube> No
07:20:32 <ChongLi> no that'd probably be stalin scheme, no?
07:20:54 <simukis_> You're rather humble people, huh?
07:20:58 <acube> I heard that jhc sometimes produces faster results than ghc
07:20:59 <beefcube> beaky: my PL professor thinks it's one of the most "advanced"
07:21:10 <Peaker> hmm... ~/.cabal/bin is in my $PATH, but somehow when I run "make", it loses that part of the $PATH before hitting the cabal command
07:21:34 <chuzz> hmm i switched to hdevtools on syntastic and vim but i still have problems, how do i make it recognize the import of the Paths_* module
07:21:41 <beefcube> beaky: in that he has trouble understanding how they accomplished some of the things in it
07:22:25 <Peaker> oooh, $PATH having ~ works in many contexts, but not in GNU make context
07:22:43 <acube> Peaker: you can use $HOME
07:22:53 <beaky> yeah it's astonishing how a high-level language can be made so efficient
07:22:59 <beaky> or is it not magic?
07:23:05 <Peaker> acube, yeah, fixed
07:23:17 <Peaker> acube, was weird that only make was failing the commands that worked everywhere else
07:24:09 <beaky> @pl f >>= \x -> g >>= \y -> return $ h x y
07:24:09 <lambdabot> (`fmap` g) . h =<< f
07:24:31 <beaky> :t liftM2
07:24:32 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
07:26:21 <acube> chuzz: I'm using a wrapper for hdevtools that adds some -g options, on emacs
07:26:33 <acube> chuzz: it's really ugly, but it works
07:28:42 <acube> chuzz: http://hpaste.org/88611, highly tailored to my needs, maybe it helps
07:28:56 <acube> chuzz: I don't know if there is a better way
07:31:02 <chuzz> acube: thanks, i'll try those options
07:32:54 <beaky> C++ is an elegant programming language
07:32:58 <beaky> oops typo
07:39:34 <jmcarthur> http://www.reddit.com/r/archlinux/comments/1f26hg/why_does_haskell_suck_on_arch/
07:47:35 <Andrea_> ChongLi, i found a solution for my problem
07:47:58 <ChongLi> oh good
07:48:06 <Andrea_> this take 5 (randomRs (3,10) (mkStdGen a ))
07:48:22 <Andrea_> only an example
07:48:31 <Andrea_> this works without IO
07:51:27 <elliott> but the results will always be the same with the same "a".
07:54:40 <Andrea_> > take 4 ( randomRs ( 1,6) ( mkStdGen 13))
07:54:41 <lambdabot>   [6,2,1,4]
07:56:48 <acube> > > take 4 ( randomRs ( 1,6) ( mkStdGen 13))
07:56:49 <lambdabot>   <hint>:1:1: parse error on input `>'
07:56:50 <acube> > take 4 ( randomRs ( 1,6) ( mkStdGen 13))
07:56:52 <lambdabot>   [6,2,1,4]
07:57:02 <Andrea_> > take 4 ( randomRs ( 1, 6) (mkStdGen 12))
07:57:03 <lambdabot>   [6,3,2,5]
08:02:26 <nooodl> http://hpaste.org/88613 <- how do i turn lines 24-29 into something that gives me an infinite list [a0, a1, a2, ...]?
08:03:18 <nooodl> looks like i'd need something like... iterateM?
08:07:52 <AtKaaZ> "hello" is just syntactic sugar for ['h','e','l','l','o']   How do you make "hello" show like that? what do you call?
08:07:53 <elliott> nooodl: you have two options: 1. use unsafeInterleaveIO 2. use randoms
08:08:12 <mauke> AtKaaZ: ghostbusters
08:08:20 <elliott> AtKaaZ: nothing, strings show like strings always. you can write a function to show it in list form if you'd like
08:08:21 <AtKaaZ> lol
08:08:45 <AtKaaZ> elliott: ok, I thought maybe it already existed
08:08:47 <mauke> :t printf "[%s]" . intercalate "," . map show
08:08:49 <lambdabot> (Show a, PrintfType c) => [a] -> c
08:09:00 <mauke> > (printf "[%s]" . intercalate "," . map show) "hello" :: String
08:09:02 <lambdabot>   "['h','e','l','l','o']"
08:09:08 <AtKaaZ> neat
08:09:10 <elliott> that printf :'(
08:09:35 <nooodl> :t unsafeInterleaveIO
08:09:37 <lambdabot> Not in scope: `unsafeInterleaveIO'
08:09:38 <mauke> AtKaaZ: ['a','b','c'] is just syntactic sugar for 'a' : ('b' : ('c' : []))
08:09:52 <elliott> nooodl: i recommend 2.
08:10:02 <nooodl> yeah but 1. is so interesting
08:10:18 <AtKaaZ> mauke: I don't know what : does yet
08:10:30 <mauke> AtKaaZ: : is the thing lists are built from
08:10:44 <Kneiva> : is cons
08:10:53 <nooodl> > 3 : [4,5,6]
08:10:54 <lambdabot>   [3,4,5,6]
08:11:33 <AtKaaZ> oh cons, got it, i didn't see the [] at the end
08:11:40 <AtKaaZ> it make sense now
08:12:58 <gilligan_> hi .. haskell newbie here ;-) could someone help me out with an accordingly simple question ? hpaste.org/88614 : what is the correct type info for calcMean ? I am getting a bit confused here. I thought i /must/ use fromIntegral but apparently not .. Some hints would be appreciated ;)
08:14:10 <Fuuzetsu> gilligan_: You can always ask GHC about the type of something.
08:14:27 <gilligan_> yeah, i did that
08:14:51 <gilligan_> oh, hm..
08:15:06 <gilligan_> calcMean :: Fractional a => [a] -> a
08:15:09 <gilligan_> makes perfect sense
08:16:00 <Fuuzetsu> Is your issue resolved then?
08:16:02 <gilligan_> ah.. think it was a 'hick up' with my set up here.. got cached hslint responses so to say
08:16:46 <gilligan_> Fuuzetsu: well, almost hehe
08:17:14 <Fuuzetsu> gilligan_: By the way, your signatures are too restrictive
08:17:16 <Andrea_> this perhaps calcMean:: [a] ->a
08:17:16 <gilligan_> Fuuzetsu: assuming Fractional certainly works .. but is it right ? i mean i could very well call this on [1,2,3] which is not Fractional
08:17:23 <Fuuzetsu> neither elemCount nor sumUp need (Num a)
08:17:52 <AtKaaZ> mauke: i got to that part in the book where they say what you said:)
08:18:10 <elliott> gilligan_: [1,2,3] works just fine as a list whose elements are of Fractional type
08:18:20 <elliott> "1" isn't an integer, it's polymorphic: it works as any numeric type
08:18:30 <Fuuzetsu> sumUp = sum; elemCount = length;
08:18:42 <gilligan_> elliott: right okay thanks
08:19:36 <gilligan_> well thanks a lot for the quick help
08:20:25 <elliott> :)
08:21:46 <gilligan_> any vim users in here by the way ? there doesn't seem to be any really good haskell indentation script ? any suggestions ? The builtin indentation from vim runtime will just totally break code on indentation. I'm using vim2hs which comes with a somewhat better indentation support but that still seems far from perfect
08:22:19 <gilligan_> or maybe i am just picky? :)
08:24:08 <Andrea_> gilligan_, calcMean :: (Fractional a) => [a] -> a
08:24:19 <Andrea_> correct ?
08:24:42 <gilligan_> Andrea_, yep
08:25:00 <hpc> gilligan_: i write my code in vanilla vim; you don't really need autoindent
08:25:45 <AtKaaZ> omg yes! i wanted this: head [] *** Exception: Prelude.head: empty list
08:25:55 <gilligan_> hpc, well sure. just a matter of comfort .
08:26:22 <Cale> AtKaaZ: Most people dread seeing that
08:27:26 <AtKaaZ> not me, I love it! in clojure you can get away with it ie. (first []) (first [nil]) both return nil
08:27:36 <Cale> oh, I see :)
08:27:40 <osfameron> !
08:28:00 <Cale> Well, you might love it a little less when you get that runtime error and nothing more from a giant program :)
08:29:35 <AtKaaZ> lol well i assume there's a way to stacktrace?
08:29:48 <Cale> There's no stack to trace
08:30:01 <AtKaaZ> nothing to show location maybe?
08:30:05 <Cale> (well, no call stack anyway)
08:30:14 <Cale> There are some tools you can use
08:30:28 <AtKaaZ> after you get the error?
08:30:35 <AtKaaZ> or have to use them from before
08:30:46 <mekeor> why is there a (=<<) but no (<<) ? :(
08:31:02 <Cale> For one, if you turn on profiling, you can get a "cost centre stack trace" which isn't quite the same as a real stack trace, but it'll at least give you a general idea of where in the code you were.
08:31:04 <ChongLi> ahhh, the old favourite: *** Exception: Prelude.head: empty list
08:31:12 <hpc> mekeor: the order of actions for (<<) is unclear
08:31:16 <Cale> You'll have to re-run your program
08:31:36 <hpc> mekeor: see - the difference between (<*) and (flip (*>))
08:31:44 <Cale> If you just get that error in a normally compiled program, you'll get no information about which head caused the problem
08:31:51 <mekeor> hpc: oh uhm okay... O.o
08:31:52 <AtKaaZ> Cale, in that case I'll make sure it's always on
08:32:06 <AtKaaZ> can the exceptions be caught?
08:32:12 <AtKaaZ> that is if you coded the catch
08:32:17 <Cale> From IO, awkwardly
08:32:25 <hpc> AtKaaZ: you don't want to try and catch exceptions in haskell
08:32:33 <hpc> there's better ways of handling such things
08:32:39 <AtKaaZ> ok
08:32:50 <Cale> You shouldn't write pure code with the intention of catching any exceptions you throw
08:33:12 <Cale> (and instead represent failure cases explicitly by values, unless you're pretty sure that they really can't occur)
08:33:13 <AtKaaZ> i was thinking maybe catch them and say where it is but still allow it to throw
08:33:34 <Cale> If you write (\(x:xs) -> x) instead, then at least it'll tell you which line the pattern match failure occurred on
08:34:41 <Cale> But it's better just to avoid using head in any case where you're not 100% certain that the list is nonempty, and instead use case to pattern match and handle both cases at once.
08:35:09 <ChongLi> Cale: what about libraries that throw exceptions?
08:35:31 <ChongLi> isn't there some http library that throws exceptions on 404s?
08:35:52 <Cale> Presumably it would do that as an IO action
08:36:06 <Cale> Exceptions thrown by the execution of IO code are no problem
08:36:21 <Ke> this is where java beats haskell, since all exceptions need to be documented in type
08:36:26 <Cale> exceptions thrown by evaluation of expressions by calls to 'error' are very fiddly to catch
08:36:53 <latro`a_> properly-designed exceptions need to be documented in type in haskell as well
08:37:04 <latro`a_> it's just exceptions from pure code that are screwy
08:37:07 <Cale> Well, if you want the sort of exception which has to be documented in the type, then you can use Either
08:37:44 <mauke> Ke: not all. half of them
08:38:26 <Cale> In the semantics, applications of error or undefined are treated as producing the same value as an infinite loop does.
08:38:44 <Cale> and that should be a generally useful guideline for when to use those
08:38:56 <Cale> (when you think you could get away with sticking an infinite loop in that position)
08:39:28 <Cale> i.e. you're fairly sure that code won't run
08:40:05 <Kneiva> :r
08:40:07 <Cale> So things like head which make calls to error have unusually important preconditions on their use, I suppose.
08:40:08 <Kneiva> oops
08:40:19 <ChongLi> undefined is nice for stubbing out functions with type annotations
08:41:16 <Cale> Right, and you could also use infinite loops to do that, undefined is just a convenient one which happens to finish quickly if you hit it :)
08:42:24 <blueonyx> hi, is there some statistics lib which helps with [[http://en.wikipedia.org/wiki/ABX_test|ABX testing]], so i just have to add my frontend and media files?
08:43:24 <blueonyx> oh, i just read the german wiki page, the english one seems to explain the algorithm xD
09:03:14 <AtKaaZ> > [x*2 | x <- [1..10], x*2 >= 12]
09:03:15 <lambdabot>   [12,14,16,18,20]
09:03:33 <AtKaaZ> is there some way to refer to the first x*2 in the predicate ? so that it's not computed twice
09:05:03 <mauke> > [y | x <- [1 .. 10], let y = x * 2, y >= 12]
09:05:04 <lambdabot>   [12,14,16,18,20]
09:05:29 <AtKaaZ> wow i like it
09:28:18 <liyang> Axman6: have you been looking at Lava?
09:30:22 <Learningg> HQ SQLi's found by hack_addicted.pt
09:38:51 <mekeor> is <http://hub.darcs.net/mekeor/Control.Monad.MapA/browse/src/Control/Arrow/MapA.hs> (â† code | examples â†’ <http://hub.darcs.net/mekeor/Control.Monad.MapA/browse/README>) suitable generally?
09:39:37 <fruitFly> what's wrong with this? http://ideone.com/hpx4T6 I'm trying to divide a word8
09:40:04 <fruitFly> note: I always will get a non fraction
09:40:15 <mekeor> fruitFly: did you mean to use `div` instead of 'div'?
09:40:31 <fruitFly> mekeor: I guess so lol .. thanks
09:40:57 <hpc> fruitFly: if your font makes it hard to tell the difference, you should probably configure your editor
09:41:07 <mekeor> fruitFly: np :) btw, do you know hpaste? ;)
09:41:31 <FreeFull> `` is for infix functions, '' is for character literals =P
09:41:51 <fruitFly> mekeor: never really used it ... i dnt have a computer so am developing on ideone.com
09:42:09 <mekeor> oh i see :)
09:42:17 <fruitFly> omg http://ideone.com/hpx4T6
09:42:30 <fruitFly> is there an index limit for (!!)
09:43:27 <hpc> fruitFly: it only goes up to 999
09:43:52 <hpc> (not really, but you should consider using something else; (!!) is not a particularly great function)
09:44:13 <enthropy> > maxBound :: Int
09:44:15 <lambdabot>   9223372036854775807
09:44:21 <geekosaur> fruitFly, lists are not vectors or arrays, indexing them is slow
09:44:26 <FreeFull> fruitFly: I wonder why you use emptyList instead of []
09:44:58 <fruitFly> FreeFull: does it use more memory?
09:45:20 <fruitFly> geekosaur:  how do I check what elem is at index i in a list?
09:45:39 <enthropy> > [1,2,3] !! 3
09:45:40 <lambdabot>   *Exception: Prelude.(!!): index too large
09:45:41 <FreeFull> fruitFly: There is nothing called emptyList in Haskell
09:46:00 <FreeFull> The way you use it there has it work the same as rest
09:46:50 <fruitFly> FreeFull: I know. I just wrote it that way for clarity. I am not operating on empty list ... lol I guess I should just put [] then
09:47:08 <fruitFly> indexes or indices?
09:47:52 <liyang> Indices, always.
09:48:33 <geekosaur> fruitFly, the question is, if youre using an index, why are you using a list instead of a vector?
09:48:53 <geekosaur> you know how to index a list. the question is whether you understand why that's generally the wrong way to do it
09:49:06 <fruitFly> geekosaur: because I'm a noob and have not even learned about vectors lol
09:49:08 <arnsholt> Both indexes and indices work. Indices is the Latin plural, while indexes is the more straightforward English formation
09:50:15 <fruitFly> arnsholt: i feel like indexes is for different types and indices is for the same type ... like fish for multiple salmon versus fishes for multiple fish of different types... maybe I'm totally wrong here though
09:51:23 <arnsholt> I guess. I'd say several database indexes, but probably array indices
09:51:35 <arnsholt> But I wouldn't really object to array indexes either, TBH
09:51:59 <fruitFly> geekosaur: I don't see how my index is too large here http://ideone.com/hpx4T6 but you think I should read up on vectors... I haven't even read the modules chapter in lyah yet though?
09:52:20 <fruitFly> arnsholt: ok cool... thanks :)
09:52:41 <geekosaur> if you want to use list indexing, just use it. try to remember that it's a bad idea though
09:52:54 <geekosaur> and don't start with a question about the limits of list indexing
09:53:10 <geekosaur> because that's just inviting what you apparently don't want to think about
09:54:00 <arnsholt> I'm a bit liberal when it comes to this though. I've a background in Classics, so people misusing Greek or Latin inflection (octopi, for example) annoys me a lot more than just sticking the normal English inflection on the end
09:55:06 <enthropy> fruitFly: "| i < 52 = (!!) ['a'..'z'] (fromEnum i)" should probably be something like  | i < 52 = (!!) ['a'..'z'] (fromEnum i - 26)
09:56:39 <fruitFly> enthropy: why?
09:57:02 <enthropy> because if i is 51, you're asking for the 52nd element of a list that only has 26 things in it
09:57:34 <AtKaaZ> what does fromEnum do?
09:58:03 <enthropy> maybe it's simpler to have the conversion as something like     (['A' .. 'Z' ] ++ ['a' ... 'z'] ++ "+/=") !! i
09:58:03 <fruitFly> enthropy: oh shit lol... i c
09:58:06 <AtKaaZ> > fromEnum 'a'
09:58:07 <lambdabot>   97
09:58:13 <simukis_> AtKaaZ: Converts enumeration to it's numeric value.
09:58:20 <AtKaaZ> simukis_: cool thanks
09:59:04 <fruitFly> AtKaaZ: i'm using it to convert a word8 (8 bit unsigned integer used for binary to an Int)
09:59:26 <AtKaaZ> sweet
09:59:27 <fruitFly> AtKaaZ: )* to an Int
09:59:55 <fruitFly> enthropy: I think your idea is good :)
10:00:31 <Shou> How would I give something of kind `* -> (* -> *) -> * -> *' a Typeable instance?
10:00:47 <acube> Is there a way I can produce "infinity" without using 1/0
10:00:48 <acube> ?
10:00:54 <acube> > 1/0 :: Int
10:00:55 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
10:00:55 <lambdabot>    arising from a use o...
10:00:59 <AtKaaZ> hey guy, btw here: http://www.haskell.org/haskellwiki/Haskell_in_5_steps   at Tutorials below, maybe put the last one first? since it's from there that I got to RWH
10:01:01 <acube> Oops
10:01:12 <Shou> read "Infinity" :: Double
10:01:30 <enthropy> Shou: one choice is something like: instance (Typeable a, Typeable1 b, Typeable c) => Typeable (F a b c)
10:02:15 <beaky> > [1..10] >>= \_ -> [3]
10:02:17 <lambdabot>   [3,3,3,3,3,3,3,3,3,3]
10:02:27 <beaky> wow how does that work
10:02:36 <AtKaaZ> > read "Infinity" :: Double
10:02:37 <lambdabot>   Infinity
10:02:44 <AtKaaZ> Shou, cool
10:03:07 <acube> @src [a] >>=
10:03:08 <lambdabot> Source not found. My mind is going. I can feel it.
10:03:10 <simukis_> Isn't [] just a sytactic sugar for monad construction?
10:03:15 <acube> @src [] >>=
10:03:15 <lambdabot> Source not found. Where did you learn to type?
10:03:21 <acube> @src >>= [a]
10:03:21 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:03:33 <beaky> > [1..10] >>= \_ -> return 0
10:03:35 <lambdabot>   [0,0,0,0,0,0,0,0,0,0]
10:03:35 <Shou> enthropy, thanks, but what do I put in there `where'?
10:03:42 <Shou> Or do I just derive that?
10:03:48 <enthropy> Shou: -XStandaloneDeriving probably works
10:03:49 <acube> beaky: for lists, x >>= f = concatMap f x
10:03:52 <beaky> ah
10:04:01 <Shou> enthropy, alright, I'll give it a shot. Thanks!
10:04:22 <simukis_> acube: instance  Monad []  where
10:04:24 <simukis_>     m >>= k             = foldr ((++) . k) [] m
10:04:25 <beaky> > concatMap (\_ -> [3]) [1..10]
10:04:26 <lambdabot>   [3,3,3,3,3,3,3,3,3,3]
10:04:37 <NemesisD> does finally re-throw?
10:04:40 <acube> @src concatMap
10:04:40 <lambdabot> concatMap f = foldr ((++) . f) []
10:05:34 <simukis_> code duplication ðŸ˜’
10:08:11 <acube> @hoogle (Monad m) => ([a] -> a) -> [m a] -> m a
10:08:11 <lambdabot> Foreign.Marshal.Utils withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
10:09:10 <crdueck> :t \f -> fmap f . sequence
10:09:11 <lambdabot> (Monad f, Functor f) => ([a] -> b) -> [f a] -> f b
10:09:22 <acube> crdueck: That's the function, yes
10:11:32 <Shou> enthropy, I tried `deriving instance (Typeable s, Typeable1 m, Typeable a) => Typeable (StateT s m a)' but GHCi returned "`StateT' must only have arguments of kind `*'" :c
10:13:36 <acube> Shou: instance (Typeable s, Typeable1 m)  => Typeable1 (StateT s m) where typeOf1 _ = mkTyCon3 "pkgname" "modulename" "StateT" `mkTyConApp` [typeOf (undefined :: s), typeOf1 (undefined :: m)]
10:13:40 <enthropy> Shou: then I guess you have to make up the TypeRep yourself
10:14:37 <enthropy> that needs -XScopedTypeVariables I think
10:14:40 <acube> yes
10:15:01 <enthropy> it's not worth doing it without that extension
10:15:32 <fruitFly> mm_freak: omg it works http://ideone.com/hpx4T6
10:15:43 <acube> I'm not an expert in this, just started messing around with Typeable some days ago so that instance might not be correct
10:16:04 <fruitFly> any critiques of my code? http://ideone.com/hpx4T6
10:16:06 <Shou> acube, I replace "pkgname" with "mtl" right?
10:16:23 <acube> yes, that should work
10:16:38 <acube> I don't know if you need to mtl version too
10:16:53 <acube> and modulename with Control.Monad.State
10:18:35 <enthropy> code can probably work with those wrong names too, the only reason you'd want to be more accurate is to avoid having two things with different types having the same TypeRep
10:25:55 <Shou> I'm getting an error: "Ambiguous type variable `a0' in the constraint: (Typeable a0) arising from a use of `typeOf'; Probable fix: add a type signature that fixes these type variable(s); In the expression: typeOf (undefined :: s)" :c
10:26:48 <enthropy> Shou: you need -XScopedTypeVariables
10:27:04 <merijn> Shou: "Ambiguous type variable" means "there's moret than one possible correct type to infer for this, specify which one you wanted"
10:27:38 <Shou> Oh, GHCi wasn't reading my language pragma or something.
10:27:46 <enthropy> without the extension, that 's' is not the same 's' as above
10:29:48 <Shou> Now it's giving me this instead: Expecting one more argument to `m'; In the first argument of `typeOf1', namely `(undefined :: m)'
10:31:46 <Cale> Shou: There are no values of types whose kind is * -> *
10:31:51 <Cale> (even undefined)
10:32:07 <Cale> :t typeOf1
10:32:08 <lambdabot> Typeable1 t => t a -> TypeRep
10:32:20 <Cale> You'll want (undefined :: m a) or something
10:32:49 <monochrom> you may be unready to use Data.Typeable
10:33:18 <Shou> Yeah, but I want to use it :c
10:33:41 <Shou> So can I just specify, say, IO or something?
10:33:47 <Shou> Limit it to that?
10:34:04 <Cale> Shou: Just add an a there
10:34:05 <monochrom> (undefined :: IO) is the same problem
10:35:12 <Shou> Cale, oh wow, that worked. I thought I'd have to add the `a' to the instance declaration or something.
10:35:15 <Shou> as well
10:35:52 <Shou> Thanks everyone :)
10:38:35 <Cale> Shou: What are you using this for btw? I've rarely come upon cases where I've had to use typeOf1
10:39:11 <enthropy> and soon typeOf1 will be obsolete
10:39:25 <Shou> Cale, IRC bot that reloads a list of functions
10:39:39 <Shou> So I don't have to restart it
10:40:05 <enthropy> http://hackage.haskell.org/trac/ghc/wiki/GhcKinds/PolyTypeable
10:40:10 <Shou> And the functions are all StateT
10:40:47 <AtKaaZ> > maxBound :: Char
10:40:48 <lambdabot>   '\1114111'
10:40:56 <AtKaaZ> how do I know what base is that? 8 or 10?
10:41:04 <Cale> It's 10
10:41:26 <Cale> > '\99'
10:41:27 <Shou> It's 10 unless it's prefixed with x, then it's hex
10:41:27 <lambdabot>   'c'
10:41:35 <AtKaaZ> ok thanks
10:41:46 <AtKaaZ> > '\65'
10:41:48 <lambdabot>   'A'
10:42:38 <acube> Shou: how do you reload a list of functions with typeable?
10:43:55 <AtKaaZ> is there another way to get a char other than via \ ?
10:44:30 <acube> > 'a'
10:44:30 <enthropy> > toEnum 1234 :: Char
10:44:31 <lambdabot>   'a'
10:44:32 <lambdabot>   can't find file: L.hs
10:44:33 <acube> like this?
10:44:38 <acube> > chr
10:44:40 <lambdabot>   *Exception: show: No overloading for function
10:44:40 <acube> @ty chr
10:44:42 <lambdabot> Int -> Char
10:44:44 <acube> @ty ord
10:44:44 <Cale> > toEnum 1234 :: Char
10:44:45 <lambdabot> Char -> Int
10:44:45 <lambdabot>   '\1234'
10:44:53 <acube> > chr 1234
10:44:54 <lambdabot>   '\1234'
10:45:36 <Cale> You can use chr/ord from Data.Char, but sometimes it's more convenient just to use toEnum/fromEnum which are in the Prelude already (but have a more general type)
10:45:47 <jmcarthur> AtKaaZ: are you actually using these values as characters, or just as numbers?
10:45:51 <AtKaaZ> nice very clever, thanks
10:46:17 <Cale> Yeah, if you're actually working with binary data, you should juse use Data.ByteString, which lets you work with Word8 bytes directly.
10:46:18 <AtKaaZ> jmcarthur: I'm only experimenting
10:46:28 <AtKaaZ> learning*
10:46:31 <k0ral_> Hello, how would you do to have a thread wait for a shared list (MVar [a]) to be non null without actively polling the MVar ?
10:46:57 <jmcarthur> k0ral_: might be easier to use TMVar
10:47:36 <Cale> k0ral_: It's hard to tell when an MVar changes without polling it. Yeah, if you use TMVar, you can just write a transaction which reads it, and then retries if the list is empty, and the transaction will only be rerun when the TMVar is modified.
10:47:48 <jmcarthur> k0ral_: because then you could poll it and then retry if it's still null. it will only actually rerun the transaction when something writes to it
10:48:22 <jmcarthur> k0ral_: alternatively, you could have another MVar that the writer must fill when it updates the one you're polling and just have your reader wait on it
10:48:31 <jmcarthur> but then you're maintaining an awkward protocol
10:48:47 <FreeFull> Or you could just use an alternative list data structure that is guaranteed to have at least one element
10:49:16 <k0ral_> FreeFull: the list may be legitimately empty so I can't
10:49:17 <jmcarthur> i was assuming the distinction between empty MVar and MVar filled with empty list was important, but if not, yeah
10:49:41 <FreeFull> k0ral_: Ok
10:49:50 <k0ral_> jmcarthur, Cale: thanks, I'll have a look at STM, which I don't know yet
10:49:53 <Cale> atomically (do xs <- takeMVar r; if null xs then retry else return xs)
10:49:54 <FreeFull> k0ral_: I would recommend STM then
10:50:00 <FreeFull> STM is awesome
10:50:41 <Cale> Er, takeTMVar rather :)
10:53:48 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm.pdf -- the first 4 sections of this paper are not a bad place to start, and you can read the stuff on semantics and implementation after that if you really care to. atomic was for some reason renamed to atomically early on, but otherwise it's accurate.
10:54:09 <k0ral_> I take it the only advantage of using MVar over TMVar is related to performance overhead ?
10:54:29 <Cale> Yeah
10:54:57 <monochrom> it may be a TVar in your case
10:55:00 <k0ral_> reading at STM seems to indicate everything MVar-s can do, TMVar-s also can
10:56:31 <Cale> That's right.
10:56:50 <k0ral_> not sure I sense the difference for now
10:57:14 <Cale> Well, the difference is that the operations on TMVar are in this STM monad
10:57:39 <Cale> actions in the STM monad can only have (reversible) memory effects
10:58:01 <Cale> but the system can arrange that they occur as if atomically with respect to each other
10:58:15 <Cale> The function  atomically :: STM a -> IO a  will execute a transaction.
10:59:17 <k0ral_> TVar can't be empty, right ?
10:59:26 <Cale> right
10:59:38 <Cale> There is a primitive:  retry :: STM a  which causes the transaction to stop immediately and rerun from the beginning
10:59:45 <simukis_> k0ral_: TVar (Maybe a)?
10:59:46 <Cale> But of course, it doesn't just busy-loop
11:00:08 <Cale> The system will wait until one of the things that the transaction had read on the way to the retry changes.
11:00:18 <Cale> and then retry the transaction
11:00:32 <Cale> simukis_: There's TMVar too :)
11:00:44 <Cale> But yeah, you could implement TMVar with TVar (Maybe a)
11:01:33 <monochrom> atomically (do { xs <- readTVar v; when (null xs) retry }) blocks until xs is non-null.
11:01:34 <k0ral_> all right, that's clear to me, thank you guys
11:01:54 <Cale> readMVar has a little issue, in that if a putMVar happens between the time that the readMVar takes the MVar, and when it tries to put the value back, it may have to block until something else empties the MVar
11:02:00 <Cale> readTMVar avoids that issue
11:02:23 <Cale> (by actually behaving atomically with respect to other threads)
11:03:47 <k0ral_> well, regarding the limitation you've just mentioned about MVar, I would expect people to hide MVar implementation details in their API and provide only abstractions over them that do not make it possible to have interleaving readMVar/putMVar
11:04:30 <k0ral_> of course, if the API disclaims the internal MVar mechanisms, nasty things could happen
11:04:54 <Cale> Well, it can require some headache pills to try to make sure that all the things like that which can happen really don't.
11:05:11 <Cale> (though MVar is in many ways nicer than plain ol' locks)
11:05:44 <k0ral_> usually you should not putMVar without having readMVar before
11:06:13 <monochrom> you are right, but I have a lazy brain :)
11:06:37 <Cale> k0ral_: The problem is when the putMVar happens in another thread at the same time as your thread is doing readMVar
11:07:02 <Cale> Because readMVar is really just a plain composite of takeMVar and putMVar
11:07:27 <k0ral_> s/readMVar/takeMVar
11:07:35 <k0ral_> oh
11:08:02 <Cale> So, readMVar might take the MVar's value out, allowing a putMVar from another thread to write its value before readMVar is able to write that value back.
11:08:19 <Cale> and you can destroy/lose an update like that
11:08:54 <ryant5000> is there any way to get longer cost center output from -hc?
11:09:50 <ryant5000> it cuts it off with an ellipsis after about 30 characters
11:10:01 <Cale> Yeah, I hate that
11:10:09 <Cale> I don't know if there's a way or not.
11:10:20 <Cale> oh
11:10:23 <Cale> there is
11:10:31 <Cale> -L<num>
11:10:38 <Cale> "Sets the maximum length of a cost-centre stack name in a heap profile. Defaults to 25."
11:11:00 <ryant5000> oh, nice; must have missed that
11:11:09 <ryant5000> thanks
11:11:36 <Cale> I think that might be new, or else I didn't notice it before when I had that problem either.
11:28:23 <JeffPenfold> Hi - just wondering if somebody has a moment (or five) to help me understand something strange happening as I teach myself Haskell?
11:28:38 <Fuuzetsu> ?ask
11:28:38 <lambdabot> Plugin `tell' failed with: Prelude.head: empty list
11:28:44 <Fuuzetsu> Just ask.
11:29:18 <geekosaur> @where justask
11:29:18 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
11:29:21 <Fuuzetsu> ^
11:29:24 <JeffPenfold> HI -- I'm just playing about with reading from stdin and converting the input character list into tokens
11:30:01 <JeffPenfold> not having trouble with the program as such .. it read input, spots tokens and output a new list tokenised
11:30:42 <JeffPenfold> and, because its all lazy :) it starts outputting the tokens found in the input before I finish typing into it
11:30:50 <JeffPenfold> so far so good.
11:31:31 <JeffPenfold> I then added some functions which filtered out some of the tokens (ie spaces etc) .. and suddenly the program is "less lazy" than it was
11:32:19 <JeffPenfold> it is still lazy in that it eventually start outputting tokens as desired, but it takes way, way more input before it does.
11:33:00 <merijn> Sounds like a case of needs more "hFlush stdout"
11:33:11 <geekosaur> maybe
11:33:14 <mauke> unlikely
11:33:38 <JeffPenfold> playing about withe the code I can "flip" between the two ways it executes by simply replacing a returned argument with True
11:33:58 <Fuuzetsu> You'll probably have to post the code for better help.
11:33:58 <duairc_> Is there any such thing as IORef "laws"?
11:34:11 <geekosaur> @paste
11:34:11 <lambdabot> Haskell pastebin: http://hpaste.org/
11:34:11 <JeffPenfold> so the program remains almost totally identical, but I get two different modes in which it runs.
11:34:15 <merijn> I stand corrected, that doesn't sound like hFlush will help
11:34:28 <JeffPenfold> program here: https://dl.dropboxusercontent.com/u/84685556/example.hs
11:34:55 <JeffPenfold> it not big, but ~120 lines, >50% comments though
11:35:12 <geekosaur> duairc_, not in the sense of mathematical laws as appy to e.g. Functor
11:35:22 <Taneb> duairc_, I don't think so. Even the obvious writeIORef var foo >>= readIORef var breaks when threading is involved
11:35:22 <Fuuzetsu> Can you give us some inputs that we could use to see the issue?
11:35:25 <JeffPenfold> Just some pointers or keywords would help so that I can get google to do the leg work
11:35:29 <mauke> so much repeated code :-(
11:35:39 <JeffPenfold> yeah .. just learning ..
11:35:51 <JeffPenfold> been doing C to too many years
11:35:57 <Fuuzetsu> You need to ease up on spaces~
11:35:59 <JeffPenfold> s/to/for/
11:36:17 <mauke> JeffPenfold: try 'filterToken ~(a,b) = a'
11:36:23 <geekosaur> JeffPenfold, pattern matching is strict (and is in fact the "natural" way to introduce strictness into a program). one way to avoid this is irrefutable matches, which are lazy
11:36:27 <geekosaur> or, what mauke just said
11:36:35 <geekosaur> (that's an irrefutable pattern)
11:36:48 <mauke> JeffPenfold: main = interact process
11:36:55 <duairc_> geekosaur: Taneb: Yeah, that's what I thought. I guess, IORef, STRef and even TVar all have something in common, and I'm just trying to formalise what that is exactly
11:40:58 <JeffPenfold> mauke, The "~(a,b)" doesn't change the apparent way the program executes.
11:41:19 <mauke> oh well, it was worth a try
11:41:56 <JeffPenfold> I suppose I could(should?) try a different haskell environment see if this is an effect of the environment?  I'm just using ghc.
11:42:04 <Taneb> The only time I actually used lazy pattern matching was for writing a Storable instance
11:43:14 <monochrom> JeffPenfold: what does the rule (LexSpaces, laSpaces, False) mean?
11:43:58 <geekosaur> this could propagate down, I guess; pluckToken would be the next place to try making a lazy pattern. (the correct way to find out is to examine the Core and see what ghc infers as strict, but this isn't really something for beginners)
11:44:20 <JeffPenfold> it ties the enum value "LexSpaces" with a functions that spots spaces "laSpaces", and says that when they're found we I don't want them "False"
11:45:38 <JeffPenfold> It  not a terribly clever way of doing things, but it provided a means for learning a new language
11:47:06 <monochrom> you compute "laSpaces xs" and compare it against 0, is that the only thing you ever do? I mean: you only compare against 0, you never compare against any other number.
11:47:17 <JeffPenfold> what's confused me is that the behavior of the program changes with such a small change (in the function filterToken)
11:47:20 <NemesisD> why is haskell indentation 4 spaces :(
11:47:28 <geekosaur> NemesisD, it's not
11:47:36 <NemesisD> it isn't?
11:47:39 <Fuuzetsu> Haskell doesn't use indentation
11:47:59 <mekeor> ?
11:48:01 <NemesisD> i thought there was a convention for how many spaces in a tab and it was 4 spaces by convention
11:48:09 <geekosaur> 8 spaces, actually
11:48:14 <geekosaur> unix convention
11:48:15 <NemesisD> christ, are you kidding?
11:48:20 <mekeor> Fuuzetsu: you mean "tab"s, not "indentation", i guess?
11:48:22 <monochrom> did you see my question?
11:48:24 <geekosaur> since ghc originated on unix
11:48:37 <NemesisD> most languages i use are 2 spaces/tab
11:48:40 <Fuuzetsu> mekeor: no, I mean indentation. Haskell uses alignment which is different
11:48:43 <jmcarthur> NemesisD: 8 spaces is actually what tab historically meant long ago
11:48:51 <geekosaur> jmcarthur, not really
11:48:54 <JeffPenfold> No, the token rules are all tested against the input list, and the longest match is returned
11:48:55 <mekeor> Fuuzetsu: ah
11:49:09 <mekeor> Fuuzetsu: what's the difference?
11:49:12 <JeffPenfold> so it starts by testing against 0..
11:49:20 <magicman> A \t expands to the nearest multiple of 8 columns. You can use any indentation you want. I usually go with 2 as well. Don't know what the convention is.
11:49:42 <geekosaur> tab used to mean either half inch or inch depending on the typewriter, and how many characters that meant varied between typewriter (and could well be a non-multiple).
11:50:03 <monochrom> ok, I tell you what, laSpace xs must consume all of xs before spitting out an answer. similarly the other la functions.
11:50:23 <Fuuzetsu> The difference is that you only have to align things with each other as opposed to indenting things some arbitrary number of spaces
11:50:26 <monochrom> err no, not really, nevermind
11:50:33 <Fuuzetsu> At least that's how I think about it.
11:50:41 <geekosaur> 8 spaces was unix's tradeoff position; probably, 10 was closer to what their typewriters did but considered too much indentation
11:50:50 <monochrom> well, it consumes until the first non-space before it spits out an answer
11:50:51 <geekosaur> but I doubt anyone remembers the details any more
11:50:58 <JeffPenfold> Perhaps I should have another crack at a tighter implementation - it was a first attempt
11:51:03 <mekeor> Fuuzetsu: ah
11:51:15 <NemesisD> i'm reading a haskell style guide that says 4 spaces
11:51:29 <copumpkin> ewww
11:51:32 <Fuuzetsu> NemesisD: Where are you reading this?
11:51:41 <geekosaur> there isn't a single blessed haskell style though
11:51:44 <Fuuzetsu> ^
11:52:06 <hpc> haskell style is more about semantics than syntax
11:52:08 <NemesisD> https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
11:52:24 <NemesisD> well i know i've had my patches cleaned up by project maintainers
11:52:36 <byorgey> yes, I follow almost everything in that style guide except I use 2 spaces indent instead of 4.
11:52:38 <geekosaur> 4 space indentation is somewhat common, but not a hard requirement
11:52:40 <Fuuzetsu> NemesisD: In the very beginning it says â€˜for this projectâ€™.
11:52:45 <NemesisD> didn't jasper van der geugt(?) write a tool to clean up haskell syntax?
11:52:53 <geekosaur> and I tend toward 2 spaces myself
11:52:58 <monochrom> so for example suppose you input slowly "    xyz". the program will not respond until it sees 'x'. but this is the price for longest match.
11:53:14 <jmcarthur> i typically shoot for 2 spaces when i need to indent a block
11:53:21 <geekosaur> that said, if I have a line of Haskell code that is long enough to suggest shrinking the indent, I probably want to rethink that line of code :)
11:53:30 <jmcarthur> unless the block has a prefix on its first line
11:53:31 <geekosaur> (or the block containing it)
11:53:33 <mekeor> byorgey: why, if i may ask?
11:53:38 <hpc> i do 2 spaces for blocks, layout for long expressions
11:53:43 <NemesisD> i'm doing more open source work in haskell on other people's projects and i don't want to be that guy whose code needs to be cleaned up
11:53:43 <byorgey> NemesisD: stylish-haskell
11:53:49 <byorgey> NemesisD: but it doesn't re-indent things
11:53:51 <monochrom> I use 3.14 spaces
11:53:55 <JeffPenfold> yes .. the program outputs an identified token once it's found a unique and longest match
11:54:00 <alexander__b> I don't grok haskell yet, but I use vertical alginment. 2 spaces if I'm just indenting something.
11:54:02 <hpc> with the distinction between a block and an expression being fuzzy
11:54:08 <byorgey> NemesisD: then look at the style used in the project you're working on, and imitate that
11:54:13 <mekeor> monochrom: i use (1+sqrt 5)/2 spaces :P
11:54:27 <jmcarthur> i wish for "good" editor support for blocks/layout, as opposed to merely spacing
11:54:47 <byorgey> mekeor: why do I use 2 spaces?  I dunno, I just like it better.
11:54:48 <yezariaely> anyone knows where the haskell written mail transfer agent 'postmaster' has gone?
11:55:07 <mekeor> byorgey: i see :)
11:55:34 <jmcarthur> i think 2 spaces is just easier to read and wastes less horizontal space
11:55:41 <geekosaur> yezariaely, I see it on hackage
11:55:51 <NemesisD> also i notice some projects use camelCase for function names but under_scored for where functions
11:56:07 <geekosaur> http://hackage.haskell.org/package/postmaster last updated Tue Feb 12 21:08:02 UTC 2013
11:56:09 <yezariaely> geekosaur: thx for the hint. too tired to look properly...
11:56:19 <JeffPenfold> but, when I enable the dropping of tokens I am not interested in it suddenly goes into a sulk and doesn't output anything until a huge number of tokens have been entered.  It feel like a buffering thing
11:56:21 <mekeor> jmcarthur: but it makes blocks better readable if youknow what i mean
11:56:40 <jmcarthur> mekeor: 4 spaces does? i think i disagree
11:56:41 <monochrom> I think tokenization must be longest match, and there is nothing wrong with looking ahead a bit more for tokenization.
11:57:10 <mekeor> jmcarthur: i mean... uh nevermind. it's so irrelevant, imo..
11:57:12 <jmcarthur> mekeor: blocks are already pretty distinguishable just due to being more than one line long
11:57:24 <mauke> JeffPenfold: does anything change if you set stdout to unbuffered?
11:57:52 <jmcarthur> this topic is general unimportant outside the context of a particular project, yeah
11:57:55 <jmcarthur> *generally
11:58:03 <JeffPenfold> yes .. token code always goes for longest match.    Mauke: Not sure how to set stdout to unbuffered.
11:58:41 <merijn> jmcarthur: Lamdu! :p
11:58:41 <geekosaur> http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#v:hSetBuffering
11:58:50 <mauke> main = do hSetBuffering stdout NoBuffering; ...
12:00:06 <JeffPenfold> mauke: let me give that a go
12:02:11 <monochrom> I want to know an example exact input that causes the program to be unresponsive, so that I can actually judge whether it is possible to be responsive to begin with.
12:02:37 <JeffPenfold> Prize goes to mauke for fixing the symptoms :D
12:03:04 <JeffPenfold> but I'd really like to understand why the behavior changed as it did
12:03:24 <mauke> JeffPenfold: probably because you stopped outputting newlines
12:03:41 <JeffPenfold> ahhhh - yes
12:03:47 <monochrom> I guess so
12:03:48 <JeffPenfold> *thank you*
12:04:06 <JeffPenfold> I would have been banging my head against that for ages
12:04:40 <merijn> Oh!
12:04:46 <merijn> So I *was* right after all!
12:04:58 <mauke> it wasn't fixed by hFlush
12:05:06 <mauke> you can't hFlush in the middle of a [Char]
12:05:07 <merijn> hFlush, hSetBuffering, whatever
12:05:51 <monochrom> yeah there was only one call to putStr (long long string)
12:05:53 <JeffPenfold> It was always going to be something trival.
12:06:19 <JeffPenfold> (Isn't 20:20 hind sight great?)
12:06:21 <monochrom> I have a cunning plan
12:07:00 <monochrom> putStr (s0 ++ (unsafePerformIO (hFlush stdout) >> return "") ++ s1 ++ (unsafePerformIO (hFlush ...
12:07:51 * hackagebot hascal 2.0.0.1 - A minimalistic but extensible and precise calculator  http://hackage.haskell.org/package/hascal-2.0.0.1 (MekeorMelire)
12:08:56 <monochrom> that killed the conversation
12:09:31 <JeffPenfold> All I did was put "\n" into the token names ... worked a treat.
12:10:22 <JeffPenfold> Thank you again.  I suppose I need to spend much more time on, well, everything to do with Haskell :)
12:17:38 <NemesisD> anyone know what simple command would be the most common amongst all *nix systems
12:17:54 <NemesisD> was thinking maybe whoami or pwd. trying to write a test for spawning a process
12:18:10 <mauke> ls
12:18:39 <geekosaur> /bin/sh
12:18:47 <sipa> echo
12:20:43 <merijn> NemesisD: env/uname?
12:24:35 <h200> PRIVMSG lambdabot :> sum [1..10]
12:25:14 <mauke> 55
12:29:26 <dwcook> Is the topic referring to the thing that was causing mueval to mysteriously die?
12:30:01 <Fuuzetsu> yes
12:44:35 <ipuustin> hi guys, how to get values out of QuickCheck Gen without using quickCheck function?
12:44:56 <ipuustin> I would like to see which kinds of Arbitrary values are being produced
12:44:59 <Iceland_jack> ipuustin: You can try sample{,'}
12:45:13 <ipuustin> Iceland_jack: ok, will try, thanks
12:45:35 <Iceland_jack> Prelude> sample' (arbitrary :: Gen Int)
12:45:35 <Iceland_jack> [-1,1,2,-2,-5,-7,1,-14,49,-68,-205]
13:37:02 <pxqr`> > read "-1" :: Word
13:37:03 <lambdabot>   18446744073709551615
13:37:33 <pxqr`> why not to throw error?
13:38:24 <monochrom> no particular reason. apart from more convenient for the implementor
13:39:01 <jmcarthur> pxqr`: it's just underflow at work, really
13:39:13 <monochrom> all these bounded number types are not meant to be overflow-proof anyway
13:39:34 <jmcarthur> > (minBound-1 :: Word, maxBound+1 :: Word)
13:39:36 <lambdabot>   (18446744073709551615,0)
13:39:36 <pxqr`> it may be convenient for implementor, but inconvenient for users
13:39:37 <monochrom> and in fact some users explicitly want overflows to be wraparounds not errors
13:40:20 <pxqr`> monochrom: but that's parser function, not a say (+), (-) or something else
13:40:29 <jmcarthur> i don't mind the inconvenience in exchange for the speed. it's pretty well defined, too, at least for the WordN types
13:40:51 <jmcarthur> pxqr`: it's not just a parser thing. literals have the same behavior
13:40:54 <jmcarthur> > -1 :: Word
13:40:55 <lambdabot>   18446744073709551615
13:41:04 <pxqr`> hm
13:41:08 <jmcarthur> > negate 1 :: Word
13:41:09 <lambdabot>   18446744073709551615
13:41:11 <monochrom> clearly, I prefer - (read "1") == read "-1"
13:41:40 <monochrom> I prefer both to give the same non-error answer, not one non-error and the other error
13:41:58 <monochrom> of course, I'm just speaking for myself
13:42:10 <pxqr`> nope
13:42:33 <monochrom> this is why "users" is such a great idea. what I secretly want, I speak as though "users" want it.
13:42:38 <pxqr`> i just thinking; for exsample we use the 'read' in optparse-applicative
13:42:42 <pxqr`> that's when?
13:43:12 <pxqr`> and a parameter specifies amount of disc to format.
13:44:05 <monochrom> look, read is one single function. well, I mean read::String->Word. it can only do one thing. whatever it chooses to do, all those other people who want it to do two other things must be disappointed.
13:44:25 <pxqr`> the problem is that we can't really distinguish "-1" and "18446744073709551615'
13:45:11 <pxqr`> monochrom: but we have readMaybe for exsample.
13:45:11 <monochrom> and if "those other people" happen to include you, I can only say I regret to hear that.
13:45:40 <monochrom> that doesn't change much, does it?
13:45:49 <monochrom> readMaybe can still only do one thing
13:46:42 <monochrom> you would just be changing the contention to: I want readMaybe "-1" = Just (good number here), you want readMaybe "-1" = Nothing
13:46:50 <pxqr`> well, but why "do one thing"  mean ignore overflows
13:47:06 <pxqr`> it's all just one thing at the end
13:47:15 <monochrom> someone made that choice before you learned haskell
13:47:47 <monochrom> really, if you were born earlier and had a hand in writing the libraries, it would go your way, I'm sure.
13:48:13 <pxqr`> monochrom: I understand. I think this was before I was born. I just don't understand why not have a different parsers for different types.
13:48:35 <monochrom> there is nothing to understand
13:48:49 <monochrom> apart from "victors write history and the libs"
13:49:14 <pxqr`> heh
13:51:24 <monochrom> did you know: ML's : and :: are exactly swapping Haskell's :: and :
13:51:48 <pxqr`> yes
13:51:58 <monochrom> did you ever ask why?
13:52:06 <pxqr`> i like ML style
13:52:13 <pxqr`> no
13:52:25 <Heffalump> must be because those ML guys just wanted to reinvent the wheel and ignore a well-established preceden
13:52:27 <pxqr`> but : used in type theory book
13:52:28 <Heffalump> t
13:53:00 <pxqr`> books i meant
13:54:20 --- mode: ChanServ set +o monochrom
13:54:24 --- mode: monochrom set +b *!*@91.240.248.27
13:54:46 <monochrom> (pre-emptive ban because I just saw it spamming ##math right now)
13:54:50 <jmcarthur> "-1" and "18446744073709551615" are actually just two different ways of rendering the same value. i see no problem with this behavior
13:55:09 <jmcarthur> if both are Words, they are indistinguishable
13:55:13 <eikke> does anyone know what the state-of-the-art is wrt (realtime) signal processing in Haskell?
13:55:52 <jmcarthur> eikke: i do not know, but i assume you mean soft real time?
13:55:54 --- mode: monochrom set -b *!*@91.240.248.27
13:56:04 <monochrom> (it signs off altogether)
13:56:20 <eikke> jmcarthur: yeah, sure. audio DSP stuff
13:56:23 <jmcarthur> eikke: for hard real time, there are a couple DSLs for generating C
13:56:31 <jmcarthur> eikke: not specifically signal processing though
13:56:46 <jmcarthur> apart from that, i'm clueless
13:58:19 <eikke> there are a couple of libs & papers, but most seem kinda dead, whilst haskell seems like a really good fit for such stream-processing
13:59:06 <jmcarthur> it might be. it's certainly an expressive language for it. the performance aspect of it might be a harder sell though
13:59:12 <jmcarthur> s/performance/latency/
13:59:21 <petantik> eikke: there are some libs for dsp algorithms, performance isn't so good from what i recall
13:59:22 <jmcarthur> (thoughtput should be fine)
13:59:29 <jmcarthur> *throughput
14:00:00 <eikke> jmcarthur: Henning Thielemann worked on emitting LLVM for the actual worker code, but keeping things high-level through an EDSL
14:00:03 <eikke> which is kinda nice
14:00:22 <jmcarthur> yeah that's a workable approach
14:00:43 <jmcarthur> but it forbids you from certain kinds of interfaces
14:00:49 <jmcarthur> e.g. monadic
14:01:09 <jmcarthur> which may be okay
14:01:25 <eikke> sure (remember how FRP and monadic APIs don't match)
14:01:33 <jmcarthur> i disagree with that
14:01:45 <Peaker> is there a convenience function to wrap a ShowS in () in the Prelude?
14:01:54 <Peaker> (would make sense to have one as a combinator to build showsPrec functions)
14:02:11 <jmcarthur> i think the problems with FRP don't really have much to do with the monadic interface. dropping that just makes the implementation easier
14:02:21 <eikke> jmcarthur: right, ok
14:02:27 <Peaker> showsPrec prec x = parenifyIf 9 prec (shows x)
14:03:06 <jmcarthur> eikke: e.g. a dynamically specializing runtime could eliminate many of the problems with monadic frp
14:03:15 <jmcarthur> eikke: same with signal processing
14:04:05 <NihilistDandy> Hey, there was a neat blog post about proving theorems like a human using a computer. Does anyone remember the post/have a link?
14:04:14 <NihilistDandy> I can't for the life of me remember, and I forgot to save it
14:04:39 <jmcarthur> Peaker: http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/Text-Show.html#v:showParen  ?
14:04:45 <troydm> NihilistDandy: was it agda related?
14:04:56 <NihilistDandy> troydm: No, I think it was a sort of novel approach
14:05:20 <NihilistDandy> I wish I could remember more details. I think it was implemented in Haskell, though
14:05:26 <NihilistDandy> It was definitely in its infancy
14:06:11 <NihilistDandy> The idea was that the proofs it would produce would be similar to human proofs (i.e., it wouldn't spend inordinate amounts of time on tedious things)
14:07:34 <trism> NihilistDandy: you mean: http://gowers.wordpress.com/2013/04/14/answers-results-of-polls-and-a-brief-description-of-the-program/ ?
14:07:47 <NihilistDandy> YES
14:07:50 <NihilistDandy> Thank you so much
14:08:07 <Peaker> jmcarthur, cool, thanks
14:10:47 <companion_cube> NihilistDandy: I was surprised by the fact they did it from scratch
14:10:57 <companion_cube> without looking at the state of the art
14:13:42 <NihilistDandy> companion_cube: I can't say I'm particularly familiar with the state of the art besides Agda/Coq/Idris. Are there articles in particular that you'd recommend?
14:13:52 <NihilistDandy> It's an interesting field, and I'd love to read more about it
14:14:02 <companion_cube> I'm more into automated theorem proving
14:14:12 <Peaker> Could make sense to generalize DList to all Monoids, and then have ShowS = DList String
14:14:52 <companion_cube> NihilistDandy: it's a vast field :/
14:15:12 <NihilistDandy> Haha, yes, so I've seen
14:15:15 <apples> could you recommend introductory material on automated theorem proving?
14:15:18 <companion_cube> relevant subdomains are superposition, resolution, tableau methods, for instance
14:15:47 <NihilistDandy> Well, I'll have to find one that sits nicely with me and do some digging, then.
14:16:23 <companion_cube> wait a sec
14:17:22 <Peaker> function application is precedence 10, and showsPrec (Just Foo)   calls showsPrec on the Foo with precedence 11. I guess the wrong associativity is a penalty of (+1) ?
14:17:33 <jmcarthur> Peaker: FMList?
14:17:34 <Peaker> It doesn't seem to be documented
14:18:07 <jmcarthur> yeah the ShowS stuff is sad
14:18:18 <jmcarthur> Peaker: http://hackage.haskell.org/packages/archive/fmlist/0.8/doc/html/Data-FMList.html
14:18:43 <Peaker> jmcarthur, FMList seems to be polymorphic on the "m" rather than parameteric..
14:18:43 <jmcarthur> it's not quite the same thing as  Monoid a => a -> a,  but similar in spirit
14:18:57 <jmcarthur> yeah it's meant to still be a lot like DList
14:19:01 <jmcarthur> in the list-like sense
14:19:35 <jmcarthur> i guess it's exactly dual to what you are looking for
14:20:07 <companion_cube> NihilistDandy: a big conference about this is CADE; http://www.voronkov.com/ is a major researcher
14:20:10 <Peaker> I don't understand why (><) type-checks in there
14:20:17 <companion_cube> I'm trying to find introductory material
14:20:27 <jmcarthur> (><)?
14:20:41 <Peaker> http://hackage.haskell.org/packages/archive/fmlist/0.8/doc/html/src/Data-FMList.html
14:20:45 <NihilistDandy> companion_cube: I had tried to play with vampire some time ago, but I think I ran into some kind of snag that I can't now remember
14:21:16 <jmcarthur> Peaker: the function instance of Monoid
14:21:21 <companion_cube> NihilistDandy: also, http://eprover.org
14:21:23 <Peaker> jmcarthur, it's the implementation of mappend -- and it seems to be mappending the two functions (which is fine, using the (->) monoid instance, point-wise mappend) -- what I don't get is why the result is just as polymorphic
14:21:24 <jmcarthur> Peaker: functions are monoids when their results are monoids
14:21:31 <jmcarthur> ah
14:21:41 <companion_cube> very good theorem prover, open source
14:21:44 <Peaker> jmcarthur, but I guess you get something like: forall newm.   instantiate first FM to newm `mappend` instantiate second FM to newm
14:22:00 <jmcarthur> yup
14:22:06 <companion_cube> "E : A brainiac theorem prover" is a very good explanation of how E works
14:22:24 <Peaker> jmcarthur, Does it right-associate the mappending like DList does?
14:22:27 <NihilistDandy> companion_cube: I hadn't heard of that one. I'll have to give it a look. I'm thinking of working through Software Foundations to get a good feel for it
14:22:37 <NihilistDandy> Theorem proving in general, that is
14:22:39 <jmcarthur> Peaker: yeah
14:22:54 <companion_cube> http://www.ags.uni-sb.de/~chris/lectures/fol-hol-tp/ maybe, also
14:23:08 <Peaker> jmcarthur, so I guess DList's main advantage is not depending on RankNTypes/PolymorphicComponents?
14:23:15 <NihilistDandy> Oh, very cool
14:23:44 <jmcarthur> Peaker: if that's an advantage at all these days, i guess
14:24:14 <Peaker> ShowS = FMList Char?
14:24:38 <NihilistDandy> companion_cube: Neat, eprover's even a brew package. I have no reason at all not to try it immediately :D
14:24:42 <Peaker> that could allow things to be instantiated to fast string builders/Text/etc, I suppose
14:24:42 <jmcarthur> well, isomorphic to
14:24:47 <jmcarthur> yup!
14:25:20 <jmcarthur> not as nice for that as your original idea though
14:25:31 <jmcarthur> since it's still tied to individual Chars
14:26:56 <jmcarthur> any Endo can be seen as a builder of sorts, really
14:28:09 <Peaker> FMList String or maybe FMList Text would make more sense than FMList Char, perhaps
14:28:43 <JoshTriplett> dcoutts: Hi.  Around?
14:30:38 <JoshTriplett> dcoutts: If you have time, would you consider releasing c2hs 0.16.5?
14:33:00 <companion_cube> NihilistDandy: also, SPASS is nice
14:33:17 <companion_cube> the common background of those three provers is superposition
14:33:58 <companion_cube> another close interesting area is SMT, which provides linear arithmetic (check out Z3, cvc4, yices...)
14:35:07 <NihilistDandy> You weren't kidding about it being a vast field :D
14:36:26 <companion_cube> :)
14:41:19 <Peaker> kinda sucks to have all the functions for String unavailable for ShowS. e.g: unwords on a bunch of ShowS
14:41:33 <Peaker> Haskell definitely lacks some type-class overloading to make these kinds of things not suck
14:41:39 <Peaker> (in the stdlib)
14:42:47 <Philippa> huh. Thought: as well as needing to ask "WTF doesn't this typecheck?", sometimes we need to ask "WTF /does/ this typecheck?"
14:43:23 <atamaitai> Philippa: For example? (And what would the solution be?)
14:44:09 <dmwit> fix . return would perhaps be a good starter exercise
14:44:20 <Philippa> atamaitai: you forget just how general a couple of the functions in some bunch of code are and the compiler finds a solution you really didn't intend (that yields unintended behaviour)
14:44:48 <Philippa> and you can actually use the same solution for both, it's just that it's less obvious that we'd have to provide the hooks in the latter case: you want a 'typing debugger'
14:44:56 <Philippa> (a debugger for the typechecking process, that is)
14:45:12 <dmwit> I guess you aren't the first person to opine for a typing debugger.
14:45:23 <Philippa> not by a long way, no
14:46:01 <Philippa> not that a good one isn't still a research project, and one tied up with more UI work than I can generally tolerate, but hey
14:46:53 <AtKaaZ> hey bros, how to get rid of the repetition here http://hpaste.org/88645
14:46:53 <Philippa> (...huh. OK, I have a pair of ideas I do need to smash together a few times to see if they work tolerably sometime? But I'm not best placed to write lots of code of late)
14:47:11 <AtKaaZ> of weight / height ^ 2
14:47:27 <AtKaaZ> some let somehow? or do i have to use another function?
14:47:49 <dmwit> bmiTell | bmi <= 18.5 = ... | bmi <= 25.0 = ... | ... where bmi = weight / heigh ^ 2
14:49:57 <AtKaaZ> dmwit: most excellent! thank you
14:54:02 <Peaker> Instead of a typing debugger, in lamdu we expose options that would be type errors when filling holes with "<err hole> <result you wanted>" -- then it tells you the type of what you wanted right next to the type it needs to match
14:54:24 <Peaker> or if you change the exported type of something and it breaks callers, it (will) insert err holes around all calls
14:56:13 <Philippa> you don't have to worry about TFs, FDs etc etc making the info flow non-obvious, though
14:56:39 <Philippa> at which point, it's pretty much in the nature of such an editor to already provide the navigation options you'd want/need
14:56:40 <AtKaaZ> dmwit: now I got to the point in the book where they tell to use where like you said =)
14:57:13 <dmwit> hah
14:57:30 <dmwit> "Implement this."
14:57:35 <dmwit> "Your implementation sucks. Here's how to fix it."
14:57:47 <dmwit> Probably good design, actually.
14:57:57 <AtKaaZ> this book I mean: http://learnyouahaskell.com/syntax-in-functions
14:58:04 <dmwit> I know which book.
14:58:07 <AtKaaZ> right
14:58:37 <AtKaaZ> so when they're at "implement this" then I'm asking the question right then
14:59:46 <neutrino_> kludge`: hey!
14:59:52 <neutrino_> kludge`: i have a tape question for you.
15:00:02 <Peaker> Another cool UI feature for type debugging -- is having icons next to each displayed type, indicating each information source that forced the type to be whatever it is
15:00:19 <neutrino_> oops.. wrong kludge, wrong channel!
15:00:30 --- mode: monochrom set -o monochrom
15:00:37 <Peaker> and being able to press those icons to jump to that source
15:00:46 <Peaker> (perhaps an icon for every kind of inference rule)
15:01:25 <AtKaaZ> Peaker, in which program ?
15:01:49 <Peaker> AtKaaZ, we didn't implement the icons in any program :)
15:01:56 <Peaker> (and we got rid of type conflicts altogether)
15:01:59 <AtKaaZ> I thought in leksah
15:02:16 <bitonic> will -xd print the locations of occurrences of <<loop>>?
15:02:17 <Peaker> AtKaaZ, in lamdu, an IDE for a Haskell-like language we're implementing from scratch
15:02:54 * hackagebot multimap 1.1 - A multimap.  http://hackage.haskell.org/package/multimap-1.1 (JulianFleischer)
15:03:25 <AtKaaZ> Peaker, sounds very interesting
15:04:04 <Peaker> AtKaaZ, at this point it's just a toy -- but it's slowly evolving..  you can toy with it at https://github.com/Peaker/lamdu
15:04:13 <AtKaaZ> yep reading it already xD
15:04:54 <AtKaaZ> there are some concepts there that I'm reading which I want
15:06:28 <AtKaaZ> Peaker, have you seen the (java) editor from Alice the second video here http://www.alice.org/index.php?page=what_is_alice/what_is_alice
15:06:40 <AtKaaZ> Peaker, I mean those kind of concepts i like that
15:08:26 <Peaker> AtKaaZ, we're not designing for beginners
15:08:35 <Peaker> AtKaaZ, but we do think our IDE will be much better for beginners
15:09:12 <AtKaaZ> true but, the concepts they use for the editor is not text, I think you're maybe aiming for similar
15:09:15 <Peaker> AtKaaZ, we believe that for many (most?) kinds of code, the textual rendering is great -- just the editing this rendering sucks, and the tooling around it sucks
15:09:34 <Peaker> so our code rendering is textual -- much like Haskell syntax
15:10:46 <Peaker> and we make an effort to have predictable editing, i.e: if you press "*" on an expression, it will structurally edit it to be a hole with "<expr> * _" and "_ * <expr>" as options
15:11:32 <Peaker> if you press "*" followed by "5" it will become "<expr> * 5", so you can edit as if it was text, but all editing operations are actually structural and preserve type checking/etc
15:12:59 <AtKaaZ> yes i like that
15:13:20 <AtKaaZ> the editor is aware :)
15:14:15 <AtKaaZ> I'm on windows, but I can't try it yet since I'm just learning haskell, so I don't know about cabal and stuff
15:14:49 <Peaker> AtKaaZ, in the lamdu dir, iirc "cabal install" should work.
15:15:55 <AtKaaZ> Peaker: don't I need step one? 1. Install the ftgl C bindings.
15:16:18 <Peaker> Oh, right
15:16:36 <Peaker> I think I got FTGL to build on Windows at some point, I don't remember how
15:17:19 <JoeyA> How do I use hpc to report the results of a cabal-built program whose dependencies have coverage enabled?  I do want coverage info for the dependencies.
15:17:38 <JoeyA> When I run hpc report acme-server.tix, I get "hpc: can not find acme-core-0.1/Acme.Dynamite in ["./.hpc"]"
15:18:12 <JoeyA> (names are fictitious)
15:19:21 <stawny> i need read whole in some funcion to memory, and then when invoking other functions use data in this field, how do make it?
15:19:38 <Peaker> stawny, read whole what?
15:19:42 <dmwit> I can't understand the question.
15:19:48 <stawny> whole file
15:20:09 <Peaker> stawny, why do you need to read the whole file to memory?
15:20:49 <dmwit> You might like readFile. You will probably also want a parser library. Parsec is popular for this.
15:21:06 <stawny> beacause i dont want to read this file in every function, again and again
15:21:12 <JoeyA> stawny: you can use Data.ByteString.readFile to read the entire file as a ByteString, without the laziness that Prelude.readFile uses.
15:21:29 <dmwit> Laziness is fine for the purpose of avoiding duplicate work.
15:21:50 <FreeFull> Reading in the whole file non-lazily doesn't sound good RAM-wise
15:22:05 <JoeyA> Depends on how big the file is.
15:22:09 <dmwit> Laziness isn't going to make a difference.
15:22:15 <dmwit> You guys are picking on all the wrong parts of the problem.
15:22:16 <JoeyA> If it's just a configuration file, no biggie.
15:22:40 <JoeyA> stawny: you probably want to parse the file first.  What do you plan to do with the content?
15:23:21 <stawny> it is going to be a small file, i need count words, lines, characters, etc every in other function
15:24:52 <monochrom> main = do { xs <- readFile "/dev/zero"; print (length (words xs), length (lines xs), length xs) }
15:25:19 <monochrom> accidentally, it satisfies the strange requirement of "must keep in memory" :)
15:25:55 <JoeyA> That's good code to run if you're tired of your computer being so responsive.
15:26:46 <brent_lap> hello-opengl question- could someone give me an example how to use the "get" StateVar method on the "matrix" CoordTrans method? http://hackage.haskell.org/packages/archive/OpenGL/2.4.0.1/doc/html/Graphics-Rendering-OpenGL-GL-CoordTrans.html#t:Matrix  I'm spinning my wheels on that one, big time.
15:28:37 <stawny> monochrom: nice code, but how to split it into some functions, ie first user type readFile, then countWord, then countLine ?
15:29:17 <dmwit> system "ghci"
15:29:36 <monochrom> "length (words xs)" is your "countWord xs". I don't know why you need a user.
15:30:32 <stawny> another strange requirement ;)
15:30:35 <monochrom> main = do { xs <- readFile "/dev/zero"; print (countWord xs, length (lines xs), length xs) }  where countWord xs = length (words xs)
15:30:36 <ocharles> JoeyA: i think there's an open bug with cabal and hpc
15:30:45 <ocharles> what cabal-install version?
15:31:40 <brent_lap> my try : " m <- get $matrix  $ Just Projection " gives "Ambiguous type variable `m0' in the constraint: (Matrix m0) arising from a use of `matrix "
15:31:46 <JoeyA> ocharles: I noticed the bug report, too.  cabal-install version 1.16.0.2
15:32:03 <monochrom> I guess I do not understand the relation between "user" and "function"
15:32:23 <ocharles> JoeyA: ah. maybe HEAD is fixed now. I have a custom hpc running script which is... ok
15:32:28 <JoeyA> Looking at the dates of the packages, it was fixed a week after Cabal-1.16.0 and cabal-install 1.16.0.2 released.
15:32:33 <ocharles> I use it with my tests, and annoyingly it shows all my test coverage there
15:33:18 <monochrom> but I recommend what dmwit says. launch ghci. then the user can type in functions.
15:33:50 <JoeyA> Looking at the source code, when it says "hpc: can not find acme-core-0.1/Acme.Dynamite in ["./.hpc"]", I think it's looking for ./.hpc/acme-core-0.1/Acme.Dynamite.mix
15:33:52 <JoeyA> (not tix)
15:33:57 * dmwit feels validated
15:34:10 <JoeyA> so I'll try symlinking the hpc directories
15:34:16 <dmwit> It's also possible that there's a translation problem here and stawny just wants to know how to make a menu or something.
15:34:19 <ocharles> JoeyA: let me know if that works
15:34:19 <monochrom> give a man a program written for ghci, and he will be happy for a day. give him ghci, and he will be happy for life.
15:34:20 <JoeyA> I'm just trying to get a report on a program I ran stand-alone.
15:34:24 <dmwit> For that, getLine is fine.
15:34:25 <monochrom> or something like that
15:34:57 <dmwit> stawny: So my alternative suggestion is "getLine".
15:35:40 <brent_lap> bbl...
15:35:44 <dmwit> I always vacillate on the right way to handle an XY problem.
15:35:54 <dmwit> Theoretically I like the "answer the Y problem and let them hang themselves" approach.
15:35:59 <dmwit> But it also feels very undfriendly.
15:36:08 <dmwit> *unfriendly
15:36:45 <blaenk> hey dmwit is there a different way to compose event hooks in xmonad aside from <+>? like an mconcat version where I can just list them all and combine them?
15:36:57 <dmwit> blaenk: How about mconcat?
15:36:59 <blaenk> asking here cause I think it's more haskell-ish of a question
15:37:00 <monochrom> I would love to answer the X problem too. But I just don't know what X is. I really don't.
15:37:02 <blaenk> oh it works? oh awesome :)
15:37:04 <geekosaur> <+> *is* mconcat
15:37:05 <blaenk> will try it
15:37:08 <blaenk> o pfft
15:37:08 <stawny> ok, and i want to give user, some functions, to use this functions he must first read file to memory, then he can invoke which function he want, countWord, countLines, but and this functions access file data from memory
15:37:10 <geekosaur> erm, mappend
15:37:12 <blaenk> thought it was mappend
15:37:13 <blaenk> yeah
15:37:23 <geekosaur> mconcat is mappend folded across a list
15:37:25 <monochrom> alternatively, I do know 100 posibilities for X. but that hardly helps.
15:37:41 <geekosaur> (aka composeAll)
15:37:52 <monochrom> I am not paid in this channel and I am not going to solve 100 X problems just in case one of them hits.
15:37:56 <blaenk> geekosaur: ohhh composeAll is what I want then, I saw that used in the other hooks but didn't know if it was specific to that
15:37:59 <blaenk> thanks
15:38:07 <blaenk> but I guess that's just a synonym for mconcat then
15:38:11 <dmwit> yes
15:38:14 <blaenk> cool thanks guys
15:38:40 <Peaker> brent_lap, are you doing 3d graphics or 2d graphics?
15:38:44 <JoeyA> ocharles: indeed, it worked: mkdir .hpc && ln -si ~/acme-core/dist/hpc/mix/acme-core-0.1/acme-core-0.1 .hpc/ && # repeat for all other dependencies
15:38:49 <Peaker> brent_lap, can you show pasted code?
15:38:52 <dmwit> It's always pleasant when somebody asks "is there something like X" and you get to say, "yes, X is like X". =)
15:39:04 <blaenk> haha
15:39:25 <RichyB> Even if <+> wasn't mappend, you could still write foldr1 <+>.
15:39:38 <JoeyA> So why doesn't cabal install the .mix files to .cabal somewhere when you install a package with --enable-library-coverage ?
15:39:39 <blaenk> yeah, was wondering if there was an already made function though
15:40:12 <JoeyA> Or does it install them somewhere global-ish that I haven't found yet?
15:40:20 <ocharles> JoeyA: sweet, I'll keep that in mind!
15:40:25 <ocharles> thanks - that'll simplify my hpc'ing :)
15:40:36 <monochrom> stawny: ok, so where are you stuck?
15:41:30 <stawny> i wolud like to keep my file in something like global field, is this possible?
15:41:38 <dmwit> No.
15:41:45 <dmwit> Pass it as an argument to the functions that need it.
15:41:52 <monochrom> or in a parameter that you keep passing around
15:42:02 <dmwit> (How is that different?)
15:42:12 <JoeyA> ocharles: though getting hpc markup to work will involve more trickery.
15:42:28 <JoeyA> Error: could not find "./Network/HTTP/Conduit/Parser.hs" in path ["."]
15:42:41 <monochrom> see my http://hpaste.org/52480 . it has to remember things. it has no global whatever.
15:42:57 <JoeyA> I guess I have to copy all of the source to a directory and use --srcdir
15:43:10 <monochrom> dmwit: fugue rather than different
15:43:48 * dmwit nods agreeably
15:44:08 <AtKaaZ> Peaker: i managed to get over the fctl in windows but stuck here http://hpaste.org/88646
15:44:55 <AtKaaZ> Peaker: maybe worth noting that i got fctl from here: http://www.opencascade.org/getocc/download/3rdparty/
15:45:10 <AtKaaZ> ftgl*
15:46:31 <monochrom> I am tempted to create an elaborate XY problem out of this.
15:46:56 <Peaker> AtKaaZ, ouch, didn't test my keyvaluehash package on windows, and seems sys/mman.h is unavailable
15:47:00 <monochrom> "you want to write an interactive program. I think you like to learn FRP and netwire..."
15:47:18 <Peaker> AtKaaZ, maybe you can build keyvaluehash in cygwin?
15:47:25 <dmwit> monochrom: Yes, or suggest ?hackage wizards
15:47:27 <dmwit> =)
15:47:35 <AtKaaZ> Peaker: I don't have it currently, unless it comes with haskell?
15:48:02 <Peaker> AtKaaZ, I don't think full cygwin does.. but a small mingw does, I think. Maybe it doesn't include sys/mman.h, I don't know
15:48:09 <Peaker> Windows is such a pain for development :(
15:48:39 <stawny> this is my problem http://wklej.org/id/1049477/
15:48:42 <monochrom> nice lib
15:49:51 <monochrom> where can I read the code for projekt?
15:49:52 <AtKaaZ> hmm, That's a POSIX facility, so you can either:
15:49:52 <AtKaaZ>  - adapt the code to use the windows memory-management API; or
15:49:52 <AtKaaZ>  - find a windows port of the mman library.
15:50:04 <AtKaaZ> Peaker ^
15:50:14 <AtKaaZ> I guess that's why you suggested cygwin
15:50:25 <monochrom> also, rewrite projekt to take one parameter, and pass xs to it
15:50:43 <Peaker> Yeah, cygwin includes more of POSIX than whatever c compilation environment you usually have with Windows or Haskell on Windows
15:50:52 <dmwit> I expect you will also have to rewrite the function shown there to take two arguments.
15:51:08 <AtKaaZ> Peaker, got it, thanks so far
15:54:34 <stawny> http://wklej.org/id/1049480/ project code
16:00:00 <stawny> monochrom, dmwit: ok, i pass it as an argument
16:03:45 <monochrom> have you read my http://hpaste.org/52480 ?
16:04:05 <stawny> yes, i did
16:17:16 <bitonic> is there any way to track down <<loop>> errors?
16:17:26 <bitonic> -xc doesnâ€™t seem to report useful information
16:17:49 <bitonic> since GHC is reporting the loop I figured it should be able to report where it detected it
16:21:27 <AtKaaZ> Peaker: ok i skipped the toubling #include from the win32 code since the msync flush wasn't implemented anyway in win32.c (i can live with it for now; some suggest using FlushViewOfFile on windows) so i managed to run it
16:22:57 <Peaker> AtKaaZ, cool
16:23:04 <Peaker> AtKaaZ, you can try to follow the tutorial
16:23:13 <Peaker> AtKaaZ, and there's more niceness in the "towards_get_field" branch
16:23:18 <Peaker> (we now have named arguments everywhere)
16:23:38 <AtKaaZ> Peaker, omg i love it
16:23:51 <Peaker> AtKaaZ, :)
16:24:00 <AtKaaZ> it's exactly what I was hoping an editor would be
16:25:09 <Peaker> AtKaaZ, press F7
16:25:23 <Peaker> AtKaaZ, oh wait, on "master" the inferred types are on by default
16:25:44 <Peaker> AtKaaZ, never mind F7 :) It will get rid of the inferred types/re-enable them  (and probably go through an unimplemented "examples" mode)
16:27:12 <AtKaaZ> this is too cool
16:27:27 <AtKaaZ> wait, am I dreaming?
16:27:45 <Peaker> AtKaaZ, it's very preliminary.. so much you can't do yet, glad you're loving it :)
16:28:03 <AtKaaZ> but the concept and all, wow
16:28:12 <Peaker> did you look at the dynamic help, btw?
16:28:18 <Peaker> AtKaaZ, You might like Ctrl+Shift+arrows
16:28:47 <AtKaaZ> Peaker, do you intend to make those be the mouse eventually?
16:29:18 <Peaker> AtKaaZ, we'll add mouse support later, but Ctrl+Shit+arrows might still be more convenient than going to the mouse for short jumps
16:29:29 <AtKaaZ> i like this natural motion like elasticity stuff
16:29:45 <Peaker> AtKaaZ, yeah, we believe smooth animations are really important for a good UI
16:29:51 <AtKaaZ> oh yes you're right about that they are close to the keyboard
16:29:59 <Peaker> Quirky jumps from one state to the next are unpleasant and disorienting
16:35:08 <brainproxy> can the yin-yang callcc example of Scheme lore be implemented using the Cont based callCC of haskell?
16:35:37 <kqr1> Peaker, why a language similar to haskell, and not haskell?
16:37:29 <Peaker> kqr1, because once we have a smart GUI to edit the code, we no longer need to hide type variables in the type system -- we can hide them in the UI, and get RankNTypes more easily, via ordinary type lambdas/etc
16:37:53 <Peaker> kqr1, and because we want to have anonymous records/sums (typically known as "structural records" and "variants")
16:38:29 <Peaker> We don't want to use tuples a lot, instead, just create a record on the spot -- and give (short?) names to the fields
16:41:38 <kqr1> ah okay
16:41:45 <mm_freak> brainproxy: Cont supports the general call/cc scheme, so the answer is "yes, if it's well-typed"
16:42:12 <brainproxy> mm_freak: right, I'm just trying to figure out how to write it out :p
16:42:35 <sedeki> just curious, what is a "call scheme"?
16:42:48 <brainproxy> not in haskell per se, but I think the monads lib I'm writing is more haskell like than scheme like
16:42:52 <mm_freak> brainproxy: i'm not sure what the "yin-yang" example is, but if you're looking for coroutines, there are better monads for that
16:42:57 <mm_freak> sedeki: call/cc
16:43:01 <mm_freak> not "call"
16:43:39 <mm_freak> brainproxy: well, obviously the first attempt would be to just rewrite the same code in haskell =)
16:43:40 <sedeki> okay, sorry. what is a call/cc scheme?
16:43:40 <brainproxy> mm_freak: http://yinwang0.wordpress.com/2012/07/27/yin-yang-puzzle/
16:44:11 <brainproxy> mm_freak: well in this case I'm developing a js monads lib, haven't learned haskell properly
16:44:22 <brainproxy> though have often been edified by reading stuff in haskell wiki, etc.
16:44:59 <mm_freak> brainproxy: well, the example performs I/O, so you would need to use ContT over IO
16:45:33 <brainproxy> yeah, i see
16:46:20 <mm_freak> > fix (\r i -> '@' : replicate i '*' ++ r (succ i)) 1
16:46:21 <lambdabot>   "@*@**@***@****@*****@******@*******@********@*********@**********@********...
16:46:43 <mm_freak> but that's not in the yin-yang style the code example uses
16:47:02 <brainproxy> right, I'm looking for something that uses Cont
16:47:17 <brainproxy> but I get what you're saying about IO, at least in principle
16:47:42 <mm_freak> you can use Writer String instead of IO
16:47:58 <brainproxy> i think I'm just going to have to wrestle with it for awhile longer in terms of my own monads lib; I understand my own implementation of Cont
16:48:08 <brainproxy> which is a good start, and my own impl of callCC
16:48:26 <brainproxy> but how to get to yin-yang equiv is not obvious to me at least at present
16:49:29 <brainproxy> slightly different subject, so I became aware yesterday, correct me if I misunderstand, that standard monads in Haskell are actually monad transformers with inner monad being Identity
16:49:31 <brainproxy> is that correct?
16:49:41 <dmwit> Some are.
16:50:06 <brainproxy> what's the advantage there, just a better generalization?
16:50:07 <brent_lap> Hi Peaker: http://hpaste.org/88647
16:50:16 <dmwit> You don't have to duplicate code.
16:50:22 <brainproxy> right, that's what I meant
16:50:30 <brainproxy> what monads are not impl'd that way?
16:50:39 <dmwit> Ones which don't have a transformer version. =)
16:50:49 <dmwit> IO, ST, [], that kind of thing
16:51:04 <brainproxy> what are ST and []
16:51:17 <dmwit> ST is only the "write and read from RAM" bits of IO.
16:51:24 <startling> brainproxy: [] is the list type
16:51:25 <dmwit> [] is the nondeterminism monad.
16:51:43 <brainproxy> oh, I thought there was a ListT
16:52:01 <dmwit> There is. But it is a commutative monad transformer, not a monad transformer.
16:52:14 <dmwit> Since not many monads are commutative, this makes it somewhat less useful than the other transformers.
16:52:48 <dmwit> There are also things like LogicT, but they don't specialize to [] really. So it makes sense to have a separate, specialized type.
16:52:56 <startling> what does commutativity mean for monads?
16:53:04 <dmwit> m >> n = n >> m, I guess
16:53:29 <dmwit> Or perhaps m >=> n = n >=> m whenever it typechecks?
16:53:33 <dmwit> Let's look it up. =P
16:54:07 <Peaker> brent_lap, the problem is that "matrix" is polymorphic on its return type, and you haven't constrained the type in any way, so GHC doesn't know which type-class instance to pick:
16:54:22 <Peaker> brent_lap, matrix (Just Projection) :: (MatrixComponent c, Matrix m) => StateVar (m c)
16:54:27 <startling> I would assume m >=> n = n >=> m, since all the monad laws are more obvious with >=>
16:54:41 <startling> but I don't understand intuitively what that means.
16:55:07 <dmwit> commutative means do { a <- ma; b <- mb; f a b } = do { b <- mb; a <- ma; f a b }.
16:55:52 <Peaker> brent_lap, according to http://hackage.haskell.org/packages/archive/OpenGL/2.8.0.0/doc/html/Graphics-Rendering-OpenGL-GL-CoordTrans.html the Matrix class has an instance GLmatrix, and MatrixComponent has GLdouble/GLfloat as instances
16:56:19 <dmwit> So the (>>) version was closer, but not quite right.
16:56:24 <startling> dmwit: ah
16:57:21 <Peaker> brent_lap, so basically, you have to constrain the type of your "mat" variable to (GLmatrix GLdouble) or (GLmatrix GLfloat). You do this by either annotating the type, or simply using "mat" as such types so the type inference can know they are those types
17:01:31 <brent_lap> Peaker: I guess getting the syntax right for that is still giving me a problem. I tried mat::(GLmatrix GLfloat) but it no like
17:03:02 <brent_lap> wait...-XScopedTypeVariables and it likes...
17:03:37 <brent_lap> Peaker: thanks, you guys have been a nice resource :)
17:03:48 <Peaker> brent_lap, ScopedTypeVariables is for type variables.. GLmatrix GLfloat doesn't have any type-varaibles
17:03:55 <Peaker> brent_lap, did you resolve the issue?
17:04:44 <brent_lap> Peaker: with the compiler flag -XScopedTypeVariables it compiles okay. Not sure why.
17:05:29 <Peaker> brent_lap, paste the code? it can't be your existing paste
17:07:55 <brent_lap> Peaker: http://hpaste.org/88648
17:09:26 <dmwit> It's probably an accident. Like ScopedTypeVariables turns on PatternSignatures or something like that.
17:09:49 <monochrom> yes that's exactly that
17:10:00 <geekosaur> it looks like recent GHC folded PatternSignatures into ScopedTypeVariables completely
17:10:02 <Peaker> "-XPatternSignatures is deprecated: use -XScopedTypeVariables or pragma {-# LANGUAGE ScopedTypeVariables #-} instead"
17:10:05 <geekosaur> I see no PatternSignatures
17:10:09 <geekosaur> ...that
17:10:15 <dmwit> interesting
17:10:24 <Peaker> weird, seems like ScopedTypeVariables is the wrong hammer to use on that
17:10:30 <Peaker> (includes much unrelated stuff)
17:10:39 <dmwit> That was my gut reaction, too.
17:10:48 <monochrom> yeah I don't understand why either. but not complaining. :)
17:11:09 <Peaker> brent_lap, instead of ScopedTypeVariables, which is simply allowing :: in left of <-   you can put the :: on the end of the line, with "IO (..)" around the type
17:11:39 <Peaker> GL.get ...  :: IO (GLmatrix GLfloat)
17:12:50 <monochrom> I understand why ScopedTypeVariable should imply PatternSignatures. you will often use the like of "(x :: type_variable) <- blah" if you have ScopedTypeVariables. I just don't understand why eliminate standalone PatternSignatures.
17:13:05 <brent_lap> Peaker: that works, thanks :)
17:13:38 <Peaker> monochrom, I think it's rather orthogonal
17:14:12 <brent_lap> I was beginning to feel like I was trying the brute force method of random characters to get the syntax right:)
17:14:13 <Peaker> surely you can find more interesting correlations between extension use patterns, that doesn't mean they should be enabled by each other
17:15:28 <stawny> i got some few functions which i use print, now i need to change it to write these messages to file, how to make it?
17:15:48 <dmwit> hPrint
17:16:00 <dmwit> alternately, writeFile . show
17:16:17 <monochrom> anyway when someone cold-calls with "what extension enables (x::Int) <- blah", it's very hard to recall ScopedTypeVariables. it is not scoped and it is not variable.
17:16:17 <dmwit> err, writeFile "foo" . show, I guess
17:17:53 <geekosaur> docs suggest the relationship is that it can be used to bring a new type variable into scope
17:18:03 <geekosaur> which, somewhat weird
17:18:05 <monochrom> appendFile "/dev/null" (show (length xs))
17:19:38 <dmwit> monochrom: such a waffler; first it was "/dev/zero", now it's "/dev/null"
17:19:50 <dmwit> (Yes, I know why.)
17:19:51 <geekosaur> :p
17:20:14 <monochrom> if you have sudo, you can also try /dev/sda
17:20:27 <dmwit> wow
17:20:41 <dmwit> That goes straight past "give them enough rope to hang themselves on Y" straight to "screw them over with Z".
17:20:47 <dmwit> =D
17:21:02 <monochrom> well, I guess /dev/tty will do for now
17:21:46 <monochrom> I just want to use a few filenames that are not entirely hypothetical
17:22:32 <dmwit> Yes. I'm sorry for snarking, you're doing a good thing.
17:23:42 <Peaker> System F inference rules can be confusing to think about
17:24:02 <monochrom> wait, inference? not just checking?
17:24:28 <dmwit> It's inference for a fragment of System F, of course.
17:24:42 <Peaker> monochrom, yeah, we do partial inference for whatever is possible, leaving holes for stuff we can't infer (pass1). Then we add rank1 type lambdas and use them in any unconstrained holes (pass2)
17:24:49 <monochrom> alright cool
17:25:28 <Peaker> and we don't allow dependent types either
17:27:35 <bitonic> Peaker: are you designing a language?
17:27:46 <startling> inference is a lot like type-checking, isn't it?
17:27:53 <Peaker> bitonic, yeah, sort of (dialect of Haskell, you could say)
17:28:15 <startling> type-checking is "see if the type of this fits one of the possibilities", where inference is "choose one of the possibilities"
17:29:03 <Peaker> startling, it's a more difficult problem... checking is easy: you just force every lambda to have an explicit param type, and every "get definition" to have an explicit type, and then propagate the types and see you don't encounter an Apply of a wrong param type or a non-Pi type
17:29:26 <Peaker> "propagate" only forward, with a very simple set of rules
17:29:41 <Peaker> inference needs to do propagation in all sorts of directions with all sorts of confusing constraints on what can or cannot be propagated
17:29:54 <startling> that's true.
17:30:05 <Philippa> startling: good type inference avoids making choices
17:30:40 <Peaker> for example, we have:   if :: (a : *) -> Bool -> a -> a -> a.      if Int :: Bool -> Int -> Int -> Int     you can propagate from the type of "if" to the type of "if Int", but you can generally not propagate information back into the type of "if"
17:30:45 <bitonic> Peaker: cool, if itâ€™s only higher ranked types there was a nice series of papers from MSR... I think elliott linked them a while ago
17:30:59 <startling> Philippa: not if there's only one choice!
17:31:37 <Philippa> startling: ...at which point "choice" is not a relevant concept
17:31:38 <dmwit> startling: There's a terminology problem here.
17:31:46 <Peaker> BUT, you *can* propagate information from the type of "if foo bar x" to the type of "if foo bar" because the type of "if foo bar" has monomorphism constraints because its type variables were already substituted, so you know they won't become new type variables to be substituted again
17:32:16 <dmwit> startling: Some people define their terms to be explicitly typed, and then type checking is very easy. Other people define their terms to be implicitly typed, and then type checking and type inference both amount to converting it to an explicitly typed term.
17:32:33 <dmwit> So depending on the definition of the language, inference can be either significantly harder or identically hard to checking.
17:32:41 <Peaker> so the rules are complicated:  Pi type -> Apply type (allowed).   Apply type -> Pi type (allowed for certain subexpressions in certain circumstances)
17:33:32 <bitonic> Peaker: thereâ€™s also pattern unification, but you probably donâ€™t need that
17:34:45 <Peaker> bitonic, As in, recursively unify matching sub-expressions?
17:35:35 <dmwit> ...that is to say, "inference" always means turning an unannotated term into an annotated one, but "checking" sometimes means that and sometimes means just sanity-checking an already-annotated term.
17:35:38 <bitonic> Peaker: no itâ€™s a decidable fragment of higher-order unification, if you want to unify lambda terms
17:35:40 <Philippa> as in Dale Miller's work
17:36:28 <bitonic> Peaker: itâ€™s needed to do inference for dep. typed languages
17:36:48 <Philippa> I don't know about needed, but it sure as hell helps
17:37:06 <Philippa> (once your inference is partial, the question is always "how much can I infer?")
17:37:33 <bitonic> Philippa: well yeah there are less powerful but simpler ways, e.g. bidirectional type checking
17:37:52 <Philippa> eh, those're two things that play nicely together
17:38:27 <Philippa> bidi checking's about your strategy for generating constraints and when you solve them, pattern unification solves specific constraints
17:40:24 <bitonic> Philippa: well the bidirectional typechecking that I know of doesnâ€™t really generate constraints but simply expects certain expressions to be typed (usually constructors) and infers when itâ€™s â€˜obviousâ€™ to do so (usually destructors)
17:40:46 <Philippa> bitonic: it buries its equality constraints!
17:40:55 <Philippa> anyway, about to be summoned elsewhere...
17:41:29 * bitonic has been struggling with some bidirectional type checking for most of today...
18:10:09 <dmwit> dcoutts_: funny thing... the other day I was complaining that cabal files have arbitrary names, and now I want to have a single directory with two different .cabal files...
18:10:24 <dmwit> Once again cabal is designed one step ahead of me.
18:10:28 * dmwit now eagerly awaits this feature
18:22:57 * hackagebot gloss 1.7.8.3 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.7.8.3 (BenLippmeier)
18:24:35 <JoeyA> Does anyone have a Windows build of the Haskell Platform 2013.2 release candidate?
18:24:57 <JoeyA> (handy, that is)
18:26:17 <JoeyA> Meh, I guess I'll just download the tarball on Windows and see if I can run through any brick walls.
18:26:22 <JoeyA> The trick is to run really really fast.
18:47:50 <JoeyA> "lambdabot mystery solved: another threadDelay case" What's the story behind this?  Just curious.
18:48:52 <shachaf> The evaluation code was using a timeout in the wrong units or something.
18:49:28 --- mode: ChanServ set +o lambdabot
18:49:33 <shachaf> @topic-tail #haskell
18:49:33 --- topic: set to '["Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.3 http://v.gd/wie445 ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D ","If Hackage is down,try: http://hdiff.luite.com "]' by lambdabot
18:49:33 --- topic: set to '["lambdabot mystery solved: another threadDelay case","Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.3 http://v.gd/wie445 ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D ","If Hackage is down,try: http://hdiff.luite.com "]' by ChanServ
18:49:33 --- mode: ChanServ set -o lambdabot
18:49:48 <shachaf> Hmm.
18:50:01 <shachaf> So much for that.
18:50:03 --- mode: ChanServ set +o shachaf
18:50:13 --- topic: set to '["Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.3 http://v.gd/wie445 ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D ","If Hackage is down,try: http://hdiff.luite.com "]' by shachaf
18:50:20 --- mode: shachaf set -o shachaf
19:17:06 <yogert> hey, is there a way to alias typeclasses in the type constraint of a function? I am finding myself having to write "foo :: (Enum a, Floating a, Fractional a) => b -> Foo a"
19:17:27 <shachaf> In recent GHC you can use ConstraintKinds and type Foo a = (Enum a, Floating a, Fraction a)
19:18:02 <yogert> i saw that and it didn't seem to work as I saw itâ€¦ granted I didn't read much about it : )
19:18:40 <yogert> i tried the first example in the red box
19:18:43 <yogert> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/constraint-kind.html
19:19:05 <yogert> and it complained about a syntax error with the "::"
19:19:35 <shachaf> Wait, type families? I didn't say anything about type families.
19:19:42 <shachaf> See the second red box for the thing I meant.
19:19:46 <yogert> ok
19:19:49 <shachaf> Anyway it's an extension, so you need to turn it on.
19:20:22 <geekosaur> presumably you'd need {-# LANGUAGE ConstraintKinds, TypeFamilies #-} for that first example
19:20:40 <shachaf> Yes, but unless you know what TypeFamilies are, I don't recommend doing that.
19:21:56 <yogert> : )  okay. Ill try it again
19:21:58 <yogert> thanks
19:23:32 <yogert> so whats the deal with all of these language extensionsâ€¦? Why have these switches that introduce functionality and change behavior?
19:24:06 <shachaf> Because they are not standard Haskell.
19:24:45 <ChongLi> they aren't portable to other implementations
19:24:50 <ChongLi> they are GHC-specific
19:24:54 <yogert> â€¦ but they are included in the standard haskell distribution. Are there the some drawbacks to including them in
19:24:56 <yogert> oh
19:24:57 <yogert> ok
19:25:06 <ChongLi> though they may eventually be incorporated into the language standard
19:25:26 <shachaf> I certainly hope ConstraintKinds isn't incorporated into the standard in the near future.
19:25:28 <ChongLi> GHC is as much a laboratory for new features as it is a production compiler
19:25:45 <geekosaur> ghc serves multiple purposes. on the one hand, it's a production Haskell compiler; on the other, it's a testbed for fancy type stuff. so you get standard Haskell by default, but can turn on particular extensions to get the experimental stuff
19:44:58 <no-n> what's the difference between :m and :m +
19:47:49 <philipdexter> :m sets the imported modules, and :m + will add new ones to the current list
19:57:03 <no-n> ah
20:15:55 <yogert> hey a question about typesâ€¦ shouldn't "Num a => [a->a->a]" describe the type of "[(+),(-),(*),(/)]"? I see that "(/)" has a type of  "Fractional a => a -> a -> a" but that I would think that "Fractional" is a "member" ( not sure if I should call it that ) of the "Num" typeclass given that "(+)" has a type of "Num a => a -> a -> a" and "4/2+1" works just fine...
20:17:17 <shachaf> Nope. Not every Num instance is a Fractional instance.
20:17:24 <shachaf> For example you can use (/) on two Integers.
20:18:04 <yogert> hmm ok
20:18:15 <bd_> > 1 / (1 :: Integer)
20:18:16 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
20:18:16 <lambdabot>    arising f...
20:18:28 <yogert> and Integer isn't an isnt an instance of Numâ€¦ ?
20:18:34 <shachaf> It is.
20:18:43 <ChongLi> :t (/)
20:18:44 <lambdabot> Fractional a => a -> a -> a
20:18:50 <otters> it is not however an instance of Fractional
20:19:44 <ChongLi> it is a bit weird
20:19:46 <yogert> ok
20:20:00 <otters> :t div
20:20:01 <lambdabot> Integral a => a -> a -> a
20:20:10 <ChongLi> ahh yeah, there you go!
20:20:22 <yogert> shachaf: wait, so is "For example you can use (/) on two Integers." a typo?
20:20:29 <shachaf> Oh.
20:20:30 <shachaf> Yes.
20:20:32 <ChongLi> > 1 `div` (1 :: Double)
20:20:33 <shachaf> That should say "can't".
20:20:34 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
20:20:34 <lambdabot>    arising from a use ...
20:20:35 <yogert> ah okay
20:20:40 <ChongLi> see now that's weird too
20:20:40 <yogert> i was confused by that
20:20:49 <otters> Double isn't an integral type
20:20:50 <ChongLi> but that's computer math for you
20:21:02 <ChongLi> gotta draw a line to keep things efficient
20:21:09 * shachaf wonders if ChongLi is trying to be unhelpful...
20:21:26 <otters> Integral = integer-y things
20:21:27 <ChongLi> shachaf: why would you accuse me of that?
20:22:35 <shachaf> I suppose the answer is no.
20:22:55 <ChongLi> I just hadn't thought about it before
20:24:02 <yogert> and would it be correct to say that Fractional is a "member" of the Num typeclass?
20:24:09 <ChongLi> I've made mistakes but I never intend to harm anyone else's learning
20:24:22 <shachaf> yogert: No.
20:24:22 <jmcarthur> yogert: no
20:24:25 <ChongLi> Fractional is its own type class
20:24:27 <shachaf> yogert: Num is a superclass of Fractional
20:24:39 <shachaf> Note that "class" has nothing to do with "object-oriented" "classes".
20:24:46 <shachaf> None of this is "object-oriented".
20:24:55 <jmcarthur> yogert: no type can be an instance of Fractional unless it is also an instance of Num, but the other way around is not true
20:25:21 <yogert> yeah, I (think) I understand that, but I wasn't sure of how to express it.
20:25:29 <ChongLi> and the superclass/subclass relationship is different; merely one of constraints
20:25:50 <jmcarthur> "class" can be interpreted as "set of types" or something
20:26:18 <jmcarthur> it's "class" as in "class of types"
20:26:58 <otters> yeah, class is short for typeclass
20:27:07 <otters> and it's not in OO languages
20:27:16 <shachaf> jmcarthur: Now explain "method".
20:27:17 <Nisstyre> jmcarthur: can it be interpreted as a set of types?
20:27:29 <yogert> so anything that is a Fractional must be a Num given "class Num a => Fractional a where..."
20:27:38 <yogert> ...right?
20:28:01 <jmcarthur> yogert: "no type can be an instance of Fractional unless it is also an instance of Num"
20:28:02 <ChongLi> I like to think of it as a constraint on types with a required set of functions (methods) which must be implemented to comply
20:28:33 <jmcarthur> i have no explanation for the term "method"
20:28:33 <ChongLi> as well as some laws, though those aren't enforced by the language
20:28:51 <jmcarthur> a method is just a value that depends on the type
20:29:02 <yogert> ChongLi: yeah. thats I have understood it as. What does the word "member" imply?
20:29:24 <ChongLi> member?
20:29:34 <jmcarthur> yogert: nothing, really.
20:29:34 <ChongLi> we use the term instance
20:30:05 <yogert> err. Well I had previously asked if calling Fractional a member of Num was incorrect
20:30:13 <ChongLi> member could probably refer to record types
20:30:20 <ChongLi> but that's unrelated :)
20:30:27 <shachaf> yogert: You brought up that word.
20:30:30 <jmcarthur> yogert: it's incorrect because it's nonsensical
20:30:31 <monochrom> Fractional is a subclass of Num
20:30:35 <shachaf> People don't use it for talking about type classes.
20:30:42 <ChongLi> instances of Fractional are also instances of Num
20:31:00 <copumpkin> is {1,2,3} a member of {1,2,3,4,5}?
20:31:02 <ChongLi> this is a constraint imposed by the definition of Fractional
20:31:13 <jmcarthur> copumpkin++
20:31:16 <yogert> yes I understand that
20:31:58 <jmcarthur> yogert: if you can answer copumpkin's question you can answer your own question about membership
20:32:23 <jmcarthur> yogert: if you cannot, that also may lead you to an answer
20:33:25 <yogert> okay, well no. I suppose "{1,2,3}" is not a member of "{1,2,3,4,5}"
20:33:32 <ChongLi> yogert: correct
20:33:39 <shachaf> copumpkin: Is n+1 defined as n âˆª {n}?
20:33:55 <ChongLi> {1,2,3} could be viewed as a set of integers
20:33:57 <copumpkin> yogert: it is a _subset_ though
20:33:57 <jmcarthur> shachaf: trickery!
20:34:01 <yogert> yes
20:34:02 <ChongLi> likewise with {1,2,3,4,5}
20:34:07 <copumpkin> those weird set theorists and nested sets
20:34:11 <ryant5000> is there any way to tell the difference between two data family instances with GHC.Generics? the Datatype class doesn't seem to tell me anything about the type arguments
20:34:12 <copumpkin> screw them
20:34:23 <popl> copumpkin: à² _à² 
20:34:27 <ChongLi> to be a member, you'd need the second one to be a set of sets
20:34:45 <copumpkin> shachaf: noes
20:34:52 <jmcarthur> ChongLi: *and* it would need to be at least {1,2,3,4,5,{1,2,3}}
20:34:52 <copumpkin> shachaf: TYPE ERROR
20:35:05 <shachaf> copumpkin: *you're* a type error
20:35:09 <copumpkin> :(
20:35:13 <popl> your mom's a type error
20:35:16 <shachaf> :(
20:35:20 <jmcarthur> type errors belong in -blah. we are well typed around these parts
20:35:21 <shachaf> copumpkin type-checks
20:35:23 <popl> BURN
20:35:30 <copumpkin> :(
20:35:52 <popl> silly
20:35:52 <monochrom> I am a kind error.
20:35:53 <yogert> jmcarthur: why "at least". Would {1,2,3} not be a subset of {{1,2,3},1,2,3,4,5}?
20:36:06 <shachaf> Wait, popl, what are you doing here?
20:36:18 <Nisstyre> yogert: {{1,2,3}} would
20:36:24 <popl> certainly not being productive
20:36:25 <jmcarthur> yogert: {1,2,3,4,5,{1,2,3}} and {{1,2,3},1,2,3,4,5} are the same set...
20:36:36 <jmcarthur> yogert: i was just adding {1,2,3} to the original set
20:36:37 <popl> shachaf: what are you doing here?
20:36:39 <ChongLi> sets aren't ordered
20:36:46 <monochrom> {1,2,3} is a subset of {{1,2,3},1,2,3,4,5}. but this is unimportant in our discussion
20:36:48 <yogert> okay. Thats what I took it as, I just was making sure I understood
20:37:17 <popl> I was defending copumpkin's honor a moment ago, I think.
20:37:26 <copumpkin> I have an honor?
20:37:27 <monochrom> we are not looking at the set {{Int,Double},Int,Double}
20:37:28 <jmcarthur> yogert: the point is that Fractional is just a name for some set of types which is actually a subset of the set of types identified by Num
20:38:08 <Nisstyre> all Fractionals are Nums but not all Nums are Fractionals
20:38:18 <monochrom> {{Int,Double},Int,Double} is likely a kind error, too.
20:38:38 <jmcarthur> monochrom: set theory /= type theory :P
20:38:39 <yogert> Okay, so the relationship might be analogous to {1,2,3,4}  {1,2,3}
20:38:44 <yogert> gotcha
20:39:02 <Nisstyre> jmcarthur: wasn't type theory developed to resolve paradoxes imposed by set theory though?
20:39:09 <jmcarthur> Nisstyre: correct
20:39:13 <ChongLi> as you can see, type classes are a whole lot simpler than classes in OOP
20:39:17 <monochrom> I like making kind errors. I am kind errors.
20:40:32 <ChongLi> classes in OOP are an amalgam of a whole bunch of different things
20:40:42 <ChongLi> which I think makes them more difficult to use and reason about
20:41:36 <popl> If it wasn't clear I was joking around earlier. :)
20:41:53 <ChongLi> type classes are a mechanism for achieving ad-hoc polymorphism
20:42:05 <ChongLi> that's really all there is to it
20:42:14 <jmcarthur> basically you want to, for now, forget OO exists. eventually you can reconsider it. there are even some fairly pleasant OO styles you can use in Haskell (although one who is not used to it might not understand it to be OO at all)
20:42:14 <yogert> sure. I don't think I was having trouble with the concept so much as choosing the right words. But thinking about it in terms of sets is helpful
20:42:27 <ChongLi> it works extremely well in tandem with parametric polymorphism
20:43:06 <ChongLi> parametric polymorphism is what you get when your function has no constraints and no concrete types
20:43:21 <ChongLi> :t id
20:43:23 <lambdabot> a -> a
20:43:25 <vazakl> i like owlz
20:43:26 <ChongLi> the canonical example
20:43:26 <yogert> ok
20:44:19 <yogert> so its essentially a function that can operate on any given type?
20:44:25 <ChongLi> yeah
20:44:33 <yogert> whats "parametric" about it?
20:44:37 <jmcarthur> that's overconstraining parametric polymorphism
20:44:47 <Nisstyre> yogert: a is a parameter of the type constructor ->
20:44:56 <yogert> ah o
20:44:57 <yogert> ok
20:45:18 <ChongLi> another example is something is cons
20:45:21 <ChongLi> :t (:)
20:45:21 <jmcarthur> any time you write a haskell function whose type includes type variables, you are using parametric polymorphism
20:45:22 <yogert> then many functions are parametric then
20:45:22 <lambdabot> a -> [a] -> [a]
20:45:28 <jmcarthur> yogert: tons
20:45:54 <jmcarthur> :t (.)
20:45:56 <lambdabot> (b -> c) -> (a -> b) -> a -> c
20:45:58 <jmcarthur> :t flip
20:45:59 <lambdabot> (a -> b -> c) -> b -> a -> c
20:46:02 <ChongLi> contrast with:
20:46:05 <Nisstyre> :t on
20:46:06 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
20:46:12 <jmcarthur> :t join :: (a -> a -> b) -> a -> b
20:46:14 <lambdabot> (a -> a -> b) -> a -> b
20:46:14 <yogert> is [a] not considered a type constraint of sorts?
20:46:16 <ChongLi> :t ((3 :: Int) +)
20:46:17 <lambdabot> Int -> Int
20:46:35 <jmcarthur> yogert: [a] is a concrete type constructor applied to a polymorphic type variable
20:46:46 <ChongLi> yogert: this is a bit of syntactic sugar
20:47:02 <jmcarthur> yogert: also notice how a lot of the function types we just showed include several named variables
20:47:29 <jmcarthur> yogert: all the "a"s in the type must be instantiated to the same type. all the "b" must be instantiated to the same type. but the "a"s don't have to match the "b"s
20:47:38 <yogert> yeah
20:47:48 <jmcarthur> this is really parametric polymorphism
20:47:54 <jmcarthur> so is
20:47:59 <jmcarthur> :t const (5 :: Int)
20:48:00 <lambdabot> b -> Int
20:48:04 <jmcarthur> even though there is an Int
20:48:11 <jmcarthur> it's still polymorphic in the argument
20:48:16 <jmcarthur> the "b" type variable
20:48:27 <jmcarthur> :t const
20:48:27 <Nisstyre> :t id (1 :: Int)
20:48:28 <lambdabot> a -> b -> a
20:48:28 <lambdabot> Int
20:48:49 <yogert> so foo :: a -> Maybe a -> Maybe a is parametric polymorphic
20:48:56 <ChongLi> yes
20:49:12 <ChongLi> because "a" can be any type
20:49:15 <yogert> yeah
20:49:52 <jmcarthur> :t \x -> Just . fromMaybe x
20:49:53 <lambdabot> b -> Maybe b -> Maybe b
20:50:09 <yogert> and typeclasses work extremely well with functions of that kind?
20:50:16 <jmcarthur> yeah!
20:50:18 <jmcarthur> :t show
20:50:20 <lambdabot> Show a => a -> String
20:50:31 <ChongLi> now here's one that will blow your mind
20:50:36 <ChongLi> :t read
20:50:37 <lambdabot> Read a => String -> a
20:50:38 <jmcarthur> show is a function that works for any type so long as there is an instance of Show for it
20:50:52 <jmcarthur> > read "5" :: Int
20:50:54 <lambdabot>   5
20:51:00 <yogert> yeah I was actually going to ask about read
20:51:00 <jmcarthur> > show (5 :: Int)
20:51:01 <lambdabot>   "5"
20:51:20 <jmcarthur> read is interesting because the implementation is determined by the *result* type rather than the argument type
20:51:24 <yogert> what about its implementation allows for that
20:51:34 <jmcarthur> read is just a name
20:51:35 <Nisstyre> > (read "5") * (read "2")
20:51:36 <lambdabot>   10
20:51:37 <ChongLi> yogert: nothing
20:51:40 <jmcarthur> the implementation is chosen based on the type
20:51:49 <ChongLi> the magic happens in Haskell's type system
20:51:50 <jmcarthur> because of the Read type class
20:52:00 <ChongLi> when we say "parametric polymorphism"
20:52:39 <ChongLi> we mean that it is parameterised by any of the type variables
20:52:49 <ChongLi> including the return type
20:53:07 <ChongLi> this works even with "regular values"
20:53:11 <Nisstyre> > sum $ read "[1,2,3]"
20:53:12 <lambdabot>   6
20:53:27 <ChongLi> > minBound :: Int
20:53:29 <lambdabot>   -9223372036854775808
20:53:43 <ChongLi> > maxBound :: Int
20:53:45 <lambdabot>   9223372036854775807
20:53:52 <yogert> :t read "1"
20:53:53 <lambdabot> Read a => a
20:54:14 <ChongLi> :t maxBound
20:54:16 <lambdabot> Bounded a => a
20:54:24 <yogert> okay. and given the context it is then used in determines the type
20:54:30 <jmcarthur> right
20:54:31 <ChongLi> you see, here we have a polymorphic value
20:54:31 <Nisstyre> yogert: exactly
20:54:39 <jmcarthur> > read "1" :: Int
20:54:41 <lambdabot>   1
20:54:43 <yogert> I'm still not clear on how to implement such a thing tho
20:54:44 <jmcarthur> > read "1" :: Bool
20:54:45 <lambdabot>   *Exception: Prelude.read: no parse
20:54:47 <Nisstyre> yogert: or you can provide an explicit type annotation
20:54:58 <ChongLi> yogert: with type classes :)
20:54:58 <Nisstyre> either way, it has to know what the return type should be
20:55:06 <jmcarthur> yogert: instance Read MyType where read str = ...
20:55:07 <Nisstyre> or else it can't pick the correct instance of Read
20:55:15 <yogert> ok, and everything provides a read implementation
20:55:19 <jmcarthur> not everything
20:55:20 <Nisstyre> yogert: not everything
20:55:24 <jmcarthur> that's the big idea
20:55:32 <yogert> well everything that is a "subset" of read
20:55:41 <jmcarthur> > read "blahblah" :: Int -> Float
20:55:42 <lambdabot>   No instance for (GHC.Read.Read (GHC.Types.Int -> GHC.Types.Float))
20:55:43 <lambdabot>    arisi...
20:56:01 <jmcarthur> yogert: every type that is an "instance" of read
20:56:33 <jmcarthur> yogert: Read is the name of the type class. read is the name of the function. Int is the name of a type. Int is an instance of Read.
20:57:17 <yogert> and to make something an instance of Read you must define how to "read" it
20:57:23 <jmcarthur> yogert: and Int->Double (the type of functions from Int to Double) is not an instance of Read
20:57:26 <jmcarthur> correct
20:57:37 <jmcarthur> yogert: using the syntax i gave above
20:57:42 <jmcarthur> yogert: instance Read MyType where read str = ...
20:57:57 <Nisstyre> yogert: type :i Read in ghci
20:58:05 <jmcarthur> @instances Read
20:58:06 <yogert> yeah I did that
20:58:06 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
20:58:16 <jmcarthur> ^^ just a partial list, really, but yeah
20:58:20 <ChongLi> @instances Bounded
20:58:21 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Dual a, Int, Ordering, Product a, Sum a
20:58:22 <yogert> theres a lot of stuf
20:58:38 <jmcarthur> Read and Show are very commonly used
20:58:51 <jmcarthur> commonly enough that haskell even has some sugar for automatically defining them
20:58:56 <bos> @pl \f g (a,b) -> (f a, g b)
20:58:56 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
20:59:05 <jmcarthur> but they (and a few other type classes) are special in that regard
20:59:08 <ChongLi> > minBound :: All
20:59:10 <lambdabot>   All {getAll = False}
20:59:17 <ChongLi> > minBound :: Bool
20:59:19 <lambdabot>   False
20:59:32 <bos> ugh, i guess pl still doesn't know about Control.Arrow
20:59:38 <jmcarthur> yeah :\
20:59:59 <jmcarthur> midnight (here)! i must sleep
21:00:01 <Nisstyre> bos: it doesn't know about "on" either
21:00:17 <ChongLi> yogert: if you think about it, one way to implement type classes is via a simple dictionary
21:00:32 <copumpkin> bos: #haskell is better at pl than @pl is
21:00:41 <copumpkin> give it to us and get the smallest expression possible back
21:00:48 <jmcarthur> pl doesn't even know (<=<), which i've found to be pretty helpful for point free at least as often as Control.Arrow stuff
21:00:49 <ChongLi> when it encounters the use of a function with a constraint applied to it, it looks up the type in the dictionary to get the appropriate function
21:00:58 <shachaf> Or your money back!
21:01:08 <bos> copumpkin: apparently
21:01:17 <copumpkin> hey, we golfed f (x, y) (a, b) = (x + a, y * b) the other day
21:01:22 <copumpkin> beat that, lambdabot
21:01:30 <jmcarthur> i forget the outcome of that
21:01:38 <jmcarthur> i need the idiom as i want that function all the time
21:01:52 <jmcarthur> i recall it wasn't super ugly
21:01:55 <yogert> ChongLi: yeah, that makes sense
21:02:20 <copumpkin> uncurry (***) . (f *** g)
21:02:41 <jmcarthur> hmm
21:02:48 <jmcarthur> no, that's still pretty ugly
21:03:12 <copumpkin> @pl \(***) -> uncurry (***) . (f *** g)
21:03:12 <lambdabot> (line 1, column 3):
21:03:13 <lambdabot> unexpected "*"
21:03:13 <lambdabot> expecting pattern
21:03:36 <jmcarthur> hmm, it seems like indexed traversals should be able to do zip-like operations
21:03:46 <copumpkin> @pl \q -> uncurry q . (f `q` g)
21:03:47 <lambdabot> liftM2 (.) uncurry (flip ($ f) g)
21:03:50 <copumpkin> there we go
21:04:21 <jmcarthur> flip ($ f) wtf
21:04:25 <copumpkin> @pl \q -> uncurry q . q (f, g)
21:04:26 <lambdabot> liftM2 (.) uncurry ($ (f, g))
21:04:56 <ChongLi> @pl \a b c -> [a,b,c]
21:04:57 <lambdabot> (. ((. return) . (:))) . (.) . (:)
21:05:26 <copumpkin> > liftA2 (.) uncurry ($ ((+), (*))) (***) (5, 6) (7, 8)
21:05:27 <lambdabot>   Couldn't match expected type `(a1, a0)' with actual type `t0 -> t1'
21:06:40 <copumpkin> > liftA2 (.) uncurry (flip ($ (+)) (*)) (***) (5, 6) (1, 2)
21:06:41 <lambdabot>   Occurs check: cannot construct the infinite type: a1 = a1 -> a1Occurs check...
21:06:44 <ChongLi> would it be possible to have a "no parens" version of pointless?
21:06:45 <copumpkin> screw you
21:09:44 <jmcarthur> :t (fmap.fmap.fmap.uncurry) (***) (***)
21:09:45 <lambdabot> (Functor (a1 (b1, b'1)), Arrow a1, Arrow a) => a1 b1 (a b c) -> a1 b'1 (a b' c') -> a1 (b1, b'1) (a (b, b') (c, c'))
21:10:23 <jmcarthur> :t ((fmap.fmap.fmap.uncurry) (***) (***) `asTypeOf` (\f g (a,b) (x,y) -> (f a x, g b y))
21:10:24 <lambdabot> parse error (possibly incorrect indentation)
21:10:38 <jmcarthur> :t ((fmap.fmap.fmap.uncurry) (***) (***)) `asTypeOf` (\f g (a,b) (x,y) -> (f a x, g b y))
21:10:39 <lambdabot> (b1 -> b -> c) -> (b'1 -> b' -> c') -> (b1, b'1) -> (b, b') -> (c, c')
21:11:51 <copumpkin> oh that's cute
21:12:26 * tgeeky has never seen "b'1" before
21:12:27 <copumpkin> I assume join on that doesn't work
21:12:32 <jmcarthur> nope
21:12:36 <copumpkin> damn join
21:12:55 <jmcarthur> the (***)s have different types
21:13:42 <jmcarthur> > (fmap.fmap.fmap.uncurry) (***) (***) (+) (*) (5, 6) (1, 2)
21:13:44 <lambdabot>   (6,12)
21:13:58 <jmcarthur> that is the weirdest haskell i've written in a while
21:17:21 <jmcarthur> @pl \f g -> (liftA2.liftA2) (,) (on f fst) (on g snd)
21:17:21 <lambdabot> (. flip on snd) . liftA2 (liftA2 (,)) . flip on fst
21:17:27 <jmcarthur> oh great
21:54:20 <kvda> i have i have 2 functions in a module, one is using the other, how can i over-ride the sub-function when using the module?
21:55:24 <ChongLi> kvda: could you make one function take the other as a parameter?
21:57:37 <kvda> i almost did that, but though there could be another way by hiding the old func
21:58:07 <ChongLi> hiding from a module's exports only serves to hide implementation
21:58:19 <ChongLi> it doesn't affect the semantics
21:59:02 <kvda> right
21:59:02 <shachaf> If you're hoping for a dynamic scoping thing of some kind, that probably isn't a good (or workable) idea
22:01:37 <kvda> shachaf, yep that sounds right, it probably started from a wrong assumption about scoping
22:02:18 <shachaf> When you have "blah = ...x...", that x refers to the value, not the name.
22:02:56 <johnw> not to mention that dynamic scoping is a blight
22:02:58 <shachaf> blah is forever bound to that particular value.
22:03:02 <ChongLi> yeah
22:03:26 <ChongLi> didn't dynamic scoping start out as a bug (which was later fixed by Gerry Sussman and co.)?
22:03:51 <shachaf> Lexical scoping existed before programming languages, surely.
22:04:11 <johnw> Yes, the ability to just say "John" without saying the full name goes back a long way
22:04:23 <shachaf> ?
22:04:34 <johnw> in human conversation, lexical scoping â‰… proximity of the speaker
22:04:54 <johnw> i thought you meant WAY before programming languages :)
22:05:22 <shachaf> That sounds too vague for me to understand.
22:05:29 <ChongLi> yeah
22:05:40 <popl> that's abstract
22:05:40 <johnw> not worth explaining
22:05:54 <popl> like talking about the scope of a chemical reagent
22:05:59 <popl> :)
22:07:17 <ChongLi> ahhh, right
22:07:43 <ChongLi> Scheme was the first to adopted lexical closures
22:08:21 <shachaf> popl: You've previously stated that you're in this channel mostly to talk about things that aren't Haskell. Has that changed?
22:08:27 <ChongLi> and that turned out to be a very magical idea
22:08:30 <popl> shachaf: I said that?
22:09:00 <shachaf> I thought so.
22:09:24 <popl> What?
22:10:49 <ChongLi> gah, wikipedia's example of a closure uses mutation :(
22:13:49 <popl> shachaf: I cannot find evidence of that in any of my log files.
22:13:57 <popl> It's possible I might have missed something, though.
22:14:05 <popl> Do you have ar ecord of me saying anything like that?
22:15:17 <shachaf> I don't remember.
22:15:19 <Nisstyre> johnw: just saying "John" without saying the full name would seem like a kind of anaphora (See: http://en.wikipedia.org/wiki/Anaphora_(linguistics) )
22:15:38 <Nisstyre> which is pretty similar to how names are resolved with lexical scope I guess
22:15:41 <popl> shachaf: Then is it right for you to make that claim? :)
22:16:04 <johnw> ah, that's where the term "anaphoric if" comes from, got it
22:16:58 <ChongLi> typically, an anaphor is a pro-form
22:17:07 <Nisstyre> ChongLi: but it doesn't have to be
22:18:11 <ChongLi> do you have an example?
22:19:49 <Nisstyre> ChongLi: hmm actually I think it would be "Exophora"
22:42:01 <nan`> are existential types bad?
22:42:13 <shachaf> No. But some uses of them are inappropriate.
22:44:20 <nan`> Hm
22:44:41 <Cale> nan`: Why would the GHC developers put lots of effort into implementing them if they were bad?
22:45:25 <shachaf> Cale: They haven't put enough effort into implementing them to make them first-class!
22:45:37 <shachaf> Anyway, GHC developers implement a lot of experimental features and extensions.
22:45:45 <shachaf> Some are universally considered bad, like n+k types.
22:45:54 <Cale> n+k patterns, you mean?
22:46:06 <shachaf> Er, yes. That.
22:46:09 <Cale> (Those were part of the standard!)
22:46:34 <mgsloan> Ooh, new extension for type families / typenats: NPlusKTypes
22:46:36 <mgsloan> ;)
22:46:52 <shachaf> I know.
22:46:53 <Cale> Better example of a feature that wasn't wildly successful: linear implicit parameters.
22:47:03 <Cale> But it's hard to say these are outright bad.
22:48:02 * hackagebot terminal-size 0.2.0.0 - Get terminal window height and width  http://hackage.haskell.org/package/terminal-size-0.2.0.0 (MatveyAksenov)
22:50:36 <mgsloan> Hmm, linear implicit parameters are interesting.  I bet they'd be used more if implicit parameters in general were used more
22:52:02 <Cale> mgsloan: It's implicit State monad -- there's a reason to see that as somewhat inappropriate :)
22:52:52 <hcaulfield57> Why does something like "let add x y = x + y" and "add 1 10 + 5" work? Since functions take precedence over operators, wouldn't that be more than two arguments?
22:53:15 <arkeet> that's parsed as (add 1 10) + 5
22:53:20 <dibblego> hcaulfield57: it does this (add 1 10) + 5
22:53:29 <arkeet> + is not an "argument"
22:53:36 <dibblego> (+) would be an argument!
22:53:39 <arkeet> yes
22:53:39 <hcaulfield57> arkeet: Ohhhhh
22:54:01 <hcaulfield57> Okay that makes sense, stupid me
22:54:03 <hcaulfield57> Thanks guys
22:55:34 <mgsloan> Cale: It's quite like a comonoid, because the result of "split" is pure.  It'd be nastier but maybe more useful if the result was monadic
22:55:58 <mgsloan> Cale: So I guess I'm not seeing how it's an implicit state monad, since there's no "put"
22:57:07 <Cale> http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue2/FunWithLinearImplicitParameters
22:57:25 <Cale> actually, you can do some really crazy stuff with them :)
22:57:47 <Cale> (It's pretty subtle though)
22:57:57 <Cale> I admit it was never really intended to be used like that
22:58:23 <mgsloan> Ahh, of course, "a" could be some side effecting thing
22:58:49 <nan`> how do you make a getter for a gadt-style type like this http://hpaste.org/88660
22:58:56 <Cale> Actually, I forget, maybe that really did involve some evil
22:59:22 <nan`> i want a getBlah2 :: (Show a) => Blah2 -> a
22:59:22 <Cale> But I seem to recall you could do some mildly evil things with linear implicit parameters alone
22:59:41 <shachaf> nan`: The GHC user's guide specifies the exact syntax. I don't remember it.
22:59:50 <shachaf> nan`: But in this case the issue isn't syntax. You can't make that function.
23:00:15 <shachaf> You're mixing up forall and exists. Your type promises that getBlah2 can return a value of *any* type (as long as it's in Show).
23:00:21 <nan`>  Could not deduce (t ~ a)
23:00:32 <nan`> haha
23:00:34 <shachaf> Whereas there's just one specific type. You don't know what it is.
23:00:51 <shachaf> The only thing you can do with a Blah2 value is show it (and showsPrec, but that's probably not relevant for you).
23:00:52 <nan`> thanks
23:01:03 <shachaf> So Blah2 is more or less the same thing as String. You should just use a String. :-)
23:01:23 <nan`> that was just my example
23:01:37 <nan`> here's my real abuse
23:01:38 <nan`> data Blah where Blah :: Show a => (FileStatus -> a) -> Blah
23:01:40 <shachaf> Right. Your example is a classical example of a place where existential types *aren't* appropriate.
23:02:10 <shachaf> Why not just use (FileStatus -> String)?
23:02:15 <nan`> i'm doing this so i can put a bunch of functions of type (FileStatus -> a) into the same list
23:02:27 <johnw> FileStatus -> String would still allow that
23:02:35 <shachaf> But the only thing you can do with those functions, once you apply them, is show (and showsPrec etc.)
23:02:35 <johnw> and is isomorphic to Show a => (FileStatus -> a)
23:02:43 <nan`> and i don't want to type [ (show . fileID), (show . deviceID) ] because i'm really lazy
23:03:08 <shachaf> But you're OK with [Blah fileID, Blah deviceID] ?
23:03:10 <johnw> name them fileIDstr and deviceIDstr :)
23:03:18 <nan`> i was just playing with what's out there ;)
23:03:46 <nan`> i thought maybe i could generalize it more if it was all in one type
23:04:18 <nan`> but that is probably not true
23:06:32 <Cale> nan`: While you can't write getBlah2 :: (Show a) => Blah2 -> a
23:06:42 <Cale> You can write  getBlah2 :: Blah2 -> String
23:07:13 <Cale> defined by  getBlah2 (Blah2 x) = show x
23:09:32 <Cale> nan`: The type of x in that definition is specific, but unknown. The only thing you know about x's type is that it's an instance of Show, so the Show operations can be applied.
23:10:19 <nan`> Cale: ya that's what i ended up doing
23:10:28 <nan`> i made a showBlah :: FileStatus -> Blah -> String
23:10:34 <nan`> it works and it's terrible
23:10:36 <nan`> thanks
23:10:47 <nan`> exactly what i wanted
23:13:31 <nan`> this is the whole thing, i wonder if anything else can be done to it http://hpaste.org/88661
23:14:01 <shachaf> Yes: Use strings instead of an existential type.
23:14:12 <shachaf> Really, it's a much better solution. What was the objection to it?
23:14:27 <nan`> Oh, i am just experimenting
23:14:41 <nan`> lol
23:14:54 <nan`> BUT
23:15:12 <nan`> in this case, now i can have some selection and then use the list in different ways
23:15:24 <nan`> for example i could add more contexts to BLah
23:15:29 <nan`> write another function
23:15:42 <nan`> have some runtime selection pick a mapper
23:15:54 <shachaf> Yes, but there are also other things you can do in the case where you have other operations.
23:15:59 <Cale> nan`: Instead of Blah, how about  blah :: (Show a) => (FileStatus -> a) -> (FileStatus -> String) ?
23:16:34 <nan`> shachaf: "in the case where you have other  operations.
23:16:35 <nan`> ?
23:16:36 <Cale> and then  items :: [FileStatus -> String]
23:16:50 <shachaf> nan`: Yes. Other operations than show.
23:17:00 <nan`> Cale in that case how would i write items?
23:17:36 <arkeet> nan`: just [fileID, deviceID] or so in that case
23:17:47 <nan`> really?
23:18:00 <arkeet> uh
23:18:07 <nan`> those are mixed types
23:18:07 <arkeet> or compose with show, or who knows what
23:18:11 <shachaf> nan`: You would write [blah fileID, blah deviceID]
23:18:15 <shachaf> With Cale's blah.
23:18:18 <arkeet> sure
23:18:26 <arkeet> but cale's blah is just (show .)
23:18:32 <shachaf> Sure.
23:19:13 <arkeet> a (Show a) consext is exactly the same as a (a -> String) argument
23:19:17 <arkeet> context too
23:20:07 <nan`> oh
23:20:14 <nan`> hehe
23:20:20 <shachaf> Almost exactly.
23:20:24 <Cale> http://hpaste.org/88661
23:20:33 <nan`> but
23:20:36 <Cale> oops!
23:20:46 <Cale> Did I edit instead of annotate?
23:20:47 <Cale> Sorry
23:20:52 <arkeet> yes
23:21:05 <arkeet> I can edit it back
23:21:08 <nan`> YOU BROKE MY PASTE
23:21:09 <nan`> lol
23:21:27 <arkeet> fixed
23:21:45 <arkeet> er
23:21:46 <nan`> Cale's blah does not allow me to make general operations on the list
23:21:49 <arkeet> fixed
23:22:01 <arkeet> now cale's is gone oops
23:22:03 <Cale> nan`: ?
23:22:18 <arkeet> cale's blah is exactly as powerful as your blah
23:22:20 <nan`> i have to show items
23:22:23 <nan`> show the items
23:22:31 <nan`> in my sample i can add more contexts
23:22:34 <nan`> i think
23:22:35 <Cale> there, added an annotation
23:22:35 <arkeet> because Blah is really isomorphic to FileStatus -> String
23:22:42 <arkeet> really
23:22:50 <nan`> i don't know how the context pattern matching actually works
23:23:07 <nan`> what if you have two contexts, do you just write two definitions
23:23:23 <nan`> (GADT context implicit pattern matching)
23:23:31 <arkeet> I'm sleepy, bye
23:23:35 <nan`> bye
23:25:57 <Cale> nan`: Sorry, can you provide an example of what you're asking about?
23:27:27 <nan`> Cale: http://hpaste.org/88665
23:27:34 <nan`> witness the beauty
23:28:17 <nan`> just kidding, once again, i am just exploring this i am not saying this is better
23:28:33 <Cale> Yes, Storable is a more interesting class than Show is.
23:28:48 <Cale> But still, you *could* also package up the results of the Storable operations.
23:29:08 <Cale> well...
23:29:15 <Cale> heh, maybe not in Storable's case
23:29:18 <nan`> but it does allow more flexibility so in a way my way is better
23:29:21 <Cale> because of the operations on Ptr a
23:29:30 <Cale> Sometimes, yeah
23:30:06 <nan`> but
23:30:08 <nan`> it feels nasty
23:30:20 <Cale> However, if you're creating a new typeclass for the sole purpose of the existential, it's often good to take a step back and ask whether you really need it.
23:30:45 <Cale> Records of the results of what would have been the typeclass methods (in cases where that applies) can often be more flexible.
23:30:59 <nan`> basically i made that typeclass just so i could have a mixed type list
23:31:07 <Cale> You can only have one class instance per type, and while that's sometimes good, it's also sometimes awkward.
23:31:10 <hcaulfield57> This doesn't work because (>>) is trying to apply a function rather than an IO monadic value right? In line 5 http://hpaste.org/88666
23:31:43 <nan`> i'm going to try to do it with a record
23:31:50 <nan`> the record is going to require lots of boilerplate though
23:32:03 <nan`> i mean the operations on them
23:32:12 <Cale> hcaulfield57: $ has lower precedence than >>
23:32:40 <Cale> If you just wrote  yes (x:xs)
23:32:42 <Cale> then it'd work
23:32:49 <arkeet> or (yes $ x:xs)
23:32:53 <hcaulfield57> Cale: Okay, so with something like "yes (x:xs)" the function gets executed whereas $ delays it I guyess
23:32:58 <arkeet> no
23:33:01 <arkeet> it's just a grouping thing
23:33:06 <Cale> hcaulfield57: Better just to think of it as precedence levels
23:33:16 <arkeet> better because that is all it is.
23:33:18 <hcaulfield57> Cale: It would take higher precedence then
23:33:25 <epta> How can some nested data type like ` Map String (Timestamp, Map String (String, Maybe String))` could be implemented in python without classes? I googled nothing :[
23:33:31 <Cale> Just like how 5 * 4 + 3 is (5 * 4) + 3 instead of 5 * (4 + 3)
23:33:46 <Cale> putStrLn x >> yes $ x:xs
23:33:47 <Cale> means
23:33:58 <Cale> (putStrLn x >> yes) $ (x:xs)
23:34:16 <hcaulfield57> Because the precedence is changed by ($), okay
23:34:40 <Cale> While plain function application (whitespace) has higher precedence than any infix operator
23:35:05 <Cale> So putStrLn x >> yes (x:xs) means  (putStrLn x) >> (yes (x:xs))
23:35:06 <hcaulfield57> So normally it would be like (putStrLn x) >> (yes (x:xs))
23:35:15 <Cale> right
23:35:31 <hcaulfield57> Haha, beat me. Thanks Cale
23:37:02 <Cale> Also, mostly as trivia, if you wrote  putStrLn x >> yes x : xs  that would mean  (putStrLn x) >> ((yes x) : xs)
23:37:16 <Cale> (and you'd get a type error for another reason)
23:37:39 <hcaulfield57> Cale: Yea noticed that originally. I don't know why precedence in Haskell is giving me so much trouble understanding.
23:38:15 <Cale> The most important thing to understand is the point I mentioned about whitespace
23:38:26 <Cale> That it binds more tightly than any infix operator can
23:38:44 <Cale> and then that $ binds as loosely as possible
23:38:58 <Cale> (but means the same thing beyond that)
23:39:15 <hcaulfield57> Cale: Yea I got that. I think I just forget because in C what I learned before Haskell, function application was more explicit with paranthases
23:42:03 <blueonyx> hi, is there already like a even more abstract name for this typeclass: class ConvertibleUnits a b where convertUnit :: a -> b
23:42:03 <no-n> is there a shorthand for "import qualified Blah.Blah as B" in ghci as there is for import Blah.Blah (:m + Blah.Blah)?
23:42:08 <blueonyx> ?
23:44:39 <hcaulfield57> Okay, thanks again Cale
23:44:47 <blueonyx> or is there even some physics package with stuff like kJ<>cal conversions, constants etc?
23:44:54 <nan`> no-n: i dunno, i was wondering the same thing
23:45:00 <Cale> no-n: I don't think there is.
23:45:30 <Cale> The ability to import things qualified in ghci is new, and came along with or shortly after the feature to import using full import declaration syntax.
23:45:44 <Cale> (It used to be you could only :m + them in)
23:45:54 <no-n> ah
23:46:00 <nan`> maybe you can make an alias
23:46:05 <no-n> so import qualified is fairly new to the language itself?
23:46:11 <mauke> no-n: no
23:46:29 <nan`> http://hackage.haskell.org/trac/ghc/ticket/1895
23:46:34 <mauke> ghci /= the language
23:46:40 <no-n> I know
23:46:45 <Cale> blueonyx: there's this: http://hackage.haskell.org/package/dimensional-0.10.2
23:46:50 <no-n> hence "itself"
23:47:04 <Cale> blueonyx: it's... a little impractical, to say the least
23:48:07 <blueonyx> thanks anyhow Cale :)
23:48:11 <Cale> And then there's some stuff in numeric-prelude, but that package is sadly unusable since Henning Thielemann maintains it and renamed all the types to T
23:49:22 <blueonyx> fork yourself
23:49:30 <blueonyx> nope
23:49:34 <blueonyx> "fork you"
23:49:37 <nan`> it looks like you can make a custom :def to do it http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/ghci-commands.html
23:51:55 <dhun> how can i include the non exported functions of a modules in the haddock documentation
23:51:55 <lambdabot> dhun: You have 1 new message. '/msg lambdabot @messages' to read it.
23:54:11 <shachaf> dhun: I don't know if you can, but you probably shouldn't.
23:54:45 <dhun> well I am just proofreding my documentation, so would be nice to print out everything
