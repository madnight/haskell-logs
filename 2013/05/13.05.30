00:13:24 <adnap> Did hpaste used to evaluate pastes?
00:13:32 <ion> no
00:13:53 <adnap> Also, there used to be a bot in here that reported pastes
00:14:22 <adnap> ... that were tagged with #haskell
00:14:22 <shachaf> We got rid of the bot because of the spam.
00:14:25 <johnw> hpaste was being spam bombed
00:15:31 <elliott> wasn't it going to be turned back on?
00:15:48 <shachaf> When it was fixed.
00:15:56 <shachaf> Looking at hpaste.org, the situation doesn't look great.
00:19:08 <johnw> i thought so, but maybe something happened again
00:19:12 <adnap> I am having a problem interpreting my own types: http://hpaste.org/88866
00:19:49 <adnap> I get an error that they are not Typeable. I guess Typeable instances aren't automatically created
00:20:20 <johnw> I can't think of any instances that are
00:20:27 <ion> {-# DeriveDataTypeable #-}, import …, data T = … deriving (Typeable)
00:21:54 <adnap> I'm not sure I understand Typeable. Does it mean that given a string representing a value of a type, there is only one possible type that could be inferred?
00:22:41 <adnap> The class only has one method: typeOf :: a -> TypeRep
00:22:48 <elliott> I'm not quite sure what you mean by that but I don't think it's true :P
00:23:09 <adnap> "Takes a value of type a and returns a concrete representation of that type. The value of the argument should be ignored by any instance of Typeable, so that it is safe to pass undefined as the argument. "
00:23:26 <shachaf> Where did strings get into it?
00:23:36 <adnap> My imagination
00:23:39 * adnap laughs
00:24:03 <adnap> I was imagining typing out a value of a type
00:24:12 <adnap> Like...
00:24:13 <adnap> Nothing
00:24:22 <adnap> (Maybe a)
00:24:44 <adnap> Anyways...
00:24:53 <adnap> What is a "concrete representation"?
00:25:17 <elliott> a value describing the type of the value.
00:25:17 <adnap> Nevermind
00:25:23 <elliott> for instance, you can get the name of the type out of it.
00:25:33 <adnap> Okay
00:25:40 <johnw> adnap: have you seen typeid() in C++?
00:25:47 <adnap> I think so
00:26:48 <johnw> so, normally types don't exist at runtime; with Typeable you can ask things at runtime about the type of a value
00:26:52 <adnap> I'm not sure how to make a TypeRep
00:27:03 <adnap> This is what is supposed to be a "concrete representation"
00:27:16 <adnap> There is no value constructor exposed
00:27:18 <elliott> there are functions for making a TypeRep in Data.Typeable.
00:27:38 <elliott> but you're not supposed to write Typeable instances yourself; usually you derive them.
00:28:01 <adnap> What is a function which makes a TypeRep>
00:28:18 <adnap> Every one I see requires a TypeRep as an argument
00:28:22 <elliott> @hoogle TypeRep
00:28:23 <lambdabot> Data.Typeable data TypeRep
00:28:23 <lambdabot> Data.Typeable typeRepArgs :: TypeRep -> [TypeRep]
00:28:23 <lambdabot> Data.Typeable typeRepKey :: TypeRep -> IO Int
00:28:25 <elliott> aw.
00:29:03 <johnw> mkTyCon3, for example
00:29:18 <elliott> johnw has a faster browser than I do.
00:29:34 <adnap> I don't see that one
00:29:43 <johnw> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Typeable.html
00:29:45 <johnw> it's on that page
00:29:52 <adnap> I am on http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/Data-Typeable.html
00:30:13 <johnw> that's an older version
00:30:15 <adnap> A TyCon is not a TypeRep
00:30:53 <johnw> no, but you can use mkTyConApp to turn it into one
00:30:55 <johnw> just keep reading
00:31:15 <elliott> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Typeable.html#g:4
00:31:18 <adnap> It requires a list of TypeRep
00:31:23 <adnap> I guess I could just use []
00:31:28 <adnap> I didn't think of that
00:31:32 <elliott> I looked at the sidebar, clicked "Construction of type representations". you can too
00:31:44 <adnap> OMG
00:31:48 <adnap> I was there the whole time
00:31:52 <adnap> Give me a break
00:32:11 <adnap> I said "Every one I see requires a TypeRep as an argument"
00:32:34 <johnw> > break (=='n') "adnap"
00:32:35 <lambdabot>   ("ad","nap")
00:32:56 <adnap> I was actually referring to mkTyConApp, mkAppTy, and mkFunTy
00:32:59 <elliott> well, you weren't exactly specific... anyway, mkTyConApp takes the "type arguments"
00:34:02 <adnap> Okay, I get it now
00:34:03 <adnap> Thanks
00:34:23 <elliott> (e.g. Int in Maybe Int)
00:35:15 <adnap> Can you make an instance of Typeable for a type which has a phantom polymorphic type?
00:35:17 <dmwit> Was it mentioned that you're not supposed to call these functions yet?
00:35:23 <adnap> dmwit: Yes
00:35:27 <dmwit> ok
00:35:34 <adnap> Like...
00:35:38 <adnap> data T t = T Int
00:35:44 <dmwit> Yes, I don't see why you couldn't derive an instance of Typeable for that.
00:35:57 <dmwit> It's easy to test, though. Just write
00:36:04 <dmwit> data T t = T Int deriving Typeable and see for yourself.
00:36:05 <adnap> Yes, sorry
00:36:24 <elliott> in fact in the newest GHC you cannot hand-write a Typeable instance
00:37:00 <adnap> elliott: Why?
00:37:07 <adnap> Oh
00:37:12 <adnap> Wait...
00:37:13 <elliott> because they are all automatically derived
00:37:14 <adnap> Yeah, why?
00:37:19 <elliott> (it is more flexible to allow this)
00:37:22 <elliott> by newest, I mean unreleased HEAD
00:37:30 <elliott> also, writing your own Typeable instances is risky: it is unsafe
00:37:36 <elliott> which is why, as said, you should derive them
00:37:43 <adnap> Do you mean that you don't even have to write "deriving Typeable"?
00:37:54 <adnap> Or that they should be automatically derived if you want them?
00:37:54 <johnw> certainly you have to write that
00:38:03 <shachaf> In HEAD you don't have to write that.
00:38:03 <johnw> there is no instance of any type class that is automatically derived for you
00:38:21 <shachaf> In Haskell 1.whatever Eval was similarly "autoderived".
00:38:40 <elliott> johnw: no, it is autoderived
00:38:43 <mgsloan> Yeah, wasn't auto deriving of Typeable discussed when generalizing it beyond "*"
00:38:58 <johnw> elliott: he won't have to write "deriving Typeable"?
00:39:22 <dmwit> neat
00:39:26 <elliott> johnw: correct.
00:39:30 <shachaf> In HEAD.
00:39:32 <johnw> interesting!  what about Data and Generic?
00:39:45 <elliott> don't know. but I seriously doubt it, that would violate data abstraction
00:39:51 <johnw> true
00:40:00 <johnw> typeable doesn't give you any additional access, does it
00:40:06 <shachaf> Data is different.
00:40:19 <johnw> if you know enough to ask for the TypeRep, you already know what Typeable can tell you
00:41:14 <dmwit> hm
00:41:37 <dmwit> Does GHC use the fact that all types have Typeable instances? (Can I leave Typeable constraints out of my contexts?)
00:41:50 <shachaf> No, you can't leave Typeable constraints out.
00:41:57 <dmwit> why nooooooot
00:42:17 <shachaf> I refer to that scenario as "monochrom's nightmare".
00:42:26 <dmwit> Nobody likes parametricity anyway.
00:42:27 <shachaf> (Actually I don't.)
00:42:35 <adnap> Well, that's good that they will be autoderived
00:42:49 <mgsloan>  Does this mean that manual Typeable instances are disallowed?
00:42:53 <adnap> Because my next question was if I can create Typeable instances for types in other packges
00:43:06 <dmwit> adnap: StandaloneDeriving, so... yes.
00:43:13 <mgsloan> when does the automatic instance get "suppressed", if they are allowed?
00:43:15 <dmwit> Even today.
00:43:15 <adnap> dmwit: I'm not familiar with that
00:43:34 <adnap> I'll check it out; thanks
00:43:46 <dmwit> adnap: It lets you write "deriving instance Typeable MyOtherPackage'sType".
00:44:06 <shachaf> Don't create orphan instances, though.
00:44:15 <dmwit> mgsloan: You are not permitted to write your own instance of Typeable in the newest GHCs.
00:44:24 <mgsloan> dmwit: Cool!
00:44:34 <mgsloan> as it should be :D
00:45:02 <adnap> dmwit: Does that "deriving" trail something, or do you literally jut put that in the code?
00:45:03 <elliott> well, you're permitted
00:45:10 <elliott> it just does nothing
00:45:10 <dmwit> adnap: literal
00:46:00 * dmwit bows backwards to the god of compatibility
00:46:38 <mgsloan> adnap: It's also useful when deriving instances of MPTCs and such
00:47:11 <adnap> What's an MPTC?
00:47:43 <shachaf> @google what's an MPTC? haskell
00:47:44 <lambdabot> http://www.haskell.org/pipermail/haskell-prime/2010-May/003187.html
00:47:44 <lambdabot> Title: Proposal to solve Haskell's MPTC dilemma
00:47:54 <adnap> Also, fly me to the moon and let me play among the stars
00:50:22 * hackagebot CCA 0.1.4 - preprocessor and library for Causal Commutative Arrows (CCA)  http://hackage.haskell.org/package/CCA-0.1.4 (PaulLiu)
00:52:35 <adnap> Okay, so "data T t = T Int deriving Typeable" doesn't seem to work
00:53:48 <elliott> what error do you get?
00:53:51 <johnw> "doesn't seem to work" is equivalent to not saying anything at all
00:55:02 <adnap> Working on it
00:55:07 <adnap> http://hpaste.org/88869
00:55:48 <elliott> that is because the derived instance is instance Typeable t => Typeable (T t).
00:56:01 <elliott> your signature is i :: Interpreter (T t), but it requires an instance Typeable (T t)
00:56:06 <elliott> therefore it requires Typeable t, per standard instance resolution
00:57:17 <adnap> I don't understand...
00:57:40 <adnap> So, I didn't have to put any class qualifications in my i signature when T was just "data T = T Int"
00:58:07 <elliott> well, the TypeRep contains information (as TypeReps) about the type parameters
00:58:10 <adnap> Also, I think I'm getting confused because I don't know what "t" is
00:58:13 <elliott> as we saw in the constructor functions
00:58:21 <elliott> therefore, a TypeRep for (T t) contains a TypeRep for t
00:58:25 <ion> Int is an instance of Typeable, “t” is not.
00:58:25 <adnap> Whether you're referring to my phantom type or some socket in the Typeable class
00:58:31 <elliott> therefore, the Typeable instance for T t requires a Typeable instance for t
00:58:40 <elliott> I am referring to the t in your (T t) in your "i"
00:59:13 <adnap> Oh, I see
00:59:22 <adnap> But how could there be a Typeable instance for t?
00:59:24 <adnap> It's a phantom type
00:59:25 <elliott> (more precisely, what actually gets generated is an instance Typeable1 T and then the Typeable instance used is a generic one based on that, but that's just complication here...)
00:59:36 <elliott> adnap: it depends on what t is, of course
00:59:45 <adnap> So...
00:59:51 <adnap> In order to interpret
00:59:53 <elliott> if "i" wants to use the Typeable instance for (T t), then it needs a Typeable instance for t, whatever t is
01:00:00 <adnap> I have to give t a type?
01:00:11 <elliott> what's wrong with just adding a Typeable t => to the type of "i"?
01:00:21 <adnap> Nothing I think
01:00:22 * hackagebot robots-txt 0.2.0.0 - Parser for robots.txt  http://hackage.haskell.org/package/robots-txt-0.2.0.0 (MarkWotton)
01:00:25 <adnap> Let me try that now
01:00:44 <elliott> alright
01:01:25 <adnap> "Could not deduce (Typeable t1) arising from a use of `as
01:01:32 <adnap> ...
01:02:27 <adnap> So, I have "interpret "T 42" (as :: T t)"
01:02:29 <blackdog> re that last upload: robots.txt RFC is on crack.
01:03:01 <elliott> adnap: because that is a different t
01:03:06 <elliott> it's the same as (as :: forall t. T t)
01:03:11 <elliott> or (as :: T asdf)
01:03:16 <elliott> type variables aren't scoped by default
01:03:21 <adnap> I just tried
01:03:27 <adnap> "interpret "T 42" (as :: Typeable t => T t)
01:03:43 <elliott> you probably want to enable ScopedTypeVariables and put "forall t." in i's signature
01:03:49 <elliott> that way, the "t" inside the body will refer to the same "t"
01:03:54 <adnap> Ohhh
01:03:55 <adnap> YEs
01:04:18 <adnap> I'm pretty new to ScopedTypeVariables, but I know what that does
01:04:37 <dmwit> Would it surprise you if I told you that was the same as: interpret "T 42" (as :: Typeable definitely_not_t => T definitely_not_t)
01:04:48 * dmwit puts on cool Morpheus sunglasses
01:05:24 <adnap> I don't... think so?
01:05:27 <yitz> are there expressions which can *only* be typed correctly by using ScopedTypeVariables?
01:05:36 <aleator> Hi, I seem to remember that there was some difficulty to have a language with that allowed both subtyping and abstracting over type constructors, but can't recall what the argument was. Any ideas?
01:05:37 <adnap> Like, I think I would need an instance of Typeable for "definitely_not_t"
01:06:18 <yitz> aleator: define what you mean by "subtyping". are you talking about OO languages only?
01:06:23 <Dacto> Is there a way in which I can update a Data.Map for each item in a list (treated as the keys)? I was thinking of mapping the update over the list but I'm not sure how to flip the last two arguments of 'update'.
01:06:33 <adnap> dmwit: Er... can you clarify what the antecedent of "that" is?
01:06:45 <elliott> yitz: you can always do asTypeOf tricks, I'm sure
01:06:56 <shachaf> Dacto: Sounds like maybe you want a fold, not a map.
01:07:04 <shachaf> But I'm confused about what you're trying to do, so I'll stop guessing.
01:07:31 <dmwit> adnap: This is the antecedent: interpret "T 42" (as :: Typeable t => T t)
01:07:47 <aleator> yitz: Well, hand-wavingly: kinda like in oo. Being able to pass a more specific type in places where more general is expected kind of thingy.
01:08:01 <Dacto> Well I have a Map and I would like to update the key's values for the keys that are in a given list.
01:08:14 <adnap> dmwit: Okay, yes it is a surprise
01:08:15 <shachaf> Maybe give a concrete example.
01:08:15 <aleator> yitz: The thing you have in scala for instance.
01:08:32 <adnap> dmwit: What does changing the name of t do if ScopedTypeVariables isn't enabled?
01:08:37 <dmwit> Dacto: How to flip the last two arguments of foo: \x y z w -> foo x y w z
01:08:54 <dmwit> adnap: Absolutely nothing.
01:09:13 <shachaf> dmwit: But what letter comes after w? If you have 5 arguments, you're stuck!
01:09:32 <Dacto> dmwit: not sure what you did besides the lamda..
01:09:32 <dmwit> v u t s r q p o n m l k j i h g f e d c b a
01:09:41 <dmwit> Dacto: Absolutely nothing.
01:09:56 <Dacto> uhh
01:10:22 * hackagebot x509 1.4.3 - X509 reader and writer  http://hackage.haskell.org/package/x509-1.4.3 (VincentHanquez)
01:10:24 * hackagebot x509-store 1.4.1 - X.509 collection accessing and storing methods  http://hackage.haskell.org/package/x509-store-1.4.1 (VincentHanquez)
01:10:26 * hackagebot x509-validation 1.4.3 - X.509 Certificate and CRL validation  http://hackage.haskell.org/package/x509-validation-1.4.3 (VincentHanquez)
01:10:28 * hackagebot x509-util 1.4.1 - Utility for X509 certificate and chain  http://hackage.haskell.org/package/x509-util-1.4.1 (VincentHanquez)
01:10:28 <dmwit> Dacto: You asked how to flip two arguments to a function. I told you how. What more could you want? =)
01:11:16 <adnap> dmwit: Oh, sorry. I misinterpreted your Morpheus statement
01:11:26 <adnap> dmwit: I think I understand now anyhow
01:11:27 <Dacto> I guess I'm not sure how that flips them
01:11:41 <johnw> adnap: "You think those are types that you're instantiating?"
01:11:47 <adnap> I'm still a bit confused about what the signature of i should look like
01:11:48 <elliott> Dacto: x y z w is not x y w z
01:11:56 <Dacto> yeah i know
01:12:03 <dmwit> Dacto: How can I help explain how it works?
01:12:11 <adnap> "i :: forall t. Typeable t => Interpreter (T t)"?
01:12:31 <dmwit> adnap: right
01:12:39 <adnap> Why do I need the forall t?
01:12:57 <dmwit> adnap: So that when you write (as :: t), that t is the same as the one in the type signature of i.
01:12:58 <adnap> I understand I need ScopedTypeVariables to make the t in as refer to the one in the signature
01:13:15 <adnap> dmwit: I thought that's what ScopedTypeVariables does
01:13:19 <dmwit> ah
01:13:24 <dmwit> Yes, okay, that's just the rule.
01:13:29 <elliott> you have to use forall to get the scoping
01:13:30 <elliott> for back compat
01:13:32 <dmwit> Variables are only put in scope when there's a forall.
01:13:37 <adnap> Oh
01:14:02 <adnap> Well, I'm getting another weird error now. One sec
01:14:23 <dmwit> I think it's not even for backwards compatibility. It would just be weird if you turned on STV for a module so you could fix one function, and suddenly all your other functions subtly broke.
01:14:47 <shachaf> dmwit: I think that's exactly what "backwards compatibility" means.
01:14:57 <dmwit> I don't think that's what it means at all.
01:15:11 <dmwit> "backwards compatibility" would mean an old version of GHC did it that way so new versions have to do it that way, too.
01:15:31 <shachaf> It is backwards-compatible with a previous version of the language, namely Haskell98 (without ScopedTypeVariables).
01:16:13 <dmwit> Okay. I buy it.
01:16:30 <elliott> for how much?
01:16:31 <adnap> See the annotation: http://hpaste.org/88869
01:17:21 <dmwit> adnap: Do you understand this error?
01:17:36 <adnap> No
01:17:43 <mgsloan> That'll cost you 5 milliolegs
01:17:43 <dmwit> i is polymorphic, and its behavior may depend on exactly which monomorphic type you pick to instantiate it at.
01:17:51 <dmwit> (It turns out it doesn't, but the compiler doesn't know that.)
01:18:02 <dmwit> So when you call i, you have to pick a monomorphic type.
01:18:08 <adnap> Nooo
01:18:25 <dmwit> The way you used your call to i didn't give enough information to narrow down the choices.
01:19:05 <adnap> so, something like "runInterpreter (i :: Interpreter (T String)"?
01:19:31 <adnap> )
01:19:37 <adnap> That did it
01:19:58 <adnap> I guess I prefer
01:20:06 <adnap> (i :: Interpreter (T ())
01:20:08 <adnap> )
01:20:18 <dmwit> Or, for example
01:20:27 <yitz> aleator: i'm not very familiar with scala. oo is definitely at least part of its type system.
01:20:31 <dmwit> case r of { ...; Right (T x :: T ()) -> ... }
01:20:56 <dmwit> should also fix the type that i was called at.
01:21:28 <yitz> aleator: whereas in haskell, if someone talks about a "more general" type, they usually mean "more polymorphic", which is something altogether different
01:22:37 <adnap> I think someone said in here before that it is impossible to interpret a true polymorphic type
01:23:12 <adnap> Is that true?
01:23:23 <yitz> adnap: i enter them at the ghci prompt, and ghci is an interpreter ;)
01:23:36 <dmwit> What does "true polymorphic type" mean?
01:23:45 <yitz> what does "interpret" mean?
01:23:52 <adnap> interpret from hint
01:23:55 <dmwit> By some definitions, you can't even pass around a true polymorphic type.
01:23:59 <yitz> give a denotational semantics?
01:23:59 <adnap> and true as in not phantom
01:24:02 <dmwit> (...without extensions)
01:50:29 <adnap> I am looking through my logs for this channel and it is funny how often the word "tricky" is used
01:50:34 <ryantanjunming> https://gist.github.com/anonymous/910f233136a2a8e9a7b3
01:51:02 <ryantanjunming> Hi, with the above link, how do i derive min?
01:51:07 <ryantanjunming> its adga btw..
01:51:21 <ryantanjunming> haskel like adga..
01:53:40 <Watabou> quick question. If a type signature has (a -> b)  where that represents a function as an input, can the type of a be the same as b?
01:54:24 <Watabou> I'm guessing yes because I can use map Data.Char.toUpper
01:54:24 <ryantanjunming> depends, in haskell a is sometimes a non-defined type
01:54:43 <ryantanjunming> but if they have a -> b, it usually is not the same type
01:55:03 <Watabou> yeah
01:56:05 <adnap> So, I found what Cale said
01:56:39 <typoclass> Watabou: hello, yes. a and b can refer to the same type. you have a good example there with 'map toUpper'. however, the 'map' function can't know or detect that the two types are the same
01:56:40 <typoclass> @type map
01:56:42 <lambdabot> (a -> b) -> [a] -> [b]
01:57:57 <Watabou> typoclass: cool, thanks
01:57:59 <adnap> 2:31 < Cale> You can't because it's polymorphic, and you can't have an instance of Typeable at a polytype.
01:59:08 <merijn> Any cabal hackers around?
02:03:03 <bitonic> merijn: dcoutts_ is the man
02:06:08 <merijn> bitonic: I know, but unfortunately I can't really mandate he stop having a live and help me and I haven't seen him around yet :p
02:15:37 <mattt_> I'm new to haskell. In simple terms, what I've understood is, "unit"/"return" wraps a value in a container, what function is used to "unwrap" it and just get the inner value?
02:15:51 <Botje> that's container-specific.
02:16:01 <elliott> what you heard is wrong, unfortunately.
02:16:07 <Botje> and, indeed, some containers don't allow it at all.
02:16:16 <mattt_> oh..
02:16:22 <elliott> (and also it's not about containers at all really...)
02:16:34 <elliott> do you have an immediate use for this, or is it just a question out of curiosity?
02:17:03 <elliott> if the latter, it's probably the wrong time to be worrying about it (a good haskell tutorial will cover the relevant subjects in due time) and going in further depth now would probably just confuse mroe than anything
02:18:29 <typoclass> mattt_: if you have any code that needs to be fixed or that you want explained, feel free to put it on hpaste.org
02:20:16 <mattt_> Thanks everyone, I'll hop in later after I've read a bit more!
02:20:33 <ryantanjunming> any agda aficionados here?
02:21:55 <Eduard_Munteanu> ryantanjunming: sure... and not only here, but in #agda too! :)
02:42:33 <meditans> hi, anyone could point me towards a guide on installing the linux platform on windows using cygwin?
02:43:01 <FreeFull> I'll have to do my own websockets, because all websocket libraries for haskell are for server-side stuff and the one that does client-side too is out of date on that part
02:43:28 <meditans> i'm forced to use windows, and when I try install some library, eg hmatrix, from the windows haskell platform, it complains saying that I should have cygwin
02:43:35 <valdyn> meditans: thats not linux, go to www.cygwin.com and follow instructions
02:44:00 <silver> meditans, just download installer, it's really simple from there
02:44:20 <silver> you can check needed apps/libraries cygwin installer will download them
02:44:46 <meditans> i already installed it... what should I do now to have the haskell platform? there isn't any cabal or ghc in the setup.exe package list
02:45:17 <silver> you need standard windows haskell platform
02:45:29 * hackagebot metadata 0.1.3.0 - metadata library for semantic web  http://hackage.haskell.org/package/metadata-0.1.3.0 (KatsutoshiItoh)
02:45:33 <meditans> ok, i installed that too... so how do I link them?
02:45:43 <silver> it's done
02:45:52 <silver> run cabal from cygwin shell
02:46:22 <typoclass> meditans: merijn was using windows+cygwin and was wrestling with getting haskell libraries for linux installed on that. not sure if he managed in the end, or wrote about it ...
02:46:26 <typoclass> merijn: ^^ ?
02:46:41 <meditans> ah.. it's so simple? Wait a minute, i'm tryng
02:47:48 <meditans> indeed, it was.. so, sorry for the stupid question :)
02:48:38 <meditans> so, if I run cabal install from cygwin and from normal windows shell, are they installing in the same place? (just out of curiosity)
02:48:44 <merijn> typoclass: No, because I had to rebuild GHC from source to link with the gcc from cygwin instead of mingw that ships with GHC/Platform
02:48:55 <merijn> typoclass: So I gave up
02:49:06 <typoclass> merijn: ah, right. i didn't remember clearly
03:00:03 <bartavelle> is there a general CS channel where smart people answer all kind of questions ? (such as:  does http://arxiv.org/abs/1305.5976 announces the end of the world ?)
03:01:38 <typoclass> bartavelle: "Keywords: Computational complexity, Hamilton Circuit Problem, P=NP, End of world"
03:01:58 <bartavelle> :)
03:04:22 <merijn> C code that calls haskell has to call hs_exit() when done, but if control flow never returns to C land, is that still necessary?
03:04:40 <merijn> bartavelle: Research level questions?
03:04:57 <elliott> haha, great references on that paper
03:05:07 <elliott> "me, me, me and also me"
03:05:17 <merijn> THere's: http://cstheory.stackexchange.com/
03:05:40 <bartavelle> merijn, thanks I suppose it's already been discussed thne
03:05:42 <merijn> Which is stackoverflow, but research level theoretical CS questions only
03:05:46 <lesshaste> bartavelle, no.. you need cstheory.stackexchange.com for that
03:05:47 <elliott> I don't think "is the 1000th P=NP paper also written by a quack?" is on-topic for cstheory SE
03:05:53 <lesshaste> bartavelle, or even math.stackexchange.com
03:05:53 <elliott> but I may be wrong
03:06:03 <merijn> elliott: oh, it depends :p
03:06:07 <merijn> I didn't check the link
03:06:09 <bartavelle> elliott : really this happens often ?
03:06:14 <merijn> bartavelle: Yes
03:06:27 <typoclass> elliott: nailing down exactly why it's quackery might be on topic. not sure
03:06:41 <lesshaste> well... not often as a percentage of the population of the earth :)
03:06:46 <elliott> bartavelle: of course cranks publish papers all the time, and of course they usually deal with something an amateur will find exciting (because the authors are amateurs). like P=NP, or grand unified theory of everything, ...
03:06:47 <bartavelle> lesshaste :)
03:06:49 <lesshaste> but there a lot of people with access to a computer
03:07:05 <elliott> or Riemann hypothesis, or Goldbach conjecture
03:07:23 <merijn> bartavelle: See blogposts like: https://rjlipton.wordpress.com/2010/08/15/the-p%E2%89%A0np-proof-is-one-week-old/
03:07:25 <lesshaste> some of the cranks may not be cranks
03:07:31 <lesshaste> just people who don't know the subject well
03:07:33 <lesshaste> to be fair
03:07:44 <bartavelle> I figured that that kind of people work in a university where someone would give them a good smack on the head before they publish nonsense
03:07:58 <merijn> Also, Terence Tao and Aaron something?
03:07:59 <lesshaste> bartavelle, sadly universities aren't like that always
03:08:06 <merijn> They frequently discuss things like that
03:08:09 <bartavelle> OTOH P=NP would be easy to "verify", just do your computation with increasing N and check if it takes polynomial time ...
03:08:11 <elliott> bartavelle: see http://www.win.tue.nl/~gwoegi/P-versus-NP.htm for a lot of proofs that P equals and does not equal NP
03:08:18 <lesshaste> plenty of university people publish nonsense too :)
03:08:22 <merijn> bartavelle: 1) There's no peer review for publishing on arXiv
03:09:02 <merijn> bartavelle: 2) Chinese name, lots of Chinese institutions are...not as rigorous about quality of results, originality and peer review...
03:09:37 <bartavelle> thanks for the pointers then
03:09:45 <bartavelle> I'll be less scared next time
03:10:31 <lesshaste> merijn, I am not sure that is scientifically verifiable as a statement
03:10:38 <elliott> another tip in closing: if a mathematics/CS paper seems to be typeset in Microsoft Word, you can probably ignore it.
03:10:40 <lesshaste> merijn, there are plenty on non-chinese cranks and a large percentage of all people are chinese
03:10:47 <lesshaste> elliott, true! :)
03:10:56 <elliott> and this one does look like it is.
03:11:14 <merijn> bartavelle: Simply put, last year (or 2 years ago now), a very famous mathematician/theoretical phycist published "I might have found an interesting way of attacking P=NP, possibly solving it" and the overwhelming assumption of everyone in CS/math was "it's going to be wrong, but being how this is a smart guy he might have discovered a few novel tools in the paper" (which was also the mindset of the guy publishing) and it was indeed wrong
03:11:19 <lesshaste> of course they should all include computer verifiable proofs :)
03:11:28 <typoclass> merijn: well, the west has its share of universities which (let's say) prioritize prestige over all else
03:11:36 <lesshaste> typoclass, yes!
03:11:44 <merijn> bartavelle: The odds of someone unknown finding a solution is...almost zero
03:11:56 <merijn> typoclass: Sure, many UK places aren't great either
03:11:58 <lesshaste> merijn, that's not true.. see only last week
03:12:14 <merijn> lesshaste: "see only last week" what?
03:12:15 <lesshaste> merijn, the advances on the twin primes conjecture
03:12:22 <merijn> So?
03:12:25 <lesshaste> he wasn't known
03:12:31 <merijn> 1 counter point doesn't refute "almost zero"
03:12:39 <lesshaste> merijn, that is true!
03:12:44 <merijn> It just proves that "almost zero" = "non-zero"
03:12:46 <lesshaste> I should have asked how close to zero :)
03:13:11 <lesshaste> it's like if you find money in the street
03:13:15 <merijn> If there's one proof from an unknown person for every 1000 from known people, that only solidifies my claim
03:13:22 <lesshaste> the chances of someone else having picked it up before you is very high
03:13:30 <lesshaste> but it doesn't mean you should ignore it :)
03:13:56 <lesshaste> merijn, not really.. I thought you were implying one shouldn't bother reading proofs of major claims by unknown people carefully
03:14:19 <merijn> In the case of P=NP I would claim that, to be honest
03:14:33 <merijn> It's like the 5 billion crackpot "universal compression algorithms"
03:14:38 <lesshaste> merijn, I think you are most likely right.. but mostly because we feel we are a million miles from proving it
03:14:51 <lesshaste> merijn, well "universal compression algorithms" is easier to ignore
03:14:57 <lesshaste> merijn, as we *know* it is false
03:15:05 <lesshaste> merijn, we don't know how hard it is to prove P=NP
03:15:10 <lesshaste> or not :)
03:15:15 <elliott> (perhaps take this to #haskell-blah now?)
03:15:20 <merijn> Yes
03:15:25 <merijn> Back to haskell!
03:15:40 <merijn> How important is it for C code to call hs_exit() to terminate the RTS?
03:15:47 <lesshaste> well.. clearly the proofs should include computer verifiable proofs written in haskell!
03:15:48 <merijn> Will the GHC RTS leak anything if you skip it?
03:16:41 <Zeev> merjin: heh even if now not you don't know when future version might
03:17:03 <merijn> (Is it even necessary to call that if your process just terminates/terminates on the haskell side)
03:17:11 <Zeev> merijn: but u know I'm not a haskell pro so sorry for out of line commt
03:17:16 <bartavelle> merijn: will you call some other haskell function after that ?
03:17:36 <bartavelle> merijn: if it terminates on the haskell side, why worry about leaks ?
03:17:51 * gds tries to decide which of the many command line option parsers to use http://www.haskell.org/haskellwiki/Command_line_option_parsers
03:17:56 <merijn> bartavelle: I mean does it leak fd's/mutexes/whatever?
03:18:07 <merijn> i.e. things that don't get cleaned up :p
03:18:09 <bartavelle> when a process terminates, those are closed
03:18:30 <merijn> Shared mutexes are not, but I guess those aren't used
03:18:32 <bartavelle> or else you would have tons of stale fd's from segfaulting programs
03:19:05 <bartavelle> good point
03:19:18 <meditans> http://hpaste.org/88887 (note the number)
03:19:18 <Ralith> gds: when in doubt, use whatever's in the haskell platform
03:19:26 <bartavelle> anyway, if you can't do it, why worry about it ?
03:19:39 <merijn> bartavelle: I could do it, but it'd be very ugly :p
03:19:43 <meditans> hmatrix w/ cygwin problem
03:19:45 <bartavelle> heh
03:19:52 <gds> Ralith: does that mean getOpt in this case?
03:19:54 <merijn> Or I'd have to "JIT initialise" the runtime
03:21:44 <Ralith> gds: I have no idea, I'm just recommending a heuristic
03:22:19 <supki> I don't think platform includes command line options parser?
03:22:38 <elliott> probably it contains the standard getopt one?
03:22:41 <elliott> i think that's even in base
03:22:44 <supki> If only there was a list of packages which platform includes
03:23:00 <gds> Ralith: Cool - thanks!
03:23:30 <supki> elliott: no one would recommend that one in base :P
03:24:03 <gds> Yeah, I started writing using getOpt, but thought it was a bit of a pain, so went to see if it was a Solved Problem.
03:24:10 <gds> It seems to be a Multiply Solved Problem.
03:35:57 <jdnavarro> is there any numeric literal to write integers in binary base?
03:36:18 <meditans> pardon me if I repeat the question, but anyone has a clue on what to do here? http://hpaste.org/88887
03:37:09 <supki> meditans: what does ghc-pkg check say?
03:38:24 <supki> meditans: also  ghc-pkg list directory  and  ghc-pkg list process
03:40:24 <typoclass> jdnavarro: not that i know of, but 0x123 (hex) and 0o755 (octal) are available. if you have a 12-digit binary number, you can take groups of four binary digits and convert each one into one hex digit. similar for octal (3 binary digits). it's quite straightforward
03:40:54 <Jaxan> is there any function/syntactic sugar to transform f (g x) (h y) into something like f # g x # h x ?
03:41:01 <Jaxan> like a left-assoc $ ?
03:41:50 <merijn> @tell dcoutts Cabal is complaining that I can't have a Main-Is file ending in .c, but afaict from the github repo there was a patch to allow this 6 months ago (including test case), so I'm not sure why my cabal from the latest Platform doesn't accept it?
03:41:51 <lambdabot> Consider it noted.
03:42:36 <meditans> supki: ghc-pkg check http://hpaste.org/88888
03:42:39 <typoclass> jdnavarro: also, you could use the general readInt function and write your number inside a String
03:42:43 <typoclass> > readInt 2 (`elem` "01") (read . (:[])) "1101101"
03:42:44 <lambdabot>   [(109,"")]
03:43:50 <jdnavarro> typoclass, the readInt trick will do for me, thanks!
03:44:07 <meditans> supki: ghc-pkg list http://hpaste.org/88889
03:44:54 <Hafydd> Would GHC expand such an expression into the equivalent of a single numeric literal?
03:45:18 <Hafydd> (If used with fst.head)
03:45:51 <meditans> supki: ghc-pkg list process & directory http://hpaste.org/88890
03:47:14 <byorgey> Jaxan: not in the standard libraries, no
03:47:16 <typoclass> Hafydd: you mean, will ghc evaluate that expression at compile time, writing the number 109 literally into the executable file? i don't think it will
03:47:21 <supki> meditans: okay, that looks like a problem. You should not reinstall packages that come with ghc (like directory and process)
03:47:33 <supki> meditans: full list is at http://www.haskell.org/ghc/docs/7.4.2/html/libraries/index.html
03:47:33 <Jaxan> byorgey: thanks, I'll make my own
03:47:57 <Hafydd> typoclass: which is a pity, because Haskell's purity quite uniquely facilitates that.
03:48:16 <elliott> Jaxan: some people want ($) to be infixl so you can do that
03:48:26 <Hafydd> But I suppose you have to stop expanding somewhere.
03:49:30 <supki> meditans: does it complain if you try to  ghc-pkg unregister process-1.1.0.2  and  ghc-pkg unregister directory-1.2.0.1
03:49:35 <supki> ?
03:50:15 <adnap> I often write stuff like "x . y . z $ w". Sometimes I can omit the w if I don't have to use it somewhere else in the function. It looks kind of ugly
03:50:38 <meditans> supki:  unregistering process-1.1.0.2 would break the following packages: Cabal-1.16.0.3
03:51:04 <meditans> supki: also, cache is out of date:......   use 'ghc-pkg recache' to fix.
03:51:28 <Kinnison> Jaxan: btw, there is & in the lens package which is left-assoc $
03:51:36 <Kinnison> @ty (&)
03:51:37 <lambdabot> a -> (a -> b) -> b
03:51:49 <Kinnison> Jaxan: dunno if that might be nicer for you
03:52:01 <Kinnison> and I didn't mean left-assoc I meant flipped
03:52:27 <meditans> supki: but if I try recache it says I haven't permissions... how do I obtain permissions in cygwin?
03:53:11 <supki> meditans: I am not familiar with cygwin :[
03:53:50 <typoclass> Hafydd: hm yes, i guess it's a good question. why doesn't ghc do partial evaluation, at least in the easy cases. there seem to be a few mailing list threads and blog posts; i'm looking at them now ...
03:54:38 <supki> meditans: anyway, the way to fix your problem is to unregister everything you reinstalled from that list of ghc-bundled packages and reinstall anything that breaks then
03:55:16 <meditans> supki: I'm going to unistall haskell platform, and reinstall it from scratch
03:55:31 <meditans> supki: just to be sure
03:58:08 <supki> meditans: problematic packages are in your user directory though
03:58:26 <supki> meditans: by the way you should probably install newest HP then
03:58:28 <merijn> Hafydd: I remember reading a blogpost where compiling with LLVM would do constant folding
03:59:10 <meditans> supki: could you write me how could I cancell all packages, so that I could restart?
03:59:55 * typoclass . o O ( i'm probably missing something, but it seems so obvious. "lots of functions in haskell are pure. why not evaluate all of them at compile time. kthxbai" )
04:00:24 <elliott> GHC does do constant folding.
04:00:31 <elliott> and more generally, inlining
04:00:40 <typoclass> ... i mean, in contrast to a language where any function can have any kind of side effect
04:00:49 <mauke> supercompilation
04:01:09 <merijn> elliott: Yeah, but I remember seeing some analysis of GHC assembly and GHC-via-LLVM assembly and llvm had folded *even more* away
04:02:16 <Hafydd> Hmm.
04:03:04 <supki> meditans: not sure how to do that on windows, sorry
04:03:43 <elliott> typoclass: haskell functions can have side-effects perfectly bad enough to prevent this strategy: nontermination
04:03:52 <meditans> supki: thank you very much, neverthless :)
04:03:53 <elliott> plain console IO or whatever is no worse for the compiler, in fact better: easy to detect
04:03:55 <typoclass> elliott: that's true!
04:10:40 <merijn> How do I convert CChar to Char? Or will it Just Work (TM) if I work with "Ptr Char" instead of "Ptr CChar"?
04:12:00 <bitonic> merijn: <http://hackage.haskell.org/packages/archive/bytestring/0.10.2.0/doc/html/Data-ByteString-Unsafe.html#g:2> is an option
04:12:28 <bitonic> merijn: <http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Foreign-C-String.html> is another option
04:12:57 <bitonic> but working with ByteString is better, since CChar really is a byte
04:13:10 <merijn> oh!
04:13:30 <merijn> I was trying to be difficult using Foreign.Marshal.Array :p
04:14:04 <merijn> bitonic: Not really, as all haskell functions on files expect FilePath = [Char]
04:14:17 <bitonic> merijn: ?
04:14:40 <bitonic> merijn: <http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/Foreign-C-Types.html#t:CChar>
04:15:26 <merijn> bitonic: My point is that ByteString doesn't really help, as openFile and friends expect a String, so I'd need to decode the ByteString before being able to use it
04:15:44 <merijn> And unix filesystems don't specify an encoding, so sanely decoding said ByteString isn't possible
04:16:12 <bitonic> merijn: right if you are relying on the locale then you should probably use Foreign.C.String
04:16:15 <merijn> i.e. I might as well go straight from "Ptr CChar" to "String" and say "sucks for you if you break things"
04:16:17 <bitonic> but I din’t know what you wanted to do
04:16:44 <bitonic> in the general case, the Haskell structure that is more close to ‘char *’ in C is ByteString
04:17:02 <bitonic> so in the general case is better to get the bytes and then work with them in Haskell
04:17:28 <bitonic> if you are relying on the locale to interpret the ‘char *’ then Foreign.C.String is useful
04:17:33 <merijn> Of course, but for manipulating filepaths it's a bit moot as the situation is doomed anyway :)
04:17:52 <bitonic> again, I didn’t know you were manipulating filepaths, so I offered a generic advice :P
04:19:07 <merijn> I keep being pleasantly surprised by how convenient and easy the FFI is :)
04:19:43 <bitonic> it’s not too bad yeah
04:25:47 <merijn> There's no type for const pointers, is there?
04:27:00 <bitonic> merijn: all pointers are constant in Haskell :P
04:27:24 <bitonic> it’s not something that carries over from C’s types system to Haskell’s
04:27:41 <merijn> I know, but the FFI types generated by Ptr CChar are "char *" so if I pass "const char *" to it the C compiler complains :p
04:28:23 <merijn> I can just cast it before calling haskell, but I was wondering if there was a nicer way
04:28:28 <merijn> Also
04:28:47 <merijn> "Hey guys, look at the start of my new haskell project! 128 lines of C, 25 lines of haskell!" >.>
04:29:29 <bitonic> merijn: I don’t think there is a way to tell Haskell to generate ‘const char *’ stubs, no
04:30:03 <merijn> Oh well
04:35:50 <typoclass> merijn: not sure if this is relevant, but this talks about #const_str (const char pointers) http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/hsc2hs.html
04:37:42 <merijn> typoclass: That's for generating haskell wrappers from C code, whereas I wanted to know if there was a type on the haskell side
04:37:57 <merijn> But I'm mostly happy with the code I have now, so :)
04:38:13 <typoclass> merijn: alright
04:38:30 <merijn> Now I just need to fix my cabal issue and then I can back to haskelling :p
04:38:59 <merijn> Actually, even that's relatively low priority, as I can compile by hand for now :p
04:39:18 <zRecursive> anybody uses dmenu here ? How can i make it support UTF-8 ?
04:40:56 <elliott> hm, is dmenu written in haskell?
04:41:12 <merijn> C, isn't it?
04:41:28 <merijn> Yeah, C it's from the suckless guys
04:53:47 <fosskers> evenin' gents
05:05:07 <fosskers> I got function definition working in my accidental lisp implementation
05:05:34 <mauke> .oO( I accidentally a lisp )
05:05:37 <fosskers> recursion works, but there aren't any control structures yet so you can't stop it
05:05:50 <mauke> do you support lambda?
05:06:09 <fosskers> i'm quite close to getting higher order functions working
05:06:20 <fosskers> once i do, lambdas should be a breeze
05:07:55 <fosskers> parsec is a gift, i swear
05:09:06 <mauke> that's german for "poison"
05:09:25 <fosskers> parsec?
05:09:29 <mauke> gift
05:09:39 <fosskers> das gift!
05:09:56 <fosskers> ich habe gegessen das gift!
05:09:57 <mekeor> well, and poisson is fish in french, isn't it?
05:10:33 <mauke> *ich habe das gift gegessen
05:10:34 <bartavelle> yes, but poison is poison
05:10:41 <fosskers> ah right, verbs at the end
05:10:59 <mauke> no, verbs in 2nd position
05:11:03 <mauke> (habe)
05:11:05 <mekeor> not really.. "ich aß das gift"...
05:11:27 <fosskers> well there are multiple verbs there, like english
05:11:36 <fosskers> habe and gegessen, no?
05:11:45 <bartavelle> the verb is essen
05:11:45 <mauke> yeah, "habe" is an auxiliary verb
05:11:48 <fosskers> right
05:11:54 <mauke> it does all the work
05:11:55 <fosskers> that's the work i was looking for, auxilliary
05:12:02 <fosskers> *word
05:12:02 <mauke> "gegessen" is static
05:12:38 <fosskers> geg = past tense in some way, yeah?
05:12:45 <sampilix> How would you write a program that adds up all numbers from N for X length. So if N is 20 and X is 5 > 20 + 21 + 22 + 23 + 24
05:13:23 <Botje> sampilix: decompose the problem into "all numbers from N" and "take X numbers from a list"
05:13:25 <bartavelle> sampilix, sum [n..(n+x-1)]
05:13:54 <typoclass> sampilix: i suggest you start by looking at the 'sum' function which will sum up a list, and then look at constructing the list that you need
05:14:01 <merijn> > (\n x -> sum [n..(n+x-1)]) 20 5
05:14:03 <lambdabot>   110
05:14:04 <typoclass> > sum [1,2,3] -- sampilix, example for sum
05:14:05 <lambdabot>   6
05:14:25 <merijn> > (\n x -> sum [n..n+x-1]) 20 5 --pffft, who needs parens
05:14:27 <lambdabot>   110
05:15:55 <mauke> > do { \n x -> sum [n .. n + x - 1] } 20 5
05:15:56 <lambdabot>   <hint>:1:37: parse error on input `20'
05:16:43 <mauke> > do { \n x -> sum [n .. n + x - 1] } `id` 20 $ 5
05:16:44 <lambdabot>   110
05:16:46 <mauke> who needs parens
05:17:26 <merijn> > let f n x -> sum [n..n+x-1] in f 20 5 -- would've been simpler...
05:17:27 <lambdabot>   <hint>:1:11: parse error on input `->'
05:17:31 <merijn> oh, duh
05:17:35 <merijn> > let f n x = sum [n..n+x-1] in f 20 5 -- would've been simpler...
05:17:36 <lambdabot>   110
05:17:41 <mauke> > 55 * 2
05:17:43 <lambdabot>   110
05:17:52 <merijn> > 110 -- now what?
05:17:54 <lambdabot>   110
05:18:35 <sampilix> lol
05:18:43 <mekeor> llo
05:19:02 <typoclass> sampilix: anyway. i suggest you use the 'sum' function, the 'take' function, and the "[n..]" syntax. ([n..] gives you an infinite list starting at n)
05:20:56 <mauke> > let pt n = n * (n + 1) `div` 2; gw f t = pt t - pt f; dm n x = gw (n - 1) (n + x - 1) in dm 20 5
05:20:57 <lambdabot>   110
05:22:00 <mauke> > let pt n = n * (n + 1) `div` 2; gw f t = pt t - pt f; dm (pred -> n) x = ap gw (+ x) n in dm 20 5
05:22:02 <lambdabot>   110
05:23:28 <mauke> > let pt n = n * (n + 1) `div` 2; dm (pred -> n) x = ap (subtract `on` pt) (+ x) n in dm 20 5
05:23:29 <lambdabot>   110
05:23:53 <mekeor> @type (sum .) . fromThenTo
05:23:54 <lambdabot> Not in scope: `fromThenTo'
05:24:08 <mauke> :t enumFromThenTo
05:24:09 <lambdabot> Enum a => a -> a -> a -> [a]
05:24:14 <mekeor> @type (sum .) . enumFromTo
05:24:16 <lambdabot> (Enum c, Num c) => c -> c -> c
05:25:30 <sampilix> Can someone convince me why I should learn Haskell? what are the pro's?
05:25:40 <merijn> @google why functional programming
05:25:41 <lambdabot> http://stackoverflow.com/questions/36504/why-functional-languages
05:25:41 <lambdabot> Title: Why functional languages? - Stack Overflow
05:26:21 <merijn> sampilix: If you don't buy the academics, listen to the guys from industry
05:26:24 <merijn> @google tim sweeney "next mainstream programming language"
05:26:27 <lambdabot> http://lambda-the-ultimate.org/node/1277
05:26:27 <lambdabot> Title: The Next Mainstream Programming Languages | Lambda the Ultimate
05:26:38 <mauke> sampilix: you shouldn't learn haskell
05:26:49 <mekeor> @wiki Why Haskell matters
05:26:49 <lambdabot> http://www.haskell.org/haskellwiki/Why_Haskell_matters
05:26:57 <merijn> and also
05:27:01 <merijn> @google john carmack functional programming
05:27:02 <lambdabot> http://www.altdevblogaday.com/2012/04/26/functional-programming-in-c/
05:27:02 <lambdabot> Title: #AltDevBlogADay » Functional Programming in C++
05:27:07 <tdammers> > (\n x -> (n `div` 2) * (2 * (x-1) + n + 1) + if even n then 0 else x + n `div` 2) 5 20
05:27:08 <lambdabot>   110
05:27:09 <sampilix> Give me a good example of where that language would be used in a modern day situation over another language.
05:27:11 <merijn> I should add these to the wiki if they're not there yet
05:27:32 <mauke> sampilix: no
05:27:44 <sampilix> Is Haskell a compiled language or an interpreted language like Python?
05:27:49 <mauke> sampilix: no
05:27:50 <sampilix> mauke: Why not?
05:27:52 <typoclass> sampilix: the haskell compiler is very helpful. it'll point out all the things that my code is doing wrong, or might be doing wrong. the upshot is that it's hard to get something to compile, but once it does, there's not much debugging left to do
05:27:56 <fosskers> sampilix: If C is banging on an old car in your garage, Haskell is a rocket ship.
05:28:17 <tdammers> a language isn't "compiled" or "interpreted". There are C interpreters and Python compilers.
05:28:41 <mauke> sampilix: give me $100
05:28:46 <typoclass> sampilix: it is normally compiled via the compiler ghc. there is an interactive tool (ghci) which you can use to evaluate short pieces of code, similarly to lambdabot
05:28:54 <typoclass> > 42*2
05:28:55 <lambdabot>   84
05:28:59 <merijn> Hey, so I had a thought (related to this conversation and some earier ones about the channel quality)
05:29:15 <Saizan> sampilix: there are many implementations of haskell, the most used is GHC which compiles but also has an interpreter for developement
05:29:19 <merijn> Why don't we start #haskell-marketing and redirect all questions/conversations like this there?
05:29:27 <merijn> (or #haskell-sales, whatever)
05:29:27 <typoclass> tdammers: well, the question was obviously referring to the common case
05:29:48 <eikke> merijn: or have a FAQ and refer people to it?
05:29:50 <mauke> typoclass: the common case is neither
05:29:51 <tdammers> I was about to say something about that, but then I figured I'm way too lazy
05:30:08 <merijn> I get that people like convincing people to use Haskell, but I do agree that these conversations in here become tiresome, repetitive and boring
05:30:12 <fruitFly> I have a function. Is there any way to invert it, I.e. give it output and it it tells me what input would give that output? What am I thinking lol.... that would probably be soooo inefficient. Anway ...
05:30:16 <typoclass> merijn: possibly yes. or a wiki page
05:30:22 <fruitFly> Anyway*
05:30:31 <tdammers> fruitFly: it's also unsolvable, because not all functions are reversible
05:30:37 <mekeor> merijn: i don't think there are so many question of this type that it makes sense to create a new channel, but idk :)
05:30:38 <mauke> fruitFly: prolog?
05:30:39 <sampilix> Yet you still haven't given me a valid scenario of where it would be used in modern day over another language.
05:30:46 <tdammers> let f x = 1
05:30:54 <mauke> sampilix: stop that
05:30:55 <merijn> mekeor, eikke, typoclass: There are wikipages and tons of articles like this already. The people asking these questions are to lazy to read them and people in here indulge there laziness
05:31:08 <sampilix> mauke: Why?
05:31:15 <mekeor> merijn: true
05:31:16 --- mode: ChanServ set +o mauke
05:31:16 --- mode: mauke set +q $a:perdent
05:31:26 <tdammers> there is no f' that satisfies f' (f x) = x
05:31:28 <merijn> sampilix: See my remark just know that there are already 500 articles + wiki pages telling you all these things
05:31:28 <DigitalKiwi> well haskell is a lazy language~
05:31:43 <fruitFly> Can haskell modify its own source code while executing?
05:31:57 <merijn> I just linked you 3 very famous ones. Demanding people here convince you is rude
05:32:01 <mauke> fruitFly: I don't think that question makes sense
05:32:02 <tdammers> @faq Can haskell modify its own source code while executing?
05:32:02 <lambdabot> The answer is: Yes! Haskell can do that.
05:32:03 <mekeor> @faq Can haskell modify its own source code while executing?
05:32:03 <lambdabot> The answer is: Yes! Haskell can do that.
05:32:06 <mekeor> AH!
05:32:23 <tdammers> it can't, though... not really, in any case
05:32:26 <merijn> fruitFly: Yes, No, Maybe, depending on what you're asking or what you want
05:32:30 <mekeor> :D
05:32:32 <DigitalKiwi> mauke: he's probably coming from lisp
05:32:38 <merijn> fruitFly: Take a look at mueval?
05:32:41 <augur> people talk about lisp as modifying its own source code but was this ever actually true?
05:32:42 <elliott> merijn: you forgot "I don't know" and "can you repeat the question".
05:32:47 <mauke> DigitalKiwi: that question makes no sense in lisp either
05:32:48 <merijn> augur: Yes, it still is
05:32:51 <augur> smalltalk certainly modified itself, but did lisp?
05:32:57 <tdammers> that's more like a haskell program that can interpret haskell code
05:33:01 <DigitalKiwi> lisp people talk about that stuff all the time
05:33:05 <tdammers> mueval doesn't modify itself as it runs, does it?
05:33:09 <mauke> DigitalKiwi: no, they don't
05:33:09 <augur> merijn: what are some examples of this??
05:33:16 --- mode: mauke set -o mauke
05:33:20 <merijn> augur: Lisp is homoiconic, i.e. source maps directly to AST and back
05:33:22 <elliott> it is better to get a clarified question than to guess at the meaning blindly.
05:33:31 <augur> merijn: that doesnt mean its modifying its own source code tho
05:33:38 <augur> that just means its easy to write "eval"
05:33:52 <merijn> augur: Well, it also means you can serialise code back to source
05:34:05 <mauke> merijn: I don't see how that follows
05:34:18 <augur> merijn: is that really feasible tho? i mean, if you quote stuff in lisp, you just get opaque junk
05:34:36 <augur> merijn: but even if that were so, that doesnt mean you've modified source, just that you've produced source
05:35:01 <merijn> augur: Like I said, it depends on exactly what you mean by "modify" and "source"
05:35:01 <fruitFly> I'm deving onan android phone. Anyone wanna donate so I can buy a cheap laptop or donate something so I can help save the world?
05:35:35 <augur> merijn: yeah. i wouldnt consider that modifying source. thats just code generation, which basically every language can do
05:35:57 <mauke> fruitFly: that doesn't look like a haskell question
05:36:07 <merijn> augur: What would "modify it's source" mean?
05:36:37 <DigitalKiwi> jit?
05:36:46 <fruitFly> Mauke ok back to work
05:37:13 <augur> merijn: somehow change the definitions of pre-existing code so that all things that make use of it are somehow affected
05:37:13 <augur> that would be modifying source
05:37:13 <augur> you've got some code running
05:37:13 <augur> you write some other code that changes how the existing code works
05:37:19 <augur> not "from now on", thats just shadowing
05:37:30 <yogurt_truck> :S
05:37:30 <merijn> You could just overwrite the old files with the new stuff
05:37:31 <augur> i guess it would be possible, since you have set! in lisp/scheme
05:37:40 <mauke> @quote augustss Quite
05:37:40 <lambdabot> augustss says: ghc had a bug once where it deleted the source file if it had a type error.  Quite sensible, I think.
05:37:45 <mauke> does that count? :-)
05:37:47 <yogurt_truck> maybe he just meant macros
05:38:03 <augur> so you could have some shady function change-fac! that changes the global fac function to be something else, and everything that refers to that fac is covertly modified
05:38:07 <elliott> yogurt_truck: it is impossible to tell. we must keep guessing and arguing.
05:38:21 <yogurt_truck> elliott: :D
05:39:00 <DigitalKiwi> sounds like what erlang lets you do
05:39:21 <augur> smalltalk does that too
05:39:38 <yogurt_truck> sounds like I should go to a coffee shop that has a better wifi
05:39:43 <yogurt_truck> latrs :)
05:43:38 <merijn> Multiple cabal projects in the same repo, yay or nay?
05:44:03 <mekeor> nay
05:44:16 <Aetherspawn> I read something about supercompilation ages ago
05:44:25 <merijn> i.e. I have some stuff I have to implement for my program, but I imagine the module might be useful for someone else in the future
05:44:37 <Aetherspawn> Apparently there was a working implementation that decreased allocations by ~50%, or something to that figure?
05:44:53 <Aetherspawn> (in regards the discussion up there a bit ^ )
05:44:55 <elliott> merijn: sure
05:45:27 <merijn> Splitting of a few lines of module code into a separate repo seems a hassle. But having it as separate cabal project would be useful for separate distribution via hackage
05:46:12 <dcoutts> merijn: yes, it makes sense to do that sometimes
05:46:12 <lambdabot> dcoutts: You have 7 new messages. '/msg lambdabot @messages' to read them.
05:46:22 <merijn> dcoutts: HA!
05:46:30 <merijn> dcoutts: I've been looking for your for like 16 hours :p
05:46:38 <Botje> run for the hills!
05:46:44 <merijn> (No, not all of those 7 messages are mine :p)
05:46:58 * dcoutts has spent most of the last 16 hours asleep
05:47:29 <merijn> dcoutts: "Error: The 'Main-Is' field must specify a '.hs' or '.lhs' file"
05:47:49 <merijn> I saw a fix for that allowing .c files in Main-Is too, which was committed including tests 6 months ago, but it's not working for me?
05:48:40 <dcoutts> merijn: yes, that'll be allowed in the next release
05:48:45 <merijn> :(
05:49:23 <merijn> Is there anyway I can patch + reinstall cabal to get it working without breaking everything?
05:49:39 <dcoutts> merijn: sure, you can use the latest version, that's no problem
05:50:09 <dcoutts> edwardk: heh just got a lambdabot message from you from 6 months ago. You were asking about weirdness with cabal update and decompression.
05:50:13 <merijn> I just pull from github and run cabal install in the cabal repo and it should Just Work (TM)?
05:51:05 <fruitFly> I'm using vim touch on my phone. What vim plugins could I use to help my dev experience, at least for better syntax highlighting etc. ?
05:51:15 <dcoutts> edwardk: what will be happening is that you must have a proxy that does transparent decompression, and then cabal recognises this and doesn't fail when it tries to decompress, so overall it works despite the silly proxy.
05:51:40 <dcoutts> merijn: Cabal and cabal-install repos, yes.
05:51:52 <merijn> So I need to reinstall both?
05:51:54 <typoclass> fruitFly: this page has some links for you http://www.haskell.org/haskellwiki/Vim
05:51:58 <merijn> Do I have to unregister them first?
05:52:05 <merijn> (is that even possible?)
05:52:14 <dcoutts> merijn: one needs to be built against the other, and no don't unregister your current version
05:52:21 <dcoutts> you'll have both, that's ok
05:52:36 * dcoutts has several
06:00:30 <kartlos> does anyone actually write programs in literate style? are there some open source examples?
06:02:21 --- mode: ChanServ set +o mauke
06:02:21 --- mode: mauke set -q $a:perdent
06:03:44 <merijn> kartlos: They're mostly used for when you want to have runnable papers/blogposts
06:03:57 <merijn> I'm not sure if anyone uses them as "normal" coding style
06:04:12 <typoclass> kartlos: twan has various blog posts that are literate, e.g. http://twanvl.nl/blog/haskell/finding-rectangles-part3 (see link near the top)
06:04:21 --- mode: mauke set -o mauke
06:04:57 <merijn> I copied the nice "add these constraints to .cabal/config" from cabal-cabal.xhtml, but that disallows multiple installed cabal versions. Is that just the person who wrote that page being overzealous?
06:04:58 <kartlos> so would you guys recommend the literate style for actual development?
06:05:28 <typoclass> kartlos: well if you want to output the program into a pdf or a blog post, then sure
06:05:28 <merijn> kartlos: Maybe if you have a module with complicated math/business logic it could be worth doing that one in literate style
06:06:07 <kartlos> ok, but you wouldn't develop an entire system in literate style?
06:06:22 <merijn> dcoutts: Actually, now that I was badgering you anyway...
06:07:13 <merijn> dcoutts: Who do I need to beg/threaten to get stuff like "cabal build" to auto-configure like install? Or where do I start hacking if I have to submit a patch for someone to consider it? :p
06:08:42 <typoclass> kartlos: i think it's not a basic philosophical choice :) you don't need to commit to one thing, and then never again do the other. it's perfectly alright to use normal style, then use literate style for a few modules where you have extra documentation needs
06:09:43 <typoclass> kartlos: minimally, you can change a .hs file to .lhs by simply putting "> " before every line. so literate haskell is not a completely fundamentally different thing
06:10:08 <kartlos> typoclass: that does make sense, although it's kind of a big hurdle to switch the style in which you write your code
06:10:19 <yitz> dcoutts: in cabal install, how do you do the opposite of --only-deps? i.e., refuse to install if any deps are missing, rather than going to get the deps
06:10:43 <merijn> yitz: "--dry-run" and make sure nothing else is listed?
06:10:56 <yitz> merijn: then it won't install anything at all
06:11:08 <merijn> Yes, but if there's dependencies missing they'll be printed
06:11:15 <yitz> oh i see. no, in script that will do that 100 or more times
06:11:34 <yitz> i guess i could scrape the output, but...
06:11:34 <merijn> You could use that + grep, but that's not very pretty :p
06:11:39 <yitz> :)
06:11:55 <bartavelle> I really would like to write "instance Num a => ToRuby a", I don't think it is risky, but I am not knownledgeable enough to decide. Anyone has a good set of reasons for deciding if it is or is not a good idea ?
06:11:59 <merijn> I'm the master of "not very pretty" grep/awk/sed scripting, so :p
06:12:34 <elliott> bartavelle: it won't work even if you add it
06:12:42 <elliott> because it will overlap with every other instance you declare of ToRuby
06:12:43 <yitz> merijn: yeah i could actually do it that way, but really, isn't there a way to do that natively in cabal?
06:12:47 <bartavelle> yeah but there certainly is some extension that would let me ?
06:12:57 <bartavelle> with every other instance ?
06:13:41 <elliott> with IncoherentInstances or something extreme like that, maybe, but it probably won't do what you want. I suggest not doing it, it breaks the open world assumption.
06:13:46 <typoclass> bartavelle: the reason is that "(Num a) =>" is not looked at when choosing instances, so as far as instance choice is concerned, you've declared an "instance ToRube a where"
06:13:50 <elliott> it's not as unrisky as you think :)
06:14:06 <bartavelle> ok then it is extremely risky
06:14:16 <bartavelle> will just define tons of instances then
06:14:30 <typoclass> bartavelle: heh, ok
06:15:38 <bartavelle> I didn't realize that  "(Num a) =>" would be ignored, I thought the only risk was when I would also define a specific instance for something that is also Num
06:15:55 <merijn> bartavelle: Abuse Generics? :p
06:16:09 <dcoutts> yitz: cabal configure will only consider packages that are already installed
06:16:14 <merijn> And then just DeriveGeneric all the stuff you want :p
06:17:18 <elliott> bartavelle: it's not that it's ignored per se
06:17:24 <elliott> it's just only considered once the instance is already picked
06:20:04 <bartavelle> hum, will look at Generics then
06:20:07 <bartavelle> later ;)
06:20:13 <merijn> dcoutts: Oh wait, 1.17 already does auto configure when I run "cabal build"!
06:20:16 <merijn> dcoutts: I love you!
06:20:29 <bartavelle> yes, that is useful !
06:20:43 <merijn> Where do I send my firstborn?
06:22:11 <osfameron> for the slaughter?
06:22:14 <osfameron> just queue here
06:23:06 <elliott> merijn: dcoutts_ heard your call.
06:23:12 <elliott> he is not bound by temporal constraints.
06:23:36 <randomclown> Is there a fairly authoritive Haskell coding style guide? (i.e. number of spaces before a where, when to line break)
06:25:51 <gienah> randomclown: here is a style guide http://snapframework.com/docs/style-guide
06:26:31 <randomclown> gienah: oh snap
06:29:01 <merijn> randomclown: In my experience haskell is more freeform than many other languages. Although I tend to follow Python's PEP8 in all languages as far as possible
06:29:47 <merijn> hmmm
06:29:52 <bitonic> I vaguely remember some code extracting a graphviz file with the module hierarchy given some cabal project/haskell code.  was I dreaming?
06:30:11 <merijn> Having multiple cabal projects in the same dir but with different licenses might be confusing >.>
06:34:00 <merijn> I guess the colliding Setup.hs files might be a problem with multiple packages in the same repo?
06:34:35 <merijn> dcoutts_: While you were at it, fixing my pet peeves, did you allow for listing multiple license files? :p
06:36:18 <geekosaur> bitonic, http://new-hackage.haskell.org/package/graphmod ?
06:36:41 <geekosaur> hm, you said graphviz
06:38:44 <bitonic> geekosaur: that will do, thanks!
06:39:04 <geekosaur> https://github.com/finnsson/hs2graphviz might be it
06:40:51 <dcoutts_> merijn: no sorry, not yet
06:41:40 <bartavelle> I suppose that "freeStablePtr" is extremely unsafe when used with arbitrary pointers ?
06:41:52 <bartavelle> it doesn't check a list of known stable pointers before doing anything, right ?
06:42:14 <merijn> bartavelle: You can't use it with arbitrary pointers, only with StablePtr's which are not guaranteed to be valid pointers at all
06:42:34 <bitonic> geekosaur: btw, got is part of graphviz
06:42:44 <bartavelle> yes but you can construct stableptr from ints (which I am doing)
06:42:59 <bartavelle> so I guess I just need to be careful
06:43:00 <geekosaur> yeh, I',m still waking up
06:43:12 <merijn> bartavelle: What do you mean construct stableptr from ints?
06:43:38 <merijn> You mean like "newStablePtr 1"?
06:44:05 <bartavelle> from intPtrToPtr
06:44:24 <bartavelle> freeStablePtr (castPtrToStablePtr (intPtrToPtr (fromIntegral i)))
06:44:30 <merijn> bartavelle: No!
06:45:02 <bartavelle> ok ? :)
06:45:04 <geekosaur> are we writing C in Haskell?
06:45:13 <bartavelle> I am interfacing with the ruby interpreter
06:45:16 <bartavelle> don't have much choice
06:45:19 <merijn> bartavelle: castPtrToStablePtr is only sensible for pointers generated by castStablePtrToPtr
06:45:25 <bartavelle> yes they are
06:45:29 <merijn> bartavelle: Using them on any other pointer is undefined behaviour
06:45:41 <bartavelle> well, they *should* be
06:45:49 <merijn> No they're not
06:46:08 <merijn> "intPtrToPtr" is not "castStablePtrToPtr"
06:46:27 <merijn> Neither is fromIntegral
06:46:40 <bartavelle> actually it's not with free that I have problems, but with deRefStablePtr (castPtrToStablePtr (intPtrToPtr (fromIntegral i)))
06:46:47 <bartavelle> well, I *might* have problems
06:46:54 <merijn> bartavelle: That line is wrong too
06:47:04 <bartavelle> how do you suggest I achieve my goal ?
06:47:07 <merijn> bartavelle: Where is i coming from?
06:47:23 <bartavelle> I convert my stableptrs to ruby bigints
06:47:23 <merijn> Why do you have an i that requires "fromIntegral" at all?
06:47:41 <bartavelle> they turn to Integer in haskell
06:47:54 <merijn> Why are you converting them to ruby bigints?
06:48:03 <bartavelle> I can't convert them to RValue
06:48:10 <bartavelle> I use that for calls from ruby functions to haskell functions using haskell values
06:48:21 <bartavelle> that I generated in the Haskell world
06:48:28 <merijn> Doesn't Ruby have some way of dealing with void*?
06:48:47 <merijn> That seems a rather deficient FFI if they don't
06:49:00 <bartavelle> that wouldn't be the only deficiencies
06:49:23 <merijn> You could try and pray it works...
06:49:24 <bartavelle> and I didn't find a better suited type ... but I am no ruby expert
06:49:36 <merijn> Might be more of a Ruby question?
06:49:42 <bartavelle> anyway, whatever type I choose, this would not matter
06:49:47 <bartavelle> this would be modifiable from ruby
06:49:52 <bartavelle> so rendered invalid
06:50:16 <bartavelle> then, deRefStablePtr will most certainly result in a segfault if I am lucky, right ?
06:50:27 <bartavelle> there is no list of "known stable pointers" ?
06:50:42 <merijn> Nope
06:50:52 <bartavelle> then I suppose I should document that ;)
06:54:11 <bartavelle> actually I could wrap a function partially applied with the value I want to embed, that would be much safer
06:55:00 <merijn> http://hpaste.org/88899 <- this or move to have 1 subdir per package with relevant LICENSE file?
06:58:03 <merijn> dcoutts_: Should extra license files be designated as data-files: or extra-source-files to get packaged when running "cabal sdist"?
07:02:01 <Nik05> im back, lets try some more haskell :P
07:05:22 <jonkri> i build ghc and made a tar.bz2 out of the directory, and when i run hsenv --ghc=myarchive.tar.bz2 is takes a very long time. any ideas?
07:05:42 <jonkri> (it successfully exits after 5-10 minutes)
07:07:08 <`^_^v> make yourself a tasty bagel
07:07:38 <Botje> jonkri: it looks like hsenv just unpacks that tarball somewhere.
07:07:57 <Botje> jonkri: how much time does a regular tar xjf myarchive.tar.bz2 take?
07:10:46 <blueonyx> what am i doing wrong if i try to cabal install myProject and cabal tells me that it couldnt resolve dep myProject? O.o
07:11:07 <merijn> blueonyx: Is "myProect" on Hackage?
07:11:12 <blueonyx> no
07:11:15 <Botje> if you're in myProject's directory, 'cabal install' suffices.
07:11:22 <merijn> ^^
07:11:31 <jonkri> Botje: let me check :)
07:11:39 <blueonyx> Botje: thats what i doo
07:11:43 <elliott> @hpaste
07:11:43 <lambdabot> Haskell pastebin: http://hpaste.org/
07:11:46 <elliott> show an error :)
07:11:52 <Botje> blueonyx: cabal install != cabal install myProject
07:11:54 <merijn> blueonyx: Also "couldn't resolve dependencies" means "the libraries you depend on specify version constraints that are incompatible"
07:12:17 <blueonyx> eg http://hpaste.org/88900
07:12:43 <Botje> okay, now show your cabal file
07:13:45 <blueonyx> http://hpaste.org/88901
07:14:50 <Botje> that looks sane enough.
07:16:14 <blueonyx> hm cabal configure shows other errs
07:17:09 <supki> blueonyx: cabal install -v3  should tell which package exactly is not found
07:17:40 <dcoutts_> blueonyx: is MechGen installed?
07:18:49 <blueonyx> supki: doesnt help
07:19:13 <blueonyx> dcoutts_: no, and thats the error i was expecting, and is reported by cabal configure
07:19:45 <blueonyx> now trying the trinity
07:20:44 <jonkri> Botje: the files produced in the prefix location by `make install' should suffice for hsenv, right?
07:20:50 <dcoutts_> blueonyx: you'll have more luck if you tell it to install MechGen too, e.g. cabal install [--dry-run] ./ ../MechGen
07:21:17 <Botje> jonkri: i don't have experience with that, I just looked at the description
07:21:24 <jonkri> ok, thanks
07:21:50 <blueonyx> dcoutts_: MechGen gave the same error, but with configure&&build&&install its fine now :/
07:23:15 <blueonyx> thanks anyhow
07:25:52 <jonkri> Botje: it looks like it installs ghc :) <https://github.com/Paczesiowa/hsenv/blob/master/src/hsenv.hs#L37>
07:40:38 * hackagebot shakespeare-i18n 1.0.0.3 - A type-based approach to internationalization.  http://hackage.haskell.org/package/shakespeare-i18n-1.0.0.3 (MichaelSnoyman)
07:53:30 <Botje> jonkri: it's worse, actually
07:53:42 <Botje> it unpacks, calls configure, and then make install
07:53:54 <jonkri> ouch :D
07:54:18 <Botje> if you're unlucky, the configure flags will be different and the ghc build system will decide to rebuild your ghc from scratch
07:54:20 <jonkri> maybe i should tar the .hsenv directory instead and install it myself :)
07:55:18 <jonkri> Botje: it looks like it sets prefix though, no?
07:55:26 <Botje> that it does
07:55:55 <jonkri> ah, i see
07:58:13 <jonkri> i'm confused by a cabal dependency error that i'm getting. <http://jonkri.com/temp/build-problem.png>
07:58:13 <jonkri> the way i read this, tls-extra wants certificate, certificate wants process, and process wants unix. unix 2.6.0.1 wants bytestring (≥0.9.2.0 & <0.11). my cabal file specifies 0.9.2.0. so why are these dependencies not compatible?
07:59:41 <supki> unix wants installed version of bytestring
08:00:07 <supki> which is not the version pontarius-xmpp wants
08:00:41 <jonkri> aha
08:01:06 <jonkri> is there a way to tell unix what it wants? :)
08:01:35 <dcoutts_> jonke: it's plausible it could find a solution involving re-installing unix to use the earlier bytestring, or installing an older version of the unix package, but you probably would not want that anyway
08:02:10 <dcoutts_> jonke: also, try with --dry-run -v --max-backjumps=-1 --reorder-goals
08:02:20 <jonkri> i want to install using the dependency versions specified in the cabal file, and cabal can break my system in order to do it if need be
08:02:33 <jonkri> ok :>
08:03:38 <jonkri> dcoutts_: i put the parameters after cabal and before install, and the output looks exactly the same, i think
08:04:24 <jonkri> i'll show you
08:04:41 <dcoutts_> should go after install, but it'll work anyway I think
08:05:33 <jonkri> dcoutts_: http://jonkri.com/temp/build-problem2.png
08:05:44 <dcoutts_> jonkri: --max-backjumps=-1 means it'll do an exhaustive search, though if it does it still reports the first failure
08:06:16 <Nik05> guys what is the parse error? :P http://ideone.com/0NgEp5
08:06:22 <Nik05> i just dont see it... :S
08:07:07 <Botje> Nik05: missing ) in the guard
08:07:26 <Nik05> damn im stupid
08:07:39 <Nik05> :P
08:07:42 <jonkri> forgive my arrogance, but how is this not a bug, or an undesired behaviour of cabal? if i say bytestring ==0.9.2.0, should that not apply to the dependencies of dependencies too? :>
08:08:10 <dcoutts_> jonkri: yes it does apply, and any solution it finds will have that property
08:08:34 <dcoutts_> jonkri: the point is that it's failing to find a solution, and it has done an exhaustive search
08:08:59 <jonkri> so why does it try the latest bytestring in the first place? is it because the other packages that are installed already depends on the "wrong" bytestring version, and cannot be decoupled from that?
08:10:01 <enigmuriatic1> if i want to take chars 3-7 of a string, what's the easiest way to do tht?
08:10:30 <mauke> enigmuriatic1: drop/take
08:10:30 <eikke> > take 4 $ drop 2 "Hello, world!"
08:10:32 <lambdabot>   "llo,"
08:10:35 <bartavelle> I realized that you should never have two versions of bytestring
08:10:40 <dcoutts_> jonkri: it's not trying the latest bytestring
08:10:45 <eikke> minus potential off-by-one somewhere
08:11:23 <dcoutts_> jonkri: it's reporting a conflict because it finds that the installed instance of unix that it wanted to use, actually uses a different version of bytestring than the one you've asked for
08:11:36 <enigmuriatic1> eikke, out of curiosity, is that efficient?
08:11:46 <eikke> enigmuriatic1: strings aren't efficient ;)
08:11:51 <enigmuriatic1> i suppose so, actually, when you think about how you would do that with a linked list
08:12:01 <eikke> but if the range is 3-7, yeah, should work pretty well
08:12:10 <enigmuriatic1> eikke, i really don't like how Haskell uses linked lists by default :/
08:12:15 <enigmuriatic1> not ideal
08:12:34 <mauke> enigmuriatic1: for what?
08:12:35 <eikke> it's not haskell using linked lists, it's you not using ByteString or Text ;-)
08:12:46 <enigmuriatic1> lists and strings by default
08:12:58 <mauke> enigmuriatic1: those are not operations
08:13:02 <enigmuriatic1> eikke, I haven't got to that yet :P
08:13:04 <enigmuriatic1> all in good time
08:13:14 <eikke> enigmuriatic1: then you shouldn't bother about efficiency
08:13:24 <dcoutts_> jonkri: yes, installed packages have fixed dependencies. That can often be avoided by the solver picking source versions of those packages instead and building those against different versions
08:13:34 <enigmuriatic1> but i just took a whole class on efficiency :D
08:13:40 <enigmuriatic1> it's hard-wired into me at this point
08:13:42 <Saizan> we use lists more like other languages use iterators
08:13:47 <dcoutts_> jonkri: what is unclear at the moment is why it could not find a solution like that
08:14:46 <dcoutts_> jonkri: we might get a more interesting solver trace with --constraint='unix source' --constraint='process source'
08:15:26 <dcoutts_> jonkri: btw, hpaste is a bit easier than pngs
08:15:54 <Nik05> hu i dont get it i have a function "f a b c" but when i do :info f it says i have an extra argument
08:16:17 <merijn> dcoutts_: Should I use data-files or extra-source-files to ensure that "cabal sdist" packs additional License file into the tar file?
08:16:29 <dcoutts_> merijn: extra-source-files
08:16:39 <merijn> Ok, thanks :)
08:16:43 <eikke> :t f a b = foldr a b
08:16:44 <lambdabot> parse error on input `='
08:16:57 <eikke> :t let f a b = foldr a b
08:16:58 <lambdabot> <no location info>: not an expression: `let f a b = foldr a b'
08:17:03 <Saizan> :t let f a b = foldr a b in f
08:17:04 <lambdabot> (a -> b -> b) -> b -> [a] -> b
08:17:10 <eikke> Nik05: ^^
08:17:34 <Saizan> Nik05: i.e. it just means the right-hand-side of the definition is a function too
08:17:42 <eikke> Nik05: your 'f' could need more arguments to be fully-applied if 'f' itself when applied to the given arguments is still a function
08:18:01 <jonkri> dcoutts_: thanks :) (i could not copy the text from the virtual machine, that's why i took a screenshot)
08:18:08 <dcoutts_> oh heh
08:18:09 <Nik05> so if you retunrn a function it doesnt have (a -> a) as last but a -> a?
08:18:13 <Nik05> not so nice...
08:18:24 <Nik05> how could you see the difference?
08:18:33 <dcoutts_> jonkri: ok so I can get an error for it too, where as there is a solution for ghc-7.4.x
08:18:57 <eikke> Nik05: (a -> a) and a -> a are the same thing, right?
08:19:50 <Saizan> Nik05: (->) associates to the right, so a -> b -> c is the same as a -> (b -> c)
08:19:55 <eikke> Nik05: if some function f has type a -> b -> c -> d, you could read it as a -> (b -> (c -> d))
08:20:02 <dcoutts_> jonke: oh hmm, no I can get a solution for 7.6 too
08:20:14 <Nik05> hm strange :P
08:20:15 <eikke> so f is a function which takes an a and returns a function which takes a b and returns a function which take a c and returns a d
08:20:37 <eikke> (hope I didn't make a mistake in the above now ^^ :D)
08:20:38 <dcoutts_> jonkri: oh but you wanted a specific bytestring version...
08:20:58 <jonkri> dcoutts_: i guess i'm doing this all wrong :P i should back up
08:21:54 <jonkri> i had this idea that i wanted to test that the lowest version numbers in the dependency version ranges that i define, to see that they still build the project
08:22:16 <dcoutts_> jonkri: did you make other changes? I cannot reproduce it. It also works when I use --constraint='bytestring == 0.9.2.0'
08:22:24 <dcoutts_> has to reinstall unix and process of course
08:22:31 <jonkri> so instead of saying <package> >= <version>, for example, i replaced >= with ==
08:23:00 <Sculptor> yo
08:23:01 <jonkri> for all the dependencies
08:23:11 <jonkri> i guess i should not do it this way
08:23:13 <dcoutts_> jonke: ah, that doesn't necessarily mean that all of them can be satisfied simultaneously
08:23:59 <dcoutts_> jonkri: incidentally in the latest cabal dev version there's a feature to try with the lowest version of all packages, rather than the usual preference for highest
08:24:15 <dcoutts_> but it doesn't force it, just reverses the preference
08:24:20 <jonkri> cool
08:24:34 <jonkri> when you say cabal dev, do you mean cabal-dev or some unstable version of cabal? :>
08:24:49 <dcoutts_> development version of cabal-install
08:25:04 <byorgey> cabal is the new cabal-dev
08:25:22 <byorgey> or should I say, cabal dev is the new cabal-dev
08:25:28 <dcoutts_> heh
08:25:32 <jonkri> haha
08:25:41 <dcoutts_> I never did understand why it got named cabal-dev
08:25:51 <dcoutts_> certainly it was never the development version of cabal
08:26:08 <jonkri> yeah, and it's not like developers are not using the regular cabal :>
08:26:13 <dcoutts_> right
08:26:22 <Nik05> how can you not return a function, but the result of the function? :P
08:26:28 <byorgey> my guess is it's supposed to be something like "cabal, for when you are doing development"
08:26:32 <byorgey> but I agree that's a bit silly
08:26:47 <fizruk> Nik05: apply a function?
08:26:57 <Nik05> well im doing that... :(
08:27:31 <fizruk> if the result is still function, maybe you need to specify more arguments?
08:27:41 <Nik05> probably somewhere :P
08:28:23 <enigmuriatic1> http://blog.raynes.me/blog/2012/11/27/easy-json-parsing-in-haskell-with-aeson/      I can't find the module Data.Applicative used in this
08:28:31 <enigmuriatic1> where would i get it?
08:29:39 <enigmuriatic1> is it Control.Applicative now?
08:29:52 <bartavelle> enigmuriatic1, I'd say it is Control.Applicative
08:30:09 <enigmuriatic1> why would he make such an obvious mistake? did they change it at some point?
08:30:36 <byorgey> people make obvious mistakes sometimes, news at 11.
08:30:50 <bartavelle> there was a big change before I started to use Haskell, and several tutorials use the old convention, although I am not sure this is the case here
08:30:51 <byorgey> it has always been Control.Applicative.
08:31:14 <byorgey> no, you're thinking of old unhierarchical module names like 'List' changing to 'Data.List'
08:31:18 <bartavelle> yes
08:31:30 <byorgey> that changed before Applicative came along.
08:31:41 <bartavelle> ok, so that happened ages ago
08:31:42 <enigmuriatic1> yeah he uses Control.Applicative in the final code
08:32:14 <monochrom> oh! I forgot to talk about "cabal configure; ...; cabal install" in my cabal-cabal.xhtml
08:33:24 <byorgey> oh no!  now it's too late!
08:33:47 <monochrom> it has always been too late
08:42:17 <giogadi> hey y'all, I'm having an issue with lazy IO
08:42:41 <giogadi> within a function, I'd like to open a file, get some data from it, close it, then have the function return that data, more or less
08:43:14 <Saizan> if you want to close the file yourself you basically have to avoid lazy I/O
08:43:20 <giogadi> aw poop
08:43:36 <giogadi> so self-closure basically doesn't work well with lazy?
08:43:39 <ssbr> "lazy IO"?
08:43:47 <mauke> giogadi: how would it?
08:43:47 <ssbr> Oh oops, wrong channel. Makes sense here. Nevermind.
08:43:56 <giogadi> I mean, I'm assuming it's a laziness issue
08:44:01 <giogadi> here's my code: http://hpaste.org/88905
08:44:01 <mauke> what issue?
08:44:14 <mauke> giogadi: yes, that's doing it wrong
08:44:15 <Saizan> giogadi: hGetContents closes the Handle for you when you consume the whole file, if you don't mind
08:44:20 <giogadi> oooooooh
08:44:30 <mauke> you can use only one of hClose and hGetContents
08:44:43 <mauke> :t readFile
08:44:44 <lambdabot> FilePath -> IO String
08:44:45 <giogadi> what about exceptions and such? is there no need to worry about haskell leaving a file open?
08:45:03 <mauke> yes, but that has nothing to do with exceptions
08:45:17 <mauke> besides, your code isn't exception safe anyway
08:45:57 <giogadi> well, for the future I guess (I know my code isn't perfectly exception safe) - how do people deal with files staying open?
08:46:05 <dwcook> Are Haskell functions total in the mathematical sense? i.e., does undefined not ruin anything if we consider it to be part of every type?
08:46:25 <Botje> giogadi: there's bracket, which allows you to create withFile $ \f -> ... things.
08:46:28 <dwcook> Or is that not a useful way to look at it?
08:46:49 <giogadi> Botje: thanks, I'll take a look at that
08:47:40 <giogadi> thanks for your help, everyone!
08:49:14 <ryantanjunming> any agda aficionados here?
08:49:28 <byorgey> dwcook: Haskell functions are not (required to be) total.  Indeed, undefined ruins everything.
08:49:48 <dwcook> byorgey, why can't we just consider that to be in every set under discussion and have everything be okay?
08:50:30 <byorgey> dwcook: well, you could define things that way.  It's just that wouldn't be a very useful notion of "total".
08:50:50 <dwcook> byorgey, what makes it not useful?
08:51:01 <byorgey> "These functions are all total!  They will either give you an answer or crash or run forever!  Guaranteed!"
08:51:04 <Saizan> ryantanjunming: me! why?
08:51:10 <dwcook> Fair point. :P
08:51:27 <dwcook> Is Turing completeness the thing that ruins totality?
08:51:49 <byorgey> Well, if you want Turing completeness you have to give up totality, yes.
08:51:54 <byorgey> because of the halting problem.
08:51:56 <dwcook> Right.
08:52:26 <dwcook> I may have asked this in here before, but is there some model that's almost Turing complete but that halts?
08:52:46 <natanyr> Saizan: ive changed nick
08:52:49 <byorgey> Languages like Agda and Coq make the other choice: they only allow you to write total functions.  So they are useful as logics, but they are not Turing complete.
08:52:59 <natanyr> http://hpaste.org/88907
08:53:17 <byorgey> dwcook: Yes, lots.  Agda and Coq are based on such models.
08:53:19 <dwcook> Why prefer Turing machines to something stronger that lets you decide halting?
08:53:23 <natanyr> Saizan: ive a problem with this base case..
08:53:31 <Saizan> dwcook, byorgey: there's a bit of room for interpretation in what turing completeness means, in total languages you might have a non-termination monad and have your general recursion there, but in the most strict sense i agree
08:54:18 <dwcook> Is it that you can't find the answers to some important problems unless you have Turing completeness?
08:54:24 <enigmuriatic1> http://blog.raynes.me/blog/2012/11/27/easy-json-parsing-in-haskell-with-aeson/       can someone tell me how I actually use the parseJSON function that I declare there? the full code is at the bottom.
08:54:39 <enigmuriatic1> i've written my version of it but don't know how to call it
08:54:45 <dwcook> e.g., what's a problem Haskell can solve that Agda can't?
08:55:08 <byorgey> dwcook: no, not really.  The usual reason is that writing programs in total, non-Turing-complete systems is either (a) boring (if the systems don't let you do very much) or (b) difficult.
08:55:19 <dwcook> I see.
08:55:36 <supki> enigmuriatic1: you use decode (or eitherDecode), not parseJSON
08:55:56 <Saizan> natanyr: what in particular? but this should go to #agda i think
08:55:56 <byorgey> dwcook: As far as I know, all examples of things Haskell can do which Agda can't are rather contrived.  But coming up with an equivalent Agda program for a given Haskell program might require massive amounts of cleverness.
08:56:21 <merijn> enigmuriatic1: Looks like decode uses the parseJSON function to return "Maybe YourType"
08:57:12 <merijn> enigmuriatic1: There's an example use on line 40-44 of that code
08:57:27 <supki> also that example is awful
08:57:27 <natanyr> Saizan: line 89, at the {!!} i can type in [], but the emacs loader complains
08:57:47 <byorgey> dwcook: the Halting problem, Rice's theorem, etc. tell us there is an abyss, but we can't know exactly where the edge is, and the closer you get, the harder you have to work at it.
08:57:54 <natanyr> Saizan, yeah ive pasted it to #agda also, but it seems really quiet there..
08:59:39 <dwcook> byorgey, here is the impression I have: If you strengthen Turing machines to the point that you can compute termination of a program, your new machine can only compute a subset of the computable functions. Is that right?
08:59:56 <Nik05> hey guys how can i optimize this code? http://hpaste.org/88904
09:00:19 <dwcook> Maybe "compute termination" is the wrong phrase
09:00:24 <dwcook> "solve the halting problem"
09:00:27 <byorgey> correct.
09:00:38 <Botje> Nik05: just bind them to temporary variables.
09:01:16 <Nik05> oh ok, that is possible? :P
09:01:36 <Botje> yes .. look at your haskell reference material for the let or where keywords
09:02:04 <dwcook> byorgey, and are you implying that it's non-obvious that there are any "important" problems outside that subset?
09:02:20 <byorgey> dwcook: yes.
09:02:34 <dwcook> Okay. Thank you very much. :)
09:02:42 <byorgey> glad I could help. =)
09:03:18 <Botje> Nik05: also, if you group your functions together you can use lexical scoping instead of passing all those variables around.
09:07:25 <Nik05> Botje second day Haskell... no idea what lexical scoping is :P
09:07:28 <Botje> Nik05: http://hpaste.org/88904
09:08:14 <Botje> every function or value in the "where" bit of trapint can see the f, a and b bound by the trapint function
09:08:16 <Nik05> oh ok, but doesnt it do the same right now?
09:08:43 <Botje> I just refactored your code to take advantage of that scoping
09:08:50 <Nik05> cant you put err and err2 in the same scope?
09:08:59 <Botje> it is functionally identical to yours, but a bit more readable
09:09:00 <Botje> you can, yes
09:09:02 <Botje> but you don't gain much by it
09:09:11 <Botje> unless err and err2 are _only_ ever used by trapint
09:09:12 <Nik05> ok but do you gain anything at all?
09:09:17 <Botje> I can't tell from the one function you pasted
09:09:32 <Botje> if you put them in the where as well, they are invisible to functions outside of trapint.
09:09:43 <Botje> this is usually what you want
09:10:03 <Nik05> yes i get that, but do you gain any speed?
09:10:09 <Botje> none whatsoever.
09:10:21 <Botje> first thing the haskell compiler will do is undo the refactoring I just made
09:10:24 <Nik05> ok so i still need temporayly variables?
09:10:29 <Botje> this refactoring is purely for your benefit :)
09:10:37 <Botje> yes, now for the temporary variables bit.
09:10:44 <merijn> Is there a way to make foreign imports check their type signature vs a C header to make sure I don't screw up?
09:12:14 <Nik05> Botje how do i add another paste to it?
09:12:46 <Botje> Nik05: click the annotate button
09:13:02 <Botje> Nik05: I just annotated it with a version where the extrpl h i part is in a temporary variable
09:13:07 <Botje> so refresh the page first
09:14:45 <Nik05> Botje im now using your code, but it doesnt compile :P
09:15:06 <Botje> untested refactoring
09:15:29 <Botje> Nik05: I can load it just fine in GHCi.
09:16:09 <Nik05> the second or third one?
09:16:15 <Botje> the third one.
09:16:21 <Nik05> oh ok
09:16:22 <Botje> the second one has an extra f a b that i missed.
09:16:28 <Botje> in the call to trap, iirc.
09:16:35 <Botje> and it won't let me edit it
09:17:48 <enigmuriatic1> http://hpaste.org/88914    can anyone tell me how to get the types to work in this?
09:18:12 <Nik05> hmm its still slow :(
09:18:30 <Nik05> even getting a stack overflow :p
09:19:18 <Botje> Nik05: are you running it in GHCi or compiling with ghc?
09:19:30 <Nik05> oh ghci, thats probably the probalem
09:19:41 <Nik05> how do i correctly compile it? :)
09:19:44 <supki> enigmuriatic1: what's the error?
09:19:52 <Botje> Nik05: well .. I think there's a bug in your code, first.
09:19:53 <supki> enigmuriatic1: I think you meant BL.getContents
09:19:59 <Botje> Nik05: your termination check is abs (...) < tol
09:20:05 <Botje> Nik05: and you pass in tol=0 in the beginning
09:20:09 <enigmuriatic1> it's telling me i'm trying to use Strings when i should be using ByteStrings
09:20:12 <enigmuriatic1> supki
09:20:26 <supki> enigmuriatic1: yes, getContents gets you String
09:20:31 <enigmuriatic1> oh, supki, does BL have its own getContents
09:20:32 <Nik05> no Botje tol isnt specified
09:20:34 <supki> yes
09:20:45 <Botje> Nik05: oh, right.
09:20:51 <Botje> Nik05: yeah, then ghc --make yourfile.hs
09:20:58 <Botje> Nik05: you will need a main function, though.
09:21:00 <Nik05> dont need a main or something?
09:21:05 <Nik05> ah ok
09:21:18 <Botje> a simple main could be main = print (trapint f a b tol)
09:21:20 <Nik05> main = trapint etc...?
09:21:29 <Botje> with actual values for those variables.
09:21:32 <Nik05> ok thanks
09:21:35 <merijn> Botje: --make is no longer required
09:22:02 <Botje> ooh, shiny.
09:22:05 <Nik05> and -O?
09:22:06 <Botje> since when?
09:22:14 <Botje> Nik05: -O2 is waht i typically use
09:22:16 <merijn> "ghc yourfile.hs -o executable" should work
09:22:24 <merijn> Botje: Since 7.2 or earlier, I think?
09:22:49 <Nik05> -Ox is almost same as gcc's -Ox?
09:23:06 <enigmuriatic1> supki, now it's telling me that a0 is ambiguous in show
09:23:07 <Botje> merijn: but then you have to type -o executable :P
09:23:19 <Botje> which is my main motivation for using --make
09:23:38 <Nik05> hm still getting a stack overflow
09:24:08 <mauke> Botje: I don't think I do
09:24:20 <fruitFly> whats wrong with this? http://ideone.com/S3twrz
09:24:38 <Botje> fruitFly: missing ) on the line above
09:24:39 <merijn> Botje: Simple solution
09:24:45 <merijn> Botje: Use cabal!
09:24:50 <Botje> *groan&
09:25:01 <Nik05> fruitFly missing )
09:25:05 <fruitFly> Aah lol... thanks
09:25:10 <Nik05> oops Botje already said it :p
09:25:23 <merijn> Especially 1.17 where you can just run "cabal build" and have it working instead of it complaining "you forgot to configure!"
09:26:12 <Nik05> Botje i can also use multiple scopes right?
09:26:23 <Botje> Nik05: you can nest them, yes
09:26:27 <Nik05> so trap h i = ... \n where trapfx = ...
09:26:39 <Botje> yes
09:26:48 <Botje> or even inline the function definition if it's only used once
09:28:04 <Nik05> Botje its telling me to inceare stack space, and to use `+RTS -Ksize -RTS` why the +RTS and then -RTS?
09:28:21 <Botje> it tells the runtime to eat the arguments inbetween.
09:28:44 <Nik05> oh so i can just put that as argument for the program?
09:28:46 <Nik05> dont need to recompile?
09:28:47 <Botje> but if your program is running out of stack size it's probably infinite looping.
09:28:56 <Botje> yes, correct.
09:29:17 <byorgey> I think you would need to recompile, actually, and pass the -rtsopts flag while compiling.
09:29:25 <Nik05> it gives a result when using tol = 1e-6
09:29:34 <Nik05> but when using 1e-10 it give a stack overflow
09:29:57 <Botje> are you using Double or Float?
09:29:58 <Nik05> 1e-7 works, but 1e-8 not
09:30:11 <Nik05> uh, what is standard? :P
09:30:16 <byorgey> I see.  So increasing the stack size might help.  But there is probably also a way to get your program to use less stack in the first place.
09:31:05 <Nik05> but both result in overflow
09:31:21 <Botje> well, that rules out float precision errors.
09:31:36 <Botje> I don't see why it doesn't turn into a nice loop, either.
09:32:21 <Nik05> Botje the code works in matlab with 1e-10 on a 32bit machine...
09:32:25 <Nik05> this runs on a 64bit machine
09:33:13 <Nik05> Botje: :info trapint says a is a Fractional
09:33:27 <Nik05> should that be a double?
09:33:42 <Botje> both Float and Double are Fractional
09:34:15 <Nik05> is Double same as long double on C++ 64bit?
09:35:08 <enigmuriatic1> http://hpaste.org/88914      why does this return nothing when given {"result":"success","return":[]}  ?
09:36:05 <jonkri> can i assume the string to be free from unnecessary whitespace etc when writing a readsPrec instance?
09:36:17 <jonkri> s/instance/implementation
09:36:54 <Nik05> Botje with tol = 1e-10 this should converge in 10 iterations...
09:37:01 <Nik05> oh need to go, thanks Botje :)
09:37:05 <Botje> Nik05: bye
09:37:07 <Nik05> goedeavond!
09:37:18 <Botje> Nik05: try forcing the type to Double, maybe it *is* related to floating point
09:37:52 <fruitFly> How is this case non exhaustive? http://ideone.com/YTqLpv
09:38:45 <Botje> fruitFly: doesn't cater for the empty list
09:39:42 <fruitFly> Botje with this logic it will never reach an empty list... so I just have to stick in empty list anyway?
09:39:47 <enigmuriatic1> http://hpaste.org/88914      why does this return nothing when given {"result":"success","return":[]}  ?
09:41:02 <Botje> fruitFly: note that your first case overlaps with the other two. put it at the back.
09:42:27 <Botje> haskell will try cases from top to bottom, so char:rest will always match first, except for the empty list.
09:43:38 <fruitFly> Oooh rite... got it thanks!
09:47:00 <supki> enigmuriatic1: it expects field "trades" to be there
09:47:13 <enigmuriatic1> thanks supki, i just figured that out
09:54:08 <enigmuriatic1> supki, why is the compiler having trouble with the fact that date is Time.ClockTime? do i have to explicitly cast the type? if so, how? http://hpaste.org/88914
09:54:41 <merijn> enigmuriatic1: What's it saying? It helps to paste the error
09:55:20 <enigmuriatic1> http://pastebin.com/frQSR77j  merijn
09:55:23 <mauke> The paste frQSR77j has been copied to http://hpaste.org/88917
09:57:51 <shanse> enigmuriatic1: just like the error says, there's no instance for that type, so you'll have to supply your own
09:58:19 <enigmuriatic1> shanse, what does that mean?
09:58:20 <jonkri> is the list returned by lex always empty or of one in length?
09:59:07 <shanse> it doesnt know how to convert the json thing into a Time.ClockTime thing
10:01:23 <shanse> http://blog.raynes.me/blog/2012/11/27/easy-json-parsing-in-haskell-with-aeson/ take a look at this
10:02:34 <ClemHout> hi everybody
10:02:56 <ClemHout> in a .prof profiling file, i have a function foo called like 10 times
10:03:12 <ClemHout> so there's a line with foo on it with entries = 10
10:03:22 <ClemHout> and under that line, i have other lines
10:03:29 <ClemHout> foo.\
10:03:31 <ClemHout> and then
10:03:34 <ClemHout> foo.\.\
10:03:35 <ClemHout> and then
10:03:40 <ClemHout> foo.\.\.\
10:03:45 <ClemHout> with a lot more entries
10:03:52 <ClemHout> anyone know what this means ?
10:04:16 <arnsholt> Does anyone know of a library that implements ordered trees?
10:04:29 <yitz> enigmuriatic1: is there a special reason why you're using old-time?
10:04:32 <acube> ordered trees? As in binary trees?
10:04:33 <merijn> arnsholt: What do you mean by ordered tree?
10:04:34 <arnsholt> I've found fgl, but I'm not sure if its trees are ordered
10:04:48 <enigmuriatic1> yitz, that's what the json feed gives me
10:04:49 <arnsholt> A tree where there's an ordering over the nodes
10:05:18 <yitz> enigmuriatic1: it gives you haskell types?
10:05:39 <enigmuriatic1> i thought you mean Unix timestamps, yitz
10:05:52 <enigmuriatic1> i'm just using what Real World Haskell suggested
10:06:08 <yitz> enigmuriatic1: really? they said to use that? where?
10:07:32 <arnsholt> Not quite the standard tree in CS, but in some cases (like mine) it's useful. Also it makes some problems (like the one I need a solution to) go from MaxSNP to P, which is nice
10:08:02 <yitz> enigmuriatic1: we use the time library now: import Data.Time. System.Time was basically abandonned about ten years ago. it's only still in base because it is part of the Haskell 98 standard.
10:09:48 <yitz> enigmuriatic1: if you can't find a FromJson instance for UTCTime somewhere, I'm sure it would be easy to make one using Data.Time.Format
10:11:57 <enigmuriatic1> http://hpaste.org/88914      why is this returning Nothing for this?    http://data.mtgox.com/api/1/BTCUSD/trades/fetch
10:14:43 <merijn> @pl \x y -> x ++ "=" ++ y
10:14:43 <lambdabot> (. ('=' :)) . (++)
10:15:09 <supki> enigmuriatic1: price, amount, price_int, amount_int and tid are strings, not numbers
10:15:30 <acube> @ty (++) . ('=')
10:15:32 <lambdabot>     Couldn't match expected type `a0 -> [a1]' with actual type `Char'
10:15:32 <lambdabot>     In the second argument of `(.)', namely `('=')'
10:15:32 <lambdabot>     In the expression: (++) . ('=')
10:15:42 <enigmuriatic1> ah right. thanks supki, i keep making stupid mistakes because I forget how the data is actually being parsed
10:16:00 <arnsholt> merijn: Anyways,
10:16:00 <arnsholt> Le livre [modifier]
10:16:00 <arnsholt> Lʼauteur entreprend de raconter en détail lʼensemble des expériences sexuelles quʼelle a menées au cours de sa vie. Elles sont distribuées en quatre chapitres : Le nombre, Lʼespace, Lʼespace replié et Détails, de façon à éviter la narration chronologique (source de biais selon lʼauteur).
10:16:05 <arnsholt> Le texte joue sur un contraste fort entre le sujet (souvent cru, la sexualité y est dépeinte dans le souci le plus absolu du détail) et la forme (un registre de langage volontiers soutenu, précis et chirurgical).
10:16:06 <shanse> enigmuriatic1: http://hpaste.org/88919 that's what I use for posix time
10:16:09 <arnsholt> Dans certains développements, le livre peut sʼapparenter à un essai, où lʼauteur déploie de multiples micro-analyses, nʼhésitant pas à théoriser ses expériences.
10:16:20 <arnsholt> Whoops. Pasto
10:16:33 <acube> @ty concat <$> id <*> pure "=" <*> id
10:16:34 <yitz> enigmuriatic1: something like newtype Date = Date UTCTime; instance FromJSON Date where parseJSON = fmap $ Date . parseTime defaultLocale "%x" . BL.unpack
10:16:34 <lambdabot>     Couldn't match expected type `a1 -> a0 -> b0'
10:16:35 <lambdabot>                 with actual type `[a2]'
10:16:35 <lambdabot>     Expected type: [[a2]] -> a1 -> a0 -> b0
10:17:00 <merijn> Style question
10:17:21 <supki> enigmuriatic1: that may be helpful to use eitherDecode instead of decode, that way you will see parser error instead of Nothing
10:17:22 <arnsholt> merijn: Anyways, I've a rough idea how to implement it a la rose trees, but as a relative fresh haskeller I figured asking about libs first would be a good idea
10:17:24 <merijn> If I have a function with a do block, should the where be indented more, less or equal to the do block
10:17:43 <acube> @ty liftA2 id (pure '=') . (++)
10:17:45 <lambdabot>     Couldn't match expected type `b0 -> c0' with actual type `Char'
10:17:45 <lambdabot>     In the first argument of `pure', namely '='
10:17:45 <lambdabot>     In the second argument of `liftA2', namely `(pure '=')'
10:17:54 <acube> @ty liftA2 (++) id (pure '=') . (++)
10:17:55 <lambdabot>     Couldn't match expected type `[a0]' with actual type `Char'
10:17:55 <lambdabot>     In the first argument of `pure', namely '='
10:17:55 <lambdabot>     In the third argument of `liftA2', namely `(pure '=')'
10:18:02 <acube> @ty liftA2 (++) id (pure "=") . (++)
10:18:03 <lambdabot>     Couldn't match expected type `[Char]'
10:18:03 <lambdabot>                 with actual type `[a0] -> [a0]'
10:18:03 <lambdabot>     Expected type: [a0] -> [Char]
10:18:08 <yitz> enigmuriatic1: ah, i see, it's a unix time stamp. so, even easier
10:18:11 <supki> merijn: I use 2 space indentation and 1 space wheres
10:18:39 <merijn> http://hpaste.org/88920
10:18:59 <applicative> todays cracked wisdom: there's no bore quite like an agda bore
10:19:20 <yitz> enigmuriatic1: that url did not return a Data. it returned {result:success return:[...
10:19:50 <enigmuriatic1> yitz, that's what a data is
10:19:56 <enigmuriatic1> the return list is a list of Trades
10:20:02 <enigmuriatic1> i got it to work
10:20:28 <joelteon> :t liftA2 (++) id
10:20:30 <lambdabot> ([a] -> [a]) -> [a] -> [a]
10:20:59 <yitz> enigmuriatic1: oh i see you called it result but it actually looks for return.
10:21:08 <yitz> enigmuriatic1: great!
10:24:46 <yitz> enigmuriatic1: instance FromJSON Date where parseJSON = fmap $ Date . posixSecondsToUTCTime . realToFrac
10:25:06 <enigmuriatic1> yitz, what's that?
10:26:13 <yitz> enigmuriatic1: that will allow you to use the usual time type, UTCTime, instead of your System.Time.ClockTime
10:27:07 <yitz> enigmuriatic1: or perhaps even just omit the Date newtype wrapper and use UTCTime directly
10:31:13 <yitz> enigmuriatic1: oh, i see there is a built in instance for UTCTime, assuming a string representation.
10:31:51 <yitz> enigmuriatic1: so you would either use POSIXTime, then convert that using posixSecondsToUTCTime. Or use a newtype wrapper
10:32:00 <yitz> oops gotta go bye
10:50:02 <tabemann> stupid stupid question: how do you convert a String into a straight strict ByteString - not a ByteString.Char8 (I saw a pack function when searching, but that created instances of ByteString.Char8)?
10:53:02 <bitonic> tabemann: Data.ByteString.Char8.ByteString is a re-export of Data.ByteString.ByteString
10:53:27 <applicative> tabemann: you want the Data.Text.Encoding functions
10:53:38 <applicative> or similar machinery
10:54:27 <applicative> T.encodeUTF8 . T.pack  makes a bytestring out of a haskell string
10:55:15 <tabemann> okay that's what I'm looking for
10:55:29 <bitonic> wait, wait
10:55:39 <bitonic> tabemann: how do you want to encode the String?
10:55:44 <bitonic> what are you doing with the ByteString
10:56:11 <applicative> this is the question that a look at Data.Text.Encoding will put to tabemann
10:56:33 <bitonic> if you want to encode the String to a sequence of UTF-8 bytes I’d use ‘utf8-string’
10:56:43 <tabemann> I'm feeding it into toForeignPtr so I can cast it into a Ptr GLchar (and put that in a Ptr Ptr CLchar) so I can feed it into glShaderSource
10:56:44 <c_wraith> I wouldn't.
10:56:47 <bitonic> if you want to truncate all characters to a byte, you can use the Char8 module
10:56:54 <c_wraith> utf8-string is probably much slower than text
10:57:07 <c_wraith> as well as having a bizarre interface
10:57:21 <c_wraith> and instances that conflict with instances in the bytestring package
10:57:49 <applicative> utf8-string is basically deprecated and unmaintained as I understand it
10:57:52 <tabemann> i.e. the reason why I am doing this is to deal with the very, um, raw interface of OpenGLRaw
10:58:04 <bitonic> oh, then sorry, do what applicative said if you want to convert it to UTF-8
10:58:40 <tabemann> I'm probably going to use the UTF-8 conversion function as a matter of course, even though I'm probably not going to be feeding in any characters greater than 0x7F
10:59:02 <bitonic> tabemann: well if you’re passing it to a C function you need to check what the C function is doing with the ‘char *’
11:00:07 <tabemann> the Ptr Ptr GLchar is being dereferenced twice and having characters being read out of it; I honestly don't know if glShaderSource modifies what you feed into it (I could probably look that up)
11:01:43 <bitonic> tabemann: considering that it’s GL shaders, I wouldn’t be surprised if it expects simple ASCII strings, but don’t take my word for it...
11:01:45 <tabemann> okay, I figured out why it takes a Ptr Ptr GLchar; apparently if you change one of the arguments you can feed in an *array* of strings to it
11:02:09 <MitchellSalad> hi, could someone please let me know if it's possible to simplify this function (using Control.Lens):
11:02:21 <MitchellSalad> getHand :: Int -> State GameState [Card]
11:02:26 <MitchellSalad> getHand index = do
11:02:30 <MitchellSalad>    player <- uses players (!! index) -- get the player at |index|
11:02:33 <MitchellSalad>    return $ player ^. hand           -- get the player's hand
11:02:45 <MitchellSalad> i'm trying to figure out if i can compose the two lenses together
11:03:13 <MitchellSalad> if it's not clear, GameState has a players :: [Player] lens, and a Player has a hand :: [Card] lens
11:03:58 <MitchellSalad> wow that's hard to read with all these disconnects
11:05:10 <supki> use (players . ix index . hand) ?
11:05:28 <supki> @hpaste
11:05:28 <lambdabot> Haskell pastebin: http://hpaste.org/
11:05:46 <jonkri> did i just author the ugliest read function ever? <http://hpaste.org/88926> :>
11:05:48 <supki> also use hpaste for pastes, please
11:06:22 <jonkri> it seems to work, but i feel that i'm writing really ugly code today. any pointers on how to improve it would be appreciated
11:06:28 <MitchellSalad> oh, will do
11:06:49 <MitchellSalad> @supki: where's ix?
11:06:50 <lambdabot> Unknown command, try @list
11:07:16 <supki> MitchellSalad: it should be in scope if you import Control.Lens
11:07:29 <supki> Control.Lens.At I think
11:07:59 <supki> > ([(1, 2), (3, 4)], 5) ^? _1 . ix 1 . _2
11:08:00 <lambdabot>   Just 4
11:08:12 <MitchellSalad> thanks supki
11:08:25 <eikke> :t compare `on` fst
11:08:26 <lambdabot> Ord b => (b, b1) -> (b, b1) -> Ordering
11:11:12 <supki> MitchellSalad: note that you will get [] if index is out of bounds
11:12:00 <supki> that's still better than your initial version though
11:12:35 <MitchellSalad> okay, thanks. yeah this is the first time I've tried using Lens and it is pretty daunting
11:12:36 <supki> you may use  preuse (players . ix index . hand)  to get  Maybe [Card]
11:15:11 <MitchellSalad> ok thanks, and is there an easy way to search hackage packages? trying to find the documentation of preuse, for example
11:16:34 <c_wraith> if all you want is the documentation for a package you know the name of, you don't even need to search
11:16:37 <c_wraith> @hackage preuse
11:16:37 <lambdabot> http://hackage.haskell.org/package/preuse
11:16:47 <c_wraith> of course, there's no package with that name
11:17:03 <c_wraith> did you want the documentation for the Prelude module, which is in the base package?
11:17:30 <MitchellSalad> preuse, the function inside Control.Lens, but i
11:17:46 <c_wraith> ah, ok.
11:17:55 <MitchellSalad> preuse is a function in Control.Lens that supki just mentioned to me, but I'm not sure how to find it
11:17:58 <shachaf> @where hayoo will probably find it.
11:17:58 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
11:18:04 <MitchellSalad> in the many modules of Control.Lens
11:18:36 <MitchellSalad> it did, thanks shachaf
11:18:43 <shachaf> preuse / use = preview / view, naturally. :-)
11:19:15 <Shin-LaC> how are ghc bindists built?
11:20:26 <shachaf> In the darkness, naturally.
11:24:03 <monochrom> someone with a previous version of GHC builds them
11:24:36 <shachaf> Or the same version, sometimes.
11:25:12 <monochrom> in fact, I did it for myself recently. configure, make, make bindist. I may mispell bindist
11:25:53 <monochrom> actually, configure, make -j2, make bindist
11:27:39 <monochrom> in fact, I also tried using a newer version (7.6.3) to build an older version (7.4.2). I was thwarted by the mere technicality of "your base is too new" or something like that
11:31:03 * hackagebot stm-chans 2.1.0 - Additional types of channels for STM.  http://hackage.haskell.org/package/stm-chans-2.1.0 (WrenThornton)
11:31:05 * hackagebot stm-chans 3.0.0 - Additional types of channels for STM.  http://hackage.haskell.org/package/stm-chans-3.0.0 (WrenThornton)
11:31:35 <Clint> rapid release
11:32:24 <shachaf> Hmm, they misspelled "wrenthornton".
11:35:45 <tabemann> I forget - what's the counterpart of newForeignPtr to call when you don't want any finalization to be done?
11:36:24 <tabemann> well, that's not the right question
11:36:48 <eikke> tabemann: I'd say, use const (return ()) as callback? :)
11:36:56 <eikke> (or whatever type you need)
11:37:10 <fizbin> Opinions on the best way to twiddle binary in Haskell? Specifically, I'm creating a ~ 2 Mb configuration binary in memory that's going to be read by a C program and that has fairly complicated structures in it that reference each other (by giving offsets into the configuration binary).
11:37:46 <Cale> fizbin: Well, there's the stuff in Data.Bits on the smaller scale, and Data.ByteString on the somewhat larger scale.
11:38:14 <tabemann> well what I'm trying to do is allocate a buffer, have glGetShaderInfoLog write into it, and then get it into a foreign pointer, so I can call fromForeignPtr on it to make a ByteString, which I can then feed into the bytestring analog of putStr
11:38:27 <Cale> If you're doing FFI, then maybe StorableArray or something along those lines would be better
11:38:50 <ChongLi> tabemann: hey, I'm messing around with that stuff too
11:38:55 <fizbin> Cale: ByteString is probably my preferred type for output, but for all the random access I'm doing when building it up I was thinking STUArray might be better.
11:39:09 <tabemann> okay second question - does fromForeignPtr copy or not?
11:39:25 <fizbin> And no FFI; I'm writing this to a file that's getting shipped out to other machines.
11:39:50 <ChongLi> tabemann: I'm not using fromForeignPtr
11:39:57 <swistak35> hi, I'm haskell beginner. What kind of project could I write in haskell to learn it? Currently I'm thinking about irc bot or something in yesod framework. Any other/better ideas?
11:40:13 <ChongLi> I use allocaArray0
11:40:45 <Clint> swistak35: yesod is not the right first thing to do
11:40:57 <ChongLi> yeah, yesod is pretty complex
11:41:10 <ChongLi> learning it would just be learning yesod, not necessarily learning haskell
11:41:22 <swistak35> Clint: I'm learning haskell on university, but I think that I should do sth more complex to understand it better
11:41:31 <swistak35> I came from ruby world, if it's helpful
11:41:50 <ChongLi> ahh, rails experience?
11:42:09 <swistak35> ChongLi: yes, that's why I thought about yesod
11:42:21 <ChongLi> I see
11:42:25 <ChongLi> well, don't get me wrong
11:42:25 <tabemann> ChongLi: so how are you converting into a ByteString
11:42:30 <ChongLi> yesod is great and worth using
11:42:44 <ChongLi> but probably not for a very first project
11:43:00 <swistak35> I was also thinking about writing some parser/interpreter  of simple language
11:43:08 <ChongLi> tabemann: peekCStringLen
11:43:13 <swistak35> "While" maybe, or sth like that
11:43:28 <ChongLi> if you want a ByteString you'll have to go from there
11:43:30 <Cale> swistak35: If you'd be interested in generating pretty pictures of some sort, Diagrams is a really cool library, or for simpler cases, but with more potential for animation and interactivity, you could check out gloss.
11:43:41 <ChongLi> swistak35: a parser is a great choice
11:44:11 <tabemann> well I don't need a bytestring; that'll work for me
11:44:29 <Cale> swistak35: and yeah, Parsec is a really cool library.
11:44:32 <ChongLi> tabemann: what I have is kind of complex
11:44:47 <Cale> (or another parser combinator library -- you could even write your own with a little direction)
11:45:00 <ChongLi> since you've also got to supply a ptr to an int to tell openGL how big your buffer is
11:45:12 <MitchellSalad> supki: from before, "preuse (players . ix index . hand)" works great to grab a player's hand, but it seems like if i want to modify a player's hand, i have to repeat the error-handling logic -- http://hpaste.org/88927
11:45:33 <tabemann> oh I'm already doing that
11:45:46 <MitchellSalad> supki: that's my code as of right now but i'm still trying to work in error handling to setHand
11:45:50 <ChongLi> ah then you're all set
11:46:03 * hackagebot hamid 0.9 - Binding to the OS level Midi services (fork of system-midi).  http://hackage.haskell.org/package/hamid-0.9 (HansHoglund)
11:46:16 <ChongLi> just make sure you don't try to return the ptr you get from allocaArray0
11:46:41 <swistak35> ChongLi, Cale: Thanks a lot, I will try these both libraries
11:46:51 <ChongLi> it's really only safe to use within the scope of the function you pass to it
11:47:42 <acube> MitchellSalad: you can just use players . ix index . hand .= yourNewValue
11:47:49 <mustermark> Anyone use YAMPA or understand arrows pretty well? I'm having a hard time understanding how v gets initially resolved in this snippet: https://gist.github.com/shargoj/7b016293950ce971c1f7
11:48:06 <MitchellSalad> acube: what if there is no player at index?
11:48:21 <acube> > evalState (_1 . ix 2 .= 4) ([1,2,3],2)
11:48:22 <lambdabot>   ()
11:48:26 <acube> > execState (_1 . ix 2 .= 4) ([1,2,3],2)
11:48:27 <lambdabot>   ([1,2,4],2)
11:48:30 <acube> > execState (_1 . ix 2 .= 4) ([1],2)
11:48:32 <lambdabot>   ([1],2)
11:48:44 <acube> MitchellSalad: it just does "nothing"
11:49:16 <MitchellSalad> oh, but i want it to error
11:49:31 <MitchellSalad> because you should never try to update a player's hand who doesn't exist
11:49:40 <Shin-LaC> <monochrom>	 actually, configure, make -j2, make bindist  <-- thanks
11:49:57 <MitchellSalad> so subki told me about preuse which returns a Maybe
11:50:03 <tabemann> ChongLi: I didn't bother to change my allocaBytes (as I'm not bothering to null-terminate), but yeah
11:50:19 <ChongLi> ahh
11:50:38 <acube> MitchellSalad: you can check if the player exists with has
11:50:49 <ChongLi> are you wrapping your GLenums in any way?
11:50:57 <tabemann> not really
11:51:00 <acube> > evalState (has (_1 . ix 4) <$> get) ([1],2)
11:51:02 <lambdabot>   False
11:51:07 <acube> > evalState (has (_1 . ix 4) <$> get) ([1,2,3,4,5],2)
11:51:09 <lambdabot>   True
11:51:43 <acube> > evalState (do v <- get; has (_1 . ix 4) v) ([1,2,3,4,5],2) -- In do notation
11:51:44 <lambdabot>   Couldn't match expected type `Control.Monad.Trans.State.Lazy.StateT
11:51:45 <lambdabot>        ...
11:51:50 <tabemann> I'm not feeling like writing my own abstraction layer over OpenGLRaw, aside from all the functions I'm finding myself writing for the purposes of marshaling when talking with functions therein
11:51:52 <acube> > evalState (do v <- get; return $ has (_1 . ix 4) v) ([1,2,3,4,5],2) -- In do notation
11:51:53 <Nik05> Botje how do i force it to Double?
11:51:53 <lambdabot>   True
11:52:10 <ChongLi> tabemann: yeah, I feel the same way
11:52:12 <Nik05> Just puting 1e-10 :: Double as tol?
11:52:20 <MitchellSalad> acube: thanks
11:52:37 <ChongLi> I think the regular OpenGL package is really weird
11:53:24 <tabemann> it is, and it is incomplete for what it claims to support, which is why I'm using OpenGLRaw
11:53:35 <ChongLi> OpenGLRaw is not too bad
11:53:47 <ChongLi> most of the functions don't require marshaling
11:53:54 <acube> ⎋/script install iset.pl
11:54:00 <tabemann> OpenGLRaw is much nicer for looking at other people's example code in C, because the identifiers are practically identical to those in C OpenGL
11:54:07 <ChongLi> yeah
11:54:19 <ChongLi> I've been going through arcsynthesis
11:54:29 <ChongLi> and it translates in a totally straightforward way
11:55:35 <ChongLi> the only other real annoyance I'm finding is the way the functions seem to arbitrarily return GLuint or GLint and you're forced to coerce
11:55:53 <ChongLi> I always worry I'm going to have some overflow issue with that
11:56:02 <tabemann> yes, that I'm finding I have to call fromIntegral or realToFrac all over the time is annoying
11:56:04 * hackagebot hamid 0.10 - Binding to the OS level Midi services (fork of system-midi).  http://hackage.haskell.org/package/hamid-0.10 (HansHoglund)
11:56:12 <tabemann> *over the place*
11:56:45 <Nik05> Botje haha i have a 1GB stack, still get overflow :P
11:57:01 <tabemann> I do wish that the implementor of OpenGLRaw had just gone and, say, used type GLfloat = Float and like
11:57:25 <ChongLi> well, they need to be able to change the representation
11:57:38 <ChongLi> in case the standard changes
11:57:48 <Nik05> something is going wrong.... How do i debug a haskell program? :S
11:57:57 <geekosaur> if it's a raw interface to system libraries it has to be CFloat, I think?
11:58:35 <ChongLi> another weird one is glVertexAttribPointer and friends
11:58:54 <acube> Nik05: if you have some simple functions, you can try to use GHCi and check what function is wrong
11:59:15 <monochrom> "how to debug" is a broad question and the subject of a thick book
11:59:17 <ChongLi> its last argument is a pointer to an offset in the buffer
11:59:22 <acube> Nik05: There is also Debug.Trace, which allows you to do printf-style debugging (tracing messages with values you want to know)
11:59:27 <monochrom> not going to type up that book in IRC
11:59:31 <enigmuriatic1> what's the problem if is successfully import Database.HDBC.sqlite3 but i'm told that GHCi "failed to load interface" when I try to use anything in it?
11:59:43 <ChongLi> which you typically build by creating a nullPtr and then offsetting with plusPtr
12:00:01 <ChongLi> it's really strange, why not just use a GLuint?
12:00:16 <tabemann> probably C OpenGL does something similar
12:00:21 <acube> Nik05: And there is a bit low-level debugging support in ghci, using :break and :step (see help for more details)
12:00:52 <acube> enigmuriatic1: Are you importing that module qualified or unqualified?
12:01:04 * hackagebot reenact 0.8 - A reimplementation of the Reactive library.  http://hackage.haskell.org/package/reenact-0.8 (HansHoglund)
12:01:06 <enigmuriatic1> acube, qualified
12:01:10 <acube> enigmuriatic1: and are you using the functions from the module qualified or unqualied?
12:01:11 <monochrom> if anything, I would rather write the book on "how to write a correct program"
12:01:53 <ChongLi> yeah but the examples I've seen in C just pass in an int
12:02:05 <enigmuriatic1> ohhh right hold on
12:02:21 <ChongLi> which OpenGL casts to a (void *) anyway
12:02:40 <enigmuriatic1> acube, qualified
12:02:52 <enigmuriatic1> tried a different syntax but still getting the error
12:03:42 <tabemann> probably a combination of iffy API design on OpenGL's part and OpenGLRaw trying to be as close to the C OpenGL API as humanly possible
12:03:47 <acube> and your prefix is right, so you don't have a typo? I usually get that error when doing something like import qualified Data.ByteString as B; and then trying to use BS.write for example
12:03:56 <ChongLi> tabemann: yeah
12:05:07 <Nik05> ok thanks guys
12:05:21 <enigmuriatic1> nope acube, syntax is right
12:06:37 <acube> enigmuriatic1: Maybe you can paste what exactly you typed and what error you got on hpaste.org?
12:06:48 <ChongLi> tabemann: what are you using for loading textures?
12:07:04 <ChongLi> I'm investigating repa-devil at the moment
12:07:14 <enigmuriatic1> http://hpaste.org/88931
12:08:45 <tabemann> I was originally planning on reading textures with SDL-Image
12:09:07 <acube> enigmuriatic1: looking at http://hackage.haskell.org/packages/archive/HDBC-sqlite3/2.3.3.0/doc/html/Database-HDBC-Sqlite3.html, there is no run function in that module
12:10:00 <enigmuriatic1> ah shoot i'm using Real World Haskell, he presented it like it was universal
12:10:08 <ChongLi> SDL just seems to put me off
12:10:14 <ChongLi> I'm using GLFW
12:10:24 <enigmuriatic1> oh i need another module with it
12:10:41 <ChongLi> it's really nice and simple
12:10:54 <tabemann> I'm used to working with SDL, as I worked for a while in the past with it under OCaml
12:11:01 <ChongLi> ahh
12:11:47 <heath> https://gist.github.com/heath/5680323
12:12:11 <heath> curious what this --package-db option is, not seeing it as an option for cabal-dev
12:12:46 <enigmuriatic1> what should i use along with that HDBC driver?
12:13:17 <Cale> heath: cabal install --help  describes it
12:14:26 <heath> Cale: is that an option for cabal-dev?
12:14:44 <acube> enigmuriatic1: The hackage docs say you have to import Database.HDBC
12:14:52 <enigmuriatic1> ah got it
12:15:34 <dcoutts_> heath: cabal-dev is mostly a wrapper that calls cabal with the appropriate --prefix, --package-db flags
12:15:41 <eikke> Whenever I start to think GHC is slow, I run a build of some mid-size C++ project and feel much better.
12:16:04 * hackagebot var 0.1.0.0 - Mutable variables and tuples  http://hackage.haskell.org/package/var-0.1.0.0 (AndySonnenburg)
12:17:15 <mustermark> Anyone in here have a decent understanding of YAMPA and arrows?
12:18:17 <heath> https://github.com/lightquake/sandboxer/blob/master/sandboxer.sh#L40
12:18:38 <heath> that's where sandboxer.sh uses the GHC_PACKAGE_PATH variable, tips on getting on getting around this?
12:18:53 <acube> mustermark: I don't know YAMPA, but I've used HXT for a very simple project which uses arrows too
12:19:40 <ChongLi> tabemann: also, why is there a GLboolean type for a bunch of these functions and yet gl_TRUE and gl_FALSE are GLenums?
12:20:01 <tabemann> ChongLi: was wondering about that
12:20:35 <applicative> yipe! proc notation!
12:20:43 <Cale> mustermark: I have a reasonably decent understanding of it, but I'm somewhat busy right at the moment. Do you have a specific question?
12:20:48 <mustermark> acube: awesome! can you help me figure out how resolving the variable v works in this recursive proc: https://gist.github.com/shargoj/7b016293950ce971c1f7
12:21:00 <mustermark> (from the YAMPA arcade paper)
12:21:20 <ChongLi> tabemann: hmmm
12:21:27 <Cale> mustermark: It's in a rec, so it uses the ArrowLoop instance to bind v throughout that recursive block
12:21:30 <applicative> what's going wrong with it mustermark
12:21:32 <ChongLi> I can't seem to figure out how to generate and bind a sampler
12:21:37 <ChongLi> the functions are missing?
12:21:45 <tabemann> I ended up making myself a function convertBoolean = (==) (fromIntegral 1)
12:21:58 <Cale> It's bound by the line with the integral on it.
12:22:11 <Cale> er, well, there's more than one, but  v <- integral -< clampAcc v ad
12:23:51 <mustermark> The first time through, it fair to assume the signal is zero?
12:23:58 <ChongLi> hmm
12:24:06 <ChongLi> they seem to have been introduced in 3.3
12:24:47 <tabemann> OpenGLRaw supports up to OpenGL 3.2
12:24:50 <Cale> mustermark: Yeah, I believe that's how integral behaves
12:25:00 <ChongLi> huh
12:25:32 <ChongLi> guess I'll have to figure out how to bind a sampler in 3.2
12:25:37 <Cale> Yeah, it starts off with zeroVector
12:25:41 <ChongLi> since apparently the API is completely different
12:25:58 <tabemann> what I find weird is that OpenGLRaw treats GLboolean values as *numbers*
12:26:04 * hackagebot language-ecmascript 0.14 - JavaScript analysis tools  http://hackage.haskell.org/package/language-ecmascript-0.14 (AndreyChudnov)
12:26:07 <mustermark> Cale: neat, thanks!
12:26:13 <Botje> ChongLi: in normal openGL you typically pass in the number of the texture unit for a sampler
12:26:18 <ChongLi> that's how all the values are represented
12:26:31 <tabemann> brb
12:26:40 <heath> https://github.com/lightquake/sandboxer/issues/2 :: so i went ahead and opened an issue
12:26:49 <heath> ideas for getting around this?
12:26:57 <ChongLi> Botje: ah, ok
12:27:24 <ChongLi> so what are the enums like gl_SAMPLER_2D for?
12:28:06 <Botje> future expansion, maybe?
12:28:35 <Botje> first hit on google says it can be returned from a glGetActiveUniform call
12:28:40 <Botje> as the type of a given uniform slot.
12:28:49 <ChongLi> ahhhh
12:28:55 <yogert> hey, how would I got about getting Parsec to correctly match this? http://hpaste.org/88934
12:29:47 <yogert> whoops
12:30:04 <Cale> heath: What does sandboxer actually do?
12:30:07 <yogert> the last error message should be a "!!" not "??"
12:30:24 <Cale> heath: Have you tried just using cabal-dev directly?
12:30:25 <Botje> yogert: your individual parsers aren't allowed to consume input.
12:30:29 <Botje> (and fail afterwards)
12:31:00 <Botje> yogert: the quick fix is to map (try . string), but you're better off refactoring that parser if you can
12:31:57 <yogert> how would you recommend refactoring it? Is what i've done bad practice?
12:33:19 <Botje> char '!' >> (char '!' >> return () <!> return ()) <!> char '?' >> (like the other branch)
12:33:35 <Botje> hmm.
12:33:55 <Botje> anyOf "?!" >> (anyOf "?!" >> return () <|> return ())
12:34:11 <Botje> and you can probably simplify the second using optional, but don't want to look at docs right now :)
12:35:00 <enigmuriatic1> http://hpaste.org/88935    why doesn
12:35:15 <enigmuriatic1> 't the compiler recognize "Just" as a type contructor?
12:35:47 <enigmuriatic1> it's telling me that the patterns have different numbers of arguments
12:35:58 <Botje> put () around Just x
12:36:54 <enigmuriatic1> ah thanks Botje
12:37:09 <enigmuriatic1> is there any reason I should know of why that's necessary?
12:37:50 <yogert> botje: ok, so just incrementally try parsing the input? Your suggestion might still consume input when failing though, right? I 'd have to throw some trys in there too, no?
12:38:24 <Botje> yogert: it will not fail after consuming input.
12:38:54 <Botje> enigmuriatic1: it solves ambiguities.
12:45:47 <enigmuriatic1> is there any way to convert all the fields of a type to a list?
12:46:06 <anthezium> hello
12:46:08 <pqmodn> enigmuriatic1: lists must be homogenous, each element must have the same type
12:46:33 <anthezium> what are you trying to do?
12:46:34 <arkeet> and if they are, you'd still have to do it manually
12:46:54 <arkeet> well, not necessarily, I suppose.
12:47:14 <anthezium> yeah if it were traversable you could do it
12:47:25 <enigmuriatic1> i'm trying to take a list of a custom type (which has about eight fields) and return a list of lists of Strings that I can use as parameters in a SQL query
12:48:04 <Nik05> Botje still here?
12:48:06 <enigmuriatic1> i could write it manually, but doing that for eleven fields is a little much (it's eleven, not eight)
12:48:07 <arkeet> anthezium: or with biplate
12:48:10 <Botje> Nik05: yes
12:48:35 <arkeet> or write your own traversal
12:48:37 <enigmuriatic1> i could use show and then words, i suppose
12:48:44 <arkeet> (lens to the rescue?)
12:48:49 <Nik05> Ok :) Didnt my function use tail-recursion? So how could it ever run out of stack?
12:48:54 <arkeet> enigmuriatic1: that's the worst. don't do it. :P
12:49:28 <enigmuriatic1> arkeet, what should i use?
12:49:54 <Nik05> oh and how do i make two "temporary" variables?
12:49:58 <pqmodn> enigmuriatic1: instead of having 11 fields, could your constructor have one list field?
12:50:04 <Nik05> let x = ..., y = ... in ?
12:50:10 <arkeet> pqmodn: that doesn't sound so safe.
12:50:21 <arkeet> Nik05: let {x = ...; y = ...} in
12:50:22 <enigmuriatic1> i don't think so, that would break how the JSON works, pqmodn
12:50:27 <tsinnema> edwardk, w.r.t. the question i asked earlier on managing values of ADTs in a database context, where you mentioned some code relating to that -- this relates to why i was asking the question, particularly in a scenario where we know of some dependencies between components of our composite type: https://gist.github.com/tsinnema/5680368/raw/2b1846ee460d54c0df338010903d55e84c4c8729/gistfile1.txt
12:50:31 <pqmodn> enigmuriatic1: i see
12:50:31 <arkeet> braces might be optional depending on things.
12:50:35 <enigmuriatic1> well, maybe, but i didn't understand the JSON code too well to begin with
12:50:44 <Nik05> thanks arkeet :)
12:51:19 <arnsholt> enigmuriatic1: I have a function which takes a ten-element list and is essentially "foo a:b:c:d:e:f:g:h:i:j:[] = {- stuff -}", except with better variable names. It's a bit ugly, but nothing major I think
12:51:38 <arkeet> arnsholt: you can use [a,b,c] syntax in patterns too
12:51:39 <Botje> Nik05: let foo = ...\n bar = ... in ...
12:52:07 <Botje> Nik05: the bar has to be aligned with foo, the in (or the stuff after it) can go on a new line
12:52:21 <arnsholt> arkeet: Oh, I didn't know that. Thanks!
12:52:26 <arnsholt> That'll clean it up a bit
12:52:46 <Nik05> ok thanks Botje
12:53:07 <tsinnema> ^ edwardk: just FYI and in the odd case that what you're doing might deal with something similar
12:54:00 <enigmuriatic1> i think i might use a custom show unless there's another option
12:54:06 <enigmuriatic1> does anyone have any suggestions?
12:54:58 <enigmuriatic1> http://hackage.haskell.org/packages/archive/lenses/0.1.6/doc/html/Data-Lenses-Template.html
12:55:10 <enigmuriatic1> could that help? i'm having a little trouble understanding it but it looks promising
12:58:02 <ezyang> If a type parameter 'a' appears only positively in some type constructor, is that type constructor guaranteed to have a functor instance?
12:58:15 <generalmajor> Miscarriage of justice: § 227 first penalty option, criminal act. Norway <<for in word or action have threatened with a criminal action that may result in higher penalty than 6 months of prison..>> @ http://www.chat.no
12:58:27 <generalmajor> § 444 criminal procedure act. Norway <<Unless anything else are as a result of section 446, an indicted have the right to compensation from the norwegian state for economical losses that the prosecution has inflicted him @ http://www.chat.no
12:58:37 --- mode: ChanServ set +o shachaf
12:58:41 <generalmajor> c) in concern that he has been arrested or imprisoned against the european convention of human rights article 5 or UN covenant on civil and political rights article 9.>> @ http://www.chat.no
12:58:43 --- mode: shachaf set +b *!*generalma@185.16.123.*
12:58:43 --- kick: generalmajor was kicked by shachaf (generalmajor)
12:58:58 --- mode: shachaf set -o shachaf
12:59:02 <danharaj> One of these days I'm going to stumble on a GHC bug before it gets reported and fixed in Head :\
12:59:02 <lambdabot> danharaj: You have 1 new message. '/msg lambdabot @messages' to read it.
12:59:16 <shachaf> ezyang: Are you just talking about regular ADTs?
12:59:23 <shachaf> I.e. sums, products, functions.
12:59:42 <byorgey> ezyang: for regular ADTs, yes.
12:59:49 <ezyang> shachaf: What is a non-regular ADT?
12:59:54 <byorgey> for GADTs or anything involving type functions, no.
13:00:00 <shachaf> What byorgey said.
13:00:05 <ezyang> ...hm! That's interesting.
13:00:25 <Nik05> Botje im keep getting a parse error on input `foo`
13:00:38 <shachaf> For example "Is x" is certainly not a functor.
13:00:42 <merijn> Nik05: Are you using tabs?
13:00:47 <danharaj> what are we talking about?
13:00:49 <shachaf> ezyang: Oh, and rank-2 types.
13:00:49 <ezyang> (remind me how Is is defined?)
13:00:54 <danharaj> I bet there's a category from which "Is x" is a functor!
13:00:57 <shachaf> data Is a b where Refl :: Is a a
13:01:12 <shachaf> By "functor" I think we meant "Functor". :-)
13:01:19 <jpcooper> hello
13:01:24 <Nik05> no merijn
13:01:27 <byorgey> danharaj: sure, the discrete category of Haskell types =P
13:01:40 <danharaj> shachaf: Let us throw off the chains of * supremacy and equalize all categories and their "Functor"s :P
13:01:42 <Peaker> Yuck, test-framework package makes adding timeouts to tests pretty ugly... An Options record to override a field in, and then apply that to a test, rather than simple combinators
13:01:53 <shachaf> ezyang: You can define type equality with rank-2 types too, -- newtype Is a b = Is (forall p. p a -> p b) -- and that's also not a Functor.
13:02:04 <merijn> Nik05: Did you paste the code + error on hpaste?
13:02:15 <ezyang> Huh. I wonder why things like type equality cause problems.
13:02:16 <Nik05> merijn hpaste doesnt give the error :S
13:02:23 <jpcooper> could someone direct me to some libraries to use in very efficiently sorting a CSV on a given column, and also grouping by a giving column and applying an operation on each group?
13:02:28 <Nik05> or doesnt hpaste compile it?
13:02:33 <shachaf> ezyang: Well, because "(a -> b) -> Is x a -> Is x b" doesn't make sense.
13:02:35 <monochrom> doesn't
13:02:39 <merijn> Nik05: I meant copy + paste the error together with your code. hpaste doesn't compile code
13:03:14 <shachaf> If you add things like subtyping you can also get a similar issue, I assume.
13:03:19 <byorgey> shachaf: if a data type can include some constraints on its type arguments, then you can't guarantee to preserve those constraints given only a function (a -> b)
13:03:33 <Nik05> http://hpaste.org/88936 merijn there it is
13:03:41 <byorgey> er, s/shachaf/ezyang/
13:04:07 <ezyang> Then I echo  danharaj's intuition that there is a category where Is x is a functor
13:04:19 <ezyang> It must be something like morphisms which preserve the constraints
13:04:42 <shachaf> But if that constraint is equality with a particular type then it sounds like a kind of boring category.
13:04:49 <byorgey> jpcooper: sclv_ had a library that could maybe do stuff like that? I think?
13:04:54 <byorgey> I can't remember what it was called though
13:05:02 <ezyang> Yes, that sounds like the discrete category. But it doesn't have to be that boring
13:05:18 <danharaj> Maybe there is an interesting 2-category structure for equality.
13:05:19 <shachaf> Right. You can build other things out of type equality.
13:05:31 <danharaj> Perhaps a fibration of some sort.
13:05:32 <byorgey> if the constraint is equality with a particular type, then you have to have the discrete category.
13:05:38 <byorgey> but there are more interesting sorts of constraints.
13:05:43 <shachaf> (Although GADT-type-equality is stronger than rank2-type-equality! In GHC's implementation, anyway.)
13:05:59 <jpcooper> sclv_: any suggestions?
13:06:26 <byorgey> for example, consider  Data Foo a = Foo (Iso Int a)
13:06:48 <byorgey> where Iso Int a represents an isomorphism between Int and a
13:07:05 <byorgey> this is a functor, but only in the category where morphisms are isomorphisms instead of normal functions
13:07:27 <Nik05> merijn no watch wrong? :)
13:07:27 <ezyang> that's right!
13:07:39 <fizbin> If I have a typeclass T that looks class T where { parseConstant :: Int, … } and I want to define some function with type (T a, T b) => String -> (a, b), within that function how can I access parseConstant and how do I specify whether I want the one for type a or for type b ?
13:07:55 <merijn> Nik05: Oh, sorry, my IRC client only highlights lines starting with my name, I'll take a look
13:07:59 <byorgey> this sort of thing comes up when thinking about species, or more generally labelled structures
13:08:25 <merijn> Nik05: If you want to do multiple definitions in a let they all need to be indented equally far
13:08:46 <Nik05> merijn didnt i do that?
13:08:47 <merijn> Nik05: i.e. make sure that the 'e' of "ex" is directly below the 'i' of "inew"
13:09:11 <Nik05> oh the i of inew
13:09:13 <Nik05> oops
13:09:26 <merijn> Nik05: It counts the indentation of the first keyword after let as the new indent
13:09:56 <merijn> Nik05: See: https://en.wikibooks.org/wiki/Haskell/Indentation
13:10:10 <danharaj> Does anyone know who I can ask about future DataKinds development?
13:10:13 <supki> fizbin: I don't think you can have  parseConstant :: Int ?
13:10:34 <supki> fizbin: you can have something like parseConstance :: Tagged a Int though
13:10:40 <byorgey> danharaj: you can ask Richard Eisenberg (eir) but he is rarely on IRC
13:10:45 <byorgey> danharaj: but you can send him an email
13:11:25 <danharaj> byorgey: thanks. I'll shoot him an email. In particular I want to know if the proposal to collapse sorts and kinds is moving along. Kinds would be a lot cooler if the promotion constraints were looser!
13:11:26 <fizbin> supki: Hrm. Okay, I can introduce data TaggedInt a = TaggedInt Int and then I see how I can do it.
13:11:41 <fizbin> Seems like a silly workaround.
13:11:47 <anthezium> hey y'all, i have a question about cabal, about to drop on hpaste
13:11:49 <byorgey> danharaj: it is moving along.  It may already be merged into HEAD.  Richard has been working on the implementation.
13:11:49 <Nik05> Botje i just added -Wall ... getting some warnings, oops
13:12:00 <byorgey> danharaj: ask him for precise details.
13:12:06 <danharaj> byorgey: oh, that's exciting.
13:12:12 <byorgey> danharaj: indeed!
13:12:27 <danharaj> byorgey: Now if only constraint kinds could be useful.... :P
13:12:29 <supki> fizbin: or you can use Tagged from tagged package :)
13:12:34 <anthezium> http://hpaste.org/88942
13:12:36 <byorgey> danharaj: they're not?
13:12:40 <arkeet> fizbin: http://hackage.haskell.org/packages/archive/tagged/0.6/doc/html/Data-Tagged.html
13:12:52 <danharaj> byorgey: I haven't found use for them and I have tried.
13:12:59 <byorgey> hehe
13:13:04 * ezyang wonders if all lambda calculus implementers should collapse their terms/types/kinds, even if they're not planning on needing dependence 
13:13:19 <danharaj> byorgey: Sure, they have a kind now, but there's no structure on them, like implication.
13:13:28 <byorgey> danharaj: true.
13:13:49 <byorgey> ezyang: PTS's FTW!
13:13:51 <fizbin> It seems a bit silly though since a typeclass should be equivalent to just passing an extra parameter to the function giving the instance implementation.
13:14:40 <ezyang> Haha, Wikipedia, "This article or section appears to contradict itself."
13:14:44 <ezyang> (on PTS)
13:14:56 <danharaj> byorgey: I guess there might be some clever things you could do with GADTs and constraint types? Like enumerating capabilities at runtime?
13:15:41 <danharaj> But it all boils down to glorified dictionary passing :P
13:18:04 <ezyang> Hm. It seems very easy to do a PTS wrong
13:18:11 <FreeFull> Since there is no good websocket client library for haskell
13:18:23 <FreeFull> I might write one
13:18:34 <FreeFull> I never wrote a library before though
13:18:37 <geekosaur> there's a thankless task
13:18:40 <Nik05> wow code is smaller now :p
13:18:44 <geekosaur> the spec is still changing rapidly
13:18:52 <Taneb> Recommended library for cryptographic hash for storing passwords?
13:19:11 <merijn> Taneb: NaCl
13:19:21 <FreeFull> websockets is the only library that supports client-side stuff at all, and it's out of date so it doesn't work for what I'm trying to connect to
13:19:33 <merijn> Taneb: Recommended lib for anything containing the word "crypto"
13:19:52 <merijn> I believe thoughtpolice has haskell bindings on github, they seem to have disappeared from hackage, though
13:20:13 <aristid> Taneb: use bcrypt
13:20:16 <merijn> Taneb: Alternatively scrypt
13:20:22 <thoughtpolice> they did not disappear. they have not been uploaded at all. the 'cabal install salt' on the homepage was pre-emptive :P
13:20:38 <merijn> aristid: scrypt is a better alternative to bcrypt
13:20:55 <aristid> merijn: what makes it better?
13:20:58 <merijn> In terms of being future-proof, that is
13:21:04 <sipa> memory-hardness
13:21:05 * hackagebot sundown 0.5.3 - Bindings to the sundown markdown library  http://hackage.haskell.org/package/sundown-0.5.3 (FrancescoMazzoli)
13:21:07 <aristid> ah
13:21:11 <thoughtpolice> it's memory-hard, for one. what that basically means is it uses a lot of memory when it computes stuff
13:21:15 <aristid> well, bcrypt is still not a bad choice i think :)
13:21:16 <merijn> aristid: bcrypt only has tunable computational hardness, scrypt is memory hard too
13:21:29 <merijn> Which means scrypt is almost impossible to run on GPGPU
13:21:32 <ChongLi> Botje: yeah I can't get this texture to work
13:21:36 <thoughtpolice> this is to make it *more* impossible to do things like construct ASIC rigs, because the memory requirements would make it infeasible
13:21:38 <merijn> aristid: It's the second best, yeah
13:21:44 <sipa> merijn: depends on which settings :)
13:21:50 <ChongLi> I don't know what to set my sampler uniform to
13:21:56 <ChongLi> since there are no sampler objects!
13:22:18 <thoughtpolice> really, PBKDF2/bcrypt/scrypt are all fine, just make sure in the case of PBKDF2 you choose a nice, high work factor (i can't remember what the typical suggestions are these days)
13:22:27 <Botje> ChongLi: can you show code?
13:22:45 <thoughtpolice> my general approach is: do you want to be safe from humans? PBKDF2 is probably OK. safe from the NSA? bcrypt is probably better. aliens? definitely scrypt
13:22:46 <ChongLi> Botje: just a sec
13:22:50 <aristid> just play with the work factor until it needs a second? :D
13:23:04 <merijn> thoughtpolice: When are you going to throw the bindings up on hackage? Also, I see you decided against shipping the NaCl source with the bindings?
13:23:15 <thoughtpolice> aristid: yeah, that's what i normally do.
13:23:25 <thoughtpolice> and if you use scrypt, don't forget that exponential backoff in the login or whatever :P
13:23:46 <aristid> exponential backoff in a hash algorithm? huh?
13:23:55 <ChongLi> hmmm
13:23:57 <thoughtpolice> merijn: i need to refactor like 2 more things. if i actually carved off a few hours this weekend it could be done. it's really that small refactoring and then the 'boring' stuff like tidying up docs, etc
13:24:14 <Nik05> help im lost in indentation :P
13:24:15 <thoughtpolice> aristid: exponential backoff for failed logins. otherwise someone can just send 50 login requests to your server at once and scrypt will eat all your RAM
13:24:19 <ChongLi> this is a big mess :(
13:24:22 <thoughtpolice> the default scrypt parameters use about 16MB, IIRC
13:24:28 <aristid> thoughtpolice: <devil in the ear>you'd rather do other things this weekend though
13:24:42 <aristid> thoughtpolice: oh, scrypt as DOS :D
13:24:48 <thoughtpolice> merijn: also, no. the source code for nacl is still shipped with the package.
13:25:02 <thoughtpolice> i am not sure if i want to switch to libsodium. i am not even sure if it's worth the effort
13:25:07 <thoughtpolice> although presumably people will probably want that
13:25:18 <aristid> thoughtpolice: sounds like bcrypt is the safer choice for server-based logins then
13:25:49 <ChongLi> Botje: http://hpaste.org/88944
13:25:57 <thoughtpolice> bcrypt is always a safe bet, least of all because it exists just about everywhere
13:26:22 <Botje> ChongLi: and your shader prorgam itself?
13:26:33 <aristid> thoughtpolice: how do i invoke bcrypt actually? :D
13:26:38 <ChongLi> http://hpaste.org/88945
13:26:52 <ChongLi> that's the fragment shader
13:27:11 <Botje> ChongLi: line 9 of your program is wrong
13:27:23 <Botje> you should set the sampler uniform to the id of the _sampler_
13:27:31 <Botje> also called texture unit
13:27:34 <thoughtpolice> aristid: it's so easy even an AI could do it! http://hackage.haskell.org/packages/archive/bcrypt/0.0.4/doc/html/Crypto-BCrypt.html
13:27:42 <thoughtpolice> the scrypt bindings have a very nice interface like that too.
13:27:47 <Botje> and the default texture unit is 0, which happens to be the default value for sampler values
13:27:53 <ChongLi> Botje: oh
13:28:28 <ChongLi> so I changed it to 0
13:28:32 <ChongLi> no result
13:28:34 <aristid> thoughtpolice: an AI... or even me!
13:28:43 <Botje> ChongLi: your glVertexAttribPointer call is suspect, as well.
13:29:33 <thoughtpolice> merijn: i suspect you want to use my bindings, yes? i've at least seen you recommend them :P
13:29:36 <ChongLi> Botje: for the texture coordinates?
13:30:17 <merijn> thoughtpolice: Well, NaCl is high on my list I expect to need in the not so distant future and I can't be arsed to write my own bindings :p
13:30:26 <thoughtpolice> merijn: i've been pestered by a few people over time to finally release it, and some people are actually using it (2 people are actively using it i'm aware of) so i should really just get it over with.
13:30:36 <merijn> thoughtpolice: So I think it prudent to make you hurry up before I need them :p
13:30:56 <Botje> ChongLi: oh wait, I see now how you've laid out your buffers
13:30:58 <Botje> nevermind :)
13:31:04 <merijn> Mostly I'm recommending NaCl, I just don't think there's any other existing bindings for haskell yet? :p
13:31:06 <Nik05> http://hpaste.org/88947 <- new program with the warnings
13:31:12 <antoineB> hello, is haskell template comparable to lisp macro?
13:31:17 <ChongLi> Botje: yeah, it's a bloody mess
13:31:27 <Botje> I'm used to seeing intermixed data in buffers.
13:31:48 <thoughtpolice> merijn: it's a great library. i think there was someone who did bind crypto_box at one point, but by then i had already had 90% of the API covered :P
13:31:56 <Botje> ChongLi: did you verify your vertex shader as well?
13:32:10 <ChongLi> my vertex shader works if I use a solid color
13:32:12 <ChongLi> let me see
13:32:23 <thoughtpolice> it really just needs docs and examples more than anything, i really dislike giving people libraries without stuff they can look at for examples, and read
13:32:40 <merijn> antoineB: Kinda, -ish I think?
13:32:57 <ChongLi> Botje: yeah if I switch to a solid color it renders fine
13:33:08 <mekeor> doesn't hayoo have a firefox-integration (as search-engine)?
13:33:13 <merijn> Speaking of docs...is there a Haddock tutorial somewhere? (Probably yes, I admit I haven't looked yet :p)
13:33:24 <ChongLi> it's just a 50x50 pixel square :)
13:33:30 <Botje> okay
13:33:45 <Botje> ChongLi: you also don't enable the texmap attribute
13:33:52 <ChongLi> oh
13:34:00 <ChongLi> ohhhhh
13:34:20 <tabemann> ChongLi: do you know if there are any good examples of usable shaders out there for things like phong shading, because I'm not sure where to start to, say, implement my own phong shader
13:34:27 <merijn> Nik05: Those are just warnings, not errors
13:34:32 <Botje> ChongLi: i'm also reasonably sure your call to glGenBuffers is horribly wrong
13:35:00 <Nik05> merijn no bad warnings?
13:35:01 <Botje> you want one buffer, not (size verts) buffers
13:35:11 <merijn> Nik05: Its just saying that without type signatures it's not sure which type you wanted, so it's defaulting your numeric constants to Integer
13:35:12 <Botje> but apart from some memory wastage, that won't hurt
13:35:20 <romanandreg> hey, is anyone playing with cabal sandbox that can enlightme a bit with an issue I'm having?
13:35:26 <merijn> Nik05: If you write down type signatures for your functions I'm pretty sure they all disappear
13:35:27 <romanandreg> specially with c dependencies on a project
13:35:34 <ChongLi> Botje: oh, ok :)
13:35:37 <ChongLi> one buffer it is
13:35:40 <romanandreg> on a library I mean, not a project
13:35:42 <ChongLi> but not rendering
13:35:58 <ChongLi> I'm beginning to suspect it's something wrong with how I load the image
13:36:29 <dcoutts_> romanandreg: what makes you think it's related to sandboxing?
13:36:58 <ChongLi> Botje: reload 88944
13:37:02 <ChongLi> the main source file
13:37:14 <Ralith> tabemann: most textbooks should have one
13:37:17 <ChongLi> I added the image load function to it
13:37:18 <romanandreg> dcoutts_: master branch of cabal, I'm trying to install HsOpenSSL through a sandbox, can't find cabal_macros.h file on cbits/HsOpenSSL.h
13:37:25 <ChongLi> I guess that still doesn't help
13:37:27 <romanandreg> dcoutts_: when installing without a sandbox, works perfectly
13:37:42 <Botje> ChongLi: you still have "fromIntegral tex" on line 16
13:38:04 <Botje> or did you change that but didn't update the paste?
13:38:09 <augur> so can i point out how cool it is that the monad laws just emerge as a consequence of lax modality's local soundness and completeness rules?
13:38:16 <augur> cause thats pretty damn cool
13:38:36 <tabemann> Ralith: unfortunately my OpenGL text I have is on OpenGL 1.4
13:38:43 <Ralith> burn it, get a new one
13:39:00 <ChongLi> Botje: I re-pasted the whole thing
13:39:01 <ChongLi> reload :)
13:39:05 <Ralith> augur: what are those?
13:39:28 <augur> Ralith: the local ~ and ~ rules? they're just beta and eta for the lax modality
13:39:29 <ChongLi> yeah, and line 6 is very bad :(
13:39:40 <ChongLi> but it doesn't give a pattern match failure, so whatever :)
13:40:01 <tabemann> Ralith: unfortunately I'm trying to not spend money right now, as I'm out of a job at the present
13:40:25 <ChongLi> opengl requires so much damn ceremony
13:40:31 <ChongLi> makes it so easy to screw up
13:40:41 <Ralith> tabemann: there are free ones
13:40:43 <romanandreg> dcoutts_: Gist for + info https://gist.github.com/roman/5681021
13:40:45 <dcoutts_> romanandreg: using same version of cabal-install in both cases?
13:40:53 <augur> Ralith: basically, given the inference rules for the lax modality, there are induced beta and eta rules (induced as in essentially fully determined) which get you the monad laws
13:41:00 <romanandreg> yes, it was
13:41:04 <tabemann> Ralith: any online?
13:41:09 <Ralith> augur: let me rephrase: I have no idea what you are talking about, where can I go to learn more?
13:41:27 <augur> Ralith: oplss 2012, pfenning's proof theory foundations lecture videos :)
13:41:32 <augur> http://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html
13:41:38 <Ralith> tabemann: I understand that http://arcsynthesis.org/gltut/ is good
13:41:53 <Ralith> augur: cool, thanks
13:42:07 <dcoutts_> romanandreg: of course cbits/HsOpenSSL.h should not be trying to #include that file in the first place, because it's hard coding the dist dir location
13:42:21 <tabemann> oh I think I've seen that one
13:42:29 <augur> Ralith: theres this notion of "acceptable" logical connective that stems from this idea called local soundness and completeness
13:42:32 <dcoutts_> romanandreg: indeed that might be the issue, I'm not sure if the sandbox changes the dist dir
13:42:38 <Botje> ChongLi: and your vertex shader nicely passes on the texture coordinates?
13:42:48 <Botje> (as that is not used in solid colors)
13:42:53 <dcoutts_> romanandreg: should be easy to check, does dist exist in that dir?
13:43:09 <augur> Ralith: basically, an acceptable connective can't let you conclude more than you started with, but it can let you conclude everything you started with.
13:43:43 <dcoutts_> romanandreg: oh you're installing a tarball so you can't check
13:44:03 <augur> Ralith: so it's not too strong nor too weak. beta and eta rules are the rules that you show this with. so beta reduction and eta expansion for functions, for instance, shows that -> is an acceptable connective.
13:44:16 <dcoutts_> romanandreg: ah yes there we go, dist/dist-sandbox-dc2d92ee
13:44:45 <dcoutts_> romanandreg: so the bug is in the HsOpenSSL package because it's hard coding ../dist/build/autogen/cabal_macros.h
13:45:02 <dcoutts_> romanandreg: but the location of the dist dir is not known to the package
13:45:17 <augur> Ralith: in general, the beta and eta rules seem to be almost entirely determined by the intro and elim rules of the connective. what this means for monads is that, type theoretically, the monad laws come about as an essential, inescapable fact given the way the lax modality is used to reason
13:45:27 <romanandreg> dcoutts_: ohh…
13:45:42 <romanandreg> dcoutts_: so basically hack the HsOpenSSL project to not rely on the fixed path of dist
13:45:45 <augur> Ralith: not that the laws HAVE to hold, but that if you can reason in that way, the laws DO hold, end of story.
13:45:47 <pmade> After getting runtime stats for an executable I'm surprised that the allocation rate is around 2GB/sec but max memory is 23MB.  The allocation rate seems insane, am I not understanding this correctly?
13:45:49 <dcoutts_> romanandreg: yes
13:45:56 <romanandreg> dcoutts_: but rather find it out in the sandbox somehow
13:46:12 <dcoutts_> romanandreg: in principle it is currently impossible
13:46:17 <ChongLi> Botje: http://hpaste.org/88954
13:46:34 <Kev112> I am trying to do something with list comprehensions to find all values of a that are in a certain range and are divisible by all elements in list b.  My code looks like this: [a | a <- [1..99], b <- [2,13,45,79], mod a b == 0]. Can anyone tell me what to do here?
13:46:43 <ChongLi> is that what I want?
13:46:50 <dcoutts_> romanandreg: but it sounds like it'd be a useful feature to include the dist/build/autogen dir in the -I search list
13:46:56 <dcoutts_> romanandreg: for .c files I mean
13:47:09 <dcoutts_> romanandreg: would you like to file a ticket? it should be an easy fix
13:48:32 <romanandreg> dcoutts_: yes, should I post the ticket in which github project? cabal or HsOpenSSL? or both?
13:49:17 <Kev112> just wondering if anyone can answer my question from 16:46
13:49:18 <Ralith> augur: I think the missing step is 'what is lax modality'
13:49:37 <augur> Ralith: its just a modality defined by the inference rules he gives.
13:50:04 <augur> its an internalization of the lax judgement, so that "A lax" means "A might be true in some computational sense"
13:50:15 <dcoutts_> romanandreg: oh both actually: for Cabal we want to ask that it build .c files with -I dist/build/autogen/ so that .c files can use the cabal_macros.h file, and for HsOpenSSL you can report that their hack does not work but it would work with that cabal feature
13:50:16 <Ralith> hm, okay
13:50:19 <augur> as opposed to the judgment "A true" which is that A _is_ true
13:50:30 <Ralith> I'll poke around in the source material
13:50:36 <augur> Ralith: so to say M : A true is to say that M just is a proof of A/value of type A
13:50:57 <augur> but to say M : A lax is to say M might get you a proof of A/value of type A or it might not terminate.
13:51:39 <romanandreg> dcoutts_:  can we copy our successfully built HsOpenSSL package from our ~/.cabal folder to the one on the .cabal-sandbox?
13:53:04 <luksow> hey guys, #haskell is the most friendly chan@freenode so I hope that you could help me with not-really-haskell-related problem: I need a native English speaker for grammar & spelling check of my MSc thesis abstract (only 6 sentences) which is about safe concurrent languages (Haskell too). If you could help me, please pm me, thanks in advance...
13:53:33 <Botje> ChongLi: going over it line by line.
13:54:28 <Botje> ChongLi: where does withPtr come from?
13:54:40 <ChongLi> Botje: from another file
13:54:48 <ChongLi> it's really simple
13:55:02 <ChongLi> withPtr fn = M.alloca $ \ptr -> fn ptr >> peek ptr
13:55:12 <JoeyA> > let f :: Int => Int => Int; f a b = a+b in f 2 3
13:55:13 <lambdabot>   Type of kind * used as a constraint
13:55:15 <Botje> okay
13:55:23 <ChongLi> alloca being from Foreign.Marshal
13:55:28 <merijn> JoeyA: Syntax error
13:55:41 <merijn> JoeyA: Types use -> not =>
13:55:53 <JoeyA> I didn't ask my question yet :-)
13:55:59 <JoeyA> GHC 7.6 lets me do that.  Why?
13:56:17 <aristid> JoeyA: can you even use f?
13:56:19 <JoeyA> ghci, with no (explicit) extensions, returns 5 when I do that (using => for function args)
13:56:26 <ChongLi> Botje: is there a way I can just generate some image data to test with?
13:56:46 <tabemann> umm, you shouldn't be using => like that, as => is supposed to be used for marking type classes as in Foo x => x -> x
13:57:02 <shachaf> JoeyA: Looks like a bug.
13:57:08 <Botje> ChongLi: just generate 3 * width * height bytes filled with 0xff
13:57:09 <JoeyA> I agree, but GHC 7.6.2 lets me do it.  Strange.
13:57:17 <ChongLi> ok
13:57:22 <Botje> that's white
13:57:27 <tabemann> GHC allows you to do a lot of things, at least with the right options set
13:57:38 <joelteon> yep works here too
13:57:39 <geekosaur> it probably doesn't do what you think (likely some ConstraintKinds thing)
13:57:54 <shachaf> It doesn't happen in HEAD.
13:58:10 <JoeyA> Thanks for checking
13:58:13 <shachaf> (HEAD from March, anyway.)
13:58:40 <joelteon> let f :: Int => Int => Int; f a b = a + b in f :: Int -> Int -> Int
13:58:41 <joelteon> how weird
13:59:38 <tabemann> this is probably a case of something that, just because the compiler lets you do it, doesn't mean it's a good idea
14:00:40 <ChongLi> Botje: nope
14:00:41 <joelteon> yeah, but why is that
14:00:45 <joelteon> that's like (Int, Int) => Int
14:00:45 <ChongLi> the generated data doesn't work either
14:00:52 <joelteon> and that doesn't make sense, Int isn't a constraint
14:01:04 <JoeyA> http://hpaste.org/88958
14:01:18 <dcoutts_> romanandreg: I'm not sure if that'd work, it might try rebuilding it again
14:01:18 <JoeyA> There's my test program.  Builds with GHC 7.6
14:01:38 <Botje> ChongLi: don't you need to set up clamping etc as well?
14:01:47 <dcoutts_> romanandreg: way to hack it is to add the source to the sandbox
14:01:50 <joelteon> :t let f :: Int => Int => Int; f a b = a + b in f
14:01:51 <lambdabot>     Type of kind * used as a constraint
14:01:51 <lambdabot>     In the type signature for `f': f :: Int => Int => Int
14:01:51 <lambdabot>     In the expression:
14:01:56 <enigmuriatic1> how do you throw an error in a do block?
14:01:57 <Botje> i'm looking through a project of mine and comparing
14:02:14 <JoeyA> enigmuriatic1: What monad are you working in?  Generally, you can use 'fail'
14:02:23 <dcoutts_> romanandreg: then you can edit the cbist/HsOpenssl.c and point it to the right place, if necessary just copy the cabal_macros.h
14:02:38 <JoeyA> Though the error message isn't pretty: fail "hello" produces "user error (hello)" in the IO monad.
14:02:58 <JoeyA> I really wish it wouldn't say "user error".  9/10, it's not the user's fault.
14:03:39 <enigmuriatic1> JoeyA, i'm just using a main = do block. i'm still somewhat new to this, so I don't know what a Monad is
14:04:42 <newsham> enigm: "main :: IO ()"  is in the "IO" monad.  useful to know, but you dont need to know much more about it right now
14:04:58 <JoeyA> enigmuriatic1: ah, okay.  The easy way to throw an error message anywhere is to use 'error'.
14:04:58 <enigmuriatic1> JoeyA, can I use that conditionally, like:     if (myData == "failed") then fail "sorry"    ?
14:05:23 <JoeyA> :t error
14:05:24 <lambdabot> [Char] -> a
14:05:25 <JoeyA> :t fail
14:05:26 <lambdabot> Monad m => String -> m a
14:05:39 <newsham> enigm: if needs a then and an else.  if you want a side effect, then "when" is appropriate.   when (myData == "failed") ...
14:06:15 <Botje> ChongLi: have you tried making your image 64x64 instead of 50x50 ? might be that your hardware doesn't support non-power-of-two textures.
14:06:55 <JoeyA> main = do n <- readLn; when (n /= 42) (fail "wrong"); putStrLn "The number you gave was acceptable."
14:07:20 <Botje> ChongLi: also, make sure to set the minify/magnify texture parameters, and the clamping parameters. although i'm not sure if you need them for opengl 3.2
14:07:21 <ChongLi> Botje: aha
14:07:30 <ChongLi> the texParameters did it
14:07:32 <Botje> my guess is on the size thing, though.
14:07:38 <Botje> oh, really?
14:07:55 <ChongLi> let me test if it was the min/mag filters or the wraps
14:08:12 <Botje> good on me for always being a nice person and copypasting the texture parameters stuff
14:08:15 <JoeyA> enigmuriatic1: you'll need to import Control.Monad to use 'when'
14:08:22 <ChongLi> it's the min/mag filter!
14:08:30 <ChongLi> they have to be set
14:08:48 <ChongLi> the texture_wrap stuff is unnecessary
14:09:10 <newsham> ?src when
14:09:10 <lambdabot> when p s = if p then s else return ()
14:09:16 <ChongLi> blood stains the altar; the white square HAS BEEN RENDERED!
14:10:43 <Botje> hurray! PRAISE BE THE WHITE SQUARE!
14:10:47 <ChongLi> switched it out for my loaded texture
14:10:51 <ChongLi> that works as well
14:11:00 <FreeFull> > do "praise"
14:11:01 <lambdabot>   "praise"
14:11:06 <ChongLi> now to calculate texture coordinates for all the sprites!
14:11:34 <Botje> caclulate ALL THE THINGS!
14:11:42 <ChongLi> these are the sprites I'm trying out:
14:11:45 <ChongLi> http://imgur.com/a/uHx4k
14:11:49 <ChongLi> found them on reddit
14:12:10 <Rembane> Seems legit
14:12:11 <ChongLi> I love nice people that make stuff such as these and release CC
14:12:28 <Botje> nice
14:12:37 <ChongLi> way better than any programmer art I could make :)
14:12:37 <Botje> thought that was a dwarf fortress spritepack, for a second.
14:12:52 <Botje> surely there's a nicer version all packed together?
14:13:11 <ChongLi> I'm not sure actually
14:13:14 <ChongLi> I'll check the website
14:13:40 <Botje> (stupid non-clickable url in the image :P)
14:14:31 <ChongLi> I guess there is no packed version
14:14:41 <ChongLi> it's not a big deal though
14:14:56 <ChongLi> I appreciate that the artist wants to retain his credit and website in the image
14:15:18 <ChongLi> that way anyone who distributes it doesn't need to do anything (unless they edit the image)
14:15:49 <Botje> horrible to load, though
14:15:54 <Botje> have fun with it, anyway
14:15:59 <Botje> i'm going to hack a bit on my typechecker
14:16:00 <ChongLi> yeah thanks a lot
14:16:32 <Botje> let me know what you come up with :)
14:17:36 <Taneb> A sudden realization occurs
14:17:51 <Taneb> It is possible to use acid-state for things that aren't websitesQ!
14:18:54 <Nik05> I dont get it :( stupid Matlab function works like well it works good... but haskell doesnt :(
14:20:13 <ChongLi> Taneb: yes, this is the advantage of libraries over frameworks :)
14:20:14 <hpc> Taneb: this might be too much realization for one day, but you can also use sql for things that aren't enormous corporate systems ;)
14:20:32 <ChongLi> always favour reusable libraries, not monolithic frameworks
14:21:02 <applicative_> Nik05: what is this 'function'?
14:21:27 <Taneb> Hmm
14:21:47 <Taneb> Hackage seems to have missed out making the documentation for one of my libraries
14:21:54 <Nik05> applicative_ let me paste it :P
14:22:35 <Nik05> applicative_ http://hpaste.org/88961
14:22:46 <Taneb> And it's not the "wait 12 hours" thing, I uploaded this in February
14:22:51 <Taneb> http://hackage.haskell.org/package/groups-0.2.0.1
14:23:47 <Nik05> applicative_ if you refresh you can also see the matlab one
14:24:02 <Nik05> the matlab one finishes in 19 iterations with tol = 1e-10
14:24:07 <Nik05> the matlab one finishes in 19 iterations with tol = 1e-12 *
14:24:32 <Nik05> The haskell one doesnt work after 1e-7...
14:24:44 <Nik05> and even takes more iterations
14:27:50 <DanBurton> so Stackage... I tried building it today but now it doesn't like that stm-chans just uploaded version 3.0, while stm-conduit is expecting stm-chans-2.0.*
14:27:59 <DanBurton> should I report this to stackage, or to stm-conduit?
14:28:02 <DanBurton> or both?
14:28:33 <DanBurton> or is there a way to tell it to just ignore stm-chans-3.0 and install 2.0.* instead?
14:28:51 <byorgey> DanBurton: you can edit the config and add an upper bound for stm-chans
14:29:01 <byorgey> DanBurton: if you wanted to report a bug you would report it to Stackage
14:29:17 <DanBurton> byorgey: is there a wiki page or something that describes how to do this?
14:29:28 <byorgey> but note that Michael Snoyman will find out about it anyway as soon as the automated nightly build of Stackage fails
14:29:59 <DanBurton> nice
14:30:12 <Nik05> Or is Haskell not made for floats?
14:30:17 <byorgey> DanBurton: no, but if you look at https://github.com/fpco/stackage/blob/master/Stackage/Config.hs it should be easy to see how to do it, by example
14:30:22 <byorgey> DanBurton: see the calls to 'addRange'
14:31:14 <supki> Nik05: how do you run it?
14:31:21 <Nik05> supki whihch one?
14:31:29 <supki> Nik05: haskell one
14:31:36 <romanandreg> dcoutts_: ticket filed on cabal project, thanks for your feedback
14:31:43 <dcoutts_> romanandreg: thanks
14:31:44 <applicative_> Nik05: you can mark floats with :: Float, if that's what you want
14:31:46 <Nik05> main = print (trapint (\x -> exp(- x^2 / 2)) 0 1 1e-12)
14:31:51 <Nik05> supki ;)
14:32:06 <Nik05> applicative_ that doesnt help
14:32:26 <Nik05> Float has less precision than Double right?
14:32:57 <byorgey> hmm, I don't see why the Haskell version should use more iterations than matlab.  Haskell is just using native machine IEEE floating point values, same as matlab presumably
14:32:58 <nejucomo> Does anyone know if it's possible with Parsec to fail with an explicit ParseError (or more specifically with a specific SourcePos) ?
14:33:14 <Beetle_jada> yes, it is
14:33:35 <applicative_> (19,0.8556243918914095)
14:33:49 <supki> Nik05: probably I don't understand the problem but it finishes for me immediately with (19,0.8556243918914095)
14:33:52 <enigmuriatic1> is there any way to write a one-line expression that takes a value of Maybe Data (Data being a custom type) and only returns true if the value of the function "result" applied to that value is true?
14:33:56 <Nik05> oh really?
14:34:04 <applicative_> is that wrong? ^^^ for trapint (\x -> exp(- x^2 / 2)) 0 1 1e-12
14:34:11 <Beetle_jada> nejucomo: does this do what you want? http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/Text-Parsec-Prim.html#v:parserFail
14:34:12 <enigmuriatic1> because it keeps giving me error messages related to the fact that the value could be Nothing
14:34:17 <nejucomo> It's rather odd, because I see functions exposed like this: http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/Text-Parsec-Prim.html#v:mergeErrorReply
14:34:36 <Nik05> why do i get overflows? :(
14:34:46 <nejucomo> -but the only way I see to utilize a Reply is by using runParsecT.
14:34:49 <DanBurton> byorgey: ah, ok thanks.
14:34:55 <supki> Nik05: do you compile it?
14:34:59 <anthezium> hey everyone!  is there a way to avoid duplicating the build-depends in all sections in a cabal file, e.g. in the library, executable foo, and test-suite sections?  i've put up an example at http://hpaste.org/88942
14:35:13 <Nik05> supki yes i compile it :S
14:35:16 <nejucomo> anthezium: Yes, with more recent versions of cabal.
14:36:03 <anthezium> nejucomo: cool!  how?  i tried putting the name of the package i'm defining in the build-depends for the executable and test-suite sections, but then it complained about the dependencies specified in the library section being hidden
14:36:31 <nejucomo> Ah, you probably need to explicitly declare the library modules with "exposed-modules" in the "library" section.
14:36:44 <DanBurton> byorgey: any reason why it rebuilds alex and happy? Stackage is supposed to be on top of Haskell Platform I thought, which already comes with these binaries.
14:36:50 <applicative_> enigmuriatic1: maybe False  result ?
14:36:57 <nejucomo> I think you also may need to declare all non-exposed modules too…  I always expose everything.  ;-)
14:37:18 <anthezium> nejucomo: in other-modules?
14:37:25 <anthezium> i tried expose: True
14:37:26 <enigmuriatic1> applicative_, could you possibly explain how that works?
14:37:29 <nejucomo> There's also something separate which is that some packages may or may not be hidden.  I've never understood that, but it hopefully doesn't affect you.
14:37:44 <nejucomo> anthezium: I believe so…  I've never used other-modules.
14:37:48 <applicative_> enigmuriatic1: does it do the right thing? I wasn't sure I followed your description
14:37:51 <applicative_> @type maybe
14:37:53 <lambdabot> b -> (a -> b) -> Maybe a -> b
14:37:55 <anthezium> maybe i need expose: True, and then all of the modules on which I depend in other-modules ?
14:38:04 <enigmuriatic1> applicative_, i'll check
14:38:12 <nejucomo> anthezium: Here's my working example, but keep in mind I don't have much cabal packaging experience at all: https://bitbucket.org/nejucomo/sappho/src/7ba5cc54f67e787ab88348e743e2d4edd1d67778/sappho.cabal?at=default
14:38:31 <anthezium> nejucomo: thanx!!!!! looking...
14:38:38 <nejucomo> I don't have expose: True.  I try to have as few options as possible.
14:38:40 <applicative_> @type maybe False
14:38:41 <lambdabot> (a -> Bool) -> Maybe a -> Bool
14:38:43 <Nik05> supki applicative_ this is so strange... compiled it again, and what do you think? :P
14:38:56 <nejucomo> (And yes the giant exposed-modules field is annoying…  I actually generate it with a script.)
14:39:20 <enigmuriatic1> applicative_, that was indeed what i was looking for, thanks
14:40:41 <anthezium> nejucomo: is the script in that bitbucket somewhere?
14:41:01 <anthezium> nejucomo: hoho fouind it
14:41:09 <Beetle_jada> nejucomo: first use Text.Parsec.Prim.setPosition to set the SourcePos, then use parserZero or parserFail to produce the error
14:41:17 <nejucomo> Yes.  This is hilarious: https://bitbucket.org/nejucomo/sappho/src/7ba5cc54f67e787ab88348e743e2d4edd1d67778/generate-exposed-modules.sh?at=default
14:41:29 <anthezium> nejucomo: whoa gnarly
14:41:42 <anthezium> the beautiful kind of ugly :)
14:41:46 <nejucomo> If I had the time I would patch cabal to have a feature which does that.
14:42:00 <Peaker> What are nice alternatives to:    SomePatternHere <- return foo        in monads like Maybe/[]  ?
14:42:24 <dcoutts_> nejucomo: unfortunately, in general finding all the source files is impossible
14:42:31 <nejucomo> Peaker: let SomePatternHere = foo
14:42:49 <Peaker> nejucomo, In a monad like Maybe/[], I'm actually making use of the "fail" method...
14:43:00 <nejucomo> dcoutts_: The compiler has to do it, so it must be possible.
14:43:02 <Peaker> may be ugly but the alternative of wrapping it all with a case ... _ -> ..  is also ugly
14:43:09 <dcoutts_> nejucomo: though it's possible for any particular configuration, so we can warn users when they've missed one.
14:43:15 <Peaker> nejucomo, so it's not like a "let"
14:43:27 <nejucomo> I suppose that could sound trollish…  I'm sure there are difficulties I'm unaware of...
14:44:04 <supki> Nik05: i suggest to replace  sum  with  foldl' (+) 0
14:44:11 <supki> Nik05: foldl' is from Data.List
14:44:12 <dcoutts_> nejucomo: you're right about the compiler of course, you have to be able to build it afterall. But think about conditional compilation, and files that happen not to be needed by the current configuration.
14:44:27 <nejucomo> Peaker: do x <- Just 4 ; let (Banana b) = myFruit; return (x, b)
14:44:49 <supki> Nik05: (because your code does overflow for me with 1e-13)
14:44:57 <dcoutts_> nejucomo: also in general, finding the files requires compiling others (and running compiled code like pre-processors within the same package)
14:44:59 <Nik05> now it doesnt for me either :S
14:45:00 <Peaker> nejucomo, I don't want "error", I want "fail"
14:45:09 <nejucomo> dcoutts_: Ah, I see.  What about the case of no template haskell, no ffi, and no conditional compilation?
14:45:10 <Peaker> nejucomo, that program will crash
14:45:10 <Nik05> supki whats the difference between float and fold?
14:45:32 <Nik05> oh it does the sum and map in one?
14:45:33 <dcoutts_> nejucomo: and no cabal flags, another source of conditional comp
14:45:34 <Peaker> nejucomo, Banana b <- return myFruit   won't crash, it will Nothing
14:45:42 <supki> Nik05: ?
14:45:43 <nejucomo> dcoutts_: I see. So it's basically a chicken and egg kind of layering problem?
14:45:47 <dcoutts_> nejucomo: and no pre-processors to make it easy
14:45:53 <Nik05> supki i meant sum and foldl :P
14:46:15 <supki> Nik05: sum is defined as foldl (+) 0, it's too lazy
14:46:30 <enigmuriatic1> http://hpaste.org/88968      why is that giving a parse error on conn?
14:46:30 <dcoutts_> nejucomo: it'd be good for cabal to do it's own dependency tracking, for loads of reasons, including that we could check that the provided list of modules is accurate so we can help users maintain that list
14:46:30 <nejucomo> Peaker: Oh, I understand.  Yeah, I would write a helper function that does MyThing -> Maybe Something, and then use that helper function inside the do notation.
14:46:33 <Nik05> so why cant i use this supki ?
14:46:40 <dcoutts_> nejucomo: but the general problem is hard
14:46:57 <nejucomo> I see.
14:47:10 <dcoutts_> nejucomo: it amounts to writing a proper dependency based build system
14:47:16 <nejucomo> So I amend my statement to: "If I had *a lot of* time, I'd work on that feature for cabal."  ;-)
14:47:20 <supki> Nik05: because it generates large thunk (... + (... + (... + ...))) and never forces it. Eventually it blows the stack
14:47:29 <Nik05> oh ok
14:47:43 <dcoutts_> nejucomo: :-) now you see why it doesn't do it already, my lack of time :-)
14:47:51 <enigmuriatic1> http://hpaste.org/88968      why is that giving a parse error on conn?
14:48:58 <supki> Nik05: http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
14:49:23 <Peaker> nejucomo, in my case, I just want to verify a list I have is of length 1, and get that element.. writing: foo [x] = [x] ; foo _ = []   (I'm in the list monad)   seems uglier than the <- return ...
14:50:45 <nejucomo> Peaker: My advice completely missed your need to rely on pattern matching failures.  Sorry for the confusion.
14:50:45 <lpsmith> Ok,  I've built zeromq-haskell before without any problems
14:50:55 <Peaker> nejucomo, no problem
14:51:11 <lpsmith> but at the moment,  it's not finding the zeromq 2.1.11 headers in /usr/include/zmq.h
14:51:15 <nejucomo> dcoutts_: BTW, where does cabal issue and revision tracking?
14:51:16 <lpsmith> I'm a bit confused
14:51:27 <dcoutts_> nejucomo: github
14:51:48 <nejucomo> This was the first google hit: https://github.com/creswick/cabal-dev
14:51:48 <Nik05> supki sorry i still dont get the difference...
14:52:15 <nejucomo> The synopsis doesn't look right.
14:52:16 <Nik05> isnt sum just foldl (+) 0 ? And why would this be a problem?
14:52:41 <nejucomo> Aha….  /haskell.
14:53:14 <FreeFull> I think sum is foldl' not foldl
14:53:29 <FreeFull> To avoid making lots of small thunks
14:53:46 <Nik05> FreeFull foldl1?
14:54:21 <byorgey> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#sum
14:54:37 <byorgey> sum does not use foldl'.
14:55:07 <byorgey> but it should.
14:55:30 <Nik05> so i should use foldl' ?
14:56:40 <FreeFull> Nik05: Sometimes foldl is right, sometimes foldl', sometimes foldr
14:56:44 <Nik05> and foldl' = foldl1?
14:56:53 <hpc> no
14:57:02 <Nik05> oh my ghc doesnt have foldl'
14:57:25 <hpc> import Data.List
14:57:54 <Nik05> thanks :)
14:57:59 <FreeFull> :t Data.List.foldl'
14:58:01 <lambdabot> (a -> b -> a) -> a -> [b] -> a
14:59:01 <hpc> Nik05: usually when you want foldl, you really want foldl'
14:59:14 <Nik05> and when do i want foldr? :P
14:59:20 <hpc> almost always
14:59:34 <shachaf> foldr is much more fundamental than foldl (for lists).
14:59:42 <Nik05> and when do i want to use foldl? :S
14:59:52 <Nik05> when you get a stack overflow...
14:59:56 <shachaf> Almost never.
15:00:25 <hpc> the simple explanation of foldr is that (foldr (*) z xs) replaces the cons (:) operator with (*), and the empty list [] with z
15:00:39 <hpc> 1:2:3:4:5:[] becomes 1*2*3*4*5*z
15:00:50 <nooodl> why is sum defined in terms of foldl, and not foldr?
15:00:57 <lokkkk> What's a 'Overloaded Function'?
15:01:04 <shachaf> nooodl: Because (+) is strict on most types.
15:01:05 <hpc> the longer explanation is beyond my current "it's a 100 degree day" energy ;)
15:04:51 <lpsmith> http://hpaste.org/88969
15:06:43 <Botje> lpsmith: do you have the zeromq headers installed?
15:07:23 <lpsmith> Why is Cabal calling gcc with -include dist/build/autogen/cabal_macros.h repeated *six* times?
15:07:32 <lpsmith> Why stop at six?  why not a dozen?
15:07:35 <lpsmith> Botje, yes
15:07:46 <shachaf> Which version?
15:08:46 <lpsmith> shachaf, whichever version of Cabal ghc-7.6.3 ships with...
15:08:56 <hpc> lpsmith: each repeated -include sets more internal flags, to make sure after 6 tries it is really imported
15:08:56 <shachaf> Which version of libzmq, I mean.
15:09:19 <lpsmith> shachaf, 2.1.11
15:09:19 <hpc> lpsmith: like how when you have a problem with windows server updates, you have to reboot 3 times in a row
15:09:28 <hpc> ;)
15:09:36 <lpsmith> hah
15:10:06 <lpsmith> shachaf, I've compiled this before without remembering having any particular problems with it
15:10:07 <shachaf> lpsmith: Works for me with 2.2.0
15:10:15 <shachaf> Ah.
15:10:35 <Nik05> Botje got it working :D
15:10:51 <Botje> Nik05: ah. yay! what was the issue? or the change that fixed it? :)
15:11:10 <Nik05> Botje i have no idea... i rewrote it all and now it works
15:11:10 <lpsmith> I can compile the zeromq3-haskell bindings ok
15:11:26 <lpsmith> although that would involve a little more work getting it onto production systems
15:11:41 <lpsmith> I really should learn how to write .deb packages.
15:11:44 <tgeeky> Nik05: use a ":" or somesuch to identify that you aren't just typing a sentence. "Botje got it working :D" looks like Botje did something.
15:12:05 <Nik05> tgeeky: ok :P
15:12:07 <shachaf> Well done, Botje!
15:12:08 <tgeeky> lpsmith: me too. I've needed to do that for a long time. I've *always* just found someone else's and hacked away at it
15:12:15 <Botje> yay me!
15:12:27 <tgeeky> Botje-- -- for taking credit for something he didn't do!
15:12:34 <Botje> aww
15:12:35 * tgeeky 's evil plan worked!
15:12:39 <Botje> I helped!
15:12:42 <Nik05> Botje helped me really good :) http://hpaste.org/88970
15:13:02 <lpsmith> on the other hand,  zeromq 2.1.11 works well enough for me and is already available in the ubuntu universe
15:13:31 <tgeeky> Botje++ -- for actually helping
15:13:37 <Nik05> now i need sleep, see you guys later, bye
15:13:39 <Botje> \o/
15:13:45 <Botje> lpsmith: there's a haskell-devscripts
15:13:58 <Botje> which you can very probably just invoke to get a nice debian package
15:15:15 <Nik05> oh Botje have you seen it? Do you see what went wrong with the other ones?
15:16:43 <Botje> not by heart, no
15:16:53 <Botje> i'm guessing laziness biting you somewhere. shrug :)
15:17:02 <Nik05> :D
15:45:24 * monochrom has used Haskell (GHC) to write a toy plugin for xchat!
15:45:56 <mekeor> monochrom: :O
15:46:07 <mekeor> code!
15:46:15 <ion> monochrom: wow
15:47:14 <monochrom> in a moment
15:48:38 <monochrom> I need sometime to recall how to use github!
15:49:26 <monochrom> nah, I can't think of a good name for the repository
15:50:38 <monochrom> oh, I have to think up a name anyway haha
15:50:44 <Fuuzetsu> just name it after an anime character you like or something
15:50:59 <Fuuzetsu> oops, I thought I was in #anime
15:51:11 <joelteon> you are
15:51:18 <mekeor> :D
15:51:21 <koala_man> name it after a combinator you like
15:51:28 <mekeor> "S"
15:51:46 <Fuuzetsu> Good luck having anyone finding it with a Google search
15:51:47 <mekeor> name it "mekeor"!1!!
15:52:09 <ion> Including the punctuation
15:52:18 <ion> and the number
15:53:11 <Fuuzetsu> I don't even think GitHub will let you use ‘!’… Shame.
15:53:23 <mekeor> "polychrom"
15:54:05 <mekeor> "mhuhgtwatpfx" – an abbrev. for "monochrom has used Haskell (GHC) to write a toy plugin for xchat!"
15:54:32 <ion> I see what you did there.
15:54:46 <monochrom> https://github.com/treblacy/xchat-plugin-haskell-toy
15:54:48 <ion> “abbrev.”
15:54:51 <mekeor> :D
15:55:18 <Peaker> merijn, your missing "main" problem is OSX, Linux or Windows?
15:57:43 * barrucadu finishes watching edwardk's Lens talk and realises how much he still has to learn
15:57:55 <barrucadu> One day I shall be a good Haskell programmer, one day…
15:58:30 <mekeor> :D
15:58:31 <monochrom> general discussion of loading Haskell *.so from C is at my http://www.vex.net/~trebla/haskell/so.xhtml
15:58:35 <mekeor> "i have a dream.."
15:58:35 <ion> monochrom: Awesome. Are my_enter and my_exit names dictated by the xchat API?
15:59:14 <monochrom> no, they are arbitrary local names, the attributes "constructor" and "destructor" are the point, and it's generally for *.so
15:59:40 <monochrom> they are like windows's libinit and libexit or whatever windows calls them
16:00:48 <monochrom> the xchat api dictates those "xchat_" names and types in Whee.hs
16:00:52 <ion> monochrom: Ah, alright.
16:01:22 <monochrom> http://xchat.org/docs/plugin20.html is the xchat-specific page
16:01:52 <KB112> newbie here: what does the error message "'Bool' is applied to too many type arguments in the type signature for (function name)" mean?
16:02:14 <c_wraith> KB112: probably that you forgot a ->
16:02:35 <c_wraith> KB112: more specifically, it means you wrote "Bool Foo" somewhere in the type signature
16:02:45 <KB112> here is my signature: modcheck :: (Num a, Bool b) => a -> [a] -> a -> b
16:02:57 <c_wraith> KB112: and the error message is saying "Hey, Bool doesn't take any parameters"
16:02:59 <ion> Constructor and destructor functions in shared objects are something i have never touched upon.
16:03:09 * hackagebot yesod-links 0.3.0 - A typeclass which simplifies creating link widgets throughout your site  http://hackage.haskell.org/package/yesod-links-0.3.0 (PatrickBrisbin)
16:03:10 <Fuuzetsu> KB112: Bool is not a typeclass, you can't do that
16:03:11 * hackagebot yesod-markdown 0.8.1 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.8.1 (PatrickBrisbin)
16:03:21 <c_wraith> KB112: then I have no clue why that's the error message it's giving you. The error message it should give you should say "No class named Bool"
16:03:43 <c_wraith> KB112: unless maybe you're using hugs?
16:03:58 <KB112> don't think so
16:04:00 <danharaj> It might be a regression due to the implementation of constraint kinds?
16:04:13 <KB112> should I try just deleting Bool B?
16:04:29 <mekeor> modcheck :: Num a => a -> [a] -> a -> Bool
16:04:36 <barrucadu> KB112: You probably want (Num a) => a -> [a] -> a -> Bool
16:04:41 <KB112> oh ok thanks
16:04:54 <c_wraith> danharaj: oh, that's possible
16:04:59 <barrucadu> The "Num a" part means that "a" is some type which can be used as a number
16:05:13 <c_wraith> KB112: the important part is that types and classes are very different. Make sure you understand the difference.
16:05:18 <barrucadu> There are various types which fulfil this criteria, such as Int, Integer, and Float
16:05:35 * danharaj wonders if understanding the kind system would make type classes easier to digest.
16:06:02 <KB112> ok, I'll have another look at that section in my book. Thanks everyone.
16:06:13 <merijn> Peaker: OSX
16:18:09 * hackagebot hsdns-cache 1.0.4 - Caching asynchronous DNS resolver.  http://hackage.haskell.org/package/hsdns-cache-1.0.4 (VladimirShabanov)
16:48:08 <thraya> hi all... is     _ <- atomicModifyIORef' ref k    equivalent to    !_ <- atomicModifyIORef ref k   (note ' on first atomic...)
16:53:08 <c_wraith> thraya: no.
16:53:29 <c_wraith> :t atomicModifyIORef
16:53:31 <lambdabot> Not in scope: `atomicModifyIORef'
16:53:41 <c_wraith> Blah, I can't remember the tuple order
16:54:15 <c_wraith> anyway, forcing the result of executing atomicModifyIORef only forces that part of the tuple.
16:54:58 <c_wraith> atomicModifyIORef' forces both the stored value and the result value
16:55:04 <thraya> ah so the internal value of the ioref may not be forced in the !_ case... ty
16:55:26 <c_wraith> yep, you've got it
16:56:01 <thraya> the code I was looking at had a tuple which was (x, x), ie the same value for internal and return, so in that case maybe they are equivalent?
16:56:56 <c_wraith> in that case, they would be, yes
16:57:29 <thraya> ok tyvm
17:03:10 * hackagebot yesod-paginator 0.4.1 - A pagination approach for yesod  http://hackage.haskell.org/package/yesod-paginator-0.4.1 (PatrickBrisbin)
17:03:44 <tabemann> random question
17:03:52 <mekeor> go ahead!
17:03:57 <tabemann> I'm using Linear, and I'm trying to find how to transpose an matrix in it
17:04:12 <tabemann> (instead of just doing it manually)
17:05:28 <BMeph> tabeman: Just to be clear (and Gloriously Pedantic): are you looking for how to find how to transpose a matrix, or just transposing? ;þ
17:05:46 <BMeph> Oopsie, tabemann: ^^
17:07:25 <tabemann> I was just trying to find if there was some convenient function to do it somewhere rather than hand-coding it
17:07:47 <tabemann> as I was assuming it was the kind of thing that would be implemented in Linear, but I couldn't find it
17:08:07 <tabemann> but I need to go (if you have a response, I'll see it later)
17:08:51 <mekeor> i don't know what transposing means but there's Data.List.transpose
17:09:19 <enthropy> tabemann: there's  adjoint, which might be transpose for a matrix of doubles
17:09:28 <applicative_> github is telling me that the last commit to pipes-parse is 'in 7 hours'
17:10:01 <enthropy> which might happen since  conjugate :: Double -> Double seems to be id from the documentation
17:11:34 <mekeor> applicative_: time zones?
17:18:10 * hackagebot graphics-drawingcombinators 1.4.4.1 - A functional interface to 2D drawing in OpenGL  http://hackage.haskell.org/package/graphics-drawingcombinators-1.4.4.1 (LukePalmer)
17:23:11 * hackagebot yesod-comments 0.9.0 - A generic comments interface for a Yesod application  http://hackage.haskell.org/package/yesod-comments-0.9.0 (PatrickBrisbin)
17:33:40 <bz> :t 4
17:33:41 <lambdabot> Num a => a
17:34:23 <bz> [1..]
17:35:12 <bz> lambdabot: [1..]
17:35:17 <bz> lambdabot: :t [1..]
17:35:23 <bz> :t [1..]
17:35:25 <lambdabot> (Enum t, Num t) => [t]
17:42:18 <ski> @type [False ..]
17:42:19 <lambdabot> [Bool]
17:43:04 <ski> @type [False..]  -- heh
17:43:05 <lambdabot> parse error on input `]'
17:48:57 <FreeFull> :t [False..]
17:48:58 <lambdabot> parse error on input `]'
17:49:20 <FreeFull> Hmm, didn't know it needed the space
17:49:26 <FreeFull> I guess it makes sense
17:50:30 <enthropy> > (succ Prelude.. pred) True
17:50:31 <lambdabot>   True
17:51:39 <enthropy> \bot could have a `module False (.)' to fix that
17:51:47 <lispy> johnw: what do you do with system-filepath's FilePath when you want to store a FilePath in a recond and also make a Read instance?
17:52:12 <lispy> johnw: I think my only real choice here is to convert to Prelude.FilePath
17:54:34 <enthropy> lispy: you could use `fromString :: String -> FilePath' in defining your Read instance
17:55:20 <mekeor> http://www.bash.org/?244321
17:55:26 <lispy> enthropy: you mean, if I defined my own instance instead of deriving?
17:55:55 * lispy would rather not use system-filepath than write Read instances by hand... :)
17:56:00 <lispy> So I'm really looking for a different solution.
17:56:44 <lispy> (also, I think you meant fromText?)
17:56:57 <enthropy> lispy: either at the level of defining    instance Read FilePath, or the instance for your record
17:57:35 * enthropy dunnos what fromText is
17:57:40 <lispy> Well, if I'm going to define an instance of Read for FilePath I'd submit a pull request to the author. I'm not fond of orphans.
17:57:58 <lispy> enthropy: where is fromString defined?
17:58:09 <lispy> http://hackage.haskell.org/packages/archive/system-filepath/0.4.7/doc/html/Filesystem-Path-CurrentOS.html
17:58:14 <lispy> That's where I'm seeing fromText
17:58:17 <enthropy> Data.String
17:58:54 <lispy> ah, I'm not familiar with that module
17:59:09 <lispy> there is indeed an IsString instance for system-filepath
17:59:32 <lispy> so then it seems like the missing bit is the Read instance for FilePath. I wonder if it's intentionally missing.
18:02:31 <dav> is there any reason to ever use foldl rather than foldl' ?
18:02:57 <lispy> to demonstrate a stack overflow ;)
18:03:16 <dav> actually speaking of stack overflow
18:03:22 <dav> just found this => http://stackoverflow.com/questions/8235797/is-foldl-ever-preferable-to-its-strict-cousin-foldl
18:03:29 <hpc> dav: if you are missing that part of your brain that helps you make reasonable decisions, it is possible to contrive an example that is bottom with foldl' but a value with foldl
18:04:00 <hpc> (relatedly, i have constructed that example before but i don't remember it off the top of my head)
18:04:18 <dav> hpc: like this? foldl' (\x y -> y) 0 [undefined, 1]
18:04:37 <hpc> > foldl' (\x y -> y) 0 [undefined, 1]
18:04:38 <lambdabot>   *Exception: Prelude.undefined
18:04:41 <hpc> > foldl (\x y -> y) 0 [undefined, 1]
18:04:43 <lambdabot>   1
18:04:45 <hpc> yes, that
18:04:58 <dav> ok
18:05:20 <dav> sounds like they should be foldl' in the Prelude..
18:07:10 <xenocons> looking for a function/alg to find a n given list within an n given list, such that find [4;5] [1;2;3;4;5;6;7] will return 3 (index)
18:07:24 <xenocons> is there something inbuilt that i can purpose
18:08:37 <ski> (was that meant for ##fsharp ?)
18:09:07 <xenocons> sorry [4,5] [1,2,3,4,5,6,7]
18:09:54 <xenocons> nah not meant for ##fsharp, it will fall upon deaf ears
18:10:09 <xenocons> (no one is ever really active in there)
18:10:15 <dav> xenocons: findIndex (`elem` [4,5])
18:10:25 <shachaf> dav: What?
18:10:31 <shachaf> Ah, hmm.
18:10:45 <xenocons> cool, returns Just 3 perfect
18:10:52 <shachaf> I suppose xenocons didn't specify their question. But I expect that it's about finding a sublist.
18:10:58 <shachaf> Or not!
18:11:06 <dav> xenocons: you familiar with Hoogle?
18:11:17 <xenocons> dav: yeah, but i struggle to use it
18:11:26 <Fuuzetsu> Guys, M-. in emacs used to jump to definitions of Haskell functions, right?
18:12:08 <geekosaur> Fuuzetsu, that would be goto-tag and assumes you have built an emacs tags table for the source in question
18:12:11 <ski> > (findIndex (isPrefixOf [4,5]) . tails) [1,2,3,4,5,6,7]
18:12:12 <lambdabot>   Just 3
18:12:16 <dav> xenocons: I thought a function to find the first common element in two lists was unlikely, but a function to find the first index that hits a predicate is more likely, so I hoogled for (a -> Bool) -> [a] -> Int
18:12:22 <Fuuzetsu> geekosaur: Do I just build it with etags?
18:12:23 <shachaf> M-. is "jump to definition". But that sounds like a #emacs question.
18:12:26 <aoshi> can anyone tell me why these where expressions aren't playing nice? http://hpaste.org/88976
18:12:31 <roconnor> ski's answer seems more general
18:12:33 <geekosaur> should be
18:12:37 <xenocons> dav: ah
18:12:38 <ezyang> Hmm, is f a = (a -> r) -> r considered a positive type operator?
18:12:40 <shachaf> roconnor: ski's answer is to a different question.
18:12:43 <shachaf> ezyang: Yes.
18:12:48 <dav> xenocons: oh wait you wanted to find a subList ?
18:12:49 <shachaf> ezyang: But not "strictly positive".
18:13:00 <xenocons> hmm, my non abstract problem is to find a list of given constants within a huge list of bytes
18:13:03 <geekosaur> might also need to M-x visit-tags-table to load the new tags table into the running emacs
18:13:25 <ezyang> Hmm. I wonder if Harper is purposely glossing over this distinction, or there's a typo in his book.
18:13:25 <dav> shachaf: ah yes looks like I misunderstood the problem
18:13:35 <Fuuzetsu> Yeah. I think I spent too much time with emacs lisp and Agda recently where it's just integrated for you beautifully…
18:13:40 <shachaf> ezyang: Which book? Is this online?
18:13:52 <xenocons> my current approach is to use boyer moore, which turns out to be a bad idea heh (or at least my implementation)
18:13:59 <ski> > findIndex (`elem` [4,100]) [1,2,3,4,5,6,7]
18:14:00 <lambdabot>   Just 3
18:14:11 <ezyang> shachaf: PFPL, you can see the mistake in the draft
18:14:19 <shachaf> xenocons: Boyer-Moore and linked lists don't go well together.
18:14:31 <roconnor> > const (const 3) $ [4,5] [1,2,3,4,5,6,7]
18:14:33 <lambdabot>   The function `[4, 5]' is applied to one argument,
18:14:33 <lambdabot>  but its type `[t0]' has ...
18:14:39 <roconnor> damn
18:15:04 <xenocons> shachaf: yeah, at the moment its in C so its just byte arrays i guess, but i figure the idea was unsound in any language
18:15:11 <applicative_> aoshi the stuff in the last where is only in scope for play_hrs
18:15:40 <ski> shachaf : .. i interpreted xenocons as asking about a (contiguous) sublist
18:15:42 <dav> xenocons: ski's solutions should work.. : findIndex :: (a -> Bool)
18:15:59 <shachaf> ski: So did I.
18:16:10 <xenocons> im going to try it
18:16:12 <dav> xenocons: bad paste, findIndex (isPrefixOf [4,5]) . tails)
18:16:14 <applicative_> aoshi: if you scrap the where on line 5 and make 'portion' just another thing you are defining, wont it compile?
18:16:19 <shachaf> ezyang: Hmm, yes, that looks incomplete unless I'm missing something.
18:16:20 <dav> @src tails
18:16:20 <lambdabot> tails []         = [[]]
18:16:21 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
18:16:27 <aoshi> applicative_ let me try
18:16:31 <ezyang> OK, I'll send him a note
18:16:39 <shachaf> ezyang: Of course, maybe when he says "positive" he means what other people mean by "strictly positive".
18:17:01 <dav> ski: is tails "efficient" ? it never copies the list right?
18:17:13 <dav> I don't see why it would..
18:17:16 <ezyang> Well, wouldn't be the first time he's gone off and used idiosyncratic terminology
18:17:18 <aoshi> applicative_ -ah, yes, that did the trick, thank you!
18:17:21 <shachaf> But double-negative being positive is pretty standard.
18:17:34 <shachaf> pigworker would be the expert on this topic, naturally.
18:17:34 <ski> dav : it shouldn't copy tails under graph-interpretation, no
18:18:53 <ski> ezyang : i've seen "positive" vs. "negative" vs. "strictly positive" context in e.g. "Constructivism in Mathematics: An Introduction - Volume I" by Anne Sjerp Troelstra,Dirk van Dalen
18:19:05 <dav> @src isPrefixOf
18:19:05 <lambdabot> isPrefixOf [] _          = True
18:19:05 <lambdabot> isPrefixOf _  []         = False
18:19:05 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
18:19:47 * ski str there were some results by Helena Rasiowa related to it
18:20:06 <dav> Seems to me that "findIndex (isPrefixOf l) . tails)" is going to be quite efficient. Is there some optimization we're missing out on?
18:20:24 <applicative_> 'strictly positive' certainly predates 'type theory'
18:20:31 * ski nods
18:20:45 <applicative_> it is found also in e.g. Dummett's Elements of Intuitionism
18:20:58 <applicative_> as something that is supposed to be familiar
18:21:49 <barrucadu> I don't really know what you're all talking about, but it sounds interesting; could someone point me to some introductory material on this positive/strictly positive/negative thing?
18:22:21 <applicative_> aoshi: like so, maybe http://hpaste.org/raw/88977
18:23:23 <ski> barrucadu : every type `tau' occurs positively (but not negatively) in itself
18:23:25 <ezyang> barrucadu: I actually wrote about this not too long ago: http://blog.ezyang.com/2012/09/y-combinator-and-strict-positivity/
18:23:37 <enthropy> > on (=~) (map chr) [3,4] [1,2,3,4,5] :: MatchArray
18:23:38 <lambdabot>   Not in scope: type constructor or class `MatchArray'Not in scope: `=~'
18:23:38 <lambdabot>  Per...
18:23:59 <applicative_> Per indeed.
18:24:07 <ski> barrucadu : if `tau0' occurs positively in `tau1' and `tau1' positively in `tau2', then `tau0' occurs positively in `tau2'
18:24:18 <ski> barrucadu : if `tau0' occurs positively in `tau1' and `tau1' negatively in `tau2', then `tau0' occurs negatively in `tau2'
18:24:30 <ski> barrucadu : if `tau0' occurs negatively in `tau1' and `tau1' positively in `tau2', then `tau0' occurs negatively in `tau2'
18:24:41 <ski> barrucadu : if `tau0' occurs negatively in `tau1' and `tau1' negatively in `tau2', then `tau0' occurs positively in `tau2'
18:24:57 <applicative_> thus the attraction of the language of 'negative' and 'positive'
18:25:19 <ski> barrucadu : both `tau0' and `tau1' occurs posiively in `tau0 /\ tau1' (aka `(tau0,tau1)' in Haskell types)
18:25:31 <ski> barrucadu : both `tau0' and `tau1' occurs posiively in `tau0 \/ tau1' (aka `Either tau0 tau1' in Haskell types)
18:25:45 <enthropy> maybe that regex-based answer would actually work, if there was  (chr . (+ bigNumber)) that avoids making any special chars
18:25:45 <ski> barrucadu : `tau0' occurs positively and `tau1' negatively in `tau0 -> tau1'
18:25:54 <applicative_> but tau0 -> tau1 what about them ski
18:25:56 <applicative_> oh
18:26:05 <applicative_> is ski a bot??
18:26:10 <ski> barrucadu : er. the other way around
18:26:17 <ski> barrucadu : `tau0' occurs negatively and `tau1' positively in `tau0 -> tau1'
18:26:19 <applicative_> yipe
18:26:31 <barrucadu> applicative_: A wisdom-dispensing bot :P
18:26:36 <applicative_> oh yes
18:26:41 <shachaf> ski: You should take these things and put them on a wiki page!
18:26:46 <dav> so "foldl (+) 0 [1..]" obviously blows up memory wise. But it does so to the point where I nearly have to reboot my computer. Is there way to set some limits to make sure things stay within some reasonable memory footprints and crash above a certain size?
18:26:50 <shachaf> It's just as much typing but then a bunch of other people get to benefit.
18:27:01 <ski> hm, i suppose
18:27:14 <barrucadu> ski: Thanks for the summary :)
18:27:19 <barrucadu> ezyang: I shall be sure to read that later
18:27:19 <shachaf> dav: Your operating system probably has a feature for this. GHC does too. It's specified somewhere in the GHC user's guide.
18:27:26 <ski> (but it's more fun to explain it interactively :-P)
18:27:37 <tabemann> daav: use foldl'
18:27:40 <xenocons> p <- readFile "C:\\Users\\t\\Desktop\\putty.exe"; (findIndex (isPrefixOf "MZ" ). tails) p -- works
18:27:41 <ski> barrucadu : are you familiar with the idea of contexts ?
18:27:48 <dav> tabemann: I know that's not the point :)
18:27:55 <barrucadu> ski: Not really, no
18:27:58 <applicative_> dav there are command line options, but that you have to reboot is a little suspicious, I think.
18:28:04 <shachaf> ski: Sure.
18:28:27 <shachaf> ski: If it was more fun to write it up on the wiki, I wouldn't have to ask!
18:28:31 <tabemann> well it's probably swapping itself to death there
18:28:51 <tabemann> it's probably not actually exhausting the mappable memory, but is going beyond the amount of actual RAM
18:28:54 <ski> barrucadu : consider a BNF for propositional logic `F ::= A | not F | F /\ F | F \/ F | F -> F' -- following so far ?
18:28:57 <shachaf> xenocons: readFile gives you a String, by the way, i.e. a list of characters.
18:29:08 <shachaf> xenocons: A binary .exe file is not a list of characters.
18:29:16 <barrucadu> ski: Yes
18:29:21 <applicative_> dav foldl is absolutely toxic.  occasionally someone like shachaf thinks up a use for it
18:29:40 <shachaf> Someone like ddarius.
18:29:53 <ski> (`A' standing for atomic formulae, iow propositional variables here)
18:29:54 <applicative_> okay, asionally someone like shachaf  thi
18:29:58 <tabemann> I just saw an example someone pointed out here of one sort of case where one might want foldl rather than foldl', but it sounded like a corner case in practice
18:30:00 <dav> applicative_: foldl' isn't a silver bullet either if the state variable isn't a basic datatype if I recall correctly.
18:30:02 <applicative_> not sure  what that was
18:30:08 <applicative_> dav oh indeed not
18:30:23 <applicative_> the right strictness conditions are necessary.
18:30:31 <tabemann> pointed out on stack overflow specifically
18:30:36 <xenocons> shachaf: right, so im guessing there is some String -> IO [byte] or such somewhere
18:31:01 <applicative_> my own view is that foldl' 's should be written long hand so you can inspect and !bang where appropriate etc
18:31:21 <tabemann> which means hand-coding your own tail-recursive func
18:31:22 <applicative_> that is, dav, even foldl' shouldn't be used directly. just the idea of it.
18:31:49 <shachaf> xenocons: No, you don't want a String. By the time you have a String it's too late. The file's been decoded (erroneously).
18:31:59 <ski> barrucadu : now, let's define also :
18:32:02 <shachaf> xenocons: You want to read the bytes straight off. Data.ByteString has functions for this.
18:32:04 <xenocons> shachaf: what about IO ByteString?
18:32:05 <ski>   P ::= * | not N | P /\ F | F /\ P | P \/ F | F \/ P | N -> F | F -> P
18:32:06 <ski> and
18:32:07 <ski>   N ::=     not P | N /\ F | F /\ N | N \/ F | F \/ N | P -> F | F -> N
18:32:07 <xenocons> ah right :)
18:32:08 <applicative_> tabemann: yeah that's what I was thinking, but it's just my practice, which apes somewhat the cognoscenti
18:32:12 <tabemann> I know there's got to be a function to read data from a handle into a lazy bytestring
18:32:14 <xenocons> found it via hoogle woot
18:32:19 <ski> (note no `*' in the `N' one)
18:32:38 <shachaf> xenocons: Note that "MZ" isn't a ByteString. The equivalent bytes are [0x4d, 0x5a]
18:32:39 <applicative_> ski, awesome
18:32:40 <ski> barrucadu : the `*' stands for a "hole"
18:33:15 <ski> barrucadu : now, we can define an operation of "plugging the hole" with a formula, so `P[F]' and `N[F]'
18:33:22 <shachaf> xenocons: ByteString even has a utility function, breakSubstring, to find a substring!
18:33:38 <xenocons> shachaf: excellent, even better!
18:34:22 <ski> e.g. if `N' is `A0 /\ ((* \/ A1) -> A2)', then `N[not A0]' is `A0 /\ ((not A0 \/ A1) -> A2)'
18:34:51 <xenocons> shachaf: is there suguar to store [0x4d,0x5a] as ByteString?
18:34:56 <shachaf> xenocons: (Since a ByteString is an array of bytes rather than a linked list, it can search more efficiently, too.)
18:35:06 <shachaf> ?
18:35:25 <xenocons> guessing breakStubstring p [0x1a] wont work
18:35:28 <ski> barrucadu : now, we can talk about a specific occurance of a subformula `F1' in a formula `F0' by decomposing `F0' into `P[F1] or `N[F1]' (for a positive context `P' or negative context `N')
18:35:30 <applicative_> B.pack xenocons ?
18:35:59 <tabemann> last time I saw B.pack it sounded like it was for creating ByteString.Char8 values
18:36:05 <tabemann> which might not be what one would want here
18:36:30 <ski> barrucadu : and then a specific subformula occurance occuring positively or negatively in the whole formula just means that the context that one gets in the intended decomposition is positive resp. negative
18:36:34 <tabemann> B.pack also takes a String, which again might not be what one would want for arbitrary octets
18:37:38 <ski> barrucadu : finally, we define "strictly positive" through the contexts described by `SP ::= * | SP /\ F | F /\ SP | SP \/ F | F \/ SP | F -> SP'
18:37:39 <applicative_> tabemann: BCHAR8.pack takes Chars , B.pack takes [Word8]
18:38:03 <tabemann> somehow I must've missed that then
18:38:21 <xenocons> breakSubstring p (Data.ByteString.pack [0x4d, 0x5a])
18:38:28 <applicative_> the shown value of B.pack [0x4d,0x5a] is "MZ" fwiw
18:38:34 <barrucadu> ski: What use do these contexts have?
18:38:43 <frankbro> How do you define a multiline list? http://hastebin.com/tefilapifa.coffee
18:38:54 <frankbro> every search I do return multiline string -.-
18:38:55 <ski> barrucadu : btw, the `*' doesn't occur (directly (though indirectly, via `P')) in `N', because a formula considered as a subformula of itself doesn't occur negatively in itself, just positively
18:39:32 <applicative_> frankbro: does that pass the compiler?  in principle it looks okay
18:39:33 <tabemann> frankbro: there's no reason lists can't cross lines
18:39:40 <ski> barrucadu : well, you can think of "occurs positively" as being roughly "output", and "occurs negatively" as being roughly "input", in terms of types
18:39:52 <geekosaur> frankbro, that paste seems alright as far as it goes, but 'let' at top level doesn't do what you want (it works in ghci but ghci is not a normal toplevel)
18:40:10 <geekosaur> at top level you should just drop the 'let'
18:40:31 <ski> barrucadu : if you want to be able to define an `fmap :: forall a b. (a -> b) -> (f a -> f b)' function for any particular `f', then `a' has to occur (only) positively in `f a'
18:40:57 <xenocons> hrm
18:41:32 <applicative_> frankbro: you can distribute the characters in xor_patterns =  [([0,0],[0]),([0,1],[1]) ,([1,0],[1]) ,([1,1],[0])]
18:41:36 <figi> hello, how i declare a new data haskell?
18:41:43 <ski> barrucadu : e.g. `f' could be `Either ()', but it couldn't be `Shower' (with `newtype Shower a = S (a -> ShowS)'? or `Endo' (with `newtype Endo a = E (a -> a)')
18:41:51 <tabemann> data Foo = Foo bar etc. etc. etc.
18:41:52 <monochrom> "data Hello = ..."
18:42:03 <applicative_> as you like in almost any way, frankbro , as long as you keep to the right of the 'x' column in xor_patterns
18:42:11 <figi> i can use other types like Int
18:42:17 <ski> barrucadu : also, this is related to covariance and contravariance of subtyping, in Object-orientation
18:42:23 <applicative_> figi: data Figi = Figi Int Char
18:42:26 <frankbro> applicative_, aww that seems to have fixed it
18:42:31 <figi> thanks
18:42:50 <shachaf> How can we trick Ross Paterson into coming to #haskell?
18:43:08 <monochrom> connect his email account to IRC
18:43:16 <applicative_> hah
18:43:16 <tgeeky> girl scout cookies
18:43:23 <barrucadu> ski: Ok, I think I see; I suppose I just need to look at some more type signatures and it'll become more clear
18:43:27 <ski> barrucadu : .. hm, or if you wonder what use these *conxtext* specifically have -- well, to be able to talk exactly about occurances, and whether they are positive or negative (or neither or both)
18:43:27 <barrucadu> ski: Thanks for the explanation
18:43:30 <applicative_> I thought it was common knowledge that monochrom is Ross Patterson
18:43:44 <monochrom> how could that be possible?!
18:44:03 <monochrom> I am not even a monic arrow
18:44:18 <applicative_> its true, common knowledge isn't possible. our brains are too small.
18:44:25 <shachaf> Ross Patterson... Is that like Ross Paterson, except he talks more?
18:44:53 <ski> barrucadu : if you have a complicated-looking type signature, like one of a higher-order function, it can often be useful to mentally think of some of the types occuring inside it as being "inputs" and some as being "outputs"
18:45:48 <shachaf> "outputs" in a pretty general sort of sense
18:46:07 <ski> barrucadu : e.g. in `foo :: (A -> Bool) -> A', `Bool' is "input" (to `foo') but both the `A's correspond to "outputs" (the first one not being a "strict" one, in the sense of "strictly positive")
18:46:09 <shachaf> E.g. If f :: (A -> r) -> r, A is an "output", because f is "giving you" an A.
18:46:23 <applicative_> what, you dont think (+1) has an output??  admittedly all the outputs already exist
18:47:49 <applicative_> (+1) has always already output 3 for 2
18:48:36 <Aetherspawn> Anyone here got much experience with aeson? I'm trying to use deriveJSON to automatically generate the toJSON and fromJSON, but it'd be really nice if I could have default values in the fromJSON and all fields optional
18:48:56 <ski> in my and shachaf's examples, `A' (the former one in my case) corresponds to an "output" from `foo'/`f', because it'll be given to a callback i (the caller) writes
18:49:06 <shachaf> 4 years of aeson experience required
18:49:20 <irene-knapp> Aetherspawn: I've used it a bit
18:49:27 <irene-knapp> I haven't used the deriveJSON business though
18:49:48 <shachaf> A is even positive in (A -> ()) -> ()
18:49:49 <Aetherspawn> What do you mean shachaf :/
18:49:52 <irene-knapp> won't the fields be optional if they're in Maybe?
18:50:25 <Aetherspawn> Uh, they might be
18:50:29 <shachaf> And in (IO a), etc.
18:50:29 <Aetherspawn> But I'd have to have 2 structures
18:50:35 <ski> shachaf : and in `(A -> Void) -> Void' :)
18:50:53 <ski> (but not in `IORef A')
18:51:25 <shachaf> But it is in (CoYoneda IORef a)!
18:52:29 <ski> top enterprise systems ought to use `CoYoneda' more
18:52:52 <barrucadu> Ok, I think I understand
18:53:07 <applicative_> we should make a list of Enterprise Functors
18:53:48 <barrucadu> applicative_: instance Functor AbstractSingletonProxyFactoryBean where ...
18:53:52 <ski> barrucadu : basically, if you have a type `..A..', and wonder whether `A' is occuring positively in it, try to define `newtype Foo a = MkFoo (..a..)' and see if you can (correctly) make a `Functor Foo' instance for it
18:54:19 <applicative_> there you go, data AbstractSingletonProxyFactoryBean a = AbstractSingletonProxyFactoryBean a | NullPointer
18:54:25 * ski . o O ( `class Functor f => EnterpriseFunctor f where ...' )
18:55:14 <applicative_> maybe the better plan is just to rename fmap
18:55:36 <startling> to "map"? yes please
18:55:36 <applicative_> > let enterprise = fmap in enterprise ord "hello"
18:55:39 <lambdabot>   [104,101,108,108,111]
18:56:04 <startling> oh, this is a joke conversation
18:56:06 <startling> BORING
18:56:14 <applicative_> > let enterprise = fmap ; nullpointerthingy = Nothing in enterprise ord nullpointerthingy
18:56:15 <lambdabot>   Nothing
18:56:16 <barrucadu> enterpriseMap :: (EnterpriseFunctor f, CorporateAuthorisation c) => f a -> c -> f b
18:57:25 <applicative_> hm, like Atkey
18:58:24 <monochrom> w00t haskell weekly news
19:00:49 <mekeor> it's weird to see an educated person like monochrom chatting in internet slang
19:00:51 <monochrom> hahaha the fix function exists to fix type problems
19:01:05 <mekeor> i like it
19:01:32 <shachaf> monochrom: No quonochroms this HWN! What happened?
19:01:48 <mekeor> i like you, monochrom. did i ever mention you're one of my idols? uh, that's -blah though
19:02:20 <Aetherspawn> :t maybe
19:02:21 <lambdabot> b -> (a -> b) -> Maybe a -> b
19:03:14 <monochrom> hahahaha well done shachaf with peano arithmetic and 88, I actually had to think
19:03:28 <mekeor> there should be "bool :: a -> a -> Bool -> a", imo..
19:03:43 <Aetherspawn> :t default
19:03:44 <lambdabot> parse error on input `default'
19:03:48 <Aetherspawn> What is default
19:04:04 <mekeor> isn't it a keyword?
19:04:14 <mekeor> http://www.haskell.org/haskellwiki/Keywords#default
19:04:22 <Aetherspawn> Oh, sweet
19:04:23 <Aetherspawn> thanks
19:04:33 <startling> :t if' -- mekeor
19:04:35 <lambdabot>     Not in scope: if'
19:04:35 <lambdabot>     Perhaps you meant f' (imported from Debug.SimpleReflect)
19:04:38 <applicative_> default(Integer,Double) is that the syntax?
19:04:39 <startling> aw
19:04:39 <mekeor> just hoogle it ;)
19:04:41 <monochrom> try defauIt
19:04:54 <applicative_> no put a Turkish I in there
19:04:59 <mekeor> ı
19:05:16 <mekeor> that's a small one
19:11:38 <applicative_> isn't there some monster package that gives you some font for most of unicode?
19:14:09 * applicative_ hadn't known the technical term for the the boxes shown where no font is available 
19:14:19 <irene-knapp> replacement characters
19:14:30 <irene-knapp> in that specific case, from the last-resort font
19:14:48 <applicative_> tofu is what wikipedia is calling them ...
19:14:51 <irene-knapp> lol
19:14:52 <irene-knapp> I see
19:16:06 <applicative_> if you don't have a font that handles chinese, you just get tofu
19:16:41 <monochrom> the monster package I use is ubuntu.
19:16:52 <mekeor> mine is DejaVu
19:19:01 <applicative_> hm, DejaVu covers 62% of Hebrew, that's nice.
19:19:27 <mekeor> isn't that low?
19:19:36 <tgeeky> Bah, Hebrew. It's always incomplete anyway!
19:19:40 * gienah likes anonymous pro for coding: http://www.ms-studio.com/FontSales/anonymouspro.html
19:19:46 <mekeor> i thought hebrew is quite few characters..
19:20:09 <applicative_> tgeeky: that's what I was thinking, I'll print a copy of scripture in it, and interpretation can be a little looser thereafter...
19:20:15 <irene-knapp> hm that IS a pretty good font, gienah
19:20:16 <mekeor> gienah: :O
19:20:18 <startling> doesn't hebrew have a lot of control characters?
19:20:40 <geekosaur> hebrew hasa lot of nikudot that are only used in religious texts
19:20:58 <geekosaur> so they don't get as much font coverage as the standard ones
19:21:03 <startling> ah
19:21:34 <applicative_> i thinits like polytonic greek, which nevertheless is supposed to have complete representation in DejaVu
19:21:45 <applicative_> except of course it has incomplete representation in Unicode
19:21:49 <mekeor> gienah: i guess i prefer DejaVu Sans Mono over Anonymous Pro
19:22:37 <gienah> mekeor: yeah I like DejaVu Sans Mono as well
19:23:18 * applicative_ goes with Mono Dyslexic, as you might have guessed. 
19:23:59 <Aetherspawn_> @pl (\f -> decodeFile f >>= \x -> maybe warn id x)
19:23:59 <lambdabot> (maybe warn id =<<) . decodeFile
19:24:11 <shachaf> @src fromMaybe
19:24:11 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
19:24:14 <shachaf> Hmm.
19:24:17 <shachaf> @ty fromMaybe
19:24:19 <lambdabot> a -> Maybe a -> a
19:24:25 <shachaf> @ty \warn -> maybe warn id
19:24:26 <lambdabot> b -> Maybe b -> b
19:24:27 <Aetherspawn_> Oh, fromMaybe was what I was looking for
19:24:33 <Aetherspawn_> Thanks
19:25:14 <startling> applicative_: does that actually help? neat.
19:26:20 <tgeeky> mono dyslexic looks unstable to me, like it should be wiggling
19:27:31 <applicative_> tgeeky: I thought that at first -- i'm not dyslexic, I was just impressed by some remarks when it came out
19:27:54 <applicative_> it took a day or two, now everything else looks like meaningless trash.
19:28:01 <applicative_> maybe it's made me dyslexic!
19:28:11 <tgeeky> applicative_: I suspect it doesn't work that way
19:28:31 <applicative_> it definitely took getting used to.
19:29:00 <startling> mono dyslexic looks very 60s to me.
19:29:52 <applicative_> startling I would probably agree, but in my terminal, you're talking in it....
19:30:13 <startling> groovy
19:30:19 <applicative_> hah
19:36:29 <dav> can we use guards in the repl?
19:36:36 <dav> case x of _ { | x < 5 -> "a"; | otherwise -> "b" }
19:36:45 <dav> (generates a parse error)
19:36:47 <shachaf> No { } and no ; necessary.
19:36:58 <shachaf> case x of _ | x < 5 -> "a" | otherwise -> b
19:37:07 <dav> oh cool
19:37:08 <dav> thanks
19:37:17 <shachaf> (In GHC 7.6: -XMultiWayIf; if | ... -> ... | ... -> ...)
19:38:02 <dav> very nice
19:38:44 <dav> alrihgt I'm turning in for the nite
19:38:50 <dav> thx
19:38:53 <mekeor> gnight :)
19:38:59 <tabemann> question - is there a convenient way to spit out bytestrings that are null-terminated?
19:41:09 <applicative_> hoogle newCString --?
19:41:18 <applicative_> @hoogle newCString
19:41:18 <lambdabot> Foreign.C.String newCString :: String -> IO CString
19:41:18 <lambdabot> Foreign.C.String newCStringLen :: String -> IO CStringLen
19:41:41 <applicative_> Marshal a Haskell string into a NUL terminated C string.
19:41:42 <applicative_> * the Haskell string may not contain any NUL characters
19:41:46 <applicative_> ick
19:41:56 <geekosaur> duh?
19:42:17 <geekosaur> you *can't* embed a NUL in a C string. period.
19:42:37 <tabemann> and then... is there a convenient way to unwrap a CString into a Ptr CChar?
19:42:45 <applicative_> oh, I was saying 'ick' to the idea of a C string
19:42:57 <tabemann> because the code I'm feeding this into expects a Ptr GLchar, and I can cast that from Ptr CChar
19:43:08 <applicative_> type CString = Ptr CChar
19:43:14 <tabemann> oh okay
19:43:57 <tabemann> that's actually... a lot more straightforward than how I was handling converting Strings into (un-null-terminated) Ptr GLchar
19:44:55 <tabemann> I was packing it into Text, then feeding that through encodeUtf8 into a ByteString, and then calling toForeignPtr and then withForeignPtr on that...
19:45:57 <tabemann> wait... how is memory management handled with newCString/newCStringLen?
19:46:31 <tabemann> because if it is spitting out a raw Ptr CChar or (Ptr CChar, CSize) (or whatever integer type), who's cleaning up after it?
19:47:25 <applicative_> "* new storage is allocated for the C string and must be explicitly freed using Foreign.Marshal.Alloc.free or Foreign.Marshal.Alloc.finalizerFree. "
19:47:32 <shachaf> tabemann: You do, with free.
19:47:42 <tabemann> just saw that when I looked up the call
19:49:22 <tabemann> oh, withCStringLen looks nicer
19:49:28 <applicative_> the solution is plain tabemann, write a pure haskell replacement for openglraw
19:50:52 <tabemann> that's quite the project there
19:51:08 <tabemann> that's... a lot of wrapping to do
19:51:54 <applicative_> well, yes, but then the rest of use can just use sensible types and not worry about NUL and Ptr Blah &c.
19:51:57 <aoshi> if I use readFile and then, depending on whatever, later in main use appendFile (on the same file), am I asking for trouble wrt laziness?
19:52:16 <applicative_> yes
19:52:39 <applicative_> but arent you asking for trouble just kind of obviously
19:53:16 <applicative_> appendFile will append to the 'real file' though, if I understand.
19:54:21 <aoshi> would the proper thing to do then, be to openFile, hGetContents, do stuff, hClose and then append?
19:54:52 <ski> never `hClose' a handle you've passed to `hGetContents'
19:55:56 <tabemann> as the contents of the file are read lazily, and the file is automatically closed when it goes out of scope
19:55:58 <aoshi> how about using System.IO.Strict for the readFile in the first scenario
19:56:31 <applicative_> hm, that works, I mean, the equivalent, inside ghci
19:57:11 <applicative_> readFile "a" >>= \content -> print (length content) >> appendFile "a" content
19:58:01 <tabemann> I wonder if that would work, though, if content were not fully evaluated before appendFile was called
19:58:28 <monochrom> hGetContents is pretty much readFile
19:58:40 <tabemann> readFile just opens the file for you too
19:58:45 <applicative_> tabemann: inside ghci, an inverted world in anycase, I get the predicatable openFile: resource busy (file is locked)
19:59:23 <applicative_> if i do, say readFile "a" >>= appendFile "a"
20:00:27 <applicative_> the trick of System.IO.Strict if I remember is just to use length on the string
20:01:05 <applicative_> readFile "a" >>= \content -> length content `seq` appendFile "a" content
20:01:42 <applicative_> which is a little shorter than import qualified System.IO.Strict as Hack
20:01:52 <aoshi> nice!
20:03:06 <tabemann> for efficiency's sake, wouldn't it be a better idea to use lazy bytestrings here, so you're not literally reading the file character by character (fewer round trips into the OS, that is)?
20:05:01 <tabemann> also if you use normal, rather than Char8, bytestrings, as it's being read as octets rather than as characters, no character conversions will occur between the reading and the appending
20:18:14 * hackagebot testloop 0.1.0.0 - Quick feedback loop for test suites  http://hackage.haskell.org/package/testloop-0.1.0.0 (RomanGonzalez)
20:46:35 <tabemann> very stupid syntax question
20:47:06 <tabemann> can you put a "where" clause inside of a function definition, or can they only be *outside* them
20:51:05 <enthropy> they are already inside, in the sense that you're allowed two in:    `f 1 = x where x = 2; f y = z where z = y+1'
20:51:36 <applicative_> > f x = let g z = h z where h y = 1  in g x  in f 3
20:51:37 <lambdabot>   <hint>:1:5: parse error on input `='
20:51:43 <applicative_> :(
20:51:47 <enthropy> too much in
20:51:51 <tabemann> what I meant was like this
20:51:56 <tabemann> foo x =
20:52:05 <tabemann>   baz y x
20:52:23 <tabemann>     where baz = ...
20:52:28 <tabemann>   where y = ...
20:52:57 <enthropy> you can nest them the other way around
20:52:59 <tabemann> where baz needs to be scoped so that it knows something inside the rest of the function
20:53:36 <tabemann> I ended up just changing my code to use lets instead of the inner wheres
20:54:01 <applicative_> > let  f x = let g z = h z where h y = 1  in g x  in f 3
20:54:02 <lambdabot>   1
20:54:11 <ski> tabemann : perhaps you should paste your code in question ?
20:54:17 <applicative_> forgot the initial 'let' as usual
20:54:45 <tabemann> the question is hypothetical as I changed my code to use inner lets now
20:54:50 <shachaf> tabemann: "where" isn't part of an expression. It's part of "=" of a binding (or "->" of case).
20:54:52 <applicative_> tabemann: the definitions of baz and y should be on a level with each other
20:54:57 * ski recalls when lambdabot accepted `> x where x = 0'
20:55:10 <shachaf> But in this case you could put both y and baz in the same where.
20:55:23 <tabemann> shachaf: that's what I was wondering about
20:55:24 <ski> depends on what tabemann wanted
20:55:36 <ski> (note there's a `y' parameter as well)
20:57:29 <tabemann> http://hpaste.org/88979
20:59:16 <tabemann> that's the code I was asking about
21:00:05 <shachaf> OK, so baz isn't just an expression, it's a binder.
21:00:44 <applicative_> the first where is mysteriously placed I can't tell what the compiler would think
21:01:09 <applicative_> its aligned with a do block
21:03:15 * hackagebot stm-conduit 2.1.0 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-2.1.0 (ClarkGaebel)
21:05:34 <applicative_> I see, it doesn't matter, that it fits with the do block is an accident. It's that you have two would-be co-equal wheres
21:07:10 <tabemann> the big reason for the inner where is that putValue needs to see valuesPtr, i.e. it needs to be inside the function \valuesPtr -> do ...
21:09:13 <ski> yes, as shachaf said, `where' attaches to defining equations `... = ...' and to branches `... -> ...'
21:09:18 <applicative_> oh I see you are using valuePtr in it; i missed that
21:10:08 <ski> if you write `foo = do x <- bar; baz y where y = f x', this gets parsed as `foo = (do x <- bar; baz y) where y = f x'
21:10:23 <ski> the `x' from `x <- bar' isn't in scope in `f x'
21:10:31 <tabemann> okay, so where is always attracted to the outer =
21:10:39 <tabemann> that is what I had suspected
21:10:42 <ski> yep
21:11:17 <ski> so you either do a `let'-in-`do' here, or you parameterize `putValue' by `valuesPtr' as well
21:11:28 <applicative_> http://hpaste.org/raw/88979 tabemann
21:11:39 <applicative_> for an easy escape hatch
21:11:40 <tabemann> but because I want to use foldM, putValue has to have the type signature it has
21:13:06 <ski> tabemann : saying `foldM (putValue valuesPtr) 0 values' and later `where putValue valuesPtr index value = do ...' would work just fine
21:13:59 <tabemann> I'm used to not using partial application much, so I missed that
21:14:23 <tabemann> (I often have to go back and add partial application to places where I missed opportunities for it in my code)
21:14:31 <ski> (or `foldM (\index value -> putValue valuesPtr index value) 0 values', if you insist)
21:14:42 <applicative_> or rather http://hpaste.org/raw/88979 looks a little better
21:14:45 <ski> tabemann : comes with practice
21:14:52 <shachaf> Hooray, progress on 7633!
21:15:29 <ski> applicative_ : .. is there a reason you're pasting the raw version of tabemann's original paste ?
21:16:26 <ski> (or rather, s/pasting/referring to/)
21:16:40 <applicative_> hm, who is lemming
21:16:50 <shachaf> Henning
21:16:56 <applicative_> ski: yeah, I was showing a simple variant that doesnt have this problem
21:17:01 <tabemann> okay that looks nicer; I'm used to the func $ \foo -> do <newline> code idiom and've been using that a lot
21:17:52 * applicative_ hate lambdas ; loves the lambda calculus
21:18:16 * hackagebot repa 3.2.3.3 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-3.2.3.3 (BenLippmeier)
21:18:16 <blackdog> shouldn't that be "scumbag applicative_" ?
21:19:35 <blackdog> :)
21:19:48 <shachaf> I,I (`runContT` return) $ do { foo <- ContT func; ... }
21:19:51 <shachaf> Flat CPS!
21:19:59 <ski> scumbag_applicat : perhaps you meant to link to <http://hpaste.org/88979#88981>,<http://hpaste.org/88979#88982>,<http://hpaste.org/88979#88983> ?
21:20:47 <scumbag_applicat> yeah, that would have happened automatically, but hpaste isn't showing in here
21:21:56 <scumbag_applicat> from now on, I'm using sprunge to get back at scumbag_ski
21:23:16 * hackagebot repa-examples 3.2.3.2 - Examples using the Repa array library.  http://hackage.haskell.org/package/repa-examples-3.2.3.2 (BenLippmeier)
21:33:48 * scumbag_applicat is too dumb for these pipes types
21:34:32 <scumbag_applicat> maybe you just have to make a lifestyle of them; I should ask Tekmo if there's some sensible project that needs done
21:34:43 * scumbag_applicat saint_applicative
21:48:02 <boothead> anyone else up at 0530 to get their haskell fix?
21:48:07 <irene-knapp> no
21:48:29 <irene-knapp> it's 12:48 AM here, because I'm in a timezone that observes twelve-hour-savings time
21:49:30 <boothead> wow you're vitamin D must be either off the charts or very deficient! (I don't the have the brain power to work out which at 05:30)
21:49:43 <boothead> or spell s/you're/your/
21:49:52 <irene-knapp> I have narcolepsy, actually
21:49:55 <irene-knapp> so I take Provigil for it
21:50:00 <irene-knapp> but I took a bit much today I think
21:50:43 <boothead> oops!
21:51:16 <irene-knapp> yes
21:52:52 <boothead> have you done much work with State(T) irene-knapp? do you know if there's a way to defer a get to a later point in time?
21:53:16 <irene-knapp> a fair amount yes
21:53:25 <irene-knapp> there is not, but I'm not sure what you mean
21:53:37 <irene-knapp> you could certainly do it with a custom monad
21:53:48 <irene-knapp> edwardk I believe was the author of an Acme package that makes time run backwards :)
21:54:02 <oio_> how do i update baskell platform uninstall and update or install it on top
21:54:13 <mzero> which OS?
21:54:36 <boothead> yes I saw that one - I don't fancy my chances right now if I can't even work out daylight savings in my head!
21:54:43 <irene-knapp> yes, haha!
21:54:57 <mzero> oio_: which OS?
21:55:00 <irene-knapp> US/Eastern, where I am, is UTC minus 04:00 right now, by the way
21:55:13 <oio_> os x
21:55:14 <irene-knapp> I can never remember whether DST is in effect in the summer, or in the winter, but whichever
21:56:02 <mzero> oio_: easy then - do you want two versions? if not use the command line utility   uninstall-hs
21:56:12 <mzero> you can run it before you install the new one, and wipe out EVERYTHING
21:56:18 <boothead> so my problems is parsing json off of a bunch of scraped html pages and generating haskell data types from them for an api library
21:56:26 <mzero> or you can run it after you install the new one, and wipe out just the old
21:57:03 <mzero> json scraped from html...?   we must go deeper....
21:57:31 <boothead> the issues is that some of them refer to others as subobjects and i'd like to be able to generate the proper fieldName :: SubObject
21:57:51 <irene-knapp> boothead: which html pages lol
21:58:11 <boothead> mzero/irene-knapp: example - https://dev.freeagent.com/docs/estimates
21:58:13 <mzero> oio_: uninstall-hs, btw, comes with the platform
21:58:24 <oio_> oj unistalling
21:58:26 <oio_> ok
21:58:30 <irene-knapp> oh, hmmmm
21:58:39 <irene-knapp> so you're making an automatic binding to their web API
21:58:48 <irene-knapp> sounds productive, actually
21:58:57 <mzero> OMG - did you look at how that json was rendered in the HTML?
21:58:59 <irene-knapp> you're certain they have no machine-readable form of the information?
21:59:07 <irene-knapp> no, I skimmed
21:59:09 <mzero> man have you got a night's work ahead of you!
21:59:17 <boothead> on that page I get a list of pages to crawl from the right pane and I would like to generate modules for all the types
21:59:33 <irene-knapp> looks fine.  it's wrapped in <code class=json>
22:00:05 <irene-knapp> boothead: I'm aware of a few grammars of Haskell in Haskell, but none that can actually generate output
22:00:11 <boothead> mzero: reading the json is the easy bit :-) https://github.com/perurbis/hfreeagent/blob/master/fa-gen-types/Main.hs#L76
22:00:24 <irene-knapp> if you create such a thing, hs-src-exts is the best one to add it to I suspect
22:00:25 <mzero> look inside, irene-knapp --- it's filled with many spans!
22:00:40 <irene-knapp> oh whoa, it actually does have a generator!
22:01:01 <boothead> irene-knapp: except I have to just get all the code elems because the left off the class=json on some on some
22:01:12 <mzero> just looks to me, boothead, like the kind of thing where it all seems regular... but it was generated by hand, and you're likely to run into pages that messed up...
22:01:21 <irene-knapp> hm, I don't actually see any spans on that particular page mzero, but I will take your work for it
22:01:29 <irene-knapp> word, too
22:01:40 <irene-knapp> but that's pretty easy to strip with tidy + xpath, really
22:01:46 <boothead> mzero: I think that's actually fairly standard pygments type output
22:01:47 <mzero> look inside that <code> block
22:01:56 <irene-knapp> there are multiple
22:02:03 <irene-knapp> anyway I do believe you, I assume I'm just blind
22:02:46 <boothead> mzero: irene-knapp: HandsomeSoup is your friend here: jsonBlocks = runX $ doc >>> css "code" //> getText
22:02:51 <irene-knapp> ah, nice!
22:02:53 <irene-knapp> good to know that trick
22:03:15 <irene-knapp> anyway, haskell-src-exts is your friend for generating the output, leaving you with only the interesting part
22:04:50 <boothead> I'm cheating vis haskell-src-exts I've just made my own representation as haskell-src-exts scared me when I was playing with Fay
22:05:01 <irene-knapp> ah, okay then
22:06:28 <codetaku> I'm a total beginner at Haskell, not having trouble with the functional aspects but just getting the syntax down... could anyone be so kind as to tell me why I get a 'paste error on `='' error from this code?  http://hpaste.org/88984
22:07:09 <ski>   let strand = ...
22:07:10 <boothead> i acutally had this working in the simple case of a json representation of 'type_name': <json object> is't handling the other cases like 'type_name_plural': [<json object>] that's a bit more tricky
22:07:12 <mzero> codetaku: in a do block you need to say     let strand =
22:07:13 <ski>       output = ...
22:07:30 <irene-knapp> boothead: ah yes…. I almost wrote a library once that did English morphology for exactly this reason
22:07:39 <codetaku> ahh, thank you, I didn't realize I needed a let there
22:07:43 <irene-knapp> (using _A Comprehensive Grammar of the English Language_ as my reference...)
22:07:46 <irene-knapp> but I lost interest halfway through
22:07:50 <irene-knapp> also it was in Lisp :(
22:08:01 <ski> codetaku : also `putStrLn (show output)', which can be written simply as `print output'
22:08:05 <ski> @src print
22:08:05 <lambdabot> print x = putStrLn (show x)
22:08:12 <johnw> irene-knapp: I have that book; it is not in Lisp. :)
22:08:19 <irene-knapp> lol, no, my code was ;)
22:08:23 <codetaku> ah, nice, thanks ski
22:08:24 <irene-knapp> good book, innit?
22:08:32 <johnw> yeah, pretty awesome reference
22:08:43 <irene-knapp> boothead: you are probably best served by making a first pass that does a word concordance, then going through that concordance by hand and entering singular/plural forms
22:08:55 <ski>   strand <- liftM fromString getLine  -- would also be possible, to avoid naming `input'
22:09:04 <irene-knapp> it's great for not actually settling grammar debates because it's descriptivist :)
22:10:18 <codetaku> is there a way to suppress the quotes from being output from print?
22:10:21 <boothead> johnw/ irene-knapp: is there stuff like "i before e (except after c)" in the book?
22:10:23 <ski> codetaku : .. and in case you're prefer not to name `n', you could say `(_,x) <- ...'
22:10:38 <johnw> boothead: it's mainly about grammar, not orthography
22:10:41 <irene-knapp> boothead: and ALL the sub-cases of those rules,  yes, it's in there
22:10:42 <ski> codetaku : don't use `show' on the string ?
22:10:50 <irene-knapp> it's mainly about grammar but it DOES have orthography :)
22:10:54 <cmears> codetaku, use putStr if you already have a String
22:11:03 <irene-knapp> I think my copy may have been in the fire :(
22:11:04 <ski> or `putStrLn'
22:11:05 <codetaku> they're Ints
22:11:08 <irene-knapp> so I need to get it again :(
22:11:21 <ski> codetaku : `output' looks like a string to me
22:11:25 <irene-knapp> but I need to make sure I don't still have it first, lol, cause of it's expensive
22:11:37 <codetaku> ah, I see what you are saying
22:11:39 <boothead> I can see how I might confuse it with lisp :-), just to show you how much I don't know about both list and grammar
22:11:53 <irene-knapp> yeah hehe
22:12:57 <mzero> codetaku: http://hpaste.org/88984
22:13:21 <torkjak> Is Ross Paterson still the guy to contact for a hackage account?
22:13:47 <codetaku> that's very helpful mzero, thank you!  What is intercalculate?  I haven't seen it before
22:13:48 <mzero> codetaku: separate out your pure and non-pure code, and you can avoid all those "let"s -
22:13:49 <ski>   main = putStrLn . process =<< getLine  -- codetaku, or this
22:13:59 <mzero> :hoogle intercalate
22:14:06 <ski> @index intercalate
22:14:06 <lambdabot> bzzt
22:14:13 <ski> @type Data.List.intercalate
22:14:14 <lambdabot> [a] -> [[a]] -> [a]
22:14:23 <mzero> > intercalate "-" ["one", "two", "apples"]
22:14:24 <lambdabot>   "one-two-apples"
22:14:53 <ski> > concat [x ++ " " | x <- ["one", "two", "apples"]]
22:14:54 <lambdabot>   "one two apples "
22:14:56 <mzero> it is the moral equivalent of join in JavaScript or python
22:15:18 <ski> > unwords ["one", "two", "apples"]
22:15:19 <lambdabot>   "one two apples"
22:16:09 <codetaku> I take it I need to import Data.List to use intercalate?  Or is Data.List part of Prelude?
22:16:11 <mzero> so, intercalate is the join from JavaScript  or Python
22:16:21 <mzero> don't remember!
22:16:29 <ski>   import Data.List (intercalate)  -- e.g.
22:16:48 <mzero> though notice hlint's suggestion on that page:    intercalate " "   is just   unwords    - which is in the Prelude
22:16:49 <ski> it's separate from `Prelude', you need to import it if you want it
22:21:47 <NinjaPenguin> Do you really have to write `mod` or is there a better way, without the `?
22:22:13 <mzero> > mod 7 2
22:22:14 <lambdabot>   1
22:22:15 <m3ga> NinjaPenguin: mod 10 3?
22:22:15 <cmears> you could write "let (%%) = mod"
22:23:01 <mzero> so, no, you don't have to write `mod`   :-)
22:23:15 <NinjaPenguin> mzero, m3ga: Alright, thanks. :)
22:24:15 <dmj> NinjaPenguin: you do if its infix
22:24:48 <dmj> > 4 `mod` 5
22:24:49 <lambdabot>   4
22:24:58 <dmj> > 4 mod 5
22:24:59 <lambdabot>   4
22:25:05 <dmj> oh, hmmmm...
22:25:26 <mzero> no no - don't look at that... that is just lambdabot insantity defining numbers to be functions!
22:25:30 <dmj> that has to be a lambdabot thing, my ghci throws up
22:25:43 <dmj> mzero: ah good, I'm not crazy
22:26:30 <mzero> > 8 "goofy"
22:26:30 <lambdabot>   8
22:26:30 <mzero> 9 undefined
22:26:31 <mzero> > 9 undefined
22:26:31 <lambdabot>   9
22:27:13 <mzero> for reasons that seem to be here only to confuse most of us, lambdabot's modules include an instance for   Num (a ->)
22:27:32 <mzero> :info Num
22:29:09 <dmj> > :i Num
22:29:11 <lambdabot>   <hint>:1:1: parse error on input `:'
22:29:30 <dmj> > :info Num
22:29:31 <startling> it's not confusing! it's so you can do
22:29:31 <lambdabot>   <hint>:1:1: parse error on input `:'
22:29:47 <startling> > ((+ 1) + (+ 2)) 4
22:29:48 <lambdabot>   11
22:30:55 <pavid> map (+1) [1,2,3,..]
22:31:01 <pavid> map (+1) [1,2,3]
22:31:20 <ski> you forgot the initial `> '
22:31:21 <pavid> > map (+1) [1,2,3]
22:31:22 <startling> pavid, forgot the >
22:31:22 <lambdabot>   [2,3,4]
22:31:29 <pavid> yeah just realized that.
22:31:33 <ski> > map (sin^2 + cos^2) [0,pi/4,pi/3]
22:31:34 <lambdabot>   [1.0,1.0,1.0]
22:32:03 <pavid> Discovered Haskell not too long ago. It's magical.
22:32:16 <ski> > map ((id^2 + id) / 2) [0 .. 9]  -- triangular numbers, by a polynomial
22:32:17 <lambdabot>   [0.0,1.0,3.0,6.0,10.0,15.0,21.0,28.0,36.0,45.0]
22:32:30 <pavid> I wish I could find a way to apply it to embedded systems, though.
22:32:59 <tabemann> considering that it's garbage collected kind of makes it hard to use it for that, especially that it uses a stop-the-world garbage collector
22:33:14 <tabemann> particularly since most embedded systems are realtime systems
22:33:17 <pavid> yeah
22:33:46 <pavid> I'm working with software defined radios, too
22:33:51 <tabemann> hell, in a lot of embedded environments they don't even use dynamic memory allocation
22:33:54 <pavid> but I already have a platform for that.
22:34:13 <shachaf> pavid: People use Haskell to generate code for embedded systems sometimes.
22:34:19 <startling> ^ yeah
22:34:23 <shachaf> @hackage atom is an example
22:34:23 <lambdabot> http://hackage.haskell.org/package/atom is an example
22:34:41 <pavid> Did that bot just copy you?
22:34:47 <pavid> Oh I see what happened
22:34:49 <pavid> lol that's awesome.
22:35:16 <mzero> also - some embedded systems are big enough - and the HalVM project lets you run Haskell RTS without an O.S. present
22:35:19 <mzero> (mostly)
22:35:31 <shachaf> @hackage copilot
22:35:31 <lambdabot> http://hackage.haskell.org/package/copilot
22:36:04 <lispy> mzero: when you say (mostly) you're referring to xen?
22:37:10 <mzero> well - yes, HalVM uses just the xen primitives- but one could imagine porting it to bare metal
22:44:25 <unlink> I'm having trouble writing an instance for my existential type... http://hpaste.org/88990
22:45:10 <boothead> is there a function to map a function a -> State b over a list of a feeding the same state through?
22:45:16 <boothead> is it just mapM?
22:46:28 <ski> `mapM' yes
22:46:29 <ski> also
22:46:41 <ski> @type mapAccumL
22:46:42 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
22:46:44 <ski> @type mapAccumR
22:46:46 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
22:48:43 <boothead> ski: thanks, so I can use mapAccumL and get/set will be working with the built up state from the start of the list?
22:49:30 <ski> unlink : `instance Target (t A) => Target (Any t)' isn't enough, you'd need `instance (forall v. Val v => Target (t v)) => Target (Any t)' (which you can't actually write)
22:50:06 <ski> boothead : if you want to use `mapAccumL' with `State', you'll need to wrap it up
22:50:09 <dmj> @type forM
22:50:11 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
22:50:52 <ski> boothead : so if you want `State', you probably want `mapM'
22:51:32 <shachaf> Or `traverse'.
22:51:35 <boothead> @type mapM
22:51:36 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
22:52:37 <dmj> @type (flip mapM)
22:52:38 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
22:52:43 <dmj> @type forM
22:52:44 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
22:52:49 <ski> @src forM
22:52:49 <lambdabot> forM = flip mapM
22:53:04 <dmj> @src length
22:53:04 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
22:53:10 <boothead> ski... hmmm what I really want is to build up my state object over the list. I don't care about the result of each individual element
22:53:24 <ski> boothead : so `mapM_' ?
22:53:25 <shachaf> Sounds like a fold.
22:53:49 <boothead> mapM_ and then execState?
22:53:54 <ski> e.g.
22:54:09 <ski> or just a fold, in case you decide to skip `State'
22:54:55 <boothead> ski shachaf thanks guys
22:55:02 <shachaf> You should use a fold.
22:55:22 <shachaf> Learn to think a new way. Then you can use State if you still want to.
22:56:26 <ski> @type (execState .) . mapM_ . ((state . ((,) () .)) .)
22:56:28 <lambdabot> (a -> s -> s) -> [a] -> s -> s
22:56:29 <ski> @type flip . foldl . flip
22:56:29 <shachaf> @ty \f s xs -> execState (mapM_ (modify . f) xs) s
22:56:30 <lambdabot> (b -> c -> c) -> [b] -> c -> c
22:56:31 <lambdabot> (a -> s -> s) -> s -> [a] -> s
22:56:31 <shachaf> @ty foldr
22:56:32 <lambdabot> (a -> b -> b) -> b -> [a] -> b
22:57:12 <shachaf> Well, OK.
22:57:30 <ski> @type (execState .) . mapM_ . (modify .)  -- *nod*, nicer
22:57:31 <lambdabot> (a -> s -> s) -> [a] -> s -> s
22:57:52 <shachaf> It's foldl, indeed.
22:57:53 <boothead> shachaf: actually you're right - I might be able to use fold now. thanks
22:58:12 <shachaf> You can always use a fold. Sometimes it's more awkward. Sometimes State is more awkward.
22:58:48 <shachaf> But you should try both ways, as a person just learning about State. State is tempting, but sometimes figuring out how to do without it can help you understand what your problem really is.
22:59:43 <ski> > foldl (flip const) () [(),(),()]  -- using a fold to compute `()'
22:59:44 <lambdabot>   ()
23:03:35 <adnap> ski: What is the point of that?
23:06:18 <ski> no point
23:29:39 <lispy> > scanl (flip const) () [(),(),()] -- it's nice to see the intermediate steps
23:29:41 <lambdabot>   [(),(),(),()]
