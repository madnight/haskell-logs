00:37:12 <Ralith> is there a way to do file-scope disabling of warnings in ghc similar to how extensions can be enabled?
00:37:15 <Ralith> specific warnings, that is
00:37:25 <tikhonjelvis> yeah
00:37:30 <tikhonjelvis> use a ghc flags pragma
00:37:46 <tikhonjelvis> options_ghc
00:38:00 <tikhonjelvis> {-# OPTIONS_GHC -fno-warn-whatever #-}
00:39:33 <Ralith> ah, thanks
00:40:09 <Ralith> is there a list of the bindings anywhere?
00:40:13 <Ralith> er
00:40:19 <Ralith> a list of the warning names
00:40:32 <tikhonjelvis> http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/options-sanity.html
00:41:01 <Ralith> much apprecitaed
00:41:02 <tikhonjelvis> all of the -fwarn-whatever flags can be negated as -fno-warn-whatever, I believe
00:41:07 <Ralith> man my typing is crap tonight
00:41:26 <tikhonjelvis> no worries
00:41:38 <typoclass> -fno-worries
00:41:44 <tikhonjelvis> heh
00:42:09 <tikhonjelvis> maybe -fno-warn-typos
00:42:33 <tikhonjelvis> some of the offical warning names are amusing
00:42:44 <Araneidae> Is there a simple monadic interface for generating strings?  I want to build a fairly complex MyType->String and lots of joining strings with ++ gets annoying
00:42:52 <tikhonjelvis> like -fwarn-dodgy-foreign-imports
00:42:54 <Araneidae> Or is there some other idomatic way of generating text
00:43:04 <tikhonjelvis> I think you want the Writer monad
00:43:14 * Araneidae goes look
00:43:20 <typoclass> Araneidae: how about concat?
00:43:32 <typoclass> > concat ["abc", "def", "ghi"]
00:43:33 <lambdabot>   "abcdefghi"
00:43:40 <typoclass> > unwords ["abc", "def", "ghi"] -- or this
00:43:40 <Araneidae> typoclass, well, I've tried generating a list of strings and joining them like that, yes
00:43:42 <lambdabot>   "abc def ghi"
00:43:47 <tikhonjelvis> :t tell
00:43:48 <lambdabot> MonadWriter w m => w -> m ()
00:43:49 <Araneidae> But it seems unsatisfactory
00:44:20 <tikhonjelvis> > runWriter $ do tell "foo"; tell " bar"
00:44:22 <lambdabot>   ((),"foo bar")
00:44:34 <tikhonjelvis> you can also have it generate a result
00:44:37 <Araneidae> tikhonjelvis, that looks just the ticket
00:44:39 <tikhonjelvis> > runWriter $ do tell "foo"; tell " bar"; return 10
00:44:41 <lambdabot>   (10,"foo bar")
00:44:49 <Araneidae> :t runWriter
00:44:51 <lambdabot> Writer w a -> (a, w)
00:44:57 <tikhonjelvis> and it's a transformer, so you can use it with other monads
00:45:07 <Araneidae> tvm
00:45:09 <tikhonjelvis> > runWriterT $ do tell "foo"; lift (print "bar"); tell " bar"; return 10
00:45:13 <lambdabot>   No instance for (GHC.Show.Show
00:45:13 <lambdabot>                     (GHC.Types.IO (a0, [GHC....
00:45:19 <tikhonjelvis> well, maybe not on lambdabot
00:45:48 <tikhonjelvis> but you get the idea
00:46:23 <Araneidae> I do indeed, thanks
00:49:01 <Araneidae> Oh, I remember: the Writer joins its writes together with mappend -- now it makes sense!
00:49:07 <tikhonjelvis> yep
00:50:19 <Araneidae> If my strings were numerous and enormous ... would I care about the inefficiency of ++?  (Fortunately they're not)
00:50:25 <tikhonjelvis> umm
00:50:32 <tikhonjelvis> depends on how numerous and how enormous
00:50:36 <tikhonjelvis> and how much you care about performance
00:50:50 <Araneidae> let's say I do and let's say they were humongous
00:50:52 <tikhonjelvis> I tend to follow the heuristic that if it's not undecideable, it's good enough
00:50:58 <Ralith> Araneidae: in short: you could use another type instead of String at that point
00:51:08 <Araneidae> Quite, sounds like the appropriate answer
00:51:14 <Araneidae> Right, not my problem yet
00:51:24 <Ralith> unless you can comfortably build your strings backwards or something
00:51:37 <Araneidae> yeah.  No, let's not go there
00:55:17 <supki> Araneidae: you should care to not nest (++) like (((... ++ ...) ++ ...) ++ ...) but (... ++ (... ++ (... +++ ...))) is fine
00:55:48 <supki> Araneidae: (++) traverses its left argument, so the former is O(n^2) while the latter is O(n)
00:56:24 <Araneidae> I get it.  Presumably concat uses the appropriate fold
00:56:39 <supki> yes
01:03:31 <refold> kosmikus: ping
01:06:47 <latermuse> is there a (++) that traverses its right argument?
01:07:04 <mm_freak> latermuse: how would that work?
01:07:15 <mm_freak> x ++ (y:ys) = ?
01:07:58 <mm_freak> btw, (++) is fine, if you associate it to the right
01:08:04 <mm_freak> bad: (x ++ y) ++ z
01:08:08 <mm_freak> good: x ++ (y ++ z)
01:08:09 <latermuse> if programming were invented by the arabs, we would surely have right traversing concatenations
01:08:36 <tikhonjelvis> well, you can get that by defining a new type like newtype ReversedList a = [a] :P
01:08:50 <mm_freak> except for the syntax error, yeah =P
01:08:58 <tikhonjelvis> put another way, the direction your list is going is just a matter of perspective
01:09:21 <tikhonjelvis> woah, that is a syntax error
01:09:22 <tikhonjelvis> boo
01:09:22 <mm_freak> tikhonjelvis: only in a total language
01:09:35 <mm_freak> > fix ("blah" ++)
01:09:37 <lambdabot>   "blahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahbl...
01:10:01 <mm_freak> (++) WHNF is O(1) when used right-associatively
01:10:08 <tikhonjelvis> my point was that you can take a normal list and pretend the head is the end and the rest of it is reversed
01:10:29 <mm_freak> tikhonjelvis: what does that mean?
01:10:58 <tikhonjelvis> it's in relation to the commend about arabs
01:11:16 <tikhonjelvis> that is, just writing something from right to left doesn't change what it actually is
01:12:14 <quchen> Eh no, the head of a list is never its end.
01:12:25 <mm_freak> tikhonjelvis: lists have a head element…  if you interpret that as the last element you lose your ability to deal with infinite lists and suddenly all operations become horribly slow
01:12:27 <quchen> As in "in no possible interpretation".
01:12:48 <mm_freak> so i don't quite agree that it's a matter of perspective
01:12:51 <latermuse> tikhonjelvis: is it possible to have a list that can be traversed in either direction in O(n)?
01:13:00 <latermuse> concat in either direction i mean
01:13:03 <tikhonjelvis> it wouldn't be a list any more
01:13:23 <mm_freak> latermuse: you always concat from left to right, don't you?  don't confuse associativity with commutativity
01:13:37 <latermuse> yes im confused
01:13:52 <mm_freak> foldr doesn't fold from the right either…  the fold goes from head to tail
01:14:05 <pete_> this point has confused me since I learned it a long time ago
01:14:55 <mm_freak> in fact i'd say that foldr is probably much more left-oriented than foldl
01:15:32 <mm_freak> for example foldr has O(1) WHNF, i.e. it gives an answer for the 'left' quickly
01:15:52 <quchen> foldr should probably be called fold, and foldl "packedipack" or something.
01:16:01 <mm_freak> yeah
01:16:06 <tikhonjelvis> packedipack
01:16:07 <typoclass> quchen: absolutely
01:16:31 <mm_freak> foldl isn't a real categorical fold anyway
01:18:05 <quchen> ... whatever that is
01:19:10 <typoclass> quchen: the real sturdy german-engineered thing. as opposed to the cheap chinese plastic imitation
01:20:36 <quchen> Kruppstahl!
01:21:18 <hiptobecubic> I realize they are equivalent, but I find it much more obvious to work with 2-3 trees than red-black
01:22:08 <b_jonas> they're not equivalent
01:22:12 <b_jonas> that's just what people say
01:22:13 <mm_freak> quchen: initial algebras denote foldable data structures in a sense, and such a fold must have an identity
01:22:17 <b_jonas> the rotation rules differ
01:22:19 <mm_freak> foldr (:) [] = id
01:22:25 <b_jonas> and the invariants differ too
01:22:25 <mm_freak> foldl ? ? = id?
01:22:27 * hackagebot yesod-json 1.2.0 - Generate content for Yesod using the aeson package. (deprecated)  http://hackage.haskell.org/package/yesod-json-1.2.0 (MichaelSnoyman)
01:22:29 * hackagebot yesod-default 1.2.0 - Default config and main functions for your yesod application (deprecated)  http://hackage.haskell.org/package/yesod-default-1.2.0 (MichaelSnoyman)
01:23:38 <hiptobecubic> b_jonas, no they don't.
01:23:48 <Araneidae> How do I project out one element of a tuple?  Something like (1,2)!!0 except that doesn't work...
01:23:59 <pete_> fst
01:24:03 <typoclass> > fst (1,2)
01:24:04 <pete_> snd
01:24:08 <lambdabot>   1
01:24:08 <hiptobecubic> b_jonas, take all red edges, make them 3-nodes. There. A 2,3 tree.
01:24:14 <Araneidae> cheers!
01:24:42 <Araneidae> So many names in Haskell.  I guess hoogle "(a,b)->a" should have given me that, come to think of it
01:24:44 <hiptobecubic> b_jonas, possibly under the left-leaning assumption as well. Is that what yo umen?
01:24:46 <hiptobecubic> you mean*
01:24:53 <liyang> > ("hello", 't', 'h', 'a', 'r') ^. _1
01:24:56 <lambdabot>   "hello"
01:25:05 <typoclass> Araneidae: yes, i'm pretty sure hoogle will find that :-)
01:25:24 <typoclass> Araneidae: liyang's example uses the 'lens' library, which is slightly more advanced
01:25:25 <Araneidae> Yes, it does.  I'm finding it a lifesaver when it works, forgot to use it this time
01:26:25 <Araneidae> typoclass, trying to keep my use of advanced techniques under control at the moment -- monad transforms are quite enough, thank you very much!
01:26:43 <liyang> Its chief feature is that it allows you to fool your fellow programmers into thinking you're writing a Perl 6 program.
01:26:53 <Araneidae> Sounds marvellous
01:27:03 <liyang> It's wonderful. :)
01:27:05 <latermuse> liyang: hahaha
01:27:08 <Araneidae> ;^)
01:27:16 <liyang> Araneidae: that's an operator in lens.
01:27:23 <Araneidae> oh God
01:27:44 <latermuse> liyang: what does that operator do?
01:27:47 <Araneidae> Haskell does have a horrible tendency to start looking like Perl I'm finding
01:28:00 <tikhonjelvis> the solution is unicode
01:28:03 <liyang> latermuse: just trolling. :)
01:28:14 <Araneidae> tikhonjelvis, I hope that was a troll!
01:28:29 <mauke> tikhonjelvis: don't worry, perl has excellent unicode support
01:28:29 <latermuse> liyang: like your style
01:28:33 <tikhonjelvis> Hey, I actually like Unicode. It makes your code more readable.
01:28:37 <mm_freak> Araneidae: until you know all those names there is nothing wrong with reinventing those functions =)
01:28:41 <kryft> They say programming languages are converging towards haskell (or lisp depending on whom you ask), but maybe haskell is converging to perl? :P
01:28:43 <latermuse> mauke: all of my perl is written with shift-jis in mind
01:28:45 <mm_freak> myFst (x, y) = x
01:28:45 <mauke> I'm typing in unicode RIGHT NOW!
01:29:02 <Araneidae> mm_freak, sure, but I'm trying to make my fragment of code as clean as I can for future reference
01:29:24 <mm_freak> Araneidae: and if you like abstract algebra, you can define a fold for (,) and do everything in terms of it =)
01:29:53 <mm_freak> foldPair :: (a -> b -> c) -> (a, b) -> c
01:29:59 <mm_freak> (of course that one exists as well)
01:30:14 <mm_freak> :t uncurry const
01:30:19 <lambdabot> (c, b) -> c
01:30:21 <mm_freak> :t uncurry (const id)
01:30:25 <lambdabot> (a, c) -> c
01:31:00 * typoclass scratches his head
01:31:01 <Araneidae> What's the name of that encoding of the lambda calculus where *all* constants can be encoded as pure lambda terms?
01:31:18 <mm_freak> Araneidae: lambda calculus
01:31:19 <Araneidae> Like 0 = \f -> \x -> x (I think)
01:31:23 <tikhonjelvis> Church encoding? There's more than one, really.
01:31:35 <mm_freak> and yes, the encoding is called church encoding
01:31:36 <fenris_mid> hy. how to explicetely tell which type to take if the function in the class takes 0 elements?
01:31:36 <tikhonjelvis> lambda calculus normally doesn't have nonsense like constants
01:31:49 <Araneidae> and s f x = f (s f x) -- think that's an encoding.  Yes, it's CHurch encoding
01:31:52 <mm_freak> fenris_mid: could you rephrase that question?
01:32:06 <mauke> where does this "hy" come from?
01:32:13 <mauke> it's not german either
01:32:19 <fenris_mid> ...
01:32:35 <Araneidae> Got that slightly wrong.  0 f x = x, s n f x = f (n f x)
01:32:56 <mm_freak> mauke: it's gangsta style…  the real world's 1337-speak =)
01:32:57 <fenris_mid> i got a class with a function-declaration; this function takes no arguments. if i want to call the function for an instance of the class, i have to name the instance
01:33:09 <fenris_mid> otherwise haskell can't know which one it is
01:33:10 <mauke> if it takes no arguments, it's not a function
01:33:12 <mm_freak> fenris_mid: if it takes no arguments, it's not a function…  it's just a value
01:33:18 <fenris_mid> mauke: hahaha, go home
01:33:21 <mauke> ?
01:33:51 <mm_freak> fenris_mid: could you paste some code and ask your question in relation to it?  i have a feeling that you may misunderstand type classes a bit
01:33:52 <liyang> I'll take an argument. What's your problem?
01:33:55 <fenris_mid> not a haskell function maybe
01:33:58 <tikhonjelvis> fenris_mid: in real code, chances are the types can get inferred
01:33:58 <mm_freak> @where hpaste
01:33:59 <lambdabot> http://hpaste.org/
01:34:01 <mauke> fenris_mid: this is #haskell
01:34:11 <tikhonjelvis> but it might not work in GHCi
01:34:15 <fenris_mid> ok:
01:34:36 <fenris_mid> i got a class with a _mathematical_function-declaration; this function takes no arguments. if i want to call the function for an instance of the class, i have to name the instance
01:34:43 <fenris_mid> foo :: t
01:34:52 <hiptobecubic> watching educational videos at 150% speed is pretty great
01:34:57 <mauke> fenris_mid: a mathematical function takes an argument
01:35:12 <fenris_mid> no, the source-set can be {()}
01:35:12 <mauke> fenris_mid: also, mathematical functions are applied, not called
01:35:12 <typoclass> > maxBound :: Int -- fenris_mid, here is an example
01:35:13 <tikhonjelvis> Okay, let's pretend foo :: () -> t
01:35:15 <lambdabot>   9223372036854775807
01:35:17 <mauke> fenris_mid: that's still an argument
01:35:19 <hiptobecubic> watching this old man talk like an auctioneer about hash functions
01:35:21 <typoclass> maxBound is defined in this class: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Bounded
01:35:33 <fenris_mid> man ...
01:35:46 <tikhonjelvis> fenris_mid: if you use foo somewhere, its type will probably get inferred
01:35:54 <tikhonjelvis> so you won't have to write it out explicitly
01:35:55 <fenris_mid> and if not?
01:36:06 <tikhonjelvis> then you will have to write it out explicitly
01:36:11 <mauke> fenris_mid: use an explicit type annotation
01:36:11 <tikhonjelvis> but that happens very rarely in practice
01:36:32 <fenris_mid> mauke: exactely that's want i want to know
01:36:37 <fenris_mid> how to do that?
01:36:47 <typoclass> fenris_mid: a type annotation is what i used above, ":: Int"
01:36:49 <mauke> fenris_mid: uh, typoclass showed you how
01:36:51 <mm_freak> fenris_mid: i'm sorry, but your description doesn't really make sense in haskell land…  we could help you much better, if you would paste some code and replace the part that you don't know how to write by "???"
01:37:02 <mauke> and I was about to type that exact example when you interrupted me with "haha, go home"
01:37:30 <fenris_mid> because you said a function has to take explicit arguments
01:37:34 <mm_freak> fenris_mid: to answer the basic question of how to give type signatures:
01:37:38 <mm_freak> > 3 :: Int
01:37:41 <mauke> fenris_mid: technically, one explicit argument
01:37:42 <lambdabot>   3
01:37:48 <mauke> fenris_mid: every function takes exactly one argument
01:37:48 <quchen> > maxBound :: Int -- fenris_mid
01:37:50 <lambdabot>   9223372036854775807
01:38:01 <fenris_mid> thanks, ":: t" does it
01:38:17 <quchen> No ":: t" does it as well most of the time.
01:38:40 <eikke> I wish ghc would be more relaxed towards recursive module imports :(
01:38:48 <mm_freak> fenris_mid: and to clarify about that function thing:  the defining feature of functions is that they can't be applied
01:38:57 <mm_freak> if you can't apply it, it's not a function
01:39:03 <tikhonjelvis> I've found that not having recursive modules forces me to organize my code better
01:39:06 <hiptobecubic> they can*
01:39:07 <tikhonjelvis> which seems to be a net win
01:39:25 <tikhonjelvis> but it really is very annoying sometimes
01:39:25 <fenris_mid> mm_freak: yeah, sorry for my bad english
01:39:29 <mm_freak> oh yeah, they /can/ be applied =)
01:39:34 <hiptobecubic> :)
01:39:46 <eikke> tikhonjelvis: on the contrary, in this case it feels like I need to put thing together which I'd rather keep separate for maintainability purposes
01:39:58 <mm_freak> fenris_mid: it's not a problem with your english…  it's just that in virtually all other languages you can have "functions with no arguments", which doesn't make sense in haskell
01:40:00 <tikhonjelvis> yeah, that happens sometimes
01:40:17 <tikhonjelvis> chances are you can extract a third parent module instead—say a module only containing the relevant types
01:40:30 <quchen> mm_freak: What's a "function with no arguments" called properly in Haskell? A constant? CAF?
01:40:35 <chairs> is there a function / good way of implementing something like "mapMT :: (Monad m) => (Char -> m Char) -> T.Text -> m T.Text"?
01:40:43 <eikke> tikhonjelvis: yah, but feels ugly and unnecessary :)
01:40:49 <mm_freak> quchen: what's a negative natural number called?
01:41:00 <fenris_mid> man ...
01:41:02 <tikhonjelvis> eikke: perhaps
01:41:03 <fenris_mid> {()
01:41:03 <quchen> mm_freak: Herbert, but I don't see how that's related
01:41:18 <fenris_mid> foo : {()} → ℕ
01:41:18 <fenris_mid> is a function
01:41:19 <mm_freak> quchen: a function is defined as something you can apply
01:41:21 <fenris_mid> get used to it
01:41:31 <mm_freak> quchen: "what's a function you can't apply?"
01:41:49 <mm_freak> doesn't make sense for the same reason as "what's a negative natural number called?"
01:42:14 <typoclass> quchen: i'd say "value". though you could argue that includes functions as well ("Prelude.map is a value")
01:42:31 <quchen> mm_freak: I appealed to your natural language parser there. Here's a more mathematical approach: "What is the object 'x' referred to in 'x = 3' (which is Haskell code)"
01:42:41 <hiptobecubic> can you have a function that's undefined everywhere?
01:42:47 <mm_freak> quchen: that's fine
01:42:48 <quchen> f x = undefined
01:43:02 <hiptobecubic> quchen, sure there's always that one.
01:43:08 <mm_freak> quchen: not fine would be, "what's the /function/ 'x' referred to in 'x = 3 :: Int'?"
01:43:15 <quchen> hiptobecubic: f x = f x
01:43:18 <tikhonjelvis> f = f
01:43:29 <hiptobecubic> but i mean if it's undefined, then you can't apply it, can you?
01:43:40 <mm_freak> hiptobecubic: you can
01:43:43 <quchen> mm_freak: That's why I put "function with no arguments" in quotes above.
01:43:43 <tikhonjelvis> you could, but you'd get ⊥ out
01:43:59 <mm_freak> quchen: value
01:44:07 <quchen> Thank you.
01:44:21 <quchen> Although functions are values too, no?
01:44:28 <tikhonjelvis> yep
01:44:29 <pete_> hang on
01:44:35 <pete_> "a function is defined as something you can apply"
01:44:39 <pete_> I don't think I agree with that
01:44:39 * typoclass purrs and has a sense of deja-vu
01:44:40 <quchen> Is there a term for a non-function value then?
01:45:02 <tikhonjelvis> what about a polymorphic value like Num a => a?
01:45:03 <pete_> A function is a set of tuples, where the collection of the first values is also a set
01:45:12 <tikhonjelvis> if you make functions instances of Num, it can be either
01:45:33 <fenris_mid> functions are relations, that are left-total and right-explicit
01:45:37 <pete_> Function application is the mapping from the first element of the tuple to the second
01:45:48 <tikhonjelvis> there's probably a more haskelly definition of function
01:45:52 <tikhonjelvis> that doesn't depend on sets
01:46:02 <fenris_mid> (if these are the correct translations for "links-total" and "rechts-eindeutig")
01:46:03 <pete_> perhaps
01:46:18 <tikhonjelvis> chances are we want to restrict ourselves to computable functions too
01:46:40 <pete_> I dunno
01:46:55 <pete_> If it's not computable, doesn't that just mean it doesn't terminate?
01:47:06 <tikhonjelvis> hmm
01:47:25 <tikhonjelvis> there are also a bunch of set-theoretic functions you simply can't write at all
01:47:50 <tikhonjelvis> where "a bunch" translates to "uncountably infinite"
01:47:58 <quchen> Oh, maybe you guys know about this blog post about "interesting sets with two elements".
01:48:01 <tikhonjelvis> which might not be the most colloquial meaning of "bunch"
01:48:04 <mm_freak> pete_: it doesn't really matter whether you agree…  it's defined that way =)
01:48:19 <quchen> I'm unable to find that post for a couple of months no, and it was given to me by some guy in #haskell.
01:48:37 <quchen> (It's about logic.)
01:48:49 <tikhonjelvis> it would have to be, wouldn't it
01:49:06 <tikhonjelvis> they're all isomorphic to {True, False}
01:49:23 <quchen> It was also nontrivial. :-)
01:49:35 <quchen> (Well, that's contained in "interesting" I guess)
01:49:40 <mm_freak> there is a strong connection to logic here…  a total function proves the implication its type represents
01:49:52 <fenris_mid> being isomorphic to a set - aha :)
01:49:54 <mm_freak> implication: a -> a
01:49:55 <mm_freak> proof: id
01:50:14 <mm_freak> (forall a)
01:50:17 <mm_freak> implication: a -> b
01:50:18 <mm_freak> no proof
01:50:33 <tikhonjelvis> of course, figuring out if a function terminates is tricky
01:50:56 <mm_freak> tikhonjelvis: not really, if you constrain the language a bit
01:51:09 <tikhonjelvis> sure
01:51:23 <pete_> mm_freak: Isn't that the halting problem?
01:51:28 <mm_freak> also it doesn't necessarily have to terminate
01:51:29 <tikhonjelvis> yep
01:51:32 <mm_freak> it just needs to be total
01:52:13 <mm_freak> pete_: the halting problem is for general turing machines…  you can construct a subset of them, for which the halting problem is solvable in finite time
01:52:32 <tikhonjelvis> an *interesting* subset, even
01:52:57 <mm_freak> pete_: see the proof assistant agda…  it's actually a programming language
01:53:04 <Araneidae> Does this have a name: (\t::Bool -> \a -> if t then a else return ()) :: (Monad m) => Bool -> a -> m a ?
01:53:09 <mm_freak> all programs in agda are guaranteed to provide an answer in finite time
01:53:14 <Araneidae> Or is there another way to conditionally add to a monad?
01:53:32 <mm_freak> Araneidae: do you mean something like 'when'?
01:53:33 <mm_freak> :t when
01:53:35 <lambdabot> Monad m => Bool -> m () -> m ()
01:53:40 <Araneidae> Yes
01:53:44 <Araneidae> thanks
01:54:34 <Araneidae> Wrote my function wrong!
01:54:59 <tikhonjelvis> well, the type wrong, anyhow
01:55:13 <Araneidae> yeah
01:55:57 <mm_freak> if your monad supports it Alternative is always a nicer way to write things
01:56:51 <Araneidae> Well, I'm just using the Writer String monad at the moment
01:57:07 <tikhonjelvis> yeah, when is perfect for combining with tell
01:57:31 <mm_freak> right
02:14:54 <silasm> @src Data.Text.concatMap
02:14:55 <lambdabot> Source not found. The more you drive -- the dumber you get.
02:18:40 <silasm> eh, does anyone know a good way of making concatMapM apply to Text?
02:18:51 <silasm> or does that not exist for good reason?
02:19:15 <mikeplus64> @hoogle concatMapM
02:19:15 <lambdabot> No results found
02:19:25 <mikeplus64> (never heard of concatMapM, not that i don't think it's sane i guess)
02:19:46 <silasm> http://hackage.haskell.org/trac/ghc/ticket/2042
02:19:50 <Kinnison> silasm: concatMapM is typically defined per-project (because people are worried that adding it to base will break too many projects which already define it)
02:20:43 <silasm> Kinnison: interesting. Is there an implementation of it that works over text rather than Lists?
02:21:03 <Kinnison> silasm: No idea.  What would you want it to do?
02:21:33 <mikeplus64> (Text -> m [Text]) -> Text -> Text
02:21:34 <mikeplus64> i guess
02:21:36 <mikeplus64> wait no
02:21:39 <mikeplus64> Char ->
02:21:56 <mikeplus64> and s/[Text]/Text
02:21:59 <silasm> yeah
02:21:59 <tikhonjelvis> (Chat -> Text) -> Text -> Text
02:22:06 <silasm> gotten that far, just don't know how to implement it.
02:22:09 <tikhonjelvis> hmm
02:22:26 <silasm> I want to avoid converting to String in between reading/writing to files
02:23:10 <Kinnison> Well, (Char -> Text) -> Text -> Text *is* Data.Text.concatMap
02:23:13 <silasm> though I don't know that it'll necessarily make much difference, since it seems like concatMap would move char by char regardless.
02:23:24 <Kinnison> So you want (Char -> m Text) -> Text -> m Text
02:23:25 <Kinnison> ?
02:23:28 <silasm> yeah
02:23:48 <silasm> using State for LZ78 compression.
02:24:03 <silasm> to take care of the Dictionary and such
02:24:22 <Kinnison> Well, (Char -> m Text) -> Text -> m [Text] looks fairly plausible
02:24:45 <Kinnison> Maybe
02:24:46 <Kinnison> Urf
02:24:51 * Kinnison pokes at data.text's source
02:24:55 <silasm> wouldn't that be mapM over text?
02:25:03 <silasm> that'd be good enough.
02:25:30 <silasm> issue is that mapM isn't Traversable, because it only takes in Char.
02:26:19 <silasm> s/mapM/Text/g
02:28:25 <silasm> mapAccumL might actually be what I need with some modification now that I look at it.
02:35:35 <silasm> trying to grasp lazy I/O, Text, and the State monad all at once in the ~2 days before my project was due was perhaps a bit too much to tackle
02:36:53 <Kinnison> :-)
02:38:44 <arbn> silasm: Yeah, that would be. Stick with it, though. :)
02:44:25 <johnw> :t sequence . concatMap
02:44:27 <lambdabot>     Couldn't match expected type `[m0 a0]'
02:44:27 <lambdabot>                 with actual type `[a1] -> [b0]'
02:44:27 <lambdabot>     Expected type: (a1 -> [b0]) -> [m0 a0]
02:44:35 <johnw> :t concatMap
02:44:37 <lambdabot> (a -> [b]) -> [a] -> [b]
02:45:07 <johnw> :t (sequence .) . concatMap
02:45:09 <lambdabot> Monad m => (a1 -> [m a]) -> [a1] -> m [a]
02:46:15 <johnw> :t (sequence .) . map
02:46:17 <lambdabot> Monad m => (a1 -> m a) -> [a1] -> m [a]
02:46:29 <johnw> :t (join . sequence .) . map
02:46:31 <lambdabot>     The operator `.' [infixr 9] of a section
02:46:32 <lambdabot>         must have lower precedence than that of the operand,
02:46:32 <lambdabot>           namely `.' [infixr 9]
02:47:10 <johnw> :t \f x -> concat <$> sequence (map f x)
02:47:12 <lambdabot> (Monad f, Functor f) => (a1 -> f [a]) -> [a1] -> f [a]
02:47:34 <johnw> silasm: that is your (Char -> m Text) -> Text -> m Text
02:48:05 <Kinnison> Not quite
02:48:10 <Kinnison> given Text is not [a]
02:48:23 <johnw> replace concat and map with their equivalents from Data.Text
02:48:46 <johnw> or maybe just mconcat instead of concat
02:48:49 <Kinnison> Data.Text.map :: (Char -> Char) -> Text -> Text
02:49:03 <johnw> :t \f x -> mconcat <$> sequence (Data.Text.map f x)
02:49:05 <lambdabot>     Couldn't match expected type `[f0 b0]'
02:49:06 <lambdabot>                 with actual type `Data.Text.Internal.Text'
02:49:06 <lambdabot>     In the return type of a call of `Data.Text.map'
02:49:12 <johnw> hm
02:49:45 <johnw> :t \f x -> mconcat <$> sequence (map f x)
02:49:47 <lambdabot> (Monad f, Functor f, Monoid b) => (a -> f b) -> [a] -> f b
02:50:01 <eikke> does anyone know about some package which provides something like BoundedChan, but which drops 'old' elements instead of blocking when written to when 'full'?
02:50:16 <johnw> eikke: like a sliding window
02:50:22 <eikke> yeah
02:50:27 <johnw> @google haskell sliding window
02:50:29 <lambdabot> http://www.markhneedham.com/blog/2012/02/28/haskell-creating-a-sliding-window-over-a-collection/
02:50:29 <lambdabot> Title: 37 Haskell: Creating a sliding window over a collection 4 at 52 Mark Needham
02:52:02 <eikke> johnw: yeah, I figured I could implement that easily by wrapping some Sequence in a TVar/MVar, but having some package providing it is slightly easier :)
02:52:19 <johnw> :t \f x -> sequence (Data.Text.concatMap f x)
02:52:21 <lambdabot>     Couldn't match expected type `[m0 a0]'
02:52:21 <lambdabot>                 with actual type `Data.Text.Internal.Text'
02:52:21 <lambdabot>     In the return type of a call of `Data.Text.concatMap'
02:52:37 <johnw> doh
02:53:11 <johnw> eikke: I think you'd have an easier time doing it with STM
02:53:42 <johnw> because then you can just shave a regular list inside a TVar without any races
02:53:51 <johnw> (or a Sequence)
02:54:02 <eikke> johnw: hence the TVar. problem then is contention, I think
02:54:44 <johnw> eikke: you mean, you think lots of people will be trying to get at your window while you're accessing it?
02:55:22 <eikke> when wrapping a simple Sequence in a TVar as-is, when it's not full, reader transactions will affect writer transactions
02:55:44 <johnw> sure
02:56:01 <johnw> but how is that not always the case?
02:56:14 <johnw> you want people to be able to read from one end while you're writing to the other?
02:56:16 <eikke> while iirc a sequence contains 2 lists, so having both in their own tvar, and handle them in a transaction, this might reduce contention, but I'm doubting myself now :)
02:56:30 <johnw> I was just going to suggest that :)
02:58:05 <eikke> it's kinda sad there are so little datastructures available which use stm internally
02:58:24 <Ghoul_> Is it possible to make a monad implementation of fail not require an argument
02:58:29 <Ghoul_> ie: if it's not used.
02:58:32 <johnw> if each list is at most N/2 long, then the only time you'll be affecting readers is when you need to make space in the inbound queue
02:59:13 <johnw> Ghoul_: the type class method requires an argument, so I'm not sure what you mean
02:59:47 <johnw> eikke: sounds like you have the makings of a library there :)
02:59:49 <eikke> johnw: actually it's easier. I don't really care about 'which elements are dropped/leftover'
02:59:53 <johnw> STM Data Structures
03:01:01 <eikke> johnw: so all I need is 2 lists of length N/2 (W and R), whenever W is 'full', drop R, replace it with W and W<-[], and whenever R is empty and W isn't, R<-W and W<-[]
03:01:03 <johnw> heh: "Zygomorphisms are seemingly a good fit for sliding window problems"
03:02:23 <johnw> eikke: http://www.iis.sinica.edu.tw/~scm/pub/mds.pdf has a section on sliding windows
03:02:43 <johnw> eikke: yeah, that sounds simple enough
03:03:10 <merijn> eikke: If you want a bounded channel and consider using STM why not use the existing TBQueue?
03:03:26 <eikke> merijn: because that one blocks writers when the queue is full
03:03:55 <merijn> block == retry
03:04:09 <eikke> merijn: yeah, which at runtime results in blocking :P
03:04:11 <merijn> Just do "writeTBQueue queue val <|> return ()"
03:04:20 <merijn> Tada
03:04:26 <merijn> Nonb-blocking failing write :p
03:04:35 <eikke> the write shouldnt fail
03:04:44 <eikke> old stuff should be dropped
03:04:48 <merijn> ah
03:04:53 <johnw> he wants a sliding bounded queue
03:05:13 <johnw> a stack that overflow into /dev/null
03:05:23 <jix> eikke: didn't you write that you don't care which elements are dropped?
03:05:34 <merijn> Maybe TArray + modulo indexing?
03:05:39 <eikke> basically, when nobody is reading from the queue, as much writers can push stuff to it, and they can keep on doing so without 'blocking'
03:05:48 <merijn> If you hit the end, go back to the start
03:05:57 <merijn> Which would overwrite old values
03:06:13 <eikke> jix: in principle I don't care. to ensure somewhat good behavior, it's better if old messages are dropped, preferedly
03:06:16 <johnw> merijn: that's a really nice idea
03:06:23 <johnw> i think it solves his problem!
03:06:31 <eikke> merijn: interesting, yeah. should do the trick
03:07:05 <merijn> \o/
03:07:09 <merijn> <- smrt
03:07:15 * eikke confirms
03:07:28 * johnw gives merijn a smartness cookie
03:07:31 <merijn> Then all you need is a separate TVar Int or something to keep track of the index
03:07:57 <eikke> 2 indices (reader & writer)
03:08:06 <eikke> a ringbuffer, basically
03:08:16 <merijn> True
03:08:17 <johnw> exactly
03:08:21 <eikke> damnit. why didnt I think about this before asking stupid questions :)
03:08:35 <jix> but then the writer has to modify the reader index when the queue is full. doesn't that have the same contention problems as just having a sequence in a TVar?
03:08:46 * johnw wonders why he went off into sliding window land...
03:09:02 <eikke> jix: read index needs only to be updated by a writer when the queue is 'full'
03:09:14 <eikke> which is hopefully not often the case
03:09:31 <jix> but it has to be read to check whether it is full or not
03:09:34 <johnw> eikke: make a TRing library :)
03:10:36 <eikke> jix: right... then maybe the '2 lists in 2 tvars' is still less contending
03:10:50 <jix> eikke: you could use 3 indices
03:11:01 <jix> eikke: reader, reader-cached and writer
03:11:12 <jix> writer only checks reader-cached first
03:11:16 <eikke> ah, yeah
03:11:22 <jix> and if that says it is full it updates reader-cached to reader and rechecks
03:11:23 <eikke> and updates it to reader when overwriting
03:11:35 <eikke> sweet
03:12:05 * eikke off to get a haircut, then write this thingy
03:12:07 <eikke> thanks for all input
03:43:00 * hackagebot polh-lexicon 0.2 - A library for manipulating the historical dictionary of Polish  http://hackage.haskell.org/package/polh-lexicon-0.2 (JakubWaszczuk)
03:43:02 * hackagebot free-operational 0.3.0.0 - Operational Applicative, Alternative, Monad and MonadPlus, built with free types.  http://hackage.haskell.org/package/free-operational-0.3.0.0 (LuisCasillas)
03:48:00 * hackagebot polh-lexicon 0.2.1 - A library for manipulating the historical dictionary of Polish  http://hackage.haskell.org/package/polh-lexicon-0.2.1 (JakubWaszczuk)
03:56:52 <no-n> does lambdabot have a command that describes what a function does?
03:57:23 <flux> just look deeply at the types and understanding will arrive.. ;-)
03:57:42 <no-n> hehe :)
03:58:35 <tdammers> very zen
03:58:48 <Entroacceptor> there really should  be a way to better link the docs
03:59:07 <Entroacceptor> like python's inline doc
03:59:18 <no-n> there's @src
03:59:31 <quicksilver> no-n: which is rubbish :)
03:59:35 <Entroacceptor> (I meant in ghc itself)
03:59:46 <Entroacceptor> @src unsafeLaunchMissiles
03:59:46 <lambdabot> Source not found. There are some things that I just don't know.
03:59:48 <Entroacceptor> :(
04:00:31 <danr> @src unsafeFireTheMissiles
04:00:31 <lambdabot> Source not found.
04:00:32 <danr> :(
04:01:00 <no-n> :(
04:13:09 <mm_freak> Entroacceptor: what do you mean?
04:15:07 <Entroacceptor> mm_freak: atm the only documentation is generated from the source into some mixture of html files which may or may not lie where one looks. There should be a way to type ":help unsafeLaunchMissiles" in ghci to see a short help, or even longer one
04:15:28 <Entroacceptor> or at least get a link to the documentation for that
04:18:00 <mm_freak> Entroacceptor: yeah, i agree with that
04:18:16 <mm_freak> i could never get used to hoogle
04:24:44 <neutrino_> hi
04:25:52 <neutrino_> i have a friend who'd like to learn about proving and verification of functional programs (in haskell and scala), can anyone suggest any good resources?
04:26:26 <hpc> neither of those are good for proofs
04:27:06 <hpc> they are turing complete, and have ways to break the type system above and beyond that
04:27:23 <hpc> try agda/coq/idris
04:28:22 <neutrino_> hpc: it's not about doing proofs in either, it's about proving the programs written in them
04:28:25 <mm_freak> haskell is good for proofs under certain assumptions, and those assumptions are actually easy to meet
04:28:32 <mm_freak> neutrino_: that's the same thing
04:29:03 <neutrino_> yeah but in haskell we have static inference and that helps a lot with stuff you'd normally have to do by hand
04:29:25 <mm_freak> neutrino_: i think a good suggestion here is:  just learn haskell
04:29:26 <neutrino_> i mean he's coming from the imperative world so just the stuff that can be easily done in haskell is a great improvement :p
04:29:50 <mm_freak> you can't learn type-guaranteeing stuff without having a deep understanding of the type system
04:30:05 <mm_freak> and btw, forget scala
04:30:06 <neutrino_> what certain assumptions did you mean earlier?
04:30:10 <hpc> this isn't really "proving programs", but you can use djinn to produce implementations of your most polymorphic functions
04:30:18 <mm_freak> neutrino_: totality, no side effects
04:30:34 <neutrino_> i thought functions in haskell weren't total.
04:30:44 <mm_freak> neutrino_: they aren't guaranteed to be
04:31:22 <mm_freak> the idea is to show totality for a set of primitives and compose programs from those
04:31:25 <neutrino_> but one can prove them to be total by hand?
04:31:28 <mm_freak> for example foldr is total
04:31:36 <mm_freak> sure
04:31:40 <neutrino_> what about foldr'? and foldl?
04:31:49 <hpc> if you stick to total functions and avoid unsafe* and use extensions to enable expressing the rest of your proof in type terms
04:31:49 <mm_freak> they are total
04:31:58 <shelf> i've only delved into haskell for toy investigations into type theory, gadts, theorem proving, and things like that. i love it for a lot of things, but not sure i could use it for certain domains. is there any sane way to conduct, say, graph work in haskell? if so, could i get a few phrases to google?
04:32:01 <hpc> then... you still can't really prove many things
04:32:03 <hpc> but some
04:32:05 <int-e> mm_freak: how do you define totality for higher-order functions?
04:32:16 <mm_freak> int-e: total, if all arguments are total
04:32:24 <bitonic> shelf: ‘graph work’?  you mean working with graphs?
04:32:25 <int-e> > foldr (&&) True (repeat True) -- or infinite data?
04:32:30 <lambdabot>   mueval: ExitFailure 1
04:32:31 <lambdabot>  mueval: Prelude.undefined
04:32:33 <hpc> mm_freak: foldl is not total; infinite data is part of its domain
04:32:42 <Botje> am I the only one who read "gadts" as "goats"?
04:32:49 <hpc> oh, which is another thing you can't use while doing proofs in haskell
04:32:51 <bitonic> I read it as ‘cats’
04:32:53 <shelf> yeah. simple graph algorithms, for instance
04:33:02 <mm_freak> int-e: that's total
04:33:04 <bitonic> shelf: sure.  there’s a nice paper about depth first search
04:33:11 <shelf> could you point me towards that?
04:33:13 <bitonic> @google depth first search haskell
04:33:15 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.49.2591&rep=rep1&type=pdf
04:33:15 <lambdabot> Title: Structuring Depth-First Search Algorithms in Haskell
04:33:18 <mm_freak> total doesn't mean "terminates"
04:33:25 <shelf> haha that made me feel silly
04:33:38 <bitonic> shelf: tbf that copy is low quality
04:33:41 * hpc now wants to write a tutorial for GADTs and call it "The Great GADTsby"
04:33:42 <bitonic> but it’s the right paper
04:33:45 <mm_freak> hpc: right
04:33:49 <mm_freak> but foldr is total
04:33:54 <shelf> good enough
04:34:04 <mm_freak> foldl is total for List, foldr is total for both List and Colist
04:34:21 <shelf> i can think of a lot of ways to do it using my basic haskell knowledge but it would probably have a pretty bizarre memory footprint
04:34:30 <hpc> you can implement List, too
04:34:30 <shelf> so i'm very interested in this paper. thanks!
04:34:45 <hpc> data List a = Nil | Cons !a !(List a)
04:34:53 <bitonic> shelf: np, it’s a very neat paper
04:35:37 <mm_freak> hpc: you don't need the first bang, though…  List a is fine, where a is codata
04:35:46 <bitonic> shelf: there are also more heavy duty libraries like ‘fgl’.  the approach in that paper is used in ‘containers’
04:35:47 <hpc> true
04:36:20 <bitonic> mm_freak: foldr as it is is not total on Colist
04:36:40 <bitonic> mm_freak: it is if the output is coinductive as well
04:36:41 <hpc> bitonic: it's guaranteed productive
04:36:54 <hpc> [] => []
04:36:59 <hpc> _:_ => _:_
04:37:19 <bitonic> hpc: what signature for this coinductive foldr are you proposing exactly?
04:37:24 <int-e> bitonic: huh?! I'm pretty sure I gave a non-productive example above.
04:37:43 <hpc> er
04:37:48 <bitonic> I’d you can stream another coinductive datatype out, but it won’t work for arbitrary functions
04:37:54 <bitonic> *I’d say
04:37:59 <hpc> lol, somehow i mixed up foldr and map
04:38:04 * hpc falls on his sword
04:38:06 <bitonic> yeah, map is fine
04:38:14 <bitonic> but foldr as it is wouldn’t work
04:38:37 <mm_freak> bitonic: that's not foldrs fault
04:38:38 <bitonic> e.g. same type signature as ‘foldr’ but replacing ‘[]’ with ‘Colist’ or whatever
04:38:42 <bitonic> mm_freak: ?
04:38:51 <int-e> foldr const  will always be a problem -- unless you somehow claim that  const  is not total?
04:38:53 <mm_freak> it's simply that haskell doesn't enforce totality of foldr's arguments
04:39:07 <mm_freak> foldr as its defined is perfectly total
04:39:25 <bitonic> mm_freak: no, you cannot define a ‘foldr : (A → B → B) → B → Colist A → B’ in Agda either
04:39:34 <bitonic> I agree that it’s total for List obviously
04:39:42 <int-e> mm_freak: so what is the value of  foldr const () (repeat ())  and why?
04:39:51 <bitonic> well, unless you write ‘foldr _ x _ = x’ :)
04:40:28 <int-e> mm_freak: you can replace the first () by some less trivial codata value if you wish; the question remains.
04:41:13 <bitonic> you can define a foldr with a coinductive folding function
04:41:15 <bitonic> I think...
04:41:38 <mm_freak> bitonic: you're right
04:45:11 <bitonic> well actually given how coinduction works in Agda I’m not sure about a general coinductive fold.  but in principle it makes sense
04:47:11 <mm_freak> bitonic: i'm trying to write foldr for Colist
04:47:15 <mm_freak> it isn't actually easy
04:47:22 <bitonic> mm_freak: you need to figure out the type first
04:47:41 <bitonic> but since corecursion must be constructor-guarded
04:47:50 <bitonic> well, since in Agda it works like that
04:48:02 <bitonic> I doubt you’ll get anywhere useful
04:48:21 <Eduard_Munteanu> That'd be the colist constructor.
04:48:29 <bitonic> Eduard_Munteanu: but we want a general return type
04:48:39 <bitonic> otherwise you’d end up with ‘map’ basically
04:48:56 <Eduard_Munteanu> Oh, hm.
04:48:57 <bitonic> OK gotta go eat I’m starving :P
04:49:33 <mm_freak> bitonic: i think you need the result to be another coinductive type
04:50:12 <bitonic> mm_freak: exactly, but you can’t really abstract that well—unless you use something like M maybe
04:51:45 <mm_freak> true
04:52:21 <mm_freak> but yeah, it makes you realize that foldr is only total, when its first argument is nonstrict in its second argument
04:53:23 <Eduard_Munteanu> What if you write something a-la scanl instead?
04:53:36 <quchen> Why doesn't the zlib module produce "Maybe ByteString" when decompressing? Is there no way decompression can fail? (I.e. if the data is corrupt the output will be corrupt, but it can still be decompressed by the algorithm)
04:54:06 <quchen> Is it a shortcoming of the library, or zlib's format by design?
04:56:25 <bitonic> mm_freak: I’m not sure what you mean there
04:56:25 <Eduard_Munteanu> :t foldr
04:56:27 <lambdabot> (a -> b -> b) -> b -> [a] -> b
04:57:13 <mm_freak> bitonic: foldr f z xs is total, when f is nonstrict in its second argument
04:57:13 <bitonic> a useful angle is to see that fold can be defined for List but not for Colist, and unfold can be defined for Colist but not for List
04:57:24 <Eduard_Munteanu> foldr :: (a -> b -> ∞ b) -> b -> Colist a -> ∞ b    -- maybe a type like that might do?
04:57:28 <bitonic> mm_freak: you mean in Haskell?  why?
04:57:35 <mm_freak> Eduard_Munteanu: nope
04:57:51 <bitonic> Eduard_Munteanu: no the recursive call will still be unguarded
04:58:04 <mm_freak> Eduard_Munteanu: if anything, the second argument to 'f' must have the ∞
04:58:35 <mm_freak> bitonic: foldr f z (x:xs) = f z (foldr f z xs)
04:58:45 <mm_freak> gives an answer in finite time, if f is nonstrict in its second argument
04:59:04 <bitonic> mm_freak: well it’s ‘total’ in the sense that it goes from codata to codata
04:59:11 <bitonic> so yeah it is productive
04:59:30 <mm_freak> yeah…  i think of corecursive programs as total
04:59:41 <bitonic> but the thing is that they’re mixed up
05:00:08 <bitonic> so I can get your output and force it all (in Haskell)
05:00:46 <Eduard_Munteanu> I was thinking like   foldr f e (x : xs) = f x (foldr f e xs)   and f already wraps stuff in a sharp
05:00:55 <mm_freak> sure…  you can't really talk of totality in haskell
05:01:32 <mm_freak> Eduard_Munteanu: you are guarding the whole thing, not the recursion there
05:01:44 <mm_freak> that's a totality error and agda confirms it
05:01:57 <Eduard_Munteanu> Oh, hm.
05:01:57 <ClaudiusMaximus> quchen: reading the docs, it can fail - but to return a Maybe it'd have to decompress the whole thing, wheras lazy bytestrings allow incremental processing of the output; maybe you want decompressWithErrors
05:02:44 <quchen> ClaudiusMaximus: Aaaah, I fell for the lazy-strict-bytestring thing again.
05:03:10 <quchen> Right, it uses lazy bytestrings, so Maybe would be bad here.
05:03:17 <ClaudiusMaximus> yeah, haddock isn't really ready for qualified imports
05:03:27 <mm_freak> foldr : {A B : Set} → (A → ∞ B → B) → B → Colist A → B
05:03:37 <mm_freak> this is the closest i get, but agda rejects it as nontotal
05:03:49 <mm_freak> it's "correct" in the sense that you can write id for Colist in terms of it
05:04:01 <mm_freak> so my conclusion is that you can't actually write foldr
05:04:42 <mm_freak> at least not haskell's foldr…  you could probably write a guarded foldr
05:04:58 <mm_freak> but then you could just as well use explicit recursion
05:05:18 <quchen> ClaudiusMaximus: It's a little tied to IO then if it throws errors. But then data compression is mostly for IO anyway, hmm.
05:08:25 <Eduard_Munteanu> mm_freak: how did you define it?
05:10:47 <Eduard_Munteanu> Hm, I think you're right, that type probably won't do.
05:12:39 <eikke> jix, johnw: just found out about rolling-queue which seems to be what I was looking for before (though not array-based, somewhat more complex, kinda like how Sequence works but in all-TVars instead)
05:13:44 <Eduard_Munteanu> Wait a minute...
05:13:46 <mm_freak> Eduard_Munteanu: http://hpaste.org/87405
05:14:48 <mm_freak> Eduard_Munteanu: that foldr is probably correct, because it matches the constructors of Colist exactly
05:14:52 <mm_freak> but it's not total
05:15:33 <mm_freak> being able to write foldId is strong evidence that it's correct
05:16:51 <Eduard_Munteanu> mm_freak: this can't possibly work... what do you expect to get when you later unwind the result one step? I suspect you're just implementing a scan instead of fold.
05:22:28 <bitonic> mm_freak: you don’t need the delayed argument to do those things
05:22:40 <b__> can `f . g . h . k' be written as a fold?
05:23:05 * hackagebot soap 0.2.0.3 - SOAP client tools  http://hackage.haskell.org/package/soap-0.2.0.3 (AlexanderBondarenko)
05:23:07 <merijn> b__: You mean if f, g, k, etc are in a list?
05:23:16 <b__> yes
05:23:19 <merijn> Yes
05:23:30 <Eduard_Munteanu> > foldr (.) id [f, g, h] :: [Expr]
05:23:32 <lambdabot>   Couldn't match expected type `[Debug.SimpleReflect.Expr.Expr]'
05:23:33 <lambdabot>             ...
05:23:33 <merijn> :t foldr (.) id
05:23:36 <lambdabot> [b -> b] -> b -> b
05:23:39 <mm_freak> Eduard_Munteanu: that's the point
05:23:44 <bitonic> mm_freak: <http://hpaste.org/87405>.  I agree that the delayed argument matches some intuition of the function ‘not forcing’
05:24:56 <Eduard_Munteanu> mm_freak: then you can just return a Colist and let the user go through it. You don't even need to make the folding function use coinductive stuff.
05:26:10 <bitonic> but I’m not sure it helps in any way from a ‘guaranteeing termination’ perspective
05:26:21 <bitonic> mm_freak: ‘sum : Colist ℕ → ℕ; sum = foldr (λ x y → x + (♭ y)) 0’ is perfectly fine for example
05:27:35 <b__> merijn: ah yeah ofc, and they have to be the same type (b -> b), hmm
05:28:02 <merijn> b__: Else they couldn't be in a list
05:28:25 <merijn> b__: You could create a heterogeneous list of functions, but I'm not quite sure what the use of that would be...
05:28:38 <merijn> Why do you need to put them in a list?
05:29:47 <mm_freak> bitonic: but your foldr isn't total either, is it?
05:29:54 <bitonic> mm_freak: ofc no
05:29:54 <bitonic> t
05:30:02 <mm_freak> ok
05:30:16 <bitonic> but my foldr’s type is more similar to Haskell’s foldr type :)
05:30:37 <mm_freak> sure…  if agda's gonna reject it anyway you could just as well use that one =)
05:31:19 <bitonic> but Agda’s right in rejecting both
05:32:11 <bitonic> I mean you can write infinite loops with both functions, it’s not that Agda’s too conservative
05:32:34 <mm_freak> i know…  that wasn't my point anyway
05:32:52 <mm_freak> however, it would be nice if you could tell it not to use certain functions as proofs
05:33:10 <mm_freak> so that you could use foldr as a kind of "macro"
05:35:13 <mm_freak> bitonic: you ruined me today…  i always considered foldr to be the shiny example of a perfect list combinator =/
05:35:32 <bitonic> mm_freak: but Colist is the opposite of a list, literally :P
05:35:37 <bitonic> its combinator is unfoldr ehe
05:36:11 <bitonic> foldr *is* the ‘perfect’ list combinator, in the sense that it’s its primitive recursor
05:36:44 <mm_freak> i'll still use foldr on infinite lists =P
05:38:43 <mm_freak> the weird thing about this is that you have a coinduction pattern that works perfectly well, but you can't capture it
05:42:48 <Chelsea> Hi all, is there a way to export a pandoc (mkd) document with css layout to pdf/docx?
05:43:27 <bitonic> mm_freak: well the fact that ‘unfold’ doesn’t work on List is even more annoying
05:45:30 <mm_freak> Chelsea: not directly
05:45:37 <mm_freak> Chelsea: you can use wkhtmltopdf or something like that
05:46:05 <mm_freak> pandoc doesn't include an entire browser renderer =)
05:47:11 <mm_freak> bitonic: indeed, although often i prefer to use explicit corecursion for construction
05:48:29 <bitonic> mm_freak: what do you mean by ‘explicit corecursion’?  building the terms manually?
05:48:43 <bitonic> for me explicit corecursion is done by pattern matching on the result :)
05:49:30 <Chelsea> mm_freak, ah, so i'm looking for a html to doc/pdf renderer.... that shouldn't be to hard to find :) thanks!
05:49:30 <mm_freak> bitonic: ones = 1 : ones
05:50:11 <mm_freak> coinductively proves [Int], whatever that means =)
05:51:21 <bitonic> well but that looks just like a normal recursive definition.  I want copatterns!
05:51:36 <mm_freak> bitonic: i don't know what you mean
05:51:43 <bitonic> @google copatterns agda
05:51:44 <mm_freak> pattern matching is a feature of recursion
05:51:47 <lambdabot> http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.AIMXVI
05:51:47 <lambdabot> Title: The Agda Wiki - AIMXVI
05:51:51 <bitonic> mpf
05:52:10 <bitonic> mm_freak: <http://www.tcs.ifi.lmu.de/~abel/popl13.pdf>
05:52:27 <bitonic> you can have pattern matching for coinductive definitions
05:52:37 <bitonic> but you pattern match on the result, not the arguments
05:53:05 * hackagebot Random123 0.1.2 - Haskell port of Random123 library  http://hackage.haskell.org/package/Random123-0.1.2 (BogdanOpanchuk)
05:53:12 <mm_freak> bitonic: could you give me a short pseudocode example?  i don't really want to read a paper now
05:53:32 <bitonic> mm_freak: ‘head ones = 1; tail ones = ones’
05:54:02 <Araneidae> Has anybody noticed that Hayoo! is still broken?  Anybody here know how to poke it?
05:54:15 <Eduard_Munteanu> mm_freak: ones = 1 : # ones
05:54:20 <mm_freak> bitonic: wow, that's weird…  but i can see what you mean
05:55:06 <mm_freak> Eduard_Munteanu: ones = 1 ∷ ♯ ones
05:55:10 <mm_freak> if you want to be pedantic, do it properly =P
05:55:24 <Eduard_Munteanu> Heh, indeed. :D
05:56:04 <mm_freak> would be funny to let emacs display "::" as ":" and ":" as "∷"
05:56:51 <bitonic> mm_freak: ‘head (map f xs) = f (head xs); tail (map f xs) = map f (tail xs)’, and so on
05:57:35 <mm_freak> bitonic: that would be awesome to have
05:57:40 <mm_freak> but it's really weird
05:57:41 <bitonic> mm_freak: you have it already in Agda
05:57:46 <mm_freak> really?
05:57:50 <bitonic> although the implementation is pretty toyish
05:58:02 <bitonic> yeah, but they have to re-implement it since now it’s just some sugar on records basically
05:58:05 <bitonic> very fragile
05:58:36 <mm_freak> if you take that to its conclusion, agda becomes a CAS
05:58:46 <bitonic> what’s a cas?
05:58:54 <Eduard_Munteanu> Computer Algebra System
05:59:18 <mm_freak> bitonic: stuff that does symbolic integration and solves quadratic equations =)
05:59:55 <bitonic> I’m not sure I see the relation to coinduction
06:06:59 <Araneidae> Orphan Instances.  Bah!  Going to have to figure another way to restructure my code :(
06:08:00 <Araneidae> Didn't want all that nasty text rendering stuff mixed up with all my real code.  Guess I need to separate the class and instance declarations from everything else
06:08:55 <mm_freak> bitonic: well, apparently it solves the equation for 'map'
06:09:48 <bitonic> mm_freak: doesn’t the normal pattern matching solve some equations for map too :P?
06:17:12 <mm_freak> bitonic: but it doesn't unapply functions =)
06:17:38 <mm_freak> although 'head' is probably a constructor
06:17:43 <mm_freak> … field
06:19:16 <Eduard_Munteanu> Yeah, copatterns work with fields.
06:20:12 <bitonic> mm_freak: head is a constructor, yes
06:20:55 <Eduard_Munteanu> bitonic: field
06:21:08 <bitonic> oh sorry, a coconstructor
06:21:16 <Eduard_Munteanu> Cofield then. :P
06:21:17 <bitonic> aka destructor
06:21:58 <Eduard_Munteanu> bitonic: not sure that's appropriate... that record only has one constructor (if it does)
06:22:06 <mm_freak> in any case, it really looks elegant…  i'd love to have that in haskell
06:22:17 <mm_freak> and it wouldn't even interfere with existing syntax
06:22:55 <bitonic> Eduard_Munteanu: ‘Stream’ has two destructors, and you don’t need constructors
06:22:59 <bitonic> (if you have copatterns)
06:25:11 <bitonic> mm_freak: yeah you ‘only’ have to convert that to ‘data Stream a = Stream {head :: a, tail :: Stream a}, ones = Stream{head = 1, tail = ones}’
06:25:38 <bitonic> and so on
06:33:11 <hseg> I was trying to reason about the Category typeclass in Control.Category, and it seems to me that it requires all categories C to have Ob(C) = Ob(Hask).
06:33:19 <hseg> Is this true, and is this fixable?\
06:34:25 <hseg> Upon further reflection, it seems this constraint exists for many built-in typeclasses. I recall that Set can't be defined as a Monad since it requires an Ord constraint on its parameter.
06:34:31 <hseg> Again, can we fix this?
06:35:17 <Eduard_Munteanu> hseg: well, a subcategory of Hask
06:36:04 <hseg> Eduard_Munteanu: Isn't that precisely what I meant when noting that Ob(C) must be equal to Ob(Hask)
06:36:05 <hseg> ?
06:36:35 <Eduard_Munteanu> hseg: not all objects from Hask must be in C, so it's not quite equality
06:37:20 <hseg> Really? Could you show a Category instance such that there are objects in Hask not in the Category?
06:41:12 <Eduard_Munteanu> hseg: well, normally I think you can assume Ob(C) >= Ob(Hask) but it requires your arrow type to be injective
06:42:25 <hseg> I think I misexplained myself. Since Category doesn't specify Ob anywhere, and in particular, it can't constrain it, it must perforce be Ob(Hask)
06:43:12 <Eduard_Munteanu> hseg: I think a counterexample is   Category (Const (Const ()))
06:45:52 <hseg> A) Is that even syntactically correct? What is (Const (Const ())) a b?
06:46:14 <Eduard_Munteanu> newtype Const a b = Const a
06:47:17 <Rarrikins> hseg: Yeah
06:47:44 <Rarrikins> > (const (const ())) 1 2
06:47:46 <lambdabot>   ()
06:47:57 <Rarrikins> Same sort of thing with the types.
06:48:19 <hseg> While that may unwrap the outer Const, how can that elevate the b into the constructor?
06:48:20 <Eduard_Munteanu> hseg: id = (); (.) = const (const ())
06:48:24 <Eduard_Munteanu> Er.
06:48:58 <Eduard_Munteanu> id = Const (Const ()); g . f = Const (Const ())
06:48:59 <hseg> i.e. (Const (Const ())) a b === (Const (Const ())) b === ?
06:49:31 <Eduard_Munteanu> Const () a = ()
06:49:40 <Eduard_Munteanu> s/=/~/
06:49:53 <Eduard_Munteanu> Const (Const ()) a b ~ ()
06:49:53 <hseg> Right, but...\
06:50:11 <hseg> data Const a b = C a
06:50:56 <hseg> (Const (Const ())) a b === (C (Const ())) b. How do you turn that into (C (C ())) ?
06:51:22 <Eduard_Munteanu> That's rather informal.
06:51:34 <Eduard_Munteanu> Mixing type and data constructors.
06:51:47 <hseg> I know, but I lack the formal background to make this more correct.
06:52:09 <hseg> s/lack the/have a weak/
06:52:50 <b__> I have a function (Word16, Word16) -> Builder: q = fromWrite . uncurry mappend . join (***) writeWord16le
06:52:53 <acube> ((Const (Const ())) a) b ~ Const () b ~ ()
06:52:58 <b__> but can it be done more clearly?
06:53:03 <Eduard_Munteanu> hseg: the type constructor Const is just that, there's nothing to expand. There's nothing to expand in say Maybe a.
06:53:32 <hseg> Oh. So basically, the definition of Const says that Const a b ~ a?
06:53:36 <Eduard_Munteanu> hseg: but let's work the other way around
06:53:50 <hseg> But how do you interpret that from the definition?
06:55:24 <Eduard_Munteanu> hseg: well take a simpler one: newtype Trivial a = T ()    Trivial a ~ ()
06:55:46 <Eduard_Munteanu> You can set up an isomorphism...
06:55:54 <acube> It also becomes clearer if you drop all those data constructors and just use type Const a b = a
06:56:08 <supki> @ty uncurry ((?fromWrite .) . (mappend `on` ?writeWord16le))
06:56:11 <lambdabot> (?fromWrite::b1 -> c, ?writeWord16le::b -> b1, Monoid b1) => (b, b) -> c
06:56:25 <Eduard_Munteanu> f :: Trivial a -> ()    f = const ()      g :: () -> Trivial a    g () = T ()
06:56:35 <hseg> Oh. So in fact, all that A ~ B claims is that a trivial isomorphism exists between A and B?
06:57:05 <Eduard_Munteanu> It needn't be trivial, I just called that type function trivial :)
06:57:29 <hseg> So all it claims is that the isomorphism exists?
06:57:47 <Eduard_Munteanu> Yeah.
06:58:07 <Eduard_Munteanu> Now, for Const...
06:58:10 <hseg> But then for all countably infinite A and B, A ~ B, so e.g. Integer ~ Char, which I thought was false?
06:58:20 <Eduard_Munteanu> f :: Const a b -> a     f (C a) = a
06:58:33 <Eduard_Munteanu> g :: a -> Const a b   f = C
06:58:40 <Eduard_Munteanu> er, g
06:59:10 <Eduard_Munteanu> hseg: all countable infinite sets are isomorphic
06:59:19 <hseg> So Integer ~ Char?
06:59:25 <Eduard_Munteanu> Yeah.
06:59:37 <Eduard_Munteanu> Well, I don't remember what Char is exactly.
06:59:49 <hseg> That's slightly counterintuitive to me.
07:00:08 <hseg> But then a ~ (a,a) ~ List a ~ List (List a), no?
07:00:08 <Eduard_Munteanu> hseg: do you know natural numbers are isomorphic to integers?
07:00:13 <hseg> Yes.
07:00:27 <Eduard_Munteanu> Mm, no a isn't isomorphic to List a.
07:00:43 <hseg> I just didn't expect that to extend to types
07:00:51 <acube> Int64 ~ Int32 isn't isomorphic either ?
07:01:06 <hseg> Sorry, should have prefaced that statement with (a ~ Integer) =>
07:01:07 <Eduard_Munteanu> acube: for finite sets you need the same cardinality
07:01:40 <hseg> So it becomes, for countably infinite a, a ~ (a,a)
07:01:59 <hseg> I think I might be wrong about the a ~ List a part.
07:02:18 <Eduard_Munteanu> hseg: a ~ List a works only if List a contains just finite lists
07:02:37 <quchen> b__: This one is a little shorter, but as unreadable: fromWrite . uncurry (mappend `on` writeWord16le)
07:03:01 <hseg> Right. That's Cantor's theorem regarding powersets, i.e. that |A| /= |P(A)|
07:03:19 <quchen> b__: I'm not sure what the function is supposed to do, but maybe split it up using a where clause to make its intentions clearer
07:03:33 <acube> Oh, so [Int32] ~ ([Int32], [Int32]) -- ([Int32] might be a possible implementation of Integer?)
07:03:48 <quchen> b__: The inliner will take care of the 'where' stuff, so the performance shouldn't take a hit
07:04:07 <acube> :t on
07:04:09 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
07:04:23 <Eduard_Munteanu> acube: yes, but Int32 is totally different from Integer.
07:04:46 <quchen> b__: Remember, "Programs must be written for people to read, and only incidentally for machines to execute." :-)
07:04:48 <acube> I know, but in theory, I could implement Integer as a list of Ints
07:04:58 <b__> I now have writeData = toLazyByteString . fromWriteList (uncurry (<>) . join (***) writeWord16le)
07:05:02 <Eduard_Munteanu> acube: [Int32] <---split in half/concatenate---> ([Int32], [Int32])
07:05:03 <b__> quchen: sure
07:05:24 <Eduard_Munteanu> acube: oh, a list of Int32s... yeah
07:05:47 <b__> writeData :: [(Word16, Word16)] -> ByteString
07:05:49 <Eduard_Munteanu> Err, wait, that's not isomorphic.
07:06:03 <acube> yeah, I thought that too
07:06:19 <Eduard_Munteanu> It's not surjective.
07:06:32 <hseg> So, back to our example, (Const (Const ())) a b ~ (), and thus the Category instance for (Const (Const ())) is in fact the category C with Ob(C) = Ob(Hask) and Ar(C) = {f | f :: () -> ()} ?
07:06:32 <Eduard_Munteanu> e.g. the preimage of ([1,2,3,4], [])
07:08:35 <Eduard_Munteanu> hseg: oh yes, you're right, my bad
07:09:32 <b__> oh wait I can just do writeData = toLazyByteString . fromWriteList writeWord16le . uncurry (++) . unzip
07:09:33 <hseg> OK. Still, the fact that the Category typeclass doesn't refer to Ob nor allows you to constrain it forces you to write categories C with Ob(C) = Ob(Hask)
07:10:18 <Eduard_Munteanu> hseg: well, Ob(C) ~ Ob(Hask)
07:10:19 <hseg> Basically, the whole "Set is not a Monad" problem all over again, if I got this right.
07:10:20 <b__> and suddenly I had 3 less imports
07:10:39 <Eduard_Munteanu> hseg: because of the type constructor
07:10:51 <b__> but it doesn't preserve order
07:11:17 <acube> There are free functors. Are there also free categories?
07:11:23 <hseg> Why would you even have that much flexibility? The type constructor only gives you flexibility in the type of your arrows.
07:11:37 <quchen> b__: That's still awful to read. Also it's not the same as your initial function. Now you're unzipping, giving you a list of (fst, snd), and then concatenating those lists. Before, you were concatenating each tuple first.
07:11:39 <Eduard_Munteanu> acube: yes, given a graph you can get a free category from it
07:12:15 <Eduard_Munteanu> acube: it's not the same 'free'.
07:12:24 <hseg> acube: Don't think so, not if you mean, given a type of kind * -> * -> *, generate the minimal category from that.
07:12:43 <quchen> b__: What about something like "writeData = toBS . map (uncurry (<>)) . map (join (***) writeWord)" - that's nicely chunked into individual functions now. Give the two maps descriptive names, put them in a where clause, and everything's much more maintainable.
07:12:47 <Eduard_Munteanu> acube: let's put it another way... F : Graphs -> Cat is the free category functor :)
07:12:57 <quchen> b__: When compiling the maps will be fused again and everyone is happy.
07:13:23 <quchen> b__: (That was pseudocode above, it most like doesn't do the right thing right now.)
07:13:31 <Eduard_Munteanu> So something you get freely vs something which yields free objects
07:14:08 <quchen> b__: But what you really want is a "prepare list element function", then a "pack list element in a sendable format", and finally push it all into a BS.
07:14:10 <acube> ok, thanks
07:14:36 <elliott> hseg: http://hackage.haskell.org/packages/archive/data-category/0.5.1.1/doc/html/Data-Category.html has a more flexible Category.
07:14:40 <Eduard_Munteanu> There's another notion of free... you can freely join ##categorytheory if you haven't already. :)
07:14:49 <mm_freak> the acronym "BS" is kinda ambiguous
07:15:23 <quchen> mm_freak: Yes, I meant that he should pack the result of the function in a bullshit. Nice catch.
07:15:32 <mm_freak> =)
07:15:45 <klrr> could i name a moduel "Parser" even if i use Text.ParserCombinators.Parsec? There's a type called Parser in it, but isnt it different namespaces?
07:16:07 <geekosaur> modules are a different namespace from types, yes
07:16:39 <quchen> klrr: Haskell doesn't really have namespaces, it uses qualified imports to avoid name clashes.
07:16:53 <quchen> klrr: So you want to "import qualified blabla.Parsec as P" or something.
07:17:12 <merijn> quchen: Wut
07:17:21 <merijn> quchen: How does haskell not have namespaces?
07:17:28 <hseg> Hm. Where can I see the instance declarations for that typeclass? I can't find them in the source file?
07:17:54 <merijn> hseg: Usually either in the file containing the datatype OR the file holding the class
07:18:20 <klrr> quchen: yes, and it got a type called Parser, am i still allowed to use Parser as the name of the module or will it fail?
07:18:21 <quchen> merijn: It does? I thought the distinguishing feature of a namespace is that it's an intrinsic property of a definition, whereas qualified imports assign a "namespace" at import.
07:18:27 <hseg> Thx
07:18:34 <b__> quchen: sure, but uncurry (<>) etc sucks anyway
07:18:49 <b__> I'll look at my types
07:19:06 <acube> hseg: There is a list of the instances on hackage
07:19:24 <hseg> Right, just couldn't find the source for the instances.
07:19:24 <quchen> b__: Well you can write "niceFunctionName (x,y) = x <> y" if you want
07:20:07 <b__> yeah clearly it isn't the function name I dislike
07:20:14 <typoclass> hseg: i've indeed wondered about the same. i do want to look at instances' sources sometimes
07:20:30 <hseg> typoclass: [17:16] <merijn> hseg: Usually either in the file containing the datatype OR the file holding the class
07:20:32 <merijn> quchen: What does "intrinsic property of a definition" even mean? Haskell modules are namespaces, it's just that import by default imports all names from a module into the current name space
07:20:35 <typoclass> hseg: seems like the haddock tool should be fixed to add those links
07:21:02 <hseg> In this case, the instance declarations were in the associated datatypes' files.
07:21:16 <hseg> i.e. instance Category Unit was in the file for Unit
07:21:58 <hseg> Just checking, though. Does data Unit a b where Unit :: Unit () () define the GADT Unit with only one constructor?
07:22:10 <hseg> Which can only instantiate one value?
07:22:14 <quchen> merijn: In C++, the module defines its namespace, saying "from outside, f will be referred to as NS.f". In Haskell, it's not the module defining the "NS" part, but how it is imported. Maybe I'm thinking too much C++y here though.
07:22:15 <acube> The Void instance for Category in that package is funny: src = magic; tgt = magic; (.) = magic :P
07:22:58 <quchen> merijn: Maybe I'm also not using non-"as" qualified imports enough. Anyway, I'll be more careful about using the word namespace then.
07:23:32 <b__> quchen: writeData = toLazyByteString . fromWriteList . (\(l,r) -> writeWord16le l <> writeWord16le r), and nvm
07:23:50 <quchen> b__: Write a where clause.
07:23:50 <acube> There are different namespaces for value constructors and type constructors in haskell
07:23:55 <hseg> acube: If I understand that correctly, specifically the part magic x = magic x, doesn't it mean that magic = (undefined :: Void a b -> x) ?
07:24:11 <acube> hseg: yes it does, just without using undefined :)
07:24:20 <acube> it's similar to the @package void
07:24:31 <acube> ah, doesn't work in-line :(
07:24:33 <acube> @package void
07:24:33 <lambdabot> http://hackage.haskell.org/package/void
07:24:33 <hseg> Couldn't the author just write undefined explicitly?
07:25:46 <acube> hseg: well, it is impossible that this function will ever get evaluated, so it's not really 'undefined'
07:26:03 <hseg> Why is that?
07:27:03 <acube> hseg: the datatype Void has no constructors, so what do you want to pass to f :: Void a b -> c ?
07:27:14 <acube> (Without using undefined itself)
07:27:44 <hseg> Oh. Point taken.
07:28:07 <dncr> @hoogle \ f (a, b, c) = f a b c
07:28:07 <lambdabot> Parse error:
07:28:07 <lambdabot>   \ f (a, b, c) = f a b c
07:28:07 <lambdabot>   ^
07:28:14 <typoclass> quchen: you could think of it this way -- haskell's modules are like c++'s namespaces, but they remove the restriction that you always need to say "NS.f". you can import NS unqualified and just say "f", as long as the name "f" isn't duplicate. (in that case you need to disambiguate)
07:28:21 <merijn> :t uncurry3
07:28:25 <hseg> On to more practical matters. I have some Parsec code that is written monadically. How do I apply <?> to it?
07:28:25 <lambdabot>     Not in scope: `uncurry3'
07:28:25 <lambdabot>     Perhaps you meant `uncurry' (imported from Data.Tuple)
07:28:29 <merijn> hmmm
07:28:36 <dncr> hm
07:28:48 <typoclass> @hoogle uncurry3
07:28:48 <lambdabot> No results found
07:29:06 <quchen> typoclass: Or even better, I could think "stop thinking about your imperative baggage" ;-)
07:29:07 <hseg> For example, in applicative code, I could write Foo <$> parser1 <*> parser2 ... <?> "A foo object"
07:29:57 <typoclass> quchen: i dunno ... seems to be a popular opinion, but in my view it is useful to describe differences and commonalities between languages
07:30:10 <hseg> typoclass: Not really, since if you were to write, e.g. using std::cout;, then the name cout would refer to std's cout.
07:30:58 <typoclass> hseg: i'm not up to date on the c++ side. i was going from how i understood quchen's remarks
07:31:19 <typoclass> hseg: can you write "cout" in c++ to mean "std::cout"?
07:31:33 <merijn> typoclass: Yes
07:31:37 <b__> quchen: ye it's pretty readable this way, cheers
07:31:42 <merijn> typoclass: If you open the std namespace
07:31:46 <hseg> Only if you import it from its namespace. Much like unqualified imports in Haskell.
07:31:55 <typoclass> merijn: alright. seems similar to haskell in this regard
07:32:40 <hseg> In applicative Parsec code, I can write Foo <$> parser1 <*> parser2 ... <?> "A Foo object". How do I do the same for monadic code?
07:34:00 <quchen> hseg: <$> = fmap, <*> = ap?
07:34:08 <quchen> Eh, liftM, not fmap
07:34:37 <quchen> Or even better: write liftM as <$> and ap as <*>, and if it breaks email the package maintainer to include an Applicative instance.
07:34:55 <Botje> hseg: (do ...) <?> "Foo"
07:35:21 <Botje> hseg: oh, don't even need the <?>
07:35:37 <hseg> Botje: So I need to put the do block in parentheses? Makes me want to write my code in applicative style even more.
07:35:43 <hpaste> botje pasted “<?> example for hseg” at http://hpaste.org/87413
07:35:59 <Botje> don't even need the (). I misremembered.
07:36:12 <hseg> Oh. That's nice.
07:36:52 <hseg> Next, is there something like optional p = option Nothing $ Just <$> p ? Looking through the docs yielded nothing
07:37:32 <Botje> I guess you just wrote it :)
07:38:06 <quchen> hseg: optionMaybe?
07:38:27 <quchen> "optionMaybe p tries to apply parser p. If p fails without consuming input, it return Nothing, otherwise it returns Just the value returned by p."
07:39:25 <hseg> quchen: That's exactly what I needed. Thanks.
07:43:06 <hseg> Next, I can't find a more elegant way to write this:
07:43:08 <hpaste> hseg pasted “Class parser” at http://hpaste.org/87415
07:43:36 <hseg> If data type definitions are needed, I'll gladly post them, as always
07:45:19 <Botje> looks rather elegant already.
07:45:24 <Botje> anything in particular standing out?
07:45:43 <hseg> line 5
07:46:20 <Araneidae> Does this function (already) exist: (a->c) -> (b->d) -> Either a b -> Either c d ?
07:46:48 <hseg> Araneidae: :t either
07:46:50 <hseg> :t either
07:46:52 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
07:47:06 <geekosaur> not quite...
07:47:07 <Araneidae> Oh, yes, of course.  I just need Left and Right
07:47:13 <Botje> you could put Class name instead of (,)
07:47:46 <hseg> Right.
07:47:50 <Botje> braces (Class name <$> many classVarDec <*> many subroutineDec
07:48:14 <Araneidae> What about (a,b,c)->c ?
07:48:16 <Botje> or braces $ do {vars <- ...; funcs <- ...; return $ Class name vars funcs }
07:48:34 <Araneidae> Like snd, but a bit more so
07:48:35 <Botje> Araneidae: no built in function for that, sorry. lens has _3, but you might not want to go there already.
07:48:44 <Araneidae> Botje, just so, thanks
07:48:51 <acube> @hoogle thd
07:48:52 <lambdabot> System.IO openBinaryTempFileWithDefaultPermissions :: FilePath -> String -> IO (FilePath, Handle)
07:48:52 <lambdabot> System.IO openTempFileWithDefaultPermissions :: FilePath -> String -> IO (FilePath, Handle)
07:48:52 <lambdabot> Network.HTTP.Auth AuthDigest :: String -> String -> String -> String -> Maybe Algorithm -> [URI] -> Maybe String -> [Qop] -> Authority
07:48:58 <acube> @hoogle trd
07:48:58 <lambdabot> Foreign.C.Types data CPtrdiff
07:48:59 <lambdabot> package astrds
07:49:08 <acube> @hoogle (a,b,c) -> c
07:49:09 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
07:49:09 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
07:49:19 <Araneidae> Yeah, hoogle was unhelpful
07:49:23 <acube> hmm, I thought there was such a function in some package
07:52:08 <supki> @ty (+++)
07:52:10 <lambdabot> ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
07:52:45 <supki> @ty (+++) `asTypeOf` (undefined :: (a->c) -> (b->d) -> Either a b -> Either c d)
07:52:49 <lambdabot> (b -> c) -> (b' -> c') -> Either b b' -> Either c c'
07:53:08 <supki> also known as bimap from bifunctors package
07:56:27 <hseg> How about this? Is my rewrite more readable, and is there room for improvement?
07:56:29 <hpaste> hseg pasted “Variable declaration parser” at http://hpaste.org/87416
07:58:32 <quchen> I think the second one is much less readable.
07:58:52 <no-n> I think Swarovski needs to be banned from hpaste.org :S
07:59:49 <hseg> Really? Hm. I guess you're right. Too much of a good thing, isn't it?
07:59:54 <Araneidae> Is there any way to inject some kind of tracing into my functions, for debugging?
08:00:02 <acube> Araneidae: Debug.Trace
08:00:08 <acube> @hoogle Debug.Trace
08:00:08 <lambdabot> Debug.Trace module Debug.Trace
08:00:08 <lambdabot> Debug.Trace trace :: String -> a -> a
08:00:08 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
08:00:09 <Araneidae> I'm used to sprinkling dodgy code with printfs ...
08:00:11 <Araneidae> Thanks
08:01:20 <Araneidae> printf: the magic dust that just fixes stuff
08:07:32 <Araneidae> Think the trace library is missing this one: traceM a = traceShow a $ return ()
08:08:37 <hseg> Can someone suggest a pastebin for multi-file Haskell projects? I'm on a computer w/o GHCi and need to test some code.
08:09:05 <typoclass> hseg: codepad? not sure
08:09:19 <simpson> hseg: codepad.org and ideone can both run Haskell.
08:09:53 <hseg> Problem is, both are single-file
08:10:27 <hseg> So I will have to concatenate all my files.
08:10:42 <hseg> And I'll have to represent the input as a string
08:10:55 <Botje> hseg: don't you have shell access to a box with ghci?
08:11:06 <hseg> Nope.
08:11:43 <hseg> That *is* one of my projects for when I have some spare time at home.
08:11:44 <Botje> ah.
08:20:14 <hseg> Odd. Both codepad and ideone don't like Text.Parsec.Token
08:21:20 <fubaz> hey, i'm running a series of validations on a record and i'd like to not fail-fast if the record is not valid but return a list of failures in the end. kind of either with failure aggregation. what'd be good way to implement this? :)
08:21:47 <acube> Using a list of failures maybe?
08:21:55 <Botje> fubaz: writer monad, tell for each failure.
08:22:21 <Botje> fubaz: or, maybe, mconcat (map validators record)
08:22:28 <hseg> http://codepad.org/EvBEut6C
08:23:20 <acube> mapMaybe ($ record) validators ? (If each validator only returns one error)
08:24:02 <fubaz> ah
08:24:07 <fubaz> acube, botje, thanks for the ideas!
08:24:15 <fubaz> i'll have to think about them
08:24:43 <fubaz> i was wondering if there was anything kind of "validation" monad available already, as it seems to be quite a common use case
08:24:55 <Botje> yeah, that'd be the writer monad.
08:25:00 <fubaz> thought about the writer monad already, but as said, was curious about other approaches
08:25:13 <fubaz> yea :)
08:25:55 <fubaz> thanks :)
08:26:35 <Botje> hseg: any specific reason you're not doing data ... = ... deriving (Show, Eq) ?
08:26:56 <hseg> Just because it looks nicer, IMO.
08:27:44 <Botje> hseg: I ran your thing through ghci, it complained about the import Syntax.Jack on line 5 and a stray tab on line 335
08:27:55 <mm_freak> fubaz: (Monoid e) => Either e a
08:28:06 <mm_freak> that's my approach
08:28:24 <Botje> hseg: after that, multiple declarations of Class and Var
08:28:28 <mm_freak> fubaz: well, almost…  you have to wrap the Either in a newtype
08:28:44 <mm_freak> newtype Error e a = Error (Either e a)
08:28:49 <hseg> Oops on the import, and why would it complain on an embedded tab in a string?
08:28:50 <Botje> you're not allowed to use the data constructor Class for both type Class and type VarName
08:28:59 <mm_freak> instance (Monoid e) => Alternative (Either e)
08:29:00 <fubaz> mm, yea botje already suggeste that. seems brilliant to me! simple but effective :)
08:29:00 <Botje> lexical error in string/character literal at character '\t'
08:29:03 <Botje> don't look at me :)
08:29:24 <mm_freak> fubaz: if you also need to have continuation spots, then you can just use ContinueT =)
08:29:29 <mm_freak> @hackage continue
08:29:29 <lambdabot> http://hackage.haskell.org/package/continue
08:29:37 <fubaz> mm, hey, thanks! :)
08:29:42 <fubaz> i'll look at that :)
08:29:43 <hseg> Right. That's one of the reasons I'm trying to run this: HLint doesn't complain, but I don't know whether my code is syntactically correct.
08:29:52 <mm_freak> for example, if something fails, try again with another value for a certain variable
08:30:56 <fubaz> mm, ah
08:30:59 <fubaz> cool
08:31:40 <mm_freak> fubaz: try pressing tab after the "mm" a number of times =)
08:32:09 <saml> how would you have [a]  that is never empty?  a list with at least one value at all times
08:32:16 <hseg> OK, fixed those. codepad still complains on import Text.Parsec.Token http://codepad.org/lM0r0nZR
08:32:20 <saml> would that be  monad?
08:32:49 <Botje> hseg: if it doesn't exist it doesn't exist :/
08:32:59 <hseg> :-(
08:33:04 <Botje> saml: you create a custom data type like data List a = One a | More a (List a)
08:33:09 <hseg> How shall I test my code, then?
08:33:24 <saml> Botje, would your List a  instance of Monad?
08:33:37 <Botje> saml: only if you wanted/needed it to.
08:34:10 <Botje> hseg: you can't run it at home or something?
08:34:13 <saml> oh i want everything to be monad
08:34:13 <fubaz> mm_freak, sorry :D just never got used to pressing the tab =p
08:34:43 <Botje> saml: bad news. Data.Set can never be a monad.
08:34:49 <mm_freak> =)
08:35:09 <hseg> Not really. Won't be at home until later this week, and I need to test this for class...
08:35:12 <saml> noooooooooooooooooo
08:35:21 <mm_freak> saml: a nonempty list is a monad
08:35:29 <mm_freak> (the concept of …)
08:35:31 <hseg> Wait. I think I have an idea as to where I could test this...
08:35:49 <acube> Lambdabot? XD
08:36:11 <hseg> XD. Not with >300 loc
08:36:17 <Botje> hseg: surely you can ask your school for a shell to test this on
08:36:21 <saml> http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros
08:36:21 <mm_freak> data NonEmpty a = NonEmpty { head' :: a, tail' :: [a] }
08:36:26 <Botje> (if it is for school, of course)
08:36:55 <hseg> Yes. Just remembered school gave my class a VM we could all use to test our languages on.
08:37:01 <hseg> With admin access
08:37:25 <Botje> ah, excellent
08:37:27 <hseg> A *shared* VM, accessible from the outside, with *admin* access for >30 ppl
08:37:36 <Botje> slightly less so.
08:37:38 <hseg> They're insane, but right now, I don't care.
08:37:45 <Botje> and people won't abuse that to peek at other implementations, I think :P
08:39:04 <hseg> :-D. It's for Principles of Programming Languages. They think that giving us a non-mainstream language and having us implement a large-scale project in it will teach us about what languages are suited for what tasks
08:39:11 <hseg> Luckily, I got Haskell
08:39:26 <acube> What were the alternatives?
08:40:17 <simpson> It's always Prolog and FORTH.
08:40:23 <hseg> Some poor sods got Mozart. Others got Racket, Objective-C, ...
08:40:36 <danharaj> Racket sounds nice.
08:40:39 <scriptor> Objective-C is a non-mainstream language?
08:40:47 <fubaz> scriptor, i was just about to ask that :D
08:41:18 <hseg> Yeah, they said "you're not supposed to be familiar with the language you got" :D
08:41:57 <ocharles> Botje: you are refering to Data.Set.Set specifically, and not sets in general, right?
08:42:03 <hseg> Been reading Haskell since last summer, a friend who got Objective-C develops iPhone apps, and a friend who got Racket is an avid LISPer
08:42:57 <simpson> hseg: Heh. I didn't take it, but there was a class at my university that surveyed different styles of computation. The class did Prolog, Python, Haskell, Scheme, and Forth.
08:43:10 <simpson> It's funny to watch Java-only programmers in that class.
08:43:32 <hseg> :D. In my uni, it's an obligatory course for CS.
08:44:00 <simpson> I was a music major. :3
08:44:55 <hseg> simpson: Sounds fun. Studying towards BSc in CS.
08:47:37 <simpson> hseg: Awesome.e
08:50:24 <hseg> Anyhow, I got GHCi. Now to remove the plethora of bugs in my code....
08:53:19 * hackagebot persistent-template 1.2.0.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.2.0.1 (MichaelSnoyman)
09:05:05 <conphile> @pl \s -> a <$> (b s)
09:05:05 <lambdabot> (a <$>) . b
09:05:14 <conphile> :|
09:05:27 <eikke> ?
09:05:33 <simpson> conphile: Not what you wanted?
09:05:42 <conphile> hoped it might be cleaner than that
09:06:00 <Araneidae> What commands does lambdabot understand?
09:06:03 <Araneidae> !help
09:06:08 <Araneidae> not that one
09:06:17 <merijn> @help
09:06:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:06:18 <simpson> Araneidae: She doesn't use !, she uses @.
09:06:20 <int-e> fmap a . b  looks fine.
09:06:21 <eikke> :t fmap a . b
09:06:21 <typoclass> @list
09:06:22 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
09:06:23 <lambdabot>     Couldn't match expected type `a0 -> b0' with actual type `Expr'
09:06:24 <lambdabot>     In the first argument of `fmap', namely `a'
09:06:24 <lambdabot>     In the first argument of `(.)', namely `fmap a'
09:06:55 <typoclass> Araneidae: your best bet is to play around with @help privately (use "/query lambdabot"), and to ask folks in here :-)
09:07:20 <Araneidae> Ok, guess I'll give it a try
09:07:49 <Araneidae> Is there any way to avoid having to pepper my code with calls to lift?  Getting a little irritating!
09:08:11 <Araneidae> Think I want a mechanism for automatic coercion...
09:08:18 * hackagebot scion-browser 0.2.15 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.2.15 (JeanPhilippeMoresmau)
09:09:36 <danharaj> :t lift
09:09:39 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
09:10:14 <ChongLi> :t fix
09:10:21 <lambdabot> (a -> a) -> a
09:10:34 <Botje> Araneidae: what operations do you need to lift?
09:10:37 <danharaj> lift is one of the warts with Monad Transformers. If you are lifting a few functions a lot, you can define foo' = lift foo and then use that to reduce clutter.
09:10:50 <Araneidae> Not a bad idea
09:11:13 <Araneidae> Unfortunately the type signature for foo' gets annoying!
09:12:13 <Araneidae> Botje, my own constructions -- I'm using Data.Binary.Get with both ReaderT and StateT layered over it, so at one point I have to do double lifts :(
09:12:19 <danharaj> In many cases you do not need to supply a type signature, and in nearly every case you only need to supply it once in the module where you bind the name.
09:12:43 <elliott> Araneidae: the mtl has typeclasss that let you avoid lifting almost always
09:12:53 <elliott> *typeclasses
09:12:56 <Araneidae> danharaj, well, I've set -Wall, and I'd prefer to work with that
09:13:02 <Botje> Araneidae: don't ReaderT have instances for monad transformers as well?
09:13:42 <Araneidae> Um um .  Don't understand.  ReaderT *is* a transformer, what do you mean Botje ?
09:14:11 <Araneidae> elliott, don't think I follow.  Guess I'll need to show some code?
09:14:22 <danharaj> Araneidae: there is a class called MonadReader which provides reader functionality so you don't have to lift them.
09:14:24 <elliott> Araneidae: in general you can just omit the "lift" entirely.
09:14:26 <elliott> but sure.
09:15:00 <Araneidae> danharaj, but I need the Reader to drive my operation of Get, so doesn't that mean it has to be a transformer?
09:15:33 <danharaj> Araneidae: there is also a class for State monads :P
09:15:40 <simpson> Oh, you're talking about lifting Get's operations.
09:15:45 <simpson> There is no GetT.
09:15:51 <danharaj> oh I see yes my mistake.
09:17:22 <Araneidae> simpson, yes, of course: I'm lifting stuff like getWord8 and its ilk
09:18:53 <hpaste> Araneidae pasted “PvTypes” at http://hpaste.org/87424
09:19:33 <Araneidae> Huh.  I've moved away from camelCase (looking at the warnings)
09:20:04 <Araneidae> Can I get some critique of my code?  It's a lot bigger than I wanted, but it's been growing...
09:22:11 <danharaj> Araneidae: sure. Can you give me a hint what it does and where I should start reading? :)
09:22:16 <Araneidae> Sure.
09:22:38 <Araneidae> It's all about serialising and deserialising the FieldType structure (line 37)
09:23:06 <Araneidae> This follows a byte serialisation protocol that's defined by a working group, we'll not go there for now.
09:23:35 <Araneidae> One annoying complication is that the endian of the byte stream is ... flexible ... hence the ReaderT Endian wrapping
09:24:24 <danharaj> Indeed. Thankfully if there are any more complications ReaderT will scale just fine.
09:24:26 <Araneidae> The second complication is the presence of a data dictionary (TypeLookup) -- I've only implemented support for reading not writing so far,
09:25:32 <fizbin> > minBound :: Word64
09:25:34 <lambdabot>   0
09:25:46 <fizbin> > maxBound :: Word64
09:25:49 <lambdabot>   18446744073709551615
09:26:00 <Araneidae> > 2^63-1
09:26:03 <lambdabot>   9223372036854775807
09:26:04 <danharaj> Araneidae: ok, my first question is about your choice of ArrayFlag. Instead of a flag, why not give FieldType two constructors, one for NonArrays and one for Arrays?
09:26:10 <applicative_> Araneidae: the == tests in line 180ff should be replaced by a pattern match, I'd think
09:26:26 <applicative_> oops interfering with danharaj
09:26:35 <Araneidae> danharaj, sounds sensible
09:26:37 <danharaj> applicative_: by all means if you want to be captain of this ship go ahead :P
09:26:57 <simukis_> @src maxBound
09:26:57 <applicative_> no operative brain here
09:26:57 <lambdabot> Source not found. The more you drive -- the dumber you get.
09:27:00 <Araneidae> applicative_, I was wondering how to pattern match that
09:27:11 <simukis_> eh?
09:27:13 <Araneidae> I can cope with two streams
09:27:53 <danharaj> Araneidae: I would use a guard. I don't like pattern matching numeric values. Are you familiar with guard syntax?
09:27:59 <simukis_> @src maxBound :: Word64
09:27:59 <lambdabot> Source not found. You untyped fool!
09:28:00 <Araneidae> How do I pattern match in an expression?  Is that using case
09:28:07 <ATuin> hi
09:28:11 <danharaj> Araneidae: that is correct.
09:28:45 <Araneidae> Ok, think I can see how to rewrite lines 184..204 using case then
09:29:19 <Araneidae> I don't think I'm familiar with guards in case though, how do I do that?
09:29:50 <elliott> you don't need guards to pattern match on integers
09:29:59 <fizbin> simukis_: maxBound is part of the Bounded typeclass.
09:30:01 <Araneidae> case x of { | x < 10 -> 33; | otherwise -> 99 }
09:30:06 <Araneidae> looks dodgy!
09:30:15 <elliott> case x of { 0xFF -> ...; _ -> ... } works fine
09:30:22 <Araneidae> > \x -> case x of { x | x < 10 -> 33; | otherwise -> 99 }
09:30:28 <lambdabot>   <hint>:1:37: parse error on input `|'
09:30:28 <elliott> can extend that with 0xFE, 0xFD
09:30:42 <elliott> similarly e.g. decode_int_size could do this
09:30:45 <danharaj> elliott is correct, I may have been exposing a little bit of my personal idiosyncrasies.
09:30:45 <Araneidae> Yes, think I'm only doing equality matching
09:30:52 <elliott> decode_int_size 0 = ...; decode_int_size 1 = ... works too
09:30:53 <Araneidae> oh oh oh
09:30:57 <elliott> (it desugars to the equivalent of the guards you have)
09:30:58 <Araneidae> Of course
09:31:05 <elliott> if you do want to use cguards in case then it'd look like
09:31:14 <elliott> case x of { _ | x == 0xFF -> ...; ... }
09:31:31 <elliott> (or case long expression of { x | x == 0xFF -> ...; ... }
09:31:32 <elliott> )
09:31:36 <danharaj> yes, you need a dummy match to attach guards to.
09:31:51 <Araneidae> splendid.  Ok, that's an easy rewrite, will do that
09:32:06 <danharaj> I like using guards because it is often that I start with only equalities and end up needing other bool tests later on.
09:32:31 <Araneidae> And getting rid of ArrayFlag will make me happy I think
09:33:06 <danharaj> Araneidae: if that will make you happy, perhaps getting rid of SignedFlag will too. It looks like you are only using it in RawFieldType, which means you could turn it into two patterns of RawFieldType instead.
09:33:53 <simukis_> fizbin: I sure know that (which is also why I tried getting source of specialised maxBound). I'm just a bit hurt now being called untyped.
09:34:01 <danharaj> Araneidae: actually nevermind, I see you use it alone in put_type.
09:34:18 <Araneidae> danharaj, but then I start drifting away from the original wire spec.  Not so sure about that one.
09:34:29 <danharaj> Araneidae: I agree with your judgment.
09:35:11 <Araneidae> I'm going to try to persuade the writers of the wire spec to support unions.  Wish me luck: they come from Java land.
09:35:36 <danharaj> Politics is beyond my ability :P
09:35:37 <elliott> if any of them know C you'd better specify they're tagged unions :p
09:35:47 <Araneidae> Yes.
09:36:09 <Araneidae> I googled java+unions and the results were quite amusing if sad
09:36:28 <Araneidae> Apparently we#re supposed to do unions by using subclasses
09:38:35 <danharaj> :t (^)
09:38:40 <lambdabot> (Integral b, Num a) => a -> b -> a
09:38:43 <applicative_> Araneidae: sort of like so http://hpaste.org/87426
09:39:21 <Araneidae> applicative_, thanks.
09:39:47 <elliott> applicative_: hm, why the case rather than direct pattern-matching in decode_int_size?
09:40:03 <Araneidae> I was wondering which looks better in that case as well
09:40:48 <hpaste> Araneidae pasted “decode_int_size” at http://hpaste.org/87427
09:40:52 <applicative_> elliott: which line?
09:40:53 <Araneidae> I've just written a bunch of direct matches: http://hpaste.org/87427
09:41:08 <hpaste> elliott annotated “magna cum case analysis” with “Araneidae: how I'd do those functions” at http://hpaste.org/87426#a87428
09:41:09 <danharaj> By the way guys, you can annotate and edit hpastes and it has version control ;)
09:41:20 <elliott> applicative_: 47-
09:41:36 <applicative_> elliott: oh yeah, it's because I was using a regex
09:41:48 <Araneidae> Yes, that looks good to me
09:41:49 <applicative_> and the transposition was immediate
09:42:06 <danharaj> Araneidae: Can you give me a rundown of Get's error handling and how you are using it?
09:42:24 <Araneidae> It's as minimal as can be, I think.
09:42:25 <applicative_> now that I think of it it could have been the other way
09:42:35 <elliott> Araneidae: (http://hpaste.org/87426#a87428, if you didn't see)
09:42:36 <Araneidae> Errors are reported by fail and can be caught
09:42:45 <danharaj> Araneidae: for example, in put_length you use `error` which will crash your process. You should use fail.
09:42:56 <danharaj> > error "oops"
09:42:58 <lambdabot>   *Exception: oops
09:43:12 <danharaj> > fix error
09:43:13 <Araneidae> danharaj, nice catch -- but those ones are deliberate!
09:43:16 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
09:43:26 <danharaj> Araneidae: oh, alright :P
09:43:38 <applicative_> I think the compiler is able to get rid of some of these equality tests
09:43:39 <Araneidae> The reason is: 1/ put_length (-1) dies, I laugh -- don't do that
09:44:00 <Araneidae> 2/ put_length something_huge is impossible on a 64-bit machine (ho ho ho)
09:44:03 <applicative_> so the transformation to case might not matter, but equality tests are generally lame
09:44:19 <Araneidae> Ok, I'll replace equality with matching
09:46:24 <Araneidae> Thanks for the critique folks :D
09:46:41 <applicative_> Araneidae: note that hlint only carps about camel_case for things at the top level; I think using underscores for things in 'where' is actually good policy.
09:47:17 <matthiasgoergens> Was there a Traversable instance for ((,) a)?
09:47:36 <Araneidae> applicative_, oh, that's an interesting thought.  I could live with that, and it's a nice distinction to make
09:47:55 <ATuin> what does an expression inside $()?
09:47:55 <arkeet> > (1,2) ^.. traverse
09:47:58 <lambdabot>   [2]
09:48:04 <danharaj> ATuin: that is template haskell.
09:48:15 <ATuin> oh
09:48:19 <ATuin> ok
09:48:27 <arkeet> matthiasgoergens: yes
09:48:29 <danharaj> Araneidae: So I just finished lightly reading the rest of the module and it seems to be rather nice code.
09:48:30 <applicative_> Araneidae: if I know that everything imported or at the top level is camelCased, then I don't get worried if I see decode_int_size and dont know what it means, I expect the explanation
09:48:36 <arkeet> ...somewhere
09:49:38 <arkeet> matthiasgoergens: oh yeah, the instance is in Control.Lens.Internal.Instances
09:49:51 <Araneidae> Thanks folks.  Must go outside to catch the sun for a bit.  I'll be back.
09:52:54 <danharaj> Peaker: You seem to be having connectivity issues.
09:52:58 <danharaj> welp.
09:53:18 <danharaj> elliott: How are you this fine afternoon?
09:53:40 <elliott> drowning in joinquits, it seems :P
09:54:14 <danharaj> elliott: Are you aware that there is another elliott in this channel ruining tab completion for your name.
09:54:28 <otters> elliottcable?
09:54:30 <otters> he's insane
09:54:41 <elliott> danharaj: there is sometimes also an elliottt
09:55:36 <elliott> none can approach the purity and perfection of my nick
09:56:17 <danharaj> Peaker has to notice eventually.
09:56:57 --- mode: ChanServ set +o elliott
09:57:21 --- mode: elliott set +b *!~Peaker@bzq-79-180-190-13.red.bezeqint.net$##fixyourconnection
09:57:26 --- mode: elliott set -o elliott
09:57:56 <danharaj> elliott: good banish
09:58:24 * elliott will take it off when the joinquit spam stops in -blah :P
09:58:53 <danharaj> Has anyone used conduit? I am being forced into it by my decision to use warp.
10:14:11 <ChongLi> what's the deal with Peaker?
10:14:18 <ChongLi> I see that guy on reddit occasionally
10:14:29 <danharaj> Peaker is known to be on reddit.
10:14:56 <ChongLi> just a troll?
10:15:42 <danharaj> Certainly not.
10:15:45 <danharaj> Why would you assume so?
10:17:53 <Philippa_> not infrequent behaviour that is easy to read as trolling? But there's helpful stuff there sometimes too, and it's not like I'm always the most polite person in chan myself
10:18:44 <klrr> why aint there no women(1), showing manuals for UI's ? :)
10:19:24 <conphile> believe the reason is documented in sexism(7)
10:19:30 <elliott> klrr: not cool and off-topic
10:19:48 <danharaj> elliott++
10:20:00 <klrr> wtf why is my message related to sexism?
10:20:08 <klrr> also, is there any haskell conferences?
10:20:24 <conphile> http://www.haskell.org/haskellwiki/Conferences
10:20:35 <danharaj> this one is coming up: http://cufp.org/conference
10:20:45 <elliott> conphile: you have a good nick for answering questions about con(ference)s
10:20:48 <klrr> danharaj:  conphile  thanks
10:21:00 <danharaj> also constructors
10:21:23 <cschneid> is there a good haskell conference that's practicality based, as opposed to theory oriented? (ie, "here's a cool pattern for working" as opposed to "hey, here's a cool new category theory thingy")
10:21:27 <conphile> elliott: hah
10:21:45 <danharaj> cschneid: There is often no difference between those two.
10:22:14 <danharaj> But yes, ICFP and CUFP tend to have loads of pragmatic stuff.
10:23:20 * hackagebot atomic-primops 0.1.0.0 - A safe approach to CAS and other atomic ops in Haskell.  http://hackage.haskell.org/package/atomic-primops-0.1.0.0 (RyanNewton)
10:23:39 <cschneid> danharaj: are there some big names of people to follow on the pragmatic side of things in the haskell community?
10:24:00 <danharaj> cschneid: If I gave you such a list it would almost certainly be incomplete.
10:24:03 <cschneid> "here's how I like to organize stuff", "here's the considerations when I make a module", etc.
10:24:45 <cschneid> questions like that seem to be hard to answer in every language. I'm at the limits of the intro books, but not at the level of full-timers in haskell.
10:25:11 <danharaj> cschneid: Those are difficult questions and I am not sure who explicitly answers them. Have you tried fpcomplete?
10:25:12 <acube> Is it possible to have "error xxx" show the source line on which the error was thrown?
10:25:19 <cschneid> danharaj: not sure what that is. so no.
10:25:28 <cschneid> ohh, cool
10:25:33 <jeltsch> Hi, when will the new Haskell Platform be released. I see that the anticipated release date was yesterday.
10:26:25 <geekosaur> jeltsch, it got delayed by the need for some bugfixes to ghc and cabal; next HP release is in testing per mailing list
10:26:52 <jeltsch> geekosaur: Any estimation about a release date?
10:27:08 <danharaj> acube: Control.Exception has `assert` which does that, but that is not as general. I am not sure otherwise.
10:27:34 <acube> danharaj: That was exactly what I needed, thanks!
10:29:22 <geekosaur> jeltsch, I'm not seeing an updated timeline. RC1 packages are supposed to be forthcoming shortly
10:30:15 <geekosaur> (discussion is on libraries@haskell.org if you want to follow along etc.)
10:30:23 <Philippa_> cschneid: Anglohaskell used to run on that kind of basis, but got a lot of (mostly younger) academic and semi-academic presence anyway
10:31:56 <jeltsch> geekosaur: What GHC version will be in the new Haskell Platform?
10:33:02 <geekosaur> 7.6.3
10:33:18 <geekosaur> which is 7.6.2 plus a single bug fix deemed necessary for the platform
10:33:28 <jeltsch> geekosaur: Great.
10:33:29 <danharaj> What is the bug?
10:34:25 <monoidal> danharaj: some code accepted by 7.6.1 was accepted by 7.6.2 but looped
10:34:33 <danharaj> oh dear
10:34:59 <danharaj> hm, I am on 7.6.1, should I upgrade to 7.6.3?
10:35:55 <monoidal> danharaj: 7.6.1, on the other hand, has a bug that allows to write unsafeCoerce using only let, where, type signatures and lambda
10:36:03 <Philippa_> cschneid: we got to hear about things like livecoding as well, though!
10:36:14 <danharaj> monoidal: oh dearer
10:36:36 <monoidal> danharaj: but since nobody noticed for a long time, it does not really seem *that* serious
10:36:47 <geekosaur> http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/release-7-6-3.html
10:36:52 <monoidal> danharaj: if it's not a big hassle for you, I'd upgrade to 7.6.3
10:37:03 <geekosaur> they considered 7.6.1 but yes, that has a nasty bug too
10:37:19 <geekosaur> and they really didn't want to stay with 7.4
10:37:20 <monoidal> not that 7.4 has it too (and earlier AFAIR)
10:38:26 <monoidal> yea, 7.2 has it too
10:41:55 <acube> Can I have a warning when I use for instance 300 as a Word8 value? Something like "Warning: literal overflow"
10:42:33 <elliott> hm, does -Wall not give one?
10:43:04 <acube> :set -Wall in ghci + 300 :: Word8 doesn't give a warning, haven't tried a real source code file yet
10:44:58 <acube> elliott: no, it doesn't :(
10:45:16 <elliott> perhaps request it on the ghc trac
10:46:19 <monoidal> note that in general it's hard: you can define x = 300 :: Num a => a, and only much later use x :: Word8
10:50:58 <Heather> hello
10:51:13 <Cale> hi
10:51:15 <Heather> $ is X Y ?
10:51:31 <Cale> f $ x = f x
10:51:34 <fizbin> @src ($)
10:51:35 <lambdabot> f $ x = f x
10:51:38 <Heather> yes
10:51:53 <Heather> is it has higher priority than right pipe?
10:52:00 <Cale> The main difference being that $ has really low precedence
10:52:23 <Cale> while real function application (space) binds tighter than any infix operator
10:52:45 <Heather> so it's not alike ml <| ?
10:52:53 <Heather> because of priority
10:53:05 <fizbin> Heather: ($) has lower precedence than anything else.
10:53:31 <Cale> So if you write  foo bar baz $ quux fred
10:53:40 <Cale> it's like (foo bar baz) (quux fred)
10:55:09 <fizbin> Also, a b $ c d $ e f is like (a b (c d (e f)))
10:56:08 <Heather> what is haskell right pipe ?
10:56:35 <Cale> right pipe?
10:56:55 <Heather> |>
10:57:03 <monoidal> Heather: there's no mainstream flipped ($), it's less needed in haskell
10:57:10 <fizbin> I think the lens library has a symbol for that, though.
10:57:15 <monoidal> Heather: some libraries use (&)
10:57:32 <fizbin> That's what lens uses. (&)
10:57:58 <Heather> I see
10:58:08 <fizbin> It is of course trivial to define your own operator that means this.
10:58:25 * hackagebot IORefCAS 0.2.0.1 - Atomic compare and swap for IORefs and STRefs.  http://hackage.haskell.org/package/IORefCAS-0.2.0.1 (RyanNewton)
10:58:27 * hackagebot lockfree-queue 0.2.0.1 - Michael and Scott lock-free queues.  http://hackage.haskell.org/package/lockfree-queue-0.2.0.1 (RyanNewton)
10:58:29 * hackagebot yi 0.6.7.0 - The Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-0.6.7.0 (DmitryIvanov)
10:58:37 <Heather> f (&) x = x f ?
10:58:53 <monoidal> Heather: f & x = x f
10:59:12 <monoidal> Heather: but, again, you need this less in haskell than ML-like languages
10:59:20 <Heather> a $ b & c ?
10:59:21 <Nafai> Woah, a new version of Yi?
10:59:52 <fizbin> Heather: that means: (a (c b))
11:00:25 <Heather> and a <| b |> c ?
11:00:35 <fizbin> Heather: if you're defining this on your own, you probably also want to add infix* declarations.
11:00:35 <Heather> if someone know ml
11:03:25 * hackagebot yi-contrib 0.6.7.0 - Add-ons to Yi, the Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-contrib-0.6.7.0 (DmitryIvanov)
11:03:34 <Cale> Heather: What does that mean in ML?
11:03:52 <Cale> (I don't know what the relative fixity of <| and |> is)
11:04:27 <Heather> it doesn't work on ml
11:04:34 <Heather> same way
11:05:10 <Cale> Heather: My recommendation to start with is just to write things using $ sparingly, and trying not to chain it.
11:05:30 <Cale> If you find yourself writing f $ g $ h $ x, consider writing f . g . h $ x instead
11:05:53 <Cale> Function composition has much nicer properties than application
11:06:21 <ChewieBeardy> I've always found the first from to be more readable to be honest
11:06:29 <Cale> For example, g . h will be meaningful
11:06:40 <Cale> but g $ h will probably be a type error there
11:07:51 <Cale> and it's a good trick to get you thinking more in terms of composing functions directly
11:09:03 <Heather> Cale what's . ?
11:09:04 <Heather> )
11:09:09 <Heather> I forgot
11:09:09 <ChewieBeardy> function compoistion
11:09:20 <Cale> (f . g) x = f (g x)
11:09:42 <Heather> hm...
11:10:47 <monoidal> > map (sin . cos) [1,2]
11:10:53 <lambdabot>   mueval: ExitFailure 1
11:10:53 <lambdabot>  mueval: Prelude.undefined
11:11:09 <Cale> > map (sin . cos) [1,2]
11:11:13 <lambdabot>   [0.5143952585235492,-0.4042391538522658]
11:12:17 <conphile> > map (sqrt . (** 2)) [1, 2]
11:12:20 <lambdabot>   [1.0,2.0]
11:13:01 <Heather> I see
11:13:03 <applicative> > let square x = x * x; heather x = square (sum (map square x)) in heather [1,2,3,4]
11:13:06 <lambdabot>   900
11:13:11 <applicative> > let square x = x * x; heather = square . sum . map square  in heather [1,2,3,4]
11:13:15 <lambdabot>   900
11:13:37 <ChewieBeardy> congratulations, you are now a function!
11:14:07 <Heather> )
11:14:28 <Heather> it's not me, it's lowercased
11:15:33 <Cale> Yeah, you'd be a data constructor, a type constructor, a class, or a module. :)
11:15:42 <applicative> yes,, Heather would have to be a data constructor data Haskell = ChewieBeardy | Heather | Cale
11:15:55 <applicative> Cale is too fast for me
11:16:01 <Heffalump> applicative: sounds like Haskell isn't Turing complete
11:16:09 <merijn> Cale: Or a type function!
11:16:16 <applicative> I meant Haskeller
11:16:25 <applicative> still incomplere
11:17:27 <applicative> yes,, Heather would have to be a data constructor data Haskeller = ChewieBeardy | Heather | Cale | Heffalump | Other String
11:17:36 <applicative> there
11:17:46 <Heather> )
11:18:03 <Araneidae> Can I put a class constraint on a type constructor definition?  Eg type MyType a = SomeClass a => Blah a .  That syntax is wrong (produces a mysterious errour about RankNTypes)
11:18:26 <monoidal> Araneidae: you can. Just put {-# LANGUAGE RankNTypes #-} on top of the file.
11:18:45 <donri> don't you need some forall for that
11:19:11 <Araneidae> Is the syntax right?  Seems I've put the constraint on a after I've first named it, which seems odd
11:19:13 <monoidal> donri: here, no
11:19:17 <applicative> No wait
11:19:41 <monoidal> donri: but if it was MyType = SomeClass a => Blah a, it would still be legal. I recently filled a ticket to change this.
11:19:46 <applicative> Araneidae: do you want the rank 2 type?
11:20:03 <Araneidae> To be honest, I really don't know!
11:20:07 <tdammers> existential quantification I'd guess
11:20:23 <tdammers> data MyType a = forall a. (SomeClass a) => Blah a
11:20:27 <applicative> Araneidae: I mean, do you want a type synonym for that rank 2 type?
11:20:43 <Araneidae> Rank 2 type?
11:21:01 <Araneidae> Do you mean type constructor, like a Monad?
11:21:05 <monoidal> no
11:21:26 <monoidal> Araneidae: here's an example of rank-2-type
11:21:34 <monoidal> f x = x ["a"] + x [0,1]
11:21:49 <monoidal> you might expect that you would call "f length" and get 1 + 2 = 3
11:21:58 <Araneidae> eww
11:22:03 <Araneidae> No, I'm not after that!
11:22:14 <monoidal> but, if you try to compile the definition of f, it will refuse because "x" is not known to be polymorphic
11:22:22 <Araneidae> A higher grade of polymorphism
11:22:43 <monoidal> Araneidae: here f :: (forall a. [a] -> Int) -> Int
11:22:51 <monoidal> so the function *takes* a polymorphic value
11:23:00 <Araneidae> No, I just want to say up front that I expect the parameter to my type constructor to have the interface of a particular class.
11:23:04 <monoidal> you cannot give it a function [Int] -> Int, for example.
11:23:10 <Araneidae> I seem to remember that that's not doable
11:23:25 * hackagebot abstract-deque 0.1.7 - Abstract, parameterized interface to mutable Deques.  http://hackage.haskell.org/package/abstract-deque-0.1.7 (RyanNewton)
11:23:41 <Araneidae> Yes, I can see that that could be jolly useful.  I'll put that in my memory for another day
11:23:45 <merijn> Araneidae: I don't think so, but you can have type aliases for sets of typeclass constraints, if you like (by using ConstraintKinds)
11:23:49 <monoidal> Araneidae: do you want MyType a -> Int to work as SomeClass a => Blah a -> Int?
11:23:54 <applicative> Araneidae: the most obvious thing you might mean was rejected by the Haskell 2010 report
11:23:55 <Araneidae> Yes
11:23:56 <applicative> or whatever it was
11:24:18 <monoidal> Araneidae: if so, it will not work with your definition. It will mean that MyType a -> Int is (SomeClass a => Blah a) -> Int
11:24:35 <Araneidae> Ok, that's good, I thought my syntax looked dodgy
11:24:47 <c_wraith> wtf
11:24:50 <c_wraith> I have a blackhole leak
11:25:04 <monoidal> Araneidae: (SomeClass a => Blah a) -> Int is different from SomeClass a => Blah a -> Int
11:25:17 <c_wraith> I, uh..  guess that implies excessive recursion while evaluating some expression?
11:25:31 <applicative> Araneidae: even if you insist that things your type constructor applies to will belong to some class, still, when you define a function involving it, you'll need to mention the constraint
11:26:07 <Araneidae> Yes, I understand.  Ah well, I'll define the type as is
11:27:05 <elliott> you can do it with GADTs though.
11:27:09 <elliott> but it's generally best not to
11:27:26 <merijn> Araneidae: Like I said, if your constraints become really annoying, then this is possible "type Foo a = (Bar a, Baz a, Xyzzy a)"
11:27:29 <immanuelkant> s
11:27:34 <merijn> (with ConstraintKinds, that is)
11:27:57 <Araneidae> merijn, thanks, I was looking on http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/constraint-kind.html , guess that's got the details
11:28:08 <Araneidae> So that's a type which isn't a type at all?
11:28:23 <Araneidae> ... because all the things on the rhs are classes
11:28:37 <monoidal> normal types have kind *. classes have kind Constraint
11:28:45 <monoidal> Num :: * -> Constraint
11:28:55 <Araneidae> Oh good grief!  Thanks, had no idea
11:29:00 <applicative> hah, if you write data Show a => ShowableThing a = ShowableThing a it says, use -XDatatypeContexts
11:29:11 <Araneidae> Extending the category of kinds....
11:29:25 <Araneidae> Right.  Back to the simple corner of the language
11:30:46 <elliott> Araneidae: what monoidal said is only true with the ConstraintKinds extension, btw
11:31:53 <merijn> Araneidae: Well, to be fair once you can read kind signatures, things like "Num :: * -> Constraint" shouldn't be too complicated :p
11:32:31 <merijn> Num is a just a type function taking a type and returning a Constraint there
11:32:53 <merijn> Similarly, "Functor :: (* -> *) -> Constraint"
11:33:08 <merijn> (Takes a type that takes a type and returns a type to return a constraint)
11:33:31 <Araneidae> Sure ... but it makes me wonder what kind of thing a Constraint really is.  After all, it's a bit glib to talk about type "functions" ... only in the mind of the compiler, perhaps?
11:33:54 <merijn> Araneidae: "type function", not function :)
11:34:00 <Araneidae> Anyhow, let me not go wandering into the garden of peculiar type theory ...
11:34:01 <Araneidae> yeah
11:34:19 <merijn> Araneidae: Type functions being things that operate on types and have to be "evaluated" at compile time, rather than runtime
11:34:42 * Heather disappears, thanks to all, see you next time
11:34:55 <Araneidae> sure sure ... but the semantics of type functions seems to be a much more thorny issue.  So many different theories of what they mean...
11:35:01 <merijn> Constraint is some GHC/ConstraintKinds specific thing, which is only used for typeclasses constraints
11:35:15 <merijn> There's different theories of what they mean?
11:35:28 * Araneidae used to study Dependent Types in Fibrations -- I've escaped!
11:36:05 <Philippa> Araneidae: so yeah, GHC's specific notion of Constraint is, well, GHC-specific? But you can at least partly derive it from older descriptions of qualified types
11:36:52 <Philippa> (the constraints in HM(X) are related, of course)
11:37:43 <c_wraith> aaargh. I have no idea why this code is overflowing. It has to be something really dumb that anyone not-me would catch instantly, but I can't post it publicly to just ask.
11:38:22 <Philippa> Araneidae: and Constraint is "just" the sort of things that go on the LHS of a =>
11:38:54 <Philippa> (Evidence : Constraint, s.t. evidence proves the constraint holds - typeclasses are all about a reasonably general mechanism for handling this)
11:39:01 <Araneidae> Philippa, I can see that it makes sense, and I'll come back to it ... later!  Thanks
11:39:02 <Philippa> but yeah, I shall leave you be
11:39:06 <Araneidae> ta
11:43:34 <Peaker> danharaj, notice that I'm disc'ing?
11:43:45 <Peaker> doh, my train station, gonna need to disc again soon
11:44:48 --- mode: ChanServ set +o elliott
11:44:56 --- mode: elliott set -b *!~Peaker@bzq-79-180-190-13.red.bezeqint.net$##fixyourconnection
11:45:00 <elliott> guess that's obsolete now :p
11:45:02 --- mode: elliott set -o elliott
11:48:51 <acube> @hoogle Data.Word
11:48:52 <lambdabot> Prelude words :: String -> [String]
11:48:52 <lambdabot> Data.List words :: String -> [String]
11:48:52 <lambdabot> Data.String words :: String -> [String]
11:48:58 <acube> @hoogle module Data.Word
11:48:58 <lambdabot> No results found
11:49:13 <acube> @hoogle module Data.Int
11:49:14 <lambdabot> No results found
12:18:31 <jfischoff> does anyone know of cryptographically secure random number generator package?
12:18:51 <jfischoff> what do people at galois use?
12:22:54 <schellsan> hey guys - i wrote a little code watcher over the weekend https://github.com/schell/steeloverseer
12:23:04 <schellsan> it's technically my first haskell project
12:23:50 <schellsan> just wanted to say thanks for your help as i learn, and contribute a bit (of naive haskell)
12:25:43 <sclv_> jfischoff: this shoudl be decent? http://hackage.haskell.org/package/monadcryptorandom
12:26:50 <jfischoff> how would I access if it is implemented correctly? Have you had any experience with it?
12:27:25 <sclv_> this also: http://hackage.haskell.org/package/RandomDotOrg
12:28:12 <eikke> crap. ghc: panic! (the 'impossible' happened)
12:28:16 <Clint> what on earth is System.FilePath.Find
12:28:57 <sclv_> you can test using a 3rd party tool like this: http://www.phy.duke.edu/~rgb/General/dieharder.php
12:29:32 <sclv_> i haven't used monadcryptorandom, but based on reputation etc it seems decent
12:30:38 <sclv_> this also seems reliable: http://hackage.haskell.org/package/cprng-aes
12:32:06 <acowley> eikke: That's when you know you're on the right track!
12:32:29 <eikke> acowley: had it before, but kinda stuck here, since code seems OK :P
12:32:44 <eikke> acowley: will retry with ghc 7.7something instead of 7.4
12:32:49 <acowley> eikke: I get nervous when I haven't triggered the impossible for more than a month or so :/
12:34:13 <magicman> @remember acowley I get nervous when I haven't triggered the impossible for more than a month or so :/
12:34:14 <lambdabot> Nice!
12:34:33 <jfischoff> thanks sclv_
12:38:29 * hackagebot simple-atom 0.1.0.1 - Atom (or symbol) datatype for fast comparision and sorting.  http://hackage.haskell.org/package/simple-atom-0.1.0.1 (ThomasSchilling)
12:40:37 <fizruk> Hi! Is it okay to ask here for code review?
12:41:02 <Clint> if you hpaste it
12:41:07 <sclv_> yes
12:41:17 <sclv_> hpaste or github or the like
12:41:19 <acowley> hpaste or github
12:41:20 <sclv_> no big pastes inline
12:41:22 <DanBurton> @where hpaste
12:41:22 <lambdabot> http://hpaste.org/
12:41:22 <fizruk> http://pastebin.com/1LhQ8VmS
12:41:38 <fizruk> its ~300 lines
12:41:50 <fizruk> Yet I'm not sure if I am not misusing some concepts.
12:41:52 <mauke> The paste 1LhQ8VmS has been copied to http://hpaste.org/87436
12:42:09 <fizruk> The program is kind of a chat with bots.
12:43:04 <sclv_> ooh hlint's suggestions on hpaste are all already good starts
12:43:05 <sclv_> if minimal
12:43:29 <eikke> interesting. ghc (7.7) warns when some given constructor is not used, although it's used in pattern matches (but not exported and never used as a constructor, though. so the warning is correct, but unexpected)
12:43:29 * hackagebot abstract-deque 0.2 - Abstract, parameterized interface to mutable Deques.  http://hackage.haskell.org/package/abstract-deque-0.2 (RyanNewton)
12:43:41 <DanBurton> I don't like the "Use if" suggestion, though. I am a fan of case someBool of True -> tru; False -> fls;
12:44:56 <monoidal> eikke: that's true. Interestingly, in development of this feature it was applied to GHC itself.
12:45:10 <fizbin> Oooh. http://www.haskell.org/haskellwiki/Hac_%CF%86 is almost in my backyard. I should go.
12:45:37 <monoidal> eikke: (it found some places with unused constructors)
12:46:07 <acowley> Yes, HacPhi is a great scene!
12:46:20 <fizruk> DanBurton: matter of taste, I think, I prefer case in monadic expressions
12:46:23 <Taneb> You know how I wrote a little thing to download something from Hackage and count how many lines there is?
12:47:22 <monoidal> fizruk: "case x of True -> return (); False -> y" == "unless x y"
12:47:30 <fizbin> acowley: Unfortunately, it seems to require a functioning laptop. I don't have such a thing at the moment.
12:47:59 <acowley> fizbin: If you're in the Philadelphia area it would probably still be worth attending just to chat with people
12:48:08 <fizbin> acowley: I mean, I have my work laptop, but I wouldn't feel right bringing that….
12:48:15 <acowley> fizbin: Why not?
12:48:28 <fizbin> Well, I wouldn't be working on work stuff.
12:48:53 <hpaste> test pasted “test” at http://hpaste.org/87437
12:49:10 <hpaste> test revised “test”: “test” at http://hpaste.org/87437
12:49:47 <fizruk> monoidal: thanks)
12:50:01 <tomejaguar> Is it only possible to UNPACK fields when they're monomorphic?
12:51:15 <acowley> tomejaguar: Yes
12:51:37 <elliott> I think you can unpack (SomeStructure a) where a is a type variable
12:51:43 <elliott> it only has to be monomorphic to "one level"
12:52:14 <tomejaguar> Oh I see
12:52:22 <monoidal> fizruk: I am unsure about details, but perhaps chatSend $ "echo: " ++ msg could be chatSend "echo" msg, that's assuming the "echo: " part is sender
12:52:24 <tomejaguar> That makes sense.
12:52:53 <monoidal> fizruk: so you'd have chatSend that takes a sender and a message
12:54:11 <fizruk> monoidal: I think it would be even better to place sender name in ChatBotE structure (Reader environment), thanks)
12:55:31 <hseg> Using parsec, specifically TokenParser, to parse a file. Yet the parser chokes on a comment.
12:55:42 <hseg> Code being posted right now.
12:55:46 <monoidal> fizruk: "do stmNode n; return ()" == "void (stmNode n)" (void is in Control.Monad, I don't remember from which version)
12:56:10 <fizruk> monoidal: thanks!
12:56:15 <hpaste> hseg pasted “Data Types” at http://hpaste.org/87439
12:56:30 <hpaste> hseg pasted “Lexer” at http://hpaste.org/87440
12:56:50 <hpaste> hseg pasted “Parser” at http://hpaste.org/87441
12:57:17 <Botje> hpaste: congratulations on being GHCi-enabled!
12:57:19 <hpaste> hseg pasted “Tester” at http://hpaste.org/87442
12:57:43 <hseg> Thanks. Was just click, download and install, luckily for me.
12:57:59 <Botje> hpaste: might want to consider keeping a gist and/or repo on github, easier to maintain
12:58:10 <monoidal> fizruk: I'm not sure about this, but stmEnv might be writable more concisely using Control.Monad.Trans.Free.iter
12:58:53 <hseg> OK. Moving this to a gist.
12:58:55 <Botje> hpaste: when you say "chokes on a comment", what is the output?
12:59:15 <acowley> garblhckae
12:59:45 <monoidal> fizruk: or Control.Monad.Trans.Free.retract
13:00:15 <monoidal> fizruk: sorry, I take back last line
13:00:51 <hseg> Left (line 1, column 1): unexpected "/" expecting A Jack class
13:01:10 <monoidal> fizruk: in any case stmEnv looks suspiciously like some type of fold / monadic fold for the free monad, and there should be some library function for this. if there isn't, I would write the abstract part as a separate function.
13:01:17 <hseg> BTW, this shows that the strings passed to <?> shouldn't be capitalised, as that doesn't fit with the output
13:02:01 <fizruk> monoidal: thanks, it should take some time for me to get into it
13:04:15 <hseg> Gist: https://gist.github.com/anonymous/5535665
13:04:34 <Botje> thanks, that's more handy than flipping through tabs
13:05:02 <fizruk> monoidal: yes, it's certainly iter for both stmNode and stmEnv
13:05:09 <Botje> hseg: consider making a parser for "jackFile"
13:05:31 <hseg> That parser would be jackFile = classDec
13:05:39 <Botje> that first parses whitespace, then classDec, then eof
13:05:56 <hseg> That caveat I forgot about.
13:06:16 <Botje> so jackFile = whitespace >> classDec <* eof
13:06:36 <Luke> byorgey: you around?
13:06:41 <Botje> the Tokenizing parsers will automatically eat whitespace (which includes comments), but you have to parse the first one yourself
13:07:10 <stelleg> is there a more idiomatic way to compose monads than: (writeFile "hello" =<<) . readFile ?
13:07:52 <Botje> :t readFile >=> writefile "hello"
13:07:53 <Luke> ccasin: you around?
13:08:02 <lambdabot>     Not in scope: `writefile'
13:08:02 <lambdabot>     Perhaps you meant one of these:
13:08:02 <lambdabot>       `writeFile' (imported from Prelude),
13:08:02 <acowley> that's not a composition of monads
13:08:08 <stelleg> Botje: thanks
13:08:31 * hackagebot crypto-api 0.12.2 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.12.2 (ThomasDuBuisson)
13:08:33 <tomejaguar> It's composition in the Kleisli category of the monad
13:08:35 * hackagebot crypto-api-tests 0.2 - A test framework and KATs for cryptographic operations.  http://hackage.haskell.org/package/crypto-api-tests-0.2 (ThomasDuBuisson)
13:08:52 <Eelis> :t readFile >=> writeFile "hello"
13:08:56 <lambdabot> FilePath -> IO ()
13:09:04 <Eelis> :t (>=>)
13:09:07 <acowley> but Botje's suggestion is a nice way of composing functions with monadic return types
13:09:08 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
13:09:47 <hseg> Same errors.
13:09:55 <stelleg> acowley: fair enough, I wasn't sure the best way to word it
13:10:44 <hseg> I would have thought the error was caused by my attempting to parse stuff before parsing the leading comment, but TokenParser should skip over that.
13:11:01 <Botje> hseg: no, tokenparser eats whitespace *after* tokens.
13:11:05 <acowley> stelleg: No problem! It seems a finicky distinction to make, but you might encounter monad transformers as a way of composing two monads, and that's completely different.
13:11:10 <Botje> you still have to eat the first whitespace if it's there
13:11:20 <Peaker> elliott, sorry about that! How many times did I disc?
13:11:23 <fizruk> monoidal: is that right that I actually do not need EPure and NPure contrustors?
13:11:44 <Botje> ewww, git copied the backslashes :(
13:11:46 <hseg> Botje: Right. But IIRC, it should skip comments once it starts consuming stuff
13:11:55 <Botje> once it starts, definitely.
13:12:11 <Botje> but each tokenizing parser expects to start at a non-whitespace.
13:12:21 <shachaf> Also, people will get really irritated if you call values of type "m a" or values of type "a -> m b" or the type "m a" or other things "monads".
13:12:30 <elliott> Peaker: about five pages of #haskell-lens backlog worth :P it's no big deal, just good to stop the irc clients doing it when it happens
13:12:31 <hseg> Botje: Which backslashes? I embedded 3 backslashes in the string literals in Test.hs
13:12:36 <shachaf> And they'll probably make fun of you behind your back.
13:12:37 <Botje> hseg: in the filenames :)
13:12:48 <stelleg> acowley: yeah I haven't played with transformers yet, but I do see at a high level where I went wrong :)
13:13:13 <hseg> I embedded that too, those are the paths relative to the directory which holds this project.
13:13:15 <Peaker> elliott, doh :(  Well, xchat is running as a little systray icon.. it really helped when danharaj mentioned my nick so it called attention to my irc client
13:13:31 * hackagebot jmacro 0.6.5 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.6.5 (GershomBazerman)
13:13:32 <Botje> hseg: yeah, i'd expect git to give me a nice directory structure for my platform (osx)
13:13:32 <hseg> That way, I can show the hierarchy of modules.
13:13:33 * hackagebot commsec 0.2.5 - Provide communications security using symmetric ephemeral keys  http://hackage.haskell.org/package/commsec-0.2.5 (ThomasDuBuisson)
13:13:35 * hackagebot commsec-keyexchange 0.1.2 - Key agreement for commsec.  http://hackage.haskell.org/package/commsec-keyexchange-0.1.2 (ThomasDuBuisson)
13:13:42 <acowley> stelleg: A great thing about Haskell is that you can go on IRC and say, "I think I want something with type…." and people will usually point you in the right direction. No need to translate to math jargon if you can sketch out the type you want.
13:13:52 <hseg> Oh. Yeah, that'd be fun.
13:14:53 <acowley> The best example of that being hoogle itself of course
13:14:57 <hseg> acowley: Conversely, the starting point for a haskell program, assuming you aren't a masochist, is to sketch out the types you want. After that, stuff just flows naturally, modulo head-scratching and guesses.
13:15:00 <stelleg> acowley: yeah it is definitely the best community I've interacted with
13:15:06 <acowley> @hoogle (a -> m b) -> (b -> m c) -> a -> m c
13:15:07 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
13:15:08 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
13:15:08 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
13:15:34 <stelleg> cool
13:15:46 <Peaker> acowley, types *are* math jargon :)
13:15:50 <acowley> hseg: I'd call that a corollary!
13:16:02 <acowley> Peaker: Nobody needs to know!
13:16:29 <stelleg> I think acowleys point is that the community provides a map from approximate types to types :)
13:16:30 <acowley> Hrmph. Here I am saying how great our tools are, and it seems hayoo is down.
13:16:34 <Botje> hseg: oh, duh.
13:16:38 <acowley> stelleg: Yes, exactly.
13:16:44 <Botje> hseg: the next problem is that your test string doesn't contain any newlines :]
13:17:37 <Botje> hseg: so adding \n to every string in Test.hs and replacing classDec by program gives me a parse error on line 12 now
13:18:31 * hackagebot sqlite-simple 0.4.2.0 - Mid-Level SQLite client library  http://hackage.haskell.org/package/sqlite-simple-0.4.2.0 (JanneHellsten)
13:18:37 <Peaker> It would be really nice if someone had a hoogle search on the web that indexed all of hackage, rather than Hayoo which is not nearly as nice
13:19:01 <simpson> Peaker: That'd be a lot of stuff. :c
13:19:17 <simpson> I do agree that Hoogle being "packages that ndm likes" is not ideal.
13:19:22 <Botje> hseg: you got that?
13:19:30 <hseg> simpson: One word. Caching, combined with hackagebot. Still, a huge search space
13:19:42 <hseg> Testing.
13:20:41 <acowley> I pine for a more widely-scoped hoogle.
13:20:56 <kostja> good evening
13:22:28 <hseg> OK. Got to the state you're at.
13:23:29 <Botje> have fun debugging the rest, let me know if you encounter another blocker
13:23:29 <hseg> Current setup: I'm remoting into a remote computer running a VM, to which I need to copy the source files before they can be tested. I'm editing on my host computer. Thus, a ~4s delay between coding and testing.
13:23:43 <Botje> you can't run an editor on the remote computer?
13:24:09 <Botje> and/or you can't access the remote computer's filesystem using yours?
13:24:14 <acowley> tramp-mode!
13:24:56 <kostja> I'm learning about monads. I'm playing with the mother, father :: Person -> Maybe Person example and asking my self, wether it is possible to retrieve the tuple of both grandfathers not by sequencing one query after the other.
13:25:30 <hseg> I might be able to run the editor on the remote computer... Trying this now.
13:25:33 <Botje> kostja: well, you can manually pattern match twice.
13:26:13 <kostja> If I have a tuple of (Maybe gf, Maybe gm) what is a reasonable way to get the Maybe (gf, gm) tuple?
13:26:35 <kostja> Botje: I don't understand what you mean.
13:26:37 <Peaker> kostja, you can use a function that does the sequencing for you. look at liftM2
13:27:07 <fizruk> kostja: tupleToMaybe (Just x, Just y) = Just (x, y)
13:27:18 <fizruk> kostja: tupleToMaybe _ = Nothing
13:27:52 <acowley> grandfathers = (,) <$> (mother>=>father) <*> (father>=>father)
13:27:57 <acowley> something like that?
13:28:38 <kostja> okay, this is to obvious. I'm sorry, for this question. That was for sure not worth your time. Thank you very much!
13:29:03 <elliott> that question wasn't obvious by my standards :)
13:29:36 <shachaf> fizruk: sequenceAOf both!
13:30:02 <acowley> I was waiting for that
13:30:16 <kostja> elliott: maybe not the question. but the anwser of fizruk is not too complicated and I should have think of something like that
13:30:19 <koala_man> kostja: uncurry (liftM2 (,)) $ (Just 4, Just 6)
13:30:34 <shachaf> Don't worry. lens is here to make it complicated.
13:31:26 <acowley> Why isn't that the short description?
13:31:36 <elliott> kostja: what's amazing is that tupleToMaybe can be defined as: tupleToMaybe (m,n) = (,) <$> m <*> n -- which ties in to acowley's answer
13:31:40 <fizruk> shachaf: what was about sequenceAOf?
13:31:56 <Botje> haskell programmers need job security too
13:32:02 <shachaf> @ty sequenceAOf both :: (Maybe a, Maybe b) -> Maybe (a, b)
13:32:03 <kostja> I don't know the operators <$> and <*> yet
13:32:04 <lambdabot>     Couldn't match type `a1' with `b1'
13:32:04 <lambdabot>       `a1' is a rigid type variable bound by
13:32:04 <lambdabot>            an expression type signature:
13:32:32 <shachaf> Well, yes.
13:32:33 <elliott> shachaf: both isn't good enough.
13:32:38 <elliott> we need more magic.
13:32:59 <shachaf> elliott: Right.
13:33:10 <shachaf> HTraversal
13:33:31 * hackagebot atomic-primops 0.1.0.2 - A safe approach to CAS and other atomic ops in Haskell.  http://hackage.haskell.org/package/atomic-primops-0.1.0.2 (RyanNewton)
13:33:47 <acowley> Is that a thig?
13:33:53 <acowley> s/thig/thing
13:34:00 <staafl> how do I turn an (a -> b) to an (a,a) -> (b,b)
13:34:07 <shachaf> @ty over both
13:34:09 <lambdabot> (a -> b) -> (a, a) -> (b, b)
13:34:24 <acowley> @ty over easy
13:34:28 <lambdabot> Not in scope: `easy'
13:34:39 <acowley> Are you kidding me?
13:34:57 <elliott> easy is a traversal for monoids.
13:35:06 <acowley> With all the ridiculous names in lens, nobody's defined something for the sake of having "over easy"?
13:35:11 <fizruk> shachaf: where are these over/both/easy from?
13:35:14 <shachaf> acowley: That would be too easy.
13:35:18 <staafl> shachaf, how can I check what module that's from?
13:35:22 <shachaf> fizruk: lens
13:35:27 <shachaf> staafl: Control.Lens
13:35:32 <shachaf> staafl: Hayoo is good for that sort of thing
13:35:35 <shachaf> @where hayoo
13:35:35 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
13:35:36 <acowley> No joke is too easy for lens.
13:35:40 <acowley> hayoo isn't working :(
13:36:03 * elliott (no monoid is too easy...)
13:36:11 <staafl> many thanks
13:36:46 <shachaf> elliott: Tree is too easy.
13:36:50 <shachaf> Or Magma. Or whatever we called it.
13:37:24 <acowley> I can't believe we don't leverage the name "magma" more than we do
13:37:54 <acowley> we have all these alien names that make people uncomfortable, and never talk about magma
13:37:55 <djahandarie> Mainly because the concept is pretty useless, probably. :P
13:38:05 <RichyB> acowley: too few properties! But yeah. "Parsing with magmas" could be funny.
13:38:12 <acowley> djahandarie: To quote elliott: You're pretty useless
13:38:17 <acowley> djahandarie: :P
13:38:31 <djahandarie> :-(
13:39:07 <elliott> I should be paying acowley for handling my burns for me
13:39:59 <hseg> OK. New problem: I have to parse "foo.bar(a1,a2,...,an)", where the "foo." part is optional and the "ai" are optional. However, the parser as I defined it in lines 163-172 of JackParser won't work if there isn't a "foo." part.
13:40:15 <shachaf> djahandarie: The concept as used in lens is useful!
13:41:11 <Botje> hseg: shouldn't the optionMaybe fix that?
13:41:12 <hseg> Specifically, I'm using optionMaybe to handle trying to parse the "foo." part, which consumes the identifier, and thus makes the entire parser fail.
13:41:24 <djahandarie> shachaf, not familiar with how it's used there.
13:42:02 <hseg> No, because it only fails after having consumed the identifier. Thus, when it reaches the period, it already has consumed input and cannot fail.
13:42:37 <hseg> Note that optionMaybe is described as optionMaybe p tries to apply parser p. If p fails *without consuming input*, it return Nothing, otherwise it returns Just the value returned by p. (emph mine)
13:43:20 <shachaf> djahandarie: data Magma = Zero | One a | Two (Magma a) (Magma a); instance Monoid (Magma a) where mempty = Zero; mappend = Two
13:43:31 * hackagebot lockfree-queue 0.2.0.2 - Michael and Scott lock-free queues.  http://hackage.haskell.org/package/lockfree-queue-0.2.0.2 (RyanNewton)
13:43:52 <Botje> hseg: there's always try.
13:44:12 <Botje> hseg: alternatively, you can left-factor your grammar.
13:44:39 <Botje> parse an identifier, then see if what comes next is a . or a (
13:44:54 <hseg> IIRC, that isn't left-factoring
13:45:05 <hseg> Oh, wait. I'm thinking of sth else
13:46:13 <kostja> actually liftM2 is sequencing the arguments
13:46:37 <hseg> By the way, won't (,) <$> (identifier <* reservedOp ".") <*> identifier also accept stuff like foo . bar?
13:46:44 <Botje> hseg: or you can be _really_ evil and tell Parsec.Token . is an operator
13:46:51 <Botje> yes, it will
13:47:47 <hseg> OK. Is there a way to prevent identifier from discarding the whitespace following the valid identifier?
13:48:32 * hackagebot jmacro 0.6.6 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.6.6 (GershomBazerman)
13:48:46 <Botje> don't use a lexeme parser
13:48:52 <danharaj> ooh jmacro update
13:48:57 <Botje> ie the regular parsec things
13:49:01 <kostja> so if one pattern matches: pair (Just x, Just y) -> Just (x, y) it could be possible, that the compiler runs both queries in parallel?
13:50:49 <acowley> kostja: The compiler will not make things run in parallel
13:51:28 <kostja> I mean, that the order of execution of the queries is undetermined?
13:52:25 <kostja> I'm really new to haskell and like to understand the concepts right
13:52:58 <hseg> :-(. OK, so basically what I want is to copy-paste Parsec's definition of an identifier, minus the wrapping of lexeme, then switch case based on whether the identifier is followed by a period.
13:53:05 <hseg> Hacking this up now...
13:53:32 <mzero> what queries, kostja? are you writing some pattern match like       pair (Just x, Just y) = Just (x, y)    ?
13:53:32 * hackagebot bitset 1.4.2 - A space-efficient set data structure.  http://hackage.haskell.org/package/bitset-1.4.2 (SergeiLebedev)
13:54:03 <sclv_> danharaj: pretty minor stuff
13:54:09 <sclv_> just bugfixes compat
13:54:41 <hpaste> “Ertugrul Söylemez” pasted “Fast bit-array-based nub” at http://hpaste.org/87446
13:54:52 <danharaj> sclv_: roger that
13:55:26 <kostja> mzero: http://hpaste.org/87447
13:55:48 <kostja> mzero: assuming mother, and father are complicated database queries
13:55:50 <simpson> Grar. Am I really so bad for just wanting to see how many things are in my list monad while it's number-crunching?
13:56:03 <sclv_> danharaj: the one improvement is that you can just use plain backticks for antiquotes
13:56:05 <danharaj> simpson: what do you mean?
13:56:08 <sclv_> instead of `(this)`
13:56:21 <sclv_> (of course with plain backticks then you can't use `infix` inside the antiquote)
13:56:30 <elliott> kostja: the compiler is allowed to "automatically" evaluate in parallel. GHC won't.
13:56:33 <simpson> danharaj: I have a list monad (StateT s [] actually) and I would like to be able to oversee its progress as it is crunching.
13:56:34 <elliott> it's incredibly tricky to get right
13:56:36 <mzero> kostja: they *can't* be complicated DB queries - that code is pure functional
13:56:48 <mzero> BUT
13:56:52 <elliott> you can add parallelism to pure code easily, though, take a look at the strategies package
13:56:52 <simpson> danharaj: To do things like understand whether it's generating too many possibilities at certain points, or could have more strictness in spots, etc.
13:56:58 <elliott> mzero: well, you can have an in-memory DB in Haskell.
13:57:41 <danharaj> simpson: that type does not allow you such introspection as such. Have you done all you could with GHC's profiling tools?
13:57:49 <mzero> elliott - one code…. though I don't think Person in that example is a Monad
13:58:02 <hseg> Need to run, lab is closing. Probably will only be free in ~12h
13:58:02 <danharaj> sclv_: I hope the error messages for ` ... `infix` ... ` are at least legibile :P
13:58:18 <simpson> danharaj: Largely. GHC's heap profiles indicate that my types are sufficiently strict, my heap is tiny and manageable, and it's crunching through possibilities as fast as it can.
13:58:42 <simpson> danharaj: I just kind of miss doing this in Python, where I could print out how many iterations or possibilies have gone by, what the best current match is, etc.
13:58:59 <elliott> use Debug.Trace?
13:59:04 <danharaj> I was about to say.
13:59:14 <danharaj> Debug.Trace is the quick and dirty way to get logging.
13:59:21 <hpc> @quote oasis
13:59:21 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
13:59:22 <simpson> I've got traces and traceShows all over.
14:00:00 <simpson> They were useful in pointing out where my algorithm was wrong, but not where things are slow or building up too much.
14:00:05 <Philippa> Control.Monad.Writer is a little less filthy, more powerful and surprisingly easy to rig up, too
14:00:29 <kostja> mzero: Of course Person is not a monad here. But I really wanted only to know the principle.
14:00:37 <kostja> elliott: thank you
14:00:40 <simpson> Also perhaps my algorithm is just not ideal.
14:01:08 <simpson> I'm solving a Cube 36 (TM) puzzle. We can call them rainbow puzzles. You have a bunch of pieces and a board and you put the pieces on the board.
14:01:20 <simpson> And right now I'm just maintaining a state of all of the pieces that haven't been placed.
14:01:44 <simpson> Maybe the Sudoku-style constraint propagation, where I list all of the possible pieces for each spot on the board, would be better.
14:02:07 <hpc> simpson: is brute force too slow?
14:02:15 <hpc> sudoku is really easy to just exhaust the problem space
14:02:56 <simpson> > factorial 36 -- a little big for me
14:03:01 <lambdabot>   Not in scope: `factorial'
14:03:06 <monoidal> fizruk: re: EPure and NPure - I don't know
14:03:08 <hpc> heh
14:03:11 <simpson> > fact 36 -- really, lambdabot?
14:03:16 <lambdabot>   Not in scope: `fact'
14:03:16 <lambdabot>  Perhaps you meant one of these:
14:03:16 <lambdabot>    `fcat' (imported f...
14:03:21 <monoidal> fizruk: it is possible Pure is enough
14:03:27 <simpson> > product [1..36] -- really now
14:03:33 <lambdabot>   mueval: ExitFailure 1
14:03:33 <lambdabot>  mueval: Prelude.undefined
14:03:34 <fizruk> monoidal: just dropped them, everything seems to work just fine
14:04:04 <fizruk> monoidal: also I had to write my own version of iter :: (Functor f, Monad m) => (f (m a) -> m a) -> FreeT f m a -> m a
14:04:27 <simpson> Anyway, suffice it to say that it's a big space.
14:04:28 <fizruk> monoidal: I believe it should be in Control.Monad.Transformer.Free
14:04:29 <monoidal> @hoogle (f (m a) -> m a) -> FreeT f m a -> m a
14:04:30 <lambdabot> Warning: Unknown type FreeT
14:04:30 <lambdabot> No results found
14:05:10 <jfischoff> does haskell-src-exts support lambda case? It didn't appear to ...
14:05:32 <monoidal> fizruk: can you hpaste the code?
14:05:57 <fizruk> monoidal: sec
14:07:00 <hpaste> fizruk pasted “iter for free monad trasfomers” at http://hpaste.org/87448
14:08:56 <fizruk> monoidal: this is the whole program, if you're interested http://pastebin.com/1LhQ8VmS
14:08:56 <mauke> The paste 1LhQ8VmS has been copied to http://hpaste.org/87436
14:13:29 <andy__> hi, are there a channel for cloud haskell ?
14:13:41 <sclv_> andy__: #haskell-distributed
14:13:49 <andy__> thanks
14:13:57 <sclv_> its v. small and low traffic
14:14:06 <sclv_> so you might be better off asking elsewhere
14:14:16 <sclv_> but you can idle and catch the cloud devs when they're around
14:14:16 <andy__> I see
14:14:55 <danharaj> Anyone know how to get a warp server to exit gracefully on windows when it is running in cabal-dev ghci and receives ctrl+C?
14:16:06 <dEPy> how do I input multiline code into ghci?
14:16:23 <geekosaur> :{
14:16:25 <acowley> :{ :}
14:16:41 <fizruk> monoidal: and you were right about chatSend name msg
14:16:44 <dEPy> :]
14:16:46 <acowley> Hard to distinguish interpreter command reference from emoticons
14:16:49 <danharaj> nevermind, figured it out. silly windows shells.
14:16:51 <dEPy> y! :)
14:17:05 <Iceland_jack> Enough smileys, answer dEPy already! :)
14:17:10 <monoidal> fizruk: what free monad package do you use?
14:17:27 <fizruk> monoidal: free-3.4.1
14:17:55 <dEPy> Iceland_jack, I got it :P
14:18:05 <dEPy> was a funny answer though :D
14:18:38 <acowley> No, not :D, :}
14:18:48 <dEPy> :}
14:18:50 <monoidal> fizruk: "iter" is not present there, right? was it removed?
14:19:47 <monoidal> fizruk: I attempted to write iter in a different way and failed. You might contact the maintainer about the function
14:20:01 <fizruk> monoidal: there's only iter for Free Monad, not monad transformer (http://hackage.haskell.org/packages/archive/free/3.4.1/doc/html/Control-Monad-Trans-Free.html)
14:20:53 <fizruk> monoidal: should I e-mail him (the maintainer)?
14:20:54 <acowley> that's an interesting omission
14:21:20 <acowley> fizruk: He's sitting right over there
14:21:52 <monoidal> fizruk: edwardk is usually here
14:22:46 <applicative> hm, i see the person pushing most to distributed-haskell these days is an erlang master.  sensible ...
14:23:30 <fizruk> edwardk: hi! there's probably a function missing in free package: http://hpaste.org/87448
14:25:14 <edwardk> fizruk: is it in recursion-schemes?
14:25:55 <applicative> the equivalent is in Control.Monad.Free iter :: Functor f => (f a -> a) -> Free f a -> a
14:26:10 <edwardk> fizruk: i only added FreeT fairly late, so i'm going to guess not
14:26:49 <edwardk> fizruk: i'm somewhat on the fence as to the right place to have it live
14:27:31 <fizruk> edwardk: there's iter for Free, so I guess there should be iter for FreeT. Still looking for a function in recursion-schemes though
14:28:30 <edwardk> its probably more appropriately an iterT or something because of the extra m, but i'm sold on adding it
14:28:45 <edwardk> can you concoct a patch under iterT and possibly the corresponding coiterT if i bothered to put a CofreeT in? =)
14:28:58 <fizruk> edwardk: that makes sense to me
14:29:43 <c_wraith> huh.  Is GHC 7.0.4 known to have any bugs that cause it to leak black holes when it shouldn't?
14:30:28 <fizruk> edwardk: never done that before, how do I make a patch?
14:31:23 <hpaste> c_wraith pasted “Why is this leaking black holes?” at http://hpaste.org/87450
14:32:54 <c_wraith> I managed to reproduce the problem without exposing any of the real homework code.  Obviously, what's left is silly.
14:33:22 <c_wraith> But a heap profile of running that shows an ever-increasing amount of heap space being held by blackhole objects
14:33:27 <c_wraith> and that doesn't make any sense to me
14:33:48 <edwardk> fizruk: set up a github account, fork the repository to your own, then check out your copy, make the changes, push it back to yours and send a pull request
14:35:45 <hpaste> carter pasted “setup.hs from hell” at http://hpaste.org/87451
14:36:22 <carter> hey all… i'm trying to hack some conditional compilation into  the LLVM setup.hs file, and i'm quite stumped
14:36:48 <carter> because normal conditional compilation tricks aren't possible in a setup.hs file
14:37:02 <carter> so that leaves template haskell
14:37:07 <carter> and i'm quite stumped at htis point
14:41:43 <carter> if someone has any ideas :)
15:04:30 * hackagebot texmath 0.6.1.5 - Conversion of LaTeX math formulas to MathML or OMML.  http://hackage.haskell.org/package/texmath-0.6.1.5 (JohnMacFarlane)
15:04:34 <c_wraith> today's surprise discovery
15:05:26 <c_wraith> in GHC 7.0.4, concatMap f can build up a giant chain of black holes in situations where concat . map f will not.
15:05:50 <simpson> Really. I thought that concatMap was always better?
15:06:22 <c_wraith> The situation is that f returns [] on nearly all inputs
15:06:39 <c_wraith> concat . map f handles that in constant space.  concatMap f does not
15:08:28 <koala_man> why is that?
15:08:45 <c_wraith> I have no clue.  It's just the result of my observations.
15:09:00 <ion> nice
15:09:04 <`Jake`> @src concatMap
15:09:05 <lambdabot> concatMap f = foldr ((++) . f) []
15:09:06 <c_wraith> crash with "out of stack space" using concatMap.  Running in constant space with concat . map
15:09:13 <`Jake`> @src concat
15:09:13 <lambdabot> concat = foldr (++) []
15:09:16 <`Jake`> @src map
15:09:16 <lambdabot> map _ []     = []
15:09:17 <lambdabot> map f (x:xs) = f x : map f xs
15:11:20 <LordBrain> c_wraith, can you test that with -O2 too, or did you already?
15:11:32 <LordBrain> i'm just curious
15:11:56 <c_wraith> that's with -O2
15:12:20 <LordBrain> wouldn't concat . map f be subject to stream fusion?
15:12:28 <Peaker> I'm not sure you can trust @src
15:12:36 <`Jake`> Peaker: Yeah, I know
15:12:37 <Peaker> it might involve RULES firing with concat/map vs. concatMap?
15:12:46 <`Jake`> > head []
15:12:49 <lambdabot>   *Exception: Prelude.head: empty list
15:12:53 <`Jake`> @src head
15:12:54 <lambdabot> head (x:_) = x
15:12:54 <lambdabot> head []    = undefined
15:12:57 <`Jake`> one example
15:13:32 <ion> What happens if you throw seqs into it randomly? Like, \f -> foldr (\a xs -> (++ xs) $! f a) ]
15:13:35 <ion> [] even
15:16:06 <hpaste> fizruk pasted “coiterT for free monad transformers” at http://hpaste.org/87453
15:16:21 <fizruk> edwardk: so, I came up with the following definition of coiterT. I barely understand co-things due to lack of experience, so may you check the implementation? http://hpaste.org/87453
15:16:23 <ion> (c_wraith: ↑)
15:17:12 <edwardk> looks roughly correct
15:17:36 <c_wraith> ion: I'm not ever using foldr directly..  I'm not sure I see how that would apply
15:17:56 <ion> c_wraith: I mean, if you replace concatMap with that
15:18:50 <fizruk> edwardk: ok, I'll try to make some examples to work and then will push changes
15:18:52 <ion> I take it the problem exhibits with \f -> foldr (\a xs -> f a ++ xs) []?
15:19:24 <c_wraith> I don't see what that change could possibly do
15:19:31 * hackagebot unm-hip 0.0.0.0 - A Library for the manipulation of images  http://hackage.haskell.org/package/unm-hip-0.0.0.0 (JosephCollard)
15:19:51 <c_wraith> then again, I don't see how this could possibly happen in the first place
15:20:41 <c_wraith> as it stands, though, I don't want to experiment until I give up hope that this will finish soon.
15:21:00 <c_wraith> This is the first time I've managed to run it and not have it die of lack of stack space
15:25:42 <Peaker> Is the mappend of two Sets O(N+M) or worse?
15:25:44 <Peaker> (Data.Set)
15:26:37 <Peaker> nm, found it is documented, properly
15:26:51 <hpc> was gonna say, Data.Set has a fantastic haddock
15:27:04 <hpc> and Data.Map
15:29:42 <yogert> hey all, I have a question concerning the design of haskell programs. Up to this point I haven't written anything extensive with haskell and I
15:30:51 <Peaker> hpc, that's an awfully polite way to say RTFM :-)  (Which is the senseful answer here..)
15:31:15 <hpc> Read The Fantastic Manual
15:32:16 <yogert> 'm not sure about some things regarding data structures. I'm writing a program that plays checkers, and from what I've read, many people using an imperative language would use a "bit board" http://en.wikipedia.org/wiki/Bitboard. This representation is a bitfield and relies on bitwise operators to query. This seems very low level, and I'm not sure whether it would make sense to take this approach with haskell
15:34:02 <c_wraith> yogert: it *is* low-level, but you could do it with the Word64 data type if you wanted to
15:34:25 <c_wraith> yogert: what you can't do is mutate them in place
15:34:30 <eikke> or an unboxed vector of word64's
15:35:19 <Peaker> If you use a mutable unboxed array of Bools, it is represented as a bitmap, last I checked
15:35:23 * eikke found a use-case for RWS and feels scared
15:35:33 <Peaker> eikke, I use RWS all the time..
15:36:18 <eikke> Peaker: I was writing my own stack containing a ReaderT, WriterT and State, luckily I remembered about RWS
15:38:11 <Peaker> eikke, I have a lot of custom monad stacks, and very often they happen to have r,w,s and become RWS or RWST
15:38:30 <Peaker> I'm now working on a new custom monad stack, and it has R,W so far.. No S yet
15:39:09 <eikke> I'll use it for my Raft implementation (Reader for config, Writer for output commands/actions on state transitions, State for actual FSM state)
15:39:12 <yogert> c_wraith: well do you think there would be a way more appropriate for haskell? In general should i looking for higher level representations of this stuff? I'm not trying to make the Rybka of the Checkers world here, so performance isn't a concern
15:40:08 <eikke> yogert: sometimes the beauty lies in providing a very nice and high-level API for very low-level (but opaque) datastructures & internal operations
15:41:23 <Peaker> eikke, I'm now using it for automatic name generation for names you didn't bother to give to things in the code structure (IDE for a Haskell-like language)
15:42:02 <Peaker> Need a first-pass with a Reader for a record of actions, and Writer for collecting already-used names.. then a second pass only with Reader to give non-colliding names
15:42:19 <yogert> eikke: do you have any example projects I might look at? I've been considering what kind of representation I might use, but haven't landed on any due to a lack of experience and knowledge
15:42:58 <yogert> eikke: not checkers/chess projects, but good examples of a high level api for low level data
15:43:04 <eikke> yogert: 'vector' itself, but that does some (nice yet non-beginner) tricks
15:43:08 <eikke> euh
15:43:16 <eikke> check the stuff in the 'container' library
15:43:28 <eikke> @hackage containers
15:43:29 <lambdabot> http://hackage.haskell.org/package/containers
15:43:46 <yogert> okay, thanks
15:43:57 <Peaker> yogert, is this one of your first Haskell projects?  weird to go to low-level bit fiddling as a first dive
15:44:38 <Peaker> yogert, why not represent the checkers state with a persistent data structure which requires no effort at all to backtrack?
15:45:07 <yogert> peaker: like a zipper?
15:45:13 <Peaker> yogert, by "persistent" I mean one that updates not in-place, both the new data structure and the old one are available at the same time
15:45:36 <Peaker> no no, zipper is not needed here (afaict)
15:46:43 <eikke> zipper is not related to the actual datastructure over which it zips
15:46:49 <yogert> so I would essentially have a set of states, each representing the board after a move was made?
15:48:20 <yogert> eikke: aren't they used with tree like data structures?
15:48:30 <eikke> yogert: among others
15:49:13 <Peaker> yogert, basically, you can do something like:   { whites :: Set Position, blacks :: Set Position } to represent a checker board. Another option:  Map Position Piece     Piece = White | Black
15:49:19 <ski> zippers are used to get cheap local access, traversal, and update
15:50:10 <ski> i'm not sure a local view of a chess board (iow as seen from the vantage point of a given square on the board, perhaps around of chess piece) would be that much helpful here
15:50:19 <Peaker> yogert, then you can recurse and in the recursion, you can create a new board state, with a move made. The new board state co-exists with the old.. so if the recursion returns, you can throw it away and re-use the old value -- thus get backtracking without explicitly back tracking
15:50:30 <ski> (s/around of/around a/)
15:51:20 <Peaker> yogert, do you want to make an AI for checkers?
15:51:26 <Peaker> yogert, or just a UI to play checkers?
15:51:52 <yogert> peaker: an ai. I was thinking that I'd need a few simultaneous representations for the search
15:52:20 <Peaker> yogert, well, immutable/persistent data structures give you that for free
15:52:41 <Peaker> yogert, if you have:   x :: Set Position      then 'x' simultaneously coexists with     Set.insert somePos x
15:52:53 <Peaker> yogert, (which is a new value, rather than an in-place mutation of x)
15:52:53 <tromp> i have a connect-4 solver written in Haskell that uses bitboards and arrays
15:52:57 <ski> for an AI, a persistent (as opposed to ephemeral) representation would be good
15:53:00 <ezyang_> Is there a name for generating something of type 'Functor f => f a' given a function 'Location -> a' (where Location is ala combinatorial species labels?)
15:53:48 <ski> ezyang_ : perhaps `tabulate' ?
15:54:16 <ski> (iirc, that name is used in the MLs for generating an array from bound(s) and a function from indices)
15:54:21 <ezyang_> Huh, tabulate does seem apt
15:54:27 <ezyang_> Yeah, that's right
15:55:02 <ezyang_> Though, is there any sort of underlying structure here ^^
15:55:15 * ski sometimes defines `tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e'
15:55:37 <yogert> peaker: err sorry I don't follow. I understand ( i think ) that with recursion I can have a new representation in scope..
15:55:54 <yogert> tromp: i'd love to see it, is the source available?
15:56:20 <tromp> http://homepages.cwi.nl/~tromp/c4/fhour.html
15:56:40 <tromp> the haskell version is way slower than the C/jave versions though
15:57:26 <yogert> tromp: thanks
16:00:42 <Peaker> yogert, something like:   search board | isWin board = .. | otherwise = -maximum (nextMoves board) ...
16:04:19 <yogert> peaker: yeah I get that
16:04:56 <yogert> peaker: er, well what is the purpose of -maximum?
16:05:25 <Peaker> yogert, do you know minimax?
16:06:11 <yogert> peaker: wouldn't the search strategy be: fnd next possible moves, create a tree to a certain depth and return best move?
16:06:34 <yogert> eh know of it. : )
16:06:40 <ski> ezyang_ : hm. not sure what you're after
16:07:04 <ezyang_> ski: Me neither!
16:07:17 <Peaker> yogert, hmm.. my example doesn't actually show any recursion, so it's a bad one :)
16:07:18 <ski> underlying structure of what ?
16:07:48 <ezyang_> Well, for example, if it was a 'fold', then I could say, "Oh, there's an underlying initial algebra"
16:07:59 <ezyang_> "Oh, it's a tabulate. There's an underlying _____"
16:07:59 <Peaker> yogert, but the point in minimax, is that the value of the move for the black player is the opposite/negation of the value for the white player, since they have opposing goals
16:08:23 <yogert> yeah. I understand the concept though I think. For each level we consider the possible moves and maybe reduce them by some kind of heuristic and then we traverse the move tree to a given depth, finally returning the "best move"
16:08:50 <Peaker> yogert, so each step in the recursion is searching the best move for either the white or the black player.   Best by white/black standards. These standards are opposite each step of the recursion
16:08:50 <yogert> peaker: ah okay, so the ai can consider the other player
16:09:14 <Peaker> yogert, so either you toggle your max/min function that you pass inside your recursion, or you just negate the value each step of the recursion
16:09:15 <yogert> and we assume the best move will be taken at each turn
16:10:10 <yogert> peaker: okay, well I have to go, but I'll give that a shot later tonight
16:10:15 <yogert> thanks for your help
16:10:15 <Peaker> yogert, Yes, that's a safe assumption to make, because at worst, the player you're up against will play worse than you predicted, and you'll just win harder
16:10:33 <Peaker> so it's ok to assume that the best move will be made.. sure thing
16:11:08 <ski> ezyang_ : istr hearing the term "naperian functor" for `f's where `f a' is iso to `i -> a', for all `a', for some `i'
16:11:33 <elliott> corepresentable functor is what they're usually called, right?
16:11:36 <elliott> or is it not co...
16:13:16 <ski> <http://stackoverflow.com/questions/12963733/writing-cojoin-or-cobind-for-n-dimensional-grid-type>
16:13:29 <ski> apparently "representable"
16:14:46 <johnw> an unanticipated benefit of using only STM for concurrency: you only need grep for the word "atomically" to review the asynchronous behavior of your application
16:15:14 <fryguybob> johnw: hehe
16:15:19 <ion> That’s unanticipated? :-P
16:15:32 <johnw> yeah, I didn't realize I was getting that benefit when i started out
16:15:40 <elliott> there's an edwardk package for it too
16:15:46 <johnw> before I had a mix of MVar's and TVar's, because I was migrating over old code
16:15:59 <johnw> recently I switched to 100% STM, and now it's much easier to review the behavior of the app
16:16:11 <ski> "What is a Naperian container?" by Peter Hancock at <http://sneezy.cs.nott.ac.uk/containers/blog/?p=14>
16:16:27 <lispy> johnw: neat
16:16:56 <lispy> johnw: sounds like an insight for the bloggosphere
16:17:10 <johnw> i mean, race conditions can *only* occur because code that comes out of an atomically block becomes stale, so I just have to read the code with that in mind
16:17:34 <johnw> and contention issues can only occur inside atomically blocks
16:18:02 <johnw> in the same way that IO sort of "divides" pure code from effectful code, STM divides code between synchronous and asynchronous
16:18:24 * lispy nods
16:18:42 <dlnx> hello all
16:18:45 <lispy> (I don't know from experience, but it sounds reasonable)
16:18:53 <lispy> dlnx: hello!
16:19:01 <johnw> lispy: and the way that STM prevents IO from being used is just brilliant
16:19:10 <johnw> there are so many ways that I can't shoot myself in the foot anymore
16:19:32 <johnw> in order to do IO, I have to be outside of STM, which means I have to think about the fact that any values I got from the last STM block may have already changed
16:19:38 <johnw> dlnx: hi
16:20:22 <dlnx> discovered haskell recently
16:20:27 <johnw> dlnx: welcome!
16:20:27 <dlnx> I mean
16:20:38 <dlnx> I've heard about it
16:20:59 <dlnx> but tried to code something in it
16:21:05 <dlnx> just last week
16:21:25 <lispy> It's a very fine language for calculating fibonacci numbers :)
16:21:28 <johnw> dlnx: how was it?
16:21:44 <lispy> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
16:21:46 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
16:21:54 <dlnx> I have experience with functional programming
16:21:55 <johnw> haha
16:22:09 <dlnx> because I did some coding in lisp/scheme
16:22:16 <sproingie> guess we need hq9+f now
16:22:25 <hpc> what's f?
16:22:30 <sproingie> fibonacci
16:23:12 <sproingie> just have each use of f produce the next fibonacci number
16:23:22 <sproingie> so fffff gives you the first five
16:23:26 <dlnx> but haskell's not that similar to lisp as I was told
16:23:26 <hpc> > fix$(1:).(1:).zipWith(+)<*>tail
16:23:29 <lambdabot>   Couldn't match expected type `a1 -> a0' with actual type `[a2]'
16:24:36 * hackagebot yesod-auth-account 1.2.0 - An account authentication plugin for Yesod  http://hackage.haskell.org/package/yesod-auth-account-1.2.0 (JohnLenz)
16:25:44 <Ghoul_> whats the difference between do { contents <- getContents; putStr $ map toUpper contents }
16:25:44 <Ghoul_> and getContents >>= mapM toUpper >>= putStrLn?
16:25:44 <Ghoul_> (I can't make the second compile because toUpper doesn't like being passed a IO Char..)
16:25:46 <dlnx> got question
16:26:08 <dlnx> are there any books like "Write yourself a scheme in 48h"?
16:28:43 <lispy> :t (>>=)
16:28:47 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:28:54 <lispy> :t mapM toUpper
16:28:57 <lambdabot>     Couldn't match expected type `m0 b0' with actual type `Char'
16:28:57 <lambdabot>     Expected type: Char -> m0 b0
16:28:57 <lambdabot>       Actual type: Char -> Char
16:29:15 <lispy> :t map toUpper
16:29:18 <lambdabot> [Char] -> [Char]
16:29:46 <Peaker> Ghoul_, the desugaring of "do" only makes a >>= for each "<-" line in the "do"
16:30:04 <Peaker> Ghoul_, you added a wrong >>= after the toUpper
16:30:14 <Peaker> @undo do { contents <- getContents; putStr $ map toUpper contents }
16:30:15 <lambdabot> getContents >>= \ contents -> putStr $ map toUpper contents
16:30:26 <Peaker> @. pl undo do { contents <- getContents; putStr $ map toUpper contents }
16:30:26 <lambdabot> putStr . map toUpper =<< getContents
16:30:37 <Ghoul_> Oh, I get it.
16:32:01 <Ghoul_> thanks
16:32:56 <JustPassingThrou>  /wave, quick question that i'm having difficulty searching for: what's the "<+>" operator called?
16:33:19 <JustPassingThrou> mix of operators/whatever it might be
16:33:39 <sproingie> in what library?
16:33:39 <lispy> JustPassingThrou: Hmm...I don't really have a name for it.
16:33:50 <lispy> JustPassingThrou: I think of it as "plus"
16:34:23 <cmccann> say "plus", while making little angle-bracket shapes with your hands
16:34:25 <cmccann> like air quotes
16:34:36 <JustPassingThrou> i would but i can't put that in google, you see
16:34:44 <JustPassingThrou> i could try
16:35:05 <JustPassingThrou> if it's meaning is just plus then I guess I don't have to search any more
16:35:13 <simpson> :t (<+>)
16:35:18 <lambdabot>     Ambiguous occurrence `<+>'
16:35:18 <lambdabot>     It could refer to either `Control.Arrow.<+>',
16:35:18 <lambdabot>                              imported from `Control.Arrow' at State/L.hs:5:1-20
16:35:27 <simpson> :t (Control.Arrow.<+>)
16:35:27 <lispy> there are many <+> in the wild
16:35:31 <lambdabot> ArrowPlus a => a b c -> a b c -> a b c
16:35:37 <johnw> lispy: I think I will blog about that
16:35:56 <doomlord> "angleplus" ?
16:35:58 <lispy> johnw: awesome
16:36:25 <JustPassingThrou> ah, I forgot about the :t trick.
16:56:33 <chrisdotcode> hi all :)
16:57:06 <Eduard_Munteanu> chrisdotcode: hi
16:57:34 <chrisdotcode> so guys, did you hear the news?
16:57:41 <chrisdotcode> john carmack is gonna port wolf 3d to haskell!
16:57:42 <chrisdotcode> https://twitter.com/ID_AA_Carmack/status/331918309916295168
17:00:47 <Eduard_Munteanu> Hm, looks legit, nice find.
17:01:45 <ion> cool
17:02:29 <Ghoul_> Data.Serialize lines 207-209 has some pretty weird whitespace consistency compared to the rest of the file
17:08:49 <applicative> can this idea of mr. carmack's be rational?
17:09:46 <Eduard_Munteanu> applicative: pfft, let the dude have some fun :)
17:10:11 <applicative> I'm just worried what will happen if he's disappointed, but who knows.
17:10:18 <Eduard_Munteanu> Hm, fair.
17:10:45 <elliott> "That's neat. You may find yourself writing C-like code for the inner loops. GHC seems to lack low-level opt. - no PhDs in it!" heh
17:11:03 <hpc> ppppsh
17:11:14 <hpc> that's what -fllvm is for
17:11:56 <chrisdotcode> applicative: I feel his biggest problems will be debugging and laziness.
17:12:04 <applicative> who said such a thing elliott
17:12:11 <chrisdotcode> applicative: a commenter
17:12:16 <chrisdotcode> tweetmenter?
17:12:17 <applicative> hm
17:13:17 <Peaker> chrisdotcode = chrisdoner?
17:13:44 <chrisdotcode> Peaker: never heard of him... (but if he's a cool guy, I don't mind being him...)
17:13:55 <hpc> > compare "chrisdotcode" "chrisdone"
17:13:57 <lambdabot>   GT
17:14:06 <Eduard_Munteanu> Heh.
17:14:07 <hpc> WELCOME TO THE CHANNEL, GREAT ONE
17:14:19 <applicative> hm, the 'no PhD's in it' guy seems at least to know some Haskell
17:14:27 <chrisdotcode> :-D
17:14:28 <Peaker> Porting a (most likely) heavily imperative program that probably uses a lot of low-level magic (wolf3d) to Haskell? as a Haskell beginner? Probably not gonna have a good time
17:14:43 * hackagebot pipes-zlib 0.2.0.0 - Pipes to deal with zlib compressed data.  http://hackage.haskell.org/package/pipes-zlib-0.2.0.0 (RenzoCarbonara)
17:14:45 <chrisdotcode> but he's carmack...
17:14:57 <Peaker> Rewriting it is probably better than porting it
17:14:59 <Eduard_Munteanu> Peaker: yeah, I don't know what to say. Maybe he's been writing quite some code secretly? :/
17:15:03 <hpc> i don't expect carmack to actually be doing a direct translation
17:15:10 <applicative> Peaker will help him
17:15:24 <Peaker> applicative, I've got my hands full with lamdu
17:15:38 <Eduard_Munteanu> Peaker: is that your structural editor?
17:15:44 <chrisdotcode> the maintainer of the haskell opengl bindings offered his help, too
17:15:55 <Eduard_Munteanu> That's lispy.
17:16:00 <applicative> Eduard_Munteanu: yeah, it's kinda like wolf-3d , I think.
17:16:03 <Peaker> Eduard_Munteanu, yeah
17:16:38 <applicative> the original source is a rats nest of C-something I see
17:17:15 <Eduard_Munteanu> applicative: what's like "wolf3d"? (/me doesn't get it)
17:17:39 <runde> Wolfenstein 3D
17:17:56 <Eduard_Munteanu> I thought that referred to the same thing.
17:18:02 <applicative> it's the game carmack was proposing to 'port' to Haskell https://github.com/id-Software/wolf3d/
17:18:33 <Philippa_> and if you already know the old code-base, "port" for anything up to and including a complete rewrite is not actually an unreasonable usage or approach
17:18:58 <Philippa_> and you *know* you're in trouble if you can't make it perform tolerably on a modern system
17:19:14 <Philippa_> (it shouldn't be too hard to get working on, say, the lowest-end embedded ARM chips either)
17:19:52 <Nafai> considering the original ran on 386-era machines
17:19:57 <cmccann> yeah
17:20:00 <Peaker> Philippa_, depending how naive the Haskell port is.. [[Pixel]] :)
17:20:02 * applicative sense ruin for Haskell when it turn's into a rats nest on him
17:20:05 <applicative> sense
17:20:06 <Eduard_Munteanu> Philippa_: like many games, I suspect it's graphics-bound rather than CPU-bound. So there's some leeway.
17:20:07 <Philippa_> Nafai: 286, even
17:20:07 <applicative> senses
17:20:15 <cmccann> making it play nicely (controls and timing and all) would be trickier than making it fast enough
17:20:17 <elliott> I think wolf3d doesn't need any optimisation on 2013 hardware
17:20:21 <Philippa_> Eduard_Munteanu: ...you didn't code on hardware that old, did you?
17:20:25 <Eduard_Munteanu> Ok, maybe not anymore, given it's old.
17:20:37 <Nafai> Philippa_: Yeah, wasn't sure, just remembering what machine I had back when I played it
17:20:42 <Peaker> Eduard_Munteanu, wolf3d didn't have GPUs to use
17:20:50 <cmccann> wolf3d is barely even 3d, it's more some clever hacks to fake 3d-ish stuff.
17:20:50 <Philippa_> *nod*. It was certainly better on a 386 w/a sound blaster
17:20:51 <Eduard_Munteanu> Philippa_: well, true, I know many d3d9 games hogged the cpu
17:20:54 <Eduard_Munteanu> Err.
17:21:07 <Eduard_Munteanu> Oh, is that the DOS game?
17:21:09 <applicative> "To render the walls in pseudo-3D, the game uses ray casting. "
17:21:12 <Philippa_> Eduard_Munteanu: In wolf3d's day, we bitbanged the VGA card
17:21:19 <chrisdotcode> hhahaha
17:21:36 <Nafai> mode 13h ftw
17:21:37 <Eduard_Munteanu> I think I'm confusing the 3D games many years later, "Return to castle Wolfenstein" perhaps?|
17:21:44 <Philippa_> Nafai: Mode X!
17:21:50 <Eduard_Munteanu> *game
17:22:09 <Peaker> 320x200x8bit color from a programmable color palette!
17:22:19 <Peaker> > 320*200
17:22:22 <lambdabot>   64000
17:22:28 <cmccann> Eduard_Munteanu: http://upload.wikimedia.org/wikipedia/en/6/69/Wolf3d_pc.png
17:22:29 <Eduard_Munteanu> Ah, yes, that's the one, I think.
17:22:34 <Peaker> a nice 64KPixel image :)
17:23:01 <Eduard_Munteanu> Oh, yes... I do remember playing it when I was little.
17:23:28 <Eduard_Munteanu> I got that mixed up with a newer, actual 3D game from the series.
17:23:56 <Nafai> Philippa_: I wrote my own graphics library for mode 13h with inline asm in C++
17:23:58 <gwern> old news, perhaps but I just saw a link to this: http://flyingfrogblog.blogspot.com/2010/08/rise-and-fall-of-ocaml.html ah, what  is that feeling... ah yes. schadenfreud
17:24:08 <Philippa_> Nafai: *nod*. You're far from the only one :-)
17:24:27 <Nafai> :)
17:24:57 <tikhonjelvis> eh, OCaml is having quite a revival now
17:25:01 <Philippa_> Hell, I remember talking to one of the lecturers about it in my first year at uni. He was teaching the intro to programming course, told me to grab a book and skip the lectures
17:25:31 <dolio> gwern: Dude, don't give him teh hits.
17:25:33 <applicative> the iphone version is a bit better than DOS http://www.appscout.com/images/wolfensteiniphone.jpg
17:25:43 <Eduard_Munteanu> Philippa_: hah, cool
17:26:46 <dolio> Also, it's spelled scootin fruity.
17:27:02 <ski> "The Next Mainstream Programming Language: A Game Developer's Perspective" by Tim Sweeney in 2006 at <http://www.st.cs.uni-sb.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf> has a section titled "Why Haskell is Not My Favorite Programming Language" (following the "The Genius of Haskell" section)
17:27:18 <Peaker> applicative, a dude I know (author of colinux) did a DOSbox emulation for Android running DOS games on Android, and more recently he wrote a compiler from Windows executables to ARM executables and runs Windows games (e.g: Starcraft) on Android!
17:27:21 <ski> hm, Sylvan apparently wrote
17:27:21 <ski> @wiki Why Haskell matters
17:27:22 <lambdabot> http://www.haskell.org/haskellwiki/Why_Haskell_matters
17:27:55 <applicative> gwern, he was just cancelling his stupid journal no; no one was willing to subscribe at £375 an issue or whatever
17:28:08 <Philippa_> Peaker: awesome. How publically available is it? Might have an interest in running 90s stuff on Android
17:28:12 <gwern> applicative: but they were before, so the cancelation pleases me
17:28:24 <Peaker> Philippa_, http://blog.winulator.com/
17:28:39 <Eduard_Munteanu> Why, can't you just run DOSBox on Android?
17:28:44 <applicative> gwern: anyway, we love ocaml on #haskell; php is another matter
17:28:45 <Eduard_Munteanu> It doesn't use vm86 AFAIK.
17:28:45 * ski . o O ( Might & Magic )
17:28:51 <Peaker> Philippa_, doesn't seem optimistic for the future, but may already run stuff...  that's the Windows thing.. not sure where the DOS thing is
17:29:00 <Philippa_> Eduard_Munteanu: half the 90s was win32
17:29:01 <gwern> applicative: ocaml and us are competing for similar people
17:29:18 <Philippa_> For DOS, half of that stuff doesn't run fast enough on ARM under DOSbox versions I've tried
17:29:28 <Eduard_Munteanu> Ah.
17:29:39 <tikhonjelvis> I'm surprised more Haskellers don't also know OCaml and vice versa
17:29:45 <Philippa_> (certainly stuff targetting the 486 onwards w/sound card etc doesn't)
17:30:02 <Eduard_Munteanu> Yeah, I guess even old x86 stuff is terribly complex to emulate.
17:30:09 <Peaker> tikhonjelvis, I tried learning some OCaml after Haskell, and got very put down by the syntax and lack of type-classes... :(
17:30:25 <Philippa_> newer is actually easier: you can use stub drivers for hardware access
17:30:30 <tikhonjelvis> on the other hand, it has a module system that doesn't suck and a very neat take on sub-typing
17:30:42 <Peaker> Eduard_Munteanu, the approach in Dan's stuff (winmulator and his dosbox thing afaik) is not to emulate, but do an asm->asm compilation/translation before-hand
17:30:45 <Philippa_> SIMD instructions are more efficient, too
17:30:48 <Eduard_Munteanu> I wonder if Haskell smells just as bad if you had to learn it after Agda. :)
17:30:55 <applicative> tikhonjelvis: yes, http://blog.ezyang.com/2010/10/ocaml-for-haskellers/ was a help
17:30:59 <Peaker> tikhonjelvis, Yeah, I know
17:31:01 <tikhonjelvis> also, from what I've heard, they're working on some features to at least partially replace typeclasses
17:31:21 <tikhonjelvis> oh yeah, and I really envy Camlp4
17:31:37 <DiegoNolan> What is the best way to find out actually package names on cabal?
17:32:16 <applicative> oh hadn't seen these helpful looking slides http://www.slideshare.net/michielovereem/beyond-functional-programming-in-haskell-an-introduction-to-ocaml
17:32:20 <tikhonjelvis> DiegoNolan: Not quite sure what you mean, but probably cabal list
17:32:34 <Eduard_Munteanu> Peaker: I sort of wonder if qemu's JITing could be used for this
17:32:49 <DiegoNolan> Like I want to get Data.Either.Unwrap on hackage
17:32:52 <applicative> i'm not sure what advantage ocaml could have over Idris, if it works out.
17:32:58 <DiegoNolan> but I don't know its actual name on cabal
17:33:05 <tikhonjelvis> hmm
17:33:09 <zRecursive> Eduard_Munteanu: qemu is VERY slow compared with KVM and VBox
17:33:20 <gelisam> google Data.Either.Unwrap
17:33:25 <tikhonjelvis> DiegoNolan: try hayoo
17:33:27 <gelisam> first line of http://hackage.haskell.org/packages/archive/either-unwrap/1.1/doc/html/Data-Either-Unwrap.html
17:33:30 <tikhonjelvis> @where hayoo
17:33:30 <applicative> http://hackage.haskell.org/package/either-unwrap-1.1
17:33:31 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
17:33:31 <sproingie> KVM is the fastest since it's paravirt
17:33:32 <Peaker> tikhonjelvis, what's the diff. between Camlp4 and TH?
17:34:02 <applicative> DiegoNolan: google is surprisingly good if you just type module names in like Data.Either.Unwrap
17:34:13 <Eduard_Munteanu> Yes, qemu seems way too slow, even for a fully userspace JIT.
17:34:14 <tikhonjelvis> the extensions to the grammar fit into the language better
17:34:17 <zRecursive> sproingie: but KVM just works in Linux
17:34:39 <Eduard_Munteanu> But hopefully you can do user emulation only?
17:34:43 <zRecursive> VBox is great on many platform
17:34:44 <applicative> DiegoNolan: either-unwrap is the 'package name', and thus the name it has on hackage.
17:34:50 <tikhonjelvis> e.g. you can just introduce your own syntax without the syntactic overhead TH enforces
17:34:58 <DiegoNolan> thanks, got it
17:35:06 <sproingie> zRecursive: well yeah that's one of the downsides of paravirtualization
17:35:25 <sproingie> also everyone sharing a kernel
17:35:32 <Eduard_Munteanu> sproingie: well, anyone can use the KVM paravirt stuff from other host vms, I suppose.
17:35:38 <zRecursive> sproingie: VBox has good performance too
17:35:55 <sproingie> vbox is pretty good, i use vagrant a lot with the vbox provider
17:36:11 <sproingie> vmware's faster but the free version has no snapshot ability :p
17:36:28 <Eduard_Munteanu> sproingie: faster at what?
17:36:30 <applicative> DiegoNolan: what led you to either-unwrap ? just wondering
17:36:45 <Eduard_Munteanu> IIRC, kvm had some issues with disk virtualization performance.
17:36:58 <DiegoNolan> I have an either and I don't want to write my own functions to unwrap it
17:37:03 <sproingie> in general.  i've got identical centos VMs doing identical work and the vmware one seems to edge out the vbox one
17:37:28 <sproingie> (same host machine)
17:37:49 <zRecursive> I am using VBox to run Windows on FreeBSD, it is great !
17:37:59 <Peaker> sproingie, did you try colinux?
17:38:02 <sproingie> it's not dramatic, vbox has gotten a lot better, but vmware didn't sit still either
17:38:03 <Eduard_Munteanu> Err.
17:38:10 <Eduard_Munteanu> Peaker: isn't... that... ancient?
17:38:33 <sproingie> colinux was awesome back in the day but it seems pretty dead
17:38:39 <no-n> I haven't tried vbox for a while
17:39:02 <Peaker> sproingie, I know Dan abandoned it, but I thought a community had already formed to maintain it
17:39:04 <Eduard_Munteanu> That stuff must be dead for at least 10 years, unless I misremember :)
17:39:25 <sproingie> Peaker: wasn't aware of that, it's not reflected on colinux.org for sure
17:39:27 <applicative> DiegoNolan: there's a more modern package with some of the same sort of utilities, http://hackage.haskell.org/package/errors explained here http://www.haskellforall.com/2012/07/errors-10-simplified-error-handling.html
17:39:34 <Eduard_Munteanu> Ok, 10 might be a bit too much.
17:39:34 <Peaker> Eduard_Munteanu, colinux? it didn't exist 10 years ago
17:39:43 <zRecursive> Unfortulately OpenBSD doesnot support virtulization technology ...
17:39:48 <sproingie> almost.  looks like it's nearly 9 years old
17:40:01 <DiegoNolan> applicative: Thanks I'll take a look
17:40:27 <Eduard_Munteanu> 0.7.9 [1] / April 9, 2011; 2 years   -- says wikipedia
17:40:49 <chrisdotcode> so guys, can you all help me with the state monad? how is using it any different from having a bunch of globals?
17:40:49 <sproingie> it's been around a lot longer than that, i wasn't even running it 2 years ago
17:41:27 <sproingie> anyway colinux is a bit too intrusive on the guest for my needs, i need vanilla centos images as build boxes for the lab
17:41:34 <tikhonjelvis> chrisdotcode: For one, because they're *not* global—they're local to your particular computation.
17:41:39 <Eduard_Munteanu> chrisdotcode: it's thread-safe
17:42:01 <tikhonjelvis> and the mutability can't escape from within the monad, so the interface you present to the outside world is still completely pure
17:42:12 <chrisdotcode> it seems just like each thread would have to carry around it's own copy of the state monad.
17:42:19 <tikhonjelvis> which also means different parts of your program are still decoupled
17:42:26 <Peaker> chrisdotcode, it's slightly like a "thread-local" global if used naively. But in combination with other monad transformers, it can do interesting things
17:42:31 <applicative> DiegoNolan: so for example isRight and so on are here http://hackage.haskell.org/packages/archive/errors/1.4.1/doc/html/Control-Error-Util.html
17:42:31 * sproingie heads out
17:42:33 * sproingie &
17:42:41 <Peaker> bg & disown
17:43:55 <applicative> chrisdotcode: you can use the state monad to implement simple pure algorithms; the State business needn't even appear in the type signature, just Int -> Int
17:44:18 <chrisdotcode> applicative: how would that work? would you have to `type Int State`?
17:44:29 <Eduard_Munteanu> No.
17:44:35 <Eduard_Munteanu> :t runState
17:44:37 <lambdabot> State s a -> s -> (a, s)
17:44:50 <tikhonjelvis> :t evalState
17:44:52 <lambdabot> State s a -> s -> a
17:45:06 <zRecursive> @unmtl State s a
17:45:07 <lambdabot> s -> (a, s)
17:45:48 <Peaker> @type execState $ modify (+1) >> get
17:45:51 <lambdabot> Num s => s -> s
17:45:55 <cmccann> > runState (replicateM 4 (state $ splitAt 2)) [1..14]
17:45:57 <lambdabot>   ([[1,2],[3,4],[5,6],[7,8]],[9,10,11,12,13,14])
17:47:50 <Mortchek> In general, if you compose f :: a → b with g :: b → a, you lose the types of the stuff in the middle, i.e., f . g :: b → b, with no a in sight.
17:48:08 <jamil_1> hello
17:48:11 <jamil_1> cabal: dependencies conflict: ghc-7.4.1 requires containers ==0.5.2.1 however
17:48:11 <jamil_1> containers-0.5.2.1 was excluded because ghc-7.4.1 requires containers
17:48:11 <jamil_1> ==0.4.2.1
17:49:12 <jamil_1> I get this for cabal install buildwrapper
17:49:39 <Mortchek> Or more general than that would be f :: b → c and g :: a → b and f .g :: a → c, rather
17:51:18 <chrisdotcode> i mean, i perfectly understand the state monad, but...
17:51:25 <chrisdotcode> it either seems genius or "cheating"...
17:52:19 <Mortchek> State is just an abstraction on functions that makes it less messy to deal with "stateful" functions, i.e., functions of the form s -> (a, s)
17:52:23 <Mortchek> There is no cheating about it
17:52:40 <Mortchek> Unless you consider type aliases to be cheating
17:53:18 <ion> or genius
17:53:39 <Eduard_Munteanu> chrisdotcode: you could chain s -> (a, s) -like functions yourself, it's just tedious
17:54:10 <Eduard_Munteanu> It's certainly not special, not anything like ST or IO.
17:55:51 <applicative> jamil_1: that's a lot of dependencies of buildwrapper
17:56:16 <applicative> jamil_1: but there is something odd about the error message.  does "ghc-pkg check" suggest anything is broken?
17:57:49 <jamil_1> applicative: ghc-pkg generates a lot of warning and in the end gives me a list saying ""The following packages are broken, either because they have a problem
17:57:50 <jamil_1> listed above, or because they depend on a broken package
17:58:12 <applicative> hm, did you reinstall ghc lately?
17:58:32 <jamil_1> nope
17:59:04 <applicative> can you paste the result from ghc-pkg list and ghc-pkg check somewhere; people should be able to figureit out
17:59:58 <applicative> the important question is whether libaries installed with the ghc and or haskell platform are broken. if not, it is just a matter of unregistering some of the locally installed things
18:00:16 <applicative> I mean, probably
18:00:58 <jamil_1> here http://paste.ubuntu.com/5643315/
18:00:58 <jamil_1> for ghc-pkg list
18:02:34 <jamil_1> applicative: http://paste.ubuntu.com/5643325/ for ghc-pkg check
18:02:38 <applicative> darn, yeah you've had ghc-7.4 for a while, so there's a lot of multiply installed packages.
18:05:43 <applicative> jamil_1: so for starters you need to do something like this http://paste.ubuntu.com/5643331/
18:06:42 <applicative> at that point though, I wonder if you shouldn't unregister all the stuff locally installed
18:06:48 <applicative> or equivalently delete /home/jamil/.ghc/x86_64-linux-7.4.1/package.conf.d
18:07:59 <Tekmo> It's good practice, but tedious, to use `ghc-pkg unregister`
18:10:28 <applicative> jamil_1: i'm worried though that some of the broken stuff is what you want - it seems generally more rencent than the rest, which speaks for unregistering everything listed after line 58 in http://paste.ubuntu.com/5643315/
18:10:38 <ski> chrisdotcode : replace Eduard_Munteanu's "tedious" by "tedious and errorprone" ..
18:10:45 <ski> applicative,tikhonjelvis : <http://www.mpi-sws.org/~rossberg/sml-vs-ocaml.html>,<http://adam.chlipala.net/mlcomp/> might also be interesting, comparing SML and OCaml
18:10:56 <ski> Peaker : see <http://mjambon.com/extend-ocaml-syntax.html#lettry> for an example of extending the syntax with Camlp5 (see "Exceptional Syntax" by Nick Benton,Andrew Kennedy in 2001-07 at <http://research.microsoft.com/en-us/um/people/akenn/sml/ExceptionalSyntax.pdf> for why this construct is useful)
18:11:03 <Eduard_Munteanu> Yeah, tedious and instructive, I guess.
18:11:09 <ski> (and also threads "Exceptions considered harmful" <http://caml.inria.fr/pub/ml-archives/caml-list/2004/07/e14417c385cbb06161846b027bf2d48e.en.html>,"Checking for eof" <http://caml.inria.fr/pub/ml-archives/caml-list/2004/12/c176307e0c46ae73fccab7992930d6ff.en.html>,<http://caml.inria.fr/pub/ml-archives/caml-list/2004/12/b5b79fcd4ea695b8e1e0aff740b07cf3.en.html> in 2004 might be interesting)
18:11:12 <applicative> then doing cabal update and then doing cabal install x y z w   where those are the things you know you want, including perhaps some with a zillion dependencies
18:11:20 <tikhonjelvis> I don't think anybody uses SML any more
18:11:51 * applicative lives in SML country
18:11:53 <ski> conceptually (in Haskell phrasing), it replaces a primitive construct `catch :: Exception e => IO a -> (e -> IO a) -> IO a' by `catchBind :: Exception e => IO a -> (e -> IO b) -> (a -> IO b) -> IO b'
18:12:00 <tikhonjelvis> SML country?
18:12:06 <tikhonjelvis> Pittsburgh?
18:12:12 <Eduard_Munteanu> tikhonjelvis: people are still using COBOL.....
18:12:20 <copumpkin> omg it's tikhonjelvis
18:12:21 <chrisdotcode> are we still talking about state? >_>
18:12:40 <ski> it is easier to algebraically manipulate (and state laws for) `catchBind' as opposed to `catch'
18:12:49 <zRecursive> iirc the "+, -, *, /" are even NOT polymorphic in OCaml :)
18:12:57 <tikhonjelvis> no, they aren't
18:12:59 <tikhonjelvis> and it's stupid
18:13:02 <applicative> http://www.cs.cmu.edu/~15150/tools.html
18:13:08 <tikhonjelvis> 1.0 +. 2.0
18:13:18 <zRecursive> Ugly !
18:13:20 <ski> zRecursive : no bounded polymorphism in the MLs
18:13:32 <applicative> bah, it's ok
18:13:34 <tikhonjelvis> I think you can do something akin to `let open Float in 1 + 2`, but I'm not sure
18:13:47 <tikhonjelvis> I also really don't remember the syntax for it
18:14:03 * applicative doesn't like opening things
18:14:06 * ski doesn't really understand why some people say OCaml's syntax is ugly ..
18:14:16 <tikhonjelvis> let everywhere
18:14:26 <zRecursive> I mean ugly +. -. *. /.
18:14:27 <ski> applicative : iirc, `Float.(1 + 2)' should be equivalent in OCaml
18:14:29 <tikhonjelvis> which forces me to write my program backwards
18:14:39 <applicative> oh.
18:14:44 <tikhonjelvis> ski: Oh yeah, maybe that's the syntax
18:14:47 <Nisstyre-laptop> tikhonjelvis: or is it really forwards
18:14:48 <DiegoNolan> Does anyone want to critque some code?
18:14:53 <Tekmo> I do!
18:15:05 <ski> zRecursive : i was more thinking about Peaker's comment
18:15:05 <copumpkin> Tekmo will suggest using pipes
18:15:06 <Mortchek> Yet the inequality operators, such as <, *are* polymorphic in OCaml, which I find super weird since the arithmetic ones aren't.
18:15:09 <Tekmo> Yeah, use pipes
18:15:10 <DiegoNolan> oh, no.  You're well known.
18:15:13 <Tekmo> I'm sure you need it, somehow
18:15:13 <tikhonjelvis> okay, maybe it is forwards, but it's in the opposite direction that I want
18:15:14 <applicative> ski of course its ugly it wasnt designed by David Turner
18:15:29 <tikhonjelvis> I want to have the big stuff first and the small details later
18:15:45 <applicative> when people devise new languages with fancy ideas, profound ideas, whatever, like eg Scala
18:15:49 <tikhonjelvis> which is why I almost always use where rather than let in Haskell
18:16:10 <DiegoNolan> Tekmo: you said you wanted to?
18:16:13 <applicative> they should realize that syntax design is like web design, you think you can do it, but in fact you need an expert.  David Turner is the expert.
18:16:17 <Tekmo> Yeah, I will review your code
18:16:22 <DiegoNolan> https://github.com/DiegoNolan/optimyze
18:16:26 <DiegoNolan> not too much
18:16:30 <Tekmo> It's ok
18:16:37 <tikhonjelvis> meh, I think the answer to syntax design is just like the answer to everything else—it should be in a library
18:16:40 <DiegoNolan> the LinearAlgerba is just a gaussian elimination solver
18:16:45 <ski> tikhonjelvis : both the `open <module path>' declaration and the `<module path>.(<expression>)' syntax works
18:16:50 <DiegoNolan> doesn't handle ill conditioned systems at all
18:16:57 <ski> (the latter is an expression)
18:17:00 <DiegoNolan> and has rounding errors and stuff from floating points
18:17:10 <DiegoNolan> doesn't use ST like it probably should etc
18:17:13 <Tekmo> Do you want me to just review coding style?
18:17:28 <DiegoNolan> Whatever you want to
18:17:39 <DiegoNolan> unless you have suggestions on how to handle row operations and stuff
18:17:45 <applicative> jamil_1: I hope my suggestions havent scared you of or something.
18:17:47 <zRecursive> At least OCaml is NOT clever to infer the type of Float, so it needs the programmwe to tell it. Moreover, OCaml still needs you to tell her "this is a recursive function" ...
18:18:01 <Tekmo> Is this an exercise?
18:18:01 <jamil_1> applicative: working on them :)
18:18:04 <DiegoNolan> no
18:18:15 <Tekmo> Because there is the HMatrix library
18:18:28 <applicative> jamil_1: if you have the more recent cabal-install you can install in parallel with -j2 or whatever.
18:18:41 <jamil_1> ok
18:18:45 <DiegoNolan> I looked at that but i think it is just a binding to blas in C
18:18:54 <DiegoNolan> I kind of wanted it all in haskell
18:19:01 <ski> Mortchek : in MetaML, those are constrained polymorphic (there's a few built-in constraints, for equality, comparision, arithmetic, lifting, row "lacks" (for extensible records and variants), and perhaps some i forget)
18:19:02 <Tekmo> Alright
18:19:03 <DiegoNolan> want to create a full convex optimization lib
18:19:08 <DiegoNolan> but my haskell is not so good yet
18:19:39 <Mortchek> ski, yeah, I just find it weird that the ad hoc polymorphism is built into the language there but not accessible by the programmer.
18:20:08 <Tekmo> Are you concerned about efficiency?
18:20:19 <ski> zRecursive : having to say "this is a recursive function" can be considered a feature ..
18:20:23 <Mortchek> I might be misunderstanding what you said actually.
18:20:29 <DiegoNolan> In the future.  I will probably switch to STVectors
18:20:34 <DiegoNolan> or add support for both
18:20:43 <ski> Mortchek : talking about SML, OCaml, or MetaML now ?
18:21:01 <DiegoNolan> in the test file
18:21:04 <Mortchek> My comment was about OCaml.
18:21:23 <DiegoNolan> you can call testSolveLinSys
18:21:28 <zRecursive> ski: i donot think so. at least not convenient
18:21:29 <DiegoNolan> and give it the dimensions
18:21:31 <Mortchek> (+) is int -> int -> int but (>) is 'a -> 'a -> bool
18:21:36 <DiegoNolan> it will create one with random numbers and solve
18:21:55 <DiegoNolan> then shows the what the rhs would be with the given solution
18:22:04 <DiegoNolan> and you can see the rounding error
18:22:18 <Tekmo> Do you plan to release this as a library?
18:22:27 <DiegoNolan> Yes, but it has a looot of work
18:22:31 <Tekmo> It's ok :)
18:22:43 <DiegoNolan> I will release it under some licenses
18:22:43 <ski> zRecursive : it means you can say `let val x = ..x.. in ..x.. end', shadowing an outer `x' -- e.g. can be used with state threading
18:22:54 <DiegoNolan> want perfect the simplex method and dual simplex
18:22:59 <DiegoNolan> and maybe some interior point
18:23:02 <DiegoNolan> bundle methods
18:23:08 <DiegoNolan> newton step stuff
18:23:11 <Tekmo> So the last few questions are related to the choice of underyling representation
18:23:26 <Tekmo> Have you considered using Repa to model these types or is that too much type machinery?
18:23:34 <ski> Mortchek : well, i'd say there's no ad hoc polymorphism in OCaml at all (in SML, however, there some, for arithmetic, but you can't make your own)
18:23:50 <DiegoNolan> I'm not familiar with Repa, have only read about it in passing
18:23:57 <DiegoNolan> but I know i want to avoid TH
18:24:02 <Tekmo> It's a nice library for modeling things more complicated than Vectors
18:24:11 <DiegoNolan> kk
18:24:15 <Tekmo> And it's also implemented in Haskell
18:24:18 <Mortchek> ski, right; (>) is conceptually ad hoc polymorphic but there is no mechanism by which the programmer can write such a function themselves.
18:24:30 <Tekmo> You can use it to add more type safety to matrix operations
18:24:40 <Tekmo> i.e. mis-matched dimensions and things like that
18:24:41 <DiegoNolan> Yeah
18:24:42 <ski> zRecursive : it means that not all bindings have to be recursive (and i suppose this makes more sense in an eager language, yes)
18:24:48 <DiegoNolan> That sounds interesting
18:24:50 <DiegoNolan> because mathematically
18:24:53 <DiegoNolan> makes a lot more sense
18:24:58 <DiegoNolan> to have length check types
18:25:01 <DiegoNolan> like tuples
18:25:05 <byorgey> Luke: what's up?
18:25:06 <DiegoNolan> but not tuples obviously
18:25:09 <Tekmo> Even if you don't use Repa
18:25:24 <Tekmo> You can still implement your own simple size checking system using phantom types
18:25:37 <Tekmo> The idea is that you might represent a matrix's type as someting like:
18:25:45 <Tekmo> Matrix Rows Cols Double
18:25:59 <Tekmo> Or Vector Rows Double
18:26:01 <ski> Mortchek : yes, i'm not so happy about that. i prefer the SML take where there is no such generic `op >' function (you have to use one specific to the particular type, if any, often defined in the module defining the type in question)
18:26:09 <Tekmo> Then the type of dot product can verify their lengths match:
18:26:17 <Tekmo> dot :: Vector n a -> Vector n a -> Vector n a
18:26:45 <hpaste> dan pasted “Install crypto-api-0.12.2 error” at http://hpaste.org/87466
18:26:48 <DiegoNolan> cool. I definitely want that.  But I was unsure if it was possible when i started writing
18:26:54 <Tekmo> Yeah, it's definitely possible
18:27:05 <Tekmo> There is typically one unsafe step when you first build the vector
18:27:21 <Tekmo> Well, not really safe, but let me explain
18:27:33 <Tekmo> Hold on one second
18:27:41 <theli0nheart> hey all, I'm running into the error posted by hpaste above when installing crypto-api. I'm running Mac OS X 10.8--any pointers on what I might be able to do to fix this?
18:30:37 <Tekmo> Ok, so I was just doing some research because it's been a while since I learned how to do this
18:31:01 <Tekmo> GHC recently added support for type level arithmetic in 7.6(?) (Somebody correct me if I'm wrong)
18:31:19 <Tekmo> So you can actually use numbers in your types
18:31:30 <Tekmo> Like "Vector 3 Double", to represent a 3-dimensional vector
18:32:03 <Tekmo> Then with some tricks you can access the value-level representation of that type if necessary in your code using functions like 'sing'
18:32:25 <Tekmo> So the entry point to your library would be a function like:
18:32:55 <Tekmo> fromList :: [a] -> Maybe (Vector n a)
18:33:13 <Tekmo> So that function would check if the list has the right number of elements for the requested Vector type and then return a Just if it matched
18:33:27 <applicative> theli0nheart: fromStrict is in the new bytestring library, but not in the one you have
18:33:36 <Tekmo> Then once you do that all the vector operations past that point are type safe so you can safely ignore vector mismatches
18:33:39 <applicative> or rather, not in the one ghc is using
18:34:38 <theli0nheart> applicative: (I'm new to Haskell) is this something I would need to update GHC for, or is it something I can update through cabal?
18:34:47 <Tekmo> Give me a second because I need to switch my environment to ghc 7.6 to test some of this stuff out myself
18:34:51 <byorgey> Tekmo: GHC 7.6 has support for type-level natural number constants.  Support for actual arithmetic will be in 7.8, I think.
18:35:02 <Tekmo> byorgey: thanks!
18:35:11 <Tekmo> I think for matrix operations he doesn't need the arithmetic
18:35:30 <DiegoNolan> I se
18:35:32 <DiegoNolan> I see
18:35:44 <applicative> theli0nheart: hm, I think Thomas Duboisson didn't update the cabal file to require bytestring-0.10 on the other hand, he shouldn't be requiring it yet
18:35:57 <byorgey> Tekmo: yeah, probably not
18:36:34 <DiegoNolan> What is this actual process called and how can I read more or see a working example?
18:36:42 <DiegoNolan> and I can do this or Repa?
18:37:11 <Tekmo> Yeah, I'm looking this up myself
18:37:16 <DiegoNolan> oh nevermind.  type-lever natural number constraints?
18:37:20 <Tekmo> Yeah, either this or Repa will work for you
18:37:22 <theli0nheart> applicative: hmm, any pointers on what I should do here?
18:37:44 <Cale> DiegoNolan: Sorry, which process?
18:38:09 <DiegoNolan> type checking by vector length
18:38:17 <applicative> hm.  theli0nheart the trouble is I don't know how wise it is to install bytestring-0.10 since you got bytestring-0.9.x with the compiler
18:38:23 <Cale> Well, it's a special case of dependent typing.
18:38:32 <DiegoNolan> okay
18:38:33 <Tekmo> Cale!
18:38:37 <Cale> (Types which depend on values)
18:38:37 <Tekmo> I need your assistance!
18:38:41 <Cale> Oh?
18:38:42 <shachaf> applicative: It is probably not wise to upgrade any library that comes with the compiler.
18:38:44 <Tekmo> I don't know how to use type level naturals
18:38:50 <Tekmo> But I think he needs them
18:38:59 <Tekmo> He wants to write a numeric library using matrix and vectors
18:39:13 <Tekmo> He's interested in using types to prevent vector and matrix size mismatches
18:39:32 <applicative> there is basically a small mistake in this commit https://github.com/TomMD/crypto-api/commit/0cde4a4f57bc7edf1a6f70f950806de7067afd0a#Crypto/HMAC.hs
18:39:45 <applicative> shachaf: yes.
18:39:55 <theli0nheart> shachaf: I'm running 7.4.2
18:40:17 <theli0nheart> applicative: good catch! so I guess this is an issue with crypto-api
18:40:30 <applicative> theli0nheart: that change meant he needed bytestring-0.10 but he didn't put that in the .cabal file; on the other hand, you don't want bytestring-0.10.
18:40:45 <applicative> theli0nheart: maybe the previous version of crypto-api
18:41:16 <Tekmo> Ok, I think I found something useful.  I'm reading this: www.haskell.org/wikiupload/1/11/Hiw2012-iavor-diatchki.pd
18:41:17 <Cale> Oh, well, you could do that, but I think it's still a little too early for that to be practical in Haskell. It's what the type level numeric literals and datatype promotion stuff is aimed at in recent GHCs though.
18:41:26 <theli0nheart> applicative: is bytestring-0.10 bleeding edge or something?
18:41:59 <applicative> theli0nheart: well it's used in the latest ghc, and in the 'haskell platform' that's coming out soon.
18:42:14 <theli0nheart> applicative: "cabal install crypto-api-0.12.1" worked like a charm
18:42:27 <applicative> oh ok, that's the answer then
18:42:52 <theli0nheart> applicative: also, is it recommended to be running latest ghc?
18:43:07 <Cale> But see here: http://www.haskell.org/ghc/docs/latest/html/users_guide/promotion.html
18:43:31 <applicative> theli0nheart: no, i think the recommended is to use the latest haskell platform
18:43:42 <Tekmo> DiegoNolan: I almost got it.  Just hang in there.
18:43:51 <applicative> but the going  haskell platform, which is now going to be replaced, has maybe been around a little too long
18:43:53 <DiegoNolan> okay
18:44:18 <theli0nheart> yeah, I see it's been out since April 2012
18:45:12 <applicative> yeah, I think that's a little too long to keep up with the mass mind of hackage -- many contributors to it forget they are using HEAD or the like ::)
18:45:38 * applicative isnt sure if he accidentally just typed an especially idiotic emoticon
18:45:44 <Cale> DiegoNolan: In a dependently typed system such as Coq, Agda, or Idris, you can do this kind of thing quite a bit more naturally. Haskell has been headed in that direction, but type level arithmetic is only just barely getting to the point where you might want to really use it.
18:46:15 <applicative> theli0nheart: mzero has been putting the finishing touches on the new os x platform.
18:46:21 <theli0nheart> applicative: gotcha...so basically some people are just jumping the gun a bit :)
18:46:38 <Nisstyre-laptop> Cale: don't they want to get some of the effects of dependent typing without actually having dependent typing?
18:46:56 <ski> byorgey : .. hm, i wonder whether type-level arithmetic in 7.8 will then amount roughly to arithmetical constraint logic programming on the type-level
18:46:58 <applicative> theli0nheart: oh yeah, if you are a little too into it, there's always some new feature that seems absolutely necessary
18:47:37 <applicative> theli0nheart: the whole culture is a bit bleeding-edgish; this is a source of problems for professional uses
18:47:43 <chrisdotcode> hey guys, is the 99 haskell problems any good for a beginner to get better?
18:47:54 <chrisdotcode> * are they suitable for *brand new* beginners
18:47:54 <applicative> users
18:48:07 <tikhonjelvis> I really didn't like the 99 problems
18:48:13 <tikhonjelvis> they're mostly not very haskellish
18:48:43 <Cale> Nisstyre-laptop: Well, yeah -- the idea, I think, is to get closer to being a dependently typed system while maintaining a higher degree of type inference than most dependently typed languages enjoy.
18:49:16 <DanBurton> still, the 99 problems are at least something simple to do
18:49:32 <tikhonjelvis> well, a bunch of them don't even make any sense for Haskell
18:49:35 <DanBurton> Can't think of an adequate substitute besides perhaps Project Euler problems
18:49:45 <tikhonjelvis> or old ACM problems
18:49:48 <blaenk> hey guys. I'm trying to install hakyll on windows (I know I know). I already got it installed perfectly fine on arch linux, on windows I have msys and mingw setup (mingw came with haskell platform). when I install hakyll, the crypto-api package fails
18:49:49 <lambdabot> blaenk: You have 2 new messages. '/msg lambdabot @messages' to read them.
18:50:18 <blaenk> it fails with reason "Crypto\HMAC.hs:38:8: Not in scope: 'L.fromStrict'". I downloaded the source to that package and saw that indeed that file imports the relevant file
18:50:30 <blaenk> import qualified Data.ByteString.Lazy as L
18:50:31 <hpaste> “Gabriel Gonzalez” pasted “Type-level naturals” at http://hpaste.org/87467
18:50:35 <geekosaur> two in an hour, what's the probability?
18:50:37 <Tekmo> Ok, I got it working
18:50:39 <blaenk> I even did cabal install bytestring just to be sure
18:50:47 <elliott> that wasn't the best idea
18:50:53 <Ghoul_> In a cabal build thing
18:50:55 <elliott> hopefully it hasn't broken anything
18:51:01 <Tekmo> DiegoNolan: If you check out that hpaste, it shows how you would set up basic support
18:51:01 <Ghoul_> would it be best to put -O2 under ghc-options ?
18:51:11 <theli0nheart> applicative: yeah, hopefully it'll get better as time goes on. I certainly am making the effort to push Haskell more in my work...but we'll see
18:51:13 <DiegoNolan> Thanks I'll take a look
18:51:19 <Tekmo> DiegoNolan: An example usage would be:
18:51:28 <DiegoNolan> and this is only ghc 7.6 and up
18:51:33 <Tekmo> DiegoNolan: fromList [1..3] :: Maybe (Vector 3 Double)
18:51:35 <Tekmo> Right
18:51:50 <DiegoNolan> all okay
18:51:54 <DiegoNolan> ahh okay*
18:52:04 <Tekmo> So if you enable DataKinds in ghci and type that out, it will return a vector correctly
18:52:06 <DiegoNolan> so it return Nothing if the list doesn't match
18:52:11 <Tekmo> Right
18:52:38 <Tekmo> Then operations like 'dot' can safely assume that all vectors obey the advertised length in the type
18:52:50 <Tekmo> This means that you have to not export the constructor for the matrix and vector
18:52:59 <geekosaur> blaenk, latest crypto-api is currently broken, it requires a version of bytestring that you really should not install. remove the just installed bytestring, and then try: cabal install crypto-api-0.12.1
18:53:01 <Tekmo> You have to enforce that the only way to build them is through approved functions like 'fromList'
18:53:13 * BMeph would recommend SPOJ over PE, if only because of the former's concentration on using a computer to solve them
18:53:28 <DiegoNolan> Okay and all the type checking/size checking is ther
18:53:30 <DiegoNolan> cool
18:53:39 <DiegoNolan> Any other suggestions, critques?
18:53:47 <Tekmo> Yeah, let me go back through your code.  Hold on a second
18:53:50 <DiegoNolan> should I move to ST right away?
18:53:51 <DiegoNolan> kk
18:54:42 <Tekmo> What matters more is unboxed vectors
18:54:48 <Tekmo> That makes a huge performance difference
18:54:55 <Tekmo> And also avoids space leaks
18:55:10 <chrisdotcode> tikhonjelvis: so it that a no to the 99 problems?
18:55:21 <Tekmo> Data.Vector.Unboxed is good enough for your purposes
18:55:24 <tikhonjelvis> well, I personally don't recommend them
18:55:25 <Tekmo> You don't need to worry about mutation
18:55:38 <Tekmo> The pure interface will be fast enough for your purposes
18:55:54 <tikhonjelvis> but don't hold my opinion sacrosanct
18:55:59 <tikhonjelvis> at least on this
18:56:03 <Tekmo> Oh wait, you still have a problem
18:56:12 <Tekmo> Your matrix is a vector of vectors, which would make the outer vector boxed
18:56:26 <chrisdotcode> alright, I'll try a few...
18:56:29 <Tekmo> You will get much greater performance if you use a single unboxed vector and map indices to the linear vector
18:56:38 <Tekmo> I think this is what Repa does, too
18:56:40 <Tekmo> Let me check
18:56:43 <DiegoNolan> Ahh
18:56:45 <DiegoNolan> hmm
18:57:50 <Tekmo> Boxed vectors will cause you a lot of headaches
18:57:57 <Tekmo> It's very difficult to keep them strictly evaluated
18:58:21 <DiegoNolan> Okay
18:58:23 <DiegoNolan> hmm
18:58:54 <DiegoNolan> I think would moving the a single vector and mapping the indices would require me to change the algorithm
18:59:26 <DiegoNolan> If I moved to ST I think I could implement it more imperatively
18:59:33 <DiegoNolan> with the recursion
18:59:34 <Tekmo> ST won't fix the boxed vectors
18:59:43 <Tekmo> Boxed vectors still leak space even when you use the mutable interface
18:59:49 <DiegoNolan> ahh
18:59:50 <DiegoNolan> him
18:59:55 <Tekmo> Even if you do the operations strictly
18:59:58 <Tekmo> It is a royal pain
19:00:04 <DiegoNolan> Ic
19:00:27 <Tekmo> If you take the time to get a single Unboxed vector to work, the rest is smooth sailing
19:00:28 <DiegoNolan> I could just change the way I do it now and not recurse by passing the lower right of the matrix
19:00:39 <Tekmo> Alternatively, you can use Repa
19:00:39 <DiegoNolan> Yeah
19:00:43 <Tekmo> which has already done the hard work on that
19:01:00 <DiegoNolan> I was reading the haskell page
19:01:16 <DiegoNolan> I may use it
19:01:26 <applicative> on repa?
19:01:40 <DiegoNolan> you host hmatrix on your github right?
19:03:06 <Tekmo> So you can mitigate changes to the underlying algorithm by using a BLAS-like approach where you define primitive operations and then build everything else on top of those
19:05:06 <DiegoNolan> Yeah.  A lot to consider
19:06:45 <Tekmo> Ok, another issue is that your column function is going to be very inefficient
19:07:08 <Tekmo> V.cons is a very expensive operation since it allocates a new vector and garbage collects the old one
19:07:27 <Tekmo> And you will be doing it N times, once for each cell
19:08:15 <Tekmo> Vector has several functions for unfolding a vector that will make this much faster
19:08:26 <DiegoNolan> OKay.
19:08:51 <Tekmo> Found it
19:08:52 <Tekmo> v.generate
19:08:55 <Tekmo> That's the function you want
19:09:02 <Tekmo> It builds the entire vector in one go
19:09:43 <DiegoNolan> Okay
19:10:01 <saulzar> Hi guys - I'm playing around with the cloud haskell stuff, and I'm getting an error trying to build with shared libraries turned on... but you see it already has the -fPIC flag:  relocation R_X86_64_PC32 against symbol `distributedzmprocesszmsshzm0zi1zi0_ControlziDistributedziProcessziBackendziSSH_vmName_closure' can not be used when making a shared object; recompile with -fPIC
19:11:01 <Tekmo> Also, in your `transpose` function, instead of using `fromList [0..something]` you can use `V.enumFromTo 0 something`
19:11:30 <Tekmo> Or even better, use `generate` there, too
19:11:51 <Tekmo> Since generate will pass the current index as a parameter to the function building that cell
19:12:20 <Cale> saulzar: Do you have a really good reason to turn on shared libraries?
19:12:52 <Tekmo> So you could just do 'transpose m = V.generate (V.length m) (column m)'
19:13:01 <saulzar> Hmm - I was trying to upload my binaries to EC2
19:13:06 <Cale> (It might be easier just to statically link everything)
19:13:15 <saulzar> But it was taking ages to upload them each time..
19:13:20 <DiegoNolan> Yeah.
19:13:23 <Cale> ah
19:13:35 <DiegoNolan> I'm definitely going to have to rewrite essentially all of this
19:13:50 <Tekmo> :)
19:14:05 <zRecursive> saulzar: Is EC2 expensive ?
19:14:14 <blaenk> applicative: you around? I'm experiencing an issue you just posted about on github
19:14:25 <blaenk> applicative: https://github.com/TomMD/crypto-api/issues/17
19:14:32 <DiegoNolan> because I'm definitely not going to used boxed vectors as you said
19:14:42 <saulzar> zRecursive: I don't really know... for now it's not as I'm just playing around
19:14:43 <applicative> ha, really blaenk
19:14:51 <blaenk> I'm new to haskell and didn't know I shouldn't install bytestring-10.0 :{ any way I can revert that before I run into problems?
19:14:56 <applicative> did you try the solution of installing the previous version of crypto-api?
19:15:09 <blaenk> applicative: yeah, I was trying to install hakyll on windows and figured it was a windows issue. on haskell-platform
19:15:16 <blaenk> no I didn't try that, should I?
19:15:25 <applicative> blaenk: yes, ghc-pkg unregister bytestring-0.10
19:15:35 <blaenk> was barely reading the irc transcript you pasted
19:15:38 <blaenk> ok thanks
19:15:39 <applicative> blaenk: what version of the compiler are you using?
19:15:43 <Tekmo> DiegoNolan: Overall, though, your coding style is pretty clean and good
19:15:46 <blaenk> how would I go about installing the previous version by the way?
19:15:50 <blaenk> sec
19:15:59 <blaenk> 7.4.2
19:16:02 <blaenk> or do you want the haskell-platform version?
19:16:05 <blaenk> that was ghc --version
19:16:25 <geekosaur> [07 21:52] <geekosaur> blaenk, latest crypto-api is currently broken, it requires a version of bytestring that you really should not install. remove the just installed bytestring, and then try: cabal install crypto-api-0.12.1
19:16:46 <applicative> cabal install crypto-api-0.12.1
19:16:53 <blaenk> geekosaur: beautiful, I will try that. thanks geekosaur and applicative!
19:16:54 <DiegoNolan> Tekmo: Thanks, I appreciate your advice
19:16:55 <Tekmo> DiegoNolan: Yeah, I don't see anything else obviously wrong
19:17:01 <applicative> like geekosaur says, blaenk
19:17:06 <geekosaur> (which is the irc discussion roughly distilled to one line, 20 minutes ago...)
19:17:17 <blaenk> really thought I was on my own here, thinking it was a fringe haskell on windows issue
19:17:34 <Tekmo> Just keep in mind that the pure Vector API will be pretty much as efficient as the mutable API
19:17:42 <Tekmo> It's a really damn smart library
19:17:53 <DiegoNolan> just Vector.Unboxed?
19:18:03 <DiegoNolan> cool
19:18:04 <geekosaur> no, someone had just reported it on OS X like 10 minutes before you showed up
19:18:10 <Tekmo> So both Vector.Boxed and Vector.Boxed will do all the neat fusion optimizations
19:18:28 <Tekmo> It's just that Vector.Boxed is way slower
19:18:29 <DiegoNolan> wait Vector.Boxed and Vector.Boxed?
19:18:30 <geekosaur> hence my "twice in an hour" comment
19:18:32 <Tekmo> Oops
19:18:36 <Tekmo> Vector.Boxed and Vector.Unboxed
19:18:39 <DiegoNolan> okay
19:18:44 * applicative was a 90 lb weakling, other haskellers looked down on, everything was a mess .... then he discovered Data.Vector.Unboxed !
19:18:51 <Tekmo> lol
19:18:57 <applicative> looked down on him
19:19:38 <Tekmo> I've tried nearly every permutation of the vector API possible in my own projects, and it pretty much entirely boils down to use Unboxed vectors
19:19:39 <DiegoNolan> hmm
19:19:45 <blaenk> awesomeeeeee, hakyll installed :D
19:19:45 <Tekmo> Almost nothing else matters other than that
19:19:47 <DiegoNolan> Okay
19:20:08 <DiegoNolan> I want to write your advice to just have a single ector and map indexs
19:20:08 <Tekmo> Hakyll is great
19:20:15 <DiegoNolan> but it changes the algorithm a lot
19:20:17 <Tekmo> Well, try Repa
19:20:19 <DiegoNolan> so I'll have to think about it
19:20:20 <DiegoNolan> okay
19:20:29 <Tekmo> Repa does that but still gives you the nice multi-index support
19:20:35 <Tekmo> So you can get the best of both worlds
19:20:38 <applicative> blaenk: oh good work!
19:20:42 <blaenk> :D
19:20:51 <DiegoNolan> Okay.  I will definitely try that first
19:21:00 <DiegoNolan> Thanks for the help.  Really appreciate it.
19:21:08 <Tekmo> No problem!  :)
19:21:10 <DiegoNolan> Will be back later hopefully with progress
19:21:14 <DiegoNolan> later
19:21:15 <Tekmo> Yeah, good luck!
19:21:18 <Tekmo> Later
19:21:33 <Tekmo> See, not one mention of pipes
19:25:35 <yogert> hey all,  this may be naive, but given I still have a lot to learn i'll go ahead and ask…. Is it possible (or even make sense) to ensure that a list is sorted by virtue of its type? Essentially I'd like to have "median::Sorted -> Sorted median l = last $ take ((length l) `div` 2) l"
19:25:36 <Ghoul_> Anyone know where I can get the "Built with Cabal" logo with a transparent background
19:26:11 <elliott> yogert: only with advanced type hackery or something that amounts to checking sortedness whenever you construct one
19:26:19 <elliott> it's more viable in dependently-typed languages
19:26:49 <Tekmo> yogert: Would you be fine with a function of type: [a] -> Maybe (Sorted a)?
19:27:23 <yogert> I
19:27:47 <yogert> no probably not… Maybe what I'm trying to do is the wrong approach...
19:28:05 <Tekmo> What I mean is that you can define the following type:
19:28:09 <BMeph> So, is any ambitious soul working on a Repa translation in Idris?
19:28:14 <Tekmo> newtype Sorted a = Sorted { unSorted :: [a] }
19:28:33 <Tekmo> You hide the 'Sorted' constructor and instead just expose a safe entry function:
19:28:35 <BMeph> I think it'd be minorly interesting to see just how much you can trim.
19:28:41 <Tekmo> fromList :: [a] -> Maybe (Sorted a)
19:29:12 <geekosaur> as a practical matter, you can look at how Data.Set works --- it maintains a sorted (finger)tree internally, but has to go to some lengths to keep from exposing that internal representation lest someone inadvertently break it
19:29:16 <Tekmo> Oh wait, it would just be:
19:29:22 <Tekmo> fromList :: [a] -> Sorted a
19:29:28 <Tekmo> fromList as = Sorted (sort as)
19:29:43 <Tekmo> Then all functions that operate on a value of type 'Sorted a' can assume the list is sorted
19:30:09 <yogert> ok, and whenever i want to creat something of that type I just make sure I use fromlist?
19:30:12 <Tekmo> Yes
19:30:29 <Tekmo> If you hide the constructor for 'Sorted', you can enforce that 'fromList' is the only way to build a value of type 'Sorted a'
19:30:43 <Tekmo> So your module's export list would be something like:
19:30:45 <yogert> hide it meaning I don't export it
19:30:46 <yogert> ?
19:30:53 <Tekmo> module Sorting ( Sorted, ... ) where
19:30:56 <Tekmo> Right
19:31:08 <Tekmo> You only export the Sorted type, and probably also the unwrapper, too
19:31:12 <Tekmo> So you could also do:
19:31:23 <Tekmo> module Sorting ( Sorted(unSorted), ... ) where
19:31:34 <Tekmo> That only exports the unwrapper function
19:32:00 <yogert> which exposes the sorted list.
19:32:22 <Tekmo> Right, in case the user doesn't care about preserving the invariant any longer
19:32:36 <yogert> for a second it looked to me that "unSorted" might even "unsort" the list : )
19:32:37 <Tekmo> If they want to use functions like 'median', they would have to rewrap the list using 'fromList'
19:32:46 <Tekmo> :)
19:32:58 <Tekmo> So your median function would have type:
19:33:04 <Tekmo> median :: Sorted a -> a
19:33:48 <Singingboyo> might want to rename "unSorted" to "extractSorted" or something similar.  "unSorted" sounds like you're getting an unsorted list.
19:34:15 <copumpkin> median (Sorted [])
19:34:30 <Tekmo> Aw, psh
19:34:36 <Tekmo> median :: Sorted a -> Maybe a
19:34:41 <yogert> yeah thats what I kinda thought it was doing for a second …. heh
19:35:11 <yogert> why the maybe? in case of  []?
19:35:14 <Tekmo> Yeah
19:35:15 <Singingboyo> or just crash if you try to get the median from a sorted list, similar to head/tail.
19:35:22 <Tekmo> No!
19:35:29 <BMeph> Sorted {getSorted:: [a]}
19:36:16 <yogert> no what?
19:36:26 <Tekmo> Don't use errors for invalid inputs
19:36:30 <yogert> is maybe always better than failing?
19:36:31 <Tekmo> Maybe is a better solution
19:36:37 <Tekmo> Yeah, pretty much
19:36:43 <Singingboyo> maybe is better, except in extreme cases yeah
19:36:54 <Tekmo> Haskell makes it very easy to work with Maybes
19:37:00 <Tekmo> So there's no reason not to use them
19:37:43 <Singingboyo> I've been doing too much scala.  The equivalent of Maybe for scala can be a pain.
19:37:47 <Tekmo> The Maybe monad makes it easy to chain multiple computations that can fail
19:38:06 <yogert> okay, thanks for all the help! I'm not sure whether this is exactly the best approach but I'm learning
19:38:21 <Tekmo> You're welcome!
19:38:27 <johnw> yogert: a more broader way to answer your question is: total functions should always be preferred to partial functions
19:38:34 <yogert> how would you chain? with <$>/ <*>
19:38:35 <yogert> ?
19:39:06 <yogert> johnw: i'm sorry, I'm not sure what you mean
19:39:19 <johnw> yogert: a partial function is one that "doesn't have an answer" for some inputs
19:39:27 <johnw> in which case it either crashes, doesn't return, or throws an exception
19:39:32 <yogert> ah ok
19:39:32 <johnw> a total function "always has an answer"
19:39:42 <zRecursive> (++) <$> getLine <*> getLine
19:39:57 <Tekmo> So, for example, let's say that you wanted to sum the medians of two separate lists
19:40:00 <johnw> using Maybe instead of failing is a way of making a partial function into a total one
19:40:00 <Tekmo> You could just write:
19:40:03 <yogert> yeah thats what I've been doing, but I'm not sure if thats what he meant by chain
19:40:12 <Tekmo> (+) <$> median sorted1 <*> median sorted2
19:40:23 <Tekmo> That's using the Maybe Applicative
19:40:58 <yogert> does Maybe expose those? Is it the same as the one in Control.Applicative?
19:41:12 <Tekmo> You'd have to import Control.Applicative to use those operators
19:41:23 <Tekmo> You can also do the equivalent using the Monad instance
19:41:38 <Tekmo> do { m1 <- median sorted1; m2 <- median sorted2; return (m1 + m2) }
19:41:53 <zRecursive> <$> makes pure function enter monad, <*> supply extra parameter in the monad ?
19:41:55 <arkeet> liftA2 (+) m1 m2
19:41:55 <johnw> you can chain Maybe two ways: with or-behavior (choose first Just value, ignore Nothing), or and-behavior (abort on Nothing, or choose last Just value).  Use <|> for the or-behavior, or the monad/applicative interfaces for the and-behavior
19:41:57 <arkeet> or liftM2
19:42:46 <zRecursive> @src (<$>)
19:42:47 <lambdabot> f <$> a = fmap f a
19:43:16 <zRecursive> so it needs fmap
19:43:26 <johnw> zRecursive: <$> applies a pure function to a value "in the monad", while <*> applies a function "in the monad" to a value "in the monad"
19:43:48 <johnw> indeed, <$> *is* fmap
19:44:15 <zRecursive> right
19:44:23 <johnw> (<$>) = fmap
19:44:53 <zRecursive> it uses fmap
19:45:10 <johnw> they are the same function
19:45:15 <Tekmo> Right
19:45:18 <johnw> <$> is another name for the function that fmap names
19:45:26 <Tekmo> (<$>) is just an infix version of fmap
19:45:31 <Tekmo> You could just as well use `fmap`
19:45:53 <Tekmo> (+) `fmap` median sorted1 <*> median sorted2
19:45:56 <zRecursive> :t fmap
19:45:58 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:46:21 <yogert> I realize that this is probably for a longer discussion, but what makes something a Monad? For instance why cant i do this?
19:46:45 <yogert> data Foo a = Bar b | Empty deriving ( Show, Functor)
19:47:02 <Tekmo> Do you mean 'Bar a'?
19:47:03 <johnw> yogert: that question actually has many answers, but the simplest is: if a type constructor implements `return` and `>>=`, and obeys the monad laws, it is a monad
19:47:03 <yogert> (+) <$> Bar 1 <*> Bar 2
19:47:07 <yogert> yeah
19:47:17 <Tekmo> YOu need to supply the type class instance
19:47:20 <Tekmo> Such as:
19:47:30 <Tekmo> instance Applicative Foo where ...
19:47:34 <Tekmo> instance Monad Foo where ...
19:47:40 <Tekmo> Then it will work
19:47:46 <lpvb> upper bounds on library dependencies in cabal should only be used when a new library breaks the program right?
19:47:58 <johnw> lpvb: yes, please
19:48:03 <lpvb> it shouldn't be used on future library versions that don't exist yet
19:48:05 <johnw> arbitrary upper bounds are worse than useless
19:48:06 <yogert> johnw: yea there is a pretty good article i read about this on the haskell wiki, but I don't think i've come to appreciate it all fuly
19:48:39 <yogert> Tekmo: can I simply use derive?
19:49:00 <johnw> yogert: i've been delving into what monads really are for several months now, and I still don't appreciate it fully.  It is just too abstract to "understand all at once".  The best thing to do is just keep reading, keep coding, keep thinking.
19:49:27 <Tekmo> No, you can't use derive
19:49:31 <Tekmo> only for Functor
19:49:52 <Tekmo> YOu can only derive Functor instances using the {-# LANGUAGE DeriveFunctor #-} pragma
19:49:58 <yogert> is Monad not a typeclass…?
19:50:03 <johnw> it is
19:50:19 <zRecursive> i always regard monad as interface first, then if your data implement the interface, then it is a monad ...
19:50:46 <Tekmo> Monad is a type class
19:50:50 <zRecursive> at least implement (>>=) and return
19:51:43 <Tekmo> Give me a second
19:51:47 <Tekmo> I'm writing up an hpaste as an example
19:51:53 <zRecursive> yogert: so you cannot use derive as each data is different
19:51:57 <yogert> okay thanks
19:52:14 <yogert> because it cannot infer how those would be implemented?
19:52:43 <Tekmo> Right
19:52:45 <Singingboyo> yogert: yes.  There's no suitable default that would fit any datatype, so it can't be derived.
19:52:52 <Tekmo> You have to tell how to implemet all type class instances
19:52:58 <johnw> yogert: a more interesting way to approach your question is, "How does it work for Functor?"
19:53:33 <johnw> even Monoid cannot be automatically derived, because a given type T admits of several different possible monoid algebras
19:53:36 <yogert> well it doesn't seem to. I have to set a flag to get that to work
19:54:08 <yogert> what then lets me know what can be derived?
19:54:32 <johnw> you can derive Functor, Foldable, Traversable, Generic, Typeable, and a few other core type classes
19:54:36 <johnw> if you enable the right extensions
19:54:55 <hpaste> “Gabriel Gonzalez” pasted “Foo Applicative and Monad” at http://hpaste.org/87468
19:55:01 <Tekmo> There, check out that hpaste
19:55:07 <johnw> Hi Gabriel!
19:55:10 <johnw> I forget your nick was Tekmo
19:55:11 <Tekmo> It shows how you can implement your own Applicative and Monad instances for Foo
19:55:13 <Tekmo> Hi!
19:55:14 <Tekmo> :)
19:55:39 <Tekmo> It also provides examples of using the applicative instance (i.e. (<*>)) and the monad instance (i.e. do)
19:55:55 <Tekmo> What is your name on reddit?
19:56:22 <johnw> jwiegley/John Wiegley
19:56:26 <johnw> i don't post very much
19:56:26 <Tekmo> Got i!
19:56:32 <Tekmo> *it
19:56:35 <johnw> i really liked your mmorph library
19:56:38 <Tekmo> Thanks :)
19:56:44 <johnw> hoist can be much easier to use than control
19:56:55 <Tekmo> Yeah, but there are still disadvantages
19:56:57 <johnw> but since control has more flexibility, that's what I generally import these days
19:57:03 <Tekmo> I haven't found a satisfactory solution to the throw/catch problem
19:57:08 <johnw> have you looked into 'layers'?
19:57:14 <Tekmo> Yeah, but I'm not satisfied with that
19:57:21 <Tekmo> I want a catch that can change the type of the error value
19:57:38 <Tekmo> i.e.
19:57:38 <johnw> my co-worker, Snoyman, and I spent a few hours discussing monad-control, mmorph and layers, and we weren't totally satisfied by anything either
19:57:46 <Tekmo> Yeah
19:57:55 <Tekmo> I would really like something with the following pseudo-type
19:57:56 <johnw> we live in monad transformers, so this stuff is really important to us
19:58:23 <Tekmo> catch :: m { e := e1 } a -> (e1 -> m { e := e2 } a) -> m { e := e2 }
19:58:36 <Tekmo> But I have no idea how to express that in Haskell
19:59:02 <Tekmo> Oops, the last one should have an extra 'a' type parameter
19:59:09 <johnw> hmm
19:59:24 <Tekmo> Actually, you could even generalize it further
19:59:37 <Tekmo> 'catch' is *supposed* to be 'bind' for the error value
19:59:49 <Tekmo> So if you could generalize bind to lens on any value, then it would work, too
19:59:50 <Tekmo> i.e.:
20:00:09 <Tekmo> bind :: x { r := a } -> (a -> x { r := b }) -> x { r := b }
20:00:21 <Tekmo> Then you could use 'bind' for 'catch' just having 'r' point to the error value
20:00:35 <Tekmo> similarly:
20:00:36 <johnw> interesting
20:00:39 <yogert> ok thanks for the paste. It's all slowly getting pieced together. These paste few days I've taken on a project that was pretty far over my head and I've learned a ton in the process.
20:00:41 <Tekmo> return :: a -> x { r := a }
20:00:54 <Tekmo> And 'throw' would be 'return' pointing to the error type parameter
20:01:12 <johnw> is your := a kind of functional dependency?
20:01:23 <Tekmo> I don't know how to implement (:=)
20:01:27 <yogert> another quick question. : ) How can I derive the Read class then? Wouldn't that involve somehow parsing an input?
20:01:30 <Tekmo> But it's supposed to be like a 'lens' into the type
20:01:37 <johnw> yogert: deriving Read, I believe
20:01:38 <Tekmo> Where you specify which type parameter you are referring to
20:01:50 <johnw> Tekmo: an indexed lens?
20:02:02 <Tekmo> More like a "lens into the type"
20:02:10 <Tekmo> in other words a lens that points to which type variable you want to modify
20:02:19 <johnw> so, if I have f a b, you mean a lens that can focus on either the a or the b?
20:02:22 <Tekmo> Right
20:02:32 <yogert> johnw: well yeah… I understand that I can derive read. I just don't understand how it actually works though
20:02:35 <johnw> yeah, I'm not sure how to express that in Haskell either
20:02:42 <Tekmo> Yeah, I don't think there is a way
20:02:52 <johnw> yogert: all types are composites of more basic types
20:03:04 <Singingboyo> yogert: when you derive Read, it just does the reverse of Show.  Show converts from data to String, Read takes a string of Show's output format, and converts it to a type
20:03:14 <Tekmo> I think that paper by Sam Lindley was getting pretty close to a good idea, though
20:03:22 <Tekmo> Do you know the paper I'm referring to?
20:03:24 <johnw> until you get to the truly fundamental, machine-represented types.  so any data structure can be "shown" or "read", if it can render down to those types.  This doesn't work for function types, though
20:03:30 <johnw> Tekmo: no
20:03:39 <Tekmo> http://homepages.inf.ed.ac.uk/slindley/papers/handlers-draft-march2013.pdf
20:03:55 <Tekmo> It looked really promising
20:04:03 <Tekmo> The only effect system I've seen that implemented pipes
20:04:52 <yogert> Singingboyo: okay, so If I implement show for some instance myself will read perform the "reverse" of what I specified then?
20:05:19 <Tekmo> yogert: If you derive both Show and Read, yes
20:05:19 <yogert> er
20:05:19 <byorgey> http://www.cis.upenn.edu/~byorgey/hosted/Delaunay2.pdf
20:05:31 <byorgey> oops, wrong window, though I guess people here may enjoy it too =)
20:05:43 <Tekmo> yogert: If you implement them yourself, then it's up to you whether or not they are inverses (although they should be)
20:05:44 <carter> byorgey ooo, meshes
20:05:45 <byorgey> made with Haskell sauce
20:06:44 <byorgey> carter: just a Delaunay triangulation, with the amount of red and blue for each triangle determined by its average x and y coordinates
20:06:51 <carter> byorgey i know
20:07:08 <carter> i at some point need to do some mesh generation code
20:07:10 * DanBurton finally finished a blog post that has been in the pipeline for months
20:07:14 <johnw> Tekmo: are you coming to ICFP?
20:07:16 <carter> DanBurton oh?
20:07:18 <johnw> DanBurton: link link!
20:07:40 <DanBurton> carter, johnw: http://unknownparallel.wordpress.com/2013/05/07/two-implementations-of-seers/
20:07:49 <Tekmo> Tekmo: I'm going to the Haskell symposium, which I think is colocated with ICFP
20:07:52 <DanBurton> fair warning, 'tis a silly thing
20:07:58 <yogert> byorgey: where did you mean to post it?
20:08:04 <johnw> Tekmo: cool, I hope to see you there then
20:08:06 <carter> diagrams channel i think
20:08:10 <Tekmo> Tekmo: Yeah, let's meet up
20:08:12 <Tekmo> Oops
20:08:12 <johnw> Tekmo: I'm going to reserve my hotel room tomorrow
20:08:28 <mux> where's ICFP taking place this year ?
20:08:31 <johnw> Boston
20:08:49 <johnw> http://icfpconference.org/icfp2013/
20:08:50 <DanBurton> oh, shout out to byorgey, still loving BlogLiterately and the new profile feature
20:08:50 <carter> yesss
20:09:15 <byorgey> yogert: yeah, #diagrams
20:09:28 <byorgey> DanBurton: =D
20:09:39 <carter> does it work with blogger?
20:10:00 <byorgey> carter: I think so, in theory it works with any platform that supports the MetaWebLog API
20:10:12 <byorgey> carter: though I don't know of anyone specifically using it with blogger
20:10:18 <Tekmo> I can be the first!
20:10:19 <byorgey> carter: if you try and it doesn't work, let me know
20:10:24 <Tekmo> I will give it a try
20:10:28 <byorgey> excellent
20:10:30 <carter> byorgey first i need to get around to resuming blogging
20:10:44 <byorgey> carter: you have that backwards.
20:10:45 <johnw> Tekmo: I created ##icfp so we can all keep in touch during the conference
20:10:53 <Tekmo> Nice
20:10:54 <byorgey> carter: the way you get around to resuming blogging is to write a blog post.
20:10:57 <mux> johnw: thnaks
20:11:00 <carter> byorgey yes
20:11:07 <Tekmo> Speaking of which
20:11:12 <Tekmo> I need to buy a decent laptop
20:11:22 <Tekmo> Can you guys recommend a good model?
20:11:24 <johnw> byorgey: or have a beeminder sting you
20:11:30 <johnw> Tekmo: I'm partial to Macs, I'm afraid
20:11:35 <Tekmo> Arg!
20:11:43 <Tekmo> I unpartial to macs
20:11:43 <DanBurton> I also owe it to byorgey for the fact that I wrote a blog post today, 'twas from he that I learned of beeminder which threatened to sting me today
20:11:46 <Tekmo> *I'm
20:11:52 <johnw> i was able to convince chrisdone to get one, and now he runs Ubuntu on it :)
20:12:28 <Tekmo> I wouldn't mind Apple if they weren't so rich
20:12:30 * byorgey is thrilled to contribute to greater dissemination of ideas!
20:12:36 <Tekmo> I just don't like companies getting very large
20:12:41 <DanBurton> Tekmo: "a decent laptop" for what purpose? My coworker convinced my employer to get him an Alienware laptop
20:13:05 <DanBurton> aimed at gamers, but it's good specs for a decent price, I think
20:13:14 <Tekmo> Two things: it needs to have decent build quailty and it needs to not strain my hands when typing
20:13:27 <Tekmo> I don't care about performance
20:13:34 <Tekmo> Up until now I've been using netbooks
20:13:53 <Tekmo> But they are hell on my wrists
20:14:50 <mux> yeah, Apple notebooks are very nice, but they're so expensive you cannot help but feel ass-raped when buying one
20:15:04 <mux> I only have one because $company bought it for me
20:15:06 <arkeet> the solution is to never get one with your own money.
20:15:09 <arkeet> haha
20:15:12 <mux> indeed. :)
20:15:12 <Tekmo> Haha
20:15:37 <Nafai> Tekmo: I'm partial to Thinkpads
20:15:38 <Tekmo> It reminds me of when I first joined UPenn
20:15:47 <Tekmo> Yeah, I've been thinking about ThinkPad
20:15:50 * arkeet thinkpad x230
20:15:58 <Tekmo> My program gave you $1500 towards a computer of your choice
20:16:12 <Tekmo> A lot of people would spend $500 extra to get a macbook
20:16:17 <Tekmo> I got a netbook and a high-end desktop
20:17:30 <Tekmo> Who here is going to be at BayHac?
20:17:41 <mux> are there "pc" laptops with high-resolution panels similar to the ones in the new macbook pro retina?
20:17:51 <mux> I must say, they're really comfortable
20:19:45 <johnw> Tekmo: I wish I could come to BayHac; are you coming to LambdaJam?
20:19:52 <mux> 1920x1200 on a 15" laptop - to think my 24" LCD has the same resolution...
20:19:58 <cmccann> clearly you should both go to hac phi.
20:19:59 <Tekmo> Where is LambdaJam?
20:20:01 <cmccann> problem solved.
20:20:03 <johnw> Chicago
20:20:04 <johnw> in July
20:20:09 * hackagebot highlighting-kate 0.5.3.9 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.3.9 (JohnMacFarlane)
20:20:13 <johnw> so far as I know that edwardk will be there
20:20:23 <johnw> ok, just reserved my ICFP room, yay
20:20:27 <Tekmo> Well, I'm in the bay area, so it's easier for me to attend BayHac
20:22:43 <edwardk> if i'm not i think they'll want their money back for the flight at least
20:23:49 <johnw> edwardk: wow, flying to Boston is really cheap
20:23:58 <johnw> is costs the same just to sleep there one night!
20:24:46 <edwardk> johnw: that reminds me i should get back to seeing if we can set up a hackathon for icfp this year
20:25:25 <johnw> yes, I bet you I could finish my commodities library within that time
20:25:30 <Nisstyre-laptop> so apparently Carmack is using RWH, not sure how useful that will be tbh
20:25:54 <johnw> Nisstyre-laptop: if he's as smart as the Internet thinks, I'm sure he'll move on to the more useful avenues soon enough
20:26:06 <johnw> if we never see him here, we'll know he's not completely serious :)
20:26:13 <Nisstyre-laptop> good point
20:26:59 <Tekmo> If he hits codereview.stackexchange.com for Haskell help, then we'll know he's really not serious
20:29:01 <gaze__> hey guys. Who has experience with GHC.Generic?
20:31:31 <Tekmo> So is Real World Haskell 2.0 ever going to happen?
20:32:35 <Ankhers> @source lcm
20:32:35 <gaze__> why should I get an error of "No instance for (Xyz Abc)" calling "encode :: (Generic a, GEncode (Rep a)) => a -> String" on a thing?
20:32:36 <lambdabot> lcm not available
20:33:38 <arkeet> @src lcm
20:33:38 <lambdabot> lcm _ 0     =  0
20:33:38 <lambdabot> lcm 0 _     =  0
20:33:38 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
20:34:07 <gaze__> ah I'm an idiot I forgot to derive the instance
20:35:21 <ski> Tekmo : hm, your `{ e := e1 }' reminds me of rows ..
20:35:31 <Tekmo> What do you mean?
20:35:54 <ski> @tell DanBurton (re seers) reminds me somewhat of "Devils and Angels" by Lennart Augustsson (augustss) at <http://web.archive.org/web/20100214103957/http://www.cs.chalmers.se/~augustss/AFP/problems/devils-n-angels/>, based on "Programming with Continuations" by Daniel P. Friedman,Christopher T. Haynes,Eugene Kohlbecker in 1983-11 at <http://www.cs.indiana.edu/pub/techreports/TR151.pdf>
20:35:54 <lambdabot> Consider it noted.
20:37:05 <ski> lpsmith : did you ever write anything up on angel-devil-milestone as mentioned at the end of <http://blog.melding-monads.com/2010/08/25/fun-with-the-lazy-state-monad-part-2/> ?
20:37:41 <ski> Tekmo : `e' would be a label, and `e1' the associated type
20:39:04 <Tekmo> I mean "What do you mean by `rows'?"
20:39:46 <Tekmo> Also, even if you use a label system, you still have the inference problem
20:39:47 <shachaf> @google row polymorphism
20:39:49 <lambdabot> http://www.cs.cmu.edu/~aldrich/courses/819/slides/rows.pdf
20:39:55 <Tekmo> The compiler wouldn't know which instance to select
20:40:12 <Tekmo> For example, using my proposed idea, Either would have two independent Monad instances, one for each type variable
20:40:30 <ski> "row" as in "row polymorphism" as in the light-weight and extensible record system Trex in Hugs <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#trex>, and the light-weight and extensible variant system "polymorphic records" in OCaml <http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual006.html#toc36>
20:41:42 <ski> er .. s/polymorphic records/polymorphic variants/
20:43:28 <augur> hey ski
20:44:04 * augur completely doesnt have anything to talk about 
20:44:31 * ski . o O ( `bindCatchError :: MonadError e m => m a -> (a -> m b) -> (e -> m b) -> m b' )
20:44:53 <Tekmo> I'm not happy with that solution
20:45:17 <Tekmo> What if my type is a monad over three separate type variables?
20:45:25 <Tekmo> This isn't hypothetical: this is the case for pipes.
20:45:27 <johnw> augur: regale us with some story of yesteryear
20:45:58 <augur> johnw: well so stuff happened last year
20:45:59 <augur> the end
20:46:09 <johnw> hmm.. I think we need to discuss the meaning of regale next
20:46:18 <Tekmo> regale means regale
20:46:33 <johnw> @wn regale
20:46:34 <lambdabot> *** "regale" wn "WordNet (r) 3.0 (2006)"
20:46:35 <lambdabot> regale
20:46:35 <lambdabot>     v 1: provide with choice or abundant food or drink; "Don't worry
20:46:35 <lambdabot>          about the expensive wine--I'm treating"; "She treated her
20:46:35 <lambdabot>          houseguests with good food every night" [syn: {regale},
20:46:36 <lambdabot>          {treat}]
20:47:26 <ski> augur : ILP system Progol, using Inverse Entailment and general-to-specific search on refinement graph, by Stephen Muggleton at <http://www.doc.ic.ac.uk/~shm/progol.html>,"An Introduction to Progol" by Sam Roberts in 1997-01-21 at <http://dottorato.di.uniba.it/dottoratoXXVI/dm/Progol.pdf>
20:47:41 <augur> ski: o hai
20:47:53 <augur> ive temporarily paused the ILP stuff for now
20:48:00 <blaenk> hey guys I'm going through the .cabal file documentation and I can't figure this out, basically I want cabal install to automatically put the binary into the current directory (same directory with the cabal file), is this possible to configure from the .cabal file?
20:48:04 <augur> trying to figure out more foundational issues
20:48:25 <blaenk> or actually maybe I don't want cabal to do that
20:48:35 <blaenk> since I imagine that'd register the package and I don't want that heh
20:49:04 <ski> Tekmo : well, the "Exceptional Syntax" paper is more about replacing the traditional `catch'/`handle' primitive with a nicer one ..
20:49:37 <ski> augur : i was thinking you might perhaps be interested in those. i don't know very much about them
20:50:01 <Tekmo> Even if you do it that way
20:50:05 <augur> i give them a look
20:50:11 <Tekmo> ski: Why do you need to combine the two binds into a single step?
20:50:12 <blaenk> basically I'm creating a cabal file for my hakyll-powered site. I like how cabal creates a dist/ directory where it dumps the intermediary object files, however, I'd like to move/copy the resulting binary into the top level directory (containing the .cabal file), is there a way to do this using cabal? or should I just use a shell script?
20:50:23 <Tekmo> ski: Why not just have the class provide return/bind/throw/catch?
20:50:33 <augur> wheres exceptional syntax? :o
20:50:43 <ski> Tekmo : iow, `bindCatchError' wasn't intended directly as addressing your problem -- just somewhat related, perhaps
20:52:23 <blaenk> oh I think I can use cabal configure's --bindir parameter
20:52:59 <ski> <ski> see <http://mjambon.com/extend-ocaml-syntax.html#lettry> for an example of extending the syntax with Camlp5 (see "Exceptional Syntax" by Nick Benton,Andrew Kennedy in 2001-07 at <http://research.microsoft.com/en-us/um/people/akenn/sml/ExceptionalSyntax.pdf> for why this construct is useful)
20:53:23 <ski> <ski> (and also threads "Exceptions considered harmful" <http://caml.inria.fr/pub/ml-archives/caml-list/2004/07/e14417c385cbb06161846b027bf2d48e.en.html>,"Checking for eof" <http://caml.inria.fr/pub/ml-archives/caml-list/2004/12/c176307e0c46ae73fccab7992930d6ff.en.html>,<http://caml.inria.fr/pub/ml-archives/caml-list/2004/12/b5b79fcd4ea695b8e1e0aff740b07cf3.en.html> in 2004 might be interesting)
20:53:36 <ski> <ski> conceptually (in Haskell phrasing), it replaces a primitive construct `catch :: Exception e => IO a -> (e -> IO a) -> IO a' by `catchBind :: Exception e => IO a -> (e -> IO b) -> (a -> IO b) -> IO b'
20:53:46 <ski> <ski> it is easier to algebraically manipulate (and state laws for) `catchBind' as opposed to `catch'
20:53:59 <ski> Tekmo,augur ^
20:55:13 <Tekmo> Why?
20:55:33 <ski> why what ?
20:55:38 <Tekmo> Why is it easier?
20:56:08 <ski> it is easier to express what one want, when programming with exceptions, using this construct
20:56:22 <Tekmo> There is still another issue
20:56:37 <Tekmo> It does not fully capture the fact that catch and throw should form a monad
20:56:59 <Tekmo> There's no exception type variable to form a monad over
20:57:15 <ski> consider a loop, where we want to catch some exception in the body, and if so, do something else (perhaps aborting the loop, perhaps doing something else before continuing the loop)
20:57:26 <augur> "consider a loop"
20:57:30 * augur looks at a rubberband
20:57:40 <latro`a> iteration is homotopic to a circle
20:57:58 <ski> we don't want to include the (tail-)recursive call inside the exception handler, since that would mean piling exception handler upon exception handler, uselessly
20:59:10 <Tekmo> What is wrong with including the tail-recurisve call inside the exception handler?
21:00:19 <ski> without this construct/primitive, one has to express oneself more clumsily, handling over something producing a `Maybe Foo', only to deconstruct the `Maybe' directly outside the handler -- or, alternatively, produce a `IO Foo' inside the handler (so we handle over `IO (IO Foo)'), only to execute the action directly outside (using `join' e.g.)
21:00:39 <Tekmo> What is wrong with this:
21:01:01 <Tekmo> loop = (doSomething >> loop) `catch` (\_ -> loop)
21:01:12 <ski> Tekmo : in typical implementations of exceptions, the body of an exception handler is *not* in a tail-position wrt the whole handle construct
21:01:31 <Tekmo> Ok, but if I implement exceptions using Either/EitherT, then they are in a tail-position
21:02:06 <ski> i don't think so
21:02:22 <Tekmo> `catch` for Either is symmetric to `(>>=)`
21:02:31 <Tekmo> If (>>=) is tail-recursive for Either, then so is `catch`
21:04:58 <ski> even if you use a `Codensity' (CPS) on it to avoid needless scrutiny of the intermediate results of the first argument of `(>>=)', `catchError' will still need to check whether the result is of shape `Left exn' before being able to continue
21:05:55 <Tekmo> Right, just like (>>=) needs to check whether the result is of shape `Right ret' before continuing
21:06:02 <Saizan> Tekmo: the first argument is not in tail position
21:07:22 <Tekmo> So if I understand correctly, the issue is that the compiler cannot compile the two separate "binds" into a single composite bind because neither one is in a tail position with respect to the other?
21:08:59 <ski> i suppose in the terminology of "Multi-return Function Call" by Olin Shivers,David Fisher in 2006 at <http://www.ccs.neu.edu/home/shivers/papers/mrlc-jfp.(p(df|s)|dvi)>, a hand-crafted `catchError' for a manually CPSed exception monad could call the body in "semi-tail-position" wrt the whole ..
21:09:36 <Tekmo> I'm going to test this out.  Give me a second
21:10:31 <ski> <Tekmo> `catch` for Either is symmetric to `(>>=)`  <Tekmo> If (>>=) is tail-recursive for Either, then so is `catch`  -- yes, and `(>>=)' for `Either e' isn't calling its first argument in tail position
21:10:51 <ski> (and neither does `catchError')
21:11:15 <shysoft> Anyone have recommendations for a relatively inexperienced haskell developer in finding a job working with the language?
21:12:12 <ski> Tekmo : i don't follow you with the "the compiler cannot compile the two separate \"binds\" into a single composite bind because neither one is in a tail position with respect to the other?"
21:12:30 <tikhonjelvis> shysoft: probably depends on your location
21:12:47 <tikhonjelvis> I'd suggest looking around to see if any startups using Haskell are located nearby and emailing them
21:13:13 <edwardk> shysoft: It's tough. There are a lot of experienced Haskell programmers out there who haven't figured out how to make that work. My advice is to keep working on becoming a more experienced Haskell developer, and release a bunch of software so people know you exist
21:13:15 <Tekmo> I'm just curious why the compiler cannot compile `catch` + `bind` into something with equivalent performance to `catchBind`
21:13:25 <edwardk> and then, in my personal experience the work comes to you ;)
21:13:57 <tikhonjelvis> it really helps to be in a tech hub
21:14:06 <ski> Tekmo : i'm not sure why you think `catch' or `bind' on their own would fare better than `catchBind' here ..
21:14:21 <Tekmo> That's why I'm testing it
21:14:31 <Tekmo> I want to see if they can at least perform just as well
21:14:35 <shysoft> "tech hub"?
21:14:42 <tikhonjelvis> like the Bay Area
21:14:42 <edwardk> and move to a big city, as tikhonjelvis noted. Boston, the bay area, New York, Singapore, various other places have big Haskell contingents too
21:14:48 <Tekmo> i.e. San Francisco, Boston, Seattle, New York
21:15:02 <tikhonjelvis> it helps if there's a good university or two around
21:15:11 <shysoft> I'm in OC, incidentally.
21:15:52 <Tekmo> Ok, you are right
21:15:58 <Tekmo> I confirmed that it does leak space
21:16:04 <Tekmo> Now I will try catchBind and see what happens
21:16:14 <tikhonjelvis> I can't speak for Haskell in particular, but I did manage to find an OCaml job last summer just from somebody I met at my university
21:16:31 <tikhonjelvis> ooh, another idea: post on one of the HN threads
21:16:32 <ski> Tekmo : iow, i'm not sure why you seem to think `catch' or `bind' for a plain `Either e' fares good (assuming no aggressive compiler optimizations/translations that "unboxes" the `Either' -- istr hearing about one or two that might do that, at least in simple enough cases)
21:16:38 <tikhonjelvis> they have one monthly
21:17:00 <tikhonjelvis> I met somebody who wanted to experiment with Haskell at his startup through one of those threads
21:17:00 <Tekmo> ski: I'd just prefer a simpler interface, and I consider catch + bind the more elegant interface
21:17:34 <Tekmo> ski: After all, the catchBind solution does not generalize to more than two continuations
21:18:04 <Tekmo> ski: If it's possible to compose multiple independent continuations, it's more general
21:19:06 <ski> Tekmo : but the main point of the "Exceptional syntax" idea is to be able to express, concisely, what you really meant to express (also afaiu, it's easier to reason and refactor with the new construct, it composes better)
21:19:37 <amatsu> Is there any way to extract the state from inside a stateful function and pass it to, say, an accumulator function in a fold, inside the function?
21:20:07 <ski> Tekmo : yes, perhaps there's a nicer way, getting closer to both sets of goals
21:20:44 <Tekmo> However, while catchBind solves the efficiency problem, it still doesn't solve the lack of a monad over the "left" type variable problem
21:21:03 * ski wonders what amatsu means by "stateful function"
21:21:04 <Tekmo> Because I'd like to use something like catchBind in a wide variety of types like 'Either', 'EitherT' and in 'EitherP' for pipes
21:21:09 <hpaste> amatsu pasted “Passing local State” at http://hpaste.org/87473
21:21:28 <Tekmo> I'd like `catchBind` to change the left type variable
21:21:28 <ski> Tekmo : anyway, for your problem, i think one either has to introduce a way to specify wrt which "type variable" (in your terminology) the (here monadic) operations is to be taken
21:21:54 <Tekmo> Right, but that's the problem: I don't know a way to specify the left type variable within Haskell's type class system, in such a way that you can modify the type variable
21:21:54 <amatsu> ski: I'm trying to pass the table from the function to another function, and have it update within the folding function.
21:22:00 <ski> Tekmo : or to introduce a way to "(change) focus" to a(nother) "type variable"
21:22:20 <Tekmo> Right, but then you get the problem of how to tell the compiler which left type variable you meant if there is more than one
21:22:46 <Tekmo> Even for a single left type variable, I'm still not sure how to implement it
21:24:02 * ski has a vague idea for how such a "focus switch" might occur
21:24:14 <Tekmo> Shoot
21:24:32 <ski> (but, at least in the form i'm thinking about it, would require new syntax, and additional inference rules in the type system)
21:25:36 <ski> Tekmo : anyway, you're familiar with `Codensity' ?
21:25:40 <Tekmo> Yes, very
21:26:42 <ski> @type modify  -- amatsu : perhaps you can use this ?
21:26:44 <lambdabot> MonadState s m => (s -> s) -> m ()
21:27:36 <ski> @type state  -- or this
21:27:39 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
21:28:26 <ski> @type foldl
21:28:28 <lambdabot> (a -> b -> a) -> a -> [b] -> a
21:28:54 <amatsu> ski: I'm not sure how I'd use those to make a foldable function.
21:28:58 <ski> hmm
21:30:33 <johnw> Tekmo: also, if you were designing your type lens, what about when f = (->), for some type f a b.  You can't "access" the codomain, although you can compose with it
21:30:49 <johnw> (i.e., profunctors)
21:31:50 <Tekmo> Well, the lens is just a way to refer to the type parameter
21:31:52 <ski> @type ((state . ((,) () .)) .) . flip . foldl . flip . (execState .)
21:31:54 <lambdabot> MonadState s m => (b -> State s a) -> [b] -> m ()
21:31:59 <Tekmo> It doesn't necessarily imply anything about what we can do to it
21:32:10 <ski> @type mapM_
21:32:12 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
21:32:49 <johnw> Tekmo: ah, I was wondering what "view" would mean
21:32:53 <amatsu> mapM_ for State maintains the state, right?
21:33:00 <ski> @type (runState .) . mapM . (state .)
21:33:02 <lambdabot> (a -> s -> (b, s)) -> [a] -> s -> ([b], s)
21:33:08 <ski> yep
21:33:09 <johnw> mapM_ = void . sequence . map
21:33:18 <johnw> so, yes, in as much as that's just what sequence does
21:33:34 <elliott> mapM_ is operationally very different from that RHS.
21:33:45 <johnw> how so?
21:33:49 <ski> @type (execState .) . mapM_ . ((state . ((,) () .)) .)
21:33:51 <lambdabot> (a -> s -> s) -> [a] -> s -> s
21:33:55 <johnw> ah, I do need more dots
21:34:07 <johnw> mapM_ f xs = void $ sequence $ map f xs
21:34:27 <johnw> @src mapM_
21:34:27 <lambdabot> mapM_ f as = sequence_ (map f as)
21:35:18 <ski> johnw : presumably `view' would just return the type in that "field"
21:35:20 <mmaruseacph2> I think it will be interesting to have the Carmack's updates in haskell weekly news
21:35:31 <johnw> ski: oh, he's talking about type-level lensing
21:35:32 <mmaruseacph2> https://twitter.com/ID_AA_Carmack/status/331918309916295168
21:35:40 * ski nods
21:35:47 <mmaruseacph2> he wants to port wolfenstein in haskell
21:35:47 <Tekmo> Yeah
21:35:52 <mmaruseacph2> things look interesting
21:36:52 <amatsu> ski: I'll see if I can get things working with mapM_, thanks!
21:37:38 <ski> mmaruseacph2 : already reported here by Nafai and chrisdotcode :)
21:37:45 <ski> (but you're welcome)
21:38:01 <ski> amatsu : yw
21:40:09 <mmaruseacph2> ski: ah, nice :D
21:52:29 <lpsmith> ski:  not really,  though I'd be happy to share my code if you'd like
21:52:40 <lpsmith> I can't say I've really looked at it since.
21:53:59 <ski> found that post when hunting down the angels and devils; haven't looked in detail at what you're doing in those two posts
21:54:28 <carter> woot, llvm-base will now build with cabal >= 1.17 and < 1.17
21:54:30 <carter> i am happy
21:54:45 <ski> perhaps that code could be interesting after understanding them
21:55:19 <lpsmith> perhaps,  lemme see if I can find it quick
21:56:24 <lpsmith> Oh crap, I hope I didn't lose it in a data loss accident :-/
21:56:39 <lpsmith> I didn't think I had lost that directory though
21:56:41 <lpsmith> I'm not sure
21:59:01 <lpsmith> ski, I may have lost the file :-(
21:59:15 <ski> sorry to hear
21:59:35 <lpsmith> I'll look for it some more later, and consider redoing it.    But I have other things to worry about atm.
21:59:50 <ski> np, no hurry
22:00:36 <ski> (but if you do anything more with it, i'd appreciate a reminder ;)
22:02:30 <lpsmith> well, I have a backup on a failed external harddisk I need to see if I can't get some data off of,  as it has a couple of things I'd like to rescue
22:02:49 <ski> (of course, you might not be much better than me to remember such things over longer periods of time)
22:02:51 <lpsmith> that failed *and* I accidentally deleted a directory all within a wek
22:03:05 <lpsmith> There's a decent chance I'll remember.
22:03:09 <ski> sounds like a bad week
22:03:15 <lpsmith> it was
22:04:07 * ski ought to try to get hold of a harddisk controller card/circuit to replace a burned one ..
22:40:05 <ryantanjunming> any one here uses adga2?
22:40:12 <ryantanjunming> im having issues installing it
22:40:44 <elliott> ryantanjunming: try #agda?
22:40:57 <ryantanjunming> kk.
22:41:01 <ryantanjunming> thxs
22:48:16 <ryantanjunming> elliott: im not getting a responds there in #agda..
22:48:58 <elliott> well, it's where the agda users are :P but if it's a cabal-related issue or such then we may be able to help
22:49:40 <ryantanjunming> its a aqaumacs "not compiling" issue.. gives me a ghci issue
23:06:30 <hpaste> “Dharmender Kumar” pasted “Medical Health Care Clothing Service” at http://hpaste.org/87474
23:18:28 <adnap> How do I produce a ctags file using GHC for a set of Haskell source files in a directory structure?
23:19:09 <tikhonjelvis> well, you can use :ctags in GHCi
23:19:22 <tikhonjelvis> also :etags, if that's more your thing
23:19:47 <shachaf> I use `hasktags`.
23:20:01 <tikhonjelvis> if you want to do it in a script, you can echo stuff to ghci
23:20:05 <tikhonjelvis> or use hasktags, which is probably better :P
23:26:31 <iross> preflex: karma brett
23:26:31 <preflex>  brett has no karma
23:26:39 <iross> preflex: karma rmunroe
23:26:39 <preflex>  rmunroe has no karma
23:32:47 <ski> @karma iross
23:32:47 <lambdabot> iross has a karma of 0
23:41:35 <chrisdotcode> hey guys, I just downloaded gloss-examples with cabal. how do I run/find the downloaded examples?
23:44:56 <td123> chrisdotcode: ~/.cabal
23:53:15 <chrisdotcode> td123: thanks :)
23:54:08 <pete_> I had a weird-ass nightmare last night where I had been given a business plan full of partial application and parentheses
23:56:51 <zRecursive> pete_: that's Common Lisp ?
23:57:28 <quchen> pete_: A Haskell business plan would've had $ instead of parentheses.
23:58:41 <pete_> I managed to complete (and ace, fwiw) a whole Haskell module at uni without knowing about $
23:59:08 <Shaladdle> what uni has haskell
23:59:31 <pete_> http://www.cs.ox.ac.uk/softeng/subjects/FPR.html
