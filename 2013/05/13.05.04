00:00:53 <diracdelta> confused about the category Hask. How can I have two different functions, say, from String->String?
00:00:54 <NihilistDandy> Is there a minimal definition of a Num instance? I expect you could get away with just fromInteger
00:01:16 <NihilistDandy> Er, no, perhaps not
00:01:28 <shachaf> diracdelta: I'm not sure I understand the question.
00:01:37 <shachaf> NihilistDandy: No, you need more than that.
00:01:44 <shachaf> The Report specifies what, I think.
00:01:46 * BMeph likes his types comfortably Num
00:01:53 <NihilistDandy> I'll look it up
00:01:55 <dsturnbull> heh
00:03:08 <NihilistDandy> shachaf: Apparently the minimal definition is everything but negate or (-)
00:03:15 <shachaf> Sounds right.
00:03:16 <diracdelta> shachaf: So, if types are objects in the category hask, than string is an object, and "id" makes an arrow from String to itself. Suppose I define the function f x = "a"++x, then I have a function from string -> string which is not id. This seems to violate the category rules.
00:03:34 <arkeet> diracdelta: what category rules?
00:03:35 * hackagebot robot 1.0.1 - Simulate keyboard and mouse events  http://hackage.haskell.org/package/robot-1.0.1 (ChrisWong)
00:03:46 <arkeet> there is no rule that says everything from an object to itself is id.
00:03:57 <shachaf> diracdelta: No, there's another arrow from String to itself.
00:04:03 <shachaf> Each function is an arrow.
00:04:31 <NihilistDandy> Each function up to isomorphism, I would think
00:04:40 <arkeet> the axioms just say that one of the arrows is id.
00:04:42 <arkeet> there may be others.
00:04:56 <shachaf> NihilistDandy: What does "isomorphism" mean here?
00:05:37 <NihilistDandy> Actually, I suppose at this level there's only one way to define any particular function, so that's a meaningless distinction
00:05:39 <NihilistDandy> Fair point
00:06:20 <arkeet> I wonder if one can make Hask an honest thing by weakening the category axioms a bit. given the fact that we have some domain structure on the hom-sets.
00:06:28 <diracdelta> right, found error. Thought there was a third category law. Thanks.
00:06:40 <arkeet> like instead of requiring f = f . id, we can require f ≤ f . id
00:06:52 <shachaf> arkeet: What if you just use strict composition?
00:07:02 <arkeet> I don't like strict composition.
00:07:47 <shachaf> But it satisfies the axioms?
00:07:57 <arkeet> but I don't like it.
00:08:20 <arkeet> do you use strict composition in practice?
00:08:25 <shachaf> Yes.
00:08:33 <arkeet> but not most of the time.
00:08:40 <shachaf> http://hackage.haskell.org/trac/ghc/ticket/7542
00:08:49 <shachaf> Oh, I should really reply to SPJ there. :-(
00:09:04 <shachaf> His proposed solution doesn't help us at all. I should mention that.
00:11:28 <arkeet> anyway, my point is that we should have something that actually models what we have with id and (.)
00:11:46 <arkeet> er, the opposite of models.
00:12:02 <NihilistDandy> Instantiates?
00:12:11 <arkeet> no.
00:12:11 <NihilistDandy> Implements?
00:12:14 <arkeet> is modelled by. abstracts.
00:12:23 <NihilistDandy> Oh. flip model
00:12:24 <shachaf> "is modeled by"
00:13:39 <arkeet> I think it could probably be made to work nicely enough.
00:14:30 <arkeet> viewing domains as categories, we're just requiring the existence of a morphism f -> f . id, and not an isomorphism.
00:17:25 <arkeet> the term "lax bicategory" sounds relevant.
00:18:26 <shachaf> copumpkin is an expert in lax bicategories.
00:18:51 <arkeet> is that so?
00:23:35 * hackagebot pipes-network 0.2.0.0 - Use network sockets together with the pipes library.  http://hackage.haskell.org/package/pipes-network-0.2.0.0 (RenzoCarbonara)
00:25:06 <NihilistDandy> Neat
00:53:28 <hpaste> “Dharmender Kumar” pasted “Tips To Follow While Buying Your Nursing Scrubs” at http://hpaste.org/87228
01:00:51 <flimbar> @undo do { let w = words l; putStrLn . unwords . tail $ w; return . head $ w }
01:00:51 <lambdabot>  Parse error at ";" (column 52)
01:01:47 <flimbar> @undo do l <- let w = words l ; putStrLn . unwords . tail $ w ; return . head $ w
01:01:48 <lambdabot>  Parse error at ";" (column 57)
01:02:17 <flimbar> @undo do l <- let w = words l
01:02:17 <lambdabot>  Parse error at end of input
01:02:41 <flimbar> @undo do x <- [3..4] ; [1..2] ; return (x, 42)
01:02:42 <lambdabot> [3 .. 4] >>= \ x -> [1 .. 2] >> return (x, 42)
01:03:41 <flimbar> @undo do l <- let w = words l ; return w
01:03:42 <lambdabot>  Parse error at end of input
01:03:49 <flimbar> @undo do l <- let w = words l ; return (w)
01:03:50 <lambdabot>  Parse error at end of input
01:04:23 <flimbar> @undo do let w = words l ; putStrLn l
01:04:24 <lambdabot>  Parse error at end of input
01:04:34 <flimbar> @undo do { let w = words l ; putStrLn l }
01:04:35 <lambdabot>  Parse error at "}" (column 35)
01:05:04 <flimbar> @undo do l <-  w = words l ; return (w)
01:05:05 <lambdabot>  Parse error at "=" (column 12)
01:05:17 <flimbar> @undo do l <-  let w = words l ; return (w)
01:05:18 <lambdabot>  Parse error at end of input
01:05:25 <flimbar> @undo do l <-  let w = words l
01:05:25 <lambdabot>  Parse error at end of input
01:05:37 <djcoin> @undo do let w = words l; return (w)
01:05:37 <lambdabot>  Parse error at end of input
01:10:36 <djcoin> @undo do w <- words l ; return (w)
01:10:37 <lambdabot> words l >>= \ w -> return (w)
01:12:28 <Darkproger> is it possible to use cabal/cabal-dev  to build a package with a custom ghc without rebuilding the whole dependency tree?
01:12:53 <Darkproger> if i install the deps with stock ghc 7.6.3 and use the custom ghc to build the rest i get this: https://gist.github.com/proger/a0a78d9b9c37ad31e47d
01:13:45 <NihilistDandy> I don't think it's possible, no
01:14:39 <Darkproger> wow that's tough
01:17:21 <NihilistDandy> I could be wrong, but that's what I remember about it
01:17:44 <NihilistDandy> I think it has to do with how ghc-pkg registers packages
01:30:22 <wole> @hoogle IO a -> a
01:30:22 <lambdabot> Foreign.Marshal unsafeLocalState :: IO a -> a
01:30:23 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
01:30:23 <lambdabot> Foreign unsafePerformIO :: IO a -> a
01:38:44 * hackagebot Workflow 0.8.0.2 - Workflow patterns and a monad for thread state logging & recovery  http://hackage.haskell.org/package/Workflow-0.8.0.2 (AlbertoCorona)
01:42:39 <Watabou> oh boy, the pattern matching chapter of learn you a haskell has me confused already. time to take a break.
01:44:48 <NihilistDandy> If you have any questions, there are plenty of people here who are happy to help :)
02:03:31 <pete_> What can I google for to find out more about what the type signature *->* means?
02:04:29 <ion> That’s a kind signature.
02:05:03 <ion> Maybe is a type-level function that takes a single type parameter. Maybe :: * -> *; Maybe Integer :: *
02:05:45 <hamid> I don( Eq a, Ord a, ... )
02:06:14 * pete_ googles "kind signature"
02:06:52 <hamid> I don't get why ( Eq a, Ord a, ... ) ? why not something like  Num ( Eq ( a) ) or whatever ?
02:07:02 <hamid> is there a reason behind this?
02:07:27 <pete_> hamid: I don't understand what question you're asking
02:07:37 <Kinnison> because Num (Eq a) implies that you want an instance of Num which is for Eq a
02:07:38 <mm_freak> pete_: "*" just means "concrete type"
02:07:52 <mm_freak> pete_: Maybe takes a type as argument, so it's a function of types:  Maybe :: * -> *
02:07:52 <Kinnison> where Num a, Eq a implies you want a to be numeric and comparable for equality
02:08:22 <pete_> mm_freak: That sounds pretty simple
02:08:29 <mm_freak> hamid: that's a kind error
02:08:43 <mm_freak> hamid: Num :: * -> Constraint
02:08:47 <mm_freak> Eq a :: Constraint
02:08:54 <mm_freak> kind error:  Constraint /= *
02:09:10 <hamid> pete_, we should write  "Ord a, Eq a" i meant repeating "a" again and again. why not somthing like this "Ord( Eq a )" ?
02:09:15 <NihilistDandy> Aren't all the Num types instances of Eq, anyway?
02:09:33 <mm_freak> NihilistDandy: no
02:09:41 <mm_freak> hamid: simply because it's wrong =)
02:10:05 <hamid> mm_freak, yeah i know that but is there an alternative to that?
02:10:30 <mm_freak> hamid: you can use a constraint synonym, but i'd consider that bad practice
02:10:43 <mm_freak> type NumEq a = (Num a, Eq a)
02:11:21 <hamid> mm_freak, hmm i see ok then
02:11:26 <ion> hamid: So, switch from repeating a to an even larger number of extra parentheses? :-P
02:11:30 <NihilistDandy> What's an example of an instance of Num that isn't an instance of Eq?
02:11:50 <mm_freak> NihilistDandy: instance (Num a) => Num (a -> a)
02:11:58 <hamid> ion, haha yeah and that :P
02:12:11 <NihilistDandy> Ah, fair enough
02:12:34 <mm_freak> you can probably be more general
02:12:46 <mm_freak> instance (Applicative f, Num a) => Num (f a)
02:12:51 <mm_freak> (don't write that instance)
02:12:53 <ion> CReal’s Eq is a bit nasty.
02:13:43 <mm_freak> so yeah, this is a valid instance:  instance (Num a) => Num (e -> a)
02:14:24 <mm_freak> even this:  instance (Num a) => Num (IO a)
02:15:22 <NihilistDandy> I suppose that's true. I guess it would have been more useful to say "Are there any sanely defined instances of Num that are not instances of Eq" :D
02:15:36 <mm_freak> NihilistDandy: i just gave you examples of that
02:16:06 <mm_freak> for all applicative functors f you can write a well-defined Num instance for (Num a) => f a
02:16:22 <mm_freak> examples include ((->) e), IO, STM, ST s, …
02:17:05 <NihilistDandy> I suppose I'll have to try writing a few of those to get a feel for it, then
02:17:26 <mm_freak> NihilistDandy: do it…  if you do it properly all instance definitions are identical =)
02:17:29 <mauke> they're all the same
02:19:16 <NihilistDandy> Well, that'll save me some time, then, won't it :D
02:21:16 <bubhubu> Hi
02:21:58 <bubhubu> I'm wondering can I define a type that is a list of a fixed length?
02:22:15 <mauke> a tuple?
02:24:36 <bubhubu> umm, yeah, but I'd want the fixed length to be determined at runtime
02:24:51 <NihilistDandy> Then it's not fixed, is it?
02:25:41 <mm_freak> bubhubu: you want static length guarantees for a variable length vector?
02:36:44 <socumbersome> Hi. Where can I find an implementation of (++) function?
02:37:04 <shachaf> You can find an implementation in the Haskell Report.
02:37:10 <shachaf> @where report
02:37:11 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
02:37:26 <shachaf> The implementation that GHC uses is probably different; you can find that in the relevant source file.
02:37:28 <pete_> A "concrete type" is a type that has been specialized, and isn't waiting on any further parameters to be specialized, right?
02:37:39 <mr-> ?src (++)
02:37:40 <lambdabot> []     ++ ys = ys
02:37:40 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
02:37:40 <lambdabot> -- OR
02:37:40 <lambdabot> xs ++ ys = foldr (:) ys xs
02:38:14 <djcoin> Is there some kind of ghc optimization for monad, stacks of monad transformers etc. ?
02:38:29 <socumbersome> Ok, thanks!
02:38:39 <shachaf> pete_: Hmm, maybe.
02:38:42 * hackagebot MFlow 0.2.0.8 - continuation-based Web framework without continuations.  http://hackage.haskell.org/package/MFlow-0.2.0.8 (AlbertoCorona)
02:38:43 <shachaf> What does specialized mean?
02:38:50 <shachaf> Is a rank-2 type concrete?
02:39:00 <pete_> I am looking for a definitino that's correct, and that I currently understand, that can go in my flashcard system :-P
02:39:31 <shachaf> Definitions are overrated.
02:39:44 <pete_> flashcards are not, however
02:39:45 <shachaf> There's no such thing as a correct definition, only an accepted one. And that only sometimes.
02:40:09 <shachaf> I don't know whether flashcards are an overrated tool for memorization. Memorization itself is overrated, however.
02:40:35 <arbn> 05:39 -!- cdidd [~cdidd@176.14.216.52] has quit [Read error: Connection reset by peer]
02:40:39 <arbn> Oops.
02:40:41 <arbn> My apologies.
02:40:55 <pete_> I have found combining lots of practice with memorization a good way to pick up technical subjects
02:41:23 <arbn> pete_: I just look things up as I need them. If I need them often enough, I end up remembering them.
02:42:12 <pete_> These days I do too little programming for things not to fade away after a while
02:43:10 <arbn> pete_: Do more programming!
02:43:29 <pete_> I would be doing my job less well if I did more programming
02:44:26 <pete_> Luckily I'm studying for a degree that lets me program a fair amount
02:44:41 <pete_> And my wife is away this weekend, so I am working through the Matasano crypto challenges in Haskell
02:44:41 <shachaf> But more well if you did more memorization of definitions of terms like "concrete type"?
02:45:30 <pete_> shachaf: No, that's what helps me keep a lot of rarely-used programming knowledge at my finger tips for when I dig back in
02:48:21 <bubhubu> @mm_freak and @NihilistDaddy thanks for your answers, but no, I was actually thinking can Haskell help me express the fact that my function will double the input list's length
02:48:21 <lambdabot> Unknown command, try @list
02:49:03 <bubhubu> for example: palindrom :: [a] of length l -> [a] of length l * 2
02:50:17 <NihilistDandy> bubhubu: You'd need dependent types for that
02:50:42 <bubhubu> Ah, I think I heard the term "dependent types" before
02:50:43 <shachaf> Well, net necessarily dependent types.
02:50:52 <shachaf> not
02:50:58 <bubhubu> let me google about it
02:51:13 <bubhubu> @shachaf, how is it so?
02:51:14 <lambdabot> Unknown command, try @list
02:51:49 <bubhubu> are there any alternatives besides dependent type to express my intentions?
02:52:21 <NihilistDandy> You can express it in Haskell's type system, I think it's just harder
02:52:42 <NihilistDandy> At least I think you can
02:53:24 <Okasu> bubhubu: http://www.lambdassociates.org/studies/study01.htm
02:53:58 <tdammers> you can definitely express list-like objects of a fixed size in Haskell's type system
02:54:17 <Okasu> It's predecessor of http://www.shenlanguage.org/.
02:54:18 <tdammers> tuples, obviously, or a data type with one constructor that takes n arguments
02:54:43 <tdammers> I have no clue how one would generalize that to arbitrary list lengths though
02:55:11 <shachaf> Okasu: That's a silly claim. Turing completeness is not the point.
02:55:21 <Okasu> tdammers: No, it's not fixed, it's depends on length of [a] of length l.
02:55:39 <shachaf> Yes, you can make a thing like that.
02:55:46 <tdammers> Okasu: I know. That's where the problem lies. But maybe someone more knowledgable can answer.
02:56:15 <tdammers> shachaf: how?
02:56:47 <shachaf> For example, with GADTs and DataKinds: data Nat = Z | S Nat; data List :: Nat -> * -> * where { Nil :: List Z a; Cons :: a -> List n a -> List (S n) a }
02:57:20 <bubhubu> interesting links about "Qi" and "Shen"
02:57:50 <tdammers> ah. interesting.
02:58:16 <bubhubu> but I think I'll take a look at dependent types first
02:58:40 <shachaf> So the type of Cons 'a' (Cons 'b' Nil) is List (S (S Z)) Char
03:00:03 <hpaste> supki pasted “double list length” at http://hpaste.org/87231
03:00:19 <supki> is it possible to do without TF?
03:00:41 <shachaf> Now, let's say with TypeFamilies, you can say: type family Twice (n :: Nat) :: Nat; type instance Twice Z = Z; type instance Twice (S n) = S (S (Twice n))
03:00:46 <shachaf> foo :: List n a -> List (Twice n) a; foo Nil = Nil; foo (Cons x xs) = Cons x (Cons x (foo xs))
03:01:04 <NihilistDandy> Ah, TypeFamilies
03:01:08 <shachaf> Now foo's type guarantees: It takes a list of length n and returns a list of length 2n.
03:01:17 <shachaf> Well, you can do it without TypeFamilies too.
03:02:15 <shachaf> (The joke's on us, by the way: foo's type guarantees nothing because this is Haskell.)
03:02:33 <bubhubu> Cool, I think TypeFamilies is something my brain can fit into
03:02:41 <Okasu> shachaf: Can you do it without ghc specific extensions?
03:02:54 <shachaf> I think yes.
03:03:02 <shachaf> But you can't really do it without extensions at all. :-)
03:03:15 <bubhubu> @shachaf, what do you mean by "foo's type guarantees nothing"
03:03:16 <lambdabot> Unknown command, try @list
03:03:19 <shachaf> Well, maybe you can do something...
03:03:25 <NihilistDandy> Haskell98 or nothing, geez :D
03:03:27 <shachaf> bubhubu: Because it might be undefined, say.
03:03:47 <shachaf> NihilistDandy: Just Haskell98 or Nothing
03:04:04 <bubhubu> do you mean it's still possible for foo to return a list with length that's not exactly twice that of its input?
03:04:19 <Okasu> @faq
03:04:20 <lambdabot> The answer is: Yes! Haskell can do that.
03:04:30 <shachaf> I mean that it's possible for foo to not return at all.
03:05:08 <bubhubu> Ah, got it thanks :)
03:05:26 <bubhubu> or more precise, the return value is Nothing?
03:05:38 <shachaf> No.
03:05:46 <shachaf> The return value is an infinite loop.
03:05:54 <shachaf> There's no Maybe in the type; how could it return Nothing?
03:06:09 <bubhubu> Wow, that's interesting :)
03:06:36 <bubhubu> Right, definitely, no Maybe, no Nothing
03:12:13 <shachaf> "There are advantages in having a weak notation for types. One advantage is that type checking in ML is guaranteed to terminate. It is guaranteed to terminate in Qi too, provided that the user does not add non-terminating type rules."
03:12:17 <shachaf> That's a great guarantee.
03:15:26 <osa1> shachaf: where is this quote from ?
03:16:23 <shachaf> A URL someone linked earlier.
03:16:34 <shachaf> @google "provided that the user does not add non-terminating type rules."
03:16:35 <lambdabot> http://www.lambdassociates.org/studies/study01.htm
03:16:36 <lambdabot> Title: Interval Type Theory
03:16:37 <shachaf> That page.
03:20:12 <b__> what's the fastest way to [(Word16, Word16)] -> Data.ByteString.Lazy.ByteString ?
03:20:28 <shachaf> const LB.empty
03:21:33 <mm_freak> pete_: basically a concrete type is something that you can pass to (->)
03:21:42 <mm_freak> good:  Int -> Int
03:21:51 <mm_freak> good:  Maybe Int -> Int
03:21:55 <mm_freak> bad:  Maybe -> Int
03:21:55 <awgn> Hi there. Is it possibile to evaluate a Haskell expression within a quasiquotation ?
03:22:18 <Okasu> shachaf: Well, solve it https://en.wikipedia.org/wiki/Halting_problem please, your sarcasm is silly.
03:22:58 <shachaf> Okasu: I solve it by not using a Turing-complete type system.
03:23:02 <b__> yes shachaf, very nice
03:23:18 <mm_freak> bubhubu: you don't need dependent types, but you'll need at least two type system extensions:  GADTs and RankNTypes
03:23:38 <shachaf> You don't really need them. Or, at least, you can manage with less.
03:23:59 <mm_freak> bubhubu: the latter is only needed when the lengths are not fully determined at compile time, i.e. when you read a list from the user or a file
03:24:14 <mm_freak> bubhubu: if you have at least GHC 7.4 you'll probably also want to use DataKinds
03:24:32 <bubhubu> yeah, I read about dependent types in Haskell, and it seems it's not yet in standard Haskell yet
03:24:33 <supki> DataKinds are broken in 7.4
03:24:47 <mm_freak> bubhubu: it's unlikely that you will find them in haskell any time soon
03:24:53 <Okasu> shachaf: Um, really?
03:24:55 <Okasu> >Alan Turing proved in 1936 that a general algorithm to solve the halting problem for all possible program-input pairs cannot exist
03:24:55 <gienah> yeah, DataKinds really need >= 7.6
03:25:09 <Okasu> Ughm
03:25:11 <Okasu> >halting problem for all possible program-input pairs cannot exist
03:25:14 <mm_freak> the DataKinds from GHC 7.4 are fine for this particular purpose
03:25:17 <Okasu> That one. :)
03:26:08 <Okasu> shachaf: Your mast be genius.
03:26:23 <shachaf> Okasu: I don't think you understand.
03:26:41 <Chousuke> Okasu: that doesn't mean it can't be solved for a restricted subset of all program-input pairs
03:26:41 <mm_freak> Okasu: there are languages that simply don't have the halting problem…  that's what shachaf means
03:26:44 <shachaf> But you're being kind of unpleasant about it so I don't really to explain.
03:26:56 <shachaf> Maybe someone in here is nicer than I am and will do so.
03:27:37 <bubhubu> @mm_freak: excuse me, a quick question, what's the relationship between DataKinds and GADTs
03:27:37 <lambdabot> Unknown command, try @list
03:27:38 <Okasu> mm_freak: Sorry, but i'm not guessing what shachaf means.
03:28:17 <mm_freak> bubhubu: to express the type of dependent vectors (vectors parameterized by their length) you need to have natural numbers on the type level
03:28:31 <shachaf> bubhubu: Both of them are GHC extensions. They're useful together, and each one of them is useful separately.
03:28:35 <mm_freak> bubhubu: the traditional way is to define two types, Zero :: * and Succ :: * -> *
03:28:45 <shachaf> bubhubu: (You shouldn't use "@name" to address people in here -- it messes up the bot. Just say "name:".)
03:29:01 <mm_freak> bubhubu: with DataKinds you just write "data Nat = Zero | Succ Nat" and the compiler lifts that to the type level for you
03:29:27 <mm_freak> it also actually differentiates between different type kinds, so that Zero is of kind Nat, not *
03:29:32 <mm_freak> so it gives you some additional type safety
03:29:33 <b__> shachaf: I'm being supernice, so could you point me to a way to convert a list of pairs of some Word type to a ByteString efficiently? Is Data.Binary.Put the way to go?
03:29:53 <shachaf> b__: What encoding do you want to use?
03:29:58 <shachaf> Or do you not care?
03:30:11 <bubhubu> shachaf and mm_freak: got it, thanks :)
03:30:21 <mm_freak> b__: is Builder an answer?  see Data.ByteString.Lazy.Builder or the blaze-builder package
03:31:20 <b__> shachaf, don't care
03:31:39 <mm_freak> Okasu: i'm saying that shachaf doesn't claim he solved the halting problem, and he's very aware that it can't be solved in general =)
03:31:40 <b__> well the Word16's are little endian
03:31:42 <hpaste> socumbersome pasted “no instance” at http://hpaste.org/87232
03:31:54 <mm_freak> b__: then you want Builder
03:32:09 <socumbersome> could someone please tell me what is wrong in the code above?
03:32:12 <Okasu> mm_freak: "shachaf> Okasu: I solve it"
03:32:31 <mm_freak> Okasu: he solves the halting problem problem, not the halting problem =)
03:32:43 <b__> mm_freak: thanks
03:33:12 <Okasu> He-he, anyway, let's not continue this sillyness. :)
03:33:27 <NihilistDandy> socumbersome: LT and EQ are Orderings
03:33:42 <mm_freak> socumbersome: compare is a curried function
03:33:44 <NihilistDandy> Oh, wait
03:33:52 <mm_freak> f(x,y) is wrong in general in haskell…  you want f x y instead
03:33:54 <NihilistDandy> I didn't read things properly, derp
03:34:51 <mm_freak> socumbersome: as a style note, "0" is the same as "fromIntegral 0" =)
03:35:09 <socumbersome> yeah, but ghci complains to me that "no instance for (Eq ((Double, t0) -> Ordering))
03:35:25 <mm_freak> socumbersome: yes, that's reasonable
03:35:31 <mm_freak> :t compare
03:35:33 <lambdabot> Ord a => a -> a -> Ordering
03:35:48 <mm_freak> :t compare (0 :: Double, 0 :: Double)
03:35:49 <lambdabot> (Double, Double) -> Ordering
03:36:16 <mm_freak> and you are using this value (which is a function) in a comparison
03:36:38 <mm_freak> :t compare (0 :: Double, 0 :: Double) == 15
03:36:40 <lambdabot>     No instance for (Num Ordering)
03:36:40 <lambdabot>       arising from the literal `15'
03:36:40 <lambdabot>     Possible fix: add an instance declaration for (Num Ordering)
03:36:51 <NihilistDandy> :t compare (delta :: Double) 0
03:36:53 <lambdabot> Not in scope: `delta'
03:36:58 <mm_freak> :t compare (0 :: Double, 0 :: Double) == undefined
03:36:59 <NihilistDandy> :t compare (4 :: Double) 0
03:36:59 <lambdabot> Bool
03:37:00 <lambdabot> Ordering
03:37:39 <mm_freak> socumbersome: in haskell it's possible in principle to have an Eq instance for comparing functions…  there just isn't a well-defined way to do it
03:38:09 <mm_freak> so instead of "this is impossible" you get "you didn't tell me how to do it"
03:38:28 <socumbersome> um... sorry, I got a bit confused. In my code, "porown" has Ordering type so I should be able to compare it with LT, right?
03:38:38 <mm_freak> socumbersome: no, it's not
03:38:46 <mm_freak> porown is a function in your code
03:38:58 <NihilistDandy> socumbersome: The issue is that you apply compare to a tuple, but it takes two arguments
03:39:21 <mm_freak> socumbersome: there is a difference between "compare (x, y)" and "compare x y"
03:39:30 <socumbersome> aah, obviously! Sorry, I'm a nitwit
03:39:34 <NihilistDandy> compare (x,y) is partially applied :D
03:43:47 * hackagebot doctest 0.9.7 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.9.7 (SimonHengel)
03:46:47 <jermey> Hi, can someone explain this line to me?
03:49:40 <shachaf> An IRC user asks a question about a mysterious, unexplained "this line". Since no further information is offered, the readers are forced to conclude that the line refers to itself.
03:51:25 <Okasu> jermey: Which line?
03:51:40 <Okasu> shachaf: Stop picking on people, please.
03:52:51 <jermey> w00ps
03:52:55 <jermey> sorry got distracted
03:53:05 <jermey> data Maybe a = Nothing | Just a
03:53:09 <jermey> this line
03:53:14 <hpaste> “Dharmender Kumar” pasted “Pet Grooming  in faridabad” at http://hpaste.org/87234
03:53:50 <Okasu> @google "data Maybe a = Nothing | Just a"
03:53:57 <lambdabot> http://www.haskell.org/haskellwiki/Maybe
03:53:58 <lambdabot> Title: Maybe - HaskellWiki
03:54:52 <Chousuke> I don't think that wiki is going to be very helpful
03:55:24 <hpaste> NihilistDandy revised “Pet Grooming  in faridabad”: “Pet Grooming in faridabad (newlines)” at http://hpaste.org/87234
03:55:24 <Okasu> Chousuke: Why?
03:56:03 <Chousuke> Okasu: because it assumes you already know what the "data" declaration does.
03:56:03 <NihilistDandy> @google lyah defining types
03:56:05 <lambdabot> http://learnyouahaskell.com/making-our-own-types-and-typeclasses
03:56:05 <lambdabot> Title: Making Our Own Types and Typeclasses - Learn You a Haskell for Great Good!
03:56:12 <NihilistDandy> jermey: ^
03:56:15 <Chousuke> http://www.haskell.org/haskellwiki/Type this one is probably more useful
03:56:25 <Chousuke> it even has Maybe as an example
03:56:33 <jermey> thanks i ll read both
03:56:42 <Okasu> jermey: No problem.
04:00:08 <shachaf> Okasu: I am not picking on anyone.
04:00:57 <Okasu> shachaf: Thank you.
04:07:52 <DigitalKiwi> why's everybody always pickin' on me
04:08:48 * hackagebot Random123 0.1.0 - Haskell port of Random123 library  http://hackage.haskell.org/package/Random123-0.1.0 (BogdanOpanchuk)
04:36:55 <zebr> hey all. is there a name for a construct such that, knowing nothing about the function f or relation -> but having a 'lifting' operator [.], a -> b /\ c -> d ==> f b c [<-] f a c [->] f a d ? is it a kind of functor? i'm a bit thrown by -> being a relation.
04:38:58 <shachaf> zebr: I don't follow.
04:39:14 <shachaf> Maybe you mean a bifunctor?
04:39:54 <shachaf> Are you saying that given (f a x) and (a -> b) and (x -> y), you can get (f b y)?
04:41:18 <sjoerd_visscher> it sounds like a Profunctor
04:41:55 <zebr> shachaf: no, i'm saying that that means there's a 'lifted relation' f b x [<-] f a x [->] f a y
04:42:09 <shachaf> I don't understand that notation.
04:42:14 <zebr> so basically fax can get to either fbx or fay (but not both)
04:42:24 <shachaf> "but not both"?
04:42:41 <shachaf> How does that work?
04:42:54 <Zeev> I have a question in try haskell when I do: map (/5) [20, 30, 40] I get floats
04:43:02 <shachaf> Maybe you have an example?
04:43:10 <Zeev> [4.0, 6.0, 7.0]
04:43:19 <Zeev> is there a way to get integers instead?
04:43:21 <isBEKaml> :t (/)
04:43:22 <lambdabot> Fractional a => a -> a -> a
04:43:27 <isBEKaml> :t div
04:43:29 <lambdabot> Integral a => a -> a -> a
04:43:34 <NihilistDandy> Zeev: Use div
04:43:35 <isBEKaml> Zeev: you want div
04:43:40 <Zeev> k thansk
04:43:44 <isBEKaml> > map div [20,30,40]
04:43:45 <Okasu> > map (div 5) [20, 30, 40]
04:43:46 <lambdabot>   *Exception: showList: No overloading for function
04:43:47 <zebr> shachaf: well, i just mean you can't say fax -> fby, because you have to go fax -> fay -> fby. so you'd need a transitive closure of -> to "reach both"
04:43:47 <lambdabot>   [0,0,0]
04:43:55 <isBEKaml> yeesh, yes
04:44:20 <shachaf> zebr: Is this about Haskell?
04:44:42 <Zeev> nihilistdandy, isbekaml: I get [0,0,0]
04:44:47 <Zeev> heh
04:44:57 <shachaf> > div 5 20
04:44:58 <zebr> shachaf: well, yes and no. i'm planning to implement in haskell, but i'm speaking a bit meta, just about maths, right now. (sorry for not making that clear.)
04:45:00 <lambdabot>   0
04:45:00 <shachaf> > div 20 5
04:45:02 <lambdabot>  Terminated
04:45:23 <shachaf> zebr: OK. That's good to clarify. :-)
04:45:41 <Shou> > map (`div` 5) [20, 30, 40]
04:45:43 <lambdabot>   [4,6,8]
04:45:56 <NihilistDandy> Zeev: Use a section
04:46:01 <NihilistDandy> Like Shou did, above
04:46:02 <mm_freak> zebr: so you want a type F :: * -> * -> * such that one function goes F A b -> F X b, and another that goes F X B -> F X Y?
04:46:32 <isBEKaml> Zeev: and don't type out nicks, use a better irc client to tab complete nicks. :-)
04:46:53 <Zeev> nihilistdandy: thanks, hope I'll learn 'bout it through tutorial eventually
04:47:26 <mm_freak> Zeev: a section is really just a partial function application:  (+ 5) is a function that takes the remaining argument to the left of (+)
04:47:35 <mm_freak> same for (`div` 3)
04:47:48 <mm_freak> (`div` 3) 5 = 5 `div` 3
04:48:10 <isBEKaml> > div 5 20
04:48:12 <lambdabot>   0
04:48:14 <isBEKaml> > div 20 5
04:48:16 <lambdabot>   4
04:48:16 <Zeev> mm_freak: no I mean why I have to use here `div` and why flat div doesn't work
04:48:36 <Zeev> why div is different than /
04:48:38 <Okasu> > 1 `+` 1
04:48:40 <lambdabot>   <hint>:1:4: parse error on input `+'
04:48:43 <mm_freak> Zeev: div x = (x `div`)
04:48:50 <mm_freak> so it takes the remaining right argument
04:49:01 <mm_freak> but you want to fix the right argument and take the left argument instead
04:49:22 <mm_freak> Zeev: the reason that you need to use 'div' is that (/) is only defined for fractional types
04:49:22 <NihilistDandy> Zeev: div is integral division
04:49:45 <Zeev> whatever, I got a lot to learn
04:49:46 <Okasu> > (+ 1) 1
04:49:48 <lambdabot>   2
04:49:49 <Zeev> ))
04:50:00 <Okasu> ;
04:50:08 <mm_freak> Zeev: if you were to define (/) for Integer you would get zeroes all the time =)
04:50:20 <kartoffelbrei> Zeev: (`div` 5) == (flip div 5) == (\x -> div x 5)
04:50:30 <mm_freak> (at best)
04:50:43 <kartoffelbrei> :t flip
04:50:46 <lambdabot> (a -> b -> c) -> b -> a -> c
04:51:25 <NihilistDandy> Ты русский?
04:52:04 <shachaf> Нет.
04:52:11 <Okasu> Нет.
04:52:45 <NihilistDandy> I was more curious about Zeev, what with the ))
04:52:46 <mm_freak> еыыыыыы…
04:53:06 <hannes> hi I have a question - I want to output sth, but depending on whether I run inside of a Writer monad or not, I want to prepend/append something to the output
04:53:38 <mm_freak> hannes: use different functions depending on the monad
04:53:43 <hannes> unfortunately ghci doesn't like my code, overlapping instances in line 30 http://pastebin.com/gNjUcymj
04:53:49 <shachaf> hannes: That doesn't sound like a thing you should want.
04:53:53 <mauke> The paste gNjUcymj has been copied to http://hpaste.org/87237
04:54:07 <hannes> shachaf: why not?
04:54:16 <shachaf> You can make it work but you should do what mm_freak said instead.
04:54:39 <shachaf> Anyway, your instances are overlapping.
04:54:41 <hannes> one is human readable strings, the other are human readable strings wrapped into some machine-readable sentence
04:54:59 <mm_freak> hannes: to answer your question this is a better way to go:  class (Monad m) => Print m where output :: (Show a) => a -> m (); …
04:55:04 <capisce> Хаскел
04:55:12 <mm_freak> hannes: but you should use different functions instead
04:55:50 <shachaf> mm_freak: Surely String -> m () is a better primitive?
04:56:00 <mm_freak> sure
04:56:07 <shachaf> Admittedly you lose an educational opportunity there.
04:56:16 <mm_freak> although (Show a) => a is not isomorphic to String
04:56:35 <shachaf> (exists a. Show a *> a) is.
04:56:37 <hannes> thanks!
04:56:47 <mm_freak> shachaf: nope
04:56:50 <mm_freak> :t showsPrec
04:56:52 <lambdabot> Show a => Int -> a -> ShowS
04:57:17 <shachaf> Well... Fine.
04:57:27 <shachaf> I doubt that was intended, though.
04:57:36 <mm_freak> people often think of Show as (-> String), but it's actually more powerful than that =)
05:00:15 <Zeev> ahh, I found it: Putting ` marks around a prefix function allows us to use it like an infix function: concatPrint "a" "b" ==> "a" `concatPrint` "b" == you had to do: div 6 2 but you couldn't do 6 div 2, contrary to 6 / 2
05:00:31 <mm_freak> Zeev: yeah
05:00:56 <mm_freak> shachaf: also i must say that i prefer using (forall a. (Show a) => a -> r) over (String -> r)
05:01:09 <mm_freak> the reason is that the former version is much easier to extend later
05:03:03 <Okasu> > ((+) 1 1)
05:03:06 <lambdabot>   2
05:03:18 <Okasu> Well, (+) is prefox function.
05:03:25 <Okasu> > 1 `(+)` 1
05:03:27 <lambdabot>   <hint>:1:4: parse error on input `('
05:03:41 <Okasu> s/fox/fix/
05:04:40 <shachaf> There is no reason for `(+)` to work. `` doesn't take an expression.
05:04:49 <shachaf> However, it's annoying that (`plus`) doesn't work.
05:05:11 <Okasu> Yeah, it's get expanded back to +.
05:05:16 <Okasu> >let plus = + in 1 `plus` 1
05:06:02 <monoidal> > let plus = (+) in 1 `plus` 1
05:06:04 <lambdabot>   2
05:06:21 <Okasu> monoidal: Great.
05:10:30 <mm_freak> > cycle "(`"
05:10:32 <lambdabot>   "(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`...
05:11:15 <mm_freak> > let theMotherOperator = "(`" ++ theMotherOperator ++ "`)" in theMotherOperator
05:11:17 <lambdabot>   "(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`(`...
05:32:42 <arbn> Hmm. I have a value of type A and I wrote a Storable A instance. What's the best way for me to get a Ptr for some value of type A?
05:33:34 <arbn> I know I can poke it into a ptr, but how do I get the ptr to begin with?
05:38:50 * hackagebot binary-shared 0.8.3 - Sharing for the binary package  http://hackage.haskell.org/package/binary-shared-0.8.3 (HamishMackenzie)
05:48:31 <adek> What is in your opinion best way to serialize data in Haskell and dump them to database. I use Persistent as the library to do DB operations.
05:49:09 <adek> I think there are two ways. First is to make all my custom types instance of Read/Show. The other is to make my types PersistentValues. Which one is better?
05:50:19 <Taneb> Read/Show is very bad for this
05:50:25 <Taneb> Don't do that
05:50:55 <Taneb> I don't know much about Persistent, though
05:51:33 <adek> Taneb: okay... any general hints then?
05:51:38 <Taneb> But instead of Read/Show look at the cereal and binary libraries, among others
05:52:12 <adek> To elaborate a bit more. I have a bunch of lists of strings/ints or objects with fields of types int and string and few maps to be dumped in DB.
05:53:51 * hackagebot computational-algebra 0.1.3.6 - Well-kinded computational algebra library, currently supporting Groebner basis.  http://hackage.haskell.org/package/computational-algebra-0.1.3.6 (HiromiIshii)
05:55:01 <Taneb> adek: looking quickly at persistent, I think the way to go would be writing a PersistentEntity instance
05:56:46 <adek> Taneb: Do you think it is correct way to do it from the design point of view?
05:57:22 <Taneb> I think so
05:57:53 <NihilistDandy> I like "instance Monomorphicable"
05:57:54 <adek> I think that the advantage of using PersistentEntity is that it ensures typecheck, while if I use some serialization to ByteStirng like in binary it will discard it.
05:58:27 <Taneb> Yes, I think so?
05:59:00 <adek> Haha, thank you Taneb :)
06:10:54 <arbn> I'd advise against using Persistent... it's just so much complexity and so many dependencies for arguably not a big advantage.
06:11:19 <arbn> That's just religious conviction, though. Feel free to ignore it. :P
06:12:56 <NihilistDandy> Rewrite the whole thing in acid-state!
06:15:44 <Taneb> Or tables!
06:16:17 <NihilistDandy> LaTeX tables!
06:20:31 * Eduard_Munteanu flips table
06:20:51 <NihilistDandy> :t flip table
06:20:53 <lambdabot> Not in scope: `table'
06:21:45 <Philonous> dcoutts:  Did you see my new submission for the c2hs patch?
06:24:13 <Taneb> flip table :: (Functor f, Tabular t) => [t] -> (Table t -> f (Table t)) -> f [t]
07:05:59 <pete_> Anyone know if there are answers for the exercises in: http://www.haskell.org/haskellwiki/Typeclassopedia?
07:06:19 <pete_> I have the question: Implement Functor instance for ((->) e)
07:06:22 <pete_> and I think I know the answer
07:06:44 <Botje> if it typechecks it's probably correct :)
07:06:49 <pete_> :)
07:07:06 <pete_> The answer is very simple, so I want to check I have actually understood it
07:07:15 <Eduard_Munteanu> Paste it in a pastebin.
07:07:37 <Eduard_Munteanu> Actually you could just post the fmap definition in here
07:07:44 <pete_> http://pastebin.com/jkWF30ME
07:07:49 <mauke> The paste jkWF30ME has been copied to http://hpaste.org/87238
07:07:50 <pete_> instance Functor ((->) e) where fmap = (.)
07:08:26 <Eduard_Munteanu> pete_: yep
07:08:30 <pete_> yay.
07:08:34 <pete_> That took a lot of thining about
07:09:20 <Eduard_Munteanu> > fmap (+10) (+3) $ 5
07:09:22 <lambdabot>   18
07:09:40 <Eduard_Munteanu> In fact lambdabot used to define (.) as fmap. :)
07:10:19 <Chousuke> is that actually a good idea? :P
07:10:24 <pete_> Trying to properly understand Haskell is keeping me sane while my lack of day to day programming is making my sellable programming skills go rusty :-/
07:10:40 <Eduard_Munteanu> pete_: if in doubt write out the complete type:  fmap :: (a -> b) -> (e -> a) -> (e -> b)
07:11:21 <Eduard_Munteanu> :t (.)
07:11:23 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:11:54 * pete_ moves on to instance Functor ((,) e) where
07:16:32 <Primoz128> hai
07:16:56 <Primoz128> You guys know Haskell ?
07:17:16 <copumpkin> nope, it's like one of those torrents with a million leechers but no seeders
07:17:21 <NihilistDandy> I could never quite figure out why the Functor instance for ((,) a) worked the way it did.
07:17:23 <copumpkin> we're all waiting around for someone who knows it to teach it to us
07:17:31 <copumpkin> but none of us know it
07:18:13 <Primoz128> http://learnyouahaskell.com/introduction#about-this-tutorial
07:18:16 <int-e> So ... welcome to the Church of Haskell, waiting for our Savior.
07:18:22 <Taneb> NihilistDandy: what's the type of fmap?
07:18:23 <Primoz128> there is where i am at
07:18:26 <pete_> instance Functor ((,) e) where fmap x (y, z) = (y, (x z)) -- works, but I'm pretty sure it's wrong
07:18:35 <Taneb> Primoz128: that is a good place to be
07:18:40 <pete_> uh, for works, I mean "type checks"
07:18:46 <monoidal> pete_: it's correct
07:18:50 <pete_> I don't even mean that. I mean "compiles"
07:18:51 <Primoz128> i tried a lot of imperative programing languages
07:18:52 <NihilistDandy> Taneb: Okay, now that I think about it again, it's pretty obvious
07:18:54 <NihilistDandy> :D
07:18:57 <Primoz128> and im hating them
07:19:04 <Primoz128> im so error not prone
07:19:09 <int-e> ( http://haskellchurchofchrist.org/ :-/ )
07:19:10 <Primoz128> i mean i make so many
07:19:26 <monoidal> pete_: in many of those exercises there is only one sensible implementation
07:19:48 <Primoz128> all of my projects allways ended full of bugs
07:19:51 <Primoz128> and that made me quit
07:19:52 <monoidal> pete_: btw that function is called "second" since it edits second component of a tuple
07:20:03 <pete_> monoidal: ah ha!
07:20:03 <Primoz128> so is functional programing something that will not do that to me ?
07:20:04 <pete_> right
07:20:07 <byorgey> > second (+1) (1,1)
07:20:09 <lambdabot>   (1,2)
07:20:12 <byorgey> > fmap (+1) (1,1)
07:20:16 <lambdabot>   (1,2)
07:20:36 <Philonous> Primoz128:  No. Writing good software just takes practice, in any language.
07:20:38 <byorgey> > first (+1) (1,1)  -- tuples are also functorial in the first parameter
07:20:40 <lambdabot>   (2,1)
07:20:52 <byorgey> (but you can't make that a Functor instance because it has to be the *last* parameter
07:20:53 <Philonous> Primoz128:  A good type system will help you catch some common errors early, though.
07:20:53 <Taneb> Primoz128: but Haskell sounds like something that you may enjoy a bit more
07:20:55 <pete_> Where is second defined?
07:20:58 <NihilistDandy> @source second
07:20:59 <lambdabot> second not available
07:21:03 <byorgey> pete_: Control.Arrow
07:21:06 <NihilistDandy> Ah
07:21:08 <byorgey> @type second
07:21:08 <pete_> fine, thanks
07:21:09 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
07:21:19 * pete_ baby steps
07:21:23 <byorgey> it's actually a bit more general, but most often gets used with the (->) instance of Arrow
07:22:02 <monoidal> (obviously, there's also first.)
07:22:08 <FireFly> @type second `asAppliedTo` (undefined:: a -> b)
07:22:10 <lambdabot> (b -> c) -> (d, b) -> (d, c)
07:22:14 <NihilistDandy> byorgey: That's a really odd looking type signature. At least… I think it is
07:22:34 <NihilistDandy> I need to learn more about arrows
07:22:35 <mm_freak> NihilistDandy: do they make more sense when you write the 'a' infix?
07:23:06 <Primoz128> my life ventured into Game Maker a scripting language tool for making games in imperative paradigm ,and i had 2 big projects streching over 2 months of work, both ended by errors and full of them that i couldn't solve,    and first project i worked all my free time on with joy, second one(in truth third) i forces myself all these months were in summer holidays
07:23:09 <NihilistDandy> mm_freak: I guess that does clarify it a little bit, but the main weirdness for me is the a b c at the beginning
07:23:17 <Primoz128> so yeh my life is kind of ruined
07:23:25 <pete_> Primoz128: Does this end in a question?
07:23:29 <mm_freak> (Arrow a) => b `a` c -> (d, b) `a` (d, c)
07:23:32 <FireFly> NihilistDandy: it's an "arrow from b to c"
07:23:35 <Primoz128> possibly
07:23:36 <mm_freak> @ NihilistDandy
07:23:40 <FireFly> Arow (~>) =>  b ~> c  ->  (d, b) ~> (d, c)
07:23:45 <Primoz128> i can't find anything i love anymore
07:23:45 <FireFly> Arrow* even
07:23:49 <NihilistDandy> Ah, that was the missing piece
07:24:16 <NihilistDandy> Primoz128: Haskell is a much more entertaining way to waste you life hth
07:24:29 <int-e> > fix error
07:24:32 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
07:24:33 <monoidal> NihilistDandy: note that the type signature uses higher-order polymorphism: "a" is a type variable of kind * -> * -> *. bit like the type of return is Monad m => a -> m a - there m :: * -> *
07:25:17 <int-e> Primoz128: any programming language worth learning will allow you to write buggy programs. after all, what's the difference between a bug and a feature?
07:25:25 <Primoz128> my whole life was playing games, (99% one and the same game) then game maker got me a new meaning in life, which soon destroyed itself, i hope a new paradigm can help
07:25:43 <Primoz128> thing is i knew how to do the thing, and what to use
07:25:47 <pete_> Primoz128: Haskell will not solve your problem here
07:25:51 <Primoz128> but it it ended bugging itself out
07:26:04 <pete_> Primoz128: Experience picking yourself up and attacking another smaller project will
07:26:05 <NihilistDandy> monoidal: Right, it started to become clear once I saw Arrow's signature. I'll need to do a little more reading, but it makes more sense now. I was reading something that used arrows last night and I was kind of blown away by how algebraically beautiful they are.
07:26:06 <Primoz128> but it will write shorter codes ?
07:26:21 <pete_> Primoz128: Also sounds like it might be worth learning how to write automated tests
07:26:36 <Primoz128> What is that ?
07:27:52 <pete_> man, there was a time once when I would have had t interact with a human to ensure a pizza arrived downstairs
07:28:00 <pete_> Aren't we glad /that/ time is finished
07:28:06 * pete_ gets back to Functors
07:28:17 <Primoz128> What are automated tests ?
07:28:18 <NihilistDandy> monoidal: I guess the main thing that blocked me was viewing something like (+1) as a b c
07:28:20 <typoclass> Primoz128: yes, programs in haskell are relatively short, compared to an equivalent program in another language
07:29:07 <Primoz128> and are different
07:29:08 * FireFly glances at APL
07:29:12 <pete_> Primoz128: They're little pieces of code you write to ensure what you've written is correct
07:29:28 <pete_> Primoz128: And thinking about how to write them can also help you make sure your code is well set-out
07:29:33 <NihilistDandy> FireFly: I still really want to learn APL, but paying for a compiler seems like bad news
07:29:35 <Primoz128> i had a good mentor, and i know code beauty and good code writting
07:29:49 <Primoz128> im good at that
07:29:57 <FireFly> NihilistDandy: check out J, if you don't mind the not-very-pretty ASCIIfied syntax
07:30:10 <pete_> Primoz128: I've been thinking that for the last 20 years, and yet somehow, every year, I learn something new about what constitutes beautiful code
07:30:30 <Primoz128> i did though on my newest project
07:30:41 <Primoz128> yet when i check other people's codes they are horrible
07:30:42 <NihilistDandy> FireFly: I have checked out J, oddly enough. I only mind the ASCII a bit. Still would prefer proper APL wackiness, though :D
07:31:00 <Primoz128> it's like they started coding via a broken keyboard
07:31:01 <NihilistDandy> Primoz128: Post example code
07:31:16 <Primoz128> well ok
07:31:31 <FireFly> Primoz128: I feel like that when I look at code I wrote a month ago
07:31:38 <pete_> Primoz128: Haskell will certainly help you develop a sense of superiority over others
07:31:44 <pete_> data Pair a = Pair a a
07:31:52 <pete_> instance Functor (Pair) where fmap f (Pair x y) = Pair (f x) (f y)
07:32:01 <typoclass> Primoz128: anyway, give haskell a try :-) it's quite interesting. i think in the end you'll be a better programmer
07:32:05 <typoclass> @where tryhaskell
07:32:05 <lambdabot> http://tryhaskell.org/
07:32:06 <pete_> reasonable?
07:32:09 <typoclass> @where lyah
07:32:10 <lambdabot> http://www.learnyouahaskell.com/
07:32:16 <typoclass> Primoz128: here are 2 links to get you started
07:32:18 <mm_freak> pete_: check the laws and answer that yourself
07:32:27 <pete_> mm_freak: What does "check the laws" mean?
07:32:28 <Philonous> pete_:  That's the only possible instance
07:32:40 <Primoz128> i already got both open
07:32:43 <mm_freak> pete_: fmap id = id?
07:32:57 <mm_freak> pete_: fmap f . fmap g = fmap (f . g)
07:33:40 <pete_> Are those ... identity element and closure?
07:33:43 <NihilistDandy> I was working an Algebra library and realized I'd made some stupid error where I'd made Semirings Groups or some such nonsense. If any of your bugs were as big as that, I'll be massively surprised
07:33:46 <pete_> Are we talking monoid laws here?
07:33:55 <mm_freak> pete_: no, those are functor laws
07:34:04 * pete_ googles
07:34:11 <mm_freak> pete_: don't =)
07:34:18 <typoclass> pete_: typeclassopedia describes them
07:34:19 <mm_freak> just prove that they hold for your instance
07:34:20 <Primoz128> give me a min to find some code
07:34:52 <FireFly> pete_: just scroll down half a screenful further in typeclassopedia :p
07:35:13 <pete_> Are those laws Haskell-specific? Or do these hold true of Functors as a concept in all contexts?
07:35:28 <FireFly> http://www.haskell.org/haskellwiki/Typeclassopedia#Laws
07:35:40 <pete_> fine fine :)
07:35:43 <mm_freak> pete_: they are actually the laws of mathematical functors, and it is expected from all haskell Functor instances that they hold
07:35:46 * pete_ finishes the exercises first
07:36:08 <FireFly> They are Haskell formulations for the mathematical laws, as I understand it
07:36:11 <NihilistDandy> Was going to say what mm_freak said
07:36:21 <mm_freak> pete_: example:  data MapCounter a = MapCounter Int a
07:36:29 <pete_> I should try and get my university to do a follow-on course from the original "Functional Programming" one I did
07:36:36 <mm_freak> fmap f (MapCounter c x) = MapCounter (c + 1) x
07:36:37 <pete_> Department is run by a bunch of Functional Programming researchers
07:36:46 <mm_freak> pete_: this function trivially breaks the functor laws
07:36:51 <mm_freak> because fmap id ≠ id
07:36:56 <pete_> And yet there's only a week's worth of Haskell and a week of Erlang
07:37:13 <pete_> ok
07:37:26 <hpc> pete_: where i went to uni, a younger professor is working on starting a dedicated FP course
07:37:43 * hpc tried to invite him here
07:37:58 <typoclass> pete_: laws are conventions. haskellers use them to communicate to one another. people in #hasklel will yell at you if you write an instance that violates the laws of that typeclass :-) they show up (if you're lucky) on the haddock page of a typeclass. but ghc doesn't usually know about or enforce laws
07:38:14 <Primoz128> [URL=http://picturepush.com/public/12848813][IMG]http://www5.picturepush.com/photo/a/12848813/220/12848813.png[/IMG][/URL]
07:38:50 <pete_> My supervisor some kind of functional programming luminary. Maybe I should lean on him more
07:38:50 <Primoz128> [URL=http://picturepush.com/public/12848814][IMG]http://www1.picturepush.com/photo/a/12848814/220/12848814.png[/IMG][/URL]
07:38:50 <hpc> @where ops
07:38:50 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver
07:38:50 <FireFly> That looks kinda spammy
07:38:50 <lambdabot>  roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
07:38:50 --- mode: ChanServ set +o geekosaur
07:38:50 <Primoz128> [URL=http://picturepush.com/public/12848815][IMG]http://www2.picturepush.com/photo/a/12848815/220/12848815.png[/IMG][/URL]
07:38:54 * hpc lights the batsignal
07:38:58 <NihilistDandy> pete_: My PL class was all in OCaml, but mostly it was "how to write an interpreter in OCaml" and "how loudly and often will Java programmers complain"?
07:38:59 * hackagebot Random123 0.1.1 - Haskell port of Random123 library  http://hackage.haskell.org/package/Random123-0.1.1 (BogdanOpanchuk)
07:39:08 --- kick: Primoz128 was kicked by geekosaur (Primoz128)
07:39:43 <copumpkin> I think it was just a mistake
07:39:47 <typoclass> geekosaur: did you kick him without a warning? :-o
07:39:55 <typoclass> copumpkin: yes i agree
07:40:10 <pete_> I thought you kicked him for (burstfire == 1 && reload = 0)
07:40:30 <copumpkin> Primoz128: don't put a bunch of random links in here in future :)
07:40:33 <NihilistDandy> Was that a bunch of tiny screenshots of code?
07:40:38 <copumpkin> it's hard to distinguish stuff like that from spam
07:40:44 <Primoz128> -.-
07:40:46 <copumpkin> NihilistDandy: if you go to the non-png links they have bigger pics
07:40:50 <copumpkin> but it wasn't haskell
07:40:51 <geekosaur> not a whole lot different from any other paste intot he channel...
07:40:54 <copumpkin> so I'm a little confused
07:40:59 <typoclass> Primoz128: sorry for that. we normally use hpaste.org to share code :-) have a look at it
07:41:05 <Primoz128> it's game maker, imperative
07:41:17 <NihilistDandy> copumpkin: I said to paste some example code to show the "beauty"
07:41:38 <Primoz128> How is it ?
07:41:54 <Philippa> typoclass: I can see that not working for (partly) visual languages, mind
07:42:05 --- mode: geekosaur set -o geekosaur
07:42:09 <typoclass> Philippa: true
07:42:13 <Primoz128> it works in game maker
07:42:22 <Philippa> Primoz128: as a rule, pasting image links without being more explicit about it on IRC will tend to draw responses like that 'mafraid. Warn people more first?
07:43:33 <mm_freak> that language doesn't seem visual
07:43:47 <mm_freak> but the code is very imperative, so it hurts my eyes
07:44:08 <typoclass> Primoz128: anyway, to get back on topic :-) try out haskell. it's a little hard to learn, but once you have it it's an improbably beautiful language
07:44:49 <Primoz128> ok
07:45:16 <mm_freak> Primoz128: a warning though
07:45:16 <NihilistDandy> I dunno. Is this beautiful, Primoz128? I see fairly meaningful comments, readable code, and so on.
07:45:39 <mm_freak> Primoz128: learning haskell will ruin you for most other languages, including all mainstream languages
07:45:39 <NihilistDandy> But eh… it just looks like pretty decent imperative code.
07:45:44 <typoclass> > (ap (==) reverse) "radar" -- Primoz128: here's a palindrome checker. it will check if the word from left to right is the same as from right to left, and tell you True or False
07:45:47 <lambdabot>   True
07:46:00 <NihilistDandy> mm_freak: Fact. Though it has made some of my non-Haskell code much more stable
07:46:25 <typoclass> Primoz128: you don't need to understand all of it in one day :-) but just to show that haskell code can be quite short
07:46:31 <mm_freak> NihilistDandy: it has made most of my non-haskell code unintelligible to non-haskell programmers =)
07:46:48 <NihilistDandy> mm_freak: Haha, also that. BUT THE STABILITY, THOUGH
07:47:19 <mm_freak> sure
07:48:02 <mm_freak> but the comments on how an OO class forms a category aren't that helpful =)
07:49:04 <NihilistDandy> Guys, look, if you just see AbstractClassFactoryFactoryBuilderFactory as category over arrows, it's obvious
07:49:07 <NihilistDandy> *a
07:50:04 <typoclass> NihilistDandy: their terminology is ridiculous jargon, our terminology is Important and Serious *shrug*
07:50:05 <typoclass> ;-)
07:51:07 <NihilistDandy> typoclass: Math is Important and Serious. At least I hope so, or this degree is probably a bad idea :D
07:51:07 <fruitFly> I travel VERY light and would like to set up a light (low mass) dev environment; I don't think I can dev on android, I'm not sure if modern netbooks are too shit, an ultrabook? I would appreciate the ideas.
07:51:49 <mm_freak> i think the last time i used one of those fancy OO patterns (which all boil down to being buzzword-studded wrappers of regular functions) is years ago
07:52:21 <mm_freak> in a non-ADT OO language i abuse traits and classes as a way to get my ADTs back — a very ugly version of them
07:53:04 <mm_freak> fruitFly: netbooks are totally sufficient, but prepare for longer compilation times
07:53:23 <mm_freak> if compilation takes too long, compile without -O
07:54:45 <fruitFly> mm_freak: any recommendations for haskell netbooks? anything in particular I should be looking out for? I'm earning crypto on it and other general development. I think I'll throw linux mint 14 on it, not sure entirely.
07:54:56 <fruitFly> learning*
07:55:11 <Chousuke> you'll probably want one that has an SSD in it at least.
07:55:16 <NihilistDandy> I always thought it would be neat to make a little development machine with two processors. One weak, cheap as dirt thing for running minor stuff, then a big fuckoff scary i7 or something for compilers
07:55:32 <mm_freak> fruitFly: my suggestion is to get a haskell-friendly linux distribution…  other than that it doesn't really matter that much
07:55:36 <Chousuke> then again, no point in having a portable computer without an SSD nowadays
07:55:45 <ab9rf> NihilistDandy: i don't tink any of th current operating systemsa re good at scheuling on asymmetric systems
07:56:17 <NihilistDandy> I expect not. I can dream, though :D
07:56:20 <mm_freak> fruitFly: my personal choice is arch linux, but i'm preparing to switch everything to NixOS in the somewhat near future
07:56:22 <ab9rf> NihilistDandy: scheduling processor resources when processors are not all identical is _much_ harder than the symmetric case
07:56:32 <Chousuke> ab9rf: I think Linux is getting there with the ARM big.Little stuff
07:56:34 <fruitFly> Chousuke: Yes, I think that's a a good idea; I'd have to put one in myself, right? So I guess I have to be looking at the housing then?
07:56:52 <NihilistDandy> Yeah, what I remember from my architecture and hardware classes backs that up
07:57:15 <mm_freak> fruitFly: the distributions with good haskell support i know of are arch linux, gentoo and NixOS
07:57:24 <Chousuke> fruitFly: many netbooks come with ssds already, but even if they don't, buying one is a good idea.
07:57:28 <mm_freak> that list is probably far from exhaustive
07:57:44 <ab9rf> it's not theoretically difficlut, it's just more complex and complexity is not really wahat you want in a scheduler
07:57:55 <gienah> gentoo is source based, sabayon is a binary distro based on the source based gentoo
07:58:25 <mm_freak> i don't know how well sabayon supports haskell
07:58:49 <fruitFly> mm_freak: Chousuke what makes a distro good for haskell
07:58:55 <Chousuke> one option is to install whatever distro you want and then a minimal chroot for arch or something.
07:59:28 <mm_freak> fruitFly: there are many options, but if all else fails you can use your favorite distribution and install the nix package manager to manage your GHC/cabal-install packages
07:59:31 <FireFly> fruitFly: having up-to-date versions in their repos, I guess
07:59:51 <Chousuke> fruitFly: I suppose the source-based distros are better because you usually have recipes for building up-to-date versions
07:59:51 <gienah> on sabayon you can use the gentoo-haskell overlay for haskell stuff to be able to build the haskell stuff from source code with emerge, while using binary pkgs for other stuff
08:00:04 <mm_freak> fruitFly: oh, i misread the question…  well, it should have a somewhat recent version of GHC and cabal-install
08:00:04 <Chousuke> I use Debian though
08:01:33 <Chousuke> I don't like using source-based distros as a base because there's too much stuff I'm forced to compile
08:01:41 <Chousuke> and my laptop is not a speedy thing
08:01:41 <mm_freak> fruitFly: you might want some haskell-related programs, too, like alex, c2hs, happy, etc.
08:01:43 <fruitFly> mm_freak: FireFly Chousuke Man, I'm such a linux noob too. So much to learn.
08:02:15 <Chousuke> fruitFly: you'll probably want to go with something reasonably simple then
08:02:29 <fruitFly> Warning, super noob quesiton: cabal install?
08:02:43 <mm_freak> fruitFly: if you consider yourself a noob it all depends on how brave you are =)
08:02:48 <mm_freak> if you are very brave, try NixOS
08:02:56 <fruitFly> Chousuke:  mm_freak very brave!
08:03:02 <fruitFly> I love learning
08:03:03 <FireFly> uh-oh
08:03:08 <fruitFly> hence why I'm in #haskell :D
08:03:14 <pete_> http://hpaste.org/87240 -- do we like it?
08:03:23 <mm_freak> NixOS is the haskell of linux distributions =)
08:03:41 <fruitFly> oh yeah.. *looking it up now*
08:04:38 <mm_freak> it's probably easier to learn when you have no prior experience with linux
08:04:47 <fruitFly> mm_freak: the haskell of linux distros meaning great for working WITH haskell, right?
08:04:54 <Taneb> It annoys me that the ArrowZero doesn't have any laws
08:04:58 <mm_freak> fruitFly: no
08:05:04 <fruitFly> mm_freak:  ok
08:05:09 <fruitFly> then?
08:05:21 <Chousuke> fruitFly: NixOS's package management is functional. sort of
08:05:22 <pete_> "Give an example of a type of kind * -> * which cannot be made an instance of Functor " -- I've got no clue. Hints?
08:05:49 <mm_freak> fruitFly: http://nixos.org/
08:05:53 <mm_freak> just read
08:05:53 <mm_freak> )=
08:05:55 <mm_freak> =)
08:05:57 <Iceland_jack> pete_: Do you know what ‘kind’ is?
08:05:57 <Chousuke> fruitFly: ie. instead of replacing old packages, you just install the new ones and garbage-collect old ones when they're no longer needed
08:06:09 <fruitFly> I read Nix is great for upgrading... does it also use zfs?
08:06:10 <mm_freak> pete_: hint: functions
08:06:10 <pete_> Iceland_jack: It's like a type signature, but for types :-P
08:06:12 <Taneb> "A type of kind * -> *" means a type function that takes a type and gives you a different type, pete_
08:07:10 <Chousuke> hm
08:07:35 <mm_freak> pete_: let me give you a side challenge:  write a function of the following type:  (a -> b) -> (a -> Int) -> (b -> Int)
08:07:43 <gienah> gentoo has good support for zfs, the sabayon installer does not handle zfs yet though which currently means running sabayon on zfs requires first installing gentoo then transforming it into sabayon
08:07:53 <pete_> mm_freak: ok
08:07:57 <NihilistDandy> Taneb: Shouldn't ArrowZero just have the monoid laws?
08:07:57 <Chousuke> is it still correct to call type functions just "types"?
08:08:11 <Taneb> NihilistDandy: ArrowPlus does
08:08:26 <Taneb> ArrowZero means nothing without ArrowPlus, though
08:08:34 <mm_freak> pete_: i'm happy with any definition that is total, i.e. it doesn't throw exceptions or go into an infinite loop =)
08:08:41 <mm_freak> Taneb: huh?
08:08:42 <Eduard_Munteanu> Chousuke: not really, types belong to *
08:08:48 <byorgey> Chousuke: it depends who you ask.  But yes, it is fairly standard to call anything with a kind a type, including types that have kind * -> *
08:08:52 <NihilistDandy> Taneb: Oh, wait, I was reading the instances backward
08:08:56 <NihilistDandy> I see what you mean
08:09:06 <byorgey> Chousuke: but some would distinguish "types" of kind *  from  "type constructors" of other kinds
08:09:07 <Eduard_Munteanu> The problem is stuff in * -> * isn't inhabited.
08:09:10 <Taneb> mm_freak: basically, I'm saying the docs for Control.Arrow are somewhat lacking
08:09:11 <pete_> mm_freak: freak x y = \x -> 2
08:09:13 <pete_> ;-)
08:09:18 <mm_freak> Taneb: i tend to think of ArrowPlus as a superclass of ArrowZero
08:09:20 <pete_> But I don't see how you'd do something more useful than that
08:09:26 <fruitFly> Chousuke: mm_freak I don't know what the #1 thing I should be looking for in a distro is? That upgrading of new packages and garbage collecting sounds really smart though, I just don't know how important it is compared to the other variables. Should I use nix? or maybe some other distro. I will do research but being such a noob my decision will to an extent be based on recommendations.
08:09:27 <Chousuke> Eduard_Munteanu: byorgey: okay. Just checking
08:09:35 <NihilistDandy> How useful is the zeroArrow by itself that it ought not to be a part of the ArrowPlus definition?
08:09:36 <Taneb> mm_freak: it's the other way round
08:09:38 <byorgey> Eduard_Munteanu: neither is Void.
08:09:57 <mm_freak> Taneb: which is stupid
08:09:59 <Chousuke> fruitFly: the number of packaged things, ease of installation, ease of administration, ease of use are some criteria
08:10:20 <mm_freak> pete_: did you type that into an actual file and type-check it?
08:10:20 <byorgey> Eduard_Munteanu: and don't tell me the only reason you call Void a type is because of bottom.
08:10:21 <Taneb> Indeed
08:10:21 <Eduard_Munteanu> Yeah... well, you could say "concrete types" to refer to stuff in * most accurately.
08:10:25 <Chousuke> fruitFly: If you have the patience, you can try several different distros
08:10:29 <pete_> mm_freak: You're right, that has the wrong type sig
08:10:33 <NihilistDandy> ArrowPlus is a monoid, but ArrowZero is just… nothing, really
08:10:34 <Chousuke> and stick with one you like.
08:10:35 <byorgey> Eduard_Munteanu: yes, that's the terminology I favor
08:10:43 <mm_freak> pete_: ;)
08:10:53 <NihilistDandy> Well, it's an arrow with zero
08:11:03 <mm_freak> NihilistDandy: what does "zero" mean?
08:11:07 <pete_> Anyway, my guess is you can't write that, as you have no way go get from b to Int
08:11:21 <mm_freak> pete_: but you have a function a -> b
08:11:26 <pete_> If both were injective, and a bunch of other constraints, you could work it out
08:11:27 <fruitFly> Chousuke: I would like to focus more on haskell atm, just would like to pick a solid distro for haskell development to start with though.
08:11:37 <Eduard_Munteanu> byorgey: in Haskell you can't actually write definitions for type functions, though, that'd be different from Void
08:11:43 <NihilistDandy> That's a pretty heavy question. I don't really know what an Arrow with zero means. I'll need to read more
08:11:48 <pete_> hrm
08:11:51 <NihilistDandy> As a step toward a Monoid I can see it
08:11:52 * pete_ looks again
08:11:55 <NeonCore> Hi! I have a problem, the code is here, with the explanation of my problem: http://pastebin.com/1vbe4C5A
08:12:02 <mauke> The paste 1vbe4C5A has been copied to http://hpaste.org/87241
08:12:03 <Eduard_Munteanu> I mean Void can be the rhs of ::
08:12:06 <NihilistDandy> I just don't know if there's a name for it without the <+>
08:12:08 <byorgey> mm_freak, pete_:  freak x y = \x -> 2  type checks just fine
08:12:18 <pete_> byorgey: Yes, but doesn't give the type sig he asked for
08:12:28 <mm_freak> pete_: are you sure? ;)
08:12:40 <monoidal> NeonCore: replicate works only for Int, not Integral
08:12:41 <mm_freak> pete_: note that the two x-es are unrelated
08:12:42 <ab9rf> NeonCore: what is the error that ghc(i) gives you?  can you add it to the paste?
08:12:46 <byorgey> @type  freak x y = \x -> 2  :: (a -> b) -> (a -> Int) -> (b -> Int)
08:12:48 <lambdabot> parse error on input `='
08:12:49 <byorgey> oops
08:13:17 <byorgey> @type  let freak x y = \x -> 2  in freak :: (a -> b) -> (a -> Int) -> (b -> Int)
08:13:19 <lambdabot> (a -> b) -> (a -> Int) -> b -> Int
08:13:37 <monoidal> NeonCore: if you replace it with genericReplicate, it will work
08:13:45 <mm_freak> pete_: your implementation, though the arguments are oddly named, is fine
08:14:22 <monoidal> NeonCore: alternatively you can give the sig [Int] -> [Int]
08:14:36 <NeonCore> yes, but I have to use this one
08:14:50 <NeonCore> it's given, there's a testing system
08:15:00 <mm_freak> pete_: next challenge:  write a function of type:  (a -> b) -> (a -> a) -> (b -> b)
08:15:51 <mm_freak> fruitFly: don't think too hard about this…  just download and install one…  chances are you will try multiple distributions anyway =)
08:16:38 <copumpkin> mm_freak: that's quite a challenge
08:17:10 <mm_freak> copumpkin: don't ruin it =)
08:17:47 <mm_freak> copumpkin: his main exercise is to come up with a * -> * that's not a functor
08:17:56 <copumpkin> ah, okay
08:18:15 <NeonCore> thanks guys, it's working :)
08:18:38 <pete_> So the issue I'm having is I have no example of b
08:18:44 <pete_> That I can use as an output here
08:18:50 <pete_> hrm
08:18:58 <pete_> wait, hang on
08:19:01 <pete_> = id
08:19:07 <pete_> freak _ _ = id
08:19:12 <byorgey> pete_: right
08:19:35 <mm_freak> pete_: good…  do you remember the functor laws?
08:19:47 <pete_> yes
08:19:50 <mm_freak> in particular this one:  fmap id = id
08:20:09 <mm_freak> do you see where i'm going?
08:20:14 * pete_ thinks
08:20:25 <pete_> If I can find an example where that doesn't hold
08:20:34 <pete_> Then I'm sorted
08:20:36 <mm_freak> you did already…  two times =)
08:21:17 <mm_freak> now think how you could use that to provide an answer
08:23:38 <byorgey> technically, just because you come up with a *possible* implementation of fmap that doesn't satisfy the laws, of course, doesn't mean that there *is no* implementation that does.
08:23:54 <byorgey> but once you understand what's going on it's not too hard to make an intuitive argument why that is the case.
08:24:51 <acube> Is there a datatype in haskell of kind * -> * where the is no implementation of fmap following the laws?
08:24:56 <pete_> data Foo a = Foo () () -- presumably this is using "undefined" though
08:25:19 <mm_freak> pete_: that one has a trivial valid Functor instance
08:25:35 <mm_freak> fmap _ (Foo x y) = Foo x y
08:25:46 <byorgey> acube: that is exactly the question pete_ is trying to answer currently.
08:25:48 <pete_> fmap _ x = x
08:25:56 <mm_freak> pete_: no, that's a type error
08:26:09 <byorgey> acube: the answer is "yes" but I won't give away more at the moment.
08:26:11 <pete_> hrm
08:26:33 <mm_freak> pete_: look at the types of the two functions you just wrote
08:26:33 <NihilistDandy> :q
08:26:45 <mm_freak> pete_: they follow a pattern…  does that pattern look familiar?
08:26:47 <NihilistDandy> Wrong window :|
08:27:33 <pete_> In both cases you're having to provide a function that always evaluates to the same output
08:27:46 <pete_> Or rather, discards the first two arguments
08:27:54 <mm_freak> pete_: yes, that's value level, but i'm asking about the /types/
08:28:00 <mm_freak> does the type pattern look familiar?
08:28:23 <pete_> Let's see, they were: (a -> b) -> (a -> Int) -> (b -> Int)
08:28:25 <pete_> and
08:28:38 <pete_> (a -> b) -> (a -> a) -> (b -> b)
08:28:56 <mm_freak> yeah
08:29:15 <pete_> In both cases you don't have a function that accepts an argument of the type the output function needs
08:29:37 <mm_freak> don't bother about what the types mean…  just look at the types themselves, they way they are written
08:30:07 <pete_> I don't see what you're getting at :-/
08:30:18 <mm_freak> could you capture 'a -> Int' as a sort of function of a?
08:30:37 <mm_freak> something like this: f a = a -> Int
08:31:03 <mm_freak> then the type signature would become:  (a -> b) -> f a -> f b
08:31:07 <mm_freak> and that should look familiar =)
08:31:26 <pete_> that does indeed look familiar
08:31:56 <mm_freak> now you could ask a question like this:  freak id = id?
08:31:59 <elliott> (er, the point is that this function is impossible, right?)
08:32:06 <elliott> (f is contravariant...)
08:32:12 <Taneb> elliott: shh
08:32:21 <elliott> ok, shhing :p
08:32:37 <pete_> mm_freak: I'm missing a step here
08:32:54 <mm_freak> pete_: replace 'f' by 'F'
08:33:54 <mm_freak> and write an actual type function…  another name for "type function" is "type constructor", i.e. something of kind * -> *
08:35:26 <mm_freak> pete_: still feeling lost?
08:35:38 <pete_> Yes, but leave me be a sec, I'm thinking through
08:38:15 <pete_> So for: f a = a -> Int
08:38:29 <pete_> Anything that returns a constant Int works
08:38:42 <pete_> I'm guessing I can also pattern-match the a
08:38:50 <pete_> and then dispatch accordingly
08:39:17 <mm_freak> pete_: that's not what i mean
08:39:22 <pete_> ok
08:39:37 <mm_freak> pete_: what do you write when you want to write a type for things that contain an Int and a Double?
08:39:53 <pete_> (Num a) =>
08:40:02 <mm_freak> pete_: i mean when you /define/ a type
08:41:08 <pete_> | delimited value constructors?
08:41:24 <mm_freak> pete_: give me an actual short example
08:41:27 <Taneb> Is it possible to compile GHC with an existing non-GHC compiler?
08:41:49 <mm_freak> Taneb: unlikely
08:42:02 <pete_> data PNum = Int | Double
08:42:15 <mm_freak> pete_: nope
08:42:24 <mm_freak> you're missing constructor names
08:43:03 <pete_> data PNum = PI Int | PD Double
08:44:05 <mm_freak> pete_: yeah…  what do you write when you want to have a custom type for values of type Int -> Int?
08:45:10 <pete_> data PNum = PI Int | PD Double | PF (Int -> Int)
08:45:39 <mm_freak> pete_: only an Int -> Int
08:46:21 <pete_> I think you've convinced me to come back to these some other time
08:46:52 <mm_freak> pete_: you were actually doing great so far =)
08:48:41 <pete_> All you need in order to make it an instance of Functor is an fmap. If you have any element of the `output` kind, you're golden, even if your fmap is stupid
08:49:10 <copumpkin> well, the fmap needs to be well behaved too
08:49:32 <pete_> That doesn't affect whether or not it can be made an instance of Functor
08:49:56 <copumpkin> it affects whether it should be
08:50:00 <elliott> you don't need any element in that case, then
08:50:01 <copumpkin> you can always define fmap = fmap
08:50:04 <elliott> instance Functor Anything where fmap = undefined
08:50:14 <pete_> elliott: undefined was specifically excluded
08:50:37 <mm_freak> pete_: one implementation of fmap is always possible
08:50:39 <mm_freak> fmap = undefined
08:50:49 <copumpkin> that's what we just said, twice :P
08:50:52 <pete_> mm_freak: Which is the one I started off by saying was excluded
08:51:01 <cmccann> hey guys you can define fmap = undefined did you know that
08:51:06 <copumpkin> wait, really?
08:51:06 <mm_freak> pete_: fmap = fmap
08:51:06 <cmccann> just thought I should mention it
08:51:17 <copumpkin> >_>
08:51:24 <pete_> presumably: fmap = error ""
08:51:25 * FireFly wonders if mm_freak has eyes
08:51:29 <pete_> is also usually reasonable
08:52:18 <ab9rf> i refuse to be reasonable
08:56:41 <NihilistDandy> Guys, I got it! fmap = undefined
08:56:42 <copumpkin> pete_: anyway, my point is that Functor has implicit laws attached to it and although you can define fmap f [] = []; fmap f (x:xs) = f x : f x : fmap f xs, that breaks the laws so shouldn't be done :P
08:57:14 <copumpkin> there's only one real law you need to make an effort to respect, anyway
08:57:32 <pete_> what goes up must come down?
08:57:38 <copumpkin> fmap id = id
08:57:57 <copumpkin> but yeah, that one too :)
09:01:09 <bjackman> The code "instance Applicative Maybe where      pure = Just" has confused me. Isn't this assigning a type constructor to a function?
09:01:26 <copumpkin> Just is a data constructor
09:01:27 <bjackman> It does make sense, because "pure x" should return "Just x"
09:01:31 <bjackman> but it seems like it's breaking the rules
09:01:35 <elliott> Just is a function too.
09:01:39 <elliott> Just :: a -> Maybe a
09:01:42 <copumpkin> Maybe is the type constructor
09:01:45 <elliott> Just 3 is just applying Just to 3.
09:01:50 <bjackman> oh yeah sorry my terminology is poor!
09:01:55 <bjackman> so is a data constructor just a function?
09:01:58 <copumpkin> yeah
09:02:01 <elliott> yes, it's special because
09:02:02 <NihilistDandy> elliott: Great justice, there
09:02:05 <elliott> (a) starts with an uppercase letter
09:02:08 <elliott> (b) you can pattern-match on it
09:02:19 <elliott> (c) some stuff about record syntax... but you can just treat it as a function
09:02:38 <bjackman> ah ok well i suppose that makes sense!
09:03:15 <bjackman> But type constructors aren't functions, right?
09:03:36 <bjackman> there's no context in which I could assign Maybe to a function is there?
09:03:44 <elliott> they're at the type level, not the value level
09:03:55 <bjackman> cool cool
09:04:05 <elliott> you can have a type and data constructor with the same name
09:04:09 <elliott> data Foo = Foo Int
09:04:20 <elliott> then, blah = Foo works. but it's the data constructor you're using there
09:04:27 <elliott> and type Blah = Foo also works. that time it's the type constructor
09:04:30 <elliott> the namespaces are separate
09:04:41 <bjackman> Ah yeah ok
09:05:14 <bjackman> cheers!
09:10:20 <mm_freak> FireFly: ?
09:10:45 <FireFly> mm_freak: both of those had just been mentioned
09:10:51 <FireFly> but.. never mind
09:11:05 <mm_freak> i know
09:11:55 <klrr>  get some really strange runtime error https://gist.github.com/klrr/5517947 (code and error in paste), it's something wrong with the apply function on line 78, anyone got an idea what's wrong?
09:12:09 <mm_freak> and i don't subscribe to the rule that things need to be said at most once =)
09:14:02 * hackagebot hledger-lib 0.20.0.1 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.20.0.1 (SimonMichael)
09:14:04 * hackagebot hledger 0.20.0.1 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.20.0.1 (SimonMichael)
09:14:06 * hackagebot hledger-web 0.20.0.1 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.20.0.1 (SimonMichael)
09:14:50 <NihilistDandy> We've made it. Haskell has an accounting package.
09:15:06 <copumpkin> it's been around for ages
09:15:12 <copumpkin> whenever I see it, I think heath ledger
09:15:25 <sm> since 2008 :)
09:15:29 <copumpkin> :)
09:15:40 <sm> there's also umm, penny, and others
09:15:47 <poco> hi
09:16:44 <poco> i am using a c library to which i pass a pure haskell function, it works. now i would like the function i pass to return a monad (it performs parallel computations). is there a way to do that?
09:16:57 <NihilistDandy> I was going to make a joke about library parity with Java as a mark of success, but the details escape me
09:17:34 <klrr>  get some really strange runtime error https://gist.github.com/klrr/5517947 (code and error in paste), it's something wrong with the apply function on line 78, anyone got an idea what's wrong?
09:18:05 <typoclass> klrr: hello, "non-exhaustive patterns" means that you're calling a partial function wrong. if you look at line 47, you can see you have two equations for function updateEnv
09:18:41 <typoclass> klrr: any guesses what arguments could not match "[] []" and neither match "(x:xs) (y:ys)" ?
09:19:18 <typoclass> klrr: urgh hang on, i misread 79 as 47 :-)
09:19:41 <typoclass> it's like, totally similar numbers
09:20:05 <klrr> hehe :P
09:20:36 <typoclass> klrr: anyway, the 'apply' function is similar. you have two equations, they can handle Prim and Func, but not any of the 5 other sorts of Expr
09:21:01 <klrr> yes but it's only meant for functions
09:21:08 <NihilistDandy> Then you need a fallthrough case
09:21:16 <klrr> oh okey
09:21:37 <NihilistDandy> apply _ _ = error "I don't even know why we got here"
09:21:51 <klrr> still get an error
09:21:54 <klrr> well
09:21:58 <klrr> now i get the error error
09:22:06 <typoclass> klrr: then you either need to make sure you call 'apply' only with Prim and Func, nothing else. or alternatively, use "apply x _ = ... x ..."
09:22:13 <mm_freak> klrr: compiling with -W is always a good idea
09:22:26 <mm_freak> then the compiler warns you about these incomplete patterns
09:22:57 <klrr> thanks
09:23:15 <klrr> but it's still not the incomplete pattern that's wrong it's something else :x
09:23:47 <NihilistDandy> What's the new error?
09:24:37 <typoclass> klrr: i don't know about your lisp program, but sometimes it can make sense to have a function process one or two cases, and give the other stuff through unchanged. "f (Something x) = ... complicated calculation with x ... ; f y = y"
09:25:33 <klrr> NihilistDandy: simply the third case i added which is "apply _ _ = throwError $ Default "error in apply""
09:25:36 <klrr> typoclass: how you mean?
09:26:37 <NihilistDandy> Right, but what does the error say?
09:26:51 <klrr> NihilistDandy: "error in apply"
09:27:08 <geekosaur> NihilistDandy, klrr meant the newlu added case in apply that calls error got invoked
09:27:14 <NihilistDandy> Ah
09:27:20 <NihilistDandy> Then you're using apply with something that's not a function
09:27:28 <typoclass> klrr: never mind, i've read some more of your program, i think it's not applicable here
09:27:29 <NihilistDandy> So look at where you use apply (I only saw one place)
09:27:48 <typoclass> klrr: anyway, you're calling apply in line 75. this is the only call. any guesses what the error means?
09:29:14 <klrr> this is the new error https://gist.github.com/anonymous/34712d67a697f5b50875
09:29:28 <int80_h> how can I show an Int in base 16?
09:29:33 <klrr> simply (+ 2 2) doesnt match any of the cases which seems weird
09:29:48 <NihilistDandy> > 24 `mod` 16
09:29:50 <lambdabot>   8
09:29:54 <NihilistDandy> int80_h: That seems to work
09:30:21 <typoclass> klrr: ok :-) that error doesn't really change the situation. you've just replaced ghc's error message with your own one
09:30:45 <klrr> typoclass: i know :( but i have to go now, parents is forcing me to work xD
09:30:48 <klrr> bbl
09:31:01 <typoclass> klrr: ok see you. as the next step, i suggest you import Debug.Trace and add some 'trace' calls
09:32:43 <int80_h> NihilistDandy: I want to represent, or show, the number 10 (for example) as a or A.
09:33:11 <int80_h> so something like show $ toHex 10
09:33:29 <int80_h> would yield A :: Hex
09:33:42 <int80_h> oh wait
09:33:52 <int80_h> I men
09:33:58 <typoclass> > showHex 123 "" -- int80_h: this?
09:34:01 <lambdabot>   "7b"
09:34:12 <int80_h> yes!
09:34:37 <int80_h> now how can to go the other way ?
09:34:54 <int80_h> foo "7b"
09:34:57 <typoclass> i kind of wonder what that empty string is doing there
09:34:59 * typoclass purrs
09:35:20 <geekosaur> think ShowS
09:35:31 <typoclass> geekosaur: i am. it's not helping
09:35:41 <elliott> > showHex 123 "q"
09:35:43 <Aune> Which is the currently recommended lens library?
09:35:43 <lambdabot>   "7bq"
09:35:44 <elliott> > shows 123 "q"
09:35:46 <lambdabot>   "123q"
09:35:49 <elliott> DList
09:35:55 <int80_h> > showInt 123 ""
09:35:58 <lambdabot>   "123"
09:36:14 <donri> Aune: lens
09:36:19 <typoclass> Aune: lens from edwardk
09:36:26 <simpson> @hackage lens -- Aune
09:36:27 <lambdabot> http://hackage.haskell.org/package/lens -- Aune
09:36:33 <int80_h> >readHex "d"
09:36:33 <NihilistDandy> > showIntAtBase 10 showHex 7b
09:36:35 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
09:36:35 <lambdabot>              with actual type...
09:36:53 <Aune> thanks, will get right to learning it then.
09:36:56 <geekosaur> NihilistDandy, parens
09:37:02 <NihilistDandy> Oh, duh
09:37:07 <typoclass> > readHex "7b" -- int80_h
09:37:09 <lambdabot>   [(123,"")]
09:37:38 <typoclass> so, the String argument to showHex just appends it?
09:38:02 <int80_h> > readHex "d"
09:38:05 <lambdabot>   [(13,"")]
09:38:21 <geekosaur> yes; the intent is functional lists: showHex foo . showWhatever bar . (...)
09:38:23 <typoclass> Aune: this is quite readable https://github.com/ekmett/lens/wiki/Overview
09:38:30 <ghorn> is the LibClang package inactive?
09:38:38 <int80_h> > showIntAtBase 10 $ showHex 7b
09:38:39 <typoclass> geekosaur: oh i see. how odd. thanks
09:38:41 <lambdabot>   Couldn't match expected type `GHC.Types.Int -> GHC.Types.Char'
09:38:41 <lambdabot>             ...
09:40:12 <Aune> typoclass, thanks
09:40:19 <int80_h> > showIntAtBase 10 (showHex 7b)
09:40:21 <lambdabot>   Couldn't match expected type `GHC.Types.Int -> GHC.Types.Char'
09:40:21 <lambdabot>             ...
09:40:30 <geekosaur> :t showHex
09:40:32 <lambdabot> (Integral a, Show a) => a -> ShowS
09:40:41 <geekosaur> hm, tht's less than obvious
09:40:52 <geekosaur> it's grumpy about a missing parameter to showHex
09:41:03 <typoclass> @type showIntAtBase
09:41:05 <int80_h> > showIntAtBase 10 (showHex 7b "")
09:41:06 <lambdabot> (Integral a, Show a) => a -> (Int -> Char) -> a -> ShowS
09:41:07 <lambdabot>   The function `Numeric.showHex' is applied to three arguments,
09:41:07 <lambdabot>  but its type...
09:41:21 <geekosaur> hm, maybe I'm confused now
09:41:24 <NihilistDandy> > showIntAtBase 16 intToDigit 14
09:41:26 <lambdabot>   *Exception: show: No overloading for function
09:41:40 <NihilistDandy> > showIntAtBase 16 (intToDigit) 25
09:41:42 <lambdabot>   *Exception: show: No overloading for function
09:41:58 <geekosaur> :t ShowS
09:42:00 <typoclass> man, we are flailing around incoherently
09:42:01 <lambdabot> Not in scope: data constructor `ShowS'
09:42:04 <NihilistDandy> Well, that's the damn definition, lambdabot, what do you want from me?
09:42:08 <geekosaur> I am now at least :/
09:42:24 <geekosaur> @src ShowS
09:42:24 <lambdabot> type ShowS = String -> String
09:42:30 <typoclass> int80_h: what do you intend with "showIntAtBase 10 (showHex ...)"?
09:42:32 <geekosaur> there was the point I wanted
09:42:39 <geekosaur> a ShowS is a function
09:42:49 <NihilistDandy> @src showHex
09:42:50 <lambdabot> Source not found. You speak an infinite deal of nothing
09:43:01 <NihilistDandy> Anyway, the point is showHex = showIntAtBase 16 intToDigit
09:43:32 <int-e> :t (\x -> (undefined :: Shows) x) -- hmm
09:43:34 <lambdabot>     Not in scope: type constructor or class `Shows'
09:43:34 <lambdabot>     Perhaps you meant one of these:
09:43:34 <lambdabot>       `Show' (imported from Prelude), `ShowS' (imported from Prelude)
09:43:51 <int80_h> typoclass: Well I am generally trying to learn how to convert between bases.
09:44:00 <int-e> :t (\x -> (undefined :: ShowS) x) -- hmm
09:44:02 <lambdabot> String -> String
09:44:59 <int80_h> typoclass: I figured if I saw a specific example I could generalize from that.
09:45:06 <NihilistDandy> int80_h: Well, that doesn't particularly convert anything. It just shows a different representation.
09:45:17 <typoclass> int80_h: ah ok. check out http://www.haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html , in particular showIntAtBase and readInt. those are the general ones afaik
09:45:51 <int80_h> NihilistDandy: I mis-spoke, I am trying to transform from one representation to another.
09:46:25 <typoclass> > showIntAtBase 19 intToDigit 123 "" -- converting to base-19
09:46:29 <lambdabot>   "69"
09:46:40 <NihilistDandy> For display purposes, this is fine. But if you want to do some kind of wacky hex math on it, you won't be able to
09:46:49 <supki> > 123 ^. re (base 19)
09:46:52 <lambdabot>   "69"
09:47:04 <NihilistDandy> :t (^.)
09:47:06 <lambdabot> s -> Getting a s a -> a
09:47:16 <NihilistDandy> Oh, god, lenses?
09:47:17 <int80_h> NihilistDandy: okay what if I want to do bit operations?
09:47:18 <supki> > "69" ^? base 19
09:47:21 <lambdabot>   Just 123
09:47:45 <ab9rf> lenses are everywhere
09:47:51 <edwardk> "oh god"?
09:48:42 <int80_h> NihilistDandy: say given a hex number "7d", I want to do bit operations on it. How can I transform it into a value I can do bit operations on?
09:49:03 <NihilistDandy> edwardk: I just haven't learned them, yet. They're scary at first :P
09:49:23 <NihilistDandy> Don't even get me started on machines T_T
09:49:26 <edwardk> > "7d" & base 16 +~ 3
09:49:28 <lambdabot>   "80"
09:49:56 <edwardk> > "7d"^?base 16.bit 3
09:49:58 <lambdabot>   Could not deduce (Data.Bits.Bits
09:49:58 <lambdabot>                      ((a
09:49:58 <lambdabot>                  ...
09:50:44 <int80_h> "7d" & base 16
09:50:50 <int80_h> > "7d" & base 16
09:50:53 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
09:50:53 <lambdabot>              with actual ty...
09:51:16 <edwardk> > "7d"^?base 16
09:51:18 <lambdabot>   Just 125
09:51:25 <edwardk> that tries to parse and tells you if it succeeds
09:51:47 <edwardk> it can of course fail, hence the need for ^? rather than ^.  and the resulting Maybe
09:52:06 <haasn> > base 16 # 65535
09:52:10 <lambdabot>   "ffff"
09:52:22 <int80_h> :t > "7d"^?base 16
09:52:25 <lambdabot> parse error on input `>'
09:52:27 <edwardk> base 16   is a prism. so you can use it like haasn just did, and build values with it, or you can use it like a traversal like i did with the ^? above.
09:52:30 <int80_h> :t "7d"^?base 16
09:52:32 <lambdabot> Integral a => Maybe a
09:52:40 <edwardk> ^? runs a traversal and returns the first result
09:52:59 <edwardk> and since every prism is a traversal it works on base 16
09:53:09 <haasn> :t (^?)
09:53:12 <lambdabot> s -> Getting (First a) s a -> Maybe a
09:53:16 <haasn> folds too then
09:53:19 <typoclass> int80_h: you need at least some familiarity with lenses. see the tutorial link i pasted a few minutes ago
09:53:21 <edwardk> yep
09:53:35 <edwardk> and getters, and lenses, and just about everything other than a setter
09:53:40 <int80_h> typoclass will do . thanks :)
09:54:28 <int80_h> typoclass: I only see the link to Numeric
09:54:37 <int80_h> typoclass: I may have missed something
09:55:03 <typoclass> int80_h: i meant https://github.com/ekmett/lens/wiki/Overview sorry, "a few minutes" wasn't accurate :-) more like half an hour
09:55:35 <int80_h> typoclass: no worries. Thanks for the help. I'm off to reading now.
09:56:30 <FireFly> @ty base
09:56:32 <lambdabot> (Integral a, Applicative f, Choice p) => Int -> p a (f a) -> p String (f String)
09:59:56 <bjackman> What do you guys think is the cleanest way to get the element out of a list you know to have only one element?
10:00:16 <typoclass> bjackman: i'd use pattern matching -- "f [x] = ..."
10:00:18 <bjackman> I could use "first" or "last " or "!!0" but I don't feel they would make clear the assumption that it only has one element
10:00:39 <typoclass> bjackman: yeah, our 'first' is called 'head' :-)
10:00:51 <cmccann> bjackman: the ideal solution is to not be using a list when you get to that point
10:00:59 <cmccann> but that's not always viable
10:01:16 <bjackman> yeah, that would be ideal, but I don't think it's vialbe in the context
10:01:26 <bjackman> I'm trying to parse lists of lines, each of which is a list of strings
10:01:27 <cmccann> especially since there's no non-empty list type in the default libraries
10:01:33 <bjackman> and the last line has only one word in it
10:02:14 <cmccann> so the "know it will have one element" is a feature of the input you intend to use?
10:02:30 <bjackman> exactly
10:02:37 <bjackman> well
10:02:41 <bjackman> It's a list of lists
10:02:51 <bjackman> all but the last element of the outer list will contain more than one inner list
10:02:57 <bjackman> but the last list will only have one element
10:03:09 <bjackman> like [[1, 2, 3], [4, 5, 6], [1]]
10:03:21 <cmccann> anyway, if you're doing any validation on the input ideally you'd extract the single element at the same time you reject other cases
10:03:22 <bjackman> except they're strings
10:03:31 <cmccann> if you're not validating input anyway, just use head
10:03:56 <bjackman> yeah i guess
10:04:08 <cmccann> well, if you're ok with the program crashing on invalid input then might as well just do the simplest thing.
10:04:23 <bjackman> yeah you're right
10:05:23 <cmccann> in any sort of real code intended to be used long-term you'd want to do something nicer
10:06:07 <typoclass> bjackman: to sum up, 'head' will crash the program if the list is empty. if the list is longer than 1, you won't notice. 'f [x] = ...' or 'case theList of [x] -> ...' will crash the program if the list is empty or longer than 1, and a benefit is you'll get a line number where it crashed.
10:07:19 <bjackman> cool
10:07:20 <cmccann> head is the simpler way if you really are certain the input will always be well-formed
10:07:34 <cmccann> otherwise the diagnostic info from the pattern failure is nice
10:07:46 <bjackman> It's just a function to read in test cases so it shouldn't matter too much
10:08:15 <bjackman> but as I'm learning I'm quite keen to pick up on whats the haskellite way to do things!
10:08:36 <bjackman> what's the haskell equivalent of the word "pythonic"?
10:08:51 <cmccann> just "idiomatic" probably.
10:09:05 <cmccann> I don't think we have a special term for "idiomatic haskell" in common use.
10:09:34 <bjackman> ha-skilled
10:09:37 <tharper> I use Haskellish
10:09:46 <tharper> I tried using Haskelly once in paper
10:09:50 <tharper> reviewer was not impressed
10:09:53 * geekosaur has seen 'haskelly' in the wild
10:09:55 <cmccann> haha
10:09:58 <typoclass> bjackman: i think it's plausible to decide that when the input file is malformed, you need to crash the program (as opposed to guessing, silently giving wrong results, etc.). the remaining decision is if you want to do that with a "nice" error message, or with ghc's normal message ("non-exhaustive pattern in line 123 ...")
10:10:10 <cmccann> haskelletal
10:10:17 <geekosaur> wouldn't be suitable for academia, no, but blogs...
10:10:27 <tharper> pfft
10:10:44 <geekosaur> (I think in formal writing, "idiomatic ..." is the right choice for (almost) all languages)
10:10:45 <typoclass> bjackman: haskellish, haskellite, haskellian, haskellean, haskellic. pick anyone :-) be sure to vary a little, just to spice things up
10:11:13 <cmccann> yeah, idiomatic is the sufficiently-formal generic term.
10:11:15 <bjackman> ooh haskellian! that's definitely the best
10:11:21 <tharper> generic = boring in this case =p
10:11:37 <byorgey> haskelloid
10:12:00 <cmccann> byorgey: haskell : haskelloid :: group : groupoid?
10:12:17 <byorgey> right, and also   ... :: mon : monoid
10:12:24 <cmccann> clearly
10:12:46 <Eduard_Munteanu> No, no... monoid : monoidoid
10:14:49 <cmccann> bjackman: anyway, say "idiomatic Haskell" if you want to sound all respectable and shit, otherwise just make up an adjective like the ones suggested and people will know what you mean.
10:16:52 <Eduard_Munteanu> Unless there's someone respectable and shit in the audience, then they might play the pedant role. :P
10:27:45 <NihilistDandy> Categorically haskelly will get past any reviewer
10:28:11 <NihilistDandy> cmccann: Wouldn't haskelloid just be a weaker haskell?
10:34:26 <mm_freak> haskellomorphic
10:39:14 <FireFly> haskellotrophic
10:40:07 <NihilistDandy> haskelleomorphic, for Haskell over metric spaces
10:40:46 <Aune> If I have: data A = A {_data :: B} , a :: A, b :: B. How would I set _data to b?  I thought  "a .~ _data b", but obviously I'm missing something.
10:42:30 <elliott> Aune: are you trying to use lens?
10:42:39 <elliott> or is this a question about regular haskell record syntax?
10:42:48 <Aune> elliott, Im trying to learn lens
10:42:59 <elliott> ok, then once you do makeLenses ''A, it's
10:43:01 <elliott> a & _data .~ b
10:43:06 <elliott> which is the same as
10:43:08 <elliott> _data .~ b $ a
10:43:58 <Aune> elliott, thanks.
10:44:17 <epta> How do you print all these sperms .~ and stuff so fast? 2 seconds for each of them. Should I learn lens to do that like you?
10:44:36 <elliott> ?
10:46:09 <elliott> vim users: is there something like neco-ghc for hdevtools instead of ghc-mod?
10:46:23 <elliott> or do I need to use ghc-mod if I want that kind of completion?
10:46:37 <typoclass> epta: i think elliott pressed up-arrow in his irc client to repeat the previous line, deleted the "a &", and added "$ a" at the end :-)
10:46:51 <NihilistDandy> elliott: As far as I know, you need ghc-mod for that
10:46:57 <NihilistDandy> Much as I wish it might be otherwise
10:47:17 <elliott> typoclass: actually I think I typed that one by hand, though I don't remember now!
10:47:38 <epta> typoclass: doesn't work for the first of them
10:47:40 <elliott> NihilistDandy: that's a shame
10:47:55 <typoclass> epta: true :-)
10:48:23 <elliott> NihilistDandy: I wonder if it would negate the benefits of hdevtools to use ghc-mod just for completion?
10:51:50 <NihilistDandy> elliott: I don't think so. I use hdevtools for most things. That said, I don't strictly know most of the things that hdevtools does
10:52:54 <nominolo_> sclv: thanks re: murmurhash2 SO question.  Replied
10:54:05 <elliott> NihilistDandy: well, I was just thinking it might negate the speed benefit if ghc-mod is involved at all
10:54:33 <nominolo_> parcs: The problem with the parallism patches to GHC were that the use of unsafePerformIO slowed down GHC when compiling certain code.  unsafePerformIO traverses the stack which can become expensive on deep stacks.
10:54:53 <nominolo_> parcs: GHC now uses stack chunks which may have made this cheaper
10:55:23 <NihilistDandy> I don't think the presence of ghc-mod should hurt anything in a noticeable way. You can still get fast information with hdevtools without ever calling out to ghc-mod.
10:55:33 <NihilistDandy> At least I would think. I use both and I haven't noticed anything amiss
10:55:39 <epta> elliott: I have used them both at the same and hdevtools was fast enough
10:55:56 <epta> the same time*
10:57:59 <nominolo_> Hm, didn't know about hdevtools
10:58:29 <nominolo_> The approach sounds like it will require huge amounts of memory (since GHC API is space-leaky)
10:59:08 * hackagebot iotransaction 0.1 - Supports the automatic undoing of IO operations when an exception is thrown.  http://hackage.haskell.org/package/iotransaction-0.1 (DylanShearer)
10:59:11 <epta> nominolo_: didn't saw it eating more than 80M
11:01:56 <NihilistDandy> elliott: What all does hdevtools do other than type annotations and symbol info? I guess it also jumps to modules now, but is there anything I'm missing?
11:02:08 <NihilistDandy> I probably am not using it to the fullest
11:04:49 <nominolo_> epta: Does it restart the client or is it like a long-running ghci session?
11:07:49 <epta> nominolo_: hdevtools client lives as long as vim session is open
11:07:54 <epta> correct me if I'm wrong
11:08:09 <nominolo_> +
11:08:20 <nominolo_> oops
11:11:36 <Aune> elliott, I still cant get it to work. I have tried both but I get "Couldn't match expected type `a0 -> Mutator b0' with actual type `World' in the expression: (_players .~)  Expected type: ASetter s0 t0 a0 b0     Actual type: World -> [Player]"
11:11:57 <Aune> Do I need to do something special in ghci to get it to work?
11:13:00 <elliott> Aune: what is your full expression?
11:13:32 <Aune> in ghci: ":t (_players .~)"
11:14:14 <donri> Aune: are you sure you don't mean "players" with no underscore?
11:15:29 <Aune> Oh, I assumed that the underscore from "data World = World {_players :: [Player]}" were required
11:16:09 <Aune> Seems I was wrong
11:16:18 <donri> Aune: did you makeLenses ''World ?
11:16:18 <michele130> ?list
11:16:19 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:17:03 <elliott> Aune: you want the underscore there, but you want to use the resulting lens as players
11:17:10 <elliott> it derives players from _players
11:17:53 <Eduard_Munteanu> Aune: "_foo" field => "foo" lens
11:18:10 <Aune> That makes so much sense.
11:18:20 <Eduard_Munteanu> (They can't share names, you know.)
11:19:17 <chrisdotcode> hey all :)
11:19:29 <Eduard_Munteanu> chrisdotcode: hi
11:20:13 <Aune> Eduard_Munteanu, I assumed it would replace the original definition with a new under the same name. Much better this way.
11:20:47 <Eduard_Munteanu> Not sure TH can even do that.
11:20:59 <chrisdotcode> can anyone help me find something equivalent and as conscise as "[1,2,3].map {|n| n*n }.reject {|n| n%3==1 }" in haskell?
11:22:09 <dolio> Just write it backwards.
11:22:19 <chrisdotcode> there's the list comprehension, but can as consisely without it?
11:22:31 <elliott> NihilistDandy: so do you use hdevtools/syntastic? do you know how to get it to display multiple-line errors reasonably?
11:23:12 <chrisdotcode> dolio: reject n % 3 == 1 $ map (\x -> x * x) [1,2,3] ?
11:23:23 <dolio> More or less.
11:23:46 <NihilistDandy> elliott: It gives me markers in the gutter, but are you looking for something to pop up in the quick-fix window or something?
11:23:47 <dolio> > filter (\n -> n `mod` 3 /= 1) . map (\n -> n*n) $ [1,2,3]
11:23:50 <lambdabot>   [9]
11:24:06 <epta> redundant $
11:24:22 <chrisdotcode> is there anyway to write it forwards? IMO, I prefer it to be sequential in steps, instead of backwards
11:24:45 <NihilistDandy> > filter (`mod` 3 /= 1) . map (^2) $ [1,2,3]
11:24:48 <lambdabot>   The operator `GHC.Real.mod' [infixl 7] of a section
11:24:48 <lambdabot>      must have lower pr...
11:24:53 <dolio> > [1,2,3] & map (\n -> n*n) >>> filter (\n -> n `mod` 3 /= 1)
11:24:55 <elliott> NihilistDandy: well, :Errors lets me see error list. but it smashes multiple-line errors (aka all of GHC's) into one line
11:24:56 <lambdabot>   Precedence parsing error
11:24:58 <lambdabot>      cannot mix `Control.Lens.Combinators.&' [infi...
11:25:13 <NihilistDandy> elliott: Really?
11:25:17 <NihilistDandy> That's odd
11:25:20 <elliott> yes
11:25:20 <dolio> Well, if that weren't a precedence error, then yes.
11:25:23 <elliott> multiple line error messages, that is
11:25:32 <NihilistDandy> Ah
11:25:36 <NihilistDandy> Yes, then I get that, too
11:25:51 <NihilistDandy> Let me google around
11:26:30 <chrisdotcode> dolio: it's a shame, because at that point, the haskell starts getting ugly =/
11:27:17 <chrisdotcode> either that, or I need to read more haskell (or both) :)
11:28:00 <elliott> you get used to it. it's the same order as regular function application, after all
11:29:31 <chrisdotcode> elliott: which way? map first or last?
11:29:43 <elliott> the normal way with (.)
11:29:53 <dolio> g . f $ x = g (f x)
11:30:07 <dolio> x & f >>> g = g (f x)
11:30:07 <elliott> right, what dolio said.
11:30:17 <chrisdotcode> I feel like composition looks backwards... unixy-pipy "|" would have been much cooler... but I'm only still learning, so I'll hold my tongue for now :)
11:30:38 <elliott> chrisdotcode: it's inherited from mathematical notation, you know :p
11:30:47 <elliott> the point is, >>> makes more sense if application is "x f" rather than "f x"
11:30:59 <elliott> composition with (>>>) is *backwards* to how regular function application looks in Haskel.
11:31:02 <elliott> l
11:31:04 <chrisdotcode> elliott: which is unfortunate, because even mathematical composition is backwards...
11:31:19 <chrisdotcode> or, backwards for left-to-right readers, intuitively
11:31:21 <dolio> No, application is backwards.
11:31:22 <NihilistDandy> You bite your tongue :P
11:31:22 * elliott says it's your intuition that's backwards
11:31:27 <chrisdotcode> hahah
11:31:27 <dolio> Go use forth.
11:31:51 <chrisdotcode> honk if forth love?
11:31:54 <elliott> with non-strict evaluation, in (f >>> g), there's a sense in which g executes "before f".
11:32:11 <elliott> > (undefined >>> (1:)) ()
11:32:12 <dolio> Yeah, that's true, too.
11:32:14 <lambdabot>   [1*Exception: Prelude.undefined
11:32:19 <elliott> > ((1:) . undefined) ()
11:32:22 <lambdabot>   [1*Exception: Prelude.undefined
11:32:25 <elliott> now suddenly (>>>) is the one that looks backwards
11:32:26 <dolio> It's also kind of true in unix pipes.
11:32:49 <dolio> If I'm not mistaken.
11:32:52 <chrisdotcode> so how do you reason about composition?
11:32:53 <BMeph> chrisdotcode: Shouldn't that be: "forth love honk if"? ;p
11:33:13 <chrisdotcode> BMeph: my forth knowledge, besides that statement is non-existent ;-)
11:33:18 <elliott> chrisdotcode: I see "length . head" and say "length of head". I think it's best to avoid a notion of "ordering" as much asyou can.
11:33:33 <Primoz128> how many of you guys have imperative paradigm as their first programing paradigm ?
11:33:41 <elliott> "length . filter (> 3) . map (+ 3)" -- length of the elements that are > 3 when 3 is added to them
11:34:01 <elliott> (note how these expressions correspond to a more "declarative" way of stating the problem in English, rather than a more step-by-step recipe-esque approach)
11:34:06 <chrisdotcode> "filter (\n -> n `mod` 3 /= 1) . map (\n -> n*n) $ [1,2,3]"
11:34:06 <chrisdotcode> filter elements divisible by three mapped from numbers 1 to 3, times themselves?
11:34:07 <elliott> er, s/length of the/count of the/
11:34:07 <chrisdotcode> >_>
11:34:08 <BMeph> elliot: So, a fan of OCaML's `o` form? ;)
11:34:31 <NihilistDandy> Primoz128: Lots of people here started in imperative languages
11:34:40 <elliott> chrisdotcode: "the divisible-by-three elements of squaring the integers 1 to 3", or something
11:34:47 <elliott> but actually, I don't translate the code to English in my head at all
11:34:54 <Primoz128> yeh im guessing that
11:34:58 <elliott> I'm just trying to express how I parse it at a deeper level.
11:35:08 <Primoz128> im here and there taking a look at tutorial
11:35:26 <elliott> filter (divisibleBy 3) . map square $ [1,2,3] -- perhaps more appealing
11:35:35 <elliott> the lambdas get in the way a bit.
11:36:03 <NihilistDandy> Primoz128: And you have questions, I imagine
11:36:16 <Primoz128> Probably
11:36:37 <Zariel> Is there a nice way of reducing a list to produce a record?
11:36:39 <chrisdotcode> elliott: oohh, that looks nice.
11:36:51 <elliott> note: divisibleBy and square don't exist. but you can define them
11:36:51 <Primoz128> how is functional programing  to you...
11:37:18 <elliott> filter ((== 0) . (`mod` 3)) . map (^ 2) $ [1,2,3] -- I might even consider writing the original expression this way.
11:37:32 <elliott> you can consider me crazy for considering this, though.
11:37:35 <dolio> That's something else, though.
11:37:42 <elliott> er, right.
11:37:44 <dolio> The expression was not congruent to 1 mod 3.
11:37:47 <dolio> For whatever reason.
11:38:06 <chrisdotcode> but still doesn't "read" as intuitively as the right to left... is it possible to do such chaining in haskell? "[1,2,3].map.reject.exists" etc?
11:38:06 <chrisdotcode> you'd have to make your own (new)type, of course, but is it doable?
11:38:06 <elliott> well, let's pretend it was meant to be. that makes my life easier.
11:38:11 <dolio> :)
11:38:18 <elliott> chrisdotcode: dolio showed you how to do that with (&) and (>>>).
11:38:21 <NihilistDandy> Damn, I was just about to say the same
11:38:40 <elliott> but really, familiarity is what's at work here far more than any kind of innate intuition
11:38:46 <dolio> elliott: Well, you can't do it with (&) and (>>>) because Ed bungled up the precedence of (&) for that. :)
11:38:57 <dolio> Probably because he wasn't concerned about it at all.
11:39:03 <elliott> dolio: true. you can chain (&) though
11:39:07 <elliott> that's even "closer" to the Ruby
11:39:12 <dolio> Yeah.
11:39:45 <chrisdotcode> elliott: yeah, I like ">>>" and "&". but either composition is better (if all the Ph.D guys say so :P), so I feel like I should learn it.
11:39:45 <chrisdotcode> *but maybe
11:40:07 <elliott> :t (>>>)
11:40:10 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
11:40:12 <elliott> it is composition
11:40:14 <elliott> it's just flip (.)
11:40:34 <elliott> anyway, I would personally recommend sticking to (.) and seeing if you get used to it
11:44:01 <mjrosenb> is there a simpler way to express (\l1 l2 -> length l1 `compare` length l2) ?
11:44:13 * hackagebot haxr 3000.9.1 - XML-RPC client and server library.  http://hackage.haskell.org/package/haxr-3000.9.1 (BrentYorgey)
11:44:15 * hackagebot diagrams-lib 0.6.0.3 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-0.6.0.3 (BrentYorgey)
11:44:36 * BMeph I show my Scheme roots by defining: "zP = (==0)"... ;)
11:45:01 <elliott> mjrosenb: comparing length
11:45:05 <elliott> :t comparing length
11:45:08 <lambdabot> [a] -> [a] -> Ordering
11:45:10 <mjrosenb> levi: danke
11:45:15 <mjrosenb> err
11:45:17 <mjrosenb> elliott: ^
11:45:19 <ab9rf> mjrosenb: you can probably do it without actually computing length
11:45:19 <elliott> the same as (compare `on` length), fwiw
11:45:30 <elliott> yeah, it's not as efficient as it could be.
11:45:43 <elliott> infinitely less efficienct for the case where one list is infinite
11:45:49 <ab9rf> mjrosenb: one problem with computing length is that you'll be bottom for infinite lists
11:45:55 * mjrosenb usually assumes that the compiler will take care of it.
11:46:00 <elliott> it won't.
11:46:05 <mjrosenb> ab9rf: I know none of these lists are infinite.
11:46:25 * BMeph usually assumes the the compiler will do what it's TOLD...
11:46:37 <NihilistDandy> elliott: Yeah, I got nothing on this syntastic thing
11:46:58 <elliott> NihilistDandy: hmm, what do you use hdevtools for then?
11:47:17 <NihilistDandy> No, I mean I have no idea how to get it to display multiple lines
11:47:28 <elliott> ah
11:47:35 <elliott> oh well
11:47:50 <NihilistDandy> I've been googling and checking the bug tracker, and other than a couple of tickets closed without associated commits, I have found nothing :(
11:49:07 <NihilistDandy> elliott: Good news, though. I disabled the ghc-mod plugin, and neco-ghc appears to still work
11:49:09 <mm_freak> edwardk: when using Data.Stream.Infinite from your streams library using explicit recursion instead of 'iterate' makes my code faster by a factor of around 7/6
11:49:12 <mm_freak> is this reasonable?
11:49:25 <dmwit> mjrosenb: It's easy to fix, though. Use genericLength and a lazy nat.
11:49:32 <dmwit> ...if the issue comes up.
11:50:07 <elliott> maybe I'll just switch to ghc-mod entirely, I think it handles multi-line errors better
11:50:26 <mjrosenb> dmwit: is generic length with a lazy nat basically map (\x -> ()) ?
11:50:41 <dmwit> pretty much, yup
11:50:48 <elliott> :t comparing (() <$)
11:50:50 <lambdabot> (Functor f, Ord (f ())) => f b -> f b -> Ordering
11:50:54 <elliott> > comparing (() <$) [1,2,3] [4,5,6,7]
11:50:57 <lambdabot>   LT
11:51:00 <dmwit> Oh, I like that!
11:51:04 <elliott> :)
11:51:42 <dmwit> elliott++
11:51:44 <acube> hdevtools seems a lot faster than ghc-mod for mee
11:52:54 <acube> :t comparing
11:52:56 <epta> acube: it's not just for you
11:52:58 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
11:53:02 <chrisdotcode> wait, wait, wait. you can *chain* type signatures to figure out the composed type?
11:53:06 <byorgey> > comparing (() <$) (1 : []) (2 : 3 : undefined)
11:53:08 <lambdabot>   LT
11:53:11 <ab9rf> why not?
11:53:15 <chrisdotcode> :t length map
11:53:17 <lambdabot>     Couldn't match expected type `[a0]'
11:53:17 <lambdabot>                 with actual type `(a1 -> b0) -> [a1] -> [b0]'
11:53:18 <lambdabot>     In the first argument of `length', namely `map'
11:53:24 <byorgey> neato
11:53:33 <acube> > () < ()
11:53:36 <lambdabot>   False
11:53:39 <mauke> :t length .: map
11:53:40 <acube> > compare ()  ()
11:53:42 <lambdabot>     Not in scope: `.:'
11:53:42 <lambdabot>     Perhaps you meant one of these:
11:53:42 <lambdabot>       `.' (imported from Prelude),
11:53:42 <lambdabot>   EQ
11:54:27 <acube> :t (length.) . map
11:54:30 <lambdabot> (a1 -> a) -> [a1] -> Int
11:55:01 <ab9rf> :t (<$)
11:55:03 <lambdabot> Functor f => a -> f b -> f a
11:55:06 <acube> :t fmap fmap fmap length map
11:55:08 <lambdabot> (a1 -> a) -> [a1] -> Int
11:55:26 <Iceland_jack> @src (<$)
11:55:26 <lambdabot> (<$) = (<$>) . const
11:55:50 <mauke> :t fmap fmap fmap length fmap
11:55:51 <lambdabot> (a1 -> a) -> [a1] -> Int
11:55:57 <epta> kosmikus: another lhs2tex question. Suppose there is a large tex file with \begin{code}code\end{code} sections of haskell code. Is there a some way to substitute them with normal code, that lhs2tex produce?
11:56:00 <chrisdotcode> :t length < filter
11:56:01 <chrisdotcode> I think I'm doing something wrong...
11:56:02 <lambdabot>     Couldn't match expected type `[a0]' with actual type `a1 -> Bool'
11:56:03 <lambdabot>     Expected type: [a0] -> Int
11:56:03 <lambdabot>       Actual type: (a1 -> Bool) -> [a1] -> [a1]
11:57:03 <elliott> chrisdotcode: I don't understand what you're trying to do
11:57:25 * geekosaur shakes head at error message; function instance of Num strikes again?
11:57:28 <chrisdotcode> acube: awesome :D
11:58:00 <mauke> geekosaur: how so?
11:58:15 <mjrosenb> @hoogle comparing
11:58:16 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
11:58:18 <acube> :t (+3) < (+4)
11:58:20 <lambdabot> Bool
11:58:27 <geekosaur> hm, no, that's normal I guess
11:58:32 <acube> (+3) < (+4) $ 2
11:58:36 <acube> > (+3) < (+4) $ 2
11:58:38 <chrisdotcode> elliott: I was trying to get the type of a composed function. like if the compiler could deduce Int from length . map
11:58:38 <lambdabot>   The first argument of ($) takes one argument,
11:58:39 <lambdabot>  but its type `GHC.Types.Bool...
11:58:55 <mauke> chrisdotcode: length . map is a type error
11:59:00 <mauke> chrisdotcode: length takes a list, not a function
11:59:02 * geekosaur should have read more closely but is jumping around too much
11:59:42 <elliott> :t length . map
11:59:44 <lambdabot>     Couldn't match expected type `[a0]' with actual type `[a1] -> [b0]'
11:59:44 <lambdabot>     Expected type: (a1 -> b0) -> [a0]
11:59:45 <lambdabot>       Actual type: (a1 -> b0) -> [a1] -> [b0]
11:59:49 <chrisdotcode> mauke: well the result of a mapped function
11:59:50 <chrisdotcode> :t (length.) . map
11:59:53 <lambdabot> (a1 -> a) -> [a1] -> Int
12:00:02 <mauke> see? it's trying (and failing) to unify [...] and ...->...
12:00:07 <chrisdotcode> that's what acube did before and it worked...
12:00:14 <ab9rf> :t \x y -> length map x y
12:00:22 <lambdabot>     The function `length' is applied to three arguments,
12:00:22 <lambdabot>     but its type `[a0] -> Int' has only one
12:00:22 <lambdabot>     In the expression: length map x y
12:00:25 <mauke> :t length (map ?f ?xs)
12:00:29 <ab9rf> :t \x y -> length $ map x y
12:00:33 <lambdabot> (?f::a1 -> a, ?xs::[a1]) => Int
12:00:36 <lambdabot> (a1 -> a) -> [a1] -> Int
12:00:39 <ab9rf> mauke: i hate implicits
12:00:41 <acube> :t (length.) . map -- notice the little dot after length?
12:00:47 <lambdabot> (a1 -> a) -> [a1] -> Int
12:00:49 <ab9rf> @pl \x y -> length $ map x y
12:00:50 <lambdabot> (length .) . map
12:00:52 <ab9rf> see?
12:00:54 <ab9rf> same thing
12:01:01 <mauke> ab9rf: they're great for :t
12:01:07 <ab9rf> mauke: i suppose
12:01:36 <chrisdotcode> so does it or doesn't it work? or does it work when you supply enough information?
12:01:44 <elliott> I don't even know what "it" is
12:01:49 <elliott> do you mean (length.) . map?
12:01:51 <elliott> or some other expression?
12:01:58 <ab9rf> chrisdotcode: it works when what you write is syntactically and semantically valid, and not whe it's not
12:02:06 <elliott> (length .) . map is (\f -> length . f) . map
12:02:13 <ab9rf> ":t dnwqd1234q1431gj5852jdx...4***8123" doesn't "work" either
12:03:27 <acube> elliott: which is (\f -> length . map f)
12:03:42 <elliott> indeed
12:04:14 <Primoz128> This Haskell is trully weird
12:04:22 <Primoz128> so is the english on this <.<
12:04:39 <typoclass> Primoz128: yes it's weird :-) it's also very beautiful
12:05:05 <Primoz128> what is this supposed to be used for ?  5 :: Int
12:05:17 <ab9rf> someone told me the other day that haskell is obsolete and will be superseded by java 8
12:05:29 <Primoz128> Java is imperative
12:05:34 <Primoz128> how can u compare that
12:05:50 <mauke> I hear Hurd will be written in Java 8
12:05:53 <ab9rf> Primoz128: you should complain about _our_ english
12:06:07 <Iceland_jack> mauke: About time!
12:06:26 <Primoz128> my english is too poor to understand much of advanced programing <.<
12:07:54 <Philippa> Primoz128: the ":: Int" bit is a "type annotation" - it says that (this) 5 has the type Int
12:08:06 <Primoz128> I don't understand how is he explaining: http://learnyouahaskell.com/types-and-typeclasses
12:08:31 <Primoz128> i can use :: to check what type something is or... am i wrong ?
12:08:53 <Primoz128> if 5 :: Int
12:08:57 <Primoz128> then true
12:08:59 <Primoz128> ?
12:09:00 <Philippa> it tells it what type it should be. That might be more specific than it /has/ to be, but it can't be something 5 can't be
12:09:14 * hackagebot simplex 0.3.6 - A simple markup language that translates to LaTeX  http://hackage.haskell.org/package/simplex-0.3.6 (JulianFleischer)
12:09:29 <monoidal> Primoz128: literals such as 5 in Haskell are polymorphic. You can use 5 in context where you need a double. Writing 5 :: Int means you explicitly use it as an Int, though often there's no need to do it
12:09:44 <monoidal> :t 5
12:09:44 <Primoz128> ah ok
12:09:46 <lambdabot> Num a => a
12:09:54 <Primoz128> but can i do if 5 :: Int Then bla bla ?
12:10:01 <FireFly> No, it's not a predicate
12:10:11 <FireFly> the type of the expression `5 :: Int` is Int
12:10:13 <monoidal> you can write (5 :: Int) + (3 :: Int), for example
12:10:17 <FireFly> :t 5 :: Int
12:10:20 <lambdabot> Int
12:10:39 <opqdonut> Primoz128: you can think of :: as a type declaration. like in C you would say "int x = 1"
12:10:45 <tromp> you get to choose your flavor of 5
12:11:00 <Philippa> Primoz128: The result of 5 :: Int is still just 5. With the type Int.
12:11:00 <tromp> Int is vanilla
12:11:04 <mjrosenb> Primoz128: for now, you should assume there is no way to check the type information at runtime.
12:11:47 <Primoz128> but it should be
12:12:17 <monoidal> Primoz128: it's a rather advanced technique. In haskell, you will very rarely need this.
12:12:31 <Primoz128> ^^
12:12:38 <Primoz128> I hope learning Haskell is worth it
12:12:44 <mjrosenb> Primoz128: but what should be?
12:13:01 <Primoz128> eh ?
12:13:56 <mjrosenb> Primoz128: you said "15:11 < Primoz128> but it should be", could you elaborate on that a bit?
12:14:35 <Primoz128> lol that was hours ago
12:14:47 <Primoz128> or what..
12:14:53 <mjrosenb> Primoz128: it was 3 minutes ago.
12:15:23 <mauke> @localtime Primoz128
12:15:23 <lambdabot> Local time for Primoz128 is Sat May 04 21:14:50 2013
12:15:23 <typoclass> Primoz128: depends on timezones
12:15:23 <Philippa> Primoz128: time zones. It's 15:14 where mjrosenb is, 20:14 where I am
12:15:23 <mauke> @localtime mjrosenb
12:15:23 <lambdabot> Local time for mjrosenb is Sat May  4 15:15:13 2013
12:16:30 <monoidal> I assume mjrosenb said " for now, you should assume there is no way to check the type information at runtime." and Primoz128 said "but it should be" (meaning "there should be")
12:16:30 <Primoz128> oh but it should be i meant, well i will at soem time need to check for something
12:16:30 <mauke> you never need to check
12:16:50 <monoidal> you can type :t <expression> in GHCi to check its type.
12:17:39 <FireFly> That time is compile time
12:17:39 <mauke> preflex: ? .si
12:17:39 <preflex>  Slovenia
12:25:53 <ryant5000> is there a library that automatically generates "deconstructors" using TH or Generics?
12:26:22 <typoclass> ryant5000: like 'bracket'? or like conduits or something?
12:26:30 <ryant5000> e.g.: given data Blah = Blah A B, it would generate a function unBlah :: (A -> B -> r) -> Blah -> r
12:27:57 <mauke> catamorphism
12:29:17 <ryant5000> mauke: i tried searching for that, but i didn't come up with much on hackage; although admittedly, i wasn't sure how to concretely apply some of the things that did come up
12:30:31 <ryant5000> mauke: maybe this is relevant? http://hackage.haskell.org/packages/archive/pointless-haskell/0.0.8/doc/html/Generics-Pointless-RecursionPatterns.html
12:31:43 <acube> isn't this just what newtype does?
12:31:49 <acube> @hackage newtype
12:31:50 <lambdabot> http://hackage.haskell.org/package/newtype
12:32:21 <typoclass> ryant5000: it sounds like you would often not really save very much? "un (Blah a b) = ... a ... b ..." vs. "unBlah (\a b -> ... a ... b ...)"
12:33:59 <ryant5000> typoclass: yeah, it's not saving a ton, but it's annoying to have to repeat arguments like that
12:34:41 <ryant5000> typoclass: i'm basically reifying function arguments so i can send them over the network or store them, so it's very mindless
12:34:44 <typoclass> ryant5000: true. in cases like "unBlah (+)" it's worth at least something
12:34:50 <ryant5000> typoclass: right
12:35:07 <ryant5000> and when the type changes frequently, it becomes 2-3 places you have to update instead of 1
12:35:16 <ryant5000> anyway, not a big deal
12:35:20 <ryant5000> maybe i'll throw it together sometime
12:35:29 <ryant5000> doesn't seem like an especially big library would be needed
12:36:46 <elliott> lens sort of does it.
12:36:48 <elliott> sort of.
12:38:27 <Shaladdle> Does anyone know of an example of a fuse filesystem written in haskell? I see there are bindings but couldn't come up with a code example
12:39:09 <parcs> nominolo_: is that because of the noDuplicate# primop? so unsafeInterleaveIO is affected too?
12:41:28 <typoclass> Shaladdle: i've actually tried it once. the code was messy, i don't think i can throw it up on hpaste :-)
12:41:29 <geekosaur> Shaladdle, http://new-hackage.haskell.org/package/ScratchFs ?
12:41:32 <charco> Hi!
12:41:35 <typoclass> Shaladdle: got to run now, but if you could specify which part is giving you trouble, maybe i can help
12:41:54 <Shaladdle> geekosaur: thanks will take a look!
12:42:03 <Shaladdle> typoclass: haven't started to write my own code yet, was just curious what was out there
12:42:08 <geekosaur> (it's also on hackage, I'm kinda beta testing the new one though)
12:42:09 <charco> Is there a way to let ghci interprete \n chars of strings?
12:42:17 <geekosaur> (new hackage, not new fuse)
12:42:18 <Shaladdle> typoclass: just did a fuse file system in C++ for a class project
12:42:34 <charco> like Prelude > "Hi \n asd" to print a line with Hi and another with asd
12:42:41 <typoclass> Shaladdle: there's a "print debug output" switch (-d? --verbose?) which you can pass to fusermount or some such. it'll print out every request from fuse to your file system. that switch is worth its weight in gold
12:42:45 <geekosaur> charco, use putStrLn ?
12:42:54 <charco> That's not an option :(
12:43:00 <charco> geekosaur,
12:43:38 <Shaladdle> typoclass: sweet, thanks
12:43:42 <monoidal> charco: why?
12:43:44 <typoclass> Shaladdle: ah i see. well i guess it's pretty much similar in haskell :-) you have this big record containing "function pointers" (= regular functions) and you pass it into hfuse. it'll then call those functions
12:43:49 <monoidal> charco: default behavior is very sensible
12:44:15 * hackagebot yesod-fay 0.4.0 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.4.0 (MichaelSnoyman)
12:45:04 <Shaladdle> typoclass: Gotcha. I'm still kind of new to haskell, so I also wanted a good example of IO heavy/state heavy code
12:45:19 <monoidal> charco: you can use ghci -interactive-print=putStrLn, then ghci will use putStrLn instead of print as default (note this will require a call to 'show' often)
12:45:21 <charco> monoidal, it's for an intro class to haskell, they aren't supossed to use IO monad, they just want to pretty-print in ghci one multi line string
12:46:16 <monochrom> then don't use string. there are infinitely many more interesting data structures to play with on GHCi and stay pure-functional
12:46:34 <monochrom> Haskell is not shell script. everything is not a string.
12:46:49 <monoidal> charco: you can define your own string datatype that will show '\n' as "next line" character. that's even more ugly
12:47:22 <charco> monochrom, they just want to derive an instance of show for their structures
12:47:24 <monoidal> charco: IMO it's best to tell students that "use putStrLn to print a string verbatim" and tell the details later
12:47:59 <monochrom> then don't use \n
12:48:14 <charco> monochrom ...
12:48:42 <monochrom> I am serious. \n is unnecessary for that purpose
12:48:46 <charco> monoidal, I think I will tell them that
12:50:29 <monochrom> essentially you seem to be saying you want all the bells and whistles and cuteness and animations and it must not use IO. frankly that's self-contradictory.
12:51:27 <charco> monochrom, yeah.. I should have guessed that asking for "interpret \n char as an escape char" is the same as cuteness and animations :p
12:52:13 <monochrom> ok, "cuteness and animations" is an exaggeration. but ask yourself why is \n used at all. answer: layout.
12:53:21 <charco> Yeah, I know they don't need \n at all, they don't even need to create a function to show the datatype
12:53:56 <charco> They just want to
12:54:13 <monochrom> so you're trying to control where things appear on the screen and it must not use IO. well that's either contradictory or kludgy. I wouldn't bother.
12:54:59 <monochrom> human wants many things, and not all are worth the effort.
12:56:44 <monochrom> I have no problem with cuteness and animations. I would actually teach that early. but I would not avoid IO. and I would spend little time on strings.
12:59:10 <charco> monochrom, but why is it so hard to interpret the escape chars and put them in the cli ?
12:59:38 <monochrom> no, I have a better question.
12:59:55 <monochrom> why is it so hard to screw strings and display their data structures graphically?
13:00:11 <monochrom> why is it so hard to screw cli?
13:00:36 <monochrom> why is it so hard to get IO involved?
13:00:58 <monochrom> well, that turns out to be 3 questions rather than 1. I can't count.
13:01:09 <cmccann> why is it so hard to count?
13:01:11 <geekosaur> charco, you would have to provide a replacement Show instance for Char with a different showList implementation
13:01:56 <cmccann> this all sounds like expecting GHCi to do something it doesn't and be something it isn't.
13:01:58 <charco> geekosaur, but It should have to be Show a => a -> IO , right?
13:02:44 <geekosaur> what?
13:03:45 <geekosaur> ghci does an implicit ```print``` (aka ```putStrLn . show```) on Show-able values. if you want to change how those values display, you change the Show instance
13:06:10 <charco> geekosaur, oh!
13:06:17 <charco> geekosaur, thanks! :)
13:07:01 <geekosaur> and this is why you also go around ghci's default by invoking putStrLn directly with what you want to print
13:08:56 <elliott> note that the output of "show" should be lexically valid Haskell.
13:14:11 <cmccann> elliott: not that anything ever breaks that rule
13:14:33 <cmccann> though in the absence of a corresponding Read instance it's hard to care too much
13:14:35 <elliott> nothing I'd associate with, anyway
13:16:56 <mreh> I want to help with clckwrks
13:17:46 <cmccann> oh man I got my Epic badge on Stack Overflow. it is so cool.
13:17:56 <sm> mreh: #happs is the place and stepcut is the guy
13:18:04 <mreh> sm: right
13:18:30 <mreh> ta
13:19:45 <Eduard_Munteanu> cmccann: you should change your nick to epicmccann :P
13:20:02 <mreh> cmccann lets see your profile then
13:20:21 <Eduard_Munteanu> Can you also get a monic badge?
13:20:22 <cmccann> mreh: http://stackoverflow.com/users/157360/c-a-mccann ?
13:20:41 <cmccann> Eduard_Munteanu: I have a "monads" tag badge, that has the same first three letters
13:20:54 <Eduard_Munteanu> Nice.
13:22:43 <cmccann> Eduard_Munteanu: I also have the gold [haskell] tag badge. for future reference, here is a handy list of people you can make fun of for spending too much time on SO: http://stackoverflow.com/badges/210/haskell?userid=157360
13:22:59 <cmccann> especially that ehird guy
13:23:46 <typoclass> who is the ehird guy?
13:23:48 <elliott> cmccann: that C. A. McCann guy is even worse.
13:24:00 <elliott> who does he think he is, abbreviating his name like that?
13:24:00 <cmccann> typoclass: that's elliott
13:24:05 <elliott> typoclass: it's cmccann.
13:24:08 <elliott> I'm C. A. McCann.
13:24:09 <typoclass> cmccann: ooh i see :-)
13:24:10 <cmccann> elliott: yeah I know who uses initials anyway
13:24:19 <tgeeky> I'm C. A. McCann.
13:24:23 <typoclass> elliott: sounds plausible
13:24:30 <cmccann> I am not spartacus >:[
13:24:50 <tgeeky> I shot the sherrif, killed the deputy, set the house on fire that John Dorner was in, and then retired at age 25.
13:24:58 <elliott> cmccann: I got six upvotes from an answer being linked on /r/haskell today!
13:25:04 <elliott> all my answers are like little investments.
13:25:15 <elliott> soon I will trade all my rep in for bitcoins.
13:25:17 <tgeeky> elliott: they never pay off?
13:25:37 <cmccann> elliott: what's the exchange rate on that
13:25:50 <elliott> cmccann: it's pointless telling you, because it will be wildly different in five seconds.
13:26:02 <cmccann> hahaha
13:26:30 <tgeeky> is stackoverflow rep even transferrable? :o
13:26:44 <cmccann> tgeeky: via bounties I guess. sort of.
13:26:49 <nicoo> tgeeky: I don't think so
13:27:02 <nicoo> cmccann: Ah? How does that work ?
13:27:03 <elliott> cmccann: you should give me all your rep through bounties.
13:27:04 <elliott> that would be fun.
13:27:20 <cmccann> nicoo: you can set a bounty and then manually award it to anyone
13:27:27 <tgeeky> we shold hack in and swap people's haskell rep for people's PHP rep and vice versa, and watch the world burn
13:27:44 <cmccann> I got a bunch of rep on meta.SO that way because of someone who wanted to dump all his rep so he could pretend he doesn't waste so much time on meta.SO
13:28:14 <typoclass> cmccann: excellent idea. i'll award him some rep for that
13:28:15 <cmccann> (not actually joking there, and I don't think he worked because he still has lots of worthless meta.SO rep)
13:28:22 <cmccann> s/he/it
13:28:44 <nicoo> cmccann: Ah, ok
13:28:57 <cmccann> it looks like the question has since been deleted though :[
13:31:54 * tgeeky was subscribed to daily haskell tags from stackoverflow, but is not anymore. Didn't read a single one.
13:33:02 <cmccann> I have a weird compulsion to keep answering questions.
13:33:13 <epta> <typoclass> who is the ehird guy? <--- and where is he?
13:33:20 <osfameron> cmccann: what is the airspeed of an unladen swallow?
13:33:37 <nicoo> cmccann: Isn't it called procrastination ?
13:33:58 <epta> cmccann: how can I get a value from a monad?
13:34:07 <cmccann> augh
13:34:32 <tgeeky> osfameron: 1, in appropriate units.
13:34:43 <cmccann> @quote monochrom IO.String
13:34:43 <lambdabot> monochrom says: How do I extract the IO out of IO String?
13:34:58 <typoclass> epta: on stack overflow :-) not on #haskell
13:35:06 <nicoo> By writting unsafeCoerce :D
13:35:07 <elliott> cmccann: [question that is obviously caused by numeric defaulting in GHCi]
13:36:03 <cmccann> elliott: is it just me or did the questions about I/O buffering behavior disappear at some point
13:36:09 <cmccann> did GHC's behavior change?
13:36:28 <epta> typoclass: the most shamefull part of this story is that I actually have asked it one time
13:36:39 <elliott> cmccann: not sure
13:37:08 <elliott> cmccann: Should I learn Haskell or Lisp or Erlang or Epigram 2 or SNOBOL???
13:37:14 * elliott awaits cmccann's vote to close.
13:37:31 <epta> typoclass: or wait, are you talking about ehird?
13:37:55 <cmccann> elliott: nah, I already answered that question twice
13:38:04 <cmccann> two of my five highest-score answers :[
13:38:06 <typoclass> epta: no, i just asked who that is. it was just a quick question :-)
13:38:20 <elliott> cmccann: including the snobol part?
13:39:20 <cmccann> elliott: I think one of them might have mentioned scala, which also starts with an S, and is therefore clearly almost the same.
13:39:23 <cmccann> like C/C++
13:39:43 <epta> The curiosity of ehird's existing on stackoverflow and not here is almost equal the curiosity of ski's existing here and not on stackoverflow
13:40:21 * elliott wonders if he should spoil the surprise and admit that that's him
13:40:46 <epta> It's not true
13:40:57 <Taneb> I'm ehird
13:41:11 <cmccann> aw, I wanted to be ehird this time
13:41:44 <epta> Ok, but who gonna be ski on stackoverflow then?
13:41:59 <cmccann> epta: maybe elliott, since obviously he can't be ehird anymore.
13:42:32 <hpaste> “Anonymous Coward” annotated “hmac sha512” with “hmac sha512 (annotation)” at http://hpaste.org/73282#a87253
13:42:37 <epta> How could anybody recognise that someone is ski on stackoverflow?
13:43:09 <cmccann> .oO(he'd probably give himself away eventually)
13:43:28 <cmccann> wait, I think I did that wrong.
13:43:31 <cmccann> oh well.
13:44:22 <FireFly> I think you need some spaces or something
13:44:35 <cmccann> yeah maybe
13:45:19 * FireFly . o O (how do thought bubbles work?)
13:45:42 <int-e> . o O ( beautifully )
13:46:06 <elliott> wait, *does* ski have an SO account?
13:46:08 <epta> There should be functional composition instead of «o»
13:46:20 <jfischoff> preflex seen ski
13:46:20 <preflex>  ski was last seen on #haskell-blah 38 days, 4 hours, 52 minutes and 31 seconds ago, saying: * ski . o O ( "The ontology of the lambs" by ttmrichter by 2012-09-17 at <http://www.txt.io/t-2hv4m> about Technicians,Engineers,Scientists)
13:46:25 * Eduard_Munteanu makes some smoke rings: =o    =o    =o
13:46:30 <cmccann> 38 days?!
13:46:31 <cmccann> :[
13:46:34 <NihilistDandy> Yeesh
13:46:42 <jfischoff> ski is so badass
13:47:07 <epta> Maybe it is a season or something?
13:47:08 <elliott> hm, I didn't notice ski was gone. but now I retroactively notice the absence of ski.
13:47:14 <elliott> preflex: xseen ski
13:47:14 <preflex>  ski was last seen on freenode/#haskell-blah 38 days, 4 hours, 53 minutes and 24 seconds ago, saying: * ski . o O ( "The ontology of the lambs" by ttmrichter by 2012-09-17 at <http://www.txt.io/t-2hv4m> about Technicians,Engineers,Scientists)
13:48:00 <Eduard_Munteanu> We need a preflex-seen for when somebody passes away... imagine your last phrase appearing upon the tombstone. You'll be definitely very careful about your last breath.
13:48:16 <elliott> something tells me there is likely a simpler explanation for his absence :P
13:48:33 <Eduard_Munteanu> Oh, heh... I didn't imply that. :)
13:48:49 <epta> Actually he is in the /names
13:49:15 <Philippa> all that tells you is that something somewhere goes PONG once in a while on his behalf
13:49:44 <Philippa> the last year or so's been "odd" for me in that regard: I actually shut down my last remaining client fairly regularly!
13:49:47 <elliott> hm, I should hire someone to do that for me in real life.
13:50:02 <elliott> just sit there and go "pong" every hour or so.
13:50:51 <epta> hire someone to pretending ski in real life
13:51:15 <Eduard_Munteanu> preflex: seen ddarius
13:51:15 <preflex>  ddarius was last seen on #haskell 245 days, 11 hours, 48 minutes and 4 seconds ago, saying: > let f n = g (n-1) where g k [] = []; g 0 (_:xs) = g (n-1) xs; g k (x:xs) = x:g (k-1) xs in f 5 "hello, world"
13:51:22 <cmccann> :[ :[ :[
13:51:35 <Eduard_Munteanu> preflex: seen kmc
13:51:35 <preflex>  kmc was last seen 341 days, 13 hours, 28 minutes and 57 seconds ago, saying: <private message>
13:51:47 <Eduard_Munteanu> That's some style.
13:51:51 <edwardk> he lives, he's just hiding from us on other channels
13:51:59 <Eduard_Munteanu> Yeah, I know.
13:52:08 <Eduard_Munteanu> preflex: seen BONUS
13:52:08 <cmccann> I've seen ddarius on LtU I think.
13:52:08 <preflex>  BONUS was last seen on #haskell 2 years, 5 days, 1 hour, 24 minutes and 22 seconds ago, saying: yeah i think that's better as well
13:52:14 <kosmikus> epta: I don't understand your question.
13:52:39 <cmccann> clearly BONUS retired to live on a tropical island with all the money he made from LYAH.
13:52:55 <edwardk> clearly
13:53:21 <cmccann> I do wish kmc and ddarius were still around in here though :[
13:53:36 * Eduard_Munteanu stares towards edwardk 
13:54:05 * tgeeky puts an appropriately sized black hole between him and edwardk to make Eduard's attempt futile
13:54:12 <edwardk> I'm going to go have dinner with ddarius in an hour or so. I'll make a case for him coming back ;)
13:54:18 <Eduard_Munteanu> Yay.
13:54:30 <tgeeky> edwardk: tell him tgeeky says hi!
13:54:34 <edwardk> Will do
13:54:48 <Eduard_Munteanu> Don't forget to mention ##categorytheory, there are 2 reasons to come back now!
13:54:58 <tgeeky> that should be funny. I wonder s/he remembers me.
13:55:13 <elliott> cmccann: kmc is still on freenode, he's just an IRC hermit.
13:55:15 <cmccann> ddarius left a comment on LtU this week so we know he's not hiding completely :P
13:55:20 <edwardk> At last check his absence was more one of 'can't get on from work, and reinstalled home machine so didn't have his favorite client' not 'screw this i'm done with #haskell'
13:55:31 <epta> kosmikus: is there a way to have that nice-looking haskell listings that smart guys had in their papers? Looks like they just write in literate haskell and then do lhs2tex
13:55:36 <Eduard_Munteanu> elliott: that must be something, being a recluse on IRC as well
13:56:07 <Eduard_Munteanu> I hear some isolate themselves in real life to escape IRC! :O
13:56:29 <edwardk> Poor 'absence', he much get so many false positive pings from his IRC client. Not nearly as many as 'so' did though.
13:56:33 <edwardk> er so does
13:57:26 <cmccann> edwardk: unlike you, who gets too many true positive pings?
13:57:27 <edwardk> Eduard_Munteanu: shocking. i've pretty much been clued to IRC off and on since 93 or so. 20 years of chatting have made me the introvert I am today
13:57:34 <edwardk> er glued to
13:58:34 <edwardk> cmccann: if i leave my machine on overnight there are typically 50 messages for me in the morning
13:58:51 <cmccann> hahaha
13:59:08 * tgeeky doesn't quite understand how that counts as introverted
13:59:35 <edwardk> tgeeky: 'introvert' was very much tongue in cheek
13:59:41 <cmccann> I think dcoutts has (or at least had at some point) his set to ping when cabal was mentioned
13:59:47 <cmccann> that probably got tedious
13:59:55 <elliott> that must be fun when people are complaining about cabal
13:59:58 <edwardk> yeah he does, or he's just the quietest lurker of all times
14:00:11 <elliott> cabal cabal cabal
14:00:30 <edwardk> it has to be rather soul crushing given that the usual litany against cabal is the same complaint repeated over and over by new people
14:00:34 <cmccann> elliott: yeah he shows up implausibly often to help people when they complain about it not working
14:00:34 <Eduard_Munteanu> You mentioned both dcoutts and cabal, that must have some result.
14:01:10 <tgeeky> edwardk: that doesn't really make their complaints invalid
14:01:13 <edwardk> at least with lens i get to log in and see a whole bunch of pings from people suggesting lens as the solution for everything
14:01:13 <tgeeky> necessarily*
14:01:20 <elliott> doesn't make the soul crushing any less valid either
14:01:21 <edwardk> much more uplifting
14:01:47 <elliott> edwardk: you should put "reflection" on ping. then you'd see my promotion too!
14:01:57 <cmccann> edwardk: and most of the complaints about your libraries seem to be things you agree with, and just consider irrelevant, acceptable trade-offs, or "features"
14:02:00 * Eduard_Munteanu retreats to his #eduard-cave
14:02:09 <edwardk> it already is ;)
14:02:20 <tgeeky> Eduard_Munteanu: I assume the answer from Philipa was effectively "no"?
14:02:27 <tgeeky> Eduard_Munteanu: I suppose I needn't ask
14:02:43 <edwardk> cmccann: i usually reply to the most egregious complaints with commit access
14:03:07 <cmccann> harsh yet fair
14:03:12 <Eduard_Munteanu> tgeeky: she still seemed upset about it
14:03:52 <edwardk> 'if you care enough to complain you may care enough to fix' its the programmer equivalent of 'if you can dodge a wrench you can dodge a ball'
14:04:06 <tgeeky> Eduard_Munteanu: it is rather odd to ban me for personal reasons but then also leave #-blah herself.
14:04:32 <tgeeky> Eduard_Munteanu: that was surprising to learn
14:04:32 <Eduard_Munteanu> tgeeky: as in generally unwilling to -b, but she didn't clearly refuse either
14:04:42 <Eduard_Munteanu> tgeeky: that's unrelated I think
14:04:46 <tgeeky> Eduard_Munteanu: well, she did, because she didn't
14:04:52 <elliott> it's even odder to talk about off-topic matters involving someone who has talked in the past ten minutes in the third person
14:05:01 <Philippa> edwardk: say hi to ddarius for me?
14:05:08 <edwardk> will do
14:05:45 <cmccann> I thought -blah was an imaginary place that shachaf invented as a destination for conversations he doesn't like.
14:06:15 <nicoo> cmccann: Perhaps it started out that way
14:06:39 <elliott> shachaf tends to be the one complaining when people redirect bad convos to -blah :P
14:06:41 <Philippa> y'know, I can't remember whether -blah was founded before or after shachaf first showed up. I'm getting old, clearly
14:06:43 <FireFly> So that's why lens discussion is forbidden in #-blah
14:06:51 <tgeeky> elliott: I have nothing to hide. I got back from AFK after Philipa was offscreen, so I didn't know.
14:07:04 <Eduard_Munteanu> FireFly: obviously Haskell is offtopic there :)
14:07:19 <cmccann> elliott: to be fair, shachaf complains about a lot of things.
14:07:20 <FireFly> Well, yes
14:07:22 <edwardk> when did lens discussion get forbidden in blah, for the longest time it was (everything - (haskell - lens))  which carefully included lens discussion
14:07:25 <elliott> I'm not sure you can call lens Haskell!
14:07:30 <FireFly> Oh, right
14:07:38 <elliott> edwardk is going to decrease my salary now.
14:07:50 <edwardk> elliott: watch out, it may go negative
14:07:55 <Eduard_Munteanu> elliott: clearly one can implement lenses in C, yeah
14:08:01 <tgeeky> Philippa: Surely it's fair to unban me at this point.
14:08:25 <Eduard_Munteanu> I don't think that gets through.
14:08:27 <edwardk> elliott: after that a 50% raise would be a bad bad thing
14:08:41 <tgeeky> Eduard_Munteanu: yeah, ignore is tricky that way. You never know :O
14:08:51 <elliott> edwardk: :(
14:09:02 <elliott> edwardk: implicit parameters and fclabels FOREVER!!!
14:09:11 <tgeeky> I suppose I could simply evade by getting a registered login thingy
14:09:19 <edwardk> i think i broke the elliott
14:09:24 <Eduard_Munteanu> tgeeky: I wouldn't suggest that :(
14:09:25 <cmccann> elliott: monad lenses as far as the eye can see
14:10:02 <tgeeky> Eduard_Munteanu: as long as an op can't or won't defend the reason for banning, and is actively evading any discussion about it
14:10:13 <tgeeky> I don't see why not, especially for something as decidely unserious as #-blah
14:10:55 <elliott> can we not talk about ban evasion of another channel in #haskell? thanks.
14:11:01 <edwardk> evading bans is a good way to get one more permanently applied
14:11:07 <edwardk> but i agree with elliott
14:11:49 <cmccann> also, unserious IRC channels always have the most srs bzns drama
14:12:11 <cmccann> since there's nothing more important to talk about it, like how confusing lens is
14:12:12 <Eduard_Munteanu> Well, I'm not sure if/how you should approach her.
14:12:28 * BMeph wonders: Why so unserious?!?
14:12:50 <Eduard_Munteanu> -blah is seriously funny, what are you talking about? :P
14:12:53 <Jeanne-Kamikaze> is there a more straightforward / conventional / idiomatic / whatever way to make a thread evaluate a pure function application ? It seems that combining async . evaluate . force does the job, but still. Please see link for an example: http://hpaste.org/87254
14:13:36 <Eduard_Munteanu> tgeeky: I guess she would've removed the /ignore when I asked, assuming there was some intention to
14:13:48 <cmccann> Jeanne-Kamikaze: pseq?
14:13:56 <Eduard_Munteanu> Anyway, this is getting awkward given you're both here.
14:13:56 <nicoo> elliott: I would suggest moving tgeeky's discussion of ban evasion to -blah.
14:14:10 <tgeeky> nicoo: how deliciously ironic
14:14:17 <Jeanne-Kamikaze> cmccann, add to the question: that can bed combined with IO
14:14:20 <k00mi> are there Foldable instances for UArray somewhere?
14:14:24 <nicoo> tgeeky: You are welcome :D
14:14:31 <Jeanne-Kamikaze> s/bed/be
14:14:37 <tgeeky> nicoo: I thought of it, but I didn't think an involved party could pull it off :)
14:14:48 <nicoo> \o/
14:15:06 <cmccann> I'm not sure what you mean by combined with IO here.
14:15:43 <nicoo> tgeeky: Btw, you can use /cs ACCESS #haskell-blah LIST to list channel admins
14:16:19 <tgeeky> nicoo: yep. This has all been discussed, but can't be discussed further.
14:16:22 <Eduard_Munteanu> I would wait a bit before pinging this issue again.
14:26:33 <FreeFull> Are there any types in Haskell for which you can't write a functor instance?
14:26:38 <elliott> yes
14:26:44 <tgeeky> FreeFull: many many
14:26:44 <elliott> well, depends what you mean
14:26:52 <elliott> you can write a Functor instance for any type of kind * -> * with undefined
14:26:55 <elliott> but it might not obey the functor laws
14:27:03 <elliott> here's an example of one that can't: data Foo a = Foo (a -> Int)
14:27:12 <elliott> or data Endo a = Endo (a -> a)
14:28:36 <acube> are all those things Contravariant functors?
14:28:44 <monoidal> data A a where A :: A Int
14:28:47 <monoidal> acube: ^
14:29:07 <hpc> monoidal: that can be done
14:29:10 <acube> instance Functor A where fmap f (A x) = (A x)
14:29:14 <hpc> er, oh it can't
14:29:18 <acube> ?
14:29:23 <hpc> acube: it's a gadt
14:29:26 <monoidal> acube: value A does not take parameters
14:29:34 <acube> oh right
14:29:42 <monoidal> acube: and if you try fmap f A = A, it will be a type error when f is not Int -> Int
14:29:47 <hpc> oh!
14:29:51 <hpc> fmap f x = x
14:29:59 <hpc> no matching on x, no constraints brought into scope
14:30:04 <monoidal> but a type error
14:30:12 <hpc> it should work
14:30:15 <monoidal> it won't
14:30:20 <elliott> acube: Endo isn't contravariant
14:30:30 <elliott> you can make it an instance of Invariant, see invariant package
14:30:36 <monoidal> hpc: There exists a function Int -> Bool, and a value of type A Int. If fmap existed, there would be a value of type A Bool, but there is none.
14:30:56 <hpc> er, dammit
14:31:02 <hpc> you do need to match
14:31:06 <hpc> but then you can't match
14:31:28 <cmccann> elliott: DList a is defined as [a] -> [a] and it has a functor instance!
14:32:02 <FreeFull> instance Functor Endo where fmap f (Endo x) = Endo (f.x)
14:32:07 <elliott> cmccann: it doesn't follow the laws over all the values!
14:32:07 <FreeFull> What's wrong with this?
14:32:17 <elliott> cmccann: you could make a DList type that only admits proper DLists in Coq.
14:32:21 <elliott> that sounds interesting.
14:32:24 <cmccann> elliott: I AM THE LAW
14:32:27 <cmccann> and yes
14:32:33 <monoidal> FreeFull: assuming x :: a -> a and f :: a -> b, f . x will not have type b -> b
14:32:38 <aristid>  OHAI LAW
14:32:43 <FreeFull> Oh, right
14:32:45 <monoidal> FreeFull: i.e. your fmap will not give a value of type Endo b
14:33:02 <cmccann> what types can or cannot be functors is trickier if you allow abstract types that enforce extra invariants
14:33:22 <FreeFull> Endo does seem to be a Monoid though
14:33:38 <byorgey> yes, it is
14:34:15 <monoidal> FreeFull: note it's a different kind of question (ha ha)
14:34:38 <cmccann> monoidal is clearly an expert here.
14:34:55 <elliott> monoidal: you should /nick soeasy.
14:41:06 <kosmikus> epta: sorry, it sounds to me as if your question is "is lhs2tex usable?" to which the answer is "yes". I still don't understand what exactly you want to know.
14:41:34 <bigHaskellBooty> Does anyone know if there is a series of problems, kind of like 99 Haskell problems, that could help you get into monads?
14:41:42 <bigHaskellBooty> I'm looking for, like, 99 Monad problems
14:42:03 <monoidal> bigHaskellBooty: there are exercises in http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
14:42:42 <shanse> i got 99 problems but a monad tutorial aint one
14:42:52 <monoidal> after that, I would reimplement standard problems
14:42:57 <monoidal> *standard monads
14:43:26 <blackdog> shanse: c'mon, you can do better than that. at least start with "if you havin' bind problems, i feel bad for you son"
14:44:50 <bigHaskellBooty> Yah, I did look over that tutorial. I dont' know if something so straight forward exists, but I'm looking for a sensibly progressing list of problems that goes something like: Do this problem. Use X Monad (and it would actually make sense/be instructive to use that Monad). Attempt the next problem.
14:45:16 <Philippa> cue 99 interpreters :p But yeah
14:45:37 <Philippa> (definitely a use case for Reader & StateT Reader)
14:46:56 <Philippa> for that matter, learning to play "spot the thinly-veiled interpreter" is useful anyway
14:46:59 <apples> is it possible to use the tying the knot technique to implement a graph?
14:47:31 <Philippa> that depends on what operations you want to be able to finish in finite time: it's not a good idea generally
14:47:54 <Philippa> (you don't actually have a graph: you have an infinitely-sized tree that's derived from the graph)
14:48:23 <apples> hrm, i see
14:49:18 * hackagebot texmath 0.6.1.4 - Conversion of LaTeX math formulas to MathML or OMML.  http://hackage.haskell.org/package/texmath-0.6.1.4 (JohnMacFarlane)
14:49:32 <Philippa> there are ways and means, but you end up using the knot-tying as at most a neat optimisation in the context of another style of implementation
14:49:39 <Philippa> (maybe you use node IDs to break loops, for example)
14:50:37 <cmccann> pure data structures containing loops usually can't share substructures, which kinda sucks.
14:50:44 <apples> so should i just have something like an [(Int, a)] for nodes and [(Int, Int)] for edges, then?
14:50:58 <FreeFull> Are there any "Use Haskell to solve all programming problems forever" tutorials?
14:51:11 <cmccann> apples: I'd probably use IntMap instead for the nicer API if nothing else
14:51:22 <tgeeky> Philippa: I must have missed apples' problem. How did we know what kind of graph he has?
14:51:23 <cmccann> @faq can haskell solve all programming problems forever?
14:51:24 <lambdabot> The answer is: Yes! Haskell can do that.
14:51:44 <tgeeky> cmccann: forever... that's asking a lot
14:51:56 <cmccann> tgeeky: sure, but you heard lambdabot.
14:52:01 <cmccann> that settles it.
14:52:12 <FreeFull> I wasn't asking if it was possible
14:52:16 <shanse> blackdog: sorry, I dont actually know the lyrics
14:52:19 <FreeFull> I was asking if there was a tutorial on it =P
14:52:22 <apples> the reason for my asking is that i'm interested in an efficient implementation of A*
14:52:34 <shanse> next time, though!
14:52:40 <Saizan> bigHaskellBooty: not quite what you asked but the examples could help http://www.haskell.org/haskellwiki/All_about_monads
14:53:00 <cmccann> apples: most standard graph algorithms are unlikely to work well with a pure immutable graph built with knot-tying
14:53:19 <FreeFull> I looked at monad laws, and went "What's the big deal all those people make about monads being hard to understand"
14:53:47 <cmccann> FreeFull: people make a big deal out of it because they think it's a big deal because of all the other people making a big deal out of it.
14:53:50 <Philippa> apples: There are better options for maps than association lists, thankfully
14:54:02 <blackdog> FreeFull: the monad laws are pretty trivial. the more interesting part is that all this structure comes from them - you couldn't say a priori that they'd be a useful abstraction.
14:54:16 <Philippa> apples: I think there's also a graph structure or two in the standard libs and certainly on Hackage
14:54:30 <apples> yeah, i could just use an IntMap like cmccann suggested
14:54:34 <apples> i'll look around on hackage
14:54:53 <cmccann> IntMap is a good default plan for hand-rolling your own simple version
14:55:07 <cmccann> looking on hackage is a better plan if you want something fancier or pre-made
14:55:25 <Philippa> cmccann: I'm wondering what you can sensibly do with the zipper of a loopy structure now. Which is annoying, because I'm pretty sure I saw Bird talk about fun and games with that a year or so back!
14:55:37 <FreeFull> Can anyone show me a practical use of Profunctors?
14:55:39 <apples> well, i'm not super interested in actually implementing it myself, just trying to get a feel for some of the time complexities involved
14:55:44 <cmccann> I seem to recall graphs being one of those things where there are more nifty API ideas than usable implementations though
14:55:48 <Taneb> FreeFull: Control.Lens.Iso
14:56:04 <edwardk> FreeFull: 90% of lens
14:56:22 <cmccann> edwardk: the other 10% is unsafeCoerce, right
14:56:28 <Philippa> cmccann: I'm definitely not in a position to recommend a specific structure. Which is annoying, I ought to pick a default for spotting binding groups/strongly connected components...
14:56:33 <edwardk> cmccann: no thats the first 90%
14:56:36 <cmccann> haha
14:56:50 <edwardk> the other 10% uses 'id' instead
14:57:28 <Philippa> as in "idon'tknowwhyIneededthatunsafeCoerce"?
14:57:29 <FreeFull> id's twin brother id . id feels underappreciated
14:57:35 <tgeeky> apples: perhaps these: http://www.ukuug.org/events/agm2010/ShortestPath.pdf
14:57:37 <cmccann> Philippa: standard zippers are pretty much useless when a structure has multiple paths to the same "location"
14:57:38 <tgeeky> apples: will interest you
14:57:51 <apples> thanks, i'll take a look
14:57:58 <cmccann> I'm sure there are clever tricks though
14:58:03 <Philippa> cmccann: usually, yeah. Bird's example had a bit more structure than that, though
14:58:05 <apples> oh nice, spj :)
14:58:16 <tgeeky> apples: from http://stackoverflow.com/questions/14012603/how-to-implement-dijkstra-algorithm-in-haskell
14:58:17 <FreeFull> tgeeky: Bah, it's not 100% comic sans
14:58:27 <tgeeky> FreeFull: you're meant to take some of it seriously
14:58:30 <Philippa> (all paths had to pass through known points)
14:58:33 <BMeph> Is there an "IntSetMap" for maps to collections of Ints? :)
14:59:37 <tgeeky> BMeph: I think... I think... I forget. There are multisets and signed multisets. I think there is an IntSetMap somewhere...
15:00:54 <tgeeky> BMeph: I can't remember where to look. Hopefully you weren't serious.
15:01:53 <apples> argh, i should spend more time in here
15:01:54 <BMeph> tgeeky: Why wouldn't I be? I'm not all that funny when I try to be.... ;)
15:03:37 <cmccann> BMeph: what, you just want a pre-defined "IntMap IntSet" combination?
15:04:07 <tgeeky> cmccann: didn't say the source was integers, though
15:04:20 <cmccann> ah
15:04:45 <cmccann> well, I've wanted a pre-defined "Map k (Set v)" type a few times just because I'm lazy.
15:05:13 <Peaker> what's a nice, small, self-contained lib to get a Vector2/Vector3/etc types from, with Applicative instances, Num instances, etc?
15:05:13 <lambdabot> Peaker: You have 1 new message. '/msg lambdabot @messages' to read it.
15:05:25 <tgeeky> Peaker: something conal wrote, probably
15:05:39 <Peaker> @tell t7 Yeah, still working on lamdu
15:05:40 <lambdabot> Consider it noted.
15:05:42 <cmccann> vector-space and linear exist
15:06:01 <Peaker> they're much bigger than just a simple uni-typed tuple...
15:06:22 <elliott> Peaker: linear!
15:06:46 <cmccann> Peaker: anything much simpler is probably trivial enough that nobody would bother putting it on hackage
15:07:25 <BMeph> cmccann: Basically, yes. I want a specialized "Map Int (Set Int)" structure. Is there a problem with that? :)
15:08:07 <dixie_> interesting DBus vs. dbus, two different libraries with difference in uppercase/lowercase letters :)
15:08:31 <cmccann> BMeph: makes sense to me
15:09:00 <Peaker> cmccann, I think triviality is a really bad reason not to put something on hackage
15:09:11 <Peaker> cmccann, sharing the same trivial vector type amongst various packages would be nice
15:09:16 <cmccann> it would
15:10:29 <Philippa> Peaker: I'd agree, except it has a way of landing you the job of maintaining it when someone wants to improve the implementation
15:11:47 <cmccann> mostly I just stopped caring about the size and complexity of my dependencies
15:12:02 <cmccann> because I know by the time I do anything interesting I'll want at least one horrendously complicated thing anyway
15:12:17 <Peaker> cmccann, but I have to choose between using OpenGL's vector (I depend on OpenGL), vector-space, linear, tensor, ...
15:12:49 <cmccann> if you depend on OpenGL why not just use those, then?
15:13:56 <cmccann> anything else will make you write a bunch of conversion back and forth if you're using them with GL
15:14:16 <cmccann> and you don't want a library that does anything interesting enough on its own to justify the hassle
15:15:07 <carado> Hello, I am looking to make a custom syntax for haskell, where should I look ?
15:16:39 <zRecursive> carado: Template Haskell ?
15:18:22 <carado> oh, that could do it ? thanks !
15:18:52 <otters> How many Prolog programmers does it take to change a lightbulb?
15:18:53 <blackdog> carado: it's possible, but you haven't explained what you want to do yet.
15:18:53 <otters> No.
15:19:32 <cmccann> otters: that is my favorite prolog joke.
15:19:43 <otters> it's now mine too
15:19:47 <simpson> otters: lightbulb/0 or lightbulb/1 ?
15:19:55 <otters> you lost me, I don't know PRolog
15:20:41 <monoidal> it's notation for arity of predicates
15:21:53 <zRecursive> Prolog syntax is similar as Erlang
15:23:54 <cmccann> it's more that erlang is similar to prolog, and by similar I mean based on.
15:24:03 <cmccann> as far as syntax goes at least.
15:25:28 <blackdog> cmccann: similarity is commutative, surely :)
15:28:31 <DigitalKiwi> http://www.j-paine.org/dobbs/prolog_lightbulb.html
15:31:53 <DigitalKiwi> i think that has to be the worst explanation ever
15:34:54 <Nisstyre> DigitalKiwi: I don't feel like reading all of that, so summarize for me why it's a bad explanation
15:35:17 <int-e> Nisstyre: scroll all the way to the end if you know a bit of prolog
15:35:31 <Nisstyre> int-e: okay the joke is kind of funny
15:36:16 <int-e> (I didn't read all the rest)
15:36:37 <Nisstyre> int-e: I learned a bit of prolog, but I didn't really have anything to apply it to
15:37:08 <int-e> same here
15:37:33 <int-e> the language is spoiled by side effect
15:37:34 <Nisstyre> int-e: I'm planning on reading The Reasoned Schemer though
15:37:40 <Nisstyre> which has you implement a logic language
15:37:55 <Nisstyre> miniKanren or whatever
15:38:28 <DigitalKiwi> http://stackoverflow.com/questions/234075/what-is-your-best-programmer-joke
15:39:06 <Nisstyre> http://www.toodarkpark.org/computers/humor/shoot-self-in-foot.html
15:39:15 <Nisstyre> the one for SML is good
15:42:21 <parcs> DigitalKiwi: i'm surprised the question isn't closed
15:43:16 <Nisstyre> parcs: well it's not overly subjective
15:43:23 <elliott> parcs: it is
15:43:37 <elliott> (more specifically, it's locked; see below the comments)
15:43:46 <Nisstyre> they closed it for being off-topic
15:44:14 <parcs> oh
15:44:27 <parcs> how... not surprising! :)
15:45:04 <Nisstyre> DigitalKiwi: the lisp one is funny, but I've actually gained the ability to count parentheses accurately without highlighting
15:59:39 <nexx> I want to update cabal-install on windows (--global). But instead of installing it into the haskell platform folder, it gets installed into a new haskell folder. How do I fix this?
16:00:07 <monochrom> add --prefix
16:01:27 <monochrom> but I would not do it.
16:02:57 <nexx> I guess me neither
16:23:32 <BMeph> I am disappointed that the Haskell entry for the "shoot yourself" page makes no reference to 'unsafePerformIO'; I'd've thought that would be a 'gimme' comment.
16:23:58 <BMeph> Or 'unsafeCoerce' for that matter.
16:25:47 <nexx> I think they are not part of the haskell standard!?
16:25:51 <hpc> BMeph: it's not really shooting yourself in the foot if you loudly proclaim that's what you are doing beforehand
16:26:31 <cmccann> if you unsafeCoerce your foot into a shot foot you'll get a segfault, not a foot with a bullet hole in it.
16:26:34 <geekosaur> oddly, unsafePerformIO is. (specifically, part of the FFI)
16:26:43 <nexx> oh
16:27:22 <hpc> in that sense, unsafeCoerce is standard too
16:27:31 <hpc> because it can be implemented in terms of unsafePerformIO
16:29:10 <shachaf> geekosaur: Are you sure?
16:29:10 <BMeph> On the other hand, I am much more impressed by the FORTH entry, than the SML one.
16:29:22 <epta> There should be something like `sudo' for unsafePerformIO
16:29:28 <cmccann> can you reliably implement unsafePerformIO using unsafeCoerce? all I can think of that might work is coercing to something with the same representation as IO.
16:30:05 <Cale> cmccann: Not *reliably*, but you can do it.
16:30:06 <bitonic> cmccann: this comes up once in a while, and I think the answer is ‘no’.  you can go the other way around
16:30:11 <shachaf> What does "reliably" mean?
16:30:13 <elliott> cmccann: yes if you know GHC's internals
16:30:17 <shachaf> I don't think you can go either way.
16:30:28 <shachaf> "reliably", that is.
16:30:30 <cmccann> shachaf: exactly the opposite of what elliott just said basically
16:30:31 <elliott> since you can define your own IO type, unsafeCoerce to it, and then do what unsafePerformIO does
16:30:39 <elliott> shachaf: well, unsafePerformIO breaking the type system is well known.
16:30:40 <Cale> unsafePerformIO + IORef -> unsafeCoerce reliably
16:30:41 <cmccann> i.e. not depending on GHC internals that might change
16:30:45 <elliott> it could give you a runtime type error or whatever instead.
16:30:52 <bitonic> shachaf: if you have IORef you can quite reliably unsafeCoerce with unsafePerformIO
16:30:53 <elliott> but it does give you a bona-fide a -> b that doesn't really "cheat"
16:31:03 <Cale> (you can make an IORef whose type is  forall a. IORef a)
16:31:22 <bitonic> the docs for ‘unsafePerformIO’ have that exact example, I think
16:31:26 <shachaf> But is it an allowed use of unsafePerformIO?
16:31:32 <shachaf> I know how it works.
16:31:44 <bitonic> shachaf: ‘allowed’?
16:31:50 <shachaf> Yes.
16:32:01 <bitonic> I don’t understand what you mean by ‘allowed’
16:32:10 * BMeph sniggers at the concept of an 'allowed' unsafePerformIO
16:32:15 <shachaf> There are some things you're allowed to do with unsafePerformIO and some things that you're not, presumably.
16:32:19 <shachaf> Just like there are with unsafeCoerce.
16:32:29 * bitonic still doesn’t understand
16:32:30 <cmccann> like, the IORef thing makes a certain amount of sense based on what the things it's implemented with do
16:32:34 <shachaf> Anyway unsafePerformIO is in the FFI addendum to Haskell 98 but it's not in Haskell 2010, although something similar is.
16:32:41 <hpc> > unsafeCoerce unsafeCoerce :: IO a -> a
16:32:43 <lambdabot>   Not in scope: `unsafeCoerce'Not in scope: `unsafeCoerce'
16:32:47 <cmccann> whereas coercing IO to something with the same representation assumes a lot more about how IO is implemented
16:32:50 <monoidal> can someone with working HEAD verify if this needs -XImpredicativeTypes: http://hpaste.org/87256
16:32:52 <geekosaur> heh. yes, it looks like H2010 calls it unsafeLocalState
16:32:59 <monoidal> that's weird because it shouldn't and 7.6.3 accepts it
16:33:11 <geekosaur> I know it was explicitly in the H'98 FFI addendum
16:33:12 <bitonic> hpc: is that a working unsafePerformIO?
16:33:15 <hpc> no
16:33:17 <hpc> :P
16:33:21 <bitonic> ehe, OK
16:33:25 <hpc> it's a specialization of unsafeCoerce
16:33:32 <shachaf> hpc: I can define a function with unsafePerformIO's type using unsafeCoerce very easily, and vice versa.
16:33:34 <hpc> and you don't even need to coerce it because it's a universal function type
16:33:39 <cmccann> yeah, just coercing IO a to a is not unsafePerformIO
16:33:41 <shachaf> Well, OK, I can't do it vice versa because there are no IORefs in the Report.
16:33:43 <Cale> ghci> let perform = unsafeCoerce unsafeCoerce :: IO a -> a
16:33:43 <Cale> ghci> perform (putStrLn "Hello")
16:33:43 <Cale> ()
16:33:43 <Cale> ghci> perform getLine
16:33:43 <Cale> ""
16:33:44 <cmccann> it is unsafePerformSegfault perhaps
16:34:03 <bitonic> I can define a function with unsafePerformIO’s type *without* unsafeCoerce!
16:34:49 <geekosaur> const undefined
16:34:58 <bitonic> geekosaur: why ‘const’?
16:34:58 <hpc> Cale: you can make some delightfully misleading examples with that
16:35:03 <geekosaur> true
16:35:26 <bitonic> Cale: aha, wth
16:36:42 <cmccann> @let unsafePerformIO = const undefined :: IO a -> a
16:36:44 <lambdabot>  Defined.
16:36:52 <cmccann> problem solved
16:36:56 <bitonic> @let unsafePerformIO = let x = x in x :: IO a -> a
16:36:58 <lambdabot>  <local>:4:1:
16:36:58 <lambdabot>      Multiple declarations of `unsafePerformIO'
16:36:58 <lambdabot>      Declared a...
16:37:02 <bitonic> :(
16:37:09 <jfischoff> monochrome: what does positivity have to do with rankntypes?
16:37:24 <monochrom> myfunc :: forall t. [t] -> Maybe t. user of myfunc chooses t. author does not choose.
16:37:38 * jfischoff nods
16:37:39 <cmccann> jfischoff: they're frustrating so you need a positive outlook to avoid getting discouraged
16:37:48 <jfischoff> wah wah
16:37:55 <monochrom> anotherfunc :: (forall t. [t] -> [t]) -> Maybe t. this time author chooses t, user doesn't choose.
16:38:05 <jfischoff> ah
16:38:09 <monochrom> oops, typo, I leaked t.
16:38:14 <monochrom> anotherfunc :: (forall t. [t] -> [t]) -> Maybe Int. this time author chooses t, user doesn't choose.
16:38:22 <jfischoff> right private interface
16:38:32 <jfischoff> err whatever
16:39:05 <jfischoff> which I guess implies you must give me polymorphic function so I can choose
16:39:24 <monochrom> you can also think: role of author and user has flipped. anotherfunc's author is user of that parameter. user of anotherfunc is author of that parameter.
16:40:02 <hpc> the way i see it is "monomorphic polymorphism"
16:40:15 <jfischoff> okay but where does positive/negative positions come into play?
16:40:31 <hpc> jfischoff: with something like
16:40:34 <Cale> ghci> let perform :: IO a -> a; perform x = unsafeCoerce (unsafeCoerce . const =<< x) ()
16:40:34 <Cale> ghci> perform (putStrLn "hello")
16:40:34 <Cale> hello
16:40:34 <Cale> ()
16:40:46 <hpc> read :: String -> (forall a. a), that's not higher ranked polymorphism
16:40:46 <monochrom> in anotherfunc, t is in a negative position
16:40:58 <Cale> ghci> perform getLine
16:40:58 <cmccann> Cale: what the crap did you just do
16:40:58 <Cale> "Segmentation fault
16:41:00 <Cale> :(
16:41:02 <cmccann> awwww
16:41:24 <shachaf> mikeplus64 can confirm that you can write unsafePerformIO with unsafeCoerce in GHC.
16:41:28 <monochrom> in X2->X1, X2 is negative, X1 is positive.
16:41:39 <shachaf> Since I kept doing it to his bot.
16:41:40 <shachaf> You can even do it with just one unsafeCoerce.
16:41:51 <monochrom> in (X3->X2)->X1, X3 positive (double negative), X2 negative, X1 positive
16:42:09 <jfischoff> ok
16:42:25 <cmccann> also known as covariant/contravariant position
16:42:48 <monoidal> shachaf: unsafePerformIO' x = runST (unsafeCoerce x)
16:43:18 <monochrom> triple_jeopardy :: ((forall b. Int -> b) -> Int) -> Int  b is in positive (double negative) position. user of triple_jeopardy chooses.
16:43:21 <cmccann> monoidal: that's one version I was wondering about, seems like it might work
16:44:09 <jfischoff> why? I would not have expected that...
16:44:17 <hpaste> Cale pasted “unsafePerformIO” at http://hpaste.org/87257
16:44:55 <Cale> ghci> perform (putStrLn "hello")
16:44:55 <Cale> hello
16:44:55 <Cale> ()
16:44:55 <Cale> ghci> perform getLine
16:44:55 <Cale> "hello
16:44:56 <Cale> hello"
16:45:00 <Cale> yay
16:45:11 <monoidal> Cale:  unsafePerformIO' x = runST (unsafeCoerce x) should work
16:45:22 <cmccann> Cale: that's kinda horrifying
16:45:50 <monochrom> ok, John is a user of triple_jeopardy. John provides param :: (forall b. Int -> b) -> Int. John cannot choose b. therefore, the other person chooses, that's author of triple_jeopardy.
16:45:56 <FireFly> I'm not sure if I want to know how that works :|
16:46:47 <jfischoff> oh I thought you meant the user of triple_jeopardy got  to determine the type of b
16:46:56 <monoidal> can someone with working GHC HEAD verify if this needs -XImpredicativeTypes: http://hpaste.org/87256 - that looks very weird, there's no impredicativity and it is accepted by 7.6
16:47:08 <Cale> FireFly: Well, if you turn off the typechecker, you can get away with lots of stuff :P
16:47:19 <monochrom> oh! right, I had a typo. author of triple_jeopardy chooses b
16:47:36 <jfischoff> okay cool
16:47:43 <FireFly> Cale: that doesn't mean it makes sense for it to do sensical things rather than crash horribly
16:48:07 <jfischoff> oh wait I get it
16:48:13 <jfischoff> weird
16:48:20 <jfischoff> get it more atleast
16:48:35 <FireFly> I guess you'd have to know the internal structure of the various types to make sense of things like taht
16:48:36 <FireFly> that*
16:49:09 <monoidal> jfischoff: http://mainisusuallyafunction.blogspot.com/2010/10/quantification-in-haskell.html - this article helped me a lot with rank-2-types
16:49:15 <monochrom> existential types. "data E = forall x. Ctor x (x -> E)". this is notation for the idea "E = ∃x. (x, x->E)". here is who chooses, and when
16:49:46 <monochrom> val1 :: E.  author of val1 chooses x. user does not choose.
16:49:50 <Cale> who here has 7.6.1?
16:50:14 * cmccann is on 7.6.2
16:50:23 <hpaste> Cale annotated “unsafePerformIO” with “unsafePerformIO (annotation)” at http://hpaste.org/87257#a87258
16:50:34 <Cale> That may or may not work...
16:50:37 <monoidal> Cale: you want to exploit the typechecker bug?
16:50:58 <Cale> haha, yes
16:51:02 <jfischoff> monochrom: couldn't parse "here is who chooses"
16:51:06 <monochrom> fun2 :: E -> Bool. think of (∃x. (x, x->E)) -> Bool. user of fun2 chooses x, because he provides an E value (perhaps he authors val1 and passes it to fun2)
16:51:07 <monoidal> Cale: ah, I see. in trac there were comments that made mueval do IO
16:51:08 <cmccann> I think shachaf showed me that bug.
16:51:19 <monochrom> oh, it means "read on"
16:51:20 <cmccann> he enjoys writing unsafeCoerces.
16:51:28 <monoidal> % mueval -e 'let unsafeCoerce v = z where z :: v; z = v where aux = const v in (unsafeCoerce (putStrLn "evil IO action") :: () -> ()) ()'
16:51:34 <monoidal> prints "evil IO action"
16:51:39 <jfischoff> oh
16:54:40 <jfischoff> hmm. Oddly though I don't appear to have trouble using existentials I am having trouble following the explanation
16:55:04 <jfischoff> I think partially because it is mixed in other comments
16:55:06 <jfischoff> one sec
16:56:19 <jfischoff> okay I'm fie
16:56:21 <jfischoff> fine
17:00:36 <monochrom> now is the graduation dissertation:
17:01:01 <jfischoff> monochrom: ask away
17:01:17 <monochrom> you know how we can convert between types X and (forall r. (X -> r) -> r)
17:01:17 <jfischoff> or do I explain first?
17:01:33 <monochrom> we're going to plug X=E
17:01:46 <Eduard_Munteanu> Clearly a good substitution.
17:01:50 <jfischoff> same E as before?
17:02:19 <Eduard_Munteanu> Err, sorry, missed the context. :)
17:03:00 <monochrom> we're looking at (forall r. ((E -> r) -> r)), which is (forall r. ( (∃x.(x,x->E)) -> r ) -> r)
17:03:29 <jfischoff> ok
17:03:31 <monochrom> user chooses r. we know that. easy part.
17:03:43 <Nibble> hey guys, it has been a while since I did anything in haskell. Are there any video guides/lectures I can find on youtube that will fresh up what I still remember?
17:04:08 <hpc> Nibble: i have found it's usually not hard to jump back into
17:04:19 <hpc> you learn quickly from the compiler which parts you have forgotten
17:04:24 <monochrom> author chooses x. count carefully to see.
17:04:43 <Nibble> hpc, the thing is that I usually watch some vids before I go to bed so id like a few videos just to use that time wisely, so to speak
17:04:51 <Cale> You could watch SPJ's "A Taste of Haskell", I suppose. It's on blip.tv though.
17:05:33 <hpc> the only good thing i can honestly say about blip.tv is that it isn't vimeo
17:05:37 <monochrom> and then, long story short, it is convertible to (forall r. (forall x. (x, x->E) -> r) -> r). mainly because, again, author chooses x.
17:05:44 <hpc> somehow vimeo has managed to make their site unusable with noscript
17:05:51 <hpc> even if you allow every script on the page
17:05:55 * jfischoff is thinking
17:05:57 <Nibble> http://channel9.msdn.com/Series/C9-Lectures-Erik-Meijer-Functional-Programming-Fundamentals/Lecture-Series-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-1 I was thinking about that one, let me sleep on it and ill come back and evaluate xD. Gotta see if it plays on my phone tho
17:06:31 <Cale> Nibble: Do you know about http://learnyouahaskell.com/chapters ?
17:06:39 <arbn> Hmm. So, I have a module, and I'm not exporting most of the functions because only a few of them constitute the interface. But... I'd still like to *test* all the functions in that module. Thoughts on how to handle this?
17:06:40 <Nibble> Cale, afaik those aren't vidya
17:07:00 <Cale> Nibble: yes, but videos aren't necessarily the easiest thing to learn a programming language with
17:07:21 <hpc> silly trick: use tts to turn lyah into an audiobook
17:07:25 <Nibble> Cale, I am not trying to learn it
17:07:26 <Cale> arbn: Put the tests in the module?
17:07:41 <Nibble> quicktime seems to work
17:07:45 <Nibble> thanks guys. off to bed
17:08:05 <arbn> Cale: I guess that's probably the best. That way, each module export its interface + testable properties or something.
17:08:34 <jfischoff> okay so first E is positive (double negative position) correct?
17:09:03 <Cale> arbn: It can be kind of awkward if you end up with a package that depends on QuickCheck despite not actually depending in any real way on it.
17:09:05 <monochrom> yes
17:09:21 <jfischoff> does that imply that the first x is also?
17:09:23 <Nisstyre> Nibble: how new are you to FP/programming in general?
17:09:27 <monochrom> yes.
17:09:45 <arbn> Cale: Yeah. So, I guess I have to choose which is more annoying... exporting all functions vs all modules depending on QuickCheck, right?
17:10:09 <jfischoff> does it say anything about the second x?
17:10:11 <monochrom> and positive ∃x means author chooses. (opposite of: positive ∀x means user chooses)
17:10:17 <Cale> arbn: It is of course possible to use CPP to good effect here. Maybe there's something better still...
17:10:21 <jfischoff> oh
17:10:21 <monochrom> same x
17:10:26 <jfischoff> okay
17:11:17 <jfischoff> very cool
17:11:34 <Cale> arbn: Well, another option is exporting everything from ModuleName.Internal, then importing ModuleName.Internal and only exporting the things you really want to export.
17:11:53 <Cale> arbn: and then you can put the tests in a third module if you wish.
17:12:14 <monochrom> so you can convert (∃x. blah) to (forall r. (forall x. blah -> r) -> r) if your language lacks ∃ but allows you to place ∀ left right and centre (rank-n types)
17:12:21 <Cale> arbn: and then you can use the cabal package boundary to not expose those internal modules
17:12:56 <monochrom> which is what http://okmij.org/ftp/Computation/Existentials.html#exist-via-forall says
17:13:05 <arbn> Cale: Ah. I see. That's a little complicated, but I guess that works, too. Hmm. Thanks for the tips.
17:13:16 <jfischoff> brb gonna read
17:17:39 <jfischoff> monochrom: super cool
17:17:57 <monochrom> ok good, you have graduated :)
17:18:03 <jfischoff> :)
17:19:15 <monochrom> you have used existential types successfully. I think you don't have that part to worry.
17:20:20 <monochrom> for rank-2 types, it suffices to understand that "runST :: (forall s. ST s a) -> a" means that GHC chooses s, therefore you can't choose s, your code has to be general for s
17:21:06 <monochrom> rank-3 types is much rarer, but here is a use case.
17:21:28 <arbn> Hmm. I have a function on a foreign type that is intended to be pure. It would be OK to use unsafePerformIO *only* in the QuickCheck property, right? I'm trying to assure myself that it has the properties I think it has.
17:23:04 <monochrom> you know about mtl's callCC :: forall r a b. ((a -> Cont r b) -> Cont r a) -> Cont r a
17:23:47 <Eduard_Munteanu> monochrom: rare? Oh, but there's that multiplate stuff... they use rank-3 poly instead of MPTCs and fundeps, *clearly* something simpler.
17:24:06 <monochrom> this allows you to choose b once per use. this is not flexible enough for some people. they want to choose b several times per use.
17:25:22 <monochrom> forall r a. ((forall b. a -> Cont r b) -> Cont r a) -> Cont r a.  now you still choose b, but you can also choose several times per use
17:26:19 <cmccann> jfischoff: bonus question, what happens if you take the same generic style of encoding (forall r. (?? (a -> r)) -> r) and use it uniformly with the components of a tuple instead of a forall?
17:27:07 <Eduard_Munteanu> Um, looks like Ran?
17:27:19 <_just> reverse $ takeWhile (/=',') $ reverse " 12,45" can i write this shorter?
17:28:55 <jfischoff> cmccann: Oh wait just got back let me read up
17:28:59 <monoidal> _just: if you have exactly one ',' in the string,  tail $ dropWhile (/=',') "12,45"
17:29:07 <monoidal> (it's not equivalent in general)
17:29:42 <_just> monoidal: thanks
17:30:51 <jfischoff> cmccann: okay I don't really follow
17:31:15 <jfischoff> what do you mean by "uniformly with the components of a tuple" ?
17:32:29 <cmccann> jfischoff: with "forall a. a -> r" the (a -> r) is inside the scope of the forall, so by analogy I'm saying do the same in each component of a tuple, e.g. (a -> r, b -> r).
17:32:38 <cmccann> do you see the similarity?
17:33:40 <jfischoff> do you mean forall a b. (a -> r,b -> r) or (forall a. a -> r, forall b. b -> r)?
17:34:02 <cmccann> jfischoff: you can get a value of any type out of "forall a. a", so in a (strained) sense it's similar to an infinite tuple of values of each possible type
17:34:23 <cmccann> in that you can think of it as picking one component to get the type you want
17:34:41 <cmccann> so narrow that down to just two types, no quantifier involved
17:34:51 <cmccann> call them A and B instead, they don't need to be polymorphic here
17:34:58 <monoidal> jfischoff: those two are equivalent, just like forall a. Int -> a is equivalent to Int -> forall a. a
17:35:08 <jfischoff> ok
17:36:18 <cmccann> jfischoff: so instead of "forall a. (a -> r)" meaning (? -> r) for all possible types, you have (? -> r) for just two specific types
17:36:27 <cmccann> jfischoff: does that make more sense?
17:37:10 <jfischoff> I don't really follow. It would appear to be that I have a tuple where each type can be anything
17:37:19 <jfischoff> I don't see why it is constrained to two types
17:37:54 <cmccann> because that's what I'm asking about :P
17:38:07 <cmccann> it can be any finite number of concrete types
17:38:15 <zRecursive> "no matter what the type is" seems NOT practical for most app. ?
17:39:21 <jfischoff> cmccann: what is the "it" in the sentence?
17:39:29 <zRecursive> As most data MUST have type
17:39:41 <cmccann> jfischoff: blah, I'm phrasing this badly, sorry
17:39:48 <jfischoff> no worries
17:40:12 <jfischoff> have you explained the answer?
17:41:00 <cmccann> jfischoff: let's just ignore the way I was trying to set up the analogy I guess
17:41:23 <cmccann> the type I was aiming for was something like (forall r. (A -> r, B -> r) -> r)
17:42:23 <cmccann> with an attempt to go via an analogy of that as being like a restricted quantification over just the types A and B, rather than all types with kind *
17:42:42 <jfischoff> hmm
17:43:18 <cmccann> if a function expects a tuple, you have to give it every component and it can pick which to use
17:43:34 <cmccann> similar to how if it expects a polymorphic value, you have to give it one and it picks the type to use
17:43:57 <shachaf> I,I (A ~ x => r, B ~ x => r) -> r
17:44:35 <cmccann> shachaf: I still have no idea how "I,I" looks like anything
17:44:45 <shachaf> It looks like an owl face.
17:44:52 <shachaf> To me, anyway.
17:44:59 <cmccann> yes. to you.
17:45:31 <byorgey> that does not explain anything.  why is an owl looking at that type.
17:45:44 <cmccann> jfischoff: anyway, there's a common aspect of "offer everything, recipient gets to choose" that I was going for. does that make any sense now?
17:46:06 <jfischoff> Not really
17:46:11 <cmccann> :[
17:46:16 <jfischoff> what helps is the connection to logic
17:46:38 <jfischoff> I understand somewhat how to reason about exists and forall in classical logic sense
17:46:47 <jfischoff> so that connection I like
17:47:05 <jfischoff> I think be leveraged that more would might help… maybe not
17:47:27 <jfischoff> I understand …. somewhat
17:47:41 <cmccann> jfischoff: what I am suggesting is to regard universal quantification as an infinite logical conjunction over the domain of discourse
17:48:00 <jfischoff> yes
17:48:06 <jfischoff> I see that
17:48:21 <jfischoff> maybe I should look at the example again ….
17:50:17 <cmccann> jfischoff: basically the idea here is that if we pretend forall is an infinite conjunction (i.e., tuple of all types), the encoding used to get existential quantification from forall can be done with a finite tuple as well
17:50:47 <jfischoff> oh ok
17:50:49 <cmccann> jfischoff: which by the same analogy of exists as an infinite disjunction, we would expect to give us a finite logical disjunction
17:50:54 <jfischoff> I get the analogy
17:51:13 <jfischoff> I need to think about more though to really get it
17:51:25 <jfischoff> huh
17:51:46 * elliott isn't sure what cmccann is on about. help.
17:53:02 <cmccann> elliott: I'm starting to wonder if I'm sure what I'm going on about.
17:54:02 <cmccann> jfischoff: anyway, the final step would be whether, and if so how, the resulting type behaves as a logical disjunction
17:55:15 <monochrom> the owl is looking at the type in awe
17:55:40 <jfischoff> Not really informed enough to comment unfortunately
17:56:23 <cmccann> jfischoff: well, what sort of values would have the type (forall r. (A -> r, B -> r) -> r)?
17:57:28 * jfischoff is negating
17:59:42 <jfischoff> so is that equivalent to there exists (A, B) ?
17:59:56 <jfischoff> wait
18:00:30 <jfischoff> yes that is final attemp
18:00:33 <jfischoff> t
18:01:15 <cmccann> well, if we think of A and B as a restricted domain of discourse here
18:01:22 <monochrom> here is a hint, or spoiler, I don't know which one. I have a mysterious 2-argument logical connective, call it ☃, you have to guess what it is. but here is an inference rule: suppose you can prove A->r, and you can prove B->r, then you can conclude A☃B -> r. what is ☃?
18:01:49 <cmccann> it would mean something like "there exists a type from the set of types {A, B}"
18:02:06 <cmccann> monochrom: that is an excellent name for a logical connective.
18:02:09 <jfischoff> or
18:02:29 <copumpkin> A 💩 B -> r
18:02:35 <monochrom> yes. the inference rule is "or elimination" in natural deduction
18:03:10 <monochrom> or you can write A☃B -> (forall r. (A->r, B->r) -> r)
18:03:37 <monochrom> "A or B" is also "there exists x in {A,B}"
18:03:42 <jfischoff> yes
18:04:06 <zRecursive> @djinn (forall r. (A->r, B->r) -> r)
18:04:07 <lambdabot> Error: Undefined type A
18:04:15 <cmccann> I don't think djinn will help here
18:04:25 <zRecursive> @djinn (forall r. (Int->r, Int->r) -> r)
18:04:25 <lambdabot> Error: Undefined type Int
18:04:28 <jfischoff> okay I guess maybe you are looking for Either a b or something
18:04:33 <cmccann> :t \e (f, g) -> either f g e
18:04:35 <lambdabot> Either a b -> (a -> c, b -> c) -> c
18:04:51 <jfischoff> cool
18:05:34 <cmccann> jfischoff: so it's a sort-of-correspondence between "Either A B" and "Not (Not A, Not B)"
18:05:45 <cmccann> in other words, one of de morgan's laws
18:05:46 <tac> :t either
18:05:47 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
18:05:49 <jfischoff> yeah totally
18:06:16 <jfischoff> and here I thought we could double negate
18:06:28 <jfischoff> s/could/couldn't
18:06:39 <cmccann> I say sort-of because the CPS encoding lets you do sneaky things
18:06:48 <jfischoff> sneaky how?
18:07:07 <shachaf> classical disjunction is the devil hth
18:07:17 <jfischoff> right
18:07:21 <cmccann> :t \k -> k . Left $ \x -> k $ Right x
18:07:23 <lambdabot> (Either (b -> c) b -> c) -> c
18:07:34 <cmccann> if you read (-> c) as negation that's the law of excluded middle
18:08:29 <cmccann> using the trick where it tries the false side first and, if given a proof to the contrary, uses the evidence that proof provides to use the true side instead
18:08:40 <jfischoff> I guess it is encoded of negation but is it actually negation?
18:09:04 <jfischoff> s/encoded/encoding
18:09:32 <cmccann> depends on how you define "actually".
18:09:38 <shachaf> @ty \k -> k . Left $ k . Right
18:09:40 <lambdabot> (Either (b -> c) b -> c) -> c
18:10:00 <jfischoff> I don't really have a definition … actually
18:10:45 <cmccann> jfischoff: it works mostly in the sense that anything in contravariant position is "negated"
18:11:21 <jfischoff> so fasinating
18:12:26 <cmccann> jfischoff: if you use "A -> Void" to mean "Not A" instead the logic still holds but you can't do anything useful with the encoded non-intuitionistic bits
18:14:17 <cmccann> the best approximation is probably what you get by quantifying over the type of the final result, like the forall r. in my initial example
18:14:52 <cmccann> since that lets all the classical nonsense work in some sense inside that scope, but doesn't let you pull anything really underhanded like using callCC
18:15:46 <jfischoff> logic regions :)
18:16:51 <cmccann> this is also why I like the idea of negative types as continuations, i.e. "Not A" means a continuation that takes a value of type A and never returns
18:17:22 <jfischoff> right
18:18:01 <arbn> "No instance for (Applicative Gen)" <-- I thought this would be in Test.QuickCheck? Hmm.
18:18:51 <arbn> Oh. I pulled in the old version somehow.
18:22:36 <cmccann> jfischoff: anyway the moral of the story is that CPS encoding is basically magic and can do everything the end
18:23:33 <jfischoff> Is that part of why Oleg doesn't like undelimited continuations?
18:24:20 <cmccann> undelimited continuations have so much magic that they undermine fancier magic you might want to do
18:25:14 <jfischoff> fair enough
18:25:34 <cmccann> anyway CPS encoding is always limited in that you're transforming specific code into CPS style
18:26:16 <cmccann> Oleg's complaints about undelimited continuations involve using them from code that isn't being explicitly mutilated into CPS style
18:26:57 <cmccann> at least if memory serves me
18:27:05 <cmccann> been a while since I read his stuff about that
18:28:10 <jfischoff> I remember an abstract where he said they were really functions in any well defined way
18:28:18 <jfischoff> s/were/weren't
18:33:54 <kniren> Hello everyone. I need to process a really big file (8G) and I want to know if there is a more efficient way to do it. I'm using ByteStrings and Binary.Get to obtain the appropriate information, but if I have to read further than 1000000 this approach turns out to be very inneficient. Any suggestions? I've read something about mmap but I'm not sure of the procedure I must follow
18:35:03 <zRecursive> :t Binary.Get
18:35:05 <lambdabot> Couldn't find qualified module.
18:35:25 <kniren> sorry Data.Binary.Get
18:35:34 <zRecursive> :t Data.Binary.Get
18:35:36 <lambdabot> Not in scope: data constructor `Data.Binary.Get'
18:36:08 <zRecursive> @hoogle Binary.Get
18:36:10 <lambdabot> package getemx
18:36:10 <lambdabot> package getflag
18:36:10 <lambdabot> package dingo-widgets
18:36:42 <zRecursive> @hoogle Data.Binary
18:36:43 <lambdabot> package binary
18:36:43 <lambdabot> package binary-bits
18:36:43 <lambdabot> package binary-communicator
18:36:55 <arbn> It's in binary, yeah.
18:37:23 <zRecursive> seems right to use binary
18:39:15 <kniren> yup, in fact I have to process the file at byte level so it is the right thing to do. Nevertheless, it is not fast enough for my needs. I don't know if you can process chunks of data mapping them into memory and the processing it. I'm a little lost regarding this
18:40:08 <zRecursive> @hoogle mmap
18:40:09 <lambdabot> package mmap
18:40:09 <lambdabot> package bindings-mmap
18:40:09 <lambdabot> package bytestring-mmap
18:40:26 <zRecursive> @where mmap
18:40:27 <lambdabot> I know nothing about mmap.
18:40:44 <zRecursive> @package mmap
18:40:45 <lambdabot> http://hackage.haskell.org/package/mmap
18:50:28 <kniren> Thx, but I already googled that. Maybe I have to be more specific: If you want to process a file this big, should you map it to the memory? size of the chunks? problems using this method?
19:18:46 * arbn learns the hard way that foreign types and QuickCheck don't mix.
19:19:30 <blackdog> whee. what happens?
19:19:59 <arbn> blackdog: "    Module `Distribution.Simple.Test' does not export `stubMain'
19:20:48 <arbn> blackdog: Plus, I had to put unsafePerformIO *everywhere* to even get this to compile. Trying to do IO inside an Arbitrary instance definition is a red flag.
19:22:12 <arbn> So, I'm officially giving up on testing C types with Haskell's QuickCheck.
19:23:09 <cmccann> just port quickcheck to C.
19:23:11 <cmccann> sounds simple enough.
19:24:04 <cmccann> (NB: the preceding statement is deliberate nonsense)
19:24:29 <sclv> someone had a post about doing a whole bunch of automated c testing driven by haskell quickcheck
19:24:43 <sclv> i think they were driving testing c functions tho
19:24:53 <arbn> cmccann: Well, you see... I have two marshalling functions. One is from the C type to the Haskell type, and the other goes back. Both *should* be pure. I wanted to write a test that assures me that the two functions perfectly undo each other. But, GHC won't cooperate.
19:25:24 <arbn> cmccann: What do you think the best approach for that kind of testing is?
19:25:37 <sclv> nah that sounds like a job for quickcheck
19:25:44 <cmccann> if they're actually pure then their types should reflect that
19:25:55 <cmccann> and they should work like any other pure function
19:25:58 <sclv> build up the haskell type first tho, then convert to c and back
19:26:20 <cmccann> unless there's memory allocation nonsense that makes it have to be impure anyway
19:26:25 <elliott> cmccann: I think there is a C QuickCheck.
19:26:42 <cmccann> elliott: you're a C quickcheck.
19:26:44 <arbn> cmccann: There is. The foreign types are of course pointers and not values.
19:26:59 <arbn> Haskell doesn't support arbitrary C values. You have to use pointers.
19:27:21 <cmccann> so what, you're basically testing a Storable instance?
19:28:16 <arbn> cmccann: Not the Storable instance. The marshaling functions.
19:28:55 <cmccann> anyway I'm far from an expert on quickcheck so I dunno what would be best
19:29:01 <arbn> I think sclv is right, though. I can test this one way, by building up the Haskell type first.
19:29:20 <arbn> sclv: Thanks for that.
19:29:31 <copumpkin> sclv has been known to be right before
19:29:38 <copumpkin> twice?
19:29:40 <copumpkin> I think
19:29:46 <cmccann> that's like a high score or something I think.
19:29:54 <arbn> I was trying to write the Arbitrary instance for the C type. Better to content myself with writing only an Arbitrary instance for the Haskell type.
19:38:32 <elliott> cmccann: by the way, you have me proving that dlist is a functor in coq now.
19:40:21 <cmccann> elliott: so you're saying you didn't... B] ...chicken out of providing a proof
19:40:42 <elliott> cmccann: B|
19:41:14 <cmccann> pretty fowl pun eh
19:41:40 <cmccann> anyway cool
19:41:47 <cmccann> let me know how it goes
19:42:49 <elliott> cmccann: it was monoidal. http://sprunge.us/gGLV
19:42:53 <cmccann> are you accounting for all the possible _|_ that can show up or going the fast-and-loose route
19:43:06 <elliott> what's a _|_? coq has never heard of such nonsense.
19:43:48 <cmccann> so you're not trying to prove it for the actual DList type as it is in Haskell then
19:44:19 <elliott> the DList type in haskell doesn't even require you obey the laws.
19:44:25 <elliott> certainly it's not a functor without that requirement
19:44:49 <cmccann> hm
19:44:54 <cmccann> oh, it even exports the constructor, doesn't it.
19:44:57 <cmccann> well that's just silly.
19:45:53 <tunixman> Hello! I'm having a bit of a problem building Dars from source with some admittedly bleeding-edge ghc and cabal, but I was wondering if anyone wanted to take a brief look and see if it's something silly or if it'll need a bit of effort to fix.
19:46:06 <tunixman> Here is the output from the build: https://gist.github.com/tunixman/5519475
19:46:18 <liyang> Ideas for how to write a cabal test that checks if a given RULES fired?
19:47:10 <copumpkin> liyang: you can ask GHC to tell you which ones fired, but you might have to call ghc manually in cabal
19:52:04 <liyang> copumpkin: yeah, I was hoping to avoid that and let cabal call GHC for me. :(
19:54:25 <liyang> Maybe I can have the test call cabal build on itself and grep the output for "Rule fired".
19:55:03 <elliott> cmccann: where is my payment!!
19:55:36 <cmccann> what payment
19:56:04 <elliott> cmccann: I thought the idea is you pay me for doing pointless things.
19:56:51 <cmccann> when did I agree to that
19:57:07 <elliott> uh, I don't recall there being an agreement involved.
19:58:34 <cmccann> ok. well, I can send you some money via imgur. you're on your own to print it out and pass it off as legal tender though.
19:58:48 <wole> @hoogle Identity
19:58:49 <lambdabot> Control.Monad.Identity module Control.Monad.Identity
19:58:49 <lambdabot> Control.Monad.Trans.Identity module Control.Monad.Trans.Identity
19:58:49 <lambdabot> Data.Functor.Identity module Data.Functor.Identity
19:59:26 <cmccann> elliott: also it will be US money because I can draw a passable dollar sign but not whatever weird symbol you use for money.
20:00:31 <elliott> cmccann: our official currency symbol is ‰ḧ
20:00:58 <cmccann> some sort of unreadable squiggle ok gotcha
20:03:15 <elliott> cmccann: well, you know who else is an unreadable squiggle.
20:08:55 <cmccann> elliott: ok here http://i.imgur.com/I6ROu7Q.png
20:10:19 <elliott> cmccann: that is some beautiful legal and/or illegal tender. I will store it in my digital bank alongside the 0 bitcoins I own.
20:10:37 <cmccann> it is totally legit moneys
20:10:42 <cmccann> it says so right on it
20:10:46 <elliott> is the person in the middle anyone in particular
20:10:57 <cmccann> some important dead guy obv
20:11:07 <elliott> ah, so it's you.
20:11:33 <cmccann> nah I don't look respectable enough to be on moneys
20:11:51 <cmccann> specially not totally legit moneys like this
20:12:33 <elliott> I like how you ended up not actually drawing a dollar sign after all.
20:12:59 <cmccann> I also forgot to save it with a transparent background apparently
20:29:35 * hackagebot xmobar 0.17 - A Minimalistic Text Based Status Bar  http://hackage.haskell.org/package/xmobar-0.17 (JoseAntonioOrtegaRuiz)
21:05:45 <SrPx> whoever are the 17 on codejam... gogogo !!!!
21:07:51 <SrPx> the world is counting on you to beat the OO behemoths ! :D
21:08:48 <monochrom> oh, interesting
21:10:44 <boccato> 17 ppl using haskell?
21:25:36 <liyang> Dear #haskell: How do I captured stdout when actioning an IO?
21:25:58 <Clint> you mean like popen?
21:26:22 <liyang> Sure... but without actually forking another process.
21:26:47 <Clint> oh, you want to capture the stdout you're emitting yourself?
21:27:01 <liyang> I'm sitting here in IO. I have another IO. I want to see what that other IO sends to stdout.
21:27:14 <liyang> Clint: right.
21:27:19 <Clint> ah
21:27:44 <liyang> Wasn't sure if there's a common idiotomatic way of doing that.
21:30:42 <elliott> I think there's a GHC-specific package that does it
21:33:07 <cmccann> is there any way to write a type signature for something that needs a constraint mentioning a class that isn't exported from the module that defines it?
21:35:16 <elliott> cmccann: I believe not
21:35:23 <elliott> "don't do that"
21:35:52 <tgeeky> there is also OI and other fake-IO packages
21:35:52 <cmccann> elliott: tell that to whoever thought it was a good idea when writing the gtk bindings
21:35:55 <tgeeky> I don't know if they are easy or not
21:35:55 <cmccann> :T
21:36:20 <tgeeky> OI is not the right thing.
21:37:12 <liyang> tgeeky, elliott: cheers, I'll look into it.
21:37:14 <tgeeky> liyang: I bet this is what you want: http://hackage.haskell.org/package/silently-1.2.4.1
21:38:13 <liyang> (heading out, brb.)
22:25:34 <aerolite>  /leave
23:20:01 <jkarni> any clues why Enum isn't a subset of Ord, when it has succ and pred?
23:20:40 <tgeeky> jkarni: if something is infinite, it may have Ord but not Enum
23:21:00 <jkarni> ah
23:21:23 <arkeet> Enum is kind of ugly.
23:21:39 <tgeeky> I can't think of the opposite case, though
23:21:49 <arkeet> it mainly exists to make stuff like [a .. b] work
23:21:58 <arkeet> I think.
23:22:34 <arkeet> tgeeky: sure, given Enum, you can define a <= b iff [a..b] is nonempty
23:23:00 <arkeet> :t \a b -> not (null [a..b])
23:23:01 <lambdabot> Enum a => a -> a -> Bool
23:23:05 <tgeeky> arkeet: I meant, I can't think of a case where you have Enum but can't use it to construct ord
23:23:17 <arkeet> me either. because you always can.
23:23:38 <Nisstyre> doesn't having Enum imply you can use any ordering that works for the natural numbers?
23:23:50 <arkeet> oh, I suppose you could go via fromEnum too.
23:24:04 <arkeet> oh, no.
23:24:08 <arkeet> that does the wrong thing for floats
23:24:16 <arkeet> > fromEnum 2.6 <= fromEnum 2.3
23:24:18 <lambdabot>   True
23:24:38 <arkeet> > [2.6 .. 2.3]
23:24:40 <lambdabot>   [2.6]
23:24:44 <arkeet> oh...
23:24:47 <arkeet> :/
23:24:55 <arkeet> ok, Enum sucks. :p
23:25:08 <Nisstyre> also, succ for floats is weird
23:25:14 <ion> No, Float sucks (in this case, in that it has an Enum instance).
23:25:15 <shachaf> Enum is kind of icky.
23:25:33 <ion> Well, Enum does suck, too, but these examples didn’t demonstrate that. :-P
23:25:36 <arkeet> well the problem is that we don't really have any laws for Enum.
23:25:52 <shachaf> At least we have a law for Num!
23:26:04 <Nisstyre> succ for Ratio is much nicer
23:26:07 <arkeet> shachaf: which one?
23:26:16 <Nisstyre> it should just internally convert to that and convert back to a Float
23:26:19 <shachaf> abs x * signum x == x
23:26:23 <arkeet> right.
23:26:56 <Nisstyre> arkeet: what do you mean? Isn't there a whole branch of math on ordering things properly?
23:27:08 <arkeet> what do I mean by what?
23:27:14 <Nisstyre> by having no laws for Enum
23:27:18 <tgeeky> when I see [2.6 .. 2.3] I think you need an additional paramter to say how fine
23:27:23 <arkeet> and what does Enum have to do with math?
23:27:31 <Nisstyre> like, if you were going to say that anything that's an instance of Enum should be an instance of Ord
23:27:40 <Nisstyre> arkeet: nothing, technically
23:29:48 <Nisstyre> arkeet: the way succ is defined for Float, it doesn't actually "enumerate" the entire set of Floats
23:29:53 <Nisstyre> that's all I'm saying
23:29:58 <Nisstyre> it does for Ratio though
23:30:02 <arkeet> it does?
23:30:05 <Nisstyre> yeah
23:30:09 <arkeet> > succ (1/2 :: Rational)
23:30:13 <lambdabot>   3 % 2
23:30:14 <Nisstyre> it's using a Farey sequence afaict
23:30:21 <arkeet> > [1/2 :: Rational .. ]
23:30:24 <lambdabot>   [1 % 2,3 % 2,5 % 2,7 % 2,9 % 2,11 % 2,13 % 2,15 % 2,17 % 2,19 % 2,21 % 2,23...
23:30:31 <arkeet> doesn't look like it.
23:30:42 <Nisstyre> no? well it could be doing it fairly easily anyway
23:30:58 <arkeet> and in any case that would be incompatible with the Ord instance
23:31:03 <Nisstyre> true
23:31:21 <arkeet> anyway, I think there ought to be laws like
23:31:38 <arkeet> [a..b] = takeWhile (<= b) (iterate succ a)
23:31:45 <arkeet> (why isn't it defined that way?)
23:32:44 <jkarni> how would you implement different steps then, though?
23:33:44 <arkeet> well, the law doesn't specify what happens then.
23:34:25 <arkeet> I'm stating laws, not implementations.
23:34:36 <shachaf> > [1..9.5]
23:34:38 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
23:35:02 <jkarni> arkeet - fair enough
23:35:13 <ion> > takeWhile (<= 256) (iterate succ 250) :: [Word8]
23:35:15 <lambdabot>   []
23:35:29 <cmccann> > succ 0 :: Fixed E3
23:35:31 <lambdabot>   0.001
23:35:35 <arkeet> interesting
23:35:38 <flebron> Is there a shorter notation for (f . f . f .f)?
23:35:52 <flebron> foldr ap or something perhaps.
23:35:53 <ion> f.f.f.f
23:35:54 <shachaf> foldr(.)id(replicate 4 f)
23:35:56 <johnw> haha
23:35:56 <flebron> haha
23:36:06 <cmccann> ion: good suggestion
23:36:24 <arkeet> foldr1(.)$replicate4f
23:36:28 <arkeet> er
23:36:30 <shachaf> ion: replicate 4f
23:36:32 <arkeet> foldr1(.)$replicate 4f
23:36:53 <johnw> nice, whitespace golfing
23:36:54 <shachaf> s/ion: /
23:36:56 <tgeeky> arkeet: originally you were doing [2.3 .. 2.6]
23:36:59 <flebron> Doing divided differences up to the kth level was very pretty.      dif nums = zipWith (-) (tail nums) nums. d4 = (dif . dif . dif . dif) nums. :)
23:37:03 <shachaf> s#$#/#
23:37:10 <tgeeky> > [2.3,2.4..2.6]
23:37:12 <lambdabot>   [2.3,2.4,2.5,2.6]
23:37:15 <arkeet> tgeeky: no, I was doing [2.6 .. 2.3]
23:37:17 <arkeet> which ought to be empty
23:37:39 <tgeeky> yep
23:37:39 <arkeet> flebron: dif []
23:37:49 <tgeeky> why not just define it as = reverse what I did
23:37:59 <flebron> No such thing, my numbers are all at least length 4 :)
23:38:03 <tgeeky> if you provide the stepping magnitude, who cares if it's reversed :o
23:38:04 <arkeet> =(
23:38:06 <flebron> (Even 5!)
23:38:48 <flebron> It should still work, however :o
23:39:04 <ion> > let fact n = product [1..n] in even (fact 5)  -- indeed
23:39:06 <lambdabot>   True
23:39:50 <arkeet> > let (!) = const true in (even 5!)
23:39:52 <lambdabot>   Not in scope: `true'
23:39:54 <arkeet> > let (!) = const True in (even 5!)
23:39:56 <lambdabot>   True
23:40:22 <arkeet> > let (!) = not in (even 5!)
23:40:24 <lambdabot>   True
23:40:43 <ion> > let (n!) = product [1..n] in even (5!)
23:40:44 <lambdabot>   <hint>:1:6: Parse error in pattern: n !
23:40:54 <ion> > let (!) n = product [1..n] in even (5!)
23:40:55 <lambdabot>   True
23:41:07 <flebron> haha
23:47:18 <latermuse> why is ; in imperative languages equal to the IO monad?
23:47:35 <simpson> latermuse: Sounds like you've been reading too many monad tutorials. :3
23:48:16 <latermuse> actually im not. i just remember reading about it last year
23:48:29 <latermuse> i still dont understand how ; is the same as an IO monad
23:49:10 <simpson> Well, the short answer is that it isn't.
23:49:44 <kwantam> I think the logic behind such a claim is something like this: " a ; b " means "do a, then do b". In something like the same way, the IO monad can be used to sequence a set of computations. But that's a tenuous connection at best.
23:49:45 <shachaf> latermuse: The question is: What does it mean to say "doSomething; doSomethingElse;"?
23:50:01 <shachaf> In Haskell there's no intrinsic meaning, because there's no intrinsic idea of effects.
23:50:18 <shachaf> Monads give you one idea of what effects should be.
23:50:29 <shachaf> (Each monad gives you its own idea, in particular; but they all have a common theme.)
23:50:51 <shachaf> There are other, non-monad techniques for specifying effects, too.
23:50:52 <kwantam> One could argue that ; is more like seq
23:51:04 <shachaf> ; is not very much like seq at all.
23:51:09 <arkeet> I don't think one could argue that very successfully.
23:51:10 <shachaf> It doesn't even guarantee ordering.
23:51:15 <kwantam> well it's not very much like IO at all either, is it.
23:51:23 <kwantam> It guarantees strictness in the first argument.
23:51:34 <shachaf> In "do { print 1; print 2; }", it behaves a lot like ; in C.
23:51:37 <arkeet> but it doesn't guarantee anything about ordering.
23:52:04 <johnw> oh?
23:52:05 <kwantam> yeah, true.
23:52:32 <kwantam> perhaps it depends which qualities of ';
23:52:38 <kwantam> ' we're attempting to replicate
23:52:55 <kwantam> but "a ; b" does mean "evaluate a", and in general (in C, e.g.) means to do so strictly
23:53:04 <kwantam> but that's... yeah. Tenuous :)
23:53:14 <shachaf> C doesn't really make a distinction between execution and evaluation.
23:53:21 <shachaf> But I would say that it means to execute a, not evaluate it.
23:53:28 <shachaf> Because a is a statement, not an expression.
23:53:44 <shachaf> (Note that expressions are statements, but not vice versa.)
23:54:32 <shachaf> In Haskell, statements are expressions and expressions are statements, because statements are a first-class notion that's not even built into the language, implemented via first-class values.
23:54:41 <johnw> expressions are technically not statements; but there is a void statement whose content is a single expression
23:55:16 <cmccann> > zipWith seq[minBound :: Ordering ..] [minBound..] :: [Ordering] -- seq doesn't affect ordering at all, see
23:55:18 <lambdabot>   [LT,EQ,GT]
23:55:32 <shachaf> An expression -- like "x = 5" -- can be used in a place where a statement is expected.
23:55:46 <shachaf> cmccann: Are you going to ICFP?
23:56:09 <cmccann> probably not.
23:56:27 <johnw> i've created #icfp, for anyone who's going
23:56:54 <Javran> I think ";" just allows code to be written in a line ...
23:57:07 <shachaf> johnw: It should be ##icfp, unless you're officially affiliated with ICFP.
23:57:13 <johnw> ah, thank you
23:57:25 <johnw> created ##icfp
23:58:59 <arkeet> Javran: some languages don't need it at all, since the rest of the syntax is enough to tell where the statements are.
23:59:01 <arkeet> e.g. lua
