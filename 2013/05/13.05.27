00:08:10 <qu1j0t3> hi, i'm trying to cabal install some packages and haskell-src-exts has a dependency on happy that it can't see is satisfied. http://hpaste.org/88667
00:08:20 <qu1j0t3> any workarounds?
00:08:48 <supki> add ~/.cabal/bin to PATH
00:08:54 <supki> cabal does not track executables
00:10:43 <supki> also I think gentoo-haskell overlay has all these packages?
00:10:46 <qu1j0t3> yeah i read this http://hackage.haskell.org/trac/ghc/ticket/7932 which made a similar point.
00:10:56 <qu1j0t3> supki: it does; i am working out of the overlay.
00:11:37 <qu1j0t3> supki: hm, so i shouldn't be using cabal directly ? this is in order to get EclipseFP working
00:13:03 <supki> qu1j0t3: well, if you want to install from overlay, you use emerge, not cabal
00:13:33 <qu1j0t3> the first thing that went wrong was that EclipseFP's bootstrap via cabal failed
00:13:42 <qu1j0t3> i.e. its required packages
00:14:07 <qu1j0t3> alright, if i want to zero local cabal install and retry with emerge.. what should i do?
00:14:36 <qu1j0t3> remove ~/.cabal for the (non-root) user?
00:15:01 <supki> you remove ~/.cabal and ~/.ghc
00:15:08 <qu1j0t3> ok
00:15:51 <supki> also there is #gentoo-haskell for questions specifically about overlay :)
00:15:56 <qu1j0t3> thanks :)
00:35:50 <Jookia> Is it possible to remove a package from cabal?
00:36:35 <absence> ghc-pkg unregister packagename
00:36:50 <absence> Jookia: you have to delete the files manually though
00:37:10 <Jookia> Why doesn't cabal do that?
00:37:20 <absence> good question :)
00:37:21 <shachaf> Because it doesn't keep track of installed files.
00:37:33 <Jookia> Why not though?
00:37:39 <johnw> the utility cabal-delete is quite good at deleting cabal installed packages
00:37:50 <johnw> it takes care of the ghc-pkg registry, and also cleaning up everything that cabal installed
00:37:59 <johnw> plus, it can do so recursively
00:38:07 <Jookia> where do i get that from?
00:38:11 <johnw> one sec
00:38:15 <shachaf> @google cabal-delete
00:38:16 <lambdabot> https://github.com/iquiw/cabal-delete
00:38:23 <johnw> yep, that's it
00:38:23 <shachaf> Because a package manager is a lot of work.
00:39:40 <absence> speaking of things that are a lot of work, are leksah and eclipsefp the current IDEs?
00:39:41 <Jookia> shachaf: ...But why make a package manager if it can't remove packages?
00:41:50 <absence> Jookia: it can install packages. that's fairly useful
00:42:26 <Jookia> I didn't say it wasn't useful, it's just kind of weird that it doesn't support removing packages
00:42:37 <Jookia> I don't know of any package managers that don't support removing packages
00:43:04 <absence> Jookia: probably it's not a completed project, and the developers focus on the most important tasks first
00:44:58 <Jookia> why does cabal not support generating document for tests
00:46:19 <absence> for the same reason i would guess
00:46:53 <Jookia> It looks like it deliberately skips them
00:47:26 <Jookia> As it preprocesses the test suite, but then just doesn't generate documentation
00:49:07 <johnw> you can submit a feature request on Github
00:49:21 <johnw> it's a volunteer project after all
00:49:49 <Jookia> I've been looking for alternatives to using it as a build system but I can't find any that are easy to use and support out of source builds
00:50:26 <johnw> it depends on your needs.  By using the Custom build type, you can do whatever it is you like
00:50:40 <johnw> if you don't want to do that extra work, and Cabal doesn't do what you want, then the only real answer is to fix Cabal and submit the work!
00:51:14 <Jookia> I'm a Haskell newbie, so I can't fix Cabal, and the patches are specific to my project so they would just end up as something extra I'd have to maintain
00:53:20 <johnw> well, I'm afraid that bringing Cabal deficiencies to our attention will not solve them
00:53:34 <johnw> in the goodness of time, of course things will improve
00:53:48 <johnw> but if everything is not up to a commercial standard just yet, is to be expected
00:57:16 <Jookia> every thread i find for alternatives to cabal end up with 'just use cabal', so the only way i really see to do it is if i wrap cabal to avoid its problems. has that been done before?
00:57:46 <shachaf> Jookia: cabal is not a package manager.
00:58:00 <johnw> other people have written wrapper tools: cab, cabal-delete, cabal-meta, etc.
00:58:32 <johnw> but shachaf is write, it is not a package manager
00:58:36 <Jookia> what is cabal then?
00:58:46 <johnw> it is a build tool
00:58:47 <shachaf> shachaf is write-only.
00:58:59 <johnw> think automake, without "make uninstall"
00:59:48 <Jookia> automake can't add custom targets? :v
01:00:24 <johnw> automake can do anything; kind of like the Custom build target for cabal... :)
01:00:56 <Jookia> cabal doesn't have a custom build target?
01:01:06 <johnw> custom build type, I meant
01:01:28 <johnw> the Custom build type lets you define any build action with arbitrary Haskell code
01:02:17 <Jookia> Is there any documentation on that?
01:02:35 <johnw> you can google for examples
01:02:45 <johnw> i've used it before, it's not a highly documented feature
01:02:57 <Jookia> those two statements seem contradictory
01:03:12 <johnw> it's documented by examples on the Web
01:03:16 <johnw> not so much in the docs
01:03:56 <Jookia> so i guess i'll be writing a Setup.hs file?
01:04:05 <johnw> yep
01:04:12 <Jookia> i was told not to do that?
01:04:13 <shachaf> You should probably not write a custom uninstall target for cabal.
01:04:22 <Jookia> shachaf: i'm not going to
01:04:26 <shachaf> OK.
01:06:08 <Jookia> if all else fails i guess i could try and privately fork cabal
01:09:56 <Taneb> Is there a tutorial anywhere for how to put tests in a cabal package?
01:10:39 <johnw> Taneb: it's just like making an executable, except you call it a "Test-suite"
01:10:51 <johnw> and you have to pick a type
01:10:57 <johnw> like, exitcode-stdio-1.0
01:11:06 <supki> Taneb: cabal user-guide describes test suites
01:11:10 <johnw> that's what I use when writing hspec tests
01:12:11 <Taneb> Thanks, johnw and supki
01:23:05 * hackagebot free-game 0.9.3.1 - Create graphical applications for free  http://hackage.haskell.org/package/free-game-0.9.3.1 (FumiakiKinoshita)
01:25:49 <Jookia> Hmm... I have a question about Haskell's performance. Since data structures are immutable, wouldn't something like changing a single voxel in a tree cause a lot of memory usage or create a performance drop?
01:26:52 <shachaf> When you change a leaf in a tree you don't need to copy the entire rest of the tree.
01:27:00 <shachaf> Just the nodes in the path to the leaf.
01:28:11 <Jookia> But won't other leaves be affected by their branches suddenly changing?
01:28:24 <aleator> Jookia: Why would they?
01:28:43 <shachaf> You don't change anything.
01:28:58 <shachaf> You make a copy of the nodes in the path to the leaf.
01:29:10 <shachaf> You don't need to change any of the other nodes, since you can just reuse the old ones.
01:31:12 <Jookia> ¯\_(ツ)_/¯ I guess I read the learnyouahaskell code wrong
01:31:40 <shachaf> This is called a "persistent data structure".
01:32:04 <shachaf> It's not unique to Haskell, and has various advantages and disadvantages compared to "traditional" data structures.
01:35:19 <Peaker> ephemeral is the traditional, iirc
01:35:22 <Jookia> Ah, Wikipedia makes sense of it.
01:41:52 <arnsholt> Heck, even Java has an immutable string type
02:16:28 <quchen> Is there some reference for Cmm? Doesn't need to be complete, I'm basically looking for the difference to C. However, googling "c vs cmm haskell" doesn't work very well.
02:17:04 <companion_cube> I'm not sure, but it may be "C minus minus"
02:17:19 <quchen> Funny. Every time I ask something here, I find a relevant link 20 seconds after doing so.
02:17:20 <quchen> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/CmmType
02:17:26 <quchen> companion_cube: Thanks anyway :-)
02:18:10 <quchen> There should be a mumbling function in my client. To me it looks like I'm posting, but nobody can read it. My brain proceeds to finding a link after 20 seconds, the channel isn't disturbed. ;-)
02:18:24 <johnw> quchen: happens to me too
02:19:09 <quchen> johnw: So you know how silly I feel now
02:20:23 <johnw> know it?  I _am_ that silly
02:20:59 <quchen> ;-)
02:21:10 <quchen> Well, that Cmm page doesn't help me much.
02:22:34 <companion_cube> http://www.cminusminus.org/ quchen
02:23:09 <quchen> companion_cube: Oh. So that's what you meant with "search c minus minus".
02:24:54 <ipuustin> Hi guys, I've a QuickCheck Gen question, which I pasted here: http://hpaste.org/88670
02:25:05 <ipuustin> (sorry about the long lines there)
02:26:56 <ipuustin> Briefly, I would somehow like to feed in data / constraints from one Gen to another, or maybe use one Gen to generate them both.
02:27:08 <quchen> ipuustin: Are you familiar with forAll?
02:27:43 <ipuustin> quchen: not really, seen it used somewhere. I can look it up. Sorry, I'm quite much a newbie. :-)
02:28:14 <quchen> ipuustin: forAll is one of the neat combinators to write properties in QuickCheck.
02:28:24 <quchen> I've annotated the code with what I mean on HPaste
02:29:19 <quchen> forAll takes a generator (usually 'arbitrary'), and then a function (usually a lambda)
02:29:52 <quchen> Conceptually, forAll will fill the lambda parameter with randomly generated values.
02:30:11 <ipuustin> quchen: ok, thanks! I'll go and take a look.
02:30:47 <quchen> My annotation isn't quite right in line 6 though. It should return a Bool, but I wrote it to return a Foo.
02:31:04 <quchen> forAll might be a good start anyway :-)
02:33:21 <quchen> ipuustin: Another annotation as a (working) example.
02:33:43 <quchen> It checks whether all lists are palindromic.
02:33:53 <no-n> :t forAll
02:33:54 <lambdabot> Not in scope: `forAll'
02:34:04 <quchen> xs is used as a single input list, and in the body of the lambda it uses it twice in "reverse xs == xs".
02:34:17 <quchen> no-n: http://hackage.haskell.org/packages/archive/QuickCheck/latest/doc/html/Test-QuickCheck-Property.html#v:forAll
02:34:31 <no-n> ty
02:34:46 <maltem> Is there a way to write the following line (even) faster, using Data.Map?
02:34:50 <maltem> Map.fromListWith (+) [ (i+j, a*b) | (i,a) <- Map.toList x, (j,b) <- Map.toList y ]
02:35:50 <maltem> (s.t. it performs better, I mean)
02:36:03 <ipuustin> quchen: The example looks quite much the thing I want. Thanks again.
02:39:28 <typoclass> > let x = M.fromList [(1,3),(2,4),(7,8)] ; y = x in [ (i+j, a*b) | (i,a) <- M.toList x, (j,b) <- M.toList y ]
02:39:29 <lambdabot>   [(2,9),(3,12),(8,24),(3,12),(4,16),(9,32),(8,24),(9,32),(14,64)]
02:40:20 <no-n> what's the point in using Map a b over [(a,b)] .. faster?
02:40:34 <maltem> typoclass, in case you were wondering, it's polynomial multiplication
02:40:48 <typoclass> maltem: you have a number of duplicates in that list. since you're summing it all up in the end using fromListWith, maybe you could streamline the whole thing with some math?
02:40:49 <shachaf> Yes, it's generally faster.
02:40:59 <shachaf> It also expresses your intent better.
02:41:06 <maltem> no-n, yes, it turned out to be much faster, and also it's better suited for polynomials (I don't have to chase multiple entries)
02:41:11 <shachaf> It has no duplicate keys and no extraneous order.
02:41:19 <no-n> ah, yeah
02:41:32 <quchen> no-n: The algorithm he posted doesn't really use Map. It converts everything to lists first, then does the computation in a list comprehension, and then combines it again. If anything, fromListWith has a performance gain.
02:41:55 <no-n> ok
02:42:57 <maltem> Maybe I was asking the channel to do miracles :)
02:47:35 <quchen> maltem: The only easy way of avoiding the List business would be by folding over the one map, inserting the other one.
02:47:45 <quchen> I'm not sure that would be faster though.
02:48:28 <quchen> What I mean is that you could use something like 'foldr (insertWith ... map1) empty map2'
02:49:45 <quchen> Ah wait no that wouldn't work, the old entries of map1 wouldn't necessarily be overwritten.
02:49:47 <quchen> Hmm.
02:57:39 <johnw> quchen: are you wanting something like union or unionWith?
02:58:01 <johnw> n/m, I have no idea
02:58:07 <quchen> johnw: Not sure. I'm trying to work on maltem's problem.
02:58:44 <quchen> johnw: Basically we need a way of calculating the cartesian product of Maps without converting to List.
02:59:05 <johnw> ah, add the keys, multiply the values
02:59:21 <johnw> sum the overlapped keys
03:06:50 <quchen> Yes.
03:07:37 <johnw> are you sure a conversion will take place?
03:07:44 <johnw> that list comprehension probably fuses pretty nicely
03:07:57 <quchen> johnw: I have no idea.
03:08:09 <quchen> I would have written some other approach and then profiled it.
03:08:27 <quchen> But you're raising a good point: how bad is it to resort to intermediate lists when using Map?
03:08:44 <johnw> the intermediate lists are often converted into plain iteration in the optimized code
03:08:59 <johnw> i.e., they're just not there
03:09:40 <typoclass> maltem: by the way, how big are those maps, if performance of the list comprehension is an issue?
03:09:42 <quchen> Yes, I know.
03:10:02 <quchen> Although I'm not sure how often "often" is with Map
03:11:31 <mos_basik> @undo do n1 <- [1..6] ; n2 <- [1..6] ; [] ; return (n1, n2)
03:11:31 <lambdabot> [1 .. 6] >>= \ n1 -> [1 .. 6] >>= \ n2 -> [] >> return (n1, n2)
03:15:57 <johnw> mos_basik: liftM2 (,) [1..6] [1..6]
03:17:07 <maltem> typoclass, actually, they are quite small :) it's a bottleneck only because my code basically consists in calling this really often
03:18:45 <hiptobecubic> seeing things applicatively is always a challenge
03:18:58 <hiptobecubic> > (,) <$> [1..3] <*> [1..3]
03:18:59 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
03:20:09 <typoclass> > map (\x -> if x == 'M' then 'A' else x) "liftM2 (,) [1..6] [1..6]"
03:20:11 <lambdabot>   "liftA2 (,) [1..6] [1..6]"
03:20:55 <FreeFull> hiptobecubic: Really? I never found it to be a challenge
03:21:46 <maltem> quchen, johnw: If toList/fromListWith is the way to do it, then I'll just to decide to be happy with it. After all, it's not slow per se (the fusion seems to be there)
03:22:34 <hiptobecubic> FreeFull, it's not a challenge to use, just a challenge to see that you can.
03:23:20 <FreeFull> hiptobecubic: That's what I mean
03:23:20 <hiptobecubic> When I see something like optparse-applicative, i think "well yeah i guess it's obvious when you think about it" but that's not the same as inventing it yourself
03:24:47 <FreeFull> Well, I didn't invent Applicatives
03:24:50 <johnw> maltem: I think that until you prove it's actually slow, oftentimes the most straightforward way to express a thing in Haskell is actually the best way
03:25:00 <FreeFull> But realising I can use Applicative isn't that difficult for me
03:25:11 <typoclass> hiptobecubic: true. something feels like it's completely obvious, but still, nobody had that idea for 20 years, so it couldn't have been quite so easy and obvious
04:19:23 <fosskers> hey guys
04:19:29 <typoclass> fosskers: hello
04:19:54 <fosskers> somebody in here the other day was asking questions about a calculator there were trying to make
04:20:26 <fosskers> i got inspired and wrote a simple repl: https://github.com/fosskers/lisp-repl
04:26:55 <dudlite> is there anyway to post on hpaste as private?
04:27:05 <shachaf> Nope.
04:27:14 <no-n> @pl rotate n xs = let len = length xs in (take len . drop (len-n) . cycle) xs
04:27:15 <lambdabot> rotate = (`ap` length) . flip . liftM2 (.) take . flip flip cycle . (((.) . drop) .) . subtract
04:27:39 <fosskers> that's... elegant?
04:27:41 <no-n> yuck :s
04:28:08 * hackagebot hquantlib 0.0.2.4 - HQuantLib is a port of essencial parts of QuantLib to Haskell  http://hackage.haskell.org/package/hquantlib-0.0.2.4 (PavelRyzhov)
04:30:49 <dudlite> Would this be the correct semantics for a read expression in an interpreter
04:31:50 <dudlite> E[read] (m,i.o) = null i -> error, (hd i, (m, tl i, o))
04:31:56 <dudlite> oops
04:31:57 <dudlite> meant
04:32:02 <dudlite> (m,i,o)
04:32:11 <dudlite> where (m, i, o) is the state
04:32:15 <dudlite> memory, input and output
04:36:05 <quchen> maltem: Well, you didn't say your algorithm was slow anyway, so we took it as an academic exercise.
04:40:49 <maltem> :)
04:55:31 <fosskers> I feel like I'm close to allowing the "define" keyword
04:55:49 <fosskers> Might end up implementing lisp by accident
04:58:00 <no-n> @src (>>)
04:58:00 <lambdabot> m >> k      = m >>= \_ -> k
05:01:53 <fosskers> :t concat
05:01:54 <lambdabot> [[a]] -> [a]
05:02:59 <no-n> @src concat
05:03:00 <lambdabot> concat = foldr (++) []
05:04:37 <no-n> is haskell haskell?
05:05:37 <quchen> maltem, johnw: From looking at the Core, I think there is an intermediate list.
05:05:44 <quchen> But I'm not very experienced with Core.
05:05:59 <quchen> Does anyone remember this online Haskell paste site that displays Core nicely?
05:06:08 <quchen> It was posted on Reddit a couple of weeks back
05:06:35 <fosskers> :t and
05:06:36 <lambdabot> [Bool] -> Bool
05:07:09 <fosskers> no-n: what do you mean?
05:07:42 <no-n> :>
05:23:09 * hackagebot conduit 1.0.5.1 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.5.1 (MichaelSnoyman)
05:46:21 <Zeev> in what chapter of "learn you a haskell" it's written about "$" sign like in " putStrLn $ "Read this carefully, because this is your future: "
05:47:00 <merijn> Zeev: I don't know the specific chapter, but $ is just a function "f $ x = f (x)"
05:49:45 <Saizan> @src ($)
05:49:46 <lambdabot> f $ x = f x
05:50:50 <Saizan> Zeev: it's an operator for function application, it's mostly uses to avoid parentheses because it has the lowest precedence
05:51:14 <Saizan> Zeev: though i don't know if LYAH talks about it specifically
05:55:03 <bakibour> Greetings
05:55:27 <bakibour> Does anyone know if Remi Turk is hanging out here?
05:55:36 <bakibour> The owner of the libffi package.
05:56:40 <shachaf> preflex: seen RemiTurk
05:56:40 <preflex>  Sorry, I haven't seen RemiTurk
05:56:53 <shachaf> preflex: seen Remi
05:56:53 <preflex>  Remi was last seen on #vim 1 year, 135 days, 20 hours, 30 minutes and 43 seconds ago, saying: mhi^: thanks!
05:57:00 <bakibour> Wow :)
05:57:07 <shachaf> Well, back in 2007.
05:57:15 <Zeev> merijn: what's the difference between putStr "abc" and putStr $ "abc"
05:57:24 <Zeev> when can I omit the $
05:57:47 <shachaf> None.
05:58:10 <shachaf> Ask rather about the meaning of f x $ g y
05:58:28 <merijn> Zeev: None, the difference is when the argument is more than one thing
05:59:15 <tekul> Zeev: http://learnyouahaskell.com/higher-order-functions#function-application
05:59:53 <merijn> "f x g y = (((f x) g) y)", "f $ x g y = f ((x g) y)", "f x $ g y = ((f x) (g y))", "f x g $ y = "(((f x) g) y)"
06:02:48 <Zeev> tekul: thanks
06:03:13 <Zeev> snoozed through that part
06:03:59 <jmcarthur> "Unlifted types cannot currently be used to represent terminating functions: an unlifted type on the right of an arrow is implicitly lifted to include _|_."  <-- this doesn't mean anything special about representation, does it? it's just a statement that unlifted types don't magically create a termination checker?
06:04:10 <jmcarthur> from http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects
06:04:30 <quchen> Zeev: For pratical purposes, you can read $ as an opening parenthesis that reaches to the end of the line.
06:05:03 <Zeev> quchen: yeah, thanks that's exactly what's written in lyah
06:05:24 <shachaf> jmcarthur: Seems right.
06:05:38 <shachaf> jmcarthur: Well, it's slightly different with functions and lifted types.
06:06:30 <jmcarthur> oh?
06:06:30 <shachaf> When f returns a lifted type I would think of it as the application (f x) "terminating" and giving you a value, which might not terminate when you evaluate it.
06:06:46 <jmcarthur> ah, right
06:06:56 <shachaf> But here with unlifted types (and also with strict languages in general) (->) gets the magic notermination powers.
06:07:27 <jmcarthur> that doesn't sound like _|_ to me
06:07:46 <enigmuriatic> does anyone know of any good lectures to listen to during a five hour solo drive? I'm open to both haskell and non-haskell topics
06:07:51 <enigmuriatic> preferably things I can download
06:08:04 <shachaf> Well, evaluating (f x) gives you ⊥.
06:09:26 <shachaf> @localtime shachaf -- I may not be making sense.
06:09:29 <lambdabot> Local time for shachaf is Mon May 27 06:09:18 2013
06:10:57 <jmcarthur> evaluating it doesn't terminate, but that's not what _|_ is. _|_ is just a model for expressions that don't terminate *when evaluated*. the witnessing of nonterminating has nothing to do with it. (this is just my understanding and could be wrong, but if i am wrong i really want to know)
06:11:41 <bubu> Hello. How can i overload the == operator for functions (a - > Int) to tell me if two functions g and f are equal. I want them to be equal if  f 0 == g 0 ?
06:12:07 <Fuuzetsu> make them an instance of Eq?
06:12:09 <shachaf> bubu: This is a pretty bad thing to do because it's completely global (and generally wrong).
06:12:11 <bubu> I've read that this is impossible for every input
06:12:21 <bubu> and seems logic
06:12:32 <jmcarthur> so my understanding would imply that if you can't get an unevaluated value then _|_ is not a possibility, even if the function itself could still not terminate
06:12:36 <shachaf> But yes, it's possible. But you should probably use a different type instead.
06:12:37 <Fuuzetsu> It's probably not what you want to do
06:13:15 <bubu> so the definition would become global for every function?
06:13:22 <Saizan> jmcarthur: in the end you want X -> Y# to be a computable functional subset of "X * (Y# + {_|_})" you need _|_ there to give a semantic to non-termination, now if X -> Y is interpreted as a subset of X * Y, then you can say the meaning of X -> Y# is about taking Y = Y# + {_|_}
06:13:24 <jmcarthur> bubu: you probably want to use a newtype
06:13:48 <bubu> :( ok, i'll try
06:14:20 <shachaf> If f :: Int# -> Int#, and x = 5# and y = f x, where is the nontermination represented?
06:14:34 <jmcarthur> Saizan: that presentation seems fair because it doesn't smash _|_ into the denotation for Y#, i guess
06:15:21 <int-e> shachaf: it doesn't need a representation. it will simply fail to terminate.
06:15:28 <jmcarthur> shachaf: Saizan's explanation i think sufficiently covers that
06:15:31 <shachaf> Right.
06:15:34 <int-e> shachaf: but maybe that's your point.
06:16:00 <shachaf> Saizan's explanation is good.
06:16:12 <jmcarthur> it's some presentation of the partiality monad
06:17:11 <Saizan> the "Y = Y# + {_|_}" is what "implicitly lifted" in the docs refers to, afaiu
06:17:23 <shachaf> The way in strict languages (->) does this everywhere is really weird, from a non-strict perspective.
06:17:57 <shachaf> Or at least from my perspective.
06:18:31 <jmcarthur> thanks shachaf and Saizan
06:18:34 <Saizan> yeah, it's sort of like their -> is a Kleisly NT
06:18:40 <Saizan> Kleisli
06:20:55 * shachaf goes to sleep
06:21:27 <Saizan> but their starting category is the one of unlifted types, i guess
06:24:03 <jmcarthur> right
06:24:50 <jmcarthur> i actually like the semantics of strict languages in some ways. when a function returns you know you have a useful value.
06:25:06 <shachaf> Or when you get an argument.
06:25:10 <jmcarthur> right
06:25:15 <shachaf> -> is the only place where nontermination can happen.
06:25:26 <shachaf> Whereas with nonstrict languages it never happens in ->.
06:26:12 <shachaf> Is there a situation where you have lifted values and also lifted ->?
06:26:15 <Saizan> as long as const undefined ~ undefined
06:26:49 <Saizan> shachaf: haskell with seq :)
06:27:02 <shachaf> Ah, right.
06:27:14 <shachaf> Well, I'm talking about *application* being nonterminating.
06:27:25 <shachaf> As opposed to the function giving you a nonterminating value.
06:27:36 <shachaf> I don't know if the distinction makes sense...
06:27:56 <jmcarthur> e.g. the argument is evaluated before applying the function, as in a strict language?
06:28:49 <shachaf> In a strict language, f :: A -> B; f x = f x promises that it'll give you a useful value, but never actually gives you anything.
06:29:09 <shachaf> In a nonstrict language the same function gives you a value immediately but doesn't promise it'll be useful.
06:29:24 <shachaf> In a total language you get the best of both worlds. Is there a situation where you get the worst of both worlds?
06:30:02 <Saizan> under some isomorphism you could do A -> (() -> B) in a strict language
06:30:23 <shachaf> I suppose.
06:30:40 <shachaf> This question is pretty useless so I don't really expect a useful answer. :-)
06:31:10 <Saizan> could be an excuse to learn about call-push-value stuff
06:31:27 <shachaf> I'm not sure I've ever seen this ->/value distinction explicitly written about. Not that I've ever read anything on the topic.
06:31:52 <jmcarthur> harper wrote a blog post that glossed over this difference once
06:32:19 <jmcarthur> it was one of his explanations of why haskell is teh suck or something
06:32:29 <Saizan> i suspect Moggi has used it as an example of how to do denotational semantics with monads
06:33:48 <shachaf> I wonder what Haskell would be like if it had actual unlifted types as standard.
06:34:12 <shachaf> tibbe-friendly, I suppose.
06:35:04 <shachaf> Anyway, as I was saying...
06:35:16 * shachaf vanishes in a puff of orange smoke.
06:35:18 <jmcarthur> i've always wanted newtype with multiple fields :)
06:37:01 <hiptobecubic> isn't that "data" ?
06:37:20 <hiptobecubic> minus the optimizations which are possible when you only have one type param
06:37:48 <jmcarthur> no
06:38:07 <jmcarthur> hiptobecubic: take it in the context of unlifted types (in particular, unboxed tuples)
06:39:27 <jmcarthur> of course then you have to solve all the weird questions that unboxed tuples bring about (and avoid right now by simply not allowing certain uses)
06:39:45 <jmcarthur> like what happens when you use one as a field in a data constructor
06:43:03 <typoclass> from our series on random things that i've never done before: "x@(Just y) = Just 42" at top level, defining the names x and y
06:43:36 <mauke> x@y@z = 42
06:46:30 <papyrus> hi
06:47:58 <papyrus> i have a qustion. i am reading Writer Monad of All about monad . this is from "http://www.haskell.org/haskellwiki/All_About_Monads#The_Writer_monad"
06:48:29 <Taneb> papyrus, fire away
06:48:32 <papyrus> but , compile error happends
06:49:01 <papyrus> i am sorry i am not good speak english. what's mean "fire away"?
06:49:09 <Taneb> Ask your question
06:49:20 <papyrus> ok.
06:49:30 <Taneb> What's the error?
06:49:49 <papyrus> listens :: (Monad m) => MyWriter (a,w) -> m (a,w)
06:50:00 <papyrus> listens m = do (a,w) <- m
06:50:10 <papyrus>                return (a,w)
06:51:01 <geekosaur> (don't paste direrctly into the channel)
06:51:04 <Botje> papyrus: all monads in a do block must be the same monad.
06:51:14 <Botje> papyrus: you will probably need to runMyWriter m instead.
06:51:54 <weebl> hey guys, i have a list of tuples Eq a => [(a,b)]
06:52:12 <papyrus> you mean the tutorial (all about monad) is wrong? or errora?
06:52:17 <weebl> there can be duplicate entries in a, and i want to do the union over b if they are the same so i don't have duplicate entries
06:52:26 <weebl> how can i do this in an easy way
06:52:59 <hpc> weebl: convert to and from Map a b, change Eq constraint to Ord
06:54:46 <typoclass> weebl: as hpc is saying, try M.fromList on your list, then use one of the union functions from http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map-Lazy.html#g:9 . does this make sense?
06:54:55 <weebl> > let a = [(1,"+"),(2,"-"),(1,"-"),(2,"0"),(3,"+")] in Data.Map.fromList a
06:54:56 <lambdabot>   Not in scope: `Data.Map.fromList'
06:55:07 <weebl> > let a = [(1,"+"),(2,"-"),(1,"-"),(2,"0"),(3,"+")] in fromList a
06:55:09 <lambdabot>   Not in scope: `fromList'
06:55:09 <lambdabot>  Perhaps you meant one of these:
06:55:09 <lambdabot>    `IM.fromList' ...
06:55:17 <weebl> > let a = [(1,"+"),(2,"-"),(1,"-"),(2,"0"),(3,"+")] in DM.fromList a
06:55:18 <lambdabot>   Not in scope: `DM.fromList'
06:55:18 <lambdabot>  Perhaps you meant one of these:
06:55:19 <lambdabot>    `IM.fromLis...
06:55:54 <geekosaur> papyrus, I do not see the thing you pasted in the tutorial
06:56:07 <papyrus> wait...
06:56:34 <typoclass> weebl: lambdabot is also available privately by doing "/query lambdabot"
06:56:37 <weebl> hpc, typoclass: it ignores any duplicate entries in the list though?
06:57:09 <typoclass> > M.fromList [(42,37)] -- silly one-entry map
06:57:10 <lambdabot>   fromList [(42,37)]
06:57:40 <weebl> > M.fromList [(42,"a"),(42,"b")]
06:57:41 <lambdabot>   fromList [(42,"b")]
06:57:48 <typoclass> weebl: you're right. for more control over this, you can use fromListWith or fromListWithKey
06:57:49 <weebl> should become [(42,"ab")]
06:58:31 <papyrus> geekosaur : http://hpaste.org/88692
06:58:37 <typoclass> > M.fromListWith (++) [(42,"a"), (42, "b")] -- example, though it's reversed
06:58:38 <lambdabot>   fromList [(42,"ba")]
06:58:44 <weebl> ah
06:58:54 <geekosaur> papyrus, yes, and the listens there is not the one you pasted
06:59:16 <geekosaur> [27 09:49] <papyrus> listens :: (Monad m) => MyWriter (a,w) -> m (a,w)
06:59:23 <geekosaur> not the same thing
07:01:35 <papyrus> i think so.. but.. what i am confusing  is that the tutorial is famouse .
07:03:37 <papyrus> thanks a ton geekosaur.
07:04:05 <papyrus> the tutorial (all about moand) is wrong? or language specification is change?
07:04:12 <piezoid> hi, is there a shorcut for "maybe ( return () ) f ma" ?
07:05:06 <mux> I personally write a whenJust function for this
07:05:14 <mauke> maybe def f ma
07:05:23 <elliott> piezoid: yes
07:05:27 <elliott> piezoid: forM_ ma f
07:05:29 <elliott> or mapM_ f ma
07:05:32 <elliott> with Data.Foldable
07:05:52 <elliott> no need to write a function for it :)
07:06:28 <piezoid> ok thank :)
07:07:17 <geekosaur> papyrus, I have no idea what you were saying above. and while there have been some changes to the "canned" monads, you're not working with those and this should work
07:07:46 <geekosaur> (you would get an error if you had the predefined one imported, but you would anyway for redefinition)
07:08:49 <papyrus> thanks geekkosaur . :-)
07:08:49 <typoclass> papyrus: hello. when i try to compile the code that you pasted, i get this compiler error: http://hpaste.org/88692 is this the question you're asking? how to fix this compiler error?
07:09:17 <papyrus> {-# LANGUAGE MultiParamTypeClasses  #-}
07:09:27 <papyrus> {-# LANGUAGE FunctionalDependencies #-}
07:10:23 <typoclass> papyrus: yes, i needed to add those two lines. i also needed to do "import Data.Monoid"
07:10:32 <papyrus> yes.
07:11:05 <papyrus> when "import Data.Monoid"  ,but error occurs.
07:11:43 <papyrus> my question is that language specification is changed? or simple errata ? or another reason?
07:12:05 <elliott> if you have an error you should hpaste it.
07:12:06 <elliott> @hpaste
07:12:06 <lambdabot> Haskell pastebin: http://hpaste.org/
07:14:25 <bookerz> Is it odd that Data.List.Utils.split _ "" = [] and not [""]?
07:14:38 <bookerz> I mean, split "foo" "a" = ["a"]
07:15:40 <typoclass> bookerz: hm ... it really is? i'd have expected split "foo" "a" = ["foo"]
07:16:43 <bookerz> yeah -- the first string is the token over which to split
07:16:52 <bookerz> the second string the string to be split
07:17:20 <typoclass> bookerz: ooh i'm sorry :-) i swapped them
07:17:35 <typoclass> bookerz: so, you're talking about MissingH, right? http://hackage.haskell.org/packages/archive/MissingH/0.18.6/doc/html/Data-List-Utils.html#v%3Asplit
07:17:41 <bookerz> nod
07:18:12 <overdamped> it makes the fixed point a common match
07:19:24 <bookerz> overdamped: mmm... I'm not sure what that means.
07:19:37 <bookerz> But if it means that there's sense to it and it's a feature and not a bug, that works for me
07:20:20 <bookerz> It just seemed odd to me that the function's behavior be different when the second string is empty
07:20:35 <typoclass> bookerz: i can see your point
07:20:57 <overdamped> bookerz: it's easy to tell that recursive invocation of the function will always end up with []
07:21:12 <overdamped> I'm assuming feature
07:21:29 <bookerz> I totally understand why it was implemented with "split _ [] = []"
07:21:43 <bookerz> But that doesn't make as much sense to the user
07:21:56 <typoclass> what happens for split "," "a," ?
07:22:20 <bookerz> ["a",""]
07:22:47 <overdamped> hrm... it makes it easier for the user to know when to terminate recursion
07:23:56 <bookerz> Ah.  If recursing on the split data, the user wouldn't have to check for equality to the empty string?
07:24:36 <typoclass> bookerz: hm ... you can get empty strings anyway, e.g. by splitting "a,,b"
07:25:21 <bookerz> typoclass: totally.  It's only when the empty string is an input does the functions behavior have that special case
07:26:44 <dmwit> papyrus: Yes, the tutorial is wrong.
07:26:46 <typoclass> bookerz: anyway, it's not completely clear to me. maybe the 'split' package is more principled?
07:26:56 <typoclass> dmwit: papyrus is gone
07:27:11 <overdamped> bookerz: I think it sounds that when it fails to split a string that it returns []
07:27:34 <bookerz> overdamped: nod -- which seems weird to me
07:27:40 <bookerz> overdamped: I'd expect [[]]
07:28:02 <bookerz> overdamped: wait -- I guess that depends on what you mean by "fails to split"
07:28:22 <bookerz> because {split "," "a" = "a"}
07:28:26 <dmwit> Well, the tutorial is right now. =)
07:28:40 <overdamped> bookerz: There is no match to the substring with which you're splitting in the string that you would like to split
07:29:05 <dmwit> It's still formatted terribly, though.
07:29:06 <dmwit> =/
07:29:16 <typoclass> bookerz: you're essentially saying the length of the returned list should always be number of delimiters in the string plus 1. this is violated if the string is empty
07:29:23 <overdamped> Therefore there is no result to return... and therefore the empty list is returned
07:30:07 <typoclass> overdamped: right, but by that logic, shouldn't split "," "abc" also give [] ?
07:30:11 <bookerz> typoclass: totally agree that that is an assumption of mine
07:30:29 <overdamped> overdamped: yes
07:30:34 <overdamped> typoclass: yes
07:30:58 <typoclass> overclass: yes yes
07:31:04 <typoclass> (sorry could not resist) =)
07:31:27 <overdamped> overclass: understandable ;)
07:32:12 * dmwit seconds the recommendation to use "split" instead of "MissingH".
07:33:41 <bookerz> typoclass: you're intuition was good -- Data.List.Split behaves as expected
07:33:45 <bookerz> your
07:33:48 <bookerz> hmm
07:33:59 * typoclass purrs
07:34:03 <bookerz> :-)
07:34:24 <efie> I have an IO.Vector from Data.Vector.Unboxed.Mutable. I want to go though a list, and for each element process the element and update the vector. If I understand Data. ... .Mutable right I don't have to return the Vector after processing the list to work with the updated Vector later... should I go over the list using foldM, or mapM or how should this be done?
07:35:05 <Philonous> efie:  mapM would do the trick.
07:35:16 <Philonous> efie:  Actually, mapM_
07:35:35 <Philonous> efie:  mapM_ is like "for each" in other languages
07:36:08 <hpc> it's usually more readable to use forM_
07:36:35 <hpc> forM_ = flip mapM_ -- the action is on the right so you can use a trailing do-block with it
07:36:35 <Philonous> forM_ is just flip mapM_ , but I agree, I like forM_ better as well
07:36:42 <bookerz> It worth filing a bug to MissingH?  Or would any modification change the interface so much that it's not implementable?
07:36:53 <typoclass> > let for = flip map in for "LOLcats" toLower
07:36:54 <lambdabot>   "lolcats"
07:37:21 <efie> ok thanks
07:38:16 <Philonous> typoclass:  I wish that was in the prelude
07:38:38 <yitz> bookerz: most people use the split library nowadays. it's in the Haskell Platform.
07:38:50 <efie> when I use foldM I have a starting value which I actualyl don't need ... isn't this confusing respectively not that readable?
07:39:23 <bookerz> yitz: good to know -- thanks!
07:39:29 <hpc> Philonous: it's in either foldable or traversable
07:40:06 <hpc> Philonous: for is less useful than forM imo, because large pure functions tend to get uglier much faster than do-blocks
07:41:00 <yitz> bookerz: other than making it run with more recent ghc and fixing the license, it looks from github that nothing has changed in missingh for several years.
07:41:24 <Philonous> hpc:  Well, the import list gets long quickly when you import Traversable, Applicative, Monad etc everywhere.
07:41:27 <elliott> hpc: huh?
07:41:31 <elliott> for is forM for Applicative
07:41:38 <hpc> oh
07:41:38 <elliott> oh, this is about some other for...
07:41:41 <typoclass> quiz: in "(a -> f b) -> t a -> f ()", there's a Foldable. which variable stands for Foldable? f? brzzzzt wrong, it's t of course
07:41:42 <hpc> nvm then
07:41:43 <typoclass> =)
07:42:37 * typoclass can find only for_ and traverse_ in Foldable, not for ...
07:42:50 <yitz> @djinn (a -> f b) -> t a -> f ()
07:42:51 <lambdabot> -- f cannot be realized.
07:42:58 <Philonous> typoclass:  for is in Data.Traversable
07:43:15 <typoclass> Philonous: ah. thanks
07:43:53 <typoclass> Philonous: regarding long import lists, i have a file Base.hs which imports the common stuff. i usually only need "import Base" and 1-2 others
07:44:45 <Philonous> Well, I could add that Base file to my skeleton script for new projects.
08:15:28 <efie> In Data.Vector.Unboxed there is a function ifoldl, which also takes the index of an element of a vector as an argument. However, I need a monadic version of this: ifoldM.  I did a ticket for this a while ago, but until now no one responded. I tried to chase down the implemenation of ifold, but it uses streams which I don't know. Does anyone know how to implement this or what I could do? SO is not the right place for this to ask, is it
08:19:26 <supki> @ty ifoldlM
08:19:27 <lambdabot> (Monad m, FoldableWithIndex i f) => (i -> b -> a -> m b) -> b -> f a -> m b
08:19:59 <efie> supki: where can this be found?
08:20:14 <supki> that's lens
08:20:42 <supki> unboxed vectors don't have that instance though
08:20:47 <supki> not sure if it's intentional
08:21:23 <jonkri> dmwit: hey. you around? :)
08:21:33 <roconnor> @type Data.Vector.Unboxed.ifold
08:21:34 <lambdabot> Not in scope: `Data.Vector.Unboxed.ifold'
08:21:35 <roconnor> @type Data.Vector.Unboxed.ifoldl
08:21:37 <lambdabot> Data.Vector.Unboxed.Base.Unbox b => (a -> Int -> b -> a) -> a -> Data.Vector.Unboxed.Base.Vector b -> a
08:21:39 <supki> probably you can copypaste instance for boxed vectors and see if it works
08:23:43 <efie> supki: I don't see a ifoldM in Data.Vector
08:24:22 <roconnor> @type (\f -> Data.Vector.Unboxed.ifoldl (\a i x -> a >>= (\a' -> f a' i x)))
08:24:23 <lambdabot> (Monad m, Data.Vector.Unboxed.Base.Unbox b) => (a -> Int -> b -> m a) -> m a -> Data.Vector.Unboxed.Base.Vector b -> m a
08:24:47 <supki> efie: ifoldl/rM should be possible to define with ifoldr/l
08:26:15 <roconnor> @pl (\f -> Data.Vector.Unboxed.ifoldl (\a i x -> a >>= (\a' -> f a' i x)))
08:26:16 <lambdabot> Data.Vector.Unboxed.ifoldl . flip ((.) . (.) . (>>=)) . (flip .) . flip
08:26:56 <efie> supki: Ifold looks like this: ifoldl f z = Stream.foldl (uncurry . f) z . Stream.indexed . stream
08:27:09 <efie> I don't know Streams
08:27:44 <roconnor> efie: let ifoldM f = Data.Vector.Unboxed.ifoldl (\a i x -> a >>= (\a' -> f a' i x))
08:33:13 * hackagebot fixedprec 0.1 - A fixed-precision real number type  http://hackage.haskell.org/package/fixedprec-0.1 (PeterSelinger)
08:34:42 <jonkri> what should i think about when i make a Read and Show instances? i'm thinking about making such instances for <http://tools.ietf.org/html/rfc6122> (which can contain all sorts of strange characters)
08:35:24 <jonkri> if it's helpful, double quotes (") appears to be prohibited in all parts of the xmpp address
08:35:58 <elliott> jonkri: Show/Read are for cheap serialisation/debugging. your Show output should ideally be lexically valid Haskell, and if you can make it valid Haskell that returns the original object, even better.
08:36:27 <supki> I expect  read . show = id  if both Read and Show are defined
08:37:38 <efie> roconnor: thanks a lot!
08:37:42 <jonkri> elliott: do you disagree with this comment? <https://github.com/pontarius/pontarius-xmpp/commit/c534456#commitcomment-3295336>
08:38:40 <elliott> jonkri: yes. though I am ok if you make your Show instance say something like: parseAddress "foo@bar.com", where parseAddress is the function that does that
08:38:47 <elliott> that's both readable and valid Haskell code
08:39:07 <elliott> worst case you can do something like <<foo@bar.com>>. just junk delimiters to deliniate the invalidity
08:39:32 <elliott> jonkri: Map's Show/Read instances are an example of custom Show instances I consider ideal
08:39:34 <c_wraith> Especially when you're doing it for a data type that contains a function
08:39:52 <elliott> c_wraith: yeah, in that case I might just say <TheTypeName> or whatever to make debugging easier
08:44:21 <c_wraith> depends on whether it's *just* functions, or it has some extra data packed in as well.
08:44:55 <c_wraith> sometimes you might be able to include useful information
08:46:30 <jonkri> elliott: when you say that the Show output should ideally be lexically valid Haskell, do you have some kind of "authorative" source for this statement? or is it a convention?
08:48:39 <elliott> jonkri: convention, but also the existing instances and derived ones, and the fact that they use Haskell's notion of operator precedence, etc. maybe the Report says something too
08:49:47 <elliott> also things like Reader's "lex" follow Haskell's syntax etc.
08:50:03 * jonkri is reading http://www.haskell.org/onlinereport/basic.html (6.3.3)
08:50:20 <elliott> anyway, if you have a parseAddress function, then my suggested form is IMO better in every way
08:50:32 <elliott> you keep the readable output but maintain strict validity as Haskell code
08:50:40 <elliott> (which is useful for pasting GHCi output back in as objects, etc.)
08:55:50 <acube> :t (id :: forall ctx. (forall a. ctx a => a -> a) -> (forall a. ctx a => a -> a)) show
08:55:51 <lambdabot>     Couldn't match expected type `a -> a'
08:55:51 <lambdabot>                 with actual type `forall a1. (ctx a1) => a1 -> a1'
08:55:51 <lambdabot>     Expected type: (forall a1. (ctx a1) => a1 -> a1) -> a -> a
08:56:22 <jonkri> elliott: thank you so very much for your help :)
08:56:28 <acube> :t (id :: (c ~ forall ctx. (forall a. ctx a => a -> a)) => c -> c) show
08:56:29 <lambdabot> parse error on input `forall'
08:56:46 <acube> :t (id :: forall ctx. (c ~ (forall a. ctx a => a -> a)) => c -> c) show
08:56:47 <lambdabot> Not in scope: type variable `c'
08:56:47 <lambdabot> Not in scope: type variable `c'
08:56:47 <lambdabot> Not in scope: type variable `c'
08:56:54 <acube> :t (id :: forall ctx. forall c. (c ~ (forall a. ctx a => a -> a)) => c -> c) show
08:56:55 <lambdabot>     Illegal equational constraint c ~ (forall a. (ctx a) => a -> a)
08:56:55 <lambdabot>     (Use -XGADTs or -XTypeFamilies to permit this)
08:56:55 <lambdabot>     In an expression type signature:
08:57:03 <elliott> jonkri: :)
09:01:17 <acube> How can I fix this error?
09:01:20 <acube> > let typef :: (forall a. forall b. ctx a => a -> b) -> (forall a. forall b. ctx a => a -> b); typef a = a in typef show
09:01:21 <lambdabot>   Could not deduce (b1 ~ [GHC.Types.Char])
09:01:21 <lambdabot>  from the context (ctx a)
09:01:21 <lambdabot>    bound...
09:01:43 <acube> @ty let typef :: (forall a. forall b. ctx a => a -> b) -> (forall a. forall b. ctx a => a -> b); typef a = a in typef show
09:01:45 <lambdabot>     Could not deduce (b1 ~ [Char])
09:01:45 <lambdabot>     from the context (ctx a)
09:01:45 <lambdabot>       bound by the inferred type of it :: (ctx a) => a -> b at Top level
09:01:50 <elliott> acube: show does not match (forall a. forall b. ctx a => a -> b)
09:01:54 <elliott> it matches (forall a. ctx a => a -> String)
09:01:58 <acube> a right
09:01:59 <elliott> perhaps you want forall b. on typef, not its parameter
09:02:57 <acube> @ty let typef :: (forall a. ctx a => a -> (forall b. ctx2 b => b)) -> (forall a. forall b. ctx a => a -> (forall b. ctx2 b => b)); typef a = a in typef show
09:02:58 <lambdabot>     Could not deduce (b1 ~ [Char])
09:02:58 <lambdabot>     from the context (ctx2 b, ctx a)
09:02:58 <lambdabot>       bound by the inferred type of it :: (ctx2 b, ctx a) => a -> b
09:03:36 <acube> hmm, that would be possible with ctx = Show and ctx2 a = a ~ String ?
09:03:57 <acube> Anyway, I can just fix ctx2 to my needs, thanks
09:04:50 <acube> @ty let typef :: (forall a. ctx a => a -> b) -> (forall a. ctx a => a -> b); typef a = a in typef show
09:04:51 <lambdabot>     Could not deduce (Show a1) arising from a use of `show'
09:04:51 <lambdabot>     from the context (ctx a)
09:04:51 <lambdabot>       bound by the inferred type of it :: (ctx a) => a -> [Char]
09:04:56 <acube> still does not work :(
09:05:43 <acube> elliott: any idea on how to fix that error without using a type annotation on typef (in the "in" clause)
09:05:45 <acube> ?
09:06:25 <elliott> I think you pretty much have to give a type signature when being polymorphic over ctx liek that
09:06:31 <elliott> perhaps you can settle for only giving show one
09:06:50 <acube> @ty let typef :: (forall a. ctx a => a -> b) -> (forall a. ctx a => a -> b); typef a = a in typef (show :: (forall a. Show a -> b))
09:06:51 <lambdabot> Not in scope: type variable `b'
09:07:01 <acube> @ty let typef :: (forall a. ctx a => a -> b) -> (forall a. ctx a => a -> b); typef a = a in typef (show :: forall b. (forall a. Show a -> b))
09:07:02 <lambdabot>     Predicate `Show a' used as a type
09:07:02 <lambdabot>     In an expression type signature: forall b a. Show a -> b
09:07:02 <lambdabot>     In the first argument of `typef', namely
09:07:18 <acube> @ty let typef :: (forall a. ctx a => a -> b) -> (forall a. ctx a => a -> b); typef a = a in typef (show :: (forall a. Show a -> a -> String))
09:07:20 <lambdabot>     Predicate `Show a' used as a type
09:07:20 <lambdabot>     In an expression type signature: forall a. Show a -> a -> String
09:07:20 <lambdabot>     In the first argument of `typef', namely
09:07:24 <acube> @ty let typef :: (forall a. ctx a => a -> b) -> (forall a. ctx a => a -> b); typef a = a in typef (show :: (forall a. Show a => a -> String))
09:07:26 <lambdabot>     Could not deduce (Show a1)
09:07:26 <lambdabot>       arising from an expression type signature
09:07:26 <lambdabot>     from the context (ctx a)
09:07:28 <acube> :(
09:07:53 <elliott> try a boxed data type
09:08:00 <elliott> it makes this stuff type better, I think
09:08:08 <acube> like data ExplicitContext ctx a ?
09:08:20 <acube> that might work
09:08:23 <acube> thanks
09:08:23 <elliott> data Blah ctx b = Blah (forall a. ctx a => a -> b)
09:08:31 <elliott> showBlah :: Blah Show String; showBlah = Blah show
09:08:43 <elliott> typef :: Blah ctx b -> Blah ctx b; typef a = a
09:10:18 <Feuerbach> Does anyone know of a convenient way to generate haddocks which can be published on the web?
09:12:05 <BMeph> Better: "Does anyone know of a convenient way to generate haddocks?" ;)
09:12:18 <acube> Using cabal ?
09:12:34 <Feuerbach> yeah, cabal works fine - but the hyperlinks are all absolute
09:18:00 <BMeph> Meme alert: "Someone who has a problem generating haddocks, may say 'I know, I'll use cabal!' Now,..." ;þ
09:22:03 <schoppenhauer> hello. is there a possibility to get a copy of a record in which only one field is changed, apart from completely creating a new one?
09:22:19 <geekosaur> theRecord { field = newValue }
09:23:24 <acube> Can I have explicit kind signatures for constraint kinds?
09:23:41 <acube> * -> Constraint gives: Not in scope: type constructor or class `Constraint'
09:23:50 <Feuerbach> acube: it's in GHC.Exts I think
09:24:18 <acube> Feuerbach: thanks!
09:24:32 <schoppenhauer> geekosaur: thank you.
09:28:14 * hackagebot haskell-packages 0.1 - Haskell suite library for package management and integration with Cabal  http://hackage.haskell.org/package/haskell-packages-0.1 (RomanCheplyaka)
10:03:15 * hackagebot liblastfm 0.2.0.0 - Lastfm API interface  http://hackage.haskell.org/package/liblastfm-0.2.0.0 (MatveyAksenov)
10:14:17 <logicbuffer> Is Prelude more of a general prompt for GHC that lets me load modules and whatnot and ghci is just the execution environment for single line commands and scripts or what?
10:14:36 <logicbuffer> I'm not understanding the difference between the two I guess.
10:14:45 <Taneb> Prelude is just a library that's imported by default
10:15:11 <Taneb> GHCi lists the modules imported as the prompt
10:17:55 <logicbuffer> Interesting. So it's just the library that provides all the standard type classes and whatnot? That's what I'm getting from http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html anyway
10:18:00 <elliott> yes
10:18:12 <Sculptor> yo
11:03:51 <acube> is (forall g. g -> c g) the same as just c ?
11:04:13 <acube> (I can't do anything with the g, can I?)
11:04:34 <latro`a_> seems isomorphic to me
11:04:45 <acube> @type gunfold
11:04:47 <lambdabot>     Not in scope: `gunfold'
11:04:47 <lambdabot>     Perhaps you meant one of these:
11:04:47 <lambdabot>       `unfoldr' (imported from Data.List),
11:04:49 <acube> @type gfoldl
11:04:51 <lambdabot>     Not in scope: `gfoldl'
11:04:51 <lambdabot>     Perhaps you meant one of these:
11:04:51 <lambdabot>       `foldl' (imported from Data.List),
11:05:00 <latro`a_> ah wait no, that's basically a value constructor type
11:05:07 <latro`a_> :t Just
11:05:08 <lambdabot> a -> Maybe a
11:05:17 <latro`a_> a value can't have type Maybe
11:05:27 <latro`a_> so it's not exactly "the same"
11:05:59 <acube> but I can do the same things as with a plain c? (A c of kind * then of course)
11:06:08 <elliott> I don't understand the question
11:06:19 <latro`a_> what you wrote up there has kind *, best I can tell
11:06:22 <elliott> how do you make a comparison between a c of kind * -> * and a c of kind *?
11:07:00 <latro`a_> the c has kind * -> *, but there isn't a way to make values with it, and for good reason: what if c has more than one constructor
11:07:32 <elliott> huh?
11:07:43 <acube> is forall g. c g ~ a, where a is some type of kind * ?
11:08:13 <elliott> do you mean (forall g. c g) or (forall g. g -> c g)?
11:08:22 <latro`a_> the first one already is of kind *
11:08:32 <elliott> and what do you mean by ~ here? and what is a?
11:08:35 <latro`a_> so is the second one, actually
11:08:43 <elliott> I don't know how to make sense of what you're asking
11:09:00 <latro`a_> I think you're asking "is c ~ (forall g. g -> c g)", to which the answer is no
11:09:12 <acube> Ok, wait, I try to reformulate my question
11:09:26 <elliott> the answer isn't "no", the question is a kind error
11:09:31 <elliott> it's just meaningless
11:09:50 <fullvlad> Hi!
11:10:05 <fullvlad> What's the type of the following function in Haskell ?
11:10:14 <fullvlad> f x y = x (f y x)
11:10:27 <roconnor> @type let f x y = x (f y x) in f
11:10:28 <lambdabot> (t -> t) -> (t -> t) -> t
11:10:28 <elliott> @type let f x y = x (f y x) in f
11:10:30 <lambdabot> (t -> t) -> (t -> t) -> t
11:11:20 <fullvlad> @lambdabot Why it's that the correct answer?
11:11:20 <lambdabot> Unknown command, try @list
11:11:46 <Fuuzetsu> lambdabot isn't human~
11:11:51 <Fuuzetsu> (yet)
11:12:45 <fullvlad> ok :)) I wasn't sure
11:13:59 <acube> If I have a function of (forall g. g -> c g) -> s  -> c s, what additional power does that give me over a function of type a -> s -> a ?
11:15:26 <jmcarthur> acube: all those are actually type variables rather than some of them being concrete?
11:15:33 <ski> augur :- o.
11:15:35 <ski> @tell hrookie `auto-paren-close' ?
11:15:35 <lambdabot> Consider it noted.
11:15:48 <augur> ski: hey hi sup
11:16:01 * ski would ask where the (apparently) free tyvars are quantified
11:16:16 <acube> jmcarthur: Yes, like in gfoldl (that's the function I'm asking about, a bit simpler, or did I simple too much?)
11:16:17 <ski> augur : lo inf
11:16:25 <augur> ski: lol
11:16:56 <ski> @type Data.Data.gfoldl
11:16:57 <lambdabot> Data.Data.Data a => (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
11:16:58 <jmcarthur> :t (\f -> f) :: (forall g. g -> c g) -> s  -> c s
11:16:59 <lambdabot> (forall g. g -> c g) -> s -> c s
11:17:14 <augur> ski: why the ping and the broken face!
11:17:22 <jmcarthur> ^^ i don't think there's much more i can do than that with such a polymorphic type
11:17:31 <ski> <augur> ski: :O
11:17:34 <jmcarthur> gfoldl at least has Data
11:17:35 <Fuuzetsu> augur: Maybe he's just writing Prolog
11:17:45 <augur> ski: oh i dont remember what i said
11:17:59 <ski> i saw no relevant nearby context
11:18:21 <acube> It seems to me that all I can do with that gfold, I can also do with a fold of type (Data a) => (forall d. Data d => c -> d -> c) -> c -> a -> c ?
11:18:53 <ski> acube : note that `c' is also used in the other argument -- otherwise it would probably be pretty useless, yes
11:18:56 <augur> ski: it was probably real world context :(
11:19:18 <augur> ski: but anyway, im 30+ pages into these lecture notes and im not done yet with the intuitionistic logic stuff
11:20:11 <acube> ski: in what other argument?
11:20:42 <ski> the one with type `forall d b. Data.Data.Data d => c (d -> b) -> d -> c b'
11:20:57 <acube> but even there it seems pretty useless
11:21:08 <elliott> acube: perhaps see http://ro-che.info/articles/2013-03-29-gtraverse-vs-gfoldl.html
11:21:53 <elliott> acube: or maybe more usefully http://ro-che.info/articles/2013-03-11-generalizing-gfoldl.html but the article I linked offers an important correction
11:24:16 <nejucomo> Is there any shorthand in a cabal configuration for a library to expose all modules found in the source tree?
11:25:23 <monochrom> no
11:25:30 <monochrom> but I have to check again
11:25:48 <ski> augur : which notes ?
11:26:09 <augur> ski: lecture notes for this class im teaching in the fall
11:26:16 <monochrom> I believe no
11:26:16 <augur> im basically writing a book
11:26:17 <Philippa_> anybody here keep a database of their paper collection, and if so does anyone have cross-platform (minimum windows+linux) software to recommend?
11:26:36 <augur> because theres no good intro book
11:26:44 <twopoint718> Is there a way to force cabal to re-install binaries? I had the bindir property set wrong.
11:26:47 <roconnor> Philippa_: does a filesystem directory count as a database?
11:26:56 <monochrom> I just keep a really long 00-index.bib file, Philippa_
11:26:58 <Philippa_> would be helpful if it can at least hoover up a bunch of filenames sensibly and let me add tags, author&title etc later
11:27:16 <Philippa_> roconnor: that's what I'm putting up with at the moment :p
11:27:40 <ski> augur : ok, you're writing the notes, not (only) reading them
11:27:41 <nejucomo> monochrom: Were you responding to me?
11:27:41 <Philippa_> (but the obvious ways to fake things like tagging won't play well cross-platform)
11:27:47 <monochrom> yes
11:27:49 <augur> ski: indeed
11:28:20 <dcoutts_> nejucomo: the reason they're all needed up front is so that it's possible to do various operations without needing to build half the code to discover which modules exist
11:28:28 <nejucomo> Hrm.  I have a bash script that spits out exposed-modules; updating it all the time is a pain.
11:28:46 <roconnor> Philippa_: Ya. .. I used OS/2 extended attirubutes, but it isn't exactly cross platform. :P
11:28:59 <dcoutts_> nejucomo: e.g. cabal sdist  would otherwise need to discover the dependencies which in general requires configuring, running pre-processors etc
11:29:21 <elliott> Philippa_: if you find something good, let me know, I've been wanting that for years
11:29:29 <nejucomo> "to discover which modules exist" ?  I suppose my case is quite simple, I just say: find ./src -type f -name '*.hs' | sed …   -you get the picture...
11:29:42 <philipdexter> Philippa_: mendeley is popular with some colleagues
11:29:44 <elliott> Philippa_: I've heard calibre used for the purpose I think, though that security hole put me off trying it
11:29:57 <elliott> mdeneley too yes
11:29:58 <dcoutts_> nejucomo: in general it's not that simple
11:30:16 <nejucomo> I expect it's the usual situation where I have a simple use case, don't understand the breadth of use cases, and therefore don't see why automation doesn't / can't exist.
11:31:55 <nejucomo> dcoutts_: In general projects need a Setup.hs, but there is special case support for simple packages which follow standard conventions.
11:32:20 <nejucomo> So, there's a policy choice somewhere about which conventions to streamline.
11:32:38 <dcoutts_> nejucomo: right, I didn't say it's impossible to dynamically discover the dependencies
11:32:39 <monochrom> um, OS/2 extended attributes :)
11:32:42 <nejucomo> Anywho, it sounds like there's no support for my special case, so I'll just deal with it.
11:38:29 <mmaruseacph2> fullvlad was cheating for an exam ;)
11:39:35 <mos_basik> @undo do n1 <- [1..6] ; n2 <- [1..6] ; [] ; return 10 ; return (n1, n2)
11:39:36 <lambdabot> [1 .. 6] >>= \ n1 -> [1 .. 6] >>= \ n2 -> [] >> return 10 >> return (n1, n2)
11:40:46 <Cale> mos_basik: The fact that there are no elements to choose from [] will mean that this is an empty list of results.
11:40:51 <Cale> > do n1 <- [1..6] ; n2 <- [1..6] ; [] ; return 10 ; return (n1, n2)
11:40:52 <lambdabot>   []
11:40:59 <Cale> > do n1 <- [1..6] ; n2 <- [1..6] ; return 10 ; return (n1, n2)
11:41:00 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(3...
11:41:19 <mos_basik> o/
11:41:38 <Cale> and return 10 = [10], from which there's only one thing to pick, and we're ignoring it, so it doesn't affect the results
11:42:03 <Cale> (More generally, (return v) in the middle of a do-block like that does nothing)
11:42:11 <mos_basik> why is the first return ignored?
11:42:13 <Cale> > do n1 <- [1..6] ; n2 <- [1..6] ; return (n1, n2)
11:42:15 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(3...
11:42:27 <geekosaur> return is not a command
11:42:35 <Cale> Well, return 10 is the action which does nothing except to produce the result 10.
11:42:45 <Cale> Which in the case of the list monad, is the list [10]
11:42:52 <Cale> So it's as if we wrote:
11:42:55 <jmcarthur> it could be considered a misleading name
11:43:03 <Cale> > do n1 <- [1..6] ; n2 <- [1..6] ; v <- [10] ; return (n1, n2)
11:43:04 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(3...
11:43:08 <mos_basik> but because of the >>, not the >>=, it's not added to the list of selections
11:43:25 <Cale> > do n1 <- [1..6] ; n2 <- [1..6] ; v <- [10] ; return (n1, n2, v)
11:43:26 <lambdabot>   [(1,1,10),(1,2,10),(1,3,10),(1,4,10),(1,5,10),(1,6,10),(2,1,10),(2,2,10),(2...
11:43:36 <Cale> > do n1 <- [1..6] ; n2 <- [1..6] ; v <- return 10 ; return (n1, n2, v)
11:43:38 <lambdabot>   [(1,1,10),(1,2,10),(1,3,10),(1,4,10),(1,5,10),(1,6,10),(2,1,10),(2,2,10),(2...
11:43:54 <jmcarthur> return is required to not really *do* anything, just inject values
11:44:14 <Cale> One of the monad laws is that  do x <- return v; f x  is the same thing as  f v
11:44:48 <Cale> return doesn't have any of the funky control behaviour that the return in imperative languages has
11:44:58 <simon> I realised that you can perform tail-recursive traversals of trees using continuations and thunks. I wonder: are there any advantages, and how do compilers handle memory use differently across stack/heap?
11:45:03 <Cale> It's just that return v is an action which does nothing except to, well, return v.
11:45:35 <augur> ski: when im done with this chapter, would you be willing to give me feedback? :x
11:46:02 <jmcarthur> simon: if the thing you're building during the traversable is a strict data structure then i could see the use, but this is unusual in haskell
11:46:18 <simon> jmcarthur, actually my examples are from F#/ML.
11:46:38 <jmcarthur> simon: tail recursion is much more important in a strict language
11:47:02 <jmcarthur> simon: in haskell we do occasionally write strict functions, but in a strict language, *every* function is strict
11:47:14 <simon> jmcarthur, shouldn't the memory usage theoretically be the same when traversing trees, whether I have stack frames on the stack or thunks on the heap?
11:47:15 <Cale> It's still kind of an important concept when writing Haskell code, but the fact that most Haskell evaluators don't have a call stack means that TCO is a bit of a moot point.
11:47:20 <jmcarthur> (unless, as in ocaml, explicit laziness is supported, but it's unusual to use that in ocaml anyway)
11:47:38 <paullik> Hi there, I just read about System.Random, but I cannot do ":m +System.Random" in GHCi nor "import System.Random", what's the matter? The Glorious Glasgow Haskell Compilation System, version 7.6.3
11:47:40 <jmcarthur> Cale: the haskell call stack is thunk entry, and TCO still has meaning there
11:47:58 <Cale> jmcarthur: I prefer to think of it as a stack of case expressions :)
11:48:02 <jmcarthur> simon: the difference is that most call stacks have bounded depth
11:48:17 <ski> augur : about when do you think you'll be done with it ?
11:48:39 <jmcarthur> simon: so there is a practical limitation on how large it can get. heaps are much less restricted
11:48:42 <acube> Is there an alterntaive for the hackage package boxes? The last version of boxes seems to be pretty old (It is a "2D" pretty printer that allows aligning documents horizontally and vertically)
11:48:59 <augur> ski: tonight?
11:49:26 <jmcarthur> acube: there are quite a few pretty printing libs. i would also love to know what the most generally recommended ones are
11:49:29 <simon> jmcarthur, so when an F# program throws a memory exception in case of the continuation-based traversal, but for a slightly larger data input, should I assume that the heap-based thunks are more efficient than stack frames, or that there's a slightly larger, static heap limit?
11:50:03 <Fuuzetsu> paullik: IIRC Random no longer comes in by default
11:50:04 <jmcarthur> simon: heaps are not usually statically limited (up to the amount of memory your VM, OS, or machine allows your program to use)
11:50:10 <Fuuzetsu> You might have to install it
11:50:16 <jmcarthur> simon: what i mean is it's usually quite large
11:50:22 <ski> simon : rewriting to tail-recursion (e.g. using CPS), but still not running bounded in space isn't much of a gain
11:50:26 <simon> jmcarthur, right. that was my impression.
11:50:47 <jmcarthur> simon: in most languages, the stack is limited to something like 1MB
11:50:51 <simon> ski, in practice there was a small gain that I was trying to explain, but that I felt were compiler-specific.
11:50:53 <paullik> Fuuzetsu, so I have to use cabal to install the package?
11:51:03 <Fuuzetsu> That should work.
11:52:14 <paullik> ok
11:53:06 <jmcarthur> simon: see jane street's map function for an example of the hoops one might jump through to get good performance and stack behavior in a strict language https://github.com/janestreet/core/blob/master/lib/core_list.ml#L411
11:53:16 <jmcarthur> simon: the unrolling is orthogonal to this, but the rest is interesting
11:53:35 <jmcarthur> simon: it uses the stack up to some depth, then switches to a tail recursive implementation to avoid filling it up
11:53:44 <acube> jmcarthur: But most pp libs are line oriented no? They put 2 multiple lines next to each other horizontally?
11:53:56 <jmcarthur> simon: the non tail recursive version would be faster, just risks overflowing the stack
11:54:07 <jmcarthur> acube: i don't know much about pretty printing
11:55:24 <jmcarthur> simon: oh i guess the unrolling has an effect on this too, since the counter is of the number of stack frames, not the sum of the sizes of the frames
11:55:58 <ski> jmcarthur : yeah, finally reversing an accumulator is pretty common
11:56:13 <jmcarthur> right
11:56:39 <jmcarthur> it's the exact same thing that a tail recursive implementation would do implicitly from the stack
11:56:46 <jmcarthur> just manually implemented and on the heap
11:57:25 <jmcarthur> sorry, what a non tail recursive implementation would do
11:57:37 <jmcarthur> in a strict language, that is
11:58:17 * hackagebot lgtk 0.5 - lens-based API for Gtk  http://hackage.haskell.org/package/lgtk-0.5 (PeterDivianszky)
11:58:26 <paullik> Fuuzetsu, that did it, thanks
11:58:32 <ski> TCMC/LCMC is interesting
12:00:26 <Fuuzetsu> np
12:01:59 <acube> > render
12:02:00 <lambdabot>   *Exception: show: No overloading for function
12:02:16 <acube> > render $ (text "Hello" $$ text "World") <+> (text "Test" $$ text "ing")
12:02:17 <lambdabot>   Ambiguous occurrence `<+>'
12:02:18 <lambdabot>  It could refer to either `Control.Arrow.<+>',
12:02:18 <lambdabot>  ...
12:02:48 <acube> > render $ (text "Hello" $$ text "World") Text.PrettyPrint.HughesPJ.<+> (text "Test" $$ text "ing")
12:02:49 <lambdabot>   "Hello\nWorld Test\n      ing"
12:03:10 * acube wants that to lay out as Hello Test\nWorld ing
12:06:29 <monochrom> I don't think Text.PrettyPrint.HughesPJ does that
12:07:28 <simon> thanks for input, jmcarthur, ski, Cale!
12:07:39 <monochrom> these pretty printers are more for "indenting multi-line math" than "web page layout"
12:08:03 <monochrom> simon: have you seen my http://www.vex.net/~trebla/haskell/lazy.xhtml ?
12:08:24 <monochrom> and while I'm at it, my new http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
12:10:10 <acube> @hoogle (Data a) => a -> String
12:10:10 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
12:10:10 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
12:10:11 <lambdabot> Prelude show :: Show a => a -> String
12:10:13 <simon> monochrom, I haven't, but why do you ask?
12:10:40 <acube> @hoogle gshow
12:10:41 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
12:10:41 <lambdabot> Data.Generics.Text gshows :: Data a => a -> ShowS
12:11:47 <monochrom> simon, because I want you to read it :)
12:13:30 <twopoint718> Is there a known issue with Cabal where it doesn't create executables?
12:13:36 <beaky> hello
12:13:40 <johnw> hi beaky
12:13:56 <beaky> how do I exit from a program in haskell
12:14:06 <johnw> see System.Exit
12:14:21 <beaky> ah thanks
12:14:43 <CindyLinz> access `undefine' (flee)
12:14:56 <monochrom> more tidy way: do not call functions anymore. then the program will exit naturally.
12:17:06 <beaky> ah
12:17:28 <beaky> I want to terminate a program when EOF is reached
12:17:35 <beaky> an interactive program
12:22:57 <monochrom> do you already know how to detect EOF?
12:24:59 <johnw> all issues are black and white to monochrom
12:25:02 <monochrom> I think this question is interesting in bringing out imperative thinking and functional (more like denotative) thinking
12:25:30 <monochrom> goal: there is nothing more to do
12:25:58 <monochrom> imperative programmer asks: how to jump out of the program? what control flow?
12:26:11 <monochrom> functional programmer asks: how to do nothing more?
12:26:59 <monochrom> (answer: to do something more, call the function that does that something. therefore, to do nothing more, call no function)
12:29:40 <monochrom> black and white are simpler
12:30:02 <monochrom> and each grey is a vector of blacks and whites anyway
12:32:11 <beaky> ah
12:34:42 <monochrom> anyway, the goal is X, and the denotative programmer says, so let's stick to X, how to do X? that's a large part of being denotative.
12:35:27 <monochrom> the imperative programmer always turns X into control flow Y or some other low level Y and asks how to do Y. it is a major cause of XY problems.
12:36:15 <b1twize> >>34113599
12:36:36 <monochrom> is that a transaction number?
12:37:09 <latro`a_> it gives you less
12:37:15 <latro`a_> er...disregard that
12:37:56 <jmcarthur> monochrom: "You must manually type cabal install --haddock-hyperlink-source every time, every bloody time." <-- it would be awesome if cabal could be configured in a similar way to darcs, where you can just specify certain flags for everything even if there isn't a special config option for it
12:37:57 <beaky> ha
12:38:13 <Philippa_> monochrom: the *really* imperative programmer just says "oh, right, you can do all the same fun stuff with jumps I'm used to already"
12:38:37 <hpc> jmcarthur: like some kind of .cabal/config file
12:38:47 <jmcarthur> hpc: does that allow arbitrary flags?
12:38:56 <Philippa_> (but termination-as-IO-effect isn't something you should do without thinking, certainly!)
12:40:23 <monochrom> I have a cunning plan
12:40:25 <beaky> how do I check for eof in haskell
12:40:40 <hpc> beaky: did you try searching?
12:40:43 <monochrom> we should write a wrapper over cabal-install for this
12:41:05 <beaky> I found this monadic value: isEOF
12:41:17 * jmcarthur facepalms in response to monochrom
12:41:18 <beaky> but I don't know how to use it
12:41:23 <monochrom> we can call it "cabal-cabal". example: "cabal-cabal install yesod"
12:41:24 <hpc> :t isEOF
12:41:25 <lambdabot> Not in scope: `isEOF'
12:41:30 <hpc> @hoogle isEOF
12:41:30 <lambdabot> System.IO isEOF :: IO Bool
12:41:31 <lambdabot> GHC.IO.Handle.FD isEOF :: IO Bool
12:41:31 <lambdabot> System.IO.Error isEOFError :: IOError -> Bool
12:41:43 <hpc> beaky: you don't know how to use IO? :P
12:41:54 <jmcarthur> monochrom: wrap ghc too and you can just call it "haskell"
12:41:56 <monochrom> the package name can be "cabal-cabal-install" or "cabal-install-cabal". or even "worker-wrapper".
12:41:56 <jmcarthur> :P
12:42:02 <beaky> I did this: eof <- isEOF; if eof then exitSuccess else doSomethingElse
12:42:12 <beaky> but it didn't work  :(
12:42:27 <hpc> @hoogle exitSuccess
12:42:27 <lambdabot> System.Exit ExitSuccess :: ExitCode
12:42:27 <lambdabot> System.Exit exitSuccess :: IO a
12:42:44 <hpc> beaky: what was the error?
12:42:56 <monochrom> beaky: the best way is to tell us which command you use for reading input, and then I can tell you how it conveys EOF
12:43:15 <jmcarthur> monochrom: how about a wrapper transformer so you can use it with your favorite existing wrappers?
12:43:22 <beaky> no error, my program just continues :(
12:43:23 <monochrom> isEOF doesn't always work
12:43:24 <jmcarthur> and build a wrapper stack
12:43:45 <monochrom> that may be called a "shell script"...
12:43:55 <jmcarthur> that's what a wrapper is anyway
12:44:01 <elliott> isEOF is bad. catch the exception from getChar or similar instead
12:44:33 <monochrom> yes, what elliott says, which is why I ask which input command you use, so I can show you concrete code
12:45:51 <monochrom> except for hGetBuf etc where you just need to look at the Int answer
12:46:13 <beaky> I am using getChar :D
12:51:14 <monochrom> beaky: http://hpaste.org/88714
12:51:58 <beaky> wow that works
12:52:13 <beaky> thats elegant :D
12:52:48 <beaky> IO in haskell is so elegant
12:53:00 <latro`a_> :t Control.Exception.tryJust
12:53:01 <lambdabot> GHC.Exception.Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)
12:53:25 <monochrom> in general you can have a more useful b than ()
12:53:47 <bubaya> In C I can write multiple case statements resulting in the same result like in switch(a){case 1: case 2: doSomething;...}. Is something like this possible in Haskell?
12:54:01 <monochrom> unfortunately no
12:54:20 <hpc> bubaya: you could do something similar with guards, likely
12:54:27 <jmcarthur> yeah i wish we could do that
12:54:50 <bubaya> hpc: With guards I have lots of =='s there.
12:54:55 <Iceland_jack> > case 0 of n | n `elem` [0,1] -> "zero or one"
12:54:56 <hpc> case expr of {x | x `between` (1, 10) -> "yes"; 15 -> "twelve"; _ -> "no"}
12:54:56 <jmcarthur> in ocaml you can do that. you can even bind the same name in multiple such patterns and use them on the shared rhs
12:54:56 <lambdabot>   "zero or one"
12:55:17 <hpc> bubaya: define a reasonable between and you are good
12:55:53 <bubaya> Okay... I think that helps me. Thank you!
12:55:57 <monochrom> x>=1 && x<=10
12:56:26 <jmcarthur> i also like how in ocaml you can do something akin to this    foo :: Tagged Foo Int -> Tagged Bar Int; foo x@(Tagged _) = x
12:56:51 <jmcarthur> whereas in haskell you actually have to say  foo :: Tagged Foo Int -> Tagged Bar Int; foo (Tagged x) = Tagged x
12:57:53 <beaky> I thought you can do that in haskell too
12:57:54 <hpc> jmcarthur: i would be curious to know what constraints are being unified in that ocaml example
12:58:26 <jmcarthur> hpc: it means the same thing as the real haskell version
12:58:33 <geekosaur> beaky, not like that, no; x has the type Tagged Foo Int, so can't be used directly as a Tagged Bar Int
12:58:37 <jmcarthur> hpc: it's also a hint to the compiler to reuse the in-memory representation
12:58:40 <hpc> jmcarthur: i mean in the typechecker
12:58:42 <jmcarthur> hpc: but i think ghc does it anyway
12:58:56 <jmcarthur> hpc: it doesn't imply anything that the haskell version doesn't
12:59:26 <monochrom> I am trying "foo x = x{}". it errors with "empty record update"
12:59:44 <monochrom> however, if it were allowed, I'm sure it would allow the type change too
13:00:02 <monochrom> afterall, x{n=1} does
13:00:25 <Cale> That really ought to be allowed
13:00:56 <jmcarthur> hpc: in particular, it is not unifying Foo with Bar as it may seem to be doing
13:01:39 <hpc> jmcarthur: the use of x on both sides makes it look like it does
13:01:52 <hpc> i would have thought that was a core part of typechecking
13:01:55 <jmcarthur> yeah, it's maybe a bit misleading
13:02:15 <monochrom> data Tagged u a = Tagged{useful::a, useless::()} deriving Show
13:02:20 <jmcarthur> there are some rules on it, but i've never bumped into them so never had to learn them
13:02:24 <Cale> It suggests that there's some equivalence which is being automatically applied
13:02:25 <monochrom> foo :: Tagged u Int -> Tagged v Int
13:02:27 <jmcarthur> but i imagine with mutable types it would be a problem
13:02:32 <monochrom> foo x = x{useless=()}
13:02:58 <jmcarthur> oh maybe not actually
13:03:01 <Cale> (perhaps just the equivalence of being represented by the same constructor application)
13:03:03 <jmcarthur> that's a phantom anyway
13:03:45 <elliott> monochrom: hah, does that work?
13:03:45 <monochrom> "linear worlds can change the type!"
13:03:50 <hpc> jmcarthur: doesn't appear to work with 7.4.1 ghci
13:03:55 <monochrom> yes elliott I only paste working code!
13:04:05 <jmcarthur> hpc: no i wouldn't expect it to
13:04:22 <monochrom> it is also Haskell 98!
13:04:22 <elliott> monochrom: I should write a bot to try all the code you paste and kick you if it doesn't compile to hold you to that
13:04:42 <irene-knapp> lol
13:04:43 <monochrom> please don't kick. just warn me. I sometimes err.
13:04:56 <irene-knapp> to err is human.  (to really screw up requires a computer.)
13:04:58 <jmcarthur> hpc: but this works in ocaml: type 'a t = Foo of int;; let f : string t -> bool t * float t = function Foo _ as t -> t, t;;
13:05:19 <jmcarthur> hpc: (should be possible to try that in the ocaml toplevel if you have it installed)
13:05:24 <Cale> elliott: The first thing he pastes is then a program which kills your bot's process.
13:05:30 <monochrom> to err is human. to get kickbanned requires an IRC server.
13:05:32 <hpc> i will pretend i know enough ocaml to read a one-liner :P
13:05:37 <irene-knapp> to err is human, to mew, feline.
13:06:09 <elliott> monochrom: ah, but the potential punishment will encourage you to triple-check your code before pasting.
13:06:16 <elliott> it will make you infallible
13:06:19 <hpc> to stderr is human, to log is divine
13:06:32 <irene-knapp> hah
13:06:33 <irene-knapp> yes
13:06:52 <monochrom> or encourage me to paste code using a pseudonym
13:07:01 <monochrom> and I already have one
13:07:14 <hpc> monochrom: your pseudonym should be "technicolor"
13:07:21 <monochrom> haha
13:08:08 <monochrom> (and don't worry, won't encourage me to stay quiet. I have my egomaniac constraints.)
13:10:40 <monochrom> (I always tell people that I'm egomaniac. it kills the conversation.)
13:15:15 <quchen>  /nick FullGarmut
13:15:55 <epta> Is there some comonad.com mirror?
13:16:23 <shortCircuit> Pardon. I'm not sure how to phrase this, but I'm looking for a construct similar to arrows but with the ability to interact with it more than once. That is, if I attempt to write to it twice within a single do proc, both resultant outputs will be different, and the state will be different than if it were written to once.
13:16:28 <ciaranm> there's a monad.com glass
13:16:49 <shortCircuit> As a simple example, imagine a MUX circuit.
13:17:06 <ciaranm> shortCircuit: uh, monad?
13:17:16 <shortCircuit> But, maintaining state?
13:17:26 <ciaranm> monad!
13:17:41 <shortCircuit> So... maintain the arrow's state within the monad, rather than in the arrow?
13:17:51 <shortCircuit> Which I guess would make it a non-arrow?
13:18:06 <quchen> I think he meant "why not the State monad"
13:18:17 <ciaranm> for some value of State, yes
13:18:25 <quchen> I think he meant "why not the State s monad"
13:18:27 <shortCircuit> Because I'm not away of the state monad :) I'll go RTFM and be back.
13:18:36 <shortCircuit> s/away/aware
13:18:47 <shortCircuit> (PS, thanks)
13:19:49 <quchen> You know about arrows but not the standard monads? How did that happen
13:20:22 <shortCircuit> I'm a generalist.
13:20:26 <quchen> Or did you mean "->" with arrow
13:20:34 <ciaranm> arrows don't generalise monads!
13:20:43 <shortCircuit> <- .. -<
13:20:48 <shortCircuit> They don't?
13:21:24 <jmcarthur> ciaranm: yes they do
13:21:31 <shortCircuit> So, from what I'm seeing, this makes sense. The only possible way to do what I want is to track the state independent of the "access" of the objects anyway.
13:21:41 <jmcarthur> ciaranm: you can make an arrow from any monad
13:21:45 <shortCircuit> So State Monad is what I want. Why do people use arrows?
13:21:55 <shortCircuit> But can you make any arrow from a monad?
13:21:56 <quchen> First of all, Arrows have a different kind than Monads.
13:22:03 <jmcarthur> shortCircuit: because sometimes something is an Arrow but not a Monad
13:22:15 <ciaranm> jmcarthur: you can make a functor from any monad. that doesn't imply functors generalise monads.
13:22:34 <jmcarthur> ciaranm: but the arrows you make out of monads have the same semantics as the monad
13:23:00 <jmcarthur> ciaranm: to make a monad from a functor you have to add more structure
13:23:26 <jmcarthur> ciaranm: you can turn a monad into an arrow and also get the original monad back out of it
13:23:35 <jmcarthur> without losing anything
13:23:40 <jmcarthur> or adding anything
13:23:44 <quchen> Functors aren't generalized Monads? I don't think so.
13:23:46 <shortCircuit> Is every Monad an arrow? Yes? Is every arrow a Monad? No? That'll settle your question.
13:24:02 <hpc> no monads are arrows
13:24:04 <shortCircuit> I just don't know what the Bool values are on those queries :)
13:24:13 <hpc> you can make a kleisli arrow from any monad
13:24:23 <ciaranm> shortCircuit: every monad is a functor, but functors are not monads
13:24:48 <shortCircuit> Can make is not the same as is..  I can probably make a Ring from any Group...
13:24:55 <ciaranm> some functors can be turned into monads. sometimes in more than one way.
13:25:27 <ciaranm> you can make a ring from any group in several ways. none of them particularly useful.
13:25:37 <jmcarthur> is the monad you can get out of ArrowApply not isomorphic to the monad you injected into Kleisli in the first place?
13:26:46 <shortCircuit> It's likely those words are meant as in, every Ring is a Group, not every Group can be made into a Ring.
13:27:06 <jmcarthur> if it is, as i believe it is, then you aren't really adding any structure to the monad in order to make the arrow out of it
13:27:29 <ciaranm> every group can be made into a ring in several different, natural ways. they're just not very useful.
13:27:39 <jmcarthur> so ArrowApply ~ Monad, and Arrow generalizes ArrowApply, so Arrow generalizes Monad
13:28:07 <quchen> ... kind mismatch ...
13:28:13 <shortCircuit> So all instances of that particular type of arrow are also Monads?
13:28:18 <jmcarthur> quchen: generalizes in power
13:28:22 <shortCircuit> Which would imply that arrows generalize monads.
13:28:25 <jmcarthur> shortCircuit: yes
13:28:45 <shortCircuit> Is it also true that monads do not generalize arrows?
13:28:49 <jmcarthur> shortCircuit: at least if you wrap it with a newtype wrapper of different kind as quchen points out
13:29:01 <jmcarthur> not all arrows are monads
13:29:07 <jmcarthur> only ArrowApplys
13:29:14 <shortCircuit> jmcarthur: Not so worried about the Haskell trivialities as the fundamentals :)
13:29:29 <jmcarthur> shortCircuit: well, kinds are fundamental, too
13:29:35 <ciaranm> fundamentally, all the cool kids are using lenses these days, and arrows are dead
13:29:39 <jmcarthur> quchen is right to point out the difference
13:29:43 <shortCircuit> jmcarthur: *groan*
13:29:49 <jmcarthur> it just doesn't change my claim
13:30:16 <jmcarthur> shortCircuit: it sounds like you are jumping into stuff that is less practical than the basics here
13:30:30 <shortCircuit> If a lens is used in a Monad, it could also manipulate the state. This sounds like what I'm looking for.
13:30:38 <jmcarthur> shortCircuit: monads should almost certainly come before arrows in most peoples' journies
13:30:55 <shortCircuit> jmcarthur: I'm doing circuit simulation. Arrows seemed natural...
13:31:07 <jmcarthur> ah i agree
13:31:11 <ciaranm> shortCircuit: have you looked at hydra?
13:31:17 <jmcarthur> monadic circuits aren't really possible, in fact
13:31:27 <jmcarthur> unless the circuits can rewire themselves dynamically
13:31:29 <shortCircuit> jmcarthur: But in an attempt to generalize the syntax the limitation of arrows reared it's head.
13:31:39 <jmcarthur> it has nothing to do with syntax
13:31:50 <shortCircuit> The goal is not to re-wite the circuits dynamically, but the lay them out and simulate them dynamically.
13:32:00 <jmcarthur> that sounds arrowy to me, indeed
13:32:15 <jmcarthur> i think your notion of "state" is throwing you off
13:32:22 <shortCircuit> But, as a matter of fact, yes, circuits can re-write themselves dynamically, see the latest gen of Xilinx and Altera high-performance FPGAs :)
13:32:28 <jmcarthur> ah fine
13:32:34 <jmcarthur> then it's a monad :OP
13:32:36 <jmcarthur> :P
13:33:09 <shortCircuit> The idea is to have seperate read/write objects to more easily distribute inputs and outputs to the circuits.
13:33:22 <ciaranm> shortCircuit: http://www.dcs.gla.ac.uk/publications/PAPERS/7524/OD2004-LNCS-EmbedHDLinTH.pdf
13:33:24 <shortCircuit> This was not possible with arrows, but it's clear how this can be done with the State Monad.
13:35:55 <shortCircuit> ciaranm: Thanks. This is interesting, but doesn't do everything I need, that is, it seems arrows would be sufficent for Hydra and they were not sufficent for this work.
13:36:16 <shortCircuit> At least in expressivness, there may be deeper parts to Hydra.
13:38:29 <ciaranm> monads are sufficiently expressive
13:40:04 <shortCircuit> ciaranm: Yes.
13:43:16 <Philippa_> FWIW: the Monad signature may be nominally expressive enough, but you'll need room to do a lot without it (or the bits that are or are equivalent to something involving join)
13:43:56 <Philippa_> when we code in monadic style, we're assuming that executing higher-order functions/computations is cheap enough we don't have cause to avoid it
13:44:01 <Philippa_> that... doesn't always hold
13:44:06 <ciaranm> are we talking monads or do notation?
13:45:34 <Philippa_> ciaranm: you don't have ap in the Monad signature
13:45:40 <Philippa_> so yeah, we're talking monads
13:46:25 <Philippa_> the surface syntax doesn't sweeten or sour it any
13:46:49 <Philippa_> (this is one reason why Control.Applicative et al matter!)
14:03:04 <scb> Hello. I'm having trouble building an instance for a custom class I have devised. The code and error is here: https://gist.github.com/scast/da1c041bdfced0e4f96f --- the error is because of the throwError, I think. But I thought Since there's an instance of Error e => MonadError it could be deduced. Any hints on how to fix this?
14:05:03 <supki> scb: evaluator _ _ = throwError ... ?
14:06:04 <scb> supki: nope, same error, could not deduce MonadError
14:08:10 <scb> Well that was quite interesting, I changed the error to (noMsg) and it compiled. Is there anyway I could use maybe a String or another Error typeclass instance?
14:12:57 <irene-knapp> oh good
14:13:14 <irene-knapp> I figured out how to fix darcs to compile against 7.6.1 so that I can get a working darcs-fastexport and never use it again ><
14:13:21 <irene-knapp> the last patch in the repo was three months ago!!!
14:13:32 <irene-knapp> it's saddening :(
14:14:42 <johnw> scb: you only have a Monad constraint, how can it deduce MonadError?
14:16:36 <scb> johnw: I thought since there is a Error e => MonadError e (Either e) instance it could. Is there anyway I could only extend the constraints for a instance and not for the whole type class?
14:17:55 <johnw> hmm
14:19:09 <c_wraith> uh.  Isn't the argument to throwError supposed to match the type of the Error?
14:19:54 <hpc> :t throwError
14:19:55 <lambdabot> MonadError e m => e -> m a
14:19:59 <c_wraith> yes it is!
14:20:07 <ski> scb> :t DivisionPorCero
14:20:13 <c_wraith> also, it has a MonadError constraint that your instance doesn't supply
14:20:46 <scb> ski: thats a custom constructor of mine.
14:20:50 <c_wraith> That error message makes it look like DivisionPorCero is a constructor that takes one argument
14:21:09 <c_wraith> scb: but its type *matters*, since you're passing it to throwError
14:21:27 <ski> scb : and the type of it is ?
14:21:53 <scb> c_wraith: hold on. https://gist.github.com/scast/d55b0eb786dccd0bcf31
14:22:11 <scb> ski: https://gist.github.com/scast/d55b0eb786dccd0bcf31
14:22:39 <ski> ok, so `ExpError' is the type of it
14:23:29 <dmwit> ?tell jonkri I'm only around infrequently. What's up?
14:23:29 <lambdabot> Consider it noted.
14:23:40 <ski> `instance  Error e =>  Evaluable (ErrorT e)' is promising that for any type `e' in class `Error' (and which thus supports `throwError' on that type), `ErrorT e' is in class `Evaluable', by the provided code for `evaluator'
14:24:12 <ski> however, `throwError DivisionPorCero' is insisting that the type `e' must be the type `ExpError'
14:24:18 <ski> this doesn't fit
14:24:21 <ski> scb : ok ?
14:24:26 <scb> I see
14:24:28 <scb> Yes
14:24:58 <ski> perhaps you want something like instance Evaluable (ErrorT DivisionPorCero)', perhaps you want to (somehow) generalize the code to work for any `e' in `Error'
14:25:15 <ski> perhaps you want something else (reworking the interface of `evaluator', or the design ?)
14:25:19 <ski> it's hard to tell
14:25:40 <scb> Could I take away the Error e => and use only an instance for Evaluable (ErrorT ExpError) ?
14:25:54 <dmwit> Perhaps you don't want a class at all, and just want a boring old monomorphic function.
14:25:58 * dmwit hasn't looked at the code
14:26:53 <scb> Well, it doesn't compile when I take away the type variable.
14:27:21 <ski> "take away the type variable" being the `instance Evaluable (ErrorT DivisionPorCero)' option ?
14:27:36 <scb> ski: Yes, Evaluable (ErrorT ExpError)
14:27:46 <ski> did you enable `FlexibleInstances' ?
14:28:14 <scb> Let me check how to do that.
14:28:26 <ski>   {-# LANGUAGE FlexibleInstances #-}
14:28:35 <ski> at the top of the file, is the easiest way
14:28:47 <dmwit> scb: Are you sure you don't want to write just evaluator :: (MonadError ExpError m, MonadReader Environment m) => Exp -> (Exp -> Int -> m ()) -> m Int
14:28:51 <dmwit> with no extra classes at all?
14:28:53 <ski> (one can also pass `-XFlexibleInstances' to GHC)
14:29:59 <scb> ski: that worked.
14:30:01 <ski> scb : er, i meant s/ErrorT DivisionPorCero/ErrorT ExpError/, yes
14:30:10 <scb> dmwit: you know what? let me check, maybe I could and I am here over engineering.
14:31:14 <scb> dmwit & ski, in general, what I am trying to do with FlexibleInstances is frowned upon? I mean, removing the type variable like I did?
14:31:53 <dmwit> FlexibleInstances is a very mild extension.
14:32:54 <ski> i'm not sure why you call it "removing the type variable"
14:33:12 <ski> it appeared to me that you introducing it in the first place was possibly a conceptual mistake
14:34:04 <dmwit> I like this answer.
14:34:25 <dmwit> It's very zen. "Is removing the type variable bad? There was no type variable to begin with."
14:34:43 <irene-knapp> lol
14:34:44 <irene-knapp> yes
14:34:59 <scb> Heh.
14:35:13 <scb> Let me see if I could just get rid of the whole typeclass deal.
14:35:15 <ski> (sortof like people wanting existential quantification, but using universal quantification : writing `foo :: Blah a => ... -> Bar a', excepting `foo' to be able to decide on what type `a' should be, instead of the caller (yes, `Bar' is meant to be covariant))
14:35:28 <ski> (s/excepting/expecting/)
14:37:02 <scb> Haha, alright. Thanks ski & dmwit.
14:37:18 <ski> np
14:37:57 <ski> (hm .. istr someone wanted to ask twanvl something -- but i can't recall who, or about what :/ )
14:38:35 <twanvl> let me check the logs
14:38:35 <lambdabot> twanvl: You have 1 new message. '/msg lambdabot @messages' to read it.
14:48:20 * hackagebot llvm-base 3.2.0.1 - FFI bindings to the LLVM compiler toolkit.  http://hackage.haskell.org/package/llvm-base-3.2.0.1 (CarterSchonwald)
14:49:42 <scb> dmwit: sorry to bother, but I'm playing around with the signature you provided me. It's complaining about Non-type variable argument. I don't see why because it's pretty much the same signature, written a lot better.
14:50:19 <dmwit> It should tell you to enable FlexibleContexts.
14:50:24 <scb> It does
14:50:29 <dmwit> So... do it?
14:50:58 <scb> Heh, sorry. I'm psyched up with enabling extensions. Don't know what most of them do.
14:53:35 <ski>   {-# LANGUAGE FlexibleInstances,FlexibleContexts #-}
14:56:24 <monochrom> the two Flexible extensions let you write for example "Class_name (Maybe Not_type_variable) => ...". normally you are only allowed "Class_name (Maybe type_variable)"
14:57:24 <elliott> aren't you only allowed Class_name type_variable => ...?
14:58:10 <monochrom> no, even Haskell 98 itself needs "Ord (Maybe a)"
14:58:20 * hackagebot llvm 3.2.0.1 - Bindings to the LLVM compiler toolkit.  http://hackage.haskell.org/package/llvm-3.2.0.1 (CarterSchonwald)
14:58:36 <dmwit> That's in an instance declaration. elliott is talking about a type signature
14:58:57 <elliott> right, I said that because monochrom said =>
15:00:06 <carter> ofan hello,  excited about gsoc?
15:00:08 <monochrom> delete "=> ..."
15:14:13 <carter> @tell ofan sometime next week lets chat, i'm your gsoc mentor for the summer
15:14:13 <lambdabot> Consider it noted.
15:14:46 <shachaf> And join #haskell-gsoc!
15:15:15 <carter> shachaf that too
15:16:16 <dmwit> huh
15:16:22 <dmwit> http://www.google-melange.com/gsoc/project/google/gsoc2013/adamgundry/23001
15:16:54 <carter> dmwit its basically a MSR intership as a GSOC project AFAICT :)
15:18:07 <dmwit> Sure, that's cool and all. What surprised me is that there somehow, somebody has made a decision about a record system that can subsume the current one.
15:18:17 <dmwit> It was my understanding that all of the proposals so far sucked in one way or another.
15:18:28 <quchen> What are 'overloaded [record] field names' the GSOC page mentions?
15:18:40 <dmwit> yeah, I dunno
15:18:47 <quchen> "Multiple things can have a 'x' record"?
15:18:49 <geekosaur> I think there's stuff going on that is working toward multiple proposals without committing to any of them?
15:19:47 <carter> dmwit i think this is mostly going to be an exploratory / experimentatin project..
15:20:14 <dmwit> These proposals come with criteria for judging success, right? Is there somewhere we can see these?
15:20:32 <dmwit> The abstracts for several have whet my appetite...
15:32:26 <scb> ski & dmwit, just finished rewriting without a typeclass. it's so much better now, I think. Thanks!
15:41:01 <ski> scb : care to show the current version ?
15:42:59 <scb> ski, it's a homework, sure.
15:43:35 <scb> ski: do you mind if I pm you the url?
15:46:07 <ski> i would prefer it being linked here, so that others could also learn ior provide advice
15:46:29 <scb> fair enough
15:46:36 <scb> I dont think any of my class mates are here anyway, heh.
15:46:44 <scb> https://gist.github.com/scast/23f129301d8f881ae771
15:46:47 <diabel232> wow that a lot people here
15:47:02 <diabel232> i see that haskell becomes very popular
15:47:41 <kqr> i'm not sure i completely understand how i would use do notation for lists... can i filter lists using do notation?
15:47:56 <quentl> could someone help me with a question about using Control.Lens?
15:48:15 <scb> kqr: yes, using guard from Monad Plus, i think.
15:48:36 <hpc> kqr: within the confines of the type of (>>=), yes
15:48:44 <hpc> kqr: you can't filter the "current" list, per se
15:49:05 <kqr> i actually got it to work
15:49:06 <hpc> but you can filter a different list as part of your building the current list
15:49:21 <kqr> do { x <- xs; if p x then return x else [] }
15:49:27 <kqr> but that's perhaps not a nice thing to do
15:49:27 <ski> > do x <- [0 .. 9]; guard (even x); return x
15:49:29 <lambdabot>   [0,2,4,6,8]
15:49:34 <ski> @undo do x <- [0 .. 9]; guard (even x); return x
15:49:34 <lambdabot> [0 .. 9] >>= \ x -> guard (even x) >> return x
15:49:36 <hpc> > do {x <- [1..5]; filter (< x) [1..]}
15:49:48 <hpc> > do {x <- [1..5]; filter (< x) [1..]}
15:49:52 <lambdabot>   thread killed
15:49:52 <ski> @undo [x | x <- [0 .. 9] , even x]
15:49:53 <lambdabot> concatMap (\ x -> if even x then [x] else []) [0 .. 9]
15:50:03 <hpc> oh right
15:50:03 <lambdabot>   thread killed
15:50:07 <hpc> > do {x <- [1..5]; filter (< x) [1..10]}
15:50:08 <lambdabot>   [1,1,2,1,2,3,1,2,3,4]
15:50:14 <dmwit> I like ensure p x = x <$ guard (p x).
15:50:17 <hpc> there's an example
15:50:27 <dmwit> ?let ensure p x = x <$ guard (p x)
15:50:29 <lambdabot>  Defined.
15:50:42 <dmwit> > ensure even [0..10]
15:50:43 <lambdabot>   No instance for (GHC.Real.Integral [t0])
15:50:44 <lambdabot>    arising from a use of `e_1010'
15:50:44 <lambdabot> ...
15:50:56 <dmwit> whoops
15:51:05 <dmwit> > [0..10] >>= ensure even
15:51:10 <lambdabot>   [0,2,4,6,8,10]
15:51:27 <ski> though that's not using `do'-notation :)
15:51:32 <adu> :t ensure
15:51:33 <dmwit> > do {x <- [1..5]; y <- [1..10]; ensure (<x) y}
15:51:33 <lambdabot> (Functor f, MonadPlus f) => (a -> Bool) -> a -> f a
15:51:35 <lambdabot>   [1,1,2,1,2,3,1,2,3,4]
15:51:49 <dmwit> ski: You like this last example better, then? =)
15:51:58 <ski> (:
15:52:06 <augur> ski: your head is on backwards
15:52:16 * ski turns all around
15:52:20 <hpc> augur: no, he's just looking backwards
15:53:51 <kqr> wow so that was a plethora of solution
15:53:56 <kqr> i think guard suffices for my purposes
15:54:05 <hpc> kqr: basically, follow the types
15:54:07 <kqr> although ensure looks neat and i'll try to keep it in the back of my head
15:54:46 <dmwit> every time you return x right after a guard (p x), you wanted ensure =)
15:54:55 <kqr> "follow the types" almost sounds like a lyah-esque star wars reference
15:55:20 <kqr> dmwit, my problem with ensure is that the predicate is fairly complicated
15:55:29 <hpc> kqr: if you want star wars advice, look to how failure states are handled
15:55:34 <hpc> kqr: do or do not, there is no try
15:55:50 <kqr> dmwit, i would like it to be the last thing on the line, but it doesn't mke sense to say "ensure value predicate"
15:55:58 <kqr> wait a minute
15:56:02 <kqr> i'm just not thinking right
15:56:06 <kqr> i think ensure is better yeah
15:56:15 <kqr> or do i...
15:56:37 <kqr> i have no idea what I'm doing anymore
15:56:43 <kqr> yeah no
15:56:46 <kqr> i'm thinking right
15:56:48 <kqr> !
15:57:27 <kqr> i could maybe solve that with some clever indentation though
15:59:56 <kqr> yeah no this'll be good
16:00:57 <dmwit> value `ensure` predicate
16:01:01 <dmwit> err
16:01:19 <dmwit> flip ensure value predicate =P
16:01:32 <dmwit> But yeah, one would want a different name for the flipped version.
16:01:53 <dmwit> ?pl \x y -> foo x y >> return ()
16:01:53 <lambdabot> flip flip (return ()) . ((>>) .) . foo
16:02:04 <dmwit> blech
16:02:10 <kqr> haha
16:02:44 <dmwit> hm
16:02:54 <dmwit> ?pl \x y -> foo x y >> def x y
16:02:54 <lambdabot> ap (ap . ((>>) .) . foo) def
16:03:17 <dmwit> :t liftM2 (liftM2 (>>))
16:03:18 <lambdabot> (Monad m2, Monad m1, Monad m) => m (m1 (m2 a)) -> m (m1 (m2 b)) -> m (m1 (m2 b))
16:03:27 <dmwit> eeeexcellent
16:07:19 <bitonic> daaaaamn.
16:07:27 <bitonic> bitten again by mutual defaults in typeclasses.
16:07:31 <bitonic> 3 hours WASTED
16:08:31 <bitonic> there was something coming in 7.8 about this, right?
16:08:53 <hpc> bitonic: mutual defaults?
16:09:03 <hpc> like Eq's definition?
16:09:09 <bitonic> hpc: in this case Error
16:09:19 <bitonic> but yes
16:09:35 <bitonic> noMsg = strMsg ""; strMsg _ = noMsg;
16:09:38 <bitonic> not even a warning
16:10:31 <shachaf> bitonic: There is my proposal at http://hackage.haskell.org/trac/ghc/ticket/7633
16:10:43 <bitonic> shachaf: yes, that’s what I was thinking of.  thanks.
16:10:52 <bitonic> and thanks for the proposal itself...
16:13:21 * hackagebot restful-snap 0.1.1 -   http://hackage.haskell.org/package/restful-snap-0.1.1 (DougBeardsley)
16:49:03 <haskell_noob> anyone mind taking a look at this and giving me a hand?
16:49:23 <dibblego> haskell_noob: ask away
16:49:26 <haskell_noob> http://hpaste.org/88724
16:49:46 <`H2O`> Brawkk-AWK!
16:50:21 <haskell_noob> just can't figure out how to loop through the Memory and display all of the Identifiers with their corresponding values
16:50:25 <`H2O`> Brawkk-AWK!
16:51:01 --- mode: ChanServ set +o elliott
16:51:09 --- mode: elliott set +q `H2O`!*@*
16:51:14 --- mode: elliott set -o elliott
16:52:25 <dibblego> haskell_noob: display xs = fst xs >>= \x -> show x ++ ": "
16:52:31 <dibblego> that compiles but I don't know if it is what you want
16:52:48 <haskell_noob> uhmm ill have a look at it and give it a go, thnx
16:53:45 <_just> haskell_noob: you cannot use fst on teh left hand side of =
16:54:36 <_just> you probably  want: display (xs, _) =
16:54:48 <haskell_noob> what does the >>= do?
16:55:10 <dibblego> haskell_noob: it maps the function on the list to produce a list of list, then flattens it
16:55:45 <haskell_noob> dibblego: thnx man
16:57:27 <ski> scb : i would replace `myFromJust' with a function that takes an identifier (string), and either also the environment, returning the result value, or (better ?) gives a monadic action that will look up the environment, and yield the result, or raise `VariableNoExiste'
16:57:40 <hpc> haskell_noob: precisely, xs >>= f = concat (map f xs)
16:58:46 <Hermit> haskell_noob: but don't go thinking it's the same operation everywhere. It deppends on the type.
16:59:03 <Hermit> it's the monadic bind
16:59:46 <haskell_noob> ok thanks
17:00:53 <_just> haskell_noob: display (xs, _)= intercalate ":" xs -- import Data.List for intercalate
17:01:11 <_just> or pointfree: display = intercalate ":" . fst
17:01:26 <Aetherspawn> @pl a >>= b >>= c
17:01:26 <lambdabot> a >>= b >>= c
17:01:39 <haskell_noob> _just: hey thanks man, i think that part is working now
17:02:02 <Hafydd> @pl \a b c -> a >>= b >>= c
17:02:03 <lambdabot> ((>>=) .) . (>>=)
17:02:31 <_just> haskell_noob: just wanted to show the usefull intercalate function :D
17:05:22 <haskell_noob> _just: ill have a look at it :P
17:05:22 <Aetherspawn> @src liftA3
17:05:22 <lambdabot> Source not found. You type like i drive.
17:05:39 <Aetherspawn> :t liftA3
17:05:41 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
17:06:01 <Aetherspawn> liftA3 (>>=) a b c == a >>= b >>= c ?
17:10:01 <elliott> :t \a b c -> liftA3 (>>=) a b c == a >>= b >>= c
17:10:02 <lambdabot>     Couldn't match expected type `m0 a0' with actual type `Bool'
17:10:03 <lambdabot>     In the first argument of `(>>=)', namely `liftA3 (>>=) a b c == a'
17:10:03 <lambdabot>     In the first argument of `(>>=)', namely
17:10:08 <elliott> :t \a b c -> liftA3 (>>=) a b c == (a >>= b >>= c)
17:10:10 <lambdabot>     Occurs check: cannot construct the infinite type: d0 = c0 -> d0
17:10:10 <lambdabot>     Expected type: (c0 -> d0) -> (c0 -> d0) -> c0 -> d0
17:10:10 <lambdabot>       Actual type: (c0 -> d0) -> d0 -> c0 -> d0
17:10:24 <elliott> doesn't even type
17:10:36 <Aetherspawn> :t liftA3 (>>=) a b c
17:10:40 <lambdabot>     Couldn't match expected type `f0 (c0 -> a0)'
17:10:40 <lambdabot>                 with actual type `Expr'
17:10:40 <lambdabot>     In the second argument of `liftA3', namely `a'
17:10:49 <elliott> :t \a b c -> liftA3 (>>=) a b c
17:10:50 <lambdabot> Applicative f => f (c -> a) -> f (a -> c -> d) -> f c -> f d
17:11:03 <ski> Aetherspawn : `liftM3 f ma mb mc = do {a <- ma; b <- mb; c <- mc; return (f a b c)}', which is equivalent to
17:11:10 <ski>   liftM3 f ma mb mc = return f `ap` ma `ap` mb `ap` mc
17:11:12 <Aetherspawn> :t \a b c -> a >>= b >>= c
17:11:13 <lambdabot> Monad m => m a1 -> (a1 -> m a) -> (a -> m b) -> m b
17:11:23 <ski> for *`liftA3'*, however, it's
17:11:42 <haskell_noob> mind having another look at this? http://hpaste.org/88724
17:11:47 <ski>   liftA3 f ia ib ic = pure f <*> ia <*> ib <*> ic
17:12:00 <Aetherspawn> Ah, I see.
17:12:40 <ski> (where  return f `ap`  /  pure f <*>  can be abbreviated as  f `liftM`  /  f `fmap`  (or using `<$>' in the latter))
17:13:31 <Aetherspawn> is it better to use stuff like liftXX rather than the long manual syntax
17:13:51 <Aetherspawn> (maybe there are rewrite rules or something?)
17:14:06 <ski> depends on which you prefer to read and write
17:14:15 <Aetherspawn> Ah, okay.
17:20:33 <Aetherspawn> (Maybe someone here knows how to solve this? :] http://stackoverflow.com/questions/16757060/haskell-conduit-one-processing-conduit-2-io-sources-of-the-same-type)
17:48:28 * hackagebot llvm-base 3.2.0.2 - FFI bindings to the LLVM compiler toolkit.  http://hackage.haskell.org/package/llvm-base-3.2.0.2 (CarterSchonwald)
18:03:29 * hackagebot llvm 3.2.0.2 - Bindings to the LLVM compiler toolkit.  http://hackage.haskell.org/package/llvm-3.2.0.2 (CarterSchonwald)
18:16:02 <carter> woot, unbroken versions this time
18:16:04 <carter> phewf
18:53:42 <unlink> Is there a combinator like this one: list :: b -> ([a] -> b) -> [a] -> b
18:54:18 <dibblego> uncons?
18:55:16 <enthropy> you could try (const . const)
18:56:27 <unlink> that's pretty close.
18:56:52 <dmwit> What is that function supposed to do?
18:56:57 <dmwit> It looks like a pretty stupid type.
18:57:01 <dmwit> (no offense)
18:57:10 <dmwit> ?djinn b -> (a -> b) -> a -> b
18:57:10 <lambdabot> f _ a b = a b
18:57:27 <zxs> hey guys. I'm using a tree type like data Tree a b = Leaf b | Branch a (Tree a b) (Tree a b)
18:57:28 <copumpkin> list :: b -> (a -> [a] -> b) -> [a] -> b
18:57:33 <dmwit> f c _ _ = c is the other obvious solution (which enthropy suggested).
18:57:45 <dmwit> copumpkin's type makes a bit more sense at least.
18:57:50 <unlink> \x f -> maybe x (f . uncurry cons) . uncons
18:57:53 <copumpkin> that's a flat eliminator
18:58:03 <shachaf> What copumpkin said. It's just the scott encoding.
18:58:11 <copumpkin> scott is weirder than that
18:58:30 <dmwit> Anyway, I don't think there's anything pre-written. But I'm sure you know how easy that is to fix. =)
18:58:45 <shachaf> Is it?
18:58:47 <shachaf> What would it be?
18:59:19 <zxs> I have a function like f :: (c -> b -> d) -> (c -> a -> (e, c, c)) -> c -> Tree a b -> Tree e d
18:59:25 <copumpkin> list z f [] = z; list z f (x:xs) = f x xs
18:59:35 <dmwit> shachaf: list x f [] = x; list x f ys = f ys, I guess
18:59:41 <copumpkin> oh, he was asking the scott
18:59:45 <dmwit> oh
18:59:47 <zxs> is this a hylomorphism? I can't figure out how to decompose it into a catamorphism and anamorphism
19:00:51 <copumpkin> shachaf: you'd want recursion in the type
19:00:58 <unlink> list :: b -> (a -> [a] -> b) -> [a] -> b is certainly more useful in general, I'm just looking for a  list' = flip list (:)
19:01:08 <shachaf> Ah, you mean that it's not really an encoding if you have [] left over.
19:01:13 <copumpkin> so something like newtype List a = List { unList :: forall r. r -> (a -> List a -> r) -> r }
19:01:18 <shachaf> But you end up with something recursive in a similar way to [].
19:03:05 <zxs> (in case it isn't clear, it's a structure-preserving top-down tree transformation. is there a term for such a thing?)
19:12:10 <zxs> I can't find anyone using this type of tree: data Tree a b = Leaf b | Branch a (Tree a b) (Tree a b)
19:12:47 <zxs> is there any particular reason? it seems more flexible than the finger tree representation
19:16:02 <dmwit> Finger trees aren't really about flexibility...
19:17:04 <copumpkin> finger trees are ordered annotated sequences
19:17:15 <copumpkin> that happen to be tree-shaped
19:18:13 <copumpkin> zxs: you'd use the a as the annotation and the b as the payload?
19:18:22 <copumpkin> the nice thing about yours is that you get to annotate with a semigroup!
19:18:37 <vazakl> ive always wanted to do that
19:18:58 <vazakl> j/k
19:19:11 <copumpkin> you could shift fingertrees a bit to make them non-empty and deal with emptiness at the topmost level
19:19:15 <copumpkin> but it's a pita
19:19:37 <copumpkin> and not the tasty kind
19:21:59 <zxs> copumpkin, yeah, a is the annotation, b is the payload. this allows for annotated leaves using b = (a, c) or no annotations with a = ()
19:22:47 <zxs> or trees with data on internal nodes with a = b
19:24:19 <zxs> I am just completely incapable of figuring out what the correct terms are for the types of transformations I want to implement
19:24:37 <copumpkin> well, presumably you want a way to keep it balanced?
19:26:34 <zxs> no, in this particular case I want to implement a top-down transformation with a seed value (like a fold) that generates a new tree with the same structure as the original
19:26:53 <zxs> so it's not really a fold
19:28:47 <dmwit> I'm pretty sure copumpkin was talking in general, not about the specific case of the type you posted above.
19:30:15 <zxs> oh. the case I'm using it in requires no balancing
19:31:28 <FreeFull> zxs: that sounds like a variation on a map?
19:31:39 <FreeFull> You probably could implement it in terms of a fold
19:33:05 <zxs> I can implement it fairly easily, I just don't know what it's called or whether it's a combination of more primitive transformations
19:35:50 <zxs> in which case I might not even have to implement it :)
19:36:36 <FreeFull> Well, it's something which fills the tree with seed values + a map
19:42:57 <zxs> do you mean something like zipWith?
19:42:57 <zxs> after constructing the seed tree
19:42:58 <zxs> even if you simplify it to that, constructing the seed tree is the confusing part, because using an unfold to do it (unfold with the seed value and tree in a tuple
19:42:58 <zxs> ) isn't guaranteed to preserve structure
19:45:13 <FreeFull> zxs: You'd fold over the original tree to get the seed tree
19:45:33 <FreeFull> You wouldn't need zipWith at any point I think
19:46:05 <tsinnema> what sorts of databases would be best for storage and retrieval of values of algebraic datatypes? i'm quite oblivious on this issue
19:46:57 <zxs> the computation I mentioned above operates on the seed and annotation/value, though, so a zipWith would be necessary on both trees
19:47:14 <zxs> f :: (c -> b -> d) -> (c -> a -> (e, c, c)) -> c -> Tree a b -> Tree e d
19:48:19 <FreeFull> zxs: You could just store both the value and seed in a tuple
19:48:31 * hackagebot splines 0.5.0.1 - B-Splines, other splines, and NURBS.  http://hackage.haskell.org/package/splines-0.5.0.1 (JamesCook)
19:48:38 <FreeFull> Or something similar
19:48:51 <FreeFull> So no need for zipWith
19:49:15 <zxs> also, FreeFull, the transformation needs to be top-down, so I don't see how a fold can do it
19:49:30 <zxs> *constructing the seed tree rather
19:49:41 <FreeFull> Top down meaning starting from the root node, or?
19:50:03 <zxs> yes
19:52:52 <zxs> I think this looks like a traverse, but with branching
19:56:14 <FreeFull> I think it's equivalent to zipping a list of seed values with a tree
19:58:00 <zxs> the hard part is generating the seeds
19:59:09 <vazakl> cool
19:59:11 <vazakl> haskell rules
20:00:58 <FreeFull> zxs: Do you have an algorithm for getting the next seed?
20:03:06 <zxs> it's a function g :: seed -> a (the internal node annotation) -> (seed, seed)
20:04:23 <FreeFull> Hmm, a tuple of seeds at the end?
20:04:37 <FreeFull> For the left and the right branch?
20:05:13 <zxs> yes
20:06:16 <FreeFull> Do you have that function?
20:10:21 <zxs> FreeFull, it's an argument to the traversal
20:16:33 <cmears> criterion's documentation says that its function "nf" does:
20:16:34 <cmears> Apply an argument to a function, and evaluate the result to head normal form (NF).
20:16:47 <cmears> Isn't this just "normal form", not "head normal form" ?
20:16:58 <cmears> (it's at http://hackage.haskell.org/packages/archive/criterion/0.8.0.0/doc/html/Criterion-Main.html#v:nf )
20:17:59 <tsinnema> what sorts of databases would be best for storage and retrieval of values of algebraic datatypes? i'm quite oblivious on this issue
20:18:45 <edwardk> tsinnema: i've got some code i've been working on based on storing 'semi-indexed' data structures and deserializing only the portions you look at
20:19:14 <edwardk> tsinnema: the 'tables' package can already do arbitrary ADTs though for in-memory storage
20:20:34 <zxs> edwardk, your site seems to be down :(
20:26:32 <edwardk> zxs: sadly. i moved it to a new box, but i still have some configuration to do
20:38:46 <zxs> okay, I'm pretty happy with this function now
20:39:40 <zxs> traverseDown :: (c -> a -> (d, c, c)) -> (c -> b -> a) -> c -> Tree a b -> Tree d e
20:41:05 <Attilah> Hey everyone
20:41:14 <holly6> Hi, what does this syntax mean in haskell? >>=
20:41:20 <zxs> it's a little different from the usual traverse because doing it with a monad would impose an ordering, and I don't need that
20:41:32 <Attilah> @holly6 it means bind (>>=)
20:41:32 <lambdabot> Unknown command, try @list
20:41:35 <Hermit> holly6: it's the bind operator
20:41:42 <holly6> Thanks
20:42:07 <Hermit> holly6: anything that doesn't contain alphanumeric chars, is an infix operator
20:42:31 <blackdog> holly6: so, it's not actually syntax, in some sense - it's just a function that happens to be in non-alphanumeric characters
20:42:47 <Attilah> @holly6 : the bind operator is a function, and its signature is : (>>=) :: (Monad m) => ma -> (a -> mb) -> mb
20:42:47 <lambdabot> Unknown command, try @list
20:42:53 <tabemann> >>= sequences two monadic actions, taking the value out of the first, and passing it to a function that creates the second, which gives the value of the resulting action
20:43:41 <holly6> Oh so like a pipe sort of
20:43:43 <tabemann> foo >>= (\x -> bar x) is equal to
20:43:45 <tabemann> do
20:43:50 <tabemann> x <- foo
20:43:52 <tabemann> bar x
20:44:03 <elliott> "the value" is a bit misleading.
20:44:21 <elliott> there can be multiple values or none at all and it can be called any number of times in different contexts, etc.
20:44:42 <byorgey> holly6: sort of like a pipe... but analogies are unlikely to get you very far =)
20:44:57 <byorgey> holly6: do you know the definition of Functor?
20:45:09 <ChongLi> the key thing to remember is the pronounciation of >>=
20:45:12 <ChongLi> "bind"
20:45:20 <ChongLi> it binds two actions together
20:46:07 <tabemann> well the difference between it and >> is that >>= extracts the value from the first and passes it to a function creating the second, whereas >> throws away the value in the first
20:46:42 <holly6> I meant like a pipeline from unix lol
20:47:06 <ChongLi> holly6: it's similar to that for some monads
20:47:09 <ChongLi> but not others
20:47:19 <holly6> ok thanks
20:47:21 <shachaf> "taking the value out of the first" is more than a bit misleading.
20:47:26 <ChongLi> the other thing to remember is that >>= is polymorphic
20:47:38 <shachaf> There's no value of type "a" inside a value of type "m a", for most monads m.
20:47:39 <ChongLi> each monad defines the operation of its own >>=
20:47:57 <ChongLi> and this is where the power of monads originates
20:48:35 <ChongLi> you are treating different values in a similar manner, based on the fact that they fit the pattern of a monad
20:48:51 <ChongLi> and the differences are captured in >>=
20:49:24 <holly6> Thankyou
20:50:18 <tabemann> shachaf: how is a value foo not in resulting value of m a when you issue "return foo"?
20:50:22 <tsinnema> edwardk: ok. i'm of course curious to see how that data store code turns out
20:50:46 <elliott> tabemann: with all due respect, I think your explanation of monads is a bit unnuanced and possibly harmful to newbies, since it's overly-restrictive and doesn't account for many important monads like [], Cont, and IO
20:51:26 <bd_> tabemann: There is the nullary monad... but any other monad 'return' will necessarily be injective
20:51:32 <byorgey> all monad explanations considered harmful
20:51:43 <elliott> @quote shachaf /bin/ls
20:51:43 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
20:52:43 <tabemann> well getLine :: IO String contains a thunk that when evaluated reads characters of a line from standard input
20:53:06 <holly6> Lol from my little bit of experience with haskell so far, a monad seems to be some mystical being and if you try and define it you get into trouble.
20:53:32 <ChongLi> holly6: you only get into trouble when you define it by analogy
20:53:47 <elliott> tabemann: that's not true. the Report doesn't say anything like that, and it's perfectly possible to give implementations of IO that don't satisfy that. GHC uses something a little like that under the hood, but it's still a bad way to think about IO.
20:53:54 <zxs> it's just a monoid in the category of endofunctors
20:53:55 <ChongLi> it has a very precise definition but that is not very useful for many people
20:54:01 <ChongLi> yes, exactly
20:54:12 <byorgey> holly6: don't worry about it too much yet.  If you are just starting, there is a lot of other stuff you can usefully learn first.
20:54:16 <bd_> lots of examples is probably more helpful in the long run
20:54:16 <zxs> when you think about it that way it's not so crazy
20:54:27 <elliott> I suggest you get a better grip on things like this before trying to explain monads to people, especially since like holly6 says, it's something that people get scared of a lot because of misleading explanations
20:54:42 <ChongLi> with examples the key is to identify the pattern
20:55:06 <bd_> ChongLi: or even just several useful patterns, even if they don't overlap
20:55:32 <ChongLi> that's really one of the big jobs of a programmer
20:55:36 <bd_> if you know how to use IO that's enough to get started with non-trivial programs, after all. You can learn how it works under the hood later :)
20:55:41 <ChongLi> identify patterns and build an abstraction for them
20:55:49 <byorgey> elliott: I think you're being a bit harsh on tabemann.
20:56:09 <zxs> 1. learn about monoids (which most people find pretty easy), 2. learn about endofunctors, 3. now you know about monads
20:56:19 <ChongLi> and if your abstraction turns out to be well-founded mathematically speaking
20:56:20 <elliott> byorgey: sorry -- not intending to come off that way.
20:56:26 <zxs> I'm not sure why the 10k examples approach is taken over that
20:56:35 <zxs> since it's much more confusing
20:56:40 <elliott> I just see newbies get themselves confused by weeks by inaccurate monad explanations and am very sensitive to them as a result :)
20:56:46 <ChongLi> you can write a few laws for it
20:56:56 <Aetherspawn> It's easier to just understand exactly how monads work then to understand what they represent
20:57:10 <Aetherspawn> (Coming from an imperative background)
20:57:20 <dmwit> zxs: There are audiences for whom your explanation would be perfectly good. There are also audiences that you just completely lost that nevertheless enjoy the 10k examples approach very much.
20:57:26 <Aetherspawn> If it wasn't for Haskell's type system, they would never work.
20:57:28 <tabemann> I am rather new to Haskell myself, and have been recently trying to wrap my brain around it as far as I can (before I got my machine repaired so I could install GHC on it)
20:57:32 <ChongLi> yeah, I think a lot of people learning haskell are operating without a complete understand of Haskell's types
20:57:39 <byorgey> elliott: sure, me too, but I am also sensitive to people at an intermediate level being scared away when trying to be helpful. =)
20:57:43 <ChongLi> since a lot of Haskell tutorials gloss over the type system
20:57:56 <Aetherspawn> All monads are boxes.
20:58:09 <Aetherspawn> Which can hold other boxes that are also monads, or base types.
20:58:16 <elliott> byorgey: fair. tabemann: I apologise for the tone.
20:58:20 <dmwit> All boxes are cardboard.
20:58:33 <dmwit> Except the ones that aren't, but those sort of behave like cardboard in same ways, so it's okay, right?
20:58:35 <Hafydd> Are boxes isomorphic to burritos?
20:58:46 <liyang> How many people *really* have a complete understanding of Haskell's types?
20:58:54 <byorgey> Hafydd: only burritos made of cardboard
20:59:07 <zxs> dmwit, there are also audiences who are totally confused and discouraged by 10k examples :/
20:59:08 <liyang> I can count them on one hand.
20:59:17 * tabemann opted to bypass most of the tutorials and instead got LYAH and RWH
20:59:19 <dmwit> zxs: I am perfectly willing to believe that.
20:59:37 <elliott> I think the monoids approach is an unnecessarily indirect route, even if you just want to present it in the fmap/join/laws form
20:59:50 <Nisstyre> tabemann: I didn't find either book to be that useful. Although the first few chapters of RWH are how I started learning.
21:00:02 <elliott> I don't think the monoidal structure really helps you understand those laws better as an initial introduction, and you have to digress through a bunch of CT to state it
21:00:35 <elliott> also, people often misinterpret the monoid-in-the-category-of-endofunctors thing as meaning that (>=>) is associative and has return as an identity
21:01:46 <zxs> elliott, it definitely helps with the "but what /is/ a monad?" part, though, which I think a lot of people get caught up on, thinking it's like a data structure
21:02:35 <Nisstyre> zxs: maybe it's better to present it as a purely algebra thing unrelated to programming?
21:02:53 <zxs> which is maybe caused by all the box analogies
21:03:06 <zxs> I think it is, at least at first
21:03:06 <elliott> I think people should have a strong understanding of typeclasses before going onto Monad
21:04:13 <tabemann> typeclasses seemed pretty trivial to wrap my brain around, as much as the are supposedly so confusing for people from a traditional object-oriented worldview
21:04:52 <Nisstyre> tabemann: well they're much simpler than object oriented classes obviously
21:05:12 <newsham> now if there was only an encyclopedia of type classes
21:05:37 <byorgey> gosh, what a great idea
21:05:40 <tabemann> it took a little more to wrap my brain around multiparameter typeclasses, but even after a bit explanation (and explaining especially how type dependencies worked) that made sense
21:05:44 <elliott> I assign byorgey to write it
21:05:50 <byorgey> I'm on it
21:05:53 <byorgey> give me a few minutes
21:06:23 <FreeFull> What about lenses? Profunctors?
21:06:27 <Hafydd> A complete encyclopedia of typeclasses?
21:06:34 <byorgey> http://www.haskell.org/haskellwiki/Typeclassopedia
21:06:41 <elliott> excellent work.
21:06:42 <byorgey> it's incomplete, I only had a few minutes to write it
21:06:55 <Hafydd> Okay, I suppose you're only human.
21:06:56 <elliott> I'll only pay you half. here's your 0 bitcoins:
21:06:59 <byorgey> also ignore that stuff about being published in 2009, that's wiki vandalism
21:07:23 <newsham> how come byorgey isnt a bitcoin millionaire?
21:07:47 <edwardk> The state of the libraries@ mailing list summarized by grumpy cat: http://cheezburger.com/7489009408
21:08:05 <byorgey> hahaha
21:08:27 <newsham> re: cheezeburgers: I can has?
21:08:29 <ChongLi> FreeFull: for lenses check out edwardk's great video: https://www.youtube.com/watch?v=cefnmjtAolY
21:08:45 <newsham> edwardk should also have more bitcoins than he does
21:09:21 <elliott> obviously edwardk invented bitcoins. he used a pseudonym because he was ashamed of writing C++ code.
21:09:28 <Hafydd> Hahah.
21:10:44 * byorgey is making his bitcoin millions vicariously through dmwit 
21:14:27 <edwardk> elliott: the problem is if i ever cash them in then i'll be immediately outed
21:14:49 <newsham> lambdabot needs a way to let people tip people
21:14:58 <edwardk> https://bitslog.wordpress.com/2013/04/17/the-well-deserved-fortune-of-satoshi-nakamoto/
21:18:01 <newsham> has satoshi been outed yet?
21:22:07 <vazakl> his identity remains mysterious
21:23:50 <vazakl> partycoin
21:26:06 <carter> theres at least 7 dfferent * coins now
21:26:53 <carter> edwardk it seems like libraries chatter has been pretty productive
21:27:03 <carter> or am I missing subtext?
21:27:09 <carter> despite having read all the emails
21:27:28 <carter> ?
21:31:06 <carter> byorgey typeclassopedia is nice, i've never read it before
21:31:13 <carter> productive bloggers
21:31:18 <byorgey> thanks carter
21:31:45 <carter> byorgey no worries, you get to hear more about my slow progress on my mad schemes in like 2 weeks
21:32:13 <byorgey> I'd rather see than hear
21:32:17 <byorgey> but looking forward to it either way =)
21:32:59 <carter> byorgey I may have a plan to solve the cmm problem
21:33:03 <carter> cmm++ == c !
21:33:04 * tabemann glances at Typeclassopedia
21:33:33 <dmwit> byorgey: P.S. I made a reservation request for 512 after all.
21:33:59 <vazakl> 512?
21:34:30 <dmwit> vazakl: a room for Hac Phi, sorry, probably this isn't the right channel for this chatter
21:35:01 <carter> dmwit its always the right channel :)
21:35:41 <carter> byorgey or at least, a way of writing direct style C with some restrictions but then using clang + llvm + some preprocessing magic to make it use the ghc calling convention
21:37:53 <carter> ghc 7.8 has a nicer calling convention for doubles math
21:38:15 <carter> byorgey has anyone benchmarked diagrams on ghc 7.8?
21:38:29 <carter> the more numerical bits could be a teeny bit faster from that alone, mayb
21:38:33 <byorgey> carter: no one has benchmarked diagrams on anything.
21:38:36 <carter> ok
21:38:38 <carter> TRUE
21:38:40 <carter> :)
21:38:48 <carter> thans jbrackers job partly then
21:39:00 <carter> since he'll have automated producing giant diagrams
21:39:11 <carter> ish
21:52:54 <BMeph> BBL - upgrading....
22:37:02 <m3ga> Yay! haskell-platform has been released!
22:37:35 <mekeor> hm?
22:41:23 <ChongLi> may 6th
22:41:26 <Finnfinn> m3ga: Wha?
22:41:52 <ChongLi> 2013.2.0.0 right?
22:43:29 <m3ga> ChongLi: yes
22:43:57 <mzero> yes 2013.2 is out
22:44:06 <mzero> and yes - it is later than we had hoped
22:44:22 <m3ga> well done mzero!
22:44:22 <mzero> but we had a late GHC change ... followed by ... well .. too much to do on my plate!
22:44:32 <ChongLi> ahh
22:44:40 <mzero> (some how I scheduled BayHac right on top of the release!)
22:44:49 <mzero> :-P
22:44:53 <ChongLi> I like that attoparsec and unordered-containers made it
22:44:55 <mzero> but - it's out! yay!
22:46:13 <m3ga> very pleased to see 7.6.3 as part of it
22:46:25 <m3ga> mzero: did i say how awesome bayhac was?
22:46:39 <mzero> aw, shucks!
22:47:55 <mzero> I had a blast too
23:33:35 * hackagebot lgtk 0.5.1 - lens-based API for Gtk  http://hackage.haskell.org/package/lgtk-0.5.1 (PeterDivianszky)
23:37:01 <arkeet> data-lens =(
23:40:17 <supki> at least it's not fclabels
23:41:04 <dpwright_> is there an easy way just to throw away the value of the last thing I call in my main function?
23:41:27 <cmears> you can put "return ()" after it (if it's a do block)
23:41:30 <shachaf> main is usually not a function
23:41:49 <shachaf> But generally, yes, you can use return () at the end, or void $ the whole expression.
23:42:04 <dpwright_> I'm just writing a simple script in haskell (my first), and the last thing it does is a call to system, which returns IO ExitCode, not the IO () that main is defined as
23:42:13 <dpwright_> hmm, thought I'd tried return (), maybe I did something stupid
23:42:22 <supki> or make  main :: IO ExitCode
23:42:35 <dpwright_> (it works if I set the type of main IO ExitCode, but then it prints out ExitSuccess every time)
23:42:50 <supki> ?
23:43:23 <elliott> no matter what a you pick for IO a, the return value is ignored
23:43:32 <elliott> IO String, IO ExitCode, IO [Int], whatever
23:43:35 <elliott> even IO (IO Int)
23:43:37 <dpwright_> doing return () works fine... no idea what I did wrong before
23:43:38 <shachaf> That's also true.
23:43:47 <dpwright_> really?  hang on
23:44:07 <shachaf> () is not required, just standard.
23:44:18 <dpwright_> maybe it's a quirk of "runhaskell", which I'm using to run it
23:44:37 <shachaf> Yes.
23:45:01 <shachaf> runghc (/ghc's runhaskell) is really more like ghci.
23:45:03 <dpwright_> yeah, just tried compiling it and it was fine
23:45:07 <shachaf> So it'll show the value.
23:45:13 <shachaf> I consider that a bug.
23:47:47 * elliott suggests just always using IO ().
23:52:24 <dpwright_> shachaf: Thanks, yeah, for now I'll, just return () to work around runhaskell's behaviour
23:53:03 <shachaf> Also note that runghc is probably significantly slower than compiling, even with -O0.
23:53:23 <shachaf> Er, I mean, than a compiled binary.
23:53:31 <dpwright_> elliott: I am doing that because all the tutorials do that, but why do you suggest it in particular?  The one thing I thought is, this thing is sort of like a shell script, so I may want to return a certain return value to indicate failure at some point...
23:54:10 <dpwright_> shachaf: Yeah, this is literally just a dumb helper script so speed doesn't really matter; for anything "proper" I'd compile
23:54:15 <cmears> dpwright_, to do that use "exitWith" and friends in System.Exit
23:54:21 <shachaf> dpwright_: "return" in Haskell is nothing like "return" in most other languages.
23:54:33 <shachaf> It doesn't "exit early" or anything like that.
23:54:41 <elliott> dpwright_: if you do IO Int and then do "return 4" it does nothing at all outside of ghci/runhaskell.
23:54:45 <shachaf> You can stick "return blah" in the middle of main and nothing will happen.
23:54:46 <elliott> and the latter is a quirk/bug of runhaskell
23:54:55 <elliott> in a compiled program or whatever, it does nothing at all
23:56:10 <dpwright_> right, I'd sort of gathered that return didn't exit early, but then I was using it at the end of a function...
23:56:19 <Mortomes_> It's a rather unfortunately chosen name
23:56:38 <dpwright_> basically this all started when I got a type error because the last line in my main function was a call to "system", and main had been declared as returning IO ()
23:56:46 <shachaf> dpwright_: Makes sense.
23:56:55 <shachaf> I recommend declaring main as IO (), and using return () at the end of main.
23:56:56 <dpwright_> so I started the "making it compile" dance there
23:57:51 <dpwright_> right, ok -- that sort of advice is nice to have, because when learning something as new as haskell is to me, often you can find four different ways to "make it work" and it's hard to tell which of those is good/idiomatic
23:57:54 <no-n> isn't it a better idea to just not type declare main?
23:58:20 <shachaf> It's a good habit to give every top-level declaration a type signature by default.
23:58:46 <shachaf> In the case of main it doesn't matter a great deal. But you may as well get into the habit.
23:59:01 <no-n> well, main is a special case
23:59:10 <no-n> it doesn't need one and it can only bite you
23:59:18 <no-n> afaik
23:59:38 <dpwright_> and in the case of runhaskell, not declaring a type signature means that whether it prints something funny after it runs your program and what it prints depends on the last line of the function/do
23:59:54 <shachaf> A type error isn't the compiler "biting you". The compiler is not your enemy.
