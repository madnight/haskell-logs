00:15:04 <latermuse> why isnt haskell able to determine > product [1..] == product [1..]
00:15:35 <shachaf> It is able to determine it.
00:15:42 <shachaf> Its values is ⊥.
00:15:47 <shachaf> s/es/e/
00:32:25 <latermuse> does using applicative for effects have better compiled performance than monadic effects? or are they the same?
00:33:11 <Aetherspawn> desugar the usage of the monad
00:33:17 <Aetherspawn> and see for yourself if you do more stuff
00:33:34 <shachaf> latermuse: It depends on the Applicative instance.
00:33:37 <shachaf> For some of them, yes.
00:33:57 <latermuse> so applicative will sometimes have better performance than the monadic equivelant?
00:34:10 <shachaf> Yep.
00:34:22 <latermuse> is it ever true that the monad will have better performance than its applicative equivelant?
00:34:56 <shachaf> I think your phrasing here is pretty vague/imprecise.
00:35:01 <shachaf> But I'll go with "no".
00:35:47 <chrisbuchholz> exit
00:35:50 <chrisbuchholz> woops
00:35:53 <chrisbuchholz> wrong buffer
00:41:07 <latermuse> so its best to use applicative whenever it can be used instead of a monad?
00:41:34 <shachaf> Yep.
00:41:39 <shachaf> And better still to use Functor.
00:41:53 <latermuse> can functors have sideeffects?
00:42:17 <shachaf> Values don't have side effects. Interpreters have side effects.
00:42:30 <shachaf> Also, functors are type constructors like Maybe. Does Maybe have side effects?
00:42:44 <latermuse> I see
00:42:57 <MasseR> Also any monad is an applicative and any applicative is a functor
00:46:27 * hackagebot terminal-size 0.1.0.0 - Get terminal window height and width  http://hackage.haskell.org/package/terminal-size-0.1.0.0 (MatveyAksenov)
00:46:44 <edwardk> lispy:one worry about using () for the writer state is that you by construction leak a giant 'tree' of mappend () (mappend () ()) stuff that doesn't get forced until the very end
00:47:03 <edwardk> lispy: this holds in general for using writer though
00:47:12 * shachaf looks for context.
00:47:49 <mauke> Context discussion => discussion -> Bool
00:56:14 <augur> mauke: actually conversational context is just the state in a stateful proposition
00:56:49 <hrookie> oh, the joys of lazy IO. :(
00:56:59 <augur> a probably more accurate way of representing this more generically than typical presentations is something like
00:57:37 <augur> Context c a => State c a
00:58:06 <augur> where Context c a just means that a is the sort of thing that can have a linguistic context at all
00:58:14 <otters> does anybody happen to know how to do a join in persistent?
00:58:20 <otters> there's no #persistent so I thought I might ask here
00:59:03 <shachaf> That sounds like a #yesod question to me.
00:59:08 <augur> mauke: tho generally its more like   c = a = [World]   or something like that
01:00:02 <otters> Yeah, I asked #yesod too, but it's never good to assume there's anybody active in there
01:00:56 <mauke> augur: what is a linguistic context?
01:01:38 <augur> mauke: usually its something like a set of worlds in the modal logic sense
01:02:22 <mauke> oh god
01:02:29 <edwardk> ?
01:03:43 <augur> mauke: ?
01:04:02 <mauke> I don't even know what modal logic is
01:04:51 <mauke> http://upload.wikimedia.org/wikipedia/commons/0/04/Modallogik.jpg
01:05:01 <augur> oh
01:05:07 <shachaf> Hey, modal logic is great!
01:05:13 <shachaf> Or at least some kinds of modal logic.
01:05:31 <augur> modal logic is a variant on normal sentential logic with an extra propositional combinator (or two)
01:05:52 <augur> you can extend it to predicate logic too.
01:06:44 <mauke> hah, but what is normal sentential logic?
01:07:26 <augur> simply typed lambda calculus
01:07:32 <augur> minus the proof terms
01:08:04 <hrookie> does anyone know how to force data in a network transmission? i'm sending bytestrings, so the trick to say "lines" and "linebuffering" doesn't work anymore >.>
01:08:15 * djahandarie wonders why augur used "sentential logic" rather than "propositional logic"
01:08:25 <augur> djahandarie: oh yes that too
01:09:02 <Cale> hrookie: hFlush?
01:09:52 <hrookie> so, if I hFlush, does it get sent *for sure* -- e.g., any delay incurred is happening on the other side of the connection?
01:12:49 <mauke> hmm, so (not . possible) == (necessary . not)
01:13:09 <hrookie> oy, i guess it's on the server side.
01:14:07 <shachaf> mauke: There are lots of modal logics with incompatible axioms.
01:14:21 <shachaf> Tell me if you find a good one!
01:14:51 <shachaf> Some of them have primitives similar to Monad's return/join but without fmap.
01:15:00 <mauke> : there exist many modal logics L for which Axioms(L) is incompatible
01:15:46 <hrookie> so, on the server i'm using hGetContents on the socket
01:15:58 <hrookie> and nothing gets evaluated until the connection closes
01:16:00 <shachaf> If you think of it from the perspective of Haskell, I think it means that you're talking about a logic *weaker* than Haskell, rather than stronger than Haskell (like a monad/comonad/functor/etc. gives you).
01:16:15 <hrookie> is there a convenient way to say seriously hGetContentsRightFreakingNow?
01:16:20 <shachaf> So in particular (a -> b) indeed doesn't imply (F a -> F b)
01:18:30 <augur> shachaf: fmap is actually one of the core modal axioms
01:19:22 <mauke> hrookie: you could use ByteStrings
01:19:24 <augur> oh no sorry
01:19:34 <mauke> or evaluate (length stuff)
01:19:52 <augur> we have an applicative like structure
01:20:40 <augur> hmm
01:21:04 <augur> is it true that P -> Q implies []P -> []Q?
01:21:12 <augur> no but its true for <> i think right
01:21:12 <hrookie> mauke: i am sending ByteStrings from the client to the server. I hFlush after each send. The server has a response routine which separates the ByteStrings by a reserved separator, then decodes them, then prints out a message response. The message responses all come at once after the connection from the client closes.
01:21:20 <augur> P -> Q implies <>P -> <>Q
01:21:36 <augur> in transitive logics i guess?
01:23:00 <mauke> hrookie: wait, then why do you want to use hGetContents?
01:23:40 <hrookie> mauke: i want to use something which just continually streams in from the socket without having a specified limit
01:23:56 <mauke> hrookie: which ByteStrings are you using?
01:24:47 <hrookie> mauke: Data.ByteString
01:25:02 <hrookie> mauke: data serialized into ByteStrings from Data.Serialize
01:25:14 <mauke> hrookie: ಠ_ಠ
01:25:19 <mauke> so what did you expect to happen?
01:25:49 <mauke> hGetContents reads data until the end is reached. there is no end until the client closes its socket
01:25:56 <mauke> so the server blocks
01:26:28 <hrookie> mauke: yeah. interestingly, if you set LineBuffering, you'll get instant responses. That's where I got the idea in the first place.
01:26:49 <hrookie> mauke: i mean, if you are using LineBuffering, transmitting plain text messages, and ending them with newlines, then using lines on whatever hGetContents yields.
01:27:16 <mauke> ... are you using ByteStrings or not?
01:27:19 <hrookie> mauke: this will get you one line of input from hGetContents on demand. However, now switching over to a ByteString with split, you don't get the same behavior.
01:27:25 <mauke> wtf
01:29:38 <hrookie> mauke: it appears that, if you're transmitting strings instead of text, LineBuffering works to yield one line at a time as it comes in. Now, with ByteStrings, it doesn't.
01:29:47 <hrookie> transmitting strings instead of ByteStrings*
01:30:03 <mauke> your description makes no sense to me
01:30:38 <hrookie> okay. server has a socket. socket wrapped in a handle. handle set to line buffering. client sends server strings separated by newlines. server will read and respond to those lines as they come in on demand, instantly.
01:30:48 <mauke> that's not code
01:30:53 <mauke> that's a vague paraphrase
01:31:29 <hrookie> well, would you like an hpaste?
01:31:33 <typoclass> hrookie: hello. have you tried to set NoBuffering?
01:31:48 <hrookie> typoclass: yes, i've tried that as well, to no avail
01:31:50 <mauke> hrookie: yes, or a description in terms of code
01:36:20 <typoclass> hrookie: how about using hGet to read one byte after the other, until you reach \n ?
01:37:27 <hrookie> http://hpaste.org/88082
01:38:09 <hrookie> typoclass: you mean set up a tail recursive function that gets one element at a time, and returns a concatenated list of them?
01:39:14 <mauke> hrookie: are those different hGetContents?
01:40:07 <hrookie> mauke: yes, sorry - lower snippet is with ByteString, top one is probably System.IO. ByteString's should be strict.
01:40:22 <typoclass> hrookie: yes, exactly :-) you could implement it yourself for exercise, or use monad-loops
01:41:00 <mauke> hrookie: and that's the difference
01:41:05 <mauke> strict ByteStrings are strict
01:41:11 <mauke> they don't support lazy IO
01:42:32 <hrookie> mauke: interesting. so, it might work if i used ByteString.Lazy?
01:42:59 <mauke> yes
01:43:21 <quchen> Aren't lazy BS pretty much lists of strict and short BS?
01:43:33 <mauke> yes
01:43:39 <quchen> In that case, wouldn't you have a strict one again until you reach the length of a section?
01:44:54 <mauke> oh, true. it still reads in chunks, not lines
01:46:48 <hrookie> hm
01:46:51 <hrookie> that may pose an issue
01:47:26 <quchen> Why don't you use lists and then profile?
01:47:34 <quchen> The whole BS thing may be unnecessary
01:47:54 <mauke> ByteStrings are for correctness, not performance
01:48:06 <quchen> Huh?
01:49:48 <quchen> hrookie: Also: use bracket! Makes it impossible to forget the hClose.
01:50:01 <quchen> Plus hClose is called even when there's an error somewhere.
01:50:10 <hrookie> quchen: I'm transmitting data across the network, so I serialize my types, send them on over, and deserialize on arrival. I'm not sure what you mean by lists and then profile.
01:50:51 <finishingmove> what do haskell people think of clojure?
01:50:52 <quchen> Ah, if you're serializing then you need BS, true.
01:51:11 <typoclass> finishingmove: do not want. needs moar type system. kthxbai. ;-)
01:51:46 <quchen> ^ The type system will probably be the primary (substantial) complaint, yes.
01:51:54 <mauke> (but don't combine hClose and hGetContents)
01:52:08 <typoclass> hrookie: have you considered the "foo ... = b <- hGet handle 1; when (b /= '\n') foo" possibility mentioned above?
01:52:15 <merijn> finishingmove: Seems a slightly neater Lisp and lisp is neat language, although almost entirely the opposite of haskell :p
01:52:23 <finishingmove> make your own type system in it
01:52:28 <finishingmove> :D
01:52:46 <merijn> finishingmove: Also, Rich Hickey seems a grade A good engineer, so that helps
01:53:14 <typoclass> finishingmove: rich hickey is clearly a sensible reasonable engineer. and i hear they did a great deal of work on data structures
01:53:14 <hrookie> typoclass: i have, but i'd like to use something a little more natural if i can.
01:53:37 <hrookie> also, does anyone have experience with Data.ByteString.Internal.ByteString coming out everywhere? when I moved over to Lazy, ghc flipped out
01:54:22 <merijn> finishingmove: In short, as far as non-haskell languages go, it's pretty good, but requires a completely different programming approach than haskell
01:54:24 <mauke> hrookie: you can ignore the "Internal" bit
01:54:32 <mauke> hrookie: there are two types called ByteString
01:54:39 <mauke> one is strict, the other lazy
01:55:50 <hrookie> mauke: it's due to the type's called upon in Serialize
01:56:27 <Aetherspawn> Is there some monad that implements ReaderT and StateT simultaneously
01:56:27 <hrookie> mauke: gotta say Lazy :D
01:56:44 <Aetherspawn> ie: like transformers RWS but without the write
01:56:59 <Chousuke> finishingmove: typoclass: https://github.com/clojure/core.typed
01:57:02 <quchen> Aetherspawn: No, you'll have to make a newtype for that yourself.
01:58:28 <merijn> Aetherspawn: I just use RWST with () as writer
01:58:39 <finishingmove> neat, Chousuke :)
01:58:44 <Aetherspawn> does tha thave performance penalty?
01:58:46 <Aetherspawn> *that have
01:59:00 <quchen> merijn: The problem with that is the () thunk buildup, because mappend is non-strict
01:59:15 <hrookie> it appears to be working, mauke! thanks!
01:59:45 <adnap> One thing I realized about record functions vs pattern matching is that code using the former doesn't need to be changed when more records are added to the data constructor or the order of records changes
01:59:50 <hrookie> typoclass: while your approach probably would have worked, i think relying on internals and flushing is just... cleaner?
01:59:55 <adnap> *value constructor
02:01:23 <hrookie> mauke++
02:02:31 <merijn> Is there a way to get the hoogle commandline tool to index/search you locally installed packages?
02:02:42 <johnw> adnap: the haskell report actually uses "data constructor" too
02:03:03 <arkeet> merijn: cabal install --haddock-hoogle
02:03:15 <adnap> johnw:
02:03:25 <adnap> johnw: I think "data constructor" is the thing on the left side
02:03:48 <johnw> that's the type or the type constructor, if it takes an argument
02:03:53 <merijn> arkeet: When installing things, you mean?
02:03:55 <quchen> merijn: Maybe search .cabal/share/doc/doc-index-All.html manually as a workaround
02:03:56 <arkeet> yeah
02:04:11 <merijn> arkeet: So that means having to reinstall everything? :(
02:04:16 <Aetherspawn> @pl (\ r s -> return (r, s))
02:04:16 <lambdabot> (return .) . (,)
02:04:17 <adnap> johnw: I think "type constructor" refers to type synonyms
02:04:25 <Aetherspawn> :t curry
02:04:28 <johnw> those are type synonyms ;)
02:04:30 <lambdabot> ((a, b) -> c) -> a -> b -> c
02:04:40 <merijn> adnap: Not only, could be type families
02:04:41 <arkeet> merijn: I don't know.
02:04:41 <johnw> data Foo a = Foo a defines a type constructor and a data constructor
02:04:54 <johnw> or am I wrong?
02:04:59 <merijn> johnw: Yes, afaik
02:05:00 <adnap> So, "value constructor" and "data constructor" are the same thing?
02:05:02 <arkeet> what does  hoogle data  do
02:05:16 <Aetherspawn> I can assume this is invalid advice then.... http://puu.sh/2V9S0/2c5e8d7b83.png
02:05:19 <quchen> adnap: Nooo. They can have the same name though, as in the "Foo" example above.
02:05:19 <johnw> adnap: let me look this up before I spout more nonsense
02:05:32 <arkeet> merijn: hoogle data  seems to do something.
02:05:37 <johnw> http://www.haskell.org/haskellwiki/Constructor
02:05:39 <adnap> quchen: Explain!
02:05:41 <johnw> ^-- that seems to agree with what I just said
02:05:45 <quchen> data FooTypeConstructor a = FooDataConstructor a
02:06:00 <quchen> Eh, pardon
02:06:05 <quchen> data FooTypeConstructor a = FooValueConstructor a
02:06:08 <merijn> adnap: quchen is wrong because he misread
02:06:12 <adnap> Oh
02:06:18 <merijn> quchen: THose are identical
02:06:36 <merijn> i.e. "DataConstructor" and "ValueConstructor" are the same thing
02:06:39 <johnw> yes
02:07:11 <quchen> merijn is right because I misread ;-)
02:07:17 <adnap> Are there any Haskell conventions in the U.S.?
02:07:41 <johnw> value constructor appears exactly once in the Haskell 2010 report, while data constructor occurs innumerable times (and is in the index)
02:08:11 <johnw> i think "value constructor" is just what some people prefer to call data constructors
02:10:29 <quchen> GHC.Tuple has funny code.
02:10:37 --- topic: set to '["lambdabot is sick =(","Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.3 http://v.gd/wie445 ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D ","If Hackage is down,try: http://hdiff.luite.com "]' by adams.freenode.net
02:10:38 --- topic: set to '["lambdabot mystery solved: another threadDelay case","Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.3 http://v.gd/wie445 ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D ","If Hackage is down,try: http://hdiff.luite.com "]' by ChanServ
02:14:53 <merijn> arkeet: hoogle data dumps a bunch of output and then still doesn't manage to find stuff I have installed locally :\
02:15:55 <merijn> hmmm, I seem to have broken hoogle completely now as it doesn't even find id or (.) anymore...
02:16:08 <johnw> merijn: are you on OS X?
02:16:25 <merijn> Yeah
02:16:30 <johnw> i know how to fix you
02:16:39 <merijn> I'm not broken :(
02:16:43 <johnw> well, your hoogle then
02:17:09 <merijn> Do tell
02:17:15 <johnw> looking fro the commit, one sec
02:17:41 <johnw> https://github.com/jwiegley/hoogle/commit/09b3673f0954f1026672d5df09a041d749579dcf
02:18:01 <johnw> for non-cabal-installed stuff (the base libs), you need that fix
02:18:39 <latermuse> my haskell programs tend to deviate towards chaos, requiring me to refactor all the time to just tame the beast
02:19:41 <no-n> write a universe in haskell
02:20:00 <johnw> so, you create entropy instead of order when you code?
02:20:05 <johnw> that might actually be an achievement of some kind
02:20:14 <alexander__b> anyone use syntastic for vim? pls2suggest a checker I can install.
02:20:14 <no-n> :]
02:20:39 <Strigoides> alexander__b: hdevtools?
02:21:04 <johnw> hdevtools is the best
02:21:19 <johnw> it's so fast, it shows me syntax errors before I make them
02:21:20 <alexander__b> hm. looks like it's not in Portage.
02:21:29 <alexander__b> what's the name of the binary?
02:21:38 * hackagebot classy-prelude 0.5.6 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.5.6 (MichaelSnoyman)
02:21:40 * hackagebot classy-prelude-yesod 0.3.0 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.3.0 (MichaelSnoyman)
02:22:02 <merijn> johnw: I find it's pretty slow upon first saving a file, though. That's annoying me a bit
02:22:16 <johnw> yeah, but so is ghc
02:22:19 <hrookie> last question of the night - i gotta hit the hay! suppose i'm reading standard input in a program - how might i go about supporting the backspace key?
02:22:26 <latermuse> newtype Universe a = Universe a (deriving EVERYTHING)
02:23:30 <hrookie> that is, if i'm in a loop reading lines forever. if i hit backspace, it goes all BLAHSDLHSDGWEAAAAHHHRRGGHHHHH on me
02:24:12 <johnw> hrookie: one way is to edit the haskeline library
02:24:19 <latermuse> Prelude > getLine    ->   typingg^?^?^?
02:24:23 <merijn> hrookie: I think you need to tweak your terminal mode to cooked mode? Google for things like "raw terminal" and "cooked terminal" for details
02:24:29 <no-n> isn't htat to do with buffering
02:24:52 <latermuse> ^?^?^?^?^CInterrupted.
02:24:53 <no-n> I think you can fix it with hSetBuffering or something
02:24:54 <merijn> Haskell just mimics the behaviour of C and other languages, so any docs you find should apply
02:25:28 <hrookie> awesome, thanks a bunch, guys!
02:25:35 <hrookie> cheers~
02:25:56 <no-n> wait what
02:26:00 <no-n> did he fix it or what?
02:26:08 <no-n> oh well
02:26:33 <neutrino> hi
02:26:50 <johnw> hi neutrino!
02:27:00 <latermuse> no-n: I assume he did.
02:27:09 <neutrino> hi johnw :)
02:27:15 <no-n> would have been nice to know how, that's all ;)
02:27:22 <neutrino> nice welcome :)
02:27:27 <johnw> yeah, glad to see you
02:27:47 <neutrino> haha nice :)
02:27:50 <neutrino> glad to see you guys too
02:28:01 <neutrino> i always come here first with tough questions :)
02:28:02 <johnw> being doing anything fun in Haskell lately?
02:28:17 <neutrino> well, i've been teaching people at work about haskell, and a bit about scala as well
02:28:43 <neutrino> comparing haskell to scalaz (which is a lib that tries to make scala a functional language)
02:29:23 <neutrino> we're trying to migrate everything to functional languages now so it's a lot of fun
02:29:29 <johnw> nice!
02:29:30 <latermuse> neutrino: you should take notes on how your coworkers learn haskell, then write some articles about how to teach it
02:30:01 <neutrino> hmm, good one
02:30:09 <merijn> johnw: After unregistering and reinstalling with that fix I still get
02:30:22 <merijn> merijn ~ 0$ hoogle getArgs
02:30:23 <merijn> No results found
02:30:26 <johnw> you need to generate your databases
02:30:34 <neutrino> oh database talk
02:30:34 <merijn> I just ran "hoogle data"
02:30:36 <johnw> I run this: https://gist.github.com/5598014
02:30:37 <typoclass> latermuse: good point. somehow i feel teaching haskell is an area that could still be improved. despite all the laudable effort so far
02:30:39 <neutrino> i had a question about db's as well
02:30:42 <neutrino> what do i need to watch out for if i want to choose an sql database connector with which i'll want to do 1000s of concurrent queries in separate threads?
02:30:48 <johnw> that builds a local hoogle for *everything* in hackage
02:30:54 <johnw> delete the "all" if you don't want tha
02:30:55 <johnw> t
02:31:01 <neutrino> are all of them safe against haskell's green threads? or against OS threads?
02:31:02 <johnw> and you'll need to cabal install rehoo
02:31:18 <johnw> neutrino: I recommend persistent
02:31:30 <johnw> we use it at FP complete in a multi-threaded environment with lots of concurrent queries
02:31:34 <neutrino> @hackage persistent
02:31:34 <lambdabot> http://hackage.haskell.org/package/persistent
02:31:43 <latermuse> typoclass: my undergrad was at a teaching university. i have some theories about how to teach FP, but i havent any people to study with me
02:31:47 <neutrino> what db can it connect to?
02:31:50 <johnw> it has an easy to use interface too
02:31:51 <johnw> all of them
02:31:58 <neutrino> oh, how so?
02:32:05 <johnw> it's an "almost ORM layer"
02:32:12 <neutrino> oh ok
02:32:18 <johnw> if you want more raw SQL, use esqueleto, which wraps persistent
02:32:26 <johnw> giving you more direct query capabliities
02:32:37 <neutrino> so i guess persistent uses actual sql connectors as dependencies then?
02:32:48 <neutrino> and does the connection pooling and whatnot
02:32:49 <johnw> yeah, I think there are persistent-* libraries for each connector type
02:32:53 <neutrino> gotcha
02:32:56 <neutrino> let me look it up
02:33:01 <johnw> yesod relies on it
02:33:08 <johnw> so it sees a lot of production use
02:33:14 <neutrino> for one thing though
02:33:17 <neutrino> i can tell you
02:33:47 <neutrino> even mid-weight php developers can start baging out code in functional languages fairly quickly
02:34:01 <merijn> johnw: oh, I think it didn't work because it tries the database in the local dir first, which didn't include everything else >.>
02:34:08 <sigma1409> Haskell _does_ have a very steep learning curve, especially if you try to dive into an actual project, using established libraries. There are lots of little corners that you bump into, with more advanced usage that none of the tutorials or books seem to cover explicitly
02:34:23 <sigma1409> I'm back to reading the typeclassopedia to try and get my head around it :)
02:34:38 <neutrino> we're doing stuff here with a run-up of reading docs online every now and then for a couple months, and within one agile sprint we're productive
02:34:46 <johnw> sigma1409: yes, it's like learning to swim by going from the kiddie pool straight to the deep end
02:34:49 <merijn> johnw: What does rehoo do, btw?
02:35:02 <johnw> merijn: it efficiently combines *many* .hoo databases into a single default.hoo
02:35:04 <neutrino> what it just needs is 1 really good person for maybe 4 people who've never done anything
02:35:08 <johnw> because hoogle will run out of memory if youtryr
02:35:28 <merijn> >.<
02:35:33 <johnw> Neil said he plans to fold rehoo into hoogle itself, but it's not a priority
02:35:45 <johnw> (I work on Hoogle sometimse, hence my closeness to the project :)
02:36:34 <merijn> blah
02:36:44 <merijn> rehoo depends on shelly, which fails to build
02:36:47 <fruitFly> I'm trying to parse out Just using a case expression and use gaurds line 26 http://ideone.com/8zuon2
02:36:53 <sigma1409> johnw: exactly, I understand what all the symbols and functions do, but I have never seen them put together like this before, and some of the syntactic sugar makes their interactions look like magic :)
02:36:56 <johnw> really?
02:37:15 <johnw> sigma1409: I know just how you feel
02:37:18 <typoclass> merijn: we can has output of -v3?
02:37:30 <johnw> I remember when I first saw Haskell, I thought the syntax was horrifically ugly
02:37:37 <johnw> now I realize it's all just window-dressing around the lambda calculus
02:37:44 <merijn> Manually installing just shelly seems to work
02:37:49 <johnw> it's not until you see the simplicity of Haskell, that you understand its complexity
02:37:51 <fruitFly> can I have Maybe String as a result of a function and then pass it to a func that takes a string?
02:38:03 <johnw> merijn: weird
02:38:06 <merijn> fruitFly: Sounds like you want the Maybe monad
02:38:18 <johnw> > Just 10 >>= (+1)
02:38:21 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe b0))
02:38:21 <lambdabot>    arising from a use o...
02:38:25 <fruitFly> merijn: ooh nooo... I haven't gotten to monads yet
02:38:25 <Bor0> lambda calculus is fantastic
02:38:32 <johnw> > (+1) <$> Just 10
02:38:33 <merijn> fruitFly: And/or maybe functor
02:38:34 <lambdabot>   Just 11
02:38:36 <latermuse> fruitfly: nows your chance
02:38:51 <merijn> > fmap (+1) Nothing
02:38:54 <lambdabot>   Nothing
02:38:59 <merijn> > fmap (+1) (Just 3)
02:39:01 <lambdabot>   Just 4
02:39:59 <typoclass> > case (Just 123) of (Just x) -> x + 10
02:40:01 <lambdabot>   133
02:40:38 <latermuse> > Just [1] `mappend` Just [3]
02:40:41 <quchen> fruitFly: You don't need to know about monads to use (>>=) for Maybe. It really is the "put the value of the Just in a function" thing you're looking for.
02:40:42 <lambdabot>   Just [1,3]
02:40:58 <quchen> fruitFly: Assuming you want a Maybe in the end
02:41:22 <typoclass> fruitFly: in principle, you use it this way ^^. on the left side of "->", use "Just", then a name for the "contents" of the Maybe. this name will then be available on the right side of "->"
02:41:49 <latermuse> > map (+3) <$> Just [1] `mappend` Just [3]
02:41:51 <typoclass> fruitFly: does that make sense?
02:41:52 <lambdabot>   Just [4,6]
02:42:02 <fruitFly> typoclass:  quchen Wait 1 sec. Can a function that takes a String take a Just String? ... or no?
02:42:18 <quchen> fruitFly: No, "String" and "Just String" are different types.
02:42:41 <typoclass> fruitFly: not directly, but look at my example that lambdabot evaluated. "x + 10" wouldn't work if x was "Just 123"
02:42:42 <neutrino> johnw is doing important work on crucial haskell infrastructure
02:42:49 <neutrino> aka hoogle :)
02:42:54 <fruitFly> quchen: typoclass  ok so is what above the easiest way to parse out Just? Gonna taker a look at it now.
02:43:05 <neutrino> johnw: when i first saw the haskell syntax, it blew my mind, but i didn't necessarily think it was unesthetic or anything
02:43:16 <neutrino> comparing with scala, i really truly miss the syntax
02:43:18 <latermuse> > map toUpper <$> Just ['a','b','c']
02:43:20 <lambdabot>   Just "ABC"
02:43:35 <neutrino> it was a bit less painful while i was doing python, but scala and php make it very clear
02:43:43 <typoclass> fruitFly: yes, "case ... of" is the most basic way. there's various other stuff, but i suggest you first learn "case" :-)
02:45:19 <fruitFly> typoclass: Ok .. so how then does my function look on line 26? I'm trying to use gaurds in the case as well http://ideone.com/8zuon2
02:45:28 <fruitFly> quchen: ^^
02:46:14 <quchen> fruitFly: You're pattern matching against a type (Word8) here, you can't do that
02:46:22 <latermuse> guards usually require an "otherwise"
02:46:36 <typoclass> fruitFly: first of all "Just [Word8] ->" isn't possible. Word8 is a type, and that is not used on the left side of "->". this is the first problem that i was trying to get at with my example
02:47:46 <fruitFly> typoclass: how is Just [Word 8] not possible? isn't it like Just [Int] ?
02:48:01 <quchen> That's also not possible.
02:48:05 <typoclass> fruitFly: yes it is, but "Just [Int] ->" isn't possible either
02:48:24 <quchen> You can pattern match against "Just x", or "Just []" or "Just [x]".
02:48:41 <typoclass> fruitFly: compare with line 23. that's a well-formed pattern match
02:48:49 <quchen> Matching "Just [Int]" is similar to matching against "Int" - you can only match values, not types.
02:48:59 <quchen> Just creates a value (of type Maybe).
02:49:47 <merijn> fruitFly: I have a feeling you'll have much less trouble if you continue/finish reading LYAH first
02:50:00 <merijn> fruitFly: You seem to have a lot of basic/syntactic problems which are explained in there
02:50:51 <adinapoli_> guys do you know where and if I can read more about the "lamdabot mystery" and the threadDelay thing?
02:51:10 <merijn> adinapoli_: I'm not sure there is anything to read?
02:51:16 <typoclass> fruitFly: also note: in "Just index", "Just x", "Just [x]", the names start with lower-case letters. this means it's a name you're introducing in that line. if you use an upper-case letter, it'll need to be a constructor that was defined in another place, like "Just" or "Nothing". Word8 and Int are not constructors, but types. you can't use them in that place
02:51:17 <johnw> neutrino: I remember complaining to a friend, arete, about Haskell syntax
02:51:36 <merijn> lambdabot's machine is a bit slow, there was a hardcoded timeout, as a result lambdabot would time out instead of responding
02:52:15 <merijn> Remove/increase threadDelay, recompile, mystery solved
02:52:23 <neutrino> johnw: i remember it annoyed me people used variable indent a lot!
02:52:35 <neutrino> luckily that's going away, and i got a bit accustomed too
02:52:59 <fruitFly> quchen: oooh... I see my problem
02:53:00 <johnw> what is variable indent?
02:53:50 <neutrino> let x = verylongfunction ( a,
02:53:58 <neutrino>                        b,
02:54:00 <neutrino>                        c,
02:54:03 <neutrino> something like that.
02:54:10 <neutrino> except a b c line up
02:54:15 <typoclass> neutrino: true! i don't like that as well. i don't use it in my code
02:54:26 <Hafydd> Why is that called variable indent?
02:54:45 <Hafydd> It looks pretty constant to me.
02:54:48 <neutrino> because the indent size varies as opposed to being fixed to the shift width
02:55:04 <Hafydd> Oh, I suppose so.
02:55:12 <typoclass> Hafydd: i don't think it's a pre-defined name, he just called it that adhoc :-)
02:55:24 <Hafydd> Well, I was asking about the ad-hoc reasoning.
02:55:57 <fruitFly> quchen: typoclass ok I removed "Just [Word8] ->" ... how do you think I should parse Just out of the input bytes? Line 26
02:55:57 <fruitFly> http://ideone.com/8zuon2
02:56:43 <typoclass> anyhoo, my rule is if i need to indent more, i use exactly 4 more spaces than the previous line
02:57:37 <typoclass> fruitFly: same way you wrote it in line 23. "Just", followed by a name, followed by "->". on the right side of "->" you can then refer to the name
02:57:43 <quchen> fruitFly: I'm not sure what your function should do. Start by writing the desired type signature! :-)
02:57:53 <typoclass> fruitFly: i think it'll help if you first add a type signature
02:58:03 <typoclass> fruitFly: (above line 26)
02:58:05 <merijn> fruitFly: I stand by my previous observation that should probably read further in LYAH before continuing with writing code
02:58:35 <typoclass> fruitFly: and merijn also has a point :-) have you seen lyah? it's a good book available for free
02:58:37 <typoclass> @where lyah
02:58:38 <lambdabot> http://www.learnyouahaskell.com/
02:58:49 <no-n> > let Just xs = Just [1,2,3] in xs
02:58:51 <lambdabot>   [1,2,3]
02:59:08 <quchen> Just^{-1} :-)
02:59:25 <no-n> quchen: ?
02:59:48 <quchen> Well, that line looks like you're applying the inverse of Just to a list.
02:59:55 <quchen> Plus a smiley.
02:59:57 <no-n> oh, it's superfluous eyah
03:00:16 <no-n> but just to show that pattern matching works thatway
03:00:29 <fruitFly> typoclass: merijn quchen  I get it. I don't even know why I asked. A little stressed guys... I will continue to read lyah. But I want to do some little programs to solidify the most basic knowledge without the whole book being blown over my head.
03:00:42 <fruitFly> despite it being basic
03:01:31 <typoclass> fruitFly: no worries :-) if you're reading lyah and at the same time writing a little code, then you're doing the right thing
03:01:35 <adinapoli_> can you guys suggest me some great haskell paper to read? I know it's a broad question, I was thinking about some kind of "milestone" which should be read by any Haskeller
03:01:56 <typoclass> adinapoli_: anything by wadler and anything by spj? :-)
03:02:47 <typoclass> adinapoli_: there's various sub-pages linked from http://www.haskell.org/haskellwiki/Research_papers
03:04:41 <fruitFly> typoclass: quchen  why do I have a parse error line 26? http://ideone.com/8zuon2
03:07:05 <adinapoli_> you need to either use just the guard at the "top-level" of your function or just use the case.. as far as I know that syntax is not allowed
03:07:36 <typoclass> fruitFly: it'll have to look like "pattern match | condition -> expression". try "Just b | length b `mod` 3 == 2 -> bytes + ..."
03:08:37 <typoclass> fruitFly: (also, right now you're re-using the name bytes. this could get confusing. better use b or bytes' or whatever)
03:08:58 <typoclass> fruitFly: make any sense? or do you want me to edit the paste?
03:09:16 <fruitFly> typoclass: can u edit the paste?
03:10:44 <alexander__b> I did cabal install hdevtools followed by git clone https://github.com/bitc/vim-hdevtools.git -- but "Not an editor command: HdevtoolsType" =(
03:10:59 <typoclass> fruitFly: http://ideone.com/AvWJQM
03:11:38 <typoclass> fruitFly: progress! :-) some new problems. but the parse error is gone
03:13:05 <supki_> alexander__b: do you have hdevtools in PATH?
03:13:08 <merijn> adinapoli_: haskell programming papers or haskell theory papers? Or both?
03:13:11 <fruitFly> typoclass: thanks!
03:13:29 <alexander__b> supki_: nerp
03:13:55 <alexander__b> supki_: I only did cabal install hdevtools as per the README. that didn't get me hdevtools in PATH. =/
03:14:15 <supki_> I think it kinda assumes you have ~/.cabal/bin in PATH
03:14:21 <alexander__b> ah
03:14:26 <alexander__b> ty!
03:14:31 <alexander__b> g2g but I'll try that.
03:14:32 <johnw> neutrino: in other languages we call that endline layout vs. block layout
03:15:06 <johnw> endline layout is bad for several objective reasons, but aesthetically some still prefer it
03:22:37 <fruitFly> typoclass: my hexToBytes function returns Maybe [Word8] ... should I parse the just out in hexToBytes ... or in the new bytesToBase64 function?
03:23:51 <fruitFly> typoclass: aah ok.. the correction you did correctly parses out the Just.. just seeing that.
03:23:54 <fruitFly> Thanks!
03:24:01 <typoclass> fruitFly: it seems like Maybe serves a real purpose in hexToBytes. it tells the caller if the hex was valid or not. so i'd keep it :-)
03:25:14 <fruitFly> typoclass: why wouldn't one parse it out and return Nothing or [Word8] .... what significance is by saying Just [Word] .. i.e. just?
03:26:21 <mauke> you can't return Nothing or [Word8]
03:26:24 <mauke> that would be a type error
03:26:56 <fruitFly> mauke: aah... I see I see ;0... :P
03:27:03 <fruitFly> ;;) *
03:27:04 <fruitFly> lol
03:27:11 <typoclass> fruitFly: a function can only give Nothing if the function is declared "-> Maybe Something"
03:27:28 <fruitFly> typoclass: meaning it would HAVE to return Just
03:27:29 <fruitFly> I get it
03:27:45 <fruitFly> excuse my brain farts sometimes #haskell
03:27:53 <fruitFly> they will diminish
03:27:56 <Hafydd> You can't return Just either.
03:28:14 <fruitFly> Hafydd: Just [Word8]
03:28:26 <Hafydd> Just is not a type constructor.
03:28:45 <mauke> Hafydd: you can't return type constructors
03:29:03 <no-n> @src Maybe
03:29:04 <lambdabot> data Maybe a = Nothing | Just a
03:29:18 <Hafydd> Those statements weren't meant to be connected.
03:32:29 <jtalk> Hi! What does '' (double single quote) mean in Template Haskell? Something like ''Type. I've read through TH wiki, but thing is supposed to be tricky a little. :(
03:36:41 <supki_> jtalk: it quotes type constructor
03:36:46 * hackagebot classy-prelude 0.5.7 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.5.7 (MichaelSnoyman)
03:37:31 <supki_> jtalk: that means you can use Type as a Name in TH
03:39:58 <merijn> johnw: Ugh, merging hoogle databases takes ages and is not very conducive to my machine's responsiveness >.>
03:42:26 <fruitFly> can a function take Just Somethign as a parameter?
03:42:38 <adinapoli> ask yourself, is Just a type?
03:42:48 <adinapoli> @src Maybe
03:42:48 <lambdabot> data Maybe a = Nothing | Just a
03:42:59 <johnw> merijn: for whatever reason, it's an order of magnitude faster with 7.6
03:43:03 <adinapoli> or is a type constructor?
03:43:04 <johnw> but it takes about 54 minutes on my machine
03:43:07 <johnw> (with 7.4.2)
03:43:19 <fruitFly> adinapoli: a typr constructor, right :)
03:44:24 <jtalk> supki_, so, this is just the way to introduce Type into the TH system, and does nothing with the type itself?
03:47:10 <supki_> jtalk: yes
03:47:39 <merijn> johnw: I think it's been on "hoogle combine" for about an hour now. Fingers crossed that it completes soon
03:47:42 <jtalk> supki_, I've just got it then, thank you
03:47:48 <merijn> I'd like to actually do things on my machine >.<
03:49:51 <johnw> merijn: yep, you didn't delete the "all" then? :)
03:49:54 <merijn> I really need to get an employer that buys me a new MacBook with a fancy SSD...
03:49:59 <johnw> at least you don't need to run this often; I do it while I sleep
03:50:09 <merijn> Nope, I figured "how long could it take..."
03:50:19 <johnw> i just got a new SSD, but employer didn't cover it :(
03:50:42 <merijn> Find a new employer ;)
03:50:51 <johnw> heck no!  i love my employer :)
03:51:02 <merijn> But apparently they don't love you enough :p
03:51:17 <johnw> i've send *them* an SSD, for being to code in Haskell this much :)
03:51:22 <johnw> s/i've/'id
03:51:23 <johnw> i'd
03:51:58 <johnw> the only other languages I've even touched in six months have been elisp and bash script, it feels surreal
03:53:37 <merijn> Lucky bastard...
03:53:59 <johnw> you see?  so I don't complain about SSDs :)
03:54:06 <epta> http://haskell98eng.blogspot.ru/
03:54:22 <Taneb> Maybe they're just trying to lull you into a false sense of security, johnw
03:54:26 <johnw> hmm
03:54:39 <johnw> i consent to being lulled by the purity of it all
03:54:57 <Taneb> Once you become the best Haskell programmer in the company, they'll say "Wow! You can do this well in such a weird language? Imagine how well you could do in a normal language, like Java!"
03:55:07 <Hafydd> Hahah.
03:56:50 <johnw> i cringe to think that I worked in java for two years
03:56:53 <johnw> i CRINGE
03:57:13 <johnw> as golem best put it, "It burns us!"
03:57:31 <mauke> ಠ_ಠ
03:57:33 <mauke> gollum
03:57:45 <johnw> only here would I get corrected on that :)
03:57:46 <adinapoli> I'm doing Scala here, but people seems to fall in temptation with the dark Java side of the moon too often :'(
03:58:12 <mauke> johnw: http://en.wikipedia.org/wiki/Golem
03:58:20 <frontendloader> I'd love for haskell to be my go-to language
03:58:21 <johnw> i know, mauke
03:59:34 <johnw> whenever my bash scripts get too long, I use to Pythonize them; now Haskell is actually easier.  the hardest part about many languages is remembering the nauances of their many libraries
04:02:00 * hackagebot hist-pl-types 0.1.0 - Types in the historical dictionary of Polish  http://hackage.haskell.org/package/hist-pl-types-0.1.0 (JakubWaszczuk)
04:02:02 * hackagebot hist-pl-lmf 0.1.0 - LMF parsing for the historical dictionary of Polish  http://hackage.haskell.org/package/hist-pl-lmf-0.1.0 (JakubWaszczuk)
04:06:33 <merijn> bah, syntastic + hdevtools don't let me get back my cursor until type checking finishes... :\
04:07:00 * hackagebot hist-pl-dawg 0.1.0 - A generic, DAWG-based dictionary  http://hackage.haskell.org/package/hist-pl-dawg-0.1.0 (JakubWaszczuk)
04:11:20 <bartavelle> merijn, same experience, quite frustrating
04:11:32 <bartavelle> but you can ctrl-c
04:12:00 * hackagebot hist-pl-lexicon 0.5.0 - A binary representation of the historical dictionary of Polish  http://hackage.haskell.org/package/hist-pl-lexicon-0.5.0 (JakubWaszczuk)
04:12:02 * hackagebot hist-pl-fusion 0.5.0 - Merging historical dictionary with PoliMorf  http://hackage.haskell.org/package/hist-pl-fusion-0.5.0 (JakubWaszczuk)
04:17:00 * hackagebot hist-pl 0.3.0 - Umbrella package for the historical dictionary of Polish  http://hackage.haskell.org/package/hist-pl-0.3.0 (JakubWaszczuk)
04:23:44 <HugoDaniel> is there any tool to indent haskell code ?
04:24:41 <latermuse> HugoDaniel: tab?
04:24:48 <HugoDaniel> :/
04:24:52 <hpc> HugoDaniel: they make this specialty device called a keyboard ;)
04:26:38 <latermuse> HugoDaniel: If you have so many lines of code to tab, you could easily write a macro in vim to do it for you
04:26:42 <HugoDaniel> not being very helpfull
04:26:50 <johnw> he wants a pretty printer utility
04:26:54 <johnw> i've never found one for Haskell
04:27:19 <latermuse> to make source code beautiful?
04:27:22 <latermuse> i need that too
04:27:57 <latermuse> it would probably be pretty difficult to make one, because of the way whitespace is used in haskell
04:28:46 <HugoDaniel> latermuse: vim already has = command
04:28:58 <HugoDaniel> still not very useful in haskell
04:32:01 * hackagebot uu-options 0.1.0.1 - Parse command line options using uu-interleave and uu-parsinglib  http://hackage.haskell.org/package/uu-options-0.1.0.1 (DoaitseSwierstra)
04:33:47 <latermuse> HugoDaniel: check this out: https://github.com/jaspervdj/stylish-haskell/blob/master/README.markdown
04:39:30 <tomejaguar> How do I get ghc to compile one file without it thinking I mean it to me Main
04:39:35 <tomejaguar> *to /be/ Main
04:40:07 <killy9999> I need a translation from Core
04:40:09 <killy9999> GHC.Real.$fIntegralInteger_$cquot
04:40:10 <MasseR> tomejaguar: -c
04:40:38 <killy9999> this referes to quot function from Integral typeclass, instance for Integer type - is that correct?
04:41:03 <Taneb> tomejaguar, make sure in the file it isn;'t called "module Main where"
04:41:03 <tomejaguar> MasseR: still says The function `main' is not defined in module `Main'
04:41:23 <Taneb> Call it something other than Main
04:41:25 <tomejaguar> Taneb: it doesn't have any module .. where
04:41:28 <tomejaguar> perhaps that's the problem ...
04:41:38 <tomejaguar> Ah!
04:41:40 <tomejaguar> Problem solved
04:41:42 <tomejaguar> thanks all
04:41:44 <Taneb> :)
04:41:51 <HugoDaniel> latermuse: yes thats what im looking for, but not only for import and language, thanks :)
04:42:45 <latermuse> HugoDaniel: It was one of the first results when i searched "haskell code prettyfier" in google
04:45:32 <HugoDaniel> yes, well i thought there might be something similar to unix indent or fmt commands but specifically for haskell
04:49:02 <supki_> HugoDaniel: autoindenting haskell code in undecidable
04:49:56 <HugoDaniel> supki_, yes but so is in C, yet the tool exists by allowing a great deal of versatibility
04:50:48 <supki_> I mean different indentation have different semantics
04:51:17 <supki_> and you can't know what user had in mind exactly
04:52:05 <HugoDaniel> true :/
04:57:02 * hackagebot hist-pl-fusion 0.5.1 - Merging historical dictionary with PoliMorf  http://hackage.haskell.org/package/hist-pl-fusion-0.5.1 (JakubWaszczuk)
05:02:09 <killy9999> > :t True
05:02:12 <lambdabot>   <hint>:1:1: parse error on input `:'
05:04:34 <simukis_> :t True
05:04:37 <lambdabot> Bool
05:16:46 <merijn> johnw: After like 2 hours I have 2 failures of rehoo with memory allocation failures :(
05:18:13 <merijn> which means that I still don't have a working commandline hoogle :(
05:22:15 <flebron> If I have a "let...in", should the "l" and the "i" be aligned, or should the "t" and the "e" be aligned?
05:22:28 <flebron> ... "t" and "n". I can spell, I promise.
05:27:42 <Botje> flebron: ghc only looks at the first non-whitespace character.
05:28:04 <Botje> so the i has to be indented at least as much as the l
05:29:01 <mauke> depends on what you mean by "should"
05:29:16 <mauke> as far as ghc is concerned, they don't have to be aligned at all
06:07:48 <flebron> It was more a stylistic concern, both indentations will have "in" be at least as indented (from the left) as "let".
06:10:31 <int-e> edwardk: I've tried to use your interned package for memoizing functions based on interened Ids. As far as I can see, this would require a function mapping Ids back to interned values (which is a crazy idea in general, but safe for memoization). Would you accept a patch implementing such a function, say, unsafeInternId :: Interned t => Id -> t  ?  (I have more complete code of my attempt at memoization here:...
06:10:37 <int-e> ...http://int-e.eu/~bf3/haskell/TermIntern.hs)
06:13:20 <fizbin> > 1 -- You feeling better, lambdabot?
06:13:24 <lambdabot>   1
06:13:37 <fizbin> So, a bit sluggish, but back in the game.
06:15:26 <fizbin> > (\g -> g g) (\f x -> if x < 2 then 1 else f f (x-1) + f f (x-2)) 5
06:15:29 <lambdabot>   Occurs check: cannot construct the infinite type:
06:15:29 <lambdabot>    t0 = t0 -> a1 -> a0
06:18:53 <quchen> Cale: Is there a reason :t doesn't work in private sessions? @type etc. are fine
06:24:15 <int-e> edwardk: Oh. Looking more closely it's not possible to implement such a function with the existing data structure. never mind then :/
06:26:54 <Scabe> Say I have a tree with many paths. Is there a way just to the return all the paths that give me the maximum values?
06:30:17 <ramses_> Scabe: sure :) You'll have to decide how to represent paths and then calculate the list of all those paths
06:30:18 <Peaker> Scabe, shouldn't there be just one path of maximum value?
06:30:52 <tdammers> Scabe: either brute force it (for every leaf, there is exactly one path, so enumerate the leaves, find the paths, sort by value, take first)
06:31:05 <tdammers> or use Dijkstra's algorithm
06:32:41 <osa1> is there a special name given to that kind of tree traversals: http://hpaste.org/88094 ?
06:32:44 <Scabe> hmm that's kinda helpful
06:33:20 <mauke> osa1: Branch is redundant
06:33:28 <osa1> right
06:35:43 <osa1> so is there a special name to this traversal?
06:45:40 <pastorius> Hi! Has anyone used acid-state for a real project? I'm wondering if it would fit the needs of a website for the company I work for...
06:46:44 <merijn> pastorius: The answers are respectively: Most probably yes & It depends
06:46:59 <Peaker> pretty annoying to have to choose between losing named record initialization and having Applicative rather than Monad constraint
06:47:41 <Peaker> hmm, I guess I have to give intermediate names with a Monad too, might as well do the same with Applicative
06:47:46 <merijn> pastorius: Do you have a more specific question about what you need?
06:48:50 <pastorius> merijin: thanks. I have only played around with acid-state, so I'm wondering if it is mature enough for corporate level development
06:49:33 <pastorius> Say, comparing to a more traditional persistence system.
06:49:48 <merijn> pastorius: Well, I would base a six 9s uptime system on it, but I think it should be fine. It kinda depends on how much data and how you plan to use it
06:49:51 <merijn> eh
06:49:55 <merijn> *wouldn't
06:51:33 <pastorius> merijin: ok, thanks for your insight
06:52:21 <pastorius> What would you base a six 9s system on, then?
06:53:05 <merijn> No clue, I'm not in the business of building those xD
06:54:27 <mm_freak> merijn: did you check out how wire combinators are defined?
06:54:41 <mm_freak> you can use stepWire internally, if you're a bit careful
06:54:43 <pastorius> With acid-state you can probably build a system that uses redundancy to avoid downtime, can't you?
06:55:19 <mm_freak> merijn: you need to be careful when it may happen that you don't step an inner wire…  to accumulate time
06:56:00 <merijn> mm_freak: Yeah, I think I might have figured out a more sensible approach
06:56:31 <merijn> mm_freak: Does this make sense? http://hpaste.org/88095
06:58:32 <mm_freak> merijn: yes, makes sense, but it keep in mind that it's not categorically sound
06:58:49 <merijn> Why not?
06:59:10 <mm_freak> because you can't express it in terms of a monad morphism
06:59:40 <merijn> My category theorese is not good enough to understand that
07:00:17 <mm_freak> mapWire :: (Monad m', Monad m) =>  (forall a. m' a -> m a) -> Wire e m' a b -> Wire e m a b
07:00:38 <mm_freak> where the function argument is a proper natural transformation
07:00:55 <mm_freak> if yes, then it's covered by category theory
07:01:26 <mm_freak> unfortunately you don't do that /and/ keep the state =)
07:01:34 <mm_freak> don't → can't
07:02:13 <merijn> I don't think it's possible to define a sensible UI without being able to hide the internal state
07:03:51 <mm_freak> merijn: i'm not sure…  the current netwire's facilities are limited there
07:04:05 <merijn> Where is mapWire defined? Or does it not exist yet
07:04:11 <mm_freak> it doesn't exist yet
07:04:40 <mm_freak> don't bother, because you can't express the combinator in terms of mapWire
07:05:03 <merijn> Oh, I no. I was just wondering if there was no way to fit mapWire and something like this
07:05:08 <merijn> I know, even
07:05:18 <merijn> And I need code to follow my reasoning :p
07:06:15 <merijn> Having the state exposed in the monad type means you can't compose widgets with different internal state :\
07:06:43 <Sculptor> yo
07:06:50 <merijn> How come this is problematic whereas mkStateM isn't?
07:07:39 <Peaker> merijn, in lamdu we have a sensible UI, indeed it hides the internal state, but inside pure function closures, no mutability or such
07:07:40 <mm_freak> merijn: well, you can't write a proper natural transformation from StateT s m to m without giving up the state
07:07:44 <mm_freak> merijn: forall m that is
07:08:07 <merijn> Peaker: hmm, I should look at lamdu, I keep forgetting that :p
07:08:18 <merijn> Peaker: Do you have a non-sucky UI? :p
07:08:24 <mm_freak> merijn: how about defining widgets as wires in the first place?
07:08:31 <mm_freak> i mean why do you need WidgetT at all?
07:08:45 <mm_freak> Wire is precisely for locally stateful computations
07:09:02 <Peaker> merijn, the UI is not comprehensive.. no mouse support, no clipboard integration, no text selections, etc. Just the very basics, but already enough for the toy usability that we need, and we believe it is extensible to support all those things within the same paradigm we chose
07:09:10 <Peaker> merijn, (we're just focusing on other stuff atm)
07:09:13 <merijn> mm_freak: Because after like a month of meditating on netwire I still can't figure out what the hell I'm doing :p
07:09:23 <mm_freak> hehe
07:09:36 <mm_freak> but you already discovered mkState and mkStateP
07:09:46 <mm_freak> they are completely identical to mkGen und mkPure
07:10:00 <mm_freak> it's just a different perspective on the same thing
07:10:23 <mm_freak> data Wire' e m a b = forall s. Wire' s ((a, s) -> m (Either e b, s))
07:10:35 <merijn> The reason to not use wires directly is because I can't figure out a nice way to compose UIs that way
07:10:42 <mm_freak> newtype Wire e m a b = Wire (a -> m (Either e b, Wire e m a b))
07:10:51 <merijn> They're fine for composing interaction, but interaction and layout are orthogonal
07:10:55 <mm_freak> those two types are isomorphic, and mkState* are basically just a mapping from Wire' to Wire
07:11:24 <merijn> How are they isomorphic? s is not a Wire?
07:11:31 <mm_freak> your problem isn't composition, you're problem is Alternative, because it takes only one path
07:11:38 <merijn> Not just that
07:11:52 <mm_freak> well, think about it:  Wire' gives you "the next state to call with the given function"
07:11:55 <merijn> How do I define layouts with Wires?
07:11:58 <mm_freak> Wire gives you "the next wire to call"
07:12:19 <mm_freak> well, say you want a box model with horizontal and vertical composition
07:12:32 <mm_freak> (Layout b) => Wire e m a b
07:12:50 <mm_freak> where Layout is Monoid + an additional associative operation with the same identity
07:12:50 <merijn> Except that I might want Widgets to output events that are not layouts...
07:13:21 <mm_freak> w1 <> w2 = horizontal composition
07:13:27 <mm_freak> w1 <-> w2 = vertical composition
07:13:33 <mm_freak> because if b is a Layout, then so is Wire e m a b
07:13:45 <merijn> Say I press a button with a given Widget focussed, that generates an event for that widget to output
07:13:59 <mm_freak> to "output"?
07:14:13 <merijn> Widgets have an effect on eachother
07:14:30 <mm_freak> yes, that effect is covered by Category and Applicative, no?
07:14:32 <merijn> If I send a button to a selection list, I might want to update other widgets based on that change
07:14:53 <Chousuke> it kind of sounds like you'd be conflating layout of widgets with their connections
07:15:01 <mm_freak> right
07:15:05 <mm_freak> but you can do that
07:15:08 <merijn> Chousuke: Yes, that's exactly the problem I'm trying to figure out
07:15:30 <merijn> mm_freak: How? It just doesn't make any sense to me, and afaik there's no one with any sort of example of that
07:15:43 <mm_freak> merijn: let's say you have two text fields and a label to display their sum
07:15:59 <merijn> Every time I think about the "just make a Widget a wire" thing I just get hopelessly lost with how that would work...
07:16:00 <mm_freak> label . liftA2 (+) text1 text2
07:16:06 <mm_freak> does that make sense?
07:16:18 <merijn> No, because how do you determine the layout based on that?
07:16:54 <merijn> What if text1 and text2 are in completely separate parts of the UI?
07:17:11 <mm_freak> depends…  you can either have an underlying LayoutWriter to capture the layout
07:17:21 <mm_freak> or you can use arrow style
07:17:31 <merijn> I want to define layout and interaction separately, not together
07:17:41 <mm_freak> then that's even easier
07:17:43 <merijn> If you do it together it becomes a horrible spaghetti mess of nonsense
07:19:04 <merijn> If it's easy, then why can I still not see how it would work?
07:19:26 <mm_freak> type UI e m a b = Wire e m a (Widget b)
07:19:34 <mm_freak> where Widget may be an applicative + comonad
07:20:01 <mm_freak> then you first describe what widgets there are in the system
07:20:37 <scooty-puff> i have a few type functions expressed as type synonyms, type Field1 a = Find N0 (ToList a), etc., where the implementation of Find, N0, ToList, etc., is not exposed (not exported, not in haddock, etc.) - what is anyones opinion on exposing type synonyms, but not exposing what its a synonym for?  is it possible to have opaque type functions?
07:20:53 <mm_freak> (t1, t2) <- text &&& text -< ();  l <- label -< (extract t1 + extract t2)
07:20:58 <mm_freak> finally you return the layout
07:21:09 <mm_freak> id -< t1 <> t2 <-> l
07:22:11 <mm_freak> merijn: ideally Widget is a Comonad, and if the user enters an invalid string, 'text' just inhibits
07:24:45 <merijn> Sometimes I feel I should just become a farmer or something...
07:26:33 <pastorius> Lol, that's similar to what I thought by just reading the conversation…
07:26:52 <mm_freak> merijn: i think the current netwire is just too complicated for library developers
07:27:45 <Chousuke> Elm's flavour of FRP is the only one I've been able to understand so far
07:27:47 <merijn> I'm not sure whether it's netwire or just FRP itself
07:28:03 <Chousuke> I also like the way Elm does layouting
07:28:14 <merijn> I mean, all the types/functions in netwire make sense to me, I just have no clue how to put them together into anything useful
07:28:47 <merijn> I'm also not really sure where tangible values would fit into my mental picture
07:29:31 <mm_freak> well, there are different approaches to FRP
07:29:45 <mm_freak> the AFRP model is really just composable stateful components
07:30:35 <enthropy> scooty-puff: type errors involving Field1 might involve  Data.Data.Something.Find Data.Data.Something.N0 (Data.Data.Something.ToList a)  instead of the way shorter Field1 a
07:31:19 <Chousuke> so the way I see it you'd have wires of widgets, and those wires go together to form the data flow, and then you have separate functions for combining the actual widgets to produce layouts?
07:31:33 <mm_freak> merijn: let me give you a guideline:  the underlying monad should always follow this law:  liftA2 (flip f) = flip (liftA2 f)
07:31:44 <mm_freak> examples:  Reader and Writer
07:31:57 <mm_freak> counterexamples:  IO, State, …
07:32:16 <dmwit> Writer, really?
07:32:21 <mm_freak> well, for Writer only if the underlying monoid is commutative
07:32:27 <dmwit> ok =)
07:32:36 <mm_freak> sorry =)
07:32:48 <mm_freak> i think i can relax the law slightly, but i'm not sure how to formalize it
07:32:53 <mm_freak> because Writer is fine in general
07:34:35 <dmwit> Is [] okay?
07:34:47 <merijn> Chousuke: That's the idea I had, yeah
07:35:14 <enthropy> > (liftA2 (,) "ab" "cd", liftA2 (flip(,)) "cd" "ab")
07:35:21 <lambdabot>   ([('a','c'),('a','d'),('b','c'),('b','d')],[('a','c'),('b','c'),('a','d'),(...
07:35:24 <dmwit> Would Set be okay if we had a suitable constrained monad?
07:36:06 <dmwit> Well, I guess Set is a stupid question because it's obviously okay. It even satisfies the law.
07:36:18 <dmwit> So I'll stick with [] as my real question.
07:36:41 <mm_freak> dmwit: i guess [] is okay
07:36:52 <dmwit> interesting
07:36:54 <enthropy> how can it be the same thing if the entries in the list come out in a different order?
07:37:16 <mm_freak> wasn't there a notion of "affine" monads?
07:37:25 <dmwit> enthropy: mm_freak has some weaker law in mind that he is trying to work out how to state.
07:37:42 <dmwit> enthropy: ...and which I am trying to guess. =)
07:38:08 <mm_freak> liftA2 (flip f) = flip (liftA2 f) looks a lot like linearity
07:38:53 * enthropy squints until everything looks like everything
07:39:56 <mm_freak> well, i'm off and will think about it on my way =)
07:40:07 * dmwit . o O ( just look at the proofs you've done and write down the exact reasoning steps you used that Monad doesn't give you )
07:40:24 <merijn> I think mm_freak is responsible for more hemoraghing in my brain than anyone else :p
07:40:45 <dmwit> This is a bit tongue-in-cheek since the first step of this process is "formalize everything in Coq". =P
07:42:07 * hackagebot numeric-prelude 0.4 - An experimental alternative hierarchy of numeric type classes  http://hackage.haskell.org/package/numeric-prelude-0.4 (HenningThielemann)
07:42:30 <dmwit> merijn: By the way, your discussion of separating layout and behavior reminded me of ftp://131.174.16.163/pub/Clean/papers/2004/eves2004-FFormsCompRefs.pdf which you might like.
07:44:56 <merijn> Or I might not :p
07:45:14 <dmwit> correct
07:45:20 <merijn> I don't want to solve this problem, I just want to write some nice prototypes, but all UI frameworks I've tried so far suck balls >.<
07:46:19 * dmwit shrugs apathetically
07:46:48 <scooty-puff> enthropy: that would be a problem - and even were it opaque, it could prob be explored with :kind!
07:52:07 * hackagebot numeric-prelude 0.4.0.1 - An experimental alternative hierarchy of numeric type classes  http://hackage.haskell.org/package/numeric-prelude-0.4.0.1 (HenningThielemann)
07:52:09 * hackagebot sample-frame-np 0.0.3.1 - Orphan instances for types from sample-frame and numericprelude  http://hackage.haskell.org/package/sample-frame-np-0.0.3.1 (HenningThielemann)
07:58:05 <mekeor> say i have a project including the modules Foo.Bar.Something and Foo.Anotherthing.  is Foo.Bar.Something not allowed/able to import Foo.Anotherthing?
07:58:17 <merijn> mekeor: It is
07:58:43 <mekeor> merijn: should it work with "import Foo.Anotherthing" ?
07:58:54 <merijn> Yup
07:59:06 <mekeor> oh, yeah, right :D it works :D
08:28:36 <Scabe> Does anyone know how to sort Rose Trees?
08:29:55 <simpson> Scabe: Using Data.Tree?
08:31:03 <dmwit> What does "sort" mean here?
08:32:01 <arnsholt> At a guess, pre- or post-order enumeration of the nodes in the tree
08:32:31 <arnsholt> Depends on what Scabe needs to do, I guess
08:33:26 <Zeev> how to print an integer with putStrLn?
08:33:33 <dmwit> Use print instead.
08:33:41 <dmwit> ?src print
08:33:41 <lambdabot> print x = putStrLn (show x)
08:33:55 <Zeev> Ay
08:34:12 <Scabe> I'll paste a code up soon
08:36:16 <Scabe> http://hpaste.org/88099 Here's my code
08:36:24 <Scabe> I think this could be a way to sort Rose Trees
08:36:31 <Scabe> But I don't know how to fix an instance problem
08:37:26 <dmwit> Perhaps you would like to add "Ord" to your deriving line.
08:39:07 <Scabe> dmwit: I tried that and I still get the error No instance for (Ord a)arising from a use of 'sorts'
08:39:29 <dmwit> Perhaps you would also like to add Ord a to the context of your types.
08:39:39 <dmwit> e.g. sort_rose_tree :: Ord a => Rose_Tree a -> Rose_Tree a
08:39:44 <dmwit> and similarly for sorts
08:39:56 <Scabe> Okay will try that
08:40:17 <Scabe> wow
08:40:18 <Scabe> works
08:40:21 <Scabe> Thanks so much
08:46:44 <Ghoul_> I just deleted my cabal directory
08:46:52 <Ghoul_> I wonder if that was a good way to solve dependency hell...
08:47:08 * hackagebot swish 0.9.0.2 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.9.0.2 (DouglasBurke)
08:48:06 <chrisbuchholz> Are there any haskell, or simply functional programming, podcasts out there?
08:48:13 <chrisbuchholz> ...any good ones, that is
08:48:27 <supki_> Ghoul_: no, you should delete ~/.ghc too
08:49:10 <supki_> Ghoul_: actually you should delete ~/.ghc and whether you delete ~/.cabal or not is not so important
08:50:16 <Ghoul_> On windows
08:50:26 <Ghoul_> but yeah, just found about .ghc and deleted it too :)
08:50:26 <Ghoul_> thanks
08:50:38 <merijn> chrisbuchholz: Podcasts specifically or would just talks/presentations work too?
08:50:45 <Ghoul_> I'll go take a shower while cabal install cabal-install runs
08:50:51 <Ghoul_> and hopefully it wont blow up my computer or something
08:52:09 * hackagebot llvm-extra 0.4.1 - Utility functions for the llvm interface  http://hackage.haskell.org/package/llvm-extra-0.4.1 (HenningThielemann)
08:52:10 * hackagebot wordsetdiff 0.0.3.1 - Compare two files as sets of N-tuples of words.  http://hackage.haskell.org/package/wordsetdiff-0.0.3.1 (RyanNewton)
08:53:27 <benmachine> http://stackoverflow.com/a/16447511/812053 I'm arguing in the comments of this answer with someone about Turing-completeness; I reckon what he's just said is untrue but I lack the background to be sure, can anyone offer an opinion?
08:58:05 <Ankhers> benmachine: If you don't really have knowledge of a subject, is it really wise to argue with someone about that subject?
09:00:41 <benmachine> Ankhers: I do have knowledge, but it's not complete; I think he's bringing up things that are irrelevant but to be completely fair I can't claim that without knowing in-depth about all the things
09:01:12 <chrisbuchholz> merijn: podcasts :)
09:01:39 <k00mi> benmachine: what he says sounds right to me, especially his last comment
09:02:12 <Peaker> I find this useful, but have never seen it outside my own code: Reader r (Reader r a -> a)
09:02:24 <benmachine> k00mi: so there are two claims here, one is that applicative parsers can only parse CFGs
09:02:50 <benmachine> k00mi: I think this is "almost true" but there's a trick involving non-strictness that actually makes it false
09:03:20 <benmachine> k00mi: even that aside, I'm pretty sure that parsing CSGs is not the same as being Turing-complete; Wikipedia says CSGs are parsed by bounded automata
09:03:47 <Ghoul_> What about a self recursive ReaderT :o
09:04:19 <Peaker> benmachine, Applicative parsers need some kind of "fix" combinator to parse even CFG's, don't they?
09:04:46 <benmachine> Peaker: that is not what I'd heard!
09:04:50 <k00mi> benmachine: you could be right about the laziness trick, I just found http://byorgey.wordpress.com/2012/01/05/parsing-context-sensitive-languages-with-applicative/
09:04:51 <benmachine> but shrug
09:04:53 <Peaker> (unless you allow an infinite parser structure, but that defeats the purpose of an Applicative parser)
09:05:08 <merijn> Peaker: blah, I installed FTGL and now lamdu/ghc disagree on the type of library I want >.<
09:05:20 <Peaker> merijn, the type of library? what do you mean?
09:05:26 <Peaker> merijn, you mean version?
09:06:47 <merijn> Peaker: architecture, I'm guessing
09:07:02 <merijn> can't load .so/.DLL for: /opt/local/lib/libftgl.dylib (dlopen(/opt/local/lib/libftgl.dylib, 9): no suitable image found.  Did find: /opt/local/lib/libftgl.dylib: mach-o, but wrong architecture)
09:07:06 <merijn> pffft
09:07:10 <merijn> Now I need to rebuild it >.<
09:08:16 <Peaker> merijn, OS X?
09:09:11 <k00mi> benmachine: I don't think that changes much, though I'm out of my water here
09:09:35 <merijn> Peaker: yeah, I guess I need to specify universal build in macports
09:09:41 <k00mi> benmachine: but he' right that a context-sensitive language is equivalent to turing complete: http://en.wikipedia.org/wiki/Context-sensitive_language
09:10:33 <benmachine> k00mi: that article says linear-bounded TM, that's not fully-general
09:10:47 <benmachine> k00mi: unless I'm missing something
09:11:50 <mzero> Woooot! #bayhac '13 starts in six hours!
09:14:02 <dmwit> Regex can parse context-sensitive grammars if you allow them to be infinite.
09:14:30 <k00mi> benmachine: I probably don't know any more than you, but to me it makes sense that "can depend on previous results" means turing-complete
09:16:22 <ntelford> hi everyone :)
09:16:54 <mekeor> hi ntelford :)
09:17:04 <ntelford> if I have a do-loop thats creating an IO [[String]]; what's the idiomatic way to turn that in to a IO [String]?
09:17:19 <ntelford> atm, I'm just doing: join $ do ... return x
09:17:55 <ntelford> where "x" is a [String]
09:18:07 <mekeor> (ntelford: it's not a "do-loop". it's a do-notation (or -expression?)...)
09:18:23 <c_wraith> :t fmap concat -- ntelford
09:18:25 <lambdabot> Functor f => f [[a]] -> f [a]
09:18:45 <c_wraith> assuming you wanted to concatenate the lists, anyway
09:18:47 <mekeor> c_wraith: would liftM be better? O.o
09:19:03 <mekeor> well, okay, we know it's IO, not any monad, so yeah it doesn't matter
09:19:04 <c_wraith> mekeor: doesn't matter when it's concretely IO, and fmap is a much prettier name
09:19:33 <mekeor> c_wraith: map would be prettier though :P :) -- <$> is nice also :]
09:19:37 <raid> i'm wondering why a lot of haskellers prefer foldr over foldl and foldl1. even when an accumulator isnt really needed. is there a good reason?
09:19:49 <ntelford> :t fmap ++
09:19:51 <lambdabot> parse error (possibly incorrect indentation)
09:19:54 <ntelford> bah
09:19:54 <Fuuzetsu> Read the Wiki article about folds, raid
09:19:57 <ntelford> thought that would work :
09:19:59 <ntelford> :)
09:20:00 <c_wraith> raid: foldr can be lazy.
09:20:05 <mekeor> :t fmap concat
09:20:07 <lambdabot> Functor f => f [[a]] -> f [a]
09:20:58 <ntelford> thanks guys - I prefer "fmap concat" over "join" as it makes the intent much clearer
09:20:58 <c_wraith> raid: writing functions that use as little of their input as necessary is generally considered good.
09:21:28 <mekeor> :t join
09:21:32 <lambdabot> Monad m => m (m a) -> m a
09:21:42 <c_wraith> concat is just a specialization of join
09:21:55 <c_wraith> > join ["foo", "bar"]
09:21:58 <lambdabot>   "foobar"
09:21:59 <ntelford> for Lists, join = fmap concat, right?
09:22:04 <Peaker> raid, foldr matches the list form, it's called the "catamorphism" of a list.  foldl isn't similar to the list form, so requires evaluating the whole list to get any result, even if the operation is lazy and only part of the result is needed
09:22:06 <mekeor> no
09:22:20 <c_wraith> > concat ["foo", "bar"]
09:22:21 <mekeor> ntelford: for lists, concat = join
09:22:22 <lambdabot>   "foobar"
09:22:33 <ntelford> oh, of course
09:22:47 <c_wraith> the fmap is just to get them to operate inside IO
09:22:57 <mekeor> ntelford: you can either do "fmap concat listOfListsOfStrings" or "fmap join listOfListsOfStrings"
09:22:58 <ntelford> yes, I see
09:23:18 <Peaker> > foldr f x [a,b,c]
09:23:20 <lambdabot>   f a (f b (f c x))
09:23:20 <Peaker> > foldl f x [a,b,c]
09:23:22 <lambdabot>   f (f (f x a) b) c
09:23:28 <mekeor> ntelford: you could also do "concat <$> listOfListsOfStrings" or "liftM concat listOfListsOfStrings" :) :D
09:23:34 <ntelford> I see now, my solution was wrong as I was doing the join on the IO, not on the [[String]] within
09:23:51 <mekeor> ntelford: exactly
09:24:02 <quchen> raid: What Peaker means with "matching list form" can be pictured as "foldr f z replaces every (:) with f, and [] with z in a list". For foldl, there's no such immediate analogy.
09:24:03 <Peaker> raid, in the first form (foldr), if "f" does not evaluate its second argument, we only look at "a" in the list.   In the second (foldl), we have to look at "c" for the first(outer-most) application of "f", meaning we had to eat the whole list
09:24:18 <ntelford> applicative style still scares me a little
09:24:43 <ntelford> just not something I've developed an intuition for yet - just about got an intuition for Monads and do-notation
09:25:13 <mekeor> ntelford: it's not really applicative style actually
09:25:26 <mekeor> ntelford: <*> is "applicative style" ;)
09:25:40 <Peaker> ntelford, do you understand the difference between the Applicative class and the Monad class?
09:25:54 <mzero> :t intercalate
09:26:00 <lambdabot> [a] -> [[a]] -> [a]
09:26:08 <mekeor> ntelford: so, you could also do "return concat <*> monadicListOfListsOfStrings", i think
09:26:16 <mzero> ntelford: you might like to know about that function, too….
09:26:32 <mzero> since one often wants to put a little somethin' between those strings!
09:26:34 <mekeor> :t let foo = return [[]] :: IO [[String]] in return concat <*> foo
09:26:37 <lambdabot> IO [String]
09:26:47 <quchen> raid: If it helps, here's a graphical version of both folds: http://codepad.org/YQvnlKaE -- Note how foldl seems to turn the list inside out
09:26:54 <mzero> and also, unlines and unwords, as well!
09:27:11 * hackagebot synthesizer-core 0.6 - Audio signal processing coded in Haskell: Low level part  http://hackage.haskell.org/package/synthesizer-core-0.6 (HenningThielemann)
09:27:16 <quchen> raid: Ignore the "mirror image" thing, I have no idea why I put that there :s
09:27:29 <mzero> these three might be preferred if you are including the separators in the body of the do
09:28:49 <stepkut> is it bad to call 'withSocketsDo' more than once on windows?
09:29:10 <magicman> http://foldr.com http://foldl.com :P
09:29:50 <quchen> :-)
09:29:59 <Peaker> I wonder who pays the bills for those 2 sites :)
09:30:39 <stepkut> Oliver Steele perhaps
09:31:45 <HugoDaniel> how can i write this better: map fromJust $ filter isJust $ map fromJust $ filter isJust lst  ?
09:32:10 <bitonic> HugoDaniel: [x | Just (Just x) <- xs]
09:32:36 <mekeor> wow
09:32:51 <HugoDaniel> oh cool, what if instead of a list i have a sequence ?
09:32:58 <k00mi> also as catMaybes in Data.Maybe
09:32:59 <elliott> HugoDaniel: catMaybes . catMaybes
09:33:14 <elliott> I think Data.Foldable has a catMaybes that works on Seq?
09:33:16 <bitonic> HugoDaniel: you can write a function like that on any Foldable
09:33:25 <bitonic> ninja’d
09:33:31 <HugoDaniel> :D
09:33:33 <magicman> Hrm. Really?
09:33:34 <elliott> er, not Foldable
09:33:39 <HugoDaniel> ah yes great, i forgot to check the foldable
09:33:39 <elliott> I meant Traversable. but actually it isn't possible.
09:33:59 <bitonic> lol yeah.  we were equally wrong.  you lack the ‘buildup’ operation
09:34:16 <HugoDaniel> hmm
09:34:24 <HugoDaniel> so in a sequence whats the best way to write this ?
09:34:27 <chrisbuchholz> merijn: i guess your silence mean you dont know any podcasts? What about some good presentations, screencasts or something? Like something really awesome?
09:34:29 <magicman> Well... foldable could work. For any monoid <_<
09:34:31 <bitonic> HugoDaniel: Foldable + Monoid
09:35:14 <merijn> chrisbuchholz: That + distraction from work :p
09:35:49 <magicman> Wait. No. Pointed monoid.
09:35:50 <merijn> chrisbuchholz: Rich Hickey (the Clojure guy) has a bunch of interesting talks, so does Erik Meijer. More haskell specific, edwardk's lens talk on youtube is really good
09:36:17 <merijn> There was also a talk on programming with generics I saw recently
09:37:02 <chrisbuchholz> merijn: yeah i have been watching erik meijers class on channel9
09:37:11 * hackagebot synthesizer-dimensional 0.7 - Audio signal processing with static physical dimensions  http://hackage.haskell.org/package/synthesizer-dimensional-0.7 (HenningThielemann)
09:38:17 <HugoDaniel> bitonic: yes but i would still need that number of passes ? or can they be avoided ?
09:39:31 <bitonic> HugoDaniel: actually I was thinking that Monoid is not enough—you lack the ‘consing’, maybe Monoid and Monad
09:39:32 <chrisbuchholz> merijn: thanks
09:39:38 <bitonic> Monoid and Applicative
09:39:53 <magicman> Yeah, you need an (a -> f a) operation.
09:40:00 <Peaker> Monoid + Applicative = Alternative ?
09:40:05 <bitonic> HugoDaniel: well, if you can write ‘catMaybes’ you can probably write a ‘cat2Maybes’ :)
09:40:18 <magicman> Strictly speaking, you don't need (<*>).
09:40:37 <bitonic> Alternative sounds good
09:40:50 <magicman> (Foldable f, Alternative g) => f (Maybe a) -> g a is what I'm coming up with.
09:41:26 <magicman> Except not really, as Alternative does not imply Monoid, afaik.
09:41:34 <bitonic> @ty Data.Foldable.foldr (\x xs -> maybe xs (<|> xs) (pure <$> x))
09:41:36 <lambdabot> (Foldable t, Alternative f) => f a -> t (Maybe a) -> f a
09:41:57 <bitonic> uhm.
09:42:00 <magicman> Ah, right. I was doing the foldMap thing.
09:42:11 * hackagebot synthesizer-midi 0.6 - Render audio signals from MIDI files or realtime messages  http://hackage.haskell.org/package/synthesizer-midi-0.6 (HenningThielemann)
09:42:25 <HugoDaniel> ok, ill just do two filters and fmaps instead then :)
09:42:41 <bitonic> HugoDaniel: that’s even more general, you go from any Foldable to any Alternative
09:42:55 <magicman> @ty Data.Foldable.foldr (\x xs -> maybe empty pure x <|> xs)
09:42:58 <lambdabot> (Foldable t, Alternative f) => f a -> t (Maybe a) -> f a
09:43:13 <magicman> Oh, right. Add another empty to that.
09:43:18 <bitonic> yes :P
09:43:30 <bitonic> @ty Data.Foldable.foldr (\x xs -> maybe xs (<|> xs) (pure <$> x)) empty
09:43:33 <lambdabot> (Foldable t, Alternative f) => t (Maybe a) -> f a
09:43:53 <bitonic> I guess magicman’s nicer
09:44:00 <magicman> What is the rationale of maybe xs (<|> xs) (pure <$> x) versus maybe empty pure x <|> xs?
09:44:10 <bitonic> magicman: no rationale, it came out like that for some reason
09:44:16 <magicman> Fair enough!
09:45:03 <benzrf> hey, I've been trying to get a better grip on instances and typeclasses, so I tried this, which doesn't work:
09:45:06 <benzrf> instance Show (Num a, Num b, Num c => a -> b -> c) where show fn = "Binary function: 5, 5 -> " ++ (show $ fn 5 5)
09:45:08 <bitonic> @ty Data.Foldable.foldr (\x xs -> maybe empty pure (join x) <|> xs)
09:45:13 <benzrf> does this show a fundamental lack of understanding
09:45:14 <lambdabot> (Foldable t, Alternative f) => f a -> t (Maybe (Maybe a)) -> f a
09:45:20 <bitonic> @ty Data.Foldable.foldr (\x xs -> maybe empty pure (join x) <|> xs) empty -- HugoDaniel
09:45:26 <lambdabot> (Foldable t, Alternative f) => t (Maybe (Maybe a)) -> f a
09:45:31 <bitonic> that’s your function
09:46:23 <benzrf> sorry, that should be Show c and not NUm c
09:46:28 <benzrf> ah, never mind
09:48:10 <quchen> And gone he is. Little impatient :s
09:48:26 <bitonic> the good ’ol Show for functions
09:49:45 <simpson> @tell benzrf instance (Num a, Num b, Num c) => Show (a -> b -> c) where ...
09:49:45 <lambdabot> Consider it noted.
09:50:09 <quchen> simpson: + Show c
09:50:20 <simpson> quchen: Ah, good point.
09:50:33 <simpson> @tell benzrf instance (Num a, Num b, Num c, Show c) => Show (a -> b -> c) where ...
09:50:33 <lambdabot> Consider it noted.
09:51:12 <magicman> And not necessarily Num c </nitpick>
09:51:51 <simpson> magicman: Indeed!
09:52:00 <alexander__b> http://pastebin.com/CutTrXnT I completely fail to see the point of Left/Right. can someone explain them using that example?
09:52:02 <mauke> The paste CutTrXnT has been copied to http://hpaste.org/88103
09:52:57 <Fuuzetsu> alexander__b: Left and Right are just like Just and Nothing except with Left being able to store a value
09:53:06 <Fuuzetsu> so instead of Nothing, you could for example store an error message in it
09:53:24 <Fuuzetsu> oh, which is exactly what the snippet you posted is doing
09:53:59 <Chousuke> Maybe a is like Either () a
09:54:21 <Chousuke> the only Left value of that type is Left (), which corresponds to Nothing
09:54:45 <alexander__b> Fuuzetsu: ohh. thanks.
09:56:06 <alexander__b> I wonder if I will ever grok haskell to the point of making it do what I want it to do. even if it's really small things, heh.
09:56:09 <Fuuzetsu> No problem. Chousuke's explanation is probably a more correct way of thinking about it especially considering that Maybe only takes one type while Either can take 2
09:56:49 <quchen> alexander__b: Spoiler: yes
09:56:54 <Fuuzetsu> ^
09:57:07 <alexander__b> well I *am* quite stupid. ;-)
09:57:11 * hackagebot jack 0.7 - Bindings for the JACK Audio Connection Kit  http://hackage.haskell.org/package/jack-0.7 (HenningThielemann)
09:57:13 <alexander__b> thanks for the encouragement though.
09:57:17 <typoclass> Fuuzetsu: i dunno. i found your explanation much easier to understand than "Either () a" ...
09:57:37 <Fuuzetsu> typoclass: I didn't said it was easier.
09:57:38 <Fuuzetsu> say*
09:57:42 <Chousuke> alexander__b: Haskell makes *everyone* think that
09:57:45 <quchen> Wasn't an encouragement, like predicting that a toddler will eventually learn to speak is an encouragement. :-)
09:58:02 <Chousuke> alexander__b: even if you're super smart, you will encounter things that make you feel stupid. it's part of the fun
09:58:21 <Chousuke> then you get to learn things and feel less stupid
09:58:36 <ParahSailin> would it be accurate to call Ethier () a and Maybe a homomorphic?
09:59:00 <quchen> More like isomorphic.
09:59:02 <alexander__b> quchen: what if the toddler is mute? ;-)
09:59:03 <typoclass> ParahSailin: i think folks call it isomorphic
09:59:08 <Fuuzetsu> it is iso
09:59:12 <ParahSailin> ah iso
09:59:29 <quchen> alexander__b: Sign language?
10:00:05 <quchen> alexander__b: Unless the toddler is Turing-incomplete, he will learn to speak.
10:00:05 <alexander__b> quchen: communication != speaking. but I digress.
10:00:25 <typoclass> ParahSailin: (if we called it 'equivalent' or even 'same', then people wouldn't know that we're oh so clever. so we're going to call it isomorphic) =)
10:00:27 <benzrf> hello!
10:00:28 <lambdabot> benzrf: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:00:45 <benzrf> oh
10:00:47 <benzrf> -.-
10:01:20 <Fuuzetsu> typoclass: Well, they aren't equivalent…
10:01:20 <Chousuke> typoclass: I suppose that's just to be precise about things
10:01:32 <Fuuzetsu> or at least, not the same
10:01:41 <benzrf> why can I do 'instance Foo (a -> b)' but not 'instance Foo (a -> b -> c)'
10:01:54 <quchen> You can do both of those
10:02:02 <benzrf> it doesn't work for me...
10:02:11 * hackagebot midi-alsa 0.2.1 - Convert between datatypes of the midi and the alsa packages  http://hackage.haskell.org/package/midi-alsa-0.2.1 (HenningThielemann)
10:02:18 <Chousuke> syntax problems?
10:02:20 <benzrf> instance Show (a -> b -> c) where show foo = "funkshun"
10:02:51 <Chousuke> oh hm
10:03:06 <quchen> That example works. http://codepad.org/peVFfiEG
10:03:06 <Chousuke> (a -> b) would match a -> b -> c where b = (b -> c), wouldn't it
10:03:19 <benzrf> yep
10:03:41 <benzrf> quchen: that doesn't work for me
10:03:42 <Chousuke> so you need some extension to make them both work at the same time
10:03:44 <sm> g'day all. Is there a json lib that makes adhoc querying of json data in ghci easy ? I'm finding it hard with aeson
10:03:57 <Fuuzetsu> benzrf: Can you be more specific?
10:04:01 <benzrf> when I do <instance Show (a -> b -> c) where show foo = "funkshun"> I get:
10:04:01 <benzrf>     Illegal instance declaration for `Show (a -> b -> c)'
10:04:02 <benzrf>       (All instance types must be of the form (T a1 ... an)
10:04:02 <benzrf> etc
10:04:48 <Fuuzetsu> oh, I get that as well~
10:04:50 <benzrf> in other news <:k a -> b> doesn't work for me
10:05:00 <Peaker> benzrf, in Haskell98/2010, instances must be of a very restricted form like the error says:  instance Class (SomeType <some type variables>) where ...
10:05:07 <monochrom> https://plus.google.com/107361282953048961750/posts/F1Lqg4nJefG
10:05:15 <Peaker> benzrf, you can override this restriction by enabling the ghc extension "FlexibleInstances"
10:05:33 <Peaker> benzrf, you can stick a pragma on the top of your file: {-# LANGUAGE FlexibleInstances #-}
10:05:46 <benzrf> Peaker: but... isn't a -> b -> c equivalent to a -> b where b is b -> c?
10:05:59 <Peaker> benzrf, Yes, and? :)
10:06:05 <naz_> Hi, I'm looking to make a plugin for xmobar. Can anybody point me to a simple one or a good resource ?
10:06:11 <benzrf> so... doesn't that mean it should work?
10:06:20 <Fuuzetsu> naz_: xmobar documentation page
10:06:32 <Peaker> benzrf, if you used:  instance Foo (a -> b) where ... then sure.   But "b" must be a type-variable, it cannot be another concrete type like: b -> c
10:06:33 <Fuuzetsu> http://projects.haskell.org/xmobar/#writing-a-plugin
10:06:39 <Peaker> benzrf, (b -> c) is not a type variable
10:06:40 <benzrf>  OH, ok
10:06:42 <typoclass> Fuuzetsu: i was being tongue-in-cheek, but still, i think it's not totally off to say "same" for things that can be losslessly converted. i'd be fine if someone said "0.789 kilo" is "the same" as 789, or even if someone said "Foo is just a newtype wrapper, so it's essentially the same as Bar"
10:07:11 * hackagebot synthesizer-alsa 0.5 - Control synthesizer effects via ALSA/MIDI  http://hackage.haskell.org/package/synthesizer-alsa-0.5 (HenningThielemann)
10:07:29 <Fuuzetsu> typoclass: but 789 is never going to be 0.789, no matter how many of us understand the intent
10:07:37 <benzrf> why does unsafePerformIO exist btw?
10:07:37 <naz_> Fuuzetsu: How did I miss this -.- Thank you !
10:07:37 <benzrf> D:
10:07:53 <quchen> benzrf: FFI, mainly.
10:08:01 <Fuuzetsu> benzrf: FFI and it also gives us based Debug.Trace
10:08:03 <benzrf> define ffi?
10:08:04 <quchen> benzrf: (Calling C from Haskell that is)
10:08:16 <benzrf> oh foreign function interface
10:08:27 <benzrf> BUT MUH PURITY
10:08:31 <typoclass> Fuuzetsu: yeah? but 0.789 kilowatt is the same as 789 watt, isn't it?
10:08:43 <quchen> Canonical example: Your C function results in a pointer to the solution. That pointer will be in IO, as the memory location is determined at runtime; the function may be pure nevertheless.
10:08:45 <Fuuzetsu> naz_: out of interest, what is it that you're writing? xmobar user here
10:09:30 <Fuuzetsu> typoclass: By definition 1000 watt = 1 kilowatt. They are the same thing by definition.
10:10:06 <naz_> Fuuzetsu: Actually not much atm, I'm learning Haskell and would like a real project. Since I like xmobar I thought I give it a try.
10:10:10 <Fuuzetsu> of course, if you had a Watt and Kilowatt _types_ then they are no longer the same.
10:10:41 <Fuuzetsu> they might be isomorphic, sure, but it's not like you can just replace one with another for any arbitrary expression, as-is.
10:10:45 <typoclass> Fuuzetsu: could you rephrase what you mean? i said how i'd be fine if someone said "0.789 kilo is the same as 789", and you objected
10:10:58 <benzrf> why the restriction on instances anyway?
10:11:33 <Peaker> benzrf, because unrestricted instance resolution becomes very tricky very fast
10:11:33 <Chousuke> amiguity problems?
10:11:46 <benzrf> what if I WANT to only make IO Int be an instance of class foo??
10:11:49 <Peaker> benzrf, there are overlapping issues, divergence/termination issues
10:11:53 <benzrf> wait brb
10:11:54 <Fuuzetsu> typoclass: Oh, you're using ‘kilo’ in it's ×1000 sense.
10:12:06 <Fuuzetsu> Well, if they are the same type, then sure, they are the same in this case.
10:12:12 * hackagebot synthesizer-llvm 0.5 - Efficient signal processing using runtime compilation  http://hackage.haskell.org/package/synthesizer-llvm-0.5 (HenningThielemann)
10:12:27 <benzrf> crap, g2g
10:12:30 <benzrf> thanks for the help anyway :D
10:12:55 <Peaker> > let eitherMaybe = iso (either (const Nothing) Just) (maybe (Left ()) Right)   in   (Right 5 ^. eitherMaybe, eitherMaybe # Nothing)
10:12:57 <Peaker> ParahSai1in, ^^
10:12:58 <lambdabot>   (Just 5,Left ())
10:13:12 <typoclass> Fuuzetsu: ok :-) right
10:15:46 <Scabe> http://hpaste.org/88104
10:15:52 <Fuuzetsu> :t iso (either (const Nothing) Just) (maybe (Left ()) Right)   in   (Right 5 ^. eitherMaybe, eitherMaybe # Nothing)
10:15:53 <Scabe> How do I make a list of the leaves in a Rose Tree?
10:15:57 <lambdabot> parse error on input `in'
10:16:47 <simpson> Scabe: Are you using Data.Tree?
10:16:51 <Fuuzetsu> :t (Right 5 ^. ( iso (either (const Nothing) Just) (maybe (Left ()) Right)), ( iso (either (const Nothing) Just) (maybe (Left ()) Right)) # Nothing)
10:16:54 <lambdabot> Num a => (Maybe a, Either () b)
10:18:00 <simpson> Scabe: Okay, so that's not a bad first approach.
10:18:01 <Scabe> simpson Nah I'm not using Data.Tree
10:18:57 <quchen> See the annotation.
10:20:45 <quchen> A leaf is a Node with no branches. That's the first case.
10:21:22 <quchen> The second case takes all the outgoing branches, and gathers their leaves recursively.
10:21:30 <simpson> Reannotated with explicit concatMap. :3
10:21:36 <quchen> Boo ;-)
10:21:47 <simpson> Scabe: BTW, is this homework? If not, just use Data.Tree.
10:22:01 <quchen> simpson: You also put in an error :P
10:22:12 * hackagebot synthesizer-llvm 0.5.0.1 - Efficient signal processing using runtime compilation  http://hackage.haskell.org/package/synthesizer-llvm-0.5.0.1 (HenningThielemann)
10:22:12 <simpson> quchen: Hey, it wouldn't be me if I didn't. :3
10:23:44 <Scabe> thanks guys and nah not hommework,assignment on a bigger picture that I have in my mind to get it running
10:35:47 <merijn> Anyone here remember how to avoid the iconv incompatibility between ghc on OSX and macports when linking to C libraries?
10:36:48 <mzero> don't use macports?  (ducks…)
10:37:10 <merijn> mzero: And you'd suggest...
10:37:10 <mzero> I think you need to be sure that the macports version isn't in your libpath
10:37:12 * hackagebot esqueleto 1.2.1 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.2.1 (FelipeLessa)
10:40:08 <merijn> I've had and solved this issue before, but I don't remember how :(
10:41:44 <merijn> Wait, how do I specify ghc flags to cabal?
10:42:37 <mzero> --ghc-option
10:42:40 <mzero> or --ghc-options
10:42:59 <dcoutts_> merijn: if you mean as package builder (as opposed to package author), then you do it with what mzero said, as args to configure or install
10:44:36 <merijn> fingers crossed
10:45:19 <merijn> \o/
10:45:30 <merijn> Configuring with extra-lib-dir worked
10:45:39 <merijn> mzero: Thanks :)
10:46:13 <mzero> woot - now write that as a StackOverflow question - then answer it yourself - and you will always have a note of you solved this!
10:48:18 <hrookie> hey y'all - anyone have experience getting command-line programs to use cooked mode for input?
10:49:27 <Fuuzetsu> I wish Haskell-like shell environment existed… Every day I think ‘this would be really neat if I had Haskell's XYZ’
10:49:48 <Fuuzetsu> I might start writing Bash scripts that emulate the behaviour.
10:50:42 <hrookie> Fuuzetsu: hehehe yeah. i'm doing a small project in haskell, but i think my use cases for haskell are honestly going to remain somewhat limited. because of the huge communities, the libraries available in imperative languages just blow haskell's out of the water.
10:50:53 <simpson> IYSS.
10:51:26 <merijn> Fuuzetsu: What's stopping you from writing a shell-like environment in haskell? There's already things like shelly
10:51:44 <mzero> hrookie: I think stdin will be in cooked mode by default when launched from a shell
10:52:23 * monochrom suddenly understands, after all these years, "cooked mode" is a pun on "the opposite of raw mode"
10:52:44 <hrookie> mzero: oh, hm! perhaps it's just GHCI then?
10:52:46 <Fuuzetsu> A shell is a pretty big project and I'm still unsure whether it's worth the effort if all I want are some basic functions that I can implement in Bash
10:52:49 <hrookie> monochrom: :D
10:53:02 <Fuuzetsu> As always, time is a precious resource.
10:53:03 <mzero> ahhhh - yes!
10:53:29 <mzero> if you are launching your code from within ghci, then yay, it'll be raw (as that is what ghci sets stdin to)
10:54:02 <Fuuzetsu> I think it'd be far easier to use GHCI with some unsafe functions to mimic basic shell or something.
10:54:14 <dmwit> hrookie: Why don't you skip straight to the real question? =)
10:54:20 <mzero> you could use the    hSetBuffering stdin LineBuffering
10:54:26 <mzero> to get it back to cooked
10:54:43 * mzero wonders if ghci will reset stdin when the code returns….
10:54:46 <dmwit> I thought buffering was a bit separate from cookedness...
10:55:14 <mzero> Uhm…. I  *AM* writing a full shell in Haskell
10:55:24 <mzero> and it is already mostly Posix compliant
10:55:33 <mzero> we've been working on it for a year and a half
10:55:41 <dmwit> Okay! I believe you, then. =)
10:55:42 <hrookie> github that @*)%! Fuuzetsu can contribute =)
10:55:42 <mzero> open source, come join the fun!
10:55:46 <Fuuzetsu> mzero: got links?
10:55:46 <hrookie> woohoo!
10:56:02 <hrookie> dmwit: and yes, cooked mode and buffering are somewhat separate.
10:56:12 <mzero> https://code.google.com/p/plush/
10:56:18 <mzero> (there is also a github repo if you prefer)
10:56:25 <Fuuzetsu> I just starred the GH repository.
10:56:29 <Fuuzetsu> I don't get along well with Google code
10:56:31 <Nafai> mzero: yay!  I've been wanting a new shell
10:56:59 <mzero> dmwit: cooked and buffering ARE different, but I think the handle code conflates them a bit -- or at least remembers the raw/cooked thing per buffering mode (or perhaps it is termios that does that… but I think it does)
10:57:24 <dmwit> I see.
10:57:30 <mzero> note that for now the bug tracker and wiki are on google code - but will be moving to github for those in the near future
10:58:05 <Fuuzetsu> How come half of it is in JavaScript?
10:58:26 <Fuuzetsu> Does it think the tests are JS?
10:58:41 <Fuuzetsu> (GitHub, that is)
10:58:44 <dmwit> Fuuzetsu: As I recall they have a document outlining why they chose to use the browser as their GUI library.
10:59:14 <mzero> I don't think so
10:59:25 <Fuuzetsu> dmwit: Are you highlighting the right person?
10:59:30 <mzero> i thinks there is more JS than HS because we included seveal JS libs
10:59:43 <dmwit> Fuuzetsu: Yes.
10:59:52 <mzero> which they? Plush?
10:59:55 <dmwit> yes
11:00:01 <mzero> plush is both command line and web pased
11:00:03 <mzero> web based
11:00:23 <mzero> it just run it -- with normal shell args (none, or -s, or -c, ) it works just like a POSIX shell
11:00:25 <mzero> on the command line!
11:00:40 <Fuuzetsu> Oh.
11:00:43 <mzero> if you run it via     plush --local     you get all the bells and whistles
11:01:14 <Fuuzetsu> Better try to build it. It's not like I have finals to study for right now or anything.
11:01:21 <mzero> and if you install it on a remote system you have access to via ssh      plush --remote <host>     will get you a local web based interface to a shell on the remote system!
11:01:38 <hrookie> Fuuzetsu: finals are when hackery reaches maximum badassness, and your ELO goes up by 200 in every video game you play
11:02:08 <hrookie> Fuuzetsu: who ever said anything about studying?
11:02:21 <dmwit> And after you graduate, you get to substitute any deadline you like for "finals" in that sentence!
11:02:26 <Fuuzetsu> hrookie: Well, http://www.structuredprocrastination.com/ is a beautiful thing but I don't really want to fail another unit ;)
11:02:27 <dmwit> It's a whole new world of procrastination.
11:04:27 <hrookie> Fuuzetsu: that's brilliant! that's why i'm learning all about network programming right now and setting up a real-time chat client as a base for a lightweight video game i'm writing from scratch in haskell right now =D
11:05:01 <hrookie> Fuuzetsu: i have papers to read! proofs to write! but alas, something way less important takes up all my time :D
11:05:28 <hrookie> disclaimer: not even i condone my own behavior
11:05:55 <Fuuzetsu> Yes, I usually end up being very productive in all the wrong ways as well but alas, I retain a little bit of sanity in that I don't want to fail the whole year and have to do it again.
11:06:15 <Fuuzetsu> Having said that, I did absolutely nothing productive for the past two days ;;
11:08:34 <joe9_> I created a Matrix like this: http://codepad.org/IMgfdbas . I want to be able to map a function on each element of that Matrix. Should I implement an fmap for that Matrix?
11:08:44 <joe9_> or, is there a better way of going about it.
11:09:15 <Peaker> joe9_, you (almost?) never have to implement fmap, you can use DeriveFunctor to implement fmap for you
11:09:22 <joe9_> or, an easier way of implementing map by using a different data type, etc.
11:09:37 <joe9_> Peaker, thanks. let me check on DeriveFunctor
11:09:52 <hrookie> Fuuzetsu: isn't that always the pattern?
11:09:55 <Peaker> joe9_, though fmap is not as powerful as you might need when iterating. You might want traverse, which is also fortunately derive'able with the DeriveFoldable,DeriveTraversable extensions
11:10:08 <Peaker> joe9_, traverse lets you have a for-each on your data structure that also does effects at each position
11:10:32 <joe9_> Peaker: thanks. let me check on traverse
11:13:24 <Peaker> joe9_, when you derive Foldable,Traversable, you can then do something like:  traverse_ print myMatrix
11:14:16 <mzero> that all said - if you are doing this to gain experience in Haskell --- I'd suggest you write your own instance of Functor (and hence fmap) --- it is easy for this data type, and you'll gain a little insight!
11:14:34 <Fuuzetsu> hm, --local just gives me a File not found in my browser
11:14:43 <mzero> oh bugger
11:14:48 <mzero> didn't update the README
11:14:56 <mzero> you should    cabal configure -fProduction
11:15:04 <mzero> then rebuild for   --local to work
11:15:08 <mzero> (sorry, ducks...)
11:15:31 <mzero> make sure you also....
11:15:35 <mzero> plush --local stop
11:15:48 <Cale> @bot
11:15:48 <lambdabot> :)
11:15:58 <Cale> > 5^2
11:16:02 <lambdabot>   25
11:16:25 <mzero> so:      ./dist/build/Plush/plush --local stop; cabal clean; cabal configure -fProduction; cabal build; ./dist/build/Plush/plush --local
11:18:09 <Fuuzetsu> that did it
11:18:32 <Fuuzetsu> I'm unsure how I feel about using my browser for a shell though.
11:18:38 <Fuuzetsu> I barely leave emacs as it is.
11:18:48 <tromp> :t ord
11:18:52 <lambdabot> Char -> Int
11:18:56 <tromp> :t chr
11:19:00 <lambdabot> Int -> Char
11:19:03 <tromp> > chr 90
11:19:05 <lambdabot>   'Z'
11:20:24 <Fuuzetsu> oh boy, it didn't like ‘git status’.
11:20:32 <Fuuzetsu> or anything after…
11:22:17 <Fuuzetsu> Hm, nope, this is not the kind of shell I'm looking for at all~
11:24:27 <mzero> if you are usig Chrome, emacs and vim work within the browser window in Plush
11:24:35 <mzero> other browsers I'm not so sure
11:24:43 <mzero> but it is a Posix shell!
11:25:10 <mebaran151> hey all, anybody have any experience wtih Persistent / Yesod?  I'm wondering if there is an easy way to get the list of entities / clear all tables
11:25:26 <mebaran151> I know it must have a function given its migration capabilities but I have yet to find it
11:25:33 <Fuuzetsu> I quite like the shell I have at the moment though. I'm just missing some handy Haskell functions when I work sometimes
11:25:34 <Fuuzetsu> like map
11:25:50 <Fuuzetsu> (also, far too much mouse work for my liking with plushy)
11:26:07 <Fuuzetsu> It looks like a cool project though.
11:26:37 <Taneb> mebaran151, try asking in #yesod ? It will be answered eventually there, but if it's not answered immediately here it'll get lost
11:27:41 <shachaf> Yes, #yesod is the right channel for Yesod questions.
11:27:57 <mebaran151> okay, question reposted there.  thanks everybody
11:29:23 <wereHamster> when given a InstalledPackageId, is it possible to find out which exact dependencies that package depends on?
11:29:26 <mzero> Fuuzetsu: type command-? -- Plush as many keyboard shortcuts - designed so that you don't have to mouse most of the time
11:30:46 <Fuuzetsu> mzero: is there something really cool and innovative you guys are going to do with it for the CLI version?
11:32:39 <mzero> the pure CLI version - not yet.
11:32:56 <mzero> the aim is to first be completely POSIX compliant for the input - what your fingers already know how to do
11:33:10 <mzero> and the aim is to be exactly the same for input from the web version as well
11:33:14 <carter> mzero ooo plush!
11:33:18 <Fuuzetsu> Too bad. I wish fish shell was faster. It seems really cool but my housemate tried it and it was apparently really slow…
11:33:34 <carter> whats new in the change log since ~ 2-4 months ago?
11:33:34 <wereHamster> ah, there is lookupInstalledPackageId in Distribution.Simple.PackageIndex
11:33:45 <mzero> there have been many attempts to do better on the input language of the shell -- they've all failed for the most part
11:34:07 <mzero> the shell language, basically set 30 years ago (!), has reached a sort of local maxima
11:34:18 <Fuuzetsu> Well, everyone knows it.
11:34:37 <mzero> carter -     local and remote plush servers --- think screen/tmux built into plush
11:34:39 <Chousuke> mzero: for the things it's good enough, it's good enough, and when it isn't, you just use something else :P
11:34:50 <carter> huh
11:34:52 <carter> neat
11:34:57 <mzero> and when your UI to the shell goes away --- it's still there running, so you can get back to it… even remotely
11:35:07 <carter> huh
11:35:14 <carter> i'm still not quite at the tmux level
11:35:21 <mzero> that is true, Chousuke  - our aim is to make the output, the visual context, of the shell be better
11:35:40 <carter> i forget… plush is a shell, or just the terminal for the shell?
11:35:51 <mekeor> so, i want to program something like blaze-html myself. (but not for html, for my personal layout.) http://hpaste.org/88108 – i want to do it using do-notation and to be able to render the stuff, i need to know whether the last command was a "hN" (which is for title), an "item" or a "paragraph". is WriterT what i am looking for?? O.o what am i looking for? or should i implement it completely myself?
11:35:55 <carter> look now
11:35:57 <Fuuzetsu> the browser acts like a terminal for it I guess
11:36:58 <carter> http://code.google.com/p/plush/wiki/ActionPlan hrmm. so both?
11:37:16 <wereHamster> now, how to get the PackageIdentifier from a InstalledPackageId?
11:37:26 <mekeor> s/ and/. furthermore,/  ;  s/title/titles/   # :D
11:37:51 <Fuuzetsu> mekeor: I don't see an issue using writer but it might be awkward to be calling functions and then store their String equivalents as a log as you'll have to parse back the string when you look in the log
11:38:11 <Fuuzetsu> Well, I guess you can pattern match on the string…
11:39:27 <mekeor> ?? i don't think that'd be necessary.. i mean, i could use "(Something,String)" instead of "String" where "data Something = Title | Item | Paragraph", couldn't i?
11:39:28 <lambdabot> Plugin `compose' failed with: Unknown command: ""
11:39:39 <hrookie> So, how long do you think it'll be before there are enough haskell libraries that people finally start to catch on? xD
11:39:59 <elliott> there is already a large amount of haskell libraries
11:39:59 <Fuuzetsu> hrookie: well, aren't there 4k+ on Hackage now? That's a fair bit.
11:40:34 <hrookie> Fuuzetsu: i mean, that get rolled as part of a standard, that you can just kind of count on being there.
11:40:36 <Fuuzetsu> mekeor: Sure you could but you never said you had those types available to you. We're not psychic.
11:40:39 * mekeor probably should read about writers again... :(
11:40:52 <elliott> hrookie: haskell platform?
11:41:24 <mekeor> Fuuzetsu: fine... :P :D
11:41:32 <dcoutts_> Fuuzetsu: I usually approximate it as 5k packages, with 25k versions
11:41:56 <hrookie> Well, I mean things like have a standard network library that lets you transmit and receive data seamlessly in an easy fashion. Digging up cereal-conduit, network-conduit, and conduit, finding cereal-conduit is in "experimental" and seeing next to no docs or examples isn't exactly encouraging.
11:42:32 <carter> hrookie theres plenty
11:42:37 <Fuuzetsu> dcoutts_: Well, I made my estimate based on someone saying 3k in a talk from October 2011 so I guess I wasn't very far off.
11:43:04 <hrookie> carter: a few competing and evolved ones near the top, each with their own quirks.
11:43:14 <dcoutts_> Fuuzetsu: right, I only happen to know because I've been working on the hackage2 import stuff
11:43:28 <Fuuzetsu> hrookie: Well, this is the part where you step in and help out the projects you feel aren't up to scratch~
11:43:34 <carter> yes
11:43:47 <carter> its incredibly easy to contribute to haskell projects / libs tools
11:43:50 <carter> to make them even better
11:43:57 <Fuuzetsu> is there any ETA on hackage2
11:44:04 <hrookie> which doesn't address the question
11:44:06 <Fuuzetsu> carter: Unless it's lens.
11:44:11 <dcoutts_> Fuuzetsu: see http://new-hackage.haskell.org/
11:44:17 <elliott> lens is easier to contribute to than most libraries
11:44:22 <carter> Fuuzetsu what elliott  said
11:44:36 <hrookie> sure, i can step in and help. i'm toying with and writing haskell right now! what i'm wondering is if haskell will ever actually gain any level of popularity.
11:44:41 <Fuuzetsu> Oh, is that why it has more contributors than people who understand it?
11:45:07 <Fuuzetsu> hrookie: We're one of the biggest channels on Freenode, is that not popular enough?
11:45:49 <hrookie> Fuuzetsu: Freenode users is not a meaningful metric. How many people actually whip up a problem and go "You know what would be great for this? Haskell."
11:46:03 <hrookie> Fuuzetsu: However, it seems like countless bajillions of people do that with python.
11:46:23 <carter> hrookie its popular enough that i get work around it
11:46:43 <carter> i don't care about pass popularity, i get to work on cool stuff that i want to, in exchange for peoples money
11:46:48 <carter> thats popular enough for me :)
11:46:55 <Fuuzetsu> hrookie: They do it with Python because they often don't know better. Many things you do with Haskell might actually be a lot better in language XYZ but you'll always think that Haskell is THE thing to use.
11:47:14 <hrookie> carter: again, ignoring the question, but i can dig the fact that that works out for you ~
11:47:31 <carter> hrookie i'm saying the questin isn't an interesting one
11:47:40 <hrookie> Fuuzetsu: i'm largely considering dropping this project in haskell, because several times i've found that haskell is *not* the thing to use
11:47:56 <carter> hrookie sounds like you're having rookie woes, haskell IRC is here to help though :)
11:48:08 <carter> whats the goal of your project?
11:48:27 <hrookie> carter: it's a tiny multiplayer video game i want to have running in real-time on a LAN
11:48:34 <carter> ok
11:48:39 <carter> hrookie step one: dont use TCP
11:48:41 <Fuuzetsu> I think it's better to have a bit smaller but tightly nit community of smart folks instead of having a multi-million user base of relatively useless people.
11:48:55 <carter> step two : don't use tcp
11:49:08 <elliott> haskell is already fairly popular.
11:49:13 <hrookie> carter: why not? lol
11:49:21 <carter> hrookie tcp is bad for real time
11:49:25 <Ankhers> Fuuzetsu: You mean... the average PHP dev isn't a good dev? :P
11:49:32 <carter> takes a lot of engineering to have real time over tcp
11:49:34 <carter> A LOT
11:49:35 <hrookie> carter: the amount of traffic is so minimal that i'm honestly not concerned about it.
11:49:40 <carter> then use udp
11:49:42 <carter> it'll be even easier
11:49:47 <carter> and you can just pretend its reliable
11:49:49 <Fuuzetsu> Ankhers: I bet you'd get eaten to death over that remark in #php or whatever channel it is they use.
11:49:59 <Fuuzetsu> PHP is the greatest after all!
11:50:04 <Fuuzetsu> (we're just hipsters)
11:50:14 <carter> hrookie what sort of real time do you want?
11:50:19 <Ankhers> Fuuzetsu: As someone that used to be a PHP dev, I'm glad I left...
11:50:22 <hrookie> carter: literally, the messages from client to server are going to be "user X pushed button Y"
11:50:30 <carter> hrookie so that will fit in a udp packet
11:50:36 <mekeor> Fuuzetsu: transformers:Control.Monad.Trans.Writer.Lazy.Writer or mtl:Control.Monad.Writer.Lazy.Writer? it's the same? which module should i import for Writer?
11:50:45 <hrookie> carter: and messages from the server to the clients will be of the form "Player pushed button X at time T"
11:50:55 <carter> hrookie: use udp
11:51:02 <carter> you'll be much happier
11:51:07 <hrookie> carter: over a LAN, TCP is really going to be that evil?
11:51:14 <carter> nope, but udp will be easier still
11:51:20 <carter> tcp isn't message oriented
11:51:26 <Fuuzetsu> mekeor: Control.Monad.Writer
11:51:29 <carter> udp is
11:51:34 <carter> your messages will fit in udp
11:51:44 <Ankhers> carter: isn't udp, in general, faster?
11:51:47 <carter> yessssss
11:51:47 <Hannibal_Smith> hrookie, in a game server, receive old "world status" is not useful, is general
11:51:49 <carter> that too
11:51:59 <hrookie> Ankhers: yes, because if something doesn't make it, there's a retransmission attempt
11:51:59 <mekeor> Fuuzetsu: okay
11:52:09 <hrookie> Ankhers: in TCP, that is. UDP is just like "whatever."
11:52:11 <Hannibal_Smith> If you client drop one, should not matter
11:52:13 * hackagebot live-sequencer 0.0.4 - Live coding of MIDI music  http://hackage.haskell.org/package/live-sequencer-0.0.4 (HenningThielemann)
11:52:15 <Eduard_Munteanu> I doubt UDP makes a difference wrt throughput.
11:52:17 <carter> to put in haskell words: UDP is both faster, and a better abstraction fit
11:52:21 <carter> Eduard_Munteanu yes
11:52:33 <carter> but its a better abstraction for this use case too
11:52:33 <hrookie> Hannibal_Smith: the things that are important are player actions
11:52:49 <hrookie> Hannibal_Smith: i want those to be reliably delivered
11:52:55 <Eduard_Munteanu> But yes, if it's a realtime thingy you probably want UDP or SCTP.
11:52:57 <carter> hrookie but udp is sually reliable
11:53:00 <Hannibal_Smith> hrookie, so go with tcp
11:53:10 <carter> its just its sometimes not
11:53:16 <carter> Eduard_Munteanu sctp isn't avaialble on os x
11:53:23 <carter> if he careas about OS X users
11:53:25 <Eduard_Munteanu> :(
11:54:30 <Eduard_Munteanu> Also it's not uncommon to combine TCP and UDP connections, if you need reliable transport for some things.
11:54:32 <carter> Eduard_Munteanu its ok, we'll have a modernized userland network stack in haskell if i find the free time in the nex tyear or so
11:54:50 <Hannibal_Smith> hrookie, if you want something more "high level" you can even look at zeromq or websockets
11:55:02 <carter> hrookie : try udp
11:55:02 <Hannibal_Smith> Both avaiable for Haskell
11:55:04 <carter> its simple
11:55:19 <carter> and you wont have spent a lot of time over engineering if it wokrs
11:55:28 <carter> and i'tll be easy to find out if it breaks and replace it if it doesn
11:55:33 <Eduard_Munteanu> UDP is simpler if you're sending messages, you don't have to deal with collecting messages from a stream.
11:55:53 <Hannibal_Smith> Eduard_Munteanu, yes but if you want a reliable system
11:55:54 <carter> tyes
11:55:56 <carter> that too
11:56:02 <hrookie> i already wrote a little utility that keeps a connection alive, then dumps serialized data to it, and gets out the serialized data on the other side.
11:56:04 <Hannibal_Smith> So rewrite tcp on udp then
11:56:05 <carter> Hannibal_Smith but udp is reliable if the network is reliable
11:56:19 <Hannibal_Smith> carter, you can't be sure
11:56:23 <carter> if the local lan is dropping packets when its not being used heavily
11:56:25 <carter> its broken
11:56:39 <carter> or someone forgot to turn off bit torrent
11:56:40 <Eduard_Munteanu> Yeah... however for sending multiplayer game update info, you often don't want reliable transport.
11:56:44 <carter> yes
11:56:46 <carter> that too
11:56:55 <carter> Eduard_Munteanu is correct
11:57:00 <carter> you just want to learn the most recent state
11:57:02 <Hannibal_Smith> <Eduard_Munteanu> Yeah... however for sending multiplayer game update info, you often don't want reliable transport. <-Yes I think that too
11:57:23 <carter> every local client just has a "predictor" when its not getting updates
11:57:27 <Hannibal_Smith> But is not something that hrookie wants
11:57:33 <carter> which is why when latency is bad, things jump around
11:57:42 <hrookie> yes, that i get
11:58:07 <hrookie> but if i move to UDP
11:58:10 <hrookie> to ensure that things are going well
11:58:18 <carter> hrookie what sort of game is it?
11:58:19 <hrookie> then i have to broadcast a lot more game state
11:58:24 <hrookie> it's kinda like light cycles
11:58:25 <Hannibal_Smith> hrookie, you should model you protocol aroud the fact
11:58:31 <Hannibal_Smith> That you can drop packets
11:59:01 <carter> hrookie : the problem with a reliable ordered tcp, is when packets get dropped, later packets dont get through until the earlier ones doo
11:59:04 <Hannibal_Smith> If you model around "be sure to not drop packets"
11:59:15 <Hannibal_Smith> You will rewrite tcp on top of udp
11:59:45 <carter> Hannibal_Smith not quite
11:59:45 <Eduard_Munteanu> hrookie: you could do what they do for in multimedia encoding... send 1 full state packet, then a bunch of diffs from that, repeat
11:59:50 <carter> only if you add the ordered message assumption
11:59:54 <carter> otherwise you get sctp :)
12:00:01 <hrookie> Hannibal_Smith: or just be using TCP off the bat
12:00:06 <Hannibal_Smith> Ok, I don't know sctp
12:00:13 <carter> sctp lets you have reliable messages
12:00:33 <carter> where it stops trying to resend if theres been too many retries or its been a while
12:00:47 <carter> and where the individual messages can be sent in any order
12:00:47 <hrookie> Eduard_Munteanu: yeah. that's what's going on right now. the initial game state goes through to everyone at the start, then just little signals that change the state come through
12:00:49 <carter> ish
12:01:22 <Eduard_Munteanu> hrookie: err, I wouldn't do *only* updates, especially if you're using unreliable transport
12:01:59 <Eduard_Munteanu> If you miss one update, then you're out of sync.
12:02:17 <dmwit> http://en.wikipedia.org/wiki/Fountain_code # slightly short of serious suggestion
12:02:32 <carter> Eduard_Munteanu one hack would be broadcast  a "heres the hash of the moves so far"
12:02:32 <hrookie> Eduard_Munteanu: hence the use of TCP so far
12:02:43 <carter> and if a client doesn't have that correct hash
12:02:48 <carter> theres a back and forther
12:02:57 <carter> and a tcp fall back for "heres the correct history"
12:03:03 <carter> dmwit that would work
12:03:32 <Hannibal_Smith> <dmwit> http://en.wikipedia.org/wiki/Fountain_code # slightly short of serious suggestion <-Wow, looks interesting
12:03:40 * dmwit feels the "if you need reliable transport, just use TCP instead of reinventing it badly on top of UDP" rant coming on
12:04:08 <carter> dmwit only if you need ordering
12:04:56 <carter> anyways
12:05:00 <carter> i should get back to work
12:07:14 * hackagebot datalog 0.1.0.0 - An implementation of datalog in Haskell  http://hackage.haskell.org/package/datalog-0.1.0.0 (TristanRavitch)
12:07:30 <dmwit> hoo boy
12:09:20 <carter> data log!
12:09:30 <hrookie> i'm with dmwit on his latest thing - just use TCP instead of reinventing it badly
12:09:35 <hrookie> apparently SC2 and WoW use TCP
12:09:37 <hrookie> that's good enough for me
12:09:39 <carter> ok
12:09:41 <carter> fair
12:09:43 <carter> do it
12:09:48 <hrookie> if i run into latency issues
12:09:51 <hrookie> in my five-player LAN game
12:09:57 <hrookie> i'll move to UDP
12:09:57 <hrookie> =D
12:10:03 <carter> cool
12:10:09 <carter> darn, thats not a pretty datalog
12:11:07 <edwardk> guess i'll need to rename the library i was splitting out of analytics for datalog work
12:11:22 <elliott> i was just thinking edwardk will be mad
12:11:29 <edwardk> meh
12:11:50 <edwardk> i've moved on to semiparsing anyways
12:12:09 <elliott> of course.
12:12:17 <companion_cube> edwardk: what algorithm do you use for Datalog?
12:12:26 <companion_cube> bottom-up + magic sets?
12:12:42 <dmwit> He invented his own that's amenable to being encoded at the type level.
12:12:44 <dolio> edwardk: By the way, I was looking at trifecta last night thinking about layout.
12:12:47 <Fuuzetsu> Just magic.
12:12:51 <edwardk> companion_cube: we've been looking at both bottom up + magic sets and top-down with variant and subsumptive tabling.
12:12:51 <dmwit> Most of the time nothing even runs at runtime.
12:13:03 <dolio> edwardk: Don't you need line numbers as well as column numbers?
12:13:03 <companion_cube> edwardk: did you hear about Earley resolution?
12:13:15 <edwardk> companion_cube: not placing it
12:13:24 <companion_cube> http://web.cecs.pdx.edu/~harry/earley/earley.htm
12:13:36 <edwardk> dolio: you only need to know if you are in a 'beginning of line' state not the line number per se
12:13:54 <dolio> Does trifecta give you that?
12:13:55 <edwardk> companion_cube: neat. i'll read it =)
12:14:08 <companion_cube> top-down+tabling looks nice, but amount to implement a XSB-like prolog
12:14:11 <edwardk> dolio: the combinators i had offered for layout used to provide it as an extra bit of state
12:14:12 <companion_cube> that's a lot of work :/
12:14:31 <dolio> Okay, but it isn't built in.
12:15:02 <edwardk> companion_cube: yeah. i was the bottom up guy. aheller is the top-down guy. we figured I'd build a decent backing store, so I could do this on very large datasets and meet in the middle.
12:15:15 <edwardk> dolio: correct
12:15:36 <edwardk> you need a layout stack and a bit for beginning of line state
12:16:18 <edwardk> we have a working version with variant tabling that brian sniffen put together, but never got around to implementing full subsumptive tabling
12:16:19 <dolio> Well, I don't know about that. I was going for something really rough.
12:16:33 <dolio> Like, just enough to suggest indentation.
12:16:41 <edwardk> dolio: i was just referring to the version that was sitting in the old trifecta repo before i stripped it out
12:16:45 <edwardk> it only has a couple of bugs
12:16:50 <edwardk> they could be squashed pretty easily
12:16:51 <dolio> So I care more about tokenizing with just enough information to figure out some layout.
12:17:24 <edwardk> its just a matter of remembering what we fixed in the parsers we have for the scala-side ermine compiler and porting them bck
12:18:18 <edwardk> hen being a parser transformer it'd work with attoparsec, parsec, even whatever horrible semiparsing toy i come up with assuming i can make it work with parsers ;)
12:18:31 <dolio> edwardk: Maybe I'm even looking for Dyck-language structure of laid out code.
12:18:45 <dolio> Together with column positions of the opening brackets.
12:18:54 <edwardk> hence why i'm steering you towards parsers and a transformer =)
12:19:04 <Michael_> Is it a good idea to manipulate trees with the state monad, or should I just stick to zippers?
12:20:09 <edwardk> Michael_: that is a vague enough question that I can't really offer a reply that isn't too either too specific or too general to be useful ;)
12:21:41 <Michael_> edwardk: I'm sorry, I'll try to elaborate. I have a Data.Tree, and I'll be moving up and down it, and replacing different subtrees with other subtrees. Is it easier/better practice/faster to use zippers, or a state monad imperatively?
12:21:52 <edwardk> i tend to stick to zippers for that
12:22:01 <TallerGhostWalt> Howdy all
12:22:06 <Fuuzetsu> Sounds like exactly what you'd use a zipper for…
12:22:22 <TallerGhostWalt> Anyone have a best tutorial on GADT? Cause that be confusing stuff
12:22:32 <elliott> you can use a zipper in a state monad. they aren't mutually exclusive.
12:22:38 <Fuuzetsu> ‘Best’ is subjective, TallerGhostWalt.
12:22:39 <elliott> the zipper is just some state you've carrying around, after all.
12:25:44 <Peaker> TallerGhostWalt, http://www.reddit.com/r/programming/comments/1cbr34/what_i_wish_i_knew_when_learning_haskell/c9fhwhz?context=3
12:25:50 <TallerGhostWalt> lol
12:25:51 <Peaker> (GADT tutorial I wrote in a Reddit comment...)
12:25:54 <TallerGhostWalt> I was about to post that
12:26:00 <TallerGhostWalt> and say, like this
12:26:08 <TallerGhostWalt> but with a little more focus on GADT specifically
12:26:14 <Fuuzetsu> is there a non-reddit mirror?
12:26:33 <Peaker> TallerGhostWalt, you found that specific comment before I linked to it?
12:26:50 <Michael_> Okay, now besides the LYAH one, does anyone know of a good tutorial on zippers?
12:27:15 <Peaker> there's also this: http://www.haskell.org/haskellwiki/GADTs_for_dummies
12:27:18 <TallerGhostWalt> no, the 'what I wish I knew'
12:27:23 <TallerGhostWalt> dummies sounds promising
12:27:29 <Peaker> and this: http://www.haskell.org/haskellwiki/GADT
12:27:43 <TallerGhostWalt> i'll check out the comment though sorry I didn't click, just read
12:28:26 <mekeor> Michael_: google suggests http://en.wikibooks.org/wiki/Haskell/Zippers and http://www.haskell.org/haskellwiki/Zipper ;) :P
12:30:00 <quchen> Michael_: LYAH does a good job at explaining the idea behind zippers. I think state of the art of actually using them is what Lens offers.
12:30:41 <edwardk> we are splitting them out into a separate zippers package in the next release
12:30:53 <quchen> edwardk: A Lens subpackage?
12:30:56 <edwardk> yeah
12:31:15 <quchen> Will Lens in general be split in multiple packages? I heard rumors some time ago.
12:31:27 <Peaker> something I don't understand - is how a generalized notion of zippers (such as in lens) can have names like "left, right, up, down" when the structure can be arbitrary and have any number of "directions"?
12:32:07 <byorgey> Peaker: "the structure can be arbitrary and have any number of 'directions'" -- that's actually not true.
12:32:19 <edwardk> > rezip $ zipper ("hello","world") & downward _1 & fromWithin traverse & focus .~ 'j' & rightmost & focus .~ 'y'
12:32:22 <lambdabot>   ("jelly","world")
12:32:23 <byorgey> Any recursive algebraic data type has canonical notions of up, down, left, and right.
12:32:52 <edwardk> quchen: not in the large. but splitting out zippers allows us to explore them at a more rapid pace than the rest of the package and lets them have better names for their combinators since they aren't infesting everyone's local scope
12:33:06 <byorgey> though it's certainly possible you might want to think of your values are representing some abstract type with other notions of "direction"
12:33:24 <Peaker> byorgey, so up/down traverses deeper/shallower into the recursion, and left/right travel in between the same recursive layer?
12:33:35 <byorgey> Peaker: right.
12:33:51 <edwardk> quchen: the main focus with lens has been making it so you _can_ define things that work with the package without depending on it. in the last release we extended it so you can define getters and folds (and "Reviews") without incurring a dependency
12:33:52 <TallerGhostWalt> sweet thanks Peaker, this is perfect.
12:34:01 <Peaker> byorgey, I guess that can be generally useful, though surely for some zippers those kinds of directions are less useful
12:34:08 <Peaker> TallerGhostWalt, cool :)
12:34:19 <edwardk> but splitting up the package makes it much harder for users to use.
12:34:34 <quchen> edwardk: Oh, so Zippers won't even deptnd on Lens then?
12:34:40 <quchen> That sounds like I misread it :-)
12:34:42 <byorgey> Peaker: possibly.
12:34:48 <edwardk> As every position we could take on this issue will antagonize someone, I choose to please myself.
12:34:51 <Peaker> edwardk, because of an extra entry in the .cabal file
12:34:51 <Peaker> ?
12:35:14 <quchen> edwardk: I wish you were the Haskell' committee right now haha
12:35:21 <edwardk> Peaker: and extra import lines cluttering up every module they use, and complicated instructions about use these 4 packages but only use this one if you like template haskell and that one if you want a pony...
12:36:03 <Peaker> TallerGhostWalt, I think I failed to mention something important: With a GADT, your pattern matches may be "partial" (some constructor cases not matched) and that's OK if the type indices prove the unmatched patterns are impossible
12:36:50 <Peaker> edwardk, Well, you use the package that exports the names you need :)
12:37:03 <TallerGhostWalt> I am going to go have to look at some of my fav. libraries internals now and see how they are using them in practice to try and get a feel for what is going on given the new info.
12:37:12 <edwardk> zippers will depend on lens, but i meant in general with lens, rather than splintering it into multiple packages we've been trying to make it so you can make your code 'lens-ready' without needing to incur a dependency on lens, that way if you have an established package, its easy enough to add a combinator or two only using base that gives you a lens or traversal that can be used by users. or by incurring a dependency on
12:37:12 <edwardk>  profunctors, contravariant or bifunctors you can get isomorphisms, prisms, getters, folds, etc.
12:37:39 <edwardk> Peaker; it pains me that i am gradually approaching more lines of imports than lines of code in many of my packages.
12:37:53 <Peaker> edwardk, I just ignore import lines :)
12:37:55 <edwardk> that tells me there is something wrong with the grain size we're using ;)
12:38:08 <Peaker> I don't mind having messier imports if I have cleaner code as a result
12:38:13 <edwardk> lens is a reaction to that, that admittedly goes pathologically far in the opposite direction
12:39:20 <Fuuzetsu> and yet we still don't have a package that exports ‘safeHead’
12:40:16 <Ankhers> How would you implement 'safeHead'?
12:40:21 <typoclass> Fuuzetsu: listToMaybe, but the name is bonkers :-/
12:40:21 <frankbro> "The program happy version >=1.17 is required but it could not be found.", yet I have 1.18 installed. Wut do.
12:40:40 <Peaker> frankbro, likely happy isn't in your $PATH?
12:40:45 <elliott> Fuuzetsu: look at the safe package
12:40:46 <elliott> @hackage safe
12:40:46 <lambdabot> http://hackage.haskell.org/package/safe
12:40:54 <dmj> hey, trying to parse only the table portions out of html pages using parsec. Having issues if anyone cares to take a look
12:40:55 <dmj> http://hpaste.org/88110
12:40:58 <Fuuzetsu> oh, listToMaybe indeed
12:41:00 <edwardk> > [1,2]^?traverse
12:41:06 <frankbro> Oh wouldnt it take it from ~/.cabal/bin?
12:41:09 <lambdabot>   can't find file: L.hs
12:41:28 <Peaker> edwardk, 12% of my code lines are import lines
12:41:35 <Peaker> (overall in the project)
12:41:40 <Fuuzetsu> oh, it's frankbro!~
12:42:04 <dmwit> Ankhers: In almost all cases, I would write "safeHead = id".
12:42:06 <Peaker> And I tend to: import qualified Data.Map as Map ; import Data.Map (Map) ; and freely import tons of little modules
12:42:08 <mekeor> dmj: why parsec? there are html-parsers for haskell, faik :)
12:42:08 <typoclass> Fuuzetsu: for some reason i have an aversion to all the names from Data.Maybe. fromJust, catMaybes, listToMaybe ... they're are all odd :-)
12:42:08 <frankbro> Fuuzetsu, OH SHI-
12:42:32 <Peaker> typoclass, how would you call those?
12:42:45 <typoclass> Peaker: not sure!
12:42:52 <Fuuzetsu> typoclass: I think many people have an issue with coming up with satisfactory names, myself included…
12:42:55 <typoclass> Ankhers: easiest way would be pattern-matching? case-of?
12:42:57 <edwardk> Peaker: we've gone round and round on preferred import styles. i'll be honest, the subject holds very little interest for me ;)
12:44:05 <dmwit> dmj: In Parsec, "string" is not atomic, so your thParser commits as soon as it sees a '<'. This means tdParser will never, ever run (unless it couldn't possibly run anyway).
12:44:30 <Peaker> edwardk, sure thing, just wanted to throw a number at the claim to show that it's unlikely to become a majority of code even if you're as extremist as myself :)
12:44:46 <typoclass> Peaker: more seriously, i think it'd be worth discussing to remove fromJust entirely. catMaybes -> justs (to be symmetrical with Data.Either.rights and lefts). listToMaybe -> head' or even head
12:44:56 <edwardk> I write in a style that yields code that i find balances intelligibility and noise to my entirely 100% subjective opinion. ;) It apparently leaves me enough time to get a fair bit of code done, so I'm not in a hurry to dramatically alter that style to match, say, henning =)
12:45:30 <edwardk> if you remove fromJust i'll just write a package and import it =P
12:45:34 <Ankhers> dmwit, typoclass: I'm assuming the point of safeHead would be to prevent the error when passing in an empty list. If that is the case, you would want to pass back something that isn't an empty list. Else, you wouldn't be able to differentiate between [] and [[]]. Or am I completely missing something here?
12:45:53 <Peaker> edwardk, why not:  fromMaybe (error "why I truly believe this won't be Nothing") ?
12:46:03 <dmwit> Ankhers: You are missing something. [[]] is not an empty list.
12:46:17 <Fuuzetsu> Ankhers: safeHead [] = Nothing; safeHead (x:_) = Just x
12:46:34 <edwardk> > (length "fromMaybe (error \"why I truly believe this won't be Nothing\")", length "fromJust")
12:46:36 <Paprikachu> how can i write a function [String] -> String that picks a random string of the list?
12:46:36 <lambdabot>   (61,8)
12:46:45 <typoclass> Ankhers: oh :-) a misunderstanding. i was just thinking of safeHead :: [a] -> Maybe a
12:47:00 <Paprikachu> the problem is that random numbers are IO
12:47:05 <dmwit> Paprikachu: You can't. However, you can write something of type [String] -> Seed -> (String, Seed) or similar.
12:47:14 <edwardk> :t Data.Maybe.listToMaybe
12:47:16 <Fuuzetsu> Paprikachu: Make a separate function to grab a random number in range
12:47:16 <lambdabot> [a] -> Maybe a
12:47:17 <Ankhers> dmwit: I know. I'm just saying, if you returned an empty list when you pass in an empty list, then you would return an empty list when passing in [] and [[]]
12:47:21 <dmwit> Paprikachu: Alternately, as you mentioned, you can write something of type [String] -> IO String.
12:47:31 <dmwit> Ankhers: Incorrect.
12:47:36 <monochrom> Paprikachu: no, the real problem is that [String]->String cannot be random
12:47:39 <Ankhers> dmwit: how so?
12:47:49 <Peaker> typoclass, what would you call maybeToList ?
12:47:50 <dmwit> > (id [], id [[]])
12:47:54 <lambdabot>   ([],[[]])
12:48:01 <Paprikachu> how do i write that random function?
12:48:03 <dmwit> Ankhers: You see? My implementation of safeHead does not have the problem you name.
12:48:03 <typoclass> edwardk: sure, putting the stuff in its own module would be a possibility worth discussing. the same was done e.g. for System.IO.Unsafe
12:48:16 <Fuuzetsu> Paprikachu: Look at LYAH chapter on random numbers
12:48:24 <typoclass> Peaker: another good question!
12:48:25 <elliott> I would call maybeToList head
12:48:31 <edwardk> typoclass: there is a HUGE difference between unsafePerformIO and something that invokes error.
12:48:34 <elliott> or nothing. accessor functions are the devil.
12:48:45 <fizbin> Ankhers: What do you imagine is the type of safeHead?
12:48:48 <Fuuzetsu> Does anyone know what's going to happen with LYAH? The domain expires in August.
12:48:49 <dmwit> Ankhers: Alternately: what are the *types* of the [] and [[]] you are proposing returning?
12:48:50 <Peaker> elliott, listToMaybe is "head", maybeToList is ?
12:48:56 <dmwit> Ankhers: Yes, what fizbin said. =)
12:49:07 <Ankhers> dmwit: Unless I am missing something, that is not actually returning the head of the list though..
12:49:12 <elliott> Peaker: oh
12:49:13 <edwardk> one steps outside of the reasonable semantics of the language, the other is no more egregious than you can already define by omitting a case in a case statement.
12:49:14 <typoclass> edwardk: it was just an example. i didn't mean that fromJust warrants an "unsafe" in the name
12:49:18 <dmwit> Ankhers: It certainly is! And the tail, too.
12:49:21 <Peaker> unhead?
12:49:24 <elliott> Peaker: I've never had the occasion to use maybeToList. it strikes me as too niche to exist
12:49:32 <Peaker> elliott, I use it all the time
12:49:32 <elliott> unhead is as good a name as any
12:49:33 <Ankhers> > id [1,2]
12:49:35 <lambdabot>   [1,2]
12:49:47 <elliott> behead :)
12:49:48 <Peaker> elliott, I have a bunch of Maybe's that I want to treat as 0/1 lists and accumulate up
12:49:51 <edwardk> elliott: hahaha
12:49:57 <elliott> because it makes the parameter be the head of its result
12:49:58 <edwardk> elliott: that belongs as a lens combinator ;)
12:49:59 <dmwit> elliott++ for this wonderful pun
12:50:02 <Peaker> behead is nice :-)
12:50:37 <Fuuzetsu> tail should be aliased to behead
12:50:40 <dmwit> :t traverse return
12:50:41 * monochrom proposes: unhead x = x:⊥. this has a good chance of being in Galois connection with head.
12:50:42 <typoclass> betail
12:50:43 <lambdabot> (Monad f, Applicative f, Traversable t) => t b -> f (t b)
12:50:51 <Ankhers> fizbin: I would probably write it as [a] -> Maybe a
12:50:52 <dmwit> > traverse return (Just 3) :: [Int]
12:50:55 <Ankhers> but I'm a newb...
12:50:57 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:50:57 <lambdabot>              with actual type ...
12:51:28 <fizbin> Ankhers: Ah, then it's fine and safeHead [] = Nothing, but safeHead [[]] = Just []
12:51:35 <dmwit> Ankhers: Here's my argument: what are you going to do with a Maybe a? Chances are pretty good you'll either pattern match on it (in which case why not pattern match on a list instead?) or call "maybe" (in which case why not call map or foldr?).
12:51:41 <Paprikachu> how can i apply show on a IO (Maybe String)?
12:51:54 <dmwit> Ankhers: The only time Maybe a is a *better* return type is when there is some third-party library which requires a Maybe as input.
12:52:13 <dmwit> Paprikachu: You can't. But you can lift show into the IO monad with fmap.
12:52:16 <monochrom> a case analysis shows that you need a case analysis :)
12:52:21 <dmwit> :t fmap show :: Show a => IO a -> IO String
12:52:24 <lambdabot> Show a => IO a -> IO String
12:52:42 <elliott> dmwit: well, maybe x f . listToMaybe is uglier when written with foldr
12:52:43 <monochrom> Ankhers: see my http://www.vex.net/~trebla/haskell/crossroad.xhtml
12:53:39 <fizbin> dmwit: are you arguing for the total elimination of Maybe?
12:53:50 <dmwit> elliott: Can be. Depends a lot on what x and f are. All I'm saying is that since I've taken on the personal challenge of treating my lists as things that shouldn't be coerced to Maybe's, I've been very pleasantly surprised with how far you can push things.
12:54:04 <carter> dmwit byorgey : for hacphi wasn't there some upenn discount for the hotel?
12:54:09 <dmwit> fizbin: Not quite. There are a few unusual cases where you really want your type to say that you *cannot* have more than one value.
12:54:09 <carter> at least last year ...
12:54:12 <dmwit> But it's quite rare.
12:54:13 <carter> is that still the case?
12:54:15 <monochrom> I think dmwit is arguing for the total elimination of XY problems. and I fully support it.
12:54:22 <Ankhers> dmwit: I completely agree, I just fail to understand how 'safeHead = id' will actually return the head...
12:54:34 <fizbin> dmwit: I like Maybe's Alternative instance.
12:54:36 <dmwit> Ankhers: How does it avoid returning the head? =)
12:54:46 <fizbin> More than I like the [] Alternative instance.
12:54:51 <carter> dmwit byorgey : or is there no longer the upenn club quaters hotel discount?
12:55:16 <elliott> dmwit: map lookup is quite common
12:55:17 <Ankhers> dmwit: it returns whatever you pass into it, so in a list of [1,2,3] I would have the list returned, and not 1.
12:55:22 <elliott> and suits Maybe better
12:55:28 <dmwit> carter: I don't think we set up the discount this year. (We didn't last year, either, but people seemed to be able to get it anyway, so we didn't bother.)
12:55:39 <carter> you told use to mention it though
12:55:41 <carter> ok
12:55:43 <dmwit> elliott: filter is a fine replacement for lookup.
12:55:43 <carter> i'll call and see if i can do that
12:55:45 <elliott> Ankhers: and listToMaybe [1,2,3] returns Just 1 not 1
12:56:10 <elliott> dmwit: for things like Data.Map??
12:56:23 <dmwit> Ankhers: It returns 1. It also returns 2 and 3.
12:56:53 <dmwit> elliott: Right. As I said, there are a few times when you want the type to say that there's exactly one returned value.
12:57:03 <Paprikachu> https://ideone.com/YBWeRF can someone explain this to me?
12:57:07 <dmwit> elliott: I will note that you *still* don't need listToMaybe (or safeHead or whatever you want to call it) there.
12:57:12 <elliott> right
12:57:16 <typoclass> dmwit: i'm confused as well. i'm not sure how id is an implementation of safeHead that is in any way cool
12:57:38 <dmwit> I find people's lack of imagination here disappointing.
12:57:44 <dmwit> In what way is "safeHead = id" uncool??
12:57:52 <elliott> :(
12:58:15 <dolio> The point is that safeHead is useless unless you have something else that specifically wants a Maybe.
12:58:16 <typoclass> dmwit: you should call it safeId or something. i don't think it does what head does
12:58:26 <Fuuzetsu> because it's not called ‘safeHeadAndTheRestOfTheListToo!’
12:58:35 <typoclass> dolio: oh i see. yeah that's of course true
12:58:36 <dmwit> It's not *supposed* to do what head does. head isn't safe.
12:58:40 <Ankhers> dmwit: I think my confusion stems from the fact that I was expecting safeHead to return ONLY the head element, and gracefully fail if you pass in an empty list.
12:59:00 <dmwit> Ankhers: Laziness means returning more is always okay.
12:59:30 <dolio> I don't agree with dmwit if he thinks that I want to return 0 or more things more often thatn 0 or 1 thing, though.
12:59:31 <typoclass> dolio: in other words, "if i pattern-match on Just and Nothing, i might just as well pattern-match on [x] and _"
12:59:34 <Ankhers> dmwit: and with that... the light bulb went off... Thank you sir.
13:00:04 <elliott> typoclass: um no!
13:00:06 <elliott> x:_
13:00:09 <dmwit> dolio: Yeah, I'm not really arguing that Maybe is a code smell, only that listToMaybe is.
13:00:39 <typoclass> dmwit: agreed
13:00:44 <carter> dmwit byorgey  i'll see if i can social engineer the discount
13:00:52 <carter> would be easier if you guys set it up though
13:00:52 <dolio> dmwit: Yeah. Although for_ . listToMabe is okay, I guess. But for_ . take 1 is shorter.
13:00:53 <Fuuzetsu> it's easier in a monad chain to write listToMaybe xs than to match on it and then return a Nothing
13:00:55 <typoclass> elliott: ah yeah sure
13:01:05 <Paprikachu> https://ideone.com/YBWeRF can someone explain this to me please? :I
13:01:11 <dmwit> Fuuzetsu: Perhaps your outer monad ought to be [], too. =)
13:01:38 <dmwit> Paprikachu: It picks a random element from a list.
13:01:47 <dmwit> Paprikachu: Also, it's broken.
13:01:49 <Paprikachu> i mean the error message...
13:01:54 <dmwit> Paprikachu: You might like one of the tutorials, see
13:01:57 <dmwit> ?where tutorials
13:01:57 <lambdabot> http://haskell.org/haskellwiki/Tutorials
13:02:09 <Paprikachu> i don't want a tutorial, i want my program to work :I
13:02:17 <Fuuzetsu> Paprikachu: your type is messed up
13:02:21 <Fuuzetsu> :t show
13:02:23 <lambdabot> Show a => a -> String
13:02:25 <Fuuzetsu> :t fmap show
13:02:27 <lambdabot> (Functor f, Show a) => f a -> f String
13:02:50 <dmwit> Paprikachu: Are you sure privmsg is meant to be applied to an IO String? That looks like something that should be applied to a boring String.
13:02:54 <Fuuzetsu> :t fmap show :: Show a => IO a -> IO String
13:02:56 <lambdabot> Show a => IO a -> IO String
13:02:59 <typoclass> Paprikachu: check the type of privmsg. try ":t privmsg" in ghci, or look it up in the docs
13:03:02 <dmwit> Paprikachu: If so, you'll need to teach it how to handle an IO string using (>>=).
13:03:17 <Paprikachu> privmsg needs a String
13:03:18 <dmwit> Paprikachu: e.g. rchoice opts >>= privmsg h ch . show -- seems pretty likely to me
13:03:52 <typoclass> Paprikachu: there we go. that's what the error message means -- expected type String, actual type IO String
13:04:00 <Paprikachu> see, i have a random string and i want to pass it to privmsg
13:04:18 <carter> byorgey dmwit  you need to get a group code
13:04:22 <carter> byorgey dmwit  you need to get a group code
13:04:28 <carter> byorgey dmwit  please :)
13:05:14 <carter> else its ~ 150 more for the trip needlessly
13:05:19 <carter> or something
13:06:05 <dmwit> Alright. I'll look into it Monday. Chances are it's a bit late to get that organized for this year, but we can put it back on the list for next year.
13:06:14 <carter> ok
13:06:26 <carter> please give me a heads up on whether its doable
13:06:28 <carter> or not
13:06:28 <dmwit> I vaguely recall that the problem with the group code is that we have to predict how many people will use it, and UPenn has to pay if we predict wrongly.
13:06:50 <carter> well,
13:07:03 <carter> predict one and only tell me the code
13:07:14 <monochrom> hehe
13:07:16 <carter> or find out if anyone else hasn't booked hotel yet by emailing them explciitly
13:07:19 <dmwit> (...so it's not like there's just free money lying on the ground to pick up, is all I'm saying.)
13:07:26 <carter> yes
13:07:28 <carter> hence
13:07:34 <carter> find out the exactl number of people who've not booked yet
13:07:38 <carter> who've emailed you
13:07:46 <carter> and who'd use the code
13:07:53 <carter> then you don't have to pay..
13:07:58 <carter> or am i mis understanding?
13:08:00 <carter> :)
13:08:21 <monochrom> you're saying: don't predict. control.
13:08:28 <carter> i can handle paying the diff, its just i'd rather not because i'm in a lull between consulting /other revenues
13:08:30 <carter> monochrom yes
13:08:33 <carter> prediction is hard
13:08:38 <carter> dont do it
13:08:46 <carter> FIAT the stuff into being exact :)
13:09:39 <monochrom> it is like PRNG in haskell
13:09:56 <merijn> FIAT?
13:10:00 <dmwit> ?wn fiat
13:10:01 <lambdabot> *** "fiat" wn "WordNet (r) 3.0 (2006)"
13:10:01 <lambdabot> fiat
13:10:01 <lambdabot>     n 1: a legally binding command or decision entered on the court
13:10:01 <lambdabot>          record (as if issued by a court or judge); "a friend in New
13:10:01 <lambdabot>          Mexico said that the order caused no trouble out there"
13:10:03 <lambdabot>          [syn: {decree}, {edict}, {fiat}, {order}, {rescript}]
13:10:16 <dmwit> Basically, force, in this context, I think.
13:10:21 <Eduard_Munteanu> Or as in run over by a Fiat? :P
13:10:57 <merijn> Anyone happen to know where I can learn more about row types?
13:11:15 <monochrom> "dear carter, here is the group code, now use it and purchase. or else: you will be run over by a Fiat"
13:11:23 <carter> that too
13:11:37 <carter> merijn how to use them or implement them?
13:11:59 <carter> dmwit yes "X, make it so"
13:12:26 <merijn> carter: Just an overview, Ur mentions that it supports "a powerful kind of metaprogramming based on row types." but I have no clue what that means :p
13:12:42 <dmwit> Perhaps you should read the Ur papers!
13:12:46 <carter> yes!
13:12:56 <Eduard_Munteanu> Papyrii?
13:13:17 <carter> merijn one neat thing you can do with row types is be able to describe the type of code with free variables
13:13:17 <merijn> dmwit, carter: Crazy talk!
13:13:39 <carter> so you can use row types to give precise types to closure converted code
13:13:42 <dmwit> Either the Ur paper will describe row types, or it will cite one that does.
13:13:48 <carter> that too
13:13:53 <mekeor> does "Writer Foobar ()" make any sense?
13:13:57 <Eduard_Munteanu> Straightforward induction on papers.
13:14:07 <dmwit> mekeor: Yes, whenever Foobar is a monoid.
13:14:09 <Eduard_Munteanu> mekeor: sure
13:14:16 <byorgey> surely the Ur-Paper does not cite anything.
13:14:28 <mekeor> cool! thanks :) i think that's what i need :)
13:14:53 <elliott> mekeor: Writer Foobar () is just Foobar
13:15:09 <elliott> except you can use do notation which is sometimes nice. but make sure Foobar won't work first
13:15:13 <monochrom> sounds like the paper induction hits the base case immediately :)
13:15:19 <applicative_tmp> it cites the Ur book, books having preceded papers
13:15:48 <mekeor> elliott: won't work? ah you mean, okay, got it. yeah, i am actually aiming at do-notation ;) :)
13:15:58 <shachaf> Writer is just (,)
13:15:58 <Eduard_Munteanu> Ur book describing ur row types!
13:16:02 <carter> thers anhttp://www.impredicative.com/ur/resources.html
13:16:09 <monochrom> I like do-notation
13:16:15 <mekeor> shachaf: :P i tried that too, but i want do-notation! :D
13:16:25 <Eduard_Munteanu> Identity Foobar :)
13:16:31 <shachaf> monochrom: Then you'll love BlazeHtml!
13:16:43 <byorgey> applicative_tmp: ah, of course
13:16:56 <mekeor> Eduard_Munteanu: can i use do-notation with that? O.o
13:17:03 <applicative_tmp> BlazeHtml is the way forward
13:17:09 <Eduard_Munteanu> mekeor: sure, it's the Identity monad :)
13:17:13 <shachaf> mekeor: What's with all the smiley faces?
13:17:25 <monochrom> :)
13:17:29 <dmwit> It was the best of IRC. =) It was the worst of IRC. =(
13:17:32 <carter> fryguybob stm notes, neat
13:17:33 <Eduard_Munteanu> I wonder that too ^_^
13:17:34 <applicative_tmp> :) :) :) You don't have to render them shachaf
13:17:34 <Eduard_Munteanu> :P
13:17:35 <Fuuzetsu> shachaf hates people having fun
13:17:40 <monochrom> I like smileys :)
13:17:45 <dmwit> They're so easy!
13:17:46 <mekeor> shachaf: i'm in fact trying to write something like blaze-html, but not for html but for my personal layout.
13:17:48 <quchen> @botsnack
13:17:48 <lambdabot> :)
13:17:49 <carter> fryguybob stm notes, neat
13:18:12 <applicative_tmp> carter: oh, what is he working on?
13:18:27 <carter> applicative_tmp http://fryguybob.github.io/STM-Commentary/
13:18:30 <applicative_tmp> I new he had gone 'academic'
13:18:45 <carter> which should be merged into the dev wiki at some point i imagine
13:18:49 <mekeor> shachaf: i want something like this: http://hpaste.org/88108
13:19:22 <applicative_tmp> yipe, its about how the rts manages stm things?, carter
13:19:40 <carter> applicative_tmp i don't understand your question
13:19:49 <carter> say it again wiht different words please
13:19:59 <carter> dmwit anyways, let met know once you know
13:20:06 <merijn> carter: Well, yes, that's exactly the page I was looking at, hence why I wanted to learn something about row types before diving in. But I guess I should just read the Ur stuff
13:20:33 <carter> merijn googling row types would work too
13:20:41 <applicative_tmp> carter oh, its just my brain froze upon reading 'This document give an overview of the runtime system (RTS) support for GHC's STM implementation. We will focus on the case where fine grain locking is used (STM_FG_LOCKS).
13:20:48 <merijn> Googling? Pfft, how 00s
13:20:52 <applicative_tmp> that was longer than it seemed
13:21:14 <merijn> In my experience Google is terrible for finding starting points for papers, I prefer knowledgable suggestions from humans :p
13:21:19 <carter> merijn true
13:21:25 <carter> in this case, idk if theres a good one
13:21:48 <carter> the vinyl lib by jon sterling is a cute in haskell row types lib
13:21:50 <carter> thats pretty nice
13:22:09 <monochrom> TaPL explains row types. it is not long. because row type is not long.
13:22:27 <carter> yeah
13:22:31 <carter> the basic idea is pretty nice
13:22:43 <merijn> I still haven't looked at TaPL, bad me >.<
13:23:02 <dmwit> Oh, mekeor's already gone.
13:23:03 <dmwit> ah well
13:23:06 <monochrom> then again, TaPL makes a short story long.
13:23:11 <merijn> Completely unrelated, as the STM discussion reminded me...where to suggest RTS changes? libraries@ or somewhere else?
13:23:18 <applicative_tmp> monochrom: yes.
13:23:41 <dmwit> The expert's short story is the novice's novel.
13:24:25 <merijn> No one?
13:24:30 <dmwit> I think I may not have survived my first year if TaPL had been much more compact.
13:24:42 <applicative_tmp> somehow TaPL's novels on Objects and Subtypes and what-all ...
13:24:57 <dmwit> merijn: I have to imagine there is a ghc development mailing list...
13:25:01 <applicative_tmp> might have been replaced with witty appendices, say
13:25:19 <dmwit> merijn: There's probably a page on their wiki telling new developers where to suggest the changes they're going to make, in fact.
13:25:22 <carter> merijn rts changes go on in ghc-dev
13:25:22 <merijn> dmwit: ghc-dev, I know it exists, but I dunno whether that is more suitable than libraries@
13:25:28 <carter> lib changes for libs
13:25:44 <merijn> dmwit: I wasn't going to change anything, I was going to suggest something and hope someone will do it for me :p
13:25:47 <applicative_tmp> merijn: you use the trac, no??
13:25:58 <carter> merijn : getting the ok to start work  on making the CAS primop awesomer was done on ghc-devs
13:26:01 <carter> when i asked a week or so ago
13:26:02 <dmwit> For that, yes, Trac.
13:26:10 <carter> wont' work on it till next month though
13:26:13 <carter> merijn what change?
13:26:27 <applicative_tmp> he wants to rewrite the rts in haskell
13:26:44 <carter> bad idea, use cmm instead
13:26:46 <merijn> "threadWaitError :: Fd -> IO ()" and "threadWaitReadSTM, threadWaitWriteSTM, threadWaitErrorSTM :: Fd -> STM ()"
13:26:48 <carter> would be much saner
13:27:12 <dmwit> um
13:27:14 <carter> well, crazy
13:27:16 <carter> but saner
13:27:25 <dmwit> Waiting on Fd's doesn't sound particularly STM-like to me.
13:27:34 <merijn> The former is to give you access to the error set of select (as someone needed in here earlier this week) and the latter would retry unless the Fd is readable/writeable/error
13:27:51 <carter> merijn write an implementation please
13:27:52 <bitonic> in this talk: <http://www.youtube.com/watch?v=YScIPA8RbVE>, the guy talks of ‘a mathematicians in Glasgow’ establishing the conditions for certain operations to be OK in the context of the algebra of abstract data types, but I can’t really hear the name.  My guess would be Conor McBride but I can’t find anything in his publications
13:27:55 <carter> so we understand what you want
13:28:16 <merijn> dmwit: Well, they would let you write polling between TChan's and, for example, sockets
13:28:33 <dmwit> Sockets don't sound particularly STM-like to me, either.
13:28:39 <merijn> dmwit: They're not
13:28:44 <merijn> dmwit: Hence, STM ()
13:28:49 <mauke> socket transactional memory
13:28:53 <dmwit> ...huh?
13:28:59 <monochrom> merijn: googling "row polymorphism" may help. try this: http://www.cs.cmu.edu/~aldrich/courses/819/slides/rows.pdf
13:29:11 <dmwit> bitonic: You should say a time!
13:29:16 <int-e> mauke: silly transactional modem?
13:29:25 <mauke> socket transfer messages
13:29:31 <merijn> carter, dmwit: Checking whether an Fd is readable/writable/error is clearly idempotent, so it should be no problem to do that in STM code
13:29:32 <bitonic> dmwit: oh yes.  one sec...
13:29:42 <carter> merijn then write it for us :)
13:29:46 <tedmiddleton> Hey - can I ask a newbie question? I'm learning Haskell and I'm a bit confused about how I would do something with a typeclass
13:29:57 <merijn> carter: I don't know how STM is implemented, so I don't know! >.<
13:30:01 <dmwit> ?where justask
13:30:01 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
13:30:03 <bitonic> dmwit: 34:24
13:30:03 <ReinH> if I have a list of Maybes, how can I extract the values of all the Justs?
13:30:11 <carter> merijn then i don't understand your claim of easy
13:30:20 <typoclass> tedmiddleton: sure :-) don't worry
13:30:39 <carter> merijn its easy to learn stm
13:30:41 <carter> do it
13:30:42 <merijn> carter: I said "no problem", I didn't say easy
13:30:42 <ReinH> I can think of a few ways I don't like :)
13:30:52 <dmwit> :t catMaybes
13:30:58 <lambdabot> [Maybe a] -> [a]
13:30:59 <carter> merijn also: ghc doesn't like nested STM
13:31:01 <carter> so those types can't work
13:31:11 <carter> and i don't see how theres STM in those ops
13:31:25 <carter> you could write them with some busy wait loops in CMM over teh c ffi's
13:31:29 <carter> and thatd be good enoguh
13:31:36 <merijn> Essentially what I'd want to write is "(threadWaitReadSTM fd >> return Nothing) <|> Just `fmap` readTChan chan"
13:32:00 <merijn> Then if you get Nothing, you know you can read from fd
13:32:03 <ReinH> dmwit: yeah, I was doing concat $ map maybeToList, but ofc there's catMaybes if I look a bit further :)
13:32:06 <ReinH> dmwit: thanks
13:32:09 <merijn> I don't know how/why you'd need to nest STM?
13:32:36 <carter> merijn doesnt matter
13:32:50 <carter> also youre not asking for something that needs stm
13:33:19 <merijn> carter: I'm not saying they need STM, I'm saying I want a way to plug my STM code into the runtime's IO blocking
13:33:29 <carter> explain more please?
13:33:33 <benj__> Hi, I have a question abou the recursion that is used in haskell... If I have a function called length that simply returns the length of a list, it is written recursively. But if i want the length of [1,3..600] I have to call length 300 times.. I know in other languages this would be considered bad practice, what is haskells view?
13:33:34 <merijn> carter: Ok, explain how to write my example code 5 lines up
13:33:41 <merijn> (threadWaitReadSTM fd >> return Nothing) <|> Just `fmap` readTChan chan
13:33:45 <carter> which code?
13:33:46 <merijn> Without busy-waiting, that
13:33:48 <carter> ok
13:33:56 <carter> can't you lift an io op into stm?
13:34:03 <merijn> No
13:34:03 <carter> or something?
13:34:11 <merijn> That's explicitly not allowed
13:34:15 <Hafydd> benj__: taking the length of a linked list is necessarily going to take O(length) time.
13:34:23 <carter> unsafeperformIO says you can
13:34:24 <carter> :)
13:34:41 <merijn> carter: The docs say using unsafePerformIO inside STM basically breaks all guarantees
13:34:43 <Fuuzetsu> benj__: Making a function call hasn't been considered expensive since 1980s
13:34:47 <benj__> but doesnt it include 300 function calls?
13:34:52 <Cale> benj__: There's no way that you can hope to do any better than that in terms of time.
13:34:54 <carter> merj i think thats for when you put STM in STM
13:34:56 <carter> not for other things
13:35:04 <applicative_tmp> benj__: you are thinking it ought to be able to inspect the [1,3..12] or whatever and do the math, so to say?
13:35:13 <Fuuzetsu> Also, the compiler can optimise it away
13:35:14 <Hafydd> benj__: moreover, recursion is not as expensive in Haskell as you think.
13:35:20 <dmwit> merijn: I don't think you and I are using the same definition of idempotent. But it doesn't matter, because idempotent isn't the relevant part of STM anyway; only affecting memory is the important part.
13:35:22 <merijn> carter: Regardless, those are still nice primitives to have that you don't want to have people brokenly implement
13:35:26 <Cale> benj__: It does take O(length xs) time to compute length xs, but this is a fundamental property of linked lists, and can't be helped.
13:35:30 <carter> true
13:35:51 <Cale> benj__: If you need to be able to compute lengths more quickly than that, lists are a bad choice of datastructure.
13:36:09 <Cale> benj__: You should think of lists as being like loops
13:36:22 <merijn> dmwit: idempotent commonly means that running an action once has the same effect as twice, in this case I mean that it's not a problem if you "retry" threadWaitReadSTM
13:36:23 <benj__> ok
13:36:41 <Cale> Just as a loop in an imperative language either doesn't happen at all (because its precondition isn't met) or consists of a single iteration followed by another loop
13:36:42 <benj__> why are recursion calls not expensive in terms of CPU time?
13:36:48 <dmwit> merijn: But it does not have the same effect when you run it twice. =)
13:36:56 <Cale> A list is either empty, or consists of a single element followed by another list.
13:37:06 <merijn> dmwit: Shush, you get what I mean
13:37:11 <Cale> benj__: Why should they be considered expensive?
13:37:23 <dmwit> merijn: No. My point is that I don't get what you mean.
13:37:34 <merijn> dmwit: What's not to get?
13:37:40 <Cale> benj__: They take a small and roughly constant amount of time each
13:37:46 <applicative_tmp> arent there more and less moronic ways of defining length
13:38:13 <Cale> benj__: Though, there's also the fact that we have no call stack, which helps, I suppose.
13:38:14 <merijn> dmwit: "threadWaitReadSTM fd" should be retry until the moment that fd becomes readable
13:38:16 <Fuuzetsu> applicative_tmp: There are more moronic ways to do anything.
13:38:19 * applicative_tmp is imagining an insane definition with STRefs
13:38:24 <applicative_tmp> Fuuzetsu: true
13:38:25 <benj__> I was taught that in languages like java, that recursive calls could crash the stack
13:38:37 <simpson> benj__: Correct.
13:38:40 <Fuuzetsu> benj__: Java doesn't do TCO
13:38:43 <merijn> dmwit: i.e. in my example, the entire thing retries until either the fd is readable *or* the read from TChan succeeds
13:38:46 <benj__> what is that?
13:38:48 <applicative_tmp> Fuuzetsu: I was thinking a strict left fold might hold hope of getting reduced to a simple loop
13:38:50 <Fuuzetsu> google.com
13:38:56 <simpson> Fuuzetsu: That's not why Haskell wins here though.
13:39:02 <Fuuzetsu> simpson: I know~
13:39:15 <dmwit> merijn: I guess what I'm not understanding is why you would do that. You can't read from the Fd inside the transaction, so it's still a race. So what's the point?
13:39:18 <Cale> benj__: Tail call optimisation
13:39:19 <merijn> dmwit: Otherwise polling between sockets/files and haskell chans is *really* painful, if not impossible
13:39:19 <simpson> benj__: Every time you make a call in some languages, the *call stack* is pushed; when that stack overflows, you're toast.
13:39:20 <Fuuzetsu> applicative_tmp: I'm pretty sure the standard definition already will
13:39:27 <merijn> dmwit: I *want* to race
13:39:33 <simpson> benj__: However, GHC doesn't use a call stack! :3
13:39:38 <dmwit> merijn: Uh, what.
13:39:38 <Fuuzetsu> I'm not willing to bet money though. You could compile with -O2 and check
13:39:46 <benj__> ok..
13:39:46 <Cale> Tail call optimisation actually kind of doesn't even apply to the kind of evaluation mechanisms which Haskell implementations tend to use
13:39:54 <benj__> I am going to look into TCO, thanks
13:39:58 <Cale> Because there's no call stack to optimise
13:40:00 <merijn> dmwit: I want to poll multiple communication channels, the fact that I can't read fd in STM doesn't matter
13:40:19 <dmwit> bitonic: I'm not sure. I was going to point you at the "Seven trees in one" paper, but it sounded like a name that started with 'T'.
13:40:24 <merijn> dmwit: The key thing I want is *block until any relevant communication channel is ready*
13:40:45 <Cale> benj__: We *do* have a stack in GHC-compiled programs, but it isn't a call stack. It's a stack of pattern matches which are waiting for their scrutinee to be sufficiently evaluated to match a pattern.
13:40:48 <merijn> dmwit: Do you wanna see how awful my current code to attempt the same thing is?
13:40:52 <dmwit> merijn: But when the transaction commits, you *still* won't know it's ready!
13:41:24 <merijn> dmwit: Why not?
13:41:30 <bitonic>  dmwit: and also, Andreas Blass is not in Glasgow :P
13:41:34 <Cale> benj__: It's important to understand that lazy evaluation is outermost-first rather than innermost-first like you'd be used to from Java or really most other languages.
13:41:34 <dmwit> Because you're racing! Some other thread may have already read.
13:41:49 <merijn> dmwit: "So Don't Do That, Then"
13:42:07 <merijn> dmwit: Just getting it working in the simple case with 1 thread would be a massive improvement
13:42:39 <dmwit> Write a thread that reads from the Fd in a blocking way and writes to an STM channel.
13:42:42 <dmwit> NEXT!
13:43:44 <merijn> dmwit: I wanted this while writing ZMQ code, ZMQ sockets are not threadsafe so I can't read/write the socket in different threads
13:44:00 <merijn> dmwit: i.e. a separate reading thread for the socket is not possible
13:44:14 <dmwit> bitonic: But see page 4 which cites several other people discussing similar results.
13:44:15 <Paprikachu> > show "Æᨹ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ"
13:44:15 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
13:44:23 <Cale> benj__: Also, the mentality of worrying a lot about performance before you have a program which definitely runs too slowly is a bad approach to things. It's always more useful to be able to say *this* program runs too slowly, so that you can sensibly ask why. Often the answer won't be what you might've though.
13:44:25 <bitonic> dmwit: OK, I’ll take a look, thanks
13:44:26 <Cale> thought*
13:44:31 <merijn> Paprikachu: lambdabot doesn't accept unicode
13:44:44 <dmwit> < show "Æᨹ䉎䮡蜭余㱒ὢ䉎䮡"
13:44:48 <goodfellow>   mueval-core: Time limit exceeded
13:44:50 <Paprikachu> aww :(
13:44:51 <dmwit> < show "Æᨹ䉎䮡蜭余㱒ὢ䉎䮡"
13:44:54 <goodfellow>   "\"\\198\\6713\\16974\\19361\\34605\\20313\\15442\\8034\\16974\\19361\""
13:44:57 <Cale> haha
13:45:01 <dmwit> lambdabot does, just lambdabot doesn't.
13:45:08 <Paprikachu> < show "Æᨹ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ䉎䮡蜭余㱒ὢ"
13:45:09 <goodfellow>   "\"\\198\\6713\\16974\\19361\\34605\\20313\\15442\\8034\\16974\\19361\\3460...
13:45:10 <Cale> Seems goodfellow has the same problem lambdabot was having
13:45:32 <dmwit> goodfellow has a different problem: the first few runs of mueval when I boot time out.
13:45:32 <Taneb> < "hello" . traversed . index 3
13:45:33 <goodfellow>   Ambiguous occurrence `index'
13:45:33 <goodfellow>  It could refer to either `Control.Lens.Indexe...
13:45:38 <dmwit> After the first few runs, everything goes fine.
13:45:38 <Taneb> < "hello" ^. traversed . index 3
13:45:39 <goodfellow>   Ambiguous occurrence `index'
13:45:40 <goodfellow>  It could refer to either `Control.Lens.Indexe...
13:45:40 <Cale> huh, okay :)
13:45:51 <Taneb> < "hello" ^.. traversed . indices (==3)
13:45:52 <goodfellow>   Ambiguous occurrence `indices'
13:45:53 <goodfellow>  It could refer to either `Control.Lens.Inde...
13:45:58 <dmwit> However, since I boot just about every day, because this is a laptop... =P
13:46:00 <Cale> dmwit: You might try looking in watchdog.hs for the weird extra fixed timeout.
13:46:01 <Taneb> ...
13:46:08 <merijn> dmwit: My current solution uses async exceptions for bidirectional communication with a socket. This means running all my code in an uninterruptibleMask and then temporarily switching to interruptible mask in the code that blocks on reading in the socket. Not pretty, nor easy to check for correctness
13:46:22 <Cale> (in mueval's source)
13:46:35 <dmwit> Cale: Or you might try applying my patches! ;-){
13:46:38 <edwardk> > "hello"^..traversed.index 3
13:46:41 <lambdabot>   Couldn't match expected type `p0 GHC.Types.Char (Control.Lens.Internal.Gett...
13:47:07 <dmwit> merijn: It sounds awful. I'm terribly sorry.
13:47:09 <Cale> dmwit: Sorry, which one did I miss?
13:47:19 <Paprikachu> https://ideone.com/pJ3QWt any tips how i can make my code more "haskellish"? i'm coming from c++.
13:47:20 <edwardk> > "hello"^..traversed.Lens.index 3
13:47:24 <lambdabot>   "l"
13:47:27 <simpson> Hey, GHC in "interpreted" mode actually compiles to bytecode and runs that in a VM, right? Are there any docs on that machine's design?
13:47:28 <dmwit> Cale: I sent it like a month ago. -_-
13:47:42 <Fuuzetsu> simpson: the GHC docs/source?
13:48:02 <merijn> hpastebot seems dead?
13:48:03 <Cale> dmwit: I seem to recall applying something from you. Was it a mueval patch?
13:48:07 <merijn> dmwit: Witness the beauty! http://hpaste.org/88112
13:48:15 <edwardk> simpson: there is some stuff in the code commentary, but the machine itself is quite simple because it can always invoke native thunks as well
13:48:21 <Fuuzetsu> Paprikachu: I wouldn't say using ‘!!’ is very Haskellish at all.
13:48:29 <Cale> dmwit: (Because if so, then I might've just blown it away with all the fiddling around that I did)
13:48:30 <dmwit> Cale: It was a patch to import Data.Universe.Instances (and a qualified import for Data.Universe). So, yeah, *sort of* a mueval patch.
13:48:38 <dmwit> Let's see if it's in there.
13:48:42 <dmwit> > U.universe :: [()]
13:48:45 <lambdabot>   Not in scope: `U.universe'
13:49:07 <Cale> Oh, okay, I can add that to Pristine/L.hs
13:49:24 <Fuuzetsu> at least not for constant numbers
13:49:24 <dmwit> It requires a little fiddling, as I recall. Should I try to dig it up and resend it?
13:49:42 <Paprikachu> Fuuzetsu: obviously, the next step would be to write a parser for that.
13:49:55 <Paprikachu> it was just quick&dirty.
13:50:17 <Cale> dmwit: Why would it be any more complicated than installing the package?
13:50:29 <Fuuzetsu> Then maybe you should implement the obvious before asking~
13:50:29 <dmwit> merijn: I'm still not totally sure I understand the problem. Why does the socket need to be threadsafe if there's just one thread reading from it anyway?
13:50:45 <Paprikachu> it's *a lot* of work
13:51:27 <Cale> Paprikachu: The lines in your first do-block in writeIrc aren't aligned.
13:51:33 <Paprikachu> they are.
13:51:39 <Paprikachu> ideone shows it wrong.
13:52:11 <Cale> Paprikachu: No, they most definitely are not
13:52:17 <Cale> You have tab characters in your source.
13:52:22 <Paprikachu> it's a bug in ideone.
13:52:26 <dmwit> Cale: Okay, it's not. But you also have to upgrade your version of conal's package... I think it's called NumInstances?
13:52:27 <Paprikachu> i use tabs everywhere.
13:52:36 <dmwit> yes, that one
13:52:46 <Cale> You should configure your text editor to expand them to spaces
13:52:58 <Cale> The putStrLn m has four spaces before it
13:53:09 <Paprikachu> tabs are better.
13:53:14 <Cale> They aren't.
13:53:17 <Paprikachu> and as i said, it's an ideone bug.
13:53:19 <dmwit> Tabs are fine.
13:53:23 <dmwit> But you need to understand the rules.
13:53:36 <Paprikachu> ideone always replaces the first tab with 4 spaces, all others with 8.
13:53:46 <Cale> You *must* configure your text editor to align to 8 space multiples if you're going to use tabs.
13:53:48 <merijn> dmwit: No, there's only one thread reading from it because it's not threadsafe to have access from different threads, so having one read incoming socket messages (and write them to TChan or whatever) while another writes to it is unsafe
13:53:53 <dmwit> Cale: Also untrue.
13:54:09 <Fuuzetsu> I'm sure he meant to hit ‘4’.
13:54:11 <dmwit> Though again you do need to understand the rules before you decide not to.
13:54:14 <merijn> dmwit: i.e. the reads and writes to the socket must both happen in the same thread.
13:54:21 <Cale> dmwit: Well, if you don't, your text editor will display some code as being different from how the compiler will read it.
13:54:22 <Paprikachu> also, i'm just using a text editor.
13:54:25 <benj__> If I understand this correctly, in Haskell a simple length method will not actually create a new stack, but instead only see how many times it would need to call itself, then return that value
13:54:26 <dmwit> Cale: Correct.
13:54:38 <mauke> benj__: wat
13:54:47 <dmwit> Cale: However, a properly configured editor will also show very obviously when code is not written in a way that's independent of tab size.
13:55:13 <benj__> nm
13:55:18 <Fuuzetsu> Properly configured editor will use spaces.
13:55:25 <Cale> The easiest thing is just to not use tabs at all. I personally don't think they should be accepted by the lexer.
13:55:33 <dmwit> ugh
13:55:41 <Paprikachu> spaces are for people who do not understand the difference between indentation and alignment.
13:55:43 <Fuuzetsu> up next: emacs vs vim
13:55:51 <elliott> let's not.
13:55:54 <Cale> Paprikachu: Haskell is alignment sensitive.
13:55:56 <dmwit> I feel socially compelled not to dig this argument up yet again, but morally compelled to keep fighting the good fight for correctly-used tabs.
13:56:01 <Paprikachu> tabs for indentation > spaces for indentation
13:56:16 <elliott> let's just agree to hate each other instead or something.
13:56:27 <dmwit> Yes. I hate Cale, and love Paprikachu.
13:56:27 <Fuuzetsu> Paprikachu: Too bad that Haskell is about alignment and not indentation.
13:56:31 <Cale> Paprikachu: You're not interested in indentation in Haskell code. You're interested in precisely which column things start in.
13:56:44 <dmwit> I am indifferent to everybody who never expresses their preference aloud.
13:56:56 <Cale> haha
13:56:58 <Lethalman> yeah, tabs will make you use spaces anyway at some point because of alignment to a char
13:56:59 <c_wraith> I must formally declare my hatred of dmwit
13:57:09 <Lethalman> so you have tabs+spaces mixed
13:57:09 <Paprikachu> indentation is what happens *before* code
13:57:11 <merijn> So must I
13:57:17 <dmwit> Lethalman: Yes. So?
13:57:18 <mauke> Haskell syntax doesn't use indentation, only alignment
13:57:25 <mauke> so even if you use tabs, you don't use tabs
13:57:29 <elliott> I hate everybody *and* their dog!
13:57:31 <Lethalman> dmwit, so just use spaces :-P
13:57:36 <dmwit> Lethalman: No.
13:57:45 <Paprikachu> just look at my code
13:57:50 <Paprikachu> those = signs are aligned
13:57:52 <Cale> Paprikachu: Anyway, you asked how to make things more Haskelly, and apart from very few people here like dmwit, everyone in the Haskell world uses spaces. There are some very good reasons for this.
13:57:59 <Paprikachu> while the | signs are indented
13:57:59 <elliott> let us unite against a common enemy
13:58:05 <elliott> people who use {;}
13:58:12 <elliott> instead of layout
13:58:22 <dmwit> Layout sucks, long live layout.
13:58:23 <Paprikachu> and what are those reasons?
13:58:26 <merijn> I prefer people who use {;} and spaces to people who use no {;} and tabs
13:58:28 <Cale> http://urchin.earth.li/~ian/style/haskell.html <-- read this :)
13:58:56 <Cale> (specifically the section on tabs)
13:59:19 <Paprikachu> who configures his tabs to be replaced by spaces?
13:59:22 <Paprikachu> that's just stupid.
13:59:25 <dmwit> The reasons are that it is "hard" to maintain code correctly if it mixes tabs and spaces, and some people are not disciplined enough/do not configure their text editor properly to collaborate properly.
13:59:41 <Cale> Paprikachu: When I press tab, my editor inserts two spaces.
13:59:45 <Paprikachu> the point of tabs is to keep them in the source code.
13:59:49 <Cale> I use the key as a sort of faster spacebar.
13:59:56 <Eduard_Munteanu> "However, many people configure their editors with 2 or 4 space tabs." -- however many people are wrong and Linus would have a thing or two to say about that :P
14:00:05 <Paprikachu> so that someone else can configure tab widths the way he likes it.
14:00:14 <elliott> I accuse Paprikachu of not understanding Haskell's syntax
14:00:22 <Paprikachu> probably.
14:00:27 <Paprikachu> i'm no haskell expert
14:00:30 <fizbin> Paprikachu: That is a nice worl, but not one I live in.
14:00:32 <Cale> Paprikachu: Regardless of how your configure your editor, the *compiler* will treat a tab character as aligning to the next column which is a multiple of 8
14:00:34 <fizbin> +d
14:00:42 <Eduard_Munteanu> Well, you can certainly write tabsize-independent code, but it's not trivial.
14:00:44 <Cale> Paprikachu: and this *matters*
14:00:48 <dmwit> Eduard_Munteanu: I do this.
14:00:49 <Paprikachu> yeah, and?
14:00:54 <Paprikachu> what is your point?
14:00:55 <dmwit> It actually *is* pretty trivial.
14:01:08 <Cale> Because code can behave in two different ways depending on which column various lines start in
14:01:26 <Eduard_Munteanu> dmwit: it sorta looks odd, if you need to split e.g. data declarations on multiple lines, unless the editor is smart
14:01:29 <Paprikachu> all i can see in these examples is missused tabs.
14:01:33 <c_wraith> dmwit: except for going to a newline after a let before any declarations are specified is *ugly*
14:01:41 <dmwit> Cale: It's like arguing "well my code can do something different if I use + instead of *"... you sort of shrug and go, "uh, yeah, so?".
14:01:42 <Paprikachu> /spaces
14:01:45 <Cale> So you can have a program which looks like it's valid in your text editor, and which actually *is* valid and accepted by the compiler, but does something different from what it looks like it ought to.
14:02:06 <dmwit> Eduard_Munteanu: You needn't change the location of anything.
14:02:14 <Cale> dmwit: The problem is that + and * actually visually look different, while in most text editors, they do not.
14:02:18 <Paprikachu> my program never looks different than what it actually is, because i know how to use tabs and spaces.
14:02:29 <dmwit> Eduard_Munteanu: The only thing you need to avoid is aligning things on lines of two different indentation levels. Which is not an issue in Haskell.
14:02:32 <shachaf> I think this channel would be much improved by a rule that says that you're not allowed to talk about tabs and spaces ever.
14:02:37 <Eduard_Munteanu> dmwit: yes, but normally you'd try *not to* align things, on purpose
14:02:38 <merijn> shachaf++
14:02:42 <Paprikachu> arguin that other people are too stupid for this simple rule is just bs.
14:02:44 <dmwit> Cale: In my editor, space and tabs look different. =)
14:02:55 <Cale> shachaf: No, I think it's important to get this sorted out with beginners.
14:03:08 <Fuuzetsu> shachaf: but then we'll end up with tabs in code
14:03:10 <dmwit> Eduard_Munteanu: huh?
14:03:10 <Paprikachu> the examples on that page don't even make sense.
14:03:22 <Eduard_Munteanu> data Maybe = Nothing
14:03:23 <shachaf> Fuuzetsu: I don't care. Stop it. You're not helping.
14:03:26 <Eduard_Munteanu>     | Just a
14:03:27 <Cale> If you look at 99% of Haskell code out there, you'll find no tab characters in it.
14:03:29 <Eduard_Munteanu> err, you get the point
14:03:32 <Paprikachu> they contain randomly inserted spaces
14:03:36 * Fuuzetsu lets Cale handle this
14:03:51 <shachaf> Cale: Helping beginners is the only excuse. The trouble is that it always turns into an argument between regulars, and people are stupidly fanatic about their own way of doing things.
14:04:06 <Cale> shachaf: I'm trying very hard to ignore dmwit on this :)
14:04:26 <shachaf> Yes. See?
14:04:31 <dmwit> Eduard_Munteanu: ...I'm not sure I do. =(
14:04:47 <dmwit> Eduard_Munteanu: But perhaps we should take it to privmsg.
14:04:53 <Eduard_Munteanu> Or -blah.
14:04:54 <mauke> I'm with dmwit
14:04:56 <c_wraith> Paprikachu: no, the spaces are very pricely inserted for alignment. None are random at all
14:04:57 <mauke> and Cale too
14:04:59 <Cale> Paprikachu: While you *can* get by with tabs, it's far more trouble than it's worth, and people will generally be annoyed if you try to contribute patches to things.
14:05:01 <typoclass> Paprikachu: you keep saying that it's all very easy and that everyone except you is stupid, but you haven't explained so far what those easy trivial rules are supposed to be
14:05:07 <Eduard_Munteanu> I'm with mauke.
14:05:18 <tomejaguar> I would like to represent something like electronic circuits using Haskell datatypes.  Does anyone know a good place to start looking for ideas?  I'm sure some work has been done on this already.  I'm having a browse of netwire in case that's relevant ...
14:05:19 <dmwit> Cale: Oh, I would never dream of putting tabs in a patch to a project that used spaces. Always fit in.
14:05:27 <dmwit> Paprikachu: You should not try to push your tabs on other projects, either.
14:05:48 <Fuuzetsu> tomejaguar: I know SICP had a section on this and I believe that someone translated that book into Haskell.
14:05:49 <Cale> tomejaguar: Have you looked at Lava?
14:05:51 <Fuuzetsu> I might be wrong though.
14:06:02 <typoclass> dmwit: do you have an explanation of your tab-width-independent style? a blog post or example hpaste code, etc.
14:06:26 <dmwit> typoclass: I don't. Perhaps I should prepare one, for the inevitable next time this discussion arises.
14:06:27 <mauke> typoclass: start a new line after every layout-introducing keyword
14:06:55 <Cale> Yeah, if you use tabs only, be prepared to always put a newline after every let, do, of, and where
14:07:09 <Paprikachu> no, why?
14:07:09 <typoclass> mauke: hm ok. that sounds clear enough
14:07:12 <dmwit> mauke's rule is one (overly conservative) solution. The other can be explained in one sentence to mathematicians: treat spaces and tabs as being of incomparable width.
14:07:34 <dmwit> (But spaces and all other characters have the same width.)
14:07:54 <simpson> I'm gonna go make my own language with fixed-width indentation using only spaces. And blackjack and hookers. In fact, forget the language.
14:08:01 <Paprikachu> it's actually easy. don't rely on tab width.
14:08:09 <Cale> Paprikachu: because the next non-whitespace character which follows those keywords sets the column for a layout block
14:08:11 * elliott sigh
14:08:12 <Eduard_Munteanu> Heh, simpson
14:08:12 <tomejaguar> Fuuzetsu: I'll try to track that down
14:08:14 <shachaf> #haskell-tabsspaces
14:08:20 <tomejaguar> Cale: No never heard of Lava.  I'll google ti.
14:08:21 <fizbin> I'll note that it has become apparent tradition in the unix open-source world that tabs are generally a bad idea in source code, and should be eliminated in favor of spaces. It used to be the tradition among windows Pascal and C programmers to assert the opposite.
14:08:23 <elliott> this argument is bad enough when it's between people who know exactly how haskell's grammar is affected by tab width etc.
14:08:27 <Cale> Paprikachu: and if you don't start a new line, you can't guarantee to hit that line with tabs
14:08:32 <Cale> er, hit that column
14:08:43 <dmwit> You don't have to guarantee that.
14:08:53 <Paprikachu> tradition is usually complete bullshit.
14:08:54 <dmwit> You put tabs under each other, and spaces under non-tabs.
14:09:07 <Fuuzetsu> tomejaguar: Apparently it hasn't been translated after all. Sorry!
14:09:08 <mauke> yeah, you just copy the structure of the preceding line
14:09:11 <dmwit> I've written lines that had tabs, then spaces, then tabs. Total madness!
14:09:11 <fizbin> Paprikachu: Do you actually understand haskell's layout rules, or are you just trolling without realizing that haskell has in some cases significant whitespace?
14:09:12 <DigitalKiwi> but how do you know which is which? :)
14:09:14 <mauke> I think it's 'copyindent' in vim
14:09:15 <Fuuzetsu> I was thinking of the OpenGL red book.
14:09:32 <nwf> Hey all; I'm regenerating haddocks with every push into a git repo, and I'd like the documentation to include the output of "git describe --always" when haddock ran.  Any suggestions?
14:09:36 <Cale> Paprikachu: I've never seen an argument for putting tab characters in source code which was at all even the slightest bit convincing.
14:09:42 <tomejaguar> Fuuzetsu: that's OK.  Thanks for the idea.
14:09:45 <nwf> (I'd also like to do it with every cabal build, but I figure that's a separate question?)
14:09:54 <Paprikachu> i can specify how much i want code to be indented.
14:09:57 <mauke> Cale: semantic indentation
14:10:00 <Cale> It *might* have made sense in the real old days when space was very tight.
14:10:02 <Paprikachu> and i can edit it in a text editor.
14:10:04 <DigitalKiwi> Cale: but it saves bytes!
14:10:06 <fizbin> dmwit: The only excuse for tab-space-tab lines is if you're coding in the esolang 'whitespace'.
14:10:07 <elliott> prediction: not one thing will be said today that any participant who is on another side finds convincing
14:10:08 <Eduard_Munteanu> dmwit: tabs then spaces are common in Linux code... not sure about tab-space-tab.
14:10:18 <elliott> and everyone will go away thinking they've won.
14:10:19 <mauke> Cale: instead of saying "I want this thing to be in column 7", you say "I want this to be indented 2 levels"
14:10:21 <merijn> Cale: But what if I don't like your identation?! (Sorry, I'll stop trolling :( )
14:10:33 <fizbin> Paprikachu: That argument only works in a language without significant whitespace.
14:10:39 <merijn> elliott: Solution, let's all switch to lamdu and not have indentation at all!
14:10:44 <shachaf> merijn: If you stop, you'll be in the minority, I think.
14:10:48 <Paprikachu> what the fuck are you talking about?
14:10:52 <Paprikachu> tabs arent whitespace
14:10:53 <dmwit> fizbin: I have empirical evidence that you are wrong. It can work in Haskell.
14:10:55 <simpson> fizbin, dmwit : Certain ancient codebases, like X.org, require new code to follow the indentation of the code around it. After a little bit of C&P, you totally end up with tab-three-space-tab-four-space code.
14:11:03 <dcoutts_> nwf: you could do it by calling haddock manually with a "prelude" that you generate
14:11:06 <Eduard_Munteanu> Any significantly whitspace-laden language is incompatible with tabs. :P
14:11:07 <elliott> Paprikachu: this will be a lot easier if you read the haskell report's syntax.
14:11:11 <fizbin> Paprikachu: e.g., that argument almost works in C.
14:11:15 <mauke> Eduard_Munteanu: nonsense
14:11:20 <mauke> Eduard_Munteanu: counterexample: whitespace
14:11:22 <nwf> dcoutts_: Oh, hm.  Any examples handy?
14:11:26 <Eduard_Munteanu> Aw. :)
14:11:33 <dmwit> Eduard_Munteanu: I have empirical evidence that you are wrong. It can work in Haskell.
14:11:34 <elliott> arguing as if haskell treats indentation, alignment etc. identically to Python or whatever is hopeless
14:11:37 <Cale> Paprikachu: The trouble is, your editor isn't smart enough to adjust the indentation of Haskell code correctly, unless you force yourself into a somewhat awkward style, or add a lot of mental burden to pressing some combination of space and tab in an appropriate way at the start of each line, and then editing those spaces and tabs just-so when modifying the code.
14:11:46 <dcoutts_> nwf: sorry, "prologue" not prelude. haddock has a --prologue=FILE flag that takes a text file to use as the intro description.
14:11:48 <fizbin> dmwit: Just because it can be made to work is not an excuse for doing so.
14:11:49 <simpson> elliott: TBF, nobody knows how it works in Python either.
14:11:50 <Eduard_Munteanu> Meh, it was a pun on something.
14:11:59 <Paprikachu> it sucks to edit space-code in a text editor.
14:12:08 <mauke> Paprikachu: why?
14:12:10 <simpson> Spoilers: Python treats tab characters as indenting to the next tab stop, where each tab stop is worth eight spaces. :T
14:12:13 <merijn> Paprikachu: How so?
14:12:18 <dmwit> fizbin: If your only argument against it is that it can't be made to work, empirical evidence that you are wrong destroys any reason not to do it.
14:12:19 <Cale> *If* we had editors which actually understood Haskell's layout rules, automatic adjustment of how much things were indented would be a very different matter.
14:12:22 <Paprikachu> and also, i want 8-space indentation.
14:12:24 <dcoutts_> nwf: when Cabal calls haddock, it passes the package description, but if you call it manually you can do what you like, such as generating a file that has the info you want.
14:12:24 <merijn> simpson: Spoiler: PEP8 disallows tabs
14:12:31 <mauke> Paprikachu: Haskell has no indentation
14:12:31 <fizbin> dmwit: That wasn't my only argument.
14:12:38 <simpson> merijn: Yes, but I'm just talking about what the parser does.
14:12:38 * Eduard_Munteanu . o O (tab-width modulation)
14:12:39 <Cale> But just changing the width of each tab is clumsy and in many cases *incorrect*
14:12:41 <Paprikachu> some people use 4 spaces, others use 2.
14:12:49 <Fuuzetsu> merijn: it's okay though because PEP8 says to use 4 spaces
14:12:50 <tomejaguar> dmwit's example of mixing tabs and spaces: http://hpaste.org/74331 (from my historical brain)
14:12:52 <mauke> Paprikachu: those people are wrong
14:12:59 <elliott> everyone is bashing their heads against everyone else's brick-wall shields.
14:13:00 <Cale> In that doing so will *change the meaning of the program*!
14:13:03 <Paprikachu> and the more spaces there are, the more often i have to press <- and -> on my keyboard.
14:13:06 <nwf> dcoutts_: Oh, how handy.  OK, I can generate that in shell easily enough.
14:13:09 <dmwit> tomejaguar: Hey, nice, thanks!
14:13:13 <merijn> elliott: I just declared this to be -blah and -blah to be #haskell
14:13:15 <mauke> Paprikachu: why?
14:13:25 <simpson> Paprikachu: Have you considered using a text editor that permits you to move around by word, etc.?
14:13:34 <shachaf> This is getting out of hand.
14:13:35 <typoclass> tomejaguar: thanks. that's a good example
14:13:41 <Cale> shachaf: No it isn't :P
14:13:42 <elliott> merijn: #haskell-make-the-pain-stop
14:13:45 <shachaf> Can you all please take the tabs vs. spaces discussion to #haskell-overflow?
14:13:48 <fizbin> Paprikachu: You really seem to be talking from the perspective of a language like C or pascal, where the extra whitespace is totally ignored by the compiler and exists 100% as human readability.
14:13:49 <tomejaguar> dmwit: You were my hero in that discussion :)
14:14:00 <Paprikachu> i am coming from c++.
14:14:03 <Eduard_Munteanu> I like it how shachaf tries to keep this discussion off -blah as well. :)
14:14:12 <Paprikachu> spaces just suck dick.
14:14:22 <dmwit> Paprikachu: Okay, that kind of language isn't warranted.
14:14:22 <Fuuzetsu> mature
14:14:22 <merijn> elliott: I'm now the dictator of #haskell-make-the-pain-stop :p
14:14:24 <elliott> Paprikachu: please stop.
14:14:28 <Cale> Paprikachu: When you're writing C++ code, where there's complete whitespace independence, these questions about whether to use spaces or tabs are much less clear cut.
14:14:35 <mauke> #haskell-overflow
14:14:35 <simpson> Paprikachu: We're in -overflow now.
14:14:45 <quchen> Paprikachu: And we all know that sucking dick is a bad thing. Good point! BRB, gotta burn some books and hit my daughter
14:14:48 <typoclass> Paprikachu: can you please either watch your language, or go to another channel. most of your comments are light on facts and heavy on abuse
14:14:57 <merijn> quchen: Don't feed the flame war
14:15:09 <Paprikachu> hey, i don't need 20 people telling me the same thing
14:15:16 <quchen> merijn: Sorry, just tuned in, didn't know this was a war. O:-)
14:15:18 <Cale> merijn: quchen was actually responding to Paprikachu's last line...
14:15:25 <int-e> @quote fugue
14:15:25 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
14:15:39 <Cale> Paprikachu: Anyway, expect a lot of friction if you use tabs in your source.
14:15:40 <typoclass> Paprikachu: well you weren't reacting before
14:15:43 <merijn> Cale: I saw that, and while perhaps appropriate it's not likely to help and only further escalate the flaming
14:15:50 --- mode: ChanServ set +o mauke
14:15:50 --- mode: mauke set +q $a:cale
14:15:58 --- mode: ChanServ set +o Cale
14:16:01 <Paprikachu> so how does the haskell compiler treat tabs?
14:16:03 --- mode: Cale set -q Cale!*@*
14:16:10 <Cale> hi
14:16:19 <tomejaguar> Oh
14:16:23 <Fuuzetsu> ~
14:16:23 <Eduard_Munteanu> lolwut
14:16:24 <Cale> Paprikachu: It treats them as aligning to the next multiple of 8 spaces.
14:16:24 <mauke> Paprikachu: it assumes there are tab stops every 8 columns
14:16:44 <socumbersome> Hi. If I have function  map f . concat  , why do I have to use it with parentheses, like (map f . concat) xss  and map f . concat  xss doesn't work ?
14:16:45 <fizbin> So, first off, you have to know that there are some cases where the column that code starts on makes a difference.
14:16:46 <Paprikachu> and what does the haskell spec say about spaces?
14:16:52 <nwf> dcoutts_: Haddock seems not to like multiple --prologue options, and I would sort of like to have the .cabal file's text there too...
14:16:56 <Cale> So 7 spaces followed by a tab will be the same as a single tab
14:17:02 <merijn> socumbersome: Function application binds tighter than operators
14:17:08 <elliott> socumbersome: the latter is parsed as (map f) . (concat xss)
14:17:11 <dmwit> socumbersome: The latter parses as (map f) . (concat xss); since (concat xss) isn't a function, that's the end of that.
14:17:15 <merijn> socumbersome: So "map f . concat xss" parses as "(map f) . (concat xss)"
14:17:20 <dcoutts_> nwf: aye, integrating it with cabal is more tricky
14:17:20 <dmwit> oh snap
14:17:24 <Cale> Paprikachu: There are 4 layout keywords: "let", "of", "do", and "where"
14:17:26 <elliott> I'm glad we've moved on to saying the same thing about a less tedious topic.
14:17:30 <socumbersome> ah, okay, that was quick : )
14:17:42 <dmwit> Paprikachu: spaces assume there are space stops every 1 column. =)
14:17:43 <merijn> socumbersome: Common newbie problem :p
14:17:45 <typoclass> socumbersome: hello. function application ("concat xss") binds tighter than anything else
14:17:50 --- mode: mauke set -o mauke
14:17:53 <frerich> Hi, I'm sorry for interrupting this interesting discussion about tabs vs. spaces (I'm glad somebody finally talks about it!) but I'm wondering whether somebody can help me understand an 'Irrefutable pattern failed' error I get. http://hpaste.org/88116 shows a small piece of Haskell code I did, and the error it triggers.
14:17:55 <tomejaguar> socumbersome: that's #haskell for you.  Solving your problems instantly in the middle of a tabs-vs-spaces flamewar.
14:18:04 <Cale> Paprikachu: The first non-whitespace character after one of these sets the column for the block of code
14:18:07 <frerich> Now, what's strange is that I *don't* get the error anymore if I add a 'print args' right before the 'let' line.
14:18:14 <nwf> dcoutts_: Rats.  Thanks for the suggestion, tho'.
14:18:26 <dcoutts_> nwf: you can call haddock manually
14:18:26 <frerich> I suppose this has something to do with strictness? But I would have thought that 'length args' already forced 'args'?
14:18:27 <Eduard_Munteanu> Flaming is a fun pastime, we do it all the time to keep #haskell lively. :P   (no, not really)
14:18:32 <shachaf> Cale: This discussion has moved to #haskell-overflow.
14:18:54 <Cale> shachaf: I'm explaining the layout rule, surely that's on-topic :P
14:18:55 <dmwit> frerich: Strange!
14:18:57 <Paprikachu> Cale: and how is that a problem with tabs?
14:18:57 <nwf> dcoutts_: Does cabal make it easy to have it do all the prep work and let me hook the prologue before it calls haddock?
14:19:05 <typoclass> frerich: hm, mysterious
14:19:20 <Cale> Paprikachu: The Haskell compiler inserts a { at the beginning of the block, and puts a ; in between lines which begin in that column.
14:19:42 <Cale> and finally, puts a } before the first line which starts in a shallower column than the block
14:19:54 <fizbin> frerich: I suspect "throw" isn't doing what you think it is.
14:20:20 <fizbin> That is, I think you're getting the wrong number of arguments.
14:20:25 <Cale> This means that if the block starts in the middle of a line with a bunch of non-tab characters in it, you have to align the rest of that block *to the exact column* which it started in.
14:20:32 <Cale> For example, I might write
14:20:33 <shachaf> Cale: #haskell-overflow is for on-topic discussions that have grown too long for #haskell.
14:20:37 <Cale> foo x y z =
14:20:42 <Cale>   do bar x y
14:20:49 <Cale>      quux z
14:20:50 <frerich> fizbin: Yeah I'm indeed invoking my program without any arguments. I *do* want the exception. But I'm getting the 'Irrefutable pattern failed' error instead
14:20:50 --- mode: ChanServ set +o mauke
14:20:50 --- mode: mauke set -q $a:cale
14:21:03 <frerich> fizbin: And if I add 'print args' right before 'let […' then I do get the exception
14:21:07 <Cale> Heh, was I muted?
14:21:22 <fizbin> Cale: No, we were ignoring you.
14:21:26 <Cale> heh
14:21:41 <merijn> Cale: No, you had already unmuted yourself, mauke unmuted you again
14:21:54 <mauke> cale had not unmuted himself
14:22:00 <mauke> he just used +o to override the mute
14:22:03 <simpson> ^^
14:22:22 <dcoutts_> nwf: not really
14:22:44 <dmwit> frerich: I wonder: what happens if you just "throw WrongArgumentCount", i.e. not wrapped in a "when"?
14:22:50 --- mode: mauke set -o mauke
14:23:22 <fizbin> frerich: So I think that the problem is that the "throw" isn't really doing anything until the next IO statement...
14:23:24 <Cale> Paprikachu: If I indent that line with quux on it by one more space, then it becomes a continuation of the line before it.
14:23:29 <fizbin> Not sure though. Just a sec...
14:23:30 <merijn> mauke: "22:15 -!- mode/#haskell [-q Cale!*@*] by Cale"
14:23:40 <elliott> that -q did nothing
14:23:43 <Cale> Paprikachu: If I indent it by one fewer space, then the do block closes
14:23:44 <merijn> ah
14:23:59 <Paprikachu> i still don't see how tabs are a issue there.
14:24:12 <frerich> dmwit: Interesting guess!
14:24:16 <merijn> Paprikachu: The width of a tab depends on its location on the line
14:24:18 <Paprikachu> you could either put do after the =
14:24:23 <merijn> Paprikachu: They are *not* a fixed size
14:24:29 <frerich> dmwit: If I remove the 'when', i.e. I just do 'throw WrongArgumentCount', then I do get the exception and not the irrefutable error
14:24:33 <Paprikachu> or you could everything until do with a tab
14:24:36 <frerich> dmwit: Maybe 'when' doesn't work like I thought it would...
14:24:43 <Paprikachu> and on the next line fill up with spaces
14:24:45 --- mode: ChanServ set +o mauke
14:24:45 --- mode: mauke set +q $a:Paprikachu
14:24:47 --- mode: mauke set +q $a:merijn
14:24:54 <fizbin> @hoogle throw
14:24:55 <lambdabot> Control.Exception.Base throw :: Exception e => e -> a
14:24:55 <lambdabot> Control.Exception throw :: Exception e => e -> a
14:24:55 <lambdabot> Control.OldException throw :: Exception e => e -> a
14:25:12 <dmwit> oh
14:25:14 <dmwit> funny =)
14:25:26 <Cale> Paprikachu: and yeah, there are some other ways to lay out things so you don't run into problems with tabs
14:25:34 --- mode: mauke set +q $a:cale
14:25:36 --- mode: mauke set -o Cale
14:25:45 <dmwit> Cale: Since everybody else is being forced to move to -overflow with this, you should do so, too.
14:25:53 --- mode: ChanServ set +o Cale
14:25:56 --- mode: Cale set -o mauke
14:26:08 --- mode: Cale set -q $a:cale
14:26:15 --- mode: Cale set -q $a:merijn
14:26:19 --- mode: Cale set -q $a:Paprikachu
14:26:36 <elliott> -overflow. please.
14:27:03 <Paprikachu> .
14:27:13 <fizbin> @src when
14:27:14 <lambdabot> when p s = if p then s else return ()
14:27:29 <dmwit> frerich: Well, I have to say I'm a bit stumped.
14:27:31 <Paprikachu> what is mode $a?
14:27:32 <mauke> Cale: please stop undoing my quiets
14:27:55 <frerich> dmwit: I think I didn't provide all the details. I just tried to write a simple self-contained example demonstrating the issue, but the one I wrote doesn't reproduce the issue...
14:28:04 <frerich> dmwit: Let me try to come up with a test case..
14:28:10 <dmwit> frerich: okay =)
14:28:24 <dmwit> frerich: I have a guess: you are using a monad transformer stack, and one of the transformers is lazy.
14:28:30 <Cale> mauke: no
14:28:42 <typoclass> mauke: 2 minutes seems sufficient
14:28:50 <mhitza> hi, I have the following piece of code http://hpaste.org/88117 for which I get the error "recv: invalid argument (Bad file descriptor)". Yet I don't understand why.
14:28:52 <dmwit> frerich: ...*and* you are using throw instead of lift throw.
14:28:54 <mstksg_> why is haskell so hard
14:29:04 <dmwit> or liftIO throw or whatever
14:29:15 <Entroacceptor> mstksg_: because it is so awesome
14:29:55 <merijn> mhitza: It'd help if you could post the error belonging to that code
14:30:31 <mhitza> merijn: post it where?
14:30:43 <dmwit> merijn: ...he did post it, didn't he?
14:30:44 <typoclass> merijn: i suspect what mhitza quoted is all the error message. it not compile-time
14:30:51 <typoclass> *it's
14:30:52 <mhitza> no, it's a runtime error
14:30:57 <typoclass> mhitza: yes
14:31:19 <merijn> I was just wondering if there was more
14:31:26 <merijn> Since I don't see recv anywhere in there
14:31:30 <typoclass> mhitza: you get only that one line of error when you run it, right? "recv: invalid ..."
14:31:59 <mhitza> that code acts as a proxy for a raw connection. When I do a connection on the binded port, it automatically closes the connection and the haskell code has that error in the output
14:32:46 <mhitza> typoclass: and I get it twice, and I assume in the two runProxy cases
14:32:56 <typoclass> mhitza: oh, interesting
14:33:16 <typoclass> frerich: maybe it's something like the binary was produced from old source that didn't have the 'throw' in it, and when you add the seemingly redundant 'print' line, it triggered a recompile, and that new binary then behaved correctly
14:33:40 <typoclass> frerich: it's a bit of a silly idea :-) i know
14:33:40 <frerich> typoclass: +1 for thinking outside the box :)
14:34:15 <frerich> typoclass: I tried to write a little sample forms crutch, but I just gave up. Everytime I think I know what makes the difference, I realize it still works. So now I'll comment out parts of my failing test case until I minimized it...
14:34:45 --- mode: ChanServ set +o mauke
14:34:45 --- mode: mauke set -q $a:Paprikachu
14:34:47 --- mode: mauke set -q $a:merijn
14:35:34 --- mode: mauke set -q $a:cale
14:37:34 --- mode: mauke set -o mauke
14:38:59 <typoclass> mhitza: try adding "print 123" between lines 22 and 23. if i read the documentation of 'serve' correctly, it'll run that do block multiple times concurrently, once for each incoming connection. maybe the first execution works, and any successive ones fail
14:39:30 <mhitza> typoclass: ok, I'll try that
14:39:39 <typoclass> mhitza: hm ... i think i didn't make sense anyway :-/
14:40:38 <mhitza> typoclass: as expected, printed once when started and every time I try to initiate a connection
14:41:16 <mhitza> i can push on github if you'd like to try it with it's dependencies
14:42:01 <typoclass> mhitza: i didn't expect that. you get one "123" when starting? i'd have thought 'serve' won't run the do block until the first connection arrives
14:42:19 <mhitza> well I've put one on 22 and another one on 23
14:42:50 <mhitza> typoclass: so there was one before the serve, and the other inside the serve callback
14:43:21 <typoclass> mhitza: oh i see :-) i thought it was only one print, between 22 and 23
14:43:22 <applicative_> whoa mhitza stylin' indentation ...
14:43:44 <tedmiddleton> if I have a typeclass, and I want to make all members of another typeclass instances of the new typeclass, is that possible?
14:43:45 <elliott> applicative_: nooo, don't mention indentation!!!
14:43:56 <tedmiddleton> So I might have
14:43:59 <mhitza> typoclass: just to hint you in, initially I thought it had something to do with the main thread finishing earlier, and the MVar is there due to this stackoverflow anwser http://stackoverflow.com/questions/8272241/why-does-my-concurrent-haskell-program-terminate-prematurely
14:44:02 * applicative_ crawls back to finals 
14:44:08 <mhitza> typoclass: but obviously that isn't the problem :)
14:44:11 <tedmiddleton> class MyTypeClass where
14:44:29 <mhitza> applicative_: is it that bad?
14:45:02 <tedmiddleton> To cut to the chase, I want to do something like : instance (Integral a) => MyClass a where
14:45:14 <tedmiddleton> But that doesn't seem to work -
14:45:24 <merijn> tedmiddleton: That overlaps with every other instance
14:45:40 <merijn> tedmiddleton: Suppose someone writes "instance MyClass Int where" what do you expect to happen?
14:46:29 <tedmiddleton> Ah - I would have hoped I guess that the more specific instance would be preferred by the compiler, but I guess that isn't possible?
14:47:22 <merijn> tedmiddleton: That's possible, but it's generally discouraged, unless you have very good reasons
14:47:27 <tedmiddleton> It does make the type class a bit more tedious ... there's an easy definition for the typeclass functions that requires toInteger
14:47:49 <merijn> tedmiddleton: Will there ever be non-integer instances?
14:48:47 <tedmiddleton> Yes - could be a lot of things
14:49:26 <frerich> typoclass, dimwit: Ok, I stripped basically everything out of my program and it still exhibits this odd behavior. However, what's *really* strange (to me) is that I only get it in the binary generated by 'cabal build', and the only flags I pass are -Wall and -threaded. If I can 'ghc -Wall -threaded Main.hs' and then execute the binary, I don't see the behaviour.
14:49:27 <tedmiddleton> But the implementation of some of these can use an Int or Integer or anything that can be made an Integer
14:49:38 <frerich> dmwit: Sorry, I meant to say 'dimwit', not 'dimwit' :-}
14:49:41 <frerich> er
14:49:48 <frerich> This bloody IRC client keeps auto-incorrecting!
14:49:57 <tedmiddleton> I'm actually looking at one of the examples in learn you a haskell
14:50:04 <tedmiddleton> it's the YesNo typeclass
14:50:28 <dmwit> frerich: Can you ghc -Wall -threaded -fforce-recomp Main.hs just to make sure?
14:50:30 <elliott> poor dmwit
14:50:39 <typoclass> frerich: hm, you're zeroing in. have you tried -v3 for cabal so that it shows you exactly which flags it gives to ghc?
14:50:44 <tedmiddleton> The example for Integer is
14:50:47 <tedmiddleton> instance YesNo Int where       yesno 0 = False       yesno _ = True
14:50:59 <tedmiddleton> instance YesNo Int where
14:51:04 <tedmiddleton>        yesno 0 = False
14:51:05 <tedmiddleton>        yesno _ = True
14:51:31 <tedmiddleton> But I was wondering whether it could be rewritten for all members of Integral?
14:51:45 <dmwit> tedmiddleton: Not really, no.
14:51:52 <dmwit> (Sorry about that.)
14:52:01 <tedmiddleton> :-)
14:52:14 <tedmiddleton> No - it totally makes sense why it can't be
14:52:17 <tedmiddleton> :-)
14:52:20 <dmwit> tedmiddleton: You can write something like defaultYesNo :: Integral a => a -> Bool, and then have all your instances for the Integral types be instance YesNo Int where yesno = defaultYesNo
14:53:08 <tedmiddleton> Ah - yes that would work wouldn't it?
14:53:23 <dmwit> tedmiddleton: Alternately, you can make a proposal to libraries@ which makes YesNo a superclass of Integral. But I don't rate the chances of it being accepted very high. =)
14:53:30 <elliott> (you can also use a default signature)
14:53:36 <dmwit> elliott: oooo, yes
14:53:43 <dmwit> Those are still new to me, I keep forgetting about them.
14:53:56 <tedmiddleton> Cool - I'm having a lot fun with this. The last time I tried to learn haskell I started with Real World Haskell and got a bit bored. LYAH seems to be much more readable.
14:53:57 <dmwit> Can you write multiple defaults? I guess that wouldn't really be sensible.
14:54:00 <elliott> though privileging Integral is a bit weird
14:54:03 <elliott> dmwit: no, unfortunately
14:54:07 <tedmiddleton> default signature?
14:54:16 <elliott> of course, I must say that YesNo is evil apart from as a learning exercise so it hardly matters :p
14:54:31 <efie> I want to turn a Double value which looks like this: X.1069958847736627e-Y into X.1069e-Y or the String "X.1069e-Y", meaning I only want the first 4 digits after comma to be displayed. what is the right approach to do this?
14:54:31 <tedmiddleton> :-) of course it is - it came from javascript
14:54:41 <elliott> tedmiddleton: it would let you make defaultYesNo implicit when Integral can be satisfied
14:54:44 <dmwit> bool :: Bool a => a -> b -> b -> b
14:54:44 <elliott> so you could just say "instance YesNo Blah"
14:54:52 <elliott> rather than instance YesNo Blah where yesNo = defaultYesNo
14:55:05 <dmwit> efie: import Numeric, use show{EFG}Float
14:55:06 <typoclass> mhitza: i'm not sure. i'd start importing "Network.Socket as S" and mucking around directly with "S.recv serviceSocket", to see if that kind of thing fails as well. next step would be looking at socketReadS's implementation to see what recv calls it really does
14:55:08 <benmachine> tedmiddleton: the problem with overlapping instances and choosing the most specific one is that people can come along later and add more instances
14:55:14 <dmwit> efie: ...or use printf, which ship out to the same.
14:55:22 <benmachine> tedmiddleton: which means that which one was most specific can become ambiguous or change
14:55:55 <mhitza> typoclass: thanks, I'll dig further than by taking that approach
14:56:01 <benmachine> tedmiddleton: another problem with it is that it means programs can change their behaviour just by importing extra modules, or by the modules they import importing extra modules
14:56:13 <tedmiddleton> yes - that makes sense. I guess that would be a problem unless it could scoped somehow
14:56:27 <typoclass> mhitza: oh, another approach: maybe try "strace runhaskell yourfile.hs", to see exactly what calls to recv() are being done and what arguments it passes in
14:56:31 <efie> dmwit: ah nice =)
14:56:45 <benmachine> tedmiddleton: it's quite easy for instances to spring up from unexpected places, so it's really a good idea to pin things down to "either this type has an instance or it doesn't" rather than "this type has an instance unless a different instance wants to replace it later"
14:57:08 <tedmiddleton> benmachine: Yes - given that explanation, it does seem a lot more sensible to not have overlapping instances
14:57:13 <typoclass> mhitza: i mean, suppose you saw something like "close(fd=5)" and later "recv(... fd=5 ...)", that would be a clue. just as an example
14:57:23 <mhitza> typoclass: I have no experience with strace, but I can paste somewhere a dump for you to inspect
14:57:54 <benmachine> tedmiddleton: well, it's certainly not as simple as it seems to have them
14:58:45 <benmachine> tedmiddleton: maybe the solution is to fiddle with instances in some other way so that these problems go away, so I'm hesitant to say "categorically a bad idea"
14:58:46 <typoclass> mhitza: i'm not an expert on strace either :-) but it's straightforward to use. just start looking near the end of the output, since the stuff at the beginning is usually the less interesting bookkeeping stuff
14:59:16 <typoclass> mhitza: but yeah, if you get stuck, feel free to throw it on hpaste.org :-)
14:59:27 <mhitza> typoclass: the only thing I get is a bunch of futex(0x1f8a14c, FUTEX_WAIT_PRIVATE, 5, NULL) = ? ERESTARTSYS (To be restarted)
15:00:12 <tedmiddleton> benmachine: I don't know - given the problems you've outlined, I'd probably just steer clear of it - just to keep from astonishing myself somehow.
15:00:17 <hnsz> If I take out a corner cube from a rubix cube, rotate it and put it back in; is it still solvable?
15:00:23 <typoclass> mhitza: how about when you do "strace ./yourcompiledprogram"
15:01:02 * applicativer adds vote to benmachine's : tedmiddleton no overlapping instances!
15:01:04 --- mode: Cale set -b $a:Ndit
15:01:05 <benmachine> tedmiddleton: oh, sure, that's certainly wise, steer clear until you've got a better grip on things :)
15:01:35 <mhitza> typoclass: I actually did it on the compiled program, because I have to use hsenv to have the possibility to compile it
15:01:40 * dmwit feels that voting isn't necessary, as tedmiddleton was convinced before people even mentioned the word "overlapping".
15:01:55 <benmachine> tedmiddleton: but I've learnt not to underestimate what ideas can be made good by application of sufficiently advanced cleverness
15:02:05 <frerich> typoclass: Hm, the ghc command line by cabal is fairly long, unfortunately I can't seem to try it by hand easily...
15:02:14 <dmwit> hnsz: Wrong channel. However: no.
15:02:54 <frerich> dmwit, typo class: I now managed to reduce the project to a trivial .cabal file and a single small Main.hs file; I uploaded it to https://www.dropbox.com/s/y3eq1fieni8a5nh/signserv.tar.bz2?v=1mcis -- maybe, if you don't mind, you can see whether running 'cabal configure && cabal build && dist/build/signserv/signserv' also yields the "Irrefutable pattern failed" error for you?
15:03:05 <hnsz> dmwit: Right channel if I find someone who can answer it:p
15:03:10 <frerich> And if it does, in src/Main.hs, adding a 'print args' just before that pattern which fails should fix it.
15:03:11 <dmwit> frerich: This I will do.
15:03:23 <FreeFull> hnsz: If you rotate the corner cube, it's not solvable anymore
15:03:30 <benmachine> oh hey, I wonder if anyone here knows: we have that SK combinator calculus is Turing-complete, and for the (->) r Applicative, pure = K and <*> = S, are they still Turing-complete? or is it the case that you need to be untyped to get completeness?
15:03:35 <frerich> dmwit: Very much appreciated! I hope that link works, I never used this DropBox thing before...
15:05:00 <dmwit> frerich: I am relaxing your base constraint.
15:05:31 <frerich> dmwit: I think that was just 'cabal init' being a bit zealous...
15:05:35 <jkff> Hey folks, who's at BayHac right now?
15:06:13 <dmwit> frerich: Okay. I do understand this problem.
15:06:21 <dmwit> You will like this StackOverflow question (one moment while I dig it up).
15:06:30 <frerich> dmwit: Is it a brown paper bag kind o' thing? :-}
15:06:42 <dmwit> http://stackoverflow.com/q/11070690/791604
15:07:12 <frerich> dmwit: Hm, let me look...
15:07:15 <dmwit> frerich: Also, you will need the clue that throw's type does not include IO.
15:07:31 <frerich> dmwit: But still: do you understand why the cabal-generated binary exhibits this issue and 'ghc' doesn't?
15:07:38 <frerich> I.e. calling ghc -Wall -threaded src/Main.hs
15:08:06 <dmwit> I think to understand that you would need to understand the internals of GHC's compilation and optimization passes.
15:08:15 <frerich> Hum...
15:08:30 <dmwit> Read the answer, then come back and we'll talk more. =)
15:08:53 <frerich> Well the good thing is: I think I'm ascending on the Haskell enlightenment ladder. I'm no longer looking at an SO article answered by you, but at one asked by you and answered by dons
15:08:59 <frerich> So I must be on to something
15:09:00 <typoclass> o grate. i actually thought "some kind of bananas reordering done by ghc" fairly early after frerich's question, but didn't say anything because i found it too vague and unlikely
15:09:06 <dmwit> hehe
15:10:49 --- mode: Cale set -b *!*@cpe-108-185-218-246.socal.res.rr.com
15:13:13 <johnw> merijn: wow
15:13:22 <frerich> dmwit: Aaah… so in my case, an irrefutable pattern failing yields an exception (like "error"?), and then there's also the WrongArgumentCount exception - so there's a set of exceptions and hence ghc is free to choose one? So the fact that adding a 'print args' before the pattern match helped was actually just lucky coincidence?
15:13:52 <dmwit> frerich: The first part is right, but the part about print fixing things was not just luck!
15:14:04 <frerich> Hm don't tell me why
15:14:05 <frerich> Let me think
15:14:12 <dmwit> okay =)
15:14:46 <frerich> Ah, is it because with the "print" in-between, it's no longer a single piece of pure code yielding two exceptions?
15:14:51 <dmwit> correct =)
15:14:55 <frerich> Ha!
15:14:59 <dmwit> Cute, no?
15:15:01 <johnw> merijn: how much RAM do you have?
15:15:19 <dmwit> frerich: As mentioned in the comments there, you should be able to fix this just by switching throw to throwIO.
15:15:32 <frerich> dmwit: I think that's… surprising.
15:15:38 <dmwit> frerich: me, too
15:15:43 <merijn> johnw: 4GB
15:15:49 <frerich> dmwit: But the reasoning given in Don's answer makes sense.
15:16:11 <merijn> johnw: Would shrinking the -c argument help?
15:16:16 <johnw> merijn: what if you use lower values like rehoo -j2 -c16?
15:16:27 <johnw> yes, it should help very much
15:16:35 <johnw> you can go as low as -c2
15:16:35 <merijn> I ran with -j2 already, because I have only 2 cores anyway
15:16:56 <johnw> it should take longer, though
15:17:06 <merijn> Right now I'd need to rebuilt the entire database as I already nuked what I had (hoogle wasn't working)
15:17:22 <dmwit> Hm, empirically throwIO does not fix things.
15:17:24 <merijn> I reran it with "hoogle data -r -l" but that still doesn't work for locally installed stuff...
15:17:26 <dmwit> This, too, surprises me.
15:17:42 <johnw> merijn: that's really strange, it should work
15:18:14 <merijn> johnw: Hell, even after the rehoo died my system was unbearably slow for like 30-40 mins, since everything had been paged out (presumably)
15:18:32 <johnw> sorry about that; I guess the 24G on my system had made this issue invisible to me
15:18:32 <joe9_>  I have a Word32, but, I want to show it with a certain format. using TypeSynonym Instances or Overlapping Instances is not helping.  "Duplicate instance declarations:" is the error message
15:18:42 <joe9_> any suggestions on how I can go about it, please.
15:18:53 <dmwit> Don't name your pretty printing function "show".
15:19:07 <dmwit> Alternately, use newtype so that your type isn't a Word32.
15:19:09 <johnw> or "print" :)
15:19:15 <joe9_> I could do newtype, but, am wondering if there is a simpler option.
15:19:55 <dmwit> Don't name your pretty printing function "show".
15:20:06 <joe9_> dmwit: johnw, ok, thanks.
15:20:11 <frerich> dmwit: What's odd is that for me, throwIO *does* fix the simple test case, but it does not help in the real application.
15:20:17 <merijn> johnw: You and your luxury machines >.<
15:20:26 <johnw> merijn: this thing is 4 years old!
15:21:34 <dmwit> frerich: It may be time to file a bug with the GHC folks.
15:21:40 <merijn> I think mine is newer >.<
15:22:02 <dmwit> frerich: ...maybe.
15:22:11 <frerich> dmwit: You say that for you, throwIO doesn't fix the simple test case I uploaded?
15:22:16 <dmwit> frerich: correct
15:22:20 <frerich> huh...
15:22:37 <merijn> Are you two using the same GHC?
15:22:45 <dmwit> no
15:22:48 <frerich> Probably not, I'm using 7.4.2
15:23:00 <frerich> And he had to adjust the .cabal file for a different requirement on 'base'
15:23:17 <blaenk> @pl \_ -> f
15:23:17 <lambdabot> const f
15:23:46 <mhitza> typoclass: added an explicit recv http://hpaste.org/88127 and that works (reads the socket and prints it out), but now the problem received is similar but on threadWait, not recv
15:24:13 <mhitza> typoclass: also checked the implementation in pipes-network, but I didn't see anything that may be wrong
15:27:46 <jkff> Let's try again: Anyone on BayHac?
15:28:37 <frerich> Oh, is that Bay as in - Bay Area, California?
15:29:10 <sipa> frerich: correct
15:29:18 * frerich temporarily moved from Germany to the Bay Area for three months, if there would be some Haskell'ish something around here, that would be great
15:29:21 <sipa> jkff: i heard roconnor is going
15:29:32 <johnw> does any know how to create indexes for a column using persistent?
15:30:00 <pqmodn> johnw: was just wondering that myself :)
15:30:11 <johnw> if I find out I'll let you know
15:30:20 <pqmodn> thanks, likewise
15:31:14 <pqmodn> johnw: it almost seems that's not a use case it addresses, http://stackoverflow.com/questions/11861339/sql-indices-with-database-persist-yesod-web-framework
15:31:47 <johnw> ah, ok
15:34:24 <Hafydd> tswett, I just perceived that we are (were) both in #cantr and #haskell.
15:35:00 <johnw> pqmodn: it appears indices are in the SQL standard
15:35:03 <johnw> maybe that's why
15:35:37 <typoclass> mhitza: hm. sorry, i've got no more ideas. i think you should ask the pipes people (mailing list?), mentioning the hpaste link and quoting all of the output of your program :-)
15:36:14 <mhitza> typoclass: ok, do you know where the pipes mailing list is located?
15:36:41 <mhitza> typoclass: nvm, I'll drop a ticket on the github
15:36:58 <johnw> pqmodn: i just added them manually
15:37:09 <typoclass> mhitza: er ... yeah :-)
15:38:02 <mhitza> typoclass: btw, thanks for the help :)
15:38:14 <typoclass> mhitza: you're welcome
15:38:28 <aloa> so, i asked today in the morning also, but nobody knew. maybe one of you can help: im searching for a portable (no installation required) compiler (prefered ghc(i)) for windows
15:39:01 <typoclass> aloa: the easy answer would be tryhaskell.org, or /query lambdabot :-)
15:40:05 <aloa> but tryhaskell depends on a internet connection, typoclass
15:40:16 <typoclass> aloa: yes
15:40:38 <sodalitumpianum_> hello
15:40:38 <aloa> i want something for my usb-stck
15:40:41 <aloa> stick*
15:41:41 <typoclass> aloa: but yeah, interesting question. i bet there's been discussions about how to simultaneously install several versions of ghc on windows. that surely involves installing ghc into different directories. with any luck, you'll be able to install it to a directory on the usb flash thingy
15:42:39 <Saizan> aloa: have you tried just installing ghc there?
15:43:13 <Saizan> i guess user's packages would still get installed into your user directory though
15:43:21 <aloa> nope, i didnt, but i assume, it wont work... shame on me, if it does
15:43:36 <Saizan> the basics should work
15:45:36 <aloa> really, i am tryin it right now :-) i'll give feedback of the progress :-)
15:45:39 <typoclass> aloa: if it doesn't work, google around for mailing list discussions/stack overflow answers/blog posts on how to use multiple ghc versions on the same windows :-)
15:46:11 <aloa> Saizan: typoclass but haskell platform will be impossible? i'm most certain
15:46:15 <mebaran151> Hey could somebody help me with a gnarly type error: http://hpaste.org/88130
15:46:19 <aloa> typoclass: yes i will do
15:48:29 <typoclass> aloa: as i understand it, the haskell platform is basically "just" a list of package names and versions. you can always install all those manually through cabal. you'll only be missing some convenience
15:49:49 <mebaran151> deleteWhere for reference is an instance function of the type class PersistBackend m
15:50:24 <mzero> typoclass: that is correct - it is "just" that --- but it is then also packaged for very easy installation on most platforms
15:50:26 <Saizan> mebaran151: i was going to say to fix it with ScopedTypeVariables but if it's a method i'm not sure if it'll work
15:50:43 <mebaran151> I'd like my equation to call the deleteWhere instance corresponding to the type of the array passed in (I suppose I am trying to class system)
15:50:54 <Saizan> mebaran151: can you show the code for the instance?
15:51:25 <typoclass> mzero: yes, i used the quotes around the word just because it's no small thing. and i appreciate a lot what you folks are doing :-)
15:51:25 <Saizan> mebaran151: my guess is that the 'a' in your "deleteWhere ([] :: [Filter a])" doesn't mean what you think it means
15:51:40 <monochrom> merijn: http://lambda-the-ultimate.org/node/4666 may help with row polymorphism
15:51:41 <mzero> yay!
15:52:01 <mebaran151> http://hpaste.org/88132
15:52:03 <monochrom> @tell merijn http://lambda-the-ultimate.org/node/4666 may help with row polymorphism
15:52:03 <lambdabot> Consider it noted.
15:52:07 <mebaran151> here's teh code that causes it
15:52:13 <monochrom> hope lambdabot doesn't die until then :)
15:52:51 <elliott> @flush
15:53:15 <mebaran151> basically where ever I use deleteWhere, I want the compiler to lookup the type of the elements of the list and use that to resolve the right instance of deleteWhere
15:53:17 <Saizan> mebaran151: http://hpaste.org/88133 <- try that way
15:54:08 <mebaran151> thanks Saizan!  That worked!
15:54:18 <mebaran151> how does the for all m a. help?
15:54:42 <mebaran151> I'm a type theory newbie so I'm curious :)
15:54:43 <typoclass> Saizan: what was the change? adding ScopedTV?
15:54:46 <Peaker> mebaran151, it lets you refer to the same "a" type in your type signature
15:54:56 <Saizan> with ScopedTypeVariables you can bind type variables in a signature using forall, and then refer to them in the body of the function
15:55:11 <Peaker> mebaran151, without both ScopedTypeVars and the explicit forall, you get an implied "forall" for each type variable in each type, and having the same name is meaningless
15:55:12 <typoclass> (oh right)
15:55:21 <Saizan> otherwise the 'a' in the body is a unrelated type variable which just happens to have the same name
15:55:25 <mebaran151> so forall is sort of a let, but for type variables
15:55:39 <Saizan> closer to a lambda
15:55:57 <Saizan> though this is mostly a GHC quirk
15:56:22 <Peaker> mebaran151, forall a. ...   is there with or without the scoped type variables and explicit syntax.   By adding the syntax explicitly, you're not adding a forall, you're making the outer "forall" explicit, and *removing* the implied forall a.  on the inner type
15:56:43 <mhitza> typoclass: well at least I can inform you that the issue arises due to forkIO. I'll let the rest to the developers of pipes-network :)
15:56:54 <mebaran151> so what was Filter a bound to before?
15:57:00 * typoclass scratches his head
15:57:01 <Saizan> (if we were in System F a forall would be the type of a type-lambda)
15:57:35 <Saizan> mebaran151: you were basically saying "deleteWhere ([] :: forall a. [Filter a])" before
15:59:22 <Peaker> in System F, where foralls are explicit lambdas, there's no "impredicative" business, is there?
15:59:57 <mebaran151> ah so before I by deleteWhere had to be very very broad (cover any a that was inserted)
16:00:08 <Peaker> In lamdu we use System F and have the extra type params/lambdas hidden by the UI
16:00:13 <mebaran151> while now I scoped it so that it will choose the specific a in my outer type definition?
16:00:45 <Saizan> the list had to be very broad, but that's no problem for an empty list
16:01:00 <Peaker> @type []
16:01:02 <lambdabot> [a]
16:01:04 <mebaran151> with ScopedTypeVariables turned on, why do you need the forall m a. (i.e. why wouldn't it do the logical thing and have the internal a bound to the external type signature)
16:01:04 <Saizan> the problem is then that deleteWhere gets something too unspecified as its argument
16:01:20 <mebaran151> Saizan that makes sense
16:01:21 <elliott> mebaran151: backwards compatibility
16:01:22 <Saizan> mebaran151: because backwards compatibility
16:01:46 <Peaker> though it is backwards compatible with Haskell98/2010 but not backwards compatible with various other GHC extensions that also allow explicit forall
16:01:51 <Saizan> mebaran151: so that old code doesn't change meaning when you turn ScopedTypeVariables on
16:01:52 <mebaran151> isnt't that what the LANGUAGE pragma is for though?
16:01:54 <Peaker> it would have been nicer to just do the sensible thing
16:02:02 <Peaker> mebaran151, I agree
16:02:34 <mebaran151> alright, so it's just a ghc quirk.  As I explore Haskell, I'm always checking to make sure my type theoretical basis is accurate
16:02:38 <Saizan> yeah, you could argue the pragma is enough, but so it is
16:03:15 <Saizan> (if it gets merged into the standard at some point it will help though)
16:03:19 <merijn> monochrom: Cheers :)
16:03:19 <lambdabot> merijn: You have 4 new messages. '/msg lambdabot @messages' to read them.
16:03:45 <mebaran151> thanks Saizan and Peaker
16:04:06 <monochrom> good good
16:04:08 <merijn> Whoa, when did I become popular?
16:04:19 <monochrom> now lambdabot can die :)
16:04:31 <Saizan> Peaker_: you still have to decide if you want to allows impredicativity or not, semantically, and how to deal with type inference if you want to hide the type-lambdas/applications
16:04:42 <merijn> lambdabot had some issues, apparently...
16:04:46 <merijn> "said 3m 21d 12h 37m 44s ago"
16:04:50 <mzero> woot! BayHac first day is in full swing ~30 people here
16:05:05 <mebaran151> so whenever I use ScopedTypeVariables, in order to have any effect, I need to prefix what I plan to scope with a forall m a.
16:05:05 <Saizan> System F per se is impredicative
16:05:16 <mebaran151> is that an accurate statement?
16:05:17 <Saizan> mebaran151: yeah
16:07:34 <Peaker> Saizan, What do you mean? How would system F change to allow impredicativity?
16:08:10 <Peaker> Saizan, We hide the type-lambdas/applications in the UI, but they do exist in the model you edit, with "holes" for the type args, and these holes have inferred values
16:09:01 <pqmodn> Peaker: isn't System F impredicative to begin with? that is, a type variable can be instantiated to a polymorphic type.. forall a. a -> a can be instantiated to tree (forall b. b -> int) -> (forall b. b -> int)
16:09:13 <pqmodn> sorry, ignore the word "tree"
16:09:57 <merijn> Forth qualifies as concatenative language, right? Or am I mixing things up in my memory now
16:10:23 <simpson> merijn: Largely, yes. ANS FORTH is not, but most Forths are to some degree.
16:10:31 <simpson> (Stupid technicalities.)
16:10:37 <DigitalKiwi> http://concatenative.org/wiki/view/Forth
16:10:45 <Peaker> pqmodn, yeah, that's why I don't see how there's any "impredicative" business at all in System F
16:10:59 <Peaker> pqmodn, there seems to be only one way to have it in System F
16:11:05 <merijn> simpson: Well, I haven't gotten around to learning any Forth yet, so technicalities are not that relevant :)
16:11:07 <Peaker> (so I'm wondering if I'm missing something)
16:11:31 <simpson> merijn: Well, in some Forths, including ANS FORTH, you can't always include the phrase defining a word in place of that word.
16:11:44 <pqmodn> Peaker: you mean it's unclear why instantiating type variables with polymorphic types should be called "impredicative"?
16:11:59 <simpson> merijn: Looping instructions and such are usually dependent on some state on the return/call stack, which can get weird in corner cases.
16:12:20 <merijn> There's a bit of conflict on whether my next language after haskell should be Racket, some Forth variant, Factor or Agda
16:12:24 <pqmodn> merijn: forth also has macros that change the syntax around, like IF and WHILE
16:12:26 <simpson> merijn: But for the most part, yes, Forths are concatenative; the stack effect of any two words is the concatenation of those words' stack effects.
16:13:12 <Eduard_Munteanu> merijn: um, conflict? Only Agda there is reasonable. :P
16:13:29 <simpson> merijn: Factor will fascinate and depress you.
16:13:33 <simpson> Just warning you. :3
16:13:53 * heath votes Agda
16:14:02 <merijn> Eduard_Munteanu: Agda seems like "more of the same, but different" as opposed to "completely different"
16:14:33 <Eduard_Munteanu> Mm... yeah, I'm not sure the others are all that different though.
16:14:47 <Peaker> pqmodn, no, I was just wondering if my intuition that the whole distinction becomes moot in System F is right or wrong
16:15:35 <Peaker> merijn, why will Forth depress?
16:16:02 <merijn> Peaker: I didn't say that
16:16:09 <Peaker> oops, simpson ^^
16:16:10 <pqmodn> Peaker: oh, i wasn't following along. i'm not sure how ScopedTypeVars relates to impredicativity
16:16:48 <simpson> Peaker: Factor's type system, syntax, ideals, etc. are both something to aspire to and something to mourn since they'll never be practical.
16:16:51 <Peaker> pqmodn, I wasn't referring to ScopedTypeVars, just impredicativity and System F specifically. I'm wondering because I'm using System F + type inference for my own system
16:17:27 <Peaker> simpson, what type system does Factor have?
16:18:14 <merijn> Actually, I'm lying, I'll probably mess around with Ur/Web before moving on to one of that list (and I secretly played a little with Racket already), but ok :p
16:18:21 <simpson> Peaker: Fully dynamic, with row-polymorphic type checking on the stack effects.
16:18:43 <simpson> You *must* declare stack effects on your phrases and they must be correct.
16:18:50 <pqmodn> Peaker: maybe i don't understand the question, but System F without impredicativity isn't System F. there are variations, like those which are limited to rank-2, and no impredicativity at all is rank-1
16:19:38 <Peaker> simpson, "Fully dynamic" doesn't sound very attractive to a Haskeller :)
16:20:18 <pqmodn> Peaker: i feel like i'm conflating ranks with impredicativity, so maybe it's not as clear to me as i thought :)
16:20:25 <simpson> Peaker: No True Haskeller
16:20:54 <Peaker> simpson, If one isn't attracted to static safety, why do Haskell at all?
16:21:11 <merijn> Peaker: True hackers know how to switch their mindset to the language they're working in :p
16:21:49 <typoclass> merijn: true hackers find php as good as haskell
16:21:53 <simpson> Peaker: Terseness? Simplicity?
16:21:56 <Peaker> merijn, I remember kind of agreeing with http://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/  but I'll need to read again to make sure
16:22:16 <Peaker> simpson, Haskell's type system adds a great deal of complexity to the language
16:22:23 <simpson> Peaker: Indeed!
16:22:48 <merijn> typoclass: That's not what I said
16:22:56 <Peaker> simpson, and I'm not sure how much terseness it adds (it does add some, but sometimes requires more lifting to appease the type checker..)
16:23:10 <simpson> Peaker: Anyway, Haskell's static safety should not imply that dynamic languages must be unsafe.
16:23:14 <merijn> typoclass: I said they can switch their mindset to the language, not that they consider each language equally good or equally nice
16:23:56 <typoclass> merijn: i know you didn't say that, but i found it dangerously close, so it should warrant some clarification that it wasn't what you meant
16:23:59 <merijn> I have no problem writing python/lua, I just approach it drastically different from how I write haskell, the same goes for C, whatever
16:24:58 <Eduard_Munteanu> Well, if you want to enjoy writing C, you must like dealing with plumbing.
16:25:14 <heath> hey guise, curious where the cabal-config should go
16:25:26 <heath> currently it's located in ~/.cabal/share/cabal-dev-0.9.2/admin
16:25:28 <merijn> I didn't say I enjoy it, I said I approach it with a different mindset
16:25:49 <simpson> Peaker: One of my main problems with that article is that is assumes that you always have the ability to typecheck in a dynamically-typed language; you don't get that in a language that only passes messages.
16:26:04 <merijn> Although sometimes the mindset can be enjoyable in its own way
16:26:06 <heath> and cabal-dev is installing stuff in cabal-dev/ and placing that directory wherever you happen to be when you install the cabal-dev install --command
16:26:08 <Sgeo> Pipes or machines?
16:26:17 <frerich> dmwit: For the record, I decided to work around the problem by not using a 'parsedArgs :: IO Arguments' but instead having 'parseArgs :: IO (Either String Arguments)'. Turns out I could also get rid of a few includes like that.
16:26:24 <heath> little help appreciated, no rush as i peruse the docs
16:27:01 <typoclass> simpson: in my opinion simplicity is a thing with many dimensions. a car with no controls except for one button that will do a left turn, is beautifully simple in a certain way. in other ways, it isn't simple, since you end up making 3 left turns where in a normal car you'd make 1 right turn
16:27:15 <simpson> typoclass: I can certainly agree with that.
16:27:31 <heath> figured it out
16:27:45 <simpson> typoclass: But that's part of the curious nature of computation; we haven't yet figured out if there is some simplest way to express all computation.
16:27:47 <typoclass> simpson: in short, i worry that forth's simplicity doesn't translate to ease of use for the programmer. and other qualities
16:27:48 <Peaker> merijn, I don't think it's a matter of mindsets, because when I take some Python codebase and transliterate it to Haskell, I generally get roughly the same code size, with roughly the same abstractions (since it's a transliteration) but with far more safety, and usually orders of magnitude faster
16:28:11 <heath> inside that cabal-dev/ directory, there's a cabal.config, just fixed up some stuff and placed that directory in my desired path
16:28:17 <Peaker> merijn, that is, Python's dynamic nature adds slowness and unsafety, but doesn't actually make things more expressive
16:28:19 <simpson> typoclass: For every evaluation and representation model, there is an algorithm which is inelegant and inefficient. CLV.
16:28:22 <heath> thanks powerful people before me
16:28:34 <Peaker> simpson, I'm re-reading it because I forgot what it said :)
16:28:42 <Peaker> (only remembered roughly agreeing)
16:28:50 <simpson> Peaker: As did I. It's a frustrating read though.
16:28:57 <typoclass> @remember Peaker Python's dynamic nature adds slowness and unsafety, but doesn't actually make things more expressive
16:28:58 <lambdabot> It is stored.
16:29:39 <typoclass> Peaker: i found it interesting that you said roughly equal code size for haskell and python. unscientifically, i'd have expected stuff to be somewhat shorter in haskell
16:30:49 <frerich> typoclass: Maybe it is the same size for large values of 'roughly'
16:31:00 <Peaker> typoclass, sure, if you rewrite it with new abstractions.. I transliterated because I wanted to prove Haskell was nicer and beats Python in its own game.. also a fairer comparison, and in some of my transliterations, I didn't even fully understand the code I was transliterating, so using different abstractions to get more concise code would take a lot more effort
16:32:07 <simpson> I'm not sure what you think Python's game is; its niche is really as a teaching language.
16:32:08 <typoclass> Peaker: oh i see. you were staying closer to python than you would have otherwise
16:33:05 <Peaker> simpson, Python's actual real world use, at least around this part of the world, is not as a teaching language.. It's being used as a default language for everything that isn't performance critical
16:33:11 <typoclass> Peaker: last question, have you written up the result? the evidence that haskell beats python at python's game? that'd a very useful link to have :-)
16:33:19 <Peaker> simpson, By many of the people I know, including many bright ones
16:33:36 <Peaker> typoclass, Maybe I should collect the examples I've transliterated so far...
16:33:37 <sigma1409> I've always seen python used as a glue language
16:33:37 <simpson> Peaker: I use it for everything, including the performance-critical things. >:3
16:33:49 <Peaker> simpson, Python? Why? :)
16:33:55 <simpson> Peaker: Because I like getting things done.
16:33:57 <typoclass> Peaker: oh absolutely. that'd be exciting to read!
16:34:05 <aloa> typoclass: Saizan , i think it works with the usb-stick :-) not the gui, but ghc and ghci in command line... nice.. .thanks for your help anyways!
16:34:24 <typoclass> aloa: you're welcome
16:35:06 <Peaker> simpson, I haven't seen Python code that couldn't be better expressed as Haskell code with little effort and to great advantages -- excluding things like "eval" on configuration files
16:35:09 <aloa> i am going to bed now, see you!
16:35:12 <typoclass> simpson: what kind of things are you getting done with python that'd be hard with haskell? you mean guis and stuff ...?
16:35:30 <simpson> Peaker, typoclass : To sum it up, there is no Single Networking Library for getting things done with Haskell.
16:35:39 <simpson> There are other things, but that is the thing that I miss the most.
16:35:51 <Peaker> simpson, The conduit world seems to be pretty comprehensive
16:36:05 <simpson> Peaker: Yes! It is also extraordinarily painful and arduous.
16:36:08 <Peaker> Though using strict IO in a Python-like manner is still going to be nicer than Python
16:36:20 <Peaker> simpson, Twisted is absolutely horrible
16:36:25 <typoclass> simpson: you mean the "twisted" thing being python's networking library? i've got to read up on that
16:36:29 <sigma1409> with python you've got a very fractured networking/async stack though (that may be changing with tulip)
16:36:47 <simpson> Peaker: Well aware. It's also *still* better than all of Haskell's offerings.
16:37:06 <simpson> sigma1409: Yup. Tulip will only make things worse.
16:37:19 <Peaker> simpson, why? Even strict IO with forkIO is going to be better than Twisted
16:37:27 <sigma1409> dunno, it might consolidate all the coroutine libraries
16:37:35 <typoclass> simpson: do you have a link that i can read to get an idea of twisted's advantages?
16:37:36 <simpson> Peaker: In what sense?
16:37:37 <sigma1409> or supplant them
16:37:45 <Peaker> simpson, much nicer concurrency, better composability, better performance, Haskell safety
16:38:14 <simpson> typoclass: Elevator pitch: A real event loop, OS-independent, mature and tested, comes with tools to help you write large event-driven systems.
16:38:41 <sigma1409> I find that twisted tends to "leak out" into the rest of your code, it makes things very un-pythonic
16:38:44 <Peaker> simpson, For example, replace the horrible Twisted protocol subclasses that don't compose with simple functions that do strict IO and yield their results to a given continuation
16:39:00 <Saizan> simpson: tried doing it with threads instead?
16:39:06 <simpson> Saizan: Yes. :c
16:39:11 <Peaker> simpson, also, Deferred's use a __del__ trick to find leaked exceptions, which is horrible
16:39:12 <typoclass> Peaker: i think "even" is not the right word :-) strict IO with tons of forkIO is a pwerful thing
16:39:29 <Saizan> since that'd be the preferred way in haskell
16:39:33 <Peaker> typoclass, well, it is supposedly bad enough to warrant the creation of a bunch of iteratee/conduit/etc kind of libraries
16:39:41 <simpson> Peaker: So, here's my current plan: Deferreds suck because they are full of corners. Provide language-level syntax and semantics for them instead.
16:39:56 <typoclass> simpson: hm ... i guess i need to google various stuff. starting with the 'real event loop' ...
16:40:05 <Peaker> simpson, well, Python *might* improve on that. Haskell forkIO already does a much better job
16:40:09 <simpson> Peaker: Event loops suck because you can see them. Make them a language-level construct. For all of its failings, Node did get this one thing "right". (Ish.)
16:40:14 <Peaker> simpson, what are you missing with forkIO+strict IO?
16:40:31 <simpson> Peaker: Note that I'm not saying that Python's great, just that it's a load easier than Haskell for networking. I aim for something better still.
16:40:42 <simpson> Peaker: Async file I/O, for starters.
16:40:51 <Peaker> simpson, the aio stuff?
16:40:52 <eikke> simpson: disagree
16:41:02 <simpson> Our OSes can't do async file I/O; that doesn't mean that we shouldn't have it in our languages.
16:41:05 <merijn> simpson: Pretty sure you could easily implement that and get best of both worlds
16:41:17 <simpson> merijn: If it's easy, why hasn't anybody done it?
16:41:19 <eikke> I've written tons of networking/server apps in Python, using several frameworks (including Twisted)
16:41:38 <merijn> simpson: I was about to say "actually, haven't people already done that a bunch of times in haskell"?
16:41:45 <sigma1409> I'm very interested in python 3.4's new async system, it does seem to give the advantages of the reactor, without the unpleasantness or having to deal directly with it. However, I'm apparently odd in liking yield from
16:41:45 <eikke> but now when writing those things using Conduits (intend to look into pipes soon) feels so much better
16:42:20 <merijn> Maybe I'm not understanding what you mean with async file IO?
16:42:31 <simpson> File I/O that doesn't block your process.
16:42:47 <sigma1409> non-blocking might be a better term than async
16:42:56 <simpson> Anyway! What convinced me that Haskell's just not a fun venue for this stuff is that trying to do things on a timer or delay was incredibly difficult.
16:42:59 <typoclass> simpson: we have forkIO of course, since several ghc versions
16:43:05 <simpson> And pretty much every answer involved some sort of FRP.
16:43:12 <simpson> typoclass: Of course!
16:43:49 <merijn> simpson: How does file IO block your process in haskell?
16:43:57 <typoclass> simpson: i'm probably missing things, but there's threadDelay for delaying and System.Timeout for timeout stuff
16:43:58 <eikke> having timers is trivial :-/
16:44:01 <simpson> merijn: Same way that it blocks you everywhere else: Blocking syscall.
16:44:15 <merijn> simpson: So? If you run it in its own thread, who cares?
16:44:38 <simpson> typoclass: Correct! Now show me how to actually put that together into a server that ticks reliably with a given interval and still allows other threads of computation to run.
16:44:40 <tswett> Hafydd: huh, that's kinda cool.
16:44:46 <merijn> That's what the IO manager is for...
16:44:56 <simpson> merijn: It has to be forkOS, not forkIO. Surprise!
16:45:08 <merijn> simpson: Why? Haskell does that internally
16:45:10 <typoclass> simpson: no, i'd swear file i/o doesn't block in haskell. you just need to run with -threaded
16:45:25 <merijn> simpson: Haskell has separate threads for blocking system calls
16:45:44 <simpson> merijn: typoclass: And now you've walked into a whole 'nother minefield. I'm not saying that this is easier in Python, as you need an OS thread there, too.
16:46:02 <simpson> I'm saying that this is painful in pretty much every language, and Haskell doesn't get some sort of exemption here.
16:46:04 <merijn> simpson: I just don't see the problem?
16:46:05 <typoclass> simpson: i don't think -threaded is a minefield at all
16:46:13 <davean_> simpson: What you're describing is a non-problem
16:46:26 <davean_> simpson: haskell doesn't use blocking system calls
16:46:40 <merijn> Timers are a nasty, but they are nasty in any non-realtime system. If you want realtime you have to do your own scheduling anyway
16:46:41 <davean_> simpson: It multiplxes that via its IO manager
16:47:30 <simpson> davean_: Pop quiz: On which systems and under which conditions does the open() call block? >:3
16:47:37 <davean_> simpson: None!
16:47:50 <copumpkin> forkOS is only needed for FFI reasons
16:47:57 <simpson> davean_: Wrong! http://linux.die.net/man/2/open covers just one OS and it's *full* of fun.
16:47:59 <copumpkin> most people shouldn't need it
16:48:07 <copumpkin> simpson: that's why Haskell is a high-level language
16:48:10 <copumpkin> you don't have to care
16:48:12 <davean_> simpson: except you don't interact with that when using Haskell!
16:48:15 <copumpkin> someone else already cared for you
16:48:16 <davean_> simpson: so that page is irrelivent!
16:48:17 <merijn> simpson: Irrelevant from haskell
16:48:33 <simpson> I want the four of you to stop for a second and consider what you just said.
16:48:39 <geekosaur> you hope
16:48:44 <davean_> simpson: Having done kernel programming, I have
16:48:53 <typoclass> simpson: my view is, haskell does that quite well because internally, none of the system calls are blocking, the io manager uses select() or poll() or whatever is necessary, depending on the OS. to the haskell program the api makes it look like one thread is blocking on a file read, which fits well because haskell's threads are so cheap and you have no problems creating eleventy bazillion threads
16:48:55 <copumpkin> I know exactly what I just said
16:49:05 <merijn> simpson: Why? I'm pretty confident I know what I just said
16:49:22 <copumpkin> sure, if I were making manual calls to open, then I would need to be careful
16:49:25 <copumpkin> but that's not what we do
16:49:42 <merijn> typoclass: Haskell does blocking system calls internally, it just uses different OS threads for that, instead of the "standard" capabilities
16:49:45 <Peaker> simpson, Not sure that's what you meant but I whipped up "async" file I/O in the last few minutes
16:50:10 <merijn> s/Haskell/GHC RTS
16:50:14 <typoclass> merijn: ok fair enough, but i guess that doesn't change the situation
16:50:27 <typoclass> copumpkin: (... do we even have a haskell binding to the low-level open() call ...)
16:50:27 <Peaker> simpson, something like: http://hpaste.org/88134
16:50:29 <merijn> typoclass: The result is mostly the same, yes
16:50:47 <Peaker> simpson, is this the kind of async file I/O you mean?
16:50:53 <simpson> Peaker: Yeah, the async package massively improves life.
16:51:12 <copumpkin> simpson: can you elaborate on the thing you said we should consider?
16:51:15 <simpson> Peaker: Largely. It's still not actually going to be async, but it's probably as close as you can get from inside Haskell.
16:51:24 <Peaker> simpson, I'm still trying to figure out what it is that you're saying is easier in Python more specifically than "networking".   Haskell gives you the best of the world of threads and the world of async
16:51:32 <merijn> simpson: If it's "not actually async", how do you define async?
16:51:55 <copumpkin> simpson: have you looked at how the GHC IO manager is implemented?
16:52:02 <copumpkin> because it's pretty awesome
16:52:09 <simpson> copumpkin: Yes. When you say that something is irrelevant from *inside* a system, what you are failing to consider is that networking programming is all about the *external* effects which are outside the semantics of your system.
16:52:11 <Peaker> simpson, Python gives you the worst of threads, or the worst of events, and you have to choose between them
16:52:12 <merijn> It's more async than Node.js or twisted, so I don't really understand the point you're making?
16:52:20 <copumpkin> simpson: oh come on :)
16:52:24 <davean_> simpson: hahaha
16:52:41 <copumpkin> simpson: can you please read up on the IO manager and then resume preaching at us, if you still feel the need to
16:52:46 <simpson> Peaker: I choose to reject Python entirely.
16:52:52 <merijn> Now you're just trolling
16:53:13 <merijn> wtf does this even mean: "all about  the *external* effects which are outside the semantics of your system."
16:53:22 <rgrinberg> Peaker: python actually has a non shitty way for concurrency
16:53:27 <simpson> copumpkin: I end up in this conversation about twice per year on this channel, and Haskell *continues* to not have a networking library.
16:53:29 <rgrinberg> it's called gevent
16:53:31 <Peaker> simpson, you said earlier Python is your go-to language for GettingThingsDone? I'm really trying to figure out the benefits..   in my eyes, the main benefits of Python are an easy "reload", "eval", that are unnecessarily hard in Haskell
16:53:43 <simpson> Peaker: print an_object
16:53:44 <davean_> Ok, feeding the troll ...
16:53:44 <Peaker> rgrinberg, what's that?
16:53:45 <merijn> rgrinberg: Still pretty shitty compared to just blocking threads :)
16:53:48 <Sgeo> simpson, um... it has a few
16:53:52 <Peaker> > print (Just 5)
16:53:54 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
16:53:55 <lambdabot>    arising from a use of ...
16:53:58 <copumpkin> simpson: perhaps if you demonstrated better knowledge of GHC, you'd be more effective. I'm going to stop this before it goes too far off the deep end, so please desist
16:54:03 <davean_> simpson: The complexity of the open call comes from the semantics it operates under
16:54:13 <davean_> simpson: Haskell uses different ones
16:54:16 <rgrinberg> Peaker: cooperative micro threads that monkey patch the standard library on to yield on blocking calls
16:54:21 <davean_> the semantics isn't what you see externally
16:54:25 <davean_> they're entirely unrelated
16:54:29 <simpson> copumpkin: Only because you asked nicely.
16:54:36 <Peaker> rgrinberg, cooperative threads aren't as nice as GHC threads
16:54:39 <Sgeo> simpson, GHC takes the external stuff and hides it from the internal program
16:54:40 <typoclass> anyway. i'd be interested in a blog post or similar that discusses things that are easy in python. if for nothing else, for the thinking effort of how hard it would be in haskell
16:54:50 --- mode: ChanServ set +o copumpkin
16:54:52 <rgrinberg> Peaker: most of the times yes
16:54:54 --- mode: copumpkin set +b simpson!*@*
16:54:56 --- mode: copumpkin set -o copumpkin
16:55:09 <rgrinberg> they do have their advantages sometimes i think
16:55:17 <rgrinberg> at least in imperative land
16:55:18 <typoclass> copumpkin: simpson was gone already
16:55:24 <copumpkin> I know
16:55:35 <copumpkin> [19:53:18] <simpson>	 copumpkin: I end up in this conversation about twice per year on this channel, and Haskell *continues* to not have a networking library.
16:55:48 <copumpkin> perhaps it's best to avoid wasting everyone's time twice a year then :)
16:56:05 <rgrinberg> copumpkin: what should a networking library consist of?
16:56:10 <copumpkin> if his only goal is to come in here, stir up shit about GHC not having async, and then leave when he's unsuccessful
16:56:36 <merijn> rgrinberg: Pixie dust!
16:56:43 <Peaker> copumpkin, I don't think being wrong or abrasively wrong warrants a ban?
16:56:46 <acowley> I thought he/she was a regular? Am I misremembering a nick?
16:56:48 <sigma1409> Gevent/eventlet/tulip/stackless are the main ways to get concurrency in python without resorting to full os threads/processes or callback soup
16:56:48 <typoclass> copumpkin: i suppose he meant "a networking library" in the sense of "a go-to networking library". it is true that conduit is competing with pipes and others
16:57:16 <merijn> typoclass: All of those are like less than a year old, though
16:57:19 <rgrinberg> typoclass: there is plenty of competition in python land
16:57:23 <rgrinberg> or in any language really
16:57:24 <merijn> Or have I been under a rock?
16:57:42 <rgrinberg> who cares that they're young
16:57:55 <rgrinberg> frameworks in other languages have been around forever an *still* suck
16:58:01 <merijn> Anyhoo, bed time
16:58:02 <typoclass> merijn: no you're right, they are both fairly new
16:58:26 --- mode: ChanServ set +o copumpkin
16:58:28 --- mode: copumpkin set -b simpson!*@*
16:58:29 <sigma1409> using a python's coroutines is a fairly interesting way to implement a state machine, but other than they're a bit anaemic
16:58:32 --- mode: copumpkin set -o copumpkin
16:58:36 <merijn> rgrinberg: I was just pointing out that saying "conduits/pipes/whatever" is not a good response to networking in the past
16:58:40 <typoclass> acowley: true! i could have sworn there were several productive discussions with simpson. anyway, i guess he/she just went off the rails today
16:58:45 <copumpkin> Peaker: I think it was pretty blatant trolling myself, but we can see what happens next time
16:59:22 <merijn> Anyhoo, bed time!
16:59:49 <rgrinberg> merijn: yep, im very much interested in what haskell land can bring to the table
17:00:22 * davean_ imagines the fun of doing TCP Splicing with conduit/pipes/etc
17:01:23 <rgrinberg> i wonder why the OCaml ecosystem does not have any iteratee libs
17:01:38 <Sgeo> Conduits vs. Pipes vs. Machines for manipulating several sources of incoming input?
17:02:00 <Sgeo> Say, wanting to take event-based stuff and make it more... Haskell-y
17:02:08 <Sgeo> Several kinds of interesting events
17:02:52 <typoclass> so, what could be a benefit of a "real event loop"?
17:04:01 <davean_> typoclass: synced state machines?
17:04:14 <davean_> typoclass: "odd" cases like TCP splicing?
17:04:26 <typoclass> davean_: beats me!
17:04:43 <davean_> typoclass: I mean, synced state machines seems pretty hard except as a state machine
17:05:07 <davean_> er
17:05:10 <davean_> as an event loop
17:05:11 <davean_> sorry
17:05:45 <davean_> But maybe I just don't see a nicer method
17:05:50 <mekeor> i have a function "usage :: Writer Foobar ()" with "usage = foo >> bar >> baz". why does it behave completely differently when i do "usage = do foo; bar; baz" instead? (the output changes from http://hpaste.org/88135 to http://hpaste.org/88136.)
17:06:02 <davean_> places where states exit the sytem also seem like it might be nicer
17:06:11 <mekeor> (i can also paste the code if needed.)
17:06:40 <DonVitoCorleone> .mass POPUNI ZA TENKOVE http://tinyurl.com/upitnik-za-tenkove I CIM DOBIJES UDARAJ PO DO
17:06:49 <mekeor> @undo do { foo; bar; baz }
17:06:49 <lambdabot> foo >> bar >> baz
17:06:54 <DonVitoCorleone> .mass POPUNI ZA TENKOVE http://tinyurl.com/upitnik-za-tenkove I CIM DOBIJES UDARAJ PO DO
17:06:57 <Sgeo> mekeor, what happens with do { foo; bar; baz } (no idea if thats the issue
17:07:20 <troydm> i'm not sure wat dat means but i hope it's not spam
17:07:21 <mekeor> Sgeo: you mean with semicolons and the brackets?
17:07:25 <Sgeo> mekeor, yes
17:07:47 <mekeor> Sgeo: still bad output
17:08:19 --- mode: ChanServ set +o monochrom
17:08:44 --- mode: monochrom set +b $a:DonVitoCorleone
17:08:49 --- kick: DonVitoCorleone was kicked by monochrom (DonVitoCorleone)
17:09:07 <mhitza> mekeor: paste the code as well
17:09:07 <mekeor> the code: http://hpaste.org/88137
17:09:22 --- mode: monochrom set -o monochrom
17:09:25 <mekeor> sorry, it's long :O
17:09:39 <monochrom> here in #haskell we only worship Don Stewart :)
17:10:19 <cmccann> don stewart, godfather of the haskell mafia
17:10:52 <mekeor> mhitza: so line 22-40 for the function which i was talking about ;)
17:11:37 <mekeor> monochrom: i worship you :) well, at least see you as idol :D
17:11:48 <mekeor> monochrom: and now say me what's wrong with my code ;) :D
17:12:45 <mekeor> i mean, what's the difference between "f = do foo; bar; baz" and "f = foo >> bar >> baz" ????
17:12:53 <acowley> Your Monoid instance is setting off warning bells for me
17:12:59 <acowley> associativity perhaps?
17:13:22 <Fuuzetsu> mekeor: the second one doesn't cause the cancer of the semicolon
17:13:30 <mekeor> acowley: nope, don't think so
17:13:46 <mekeor> Fuuzetsu: pardon? what?
17:14:13 <Fuuzetsu> sorry I just read up
17:14:15 <Fuuzetsu> I'm tired.
17:14:20 <mekeor> Fuuzetsu: ah, yeah. but you don't need semicolons in do-notation with indentation ;) :D
17:14:21 <dolio> The associativity is different.
17:14:31 <acowley> I tried :/
17:14:34 <pqmodn> mekeor: it's a reference to an Alan Perlis quote: "too much syntax sugar causes cancer of the semi-colon"
17:14:35 <Fuuzetsu> Yeah.
17:14:36 <mekeor> dolio: O.o
17:14:58 <mekeor> pqmodn: ah
17:15:12 <acowley> :i (>>)
17:15:16 <Fuuzetsu> :t (>>)
17:15:18 <lambdabot> Monad m => m a -> m b -> m b
17:15:21 <merijn> mekeor: The first probably parses "(foo >> bar) >> baz" whereas the ; notation might parse as "foo >> (bar >> baz)"
17:15:25 <acowley> Why do we not have an :info command?
17:15:26 <geekosaur> mekeor, if it's just `foo` then it's the same; if `foo` is an expression using, say, ($), then you need parentheses
17:15:29 <merijn> @info (>>)
17:15:29 <lambdabot> (>>)
17:15:35 <merijn> oh, bah
17:15:37 <pqmodn> that's why :)
17:15:39 <acowley> thanks lambdabot, very helpful
17:15:39 <Fuuzetsu> it's just λ _ → f
17:15:43 <monochrom> yeah, do-notation makes right-associative
17:15:46 <mekeor> merijn: what the hack! i thought of that but i thought that's impossible!
17:15:46 <acowley> exactly
17:16:16 <acowley> The jankyness of the Monoid instance should make you itchy in any case.
17:16:17 <mekeor> so i can't use do-notation??? OMG!
17:16:30 <mekeor> i did all this to be able to use do-notation :(
17:16:32 <merijn> mekeor: "do { foo; bar; baz }" translates to "foo >> do { bar; baz }"
17:16:43 <napping> >> is infixl1
17:16:50 <mekeor> yeah
17:16:58 <monochrom> but why should it matter, if you have a correct monoid
17:17:00 <merijn> mekeor: Stop implementing hacky non-associative monoid instances, then!
17:17:01 <napping> your monad instance is bad if they are not equivalent, but I suppose there might be a performance difference
17:17:01 <mekeor> is there anyway i can use do anyway?
17:17:05 <elliott> that Monoid instance looks incredibly wrong
17:17:06 <mekeor> *any way
17:17:16 <mekeor> napping: Monoid?
17:17:18 <merijn> napping: Naah, the monad instance is right
17:17:22 <dolio> monochrom: Performance.
17:17:24 <mekeor> elliott: why? :O
17:17:27 <merijn> napping: The monoid for writer is wrong
17:17:29 <elliott> mekeor: does it obey the laws?
17:17:35 * acowley is from the future
17:17:46 <mekeor> elliott: uhm :D heh. i don't think so, i'm not sure
17:17:51 <mekeor> probably not
17:17:52 <napping> it's a law that (f >> g) >> h should equal f >> (g >> h)
17:18:07 <djahandarie> If you break it the Haskell cops come after you
17:18:09 <pqmodn> do not collect $200
17:18:11 <mekeor> ah
17:18:12 <merijn> napping: Yes, but Writer is only a lawful monad if you monoid is correct
17:18:36 <mekeor> elliott: so, if it'd hold the laws, the do-notaion and the >>-notation would be the same, right?
17:18:37 <merijn> napping: So the problem is not Writer, but the monoid he's using with it
17:18:43 <merijn> mekeor: Yes
17:18:45 <elliott> mekeor: yes
17:18:48 <mekeor> :(
17:19:30 <merijn> mekeor: Show your monoid instance?
17:19:45 <mekeor> merijn: hm?
17:19:47 <pqmodn> mekeor: http://hpaste.org/88137
17:19:52 <pqmodn> er, merijn http://hpaste.org/88137
17:20:12 <merijn> ah, missed that
17:20:19 <monochrom> look for "instance Monoid State where"
17:20:52 <merijn> I asked more for other people to help, because I should go to bed like I said 30 mins ago :p
17:22:03 <mekeor> uhm, so the only way for me to make the do-notation usable is trying to make this monoid-instance hold the laws? :(
17:22:12 <pqmodn> yep
17:23:11 <acowley> Haskellers are, at least publicly, a law-abiding bunch. We only unsafeCoerce behind closed doors.
17:23:20 <mekeor> :D
17:24:20 <Peaker> and in the lens library, 124 times
17:25:07 <acowley> No peaking! (Damn appropriate username)
17:25:16 <pqmodn> ekmett is the law
17:26:06 <mekeor> why do i get a warning because of non-exhaustive pattern-match(es) on this line?: http://hpaste.org/88137#line142
17:26:47 <Sgeo> mekeor, Haskell probably isn't smart enough to know that one of those three will always return True
17:27:01 <mekeor> :( ok
17:27:02 <pqmodn> mekeor: replace the last with "otherwise"
17:27:08 <mekeor> ah okay :D
17:27:39 <Sgeo> Hmm, wow I'm rusty. Was about to suggest using compare and pattern-matching on that
17:27:41 <Sgeo> :t GT
17:27:42 <lambdabot> Ordering
17:27:47 <Sgeo> *on the Ordering
17:28:36 <arkeet> Sgeo: I would do that too.
17:29:35 <elliott> that is better than guards, yes
17:30:06 <mekeor> but you'd have to use compare in another function-definition, or how exactly?
17:30:22 <arkeet> case
17:30:31 <mekeor> oh right :D
17:30:51 <pqmodn> elliott: why is one preferred over the other?
17:31:09 <elliott> pqmodn: same reason pattern matching is better than checking isJust and then doing fromJust
17:31:12 <elliott> or checking null and then doing head
17:31:43 <elliott> you have the guarantee that your cases "make sense" (i.e. the various possibilities are mutually exclusive and are all "about" the same thing, the ordering of the two things), and cover all possible cases
17:31:55 <elliott> also, there is likely a performance benefit to using compare over doing multiple comparison checks in general
17:32:17 <pqmodn> hmm, i see
17:34:18 <magicman> I could see GHC being smart enough to compile isJust/fromJust to the same code as the pattern matching version. Multiple structural checks may be trickier, true.
17:35:26 <elliott> magicman: it does
17:35:29 <elliott> but there are benefits other than performance
17:35:31 <elliott> monochrom has a nice article on this
17:35:34 <elliott> @where crossroads
17:35:34 <lambdabot> I know nothing about crossroads.
17:35:36 <elliott> there, http://www.vex.net/~trebla/haskell/crossroad.xhtml. (I seem to be lagging.)
17:35:54 <magicman> Oh yeah. I agree about the static checks that pattern matching enable.
17:36:11 * magicman will read that article anyway, because hey, new article.
17:36:46 <mekeor> :D
17:38:19 <monochrom> and after that, don't forget http://article.gmane.org/gmane.comp.lang.haskell.cafe/104783/ :)
17:39:56 <mekeor> haha
17:40:02 <magicman> Nice XD
17:40:46 <cmccann> monochrom: is that the bit where ghc outsmarts your attempt to make a point?
17:40:51 <cmccann> that was beautiful.
17:40:51 <monochrom> yes
17:41:07 <Hafydd> Hahahah.
17:42:06 <copumpkin> I love me some :print in ghci
17:48:31 <pqmodn> copumpkin: what does it mean? i notice it shows nested quantifiers that :type does not (eg the difference between <*> and <$> seems to be important)
17:48:50 <copumpkin> try
17:48:53 <copumpkin> let xs = [1..]
17:48:55 <copumpkin> :print xs
17:48:58 <copumpkin> head xs
17:49:02 <copumpkin> :print xs
17:49:09 <copumpkin> xs !! 5
17:49:11 <copumpkin> :print xs
17:49:13 <pqmodn> woah
17:49:28 <pqmodn> nice :)
17:49:37 <copumpkin> now play around with fingertrees and behold the magnificence
17:51:43 <mekeor> cool :)
17:51:55 <mm_freak> a few hours ago i was asked why it's called 'monoid'…  my answer was:  mono = one, a one-object category
17:52:03 <mm_freak> while it makes sense i'm not sure whether it's actually correct
17:56:05 <byorgey> http://math.stackexchange.com/questions/156952/why-the-terminology-monoid
17:56:42 <applicativer> monochrom: nice module E.  If you compile without optimizations, feval is perfectly hideous.  It stands to reason that in more complicated cases the compiler wouldn't see how to make it unhideous with -Owhatever, so I say you were right
17:59:33 <applicativer> byorgey: funny I looked into this question the other day. There seems to be a much older geometrical use of monoid
17:59:48 <elliott> I think it would work as long as the compiler can inline isFoo and fromFoo
17:59:57 <elliott> and since those are small I think they'd be likely to in practice?
18:00:23 <byorgey> applicativer: I'm not surprised.  I imagine it probably arose independently several different times.
18:01:05 <cmccann> hopefully people at least aren't trying to credit Leibniz there too.
18:01:37 <applicativer> byorgey: yes it looks independent 'on the types of monoidal involutions' Virgil Snyder 1915
18:02:49 * acowley retcons to monadology
18:03:01 <roconnor> is there a bayhac irc channel?
18:03:17 <mm_freak> byorgey: that question doesn't seem to have a conclusive answer
18:03:20 * applicativer affirms that there were no monoids in monadology
18:03:36 <byorgey> mm_freak: I believe you.
18:03:41 <acowley> applicativer: The goal here is to rile up cmccann.
18:03:57 <cmccann> :[
18:04:58 <mm_freak> i guess, if you continue my logic, then a two-objects category would be a bid, did, duid or maybe duoid?  bioid?  dioid?
18:05:29 <mm_freak> biid, diid…
18:06:59 <cmccann> mm_freak: dyid, surely.
18:07:43 <mm_freak> zweiid
18:08:13 <cmccann> no no no germanic roots don't sound fancy enough.
18:08:19 <cmccann> that's not how it's done.
18:08:24 <mm_freak> hmm, too bad
18:08:47 <heathern> ohai guise, me again
18:09:04 <heathern> just wondering if someone can demonstrate how to use Data.Text.any
18:09:10 <mm_freak> cohai disguise, you again
18:09:36 <mm_freak> heathern: T.any isLetter "blah" = True
18:09:42 <mm_freak> heathern: T.any isLetter "123" = False
18:11:25 <no-n> why not just use any
18:12:13 <heathern> <interactive>:35:41: parse error on input `='
18:12:21 <heathern> however
18:12:24 <heathern> Data.Text.any Data.Char.isLetter "blah" == True
18:12:32 <heathern> returns Couldn't match expected type `Text' with actual type `[Char]'
18:12:39 <heathern> so close!
18:12:45 <mm_freak> heathern: sorry, i assumed -XOverloadedStrings
18:12:50 <heathern> i can feel it meh bones
18:13:25 <mm_freak> heathern: import qualified Data.Text as T
18:13:28 <mm_freak> import Data.Char
18:13:36 <mm_freak> T.any isLetter (T.pack "blah")
18:14:13 <heathern> interesting!
18:14:18 <heathern> thank you mm_freak
18:14:40 * heathern idles as heath and fetches food
18:15:37 <monochrom> "xxx == True" is the same as "xxx"
18:17:01 <monochrom> but some people like to speak like "if tomorrow is sunny is true, I will go out is true". it's true!
18:20:52 <mekeor> how can i make cabal/haddock generate docs for ANYTHING there's a documentation for? (including non-exported stuff.) (i already asked this once but forgot the answer. (- i think it wasn't helpful.))
18:21:12 <mekeor> --internal only seems to generate docs for internal modules..
18:21:42 <mekeor> (that is, "cabal haddock --internal" and "cabal install --haddock-internal".)
18:24:57 <applicativer> the solution to call the modules Internal, but export everything, otherwise we will want to kill you anyway
18:25:51 <mekeor> "the solution IS to call..."?
18:26:02 <applicativer> yes mekeor
18:26:06 <mekeor> :)
18:26:28 <mekeor> applicativer: but why should i call them Internal? :O
18:26:39 <dmwit> It's the Python attitude.
18:26:43 <dmwit> We're all consenting adults.
18:26:52 <applicativer> well, then we know you dont want use to use them
18:27:01 <dmwit> But the conventional word for consent is "Internal" instead of "yes" like in meatspace.
18:27:18 <applicativer> but if we don't have access to them, its a nightmare
18:28:09 <applicativer> What is the Python attitude dmwit?
18:28:17 <dmwit> See the line right after that.
18:28:36 * applicativer did, but was still a little lost. ok
18:28:50 <dmwit> Oh, okay then. It's a reference to the idea that there are no private variables.
18:28:54 <applicativer> ah
18:28:57 <applicativer> thank you
18:29:02 <dmwit> Only ones that you should know something about before touching.
18:29:17 <dmwit> In Python, the word for consent is double underscore.
18:29:26 <dmwit> If my memory serves.
18:29:35 <applicativer> 'there are no private variables', but some, you should consent to them
18:29:39 <dmwit> yes =)
18:29:50 <elliott> it's single underscore
18:29:51 * roconnor uses python reflection to search for all class member variables that are integers and adds one to them cause I know what I'm doing.
18:29:57 <elliott> double underscore gets the names mangled
18:30:01 <elliott> (but still publicly accessible)
18:30:07 <elliott> no idea why anyone thought that was a good idea
18:30:31 * applicativer would believe that 'roconnor knows what he's doing' in most contexts
18:30:41 <applicativer> but python reflection??
18:30:41 <cmccann> because most people who create languages know nothing about creating languages when they start.
18:30:52 <cmccann> and sometimes they know nothing after they finish, either.
18:31:03 <applicativer> take English
18:31:08 <applicativer> please
18:31:08 <mekeor> heh
18:31:48 <applicativer> Cultofmetatron wow.
18:34:16 <roconnor> hi conal
18:34:24 <copumpkin> hi roconnor
18:34:27 <conal> roconnor: hi
18:34:36 <roconnor> copumpkin, where are you?
18:34:43 <conal> roconnor: what brings you to town?
18:34:44 <copumpkin> I'm right here, how about you?
18:34:53 <roconnor> In the dojo
18:35:02 <copumpkin> oh, I'm on the wrong side of the country
18:35:12 <copumpkin> :(
18:35:13 <roconnor> conal, BayHac and a few other events that are all happening at the same time
18:35:19 <copumpkin> I should have listened to shachaf
18:35:26 <roconnor> heh
18:35:33 <roconnor> shachaf convinced me to come :D
18:36:09 <shachaf> hi roconnor
18:36:17 <roconnor> shachaf, where are you?
18:36:25 <shachaf> Front-left table.
18:36:54 <monochrom> God, you're in the same room and use IRC to converse
18:37:28 <dmwit> I've done that with byorgey when it makes sense for the rest of the channel to hear what we're thinking.
18:37:36 <shachaf> Can you do m (t m a) -> t m a in general?
18:38:03 <dmwit> :t join . lift
18:38:04 <lambdabot> (Monad m, Monad (t m), MonadTrans t) => m (t m a) -> t m a
18:38:54 <elliott> if I shout really loud shachaf and roconnor will be able to hear me
18:39:09 <elliott> much better than IRC.
18:52:16 <shachaf> dmwit: Oh, I had that, but my newtype messed it up.
18:52:27 <shachaf> OK, what I have is already general.
18:53:29 <magicman> @type join . liftM lift
18:53:30 <lambdabot> (Monad m, Monad (t m), MonadTrans t) => t m (m a) -> t m a
19:11:50 * applicativer has found the solution to his difficulty with the types in  pipes-parse
19:12:09 <applicativer> "Mild electric shocks to brain may help students solve maths problems; Psychologists find students do puzzles 27% faster after non-invasive procedure than those who had no treatment"
19:12:45 <monochrom> it is scary. use at own risk :)
19:13:12 <liyang> Didn't they do that at the beginning of Ghostbusters?
19:13:27 <applicativer> well, it's worth a try
19:14:26 <applicativer> six students vs six controls ... that's science, that's not an anecdote
19:20:32 <Aetherspawn> Someone got an idea why I get this error? http://hpaste.org/88146
19:21:01 <Aetherspawn> serverApp :: Application SessionIO
19:21:46 <Aetherspawn> SessionIO is just Session and IO fused
19:21:55 <hualet> :)
19:24:57 <Ndit> has anyone ever successfully used Haskell as a kinda scripting language bound inside C++? With the interpreter. I've looked at HINT. Any other ideas?
19:27:07 <liyang> Aetherspawn: I'm only guessing what RST is, but try liftIO (runTCPServer settings serverApp)
19:27:16 <liyang> Or just lift.
19:27:30 <Aetherspawn> oh yeah
19:28:51 <liyang> But you won't have to do that if you can write (or find) an instance MonadBaseControl IO (RST r s IO).
19:30:06 <liyang> Did you define SessionIO yourself? That might not be how you're supposed to use MonadBaseControl &c.
19:31:27 <edwardk> preflex: xseen Philippa
19:31:28 <preflex>  Philippa was last seen on freenode/#haskell 10 days, 5 hours, 31 minutes and 23 seconds ago, saying: Control.Monad.Writer is a little less filthy, more powerful and surprisingly easy to rig up, too
19:31:51 <Aetherspawn> liyang, ick
19:31:53 <edwardk> @tell Philippa I may have something slightly stronger than a VPL that is interesting
19:31:53 <lambdabot> Consider it noted.
19:32:10 <Aetherspawn> I can't seem to lift the right type up
19:33:12 <Aetherspawn> RST feels like a shortcoming. I /know/ transformers are supposed to be used
19:33:24 <Aetherspawn> but RWS exists in transformers and RS doesn't :\
19:33:43 <Aetherspawn> So I had to roll my own ReaderT . StateT
19:33:55 <Aetherspawn> /s/I/we
19:34:15 <liyang> Who are "we"?
19:34:47 <dmj> I'm having issues with an html parser I'm creating. The content inside of header tags isn't being parsed. I only care about the tables.
19:34:51 <dmj> http://hpaste.org/88147
19:35:33 <liyang> Aetherspawn: could you use RWST and just live with the negligible performance hit?
19:36:15 <Saizan> dmj: unless this is to learn parsec, maybe you could use tagsoup
19:36:16 <Aetherspawn> liyang, preferrably not
19:36:32 <edwardk> Aetherspawn: lots of folks have implemented RWT, RST, RWT, etc. over the years in little libraries
19:36:57 <Aetherspawn> edwardk, any idea what one of them might be called?
19:37:04 <liyang> Aetherspawn: care to elaborate?
19:37:15 <edwardk> Aetherspawn: there is one in snap for instance
19:37:30 <Aetherspawn> liyang, the errors dont sprout from the RST I don't think
19:37:32 * hackagebot network-bitcoin 1.2.1 - An interface to bitcoind.  http://hackage.haskell.org/package/network-bitcoin-1.2.1 (ClarkGaebel)
19:37:51 <dmj> Saizan: tagsoup returns literally soup. Just one giant list of html elements, I need to write a parser for that alone.
19:37:59 <edwardk> Aetherspawn: that said, ReaderT e (StateT s m) a  winds up with the same shape as what you are building if you rip out the newtype noise
19:38:19 <liyang> It's not an error per se, it's telling you that you don't have / haven't written an instance MonadBaseControl IO (RST r s IO).
19:38:38 <edwardk> Aetherspawn: the only one that doesn't get the 'right' shape would be state + writer, because it doesn't build a triple for the result, but instead winds up with nested tuples
19:38:40 <dmj> Saizan: Parsec is nice because of the langugae def, I'm just stuck on this error
19:39:11 <edwardk> Aetherspawn: my rule of thumb is to write the code in terms of MonadState and MonadReader and then come through with whatever i want to use later on
19:39:23 <edwardk> hen i can benchmark the alternatives
19:39:56 <Aetherspawn> hmm, thanks
19:40:13 <dmj> Saizan: Maybe I'm using it incorrectly, it'd be nice if it had a getTables :: [String] -> [HTML] or something :) I'm just calling getTags with it
19:40:22 <edwardk> it also means i have to refactor the code less later on and i get more general signatures
19:40:47 <dmj> parseTags*
19:41:58 <Saizan> dmj: you could write a parser which start from the html tags as tokens
19:42:40 <Saizan> dmj: anyhow i think the problem is that reserved expects a space or eof after the reserved string
19:43:58 <dmj> Saizan: Where do you see that?
19:45:22 <Saizan> dmj: http://hpaste.org/88148
19:47:22 <dmj> Saizan: Is there a place in the language def where I can specify that whitespace is irrelevant?
19:48:01 <Saizan> dmj: i'm not that familiar with that part of parsec
19:54:40 <monochrom> parsec's makeTokenParser is unsuitable for HTML
19:55:22 <dmj> monochrom: why?
19:55:48 <dmj> because html elements can contain more than just alphaNum characters?
19:57:04 <monochrom> suppose your language has a reserved word "let". when I input "lettive", do you consider to be two tokens (1st token reserved "let", 2nd token identifier "tive")? or one token (identifier "lettive")?
19:57:26 <monochrom> same question for "<td></td>"
19:58:26 <dmj> monochrom: I see, hadn't even thought about the empty td case
19:59:12 <monochrom> that is not my point. "<table><tr>" has exactly the same consideration
20:00:21 <cmccann> solution: construct your entire language using only single-character tokens.
20:00:35 <cmccann> with a good unicode font, you have plenty to pick from!
20:00:39 <zRecursive> then what's the best parder for HTML ?
20:00:47 <zRecursive> s/parder/parser
20:00:55 <a-gjp> But APL exists already.
20:01:01 <monochrom> Token is written for programming languages, where "lettive" is not ["let", "tive"] just because "let" is a prefix. therefore "<table><tr>" is not ["<table>", "<tr>"] just because "<table>" is a prefix. no matter how many times you swear that "<table>" is reserved.
20:01:29 <cmccann> a-gjp: hm, was everything in APL single characters? I actually don't know APL.
20:02:12 <monochrom> this is why I too recommend tagsoup. it does give you the desired token stream.
20:02:43 <a-gjp> cmccann: Not everything, but as far as I remember it, all standard functions are special symbols.
20:04:37 <dmj> monochrom: what about tagstream-conduit? http://hackage.haskell.org/package/tagstream-conduit
20:04:45 <monochrom> I don't know about that
20:05:16 <a-gjp> And because these symbols are all non-ascii, all longer tokens like variables and literals can be distinguished easily.
20:05:17 <monochrom> but you can use parsec to process the token stream produced by tagsoup
20:07:52 <dmj> monochrom: how? I was planning on just trying to filter the list and extract only the tables and everything in them
20:08:30 <monochrom> if you plan works, then stick to it
20:08:59 <dmj> monochrom: ok I'll try it with parsec
20:10:04 <dmj> tagsoup + parsec that is
20:12:45 <monochrom> then see my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#token for how parsec can parse [T] where T is not Char
20:17:10 <monochrom> or use purely parsec. just write your own code to detect tags and comments, don't use Token
20:17:10 <dmj> monochrom: have you tried this? http://hackage.haskell.org/package/tagsoup-parsec
20:17:18 <monochrom> I have not
20:18:44 <otters> someone should add a flag to ghci to ignore $HOME/.ghci
20:18:51 <otters> but use ./.ghci and so forth
20:19:33 <monochrom> that is the default
20:19:37 <otters> is it
20:19:44 <otters> it's not
20:19:47 <otters> not in GHC 7.6.3 at least
20:19:54 <dmj> monochrom: Thanks for this link
20:20:16 <otters> the docs say it loads ./.ghci then ~/.ghci in sequence
20:21:03 * geekosaur wonders what happens if you set -ignore-dot-ghci in ./.ghci
20:21:11 <monochrom> I see. but perhaps exploit -ignore-dot-ghci -ghci-script ./.ghci
20:21:17 <otters> oh
20:21:56 <otters> oh, that works
20:21:59 * monochrom is a composer
20:22:03 <blaenk> sup geekosaur
20:25:10 <monochrom> ":set -ignore-dot-ghci" inside .ghci does not have an effect
20:25:54 <monochrom> it is a static flag
20:49:59 <stepcut> @getshapr
20:49:59 <lambdabot> shapr!!
20:59:53 <johnw> preflex: seen shapr
20:59:53 <preflex>  shapr was last seen on #haskell 32 days, 3 hours, 40 minutes and 24 seconds ago, saying: Is there already a TH+QC golf module that tries to simplify a given expression?
21:30:46 <dmwit> > sort [(2/5, "helmet"), (6/8, "chestplate"), (5/7, "leggings"), (2/4, "boots")]
21:30:48 <lambdabot>   [(0.4,"helmet"),(0.5,"boots"),(0.7142857142857143,"leggings"),(0.75,"chestp...
21:53:49 <tgeeky> dmwit: those must be some precisely manufactured leggings
22:01:01 <no-n> > (putStrLn . intercalate " " . replicate 8) "hello"
22:01:02 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
22:01:02 <lambdabot>    arising from a use of ...
22:01:18 <no-n> > (intercalate " " . replicate 8) "hello"
22:01:20 <lambdabot>   "hello hello hello hello hello hello hello hello"
22:04:05 <orzo_>     Ambiguous module name `Prelude':
22:04:06 <orzo_>       it was found in multiple packages: base haskell98-2.0.0.1
22:04:12 <orzo_> how do I address that?
22:04:25 <orzo_> uninstall haskell98-2.0.0.1 ?
22:07:39 <blackdog> hm, this is odd. why is cabal install --disable-benchmarks still trying to install criterion? It's not specified in the Library section.
22:08:59 <_anycat> Ok, going to start learning haskell as my first official 100% language
22:09:37 <_anycat> Which text editor would be best for windows?
22:09:55 <zomg> official 100% language? are there 99% languages too? =)
22:10:09 <elliott> you can use anything. I hear notepad++ is popular.
22:10:16 <oio> how to add modules with only ghc installed?
22:10:18 <_anycat> Yeah, most are 87.6%
22:10:29 <elliott> you likely want to set it to use spaces instead of tabs, or we'll be answering a question about why your code has a syntax error some weeks down the line :)
22:10:56 <_anycat> I looked at notepad++ but didnt see any references to haskell
22:12:20 <_anycat> I was deciding between clojure and haskell. You win because they download and setup was painless. Plus it was hashed, so integrity of the download was assured.
22:12:30 <_anycat> *the
22:13:03 <NemesisD> had a lens question. i've got: data Metric a = Metric { _metricId :: a } makeClassy ''Metric, i want to define a class HasResourceId i, so I could do instance HasResourceId (Metric ID) where resourceId = metricResourceId
22:13:35 <NemesisD> problem though is that the metricResourceId lens has the constraint of HasMetric, so i can't define the type in the HasResourceId class
22:14:12 <edwardk> class HasResourceId t where resourceId :: Lens' t ID      or class HasResourceID t a | t -> a where resourceId :: Lens' t a
22:14:19 <edwardk> which one are you looking for?
22:14:48 <_anycat> Is everybody happy?  :-)
22:15:02 <edwardk> you can of course use metricId.resourceId
22:15:07 <elliott> _anycat: you don't need a haskell-specific editor to edit haskell
22:15:12 <elliott> but if you want one, try leksah
22:15:31 <edwardk> instance HasResourceId a => HasResourceId (Metric a) where resourceId = metricId.resourceId
22:15:43 <edwardk> not sure what is or has an id in your world
22:15:43 <NemesisD> edwardk: i think the second one. don't need to lock it down to ID.
22:16:00 <NemesisD> i'm not sure I understand the syntax around HasResource t a | t -> a
22:16:21 <edwardk> thats saying it is a multiparameter typeclass and the first parameter is enough to determine the second
22:16:23 <edwardk> thats a fundep
22:16:29 <_anycat> Thanks elliott
22:16:46 <edwardk> class Monad m => MonadState s m | m -> s where get :: m s; put :: s -> m ()
22:16:52 <edwardk> there the second parameter determines the first
22:16:54 <edwardk> :t get
22:16:55 <lambdabot> MonadState s m => m s
22:17:16 <oio> get data.list on ghc ?
22:17:45 <NemesisD> hmm let me give it a shot
22:17:58 <edwardk> so class HasResourceId t a | t -> a where resourceId :: Lens' t a -- says you can get a resource id of type 'a' out of 't'. which is a sensible thing if you have multiple ID types
22:18:29 <edwardk> but if an ID is just an Int or something then perhaps just using class HasResourceId t where resourceId :: Lens' t Int -- would give easier inference, etc.
22:18:44 <NemesisD> edwardk: how should i read Lens' t a
22:19:05 <edwardk> Lens' t a is a monomorphic lens that knows how to get (and replace) an 'a' inside a larger 't'
22:19:13 <edwardk> read Lens' like (->)
22:19:29 <edwardk> t -> a  knows how to get an 'a' using 't'. Lens' t a knows how to get an 'a' using 't' as well
22:20:05 <edwardk> Lens s t a b is the more general form. in that setting given an 's' you can get an 'a', and given another 'b', we'll give you back a 't'.
22:20:28 <NemesisD> ah, i could mnemonically interpret t a as from -> to in the getter case
22:21:08 <edwardk> the '  convention simplifies away the distinction, making it so you can't do type-changing assignment and the other lens tricks
22:21:20 <NemesisD> nice
22:21:46 <NemesisD> i have a hard time loading more than 2 type parameters into my brain at once
22:22:31 <johnw> NemesisD: and you're reading lens code?
22:22:46 <NemesisD> johnw: writing it D:
22:23:34 <johnw> ah, props
22:23:41 <NemesisD> i'm sure my use of lens is about as barbaric and simplistic as you can get, my knowledge of it is pretty incomplete
22:23:46 <NemesisD> i wouldn't recommend it
22:23:54 <NemesisD> my strategy. i would recommend lens*
22:23:57 <johnw> as far as I knew, that's the only kind of knowledge of lens that anyone has access to :)
22:26:30 <NemesisD> i really got sold on lens on how easy it made it in a previous project to reach deep into fairly complex data structures and do manipulations concisely
22:26:38 <johnw> yes, it's brilliant for that
22:27:16 <NemesisD> but i haven't gotten much more in depth than that. mainly because i burn out my projects before it would become useful. the burnout is not due to lens
22:29:15 <johnw> lens isn't focusing the intensity of the sun onto your brain?
22:30:02 <NemesisD> lol
22:45:06 <_anycat> (Thanks. Bye for now.)
22:50:57 <carter> edwardk soon my multicriterion template for benchmark data will be ready
22:51:10 <carter> just one more weird js bug I need to find an expert js friend to fix
22:51:16 <carter> mwahahah
23:14:29 <carter> etrepum sent yah the email
23:18:01 <etrepum> carter: cool, what is the bug? is it just the units?
23:18:11 <carter> etrepum yeah, i think so at this point
23:18:17 <carter> if you look at the means lower down
23:18:29 <carter> you'll see that the morton z ones should be micro seconds not millis
23:18:37 <carter> once i figure out that last bit
23:18:44 <carter> i'll factor it out into a template properly
23:18:54 <carter> and just have it as my default criterion tempalte
23:19:06 <carter> because for me
23:19:25 <carter> its all about tracking the relative performance of "equivalent" algoirthms
23:19:32 <carter> and i cant spell right now
23:19:52 <carter> then i can move on
23:19:55 <carter> to messing with cmm
23:20:08 <carter> and i have a neat trick that should make run time generated functions nice to use
23:20:13 <carter> and i want to benchmark it all
23:20:15 <carter> very clearly
23:20:17 <carter> and this will help
23:20:48 <carter> theres enough orders of magnitude in all the things i'm benching that if i don't have each operation group in a seperate plot
23:20:59 <carter> the micro ops would all be plotted at zero
23:21:28 <carter> cause 10 micro seconds is ~ 0 when next to stuff running for .08-2 seconds
23:22:49 <carter> etrepum if that answers your question
