00:00:03 * hackagebot asn1-types 0.1.3 - ASN.1 types  http://hackage.haskell.org/package/asn1-types-0.1.3 (VincentHanquez)
00:10:03 * hackagebot egison 3.0.1 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-3.0.1 (SatoshiEgi)
00:54:04 <fetter_oml> good day to you sirs.
00:54:04 <fetter_oml> today i've stumpled on "forall" in a type declaration the first time:
00:54:19 <fetter_oml> (>>=) :: forall a b.  m a -> (a -> m b) -> m b from http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html#v:-62--62--61-
00:54:55 <ion> @type (>>=)
00:54:56 <lambdabot> Monad m => m a -> (a -> m b) -> m b
00:55:02 <ion> In that, the “forall a b.” is just implied.
00:55:04 <fetter_oml> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types tells me that this is pretty much the same as
00:55:04 <fetter_oml> (>>=) ma -> (a -> mb) -> mb
00:55:24 <fetter_oml> ion: jep. then why use it at all?
00:56:23 <fetter_oml> note that the same library page about Control.Monad
00:56:24 <fetter_oml> return :: a -> m a
00:56:24 <fetter_oml> is defined like always
00:56:37 <ion> Hm, i’m not sure why they chose to use an explicit forall there.
00:57:22 <fetter_oml> mhm, k. just wondered if there was some special meaning behind it.
00:57:28 <fetter_oml> thank you very much
00:59:31 <ion> Some foralls do make a semantic difference, but i’m pretty sure that one doesn’t.
00:59:42 <shachaf> ion is correct
00:59:47 <shachaf> listen to ion
01:00:00 <ion> Don’t listen to shachaf, he’s lying.
01:00:07 <fetter_oml> :)
01:00:20 <shachaf> "(>>=) ma -> (a -> mb) -> mb" is a syntax error.
01:00:33 <shachaf> But it does mean (>>=) :: m a -> (a -> m b) -> m b
01:01:30 <fetter_oml> yeah, didnt press enough buttons. forgot that there was copypaste
01:02:14 <shachaf> ("it" being the forall-ed thing, not the syntax error.)
01:20:04 * hackagebot finite-field 0.6.0 - Finite Fields  http://hackage.haskell.org/package/finite-field-0.6.0 (MasahiroSakai)
02:00:05 * hackagebot plot 0.1.8 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.1.8 (VivianMcPhail)
02:20:05 * hackagebot sequor 0.3.1 - A sequence labeler based on Collins's sequence perceptron.  http://hackage.haskell.org/package/sequor-0.3.1 (GrzegorzChrupala)
02:21:07 <haasn> ‘forall’ is only necessary for rank 2+ types and when using scoped type variables, unless I've forgotten something
02:26:36 <shachaf> Existential types.
02:45:06 * hackagebot Monaris 0.1.6 - A simple tetris clone  http://hackage.haskell.org/package/Monaris-0.1.6 (FumiakiKinoshita)
03:20:07 * hackagebot hyakko 0.5.0 - Literate-style Documentation Generator  http://hackage.haskell.org/package/hyakko-0.5.0 (JeremyHull)
03:30:57 <Jaxan> Is there a standard function which is flip <$> ?
03:32:33 <supki> depends on how standard is lens for you
03:33:35 <shachaf> Jaxan: lens has (<&>)
03:33:39 <shachaf> base has nothing.
03:49:54 <Jaxan> shachaf: thanks, but I decided to use <$> anyway :)
03:50:03 <Jaxan> because thats consistent with teh other things
04:00:02 <Igloo> Am I missing something, or are fundeps "a -> s, a t -> s" equivalent to just "a -> s"?
04:00:38 <elliott> sounds riht
04:04:09 <shachaf> Hmm, I wonder whether something got mixed up while swapping letters.
04:04:35 <shachaf> There are a lot of classes in lens like class Field1 s t a b | s -> a, t -> b, s b -> t, t a -> s where
04:58:41 <kniren> Hi everyone, I have a little problem with lazy evaluation. I want to read a list of newline separated words from a file and process it. The current implementation is through hGetContents, the problem is, if I print the function that handles the processing, it works as expected, but it won't evaluate without it. Any suggestions?
04:59:14 <shachaf> hGetContents does lazy I/O and puts a handle in a "semi-closed" state.
04:59:21 <smithw> Hi. I'm trying to emulate dimensional constraints in haskell, and I figured I'd need something like "fixed-size lists" where the size belongs to the type, but where I can generalize the type, i.e., something like vector :: RealVector n, where n would be a number and vector would "expand" to something like (Real, ..., Real) repeated n times. is this at all possible in haskell?
04:59:29 <shachaf> Read more about lazy I/O and semi-closed handles to understand wht's going on. You should understand what's going on.
05:00:03 <kniren> shachaf, thx i will search for that.
05:00:03 <shachaf> The short answer is that you shouldn't hClose a handle after you hGetContents it. It'll be closed automatically when it's been fully read.
05:01:46 <kniren> shachaf, nice! that worked. Now I will do my homework to understand the implications. Thx a lot
05:02:01 <byorgey> smithw: have you seen  http://hackage.haskell.org/package/dimensional  ?
05:02:24 <smithw> byorgey, I had not, thanks, I'll look into it
05:04:47 <smithw> byorgey, it's not exactly what I was looking for but reading the docs gave me an idea of how to proceed. thanks a lot!
05:11:48 <hseg> Is there any way to write the type (a+b)c without distributing the addition over multiplication?
05:12:35 <hseg> i.e. I could write data T = A a c | B b c, but I'd like something more like data T = (A a | B b) c
05:12:44 <alexander__b> when doing e.g. "vplus (Vector 1 2 3) $ (vectMult (Vector 4 5 6) 10)" -- how would I go about doing the vectMult *first*?
05:13:03 <alexander__b> i.e. vplus [the result of the mult] (Vector 1 2 3)
05:13:25 <hseg> And using Either would force me to use Either's constructors, which would require me to write a path in a binary tree. Not fun.
05:13:59 <elliott> hseg: data T' = A a | B b; data T = T T' c?
05:14:17 <monoidal> hseg: you can write data T = A { x :: a, z :: c} | B { y :: b, z :: c} which gives you "z" to access c in both cases
05:14:24 <elliott> alexander__b: vplus (vectMult (Vector 4 5 6) 10) (Vector 1 2 3)
05:14:35 <alexander__b> elliott: oh. durr.
05:14:38 <elliott> also, note that that $ is redundant
05:14:51 <alexander__b> elliott: yes. that's what I realised. thanks.
05:15:03 <elliott> :)
05:15:10 <hseg> I like elliott's answer, but is there an equivalent to where for data declarations?
05:15:26 <hseg> i.e. data Foo = ... where Bar = A | B
05:16:10 <elliott> no, sorry
05:16:23 <hseg> Pity.
05:16:48 <monoidal> note it's essentially equivalent to type T' = Either a b, but you have more meaningful constructors
05:17:38 <monoidal> same with type T = (T', c)
05:17:39 <hseg> Right. They're both trivially isomorphic, but seeing as those constructors will be in my code, I'd rather they had some semantic meaning.
05:19:14 <hseg> Anyway, the guy whose laptop I'm using wants it back. Thanks, guys!
05:55:15 * hackagebot fixed-vector 0.4.2.0 - Generic vectors with statically known size.  http://hackage.haskell.org/package/fixed-vector-0.4.2.0 (AlexeyKhudyakov)
06:08:02 <bfrn> hi everyone, first time I use a chat client, it's a strange experience
06:08:19 * Botje waves
06:08:30 <typoclass> bfrn: hello, welcome. this channel is about the haskell programming language
06:09:00 <bfrn> I have a question: what packge do I use for regex with Data.Text?
06:11:44 <bfrn> rephrase: i am looking for a package that gives me regular expression matching on values of type Data.Text.Text
06:12:30 <bfrn> preferably with the ability to return a list of sub-matches (also as Data.Text)
06:13:18 <bfrn> @typoclass: I know that's why I am here ;-)
06:13:18 <lambdabot> Unknown command, try @list
06:13:28 <quicksilver> possibly http://hackage.haskell.org/package/text-icu-0.6.3.2
06:15:23 <bfrn> thanks, quicksilver, i am looking at it now, seems this is a binding to a C library?
06:15:32 <typoclass> bfrn: ok sure. have you considered one of the parsec variants? in haskell, regexes are not used as often as in other languages
06:17:48 <b__> how unreadable is `f g . ((<$> xs) . h . k =<<) . p <$> q' ?
06:18:21 <bfrn> typoclass: i have often used parsec for 'real' parsers but i was looking for something a bit more light-weight
06:18:43 <b__> original function names have been substituted for single char names to protect the guilty
06:19:00 <typoclass> b__: pretty unreadable :-/
06:19:05 <bfrn> btw, isn't Data.Text recommended for (longer) text? why then do the regex-* packages not support it?
06:19:12 <quicksilver> I don't really think regular expressions are lightweight.
06:19:29 <quicksilver> regular expressions are for then the thing you're matching/replacing isn't know at compile time
06:19:37 <b__> typoclass: was afraid that might be the case =D
06:19:55 <quicksilver> e.g. supplied by the user interactively (you're writing a text editor) or in the configuration file (you're writing a proxy rewrite/forwarder)
06:20:26 <quicksilver> regexp have merit as a minilanguage which your users can speak without expecting them to learn haskell (or other source language)
06:21:56 <bfrn> with light-weight i mean syntactically; think perl regexes
06:23:20 <typoclass> what i'd like is something very simple that consists of Prelude.lines, Prelude.words, a split function, and a few others. you could use it for stuff like parsing "value: something"
06:24:09 <typoclass> ... not sure if that even makes sense. it *almost* exists already
06:25:51 <shergill> so whatever happened to liskell and lisk?
06:28:16 <dmwit> typoclass: Data.List.Split? =)
06:36:50 <bfrn> bye for now
06:49:56 <shachaf> Igloo: Hooray!
06:54:26 <Ankhers> Is there a scenario I should be using >>= instead of do syntax? Or is it just a preference thing?
06:55:04 <shachaf> Yes.
06:56:51 <Squid_Tamer> Ankhers: do and >>= are different things, aren't they? I'm new to haskell, but I remember that do chains expressions with >> instead of >>=.
06:57:13 <elliott> Squid_Tamer: no
06:57:16 <elliott> do uses >>= as well as >>
06:57:33 <Squid_Tamer> elliott: Oh, didn't know that, thanks.
06:57:41 <elliott> (m >> n is just m >>= \_ -> n, anyway)
06:57:48 <typoclass> Ankhers: i think it's largely preference. for each piece of code, use whatever is more readable
06:59:03 <Ankhers> Awesome, thanks everyone.
07:00:10 <shachaf> fun fact: a>>b>>c is not the same as do{a;b;c}
07:02:30 <typoclass> > "a>>b>>c" == "do{a;b;c}"
07:02:34 <lambdabot>   False
07:04:51 <int-e> shachaf: a>>(b>>c) would be?
07:05:07 <shachaf> Yes.
07:07:20 <ocharles> isn't bind assossciative?
07:07:55 <shachaf> Yes, if you obey the monad laws.
07:08:04 <ocharles> oh, you're talking about the cases where people violate monad laws
07:08:19 <shachaf> Even if you obey them, (a ++ b) ++ c can be different from a ++ (b ++ c)
07:08:57 <ocharles> why's that? isn't it that (a * b) * c = a * (b * c) exactly what assossciativity is all about?
07:10:07 <shachaf> Yes. But they can be operationally different.
07:10:14 <shachaf> That counts for something.
07:10:51 <sproingie> assuming they're pure the observable effect should be identical
07:11:11 <mike4_> hi what programs can I make with haskell?
07:11:21 <Kinnison> Anything you can think of, within reason
07:11:21 <shachaf> Not if you have to wait for them to finish evaluating.
07:11:28 <SrPx> Hey guys, could you provide an example of an important algorithm that is either much smaller in Haskell *and* faster than the C++ version? Maybe something parallel (as Haskell is only ~3x slower than C, I guess it outperforms single-core C++ in anything parallel)
07:11:43 <mike4_> within reason?
07:12:03 <mike4_> Can I make a 3d-game with haskell?
07:12:05 <osfameron> @faq can Haskell create unreasonable programs?
07:12:05 <lambdabot> The answer is: Yes! Haskell can do that.
07:12:05 <SrPx> QuickSort for example, is 2 lines long in haskell, 90 lines long in C++. How hard it would be to parallelize the qsort?
07:12:13 <Kinnison> mike4_: yes, there's a quake clone to prove that
07:12:15 <tdammers> mike4_: sure.
07:12:34 <sproingie> never could get frag to compile
07:12:41 * Kinnison did, once
07:12:49 <ocharles> mike4_: lambdacube is some interesting research on 3d programming in Haskell
07:12:53 <tdammers> one good reason *not* to use haskell for a project would be when you need full control over memory allocation
07:13:03 <tdammers> e.g., realtime-critical code
07:13:16 <ocharles> http://lambdacube3d.wordpress.com/
07:13:18 <sproingie> SrPx: the haskell quicksort is a toy that really doesn't respect the runtime properties that have people using quicksort in the first place
07:13:34 <sproingie> it's just a demonstration of how convenient declarative syntax is, is all
07:13:36 <SrPx> mike4_: yes, you can. Yes, much more than you can in probably any other language. The only thing stopping it to be easy is that haskell isn't widely adopted by gamedev for historical reasons, so there isnt a huge 3d gaming library with decades of tuning made for it. That's all. Nothing to do with the language.
07:14:02 <osfameron> considering that node.js is advertised for "realtime" purposes, surely haskell would be no worse for it than that...
07:14:04 <sproingie> the haskell implementation of "true quicksort" ... looks a lot like C.
07:14:08 <CaptainLex> Oh goodness Haskellers :P
07:14:16 <CaptainLex> This room is just as enormous as I feared!
07:14:16 <sproingie> osfameron: haskell web frameworks run circles around node
07:14:26 <FireFly> CaptainLex: is that a problem? :P
07:14:28 <osfameron> sproingie: I can imagine
07:14:38 <CaptainLex> FireFly: depends on your purposes!
07:14:57 <SrPx> ocharles: hmm I'll read, but is that what I'm asking? I'm asking for a small snippet of something useful (like quicksort) that actually outperforms the C++ couterpart..
07:15:39 <CaptainLex> Is anyone in here, awake, and paying attention familiar with my GSoC proposal, as shown here? http://www.google-melange.com/gsoc/proposal/review/google/gsoc2013/captainlexington/1
07:15:43 <Chousuke> tdammers: are you sure about that? http://www.haskell.org/pipermail/haskell-cafe/2010-April/075647.html this seems like they're using Haskell successfully in an embedded environment
07:15:47 <mike4_> I see SrPx.
07:15:51 <mike4_> makes sense.
07:15:52 <typoclass> sproingie: "true quicksort"?
07:16:11 <mike4_> You could say C++ is running a monopoly of sorts.
07:16:21 * sproingie *snrk*
07:16:29 <FireFly> typoclass: I guess in-place
07:16:44 <sproingie> typoclass: in the sense of being in-place and choosing something other than always the first element as pivot
07:17:12 <sproingie> quicksort sucks for partial orders tho, it's not stable
07:20:19 <CaptainLex> Speaking broadly of the Summer of Code, my instinct was that there'd be lots and lots of people here
07:20:22 <CaptainLex> is that a true thing?
07:20:37 <typoclass> i understand it's normal to have several variants of an algorithm, but how is an in-place quicksort a "more true" variant?
07:20:54 * typoclass goes look up what guix is ...
07:21:19 <sproingie> typoclass: in that the original implementation was in-place and that's the main reason it still gets used today
07:21:26 <typoclass> CaptainLex: depends on whether america is awake and germany has a public holiday :-)
07:21:53 <CaptainLex> typoclass: I mean there'd be a lot of people applying for GSoC, "here" referring to the Haskell community at largew
07:22:18 <SrPx> hmm so guys, nobody ?
07:22:20 <CaptainLex> That is, that Summer of Code would have had a flood of applicants, all louder and more experienced in Haskell than I
07:22:51 <ryantanjunming> whats a spark in parallel programming?
07:22:52 <sproingie> usually some variant of quicksort these days like dual-pivot
07:22:58 <SrPx> I'm positive this can be done, a small snippet in Haskell that beats the thousandth lines long C++ version in performance, for running in parallel.
07:23:15 <SrPx> Of anything useful
07:23:21 <Chousuke> SrPx: check out http://www.eecs.harvard.edu/~mainland/publications/mainland13haskellbeatsc.pdf
07:23:33 <sproingie> technically the unsafe language can always win because you can write any instruction sequence you want in it
07:23:39 <typoclass> sproingie: ok, "being in-place is the only reason to still use it" is a good reason
07:23:50 <sproingie> but there's crazy hand-optimized C and there's real world C
07:24:59 <quicksilver> sproingie: you can't write anything like any instruction sequence you want in C
07:25:08 <quicksilver> (unless you're counting inline assembly as C)
07:25:19 <sproingie> or poking arbitrary memory locations
07:25:28 <sproingie> which does assume an executable stack i suppose
07:25:29 <quicksilver> one of the reasons C is such a terrible language is it's very badly matched to modern processors
07:25:37 <quicksilver> and gives you no control at all over the instructions produced.
07:25:53 <quicksilver> compensating for that is many hundreds of man-years experience in writing C compilers
07:25:54 <typoclass> SrPx: i agree, it'd be useful to have short haskell snippets that show off parallelism
07:26:00 <quicksilver> some of them the very same people who designed the processors.
07:26:24 <typoclass> SrPx: you could ask on stack overflow, though i don't know if that's an acceptable question by their standards ...
07:27:40 <typoclass> quicksilver: not sure if c is badly matched to processors, but i thought cpus for decades have been designed with c compilers in mind ...?
07:27:44 <Chousuke> sproingie: couldn't you technically write Haskell in a way that forces GHC to output a particular instruction sequence?
07:27:46 <tew88> I'm working through LYAH.  I'm on chapter 9 and am playing with System.Random.  My program's behaviour differs from that described in the book: http://hpaste.org/86991 -- the behaviour I observed (the second segment) wouldn't surprise me if explained in terms of lazy IO, but that it differs from the book is a slight cause for concern.  Any insight?
07:28:18 <Chousuke> Anything is possible, the question always is whether it's worth the trouble.
07:28:31 <sproingie> Chousuke: yah, haskell can be an unsafe language if you let it.  there just tends to be a clearer line.
07:28:46 <parcs> tew88: post the code
07:29:17 <Chousuke> sproingie: It's very interesting when people find new optimisations for high-level code though.
07:29:26 <Chousuke> like in that paper I linked
07:29:33 <typoclass> CaptainLex: so, guix is a new package manager, and it's written in a pure variant of scheme ...?
07:29:51 <tew88> parcs: Sure: http://hpaste.org/86993
07:29:51 <sproingie> programming language comparisons have to stick to idiomatic code written by people with N years experience
07:29:51 <Chousuke> very high level code, but still competitive with hand-optimized C/C++
07:29:54 <CaptainLex> typoclass: Did I actually link to the wrong proposal?
07:29:59 <CaptainLex> typoclass: I am a bad person
07:30:27 <typoclass> CaptainLex: i dunno if it's wrong :-) it says "package gnome for guix"
07:30:29 <CaptainLex> I mean this one, my Haskell one:
07:30:31 <CaptainLex> http://www.google-melange.com/gsoc/proposal/review/google/gsoc2013/captainlexington/1001
07:30:50 <sproingie> C is such that any old slapdash effort will tend to be pretty fast.  segfault a lot, but pretty quickly anyway
07:31:06 <sproingie> higher level languages take a little more effort
07:31:19 <quicksilver> typoclass: C has no control over arithmetic flags, which have been in every processor since 1980
07:31:19 <typoclass> CaptainLex: ah! suddenly, my question of what the proposal has to do with haskell is evaporating
07:31:30 <Chousuke> with C/C++ it is possible to write very fast code, but packaging that in a library that is fast, general, and easy to use is difficult.
07:31:46 <typoclass> quicksilver: "overflow occurred" and stuff like that?
07:31:46 <quicksilver> typoclass: let alone cache coherency or compare-and-swap or branch prediction or register allocation or vectorised maths or...
07:32:11 <quicksilver> now to be fair you don't want to worry about those things in 'normal' programming
07:32:18 <typoclass> quicksilver: hm ok. fair enough. (does haskell have all that?)
07:32:20 <quicksilver> but they are all the reasons I don't consider C to be low-level.
07:32:27 <tdammers> Chousuke: interesting... but not the kind of realtime constraints I am concerned about
07:32:30 <quicksilver> C's a high-level language too.
07:32:34 <fryguybob> @karma C/C
07:32:35 <lambdabot> C/C has a karma of 456
07:32:37 <quicksilver> (just a rather simple one)
07:33:04 <sproingie> @karma Notepad
07:33:04 <lambdabot> Notepad has a karma of 42
07:33:15 <tdammers> I tried using haskell for a realtime audio project, with latencies in the 1 ms range
07:33:18 <tdammers> didn't quite work out
07:33:37 <mike4_> so Haskell will be the new C?
07:33:51 <sproingie> tdammers: i bet it's doable, just tricky
07:34:13 <Chousuke> tdammers: I got the impression they basically used Haskell to generate C and it turned out to be worth the trouble.
07:34:13 <sproingie> but then "possible"
07:34:16 <sproingie> arg
07:34:22 <t7> tdammers, you use C in the end?
07:34:23 <typoclass> CaptainLex: ah, so it's developing a set of exercises (and solutions) for lyah? that sounds very useful. that question seems to come up in here regularly. and i keep thinking we need to improve and polish the "99 problems". they're not optimal
07:34:29 <typoclass> @google 99 problems haskell
07:34:30 <sproingie> but then "easy" does dominate "possible"
07:34:31 <tdammers> sproingie: I don't really see how... the problem, I figured, is that you can't control when and where the runtime allocates and cleans up
07:34:32 <tromp> if you consider https://github.com/tromp/AIT/blob/master/Uni2.hs s a small snippet of code, that is something you cannot match in performance with  C++
07:34:35 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
07:34:35 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
07:34:41 <tdammers> t7: I put the project on ice for now
07:34:46 <CaptainLex> typoclass: I actually have some experience with the 99 problems
07:34:48 <quicksilver> tdammers: you can't, and 1us latency would be a problem.
07:34:55 <tdammers> quicksilver: exactly
07:34:57 <quicksilver> tdammers: 1ms ought to be achievable though
07:35:09 <sproingie> CaptainLex: but a b*tch aint one?
07:35:14 <CaptainLex> In fact, I'm going to be working on a Lisp In Small Projects project related to the 99 problems
07:35:35 <tdammers> quicksilver: I couldn't get my jack client to perform without xruns for even a moderately complex sound generator
07:35:46 <CaptainLex> (Basically, a website in Clojure that acts a repository for solutions to the problems in many languages)
07:36:05 <quicksilver> tdammers: well it does depend how much you're trying to do in that 1ms :)
07:36:27 <quicksilver> tdammers: certainly, challenges abound and expert tweaking and knowledge may be required.
07:36:33 <typoclass> CaptainLex: so it'd be similar to rosetta code
07:36:46 <Chousuke> hmm
07:37:09 <CaptainLex> typoclass: Indeed, but geared specifically to functional languages
07:37:59 <CaptainLex> typoclass: And there'd be more useful metadata than a wiki would have, so problems would be sortable by difficulty, which languages they had solutions for, etc
07:38:11 <CaptainLex> Instead of with community-maintained categories
07:38:21 <klrr> what module should i use if i want to send a http request to a server, then parse the corrisponding json file?
07:38:21 <typoclass> CaptainLex: yeah. so as far as the haskell side is concerned, great idea. we could use that
07:38:23 <Chousuke> I suppose if you really wanted to you could write haskell that had compile-time known memory usage, but it would look quite different from normal Haskell
07:38:56 <CaptainLex> But that's a different thing entirely; I'm not even going to think two lines of it until June, when the content opens for registration
07:39:01 <typoclass> klrr: regarding the http request, you could look at http-conduit
07:39:14 <CaptainLex> Right now, I'm just wondering if my throw-away Haskell proposal actually has a chance at acceptance
07:39:36 <klrr> typoclass: okey, would curl module work though?
07:40:25 <mike4_> why is it important how you do something and not the end product itself?
07:40:30 <typoclass> klrr: possibly, but you might run into problems. it's a binding to a c library that has some quirks, iirc
07:40:41 <Chousuke> Anyone know of any research into writing Haskell programs that don't depend on GC?
07:40:59 <klrr> typoclass: okey, will use that one you suggested then
07:42:29 <typoclass> CaptainLex: i'm not familiar with the gsoc process, but the idea itself is sound, in my opinion. it's useful and would have a lot of impact
07:43:01 <CaptainLex> typoclass: Well thank you! Do you know where I might go to find people involved the GSoC situation for Haskell?
07:43:13 <typoclass> luite: ping?
07:43:22 <CaptainLex> Like I said, I assumed Haskell would be an extremely popular target ands that I would not be competitive, so I didn't explore it much
07:46:25 <parcs> tew88: on line 13 you're showing randNumber instead of number
07:46:34 <parcs> tew88: is that what the book says?
07:46:43 <mike4_> can someone explain to me why focusing on the language, how the program is written, how elegant it looks, is more important than how the end program works?
07:47:24 <CaptainLex> mike4: From a pragmatic standpoint, it's important when you return to the project after a long time
07:47:25 <parcs> tew88: aha, looks like the book has a typo. nice catch
07:47:30 <CaptainLex> Or when someone else looks at your code
07:47:30 <sproingie> i wouldn't say that, but a program you can't read is one you can't write
07:47:38 <geekosaur> mike4_, because you have to be able to figure out how it works and maintain it when you come back in 6 months, much less a couple years
07:47:41 <sproingie> unless of course it's APL ;)
07:47:45 <tew88> parcs: Yep, I've just copied it directly to test the behaviour
07:47:51 <tew88> parcs: Ahha.  What've you found?
07:48:00 <CaptainLex> Some people, though, like me, just prefer it for the aesthetics
07:48:01 <elliott> mike4_: strawman? who said that?
07:48:04 <geekosaur> also see Kernighan re debugging
07:48:33 <CaptainLex> mike4_: And many people will you that learning and understanding functional languages will make your imperative code better as a result
07:48:46 <sproingie> it's about expressiveness.  what can you express in ten lines, or ten minutes of your time?
07:49:06 <CaptainLex> mike4_: It's also about how big the tradeoff between elegance and performance really is
07:49:18 <parcs> tew88: oh wait -- the problem you're referring to is that the question gets printed AFTER the answer, right?
07:49:21 <Chousuke> one benefit to functional languages is also that things tend to be local
07:49:30 <tew88> parcs: Yes, that's it
07:49:33 <Philippa> CaptainLex: so as a past mentor, I'd be wary of the achievability of a set for the entire book in that timespan but otherwise I'd happily +1 the proposal as a whole and be looking for whether there's a mentor available with suitable teaching experience to help
07:49:43 <Chousuke> ie. often the code you are looking at is the only thing that matters
07:49:46 <Philippa> (I'm not participating in this year's process currently, though)
07:50:01 <Chousuke> whereas in an imperative language you have to understand how it affects the rest of the codebase
07:50:04 <mike4_> hehe
07:50:19 <tdammers> quicksilver: I just figured writing the actual signal processing in C and then driving the engine with a more comfortable REPL written in Haskell is probably the best way to go
07:50:29 <mike4_> that's the most interesting explination of Haskell I've seen.
07:50:39 <parcs> tew88: ok, in order to fix that you have to flush the text output buffer after the call to 'putStr'. to do so you 'import System.IO (stdout, hFlush)' and then call 'hFlush stdout' after 'putStr'
07:50:54 <Philippa> sproingie: so that's why haskell's ability (or lack thereof) to talk about 'extension' annoys me? I love notions like "context free grammar = regex + letrec"
07:50:59 <Chousuke> of course if you write all your code in IO then you'll have the same problems as with any imperative language, but that's why it's not a good idea to write everything in IO :P
07:51:37 <CaptainLex> Philippa: Interesting; I suppose I did not anticipate that the book would end up that large (I'm currently about halfway through or something); nonetheless, I'd appreciate any guidance you could give me on the politics of Haskell GSoC
07:52:06 <tew88> parcs: Right, that solution makes sense, thanks.  I can't say I'm happy with how that's been overlooked in the book though!
07:52:21 <typoclass> mike4_: obviously it's no good if a programmer (or craftsman) polishes his tools all day, never actually producing anything. but the other extreme is equally bad, maybe even worse. i surely don't want to work with someone who pays no attention at all to intellectual tools and software tools. i find it hard to believe that this sort of shoddy botchy person would produce any lasting product
07:52:27 <Philippa> hrmm. So certainly when I was involved: convincing one mentor that an idea is good tends to lead to them explaining to other mentors why that's the case, so ideas with a 'niche' audience initially can get more priority than expected?
07:52:48 <typoclass> mike4_: so, try to find a sensible middle ground, is what i'm saying :-)
07:52:55 <Philippa> admittedly the first example that comes to mind for me there is Language.C and some of the potential mentors work for eg military contractors who have potential uses for such things
07:53:22 <mike4_> of course.
07:53:25 <Philippa> typoclass: someone who polishes /trivially reproducible/ tools is a tool-crafter, yeah
07:53:38 <hz> hello, im on debian-wheezy-rc2 and ive apt-installed haskell-platform to use "geordi" from Eelis
07:53:45 <Shaladdle> typoclass: is haskell a good middle ground? or SML?
07:53:53 <typoclass> Philippa: is there a special haskell-gsoc mailing list or something?
07:53:59 <parcs> tew88: indeed
07:54:09 <typoclass> typoclass: haskell is the bestest middlest ground of all :-)
07:54:21 <Philippa> typoclass: IIRC most of the talking I did at the time was either on an IRC channel somewhere or a chunk of the wiki. It's been half a decade though, haven't got a free t-shirt since '08
07:54:23 <hz> i run "cabal update" and then "cabal install" under geordi dir but network does not build
07:54:39 <Philippa> (I even got google's recruiters to stop spamming me :p)
07:54:47 <typoclass> Philippa: =D
07:55:04 <Shaladdle> typoclass: haha but what are the arguments for that? Monads are hard for people who aren't super mathematical, and not having for loops throws people used to imperative stuff (obviously this one is easier to get over)
07:55:05 <geekosaur> haskell platform should come with network?
07:55:09 <CaptainLex> Philippa: #haskell-gsoc exists!
07:55:24 <Philippa> CaptainLex: that's the bunny :-)
07:55:27 <geekosaur> hz, haskell-platform comes with network, why are you trying to reinstall it?
07:55:31 <Shaladdle> typoclass: of course that comment about monads I just made could be awfully ill-informed, since I'm still understanding monads myself
07:55:33 <quicksilver> tdammers: certainly not a bad way :)
07:55:50 <sproingie> nonsense.  i'm nothing even close to "super mathematical" and monads are a basic thing like loops and exceptions would be in other languages
07:55:53 <quicksilver> tdammers: it's an interesting technical question to ask if we can get the haskell fast enough, but that might not be the quickest way to your working program.
07:56:00 <hz> i installed it by apt-get
07:56:02 <Philippa> Shaladdle: so I probably meet most people's idea of "super-mathematical" despite most of my 'proper' mathematical background being prior to university in my country? But within that, I don't think the required skill is being mathematical, it's something else
07:56:09 <hz> not reinstalled
07:56:12 <geekosaur> (note: do not, ever, try to upgrade a platform package yourself. this is very much an experts only thing because of the way ghc handles cross-module deps)
07:56:24 <typoclass> Shaladdle: well, i think the jump from for loops to foreach loops (as in perl or java) is about as wide as the jump to the map function. in other words, not a difficult jump
07:56:25 <geekosaur> [01 10:54] <hz> i run "cabal update" and then "cabal install" under geordi dir but network does not build
07:56:29 <tdammers> quicksilver: it's not so much that haskell isn't fast enough, I think - the problem is more that memory allocation/deallocation happens at unpredictable times
07:56:36 <geekosaur> why are you trying to build network then?
07:56:38 <mike4_> for me it's all about end fuctionality, I wouldn't want sacrifice support and end performance, for elegant code and correctness though.... it seems hmm like programming for programming.
07:56:52 <Philippa> being willing to accept and use abstractions even if you don't have a "concrete" intuition for them is a big step and monads both stretch that and require using more of Haskell's abstraction tools on a regular basis than most tasks people are exposed to before then
07:56:56 <shachaf> @where+ gsoc #haskell-gsoc | http://www.google-melange.com/gsoc/org/google/gsoc2013/haskell
07:56:56 <lambdabot> Okay.
07:57:27 <tdammers> so even though my code can easily deliver on average, occasionally GC kicks in and blows a frame
07:57:31 <mike4_> But o well, the programmer isn't a machine and wants to be an artist too!
07:57:34 <hz> "cabal install" builds only haskell libs?
07:57:39 <yrlnry> I have a type class, "Applicative" and I want to say that any constructor that is an instance of Monad is also an instance of Applicative.  I thought I could do this by writing "instance Monad f => Applicative f where..." but ghc says "Illegal instance declaration for `Applicative f'".
07:57:42 <tdammers> at least that's what I figured is what happens
07:58:09 <quicksilver> tdammers: well allocation is very fast indeed.
07:58:12 <FireFly> mike4_: developer time/cost is a factor too
07:58:14 <quicksilver> tdammers: GC can be tuned.
07:58:15 <yrlnry> It also suggests enabling -XFlexibleInstances, but I'm not sure whether I should do that or if I just did something trivially silly like omitting parentheses.
07:58:16 <Shaladdle> typoclass, Phillipa: maybe that's true, going to map for everything was a little weird for me, I guess the biggest thing is that you can't modify state, I think of implementing something in haskell and then I get stuck on that
07:58:26 <quicksilver> tdammers: you can change the parameters and you can ask it to happen at a good time.
07:58:33 <Philippa> Shaladdle: yeah, better to work functionally for a while
07:58:35 <Philippa> right, AFK a bit
07:58:37 <geekosaur> hz, I do not understand what that question has to do with it
07:58:47 <mike4_> I do finance programming and I don't see why I should change my language, I don't see how the finance output will become better displayed.
07:58:57 <tdammers> well, ideally I'd want to move allocations and deallocations out of the jackd callback entirely
07:59:00 <Shaladdle> typoclass: even just not being able to print what's going on at each step of my program is helpful, and I'm not sure how to do that in Haskell without making everything :: IO ()
07:59:08 <Shaladdle> typoclass: or whatever the right type is lol
07:59:10 <geekosaur> I am saying that installing anything yourself which is already installed by a package manager or as part of the compiler is extremely risky, don't do it.
07:59:15 <SrPx> Well, I've asked on Stack Overflow. My question has been closed. Then upvoted. Then reopened. Stil no answers
07:59:18 <tdammers> it's fairly straightforward in C, but in Haskell I wouldn't know where to begin
07:59:20 <parcs> tdammers: the best way to avoid GC pauses is to avoid generating garbage :P
07:59:20 <shachaf> yrlnry: The trouble is that then you can't declare any other (non-overlapping) instance.
07:59:33 <typoclass> SrPx: give it a few days :-)
07:59:58 <hz> geekosaur: i thought cabal install its for geordi too so required
08:00:00 <yrlnry> shachaf:  I don't understand.  Can you elaborate a little bit?
08:00:23 <elliott> yrlnry: the prerequisite constraints of an instance aren't checked when doing resolution
08:00:25 <shachaf> yrlnry: OK, there are a few different troubles.
08:00:29 <hz> geekosaur: but from what are you saying i understand cabal install its not geordi thing at all
08:00:33 <geekosaur> hz, again I don;t quite see the connection here
08:00:35 <typoclass> mike4_: figuratively speaking, i don't have too much against someone who drives a nail in the wall by kicking it with his shoes. but it becomes sad if he keeps doing that for years or decades, never investing an afternoon for checking out an actual hammer
08:00:36 <Chousuke> Shaladdle: I think monads are only hard to most people because it abstracts something that most people are not used to be able to abstract
08:00:39 <shachaf> The biggest is what elliott said.
08:00:41 <elliott> yrlnry: the compiler just sees an instance "Applicative f" for all f
08:00:44 <geekosaur> you were talking abotu network, now you are talking about geordi
08:00:58 <yrlnry> Aha.
08:01:03 <geekosaur> if geordi is trying to reinstall network then something else is wrong somewhere
08:01:03 <elliott> yrlnry: and then once it chooses that instance, it tries to satisfy "Monad f"; it's not like prolog
08:01:15 <shachaf> It's like some parts of Prolog. :-)
08:01:25 <elliott> so, your instance overlaps with every other possible Applicative instance, which is a problem :)
08:01:36 <luite> typoclass: pong
08:01:37 <geekosaur> try: cabal install geordi --constraint='network installed'
08:01:38 <yrlnry> I thought there was a way to say that any constructor satisfying Monad f would also satisfy Applicative f.  Is that not the case?
08:02:00 <Shaladdle> Chousuke: Yeah, I think the concept is foreign, I'm just wondering if there's a way to have the best of both worlds, where we have something that has the advantages of a functional languages, but isn't *such* a crazy departure from what most programmers know
08:02:01 <typoclass> luite: ohai. you involved in this year's gsoc? do they have a mailing list etc?
08:02:02 <shachaf> yrlnry: It's not really the case, at least not without evil things. :-(
08:02:08 <geekosaur> (and hope someone fixes that particular cabal annoyance soon)
08:02:23 <yrlnry> Very good, thanks.
08:02:25 <hz> geekosaur: im not used to haskell, installed it to try geordi, and i was following (maybe wrongly) the install predure described on geordi pages
08:02:27 <elliott> yrlnry: if it was that easy, nobody would complain about the missing superclass :)
08:02:27 <shachaf> yrlnry: You can make overlapping instances but it won't work as well as you hope.
08:02:39 * geekosaur just pegs all the platform packages as constraints so abal won't try to replace them
08:02:44 <typoclass> luite: CaptainLex was proposing to make a set of exercises that can accompany lyah. everyone finds it a good idea
08:02:53 <elliott> yrlnry: at least "instance Applicative X where pure = return; (<*>) = ap" is just one line of boilerplate for any concrete monad X, though...
08:03:07 <luite> typoclass: gsoc proposal, right?
08:03:12 <Chousuke> Shaladdle: honestly I think it's only the category-theoretical terminology that scares people
08:03:13 <Shaladdle> typoclass: yayayaya
08:03:19 <yrlnry> True. That's good enough for me today.  Thanks to both of you for your help.
08:03:23 * geekosaur looks; has no idea what geordi is
08:03:33 <geekosaur> ...oh, that, right
08:03:44 <Shaladdle> Chousuke: you mean that if you made the terms less scary sounding people wouldn't mind? I would probably agree with that, although I can't really comment until I understand them well :P
08:03:49 <luite> typoclass: i've registered as a mentor
08:04:06 <sproingie> the CT terms may be scary but i suspect any invented terminology would be just as intimidating
08:04:30 <typoclass> luite: this is the link http://www.google-melange.com/gsoc/proposal/review/google/gsoc2013/captainlexington/1001
08:04:50 <Shaladdle> sproingie: yeah I guess if there's no analog in the more popular languages, then it's hard to choose the right term
08:05:09 <luite> typoclass: yeah i've seen it
08:05:57 <sproingie> i think the problem is many introductions start with the terms, which is bully for people who already know it, but not too useful for people learning it
08:06:18 <sproingie> i dont think thats so of haskell in general tho, just some bits like, oh, arrows
08:06:19 <luite> typoclass: the problem is that i'm not sure what it will bring us, there's SoH already, and this would just be some tutorials written for that?
08:06:28 <Shaladdle> sproingie: but don't you need to know that stuff in order to write real programs?
08:06:53 <geekosaur> hz: so, I just see it requiring network, it should not be installing network again
08:06:55 <sproingie> Shaladdle: sure, but most people learn by inferring the abstract from the concrete
08:07:01 <sproingie> you have to show first, then tell
08:07:14 <luite> typoclass: perhaps it'd be a native program instead, but still i'm not sure
08:07:18 <Shaladdle> sproingie: yeah I agree completel
08:07:34 <typoclass> luite: let me google what soh is
08:07:34 <geekosaur> hz: nopaste (a) output of 'ghc-pkg list' (b) actual full output from trying to build geordi
08:07:41 <luite> typoclass: fpcomplete school of haskell
08:07:46 <geekosaur> @paste
08:07:46 <lambdabot> Haskell pastebin: http://hpaste.org/
08:08:29 <mike4_> typoclass: you meant you don't have a problem with someone driving the nail in the wood frame with his hammer, but it becomes sad when he doesn't research the physics and inertia needed to drive the nail into the wood, how much energy is lost when the hammer bounces back, the impact to the muscles, angles, intervals, and so on until the carpenter arrives at a equation to drive nails,suchas: N=L(F)
08:09:11 <mike4_> because I think we already have the hammer.
08:10:00 <Cale> sproingie: Though, the arrow typeclass isn't directly based on CT -- it can be described in various ways using some categorical language, but rarely is, especially in introductory stuff.
08:10:01 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:11:37 <typoclass> mike4_: yeah ... i didn't really mean that. i meant learning about better tools that are available. giving some thought to the existing tools, and to how they could be improved. physical understanding in terms of energy and inertia and stuff may or may not be helpful for that
08:12:54 <mike4_> i see.
08:13:36 <luite> typoclass: i think it would still be too much of a documentation project given the available existing tools, not sure if that's outside the scope of gsoc
08:13:41 <luite> typoclass: #haskell-gsoc btw
08:13:56 <Shaladdle> typoclass: but you understand that's how it looks to some who try to learn fp, right?
08:14:05 <Cale> and indeed, it has been useful for that, we have nailguns now
08:14:31 <Shaladdle> Cale: right, but you can show me a nailgun in 2 seconds and I'll understand how useful it is
08:14:42 <Shaladdle> Cale: whereas fp takes more time to understand what's going on
08:15:19 <Shaladdle> Cale: and obviously it's not going to be as simple as hammering nails because programming/CS is not that simple, but it still seems like a lot of effort, and it's hard to quantifiably say that the result is better with fp
08:15:23 <Cale> Much of that is that a lot of the abstractions people get caught up in are only obvious if you've been doing the kinds of jobs that functional programmers have been doing in the way that they've been doing them.
08:15:46 <typoclass> Shaladdle: i agree that it's a weakness of haskell. there is a need for improving several haddock pages. a lot of jargon should be explained better, in my opinion
08:16:05 <Cale> If you'd used glue and mortise/tenon joints all your life, maybe nailguns would be a weird idea. :D
08:16:15 <Shaladdle> true true :)
08:17:47 <Shaladdle> it's still obvious that the two things are fastened within a few seconds though
08:17:48 <typoclass> Shaladdle: regarding monads, there is this tradition of presenting them as mystical and hard to understand. in my opinion that's quite unfortunate
08:17:57 <Shaladdle> people are just very instant gratification, which is annoying
08:17:58 <parcs> people sure love their carpentry analogies :)
08:18:04 <yrlnry> Do people usually use <*> for the applicative functor application operator?
08:18:09 <Shaladdle> but we can't just replace them with other people lol
08:18:33 <typoclass> yrlnry: it's at least common in the "f <$> x <*> y <*> z" idiom
08:18:47 <Shaladdle> typoclass: I am getting that idea too, is there some reason people do that? and don't just say what they are?
08:18:48 <Cale> parcs: :D
08:18:48 <typoclass> > ((==) <*> reverse) "radar" -- yrlnry: palindrome checker :-)
08:18:51 <lambdabot>   Could not find module `Numeric.AD.Types'
08:18:51 <lambdabot>  Use -v to see a list of the files...
08:19:04 <elliott> nice palindrome checker
08:19:18 <Shaladdle> typoclass: just need someone who is good at articulating what's going on
08:19:19 <typoclass> elliott: it is, isn't it
08:19:33 <shachaf> yrlnry: Well, it's the method in the type class. So you have to implement it.
08:19:35 <elliott> "Could not find module `Numeric.AD.Types'" is one of the lesser-known booleans
08:19:45 <typoclass> > 1
08:19:46 <lambdabot>   Could not find module `Numeric.AD.Types'
08:19:46 <lambdabot>  Use -v to see a list of the files...
08:19:48 <sproingie> elliott: along with FileNotFound
08:20:03 <shachaf> yrlnry: It's also convenient in the idiom-bracket sense that typoclass mentioned.
08:20:13 <shachaf> Pedagogically I prefer e.g. liftA2. :-)
08:20:14 <sproingie> i think the bot just had an anuerysm
08:20:22 <Shaladdle> poor lambdabot
08:20:22 <Cale> oh, dang
08:20:27 <Cale> I just upgraded lens
08:20:49 <edwardk> ooh new lens on lambdabot?
08:20:51 <Cale> er, edwardk wat do
08:20:51 <edwardk> :t only
08:20:52 <lambdabot> Not in scope: `only'
08:20:58 <Cale> > 1
08:20:59 <lambdabot>   Could not find module `Numeric.AD.Types'
08:20:59 <lambdabot>  Use -v to see a list of the files...
08:21:03 <Cale> ^^ what's going on?
08:21:07 <parcs> Shaladdle: i think philip wadler is great at teaching haskell. check out his recorded haskell lectures if that's what you're looking for
08:21:08 <Cale> Where's that module now?
08:21:15 <typoclass> edwardk: 'new' in the sense of it now doesn't do anything anymore :-)
08:21:16 <edwardk> you're on ad 3.4?
08:21:20 <Shaladdle> parcs: will do, thanks!
08:21:32 <shachaf> Cale: What version of ad do you have, if any?
08:21:38 <parcs> Shaladdle: incidentally he also pioneered the use of monads for performing IO
08:21:40 <edwardk> Cale: erm, is ad installed?
08:21:40 <Cale> 3.3.1.1
08:21:49 <edwardk> try upgrading to 3.4 i think
08:22:10 <edwardk> 3.4 has Numeric.AD.Types still
08:22:11 <Cale> ah, yeah, I have broken packages
08:22:17 <Cale> after cabal install lens
08:22:17 <edwardk> that'd do it
08:22:19 <Shaladdle> parcs: interesting
08:22:31 <yrlnry> shachaf, typoclass : thanks
08:22:33 <quicksilver> blame cabal. everyone else does.
08:22:36 <edwardk> lens wound up with some updated dependencies
08:22:54 <Cale> quicksilver: I blame society
08:23:04 <elliott> @quote blame.shac
08:23:05 <lambdabot> cmccann says: some people blame themselves, some people blame the language, but the people who really know what they're doing blame shachaf.
08:23:20 <Cale> ahahaha
08:23:58 <ajovanov93> hello
08:24:00 <ajovanov93> I wrote this
08:24:03 <ajovanov93> http://aleksandarjovanov.blogspot.com/2013/05/making-programming-languages-more.html
08:24:10 <ajovanov93> tell me what do you think :)
08:24:25 <sproingie> making-sluglines-more
08:25:42 <Cale> > 1
08:25:45 <lambdabot>   1
08:25:50 <Cale> :t only
08:25:52 <lambdabot> (Eq a, Applicative f, Choice p) => a -> p () (f ()) -> p a (f a)
08:25:55 <elliott> :t (#)
08:25:57 <sproingie> yay we have numbers again
08:25:58 <lambdabot> parse error on input `)'
08:26:00 <elliott> :t ( # )
08:26:02 <lambdabot> AReview s t a b -> b -> t
08:26:10 <elliott> huraĳ
08:26:16 <sproingie> > ((==) <*> reverse) "radar"
08:26:19 <lambdabot>   True
08:26:37 <sproingie> > ((==) <*> reverse) "satanoscillatemymetallicsonatas"
08:26:39 <lambdabot>   True
08:26:49 <simpson> ajovanov93: It's a shame that I can't read your blog without JavaScript.
08:27:03 <FreeFull> I need ideas for some program to write
08:27:12 <ajovanov93> simpson: That is because of the animated styles
08:27:15 <ajovanov93> I will turn them off
08:27:55 <Cale> Probably abs would translate to апс
08:28:01 <ajovanov93> better now?
08:28:22 <simpson> ajovanov93: Your idea is interesting but ultimately you would have a lot of trouble making this sort of system self-hosting.
08:29:04 <ajovanov93> simpson: I am aware of that, I haven't planed to work on that now, It's just an idea.
08:29:15 <ajovanov93> btw what do you think of extended type synonyms
08:30:05 <simpson> Dangerous and obfuscating.
08:30:22 <Cale> another tangential point (which I thought your article might be about before I saw that it was about translation) is that Boolean is frequently evil, and that instead of a boolean value, it's often more useful to use some kind of witness or evidence of whatever it was that's true.
08:30:48 <ajovanov93> simpson: Obfuscating probably, dangerous it depends on who is using them
08:31:04 <Cale> (though this gets done more frequently in dependently typed languages)
08:31:10 <nexx> dangerous it depends on who is using them <<< same for goto!?
08:31:31 <typoclass> ajovanov93: hi :-) i think in the line "options :: [Yes, Yes, Yes]" you mean "options = [Yes, Yes, Yes]"
08:31:50 <ajovanov93> typoclass: yes, will fix it :)
08:32:08 <Cale> Also, yn == True is the same thing as yn
08:32:48 <Cale> and then (\yn -> yn) is the same thing as id
08:33:00 <Cale> and all id is the same thing as and
08:33:04 <Cale> :)
08:33:39 <typoclass> @type and all id
08:33:39 <ajovanov93> I know that var == True is redundant :D
08:33:40 <lambdabot>     The function `and' is applied to two arguments,
08:33:40 <lambdabot>     but its type `[Bool] -> Bool' has only one
08:33:40 <lambdabot>     In the expression: and all id
08:33:51 <typoclass> Cale: no, doesn't seem to be the same
08:33:55 <typoclass> Cale: ;-) j/k
08:34:13 <Cale> heh
08:34:37 <Cale> if b then Yes else No  also is redundant :D
08:35:00 <hiptobecubic> It feels like you need a big stack of monads to do anything, but then everything is so ugly and hairy
08:35:05 <ajovanov93> Cale: Je sais, je sais :D
08:35:13 <ajovanov93> It's there to show a point
08:35:19 <Cale> yeah, I know :)
08:35:19 <ajovanov93> not be a perfect code
08:36:17 <Cale> hiptobecubic: You don't. In fact, I often avoid using monad transformers for as long as possible until I'm absolutely certain that they'll make my life better.
08:38:01 <Cale> I mean, if I'm implementing the bind for StateT in-place everywhere, then I'll break down and use StateT instead.
08:38:05 <ajovanov93> You can read, write and maybe something else at same time with them, don't neglect them :)
08:38:57 <ajovanov93> Got to go, duty calls. Comment on the blog post if you have something to add. Bye :)
08:39:41 <Cale> But ReaderT is a bit evil, especially. Some people are too quick to try to avoid simple parameter passing.
08:40:23 <edwardk> > diff sin pi
08:40:24 <Cale> If you end up having to lift everything, it's not really better than passing parameters, you've just shifted the syntactical weight around a bit.
08:40:28 <lambdabot>   mueval-core: Time limit exceeded
08:40:32 <edwardk> > diff sin pi
08:40:36 <lambdabot>   mueval-core: Time limit exceeded
08:40:39 <Cale> hmm
08:40:56 <Hafydd> > diff (const 0) 0
08:40:57 <Cale> > 1
08:40:59 <lambdabot>   0
08:40:59 <lambdabot>   can't find file: L.hs
08:41:02 <yrlnry>  is there a less ugly way to define 'ap' than  \f x -> f >>= \f -> x >>= \x -> return (f x)
08:41:03 <Cale> lol
08:41:07 <yrlnry> I feel like I'm missing something obvious.
08:41:17 <shachaf> yrlnry: Not in terms of (>>=)/return, no.
08:41:21 <Cale> > diff sin pi
08:41:23 <lambdabot>   -1.0
08:41:25 <Cale> lol
08:41:30 <edwardk> just slow today
08:41:31 <shachaf> yrlnry: Well, it would be less ugly not to shadow like that. :-)
08:41:35 <elliott> yrlnry: do { f <- mf; x <- mx; return (f x) } is less hideous, at least...
08:42:05 <shachaf> @src ap
08:42:06 <lambdabot> ap = liftM2 id
08:42:06 <edwardk> would doubling the mu-eval timeout help with lambdabot? it triggers a lot with false kills these days
08:42:08 <elliott> yrlnry: but of course it's ugly to express this kind of lifting with just the monad ops, or Applicative wouldn't be so popular :)
08:42:14 <Cale> I was going to say liftM2 id as well :)
08:42:18 <hpaste> hiptobecubic pasted “Hangman Again” at http://hpaste.org/87000
08:42:23 <hiptobecubic> Cale, maybe you can complain about this then?  ^
08:42:24 <yrlnry> I should have mentioned that I already asked lambdabot.
08:42:33 <shachaf> yrlnry: Also note that for some types you can define (<*>) more efficiently than anything that uses (>>=).
08:42:41 <edwardk> since the usual response to such a premature kill is to run the query 2-3 more times it probably would be a net good ;)
08:42:49 <shachaf> But if you want something monad-polymorphic, you're pretty much stuck with this sort of thing.
08:42:53 <yrlnry> OK!
08:43:21 <Cale> hiptobecubic: StateT over IO is frequently kind of silly, when IO already has so many facilities for state built into it.
08:43:40 <Cale> I mean, at worst, you just pass in an IORef
08:44:18 <shachaf> IORef is a different sort of state from StateT.
08:44:26 * Kinnison finds StateT over IO to be nicer looking than muffing about with IORefs
08:44:31 <c_wraith> StateT guarantees you won't have any concurrency issues
08:44:34 <c_wraith> IORef does not
08:44:38 <quchen> Cale: I usually use the IO part for printing, while the "s" state is used in a pure haskelly way. Is that not a good policy?
08:44:42 <shachaf> It makes sense sometimes to write functions :: Foo -> IO (Foo, a); so it makes sense sometimes to use StateT.
08:44:51 <Cale> c_wraith: That's true, but it's kind of a moot point in this program.
08:44:53 <c_wraith> I think Cale is relatively alone in this viewpoint
08:45:06 <shachaf> I agree with Cale in some cases.
08:45:25 <Cale> But also, you can make this nice by reducing the use of IO
08:45:29 * ocharles hugs his liberal use of ReaderT
08:45:30 <hiptobecubic> quchen, that was my thinking as well
08:45:31 <elliott> concurrency is relevant here
08:45:49 <Cale> elliott: ?
08:46:12 <Cale> elliott: This program makes no use of it, at least.
08:46:12 <hiptobecubic> I guess if took the loop out of play, i could take the renderGame call out as well
08:47:04 <hiptobecubic> also there are some refactoring warts still lying around
08:47:21 <Hafydd> > diff exp (exp 1) - (exp 1)
08:47:25 <lambdabot>   mueval-core: Time limit exceeded
08:47:33 <Hafydd> > diff exp (exp 1)
08:47:37 <lambdabot>   15.154262241479262
08:47:59 <FreeFull> :t diff
08:48:00 <lambdabot> Num a => (forall (s :: * -> *). Numeric.AD.Types.Mode s => AD s a -> AD s a) -> a -> a
08:48:10 <hammond> How can haskell help me to enhance the end consumer experience?
08:48:36 <FreeFull> :t diff 3 3
08:48:38 <lambdabot> Num a => a
08:48:41 <ocharles> Eliminating a whole class of bugs with just the type system feels like quite an improvement
08:48:43 <FreeFull> :t diff 3
08:48:44 <dmwit> Happy programmers make better products.
08:48:45 <lambdabot> Num a => a -> a
08:48:46 <c_wraith> hammond: by letting you quickly change lots of code without introducing breaking bugs
08:48:50 <Cale> hammond: by preventing bugs
08:49:06 <Cale> heh
08:49:10 <FreeFull> I don't get the type of diff
08:49:12 <hammond> hmmm
08:49:22 <hammond> so haskell is less buggy?
08:49:42 <c_wraith> haskell makes it easier to write less-buggy software
08:50:02 <Cale> hammond: Haskell has a rather expressive type system among languages which are as practical as it is for getting real-world software written.
08:50:05 <c_wraith> It still requires knowing what it is you want to do, and writing code to do it.
08:50:06 <Philippa> re
08:50:06 <hiptobecubic> Cale, how would you remove IO from this?
08:50:12 <FreeFull> hammond: Haskell errors on more buggy code than many (but not all) programming languages
08:50:29 <ocharles> Haskell's compiler errors*
08:50:39 <ocharles> (worth being precise)
08:51:03 <FreeFull> It is possible to prevent even more bugs with an even more expressive type system, that's where you start to get into dependent typing
08:51:18 <Philippa> hammond: Haskell can also encourage designs that have a 'clean' logic to them - making it easier for users to internalise a 'real' model of how your product works and start exploiting its capabilities
08:51:18 <typoclass> hammond: my experience is that it's hard to get stuff to compile in haskell, but once it does, there's not much debugging work left
08:51:24 <FreeFull> But if you do dependent typing then you'll probably end up having to write proofs, and type inference doesn't work as well
08:51:25 <zebr> hey all. i don't suppose there's a friendly guide to the different kinds of categories in cat theory, kinda similar to the typeclassopedia? basically i want to know if the concepts i'm dealing with can be used to model a kleisli category (and how).
08:51:29 <Cale> (but there aren't so many dependently typed languages as of yet which are as practical as Haskell for 'real world' use)
08:52:07 <FreeFull> Haskell makes it easy to write a bunch of small functions, combine them and end up with something more concise and less likely to have bugs than any imperative equivalent
08:52:21 <dmwit> I don't buy all this "my code compiles therefore it's correct" stuff. I still write bugs all the time.
08:52:23 <Cale> hiptobecubic: Well, let's try to reduce the use of StateT a bit
08:52:26 <dmwit> Maybe I'm just a skilled bug writer.
08:52:29 <Philippa> (example: it turns out mutability confuses everyone anyway - tools like Photoshop or Cubase or hmm, Nuke? Are about building up a big conceptually-immutable frameworks for producing the desired media)
08:52:38 <hammond> hmm... so when the software reaches the end consumer if it's written with haskell it's less buggy than if it was written with other languages?
08:53:08 <Philippa> (Haskell makes it easier to build such frameworks from the start instead of kludging them on top and ending up with the sort of mess that MS Word is)
08:53:22 <typoclass> hammond: i'd agree with that, all else being equal
08:53:23 <FreeFull> hammond: I'm sure there are other languages which will on average have programs with about the same bug/code ratio as Haskell
08:53:33 <zebr> dmwit: grats. that's a talent in itself.
08:53:44 <Cale> hiptobecubic: playRound is recursive anyway, and explicitly uses evalStateT, even though it is itself a StateT Game IO action
08:53:57 <hiptobecubic> Cale, playRound is particularly upsetting, yes.
08:53:58 <FreeFull> I'll take a map/foldl/foldr over a for loop any day
08:54:28 <hiptobecubic> Cale, I thought it looked like a good place for something from monad-loops, but I didn't see how to use whileM there.
08:54:35 <Cale> hammond: Or less time was spent getting it to that point, is the idea.
08:54:40 <hammond> is there such a benchmark that asses the number of bugs between languages?
08:54:50 <zebr> for a lot of things i'd rather have a for-loop but restrict it in certain ways so certain bugs are made impossible. that would be nice.
08:54:51 <hammond> I mean compares*
08:55:04 <Cale> hiptobecubic: Why not make the state there just a parameter to playRound?
08:55:39 <typoclass> dmwit: i meant compared to say java. (we don't even need to talk about dynamic languages.) haskell excludes more potential for bugs. Maybe alone has a big impact
08:55:56 <hiptobecubic> Cale, the state in playRound is the number of points, not the game
08:56:02 <dmwit> Haskell has a good type system. This enables more code reuse and spots some classes of bugs early. Haskell has a laziness. This enables more code reuse and reduces the need for a macro system. Haskell is functional. There are entire journal papers dedicated to explaining why this helps.
08:56:26 <nebnesknarf> typoclass: thanks for telling me about text-icu; but teh regex part looks horribly stateful to me
08:56:31 <Cale> hiptobecubic: yeah, just realised that
08:56:31 <dmwit> Haskell takes purity seriously. This enables better concurrency and parallelism mechanisms, and as a discipline makes code reuse safer.
08:56:36 <Cale> hiptobecubic: But the same applies
08:56:38 <hammond> ok
08:56:53 <nebnesknarf> typoclass: (iwas bfrn last time)
08:56:54 <hiptobecubic> Cale, which I used because it accumulates the scores of many calls to play
08:57:03 <typoclass> nebnesknarf: i think it was quicksilver who told you about text-icu, but you're welcome ;-)
08:57:12 <nebnesknarf> oops
08:57:16 <Cale> hiptobecubic: But it only runs play once per loop
08:57:24 <dmwit> How all of these translate into "better end-user experience" is very difficult to quantify.
08:57:29 <Cale> hiptobecubic: So you could just have it calling itself recursively with the new score.
08:57:32 <hiptobecubic> Cale, originally it was a WriterT over Sum, but I realized I wanted to print the score between plays
08:57:38 <hpaste> “Anonymous Coward” annotated “"jolly jumper"” with “"jolly jumper" (annotation)” at http://hpaste.org/50938#a87004
08:57:59 <hammond> but haskell isn't widely supported yet, how does this help benifit the end user of the end software?
08:58:03 <nebnesknarf> anyone else any idea for a regex library that is pure and supports Data.Text?
08:58:13 <Cale> also, don't use when (isRight ...), use case
08:58:36 <dmwit> The setup to that question doesn't seem connected to the question itself. Was it intended to be?
08:58:49 <Cale> well, I guess it doesn't matter so much
08:58:56 <hiptobecubic> Cale, I could, yes. That removes the call to execStateT i guess...
08:59:00 <Cale> But you awkwardly use either in the line before
08:59:13 <Cale> When if you were using case to pattern match, you wouldn't need to
08:59:58 <hiptobecubic> Cale, also true. But since the Left function actually does nothing, could I just move the Right one into the when block?
09:00:13 <Cale> hiptobecubic: I suppose you could
09:00:25 <Cale> Left e -> return ()  isn't so bad though
09:00:45 <Cale> I think it makes up for being able to pattern match the Right constructor away
09:00:53 <hammond> ok
09:01:17 <hiptobecubic> Cale, why do we want to do that?
09:01:28 <quicksilver> Cale: whenRight :: (Either a b) -> (b -> IO ()) -> IO () perhaps?
09:01:32 <hiptobecubic> I felt like "when isRight" was pretty understandable
09:02:04 <Cale> hiptobecubic: Well, it saves you the application of either
09:02:05 <shachaf> _Right (\x -> ...) (Right x)
09:02:12 <shachaf> I guess the order there is backwards.
09:02:21 <typoclass> shachaf: that's a lens thing?
09:02:22 <dmwit> :t (return () |||)
09:02:23 <lambdabot> (Monad (a b), ArrowChoice a) => a c () -> a (Either b c) ()
09:02:24 <shachaf> _Right ?? Left y $ \x -> ...
09:02:34 <shachaf> typoclass: It's exported from lens, yes.
09:02:48 <typoclass> shachaf: i see, thanks
09:02:51 <Cale> I also have a strong bias against isFoo/fromFoo functions
09:03:00 <hiptobecubic> Cale, why?
09:03:02 <quicksilver> shachaf: how does that do the return () on Left part?
09:03:08 <Philippa> so, I'm thinking something having missed most of that conversation aside from the chunk I did a driveby on...
09:03:12 <Cale> Because it's easier to screw up your use of them
09:03:13 <Philippa> folks, we suck at talking management
09:03:15 * elliott smells a lens opportuniti
09:03:25 <hiptobecubic> hmm
09:03:26 <elliott> :t _Right print
09:03:28 <lambdabot> Show a => Either c a -> IO (Either c ())
09:03:28 <Philippa> hammond was asking management questions about haskell as a "technology" (to managers, that's a formal concept)
09:03:33 <SrPx> SrPx: check out http://www.eecs.harvard.edu/~mainland/publications/mainland13haskellbeatsc.pdf
09:03:40 <SrPx> this is an extremely specific problem...
09:03:41 <shachaf> quicksilver: _Right :: Applicative f => (a -> f b) -> (Either c a) -> f (Either c b)
09:03:55 <Cale> Philippa: alternately, he might have been a protontorpedo
09:03:57 <shachaf> quicksilver: (Actually it has a more general type than that. But that doesn't matter so much here.)
09:04:04 <Philippa> Cale: true
09:04:10 <shachaf> Anyway the pure is built in.
09:04:18 <Philippa> OTOH, either way we can take this as an opportunity to improve our talking-to-managers
09:04:49 <Philippa> for example: papers? Useless to them, you can't refer to them in slides aimed /at other managers/ unless they're empirical studies on results
09:05:01 <nebnesknarf> quicksilver: thanks for bringing text-icu to my attention (even though it is not what I was looking for)
09:05:02 <quicksilver> shachaf: so on the 'left' side it uses pure to pass through the plain value already stored on the left.
09:05:05 <quicksilver> nebnesknarf: ;)
09:05:08 <quicksilver> nebnesknarf: yw.
09:05:14 <quicksilver> shachaf: makes sense.
09:05:23 <Philippa> amusingly enough, comparing tweet counts for "java less buggy than haskell" and vice versa might matter
09:05:34 <shachaf> quicksilver: Better would be to use traverseOf_ _Right
09:05:39 <Cale> hiptobecubic: When you use case and pattern match, you have a harder time not handling some cases, or extracting the wrong components in the branch of the logic you're in (because they're bound by the patterns which matched)
09:05:45 <quicksilver> shachaf: why would that be better?
09:05:51 <dmwit> I feel that "less buggy" is not the right talking point.
09:05:52 <shachaf> For the same reason mapM_ is better than mapM
09:06:08 <bos> current status: http://i.imgur.com/qeKLbqy.gif
09:06:09 <shachaf> Ah, forOf_ _Right eitherValue $ \x -> ...
09:06:09 <quicksilver> shachaf: would it force c to be () ?
09:06:33 <quicksilver> or would it just ignore c.
09:06:36 <shachaf> forOf_ _Right :: Applicative f => Either c a -> (a -> f r) -> f ()
09:06:42 <typoclass> bos: was hoping for cat picture :-(
09:06:43 <quicksilver> some many combinators so little brain space :)
09:06:47 <shachaf> In particular it wouldn't rebuild the structure unnecessarily.
09:06:50 <quicksilver> yes.
09:06:58 <shachaf> It doesn't matter so much here because an Either is small.
09:07:05 <dmwit> The talking point should be "more productive", or maybe "not slow at prototyping and fast for prototype -> product conversion".
09:07:06 <quicksilver> that is exactly a generalisation of whenRight.
09:07:15 <quicksilver> :)
09:07:20 <shachaf> quicksilver: Right.
09:07:23 <quicksilver> shachaf++ # lens-san
09:07:29 <shachaf> quicksilver: Most of these combinators are existing Data.{Foldable,Traversable} with an extra "Of" inserted.
09:07:48 <dmwit> bos: The cost of simplicity sure seems like more than $0.75 these days. =P
09:07:58 <shachaf> That way you can also say _Left or (traverse . _Just) or things like that.
09:08:10 <hiptobecubic> Cale, so instead of "when (isRight foo)" You prefer case foo of Right .... Left -> return () ?
09:08:28 <quicksilver> hiptobecubic: only when you use fromRight.
09:08:33 <Cale> hiptobecubic: if I'm going to be using the value in the Right constructor, certainly
09:08:42 <quicksilver> if I follow cale's argument
09:08:43 <hiptobecubic> Cale, yes.  I realize now that that's why this call to modify wasn't in there to start with...
09:08:51 <shachaf> (traverse . _Just) would give you Applicative f => [Either a c] -> (a -> f r) -> f ()
09:09:01 <hiptobecubic> Have to unpack it before i can call points on it...
09:09:20 <shachaf> quicksilver: You should come to #haskell-lens!
09:09:39 <elliott> dmwit: I think I am a hopeless case: I read "more productive" immediatel as referring to codata.
09:09:51 <dmwit> Hah!
09:10:04 <quicksilver> shachaf: I should find some time to write some haskell.
09:10:12 <quicksilver> shachaf: I don't really understand stuff unless I use it.
09:10:15 <typoclass> Philippa: i think haskell is difficult to sell to mainstream programmers, even those who would like to improve themselves, because they perceive haskell as having an impossibly high barrier of entry. some of it is silly rumor, but some is actually encouraged by the terminology, the state of several of our haddock pages, the myriad monad tutorials
09:10:29 <hiptobecubic> typoclass, ++
09:10:45 <hiptobecubic> For me, it was a reason *too* start learning it, but many disagree
09:11:13 <Philippa> typoclass: Yep. Managers are a separate group with separate concerns though, and getting some on board could actually help ease that perception problem over time by giving us new resources
09:11:15 <ocharles> I'm not sure why I started learning it
09:11:34 <shachaf> quicksilver: OK, but you should still come.
09:11:39 <typoclass> Philippa: true
09:11:42 <hpaste> Cale annotated “Hangman Again” with “Hangman Again (annotation)” at http://hpaste.org/87000#a87008
09:11:52 <hiptobecubic> In particular, people seem really aggressive about the idea of calling something a Monoid instead of an "Addable" or whatever they think of
09:11:56 <Philippa> dmwit: the points I was making are also significant though. They help you do things that are right *for the user*
09:12:01 <Cale> hiptobecubic: ^^ isn't that nicer without all the liftIO's?
09:12:07 * typoclass should go make some haddock patches, just as proposals
09:12:37 <hiptobecubic> And arguments like "monoids have been around forever and there's no need to make up new words every time a language reinvents something because no one did any research" don't seem to sway them
09:12:40 <nebnesknarf> I started learning Haskell because I was unsatisfied and it looked interesting; part of the fun was that when I started I did not understand a thing
09:13:04 <nebnesknarf> I mean unsatisfied with the existing languages (those I knew of)
09:13:12 <dmwit> Philippa: Yes, I think you had some fine points.
09:13:28 <dmwit> I like those a lot more than "less bugs silver bullet lollerskates!".
09:13:34 <Cale> I don't think we have to worry so hard about winning every popularity contest which comes along.
09:13:54 <nebnesknarf> Cale: +1 from me
09:13:55 <shachaf> Cale: All the cool people try to win popularity contests.
09:14:07 <Philippa> dmwit: Yeah. I suspect they're ones that not enough of our own community readily appreciates yet, they're the sort of thing you have to've seen a few products evolve for
09:14:26 <dmwit> Cale: People who would like to have a job at a Haskell shop might disagree with you. =)
09:14:30 <typoclass> Cale: true, but there's nothing wrong with discussing e.g. how to improve the teaching of haskell
09:14:31 <Philippa> Cale: Agreed. But there's a difference between that and knowingly letting ourselves be inaccessible to a group
09:14:34 <Cale> There's value in being able to look up research on the concepts that people are using because they haven't arbitrarily renamed things to be more "friendly"
09:14:52 <quicksilver> Philippa: I'm a manager. None of my team use haskell. Does that make me part of the problem?
09:15:21 <Cale> When someone uses the term Monoid, if I don't know what a monoid is, I can google it, and I get a wikipedia page which tells me useful stuff about monoids.
09:15:21 <Philippa> quicksilver: not as far as I'm concerned. Not just because I don't know what you manage, either
09:16:04 <Philippa> Cale: yeah. Although said page is pretty inaccessible to anyone without a maths background which eg approximately nobody in the UK who hasn't studied a mathematical subject at uni has
09:16:07 <Cale> If we changed the name to Addable or whatever, that would be 1) potentially misleading, and 2) impossible to look up apart from our own community's documentation.
09:16:14 <quicksilver> Cale: (although it's not entirely clear that that wikipedia page is the best possible resource for a computer programmer)
09:16:27 <hiptobecubic> Cale, you're preaching to the choir here. I'm telling you that these arguments don't work in practice
09:16:46 <Cale> hiptobecubic: What do you mean?
09:16:51 <Philippa> for perspective: *I* had trouble with that stuff in '00
09:16:57 <Cale> These arguments do apply in practice, to me.
09:17:02 <ocharles> we do have some overly cryptic names though. the last one that come up in a silly work argument was "intercalate"
09:17:06 <hiptobecubic> Cale, especially when someone google's monoid, goes to the top result which is typically wikipedia, and are led into the bowels of abstract algebra as taught by the kind of people that write math articles on wikipedia
09:17:11 <Philippa> not insurmountably so, but at a level that would have been for many
09:17:17 <hiptobecubic> and is*
09:17:26 <Cale> (of course, I know what a monoid is, and already knew before I started learning Haskell)
09:17:39 <Cale> But I have a selfish interest in Haskell being the way that I like things to be.
09:17:40 <Philippa> hiptobecubic: quite. "Abstract Algebra for Programmers" is something that can be done and made easy, but it sure as hell doesn't involve founding yourself in set theory
09:17:59 <FireFly> see e.g. caleskell?
09:18:16 <oconnor0> probably the third or fourth time i read the wiki page on monoids, i understood it.
09:18:37 <Philippa> ocharles: there comes a point where the thesaurus is only so good though. What else can you do?
09:18:47 <typoclass> Cale: the first thing that comes up when googling 'monoid' is the wikipedia page saying 'In [abstract algebra], a branch of [mathematics], a monoid is an [algebraic structure] with a single [associative] [binary operation] and an [identity element].' i don't think any of this stuff even hints at the idea of appending
09:18:49 <Philippa> I mean, aside from a name half a screen long?
09:19:18 <hiptobecubic> typoclass, or programming. Or anything the average person who hasn't taken a "real" math class would recognize
09:19:21 <Cale> hiptobecubic: I see very little issue with the wikipedia article for monoid. The blurb at the top is kind of distracting, perhaps, and if I'd written the article, it would just start with the definition before getting into philosophical points of where it sits relative to everything else.
09:19:31 <Cale> But the definition is right under that
09:19:36 <Cale> and it's clear enough...
09:19:47 <typoclass> ocharles: yeah, there was also a #haskell discussion on intersperse/intercalate the other day.
09:19:48 <Philippa> Cale: so you'd happily throw an interested smart 10 year old that and nothing else and expect that'd /reliably/ do the trick?
09:20:03 <hiptobecubic> Cale, it's clear because you know how to read and interpret formal definitions in mathematics
09:20:07 <quicksilver> ocharles: "intercalate" makes me thing "hmm, no idea what that word means, something like interpolate but different" which is by no means the worst intuition for it.
09:20:08 <Philippa> (hint: at 10 I was capable of grokking basic abstract algebra)
09:20:28 <Philippa> (I didn't know the field /existed/ for nearly another decade)
09:20:50 <Philippa> (I did as much 'pure' maths as you can do within the UK educational system prior to university...)
09:21:25 <dmwit> typoclass: I'm not sure I buy your argument that "appending" is the core of monoids, even the way Haskellers use them.
09:21:33 <ocharles> quicksilver: not good enough imo. for a start, it took me a long time to commit to memory the difference between intersperse and intercalate
09:21:39 <hiptobecubic> dmwit, no?
09:21:45 <dmwit> no
09:21:48 <quicksilver> ocharles: I still have the check their types. Does it matter?
09:21:56 <ocharles> yes it matters, because that's a context switch
09:22:02 <Philippa> dmwit: myself I'm more interested in the idea that 'associativity' makes the structure 'flat' (as one component) and identities in general as another
09:22:04 <dmwit> That's [a], Text, ByteString, maybe. But we have dozens of other monoids that we use all the time.
09:22:09 * geekosaur thinks of it more as "combining"
09:22:11 <ocharles> but i don't want to argue about this specific name
09:22:24 <Cale> Philippa: Well, you might have a bit harder time as a 10 year old, but it's better to have a bunch of resources which may be a bit more tricky to understand and require looking up basic terms in, than to have... nothing because the people who wrote the library invented a completely new term.
09:22:27 <ocharles> my point is that we have a bunch of stuff in prelude that's named more abstractly than it need be
09:22:29 <nebnesknarf> isn't appending what comes out naturally for a free monoid?
09:22:31 <Philippa> (the fact a monoid /specifically/ doesn't give you a structure you can build a tree with sans extra knowledge)
09:22:35 <geekosaur> which may be appending, or aggregating, or something else (think the Maybe instance)
09:22:39 <quicksilver> ocharles: I suppose if I used them every day I might remember, but I don't see this is teribly unusual in programming. I can't remember the order of the arguments in regexp_replace in PHP, for example.
09:22:41 <dmwit> nebnesknarf: Yes, but most monoids have further laws.
09:22:50 <ocharles> not to mention our documentation being extremely obtuse in many places, mentioning things like 'dual's and 'Kleisli arrows'
09:22:59 <quicksilver> ocharles: and I can't remember the order of the return values in perl's gmite
09:23:01 <quicksilver> gmtime
09:23:03 <Philippa> Cale: Those resources are *worse than useless* to a substantial proportion of people. It's not about the naming.
09:23:08 <ocharles> quicksilver: but you remembered the names of the functions
09:23:22 <Philippa> A merely useless resource doesn't give people the impression they aren't smart enough when they're just not being given an appropriate explanation
09:23:25 <quicksilver> ocharles: no, I didn't. It's preg_replace ;)
09:23:27 <hiptobecubic> dmwit, "append" is really a horrible name
09:23:27 <typoclass> dmwit: ok, what would you call it? suppose you had to give 1-2 typical examples how haskellers use monoids
09:23:30 <ocharles> quicksilver: when you're a newbie and you don't know what you're even looking for, scanning the index on going "oh, intercalate - of course!"
09:23:39 <ocharles> that doesn't happen
09:23:43 <typoclass> hiptobecubic: you mean mappend?
09:23:45 <nebnesknarf> dmwit: so appending is just an example of a monoid, albeit one that is somewhat 'natural'
09:23:48 <Philippa> so they don't just fail to educate: they're worse than failure
09:23:49 <quicksilver> that's true, ocharles, that's a good point.
09:23:55 <Cale> Philippa: How would you change the wikipedia page for monoids to be more accessible?
09:24:04 <quicksilver> I suppose I don't often scan through indices like that.
09:24:06 <ocharles> especially as intercalate in day-to-day speech here is about taking time out of university studies ;)
09:24:13 <Cale> I don't doubt there's lots of ways in which it could be improved
09:24:17 <dmwit> typoclass: Why not call it a monoid? =)
09:24:18 <hiptobecubic> typoclass, yes sure. Associating the monoid operation with the idea of "appending" is bad
09:24:18 <Philippa> Cale: loaded question. I'd have to change the entirety of how wikipedia handles maths
09:24:27 <geekosaur> quicksilver, it's based on (struct tm) but with additions. the important part is most to least specific: sec min hour day month year
09:24:30 <Cale> hmm
09:24:33 <quicksilver> the wikipedia page for monoids is fine.
09:24:40 <quicksilver> because monoids are an important concept
09:24:49 <hiptobecubic> quicksilver, for mathematicians I agree.
09:24:50 <quicksilver> unfortnuately it's not a great resource for a computer programmer
09:24:51 <Philippa> like, there should be a page that is approximately that one: it is an appropriate reference for mathematicians in the absence of something better targetted
09:24:52 <typoclass> hiptobecubic: ok that may or may not be, but i didn't come up with the name mappend :-)
09:25:00 * typoclass agrees with Philippa on all counts
09:25:00 <hiptobecubic> typoclass, i'm not blaming you :)
09:25:04 <quicksilver> because the programmer is looking for somethiing different
09:25:19 <Cale> I think it's unreasonable to expect programmers not to have to learn some mathematics along the way
09:25:21 <ocharles> Philippa: are you looking for simple wikipedia?
09:25:27 <Philippa> I would be happy building something from a computational POV for a much wider audience because I share a certain kind of mathematical religion ;-)
09:25:30 <hiptobecubic> anyone want to write the simple english translation?
09:25:33 <quicksilver> "In computer science, a type with a combining operation can be called a Monoid..."
09:25:43 <Philippa> ("computational POV" /= "for programmers")
09:25:54 <quicksilver> Cale: I think it's unreasonable to accept that most programmers do not understand abstract algebra.
09:25:55 <typoclass> quicksilver: "combining" sounds a lot like appending ...
09:26:02 <nebnesknarf> I agree that the wikipedia math pages are a bit overfrought with expert stuff like mentioning all the connections to other math fields rigth at the start. Definition should come first, then a few simple examples, then everything else
09:26:02 <typoclass> (which was criticized)
09:26:06 <quicksilver> I've worked with many, including many good ones.
09:26:12 * dmwit starts out his Wikipedia rewrite with "a monoid is a one-object category"...
09:26:15 <hiptobecubic> typoclass, it's definitely more general than appending
09:26:29 <quicksilver> typoclass: it was more or less a straw man.
09:26:33 <Philippa> I'd probably have to do quite a lot of active, hard work to then figure out how my first attempt drops out, because I'd need to be doing open examples in the text
09:26:34 <Cale> quicksilver: Did you say the inverse of what you meant, or is your position even stronger than mine?
09:26:43 <typoclass> hiptobecubic: ok, but people learn by going from the concrete to the abstract
09:26:53 <Philippa> (it would be easier if I chose to use Haskell for examples, but finding a way to avoid the type class mechanism is good here)
09:27:03 <hiptobecubic> typoclass, then use a concrete example with the correct vocabulary
09:27:13 <quicksilver> Cale: I meant to say "I've worked with many programmers, including many good ones, and the majority - even of the good ones - do not have a good understanding of abstract algebra"
09:27:34 <Cale> Perhaps they should obtain one!
09:27:37 <hiptobecubic> but combining paint in a can is a perfectly fine monoid example that has nothing to do with gluing things together face-to-butt.
09:27:53 <quicksilver> typoclass: I don't think the WP page should be rewritten to make a computer programming example front and center, because I don't think it's front and central to the notion of monoid.
09:28:01 <hiptobecubic> quicksilver, agreed
09:28:03 <quicksilver> typoclass: the computer programming case is a niche.
09:28:11 <dmwit> Ah, color. One of those things that ranks up there with text and time for unobvious complexity.
09:28:13 <quicksilver> although I niche I'm personally interested in :)
09:28:33 <hiptobecubic> The problem is that it's the only place to go unless you already know where to look
09:28:48 <quicksilver> Cale: perhaps they should. I'd recommend it to anyone. But I would ideally not like it to be a pre-requisite for using haskell.
09:28:49 <typoclass> Cale: i think we should be careful with "well they just need to learn that stuff", because that can is just as much an argument for AbstractPatternAbstractFactoryFactory
09:28:52 <Cale> It's a really big niche in the case of monoids.
09:28:54 <quicksilver> and actually I really don't think it is one.
09:29:09 <Philippa> Cale: one reason I'd have to work quite hard is that the mere idea of doing maths on "things that aren't numbers" is weird to the target audience and finding a notation that intuitively fits is surprisingly tricky
09:29:23 <Cale> The theory of formal languages is often thought of as a branch of computer science, and monoids are central to the study of that.
09:29:26 <Philippa> as it happens, you can do a lot by just laying out stuff appropriately
09:29:37 <nebnesknarf> There are people how think that they need not know anything about logic before starting to write programs - I think this is just silly
09:29:46 <Philippa> Cale: And yet commonly ignored in undergrad CS classes on the subject, even at 'good' universities
09:30:00 <dmwit> Okay. I will admit that the first time I saw "+" being used for an operation that wasn't numerical addition, I got a bit thrown.
09:30:08 <Cale> typoclass: Well, don't you need to know those patterns if you're working on code which makes such hideously explicit use of them?
09:30:25 <typoclass> anyway, i still think that it'd be worth a try to find 1-2 different examples, each 3 lines of haskell code, that are "a good example" of using Monoid
09:30:30 <tac> dmwit: What about when you get to modern algebra, and you see xy to mean "x plus y" :)
09:30:54 <oconnor0> i certainly had no exposure to monoids or other such concepts in my undergrad.
09:30:54 <nebnesknarf> IMO Universities should teach a minimum of abstract algebra to gether with basic formal logic before mentioning programming at all
09:30:57 <tac> (rather x . y  with some kind of dot in between)
09:31:13 <dmwit> tac: By the time that happened, I was a sophisticated enough mathematician to take notational choices in stride. =)
09:31:20 <hiptobecubic> nebnesknarf, well they don't.
09:31:47 <dmwit> You should only be surprised by something once... or twice, if it's really surprising. ;-)
09:31:52 <nebnesknarf> tac: mathematical notation is often horribly twisted
09:32:04 <Philippa> dmwit: yeah. Whereas when you're introducing 'advanced' mathematical concepts to an audience that's a little scared of maths, the best notation probably isn't one that's chosen for efficiency of manipulation by people doing stuff day-in day-out
09:32:05 <tac> dmwit: I think the real lesson is simple substitution is a very tricky concept for people to understand (at least, once you reach a certain threshold)
09:32:25 <Cale> I tend to see it as a good thing if the knowledge of mathematicians and the knowledge of programmers and computer scientists is somehow made to overlap more.
09:32:30 <Philippa> tac: Hah! To the point of being a research subject, yes :-)
09:32:30 <nebnesknarf> hiptobecubic: so programming language communities should rectified that? I don;t think so
09:32:33 <hiptobecubic> My girlfriend has had exactly one mandatory course on abstract algebra in her pure math program in the netherlands, a second is available as an elective. Asking for more than that in CS is going to be a hard sell.
09:32:59 <Cale> These are obviously related subjects and can be made to share a lot of notation and perspective on things.
09:33:15 <Philippa> hiptobecubic: quite. As is asking people to be highly adept at scaling abstraction hierarchies /while they're still learning/
09:33:18 <Cale> Sometimes they have a different philosophical outlook, and that's fine
09:33:28 <Philippa> I get by because I've been coding for... eh, if you ask my dad then about 25 years
09:33:30 <nebnesknarf> hiptobecubic: i dont't believe in selling ideas
09:33:37 <Cale> But to the extent that terminology and concepts can be shared, I'd like to see it happen.
09:33:47 <Philippa> Cale: Terminology and concepts I agree. Notation? Fuck that
09:33:58 <tac> Math notation isn't always terrible.
09:34:04 <hiptobecubic> Especially since the vast majority of software running the world has been written by people who don't have any particular training in abstract algebra and don't (intentionally) use it.
09:34:14 <Philippa> Mathematicians *have different requirements*. Same way engineers do.
09:34:17 <tac> Philippa: Unless it touches calculus at all....
09:34:21 <Philippa> Engineers do, in fact, commonly use different notation
09:34:50 <Cale> Modern mathematics notation which wasn't invented by physicists or engineers is usually not terrible ;)
09:35:23 <nebnesknarf> would you want your house to be built by someone who doesn't know enogh math to correctly calculate the statics?
09:35:28 <tac> Whenever I see something like "let x=x(t) be a function" I die a little inside :P
09:35:41 <Philippa> Cale: it is commonly not an /aid/ to internalising a new concept though, and programmers are expected to do so momentarily and sit out a patch on a day-to-day basis. That creates entirely different psychology around the matter
09:35:55 <nebnesknarf> tac: +1
09:36:08 <Cale> tac: So do I, and so do most mathematicians
09:36:21 <Philippa> Cale: there are definitely improvements over time, yeah. To the point where so long as I start using strings rather than characters for variable names I'm often happy applying it for code
09:36:39 <FreeFull> Eventually people do get fed up with crappy notation if it's used a lot
09:36:59 <Philippa> and this is another problem: people tend to've been exposed to courses using bad, older notation but no historical perspective. Worst of both worlds and downright scary.
09:37:08 <Cale> yes
09:37:22 <typoclass> FreeFull: (... and start defending the crappy notation, due to some kind of stockholm syndrome ...)
09:37:25 <tac> I was watching a few Coursera lectures on algorithms, and I noticed something funny about the teacher. He kept saying how he was going to rigorously prove things with math, and that while difficult, it was necessary
09:37:28 <Philippa> FreeFull: yeah. Propagating that through high school-level teaching can take a substantial chunk of a century though
09:37:47 <tac> But there was no rigor. It was entirely engineering equation handwaving
09:38:12 <typoclass> tac: guess it wasn't so necessary after all? :-)
09:38:43 <hiptobecubic> tac, indeed. I remember that course.
09:38:44 <FreeFull> I'd rather watch the free MIT videos than coursera
09:38:45 <Philippa> Cale: I have some things I need to get done today etc etc, but would it make sense if we chat in PM or one of the side chans about this (and the monoid example in particular) a bit later?
09:38:56 <tac> Handwaving analysis has its place. But it's a farce to pretend it's "math"
09:38:58 <Cale> Philippa: sure, if you'd like :)
09:39:02 <Philippa> if useful: I'm on UK time and should be around before midnight locally
09:39:48 <Philippa> but: the big reason I didn't tell you straight up how I'd improve the monoid page is that it involves figuring out the (slightly implicit) curriculum I'd pick to support the damn thing
09:40:02 <Philippa> which is a bit much like hard work for a drop-in conversation
09:40:10 <nebnesknarf> tac: when i studied math, i had this problem with probability theory, which is why i never learned it properly; everything was handwaving
09:40:19 <Cale> One of my hopes for the future is that Voevodsky's program is successful, and the notation of mathematics and computation becomes more unified.
09:40:21 <Philippa> nebnesknarf: Hah, yes
09:40:44 <tac> nebnesknarf: I really wish I could have taken statistics in the math department at my school. By some bullshit, I ended up taking MQ101, the business stats class.
09:40:58 <Cale> and we actually end up writing programs in dependently typed languages based directly on homotopy type theory :)
09:41:02 <tac> Cale: for sure. That would be grand
09:41:31 <tac> Cale: I was thinking the other day of how you could write a near-natural language theorem assistant
09:41:33 <Cale> and those same languages not only can be, but are used to formalise mathematics
09:42:03 <Cale> (in a way that ZFC only does now in a wishful-thinking kind of way)
09:42:05 <tac> Where you had multiple choices in how you presented things. "For all blah blah", "the product of blah blah", "Let x be a blah blah" all translate into a Pi type
09:42:06 <nebnesknarf> tac: ...and i wish i had taken abstract algebra and category theory instead of functional analysis, i would have profited mroe and i think i would have had more fun, too
09:42:19 <Cale> tac: indeed :)
09:43:00 <tac> nebnesknarf: You would probably like the book I'm going through atm. Aluffi's Algebra Chapter 0
09:43:12 <tac> It's algebra with a light application of category theory from the very start.
09:43:25 <Eduard_Munteanu> Yikes, functional analysis.
09:43:40 <Eduard_Munteanu> Depends what you're doing, if it's engineering it probably made more sense at the time.
09:45:16 <nebnesknarf> Eduard_Munteanu: the basic stuff is pretty nice (i mean: beautiful), but the more advanced parts are extremely difficult and not very general i.e. messy
09:45:40 <Cale> Functional analysis can be really frustrating at first when your intuition is garbage.
09:45:52 <Eduard_Munteanu> Yeah, I don't know much about it... I've taken some courses in optimization.
09:45:57 <Cale> and you just have to treat everything in a completely technical fashion
09:46:13 <nebnesknarf> Cale: right, but doesn't that apply to algebra and cat theory too?
09:46:17 <Eduard_Munteanu> (but not proper functional stuff)
09:46:36 <Cale> nebnesknarf: Well, yes, but in this case, you're more tricked into thinking that your intuition might work :)
09:46:45 <Cale> It's largely about various sorts of infinite dimensional normed vector spaces
09:47:04 <Cale> and if you try to apply finite dimensional intuitions, you can fall into various traps :)
09:47:22 <Eduard_Munteanu> I find it the intuition in CT and abstract algebra is easier to summon. Everyone knows cartesian products or addition in reals, so they can grasp examples of basic stuff.
09:48:11 <nebnesknarf> Or, to put it more intuitively, it's about solving linear equations, like in linear algebra, but for the infinite dimensional case
09:48:23 <FreeFull> I don't even know how to raise something to a complex power yet =P. I guess I should find out
09:48:55 <tac> > (1 :+ 1) ** (2 :+ 2)
09:48:58 <lambdabot>   (-0.2656539988492411) :+ 0.3198181138561361
09:49:13 <Eduard_Munteanu> That's trickier compared to the real case, yeah.
09:49:19 <nebnesknarf> FreeFull: that's also something i never found the right intuition for
09:49:19 <Cale> > (0 :+ 1) ** (0 :+ 1)
09:49:21 <lambdabot>   0.20787957635076193 :+ 0.0
09:50:01 <Cale> If you *really* know how to raise things to a real power, it's not so bad.
09:50:34 <Eduard_Munteanu> Um, I don't get "really" then. :)
09:50:52 <FreeFull> Complex addition, multiplication, and raising a complex number to a real power is easy enough
09:51:13 <Cale> FreeFull: How do you raise a complex number to the power of sqrt(2)?
09:51:15 <Eduard_Munteanu> That has pitfalls too.
09:52:02 <monoidal> raising complex to integers is easy; raising to a rational p/q is q-valued; to a real is infinitely-many valued
09:52:11 <Eduard_Munteanu> Even taking the sqrts of complex numbers requires a bit of care.
09:52:26 <nebnesknarf> self-reflecting about where the discussion started: so do we scare the non-math educated / interested away now?
09:52:32 <Cale> Even just: how do you raise a positive real number to the power of sqrt(2)?
09:52:55 <FreeFull> I'd use an infinite sum
09:52:59 <monoidal> Cale: x^y = exp(y ln x)
09:53:18 <Cale> monoidal: correct :)
09:53:59 <Taneb> > exp (sqrt 2 * log 10)
09:54:01 <lambdabot>   25.954553519470092
09:54:02 <Eduard_Munteanu> Can't you handwave it as raising to ever-better rational approximations of the real?
09:54:02 <Cale> The story involving a little bit of calculus which produces this result is interesting though :)
09:54:30 <nebnesknarf> Eduard_Munteanu: certainly
09:54:32 <monoidal> Eduard_Munteanu: you can (when x > 0)
09:54:32 <Cale> Eduard_Munteanu: ehhhh... you *can*
09:55:16 <FreeFull> Eduard_Munteanu: That's not useful if you want an exact answer though
09:55:55 <Eduard_Munteanu> Exact answers kinda went out the window ever since we graduated from addition and multiplication (and their inverses). :)
09:55:55 <Cale> It can be formalised by taking limits or even the supremum of an appropriate set directly.
09:56:08 <Cale> and those are exact
09:56:19 <Cale> (at least in whatever sense real numbers are exact)
09:56:27 <nebnesknarf> but what about complex (i mean: imaginary) powers?
09:56:41 <Cale> nebnesknarf: So, you pull this same trick
09:57:01 <Cale> You usually define exp and log in order to get exponentiation to real powers
09:57:07 <Taneb> exp (i * theta) = cos theta + i * sin theta
09:57:11 <FreeFull> Well, by exact I mean equivalent
09:57:31 <Cale> and by generalising exp and log to complex numbers, you can obtain exponentiation in the same way
09:57:33 <FreeFull> Like how sin²x + cos²x is exactly 1
09:57:46 <nebnesknarf> Taneb: ah, that was it, right
09:58:25 <Eduard_Munteanu> Fun fact: sines of complex numbers can be larger than 1 in absolute value (our teacher called it "industrial sine" :P)
09:58:28 <FreeFull> Isn't ln(-x) = ln(x) ± i*pi
09:59:08 <quchen> Eduard_Munteanu: That's because sin grows exponentially for (purely) complex arguments.
10:00:00 <Eduard_Munteanu> Yeah, I guess you can blame it on the e^(i*x).
10:00:04 <Cale> Another fun fact: if they couldn't, the sine function, being differentiable everywhere, would be constant.
10:00:21 <Eduard_Munteanu> Wow, not sure how to interpret it.
10:00:38 <nebnesknarf> no analytic function can be limited (in modulus) everywhere it is defined other than the constant functions
10:00:39 <Cale> Every bounded entire function is constant
10:00:53 <quchen> FreeFull: + 2*k*pi*i, k from Z
10:00:53 <nebnesknarf> Cale: you said it better
10:00:57 <Cale> http://en.wikipedia.org/wiki/Liouville's_theorem_(complex_analysis)
10:01:02 <Eduard_Munteanu> Cale: you mean you'd get a constant function if you defined sine as a solution of a differential equation with that constraint?
10:01:35 <nebnesknarf> Eduard_Munteanu: no, if you arbitrarily limit the domain it will be limited of course
10:01:36 <monoidal> Eduard_Munteanu: no, you'd get normal complex sine
10:01:59 <Cale> Eduard_Munteanu: Well, I just mean that given the property that f: C -> C is differentiable everywhere, and the fact that it's bounded (in magnitude), you can show that it must be a constant function.
10:02:06 <monoidal> Eduard_Munteanu: y'' + y = 0 has solutions y=Csinx + Dcos x
10:02:10 <Eduard_Munteanu> Hm.
10:02:44 <Cale> Differentiability for complex functions is a very strict property
10:02:52 <nebnesknarf> The theorem Cale cited is only true if you regard the function over the its whole (complex) domain
10:03:02 <Cale> (much moreso than differentiability of functions R^2 -> R^2)
10:03:13 <Eduard_Munteanu> Yeah... forgot quite a bit about holomorphic functions and such.
10:03:32 <nebnesknarf> Eduard_Munteanu: me too, apparently ;-)
10:03:43 <tac> FreeFull: don't forget ln is not defined at 0 :)
10:03:45 <tac> > log 0
10:03:47 <lambdabot>   -Infinity
10:03:54 <tac> (Unless you're the IEEE........)
10:04:02 <klrr> why is all JSON libraries so hard to use?
10:04:03 <Cale> > log 0 :: Complex Double
10:04:05 <lambdabot>   (-Infinity) :+ 0.0
10:04:09 <Cale> kekeke
10:04:25 <tac> klrr: No one knows :( But they are
10:04:35 <nebnesknarf> klrr: maybe because json is untyped and Haskell is typed?
10:04:36 <Eduard_Munteanu> klrr: not sure, what are you having difficulties with?
10:04:37 <quchen> I have no complaints about Aeson.
10:04:44 <monoidal> the log 0 = -infinity is bit awkward: for complexes there's generally one infinity
10:04:50 <tac> nebnesknarf: that's nothing a Maybe shouldn't fix, though.
10:05:07 <tac> (well, I guess it's a little more complicated than that...)
10:05:18 <monoidal> I'm not sure if the way it's currently defined is correct/consistent with other properties.
10:05:21 * hackagebot binary 0.7.1.0 - Binary serialisation for Haskell values using lazy ByteStrings  http://hackage.haskell.org/package/binary-0.7.1.0 (LennartKolmodin)
10:05:29 <quchen> monoidal: That depends on whether you consider the compactification or not.
10:05:31 <Cale> Okay, so getting back to how we approach the original definition for raising a positive real number to a real power...
10:05:37 <Eduard_Munteanu> monoidal: one infinity? I guess you can approach infinity at any angle [0; 2pi) in polar coordinates
10:06:01 <monoidal> Eduard_Munteanu: yes, but AFAIR most things get ugly then
10:06:03 <Cale> We know that for natural number powers, we have a^n * a^m = a^(n+m)
10:06:05 <Jaxan> Eduard_Munteanu: you can extend C with one infi to be like a sphere ;)
10:06:11 <tromp> or you can spiral to infinity
10:06:17 <nebnesknarf> I find that fitting untyped stuff to Haskell often leaves me somewhat unsatisfied
10:06:19 <klrr> i tried to write a simple Hacker News app, that simply prints the 10 latest posts, but then i try use Text.JSON and it was too difficult and then Aeson but it couldnt parse json arrays, now im trying to write parse json using parsec combinators but am stuck at parsing JSON objects
10:06:40 <quchen> With the same argument you could say the real infinities are equal because the compactification is a circle.
10:06:57 <Cale> and using this property as a guide, it's easy enough to generalise to integer powers, since if a^(-n) * a^n = a^0 = 1, then a^(-n) must be the multiplicative inverse of a^n
10:07:18 <Eduard_Munteanu> Hm.
10:07:29 <monoidal> quchen: there's a good reason to consider +-infinity compactification for reals. I'm not sure if there is one for complexes. at least I don't recall it when learning complex analysis
10:07:43 <FreeFull> monoidal: Shouldn't complexes have an infinite number of infinities
10:07:43 <Cale> and similarly, it gets us rational powers easily enough, because a^(1/n) * ... * a^(1/n) repeated n times ought to be a^(1/n + ... + 1/n) = a^1 = a
10:08:02 <Cale> and this algebraically forces that to be an nth root.
10:08:05 <quchen> monoidal: The Riemann sphere is quite useful in proofs, "epsilon neighbourhood around infinity" etc.
10:08:15 <monoidal> for example, 1/x is usually extended to 1/0 = infinity
10:08:16 * Eduard_Munteanu ponders extended complex numbers (C + infinities)
10:08:31 <nebnesknarf> monoidal: there is a on-point compactification and it means rolling up the complex plane to a sphere
10:08:37 <quchen> monoidal: It also makes sense of the awkward formula for residues at infinity.
10:08:45 <quchen> ... to give an example
10:08:51 <klrr> i dont understand, ive tried writing many programs in haskell but everything is soo difficult i cant figure out how the programs should work, and when i do i get stuck with some difficult library or other things, can someone suggest a program that i can write?
10:08:59 <monoidal> quchen: but that's the one-point compactification, right?
10:09:04 <quchen> Yes
10:09:32 <monoidal> quchen: I don't know any other snsible one
10:10:03 <Cale> So if we want to continue using this property as a guide, we're looking for a function f such that f(x+y) = f(x) f(y) for all real numbers x and y. One way to approach the construction is to try to solve a more specific problem -- to try to find a differentiable such f.
10:10:14 <NihilistDandy> klrr: Write cat
10:10:28 <lambdabot> NihilistDandy: You have 1 new message. '/msg lambdabot @messages' to read it.
10:10:31 <Cale> Were such an f to exist, we'd have:
10:10:32 <Eduard_Munteanu> Cale: if you do the exp(y * ln x) trick, I guess you can write it as a series?
10:10:35 <nebnesknarf> I could of course cite the stone-cech compactification (which always exists for locally compact spaces) but it is seldom useful in practice
10:10:38 <Jaxan> quchen: stone-ceche compactification :)?
10:10:43 <Cale> Eduard_Munteanu: well, I'm working my way up to that :)
10:10:50 <Eduard_Munteanu> Ah, ok. :)
10:11:00 <Cale> f'(x) = limit as h -> 0 of (f(x+h) - f(x)) / h
10:11:13 <Cale> but then we have f(x+h) = f(x) f(h)
10:11:31 <Jaxan> Cale: the zero function ;D?
10:11:46 <nebnesknarf> Jaxan: it's a horrible thing that blows up the space to a huge monster where /every/ bounded sequence has a limit; hard to imagine ;-)
10:11:58 <monoidal> well yes, stone-cech might have some justification (though it should be equivalent to B(R^2) and complex structure seems irrevelant)
10:11:59 <Cale> Jaxan: That is a solution here, but obviously we're especially interested in nonzero ones :)
10:12:00 <klrr> NihilistDandy: "main = getContents >>= putStrLn"
10:12:05 <Cale> and so this would be equal to the limit as h -> 0 of (f(x)f(h) - f(x)) / h
10:12:05 <klrr> NihilistDandy: any other suggestion?
10:12:14 <quchen> klrr: cat takes multiple arguments as well
10:12:24 <Cale> and then this is f(x) * limit as h -> 0 of (f(h) - 1) / h
10:12:41 <quchen> klrr: Look at the manpage and you'll find all its options :-)
10:12:52 <Jaxan> nebnesknarf: it's the initial object of the category of T2 compacitifications (of a given space), awesome right?
10:12:55 <klrr> quchen: i know, but i wont learn from implementing a extremely simple program, i need something that i can learn from qhile still being able to write it before getting depressed
10:12:57 <Gilly> Cale: and here is where you want f(x) != 0
10:13:08 <Cale> yes :)
10:13:10 <nebnesknarf> monoidal: what is B(R^2)?
10:13:18 <klrr> quchen: also original cat didnt have arguments, so mine is totally valid in terms of unix
10:13:19 <NihilistDandy> klrr: You can learn a lot from implementing cat
10:13:20 <monoidal> nebnesknarf: Beta(R^2), Stone-Cech of B^2
10:13:25 <monoidal> nebnesknarf: * of R^2
10:13:27 <nebnesknarf> Jaxan: I wouldn't know about that ...
10:13:34 <hiptobecubic> Is there a better switch-like idiom than case () of _ | pred1 -> ... | pred2 -> ...   ?
10:13:47 <quchen> hiptobecubic: MultiwayIf?
10:13:51 <klrr> NihilistDandy: i can?
10:13:55 <FreeFull> Cale: How about f(x) = 1
10:14:19 <hiptobecubic> quchen, go on?
10:14:27 <Cale> FreeFull: well, that will be yet another solution :)
10:14:34 <NihilistDandy> klrr: Take the cat one-liner and add the functionality of the -b flag
10:14:36 <nebnesknarf> monoidal: well, yes; ah, I see what you mean, it is unclear what happens with the multiplication
10:14:45 <NihilistDandy> Then just keep adding things until you're done
10:14:50 <Cale> We'd expect 1^x to often times be 1
10:14:55 <nebnesknarf> maybe stone-cech is really not useful for the complex number; probably
10:14:58 <NihilistDandy> Use the pipes library if you want to have more fun :D
10:15:07 <quchen> hiptobecubic: It's a GHC extension: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#multi-way-if
10:15:16 <quchen> hiptobecubic: Pretty much what you were asking for
10:15:20 <Jaxan> nebnesknarf: I have no idea, I only know that it is indeed a beast :P
10:15:23 <hiptobecubic> quchen, aha
10:15:34 <Gilly> In fact you could also notice that if f(x) != 0 for all x, then you can define g(x) = log f(x), which satisfies the Cauchy equation g(x+y) = g(x) + g(y). Here if I recall correctly, continuity implies that g(x) = cx for some constant c.
10:15:51 <Gilly> But I
10:16:01 <hiptobecubic> quchen, when did they appear? Is it safe to assume they are available?
10:16:02 <Gilly> 'm not sure what you are doing :) probably you don't have log in your disposal.
10:16:32 <monoidal> nebnesknarf: since R^2 and C are homeomorphic, Beta(R^2) and Beta(C) are too; there might be a way to extend multiplication from C*C -> C to Beta(C)*Beta(C) -> Beta(C). in any case, I'm not convinced yet it should be useful in any way.
10:16:40 <quchen> hiptobecubic: They're proposed for Haskell prime, they are very useful (getting rid of the dummy case expressions) and everyone seems to like them. I think they're safe to use.
10:17:00 <Cale> Gilly: I'm approaching the definition of exp starting from the principles that we're interested in the properties of differentiable functions f such that f(x+y) = f(x)f(y)
10:17:05 <hiptobecubic> quchen, good enough for me :)
10:17:33 <quchen> hiptobecubic: Worst case is that one day they're ruled out and the compiler will complain about syntax errors that are easy to fix by reverting to the case notation
10:17:36 <Cale> based on generalising the idea that worked so well when generalising the notion of exponentiation to a natural power to integer and rational exponents
10:17:43 <quchen> hiptobecubic: I don't think that's going to happen though
10:17:49 <FreeFull> Cale: Ok, both f(x) = a^x for any a should work
10:17:52 <quchen> hiptobecubic: same for LambdaCase
10:18:01 <Gilly> I see. :)
10:18:06 <monoidal> (btw has anyone implemented a complex analysis library for haskell? for example, holomorphic functions might be remembered lazily using their series expansion. I'm not sure what utilities it might have.)
10:18:07 <Cale> FreeFull: But the goal is to define what a^x means when x is a real number
10:18:23 <Cale> FreeFull: So, that would be a little bit circular :)
10:18:23 <nebnesknarf> I think it is not possible to extend the multiplication from C to B(C) such that the result is again a field; i remember that there is some theorem that C is 'maximal' among all algrebras
10:18:36 <hiptobecubic> quchen, when were these introduced?
10:18:46 <quchen> hiptobecubic: I don't know
10:19:15 <FreeFull> Cale: Hmm, the recursive definition would work only for integers
10:19:15 <nebnesknarf> I meant: maximal and still be a proper field
10:19:38 <hiptobecubic> not 7.4 apparently
10:19:50 <monoidal> nebnesknarf: C is a proper subfield of C(x). but I also think there's no sensible field for Beta(C).
10:19:59 <quchen> hiptobecubic: Yeah I just manually searched the GHC manuals, seems to be a 7.6 addition
10:20:09 <hiptobecubic> quchen, fair enough
10:20:10 <Cale> Note that we have that f(y) = f(0+y) = f(0) f(y), and so as long as f isn't 0 everywhere, we really must have f(0) = 1
10:20:21 <monoidal> multiwayif is new in 7.6
10:20:22 <quchen> hiptobecubic: Wait for the new platform? :-)
10:20:37 <hiptobecubic> quchen, I'd like to write programs before then :)
10:21:08 <monoidal> you can define cond :: [(a, Bool)] -> a to simulate multi-way if.
10:21:30 <Cale> and so f'(0) = limit as h -> 0 of (f(0+h) - f(0)) / h = limit as h -> 0 of (f(h) - 1) / h
10:21:47 <Gilly> As an aside, in fact all continuous solutions are of the form f(x) = 0 or f(x) = a^x for a > 0.
10:21:48 <nebnesknarf> monoidal: I remember now that the theorem is: you cannot extend C to something that is larger and that is still a field /and/ a normed complete vector space.
10:21:52 <FreeFull> monoidal: Doesn't it make more sense to use guards though
10:21:52 <quchen> hiptobecubic: #define
10:21:55 <quchen> hiptobecubic: :-D
10:22:04 <monoidal> FreeFull: you can't use them inside expressions.
10:22:08 <quchen> (That was a joke, don't hang me)
10:22:11 <hiptobecubic> hehe
10:22:20 <Cale> and so to continue from where we got to before, we had:  f'(x) = f(x) * limit as h -> 0 of (f(h) - 1) / h
10:22:21 <monoidal> FreeFull: but personally I am not fully convinced that multi-way if is a good addition to language
10:22:32 <Cale> and we see that this is f'(x) = f(x) f'(0)
10:22:44 <monoidal> FreeFull: since we can define a "cond" function and have essentially same thing with built-in syntax.
10:22:47 <Cale> Well, this hasn't quite got us anywhere yet
10:23:08 <quchen> hiptobecubic: In that case, use the normal "case _" way of writing things, maybe HLint will throw warnings some day about it so you can change it
10:23:08 <FreeFull> > let x y | y == 3 = 1 | y == 0 = 0 | otherwise = 3 in x 3
10:23:10 <lambdabot>   1
10:23:23 <Cale> But let's just name f'(0) = a
10:23:23 <FreeFull> There, an expression with guards
10:24:09 <Cale> and consider the derivative of the inverse function, supposing that exists:
10:24:40 <Cale> (f^-1)'(x) = 1/(f'(f^-1(x))) -- generally
10:25:00 <Cale> but then we know that f'(x) = a f(x)
10:25:21 * hackagebot git-annex 4.20130501 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-4.20130501 (JoeyHess)
10:25:22 <Cale> So (f^-1)'(x) = 1/(a f(f^-1(x))) = 1/(ax)
10:25:54 <monoidal> FreeFull: it's toplevel. Try to write x = map (\t -> if a then b else c) using multi-way if and without introducting an extra "where".
10:26:13 <FreeFull> monoidal: That wasn't top level. See the in?
10:26:44 <monoidal> FreeFull: ah, yes, you can introduce an auxiliary if
10:26:49 <monoidal> *auxiliary let-in
10:26:53 <Cale> That's about as simple a derivative as we could hope for, and knowing this, we can construct such a function using the fundamental theorem of Calculus and integrating.
10:27:02 <klrr> NihilistDandy: i cant :x should i kill myself or learn another language which is better to think in?
10:27:13 <monoidal> FreeFull: it's a question of style
10:27:16 <Cale> Of course, if we wanted to define, say, 10^x, we don't know what number a should be
10:27:31 <FreeFull> let x = map (\t -> let x t | t == 3 = 0 | otherwise = 1 in x t) in x [1,2,3,4,5]
10:27:34 <FreeFull> > let x = map (\t -> let x t | t == 3 = 0 | otherwise = 1 in x t) in x [1,2,3,4,5]
10:27:38 <lambdabot>   mueval-core: Time limit exceeded
10:27:41 <Cale> But we can just choose a = 1, and hope to get a logarithm function to *some* base
10:27:51 <nebnesknarf> klrr: give yourself some time, I know it took me several tries to get the hang of it
10:27:53 <FreeFull> Cale: And then we get e^x
10:27:55 <NihilistDandy> klrr: You certainly can do. Just think about what you need to do, then ask when you have questios
10:27:58 <NihilistDandy> *questions
10:28:14 <FreeFull> > let x = map (\t -> let x t | t == 3 = 0 | otherwise = 1 in x t) in x [1,2,3,4,5]
10:28:16 <Cale> FreeFull: Or, we get the natural logarithm first, but yes
10:28:16 <lambdabot>   [1,1,0,1,1]
10:28:27 <quchen> klrr: Killing yourself isn't beneficial to your Haskell learning process. We as a Haskell channel do not recommend it for that reason.
10:28:42 <klrr> okey
10:28:44 <Cale> We can define for x > 0, the function log x = integral from 1 to x of 1/t dt
10:29:16 <quchen> klrr: I think a good timeframe to become somewhat comfortable in a new thing is a year. Stay interested and give yourself some time.
10:29:59 <nebnesknarf> Cale: I tried to scoll up to find out what you are proving but I can't find it
10:30:12 <Cale> I'm telling a mathematical story :)
10:30:16 <quchen> klrr: Maybe try writing a small chat program? Setting up a server, sending messages etc?
10:30:20 <smithw> ok, now I feel proud, I got an "the impossible happened" error writing would-be-serious code.
10:30:35 <FreeFull> smithw: What error is it?
10:30:42 <klrr> quchen: i did that :D
10:30:43 <nebnesknarf> Cale: about what (just interested)?
10:30:44 <quchen> klrr: You can then make that more complicated by adding HTTP headers, the long time goal could be a minimal HTTP server
10:31:06 <hiptobecubic> klrr, it took me a long time and several restarts before I could write anything fun. Don't kill yourself yet
10:31:18 <Cale> nebnesknarf: About how we can naturally set out to define raising a positive number to a real power
10:31:18 <klrr> quchen: https://gist.github.com/klrr/5445037
10:31:19 <smithw> FreeFull, I don't know for sure since the message is so cryptic, but it seems related to GADT
10:31:24 <Cale> and come to some conclusions about it
10:31:32 <quchen> klrr: Write a Scheme interpreter (side effect: you'll learn Scheme syntax), there's a tutorial for that even
10:31:40 <klrr> well ive tried learning programming several times
10:31:46 <Cale> defining the natural logarithm and exponential map along the way :)
10:31:49 <klrr> quchen: did that, but macros and continuation is too complicated
10:32:00 <Cale> I don't know how many people are following it though :)
10:32:25 <NihilistDandy> klrr: Then you're better than most professional PHP programmers
10:32:32 <quchen> klrr: My first real program was one that formats a tab-separated file nicely, so don't worry, no matter how dumb your program is it'll beat mine :-)
10:33:02 <nebnesknarf> quchen: yea that is a good exercise, did that myself and it helped me alot to get off the ground; i think it's called "write yourself a scheme in 48 hours" or so
10:33:17 <hiptobecubic> :t forever -- klrr
10:33:18 <lambdabot> Monad m => m a -> m b
10:33:41 <klrr> well ill first do that cat -b program
10:33:57 <hiptobecubic> forever $ do msg <- hGetline h....
10:34:01 <klrr> even if it's against the unix philosphy, it should be done with cat and sed :P
10:34:02 <FreeFull> forever x = x >> forever x    I think
10:34:08 <typoclass> klrr: the outcome of exercises is not really the solution to the exercise, the outcome is that you now have a better understanding than before you did the exercise. so i wouldn't worry about "how dumb" a program is
10:34:20 <newsham> > do { Void <- forever (readFile "foo") }
10:34:22 <lambdabot>   The last statement in a 'do' block must be an expression
10:34:22 <lambdabot>    Void <- forever...
10:34:37 <newsham> > do { Void <- forever (readFile "foo"); return "done" }
10:34:39 <lambdabot>   Not in scope: data constructor `Void'
10:34:45 <monoidal> FreeFull: the defn was recently changed to forever x = let a =  x >> a in a, this has smaller memory usage, but other than that, yes
10:35:01 <hiptobecubic> monoidal, why?
10:35:06 <hiptobecubic> monoidal, is the mem usage smaller, i mean
10:35:29 <quchen> klrr: In your client, you're never closing the connection. Do you know about 'bracket'?
10:35:33 <monoidal> hiptobecubic: similar reason to fix f = f (fix f) vs fix f = let x = f x in x
10:36:26 <aristid> klrr: cat and sed? why not just sed?
10:36:45 <ryant5000> has anyone seen panics when using GHC.Generics and {-# SOURCE #-} imports?
10:36:51 <nebnesknarf> newsham: "SomethingInUppercase <- ..." is usually bad, since upper case means constructor, but you want a variable
10:37:02 <hiptobecubic> monoidal, I don't know why we did that either.
10:37:02 <newsham> no, I dont want a variable.
10:37:06 <monoidal> klrr: did you fix the panic? I can't reproduce it on your git.
10:37:31 <newsham> http://hackage.haskell.org/packages/archive/void/0.5.1/doc/html/Data-Void.html
10:37:35 <nebnesknarf> newsham: what else do you want (I mean to the left of the <-)
10:37:46 <typoclass> nebnesknarf: sometimes you need "Just x <- anActionThatGivesAMaybe". but yeah, i don't know what Void is
10:38:00 <hpaste> smithw pasted “impossible” at http://hpaste.org/87014
10:38:03 <monoidal> hiptobecubic: consider fix (0:). first definition will give a list 0:0:0:.. where each 0 has a different spot in memory. second will give let x = 0:x, so the 0 cell will point to itself
10:38:03 <newsham> nebnesknarf: a constructor to match against
10:38:17 <newsham> ie:   (Just x) <- mightGetSomething
10:38:18 <FreeFull> monoidal: Oh, sharing
10:38:22 <nebnesknarf> newsham: I see; use ()
10:38:25 <smithw> FreeFull, that's the error I got. do you want to see the code too?
10:38:32 <monoidal> smithw: can you paste the code?
10:38:40 <newsham> nebnesknarf: no need for parens, there's no argument to Void
10:38:40 <FreeFull> smithw: Why not
10:38:41 <hiptobecubic> monoidal, aha
10:38:48 <hiptobecubic> :t catMaybes
10:38:49 <lambdabot> [Maybe a] -> [a]
10:39:08 <smithw> monoidal, FreeFull, it's a bit long and split into two files, but I'll do it
10:39:18 <typoclass> newsham: he may have meant "() <- readFile ..."
10:39:27 <klrr> quchen: not really, the one on gist may not work but i got a working copy on my harddrive somewhere
10:39:31 <hiptobecubic> has `head . catMaybes` been invented alread? :)
10:39:38 <hiptobecubic> already*
10:39:50 <typoclass> hiptobecubic: listToMaybe i think. goofy name though
10:39:54 <nebnesknarf> newsham: why do you want to match against Void?
10:40:02 <dmwit> hiptobecubic: mconcat
10:40:09 <hiptobecubic> dmwit, aha yes
10:40:09 <dmwit> hiptobecubic: may need mconcat . map First
10:40:32 <dmwit> :t ala First
10:40:36 <lambdabot> ((Maybe a -> First a) -> e -> First a) -> e -> Maybe a
10:40:45 <quchen> klrr: The point isn't whether it works or not. Using bracket by default is good practice in general: it makes sure that a function is always called in the end no matter what. That applies to reading files, opening network sockets etc.
10:40:46 <monoidal> smithw: if you use DataKinds, it might be http://hackage.haskell.org/trac/ghc/ticket/7070. if you paste your code, i can test it in 7.6 and head.
10:40:50 <nebnesknarf> newsham: I have not looked it up but isn't Void supposed to have /no/ constructors, so undefined is the only value of that type?
10:40:59 <hiptobecubic> dmwit, ah no. this is different.
10:41:01 <dmwit> :t ala First (const mconcat)
10:41:04 <lambdabot> [First a] -> Maybe a
10:41:10 <typoclass> hiptobecubic: i was wrong by the way :-x
10:41:21 <FreeFull> smithw: 7.4.2 is a bit old
10:41:28 <dmwit> hiptobecubic: Different how?
10:41:41 <dmwit> Also, I clearly don't understand how to use ala.
10:41:49 <hpaste> smithw pasted “impossible - part 2: the source” at http://hpaste.org/87016
10:41:59 <klrr> quchen: okey, ill hoogle it and add it
10:42:04 <hiptobecubic> :t mconcat
10:42:06 <nebnesknarf> :t ala
10:42:09 <lambdabot> Monoid a => [a] -> a
10:42:10 <lambdabot> Wrapped s s a a => (s -> a) -> ((s -> a) -> e -> a) -> e -> s
10:42:17 <dmwit> :t ala First ((mconcat .) . map)
10:42:19 <lambdabot> [Maybe a] -> Maybe a
10:42:20 <quchen> klrr: `bracket` takes three actions: what to do in the beginning, in the end, and in between. A common pattern is "bracket openSomething closeSomething $ \h -> (do something with the handle)
10:42:25 <dmwit> There we go.
10:42:28 <hiptobecubic> dmwit, that looks better
10:42:35 <dmwit> But that's not obviously better than map getFirst . mconcat . map First
10:42:36 <smithw> FreeFull, monoidal, I'm using whatever came with ubuntu 12.10. I tried upgrading to 13.04 but it broke my video card, I was happy to be able to downgrade :/
10:42:37 <hiptobecubic> whta is First?
10:42:47 <hiptobecubic> what*
10:42:58 <dmwit> > First (Just 3) `mappend` First (Just 4)
10:43:00 <lambdabot>   First {getFirst = Just 3}
10:43:03 <FreeFull> @info First
10:43:03 <lambdabot> First
10:43:04 <klrr> User_: oh it seems very handy
10:43:07 <hiptobecubic> the platform is still at 7.4.2
10:43:11 <klrr> quchen: oh it seems very handy
10:43:12 <quchen> klrr: It basically makes sure the ressource is deallocated correctly. The hard way of doing this is adding the "close" function to the end of each block manually, which most of us forget in half of all cases. :-)
10:43:14 <geekosaur> FreeFull, there is no @info
10:43:20 <hiptobecubic> dmwit, ohhhh it's a monoid instance
10:43:24 <hiptobecubic> yes looks good
10:43:31 <nebnesknarf> I remember 'ala' from Conor McBride's papers and that that was the point where no longer understood anything :-\
10:43:37 <klrr> quchen: may i ask a quick type error question?
10:43:45 <monoidal> smithw: your code compiles fine in 7.6
10:43:47 <dmwit> :t foldMap
10:43:49 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
10:44:09 <dmwit> :t ala First foldMap
10:44:11 <lambdabot> Foldable t => t (Maybe a) -> Maybe a
10:44:12 <klrr> why doesn't this work https://gist.github.com/klrr/5496861 ? it seems totally logical to me :/
10:44:16 <smithw> monoidal, well, good to know... is there a ppa to use the most recent haskell platform on ubuntu?
10:44:17 <dmwit> much better
10:44:27 <dmwit> hiptobecubic: ala First foldMap =)
10:44:56 <monoidal> smithw: but HEAD gives a compile error
10:45:07 <geekosaur> klrr, (:) in String expects a Char on the left
10:45:15 <geekosaur> you have a String; use (++) instead
10:45:22 <hiptobecubic> :t ala
10:45:23 <klrr> oh okey thanks!
10:45:25 <lambdabot> Wrapped s s a a => (s -> a) -> ((s -> a) -> e -> a) -> e -> s
10:45:26 <typoclass> > getFirst $ foldMap First [Nothing, Just 3, Just 4]
10:45:29 <lambdabot>   Just 3
10:45:33 <smithw> monoidal, another panic or a mistake I made? on HEAD, I mean
10:45:45 <dmwit> > ala First foldMap [Nothing, Just 3, Just 4]
10:45:49 <lambdabot>   mueval-core: Time limit exceeded
10:45:50 <hpaste> monoidal annotated “impossible - part 2: the source” with “impossible - part 2: the source (annotation)” at http://hpaste.org/87016#a87017
10:45:52 <dmwit> > ala First foldMap [Nothing, Just 3, Just 4]
10:45:58 <lambdabot>   Just 3
10:46:01 <FreeFull> klrr: ("\n" ++ show x ++ " ") : (addNumbers (x + 1) ys)  is a [String] and not a String
10:46:02 <geekosaur> :t "\n" : ??s
10:46:03 <lambdabot> parse error on input `??'
10:46:06 <monoidal> smithw: I annotated with error when compiling using HEAD http://hpaste.org/87016
10:46:15 <hiptobecubic> dmwit, how does it getFirst?
10:46:25 <geekosaur> :t "\n" : ?s
10:46:26 <dmwit> hiptobecubic: There's a type class that maps First to getFirst.
10:46:28 <lambdabot> (?s::[[Char]]) => [[Char]]
10:46:31 <newsham> nebn: good point.. Void is the type not the constructor.
10:46:32 <FreeFull> Oh, geekosaur already said it
10:46:36 <hiptobecubic> dmwit, or does it keep a pointer to the unmodified list
10:46:38 <hiptobecubic> dmwit, oh
10:46:44 <FreeFull> Hey, lambdabot does holes
10:46:49 <newsham> so my example isnt what i wanted
10:46:55 <geekosaur> not exatcly. that's an implicit parameter
10:47:03 <geekosaur> which works for some kinds of 'holes' and not others
10:47:15 <monoidal> smithw: and let me add that HEAD got many things fixed when it comes to this typechecking area, so it's probably correct
10:47:20 <geekosaur> (in particular, GHC holes are type level, implicit parameters are value level)
10:47:34 <klrr> NihilistDandy: https://gist.github.com/klrr/5496861 cat -b :)
10:47:40 <hiptobecubic> where is ala defined?
10:47:46 <dmwit> ?hackage newtype
10:47:50 <lambdabot> http://hackage.haskell.org/package/newtype
10:47:51 <hiptobecubic> lens i guess
10:47:54 <newsham> :t 'b':?c:'c':'k':'e':'t':[]
10:47:55 <dmwit> nope
10:47:56 <lambdabot>     Not in scope: data constructor `:?'
10:47:56 <lambdabot>     Perhaps you meant one of these:
10:47:56 <lambdabot>       `:+' (imported from Data.Complex),
10:48:05 <simpson> `ala` is from Data.Monoid, isn't it?
10:48:06 <newsham> :t 'b': ?c :'c':'k':'e':'t':[]
10:48:07 <lambdabot> (?c::Char) => [Char]
10:48:17 <dmwit> simpson: still nope
10:48:20 <smithw> monoidal, I haven't got the slightest idea on how to start debugging this... I had no idea my code had so many bugs
10:48:21 <newsham> there's a hole int he bucket
10:48:23 <quchen> klrr: Printf would probably makes this a little nicer even
10:48:33 <geekosaur> would have worked with parens
10:48:50 <geekosaur> :t 'b':(?c):'c':'k':'e':'t':[]
10:48:52 <lambdabot> (?c::Char) => [Char]
10:48:52 <simpson> dmwit: Well, Hoogle doesn't know, so I give up. :3
10:48:56 <newsham> > do { (x :: Void) <- forever (readFile "foo"); return "done" }
10:48:59 <lambdabot>   Not in scope: type constructor or class `Void'
10:48:59 <dmwit> simpson: I already answered the question!
10:49:08 <klrr> quchen: https://gist.github.com/klrr/5496861 now it's a bit nicer i think
10:49:08 <simpson> Ooooh. I see.
10:49:10 <nebnesknarf> newsham: i remember very well being confused by the data vs. type constructor thing, especially since both are upper case and often the data constructor has the same name as the type constructor
10:49:25 <klrr> quchen: forgot that functions could be partial applied/curried
10:49:39 <monoidal> smithw: it's probably the same issue everywhere. let me read it.
10:50:06 <arkeet> hmm
10:50:06 <nebnesknarf> :i Void
10:50:22 * hackagebot bibtex 0.1.0.2 - Parse, format and processing BibTeX files  http://hackage.haskell.org/package/bibtex-0.1.0.2 (HenningThielemann)
10:50:26 <arkeet> if you mix up a type constructor with a data constructor, it's not a type error or a kind error, so what do you call it?
10:50:27 <geekosaur> no :i in lambdabot either
10:50:40 <nebnesknarf> geekosaur: too bad
10:50:44 <newsham> arkeet: syntax error? :)
10:50:53 <typoclass> nebnesknarf: Void is from the package that newsham linked a few minutes ago
10:51:11 <newsham> "data Void"
10:51:13 <arkeet> no, it can't be a syntax error.
10:51:19 <klrr> which is most easy / simple web framework for haskell?
10:51:21 <nebnesknarf> typoclass: I know, I just thought ti might be useful to see information about it
10:51:50 <typoclass> nebnesknarf: ok :-)
10:51:54 <quchen> klrr: I've added another version as a comment to your gist.
10:52:01 <dmwit> klrr: http://www.haskell.org/haskellwiki/Web/Frameworks
10:52:14 <klrr> dmwit: looking there now quchen: will check
10:52:46 <dmwit> arkeet: level error
10:52:57 <dmwit> arkeet: Though GHC will call it a scoping error. =)
10:53:04 <arkeet> mhm
10:53:31 <benzrf> hello!
10:53:49 <benzrf> the wikipedia page on monads has a bit that I find rather perplexing
10:53:54 <benzrf> http://en.wikipedia.org/wiki/Monad_%28functional_programming%29#Monad_laws
10:54:07 <david1991> I have a small question, is there a good PHP parser to an abstract syntax tree on Hackage or one that someone can recommend?
10:54:08 <nebnesknarf> typoclass: I am still new to this channel and lambdabot, trying to figure out what works and what doesn't; is there a quick reference somewhere?
10:54:24 <dmwit> ?list
10:54:24 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:54:27 <quchen> klrr: In any case, you could recreate cat as a whole, not just "cat -b" in one program. Like add a command line argument parser and all that.
10:54:45 <benzrf> @src <<
10:54:45 <sclv_> nebnesknarf: lots of that stuff is somewhat outdated and odd
10:54:45 <lambdabot> Source not found. Wrong!  You cheating scum!
10:54:50 <benzrf> O:
10:54:50 <byorgey> david1991: I know that Facebook has a PHP parser written in Haskell, but I don't know if it's open source
10:54:51 <benzrf> @src ??
10:54:52 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
10:54:53 <FreeFull> benzrf: What do you find perplexing?
10:54:56 <benzrf> @src >>
10:54:56 <lambdabot> m >> k      = m >>= \_ -> k
10:54:58 <typoclass> nebnesknarf: you can play around after you do "/query lambdabot". i don't know about any good explanations. best bet is try it in here and wait until people correct you :-)
10:55:02 <sclv_> also remember to play with it in privmsg, not on the channel
10:55:06 <nebnesknarf> dmwit: thx
10:55:07 <hiptobecubic> What about this?  multiIf :: [(Bool, a)] -> a -> a;  multiIf [] = id;  multiIf ((p,x):xs) = if p then const x else multiIf xs
10:55:14 <klrr> quchen: clever solution, even though i think mine is easier to understand
10:55:14 <benzrf> FreeFull: doesn't the first rule listed about return being identity nnot hold in a great deal of cases?
10:55:31 <benzrf> oh wait, it said 'approximately'
10:55:32 <david1991> Oh icic, but the Facebook PHP parser does not have any documentation :(
10:55:33 <dmwit> :t find fst
10:55:34 <benzrf> never mind >_>
10:55:37 <monoidal> smithw: j11 are vectors of Doubles, right?
10:55:41 <lambdabot> [(Bool, b)] -> Maybe (Bool, b)
10:55:45 <monoidal> smithw: if so, you shouldn't use ^ for exponentation
10:55:46 <dmwit> hiptobecubic: ?
10:55:57 <hiptobecubic> hm
10:56:00 <hiptobecubic> :t find
10:56:06 <lambdabot> (a -> Bool) -> [a] -> Maybe a
10:56:09 <sclv_> the facebook parser is the only one i know of
10:56:09 <smithw> monoidal, (**) then?
10:56:13 <FreeFull> benzrf: Wait, can you give an example where it wouldn't hold?
10:56:34 <benzrf> FreeFull: Nothing >>= \foo -> foo + 1
10:56:38 <quchen> klrr: Yours has a space leak due to the "+1", and the parameter isn't really necessary in the first place. zip [0..] is quite common to number a list
10:56:45 <dmwit> benzrf: Nothing is not return x for any x.
10:56:54 <nebnesknarf> sclv: how do i do that?
10:56:57 <benzrf> no wait
10:56:59 <hiptobecubic> dmwit, I suppose, although I think it's more awkward to use.
10:57:04 <benzrf> hold on
10:57:04 <smithw> monoidal, ... and now it compiles on 7.4 also
10:57:10 <sclv_> nebnesknarf: /msg lambabot @bot
10:57:17 <dmwit> hiptobecubic: So munge it. multiIf = snd . fromJust . find fst
10:57:21 <benzrf> crap, I forgot
10:57:24 <dmwit> hiptobecubic: I'm just saying don't write it manually.
10:57:38 <smithw> ... or not
10:57:50 <klrr> quchen: in your scheme, have you implemented continuation or macros yet? i would like to understand how even though i might not be able to incorperate it into my own? (answer to your statement: yes mine has flaws i just meant in general but im no real programmer so i cant say much)
10:57:55 <benzrf> Nothing >>= (\foo -> Just $ foo + 1)
10:57:58 <dmwit> hiptobecubic: Though I would encourage you to Not Do That. =)
10:58:03 <typoclass> david1991: i think facebook has done some work lately on using haskell to process their sizable php code base. but who knows if they open-sourced it
10:58:06 <hiptobecubic> dmwit, sure. Although that way is pretty unsafe looking
10:58:07 <dmwit> hiptobecubic: [(a,Bool)] -> [a] is a much saner type. =)
10:58:16 <benzrf> dmwit: that's true
10:58:16 <dmwit> hiptobecubic: Your way was just as unsafe, no?
10:58:26 <hiptobecubic> dmwit, how so? It can't fail.
10:58:30 <dmwit> hiptobecubic: Oh! I misread your implementation.
10:58:33 <dmwit> Let me try again. =)
10:58:35 <monoidal> smithw: it also compiles on HEAD once you add type signatures for j11, j12, j21, j22, f1, f2
10:58:41 <benzrf> but my example would be true for a type you created that filters by if the wrapped value is 0 instead of Nothing
10:58:48 <hiptobecubic> multif [some tuples] defaultvalue
10:58:50 <benzrf> then return 0 would give you a monad that  bypasses the function application
10:59:06 <dmwit> :t \x -> maybe x snd . find fst
10:59:07 <lambdabot> c -> [(Bool, c)] -> c
10:59:23 <smithw> monoidal, not on 7.4, though
10:59:31 <FreeFull> benzrf: I don't think that would be a monad
10:59:36 <dmwit> :t maybe id (const . snd) . find fst
10:59:37 <lambdabot> [(Bool, a)] -> a -> a
10:59:49 <hiptobecubic> dmwit, FINE !  :D
10:59:49 <FreeFull> benzrf: Especially since it'd require a Num and Eq constraint
11:00:07 <benzrf> whatever man
11:00:14 <hiptobecubic> dmwit, although that seems way less readable. Maybe i'm just too green
11:00:20 <benzrf> anything that implements return and bind is a monad though, right?
11:00:29 <hiptobecubic> benzrf, the laws!
11:00:30 <FreeFull> klrr: I thought macros were just functions that work on functions. It might be trickier than that though
11:00:31 <dmwit> benzrf: No. It's only a monad if it satisfies the laws.
11:00:32 <elliomax> Hello! Has anyone here ever done something like a parFilter?
11:00:32 <monoidal> smithw: also you get a lot of "inexhausitive patterns" errors. this is because the inexhaustivity checking is generally in a very sad state in GHC, and nobody moved it.
11:00:49 <monoidal> smithw: j11, .., f2 :: Vec T2 Double -> Double does not work?
11:00:55 <benzrf> pooh
11:01:02 <dmwit> benzrf: (Although it's a Monad just as soon as you write "instance Monad"... even if you don't implement (>>=) and return!)
11:01:19 <benzrf> ok
11:01:32 <simpson> benzrf: Are you currently stumped on writing a Monad instance for a custom type?
11:01:33 <simpson> ...Oh.
11:01:55 <dmwit> hiptobecubic: Sure. If I were going to write it in code I might write:
11:02:11 <klrr> FreeFull: macros takes an unevaluated expression and transform it into code that can be evaluated, so for example you can implement a macro that evaluates (2 + 2) even if everthing else uses nnormal s-expression syntax, this requires them to have access to the parser wihtin the implementation this is the tricky part
11:02:13 <dmwit> :t \xs def -> head $ [x | (True, x) <- xs] ++ [def]
11:02:14 <lambdabot> [(Bool, a)] -> a -> a
11:02:20 <klrr> FreeFull: that's what i think it is at least
11:02:37 <dmwit> That's the readable way. But it's not very compositional.
11:02:39 <monoidal> smithw: btw 7.6.3 compiles both when the signature is given and is missing
11:02:48 <smithw> monoidal, those inexhaustive patterns errors are then my fault or ghc's? and nope, nothing works on 7.4, I'm searching for 7.6 sources right now
11:03:00 <hiptobecubic> dmwit, what do you mean?
11:03:01 <monoidal> smithw: ghc's
11:03:12 <dmwit> hiptobecubic: I mean it doesn't have very many reusable subexpressions.
11:03:20 <hiptobecubic> ah, ok sure
11:03:34 <monoidal> smithw: you can ignore them. I think you don't need sources for 7.6, only the binaries
11:03:35 <FreeFull> klrr: Don't you make the whole program into a big S-expression and then eval it? I think macros would simply work on it before it's evalled
11:03:52 <monoidal> smithw: http://www.haskell.org/ghc/download_ghc_7_6_3
11:04:14 <elliomax> Has anyone here used parMap before?
11:04:19 <smithw> monoidal, thanks, I had just found, downloading now. thank you very much for all you attention and help
11:04:30 <monoidal> no problem.
11:04:41 <dmwit> elliomax: Do you have a specific question about parMap?
11:04:46 <quchen> klrr: Nah, I lost interestin the Scheme interpreter after some time
11:04:47 <klrr> FreeFull: i dont know im not very smart, but in the future if ive got more iq ill try write a scheme again
11:05:05 <dmwit> elliomax: Also, the problem with parFilter is that it's not very common to have an expensive enough predicate to make it worthwhile.
11:05:19 <elliomax> dmwit: how about factors?
11:05:32 <dmwit> I don't understand the question. Can you expand it a bit?
11:06:07 <FreeFull> klrr: Say, instead of using macros you could write all your functions as  '(something) and then run that through a function (your macro) before evalling
11:06:18 <elliomax> dmwit: I am going after pretty large numbers and trying to get factors
11:06:41 <klrr> FreeFull: maybe i dont know, i always get type errors i cant solve anyway :x
11:07:50 <FreeFull> klrr: I mean, it would be done on the Scheme side rather than on the Haskell side
11:08:18 <klrr> FreeFull: you mean i can implement macros on the scheme side? :DDDDDDDDDDDDDDDDDDD
11:08:41 <FreeFull> Depends on what the macros look like
11:08:54 <dmwit> elliomax: Neat! How's that going?
11:08:59 <klrr> FreeFull: is this enough to do so? https://github.com/klrr/scmbot/blob/master/src/Scheme.hs
11:09:26 <monoidal> smithw: (btw there's something called automatic differentiation that allows you to write just f1 and f2 as they are and get j11, j12 etc. for free.)
11:09:27 <elliomax> dmwit: Well I am no math major, just doing euler problems, LISP was not so great for this one so I went to Haskell
11:09:31 <FreeFull> I've never actually written a Scheme myself
11:10:06 <smithw> monoidal, seriously? that would be good, but I guess it'd feel kinda dirty
11:10:22 <dmwit> (where "for free" means programmer cost, not necessarily runtime cost)
11:10:28 <FreeFull> klrr: You'll probably will actually need to add code Haskell-side
11:10:31 <elliomax> dmwit: What about parList? It looks interesting
11:10:38 <dmwit> What about it?
11:10:44 <klrr> FreeFull: okey :(
11:11:40 <monoidal> smithw: in short, you define data Dual a = Dual a a - a pair of numbers a + b epsilon, like complex numbers a+b i, but with complexes we have i^2 = -1 while for duals epsilon^2 = 0
11:12:19 <nebnesknarf> Sorry for the repetition, just to make sure: there is no Haskell library for doing regex matching and which takes Data.Text as input (and returns same for sub matches) and that has a pure API?
11:12:30 <monoidal> smithw: then you define arithmetic operations Dual a b + Dual c d = Dual (a+c) (b+d), Dual a b * Dual c d = Dual (a*c) (b*c + a*d) etc
11:13:48 <dmwit> nebnesknarf: Careful! That question is dangerously close to volunteering to write a Haskell library for doing regex matching on Text with a pure API.
11:14:07 <smithw> monoidal, I'm probably missing something, I'm still not seeing how this Dual datatype would eventually lead to free derivatives
11:14:09 <nebnesknarf> dmwit: I am aware of that ;-)
11:14:34 <dmwit> nebnesknarf: If you have looked at the regex packages on Hackage and didn't see one that supported Text, you are probably right.
11:14:37 <monoidal> smithw: you leave your functions as they are, only use the Dual type (no need to change definitions, only type)
11:14:54 <monoidal> smithw: then when you compute f (Dual x 0), you get Dual (f x) (f' x)
11:14:56 <dmwit> That said, have you looked in text-icu?
11:15:15 <geekosaur> http://new-hackage.haskell.org/package/regex-tdfa-text ?
11:15:25 <monoidal> smithw: there's ad library, but I know little about it https://github.com/ekmett/ad
11:15:46 <dmwit> nebnesknarf: (From the Hackage landing page for text: "To use an extended family of functions... regular expressions... see the text-icu package.".
11:16:00 <monoidal> smithw: also http://blog.sigfpe.com/2005/07/automatic-differentiation.html
11:16:02 <nebnesknarf> dmwit: I was maybe unconciously hoping to prod the existing regex library authors to consider adding Text support
11:16:10 <smithw> I think I get it... it's like giving the building blocks for the the system to calculate the derivative
11:16:24 <smithw> when I redefine sums, exponentiation etc.
11:16:35 <geekosaur> regexes are not particularly loved in the haskell community
11:17:01 <nebnesknarf> dmwit: I was pointed to text-icu but the API is very stateful, the docs even warn it is non-reentrant
11:17:23 <monoidal> smithw: Yes. The point is, if you define say h(x) = f(x) g(x) on dual numbers, it translates to h(x) = f(x) g(x), h'(x) = f(x) g'(x) + f'(x) g(x) on normal numbers; it computes the original in one component, and derivative in the other
11:17:24 <nebnesknarf> that's why I asked about a pure API
11:17:48 <dmwit> nebnesknarf: Parsers are cheap and easy in Haskell. Have you considered just jumping straight to a better technology?
11:18:23 <monoidal> smithw: and if you have 2 variables, it might translate to three pairs (original, derivative on x, on y) etc; or higher derivatives etc. Point is, you only define derivatives for primitive functions, and their compositions get everything else for free. it's really clever.
11:18:34 <hpaste> jfischoff pasted “NoMonomorphism Restriction Issue” at http://hpaste.org/87019
11:18:35 <smithw> monoidal, that's insanely cool.
11:19:16 <smithw> monoidal, but would it work for Rn->Rm functions either? I mean, I can see it generating gradients, but jacobians?
11:19:30 <arkeet> yes, you take gradients of one component at a time
11:19:40 <jfischoff> I need help understand the nature what NoMonomorphism restriction does ^
11:19:43 <k0ral> Hey, first time I'm getting "ghc: panic! (the 'impossible' happened)"
11:19:50 <arkeet> @where dmr -- jfischoff: have you read this?
11:19:50 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
11:20:06 <dmwit> jfischoff: Because the MR implies another extension. MonoLocalBinds, I think?
11:20:08 <arkeet> k0ral: ghc version? it could be fixed in HEAD
11:20:09 <monoidal> k0ral: paste your code?
11:20:18 <arkeet> and paste the error
11:20:21 <k0ral> k0ral: code is pretty big...
11:20:21 <monoidal> k0ral: (on hpaste.org)
11:20:24 <nebnesknarf> dmwit: I believe in using the tool that fits the problem domain best; general (context free, whatever) parsing libraries are overkill if the language you have is regular
11:20:34 <jfischoff> dmwit: cool I'll check that out
11:20:35 <k0ral> is there a chance this is not a GHC bug but something bad I did ?
11:20:36 <arkeet> oh, monolocalbinds.
11:20:42 <arkeet> k0ral: no, those are always ghc bugs.
11:20:43 <monoidal> k0ral: panics are always GHC bugs
11:20:45 <k0ral> (GHC version 7.6.3 for x86_64-unknown-linux)
11:20:55 <k0ral> there is also "kindFunResult ghc-prim:GHC.Prim.*{(w) tc 34d}"
11:21:05 <arkeet> I've seen that a few times. :p
11:21:06 <monoidal> k0ral: very many kindFunResults got fixed in HEAD
11:21:20 <monoidal> k0ral: but if you want to get sure, paste the code and i'll check head
11:21:47 <k0ral> hmmm do you want ALL the code or the module that causes the panic ?
11:22:02 <monoidal> k0ral: let's start with the module
11:22:45 <monoidal> smithw: the ad library supports jacobians; IIUIC it's just a "dual number" but with about n*m components
11:22:46 <k0ral> there is the line in the error
11:22:55 <k0ral> I'm pasting it
11:23:03 <dmwit> jfischoff: The GHC manual suggests I may be thinking of MonoPatBinds.
11:23:42 <monoidal> smithw: you might see conal's exposition: http://conal.net/papers/beautiful-differentiation/ where a lot of theory is mentioned.
11:24:35 <jfischoff> dmwit: can you point me to the part of the manual?
11:24:56 <dmwit> http://www.haskell.org/ghc/docs/latest/html/users_guide/monomorphism.html
11:25:00 <nebnesknarf> dmwit: another reason to chose regexes instead of more general tools is that matching regexes is know to be strictly resource-limited (for real regexes, not the backtracking perl stuff that isn't needed for most applications)
11:26:49 <k0ral> for the GHC panic: http://hpaste.org/87020
11:27:24 <dmwit> nebnesknarf: I'm surprised you have a regular language, to be honest.
11:27:33 <jfischoff> dmwit: just turning on XNoMonoPatBinds doesn't cause the issue
11:27:48 <dmwit> drat
11:28:27 <jfischoff> it does appear the binding is too polymorphic
11:28:33 <smithw> monoidal, thanks a lot, this might save me a lot of time in the future. I just think that for this specific piece of homework I'm doing now, it'd probably be considered cheating. I'm actually afraid my vector implementation (based on two different sources on the web) might be considered so too...
11:28:37 <k0ral> monoidal: ^
11:29:37 <nebnesknarf> dmwit: think about simple configuration languages, data or protocol description languages, tokenizing, etc
11:30:22 <monoidal> k0ral: yes, it's fixed in HEAD
11:30:55 <dmwit> Simple configuration languages have a habit of becoming nonregular as the program grows. Same with serialization and network protocols.
11:31:23 <k0ral> monoidal: how usable (in a daily basis) is HEAD anyway ?
11:31:54 <monoidal> k0ral: if you use libraries, the usability is small. but wait
11:32:05 <dmwit> I think even if my configuration language were regular, it would be a maintenance nightmare to read it with a regex library anyway. Yuck.
11:33:28 <nebnesknarf> dmwit: many do, but many don't. there are millions of dumb configuration file formats out there, especially in the unix world. and often you don't want to create such a language, you just need to parse it, or rather parse a small subset
11:34:15 <arkeet> monoidal: waiting. :-)
11:34:27 <carter> general question: in  cabal file how do I pass multiple flags / args to the -optlo / -opltc args?
11:34:49 <dmwit> jfischoff: I thought http://hackage.haskell.org/trac/haskell-prime/wiki/SpecifyPatternBindingSemantics was it for sure.
11:35:08 <carter> the ghc manual a  bit vague on this
11:35:35 <nebnesknarf> regular expressions are to context free grammars as a bycicle is to a motor bike
11:35:48 <geekosaur> carter, mutiple options. -optX-x -optX-y
11:36:00 <carter> ok
11:36:07 <geekosaur> also to pass `-foo bar` it's -optX-foo -optXbar
11:36:11 <geekosaur> which looks strange...
11:36:16 <carter> geekosaur ok
11:36:19 <carter> thats what i was doing
11:36:20 <dmwit> nebnesknarf: This is starting to get a bit abstract. What is the problem *you* are trying to solve in your code right now?
11:36:22 <carter> but i was worried i was doing it wrong
11:36:49 <carter> geekosaur thanks i've been doing it like -optlo "-O3"    -optlc "-O3"
11:36:54 <carter> or the like
11:37:00 <carter> glad to know i'm not being totally aft
11:37:02 <carter> daft
11:37:13 * geekosaur is not sure a space will work like that though
11:37:16 <monoidal> k0ral: yes, it was already reported. but most kindFunResult bugs are due to code that would not compile anyway, and I believe this is the case too.
11:37:27 <jfischoff> dmwit: some basically it is undefined behavior right now? (and probably incorrect)
11:37:46 <monoidal> k0ral: "lift . writeBrowser" shouldn't typecheck. can you verify?
11:38:12 <dmwit> um
11:38:18 <carter> geekosaur it works, if i make up flags they barf :)
11:38:29 <FreeFull> :t writeBrowser
11:38:30 <lambdabot> Not in scope: `writeBrowser'
11:38:31 <nebnesknarf> dmwit: i am not aware that 'too abstract' is an allowed criticism here ;-)
11:38:35 <dmwit> I think there was a decision handed down from the Haskell committee. But I don't know how to find the email I'm thinking of that mentions this.
11:38:48 <hpaste> monoidal pasted “simplified panic” at http://hpaste.org/87021
11:38:54 <monoidal> k0ral: http://hpaste.org/87021
11:38:55 <k0ral> monoidal: oh right, it should be writeBrowser l v = lift $ writeBrowser l v
11:39:06 <dmwit> nebnesknarf: Of course. My abstract answer is "a pure Text regex library is possible".
11:39:23 <monoidal> k0ral: probably yes. now, does it work?
11:39:24 <k0ral> monoidal: no more panic :)
11:39:32 <carter> ok , i'll test to see if i'm wrong by seeing what happens when I pass  -optlo "-O3NINJA"    -optlc "-O3NINJA"
11:39:38 <nebnesknarf> dmwit: but to answer your question: no concrete problem at the moment, but comes up now and again when I want to write a small program
11:39:42 <carter> yup, it barfs when i give nonsense fields that way
11:40:27 <k0ral> thank you for hinting :)
11:42:28 <nebnesknarf> dmwit: btw, it was you who started the abstract discussion by trying to tell me that regexes are inferior technology (which tried to disprove)
11:43:30 <FreeFull> Basic regular expressions are very handy
11:43:49 <Clint> we have a large number of regex libraries
11:44:20 <FreeFull> Can you point to one for Data.Text, that is pure and returns Data.Text?
11:45:09 <monoidal> smithw: independently of whether you need currently AD or not, I recommend looking at it in free time, perhaps conal's paper. it's really interesting.
11:46:31 <smithw> monoidal, I'll certainly will. it's beyond amazing
11:46:34 <nebnesknarf> Please note, it was not my intention to complain about regex support in Haskell. I just wanted to make sure I haven't overlooked something.
11:58:10 <klrr> it's not learning haskell, it's learning all damn DSLs that's annoying
11:58:20 <sm> nebnesknarf: you haven't, it isn't as complete as it could be
12:00:31 <hiptobecubic> I'm using getLine in this hangman game. I want ^D to exit the game sanely. I tried wrapping it in `finally` but I'm still ending up with abrupt termination and "<stdin>: hGetLine: end of file"
12:00:49 <dmwit> Cale: lambdabot is acting up.... everything is timing out
12:01:08 <chrisdotcode_> hi all :)
12:01:16 <carter> hello
12:01:38 <chrisdotcode_> I think learning about the state monad is making me fall in love with haskell all over again.
12:03:01 <nebnesknarf> hiptobecubic: maybe rather than 'finally' you want to 'catch' the exception and handle it (by quitting the game)
12:03:46 <hiptobecubic> nebnesknarf, I'm not sure I do though. If the game fails, then I just take the current state and call the same code i would have called had the game not failed.
12:04:17 <hpaste> jfischoff pasted “ScopedVariable questions” at http://hpaste.org/87022
12:04:38 <jfischoff> more type checking woes ^
12:04:42 <Taneb> I was bored and made a little module for type-safe SI unit-y things
12:04:45 <dmwit> jfischoff: You forgot the "forall".
12:04:47 <merijn> jfischoff: SCTV requires explicit forall
12:05:09 <hiptobecubic> oh i see... it does the 'finally' part, but doesn't swallow the exception
12:05:14 <Taneb> Using DataKinds
12:05:18 <hiptobecubic> nebnesknarf, i think you're right after all. thanks
12:05:20 <merijn> i.e. "forall m . Monad m => ASDF m"
12:05:32 <jfischoff> test' :: forall m. Monad m => ASDF m ?
12:05:48 <merijn> jfischoff: No, in test1
12:06:16 <nebnesknarf> hiptobecubic: yw
12:06:17 <merijn> jfischoff: The forall brings them into scope for the local type signatures
12:06:26 <jfischoff> okay that work :) thanks merjin, dmwit
12:06:30 <jfischoff> aye
12:07:35 <nebnesknarf> btw, am i the only one who thinks this special meaning of 'forall' (i.e. introduce a scope) is a wart?
12:07:59 <dmwit> Yes, it's totally backwards. Everybody agrees.
12:08:20 <nebnesknarf> ah, good to know
12:08:40 <hiptobecubic> ambiguous type variables when working with exceptions you want to ignore are pretty ugly
12:09:20 <Eduard_Munteanu> Maybe it could treat type variables as implicit parameters, which you could bind to in clauses. Like Agda.
12:09:54 <hpaste> jfischoff annotated “ScopedVariable questions” with “ScopedVariable questions (annotation)” at http://hpaste.org/87022#a87023
12:10:07 <jfischoff> progress but no I have another question ^
12:10:21 <jfischoff> the annotation is on the bottom ...
12:10:26 * hackagebot haddock 2.13.2 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.13.2 (DavidWaern)
12:10:44 <nebnesknarf> apropos wart: why does the quantification add yet another(!) meaning to the dot (.) symbol? this is just plain stupid IMO, i would have chosen 'in', making it clear that there is a new (type) variable in scope in what follows
12:11:14 <dmwit> jfischoff: I'm having trouble parsing the question.
12:11:18 <nebnesknarf> Like in: "forall a in a -> a"
12:11:33 <Eduard_Munteanu> f :: forall a. a -> ...    f {a} x = ... where g :: t -> a -> ...
12:11:36 <jfischoff> dmwit: oh s/no/now
12:11:53 <jfischoff> dmwit: and the question is why does it not type check?
12:12:30 <arkeet> well first of all, you should remove the Monad m constraint.
12:12:32 <arkeet> on line 20
12:12:33 <jfischoff> dmwit: but I think I figured it out. The c = y test part specialized test before the scoped type variable annotation could help out
12:12:42 <wole> @hoogle Nat -> [Nat] -> Nat
12:12:43 <lambdabot> Warning: Unknown type Nat
12:12:43 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
12:12:43 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
12:12:59 <jfischoff> arkeet: still no dice
12:13:17 <jfischoff> if I remove the c = y test line it works
12:14:50 <dmwit> jfischoff: It doesn't know which type to specialize test's m to when calling y.
12:15:12 <dmwit> jfischoff: And, because that variable has a constraint on it, the value of test can vary depending which specialization it chooses.
12:15:24 <Cale> dmwit: I don't know why this is, all I did was update lens ;)
12:15:32 <geekosaur> @tell nebnesknarf existing mathematical usage, plus *in that context* it doesn't conflict with other meanings
12:15:33 <lambdabot> Consider it noted.
12:15:40 <dmwit> jfischoff: (Of course, you and I know that variation can't matter. But the compiler can't know that.)
12:15:44 <Cale> > 1
12:15:47 <lambdabot>   1
12:15:54 <dmwit> > sum (replicate 9 0.1)
12:15:54 <Cale> > sum [1..1000]
12:15:57 <lambdabot>   mueval-core: Time limit exceeded
12:15:58 <lambdabot>   mueval-core: Time limit exceeded
12:16:13 <Cale> > sum (replicate 9 0.1) :: Double
12:16:14 <lambdabot>   0.8999999999999999
12:16:21 <Cale> > sum (replicate 9 0.1)
12:16:24 <lambdabot>   0.8999999999999999
12:16:26 <Cale> hmm
12:16:31 <h4199> Is lambdabot ill?
12:16:39 <Cale> From this experiment, I conclude nothing
12:16:39 <dmwit> jfischoff: Writing "c = y (test :: ASDF m)" for example fixes the problem.
12:16:42 <FreeFull> No, just floats
12:16:53 <FreeFull> > sum (replicate 9 0.1) :: CReal
12:16:54 <lambdabot>   0.9
12:17:13 <jfischoff> ah right
12:17:14 <Cale> The CPU is not especially busy
12:17:28 <Taneb> Wow, the Haskell 2014 committee has formed
12:17:41 <edwardk> Cale: it has been acting up for a couple of weeks now, honestly. Its just a little bit worse than normal
12:17:47 <edwardk> ok, a couple of months
12:17:51 <Cale> edwardk: hmm
12:18:06 <Cale> Well, there were some changes to the hosting, but they sounded like positive changes.
12:18:07 <dmwit> Really, though, adding 9 copies of 0.1 and 1000 Integers shouldn't be taxing its limits.
12:18:24 <Fuco> is there something like `find' that simply throws an error instead of returning Maybe? I can guarantee that the element is always present in the list.
12:18:33 <Fuco> and so handling the maybe is useless
12:18:42 <edwardk> dmwit: well, i think there is something external causing it to just not get around to starting the calculation before the end of the timeout more than the task is taking too long ;)
12:18:43 <dmwit> fromJust + find ;-)
12:19:01 <dmwit> edwardk: right
12:19:41 <Cale> dmwit: Well, the time limit awkwardly seems to include the time taken by GHC, and it's pretty short. Maybe I could look into increasing it a bit.
12:19:52 <hiptobecubic> ignoreWith = const . return :: a -> SomeException -> a   should be in the standard library :)
12:20:41 <Cale> (It's actually good that it includes the time taken to compile because otherwise you end up with people abusing bugs or writing short programs which use lots of time/space to typecheck)
12:20:58 <dmwit> sure
12:21:59 <dmwit> :t let f = join (,) in f . f . f . f . f
12:22:01 <lambdabot> a -> (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))
12:23:15 <armlesshobo> ls
12:23:18 <armlesshobo> oops
12:25:16 <dmwit> I guess you *could* make typechecking that go faster than exponential in the number of "f"s. But testing in ghci seems to indicate that GHC doesn't.
12:25:38 <hseg> I'm trying to write a lexer in Parsec. Posting specification of the target language on hpaste, along with my code so far. Only problem is that I need to limit integer literals to [0..2^(15)] and string literals to not include " or newlines. I have no idea how to do this.
12:25:59 <hpaste> hseg pasted “Code so far” at http://hpaste.org/87024
12:26:47 <Botje> hseg: wrap the number / string parsers you get back
12:27:07 <hseg> How?
12:27:31 <chrisdotcode_> does haskell have/need anything similar to lisp's macros?
12:28:42 <Botje> hseg: myNumber = do { n <- natural jackStyle; when (n < 0 || n > 65535) $ error "literal is wrong"; return n
12:29:20 <edwardk> chrisdotcode_: we have 'template haskell' which is necessarily more complicated than a lisp macro system because the syntax isn't simple and homoiconic.
12:29:26 <Botje> hseg: oh, you can use parserFail instead of error, apparently. that's nice.
12:29:43 <chrisdotcode_> edwardk: I hear that TH is a necessary evil?
12:29:53 <edwardk> chrisdotcode_: but it can be used for many of the same purposes. On the other hand, we put less pressure on that macro system because we can use laziness to make nicer EDSLs within the language we have for the most part
12:29:54 <FreeFull> I don't see how TH is necessary
12:29:57 <FreeFull> It can be nice though
12:30:15 <chrisdotcode_> edwardk: right... that makes sense...
12:30:17 <hseg> OK. And the restriction on string literals? I'm not sure what the default definition of stringLiteral is.
12:30:26 <edwardk> chrisdotcode_: its an evil, not sure how necessary it is, but its the bargain we've made with some sort of infernal being or other. ;)
12:30:46 <Botje> hseg: "This parsers deals correctly with escape sequences and gaps."
12:31:14 <Botje> hseg: so you can do a similar thing with something like ' ' `elem` str || '\n' `elem` str
12:31:18 <chrisdotcode_> edwardk: but I hear that they're type safe and fast; what's so bad about them?
12:31:55 <hseg> Oh. And so if it parsed a gapped string by accident, there will be an embedded newline, so I'll be able to pick it up.
12:31:57 <hseg> Thanks.
12:32:11 <FreeFull> Botje: That might be less efficient than doing it during parsing time
12:32:21 <FreeFull> Since you'll end up going over the string twice
12:32:31 <Botje> hseg: not sure what they mean by 'gapped string', sorry.
12:32:41 <Botje> is that the concatenation C does, for example?
12:33:12 <Botje> FreeFull: room for optimisation later.
12:33:47 <hseg> String gaps in Haskell. If the final character on a line with an unclosed string literal is \, the lexer ignores that \ and all whitespace until the next \,
12:34:02 <hseg> Used to write multiline strings in Haskell.
12:34:38 <hseg> Oh. But that wouldn't leave any evidence of being there, so I won't be able to ban it.
12:34:39 <arkeet> > "abc\      \de"
12:34:40 <lambdabot>   "abcde"
12:34:42 <Botje> oh? never used that.
12:35:02 <Botje> hseg: one way to find out i guess :]
12:35:38 <hseg> Of course, people don't like the fact that it doesn't resemble other languages, and are clamoring to have it removed: http://hackage.haskell.org/trac/haskell-prime/wiki/RemoveStringGaps
12:35:44 <arkeet> :t any (\x -> x == ' ' || x == '\n')
12:35:46 <edwardk> chrisdotcode_: template haskell is interesting. its strongly typed enough to be inconvenient but not strongly typed enough to prevent you from generating type incorrect code. not sure how much better of a point in the design space exists though given the constraints on it.
12:35:46 <lambdabot> [Char] -> Bool
12:35:52 <edwardk> chrisdotcode_: i've learned to use it, but not to love it
12:36:34 * djahandarie has avoided it pretty much entirely
12:37:25 <hseg> OK, thanks guys.
12:38:25 <arkeet> > (\str -> ' ' `elem` str || '\n' `elem` str) (repeat '\n')
12:38:30 <lambdabot>   mueval: ExitFailure 1
12:38:30 <lambdabot>  mueval: Prelude.undefined
12:38:33 <arkeet> > any (\x -> x == ' ' || x == '\n') (repeat '\n')
12:38:35 <lambdabot>   True
12:39:52 <arkeet> do we have a parallel or somewhere?
12:40:00 <k0ral> can someone confirm http-conduit doesn't cache http responses ?
12:40:08 <arkeet> i.e. given x and y, evaluate both, and return True as soon as one of them evaluates to True.
12:40:13 <arkeet> evaluate in parallel, that is.
12:41:04 <Zeta> Hello. How can I run a shell command with expansion like: ls $PWD?
12:41:21 <chrisdotcode_> edwardk: what's a really good use case example?
12:41:44 <edwardk> chrisdotcode_: i use template haskell in lens to generate the boilerplate for working with new data types.
12:41:46 <Zeta> Using readProcess fails because it puts quotes around the arguments.
12:41:50 <Botje> Zeta: System.Process.system is like the C system(), I think?
12:41:58 <arkeet> Zeta: let a shell interpret it?
12:42:00 <arkeet> sh -c 'ls $PWD'
12:42:33 <edwardk> chrisdotcode_: i use it in some other code to generate function calls for internationalization and localization that map to code in an appropriate localization module
12:43:03 <chrisdotcode_> edwardk: oh, okay. so i18n essentially?
12:43:09 <edwardk> chrisdotcode_: i use it in my automatic differentiation library to avoid duplicating an insane amount of code between different AD modes, generating dozens of instances at a time
12:43:20 <Zeta> Thanks arkeet that works.
12:43:30 <chrisdotcode_> and also meta-meta-programming (because most of haskell is already meta ;) )
12:44:05 <edwardk> i use little splaces of it in my implementation of hyperloglog to make it easier to make types out of each bucket count, e.g. HyperLogLog $(5)
12:44:18 <edwardk> i use it in my old type-int library to generate about 10k instances.
12:44:39 <chrisdotcode_> so I guess I'm still confused on *what* TH is, then...
12:44:45 <chrisdotcode_> so looks like I'll have some reading to do :)
12:45:23 <edwardk> template-haskell is a way to let you hook in at compile time and run some haskell code that generates haskell code
12:45:33 <edwardk> thats all it is
12:45:35 <arkeet> when is a GHC release getting the type nat solver?
12:46:11 <carter> arkeet allegedly 7.8
12:46:17 <carter> though i don't think its merged in yet...
12:46:22 <edwardk> arkeet: More importantly, when will someone figure out exactly what subset of problems involving natural numbers it'll actually be able to solve ;)
12:46:27 <arkeet> heh
12:46:30 <carter> edwardk yeah, that too
12:46:54 <carter> unless you can plug in your own solver / prover, its going to have some frustration points
12:46:55 <arkeet> it should solve Tarski's high school algebra problem.
12:47:09 <arkeet> er,
12:47:57 <dmwit> Oh, it's not just some well-studied subset, like Presburger arithmetic?
12:48:56 <edwardk> dmwit: thats the problem. i'd like to see some kind of guarantee that it can handle Presburger 'and maybe some extra stuff' but at last check it was just a hodgepodge of rules
12:49:31 <edwardk> that was when i kinda decided to stop worrying about it and see how well it worked when it got here, but not hold my breath =)
12:50:10 <dmwit> dang
12:50:50 <dmwit> That's super disappointing. I feel like "just throw in a hodge-podge of stuff" hasn't really worked out that well for other languages.
12:58:36 <edwardk> likewise
12:59:53 <carter> edwardk dmwit  is there any way to push back on that? or will helping that require someone to intervene with actual engineering time?
13:00:24 <edwardk> carter: i may be completely off base here, but copumpkin was pushing at one point and bounced off it, so i decided not to bother
13:00:28 * hackagebot hledger-lib 0.20 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.20 (SimonMichael)
13:00:30 * hackagebot statistics 0.10.4.0 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.10.4.0 (BryanOSullivan)
13:00:32 * hackagebot hledger 0.20 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.20 (SimonMichael)
13:00:33 <carter> copumpkin care to chime in ?
13:00:34 * hackagebot hledger-web 0.20 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.20 (SimonMichael)
13:00:45 <acowley> what's the issue?
13:00:47 <edwardk> i'd suspect it'd mostly take engineering time and th ear of the right people, etc.
13:01:07 <carter> acowley the soundness / guarantees on the pending nat solver
13:01:40 <dmwit> I expect soundness is not an issue.
13:02:16 <carter> dmwit what maybe then?
13:02:23 <carter> coverage / completness?
13:02:27 <carter> ish
13:02:28 <dmwit> yeah
13:02:30 <acowley> I would expect that kinds of expressions it can simplify to be a limit
13:02:54 <dmwit> Soundness is the easy half of a type system. Just don't stick in anything stupid.
13:03:17 <carter> fair enough
13:03:34 <dmwit> (Though maybe I should hold my tongue a bit, since even experts get it wrong sometimes!)
13:05:21 <acowley> Should probably just pull sbv into the type checker.
13:05:26 <acowley> ghc-stageSMT
13:06:12 <wmoss> does anyone know if STM generates generation zero garbage?
13:06:36 <wmoss> I've got a program that seems to generate a lot of gen 0 garbage, which is really hurting performance when it stops everything to collect
13:07:14 <carter> acowley http://cvc4.cs.nyu.edu/web/ seems to be the only one with a permissive license
13:07:36 <carter> wmoss are you allocating anything? per se collection only takes time when theres stuff to collect / still alive though
13:09:29 <wmoss> carter: yeah, the program sits in between a database and an application process
13:09:48 <wmoss> so it gets requests from the application, does somethings, makes a request of the database, does some more things, responds to the client
13:09:51 <wmoss> then all that is garbage
13:10:00 <wmoss> so it's definitely making garbage, which is unavoidable given the design
13:10:21 <carter> wmoss then set the nursery size to be large enough that collection only happens when the bulk of the data is no longer live
13:10:23 <wmoss> but I would like to avoid gen 0 garbage, since that really negatively impacts the response time (when it's doing a collection)
13:10:24 <carter> have you tried tied?
13:10:33 <carter> *tried that
13:11:00 <carter> any short lived stuff thats dead shortly after allocation is gen0 garbage
13:11:04 <wmoss> carter: I've messed around with the GC settings without much success...
13:11:21 <wmoss> seems like if I'm constantly handling request, there will always be plenty of stuff that's active
13:11:32 <wmoss> although obviously the ratio will change
13:12:01 <wmoss> carter: also, is there some description of what generates what generation of garbage?
13:12:16 <carter> everything gets allocated to the nursery
13:12:23 <wmoss> I was looking around for something to read on the subject, but couldn't find anything
13:12:26 <carter> stuff gets promoted up
13:12:36 <carter> wmoss have you tried setting gen 0 to be big?
13:12:43 <carter> like 4-20mb range?
13:13:05 <carter> wmoss collecting a generation takes time proportional to the number of live objects
13:13:15 <carter> if you're collecting much shorter than the lifetime of the objects
13:13:18 <carter> you'll have lots of pausing
13:13:37 <carter> also it sounds like you care about median latency rather than 99th percentil latency
13:13:47 <carter> in which case making the nursery larger would be the right trade off
13:13:54 <carter> ghc uses a generational collector
13:13:56 <carter> with fancy bits
13:14:02 <luite> carter: that depends on on how many roots you have though
13:14:12 <luite> large stacks, lots of weak refs add up
13:14:18 <carter> yeah
13:14:22 <luite> or was it stableprts?
13:14:25 <luite> yeah stablethings
13:14:35 <luite> they're going to be stored per generation in 7.8
13:14:35 <carter> luite but most people don't use stable pointers much
13:14:46 <carter> luite what were the stable pointers doing before?
13:14:50 <carter> though stable pointers are awesome
13:15:01 <luite> one list that had to be traversed every minor and major collection
13:15:21 <luite> someone was using them to speed up hashmaps and got slow minor collections because of this
13:15:28 * hackagebot statistics 0.10.4.1 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.10.4.1 (BryanOSullivan)
13:15:35 <carter> welll, that should be fixed ish then
13:15:48 <carter> wmoss the answer is the depending on the exact data life cycle
13:15:52 <carter> and code
13:15:55 <carter> try differen things
13:16:08 <luite> but yeah, usually gen0 garbage isn't that bad :)
13:16:19 <luite> if everything dies shortly after promoting, that's bad
13:16:23 <carter> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-gc
13:16:35 <carter> luite hence me suggesting larger nursery
13:16:45 <wmoss> carter: right now it's set at 16M, I forget how high we tried, although it was at least double, I think
13:17:05 <carter> wmoss could you show us code or no?
13:17:15 <carter> how much data is each query thingy doing?
13:17:38 <wmoss> carter: https://github.com/bumptech/montage
13:17:39 <carter> like, how many pieces of work happen to fill up the heap
13:17:42 <wmoss> that's the bulk of the code
13:17:44 <acowley> You can also put a performGC at the end of the handler in your server, if you haven't already, which can help avoid a surprise GC when it would be less convenient.
13:18:00 <carter> acowley yeah thats a good idea too
13:18:25 <carter> cool, i was wondering when bump hs code would be public ;)
13:18:38 <wmoss> carter: haha, well yes, some of it is
13:19:01 <luite> is there an easy way to generate an export list for a module? (so if i want to export 90% of the symbols, i just have to delete the 10%)
13:19:01 <wmoss> and sadly, under load, this thing freaks out and does a lot of GCing...
13:19:10 <wmoss> let me find you a graph
13:19:36 <carter> wmoss which file in question too?
13:20:13 <carter> wmoss also: it might be worth playing with the protobuf lib
13:20:28 * hackagebot language-slice 0.1.0.0 - AST and parser for the ZeroC Slice language (Specification language for ICE)  http://hackage.haskell.org/package/language-slice-0.1.0.0 (PaulKoerbitz)
13:20:28 <carter> 'cause if the allocation is on the protocolbuffer lib side
13:20:30 * hackagebot criterion 0.8.0.0 - Robust, reliable performance measurement and analysis  http://hackage.haskell.org/package/criterion-0.8.0.0 (BryanOSullivan)
13:20:32 <luite> hm, is it possible to get detailed gc statistics? number of roots, reachable objects, time spent using marking and compacting?
13:20:33 * hackagebot array-forth 0.2.0.6 - A simple interpreter for arrayForth, the language used on GreenArrays chips.  http://hackage.haskell.org/package/array-forth-0.2.0.6 (TikhonJelvis)
13:21:03 <acowley> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/GHC-Stats.html
13:21:03 <wmoss> carter: I'm quite sure the protobuf lib is not optimal :(
13:21:05 <carter> wmoss because the protocol buffer  lib (unlike the protobuf lib) has some gnarly cpp underneath
13:21:07 <carter> and is pretty complex code
13:21:14 <acowley> I think that's all you can get
13:21:28 <carter> wmoss yes, but its also alleged that its faster that most network connections
13:21:32 <wmoss> acowley: luite: We're tracking all of those over time
13:21:50 <carter> wmoss whats the data volume over the network to the machine per second?
13:22:00 <wmoss> carter: wait, we're using the pure haskell protocol buffersl...
13:22:05 <carter> nope
13:22:07 <wmoss> there's a c++ backed on?
13:22:11 <carter> no
13:22:20 <carter> that one IS the cpp one i think
13:22:26 <wmoss> carter: oh, I see
13:22:31 <wmoss> I thought it was pure haskell
13:22:38 <luite> acowley: oh cool, not bad, though it would be nice to see separate minor/major collection statistics
13:22:39 <carter> protobuf is worth checking out
13:22:39 <k0ral> in Control.Concurrent documentation, I read a lot of (GHC only)
13:22:41 <wmoss> http://hackage.haskell.org/package/protocol-buffers
13:22:50 <k0ral> is that bad to use functions that are "GHC only" ?
13:22:54 <carter> oh yeah
13:22:55 <wmoss> that's what we're using
13:22:58 <carter> it does lots of crazy code generation
13:23:08 <wmoss> yeah, it definitely does
13:23:18 <carter> the protobuf lib doesn't
13:23:42 <carter> meaning: IF the allocation churn is from the protobuff (de)serialization code
13:23:49 <geekosaur> k0ral, there is a lot of stuff that is currently ghc only. I wouldn't worry about it too much
13:23:51 <carter> it'd be easier to isolate with protobuf
13:24:05 <carter> do you have a heap profile by type info?
13:24:08 <carter> that would nail it
13:24:09 <wmoss> carter: http://hackage.haskell.org/package/protobuf
13:24:10 <wmoss> this one?
13:24:15 <carter> yup
13:24:20 <wmoss> hmm, cool
13:24:26 <carter> its still nacent, but i LIKE IT
13:24:29 <carter> and its simple
13:24:30 <wmoss> I'll take a look at that, I hadn't seen that before
13:24:33 <geekosaur> alternatve compilers appear to have mostly given up on even trying :(
13:24:47 <k0ral> sad :(
13:25:05 <carter> wmoss also do a heap profiling run by type
13:25:10 <wmoss> carter: how would I generate a heap profile
13:25:12 <wmoss> ?
13:25:18 <k0ral> so I can kill my threads without fear of breaking portability, right ?
13:25:28 * hackagebot slice-cpp-gen 0.1.0.0 - Generate C++ skeletons from slice files  http://hackage.haskell.org/package/slice-cpp-gen-0.1.0.0 (PaulKoerbitz)
13:25:30 <carter> http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html#rts-options-heap-prof
13:25:39 <chrisdotcode_> so are there any good reads/papers/blog posts on understand recursion fully, guys?
13:25:45 <geekosaur> there's nothing sensible to be portable *to*
13:25:45 <chrisdotcode_> (especially targetting haskell?)
13:25:47 <carter> also a good but old walk through in a later section of real world haskell
13:25:47 <wmoss> carter: oh yeah, I've done that before for something else
13:25:56 <wmoss> okay cool, I'll try that on this thing
13:26:14 <carter> yeah
13:26:17 <carter> do type profiling
13:26:24 <carter> and maybe some of the other ones
13:26:35 <nebnesknarf> geekosaur: I beg to differ; there is jhc and there is uhc, both of which are very much alive
13:26:36 <lambdabot> nebnesknarf: You have 1 new message. '/msg lambdabot @messages' to read it.
13:26:49 <nebnesknarf> '/msg lambdabot @messages
13:26:51 <wmoss> cool, thanks
13:26:53 <geekosaur> I've been tracking jhc "develoment"; there isn't much
13:27:00 <wmoss> I've at least got some stuff to try now!
13:27:22 <carter> glad i could help. i'm usually  the one who has no clue what he's doing
13:27:39 <luite> carter: no way, i'm that one already!
13:27:40 <chrisdotcode_> so... guys? any good recursion primers around?
13:28:01 <carter> chrisdotcode_ read SICP or HTDP2e
13:28:14 <carter> luite lies, you've written a ghc backend esentially!
13:28:20 <carter> and i can't spell
13:28:35 <chrisdotcode_> carter: SICP will definitely kill me at the moment
13:28:41 <carter> chrisdotcode_ whas the goal
13:28:43 <carter> *whats the goal
13:28:54 <carter> unless we know what your goal is we can't give relevant suggestions
13:29:01 <carter> HTDP2e is pretty accessible
13:29:05 <carter> and well written
13:29:12 <chrisdotcode_> carter: get a more-than-binary-tree (and factorial)-understanding of recursion
13:29:17 <nebnesknarf> geekosaur: jhc is more or less a one-man project, development seems to be in sprints interleaved with long pauses...
13:29:19 <carter> then do both
13:30:00 <tac> SICP is nice if you can stomache lisp
13:30:05 <chrisdotcode_> carter: sadly, I'm not a academic, so SICP will probably go right over my head the first time
13:30:07 <nebnesknarf> geekosaur: in practice i am using ghc extensions w/o much extra consideration
13:30:13 <chrisdotcode_> and I don't much lisp, but I think it looks ugly
13:30:16 <carter> chrisdotcode_ i read it in high school
13:30:19 <Cale> chrisdotcode_: SICP is written for first year students
13:30:20 <carter> if you want to learn
13:30:25 <chrisdotcode_> oh really?
13:30:27 <chrisdotcode_> I didn't know that.
13:30:27 <carter> yes
13:30:30 <carter> now you do
13:30:35 <chrisdotcode_> I thought it was as thick as, say, the dragon book.
13:30:36 <carter> read it :)
13:30:47 <carter> the dragon book isn't even a good compiler book!
13:30:49 <carter> :)
13:31:09 <chrisdotcode_> I hear it's the best compiler *optimization* book, and is good as a reference, but sucks for teaching.
13:31:17 <Cale> In order to understand recursion, you must first understand recursion.
13:31:19 <carter> chrisdotcode_ … says who?
13:31:24 <chrisdotcode_> and do I already need to know scheme for SICP?
13:31:29 <carter> chrisdotcode_ no
13:31:32 <chrisdotcode_> carter: the general consensus from asking around
13:31:35 <carter> just read it
13:31:36 <chrisdotcode_> okay, sweet
13:31:38 <carter> chrisdotcode_ asking who? :)
13:32:03 <chrisdotcode_> carter: the HN crowd mostly, and a few various others
13:32:04 <acowley> I really liked The Little Schemer for introductory material
13:32:12 <carter> HN is rarely full of experts
13:32:21 <carter> the little schemer is great
13:32:32 <chrisdotcode_> carter: yeah. so many grains of salt I used up two containers :)
13:32:47 <chrisdotcode_> so the little schemer or SICP first?
13:32:58 <carter> chrisdotcode_ HN is a great marketing and circle jerk community that occasionally has nuggets of cool, sometimes
13:33:05 <chrisdotcode_> and I eventually want to build a compiler, those will help right?
13:33:15 <carter> chrisdotcode_ which will help with what?
13:33:20 <chrisdotcode_> carter: yeah, I've found that occasionally. comments are cool to skim, for something useful
13:33:31 <chrisdotcode_> reading the little schemer and SICP will eventually help with building a compiler later
13:33:36 <acowley> The Little Schemer is really short, and understanding the material it contains would be of value to virtually any human being.
13:34:47 <carter> yeah
13:34:56 <carter> little scheme
13:35:11 <nebnesknarf> Althoigh I read SICP late in my life I agree with Cale that it is very accessible to beginners; recursion /is/ explained in detail
13:35:18 <hpaste> bos pasted “new key-value type - first benchmarks” at http://hpaste.org/87028
13:35:24 <bos> OH I AM EXCITED ^^^^
13:35:27 <parcs> recursion is so easy
13:35:35 <carter> bos oh?
13:36:22 <carter> wheres this critbit code?
13:36:24 <acowley> A new CritterBite library for all our animal control needs!
13:36:57 <carter> ah https://github.com/bos/critbit
13:36:59 <carter> neat
13:37:11 <carter> bos btw: criterion crashes when i say do only two samples
13:37:51 <tgeeky> bos: to your knowledge, has anyone used criterion to measure CPU or memory performance?
13:38:09 <carter> tgeeky neat idea
13:38:20 <acowley> Wow that's not a lot of code
13:38:24 <carter> i've been getting pretty consistent per machine numbers with my code
13:38:44 <carter> acowley you mean its none right?
13:39:00 <carter> slick
13:39:16 <bos> 30% faster than hashmaps so far, which is a good place to start
13:39:28 <carter> (i had another crash that may have been my own stuff i was debugging that only happened when running my code in criterion with profiling enabled… which is how i stumbled into the 2 sample bug)
13:39:37 <carter> bos neat
13:40:28 * hackagebot snap 0.11.3 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.11.3 (DougBeardsley)
13:44:00 <tgeeky> bos: doesn't edwardk have patrica tree based code that you could compare against?
13:44:33 <bos> tgeeky: dunno
13:44:35 <tgeeky> oh, critbit = patrcia, sort of?
13:44:48 <acowley> less overhead
13:53:36 <beaky> hello
13:53:46 <beaky> @pl \a b f -> f a b
13:53:47 <lambdabot> flip . flip id
13:54:07 <tgeeky> @pl \a b f -> f b a
13:54:07 <lambdabot> flip (flip . flip id)
13:54:27 <beaky> @pl \a b -> a
13:54:28 <arkeet> @pl \q a b f -> q f a b
13:54:28 <lambdabot> (flip .) . flip
13:54:28 <lambdabot> const
13:54:37 <arkeet> now apply to id
13:55:13 <hseg> Can someone explain first few entries in the export list of http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/src/Text-Parsec.html
13:55:26 <arkeet> it's re-exporting the contents of other modules.
13:55:52 <beaky> how does haskell sort lists?
13:55:58 <arkeet> @src sort
13:55:59 <lambdabot> sort = sortBy compare
13:56:01 <arkeet> @src sortBy
13:56:01 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
13:56:06 <arkeet> hm
13:56:08 <beaky> aha insertion sort
13:56:24 <beaky> @src compare
13:56:25 <lambdabot> compare x y | x == y    = EQ
13:56:25 <lambdabot>             | x <= y    = LT
13:56:25 <lambdabot>             | otherwise = GT
13:56:32 <arkeet> @src insertBy
13:56:32 <lambdabot> insertBy _   x [] = [x]
13:56:33 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
13:56:33 <lambdabot>                                  GT -> y : insertBy cmp x ys'
13:56:33 <lambdabot>                                  _  -> x : ys
13:56:34 <tgeeky> beaky: that's just the one offered in the Prelude. There are many others, of course
13:56:37 <hseg> So if I import stuff from Text.Parsec, it's as if I imported it from the appropriate module Text.Parsec exports?
13:56:45 <beaky> yeah I was expecting quicksort
13:56:55 <arkeet> but @src doesn't tell the whole story.
13:57:00 <beaky> ah
13:57:02 <arkeet> look in the Data.List source
13:57:04 <hseg> What if Text.Parsec exports two modules that export the same naem?
13:57:09 <hseg> s/naem/name
13:57:34 <arkeet> hseg: nothing, but if you try to use what's exported, you'll get an ambiguous name error
13:57:47 <arkeet> same thing would happen if you imported two modules that exported the same name
13:58:02 <hseg> Ok. Thanks
13:58:05 <arkeet> I think.
13:58:16 <beaky> what do I do in haskell if I have a list of widgets of different types that I want to operate on polymorphically?
13:58:24 <beaky> like a heterogeneous list
13:58:47 <arkeet> oh wait.
13:58:56 <arkeet> the error happens when you import the first module.
13:59:20 <arkeet> with a "conflicting exports" error
13:59:26 <nebnesknarf> hseg: arkeet: interesting question; if I get a name clash due to re-exports, how can i dis-ambiguate it?
13:59:34 <arkeet> use a qualified name.
13:59:54 <nebnesknarf> arkeet: but both are imported from the same module
14:00:19 <arkeet> nebnesknarf: ?
14:00:19 <hseg> nebnesknarf: Impossible. module A cannot export the name n twice.
14:00:24 <arkeet> ^
14:00:57 <hseg> Unless you mean module A re-exports modules B and C, which both export n. In that case, import A hiding n, then import B and C qualified.
14:01:03 <nebnesknarf> ok, so that means exporting two modules is forbidden if there is a single shared name between them?
14:01:05 <arkeet> if A exports two things with the same name, you get an error when compiling A.
14:01:39 <hseg> Or use explicit import lists. That's how I've avoided the problem. Slightly inconvenient, but the self-documentation is worth it.
14:01:51 <nebnesknarf> hseg: yes, that was what I meant, since it was your original question
14:02:00 <arkeet> yes, so my first answer to hseg was wrong.
14:02:10 <conal> does anyone here know how to do the equivalent of -ddump-simpl, -dsuppress-type-applications, etc in the ghc api?
14:02:23 <nebnesknarf> arkeet: i am not sure, must read the report
14:02:33 <arkeet> nebnesknarf: I'm just saying what GHC does.
14:02:55 <hseg> arkeet: Not when compiling A, when importing it. Otherwise, people would get such errors when compiling Parsec
14:03:09 <arkeet> no, definitely compiling.
14:03:22 <arkeet> Parsec doesn't import the whole modules being re-exported
14:03:25 <conal> … for simplifying the pretty-printing of GHC Core output ?
14:03:36 <arkeet> note the hiding directives
14:03:48 <hseg> Correct.
14:03:53 <nebnesknarf> but... as a user of a library i might not know about the identifier being re-exported; this could be quiote confusing
14:04:02 <hseg> s/Correct/I stand corrected/
14:04:04 <nebnesknarf> s/quiote/quite
14:04:57 <hseg> nebnesknarf: It appears I was wrong in my evaluation of the export list of Parsec. It doesn't re-export the same name from two modules, rather it imports them hiding the conflicting names.
14:05:05 <arkeet> correct
14:05:13 <hseg> The conflicting names are accessed by importing the appropriate module.
14:09:40 <nebnesknarf> I just tried it with a simple example and at least ghc complains when compiling the module that re-exports an ambigous name. Says: Conflicting exports for `x'
14:10:15 <nebnesknarf> So ghc acts sane here
14:10:41 <arkeet> that's what I said happens.
14:11:07 <nebnesknarf> arkeet: yes, sorry
14:14:45 <tgeeky> and you can generally turn warnings into errors, if you want (I think?)
14:18:10 <nebnesknarf> tgeeky: was that a question? if yes: I believe -Werror is the switch
14:18:19 <jfischoff> does -Werror imply -Wall ?
14:18:37 <arkeet> I doubt it.
14:19:27 <skyflash> Best practices poll: I'm building out an app and want to add some general app state (atm just config).  Should I roll a StateT or use and IORef (and importantly, what's the rationale)?   If an IORef, then why not an MVar.  If an MVar then why not a TVar?
14:20:38 <hpc> skyflash: depends, i think
14:20:44 <tgeeky> nebnesknarf: I made an assumption and I was covering my ass-umption. I have never tried it.
14:21:04 <hpc> StateT, IORef, MVar, and TVar are all different in what they express
14:21:11 <hpc> i personally might go with StateT
14:21:24 <hpc> and if you see performance issues, try strict(lazy?) StateT
14:21:25 <skyflash> hpc: figures.  I've read around, but not sure really how you would cleave to one option.
14:21:36 <arkeet> if you use an IORef or similar, you'd have to pass it around everywhere
14:21:43 <arkeet> so you'd end up using a ReaderT IORef instead of StateT anyway
14:21:45 <nebnesknarf> skyflash: I think current best practice is to use ReaderT for pure configuration (i.e. stuff that doesn't change when the program runs) and additionally StateT for things that do
14:22:00 <hpc> i would try to avoid using a ref unless you are positive that you want ref-like semantics everywhere in your code
14:22:20 <nebnesknarf> Furthermore, IORef is not thread-safe
14:22:37 <nebnesknarf> (in general)
14:23:13 <lambdazerocool> With Control.Monad.Writer, given a function logNumber x = writer (x, ["Got Number: " ++ show x]), I can't call "logNumber 3" unless I type logNumber as (Show a) => a -> Writer [String] a (error: No instance for MonadWriter [[Char]] m0). Why can't (Show a) be inferred by the type system with the use of "show"?
14:23:36 <nebnesknarf> tgeeky: ok
14:23:39 <hpc> :t \x -> writer (x, ["Got Number: " ++ show x])
14:23:40 <lambdabot> (Show a, MonadWriter [[Char]] m) => a -> m a
14:24:31 <lambdazerocool> i see. show is inferred, but the fact that it outputs a monadwriter [[char]] m0 is not?
14:24:37 <arkeet> lambdazerocool: it's not the Show part that's the problem
14:24:44 <arkeet> it's that the m0 there is ambiguous, probably.
14:24:48 <arkeet> if you look at the rest of the error message.
14:24:53 <arkeet> so it doesn't know which MonadWriter instance to pick.
14:25:26 <lambdazerocool> the possible fix is "add an instance declaration for..." -- there is no further information
14:25:38 <skyflash> Thanks.  I was starting to write the StateT stuff.  Then I got thinking about IORef, and then that got me thinking about the other ref/var thingies.  Sounds like StateT is still the right option (I will eventually want to edit the content).  Didn't think about ReaderT, so that's a good pointer for the constant stuff.   Cheers.
14:26:08 <arkeet> lambdazerocool: paste the whole code and error?
14:26:32 <hpc> skyflash: if you are evil, ReaderT (IORef something)
14:26:41 <nebnesknarf> lambdazerocool: you might want to not import the class stuff, just the plain Control.Monad.Writer (I believe they separated the class out some time ago)
14:26:47 <hpc> and then newtype around the IORef with something seemingly inocuous like Config
14:27:00 <arkeet> hpc: sure, but then using it is a pain.
14:27:01 <hpc> so your (ReaderT Config) has a mutable configuration
14:27:01 <hpc> :D
14:27:15 <arkeet> since everywhere you have to ref <- ask; blah <- readIORef ref etc.
14:27:17 <skyflash> hpc: :D indeed
14:27:19 <hpc> self-undocumenting types at their finest
14:27:44 <arkeet> StateT is the thing to use, unless you have a good reason not to.
14:28:11 <skyflash> arkeet: that's a good rule of thumb, and good confirmation.  Thanks.
14:28:29 <hpaste> lambdazerocool pasted “Control.Monad.Writer issues” at http://hpaste.org/87034
14:28:55 <arkeet> you won't be able to use StateT to update the state in multithreaded code, for instance.
14:29:36 <nebnesknarf> lambdazerocool: Ah, I meant Conrtol.Monad.Trans.Writer from the transformers package
14:29:48 <arkeet> hmm
14:29:57 <arkeet> lambdazerocool: do you get the same error if you use NoMonomorpshimRestriction?
14:30:29 * hackagebot directory-layout 0.3.0.0 - Declare, construct and verify directory layout  http://hackage.haskell.org/package/directory-layout-0.3.0.0 (MatveyAksenov)
14:31:16 <lambdazerocool> arkeet: no, it compiles fine with -xNoMonomorphismRestriction
14:32:00 <hpaste> facepalm pasted “Haskell function” at http://hpaste.org/87035
14:32:32 <facepalm> hello I am trying add together the result from filterTrues in a new function called sumTrues
14:32:35 <lambdazerocool> nebnesknarf: thank you for the suggestion - at this moment in time i'm trying to really get a grasp on monads themselves, though :D
14:32:44 <arkeet> lambdazerocool: well, the thing to do is to fix one of the types, then.
14:32:54 <skyflash> arkeet: not sure if this question is even sensible, but if you want to hedge your bets about threads, what's the best way to think about app state?  Do you start with StateT and then go to ReaderT with TVars... or something?
14:34:06 <nebnesknarf> lambdazerocool: what i suggested was not better, just forget it, it is really the monomorphism restriction (ugly thing that)
14:34:49 <arkeet> skyflash: it's a good question, and I don't have a good answer
14:35:14 <lambdazerocool> thanks, guys! i'll let the haskell wiki on the monomorphism restriction take it from here. i appreciate your help! :D
14:35:37 <facepalm> I thought I could represent the mask list and data list of filterTrues with x:xs and y:ys then just add together the results of the new list
14:36:42 <FreeFull> facepalm: What do you think addition on lists is meant to do?
14:36:49 <FreeFull> If you want to concatenate two lists, use ++
14:38:26 <facepalm> I dont want to add 2 lists I want to add together the result of filterTrues which takes  [True, False, True][1, 2, 3] and returns [1 , 3] so what sumTrues is meant to do is to add the 1 and 3 together and just return 4
14:38:42 <nebnesknarf> skyflash: It depends of course. StateT is 'thread safe' but any change you make will be local to the thread (or rather: local to the run/exec/evalState call) which might not be what you want. If you think you'll have multiple threads that want to share state then a MVar will be what you want.
14:38:56 <FreeFull> facepalm: Why don't you just use the sum function then?
14:38:59 <skyflash> arkeet: fair enough!  I'm transitioning from a functional language that isn't so dogmatic about purity.  I'm trying not to learn any bad habits while building out my 'muscle memory' in Haskell.  However, it's not surprising I suppose that there's no silver bullets :-)
14:39:17 <facepalm> FreeFull: I did that but it says parse error on sum
14:39:36 <FreeFull> facepalm: Can you show the code and the error?
14:40:26 <skyflash> nebnesknarf
14:40:30 * hackagebot persistent 1.2.0.1 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.2.0.1 (FelipeLessa)
14:40:32 <arkeet> :t map snd . filter fst .: zip
14:40:33 <lambdabot>     Not in scope: `.:'
14:40:33 <lambdabot>     Perhaps you meant one of these:
14:40:33 <lambdabot>       `.' (imported from Prelude),
14:40:36 <arkeet> eh
14:40:39 <nebnesknarf> skyflash: if there is anything even resembling a silver bullet against concurrency woes it is STM, so I should have recommended using a TVar.
14:40:41 <arkeet> when did we lose that?
14:40:45 <skyflash> nebnesknarf: OK, thanks
14:40:53 <mauke> > (.:)
14:40:54 <lambdabot>   Not in scope: `.:'
14:40:54 <lambdabot>  Perhaps you meant one of these:
14:40:55 <lambdabot>    `.' (imported from P...
14:41:03 <arkeet> we used to have (f .: g) x y = f (g x y)
14:41:10 <mauke> @let (.:) = (.) (.) (.)
14:41:12 <lambdabot>  Defined.
14:41:16 <arkeet> :)
14:41:17 <arkeet> :t map snd . filter fst .: zip
14:41:19 <lambdabot>     Precedence parsing error
14:41:19 <lambdabot>         cannot mix `.' [infixr 9] and `.:' [infixl 9] in the same infix expression
14:41:21 <arkeet> :(
14:41:21 <FreeFull> mauke: Problem with that, no fixity declaration
14:41:23 <arkeet> @undefine
14:41:26 <facepalm> FreeFull: I think I tried something like this sumTrues = sum filterTrues
14:41:29 <mauke> my emperor
14:41:29 <arkeet> @let (.:) = (.) (.) (.); infixr 9 .:
14:41:32 <lambdabot>  Defined.
14:41:44 <FreeFull> facepalm: You'll have to make that  sum . filterTrues
14:41:45 <arkeet> oh that's not what I want anyway.
14:41:51 <arkeet> :t (map snd . filter fst) .: zip
14:41:52 <lambdabot> [Bool] -> [b] -> [b]
14:41:59 <FreeFull> facepalm: sum expects a list of numbers but you're giving it a function there
14:42:07 <arkeet> :t goard
14:42:08 <lambdabot>     Not in scope: `goard'
14:42:08 <lambdabot>     Perhaps you meant `guard' (imported from Control.Monad.Writer)
14:42:10 <arkeet> :t guard
14:42:11 <lambdabot> MonadPlus m => Bool -> m ()
14:42:49 <arkeet> :t \bs xs -> [ x | b <- bs | x <- xs, b ]
14:42:50 <lambdabot>     Unexpected parallel statement in a list comprehension
14:42:50 <lambdabot>     Use -XParallelListComp
14:42:51 <arkeet> aw
14:42:57 <monochrom> it is not prudent to ignore types
14:43:24 <arkeet> :t \bs xs -> [ x | (b,x) <- zip bs xs, b ]
14:43:25 <lambdabot> [Bool] -> [t] -> [t]
14:43:48 <facepalm> FreeFull: that gives type error
14:44:18 <FreeFull> facepalm: Where are you getting filtermask from?
14:44:26 <arkeet> @let when' b x = guard b >> return x
14:44:28 <arkeet> :t when'
14:44:29 <lambdabot>  Defined.
14:44:30 <lambdabot>     Not in scope: when'
14:44:30 <lambdabot>     Perhaps you meant `when' (imported from Control.Monad.Writer)
14:44:31 <facepalm> its another function I wrote
14:44:32 <arkeet> :t when'
14:44:34 <lambdabot> MonadPlus m => Bool -> b -> m b
14:44:38 <FreeFull> Also, what's the error
14:44:38 <facepalm> I will show it to you
14:44:59 <arkeet> :t catMaybes .: zipWith when'
14:45:00 <lambdabot> [Bool] -> [a] -> [a]
14:45:06 <facepalm> couldnt match expected type
14:45:26 <FreeFull> Just paste the code and the full error
14:45:28 <hpaste> facepalm pasted “Haskell function” at http://hpaste.org/87036
14:45:53 <hpaste> facepalm pasted “Haskell function” at http://hpaste.org/87037
14:46:01 <facepalm> sorry that onehas the error in it too
14:46:22 <FreeFull> Ok, I see the problem. You'll have to either use .: instead of . or do    sumTrues xs = sum . filterTrues xs
14:46:55 <arkeet> . composes functions of a single argument.
14:47:25 <arkeet> filterMask (\m d -> m) takes two arguments
14:47:39 <tac> arkeet: Ah, but all functions are of one argument in the right lens :)
14:47:41 <nebnesknarf> skyflash: only a last remark: hedging against things that may come up in the future (like accessing state from multiple threads) may not be the best idea, i'd rather re-factor if and when this actually becomes an issue.
14:47:45 <monochrom> sumTrues xs1 xs2 = sum (filterTrues xs1 xs2)
14:47:54 <arkeet> tac: such pedantry doesn't help with pedagogy here I think :)
14:48:03 <tac> maybe not!
14:48:17 <facepalm> FreeFull: which is better to use?
14:48:35 <arkeet> I would write what monochrom wrote.
14:48:51 <FreeFull> I would use xs and ys instead of xs1 and xs2
14:48:56 <arkeet> that too
14:49:17 <monochrom> I reserve ys for "output" e.g., ys = map f xs
14:49:18 <FreeFull> I don't like having numbers in identifiers for some reason =P
14:49:35 <FreeFull> monochrom: Do you ever use zs?
14:49:43 <monochrom> I don't know yet
14:49:53 <facepalm> sumTrues xs = sum . filterTrues xs
14:50:06 <facepalm> this works withouth the use of the ys
14:50:21 <FreeFull> I think I've used as before but I've never used zs
14:50:38 <arkeet> facepalm: but that has some weird asymmetry
14:50:53 <FreeFull> arkeet: Because it's not pointfree
14:50:57 <skyflash> nebnesknarf: I agree in principle.  Mostly I'm trying not to embark on using methods/idioms that are generally regarded as poor practice to begin with - when there are generally accepted preferred approaches.
14:51:14 <arkeet> I like sumTrues = (.)(.)(.) sum filterTrues
14:51:25 <FreeFull> That looks just weird though
14:51:27 <facepalm> what is meant by point free?
14:51:27 <arkeet> =)
14:51:31 <FreeFull> And is harder to understand
14:51:44 <arkeet> facepalm: when you write code without explicit function arguments
14:51:47 <hpc> @let totalRecall = (.)(.)(.)
14:51:49 <lambdabot>  Defined.
14:51:52 <arkeet> then it's pointfree.
14:52:10 <facepalm> my filter trues function is supposed to be point free
14:52:15 <monochrom> I like to know why filtermask wants two lists not one, and why sumTrues wants to use filtermask.
14:52:25 <arkeet> h x = f (g x)  is not pointfree, since there is a point, namely x
14:52:27 <FreeFull> http://www.haskell.org/haskellwiki/Pointfree    Article on it
14:52:29 <arkeet> h = f . g is pointfree
14:52:32 <FreeFull> facepalm: It is
14:52:47 <Arrmand> I'm getting this error "Couldn't match expected type `(Int, Int)' with actual type `Game -> (Int, Int)'" ...how can I use the 'Game -> (Int, Int)' as a normal (Int, Int)?
14:52:56 <arkeet> Arrmand: you can't.
14:52:59 <FreeFull> Arrmand: Give it a Game
14:53:09 <arkeet> ok, sure.
14:53:42 <hpc> arkeet: your function contains (Int, Int) in the same way that /bin/ls contains a list of files
14:53:47 <hpc> you have to run it first ;)
14:53:50 <arkeet> =)
14:54:00 <facepalm> monochrom: filtermast is meant to accept a function a mask list and a data list
14:54:07 <hpc> er
14:54:10 <geekosaur> Armand, that's telling you it expects a function, not an (Int,Int). which may mean you have not enough or too many parameters somewhere
14:54:13 <hpc> Arrmand: what i said
14:54:37 <hpc> geekosaur: other way
14:55:06 <geekosaur> mm, right, you are passing a function instead of calling it
14:55:21 <geekosaur> which may instead mean you are missing parentheses, come to think of it
14:55:45 <FreeFull> I would write    filtermask = map snd . filter fst .: zip
14:56:04 <geekosaur> ```somefunc (nextmove game)``` and ```somefunc nextmove game``` are not the same thing
14:56:20 <facepalm> that one line will do everything I have ? lol
14:57:11 <FreeFull> facepalm: Yep, or   filtermask xs = map snd . filter fst . zip xs    if you don't want the .:
14:57:29 <facepalm> it tells me .: is out of scope lol so Ill try the other one
14:57:50 <hpc> (.:) = (.)(.)(.)
14:57:57 <FreeFull> .: is in several libraries
14:58:04 <FreeFull> hpc: Probably would want to set fixity too
14:58:05 <arkeet> please don't import a library just for .:
14:58:32 <FreeFull> arkeet: What if it's just a library of higher-level functions
14:58:39 <nebnesknarf> :t \xs -> map snd . filter fst . zip xs
14:58:40 <lambdabot> [Bool] -> [b] -> [b]
14:58:54 <arkeet> well, I guess if you're writing an application then it shouldn't really matter.
14:59:13 <arkeet> but pulling in an extra dependency for a one-liner seems like a waste
14:59:18 <Arrmand> Well I have a function that takes x and y as Int and then a record that includes (x, y) tuples... what I'm trying to do is test if one of the tuples in the record matches the x and y given to the function in question. So how do I compare them? Now I have '(x, y) == tuplename' but it's giving me the abovementioned error
14:59:37 <arkeet> Arrmand: tuplename isn't a tuple.
14:59:49 <Arrmand> How do I access that tuple
14:59:51 <arkeet> it's a function.
15:00:03 <arkeet> presumably a function Game -> (Int,Int)
15:00:10 <arkeet> so you need to give it a Game if you want a (Int,Int)
15:00:22 <Arrmand> Oh. tuplename recordname
15:00:27 <facepalm> FreeFull: doing it that way and using the examples I am given for testing doesnt work
15:00:29 <Arrmand> Thanks! :D
15:00:32 <FreeFull> Arrmand: There you go
15:00:42 <FreeFull> facepalm: Hmm
15:01:01 <Arrmand> I have to say, I tried to dig up the answer from everywhere, as it felt like I was missing some basic record syntax (as I was)... but that isn't mentioned anywhere
15:01:04 <FreeFull> facepalm: Oh, right
15:01:11 <FreeFull> facepalm: Yours takes a function
15:01:31 <arkeet> record accessors are functions.
15:02:32 <facepalm> FreeFull: correct it does
15:02:55 <Arrmand> If you have to read between the lines to understand the most basic level tutorial, it isn't much of a tutorial
15:04:00 <FreeFull> Maybe then   filtermask p xs ys = map snd . filter fst . zip (zipWith p xs ys) ys
15:04:15 <FreeFull> :t \p xs ys -> map snd . filter fst . zip (zipWith p xs ys) ys
15:04:16 <lambdabot>     Couldn't match expected type `a0 -> [(Bool, b0)]'
15:04:16 <lambdabot>                 with actual type `[(a1, b1)]'
15:04:16 <lambdabot>     In the return type of a call of `zip'
15:04:33 <FreeFull> Hmm
15:04:40 <FreeFull> Oh, right
15:04:44 <FreeFull> :t \p xs ys -> map snd . filter fst . zip (zipWith p xs ys) $ ys
15:04:45 <lambdabot> (a -> b -> Bool) -> [a] -> [b] -> [b]
15:04:53 <FreeFull> Yeah, that looks right
15:05:22 <FreeFull> facepalm:   filtermask p xs ys = map snd . filter fst . zip (zipWith p xs ys) $ ys
15:05:42 <FreeFull> facepalm: Sorry for not reading your code more closely
15:05:48 <nebnesknarf> Arrmand: I agree. Which tutorial did you read?
15:06:17 <FreeFull> Hmm, that probably could be made more concise
15:07:34 <FreeFull> :t filterWith
15:07:37 <lambdabot>     Not in scope: `filterWith'
15:07:37 <lambdabot>     Perhaps you meant one of these:
15:07:37 <lambdabot>       `IM.filterWithKey' (imported from Data.IntMap),
15:07:53 <monochrom> there is no tutorial that addresses all thinking errors
15:08:04 <facepalm> FreeFull: is there a way to get it to work for filterTrues without calling filtermask on it? before I had filterTrues = (\m d -> m) but all it would give me is the true false true that I typed into my first list
15:09:19 <nebnesknarf> monochrom: How to use records in Haskell is far from obvious IMO, just think about the strange update syntax
15:09:24 <Ghoul_> > let f p xs ys -> map snd . filter fst . zip (zipWith p xs ys) $ ys in f (++) [1..] [5..]
15:09:26 <lambdabot>   can't find file: L.hs
15:09:44 <Ghoul_> Uh, what.
15:09:46 <Ghoul_> > let f p xs ys -> map snd . filter fst . zip (zipWith p xs ys) $ ys in f (++) [1..] [5..]
15:09:47 <lambdabot>   <hint>:1:15: parse error on input `->'
15:09:56 <Ghoul_> > let f p xs ys = map snd . filter fst . zip (zipWith p xs ys) $ ys in f (++) [1..] [5..]
15:09:58 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Bool)
15:09:58 <lambdabot>    arising from the literal `1...
15:10:28 <latro`a_> how does one zipWith ++ two number lists
15:10:28 <FreeFull> Ghoul_: Expects an  a -> b -> Bool
15:11:25 <Ghoul_> :t zipWith
15:11:27 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
15:11:34 <Ghoul_> :t filter
15:11:36 <lambdabot> (a -> Bool) -> [a] -> [a]
15:11:52 <FreeFull> facepalm: You could write filterTrues without filterMask as     filterTrues xs = map snd . filter fst . zip xs     (although that's obviously not pointfree)
15:12:02 <h4199> facepalm: What is it precisely that you want to do with sumTrues? Do you want to sum the values that were left after your "filtermask"
15:12:07 <FreeFull> facepalm: Seems I accidentally gave you the code for filterTrues instead of filtermask earlier
15:13:10 <facepalm> h4199: I want the sum of the result of filterTrues
15:13:11 <nebnesknarf> Arrmand: what monochrom means (I think) is that you would have to specify from which record the field should be taken; and this would be so in any programming language, regardless of the concrete syntax
15:14:05 <Ghoul_> :t zip
15:14:06 <facepalm> FreeFull: is that one liner for filtermask still point free? i
15:14:07 <lambdabot> [a] -> [b] -> [(a, b)]
15:14:21 <FreeFull> facepalm: No, it isn't
15:14:35 <facepalm> oh I cant use that then
15:14:58 <FreeFull> facepalm: It could be made point free if you declare a .: or make it uglier
15:15:28 <FreeFull> :t (.) (.) (.) (map snd . filter fst) zip
15:15:29 <lambdabot> [Bool] -> [b] -> [b]
15:15:29 <Arrmand> I've been mostly reading Learn You A Haskell, it's pretty good, but sometimes hard to use as a reference due to its structure. Looking back at it now, I missed the important bit about record members being functions, not "variables", because once records are introduced they're never used in the chapter, only before that part to show what they're a sugaring for
15:15:51 <Arrmand> And when I was using the book as a reference I of course didn't read the entire chapter, but just the part from records onwards
15:16:11 <FreeFull> Arrmand: You could use real world haskell as a reference
15:16:29 <monochrom> real world haskell is not a reference either
15:16:41 <h4199> facepalm: and what precisely should the result of filterTrues be? because it seems like you art trying to sum Booleans not numbers.
15:16:41 <FreeFull> What would be a good reference?
15:16:42 <monoidal> Arrmand: indeed. Haskell syntax for declaring records might be misleading. You write data A = A { x :: Int }, but actually x :: A -> Int, not x :: Int.
15:16:51 <monochrom> http://www.haskell.org/onlinereport/haskell2010/ is a good reference
15:16:52 <arkeet> FreeFull: the report, ghc docs, library docs
15:17:04 <h4199> s/art/are
15:17:07 <FreeFull> h4199: I don't see the problem
15:17:12 <nebnesknarf> Arrmand: that's probably because 'records' in Haskell are a poor excuse for not having real records
15:17:35 <hpc> records in haskell were an afterthought, i read
15:17:42 <simpson> nebnesknarf: What, if I may ask, is a "real record?" >:3
15:17:45 <FreeFull> That's what I read too
15:17:51 <hpc> it was something like "hey, doing this is annoying" on the mailing list
15:17:58 <hpaste> facepalm pasted “Haskell function” at http://hpaste.org/87041
15:18:04 <hpc> then a guy hacked it into the compiler of the time and it stuck
15:18:14 <facepalm> h4199: there is it working correctly and its output
15:18:20 <hpc> but there was never any care to make it better because very few people used records
15:18:26 <facepalm> it is
15:18:39 <nebnesknarf> simpson: for a start, you should be able to use the same field name in different record types
15:19:07 <FreeFull> facepalm: (.) (.) (.) (map snd . filter fst) zip   is a pointfree filterTrues but a bit ugly
15:19:20 <adas> in a pattern guard it seems like I can either use a qualifier or a Bool ... but this fact is not mentioned in the documentation for Ghc 7.6 . Did I misunderstand something or this fact mentioned somewhere int he docs?
15:19:27 <nebnesknarf> The question has been discussed to death on mailing lists, I wouldn't want to repeat all that here
15:19:28 <simpson> nebnesknarf: How should this be done? What would the scoping rules look like for field names?
15:19:47 <simpson> nebnesknarf: I'm pretty convinced that there is no such thing as a "real record", unless you're talking about vinyl.
15:20:01 <facepalm> yeah thats confusing to me I am still a noob at this haskell jazz
15:20:05 <nebnesknarf> simpson: go to the ghc wiki and search for "records", the design space is amazing
15:20:08 <haasn> simpson: haha
15:20:27 <haasn> classy lenses are the real records of the future!
15:20:40 <simpson> nebnesknarf: I'm well aware.
15:20:42 <nebnesknarf> simpson: ;-)
15:21:11 <h4199> facepalm: Ah, I see.
15:22:30 <nebnesknarf> haasn: I was about to say something like that ;-)
15:22:39 <FreeFull> What about Vinyl?
15:22:47 <Arrmand> The Haskell report seems a bit too abstract for me at this point, Real World Haskell seems interesting though as it has actual code examples, I'll try and use it as a secondary source when I don't get LYAH :)
15:22:54 <Arrmand> Anyway, thanks everyone for help
15:23:08 <nebnesknarf> FreeFull: i think it's ugly
15:23:17 <facepalm> h4199: with this  filtermask(\m d -> m) does the -> mean equal to?
15:23:30 <arkeet> @arrmand
15:23:30 <lambdabot> Unknown command, try @list
15:23:32 <arkeet> @arr mand
15:23:33 <lambdabot> Keelhaul the swabs!
15:23:43 <monochrom> no. it is punctuation two separate arguments and body
15:23:49 <arkeet> facepalm: it's part of the lambda syntax
15:24:15 <monoidal> \m d -> m means the same thing as "f" when you define f m d = m
15:24:31 <Ghoul_> > "test" -> putStrLn
15:24:33 <lambdabot>   <hint>:1:8: parse error on input `->'
15:24:43 <facepalm> because for a seperate function it say is true if mask items are different
15:24:46 <nebnesknarf> FreeFull: i don't know why but lens simply looks more like "real Haskell code"
15:25:52 <h4199> facepalm: In this case it means that it will take m from your first list and d from your second list and return the m, since m is a bool, your filtermask functions can use that bool to filter unwanted values. Does that make sense?
15:25:54 <edwardk> the main problem i have with vinyl is that overlapping instance based code tends to be very brittle as it inherently relies on the type checking rather than type inference. this means you wind up needing more signatures than you want, its harder to try out in ghci, etc.
15:25:57 <facepalm> for example filterDiffs["a", "B", "Z"] ["A", "B", "C"] returns ["A", "C"]
15:26:29 <Ghoul_> :t vinyl
15:26:31 <lambdabot> Not in scope: `vinyl'
15:27:02 <edwardk> this is a general gripe about 'data types a la carte approaches' though
15:27:20 <edwardk> vinyl just gets painted with that broad brush
15:27:33 <Ghoul_> :t flip
15:27:37 <lambdabot> (a -> b -> c) -> b -> a -> c
15:27:40 <Ghoul_> :t (reverse . flip)
15:27:45 <lambdabot>     Couldn't match expected type `[a0]'
15:27:45 <lambdabot>                 with actual type `b0 -> a1 -> c0'
15:27:45 <lambdabot>     Expected type: (a1 -> b0 -> c0) -> [a0]
15:27:55 <Ghoul_> :t (flip . reverse)
15:27:56 <lambdabot>     Couldn't match expected type `a0 -> b0 -> c0'
15:27:57 <lambdabot>                 with actual type `[a1]'
15:27:57 <lambdabot>     Expected type: [a1] -> a0 -> b0 -> c0
15:28:03 <facepalm> h4199: yes I think this makes sense what you said
15:28:30 <edwardk> ghoul: reverse wants one arg, not sure how that should work in either regard =)
15:28:47 <nebnesknarf> edwardk: yes. for the same reason I have problems with the regex-* libraries, I hate to give extra type annotations to explain what I want (instead of documenting what I do)
15:29:00 <Ghoul_> In another channel someone told me that reverse was the same as flip, but I can't emulate it so I'm not going to bother understanding how it works
15:29:01 <FreeFull> edwardk: I think Ghoul_ is just typing random stuff into lambdabot rather than taking it to ghci
15:29:13 <FreeFull> Ghoul_: Reverse isn't the same as flip at all
15:29:19 <FreeFull> :t reverse
15:29:20 <FreeFull> :t flip
15:29:21 <lambdabot> [a] -> [a]
15:29:23 <lambdabot> (a -> b -> c) -> b -> a -> c
15:29:43 <FreeFull> > reverse [1,2,3,4]
15:29:46 <lambdabot>   can't find file: L.hs
15:29:49 <FreeFull> > reverse [1,2,3,4]
15:29:50 <lambdabot>   [4,3,2,1]
15:30:23 <FreeFull> > flip map [1,2,3] (+1)
15:30:26 <lambdabot>   [2,3,4]
15:30:40 <Ghoul_> > map [1..3] (+1)
15:30:41 <arkeet> < flip map
15:30:42 <lambdabot>   Couldn't match expected type `a0 -> b0' with actual type `[t0]'
15:30:54 <Ghoul_> > map (+1) [1..3]
15:30:56 <lambdabot>   [2,3,4]
15:30:58 <Arrmand> Is there a way to compare a single tuple with each tuple in a list, in a guard
15:30:59 <Ghoul_> Oh, I see.
15:31:11 <h4199> facepalm: the filterDiffs probably is a function that looks like this filtermask (\x y -> x /= y) so that it only returns true when the values from the two lists are not equal.
15:31:21 <FreeFull> Arrmand: Maybe elem
15:31:30 <ParahSai1in> @let (╯°□°)╯︵ ┻━) = flip
15:31:30 <lambdabot> Plugin `eval' failed with: Enum.toEnum{Word8}: tag (9531) is outside of bounds (0,255)
15:31:55 <FreeFull> yourtuple `elem` xs
15:32:03 <Arrmand> Oh of course
15:32:29 <nebnesknarf> Arrmand: a guard is just an expression of type Bool
15:32:58 <facepalm> that fails
15:33:22 <hpc> @src otherwise
15:33:23 <lambdabot> otherwise = True
15:34:27 <monochrom> I do not understand "compare one tuple with many tuples". should "compare (1,1) with (3,2) (1,1) (4,5)" be True? False?
15:34:31 <monochrom> and why?
15:35:47 <arkeet> should it even be a Bool?
15:36:00 <FreeFull> > and ([False] ++ repeat True)
15:36:02 <lambdabot>   False
15:36:16 <arkeet> [False] ++
15:36:48 <FreeFull> Oh, right, False :
15:37:05 <facepalm> h4199: gives me ambiguous type variable error it didnt like  /=
15:39:59 <h4199> facepalm: hmm, not sure, try declaring your types
15:48:50 <facepalm> h4199: I had my types declared before but then it doesnt work with all my test cases because some of them are mix and match of numbers and letters
15:51:24 <nebnesknarf> facepalm: you cannot make Haskell do dynamic typing by using type classes
15:51:37 <facepalm> h4199: I had my types declared before but then it doesnt work with all my test cases because some of them are mix and match of numbers and letters
15:54:02 <h4199> facepalm: Try declaring them like so filterdiffs::[a] -> [a] - [a].
15:54:04 <nebnesknarf> facepalm: data MyInputData = Number Int | Letter Char
15:56:34 <facepalm> h4199: one of my test cases for filtermask is $ filtermask (\m d -> d < m) (replicate 10 6) [1..10] what does the $ mean?
15:56:58 <facepalm> it runs fine without the $ but throws parse error with it
15:57:26 <ab9rf> $ is function application
15:57:26 <Botje> $ filtermask ... sounds wrong.
15:57:33 <ab9rf> f $x === f x
15:57:35 <Botje> are you sure there's nothing in front of the $ ?
15:57:48 <Botje> or maybe your instructor means for $ to represent your ghci rpompt
15:57:54 <ab9rf> but $ has the lowest precedence, so it's really just a way to avoid parens
15:58:01 <cmccann> my GHCi prompt is better.
15:58:04 <ab9rf> there is no point to a leading $, and it would be wrong.
15:58:11 <h4199> facepalm: I think your professor screwed up
15:58:14 <facepalm> the entire test case looks like this   assertEquals "filterMask base case returned wrong list." [] $ filtermask (\m d -> m) [] ([] :: [Int])
15:58:26 <facepalm> h4199: its from a script that will test them all at once
15:58:46 <Clint> @pl assertEquals "filterMask base case returned wrong list." [] $ filtermask (\m d -> m) [] ([] :: [Int])
15:58:47 <lambdabot> assertEquals "filterMask base case returned wrong list." [] (filtermask const [] ([] :: [Int]))
15:59:03 <ab9rf> facepalm: it's being used to avoid putting parentheses around the last argument to assertEquals
15:59:19 <facepalm> oh ok so I dont have to worry about it when I am doing my tests then
15:59:26 <ab9rf> f a b c $ g d e f === f a b c (g d e f)
15:59:35 <Botje> facepalm: well, you should just run the test script and see what happens :)
15:59:52 <facepalm> im not completely finished with the whole program yet
16:00:42 <ab9rf> no program is ever completely finished :)
16:00:44 <facepalm> I have a just a few more functions to write then I have to write some classes lol
16:00:58 <facepalm> and then it makes the game battleship :)
16:02:05 <lightquake> if i have f x y = let …. in f x z, and x is used nowhere in …, should that be a warning under -Wall?
16:02:07 <Botje> you could isolate the tests for filterMask and already run those
16:02:13 <lightquake> (it isn't, but the question is: should it be?)
16:02:31 <ab9rf> lightquake: hlint may warn for that, but it's not "wrong"
16:02:49 <lightquake> ab9rf: i'd argue it's as wrong as an unused variable is
16:03:11 <ab9rf> lightquake: the main oncern is that you may have a typo
16:03:25 <monochrom> x is used in "f x z". that is good enough for me
16:03:40 <lightquake> ab9rf: what do you mean?
16:04:07 <ab9rf> lightquake: if you have an identifier that is bound but never used that creates the concern that you may have failed to use it becaue of a typo :)
16:04:13 <ab9rf> lightquake: that's why compilers warn you of such things
16:04:16 <monochrom> in fact I do not see why "..." must use every bloody parameter in scope
16:04:37 <ab9rf> they don't actually care if bound identifiers are eventually used
16:04:43 <ab9rf> it's not _their_ concern
16:05:37 <lightquake> there's tons of stuff that ghc doesn't care about that it still warns you about
16:05:55 <lightquake> (with -Wall)
16:06:01 <monochrom> that is why I turn off -Wall
16:06:08 <ab9rf> yes. well, ghc is a cranky, tempestuous tyrant
16:06:36 <monochrom> only a few make sense such as non-exhaustive pattern matching
16:07:39 <monochrom> and hlint is even more ridiculous than -Wall. my choice of names is none of its business. my choice of pointful or pointfree has my reasons and again none of its business.
16:07:52 <facepalm> I still have to write filterDiffs and  joinDiffs
16:08:14 <facepalm> then the classes should al be able to just use the functions I created I am guessing
16:08:28 <monochrom> anyway if I write a 10-line function of 3 parameters I do not expect anything to warn me "you didn't use the 2nd parameter in line 4"
16:10:18 <nebnesknarf> monochrom: i mostly agree, and even though non-exhaustive patterns are a good reason to give a warning, it is not a good idea to silence them by adding _ -> error "..." cases, since this makes it awfully hard to pinpoint the location of the error if it happens
16:12:47 <lightquake> nebnesknarf: that's your fault for writing bad error messages, though
16:12:54 <lightquake> :P
16:14:44 <nebnesknarf> lightquake: so what is the better error message they should have used instead of "Prelude.tail: empty list"
16:15:01 <facepalm> I am trying to get to work the filterDiffs but even declaring the types it still doesnt like the /=
16:15:49 <lightquake> nebnesknarf: what i'm saying is that if you just do error "impossible", of course you're going to have a hard time tracking it down
16:17:38 <ab9rf> > fix error
16:17:40 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
16:18:02 <nebnesknarf> lightquake: so how do you track down "Prelude.tail: empty list"?
16:18:35 <ab9rf> i tend to use error messages like "narf" and "fuck" and "fucknarf"
16:18:44 <ab9rf> as long as they're all distinct you can figure it out
16:18:45 <nebnesknarf> ab9rf: that should go to HWN
16:19:50 <ab9rf> hurricane watch net?
16:19:51 <nebnesknarf> ab9rf: not if you call the function from many places in your program
16:20:42 <lightquake> nebnesknarf: it's not easier/harder to track down than if tail just didn't have a pattern for []
16:21:51 <nebnesknarf> > tail []
16:21:52 <lambdabot>   *Exception: Prelude.tail: empty list
16:21:56 <facepalm> ab9rf: if I do filtermask (\x y -> x /= y) can you see why it would say it doesnt like /= ?
16:22:28 <nebnesknarf> @let mytail (x:xs) = xs
16:22:32 <trescenzi> is there a way to force exceptions to print a stack traces?
16:22:33 <lambdabot>  Defined.
16:22:42 <nebnesknarf> > mytail []
16:22:43 <lambdabot>   *Exception: <local>:4:1-18: Non-exhaustive patterns in function mytail
16:22:55 <byorgey> nebnesknarf: if you want a quote to show up in the HWN you can @remember it, like so:
16:22:58 <byorgey> @remember ab9rf i tend to use error messages like "narf" and "fuck" and "fucknarf". as long as they're all distinct you can figure it out
16:22:59 <lambdabot> Done.
16:24:15 <nebnesknarf> byorgey: thx. btw, i meant the "fix error" + lambdabot's answer which I find a lot funnier ;-)
16:24:54 <adas> can someone please explain to me what problem "view patterns" solve? The docs are a bit unclear. A hint would be usefull too.
16:24:55 <byorgey> nebnesknarf: oh =)  well, that's fairly well-known anyway
16:25:00 <ab9rf> facepalm: my guess is that x and y are of different types, or of the same type of a type that doesn't have an Eq instance
16:25:22 <ab9rf> nebnesknarf: 'fix error' is old
16:25:31 <nebnesknarf> byorgey: never saw it, i was rotfl
16:26:06 <ab9rf> i was impressed by whoever it was who used fix show to generate powers of two
16:26:39 <Taslem> I'm trying to install OpenAL on Windows, and I can't get it to work. Namely, I appear to be missing some OpenAL header files and have no idea how to install them.
16:27:05 <ab9rf> Taslem: getting external libs to work on windows is a right royal pain.
16:27:18 <hpaste> facepalm pasted “Haskell function” at http://hpaste.org/87042
16:27:24 <facepalm> thats the error I get
16:27:35 <ab9rf> Taslem: you have to drop the libs and includes into the right mingw directories inside the haskell platform directory
16:28:06 <ab9rf> Taslem: and they have to be built for mingw, not for MSVC, and for the same version of mingw that's installed with the haskell platform, which is likely not the current one
16:28:13 <nebnesknarf> lightquake: you are right it's not that much more useful, it just pinpoints the location of teh pattern match in the code; what I want is a stack trace
16:28:41 <Taslem> Is there any work being done to make the process easier? Or no interest?
16:28:43 <ab9rf> facepalm: aha, a monomorphism restriction violation
16:28:48 <ab9rf> Taslem: use linux :)
16:29:04 <adas> it says a "view pattern" can be used in place of a "pattern". But does that mean a "view" function needs to be defined for every type defined the "data"?
16:29:05 <byorgey> > map (succ . length) . splitOn "\"" $ fix show
16:29:09 <lambdabot>   mueval-core: Time limit exceeded
16:29:24 <byorgey> come on lambdabot, you can do it
16:29:26 <byorgey> > map (succ . length) . splitOn "\"" $ fix show
16:29:30 <lambdabot>   mueval-core: Time limit exceeded
16:29:34 <ab9rf> Taslem: that, or install a full cygwin environment, then build the entire haskell platform yourself using the cygwin environment
16:29:36 <nebnesknarf> lightquake: but replacing it with an error call is no improvement either IMO
16:29:54 <byorgey> > take 10 . map (succ . length) . splitOn "\"" $ fix show
16:29:57 <lambdabot>   [1,2,4,8,16,32,64,128,256,512]
16:30:15 <Taslem> ab9rf: I think I'll try Linux instead. :3
16:30:33 * hackagebot indexed-do-notation 0.1 - Do notation for indexed monads  http://hackage.haskell.org/package/indexed-do-notation-0.1 (FumiakiKinoshita)
16:30:44 <ab9rf> Taslem: you could also try to build GHC using MSVC....
16:31:04 <arkeet> hmm, I was just thinking about wanting something like indexed-do-notation eariler.
16:31:08 <byorgey> @@ @oeis @run intercalate " " . map show . take 10 . map (succ . length) . splitOn "\"" $ fix show
16:31:10 <lambdabot>  Powers of 2: a(n) = 2^n.
16:31:10 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
16:31:50 <ab9rf> heh
16:32:09 <ab9rf> facepalm: i can understand being confused by the monomorphism restriction
16:32:43 <monoidal> facepalm: you can add a type signature and the error should go away
16:32:54 <ijp> does oeis provide an api, or is it scraping?
16:33:02 * ijp goes to check source
16:33:32 <nebnesknarf> say after me: the MR is evil. repeat 3 times per day.
16:33:36 <byorgey> ijp: it provides an API
16:34:17 <ijp> byorgey: cool, didn't know that
16:34:34 <ab9rf> facepalm: or use a pattern match instead of an anonymous lambda
16:34:58 <facepalm> I did add type signute filterdiffs::[a] -> [a] -> [a]
16:35:47 <cmccann> oeis is one of those things that proves this whole internet thing was worth the hassle
16:35:51 <cmccann> it is a beautiful site
16:40:42 <Cale> There is truly no nobler task than identifying integer sequences
16:40:54 <Cale> (but honestly, I agree, it's awesome)
16:53:44 <jmr> i'm trying to use Data.Binary with my own data type. is there an easy way to do this with deriving ()?
16:53:46 <johnw> is there a way to get cabal build to display absolute paths in its error messages, instead of relative ones?
16:55:06 <jmr> http://stackoverflow.com/questions/8714692/is-there-a-template-haskell-deriving-mechanism-for-data-binary-or-friends seems to indicate yes, but doesn't say how
17:00:40 <jmr> aha. google sent me to the old docs. this is better http://hackage.haskell.org/packages/archive/binary/0.7.1.0/doc/html/Data-Binary.html
17:04:10 <facepalm> ab9rf: when I declare the type filterdiffs :: [a] -> [a] -> [a] it says no instance for (Eq a) is that because I need a variable for my equals case? like filterdiffs x = (\x y -> x /= y) ?
17:04:39 <geekosaur> no
17:05:04 <geekosaur> it's because you need to specify an Eq constraint in your type signature
17:06:50 <facepalm> geekosaur: it needs to return true if the mask item is diff than the data item
17:07:20 <facepalm> I didnt think I would need a type signiture
17:07:35 <geekosaur> tell me, have you ever looked at a Haskell tutorial at all?
17:07:49 <facepalm> of course.
17:07:59 <geekosaur> you need either a type signature, or parameters, or turn off the monomorphism restriction
17:08:14 <geekosaur> and any tutorial would have told you about Eq
17:11:39 <acowley> facepalm: That function definition looks a little strange. Can you elaborate on what you're trying to do?
17:12:44 <hpaste> facepalm pasted “Haskell function” at http://hpaste.org/87043
17:13:28 <facepalm> acowley: this is to partially use filtermask function  and returns true if mask item is diff from data item
17:14:01 <facepalm> filterDiffs ["my", "favourite", "colour", "is"] ["my", "favorite", "color", "is"] returns favorite and color
17:15:04 <acowley> I don't think filterdiffs makes sense: You take two parameters x and y, but then return the result of applying filtermask to a lambda that shadows x and y. filtermask will give you a [a] -> [a] -> [a], but you've called it [a] in the type of filterdiffs
17:16:18 <acowley> Note that the x and y you bind on the lhs of filterdiffs are never used anywhere. This should be a warning sign that things have gone astray!
17:20:26 <hiptobecubic> Has anyone tried to do anything at all with the QuantLib bindings in hquantlib?
17:22:42 <facepalm> acowley: so if I understand correctly my x and y params are the data list and mask list correct? and I want to return the differences found in the mask list compared to data list
17:23:42 <acowley> facepalm: We don't need to get into the semantics to see that something's wrong. The types don't line up!
17:24:33 <facepalm> I am trying to understand the problem so that I can attempt to figure out a solution
17:24:36 <acowley> facepalm: Do you see that the x and y on the lhs of filterdiffs are unused bindings?
17:25:07 <acowley> The lambda expression on the rhs binds its own x and y
17:25:09 <facepalm> I thought the x and y's i have on the rhs were using those on the lhs
17:25:35 * hackagebot toysolver 0.0.5 - Assorted decision procedures for SAT, Max-SAT, PB, MIP, etc  http://hackage.haskell.org/package/toysolver-0.0.5 (MasahiroSakai)
17:26:27 <acowley> No, bindings go inside-out: You keep going up through expressions until you find a place where the identifier is bound. In this case, the expression "x /= y" has two free variables, x and y. We go up one level to the expression that contains that equality test and find "\x y -> x /= y" and that is where the x and y in "x /= y" are bound
17:32:07 <ab9rf> @pl (\x y -> x /= y)
17:32:07 <lambdabot> (/=)
17:32:39 <ab9rf> so why do filtermask (\x y -> x /= y) when you can just do filtermask (/=) ?
17:33:51 <acowley> Better question is why bind x and y on the lhs of filterdiffs? The lambda is noisier than need be, but not wrong in and of itself.
17:34:03 <ab9rf> acowley: yes
17:34:35 <ab9rf> especially since they're being shadowed in the lambda
17:36:11 <acowley> I suppose http://learnyouahaskell.com/higher-order-functions is the closest coverage of this subject in LYAH.
17:40:35 * hackagebot text 0.11.3.1 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.3.1 (BryanOSullivan)
17:53:23 <koninkje> Does anyone know if there's a "beam" datastructure on hackage anywhwere?
17:53:47 <koninkje> i.e., keep track of the top-N things, with low-valued things falling off the end
17:54:31 <ab9rf> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:beam
17:55:28 * koninkje was thinking "beam" a la beam-search; not sure if there's a proper name for this sort of queue
17:55:40 <ion> koninkje: I suppose you could use Data.Set for that rather easily. Pick the pivot element with elemAt and use split.
18:00:32 <sclv> koninkje: isn't a list perfectly cromulent for this?
18:01:07 <hiptobecubic> indubitably
18:01:24 <koninkje> sclv: it's not very efficient. We need to keep things in order and would like to insert in O(log n) rather than O(n)
18:01:44 <koninkje> ...or better than O(log n) if possible; but O(log n) is the bare minimum...
18:02:34 <hiptobecubic> sequence has that complexity doesn't it?
18:02:41 <hiptobecubic> the 2-3 finger trees
18:03:34 <koninkje> that might work
18:03:58 * koninkje was hoping someone had already packaged this up, instead of having to roll her own
18:04:38 <hiptobecubic> well you want sorted data with O(log n) access and insert?
18:04:40 <cmccann> is it bad that I'm actually considering putting comments in the empty space left of a layout block?
18:04:55 <cmccann> I hate wasted space like that :[
18:05:20 <ijp> that's, er, different?
18:05:46 <cmccann> legal syntax, though!
18:05:56 <cmccann> cf. http://hpaste.org/86610
18:06:03 <koninkje> hiptobecubic: and things automatically falling off the end of the queue as necessary; also, ideally, already handling the item vs quality of item stuff
18:07:51 * koninkje afk
18:08:15 <hiptobecubic> koninkje, shouldn't be that hard though? Sequence as o(1) append on both ends
18:08:17 <facepalm> ab9rf: I talked to another student in my class and he said that you have to get the joinDiffs function to work then filterDiffs = filtermask (\x y -> x /= y) will work apparently without of the monomorphism error because joinDiffs changes filterDiffs type sig
18:08:55 <ab9rf> facepalm: mmm
18:09:58 <facepalm> ab9rf: joinDiffs accepts mask and data list and concats data values that are different from mask values seperated by a newline
18:10:43 <ion> cmccann: hah
18:11:03 <cmccann> ion: I think that discovery was arkeet's fault, so you can blame him.
18:11:33 <cmccann> I said that comments are whitespace as per the report and he asked about layout and it went downhill from there
18:12:18 <ijp> I assume it was more work to specify this away
18:12:23 <hpc> cmccann: you mean you can write inner hanging comments?
18:12:45 <hpc> longName = do x <- blahblah
18:12:51 <cmccann> hpc: look at the hpaste
18:12:52 <hpc>               ...
18:12:54 <hpc> oh
18:13:08 <hpc> that's awesome
18:13:32 <ion> We should have a right-to-left “--”
18:13:32 <cmccann> ijp: I suppose so, since it's just tracking the column position of tokens and since comments are legal whitespace it makes sense
18:13:40 <cmccann> ion: hahahaha
18:14:05 <hpc> ion: i vote for using the RLO character in there somewhere
18:14:06 <cmccann> ion: I'd suggest either || or ++ for the visual pun but we kinda need those for other purposes
18:14:16 <ion> ←←
18:14:22 <cmccann> haha
18:14:22 <gwern> @quote
18:14:23 <lambdabot> add says: qebab I tried Perl once, then it flattened a list I made
18:14:24 <hpc> why have it be visually different from left-to-right --?
18:14:44 <hpc> perl's list flattening is my favorite feature, fwiw
18:14:51 <ion> U+2010 HYPHEN
18:14:54 <ion> ‐‐
18:15:03 <hpc> diabolical
18:15:10 <hpc> add it to the h' trac!
18:15:31 <cmccann> yes do that
18:15:39 <cmccann> this is a beautiful idea
18:15:44 <ion> verily
18:16:26 <ion> λ> let a ‐‐ b = a * b in 10 ‐‐ 20
18:16:29 <ion> 200
18:19:02 <Rotaerk> what does λ> do differently from >
18:19:15 <cmccann> that's just his GHCi prompt
18:19:28 <Rotaerk> oh
18:19:32 <luite> λ> makes ion do the calculations in his head
18:19:37 <Rotaerk> lol
18:20:17 <ijp> ion: that's brilliant
18:20:23 * cmccann is still using "∀x. x ⊢" for his prompt, because why not.
18:20:48 <Rotaerk> heh
18:20:58 <arkeet> heh
18:21:07 <ijp> ion: of course, what happens if you do "foo -- bar ‐‐ baz"
18:21:20 <ijp> presumably 1) only bar is commented out, or 2) foo and baz are commented out
18:21:36 <arkeet> why not just use -}
18:21:49 <ijp> right, so 2) is the better choice
18:22:39 <arkeet> no, I mean instead of ‐‐
18:22:42 <acowley> Pretty sure ಠ_ಠ is reserved for uses like this
18:22:56 <arkeet> although I guess that would mess with nesting.
18:23:21 <arkeet> then why not }}
18:23:33 <arkeet> hmm, that's no good either.
18:24:31 <cmccann> arkeet: why not ⦄?
18:24:40 <cmccann> that's currently a lexical error, so it's not already used.
18:24:41 <arkeet> I see a box.
18:24:45 <arkeet> ah.
18:24:49 <cmccann> ok. get a better font, then.
18:24:56 <arkeet> I pasted it into a thing with a better font.
18:24:57 <cmccann> it's a fancy unicode }}.
18:25:02 <arkeet> that would be difficult to type.
18:25:07 <ijp> it is RIGHT WHITE CURLY BRACKET
18:25:31 <arkeet> ..unless vim has a digraph for it.
18:25:39 <cmccann> my editor turns }} into ⦄ when I press ctrl-B, because unicode.
18:26:03 <cmccann> it's important for me to be able to type code points that aren't even valid lexemes in Haskell, clearly.
18:26:15 <arkeet> > generalCategory '⦄'
18:26:16 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
18:26:18 <arkeet> argh
18:26:20 <arkeet> < generalCategory '⦄'
18:26:24 <goodfellow>   mueval-core: Time limit exceeded
18:26:28 <arkeet> =(
18:26:31 <arkeet> < generalCategory '⦄'
18:26:33 <goodfellow>   ClosePunctuation
18:27:19 <cmccann> open and close punctuation characters are lexical errors in Haskell for the most part
18:27:24 <cmccann> with the obvious exceptions
18:28:01 <monochrom> that's too bad. because "iI f x y Ii" which is f<$>x<*>y could use ⟦f x y⟧
18:28:05 <arkeet> circle: you should set up your client to identify before joining channels. see http://freenode.net/faq.shtml#nicksetup
18:28:13 <monochrom> < generalCategory '⟦'
18:28:14 <goodfellow>   OpenPunctuation
18:28:44 <cmccann> monochrom: alas, it cannot be so.
18:28:56 <monochrom> oh well, f<$>x<*>y is not too hard to type, I'll cope
18:29:26 <monochrom> Heaven would be jealous if Haskell were perfect :)
18:29:43 <circle> arkeet: why?
18:30:15 <DigitalKiwi> cause you have a nice shiny cloak but we still know your ip
18:30:30 <arkeet> circle: because http://pastebin.com/jNDHCtLz
18:30:32 <DigitalKiwi> cause you joined before you identified
18:30:50 <mauke> The paste jNDHCtLz has been copied to http://hpaste.org/87044
18:30:53 <arkeet> augh
18:30:58 <cmccann> haha
18:31:00 <circle> interesting
18:31:16 <circle> il try work it out in a while]
18:33:22 <monochrom> I think not too many users care. because I see a lot of users let that happen to themselves.
18:34:02 <ab9rf> yeah, ghosting _after_ you join actually serves to draw attention to your IP instead of concealing it
18:34:11 <ab9rf> i use IPv6 anyway
18:34:24 <ab9rf> which confuses most people
18:35:22 <ab9rf> i have multiple v6 addresses on this computer but i've had no luck convincing irssi to use the one i want it to
18:36:39 <esxx> I'm looking for a clean way to compose predicates, something exactly like .&&. from this so answer: http://stackoverflow.com/a/841931
18:36:58 <arkeet> compose how?
18:36:59 <esxx> <&&> from control.conditional does the same, http://hackage.haskell.org/packages/archive/cond/0.4.0.2/doc/html/Control-Conditional.html
18:37:14 <arkeet> (.&&.) = liftA2 (&&)
18:37:22 <cmccann> esxx: what's wrong with the code in that answer?
18:37:26 <esxx> but it says liftM2 (&&) won't short circuit "in the monad"
18:37:35 <arkeet> ah, well there's not much you can do about that.
18:37:42 <arkeet> aside writing your own special short-circuiting version.
18:37:43 <esxx> cmcann wondering if that's alreaday a part of some library or there's a more general way
18:38:05 <cmccann> oh, that's more complicated if you want it to do control flow in a monad
18:38:09 <shachaf> arkeet: Isn't it awful? :-(
18:38:14 <arkeet> no
18:38:19 <esxx> liftA2 (&&)
18:38:22 <arkeet> obviously the answer is that <&&> is the right thing to start with
18:38:24 <arkeet> and then we obtain && from it
18:38:36 <esxx> looks totally reasonable, will that not short circuit the way I expect?
18:38:40 <cmccann> shachaf: oh! did you see the amazing syntax that arkeet and I discovered? it is so cool.
18:38:45 <arkeet> esxx: it will not
18:38:49 <shachaf> arkeet: Do you feel like doing some Core-diving and optimizing alterF to get the last 10%? I bet it's possible.
18:38:52 <shachaf> cmccann: Nope.
18:38:54 <arkeet> it will "run" both actions in any case.
18:38:55 <cmccann> shachaf: http://hpaste.org/86610
18:38:59 <monochrom> so use <&&>
18:39:00 <esxx> interesting
18:39:31 <arkeet> esxx: any use of Applicative is like this. you can never choose which actions to run with only Applicative stuff.
18:39:33 <shachaf> cmccann: You can indent with comments?
18:39:42 <monochrom> liftM2 and liftA2 were never meant to short-circuit. in fact, we expect them to never short-circuit.
18:39:43 <arkeet> shachaf: comments are whitespace.
18:39:49 <shachaf> cmccann: Brilliant! Finally we have an answer to tabs vs. spaces!
18:39:58 <arkeet> we do?
18:40:05 <shachaf> I propose that all code be indented with poetry.
18:40:08 <cmccann> :D
18:40:09 <arkeet> =)
18:40:24 <monochrom> what is indent with poetry? example?
18:40:36 <cmccann> monochrom: {- poetry goes here -}
18:40:47 <cmccann> because comments are whitespace
18:40:52 <monochrom> oh!
18:41:44 <monochrom> well actually, it is not so much "comment is whitespace" as "de-layout looks at column numbers"
18:41:52 <Rotaerk> let f{--}x{--}y{--}={--}x{--}+{--}y{--}+{--}5
18:41:58 <Rotaerk> dangit, I missed one
18:42:00 <sellout-> monochrom: Yeah, that was going to be my comment.
18:42:19 <sellout-> That example looks fine to me. Columns line up, the end.
18:42:22 <DigitalKiwi> haiku or sonnet will be the new debate
18:42:35 <cmccann> monochrom: both, really. comments are valid anywhere whitespace is, and they don't change the column of the code after them
18:42:41 <hpaste> facepalm pasted “Haskell function” at http://hpaste.org/87045
18:42:54 <monochrom> clearly, it ought to be Chinese 5-syllable poems!
18:42:58 <cmccann> it just never occurred to me before that you could put comments to the left of a layout block like that.
18:43:17 <cmccann> DigitalKiwi: what about limericks?
18:43:17 <facepalm> can anyone see why I would be getting type error with my joinDiffs function?
18:43:50 <esxx> thanks arkeet
18:43:59 <esxx> much appreciated
18:44:52 * shachaf notes that pragmas don't behave like comments at all.
18:45:03 <arkeet> really?
18:45:29 <cmccann> shachaf: that sounds like a bug. you should complain.
18:45:36 <arkeet> you mean we can't indent with pragmas?
18:45:43 <shachaf> arkeet: They get their own semicolons and everything?
18:45:49 <arkeet> ??
18:45:55 <shachaf> foo :: ...; foo = ...; {-# INLINE foo #-}; {-# ... #-}
18:46:08 <shachaf> They have to be indented to the right level and all that, too.
18:46:14 <cmccann> I mean, I can't think of anywhere better to put an inline pragma than to the left of a layout block in the function it applies to.
18:48:33 <shachaf> arkeet: imo your homework is to go Core-diving hth
18:49:06 <arkeet> no, I've had it with homework.
18:49:23 <shachaf> http://www.haskell.org/pipermail/libraries/2013-May/019763.html
18:49:39 * shachaf vanishes in a puff of orange smoke.
18:52:01 <dmwit> tdh, nothachaf
18:53:07 <cmccann> dmwit: so where do you stand on the issue of what manner of poetry to indent with
18:53:12 <cmccann> it is a very important issue.
18:53:20 <DigitalKiwi> lol
18:53:59 <dmwit> Wait, "comments don't change the column of the code after them"?
18:54:02 <dmwit> That doesn't sound right.
18:54:15 <cmccann> dmwit: badly phrased perhaps
18:54:31 <cmccann> the column is what it is, no matter what kind of whitespace is to the left
18:54:41 <cmccann> a ten-character comment is equivalent to ten spaces
18:54:57 <dmwit> mmm
18:55:11 <dmwit> I guess the real way to say that is that all non-tab characters count as one space...?
18:55:18 <dmwit> (even ones in comments)
18:55:23 <cmccann> dmwit: cf. http://hpaste.org/86610 if you didn't see it yet
18:55:35 <arkeet> did we figure out what tabs in comments did?
18:55:52 <dmwit> Surely it jumps to the next tabstop, like tabs anywhere else.
18:55:57 <cmccann> arkeet: yes remember http://ircbrowse.net/browse/haskell/?id=15572370&timestamp=1366924051#t1366924051
18:56:06 <arkeet> ah right
18:56:36 <dmwit> Confirmed: tabs in comments are not special.
18:56:59 <dmwit> I do computer science! With experiments and everything!
18:57:06 <dmwit> I even had a hypothesis.
18:57:12 <cmccann> dmwit: yay, science!
18:58:08 <dmwit> http://media.tumblr.com/tumblr_lsx1vlxrSw1qg25cc.gif
18:58:48 <DigitalKiwi> how'd you get that picture of me
18:59:52 <arkeet> dmwit: not special, meaning they jump to the next tabstop?
19:00:04 <dmwit> yes
19:16:01 <copumpkin> > bwt banana
19:16:03 <lambdabot>   [Just (Just 'a'),Just (Just 'b'),Just (Just 'a'),Just Nothing,Nothing,Just ...
19:16:10 <copumpkin> hmm
19:16:14 <copumpkin> that seems wrong
19:16:19 <copumpkin> oh, nevermind
19:16:21 <copumpkin> > bwt "banana"
19:16:23 <lambdabot>   [Just 'a',Just 'n',Just 'n',Just 'b',Nothing,Just 'a',Just 'a']
19:16:28 <copumpkin> > unbwt (bwt "banana")
19:16:30 <lambdabot>   "banana"
19:16:39 <copumpkin> > unbwt (bwt "foobarbazboo")
19:16:41 <lambdabot>   "foobarbazboo"
19:18:26 <monochrom> > bwt "abcde"
19:18:29 <lambdabot>   [Just 'e',Nothing,Just 'a',Just 'b',Just 'c',Just 'd']
19:19:15 <copumpkin> unbwt = catMaybes . fromJust . find (isNothing . last) . last . snd . unzip . ap zip (ap (iterate . (. sort) . zipWith (:)) (map pure))
19:19:24 <copumpkin> not the most elegant implementation possible though
19:20:12 <monochrom> there is no limit to human craziness
19:22:24 <cmccann> copumpkin: it's completely pointless, that's almost the same thing as elegance, right
19:22:30 <copumpkin> yeah
19:22:38 <copumpkin> well, I'd like to golf it more
19:22:42 <copumpkin> it's a cute algorithm
19:23:11 <kennyd> @src bwt
19:23:11 <lambdabot> Source not found.
19:23:20 <monochrom> w00t, the committee for Haskell 2014 is formed
19:23:21 <copumpkin> it's also not particularly elegant right now
19:23:39 <copumpkin> bwt = ((((map last.sort).).zipWith(++))<$>tails<*>(init.inits)).(++[Nothing]).map Just
19:23:48 <copumpkin> thinking of moving the Nothing to the front
19:23:53 <cmccann> copumpkin: well running it through @pl wouldn't help so I'm out of ideas.
19:24:07 <cmccann> if there's any other way to make things elegant, I don't know about it.
19:24:11 <copumpkin> lol
19:24:11 <monochrom> yikes, I haven't heard of 1/3 of the committee members
19:24:59 <monochrom> also, where is Haskell Weekly News!
19:25:44 <cmccann> I recognize all but two of the names
19:25:57 <luite> i don't recognize the first two
19:26:33 <ParahSail1n> burrows wheeler?
19:26:38 <copumpkin> ParahSail1n: yeah
19:26:56 <monochrom> oh! Burrows-Wheeler, no wonder.
19:27:00 <cmccann> though some of the names I really only know from "uploaded by" on hackage and/or the headers of messages I didn't read from -cafe
19:27:11 <cmccann> monochrom: what did you think bwt stood for :P
19:27:23 <monochrom> I did not think at all.
19:27:38 <ParahSail1n> i still dont know how bwa or bowtie alignment algorithms work
19:27:41 <copumpkin> > (zipWith (++)<$>tails<*>inits) "banana"
19:27:44 <lambdabot>   mueval-core: Time limit exceeded
19:27:49 <copumpkin> oh come on lambdabot
19:27:50 <ParahSail1n> the bwt part is simple enough
19:27:52 <cmccann> monochrom: tch. surely you didn't expect that copumpkin would give a function a completely meaningless three-letter name!
19:27:55 <copumpkin> oh come on lambdabot
19:27:57 <copumpkin> > (zipWith (++)<$>tails<*>inits) "banana"
19:27:59 <lambdabot>   ["banana","ananab","nanaba","anaban","nabana","abanan","banana"]
19:28:39 <facepalm> dmwit: could you take a peek at this and see if you can tell why joinDiffs is yelling at me about type? filterDiffs and joinDiffs are my last 2 functions lol and I have been working on them for hours
19:28:43 <copumpkin> > head . transpose . sort . (zipWith (++)<$>tails<*>inits) $ "banana"
19:28:45 <lambdabot>   "aaabbnn"
19:29:12 <copumpkin> > head . transpose . sort . (zipWith (++)<$>tails<*>inits) . (:Nothing) . map Just $ "banana"
19:29:14 <lambdabot>   Couldn't match expected type `[a0]'
19:29:14 <lambdabot>              with actual type `Data.May...
19:29:24 <facepalm> http://pastebin.com/FMf4wqyB
19:29:25 <cmccann> copumpkin: that looks like a good implementation
19:29:27 <copumpkin> > head . transpose . sort . (zipWith (++)<$>tails<*>inits) . (Nothing:) . map Just $ "banana"
19:29:29 <lambdabot>   [Nothing,Nothing,Just 'a',Just 'a',Just 'a',Just 'b',Just 'n',Just 'n']
19:29:44 <copumpkin> > head . transpose . sort . init . (zipWith (++)<$>tails<*>inits) . (Nothing:) . map Just $ "banana"
19:29:45 <mauke> The paste FMf4wqyB has been copied to http://hpaste.org/87046
19:29:46 <lambdabot>   [Nothing,Just 'a',Just 'a',Just 'a',Just 'b',Just 'n',Just 'n']
19:29:58 <copumpkin> > last . transpose . sort . init . (zipWith (++)<$>tails<*>inits) . (Nothing:) . map Just $ "banana"
19:30:00 <lambdabot>   [Just 'a',Just 'n',Just 'n',Just 'b',Nothing,Just 'a',Just 'a']
19:31:00 <copumpkin> > (last<$>) . sort . init . (zipWith (++)<$>tails<*>inits) . (Nothing:) . map Just $ "banana"
19:31:02 <lambdabot>   [Just 'a',Just 'n',Just 'n',Just 'b',Nothing,Just 'a',Just 'a']
19:31:08 * copumpkin moves to PM again
19:32:49 <h4199> facepalm: You cannot concatenate a Bool and a String
19:33:32 <h4199> @ty "\n"
19:33:33 <lambdabot> [Char]
19:34:13 <h4199> @ty x /= y
19:34:14 <lambdabot> Bool
19:34:32 <h4199> @ty x /= y ++ "\n"
19:34:34 <lambdabot>     Couldn't match expected type `Expr' with actual type `[Char]'
19:34:34 <lambdabot>     In the second argument of `(++)', namely `""'
19:34:34 <lambdabot>     In the second argument of `(/=)', namely `y ++ ""'
19:34:40 <h4199> see?
19:34:44 <facepalm> yes
19:35:56 <h4199> facepalm: Can I see what an input/output example?
19:36:16 <facepalm> h4199: for join?
19:36:23 <h4199> yeah
19:37:02 <Clint> huh, somebody fixed the spelling of "inferred"
19:37:11 <h4199> the "what" was leftover, sorry
19:37:46 <facepalm> h4199: joinDiffs["a", "B", "Z"]["a", "B", "C"] should return "A\nC\n"
19:38:11 <facepalm> Second list the A should be caps
19:38:12 <facepalm> sorry
19:38:22 <h4199> I get it
19:39:34 <h4199> So what you really want to do is insert a newline between each value that your filterDiff returns and conctenate all of them into a single string?
19:39:36 <sw2wolf> @ty transpose
19:39:38 <lambdabot> [[a]] -> [[a]]
19:39:43 <facepalm> h4199: apparently if I can get that joinDiffs to work then my filterDiffs will work the way it is written now. Idk how that would change anything but i was told it does
19:40:13 <cmccann> is google+ actually worth using? I usually ignore whatever the latest form of social networking annoyance is, but people in the haskell community appear to actually be using it for worthwhile things occasionally...
19:40:30 <facepalm> h4199: yes with foldl and a lambda concatenator
19:43:15 <h4199> He specifically wants a left fold and a lambda?
19:43:21 <facepalm> yes
19:44:16 <facepalm> Assemble the results with a call to foldl and a lambda concatenator (83 characters 1 case)
19:44:50 <h4199> Have you looked at some other folds and thought about how you might write it?
19:45:05 <h4199> in LYAH
19:45:22 <facepalm> yes
19:45:45 <kludgy> Hi all. Anyone able to help with a beginner space leak?
19:46:52 <Ghoul_> space leaks? What's that in haskell?
19:47:03 <h4199> facepalm: If that is so, then can you tell me what is wrong with how you have written the fold for joinDiffs?
19:47:25 <facepalm> I tried something like this too joinDiffs = foldr (\x y -> y : x) but it doesnt have the concat it
19:47:34 <Cale> kludgy: Quite possibly
19:47:55 <Cale> Hard to know without seeing the code
19:48:10 <h4199> facepalm: First off, what do you think x and y are in the context of your input?
19:48:14 <cmccann> Ghoul_: basically the same as "space leaks" in any GC'd language
19:48:38 <kludgy> Basically I seem to be piling up a huge amount of memory in the idle function here, but cannot figure out why: https://github.com/Kludgy/glasteroids/blob/master/src/Main.hs
19:49:08 <cmccann> Ghoul_: i.e. stuff what oughtta be garbage but ain't 'cuz something somewhere still has a reference to it
19:50:08 <facepalm> I think it is trying to fold together my first and second list
19:50:17 <facepalm> so I probably am in need of filter also
19:50:17 <Cale> kludgy: Try putting a ! before GLfloat in the definition of State, and then putting one immediately before the s in the definition of idle and adding {-# LANGUAGE BangPatterns #-} to the top
19:50:33 <kludgy> Cale: I'll give it a go
19:50:39 <Cale> oh, I just noticed modifyIORef'
19:50:51 <kludgy> oh?
19:50:55 <Cale> That's going to help, you might not need the bang pattern
19:51:04 <Cale> But you'll probably need the strict field anyway
19:51:11 <kludgy> ok trying anyway
19:51:27 <facepalm> but if x /=y is a boolean then shouldnt it fold together where letters in x do not equal letters in y?
19:51:28 <Cale> Because seq will only evaluate an expression up to determining the top-level constructor
19:51:35 <Cale> i.e. in this case, State
19:51:46 <Ghoul_> cmccann: are there any examples of how that could happen anywhere?
19:51:58 <Cale> So you'll still be able to build up a large expression in the shipAngle field
19:52:57 <cmccann> Ghoul_: consider something like (length xs)
19:53:10 <kludgy> Cale: Oh great pointer thanks! Unfortunately I have to rebuild my cabal environment here before trying the change..
19:53:15 <cmccann> if xs is a large list which is forced by some other expression, it ends up in memory
19:53:37 <Ghoul_> The list is duplicated just for its length?
19:53:37 <h4199> facepalm: Ok, backing up, what does your filterDiff produce?
19:53:38 <Cale> Ghoul_: In kludgy's case, the space leak is caused by larger and larger expressions being built up inside a data structure and not being evaluated despite the type of the expression being GLfloat
19:53:45 <cmccann> Ghoul_: but if you never force the (length xs) expression there's still a reference to the whole list
19:53:57 <cmccann> Ghoul_: whereas after forcing it, the length is computed and the list can be GC'd
19:54:03 <Cale> kludgy: You shouldn't need the BangPatterns extension if it helps
19:54:17 <Ghoul_> Ah, so lazyness is the culprit
19:54:19 <Cale> kludgy: Just do the first bit where you put a ! before the GLfloat
19:54:41 <facepalm> h4199: if working properly then filterDiffs["a", "B", "Z"]["A", "B", "C"] would return ["A", "C"]
19:54:58 <cmccann> Ghoul_: sort of. like I said, you get the same issue in any GC'd language if you misplace a reference to some large value
19:55:18 <cmccann> Ghoul_: it's just easier to do that without realizing it when laziness is involved
19:55:39 <h4199> facepalm: Right, and if you feed that into your fold then how many lists would fold receive?
19:56:15 <facepalm> just one which would be the result of filterDiffs correct?
19:57:22 <kludgy> Cale: I'll give that ago as soon as I sort out my dependency conflicts. Appreciate the help!
19:57:24 <facepalm> otherwise 2 lists if it has to actually calculate the result first i
19:58:54 <monochrom> it is so lazy to blame everything on laziness :)
19:59:03 <h4199> facepalm: It will be one, fold works on a single list with a function and an initial value
19:59:40 <h4199> facepalm: so the x and y are not values from two lists
20:00:05 <kludgy> Cale: Yes the space leak is gone. Amazing
20:00:32 <cmccann> monochrom: no, that is being eager to blame laziness. being lazy would mean not blaming anything until forced to do so.
20:00:45 <h4199> http://learnyouahaskell.com/higher-order-functions#folds
20:01:03 <monochrom> but humans are usually forced to blame something
20:01:32 <kludgy> Cale: So is the trick here indeed in understanding that seq stops evaluation at the constructor?
20:01:48 <cmccann> monochrom: usually due to scattering seq everywhere in hopes of accidentally fixing the problem, though.
20:03:00 <cmccann> monochrom: surely without seq, blame is only forced given incontrovertible evidence of guilt!
20:05:51 <facepalm> h4199: so I can do something like joinDiffs y ys = foldl(\filterDiffs x -> if x /= y then True else filterDiffs) False ys ? kinda like example from that link?
20:07:07 <h4199> What on earth is \filterDiffs?
20:07:39 <copumpkin> > 5
20:07:41 <lambdabot>   5
20:07:44 <copumpkin> > bn
20:07:47 <lambdabot>   [Just 'a',Just 'n',Just 'n',Just 'b',Nothing,Just 'a',Just 'a']
20:07:55 <facepalm> I was under the impression you had to pass it the function. my brain is pretty much toast right now lol sorry
20:07:56 <copumpkin> lambdabot is failing a lot
20:10:08 <h4199> Ok, well, all you need to do is assume you have an input list of strings and figure out how to make them into a single string with newlines inserted, forget about filterDiffs for now, just try to write something that will work on any list of strings
20:10:57 <sw2wolf> @ty unlines
20:10:58 <lambdabot> [String] -> String
20:12:09 <h4199> > foldl1 (++) ["understand", "this", "first"]
20:12:11 <lambdabot>   "understandthisfirst"
20:13:16 <smatic__> hello all
20:14:23 <h4199> sw2wolf: he has to use a fold and a lambda, otherwise that would have been where I directed him
20:14:32 <ab9rf> intercalate " " ["understand", "this", "first"]
20:14:35 <ab9rf> > intercalate " " ["understand", "this", "first"]
20:14:40 <lambdabot>   mueval-core: Time limit exceeded
20:14:50 <ab9rf> odd
20:15:04 <ab9rf> > intercalate 0 [1]
20:15:07 <lambdabot>   No instance for (GHC.Num.Num [a0])
20:15:07 <lambdabot>    arising from a use of `e_101'
20:15:07 <lambdabot>  Possib...
20:15:07 <h4199> She is sick today
20:15:30 <ab9rf> :t intercalate
20:15:34 <lambdabot> [a] -> [[a]] -> [a]
20:16:01 <ab9rf> > intercalate [0] [[1],[2]]
20:16:04 <lambdabot>   [1,0,2]
20:16:14 <ab9rf> > intercalate " " ["understand", "this", "first"]
20:16:16 <lambdabot>   "understand this first"
20:16:19 <ab9rf> there, better
20:16:29 <ab9rf> poor lambdaboot
20:17:18 <copumpkin> @undef
20:17:21 <facepalm> h4199: I understand that
20:17:22 <copumpkin> @def bwt = (last<$>).sort.init.(zipWith(++)<$>tails<*>inits).(Nothing:).(Just<$>)
20:17:22 <lambdabot> Maybe you meant: bf do let
20:17:28 <copumpkin> @let bwt = (last<$>).sort.init.(zipWith(++)<$>tails<*>inits).(Nothing:).(Just<$>)
20:17:30 <Rotaerk> > intercalate [0,1,2] [[3,4],[5,6]]
20:17:33 <lambdabot>  Defined.
20:17:33 <copumpkin> @let unbwt = catMaybes.head.foldr((sort.).zipWith(:))(repeat[]).(replicate=<<length)
20:17:34 <lambdabot>   mueval-core: Time limit exceeded
20:17:38 <lambdabot>  Defined.
20:17:44 <copumpkin> I think those work
20:18:04 <copumpkin> > unbwt (bwt "foobarbaz")
20:18:06 <lambdabot>   "foobarbaz"
20:18:30 <h4199> facepalm: now what you have to do is write a lambda that adds the "\n" between, do you think you can do that?
20:19:15 <ab9rf> @src intercalate
20:19:16 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
20:19:25 <ab9rf> @src intersperse
20:19:26 <lambdabot> intersperse _   []     = []
20:19:26 <lambdabot> intersperse _   [x]    = [x]
20:19:26 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
20:19:48 <ab9rf> @src kittens
20:19:48 <lambdabot> Source not found. You type like i drive.
20:20:19 <ab9rf> > take 25 $ intersperse 0 [1..]
20:20:23 <lambdabot>   [1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13]
20:21:08 <facepalm> h4199: yes I think I would add the "\n" in with the (++)
20:22:23 <h4199> right so with (\acc x -> ...) what would you write?
20:22:56 <facepalm> h4199: what is intercalate
20:23:03 <ab9rf> i am always leery of using (++)
20:23:17 <h4199> It is a library function that I assume that you cannot use
20:23:33 <h4199> also...
20:24:07 <h4199> > unlines ["A","C"]
20:24:11 <lambdabot>   mueval-core: Time limit exceeded
20:24:14 <h4199> > unlines ["A","C"]
20:24:15 <lambdabot>   "A\nC\n"
20:24:28 * ab9rf tosses lambdabot a scooby snack
20:24:30 <h4199> as sw2wolf mentioned
20:24:50 <ab9rf> h4199: that's not quite right
20:25:11 <ab9rf> h4199: not supposed to have that last trailing newline
20:25:54 <h4199> h4199: joinDiffs["a", "B", "Z"]["a", "B", "C"] should return "A\nC\n"
20:26:02 <h4199> earlier
20:26:18 <facepalm> that is correct
20:28:16 <ab9rf> h4199: oh, i missed that
20:28:20 <ab9rf> heh
20:28:23 <ab9rf> @src unlines
20:28:23 <lambdabot> unlines = concatMap (++ "\n")
20:28:30 <ab9rf> hah
20:29:46 <erisco> :t concatMap
20:29:48 <lambdabot> (a -> [b]) -> [a] -> [b]
20:29:51 <facepalm> foldl(\acc x -> ++ "\n")
20:30:39 <h4199> facepalm: look again at LYAH, where do you want the acc and the x to go?
20:33:17 <ab9rf> if you put a variable on the left of the -> in a lambda, you probably should use it somewhere on the right too....
20:33:30 <ab9rf> if you don't, you should ask yourself why you put it there in the first place
20:33:35 <copumpkin> yay
20:33:40 <ab9rf> coyay
20:33:48 <copumpkin> I wrote a real compressor and decompressor in two tweets
20:33:58 <copumpkin> @let compress = map(length&&&head).group.(last<$>).sort.init.(zipWith(++)<$>tails<*>inits).(Nothing:).(Just<$>)
20:33:59 <lambdabot>  Defined.
20:34:00 <ab9rf> copumpkin: get it down to one
20:34:06 <copumpkin> @let decompress = catMaybes.head.foldr((sort.).zipWith(:))(repeat[]).(replicate=<<length).(uncurry replicate=<<)
20:34:07 <lambdabot>  Defined.
20:34:19 <copumpkin> > decompress (compress "this is haskell")
20:34:21 <lambdabot>   "this is haskell"
20:34:23 <ab9rf> copumpkin: rle?
20:34:36 <copumpkin> partly
20:34:59 <ab9rf> > compress "this is haskell"
20:34:59 <copumpkin> > compress "fobfobfobfobfoofoofabfubfobobf"
20:35:02 <lambdabot>   can't find file: L.hs
20:35:03 <lambdabot>   [(1,Just 'l'),(2,Just 's'),(1,Just 'h'),(1,Just 'k'),(1,Just ' '),(1,Just '...
20:35:11 <h4199> > compress ("Is this Haskell")
20:35:15 <lambdabot>   [(1,Just 'l'),(2,Just 's'),(1,Just ' '),(1,Nothing),(1,Just 'H'),(1,Just 'k...
20:35:38 <ab9rf> meh, fire up ghci
20:35:40 <copumpkin> > max . compress $ "fobfobfobfobfoofoofabfubfobobf"
20:35:42 <lambdabot>   *Exception: show: No overloading for function
20:35:48 <copumpkin> > maximum . compress $ "fobfobfobfobfoofoofabfubfobobf"
20:35:50 <lambdabot>   (5,Just 'f')
20:36:01 <copumpkin> see, it found lots of repetitions of 'f'
20:36:02 <facepalm> foldl(\acc x ->  acc =/ x ++ "\n") but I need a starting value on on outside on the right
20:36:08 <copumpkin> even though there are no contiguous 'f' values
20:36:18 <facepalm> paired with my list that I can call xs I guess
20:36:46 <h4199> Nothing in the assignment about not having values on the right, right?
20:36:58 <ab9rf> huh
20:36:59 <lispy> hello
20:37:05 <ab9rf> my ghci instance rejects uncompress
20:37:09 <facepalm> correct
20:37:27 <dmwit> > compress "foobar"
20:37:31 <lambdabot>   mueval-core: Time limit exceeded
20:37:34 <dmwit> > compress "foobar"
20:37:37 <lambdabot>   [(1,Just 'r'),(1,Just 'b'),(1,Just 'o'),(1,Nothing),(1,Just 'o'),(1,Just 'f...
20:37:46 <dmwit> > compress "foo"
20:37:49 <lambdabot>   [(1,Just 'o'),(1,Nothing),(1,Just 'o'),(1,Just 'f')]
20:38:06 <h4199> facepalm: anyway try joinDiffs . filterDiffs [your] [lists]
20:38:06 <dmwit> > compress "oooo"
20:38:08 <lambdabot>   [(4,Just 'o'),(1,Nothing)]
20:38:09 <ab9rf> no instance for (Monad ((->) [Maybe a0]))
20:38:13 <ab9rf> what am i missing?
20:38:19 <dmwit> Control.Monad.Instances
20:38:19 <copumpkin> Control.Monad.Instances
20:38:25 <copumpkin> I hate that orphan instance
20:38:42 <ab9rf> ah, thank ye
20:38:50 <Cale> kludgy: yes, that's right
20:39:33 <Cale> kludgy: In general, evaluating an expression will generally mean putting it in the form of a constructor applied to some arguments (which might be unevaluated expressions), or else a lambda.
20:39:56 <dmwit> copumpkin: [(1, Just 'o'), (1, Nothing), (1, Just 'o'), ...] just seems... wrong =P
20:40:00 <ab9rf> eh, uses (&&&)
20:40:04 <ab9rf> isn't that from lens?
20:40:04 <copumpkin> dmwit: how come?
20:40:09 <copumpkin> ab9rf: Control.Arrow
20:40:13 <dmwit> just looks funny
20:40:20 <h4199> facepalm: hopefully that works and you can sleep or eat or something.
20:40:34 <copumpkin> dmwit: well, I'll admit it isn't the most compact serialization format for the output :)
20:40:48 <copumpkin> > length $ compress "fobfobfobfobfoofoofabfubfobobf"
20:40:48 <facepalm> it tells me out of scope.
20:40:50 <lambdabot>   15
20:40:55 <copumpkin> > length $ "fobfobfobfobfoofoofabfubfobobf"
20:40:57 <lambdabot>   30
20:41:09 <copumpkin> then again, I add a count to each of them
20:41:25 <copumpkin> > length $ compress "fobfobfobfobfoofoofabfubfobobffobfobfobfobfoofoofabfubfobobf"
20:41:27 <lambdabot>   17
20:41:27 * dmwit calls foul: each entry in the 15-element list costs at least three words, and each element in the 30-element only costs one!
20:41:34 <copumpkin> > length $ "fobfobfobfobfoofoofabfubfobobffobfobfobfobfoofoofabfubfobobf"
20:41:36 <lambdabot>   60
20:41:47 <dmwit> ah, okay, you just barely pay for yourself by there =P
20:41:49 <ab9rf> copumpkin: hm, ghci tells me compress is type [()] -> [(Int, Maybe ())]
20:41:51 <ab9rf> what am i missing?
20:41:52 <dmwit> okay, bedtime
20:41:58 <dmwit> NoMonomorphismRestriction
20:42:02 <ab9rf> figures
20:42:21 <facepalm> and I still need to use a lambda  and foldl
20:42:36 <copumpkin> > length $ compress (join (replicate 5 "fobfobfobfobfoofoofabfubfobobffobfobfobfobfoofoofabfubfobobf"))
20:42:38 <lambdabot>   17
20:42:42 <copumpkin> that's pretty compressed!
20:42:52 <copumpkin> > length $ compress (join (replicate 50 "fobfobfobfobfoofoofabfubfobobffobfobfobfobfoofoofabfubfobobf"))
20:42:56 <lambdabot>   mueval-core: Time limit exceeded
20:43:00 <copumpkin> > length $ compress (join (replicate 10 "fobfobfobfobfoofoofabfubfobobffobfobfobfobfoofoofabfubfobobf"))
20:43:02 <lambdabot>   17
20:43:12 <copumpkin> > length $ (join (replicate 10 "fobfobfobfobfoofoofabfubfobobffobfobfobfobfoofoofabfubfobobf"))
20:43:14 <lambdabot>   600
20:43:19 <copumpkin> dmwit: good enough for you? :P
20:43:32 <lispy> > length $ compress (join (replicate 20 "fobfobfobfobfoofoofabfubfobobffobfobfobfobfoofoofabfubfobobf"))
20:43:34 <lambdabot>   17
20:44:27 <copumpkin> @let check xs = decompress (compress xs) == xs
20:44:29 <lambdabot>  Defined.
20:44:35 <copumpkin> > check (join (replicate 20 "fobfobfobfobfoofoofabfubfobobffobfobfobfobfoofoofabfubfobobf"))
20:44:39 <lambdabot>   mueval-core: Time limit exceeded
20:44:42 <copumpkin> > check (join (replicate 10 "fobfobfobfobfoofoofabfubfobobffobfobfobfobfoofoofabfubfobobf"))
20:44:46 <lambdabot>   mueval-core: Time limit exceeded
20:44:51 <copumpkin> man, I need a better algorithm :)
20:44:55 <copumpkin> > check (join (replicate 5 "fobfobfobfobfoofoofabfubfobobffobfobfobfobfoofoofabfubfobobf"))
20:44:58 <lambdabot>   True
20:45:39 <lispy> does it work in /msg? You get more evaluation time there, IIRC
20:45:41 <geisthaus> to wit woul using an infinite stream of IO [Bool] be affective to generating a tree algebra that could be flattened to produced a random "shuffle" of a finite list?
20:45:44 <geisthaus> :D
20:45:54 <copumpkin> lispy: it does, but I don't think you get more evaluation time
20:46:03 <copumpkin> at least in my private tinkering it didn't feel like it
20:46:08 <copumpkin> it works in lambdabot at least :)
20:46:15 <hpaste> “Anonymous Coward” annotated “varargs” with “varargs (annotation)” at http://hpaste.org/53290#a87047
20:47:02 <h4199> facepalm: joinDiffs xs = (foldl1 (\acc x -> acc ++ "\n" ++ x) xs) ++ "\n", should suffice no?
20:47:13 <lispy> copumpkin: hmm...okay. I know you get more lines of spew back from lambdabot and for some reason I thought she granted more CPU time too.
20:47:59 <facepalm> h4199: almost :)
20:48:07 <lispy> I don't mean to alarm anyone, but sometimes I misremember things.
20:48:48 <copumpkin> for reference, lispy's replicate 50 output is
20:48:50 <copumpkin> [(101,Just 'f'),(400,Just 'o'),(100,Just 'u'),(100,Just 'o'),(100,Just 'a'),(100,Just 'o'),(1,Just 'b'),(100,Just 'o'),(99,Just 'b'),(99,Just 'f'),(1,Nothing),(400,Just 'b'),(100,Just 'o'),(300,Just 'b'),(500,Just 'f'),(200,Just 'o'),(300,Just 'f')]
20:49:18 <copumpkin> look at all that structure it found
20:49:23 * copumpkin beams
20:49:33 <lispy> copumpkin: what is Nothing?
20:49:38 <facepalm> h4199: now it compiles but it says joinDiffs is applied to two args but its type only has 1
20:49:49 <lispy> copumpkin: eg., could you remove it and get better compression?
20:49:51 <copumpkin> lispy: just a marker so I can figure out how to undo it
20:49:59 <copumpkin> there is a fancier scheme that lets you omit it
20:50:03 <lispy> I see
20:50:09 <copumpkin> but it's not as easy to golf :P
20:51:00 <h4199> facepalm: just guessing, but try joinDiffs . filterDiffs $ [your] [lists] instead, sorry
20:56:11 <facepalm> h4199: thank you for your patience and assistance I appreciate it. that last thing you put I do not understand what it means with that notation. but I felt stupid enough for one day  haha
20:56:36 <h4199> lambdas?
20:57:52 <facepalm> lambdas yes but I have not seen them written that way
21:00:01 <h4199> sum x y = x + y == sum = \x y -> x + y == sum = (+) == sum = \x y -> (+) x y
21:00:49 <h4199> When you are fresh reread the sections on currying and lambdas in your textbook or LYAH
21:01:09 <facepalm> ok ty again.
21:01:20 <h4199> np
21:01:36 <lispy> eta-expansion/reduction, do you speak it?
21:02:02 * lispy can never remember which direction is which, adding formal parameters == expansion?
21:04:08 <arkeet> eta expansion is f  -->  \x -> f x
21:05:21 <arkeet> so you get a bigger term.
21:05:56 <copumpkin> or (fst x, snd x)
21:09:51 <facepalm> h4199: what I was saying I didnt understand wasn't lambdas but writing one like you had it joinDiffs . filterDiffs $ .... lambdas I expect to start with the (\ notation. like you had the first one joinDiffs xs = (foldl1 (\acc x -> acc ++ "\n" ++ x) xs) ++ "\n"
21:10:48 <h4199> uhh joinDiffs . filterDiffs $ ... is not a lambda, it is just function composition
21:12:17 <h4199> so that one function "pipes" into the other, you have done that right?
21:12:42 <facepalm> not so far.
21:13:14 <facepalm> I have written a total of 9 Haskell  functions that properly work
21:13:50 <facepalm> filterDiffs and joinDiffs will be my 10 and 11 if I get them to work :)
21:15:34 <facepalm> thats why I was confused then because I have to write it using the lambda and foldl so when I saw your function composition I thought you were using a different way of writing it with short cuts or something
21:19:44 <h4199> facepalm: Did the composition not work as expected?
21:21:22 <facepalm> no it didnt work it just said out of scope.
21:23:58 <h4199> facepalm: what was out of scope?
21:24:11 <ab9rf> tell it to use listerine instead
21:24:28 * h4199 groans
21:24:56 <facepalm> I do not remember I am looking back to try and find it
21:29:07 <facepalm> filling in the blanks it should look something like this? correct?
21:29:58 <h4199> facepalm: error: "this" is not in scope
21:36:24 <Rileld> Hi all, I'm trying to insert rows into the DB with persistent from a yesod app. Can anyone give me some pointers on how I fix this snippet http://hpaste.org/87050
21:39:32 <shachaf> @where yesod
21:39:32 <lambdabot> #yesod - http://yesodweb.com/
21:40:15 <facepalm> h4199: but yeah that won't work anyways because I do not think he wants us to write it that way. I just now started reading about them and no we never covered it
21:41:31 <kludgy> Cale: Got it. While looking for information on the subject of seq itself, I came across this interesting page: http://www.haskell.org/haskellwiki/Lazy_vs._non-strict
21:42:40 <h4199> facepalm: So you are saying that you are not allowed to compose two functions?
21:42:48 <adas> i think i get what existential types are. But i feel like Im missing something important. Can someone please pen it down in a sentence? If you had to explain existential quantified in one sentence, what would it be?
21:44:19 <h4199> facepalm: you already did that with sumTrues you know...
21:45:08 <facepalm> sumTrues xs ys = sum (filterTrues xs ys)
21:45:29 <kludgy> Cale: What do you think of the merits of haskell compilers with more strict-by-default semantics, such as DDC? I'm sure it must have been discussed ad nauseum at many levels, but I've never read through such a discussion.
21:45:49 <Cale> I dislike strict by default personally.
21:46:03 <h4199> facepalm: right, you composed two functions there
21:46:29 <Cale> Lazy evaluation by default results in better composability and more reusable libraries.
21:48:13 <Cale> http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf -- this might interest you :)
21:49:11 <Cale> A good chunk of that paper is devoted to explaining why lazy evaluation is helpful.
21:49:18 <ab9rf> i question the competency of an instructor who teaches haskell yet tries to prohibit function composition
21:50:10 <Nisstyre-laptop> Cale: I was going through PLAI and it has a reasonable explanation for why you might want lazy evaluation
21:50:30 <Nisstyre-laptop> actually they kind of sneak it in
21:50:37 <h4199> facepalm: If you want you can do something like this.
21:50:45 <hpaste> h4199 revised “pastebin.com/FMf4wqyB”: “options” at http://hpaste.org/87046
21:50:47 <ab9rf> i'd rather have lazy be the general default with the ability to force strictness, than the other way around
21:51:37 <tikhonjelvis> I think it's much easier to introduce strcitness in an otherwise lazy language than vice-versa
21:52:07 <tikhonjelvis> although that could be more because other languages allow side-effects everywhere
21:52:07 <ab9rf> technically the oppose of lazy is eager, not strict
21:52:12 <ab9rf> strict is a separate concept
21:52:15 <tikhonjelvis> right
21:52:38 <kludgy> Cale: Cheers on whyfp90
21:52:40 <Cale> Well, some people and authors also use "strict" to refer to a particular evaluation order.
21:52:53 <h4199> facepalm: You can see why composition is preferred, if nothing else but for succinctness.
21:53:02 <ab9rf> Cale: i think that's partially because eagerness tends to force strictness
21:53:06 <Cale> (while preserving a distinction between "strict evaluation" and "strict semantics")
21:53:07 <kludgy> Cale: Are you using lazy to refer to outside-in evaluation in this discussion?
21:53:38 <facepalm> yes it looks much nicer
21:53:48 <Cale> "Eager" has also been used to refer to some usually-innermost-first evaluation strategies for nonstrict semantics.
21:54:06 <kludgy> interesting
21:54:08 <Cale> kludgy: Lazy evaluation means outermost-first, plus sharing.
21:54:30 <ab9rf> Cale: sharing in this context meaning?
21:54:47 <tikhonjelvis> I usually assume people mean "non-strict" rather than lazy per se, even if they use the word "lazy"
21:55:12 <Cale> ab9rf: Any bound variable is evaluated at most once, and the results of that evaluation shared amongst its occurrences.
21:55:49 <ab9rf> Cale: ok.  you're not talking about CSE optimizations being necessary for that, then
21:55:57 <Cale> When talking about performance, I would usually assume lazy means mostly lazy, with fairly conservative optimisations.
21:56:14 <Cale> no CSE is necessary, or usually implemented for that matter
21:56:38 <facepalm> I appreciate you being patient with my stupidity lol I basically have to learn a new language on the fly every week in this class
21:56:45 <Cale> The only CSE which GHC does, last I checked, was when you had nested case expressions with syntactically identical scrutinees
21:56:49 <kludgy> Cale: I recall an interesting interview with Brian Beckman, "Don't fear the monad" I think it was called? It addressed more of the pragmatic concerns revolving around cherry-picking the benefits of FP and imperative strategies, with a heavy emphasis on guaranteeing composition.
21:56:54 <ab9rf> facepalm: that's not very nice, they really should give you six weeks at least with each langage
21:57:10 <Cale> (which is a case that usually only comes up when desugaring various syntax)
21:57:11 <ab9rf> i hate monads
21:57:24 <ab9rf> not the ocncept
21:57:34 <ab9rf> the fact that everyone obsesses on them
21:57:35 <h4199> facepalm: That is a tall order, and not reasonable for anything but maybe python
21:58:00 <tikhonjelvis> eh, languages like Scheme are certainly easier to learn than Python
21:58:01 <h4199> I want people to obsess with comonads for a change of pace
21:58:07 <kludgy> lol
21:58:22 <tikhonjelvis> maybe even Prolog--it requires a shift in thinking, but is otherwise extremely simple
21:58:26 <facepalm> haha I wish I have learned assembly Ruby Haskell C C++ Java some Dot language for grammars some LOGO and Antlr
21:58:27 <DigitalKiwi> i'd rather learn lua in a week than python
21:58:36 <facepalm> just in one semester
21:58:54 <ab9rf> logo?  people still teach logo?
21:59:12 <tikhonjelvis> my intro CS class had us implement a logo interpreter as the final project
21:59:18 <tikhonjelvis> so we had to learn it for that
21:59:29 <facepalm> not including my web programming class where I have had to learn all the different web technologies in java jsf etc php javascript .net
21:59:34 <ab9rf> tikhonjelvis: i wrote a logo interpreter in ROM BASIC when i was 11
21:59:38 <facepalm> logo was more of something just for fun
21:59:46 <h4199> facepalm: I like the idea of teaching polyglotism, but that is just too fast for anything but surface absorption.
22:00:10 <Rileld> Hi all, I'm trying to insert rows into the DB with persistent from a yesod app. Can anyone give me some pointers on how I fix this snippet http://hpaste.org/87050
22:00:16 <Recursive> @ty (*>)
22:00:20 <lambdabot> Applicative f => f a -> f b -> f b
22:00:30 <shachaf> Rileld: Did you ask in #yesod?
22:00:32 <facepalm> well thats why I don't know the details and guts of much of Haskell. the only haskell I have done is the functions i have written for this assignment and I am basically reading and learning as I go through each one
22:01:00 <facepalm> learning assembly made me want to cut myself lol
22:01:12 <tikhonjelvis> what sort of assembly?
22:01:16 <Rileld> shachaf: ya, I asked there 30 min ago and haven't received a response yet
22:01:31 <facepalm> AT&T
22:01:36 <tikhonjelvis> ah
22:01:56 <Cale> facepalm: If it's any consolation, it took me about 2 months before I really felt like I could get useful things done in Haskell, and about a year before I was really comfortable. That was back around 2001-2002 or so though.
22:02:47 <facepalm> well then I dont feel as dumb I guess. I started this about 2 weeks ago and stopped and did the Ruby assignment for a week then picked this back up again a few days ago
22:02:52 <kludgy> It has taken me significantly longer to grow with Haskell.. mind you I've just been doing broad reading and its not my day job
22:03:28 <tikhonjelvis> the thing is that compared to Haskell, C, C++, Java and (to a lesser extent) Ruby are virtually identical
22:03:54 <kludgy> I do have a lot of good ammo for shooting down javascript, C++ and java for app development now though. Or at least much better software architecture principles as a result of studying :)
22:04:10 <facepalm> now I get to teach myself how to write classes in haskell and program a game in 2 days
22:04:39 <kludgy> facepalm: Is this a self-imposed limit or a competition?
22:04:58 <ion> tikhonjelvis: Someone coined a nice term for them: CLispScript. http://www.jerf.org/iri/post/2908
22:05:03 <facepalm> this is a deadline or no credit lol
22:05:28 <kludgy> ouch. Well I guess the constraints of the problem are simple ;)
22:05:54 <facepalm> so adderall and mountain dew binge time
22:07:18 <Cale> facepalm: If you mean classes in the sense of OO, then there's no built-in support for them. However, I have found it reasonably easy to do object oriented programming in Haskell with one of a couple very lightweight and simple encodings
22:08:46 <Cale> The main idea being that an object is really supposed to be a thing which responds to a certain set of messages somehow, and objects are determined entirely by the manner in which they react to these messages.
22:09:23 <facepalm> an example of the first one I have to write is a type class Row consisting of constructors name A through J write a type class Column consiting of constructor named One thorugh Ten. have both derive Enum, Ord, Show, Eq, and Read.  lol
22:09:35 <Cale> Ah, okay, type classes :)
22:10:13 <Cale> Actually, wait
22:10:15 <tikhonjelvis> those sound more like algebraic data types than typeclasses
22:10:20 <Cale> Those don't sound like type classes at all, yeah
22:10:30 <Cale> Eq and Ord, etc. are type classes
22:11:40 <facepalm> idk wth that even means yet
22:11:44 <Cale> You just want data types, using the 'data' declaration.
22:16:03 <Recursive> Cale: In "data Foo a b = ...", how to use both a and b ?
22:17:12 <Cale> Refer to them on the right hand side of the = sign by using them in the parameter types of the constructor(s) you define
22:17:43 <Cale> (or maybe I don't know what you mean by 'use' here)
22:18:39 <Recursive> Both a and b are called "type parameter" ?
22:18:40 <h4199> Cale: He is making battleships, so they stand for grid positions
22:19:41 <mzero> Recursive: for example...         data FunnyTree w s = Leaf s | Node (FunnyTree w s) w (FunnyTree w s)
22:19:58 <mzero> here there is an s at every leaf, and a w at every node
22:20:23 <Recursive> mzero: then how to use the FunnyTree ?
22:21:03 <Recursive> what's the type of w and s ?
22:21:16 <facepalm> Cale: does this look like it? data Row = A B C D E F G H I J data Column = One Two Three Four Five Six Seven Eight Nine Ten
22:21:24 <mzero> aTree :: Tree Double String        aTree = Node (Leaf "a") 0.33 (Node (Leaf "q") 0.91 (Leaf "r"))
22:21:37 <sellout-> Recursive: Node (Leaf 1) True (Leaf 2) :: FunnyTree Bool Int
22:21:41 <Cale> facepalm: stick some |'s in between each of the constructors
22:21:42 <mzero> Recursive: the idea is that w and s are supplied at time of use
22:21:52 <mzero> in a concrete expression
22:22:20 <facepalm> I see you put deriving enum but I dont see anywhere how to state multipul ones
22:22:25 <Cale> data Hue = Red | Orange | Yellow | Green | Blue | Violet
22:22:26 <Recursive> mzero: same as template function in C++ ?
22:22:34 <mzero> Well - similar
22:22:45 <Recursive> mzero: i see, thx
22:22:45 <mzero> and certainly a reasonable 1st order approximation
22:23:56 <h4199> deriving (Eq, Show, Read, Etc...)
22:31:30 <facepalm> Cale: is this how id make Address and have it take a row and column? data Address = Address(Row)(Column)
22:31:47 <Cale> facepalm: You don't need the parens
22:32:03 <Cale> but yes, that works
22:33:01 <facepalm> cool at least its not overly difficult then
22:33:03 <Cale> That defines a new type called Address with a single data constructor (also called Address), which takes a value of type Row and a value of type Column as parameters
22:33:53 <facepalm> yep thats what I was shooting for
22:35:49 <facepalm> getting close to the end of having the game of Battleship in haskell haha
22:39:36 <facepalm> to make it take a list of something for instance data Ship = Ship [Cell] deriving(Show) and data Ships = Ships [Ships] deriving (Show) correct?
22:40:38 <cmears> maybe that last one should be "data Ships = Ships [Ship]" ?
22:42:05 <facepalm> I have one named Ship and another named Ships lol and it says it takes a list of Ships so I was just guessing it meant the plural version  but you could be correct
22:44:19 <mzero> facepalm: it would be idomatic to just use    type Ships = [Ship]
22:44:42 <mzero> this is just a type synonym (think typedef from C)
22:45:22 <mzero> the extra level of constructor in     data Ships = Ships [Ship]    really doesn't buy you any expressivity or program clarity
22:45:38 <mzero> and just make manipulating the list a bit of a pain in many cases
22:50:52 * hackagebot yesod 1.2.0 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.2.0 (MichaelSnoyman)
22:50:54 * hackagebot yesod-auth 1.2.0 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.2.0 (MichaelSnoyman)
22:52:29 <facepalm> I have to construct and return an address from this toAddress :: Row[1-9] -> Column[1-9].. if infact I wrote this function correctly
22:55:52 * hackagebot yesod-bin 1.2.0 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.0 (MichaelSnoyman)
22:55:54 * hackagebot yesod-core 1.2.0 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.0 (MichaelSnoyman)
22:55:56 * hackagebot yesod-form 1.3.0 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.0 (MichaelSnoyman)
22:55:58 * hackagebot yesod-newsfeed 1.2.0 - Helper functions and data types for producing News feeds.  http://hackage.haskell.org/package/yesod-newsfeed-1.2.0 (MichaelSnoyman)
22:56:00 * hackagebot yesod-persistent 1.2.0 - Some helpers for using Persistent from Yesod.  http://hackage.haskell.org/package/yesod-persistent-1.2.0 (MichaelSnoyman)
22:56:41 <latermuse> what is more difficult to implement on a programming language design level? static or dynamic typing
22:56:57 <simpson> latermuse: Mu.
22:57:11 <latermuse> mu?
22:57:51 <arkeet> http://catb.org/esr/jargon/html/M/mu.html
22:57:56 <mzero> http://en.wikipedia.org/wiki/Mu_(negative)
22:57:57 <simpson> Yeah. Neither is more difficult on some intrinsic level. It's all about the language that you're implementing.
22:58:33 <latermuse> ahh Mu is 无
22:59:02 <arkeet> agh simplified chinese.
22:59:06 <latermuse> I understand. In hindsight I guess it was a pretty broad question.
22:59:14 <simpson> I *really* have to get my Unicode fixed at some point.
22:59:20 <mzero> latermuse: From a /design/ perspective, I've seen dyanic and static typing at both ends of the complexity spectrum
23:00:15 <lispy> latermuse: if you were asking because you are looking for a reason to skip adding static types to a language you are designing, there are good introductory materials for how to implement static types. Eg., don't be afraid to have static types as a feature :)
23:00:44 <mzero> From an /implementation/ perspective, dynamic typing can be done very quickly and easily... but as one wants to add more complex features in the implementation, can often be harder
23:00:51 <hpaste> facepalm pasted “Haskell function” at http://hpaste.org/87052
23:00:56 <latermuse> lispy: im not designing a language. I was just curious
23:01:02 * hackagebot yesod-routes 1.2.0 - Efficient routing for Yesod.  http://hackage.haskell.org/package/yesod-routes-1.2.0 (MichaelSnoyman)
23:01:04 * hackagebot yesod-sitemap 1.2.0 - Generate XML sitemaps.  http://hackage.haskell.org/package/yesod-sitemap-1.2.0 (MichaelSnoyman)
23:01:06 * hackagebot yesod-static 1.2.0 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.2.0 (MichaelSnoyman)
23:01:08 * hackagebot yesod-test 1.2.0 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.2.0 (MichaelSnoyman)
23:01:30 <latermuse> mzero: like php right? they took the easy route in the beginning, and now its just a mess
23:01:41 <facepalm> I need to write function toAddress that takes in a row and a column each  in [0-9] and construct an address and return it. am I setting this up correctly?
23:01:42 <lispy> latermuse: designing languages is fun, so I just assume everyone wants to do that :)
23:02:16 <mzero> well - I was thinking of trying to do program transformations, intellegent IDE support, optimizations, and compilation (even JIT) -
23:02:32 <latermuse> lispy: I do enjoy thinking about language design. Do you have any examples of languages you have designed?
23:02:38 <mzero> doing these thigns in a dynamic language can be very difficult (especially if you are trying to them correctly)
23:03:04 <lispy> latermuse: much in public places, sorry
23:03:25 <lispy> latermuse: autoproc (on hackage) is one that I did early one. It's a eDSL for procmail recipes.
23:03:27 <flebron> This may be a dumb question but, is the ST monad implemented "efficiently" in GHC? That is, will my updates to, say, a Data.Array.Unboxed really be just writing to a memory address?
23:05:11 <mzero> facepalm: what are those [] ?    just   toAddress :: Row -> Column -> Address
23:05:25 <mzero> but you don't need that ... you have it!       toAddress = Address
23:05:26 <mzero> !
23:06:22 <mzero> because the type Address has a constructor (also called) Address --- and constructors act like functions: They take the data and produce a value of their type
23:06:42 <facepalm> says to write a function toAddress that takes a row and column each in [0-9] so thats what I was attempting
23:06:47 <mzero> so...    upperRight = Address A Ten
23:06:55 <latermuse> flebron: You can check out the core dump on your code to see if its doing it that way or not
23:07:01 <mzero> is perfectly normal way to create an Address
23:07:05 * flebron hasn't learned to read that yet :(
23:07:13 <mzero> OH
23:07:28 <mzero> did they perhaps want      toAddress :: Int -> Int -> Address    ????
23:07:49 <facepalm> im not sure. im learning this as I go  lol
23:08:01 <latermuse> flebron: http://book.realworldhaskell.org/read/profiling-and-optimization.html
23:08:02 <mzero> can you see the difference between the signatures?
23:08:07 * lispy >>= bed
23:08:18 <latermuse> lispy is bound to a bed?
23:08:58 <hpaste> facepalm pasted “Haskell function” at http://hpaste.org/87053
23:09:10 <mzero> latermuse: only in the IRC monad....!
23:09:13 <facepalm> mzero: that is the exact instruction
23:09:34 <latermuse> facepalm: homework?
23:09:47 <mzero> well, poorly written for a Haskell problem set - because it uses [ ] in a non-Haskell way
23:10:09 <mzero> but sure, I read that as "takes two integers and returns a value of your Address type"
23:10:14 <facepalm> latermuse: yep...i am only asking questions and learning I am not trying to get anyone to do my homework :)
23:10:33 <mzero> I notice the express hint: "Use toEnum to..."
23:11:00 <facepalm> yeah idk what that is yet
23:11:02 <mzero> alas, the phrase "... to index into your Row and Column enums lists" is just gibberish for Haskell
23:11:11 <mzero> was this a Haskell specific assignment?
23:11:17 <latermuse> yeah this question is pretty garbage
23:11:25 <facepalm> mzero: yes
23:11:30 <latermuse> what does this even mean? each in [0 - 9].
23:11:40 <mzero> Sigh. It is clear your instructor doesn't know Haskell enough to be qualified to teach it.
23:11:51 <facepalm> latermuse: I have no idea lol
23:13:06 <h4199> They are learning a programming language /per week/, so I am not too surprised at the omissions
23:13:13 <arj1> Does anyone of you really use utf8 symbols while coding? I regularly write "delta" in my coder and wondered why not writing the real symbol for delta.
23:13:19 <arj1> -r
23:13:29 <latermuse> a language per week?
23:13:39 <h4199> I set up my editor to insert delta when I type deltaE
23:13:55 <latermuse> that might work with some of the esoteric turing tarpit languages
23:14:02 <smatic__> haskell is the future
23:14:04 <h4199> Vim Emacs and Sublime all can do that kind of thing
23:14:19 <hpaste> mzero annotated “Haskell function” with “Haskell function (annotation)” at http://hpaste.org/87053#a87054
23:14:37 <mzero> there - I reworded it into something that can pass for a Haskell assignment
23:14:57 <latermuse> mzero: that looks about right
23:15:05 <flebron> How would I do something like "While this ST variable is not zero, carry out this action", without explicitly recursing?
23:15:09 <yezariaely> h4199: do you have coworkers working on your code, too? I ran into problems regarding that. And additionally, on terminals, the error message are not always properly formatted when a utf8 symbol occurs.
23:15:19 <yezariaely> How are your expiriences there?
23:15:56 <mzero> flebron: you write a combintor for it --- but not that the combintor will explicitly recurse
23:15:56 <latermuse> flebron: use guards
23:16:16 <mzero> er,  "but note that..."
23:16:34 <Vicfred> where is bonus? :c
23:16:42 <FreeFull> h4199: It tends to be better to have your editor display stuff as UTF-8 symbols but still be the ASCII underneath
23:16:48 <h4199> Yezariaely: Personal stuff only, for the reason you mentioned I leave it in or convert to ASCII everything else.
23:17:34 <yezariaely> FreeFull: that is a nice approach. Didn't know this is possible.
23:18:25 <Rileld> shachaf: ya, I asked there 30 min ago and haven't received a response yet/quit
23:18:39 <h4199> https://github.com/frerich/unicode-haskell
23:19:06 <yezariaely> h4199, FreeFull: thanks for discussion.
23:20:49 <facepalm> so do I have to change my type sig then or is toAddress :: Int -> Int -> Address still correct? do I have to have someting about enum in there
23:21:08 <mzero> facepalm: Yes, that looks right -
23:21:22 <h4199> @ty toEnum
23:21:23 <mzero> your original signature    Row[0-9] doesn't mean anything in haskell
23:21:23 <lambdabot> Enum a => Int -> a
23:21:45 <mzero> (which I why the instructor was a clod for wording the assignment that way)
23:22:24 <mzero> facepalm: can you think of what the difference between    Int -> Int -> Address     and     Row -> Column -> Address     is?
23:22:43 <Rotaerk> hmm, say I have a function foo of signature ((ContextOf Something context) => context -> context), where ContextOf means it has a Something inside it.  (data Something context) then contains, basically, a [context->context], which foo internally composes with its own changes to the context
23:22:43 <h4199> > toEnum 37 :: Char
23:22:45 <lambdabot>   '%'
23:22:55 <flebron> Ah, I think there's whileM in Control.Monad.Loops :)
23:23:09 <facepalm> to me saying Row is specifying a custom type
23:23:11 <Rotaerk> other things within this context that are aware of the existence of the Something can ... add functions to that list
23:23:24 <facepalm> int is just a more broad general number.
23:23:25 <Rotaerk> (this reminds me of events and event handlers in C#, a little)
23:24:13 <Rotaerk> anyone think it would be inappropriate to call this [context->context] an event? (though I'll be making it a new type with the ability to register and unregister "handlers")
23:24:30 <Rotaerk> the event handling libraries I've seen for haskell seem to be oriented around IO events
23:24:35 <mzero> facepalm: No, not quite
23:24:54 <mzero> Int is NOT a more general type -
23:25:09 <mzero> your enum like type Row is NOT like enum in C - it isn't a restriction of Int
23:25:16 <mzero> it is a distinct type
23:43:10 <latermuse> facepalm's teacher is doing more harm than good with this assignment
23:43:49 <latermuse> facepalm might be one in a class of 10-20 kids. and hes the only one to seek out advice on this problem set
23:46:27 <h4199> The entire concept of the class seems tenuous at best
23:46:37 * flebron writes his first ST computation, stares in awe at the state of things. http://hpaste.org/87056
23:47:35 <flebron> Save for some acceptable boilerplate (for the purity of the race^H^H^H^Hlanguage), it doesn't look _that_ much different than the equivalent while (n) { t += n&1; n>>=1; }, in C.
23:48:10 <flebron> Hrm I guess my >>= return . could be made into a fmap.
23:49:06 <flebron> (/= 0) <$> readSTRef n' it is :)
23:49:35 <mzero> flebron: what is whileM_   ?
23:49:51 <flebron> It's from Control.Monad.Loops
23:50:06 <mzero> and... why would you write that using STRef?   it is a simple pure computation?
23:50:14 <h4199> @src Control.Monad.Loops.whileM_
23:50:14 <lambdabot> Source not found. Wrong!  You cheating scum!
23:50:14 <flebron> http://hackage.haskell.org/packages/archive/monad-loops/0.3.0.2/doc/html/Control-Monad-Loops.html#v:whileM_
23:50:29 <flebron> mzero: It's a toy for something a bit more involved I'll write.
23:51:00 <flebron> (A relatively heavy number-crunching computation, that I'd like to use ST with, as opposed to recursion and passing around pure Data.Array.Unboxeds.)
23:51:00 <mzero> er... okay.... as it sits it is both ineffecient and awkward
23:51:17 <mzero> hmmmmm .... okay .....
23:51:23 <flebron> Yes, as all new things do, but it shows promise of a lot of power :)
23:51:29 <flebron> (Without going to the dark side, known as IO.)
23:51:46 <mzero> do you *know* that tail-recursion (even in ST) is going to be a performance problem?
23:52:01 <lightquake> if i have functors Foo and Bar, is there a way for me to say that their composition is a Functor?
23:52:24 <mzero> not sure what composition of functors means here
23:52:40 <flebron> mzero: I'd think it likely, I'll mostly be passing around arrays...
23:53:20 <mzero> if     Foo    is  a functor     then     type FooBar a = Foo (Bar a)      is a Functor just as it sits
23:53:31 <flebron> (I'm also trying to squeeze out performance at any cost here. The program is for a programming competition, and I'm trying to match C code timings.)
23:54:18 <mzero> flebron: I bet not - even if you have a mutable Array (or Vector) you use in ST, doing the control loop via standard tail recursion is likely to be no speed penalty
23:54:44 <flebron> I was planning on using STUArray...
23:54:45 <mzero> heh - besides
23:54:55 <mzero> whileM_ is..... tada.... tail recursive!!!!
23:55:28 <flebron> Of course, there will be recursion, that's the only way to do loops in Haskell.
23:55:47 <flebron> I'm not worried about that, however. I am worried about passing non-ST stuff.
23:55:49 <shachaf> mzero: No it's not.
23:55:58 <fruitFly> addThree x y z = x + y + z  EQUALS addThree = \x -> \y -> \z -> x + y + z  ... Is that because on the right x takes a function that takes a function that takes x y AND z? I'm trying to see it.
23:57:31 <mzero> well.. I think the new hotness in very fast arrays of basic values is Vector ---- and if you are baseing the loop on a single value (/= 0) then I think keeping it in an STRef will just make it all slower
23:57:50 <flebron> Unfortunately the version of GHC that the contest site uses does not have Vector, so I must use Array.
23:58:20 <mzero> okay - but still - why STRef the bit value n'    ?
23:58:26 * BMeph tried to use an STFUArray, but no one would tell him how it worked....
23:59:49 <mzero> >>= sleep
23:59:51 <lightquake> actually, wait, hm
