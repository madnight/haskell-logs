00:07:10 <hrookie> super haskell rookie question - i'd like to export polymorphic type constructors... it doesn't appear to work
00:08:17 <shachaf> It doesn't work? Then I suggest you fix it.
00:08:37 <Cale> hrookie: What do you mean by that?
00:08:42 <shachaf> If you want more details, then you should provide more details. :-)
00:08:55 <shachaf> In particular: * what you did; * what you expected would happen; * what happened
00:09:40 <hrookie> Cale: i have a data type Status = Active Float Float | Inactive Float. If I export Status, I can't access the Active or Inactive constructors
00:09:46 <hrookie> shachaf: got it.
00:10:02 <Cale> hrookie: Put   Status(..)  in your export list
00:10:35 <Cale> Which is equivalent to putting  Status(Active,Inactive)  there.
00:10:36 <shachaf> Status(..), or Status(Active, Inactive)
00:10:54 <shachaf> (I'm not sure what polymorphism has to do with it, though?)
00:11:10 <hrookie> shachaf: if there is only one constructor it doesn't seem to take issue?
00:11:18 <hrookie> shachaf: that or i just haven't run into it
00:11:22 <shachaf> ?
00:11:26 <hrookie> no worries, thanks guys!
00:11:33 <shachaf> "polymorphic" doesn't mean "there are multiple constructors"
00:12:00 <adnap> Cale: mult = \n m -> \zero succ -> n zero (\zero -> m zero succ)
00:12:37 <Cale> adnap: yeah, that works!
00:12:41 <adnap> \o/
00:12:47 <Cale> @let mult = \n m -> \zero succ -> n zero (\zero -> m zero succ)
00:12:49 <lambdabot>  Defined.
00:13:13 <Cale> > showNat (mult two two)
00:13:14 <lambdabot>   4
00:13:17 <Cale> > showNat (mult two three)
00:13:19 <lambdabot>   6
00:13:35 <adnap> Cool
00:13:40 <adnap> My brain is fried
00:14:58 <Cale> adnap: Anyway, the nice thing about this kind of thing is that it means we get relatively easy definitions of useful stuff, at least compared to the Turing machine description of computation.
00:15:28 <adnap> Cale: Is the antecedent of "this" "lambda calculus"?
00:15:34 <Cale> yeah
00:16:34 <adnap> By "Turing machine description of computation", are you referring to the concept of a tape and write head that can move left and right and write zero's and one's?
00:16:44 <Cale> yeah
00:17:06 <adnap> ... and write "empty"
00:17:55 <Cale> Composing Turing machines to make real programs is a lot more awkward than composing lambda terms, and the actual description of Turing machines is about as complex (if not more complex) than saying what lambda terms are and what reductions/conversions are allowed between them.
00:18:09 <Flaeme> Well, goodnight, anyone reading this. Bai~
00:22:31 <blaenk> does something have to be switched in ghc to allow preprocessor conditionals?
00:22:33 <blaenk> #ifdef?
00:22:40 <blaenk> I keep getting lexical error at character 'i'
00:22:43 <shachaf> Yes, CPP.
00:22:44 <blaenk> #(i)fdef
00:22:48 <blaenk> oh okay
00:26:24 <Cale> blaenk: Add the pragma {-# LANGUAGE CPP #-} to the top of your file
00:26:33 <blaenk> Cale: got it, thanks :)
00:27:55 <et09> ok so i just noticed this
00:28:03 <et09> > map (\x -> (x-1)^2 - (x-2)^2) [1..30]
00:28:04 <lambdabot>   [-1,1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,5...
00:28:36 <et09> the set of differences between squares is equal to the set of odd integers
00:28:42 <et09> can someone explain to me why that's boring
00:29:39 <Cale> et09: Picture a square with sides of length n, and extend each side out to n+1
00:29:52 <Cale> er, let me just get a picture for you :)
00:30:09 <et09> oh you're right
00:30:10 <et09> that is boring
00:30:12 <cmears> (n+1)^2 = n^2 + 2*n + 1   --- take away the n^2, you just get 2*n+1, which is the odd numbers
00:30:23 <Cale> et09: You're adding 2*n + 1
00:30:25 <et09> i think i need to sleep
00:31:04 <Cale> et09: It's not what I'd say is *boring*, but it is one of the first proofs you'd be likely to do when starting out in mathematics, and is a nice example to apply induction to :)
00:31:42 <Ndit> wtf
00:31:45 <Ndit> why is there a {-# LANGUAGE CPP #-} ?
00:32:00 <Ndit> what in gods name possessed someone to make it?
00:32:13 <Cale> Ndit: To get ghc to apply its slightly modified version of the C preprocessor to the source.
00:32:15 <blaenk> Ndit: what do you think it is
00:32:38 <Ndit> why does ghc have the CPP?
00:32:39 <Cale> Ndit: It's useful for conditional compilation.
00:32:40 <et09> what's something more interesting Cale
00:32:41 <Ndit> it has a nice module system
00:32:48 <Ndit> errrrr
00:33:05 <Ndit> Cale, 'static if' is better there
00:34:19 <Ndit> in D, there's no CPP, and it's missing nothing
00:34:45 <Cale> et09: The very next thing we were required to do, as I recall, was to show that the sum of the first n cubes is equal to the square of the sum of the first n numbers.
00:35:21 <Cale> i.e. sum over k = 1 to n of k^3 = (sum over k = 1 to n of k)^2
00:35:52 <et09> > sum $ map (^3) [1..10]
00:35:54 <lambdabot>   3025
00:36:12 <et09> > (sum [1..10])^2
00:36:14 <lambdabot>   3025
00:36:18 <Cale> Ndit: You certainly don't have to use it, but some people find it to be useful on occasion.
00:36:24 <et09> sigh
00:36:35 <et09> how do you prove that
00:36:41 <Cale> et09: Induction works.
00:37:15 <et09> oh yes
00:37:21 * et09 has flashback to cryptography class
00:37:38 <et09> well that's all for tnite ttyl
00:37:53 <Ndit> Cale, coming from C++, I hate the CPP, so in Haskell i'd expect it to be language level
00:38:28 <Cale> Ndit: We have a lot of other options for doing the kinds of things that people would use CPP for in C++
00:38:55 <Ndit> So you're saying you can just use it for the basic intention, killing off a block of code
00:39:01 <Ndit> and therefore its not so bad
00:39:25 <Cale> yeah, or it seems to show up in a lot of cases for the purposes of hiding things from the documentation generator
00:39:32 <Ndit> well, in languages like D/Clay, static if works at the same language level so you can static-if on any static constant
00:39:35 <Ndit> which is the main thing
00:39:48 <Ndit> if-ing on constants from the language level, rather than another separate level
00:40:06 <Cale> (when either it doesn't yet support whatever language features are being used, or you just have a lot of extra cruft in your source that you don't want documented)
00:40:57 <Ndit> Ok, I won't worry about it
00:40:58 <Cale> The one advantage of the C preprocessor over in-language tools is that it's separate, and so other tools for processing your source code have an easy time applying it as well.
00:41:08 <merijn> haha, the majority objections to Foldable/Traversable in Prelude (in the Google poll on /r/haskell) is "I just want to piss of ekmett"
00:41:19 <Cale> lol
00:41:22 <capisce> another thing the C preprocessor provides is avoiding code duplication
00:41:34 <Cale> capisce: er...
00:41:35 <merijn> I have to admit I voted for that too >.<
00:41:47 <capisce> although that is solved in a better way by Lisp or Rust macros
00:41:48 <Ndit> capisce: that's precisely the thing that it's bad for
00:41:49 <Cale> capisce: Well, perhaps in some cases.
00:41:55 <Ndit> which is what I hate about it in C++
00:41:56 <Cale> But yeah, it's bad for that.
00:42:08 <Cale> I *have* seen Haskell code which uses it that way
00:42:12 <merijn> Related, go vote! https://docs.google.com/forms/d/1lKckA0pA6K4uQ-UnnmjRR32PKHph0WeZoQeVTTQJZ4I/viewform?pli=1
00:42:17 <capisce> or Template Haskell
00:42:18 <Ndit> but you only use it that way when you are against the wall
00:42:23 <Cale> But generally these days you'd use TH
00:42:24 <Cale> yes
00:42:31 <ski> capisce : how does Rust macros work ?
00:42:31 <lambdabot> ski: You have 1 new message. '/msg lambdabot @messages' to read it.
00:42:37 <ski> @messages
00:42:37 <lambdabot> dav said 5h 3m 28s ago: thanks
00:43:01 <capisce> ski: you define a pattern to match against and how that pattern should be expanded
00:43:41 <ski> capisce : so it operates on the AST ? is it hygienic (by default) ?
00:43:47 <Ndit> do you think there could be a good language where almost the entire language is defined in the prelude?
00:43:58 <capisce> ski: the pattern can be for instance ($inp:expr $sp:ident)
00:44:18 <capisce> ski: saying to match against two parameters, one expression and one identifier
00:44:40 <capisce> ski: http://static.rust-lang.org/doc/tutorial-macros.html
00:44:59 <Ndit> so that {-# patches #-} are implemented only in the language itself, but not patches to the compiler
00:45:00 <ski> nice, syntactical categories specified
00:45:18 <ski> (though i suppose it's more or less a must, given non-SEXP syntax)
00:45:30 <capisce> although unlike Lisp it doesn't let you do arbitrary transformations at compile time
00:45:32 <gaze__> I have a family of a -> IO () for numerous 'a's. There may be more than one a -> IO () for each a. I have a function that will send b -> a for one b and each a. I want one function b -> IO ()
00:45:33 <Ndit> I guess LISP is kinda like that
00:45:42 <Ndit> Lisp...
00:45:46 <ski> capisce : are macros statically "typed" by the syntactic categories they expect ?
00:45:52 <ski> Ndit : which Lisp ?
00:45:59 <ski> Scheme perhaps ?
00:45:59 <Cale> Ndit: Depends on which lisp you're talking about :)
00:46:11 <Ndit> Scheme mostly
00:46:16 <Cale> In practice, lisps have a lot of syntax.
00:46:29 <capisce> ski: I don't really know enough about Rust yet :)
00:46:33 <Cale> (it's just a syntax which has a lot of uniform structure to it)
00:46:40 <ski> capisce : ok, no worry
00:47:00 <capisce> ski: but I guess you would get a type error if you tried to give the wrong syntactic categories to a macro
00:47:39 <ski> gaze__ : perhaps give a slightly more concrete example with a definite set of `a's ?
00:48:21 <ski> capisce : yes. i wondered whether that type error would happen after the macro expansion starts, or before
00:48:57 <capisce> ski: I'd guess before since the syntactic category is specified right there in the macro definition
00:49:05 <ski> gaze__ : it's not clear how your `b -> a' will work
00:49:13 <capisce> ski: i.e. the type error would happen at the pattern matching step and not at the expansion step
00:49:33 <capisce> that is not after the macro has been expanded and the resulting code is fed to the regular compiler
00:50:39 <ski> capisce : if this macro invocation was itself a subform of another macro invocation, would the error be flagged before the other macro started expanding as well ?
00:51:33 <capisce> ski: '
00:51:36 <capisce> 'A macro may accept multiple different input grammars. The first one to successfully match the actual argument to a macro invocation is the one that "wins".'
00:51:57 <capisce> hmm, that's slightly to the side
00:52:02 <gaze__> ski: Okay so here's the problem I've been trying to solve. I want to log somewhere that a function f :: a -> (b -> m1 ()) -> m2 () needs to be called. a is the "input" datatype, and b is the output of this function passed along to a continuation (b -> m1())
00:52:16 <ski> capisce : yeah, it doesn't really answer my question :)
00:52:28 <capisce> ski: recursive use of macros accepting multiple different input grammars could quickly get computationally expensive though
00:52:37 <gaze__> upon resuming this program, I want to be able to resume this program, as every f is idempotent.
00:52:53 <capisce> ski: actually no, if the innermost macros are always fully evaluated first
00:52:57 <gaze__> so if f gets restarted, that's fine
00:53:45 <gaze__> but the callback itself atomically does {removes the record for f, adds records for n other functions based on b}, then calls those n other functions
00:53:49 <ski> capisce : i don't know whether macro evaluation in Rust is cbv or cbn
00:53:56 <ski> s/evaluation/expansion/
00:54:17 <ski> (in the Lisps i know about, it's cbn)
00:54:33 <ski> (iow, outer macros expand before inner ones)
00:54:44 <gaze__> so I need to log which b -> m1 () needs to run along with which f, and with what a
00:54:55 <gaze__> does this all make sense?
00:55:42 <ski> "the callback" here being of type `b -> m1 ()' ?
00:55:52 <gaze__> yes exactly
00:56:08 <gaze__> I should say continuation, not callback, sorry it's late here
00:56:20 <gaze__> s/callback/continuation/g
00:56:56 <ski> so would those other callbacks^Wcontinuations have types like `b0 -> m1 ()',`b1 -> m1 ()',... for some types `b0',`b1',... depending on `b' and the callb^Wcontinuation ?
00:56:57 <capisce> ski: btw, ##pldesign or similar might be a better place for a discussion around this :)
00:57:01 <juniper_> tell lambdabot @help
00:57:16 <ski> @help
00:57:16 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:57:51 <capisce> ski: yes, but in Lisp macros can perform arbitrary computations and transformations
00:57:53 <ski> juniper_ : .. you had any question ?
00:58:02 <capisce> ski: doesn't look like that's the case in Rust
00:58:16 <ski> ok, so just a pattern-language
00:58:20 <capisce> mhm
00:58:28 <capisce> a better one than the C preprocessor for sure
00:58:29 <ski> (which is orthogonal to the cbv/cbn thing)
00:58:48 <capisce> i.e. safer and better at communicating intent
00:58:53 <ski> like `syntax-rules' in Scheme is ("just") a pattern-language
00:58:53 <gaze__> well, there may be more than one f... sorry, I should have made that clear. f is just one function that we'll call a resumable kind
00:59:20 <gaze__> resumable functions have some input type a, some output type b, run in a resumable function monad m2
00:59:50 <gaze__> and when they're done, want a function b -> m1 () to run with their output.
01:00:32 <gaze__> which atomically { removes the fact that f should be called, and adds a log entry that some resumable functions g, h, and i need to be called}, calles g h i
01:00:36 * ski . o O ( "A Scheme -to- syntax-rules compiler" by oleg in 2002-07-15 at <http://okmij.org/ftp/Scheme/macros.html#syntax-rules-compiler> )
01:00:56 <gaze__> g h and i might have types g :: p -> (q -> m1 ()) -> m2 ()
01:01:11 <gaze__> where p and q are the relevant inputs and outputs for the g function.
01:02:53 <ski> hm, so you're wanting to represent `f' conceptually calling `g',`h',`i' ?
01:03:09 <gaze__> yeah exactly
01:03:09 <ski> or the latter being called when `f' returns ?
01:03:25 <gaze__> yeah that's closer to it. f does some stuff, say downloading a song
01:03:31 <gaze__> g h and i transcode it to different formats
01:03:40 <gaze__> I don't want to lose that I downloaded the song
01:03:53 <gaze__> a could be a url, b could be the on disk location
01:04:19 <gaze__> then for g, the transcoder from flac to mp3, a would be the flac file, b would be the mp3 file
01:04:34 <gaze__> hopefully that explains why I'd go through all this
01:04:59 <gaze__> and why f, g, h, and i can/need to be idempotent
01:05:48 <gaze__> I can kinda think of a way to do it using a nightmarish amount of template haskell
01:05:49 <ski> if you didn't want/need to make provisions for stuff going wrong and having to restart (presumably carrying on from last known good state), how would you write this ?
01:06:10 <ski> are `g',`h',`i' supposed to be run in sequence after `f' ?
01:06:22 <ski> or just in any order, after `f' finishes ?
01:06:43 <gaze__> the continuation notes that g, h, and i should run
01:06:52 <gaze__> and then magic happens and they run.
01:07:18 <ski> yeah, but in case you didn't need to do that, i presume you could make do with `f :: a -> M b', and similarly for the others
01:08:17 * ski is attempting to get a grasp on the kind of calling structure you want to encode, to which resumability would be added
01:08:41 <gaze__> lemme pastebin something. Thanks for taking the time
01:10:26 <quchen> gaze__: While you're at it, use HPaste, not Pastebin. :-)
01:10:29 <quchen> @where hpaste
01:10:29 <lambdabot> http://hpaste.org/
01:17:17 <gaze__> ski: http://hpaste.org/88336
01:17:44 <gaze__> I mean obviously I can't directly call cb like that
01:17:54 <gaze__> but hopefully the spirit of what I want makes sense
01:22:34 <ski> hm, i would still like a view of it where you have it expressed in terms of `downloadHTTP :: HTTPURL -> M Filename' (ignoring the possiblity for failure and for having to be able to resume from where it was left)
01:24:18 <gaze__> well, I don't see a way to get around storing a continuation.
01:25:35 <ski> yeah, but i explicitly wanted to ignore that aspect, atm :)
01:26:25 <ski> in your case, you have only one callback scheduled to happen after each of `downloadFTP' and `downloadHTTP'
01:26:33 <ski> what if you have more than one ?
01:26:54 <ski> iow, if you have `g',`h',`i' for an `f', in terms of what you said above
01:29:13 <gaze__> ahh... I see what you mean.
01:29:34 <gaze__> as in... not all these functions right now are tail calls
01:30:00 <gaze__> as they really should be
01:30:30 <gaze__> wait no that's not it
01:30:46 <gaze__> well okay. Yes. What you're saying is true
01:31:23 <gaze__> and that's okay by me. One continuation scheduled to run after each Resumable step is a fine limitation by me
01:31:50 <gaze__> I basically want all branching decided in the Router () steps
01:56:18 <mcnster> hi :) how should i perform a Prelude.read on a ByteString?
01:59:30 <mcnster> anyone awake at this lovely hour?
01:59:46 <latermuse> hello yes
01:59:54 <gaze__> I am
01:59:58 <shachaf> There is only silence and some second-hand clothes.
01:59:59 <DigitalKiwi>  yes but i'm no good at haskell ;0
01:59:59 <gaze__> for some odd reason
02:00:19 <shachaf> (And also about a thousand people from all around the world. Why wouldn't people be awake at 18:00?)
02:00:25 <mcnster> anyone want to help me reading from a ByteString?
02:00:29 <DigitalKiwi> ooop 4 o 'clock time for sleep ;)
02:00:35 <gaze__> anyone here up for helping me sort out the idea of restartable functions?
02:00:39 <shachaf> If you have a question you should just ask it.
02:00:53 <DigitalKiwi> he did
02:01:05 <latermuse> mcnster: you need to pack a string into a bytestring
02:01:13 <companion_cube> gaze__: what do you mean?
02:01:16 <latermuse> or unpack a bytestring into a string. then read it
02:01:37 <mcnster> unpack unpacks to [Word8]
02:02:05 <mcnster> is there a fn to go from [Word8] -> [Char]?
02:02:11 <shachaf> Yes, many such functions.
02:02:19 <mauke> mcnster: show
02:02:35 <shachaf> A ByteString is not a sequence of Chars. It's a sequence of bytes.
02:03:16 <merijn> shachaf: 18:00? Try 10:00!
02:03:26 <mauke> you're all wrong. it's 11:03.
02:03:26 <mcnster> so what would be the best way of performing a Prelude.read on a ByteString?
02:03:36 <mauke> mcnster: decode it first
02:03:37 <merijn> mauke: Continental scum!
02:03:49 <johnw> mcnster: what kind of thing are you trying to read?
02:03:53 <shachaf> The true time is 09:03.
02:03:57 <mauke> >Merijn Verstraaten
02:04:03 <gaze__> http://hpaste.org/88336 This is what I'd like. I hope this is clear enough
02:04:29 <mcnster> i'm trying to read unsigned char, short, and int data from a file into a data structure
02:04:50 <shachaf> That's a first-rate last name you have there.
02:05:00 <johnw> then why do you want to use Prelude.read?  The ByteString already has the bytes in it
02:05:42 <gaze__> http://hpaste.org/88336 adjusted a bit
02:06:30 <gaze__> now the question is
02:06:41 <gaze__> how do I log the callbacks that I want to run?
02:06:56 <gaze__> without a GNARLY amount of template haskell?
02:10:11 <ski> gaze__ : "not all these functions right now are tail calls","as they really should be" -- maybe, maybe not; i don't know, i was attempting to determine this partly :)
02:10:38 <gaze__> so in this case, they aren't
02:10:51 <gaze__> and that's okay. We're basically depth-firsting a lazy tree
02:12:02 <ski> my point about "ignore that aspect" (the (un)registering of callbacks, and even of expressing it in terms of callbacks at all) was to try to determine what call/dependency structure you wanted to achieve
02:12:58 <ski> it seems like if you ignore this, then you'd possibly have
02:13:09 <ski>   initialRouterCall = do
02:13:27 <ski>     dealWithFile =<< downloadFTP  "ftp://blah"
02:13:38 <ski>     dealWithFile =<< downloadHTTP "http://blah"
02:13:41 <ski> where
02:13:50 <ski>   foo =<< bar
02:13:58 <ski> is a short way of saying
02:14:03 <ski>   x <- bar
02:14:05 <ski>   foo x
02:14:21 <b_jonas> put a do around that
02:14:51 <ski> heh, i was considering `foo =<< bar' as a command sub-sequence in `do', not as an expression ;)
02:14:57 <b_jonas> ah
02:15:01 <b_jonas> ok
02:16:11 <ski> (hm, i suppose one ought to consider `x <- foo; bar x' as a valid command sub-sequence of `do x <- foo; y <- bar x; baz x y')
02:17:39 <gaze__> okay. Let's make this more complicated but more concrete. Say that instead of function calls, you were trying to get the right a to the right Concurrent.Channel (as in, downloadHTTP etc. are all servers)
02:17:49 <b_jonas> only if you use that monad identity
02:18:02 <b_jonas> no wait
02:18:03 <b_jonas> not even then
02:18:25 <gaze__> when b came back over the same chanel, it would need to go to the continuation specified by runResumable
02:18:28 <ski> which monad identity ?
02:18:32 <b_jonas> ski: no, because x is used in the the last command so you can't refactor it to (foo >>= bar) >>= something
02:19:02 <gaze__> so now we have a message passing thing going on
02:20:04 <b_jonas> ski: the monad identity that says something like a >>= (b >>= c) = (a >>= b) >>= c but not quite
02:20:15 <ski> ok, associativity
02:21:38 <b_jonas> only you can't use that one in your example
02:21:39 <ski> i was taking "prefixing" `x <- foo; bar x' by `y <-' to yield `x <- foo; y <- bar x'
02:21:53 <augur> ski: learn about kleisli categories!
02:22:20 <ski> (this would perhaps look more natural if we "suffixed" `foo -> x; bar x' by `-> y', getting `foo -> x; bar x -> y')
02:22:32 <ski> augur : what about them ?
02:22:42 <augur> ski: they make live better
02:23:00 <b_jonas> ski: that works, but your example was (do { x <- foo; y <- bar x; baz x y }) which you can't transform that way
02:23:18 <ski> augur : i know about them, it's Eilenberg-Moore categories i don't have a good grasp on
02:23:28 <augur> ski: catsters!
02:24:26 <ski> b_jonas : i was arguing that if we consider `x <- foo; bar x' as a valid sub-sequence of that, and also with the "prefixing" provision above, we can
02:24:56 <ski> b_jonas : .. i'm just attempting to reason at the level of commands and command sequences, instead of at the level of the expressions which they expand to
02:25:19 <b_jonas> oh. well I'm looking at the semantics, not at the syntax.
02:26:08 <ski> (also, `do if ... then {x <- foo; y <- bar x} else {(x,y) <- baz}; quux x y' would be useful
02:26:25 <ski> )
02:27:19 <dalaing1> I've recently been pointed towards Oleg's lecture notes on final tagless interpreters - I'm really liking the ideas in the notes so far, and was wondering if there are any "gotchas" or impressions based on people using them in anger
02:27:34 <ski> (with obvious expansion in terms of (unboxed ?) tuples)
02:28:34 <ski> gaze__ : mhm, ok
02:32:25 <gaze__> I mean either way the order doesn't matter too much. FTPDownload fires, continuation is called to figure out who is up next, dealWithFile fires on the FTP downloaded file, and then somehow in parallel, HTTPDownload fires, dealWithFile fires on the HTTP downloaded file
02:35:09 <gaze__> either way the flow of execution should look like somehow like a tree... the Resumable () have one outward edge to the continuation, which have n outward edges to Resumables, etc. etc.
02:38:37 <merijn> edwardk: Did you see the google poll on Foldable/Traversable in Prelude? :p
02:39:23 <merijn> edwardk: The leading objection (at 31% right now) is "I just want to piss off ekmett" ;)
02:39:34 <ski> you could possibly use something like `exists a. (IORef a,a -> m1 ())' to store each callback
02:39:48 <ski> or `MVar'
02:40:34 <ski> the producer would store the result `a' in the `MVar a' when it's done
02:41:09 <ski> a scheduler could walk a list of the above, checking if any result is available, and if so launch its callback
02:41:22 <ski> hm
02:41:59 <ski> or maybe you could just spawn threads for each thing, not doing any manual scheduling
02:42:14 * ski is getting tired
02:43:31 <edwardk> merijn hahahaha
02:43:31 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
02:43:43 <ski> (it would depend on what kinds of things you can expect in this framework thing)
02:43:51 <edwardk> merijn: link?
02:46:54 <merijn> edwardk: Not so many responses yet (althought of the 50 so far there has been overwhelming support for Foldable/Traversable in Prelude)
02:46:57 <merijn> edwardk: https://docs.google.com/forms/d/1lKckA0pA6K4uQ-UnnmjRR32PKHph0WeZoQeVTTQJZ4I/viewform
02:49:29 <edwardk> merijn: nice
02:50:03 <edwardk> merijn: i personally would have added a point in the "How should Prelude be?" about striking a balance, but for humor value it was pretty good
02:50:28 <johnw> edwardk: I was going to send another post calling for votes, and linking to the haskellwiki proposal, but I wasn't sure if that proposal was still the "state of the art", and that perhaps it should be someone with more gravitas starting the vote call
02:52:27 <edwardk> i hadn't realized quite the level of support for the proposal. i was expecting something like 7:3, not 5:1
02:52:57 <merijn> edwardk: I think the support might be more than 5:1, it's just laziness/mailing list inertia stopping the proponents from voting
02:53:11 <merijn> Also, the many people who'd support it, but don't follow libraries@
02:53:34 <merijn> (Hell, I forgot to vote and I strongly support Foldable/Traversable in Prelude with polymorphic mapM)
02:54:17 <edwardk> sure, but sample bias could also go the other way, given that folks who only use it to teach classes, etc. may not follow the libraries list, etc. so i'm happy to consider it just as a data point on its own merits
02:54:24 <adnap> Hi
02:55:40 <adnap> I wrote a function and it seems to be running forever without giving a result, but I don't understand why. Will someone help?  http://hpaste.org/88334
02:55:52 <adnap> (Help explain why)
03:01:34 <merijn> adnap: I don't understand what the function tries to do (at least not without investing more effort than I'm willing to)
03:01:51 <merijn> Maybe try giving the functions slightly more expressive names and/or explain what they're supposed to do?
03:02:44 <adnap> merijn: Someone said that earlier. I don't know how to express it better
03:03:05 <adnap> merijn: I don't think it's that hard to understand
03:03:19 <adnap> If you know Applicatives and Monads
03:06:49 <merijn> adnap: I'd expect it to crash on
03:06:52 <merijn> > tail []
03:06:54 <lambdabot>   *Exception: Prelude.tail: empty list
03:06:57 <merijn> eventually
03:07:29 <adnap> Well, the idea is that I'm only taking a finite number of elements from the list
03:07:53 <adnap> I'm taking the number of elements in the original list
03:08:21 <c_wraith> uh.  taking a finite number of elements from the output doesn't mean it can skip processing the whole thing
03:08:28 <c_wraith> it needs to sequence all the effects
03:08:37 <c_wraith> regardless of how much of the list you consume
03:08:45 <adnap> The sequence happens after taking elements...
03:08:55 <merijn> adnap: No, it does not
03:09:13 <adnap> Well, can I make it do that?
03:09:33 <merijn> No, that's kinda the point of sequence...
03:10:34 <merijn> "sequence $ map print [1..]" will never terminate even if you try to take a finite number of result elements
03:10:37 <merijn> @src sequence
03:10:37 <lambdabot> sequence []     = return []
03:10:37 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
03:10:37 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
03:11:06 <merijn> As you see on the second line it doesn't "return (v:vs)" until after the tail has been sequenced
03:11:10 <c_wraith> well, those functions don't use sequence
03:11:24 <merijn> c_wraith: The second does...
03:11:31 <c_wraith> oh, so it does
03:11:41 <merijn> It's literally the first symbol after = :p
03:11:44 <adnap> Even if I remove the sequence, it still doesn't finish
03:12:18 <adnap> If I change it to "h :: (Applicative f, Monad m) => f [a] -> (f a -> f (m b)) -> f [m b]" and "h x g = liftA2 take (length <$> x) (f x g)"
03:12:43 <c_wraith> well, does f ever terminate?
03:12:47 <c_wraith> I'm not seeing how it could
03:12:47 <adnap> No
03:12:53 <adnap> but neither does [1..]
03:13:18 <c_wraith> the difference being that [1..] is productive
03:13:20 <c_wraith> and f is not
03:13:31 <adnap> Why is f not productive? What does that mean exactly?
03:14:16 <adnap> f takes elements from the head of the list and attaches them an inifinite list...
03:14:17 <c_wraith> it means that after sufficient evaluation, it will return a data constructor
03:14:27 <merijn> adnap: "[1..]" returns "1:[2..]" the [2..] is run until the second part is forced
03:14:38 <adnap> Right
03:14:43 <adnap> I am trying to do the same thing
03:14:50 <merijn> adnap: If you need to run all Applicative/Monad effects before returning a value, that can't happen
03:15:03 <k00mi_> with unsafeInterleaveIO, it can
03:15:06 <c_wraith> but you're not, because (:) isn't the top-level constructor
03:15:17 <adnap> I don't understand what is going on
03:15:20 <merijn> adnap: Oh? How? You're returning some f as top level
03:15:30 <merijn> adnap: The f requires everything in the list to be evaluated...
03:15:39 <adnap> Ohh
03:15:43 <adnap> To contruct an Applicative
03:15:50 <adnap> But...
03:15:53 <adnap> I can do
03:16:13 <adnap> > take 5 <$> [[1..]]
03:16:15 <lambdabot>   [[1,2,3,4,5]]
03:16:31 <adnap> [] is an Applicative, and it has an infinite list inside
03:17:17 <merijn> adnap: It's not an infinite list of Applicatives...
03:17:32 <c_wraith> if your f function was to make [] its f type (ugh, please name the function and its type variables something different)
03:17:45 <merijn> > take 5 <$> map (:[]) [1..]
03:17:47 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17...
03:18:06 <merijn> That only works because <$> for [] == map
03:18:11 <merijn> And map is constructive too
03:18:44 <merijn> i.e. "map f (x:xs) = <f x thunk> : <map f xs thunk>"
03:18:56 <c_wraith> heh.
03:19:08 <adnap> So, I'm constructing an applicative with an infinite list of monads inside
03:19:09 <user123abc> what's the recommended way to parse command line options?
03:19:14 <user123abc> it looks like there are quite a few options
03:19:27 <c_wraith> What's really going on here is you're trying to use a control-flow that requires the monad interface with an applicative interface
03:19:49 <adnap> So, this function can't be written?
03:19:53 <c_wraith> The difference between the two is allowing a function like f to terminate
03:20:19 <adnap> I just don't understand what is going on
03:20:48 <donri> @hackage optparse-applicative for user123abc
03:20:48 <lambdabot> http://hackage.haskell.org/package/optparse-applicative for user123abc
03:21:30 <user123abc> donri, thanks
03:21:31 <c_wraith> adnap: what's going on is that f is an infinite loop of effects. It can't return until it has put *all* the effects together.
03:21:42 <adnap> What are the "effects"?
03:21:51 <donri> user123abc: that's the nice one. the zero-dependency one is System.Console.GetOpt in base
03:21:53 <c_wraith> whatever your applicative instance defines them as
03:22:02 <k00mi_> that really depends on what Applicative you have
03:22:09 <adnap> I don't get it
03:22:19 <adnap> Can you explain what the "effects" are in the case of []?
03:22:21 <merijn> adnap: Imagine I pick IO as you Applicative, then what
03:22:30 <merijn> adnap: You don't get to pick which applicative happens!
03:22:44 <adnap> No, but can't we use [] as an example?
03:22:50 <adnap> Since the function doesn't work on []
03:22:53 <merijn> adnap: No
03:23:02 <adnap> merijn: Why?
03:23:22 <merijn> What happens with "f :: (Monad m) => IO [a] -> (IO a -> IO (m b)) -> IO [m b]"
03:24:17 <adnap> So..
03:24:27 <adnap> an IO has to run to get IO [a]
03:24:35 <adnap> before I can take out the head
03:25:19 <adnap> Then the (IO a -> IO (m b)) defines a new IO
03:25:22 <merijn> adnap: "(:) <$> ioActionA <*> ioActionB" == "do { x <- ioActionA; xs <- ioActionB; return (x:xs)"
03:25:58 <merijn> if ioActionB never terminates (because your f never terminates), then logically, neither does "(:) <$> ioActionA <*> ioActionB"
03:26:45 <adnap> Well, can't I force ioActionB to happen before doing anything else?
03:26:54 <c_wraith> you can
03:26:59 <c_wraith> but if it's infinite, that doesn't help
03:27:05 <merijn> You can, but that doesn't help if its infinite...
03:27:09 <adnap> Why?
03:27:14 <adnap> Oh
03:27:16 <adnap> Nevermind
03:27:23 <adnap> Gah
03:27:28 <adnap> I'm stuck
03:27:38 <adnap> I don't know how to write this function
03:27:54 <merijn> adnap: Why does it have to be one function? Split it up in pieces...
03:27:54 <adnap> I can add an Int argument to f to make it stop
03:27:56 <c_wraith> why are you trying to write that function?
03:28:16 <adnap> c_wraith: Well, that involves explaning the whole project I am working on
03:28:22 <c_wraith> no it doesn't
03:28:31 <adnap> I
03:28:32 <k00mi_> adnap: you can use unseafeInterleaveIO, which is in some cases fine (getContents uses it)
03:28:53 <k00mi_> adnap: it would make the sequence return values before it's finished
03:28:54 <merijn> k00mi_: That is terrible advice to give to people
03:29:11 <adnap> c_wraith: What would I explain?
03:29:25 <k00mi_> merijn: there are cases where it's unproblematic
03:29:29 <c_wraith> adnap: why f :: (Applicative f, Monad m) => f [a] -> (f a -> f (m b)) -> f [m b] instead of f :: (Monad f, Monad m) => f [a] -> (f a -> f (m b)) -> f [m b]
03:29:48 <merijn> k00mi_: Yes, but people capable of using unsafeInterleaveIO don't ask basic questions like this
03:29:55 <c_wraith> the latter is easy to make to do what you want
03:30:10 <k00mi_> merijn: yeah that's right
03:30:11 <merijn> k00mi_: Hence, giving unsafeInterleaveIO as an answer to this question is awful advice
03:30:25 <adnap> c_wraith: Because I am writing it for a program which uses a library where the type I am working with is an Applicative and not a Monad
03:30:31 <k00mi_> ok, adnap, ignore me =)
03:32:00 <user123abc> so I'm learning haskell and using http://cheatsheet.codeslower.com/ as a tutorial/reference
03:32:14 <user123abc> I really like it for its conciseness, but I wonder how complete it is
03:32:39 <k00mi_> adnap: so you want to write a function that works on one f only?
03:32:44 <user123abc> is anyone familiar enough to say whether this document misses any major language feature that I should look into?
03:33:07 <adnap> k00mi_: Yes
03:33:47 <adnap> This one: http://hackage.haskell.org/packages/archive/reactive-banana/0.7.1.2/doc/html/Reactive-Banana-Combinators.html#t:Behavior
03:34:19 <c_wraith> adnap: that whole type signature looks really odd. Why all the fs? Why are they exactly where they are? It's nearly liftA2 map
03:34:27 <c_wraith> :t liftA2 map
03:34:28 <lambdabot> Applicative f => f (a -> b) -> f [a] -> f [b]
03:34:53 <c_wraith> except that has a slightly different arrangement of where the fs go
03:35:01 <adnap> What...
03:35:33 <c_wraith> which is enough to make your type signature way harder to deal with
03:35:47 <adnap> Yeah, there's a point to the type signature
03:35:49 <c_wraith> But *why* does your type signature have those fs exactly where it does?
03:35:51 <ski> user123abc : doesn't mention `default' as a keyword
03:35:55 <adnap> f's?
03:36:03 <adnap> Applicatives?
03:36:11 <adnap> I mean, I could change the order of the arguments
03:36:17 <c_wraith> eh, order doesn't matter
03:36:28 <adnap> Well, the types are what they are for a reason
03:36:28 <ski> nesting matters
03:36:30 <fosskers> What was the type signature? Just got here.
03:36:41 <c_wraith> I'm saying, why is the function you're passing it have the type f a -> f (m b) ?
03:36:47 <c_wraith> That's..  kind of odd.
03:36:52 <adnap> I'll explain
03:37:01 <merijn> user123abc: It's a good beginner/syntax cheat sheet, but it doesn't mention any of the common libraries/GHC extensions
03:37:03 <adnap> In my case, f is http://hackage.haskell.org/packages/archive/reactive-banana/0.7.1.2/doc/html/Reactive-Banana-Combinators.html#t:Behavior
03:37:21 <adnap> And a is like...
03:37:23 <adnap> Float
03:37:40 <adnap> and m is IO
03:37:49 <user123abc> ski, thanks
03:37:53 <c_wraith> m is irrelevant
03:37:56 <merijn> user123abc: You might want to maintain a cheatsheet of common typeclasses/combinator libraries in addition to it
03:38:06 <c_wraith> your type signature is more specific than it needs to be
03:38:16 <user123abc> merijn, yeah, I wouldn't expect that kind of stuff - but it looks like the documentation for that is pretty good in other places
03:38:30 <adnap> c_wraith: In what way?
03:38:41 <c_wraith> your function is equivalent to Applicative f => f [a] -> (f a -> f b) -> f [b]
03:38:45 <merijn> user123abc: Typeclassopedia, the monad chapter of LYAH are good starting points for those
03:38:50 <adnap> c_wraith: No
03:38:53 <merijn> adnap: Yes
03:38:54 <user123abc> merijn, thanks
03:38:58 <ski> `f' is
03:39:17 <merijn> adnap: Just pick "b" as "Monad m => m b"
03:39:28 <adnap> Okay, let me think...
03:40:12 <adnap> c_wraith: Maybe you're right
03:40:24 <adnap> But b is definitely a monad for my purposes
03:40:32 <c_wraith> that matters for h.
03:40:35 <c_wraith> it doesn't matter for f
03:40:35 <adnap> Yeah
03:40:41 <adnap> You're right
03:40:49 <adnap> Perhaps I can turn it into a monad afterward
03:41:03 <c_wraith> I don't think so, from what you've said
03:41:21 <adnap> Why?
03:41:30 <adnap> Or... what did I say?
03:41:31 <c_wraith> because f is still going to be Behavior
03:41:37 <adnap> Yeah...
03:41:53 <adnap> But I can turn the thing inside the Behavior into a monad later, right?
03:42:13 <c_wraith> the contents really don't matter, for the function f.
03:42:19 <adnap> Right
03:43:10 * ski isn't sure what "turn the thing into a monad" would mean
03:43:43 <c_wraith> adnap: does your second argument have to be (f a -> f b)?  This is easy if you can get away with just (a -> b)
03:43:56 <adnap> c_wraith: Yes it does
03:44:50 <c_wraith> My intuition is suggestion the Applicative interface just isn't powerful enough for this, then
03:44:59 <adnap> Crap
03:44:59 <c_wraith> It seems like you need join
03:45:08 <adnap> I wanted join before...
03:45:16 <ski> not sure whether it would help, but would `f (a -> b)' be easier ?
03:45:26 <adnap> And I am doing all this thinking trying to get around the fact that Behavior is not a monad
03:45:51 <c_wraith> ski: well, f (a -> b) would make it trivial, so yes.  If that worked, it would solve the problem
03:46:06 <adnap> Whoa
03:46:11 <adnap> Maybe that would work
03:46:20 <adnap> (For my purposes)
03:46:31 <c_wraith> in that case, what you want would be
03:46:49 <c_wraith> :t liftA2 $ flip map
03:46:51 <lambdabot> Applicative f => f [a] -> f (a -> b) -> f [b]
03:47:24 <k00mi_> I don't think you can turn a function f a -> f b, that can't be a -> b, into f (a -> b)
03:47:34 <ski> k00mi_ : not in general, no
03:47:53 <ski> just like you can't in general turn `m a -> m b' into `a -> m b', for a monad `m'
03:48:05 <adnap> k00mi_: If I remove what you wrote between the commans, your statement makes no sense
03:48:09 <adnap> *commas
03:48:14 <adnap> < k00mi_> I don't think you can turn a function f a -> f b, that can't be a -> b, into f (a
03:48:28 <adnap> < k00mi_> I don't think you can turn a function f a -> f b into f (a -> b)
03:48:31 <ski> but in some cases it can be done (in the sense that `(<*>)' resp. `(=<<)' applied to the new function yields the original function)
03:48:41 <adnap> Oh, nevermind
03:48:46 <adnap> I misread >_<
03:49:31 <adnap> Fortunately, I don't think I need to work with f a -> f b
03:49:41 <adnap> I can just change the semantics of my program
03:50:40 <ski> k00mi_ : e.g., a `Parser (Expr -> Expr)' which is nontrivial (so is not `pure'/`return' of an `Expr -> Expr' function) could be one example
03:51:31 <ski> (i.e. assuming you for some reason were starting with `(<*>)' of that parser (which has type `Parser Expr -> Parser Expr'), and then realizing that you could factor out `(<*>)' in this way)
03:51:51 <k00mi_> ski: I see
03:53:07 <ski> i call a function `f :: m a -> m b', where `f = (g =<<)' for some `g :: a -> m b' (`m' a monad), referentially transparent
03:53:58 <ski> perhaps one could call an action `f :: i (a -> b)', where `f = (g <*>)' for some `g :: a -> i b' (`i' an applicative functor), referentially transparent as well ..
03:55:46 <xc__> men, in NNs, are neuron dynamically added in the system?
03:56:49 <k00mi_> ski: wait, how does (g <*>) typecheck
03:57:01 <hamid> Haskell is language of extensions according to "Real World Haskell".
03:57:18 <ski> @type (?f <*>)
03:57:19 <lambdabot> (?f::f (a -> b), Applicative f) => f a -> f b
03:57:24 <hamid> I don't feel any good about that.
03:57:39 <hamid> Or I'm just misleading?
03:57:50 <ski> k00mi_ : er, sorry, you're right
03:58:08 <ski> k00mi_ : it should of course be :
03:58:31 <ski> perhaps one could call an action `f :: i a -> i b', where `f = (g <*>)' for some `g :: i (a -> b)' (`i' an applicative functor), referentially transparent as well ..
03:58:36 <ski> apologies
03:58:46 <k00mi_> ok, now it makes sense =)
03:59:17 <merijn> hamid: Why's that?
03:59:35 <ski> anyway, if you're wondering, there's a point to calling the `f :: m a -> m b' above referentially transparent
03:59:47 <merijn> hamid: The problem is that the official haskell report is *very* conservative, as a result, any GHC feature that is not in the report has to be an extension
04:00:25 <hamid> merijn, that books just mentions portability issues .
04:00:28 <fosskers> For ease of compiler implementation, i imagine.
04:01:13 <merijn> hamid: It means portability as in "being able to compile your haskell code on another haskell compiler"
04:01:26 <merijn> hamid: *not* "being able to compile your haskell code on a different machine"
04:01:29 <hpc> fosskers: partly for compiler writers, partly for programmers
04:01:39 <fosskers> how many major compilers are there?
04:01:43 <merijn> 1
04:01:47 <fosskers> haha
04:01:47 <hpc> fosskers: and partly to cleverly avoid mentioning implementation details in any way whatsoever
04:01:59 <k00mi_> xc__: you mean adding neurons during training? no
04:02:02 <merijn> There's a bunch of research compilers, but they're not near "major"
04:02:16 <hpc> the report doesn't even mention lazy evaluation
04:02:21 <fosskers> I've heard hugs mentioned but only ever used GHC.
04:02:30 <hpc> it just says "these are bottom, these are not"
04:02:36 <merijn> fosskers: hugs is dead, it's an out of date teaching tool
04:02:46 <hamid> merijn, Yeah I couldn't think of anything else. but can those extensions drop in future releases and etc
04:02:46 <fosskers> dead eh
04:02:49 <merijn> fosskers: There's UHC (the Utrecht compiler) and a few others, though
04:02:57 <fosskers> advantages?
04:03:01 <hpc> there's also weird stuff like ghcjs
04:03:07 <fosskers> or is ghc The One True Compiler
04:03:08 <hamid> merijn, and then you as a programmer rely on some extensions and then you broke :P
04:03:19 <merijn> hamid: I've never heard of an extension being removed
04:03:31 <hamid> merijn, hmm just deprecated?
04:03:44 <hpc> wasn't nplusk removed?
04:03:47 <fosskers> hamid: extensions sometimes change name
04:03:48 <nomeata> There is a list of implementations in http://www.haskell.org/haskellwiki/Implementations
04:03:52 <merijn> nplusk wasn't an extension
04:04:00 <quchen> merijn: Well, (n+k) pattern were made an extension that is disabled by default, if that counts.
04:04:05 <fosskers> nomeata: thanks
04:04:06 <merijn> It was made an extension in Haskell2010, yes
04:04:10 <hpc> oh, pah
04:04:25 <quchen> It's sort of an extension that's there just to be removed. :-)
04:04:39 <xc__> k00mi_, yep, need to get grips on them, (wanting to implement decision strategies on forex orders), it's weird to see if all neuron are equivalents, but in different states?, (going to learn with examples it's better I think)
04:04:43 <hamid> fosskers, it's even scarry that way
04:05:22 <merijn> hamid: The NPlusK is the only thing I can think of and that was a hated, bad feature that was changed into an extension (i.e. disabled by default, but easy to turn on again) in a language update more than 12 years after it was introduced
04:05:39 <merijn> fosskers: Oh? When has that happened?
04:05:59 <quchen> DoRec, RecursiveDo?
04:06:07 <quchen> Or whatever they are called
04:06:09 <fosskers> quchen: that's the only one I'm aware of
04:06:11 <merijn> hamid: Keep in mind, that I think Python regularly breaks things more drastically than GHC extensions do (not even counting py3k(
04:06:44 <merijn> hamid: They're more stable than many other popular languages are, so I wouldn't worry about it so much
04:09:36 <merijn> hamid: What languages are you used to working in?
04:09:38 <hamid> merijn, Got it :) thx. btw, Is there another haskell standard under development? I've read of something called Haskell Primer or Haskell 2012.
04:10:00 <hamid> merijn, C++ and Java :)
04:10:22 <merijn> Haskell2010 is the most recent, Haskell' (read: Haskell Prime) is the name of the "in progress" standard, but I think it'll be a while before a new one is released
04:11:14 <merijn> hamid: I would put the odds of extensions breaking about as high as the odds of a new Java release breaking things due to backwards incompatibility.
04:12:51 <hamid> yep :)
04:13:56 <merijn> And tbh I think extension renaming is a non-problem, you can easily fix that with sed
04:15:33 <hamid> merijn, yep. How can find a list GHC extensions with their descriptions ?
04:25:12 <kartlos> I'm still puzzled on how to use random numbers in Haskell, let's say I want to extract a random entry from a list, using randomRIO(0, length xs - 1) I can get an index that has type IO Int. How do I use this IO Int to extract an actual element from the list?
04:26:27 <zomg> kartlos: you just need get the value out from the IO monad first
04:26:52 <kartlos> zomg: how does one get the value out of the IO monad?
04:27:09 <zomg> foo <- myIoVariable
04:27:12 <zomg> for example like that
04:27:26 <zomg> you might want to read more about IO and monads and such if it confuses you :)
04:28:01 <kartlos> I've read a lot of articles, I've also watched all the Haskell lectures by Philip Wadler
04:28:20 <kartlos> but I just have to find things out myself before I truly understand them
04:28:31 <zomg> heh, same for me
04:28:46 <ski> @wiki Introduction to IO
04:28:46 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
04:28:58 <ski> is perhaps useful, if you haven't seen it before
04:29:27 <kartlos> I found this also very usefull http://www.haskell.org/haskellwiki/IO_inside
04:54:45 <merijn> hamid: The GHC user manual has a list with explanations
04:55:08 <merijn> hamid: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
04:56:05 <hamid> merijn, Nice. Thank you.
04:57:58 <merijn> hamid: There's a ton of not-so-relevant or obscure ones, though. A list of "common" ones (plus whether you should use them) can be found here: http://stackoverflow.com/questions/10845179/which-haskell-ghc-extensions-should-users-use-avoid
04:58:14 <bartavelle> I loved it yesteday how the FFI was easy to use. Now I'm getting all kind of segfaults :)
04:59:46 <neutrino> hi
05:00:40 <neutrino> i would like to create a class called MyClass which contains a function called "make". When I'm in the list monad I'd like "x <- make" to yield 2, whereas in the maybe monad I'd like it to yield 3. How can I do that?
05:01:22 <simukis_> Who's on a mac? Does your system have a `false`?
05:01:38 <simukis_> false binary I mean.
05:02:08 <Botje> % ls -lh /usr/bin/false
05:02:08 <Botje> -r-xr-xr-x  1 root  wheel    49K May 18  2009 /usr/bin/false
05:02:12 <merijn> simukis_: merijn ~ 0$ which false
05:02:12 <merijn> /usr/bin/false
05:02:17 <merijn> So, yes
05:02:19 <neutrino> "false" is part of posix.
05:02:20 <S11001001> neutrino: is your class called FunctOrdinal?
05:02:29 <Botje> (my shell just says "shell built-in", stupid thing)
05:02:31 <mauke> neutrino: which 2?
05:02:33 <neutrino> S11001001: nope it's called ContextBased.
05:02:37 <neutrino> let me paste my code
05:02:58 <merijn> neutrino: "false is part of posix" means nothing
05:03:04 <merijn> neutrino: Which posix
05:03:18 <merijn> There's a billion different standards with varying levels of support
05:03:31 <simukis_> ok thanks.
05:03:52 <neutrino> S11001001: I've been following the scalaz tutorial as you suggested. I'm trying to learn classes a bit better in haskell before I attempt it in scalaz.
05:03:52 <ion> neutrino: class Foo m where { make :: m Integer }
05:04:53 <neutrino> ion: I want the result to change depending on what m I'm in.. hmm.. let me look at that
05:05:03 <ion> Yes, you’ll use instances for that.
05:05:13 <S11001001> neutrino: worth noting: this is a PITA in scala because it won't infer higher-kinded parameters from context (it picks Nothing which it thinks is polykinded), only *-kinded ones, so you'll always have to provide a type param to make in scala :/
05:05:54 <neutrino> S11001001: yeah i heard. I'm trying to figure out configuration propagation using type classes.
05:06:16 <neutrino> why is the bot not posting my url? hmm
05:06:21 <neutrino> http://hpaste.org/88346
05:06:26 <neutrino> here's my code as of now
05:06:52 <ski> "I also haven't said anything about exception handling, which is a natural part of the \"monad\" concept."
05:07:02 <S11001001> neutrino: anyway ion's answer works
05:07:11 <ion> ski: ಠ
05:07:15 <S11001001> ski: heh
05:07:59 <ski> should i update it to say "IO monad" ?
05:09:28 <neutrino> yep it works
05:09:30 <neutrino> thanks
05:09:52 <neutrino> S11001001: what would you suggest for doing something like config propagation, which is similar to using typeclasses?
05:10:08 <neutrino> in scalaz
05:11:42 <S11001001> neutrino: plain implicit values.  There's clever stuff you can do with shapeless to talk about configuration subsets.  But don't say "similar to using typeclasses"; the hack you use in scala makes them look similar, but they really aren't
05:11:46 <S11001001> (scala chat in #haskell)
05:12:30 <ski>   "Second, the IO monad implementation described here is really used in the GHC, yhc/nhc (Hugs/jhc, too?) compilers."
05:12:33 <ski>   "The Yhc/nhc98 implementation   `data World = World'   `newtype IO a = IO (World -> Either IOError a)'"
05:12:36 <ski> huh ?
05:13:03 <Diagoras> hello, people! anyone experienced with Control.Lens here?
05:13:14 <ski> and Hugs uses `newtype IO a = IO ((a -> IOResult) -> IOResult)', so should be mentioned in "For example, the hbc Haskell compiler implements IO monad via continuations."
05:13:54 * ski isn't sure what jhc uses
05:14:35 <supki> Diagoras: you should just ask you question
05:14:38 <neutrino> S11001001: hmm so is the scala hack not really typeclasses?
05:14:41 <supki> Diagoras: also there is #haskell-lens
05:14:56 <neutrino> we can talk in #scala if you prefer.
05:16:12 <Diagoras> I'm curious, if I can do something like this: "container ^. commonPath . someFunction (pathOne, PathTwo)" so it would be equal to "(container ^. commonPath .pathOne, container ^. commonPath .pathTwo)"
05:19:23 <Diagoras> oups - not "PathTwo", but "pathTwo" of course in first code
05:19:44 <supki> not really
05:19:59 <sopvop> maybe `zoom` may help
05:20:21 <sopvop> or magnify
05:21:57 <Diagoras> hm... thanks for direction - I'll check
05:23:07 <sopvop> > (1,('a', 'b', 3)) & magnify _2 ( \x -> (x^._1, x^._2))
05:23:09 <lambdabot>   ('a','b')
05:23:39 <sopvop> > (1,('a', 'b', 3)) & magnify _2 & \x -> (x^._1, x^._2)
05:23:41 <lambdabot>   Could not deduce (GHC.Base.Functor
05:23:41 <lambdabot>                      (Control.Lens.Inter...
05:23:51 <sopvop> damn you fixity
05:24:30 <Diagoras> wow! that's cool! Control.Lens looks superpowerfull, but it's hard to understand even what it can do, without even talking about finding exact way to do it :-)
05:25:15 <aleator> I'm not sure if I like control.lens but it sure does make code shorter at times.
05:25:16 * hackagebot Workflow 0.8.0.4 - Workflow patterns and a monad for thread state logging & recovery  http://hackage.haskell.org/package/Workflow-0.8.0.4 (AlbertoCorona)
05:25:18 * hackagebot MFlow 0.2.0.9 - continuation-based Web framework without continuations.  http://hackage.haskell.org/package/MFlow-0.2.0.9 (AlbertoCorona)
05:25:46 <sopvop> http://i.qkme.me/3rv95m.jpg
05:26:36 <Diagoras> lol! perfect shot
05:27:01 <sopvop> every project starts with  Build-depends: base, errors, lens
05:27:19 <sopvop> also transformers, mtl....
05:27:33 <sopvop> containers... that gets quite long
05:30:16 * hackagebot Elm 0.8.0.1 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.8.0.1 (EvanCzaplicki)
05:30:23 <eikke> I never used errors, should look into it
05:34:57 <ski> hm, does Malcolm Wallace (appearing to be developing Nhc) frequent #haskell ?
05:35:31 <ski> preflex: xseen ndm
05:35:31 <preflex>  ndm was last seen on freenode/#haskell 2 years, 154 days, 17 hours, 19 minutes and 35 seconds ago, saying: if you don't, then there was a parse error
05:37:54 <Diagoras> sometimes I have a feeling that somewhere on hackageDB there is a package called something like "cute-bunny". but you can never be exerienced enough to even know that it can actually solve every world problem
05:39:36 <sopvop> Diagoras: I'm still waiting for  import edwardk; main = runEdwardk 42
05:39:47 <otters> edwardk isn't a valid module name
05:39:49 <otters> keep waiting
05:41:28 <no-n> :]
06:10:37 <meditans> hi, I'm toying around with haskell unicode support. Does there exists a method to have haskell accept \lambda x -> 2 * x with \lambda for the actual unicode symbol?
06:11:01 <meditans> I mean, no visual substitution in vim or emacs, just unicode
06:11:29 <meditans> (I'm asking because ghci seems to complain about)
06:11:39 <quchen> meditans: I don't know. In general, I would not suggest to have non-ASCII in source files anyway.
06:11:54 <mauke> I would suggest not trying to replace \ by lambda
06:12:03 <mauke> it's pointless
06:12:17 <merijn> quchen: Whut, that seems overly conservative
06:12:28 <meditans> mauke: I know, but it's very very pretty, and I just want to try :D
06:12:34 <quchen> Everyone can type ASCII, not many can write \lambda. Everyone can read ASCII, not all have a glyph for \lambda.
06:12:38 <merijn> unicode function/variable names and string contents seem perfectly reasonable
06:12:55 <merijn> I'd avoid unicode syntax, though
06:12:58 <k00mi_> meditans: AFAIK there is no way to do it
06:13:12 <merijn> k00mi_: Sure there is, CPP abuse would probably work :p
06:13:20 <quchen> Unicode function names? "ö" in functions? Eww.
06:13:37 <k00mi_> by which I mean reasonable way ;)
06:13:58 <mauke> meditans: it's not pretty. or at least not as pretty as \
06:14:37 <meditans> mauke: why?
06:14:44 <meditans> so then, could you explain why
06:14:55 <meditans> I can use a unicode symbol for the arrow
06:15:14 <int-e> that's easy: lambda is a letter.
06:15:48 <meditans> :int-e could you explain a little more?
06:15:53 <meditans> ah ok
06:16:08 <int-e> I'd like to explain it in greek but I don't know greek :/
06:16:13 <meditans> sorry, that's completely reasonable
06:16:15 <meditans> :D
06:16:16 <quchen> http://p.bfram.es/suitability-just-because-you-can-doesn-t-mean-you-should.jpg
06:16:21 <quchen> ^ This ;-)
06:16:23 <_emm_> you have vim plugins which display lambda as lambdas
06:16:28 <kartlos_> λ
06:16:42 <_emm_> which is cool unless you want to use X's copy-paste
06:16:56 <_emm_> s/unless/until/
06:16:59 <int-e> meditans: lambda also looks ugly in my terminal font ;)
06:17:01 <mauke> even if you made λ a keyword, you still couldn't write λx because that's a single identifier
06:17:10 <meditans> _emm_ I know, but they also display \ as lambda in literals
06:17:13 <mauke> \ is superior in every way
06:17:38 <mauke> the so called "lambda calculus" didn't even use λ originally
06:18:00 <mauke> λ was just a workaround because the printer couldn't handle the punctuation-based syntax
06:18:02 <_emm_> meditans: nope
06:18:36 <meditans> _emm_ omg, I have to look back at that package then
06:18:39 <_emm_> meditans: at least https://github.com/dag/vim2hs doesn't
06:19:28 <meditans> ok, guys, you convinced me to use \ with at most some cosmetic changes :D
06:19:57 <meditans> mauke: how did lambda calculus look like, then?
06:20:18 * hackagebot phone-push 0.1.3 - Push notifications for Android and iOS  http://hackage.haskell.org/package/phone-push-0.1.3 (DavidFendrich)
06:21:07 <mauke> x̂.x
06:21:09 <ski> `î. i+1' instead of `λi. i+1', or something like that
06:21:50 <meditans> mauke, ski, so the name lambda calculus is a later add?
06:21:56 <niteria> http://mth.io/talks/haskell-in-production/#/5, does anyone know what 'Z' is referred to here?
06:21:59 <mauke> meditans: yes
06:22:07 <int-e> meditans: http://int-e.eu/~bf3/tmp/lambda.png ;-)
06:22:08 <tero-> I'd want to distribute an executable through hackage that needs alex- and happy- tools
06:22:14 <meditans> wow, that's interesting to know
06:22:22 <quchen> Circumflex calculus!
06:23:27 <meditans> int-e i see :D
06:24:00 <tero-> can I somehow require that they are present or should I just include the sources for the generated lexer and parser
06:29:04 <ski> meditans : <http://math.stackexchange.com/questions/64468/why-is-lambda-calculus-named-after-that-specific-greek-letter-why-not-rho-calc>,<https://mail.mozilla.org/pipermail/es-discuss/2008-December/008520.html>,<http://enl.usc.edu/~jkna/fpl/church.pdf>
06:29:30 <EvanR> int-e: ya unifont lambda looks funny
06:29:43 <EvanR> backwards h sort of
06:30:01 <meditans> ski thanks for the link but returns a 404
06:30:09 <niteria> is there a Z monad in yesod?
06:30:44 <meditans> ski no ok it doesn't :D
06:30:52 <ski> three links, all work here
06:31:05 <saml> can i fold  (different type of) monads?
06:31:08 <meditans> yes, thanks very much
06:31:30 <saml> I have  MySQLQuery, ElasticSearchQuery, MongoDBQuery command (a list of)
06:31:46 <saml> and I have a initial JSON. I want to fold those commands and snowball the initial JSON
06:31:57 <saml> you know what i mean?
06:32:05 <EvanR> SNOBOL
06:32:30 <quchen> saml: No, foldM requires you to have the same Monad all along the way if that's what you mean
06:32:44 <EvanR> saml: you can lift each one
06:32:50 <EvanR> maybe
06:32:51 <quchen> saml: You would have to convert them to a common format first
06:33:06 <saml> {"tags": ["door"], "author": "saml"}      after fold, I'll get  {"tags": [{"id": "door", "title": "Door", "url": "http://elasticsearch..." }], "author": {"id": "saml", "sex": "good", .. } }
06:33:59 <saml> so given id, I need a way to fetch detailed data of the id
06:34:20 <saml> in SQL, snowballing is standardized as JOIN
06:34:47 <EvanR> if snowball means fold, then snowball doesnt mean join
06:34:47 <bartavelle> you mean, given the id, getting the information from all 3 sources ?
06:34:52 <saml> but since we are living in hipster json saas soa restful crap... i need a good way to snowball json
06:35:11 <bartavelle> and doing an "union" ?
06:35:55 <saml> i mean.. i have different services (most speak HTTP. some tcp). need to fetch data and combine them to single json before sending the json to html template writing thingy
06:36:17 <EvanR> do it in three separate steps
06:36:17 <saml> not sure why data is across differetn services. i need a babelfish
06:37:32 <saml> 1.  get all data.   2. cross product    3. filter out good ones   ?
06:37:43 <saml> filter using map reduce
06:38:54 <EvanR> you want a json operation to put three things in one object?
06:46:18 <_Sgoettschkes> Hi guys
06:47:32 <Sgoettschkes> fighting with haskell data types right now. Maybe somebody can help me:
06:49:25 <k00mi_> Sgoettschkes: just describe your problem, that's the best way to get help
06:49:49 <Sgoettschkes> I'm trying to get some minor code example
06:50:08 <Sgoettschkes> which describes my problem
06:50:13 <k00mi_> use hpaste if it is more than one line
06:50:16 <k00mi_> @where hpaste
06:50:17 <lambdabot> http://hpaste.org/
06:52:52 <Sgoettschkes> Thanks k00mi_
06:52:56 <Sgoettschkes> Here it is: http://hpaste.org/88350
06:53:50 <ski>   num `div` 2
06:54:20 <Sgoettschkes> really?
06:54:52 <ski> `div' is integral division, `/' is for exact division (or as close to it as possible, for floating-point)
06:54:59 <k00mi_> Sgoettschkes: the problem is that (/) expects a Fractional a but mod expects a Integral a and there is no type that is an instance of both
06:55:12 <Sgoettschkes> I see
06:56:33 <ski> @type \n -> floor (fromIntegral n / 2)
06:56:35 <lambdabot> (Integral a, Integral b) => a -> b
06:56:41 <ski> @type \n -> n `div` 2
06:56:43 <lambdabot> Integral a => a -> a
06:57:02 <ski> the former above would also work ..
06:57:26 <ski> `fromIntegral' to convert from your integral type to a fractional type for `/')
06:58:06 <Sgoettschkes> Thanks ski and k00mi_
07:01:37 <Zeev> what is IO
07:01:42 <ski> a type
07:01:48 <Zeev> I see it in a lot types declarations
07:02:16 <opqdonut> the type of side effects
07:02:19 <merijn> Zeev: It's the type for stateful computations that have/perform IO operations
07:02:39 <ski> it's a way to separate code which interacts with the world outside the process executing the program, and code which just computes results from arguments
07:03:06 <kartlos_> is there a function that concatenates the elements of [IO String]?
07:03:18 <mauke> kartlos_: what do you mean by "concatenate"?
07:03:29 <ski> @type mapM concat . sequence
07:03:30 <lambdabot> [[[b]]] -> [[b]]
07:03:44 <ski> er
07:03:47 <ski> @type liftM concat . sequence
07:03:49 <lambdabot> Monad m => [m [a]] -> m [a]
07:04:03 <ski> is perhaps what kartlos_ had in mind
07:04:09 <kartlos_> wow confusing types
07:04:21 <ski> `[a]' can be `String' (when `a' is `Char')
07:04:35 <ski> @type liftM concat . sequence :: [IO String] -> IO String
07:04:36 <lambdabot> [IO String] -> IO String
07:04:39 <kartlos_> aaa ok, I get it
07:04:51 <kartlos_> thanks!
07:04:52 <blueonyx> @type sequence
07:04:54 <lambdabot> Monad m => [m a] -> m [a]
07:05:25 <merijn> :t fmap concat . sequence :: [IO String] -> IO [String]
07:05:27 <lambdabot>     Couldn't match expected type `String' with actual type `Char'
07:05:27 <lambdabot>     Expected type: [IO String] -> IO [[String]]
07:05:27 <lambdabot>       Actual type: [IO String] -> IO [String]
07:05:32 <ski> `sequence' takes the list of `IO'-actions, and returns an `IO'-action that when executed will execute the given `IO'-actions (in the given order in the list), and yield a list of all the individual results of the `IO'-actions
07:05:35 <merijn> aww
07:05:39 <merijn> :t fmap concat . sequence :: [IO String] -> IO String
07:05:40 <lambdabot> [IO String] -> IO String
07:06:26 <ski> then `liftM concat' takes this `IO'-action that yields a list of strings, and gives an `IO'-action that when executed will execute the given action, and then concatenate the resulting list of strings to a single string
07:06:30 <ski> kartlos_ : ok ?
07:06:57 <kartlos_> ok :) thanks everyone!
07:07:16 <ski> kartlos_ : however, depending on what you're doing, it might be nicer not to construct your list of `IO'-actions to begin with ..
07:07:34 <merijn> kartlos_: Also, how are you ending up with "[IO String]" sounds like you might be better of using mapM somewhere
07:07:42 <ski> e.g. if you use `map' to construct it, you may use `mapM' instead to get to `IO [String]' directly
07:07:46 <kartlos_> ski: yes I think you're right about that
07:08:17 <ski>   mapM f = sequence . map f
07:08:33 <ski> @src mapM
07:08:33 <lambdabot> mapM f as = sequence (map f as)
07:09:12 <kartlos_> merijn: I have a function that returns IO String, now I want it to returns n times IO String, so I wrote a function that calls the first one recursively N times and builds a list
07:09:48 <merijn> kartlos_: Oh, sounds like you want replicateM
07:09:51 <merijn> :t replicateM
07:09:53 <lambdabot> Monad m => Int -> m a -> m [a]
07:10:06 <kartlos_> sounds promising :)
07:10:20 * hackagebot music-pitch 1.2 - Abstract representation of musical pitch.  http://hackage.haskell.org/package/music-pitch-1.2 (HansHoglund)
07:10:22 * hackagebot music-pitch-literal 1.2 - Overloaded pitch literals.  http://hackage.haskell.org/package/music-pitch-literal-1.2 (HansHoglund)
07:10:24 * hackagebot music-dynamics 1.2 - Abstract representation of musical dynamics.  http://hackage.haskell.org/package/music-dynamics-1.2 (HansHoglund)
07:10:26 * hackagebot music-dynamics-literal 1.2 - Overloaded dynamics literals.  http://hackage.haskell.org/package/music-dynamics-literal-1.2 (HansHoglund)
07:10:28 * hackagebot music-parts 1.2 - To be written.  http://hackage.haskell.org/package/music-parts-1.2 (HansHoglund)
07:10:32 <ski> @src replicateM
07:10:32 <lambdabot> replicateM n x = sequence (replicate n x)
07:10:45 <merijn> :t iterateM
07:10:47 <lambdabot>     Not in scope: `iterateM'
07:10:47 <lambdabot>     Perhaps you meant one of these:
07:10:47 <lambdabot>       `iterate' (imported from Data.List),
07:10:48 <quchen> kartlos_: sequence is a pretty handy function from which other combinators can be derived easily (replicateM, mapM, ...). If you understand sequence, you can come up with the others pretty easily.
07:11:07 <merijn> :t iterate
07:11:08 <lambdabot> (a -> a) -> a -> [a]
07:11:22 <kartlos_> quchen: is there a tutorial about these functions?
07:11:24 <merijn> :t \f -> sequence . iterate f
07:11:25 <lambdabot> Monad m => (m a -> m a) -> m a -> m [a]
07:11:41 <merijn> :t \f -> sequence . (iterate f=<<)
07:11:42 <lambdabot> Monad m => (m a -> m a) -> [m a] -> m [a]
07:11:46 <merijn> hmm
07:11:51 <merijn> that's not right
07:11:59 <merijn> kartlos_: Hoogle is your friend :)
07:12:01 <ski> @type \f -> sequence . iterate (f =<<)
07:12:02 <lambdabot> Monad m => (a -> m a) -> m a -> m [a]
07:12:09 <merijn> ski: Oh..duh
07:12:24 <merijn> @hoogle Int -> m a -> m [a]
07:12:25 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
07:12:25 <lambdabot> Test.QuickCheck.Gen vectorOf :: Int -> Gen a -> Gen [a]
07:12:25 <lambdabot> Test.QuickCheck vectorOf :: Int -> Gen a -> Gen [a]
07:12:26 <kartlos_> merijn: true, hoogle is awesome
07:12:56 <merijn> kartlos_: Also, just browsing through the Prelude can't hurt
07:13:31 <quchen> kartlos_: Sequence isn't that difficult, you can understand it in a couple of minutes. Intuitively, sequence performs each action of a monadic list and gathers the results. It takes a [m a] and creates a m [a] out of it. sequence (mx:mxs) = do { x <- mx; xs <- sequence mxs; return (x:xs) }
07:13:36 <kartlos_> merijn: I don't think these functions are in the prelude
07:14:10 <quchen> kartlos_: So what this does is it "<-"s the value out of the head of the list, then recursively does that for all other elements, and calls 'return' on all these values.
07:14:36 <kartlos_> quchen: thanks, that seems to make sense :)
07:14:48 <quchen> kartlos_: Here's a more visual version of what I meant: http://hpaste.org/88352
07:14:50 <Sculptor> yo
07:15:30 * hackagebot music-articulation 1.2 - Abstract representation of musical articulation.  http://hackage.haskell.org/package/music-articulation-1.2 (HansHoglund)
07:15:32 * hackagebot music-score 1.2 - Musical score and part representation.  http://hackage.haskell.org/package/music-score-1.2 (HansHoglund)
07:15:34 * hackagebot hamid 0.7 - Binding to the OS level MIDI services  http://hackage.haskell.org/package/hamid-0.7 (HansHoglund)
07:15:36 <quchen> kartlos_: For comparison, I annotated it with mapM so you can see how little that adds to the concept
07:15:36 * hackagebot reenact 0.6 - A reimplementation of Conal Elliott's Reactive.  http://hackage.haskell.org/package/reenact-0.6 (HansHoglund)
07:15:56 <quchen> sequence is the hard(er) function to understand, once you got that one mapM is trivial :-)
07:16:22 <kartlos_> quchen: thank you, I'll have to study your example and let that sink in :)
07:17:20 <quchen> kartlos_: For practical purposes, think of sequence as "factoring the monad out of a list". Got "[m" but want "m ["? Sequence it! :-)
07:18:20 <kartlos_> quchen: interesting!
07:20:18 <hamid> lol. a library named after me.
07:20:21 * hackagebot musicxml2 1.4 - A representation of the MusicXML format.  http://hackage.haskell.org/package/musicxml2-1.4 (HansHoglund)
07:22:43 <Zeev> haskell learning question: why this works: main = appendFile "log.txt" (Text.Printf.printf "Hello\n") and this doesn't work: main = appendFile "log.txt" (Text.Printf.printf "Hello,%d\n" 5)
07:23:21 <Zeev> phhhhhh f# is so easy
07:23:40 <Adeon> hmm, still no new haskell platform
07:23:47 <Adeon> anyone happen to know how imminent the next release is?
07:23:48 <merijn> Adeon: RC is done
07:24:05 <merijn> So Anytime Now(TM)
07:24:14 <merijn> Zeev: What's the error you get?
07:25:21 * hackagebot music-preludes 1.2 - Some useful preludes for the Music Suite.  http://hackage.haskell.org/package/music-preludes-1.2 (HansHoglund)
07:25:57 <Zeev> merjin: Ambiguous type variable `a0' in the constraints:
07:26:24 <Zeev> merjin: Probable fix: add a type signature that fixes these type variable(s)
07:26:51 <Zeev> merjin: In the second argument of `printf', namely `5'
07:27:08 <mr-> Zeev: have you tried something like (5 :: Int) ?
07:27:56 <Zeev> merijn: sorry for nickname mess
07:28:20 <zardoz8> printf is evil :D
07:28:32 <zerokarmaleft> Zeev: are you trying to append "Hello,5" to log.txt or log something as you append to it?
07:28:57 <merijn> Zeev: Yeah, try adding "(5 :: Int)" or "Text.Printf.printf "Hello,%d\" 5 :: String"
07:29:16 <merijn> printf uses awful typeclass voodoo to fake varargs functions
07:29:20 <merijn> :t printf
07:29:21 <lambdabot> PrintfType r => String -> r
07:29:31 <merijn> :t printf "Hello,%d\n"
07:29:32 <lambdabot> PrintfType r => r
07:29:36 <merijn> > printf "Hello,%d\n" 5
07:29:38 <lambdabot>   Ambiguous type variable `a0' in the constraints:
07:29:38 <lambdabot>    (GHC.Show.Show a0)
07:29:38 <lambdabot>     ...
07:29:41 <merijn> > printf "Hello,%d\n" 5 :: String
07:29:41 <kennyd> Zeev 5 is a polymorphic value, and printf call doesn't know what type it should be.
07:29:43 <lambdabot>   "Hello,5\n"
07:29:48 <kennyd> :t 5
07:29:49 <lambdabot> Num a => a
07:29:52 <Adeon> I did not know there is a printf for haskell
07:29:59 <mauke> there are at least 2
07:30:04 <merijn> kennyd: No, it doesn't know which type printf should be
07:30:12 <magicman> Yeah, definitely the 5, not the result of the printf call. That gets forced by appendFile.
07:30:14 <kennyd> right
07:30:29 <merijn> @hoogle appendFile
07:30:30 <lambdabot> Prelude appendFile :: FilePath -> String -> IO ()
07:30:30 <lambdabot> System.IO appendFile :: FilePath -> String -> IO ()
07:30:30 <lambdabot> Data.ByteString appendFile :: FilePath -> ByteString -> IO ()
07:30:40 <kennyd> merijn no actually, it does. appendFile accepts a String
07:30:48 <merijn> hmm, yeah, you're right
07:31:02 <ski> @type let mapInterleaveIO :: (a -> IO b) -> [a] -> IO [b]; mapInterleaveIO f = foldr (\a -> System.IO.Unsafe.unsafeInterleaveIO . liftM2 (:) (f a)) (return []) in mapInterleaveIO
07:31:04 <lambdabot> (a -> IO b) -> [a] -> IO [b]
07:31:17 <ski> @type let foldrInterleaveIO :: (a -> IO b -> IO b) -> IO b -> [a] -> IO b; foldrInterleaveIO f = foldr (\a -> System.IO.Unsafe.unsafeInterleaveIO . f a) . System.IO.Unsafe.unsafeInterleaveIO in foldrInterleaveIO
07:31:19 <lambdabot> (a -> IO b -> IO b) -> IO b -> [a] -> IO b
07:32:56 <zardoz8> Zeev are you reading LYAH? it explains pretty well what IO is
07:33:39 <Zeev> zardoz8: yeah it looks like I have no choice if I ever wanna use haskell
07:33:58 <Zeev> ...
07:42:54 <zardoz8> basically, IO describes what would be side effects in other languages. the purpose is to separate pure and impure code
07:43:31 <zardoz8> and it's done at type level, if you try to call IO String from a function that returns String you will get compile error
07:47:23 <merijn> zardoz8: Except that it doesn't separate pure and impure code as it's all pure...
07:47:42 <Chousuke> merijn: in practice it does
07:48:30 <merijn> Actually...I'm waiting for some colleagues. Now is as good a time as any to write my "IO a first class programs" article
07:55:35 <Chousuke> that's one benefit of doing imperative programming in haskell; that you can treat entire programs as first-class values
07:55:48 <edwardk> merijn: http://www.ugcs.caltech.edu/~keegan/talks/first-class-concurrency/talk.pdf makes a good study of that "IO as first class programs" argument
07:56:22 <Fuuzetsu> I swear that all Haskell groups are in Boston…
07:58:34 <merijn> edwardk: That's something else from what I had in mind, though
07:58:44 <edwardk> fair nuff
07:58:56 <merijn> I wanted to clear up the whole "IO code is impure" confusion many people seem to have
07:59:06 <FreeFull> The nice thing about imperative programming in Haskell is programmable semicolons
07:59:42 <FreeFull> Not many languages have the list monad or the state monad
08:00:22 * hackagebot music-preludes 1.2.1 - Some useful preludes for the Music Suite.  http://hackage.haskell.org/package/music-preludes-1.2.1 (HansHoglund)
08:05:20 <dolio> Pretty sure there's only the one in Boston.
08:05:47 <Fuuzetsu> It must be pretty active then because I see it pop up everywhere.
08:05:48 <Chousuke> FreeFull: those are not even imperative though
08:07:33 <djahandarie> dolio, you haven't heard of the Cambridge Haskell Cabal?
08:07:49 <dolio> No, and I live in Cambridge!
08:08:27 <djahandarie> It's pretty exclusive.
08:09:23 <dolio> Apparently.
08:10:23 * hackagebot music-score 1.2.1 - Musical score and part representation.  http://hackage.haskell.org/package/music-score-1.2.1 (HansHoglund)
08:11:32 <dcoutts_> djahandarie: :-)
08:12:06 <dcoutts_> djahandarie: we have one in Oxford too, pub meetings planning Haskell world domination
08:12:50 <dmwit> Are you thinking what I'm thinking, dcoutts_?
08:13:03 <dcoutts_> dmwit: almost certainly
08:14:34 <adinapoli> It's sad that I live in the grey Manchester and we don't have any Haskell user groups, just clouds and rain =_=
08:15:23 <Fuuzetsu> It's sad that I only heard about interest for user group in Manchester after I moved out of the area to study
08:15:41 <Fuuzetsu> adinapoli: From what I hear, there's a functional programming group that meets weekly
08:15:44 <Kinnison> Which 'grey Manchester' ?
08:16:03 <Kinnison> If the one in the UK, there's (at minimum) a monthly FP meeting (Manchester Lambda Lounge)
08:16:06 <merijn> There doesn't seem to be an Edinburgh haskell group :\
08:16:54 <Fuuzetsu> Anyone in the Bristol (UK) area?
08:19:08 <djahandarie> merijn, surely you could just go hang out with Philip Wadler.
08:19:13 <FreeFull> Chousuke: How are those not imperative?
08:23:46 <merijn> djahandarie: How is he in person? I saw he was looking for phds...
08:24:25 <djahandarie> Never met him. Probably a cool guy though.
08:28:20 <Chousuke> FreeFull: well, there's nothing impure about them
08:36:22 <Saizan> allowing mutation, what would be the most efficient datastructure for a map with keys of type [Int32]? (and values of type Int32)
08:37:37 <ziman> how long are the lists?
08:38:26 <Saizan> quite short, around ~10 elements
08:40:21 <fizbin> Saizan - explain what kind of mutation you have in mind.
08:40:24 * hackagebot reenact 0.7 - A reimplementation of Conal Elliott's Reactive.  http://hackage.haskell.org/package/reenact-0.7 (HansHoglund)
08:40:24 <ziman> and what efficiency do you have in mind, insert, lookup, delete, memory consumption?
08:41:00 <Saizan> insert/lookup, no delete or update
08:41:19 <Saizan> and i'm mostly interested in time efficiency
08:42:52 <Saizan> basically this is about traversing an AST and building a graph-like representation maximizing sharing which then gets serialized
08:44:00 <ziman> hm, i'd expect a hash table to perform best in such cases; something compact that would play well with caches, too
08:44:21 <Saizan> the current cose is using hashtables from hackage
08:44:24 <Saizan> *code
08:47:14 <FreeFull> Chousuke: There is nothing impure about the ST monad
08:47:20 <FreeFull> And the ST monad is very imperative
08:53:21 * djahandarie wonder how hashtables compares against unordered-containers
08:53:36 <kennethmosquera> best way to store conceptual maps
08:54:13 <djahandarie> HashMap is a patricia tree I think, so it's probably slower but it'd be interesting to actually test them on different datasets
08:55:09 <Saizan> yeah, HashMap uses IntMap
08:56:04 <kennethmosquera> http://hpaste.org/88357
08:56:15 <kennethmosquera> i want to store that
08:57:30 <Saizan> kennethmosquera: it depends on the operations you'll need on it
08:58:16 <kennethmosquera> modify add delete
09:00:10 <Saizan> i guess you can build something with Data.Map
09:00:13 <illuminato> a *.jar file is a binary file, right, not compressed intellegible java
09:00:25 * hackagebot musicxml2 1.4.1 - A representation of the MusicXML format.  http://hackage.haskell.org/package/musicxml2-1.4.1 (HansHoglund)
09:00:34 <applicative> a *.jar file is a binary file, right, not compressed intellegible java
09:01:06 <Botje> it's a zip containing .class files.
09:01:12 <Botje> you can decompile .class files quite easily.
09:01:24 <Botje> especially if they contain debugging information
09:02:16 <applicative> ah a zip file
09:03:39 <elliott> Saizan: does it?
09:03:45 <elliott> I hear HashMap can oiutperform IntMap
09:05:25 * hackagebot music-score 1.2.2 - Musical score and part representation.  http://hackage.haskell.org/package/music-score-1.2.2 (HansHoglund)
09:06:41 <Saizan> elliott: the code says so
09:07:32 <elliott> Saizan: pfft, in my experience you can't trust the code
09:07:58 <applicative> Botje: grr.  in any case, it is true to say that if you give me the jar file, I have to decompile in order to figure out what the source was like
09:08:12 <applicative> or the .jar thingy
09:08:29 <Botje> you could also stare at the bytecode and reverse engineer the source from there.
09:08:51 <Botje> but that's just doing decompilation by hand :)
09:09:11 <applicative> Botje: I see; I was asking because a question about what is 'public' and 'scientific evidence' etc. was at issue
09:09:36 <applicative> Botje: thanks.
09:10:06 <applicative> It seems to me that there is a path to the defense of Haskell or some successor language as potentially making the use of computation in science actually be science.
09:11:55 <applicative> that is, so that the terms and claims in the scientific essay are discoverable in the attached files
09:11:55 <applicative> not that they bother to attach files
09:12:14 <merijn> elliott: You can't trust hardware either :p
09:12:25 <merijn> elliott: In short, you can't trust anything :p
09:12:32 <armlesshobo> LOL
09:12:39 <armlesshobo> lock yourself up in your closet
09:13:19 <elliott> I certainly can't trust shachaf
09:15:12 <merijn> I'm not even joking, just read "Reflections on Trusting Turst" and any paper on "malicious hardware" and you just give up on security ;p
09:15:30 <elliott> http://www.dwheeler.com/trusting-trust/ might help restore some faith
09:17:17 <merijn> elliott: Then you're still screwed if you believe King et al. in "Designing and Implementing Malicious Hardware" :p
09:17:50 <elliott> I think the same technique is applicable to hardware to some degree or some such
09:18:09 <elliott> no idea as tothe details though
09:25:26 * hackagebot reenact 0.7.1 - A reimplementation of Conal Elliott's Reactive.  http://hackage.haskell.org/package/reenact-0.7.1 (HansHoglund)
09:30:26 * hackagebot reenact 0.7.2 - A reimplementation of Conal Elliott's Reactive.  http://hackage.haskell.org/package/reenact-0.7.2 (HansHoglund)
09:30:28 * hackagebot reenact 0.7.3 - A reimplementation of Conal Elliott's Reactive.  http://hackage.haskell.org/package/reenact-0.7.3 (HansHoglund)
09:35:45 <int80_h> Hey, anyone care to talk about the Reactive Banana library with me?
09:35:49 <otters> is it just me, or does System.Directory lack a way to remove everything *in* a certain directory
09:37:11 <Fuuzetsu> @hoogle System.Directory
09:37:11 <lambdabot> package directory
09:37:12 <lambdabot> package directory-tree
09:37:12 <lambdabot> System.Posix.Files directoryMode :: FileMode
09:37:18 <Fuuzetsu> @package System.Directory
09:37:18 <lambdabot> http://hackage.haskell.org/package/System.Directory
09:37:29 <otters> yeah, looks that way
09:37:34 <otters> ah well
09:37:37 <Kinnison> otters: getDirectoryContents foo >>= mapM_ removeFile
09:37:38 <Kinnison> ?
09:37:43 <otters> close enough
09:38:54 <Kinnison> otters: getDirectoryContents >=> mapM_ removeFile
09:38:56 <Kinnison> otters: even
09:39:05 <Fuuzetsu> otters: or ‘removeDirectoryRecursive dir >> createDirectory dir where dir = "foo"’
09:39:53 <otters> heh
09:40:55 <Kinnison> otters: Enough options for you? :-)
09:41:10 <Fuuzetsu> We're only on two.
09:41:22 <otters> Kinnison: yeah, that's about enough
09:41:28 <otters> thanks
09:42:09 * Kinnison wishes he'd known about >=> and <=< before
09:42:14 <Kinnison> mmm pretty arrows
09:42:15 <otters> the first solution was what I was gonna do, but I wasn't sure how I felt about calling removeFile for every file instead of just issuing a "remove everything in the directory" command, like exec("rm dir/*")
09:42:18 <Fuuzetsu> :t (>=>)
09:42:20 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
09:42:20 <otters> but I guess they're equivalent when it comes down to it
09:42:23 <Fuuzetsu> I always forget what they do
09:42:37 <otters> kliesli composition, NOOB
09:42:54 <Fuuzetsu> otters: rm dir/* is just rm on every file
09:42:56 <Fuuzetsu> your shell expands the *
09:43:02 <otters> yeah, I know
09:43:07 <otters> that's why I said I guess they're equivalent
09:43:14 <otters> is it considered bad practice to use fromString in code?
09:43:16 <Kinnison> Fuuzetsu: Like >>= but composition rather than bind
09:43:36 <Fuuzetsu> I always think of bind as composition…
09:43:44 <otters> haha
09:43:47 <bartavelle> this is a nightmare : memory corruption during the Ruby GC (I try to embed the ruby intepreter into my program). I can reproduce it, but checked everything I did and can't find why. If someone has wisdom to share on debugging that kind of problems, I am interested
09:43:52 <Kinnison> Fuuzetsu: I've been trying to learn to use composition more.  I was overfond of $ until I learned how to . things better
09:44:13 <Fuuzetsu> I use $ where . results in arcane code
09:44:33 <Fuuzetsu> :t (fromString)
09:44:34 <lambdabot>     Not in scope: `fromString'
09:44:34 <lambdabot>     Perhaps you meant `showString' (imported from Prelude)
09:44:40 <Fuuzetsu> @hoogle fromString
09:44:41 <lambdabot> Data.String fromString :: IsString a => String -> a
09:44:41 <lambdabot> GHC.Exts fromString :: IsString a => String -> a
09:44:41 <lambdabot> Data.Text.Lazy.Builder fromString :: String -> Builder
09:44:52 <Fuuzetsu> I don't see why it would be
09:49:44 <c_wraith> Fuuzetsu: there is no place (.) results in arcane code where ($) does not.
09:51:13 <dolio> Unfortunately, there are a few situations in GHC now where 'f $ g $ x' can't be replaced by 'f . g $ x'.
09:51:43 <c_wraith> all ones involving non-prenex typing, right?
09:52:00 <dolio> Yeah.
09:52:01 <dolio> $ is magic.
09:54:45 <zardoz8> dolio n you give an example ?
09:54:48 <zardoz8> can
09:55:18 <dolio> So, runST $ ... works
09:55:18 <dolio> Because there's a special-case hack to make that work.
09:56:02 <dolio> Say the output of that is Maybe Int.
09:56:03 <dolio> You can write: fromMaybe 0 $ runST $ ...
09:56:15 <dolio> However, if you try to write fromMaybe 0 . runST $ ...
09:56:36 <dolio> It won't work, becuase that would require a similar special-case hack for . to be used with runST.
10:04:29 <otters> Kinnison: you sinister son of a gun
10:05:01 <otters> getDirectoryContents returns . and .. in the output
10:06:32 * geekosaur was wondering about that...
10:07:01 <geekosaur> (not that you can unlink either of them. following them, otoh...)
10:13:19 <otters> of course testing for . and .. makes that much less of a pleasant one-liner
10:15:43 <merijn> just filter before passing to mapM
10:15:59 <otters> or \\
10:16:20 <Fuuzetsu> just removeRecursively
10:16:29 <otters> good idea
10:21:29 <b___> > let f a b n = [a, a + (b - a) / n .. b] in f 2 1 10
10:21:31 <lambdabot>   [2.0,1.9,1.7999999999999998,1.6999999999999997,1.5999999999999996,1.4999999...
10:21:38 <b___> > let f a b n = [a, a + (b - a) / n .. b] in last $ f 2 1 10
10:21:40 <lambdabot>   0.9999999999999991
10:21:45 <b___> > let f a b n = [a, a + (b - a) / n .. b] in last $ filter (> 1) $ f 2 1 10
10:21:47 <lambdabot>   1.0999999999999992
10:22:18 <b___> why do these differ?
10:22:40 <Fuuzetsu> floating point errors
10:22:53 <Fuuzetsu> There's a post on haskell-cafe about this
10:23:03 <b___> okay, thanks
10:23:43 <b___> Do you know where it's at? If not I'll look it up
10:24:26 <Fuuzetsu> I'm looking for it now
10:24:38 <Fuuzetsu> Google is being useless so I'll have to look through my mail client, give me a sec
10:24:40 <b___> much appreciated
10:25:28 <geekosaur> b___, you can find references on the issues with floating point with google if you look around
10:25:30 <Fuuzetsu> http://comments.gmane.org/gmane.comp.lang.haskell.beginners/11369
10:25:30 <geekosaur> has nothing to do with haskell
10:25:32 <geekosaur> floaing point is inherently inexact
10:25:35 <supki> > 0.1 + 0.2
10:25:36 <lambdabot>   0.30000000000000004
10:26:58 <b___> yes but these differences
10:27:01 <b___> > let f a b n = [a, a + (b - a) / n .. b] in last $ filter (> 1) $ f 2 1 10
10:27:03 <lambdabot>   1.0999999999999992
10:27:05 <b___> > let f a b n = [a, a + (b - a) / n .. b] in f 2 1 10
10:27:07 <lambdabot>   [2.0,1.9,1.7999999999999998,1.6999999999999997,1.5999999999999996,1.4999999...
10:27:11 <b___> > let f a b n = [a, a + (b - a) / n .. b] in last $ f 2 1 10
10:27:13 <lambdabot>   0.9999999999999991
10:27:29 <b___> it has something to do with list comprehensions right?
10:27:38 <Fuuzetsu> it has to do with how you build it up
10:27:42 <Fuuzetsu> look into the thread I linked
10:27:54 <b___> I will, thanks :)
10:39:53 <mietek> There really should be a chunksOf for List and ByteString, not just Text
10:44:13 <supki> mietek: there is chunksOf for [] in split
10:45:54 * typoclass wishes the split package came with ghc
10:46:19 <mietek> supki: I know, what I meant — in the standard library
10:47:11 <supki> well, split is in platform
10:47:30 <Kinnison> otters: bleh :-)
10:47:40 <Kinnison> otters: I was only guessing :-)
10:51:36 <monochrom> Haskell Platform has awesome packages such as split, vector, async, unordered-containers, and new OpenGL stuff
11:01:57 <kennethmosquera> is there a reverse haskell function
11:02:17 <typoclass> > reverse "lolcats" -- kennethmosquera: you mean this?
11:02:18 <lambdabot>   "staclol"
11:02:51 <kennethmosquera> reverse function
11:03:29 <kennethmosquera> rbol :: Tree a -> Arbol a a
11:03:29 <kennethmosquera> rbol (Node a []) = Hoja a
11:03:30 <kennethmosquera> rbol (Node b [cs, ds]) = Rama b (rbol cs) (rbol ds)
11:04:23 <lispy> monochrom: yeah, mzero has done a lot of good leg work to make this release useful to a wide audience
11:04:36 <monochrom> and also you!
11:04:45 <kennethmosquera> reverse rbol
11:04:47 <kennethmosquera> rbol :: Arbol a a -> Tree a
11:04:47 <kennethmosquera> rbol (Hoja a) = Node a []
11:04:48 <kennethmosquera> rbol (Rama b cs ds) = Node b [rbol cs, rbol ds]
11:04:51 <lispy> eh, I mostly merge pull requests :)
11:05:37 <otters> > reverse "citats"
11:05:39 <lambdabot>   "static"
11:07:37 <dmwit> kennethmosquera: http://stackoverflow.com/a/13404681/791604
11:10:46 <kennethmosquera> thnx
11:20:31 * hackagebot process-listlike 0.6 - Enhanced version of process-extras  http://hackage.haskell.org/package/process-listlike-0.6 (DavidFox)
11:22:14 <ski> .. `rbol' sounds ominous
11:23:02 <dmwit> just sounds like a pun for "arbol" to me =P
11:23:34 <hseg> Was reading through some of the numerical prelude code and found two features of the language I hadn't heard of before:
11:23:52 <hseg> http://hackage.haskell.org/packages/archive/numeric-prelude/0.4.0.1/doc/html/src/Number-SI-Unit.html : Multiple names can be assigned the same type as follows:
11:23:56 <tdammers> sounds like a pun for COBOL to me
11:23:59 <hseg> a,b,c,d,... :: T
11:24:30 <merijn> hseg: Yes?
11:24:39 <dmwit> hseg: Yep. In records, too. data Foo a = Foo { xlo, xhi, ylo, yhi :: Int, v :: a }
11:25:14 <hseg> That seems odd to me. Also, a source for saving typing a *lot* in parts of my code.
11:25:49 <typoclass> hseg: yes that's possible. it's not very useful if you want to document stuff, since haddock blocks attach to the type signature, so you'd have to pull them apart again (at least i think so)
11:26:13 <hseg> Second: http://hackage.haskell.org/packages/archive/numeric-prelude/0.4.0.1/doc/html/src/Algebra-Laws.html#leftDistributive : Suppose one of the parameters to your function is a function. Then you can bind that function to a symbol, with the usual semantics.
11:26:36 <hseg> i.e. foo (+) (*) x y = x + (y * x)
11:26:39 <typoclass> hseg: ha :-) nice find
11:26:48 <dmwit> ?src on
11:26:48 <lambdabot> (*) `on` f = \x y -> f x * f y
11:27:51 <dmwit> I wonder why they only do it half-assed.
11:28:04 <dmwit> (#) and #, but op and `op`?
11:28:25 <hseg> Yeah, it would more accurately reflect mathematical literature to define these properties in terms of (+) and (*)
11:28:42 <hseg> Odd.
11:29:49 <typoclass> anyway, it wouldn't be bad if some repetition of the function name could be avoided. "doodle :: ... ; doodle 0 = ... ; doodle n = ..."
11:30:12 <dmwit> doodle = \case 0 -> ...; n -> ...
11:31:00 <typoclass> dmwit: hm right. what's the name of the extension again?
11:31:13 <dmwit> LambdaCase, probably =P
11:31:46 <dmwit> And you know the syntax is good because it took several weeks to pick it.
11:32:11 <Fuuzetsu> You mean, we actually managed to agree on syntax?
11:32:19 <dmwit> Oh, heck no.
11:32:41 <hseg> nono, you know it's good because it's got lambda symbols in it. :)
11:32:59 <typoclass> Fuuzetsu: for what it's worth, the ghc wiki doesn't agree :-)
11:33:15 <Fuuzetsu> No one ever agrees.
11:34:04 <beaky> hello
11:34:11 <dmwit> Hello again, beaky.
11:34:22 <hseg> hey
11:34:24 <HBu> hi
11:34:50 <beaky> Is there a functional-programming based GUI toolkit for haskell?
11:35:09 <Fuuzetsu> Didn't you ask about this recently?
11:36:11 <HBu> I've got a newbie question about a curried example from learn you a haskell
11:36:13 <beaky> ah I guess I did ask for some FRP-based API someday
11:36:37 <hseg> HBu: Ask away. Don't ask to ask, just ask.
11:37:04 <HBu> module Scratch where
11:37:04 <HBu> compareWithHundred :: (Num a, Ord a) => a -> Ordering
11:37:04 <HBu> compareWithHundred x = compare 100 x
11:37:04 <HBu> compareWithHundred' :: (Num a, Ord a) => a -> Ordering
11:37:05 <HBu> compareWithHundred' = compare 100
11:37:05 <HBu> loaded in ghci, tried:
11:37:06 <HBu> *Scratch> compareWithHundred 3.0
11:37:06 <HBu> GT
11:37:07 <HBu> *Scratch> compareWithHundred' 3.0
11:37:08 <HBu> GT
11:37:16 <mauke> HBu: fail
11:37:26 <dmwit> In the future, please use hpaste.org or similar for code snippets longer than a line or two.
11:37:29 <typoclass> HBu: hello, welcome to #haskell. please use hpaste.org for code >1 line
11:37:35 <HBu> ah, ok
11:37:45 <conal> beaky: "functional" is a pretty fuzzy term. many different ideas of what it means. (i prefer "denotative", following peter landings advice.) what properties of "functional" are you looking for?
11:37:51 <mauke> because now it only takes a while and your code will have scrolled off
11:38:09 <mauke> and you haven't even asked a question yet
11:38:33 <dmwit> Give him a second, yeesh.
11:39:10 <conal> (peter *landin's* advice)
11:39:16 <beaky> ah
11:40:07 <beaky> well i like the declarative bits of fp
11:40:08 <HBu> http://hpaste.org/88363
11:40:09 <Fuuzetsu> HBu: both of those functions are exactly the same
11:40:27 <Fuuzetsu> oh, I see
11:40:28 <mauke> HBu: monomorphism restriction
11:40:28 <Fuuzetsu> wait
11:40:32 <Fuuzetsu> yeah
11:40:48 <Fuuzetsu> http://www.haskell.org/haskellwiki/Monomorphism_restriction
11:41:30 <dmwit> I can't believe the #haskell FAQ doesn't have an entry on the monomorphism restriction and extended defaulting.
11:41:40 <plhk> is there better way to do this? -> http://hpaste.org/88364
11:41:44 <hseg> beaky: fp <-/-> declarative
11:41:49 <Fuuzetsu> We have an FAQ?
11:42:19 <grlpx> For me functional programming is great, that's why i love JavaScript
11:42:22 <dmwit> ?where faq
11:42:23 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
11:42:31 <typoclass> @faq do we have a faq?
11:42:31 <lambdabot> The answer is: Yes! Haskell can do that.
11:43:06 <Fuuzetsu> @faq is typoclass wrong?
11:43:06 <lambdabot> The answer is: Yes! Haskell can do that.
11:43:24 <dmwit> :t \k v xs -> head $ [v | (k', v) <- xs, k == k'] ++ [v]
11:43:27 <lambdabot> Eq a1 => a1 -> a -> [(a1, a)] -> a
11:43:54 <dmwit> :t def
11:43:55 <lambdabot>     Not in scope: `def'
11:43:55 <lambdabot>     Perhaps you meant `dff' (imported from Data.Graph)
11:43:59 <dmwit> too bad
11:44:06 <elliott> dmwit: you're lucky enough to get to write it :p
11:44:18 * dmwit nods sadly
11:44:23 <grlpx> I think that everything somebody need for lambda programming is javascript, all the rest is whistles and nice looking stuff without practical reason
11:44:43 <elliott> grlpx: you again?!
11:44:47 <Fuuzetsu> whistles and nice looking stuff IS the practical reason
11:45:03 <dmwit> plhk: You might consider defining a named function like lookupWithDef k xs = head $ [v | (k', v) <- xs, k == k'] ++ [def]
11:45:13 <tromp> I think that everything somebody need for lambda programming is  lambda calculus, all the rest is whistles and nice looking stuff without practical reason
11:45:16 <tomejaguar> Why is sortWith in GHC.Exts?
11:45:27 <Fuuzetsu> @hoogle sortWith
11:45:27 <lambdabot> GHC.Exts sortWith :: Ord b => (a -> b) -> [a] -> [a]
11:45:29 <hseg> grlpx: BTL, you should program in Lazy-K.
11:45:34 <dmwit> plhk: Feel free to use the expression you wrote as a lambda if you prefer it, of course. Anyway my point being you should name that lambda.
11:45:40 <hseg> s/BTL/By that logic
11:46:05 <Fuuzetsu> You can't do self-recursion with just lambda
11:46:18 <mauke> :t sortBy . comparing
11:46:21 <lambdabot> Ord a1 => (a -> a1) -> [a] -> [a]
11:46:42 <dmwit> I do think Data.List sholud bundle sortBy . comparing and groupBy . equating, though.
11:46:46 <dmwit> They're such common use cases.
11:47:04 <HBu> so monomorphism restriction means that the guy on youtube that said haskell type signatures were totally optional wasn't as smart as he thought?
11:47:05 <typoclass> grlpx: you're phrasing things a bit provocatively. anyway, as an example, i'd rather write "\x -> x * 2" instead of "function (x) { return x * 2; }". you're right that it's not the end of the world, but it does add up over time and is constant ballast
11:47:08 <tromp> ever heard of Y = \f (\x. x x) (\x. f (x x)) ?
11:47:21 <mauke> HBu: you can always turn it off
11:47:23 <dmwit> HBu: The monomorphism restriction is gone in modern Haskell. Upgrade your compiler. ;-)
11:47:35 <elliott> dmwit: er, it is?
11:47:37 <mauke> HBu: but some things still require explicit type annotations
11:47:39 <elliott> I think it was turned off only in GHCi?
11:47:56 <dmwit> I thought it was taken out of H2010!
11:48:03 <geekosaur> no, sadly
11:48:06 <grlpx> typoclass: Javascript is MUCH more than that
11:48:09 <HBu> mauke: latest haskell package in homebrew ghc 7.4.2
11:48:09 <dmwit> arrrrgh
11:48:10 <elliott> I think you live in a fantasy world. can I move there?
11:48:18 <dmwit> =(
11:48:19 <c_wraith> But yeah, regardless of the monomorphism restriction, there are things where the type can't be inferred.
11:48:27 <mauke> :t show . read
11:48:29 <lambdabot> String -> String
11:49:07 <c_wraith> heh.  lambdabot cheats on that one
11:49:13 <c_wraith> it *shouldn't* compile
11:49:14 <hseg> Especially when stuff gets complicated, or not H98
11:49:26 <c_wraith> > (show . read) "1"
11:49:28 <lambdabot>   "*Exception: Prelude.read: no parse
11:49:31 <Fuuzetsu> lambdabot would never cheat~
11:49:37 <c_wraith> and that's why it shouldn't compile!
11:49:38 * geekosaur wonders if that's ExtendedDefaultRules
11:49:42 <beaky> what is the difference betwen python lists and haskell lists?
11:49:45 <c_wraith> geekosaur: it is
11:49:47 <geekosaur> > (show . read) ()
11:49:49 <lambdabot>   Couldn't match expected type `GHC.Base.String'
11:49:50 <lambdabot>              with actual typ...
11:49:58 <c_wraith> beaky: basically everything. python lists are actually arrays
11:49:59 <elliott> > (show.read) "()"
11:50:01 <lambdabot>   "()"
11:50:02 <beaky> ah
11:50:07 <geekosaur> oops, right
11:50:13 <dmwit> Python lists are hashmaps, aren't they?
11:50:14 <grlpx> you can do this in JavaScript: "var adder = function (x) {return function (y) {return x + y;};};"
11:50:17 <typoclass> beaky: an obvious difference is that python is weakly typed
11:50:27 <mauke> grlpx: why are you talking about javascript?
11:50:31 <hseg> dmwit: Don't think so
11:50:35 <beaky> so python lists are actually HLists?
11:50:35 <Fuuzetsu> grlpx: uh, ok? adder = (+)
11:50:44 <c_wraith> dmwit: no, they're arrays. They only support numerical indexes, and they are contiguous in memory
11:50:49 <beaky> ah
11:50:51 <HBu> so what would be the idiomatic form, is "compareWithHundred x = compare 100 x" better than "compareWithHundred = compare 100" or vice versa?
11:50:56 <grlpx> because javascript it's the only functional language that everybody learn
11:51:07 --- mode: ChanServ set +o mauke
11:51:07 --- mode: mauke set +q $a:grlpx
11:51:11 <hseg> And they're untyped. [1,2,3,"eggs"] is valid Python
11:51:12 <Fuuzetsu> grlpx: Tell that to Python people then
11:51:18 <typoclass> HBu: type signatures are 99% optional in haskell. regarding {-# LANGUAGE Something #-}, i'd guess that average haskell files have about 3 to 5 lines like that. NoMonomorphismRestriction is probably the most popular one
11:51:20 <plhk> dmwit: i think i'll use Data.Map and findWithDefault
11:51:26 <mauke> HBu: I'd just disable the restriction
11:51:28 <Fuuzetsu> adder = lambda x: lambda y: x + y
11:51:31 <dmwit> plhk: Yup, also a great choice.
11:51:56 <c_wraith> addr = (+) -- haskell syntax is optimized for this
11:52:01 <mauke> c_wraith: repost
11:52:07 <c_wraith> oops
11:52:09 <HBu> thx
11:52:17 <aristid> Fuuzetsu: python is most definitely not functional... you can't even put statements in lambdas. i wouldn't call javascript functional either though.
11:52:18 <acube> You can even write a function curry in javascript that converts a function to curried style
11:52:27 <dmwit> In fact, just s/adder/(+)/g. Save yourself a few bytes and a definition.
11:52:28 <beaky> why does haskell use linked lists over arrays as the default sequence type?
11:52:47 <aristid> beaky: it's easier to write the monoid that way
11:52:50 <Fuuzetsu> aristid: It's functional until you can define what functional is and show otherwise
11:52:51 <mauke> beaky: because lazy lists loop better
11:52:52 <acube> beaky: Because with linked lists can be infinite
11:52:53 <dmwit> beaky: Haskell syntax and semantics make inductive types very convenient. Linked lists are inductive; arrays are not.
11:53:08 --- mode: mauke set -o mauke
11:53:15 <Fuuzetsu> I wouldn't recommend it for functional programming but it has (gimped) lambda, first-class functions and now keyworded closures
11:53:33 <dmwit> Also, immutable arrays are useful less often than mutable ones.
11:53:48 <Fuuzetsu> You don't have to use lambda either. You can have inner functions which don't suffer from this restriction
11:53:54 <geekosaur> lists aren't really containers; they're loops encoded as data
11:54:02 <beaky> ah; i guess linked lists have more "functional" properties (operate on the head, recurse on the tail) while arrays are clumsy to use
11:54:25 <monochrom> I didn't know that Haskell "defaults" to the list type.
11:54:41 <aa_> there's nothing wrong with 'arrays'
11:54:46 <monochrom> Some people defaults to the list type, sure.
11:55:02 * applicative wonders how he produced the nick aa_
11:55:17 <c_wraith> applicative: optimization?
11:55:25 <Fuuzetsu> should have just called yourself _
11:55:27 <typoclass> monochrom: i guess it defaults in the sense that there's a bit of special syntax for lists []
11:55:31 <dmwit> obfuscated #haskell
11:55:32 <monochrom> Lisp may also default to the list type, but I wouldn't bet money on even that.
11:55:52 <beaky> arrays need a modue to be imported, [] is always there :D
11:55:54 <monochrom> that's well-supported not default.
11:55:56 <beaky> module*
11:56:00 <beaky> ah
11:56:14 <dmwit> Quit picking on the stupid way the question was asked. Lists are used way more often than arrays in Haskell. Are you really going to dispute that?
11:56:16 <applicative> well thats true, I guess
11:56:18 <monochrom> "default" means if you don't write a type sig then a list type sig is filled in for you.
11:57:02 <applicative> dmwit: I think I disagree, it should be emphasized again and again that [] and : are data List a = Nil | Cons a (List a)
11:57:43 <monochrom> anyway this is mindless chit chat but still I think my "what does default mean" chit chat is still less mindless than the other current chit chats
11:57:50 <beaky> What are arrays and vectors used for in haskell, if lists serve the iteration purpose that arrays are traditionally used for?
11:58:08 <c_wraith> They're used when you want fast indexed lookups
11:58:15 <monochrom> especially since all the other questions seem loaded
11:58:16 <applicative> beaky: they are so unlike, it's really hard to compare them
11:58:24 <typoclass> applicative: still, it seems more convenient to write [1,2,3] than to write Cons 1 (Cons 2 (Cons 3))
11:58:32 <hseg> Or when implementing imperative algorithms
11:58:34 <applicative> arrays and vectors are awesome
11:58:45 <hseg> e.g. union-find
11:58:52 <dmwit> applicative: I'm not sure I understand your objection yet.
11:58:59 <applicative> typoclass: yes, still better to write "typoclass" than Cons 't' (Cons 'y' ...
11:59:24 <dmwit> applicative: (I'm not even sure what you're objecting to!)
11:59:51 <applicative> I'm objecting to your objecting to everyone's objecting to dear beaky 's original objection
11:59:55 <applicative> pretty simple really
12:00:06 <dmwit> I'm not objecting to everybody, only monochrom. =)
12:00:17 <typoclass> it's all very objection-oriented
12:00:32 <duairc> cabal defines MIN_VERSION_base, but not MAX_VERSION_base; how can I accomplish the latter? Specifically I want to say: #if MAX_VERSION_base(4, 5, ); import Prelude hiding (catch); #endif.
12:00:41 * applicative is with monochrom basically, but drops it
12:01:09 <dmwit> #if MIN_VERSION_base(4, 6) #else import Prelude hiding (catch) #endif
12:01:09 <c_wraith> objection-oriented programming, huh?
12:01:20 <beaky> everything is an objection
12:01:25 <typoclass> c_wraith: i'm against that
12:01:26 <applicative> !
12:01:27 <typoclass> =)
12:01:30 <dmwit> Harping on the word "default" isn't helpful when the intention of the question was clear despite the mangled wording.
12:02:23 <hseg> Why do the default implementations of length, take, .. use Ints instead of Integers?
12:02:36 <hseg> It seems like a premature optimization.
12:02:43 <dmwit> 2^64 elements ought to be enough for anybody
12:02:52 <applicative> because it takes so long to take 2 ^ 300 elements of a list
12:02:57 <beaky> probably some early design decision for efficiency, like how java uses primitive Int instead of Integer as the default
12:03:19 <applicative> hm, beaky in Haskell Integer is the default
12:03:27 <beaky> ah
12:03:32 <dmwit> :t genericTake
12:03:33 <lambdabot> Integral i => i -> [a] -> [a]
12:03:34 <typoclass> hseg: i guess in principle you're right. conceptually it should be Integer
12:03:36 * applicative just though he'd say that, on the lame ground that ghci does default to it 
12:03:46 <dmwit> typoclass: No! Conceptually it should be genericTake
12:03:53 <monochrom> dmwit: I don't understand the intention. I think even the intention is mangled.
12:04:26 <hseg> applicative: But wouldn't take (2 ^ 300) evaluate lazily, only consuming those elements in the prefix of length 2^300 that are actually used?
12:04:33 <typoclass> dmwit: hm possibly. you mean it should be "Integral a =>" instead of "Integer"
12:04:39 <dmwit> I do mean that.
12:04:42 <applicative> > length [1 .. 2^300 :: Integer]
12:04:57 <lambdabot>   thread killed
12:05:29 <applicative> hseg: then you would need to use lazy naturals no
12:05:33 * hackagebot process-listlike 0.6.1 - Enhanced version of process-extras  http://hackage.haskell.org/package/process-listlike-0.6.1 (DavidFox)
12:05:41 <dmwit> It is totally within GHC's powers to have a rewrite rule that specializes genericTake to take when it knows the argument is an Int, anyway.
12:05:47 <monochrom> see also today's xkcd. whenever you see some broad wording, it's easy to assume that it refers to concrete things you have in mind, when the intention is the exact opposite: to be broad and void.
12:05:55 <applicative> nlength [] = Z; nlength (x:xs) = S (nlength xs)
12:06:15 * applicative refuses to see todays xkcd
12:06:20 <dmwit> applicative: I thought we were talking about take, not length. =)
12:06:39 <applicative> dmwit: they were both mentioned
12:06:47 <applicative> !! might have been mentioned too
12:07:01 <Fuuzetsu> reminds me to go and have a look at today's xkcd
12:07:03 <dmwit> ...you're right.
12:07:03 <applicative> oh i see, on this
12:07:17 <hseg> Again, wouldn't lazyLength [] = 0; lazyLength (x:xs) = succ (lazyLength xs) just evaluate enough of the stack of succs to calculate whatever property it needs?
12:07:28 <applicative> I was showing how to write nat_take and nat_length or whatever
12:07:47 <dmwit> hseg: Well, it depends on the implementation of succ.
12:07:53 <dmwit> If succ is (+ (1 :: Int)), then no.
12:08:12 <monochrom> it really depends on the specific succ
12:08:15 <dmwit> If succ is S from data Nat = Z | S Nat, then yes.
12:08:45 <applicative> instance Enum Nat where succ = S; pred (S n) = n ; -- ick
12:08:47 <monochrom> succ is a type class method. God knows how many instances are out there doing different things.
12:08:48 <dmwit> :t genericLength
12:08:50 <lambdabot> Num i => [b] -> i
12:09:06 <dmwit> ^^ this is the right type, and allows both lazy and strict number types
12:09:43 <applicative> hseg: the Int thing starts looking kind of sensible, when you consider that there seems to be no limit to arguing about the right starting point
12:09:49 <dmwit> applicative: Yeah, Enum is kind of a strange class. It can't decide what it wants to be.
12:09:59 <applicative> obviously the haskell Integer type is wrong, it includes signed numbers
12:10:52 <hseg> Right. It should be genericLength :: NonNegInteger i => [b] -> i
12:11:03 <dmwit> hseg: I think you should just use mconcat.
12:11:05 <ion> a.k.a. natural
12:11:12 <dmwit> :t mconcat . map (const (Sum 1))
12:11:13 <lambdabot> Num a1 => [a] -> Sum a1
12:11:20 <applicative> Natural n => [b] -> n
12:12:03 <dmwit> Oh, Monoid isn't quite right. It has 0 and +, but not 1.
12:12:05 <hseg> So in sum, we started with an optimized version, and creating an ideal version is hard?
12:12:07 <ion> @type foldMap (const (Sum 1))
12:12:08 <lambdabot> (Num a1, Foldable t) => t a -> Sum a1
12:12:54 <dmwit> PointedMonoid lol
12:13:54 <ion> Where? They usually don’t laugh.
12:14:28 <Fuuzetsu> Maybe you're just not as entertaining as you think you are.
12:14:47 <dmwit> Huh, there are only ten times as many occurrences of '[' as 'array' (case-insensitive) in my copy of Hackage. I would have expected something a bit higher.
12:15:24 <typoclass> dmwit: oh interesting. i agree that it sounds implausible
12:16:02 <dmwit> I guess a more realistic answer would require type inference... =P
12:16:39 <applicative> my grep doesn't doesnt do type inference for some reason
12:17:29 <applicative> it demands a signature
12:17:37 <Fuuzetsu> hue
12:18:25 <hseg> gpg --output grep.sig --sign grep
12:18:58 <dmwit> I don't know the "grep" sign... is that before or after Libra?
12:19:28 <Fuuzetsu> #haskell-badjokes
12:34:09 <dav> So I finally wrote my first haskell program :)
12:34:23 <typoclass> dav: oh, congratulations :-)
12:34:24 <dav> and it doesn't print out the fibonacci sequence or prime numbers..
12:34:43 <typoclass> dav: how can this be? are you sure you wrote it in haskell?
12:34:53 <lambdazerocool> dav: congratulations! do you mean that as in "it does something useful" or "it doesn't work?" :D
12:34:55 <dav> if anyone has it in their heart to have a look and tell me what I should have done differently: http://paste.debian.net/5665/
12:35:15 <ski> beaky : arrays aren't traditionally used for iteration. arrays are traditionally (commonly) iterated *over*  -- the linked list corresponds more to `for (int i = 0; i < n; i++)' or `for (A a : as)'
12:35:17 <dav> typoclass :)
12:35:33 <hseg> dav: congratulations! 【ツ】
12:36:03 <ski> dav : the `return 0' in `main' is ignored
12:36:29 <dav> lambdazerocool: it does what it's supposed to. the problem I'm trying to solve is as follows: to hard drives with large files are kept in sync, then one goes out of sync, some files get renamed: find the renamed files and rename them on the other drive so that they match.
12:36:42 <ski> @hoogle exitSuccess
12:36:43 <lambdabot> System.Exit ExitSuccess :: ExitCode
12:36:43 <lambdabot> System.Exit exitSuccess :: IO a
12:36:44 <ski> @hoogle exitFailure
12:36:44 <lambdabot> System.Exit ExitFailure :: Int -> ExitCode
12:36:44 <lambdabot> System.Exit exitFailure :: IO a
12:36:57 <dmwit> dav: (You might like "unison".)
12:37:03 <ski> (or just omit `return 0', for a successful exit)
12:37:06 <beaky> ah
12:37:08 <dav> where signature is defined as size - hask of first 4 kbytes
12:37:16 <dav> hash sorry
12:37:43 <dmwit> dav: http://www.cis.upenn.edu/~bcpierce/unison/
12:37:45 <dav> ski: ok I'll get rid of the return 0
12:38:06 <dav> dmwit: I'm familiar with it. Used to sync my home with it in like 1999 :)
12:38:12 <ski> and then you could as well say `main :: IO ()'
12:38:29 <ski> `From f : To t : []' could be `[From f,To t]
12:38:32 <lambdazerocool> dav: i'm glad you started with something small, then jumped into IRC to get some feedback xD. i'm starting with a large out-of-control project. but screwit.
12:38:33 <dmwit> dav: ok =)
12:41:08 <dav> dmwit: "If D is renamed to D' on the remote machine, and this change is propagated to the local machine, all such files or subdirectories P will be deleted. This is because Unison sees the rename as a delete and a separate create" (http://www.cis.upenn.edu/~bcpierce/unison/download/releases/stable/unison-manual.html)
12:41:21 <dav> dmwit: the files are rather large so I'd rather avoid recopying them.
12:41:48 <dav> dmwit: think 'movies' :)
12:42:03 <dmwit> dav: Hm. At least here it does all deletions last, and detects moves and uses copying as a shortcut.
12:42:31 <dmwit> The semantics is "delete and recreate", but the operations it uses to achieve that semantics is "copy and then delete".
12:42:58 <dav> dmwit: if I move a file to a totally different folder, it will recognize that?
12:43:04 <dmwit> I dunno. Let's test it!
12:43:08 <dmwit> computer science!
12:43:10 <dav> dmwit: btw, even hashing the entire file is an expensive operation
12:43:41 <dav> dmwit: my tool only hashes the first 4kb, which means it's not perfect, but it has a decent chance of success on movies..
12:43:55 <dmwit> dav: I see. Neat!
12:43:57 <Fuuzetsu> AHH THE NUMBERS
12:45:56 <typoclass> dav: random suggestion -- i usually don't bother with listing all the individual functions in import lines. i find it doesn't add any benefit. my rule of thumb is importing common stuff unqualified (roughly meaning "if it's from one of the packages shipped with ghc"), and doing "import qualified Lesser.Known.Module as LKM", i.e. i'll then have "foo x = LKM.function (x + 1)" to make clear to readers where 'function' came from
12:46:39 <typoclass> dav: the idea is of course that if i want to use LKM.otherFunction, i don't have to touch the import line again
12:46:51 <tdammers> typoclass: that's my general strategy too
12:46:59 <typoclass> urgh. foot in mouth. i think i explained that awkwardly
12:47:21 <dav> ski: thanks, I've incorporated your changes
12:47:26 <tdammers> sometimes I use more detailed imports though, when I import a module that provides the same functionality as Prelude, but more general or sth like that
12:47:31 <dav> typoclass: makes sense, I'll do that.
12:47:47 <dmwit> dav: Conclusion: yes, unison notices cross-directory moves.
12:47:52 <dmwit> http://hpaste.org/88367
12:48:33 <dav> dmwit: interesting
12:49:03 <dav> dmwit: but it would not work in my case, because the test file got read 3 times and written once
12:49:13 <byorgey> I think it just uses hashes of file contents to decide when to copy
12:49:18 <dav> dmwit: it must have hashed it twice to figure out that it was the same
12:49:32 <dav> dmwit: then it read it to copy it + wrote it
12:49:44 <dmwit> Well, I'm sure one of the hashes was stored from a previous run. But yes, I understand why your approach may be better in your case. =)
12:49:46 <dav> dmwit: on multi-Gb files, those are things one would rather avoid :)
12:50:04 <dmwit> Also, copy can be much faster than read+write.
12:50:17 <dmwit> ...depending on your file system.
12:50:22 <dav> fair
12:50:34 <dav> which filesystem is smart about cp?
12:51:03 <dav> ext2/3/4 aren't afaik
12:51:22 <dmwit> No, ext* aren't. ZFS and btrfs, I think
12:51:42 <dav> typoclass / ski - is the separation of IO and functional code adequate?
12:52:10 <dmwit> According to Wikipedia, GPFS, ext3cow, NILFS, Reiser4, Reliance, Reliance Nitro, ZFS, Btrfs
12:52:20 <dmwit> http://en.wikipedia.org/wiki/Comparison_of_file_systems#Features, the COW column
12:52:29 <dav> ah yes, copy-on-write
12:55:28 * typoclass . o O ( the name 'nitro' kinda negates the associations from the name 'reliance'. it's a bit like calling something the hello kitty killbombcannon )
12:55:54 <MHD> Is there a way, when defining a type of a constructor of a gadt,  to say it takes a value that will eventuall resolve to a, say, int? For example, if I have a gadt of called Foo, with a constructor Bar, which takes another Bar Int and returns a Bar Int, is there a way for me to pass Bar a nested Bar, with an in finally at the bottom, like Bar (Bar
12:55:54 <MHD> ( Bar 4)))?
12:56:11 * leifw goes to find someone to market a hello kitty killbombcannon
12:58:48 <dav> typoclass: so import qualified Data.Map as Map; import Data.Map (Map) if I want to avoid all the type signatures saying Map.Map ?
13:00:35 <typoclass> dav: yes! that's exactly what i do with Data.Map
13:02:28 <aristid> dav: i like to import it as M
13:02:33 <aristid> M.Map isn't so bad IMHO
13:03:36 <typoclass> oh god ... package filepath contains System.FilePath.Posix and .Windows, while package system-filepath contains Filepath.Path.CurrentOS and .Rules
13:03:56 <typoclass> excuse me, "Filesystem.Path..."
13:04:20 <dmwit> ?tell MHD How about something like data Foo a where Bar :: Foo Int -> Foo Int; Lit :: Int -> Bar Int? In fact, forget the GADT, how about type Foo = (Nat, Int) telling how many Bar constructors there are? ;-)
13:04:20 <lambdabot> Consider it noted.
13:04:45 <byorgey> typoclass: filepath is the package that comes in the Haskell Platform.  system-filepath is a more modern, typesafe reimplementation which unfortunately hasn't caught on yet (filepath has a lot of inertia).
13:04:57 <byorgey> they are not intended to be interoperable.
13:05:26 <typoclass> byorgey: right. the package-name-to-module-name mapping is however a bit counterintuitive :-)
13:05:39 <dav> typoclass: do you import qualified even if you only need 1 function from that lib?
13:05:41 <byorgey> ah, hehe, I see
13:06:00 <byorgey> 'Filesystem' is a rather odd top-level module name.
13:06:53 <byorgey> hehe, also, the system-filepath package is developed in a repository named haskell-filesystem =P
13:07:23 <byorgey> er, that's the homepage
13:10:48 <typoclass> dav: depends. i don't have a rigid scheme. i use whatever i feel will be most clear to a clueless human reader (i.e. "me in six months"). so if i'm working on a tool that inspects dbus, i'll choose to import DBus.* unqualified, since it's obvious a dbus-inspecting tool will use that kind of module. if i'm working on some other thing, say a lolcat picture viewer, that only incidentally uses dbus for one particular thing, i'll definitely 
13:10:57 <quchen> After listening a bit to the mailing lists and poking around, I've revised my Applicative => Monad proposal (39 times). Seeing that the mailing list wants to decide on another impactful issue (namely: "Foldable/Traversable for Prelude?"), I think it's a good time to discuss this. However, I like to ask on IRC first to prevent embarassing myself on the mailing lists ;-)
13:11:02 <quchen> https://gist.github.com/quchen/5501031
13:11:07 <quchen> (The new code for Base is sketched at the bottom in a seprate file)
13:11:11 <quchen> Patches, comments, constructive criticism, insultments welcome.
13:12:00 <Fuuzetsu> the Applicative => Monad is going to become a warning from GHC for time being from what I can read in ghc-devs
13:12:21 <Fuuzetsu> Not sure for how long though…
13:12:32 <quchen> Fuuzetsu: I just proposed that today on ghc-devs.
13:12:39 * ski annotated david's paste at <http://paste.debian.net/5665/> with <http://paste.debian.net/5835/>
13:12:42 <ski> dav ^
13:13:01 <quchen> Fuuzetsu:  SPJ just said "it's doable if the mailing list agrees it's good"
13:13:39 <typoclass> dav: it's largely a matter of "in foo x = weirdFunction blah", can the clueless reader guess what weirdFunction does, or at least where it comes from. in the dbus inspector project, i'll assume it's from the dbus-core package, no prefix needed. i add a prefix if i feel the poor guy will have to hoogle the name weirdFunction, or closely inspect the import list and take guesses, grep through the project, etc.
13:14:25 <c_wraith> quchen: I find the performance argument highly non-compelling. In order for it to actually work, you'd need a completely different mode of operation for Applicative instances than Monad instances, for things that support both.
13:14:34 <c_wraith> quchen: very few types will ever put that much work in
13:14:41 <dav> typoclass: doesn't listing the functions provide some useful context in that sense?
13:15:06 <ski> typoclass : cut off near ".. that only incidentally uses dbus for one particular thing, i'll definitely"
13:15:20 <typoclass> ski: "definitely import it qualified"
13:15:21 <quchen> c_wraith: Yeah, the performance argument *sucks* right now. Also it's not backed by evidence.
13:15:39 * typoclass 's irc-message-length-guessing skills are off by about 3 words
13:15:51 <quchen> c_wraith: However, it seems to be a real concern in Lens for example.
13:15:54 <dav> ski: looking
13:15:55 <typoclass> dav: yes, but it's also a lot of work :-) adding all the functions by name
13:16:16 <dav> typoclass: alright I think we've beaten that horse to death :)
13:16:19 <dav> typoclass: thanks
13:16:48 <c_wraith> quchen: Hmm.  Interesting to note.  But I'd say that as it stands, that section will invite more argument than any value it provides.  If you could through in the Lens concerns as a specific example, that'd help it a bunch.
13:16:59 <c_wraith> *throw in
13:17:05 <dmwit> quchen: FWIW, "We should remove warts from the language, even if it takes some work." is argument enough for me.
13:17:20 <quchen> dmwit: I believe that, but it won't be enough for a proposal.
13:17:41 <typoclass> dav: here is some suggestions, mostly superficial. but no guarantees :-) http://hpaste.org/diff/88366/88368
13:17:53 <typoclass> dav: i find it's really solid code overall. congratulations
13:18:07 <quchen> dmwit: Also, Haskell has this "devil's advocate" problem. We also need to convince the people that predict that everything will break, that beginners will have a hard time reading older books etc.
13:18:24 <quchen> dmwit: So I think we need some better arguments than It's The Right Thing™
13:18:41 <Fuuzetsu> We don't want to end up like C++.
13:19:01 <MercurialAlchemi> If "it's the right thing" was sufficient, everybody would be on Python 3 right now
13:19:21 <c_wraith> quchen: I'd push harder on the fact that it will let you use fmap (<$>) and <*> in code with only a Monad constraint. That's something that actually makes a practical difference when writing code.
13:19:28 <Fuuzetsu> Python3 is steadily advancing on Python2 though
13:19:44 <tdammers> they're both python though
13:19:46 <Fuuzetsu> I don't remember the last time I wanted to use a library that I had in 2 that I don't have in 3
13:20:11 <dav> typoclass: thanks a lot for reviewing, annotating, and complimenting :)
13:20:20 <c_wraith> quchen: people might say that writing code isn't the most important part, but as a matter of fact, it really does make it more pleasant to write some code.
13:20:20 <typoclass> dav: additionally, i notice you have some moderate duplication once: "e <- doesDirectoryExist p ; if e then ... else ...". try writing a helper function ifDirectory :: FilePath -> (FilePath -> IO a) -> (FilePath -> IO a) -> IO a
13:20:22 <tdammers> the better libraries work on both anyway
13:20:42 <MercurialAlchemi> Fuuzetsu: Python 3 was released in 2008, though
13:21:25 <Fuuzetsu> MercurialAlchemi: You're right but I don't think Haskell has nearly as many libraries that would actually have to be ported.
13:21:32 <c_wraith> quchen: those are my thoughts. By the way, I'm all for this.
13:21:36 <Fuuzetsu> Even if something breaks, the change is pretty much mechanical.
13:22:04 <quchen> c_wraith: Good to hear. I'm not sure how to write your suggestion above down though.
13:22:08 <tdammers> well, in any case, it's virtually impossible to accidentally use a library that doesn't work with your current ghc version
13:22:20 <quchen> c_wraith: Right now, all I can think about is "yipee you can sprinkle <$> in Monad code!" ;-)
13:22:25 <kennethmosquera> best way to create a tree?
13:22:32 <dav> typoclass/ski/all - btw in case anyone cares this is the python version of the same software: http://paste.debian.net/5666/
13:22:33 <quchen> kennethmosquera: Data.Tree? :-)
13:22:51 <MercurialAlchemi> tdammers: sure, but what you don't want to find out is that no library works with your GHC version :)
13:23:00 <c_wraith> quchen: Yeah, it's not very concrete of a suggestion. It's just the thing I would appreciate most about the change.
13:23:34 <tdammers> MercurialAlchemi: of course. But at least version mismatches are trivial to detect
13:23:47 <quchen> c_wraith: Well, thanks for the suggestion. I think I should change the "If it can be done, someone will do it" headline and incorporate your change in that section somehow.
13:23:58 <kennethmosquera> quchen: http://hpaste.org/88369 for this
13:25:17 <quchen> kennethmosquera: "I've got the following file, and I would like to read it in Haskell and store it as a tree." <- So that's the question then?
13:25:42 <MercurialAlchemi> tdammers: Yes. But the Python 3 problem is more "I can't use Python 3 because 15 of my dependencies are Python 2-only"
13:25:57 <kennethmosquera> quchen: yep
13:26:31 <tdammers> the python problem is also "I have no clue whether my code will work with python 3, because I have to run it through all possible execution paths to find out"
13:26:38 <johnw> guys, this really isn't #python
13:26:58 <MercurialAlchemi> tdammers: so you want to avoid that, either by minimizing the number of libs affected by the change, or by making it so that you can semi-automatically convert them, ideally also working with older versions
13:27:21 <MercurialAlchemi> johnw: Absolutely, but it's a relevant example in the context of introducing breaking changes
13:27:31 <joeyh> if I want to run 3 threads, and kill any of them if any of the others throw an exception, as well as if the calling thread dies, does this work? pinger `concurrently` sender `concurrently` receiver
13:27:54 <joeyh> getting a bit overloaded with the async documentation
13:28:19 <johnw> joeyh: it looks like that's right
13:28:40 <joeyh> if it does, it's more proof to me that async is beautiful
13:28:53 <johnw> if either A or B in A `concurrently` B throws and exception, then A+B `concurrently` C will receive the same exception, resulting in all three being cancelled and the exception propagating out
13:29:41 <joeyh> and concurrently is implemented in terms of withAsync, so if the caller dies, the exception should propigate in
13:29:45 <joeyh> that's the part I'm less sure of
13:30:22 <johnw> propagate "in"?
13:30:28 <ski> dav : you'll note i made various changes, you'll have to decide which of them you like
13:30:30 <joeyh> in to A B and C
13:30:35 <johnw> you mean, will the parent thread induce an exception within A or B?
13:30:43 <joeyh> right
13:30:44 <quchen> kennethmosquera: I don't know an easy solution. I would probably shoot Parsec at it. However, that sounds like I'm overcomplicating things a lot. Maybe someone else is smarter
13:30:51 <ParahSailin> what is the amount of memory printed in ghci when +s is set?
13:30:51 <johnw> I don't think that's how it works...
13:31:00 <johnw> let me read code
13:31:00 <ParahSailin> is that the total amount that the runtime has allocated?
13:31:11 <johnw> ah, it is
13:31:22 <johnw> cancel will be called within the child
13:31:49 <joeyh> "if the enclosing IO operation returns before it has completed" -- I think that's what that says, but the use of "enclosing" is a bit hard to follow
13:31:59 <dav> ski: yes, I'm still processing through all the feedback. thanks :)
13:32:05 <kennethmosquera> quchen: was thinking about something with read "Node "Blbla" [xxxxx,xxxx]"
13:32:15 <johnw> joeyh: sounds like grounds for a test!
13:32:30 <dmwit> quchen, kennethmosquera: Parsec (or another parsing library) sounds like the right thing to shoot at it to me.
13:32:36 <typoclass> dav: i'm not completely sure, but does any of this help? http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map-Lazy.html#g:10 i mean concerning computeMoves
13:33:05 <ski> dav : some commented-out stuff are alternatives
13:33:47 <quchen> dmwit: Oh. Well, I thought maybe there was some fancy way using ... zip or something.
13:34:04 <dmwit> There probably is. But why bother?
13:34:04 <kennethmosquera> dmwit: i know very little about parsing .. where could id learn
13:34:07 <quchen> dmwit: After finding out how Show for Tree is implemented, I'm careful talking about trees. :-)
13:34:09 <dmwit> It's so easy with parsing.
13:34:22 <ski> dav : btw, i haven't really thought might about what you're actually doing in the paste -- just doing local, more or less mechanical, refactorings into a form i like better
13:34:27 <quchen> dmwit: How would you track the current indentation level? User state?
13:34:29 <ski> s/might/much/
13:34:50 <dmwit> kennethmosquera: http://legacy.cs.uu.nl/daan/parsec.html
13:35:11 <dmwit> quchen: Just an argument to the parser, I'd say.
13:35:35 <dmwit> parse :: Int -> Parser (Forest String) or some such thing.
13:36:43 <dmwit> Let's see...
13:36:54 <quchen> dmwit: Oh, right, and when the parser fails one pops up a level. Sounds right.
13:37:00 * dmwit nods
13:37:01 <byorgey> parseTree n = replicateM n parseIndent >> (Node <$> string <*> many (parseTree (n+1)))
13:37:22 <byorgey> parseForest = many . parseTree
13:37:33 <quchen> dmwit: This was the first time in months that I thought imperatively. Conclusion: 1. it complicated things, 2. it was refreshing
13:37:39 <byorgey> something like that =)
13:37:57 <kennethmosquera> http://hpaste.org/88369
13:38:02 <typoclass> @remember quchen This was the first time in months that I thought imperatively. Conclusion: 1. it complicated things, 2. it was refreshing
13:38:03 <lambdabot> It is forever etched in my memory.
13:38:53 <dmwit> Yeah. There's probably fiddly stuff with newlines, needing to use "try", the usual nonsense.
13:39:05 <byorgey> indeed
13:39:24 <dav> typoclass: intersection might, union doesn't
13:39:36 <dav> typoclass: I'm struggling with your use of the <$> operator on a 2-tuple
13:40:01 <dav> typoclass: is (a, b) a functor somewhere? and why fould fmap f (a, b) = (a, f b) ?
13:40:10 <typoclass> dav: right :-) with <$> being an alias for fmap, that uses the Functor instance for 2-tuples
13:40:15 <dav> typoclass: it looks like it works, but seems rather obscure..
13:40:22 <dmwit> dav: Yep, that's the exact implementation of the Functor instance for (,) a.
13:40:29 <dav> dmwit: what's the rational?
13:40:36 <dmwit> "because why not?"
13:40:37 <typoclass> dav: i don't know why, it just is :-/ it applies the function on the right half of the tuple
13:40:38 * hackagebot penny-lib 0.14.0.0 - Extensible double-entry accounting system - library  http://hackage.haskell.org/package/penny-lib-0.14.0.0 (OmariNorman)
13:40:40 <dav> dmwit: why not apply to the fst ?
13:40:40 * hackagebot penny-bin 0.14.0.0 - Extensible double-entry accounting system - binary and documentation  http://hackage.haskell.org/package/penny-bin-0.14.0.0 (OmariNorman)
13:40:50 <dmwit> dav: Oh, that part has a half-way decent rationale.
13:40:59 <johnw> dav: a functor only maps over one type, and (a,b) contains two types
13:41:01 <dmwit> dav: You can only partially apply type constructors in argument order. =)
13:41:03 <typoclass> dav: it may have some reason based on mathematics. i'm not sure
13:41:07 <dmwit> dav: (To aid with type inference.)
13:41:19 <johnw> the pair (a,a) could be fmapped as (f a, f a)
13:41:42 <dav> johnw: yes, but why not fmap a b = (f a, b)
13:41:42 <dmwit> dav: So you can write (,) :: * -> * -> *, and you can write (,) a :: * -> *, but there's not really anything for flip (,) b :: * -> *.
13:41:51 <typoclass> johnw: right, but it could still be (f a, b). what dmwit said is the reason why that's excluded
13:41:52 <dav> johnw: (I think dmwit is explaining this)
13:41:53 <johnw> dav: you could write such an instance, it's not the default one
13:42:03 <dmwit> dav: (Short of making a brand new type with the argument order switched, of course.)
13:42:59 <dmwit> dav: So, there's a perfectly good functor whose fmap applies to the fst part of the tuple; it's just not a Functor because of technical limitations in Haskell's type system.
13:43:56 <dav> johnw: actually it looks like (a, a) still fmaps to (a, f a)
13:44:00 <Fuuzetsu> You could ask on the mailing list and then hope that Oleg replies with a magical solution
13:44:09 <johnw> dav: I said could, not is :)
13:44:25 <dav> johnw: ok :)
13:44:41 <johnw> but you could not have (f a, f b)
13:44:49 <johnw> that wouldn't type check
13:44:58 <dmwit> dav: You could imagine data Pair a = Pair a a; instance Functor Pair where fmap f (Pair x y) = Pair (f x) (f y)
13:45:18 <dav> dmwit: yes, yes, totally
13:45:30 <dmwit> dav: ...and you could imagine data BackwardsTuple b a = BT a b; instance Functor BackwardsTuple where fmap f (BT a b) = BT (f a) b
13:45:36 <dav> dmwit: I'm reading your explaination on why the default is the way it is, and I have to say it's beyond my abilities to comprehend :(
13:45:47 <dmwit> dav: Tell me the first thing you don't understand.
13:46:03 <ski> @quote refreshing.desert
13:46:03 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
13:46:26 <typoclass> dav: i think dmwit's message about BackwardsTuple sums it up
13:46:30 <dav> dmwit: "You can only partially apply type constructors in argument order." => what does that mean?
13:46:57 <dav> dmwit: how does one "apply" a type constructor?
13:47:14 <ski> `Maybe Int' is `Maybe' applied to `Int'
13:47:16 <dmwit> dav: Let's talk about data Pair a b = PCons a b for a moment.
13:47:27 <ski> `Either Int Bool' is `Either Int' applied to `Bool'
13:47:28 <dmwit> dav: (instead of tuples, because they have special syntax that just confuses things a bit)
13:47:33 <dav> ski: I see
13:47:37 <dmwit> ...but yes, what ski is saying =)
13:47:39 <typoclass> dav: it means for "Either a b", i can do "Either Int", fixing the 'a'. i can't do "Either ... String" to nail down the 'b' and leave 'a' for later
13:47:49 <ski> the type `(Int,Bool)' really means `(,) Int Bool'
13:47:53 <dav> alright i get this
13:48:02 <dav> now how it relates to <$> I'm not yet sure :)
13:48:09 <typoclass> (with "..." being some magical syntax that haskell doesn't have, as far as i know)
13:48:16 <dmwit> Anyway, you can think of "Pair" as being "\a b -> Pair a b"; you can think of "Pair a" as being "\b -> Pair a b"; but there's no analogue of "\a -> Pair a b".
13:48:41 <dav> dmwit: I got that last one
13:48:45 <dmwit> Great.
13:49:01 <dmwit> So now, we want to declare a Functor instance for some kind of Pairs.
13:49:20 <dmwit> Functor instances have to be type constructors -- they have to be able to take another type argument.
13:49:57 <dav> not clear on that
13:50:03 <dmwit> okay
13:50:10 <dav> is that true of every typeclass
13:50:12 <dmwit> Would you believe that types have a type system, too? =)
13:50:17 <dav> or just of the Functor ?
13:50:20 <dmwit> (no, it is not true of every type class)
13:50:30 <dmwit> (it is also not only true of Functor)
13:50:53 <dav> ok
13:51:12 <dmwit> dav: We can have a type system for types. To avoid confusion, let's pick another name, "kind".
13:51:15 <typoclass> dav: it means, you can (and do) have a Functor instance for Maybe, but you couldn't have a Functor instance for (say) Int. this is because Maybe has an argument. "Maybe" is not a complete type, only "Maybe String" is, or "Maybe Foo"
13:51:28 <dmwit> There's a special kind "*" which classifies concrete types like Int, Bool, Char, Either String (), etc.
13:51:37 <typoclass> dav: (we say that Maybe is of kind * -> *, while the type Int is of kind *)
13:51:41 <dmwit> Types that are classified by the kind "*" have values associated with them.
13:51:44 <dav> ha yes this all rings a bell now
13:51:59 <dmwit> Now, we can also have type constructors -- type-level terms that take arguments.
13:52:08 <dav> I think I get it all
13:52:11 <dav> I got unstuck
13:52:12 <dmwit> "Maybe" is a type-level term that takes a type and returns a type: it has kind "* -> *".
13:52:27 <dav> (Pair a) b is like List b
13:52:32 <dav> fmap applies to b
13:52:35 <dmwit> right
13:52:36 <dav> in both
13:52:42 <dmwit> That's it. =)
13:52:44 <dav> wait
13:52:51 <dav> what about Triple a b c :)
13:53:01 <dmwit> Then fmap only gets to apply to the "c" part. =)
13:53:13 <dmwit> Triple a b c is like (Triple a b) c
13:53:46 <shachaf> dmwit: OK, now how about Quadruple a b c d?
13:53:47 <dav> but that doesn't seem to work
13:53:54 <dav> let's see how do I invoke lambdabot?
13:53:54 <typoclass> dmwit: btw, i find it great how you're explaining this so patiently. kudos
13:54:05 <shachaf> You don't do this in lambdabot.
13:54:10 <dmwit> dav: Well, you can't define types and instances in lambdabot. So just say the code here.
13:54:16 <shachaf> lambdabot is pretty limited.
13:54:19 <dmwit> ...or on hpaste if it's long.
13:54:22 <dav> @eval fmap (+ 1) (1,2,3)
13:54:32 <typoclass> > reverse "lolcats" -- lambdabot interprets stuff that starts with "> "
13:54:33 <dmwit> > fmap (+1) (1,2,3)
13:54:34 <lambdabot>   "staclol"
13:54:35 <lambdabot>   No instance for (GHC.Base.Functor ((,,) t0 t1))
13:54:35 <lambdabot>    arising from a use of `e...
13:55:05 <dav> ok thx :)
13:55:13 <dmwit> ?help eval
13:55:13 <lambdabot> eval. Do nothing (perversely)
13:55:25 <byorgey> wat
13:55:28 <typoclass> fantastic
13:56:11 <typoclass> i swear, sometimes she is just mocking us. @info is another one of those un-commands
13:56:28 <dav> dwcook: so they just didn't define a functor instance for 3-tuples but if they did it would apply to the last one?
13:56:30 <dmwit> ?info do { v <- f; x }
13:56:30 <lambdabot> f >>= \ v -> x
13:56:35 <dav> s/dwcook/dmwit/
13:56:42 <dmwit> dav: right
13:56:50 <dav> dmwit: ok, makes sense
13:57:09 <dmwit> ?info [x | True]
13:57:09 <lambdabot> if True then [x] else []
13:57:27 <dmwit> typoclass: ?info is perfectly cromulent =P
13:57:43 <typoclass> dmwit: what, it autocorrects to @undo?
13:57:48 <dmwit> yes =)
13:57:49 <tom39291_> Does anybody know of a tutorial explaining the usefulness of Data.Tagged? (It's hard to google!)
13:57:57 <typoclass> @info Num
13:57:57 <lambdabot> Num
13:57:58 <dav> to close the topic, is it common to find uses of fmap on 2-tuples? if most people don't know about what we just discussed that makes the code a bit unreadable.. Or do most haskell programmers just know this stuff?
13:58:53 <icarot> While we're all in a cheery and communal mood, anyone want to explain conceptually infinite data, e.g., fib = 1:1:[a+b|(a,b)<-zip fib (tail fib)]
13:59:01 <byorgey> I think many Haskell programmers know about the Functor instance for tuples, but it is not actually very commonly used
13:59:08 <icarot> Because I think I lost brain cells trying to grasp it.
13:59:15 <byorgey> it just doesn't seem to come up very often.
13:59:25 <dav> icarot: you and me both..
13:59:31 <otters> > fmap (+1) (1,2)
13:59:33 <lambdabot>   (1,3)
13:59:36 <otters> yeah, nobody needs it
13:59:47 <shachaf> > over _2 (+1) (1,2)
13:59:49 <lambdabot>   (1,3)
13:59:50 <dmwit> tom39291_: Sometimes you want to write a value that depends on a type. To achieve this, one old trick was to make a type class like class FunVal a where FunVal :: a -> Int
13:59:52 <shachaf> > over _1 (+1) (1,2)
13:59:54 <lambdabot>   (2,2)
13:59:55 <shachaf> > over both (+1) (1,2)
13:59:57 <lambdabot>   (2,3)
14:00:01 <dmwit> tom39291_: err... funVal :: a -> Int
14:00:01 <dav> shachaf: that's cool!!
14:00:05 <byorgey> dav: in practice if you need to modify a tuple one would use 'first' or 'second', or perhaps lenses as shachaf demonstrates
14:00:08 <icarot> dav: It's okay, we can cry together.
14:00:15 <dmwit> tom39291_: Then you would write funVal (undefined :: Bool) to get the value associated with type Bool.
14:00:21 * icarot feels inadequate
14:00:30 <dmwit> tom39291_: This sucks, because you're using undefined and there's no guarantee that funVal doesn't actually inspect the value.
14:01:20 <_{^_^}__> following along in LYAH and this example {{ Just (+3) <*> Just 3  }} yields {{ Not in scope: `<*>' }} in ghci
14:01:23 <typoclass> dav: i do think things *may* get more unreadable as you use more abstract things. e.g. if i see "map", i immediately know there's a list going in and out of this. if i read "fmap", i'll have to look at the arguments, i'll have to do type inference in my head, or hope that someone wrote it down
14:01:26 <beaky> what are the different styles of programming in haskell?
14:01:48 <dmwit> tom39291_: One alternative is data Proxy s = Proxy; this lets you write class FunVal a where funVal :: Proxy a -> Int instead, which can be guaranteed doesn't inspect an actual 'a' value and for which there's an easy non-undefined value available.
14:02:01 <byorgey> beaky: crane, frog, tiger, rabbit, and edwardk
14:02:12 <dmwit> tom39291_: I assume Tagged sits in a similar niche (perhaps the same one).
14:02:16 <typoclass> byorgey: what food chain is this?
14:02:35 <shachaf> _{^_^}__: If you change your nick to something more alphanumeric I'll tell you where to find (<*>).
14:02:36 <byorgey> typoclass: beaky asked about the different styles of programming in Haskell
14:02:43 <dav> http://hackage.haskell.org/packages/archive/fgl/latest/doc/html/src/Data-Graph-Inductive-Query-Monad.html#mapSnd <= the stuff one finds on hackage
14:03:04 <_{^_^}__> shachaf: extortion much?
14:03:14 <sh> I think technically this is bribery.
14:03:39 <dmwit> icarot: How about starting with a simpler one?
14:03:44 <dmwit> icarot: Do you grok "ones = 1:ones"?
14:03:47 <typoclass> byorgey: sure, but is it "cranes are eaten by frogs, frogs are eaten by tigers, etc., everything is eaten by edwardk", or is it "cranes eat frogs, which eat tigers, etc., everything eats edwardk"
14:03:48 <shachaf> You are free to wait for someone else to answer your question (or to look at the top of that section in LYAH).
14:04:05 <byorgey> typoclass: they are in no particular order.
14:04:06 <_{^_^}__> sh: good point
14:05:47 <beaky> which style is the best?
14:05:51 <tom39291_> dmwit: Tagged and Proxy are in the same package, so indeed they are probably related. Thanks, that explanation helped. I'll have a play around and see if it becomes clearer.
14:05:56 <_{^_^}__> ah
14:05:59 <_{^_^}__> import Control.Applicative
14:06:01 <tom39291_> dmwit: http://hackage.haskell.org/package/tagged-0.4.4
14:06:07 <byorgey> beaky: I prefer rabbit
14:06:13 <_{^_^}__> shachaf: thnx for the hint
14:06:29 <Fuuzetsu> at least his name doesn't start with a backtick
14:06:32 <shachaf> I would appreciate it if you got an alphanumeric nick anyway.
14:06:36 <shachaf> But do as you will.
14:07:01 <beaky> ah what is the rabbit style?
14:07:01 <typoclass> dav: anyhoo. the Functor instance for 2-tuples is kinda on the edge. might use it, might not. nobody is going to eat you if you write code that could use it, but doesn't. i put it in to let you that it could alternatively be written like this, to spark the discussion you had with dmwit and just so you've seen it used once
14:07:18 * Kinnison also dislikes people whose nickname requires chording keys to get enough to tab complete.
14:07:33 <dav> typoclass: yes this is very enlightening :)
14:08:10 <dmwit> beaky: You use a standing desk, but hop at it instead of standing still. Good for your calves.
14:08:24 <dmwit> Then you practice calves style!
14:08:44 <dav> shachaf: so I'm looking for over and can't find it. Which module is it in?
14:09:11 <shachaf> Control.Lens. It's not in the standard library.
14:09:12 <typoclass> byorgey: i think him working out now on his new treadmill desk will change his role in the ecosystem. it will change what he preys on and can prey on, and change which others can prey on him
14:09:14 <dav> dmwit / typoclass / everyone - thanks a lot for taking the time to explain all this stuff.
14:09:38 <chuzz> i have a problem with ghc_mod with vim and syntastic, it keeps saying that it can't find Control.Monad.State
14:09:43 <dmwit> ?hackage lens has Control.Lens, by the way
14:09:43 <lambdabot> http://hackage.haskell.org/package/lens has Control.Lens, by the way
14:10:38 <typoclass> chuzz: when you do ":m + Control.Monad.State" in ghci, does it find it?
14:11:08 <typoclass> i'm kind of annoyed that the haskell code is more than 1.5x as long as the python code.  http://paste.debian.net/5835/ vs. http://paste.debian.net/5666/ one reason is having 3 large functions vs. the overhead of many smaller ones, but still
14:11:20 <chuzz> typoclass: yes
14:12:00 <dav> thanks
14:12:10 <typoclass> dav: you're welcome
14:15:42 <rolf246> Hi everyone; I am new to Haskell and just wrote my first programs. One thing I wrote is a solver for the 8 queens puzzle (pretty standard). I have 2 slightly different functions which solve the puzzle, but one of them is approx. 500 times slower than the other one. I am wondering how that can be? Is there a possibility to post some (short) code?
14:16:05 <Clint> @where hpaste
14:16:05 <lambdabot> http://hpaste.org/
14:16:12 <typoclass> rolf246: hello, yes there is, use hpaste.org. thanks
14:16:57 <rolf246> ok i will try that. thanks
14:22:09 <hvr> edwardk: btw, are you aware that this will go down in the haskell history books as the notorious burning-bridge poll/debate?
14:23:16 <Fuuzetsu> what debate is being talked about?
14:23:19 <quchen> hvr: Wait until we get started on Applicative/Monad
14:23:20 <johnw> we are voting to have bridges burned
14:23:23 <int-e> it's a good way of attracting pyromaniacs to the haskell language.
14:23:34 <hpc> hvr: remember, always transactionally destroy the bridge
14:23:41 <johnw> Fuuzetsu: making mapM, etc., more polymorphic in the Prelude by bringing in Foldable/Traversable
14:23:42 <hpc> so it is either completely gone or completely intact
14:23:46 <typoclass> johnw: i'm against it unless explosives are also involved
14:24:07 <Fuuzetsu> oh, so just the usual
14:24:22 <int-e> (unsafeBurnBridge is the new unsafeLaunchMissiles)
14:24:30 <Fuuzetsu> unsafeCorceBridge
14:24:57 <typoclass> http://www.scenicreflections.com/files/cat_and_aquarium_Wallpaper_l4fy0.jpg <- relevant for any discussion of bridges
14:25:14 <johnw> unsafeCoerceMailingList :: Bad Argument -> Good Argument
14:25:40 * hackagebot yamemo 0.3.0.1 - Simple memoisation function  http://hackage.haskell.org/package/yamemo-0.3.0.1 (NobuoYamashita)
14:25:57 <hpc> johnw: readMailingList# -- because only primitives use mailman anymore ;)
14:26:13 <johnw> haha, true!
14:29:39 <kennethmosquera> > drawTree (node "s" [])
14:29:40 <lambdabot>   Not in scope: `node'
14:29:40 <lambdabot>  Perhaps you meant `mode' (imported from Text.PrettyPr...
14:30:02 <kennethmosquera> drawTree (Node "s" [])
14:30:30 <kennethmosquera> >drawTree (node "s" [])
14:30:45 <kennethmosquera> > drawTree (Node "s" [])
14:30:46 <rolf246> Hi, have posted some code concerning the eight queens puzzle being very slow here: http://hpaste.org/88378 maybe someone would have a look?
14:30:49 <lambdabot>   "s\n"
14:30:56 <kennethmosquera> need more food
14:32:10 <byorgey> rolf246: is your question why queens is slower than queens' ?
14:32:16 <rolf246> yes
14:32:53 <typoclass> kennethmosquera: hello. lambdabot is also available if you do "/query lambdabot"
14:33:08 <kennethmosquera> ok
14:33:17 <rolf246> ...and extremely slower
14:34:50 <hvr> oh noes... we got a "+1000 for doing nothing" vote from malcom :-(
14:35:34 <byorgey> rolf246: hmm, that's subtle, I'm not sure
14:35:35 <quchen> It's only a matter of time until someone exceeds normalizations.
14:35:47 <byorgey> @undo [ x:l | l <- queens' (m - 1) n, x <- [1..n], not $ check (x:l) ]
14:35:47 <lambdabot> concatMap (\ l -> concatMap (\ x -> if not $ check (x : l) then [x : l] else []) [1 .. n]) queens' (m - 1) n
14:35:48 <quchen> You can't talk about percentages without someone saying 110 %.
14:35:59 <byorgey> @undo filter (not.check) $ concat [ map (x:) $ queens (m - 1) n | x <- [1..n] ]
14:36:00 <lambdabot> filter (not . check) $ concat concatMap (\ x -> [map (x :) $ queens (m - 1) n]) [1 .. n]
14:36:08 <typoclass> quchen: righto. 110% sure man
14:50:23 <rolf246> maybe there is a mailing-list where I can ask something about haskell being sometimes slow?
14:50:58 <neutrino> the haskell mailing list?
14:51:07 <dmwit> List comprehensions have special compiler support. They don't turn into concatMap calls.
14:51:24 <neutrino> really?
14:51:25 <typoclass> rolf246: i think you're looking for the haskell-cafe mailing list :)
14:51:29 <dmwit> really
14:51:48 <neutrino> i thought they were just syntactic sugar for do or something do desugars to.
14:51:57 <Finnfinn_> Say, the lambdabot is considered "female", so to say, if I recall correctly?
14:52:06 <dmwit> Now, I'm not 100% sure that's what's causing this issue.
14:53:40 <dmwit> rolf246: When compiling with optimizations, your two implementations both run instantaneously for me (0.00s according to "time").
14:54:10 <dmwit> rolf246: ...and it is well-known that even very slight refactorings can have dramatic affect on the non-optimized runtime.
14:55:03 <rolf246> oh that's interesting; i will try this.
14:55:43 <dmwit> Using queens 11 11 instead of queens 8 8 makes it take long enough for "time" to say something reasonable.
14:56:05 <dmwit> However, the times are still close -- 0.5 to 0.75s -- close enough that I'm guessing the "list comprehensions are not concatMap" really is the explanation.
14:56:06 <dav> rolf246: btw is this code correct? queens 4 4 => [[3,1,4,2],[2,4,1,3]]. the're all on the diagonal?
14:56:29 <c_wraith> Two numbers? Is the n-queens problem really defined for non-square boards?
14:56:41 <rolf246> i just ran runhaskell queens.hs to get my results
14:56:51 <c_wraith> runhaskell doesn't do any optimizations
14:56:53 <c_wraith> or even compile
14:57:02 <c_wraith> it just interprets it, which is the slowest option available
14:57:12 <beaky> is there a special name for a function that takes a function as an argument and applies that function?
14:57:27 <dmwit> ?src ($)
14:57:27 <lambdabot> f $ x = f x
14:57:40 <c_wraith> beaky: "higher-order"?
14:57:41 <beaky> so, the dollar sign function?
14:57:42 <dmwit> Functions which take other functions as arguments are called "higher-order functions".
14:57:44 <beaky> ah
14:57:54 <dav> eval :)
14:57:55 <typoclass> > map ($ 42) [pred, (*2) -- beaky, here's an example
14:57:57 <lambdabot>   <hint>:1:51: parse error (possibly incorrect indentation)
14:58:00 <dmwit> The specific higher-order function that applies a function is just called "id".
14:58:14 <typoclass> > map ($ 42) [pred, (*2)]
14:58:15 <lambdabot>   [41,84]
14:58:40 <Jookia> Is it possible for Cabal to generate Haddock documentation from a Test-Suite?
14:59:03 <typoclass> Jookia: hm, interesting question
14:59:08 <typoclass> dcoutts: ohai?
14:59:40 <rolf246> @dav [3,1,4,2] means queen in row 1 column 3, queen in row 2 column 1 queen in row 3 column 4 queen in row 4 column 2 a valid solution
14:59:40 <lambdabot> Maybe you meant: do faq map v
15:00:34 <Jookia> Hmm... Another question is, is it possible to add custom commands to cabal, specific to my project?
15:01:15 <dmwit> No, though it's possible to add custom commands to your Setup.hs.
15:01:29 <Jookia> My Setup.hs?
15:01:30 <dmwit> I don't really recommend it, though. Most people don't bother using Setup.hs any more, so it will be an uphill battle.
15:01:45 <dav> is this function defined somewhere in the Prelude? I can't find it on Hoogle.. => uniq (a:b:cs) = if a == b then r else a : r where r = uniq (b:cs) ; uniq cs = cs
15:01:58 <dmwit> :t nub
15:01:59 <lambdabot> Eq a => [a] -> [a]
15:02:04 <Jookia> Mmmm. Maybe I should avoid Cabal?
15:02:05 <dav> dmwit: that's not the same thing
15:02:16 <dav> dmwit: nub is O(n^2) and looks through the entire list
15:02:26 <dav> dmwit: this is O(n)
15:02:30 <dmwit> :t map head . group
15:02:31 <lambdabot> Eq b => [b] -> [b]
15:02:44 <dav> cool :)
15:03:20 <typoclass> Jookia: Setup.hs (or .lhs) is basically for when you want more detailed control than a *.cabal file. your Setup.hs is a program written in full haskell, which will "press" various "buttons" of cabal
15:04:07 <Jookia> Ah. I'm wondering if it'd be better to just use Makefiles.
15:05:00 <typoclass> Jookia: i would guess that that's not going to be an improvement
15:05:00 <c_wraith> make files are terrible for libraries you'd like to be part of the community. They're... sort of ok for building binaries you don't intend to put on hackage.
15:05:11 <lambdazerocool> I would like to transmit UTCTime across the network, but there isn't an instance of serialize. any suggestions? >.>
15:05:27 <lambdazerocool> sorry, instance Serialize of UTCTime, from Data.Serialize and Data.Time
15:05:53 <Jookia> Mmm. Well, treating a test suite as an executable fixes quite a few problems (coverage generation, haddock) but it also means I can't run 'cabal test' on it
15:09:09 <Guest9748> I'm having a build fail on RedHat EL 5 because there is no --build-id flag in ld.   ghc 7.4.1
15:09:34 <Jookia> This also means I can't make a 'cabal coverage' command that generates test coverage. :\ Are makefiles really that awful if they can do what I want?
15:11:00 <typoclass> lambdazerocool: you could convert the UTCTime to a String, using its Show instance
15:11:45 <lambdazerocool> typoclass: hm, this is an interesting fix ~
15:12:34 <lambdazerocool> typoclass: it will resort into my storing strings in records for serialization... but it's probably my best bet for now
15:13:41 <edwardk> hvr: hahahah!
15:13:41 <dav> lambdazerocool: yeah it doesn't sound like you've taken on something massive if this is your first haskell project :)
15:13:41 <dav> lambdazerocool: UTC times over the network?? :)
15:13:42 <lambdazerocool> dav: :) :)
15:13:42 <rolf246> thank you very much for the optimization tip; now other haskell functions of mine run awfully fast
15:14:44 <edwardk> typoclass: the treadmill desk is mostly just to make sure i can outrun anything in the ecosystem that could kill me before, and make it easier to run the other things to ground. ;)
15:15:06 <lambdazerocool> dav: it is a teeny tiny piece in a much bigger puzzle
15:15:27 * typoclass hides on the top bookshelf in an effort to evade edwardk
15:15:28 <typoclass> =)
15:15:38 <edwardk> typoclass: i'm tall. that isn
15:15:42 <edwardk> t a good defense ;)
15:16:20 <typoclass> edwardk: snore ... huh what? oh sorry, i fell asleep up here
15:17:34 <merijn> edwardk: Well, after the initial lack of response seems to have resulted in a really major support in favor of Foldable and Traversable in Prelude on the google poll and mailing list, so yay! \o/
15:17:34 <typoclass> lambdazerocool: Strings are probably the easiest. if you later want to dig in deep, UTCTime consists of two simple parts, a Day (= basically an Integer, days since "1 jan 1970") and a DiffTime (number of seconds since midnight; a Pico from Data.Fixed, which is an Integer + "." + 12 decimal places)
15:18:00 <typoclass> lambdazerocool: you could extract these two parts and store them away separately. it's really just two or three Integers
15:18:02 <dav> How come binaries generated by ghc are ginormous? Is everything always statically linked with ghc?
15:18:04 <edwardk> merijn: i think once people realized it might actually happen there was a fairly big outpouring of support
15:18:16 <edwardk> dav: static linking by default
15:18:20 <Jookia> is it possible to use HPC with cabal?
15:18:37 <hpc> Jookia: yes
15:18:40 <user123abc> dav, think that's bad?
15:18:41 <cmccann> edwardk: I choose to believe that it was because I joined the libraries@ list.
15:18:43 <typoclass> lambdazerocool: when i say "1 jan 1970", it's not actually that date, it's a weird thing in the 1800s that nobody can remember. but conceptually it's like the wellknown "1-1-1970"
15:18:48 <user123abc> guess who's learning haskell for a course in which he writes a compiler
15:18:53 <user123abc> <- this guy
15:18:53 <edwardk> cmccann: that helped too
15:18:57 <Jookia> hpc: Is there a tutorial somewhere? Nothing I've read works.
15:19:06 <ion> What google poll and which mailing list?
15:19:07 <edwardk> you also made a pretty good case for it
15:19:20 <edwardk> ion: the libraries@ mailing list for haskell
15:19:35 <edwardk> ion: and the poll is https://docs.google.com/forms/d/1lKckA0pA6K4uQ-UnnmjRR32PKHph0WeZoQeVTTQJZ4I/viewform
15:19:43 <ion> thanks
15:19:44 <hpc> Jookia: add it as part of the test suite
15:19:49 <hpc> Jookia: and run it with "cabal test"
15:19:51 <typoclass> user123abc: hehe :-) congratulations. and/or condolences
15:19:56 <lambdazerocool> typoclass: thanks!
15:19:57 <dav> user123abc: you write it in... C ?
15:20:03 <typoclass> user123abc: you've seen lyah, i presume?
15:20:05 <typoclass> @where lyah
15:20:05 <lambdabot> http://www.learnyouahaskell.com/
15:20:09 <cmccann> edwardk: a.k.a. adding my overwrought complaints to random threads
15:20:11 <user123abc> it compiles C (or a subset)
15:20:13 <typoclass> user123abc: ^^ good book available online
15:20:18 <Jookia> hpc: How do I add it to the test suite?
15:20:24 <dav> user123abc: you wrote a C compiler in haskell ?
15:20:32 <lambdazerocool> typoclass: i'm actually going to string up NominalDiffTime's. wheee!
15:20:44 <edwardk> currently we're pushing an 82% supermajority. If we can't get something through the libraries process with that kind of majority opinion, then I officially give up
15:20:47 <user123abc> typoclass, to be fair, I know SML, so a good amount of that was a bit slow for me
15:20:48 <hpc> Jookia: do i look like my name is "cabal"? ;)
15:21:08 <hpc> Jookia: it's part of the .cabal file; i don't remember the syntax
15:21:12 <lambdazerocool> typoclass: but the string trick is totally where it's at =D
15:21:12 <user123abc> dav, not quite yet - the course aims to write a compiler for a simple subset of C
15:21:24 <Jookia> hpc: I think I give up on Cabal at this point
15:21:33 <Taneb> I swear I'm on the libraries mailing list but I never get anything
15:21:45 <dav> user123abc: I wonder what subset of C is simpler than C :)
15:21:49 <merijn> Yes! Everyone vote on the inclusion of Foldable/Traversable in Prelude! Unless you disagree, then don't vote! >.<
15:22:03 <typoclass> user123abc: oh i see. how about rwh?
15:22:05 <typoclass> @where rwh
15:22:05 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:22:07 <cmccann> edwardk: I have to question that accuracy of the poll though
15:22:23 <pikhq> dav: C isn't actually *simple*.
15:22:24 <cmccann> since pissing you off only got 33% I mean really
15:22:27 <merijn> cmccann: The mailing list is showing a *strong* majority in favour too
15:22:28 <edwardk> cmccann: likewise, but it still cheered me up and made me laugh
15:22:29 <user123abc> typoclass, if you're recommending stuff, I'd be interested in problem sets
15:22:43 <user123abc> I'm looking at dartmouth's CS8 course now
15:22:47 <merijn> I voted in favour of pissing edwardk off too :>
15:23:00 <edwardk> I think even I voted in favor of pissing me off.
15:23:00 <pikhq> dav: It features little in the way of abstraction, sure, but that doesn't mean it's simple. :)
15:23:14 <typoclass> user123abc: hm yeah ... there's the 99 problems, which in my opinion could use a cleanup, but still
15:23:17 <typoclass> @google haskell 99 problems
15:23:19 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
15:23:19 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
15:23:24 <merijn> @where exercises
15:23:24 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
15:23:30 <P1RATEZ> LOL
15:23:37 <typoclass> merijn: ah good point
15:23:38 <P1RATEZ> haskell's got 99 problems but c isnt' one!
15:23:44 <user123abc> typoclass, ah, thanks
15:23:45 <cmccann> merijn: yes, I've been following the thread (if you hadn't noticed :P)
15:23:52 <merijn> I saw
15:23:59 <cmccann> edwardk: I figured you would
15:24:00 <typoclass> user123abc: you can thank merijn as well :-)
15:24:01 <hpc> haskell's got 99 problems and 45-80 is mostly empty
15:24:07 <user123abc> hpc, nice
15:25:08 <otters> oh boy
15:25:08 <Guest9748> Anyone know what turns on the --build-id flag to the linker in ghc, or how to turn it off? Thanks
15:25:14 <otters> debian is breaking something SERIOUS
15:25:42 <dav> pikhq: relatively few keywords to implement. Maybe I'm missing something but I think C would be one of the simpler languages to interpret or compile?
15:26:04 * edwardk is starting to really like this semi-indexing trick
15:26:15 <merijn> dav: Lots of annoying integer types and coercions to account for
15:26:15 <hpc> edwardk: semi-indexing?
15:26:17 <pikhq> dav: It's got a decent number of weirdo edge cases. :)
15:26:25 <typoclass> Jookia: hm, sad to hear it. there is shake by neil mitchell, a build system for haskell projects. it's not exactly aiming to replace cabal, but have a look http://neilmitchell.blogspot.de/2012/02/shake-better-make.html
15:26:44 * hpc braces for an hour of edwardk saying confusing things
15:26:44 <dav> I'll take your words for it :)
15:26:53 <edwardk> hpc: basically building a form of supplementary index that lets me make a 'random access' Data.Binary that you can deserialize only the parts of the data structure that you actually use.
15:27:03 <edwardk> hpc: same thing works for syntax trees, xml, json, etc.
15:27:04 <typoclass> Jookia: also, you should check back with your questions. dcoutts is in the channel fairly often and is always happy to help with cabal. he knows all the details
15:27:09 <merijn> Simple C inspired languages are easy, actually implementing C proper with all its edge cases is a pain
15:27:09 <typoclass> preflex: seen dcoutts
15:27:10 <preflex>  dcoutts was last seen on #haskell 3 days, 6 hours, 32 minutes and 1 second ago, saying: :i Int
15:27:23 <edwardk> hpc: the 'semi-index' is very very small though 3-10% of the size of the original file.
15:27:36 <hpc> snazzy
15:27:42 <edwardk> hpc: and in exchange for constructing it you only pay for the parts of the file you look at when deserializing
15:27:44 <Jookia> typoclass: Thanks for your help. I'll check back another time.
15:27:54 <edwardk> even if you do so lazily by building an ADT off it
15:28:06 <user123abc> I can't exactly think of "edge cases" in the syntax of C
15:28:17 <user123abc> merijn, what would be an example?
15:28:25 <monochrom> forget syntax. you will spend most time in semantics.
15:28:34 <edwardk> my current goal is to have a Data.Binary which you can deserialize parts of a tuple or data type as they are inspected
15:28:36 <pikhq> user123abc: int foo(int bar[static 4]) Have fun.
15:28:45 <user123abc> ok point taken
15:28:51 <hpc> user123abc: unspecified behavior is tricky, too
15:29:02 <hpc> user123abc: you can do whatever you want, but it has to be consistently that one thing
15:29:03 <user123abc> I have seen that, to be fair
15:29:12 <edwardk> hpc: http://www.di.unipi.it/~ottavian/files/semi_index_cikm.pdf sketches the basic idea using json
15:29:21 <user123abc> I'm sure that this is beyond the scope of the project, but I'm just curious about the general principle
15:29:47 <typoclass> pikhq: that's what you're expecting to be contained in a reasonable "simplified subset of c"?
15:29:51 <typoclass> pikhq: =P
15:30:02 <pikhq> typoclass: No, I'm giving that as an example of something that would be omitted.
15:30:27 <user123abc> a lot of the unspecified behavior that I can think of boils down to machine details and how it would interact with a compiler doing the most obvious thing
15:32:29 <merijn> user123abc: Also, details like struct { int foo : 5; int bar : 10; }
15:32:47 <lambdazerocool> seriously, something has an instance of show, but not read. are you. for real.
15:33:14 <lambdazerocool> i mean, for some things this makes sense. here, it just doesn't. =D
15:33:16 <typoclass> lambdazerocool: urgh. that's not great
15:33:43 <lambdazerocool> typoclass: yeah. it's NominalDiffTime! It's not hard to read. it's like blabla.blablalbas
15:33:46 <lambdazerocool> where the s is for seconds
15:33:47 <hpc> lambdazerocool: i do that for personal projects sometimes
15:33:56 <monochrom> UTCTime has Read. I use it all the time.
15:34:03 <hpc> oh, that's evil
15:34:22 <typoclass> lambdazerocool: oh, you may need to import another module. possibly even Data.Time.Format or whatnot
15:34:26 <hpc> monochrom: i get the impression that UTCTime is the canonical time type for almost all code
15:34:56 <lambdazerocool> hpc: i see. this makes sense. also, for certain applications, you don't write out an entire record in its "tostring" or "show" or whatever
15:35:07 <lambdazerocool> hpc: so i can definitely understand it not being a rule that instance Show => instance Read
15:35:15 <typoclass> hpc: probably. iirc the Zoned thing is a record with one UTCTime in it and a thing that indicates the timezone
15:35:37 <hpc> lambdazerocool: mostly i set a personal rule to avoid using read in real code
15:35:49 <typoclass> lambdazerocool: by the way, if you're doing anything at all with Data.Time, check http://pleac.sourceforge.net/pleac_haskell/datesandtimes.html
15:35:50 <hpc> lambdazerocool: and the easiest way to do that is to force myself to not write an instance
15:36:55 <hpc> usually Show only wiggles in for Debug.Trace
15:39:21 <Fuuzetsu> I'm so disappointed that Google still doesn't give me Haskell's Haddock-related page when I Google for ‘Haddock’…
15:39:35 <lambdazerocool> hpc: interesting. i'm trying to think of when i would use read in real code... beyond reading from file xD
15:39:45 <lambdazerocool> hpc: and of course user input at the keyboard
15:40:06 <lambdazerocool> hpc: right now i'm taking heavy advantage of GHC's generics for serialization, which is all in all wonderful
15:40:12 <typoclass> Fuuzetsu: i know, right! i didn't even know it was a fish or whatever. i just googled 'haddock' and stared at the search results confusedly
15:41:34 <monochrom> they chose "haddock" for pun with haskell, doc, and British fish and chips
15:42:14 <typoclass> cod and chips, mate, cheers!
15:43:34 <monochrom> when you one day want to invent a doc format and system for Coq, consider Cod. it rhymes with Coq, it is doc reversed, and it is Coq's mirror image or rotation along a horizontal axis.
15:44:12 <monochrom> and it is also British fish and chips, the cheaper kind
15:44:16 <sclv> coqdoc
15:45:27 <lambdazerocool> monochrom: you have put far too much thought into this
15:45:43 <monochrom> no, it only took 1-2 minutes
15:45:50 <johnw> coqbloc
15:45:53 <lambdazerocool> monochrom: like i said.
15:46:03 <quchen> British fish n chips? Where is that in Haddock?
15:46:11 <monochrom> 90% of that was just typing
15:46:20 <typoclass> monochrom: i like your ideas a lot =)
15:46:44 <Fuuzetsu> Programmer's have the worst naming sense.
15:46:48 <Fuuzetsu> Programmers*
15:46:52 <quchen> Waaaaait. You weren't joking when you said fish
15:46:54 <quchen> Oh my.
15:49:37 <typoclass> quchen: let me guess, you googled 'haddock' and asked what's all this? same happened to me some years ago
15:49:51 <eikke> quchen: applicative_monad.md results in 404
15:50:07 <Fuuzetsu> We should take it up with Google.
15:50:17 <monochrom> I am just glad I had fish and chips at several places before I learned haskell
15:50:18 <eikke> quchen: basically, github.com/quchen gives 404
15:50:21 <Fuuzetsu> Clearly majority of us find this an inconvenience
15:50:27 <typoclass> quchen: please peruse http://spl.smugmug.com/Humor/Lambdacats/i-J7smZk3/0/O/haddock.jpg
15:51:00 <monochrom> haha
15:51:05 <typoclass> eikke: apparently github is having some problem this evening
15:51:15 <eikke> ah, right
15:51:16 <user123abc> names should involve fewer puns and more acronyms
15:51:18 <user123abc> you hipsters
15:51:29 <quchen> eikke: That's very odd, it works for me. But my Gist page doesn't work.
15:51:41 <quchen> eikke: I posted it to a Git repo because that *did* work.
15:51:58 <quchen> eikke: Now that doens't work. Hm. I'll just upload the file to HPaste.
15:51:58 <blaenk> what's the best way to exit a program?
15:51:59 <cmccann> Fuuzetsu: btw, http://www.haskell.org/haddock/ is the second google result I get for "haddock"
15:52:07 <blaenk> if something bad has happened, use error?
15:52:20 <eikke> cmccann: search bubble?
15:52:44 <Fuuzetsu> it's like 8th for me
15:52:48 <quchen> eikke: http://hpaste.org/88382 (Long lines warning, use manual line breaks in your editor)
15:52:57 <quchen> (Or view it as markdown)
15:52:59 <Fuuzetsu> and oh god the LambdaCats
15:53:02 <cmccann> Fuuzetsu: clearly you don't let google stalk you enough.
15:53:04 <Fuuzetsu> my evening is set
15:53:16 <Fuuzetsu> cmccann: I'm signed in and everything!
15:53:51 <typoclass> Fuuzetsu: yes, sean has very nicely collected them :-) you need to know the lambdacats. i don't know how you could function inside the haskell culture otherwise
15:53:56 <cmccann> Fuuzetsu: do you use gmail?
15:54:04 <eikke> quchen: reading :)
15:54:12 <cmccann> years of getting piles of -cafe emails might be helping.
15:54:48 <eikke> quchen: I always wonder why it's only Applicative => Monad, and no Pure or Functor in the game
15:55:04 <quchen> eikke: Because we already have Functor => Applicative.
15:55:15 <quchen> Truth be told: Also AMP sounds cool.
15:55:32 <eikke> but no Functor => Pure => Applicative
15:55:42 <ion> It would also be fine to get join into Monad.
15:55:55 <quchen> ion: That's part of the proposal
15:56:13 <ion> s/fine/nice/, weird typo. I was just reading something about Double Fine. :-)
15:56:22 <Fuuzetsu> cmccann: I have a gmail account but I'm signed in with my university address (through YouTube I believe)
15:56:31 <merijn> typoclass: Did you say...lambdacats.org? :p
15:56:46 <Fuuzetsu> typoclass: I have only seen olegcat before and I couldn't find any more
15:56:51 <Fuuzetsu> The day has come though.
15:57:02 <typoclass> merijn: awww :-) it redirects now. excellent :-) thanks
15:57:09 <merijn> (Also, someone make me some nice software for uploading/voting on pics and I'll get it running on lambdacats.org for you)
15:57:22 <merijn> typoclass: That has redirected for over a year and a half now
15:57:34 <merijn> (I know, 'cause I'm the one that bought it :p)
15:57:41 <tgeeky> merijn: hot-or-not, but for lambdacats?
15:57:58 <merijn> tgeeky: Or just reddit, but for lambdacats, whatever :p
15:58:00 <ion> quchen: The link in http://www.haskell.org/pipermail/libraries/2013-May/019985.html 404s for me.
15:58:21 <Fuuzetsu> I wish it didn't require JavaScript to view a bunch of pictures…
15:58:35 <elliott> eikke: Pointed doesn't have any non-free theorem laws
15:58:40 <quchen> ion: Yeah, Github seems to have problems. I posted a HPaste of the .md file above
15:58:46 <cmccann> yeah Pointed isn't cool anymore.
15:59:00 <merijn> Fuuzetsu: See previous remark of "provide software and I'll fix it" :p I haven't gotten around to writing something simple myself yet...
15:59:06 <eikke> ok...
15:59:18 <tgeeky> every time someone reminds me that I *should* be running NoScript etc., I wonder what kind of horrible htt-erpies my poor browser gets because of my laziness.
15:59:27 <cmccann> elliott: btw I haven't seen you voting on libraries@ yet
15:59:28 <typoclass> merijn: oh! i must be mistaken then. i just recall being on some webpage that looked like it'd show me cat pictures with haskell-related captions, but actually was a green "exit sign" thing and didn't redirect to smugmug.com
16:00:27 <ion> quchen: Typo: requres
16:02:07 <singpoly1a> is readIORef threadsafe, as long as I don't use it to modify the IORef?
16:02:23 <merijn> singpoly1a: reading an IORef is atomic, yes
16:02:37 <merijn> So is writing, for that matter
16:02:41 <cmccann> singpoly1a: you're asking whether individual reads and writes are atomic?
16:02:51 <eikke> are empty and (<|>) in Alternative in any way different from mempty and mappend in Monoid?
16:03:05 <cmccann> eikke: different kinds
16:03:10 <cmccann> and different instances.
16:03:25 <cmccann> but Alternative does define a lowercase-m monoid
16:03:30 <singpoly1a> cmccann: yes
16:03:35 <singpoly1a> merijn: cool
16:03:54 <eikke> right. I need sleep :)
16:05:46 <lambdazerocool> here's a silly question - is there an easy way to go from NominalDiffTime to a float or a double? this is one place where i miss C. "it's just bits, darnit."
16:06:13 <typoclass> lambdazerocool: realToFrac or some such. one of the general-purpose converter functions :-)
16:06:28 <monochrom> realToFrac. because NomimalDiffTime is a Real instance
16:06:29 <lambdazerocool> typoclass: why thanks! :D
16:06:39 <johnw> it's just numbers, darnit
16:06:49 <lambdazerocool> johnw: :D
16:06:56 <monochrom> use ":info NominalDiffTime" to see more instances
16:06:57 <typoclass> lambdazerocool: you're welcome. have you seen the pleac link above? it's very useful
16:07:59 <lambdazerocool> typoclass: indeed i have, thanks!
16:12:53 <Fuuzetsu> http://spl.smugmug.com/Humor/Lambdacats/i-6djpLdS/0/L/simon-L.jpg heh, every time someone posts on GHC mailing lists
16:13:47 <typoclass> Fuuzetsu: one of my favorite lambdacats :-) the cup is clearly irreversibly damaged, yet kitty says "is fixed in the head"
16:15:56 <lambdazerocool> as a rookie, this joke is lost on me
16:16:43 <hpc> lambdazerocool: give it a year or two
16:16:50 <frankbro> Does anyone have a link to this cool page I saw once explaining how monads, applicative and functors work with images of boxes
16:17:09 <tgeeky> lambdazerocool: it's ok. As a lover of dogs, and a ambivolence toward cats, all of them are lost on me.
16:17:55 <blaenk> frankbro: have you tried googling it, that's literally the name of the article haha
16:17:59 <tgeeky> ws/a/having only/
16:18:08 <frankbro> blaenk, I did, with no result
16:18:13 <blaenk> aight I'll bring it up
16:18:24 <typoclass> lambdazerocool: allow me to explain (jokes usually get better after long explanations). HEAD means the current state, the newest state of a source repository. for example the git repository that contains the source code of ghc (= haskell compiler). the two simons are important developers on the compiler (simon marlow and spj, simon peyton jones)
16:18:26 <josephle> frankbro: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
16:18:30 <blaenk> frankbro: s/images/pictures
16:18:31 <blaenk> http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
16:18:41 <josephle> next time just try finding it on the haskell reddit
16:18:42 <frankbro> awww perfect thanks <3
16:18:47 <blaenk> np
16:18:53 <frankbro> all I found was http://newartisans.com/2012/08/monads-in-pictures/ .. p. cool too
16:18:56 <frankbro> to explain easily
16:19:29 <josephle> that site also has an interesting article on STM and actors
16:19:50 <blaenk> explains actors with ruby iirc
16:21:50 <slack1256> blaenk: you mean this? http://adit.io/posts/2013-05-15-Locks,-Actors,-And-STM-In-Pictures.html
16:22:09 <blaenk> slack1256: yeah, though I wasn't looking for it :)
16:23:06 <Fuuzetsu> is monads with pictures the pictorial equivalent to monads as burritos?
16:23:15 <slack1256> oh. note to self. I need to read the context before replying.
16:23:25 <slack1256> burritos in spacesuits to be exact
16:24:02 <josephle> was the burrito radioactive, or was that space itself?
16:24:06 <shachaf> Can we make a bot that autobans anyone who says the word "burrito" in this channel?
16:24:11 <shachaf> It would be a much better channel.
16:24:27 <shachaf> I don't mind being banned by the bot for suggesting it, once it's up.
16:24:43 <slack1256> yeah, that would be a signal of channel saturation (start banning by little details)
16:24:55 <slack1256> iirc it's on freenode recomendations not to do that
16:25:23 <koala_man> haha
16:25:37 <Fuuzetsu> I still have to read that infamous guide
16:25:38 <typoclass> shachaf: i looked at the haddock for TMVar, read "it can be thought of as a box that can be empty or full" and cringed. "oh god not the box analogies again"
16:26:21 <cmccann> Fuuzetsu: there is no burritos analogy guide. it came from something criticizing the dumb analogies.
16:26:40 <merijn> typoclass: Except that (T)MVar actually *does* behave like a box...
16:27:00 <Fuuzetsu> really?
16:27:02 <blackdog> a monad is like a thing that has a bind operation and a return operation. almost uncannily like it, really.
16:27:06 <lambdazerocool> typoclass: yeah. it's not suitable for monads. but for MVar is's pretty good. xD
16:27:07 <Fuuzetsu> That's kind of disappointing.
16:27:12 <typoclass> yes, it is called "the monad tutorial fallacy" and criticizes the tutorials that explain monads in terms of space suits and whatnot
16:27:17 <typoclass> (iirc)
16:27:31 <cmccann> yes, it was written by byorgey I think
16:27:33 <Fuuzetsu> Pretty sure LYAH uses a chest example or something
16:27:33 <lambdazerocool> typoclass: it's like the "water" analogy with circuits - it's good for like, two circuits, then things break down instantly.
16:27:40 <cmccann> which he probably regrets by now
16:27:41 <Fuuzetsu> that's how I initially learnt it
16:27:46 <typoclass> merijn: yes, it's not too bad overall. i just initially got the impulse to cringe for a moment
16:27:57 <merijn> Fuuzetsu: The best Monad tutorial (and the only one worth reading) remains "You Could Have Invented Monads (And Maybe You Already Have!)"
16:28:20 <cmccann> lambdazerocool: the hydraulic analogy actually gets you pretty far as long as you don't worry overmuch about the implementation details of physical systems
16:28:29 <Fuuzetsu> I'll look it up I guess, out of curiosity
16:28:47 <merijn> Fuuzetsu: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
16:28:49 <cmccann> more importantly, the intuition built from the hydraulic analogy mostly points you in the right direction-ish
16:29:01 <cmccann> whereas dumb monad analogies don't lead anywhere helpful
16:29:10 <merijn> Fuuzetsu: For best effect, make sure you grok typeclasses and type signatures before reading
16:29:37 <typoclass> Fuuzetsu: it makes a valid point http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
16:30:13 <slack1256> merijn: exactly, also working the definitions by hand is super helpful (once you understand the definitions)
16:30:17 <josephle> I wonder if people eventually realize monads are just algebraic structures with 2 operations and then call it a day
16:30:35 <lambdazerocool> cmccann: it is largely possible that you only got as far with circuits as hydraulics take you, as you get while boxes are useful monad analogies =D
16:30:58 <lambdazerocool> cmccann: TBH i actually thought the "boxes" were alright for a while, then i started thinking of "contexts", and that's about where i'm at
16:31:28 <merijn> josephle: You'd be amazed how hard that conclusion is to reach for some...
16:31:45 <lambdazerocool> cmccann: also i am joking, it looks like i'm being a douche
16:32:14 <lambdazerocool> josephle: you assume people know what that even means
16:32:21 <Eduard_Munteanu> @quote monad.*endofunctors
16:32:21 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
16:32:26 <cmccann> lambdazerocool: I switched from EE to CS halfway through my undergrad degree so I'll take your word about circuits :P
16:32:45 <enigmuriatic> i don't totally understand why you aren't supposed to use type constraints in data declarations. isn't that circumventing Haskell's type safety?
16:32:48 <lambdazerocool> cmccann: i was venturing into EE and was like "eff this im outa here" =D
16:33:10 <eikke> enigmuriatic: it's not really useful
16:33:19 <josephle> Eduard_Munteanu: after taking a class in category theory, all I've realized is how unhelpful that quote is
16:33:30 <josephle> 100% true, 100% nondescriptive
16:33:31 <enigmuriatic> eikke, but doesn't it prevent you from passing an invalid type?
16:33:35 <Eduard_Munteanu> enigmuriatic: type functions are supposed to work for any type
16:33:36 <cmccann> lambdazerocool: anyway, physical sciences and engineering are full of analogy-like simplifications used (ideally) because they're good approximations at some level and aren't actively misleading as deeper understanding is gained
16:33:42 <eikke> enigmuriatic: functions over data define constraints the data should obey to (obviously), datastructures don't constrain something
16:33:47 <eikke> enigmuriatic: like what?
16:33:59 <enigmuriatic> like the key of a map
16:34:19 <eikke> what about it?
16:34:30 <cmccann> :t Data.Map.lookup
16:34:32 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
16:35:04 <enigmuriatic> keys are supposed to be ordered, so why don't you constrain the type in the data declaration?
16:35:16 <enigmuriatic> or is Learn You a Haskell lying to me?
16:35:21 <eikke> enigmuriatic: because keys should only be ordered when some operation on those keys requires ordering
16:35:24 <merijn> enigmuriatic: Because the function needs to know how to use the ordering
16:35:45 <typoclass> josephle: my own explanation is that Monad is a typeclass, it contains 3-4 functions, it has various instances (2-3 of them very popular), several functions in the standard library consume a monad or give back a monad. there's a bit of syntax that translates do blocks into calls to the typeclass's functions. and that's about it. next steps: reading signatures of those 3-4 functions, reading implementations of instances, and looking at t
16:35:47 <merijn> enigmuriatic: Which means that if you want to use the ordering you need the constraint on the function anyway, rendering the one on the data redundant
16:35:54 <eikke> enigmuriatic: say there's no Ord instance for some type T, why can't I create a value like "Map.empty :: Map T Int" ?
16:36:09 <cmccann> also, constraints on data types never did what most people expected.
16:36:17 <cmccann> and never anything useful, either.
16:36:17 <typoclass> josephle: and as far as i know the "is just an endofunctor" quote was written as a joke
16:36:46 <merijn> typoclass, josephle: It was. A bad joke. That confuses many newbies for no good reason and should die
16:36:47 <cmccann> typoclass: the "just a monoid in blah blah what's the problem" quote?
16:36:49 <typoclass> josephle: that's the source as far as i can tell. it's a very funny article http://james-iry.blogspot.de/2009/05/brief-incomplete-and-mostly-wrong.html
16:36:58 <cmccann> yeah, that is the source of the joke.
16:37:02 <josephle> typoclass: it's a joke, but it's sadly a correct definition of monads as understood by category theory.
16:37:04 <eikke> enigmuriatic: Map.null (Map.empty :: Map t Int) is perfectly OK code using Map functions which doesnt rely on keys being orderable
16:37:06 <typoclass> cmccann: yes
16:37:14 <cmccann> the quotation is a slightly mangled one from Categories for the Working Mathematician I think.
16:37:15 <Peaker> It is possible to pure the Ord constraint inside the data declaration, e.g: via GADT (or iirc there's a specific extension for that).. Then you'd have Ord constraint on functions that build a Map but Map will carry around the Ord constraint in it
16:37:41 <merijn> I <3 GADTs so much...
16:37:48 <merijn> I wish I could marry them...
16:37:50 <lambdazerocool> so, after i do a project or two in haskell, the next thing on my tour is probably common lisp. i'm wondering if it will feel as good as bending my brain into haskell feels >.>
16:38:04 <typoclass> josephle: right, it may be a correct definition, but you said it before. it's only helpful if you know all of it beforehand
16:38:13 <eikke> enigmuriatic: makes sense?
16:38:22 <hpc> lambdazerocool: the heavy syntax for lambdas will be painful
16:38:22 <enigmuriatic> i think so, yeah
16:38:39 <hpc> as will the complete lack of pattern matching
16:38:44 <typoclass> lambdazerocool: omg no type system?
16:38:46 <typoclass> ;-)
16:38:52 <josephle> typoclass: yep. But I have to say that understanding monads as typeclasses is almost equivalent to understanding them as algebraic structures
16:39:00 <Peaker> lambdazerocool, The main cool thing about Lisp is that the code is in an easy-to-manipulate syntactic formation...  IMO that's overrated but then again I'm a Haskeller :)
16:39:14 <eikke> enigmuriatic: basically, just like functions, you want datatypes to be as generic as possible. and as cmccann said, constraints on datatypes might not work the way you think they do anyway :)
16:39:30 <enigmuriatic> is common lisp still what's commonly suggested to be learned? things like Clojure seem way more attractive and useable
16:39:41 <enigmuriatic> the dialect that's commonly suggested, i should have said
16:39:51 <Peaker> I presume Clojure is a Lisp-1?
16:40:01 <josephle> lambdazerocool: in risking the wrath of some of the more avid functional programmers, I'd suggest smalltalk as a language that blows your mind
16:40:07 <merijn> I tend to recommend Clojure or Racket, depending on peoples goals
16:40:29 <lambdazerocool> I also want to do Common LISP for vintage points. =D
16:40:40 <josephle> although I guess smalltalk has even less practical value these days than haskell or lisp :/
16:40:41 <merijn> Racket because it attracts many PLT people (and has types!), Clojure because of JVM support and actual companies paying people to write it :p
16:40:52 <lambdazerocool> josephle: yeah, and we're kind of limited already >.>
16:40:55 <merijn> josephle: Sell it as "Objective-C practice"
16:40:56 <cmccann> smalltalk is a good language if you want to learn how to complain about other so-called OO languages more effectively.
16:41:13 <cmccann> clojure has STM, btw. that's pretty nice.
16:41:58 <enigmuriatic> merijn, PLT?
16:42:11 <josephle> cmccann: "Java isn't a Purely OO programming language!"
16:42:32 <merijn> enigmuriatic: Programming Language Technology, common acronym for referring to anything related to programming language research
16:42:45 <merijn> enigmuriatic: or Theory instead of Technology
16:42:49 <merijn> Depending on who you ask
16:42:54 <abstracted> So I was trying to figure out, exactly how possible or impossible is writing android apps in haskell right now?
16:43:09 <shachaf> If you ask the right people they would say "Theory".
16:43:10 <enigmuriatic> i think i'm doing Racket within the next two years in school
16:43:18 <josephle> I still find it kinda cool that smalltalk is just another take on the ideas of lisp, ah well
16:43:19 <cmccann> merijn: Pointless Letter Triad
16:43:29 <typoclass> merijn: well and clojure has (afaik?) top-notch concurrent data structures, and rich hickey is a dedicated guy who is clever and has experience
16:43:49 <enigmuriatic> abstracted, could you possibly use Clojure or Scala with some kind of Android module? that's what i'd Google, anyway
16:44:01 <merijn> Racket if you wanna be experimental, Clojure if you wanna be paid
16:44:31 * monochrom prefers Theonology
16:44:49 <abstracted> enigmuriatic: clojure is i think possible but usually discounted because the runtime is heavy (i think), lots of people use scala, it can be made to work.
16:44:54 <merijn> For more accuracy Programming Language Theology
16:45:17 <hpc> PROGRAMMING LANGUAGE THUNDERDOME!
16:45:22 <hpc> ONLY ON GITHUB GITHUB GITHUB!
16:45:28 <cmccann> hpc: yes good
16:45:29 <monochrom> what is thunderdome?
16:45:50 <typoclass> monochrom: i presume it's something american. i'd guess it'll be food?
16:46:15 <hpc> https://en.wikipedia.org/wiki/Mad_Max
16:46:27 <hpc> you guys are painful sometimes ;)
16:46:29 <enigmuriatic> the guy that wrote Clojure seems brilliant too
16:46:46 <enigmuriatic> there are a bunch of good interviews and talks with him that I have on my "read later" list
16:46:59 <enigmuriatic> i've picked through some and he seems like a far-out, thoughtful dude
16:47:23 <abstracted> clojure is interesting.  i hate the jvm.
16:47:53 <Peaker> enigmuriatic, why untyped? :(
16:48:04 <enigmuriatic> Peaker, huh?
16:48:09 <josephle> abstracted: all we need is a VM for haskell. Then our cross-platform power shall over take the JVM!
16:48:20 <enigmuriatic> is Clojure untyped? i've never touched a single line of it, lol
16:48:27 <Peaker> enigmuriatic, why do brilliant people make untyped languages?
16:48:52 <enigmuriatic> Peaker, that does indeed sound like an awful idea
16:49:07 <abstracted> no, no vm
16:49:14 <lambdazerocool> enigmuriatic: it's derived from LISP. in LISP, there is very, very minimal typing.
16:49:16 <josephle> Peaker: OO lends itself really nicely to untyped languages, but at great cost to the programmer
16:49:41 <abstracted> runtime
16:49:51 <Peaker> josephle, OO consists of many things..  the most useful part is having records of functions, and that works quite well with Haskell style types
16:50:14 <monochrom> hpc: I forgot the name thunderdome, but I still remember "break the deal and face the wheel", and other similarly catchy rhyming laws made by the ruler of that settlement :)
16:50:15 <josephle> just look at Gilad Bracha's Newspeak programming language - cool ideas that become terrifyingly bad in the context of static types
16:50:17 <Peaker> The open recursion part I don't personally find useful, but that too can work with a HM-like type system
16:50:42 <Peaker> josephle, I've always been left unimpressed with Gilad Bracha's stuff
16:51:07 <Peaker> Newspeak's website is refusing to zoom the text :(
16:51:12 <josephle> Peaker, I am less than unimpressed by Dart
16:51:13 <cmccann> honestly, most things that are difficult to express in an ML-ish type system are probably too difficult for most programmers to use correctly
16:52:08 <Peaker> what cool ideas are you referring to in Newspeak?
16:52:11 <josephle> cmccann, when you say ML-ish, is this with or without a module system?
16:52:36 <hpc> i still don't understand the ML module system
16:52:40 <cmccann> josephle: it's with deliberate ambiguity.
16:53:08 <josephle> Peaker, perhaps not "cool" per se from a PLT standpoint. But ideas like functorizing all your imports is a nice idea (ML-style functorization)
16:53:29 <josephle> that is to say, forcing dependencies to be explicit at the module level
16:54:17 <josephle> hpc: I wrote a phasesplitter for the ML module system, and I still don't know what was going on
16:54:37 <josephle> withtypes are scary
16:54:38 <hpc> yeah
16:54:42 <Peaker> josephle, that's fine, and not a new idea
16:54:51 <Peaker> josephle, also not that exciting
16:55:00 <hpc> in any event, merging semantics (functor modules) with code organization (file structure) is a stupid idea
16:55:13 <Peaker> but Gilad Bracha's papers say things like "Mandatory type systems greatly reduce the number of legal programs, they're awful!"
16:55:15 <hpc> i would say something about learning a lesson from java, but ML predates it
16:55:37 <hpc> Peaker: "think of all the poorly-typed programs we could be writing that it is denying us!"
16:55:45 <josephle> Peaker, I'm no fan of Bracha to be honest
16:56:34 <josephle> I'm just giving an example of an idea that ends up being painful if you want to upgrade from untyped to some versions of statically typed
16:57:17 <josephle> hpc: but, but separate compilation! Or something like that.
16:57:19 <abstracted> I think that I need an interesting project more than an interesting programming language.  and then the freedom to use the best programming langauage, and then the time to actually focus and dedicate myself to the problem.
16:57:32 <blackdog> hpc: would you consider programs with plugins like xmonad to be fully statically typed? I haven't got it quite settled in my head yet.
16:57:47 <josephle> abstracted: I think that's the right way to go.
16:57:56 <hpc> blackdog: i would consider xmonad to be painful to work with for quite separate reasons ;)
16:58:21 <blackdog> hpc: why?
16:58:24 <lambdazerocool> while for some things i am really digging static typing cuz it catches blurps at compile time, there are other times when i find it heinously inconvenient to not be like "look subtraction it works"
16:58:59 <blackdog> hpc: it seems like there's some value in not having to stop a process entirely in order to run new code at native speed
16:59:25 <josephle> lambdazerocool: be glad you don't do dependent types. Now that's a love/hate relationship with the typechecker.
16:59:51 <cmccann> that is, with dependent types, the type-checker hates you and you love it.
16:59:54 <hpc> blackdog: there is; i just don't like their API
17:00:01 <hpc> it's mostly X's fault i think
17:00:11 <hpc> blackdog: i could show you my IRC bot :P
17:00:19 <hpc> self-reloading perl
17:00:20 <abstracted> I have none of the three things I mentioned, though if I had the last thing, the other two would follow.
17:00:31 <typoclass> lambdazerocool: sometimes yes, but i think over time you learn to wrangle the type system, and then it becomes a matter of ghc telling you what's wrong with your program. at that point it's not artificial hurdles to annoy you, it's information that you'd want to know anyway, sooner or later
17:00:32 <cmccann> hpc: ew, perl
17:00:34 <blackdog> hpc: right, fair enough. but any program intended to run for a long time & be upgraded on the fly will have the same issue
17:00:49 <hpc> cmccann: it's actually quite nice
17:00:54 <blackdog> and it seems like that sort of staged computation is still not totally obvious with haskell
17:00:56 <cmccann> I was joking anyway.
17:01:04 <lambdazerocool> typoclass: that's what's happening 90+% of the time already. right now, with this time stamping business, i'm just having major issues. =D
17:01:47 <josephle> speaking of dependent types, does anyone know about the status of Haskell holes?
17:01:54 <elliott> they're in HEAD
17:02:04 <cmccann> release will be late this year, I think?
17:02:05 <josephle> I'd love to have some agda-style fill-in-the-blank games
17:02:07 <hpc> elliott: you are not simon cat!
17:02:11 <typoclass> lambdazerocool: you can always put code on hpaste.org (if it works or not). folks in here often have valuable input
17:02:14 <shachaf> josephle: Just use ImplicitParams.
17:02:21 <elliott> what shachaf said
17:02:26 <shachaf> It's approximately as good. In some ways it's slightly better.
17:02:28 <dolio> Just use something crappy.
17:02:34 <josephle> shachaf: ah, I didn't know about that
17:03:43 <typoclass> josephle: i can't come up with an example right now, but look at ircbrowse.net. people in here have used it occasionally. "@type ... ?blah :: ..."
17:03:53 <abstracted> anyways, I found this : https://github.com/neurocyte/android-haskell-activity and also this https://github.com/neurocyte/ghc-android so its as if this guy got something to work
17:04:14 <abstracted> though maybe I don't know enough to interpret what I'm looking at.
17:04:37 <abstracted> the later scripts I couldn't get to work on osx or ubuntu
17:05:06 <abstracted> after some attempts and manipulations.
17:05:45 <typoclass> i've always thought that "mandatory type systems exclude so many programs" would have to lead to writing everything in assembly, wouldn't it? you can do anything at all, so this must be best, somehow
17:06:09 <abstracted> neurocyte: actually you are here maybe I should just ask you?
17:06:42 <josephle> typoclass: I would also add on that assembly is faster than everything else, but I suspect C compilers today are too smart for that
17:07:00 <dolio> 'Type systems exclude programs,' is the same kind of error in thinking as only considering, 'types are good because they catch errors early.'
17:07:42 <c_wraith> type systems exclude many programs.  *most* of the ones they exclude are wrong.
17:07:50 <c_wraith> at least if the type system is any good
17:08:02 <shachaf> All programs they exclude are wrong by definition.
17:08:19 <cmccann> type systems make it slightly harder to write programs without knowing wtf you're doing.
17:08:26 <cmccann> some people don't like that.
17:09:12 <dolio> Types are good ways of fundamentally structuring your program, and getting the computer to help you with your programming.
17:09:29 <dolio> Maybe it even fills in some details for you automatically.
17:09:33 <hpc> cmccann: knowing wtf they are doing?
17:09:52 <cmccann> hpc: yes
17:09:59 <hpc> ;)
17:10:31 <cmccann> that is how you get people on SO who post horrible broken code and, when asked why they expected it to do something, reply "because I wanted it to".
17:11:01 <koala_man> maybe they didn't wish hard enough
17:11:08 <cmccann> perhaps.
17:11:28 <typoclass> dolio: you mean, when saying 'types are good because they catch errors early', people forget to consider things like 'without inference, it becomes terribly bureaucratic because we have to write each last type signature by hand'?
17:11:32 <dolio> The Secret for programmers.
17:11:43 <hpc> if it's javascript, they just need to use the "use even less strict than before" pragma
17:11:48 <monochrom> sometimes, when a type error is reported, it is suitable to say "that is exactly correct behaviour".
17:11:55 <cmccann> so what's the tally on the libraries@ thread at this point? something like 15 in favor, 1 neutral, and 1 lunatic?
17:11:56 <abstracted> So I am probably an immature developer in many ways but, my take on why I'm attracted to learn more languages with strong type systems is the notion of fail-fast or, bring the pain forward
17:11:56 <dolio> typoclass: No, I mean that's not the only reason they're good.
17:12:21 <typoclass> dolio: oh i see
17:12:34 <abstracted> which is this supposed "agile" lesson but then most agile dudes are out there using java which is one of these lanugauges I regard as the worst of both worlds.
17:13:06 <cmccann> abstracted: agile has become a buzzword that means very little in practice in most of the industry.
17:13:18 <abstracted> I think more dynamic langugaes are legit as well, different approaches etc
17:13:29 <abstracted> cmccann: I know trust me I'm right in the center of it.
17:14:01 <monochrom> there is economic incentive for programmers to desire fail-late
17:14:10 <abstracted> agile could be viewed as a cult, or a money grab, or a set of common sense ideas, or ...
17:14:26 <hpc> it's not a moneygrab until paul graham blogs about it
17:14:27 <hpc> ;)
17:14:28 <arkeet> haha monochrom
17:14:30 <cmccann> hahahaha
17:14:50 <dolio> typoclass: It is a view of types as only things as something you slap on after the fact, to catch some mistakes, instead of types as a fundamental building block of your program.
17:14:52 <monochrom> the ideal sequence of events is: ship and deploy, collect money, now have errors.
17:15:08 <dolio> Curry vs. Church, in a sense.
17:15:16 <no-n> haha Mon_Ouie
17:15:19 <no-n> monochrom: *
17:15:19 <elliott> dolio += 1000. (from libraries@, I understand you can have 1000 votes on anything if you'd like, not just one.)
17:16:04 <typoclass> monochrom: additionally there's a psychological incentive. you can keep up the hope that it'll somehow work well enough for long enough, against all experience
17:16:04 <dolio> This isn't really my argument. I just stole it from Conor.
17:16:14 <typoclass> dolio: right
17:16:16 <abstracted> what is +=? do we now have a new dolio except with more votes?
17:16:26 <arkeet> :t (+=)
17:16:27 <lambdabot> (Num a, MonadState s m) => ASetter' s a -> a -> m ()
17:16:46 * elliott recognised it as being Conor's argument, but sought to embiggen dolio's wealth regardless so that I may be rewarded richly if he ever becomes world dictator
17:17:03 <elliott> pretty sure this is how politics works.
17:17:09 <monochrom> but what if Conor became world dictator
17:17:12 <cmccann> sounds legit to me.
17:17:25 <elliott> monochrom: then we are doomed regardless.
17:17:34 <shachaf> monochrom: I vote for Conor for world dictator.
17:17:46 <cmccann> monochrom: he would be too principled to stoop to crass cronyism, and would instead hand out political favors in exchange for puns.
17:18:00 <shachaf> Note: I vote for people for world dictators based entirely on their puns.
17:18:02 <hpc> if conor becomes dictator, all we need to do is trade lenses for frp
17:18:29 <shachaf> ?
17:18:32 <elliott> also, if Conor becomes dictator someone will probably assassinate him for not working on Epigram 2.
17:18:37 <abstracted> I'm sitting at a bar, which has gotten crowded since I sat down, and now I'm buzzed.
17:18:38 <cmccann> haha
17:18:39 <elliott> so it's not much of a concern.
17:18:44 <blackdog> elliott: can you prove that?
17:19:06 <elliott> blackdog: I'm afraid a constructive proof would have certain side effects
17:19:24 <blackdog> elliott: *grin*
17:43:45 <Fuuzetsu> Can someone with a Haskell Wiki account fix this? http://www.haskell.org/haskellwiki/Haddock/FAQ
17:45:40 <monochrom> what needs to be fixed? in addition to what I think needs to be fixed, of course.
17:45:53 <monochrom> do you know what I think needs to be fixed?
17:45:56 <Fuuzetsu> Most likely the thing you are thinking of.
17:46:16 <monochrom> we must have reached telepathy
17:46:24 <Fuuzetsu> A type-safe telepathy.
17:46:26 <monochrom> I wonder why we even bother to use IRC
17:46:26 <Fuuzetsu> The command seems split into many lines instead of existing as a single one.
17:50:42 <cmears> Fuuzetsu, I think it looks better now
17:50:48 <Heffalump> is there a standard type-safe heterogenous map around? (externally type-safe, but relies on internal invariants and associated types to maintain the key -> value mapping)
17:51:18 <tswett> Ahoy. How do I see the Haddock for my Haskell installation?
17:51:27 <tswett> On OS X, which I assume is the same as other Unixes.
17:51:51 <cmccann> tswett: first, make sure you actually have haddocks. I think that's disabled by default, which is silly.
17:52:26 <cmccann> tswett: beyond that, mine are in ~/.cabal/share/doc/
17:52:30 <Saizan> you might have a ~/.cabal/share/doc/index.html
17:52:50 <cmccann> OS X may or may not use a different location.
17:52:59 <tswett> I don't even have a ~/.cabal/share.
17:53:28 <Fuuzetsu> cmears: Thanks
17:53:40 <monochrom> I think cabal-install deliberately defaults to a location different from other unixes
17:54:03 <Saizan> your cabal config should have the locations, if you can find it :)
17:54:04 <cmccann> yeah, there is probably a more OS X-appropriate location that it uses?
17:54:18 <tswett> Anyway, the problem I'm actually trying to solve: I want to import Random, but I can't :m + System.Random ("It is not a module in the current program, or in any known package.") or Random ("It is a member of the hidden package `haskell98-2.0.0.1'.").
17:54:37 <tswett> Lemme use my X-fu to see if I can guess where it is.
17:54:56 <Saizan> cabal install random ?
17:55:11 <monochrom> System.Random no longer comes with GHC
17:55:36 <tswett> Looks like /Library/Haskell/doc is a symbolic link to the appropriate location.
17:56:57 <tswett> All right, I got it. Thanks.
18:03:42 <tswett> All right. This gives me a "parse error (possibly incorrect indentation)":
18:03:43 <tswett> do rands <- sequence (replicate 26 (randomRIO (1,5))); let letters = zip ['a'..'z'] rands; return [map fst $ filter ((== n) . snd) letters | n <- [1..5]]
18:04:09 <shachaf> tswett: let can have multiple ;-separated bindings.
18:04:18 <shachaf> The "return ..." is treated as one of those bindings.
18:04:28 <tswett> Whoops. Should I add some braces?
18:04:34 <shachaf> Gopher it.
18:04:50 <tswett> Yup, sticking braces around the let worked. Thanks.
18:24:08 <elliott> geekosaur: wow, where did you buy those 10000000 votes?
18:24:28 <cmccann> from Malcolm, perhaps?
18:24:32 <Fuuzetsu> > repeat 10000000 "vote"
18:24:32 <cmccann> he seems to have plenty to spare.
18:24:33 <lambdabot>   The function `GHC.List.repeat' is applied to two arguments,
18:24:33 <lambdabot>  but its type `...
18:24:35 <geekosaur> more or less...
18:24:38 <Fuuzetsu> oops
18:24:48 <Fuuzetsu> > replicate 10000000 "vote"
18:24:49 <lambdabot>   ["vote","vote","vote","vote","vote","vote","vote","vote","vote","vote","vot...
18:25:48 <elliott> of course, on libraries@ the maximum number of votes you can have is 2^29 - 1
18:25:58 <elliott> though you can vote -(2^29) too.
18:26:21 <Fuuzetsu> One day I will have signed up to all Haskell mailing lists there are
18:26:37 <fluffynukeit> hi all.  I have a duped chan I'm using for 2 way communication.  Two threads write to the duped chan (one each), but each thread filters getChanContents to only include messages with the "correct" constructor for that thread, and ignore others.  Would this cause a space leak (I have one related to the Chans I think)?
18:29:35 <fluffynukeit> anyone have any ideas on my chan question?
18:55:33 <shergill> johnw: +1000 for this: 'If "avoiding success at all costs" is jokingly our by-word, are not backwards incompatible changes in the name of seeking perfection one of the best ways to forestall success? :)'
18:58:36 <cmccann> shergill: plussing larger powers of ten, I see. that's very in these days.
18:59:02 <shergill> cmccann: just following precedent :P
18:59:17 <shachaf> -1 for that
18:59:47 <shergill> dammit
19:05:33 <enigmuriatic> what exactly is the difference between infixl and infixr?
19:05:53 <shachaf> @google what exactly is the difference between infixl and infixr?
19:05:54 <lambdabot> http://stackoverflow.com/questions/2617646/difference-between-infix-infixr-infixl
19:05:54 <lambdabot> Title: sml - difference between infix, infixr, infixl - Stack Overflow
19:06:16 <shachaf> Hmm, that's SML. But it's the right answer.
19:07:01 <elliott> it's not quite right for Haskell i don't think
19:07:01 <enigmuriatic> i don't quite get what associativity means in terms of an infix function though
19:07:16 <cmccann> on one hand, infixl says how operator application groups together, while infixr groups them on the other hand.
19:07:35 <elliott> enigmuriatic: let's say your operator is (+)
19:07:41 <elliott> infixl -> a + b + c = (a + b) + c
19:07:46 <elliott> infixr -> a + b + c = a + (b + c)
19:08:01 <enigmuriatic> ah right
19:08:03 <elliott> note that the two are not always equal
19:08:08 <elliott> infix -> uh, I think this makes a + b + c an error or something. or is the same as infixl? or something.
19:08:10 <enigmuriatic> i assumed that that was predetermined by the language
19:08:20 <shachaf> It's an error.
19:08:27 <shachaf> > True == False == True
19:08:30 <lambdabot>   Precedence parsing error
19:08:30 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
19:08:53 <cmccann> just infix only has a precedence level. it's an error if chosing associativity would be required.
19:09:26 <enigmuriatic> haskell is generally left-associative by default, right?
19:09:31 <geekosaur> most languages are
19:09:39 <geekosaur> but exponentiationis conventionally right associative
19:09:54 <geekosaur> (consider exponentiation written with the usual superscript notation)
19:10:48 <cmccann> > let foo x y = "(" ++ x ++ y ++ ")" in "foo" `foo` "bar" `foo` "baz"
19:10:53 <lambdabot>   "((foobar)baz)"
19:11:01 <cmccann> infixl is the default, yes.
19:16:42 <johnw> shergill: :)
19:19:28 <cmccann> johnw: so I think it's now something like 17 in favor, one neutral, one against for no apparent reason, and one against for a bad reason.
19:19:57 <johnw> if those two people who want no change get to decide the vote, it will be time for collective hysteria
19:20:28 <johnw> but I'm glad that consensus is so clear
19:20:43 <johnw> the C++ committee has had an easier time, with multi-national voting, at passing undesired features with even less buy-in
19:21:19 <cmccann> yes, that would be the point at which the sensible approach would be to throw one's hands up and say that wren's ranting about forks was right all along.
19:21:29 <johnw> yes, I agree
19:21:44 <shachaf> wrenting
19:21:47 <johnw> also, that reddit threat on "who killed haskell'" was very apropos
19:22:01 <cmccann> I sorta wonder what SPJ is making of all this.
19:22:14 * elliott sort of hopes foldr isn't generalised.
19:22:18 <cmccann> I sorta imagine him shaking his head and going back to writing another 20 papers and adding three cutting-edge features to GHC.
19:22:23 <johnw> elliott: why?
19:22:26 <shachaf> SPJ doesn't even support generalising let.
19:22:34 <shachaf> He wrote a whole paper about it.
19:22:35 <dolio> Zing.
19:22:37 <elliott> johnw: because it's the native fold for a list
19:22:42 <elliott> the generalisation is a bit weird in the same way
19:22:47 <elliott> :t Data.Foldable.concat
19:22:48 <lambdabot> Foldable t => t [a] -> [a]
19:22:50 <elliott> is
19:22:56 <johnw> :t Data.Foldable.foldr
19:22:58 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
19:23:07 <shachaf> @ty Data.Foldable.fold
19:23:08 <lambdabot> (Foldable t, Monoid m) => t m -> m
19:23:12 <johnw> i still don't quite understand the objection
19:23:22 <cmccann> personally I prefer generalizing concat to mconcat.
19:23:27 <johnw> how does generalizing foldr hurt?
19:23:34 <applicative_> whats the object of wrenting??
19:23:38 <elliott> cmccann: fold > mconcat, surely.
19:23:59 <cmccann> > "fold" > "mconcat"
19:24:00 <lambdabot>   False
19:24:04 <cmccann> so there.
19:24:06 <elliott> johnw: because foldr is in some sense "about lists" and doesn't generalise as cleanly to other Foldables.
19:24:13 <elliott> foldl even moreso
19:24:29 <applicative_> foldl yes, why foldr?
19:24:30 <elliott> as opposed to foldMap etc. which generalises nicely to tree structures.
19:24:41 <shachaf> It's not bad for there to foldr and foldl for folding anything right-biasedly and left-biasedly.
19:24:55 <shachaf> And as it happens that matches []'s Real Fold exactly.
19:24:56 <elliott> applicative_: well, because foldr follows the [] structure directly. it's weird in the same way generalising "maybe" or "either" would be weird, IMO.
19:25:06 <elliott> but whatever.
19:25:06 <shachaf> But I do like a monomorphic foldr for [].
19:25:35 <applicative_> ah found the Libraries list tempest...
19:25:45 <johnw> i'd be OK if it were called gfoldr, or foldrA or whatever
19:25:47 <cmccann> carter: btw just so you know it's mostly because of you and shachaf that I'm posting to libraries@ now.
19:25:59 <carter> cmccann i'm ahppy to hear that :)
19:26:00 <shachaf> cmccann: I consider it my good deed of the day.
19:26:15 <shachaf> Unfortunately it was yesterday. Today I need a new good deed.
19:26:16 <cmccann> shachaf: s/day/week/ surely
19:26:29 <shachaf> cmccann: I'm 7 times better than that.
19:26:31 <Fuuzetsu> cmccann: I swear that I was thinking exactly the same thing right now.
19:26:34 <cmccann> well, your next good deed can be to annoy elliott.
19:26:37 <applicative_> would it be optimizable in the same way if it were generalized somehow ?
19:26:38 <carter> cmccann shachaf  you two will be happy to know that i now have AC installed, so i will be less crazy / gibbery in a few days
19:26:50 <carter> A/C = yay
19:26:51 <shachaf> The trouble with libraries@ is that just anyone gets to vote.
19:27:08 <carter> shachaf yeah… but whats a good alternative?
19:27:13 <applicative_> don't worry shachaf I'm not a subscriber
19:27:25 <johnw> shachaf: anyone can vote, but only those who object matter
19:27:30 <applicative_> everyone who can tolerate all the arguments gets a vote
19:27:33 <Fuuzetsu> carter: Make a Haskeller power ranking and only let the top 100 vote.
19:27:42 <cmccann> I think the most popular alternative to libraries@ is to stage a coup and make edwardk dictator for life.
19:27:48 <shachaf> libraries@ is an object-oriented mailing list.
19:27:51 <johnw> cmccann: I'm almost tempted to agree
19:27:59 <applicative_> objection-oriented
19:28:13 <dolio> shachaf: Puns don't count as good deeds.
19:28:44 <shachaf> Then I've done very few good deeds in my life.
19:29:07 * applicative_ isnt sure about edwardk as dictator as much as he loves him
19:29:28 * edwardk doesn't need to be loved, merely obeyed. ;)
19:29:38 <shachaf> Perhaps there should be a poll tax. I hear that's a good way to solve these issues.
19:29:41 <cmccann> applicative_: yes but consider the alternative. you read that libraries@ thread, right?
19:29:55 <Fuuzetsu> I think we would have no actual programs. Just very abstract frameworks to write those programs. And then abstract frameworks to write frameworks.
19:30:24 <carter> Fuuzetsu yeah, edwardk  does write libraries for library writer
19:30:24 <carter> s
19:30:24 <carter> not application writers
19:30:26 <carter> usually
19:30:46 <johnw> shachaf: I hear that in early Sparta, any citizen could propose a new law, but if popular vote rejected the law, you were hanged
19:30:53 <cmccann> anyway, according to the highly scientific data which I basically just made up right now, by 2019 approximately 115.3% of all Haskell code will rely on the edwardk platform(tm).
19:30:57 <edwardk> i mostly get forced to write libraries i need for my libraries
19:31:01 <cmccann> so he might as well be in charge by then anyway.
19:31:23 <shachaf> johnw: Sounds like they *really* weren't fans of me in early Sparta.
19:31:28 <Fuuzetsu> Maybe we should rename it HaskellK
19:31:41 <enthropy> flip f x = fmap ($ x) f; (.) = fmap -- the next libraries@ bridge to goo
19:31:55 <carter> johnw hopefully i was helping things a hair
19:32:07 <shachaf> class Dot a where (.) :: a
19:32:09 <carter> looks like we got a yes from everyone who's actually doing things with haskell
19:32:11 <johnw> this @libraries discussion makes me wonder if schools should just switch to Hugs and optimize everything for teaching; then let the interested discover GHC later
19:32:29 <shachaf> No, Hugs is not good for teaching. Use GHC.
19:32:47 <johnw> Hugs is actually worse?
19:32:54 <edwardk> I don't really see any problem with the teaching aspect. The Haskell2010 and Haskell98 packages wouldn't be affected by this change. If you need mapM from the stone age, there it is, unmodiifed in its full monomorphic glory.
19:33:09 <johnw> edwardk: yeah, that was a great counter-argument I thought
19:33:16 <edwardk> You can set up your 8-track and zone out while coding some basic list processing.
19:33:19 <johnw> you are right, just let them stick with haskell2010 and use GHC
19:33:22 <johnw> haha
19:33:36 <carter> johyeah
19:33:49 <edwardk> You have all the monads you need. IO, [], and Maybe. Like God and Wadler intended.
19:34:18 <cmccann> party like its h98
19:34:23 <edwardk> haskell2010 might be a bit too modern. Lets be honest those textbooks were written before it came out. Don't rock the boat.
19:34:38 <johnw> sadly, every vote-calling thread seems to devolve into a massive discussion about some objection, basically ended the vote
19:34:41 <edwardk> I mean its not like anybody wants to write new versions of textbooks and make more money
19:34:50 <copumpkin> what if someone accidentally writes an arrow on the right side of a guard bar
19:34:53 <copumpkin> and it works!
19:34:56 <darinmorrison> heh, mailing list drama?
19:34:57 <edwardk> johnw: right now we're sitting at around an 85% supermajority.
19:34:57 <dolio> Haskell 1.4 is too modern, too.
19:34:57 <copumpkin> what will they think then!
19:35:17 <cmccann> darinmorrison: proposal on libraries@ to move Foldable/Traversable into Prelude
19:35:32 <darinmorrison> ah
19:35:33 <cmccann> and throw all the monomorphic list crap out
19:35:40 <edwardk> If we can't get something through the libraries process with that kind of margin, then perhaps we don't deserve to continue ;)
19:35:49 <darinmorrison> cmccann: and people are freaking out?
19:35:50 <carter> darinmorrison I may or may not have helped heckle it along :)
19:36:00 <cmccann> edwardk: by my count it's around 17 in favor, 1 neutral, 2 against.
19:36:11 <cmccann> darinmorrison: less than I expected, actually.
19:36:18 <edwardk> > 17/20
19:36:19 <carter> though thankfully shachaf and cmccann  prevented me from going overboard
19:36:20 <lambdabot>   0.85
19:36:21 <geekosaur> someone seriously proposed that we must not do so because it would make it harder to teach peopple who aren't even really being taught Haskell
19:36:26 <carter> yeah
19:36:32 <darinmorrison> edwardk: that's not bad
19:36:53 <darinmorrison> geekosaur: *rolleyes* seen that one before
19:37:07 <geekosaur> I would have proposed such a thing as a *straw man* for not changing things... but it was a serious complaint.
19:37:38 <edwardk> geekosaur: the existence of the haskell2010 and haskell98 packages largely nullifies that assault on this topic
19:37:43 <carter> darinmorrison i was very close to pulling the "it seems every person who's actually using haskell in their biz supports this change" card
19:38:03 <edwardk> geekosaur: that argument will rear its ugly head again when Applicative as a superclass of Monad comes up, but hopefully is defanged for now here.
19:38:03 <darinmorrison> carter: can understand how you feel
19:38:30 <geekosaur> I only wish it did. Unfortunately I expect that someone will, with a straight face, complain that not teaching such people modern Haskell is a disservice
19:38:30 <darinmorrison> IMO if people are that serious about keeping things simple for teaching, they should develop their own mini-haskell or fork it
19:38:31 <monochrom> I worry about teaching too. but I guess "import Prelude(); import Basic" will have to do. Basic is an elementary prelude I would write for teaching.
19:38:38 <geekosaur> never mind that that's exactly what they are doing!
19:38:45 <edwardk> carter: malcolm wallace invalidates your argument though
19:38:51 <carter> oh?
19:38:54 <Fuuzetsu> hasn't Applicative => Monad pretty much been agreed on already?
19:38:54 <carter> how so?
19:39:08 <carter> edwardk but they don't use ghc
19:39:08 <edwardk> carter: he came down on the other side and works in haskell professionally =P
19:39:23 <Igloo> edwardk, johnw: Library decisions aren't made by voting, FWIW
19:39:28 <edwardk> Fuuzetsu: yes. last time oleg had a bit of a brainfart and it got very very confused.
19:39:33 <edwardk> Igloo: i understand that.
19:39:40 <carter> Igloo pray elaborate?
19:39:47 <carter> edwardk oleg what?
19:40:31 <carter> mind you, i've also been short on sleep much of the past week, so i've not been  very constructive in that whole list
19:40:37 <edwardk> Igloo: we abandoned things like (&) after it was clear there was a vocal minority against it. Here, I do feel that the number of people in favor of the change is somewhat overwhelming though.
19:40:37 <Igloo> carter: The maintainer decides what happens (although they would be unlikely to go against a strong consensus)
19:40:52 <carter> Igloo got it
19:40:59 <dolio> Oleg has some not very convincing reasons for not wanting Functor/Applicative above Monad.
19:41:08 <dolio> Like not wanting to write two extra lines of code.
19:41:14 <carter> ahhh
19:41:16 <carter> that is odd
19:41:17 <darinmorrison> heh
19:41:32 <cmccann> carter: to be fair, oleg is odd himself :P
19:41:38 <Fuuzetsu> Where can I read Oleg's opinion?
19:41:40 <Igloo> edwardk: Sure, just thought I'd make sure everyone was straight on the technicalities
19:41:45 <dolio> And saying that if you want to have something like Functor f => Functor FooT f, you have to write more than two lines, which is true anyway.
19:41:57 <edwardk> Igloo: sure.
19:42:17 <dolio> Fuuzetsu: You have to look at the libraries list archives.
19:42:30 <dolio> For the last time the Monad hierarchy thing came up.
19:42:39 * Igloo is getting tempted to propose completely removing the Prelude, and seeing what happens
19:43:10 <carter> Igloo btw: your alternative works with clang but not gcc
19:43:14 <carter> i'll add it to the ticket
19:43:17 <elliott> dolio: weren't his reasons more like "typeclasses can't express that every Monad gives rise to an Applicative instance, so we should just not do it"?
19:43:31 <elliott> which... would sort of make sense if there weren't Applicatives that aren't Monads
19:43:39 <edwardk> Igloo: as the maintainer for base is 'ghc central' who ultimately is the person that we have to lobby? =)
19:43:45 <edwardk> Igloo: i figured it was you ;)
19:43:56 <cmccann> I for one would at least like it to be made explicitly clear if a strong consensus for change is going to be ignored. for this, or any other issue.
19:44:00 <dolio> I don't really remember that one, but maybe.
19:44:07 <johnw> edwardk: according to the wiki: SPJ, Marlow, Lyangh
19:44:08 <carter> Igloo save that prelude one for right before the start of the fall :)
19:44:15 <shachaf> Fuuzetsu: #haskell is an echo chamber. If your opinions of "what everyone thinks" are based on #haskell, they're probably wrong.
19:44:20 <liyang> Igloo: I'd be for removing the Prelude.
19:44:29 <cmccann> also, a proposal for removing Prelude sounds incredibly entertaining.
19:44:32 <monochrom> but typeclasses can express that Applicative is more general than Monad, just as Eq is more general than Ord
19:44:34 <carter> shachaf that too
19:44:38 <Igloo> edwardk: Well, that isn't as well-defined as it could be  :-)
19:44:48 <Fuuzetsu> shachaf: What gave you that idea?
19:44:55 <cmccann> shachaf: my opinions of what everyone thinks are based on listening to edwardk and assuming everyone agrees with him.
19:44:56 <Igloo> carter: Why's that? And when's the start of the fall?
19:45:13 <carter> because april 1 is too far away  :)
19:45:19 <carter> though maybe no prelude is a good idea
19:45:21 <carter> idk
19:45:30 <liyang> To be fair, edwardk usually has a point.
19:45:32 <applicative_> monochrom: Functor is more general than Monad, but at least liftM and fmap have to coincide
19:45:40 <elliott> liyang: sometimes it's free.
19:45:51 <carter> hahah
19:45:56 <dolio> I could almost get behind no prelude.
19:46:06 <Igloo> carter: Can you add the result of going via -s with clang too please?
19:46:12 <applicative_> that I could get behind
19:46:12 <carter> Igloo sure
19:46:21 <darinmorrison> no prelude? won't someone think of the students?
19:46:30 <monochrom> my analogy is robust. a>=b && a<=b has to coincide with a==b too
19:46:31 <carter> Igloo i'm a bit tired (crap sleep the past few days) but i can swing tha tat least
19:46:35 <liyang> A minimal Prelude maybe. If you want to work with lists, import Data.List. I don't need nor want it particularly often.
19:46:37 <dolio> But I don't want to write import Data.Function ; import Data.Tuple import Data.Either; import Data.Maybe; import Data.List; import Control.Monad; import ...
19:46:44 <carter> yeah
19:46:48 <carter> there is that
19:46:51 <carter> dolio has a point
19:47:02 <johnw> dolio: it just means that there'd be several preludes to choose from on Hackage (like there are now)
19:47:06 <applicative_> I'm with no default prelude, but just many; there ought to be preludes in different human languages for instance
19:47:10 <Igloo> dolio: Perhaps I should say, no implicit-loading of the Prelude
19:47:13 <applicative_> I mean for students
19:47:15 <johnw> general-prelude is basically all of those imports, plus a few more
19:47:17 <darinmorrison> carter: that kind of thing could be handled by a tool
19:47:19 <djahandarie> Control.* is Data.*. Data.* is Control.*.
19:47:28 <elliott> dolio: it might be nice with tooling support.
19:47:33 <elliott> of course, that's what the java people say.
19:47:35 <dolio> If it's not loaded by default, do we get to make it good?
19:47:48 <cmccann> I would worry about proliferating incompatible quasi-Prelude libraries with no "official" one though.
19:47:48 <carter> Fuuzetsu shachaf yeah… IRC and cafe and reddit are different sub communities mostl
19:47:53 <carter> yeah
19:47:54 <johnw> lens isn't loaded by default, and it's becoming good
19:47:55 <carter> that too
19:47:57 <cmccann> that kind of fragmentation would be very bad.
19:47:59 * applicative_ is happy to import Prelude.Dolio
19:48:00 <liyang> Students will cope.
19:48:05 <darinmorrison> elliott: no harm in having reasonable tooling support. As long as we don't start seeing boilerplate everywhere
19:48:06 <Igloo> dolio: Well, one advantage of doing it is that it removes a huge barrier to using the alternative preludes
19:48:25 <carter> there is that
19:48:30 <johnw> we'd mostly all use Prelude.Edwardk anyway, wouldn't we?
19:48:38 <dolio> I don't know if I buy that.
19:48:39 <johnw> Edwarlude
19:48:40 <carter> which alternatives are out there that are *good*
19:48:49 <carter> or at least not terrible
19:49:00 <johnw> carter: general-prelude is very simple in its aims
19:49:00 <edwardk> the problem is my own little Prelude can't fix things like the class hierarchy. that still needs GHC HQ ;)
19:49:11 <johnw> edwardk: that's an excellent point
19:49:19 <carter> edwardk good point
19:49:19 <djahandarie> Guys, it's called Control.Lens, you don't need to come up with some weird name for it.
19:49:24 <johnw> the prelude is something that every library agrees on
19:49:30 <edwardk> djahandarie: hahaha
19:50:01 <elliott> alternative preludes are just toys.
19:50:16 <elliott> enabling them is pointless because they cannot really do anything of value without breaking compatibility with every library ever, inherently
19:50:27 <cmccann> yes, what elliott said.
19:50:42 <Igloo> In general there's resistance towards using packages that don't come with the HP, packages that don't come with GHC, modules that aren't in base, and things that aren't in the Prelude. This has the effect that everyone tries to push their pet code further towards the Prelude end, but I think we'd be better served by pushing stuff further away instead, to level the playing field
19:50:46 <johnw> elliott: yes, I agree
19:50:52 <cmccann> I mean, I habitually use my own minimal alternate prelude and I still don't think alternate preludes are a good solution overall.
19:51:24 <monochrom> use Helium for teaching
19:52:17 <edwardk> Igloo: for the vast majority of things i happen to agree
19:52:17 <monochrom> anyway the Racket people have long learned and practiced that the teaching language must be a restriction of the production language.
19:52:18 <dolio> I can say that there is no alternative prelude that I think is better than the regular prelude yet.
19:52:29 <cmccann> an alternate prelude that can't replace Num can't really fix anything interesting. an alternate prelude that does replace Num won't work with anything else.
19:52:31 <dolio> And that's not because I need to write two extra lines.
19:53:05 <dolio> At least, I haven't seen one.
19:53:32 <carter> cmccann yeah… basically to push an alternative prelude, the pusher would need to fix EVERYONES libraries to make it nice
19:53:42 <carter> i mean an alternate Num
19:53:59 <Ralith> could write an automated fixer
19:54:17 <applicative_> Prelude.YAP has a different Num
19:54:29 <dmwit> If the fixes are truly mechanical, the new Prelude probably isn't better than the old one.
19:54:33 <cmccann> plus there's the whole business with stuff being baked into the language and defaulting and whatnot, which makes it hard to really do anything interesting in an alternate prelude.
19:54:42 <elliott> I fear I will be making a joke about classy-prelude within the next five minutes
19:54:55 <cmccann> elliott: as long as it's a classy joke.
19:55:05 * applicative_ goes with module-prelude
19:55:11 <applicative_> modular
19:55:18 <monochrom> may I say "inb4 classy-prelude"? :)
19:55:26 <cmccann> we'll need a prelude-prelude, that people can import while writing preludes.
19:55:26 <johnw> modest-prelude, in the vein of the proposal of the same name
19:55:37 <johnw> cmccann: actually, that exists
19:55:42 <johnw> i think it's called base-prelude
19:55:43 <cmccann> oh god I was joking
19:55:45 <cmccann> :[
19:56:08 <monochrom> "be careful with your jokes. they may come true." :)
19:56:10 <shachaf> It exists but I don't recommend it.
19:56:31 <cmccann> shachaf: what do you recommend?
19:56:34 <applicative_> but couln't a 'prelude' be a language level thing, which has to resolve various things like the interpretation of literals etc
19:56:42 <johnw> he recommends not recommending things
19:57:10 <dolio> cmccann: You missed the post in the discussion where someone recommended using something from the 'Prelude' section of hackage?
19:57:47 <cmccann> dolio: I saw that. I just never looked at that section of hackage.
19:58:06 <edwardk> Igloo: the Foldable/Traversable thing is something already in use in the vast majority of haskell code, already in base, with solid laws and with no reasonable haskell 98/2010 generalization, killing the clashy versions of things already in the Prelude and upgrading them to their replacements from Foldable and Traversable breaks very little code and puts useful abstractions in easy reach.
19:58:11 <elliott> alternative preludes remind me of people writing, say, their own operating system. cute and fun, but irrelevant
19:59:43 <edwardk> Counting just off my own project directory, it would appear to enable me to eliminate 730+ lines of import statements -- Not counting the reduction in hidings from Prelude which are trickier to count, but is another 100+ lines at minimum.
20:00:07 <carter> and if we count everyone who uses those libs in that count
20:00:11 <carter> we can multiply that by at least 10!
20:00:14 <carter> 10 !
20:00:16 <edwardk> now that isn't a huge selling point, but it is at least indicative of scale to me
20:00:27 <carter> 10 ! << 10!
20:00:30 <cmccann> carter: 10 is passe, we do things in multiples of 1000 these days.
20:00:31 <tinyghost> hi! is there a way to specify different libraries for Cabal in the extra-library section for different operating systems?
20:00:50 <carter> tinyghost i thinks theres some libs that do that...
20:00:53 <edwardk> tinyghost: you can use flags to make different extra-library sections based on operating system
20:01:01 <tinyghost> this has ncursesw and panelw listed, and they come with most systems but on OS X they're stored under ncurses and panel
20:01:07 <edwardk> if os(windows)\n  extra-libraries: ...
20:01:08 <applicative_> somewhere I made a prelude that could import as much of base as didnt introduce name clashes on a dare with nand or someone
20:01:14 <tinyghost> edwardk oh cool :3
20:01:56 <edwardk> applicative_: i'm generally with igloo on the 'paring down the prelude' argument. i just disagree in this particular case
20:02:31 <kfish> carter, edwardk: what i'm finding strange is that it's the industrial programmers who want the more general types and sensible hierarchy, and the university PL researchers/lecturers fighting against the changes
20:02:41 <applicative_> of Foldable? , edwardk
20:02:49 <carter> kfish (aside from malcom wallace)
20:02:53 <carter> kfish YES
20:02:55 <carter> its weird
20:02:55 <edwardk> kfish: hah
20:02:58 <applicative_> tinyghost: https://github.com/michaelt/cabal/blob/master/cabal-install/cabal-install.cabal line 135 ff
20:03:19 <tinyghost> applicative_ thanks!
20:03:27 <edwardk> kfish: i've concluded there is a hardline 10-12% that will fight any change, no matter what
20:03:28 <carter> kfish i'm even ok with explaining any breakage fallout a bajillion times to potential customers
20:04:00 <carter> edwardk i was very very close to emailing a CHANGE champaign poster attachment in one of my emails
20:04:01 <kfish> we'd refactor our code to handle the changes in a few hours flat because *that's what we do all day every day anyway*
20:04:03 <carter> i got talked out of it though
20:04:10 <carter> kfish that too
20:04:14 <carter> its EASY
20:04:41 <dolio> I think authors should push for more change.
20:04:46 <dolio> Sell new editions.
20:04:47 <dolio> Make money.
20:05:03 <edwardk> applicative_: yeah Foldable/Traversable
20:05:08 <kfish> though for this particular Foldable/Traversable change, most of the refactoring would be removing redundant imports
20:05:16 <dolio> Gotta buy LYAH revised edition.
20:05:39 <kfish> and will my code look important enough if i only have 20 imports instead of 40 in each file?
20:05:49 <applicative_> I don't really use Foldable and Traversable much, I wonder if it's because theyre not in the Prelude ...
20:06:09 <liyang> To add to what kfish said earlier, IME lots of university researchers *can't actually program*.
20:06:35 <cmccann> liyang: some of the university homework questions that end up on SO are horrifying.
20:06:43 <applicative_> liyang: they can but they use java and then cover it up
20:06:58 <carter> liyang that too
20:07:03 <applicative_> liyang: or so it was in a battle I was waging today...
20:07:04 <liyang> I mean, FP researchers can't program.
20:07:08 <cmccann> I always feel like demanding that these students tell me who their teacher is so I can give them whatfor until they stop assigning stupid things.
20:07:19 <carter> when i was briefly in grad school, poeple didn't understand why i found matlab so horrifying and frustrating
20:07:20 <elliott> I find it odd that people seem to care about this change more than anyone has ever cared about Applicative => Monad, which seems clearly more relevant to me
20:07:26 <applicative_> what do you mean, they write papers in lhs, liyang , they're the only trustworthy ones
20:07:30 <elliott> perhaps just because caring about this proposal is fashionable
20:07:38 <elliott> (not that I oppose it)
20:07:41 <liyang> (In general) They know the theory better than many programmers but they never really apply it to anything substantial.
20:07:50 <carter> in theory :)
20:08:06 <applicative_> liyang: the rest of them claim to have implement things that are at best public in e.g. java .class files, and then just make arbitrary claims. It's so utterly decadent.
20:08:14 <applicative_> implemented, rather
20:08:37 <geekosaur> actually, this proposal seems to have hit a hot button in a way that has caused Functor/Applicative/Monad to come back up again. I feel like some line has been crossed and people are now fed up enough to seriously challenge the status quo
20:08:37 <applicative_> a computer science paper that is not a literate program is simply not science
20:08:41 <carter> applicative_ bast in class, hurhur
20:08:55 <carter> applicative_ true
20:09:02 <johnw> geekosaur: I certainly hope so
20:09:20 <carter> applicative_ i'mfind so much low hanging fruit in actually implementing stuff is amazinggggg
20:09:25 <geekosaur> I *hope* this doesn't nead to a language fork, but if the must-be-suitable-for-teaching-by-default folks win then we may be looking at that. "ok, have your training wheels, we prefer not to be Pascal"
20:09:26 <carter> johnw geekosaur  me too
20:09:44 <carter> geekosaur they can stay with haskell98 / 2010
20:09:53 <carter> their students won't be using hackage libs anyways
20:10:02 <carter> but some bizarre distro their IT folks cooked up
20:10:06 <geekosaur> no, I suspect they won't be satisfied with that
20:10:09 <carter> (happend when I TA'd a haskell class)
20:10:09 <geekosaur> as I said earlier
20:10:23 <geekosaur> they will demand that the modern Haskell standard be their tutorial-only language
20:10:27 <carter> geekosaur i'm willing to be the effigy of their hatred
20:10:34 <geekosaur> becuase that is why we still have a crap Prelude
20:10:54 <carter> geekosaur i will shoot the down hard
20:10:55 <edwardk> geekosaur: i don't see there being any need for a language fork or anything drastic. both the foldable/traversable change and the applicative/monad change are well within the capabilities of the community to handle
20:11:03 <carter> yeah
20:11:05 <geekosaur> h'2010 rejected a bunch of stuff basically to stay with the current limitations
20:11:05 <carter> that too
20:11:20 <carter> talking about university cultcha makes me grumpy
20:11:20 <edwardk> geekosaur: i think any attempts to call for such a thing are rather hopelessly naive about how much work goes into something like that
20:12:05 <geekosaur> I'm not calling for a fork. I'm wondering if people will seriously consider it if it turns out that there is no reconciliation between the current training-wheels Prelude and practical use
20:12:20 <edwardk> geekosaur: i honestly agree with the general flavor of haskell2010. it shored up a few things that were obvious and avoided tackling things that would have been too contentious. keep in mind haskell2010 happened out of the ashes of a haskell' that was _MUCH_ more ambitious
20:12:32 <Aetherspawn> How do I un-@pl ?
20:12:36 <kfish> geekosaur, maybe they can make their own fork of Prelude-Haskell; they can call it Paskell
20:12:40 <edwardk> @unpl foo . bar
20:12:40 <lambdabot> (\ c -> foo (bar c))
20:12:44 <Aetherspawn> @unpl flip (. initReader) prop . initState
20:12:44 <lambdabot> (\ g -> initState g (initReader prop))
20:12:53 <liyang> Paskell++
20:12:58 <liyang> DO EET.
20:13:17 <edwardk> liyang: i still have the domains for 'turbo haskell' =)
20:13:32 <kfish> hi conal :)
20:13:35 <cmccann> edwardk: ahaha nice
20:13:40 <geekosaur> (I do wonder if my suggestion on the list might actually be viable: *no* prelude by default)
20:13:50 <conal> kfish: hi
20:13:53 <edwardk> geekosaur: i'd be against it
20:13:56 <cmccann> geekosaur: I'm not sold on the potential consequences of that.
20:14:06 <johnw> Aetherspawn: if you're using lens, that's just: initState ?? (initReader prop)
20:14:07 <cmccann> mostly a drift toward fragmentation of basic libraries.
20:14:22 <carter> conal hey! (did you get my email last week? i may have been a bit tired when i wrote it, but the intent is there)
20:14:29 <geekosaur> I'm not especially fond of it, but it would at least allow each group to have its own Prelude
20:14:34 <edwardk> geekosaur: it doesn't help. the classes are still going to be controlled centrally by base, so by hiding the Prelude all you do is make everyone import a dozen modules by hand every time.
20:15:03 <edwardk> geekosaur: not really. I can't make a better Num that way. You can't fix the Applicative m => Monad m thing, etc.
20:15:06 <conal> carter: yes, and thanks for the reminder. my hard drive died, and i've been putting my system back together.
20:15:06 <liyang> conal: we're having an internet mass-debate. Care to chip in? :)
20:15:12 <cmccann> I really don't want a future where half of hackage is using classy-prelude-3.1 and the other half is using lens-prelude-23.2.1 and nothing works with both
20:15:24 <edwardk> geekosaur: it gives you the illusion that you can have your own, not the reality
20:15:34 <breadthfirst> Is case an expression?
20:15:40 <geekosaur> breadthfirst, yes
20:15:52 <edwardk> as a community we barely survived having mtl and monads-fd and monads-tf. let alone a tower of babel of preludes. =P
20:15:57 <geekosaur> edwardk, I know, but in some sense we may be headed there anyway
20:15:59 <liyang> Expression of what? Despair?
20:16:02 <Aetherspawn> johnw, thanks
20:16:23 <carter> conal ach, that sucks
20:16:26 <edwardk> geekosaur: we have 3 'blessed' preludes at this point as it is =P
20:16:28 <geekosaur> some people want the illusion that haskell can be hobbled to keep it teachable
20:16:40 <carter> edwardk is the 3rd the one we're about to birth?
20:16:41 <beefcube> can I just have a hackage without this: http://hackage.haskell.org/package/acme-dont-1.1 ?
20:16:44 <conal> carter: i'll reply to your note. sorry about the delay.
20:16:48 <carter> conal its ok
20:16:49 <geekosaur> (I consider their 'keeping it teachable' quite an illusion as it is)
20:16:55 <dmwit> beefcube: NO.
20:17:01 <edwardk> geekosaur: haskell98 + haskell2010 are those hobbled forms. base is the pragmatic compromise.
20:17:09 <cmccann> I really expect that the end result of no "official" prelude would be either fragmenting the community or a de facto official prelude that might as well be blessed.
20:17:15 * elliott thinks this talk of haskell2010 is a bit dishonest.
20:17:30 <elliott> if GHC's Prelude gets this stuff then it will surely end up in the next actual Haskell standard.
20:17:44 <elliott> (or else the standard faces even more irrelevance than it already does)
20:17:56 <geekosaur> I still maintain that there will be standards after h2010, and if the training wheels folks have their way then the next standard and the next standard and ... will also be training wheels
20:17:57 <cmccann> a new standard will not make haskell2010 stop being a thing that exists.
20:18:33 <carter> geekosaur fret not, i will spazz flame any who do that
20:18:35 <cmccann> though I still kind of expect that the next standard will be haskell2017 or something, and all it will do is a minor change to lexical syntax of comments that fixes nothing but nevertheless breaks 20% of hackage.
20:18:36 <carter> or something
20:18:37 <elliott> cmccann: sure. but "this isn't changing the nice predictable standard, just GHC's base" actually means "oh, shut up and use the old version" in context :P
20:18:39 <carter> probably something else
20:18:58 <carter> cmccann hehe
20:19:20 <dmwit> Haskell 2017 chooses the other nesting for quotes and {-
20:19:34 <cmccann> dmwit: yes that works
20:19:40 * zRecursive i hope haskell would have ANSI standard :P
20:19:49 <edwardk> elliott: well, yes.
20:19:53 <johnw> zRecursive: i really don't think you want that
20:20:05 <liyang> @remember cmccann I still kind of expect that the next standard will be haskell2017 or something, and all it will do is a minor change to lexical syntax of comments that fixes nothing but nevertheless breaks 20% of hackage.
20:20:05 <zRecursive> johnw: why ?
20:20:06 <lambdabot> Nice!
20:20:08 <elliott> I mean, I'm ok with "shut up", mind.
20:20:31 <johnw> zRecursive: because then a really small group of people votes in insane language extensions to cater to highly specific market segments, while the features that everyone wants rarely make it in
20:20:49 <johnw> for example, C++'s export templates
20:21:07 <johnw> a complete debacle which several members of the committee became enraged over, no one wanted, no one _used_, and yet it got in anyay
20:21:26 <zRecursive> but C99 seems great ?
20:21:27 <johnw> which meant that standards-conforming compilers had to implement it, even though only one ever did
20:21:50 <johnw> zRecursive: C11 is already out.  anyway, having been a part of the ANSI process for a while now, I don't wish that on Haskell
20:21:55 <cmccann> to be fair, C++'s design is a horrible abomination to begin with.
20:22:20 <elliott> johnw: it sounds like shachaf would say you ASCII silly question.
20:23:05 <cmccann> elliott: ASCII a silly question, get a silly ANSI-er?
20:23:11 <elliott> @quote shachaf ascii
20:23:11 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
20:23:14 <elliott> hmph.
20:23:24 <elliott> cmccann: it was just "get a silly ANSI"
20:23:30 <shachaf> It's hardly original to me.
20:23:33 <carter> zRecursive closed committees are even worse than open commitee
20:23:33 <zRecursive> johnw: If haskell has ANSI standard, then there will be many compilers for user to choose ?
20:23:39 <carter> zRecursive nope
20:23:41 <shachaf> @google "ascii silly question"
20:23:42 <lambdabot> http://flewellyn.dreamwidth.org/27618.html
20:23:46 <elliott> shachaf: well, you should be used to taking credit for the achievements of others.
20:23:54 <elliott> because you're bad, see.
20:23:55 <carter> zRecursive theres a pretty clear set of semantics for various haskell features
20:24:02 <shachaf> elliott: Is the joke that I'm bad?
20:24:07 <elliott> yes.
20:24:08 <elliott> you got it!
20:24:19 <carter> its merely a question of people wanting to write other compilers and be willing to spend the money / manpower / time to do it
20:24:21 <shachaf> Thanks for clarifying.
20:24:30 <applicative_> bos says "Aarhus syndrome, or template–bonding, is a psychological phenomenon in which hostages express empathy and sympathy and have positive feelings toward C++, sometimes to the point of defending it, and sometimes the feeling of love for the language shows."
20:25:29 <carter> aarhus? heheh
20:25:33 <carter> explain that locatlin?
20:25:35 <carter> *location
20:26:15 <applicative_> the parallel is with the Stockholm syndrome, I suppose Aarhus is where mr c++ whathisname comes from
20:26:23 <cmccann> stroustrup. and yes.
20:26:44 <applicative_> Aarhus is in Denmark. There is a great University there
20:26:50 * zRecursive in fact i wish there is competitors for GHC ...
20:27:09 * geekosaur still has hopes for jhc
20:27:31 <applicative_> really, j meacham does seem to do much haskell anymore
20:27:41 <applicative_> doesnt , rather
20:27:45 <geekosaur> I know :(
20:28:29 <cmccann> applicative_: that must be why he's on the haskell2014 committee.
20:29:17 <kfish> hey m3ga
20:29:34 <m3ga> hey kfish!
20:29:46 <m3ga> kfish: going home tomorrow. really looking forward to it.
20:30:16 <kfish> back to the land of fine craft beer and good coffee?
20:30:29 <amosr> hopefully the weather fines up for you. it's pretty maudlin at the moment
20:31:02 <liyang> Here #haskell, have a read of this: http://grenzgenial.com/post/2414488498/javascript-and-the-brain-why-javascript-is-the-future
20:31:10 <cmccann> no, don't
20:31:13 <cmccann> save yourselves
20:31:16 <cmccann> or
20:31:21 <cmccann> at least get a stiff drink first
20:31:31 <liyang> lolol
20:31:53 <liyang> I felt stupider after reading that.
20:32:06 <cmears> neurons are untyped
20:32:11 <cmears> ...
20:32:27 <cmccann> cmears: it gets worse
20:32:31 <liyang> Can't you see he's being OBJECTIVE?!?
20:32:48 <johnw> that article was either a poorly executed joke, or just really terrible
20:33:10 <cmears> the comments are interesting
20:33:15 <cmears> "The only comparison I can draw between JS and a brain is that JS is slow, error prone and can produce unpredictable outcomes."
20:33:38 <johnw> lol
20:34:02 <johnw> "this is your brain; this is your brain on javascript.  No, wait, your brain is javascript.  No, wait..."
20:34:12 <cmears> not even once!
20:34:16 <liyang> It's blub all the way down...
20:34:57 <carter> and then the recursion causes a medical issue
20:35:02 <carter> wait
20:35:13 <carter> thats a simple proof that the bijection is a lie!
20:35:17 <liyang> JS is a medical issue. :<
20:36:40 <amosr> @hoogle [a] -> Int -> ([a],[a])
20:36:41 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
20:36:41 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
20:36:41 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
21:05:53 * hackagebot hOpenPGP 0.6.2 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-0.6.2 (ClintAdams)
21:38:41 <AfC> It would be more useful if hackagebot would report people's IRC nicks rather than their Hackage usernames.
21:39:01 <Clint> would it?
21:39:11 <shachaf> Clint = ClintAdams?
21:39:21 <Clint> i'm tricky like that
21:39:40 <shachaf> I have a file mapping names <-> nicks
21:39:56 <shachaf> So far it has 142 entries.
21:40:50 <Clint> is this going on my permanent record?
21:41:04 <shachaf> Absolutely.
21:44:01 <dav> all - why am I running out of memory on this given that I'm using foldl' ? => http://paste.debian.net/5911/
21:44:26 <AfC> Clint: you know, "on the internet, everyone can hear you scream"
21:44:34 <shachaf> dav: Maybe you need to be strict in the components of the tuple?
21:44:58 <AfC> Clint: so, nice to see an OpenPGP implementation. Calling out to gpg{,me} is a pain
21:45:10 <shachaf> ?!
21:45:11 <lambdabot> Maybe you meant: . ? @ v
21:45:18 <shachaf> Someone's implementing PGP in pure Haskell?
21:45:34 <AfC> shachaf: ^ ; http://hackage.haskell.org/package/hOpenPGP-0.6.2
21:46:21 <coppro> shachaf: because foldl' still needs to go through the entire list
21:47:41 <shachaf> coppro: ?
21:48:05 <AfC> Clint: some documentation wouldn't be amiss if you want people to be comfortable using the library. (as edwardk has learned :))
21:48:43 <AfC> [unless the delta between 0.6.1 and 0.6.2 is a massive avalanche of haddock comments!]
21:48:58 <shachaf> As with all cryptography libraries, I hope that people aren't comfortable using the library until it's been reviewed by cryptographers and tested for a while.
21:49:23 <AfC> shachaf: indeed
21:49:34 <dav> shachaf: works
21:49:38 <dav> shachaf: thanks
21:50:06 <cmccann> make sure no debian maintainers fix your compiler warnings, either.
21:50:36 <AfC> shachaf: (although there is a chicken-and-egg problem there, so I do my best to encourage early adoption by people who are in a position to take the risk; in this case, with PGP payloads one can probably do serious A/B testing between h and reference versions)
21:50:55 <Chat2786> Hi
21:51:23 <Chat2786> How r u
21:51:28 <AfC> shachaf: (people keep wanting me to use the tls package instead of hopenssl, but the objection you've raised makes it prohibitive)
21:52:03 <shachaf> There is this odd obsession with rewriting cryptography libraries in pure Haskell for actual production use.
21:52:51 <shachaf> I don't think e.g. Ruby people do this sort of thing nearly so much.
21:54:04 <AfC> Admittedly linking against (creating a binding for) gpgme wouldn't be much fun.
21:55:00 <AfC> shachaf: yeah, there is that; there's a strong feeling amongst Haskell programmers that our language allows us to write "more correct" code, and so clearly re-implementing a crypto algorithm will be "better" because of its clear high level description.
21:55:11 <cmccann> shachaf: writing in Haskell lets you use type safety to ensure that all the security holes you create a subtle instead of obvious.
21:55:23 <AfC> cmccann: heh
21:55:37 <cmccann> also because Haskell is math-y, and so is crypto, therefore it's a perfect match.
21:55:48 <shachaf> @remember cmccann writing in Haskell lets you use type safety to ensure that all the security holes you create a subtle instead of obvious.
21:55:48 <lambdabot> It is forever etched in my memory.
21:55:57 <shachaf> Should I re-@remember that with "are" instead of "a"?
21:56:01 <AfC> shachaf: you could have fixed the typo first!
21:56:03 <cmccann> yeah probably
21:56:05 <shachaf> @forget cmccann writing in Haskell lets you use type safety to ensure that all the security holes you create a subtle instead of obvious.
21:56:05 <lambdabot> Done.
21:56:12 <shachaf> @remember cmccann writing in Haskell lets you use type safety to ensure that all the security holes you create are subtle instead of obvious.
21:56:12 <lambdabot> Good to know.
21:56:39 <cmccann> not sure if that makes sense without the context of reimplementing crypto though...
21:56:58 <shachaf> @forget cmccann writing in Haskell lets you use type safety to ensure that all the security holes you create are subtle instead of obvious.
21:56:59 <lambdabot> Done.
21:57:03 <AfC> isn't that the whole point of lanbdabot quotes? To be taken out of context in HWN?
21:57:07 <cmccann> maybe should include your line about "There is this odd obsession..."
21:57:10 <cmccann> I dunno.
21:57:16 <shachaf> @remember cmccann [on reïmplementing cryptography in pure Haskell] writing in Haskell lets you use type safety to ensure that all the security holes you create are subtle instead of obvious.
21:57:16 <lambdabot> Nice!
21:57:27 <shachaf> OK, the ï is excessive. Someone else do this.
21:57:43 <ParahSail1n> goddamn new yorker diaereses
21:57:47 <cmccann> no, I like the umlaut. it's stylish.
21:58:01 <cmccann> very metal.
21:58:08 <AfC> what you really want is the Tolkien-esque triple dot
21:58:13 <shachaf> It's not an umlaut.
21:58:25 <cmccann> close enough.
21:58:46 <AfC> I notice that Clint is studiously ignoring us
21:59:19 <cmccann> maybe he doesn't like fake umlauts.
21:59:24 <joeyh> quote''' is probably far enough (oh and Clint can fix his own compiler warnings)
21:59:48 <dolio> shächäf
22:00:15 <AfC> joeyh: [ah, the pereneal "should you be allowed to package your own software" debate]
22:00:32 <shachaf> dölïö
22:00:42 <shachaf> d̈öl̈ïö
22:00:43 <AfC> Clint: I actually was trying to get to the point of asking you a question.
22:00:45 <joeyh> well hello AfC!
22:01:07 <shachaf> ¨d̈ö̈l̈ïö¨
22:01:13 <gaze__> Say I have a series of "servers" that I've forkIO'ed that are on one end of their own Control.Concurrent.Chan, and I own all these servers... what's the right data structure to contain contain these Chans... how do I sorta persist these channels through the execution of my program?
22:01:22 <dolio> I need to get some dead keys.
22:01:34 <gaze__> there's a fixed number of servers, they all have their own names, and they're all booted at application startup
22:01:35 <AfC> Clint: is there a requirement that hopenpgp be linked to conduit? It seems that the underlying datatypes are agnostic, and that the conduit dependency could be in a separate package (thereby allowing one to use one of the other streaming libraries if appropriate)
22:01:46 <AfC> joeyh: and unto you, well hello
22:01:52 <Aetherspawn> gaze__, If it's to send messages down each induvidual client
22:02:04 <Aetherspawn> I used a single broadcasting TChan since some messages need to go to multiple clients
22:02:09 <Aetherspawn> and the ones that dont need it, ignore it
22:02:13 <shachaf> U+2F972 COMBINING DOLIO ABOVE
22:02:14 <Aetherspawn> but that might not be suitable for you
22:02:55 <gaze__> oh interesting
22:03:02 <cmccann> I wish IRC would let me change my nick to cmccan̈n̈.
22:03:33 <Ralith> 𦈨
22:04:11 <gaze__> I mean certainly that's one way to go about it... but a TChan is more like a mailbox than a queue, yeah?
22:04:19 <shachaf> 2F972   CJK COMPATIBILITY IDEOGRAPH-2F972     [𦈨]
22:04:30 <shachaf> Ralith is such a spoilsport.
22:04:55 <Ralith> \o/
22:05:17 <gaze__> what if I don't know that the servers are gonna eat from this queue all the time? I mean the first way I can think of to do this is to have a StateT Env IO (), w/ data Env = Env { a = Chan (data1), b = Chan (data2), ... }
22:05:19 <danr> gaze__: well it's a mailbox where the messages are ordered as a queue :)
22:05:57 <gaze__> or rather ReaderT
22:06:32 <Aetherspawn> gaze__, if you use newBroadcastWhateverIO
22:06:42 <Aetherspawn> and then for each client dupTChan
22:06:53 <Aetherspawn> then they will recieve messages which they can handle at their own rate
22:06:54 <dav> http://hpaste.org/88377 <= there are some strange things that go on on hpaste..
22:07:07 <Aetherspawn> and they will be deleted when they are no longer referenced by any
22:07:13 <Aetherspawn> (or so, I undersand it. Read the docs)
22:07:30 <gaze__> ahh it is a fifo
22:08:52 <gaze__> wait but no... if a server blocks for some reason, it'll block all the rest of the clients
22:09:00 <gaze__> err. it'll block all the other servers
22:09:11 <gaze__> since they'll never see a message of their form at the head of the queue
22:10:53 <Heffalump> are there any packages that offer type-safe heterogenous maps around? (I asked earlier but got no response, so trying again)
22:11:12 <shachaf> Type-safe how?
22:11:15 <cmccann> Heffalump: with what sort of API?
22:11:31 <cmccann> stuff like that can easily be a pain to work with.
22:11:40 <Heffalump> I'll hpaste, hangon
22:12:30 <NemesisD> anyone see the presentation that got posted today called Haskell in Production from apiengine?
22:12:40 <joeyh> gaze__: it won't block if you dup it. But it might turn into a memory leak
22:13:11 <Aetherspawn> gaze__, once you read it that particular duped channel wont see it again
22:13:20 <Aetherspawn> so read it, check if it applies, discard it ASAP
22:13:49 <Heffalump> http://hpaste.org/88390 - the API is at the top, the insert and lookup functions
22:13:52 <Aetherspawn> It'll only leak if some client socket handler can't decide whether it wants it or not
22:14:01 <Aetherspawn> so just sits there meditating :P
22:14:06 <NemesisD> the presentation talks about haskell libraries like yesod and aeson, but it mentions "Z"
22:14:08 <Heffalump> my implementation uses Typeable but there are probably other options
22:14:11 <joeyh> I have a program much like yours and have been happy with different channels per thread
22:14:18 <NemesisD> i can't tell if tht was a placeholder or if there is some haskell tool called Z. i can't find a packaged named Z
22:14:31 <shachaf> Heffalump: Hmm, have you seen Vault?
22:14:34 <joeyh> for one thing, it leaves you free to have very different data structures, rather than lumping everything together
22:14:41 <cmccann> yeah, was gonna ask about vault
22:14:41 <luite> Heffalump: vault does something like that, but some stuff is in IO to prevent polymorphic keys
22:15:02 <Aetherspawn> joeyh, can you give an example?
22:15:17 <shachaf> elliott has an interesting vault-like API, I think.
22:15:32 <Heffalump> thanks, looking now. Can you elaborate on what you mean by polymorphic keys? I know that there are games you can play with this kind of library to cheat the type system, but I can't think of any obvious flaws with the API I gave
22:15:55 * hackagebot timeplot 1.0.20 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.20 (EugeneKirpichov)
22:16:21 <bos> Heffalump: i happened to see today that you wrote a bunch of papers with damien sereni back in the day
22:17:02 <Heffalump> bos: yeah, a bunch of stuff that all came out of one project we worked on together
22:17:22 <bos> small world
22:17:23 <shachaf> elliott has some interesting ideas related to Keys.
22:17:34 <shachaf> You should ask him when he's online.
22:18:30 <luite> Heffalump: a let me check
22:19:25 <Heffalump> I could probably live with being in IO for my actual use case, but I think not being constrained to IO is a big win in general. Albeit that my implementation uses Typeable and associated types which come with their own costs.
22:19:47 <shachaf> Vault has an ST API too.
22:20:34 <cmccann> IO is only needed to create keys, right?
22:20:48 <shachaf> Right.
22:20:55 * hackagebot wai 1.4.0.1 - Web Application Interface.  http://hackage.haskell.org/package/wai-1.4.0.1 (MichaelSnoyman)
22:20:57 * hackagebot warp 1.3.8.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.8.2 (MichaelSnoyman)
22:21:07 <AfC> How have I not seen timeplot before? That looks pretty cool.
22:22:14 <shachaf> elliott had an alternative API for Typeable that used Keys.
22:22:18 <Heffalump> ok, so it needs IO/ST because the keys come from Data.Unique - my approach is to use Typeable to sort betwee different types of keys
22:22:59 <shachaf> Key is something like a more principled way to do some of the things Typeable does.
22:23:05 <cmccann> shachaf: does elliott have any ideas that aren't potentially terrifying?
22:23:23 <coppro> cmccann: there's always @
22:23:31 <shachaf> elliott: Why don't you upload your files to some semi-persistent place with easy-to-remember URLs, rather than sprunge? :-(
22:23:34 <shachaf> That way I could find them.
22:23:48 <luite> Heffalump: ah right, the goal of vault was to not require the Typeable instance, dunno if that's useful :)
22:24:37 <shachaf> cmccann: I think they're all either terrifying or terrible.
22:24:49 <shachaf> I like his terrifying ideas.
22:24:54 <Heffalump> shachaf: does the ponit about sprunge relate to Keys? I can't find any details of them with google.
22:24:56 <cmccann> ok. that's what I thought.
22:25:17 <shachaf> Heffalump: He put it on an hpaste-style website but it's gone by now.
22:25:40 <cmccann> such a shame.
22:25:50 <cmccann> elliott's terrible ideas really ought to be preserved for posterity.
22:26:21 <Heffalump> if my version isn't already on hackage, I might put it there
22:26:30 <shachaf> Typeable is evil. :-(
22:26:40 <Heffalump> and shortly ubiquitous :-/
22:27:02 <shachaf> It's good for types to be instances of Typeable.
22:27:10 <shachaf> It's the functions with Typeable constraints that I mind.
22:27:26 <cmccann> I wonder how the efficiency compares between vault and Typeable stuff.
22:27:30 <shachaf> @ty Data.Typable.gcast Refl
22:27:32 <lambdabot> Couldn't find qualified module.
22:27:40 <shachaf> @ty Data.Typeable.gcast Refl
22:27:43 <lambdabot> Not in scope: data constructor `Refl'
22:27:49 <shachaf> Cale: Didn't you add Refl?
22:27:52 <shachaf> @undefine
22:27:59 <shachaf> @ty Data.Typeable.gcast Refl
22:28:02 <lambdabot> Not in scope: data constructor `Refl'
22:28:05 <shachaf> Bah.
22:28:43 <Cale> hmm
22:28:53 <Cale> Thought I did
22:28:58 <Cale> Well, I'll add it again
22:29:18 <Cale> @undefine
22:29:23 <Cale> @ty Data.Typeable.gcast Refl
22:29:26 <lambdabot> (Typeable b, Typeable a) => Maybe (Is a b)
22:29:37 <shachaf> You can call Is (==) while we're at it, I guess?
22:29:44 <shachaf> If you have TypeOperators.
22:29:48 <luite> cmccann: TypeReps are relatively efficient to compare, 2x 64 bit word, perhaps a bit slower since it has to come from the dictionary, instead of the integer key in the key record in vault
22:29:56 <shachaf> Though really this isn't much use for lambdabot one-liners.
22:29:59 <cmccann> shachaf: that's Cale's favorite extension, you know.
22:30:09 <shachaf> cmccann: Sure.
22:30:12 <shachaf> Everyone loves it.
22:30:16 <cmccann> yes.
22:30:21 <Cale> ;___; yes, it's my favourite
22:30:33 <shachaf> It has the Elliott-Gibbard seal of approval.
22:31:18 <shachaf> Maybe there was a thing like Key a -> Key b -> p a -> Maybe (p b)
22:31:25 <cmccann> shachaf: that combination of names doesn't make sense.
22:31:45 <shachaf> cmccann: The joke is that Elliott is actually conal.
22:32:03 <cmccann> oh, ok.
22:32:06 <cmccann> carry on then.
22:38:34 <Aetherspawn> I guess the merit of having one channel is that it's higher concurrancy
22:48:43 <stevejb> hello, I am somewhat new to Haskell and I am trying to get the accelerate package working
22:48:55 <stevejb> I got the following error: Setup: At least the following dependencies are missing:
22:48:55 <stevejb> fclabels >=1.0, hashable >=1.1, hashtables >=1.0
22:49:14 <stevejb> I then installed those via cabal install , and that seemed to download and install sufficiently new versions
22:49:25 <stevejb> however, I am getting the same error as before
22:51:13 <stevejb> I did a git clone of the accelerate repo and I am trying to run `runhaskell Setup configure` from the root of that directory
22:51:34 <cmears> stevejb, try "cabal install" in there instead (assuming you want to install it)
22:52:06 <stevejb> cmears: I thought that "cabal install" would download the stable version, whereas in this case I was hoping to get a later version
22:52:26 <cmears> If you do "cabal install" in that directory, it'll install whatever's there
22:52:36 <stevejb> cmears: oh cool, trying that
22:52:37 <cmears> Don't do "cabal install accelerate" though, because that would download it from hackage
22:53:11 <stevejb> great, it seems to be compiling a bunch of accelerate packages
22:53:43 <stevejb> cmears: well, that ended quickly. Perhaps I should get the stable version instead
22:54:04 <cmears> the compilation failed?
22:54:08 <stevejb> yeah
22:54:20 <stevejb> Data/Array/Accelerate/Trafo/Sharing.hs:341:31:
22:54:20 <stevejb>     Type of kind * used as a constraint
22:54:20 <stevejb>     In the type signature for `convertFun':
22:54:20 <stevejb>       convertFun :: Function f r => Bool => f -> Fun () r
22:54:37 <cmears> seems to be working for me... what version of GHC are you using?
22:54:45 <stevejb> 7.4.2
22:54:59 <cmears> ah, maybe that is the reason (I am using 7.6.3)
22:55:19 <stevejb> oh alright, I will try upgrading.
22:55:27 <cmears> good luck (:
22:55:35 <stevejb> thank you
22:57:54 <stevejb> cmears: one quick follow-up question. On linux, would you recommend simply downloading the ghz tar?
22:58:05 <cmears> to upgrade GHC?
22:58:10 <stevejb> yeah
22:58:27 <cmears> I always do it by downloading the source tarball and building it
22:58:50 <stevejb> that seems like a good idea, thanks
23:04:44 <dmwit> No real reason to build it yourself if the binary tar links against libraries you have.
23:05:21 <cmears> I think it was some library mismatch that prompted me to do it from source, then I just kept doing it that way
23:05:21 <dmwit> stevejb: Uh, surely you just meant "Bool ->" instead of "Bool =>"?
23:06:04 <cmears> convertFun :: Function f r => Bool => f -> AST.Fun () r
23:06:08 <cmears> that's the line in the source
23:06:43 <dmwit> That line just looks wrong.
23:06:45 <cmears> it does have a lot of LANGUAGE pragmas
23:06:47 <amosr> there is a lot of magic
23:10:41 <stevejb> dmwit: I just copied the error message
23:10:52 <dmwit> stevejb: I'm saying I believe the source is wrong.
23:10:58 <dmwit> And I'm saying what I believe the fix could be.
23:11:10 <cmears> it builds for me
23:11:23 <dmwit> Not for me. Have you pulled the latest?
23:11:31 <dmwit> I get the same error as stevejb.
23:11:54 <dmwit> After I make the change I suggested, it builds.
23:12:26 <dmwit> (I conclude that cmears is lying... though probably not on purpose.)
23:12:34 <cmears> I think I have the latest (via git)
23:12:36 <cmears> (:
23:13:07 <stevejb> I seem to be on commit  4f95a06203646bed0c2be391c2ab5304e5233b8b
23:13:08 <dmwit> Well, I just did a fresh git clone of AccelerateHS/accelerate about five minutes ago, and I get the same error as stevejb.
23:13:16 <dmwit> Correcting => to -> makes the build succeed.
23:13:35 <dmwit> stevejb: me, too
23:13:37 <stevejb> dmwit: but I would still need a newer GHC right?
23:13:43 <dmwit> stevejb: doubt it
23:13:53 <cmears> it builds for me with -> or =>
23:14:10 <dpwright_> I'm trying to install hakyll with cabal-install, but it's failing to build regex-tdfa-1.1.8
23:14:29 <cmears> even "let f = (id :: Int => Int)" works for me in ghci
23:14:31 <blaenk> anyone have a resource for understanding 'Alternative'
23:14:48 <dmwit> cmears: Perhaps you should report a bug.
23:14:49 <shachaf> Look up resources for understanding MonadPlus, generalize.
23:14:55 <dpwright_> I'm new to haskell, and thus to cabal-install, so I'm not really sure what's causing it
23:14:58 <blaenk> think I found some
23:15:23 <dmwit> cmears: Like, a bug in GHC. =)
23:15:23 <stevejb> dmwit: as soon as ghc finishes compiling I will let you know if I get the same thing
23:15:43 <dmwit> stevejb: ...don't compile GHC
23:15:49 <cmears> dmwit, surely that is not just an accident
23:15:51 <dmwit> just change the "=" to a "-" and go on your merry way...
23:15:51 <dpwright_> I get some other messages about things like -XRecursiveDo being deprecated as well, but they look like warnings so I don't think they're the cause of the error
23:16:00 <dmwit> It'll save you literally hours.
23:16:09 <dmwit> cmears: It is almost certainly just an accident.
23:16:12 <shachaf> Don't compile GHC.
23:16:49 <dpwright_> does anybody have any idea what the problem is?  The output is "regex-tdfa-1.1.8 failed during the building phase. The exception was: ExitFailure 9"
23:17:01 <dmwit> dpwright_: The real error is before that.
23:17:04 <dmwit> whatever it is
23:17:15 <dpwright_> unsafeFreeze deprecated?
23:17:27 <dmwit> ?hpaste the whole output if you can't read it yourself
23:17:28 <lambdabot> Haskell pastebin: http://hpaste.org/
23:17:28 <dpwright_> Deprecated: "Please import from Data.Array.Unsafe instead; This will be removed in the next release"
23:17:31 <dpwright_> ok
23:17:32 <dolio> dmwit: By the way, am I registered? I don't think I got a confirmation of any sort.
23:17:56 <dmwit> If your name is on the Attendees list, you're registered. =)
23:18:00 <dolio> Okay.
23:18:08 <stevejb> dmwit: I have 12 cores and I did a make -j 12 on it. Will it really take that long?
23:18:14 <dmwit> (I think a few people added themselves, but those few happen to be registered anyway.)
23:18:38 * dmwit shrugs at stevejb
23:18:54 <dmwit> Troubleshooting problems can easily take hours, in my experience.
23:19:10 <stevejb> dmwit: good point. Well, I can always download the binary while this is compiling and give that a try
23:19:13 <stevejb> one sec
23:19:15 <dmwit> Also, I have now confirmed: after fixing the obvious error, accelerate builds with GHC 7.4.1 as well.
23:19:50 * dmwit can't really understand why just fixing the error is such a controversial suggestion that stevejb is trying EVERYTHING else possible first
23:20:17 <stevejb> dmwit: trying to fix that error now
23:20:42 <amosr> dmwit: it is weird that it works on 7.6
23:20:49 <dmwit> It does not work on 7.6.
23:20:52 <amosr> oh
23:20:57 <dmwit> At least, it does not work on 7.6.1.
23:21:05 <stevejb> dmwit: I haven't done much Haskell yet
23:21:17 <stevejb> dmwit: you're right, it compiled on 7.4.1 by fixing that one arrow
23:21:41 <dmwit> Bonus points for sending a pull request... ;-)
23:22:20 <shachaf> Or a patch.
23:22:30 <stevejb> dmwit: for one character? :)
23:22:43 <dmwit> Bonus points for informing the maintainer, in whatever manner you find least objectionable.
23:22:55 <dmwit> patch, pull request, "hey you fucked up your arrows" in an email, whatever
23:23:13 <amosr> dmwit: it compiles with 7.6.2
23:23:24 <dmwit> amosr: Crazy. That really sounds like a GHC bug to me.
23:23:54 <cmears> I couldn't see anything in the release notes for GHC that says "you can choose your own arrow style now"
23:24:02 <dmwit> In fact, it's such a blatant one that I wouldn't even be surprised if it were fixed in HEAD already. =P
23:24:07 <stevejb> cmears: dmwit: I really don't know enough Haskell to understand why that is a bug yet
23:24:28 <dmwit> stevejb: ...do you want to?
23:24:36 <stevejb> dmwit: yes!
23:24:39 <dmwit> okay =)
23:24:46 <dmwit> There are types and there are type classes.
23:24:49 <dmwit> They don't really mix.
23:25:05 <dmwit> "=>" separates the type classes that must be available from a type.
23:25:17 <dmwit> "Bool" is a type, not a type class, so it doesn't make sense to put it to the left of a "=>".
23:25:21 <dmwit> ...that's it.
23:25:41 <stevejb> so, `Function f r => Bool -> f -> AST.Fun () r`
23:25:52 <amosr> I'll try on head. if all the dependencies install
23:26:06 <stevejb> that means, function of type bool takes an f and returns aAST.Fun () r
23:26:21 <dmwit> Well, it means:
23:26:22 <cmears> amosr, you can just try using "=>"
23:26:37 <cmears> amosr, as in "let f = (id :: Int => Int)"
23:26:48 <dmwit> "assuming that there's an instance of the type class Function for f and r, this is a function type that takes a Bool and an f and returns an AST.Fun () r"
23:27:28 <dmwit> "a -> b" is the type of functions that take an "a" and return a "b", so...
23:27:28 <stevejb> ah, I see
23:27:37 <blaenk> dmwit: in that, Function f r, is that shorthand for like (Function f, Function r) => ?
23:27:47 <amosr> yes it appears to be fixed in head
23:27:53 <dmwit> "a -> b -> c" is the type of functions that take an "a" and return a function from "b" to "c", OR you can think of that as the type of functions that take an "a" and a "b" aond return a "c"
23:28:03 <stevejb> ah okay, that is currying
23:28:04 <amosr> "Expected a constraint, but Int has kind '*'" :-)
23:28:07 <stevejb> right?
23:28:12 <pqmodn> stevejb: yep
23:28:13 <dmwit> blaenk: No, it's an extension to typeclasses that let them act as relations between types rather than sets of types.
23:28:30 <blaenk> dmwit: o ok
23:28:37 <blaenk> what's the extension called so I can look it up?
23:28:42 <dmwit> MultiParamTypeClasses
23:28:45 <blaenk> thanks
23:28:50 <dmwit> or maybe MultiParameterTypeClasses
23:29:02 <dmwit> GHC is a little bit inconsistent about when it uses abbreviations for its extension names.
23:29:18 <blaenk> first was right, http://www.haskell.org/haskellwiki/Multi-parameter_type_class
23:29:25 <dpwright_> http://hpaste.org/88392 This is the output from my cabal install error
23:30:19 <dmwit> dpwright_: Strange. Is your hard drive full? Do you have write permissions in all the appropriate places? Have you managed to run out of memory?
23:30:20 <dpwright_> I guess regex-tdfa is using some deprecated function and needs to be updated?
23:30:26 <dpwright_> oh, hmmm
23:30:33 <stevejb> dmwit:, cmears: thanks for the help
23:30:49 <dpwright_> the partition my home directory is in is quite full
23:30:58 <cmears> you're welcome
23:31:04 <dpwright_> actually
23:32:58 <dmwit> amosr: good stuff =)
23:34:26 <blaenk> @hoogle <>
23:34:26 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
23:34:26 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
23:34:26 <lambdabot> Text.PrettyPrint (<>) :: Doc -> Doc -> Doc
23:34:42 <dmwit> It's also in Data.Monoid, if your Data.Monoid is modern enough.
23:34:53 <blaenk> yeah! that's what I was looking for, thanks :D
23:35:09 <blaenk> o ok infix synonym for mappend
23:35:09 <startling> (it's mappend)
23:35:10 <blaenk> cool
23:35:12 <blaenk> :D
23:35:19 <blaenk> thought so but wanted to make sure
23:35:24 <dmwit> yep
23:36:26 <dpwright_> I tried moving ~/.ghc and ~/.cabal to a different partition and symlinking them... broke in exactly the same way
23:36:59 <dpwright_> dmwit: Are there any other appropriate places I should be checking write permissions apart from those two folders?
23:40:37 <pqmodn> dpwright_: could you be running out of RAM?
23:41:46 <pqmodn> dpwright_: if you're on linux you might check the output of dmesg to see if kernel killed ghc for requesting too much memory
23:42:56 <dpwright_> pqmodn: I guess that's possible... I am running this on a linode which only has like 512MB RAM I think.
23:43:06 <pqmodn> dpwright_: yep, just found this http://www.haskell.org/pipermail/beginners/2011-April/006806.html
23:43:09 <dpwright_> ah, ok... I just watched top while running it and that looks quite likely
23:43:30 <dpwright_> yeah, "Out of memory: Kill process 11618 (ghc) score 437 or sacrifice child"
23:43:36 <pqmodn> dpwright_: you can create a swap file and mount it temporarily
23:43:59 <dpwright_> pqmodn: Great, I'll try that -- thanks!
23:44:07 <bos> dpwright_: also, linode has a nice habit of causing ghc to crash mysteriously.
23:44:34 <bos> i gave up on linode for haskell work because the compiler would simply crash at random.
23:45:29 <dpwright_> bos: Oh dear, that's a shame
23:45:54 <dpwright_> I guess I'll have to see how it goes :-/
23:46:39 <hrookie> So, i've got two records which are quite similar in nature, and i want to perform similar types of operations on them, but one record is slightly different than the first. Coming at this from OO, I want to tackle the problem with inheritance and just overriding and augmenting a couple fields. Is there a best-practice for this in haskell?
23:48:17 <blaenk> type class? I don't know, that 'similar operations on different types' reminds me of type classes, like Functor and fmap, but maybe I misunderstood your question
23:50:21 <pqmodn> hrookie: perhaps the common things could be factored into a single constructor. eg Person { first :: String, last :: String, phone :: Phone, email :: Email } | Company { name :: String, phone :: Phone, email :: email } could become Person { first :: String, last :: String, contact :: Contact } | Company { name :: String, contact :: Contact }
23:51:09 <pqmodn> hrookie: assuming the operation you wanted to perform was on the phone and email fields (nevermind my example above is invalid)
23:51:35 <hrookie> pqmodn: well, one field i want to explicilty overwrite, and i want to augment like two fields
23:52:26 <hrookie> pqmodn: having two different constructors so one field is exchange seems like overkill, but i can't really find any better solution
23:52:49 <hrookie> pqmodn: also, is there an edeq1modn?
23:52:53 <pqmodn> hrookie: you'll probably get better answers if you can upload an example to hpaste
23:53:07 <pqmodn> hrookie: i don't know of one :)
23:53:33 <hrookie> brb forgot to launch tmux, i'll hpaste
