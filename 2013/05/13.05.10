00:00:39 <hpaste> lpvb pasted “Folding Config options” at http://hpaste.org/87647
00:00:42 <lpvb> can anyone help me figure this out
00:02:27 <dmwit> Perhaps you will enjoy
00:02:39 <dmwit> Test <$> getn "field1" <*> getn "field2" <*> getn "field3"
00:03:01 <dmwit> As you say, asking for this to work as a fold is hopeless.
00:03:11 <lpvb> but then I have to keep listing getn for every argument to Test
00:03:17 <dmwit> correct
00:03:22 <Nisstyre-laptop> Does anyone know if the library monad-loops is being maintained? This function results in an infinite loop: http://ideone.com/KPX2C5
00:03:28 <Nisstyre-laptop> I'm pretty damn sure it should work
00:03:31 <lpvb> so there's no way around this tediousness?
00:04:08 <dmwit> You could declare a class which had instances for Test and (a -> b).
00:04:10 <Nisstyre-laptop> if I do "test' 0 []" it works
00:04:12 <dmwit> Not much else, though.
00:04:37 <jocolloman> Nisstyre-laptop: Which version of ghc are you using. Also, is it an infinite loop in ghci or when compiled with ghc?
00:05:41 <jocolloman> Nisstyre-laptop: I've had infinite loop problems in ghci with 7.4.2
00:06:03 <jocolloman> Nisstyre-laptop: That were non-issues when compiled
00:06:10 <bartavelle> is my "cabal upload" supposed to hang forever ? the new version seems to be on hackage, but there were no notifications here
00:06:33 <Nisstyre-laptop> jocolloman: ghci, I'll try compiling it
00:06:43 <Nisstyre-laptop> also 7.6.3
00:06:59 <lpvb> dmwit: could I do Test <$> (foldl1 <*> (map getn ["field1","field2","field3"])) ?
00:07:13 <dmwit> no
00:07:15 <jocolloman> Nisstyre-laptop: The looping issues in ghci went away for me when I started using 7.6
00:07:21 <lpvb> same problem?
00:07:51 <Nisstyre-laptop> jocolloman: I just get an error about a stack overflow
00:08:12 <Nisstyre-laptop> I think it's something the function is doing
00:08:18 <Nisstyre-laptop> I have no idea what though
00:08:23 <Nisstyre-laptop> http://hackage.haskell.org/packages/archive/monad-loops/latest/doc/html/src/Control-Monad-Loops.html
00:08:33 <jocolloman> Nisstyre-laptop: Okay. I will look at it a bit more. I'm not familiar with the monad-loops package
00:11:32 * hackagebot hslogstash 0.2.3.1 - A library to work with, or as, a logstash server  http://hackage.haskell.org/package/hslogstash-0.2.3.1 (SimonMarechal)
00:11:34 * hackagebot webserver 0.7.1.0 - HTTP server library  http://hackage.haskell.org/package/webserver-0.7.1.0 (JohnLato)
00:20:35 <jocolloman> Nisstyre-laptop: I think there is a bug. Does this produce the result you want? http://hpaste.org/87649
00:22:50 <Nisstyre-laptop> jocolloman: yes
00:23:00 <Nisstyre-laptop> yeah I thought there must be a bug
00:23:30 <Nisstyre-laptop> jocolloman: this is what I was trying to simplify, btw http://ideone.com/aeycmA
00:23:46 <Nisstyre-laptop> maybe there is a better way of doing that than unfoldrM anyway
00:23:49 <jocolloman> Nisstyre-laptop: It doesn't look like there has been an update to the package in awhile. I will fork a copy and submit a fix and hopefully it will get pushed relatively soon.
00:24:28 <Nisstyre-laptop> jocolloman: cool, thanks
00:27:25 <jocolloman> Nisstyre-laptop: The bug is actually fixed in the latest version: https://github.com/mokus0/monad-loops
00:27:30 <Nisstyre-laptop> ah okay
00:27:33 <jocolloman> Nisstyre-laptop: It just has not been pushed to hackage
00:27:56 <jocolloman> Nisstyre-laptop: If you clone that repository, you should be able to type "cabal install" from the directory to use the latest version
00:28:08 <Nisstyre-laptop> sweet, thanks
00:28:54 <jocolloman> Nisstyre-laptop: Also, I'll ping the owner to see if he will push the latest version to hackage.
01:34:00 <hpaste> “Dharmender Kumar” pasted “HR consultants offer in delhi” at http://hpaste.org/87653
01:35:36 <lpsmith> fun, hpaste spam
01:36:00 <Kinnison> lulz
01:36:06 <Botje> reported as spam
01:36:29 <quchen> Reported as not obeying the 80 char limit
01:37:22 <Kinnison> If only hpastebot could make it so that you needed a token from IRC in order to paste
01:37:40 <quchen> I should found a startup that consults spammers. I'd make sure they don't misspell words, use too much caps etc.
01:38:08 <quchen> That would probably boost their success considerably
01:38:10 <flux> you could call it Gourmet Spam
01:38:27 <flux> +Consulting
01:38:32 <Cale> There's been so much hpaste spam lately
01:38:54 <Cale> Every once in a while I try to go through and delete things, but it's a big hassle
01:39:10 <Cale> (you can basically only delete them one at a time)
01:39:14 <quchen> That doesn't fix the issue anyway
01:39:34 <flux> it should work like this: hpaste, spam
01:40:02 <quchen> Cale: You're not involved in hosting HPaste are you?
01:40:04 <Botje> or even /msg hpaste that was spam, dude.
01:40:07 <lpsmith> Hey,  is there alternative solutions to the ST monad, beyond phantom types and rank-2 polymorphism?
01:40:16 <Cale> no, I'm not
01:41:38 <lpsmith> With my new inotify bindings,  I'm wondering if there is a way to ensure that watch descriptors are only operated on their corresponding inotify descriptors
01:42:20 <lpsmith> i.e. when you want to watch a file or directory for changes,  the kernel passes back a watch descriptor associated with the inotify descriptor to stop watching that file.
01:43:12 <lpsmith> It's a similar problem as ensuring that STRefs are only used within a single ST computation,  but there isn't any runInotify here.
01:48:16 <lpsmith> intuitively,  if GHC supported true existential types,  it seems like I might be able to use those.    e.g.  Inotify.init :: exists a. IO (Inotify a);    addWatch :: Inotify a -> FilePath -> IO (Watch a),    rmWatch :: Inotify a -> Watch a -> IO ()
01:50:12 <mauke> Inotify.init :: (forall a. Inotify a -> IO r) -> IO r
01:51:35 <doomlord> anyone know off hand how to get the limits of a type
01:51:49 <Eduard_Munteanu> :t minBound
01:51:51 <lambdabot> Bounded a => a
01:51:54 <Eduard_Munteanu> :t maxBound
01:51:56 <lambdabot> Bounded a => a
01:51:59 <doomlord> thanks
01:53:28 <lpsmith> mauke, but I don't want to constrain the scope of the Inotify descriptor;  I want to let it escape the callback init is using.
01:55:04 <no-n> @src ($)
01:55:04 <lambdabot> f $ x = f x
01:55:08 <no-n> @src (.)
01:55:08 <lambdabot> (f . g) x = f (g x)
01:55:08 <lambdabot> NB: In lambdabot,  (.) = fmap
01:56:58 <johnw> :t (.)
01:57:02 <lambdabot> (b -> c) -> (a -> b) -> a -> c
01:57:05 <johnw> that note is no longer true
01:57:30 <no-n> what note?
01:57:37 <johnw> <lambdabot> NB: In lambdabot,  (.) = fmap
01:57:44 <no-n> ah
01:57:51 <mauke> > succ . "a"
01:57:55 <lambdabot>   Couldn't match expected type `a0 -> c0'
01:57:55 <lambdabot>              with actual type `[GHC...
01:59:53 <doomlord> how do you distinguish negative float literal from partial application with -
02:00:07 <mauke> easy, there are no negative literals
02:00:12 <doomlord> hah
02:00:28 <mauke> and (- foo) is always unary minus
02:00:34 <mauke> this is a terrible hack in the grammar
02:01:21 <mm_freak> (-x) is the same as 'negate x'
02:01:50 <doomlord> (- 1.0::Float)  seems to work
02:02:02 <mm_freak> although in actual implementation when used together with a literal it's more likely to get interpreted as the negative Integer it represents directly
02:02:08 <mauke> > (- 1.0)
02:02:11 <lambdabot>   -1.0
02:02:30 <mauke> why limit yourself to floats, though?
02:02:31 <mm_freak> doomlord: mauke was just a bit sarcastic about the weird grammar rule for negation
02:02:33 <mauke> > (- 1)
02:02:39 <lambdabot>   mueval: ExitFailure 1
02:02:39 <lambdabot>  mueval: Prelude.undefined
02:02:43 <mauke> ಠ_ಠ
02:02:54 <mauke> mm_freak: was I?
02:02:57 <doomlord> let me see what i''m doing, i ahve another error clouding
02:03:36 <mm_freak> mauke: i think so
02:04:13 <mauke> I disagree!
02:05:27 <mm_freak> mauke: my apologies
02:06:24 <doomlord> is it normal that i have to instance Bounded Float myself, or am i missing an import
02:06:45 <mm_freak> doomlord: it's not normal…  likely you're missing a type signature
02:06:51 <mm_freak> > minBound :: Float
02:06:54 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Float)
02:06:54 <lambdabot>    arising from a use of...
02:06:59 <mm_freak> correction
02:07:02 <mm_freak> it's normal =)
02:07:23 <mm_freak> you can construct the minimum number yourself by using RealFloat
02:07:32 <mauke> spoilers: it's -Inf
02:07:38 <doomlord> hmm... but wouldn't the instanece in the libraries be what actually provides those literals
02:07:49 <mm_freak> you can construct the minimum finite number yourself by using RealFloat
02:07:50 <johnw> i wouldn't really mind if there is no prefix - operator
02:07:52 <doomlord> -Inf works for any type? should i just use that instead?
02:07:59 <mm_freak> johnw: i agree
02:08:04 <mauke> doomlord: -Inf doesn't work for any type
02:08:15 <johnw> I can always say 0-x if I want to
02:08:18 <mauke> doomlord: what are you trying to do?
02:08:25 <mm_freak> johnw: negate x
02:08:31 <johnw> well, more letters
02:08:34 <johnw> adding a 0 is just one
02:08:47 <mm_freak> for the base types that's probably fine
02:08:54 <johnw> ah, good point
02:09:04 <johnw> i'm fine with negate too
02:09:05 <mm_freak> for some types you may give up quite some performance
02:09:05 <doomlord> find the minimum of a list... (foldl  (min) (input value)  (list))
02:09:31 <mauke> doomlord: use 'minimum'
02:09:56 <johnw> > foldl1 min [2,3,1,4]
02:09:59 <lambdabot>   1
02:10:09 <johnw> > minimum [2,3,1,4]
02:10:14 <lambdabot>   1
02:10:15 <mm_freak> there is one case where using foldl' instead of minimum may be reasonable
02:10:30 <doomlord> whats bit more detial - sorry its not scalars, its my own vector type going in there
02:10:55 <mm_freak> doomlord: minimumBy
02:11:03 <doomlord> createExtents....    where    vmin=(foldl (vecMin) (vecSplat FLT_MIN) srcVectorList) ...
02:11:20 <doomlord> FLT_MIN.. is what i'd have for floats in C, i'm using 'minBound' now
02:11:34 <doomlord> and oops, its max not min there lol
02:11:57 <doomlord> i suppose i could use the first element of the list and pattern match the empty list to do something else
02:12:23 <doomlord> but it would be good to know if this is possible
02:12:26 <mm_freak> > let sqMag (a, b) = a^2 + b^2 in minimumBy (comparing sqMag) [(1, 2), (2, 3), (1, 3), (3, 1)]
02:12:28 <lambdabot>   (1,2)
02:12:36 <mauke> FLT_MIN isn't even the smallest possible float
02:12:41 <mm_freak> > let sqMag (a, b) = a^2 + b^2 in maximumBy (comparing sqMag) [(1, 2), (2, 3), (1, 3), (3, 1)]
02:12:45 <lambdabot>   (2,3)
02:12:48 <doomlord> i need +/-FLT_MAX actually
02:12:52 <doomlord> not FLT_MIN sorry
02:12:59 <mauke> FLT_MAX < Inf
02:13:14 <mm_freak> > 1/0
02:13:16 <lambdabot>   Infinity
02:13:19 <doomlord> do i have the wrong idea about comparing with infinity...
02:13:29 <doomlord> it doesn't usually go well...
02:13:32 <doomlord> QNAN
02:13:41 <mm_freak> Float doesn't usually go well
02:14:28 <doomlord> ok , i''m feeding the first list element instaead, and making a seperate case for empty list.. is that a hack or cop out?
02:14:33 <mauke> comparing with infinity works fine
02:14:43 <mauke> doomlord: it's what 'minimum' does
02:14:53 <doomlord> its a custom type in the list though
02:14:55 <mr-> mm_freak: comparing! You saved me from my maximumBy (\x y -> sqMag x `compare` sqMag y) - foolishness!
02:14:57 <mauke> except the "separate case" just dies
02:15:02 <mauke> doomlord: ... so?
02:15:10 <mauke> 'minimum' is polymorphic
02:15:13 <mm_freak> doomlord: of your type doesn't have a sensible Ord instance use minimumBy
02:15:19 <mm_freak> or maximumBy or whatever
02:15:33 <mm_freak> mr-: =)
02:15:41 <doomlord> should i instance 'minimum' for it; the type is data Vec3 a =Vec3{  x::a,y::a,z::a}
02:15:50 <doomlord> v3x::a v3y::a v3z::a
02:16:00 <mm_freak> doomlord: minimum is predefined for Ord types
02:16:06 <mm_freak> you don't have to write it
02:16:15 <doomlord> ok but this is a vector with named elements
02:16:21 <mm_freak> doomlord: so?
02:16:29 <doomlord> its a list-of-vectors
02:16:30 <mm_freak> can they be sensibly ordered?
02:16:45 <doomlord> it wants a componentwise min operation
02:17:01 <doomlord> this is for calculating bounding box of a cluster of points
02:17:07 <doomlord> AABB
02:17:07 <mm_freak> doomlord: you are new to haskell, aren't you? =)
02:17:11 <doomlord> yes , very
02:17:22 <doomlord> ive just started hacking around again after leaving it for a while
02:17:22 <mauke> ah, so vminimum xs may not actually be an element of xs
02:17:31 <mm_freak> doomlord: the idea is this:  there is a type class Ord for types that have some kind of order
02:17:42 <mm_freak> like greater-than-or-equal for Doubles
02:17:45 <pxqr`> Where is something like bracket :: (Monad m, ?) => m a -> m b -> (a -> m c) -> m c
02:17:47 <doomlord> right i thought that is really for scalars
02:18:02 <mauke> doomlord: there are no scalars
02:18:09 <doomlord> if you want a (>) a->a->bool
02:18:11 <mm_freak> pxqr`: Control.Exception?  although the type is slightly more sensible
02:18:17 <mm_freak> :t bracket
02:18:18 <doomlord> that makes no sense for x y z componnets IMO
02:18:19 <lambdabot>     Not in scope: `bracket'
02:18:19 <lambdabot>     Perhaps you meant one of these:
02:18:19 <lambdabot>       `brackets' (imported from Text.PrettyPrint.HughesPJ),
02:18:30 <mm_freak> pxqr`: however, 'bracket' is for IO
02:18:34 <doomlord> (1.0,0.0,0.0) > (0.0, 1.0, 0.0)  ... no sense
02:18:40 <mm_freak> if you need something more general, look into the monad-control package
02:18:48 <doomlord> the result is (true,false,false)
02:18:54 <mauke> doomlord: makes sense for lexical comparisons
02:18:54 <doomlord> its componentwise
02:18:55 <pxqr`> mm_freak: yes, I have to look it
02:19:00 <johnw> mm_freak: pointing him to lifted-base would be much easier
02:19:08 <mm_freak> johnw: probably
02:19:10 <johnw> doing it with monad-control is doing it the hard way
02:19:12 <doomlord> shall i paste ?
02:19:22 <mauke> doomlord: no, why?
02:19:28 <mm_freak> johnw: you are doing it with monad-control when you use lifted-base ;)
02:19:30 <johnw> (and the lifted-base author wrote monad-control, so he knows what you want :)
02:19:47 <johnw> i rarely use plain Control.Exception anymore
02:20:03 <doomlord> can you clarify whats a lexical comparison - at the minute i dont perceive ORd makes sensee for calculating the bounding box of a series of 3d points
02:20:10 <mm_freak> i tend to use Control.Exception where possible
02:20:17 <mauke> doomlord: it doesn't
02:20:18 <doomlord> i thought Ord is for linear comparison of scalars
02:20:20 <johnw> mm_freak: is it faster?
02:20:34 <doomlord> i can see you can order strings aswell... but thats not right for x,y,z components
02:20:34 <mm_freak> doomlord: no, it's for any order you want for your type
02:20:38 <johnw> doomlord: http://en.wikipedia.org/wiki/Lexicographical_order
02:20:40 <mauke> doomlord: you're kind of stuck in seeing everything as numbers or vectors
02:20:52 <mm_freak> doomlord: you define a function 'compare' for your type
02:20:57 <mm_freak> as part of the Ord instance
02:21:11 <doomlord> ok in your picture of ord, whats (1.0, 0.0, 0.0) > (0.0,1.0,0.0)
02:21:13 <mm_freak> it takes two values of your type and tells which one is "larger" in whatever sense you want
02:21:22 <doomlord> i think that is (true,false,flase)
02:21:27 <mm_freak> doomlord: that's up to you…  /you/ define the order!
02:21:39 <mauke> > (1.0, 0.0, 0.0) > (0.0,1.0,0.0)
02:21:41 <lambdabot>   True
02:21:43 <pxqr`> indeed, lifted-base is that i need. thanks.
02:21:45 <doomlord> but there is no order. i need to know the max & min of each axis independantly, to make a bounding box
02:21:54 <mauke> doomlord: you're arguing about nothing
02:22:04 <doomlord> i have a list of points in 3D space. i want to find a bounding box around it
02:22:05 <johnw> doomlord: then < isn't what you want
02:22:09 <magicman> If there is no order, don't use Ord <_<
02:22:17 <doomlord> ***BINGO!!!***
02:22:23 <mm_freak> doomlord: that's no problem…  minimum . map x
02:22:28 <doomlord> i've mad "vecMin" similar to SIMD vec min
02:22:29 <mauke> mm_freak: wat
02:22:51 <magicman> (except possibly for keys in Map, but that can be an arbitrary order, so lexicographic order works)
02:23:04 <doomlord> componentwise.... vecMin (x0,y0,z0) (x1,y1,z1) = (Vec3 (min x0 y0),(min y0 y1)(min z0 z1))
02:23:05 <mm_freak> doomlord: you have a list of points…  map your 'x' over it
02:23:16 <doomlord> oh you suggest SOA..
02:23:27 <mm_freak> > map fst $ [(1, 2), (2, 3), (1, 4), (4, 3)]
02:23:29 <lambdabot>   [1,2,1,4]
02:23:31 <mm_freak> then use the minimum on that
02:23:35 <mm_freak> > minimum . map fst $ [(1, 2), (2, 3), (1, 4), (4, 3)]
02:23:38 <lambdabot>   1
02:23:48 <mm_freak> similarly for the max bound of your box
02:23:52 <mauke> ah
02:23:54 <mm_freak> > maximum . map fst $ [(1, 2), (2, 3), (1, 4), (4, 3)]
02:23:55 <doomlord> Vec3(minimum (map x srcList) minimum (map y srcList) minimum (map z srcList) )
02:23:56 <lambdabot>   4
02:24:34 <doomlord> ok i can see that would work, however i've already got vecMin,vecMax coming out of my typeclasses for vec2,vec3,vec4
02:24:50 <doomlord> and i'm making an "extents" (aka Bounding Box) type / typeclass
02:25:01 <doomlord> ^ with associated operations like comparing for overlap, containment
02:25:06 <quchen_> Why isn't Complex an instance of Ord? It can be total ordered after all, for example by first comparing real, then imaginary parts. It is not an ordered field, but that's not something Ord is concerned about.
02:25:58 <doomlord> i for one want > on vectors to return a componentwise bool - like happens in SIMD registers
02:26:07 <doomlord> vectors as in xyz
02:26:12 <mm_freak> doomlord: you're familiar…  did you ask this earlier?
02:26:34 <johnw> does Ord require a total order?  or just strict weak?
02:26:38 <mm_freak> (not meant as an offense, btw)
02:27:01 <mm_freak> johnw: i think that's not defined
02:27:03 <johnw> doomlord: map (>)
02:27:04 <Eduard_Munteanu> johnw: a decidable total order
02:27:10 <doomlord> i'm defining my own function names for this - but i would want to implement > like that for my custom types
02:27:11 <johnw> err, zipWith
02:27:21 <Eduard_Munteanu> Well, (<) is partial if not defined for all inputs.
02:27:54 <mm_freak> doomlord: could you tell in words what < should mean for your type?
02:27:55 <doomlord> i realise you can do vector maths very elegantly with zip map etc on a [a] ... but i want to go through the process of making a fixed datastrcuture taht i know is 4elements or wahtever
02:28:15 <mm_freak> doomlord: you should look into the 'linear' package
02:28:18 <doomlord> it should compare each component, and return a "select mask" - a vector of bools
02:28:32 <doomlord> i realise everything i'm triying to do is probably in the packages...
02:28:38 <mm_freak> hehe yeah
02:28:40 <int-e> Eduard_Munteanu: there are two conflicting meanings of "partial" here. A partial order may have elements a,b such that neither a < b not a = b not b < a.
02:28:40 <mm_freak> quite possibly
02:28:42 <doomlord> .... but if I can't write this myself, i will give up on the langauge
02:28:50 <doomlord> i wont feel i know it
02:29:06 <mm_freak> doomlord: i see…  well, go ahead
02:29:21 <doomlord> i can't have unknown magic for basic things ... otherwise how am i going to do anything complex :)
02:29:25 <johnw> Eduard_Munteanu: the notes in http://hackage.haskell.org/packages/archive/logfloat/0.12.1/doc/html/Data-Number-PartialOrd.html relate
02:29:58 <johnw> and the docs for Ord mention that it's for total orders
02:30:32 <mm_freak> doomlord: well, rethink your type…  you seem to be stuck with floats/doubles/whatever you hardcode
02:30:32 <johnw> cool, I never knew about Down
02:31:12 <doomlord> its not hardcoded right now, but its being driven of float literals ; its (Num a)=>Vec3 a ...
02:31:33 <doomlord> i'm just saying floats because thats what i'm inputing and i'm trying to abreviate to explain
02:31:41 <mm_freak> doomlord: great…  then you can think more algebraically about your type
02:31:47 <mm_freak> it's a functor, so you get map
02:31:54 <mm_freak> it's also applicative, so you get zipWith
02:32:02 <mm_freak> try to define an Applicative instance for your type
02:32:04 <doomlord> i have a c++ brain , i gathe functor means soething else here...
02:32:08 <mm_freak> then liftA2 will turn out to be zipWith
02:32:32 <mm_freak> doomlord: nothing wrong with that, just keep in mind that haskell uses the categorical notions of these things
02:32:56 <johnw> doomlord: we do use the word functor to mean the mathematical definition, not what C++ uses it for
02:33:01 <mm_freak> so simply put for programmers, a functor F lifts (a -> b) to (F a -> F b)
02:33:05 <mm_freak> in your case F = Vec3
02:33:26 <mm_freak> :t fmap
02:33:28 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:33:43 <doomlord> i'll need to work through examples to see what the implications of that are.
02:33:52 <doomlord> i know of map on collections :)
02:34:02 <mm_freak> doomlord: the implication is that you get a mapping function that is in a very strong sense "sensible"
02:34:08 <mm_freak> > fmap (^2) [1..10]
02:34:10 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
02:34:17 <doomlord> fmap...functor...lift...  i *have* encountered monads but am no  expert..
02:34:27 <mm_freak> nothing to do with monads here =)
02:34:53 <mm_freak> you may a weaker form of Functor as whatever you get in a java-like language for mapping…  IEnumerable or whatever
02:35:01 <mm_freak> + know
02:35:25 <Cale> doomlord: Basically a functor is some kind of structure parameterised by a type and to which you can apply a function to all of the elements of that type in it (if you're thinking of it as a container of some sort), or to the results of the computation that it represents (if you're thinking about it that way instead)
02:36:09 <Cale> (Really, this is an endofunctor on the category of Haskell types, rather than a functor generally)
02:36:41 * hackagebot haskdogs 0.3.1 - Generate ctags file for haskell project directory and it's deps  http://hackage.haskell.org/package/haskdogs-0.3.1 (SergeyMironov)
02:36:43 <mm_freak> doomlord: Cale's explanation is great, but feel free to ignore the second part in parentheses for now =)
02:37:15 <Cale> It consists of a mapping from types to types, F, and for each function f :: A -> B, it assigns some function fmap f :: F A -> F B
02:37:17 <doomlord> ok i got what i want by what i consider a little hack,
02:37:25 <johnw> functor are deserving of much contemplation, since just thinking of them as "something that gives you a sensible map" is to selling them far too short
02:37:38 <doomlord> createExtents ::[] = ....    createExtents:: vecList = .....
02:37:57 <mm_freak> doomlord: really you shouldn't start with hacks…  try to understand functors, they are both very important and very simple
02:38:05 <Cale> johnw: Well, once you're allowed to think about other categories, I agree :)
02:38:14 <doomlord> i've added a case for the empty list, and insted of feeding in my numeric FLT_MAX/-FLT_MAX to "clear" extents, i do it manually
02:39:32 <mm_freak> johnw: i don't mean 'map' in the list sense, but in the sense of embedding pure functions
02:39:44 <mm_freak> and that's fine for haskell's endofunctor-on-hask-in-disguise
02:39:52 <johnw> ah, like lifting, except that lift means something else
02:39:58 <johnw> (in Haskell)
02:40:19 <doomlord> http://pastebin.com/13WBQXhZ <<< so here;'s my code for computing a bounding box given a "v a" (v = Vec2,Vec3,Vec4...)
02:40:31 <mauke> The paste 13WBQXhZ has been copied to http://hpaste.org/87656
02:40:37 <doomlord> ^^^ createExtents
02:41:11 <doomlord> i didn't paste my  data Extents v a = Extents { eMin::v a ,eMax:: v a}
02:41:22 <doomlord> Extents AKA AxisAlignedBoundingBox
02:41:57 <mm_freak> doomlord: minor style note:  foldl (f) (xs !! 0) = foldl f (head xs)
02:42:13 <doomlord> oh tahts much nicer thanks
02:42:36 <doomlord> head  and 'rest' i presume?
02:42:43 <johnw> tail
02:43:31 <doomlord> i still get this feeling of clunkines with records, but i gather destructuring could avoid me even needing to name elements
02:43:58 <doomlord> eg i've made  Vec2 { v2x, v2y}  Vec3 { v3x,v3y}.. etc which feels really clunky compared to C++
02:44:48 <mm_freak> doomlord: the clunkiness can be fixed, but you will get there
02:45:15 <doomlord> once i have the vector maths functoins i'd rarely use the components anyway
02:45:16 <quchen_> doomlord: http://s3.amazonaws.com/lyah/listmonster.png
02:45:25 <mm_freak> record syntax is quite powerful, and later someone will tell you to learn lenses =)
02:45:48 <johnw> mm_freak: what do you think of vinyl?
02:45:52 <mm_freak> doomlord: the point is that you can get along without any kind of type class here
02:45:58 <mm_freak> johnw: vinyl?
02:46:03 <johnw> extensible records
02:46:09 <mm_freak> that hugs stuff?
02:46:16 <doomlord> extensible records?
02:46:20 <johnw> http://www.jonmsterling.com/posts/2013-04-06-vinyl-modern-records-for-haskell.html
02:46:30 <doomlord> i posted a suggestion a very long time ago about single inheritance :)
02:46:43 <doomlord> i made the analogy with offset equates in Assembler :)
02:47:16 <doomlord> maybe "extensible records" is what i wanted
02:47:29 <johnw> i would really hate inheritance.  There is a certain satisfaction that comes from knowing that a function which is not polymorphic in a given type will only receive values of that type.  If I wanted restricted polymorphism, I'd use a type class
02:47:58 <doomlord> http://pastebin.com/XGSGUf7m <<< this is the current state of my 'vector maths library in haskell'...
02:48:13 <mauke> The paste XGSGUf7m has been copied to http://hpaste.org/87657
02:48:27 <mm_freak> doomlord: no, it's not =)
02:48:38 <mm_freak> what you want is to learn functors and applicative functors
02:48:54 <doomlord> that would make this easier?
02:48:57 <mm_freak> a lot
02:49:12 <mm_freak> you can work with vectors without caring at all about their underlying structure
02:49:44 <doomlord> just to clarify, you know i mean x/y/z and not std::vector.  (you can of course implement this as std::array<float,3> say in C++
02:49:59 <mm_freak> doomlord: yes
02:50:06 <doomlord> class Vec3f : std::array<float,3> { .... }   .... would it be anything like that..
02:50:10 <mm_freak> you mean vectors in the linear algebra sense
02:50:14 <magicman> From a first glance, most methods of VecOps that don't have a default are actually Applicative methods in disguise.
02:50:24 <mm_freak> magicman: exactly
02:50:54 <doomlord> so i'm re-inventing a pattern with the wrong names
02:50:55 <doomlord> ?
02:51:12 <mm_freak> doomlord: no, right now you're simply not seeing the pattern =)
02:51:31 <doomlord> what can be factored out that i haven't already
02:51:41 <mm_freak> doomlord: the applicative functor pattern
02:52:17 <doomlord> can you see how i've built up to things like "vecPerp" (return one vector perpendicularized to an axis)
02:52:31 <magicman> For vecUnaryOp and vecBinaryOp, you could relax the types to (a -> b) -> v a -> v b. This is exactly fmap from Functor.
02:52:50 <magicman> And (a -> b -> c) -> v a -> v b -> v c, which corresponds to a function in Applicative.
02:53:25 <mm_freak> doomlord: let me point out that applicative functors are definitely not something you know from C++
02:53:41 <johnw> that's for certain
02:53:56 <mm_freak> the pattern gives you an extremely general zipWith with which you can express about any vector operation you may be thinking of
02:54:05 <mm_freak> "vector" as in linear algebra vectors
02:54:24 <doomlord> so i'd say vecAdd a b= zipWith (+) a b  ?
02:54:30 <doomlord> so i'd say vecAdd a b= fmap (+) a b  ?
02:54:30 <johnw> I never knew that mapMaybe = catMaybes . map
02:54:37 <johnw> thank you, hlint
02:54:43 <mm_freak> doomlord: well, you would say vecAdd = liftA2 (+)
02:54:59 <doomlord> ah.
02:55:09 <doomlord> A2 ... 2 arguemnts by any chance?
02:55:22 <mm_freak> doomlord: yeah
02:55:33 <elliott> the 2 part means 2 arguments
02:55:34 <elliott> the A part doesn't
02:55:42 <mm_freak> doomlord: A means Applicative
02:56:01 <mm_freak> there is a lift* for about all letters from the alphabet =)
02:56:03 <doomlord> i just tried :t liftA2 ... what do i 'import'
02:56:11 <johnw> Control.Applicative
02:56:11 <mm_freak> doomlord: Control.Applicative
02:56:30 <mm_freak> some people feel more comfortable writing this instead:  vecAdd a b = (+) <$> a <*> b
02:56:38 <doomlord> wow, i dont
02:56:41 * johnw is some people
02:56:42 <mm_freak> liftA2 is just a shorthand for that
02:56:56 <doomlord> <$> (superman operator?) is fmap
02:57:02 <mm_freak> yeah
02:57:08 <mm_freak> and (<*>) comes from Applicative
02:57:14 <doomlord> and what is <*> ...
02:57:31 <johnw> f <$> F(a) => F(f a).   F(f) <*> F(a) => F(f a).  If that makes any sense
02:57:36 <mm_freak> doomlord: just read the type signature
02:57:45 <mm_freak> fmap :: (a -> b) -> F a -> F b
02:57:54 <mm_freak> (<*>) :: F (a -> b) -> F a -> F b
02:58:02 <doomlord> f=>f (a->b)->f a -> f b... and the 'f' all along is my collection? (vec3, etc)
02:58:16 <mm_freak> try reading "F" as "vector of"
02:58:24 <Zariel> Is there a way to get parsec to apply a parser 0 or mroe times until the parser fails?
02:58:32 <johnw> manyTill?
02:58:35 <mauke> Zariel: many
02:58:42 <johnw> ah, yes, just many
02:59:16 <Zariel> mauke: using many it tries to apply it once too many then the parsing fails
02:59:19 <mauke> template<template<typename> F, typename A, typename B> F<B> lolwut(F<B (A)>, F<A>);
02:59:22 <mauke> Zariel: no
02:59:30 <mm_freak> doomlord: and yes, in your case it applies a vector of functions to a vector of values yielding a vector of values
02:59:42 <mauke> Zariel: many . try
03:00:31 <doomlord> should i keep this typeclass 'VecOps' or not
03:00:38 <mm_freak> doomlord: in order to make your type an applicative functor you write (<*>) and 'pure' for it…  the former should apply coordinate by coordinate, the latter should just construct a vector where the values are all equal
03:00:41 <doomlord> do i replace it with a load of definitions using <$>
03:00:43 <mm_freak> doomlord: no
03:00:48 <mm_freak> doomlord: yes
03:00:52 <mm_freak> and (<*>)
03:01:16 <doomlord> and i just implement <$> for my 'Vec3 Vec4' etc..
03:01:33 <mm_freak> well, fmap…  (<$>) is just an infix alias for it
03:01:44 <Zariel> mauke: im doing that inside a permute, .. <||> (try $ many parser)
03:02:08 <mm_freak> doomlord: there are mainly four classes predefined that you need:  Applicative, Foldable, Functor, Traversable
03:02:10 <doomlord> would this extend to tuples of generalized types- its conceivable that x,y,z could be different precision.. but i've not used that
03:02:12 <johnw> Zariel: I think he meant use many (try parser)
03:02:21 <mm_freak> if you define those, you can express pretty much any vector operation independent of the type
03:02:48 <mm_freak> doomlord: nope, that's the limitation
03:02:48 <johnw> mm_freak: which is exactly what the linear library is all about
03:02:50 <mauke> Zariel: (many . try) parser
03:02:54 <mm_freak> all component types must be equal
03:03:19 <mm_freak> johnw: i pointed that out already, but doomlord prefers to reinvent it for the sake of learning
03:03:24 <johnw> doomlord: I think you would really like linear, at least to see how it's done
03:03:37 <johnw> yeah, but his "learning" consists of us basically telling him longform how linear is implemented
03:03:40 <doomlord> yeah i'll give in and take a look
03:03:52 <doomlord> johnw, if i can't write this, i dont know how to think in haskell
03:03:53 <mm_freak> @hackage linear
03:03:53 <lambdabot> http://hackage.haskell.org/package/linear
03:04:08 <johnw> doomlord: don't worry, you won't understand linear right away
03:04:14 <johnw> by the time you do, you'll know a hell of a lot of Haskell
03:04:30 <mm_freak> i agree
03:04:43 <mauke> doomlord: I think you're solving the wrong problem
03:04:59 <johnw> in fact, just trying to break your brain against linear might be the better way to go about acquiring the learning you desire
03:05:13 <mm_freak> doomlord: don't expect to understand everything in two days…  it takes weeks to understand these very different concepts
03:05:49 <doomlord> in the meantime if i get something onscreen again, it'll spur me on- i can do something tangible with what i've got, then refine it perhaps
03:06:16 <doomlord> so it seems like theres some library code that basically streamlines this.
03:07:34 <doomlord> originally i stumbled on not having C++ style overloading, and didn't really master typeclasses which i gathered were key. i'm trying haskell again after using rust Traits ,wihch aren't completely baffling, and which i actually liked
03:08:11 <mauke> C++ style overloading is boring
03:08:19 <mauke> it's just separate names under the hood
03:08:20 <doomlord> its pretty easy to use though
03:08:23 <mm_freak> doomlord: type classes are a combination of interfaces and traits on steroids
03:08:30 <mauke> it's pointless sugar
03:08:34 <johnw> I missed C++ overloading in the beginning, then at some point I stopped :)
03:09:08 <mm_freak> that leads beginners to think that they should write a type class for everything…  the truth is, in practical haskell development you seldomly define classes =)
03:09:19 <johnw> mauke: that's a good point.  It's like all those dynamically typed languages that are really monotyped :)
03:09:22 <mauke> either you can determine the function to call statically (in which case you could've just used a different name), or you can't (in which case the code is ambiguous anyway)
03:09:23 <doomlord> well it does the job of looking up functions for you, and makes refactoring easier when you dont have to go and change all those _what_type prefixes onthe function names
03:09:34 <johnw> mm_freak is right
03:09:43 <johnw> i'm a recovering type class addict
03:09:52 <mm_freak> doomlord: there are other ways to fix this, which are more appropriate
03:10:02 <mm_freak> type classes aren't a modularity abstraction
03:10:13 <johnw> now whenever I reach for type classes, I force myself to ask if a higher-order function can't do the same job
03:10:57 <doomlord> i guess i should add in C++ i usually end up with a #define to implement all the operators...
03:11:13 <mauke> doomlord: that doesn't sound right. C++ doesn't do type inference so you'll have to change all declarations anyway
03:11:22 <johnw> it's not like you can't do that in Haskell.  MUHAHAHAA  (runs away in shame and fear)
03:11:23 <doomlord> as in there's repetition you can't easily express
03:11:37 <mm_freak> mauke: it does some limited form of type inference since C++1x though
03:11:48 <mauke> the auto thing?
03:11:51 <doomlord> thats the point , i stilll find myself being able to eliminate repition with #defines that other means can't quite
03:11:54 <mm_freak> yeah
03:11:56 <doomlord> C++11 has local type inherence
03:12:18 <doomlord> and templates do some type infering, which is why overloading is useful
03:12:25 <mm_freak> but that 'auto'-inference suffers from all the language features that don't exactly support type inference
03:12:40 <mm_freak> that's why even in a language like C# you have to write types all the time
03:13:03 <doomlord> using a combination of templates betweeen functions and auto locally,you have quite a bit of inference going on,not as much as haskell still i guess
03:13:16 <t7> not close to haskell
03:13:20 <mauke> templates are untyped
03:13:26 <doomlord> unbounded
03:13:31 <johnw> doomlord: in C++ you can't "auto ptr = malloc;" and then use ptr and have the compiler infer how much it should malloc based on how you used the ptr.  In Haskell, that just works
03:13:37 <t7> C++11 'type inference' only uses data the compiler has to know for type checking
03:13:38 <mauke> they just generate code, which is type checked later
03:13:53 <mm_freak> doomlord: you use "overloading" in haskell, too…  you use it all the time…  but the concept behind it is parametric polymorphism, not ad hoc polymorphism
03:14:01 <doomlord> oh, the type inference goes *backwards* ?
03:14:12 <johnw> doomlord: the type inference goes *all the way*
03:14:13 <doomlord> aswell as forwards
03:14:13 <mauke> doomlord: type inference goes everywhere at the same time
03:14:17 <magicman> Type inference goes everywards.
03:14:20 <mauke> doomlord: it's like The Force
03:14:32 <Cale> doomlord: The type inference goes every way. It generates a bunch of constraints on the types of things and solves the equations.
03:14:37 <t7> mauke, quantum direction ?
03:15:05 <doomlord> i figure a lot of haskel is like writing the whole program as one big template. (on steroids)
03:15:06 <Cale> doomlord: and in this case (malloc), the inferred type is even used to choose an implementation :)
03:15:32 <Cale> Except unlike templates, polymorphic things are compiled just once
03:15:40 <mauke> and they're type checked
03:15:45 <mm_freak> doomlord: no, templates are different…  "template" is to be taken literally
03:15:46 <doomlord> i'm still not sure how far i'll go with haskell .. but it is interesting.
03:15:48 <johnw> doomlord: a Haskell program sort of builds a program which is then executed, so you're not far off
03:15:59 <doomlord> a big dependancy graph
03:16:02 <johnw> exactly
03:16:08 <mauke> in a C++ template you can write any nonsense you want. you'll only get type errors when they're instantiated
03:16:12 <johnw> where unevaluated leaves are just truncated
03:16:15 <doomlord> then you ask for the answer and it works backwards
03:16:18 <mm_freak> polymorphic haskell functions actually have only one opcode representation, although sometimes the compiler produces multiple versions for efficiency, not because they mean different things (they don't)
03:16:45 <doomlord> yeah i'm noticing this, you spend longer fighting the compiler ... (but then its more likely the program is correct)
03:16:52 <johnw> yep
03:16:55 <johnw> that is so true
03:17:01 <johnw> better to spend your costs up front
03:17:13 <johnw> because you always have to spend that money, it's just a question of when
03:17:17 <doomlord> i understand the logic behind it
03:17:25 <mm_freak> doomlord: that's the three (long) steps to mastering the type system:  1. you hate it, 2. you love it, 3. you use it
03:17:29 <doomlord> the more you can prove the better, before actual testing..
03:17:33 <mm_freak> it can take months to years to arrive at 3.
03:17:34 <neurocyte> The big difference betwen C++ and Haskell is that C++ does not support return type polymorphism. We use that in Haskell all the time.
03:17:36 <Cale> > let f :: (Show a) => a -> Integer -> String; f x 0 = show x; f x n = f (x,x) (n-1) in map (f ()) [0..]
03:17:37 <lambdabot>   ["()","((),())","(((),()),((),()))","((((),()),((),())),(((),()),((),())))"...
03:17:55 <mm_freak> neurocyte: huh?  C++ does support that
03:17:57 <Cale> ^^ this program uses the Show typeclass at infinitely many types
03:18:02 <mauke> > let f :: (Show a) => a -> Integer -> String; f x 0 = show x; f x n = f (x,x) (n-1) in map (f 'c') [0..]
03:18:04 <lambdabot>   ["'c'","('c','c')","(('c','c'),('c','c'))","((('c','c'),('c','c')),(('c','c...
03:18:09 <mauke> mm_freak: not really
03:18:15 <neurocyte> mm_freak, no it doesn’t
03:18:21 <Cale> If it compiled separate code for each one, then it would spend forever compiling :)
03:18:24 <johnw> mauke: C++11 allows for auto return types, doesn't it?
03:18:27 <mm_freak> template <typename A> A f(…);
03:18:28 <doomlord> i think i know what you mean, the inference working bakcwards
03:18:29 <mm_freak> what's that?
03:18:31 <doomlord> it doesn't in c++11
03:18:38 <johnw> Cale: uh, have you used a C++ compiler lately?
03:18:39 <QinGW> How to use sepBy with string as seperator?
03:18:41 <mauke> johnw: I don't know C++11
03:18:43 <doomlord> you cant say Foo f = blah.... and blah is overloaded
03:18:48 <doomlord> based on Foo
03:18:48 <Cale> johnw: hah
03:19:01 <doomlord> C++11's inference is all forward even for return types
03:19:08 <johnw> the only thing slower than a c++ compiler is an even slower c++ compiler
03:19:22 <doomlord> and you need to write out  decltype yada to specify an infereed return type
03:19:31 <johnw> true
03:19:36 <johnw> you have to guide the "inference"
03:19:37 <Cale> But in this case, it really wouldn't just be slow, but take forever. (actually it would probably hit some limit and bail)
03:19:37 <noteventime> "... is a C++ compiler after you add another template"
03:19:47 <doomlord> eg template<typename T,typename Y> auto mul(T& a, Y& b) -> decltype(yada yada ...) { ..}
03:20:11 <mauke> mm_freak: something you have to resolve explicitly, as in F<int>()
03:20:23 <mm_freak> mauke: sure
03:20:40 <mm_freak> but the statement was that C++ doesn't support return type polymorphism
03:20:54 <mauke> you can fake it
03:20:58 <mauke> I have written a magic malloc in C++ but it's not pretty
03:21:04 <mm_freak> you fake polymorphism anyway in C++
03:21:14 <mm_freak> but you can certainly write this:  template <typename A> A f(…);
03:21:16 <neurocyte> return types are always explicit in C++, either directly or indirectly, C++ can never infer them for you.
03:21:35 <mm_freak> neurocyte: you didn't say C++ doesn't support return type /inference/
03:21:40 <notdan> What's the proper way to split Data.Set into an element of a set and the rest?
03:21:50 <notdan> Kinda like (set-first) + (set-rest) in racket
03:21:51 <neurocyte> mm_freak, sorry, that was what I mean’t
03:22:04 <Cale> minView :: Set a -> Maybe (a, Set a)
03:22:09 <mauke> "mean’t" ಠ_ಠ
03:22:11 <Cale> maxView :: Set a -> Maybe (a, Set a)
03:22:40 <mm_freak> notdan: if you mean some element in the middle of the set, you can 'split'/'splitLookup' and then re-'union'
03:22:51 <doomlord> so beyond what i'm doing now, fmap is used across all the more complex datastructures ? trees etc
03:22:58 <notdan> thanks Cale!
03:23:15 <mm_freak> doomlord: fmap is everywhere
03:23:24 <Cale> The apostrophe is a polite way of letting the reader know that an s or t is coming up a't the end of a word.
03:23:27 <notdan> mm_freak: well I just need an arbitrary element; Cale pointed me to the right direction
03:23:44 <mauke> Cale: it's not even an apostrophe, it's a right single quotation mark :-(
03:23:50 <doomlord> mm_freak after i do this,  something like BSP tree generator would be next.. or tristrip generation
03:23:59 <mauke> http://mauke.hopto.org/stuff/c++/awesome/malloc.hh
03:24:12 <notdan> I wish it would be O(1) but I guess I'd have to use lists for that
03:24:17 <doomlord> i want to see what spatial clustering routines look like in haskell
03:24:34 <notdan> Actually converting a set to list and performing my computation and then converting back is going to be faster, I think
03:24:39 <doomlord> but i figure i'm going to get further if i actually get something onscreen ASAP before wading through lots of theory
03:24:41 <quchen> Cale: It beat's XML syntax for sure: "There is a suffi<suffix>x</suffix> coming up"
03:24:57 <mm_freak> doomlord: if you want to see ready-made code for this you can look into an old opengl demo called frag
03:25:17 <mm_freak> doomlord: but the code is very old, so chances are you would do things differently today
03:25:35 <mm_freak> in particular the applicative pattern wasn't as ubiquitous back then
03:26:12 <mm_freak> doomlord: the demo loads quake3 maps and allows you to walk through them and shoot against walls =)
03:32:37 <doomlord> ii figure if i have a use for haskell it is most likely to be things like scene preprocessing, the actual BSP generator
03:33:11 <doomlord> polygonSoup -> optimalBVH or whatever
03:34:42 <noteventime> doomlord: If you're interested, John Carmack is working on a project to port Wolf 3D to haskell
03:34:51 <doomlord> yeah i saw that news
03:34:59 <mm_freak> well, wold3D is not based on BSP
03:36:18 <noteventime> mm_freak: Not the new one either?
03:36:30 <mm_freak> noteventime: unlikely, i think
03:36:38 <mm_freak> if anything it will probably do something close to doom
03:36:42 <mm_freak> sections + visibility
03:36:43 <noteventime> It sounded kinda like the iOS port would form the basis
03:37:04 <mm_freak> but of course you could encode that as a BSP
03:38:11 <mm_freak> interestingly BSP itself would make an applicative functor =)
03:38:22 <mm_freak> a monad even
03:38:47 <mm_freak> so most BSP operations wouldn't even need to be reinvented in haskell
03:40:08 <mm_freak> mr. carmack said that the haskell wold3d port will use opengl, so he won't use ray-casting
03:40:17 <mm_freak> (+ "likely")
03:40:36 <fruitFly_> what's the difference between a package, module, library etc.?
03:41:04 <mm_freak> fruitFly_: a package is a collection of executables, test suites, benchmarks and optionally a library
03:41:15 <mm_freak> libraries, executables, test suites and benchmarks are a collection of modules
03:42:02 <fruitFly_> mm_freak: modules? a collection of functions oriented to a similar goal?
03:42:15 <mm_freak> fruitFly_: a collection of definitions
03:42:25 <mm_freak> how you group them into modules is up to you
03:44:34 <fruitFly_> mm_freak: You said I need Data.bytestring for the matasno challenges... is that a module?
03:45:14 <mm_freak> fruitFly_: you don't /need/ it…  i just told you what i do and what sounds sensible to me =)
03:45:19 <mm_freak> Data.ByteString is a module
03:45:43 <mm_freak> and it exports a type called ByteString, which is a dynamic array of Word8
03:47:48 <fruitFly_> mm_freak: Ok, I'm about to start... I don't know much about hex or base 64... btu it seems I should just write a program that converts hex to binary and then binary to base 64. I don't see why I would need to import anything, or not yet at least... I
03:47:55 <fruitFly_> mm_freak:  I'll give it a go.
03:48:31 <mm_freak> fruitFly_: to make it easier for yourself start with a function of this type:  [Word8] -> [Char]
03:48:44 <mm_freak> (you need Data.Word for that)
03:49:24 <mm_freak> and make sure that it agrees with the 'base64' command line tool
03:49:46 <mm_freak> i.e. 'base64 [0, 0, 0]' should yield "AAAA"
03:49:52 <fruitFly_> mm_freak: what is word8 ? isn't hex just base 16 .. seems simple enought write a func to convert that to binary and then I'll look at the base 64 conversion and then just convert to that.
03:50:01 <mm_freak> fruitFly_: ignore the hex bit for now
03:50:34 <mm_freak> you are converting a string of hex digits to a string of bytes (Word8)
03:50:45 <mm_freak> then that string of bytes to a string of base64 characters
03:54:33 <fruitFly_> mm_freak: I remember some arrows for the base64 conversion when it isn't divisible by 8bits but is it the same for hex? does just doing the conversion from the start in bytes make the problem easier?
03:54:56 <fruitFly_> mm_freak: I was just thinking hex to binary... then binary to base64 and add the arrows lol
03:59:48 <mm_freak> fruitFly_: if you have functions hexToBin and base64, you would just do base64 . hexToBin
04:01:37 <fruitFly_> mm_freak: isn't that the most efficient way to do it? creat a func hex to bin then bin to base64
04:02:57 <mm_freak> fruitFly_: yeah, sure
04:03:06 <mm_freak> that's what i'm suggesting
04:03:17 <mm_freak> but hex to binary is easy, so start with binary to base64
04:03:36 <fruitFly_> mm_freak: oh ok
04:03:59 <mm_freak> but feel free to start with hex to binary…  that may give you an idea on how to process streams =)
04:04:40 <fruitFly_> mm_freak: i'll do hex to bin :)... let you know how that goes :)
04:04:54 <Entroacceptor> now that I've started writing my mpd client for my raspi in haskell, I can compile and run it there, can't I?
04:04:57 <mm_freak> fruitFly_: write the type signature first:  hexToBin :: String -> Maybe [Word8]
04:05:11 <mm_freak> Entroacceptor: you can
04:05:28 <fruitFly_> @type maybe
04:05:29 <lambdabot> b -> (a -> b) -> Maybe a -> b
04:05:33 <Entroacceptor> is it worth setting up a cross compiling ghc?
04:05:49 <mm_freak> Entroacceptor: definitely, unless you want compilations to take forever =)
04:06:01 <fruitFly_> @src maybe
04:06:01 <lambdabot> maybe n _ Nothing  = n
04:06:01 <lambdabot> maybe _ f (Just x) = f x
04:06:18 <mm_freak> fruitFly_: try @src Maybe
04:06:29 <fruitFly_> @src Maybe
04:06:30 <lambdabot> data Maybe a = Nothing | Just a
04:07:07 <fruitFly_> @type Maybe
04:07:09 <lambdabot> Not in scope: data constructor `Maybe'
04:07:54 <Entroacceptor> well, if it takes forever and ever to set it up, it might be fine not to use it :)
04:07:59 <quchen> Maybe doesn't "have" a type, it *is* a type.
04:08:21 <quchen> You can ask for the type of its type constructors though:
04:08:23 <quchen> @type Just
04:08:25 <lambdabot> a -> Maybe a
04:08:47 <mm_freak> Entroacceptor: remember that you need to compile a whole bunch of packages for raspi, not just your own program
04:08:51 <Javran> @pl \f x -> f $ f x
04:08:52 <lambdabot> join (.)
04:09:14 <mm_freak> Entroacceptor: building the cross compiler + compiling those on your PC may take less time than building on the raspi directly
04:09:40 <mm_freak> but of course building on the raspi is going to be much easier
04:14:03 <doomlord> i read that haskell can run on android but via a hacky compile to c (with bugs?)
04:14:20 <doomlord> http://stackoverflow.com/questions/5151858/running-a-haskell-program-on-the-android-os
04:14:39 <elliott> there is native ARM support these days.
04:15:07 <doomlord> as i discovered with Rust, you still might need OS details
04:15:14 <neurocyte> doomlord, that is way outdated
04:15:33 <doomlord> ( ifailed to get Rust onto iOS as yet, despite the fact they have some android support)
04:15:45 <neurocyte> doomlord, ghc now supports ARM as a cross compiler target (with LLVM)
04:16:18 <neurocyte> at least ghc HEAD does
04:18:10 <doomlord> is haskell on the jvm  a disaster or not
04:18:18 <doomlord> (being GC based)
04:20:01 <neurocyte> compiling haskell to run *in* the JVM as java byte code is not really a viable option atm.
04:20:21 <hpc> see also: the hilarity that scala compilers have to deal with
04:20:27 <neurocyte> but loading the Haskell RTS into a JVM as a shared object works very well in my experience.
04:22:17 <neurocyte> I am working on making the Haskell native code running in a JVM as a native binary as seamless as possible by generating Haskell JNI wrappers to Java APIs.
04:22:46 <neurocyte> But that is a work in progress.
04:25:49 <neurocyte> doomlord, if you are interested, checkout https://github.com/neurocyte
04:26:52 <mura> Where can I find the reference of the generated G code traces of Hugs? except looking into its source.
04:30:30 <latermuse> how do i install @pl in my own ghci?
04:31:44 <byorgey> latermuse: cabal install pointfree
04:31:45 <nlogax> latermuse: cabal install pointfree, add `:def pl return . (":!pointfree " ++) . show' to your ghci
04:31:55 <nlogax> .ghci, that is
04:32:08 <typoclass> latermuse: you can always use "/query lambdabot" if you want
04:32:11 <latermuse> thanks guys :)
04:36:53 <latermuse> is the unpl program a different program to install?
04:37:07 <latermuse> cabal: There is no package named 'unpointfree'.
04:37:26 <nlogax> Is it "pointful" perhaps?
04:37:46 <latermuse> perhaps. giving it a shot
04:39:18 <latermuse> yes it is. thanks!
04:43:25 <mm_freak> elliott: native ARM support unfortunately doesn't help with android
04:43:49 <mm_freak> the system is so brain-damagedly designed that to do anything useful you need to go through the JVM
04:44:49 <mm_freak> well, except for OpenGL stuff perhaps, but then it's a lot of work
04:45:41 <sanbonpe> Nooby question: I have a function of type String -> String -> String -> String -> SomeType and i want to use this to write a function [String] -> SomeType (ignoring any values after the fourth string), this seems like a fold, but the types don't match
04:46:37 <mm_freak> sanbonpe: that's not a fold
04:46:44 <mm_freak> and in fact it's a bad idea
04:46:59 <mm_freak> unless you have a well-defined result for [a, b, c]
04:47:30 <typoclass> sanbonpe: is it like concat or unwords, i.e. can it have any number of Strings? or does it always have to be four?
04:47:38 <typoclass> > unwords ["abc", "def"]
04:47:40 <lambdabot>   "abc def"
04:48:04 <sanbonpe> Oh ok, basically i'm trying to convert a row from a csv into a simple data type (it has 3 strings, and a list of strings which can be converted from a string), or should I be doing something different here too?
04:48:22 <latermuse> > concat ["abc", "def"]
04:48:24 <lambdabot>   "abcdef"
04:48:38 <mm_freak> sanbonpe: go with your original String -> String -> String -> String -> SomeType for now
04:48:48 <mm_freak> to get some type-safety you can introduce newtypes for your strings
04:48:50 <typoclass> sanbonpe: no, your plan sounds reasonable so far :-)
04:48:57 <mm_freak> newtype Name = Name { getName :: String }
04:49:21 <mm_freak> Name -> Address -> Country -> Employers -> Applicant
04:49:49 <typoclass> mm_freak: well if he's reading from csv, it'll all be String anyway. newtypes might end up being an unnecessary conversion
04:50:06 <mm_freak> typoclass: "conversion" in what sense?
04:50:06 <typoclass> but yeah, depends on his code :-)
04:50:07 <sanbonpe> Right. So for parsing from the CSV, should i pull out each field using the index operator and handle each explicitly?
04:50:25 <mm_freak> sanbonpe: are you writing the CSV parser yourself?
04:50:27 <typoclass> mm_freak: wrapping Strings, unwrapping Strings
04:50:35 <sanbonpe> Nope. I'm using Text.CSV
04:50:43 <mm_freak> from which package is that?
04:51:51 <sanbonpe> err, hackage says csv-0.1.1 i think
04:52:05 <mm_freak> @hackage csv
04:52:06 <lambdabot> http://hackage.haskell.org/package/csv
04:52:33 <mm_freak> hmm
04:53:11 <mm_freak> well, i'd just pattern-match on the results
04:54:05 <Bor0> is this a valid proof? http://pastebin.com/Z5CmjMxh
04:54:12 <mauke> The paste Z5CmjMxh has been copied to http://hpaste.org/87663
04:54:28 <mm_freak> parseCSV "" text >>= foldM f z  where f x [field1, field2, field3, field4] = …
04:55:10 <Entroacceptor> mhm, maybe using qemu is easier
04:55:43 <elliott> Bor0: looks right -- one detail: fffx is wrong
04:55:46 <elliott> it's ((ff)f)x
04:55:52 <elliott> but you mean f(f(fx))
04:56:02 <arnsholt> Hi, I need to represent a directed tree where there is also an ordering over the nodes (a dependency graph for those in the NLP business). Is there a library that handles this already?
04:56:06 <elliott> but the spirit is right
04:56:16 <Bor0> correct, thank you
04:56:25 <int-e> Bor0: almost - you need more parentheses. And you should introduce some notation for apply f k times to x -- f^k x  is quite common
04:56:40 <xc__> men, whare are your thoughts about http://en.wikipedia.org/wiki/Decision_tree model?
04:56:41 <int-e> *applying
04:56:44 <neutrino_> hi
04:56:54 <neutrino_> has anyone here managed to get ensime to work?
04:57:07 <Bor0> thank you int-e, elliott. I'll fix that
04:57:09 <int-e> Bor0: (LaTeX; ^ denotes an exponent (or superscript))
04:57:21 <Hafydd> arnsholt: an ordering other than that represented by the edges?
04:57:24 <sanbonpe> mm_freak, thanks. I'll do that. Though, what is the x in f x for?
04:57:52 <mm_freak> sanbonpe: you can write a list traversal yourself for now instead of using foldM
04:57:54 <Bor0> not much introduced to LaTeX, but I'll step into it one day I guess.  I'm playing around with lambda calculus for the last couple of days, and now with proofs. can't stop being amazed by it :P
04:57:58 <mm_freak> in foldM the 'x' is the "value so far"
04:58:05 <arnsholt> Hafydd: Yeah. The graph represents syntactic relations between words in a sentence, so the nodes are ordered as well by the linear order of the words
04:58:13 <Hafydd> I see.
04:58:24 <sanbonpe> ah right.
05:00:19 <arnsholt> Ultimately I need to implement a tree edit distance algorithm (http://www.sciencedirect.com/science/article/pii/S0304397505000174 if you have Elsevier access, or http://www2.imm.dtu.dk/~phbi/files/publications/2005asotedarpJ.pdf for the samizdat version), but first I should probably figure out how to best store the data I'll be working with =)
05:01:30 <magicman> d
05:02:38 <magicman> (note to self: tab out of IRC before bashing keyboard)
05:03:17 <mm_freak> magicman: there are haskell to javascript compilers…  don't ruin your life
05:05:07 <doomlord> how does deriving(show) work , i.e. getting the element names for data
05:05:25 <mm_freak> doomlord: it's magic
05:05:26 <mauke> magic
05:05:44 <doomlord> template haskell? or somehting inbuilt
05:05:55 <mm_freak> template haskell can do it, but it's built-in
05:06:06 <no-n> what's template haskell?
05:06:19 <mm_freak> no-n: meta programming in haskell
05:06:38 <mauke> no-n: do you know lisp?
05:06:46 <Peaker> no-n, a macro system that lets you run arbitrary Haskell programs in compile-time that can look at the structure of the program and output code to the compiler
05:06:46 <no-n> I know /of/ lisp ;)
05:07:15 <mm_freak> TH is the type-safe equivalent =)
05:07:17 <no-n> madness
05:07:46 <t7> dont people say TH isnt very safe?
05:07:55 <Peaker> TH is not quite Lisp equivalent, because the input is too restrictively structures (reading existing code), or just stringy (quasiquotes)
05:08:10 <Peaker> s/structures/structured
05:08:32 <Peaker> Lisp makes it easy to add new forms via macros, that look very much like the existing forms in the language.. TH doesn't allow that
05:09:00 <Peaker> For that, Lisp sacrifices nice forms and does everything with uniformly ugly forms :)
05:09:03 <mauke> that's only because Lisp has messed up forms by default
05:09:22 <doomlord> i enjoyed lisp quite a lot
05:09:52 <doomlord> some of the things in clojure were nice IMO
05:09:53 <arnsholt> Lisp (or at least Common Lisp, which is what I've used) is a wonderful language. It's just a shame the syntax is so bad =)
05:10:00 <mauke> "oh, you wrote (foo bar)? I don't see a definition for 'foo' anywhere so I guess you meant (funcall #'foo bar)"
05:10:05 <doomlord> the syntax is simple
05:10:11 <mauke> doomlord: it's not
05:10:18 <mauke> er
05:10:26 <mauke> I misparsed context
05:10:27 <mm_freak> arnsholt: that sounds like a mixed message…  common lisp is basically the syntax =)
05:10:33 <augur_> arnsholt: scheme is supreme!
05:10:47 <doomlord> all the macro magic in lisp works because you're thinking about the ast
05:10:55 <arnsholt> mm_freak: No, Common Lisp is one of the many Lisp dialects
05:11:16 <mm_freak> arnsholt: i mean that the language is pretty much defined by how it interprets its own syntax
05:11:31 <mm_freak> add in some primitives and you have common lisp
05:11:44 <XexonixXexillion> don't forget adding multiple name spaces
05:11:52 <klrr> i have a really strange run time error anyone got an idea what's wrong, is it me that have done something wrong or is it the logic that is wrong? http://hpaste.org/87664 (error and code in paste)
05:11:58 <arnsholt> That's how all languages work. The syntax has semantics, and execution follows from that
05:12:01 <XexonixXexillion> scheme is probably closer to being just defined by syntax
05:12:02 <Peaker> Common Lisp is a rather ugly imperative language
05:13:54 <doomlord> so a "functor" in haskell is almost the inverse of what it is in C++... ?
05:14:11 <XexonixXexillion> what is it in C++?
05:14:22 <doomlord> in C++ some HOFs take functors... (a class with call overloaded)
05:14:23 <mauke> XexonixXexillion: an object that pretends to be a function so you can "call" it
05:14:40 <doomlord> in Haskell, the "functor" is the thing that accepts the function..?
05:14:51 <mauke> doomlord: no, the functor is the type constructor
05:15:03 <klrr> i have a really strange run time error anyone got an idea what's wrong, is it me that have done something wrong or is it the logic that is wrong? http://hpaste.org/87664 (error and code in paste)
05:15:24 <t7> functor in C++ is kinda like currying in haskell
05:15:37 <mauke> wtfamireading.jpg
05:15:42 <doomlord> yes in that its a way of combining some parameters with a function pointers
05:15:47 <doomlord> pointer. singular
05:15:56 <Peaker> klrr, can you clean the hlint output first?
05:16:04 <mm_freak> arnsholt: nevermind, my bad english skills bite me again =)
05:16:18 <doomlord> you can emulate currying with by making a c++ functor  with bind
05:16:37 <doomlord> or do similar things with macros
05:16:41 <klrr> Peaker: what's hlint?
05:16:42 <doomlord> messily
05:16:56 <Peaker> klrr, the program that outputs all the warnings around your paste
05:17:17 <mm_freak> doomlord: i don't think you can compare the two
05:17:30 <klrr> Peaker: those hints on making my code not sucking ? :P
05:17:30 <mm_freak> in haskell "Functor" is a design pattern
05:17:40 <Peaker> klrr, on making the style nicer :)
05:17:43 <doomlord> i've made macros that let you declare a curryable function in C++, its just very mesy :)
05:17:49 <zachk> wait..there is design patterns in haskell?
05:17:52 <Peaker> mm_freak, once its captured by a library, it's no longer a "design pattern"
05:17:57 <noteventime> doomlord: A functor is a higher order type with a "map" operation, I don't quite see how it would compare to the C++ thing...
05:18:07 <klrr> Peaker: okey some i can, but i like case more than if :P
05:18:35 <doomlord> well thats why i started out asking if its almost the inverse of what it is in C++ , then someone said 'functors in c++ are a way of doing currying'
05:18:45 <mm_freak> well, let's say that Functor is a set of axioms for design patterns which you may call functors
05:18:47 <doomlord> confusing the discussion somewhat :)
05:19:13 <Peaker> klrr, weirdo :)
05:19:18 <Peaker> klrr, I prefer guards
05:19:24 <noteventime> doomlord: On what sense is it the inverse?
05:19:28 <noteventime> In*
05:20:14 <doomlord> in C++, you pass a functor into a HOF. so i asked, in haskell, is the 'functor' the thing you pass the function into...
05:20:38 <mm_freak> doomlord: you can't pass a functor
05:20:42 <mm_freak> a functor is a type
05:20:48 <mm_freak> together with its fmap
05:20:50 <mauke> (type constructor)
05:20:58 <mauke> * -> *
05:21:02 <mm_freak> yeah
05:21:11 <mm_freak> Maybe is a functor, for example
05:21:25 <mm_freak> > fmap (+ 3) (Just 15)
05:21:27 <lambdabot>   Just 18
05:21:55 <doomlord> you can in C++. this discussion is confusing because we keep alternating between C++ and haskell :)
05:22:12 <noteventime> Asking lambdabot to compute some Maybe makes it sound all casual about the result
05:22:27 <mm_freak> noteventime: it should =)
05:22:53 <mm_freak> functors aren't complicated…  in essence they give you nothing but a way to map without caring about the structure of a type
05:23:25 <mauke> let's use the OCaml definition of functor instead
05:23:26 <mm_freak> and the map is "sensible" in a strong formal sense
05:24:23 <hpaste> “Dharmender Kumar” pasted “Medical Clothing Service Call me @ +91-261-3090200” at http://hpaste.org/87666
05:27:25 <quchen> doomlord: Functors in C++ have nothing to do with Functors. Functors in Haskell have something to do with Functors.
05:27:30 <doomlord> yes i know
05:28:52 <quchen> Like every science calls something different 'Matrix', it seems every programming language needs something to call a functor. ;-)
05:29:07 <doomlord> silly word anyway
05:29:34 <noteventime> quchen: If you take C++ functors to just be morphisms there is a kind of duality thing going on though, in that functors are the structure preserving things on morphisms (take some appropriate category on the right hand side and you get something like the dual space of a vector space)
05:29:56 <doomlord> c++ should be called "function-objects" i guess
05:30:02 <noteventime> At least that's what I think doomlord was getting at
05:31:48 * hackagebot parconc-examples 0.1 - Examples to accompany the book "Parallel and Concurrent Programming in Haskell"  http://hackage.haskell.org/package/parconc-examples-0.1 (SimonMarlow)
05:31:58 <noteventime> Cool
05:32:37 <noteventime> Quite a bag of dependencies there :P
05:33:36 <doomlord> is liftA2 implemented in terms of <$> and <*>
05:33:52 <elliott> liftA2 f x y = f <$> x <*> y
05:33:54 <doomlord> liftA2 f a b = f <$> a <*> b if i remmber
05:33:58 <elliott> aka liftA2 f x y = pure f <*> x <*> y
05:34:02 <mauke> @src liftA2
05:34:03 <lambdabot> liftA2 f a b = f <$> a <*> b
05:39:12 <doomlord> does <*> have a name
05:39:20 <mauke> yes: <*>
05:39:24 <klrr> FUCK APPLY FUNCTION!
05:39:27 <mauke> inb4 modem
05:40:28 <elliott> klrr: ?
05:41:08 <klrr> elliott: i have a bug or sth in my program that's impossible to find
05:41:20 <klrr> but i know it's in the apply function
05:41:30 <elliott> ah
05:42:11 <Ghoul_> Hi #haskell
05:42:42 <Ghoul_> is there a way to loop a generic function each time with a different type
05:43:37 <Ghoul_> My friend popped in here earlier and we've been trying to solve the issue of foldl requiring that the output be the same as the input when in reality its really inconvenient for that to be the case -- http://hpaste.org/87647
05:46:21 <mm_freak> Ghoul_: you need polymorphic recursion for that
05:46:28 <mm_freak> see the RankNTypes extension
05:46:45 <Ghoul_> mm_freak: thanks
05:47:07 <quchen> Ghoul_: A parser might be a better solution for your problem.
05:47:47 <quchen> What you're trying to do is converting text to a custom Haskell data type it seems.
05:48:06 <quchen> Well, not a Haskell data type, but Haskell data (which has some type).
05:49:22 <arnsholt> What's the correct way to split a string on whitespace again?
05:49:39 <quchen> words?
05:49:53 <typoclass> > words "abc def ghi" -- arnsholt?
05:49:54 <arnsholt> That's the one. Thanks!
05:49:55 <lambdabot>   ["abc","def","ghi"]
05:49:56 <Ghoul_> :S RankNTypes is confusing
05:50:22 <Ghoul_> Am I correct in saying that I would need to use a foldl variant supporting forall
05:50:43 <quchen> arnsholt: I think it splits only on space though. If you want to use any whitespace, have a look at the more generic functions in Data.List.Split
05:51:09 <quchen> > words "abc def\tghi\nlmn"
05:51:11 <lambdabot>   ["abc","def","ghi","lmn"]
05:51:15 <quchen> Oh, nevermind.
05:54:10 <hpaste> Bor0 revised “Lambda calculus example proof”: “Lambda calculus example proof” at http://hpaste.org/87663
05:55:32 <hpaste> quchen annotated “Folding Config options” with “Folding Config options (annotation)” at http://hpaste.org/87647#a87668
05:55:46 <quchen> Ghoul_: What about Applicative style? :-)
05:56:15 <Ghoul_> quchen: please explain
05:56:25 <Ghoul_> You mean the very long chain of <*>'s ?
05:56:36 <quchen> <*> insted of <-, yes.
05:56:42 <Ghoul_> We tried it.. it spans many lines and it looks a little clunky.
05:59:57 <mm_freak> Ghoul_: even with that clunkiness it makes the code a lot easier to read for someone used to applicative style
06:00:09 <mm_freak> just align the applicative operators to the left
06:00:38 <mm_freak> f \\ <$> x \\ <*> y \\ <*> z
06:00:42 <mm_freak> where "\\" means "next line"
06:00:54 <quchen> mm_freak: That's what I annotated :-)
06:01:32 <mm_freak> sorry, i didn't look into the paste =)
06:02:32 <mm_freak> IMO <*> should have a lower priority than >>=
06:03:10 <mm_freak> and <|> should probably have a higher one, because for short expressions you can use liftA* instead
06:03:42 <quchen> mm_freak: >>= has fixits 1, going lower isn't really an option
06:03:59 <mm_freak> quchen: but you can go higher
06:04:26 <quchen> Yeah, but that would probably break a lot of code
06:04:36 <mm_freak> i think i've never encountered a case where i would use (>>=) between applicative expressions, but the other way i encounter a lot
06:04:59 <mm_freak> yeah, i'm just saying =)
06:05:23 <quchen> Let's propose Float fixities! :D
06:05:32 <quchen> Or even better, Rational
06:05:32 <mm_freak> hehe
06:06:03 <mm_freak> in fact i'd vote for that
06:06:37 <quchen> mm_freak: Not sure about that idea. It sounds good in isolation, but it would probably lead to a real mess.
06:06:46 <quchen> HAHA REAL MESS unintentional bad pun sorry
06:06:53 <nlogax> :D
06:07:10 <mr-> quchen: but only if you take it to the limit
06:07:18 <mm_freak> lol
06:07:21 <quchen> Past the point of no return?
06:07:23 <mr-> (sorry)
06:07:37 <mm_freak> one pun after another
06:08:16 <mm_freak> i'd like rational fixities between 0 and 1
06:08:31 <quchen> mm_freak: That's at least a thousand of them!
06:08:32 <mm_freak> as well as local fixities
06:09:21 <quchen> mm_freak: >>= has fixity 439437/1038484, <*> has 5239424/11223234, which one has higher precedence? :D
06:09:46 <quchen> (I chose short numbers to make it more readable in the example)
06:09:56 <simukis_> > (439437/1038484, 5239424/11223234)
06:09:58 <lambdabot>   (0.42315240292580336,0.46683727702728106)
06:10:26 <quchen> Cool, my guess of two fractions close to each other wasn't even that bad
06:11:29 <mm_freak> quchen: you can use decimal and just compare lexically
06:11:32 <mm_freak> there is no need to use floats
06:11:56 <mm_freak> 1.5 has a lower priority than 1.55
06:12:45 <quchen> instance Eq a b where ... (>>=) < (<*>) = False
06:13:18 <hpaste> fizbin revised “Request for style comments”: “Request for style comments (rev. 2)” at http://hpaste.org/87615
06:13:50 <quchen> fizbin: More documentation, more intermediate comments, more newlines to make the code more appealing.
06:14:11 <quchen> Align your "=".
06:15:01 <fizbin> I'll cop to the more intermediate comments/documentation. Not sure though where I should put more newlines.
06:15:25 <fizbin> Let me add more comments first and do that aligning in the "let" block beginning on line 45
06:16:22 <quchen> fizbin: For me, reading code is often a psychological problem: if I don't enjoy looking at it, I probably won't read it unless forced to.
06:16:46 <quchen> The paste for example looks like a large blob of definitions to me.
06:17:01 <quchen> (Not sure how others handle things like these, I may be a little quirky in that respect.)
06:18:08 <quchen> I think a good guideline for good code is to not surprise the reader. Especially avoid "oh that's what he means" surprises :-)
06:18:42 <fizbin> Yeah, quchen. That's masssively easier said than done.
06:18:44 <quchen> There are variables called "va, vb, nm" in there, for example.
06:18:58 <fizbin> After all, *I'm* not surprised by the code anymore...
06:19:27 <quchen> I know that problem haha
06:19:45 <quchen> But then I think of future me being angry at myself
06:21:41 <quchen> The expression in line 34 is really hard to read too, it spans over 3 lines, and the last line is at a weird indentation level
06:21:55 <quchen> You could maybe split that up into multiple definitions inside the 'let'
06:22:04 <quchen> ... at which point you could give the sub-parts descriptive names
06:22:24 <quchen> Oh, and change "bdy" to "body" if you can spare the disk space ;-)
06:26:10 <mSSM> Given a set S={1,2,3}, is there a smart way to take the Cartesian product of S with itself, s.t. for an element s'=(k,l) the inequality l>k holds for all s' in S'?
06:26:54 <mSSM> Hm, I guess a filter? [(x,y) | x <- xs, y <- ys, x < y]
06:27:01 <mSSM> Sorry, I should have thought of that before coming here...
06:28:03 <Hafydd> That only works for Ord a => [a]
06:28:31 <mSSM> Hafydd: Indeed, but that's what I have.
06:28:35 <fizbin> quchen: I've gotten into the habit of instinctively abbrvng names to avoid name conflicts. (I like to be ghc -Wall clean when possible)
06:28:46 <mSSM> Ok, now I need to do this in python. :D
06:29:12 <fizbin> mSSM: The list comprehension translates pretty directly into python.
06:29:18 <quchen> fizbin: Body isn't reserved anywhere, is it? In any case, I think primes are more readable than only-consonant-abbreviations
06:29:35 <quchen> head' is better than hd ;-)
06:29:38 <fizbin> Most list comprehensions do...
06:30:07 <Hafydd> But if your list is already sorted, there's a faster way, I think.
06:30:27 <mSSM> Hafydd: it is
06:30:33 <Hafydd> But since you intend to translate it into Python, it's a waste of time to think about it.
06:30:49 <mSSM> Hafydd: I am curious though. How could I make this faster?
06:30:50 <kuribas> I deleted my .cabal directory, because I got a lot errors.  When I now use "cabal install salvia", I get an error: "cabal: Couldn't read cabal file "hashable/1.2.0.6/hashable.cabal"".
06:31:26 <quchen> [(x,y) | x <- xs, y <- takeWhile (/= x) xs] -- Something like that, Hafydd?
06:31:31 <mSSM> Hafydd: Since a list is an applicative: (,) <$> [1,2,3] <*> [4,5,6]
06:31:33 <supki> there isn't much point in deleting ~/.cabal without deleting ~/.ghc
06:31:42 <mSSM> But that's just the same, I guess.
06:31:49 * hackagebot wai-static-pages 0.2.0.0 - generate static html pages from a WAI application  http://hackage.haskell.org/package/wai-static-pages-0.2.0.0 (GregWeber)
06:31:59 <kuribas> supki: Ok, I'll try that.
06:32:39 <kuribas> supki: No, still the same error.
06:32:40 <beaky> hello
06:32:42 <beaky> what is an initial algebra
06:33:22 <fizbin> mSSM: Faster version is something like: func [] = []; func (x:xs) = map ((,) x) xs ++ func xs
06:34:09 <fizbin> Or in python… um… let me think...
06:34:33 <mSSM> pretty cool
06:34:58 <sclv> beaky: http://stackoverflow.com/a/5917133/371753
06:35:18 <supki> kuribas: what cabal-install version do you have?
06:35:25 <mSSM> fizbin: Python gets ugly with nested range/iterator objects.
06:35:28 * mSSM hates it.
06:35:56 <sclv> also http://homepages.cwi.nl/~janr/papers/files-of-papers/2011_Jacobs_Rutten_new.pdf
06:35:57 <supki> kuribas: older versions have a bug that they can't parse test sections with conditionals
06:35:58 <fizbin> In python I think the easiest thing to do is use indexes: [(xs[xi], xs[yi]) for xi in xrange(length(xs)) for yi in xrange(xi+1, length(xs)) ]
06:36:09 <fizbin> mSSM: Not so ugly.
06:36:23 <kuribas> supki: cabal-install 0.10.2 from ubuntu.
06:36:37 <Hafydd> > let xs = "hello" in [(x, y) | (x : xs') <- tails xs, y <- (x : xs')]
06:36:39 <lambdabot>   [('h','h'),('h','e'),('h','l'),('h','l'),('h','o'),('e','e'),('e','l'),('e'...
06:37:02 <supki> kuribas: not sure what you can do beside upgrading to 0.14 at least
06:37:14 <kuribas> supki: Ok, I'll try that.
06:37:38 <Hafydd> quchen, mSSM: that's what I had in mind; I concede there are other good ways to do it.
06:37:42 <fizbin> Hafydd: Almost what mSSM asked for. I think mSSM wanted ([(x, y) | (x : xs') <- tails xs, y <- xs'])
06:37:43 <supki> you can probably manually fix all .cabal files, but that's more painful I think
06:37:50 <Hafydd> Oh yeah...
06:37:57 <Hafydd> > let xs = "hello" in [(x, y) | (x : xs') <- tails xs, y <- xs']
06:37:59 <lambdabot>   [('h','e'),('h','l'),('h','l'),('h','o'),('e','l'),('e','l'),('e','o'),('l'...
06:38:06 <mSSM> cool stuff
06:38:08 <Hafydd> That's nicer to write, in fact.
06:38:29 <mSSM> fizbin, Hafydd thank you
06:38:37 <beaky> ah thakns
06:38:49 <Hafydd> But Python doesn't have an efficient way of taking the "tail" of a list.
06:39:16 <Hafydd> So you may be better off using itertools.product and a filter.
06:54:21 <kuribas> supki: Ok, now cabal says that installing this package (salvia) will break my ghc version! (7.0.3).
06:54:42 <kuribas> So my ghc version from ubuntu is useless?
06:55:26 <nh2> I read a recent Functor->Applicative->Monad hierarchy discussion. Has anybody ever actually tried out how much of hackage it would break?
06:55:40 <Kinnison> kuribas: Certainly 7.0 is rather old
06:56:06 <kwos> hi all!
06:56:07 <nh2> kuribas: it is very easy to get an out-of-repo ghc, I'd recommend it
06:56:27 <kuribas> from source?
06:56:51 <nh2> kuribas: no, the ghc website distributes quite portable binaries
06:57:08 <Igloo> nh2: It's quite hard to get meaningful figures, as if something like mtl breaks then a lot of packages will failt to install because they depend on mtl
06:58:12 <nh2> Igloo: I'd spend a weekend on trying that (and making fixes for cases like you say), but I don't want to miss out people who've already done that before
06:58:29 <nh2> especially, I wonder what a good infrastructure for this kind of thing is
06:59:02 <kwos> I have a quick question about lens: how can I given two getters make another getter that picks two fields of a record and puts them in a tuple?
07:00:04 <fruitFly_> mm_freak: you here?
07:00:12 <mm_freak> fruitFly_: pong
07:00:19 <fruitFly_> mm_freak: lol
07:00:39 <fruitFly_> ok so word8 is just an 8 digit number?
07:00:53 <hpaste> fizbin revised “Request for style comments”: “Request for style comments (rev. 3)” at http://hpaste.org/87615
07:02:36 <quchen> fruitFly_: 8 binary digits.
07:02:45 <quchen> Word8 = Byte.
07:02:56 <fruitFly_> ok
07:03:05 <badkins> A while back, some folks on this channel helped me create a pointfree version of nand. It was a helpful learning exercise, but in practice which of the following would be more idiomatic? "foo = (not .) . (&&)" vs. "foo = curry (not . (uncurry (&&)))"
07:03:27 <quchen> fizbin: Didn't read it, but it looks much better already :-)
07:03:44 <fruitFly_> quchen: why does it say "8-bit unsigned integer type"
07:03:47 <badkins> the latter seems much more clear to me, but more verbose, the double (.) in the former took a while to wrap my head around
07:03:51 <fruitFly_> quchen: unsigned integer?
07:04:06 <quchen> fruitFly_: It means it's representing whole numbers starting with zero.
07:04:13 <quchen> And it uses 8 bit to do so.
07:04:21 <quchen> > [minBound :: Word8, maxBound]
07:04:24 <lambdabot>   [0,255]
07:04:52 <fruitFly_> quchen:  got it
07:04:53 <badkins> The original is probably the most clear: nAnd x y = not (x && y)
07:05:00 <ramses_> badkins: I think the first one is clearer as it obviously just combined not and (&&), if the type works out, I wouldn't worry about that nested dot
07:05:12 <int-e> @type let (.:) = (.) . (.) in not .: (&&)
07:05:15 <lambdabot> Bool -> Bool -> Bool
07:05:17 <no-n> nand = not . and
07:05:24 <klrr> ?src map
07:05:24 <lambdabot> map _ []     = []
07:05:25 <lambdabot> map f (x:xs) = f x : map f xs
07:05:40 <ramses_> :t and
07:05:41 <lambdabot> [Bool] -> Bool
07:05:42 <ramses_> :t (&&)
07:05:43 <lambdabot> Bool -> Bool -> Bool
07:05:48 <no-n> oh yeah
07:05:56 <quchen> > [minBound, maxBound] :: [Int8] -- fruitFly_: "signed Word8"
07:05:58 <lambdabot>   [-128,127]
07:06:11 <badkins> no-n that's what I wanted it to be :)
07:06:18 <no-n> not . (&&) maybe?
07:06:28 <badkins> if && was (Bool,Bool)->Bool, then it would've been fine
07:06:36 <ramses_> no-n: wont work :) you can't leave out that second dot
07:06:36 <badkins> just took a while to work out the curry part
07:06:53 <fizbin> :t over
07:06:55 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
07:06:58 <joe9>  is there a haskell equivalent  of the shell xtrace or verbose functions? I am getting some run-time exceptions and am trying to figure out which function is raising that exception. I do not want to add printf's all over the program. Any thoughts, please?
07:07:25 <klrr> ?src filter
07:07:25 <lambdabot> filter _ []     = []
07:07:25 <lambdabot> filter p (x:xs)
07:07:25 <lambdabot>     | p x       = x : filter p xs
07:07:25 <lambdabot>     | otherwise = filter p xs
07:07:28 <Kinnison> no-n, badkins: curry $ not . uncurry (&&)
07:07:31 <ramses_> badkins: but then you wouldn't be able to slice your nand
07:07:40 <ramses_> (easily)
07:07:54 <quchen> joe9: http://www.haskell.org/haskellwiki/Debugging#Stack_trace
07:08:25 <badkins> Kinnison: to my relatively newbie eyes, that syntax seems the most obscure
07:08:55 <quchen> badkins: Which one? (.).(.)?
07:09:00 <elliott> nand x y = not (x && y) is the cleanest way to write it.
07:09:11 <no-n> yeah, what elliot said
07:09:12 <elliott> from non-newbie eyes
07:09:17 <int-e> badkins: I'd also stick to the pointed version.
07:09:36 <Kinnison> badkins: If you wanted it pointfree...
07:09:49 <badkins> elliott int-e I agree on clarity
07:10:21 <badkins> Kinnison: if I sacrifice clarity for point free,  I think (not .) . (&&) is probably the most concise
07:10:37 <shergill> so i'm starting out with smallcheck/quickcheck (it's been a long time coming) and one thing which i always wanted to do was to use them to perform automated testing of monad/arrow laws. thoughts?
07:10:45 <badkins> I don't have a good feel for the pros/cons of point free in Haskell given partial application, etc.
07:10:47 <quchen> Point free isn't something you should aim for. Clarity is. Do whatever suits that need.
07:10:49 <Kinnison> badkins: Bah, I like curry/uncurry
07:10:52 <Kinnison> badkins: :-)
07:11:21 <badkins> quchen: agreed re: clarity
07:11:22 <int-e> badkins: I can read (not .) . (&&), but I take sections of (.) to be an indication that I should add variables. (I also don't use (.:) despite my example above)
07:11:27 * Kinnison tends to find the (foo .) . bar syntax harder to read
07:11:47 <Kinnison> But that's more because I'm still finding it hard to remember partial applications
07:11:49 <int-e> and the curry/uncurry thing is too long.
07:11:54 <joe9> quchen: ghc +RTS -XC --make <myhaskellprogram>.hs
07:12:00 <fizbin> Though it does make me want to think about the general problem of "I've got an n-param function bar, a 1-param function foo, and want to create another n-param function that is \a1 .. an -> foo (bar a1 … an)"
07:12:05 <joe9> is that how it is used? I cannot get it to work.
07:12:11 <badkins> int-e: yeah, your example of (.:) above is something I'm still chewing on!
07:12:28 <joe9> quchen: forget it, got it.
07:12:32 <quchen> joe9: -xc, not -XC. Also you need to compile your program for profiling to run ith with -XC.
07:12:35 <quchen> Good :-)
07:12:45 <nooodl> (f . g) x = f (g x)
07:12:47 <nooodl> (f .: g) x y = f (g x y)
07:13:17 <nh2> how can I get all headings published on planet haskell in the last year?
07:13:44 * fizbin suspects that the general solution to that problem will end up being something like his reformulation of of the liftA* functions he was talking about yesterday.
07:13:50 <fizbin> :t (.:)
07:13:51 <lambdabot>     Not in scope: `.:'
07:13:51 <lambdabot>     Perhaps you meant one of these:
07:13:51 <lambdabot>       `.' (imported from Prelude),
07:14:43 <int-e> @type (fmap (fmap not)) (&&)
07:14:46 <lambdabot> Bool -> Bool -> Bool
07:14:51 <quchen> joe9: There's also Debug.Trace.traceStack: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Debug-Trace.html
07:15:05 <int-e> fizbin: see, no applicative required, it's just plain functors :)
07:15:27 <joe9> quchen: ok, thanks.
07:16:19 <quchen> joe9: And finally, here's the corresponding GHC manual page. http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-debugging
07:16:46 <joe9> quchen: there are a lot of libraries that I have to reinstall with profiling on. If I have profiling on, will it have a runtime performance hit( noticeable, I mean.)
07:17:06 <fizbin> int-e: I didn't say it would require applicative, just that it would be reminiscent of the particular way I reformulated the liftA functions yesterday, which you can see in the comments on http://hpaste.org/87615
07:17:24 <fizbin> And indeed:
07:17:40 <quchen> joe9: Not sure. I never compared profiling to normal runs. If you have lots of libraries without profiling enabled, you've got sort of a problem though.
07:17:54 <fizbin> > ((.) . (.)) not && False False
07:17:55 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
07:17:56 <lambdabot>              with actual type...
07:18:17 <quchen> joe9: I usually enable profiling libs right after I install GHC, so all libs I install support it
07:18:18 <ramses_> :t (||) `on` not -- badkins
07:18:20 <lambdabot> Bool -> Bool -> Bool
07:18:45 <quchen> joe9: If you didn't do that you'll basically have to reinstall half of Haskell (or find a smarter way than mine to accomplish the same thing)
07:18:48 <fizbin> > ((.) . (.)) not (&&) False False
07:18:50 <lambdabot>   True
07:18:57 <joe9> quchen, ok, thanks. enable-profiling in ~/.cabal/config?
07:19:00 <badkins> you guys are bending my brain
07:19:17 <joe9> quchen: do you enable it for executable-profiling too?
07:19:24 <tromp> :t (.) . (.)
07:19:25 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
07:19:25 <fizbin> @src on
07:19:26 <lambdabot> (*) `on` f = \x y -> f x * f y
07:19:28 <quchen> joe9: Exactly. You may also want to enable "shared" (for shared libraries) and docs as well.
07:19:41 <quchen> I'm not sure what executable-profiling is.
07:19:41 * Lethalman doesn't care about executable-profiling
07:19:56 <ramses_> fizbin: it applies the function on both inputs first
07:20:17 <fizbin> ramses_: Hence the swapping of (||) for (&&)
07:20:19 <joe9> I cannot do cabal install --reinstall world?
07:20:28 <joe9> with the profiling turned on?
07:20:33 <badkins> ramses_: what is on  ?
07:20:34 <quchen> joe9: Oh, I think executable-profiling is for modules that produce only an executable. You don't need that.
07:20:37 <badkins> not in my book
07:20:41 <acube> :t on
07:20:43 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
07:20:46 <acube> that's on
07:20:48 <quchen> What you need is library-profiling (and maybe "shared" and "documentation").
07:21:09 <ramses_> badkins: (f `on` h) x y == f (h x) (h y)
07:21:19 <badkins> ok
07:21:28 <fizbin> badkins: 'on' is a function that takes a two-param function f and a one-param function g and creates a two param function \x y -> f (g x) (g y)
07:21:45 <quchen> joe9: If you've got time you can try that, yes. But changing lots of libs may cause unexpected problems (in my experience), so be ready to do a clean reinstall (deleting .ghc and .cabal) just in case ;(
07:22:17 <fizbin> So that's why ((||) `on` not) is equivalent to nAnd.
07:22:35 <badkins> fizbin: thx
07:22:43 <quchen> `on` is probably called like it is because it's sometimes used for (compare `on` ...)
07:22:44 <badkins> so much to learn, but it's fun
07:23:05 <badkins> quchen: yeah, name wasn't very descriptive
07:23:08 <fizbin> But I'm still noodling with ( (.) . (.) )
07:23:21 <quchen> fizbin: do you understand fmap?
07:23:24 <quchen> fmap . fmap?
07:23:24 <acube> :t (not.) . (&&)
07:23:26 <lambdabot> Bool -> Bool -> Bool
07:23:38 <quchen> fizbin: (.).(.) is fmap.fmap for Reader :-)
07:23:44 <quchen> (Also boobies.)
07:23:48 <fizbin> quchen: Well… the implications of fmap get weird.
07:24:04 <fizbin> And in particular of things like fmap.fmap.fmap
07:24:18 * acube forgot why long chains of fmap fmap fmap fmap fmap ... get equavilent to shorter ones
07:24:19 <quchen> > fmap (+1) [1,2,3]
07:24:21 <lambdabot>   [2,3,4]
07:24:29 <quchen> > (fmap.fmap) (+1) [[1,2,3], [4,5,6]]
07:24:31 <lambdabot>   [[2,3,4],[5,6,7]]
07:24:35 <acube> :t fmap fmap fmap
07:24:37 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
07:24:39 <acube> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap
07:24:40 <lambdabot> (Functor f3, Functor f2, Functor f1, Functor f) => f (f1 (f2 (a -> b))) -> f (f1 (f2 (f3 a -> f3 b)))
07:24:56 <quchen> :t flip flip flip
07:24:58 <lambdabot> (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
07:25:00 <fizbin> acube: (fmap fmap) and (fmap . fmap) are two very different things.
07:25:05 <acube> fizbin: i know
07:25:18 <ramses_> fizbin: fmap . fmap == fmap fmap fmap
07:25:27 <joe9> quchen: is there any way to get the behaviour of +RTS -xc within ghci?
07:25:50 <fizbin> So (.) takes a 1-param f and a 1-param g and creates \x -> f (g x).
07:26:15 <fizbin> (.) . (.) takes a 1-param f and a 2-param g and creates \x y -> f (g x y)
07:26:46 <fizbin> And (.) . (.) . (.) f g is \x y z -> f (g x y z)
07:27:06 <fizbin> I think. I must prove that the relation really holds going forward.
07:28:06 <fizbin> :t (.) . (.) . (.) . (.) . (.) $ id
07:28:08 <lambdabot> (a -> a1 -> a2 -> a3 -> a4 -> c) -> a -> a1 -> a2 -> a3 -> a4 -> c
07:28:40 <acube> :t fmap . fmap . fmap . fmap
07:28:42 <lambdabot> (Functor f3, Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
07:28:46 <fizbin> Huh. So (.) . (.) . (arbitrary number of .s) $ id is just id (with a restricted domain)
07:29:31 <acube> so (.) . (.) . (.) . (.) f g applies function f to a function g, and the more (.)'s you use, the more arguments g can have?
07:29:53 <ramses_> fizbin: it's actually easier with the types produced by using fmap instead of (.), less arrows
07:31:09 <ramses_> every extra two fmaps give an extra layer of (a ->) which you are lifting the initial function through
07:31:10 <badkins> ramses_: I do like the syntax of .:  one dot with two dots is a good mnemonic, I just still can't get my head round composing composition with composition!
07:31:57 <acube> :t (>=>) `asAppliedTo` id
07:31:59 <lambdabot> Monad m => (m b -> m b) -> (b -> m c) -> m b -> m c
07:32:27 <acube> :t (>=>)
07:32:29 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
07:33:31 <ramses_> badkins: I understand it best by viewing functions as functors, and fmap then let's you change their result. A function (a -> b) is a box which, given an a, returns a b, and fmap f with (f:: b -> c) on that function gives a new box which, given an a, gives you a c
07:34:30 <badkins> ramses_: I think it's the currying that confused me with composition
07:34:31 <ramses_> then "(not .) . (&&)" could be written as "fmap not . (&&)"
07:34:52 <nh2> what's the status of the scoutess project?
07:35:32 <ramses_> badkins: ah, maybe because you forgot (->)'s right associativeness? a -> b -> c == a -> (b -> c)
07:35:59 <badkins> no, it's just harder to visualize than (Bool,Bool) -> Bool for me
07:36:08 <badkins> the "unwrapping" during composition
07:36:41 <badkins> I know && returns a function given a boolean, but when combining that with two successive compositions, it's a little confusing for newbies like me :)
07:36:46 <ramses_> the uncurried version doesn't compose well at all, I've got that problem all the time with scala code
07:37:17 <badkins> ramses_: why so?  seems not . &&   works ok if && is uncurried
07:37:36 <Eduard_Munteanu> :t not . &&
07:37:38 <lambdabot> parse error on input `&&'
07:37:43 <Eduard_Munteanu> :t not . (&&)
07:37:45 <badkins> easy to visualize on paper diagram also && is a box with 2 in 1 out, not is a box with 1 in 1 out
07:37:45 <lambdabot>     Couldn't match expected type `Bool' with actual type `Bool -> Bool'
07:37:45 <lambdabot>     Expected type: Bool -> Bool
07:37:45 <lambdabot>       Actual type: Bool -> Bool -> Bool
07:37:49 <Eduard_Munteanu> :t not .: (&&)
07:37:51 <lambdabot>     Not in scope: `.:'
07:37:51 <lambdabot>     Perhaps you meant one of these:
07:37:51 <lambdabot>       `.' (imported from Prelude),
07:37:59 <Eduard_Munteanu> Grr.
07:38:00 <badkins> Eduard_Munteanu: not the point, but thanks - was in a hurry
07:38:13 <ramses_> yes, in this particular case, but you constantly run into issues when functions are uncurried
07:38:49 <badkins> ramses_: I can see a disadvantage in not being able to use partial application with uncurried functions
07:40:49 <ramses_> badkins: and eta reductions become a mess
07:41:08 <ramses_> they change the type
07:41:16 <danr> :t (not .) . (&&)
07:41:17 <lambdabot> Bool -> Bool -> Bool
07:42:42 <fizbin> :t fmap . fmap not &&
07:42:44 <lambdabot> parse error (possibly incorrect indentation)
07:42:53 <fizbin> :t (fmap . fmap) not (&&)
07:42:55 <lambdabot> Bool -> Bool -> Bool
07:43:08 <fizbin> :t fmap . fmap not (&&)
07:43:10 <lambdabot>     Couldn't match expected type `a0 -> b0' with actual type `Bool'
07:43:10 <lambdabot>     Expected type: Bool -> a0 -> b0
07:43:10 <lambdabot>       Actual type: Bool -> Bool
07:46:23 <fizbin> :t let opy op a b = a . op . b in (opy (+)) . (opy (+)) . (opy (+))
07:46:25 <lambdabot> Num b => ((b -> b) -> c) -> (a -> b) -> a -> b -> b -> c
07:46:59 <fizbin> :t let opy op a b = a . op . b in (opy (+)) . (opy (+)) . (opy (+)) id
07:47:01 <lambdabot> (Num b1, Num b) => ((b -> b) -> b1) -> (a -> b) -> a -> b -> b1 -> b1
07:47:30 <Ankhers> What is the difference of b and b1 in that scenario?
07:48:45 <fizbin> Not sure yet. I'm not entirely sure where I'm going with this.
07:49:25 <Ankhers> I just don't understand why there is a b and b1 that are both of type Num
07:49:36 <Ankhers> But... I'm still a newb...
07:49:57 <LVCIFER> hello. can someone please help me? I am unable to install haskell. I always get stuck and I get the message : extract, error writing to file libHSghc-7.4.2_p.a What seems to be the problem? I'm using win7
07:50:13 <geekosaur> Ankhers, consider op = fromIntegral
07:50:37 <hpaste> fizruk pasted “Lift inside of FreeT” at http://hpaste.org/87676
07:51:26 <fizruk> hi! is there a common name/definition for this? http://hpaste.org/87676
07:51:39 <geekosaur> because (+) gets used on both sides, op can be assumed to go from some Num instance to some Num instance, but it can't be assumed that they're the same (fromIntegral, floor, etc.)
07:52:04 <taylorgb_> LVCIFER: Are you using the haskell platform installer?
07:52:06 <fizruk> it's just a lift function of type FreeT f m a -> FreeT f (t m) a
07:52:21 <LVCIFER> taylorgb, yes I am.
07:53:21 <Ankhers> geekosaur: Noted, thanks.
07:54:47 <geekosaur> also note that *we* may be able to see that there is no sensible function that can convert as needed to chain them together, but the compiler can't (and, if you don't actually evaluate it, there is at least one value of op that will typecheck even in a chain: undefined)
07:55:13 <taylorgb_> Hrm. Seems to work okay here with the latest
07:55:33 <geekosaur> disk space? permissions?
07:55:43 <geekosaur> quota?
07:56:19 <geekosaur> on the less likely but possible end, failing disk? (check /var/log/messages or etc.)
07:56:20 <LVCIFER> permissions ok. disk space, little over 1GB
07:56:29 <taylorgb_> It's windows, geekosaur.
07:56:37 <geekosaur> oh
07:56:43 <acube> fizruk: You may be interrested in the mmorph package
07:56:48 <acube> @hackage mmorph
07:56:49 <lambdabot> http://hackage.haskell.org/package/mmorph
07:56:52 <taylorgb_> Is there an existing installation?
07:57:00 <LVCIFER> yes.
07:57:36 <taylorgb_> You're not running ghci or anything I assume? And the setup elevates correctly for you?
07:57:53 <acube> fizruk: I think your function would be hoist lift
07:58:19 <LVCIFER> no, I'm not running anything. And the setup is correct.
07:58:38 <fizbin> > let opy a b = a . (+) . b in (opy.opy.opy) (flip (ap (*)) 10) read "3" 4 5
07:58:40 <lambdabot>   220
07:58:50 <fizbin> Now I wonder what that means.
07:58:59 <taylorgb_> Anti-virus software could potentially be blocking the file access. I know that Avast/Avira does this sometimes.
07:59:06 <fizruk> acube: indeed, hoist lift it is, thanks
07:59:17 <taylorgb_> If you're using such a thing it might be worth disabling resident protection briefly then trying to re-run the installer
07:59:27 <nh2> Igloo: do you know where the base patches for the Functor->Monad business are?
08:04:19 <LVCIFER> I disabled my antivirus. I get the same message during the installation.
08:04:59 <Igloo> nh2: No, sorry
08:05:13 <Ankhers> LVCIFER: Are you installing with admin rights? Do you have Disk Space?
08:05:35 <Igloo> nh2: But unless they're recent, it'll probably be just as easy to recreate them
08:05:59 <LVCIFER> yeah, admin rights and enough disk space.
08:06:10 <nh2> Igloo: ok, thank you!
08:06:55 <LVCIFER> could the firewall be the problem? PC tools firewall plus.
08:09:51 <fizbin> :t hoist
08:09:52 <lambdabot> Not in scope: `hoist'
08:09:59 <Ankhers> LVCIFER: A firewall is protection from the network. I highly doubt that is the problem, unless the 'firewall' is doing something it should not be doing.
08:11:00 <LVCIFER> yeah, I know what a firewall is. But this firewall also does some stuff on the hard drive; manages installing permissions etc.
08:11:42 <LVCIFER> its got some other options integrated into it.
08:11:51 <LVCIFER> *it's
08:12:31 <Ankhers> May as well give it a try.
08:13:46 <benj_> I guess those bits are the "plus" part
08:14:32 <benj_> sounds kind of partially applied, (firewall +)
08:17:48 <joe9> does anyone use a different "install-dirs user" for cabal? could you please share it with me? I want to split the .cabal into a cabal config folder and another for bin/lib.
08:17:57 <joe9> not sure if anyone has already done that.
08:19:51 <ParahSailin> "cabal: <file descriptor: 9>: hardware fault" i'm sure there is a hardware fault... but how do i find out more than that
08:19:53 <doomlord> http://pastebin.com/LxVKNbxA tried implementing vectorspaces again based on advice here, but feels very weird
08:20:09 <mauke> The paste LxVKNbxA has been copied to http://hpaste.org/87677
08:20:37 <applicative_> hah, Why is it hard to uninstall Haskell Platform 2011.2.0.1 sometimes  There are times when people had to take computers to a store asking the technicians to solve the frustrating uninstall problem when they fail to uninstall Haskell Platform 2011.2.0.1, which wasted them more time and took them a large amount of money.
08:22:36 <Hafydd> Once you install the Haskell Platform, there is no going back. Don't even try.
08:24:29 <mauke> 5: hardware fault (Input/output error)
08:24:47 <applicative_> Hafydd: sorry that was silly; the  generated page even has "Download: Microsoft Windows Haskell Platform 2011.2.0.1 Removal/Uninstall Tool  Tested Malware & Virus Free by McAfee™" etc etc
08:24:51 <amyers> Hafydd: (Having never installed HP) why is that?
08:25:03 <applicative_> doomlord: what is wrong, the boilerplate?
08:25:35 <Hafydd> Hahah.
08:25:56 <Hafydd> amyers: I was not serious.
08:26:06 <amyers> ah, haha
08:26:15 <doomlord> well this is more compact, i'd been advised to look into <$> and <*> ... and I tried using nameless elements with destructuring instrad of the usual C struct {x,y,z} .. which gets clunky in haskell 's record syntax
08:27:37 <doomlord> is there something like  C++ std::array<T,N> which could do the n-dimensional stuff better than my Vec2,Vec3,Vec4
08:28:47 <dcoutts_> doomlord: the ordinary Data.Array does multi-dimensional arrays
08:29:12 <doomlord> will that be efficient for small fixed-size arrays - 2,3,4 elements only
08:29:35 <dcoutts_> oh no, not really
08:29:46 <dcoutts_> I thought you meant multi-dimensional arrays
08:29:52 <dcoutts_> not short fixed-size
08:30:31 <doomlord> oh no, sorry for confusion - n-dimensional 'vector' as in x[y[z[w]]]
08:30:56 <arkeet> doomlord: you can have fixed-size vectors by encoding natural numbers in the type level
08:31:03 <arkeet> x[y[z[w]]] ???
08:31:15 <doomlord> x or x,y  or x,y,z or x,y,z,w
08:31:22 <doomlord> []=optional
08:31:32 <arkeet> I have no idea what that would mean.
08:31:47 <dwcook> A sequence of length at most 4, in other words?
08:31:52 <doomlord> yes
08:32:25 <doomlord> and the type is a fixed length... e.g. arrays of 3d coordinates
08:33:14 <applicative_> arkeet: I think there will be trouble with some of the instances if he uses the familiar method with type level naturals no?
08:33:16 <arkeet> I'm not sure what you mean. do you want a single type that contains vectors of different sizes?
08:33:24 <arkeet> applicative_: like what?
08:33:25 <doomlord> the C++ method is std::array<T,N>
08:33:55 <arkeet> or you want a bunch of types, one for each size?
08:34:04 <arkeet> (i.e. parametrized by a natural)
08:34:16 <doomlord> i'd certainly 'typedef' them from the original ... vec3, vec4 ..
08:34:29 <applicative_> ooh, wowser, google hits the gold http://stackoverflow.com/a/10531030/315013
08:34:58 <doomlord> type  vec3 a = HaskelsVersionOfCplusPLusStdArray a 3
08:35:07 <arkeet> applicative_: ah
08:35:25 <applicative_> so it can be done with the customary indirection
08:36:22 <camio> Does anyone know how to pronounce De Bruijn? As in "Nicolaas Govert de Bruijn"?
08:36:55 <nlogax> camio: http://sv.forvo.com/word/nicolaas_govert_de_bruijn/#nl
08:37:15 <joaopizani> camio: De "ui" sound is something like saying "house" with a scottish accent
08:37:28 <joaopizani> camio: :P  I am living in the Netherlands for 1 year now :)
08:37:49 <nlogax> Sounds a lot like 'ö' in my language
08:38:01 <joaopizani> nlogax: which language?
08:38:07 <nlogax> joaopizani: Swedish
08:38:18 <joaopizani> nlogax: ahhh nice, it's my next target :)
08:38:25 <nlogax> :)
08:38:27 <camio> Thanks all for the tips.
08:38:46 <camio> Twisting my toungue to pronounce it is the next step :)
08:39:08 <nlogax> doomlord: Would type Vec3 a = (a, a, a) be bad?
08:39:18 <sleepynate> camio: are you american?
08:39:28 <camio> sleepynate: yep
08:39:36 <sleepynate> day broy in
08:39:47 <doomlord> nlogax did i need to make it 'data' to implemnt fmap and so on - or can i implement those for tuples too. or are they even already given for tuples...
08:39:54 <fizbin> So the vowel sound is like the "oo" in the Californian slang that abbreviates "cool" to drop the "l" sound.
08:40:39 <nlogax> doomlord: No Functor instances that I can see, but you can write them
08:41:22 <mauke> > fmap show (42, 'c')
08:41:24 <lambdabot>   (42,"'c'")
08:41:31 <nlogax> Oh
08:41:33 <mauke> > fmap show (42, 'c', "a")
08:41:35 <lambdabot>   No instance for (GHC.Base.Functor ((,,) t0 GHC.Types.Char))
08:41:35 <lambdabot>    arising from...
08:41:51 <applicative_> or maybe not. he can't write a functor instance for (a,a,a)
08:42:21 <fizbin> > fmap show ((42, 'c'), (6, "y"))
08:42:23 <lambdabot>   ((42,'c'),"(6,\"y\")")
08:42:35 <applicative_> doomlord: you can use LANGUAGE DeriveFunctor to get rid of those few lines ... deriving (Show, Eq, Ord, Functor ...)
08:43:02 <doomlord> deriving functor... hmm let me try
08:43:55 <LVCIFER> no luck.
08:44:01 <dwcook> You could write a newtype and write a Functor instance for that, no?
08:44:40 <doomlord> ok, thanks, 'DeriveFunctor' deriving(..Functor..) works...
08:45:04 <dwcook> newtype Vec3 a = (a, a, a); instance Functor Vec3 where { fmap f (x, y, z) = (f x, f y, f z) }
08:45:08 <doomlord> although i've benefited from manually writing it
08:45:32 <dwcook> Err, newtype Vec3 a = Vec3 (a, a, a)
08:45:56 <dwcook> and fmap f (Vec3 (x, y, z)) = …
08:46:38 <acube> is type X a = (a,a,a); instance Functor X where fmap f (x,y,z) = (f x, f y, f z) valid haskell?
08:47:00 <acube> (with TypeSynonymInstances maybe?)
08:47:01 <monoidal> acube: No. Type synonyms have to be completely applied.
08:47:11 <acube> ah right
08:47:18 <monoidal> acube: Type synonyms essentially work like macros in C
08:48:07 <applicative_> dwcook: oh yes, but then the indirection seems odd, why not Vec3 a a a   Later for example he might find occasion to make the fields strict
08:48:33 <dwcook> Depends on what it's used for, I suppose.
08:51:10 <applicative_> yeah
09:02:24 * fizbin thinks http://hackage.haskell.org/package/tardis is a great package name, and probably an appropriate use of the word.
09:02:49 <fizbin> Though perhaps it should be used for some lazy data structure that is "bigger on the inside"
09:03:03 <Taneb> As far as I am aware, Haskell is the only language with a time-travel dsl
09:03:09 <Taneb> *only serious language
09:04:20 <fizbin> Taneb: Well, languages with continuations have stuff that looks like time travel, sort of.
09:04:48 <fizbin> And I've certainly implemented a prophetic dsl (i.e. the amb operator) in them.
09:06:49 <applicative_> hm, a class MonadTardis where sendFuture :: fw -> m ()
09:08:03 <fizbin> :t rec
09:08:04 <lambdabot>     Not in scope: `rec'
09:08:05 <lambdabot>     Perhaps you meant one of these:
09:08:05 <lambdabot>       `rem' (imported from Prelude), `re' (imported from Control.Lens)
09:08:06 <statusfailed> ahhhhh, what the hell is a lattice
09:08:58 <fizruk> hi! I'm trying to build an agent-system, with monadic agent and comonadic environment. This is what I got: http://pastebin.com/eZTe3RU5
09:09:16 <mauke> The paste eZTe3RU5 has been copied to http://hpaste.org/87680
09:09:51 <fizruk> I have some troubles with comonadic environment, and I believe, I do something wrong about it (because it is difficult to build some worlds)
09:10:36 <fizruk> Can anyone review my code? I'd highly appreciate that! Some questions are marked with XXX.
09:11:11 * applicative_ wont look at those then
09:11:16 <Hafydd> XD
09:11:40 <doomlord> are there downsides to the langauge pragmas : DeriveFunctor,DeriveFoldable ... are these experimental,potentially buggy features?
09:17:59 <bitonic> doomlord: those are pretty safe.  GeneralisedNewtypeDeriving isn’t
09:18:37 * applicative_ dimly remembers some bug with DeriveFunctor making an inefficient instance. 
09:18:46 <mauke> ah, yes
09:18:52 <mauke> excessive etaizing
09:18:55 <applicative_> but it was cured immediately
09:19:10 <fizbin> Anyone have somewhere an explanation of how statements with the "rec" keyword (Under {# LANGUAGE DoRec #}) translate in terms of normal lambda bindings and >>= calls?
09:19:10 <applicative_> mauke remembers
09:19:45 <mauke> http://hackage.haskell.org/trac/ghc/ticket/7436
09:22:35 <applicative_> well, maybe not fixed.
09:22:46 * applicative_ is using getFuture
09:23:23 <applicative_> fizbin the wiki has a page on 'monadfix'
09:23:33 <applicative_> http://www.haskell.org/haskellwiki/MonadFix
09:23:51 <fruitFly_> why can't I initialize a string in tryhaskell.org ... let b = "bee" ..  not working?
09:24:34 <applicative_> fizbin: and in the guide http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/syntax-extns.html
09:24:55 <DrTeggy> fruitFly_: let b = "bee" in b
09:25:03 <Hafydd> fruitFly_: you enter expressions, not declarations.
09:25:30 <fruitFly_> ok thanks DrTeggy  Hafydd
09:26:01 <applicative_> > let b = "bee"; c = "see" in unwords [c,b]
09:26:03 <lambdabot>   "see bee"
09:33:02 <fruitFly_> what's wrong with this?.. trivially simple main = print (elemIndex 'a' [a..z])
09:33:54 <sipa> > elemIndex 'a' [a..z]
09:33:56 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
09:33:56 <lambdabot>              with actual type...
09:34:01 <sipa> :t elemIndex
09:34:03 <lambdabot> Eq a => a -> [a] -> Maybe Int
09:34:15 <sipa> > elemIndex 'a' ['a'..'z']
09:34:18 <lambdabot>   Just 0
09:34:25 <fruitFly_> oh lol
09:34:28 <fruitFly_> thanks :)
09:35:53 <Taneb> I'm annoyed that web-routes uses "url -> [(Text, Maybe Text)] -> Text" and hamlet uses "url -> [(Text, Text)] -> Text" for I think the same thing
09:36:23 <mixmixmix> hi, i have a GADT i'm trying to recursively travese. data Formula ts where Forall :: [a] -> (Term a -> Formula as) -> Formula (a, as). However when i use the function on a Term a, i get a 'Formula as'  and ghc complains saying i need Formula ts
09:37:27 <fizruk> mixmixmix: could you hpaste code?
09:45:25 <fruitFly_> what's wrong with this?
09:45:28 <fruitFly_> http://ideone.com/ai4P6P#view_edit_box
09:45:57 <monoidal> fruitFly_: it's Data.Word
09:46:17 <monoidal> fruitFly_: and ":t" is GHCi syntax, not a function
09:46:52 <monoidal> fruitFly_: and "[Word8]" is not a value, it's already a type
09:47:46 <monoidal> fruitFly_: what did you want it to output?
09:47:50 <fruitFly_> monoidal: Thanks .. I don't have a dev environment and I'm finding it hard leaening
09:48:08 <monoidal> fruitFly_: you can't install HP?
09:48:23 <fruitFly_> monoidal: I'm trying to understand what's special about [Word8]
09:48:29 <monoidal> fruitFly_: there's nothing special
09:48:36 <monoidal> fruitFly_: it's a normal type, list of Word8
09:48:41 <fruitFly_> monoidal: I temporarily using a friends os x 10.5.8 ... dn't know how to install it
09:49:19 <monoidal> fruitFly_: you can talk privately to lambdabot or use http://tryhaskell.org/
09:49:22 <fruitFly_> monoidal: does it have to be just 0s and 1s
09:49:55 <ion> Does what have to be?
09:50:05 <fruitFly_> ion: [Word8]
09:50:15 <monoidal> > 2 :: Word8
09:50:18 <lambdabot>   2
09:50:20 <ion> > maxBound :: Word8
09:50:24 <lambdabot>   255
09:50:24 <monoidal> Word8 is a 8-bit word
09:50:59 <fruitFly_> monoidal: so an 8bit string?... or is it just a word
09:51:56 <monoidal> fruitFly_: a collection of 8 bits, can represent a value from 0 to 255. for strings, use [Char]
09:52:47 <arnsholt> Say I have a function readThing that reads a Thing from a Handle. Is there an idiom to apply it repeatedly to get a [Thing]?
09:53:12 <monoidal> arnsholt: what are the types?
09:54:32 <arnsholt> monoidal: The Thing will eventually be a data type representing the fields in the file (it's a line-based format), but for the time being I'm just splitting each line with words
09:54:35 <Botje> arnsholt: if you know how many to read, replicateM n readThing
09:54:49 <monoidal> arnsholt: readThing :: Handle -> IO Thing?
09:54:54 <arnsholt> Yah
09:55:26 <monoidal> then, you can do what Botje said, or loop till EOF (I don't know anything elegant for this)
09:56:01 <arnsholt> Loop 'till EOF it is then, since I don't know how many records there are
09:56:28 <arnsholt> Thanks for the help, anyways. I'm sure replicateM will come in handy at some point =)
09:56:41 <fruitFly_> monoidal: can I operate on [Word8] like I wold a string... like take it's last element, head etc?
09:57:01 <monoidal> fruitFly_: you can take last element, head etc. on [a] for any a
09:58:09 <monoidal> arnsholt: f handle = do x <- hIsEOF handle; if x then return [] else liftM2 (:) (readThing handle) (f handle) - something like this
10:01:22 <kennyd> fruitFly_ String is just [Char]
10:02:09 <viller> why does show add quotes? Is there a function Show a => a -> String that doesn't add quotes?
10:03:14 <viller> sorry, it's only a problem with strings
10:08:51 <ParahSailin> anyone have experience with fay?
10:09:11 <ParahSailin> i dont understand what it wants me to do here "fay: Constructor 'Just' was not found in stateRecords, did you try running this through GHC first?"
10:09:33 <napping> Is fay supposed to be a subset of Haskell?
10:09:56 <Taneb> napping, yes
10:10:03 <geekosaur> ParahSailin, I read that one as "I'm not smart enough to know what went wrong here, try using a real haskell compiler"
10:10:05 <Taneb> I believe part of its compilation uses GHC
10:10:14 <geekosaur> hm
10:10:27 <napping> I read it like geekosaur
10:11:00 <geekosaur> viller: Show is for serialization, not for pretty printing. With serialization, you want your strings to be delimited and appropriately encoded so as not to lose information
10:11:11 <geekosaur> If you want pretty printing, use a pretty printing package
10:11:28 <arnsholt> monoidal: Ooh, thanks! That looks very promising!
10:12:42 <monoidal> viller: the convention is that result of show should be a string that is valid haskell; therefore show quotes and escapes (i.e. show "\n" == "\\\n")
10:12:51 <ijp> what's the state of linear languages today?
10:15:14 <viller> thanks geekosaur monoidal. I already understood that from googling. The problem is the exercise we were given. I have to write a pretty printer for a type with a type parameter (don't know if it's the correct way to say this) which is in the Show class. I guess there's no way to make it work ok for strings.
10:15:35 <viller> "we were given" <- a school exercise
10:16:13 <viller> I'll just go with "\"ugly\"" then
10:16:54 <monoidal> viller: quotes is normal way to output strings. If there were no quotes, you wouldn't know where they start and where they end.
10:18:12 <monoidal> viller: also the ugliness is partly a result of the fact that GHC calls show to output a string. try putStrLn and "\"ugly\"" will be shown as "ugly"
10:19:54 <viller> monoidal: putStrLn is IO(). I can't use it in a pretty printer.
10:20:09 <applicative_> > text "hi"
10:20:13 <applicative_> > text $ show "hi"
10:20:15 <lambdabot>   mueval: ExitFailure 1
10:20:15 <lambdabot>  mueval: Prelude.undefined
10:20:16 <lambdabot>   "hi"
10:20:21 <applicative_> :(
10:20:35 <applicative_> > text $ show "hi"
10:20:38 <lambdabot>   "hi"
10:20:44 <tac> :t show $ ?x "hello world"
10:20:44 <applicative_> > text "hi"
10:20:46 <lambdabot> (?x::[Char] -> a, Show a) => String
10:20:46 <lambdabot>   hi
10:21:07 <monoidal> viller: show the final output using putStrLn. you will not see "\"something\"" but  "something"
10:21:14 <otters> oh, *that* is what people use implicit parameters for
10:21:18 <tac> > show $ "Hello " ++ ?x
10:21:22 <lambdabot>   mueval-core: internal error: PAP object entered!
10:21:22 <lambdabot>      (GHC version 7.4.2 fo...
10:21:30 <tac> PAP object entered!
10:21:38 <amyers> > show ['"', 'h', 'i', '"']
10:21:40 <lambdabot>   "\"\\\"hi\\\"\""
10:21:45 <monoidal> otters: TypeHoles supersede this usage, though.
10:21:49 <otters> right
10:21:53 <otters> :t show $ "Hello " ++ _
10:21:55 <lambdabot> Pattern syntax in expression context: _
10:21:58 <amyers> > ['"', 'h', 'i', '"']
10:22:00 <lambdabot>   "\"hi\""
10:22:06 <amyers> > putStrLn  ['"', 'h', 'i', '"']
10:22:08 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
10:22:08 <lambdabot>    arising from a use of ...
10:22:27 <otters> what version of GHC has TypeHoles?
10:22:36 <monoidal> HEAD
10:22:45 <amyers> > putStrLn "\"hi\""
10:22:49 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
10:22:50 <lambdabot>    arising from a use of ...
10:22:54 <monoidal> amyers: you can't do IO with lambdabot
10:22:59 <amyers> ah
10:23:02 <amyers> Didn't know that
10:23:17 <amyers> Makes perfect sense though
10:23:20 <applicative_> it used to just say <IO> or something mysterious didn't it?
10:23:48 <viller> are haskell strings UTF-8?
10:23:57 <luite> no
10:24:15 <luite> viller: haskell Char stores a unicode codepoint
10:24:49 <luite> the String itself has no specific encoding, but you can set the encoding of the handle when outputting it
10:24:51 <geekosaur> haskell strings are unicode, but not internally utf8
10:26:02 <c_wraith> applicative_: yeah, there used to be a Show instance for (Typeable a) => IO a
10:26:12 <applicative_> ah
10:28:44 <applicative_> viller what is the trouble you are having with strings? maybe the matter can be clarified
10:28:45 <viller> haskell prints a backslash followed by the unicode value of a character instead of the character itself :(
10:29:01 <applicative_> inside ghci?
10:29:08 <viller> yes
10:29:16 <luite> viller: try putStrLn to really output it
10:29:28 <geekosaur> ghci invokes show automatically. use putStr or putStrLn
10:29:38 <luite> viller: otherwise it uses teh Show instance, which tries to generate something that looks like haskell code
10:29:47 <viller> thanks that worked
10:31:58 * hackagebot applicative-numbers 0.1.2 - Applicative-based numeric instances  http://hackage.haskell.org/package/applicative-numbers-0.1.2 (ConalElliott)
10:33:12 <viller> I think I already had these issues when I was first learning haskell a year ago but I have just forgotten :)
10:33:58 <c_wraith> viller: that's more or less the same thing every language with a repl gives you
10:34:20 <c_wraith> viller: certainly python and ruby work the same way.
10:35:10 <viller> I wasn't blaming Haskell or GHCi. I just didn't know these things.
10:35:24 <c_wraith> viller: it's just a consequence of needing to display many different types, and wanting do display the number 5 differently from the string "5"
10:39:50 <doomlord> * wuyun has quit (Quit: Leaving)
10:39:51 <doomlord> <doomlord> are haskell integers boxed (bits reserved for GC ...30 or 31bits, something liek that) .. or a power-of-2 size
10:41:35 <geekosaur> the haskell standard allows bits to be reserved, but ghc does not
10:41:48 <lispy> > maxBound :: Int
10:41:52 <lambdabot>   9223372036854775807
10:42:01 <lispy> > 2^64-1
10:42:04 <lambdabot>   18446744073709551615
10:42:16 <geekosaur> hm, maybe I'm misremembering...
10:42:20 <mm_freak> doomlord: both
10:42:20 <geekosaur> oh
10:42:22 <lispy> geekosaur: you're right
10:42:28 <mm_freak> doomlord: in GHC at least
10:42:33 <lispy> I think I just wrote the wrong formula :)
10:42:33 <geekosaur> 2^63 don;t forget the sign bit
10:42:43 <doomlord> the sign bit i'm fine with :)
10:42:51 <geekosaur> > 2^63-1
10:42:57 <lambdabot>   mueval: ExitFailure 1
10:42:57 <lambdabot>  mueval: Prelude.undefined
10:43:01 <mm_freak> doomlord: if you want to write portable code you should probably use Int32/Word16/…
10:43:08 <geekosaur> > 2^63-1
10:43:12 <lambdabot>   9223372036854775807
10:43:14 <doomlord> fair enough , int32 ftw
10:43:17 <mm_freak> those are guaranteed to have the given bit size
10:43:32 <lispy> > (maxBound::Int)== 2^63-1
10:43:33 <fizbin> > maxBound :: Int32
10:43:36 <lambdabot>   2147483647
10:43:36 <lambdabot>   can't find file: L.hs
10:43:44 <lispy> > (maxBound::Int)== 2^63-1
10:43:48 <lambdabot>   True
10:44:08 <fizbin> > maxBound :: Int64
10:44:10 <mm_freak> doomlord: btw, usually we just work with Integer and let the implementation optimize the large integer machinery away…  GHC does that (i.e. it doesn't introduce large integers by itself)
10:44:12 <lambdabot>   9223372036854775807
10:44:25 <fizbin> > maxBound :: Word64
10:44:30 <lambdabot>   18446744073709551615
10:44:36 <arkeet> > (maxBound :: Word64) == -1
10:44:40 <lambdabot>   True
10:44:54 <arkeet> > maxBound + 1 == minBound
10:44:59 <lambdabot>   Ambiguous type variable `a0' in the constraints:
10:44:59 <lambdabot>    (GHC.Enum.Bounded a0)
10:44:59 <lambdabot>  ...
10:45:03 <arkeet> > maxBound + 1 == (minBound :: Int)
10:45:06 <lambdabot>   True
10:45:17 <arkeet> really, it didn't pick a default Num instance?
10:45:30 <arkeet> oh
10:45:35 <arkeet> the default would have been Integer.
10:45:50 <mm_freak> arkeet: it does that only when you use operations from certain type classes
10:46:03 <arkeet> isn't Num one of those classes?
10:46:09 <mm_freak> arkeet: but Bounded isn't
10:46:20 <hiato> Hello all, I have a parsec question :) In particular, I'm recursively calling a method of type Parser a and I want to detect the eol and terminate the recursion. I tried to do this with choice [char '\n' >> return foo, bar] but that doesn't seem to work. I'm a noob, what am I overlooking?
10:46:21 <monochrom> the defaulting rules are more complicated than you think
10:46:39 <arkeet> I didn't really think anything of them.
10:46:52 <mm_freak> > let (b1, b2) = (minBound, maxBound) in b1 + 1 == b2
10:46:56 <lambdabot>   Ambiguous type variable `t0' in the constraint:
10:46:57 <lambdabot>    (GHC.Enum.Bounded t0) ar...
10:47:28 <arkeet> what would make sense to me is that Num will only default to Integer or Double, neither of which are Bounded
10:48:08 <Cale> hiato: What you wrote there is a list of what is presumably two parsers
10:48:32 <Cale> hiato: Perhaps you want manyTill
10:48:33 <monochrom> that's right arkeet
10:48:35 <hiato> Cale: yep? The function is foo and the result is bar
10:48:44 <hiato> Cale: ah, ok, let me check this out
10:49:00 <arkeet> so it's exactly what I would have expected, had I thought a little more.
10:50:19 <hiato> Cale: oh wow. Though not actually the solution to this particular problem, it provides a really obvious way to do it otherwise
10:50:42 <Cale> hiato: manyTill p end = (end >> return []) <|> (do x <- p; xs <- manyTill p end; return (x:xs))
10:51:29 <Cale> Perhaps its implementation says something about how to use parsers recursively :)
10:51:55 <hiato> Cale: you are wise as you are kind, thank you :)
10:52:14 <Cale> no problem
10:53:46 <arkeet> > succ ()
10:53:49 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
10:54:39 <tromp> > iterate (map succ) "Haskell"
10:54:43 <lambdabot>   ["Haskell","Ibtlfmm","Jcumgnn","Kdvnhoo","Lewoipp","Mfxpjqq","Ngyqkrr","Ohz...
10:55:51 <xc__> > take 5 $ drop 50 $  iterate (map succ) "Haskell"
10:55:54 <lambdabot>   ["z\147\165\157\151\158\158","{\148\166\158\152\159\159","|\149\167\159\153...
10:56:51 <xc__> hmm :
10:58:15 <ReinH> aninhumer: your lens tutorial is amazing
11:02:20 <xc__> > (take 5 . drop 50)  iterate (map succ) "Haskell"
11:02:25 <lambdabot>   mueval: ExitFailure 1
11:02:25 <lambdabot>  mueval: Prelude.undefined
11:03:52 * geekosaur wishes lambdabot were a bit more stable, sigh. (that's not a failure of your code but something going wrong in the bot)
11:04:30 <fizbin> > (take 5 . drop 50) $  iterate (map succ) "Haskell"
11:04:30 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
11:04:39 <geekosaur> ...
11:04:44 <fizbin> > (take 5 . drop 50) $ iterate (map succ) "Haskell"
11:04:45 <xc__> > take 5 $ drop 100 $  iterate (map succ) "Haskell"
11:04:48 <lambdabot>   ["z\147\165\157\151\158\158","{\148\166\158\152\159\159","|\149\167\159\153...
11:04:48 <lambdabot>   can't find file: L.hs
11:05:24 <fizbin> I suspect my irc client slipped a unicode character in there for mueval to choke on.
11:06:11 <fizbin> > (take 5 . drop 50) $ iterate (map succ) "Haskell"
11:06:16 <lambdabot>   mueval: ExitFailure 1
11:06:16 <lambdabot>  mueval: Prelude.undefined
11:06:24 <fizbin> > (take 5 . drop 50) $  iterate (map succ) "Haskell"
11:06:24 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
11:06:41 <xc__> > take 5 $ drop 10 $  iterate (map succ) "Haskell" -- yep let's not hit the bot
11:06:45 <lambdabot>   ["Rk}uovv","Sl~vpww","Tm\DELwqxx","Un\128xryy","Vo\129yszz"]
11:09:33 <ParahSailin> ok, i have no idea how to make fay pattern match a Maybe
11:09:56 <envogue> does the haskell platform come witht hat erlang lib for distributed computing? what is it called?
11:10:05 <monochrom> does not
11:10:43 <ParahSailin> literally have a file that is "module Derp where derp b = case b of {Nothing -> 1; Just i -> i}" and its telling me "fay: Constructor 'Nothing' was not found in stateRecords, did you try running this through GHC first?"
11:11:18 <c_wraith> that's pretty amazing.
11:11:29 <c_wraith> I'd ask a fay expert about that one
11:11:48 <ReinH> ParahSailin: maybe fay does not appreciate your file's derbiness
11:11:51 <ReinH> *derpiness
11:13:41 <xc__> > (take 3 (iterate (map pred) "Haskell")) ++ ["Erlang"]
11:13:44 <lambdabot>   ["Haskell","G`rjdkk","F_qicjj","Erlang"]
11:13:55 <acowley> ParahSailin: Add a type signature?
11:14:14 <ParahSailin> acowley: tried it both ways, with and without
11:14:17 <acowley> ParahSailin: I just tried out something like your derp in fay's web IDE, and I needed a type signature
11:15:04 <acowley> Did you import Language.Fay.Prelude ?
11:15:57 <ParahSailin> i think it's just called Prelude in the current version
11:16:03 <ParahSailin> because i get "Could not find module `Language.Fay.Prelude'"
11:16:26 <envogue> monochrom: what is that lib called?
11:17:19 <ParahSailin> acowley: ah, seems explicit import of Prelude makes it work
11:17:45 <acowley> ParahSailin: Hooray! I wonder why the web IDE is using an old(?) version
11:18:24 <acowley> envogue: Cloud Haskell
11:18:43 <envogue> ah, yes
11:18:49 <envogue> is it good?
11:18:55 <acowley> I've never used it
11:24:30 <beaky> hello
11:24:47 <beaky> what sorting algo does prelude use to sort its lists
11:25:06 <sproingie> one-line quicksort of course ;)
11:25:11 <mauke> @index sort
11:25:11 <lambdabot> Data.List
11:25:12 <mauke> none
11:25:26 <mauke> (it was a trick question)
11:27:53 <monochrom> I agree. there is not sorting in Prelude
11:30:07 <fragamus> Ok so I have been reading that banana lens envelope barbed wire paper. I got a little lost. Would like for someone to take just one example of morphisms and one associated law and tell me why it helps to have that
11:30:10 <beaky> oh oops I meant in Data.List
11:30:21 <petantik> I'm using vim+hdevtools+syntastic with vim, installed hdevtools with cabal and when I open a haskell file in terminal vim it seems to run fine. However in gvim I encounter "hdevtools: hdevtools is not executable!"
11:30:27 <Taneb> Ugh...
11:30:35 <Taneb> My emacs ghc-mod is playing up
11:31:10 <joe9> I find the +RTS -xc stack trace to be useless:  http://codepad.org/5TIrPW8D . It does not tell which function is throwing that exception.
11:31:13 <Taneb> It's not finding modules that GHC finds easily
11:31:14 <mauke> petantik: your PATH is set by your shell initialization script
11:31:15 <napping> beaky: http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/src/Data-List.html#sort
11:31:18 <joe9> Is there a better trace possible with haskell
11:31:42 <mauke> petantik: your gvim wasn't started from a shell
11:31:52 <petantik> mauke: ahhh, you are correct. I should set this in .xprofile?
11:31:52 <chrisdone> joe9: you can compile with profiling and then there's a -tc argument you can pass as a runtime option. an exception will then print a backtrace (of sorts)
11:31:53 <lambdabot> chrisdone: You have 3 new messages. '/msg lambdabot @messages' to read them.
11:32:07 <beaky> wow  I didn't know mergesort worked on singly-linked lists
11:32:19 <joe9> chrisdone: ok, thanks. will try that.
11:32:32 <beaky> and how elegant mergesort looks in haskell
11:32:55 <chrisdone> joe9: sure. it's in the ghc manual under backtrace/traces somewhere
11:33:03 <acowley> Taneb: Look for a .cabal file somewhere in the ancestors of your current directory
11:33:12 <joe9> chrisdone: does not seem to help either: http://codepad.org/v8YyxIlY
11:33:36 <Taneb> acowley, I hope not, I'm in the home directory
11:34:07 <acowley> Taneb: I once had ghc-mod troubles that were due to a .cabal-dev directory exisint in my home directory. Not sure how it got there, but it really messed things up!
11:34:34 <chrisdone> joe9: tch. tricky
11:34:57 <Taneb> acowley, no .cabal-dev directory
11:35:24 <chrisdone> joe9: ah, maybe you need that argument to specify that every expression should be a point of interest
11:35:35 <chrisdone> i can't remember what it's called. it's a profiling option
11:35:52 <Taneb> acowley, and I can't see any .cabal files anywhere in the ancestry
11:36:07 <chrisdone> joe9: i think this: -fprof-auto
11:36:11 <acowley> chrisdone: auto-all?
11:36:11 <chrisdone> joe9: does that do the trick?
11:36:14 <acube> chrisdone: -auto-all
11:36:20 <chrisdone> ah that one
11:36:22 <chrisdone> yeah
11:36:47 * acube was just searching for that option too atm (thought of -prof-auto first too :P)
11:36:48 <acowley> Taneb: Unfortunately that's my only tip for debugging issues where ghc-mod can't find modules :(
11:36:54 <chrisdone> =)
11:44:42 <joe9> chrisdone: acube: where do I specify the -auto-all? to --make?
11:45:34 <joe9> chrisdone: acube: http://codepad.org/hi0hBlVz still not much info. just a little bit more though.
11:45:48 <acowley> joe9: -prof -auto-all when compiling
11:45:57 <acowley> joe9: You don't need --make with recent GHCs
11:46:31 <joe9> acowley: chrisdone: acube: this is the .hs file http://codepad.org/cevYZN7H
11:47:00 <joe9> I want to figure to which lines 27-54 is causing the error.
11:48:36 <amyers> joe9: http://hpaste.org/
11:48:39 <amyers> is handy
11:49:02 <acowley> joe9: have you tried something as low tech as printfs?
11:49:17 <monochrom> is "(Just device) <- getMyDevice" really what you want? are you sure you won't get Nothing?
11:50:21 <acowley> monochrom: If you don't display confidence, GHC won't respect you.
11:51:02 <jfischoff> haha
11:58:55 * applicative_ wonders how to delete these en masse http://hpaste.org/browse?author=Swarovski or maybe we should devise a mad scheme to destroy whatever instrument is sending htem
12:02:22 <joe9> acowley: monochrom: I can use printf, but, I am tired of mucking around with printf's and am looking for something similar to shell xtrace or verbose output.
12:03:14 <joe9> monochrom: about the Just pattern match. If there is Nothing, I get a message with the line number and I am ok with that.
12:05:32 <monochrom> I don't know of a library for that
12:08:40 <Raynes> I just realized that the new Haskell platform hasn't been released yet. sadpanda.
12:08:50 <Raynes> Target was May 6th. Engineers not meeting deadlines? Unheard of.
12:09:28 <zeta-> is there a new target?
12:09:33 <Raynes> No.
12:09:39 <Eelis> deadlines have to be taken with a grain of salt in volunteer outfits :P
12:09:45 <Raynes> I mean, not on the wiki.
12:09:54 <Heffalump> Eelis: and in commercial organisations :-)
12:09:54 <Raynes> I'm sure they don't intend to go back in time and release it.
12:10:11 <Clint> perhaps you should sue
12:10:21 <Eelis> Heffalump: yeah, but there the "or else" is typically more serious
12:10:25 <Raynes> I don't think there are any really valid time estimations in engineering of any sort.
12:10:41 <Raynes> I think xkcd had an excellent chart for this a while back.
12:10:53 <Heffalump> Eelis: marginally
12:10:57 <Eelis> Raynes: that seems a bit general. for typical tasks i can make estimations like "probably a couple of weeks" or "probably a couple of days"
12:10:59 <geekosaur> Raynes, RC1 is out for some platforms now. there were some GHC and Cabal bugs that needed to be sorted that delayed things a bit; see archive for libraries@haskell.org
12:11:50 <Raynes> Eelis: Non engineers hate that though. I've been asked for a date and a specific time that I'd have something done.
12:11:51 <Raynes> :p
12:12:14 <Eelis> Raynes: yup
12:13:09 <Eelis> just pick a wide upper bound :)
12:13:50 <Michael_> What's the best 2d graphics library for a situation where performance is a small, but significant factor, but ease of use is more important?
12:14:19 <Raynes> Eelis: "February 5th, 2015, 3:28PM."
12:14:31 <Eelis> Raynes: works for me!
12:15:01 <Eelis> if you finish the job a month before that you'll get a promotion
12:15:05 <Raynes> I <3 this new sandbox stuff in cabal.
12:15:29 <Raynes> I wish you could get a ghci instance inside the sandbox. It's only marginally useful for me until then. :<
12:15:33 <c_wraith> Michael_: try Gloss, maybe?
12:15:47 <c_wraith> Michael_: it's not the fastest or most powerful, but it is the easiest to use
12:16:12 <Michael_> c_wraith: Thanks, I'll check it out
12:16:15 <acowley> Michael_: Are you trying to produce a static graphic, or an animation?
12:16:24 <Michael_> animation
12:16:44 <acowley> Then gloss is a good option
12:17:03 <acowley> If you have trouble installing it, you can manually relax the version constraints on OpenGL and GLUT.
12:17:12 <chrisdone> Raynej
12:17:35 <acowley> I also recommend using the GLFW-b backend if you're on a Mac to make emacs/ghci integration better.
12:17:50 <luite> and the javascript backend \o/
12:18:25 <jfischoff> is there a function like maybe for lists? you pass a default value [] and other wise a functions?
12:18:46 <luite> :t listToMaybe
12:18:51 <luite> like this?
12:18:52 <lambdabot> [a] -> Maybe a
12:18:55 <chrisdone> jfischoff: what would the type be?
12:19:11 <luite> (that returns Just (head xs) if it's nonempty
12:19:54 <jfischoff>  b -> ([a] -> b) -> [a] -> b
12:20:16 <chrisdone> aha
12:20:21 <Clint> if x == [] then blah someconst else blah x ?
12:20:51 <chrisdone> jfischoff: http://hackage.haskell.org/packages/archive/higherorder/0.0/doc/html/Data-List-Higher.html
12:21:07 <jfischoff> :p
12:21:14 <Peaker> Pretty terrible that there's no way to get a warning for a partial pattern match on left of <- in a "do" block :(
12:21:22 <jfischoff> yeah I should have hoogled
12:21:54 <ion> do a <- foo; let { Bar b = a } ;-)
12:22:06 <jfischoff> I want it in prelude though :/
12:22:43 <jfischoff> Peaker: one more reason to avoid do notation
12:23:38 <joe9> monochrom: do you think it would be something easy to do with template haskell?
12:23:40 <chrisdone> jfischoff: well, lazy patterns are the same
12:24:10 <monochrom> I don't know
12:24:14 <jfischoff> chrisdone: true, but you have to be explicit about that
12:24:27 <jfischoff> a beginner isn't going to use ~
12:24:35 <Peaker> jfischoff, pointed notation is so much nicer in so many instances...
12:24:56 <chrisdone> > let Just x = undefined in "Yay!" -- gives no warnings
12:25:00 <lambdabot>   "Yay!"
12:25:06 <Peaker> chrisdone, that is annoying too :(
12:25:26 <jfischoff> Peaker: it is unfortunate, but you are right
12:25:27 <Peaker> forget beginners, what if I have a data type like:    data Foo = Foo Int Char         and I use   do { Foo x y <-  ... }  and tomorrow I add:  | Baz ...
12:25:39 <Peaker> (Actually happened to me)
12:25:48 <Peaker> The type checker is supposed to help me find all the broken cases now
12:25:51 <chrisdone> yup
12:26:03 <chrisdone> hm, wait
12:26:07 <simpson> But those aren't broken.
12:26:23 <chrisdone> simpson: they're broken in the sense that they can go wrong, just like a case analysis
12:26:36 <simpson> chrisdone: But there's a well-defined behavior for when that match fails. :3
12:26:39 <chrisdone> i think i actually saw this in a ghc ticket and i vaguely remember there being an explicit warning flag for it…
12:26:59 <jfischoff> chrisdone: I misundstood what you meant, and didn't realize that was true. That's too bad
12:26:59 <simpson> I mean, `fail` in Monads is the problem here, and this is just a symptom, IMO.
12:27:07 <chrisdone> simpson: there's a well-defined behaviour for when lazy patterns fail, it's in the report
12:27:56 <jfischoff> I wonder how hard it would be for the compiler to give a warning in those instances
12:28:20 <simpson> chrisdone: I know. It sucks, but it's there.
12:28:35 <jfischoff> I can't see a fundemental reason why it can't warn, is there one?
12:28:50 <monoidal> chrisdone: there's a separate warning flag for inexhaustive lambdas such as \Nothing -> ..., but I'm unaware about one for do notation
12:29:20 <monoidal> -fwarn-incomplete-uni-patterns
12:29:39 * acube wants -Weverything as clang has
12:29:55 <chrisdone> aha, that's the one
12:30:01 <chrisdone> -fwarn-incomplete-uni-patterns. good one
12:30:02 <Peaker> simpson, sure, "fail" sucks. We can have a flag to require some explicit action to get "fail" involved
12:30:06 <Peaker> (or get a warning)
12:30:31 <Peaker> will that flag catch the "do" case too?
12:30:46 <monoidal> Peaker: the one I mentioned? no
12:30:55 <chrisdone> http://hackage.haskell.org/trac/ghc/ticket/5813
12:31:50 <chrisdone> in other words, feature request made, not implemented yet
12:33:39 <chrisdone> likely to be forgotten forever until someone kicks up a fuss about it again
12:33:48 <chrisdone> (or just implements it)
12:35:50 <jfischoff> I would like to do it … I'll probably forget …
12:35:56 <acowley> I ended up implementing a StateT around Data.Tuple.Strict. Is this available somewhere on hackage? I don't like having such a general thing hanging around in a particular project.
12:36:46 <jfischoff> there should be TH for making your own stack newtypes
12:37:15 <jfischoff> makeMTL [''ErrorT, ''StateT]
12:37:19 <jfischoff> etc...
12:37:48 <jfischoff> generates all the MonadBlah derivings ...
12:38:51 <acowley> I didn't define every last thing you might want in a StateT, and I don't particularly want to bother with it.
12:39:37 <acowley> I'm not sure I like the idea of it being a separate package, either. So I guess it's a lose-lose situation.
12:57:04 * hackagebot monad-loops 0.4.2 - Monadic loops  http://hackage.haskell.org/package/monad-loops-0.4.2 (JamesCook)
12:59:58 <Reite> I want to find all integers within a given range in a large set of integers. It seems that the most efficient way to do this is a range tree, but I cant find any haskell implementation. Is there a better way to do it or is it not a common problem? For reference: http://en.wikipedia.org/wiki/Range_tree
13:00:21 <Ralith> doesn't Data.Set have relevant operators?
13:01:28 <Ralith> Reite: you can do n * log n with Data.Set trivially
13:01:41 <Ralith> well
13:01:54 <Ralith> O(m * log n) where m = size of range
13:02:28 <earthy> that sounds suspicious
13:02:59 <Ralith> ?
13:03:05 <earthy> I'd believe it if the requested range would be at the top of the tree in all cases
13:03:29 <earthy> otherwise I don't see how you're going to beat O(n * logn)
13:03:39 <Ralith> oh, yes, my mistake
13:07:51 <Ankhers> How large is the set?
13:08:47 <Reite> Say 5000 items between 0 and 1 000 000 00
13:09:20 <Reite> But I have to do a lot of lookups and thats why I need it fast
13:09:25 <Reite> and also multi dimensional
13:10:09 <Reite> Im probably trying to solve an already solved problem but can figure out how to articulate it well enough to google it -.-
13:14:05 <otters> ugh
13:14:05 <jocolloman> Could you give an example of the queries you will make?
13:14:16 <otters> so you can either use hayoo which sucks or hoogle which indexes virtually nothing
13:14:39 <otters> anybody know of a way to query whether a blaze-html Html object is empty?
13:14:52 <otters> see http://hackage.haskell.org/packages/archive/blaze-html/0.6.1.1/doc/html/Text-Blaze-Html.html#t:Html
13:15:04 <Heffalump> reite: is http://en.wikipedia.org/wiki/Z-order_curve relevant?
13:15:14 <acowley> https://www.fpcomplete.com/hoogle?q=
13:16:46 <acube> acowley: wow a hoogle that has lens, thanks!
13:17:02 <acowley> acube: I only learned of it the other day!
13:17:17 <acowley> acube: it does give me error messages on a regular basis, which is rather disconcerting
13:17:37 <acube> You mean like:
13:17:41 <acube> Internal Server Error
13:17:42 <acube> src/Hoogle/Type/TypeSig.hs:(117,9)-(121,26): Non-exhaustive patterns in case
13:17:44 <acube> ?
13:17:51 <acowley> Yeah
13:18:16 <acowley> which makes it okay for name lookup, but not so hot for type-based search... which is 90% of the point
13:18:26 <acowley> not sure how I feel about it when all's said and done
13:20:47 <acowley> How can a name someone is asking be included in the standard libraries be "canonical"?
13:21:29 <acowley> We should let #haskell-lens name whenJust. They'll call it :@?~~: and the debate will be over.
13:22:05 <otters> :#$@@_#_____~_~_#@#
13:22:08 <c_wraith> whenJust *is* a pattern I want a lot
13:22:41 <c_wraith> though..
13:22:52 <c_wraith> :t traverse
13:23:01 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
13:23:11 <acowley> for_ is great, though. Not only does it do what you want, it encourages you to think more generally.
13:23:22 <c_wraith> traverse is more or less whenJust
13:23:31 <acube> :t for_
13:23:32 <acowley> :#$@@_#_____~_~_#@# = unsafeCoerce
13:23:33 <acube> :t traverse_
13:23:37 <lambdabot>     Not in scope: `for_'
13:23:37 <lambdabot>     Perhaps you meant one of these:
13:23:37 <lambdabot>       `Data.Foldable.for_' (imported from Data.Foldable),
13:23:39 <lambdabot>     Not in scope: `traverse_'
13:23:39 <lambdabot>     Perhaps you meant one of these:
13:23:39 <lambdabot>       `Data.Foldable.traverse_' (imported from Data.Foldable),
13:23:47 <acube> :t Data.Foldable.traverse_
13:23:50 <acube> :t Data.Foldable.for_
13:23:53 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
13:23:56 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
13:24:06 <c_wraith> man, Cale, can you kick the machine lambdabot's on?
13:25:18 <acube> Woo, I found a new way to generate random numbers from pure code in haskell: V.I.create (V.M.new 10) :: V.I.Vector Int
13:25:34 <acube> (V.I. is Data.Vector.Unboxed, V.M. is Data.Vector.Unboxed.Mutable)
13:25:47 <dolio> @type forOf_ _Just
13:25:51 <lambdabot> Applicative f => Maybe a -> (a -> f r) -> f ()
13:25:59 <Heffalump> acube: shouldn't that come from zero-initialised memory?
13:26:07 <acube> Heffalump: it doesn't
13:26:19 <acube> > Data.Vector.Unboxed.create
13:26:23 <lambdabot>   Not in scope: `Data.Vector.Unboxed.create'
13:26:27 <acube> :/
13:26:45 <c_wraith> heh.  More than one attack has come from the fact that uninitialized memory isn't random at all. :)
13:32:50 <monoidal> fizbin: are you there?
13:32:57 <fizbin> Hrm?
13:33:07 <fizbin> I'm vanishing soon, but haven't yet.
13:33:28 <hpaste> monoidal pasted “liftA via TH” at http://hpaste.org/87690
13:33:54 <applicative_> acube: [4455565272,4422023008,4455565400,4455565376,4422225224,4424771283,4455565426,4422225224,4459803361,4423582177] isnt looking too random, but I like it
13:33:59 <monoidal> fizbin: ^ it uses a different approach. but it doesn't define type (yet0
13:34:49 <acube> applicative_: Why not too random? If i evaluate it twice, I get different results
13:34:51 <fizbin> monoidal: I had to define the type to get it to work without turning off the monomorphism restriction.
13:35:01 <applicative_> ah in that sense ok
13:35:27 <monoidal> fizbin: yeah, alternatively you could eta-unreduce
13:36:07 <applicative_> if I compile it I get fromList [0,0,0,0,0,0,0,0,0,0] every time :(
13:36:09 <fizbin> monoidal: not sure what that means.
13:36:32 <monoidal> fizbin: instead of f = g, write f x = g x, then you're freed from monomorphism restriction
13:36:38 <fizbin> Ah.
13:36:49 <fizbin> Yeah, okay.
13:37:57 <fizbin> I'm going to have to see what your functions do.
13:38:49 <Reite> Im basically trying to do this as fast as possible: https://gist.github.com/reite/5557181
13:40:17 <fizbin> :t let next n acc x = n (acc <*> x) in next next
13:40:20 <lambdabot> Applicative f => (f b1 -> a -> b) -> (f b1 -> a) -> f (a1 -> b1) -> f a1 -> b
13:41:08 <Reite> And Im thinking range tree is the way to go but I dont know enough about these kinds of algorithms
13:41:57 <monoidal> fizbin:  next (next zero) x y z = next zero (x <*> y) z = zero (x <*> y <*> z) = x <*> y <*> z
13:42:41 <monoidal> fizbin: whoops! that's not what I wanted. but it's reasonably close.
13:42:58 <monoidal> it gives a function f (a -> b -> c) -> f a -> f b -> f c, the first argument has to take "pure"
13:43:29 <fizbin> monoidal: yeah, and popping a ". pure" on the end is easy.
13:43:47 <fizbin> I'm a bit surprised though that you don't need a layer of parentheses.
13:44:36 <fizbin> That is, I'm surprised $(x 2) doesn't expand to (next next zero) but instead expands to (next (next zero))
13:45:01 <fizbin> :t let next n acc x = n (acc <*> x) in next (next id)
13:45:02 <monoidal> fizbin: TH works on trees of expressions
13:45:03 <lambdabot> Applicative f => f (a -> a1 -> b) -> f a -> f a1 -> f b
13:46:26 <monoidal> fizbin: in other words, [| $x $y |] will always be application of x to y, like there were parens (x) (y)
13:46:38 <fizbin> monoidal: So I can't ever splice in multiple arguments? Like, if I wanted [| f x $(splice) y z |] to expand to "f x g h k y z", there's nothing I could write in that splice to make that work?
13:47:03 <monoidal> fizbin: I don't think you can. But I'm not a TH expert.
13:47:43 <fizbin> :t let next n acc x = n (acc <*> x) in next (next pure)
13:47:47 <lambdabot> (Applicative f1, Applicative f) => f (a -> a1 -> b) -> f a -> f a1 -> f1 (f b)
13:48:16 <c_wraith> fizbin: Yeah, a splice must be a single expression.
13:48:33 <fizbin> :t let next n acc x = n (acc <*> x) in next (next id) . pure
13:48:35 <lambdabot> Applicative f => (a -> a1 -> b) -> f a -> f a1 -> f b
13:49:01 <c_wraith> Clearly, we need to change TH so that splices can be multiple expressions
13:49:02 <fizbin> :t let next n acc x = n (acc <*> x) in (next id) . pure
13:49:03 <lambdabot> Applicative f => (a -> b) -> f a -> f b
13:49:38 <lispy> People frequently ask about Haskell jobs. Add this to the list: http://www.functor.se/careers/openings/
13:49:52 <fizbin> c_wraith: Not clear to me. If we're going to do that, I'm all for replacing TH with an m4 pass over the source before ghc gets to it.
13:49:53 <Botje> cool company name.
13:49:59 <Sculptor> lispy, aren't they a myth
13:50:05 <Eduard_Munteanu> Heh, was about to say the name, Botje.
13:50:31 <lispy> Sculptor: haskell jobs? I don't think people around the office would agree...
13:50:47 <Sculptor> good news
13:50:57 <c_wraith> Sculptor: lispy works at a haskell company :)
13:51:07 <fizbin> monoidal: For the record, your declarations run afoul of the monomorphism restriction.
13:51:21 <Sculptor> congrats lispy
13:52:33 <lispy> Sculptor: thanks :) But seriously, there's been a lot of haskell jobs in the last 5 years or so
13:52:44 <lispy> Several companies in Portland, OR for example
13:54:54 <c_wraith> For instance, I'm at one of the *other* Portland companies that does haskell work.
13:55:03 <c_wraith> Located about 2 blocks from lispy's
13:56:15 <lispy> c_wraith: oh, I didn't realize that
13:56:20 <lispy> very cool
13:56:55 <lispy> BTW, PrimMonad doesn't seem to have an instance for Applicative. That must simply be an oversight? Does an package provide that?
13:57:39 <glguy> Is PrimMonad a typeclass or a type?
13:57:44 <c_wraith> neither
13:57:49 <c_wraith> It's a type family
13:58:00 <monoidal> PrimMonad in what package?
13:58:06 <glguy> ah, I must be looking at the wrong package, then
13:58:09 <c_wraith> Unless I'm thinking of the wrong PrimMonad
13:58:09 <glguy> I was in "primitive"
13:58:10 <c_wraith> :)
13:58:30 <wole> @hoogle [a] -> [[a]]
13:58:30 <lambdabot> Data.List inits :: [a] -> [[a]]
13:58:30 <lambdabot> Data.List permutations :: [a] -> [[a]]
13:58:31 <lambdabot> Data.List subsequences :: [a] -> [[a]]
13:59:05 <lispy> glguy: you're in the right place.
13:59:16 <lispy> that's the definition of PrimMonad that i'm using
14:00:51 <monoidal> lispy: um, but PrimMonad is a class, how do you want an instance of Applicative?
14:01:12 <monoidal> class (Applicative m, Monad m) => PrimMonad m?
14:01:41 <jeff_s1> Does persistent support paging? I guess I'm wondering if it can fetch rows lazily.
14:02:04 <lispy> Yeah, I think this won't work the way I had hoped
14:02:15 <lispy> I'll just add applicative to my constraint
14:03:11 <rck> what's the word on the new haskell platform?
14:03:39 <hpaste> fizruk pasted “Monadic robot acting in a comonadic world” at http://hpaste.org/87691
14:03:40 <zebr> hey all. is there a name for an 'application sequence' (f x y z), or a more general term for such a thing, given left association?
14:03:40 <NihilistDandy> rck: Committee just formed, last I heard
14:03:41 <lispy> rck: the RCs exist
14:03:51 <lispy> NihilistDandy: that's unrelated
14:04:02 <lispy> NihilistDandy: that's a committee for the language standard
14:04:14 <rck> lispy: the proposed date was the 6th, is there a new timeline somewhere?
14:04:16 <NihilistDandy> Oh, duh. That's my mistake
14:04:30 <NihilistDandy> zebr: Isn't that just function composition?
14:04:35 <Eduard_Munteanu> zebr: how about just "application"?
14:05:30 <zebr> Eduard_Munteanu: well, i want to emphasise the fact that it's a number of binary applications, (((f x) y) z)
14:05:53 <fizruk> Hi! Could anyone review my code? I have a feeling that I'm doing comonads wrong. Thanks in advance! http://hpaste.org/87691
14:05:56 <zebr> but it's left associative so it forms a kind of specific sequence, if that makes sense
14:06:00 <Eduard_Munteanu> zebr: you get that by definition, really
14:06:18 <Eduard_Munteanu> zebr: in many calculi you only apply one parameter at a time
14:06:22 <lispy> rck: sorry, I haven't been paying that close of attention you need mzero
14:06:26 <Eduard_Munteanu> Haskell too.
14:06:46 <lispy> glguy: looks like liftM/ap are the easiest way to jump around this applicative thing :)
14:07:11 <Eduard_Munteanu> zebr: you could say 'f x y z' is just sugar for, or parsed as '((f x) y) z'
14:07:15 <zebr> Eduard_Munteanu: the thing is, i want to say "a free variable f can only occur in the [application sequence] f u_1 ... u_n where ..."
14:07:17 <ATuin>  Not in scope: type constructor or class `Read' <- isnt Read in Prelude?
14:07:43 <ATuin> why is complaining about it when deriving Read?
14:07:47 <hpaste> monoidal annotated “liftA via TH” with “liftA via TH (annotation)” at http://hpaste.org/87690#a87692
14:07:58 <monoidal> fizruk: ^ here's above with the eta-expansion
14:08:07 <Eduard_Munteanu> zebr: are you trying to define free variables? (then it doesn't sound quite right)
14:08:45 <zebr> Eduard_Munteanu: well, no, it's to do with higher-order rewriting. i just figured someone might know if there's a term for a sequence (t_1 t_2 ... t_n)
14:08:57 <Eduard_Munteanu> Hm.
14:09:04 <zebr> (it's part of the definition of Nipkow's Higher-order Rewrite Systems.)
14:11:05 <monoidal> zebr: I vaguely recall 'spine' or a similar term.
14:11:06 <fizruk> monoidal: m… how's that related? you have probably used the wrong link, or I don't get it
14:11:44 <monoidal> fizruk: it's the liftA via TH, in the annotation there's a version that does not require monomorphism restriction
14:12:39 <monoidal> fizruk: sorry, you aren't fizbin
14:12:42 <fizruk> monoidal: my question was about comonads, code is here: http://hpaste.org/87691
14:12:54 <monoidal> I confused two people. sorry
14:13:02 <fizruk> monoidal: no, I'm not :)
14:13:41 <fizruk> monoidal: i thought prefix 'fiz' was rather unique, but it's not
14:16:15 <zebr> monoidal: hmm, spines are similar, but go down the left and through lambdas
14:16:27 <zebr> i think it's a related notion, though
14:27:16 <ezyang> I wonder what the category theoretic perspective on "zips" is
14:28:48 <kylcarte_> anyone know of an existing mechanism for applicative transformers?
14:29:26 <cmccann> kylcarte_: functor composition of Applicatives always produces another Applicative
14:29:34 <cmccann> and monad transformers also work
14:29:51 <kylcarte_> yes, but it does not provide the functions for "lifting"
14:29:58 <cmccann> I'm not sure if there is a useful concept of Applicative transformer not covered by one of those
14:30:07 <kylcarte_> or joining
14:30:22 <acube> joining sounds like monad stuff
14:31:21 <apes> If there's only a 0.0001% chance of a police officer killing someone, that's like one a day.
14:31:40 <apes> Wrong channel, oops
14:31:58 <kylcarte_> so, if you were to try transforming an applicative with ReaderT, you don't get ask, since it requires the f in (ReaderT r f) to be a monad
14:32:37 <cmccann> kylcarte_: yes, true
14:32:59 <kylcarte_> so, by both the transformers and mtl approaches, it's a bit useless
14:35:06 <cmccann> kylcarte_: in practice I suspect the types people want to use are also Monad instances so it's usually not an issue
14:35:21 <kylcarte_> cmccann: except when they arent'
14:35:29 <kylcarte_> xp
14:35:59 <cmccann> there really aren't many Applicatives that aren't also Monads
14:36:15 <cmccann> even if you include the ones where (>>=) is horrifically inefficient as non-Monads
14:36:40 <stepcut> formlets is the only one I can think of offhand
14:36:48 <acube> :t ask
14:36:49 <monoidal> ziplists, const m
14:36:54 <lambdabot> MonadReader r m => m r
14:37:15 <cmccann> yeah, fixed-length lists aka zippy Applicatives are the obvious example
14:37:25 <kylcarte_> cmccann: practically, yes, but theoretically, no
14:37:31 <stepcut> (applications with out monads)
14:38:01 <cmccann> since if you actually restrict the length you get a horrible (>>=) and no expressive power, and if the size isn't fixed it breaks the Monad laws
14:38:45 <kylcarte_> cmccann: the case I'm running into is the liblastfm pkg
14:39:21 <cmccann> well if you want to concoct a general-purpose ApplicativeTrans and put it on hackage I don't think anyone will mind :P
14:39:30 <cmccann> if it doesn't already exist at least, maybe it does
14:40:19 <kylcarte_> where Requests are built as Applicatives. I don't see any reason yet why a Monad instance couldn't also be defined, but it raised the question...
14:42:12 <cmccann> wow, that's kind of a scary instance definition
14:42:33 <acube> @package lastfm
14:42:34 <lambdabot> http://hackage.haskell.org/package/lastfm
14:43:24 <cmccann> oh, I guess it's some sort of really fancy Const
14:43:50 <cmccann> that's hilarious, it's just the Endo monoid with phantom type parameters
14:44:06 <fizruk> @package liblastfm
14:44:07 <lambdabot> http://hackage.haskell.org/package/liblastfm
14:44:36 <hpaste> “Thomas Brandstätter” pasted “parse error in pattern” at http://hpaste.org/87693
14:45:01 <vervic_> why i get the error message here: http://hpaste.org/87693
14:45:34 <fizruk> vervic_: remove parens around (low high)
14:45:40 <kylcarte_> cmccann: it's not unsafeCoerce, it's a change in phantom types
14:46:19 <vervic_> fizruk: if i do that i get the error: src/Data/Gist.hs:24:50: Not in scope: `true'
14:46:26 <vervic_> same for false
14:46:51 <fizruk> vervic_: false → False, true → True
14:47:16 <fizruk> vervic_: True and False are data constructors of type Bool
14:47:33 <fizruk> vervic_: every data constructor should start with a capital letter
14:48:03 <applicative_> vervic_: (GKey low high)
14:49:00 <vervic_> applicative_: you rock!
14:49:03 <fizruk> vervic_: sorry, applicative_ is right
14:49:30 <vervic_> fizruk: ty
14:50:17 <fizruk> monoidal: sorry to bother you, should I wait for a response?
14:52:14 <monoidal> fizruk: sorry, I'm busy now
14:52:32 <fizruk> monoidal: ok, thanks anyway!
14:58:28 <fxr> johnw: re
15:22:12 * hackagebot hobbes 0.2.1 - A small file watcher for OSX  http://hackage.haskell.org/package/hobbes-0.2.1 (JasonHickner)
15:37:49 <arbn> So... I'm trying to exclude null characters from a QuickCheck arbitrary instance. Advice on how to do this?
15:38:13 <arbn> Is there some notNull for characters or whatever?
15:38:26 <aristid> (/= '\0') ?
15:38:44 <acube> arbitrary `suchThat` (/= '\0')
15:39:00 <arbn> acube: Ah. OK. Yeah... that works, doesn't it? Thanks.
15:42:17 <aristid> :t suchThat
15:42:19 <lambdabot> Not in scope: `suchThat'
15:42:47 <napping> transformers has Data.Functor.Product, what about Sum?
15:43:15 <glguy> Data.Functor.Coproduct ?
15:43:30 <hpc> why not mtl?
15:44:44 <napping> Coproduct will do
15:48:16 <no-n> @hoogle [(a,b)] -> [a]
15:48:16 <lambdabot> Prelude fst :: (a, b) -> a
15:48:16 <lambdabot> Data.Tuple fst :: (a, b) -> a
15:48:16 <lambdabot> Data.Graph.Inductive.Query.DFS topsort' :: Graph gr => gr a b -> [a]
15:49:13 <troydm> i'm trying to figure out the difference between HNF and WHNF
15:49:36 <troydm> so say (1 + 3 + 4) is WHNF and (1+3) HNF correct?
15:49:54 <Saizan> neither are correct
15:50:19 <Saizan> assumming the type there is Int or similar
15:50:46 <hpc> troydm: WHNF is matching on the constructor
15:51:00 <Saizan> for a "flat" type like Int both WHNF and HNF are the same as NF
15:51:00 <hpc> if you have a value of type Maybe Int, (Just {thunk}) is WHNF
15:51:25 <troydm> so Just 1 is WHNF
15:51:29 <troydm> and 1 is NF
15:51:35 <hpc> troydm: HNF is a subtle nuance that only has to do with lambda
15:51:36 <Saizan> Just 1 is NF too
15:51:41 <hpc> and NF is when something is fully evaluated
15:51:49 <hpc> in strict languages, all values are normal form
15:52:14 <troydm> so [1..] is WHNF?
15:52:20 <troydm> since it's not evaluated
15:52:38 <mm_freak> troydm: you have WHNF when the outermost constructor is evaluated
15:52:46 <aristid> troydm: by itself [1..] is not even WHNF
15:52:48 <hpc> if it's unevaluated entirely, it's not in any normal form
15:52:52 <Saizan> troydm: something is WHNF iff (it's a lambda or the outermost application is a constructor)
15:52:58 <hpc> {enumFrom 1} is not in any normal form
15:53:00 <mm_freak> troydm: it's not a property of expressions, but of their current evaluation state
15:53:07 <hpc> {1}:{enumFrom 2} is in WHNF
15:53:18 <hpc> because it's been evaluated to (:)
15:53:22 <mm_freak> troydm: so the question whether "[1..]" is in WHNF can't be answered
15:53:26 <Saizan> hpc: why braces?
15:53:34 <hpc> Saizan: just to represent the thunks
15:54:08 <mm_freak> troydm: when you just say [1..] you can't make any assumptions, but when you say "case x of (x:xs) -> y", then while evaluating y, x is guaranteed to be in WHNF
15:54:18 <troydm> so if it's a constructor it's HNF
15:54:31 <troydm> if it's not constructor it's WHNF
15:54:34 <troydm> ?
15:54:35 <Saizan> no
15:54:46 <Saizan> everything in HNF is also in WHNF
15:55:02 <hpc> for non-functions, HNF = WHNF
15:55:06 <hpc> NF = fully evaluated
15:55:12 <napping> if it's not a constructor, it's not WHNF
15:55:14 <hpc> WHNF = evaluated to the outermost constructor
15:55:20 <aristid> hpc: what is HNF for funcitons?
15:55:22 <napping> if it is a constructor it's WHNF
15:55:28 <hpc> entirely unevaluated = nothing at all, really
15:55:32 <mm_freak> troydm: again, normal forms are not a feature of expressions or values…  they are a feature of evaluation!
15:55:38 <napping> and HNF is something stronger that hardly ever happens
15:55:47 <Saizan> HNF is a stronger condition, the difference is that (\x -> b) is in HNF only if b is also in HNF
15:55:52 <Saizan> iirc
15:55:58 <aristid> huh
15:55:58 <hpc> aristid: for functions, HNF means the lambda is evaluated like WHNF, and the root of the lambda body is a constructor
15:56:08 <hpc> \x -> x:[] -- HNF
15:56:11 <troydm> i think i lack a brain capacity to understand it now
15:56:16 <aristid> is HNF important for ghc?
15:56:17 <hpc> \x -> return x -- WHNF
15:56:18 <troydm> i'll try reading some articles
15:56:21 <hpc> it's not important
15:56:33 <hpc> it has some vaguely useful properties for productivity checking
15:56:44 <aristid> troydm: you can always revisit it later.
15:56:46 <hpc> but HNF itself doesn't really pop up in the theory there
15:56:51 <mm_freak> troydm: take the following as an example:  ones = 1 : ones
15:56:55 <mm_freak> that's an infinite list of ones
15:57:22 <troydm> mm_freak: yes and it's HNF is it not?
15:57:27 <mm_freak> it's in WHNF if the outermost constructor is evaluated, that is when it is established by the run-time (!) that the list has at least one element
15:57:36 <aristid> troydm: no
15:57:44 <mm_freak> and it's never in NF
15:58:10 <aristid> mm_freak: only finite structures can ever be in NF, right?
15:58:17 <mm_freak> right
15:58:22 <aristid> hm:)
15:58:30 <Saizan> aristid, troydm: 1:ones is HNF
15:59:17 <hpc> ... can we slow down and pick one of WHNF and HNF and use just that for this explanation?
15:59:30 <troydm> i know the deference between NF and HNF
15:59:48 <mm_freak> troydm: then question, is [1, 2, 3] in normal form?
15:59:52 <troydm> i just don't understand difference between WHNF and HNF
15:59:54 <aristid> Saizan: but "ones" is not, no? :)
16:00:25 <Saizan> troydm: \x -> x+1 is WHNF but not HNF
16:00:33 <troydm> mm_freak: yes
16:00:44 <mm_freak> troydm: wrong…  the correct answer is, "i don't know"…  if your answer is anything else, you haven't understood normal forms yet =)
16:01:23 <troydm> isn't [1,2,3] expression evaluated right away?
16:01:33 <aristid> mm_freak: doesn't it make more sense to think about the normal forms in conjunction with pattern matches?
16:01:34 <mm_freak> it's just an expression, nothing else
16:01:40 <mm_freak> aristid: exactly
16:02:03 <mm_freak> case myList of (x:xs) -> y
16:02:20 <aristid> there myList is forced to (W)HNF, righto?
16:02:23 <Eduard_Munteanu> Still, I guess in most calculi that is a NF.
16:02:25 <mm_freak> you can make a statement here like:  myList is in WHNF, as soon as y is evaluated
16:02:44 <aristid> Eduard_Munteanu: haskell isn't most calculi i think :D
16:02:46 <Eduard_Munteanu> [1,2,3] can't be reduced.
16:02:54 <Saizan> WHNF and friends are defined on expressions, tbf
16:02:54 <Eduard_Munteanu> Yeah.
16:03:06 <aristid> Saizan: they are?
16:03:10 <aristid> Saizan: interesting
16:03:18 <Eduard_Munteanu> In Haskell you could argue even constants are thunks, so yeah, they're not necessarily NFs.
16:04:09 <mm_freak> Saizan: tb even more f, there is no [1, 2, 3] in lambda calculus
16:04:31 <Saizan> yeah, the theory of LC and even the evaluation strategies is fairly syntactic
16:04:33 <Eduard_Munteanu> (by constants I mean primitive values + constructor application, so no functions etc.)
16:05:33 <Eduard_Munteanu> mm_freak: you could ask the same of say '1' in STLC though
16:05:52 <Eduard_Munteanu> Or something involving a constructor, if you want.
16:06:09 <aristid> Saizan: meanwhile haskell evaluation isn't really syntactic at all, or is it?
16:06:27 <Saizan> you do talk about values, but as a subset of expressions
16:06:46 <mm_freak> aristid: you can translate it into syntax
16:07:01 <aristid> mm_freak: 100% haskell syntax?
16:07:02 <Saizan> aristid: GHC doesn't implement it as such, no :)
16:07:13 <mm_freak> the problem is, at some point you will have to perform IO to proceed
16:07:17 <mm_freak> at which point it becomes magic =)
16:07:28 <mm_freak> up until then you can interpret it as purely syntactic
16:07:30 <aristid> mm
16:07:54 <aristid> i know that using term rewriting to reason about haskell functions is possible so i guess it shouldn't surprise me too much
16:08:50 <Saizan> in fact rather than graphs i like let expressions as a representation of sharing
16:10:24 <aristid> and not where because where operates on declarations not expressions, right? :)
16:11:55 <mm_freak> aristid: let and where are technically the same thing
16:12:15 <mm_freak> where can even do stronger sharing, because it can share across guards
16:12:54 <Saizan> even where is fine where appropriate, a let could introduce a declaration which might contain a where
16:22:10 <aristid> hm:)
16:28:18 <tswett> What's a nice way to replace the last three elements of a list with something else?
16:28:58 <napping> is there any way to look up instances of a type family?
16:29:20 <hpc> tswett: the nicest way is to go up a level and solve your problem another way ;)
16:29:24 <Nisstyre-laptop> napping: like, all ever?
16:29:39 <napping> sure
16:29:43 <Nisstyre-laptop> I don't think so
16:29:49 <napping> something like :info or haddocks for type classes
16:29:50 <Nisstyre-laptop> because you can keep adding instances in any file
16:30:30 <Nisstyre-laptop> maybe I'm wrong though
16:30:34 <Nisstyre-laptop> but I don't see how it would work
16:31:01 <napping> show all the instances visible at your ghci prompt, or perhaps defined in a module, like :info on a type class already does
16:31:37 <Nisstyre-laptop> yeah, maybe
16:31:37 <hpc> does :info not work?
16:31:52 <napping> just shows the kind and source module, no instances
16:32:09 <napping> I'm not sure there's even a nice way to normalize a particular application
16:32:22 <tswett> Well, suppose I have a list of filenames, some of which end with ".foo". I'd like to get a list of all the filenames that end with ".foo", and a list that's the same except with the ".foo" replaced with ".bar".
16:32:59 <Nisstyre-laptop> tswett: data FileName = FN String String
16:33:06 <Nisstyre-laptop> where the second String is your extension
16:33:18 <Saizan> tswett: System.FilePath
16:33:20 <hpc> tswett: there's a function somewhere that splits files into (name, ext)
16:33:26 <Nisstyre-laptop> then just define the show instance so it concatenates both things
16:33:27 <tswett> This isn't something I actually want to do; I'm just curious whether or not there's a concise way to do it.
16:34:05 <Saizan> tswett: takeExtension and replaceExtension
16:34:49 <tswett> Saizan: *nod* Cool. Thanks.
16:34:55 <Saizan> [replaceExtension fn "bar" | fn <- xs, takeExtension fn == "foo"]
16:35:50 <zeta-> why does testing for equality in a guard need *two* == ? is it a hang-over from C et al -- in Haskell /= means =/ :?
16:36:17 <Saizan> = is reserved for definitions
16:36:26 <zeta-> *means = /
16:36:32 <sproingie> = is for bindings, == is the operator for the Eq typeclass
16:36:50 <Nisstyre-laptop> :t (==)
16:36:52 <lambdabot> Eq a => a -> a -> Bool
16:37:01 <napping> free and recursion-schemes have some nice stuff for working in terms of base functors, but is there any good way to make a smart constructor that will work for (Fix f) and (Free f a)?
16:37:15 <zeta-> I think of = as a function
16:37:29 <c_wraith> really? what does a section of it mean?
16:38:15 <Saizan> napping: are those classes or types?
16:38:23 <napping> types
16:38:34 <napping> Fix is the fixpoint of a base functor, Free f is the free monad over it
16:38:38 <Nisstyre-laptop> zeta-: it's not a function though
16:40:24 <napping> making an instance Base (Free f a) = f and an instance Functor f => Unfoldable (Free f a) where embed = Free
16:41:07 <zeta-> Nisstyre-laptop: maybe I'll stop thinking about it
16:43:09 <theli0nheart> I'm having some trouble parsing some very simple JSON using the Aeson tutorial on hackage. http://hpaste.org/87697
16:43:49 <Fuuzetsu> theli0nheart: What's unclear about the error?
16:44:11 <Fuuzetsu> You're getting ByteString out of the parser and you're trying to pass it to print which is expecting String.
16:44:32 <Fuuzetsu> :t unpack
16:44:34 <lambdabot>     Not in scope: `unpack'
16:44:34 <lambdabot>     Perhaps you meant one of these:
16:44:34 <lambdabot>       `BS.unpack' (imported from Data.ByteString),
16:44:43 <Fuuzetsu> :t BS.unpack
16:44:45 <lambdabot> BSC.ByteString -> [Word8]
16:44:45 <theli0nheart> here's my code: http://hpaste.org/87698
16:45:00 <theli0nheart> lambdabot: got it--so is the example code on http://hackage.haskell.org/packages/archive/aeson/0.6.1.0/doc/html/Data-Aeson.html incorrect?
16:45:45 <Fuuzetsu> Oh, right. I misread the first paste.
16:45:51 <Fuuzetsu> :t decode
16:45:53 <lambdabot> Not in scope: `decode'
16:46:26 <Fuuzetsu> theli0nheart: http://hackage.haskell.org/packages/archive/aeson/latest/doc/html/Data-Aeson.html#v:decode
16:46:29 <Fuuzetsu> it takes a ByteString
16:46:46 <theli0nheart> I see that decode has type definition "FromJSON a => Data.ByteString.Lazy.Internal.ByteString -> Maybe a"
16:47:25 <Fuuzetsu> :t readFile
16:47:30 <lambdabot> FilePath -> IO String
16:48:09 <Fuuzetsu> json <- readFile foo; decode json; is going to fail. String ≠ ByteString
16:48:21 <theli0nheart> Fuuzetsu: but in the reference, it says "we can now parse the JSON data like so:"
16:48:24 <theli0nheart> Fuuzetsu: decode "{\"name\":\"Joe\",\"age\":12}" :: Maybe Person
16:48:34 <Fuuzetsu> You could try http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString-Char8.html#v:pack
16:48:40 <theli0nheart> are the docs incorrect? I haven't compiled that but I think it would fail
16:49:11 <Fuuzetsu> I believe it will implicitly convert the literal to ByteString if that's what the docs say.
16:49:29 <Fuuzetsu> Hmm, I don't have Aeson installed to try
16:50:43 <theli0nheart> Fuuzetsu: gotcha...so a literal String won't get treated the same way as the contents pulled from readFile
16:52:12 <Fuuzetsu> Well, you're not going to get an implicit conversion from String to ByteString
16:52:29 <Fuuzetsu> I installed Aeson, let me try it out
16:52:55 <Ralith> theli0nheart: there are ByteString versions of the standard IO functions, iirc
16:52:56 <Ralith> just use those
16:53:10 <Ralith> :t BS.readFile
16:53:12 <lambdabot> FilePath -> IO BSC.ByteString
16:53:13 <theli0nheart> Fuuzetsu: cool, thanks :)
16:53:37 <theli0nheart> Fuuzetsu: I get this error when running the code from the documentation. I'm now sure if I'm doing anything wrong. http://hpaste.org/87700
16:53:48 <theli0nheart> Ralith: thank you!
16:54:08 <troydm> btw is there builtin function that would force the list to be evaluated?
16:54:30 <Ralith> troydm: that question doesn't really make sense.
16:54:53 <Fuuzetsu> theli0nheart: I just looked and the docs used OverloadedStrings extension
16:55:08 <theli0nheart> Fuuzetsu: yep, I have this at the top of my file: "{-# LANGUAGE OverloadedStrings #-}
16:55:24 <theli0nheart> Fuuzetsu: assuming that should do it...do I have to pass a flag to ghc?
16:55:29 <troydm> Ralith: like say i have let a = map \x->x+10 [1,2,3]
16:55:43 <Fuuzetsu> No, I don't think so…
16:55:47 * Fuuzetsu loads up GHCi
16:56:13 <Ralith> theli0nheart: those pragmas should be effectively equivalent to passing a flag to ghc
16:56:51 <theli0nheart> Ralith: that's what I assumed. OK, I'm going to post my full source...
16:57:40 <Fuuzetsu> theli0nheart: I can confirm that OverloadedStrings implicitly converts string literals into ByteString for decode
16:58:44 <theli0nheart> Fuuzetsu: here's what I've got-- source: http://hpaste.org/87701, error: http://hpaste.org/87702
16:59:42 <Fuuzetsu> worked for me: Just (Person {name = "Joe", age = 12})
17:00:51 <theli0nheart> Fuuzetsu: huh. fwiw I'm running ghc 7.4.2
17:01:08 <Fuuzetsu> misaki shana % ghc json.hs
17:01:08 <Fuuzetsu> [1 of 1] Compiling Main             ( json.hs, json.o )
17:01:08 <Fuuzetsu> Linking json ...
17:01:11 <Fuuzetsu> ? misaki shana % ./json
17:01:14 <Fuuzetsu> Just (Person {name = "Joe", age = 12})
17:01:17 <greg`> greetings
17:01:30 <Fuuzetsu> GHC 7.6.2; Loading package bytestring-0.10.0.2 ... linking ... done.; Loading package aeson-0.6.1.0 ... linking ... done.
17:02:04 <greg`> continuing to look at why fp matters
17:02:07 <theli0nheart> Fuuzetsu: is my ghc totally botched or something?
17:02:19 <theli0nheart> Fuuzetsu: it's starting to look like it...
17:02:25 <greg`> btw does anyone here actually WORK with Haskell proffessionaly?
17:02:49 <Fuuzetsu> greg`: Quite a few people from what I know.
17:03:01 <greg`> any in uk?
17:03:17 <greg`> im really impressed by Haskell , i think im finally turning a corner!
17:03:32 <Fuuzetsu> theli0nheart: Well, I'm not going to say yes/no and it's probably solvable and maybe just an issue with your libs (outdated maybe?) but I'd recommend that you update to 7.6.2 regardless
17:03:41 <Fuuzetsu> or 7.6.3 as that seems to be out
17:03:58 <hpc> the 7.4 series of ghc is excellent, and not yet out of date imo
17:04:26 <Fuuzetsu> hpc: Feel free to troubleshoot the problem.
17:05:12 <Fuuzetsu> I just don't think it's worth chasing the culprit if a newer version might be the solution unless you have a good reason for not using >7.4
17:05:52 <theli0nheart> Fuuzetsu: yeah. makes sense. I'm downloading 7.6.3 now.
17:06:20 <theli0nheart> Fuuzetsu: as a newcomer this sort of thing is sort of confusing to me. Not sure if it's my fault, the documentation, my compiler, etc.
17:07:49 <Fuuzetsu> theli0nheart: Heh. Library version mismatches are the worst. You get errors about passing X instead of passing X to something.
17:08:52 <Fuuzetsu> IsString is used by the OverloadedStrings extension so I think an updated compiler is a good start
17:09:04 <hpc> theli0nheart: found your issue
17:09:24 <hpc> the IsString instance for ByteString is in .Char8
17:10:02 <theli0nheart> hpc: good find. but that would make the example code in the Aeson library wrong as well, right?
17:10:20 <theli0nheart> hpc: ...as I pretty much copy-pasted what was in there.
17:10:43 <theli0nheart> Fuuzetsu: I hope it fixes the issue!
17:11:15 <Fuuzetsu> hpc: and an explanation for why it works out of the box for me would be…?
17:11:28 <hpc> hmm
17:11:35 <Hafydd> greg`: I have my doubts about your ability to write proper programs if you're unable to use punctuation or spaces, or spell words properly.
17:12:18 <Fuuzetsu> theli0nheart: Well, it seems to be correct for the newest non-minor release of GHC.
17:12:23 <SrPx> What is the name of the function that receives a value and returns a function that returns that value?
17:12:26 <Fuuzetsu> I guess we'll find out soon.
17:12:37 <Fuuzetsu> SrPx: const?
17:12:39 <Fuuzetsu> :t const
17:12:41 <lambdabot> a -> b -> a
17:12:44 <Fuuzetsu> or not
17:12:55 <SrPx> oh, ok, thanks. I confused with "just"
17:13:09 <Fuuzetsu> Sorry if I don't make much sense, pretty tired
17:13:22 <Fuuzetsu> Yeah, const is what you want.
17:14:16 <hpc> Fuuzetsu: witchcraft
17:14:20 <hpc> Fuuzetsu: it's the only explanation ;)
17:15:33 <Fuuzetsu> those damn wizards, always messing with other peoples programs
17:16:00 <Fuuzetsu> people's*
17:16:54 <hpc> or i just didn't put an upper bound on the aeson version
17:17:14 <hpc> if i spent more than 15 minutes i could probably get it to cabal-dev and run properly
17:17:17 * hackagebot robot 1.0.1.1 - Simulate keyboard and mouse events  http://hackage.haskell.org/package/robot-1.0.1.1 (ChrisWong)
17:17:42 <Fuuzetsu> is it your brainchild?
17:26:49 <theli0nheart> taking a loooong time to download
17:28:50 <greg`> pfft!
17:47:19 * hackagebot jmacro 0.6.7 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.6.7 (GershomBazerman)
18:02:02 <SrPx> Is there a convention for naming 9-slice images?
18:09:24 <tgeeky> SrPx: I had to look it up, but won't the cardinal directions suffice (with one addition): [NW, N, NE, E, SE, S, SW, W] ++ [Center]
18:09:37 <tgeeky> SrPx: this is the nine-slice image resizing thing?
18:10:52 <SrPx> tgeeky: yea, except now I just noticed there are actually 13 slices
18:11:16 <SrPx> ¬¬
18:11:24 <tgeeky> SrPx: seems weird to name it 9 slice then.
18:11:40 <SrPx> tgeeky: uh huh, it has 4 extra slices for concave angles
18:12:19 <tgeeky> SrPx: where... are they?
18:12:22 <tgeeky> the corners?
18:12:29 <SrPx> yea, the corners
18:12:38 <SrPx> http://o7.no/17SwK1e this thing
18:13:08 <tgeeky> SrPx: now I really don't know what I'm looking at.
18:13:14 <SrPx> heh
18:13:40 <SrPx> http://o7.no/17SwK1e the corner of this thing tgeeky
18:13:58 <SrPx> tgeeky: I mean this http://o7.no/ZUXoVl
18:14:29 <SrPx> what the heck people stop quitting
18:14:51 <sclv> srpx its a netsplit
18:14:56 <sclv> ppl aren't actually quitting
18:15:33 <SrPx> what the heck people stop netsplitting
18:19:02 <luite> SrPx: what kind of names are you looking for? the only things that come to mind from that image in general are 'sprite' and 'tile'
18:22:16 <tgeeky> SrPx: is this technique about resizing the image, specifically the borders?
18:22:34 <SrPx> luite: nevermind I just thought there was a default naming for this. http://o7.no/17SxROf
18:22:52 <luite> i don't understand the question
18:22:58 <SrPx> tgeeky: yea, but in this case is for tiling
18:23:16 <luite> SrPx: hm, i'd say that's some tileset. dunno anything more specific, i see what you're asking now :)
18:23:24 <SrPx> ^^
18:23:58 <tgeeky> SrPx: so does what I suggested above make sense so far (the ordinals)
18:24:01 <tgeeky> cardinals*
18:24:11 <SrPx> tgeeky: yea but what about the corners?
18:24:20 <SrPx> they don't really point anywhere
18:24:27 <tgeeky> i wasn't thinking of pointing
18:24:41 <SrPx> hum
18:25:18 <tgeeky> SrPx: one sec, let me find the page I was looking at from random googling
18:26:24 <tgeeky> SrPx: http://www.codeproject.com/Tips/377680/Resize-Images-using-9-Slices <-
18:27:17 <SrPx> tgeeky: they are using just right/left okay
18:28:25 <no-n> @src unzip
18:28:25 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
18:32:54 <tgeeky> .
18:37:59 <luite> hm this is a tad distracting indeed
18:47:12 <bhu> Trying to compile a program. "Could not find module `Network.Curl'" What should I do?
18:47:22 * hackagebot cufft 0.1.0.1 - Haskell bindings for the CUFFT library  http://hackage.haskell.org/package/cufft-0.1.0.1 (RobEverest)
18:48:19 <luite> bhu: install the curl package
18:48:36 <bhu> Thanks
18:48:41 <luite> :)
18:49:03 <bhu> luite: "curl-7.30.0-1 is up to date -- reinstalling"
18:49:08 <bhu> I already have it :(
18:49:34 <luite> bhu: the haskell package
18:49:42 <luite> bhu: cabal install curl
18:49:49 <bhu> Oh, thanks.
18:49:53 <luite> you'll need the development version of the curl lib
18:49:57 <bhu> Sorry, I don't program in haskell
18:50:38 <bhu> Worked, I think
18:50:40 <bhu> Thanks
18:51:40 <Twey> I've been wondering… what prompted the development of Cabal, rather than using an existing package manager, like maybe Nix?
18:51:57 <Twey> Are there any features Cabal has that set it apart?
18:52:19 <Hafydd> Twey: it's written in Haskell.
18:52:25 <Twey> Is that it?
18:52:26 <mikeplus64> Twey: cabal probably predates nix
18:52:31 <Hafydd> Therefore it doesn't depend on anything external.
18:52:36 <Twey> Well, Nix was just an example
18:52:42 <Twey> I see…
18:52:43 <Hafydd> (Well, it does - but the language doesn't)
18:52:44 <geekosaur> cabal's not really a package manager, it's a convenience for installing stuff from hackage
18:52:47 <dcoutts_> Twey: do you mean the cabal-install program, or the Cabal lib + packaging format?
18:53:04 <mikeplus64> geekosaur: (but it should be, imo)
18:53:13 <mikeplus64> cabal-install rather
18:53:54 <geekosaur> the cabal library and cabal descrtiption files are just ways for a compiler to manage its libraries; they're not even really "packages" as such
18:54:19 <dcoutts_> Twey: cabal-install was intended as a complement to distro packages. There are also tools that translate into distro packages, but it takes a long time for packages to make it into distros and developers need something quicker. And then of course there's Windows...
18:55:42 <luite> did it allow multiple versions of a single package from the start?
18:56:45 <dcoutts_> luite: yes and no. Initially Cabal didn't really care about that. That restriction was relaxed by ghc-6.4
18:57:33 <luite> ah
18:57:35 <geekosaur> mikeplus64, do you have system integration experience? multiple real package managers simply do not mix on a system; they fight with each other over file ownership.
18:57:39 <dcoutts_> Twey: and the sad truth is that there is no cross-platform package format + manager anyway
18:58:30 <geekosaur> (see for example how the homebrew folks relearned this lesson the hard way, after starting out "knowing better")
18:58:40 <dcoutts_> sadly what we have is a bunch of language-independent and os/distro-specific package formats
18:59:04 <dcoutts_> and another bunch of os/distro-independent and language-specific ones
19:25:02 <zeta-> Is it possible to define polymorphic functions that differ only in their output type, and can ghc recognise which is required in any context?
19:25:25 <Eduard_Munteanu> zeta-: yeah
19:25:40 <Eduard_Munteanu> :t minBound
19:25:42 <lambdabot> Bounded a => a
19:26:06 <zeta-> Eduard_Munteanu: B) thanks
19:26:57 <mikeplus64> anyone familiar with repa? what's the equivalent Data.Vector.// for repa arrays?
19:27:31 <zeta-> Ah Ok! -- zero parameter function.
19:28:08 <Eduard_Munteanu> zeta-: not necessarily. Mind you kinda have to constrain that return type with a typeclass, something like   Foo -> a   doesn't make much sense.
19:28:11 <mikeplus64> or am i supposed to just use map with the indices and like case index of 2 :. 3 :. Z -> ...; ...
19:28:33 <Eduard_Munteanu> :t const minBound
19:28:35 <lambdabot> Bounded a => b -> a
19:28:46 <joeyh_> :t read
19:28:48 <lambdabot> Read a => String -> a
19:28:50 <mikeplus64> :t flip const minBound
19:28:52 <lambdabot>     Ambiguous type variable `b0' in the constraint:
19:28:52 <lambdabot>       (Bounded b0) arising from a use of `minBound'
19:28:52 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
19:28:54 <Eduard_Munteanu> Ah, yes... better example.
19:29:08 <zeta-> yeah sure -- doesn't have to be zero
19:29:26 <Eduard_Munteanu> @hoogle printf
19:29:27 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
19:29:27 <lambdabot> Text.Printf class PrintfArg a
19:29:27 <lambdabot> Text.Printf class PrintfType t
19:29:35 <Eduard_Munteanu> (for something quite fancy)
19:30:03 <mikeplus64> huh, why does ghc need to know what b0 is in flip const minBound?
19:30:17 <mikeplus64> (where minBound :: b0)
19:30:24 <Eduard_Munteanu> mikeplus64: because the value is ignored
19:30:36 <Eduard_Munteanu> mikeplus64: so b0 can be anything
19:30:39 <mikeplus64> yeah, that makes me think it shouldn't need to be known?
19:30:59 <^|{`-}^{> you would be right in a dynamically typed language
19:31:06 <mikeplus64> lazy typing
19:31:37 <Eduard_Munteanu> Actually it's not because the value is ignored, that's more or less related to parametricity, but...
19:31:40 <Eduard_Munteanu> :t const
19:31:45 <lambdabot> a -> b -> a
19:31:46 <mikeplus64> :t flip const undefined
19:31:51 <lambdabot> c -> c
19:31:55 <geekosaur> defaulting only applies to Num, doesn't it? all it knows there is Bounded
19:31:59 <^|{`-}^{> unfortunately, statically the computer thinks minBound matters
19:32:05 <Eduard_Munteanu> The 'b' there can be anything and it isn't constrained at all.
19:32:11 <mikeplus64> i don't understand why "flip const undefind" should work but not "flip const minBound"
19:32:30 <Eduard_Munteanu> mikeplus64: because for minBound it needs to figure out the instance
19:32:31 <mikeplus64> the only difference is minBound is a typeclass thing
19:32:33 <^|{`-}^{> but undefined doesn't come with a type class
19:32:39 <geekosaur> undefined doesnt have to ... that
19:33:00 <mikeplus64> :t flip const (undefined :: Monad m => m ())
19:33:03 <geekosaur> it "shouldn't" matter, but it still needs to pick a dictionary
19:33:04 <^|{`-}^{> if a type class is involved, the computer wants to know
19:33:05 <lambdabot>     Ambiguous type variable `m0' in the constraint:
19:33:05 <lambdabot>       (Monad m0) arising from an expression type signature
19:33:05 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
19:33:20 <zeta-> Eduard_Munteanu: can output type be a data = enumeration as well as a type class
19:33:37 <^|{`-}^{> @type flip const return
19:33:41 <lambdabot>     Ambiguous type variable `m0' in the constraint:
19:33:41 <lambdabot>       (Monad m0) arising from a use of `return'
19:33:41 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
19:33:53 <Eduard_Munteanu> zeta-: not sure what you mean by the output being both of those, at the same time?
19:34:08 <zeta-> no either
19:34:29 <zeta-> ie both are possible
19:34:43 <Eduard_Munteanu> :t not
19:34:48 <lambdabot> Bool -> Bool
19:34:57 <Eduard_Munteanu> data Bool = False | True
19:35:05 <Eduard_Munteanu> Is that what you mean?
19:35:14 <zeta-> B) yes
19:35:48 <zeta-> thanks a lot
19:36:06 <Eduard_Munteanu> Sure... any type can be a return type, really.
19:36:14 <^|{`-}^{> information wants to be free. type class wants to be unfree
19:42:47 <Eridius> cabal broke when I moved my home folder. I edited the config to point to the new path, but now I can't install anything
19:43:03 <Eridius> because it says it can't read cabal file "foo" (for cabal-install, it's "hashable/1.2.0.6/hashable.cabal")
19:43:09 <Eridius> where the heck is that file supposed to be, and how can I fix this?
19:43:39 * Eridius is currently redownloading the haskell platform in the hopes that reinstall will fix it, but it's taking a while
19:44:23 <byorgey> Eridius: the folders that matter are ~/.cabal and ~/.ghc
19:44:51 <Eridius> byorgey: ah hah, all the stuff in .ghc has the old home folder path embedded in it
19:45:23 <byorgey> ah, that would do it
19:45:51 <Eridius> byorgey: there must be more .conf files somewhere though, because hashable isn't here
19:46:39 <Eridius> woo, download done. Time to try reinstalling
19:46:54 <tystr> HAI
19:46:59 <tystr> woooooooooo!
19:47:16 <Eduard_Munteanu> tystr: ohai
19:47:22 <tystr> ah shit, wrong channel, sorry about that
19:47:25 <byorgey> Eridius: reinstalling will certainly work if you don't mind doing that.
19:47:55 <byorgey> > intercalate "hai" (repeat "o")
19:47:58 <lambdabot>   "ohaiohaiohaiohaiohaiohaiohaiohaiohaiohaiohaiohaiohaiohaiohaiohaiohaiohaioh...
19:48:10 <latermuse> heehe
19:48:14 <Eduard_Munteanu> aioha
19:49:30 <Eridius> wtf, `cabal install cabal-install` fails
19:49:37 <Eridius> 25 warnings and 3 errors
19:50:16 <Eridius> it thinks s' is an unterminated ' and s'' is an empty character constant
19:50:27 <zeta-> Eridius: you might find http://www.vex.net/~trebla/haskell/sicp.xhtml useful for reference
19:50:43 <jfischoff> why do the GHC.Generic :+: and :*: not have functor instances?
19:51:09 <jfischoff> aren't they?
19:51:20 <Eridius> zeta-: possibly useful
19:52:09 <byorgey> jfischoff: sure, but making Functor instances for bifunctors seems a little arbitrary
19:52:10 <mikeplus64> now that more people are here: anyone familiar with repa? what is the equivalent repa function to (//), and is there a way to e.g. update a region of an array in bulk (e.g. set all elements from ix2 0 0 to ix2 4 4 to some value)?
19:52:42 <byorgey> jfischoff: you would only be able to map over one of the types and not the other
19:52:51 <jfischoff> ah true
19:53:41 <mikeplus64> so much net splitting...
19:56:29 <Eridius> sigh. setup: internal error: evacuate(static): strange closure type 727844
19:56:45 <Eridius> haskell is now well and truly screwed up on my machine, despite the fact that I just reinstalled
19:57:20 <blaenk> "strange closure type 727844"
19:57:28 <blaenk> dodged a bullet there, not getting type 727843
19:57:33 <Eridius> hah
19:59:13 <byorgey> Eridius: wow, congratulations.  that's quite impressive.
20:01:48 <Eridius> byorgey: any clue? I was trying to install blaze-builder (as a prereq for pandoc)
20:02:50 <byorgey> Eridius: I don't, sorry.  I have never seen that error before.
20:02:55 <byorgey> try googling for it?
20:03:39 <Eridius> byorgey: nothing for that exact string. I dont' know what the significance of the number is though
20:06:13 <byorgey> Eridius: the number is probably just garbage
20:06:23 <byorgey> i.e. whatever the incorrect contents of memory happened to be
20:06:32 <Eridius> byorgey: probably
20:07:42 <Eridius> hah, I deleted the 'self annotations from the code that originally triggered my question, and no complaints
20:07:53 <Eridius> I'm sure rust 0.6 demanded them though, because I wouldn't have added them otherwise
20:08:13 <Eridius> ...crap, wrong room
20:08:15 <Eridius> dammit irssi!
20:08:39 <hpaste> WhoNeedszzz pasted “Subsequences” at http://hpaste.org/87716
20:09:23 <WhoNeedszzz> hey guys
20:09:47 <WhoNeedszzz> How do i add a simple main for this program to be run from a terminal? http://hpaste.org/87716
20:09:57 <WhoNeedszzz> i'm still grasping haskell io
20:10:26 <byorgey> WhoNeedszzz: something like   main = print (powerSet [1,2,3]), perhaps?
20:10:41 <WhoNeedszzz> ok i thought it should be that simple
20:10:42 <byorgey> WhoNeedszzz: if you just want to test it, you should run ghci and :load the file
20:10:56 <byorgey> WhoNeedszzz: then you can evaluate expressions like  powerSet [1,2,3] at the ghci prompt
20:11:01 <WhoNeedszzz> yeah i just want to have it to where you can just run the file directly
20:11:11 <WhoNeedszzz> i did that to test that it works
20:11:29 <WhoNeedszzz> but of course it works bc what i wanted is a built-in function of Data.List :)
20:12:05 <byorgey> WhoNeedszzz: note that subsequences is not the same as what I would call "power set"
20:12:41 <byorgey> I would assume that  length (powerSet xs) == 2^(length xs)
20:13:19 <blackdog> byorgey: so contiguous subsequences?
20:13:20 <byorgey> oh, wait, that is what subsequences does
20:13:33 <WhoNeedszzz> yep
20:13:37 <WhoNeedszzz> sure does
20:13:40 <byorgey> for some reason I thought subsequences only gave contiguous subsequences
20:13:44 <WhoNeedszzz> nope
20:13:53 <WhoNeedszzz> yeah this made my assignment incredibly easy
20:13:53 <byorgey> carry on then =)
20:14:10 <Eduard_Munteanu> > subsequences [1,2,3,4]
20:14:12 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,...
20:14:14 <byorgey> WhoNeedszzz: why do you have the special case for [] ?
20:14:21 <WhoNeedszzz> those 6 lines versus ~35 lines of java
20:14:44 <WhoNeedszzz> byorgey, bc if it's empty don't even call subsequences
20:15:27 <WhoNeedszzz> i know in this case it doesn't matter, but i try to be efficient when i can
20:15:44 <WhoNeedszzz> > subsequences []
20:15:46 <lambdabot>   [[]]
20:16:06 <byorgey> WhoNeedszzz: I doubt it makes an efficiency difference at all, but if it does, I would think it is *less* efficient to have the extra check than to just call subsequences in the first place.
20:16:08 <WhoNeedszzz> > subsequences ["a","b","c"]
20:16:11 <lambdabot>   [[],["a"],["b"],["a","b"],["c"],["a","c"],["b","c"],["a","b","c"]]
20:16:31 <WhoNeedszzz> i guess
20:16:45 <WhoNeedszzz> what i don't understand is why the result isn't ordered
20:16:56 <byorgey> you mean why it isn't sorted?
20:17:10 <WhoNeedszzz> ["a","b"] shouldn't come before ["c"]
20:17:16 <WhoNeedszzz> not that it matters
20:17:17 <byorgey> why not? =)
20:17:19 <WhoNeedszzz> but just curious
20:17:29 <Eduard_Munteanu> I think the ordering is consistent.
20:17:32 <blackdog> you can sort it afterwards if you want to :) but being sorted isn't part of the spec
20:17:34 <byorgey> it's a perfectly reasonable order.
20:17:38 <WhoNeedszzz> my java code has the same order
20:17:50 <byorgey> it's the most natural order that you get if you implement it recursively
20:17:56 <WhoNeedszzz> except ["a","b","c"] is out of order in the java
20:17:56 <byorgey> or one of the most natural orders
20:18:10 <WhoNeedszzz> oh i see now
20:18:13 <WhoNeedszzz> i guess s
20:18:15 <WhoNeedszzz> so
20:18:28 <byorgey> note that it is nicely divided in half: the first four elements don't contain c, and the last four do
20:18:45 <byorgey> it directly corresponds to the 8 3-bit numbers listed in counting order
20:19:00 <Eduard_Munteanu> Hm, indeed.
20:20:01 <byorgey> it also has the nice property that  subsequences xs  is a prefix of  subsequences (xs ++ ys)
20:20:22 <byorgey> (which is related to the recursive implementation)
20:22:18 <WhoNeedszzz> ah ok that makes sense then
20:23:02 <^|{`-}^{> !list
20:23:03 <monochrom> ^|{`-}^{: http://hackage.haskell.org/packages/archive/pkg-list.html
20:23:28 <lpsmith> actually subsequences is a binary counter,  with the first element being the least significant bit.
20:24:04 <lpsmith> there's good reason for that though,  as it's much more efficient than having the last element of the list being the least significant bit.
20:24:05 <Eduard_Munteanu> Task: implement a Grey code variant of 'subsequences'. :P
20:24:11 <lpsmith> haha
20:24:36 <lpsmith> still wouldn't be quite as efficient as first element being a least significant bit
20:25:28 <lpsmith> but who knows, it could very well be useful in some application
20:27:46 <byorgey> > let grey [] = [[]]; grey (x:xs) = let g = grey xs in reverse g ++ map (x:) g in  grey [1,2,3]
20:27:50 <lambdabot>   [[2,3],[2],[],[3],[1,3],[1],[1,2],[1,2,3]]
20:28:22 <byorgey> > let grey [] = [[]]; grey (x:xs) = let g = grey xs in g ++ map (x:) (reverse g) in  grey [1,2,3]
20:28:24 <lambdabot>   [[],[3],[2,3],[2],[1,2],[1,2,3],[1,3],[1]]
20:29:16 <byorgey> lpsmith: thanks for pointing that out re: most vs least significant bit, I hadn't actually looked at the implementation of subsequences before.  It's quite clever.
20:35:34 <joe9> is there some library in haskell to print out ascii tables? I have 5 rows and 5 column data that I want to represent / show as an ascii table. Any thoughts, please?
20:35:46 <WhoNeedszzz> ok well thanks for the help guys
20:36:11 <Michae___> If I'm defining a top level variable, can I use a where clause inside of it?
20:37:29 <Eduard_Munteanu> Michae___: "variable"? If you mean value, yes.
20:37:47 <Michae___> yes, old habits from my ruby days :)
20:47:33 <Ghoul_> Whats the easiest way to pull something out the right hand side of an Either
20:47:44 <Ghoul_> but if the left hand side is an error, return a default value instead
20:48:01 <geekosaur> :t either
20:48:02 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
20:48:19 <geekosaur> mm, might be something easier than that even
20:48:37 <Ghoul_> hm, thanks
20:48:38 <geekosaur> @hoogle Either a b -> b -> b
20:48:39 <lambdabot> Data.Generics.Aliases ext2B :: (Data a, Typeable2 t) => a -> (forall d1 d2. (Data d1, Data d2) => (t d1 d2)) -> a
20:48:40 <lambdabot> Data.Graph.Inductive.Graph deg :: Graph gr => gr a b -> Node -> Int
20:48:40 <lambdabot> Data.Graph.Inductive.Graph indeg :: Graph gr => gr a b -> Node -> Int
20:48:46 <geekosaur> ...
20:49:38 <geekosaur> either (const defaultValue) id --- not exactly the easiest, no
20:49:48 <BMeph> @hoogle b -> Either a b -> b
20:49:49 <lambdabot> Data.Generics.Aliases ext2B :: (Data a, Typeable2 t) => a -> (forall d1 d2. (Data d1, Data d2) => (t d1 d2)) -> a
20:49:49 <lambdabot> Data.Graph.Inductive.Graph deg :: Graph gr => gr a b -> Node -> Int
20:49:49 <lambdabot> Data.Graph.Inductive.Graph indeg :: Graph gr => gr a b -> Node -> Int
20:50:06 <BMeph> Pity. :/
20:50:24 <geekosaur> well, really, this is (mis)treating an Either as a Maybe
20:52:59 <bwr> I'm parsing an xml file using hexpat and I get a [SAXEvent String String]. I'm currently parsing this list to get my data out manually. Would using Parsec on the [SAXEvent String String] be a reasonable thing to try?
20:56:43 <kwos> hello!
21:07:44 <lispy> hello my fellow humans!
21:08:04 <lispy> I hope everyone is very well on this fine day.
21:08:13 <lispy> Has there been much coding?
21:08:34 <lispy> What wonderful computational tales do you have to share?
21:08:45 <shachaf> lispy: *Ahem*. lambdabot is here too.
21:11:03 <kwos> lispy: it's raining outside but I'm chipping away at my little project and have a coffee by my side, so all is good :D
21:11:14 <Ghoul_> :t id
21:11:16 <lambdabot> a -> a
21:11:24 <Ghoul_> > id String
21:11:27 <lambdabot>   Not in scope: data constructor `String'
21:11:34 <Ghoul_> > id "hello"
21:11:36 <lambdabot>   "hello"
21:11:44 <Ghoul_> > id 3
21:11:47 <lambdabot>   3
21:12:04 <Ghoul_> Is there a way I can get the err.. "default" value of a type, if you get what I mean
21:12:31 <dmwit> The default defaults are Integer and Double, in that order.
21:12:54 <dmwit> If that does not answer your question, then no, I don't get what you mean.
21:13:14 <dmwit> There is a subtlety in ghci, which adds some more default defaults and will default things more often.
21:14:48 <bwr> Ghoul_: maybe http://hackage.haskell.org/packages/archive/data-default/0.5.3/doc/html/Data-Default.html
21:15:35 <bwr> > def :: String
21:15:38 <lambdabot>   Not in scope: `def'
21:15:38 <lambdabot>  Perhaps you meant `dff' (imported from Data.Graph)
21:15:56 <dmwit> Oh, I read "default specialization of a polymorphic type" instead of "default value of a type". Shame on me.
21:16:10 <dmwit> bwr++ for paying attention
21:16:20 <bwr> I guess string isn't in there though
21:16:48 <dmwit> There's an instance for [a], which covers String.
21:16:56 <bwr> oh ok
21:16:58 <dmwit> lambdabot just doesn't have that module.
21:17:29 <bwr> yea, i figured you can't import things in lambdabot?
21:17:37 <Ghoul_> Ah, default is great!
21:18:56 <bwr> so you could make a function with with the following type: Default b => Either a b -> b
21:19:08 <bwr> and return the default if the either is "left"
21:23:28 <lispy> kwos: nice!
21:23:38 <lispy> shachaf: Good point.
21:26:34 <lispy> I really want to be able to track repositories in my cabal files.
21:26:45 <lispy> That would make depending on unreleased things easier.
21:27:21 <lispy> Right now I have to download the repo and then 'cabal-dev install $OTHERLIB'
22:21:59 <johnw> lispy: cabal-meta can do that
22:30:02 <lispy> oleg saves the day, again
22:30:32 <dmwit> mmm
22:30:34 <dmwit> cabal meat
22:30:50 <dmwit> funny the typos your brain can make for you sometimes
22:31:46 <lispy> dmwit: typos for free!
22:31:54 <lispy> (it's like theorems for free but with more mistakes)
22:32:22 <cmccann> vinyl is kinda neat.
22:32:24 <cmccann> in a terrifying way.
22:33:04 <lispy> that's the quasi-dependent types record replacement?
22:33:08 <sclv> oh that existential/do notation hack is lovely
22:33:23 <sclv> it does wonders with the equality gadt
22:33:32 <lispy> sclv: re: oleg?
22:33:37 <sclv> yeah
22:33:48 <cmccann> lispy: vinyl is mostly a fancied up version of what HList did ages ago
22:34:07 <cmccann> just taking advantage of GADTs and DataKinds and other new GHC hackery to make it actually, like, usable
22:34:48 <lispy> cmccann: this should be a pattern. Taking an Oleg idea and making it usable for the masses.
22:35:23 <cmccann> the proliferation of stream libraries suggest that's either worked too well or not well enough with iteratees.
22:35:28 <cmccann> I'm not sure which.
22:36:31 <lispy> streams has not worked well enough yet
22:36:46 <lispy> It's something we could use a solid solution too, but people haven't quite nailed it yet
22:36:48 <johnw> did oleg ever write an FRP library?
22:37:10 <cmccann> iteratees and arrow-style FRP differ more in terminology than structure
22:37:16 <lispy> johnw: haha, not that I know of
22:38:14 * cmccann hacks on vinyl in an attempt to make it more frightening yet
22:38:41 * lispy sent a pull request to Juicy.Pixels today
22:38:56 <lispy> That's quickly becoming _the_ image library for haskell
22:39:30 <cmccann> it sort of already was, if by "for haskell" you mean something like "written in haskell, for haskell"
22:39:55 <johnw> has anyone done anything really interesting in netwire or reactive-banana yet?
22:40:05 <lispy> cmccann: just need a "by haskell" in there :)
22:40:22 <lispy> johnw: reactive-banana? I was going to use that for something and never did.
22:40:35 <lispy> johnw: the problem there was more a lack of freetime
22:40:51 <lispy> maybe carmack will use that for his wolf3d port ;)
22:41:41 <cmccann> I think netwire is probably the closest approximation to "what if oleg wrote an FRP library, and then someone else made it actually usable"
22:42:09 <johnw> i wonder if an FRP library could take advantage of STM's retry semantics
22:42:19 <lispy> what makes netwire different than reactive-banana. I've yet to learn FRP, so it could be that I'm not ready for your answer.
22:42:21 <cmccann> since it's based on the automaton arrow if memory serves me, which is pretty much what iteratees are as well
22:42:22 <kwos> could someone help me with lenses? I'm having trouble finding the runes to construct a getter that picks some fields from a record and sticks them in a tuple; i.e. I'd like to do something like rec^.getter and get (foo, bar, bas)
22:42:27 <johnw> netwire is based on arrow syntax
22:42:53 <johnw> (rec^._1, rec^._2, rec^._3)
22:42:57 <cmccann> lispy: well, do you know what the automaton arrow is?
22:43:06 <johnw> (rec^.foo, rec^.bar, rec^.bas)
22:43:12 <lispy> is yampa still a thing or has it been given up on (presumably due to unfixable space/time leaks)
22:43:21 <edwardk> kwos: 'to' will make a getter from any function
22:43:25 <kwos> johnw: yeah, but I can't pass that as a getter into a function
22:43:39 <lispy> cmccann: I don't think so. Is that the robot analogy that all the arrow tutorials glom on to?
22:43:42 <johnw> so, you want a lens that turn "rec" into a triple?  I don't think that's a lens
22:43:45 <edwardk> for instance       to (\x -> (x^.foo, x^.bar, x^.bas))
22:43:49 <johnw> yeaah
22:44:03 <johnw> edwardk: will 'to' make that lambda into a lens?
22:44:11 <lispy> :t to
22:44:11 <ryantanjunming> is this the same? a -> a -> a And a -> (a -> a)
22:44:11 <edwardk> to makes it into a getter
22:44:13 <lambdabot> (Functor f, Conjoined p, Contravariant f) => (s -> a) -> p a (f a) -> p s (f s)
22:44:15 <cmccann> lispy: no, it's literally a representation of a finite state machine (i.e. automaton)
22:44:17 <kwos> edwardk: okay, let me try...
22:44:24 <edwardk> > (1,"hello")^._2.to length
22:44:26 <lambdabot>   5
22:44:28 <johnw> yeah, not a lens, just a getter
22:44:48 <cmccann> lispy: basically "Automaton i o = Automaton (i -> (o, Automaton i o))" with whatever extra stuff tacked on
22:45:31 <lispy> so an input i, allows you to get an output o and another automaton?
22:45:32 <doomlord> does ghci have hoogle's type based search
22:45:46 <shachaf> newtype Mealy i o = i -> (o, Mealy i o)
22:45:54 <cmccann> lispy: yes. think of a state machine that accepts input i, then produces output o and moves to the next state
22:46:00 <shachaf> data Moore i o = Moore o (i -> Moore i o)
22:46:03 <lispy> doomlord: not by default, but you can build it. There used to be a package called goa (ghci on acid) that added some cool features.
22:46:07 <cmccann> where the "state" is implicit as the automaton value itself
22:46:10 <shachaf> But I like the mutually-recursive definitions.
22:46:23 <natnayr> Hi everyone, need to ask this question, is "val :: a -> a -> a" the same as "val :: a -> (a -> a)"????
22:46:31 <shachaf> natnayr: Yes.
22:46:33 <cmccann> and yeah, it's technically a Mealy machine
22:46:40 <doomlord> the type based search is really neat
22:46:49 <lispy> natnayr: yes, because the function arrow (->) is right assosciative
22:47:24 <cmccann> I should really figure out how to make a concurrent ST monad work usefully. that would be fun.
22:47:25 <natnayr> lispy: so the parenthesis doesnt materter?
22:47:39 <lispy> natnayr: they are redundant
22:47:57 <natnayr> Forall :: Show a
22:47:58 <natnayr>          => [a] -> (Term a -> Formula as) -> Formula (a, as)
22:48:00 <natnayr> given the following..
22:48:12 <natnayr> does the parenthesis matter here as well?
22:48:13 <lispy> (they do matter, but in your example they do not change the structure compared to if they were missing)
22:48:27 <lispy> yes it matters and it changes the meaning
22:48:30 <edwardk> technically Mealy and Moore are for the potentially infinite versions of the notion of a mealy and moore machine. infinite state automata
22:48:55 <lispy> natnayr: in that example, (Term a -> Formula as) is grouped together and represents a function passed to Forall
22:48:55 <natnayr> Lispy: ok so im guessing (Term a -> Formula) derives another type?
22:49:23 <natnayr> but not a type?
22:49:27 <lispy> Term a -> Formula is ill-kinded. I assume you meant Term a -> Formula as
22:49:55 <lispy> natnayr: the function arrow constructs types. if a and b are types then (a -> b) is a type
22:49:58 <natnayr> lipsy: sry i didnt get what u meant in ill kinded
22:50:25 <natnayr> do u mena a defined type
22:50:26 <natnayr> ?
22:50:33 <lispy> natnayr: just that Formula appears to take a type, so 'Formula' by itself is not a type, but 'Formula as' is a type
22:50:52 <kwos> edwardk: almost there; however since I have an algebraic data type I actually use a traversal, so to (\r -> (r^?foo, r^?bar)) will give me (Maybe a, Mabe b); what I'd really like is Maybe (a, b) iff both succeed
22:50:57 <kwos> edwardk: is this doable?
22:51:03 <lispy> natnayr: in Haskell, we say that types have a kind (similar to how we say that values have a type)
22:51:09 <cmccann> edwardk: infinite in the ambiguously corecursive way common in Haskell, though. there's no "completed" infinity in the same sense that a typical FSM has an explicit set of states
22:51:22 <natnayr> lipsy okok, kinda get what u mean
22:51:34 <edwardk> cmccann: correct
22:51:35 <ParahSailin> what do kinds have?
22:51:43 <natnayr> lipsy: thanks
22:51:46 <lispy> ParahSailin: sorts
22:52:00 <edwardk> kwos: sure. just use liftA2 (,)
22:52:28 <edwardk> kwos: to (\r -> (,) <$> r^?foo <*> r^? bar)   also works
22:52:29 * hackagebot bytes 0.7 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.7 (EdwardKmett)
22:52:33 <lispy> natnayr: you're welcome!
22:52:42 <edwardk> but at this point i'd challenge that you can probably do something better ;)
22:52:46 <cmccann> edwardk: and when I call them FSMs I suppose I mean it in the same sense that my desktop is a FSM rather than a turing machine
22:52:51 <Rogach> Q: Does Parsec have some combinator for checking that all of the input was consumed?
22:52:51 <lispy> edwardk: how is gsoc adding up this year
22:52:57 <edwardk> not sure what it is, but this doesn't 'feel' like the right solution
22:53:01 <cmccann> Rogach: eof
22:53:27 <Rogach> cmccann: Thanks!
22:53:32 <kwos> edwardk: alright, thanks!
22:53:33 <edwardk> lispy: its coming along really well, we've received a couple more slots than in years past, now its just a matter of getting through the inter-org horse-trading session
22:53:48 <phao> what a surprise, this channel is one of the largest of freenode
22:53:53 * lispy really should write his tutorial for using alex + happy. To help get the word out that the Haskell world has more to offer than parsec :)
22:54:06 <lispy> edwardk: cool
22:54:08 <edwardk> cmccann: i just figured i'd put in the pedantic note and let it sit there ;)
22:54:24 <cmccann> lispy: parsec is the Haskell version of other languages and "when the only tool you have is regexps..."
22:55:15 <lispy> cmccann: if parsec was split into applicative and monadic and added lots of parser analysis I wouldn't mind it so much :)
22:55:45 <lispy> We're all about dsls right? Well, parser theory comes with lots of good dsl opportunties. Let's use them :)
22:56:11 <edwardk> lispy: sounds good. start throwing code at trifecta ;)
22:56:19 <edwardk> i'm all for smarter parsers ;)
22:56:51 <cmccann> lispy: yeah that sounds a lot like volunteering to write edwardk's packages for him
22:56:52 <lispy> edwardk: I could be wrong, but I think monadic parsers are too powerful to analysis intelligently. Where does trifecta sit on the expressivity spectrum?
22:57:01 <cmccann> lispy: careful before you end up like shachaf and elliott
22:57:03 <lispy> analyze*
22:57:07 <lispy> heh
22:58:27 <edwardk> lispy: 'parsers' works within the applicative fragment as much as possible
22:58:40 <edwardk> trifecta sits on top of that. you can build a monadic parser with it, but you don't have to
22:58:53 <lispy> cmccann: I think jmcarthur et al already roped me into helping with their haskell-game project. I can't remember, you're part of that too right?
22:59:12 <cmccann> yeah. been busy lately though :T
22:59:20 <cmccann> need to get moving on that again.
22:59:40 <lispy> I haven't been directly contributing, but I do my usual thing. Small patches and bug reports where I can
23:00:01 <lispy> Like my recent improvements to Juicy.Pixels and language-c-quote
23:00:17 <lispy> I'm probably just throwing stones in a lake, but I like to think it helps.
23:01:12 <lispy> cmccann: I think audio will be a tough nut to crack for that project.
23:01:16 <edwardk> lispy: anyways, i used to have a toy parser in one of the trifecta versions that would do FIRST set calculations and FOLLOW set calculations when the whole parser was applicative
23:01:17 <cmccann> yeah
23:01:32 <lispy> edwardk: nice.
23:01:53 <edwardk> i've been wondering if i couldn't do something like that with 'semi-indexing' to make a nice parser that might be much faster in practice
23:02:24 <edwardk> semi-indexing: http://www.di.unipi.it/~ottavian/files/semi_index_cikm.pdf
23:02:42 <edwardk> if nothing else i may think about putting together a json parser that uses semi-indexing
23:02:43 <lispy> I've never written a parser that was obviously too slow but I've written lots of incorrect parsers. So that tends to reflect my priorities :)
23:02:57 <edwardk> I've written plenty of both ;)
23:03:14 <lispy> (I have actually written parsers that were too obviously slow in python, but I meant Haskell)
23:04:43 <edwardk> (i really like the results of that paper, and not just because its a trivial application of a couple of the structures going into analytics right now)
23:05:05 <edwardk> well, ok, mostly just because it is a trivial application of a couple of the structures going into analytics right now
23:08:36 <lispy> edwardk: good thing we cleared that up ;)
23:13:26 <johnw> any timeplot users here?  I can get splot to work great, but tplot gives me bizarre looking jumbled up images, which makes me think something is just failing
23:13:35 <wole> @hoogle a -> b
23:13:35 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
23:13:36 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
23:13:36 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
23:13:42 <johnw> hahaha
23:13:45 <johnw> unsafeCoerce is the first hit
23:13:53 <johnw> edwardk is vindicated
23:14:09 <johnw> i suppose it's the only function that exactly matches that type
23:14:46 <edwardk> well, you could have it launch missiles first
23:15:11 <johnw> that's true, with unsafePerformIO I could make other functions with that type
23:15:27 <johnw> coerceEdwardk :: $$$ -> LotsO'Code
23:15:39 <edwardk> i'm easily coerced by $$$
23:16:04 <edwardk> That should be: ($$$) :: EdwardK -> LotsOfCode
23:16:05 <johnw> the hotel for ICFP is sure $$$
23:16:37 <fruitFly> wow... it's the famous edwardk
23:17:02 <fruitFly> edwardk: heard soo much about you... I am Sir haskell nublet
23:17:17 <edwardk> johnw: if only you knew someone in the boston area with a couch
23:17:32 <johnw> edwardk: is said couch available??
23:17:42 <johnw> crashing with you would be infinitely more joysome
23:19:38 <edwardk> johnw: Let me know the days you plan on being out here and i'll ask my wife. We have sort of a standing "3 days" policy, but I think we can probably make it work
23:19:50 <johnw> let me check my schedule
23:20:28 <edwardk> fruitFly: i just got bored one day and started writing a lot of code. =)
23:20:40 <edwardk> its been a great way to learn a lot of stuff
23:21:25 <johnw> i come into Boston evening of Tue, Sep 24, and leave at noon on Sat 28, which is 5 days inclusive.  But if you want to kick me out after three, even that would be a big help; just let me know in that case so I can simply reduce the reservation
23:21:47 <johnw> and of course all meals would be on me at that point :)
23:21:59 <johnw> why pay to Hilton what can be spent in the name of edwardk?
23:22:14 <fruitFly> haha :)
23:22:14 <johnw> and we can discuss analytics on the drive to/from :)
23:22:15 <edwardk> lets plan on 3 of it then
23:22:45 <edwardk> Its Boston, the commute in is by T =)
23:22:50 <johnw> ok, so if I stay with you for 3 nights, then I only have to spend one night at the hotel
23:23:08 <fruitFly> give him 4 nights dammit~
23:23:18 <johnw> yes, I remember our previous T discussion.  I now know what Rank-2 types do from having to use them several times :)
23:23:40 <edwardk> fruitFly: thats something i'd have to ask my wife, and she's sleeping at the moment
23:23:41 <johnw> fruitFly: another reason for me to stay at the airport is that then I'm right there to catch my flight the next morning
23:23:51 <johnw> i mean, to stay at the airport hotel that 4th night
23:23:53 <johnw> so that actually works out
23:23:57 <edwardk> johnw: that makes some sense
23:24:23 <fruitFly> lameish excuse
23:24:26 <fruitFly> jk :P
23:25:08 <edwardk> too bad you've already booked the flights. i haven't been able to work out if/when we can get a boston haskell hackathon going near icfp
23:25:50 <johnw> edwardk: well, staying longer would have meant more hotel days, and it was straining my budget already.  I justified it simply by the sheer amount of Haskell awesomeness that will be there
23:26:08 <johnw> work is defraying some it, but not the hotel/flight
23:26:15 <edwardk> I can definitely understand that
23:26:28 <johnw> i'll wait until you talk with your wife before changing any reservations
23:26:37 <edwardk> Be warned, I keep odd hours ;)
23:26:38 <johnw> "No" is always a perfectly acceptable answer
23:26:41 <johnw> hahah
23:26:47 <johnw> oddness is my middle name
23:27:10 <edwardk> I can unilaterally commit to the 3 days, anything longer takes both of us, that was the deal we made a while back =)
23:28:17 <edwardk> On vacation, so far i've gotten more code done here than I have at home for the last 2 weeks
23:28:24 <johnw> haha
23:28:33 <johnw> i'm addicted to work this month
23:28:35 <fruitFly> The OS X 10.5 installer isn't working (install button greyed out)... any advice on getting haskell installed on this system?
23:28:58 <johnw> i've been working 50-60 hours weeks, and every time I sit down to do something relaxing, I end up reading Haskell articles, finally understanding some key point, and then going to make the change in our code
23:29:01 <fruitFly> edwardk: what are you currently working on?
23:29:02 <edwardk> fruitFly: never seen that before, maybe someone else knows more
23:29:33 <johnw> today was spent changing our logging out so that I could feed the data into splot, which revealed a latency bug in our interface serialization code
23:29:34 <edwardk> fruitFly: i've been building a 'big data' analytics platform for haskell for calculating interesting aggregations over large datasets in sublinear time
23:29:45 <johnw> fruitFly: do you use hoembrew?
23:30:08 <fruitFly> johnw: I can try..
23:30:13 <johnw> that's what I use
23:30:16 <johnw> brew install ghc
23:30:21 <johnw> then, go download the cabal-install tarball
23:30:31 <johnw> http://hackage.haskell.org/packages/archive/cabal-install/1.16.0.2/cabal-install-1.16.0.2.tar.gz
23:30:37 <johnw> untar that, run "sh bootstrap.sh"
23:30:43 <johnw> then just run "cabal update", and you're good to go
23:31:29 <johnw> if you want a whole bunch of libs to install, do something like "cabal install lens yesod"
23:31:35 <johnw> that will bring in a ton of standard stuff
23:33:23 <fruitFly> thanks johnw :) ... but just got this http://pastebin.com/wwRn9bJM
23:33:26 <mauke> The paste wwRn9bJM has been copied to http://hpaste.org/87725
23:35:17 <johnw> yes, you need to install Xcode
23:35:34 <johnw> and then you need to install the command-line tools for XCode, which is done in its Preferences (google for more info on this)
23:35:39 <johnw> and you also should install Xquartz
23:35:51 <johnw> http://xquartz.macosforge.org/landing/
23:41:04 <fruitFly> johnw: do you think it would just be easier if I upgraded my friends computer to 10.6 ? Where should I install Xcode from... apple?
23:42:08 <johnw> "upgrade to 10.6"?
23:42:19 <johnw> that's like upgrading a T-rex to a velociraptor
23:42:31 <fruitFly> johnw: OS X version
23:42:34 <johnw> i have no knowledge of 10.6, but I used the App Store
23:42:50 <johnw> i've only ever used Haskell on 10.8, I think
23:43:31 <fruitFly> johnw: ok thanks
23:45:09 <fruitFly> johnw: And I travel a lot and want a light mobile dev environment (maybe 11.6 inches.. maybe 13inches.. I just want to keep it light. What do you think is a good processor OS combination for the job?
23:45:32 <fruitFly> johnw: or at least processor
23:45:48 <johnw> do you want to run OS X?
23:46:12 <fruitFly> johnw: probably linux
23:46:14 <Ghoul_> Anyone have any ideas for the IO Bool -> Bool mismatch on line 24? http://hpaste.org/87726 :(
23:46:33 <fruitFly> johnw: maybe nixos, arch, gentoo etc.... not sure yet
23:47:55 <edwardk> fruitFly: this is starting to drift into #haskell-blah territory. i'm a huge macbook air fan for light mobile dev, because i don't notice i'm carrying it, and i can whip it out at a moment's notice and be productive
23:48:36 * cmccann hacks some simple support for sum types into vinyl and is surprised that it sorta works decently
23:48:55 <blaenk> hey is there a way I can annotate source so that when ghc errors it tells me the type of the things I annotated?
23:49:13 <fruitFly> ok thanks.. I appreciate the advice. And the haskell configurability on os x is just as great on linux, right?
23:49:20 <johnw> Ghoul_: I think you need: ((>0) <$> opt 0 "prop3")
23:49:56 <edwardk> haskell on osx works pretty well. just click the installer
23:49:58 <lispy> blaenk: I think you want this, there is a video linked: http://www.reddit.com/r/haskell/comments/19aj9t/holedriven_haskell/
23:50:17 <blaenk> yeah I had heard of holes, but I don't think they're implemented yet?
23:50:20 <blaenk> not sure
23:50:46 <johnw> blaenk: they are in GHC HEAD
23:50:50 <lispy> blaenk: if you click the link at the top there is a video demo that shows you how to sort of "do it yourself" without the holes feature
23:50:59 <blaenk> will check then, thanks
23:51:05 <Ghoul_> johnw: thanks, worked
23:51:15 <lispy> it's not the most elegant thing but it certainly works
23:51:23 <arkeet> also, ImplicitParams
23:51:41 <lispy> :t map ?f [1..]
23:51:43 <lambdabot> (?f::a -> b, Enum a, Num a) => [b]
23:51:46 <edwardk> blaenk: what I use are implicit params as "poor mans' holes"
23:51:57 <edwardk> blaenk: which is to do just what lispy did there
23:51:57 <shachaf> ==edwardk
23:52:09 <shachaf> It's so great.
23:52:11 <blaenk> cool thanks
23:52:15 <shachaf> It's better than holes in HEAD, in fact.
23:52:18 <edwardk> turn on {-# LANGUAGE ImplicitParams #-}  in the module then put ?huh   in wherever you need the type
23:52:20 <johnw> neat trick!
23:52:32 <johnw> I usually use () and then read the type error
23:52:54 <lispy> agda has us beat by a long shot, but these tricks still work
23:53:22 <lispy> there is a certain zen about agda-mode. It's very pleasing.
23:54:25 <natnayr> how do i recursively ensure that [a,a,a] is entirely of type bool
23:54:27 <natnayr> ?
23:54:49 <johnw> by making the type [Bool]....?
23:55:03 <Ghoul_> lol
23:55:13 <djahandarie> You don't do it recursively, unless you're writing a type checker.
23:55:27 <johnw> > [True,False,20] :: [Bool]
23:55:30 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Bool)
23:55:31 <lambdabot>    arising from the literal `2...
23:57:25 <Ghoul_> Mhm, I moved the logic out into a let so I could repeat it over and over again for more bool types
23:58:57 <natnayr> johnw, this is regarding GADTs.. so if i have Term t which i have the option of Int or Bool.. So i have to evaluate that the list are [True, True, False], instead of [1,True,False]
23:59:37 <natnayr> johnw: nah wait, ur right, a list cant have dual types
