00:00:03 <Tene> Google knows of a few options: https://www.google.com/search?q=haskell+detect+character+encoding
00:01:24 <namor> hey. is there a way to force struct evaluation (recursively! not $!)? im writing a benchmark and need a function that works like "print", but does not actually print the data passed.. type: "a -> IO ()" would be fine.
00:01:34 <johnw> is there a Haskell jabber server?
00:01:34 <namor> s/struct/strict
00:03:26 <Cale> namor: look in Control.DeepSeq
00:03:43 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/deepseq-1.3.0.1/Control-DeepSeq.html
00:04:57 <namor> Cale, looks promising. No fbsd port yet, trying to install from cabal..
00:05:30 * namor notices cabal installation works flawlessly
00:05:33 <Cale> It should come with GHC, I think.
00:05:38 <Cale> But okay
00:06:11 <namor> Cale, you are right. That explains why there is no port. :-)
00:07:52 <wagle> johnw: I get googles for haskell jabber  what are you looking for?
00:08:17 <johnw> something I can cabal install
00:08:47 <Cale> namor: deepseq is one of those packages which is transitively a dependency of a *lot* of stuff, and so you should be careful about installing multiple versions of it
00:09:16 <Cale> (because things built against different versions won't be compatible and it can become sort of frustrating to sort out on occasion)
00:09:32 <namor> Cale, yeah, i feared as much. Just ghc-pkg unregistered the local version again.
00:10:27 <namor> i usually only use local cabal installations if i test some new stuff, like the version of largeword i want to benchmark.
00:10:42 <wagle> johnw: pangeas under https://www.google.com/search?q=haskell+xmpp+server+cabal
00:11:07 <wagle> ?
00:11:19 <wagle> i never done it, but I'm curious
00:14:35 <johnw> cool, thanks wagle
00:14:43 <wagle> a local company finds that haskell packages often have category killers that aren't, well, "production quality"
00:15:51 <Saizan> what is a category killer?
00:16:30 <hrookie> anyone here have experience with cereal-conduit?
00:16:45 <Hafydd> The category of killers, Kill.
00:17:35 <namor> Cale, the most "forceful" evaluation option in deepseq seems to be |force = x `deepseq` x|, which is described as doing deep evaluation only if the value of x is demanded, though. I remember seeing |evaluate :: a -> IO ()|  being used in chap 20 of RWH. It's from the Control.Exception.Base package. (evaluate.force) should do the job.
00:17:58 <Cale> namor: yep
00:18:12 <namor> :-)
00:18:18 <wagle> choose a category of software..  write something that matches that category enough to prevent/distract/etc others from developing alternate software for that category
00:18:38 <namor> wagle, haha
00:19:46 <namor> wagle, it's similar to the common lisp world, where you usually find code for everything but it usually does 70% of what you need. (haksell may be 80% tho)
00:23:23 <wagle> has someone written a hoogle app/hook for firefox search box?
00:24:38 <wagle> @google hoogle
00:24:40 <kappabot> http://www.haskell.org/hoogle/
00:24:40 <kappabot> Title: Hoogle
00:24:54 <wagle> gee
00:24:57 <hrookie> this might be funny to ask, but would serialized data ever contain a space character, or a newline?
00:25:12 <wagle> why not?
00:25:39 <hrookie> those seem like extremely special values to have lying around
00:25:53 <wagle> just like any other char
00:25:59 <hrookie> this is a true fact
00:26:11 <hrookie> statistically, it could definitely appear
00:26:25 <wagle> and just as likely for random data
00:26:41 <hrookie> yeah
00:27:01 <wagle> that answer your question?
00:27:03 <hrookie> i suppose going with the cereal-conduit library is my best bet to not manually parse data structures
00:27:16 <hrookie> yeah. i'm just trying to find a way to easily feed discrete chunks of custom data across the network
00:27:33 <hrookie> unfortunately, a lot of that functionality is brand-spanking-new in haskell, and has only "experimental" stability, and little to no docs or tutorials >.>
00:28:16 <hrookie> currently considering switching to python over that
00:28:42 <wagle> im not the person to go to for that..  in a couple years I might get better
00:29:15 <hrookie> yeah. i mean, though, even when i get all this stuff up and running, i've only talked to one other person who achieved what it is i'm trying to achieve
00:29:21 <hrookie> and no matter how you do it, it's just hacky right now
00:29:33 <hrookie> synchronized broadcast from a server to a list of active clients
00:30:56 <wagle> binary data is just binary data..  no stop bits, just a length and that number of 1's and 0's
00:31:25 <hrookie> in response to?
00:31:28 <wagle> are you thinking in C with null-terminated strings
00:31:31 <wagle> ?
00:31:54 <arcatan> jlaire: :O
00:32:09 <wagle> you are worried about spaces and newlines, I'm reasoning out why you might bee wary
00:32:11 <wagle> be
00:32:25 <hrookie> oh, i was considering cheating and just having the server process lazily with "lines"
00:32:28 <hrookie> =D
00:32:41 <jlaire> arcatan: :O
00:32:56 <wagle> note that your messages are going to get broken up into packets
00:33:05 <hrookie> wagle: yes, clearly.
00:33:32 <hrookie> wagle: you can currently get away with pretending a TCP socket is a file handle, and reading out of that, since TCP guarantees correct and in-order transmission
00:33:53 <wagle> the packet breaks aren't neccessarily on line boundaries
00:34:03 <hrookie> wagle: yes, i am *very* well-aware.
00:34:10 <wagle> ok
00:35:12 <hrookie> wagle: there are a variety of ways of determining which chunk of TCP data you want. one such way is to say "all the incoming data on this socket is one giant file. lines it, then mapM_ (processor function) (lines input)
00:35:41 <wagle> i'm reacting to having a bug once where during the day, when I tested, everything was in a single packet..  at night, when it was bugged, it got broken into three packets, and a TCP reset between the second and third blew up the connection
00:36:12 <hrookie> wagle: wow, right in between two packets? that sucks
00:36:28 <hrookie> wagle: talk about timing
00:37:43 <wagle> i dont remember exactly what it was, but it was doing it to close one side of the two counter-directional network pipes
00:38:25 <wagle> anyway, back to your problem
00:38:42 <wagle> oic
00:39:06 <wagle> could uuencode it
00:39:42 <wagle> which is a weak compression which breaks it into lines of ascii
00:41:14 <Kinnison> uuencode doesn't compress
00:41:44 <Kinnison> You could compress and then uuencode, but uuencoding (or base64, etc) increases the transfer size in order to 'ascii armour' the content
00:41:47 <wagle> yeah, i just figured that out, and came back to say that
00:43:19 <wagle> could think in fixed sized records instead of variable sized ones (with line and space delimiters)
00:44:08 <wagle> then you get to ByteStrings or whatever, which I dont understand at the moment
00:44:13 <adnap> Hey
00:44:46 <adnap> So, I didn't really have my full attention earlier
00:44:57 <adnap> Let's see if I can be more clear...
00:47:01 <hrookie> well
00:47:07 <hrookie> the obvious answer is
00:47:19 <hrookie> let cereal-conduit and network-conduit handle it for us
00:47:28 <hrookie> cereal-conduit: seralize data and pump it through
00:47:32 <hrookie> network-conduit: slap conduits on sockets
00:47:42 <hrookie> end result: serialized conduits slapped on sockets
00:48:07 <wagle> over my head, not familier with any of that
00:48:23 <hrookie> conduit: streaming data goodness in constant space
00:48:36 <b___> I read in a comment no reddit that if I have a data type where a field can be derived from the other fields, it's preferable to write a function for it and ditch the field. Is there a concensus on this? (I'm sure it depends on performance and use of the field, but in terms of design, is it preferable?)
00:48:38 <adnap> In C, a pure function which returns a modified copy of its argument will incur a time cost of O(log n), where n is the running time of a function which mutates its argument. The running time increases as the memory being copy increases, so the copy cost is bounded by the running time. A pure Haskell function will also incur the same cost as the pure C function.
00:48:53 <adnap> *worst cast time cost
00:49:46 <hrookie> b___: i would wager it's preferable to ditch the field in most cases, because you're going to have to compute it to use it anyway
00:50:08 <hrookie> b___: heeding, of course, to the dependency on performance/use of the field. if it makes no difference, i'd ditch it.
00:50:35 <wagle> i can imagine situations where the haskell would use a special instruction, but the C wouldnt (and vice versa)
00:50:45 <b___> ok, even when the datatype describes the header of a known filetype?
00:51:12 <hrookie> b___: i'm not quite sure what you mean
00:51:23 <wagle> sorry, not used to several conversations at once
00:51:34 <hrookie> b___: so it's just a type that says like "HTML this encoding that thingy"
00:51:42 <wagle> dont stop, i'll just rremember to say who I'm talking too
00:52:09 <b___> hrookie: no it is for example the decoded fields of the header of a WAV file
00:52:25 <hrookie> b___: oh, well in that case, i'd probably leave it as a field, yeah.
00:52:31 <b___> alright :)
00:52:44 <hrookie> b___: in that case, i'd say it makes a difference =).
00:52:58 <hrookie> this is a random general question, but if i enjoy haskell, would i more likely enjoy python, or ruby?
00:53:07 <b___> python
00:53:09 <hrookie> trick question, their type systems both suck. just kidding, which one would i like more.
00:53:23 <wagle> adnap: some machines have special instructions for copying data..  haskell might be better prepared to use them automagically
00:53:34 <wagle> ... or not..
00:53:34 <adnap> Python's type system is a map String -> Identifier
00:54:00 <mauke> hrookie: perl
00:54:28 <adnap> or String -> Value
00:54:43 <mauke> (reference: I like haskell and perl; I don't like python)
00:54:55 <adnap> wagle: Huh?
00:55:18 <hrookie> mauke: =)
00:55:44 <hrookie> i have a tiny bit of background in python, so i'm leaning toward that for now
00:56:11 <adnap> To put my statements in context, I want to make a pure Haskell function from a C function which modifies a big struct. I am worried about about the cost of copying the struct.
00:56:13 <EmilyScott> I'm not sure I'm in the right channel, but I was wanting to talk about programming language design with someone, and this was the first place that came to mind(sorry to interrupt)
00:56:46 <hrookie> ahoy! the time! almost 01:00. it looks like i have to leave, despite the fact that it looks like a fun discussion is about to ensue :(
00:56:50 <hrookie> night all~~
00:56:57 <adnap> I am reading http://www.haskell.org/haskellwiki/Monad/ST now, as someone mentioned ST earlier. So far, the introduction sucks.
00:57:02 <wagle> adnap: if i made no sense, don't worry about it..  i was thinking in terms of the instructions used to process the data, and thinking haskell compiler would be more prepared to exploit them, but I dont know that for a fact
00:58:07 <wagle> EmilyScott: good place
00:58:29 <EmilyScott> wagle - but my language isn't haskell and I wrote the interpreter in Java... ;)
00:59:28 <wagle> haskell's easier to write interpreters in...  what did you interpret?
01:00:17 <EmilyScott> well, the language is my own oddity, and I wrote it for doing templates for web apps.
01:00:59 <wagle> EmilyScott: what you might get here is how to do that in haskell instead of java
01:01:26 <shachaf> It's not really the right channel but the "just ask, don't ask to ask" rule still applies. :-)
01:02:08 <EmilyScott> I wandered in here because I was trying to think about how to explain some of the stuff in my language, and I figured getting in to, e.g. "is this dynamically scoped or lexically scoped" would involve less explaining here than somewhere else.
01:02:22 <wagle> yeah, if you can keep it on general principles instead of java specific, that might work very well
01:02:52 <wagle> well, I'm interested, i dunno about others though
01:02:56 <EmilyScott> so semantics of a little language was really more of the topic. But it's still not haskell per se. :/
01:03:00 <EmilyScott> I can PM if you want?
01:03:04 <wagle> sure
01:03:07 <mauke> or #haskell-blah
01:03:19 <EmilyScott> that exists?
01:03:29 <wagle> that might make more sense, lets more people join in
01:03:53 <EmilyScott> I'm shy... having one person tell me I'm crazy is better than a whole IRC channel. ;)
01:04:09 <wagle> you arent crazy
01:04:11 <shachaf> A channel is much better to ask than one person.
01:04:40 <wagle> try #haskell blah, and if you cant stand it, we can PM
01:04:46 <EmilyScott> alright.
01:04:48 <EmilyScott> thanks. :)
01:05:08 * hackagebot asn1-types 0.2.0 - ASN.1 types  http://hackage.haskell.org/package/asn1-types-0.2.0 (VincentHanquez)
01:05:10 * hackagebot asn1-encoding 0.8.0 - ASN1 data reader and writer in RAW, BER and DER forms  http://hackage.haskell.org/package/asn1-encoding-0.8.0 (VincentHanquez)
01:05:12 * hackagebot hist-pl 0.2.0 - Umbrella package for the historical dictionary of Polish  http://hackage.haskell.org/package/hist-pl-0.2.0 (JakubWaszczuk)
01:05:16 * hackagebot asn1-parse 0.8.0 - Simple monadic parser for ASN1 stream types.  http://hackage.haskell.org/package/asn1-parse-0.8.0 (VincentHanquez)
01:05:19 <wagle> (i didnt know about haskell blah either)
01:05:47 <wagle> hmm..  they are discussing trek in there
01:06:06 <adnap> Can someone point me to a good explanation of the ST monad?
01:06:24 <shachaf> They discuss anything that isn't Haskell in there. That's the point.
01:10:08 * hackagebot x509 1.4.0 - X509 reader and writer  http://hackage.haskell.org/package/x509-1.4.0 (VincentHanquez)
01:10:10 * hackagebot x509-store 1.4.0 - X.509 collection accessing and storing methods  http://hackage.haskell.org/package/x509-store-1.4.0 (VincentHanquez)
01:10:13 * hackagebot x509-system 1.4.0 - Handle per-operating-system X.509 accessors and storage  http://hackage.haskell.org/package/x509-system-1.4.0 (VincentHanquez)
01:10:15 * hackagebot x509-validation 1.4.0 - X.509 Certificate and CRL validation  http://hackage.haskell.org/package/x509-validation-1.4.0 (VincentHanquez)
01:10:17 * hackagebot x509-util 1.4.0 - Utility for X509 certificate and chain  http://hackage.haskell.org/package/x509-util-1.4.0 (VincentHanquez)
01:12:25 <Cale> adnap: Well, the main things to know are runST (from Control.Monad.ST), along with the stuff from Data.STRef, http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-STRef.html
01:12:59 <adnap> Cale: Should I try to figure out how it works by reading the hackage doc?
01:13:05 <quchen> adnap: ST is like a more constrained version of IO that allows a safe version of unsafePerformIO, basically.
01:13:20 <Cale> adnap: Unless you're concerned with the actual implementation, then yeah
01:13:25 <adnap> quchen: Sorry, but that's not helpful
01:13:54 <Cale> Okay, so the basics are:
01:13:54 <shachaf> What an operational view.
01:14:01 <Cale> runST :: (forall s. ST s a) -> a
01:14:29 <Cale> Don't let the forall there scare you too much. The point is that whatever the type 'a' is, it can't depend in any way on s.
01:14:55 <RoboTeddy> hmm if I install a package via cabal (e.g. cabal install gloss-examples), where does it put the source code of the package? (I wanna go read it). I see a /Users/<myuser>/.cabal/packages/hackage.haskell.org/gloss-examples/1.7.7.201204.1/gloss-examples-1.7.7.201204.1.tar.gz -- should I just extract?
01:15:09 * hackagebot crypto-pubkey-types 0.4.0 - Generic cryptography Public keys algorithm types  http://hackage.haskell.org/package/crypto-pubkey-types-0.4.0 (VincentHanquez)
01:15:10 <Cale> (this prevents you from sneaking mutable variables out in the result of your computation)
01:15:11 * hackagebot crypto-pubkey 0.1.4 - Public Key cryptography  http://hackage.haskell.org/package/crypto-pubkey-0.1.4 (VincentHanquez)
01:15:27 <Cale> and then you have:
01:15:32 <Cale> newSTRef :: a -> ST s (STRef s a)
01:15:36 <Cale> readSTRef :: STRef s a -> ST s a
01:15:40 <Cale> writeSTRef :: STRef s a -> a -> ST s ()
01:16:37 <Cale> newSTRef takes a value of some type a, and produces an ST action which creates a new STRef initialised with that value.
01:16:46 <adnap> So, you can only make an ST where a is a (STRef s a)?
01:17:23 <Cale> Well, this is a monad, we can join these things together in the usual ways
01:17:57 <Cale> :t do r <- newSTRef 0; v <- readSTRef r; writeSTRef r (v + 1); return v
01:17:58 <kappabot> forall b s. Num b => ST s b
01:18:08 <Cale> > runST (do r <- newSTRef 0; v <- readSTRef r; writeSTRef r (v + 1); return v)
01:18:09 <kappabot>   No instance for (GHC.Num.Num ())
01:18:09 <kappabot>    arising from the literal `1'
01:18:09 <kappabot>  Possible ...
01:18:16 <Cale> > runST (do r <- newSTRef 0; v <- readSTRef r; writeSTRef r (v + 1); return v) :: Integer
01:18:17 <kappabot>   0
01:18:32 <Cale> (some ambiguity there about which type of number it was...)
01:18:43 <Cale> > runST (do r <- newSTRef 0; v <- readSTRef r; writeSTRef r (v + 1); readSTRef r) :: Integer
01:18:44 <kappabot>   1
01:19:02 <Cale> so there you can see that we actually updated the value
01:19:25 <Cale> There's also  modifySTRef :: STRef s a -> (a -> a) -> ST s ()
01:19:56 <Cale> which applies a function to the contents of an STRef (lazily though, so be careful about building up large expressions in them)
01:20:03 <Cale> and a strict version of that:
01:20:08 <Cale> modifySTRef' :: STRef s a -> (a -> a) -> ST s ()
01:20:29 <Cale> > runST (do r <- newSTRef 0; modifySTRef (+1); readSTRef r) :: Integer
01:20:30 <kappabot>   Couldn't match expected type `GHC.ST.ST s a0'
01:20:30 <kappabot>              with actual type...
01:20:36 <Cale> > runST (do r <- newSTRef 0; modifySTRef r (+1); readSTRef r) :: Integer
01:20:36 <kappabot>   1
01:20:51 <Cale> adnap: cool?
01:21:12 <adnap> Yeah, but...
01:21:23 <adnap> What is the purpose of STRef?
01:21:42 <Cale> It's like a mutable cell which holds a value which can be changed as the computation proceeds.
01:21:49 <arkeet> it's the reason ST exists.
01:22:08 <adnap> It seems like an IORef
01:22:18 <arkeet> yes, except you don't need IO
01:22:28 <adnap> But with a phantom type s
01:22:34 <Cale> yes
01:22:49 <arkeet> so you can use it in pure code
01:23:14 <adnap> Because...
01:23:19 <arkeet> because runST exists.
01:23:22 <Cale> See, if we tried to return our STRef from the computation that we run in runST, we'll get a type error about that
01:23:23 <adnap> The s restricts all mutation to within the ST monad
01:23:33 <adnap> And you can only pull a out when you're done mutating
01:23:34 <Cale> > runST (do r <- newSTRef 0; return r) :: Integer
01:23:35 <kappabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
01:23:35 <kappabot>              with a...
01:23:40 <Cale> > runST (do r <- newSTRef 0; return r)
01:23:41 <kappabot>   Couldn't match type `a'
01:23:41 <kappabot>                 with `GHC.STRef.STRef s GHC.Integer...
01:24:06 <Cale> :t runST (do r <- newSTRef 0; return r)
01:24:07 <kappabot>     Couldn't match type `a' with `STRef s Integer'
01:24:07 <kappabot>       `a' is a rigid type variable bound by
01:24:07 <kappabot>           the inferred type of it :: a at Top level
01:24:15 <adnap> :t unsafePerformIO
01:24:17 <kappabot> Not in scope: `unsafePerformIO'
01:24:25 <Cale> unsafePerformIO :: IO a -> a
01:24:37 <adnap> How is this different?
01:24:51 <Cale> Evaluation of the expression (unsafePerformIO x) will cause the action x to be carried out
01:25:00 <Cale> which can cause arbitrary effects on your computer
01:25:28 <Cale> However, the only things available in the ST monad are memory effects on newly defined memory cells
01:25:30 <adnap> So, ST is weaker because you can only do mutations with pure functions?
01:25:52 <Cale> and that means that whatever it is that an ST action computes, it'll proceed in exactly the same way every time
01:25:54 <shachaf> Explaining ST in terms of unsafePerformIO is kind of bizarre since unsafePerformIO is almost meaningless.
01:26:00 <Cale> yes, that's true
01:26:15 <shachaf> Or, at least, very operationally minded.
01:26:16 <Cale> I don't really like that explanation, but I thought I might as well clear it up now that it's on the table
01:26:27 <adnap> What explanation?
01:26:38 <Cale> The explanation of runST as a kind of unsafePerformIO
01:26:52 <adnap> Is what I said correct?
01:26:58 <Cale> It is *kinda* like that... you could even implement it like that
01:27:04 <adnap> You can't do any IO in the ST monad...
01:27:07 <Cale> right
01:27:17 <Cale> you can't do any actual I/O in the ST monad
01:27:21 <adnap> But you have some state
01:27:27 <Cale> arbitrary amounts of state
01:27:31 <adnap> That you can modify with pure functions
01:27:38 <Cale> There's also array libraries
01:28:10 <adnap> So, someone brought ST up earlier as a solution to making a pure function from a C function which modifies a value pointed to by its pointer argument
01:28:14 <Cale> Data.Array.ST defines an array type for ST which can be used with the operations of the MArray class defined in Data.Array.MArray
01:28:34 <Cale> yeah
01:28:46 <adnap> I haven't made the connection yet
01:29:03 <Cale> Well, an STRef s a is a lot like a pointer to a
01:29:11 <Cale> except that you can't do pointer arithmetic
01:30:02 <Cale> You can think of it as a memory location where a value of type a sits, and that value can be updated and read.
01:30:06 <adnap> But I have to use pure functions to mutate the a
01:30:22 * shachaf still wants to know what the minimal primitives needed to implement the ST interface are.
01:30:35 <adnap> So, I don't see how I can use impure C functions
01:30:40 <Cale> adnap: The ST computation itself that you're running is an imperative program.
01:30:48 <Cale> (of sorts)
01:31:13 <Cale> You can write loops and create arbitrary amounts of additional state, and modify things over time
01:32:01 <Cale> You can imagine translating a C program which used pointers, but did no I/O into an ST computation fairly directly.
01:32:43 <adnap> So imagine I have struct A { int x; }; and void foo(struct A *p) { p->x +=1; }
01:32:47 <Cale> i.e. a C program which did some computation which was actually of a pure function, or some constant.
01:33:04 <adnap> And I want a Haskell function foo :: A -> A
01:33:16 <adnap> How does the ST monad help me?
01:33:53 <Cale> data A = A Int
01:34:15 <Cale> foo :: STRef s A -> ST s ()
01:34:51 <adnap> I want to actually use the C function because I am trying to optimize the Haskell function foo :: A -> A
01:34:53 <Cale> foo r = do (A v) <- readSTRef r; writeSTRef (A (v+1))
01:35:09 * hackagebot x509 1.4.1 - X509 reader and writer  http://hackage.haskell.org/package/x509-1.4.1 (VincentHanquez)
01:35:11 * hackagebot hist-pl 0.2.1 - Umbrella package for the historical dictionary of Polish  http://hackage.haskell.org/package/hist-pl-0.2.1 (JakubWaszczuk)
01:35:13 * hackagebot x509-validation 1.4.1 - X.509 Certificate and CRL validation  http://hackage.haskell.org/package/x509-validation-1.4.1 (VincentHanquez)
01:35:26 <Cale> adnap: There's no FFI to ST
01:35:37 <Cale> adnap: You can't actually call C code from ST
01:35:57 <adnap> Okay, then I don't know why someone brought this up as a solution earlier. I guess they just misunderstood me
01:36:25 <Cale> adnap: They probably thought you wanted a way to translate a C program into Haskell
01:36:40 <adnap> the point is the the C foo is fast, and I want to take advantage of the in-place mutation
01:36:41 <Cale> and ST does give you a... somewhat awkward, but reliable way to do it
01:36:57 <adnap> But I want to use the FFI to create a pure function from the C foo
01:36:59 <Cale> and you can take advantage of in-place mutation with ST of course
01:37:11 * shachaf wishes GHC was better at optimizing ST.
01:37:15 <adnap> Yes, but I want the speed of C too
01:37:34 <adnap> Is it possible, or do I have to make a pure C function?
01:37:35 <Cale> You can just use the FFI to import the C function as a pure Haskell function, or else use unsafePerformIO for that
01:38:25 <adnap> but haskellFoo a `seq` haskellFoo a might give a different result than haskellFoo a
01:38:26 <Cale> But yeah, if the C function itself has other effects which would be a problem if they happened somewhat unpredictably, then you should do something to wrap it up a bit.
01:38:31 <Cale> no
01:38:39 <Cale> x `seq` x is unconditionally equal to x
01:38:46 <Cale> no matter what x is
01:38:55 <adnap> Even if the function has side effects?
01:39:12 <Cale> oh, yeah, like that, yes
01:39:18 <arkeet> evaluation /= execution
01:39:37 <adnap> Uh...
01:39:46 <adnap> I think it is if x is a haskel function calling a C functon
01:39:49 <arkeet> evaluating  putStrLn "hello" `seq` 5  will not print anything.
01:39:50 <Cale> You should make sure that the execution of the C code will be invisible enough that you can pretend that haskellFoo a `seq` haskellFoo a is the same as haskellFoo a
01:40:09 <arkeet> if your C function isn't pure, it should be imported as some IO function.
01:40:11 <Cale> (if you're using unsafePerformIO or FFI importing the C function as pure)
01:40:16 <Cale> right
01:40:22 <adnap> Well, can we just start from the example I gave?
01:40:35 <adnap> The C function is obviously not pure
01:40:41 <Cale> Can we know what you're actually importing?
01:40:51 <adnap> Importing?
01:40:58 <Cale> Well, I don't think that's obvious...
01:41:06 <Cale> The sin function in C is pure.
01:41:15 <Cale> (along with most other math stuff)
01:41:17 <adnap> So imagine I have struct A { int x; }; and void foo(struct A *p) { p->x +=1; }
01:41:48 <adnap> I want to use the FFI to create a type A in Haskell, which references a struct A
01:41:51 <Cale> For something that trivial, I don't think you'll see a benefit to using FFI here.
01:41:56 <adnap> I know!
01:42:01 <adnap> It's just a simple example
01:42:04 <arkeet> then your imported thing would have some type like  Ptr A -> IO ()
01:42:15 <Cale> yeah
01:42:33 <Cale> and you'd want to write an instance of Storable for A
01:42:35 <adnap> So, there is absolutely no way to make a pure function in Haskell with the impure C function?
01:42:56 <mauke> sure there is
01:42:57 <eikke> there is, but you shouldn't do that kind of stuff
01:42:58 <Cale> adnap: Well, what do you want to do?
01:43:02 <arkeet> how would you make it pure?
01:43:07 <Cale> That function isn't pure
01:43:11 <adnap> That is the question I am asking!
01:43:19 <adnap> I know it's not pure
01:43:22 <arkeet> what would it do?
01:43:22 <mauke> serialize Haskell value to C object, call mutator, deserialize to new Haskell value
01:43:32 <adnap> The reason I want to use an impure C function is to avoid the cost of copying the struct A
01:43:34 <mauke> unsafePerformIO it
01:43:54 <Cale> You're going to have to malloc anyway.
01:44:09 <mauke> unless your Haskell value wraps a pointer
01:44:16 <mauke> but that's the opposite of pure
01:44:35 <Cale> and the Storable instance will effectively copy the Haskell datastructure into a format which is readable by the C code
01:44:54 <Cale> Because in memory, a Haskell data type like  data A = A Int
01:44:54 <adnap> I'm a bit lost
01:44:58 <adnap> I don't know Storable
01:45:03 <adnap> I should read about that
01:45:03 <Cale> looks absolutely nothing like that C struct you defined
01:45:22 <Cale> In particular, the Int field will be a pointer *to code*
01:45:48 <adnap> I think by serializing and deserializing, I am effectively making a copy
01:45:52 <arkeet> you could make it an unboxed strict thing
01:45:56 <mauke> newtype A = A Int#
01:45:56 <Cale> which when entered, has the effect of putting a Haskell Int on the stack, which is itself a pointer to code...
01:45:59 <adnap> When I could just write a pure C function which makes a copy
01:46:59 <Cale> (and of course, the Haskell compiler often optimises away lots of redundant boxings and unboxings)
01:47:21 <adnap> I don't actually care if the Haskell type is accessible...
01:47:22 <adnap> meaning
01:47:33 <adnap> I don't care if it looks like data A = A Int
01:47:44 <tdammers> hehe, I almost doubted Haskell
01:47:57 <adnap> because the interface can hide the value constructor
01:48:03 <tdammers> wrote a little benchmark that reads a 1.4 MB JSON file
01:48:08 <Cale> adnap: A common trick for opaque C-side data is to use  newtype A = A (Ptr A)
01:48:16 <tdammers> haskell performed slightly worse than PHP and Python
01:48:28 <adnap> Cale: Yes, that is essentially what I want
01:48:55 <tdammers> but now I'm running a test that does it 1000 times
01:49:02 <Cale> You can even use newtype deriving to derive Storable for that
01:49:05 <adnap> Cale: If I am understanding it right. Is the (Ptr A) a pointer to the C A type?
01:49:18 <Cale> It really means it's a pointer to the Haskell A type
01:49:39 <Cale> But it doesn't really matter
01:49:46 <adnap> I'm so lost...
01:49:46 <mauke> it's really an opaque pointer
01:50:00 <Cale> Because at the end of the day, everything's a void pointer.
01:50:09 * hackagebot tls-extra 0.6.3 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.6.3 (VincentHanquez)
01:51:01 <Cale> The infinite recursion here doesn't actually matter, it's just cute.
01:51:23 <adnap> I think I need to read how to referece C pointers in Haskell before I can form another good question
01:51:50 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Ptr.html
01:52:47 <adnap> I know I have something like struct A { int x; }; and void foo(struct A *p) { p->x +=1; }, and I want to make a Haskell type A which holds a pointer to a C struct A and whose value constructor is not exported, and I want to have a pure Haskell function A -> A which internally calls the C function foo
01:53:13 <adnap> or does something equivalent, which avoids making a copy of the struct A
01:53:43 <Cale> That's unsafe, and will be broken as hell
01:54:09 <eikke> adnap: someone explained last night (for me at least :P) how that breaks when using e.g. `seq`
01:54:18 <adnap> Okay
01:54:19 <tdammers> surprisingly, at 100 iterations, PHP still beats Haskell
01:54:22 <Cale> You don't even need seq
01:54:25 <Cale> You just need tuples
01:54:30 <adnap> So, I don't want to make anything unsafe, so perhaps it's not possible
01:54:33 <Cale> What if someone writes (foo x, foo x)
01:54:46 <adnap> I need to find a way to write a pure C function which doesn't deep copy
01:55:25 <eikke> adnap: if your C procedure modifies some data in-place, it's impure, by definition
01:55:36 <Cale> adnap: Perhaps you'd be better off with A -> IO A?
01:56:04 <eikke> adnap: and the only way to make sure nothing is mutated in-place is 1) copy (part of it), or 2) guarantee somehow the 'original' value can't be used anywhere else before modifying it in-place
01:57:42 <adnap> So, I have to copy everything that is going to be modified...
01:58:55 <Cale> adnap: What are you *actually* doing?
01:58:57 <adnap> if I have struct A { int *x }; and foo would modify the value pointed to by x, then I need to make a deep copy of the value pointed to by x
01:59:15 <adnap> Cale: It's kind of a long story
01:59:46 <frontendloader> deep copy
01:59:48 <adnap> Give me a sec to try and think of how to explain
01:59:50 <frontendloader> what a horrible thing to do
02:00:09 <frontendloader> one time I thought I needed to do that in LUA, but I didn't.
02:00:32 <Cale> There are frequently ways to avoid having to copy an entire data structure when constructing an updated version of it.
02:00:41 <Cale> while not mutating the original
02:01:21 <Cale> (i.e. by referring to the rest, or most of the rest of the old structure in-place without having to copy)
02:01:50 <_emm_> tdammers: I assume "PHP" is actually a C function with a thin wrapper?
02:01:50 <adnap> Cale: But if the original structure would be thoroughly mutated, then one has to make a copy of everything, right?
02:03:01 <Cale> adnap: Well, yeah, though presumably the old structure is immediately garbage as well.
02:03:18 <Cale> (except when it isn't, and things still behave okay in that case)
02:03:48 <tdammers> _emm_: I think it is, yes. json_decode.
02:04:10 <tdammers> it is also incorrect, so I don't think it really counts anyway
02:04:44 <tdammers> (for kicks: var_dump(json_decode("trUE"));)
02:04:45 <mauke> http://www.reddit.com/r/lolphp/comments/1efmol/i_love_json_its_so_easy/
02:05:00 <tdammers> ^ that's what made me do it in the first place :D
02:05:09 * hackagebot http-streams 0.6.0.1 - An HTTP client using io-streams  http://hackage.haskell.org/package/http-streams-0.6.0.1 (AndrewCowie)
02:05:33 <tdammers> it also shows how the PHP crows is apparently not very good at writing parsers
02:05:44 <tdammers> which in turn partially explains the general state of PHP
02:06:09 <Cale> tdammers: I was about to say...
02:07:12 <mauke> http://www.reddit.com/r/lolphp/comments/ps6x5/0x0_wat/
02:08:33 <tdammers> Normal programmers go "First, make it work. Then make it correct. Then make it fast.". PHP is more like "First, make it fast. Then make a reasonable effort to make it work. Then you're done."
02:08:54 <tdammers> mauke: didn't they fix this one by now?
02:09:01 <mauke> yeah, a while ago
02:09:31 <mauke> but it took a separate patch to fix the same bug in the copy/pasted code for binary literals IIRC
02:09:35 <tdammers> did they fix it as promptly as #32100?
02:09:39 <_emm_> I'm not sure I would characterise most of PHP as an effort to "make it fast"
02:11:03 <tdammers> _emm_: I was hinting at the common situation where people say that PHP isn't doing things correctly, and PHP zealots are all like "yeah, OK, but it's faster than {your language here}"
02:15:50 <benj_> PHP isn't particularly fast
02:18:27 <benj_> sure it's faster than, say, Rails, but that's really not saying much
02:31:12 <Rhainur> sorry guys. this is going to seem a bit spammy, but I just started learning haskell yesterday, and today I read about list comprehensions
02:31:25 <Rhainur> and now I feel an intense pain for all the years I've lost
02:32:09 <Saizan> list comprehensions aren't _that_ great
02:33:08 <no-n> they are in python too
02:33:21 <no-n> /kick no-n off-topic
02:34:26 <Rhainur> context: I'm a PHP dev trying to escape
02:36:23 <bitonic> Rhainur: if you did useful things with PHP, it wasn’t time lost, and there’s always time to learn :)
02:45:10 * hackagebot crypto-pubkey-openssh 0.2.1 - OpenSSH keys decoder/encoder  http://hackage.haskell.org/package/crypto-pubkey-openssh-0.2.1 (FedorGogolev)
02:51:04 <dreixel> any easy way to tell cabal-install "ignore this library's constraint and instead use this one"?
03:02:17 <bitonic> dreixel: I don’t think so, without editing the .cabal file
03:02:38 <bitonic> but dcoutts_ probably knows best
03:04:19 <earthy_> there is install --force, isn't there?
03:05:31 <c_wraith> that forces an install that would break an installed package. It doesn't force attempting to compile against a different version of the package than the .cabal file specifies
03:05:35 <bitonic> earthy: but I think that would still require installation of the ‘right’ libraries, even if they could be break things
03:05:46 <bitonic> /s/be//
03:06:19 <earthy> hm. right.
03:06:19 <c_wraith> as far as I know, editing the .cabal file is the only way
03:07:03 <earthy> http://stackoverflow.com/questions/6312592/haskell-cabal-how-to-ignore-dependencies has dons' answer...
03:07:10 <earthy> which concurs with c_wraiths
03:07:23 <earthy> so, nope, only editing the .cabal file works.
03:08:25 <c_wraith> bitonic said the same thing before me. Give him the credit. I was just agreeing. :)
03:10:11 * hackagebot language-puppet 0.4.0 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.4.0 (SimonMarechal)
03:16:41 <SpockzT> Is it possible to find whether there exists an instance Eq a when you have the constraint Typeable a?
03:23:48 <yitz> SpockzT: you can specify Eq a as an additional constraint
03:24:20 <SpockzT> yitz: yes I could, but that would defeat the purpose in my case
03:25:11 * hackagebot hcube 0.1.0 - Virtual Rubik's cube of arbitrary size.  http://hackage.haskell.org/package/hcube-0.1.0 (ToddWegner)
03:25:44 <ocharles> Aw, I wanted that to be of arbitrary dimensions
03:26:14 <c_wraith> I can solve a 1x1x1 cube *really* fast
03:26:31 <ocharles> I'd probably build a Lego robot to do that
03:26:50 <SpockzT> yitz: in my case I want to do something different when I happen to have Eq
03:27:20 <c_wraith> no way to determine the instances you have available at runtime.
03:27:35 <c_wraith> You can check at compile time, though, via template haskell.
03:27:52 <c_wraith> But that requires knowing the concrete type at compile time.
03:28:50 <bsrk> Hi
03:28:55 <SpockzT> c_wraith: so not even with cast?
03:28:58 <yitz> SpockzT: the whole idea of type classes is that you want them to be determined at compile time.
03:29:01 <bsrk> I need to make a HTTP request
03:29:08 <bsrk> sorry https request
03:29:31 <bsrk> is there a haskell package that supports this?
03:29:48 <bsrk> HTTP (http://hackage.haskell.org/package/HTTP-4000.2.8) does not seem to
03:30:09 <c_wraith> basically every other HTTP client library does support https
03:30:24 <bsrk> ah, so what should I use?
03:30:51 <c_wraith> whichever one has the api you like? There are tons of options
03:31:50 <c_wraith> http://hackage.haskell.org/package/http-wget is probably
03:31:52 <c_wraith> the simplest
03:32:17 <c_wraith> Though I'm not 100% certain that one actually supports https
03:32:38 <Kinnison> From the package description:
03:32:38 <FUZxxl> If anybody wants free tickets for the LinuxTag in Berlin next week, drop me an email (fuz@d00m.org).
03:32:39 <Kinnison> This provides the simplest interface I could imagine to making HTTP requests. It supports GET and POST parameters. Since it simply wraps the WGET program, there are no library dependencies, and it automatically gets HTTPS.
03:32:44 <SpockzT> yitz: so suppose I have a function f with some constraints X and a type parameter a. Could I (perhaps with Template Haskell) have a different implementation of f when I/the compiler know(s) that there is an additional Eq instance?
03:33:00 <c_wraith> oh, that's actually a wget wrapper? ick.
03:33:55 <bsrk> c_wraith: I will use http-wget then. :)
03:34:11 <SpockzT> yitz: You can't do it with typeclasses because you only change the constraints so you get undecidable/overlapping instnaces
03:34:58 <yitz> SpockzT: right
03:35:09 <yitz> SpockzT: are you trying to do OOP in haskell?
03:35:11 <SpockzT> yitz: So I wanted to try to do it with cast
03:35:11 * hackagebot wai-app-static 1.3.1.3 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-1.3.1.3 (MichaelSnoyman)
03:35:36 <SpockzT> yitz: not directly
03:36:49 <yitz> SpockzT: generally, we don't want it to be possible to have more than one implementation for a function. we want functions to have reliable fixed semantics.
03:36:50 <sigma1409> hi, does anyone have any experience with zeromq in haskell? I'm wondering if there is a gotcha somewhere that I'm missing...
03:37:01 <SpockzT> yitz: I have a deep embedding of the Arrow class, but I do not want to force the user by putting the Eq constraint on my constructors. But I can 'optimise' certain functions when we happen to have an Eq instance
03:37:18 <yitz> SpockzT: and we want types to have reliable semantics, too, so we generally don't want it to be possible to cast
03:38:08 <yitz> SpockzT: there are ways to do those things, but they are intended for very special low-level programming of certain libraries that you wouldn't normally want to use for general programming.
03:38:26 <SpockzT> yitz: I am creating a library here
03:39:47 <yitz> SpockzT: i mean the kinds of libraries that define Haskell itself
03:40:00 <yitz> or something like that
03:40:07 <SpockzT> yitz: and I understand that generally we don't want to do this. But in this case I don't see the harm of it
03:40:41 <SpockzT> yitz: if I could somehoew make a specialise rule it would be great as well
03:40:48 <yitz> SpockzT: i'm not worried that you'll hurt anybody :)
03:43:58 <yitz> SpockzT: the usual techniques are: for things that need to behave differently at runtime, you encode that information in the data. for operations that need different implementations for different types, you write separate functions with the matching types.
03:44:35 <SpockzT> yitz: in my case all the types are known at compile time
03:45:05 <yitz> bsrk: http-conduit is one good choice
03:45:11 * hackagebot exception-mailer 0.3 - Catch all runtime exceptions and send an email  http://hackage.haskell.org/package/exception-mailer-0.3 (DavidPowell)
03:45:22 <haasn> Can some lenslike be made for modulo arithmetic? like 5 & mod 10 +~ 7 -- 2
03:45:40 <ggherdov> did anybody noticed this page? http://research.microsoft.com/en-us/events/icfpcontest2013/ it's gonna be aug 8th --> aug 11th
03:45:46 <haasn> oh
03:45:48 <haasn> no
03:45:53 <haasn> violates associativity probably no matter which way you formulate it
03:46:07 <haasn> well not associativity
03:46:09 <haasn> but uh, that one law
03:46:11 <haasn> composition
03:48:31 <augur> haasn: composition??
03:49:01 <haasn> augur: mod 10 %~ (f . g)  = (mod 10 %~ f) . (mod 10 %~ g)
03:49:11 <augur> aha
03:49:40 <SpockzT> yitz: zo basically the info is already there at compiletime. I just need to know how to access it
03:56:14 <yitz> SpockzT: the classic haskell way would be to write a separate function for each type. if that would create a lot of boilerplate, so there are ways to reduce it, but they also reduce the clarity and theoretical soundness of your program.
03:57:06 <SpockzT> yitz: I would write the different functions anyway, with another function in front of it that would determine which actual implementation would be called
03:58:21 <yitz> SpockzT: so why can't the compiler just pick the right implenetation from the type of the function?
03:59:00 <yitz> SpockzT: here is the kind of case i am imagining you are in:
04:00:45 <yitz> SpockzT: let's say i need to nub a list. for some types, if there is Ord instance, I can use map head . group . sort. otherwise i need to use nub, which is O(n^2).
04:01:01 <yitz> SpockzT: is that the kind of situation you have?
04:01:28 <SpockzT> yitz: yes, I don't see any differences
04:02:23 <yitz> SpockzT: so i might do something like this:
04:02:57 <yitz> SpockzT: i could say: class Nubable a where nubIt :: [a] -> [a]
04:03:55 <yitz> SpockzT: then for each type in my program that i to do this for, I would either write instance Nubable Foo where nubIt = map head . group . sort, or instance Nubable Foo where nubIt = nub
04:05:42 <SpockzT> yitz: of course, that would circumvent the overlapping instances issue
04:08:39 <jobseeker> ehh, too old to program I am
04:09:02 <SpockzT> jobseeker: hence the name? :)
04:13:45 <SpockzT> yitz: In this case however, I cannot add my own class as that would be practically the same as adding the Eq constraint => I would have to add the constraint to my embedding as well
04:13:49 <jobseeker> I'm ashamed of myself for not understanding compiler errors, can someone give me a quickstart pls: http://hpaste.org/88049
04:14:11 <jobseeker> so nice when docs have examples of code in them
04:14:57 <SpockzT> jobseeker: what are the types of readImage and savePngImage/
04:15:37 <igstan> jobseeker: so, savePngImage expects two args, the second one, which you named img has the wrong type. savePngImage expected 2nd to be DynamicImage, but it is Either String DynamicImage actually.
04:16:21 <igstan> jobseeker: makes more sense?
04:16:29 <jobseeker> not yet...
04:16:37 <jobseeker> sec me think
04:18:00 <jobseeker> igstan: how do I grok  "Either String DynamicImage" the word "string" i grok. Wtf is "either"? Some built-in type in hs? ))
04:18:22 <SpockzT> data Either a b = Left a | Right b
04:18:31 <igstan> ah, I see. yes, used quite often actually
04:19:11 <igstan> jobseeker: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Either
04:19:34 <jobseeker> thanks I'll keep doing my hw
04:47:36 <blueonyx> hi, i just apt-get installed ghc on ubuntu 10.04, cabal update && cabal install cabal-install, now i ghc-pkg list shows 2 base versions, but always selects base-3.* which conflicts in syb for json-0.7
04:47:53 <blueonyx> how to force it to use the other base version?
04:48:43 <seliopou> blueonyx: are you using cabal?
04:50:10 <blueonyx> seliopou: apt-get installed cabal-install too
04:52:16 <seliopou> specify a version constraint in your cabal file for the base package
04:54:08 <blueonyx> i have base==4.2.*
04:56:36 <blueonyx> but 'cabal install json' doesnt work
04:57:42 <blueonyx> http://hpaste.org/88052
05:00:51 <yitz> blueonyx: it's usually a good idea to stick with the cabal-install that comes with the version of ghc you have
05:01:35 <yitz> blueonyx: also, it sounds like you got a really old ghc from apt-get. what version is it?
05:01:58 <blueonyx> yitz: 6.12.1
05:02:21 <yitz> blueonyx: yeah quite old
05:03:03 <yitz> blueonyx: while the debian packager does a great job, getting ghc via apt-get is probably not what you want unless you are using debian unstable or equivalent.
05:05:02 <supki> more like debian experimental I think
05:05:11 <blueonyx> yitz: yea i know, but i got to stick to ubuntu 10.04 for now
05:05:26 <yitz> blueonyx: what i do is: find out what version of ghc is tested with the version of haskell platform i want, install the ghc binary tarball for that version (ignoring the warnings on the ghc web site that i really want haskell platform), then install haskell platform using its source tarball, following the instructions on the haskell platform site.
05:06:19 <blueonyx> yitz: yea i'll try this
05:06:21 <yitz> supki: i haven't checked lately, but i think his packages make it into unstable quite promptly
05:06:59 <yitz> blueonyx: then, avoid upgrading cabal or cabal-install
05:07:43 <yitz> blueonyx: (i.e. *I* avoid those upgrades. some people do it and seem to be happy, though. ask them.)
05:09:31 <supki> yitz: not in the case of ghc =(
05:09:54 <yitz> supki: ah i see.
05:11:20 <yitz> supki: nope. ghc 7.4.1 is even in stable now.
05:12:36 <yitz> supki: experimental has 7.6.2 and 7.6.3
05:13:15 <yitz> supki: i assume joachim will get the appropriate 7.6.* into unstable in time for the upcoming haskell platform release, or very soon after.
05:13:52 <watermind> when using kind promotion, what is the syntax to refer to the type con, rather than the val con, for instance when doing queries in ghci?
05:14:25 <monoidal> watermind: precede identifier with '
05:14:35 <watermind> monoidal: thank you!
05:15:36 <watermind> by the way, as there been decided upon some way to avoid the overloading for defining new kinds? e.g.  "data kind"  and "data type"  or something of the sort?
05:16:19 <monoidal> watermind: they are planned in 7.8, not sure what is already decided
05:16:27 <watermind> monoidal: alright, thanks again!
05:20:41 <hiptobecubic> @faq Can Haskell get funky? CAN HASKELL GET DOWN!?
05:20:41 <kappabot> The answer is: Yes! Haskell can do that.
05:20:47 <hiptobecubic> PRAISE THE LORD!
05:21:05 * hiptobecubic throws his hands in the air
05:24:04 <supki> yitz: waiting for the platform is really strange reason to not release latest ghc in "unstable"
05:26:15 <canta> Is there a simple way to check how ghc automagically derived Ord? I mean to see how the auto-derived code looks, to make sure that there is nothing going wrong.
05:26:50 <supki> canta: -ddump-deriv
05:27:51 <DMcGill> canta: also, quickcheck would help here
05:27:51 <kappabot> DMcGill: You have 1 new message. '/msg kappabot @messages' to read it.
05:28:21 <blueonyx> @where LYAH
05:28:21 <kappabot> http://www.learnyouahaskell.com/
05:28:48 <blueonyx> the king is dead, long live the king!
05:31:17 <canta> supki, DMcGill: thanks
05:32:31 <DMcGill> channel topic: "lambdabot is sick =("
05:32:41 <DMcGill> @ head topic
05:32:45 <DMcGill> : head topic
05:32:53 <DMcGill> > head topic
05:32:54 <kappabot>   Not in scope: `topic'
05:41:50 <fruitFly_> mm_freak: Yo!
05:49:59 <fruitFly_> how to concatenate "yo" and "dawg"?
05:50:21 <TanebNgevdatriq> fruitFly_: they're monoids
05:50:23 <fruitFly_> got it
05:50:23 <fruitFly_> ++
05:50:24 <TanebNgevdatriq> Monoids are easy
05:50:34 <TanebNgevdatriq> I love them
05:50:46 <fruitFly_> TanebNgevdatriq: havn't got there yet.. thanks
05:51:05 <TanebNgevdatriq> fruitFly_: good luck!
05:51:06 <blueonyx> @src concat
05:51:06 <kappabot> concat = foldr (++) []
05:51:26 <fruitFly_> TanebNgevdatriq: what the helld o they do?
05:51:46 <TanebNgevdatriq> fruitFly_: they're basically "things you can concatenate", except slightly more complicated
05:52:41 <TanebNgevdatriq> They're things with a function (called "mappend" in Haskell) combining two of them, and a blessed value of the type (called "mempty" in Haskell) such that mappend mempty a == mappend a mempty = a
05:52:50 <mauke> @src Monoid
05:52:50 <kappabot> class Monoid a where
05:52:50 <kappabot>     mempty  :: a
05:52:51 <kappabot>     mappend :: a -> a -> a
05:52:51 <kappabot>     mconcat :: [a] -> a
05:52:56 <TanebNgevdatriq> Plus a couple of rules on what mappend can be
05:53:22 <mauke> instance Monoid [a] where { mempty = []; mappend a b = a ++ b }
05:55:09 <typoclass> fruitFly_: if you only need to concatenate some Strings, try (++) or concat
05:55:16 <typoclass> > "abc" ++ "def" ++ "ghi"
05:55:17 <kappabot>   "abcdefghi"
05:55:23 <typoclass> > concat ["abc", "def"]
05:55:24 <kappabot>   "abcdef"
05:55:49 <donri> > unwords ["yo","dawg"]
05:55:50 <kappabot>   "yo dawg"
06:16:35 <ozgura> Hello! A should-be-simple question, I want to write a NominalDiffTime to a file, and parse it later. NominalDiffTime has a non-standard Show instance but no Read instance. Failing this, how can I go via something like Double?
06:17:26 <typoclass> ozgura: hello. maybe one of the general-purpose converter functions? fromIntegral, realToFrac, etc.
06:17:30 <mauke> :t toRational
06:17:31 <kappabot> forall a. Real a => a -> Rational
06:17:42 <mauke> that would work
06:18:50 <ozgura> mauke: it does, but then it gives be things like (5029327 % 1000000) for 5.029.. seconds.
06:18:58 <ozgura> the file looks funny.
06:19:01 <mauke> ozgura: and?
06:19:11 <ozgura> maybe I should go to Double
06:19:13 <typoclass> ozgura: in general, this page is useful when you work with the time library http://pleac.sourceforge.net/pleac_haskell/datesandtimes.html
06:20:07 <ozgura> typoclass: thanks for this! I think I found it via google before. doesn't have any DiffTime though, as far as I can see.
06:21:17 <ozgura> OK, I'll just use (realToFrac . toRational) to go to a Double. Thanks.
06:21:39 <mauke> wat
06:21:43 <mauke> :t realToFrac
06:21:44 <kappabot> forall a b. (Fractional b, Real a) => a -> b
06:21:50 <mauke> ozgura: just use realToFrac
06:22:00 <blueonyx> :t toRational
06:22:01 <kappabot> forall a. Real a => a -> Rational
06:22:06 <typoclass> ozgura: you're welcome. check the "difference of two dates" section. "diffUTCTime bree nat" will give a NominalDiffTime according to its signature. later, they convert it to Float
06:22:12 <mauke> @src realToFrac
06:22:12 <kappabot> realToFrac = fromRational . toRational
06:24:33 <ozgura> mauke: good, realToFrac works both ways: NominalDiffTime -> Double and back.
06:34:07 <alang__> is this a known bug? http://hpaste.org/88058
06:34:50 <alang__> oh this is the wrong channel
06:43:59 <vermeille> > "test"
06:44:00 <kappabot>   "test"
06:44:07 <vermeille> > 42 / 0
06:44:08 <kappabot>   Infinity
06:44:38 <Peaker> > 42 / -0
06:44:39 <kappabot>   Precedence parsing error
06:44:39 <kappabot>      cannot mix `GHC.Real./' [infixl 7] and prefix...
06:44:44 <Peaker> > 42 / (-0)
06:44:44 <kappabot>   -Infinity
06:46:12 <rgrinberg> > 1 + "2.0"
06:46:13 <kappabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
06:46:13 <kappabot>    arising from the literal ...
06:46:18 <rgrinberg> no php mode :(
06:47:11 <Entroacceptor> you could probably do that with overloadedstrings
06:47:16 <simpson> rgrinberg: There is a joke Prelude that has PHP-style instances for things, but nobody actually uses it.
06:47:21 <monoidal> Entroacceptor: or with a Num String instance
06:47:30 <simpson> rgrinberg: http://hackage.haskell.org/package/acme-php
06:58:10 <rgrinberg> acme - the first perl influcence I've found in haskell
06:59:15 <mauke> :t (=~)
06:59:16 <kappabot> forall source source1 target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
07:00:46 <byorgey> rgrinberg: I don't know if it's Perl influence specifically so much as it is Road Runner influence
07:01:40 <Peaker> mauke, that's a terrible type :(
07:01:47 <mauke> byorgey: but what other language has an Acme.* module namespace?
07:01:58 <Hafydd> Hahah.
07:02:14 <Entroacceptor> oh, there's so many gems in that
07:02:15 <mauke> Peaker: that's what happens when you try to outperl Perl without thinking
07:02:40 <arnsholt> mauke: Or a module that cleans away all those unsightly printable characters (while preserving the semantics of the code =D)?
07:03:24 <mauke> arnsholt: are you talking about Acme::Bleach?
07:04:12 <mauke> http://hackage.haskell.org/packages/archive/acme-year/2013/doc/html/Acme-Year.html :3
07:04:32 <arnsholt> Yeah, that'd be Bleach =)
07:04:44 <mauke> arnsholt: is there a Haskell version of that?
07:05:11 <arnsholt> Not to my knowledge, sadly
07:05:27 <mauke> that doesn't count as a perl influence on haskell, then
07:05:34 <Peaker> mauke, perhaps a good name for this kind of abuse would be "premature lifting"
07:06:16 <arnsholt> mauke: Not sure it's possible to replicate either. IIRC it's done with source filters
07:06:19 <Entroacceptor> but http://hackage.haskell.org/packages/archive/acme-dont/1.1/doc/html/Acme-Dont.html is from PERL
07:06:25 <Peaker> e.g: You have some type like   a -> Maybe b,  and you say, what if someone wants to use it with other types and not Maybe? Let's lift it with (maybe mzero return)  to yield  "MonadPlus m => a -> m b"
07:07:24 <tdammers> Acme.PHP is influenced Perl, which, as we all know, is an ad-hoc, bug-ridden implementation of half of misunderstood Perl
07:07:28 <tdammers> eh
07:07:32 <mauke> arnsholt: worse
07:07:34 <tdammers> is influenced by *PHP*
07:07:44 * tdammers needs more caffeine
07:07:50 <mauke> Entroacceptor: Perl, not PERL
07:08:13 <Peaker> tdammers, or its poor substitute known as sleep
07:08:40 <Entroacceptor> mauke: yeah, I'm ill, couldn't lift my finger in time
07:08:50 <mauke> Entroacceptor: http://backpan.perl.org/authors/id/J/JM/JMCNAMARA/Acme-Inline-PERL-0.01.readme
07:08:54 <mauke> on the other hand ...
07:08:55 <Eduard_Munteanu> Peaker: yeah, sleep only brings *temporary* relief, and then you have to do it all the time. :P
07:14:29 <mauke> http://hackage.haskell.org/packages/archive/acme-realworld/0.1.1/doc/html/Acme-RealWorld.html
07:14:33 <mauke> this is terrible. I like it
07:25:01 <Peaker> mauke, subtext 1 had a kind of "hypothetically" in the GUI
07:25:18 <mauke> o_O
07:25:46 <Peaker> where the "universe" only consisted of the Subtext state, of course :)
07:25:55 <Peaker> it visualized something like IO actions by visualizing a RealWorld result, where RealWorld was the state of the Subtext GUI
07:55:26 * hackagebot egison 3.0.4 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-3.0.4 (SatoshiEgi)
07:56:37 <phischu> Is there a free proxy transformer?
07:57:25 <yitz> supki: sry was at a meeting
07:58:37 <yitz> supki: i don't think they're wating for the platform to get ghc 7.6 into unstable. i thinkthat's a reason for them to hurry up and get it into unstable.
07:58:39 <edwardamsden> I'm getting a strange error from ghc 7.4.2 on OS X mountain lion: http://hpaste.org/88060
07:59:18 <Kinnison> yitz: debian won't be pushing 7.6 into unstable until the new libffi transitions to jessie IIRC
07:59:26 <edwardamsden> Basically, the folder the source file is in is all-caps in the FS, and the first element of the module name is all caps, but GHC thinks that the folder is capitalized with small letters after, and so it complains about a module name mismatch
07:59:31 <edwardamsden> but I'm not sure why it thinks that.
08:00:10 <yitz> edwardamsden: you need to name it Foo.hs
08:00:41 <edwardamsden> erm no
08:00:45 <edwardamsden> the module is FOO.Bar
08:00:48 <yitz> edwardamsden: even "case insensitive" filesystems on os x are not as "case insensitive" as they are on windows.
08:01:01 <edwardamsden> it's in FOO/Bar.hs
08:01:11 <edwardamsden> But ghc thinks its in Foo/Bar.hs
08:01:23 <edwardamsden> So basically, don't use an all-caps module name?
08:01:37 <yitz> edwardamsden: so somewhere in the code it is referred to as Foo.Bar
08:01:49 <edwardamsden> ok well let me see if I can find that...
08:02:01 <yitz> edwardamsden: either "module Foo.Bar where" or import Foo.Bar or something
08:02:08 <quchen> If there's "module Foobar where" in your file, you should call it Foobar.hs.
08:02:22 <quchen> If your module contains "module FOOBAR where", then you should be able to name the file FOOBAR.hs.
08:02:49 <quchen> I don't recommend going all caps for abbreviations longer than two letters though.
08:03:04 <quchen> XMLHTTPRequest <-> XmlHttpRequest
08:04:26 <simukis_> quchen: the name for XMLHTTPRequest is still awkward – regardless of casing.
08:04:29 <Hafydd> XtensibleMarkupLanguageHyperTextTransferProtocolRequest
08:05:02 <Hafydd> XTENSIBLEMARKUPLANGUAGEHYPERTEXTTRANSFERPROTOCOLRequest
08:05:02 <yitz> Kinnison: ouch. that is going to hold back the new platform release? that would really be a shame.
08:05:11 <tdammers> that's nothing
08:05:16 <quchen> You can't beat the Metal Oxide Semiconductor Field Effect Transfer Resistor. Also, let's not make this an argument about how useful abbreviations are.
08:05:28 <tdammers> ASYNCHRONOUSJAVASCRIPTANDXTENSIBLEMARKUPLANGUAGEHYPERTEXTTRANSFERPROTOCOLRequest
08:05:42 <Kinnison> yitz: It's understandable, haskell is a large transition and it could hold up ffi if it went wrong.  ffi is important to get upgraded
08:08:06 <Hafydd> Xhr
08:10:00 <edwardamsden> yitz: It seems the issue was indeed an errant import. That's annoying. Thank you!
08:11:26 <yitz> @tell edwardamsden you're welcome
08:11:26 <kappabot> Consider it noted.
08:13:41 <simukis_> Systemd bindings for haskell?
08:14:26 <simukis_> ah, there it is.
08:18:55 <james-sh> is there any mailing list for job offers specifically for Haskell people?
08:18:55 <james-sh> i mean, haskell developers
08:19:36 <`^_^v> ha
08:20:23 <quchen> james-sh: cat /dev/null
08:20:24 <quchen> ;-)
08:20:47 <james-sh> :)
08:21:06 <quchen> Maybe check out http://functionaljobs.com/ or http://www.haskellers.com/
08:21:42 <james-sh> thought may be haskellers has a better chance of employment give their narrow interest
08:23:12 <james-sh> functionaljobs is cool
08:24:53 <Peaker> "deriving (Show)" becomes ambiguous with GeneralizedNewtypeDeriving..
08:25:34 <elliott> well, only one meaning is really reasonable.
08:26:11 <merijn> james-sh: I've had 2 companies contact me after finding me on haskellers.com, for whatever that's worth
08:26:51 <stepkut> I can use Network.accept which returns a Handle or Network.Socket.accept which returns a Socket. Is there some reason to favor the Handle variant if I don't really need a Handle?
08:27:08 <stepkut> I can use either version, so it seems like using the Socket directly is going to be less overhead
08:30:20 <akamaus> hi, what's the status of cabal support for different compilers?
08:31:08 <Taneb> I think it's "pretty good, but why are you using different compilers"
08:31:24 <akamaus> I'm going to release an frp library both for hastec and fay
08:34:44 <akamaus> Taneb,  most modules would be common for all the platforms, but not all. For example, type class related stuff isn't supported by fay.
08:35:06 <Taneb> I don't know about that, but I believe it is doable
08:40:27 * hackagebot git-annex 4.20130516 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-4.20130516 (JoeyHess)
08:43:35 <Sculptor_> yo
08:48:44 <Floris> do you guys think it is possible to run haskell on my calculator?
08:49:53 <Adeon> depends on the calculator
08:50:16 <Floris> it is an Nspire cx
08:50:28 <Floris> there is an arm9 inside
08:52:06 <Adeon> if I recall correctly, there is a haskell compiler that outputs portable C code that might be suitable for embedded platforms
08:52:12 <Adeon> but I don't remember the details
08:52:17 <Adeon> might want to look up on that
08:52:45 <Floris> ah, so it makes c code from haskell?
08:52:46 <geekosaur> jhc?
08:53:36 <akamaus> Adeon, maybe it's jhc?
08:53:39 <Adeon> yeah, I think it was jhc
08:54:00 <Adeon> I heard rumors that configuring platform specific stuff is rather simple with it
08:54:15 <Adeon> but I recommend not blindly believing in wild rumors
08:55:31 <Floris> i'm going to look into it! but not sure what libraries work on it
09:02:11 <piezoid> @hoogle Parser a -> Parser (Maybe a)
09:02:11 <kappabot> A Hoogle error occurred.
09:02:52 <piezoid> any shortcut for : \p -> Just <$> p <|> pure Nothing ?
09:03:59 <fizbin> @type \p -> Just <$> p <|> pure Nothing
09:04:00 <kappabot> forall (f :: * -> *) a. Alternative f => f a -> f (Maybe a)
09:05:52 <piezoid> it's an optional field in applicative parser style
09:07:15 <piezoid> @type optional
09:07:16 <kappabot> forall (f :: * -> *) a. Alternative f => f a -> f (Maybe a)
09:07:17 <monoidal> piezoid: optional
09:07:24 <piezoid> ok :)
09:07:34 <fizbin> @src optional
09:07:35 <kappabot> optional v = Just <$> v <|> pure Nothing
09:21:21 <acube> < 1 + 1
09:21:53 <mauke>  3
09:21:58 <acube> xD
09:22:34 <shachaf> I seem to be running into this: https://github.com/haskell/cabal/issues/1004
09:23:13 <shachaf> Is there a reasonable solution other than HEAD cabal-install or downgrading?
09:26:49 <shachaf> Ugh, downgrading cabal doesn't work either...
09:27:40 <elliott> shachaf: install the package manually?
09:27:48 <shachaf> elliott: It's lens.
09:28:00 <shachaf> Or, rather, it's a lot of lens's dependencies.
09:28:01 <acube> Why is Data.Functor.Product [from transformers] not an instance of monoid? :/
09:28:03 <shachaf> Not one package.
09:28:49 <shachaf> Is Cabal one of the libraries you're allowed to upgrade?
09:29:05 <elliott> I think dcoutts once told me to upgrade Cabal.
09:29:08 <elliott> so maybe only if you get permission.
09:30:46 <shachaf> Hmm, I can't reüpgrade cabal because the old version is so broken.
09:30:51 <shachaf> bootstrap.sh time!
09:31:25 <shachaf> Whoops, that's broken too.
09:31:46 <dolio> Buy a new computer.
09:32:37 <dolio> It's the only way to be sure.
09:37:21 <int-e> dolio: http://www.theonion.com/articles/after-checking-your-bank-account-remember-to-log-o,32260/
09:39:08 <haasn> “Three, rip all the wiring from the establishment’s walls and ceilings. Four, douse the premises in gasoline or acetone and set it on fire.”
09:39:15 <dolio> int-e: Exactly.
09:55:13 <acube> Is there a type like Data.Functor.Compose [from transformers], but with the Alternative instance the other way around, i.e instance (Applicative f, Alternative g) => Alternative (Compose2 f g) ?
09:55:30 * hackagebot reflection 1.3.2 - Reifies arbitrary terms into types that can be reflected back into terms  http://hackage.haskell.org/package/reflection-1.3.2 (EdwardKmett)
09:59:07 <edwardk> acube: nope
10:13:49 <Hidenori> i am studying how to define my own "value constructor", and remembered that my GHCi sometimes says "Not in scope : data constructor ...". i am wondering if "value constructors" and "data constructors" are the same.
10:14:15 <mm_freak> Hidenori: they are
10:15:03 <Hidenori> mm_freak: i see thank you
10:24:12 <acube> @hoogle (Traversable t) => Int -> t a -> t a
10:24:12 <kappabot> A Hoogle error occurred.
10:26:44 <saml> is there timezone library that supports mars time? i'm developing mars rover and time calculation is off
10:27:20 <geekosaur> doubt it, since timezone support still assumes an Earth day
10:28:08 <acube> Is there a generic drop/take for Traversable somewhere?
10:28:10 <saml> problem is the black hole in between. that shifts time at random
10:28:40 <geekosaur> (more to the point, timezone support cannot relax the behavior of time functions that assume Earth time for seconds/minutes/hours/days relationships)
10:30:51 <acube> > itakingWhile (const . (<3)) traversed [1,2,3]
10:30:56 <kappabot>   Couldn't match expected type `p0 a0' with actual type `[]'
10:31:13 <acube> > [1,2,3] ^.. itakingWhile (const . (<3)) traversed
10:31:16 <kappabot>   [1,2,3]
10:31:21 <acube> > [1,2,3] ^.. itakingWhile (const . (<1)) traversed
10:31:23 <kappabot>   [1]
10:31:53 <acube> @ty \x -> x ^.. itakingWhile (const . (<1)) traversed
10:31:55 <kappabot> forall a (f :: * -> *). Traversable f => f a -> [a]
10:32:47 <supki> :t toListOf (takingWhile (<1) folded)
10:32:49 <kappabot> forall a (f :: * -> *). (Num a, Ord a, Data.Foldable.Foldable f) => f a -> [a]
10:34:40 <supki> :t toListOf (itakingWhile (const . (<1)) ifolded)
10:34:42 <kappabot> forall a i (f :: * -> *). (Num i, Ord i, FoldableWithIndex i f) => f a -> [a]
10:35:20 <acube> @ty fromList
10:35:21 <kappabot> forall (m :: * -> *) a. MonadRandom m => [(a, Rational)] -> m a
10:35:26 <acube> What?
10:35:36 <acube> @ty Data.Traversable.fromList
10:35:37 <kappabot>     Not in scope: `Data.Traversable.fromList'
10:35:37 <kappabot>     Perhaps you meant one of these:
10:35:37 <kappabot>       `Data.Traversable.forM' (imported from Data.Traversable),
10:36:06 <shachaf> That's, uh, Control.Monad.Random.fromList
10:36:18 <shachaf> Traversable doesn't give you fromList -- that doesn't really make sense.
10:36:26 <shachaf> Foldable gives you toList, though.
10:38:29 <acube> There is no way I can change the length of a structure with traverse, is there?
10:38:38 <shachaf> Correct.
10:49:52 <Floris> how do i add data.statevar?
10:50:11 <Floris> Could not find module `Data.StateVar'
10:50:42 <shachaf> @google Data.StateVar
10:50:44 <kappabot> http://hackage.haskell.org/packages/archive/StateVar/1.0.0.0/doc/html/Data-StateVar.html
10:50:44 <kappabot> Title: Data.StateVar
10:50:51 <shachaf> It looks like it's part of the package StateVar.
10:52:02 <Floris> hm. can you tell me how i add it?
10:52:19 <Floris> i'm kind of noob on haskell
10:53:44 <Taneb> "cabal install StateVar --enable-documentation --haddock-hyperlink-source"
10:54:50 <Floris> huh? what is this.. :(
10:54:51 <Floris> Ambiguous occurrence `flush'
10:54:52 <Floris>     It could refer to either `Graphics.UI.GLUT.flush',
10:54:54 <Floris>                              imported from `Graphics.UI.GLUT' at Rendering.hs:17:1-23
10:54:55 <Floris>                              (and originally defined in `OpenGL-2.2.3.1:Graphics.Rendering.OpenGL.GL.FlushFinish')
10:54:57 <Floris>                           or `Graphics.Rendering.OpenGL.flush',
10:54:58 <Floris>                              imported from `Graphics.Rendering.OpenGL' at Rendering.hs:18:1-32
10:54:58 <Floris>                              (and originally defined in `Graphics.Rendering.OpenGL.GL.FlushFinish')
10:55:32 <shachaf> Floris: Please use hpaste.org to paste things more than a couple of lines long.
10:55:48 <Floris> oh sorry for that
10:56:02 <monochrom> also, what were you doing when you got that? need more context.
10:56:18 <Floris> trying to compile: https://github.com/rtperson/Haskell-Pong
10:56:56 <monochrom> it may be just old code
10:57:16 <sdodson_> Hi, I am new to Haskell and I am trying to write a simple function that adds all the odd numbers in a list. Can anyone help me?
10:57:29 <Floris> hm, does someone know a simple game that i can compile myself?
10:57:31 <monochrom> libraries have changed in the past 2 years
10:58:09 <tromp> :t odd
10:58:12 <kappabot> forall a. Integral a => a -> Bool
10:58:15 <Floris> ah oke
10:58:42 <otters> filter odd
10:59:48 <Hafydd> sum . filter odd
10:59:56 <monochrom> a recent video says cuboid compiles recently. http://www.youtube.com/watch?v=-IpE0CyHK7Q  the code is at http://hackage.haskell.org/package/cuboid
11:00:21 <sdodson_> Hafydd -- what's the '.' do in 'sum . filter odd'?
11:00:33 <tromp> :t (.)
11:00:34 <kappabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
11:00:35 <Hafydd> sdodson_: function composition
11:00:38 <monochrom> in fact the video author says "it's one of the very few games that compiles today" :)
11:00:45 <sdodson_> Ah, thank you.
11:04:15 <saml> is there atomically function for fileystem io? something like TVar
11:04:45 <Floris> monochrom: ah thanks i will look at that
11:05:00 <monochrom> no. unfortunately, transactional file systems have not entered the minds of OS leaders
11:05:42 <monochrom> this really sucks because all of your cabal problems could have been relieved by transactional file systems.
11:06:52 <dmwit> saml: Most filesystems have only a very few atomic operations, sadly.
11:07:18 <dmwit> monochrom: What, all? really?
11:07:32 <dmwit> It sure seems like most of the problems I run into with cabal aren't the filesystem's fault.
11:08:06 <monochrom> you can roll back to a previous state
11:08:39 <saml> dmwit, is there semiAtomically file io?
11:08:56 <dmwit> monochrom: Seems like versioning and transactions are pretty orthogonal.
11:09:02 <dolio> btrfs can do that kind of thing, but you'd have to know in advance that you're going to do something you'd want to roll back from, and make a snapshot.
11:09:06 <dolio> Probably zfs, too.
11:09:10 <dmwit> Once I commit a transaction, being able to roll back that transaction is a separate superpower.
11:09:52 <dmwit> saml: Depending on your operating system and how much cooperation you expect from other processes, there is sometimes locking.
11:10:09 <plhk> https://twitter.com/HenningBrauer/status/335070068188786688/photo/1
11:10:20 <plhk> (zfs)
11:10:59 <dmwit> saml: http://linux.die.net/man/2/flock
11:10:59 <monochrom> ok, each of {transactional, versioning} relieves all cabal problems. I don't care that two reliefs are orthogonal. I only care that one of them is a relief and I am naming it.
11:11:51 <dmwit> No, you misunderstood me.
11:12:38 <monochrom> don't commit a cabal transaction. then it can be rolled back.
11:12:44 <dmwit> I'm saying that the ability to collect multiple operations into a single transaction that can be rolled back any time before it's committed (i.e. transactional file systems) and the ability to roll back transactions which have already committed (i.e. versioning) are separate superpowers, and only *one* of them (namely versioning) solves all of cabal's problems.
11:12:57 <dmwit> If you don't commit a cabal transaction, you also can't *use* the transaction.
11:14:24 <tgeeky> oh man kappa doesn't have djinn
11:14:41 <joe9_> is there a better way of writing this: http://codepad.org/jkSipecb without return for each putStrLn and the trailing  >> return ((),s)) . I do not want to use "do" as I want to follow the RWH advice to use combinators to get a better feel for monads.
11:15:39 <dmwit> lift (putStrLn $ show "test")
11:16:35 <monochrom> ok, next time I'll stick to versioning
11:16:55 <dmwit> ...though that's assuming you actually wanted to execute the putStrLn. Which your code doesn't, I think.
11:17:35 <monochrom> is there versioning function for filesystem I/O? something like Data.Map :)
11:17:46 <dmwit> =)
11:17:58 <joe9_> dmwit, yes, I want to execute the putStrLn. thanks.
11:18:23 <dmwit> You may also like liftIO when you want to lift IO through more complicated transformer stacks.
11:20:22 <joe9_> dmwit: http://codepad.org/kBxqksrZ I am getting this error with just lift
11:20:26 <joe9_> let me check out liftIO
11:20:34 * hackagebot language-slice 0.2.1.0 - AST and parser for the ZeroC Slice language (Specification language for ICE)  http://hackage.haskell.org/package/language-slice-0.2.1.0 (PaulKoerbitz)
11:20:37 * hackagebot slice-cpp-gen 0.2.2.0 - Generate C++ skeletons from slice files  http://hackage.haskell.org/package/slice-cpp-gen-0.2.2.0 (PaulKoerbitz)
11:20:54 <joe9_> dmwit: liftIO helped
11:21:15 <boothead> hi folks, can anyone tell me an elegant way to go from a json object {'name': <an object of type name>} to a decoded object of that type?
11:21:19 <dmwit> joe9_: no
11:21:26 <dmwit> joe9_: not StateT $ anything
11:21:43 <dmwit> joe9_: just 'lift $ putStrLn (show "test") :: StateT RunState IO ()"
11:22:06 <boothead> I should clarify that the key of the json object defines which type it is..
11:22:20 <dmwit> joe9_: Like, that's literally all the code.
11:22:54 <dmwit> boothead: Define a Haskell type that covers all the types you expect and use aeson?
11:23:36 <joe9_> dmwit: ok, cool. thanks.
11:24:18 <dmwit> data IncomingJSONLOL = FunThing FunThing | BoringThing BoringThing; instance FromJSON IncomingJSONLOL where parse (Object o) = (FunThing <$> o .: "funthing") <|> (BoringThing <$> o .: "boringthing")
11:24:34 <boothead> I'm using Aeson and the Generic version of decode, but I think I want the data types separate... it seems strange to conflate a Company type with a Contact type for example
11:25:01 <dmwit> I don't see how you can expect anything else to happen if you don't know statically which one you're going to get.
11:25:12 <tero-> anyone knows how to compose Database.Esqueleto queries?
11:25:22 <boothead> each type has many fields and I thought it might be a bit unwieldy to combine ~20 types like that.
11:25:31 <dmwit> Oh, what? Don't combine them.
11:25:35 <dmwit> Define them separately, of course.
11:25:44 <dmwit> Then have one top-level type with one constructor for each type.
11:25:59 <boothead> dmwit: ah i see you have like a container type that unifies them?
11:26:02 <dmwit> yes
11:26:13 <acube> @src optional
11:26:13 <kappabot> optional v = Just <$> v <|> pure Nothing
11:26:15 <dmwit> But are you really sure you don't know what type you're going to be trying to read? I find that very strange.
11:26:32 <joe9_> dmwit: if I use lift/liftIO without the lambda expression. Do I have to explicitly use get to read the state?
11:26:36 <dmwit> What kind of protocol can return a company or a person from the same call?
11:27:02 <dmwit> joe9_: yes
11:27:13 <Eduard_Munteanu> Well, you don't have to, but it's nice.
11:27:14 <joe9_> dmwit: thanks.
11:27:27 <boothead> apiCall :: (Data b, MonadIO m) => ByteString -> ByteString -> FAMonad m b
11:27:40 <boothead> it doesn't but at the moment I have the previos function
11:27:48 <dmwit> Don't Do That
11:27:58 <boothead> apiCall url token -> data
11:28:06 <boothead> do what?
11:28:48 <dmwit> Don't try to write a single function that can do all API calls and therefore has the wrong type for all of them.
11:30:09 <boothead> well I thought I could specialise that call based on the url (due to all of my types being Data.Data instances)
11:30:48 <boothead> somehting like apiCall "company" :: ByteString -> FAMonad m Company
11:31:14 <dmwit> Yes, you can do that. But then surely the JSON you're getting is a Company, not a {"company" : Company}.
11:31:30 <dmwit> a.k.a. I'm very confused about the collection of requirements you've posed so far
11:33:16 <boothead> maybe a key function APIType a => a -> ByteString?
11:33:54 <boothead> i maybe trying to be too pythoninc here as in python I'd just use introspection or just use the dict directly
11:34:03 <boothead> haskell hurts my brain :-)
11:34:07 <dmwit> I'm very confused.
11:34:18 <dmwit> Do you or do you not expect one of your API calls to have a type which is not statically known?
11:35:12 <boothead> No I should know all of the types, but I don't want to have to write ~20 different functions that basically do the same thing.
11:35:32 <boothead> I'm trying to build a template of url, json key and data type I guess...
11:35:52 <boothead> does that make more sense?
11:36:12 <dmwit> Okay. If the type is statically known, why did we lead off with "I'm going to receive some JSON that starts with the type name and I don't know what name that will be"?
11:37:03 <boothead> sorry, miscommunication - to little thinking up front!
11:37:52 <boothead> to clarify i will get {'key' : <some json representing a type identified by key> }
11:38:00 <dmwit> Okay. Then your FromJSON instance should already know enough to parse everything properly.
11:38:13 <dmwit> i.e. your FromJSON instance for Company already knows what key to expect.
11:38:23 <dmwit> So... just write the parser to expect that key?
11:38:48 <boothead> but I don't have a FromJson instance AFACT because there's a Generic version of decode that just results in a Data
11:39:41 <mm_freak> i think i'm slowly approaching understanding of the yoneda lemma…  what i don't understand yet is why categorical people praise it so much
11:39:43 <dmwit> The Generics and Typeable stuff is just there to make writing a FromJSON instance easier if the JSON happens to be in a particular format.
11:39:59 <boothead> (which is another question) Why does Aeson not define instance (Data a) => FromJSON a ?
11:40:01 <dmwit> If it doesn't parse the right format, you have to write a parser yourself that does.
11:40:21 <dmwit> The problem with that is that it is a really big instance. Bigger than it looks naively.
11:40:35 <dmwit> Haskell compilers don't consider the context when choosing an instance, so to begin with it looks like
11:40:39 <boothead> you mean Data a?
11:40:48 <dmwit> "instance FromJSON a", and then later you check whether there's also an instance "Data a".
11:41:06 <dmwit> So "instance FromJSON a" matches _every_ type, no matter what, and you can't write _any_ other instances without overlapping.
11:41:16 <Iceland_jack> mm_freak: http://mathoverflow.net/questions/3184/philosophical-meaning-of-the-yoneda-lemma this might help?
11:41:20 <boothead> ahhhh i see
11:41:40 <dmwit> (Additionally, as you've observed, the instance you get from the Data constraint isn't always the one you want!)
11:42:23 <boothead> dmwit: thanks for your help. I need to go and get the kids out of the bath. My wife won't let me write any more haskell if one of them drowns :-)
11:42:32 <dmwit> =)
11:42:33 <dmwit> g'luck
11:43:49 <mm_freak> Iceland_jack: i think this one is better:  http://blog.sigfpe.com/2006/11/yoneda-lemma.html
11:44:07 <mm_freak> after having read the introduction at https://www.fpcomplete.com/user/bartosz/understanding-yoneda, which i quite liked
11:44:51 <shachaf> The Yoneda type in Haskell is a much simpler thing than the Yoneda lemma in general.
11:45:02 <shachaf> CoYoneda is, I think, even simpler.
11:50:51 <enigmuriatic> if i want to test that both x and y are >= 0, is there a way to do that all in one expression?
11:51:14 <shachaf> x >= 0 && y >= 0 is one expression
11:51:22 <shachaf> So is all (>= 0) [x,y]
11:51:50 <enigmuriatic> thanks shachaf
11:54:45 <tromp> (x .|. y) >= 0 sort of works too :(
11:56:28 <monoidal> tromp: min x y >= 0 might be better
11:57:11 <tromp> i was looking to reduce branches
11:57:22 <Reiser> I like the min example, that's quite nice
12:01:15 <dmwit> (-x) .&. (-y) < 0
12:01:28 <dmwit> err
12:02:19 <dmwit> yeah
12:02:56 <dmwit> tromp's is better =P
12:03:51 <dmwit> > (-1) .|. 72 :: Integer
12:03:52 <kappabot>   -1
12:05:41 <ReinH> having trouble installing ncurses on OS X, can't find ncursesw and panelw libraries. Anyone seen this?
12:07:41 <geekosaur> yes. those are obsolete libraries. linux often has hacks to make them redirect to the standard ones, OS X typically doesn't bother with them
12:08:22 <ReinH> so ncurses depends on obsolete libraries. Alternatives? Is hscurses better?
12:09:01 <ReinH> looks like it's way more recent, at least
12:09:03 <ReinH> thanks
12:09:16 <elliott> there's also vty
12:09:19 <elliott> with no native library dependencies
12:09:51 <ReinH> how do they compare?
12:10:09 <enigmuriatic> http://pastebin.com/e8P69pRv  why doesn't this work?
12:10:18 <mauke> The paste e8P69pRv has been copied to http://hpaste.org/88063
12:11:01 <dmwit> emacs psychologist mode activated!
12:11:08 <dmwit> "Tell me more about DOESN'T WORK."
12:11:59 <dmwit> Ah well, anyway, it's because (>= 0) isn't a function that you can apply to lists.
12:12:06 <dmwit> Perhaps you'd like all or any.
12:12:07 <dmwit> :t all
12:12:09 <kappabot> forall a. (a -> Bool) -> [a] -> Bool
12:12:36 <mingsping> hi there, im wondering if there is a haskell compiler (ghc hopefully), which doesnt require an installation? is a portable version
12:12:41 <dmwit> But in the future it's polite to describe your problem more precisely.
12:13:08 <enigmuriatic> schachaf, you lied to me
12:13:22 <monochrom> <shachaf> So is all (>= 0) [x,y]
12:13:23 <monoidal> enigmuriatic: shachaf said "So is all (>= 0) [x,y]"
12:13:24 <geekosaur> ghc requires "installation" but you can install a private copy of the binary tarball
12:13:36 <enigmuriatic> i way kidding
12:13:37 <monochrom> shachaf included "all". where is the lie?
12:13:43 <monochrom> ok! har har har
12:13:44 <enigmuriatic> *was
12:14:01 <enigmuriatic> oh, i didn't see the "all"
12:14:06 <enigmuriatic> thought it was a typo
12:14:20 <mingsping> geekosaur, i mean, can i put it on a usb-stick and copy&paste the files to a OS (winxp for instance.. there are some admintools, which dont allow any installation)
12:14:37 <geekosaur> hm, I odn't know about windows installs
12:15:42 * hackagebot hsfacter 0.2.1 - A small and ugly library that emulates the output of the puppet facter program.  http://hackage.haskell.org/package/hsfacter-0.2.1 (SimonMarechal)
12:15:43 * hackagebot puppetresources 0.4.2 - A program that displays the puppet resources associated to a node given .pp files.  http://hackage.haskell.org/package/puppetresources-0.4.2 (SimonMarechal)
12:16:35 <enigmuriatic> http://hpaste.org/88064
12:16:56 <enigmuriatic> that's the error message i get (the last fix didn't change it)
12:17:10 <dmwit> Add parentheses.
12:17:28 <dmwit> Currently you are passing "sum" three arguments, the first of which is "map", then "boolInt", then "[...]".
12:17:37 <dmwit> You may also like
12:17:38 <dmwit> ?src ($)
12:17:39 <kappabot> f $ x = f x
12:17:42 <monochrom> sum (map booIlnt [the list])
12:17:52 <enigmuriatic> ah thanks monochrom
12:22:27 <mingsping> got to go. cu
12:25:00 <enigmuriatic> got it to work, thanks everyone
12:26:23 <acube> is there a difference between ?src and @src?
12:26:39 <joe9_> let ps = putStrLn . show -- I want to use this function where the input is an Int or Word32, etc. Is that possible?
12:26:55 <Clint> @src print
12:26:56 <kappabot> print x = putStrLn (show x)
12:28:01 <elliott> acube: no
12:28:08 <joe9_> Clint: thanks.
12:28:16 <elliott> joe9_: sounds like you are running into the monomorphism restriction
12:28:19 <elliott> but yes, you can just use "print"
12:29:03 <monoidal> joe9: you can add a type signature ps :: Show a => a -> IO (), and it should work
12:29:09 <monoidal> joe9_: ^
12:40:29 <enigmuriatic> if i just want to make a simple animated grid of black squares, what graphics library should i use?
12:41:33 <elliott> gloss?
12:42:48 <enigmuriatic> I just came across a good recommendation for GLUT too
12:43:04 <mr-> (definitely gloss)
12:44:40 <elliott> opengl is a bit of a fuss
12:44:47 <elliott> (whether used with glut or not)
12:46:26 <tero-> today's problem with Database.Esqueleto http://stackoverflow.com/questions/16595892/composing-database-esqueleto-queries-conditional-joins-and-counting
12:46:53 <tero-> I guess I'll resort to concatenating raw SQL strings
12:53:09 <sacundim> huh.  i need to study that library
12:53:28 <tero-> it's very cool but the error messages are blowing my socks off
12:53:44 <tero-> some dark magic inside
12:55:32 <ReinH> elliott: vty is super snazzy, especially vty-ui
12:55:54 <elliott> yeah, I haven't used vty-ui myself but it looks pretty nice
12:56:05 <ReinH> It has a user manual. I love documentation.
12:58:40 <heath> http://dpaste.com/1169255/ :: tips on getting this to work?
12:58:58 <merijn> ReinH, elliott: It's ok
12:59:10 <merijn> ReinH: There some seriously nasty corners in it, though
12:59:43 <merijn> It's really hard/impossible to do overlays or forward information between interfaces in a clean way
13:00:18 <merijn> The lack of scrollable text widget is a bit annoying too :\
13:01:12 <heath> System.Time.calendarTimeToString :: CalendarTime -> String
13:02:07 <ReinH> merijn: hmmm
13:02:20 <ReinH> merijn: "forward information between interfaces"?
13:03:01 <heath> fmap show getClockTime
13:03:02 <heath> there we go
13:03:28 <roconnor> I have a horrible timezone issue:  Is there a good way, in Haskell, to parse a date with respect to the PST8PDT timezone (despite the fact that it is ambiguous)?  I'm am willing to accept an IO function to do this.
13:04:51 <roconnor> also, you do not have to tell me about how wrong this whole idea is.
13:05:04 <enigmuriatic> if i installed cabal do i automatically get gloss?
13:05:07 <aristid> roconnor: why is it wrong?
13:05:12 <heath> !seen shapr
13:05:43 <aristid> roconnor: maybe this? http://hackage.haskell.org/package/timezone-series
13:05:52 <roconnor> aristid: because when DST start is subject to the whims of politicians, which makes it really annoying
13:05:58 <monochrom> no, you have to manually "cabal install gloss"
13:06:03 <ReinH> heath: I assume you're aware that System.Time is deprecated in favor of Data.Time?
13:06:13 <heath> ReinH: i am now
13:06:17 <aristid> roconnor: well that's how it is, doesn't make it less necessary to parse dates
13:06:23 <chrisbuchholz> Hey guys
13:06:30 <ReinH> heath: FYI System.Time is deprecated in favor of Data.Time :)
13:06:44 <heath> ReinH: i already know this :)
13:07:16 <ReinH> heath: ;)
13:08:00 <ReinH> merijn: so you can't do overlays because vty expects exactly one container to be visible, right?
13:08:01 <heath> thanks ReinH
13:09:49 <roconnor> are there any bindings to something like strftime?
13:10:02 <dschoepe> Is there a library that provides a data types for x86 assembly instructions, and, ideally some way to print it in a way understood by as/nasm/etc.?
13:10:25 <dschoepe> I've seen harpy, but it's slightly too high-level for my scenario, I think
13:10:38 <merijn> ReinH: I've been looking into developing my own library using vty that has a more convenient API
13:10:53 <ReinH> merijn: I would like to subscribe to your newsletter.
13:11:09 <elliott> roconnor: I think the time library has something like strftime?
13:11:10 <merijn> ReinH: Unfortunately vty doesn't seem to expose key press/depress events, so I might have to patch that or fork vty
13:11:33 <ReinH> merijn: and it seems to have issues recognizing modifiers in OS X? I haven't tested on my OS X yet.
13:12:04 <merijn> ReinH: I haven't tested modifiers, tbh
13:12:21 <chrisbuchholz> So i have been playing with haskell and doing some project euler problems with it for a few month, but have recently been a bit off haskell for about two months (playing with golang, you know). So my question is. Im in doubt as to where i should continue this endeavor or if i should stop here. I like haskell type inference, its lazy evalution, its partial application and function application, its list comprehensions and its pattern ma
13:12:27 <chrisbuchholz> ... really use haskell for, other than maybe project euler problems. That is surely because im a novice, but can some of you more experienced share some of it? Now that i now that functional programming is great and fits in about more places than object oriented programming does, should i take that with me and look at a more practical function language or something, or can i really use haskell for something? Many peeps on the web does
13:12:33 <chrisbuchholz> ... anything else, you should learn haskell so you can use the benefits of its ideology in other programming languages" and is this really what it is used for?
13:12:51 <merijn> But I consider it really inconvenient that vty doesn't generate "A pressed" and "A released" events, this makes it hard to do things like "make visible while key X is pressed"
13:13:05 <roconnor> elliott: In particular I need to use the PST8PDT timezone which appears to be out of scope for the parsing function in Data.TIme
13:13:09 <merijn> It just periodically generates "A pressed" events if you press and hold
13:13:17 <elliott> roconnor: ah, no idea then
13:13:35 <elliott> chrisbuchholz: your first two lines got cut off.
13:13:42 <merijn> chrisbuchholz: Your first sentence cut off after "its pattern ma"
13:13:43 <ReinH> merijn: I guess I'll see what happens
13:13:51 <ceti331> i find haskell very elegant but really odd for basic things that you take for granted in OO languages (or rather languages with C like structs)
13:14:09 <dmwit> Haskell is good for what ails you.
13:14:21 <elliott> chrisbuchholz: anyway, from what I can infer, haskell is perfectly practical and people use it to write actual programs, whether web development (see yesod, snap, happstack), compilers (ghc, of course), window managers (xmonad), version control systems (darcs)...
13:14:25 <merijn> ceti331: I find it really nice for basic things too, but I will admit that it took my quite a lot of familiarising with libraries/tools before I felt that way
13:14:28 <Zeev> chrisbuchholz: what'che learning haskell for
13:14:30 <Zeev> ?
13:14:30 <dmwit> I wonder what qualifies as "a more practical functional language".
13:14:38 <ceti331> i think the best languages are multi-paradigm. languages which take haskell-style ideas and add them to more traditional OO would be the best, IMO
13:14:41 <merijn> dmwit: Ocaml, just ask Harper!
13:14:43 <ceti331> rust looks awesome
13:14:50 <elliott> there are lots of good, mature libraries on hackage. the problem of "what can I write in Haskell?" is close to the problem of "what can I write in your average general purpose language?"
13:14:54 <monochrom> chrisbuchholz: I use haskell for some of my own little programs. http://www.vex.net/~trebla/portfolio/index.html  I have never cared about project euler.
13:15:11 <elliott> and ironically Haskell is actually not really that suited to project euler.
13:15:17 <stepcut> chrisbuchholz: I use it for just about everything, from replacing bash scripts to database driven websites
13:15:45 <stepcut> hoping to use it for robots soon, but the ARM support is only just now coming to life
13:16:15 <dmwit> I know of at least one dude (who's even in-channel a lot these days!) who uses Haskell for robots.
13:16:22 * thoughtpolice uses it at work for everything from networking tools to tearing apart binary files in automated ways
13:16:27 <merijn> I have a colleague who uses haskell to design chips/FPGAs using a haskell DSL
13:16:42 <stolaruk> ceti331: maybe Common Lisp for multi paradigm?
13:16:48 <monochrom> but you can always say you want to focus on job languages. it's your life.
13:17:09 <elliott> I like the near-simultaneous mention of robots
13:17:44 <ceti331> stolaruk, i'm a C++ person really; i enjoyed lisp alot for its macro system and reasonable functional feel. Rust looks like the most promising 'next langauge' for me, being so close to what C++ can do
13:17:55 <enigmuriatic> http://hpaste.org/69535
13:17:58 <enigmuriatic> how do i fix that?
13:18:28 <dmwit> Install the z library.
13:18:34 <monochrom> apt-get install zlib1g-dev
13:19:00 <monochrom> God I can't believe I remember the exact string "zlib1g-dev"
13:19:08 <Cale> ceti331: I've found that you can actually do OO programming in Haskell perhaps better than you can do it in most other typed "OO" languages.
13:19:23 <chrisbuchholz> elliott: yeah, exactly, but just as haskell is superior for some stuff, because of the abstractions is has, is it just as bad for other more practical stuff for the same reason? Thats what im thinking because there must be a reason that its only used by academics and hippies, right?
13:19:39 <ReinH> merijn: handing press/release events is an edge case for me but I can see how it would be useful.
13:19:40 <merijn> chrisbuchholz: What practical stuff is it bad at?
13:19:41 <stolaruk> Cale: how so? Just curious.
13:19:45 <chrisbuchholz> Zeev: to learn functional programming
13:19:51 <thoughtpolice> monochrom: yeah, i hate that package name for that reason. i don't know why it breaks the typical 'lib<foo>-dev' convention
13:19:58 <thoughtpolice> and what's with the 1g part?
13:19:58 <chrisbuchholz> monochrom: cool, will give it a check
13:19:59 <elliott> chrisbuchholz: lol, are you trolling?
13:20:05 <elliott> "only used by academics and hippies"?
13:20:06 <ReinH> chrisbuchholz: lots of fallacies in that statement
13:20:06 <ceti331> Cale , i want to like haskell, and have enjoyed dabbling with it, but i still find it really alien without C style object.member data acess ... and the workaround of putting little prefixes on member names
13:20:08 <Cale> Just using a very simple encoding where types of objects are simply records which consist of the messages that the object is capable of responding to.
13:20:11 <roconnor> unix-time seems like it might work
13:20:15 <roconnor> for me
13:20:34 <chrisbuchholz> stepcut: is that a breeze or is it more trouble than its worth? Like, can haskell manipulate file trees better than bash?
13:20:36 <Cale> Typically, as a bunch of functions which take some parameters, and perhaps produce another object of the same type.
13:20:37 <ReinH> ceti331: haskell record syntax is definitely warty, but it's not worth throwing the baby out with it.
13:20:46 <chrisbuchholz> merijn: i dont know, im asking you guys :D
13:20:51 <ceti331> Cale, i'm not a fan of OO - i dont like the style of coding of putting everytghing in classes. i write in a C/C++ style as opposed to C++
13:20:53 <chrisbuchholz> elliott: about what?
13:20:54 <ReinH> Lenses are an excellent way to improve record access (among other things)
13:20:57 <stepcut> bash is definitely more trouble than it is worth
13:21:06 <elliott> chrisbuchholz: <elliott> "only used by academics and hippies"?
13:21:12 <Cale> The thing which is really really harmful about most typed OO languages is that they tie method implementations to the types of the objects involved.
13:21:13 <ReinH> and, in fact, provide a very imperative-style access
13:21:38 <merijn> elliott: No one uses haskell for real stuff! I certainly have never been asked to write it for money!
13:21:39 <ceti331> i tried single-letter prefixes which is almost like m_Blah in C++ .. then again I hate that style in C++ aswell :) i prefer to use this->blah to m_Blah
13:21:41 <chrisbuchholz> Eliel: well, thats probably not exactly right, but you should be able to infer my meaning there too :D
13:21:41 <enigmuriatic> what about this? http://hpaste.org/88065
13:21:41 <Zeev> chrisbuchholz: what'cha learning functional programming for, then?
13:21:43 <monochrom> if you asked me why other people wouldn't use Haskell, I cannot answer you. I use Haskell, I am not other people. ask those people who don't use Haskell. ask other channels.
13:21:44 <Cale> like, C++ for instance, has you define your method implementations inside of each class.
13:21:53 <ceti331> i tried using destructuring more , which is ok, but still alien for me
13:21:57 <Cale> This is what causes people to want to subclass a lot more.
13:22:10 <chrisbuchholz> Zeev: to become a better programmer - to broaden my horizon.
13:22:32 <ceti331> yeah this side of OOP annoys me imensly. i like what Rust does with struct,trait,impl
13:22:38 <elliott> chrisbuchholz: (I assume you meant to ping me) the only inference I can make from that statement is that you're making some kind of weird assumption about who uses Haskell rather than looking at who actually does. probably someone else told you only academics and hippies use Haskell and you believed them?
13:22:38 <ceti331> which is of course inspired by haskell
13:22:40 <stepcut> chrisbuchholz: I can't find the CUFP paper we wrote offhand, but here are some slides, http://cufp.org/archive/2006/slides/CliffordBeshers.pdf
13:22:51 <ceti331> its why i prefer using Functions in C++ to Member-Functions
13:23:28 <ceti331> C# has "extention methods" to solve this problem, and D has "uniform call syntax" a.foo(b) === foo(a,b)
13:23:52 <Cale> So, yeah, in Haskell, if you take the position that a type of an object is meant to express the types of the messages it can respond to (and the types of its responses), then you can do a lot without subtyping at all.
13:24:11 <chrisbuchholz> elliott: well, mostly that is the feeling im getting around the web but surely i can be wrong!
13:24:18 <chrisbuchholz> elliott: it was just a joke anyways
13:24:53 <stolaruk> Cale: I'm still early in the Haskell learning process, looking forward to many (more) revelations, being that I am coming from an OO background for the most part
13:24:58 <enigmuriatic> why is this happening? i have the newest version of cabal http://hpaste.org/88065
13:24:58 <Cale> and by implementing specific objects as functions taking the values of "private members" as parameters, and producing an object type result (often recursively, as in a pure encoding, the object will produce a modified version of itself in response to many messages)
13:25:11 <elliott> people say lots of things about haskell, just as people say lots of things about anything on the internet, and just like most things, most of the statements about haskell on the internet are nonsense
13:25:32 <chrisbuchholz> stepcut: nice slides
13:25:39 <Cale> you can very easily translate the major ideas of Smalltalk-style OO without all the baggage from Modula
13:25:56 <Cale> (at least, I think so)
13:26:13 <chrisbuchholz> elliott: sure. so that is why i am asking. I want to know what those people that are not hippies and academics use it for
13:26:43 <Cale> ceti331: The little syntactic thing of needing different names for the methods of different objects maybe takes a little getting used to, but it's really not so bad.
13:26:44 <monochrom> enigmuriatic: that is abnormal. on my normal computer, using GHC 7.4.2, "cabal install gloss" successfully chooses an older gloss (1.7.7.201204.1) as opposed to getting stuck.
13:26:45 <merijn> I think the only person that complains about haskell who is not uninformed seems Rob Harper and he's just jealous that haskell is winning the FP popularity context :p
13:26:53 <Cale> ceti331: and you can always use type classes :)
13:27:18 <merijn> chrisbuchholz: Why would you disqualify academics?
13:27:28 <ceti331> Cale yes i heard you could make a typeclass for a specific element name .. and macros to instantiate them?
13:27:33 <Cale> But yeah, you'll also be able to squish many more objects into the same type, because you can implement methods differently on a per-object basis.
13:27:38 <elliott> chrisbuchholz: you may be interested in https://www.fpcomplete.com/blog/2013/02/announcing-case-studies, http://www.haskell.org/haskellwiki/Haskell_in_industry (latter probably outdated)
13:27:58 <enigmuriatic> monochrom, any idea how to fix it?
13:27:59 <chrisbuchholz> merijn: oh i didnt? Not on purpose anyways
13:27:59 <Cale> ceti331: You don't necessarily need macros, but instances anyway.
13:28:24 <elliott> chrisbuchholz: facebook and intel and stuff have used haskell for individual things. it's not really a mainstream language, but it's far from hopelessly obscure.
13:28:24 <Cale> (there's a bit of syntactic baggage that you might be able to avoid with some Template Haskell, but it's no big deal)
13:28:25 <merijn> I know university people who do hardware design and use haskell, the fact that they're doing that at a university seems orthogonal to whether you'd use haskell for "real world" code
13:28:32 <merijn> elliott: Google too
13:28:53 <merijn> I remember Google validating some sort of cluster management thing by reimplementing it in haskell
13:29:00 <monochrom> I don't even know the cause. it is abnormal. I can't say how to fix. well I could say "start with a clean computer" but that's silly.
13:29:33 <thoughtpolice> NVidia also uses Haskell. and so does AMD :)
13:29:37 <chrisbuchholz> elliott, merijn: but what are the obvious reasons that you dont write say the backend code for a chat in haskell and the frontend in ObjC (or C++, god forbid)
13:29:41 <dmwit> monochrom: Perhaps gloss is the name of a directory and something weird there is happening...?
13:29:51 <dmwit> enigmuriatic: Could you add some verbosity and try again?
13:29:54 <elliott> chrisbuchholz: what do you mean?
13:29:57 <chrisbuchholz> elliott, merijn: as in, that is not what i am hearing people doing
13:29:58 <dmwit> -v3 why not
13:30:01 <Cale> merijn: While you definitely can't say that Rob Harper is uninformed, some of the things he says about lazy evaluation are either disingenuous or a bit kneejerk.
13:30:03 <elliott> if I were writing some chat thing, I'd feel free to do that.
13:30:15 <joe9_> i am looking for a pretty printing 2-d array library. Any recommendations, please?
13:30:15 <thoughtpolice> chrisbuchholz: well, i would write the backend code in haskell, most certainly. :)
13:30:15 <chrisbuchholz> elliott: well, its such a cool language (language vice), why is it not used me for those kinds of jobs?
13:30:18 <elliott> chrisbuchholz: if you are only interested in what most people do, how can you claim to be interested in broadening your horizons?
13:30:21 <monochrom> -v3 is ok. I know how to read its output
13:30:34 <elliott> languages can be popular for reasons other than their merit
13:30:47 <merijn> Cale: I wasn't saying he was correct, only that he is not uninformed ;)
13:30:55 <Cale> :)
13:30:59 <dmwit> Nooooo, nerddom is a universal meritocracy!
13:31:40 <chrisbuchholz> elliott: ha :D Well, i am broadening my horizon by asking why other people are not doing stuff, merely to understand - not to not do them the act after
13:31:40 <ReinH> chrisbuchholz: I suspect that you are not indending it this way but what you are saying is coming across as trollish
13:31:41 <enigmuriatic> dmwit http://hpaste.org/88067
13:31:54 <Zeev> chrisbucholz: find something annoying that you have when interfacing with the machine *aka working with a computer*, then automate it. Then the correct language choice will flow from that
13:31:58 <merijn> chrisbuchholz: I totally would do that, a haskell backend would probably be easier to implement and perform really well too
13:32:08 <elliott> chrisbuchholz: probably the reason people don't write backends in haskell is because they don't know haskell.
13:32:12 <Zeev> chrisbucholz: no need to aimlessly 'broaden your horizons' for example
13:32:14 <chrisbuchholz> ReinH: Not intentionally, that is for sure!
13:32:28 <merijn> chrisbuchholz: I would say that concurrent networking/server things are one of the best usecases for Haskell
13:32:32 <dmwit> enigmuriatic: moar, MOAR! -v3
13:32:44 <merijn> forkIO and synchronous socket handling are your friends!
13:32:46 <ReinH> chrisbuchholz: you seem to be making a lot of assumptions about what kind of things Haskell is good for and what kind of things it is used for without any real insight. No offense.
13:32:47 <dmwit> enigmuriatic: I'm going to feel awful when even -v3 doesn't have enough information, aren't I? =P
13:32:55 <chrisbuchholz> merijn: right okay. Interesting
13:32:57 <elliott> chrisbuchholz: the reasons they don't know haskell can depend. take your pick: they've just never heard of it; jobs for other languages are more available so they stuck with those; it's too dissimilar from languages they know; someone told them Haskell is only for hippies and academics.
13:33:10 <monochrom> nerddom is clearly an egomaniacracy not meritocracy
13:33:17 <elliott> (that's not to say that anyone who knows haskell will use it for anything. it's not perfect by any means.)
13:33:18 <merijn> chrisbuchholz: Bollocks to all these "node.js asynchronous spaghetti" nonsense >.>
13:33:20 <ReinH> chrisbuchholz: I personally think there's a real problem in beginner-intermediate education for Haskellers
13:33:23 <enigmuriatic> http://hpaste.org/88068 dmit
13:33:28 <enigmuriatic> http://hpaste.org/88068 dmwit
13:33:30 <ReinH> chrisbuchholz: and that this is one of the reasons that Haskell is not more widely adopted
13:33:42 <merijn> ReinH++
13:33:47 <ReinH> chrisbuchholz: but the language per se is certainly suitable for a wide variety of tasks
13:33:53 <monochrom> python and perl are widely used because they have big egos behind
13:34:26 <merijn> The step from end of LYAH/RWH to transformers+lens+conduits/iteratee/flavour-of-the-month+stuff is a bit big
13:34:28 <dmwit> enigmuriatic: Wait, GHC 6.12?
13:34:33 <seliopou> monochrom: really? not because they solve problems without comptuer science?
13:34:37 <chrisbuchholz> ReinH: No, I dont think I am. I think I am asking why i dont hear haskell is used for stuff to get a better understanding - is it because it is not possible?
13:34:42 <elliott> haha, "without computer science"
13:34:56 <enigmuriatic> dmwit, i'm on a default debian install
13:34:57 <ReinH> chrisbuchholz: No, haskell is capable. It's a people problem.
13:35:07 <monochrom> haskell is much less used because Peyton Jones, Wadler, and Hughes are reasonable easy-going people
13:35:08 <elliott> imagine if people said that kind of thing about other fields.
13:35:12 <ReinH> chrisbuchholz: Haskell has a perception problem and an education problem.
13:35:17 <elliott> "I solved the problem of building this house without architecture or construction!"
13:35:18 <ReinH> chrisbuchholz: it emphatically does not have a technology problem.
13:35:22 <edwardk> merijn: when i find infinite free time i'll write a book ;)
13:35:53 <chrisbuchholz> merijn: Id like to write a server in haskell. Happy to hear it should be good at it. Will take me a few more months before i understand enough of haskell to do it
13:35:55 <merijn> edwardk: Oh, that'll probably coincide with me writing my "Guided tour of GHC extensions" book :)
13:35:55 <seliopou> elliott: imagine if you were a biology researcheer and you had to study optics extensively to use a microscope
13:36:09 <monochrom> shapr comes close to being an iron wrist but only for #haskell not haskell
13:36:17 <chrisbuchholz> ReinH: And you are surely right, i am not saying it isnt. I am merely asking!
13:36:42 <dmwit> enigmuriatic: Okay. You will need to ask for an older version of gloss -- no later than 1.7.7.1 if I'm reading Hackage/the GHC release notes correctly.
13:36:44 <elliott> seliopou: well, it is not true that you have to study more "computer science" to learn Haskell than to learn any other language, so I reject the analogy.
13:36:48 <geekosaur> you can't use unsafePerformIO to write a book :p
13:36:51 <monochrom> under the iron wrist, err guiding hand!, of shapr, #haskell has grown to over 1100 users!
13:36:53 <ReinH> chrisbuchholz: sure, but you were asking in such a way that it seemed you had already made your mind up. That's all. Being open is a more productive way to learn things. :)
13:36:58 <merijn> chrisbuchholz: It's fairly easy if you know socket programming already, you bind a port, accept connections in a loop, then forkIO a thread per connection. The GHC runtime will take care of blocking/unblocking threads using select/kqueue/epoll for you :)
13:36:58 <edwardk> shapr has slacked off in his old age and left us to fend for ourselves mostly ;)
13:37:00 <elliott> you have to study Haskell. Haskell is a programming language, hence part of computer science. so you'll learn computer science. but the same applies to Python or any other language
13:37:17 <seliopou> elliott: that's obviously false
13:37:23 <dmwit> enigmuriatic: Alternately, try 'cabal install gloss --constraint "base installed"' and see if that gives cabal enough of a kick to pick an old version by itself.
13:37:33 <chrisbuchholz> ReinH: I am sorry that it came across like that. It would make no sense to ask the questions, if I had already decided on the answers.
13:37:34 <seliopou> look at the state of the world around you, and attempt to explain it
13:37:52 <chrisbuchholz> merijn: sounds fancy ;)
13:37:57 <edwardk> shapr swooped in like 'community man' with a lambda on his chest built a #haskell community, and said "my work here is done, carry on".
13:38:08 <elliott> seliopou: the state of the world has very little to do with haskell or python, I find
13:38:12 <ReinH> chrisbuchholz: Yep, and I'm not trying to beat you up. Just offering suggestions to help you avoid miscommunications. :)
13:38:13 <edwardk> er chest, built
13:38:59 <chrisbuchholz> ReinH: yeah sure ;)
13:39:07 <merijn> edwardk: And by that you mean he got hijacked by a woman and the fancy notion that college degrees are useful, right?
13:39:08 <seliopou> elliott: that really moves the conversation forward
13:39:10 <ReinH> chrisbuchholz: "Why isn't Haskell more prevalent in industry?" is a valid question and there are a lot of factors.
13:39:22 <monochrom> seliopou: I can answer your question. first they still use a bit of computer science, just not entirely. secondly you beg the question: but why not use more computer science? and my point explains that: because ego. my explanation is more fundamental.
13:39:25 <elliott> seliopou: about as much as "that's obviously false" does
13:39:29 <ReinH> chrisbuchholz: I don't think it's because it is unfit, though.
13:39:31 <edwardk> merijn: pretty much. i think i may have been a bad influence from the college front. =)
13:39:35 <chrisbuchholz> ReinH: yeah exactly, and that is what i wanted to know more about
13:39:48 <elliott> seliopou: I assume what you meant was something like "try to explain why more people use Python than Haskell". but in fact I already gave my explanation of this
13:39:48 <ReinH> chrisbuchholz: I think it's mainly historical, cultural, and etc.
13:40:08 <elliott> seliopou: <elliott> languages can be popular for reasons other than their merit  <elliott> chrisbuchholz: the reasons they don't know haskell can depend. take your pick: they've just never heard of it; jobs for other languages are more available so they stuck with those; it's too dissimilar from languages they know; someone told them Haskell is only for hippies and academics.
13:40:14 <chrisbuchholz> What are some great haskellers to follow on twitter? I guess that would be a way to get into the culture more, and hear more about haskell stuff
13:40:15 <merijn> I'm still stuck on the hard decision between phd and going to work for something like Jane Street and earning big FP bucks :p
13:40:37 <elliott> I find this explanation more plausible than "Haskell is inherently hard because it uses computer science and C++ and Python don't"
13:40:39 <ReinH> chrisbuchholz: edwardk is my personal Haskell Hero.
13:40:48 <merijn> Word
13:40:50 <ReinH> chrisbuchholz: @kmett
13:40:54 <thoughtpolice> chrisbuchholz: the trick is you only have to find one and you can just look at their followers and who follows them :P
13:41:04 <merijn> Everytime edwardk releases a library I can scrap half my code :p
13:41:04 <thoughtpolice> edwardk is a pretty good bet i'm sure!
13:41:14 <ReinH> elliott: no, no, you've got it all wrong. Haskell is inherently hard because it uses *Math* and C++ and Python don't.
13:41:18 <ReinH> elliott: :p
13:41:19 <elliott> (clearly when Python brought in list comprehensions and C# brought in lambdas and LINQ, they stripped all the computer science out of it first... otherwise they wouldn't be popular any more)
13:41:21 <seliopou> oy
13:41:23 <seliopou> ok
13:41:39 <ReinH> the rhetoric is really flying in this room today.
13:41:39 <shachaf> Cale: How's lambdabot doing?
13:41:54 <monochrom> always blame information cost
13:42:22 <chrisbuchholz> ReinH: I also think its because most programmers know C-style languages and Haskell (among others) are not, so its harder to get a community around it as big as say Python. Then some java folks spread Scala around, and some Javascript hipsters did the same with Erlang and it became quite popular with web folks because of CouchDB, so theres that. Haskell doesnt have stuff like that though
13:42:35 <ReinH> I think the CS/Math concepts exposed Haskell are less familiar to your average CS grad than those exposed by Python, C++, etc. I think that's a perfectly valid thing to say.
13:42:37 <seliopou> monochrom: I'm not arguing that more comptuer science is bad. In fact I take the oposite position in principle but pragmatically I don't think industry shares that belief, or at least cannot act on it. Also, I  fail to see how that explanation is more fundamental.
13:42:40 <ReinH> *exposed by Haskell
13:42:40 <thoughtpolice> shachaf: having fun running kappabot?
13:42:41 <chrisbuchholz> ReinH: thanks
13:42:52 <chrisbuchholz> thoughtpolice: indeed, that is the trick :D
13:43:11 <merijn> mm_freak: Would it be silly to use Wire inhibition as the way to produce render output?
13:43:13 <ReinH> chrisbuchholz: np
13:43:17 <shachaf> thoughtpolice: It's a lot of fun. You should try it.
13:43:33 <chrisbuchholz> thoughtpolice: problem is, if you find one, and who is just one of those that follows everyone, then you gotta sort through thousands of people.
13:43:35 <seliopou> elliott: "too dissimilar" and "harder" have a similar behavioral effect, and are also empriical questions
13:43:39 <merijn> seliopou: Depends, there's people in industry that do share the belief
13:43:40 <Zeev> I got to haskell through F# and by issuing /list on freenode
13:43:41 <seliopou> empirical*
13:43:42 <thoughtpolice> chrisbuchholz: happens :P
13:43:46 <ReinH> chrisbuchholz: I'd also follow http://www.haskellforall.com/
13:43:51 <seliopou> merijn: not disputing that
13:43:52 <merijn> seliopou: i.e. Carmack and Sweeney are about as "industrial" as you get
13:43:58 <seliopou> however, again, take a look around
13:44:03 <ReinH> chrisbuchholz: for more serious readings, http://themonadreader.wordpress.com/
13:44:12 <thoughtpolice> shachaf: i couldn't take kappabot from you, that would surely be devastating, what with all the fun you're having
13:44:27 <ReinH> chrisbuchholz: if you want a brief (and currently incomplete) introduction to haskell via actual coding, I do HaskellLive.com
13:45:01 <monochrom> if I try running a version of lambdabot, I'll call it eta_mu, because, you know, eta and mu, return and join, monad...
13:45:27 <Taneb> I'd call mine Tanebskellbot
13:45:34 <merijn> Caleskellbot
13:45:38 <seliopou> monochrom: nerd-five :P
13:45:57 <shachaf> monochrom: what about eta and epsilon
13:46:21 <monochrom> I heard that epsilon was afraid of zeta
13:46:37 <shachaf> Who isn't?
13:46:51 <monochrom> catherine zeta-jones isn't
13:47:01 * shachaf still supports switching from Greek to Hebrew letters.
13:50:31 <monochrom> just call it PAAMAYIM_NEKUDOTAYIM
13:51:50 <monochrom> oddly enough, :: is important in Haskell too :)
13:53:09 <chrisbuchholz> ReinH: thanks
13:57:24 <monochrom> I need to add a sicp.xhtml section on "cabal install" as root such as "sudo cabal install" which is "sudo cabal install --user" which totally does the opposite of what people assume.
14:00:01 <Saizan> noone ever got around to checking if it's running as super-user and default to --global there
14:00:45 <Saizan> there are some portability problems, iirc
14:01:11 <orzo> Is there an "xor" operation for Bool in the standard libraries?
14:01:30 <orzo> if so, what is it?
14:01:59 <elliott> orzo: (/=)
14:02:07 <orzo> oh, thanks
14:02:14 <elliott> :)
14:02:41 <Bio> is there a way to convert a list of integers into a list of chars?
14:02:58 <Bio> ints*
14:03:08 <mm_freak> merijn: yes, probably
14:03:28 <mauke> Bio: show
14:03:29 <monoidal> Bio: map toEnum
14:03:40 <Eduard_Munteanu> Bio: sure, do you know how to convert an integer to a char?
14:03:55 <elliott> Bio: what do you want it to do?
14:04:02 <Bio> i can use show to convert an inteeger to a char, but when i do it on an array
14:04:03 <elliott> don't just say the type; say the behaviour
14:04:06 <merijn> mm_freak: ok, good, that means I'm not crazy for thinking that, then :)
14:04:24 <quchen> Remind me again, why do we still have the DMR on by default?
14:04:27 <Bio> using map, then it seem to turn int an list of strings
14:04:40 <mauke> I didn't say map
14:04:42 <mauke> I said show
14:04:49 <ReinH> chrisbuchholz: np
14:04:56 <Bio> okey, gonna try that then
14:04:58 <Botje> :t map show
14:04:59 <kappabot> forall a. Show a => [a] -> [String]
14:05:07 <mm_freak> merijn: one easy and clean way to produce render output is to use a writer as the underlying monad
14:05:16 <mm_freak> so express your scene as a monoid
14:05:43 <mm_freak> even better if it's commutative
14:05:45 <Botje> quchen: it's a devious way of luring newbies to #haskell, i'm sure.
14:05:47 <Bio> well, show just made the output look weird
14:06:29 <Botje> Bio: can you give an example of what you want, then?
14:06:42 <Botje> because show [1,2,3] is technically ' a list of chars'
14:06:44 <Eduard_Munteanu> Bio: well, what do you expect it to do?
14:07:02 <Bio> i just want to turn a list of ints [1, 2, 3, ...] into a string that looks like "1 2 3 ..."
14:07:21 <Botje> > unwords (map show [1,2,3])
14:07:22 <kappabot>   "1 2 3"
14:07:38 <Bio> ah
14:07:39 <Eduard_Munteanu> > unwords (fmap show [1,2,3])
14:07:40 <kappabot>   "1 2 3"
14:07:55 <quchen> Botje: Wouldn't a devious compiler warning be enough?
14:07:57 <quchen> I'm thinking of the empty string, to spell it out ;-)
14:08:16 <enigmuriatic> why does this happen with containers? http://hpaste.org/80431
14:08:20 <Botje> what would a devious warning look like :P
14:08:23 <enigmuriatic> (i used a paste i found on google)
14:08:26 <Eduard_Munteanu> > unwords (fmap show $ listArray (1, 3) [1,2,3])
14:08:27 <kappabot>   Couldn't match expected type `[GHC.Base.String]'
14:08:27 <kappabot>              with actual t...
14:08:35 <Eduard_Munteanu> :t listArray
14:08:36 <kappabot> forall i e. Ix i => (i, i) -> [e] -> Array i e
14:08:53 <Botje> Eduard_Munteanu: stick a call to elems in there
14:09:06 <Eduard_Munteanu> Oh, duh.
14:09:10 <Botje> although that kind of defeats the point
14:09:18 <merijn> mm_freak: Yeah, that's another thing I considered. I will basically have to see which way works out nicer
14:09:44 <Eduard_Munteanu> > unwords (map show . elems $ listArray (1, 3) [1,2,3])
14:09:46 <kappabot>   "1 2 3"
14:09:46 <haasn> “<interactive>:3:5: One-liner not elegant enough. Perhaps you meant to import Control.Lens? For further feedback, it has been automatically pasted to IRC and the results collected here: <hpaste>”
14:09:55 <merijn> mm_freak: As that approach might spend a lot of unnecessary time creating scenes
14:10:04 <quchen_> Is Bas van Dijk in this channel by any chance?
14:10:10 <Eduard_Munteanu> Botje: well, not quite, converting it to a list seems ok
14:10:21 <enigmuriatic> why does this happen with containers? http://hpaste.org/80431
14:10:21 <enigmuriatic> (i used a paste i found on google)
14:10:30 <ReinH> "One-liner not elegant enough"? That's awesome.
14:10:55 <mm_freak> merijn: you can also have scene deltas
14:11:16 <Bio> thanks guys :)
14:11:27 <Eduard_Munteanu> ReinH: yes, we don't golf, we prefer verbose recursion schemes and category theory abstractions.
14:11:43 <elliott> we do golf!
14:11:49 <elliott> though I forget the lambdabot @where names.
14:11:53 <geekosaur> ummm, why are you letting it install a new version of containers?
14:12:01 <mm_freak> merijn: hint:  make your scene a group instead of just a monoid
14:12:13 <geekosaur> that's a lovely way to hose your installation. (and it looks like it may be incompatible with your ghc)
14:12:35 <haasn> @where pi10
14:12:36 <kappabot> I know nothing about pi10.
14:12:37 <haasn> or something like that
14:12:39 <haasn> hmm
14:12:41 <haasn> @where pi
14:12:41 <kappabot> I know nothing about pi.
14:12:44 <haasn> oh
14:12:45 <mm_freak> merijn: for example this is a group:  Map SceneObject Integer
14:12:46 <haasn> kappabot
14:12:55 <mm_freak> merijn: where the Integer acts like a reference count
14:13:04 * mauke waves to osa1
14:13:15 <hpc> @where pi_10
14:13:16 <kappabot> I know nothing about pi_10.
14:13:20 <elliott> @where pi15
14:13:20 <kappabot> I know nothing about pi15.
14:13:22 <elliott> @where pi12
14:13:22 <kappabot> I know nothing about pi12.
14:13:23 <mm_freak> merijn: then 'fmap negate scene' is the inverse of 'scene'
14:13:26 <elliott> we just need to keep guessing numbers.
14:13:28 <elliott> oh wait, kappabot
14:13:33 <merijn> mm_freak: I haven't decided what my scene datatype will end up being, though
14:13:34 <elliott> of course it doesn't have lambdabot's @wheres.
14:13:37 <haasn> 2013-01-12 03:36:18 lambdabot (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]] -- pi_10
14:13:38 <edwardk> @where pi10
14:13:38 <kappabot> I know nothing about pi10.
14:13:41 <edwardk> =(
14:13:46 <haasn> 2013-01-12 03:36:55 lambdabot [show(foldr(\k a->20*100^n+a*k`div`(2*k+1))0[1..[4,8..]!!n])!!n|n<-[0..]] -- pi_11
14:14:02 <mauke> preflex: version
14:14:03 <preflex>  9.784
14:14:40 <mauke> preflex: store pi_10 (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
14:14:49 <mauke> preflex: store pi_11 [show(foldr(\k a->20*100^n+a*k`div`(2*k+1))0[1..[4,8..]!!n])!!n|n<-[0..]]
14:15:02 <mauke> preflex: ? pi_10
14:15:02 <preflex>  (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
14:15:08 <haasn> > (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
14:15:12 <kappabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
14:16:37 <hpc> > [show(foldr(\k a->20*100^n+a*k`div`(2*k+1))0[1..[4,8..]!!n])!!n|n<-[0..]]
14:16:41 <kappabot>   mueval-core: Time limit exceeded
14:17:11 <haasn> > take 10 [show(foldr(\k a->20*100^n+a*k`div`(2*k+1))0[1..[4,8..]!!n])!!n|n<-[0..]]
14:17:12 <kappabot>   "3141592653"
14:17:35 <lispy> Cale: have we pretty much given up on lambdabot at this point?
14:19:01 <enigmuriatic> how do i install ghc with cabal?
14:19:15 <monochrom> cannot
14:19:55 <monochrom> but usually if you ask that because of a cabal error message, then your package database is hosed. erase.
14:20:15 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml#remove . in fact, see the whole thing.
14:21:15 <Cale> lispy: no, still working on it
14:21:28 <lispy> Cale: let me know if I can help
14:21:59 <monochrom> Cale: what have you figured out so far? just broadly and vaguely is ok
14:22:13 <dmwit> haasn:
14:22:15 <dmwit> ?where pi10
14:22:15 <kappabot> I know nothing about pi10.
14:22:22 <dmwit> oh, right
14:22:28 <mauke> why so repeat
14:22:33 <monochrom> err, what is pi10?
14:22:36 <dmwit> Because I am dum.
14:22:40 <Cale> monochrom: mueval itself is dying after 5 seconds regardless of how the timeout is set (and I can verify that it's actually setting the timeout correctly)
14:22:47 <haasn> pi10 is approximately 31.415926
14:23:11 <monochrom> interesting
14:23:25 <quchen_> Cale: Do you know what's wrong with Lambdabot?
14:23:35 <mauke> ...
14:23:38 <Cale> quchen_: I just said what's wrong with lambdabot
14:23:51 <quchen_> Oh, I think I lost connection there then.
14:23:52 <monochrom> I think quchen_ is doing a joke on repeating :)
14:23:59 <quchen_> Nope, not a joke :-(
14:24:03 <monochrom> or that
14:24:10 <monochrom> I lag! :)
14:25:07 <Cale> quchen_: mueval itself is dying after 5 seconds regardless of how the timeout is set (and I can verify that it's actually setting the timeout correctly)
14:25:22 <quchen_> Ah. I indeed missed that.
14:26:08 <Cale> The annoying thing is that it takes very close to 5 seconds to respond to any request in any case on this machine
14:26:34 <Cale> So, when it succeeds, it often takes somewhere from 3 to 4.9 seconds
14:26:41 <monochrom> is it a virtual machine? 5 seconds is a long time these days
14:26:45 <Cale> yes
14:27:01 <Cale> It's hosted on lispy's linode
14:28:44 <monochrom> it's still pretty bad. on my 4-year old laptop, and an entry-level one even at that time (like, "pentium", small cache...), inside virtualbox, launching ghc doesn't take 5 seconds
14:28:49 <Cale> oh
14:28:56 <Cale> lol, I think I found it
14:29:01 <Cale> this is... derpy
14:29:32 <monochrom> um, please tell me it is not another "what do you mean threadDelay is in microseconds" :)
14:30:07 <Cale> lol, apparently it was being killed after 49 tenths of a second, because there was a delay of 7 * 700000
14:30:22 <Cale> I don't think whoever wrote this code actually knew what units threadDelay was in
14:30:35 <mauke> ಠ_ಠ
14:30:42 <monochrom> ok, it is. dammit. dammit when I guess right hahaha
14:30:57 <elliott> Cale: so wait...
14:30:59 <elliott> how did lambdabot ever work?
14:31:01 <elliott> btw, it is sin that threadDelay does not take Data.Fixed (in seconds) or something instead
14:31:03 <Cale> But also, this delay was being set independently of the timeout, I just missed it
14:31:05 * hackagebot fgl-visualize 0.1.0.1 - Convert FGL graphs to dot (graphviz) files  http://hackage.haskell.org/package/fgl-visualize-0.1.0.1 (ThomasDuBuisson)
14:31:27 --- mode: ChanServ set +o monochrom
14:31:28 <Cale> elliott: It worked because the machine it was running on seems to have been faster in the past, I suppose
14:32:01 <elliott> monochrom: don't kick me! whatever it is was shachaf's fault!
14:32:21 <augur> Cale: all machines seem to have been faster in the past. :(
14:32:22 --- topic: set to '["lambdabot mystery solved: another threadDelay case","Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.3 http://v.gd/wie445 ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D ","If Hackage is down,try: http://hdiff.luite.com "]' by monochrom
14:32:38 --- mode: monochrom set -o monochrom
14:35:41 <Cale> Okay, it should be significantly less derpy now, and I think I'll try letting people have a somewhat longer timeout for now, say, 20 seconds.
14:36:02 <Cale> (now that it'll actually observe the correct timeout)
14:36:11 <Eduard_Munteanu> @bot
14:36:11 <kappabot> :)
14:37:31 <monochrom> perhaps linode has a tough time doing businees, and so cut corners on customers
14:38:04 <elliott> what timeout was it meant to be using previously?
14:38:44 <heath> http://hackage.haskell.org/packages/archive/random-extras/latest/doc/html/Data-Random-Extras.html#v:choices
14:38:47 <Cale> elliott: Originally it was set to 5 seconds, which was okay when most things completed in significantly less time than that.
14:38:54 <quchen_> The topic should probably be moved to a textfile or something. And then replaced by the topic of this channel, which is "Haskell, the prgramming language".
14:38:56 <heath> I'm not seeing Data.Random.Extras, ideas on why that is?
14:39:03 <heath> you can assume i don't know the basics :)
14:39:11 <Cale> elliott: Then when we started having the timeout problems, I set it to 10, but it was still being killed after 4.9 regardless.
14:39:16 <mauke> heath: "seeing"?
14:39:41 <Cale> It turns out there's a *second* timeout inside mueval itself which is hardcoded to that amount for some derpy reason.
14:39:46 <heath> mauke: http://hpaste.org/88069
14:40:08 <mauke> heath: that means nothing
14:40:14 <mauke> do you have an actual problem?
14:40:29 <heath> i'm looking for Data.Random.Extras.choicees
14:40:35 <heath> Data.Random.Extras.choices rather
14:40:43 <elliott> heath: it's in the random-extras package
14:40:47 <mauke> did you import Data.Random.Extras?
14:40:49 <heath> maybe i don't have the latest version of the random-extras package
14:40:52 <heath> yeah
14:40:56 <elliott> oh, this is about tab completion
14:40:58 <merijn> Aww, why doesn't this record syntax work with GADTs? :( http://hpaste.org/88070
14:41:16 <lispy> Cale: oh cool
14:41:19 <mauke> heath: what happens when you enter 'Data.Random.Extras.choices'?
14:41:30 <lispy> Cale: sounds like you found the problem
14:41:34 <heath> Installed versions: 0.
14:41:36 <heath> Installed versions: 0.19
14:42:22 <Cale> lispy: Yeah, I totally missed this timeout before somehow
14:42:23 <heath> http://hpaste.org/88071
14:42:23 <monochrom> merijn: I think it is only objecting to xyzzy being both Foo a b -> a and Foo a () -> a. similarly magic.
14:42:35 <mauke> heath: so it's there
14:42:39 <mauke> there is no problem
14:42:47 <merijn> monochrom: I know, but I'm sad that that doesn't work :(
14:42:48 <Cale> I've been pretty out of it lately, either suffering from allergies, or suffering from the side effects of allergy medication.
14:42:48 <heath> it doesn't import it
14:42:54 <mauke> heath: it obviously does
14:42:54 <monochrom> I see
14:43:05 <heath> ?
14:43:10 <monochrom> I also didn't know that record syntax can be put into GADT
14:43:15 <merijn> monochrom: I have two constructors that overlap in everything but 1 optional field and now I can't use record syntax for the rest
14:43:30 <heath> it imported Data.Random successfully and then blew up when I did Data.Random.Extras.choices
14:43:37 <mauke> heath: it didn't blow up
14:43:42 <mauke> did you even read the message
14:43:52 <heath> Prelude Data.Random> :t Data.Random.Extras.choices
14:43:52 <heath> Data.Random.Extras.choices :: Int -> [a] -> RVar [a]
14:43:53 <heath> i see
14:43:53 <mauke> also, why did you import Data.Random?
14:44:36 <heath> i'm trying to select 24 elements from a list randomlllly
14:44:51 <monochrom> merijn: I am reading the GHC user's guide on GADT. it explicitly forbids.
14:44:52 <heath> that seemed appropriate
14:44:56 <mauke> heath: why?
14:45:03 <mauke> heath: you want Data.Random.Extras, not Data.Random
14:45:05 <Cale> > 2^10
14:45:07 <kappabot>   1024
14:46:14 <merijn> I guess I'll just have to write my own record accessors/lenses
14:47:05 <Cale> I wish my scroll wheel would work inside screen like it does in vim.
14:47:14 <edwardk> merijn: i tend to just makeClassy on a base type that has all the common fields, and then make an instances of HasFoo for the type that adds some extra field or what not
14:47:21 <edwardk> merijn: then all the lenses work for both
14:47:53 <monochrom> edwardk++
14:48:12 <Cale> @bot
14:48:12 <kappabot> :)
14:48:17 <lambdabot> :)
14:48:40 <monochrom> @quote monochrom russian.doll
14:48:40 <kappabot> No quotes match.
14:48:47 <lambdabot> monochrom says: primop is where the turtle tower ends and the russian dolls begin!
14:48:52 <monochrom> \∩/
14:49:00 <edwardk> cale with the need for that "> 2^10" query you placed your status as a computer scientist in jeopardy. Since the number was greater than 2, your status as a mathematician still remains sound. ;)
14:49:04 <Cale> kappabot: @part #haskell
14:49:04 <kappabot> Not enough privileges
14:49:04 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
14:49:09 <monochrom> ok, I now +q kappabot
14:49:11 --- mode: ChanServ set +o monochrom
14:49:19 <mauke> did you mean: /kick
14:49:25 <Cale> > 1 + 1
14:49:27 <kappabot>   2
14:49:27 <merijn> mm_freak: What (if anything) is the difference between using mkState to turn "Time -> (a, s) -> m (Either e b, s)" into a Wire and having "Wire e (State s) a b"?
14:49:39 <lambdabot>   2
14:49:52 <Cale> slooooow
14:49:55 <edwardk> oh, lambdabot testing. nevermind. carry on then =)
14:50:00 <Cale> Though it's probably still joining channels
14:50:37 --- mode: monochrom set +q kappabot!*@*
14:50:50 <elliott> kappabot: @part
14:50:53 <elliott> kappabot: @part #haskell
14:50:58 <elliott> huh.
14:51:09 <Cale> At least it shouldn't fail catastrophically if it's a bit slow now
14:51:11 <monochrom> we probably need shachaf or one of his trustees
14:51:17 <elliott> I was a kappabot admin last time
14:51:19 <edwardk> Cale: what was the fix?
14:51:30 <mauke> edwardk: /topic
14:51:35 <monochrom> hehe
14:51:37 <edwardk> k
14:51:46 <Cale> edwardk: mueval had a second derpy timeout which I didn't see last time I was looking, with a threadDelay of 7 * 700000
14:52:40 <Cale> Hardcoded, ignoring the timeout which is set by the commandline argument
14:53:57 <Cale> edwardk: and I guess the linode that lambdabot is running on is slower than it used to be, making many requests take a little over 5 seconds just to compile
14:54:08 <edwardk> fair nuff
14:54:12 <merijn> hmmm
14:54:49 <glguy> Wow… I'll remember to avoid Linode (is lambdabot using some kind of "free tier" service?)
14:54:56 <Cale> Ask lispy
14:55:21 <merijn> I feel there should be a nicer way to have a datatype with an optional field (field presence encoded in the type!) than having 2 constructors that duplicate all 10 or so record fields >.<
14:55:24 <glguy> ?bot
14:55:24 <lambdabot> :)
14:55:35 <merijn> Any suggestions?
14:56:00 <sacundim_> you can factor the 10 fields into a separate type
14:56:10 --- mode: monochrom set -o monochrom
14:56:42 <sacundim_> PS if you think your type has 10 fields, check again, you may have forgotten one...
14:58:03 <Cale> http://www.haskell.org/pipermail/ghc-devs/2013-May/001255.html -- this is interesting!
15:00:01 <merijn> Yeah, I though about factoring it out into a separate type, but I'm not sure that's working out as nice as I'd like :\
15:02:04 <Cale> merijn: Maybe
15:02:22 <c_wraith> oh, hey, I wondered if anything was ever going to happen with the typed TH proposal
15:02:24 <c_wraith> looks like it has
15:03:09 <ArtyomKazak> Hi guys! Does anybody know why random-fu package (Data.Random) doesnt provide `Distribution` instance declarations for tuples? Is there maybe some good reason for that which Ive overlooked?
15:03:33 <merijn> Cale: That doesn't let me reflect it in the type, though
15:04:04 <monochrom> untyped template haskell. whee!
15:04:32 <augur> !seen ski
15:04:40 <merijn> Cale: Basically, I have things with an (existential) internal state s. That state is either extractable (by having have a projection function from s to some known a) or not
15:04:48 <augur> @seen ski
15:04:48 <lambdabot> Unknown command, try @list
15:04:51 <augur> :(
15:04:57 <Cale> merijn: Oh, I see, yeah, factoring out the separate type is the usual thing, or having a type parameter and a field of the parameter type
15:04:59 <otters> > 1
15:05:02 <lambdabot>   1
15:05:02 <merijn> Now the ones with a projectable state are Functors (fmap over the projected state) but the ones without are not
15:05:05 <augur> preflex seen ski
15:05:05 <preflex>  ski was last seen on ##logic 8 days, 14 hours, 28 minutes and 45 seconds ago, saying: yes
15:05:09 <Cale> (and that lets you use () when you don't want an annotation)
15:05:10 <augur> preflex seen ski_
15:05:10 <preflex>  ski_ was last seen on #haskell 33 days, 1 hour, 40 minutes and 30 seconds ago, saying: @hoogle sized
15:05:25 <augur> hm
15:07:20 <Cale> merijn: Can you hpaste your type?
15:09:14 <merijn> Cale: Right now I have something like http://hpaste.org/88072
15:11:06 <Cale> merijn: wait... that's not a valid GADT declaration
15:11:23 <Cale> oh, it is!
15:11:24 <Cale> hah
15:11:27 <Cale> type synonyms
15:12:08 <lambdazerocool> So, I've decided to work on a best-first search (a la A*) -- I imagine the best way to go about this is to use the state monad with a priority queue data structure? It feels rather imperative, but that's what comes to mind. Am I too rotted by imperative langs? :D
15:12:26 <Cale> merijn: What's WidgetWire?
15:12:26 <merijn> Cale: Yeah, if I could have compose without the newtype bagage I could do use type level Just to make functor, but without that it requires silly hacks like this
15:12:57 <merijn> Right now this (but I don't like it, I'm still figuring out what the types should be...)
15:13:00 <merijn> newtype WidgetM s m a = WM { runWM :: RWST Foo () (s, WState) m a } deriving (Functor)
15:13:03 <merijn> type WidgetWire s m a b = Wire () (WidgetM s m) a b
15:14:08 <Cale> lambdazerocool: I didn't find I needed a state monad, but you will definitely want some kind of record of the state that the algorithm is in.
15:14:43 <shachaf> Uh oh.
15:14:44 <shachaf> What happened?
15:14:51 <merijn> I'm not even sure whether I should use this RWST monad for the Wire or whether I should use the mkStateM that's in Control.Wire.Wire
15:14:58 <Cale> lambdazerocool: http://hackage.haskell.org/packages/archive/astar/0.2.1/doc/html/src/Data-Graph-AStar.html -- you can see the AStar type I used here
15:15:21 <shachaf> kappabot: @admin + elliott
15:15:24 <hpc> merijn: that reminds me, i need to write a YMCA monad
15:15:29 <hpc> Y would be Yoneda
15:15:41 * merijn still doesn't know what Yoneda is
15:15:46 <edwardk> that reminds me i should add a best first Fold to lens
15:16:03 <merijn> Clearly I need to drink more whiskey until my types start to make sense...
15:16:21 <shachaf> lambdabot: @admin + shachaf
15:16:21 <lambdabot> Not enough privileges
15:16:25 <shachaf> Hmph.
15:16:36 <shachaf> Cale: You should add lens to lambdabot's Hoogle!
15:16:47 <shachaf> kappabot: @hoogle ^?
15:16:50 <Cale> lambdazerocool: I hacked that module together quickly from a description of the algorithm on wikipedia at one point, but it apparently has had a few users, so it's at least somewhat reliable.
15:16:57 <edwardk> kappabot has been silenced
15:16:58 <shachaf> Oh, +q
15:17:24 --- mode: ChanServ set +o shachaf
15:17:32 --- mode: shachaf set -q kappabot!*@*
15:17:38 <shachaf> kappabot: @part #haskell forever
15:17:40 <Cale> merijn: I'm a little curious as to whether you actually even need the existential, though it's not as simple to remove as some uses of existentials.
15:17:42 --- mode: shachaf set -o shachaf
15:17:56 <lambdazerocool> thanks Cale :D
15:18:02 <merijn> Cale: I'm not sure I need it either :p
15:18:13 <merijn> In fact, I'm not sure of anything...I have no clue what I'm doing :D
15:18:25 <lambdazerocool> Cale: I may tweak it a bit. What I'm actually tampering with is writing my own rubik's cube solver.
15:18:27 <merijn> Actually, the more I look at it, the more this is probably
15:18:31 <merijn> +wrong
15:18:49 <merijn> I think I want "mkStateM :: Monad m => s -> (Time -> (a, s) -> m (Either e b, s)) -> Wire e m a b" instead
15:19:06 <Cale> lambdazerocool: Yeah, feel free to rewrite it if you want the exercise of course :)
15:19:50 <Cale> lambdazerocool: I wrote it as a higher order function taking the graph operations that it would need as parameters, so it is pretty much independent of your choice of graph representation.
15:20:20 <Cale> lambdazerocool: and in fact, if you have no explicit graph representation, that's fine too :)
15:20:22 <shachaf> So fmap's argument is really existential: fmap :: forall f b. Functor f => (exists a. (a -> b, f a)) -> f b
15:20:45 <shachaf> It's just curried.
15:20:48 <Eduard_Munteanu> :t uncurry fmap
15:20:51 <lambdabot> Functor f => (a -> b, f a) -> f b
15:21:05 <shachaf> Well, you have to uncutty the type argument too to get what I wrote. :-)
15:21:17 <Eduard_Munteanu> Hmmm... :)
15:21:25 <shachaf> s/tt/rr/
15:21:30 <merijn> Cale: I don't think it's possible to have a modifiable but hidden state without an existential, though
15:21:35 <lambdazerocool> Cale: yeah, i was looking at that :-P. it was sort of funny, yesterday i was explaining to some undergrads that you can do things like BFS on things that aren't *actually* graphs
15:21:40 <Cale> merijn: it is
15:21:50 <Cale> merijn: You just have your datatype be recursive :)
15:22:03 <lambdazerocool> Cale: for instance, find the minimum number of moves to get X amount of water into this cup given these three cups and a bucket of water -- you just BFS it :D
15:22:23 <merijn> Cale: That's not really convenient in this case, though
15:22:45 <Cale> merijn: and use the datatype itself in place of the hidden existential. You can then write a "constructor" with a function parameter (or many) that consists of the hidden state.
15:22:57 <Cale> Yeah, I don't know whether that would be convenient or not.
15:23:52 <Cale> merijn: But if the only thing we can do with an s' is to get an s from it, then we might as well just use an s
15:24:05 <Cale> Of course, there's also this WidgetWire bit...
15:25:11 <Cale> merijn: and you presumably have some way to run the WidgetWire on the given s'? I'm not sure what the APIs for these things look like.
15:25:43 <Cale> merijn: But depending on how that works, perhaps it's possible to replace that with a WidgetWire () m a b in some fashion?
15:26:28 <Cale> Or else a WidgetWire (Widget ...) m a b
15:26:55 <lispy> Cale: I just disabled swap. Let's see if the performance improves.
15:26:58 <Cale> I don't really know what we're trying to represent with this :)
15:27:01 <Cale> lispy: cool
15:27:26 <lispy> > 1 + 1
15:27:26 <Garyuutensei> Hello! The function 'cellNeighbours' comes up as the mostly costly one in my program, could some check if and how its performance can be increased ( http://hpaste.org/88073 ) :)?
15:27:29 <lambdabot>   2
15:30:52 <merijn> Cale: The widgetwire can work on the s', it just can't expose it directly to the outside work
15:30:55 <merijn> eh, world
15:31:07 <Cale> merijn: right...
15:31:16 <Cale> merijn: hmm
15:31:31 <Cale> yeah, I guess that's a sensible use of an existential
15:31:32 <merijn> Unless the state is projectable, in which case the Wire could run project on it and return that
15:31:48 <merijn> (the trivial case being project = id)
15:32:19 <merijn> I just want to keep the "observable" state of a widget, separate from however it may be implemented
15:32:22 <monochrom> http://www.vex.net/~trebla/haskell/sicp.xhtml#root  new section :)
15:32:40 <merijn> (i.e. a selection box might have a list + index or whatever, but should only return the active selection)
15:33:24 <elliott> monochrom: "cabal install as root is pretty useless in practice" -- unless you pass --global in which case you likely have to run as root?
15:34:03 <monochrom> yes. I think I should amend that.
15:34:59 <cmccann> I thought that in recent versions of cabal, doing global installs causes monochrom to pop out of your computer and lecture you for at least ten minutes about whether you really want to do that.
15:35:35 <Cale> Garyuutensei: hmm...
15:35:52 <Cale> Garyuutensei: what's liftF2?
15:36:27 <enthropy> Cale: it's defined in the where
15:36:34 <Garyuutensei> oh, it's llike liftA2 for the type Vec3 which is an instance of a Functor :P
15:36:52 <Cale> enthropy: no it's not
15:36:53 <enthropy> oh no I'm wrong
15:38:07 <Cale> Garyuutensei: So, fmod takes a pair of Vec3's and mods one out by the other componentwise?
15:38:31 <monochrom> cmccann: I am not Cale :)
15:38:35 <Garyuutensei> Cale: yes, exactly :)
15:38:38 <merijn> Cale: Now that I think about it, I think the entire current approach is doomed anyway, as *all* wires would have to have the same WidgetM monad wrapping them, which is clearly wrong. I should probably use the mkStateM function, but I'm but that has me writing "raw" functions, as opposed being able to neatly compose wires. Blah. I should pick less ambitious hobby projects...
15:38:50 <monochrom> anyway, amended. reload to see.
15:39:31 <Shinka> I'm on Windows and when I tyoe "cabal update", it says a new version of cabal is available and to type "cabal install cabal-install". I do so, it seems to work, but when I tyoe "cabal update" it says, again, to do a "cabal install cabal-install", and cabal is still at version 0.14 (lib: 1.14).
15:39:50 <NetBat> people: What's the job of `scanl' ?
15:39:58 <shachaf> Shinka: Check your PATH.
15:40:05 <hpc> Shinka: yeah, it really does a crap job of telling you what to do
15:40:07 <fryguybob> Shinka: You might want to set your path so that the place where cabal installs binaries is before ghc.
15:40:10 <Cale> NetBat: It's like foldl except that it reports all the intermediate results in a list
15:40:14 <monochrom> I write these web pages so that instead of me popping out to repeat the lecture (what an inefficiency!), the web browser can pop out to display my page.
15:40:14 <shachaf> Shinka: It's probably installing it in ~/.cabal/bin, but you're running something from /usr/bin/
15:40:17 <hpc> Shinka: on linux, you put ~/.cabal/bin on your path and be done with it
15:40:25 <Cale> NetBat: It can be used to compute partial sums like this for instance:
15:40:27 <hpc> not sure where things go on windows
15:40:28 <shachaf> monochrom++
15:40:33 <Cale> > scanl (+) 0 [1..]
15:40:34 <monochrom> w00t shachaf! lambdabot is repaired. please retire kappabot.
15:40:34 <Saizan> monochrom: you should mention that The Right Way, if you want, is cabal install --global --root-cmd=sudo
15:40:37 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
15:40:42 <Eduard_Munteanu> NetBat: last $ scanl ... = foldl ...
15:40:48 <monochrom> oh yikes
15:40:49 <shachaf> monochrom: kappabot is already gone from this channel
15:40:54 <monochrom> oh thanks
15:40:57 --- mode: ChanServ set +o monochrom
15:41:09 <shachaf> The +q is gone too.
15:41:16 <monochrom> haha thanks again
15:41:21 --- mode: monochrom set -o monochrom
15:41:28 <Hafydd> lambdabot is back!
15:41:30 <shachaf> NetBat has an odd way of asking questions...
15:41:37 * Hafydd rushes towards lambdabot, arms outstretched.
15:41:38 <Eduard_Munteanu> @vixen Are you back for good?
15:41:38 <lambdabot> They're not like us. They smell different, they look different, they act different.  The trouble is, you can't find one that's honest.
15:41:41 <shachaf> I think this is the fourth time they joined, asked a question, and left within a couple of minutes.
15:41:44 <Eduard_Munteanu> Aww. :(
15:41:44 <Saizan> monochrom: that way only the installation is run as root
15:41:50 <Eduard_Munteanu> Not mah lambdabot.
15:42:07 <Shinka> hpc: hey! Don't rub it in my face, my Linux laptop died and I'm stuck on Windows for a while :P
15:42:14 <shachaf> lambdabot: Those Italians, eh?
15:42:25 <shachaf> How is it that vixen got removed for being offensive but nixon stayed, again?
15:42:30 <Cale> shachaf: Always trying to steal our Arctic Circle Candy.
15:42:44 <Cale> shachaf: I honestly have no idea.
15:42:45 <merijn> mm_freak: Sorry, but I have Yet Another Question :p
15:42:48 <hpc> Shinka: you could probably try %appdata%/.cabal/bin
15:42:55 <shachaf> Cale: You're the one who does these things.
15:42:59 <hpc> put that on your path somehow
15:43:05 <shachaf> So presumably you should have *some* idea.
15:43:10 <Eduard_Munteanu> At least vixen was popular, funny and horny. @nixon is none :)
15:43:11 <Cale> shachaf: Well, byorgey iirc, and some others complained.
15:43:26 <Shinka> hpc: Yea thanks, I think I'll be able to figure it out now.
15:43:49 <shachaf> Cale: kmc complained that vixen was removed and nixon stayed.
15:43:54 <cmccann> shachaf: because vixen says things that could be mistaken for a real person, not an obvious parody. of course.
15:43:59 <merijn> mm_freak: I had something like http://hpaste.org/88072 but that's not what I want, as that would mean all widgets share the same state (unless I have every wire manually stepWire the ones inside it, which seems wrong?)
15:44:02 <shachaf> Now nixon is still here, but kmc is gone.
15:44:22 <Eduard_Munteanu> We can make a @kmc to remind us of him.
15:44:24 <cmccann> shachaf: clearly lambdabot needs @kmc instead.
15:44:28 <cmccann> dammit
15:44:30 <Eduard_Munteanu> :D
15:44:39 <Cale> Hey, where is kmc anyway?
15:44:51 <Saizan> you could just make it react to "trivial" or "C++"
15:44:52 <cmccann> he broke up with #haskell or something I guess.
15:44:53 <Eduard_Munteanu> He's around, on Freenode... just not here for some reason.
15:45:01 <Saizan> it'd be quite realistic
15:45:11 <Eduard_Munteanu> Last I asked he said he still reads the logs of #haskell sometimes.
15:45:19 <cmccann> anyway, I hear edwardk knows all about making bots imitate people, I bet he could write a @kmc plugin for us!
15:45:31 <merijn> mm_freak: Now mkStateM does the right thing, but unfortunately that means I have to manually write the "Time -> (a, s) -> m (Either e b, s)", which makes it hard to use any of the predefined wires in there?
15:45:38 <Eduard_Munteanu> Saizan: heh, or go ballistic at the sight of "C/C++"
15:45:58 <haasn> kmc markov chains
15:46:02 <merijn> mm_freak: Am I missing some obvious approach that lets me use a "hidden" state, while still letting me use the existing wires internally?
15:48:38 <Eduard_Munteanu> Actually, an @edwardk bot would also be appropriate... just generate lots of (bogus) updates for (bogus) Hackage packages. :)
15:48:50 <applicative_> hm, what became of kmc, I don't get rudely 'corrected' enough ...
15:49:30 * applicative_ thought they were all real updates of real packages, adding imaginary ones turns out not to be necessary
15:49:53 <Eduard_Munteanu> Hm, you're right. :)
15:50:08 <monochrom> http://www.vex.net/~trebla/haskell/sicp.xhtml#root  updated
15:50:32 <Eduard_Munteanu> Woo, a lolcat
15:50:51 <Eduard_Munteanu> Ah, typoclass. :)
15:50:55 <monochrom> oh, the lolcat is for another section
15:52:01 <yitz> shachaf: for the record, i also complained that vixen was removed
15:52:19 <applicative_> hm, another hackage/cpan/... attempt for ocaml. looks pretty good. http://opam.ocamlpro.com/index.html it integrates 'state-of-the-art dependency management technologies'
15:52:24 <Eduard_Munteanu> I think byorgey complained about vixen and Cale removed it, actually.
15:52:31 <Eduard_Munteanu> Maybe I misremember.
15:52:40 <Cale> Eduard_Munteanu: that's vaguely what I remember too
15:52:52 <applicative_> vixen wasn't as bad as it seemed to corrupt minded people.
15:52:53 <Cale> A fair number of people were in agreement with him at the time
15:52:56 <shachaf> My main complaint is that kmc was removed.
15:53:04 <Eduard_Munteanu> Yeah. :(
15:53:13 <applicative_> what became of kmc?
15:53:19 <applicative_> enough of haskell?
15:53:25 <shachaf> enough of #haskell
15:53:32 <yitz> i think it would have been much better to ask byorgey to list specific responses that were offensive (yes there were some of those) and just remove/replace those
15:53:38 <monochrom> byorgey's last words on the matter: "what have I done?"
15:53:40 <shachaf> People leaving is the hidden cost of the channel not being a pleasant place for whatever reason.
15:53:50 <applicative_> ah, then no great loss
15:53:52 <shachaf> Well, that and people being unhappy. But sometimes people are so unhappy that they leave.
15:53:54 <yitz> kmc is visiting mmorrow
15:54:09 <shachaf> kmc is on Freenode.
15:54:13 <Eduard_Munteanu> Aww.
15:54:20 <Eduard_Munteanu> preflex: xseen mmorrow
15:54:20 <preflex>  mmorrow was last seen on freenode/#ghc 3 years, 119 days, 19 hours, 56 minutes and 50 seconds ago, saying: * mmorrow is rtfm'ing
15:54:27 <Eduard_Munteanu> preflex: xseen kmc
15:54:27 <preflex>  kmc was last seen on freenode 353 days, 15 hours, 31 minutes and 50 seconds ago, saying: <private message>
15:54:32 <cmccann> that's a long time to be rtfm'ing.
15:54:35 <Eduard_Munteanu> Hm, I see a pattern.
15:54:35 * applicative_ is trying to penetrate shachaf 's last remark.
15:54:45 <shachaf> Never mind my remarks.
15:55:15 <applicative_> Oh, I never do.
15:55:16 <cmccann> you should definitely remind his marks though.
15:56:04 <merijn> ok, I give up for the night...
15:56:57 <applicative_> hm, but it seems the thought is that kmc was hurt somehow by the channel; that would be irksome.
15:57:08 <Eduard_Munteanu> merijn was last seen on freenode 1218 days, 11 hours, 1 minutes and 20 seconds ago, saying: ok, I give up for the night...
15:57:31 <Eduard_Munteanu> I hope that doesn't fit the pattern.
15:57:36 * applicative_ misses merijn
15:57:43 <Eduard_Munteanu> Yeah, I do too already.
15:57:44 <haasn> last message in my logs: 2012-02-02 03:20:23 kmc i don't really want #haskell to consist of people typing in LYAH one sentence at a time
15:57:57 <Eduard_Munteanu> Wow.
15:58:19 <zenware> Wow, people have been in this channel from 4 years ago?
15:58:28 <monochrom> I have a cunning plan
15:58:40 <haasn> it is an old channel
15:58:51 <applicative_> hm. yes, that attitude rings a bit of a bell.  the unrelenting repetitiousness of tutoring isn't for everyone.
15:58:51 <Eduard_Munteanu> A lot older than 4 years.
15:58:56 <merijn> Eduard_Munteanu: Well, I meant with solving my problem :p
15:59:08 <yitz> zenware: yes, but most of them do take off a few hours to sleep every once in a while
15:59:38 <haasn> applicative_: every time you teach the basics, there's one more person to share the excitement with
16:00:23 <Eduard_Munteanu> If it's problematic, that's more often the case on web forums, I'd say.
16:00:39 <heath> i'm trying to produce something equivalent in haskell of this: https://gist.github.com/heath/5595762 ..here's what i got so far: https://gist.github.com/heath/5595762
16:00:48 <applicative_> haasn: yes.
16:01:07 * hackagebot taglib-api 0.1.0.0 - A convenient layer over TagLib's C bindings  http://hackage.haskell.org/package/taglib-api-0.1.0.0 (KyleCarter)
16:01:12 <haasn> heath: I think you pasted that twice
16:01:16 <monochrom> http://www.vex.net/~trebla/haskell/siCp.xhtml  hehehe!
16:01:28 <applicative_> no way that type checks heath !
16:02:04 <heath> oops, yeah https://gist.github.com/heath/5585863/44e98124e4d08887c15054cb452bdb98c454cca2
16:02:24 <heath> that uses tail recursion which is going to cause python to crash
16:02:30 <haasn> but so what does it to? I'm too tired to decipher an alien language :(
16:02:36 <haasn> it do*
16:02:56 <elliott> monochrom: good page
16:03:09 <heath> i've read that incrementing a number is not the way to think in haskell... i'm wondering what the best way is for thinking about the haskell version of the go_monkey_go function
16:03:21 <elliott> monochrom: typo "sudo caball install"
16:03:30 <monochrom> yikes
16:03:31 <elliott> monochrom: (recognised by "COBOLl" on the siCp page)
16:03:39 <monochrom> haha
16:04:10 <haasn> oh so the only change is s/cabal/COBOL/g? How boring, I was expecting something more witty :(
16:04:36 <monochrom> isn't "COBOL install" witty enough? :)
16:04:48 <haasn> COBOL install cabal-install
16:05:13 <Eduard_Munteanu> What is that?
16:05:23 <Eduard_Munteanu> Isn't it that ancient PL they call cabal?
16:05:50 <monochrom> hi, I want to learn COBOL by solving project euler
16:05:56 <haasn> I prefer http://www.yesodweb.com/blog/2012/04/replacing-cabal
16:06:19 <Eduard_Munteanu> Hah, 'cabala'.
16:06:23 <applicative_> monochrom: sounds like an excellent plan
16:06:56 <applicative_> 'cabala receive pony'
16:07:10 <haasn> “Cabal instead has the audacity to try and build the code it receives, perverting it into something else!”
16:07:14 <haasn> yuck, how side-effectuous
16:07:34 <yitz> someone needs to photoshop that lambda cat to say "cobol"
16:08:15 <Eduard_Munteanu> We should also s/mutation/perversion/
16:09:06 <Eduard_Munteanu> STArray - Pervert arrays in the ST monad
16:09:57 <haasn> s/side effect/ ...
16:10:45 <Eduard_Munteanu> para-effect?
16:11:00 <Eduard_Munteanu> (analogous to paraphilia :P)
16:11:34 <haasn> rape/g
16:11:51 <shachaf> OK, I think this is enough.
16:12:09 <Eduard_Munteanu> Fortunately those get locked up in IO monads.
16:26:04 <applicative_> hm, yet another haskellizing startup ...' just emerging from stealth mode' ...?  they are certainly coming thicker and faster these days, for what it may be worth. http://www.alephcloud.com/
16:26:54 * applicative_ will have to brush up on his 'mongo db'
16:27:37 <blackdog> applicative_: it's exciting, no?
16:27:53 <applicative_> blackdog: yes, of course
16:28:12 * blackdog has his own haskell startup on the burner :)
16:28:28 <blackdog> but i think it's becoming more plausible - the tools are there now.
16:28:29 <applicative_> am I hallucinating, or does it seem plain there's more activity like that than in the past or past-that-I-can-remember
16:28:34 <blackdog> heaps more.
16:28:58 <blackdog> then again, i'm at lambdajam right now, so i might just be drinking the kool-aid :)
16:29:04 <applicative_> ha
16:29:55 <applicative_> just the other day there was something about to do with 'fusion'  in Cambridge
16:30:05 <applicative_> i mean, nuclear fusion
16:30:38 <acowley> If you fuse fusion then you don't produce waste?
16:32:50 <applicative_> it must have a peaceful purpose since the fusion gizmo has all-european funding.  maybe that doesn;t follow.
16:32:57 <applicative_> you cant go wrong with 'Dr. pr. Sean Leather, Team Leader, Specialist Developer'
16:33:14 <acowley> Such a tease when I discover I already have a git repo for something I'm starting to work on, think I've already written the code, and then find the repo just has one source file with some notes.
16:35:45 <enigmuriatic> how bearable is using Haskell on FreeBSD? do the packages work okay?
16:36:21 <applicative_> what packages do you need besides the ghc + boot packages + cabal - install?
16:37:11 * applicative_ uses UnFreeBSD aka os x
16:37:42 <enigmuriatic> so do i, mostly
16:37:51 <enigmuriatic> the packages are pretty unbearable though
16:37:58 <enigmuriatic> i like my apt-get
16:38:00 <acowley> Why do you need any packages?
16:38:10 <enigmuriatic> graphics etc
16:38:16 <enigmuriatic> acowley
16:38:34 <acowley> I meant Haskell packages. You're right you need some things from your PM.
16:38:37 <applicative_> enigmuriatic: I would just handle all the haskell stuff myself , no?  there's a bindist here http://www.haskell.org/ghc/download_ghc_7_6_3#freebsd
16:38:37 <yitz> enigmuriatic: is there a binary ghc tarball for a recent ghc? if so, it should be no problem.
16:39:23 <applicative_> enigmuriatic: yes, graphics things can be difficult to get linked to the c nonsense.  Somehow I dont have trouble anymore though.
16:39:39 <acowley> Like what? GLFW?
16:40:09 <applicative_> enigmuriatic: have you seen monochrom 's page on locally installing ghc + haskell platform libs?
16:42:53 <applicative_> oh here http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
16:44:09 <applicative_> enigmuriatic: so this lists the stuff youd need from the freebsd package manager for the graphics business that come with the Haskell Platform
16:52:03 <applicative_> oh yeah, here's the haskellizing fusion people http://www.functor.se/careers/openings/
17:43:19 <xerbrezers> Type of trie data Trie a = TrieNode (Maybe a) [(Char, Trie a)] deriving Show I want to write a function that takes in a key-value pair and a prefix tree. I then want it to return the symbol table where the key-value pair is included. If the key already exists the new value should replace the old one.
17:43:39 <xerbrezers> Example: trieInsert ("abc",10) emptyTrie-> TrieNode Nothing[('a', TrieNode Nothing[('a',TrieNode Nothing[('c',Trie_TrieNode(Just 10)[])])])]
17:44:16 <xerbrezers> I also want to be able to search in the tree and find keys that start with a certain prefix.  Example: findTree "c" oneTree -> ["at","in"] findTree "ca" oneTree -> ["z","r"]
17:47:40 <Cale> xerbrezers: okay
17:48:36 <xerbrezers> Oops, wrong channel.
17:50:06 <xerbrezers> Question: How do you differentiate a type name, and its constructor's name? I know there are many different styles, but which do you prefer? In one place, I see this: data AccountInfo = Account String String Integer Bool  data AccountTableInfo = AccountTable String [AccountInfo]
17:50:32 <xerbrezers> Other places claim you shouldn't bother making them different because there's never an ambiguity between using the constructors and applying the type in a type signature. So they say the constructor and type should be called the same thing.
17:50:39 <xerbrezers> Your style?
17:50:49 <geekosaur> this is a bit of an editor war type thing
17:51:11 <Cale> If there's only one constructor, I'll often name it the same thing, or as some abbreviation of the type name
17:51:33 <Cale> (if I'm not exporting it, it's okay to give it a much shorter name)
17:52:39 <Cale> If I'm *discussing* the construction of the code with someone reasonably new to Haskell on IRC, I'll usually make sure to name them differently, just so that when I'm talking about things it's completely clear what I'm referring to.
17:54:10 <lispy> Cale: are we having some netsplits, because I can't find the context of your comment about naming things.
17:54:15 <geekosaur> I personally lean somewhat toward naming them differently; sure, the compiler can keep them straight, but when possible it's better to write code for a *human* reader, and human readers may have a harder time keeping them straight
17:54:25 <Cale> lispy: yes, we are, I think
17:54:34 <geekosaur> netjoins, actually; the splits happened earlier
17:54:50 <Cale> lispy: xerbrezers asked about the practice of naming type and data constructors the same way
17:54:57 <Aetherspawn> is it possible to do a local enumerator data constructor thing
17:55:02 <geekosaur> but the context os now several hundred lines back if you don't hide joins/parts :)
17:55:03 <lispy> ah
17:55:15 <lispy> > 1 + 1
17:55:17 <Aetherspawn> Let's say I want to do data Something = Pair (t, bool) where t = A | B | C ..
17:55:17 <lambdabot>   2
17:55:45 <Cale> Aetherspawn: no, though people have considered that feature
17:55:51 <Aetherspawn> Damn.
17:55:55 <zRecursive> lambdabot: are you alive now ?
17:55:57 <Aetherspawn> I can't hack it with GADT's or something?
17:56:05 <Cale> Aetherspawn: You can just define the enumeration type separately, and not export it from your module.
17:56:12 <t3nsor> Hey guys, I finally managed to get lambdabot+mueval to work
17:56:14 <lispy> You could use some of the new extensions to make it so that only certain things go in that hole, but it's probably pretty heavy handed
17:56:20 <Aetherspawn> mhm it'll be hard giving it a name :P
17:56:23 <Aetherspawn> but thanks.
17:56:26 <t3nsor> But I still have some trouble with irc
17:56:42 <t3nsor> It seems like it fails to join channels, and I assume it's because it sends the join command too early
17:56:48 <t3nsor> Is there a way to introduce a delay perhaps?
17:57:07 <Cale> t3nsor: weird, I don't think I've ever seen that happen
17:57:23 <t3nsor> Cale: Maybe I'm misdiagnosing the problem, h/o
18:04:34 <acfoltzer> hmm, can one really not ask fgl for the postdominators of a node?
18:09:42 <Aetherspawn> Is there a way to pull a bit out of a Word8 as a Bool?
18:10:24 <Aetherspawn> /s/way/shortcut
18:10:40 <shachaf> Yes.
18:10:48 <shachaf> It's in the Data.Bits documentation somewhere.
18:10:52 <Aetherspawn> thanks
18:11:20 <Aetherspawn> testBit is the one
18:14:18 <Aetherspawn> @pl (\x -> testBit x 3)
18:14:18 <lambdabot> flip testBit 3
18:14:37 <shachaf> @ty (^. bitAt 3)
18:14:40 <lambdabot> Bits s => s -> Bool
18:14:55 <Aetherspawn> Oh, that's cooler
18:16:15 <shachaf> It also uses lens. Not just base.
18:27:02 <Aetherspawn> Ick, I can't seem to find traverseBits
18:27:45 <shachaf> It's called "bits" now.
18:28:21 <Aetherspawn> Oh
18:29:13 <cmccann> shachaf: is there a lens to traverse the unary digits of a number, too?
18:29:49 <shachaf> replicated hth
18:29:51 <shachaf> (No.)
18:32:50 <cmccann> > "1111" ^? base 1
18:32:53 <lambdabot>   *Exception: base: Invalid base 1
18:32:54 <cmccann> lame!
18:33:02 <Aetherspawn> Where does toListOf come from?
18:33:42 <Aetherspawn> nvm hoogle
18:34:18 <Aetherspawn> un-nvm hoogle, it can't find it.
18:34:45 <shachaf> It's in lens.
18:34:51 <shachaf> Normal Hoogle doesn't search lens.
18:34:57 <geekosaur> hayoo is your friend
18:35:04 <Aetherspawn> ah, thanks.
18:35:12 <geekosaur> http://holumbus.fh-wedel.de/hayoo/hayoo.html
18:36:45 <blackdog> anyone else noticed that ghc-mod check appears to do something a bit weird with newlines?
18:37:14 <shachaf> Cale: Could you add lens to lambdabot @hoogle?
18:38:57 <Cale> shachaf: hau do?
18:39:52 <shachaf> Cale: Uh, something like: hoogle data lens; cd ~/.cabal/share/i386-linux-ghc-7.4.2/hoogle-4.2.16/databases/; hoogle combine lens.hoo
18:39:55 <shachaf> Or something.
18:40:01 <shachaf> I don't know, I made it work with kappabot somehow.
18:41:32 <shachaf> Oops.
18:41:36 <Cale> ?
18:41:38 <shachaf> I think I have *only* lens results in Hoogle now.
18:41:42 <Cale> heh
18:41:46 <shachaf> I guess I should've done hoogle combine default.hoo lens.hoo
18:41:47 <shachaf> Or something.
18:41:55 <Cale> @hoogle a -> a -> a
18:41:55 <lambdabot> Prelude asTypeOf :: a -> a -> a
18:41:56 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
18:41:56 <lambdabot> Prelude atan2 :: RealFloat a => a -> a -> a
18:42:00 <cmccann> shachaf: do you actually need/use anything else, though?
18:42:06 <cmccann> sounds like a feature, not a bug.
18:42:11 <shachaf> cmccann: lens doesnt't reëxport unsafeCoerce
18:42:13 <Cale> I don't have a lens.hoo
18:42:16 <shachaf> ...Well, not on purpose.
18:42:19 <edwardk> this is a subtle advertising ploy i think
18:42:22 <shachaf> Cale: Even after running hoogle data lens?
18:42:24 <Cale> even after running that first command
18:42:25 <Cale> yeah
18:42:30 <shachaf> Hmm.
18:42:34 <shachaf> Did the first command succeed?
18:42:36 <Cale> Starting lens
18:42:37 <Cale> Warning: lens couldn't find both Cabal and Haddock inputs
18:42:37 <Cale> Finished lens
18:42:37 <Cale> Warning: lens couldn't find both Cabal and Haddock inputs
18:42:37 <Cale> Data generation complete
18:42:44 <shachaf> I had to do a little hunting down to make it work.
18:43:02 <shachaf> (In particular I straced hoogle to figure out what it was doing.)
18:43:12 <shachaf> (But you can use your own debugging methods. Such as reading the documentation.)
18:44:23 <shachaf> And obviously I didn't completely figure it out.
18:44:34 <shachaf> So you should do your own investigating regardless.
18:44:47 <Aetherspawn> hmm
18:45:08 <cmccann> just try random things until it works.
18:45:12 <cmccann> that's always a good approach.
18:45:17 <Aetherspawn> ^
18:45:58 <Nisstyre> cmccann: the monte carlo method of debugging
18:46:44 <cmccann> stochastic maintenance
18:48:48 <Aetherspawn> > shift
18:48:50 <lambdabot>   Ambiguous type variable `a0' in the constraint:
18:48:50 <lambdabot>    (Data.Bits.Bits a0) aris...
18:48:54 <Aetherspawn> Oh good, it has it.
18:49:19 <Aetherspawn> > shift (3 :: Word8) 6
18:49:21 <lambdabot>   192
18:49:45 <Aetherspawn> > shift (3 :: Word8) -6
18:49:48 <lambdabot>   *Exception: show: No overloading for function
18:50:28 <geekosaur> parens
18:50:35 <cmears> > shift (3 :: Word8) (-6)
18:50:37 <lambdabot>   0
18:51:44 <Aetherspawn> > rotateL (shiftL (3 :: Word8) 6) 2
18:51:46 <lambdabot>   3
18:52:12 <Aetherspawn> > map [1..20] (\x -> rotateL (shiftL (x :: Word8) 6) 2
18:52:13 <lambdabot>   <hint>:1:53: parse error (possibly incorrect indentation)
18:52:18 <Aetherspawn> > map [1..20] (\x -> rotateL (shiftL (x :: Word8) 6) 2)
18:52:19 <lambdabot>   Couldn't match expected type `a0 -> b0' with actual type `[t0]'
18:52:26 <Aetherspawn> Ugh, I'm sory.
18:52:39 <Aetherspawn> > map (\x -> rotateL (shiftL (x :: Word8) 6) 2) [1..20]
18:52:41 <lambdabot>   [1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0]
18:53:26 <Aetherspawn> @pl (\x -> rotateL (shiftL (x :: Word8) 6) 2)
18:53:26 <lambdabot> flip rotateL 2 . flip shiftL 6 . (:: Word8)
18:53:36 <shachaf> good section
18:53:48 <Aetherspawn> Hmm?
18:54:10 <geekosaur> the @pl stuff doesn't know haskell (it just matches patterns) and thinks :: is an operator
18:54:24 <Aetherspawn> Ah.
18:54:28 <Aetherspawn> @pl (\x -> rotateL (shiftL (x) 6) 2)
18:54:28 <lambdabot> flip rotateL 2 . flip shiftL 6
18:54:43 <cmccann> operator sections of (::) sound useful.
18:54:48 <cmccann> that should be a language extension.
18:54:53 <shachaf> Especially left sections.
18:55:10 <Aetherspawn> Oh joy
18:55:14 <Aetherspawn> I invented a haskell extension.
18:55:17 <shachaf> Anyway I've proposed that before.
18:55:56 <cmccann> sections of = and <- would be nice while we're at it.
18:57:55 <elliott> how about a section of (->)
18:58:00 <elliott> (\x ->) x
18:58:13 <shachaf> (->) (\x) (x)
18:58:22 <cmccann> oh, that ->. I was gonna say, that's too boring if you mean the function type constructor.
18:58:59 <elliott> let x = 2; f = (\-> x*2) x in f x
18:59:01 <elliott> let x = 2; f = (\-> x*2) _ in f x
18:59:03 <elliott> guess the results
18:59:10 <elliott> er.
18:59:12 <elliott> don't because they're identical.
18:59:18 <shachaf> let foo a b = (\a -> b)
18:59:26 <shachaf> join foo :: a -> a
18:59:48 <elliott> help.
19:00:25 <cmccann> I think the \ needs to stay with the a, not be added by the -> expression.
19:00:54 <cmccann> that is, "a" should be in contravariant position no matter where it's used for that to make sense.
19:01:07 <cmccann> so that means the first argument of foo must be in covariant position of course.
19:01:16 <cmccann> this is all entirely sensible I'm sure.
19:01:21 <shachaf> cmccann: Don't bring sense into this.
19:02:25 <cmccann> anyway, more fun is if you pattern match on the lambda instead.
19:03:26 <shachaf> case case x of Foo y -> y + y of case e of p -> r -> e
19:03:28 <dmwit> It ought to be possible to write "case f of (\_ -> _) -> ..." as an alternative to seq.
19:03:46 <cmccann> dmwit: ooh, good idea.
19:03:48 <cmccann> I like it.
19:03:57 <shachaf> is my thing followable
19:04:06 <elliott> if by followable you mean ...
19:04:13 <cmccann> shachaf: parse error at location everything
19:04:18 <jmcarthur> higher order unification would be pretty nice at least
19:04:23 <jmcarthur> :)
19:04:31 <shachaf> cmccann: case (case x of Foo y -> y + y) of (case e of p -> r) -> e
19:04:43 <shachaf> It should evaluate to x.
19:05:05 <jmcarthur> > case (case x of Foo y -> y + y) of (case e of p -> r) -> e
19:05:08 <lambdabot>   <hint>:1:37: Parse error in pattern: case e of { p -> r }
19:05:09 <jmcarthur> oh Foo
19:05:22 <shachaf> jmcarthur: Foo, and also the fact that the whole thing is made up nonsense syntax.
19:05:42 <cmccann> it probably makes more sense than you'd hope.
19:05:44 <jmcarthur> i didn't even pay attention to the parens
19:06:11 <cmccann> not very respectful of extensionality though.
19:06:15 <jmcarthur> okay so i'm going to scroll up and actually read
19:06:28 <shachaf> jmcarthur: Not sure how much you'll gain from that, but OK...
19:06:41 <cmccann> whereas "pattern matching" on a "lambda" would just separate the arguments from the body.
19:06:43 <jmcarthur> i have no context
19:06:49 <elliott> cmccann: I like petty concerns like that when you're dealing with seq
19:07:32 <jmcarthur> :\ i have no idea what we're talking about
19:07:45 <dmwit> We are joking about ridiculous syntax.
19:07:49 <cmccann> jmcarthur: we're treating nonsense as if it were reasonable, and discussing the consequences.
19:07:53 <dmwit> This is, after all, #haskell.
19:08:03 <jmcarthur> ah then i *do* understand
19:09:22 <elliott> cmccann: that's two good descriptions of IRC in as many days.
19:09:32 <jmcarthur> or mathematics
19:12:00 <Aetherspawn> @pl (\x -> GameMode (decodePlayerMode pm, hardcore))
19:12:00 <lambdabot> const (GameMode (decodePlayerMode pm, hardcore))
19:12:20 <Aetherspawn> @pl (\x -> GameMode (decodePlayerMode $ pm x, hardcore))
19:12:20 <lambdabot> GameMode . flip (,) hardcore . decodePlayerMode . pm
19:12:28 <Aetherspawn> eeew. I'm fine.
19:12:46 <dmwit> GameMode . (,hardcore) . decodePlayerMode . pm
19:13:31 <Aetherspawn> yeah, still wont make sense to me in like 2 weeks
19:13:33 <Aetherspawn> so I'll leave it as-is.
19:13:48 <dmwit> Future Aetherspawn thanks you.
19:13:52 <Aetherspawn> lol
19:14:04 <jmcarthur> apply pm, then apply decodePlayerMode, then apply (,hardcore), then apply GameMode
19:14:11 <jmcarthur> :)
19:14:54 <jmcarthur> except in reverse. apply GameMode to the result of applying (,hardcore) to the result of applying decodePlayerMode to the result of applying pm
19:16:32 <dmwit> ?let (f ⠄ g) x = g (f x)
19:16:34 <Aetherspawn> Is there something which either does clearBit or setBit depending on a bit # and a bool?
19:16:36 <lambdabot>  Defined.
19:16:56 <dmwit> > (+1) ⠄ (*10) $ 30
19:16:56 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
19:17:02 <dmwit> oh bah
19:17:04 <cmccann> elliott: lem f@(\a -> b) = let _ = f (Left . flip (->) _ $ (\a)) in Right b
19:17:33 <dmwit> Aetherspawn: xor
19:17:35 <cmccann> elliott: if you don't have a headache you aren't thinking about it hard enough
19:17:39 <dmwit> :t xor
19:17:41 <lambdabot> Bits a => a -> a -> a
19:17:48 <dmwit> > xor 15 (bit 3)
19:17:50 <lambdabot>   7
19:17:52 <dmwit> > xor 7 (bit 3)
19:17:54 <lambdabot>   15
19:18:07 <dmwit> Or perhaps I misunderstood.
19:18:11 <shachaf> @slap cmccann
19:18:11 <lambdabot> I won't; I want to go get some cookies instead.
19:18:13 <Aetherspawn> Except I have whether the bit should be set or not in a Bool
19:18:13 <cmccann> elliott: wait hm I think I forgot an application of f at the end
19:18:17 <Aetherspawn> :P
19:18:21 <cmccann> anyway you get the idea.
19:18:30 <elliott> cmccann: no. no I don't.
19:18:31 <cmccann> shachaf: pf.
19:18:41 <dmwit> Aetherspawn: if myBool then set else clear
19:18:48 <cmccann> elliott: imo you do, hth. </shachaf>
19:18:58 <dmwit> :t set
19:18:59 <lambdabot> ASetter s t a b -> b -> s -> t
19:19:03 <dmwit> not that one
19:19:16 <dmwit> :t setBit
19:19:18 <lambdabot> Bits a => a -> Int -> a
19:19:27 <dmwit> :t \b -> if b then setBit else clearBit
19:19:29 <lambdabot> Bits a => Bool -> a -> Int -> a
19:19:48 <Aetherspawn> :t id
19:19:50 <lambdabot> a -> a
19:20:07 <shachaf> cmccann: You should be glad that I've spared you from a "case"y pun.
19:20:30 <cmccann> those are pretty stale for me.
19:20:43 <cmccann> the novelty long since wore off.
19:20:49 <acowley> Is anyone working on targeting the Ouya with GHC?
19:23:26 <Aetherspawn> @pl (\b -> if b then flip setBit 3 else id)
19:23:27 <lambdabot> flip (flip if' (flip setBit 3)) id
19:23:37 <Aetherspawn> Is there a lambdabot reduction command?
19:24:09 <dmwit> reduction?
19:24:50 <shachaf> There is a lambdabot reduction command, but it's still beta.
19:24:52 <Aetherspawn> Like, to look through the source of prelude (or something like that)
19:24:58 <Aetherspawn> and to find a better function
19:25:15 <dmwit> There is ?src for the former and ?hoogle for the latter.
19:25:24 <Aetherspawn> both at once :P
19:25:43 <dmwit> I still don't really understand what it is you want.
19:25:48 <pqmodn> is there a consensus about isolating dependencies, what's the difference between hsenv and virthualenv? is something else more widely used?
19:26:21 <geekosaur> virthualenv is the old version of hsenv
19:26:22 <cmccann> we need an "unreinvent wheels" command that works like @pl except it replaces expressions with equivalent standard library functions.
19:26:38 <acowley> I use #haskell-lens for that
19:26:41 <acowley> they've got lots of wheels
19:26:41 <pqmodn> geekosaur: ok, thanks
19:26:43 <Aetherspawn> dmwit, let's say I want to reduce something like
19:27:10 <Aetherspawn> return . whatever <<= whatever2
19:27:19 <cmccann> acowley: that's more like superconducting maglev instead of wheels
19:27:22 <Aetherspawn> the command I'm describing would (I think) find liftM and do it for me
19:27:39 <geekosaur> hlint does some of that
19:27:41 <Aetherspawn> /s/<<=/=<<
19:27:42 <cmears> pl does that
19:27:50 <cmears> @pl return . whatever =<< whatever2
19:27:50 <lambdabot> whatever `fmap` whatever2
19:27:58 <acowley> cmccann: As long as it gets me from a to b
19:27:59 <cmccann> yeah, hlint does a few, and so does pl (in a very limited way)
19:28:02 <geekosaur> well, doesn't do it for you, but an IDE could make use of its output
19:28:06 <cmccann> neither is really sufficient though
19:28:35 <dmwit> :t \a b -> ?f (return . a) b
19:28:37 <lambdabot> (?f::(a -> m b) -> t1 -> t, Monad m) => (a -> b) -> t1 -> t
19:28:50 <dmwit> ?hoogle Monad m => (a -> m b) -> t1 -> t
19:28:51 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
19:28:51 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
19:28:51 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
19:29:13 <dmwit> That didn't work amazingly well.
19:29:34 <dmwit> ...this is because I made the wrong query, of course.
19:29:47 <dmwit> :t return . ?a =<< ?b
19:29:48 <lambdabot> (?a::a -> b, ?b::m a, Monad m) => m b
19:30:02 <dmwit> ?hoogle Monad m => (a -> b) -> m a -> m b
19:30:02 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
19:30:02 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
19:30:03 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
19:30:13 <dmwit> There we go. See? hoogle already does it =)
19:31:57 <Aetherspawn> hm
19:32:29 <Aetherspawn> But it requires you to understand all the underlying types
19:32:33 <Aetherspawn> and i'm just a beginner :)
19:36:09 <dmwit> No understanding. Just put ? on your holes, then turn the ? types into arguments.
19:36:12 <Aetherspawn> Raising an opinion here that there should be a function Bool -> (a->b) -> (a->b)
19:36:31 <Aetherspawn> defined as if b then f else id
19:36:34 <dmwit> ?djinn Bool -> (a -> b) -> (a -> b)
19:36:34 <lambdabot> f a b =
19:36:35 <lambdabot>     case a of
19:36:35 <lambdabot>     False -> b
19:36:35 <lambdabot>     True -> b
19:36:48 <dmwit> Aetherspawn: \b f -> if b then f else id does not have that type.
19:36:54 <tromp> id is not a->b
19:36:59 <pqmodn> dmwit: does that require ImplicitParams, or is it part of something else?
19:37:01 <Aetherspawn> well, then im stupid. :\
19:37:06 <Aetherspawn> But you get the idea.
19:37:09 <dmwit> pqmodn: Yes, it's ImplicitParams.
19:37:15 <Aetherspawn> And please point me towards a function like that if it exists :)
19:37:15 <cmccann> \b f -> if b then f else unsafeCoerce
19:37:17 <cmccann> problem solved!
19:37:18 <pqmodn> dmwit: very cool, thanks :)
19:37:27 <dmwit> :t \b f -> foldr (.) id [f | b]
19:37:30 <lambdabot> Bool -> (b -> b) -> b -> b
19:37:54 <Aetherspawn> Oh, oops!
19:38:00 <Aetherspawn> make them all b->b and my sig is right again
19:38:18 <Aetherspawn> @pl (\b f -> foldr (.) id [f | b])
19:38:18 <lambdabot> (foldr (.) id .) . flip flip [] . ((:) .) . flip (|)
19:38:23 <Aetherspawn> lold.
19:38:48 <cmccann> there's probably a very concise version of this in terms of the Endo monoid and some other stuff that would be ten times longer to write because of newtype cruft.
19:38:55 <dmwit> :t \b f x -> iterate f x !! fromEnum b
19:38:57 <lambdabot> Enum a1 => a1 -> (a -> a) -> a -> a
19:39:03 <Cale> Aetherspawn: @pl doesn't understand list comprehensions
19:39:07 <dmwit> cmccann: Yes, it's mconcat [f | b]
19:39:10 <Cale> @undo [f | b]
19:39:10 <lambdabot> if b then [f] else []
19:39:12 <dmwit> plus newtype cruft
19:39:22 <cmccann> dmwit: ah yes of course
19:39:32 <Aetherspawn> OOOHHH
19:39:34 <Aetherspawn> I get it.
19:39:39 <Aetherspawn> [f | b] is trickery
19:39:39 <dmwit> cmccann: ...which is why I spelled mconcat as foldr (.) id instead. ;-)
19:39:52 <cmccann> dmwit: yes suddenly I understand everything
19:40:00 <dmwit> nirvana
19:40:08 <Cale> Aetherspawn: I really like using list comprehensions of that sort when adding elements to a list conditionally on an individual basis.
19:40:13 <Aetherspawn> :t foldr
19:40:16 <lambdabot> (a -> b -> b) -> b -> [a] -> b
19:40:30 <dmwit> > fromEnum False
19:40:32 <lambdabot>   0
19:40:34 <dmwit> perfect
19:40:36 <dmwit> by accident
19:41:05 <dmwit> ?pl \b f x -> iterate f x !! fromEnum b
19:41:05 <lambdabot> flip (flip . ((!!) .) . iterate) . fromEnum
19:41:09 <dmwit> SHIP IT
19:41:30 <dmwit> ?pl \f x b -> iterate f x !! fromEnum b
19:41:31 <lambdabot> flip flip fromEnum . (((.) . (!!)) .) . iterate
19:42:11 <dmwit> Proposal: an extension to ?pl that tries all permutations of argument order and picks the shortest result.
19:42:11 <cmccann> that (!!) is very emphatic. quite persuasive.
19:42:25 <cmccann> proposal: dmwit writes that extension.
19:42:53 <dmwit> proposal: dmwit writes the proposal for the extension
19:43:50 <cmccann> hm.
19:43:57 <cmccann> let's have shachaf write the extension instead.
19:44:03 <cmccann> he's clearly an expert on lambdabot now.
19:44:47 <Aetherspawn> :t ap
19:44:49 <lambdabot> Monad m => m (a -> b) -> m a -> m b
19:44:50 <Aetherspawn> @src ap
19:44:50 <lambdabot> ap = liftM2 id
19:45:06 <Aetherspawn> @pl (\a b -> a . b)
19:45:06 <lambdabot> (.)
19:45:22 <cmccann> I like how it uses liftM2 id there, not liftM2 ($).
19:45:33 <cmccann> it's one character shorter!
19:45:45 <Aetherspawn> ugh, first world problems
19:45:56 <Aetherspawn> (.) is 1 character too long for my line to fit in ruler 80
19:47:45 <cmccann> clearly (.) should be named "b".
19:48:16 <cmccann> also "c" for flip and "k" for const.
19:48:21 <cmccann> &c.
19:48:39 <cmccann> I think "w" is join.
19:49:00 <Aetherspawn> does [f | b] get optimized into if then else ?
19:49:06 <Aetherspawn> I would hope so.
19:49:24 <cmccann> @undo [f | b]
19:49:24 <lambdabot> if b then [f] else []
19:49:38 <Aetherspawn> Ah, excellent
19:50:00 <cmccann> I think @undo is the actual desugaring? or at least close to it.
19:50:08 <pqmodn> @undo do { x <- "xyz"; return x }
19:50:08 <lambdabot> "xyz" >>= \ x -> return x
19:50:14 <zRecursive> There are so many syntax sugar in haskell
19:50:15 <cmccann> anyway GHC is usually good about optimizations like that.
19:54:13 <copumpkin> > [5|false]
19:54:16 <lambdabot>   Not in scope: `false'
19:54:20 <copumpkin> > [5|False]
19:54:22 <lambdabot>   []
19:54:27 <copumpkin> seems like a handy golfing trick
19:54:46 <cmccann> yes, [x|False] is clearly a good way to golf an empty list.
19:55:00 <Aetherspawn> lol'd
19:55:10 <copumpkin> pqmodn: thanks! :P
19:55:12 <cmccann> but yeah, it's a cute trick.
19:55:43 <pqmodn> copumpkin: hehe
19:55:53 <copumpkin> I'm still pretty proud of my golfing achievement last night
19:56:30 <elliott> what did you do
19:56:46 <copumpkin> let d(viewl->_:<t)=t;d(viewl->_)=empty;in((map measure.(uncurry(scanl((|>).d).fromList))).).splitAt
19:56:59 <copumpkin> not only did it fit in a tweet but it fit in a tweet with a description
19:57:12 <cmccann> pf, as if it needs a description.
19:57:19 <cmccann> it's practically self-documenting.
19:57:29 <copumpkin> and I think it's asymptotically optimal for what it does
19:58:08 <cmccann> asymptotically golpftimal
19:58:15 <copumpkin> :P
19:58:53 <cmccann> trying to pronounce golpftimal is kinda fun actually.
19:59:01 <cmccann> it's just close enough to plausible.
20:14:21 <DiegoNolan> anyone want to link me to a good .vimrc file for haskell
20:14:58 <Cale> set expandtab
20:15:58 <lispy> :t viewl
20:16:00 <lambdabot>     Not in scope: `viewl'
20:16:00 <lambdabot>     Perhaps you meant one of these:
20:16:00 <lambdabot>       `Seq.viewl' (imported from Data.Sequence),
20:16:17 <lispy> :t Seq.viewl
20:16:19 <lambdabot> Seq.Seq a -> Seq.ViewL a
20:16:43 <DiegoNolan> i have that one
20:17:43 <dmwit> set autoindent
20:18:42 <lispy> DiegoNolan: here is mine, but I make no claim that it's good: https://github.com/dagit/dotfiles/blob/master/.vimrc
20:19:00 <DiegoNolan> thanks I'll take a look
20:23:31 <tgeeky> i can give you mine if you happen to be on windows, but not if you're not
20:25:50 <Aetherspawn> ARM Linux should probably be a tier 1 platform
20:28:14 <augur> are there any elegant ways to improve the type system to allow for zip(3/4/5/...) to be collapsed into a type class method?
20:28:56 <Cale> It already could be, with a little typeclass hackery
20:29:06 <augur> oh?
20:29:15 <Cale> See printf
20:29:15 <sipa> :t zip
20:29:17 <lambdabot> [a] -> [b] -> [(a, b)]
20:29:20 <sipa> :t zip3
20:29:22 <lambdabot> [a] -> [b] -> [c] -> [(a, b, c)]
20:29:25 <ParahSai1in> :t printf
20:29:28 <lambdabot> PrintfType r => String -> r
20:30:00 <Cale> > printf "%d %d %d" 3 4 5 :: String
20:30:04 <lambdabot>   "3 4 5"
20:30:16 <Cale> > printf "%d %d %d %f" 3 4 5 pi :: String
20:30:21 <lambdabot>   "3 4 5 3.141592653589793"
20:30:27 <Cale> ^^ this stuff is Haskell 98
20:30:27 <ParahSai1in> whoa i didnt know there were variadic functions
20:30:43 <johnw> ParahSai1in: there's a paper on how the trick works
20:31:17 <johnw> it's not so much a variadic function as a function that keeps returning a function when it knkows that more arguments are required
20:31:38 <johnw> (i.e., it's not syntax, it's just a feature of higher-ordered functions)
20:31:59 <ParahSai1in> makes sense
20:32:45 <Cale> Or: it's a typeclass polymorphic thing which can be of many different function types
20:32:45 <johnw> it uses type classes to work around the difficulty of returning a function in some cases, but a plain IO action in the final case
20:32:56 <Cale> Or a String in others :)
20:33:00 <johnw> yeah, or a String
20:33:04 <ntus1017> :t zip
20:33:06 <lambdabot> [a] -> [b] -> [(a, b)]
20:33:24 <johnw> Cale: that's a better way to put
20:33:29 <johnw> it's a typeclass polymorphic thing
20:33:39 <Cale> augur: In any case, it's probably not worth the trouble because nobody ever uses zip3/4/5 anyway
20:34:21 <augur> Cale: true :p
20:34:24 <augur> im just curious
20:34:34 <geekosaur> not clear to me how you'd use it here anyway, printf can do it because it knows the number of parameters from the format string, how do you determine the nunber of lists to zip?
20:37:00 <blaenk> @src printf
20:37:00 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
20:37:22 <blaenk> http://stackoverflow.com/questions/7828072/how-does-haskell-printf-work
20:38:53 <hrookie> any great way to write a byte string to a file handle?
20:39:28 <lispy> ?hoogle ByteString -> Handle -> IO ()
20:39:28 <lambdabot> Data.ByteString hPut :: Handle -> ByteString -> IO ()
20:39:28 <lambdabot> Data.ByteString.Char8 hPut :: Handle -> ByteString -> IO ()
20:39:29 <lambdabot> Data.ByteString.Lazy hPut :: Handle -> ByteString -> IO ()
20:40:06 <hrookie> thanks lispy :D
20:40:14 <Aetherspawn> ?hoogle (a->b) -> b
20:40:14 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
20:40:15 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
20:40:15 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
20:40:17 <lispy> don't thank me, thank the authors of hoogle :)
20:40:28 <Aetherspawn> oooh $!
20:40:33 <Aetherspawn> that must be strict $
20:40:36 <hrookie> ?hoogle Data.ByteString.Internal.ByteString -> ByteString
20:40:36 <lambdabot> Parse error:
20:40:36 <lambdabot>   Data.ByteString.Internal.ByteString -> ByteString
20:40:36 <lambdabot>       ^
20:40:39 <shachaf> ¡$!
20:41:45 <Clint> ¿$?
20:42:08 <shachaf> hrookie: id
20:43:58 <geekosaur> actually wouldn't that be strict vs. lazy ByteString?
20:44:11 <lispy> geekosaur: that's my bet
20:45:20 <Aetherspawn> :t (¡$!)
20:45:21 <lambdabot> fd:9: commitBuffer: invalid argument (invalid character)
20:45:25 <Aetherspawn> lold
20:46:06 <shachaf> Cale: kappabot handled Unicode properly! :-(
20:50:41 <palmfrond_> er, is this an appropriate place to ask really beginner haskell questions?
20:50:56 <shachaf> Just ask your questions. Don't ask to ask.
20:51:01 <shachaf> At worst you'll be directed somewhere else.
20:51:16 <sclv> augur: the idiomatic thing to do for nary zip is to use the ziplist applicative
20:51:27 <augur> sclv: ?
20:51:45 <Clint> no, at worst you'll be ignored
20:51:46 <palmfrond_> I want an Integer from ceiling, but I don't think i'm getting one and I don't really know what to do
20:52:01 <Aetherspawn> fromIntegral ?
20:52:08 <Aetherspawn> :t ceil
20:52:10 <lambdabot> Not in scope: `ceil'
20:52:18 <shachaf> A good way to ask a question is to say (a) what you did (b) what you expected (c) what happened
20:52:30 <Aetherspawn> :t ceiling
20:52:31 <shachaf> With that said, "ceiling" can give you an Integer.
20:52:33 <lambdabot> (Integral b, RealFrac a) => a -> b
20:52:49 <Aetherspawn> :t (fromIntegral . ceiling)
20:52:50 <geekosaur> if youre not getting an Integer then it's being typed as some other Integral type and you need to figure out why
20:52:51 <lambdabot> (Num c, RealFrac a) => a -> c
20:52:57 <Aetherspawn> There we go, that's the one
20:53:05 <Aetherspawn> > (fromIntegral . ceiling) 99
20:53:08 <lambdabot>   99
20:53:20 <sclv> augur: you can use ziplist to get zip3, zip4, zip5 etc
20:53:26 <Aetherspawn> > (fromIntegral . ceiling) 99.12345
20:53:28 <lambdabot>   100
20:53:29 <augur> sclv: ?
20:53:43 <sclv> the ziplist applicative
20:53:49 <lispy> :t ceiling :: Double -> Integer
20:53:51 <lambdabot> Double -> Integer
20:54:00 <augur> sclv: :|
20:54:06 <sclv> ?
20:54:32 <palmfrond_> :( I got more errors, I'll try to formulate a better question and come back
20:54:50 <geekosaur> augur: http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/Control-Applicative.html#t:ZipList
20:54:51 <sclv> if you find it too noisy there's lens tricks to clean it up
20:54:54 <augur> sclv: how does that achieve anything
20:54:55 <sclv> http://stackoverflow.com/questions/2468226/how-to-zip-multiple-lists-in-haskell
20:55:00 <lispy> palmfrond_: if it helps, we sometimes put code samples on hpaste.org and then share the link here
20:55:39 <shachaf> I,I if you find it not noisy enough there's lens tricks to clutter it up
20:55:43 <augur> sclv: aha i see
20:55:53 <geekosaur> palmfrond_, I don't think the fromIntegral suggestion actually understood your issue; celing can produce Integer among other Integral types, and adding fromIntegral cannot help if it's inferring the wrong one
20:56:13 <shachaf> Yes. fromIntegral is not relevant to the question you asked.
20:56:26 <shachaf> It might be relevant to what you're doing, but we don't know what that is. Hence what I said above.
20:57:08 * Aetherspawn goes poof
20:57:36 <Aetherspawn> I guess I have to learn it before I should teach it.
21:03:13 <u_> has anyone in this channel ever successfully cabal installed Chart on a mac?
21:03:15 <tonsofquestions> hi, channel, how can I tell the type of an reserved operator, such as ->
21:03:32 <shachaf> -> doesn't have a type.
21:03:41 <shachaf> Well, not the one in (\x -> y) syntax.
21:03:59 <shachaf> (->) -- as in Int -> Char -- has a kind, but that's a different thing.
21:04:02 <shachaf> Hoogle will usually tell you.
21:04:04 <shachaf> @where hoogle
21:04:04 <lambdabot> http://haskell.org/hoogle
21:04:15 <tonsofquestions> thx
21:05:32 <sclv> u_: once, a long time ago
21:05:37 <sclv> i do not recommend it
21:05:43 <sclv> sadly
21:05:49 <u_> sclv im going nuts here :(
21:05:52 <tonsofquestions> as hoogle, -> is a keyword, as in report2010, it's a reservedop
21:05:56 <sclv> you can use gtk-plot or something for rough and ready plotting
21:06:02 <u_> sclv it gets stuck on cairo and glib
21:06:05 <u_> gtk-plot?
21:06:11 <u_> is that another cabal thing or
21:06:16 <sclv> u_: right you need gtk first
21:06:23 <u_> i got gtk
21:06:23 <sclv> which is horrible
21:06:24 <u_> still breaks
21:06:27 <sclv> unless you're all on macports
21:06:32 <u_> i have macports
21:06:36 <u_> and i just did port install cairo
21:06:40 <u_> and then it seemed to install cairo
21:06:46 <sclv> but the ghc libs don't play with the macports libs
21:06:47 <sclv> so things clash
21:06:52 <sclv> its horrible
21:06:54 <u_> aw crap
21:06:57 <tonsofquestions> keyword is the same concept as reservedop?
21:07:03 <u_> Loading package cairo-0.12.4 ... <command line>: can't load .so/.DLL for: /opt/local/lib/libcairo.dylib (dlopen(/opt/local/lib/libcairo.dylib, 9): no suitable image found.  Did find:
21:07:04 <u_> 	/opt/local/lib/libcairo.dylib: mach-o, but wrong architecture)
21:07:04 <u_> cabal: Error: some packages failed to install:
21:07:20 <u_> so close
21:07:58 <sclv> oh not gtk-plot, erm i meant gnuplot: http://hackage.haskell.org/package/gnuplot
21:07:58 <geekosaur> you have a 32-bit ghc on a 64-bit OS X
21:08:08 <u_> ah
21:08:15 <u_> i was like, if gtk is the whole problem, why is that an alternative? lol
21:08:19 <u_> yay that installed right
21:08:29 <u_> before that i was trying the google charts api as an alternative
21:08:29 <sclv> it relies on the gnuplot program
21:08:32 <geekosaur> (there are reasons to do that, having to do mainly with ghc bugs)
21:08:33 <sclv> but that should be easy enough
21:08:40 <u_> but google charts has stupid limitations
21:08:44 <u_> and the colors weren't working
21:08:47 <u_> so every line came out orange
21:08:55 <sclv> geekosaur: i thought it was a performance thing and we were moving to 64 bit in the future
21:09:27 <geekosaur> reinstall macports stuff +universal, but if your ghc did not also come from macports then there are worse problems ahead (namely conflicts with libiconv and other incorrect libraries that apple ships [readline!])
21:10:02 <u_> as in, if i had installed ghc using macports it might've worked?
21:10:03 <u_> bleh
21:10:04 <u_> no thanks
21:10:20 <geekosaur> macports would have ensured the architectures matched, yes
21:10:34 <u_> that'll probably just break something else
21:10:40 <u_> and i'll never write another haskell program again
21:10:53 <u_> so how do you get this gnuplot thing
21:10:57 <sclv> haha exactly -- the lib conflicts are nuts. the one time i got it working i ended up doing something like just building my own gtk
21:11:48 <sclv> u_: i don't know the best way -- there are a zillion, but you can macports it
21:12:04 <sclv> and since its just an executable binary you don't have to worry about lib mismatches
21:12:34 <u_> i don't know much about these lib things but they are starting to sound like a gigantic tragedy
21:13:11 <lpvb> if a thread reads a value from a TChan, that value is consumed by that thread and not available to other threads right?
21:13:23 <u_> oh noes this file isn't in the right place, this database needs to be updated, this symbol is missing, yada yada yada
21:13:24 <shachaf> If the transaction goes through, sure.
21:13:32 <shachaf> It's a lot like a regular Chan.
21:14:18 <lpvb> I couldn't find any literature on their behavior
21:14:27 <lpvb> TChan/Chan
21:14:37 <sclv> u_: its a downside of os x -- they deviate from *nix libraries in maddening ways
21:14:44 <shachaf> http://community.haskell.org/~simonmar/slides/cadarache2012/ are good slides that cover this among other things.
21:14:48 <lpvb> so TChans are a good way to load balance right?
21:14:54 <shachaf> Also the book he's writing, though it's not finished.
21:15:17 <sclv> lpvb: well you need fairness on who pulls off he tchan
21:15:18 <shachaf> But I imagine the documentation at least somewhat covers the behavior?
21:16:36 <palmfrond_> ok, so I made this function to give me a list of all the even fibonacci numbers under a certain number which is passed as a parameter to the function. At first, I just put the number I wanted to pass as a parameter into the actual function, and it worked well. I tried taking the number out and replacing it with the parameter name so I could use with other numbers, but then I got a bunch of errors, and I don't know if it's a problem 
21:16:46 <sclv> haha the stm documentation in the libs is… lacking
21:16:55 <sclv> someone should patch that!
21:17:03 <shachaf> So it is.
21:17:09 <sclv> much like other ghc lib documentation it has some info on individual functions and points to a paper
21:17:13 <sclv> that is partially outdated
21:17:26 <sclv> hey someone, get on that documentation!
21:18:01 <sclv> palmfrond_: you can hpaste.org the bad and good versions if you want us to take a look
21:18:06 <shachaf> But you're our resident expert on how bad the documentation is!
21:18:14 <palmfrond_> the hpaste I put has both versions
21:18:20 <palmfrond_> the one with ' is good
21:18:22 <lpvb> shachaf: like sclv says there is no documentation on the specific behavior of Chans :\
21:18:40 <palmfrond_> and if you delete the other one it works, but the other one causes a bunch of errors
21:19:59 <hrookie> is there convenient way to declare a byte value?
21:20:10 <hrookie> i can't seem to shake the fact that i'm really declaring chars
21:20:17 <lpvb> hrookie: Word8 ?
21:20:28 <shachaf> hrookie: ?
21:20:39 <shachaf> What do bytes have to do with Chars?
21:20:41 <hrookie> lpvb: yeah, that's what i'm after - is there a constructor i'm just totally missing?
21:20:47 <shachaf> 0 :: Word8 etc.
21:20:50 <sclv> palmfrond_: looking now. sec.
21:21:16 <cmears> palmfrond_, you can't do "x - 1.5", because x is Integer
21:21:20 <lpvb> palmfrond_: it's because the type that your math functions are expecting is not Integer
21:21:46 <sclv> palmfrond_: two things to fix it
21:21:56 <sclv> first make the sig Double -> [Integer]
21:22:00 <hrookie> oh i see, thanks!
21:22:01 <sclv> because x needs to be floating point.
21:22:11 <sclv> then, in the x > n condition
21:22:16 <sclv> make it x > fromIntegral n.
21:22:38 <palmfrond_> oh
21:22:39 <sclv> because we need to lift n from an integer to let us compare it to x, which is now a double
21:23:02 <shachaf> lpvb: You can also look at the source for TChan. :-)
21:23:08 <palmfrond_> i see
21:23:09 <shachaf> It's pretty nice: http://hackage.haskell.org/packages/archive/stm/2.4.2/doc/html/src/Control-Concurrent-STM-TChan.html
21:23:12 <palmfrond_> thanks sclv!
21:23:15 <shachaf> Much nicer than the source for Chan.
21:23:32 * shachaf ❦ stm
21:25:24 <Aetherspawn> You ask why all data with like <4 members isn't unpacked by default given the amount of unpacking repeated in libraries for performance reasons
21:25:42 <Aetherspawn> or maybe I just don't understand.
21:34:43 <u_> sclv: ok, i did "sudo port install gnuplot", opened ghci, imported graphcis.gnuplot.simple and typed "plotlist [] [1,2,3]
21:34:45 <u_> "
21:34:47 <u_> and nothing happens
21:34:55 <u_> how am i supposed to use it?
21:34:58 <u_> does it write to a file or what
21:35:02 <sclv> basically that
21:35:13 <u_> where?
21:35:20 <sclv> i mean you used it right
21:35:26 <u_> oh
21:35:30 <sclv> you should make sure its in your path
21:35:31 <u_> so should it open a window or
21:35:39 <sclv> yeah it typically pops open a window
21:35:43 <u_> hm
21:35:52 <u_> make sure .cabal/bin/gnuplot is in my path?
21:36:10 <sclv> wait why is gnuplot in .cabal/bin?
21:36:15 <u_> it isn't my bad
21:36:27 <u_> we're talking about the non-haskell part, right
21:36:30 <sclv> you can test gnuplot directly from the command line to make sure it works
21:36:31 <u_> hm where would it be then
21:36:35 <sclv> yep -- the non haskell part
21:36:46 <u_> aha
21:36:47 <u_> seems to work
21:40:21 <u_> sclv what should i add to path?
21:40:39 <sclv> well you should make sure that you can call gnuplot unqualified from the cmd line
21:40:41 <frankbro> I have cabal installed hlint, how do I run it? hlint doesnt work in ghci nor in a standard shell. Im on linux btw.
21:40:44 <u_> i can
21:40:49 <sclv> then it is in the path
21:40:52 <u_> oh
21:40:55 <sclv> dunno why ghc isn't invoking it
21:40:59 <u_> :(
21:41:26 <u_> all i want is to stop copy pasting the output into excel lol
21:41:39 <u_> probably could've done that one repetitive action thousands of times by now
21:42:11 <palmfrond_> u_: do you do numerical work with haskell?
21:42:17 <u_> yeah
21:42:29 <u_> i'd say am doing but yeah
21:42:30 <palmfrond_> do you need it for parallel computing or something?
21:42:37 <u_> no i'm just playing around
21:42:39 <palmfrond_> oh
21:43:18 <cmears> frankbro, maybe you just don't have it on the path?
21:43:19 <u_> sclv suddenly it works, even though i typed the exact same thing i typed last time (as far as i know)
21:43:20 <u_> :D
21:43:44 <sclv> well, good enough to declare victory!
21:43:46 <cmears> frankbro, by default it will be in ~/.cabal/bin/hlint
21:44:16 <frankbro> cmears, its not there
21:44:47 <u_> yeah no more selecting shit, waiting 10 seconds for it to scroll up, taking 10 more seconds to get the end of the selection in the right place, right clicking to copy because the keyboard shortcut doesn't work for some reason, pasting into excel and waiting 30 more seconds for it to unhang :D
21:45:09 <cmears> frankbro, are you sure it installed correctly?  At the end it says where it puts the executable
22:21:04 <carter> hey all, does anyone have a nice way of getting criterion to generate a seperate bar chart per bench broup
22:21:07 <carter> ?
22:23:02 <carter> yo blackdog hows lambdajam?
22:23:23 <johnw> isn't lambdajam not until july?
22:23:26 <johnw> i thought it was bayhac happening now
22:24:12 <shachaf> There is more than one lambdajam in the world.
22:24:18 <carter> johnw itheres an australian one
22:24:20 <carter> or something
22:24:26 <johnw> oh yeah!
22:24:30 <johnw> i forgot about that
22:24:52 <mauke> ooh black betty
22:27:27 <carter> does anyone have a criterion template that doesn't group ALL The benchmarks on the same barchart?
22:29:16 <mzero> If you're in Australia, then you might be Lambda Jam'ing right now
22:29:22 <lispy> carter: I'd ask carter+2weeks. I think I heard he was working on it :)
22:29:36 <mzero> If you're in No. Califoria, then you might be BayHac'ing tomorrow afternoon
22:30:09 <carter> lispy no, i'll be cursing at llvm quirks i'm discovering
22:30:32 <carter> around then
22:30:40 <carter> i can live without the nice pllots
22:30:42 <carter> plots
22:30:46 <carter> i'd just like to have nice plots
22:33:30 <carter> ok, fine, i'll mess with the criterion templates
22:36:29 <hrookie> is there a convenient way to put a type constraint on a bunch of functions at the same time? e.g., i want to have all my "elements" be serializable -- how can i silver-bullet "Serializable Element => [Element] -> ByteString" etc?
22:37:52 <mzero> meaning you have a number of functions of the form       [Element] -> ByteString     and all of them need the Serializable Element constraint?
22:38:18 <hrookie> yes - Element appears in many function signatures, and in each one, I want it to be constrained as Serializable.
22:38:42 <lispy> is Element a type?
22:39:05 <hrookie> i suppose I'd indeed have to type it xD
22:39:36 <mzero> I don't understand ---- isn't Element a concrete type?
22:39:56 <lispy> what I mean is that, when we say, "Foo a => [a] -> ..." `a` is a type variable. If Element is a concrete and specific type you don't need to specify the type class
22:40:24 <hrookie> oh, silly me - sorry, i had a concrete type in there, now i'd like to switch it over to a type variable ^^
22:40:34 <shachaf> Please try to help the people who are trying to help you.
22:40:58 <mzero> Ah      Serializable a => a -> ByteString     is what you are after in a number of functions
22:40:59 <mzero> okay
22:41:46 <mzero> short answer is no --- you just add that constraint to each signature
22:42:17 <mzero> if you have multiple constraints, you can use an empty type class to collapse them into one "bundle" that you use
22:42:30 <hrookie> oh, i see
22:42:32 <hrookie> thanks!
22:42:37 <hrookie> sorry for the little mix-up i posted up there :_P
22:44:06 <mzero> no problemo at all!
22:44:53 <carter> mzero have fun with bayhac
22:45:10 <mzero> thanks - in the middle of a million last minute loose ends with it now
22:45:29 <mzero> (whcih is obviously why I'm hanging here answering questions!    mzero >>= procastination
22:45:32 <shachaf> mzero: But an empty type class will still need an instance for every type.
22:46:11 <mzero> instance (Foo a, Bar a, Baz a) => FooBarBaz a
22:46:17 <mzero> isn't there a GHC extension that allows that
22:47:03 <shachaf> UndecidableInstances?
22:47:03 <carter> constraint kinds?
22:47:13 <shachaf> Of course ConstraintKinds will let you just make a synonym.
22:58:22 <NetBat> People: Could one of you sned me the direct link to the `Prelude' module, please? I'm having slight difficulty locating any of the modules.
22:58:38 <NetBat> s/sned/send/
22:59:21 <Saizan> the docs?
22:59:42 <Saizan> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/Prelude.html
22:59:46 <NetBat> Is that the same as the code?
22:59:57 <arkeet> you can view the source there
23:00:09 <NetBat> Thanks
23:00:18 <Saizan> it's not very interesting though, it just reexports stuff
23:00:22 <arkeet> although most of the stuff there is re-exported from other modules
23:02:46 <boothead> hi guys is there a syntax for having a keyword as a field name? I'm parsing json and one of the keys it "type" :-/
23:02:52 <boothead> *is
23:03:45 <NetBat> What I need to do is to learn to find modules more efficiently. I seem to have some difficulty with that.
23:04:01 <shachaf> @where hoogle
23:04:01 <lambdabot> http://haskell.org/hoogle
23:04:13 <shachaf> You also need to learn to stay in an IRC channel after you ask a question. :-)
23:04:53 <NetBat> Shachaf: you also need to learn to find out out why I leave so soon. :)
23:05:10 <johnw> NetBat: what is that?
23:05:19 <johnw> s/what/why
23:05:54 <zRecursive> Maybe his teacher / boss is coming ?
23:06:03 <johnw> that only needs hiding the window
23:06:10 <NetBat> johnw: the text moves too fast for me to follow and it gives me a head.
23:06:24 <NetBat> s/head/headache/
23:06:32 <johnw> but why leave the channel?  just stop reading for a little bit
23:06:35 <zRecursive> NetBat: not ERC ?
23:06:52 <NetBat> No teacher or boss here
23:07:12 <NetBat> and gratuitous comments is another reason why I take a quick exit from channels
23:08:34 <NetBat> johnw: that would make it even harder as I would have to find the right replies to my query.
23:08:49 <johnw> interesting
23:09:00 <NetBat> johnw: it is, beleive me.
23:09:03 <johnw> then always ask questions at around 3am, it's always quiet then
23:09:16 <johnw> 3am at GMT-6, of course
23:09:41 <NetBat> johnw: so I should stay up until 3 in the morning only in order to ask questions on IRC
23:09:56 <NetBat> it shall be done my lord
23:10:21 <mzero> boothead: no - you can't use 'type' as a field name
23:10:21 <lpvb> what's the difference between transformers and mtl?
23:10:31 <mzero> common convention is to mutate it to   type_
23:11:20 <boothead> mzero: I was hoping that theres be some other way as I'm deriving Data and using the generic functionality of Aeson...
23:11:24 * hackagebot comonad-transformers 3.0.2 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-3.0.2 (EdwardKmett)
23:11:55 <mzero> boothead: I thought Aeson emplyed just such a convention for this
23:12:09 <boothead> I could just leave out that field I suppose - anoying though
23:12:13 <johnw> NetBat: I was just being facetious
23:12:36 <lpvb> what should I use, mtl or transformers?
23:12:41 <johnw> transformers
23:12:42 <NetBat> johnw: you surprise me.
23:12:51 <johnw> NetBat: :)
23:12:51 <lpvb> johnw: thanks
23:14:45 <boothead> mzero: I can't see anything that does so in the source, and manually converting the field to type_ gives my Nothing when I parse
23:15:22 <mzero> in the TH stuff of Aeson, there is support for supplying a JSON field name <-> Haskell field name function
23:15:33 <lispy> NetBat: perhaps IRC isn't for you.
23:15:39 <mzero> I thought such a function was used for the generic.
23:16:04 <lispy> NetBat: I'm not trying to be rude, but it sounds like it may not fit your prefered style of interaction
23:16:12 <boothead> mzero: thanks for the pointer, I'll have a look. Now I have to put haskell down and go to work :-(
23:16:24 <mzero> sorry to hear that!
23:16:41 <johnw> yes, that's a sad thing
23:16:46 <mzero> well - have a good day (and I know I've lost count of the number of days I was late for work due to Haskell...)
23:17:33 <lispy> mzero: lazy schedule where you didn't show up until your presence was demanded?
23:17:35 <boothead> if it wasn't for having to feed my children I'd stay. If only someone in London would have the foresight to let my feed my children with Haskell :-)
23:17:59 <lispy> the big banks in london use haskell
23:18:20 <boothead> lispy: a couple do - but not the one I work for ;-)
23:18:52 <mzero> but children in london probably still use pasta and cookies
23:20:52 <boothead> mine must have been eating Haskell - they're being very lazy and won't get out of bed! :-D
23:21:13 <lpvb> how do I make a RST from RWST in transformers?
23:21:19 <lpvb> type RST r w s = RWST r (Identity w) s ?
23:22:07 <arkeet> ???
23:22:18 <arkeet> w is the writer state type.
23:22:24 <arkeet> if you don't want any writing, use () for it
23:22:36 <arkeet> RST r s = RWST r () s
23:22:37 <lpvb> so type RST r w s = RWST r (Identity ()) s ?
23:22:41 <lpvb> oh
23:22:46 <lispy> > () `mappend` ()
23:22:49 <lambdabot>   ()
23:22:50 <mikeplus64> or "forall a. RWST r a s", maybe
23:22:58 <arkeet> maybe
23:23:08 <mikeplus64> if for some reason you don't like ()
23:23:26 <otters> are there any syntax highlighting libs for haskell?
23:23:46 <mikeplus64> !hackage highlighting-kate
23:23:50 <mikeplus64> @hackage highlighting-kate
23:23:50 <lambdabot> http://hackage.haskell.org/package/highlighting-kate
23:24:09 <otters> oh, awesome
23:25:54 <lispy> the fun thing about using () for the writer state is you could still 'tell ()'
23:26:16 <otters> :t shouldn't've
23:26:18 <lambdabot> Not in scope: `shouldn't've'
23:27:54 <otters> what about a markdown renderer?
23:28:07 <arcatan> @hackage pandoc
23:28:07 <lambdabot> http://hackage.haskell.org/package/pandoc
23:28:19 <johnw> and @hackage markdown
23:28:26 <johnw> @hackage markdown
23:28:26 <lambdabot> http://hackage.haskell.org/package/markdown
23:28:41 <johnw> the latter has a more lenient license
23:28:47 <johnw> which is mainly why it exists
23:28:55 <otters> oh, man, no way
23:28:59 <otters> there's an actual markdownField type
23:31:33 <mmaruseacph2> damn, fb package seems broken
23:33:09 <mmaruseacph2> No instance for (A.FromJSON ZonedTime)
23:33:10 <mmaruseacph2> :(
23:33:25 <mmaruseacph2> will look into it
23:36:32 <blaenk> My program uses a package (hakyll) and it seems like there's a bug in it, I get an "openFile: permission denied" error. is there a way to get a lead on this? like perhaps have it print the line number it occurs at, or /anything/?
23:36:42 <blaenk> function it occured in, anything at all that would give me a place to start
23:36:51 <blackdog> blaenk: maybe strace it?
23:36:56 <blaenk> :(
23:37:05 <mikeplus64> blaenk: openFile is the function that had the error, which indicates maybe you don't have write permission
23:37:11 <mikeplus64> or executable permission or similar for something
23:37:12 <blaenk> guess it's judgement time
23:37:21 <blaenk> I'm on windows, this doesn't happen in linux when I do it
23:37:25 <mikeplus64> actually not executable that doesn't make sense for openFile
23:37:31 <blaenk> but it didn't happen a few commits back
23:37:35 <blaenk> *few commits back to hakyll
23:37:57 <blaenk> so I'm trying to help out and figure out what caused this to happen, git bisect didn't help much, not really sure where to start
23:38:16 <mikeplus64> try run as admin? that's not much of a fix though.
23:38:23 <blaenk> yeah, did try that first thing :(
23:38:33 <blaenk> see the problem is
23:38:39 <mikeplus64> it'd be good if openFile's exception had the file name it was trying to read
23:38:44 <blaenk> I searched around already and it seems it's a problem on windows becuase ghc requires file locking or something
23:38:56 <blaenk> oh it does have the filename, but I don't think it's of much use
23:39:25 <blaenk> http://www.haskell.org/pipermail/haskell-cafe/2011-December/097984.html
23:39:52 <blaenk> this is shorter though, by dons http://stackoverflow.com/questions/6081794/openfile-permission-denied-when-reading-and-writing-to-the-same-file
23:40:17 <blaenk> I think that may be the problem, but I'm not sure. I think readFile is being called twice on the same file and so the second time it gives that error? not sure
23:40:26 <blaenk> the problem is there are multiple places where files are read, so I was hoping for some sort of lead
23:40:49 <blaenk> to at least have some place to begin looking, especially since this is occuring in the hakyll codebase
23:40:52 <blackdog> blaenk: wouldn't strace give you that?
23:41:06 <blaenk> like I said, I'm on windows :(
23:41:10 <blackdog> oh, duh.sorry.
23:41:13 <blaenk> this problem doesn't occur on linux
23:41:23 <blaenk> but yeah encountering this makes me long for those tools
23:41:40 <blaenk> it's a shame because it didn't happen until a few commits ago, I even know the infringing commit, but I have no idea where to begin looking for a lead
23:41:53 <blaenk> I was hoping maybe the function name where it occured, or line number, or anything like that
23:42:04 <blaenk> *was hoping to have access to
23:44:23 <blackdog> blaenk: yeah, it looks like readFile depends on hGetContents, so by the time that the exception is thrown, you don't have access to the filename any more
23:45:13 <amosr> some kind of stack trace or something would be very useful
23:45:48 <blaenk> blackdog: yeah :(
23:45:52 <blaenk> amosr: agreed
23:46:02 <blaenk> I think I'm gonna try looking for every occurence of readFile, and see if I can force it to be strict
23:46:10 <blaenk> then if the problem's gone, I'll know it's that
23:46:14 <blaenk> ;_;
