00:00:02 <carter> if you're moving a binary beetween two differen versions of the same os
00:00:12 <carter> local nix vs hosted vps>
00:00:14 <carter> ?
00:02:49 <mm_freak> if you find a feasible way to use a functional language on android, please let me know
00:03:00 <blackdog> yes, but it's compiled on my local box the same way, and it works fine except when i package it with fpm
00:03:51 <carter> fpm? whats that?
00:06:44 <Jookia> Hello!
00:08:55 <blackdog> carter: fpm is Effing Package Manager - quite cute for building native packages.
00:09:03 <carter> ah
00:09:06 <blackdog> do it once, then it can turn out debs, rpm, whatever
00:09:34 <carter> theres a trick to statically link the c libs bindings into the ghc binary
00:10:06 <carter> or something
00:15:17 <blackdog> carter: the weird bit is that it doesn't die with a linking error - it just fails to make a tcp connection
00:15:20 <blackdog> very odd
00:15:26 <carter> ah
00:15:28 <carter> well
00:15:30 <carter> idk
00:16:16 <Jookia> Could somebody help me with this: http://sprunge.us/hIQE?haskell ? I have a feeling that I can do line 29 better, where a maybe may return a modified structure. I tried a small function 'optModify options record value :: Options -> String -> String' but it seems that's not a good way to do things?
00:21:11 <supki> case d of Just x -> o { directory = x }; Nothing -> o
00:23:58 <Jaxan> I often find myself writing o { bladiebla = f (bladiebla o) }, is there a nicer way to do this?
00:24:19 <shachaf> Yes: Lenses.
00:25:05 <shachaf> Well, you can write a modifier function: overBladiebla f o = o { bladiebla = f (bladiebla o) } once, and then use it in different places.
00:25:06 <Jaxan> ok, then I'll look into that someday ;)
00:25:10 <shachaf> But a lens is better.
00:27:21 <arkeet> o & bladiebla %~ f
00:27:25 <arkeet> (with lens)
00:27:46 <arkeet> or, if you don't like operators, over bladiebla f o
00:29:52 <shachaf> Maybe there should be a type class with a method that maps a getter to a lens.
00:29:56 <mrwonko> can I create a function by compositing existing ones that given [a, b, c, d] returns [a, a*b, a*b*c, a*b*c*d]? I have a feeling it should be possible. It's basically folding the result of take...
00:30:08 <shachaf> Then you could use over (foo field) ... without bother with _s.
00:30:32 <shachaf> > scanl1 (*) [a,b,c,d]
00:30:35 <lambdabot>   [a,a * b,a * b * c,a * b * c * d]
00:31:20 <mrwonko> that was about as pleasantly simple as I had hoped :) time to look at scanl1
00:32:12 <shachaf> A scan is like a fold except instead of getting one final value you get a list of every intermediate value.
00:55:13 <Shaladdle> What magic did lambdabot use to do that symbolically?
00:57:54 <FireFly> @ty a
00:57:55 <lambdabot> Expr
00:58:06 <bitonic> Shaladdle: I don’t even know what you are referring to, but I’m going to guess: ‘simple-reflect’
00:58:13 <bitonic> @hackage simple-reflect
00:58:14 <lambdabot> http://hackage.haskell.org/package/simple-reflect
00:58:44 <shachaf> bitonic is correct
00:58:47 <Shaladdle> bitonic: I meant the scan
00:58:49 <Shaladdle> cool
00:58:51 <Shaladdle> thanks :)
00:59:17 <FireFly> > sum [1..5] :: Expr
00:59:20 <lambdabot>   0 + 1 + 2 + 3 + 4 + 5
00:59:24 <bitonic> Shaladdle: I had just joned ehe
00:59:28 <FireFly> okay, *that* confuses me.. heh
00:59:40 <shachaf> FireFly: Which part?
00:59:41 <Shaladdle> bitonic: hah
01:00:01 * bitonic is used to lambdabot magic questions ehe
01:00:23 <FireFly> shachaf: the part where I thought that  sum [1..5]  would just evaluate to a single value that couldn't be torn apart, even by magic packages
01:00:49 <shachaf> Hmm.
01:00:50 <bitonic> FireFly: Expr is an instance of Num
01:00:51 <cmears> Don't think of "1" as an integer, think of it as an Expr
01:00:53 <FireFly> wait, application binds higher than ::, right?
01:00:53 <shachaf> > 1 + 2 :: Expr
01:00:58 * hackagebot vector-heterogenous 0.1.1 - A type-safe library for vectors whose elements can be of any type, or any type satisfying some constraints  http://hackage.haskell.org/package/vector-heterogenous-0.1.1 (MikeIzbicki)
01:00:59 <Jaxan> FireFly: there is no conversion, so the type systems infers that 1 is also of type Expr
01:00:59 <lambdabot>   mueval: ExitFailure 1
01:00:59 <lambdabot>  mueval: Prelude.undefined
01:01:00 * hackagebot HLearn-algebra 1.0.0.1 - Algebraic foundation for homomorphic learning  http://hackage.haskell.org/package/HLearn-algebra-1.0.0.1 (MikeIzbicki)
01:01:01 <shachaf> > 1 + 2 :: Expr
01:01:02 * hackagebot HLearn-distributions 1.0.0.1 - Distributions for use with the HLearn library  http://hackage.haskell.org/package/HLearn-distributions-1.0.0.1 (MikeIzbicki)
01:01:07 <Jaxan> i guess
01:01:07 <lambdabot>   mueval: ExitFailure 1
01:01:07 <lambdabot>  mueval: Prelude.undefined
01:01:10 <FireFly> Jaxan: oh...
01:01:13 <FireFly> sneaky
01:01:20 <shachaf> sighmdabot
01:01:24 <shachaf> b
01:01:32 <FireFly> (well, maybe not. maybe I'm just slow)
01:01:53 <bitonic> @ty sum
01:01:56 <lambdabot> Num a => [a] -> a
01:02:03 <bitonic> FireFly: see above, in that case the ‘a’ is Expr
01:02:23 <bitonic> @ty (+) :: Expr -> Expr -> Expr
01:02:26 <lambdabot> Expr -> Expr -> Expr
01:02:30 <bitonic> @ty 1 :: Expr
01:02:34 <lambdabot> Expr
01:02:38 <FireFly> @ty (+) `asAppliedTo` a
01:02:43 <lambdabot> Expr -> Expr -> Expr
01:02:45 <bitonic> yeah.
01:02:52 <FireFly> Okay, I get it now
01:03:28 <bitonic> it’s quite neat, but it pollutes the namespace with all those variable names :P
01:05:58 * hackagebot list-tries 0.5 - Tries and Patricia tries: finite sets and maps for list keys  http://hackage.haskell.org/package/list-tries-0.5 (MattiNiemenmaa)
01:06:26 <blackdog> gwern: hey, you around? noticed you hit a "getProtocolByName: does not exst (no such protocol name: tcp)" error back in 2010, and was wondering if you ever actually solved it
01:07:09 <shachaf> blackdog: Any clues from strace or some such?
01:07:18 <shachaf> Not that you'd expect a system call for that, but...
01:07:49 <blackdog> shachaf: didn't think of strace, i'll try that.
01:08:42 <shachaf> Maybe ltrace or some such. I don't know how well all these things work with GHC.
01:09:04 <shachaf> I guess getProtocolByName is just an FFI binding to getprotobyname? I don't know.
01:09:15 <shachaf> Also do you know where it's being called? You could try to get a stack trace.
01:11:02 <blackdog> shachaf: sorry, it's a bit slow - i only see the bug on my vps
01:11:15 <blackdog> just recompiling to remove some concurrency
01:20:47 <klrr> i get this strange type error, it says it expected some weird type but i actually has specified that type in the signature, any ideas? http://hpaste.org/87557 (code and error in paste)
01:23:47 <acube> klrr: putStrLn x >> return $ Bool True parses as (putStrLn x >> return) (Bool True). Is this really what you want?
01:24:09 <klrr> acube: aaa thanks!
01:24:12 <acube> @src *>
01:24:13 <lambdabot> (*>) = liftA2 (const id)
01:24:15 <klrr> damn im a real haskell nube
01:24:28 <acube> @src <$
01:24:28 <lambdabot> (<$) = (<$>) . const
01:24:40 <johnw> > 10 <$ Just 20
01:24:42 <lambdabot>   Just 10
01:25:06 <acube> klrr: You could also rewrite it as Bool True <$ putStrLn x
01:25:09 <johnw> more useful with, say, a parser: "Goodbye" <$ string "Hello"
01:25:17 <acube> (<$) is from Applicative
01:26:00 <klrr> acube: oh okey
01:26:06 <klrr> ?type <$
01:26:08 <lambdabot> parse error on input `<$'
01:26:13 <acube> ?type (<$)
01:26:15 <lambdabot> Functor f => a -> f b -> f a
01:26:16 <klrr> aa
01:26:26 <klrr> a monad is a functor?
01:27:09 <johnw> kirr: are you asking about Haskell?
01:27:11 <ion> All monads are functors. Due to a historical mistake, Haskell’s Monad class doesn’t depend on Functor/Applicative.
01:28:07 <acube> How can one actually prove that fmap . const == (>>) . return ?
01:28:36 <acube> oops, that wasn't right. The second for has to be (\x y -> x >> return y)
01:28:50 <acube> @pl \x y -> x >> return y
01:28:50 <lambdabot> (. return) . (>>)
01:29:00 <klrr> acube: i get another error now :x it still returns IO () even if i wanna return ErrorOr
01:29:06 <shachaf> Not everything has to be point-free.
01:30:12 <johnw> shachaf: you don't need to tell us that every time someone uses (. foo) :)
01:30:35 <ion> Someone does.
01:31:32 <acube> kllr: Bool True <$ putStrLn x is of type IO Expr. But you said the return type of print' is IOErrorOr Expr
01:31:47 <shachaf> johnw: There is a natural tendency toward clever but unreadable code.
01:31:54 <shachaf> Someone has to push the other way.
01:32:04 <acube> klrr: so you need to lift the IO Expr to an IOErrorOr Expr
01:32:10 <shachaf> acube: If you'll allow that fmap = liftM, then it's (\x y -> liftM (const x) y) === (\x y -> y >> return x)
01:32:13 <shachaf> @src liftM
01:32:14 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
01:33:17 <shachaf> So it's y >>= (\z -> return (const x z)) === y >>= (\_ -> return x)
01:33:28 <shachaf> You can probably do the rest. :-)
01:33:48 <shachaf> The proof that liftM is necessarily fmap is a bit trickier.
01:36:24 <ion> Their type signatures match, Q.E.D.
01:36:26 <klrr> acube: thanks!
01:36:36 <klrr> it works now, my LISP HAS IO!!! :DDDD
01:36:49 <ion> You ruined it.
01:38:25 <t7> impure
01:38:40 <t7> (fire the-missiles)
01:41:32 <kennyd> not if you replace defun with your own version of pure, typed lisp
01:43:18 <t7> (bind (fire the-missiles) (print '(Hello World!)))
01:55:42 <robstewartuk> Is there a way in haskell-mode in emacs to easily turn my haskell code into literate haskell ?
01:57:00 <kostja> I want to split a string in all possible ways in (head, tail) pairs. I tried split s = scanr (\_ (x:xs,y) -> (xs,x:y)) (reverse s,"") s But I get reversed heads. Using scanl I get reversed tails.
02:01:02 <monoidal> kostja: one (rather ugly) version: split l = map (flip splitAt l) [1..length l]
02:01:33 <monoidal> well, [0..length l]. does not work on infinite lists etc
02:04:43 <wto> 77
02:04:45 <wto> oops
02:04:52 <supki> > liftA2 zip inits tails "haskell"
02:04:54 <lambdabot>   [("","haskell"),("h","askell"),("ha","skell"),("has","kell"),("hask","ell")...
02:05:10 <kostja> ui!
02:05:11 <monoidal> supki: wow, that's much better
02:06:13 <Peaker> > takeWhile (not . null . snd) $ iterate (\(before,after) -> (take 1 after ++ before, drop 1 after)) ([], "Hello")
02:06:16 <lambdabot>   [("","Hello"),("H","ello"),("eH","llo"),("leH","lo"),("lleH","o")]
02:07:09 <Peaker> if you don't care about the order, better to do it zipper-style to avoid O(N) init at each iteration
02:08:16 <acube> > liftA2 zip tails (reverse . tails) "haskell"
02:08:17 <lambdabot>   [("haskell",""),("askell","l"),("skell","ll"),("kell","ell"),("ell","kell")...
02:08:29 <acube> > liftA2 zip (reverse . tails) tails "haskell"
02:08:32 <lambdabot>   [("","haskell"),("l","askell"),("ll","skell"),("ell","kell"),("kell","ell")...
02:08:35 <kostja> Peaker: your's the same, like my version, isn't it?
02:09:18 <acube> Peaker: But inits should be more efficient, no?
02:09:41 <johnw> ozataman: ping
02:09:56 <ozataman> johnw: pong
02:10:06 <johnw> hi, I'm trying to get your DynamoDb.hs example working
02:10:12 <johnw> is devel-1 the table name?
02:10:18 <Peaker> acube, nope, it has to copy the entire list for each init
02:10:23 <Peaker> acube, lists can share tails not heads
02:10:23 <ozataman> johnw: sec, I have to remind myself
02:10:26 <Peaker> kostja, perhaps it is :)
02:11:23 <ozataman> johnw: yes
02:11:32 <johnw> ok, let me try something else then
02:12:36 <johnw> ozataman: I keep getting: DynamoDb: aws: Could not parse error message from DynamoDB
02:12:44 <johnw> is there a way to dump the raw mesage?
02:12:52 <johnw> i guess i can sniff the line with wireshark
02:13:10 <ozataman> johnw: can't remember off the top of my head. but that code was definitely working last I checked - maybe 3-4 weeks ago
02:13:30 <ozataman> johnw: it is possible the merge changes something in the core modules and affected this..
02:13:36 <johnw> are the name/class items the hash/range?
02:13:38 <ozataman> changed*
02:14:17 <kostja> @ty liftA2
02:14:19 <ozataman> don't follow what you mean by name/class
02:14:19 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
02:14:32 <johnw> attrAs text "name" "josh"
02:14:37 <johnw> attrAs text "class" "not-so-awesome"
02:14:44 <neurocyte> lpvb, mm_freak: ghc 7.8 can cross compile to android just fine. I've already built a few experimental android apps with it.
02:14:51 <ozataman> I usually document haddocks as I go along - you might want to look at the docs for DynamoDb.Core
02:15:03 <ozataman> oh that name class
02:15:12 <ozataman> right, name is the row key there
02:15:22 <ozataman> oh, no
02:15:37 <johnw> i'm just wondering how to create my table correctly
02:15:40 <ozataman> sorry, my bad - name is the key, josh is the value
02:15:41 <johnw> because that may be the problem
02:15:47 <ozataman> right, name and class are column names
02:15:51 <johnw> right, and class is the range?
02:15:54 <neurocyte> It can be pretty tricky to build the cross compiler though. Check out http://github.com/neurocyte for my build scripts.
02:16:08 <ozataman> don't think I have a range key in that example
02:16:12 <johnw> ok
02:16:20 <Peaker> kostja, there's also the ListZipper package, you can use takeWhile (not . endp) . fromList
02:16:32 <Peaker> oops: takeWhile (not . endp) . iterate right . fromList
02:16:36 <ozataman> hpk :: IsDVal a => a -> PrimaryKey
02:16:40 <ozataman> vs.
02:16:42 <ozataman> hrpk :: (IsDVal a, IsDVal b) => a -> b -> PrimaryKey
02:17:01 <johnw> so, when I create the table
02:17:10 <johnw> the primary key type for this example should be just "hash"?
02:17:14 <ozataman> yup
02:17:32 <kostja> Peaker: the version from supki is O(n^2) right?
02:17:57 <kostja> because init is O(k) and it sums k from 1 to n
02:18:03 <Peaker> kostja, any version that gives you the inits will be
02:19:01 <kostja> Peaker: O(n) should be enough to split the list in heads and tails, not?
02:19:31 <Peaker> kostja, if you build the reversed heads/inits and not inits, then yeah, because you can share them
02:20:00 <kostja> Peaker: okay, I get it
02:20:21 <kostja> is there a "double linked list, then?"
02:20:30 <kostja> there one can take from the end?
02:22:10 <Peaker> > liftA2 zip (reverse . tails . reverse) tails [1,2,3]
02:22:11 <lambdabot>   [([],[1,2,3]),([1],[2,3]),([2,1],[3]),([3,2,1],[])]
02:22:57 <Peaker> kostja, there's Data.Sequence which makes taking from the end cheaper
02:23:27 <johnw> ozataman: hmm.. still getting that same error message
02:23:42 <kostja> would be nice to have a list to pattern match on the end
02:25:05 <kostja> one could match either on empty, on (x:(xs:y)), on (x:xs), on (xs:x) or otherwise on a list, which is infinite in both ends
02:25:43 <Peaker> kostja, what are you using this list for?
02:26:00 <kostja> Peaker: it's just expirementing, really
02:26:11 <kostja> Peaker: nothing productive, just playing and learning haskell
02:27:17 <Peaker> kostja, ah ok
02:28:30 <johnw> ozataman: ah, I dump the error message and it's saying I'm not authorized
02:28:36 <johnw> funny that it couldn't parse it
02:29:16 <merijn> kostja: The most efficient way to represent a list with easy append on both end would be a tree like structure
02:31:53 <kostja> merijn: something like: data L a = EOL | P a (L a) | A (L a) a
02:32:25 <kostja> EOL = the end of list with Prepend operator and Append operator
02:32:35 <kostja> then you can pattern match on P and A
02:34:57 <kostja> merijn: or do you think of something like: data T a = EOL | Node { data :: a; next :: T a; previous :: T a }
02:47:34 <blackdog> shachaf: i think i solved my TCP problem
02:47:45 <blackdog> weirdly, if i strip my binary, it fails - if i don't strip, it's fine.
02:47:51 <blackdog> ... that'd be a bug, surely?
02:58:28 <Rogach> Q: What will be the best way to read a file into "Vector Double"?
02:58:37 <Araneidae> How do I install haskell-platform on Ubuntu 13.04?  Doesn't seem to be an available package
02:59:38 <_dlnx> Araneidae: http://packages.ubuntu.com/search?keywords=haskell-platform ?
03:00:02 <Rogach> _dlnx: It's there only for precise and quantal.
03:00:11 <Rogach> _dlnx: For raring, it's missing.
03:00:18 <Araneidae> Just so
03:00:41 <Araneidae> What the hell?!  I've just tried installing darcs from the package manager .... and it wants to install postfix?!
03:00:42 <_dlnx> oh
03:00:56 <mr-> Take the first argument, convert it to an Int. If that fails, use a default
03:01:01 <mr-> Oops
03:01:08 <Rogach> Araneidae: You can install ghc and cabal, and then install haskell platform via cabal.
03:01:36 <Araneidae> Sure ... but I was hoping for a maintained install
03:01:38 <hpaste> mr- pasted “Simple command line arguments” at http://hpaste.org/87560
03:01:43 <Araneidae> Fat chance I guess
03:01:55 <Araneidae> Ok, I'll do that
03:02:17 <Rogach> Araneidae: http://askubuntu.com/questions/286764/how-to-install-haskell-platform-for-ubuntu-13-04
03:02:23 <Rogach> Araneidae: Seems that you are not alone :)
03:02:30 <mr-> Is there a nicer way (than in the paste) to take the first command line argument, read it as an Integer, and if that fails, use a default value?
03:02:46 <Araneidae> Rogach, oh, that's quite helpful.
03:02:46 <blackdog> Araneidae: darcs gets lonely, it likes to get email.
03:03:02 <Araneidae> Also tells me that simply installing ghc and haskell platform won't work.  Sigh
03:03:36 <Araneidae> darcs can stay lonely.  Every time I encounter it I get less impressed
03:04:01 <Rogach> Araneidae: Why, darcs is cool. The concept of lazy repos is totally amazing.
03:04:22 <Araneidae> If they were rock solid.  git just works.  darcs ... sometimes works
03:04:29 <Rogach> Araneidae: (I use git myself, but darcs looks quite nice once in a while)
03:04:43 <Araneidae> Also, I just discovered darcs depositing junk in my home directory.  Thanks a bunch
03:04:59 <Araneidae> It places lots of files in ~/.darcs/cache for some reason
03:05:19 <Rogach> Araneidae: That's connected to the concept of lazy repos somehow.
03:05:28 <Araneidae> What's a lazy repo?
03:05:49 <Rogach> Araneidae: When you clone git repo, you pull *everything* - down to the very first changeset.
03:05:57 <Araneidae> Sure, that's  true
03:06:09 <Araneidae> can be a bit painful, particularly when running `git svn clone`
03:06:11 <Rogach> Araneidae: When you clone darcs repo, you can chose to only get the latest version and work from that.
03:06:25 <Araneidae> whatever.  That's back to the good old days of SVN
03:06:27 <Rogach> Araneidae: And then darcs will load history "on demand".
03:06:40 <Rogach> Araneidae: Much faster.
03:06:53 * Araneidae is cynical about this "feature"
03:09:32 <Rogach> mr-: "foo $ maybe 8 id x" ?
03:09:46 <mauke> did you mean: fromMaybe
03:10:06 <Rogach> mauke: Even better.
03:10:29 <Rogach> mr-: "foo $ fromMaybe 8 x"
03:12:11 <Rogach> Q: So, how can one read a vector of doubles from the file?
03:12:26 <Chousuke> git svn clone is only painful because svn is so slow :P
03:12:28 <mr-> Ok, and the let x = (listToMaybe args >>= readMaybe) :: Maybe Integer is Okay?
03:12:49 <Rogach> mr-: It looks horrible, but I don't know a better way :(
03:12:49 <Chousuke> I've seen git repos that are in their entirety smaller than an SVN checkout of the same repository.
03:13:07 <sipa> Chousuke: that's quite common
03:13:15 <mr-> Rogach: I agree, it does ;-)
03:13:28 <mauke> svn checkouts contain every file twice, plus overhead
03:14:20 <Araneidae> Yes, I much prefer `git svn clone` for my work, even though our master repo is SVN.
03:14:38 <Araneidae> The only missing feature is the ability to delete a directory, don't know why git is missing this.
03:15:24 <Chousuke> delete a directory? :/ what happens when you try to delete one
03:15:45 <Araneidae> You can't delete a directory as such, instead you can delete all the files in a directory.
03:16:12 <Araneidae> Unfortunately when you push that change to svn the directory deletion doesn't happen, you have do that directly on svn as a separate commit.
03:18:54 <Chousuke> must be some weird mismatch in the way svn tracks directories compared to git, then
03:19:29 <Chousuke> you'd think if you remove a directory in git, git-svn would know to tell svn that it doesn't exist anymore
03:20:43 <Araneidae> I think git doesn't actually track directories as entities, so I suspect you can't add an empty directory to git.
03:22:10 <Araneidae> Yes: if you create an empty directory and run `git add emptydir` then `git status` shows there's nothing to commit.
03:22:15 <Araneidae> Sorry I'm so OT here!
03:22:41 <noteventime> Is there some simple way to see what flags Hakyll passes to Pandoc?
03:23:36 <pete_> git treats directories as tree nodes, iirc, but will ignore blank ones
03:23:47 <Araneidae> Pity about that
03:25:15 <noteventime> I can't get Hakyll to recognise my bibtex bibliography entries, while they work fine when I run Pandoc manually.
03:28:17 <noteventime> Or perhaps I should say what would be the flags corresponding to what Hakyll does (I assume it uses Pandoc as a library rather than calling to the binary).
03:28:30 <donri> you can put a .gitignore in a directory and track that :p
03:28:41 <donri> (or just use darcs dammit!)
03:28:53 <mm_freak> noteventime: yes, hakyll uses pandoc as a library
03:29:38 <mm_freak> donri: you'll be happy to know that i'm back to darcs and registered on hub.darcs.net yesterday =)
03:29:45 <donri> mm_freak: nice! :)
03:36:02 <Javran> I have some question about SICP, is here a right place to ask?
03:37:23 <MasseR> Javran: Perhaps not the best, but as its not too crowded, fire away
03:38:20 <Javran> it's exercise 1.41, http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_sec_1.3.4
03:38:40 <Javran> > let double f = f.f; inc = (+ 1) in double (double double) inc 5
03:38:41 <lambdabot>   21
03:39:05 <Javran> I want an explanation of the expression above ...
03:39:50 <isomorphic> I'm building an attoparsec parser, and I'm using <|> to combine parsers.   I want the parsers to apply according to a particular priority, since potentially multiple parsers will match from a given point in the stream, but one is preferred.  What's the proper way of expressing the priority of parsers?
03:40:18 <Rogach> Javran: First argument to function "double" is a function. "." is function composition.
03:40:56 <Rogach> Javran: So, "f . f" means something like "take a value, apply function f to it, and apply f again to the result".
03:41:04 <Rogach> Javran: It can be rewritten as follows:
03:41:36 <Rogach> Javran: let double f = \arg -> f (f arg))
03:42:59 <Rogach> Javran: Thus, "double double" returns a function, that takes another function as argument, and returns a function that will apply 4 times to the argument.
03:43:16 <Rogach> Javran: So, "double (double double) inc" => "(+4)"
03:43:48 <Rogach> Javran: Oh, wrong.
03:43:49 <wto> Rogach: eh...that is incorrect.
03:44:06 <Rogach> Javran: "double double inc" => "(+4)"
03:44:14 <wto> =)
03:44:16 <Rogach> Javran: And "double (double double) inc" => "(+16)"
03:44:28 <Rogach> Javran: And 5 + 16 is obviously 21.
03:44:43 <Rogach> Javran: Did that help?
03:46:48 <Javran> Rogach: thanks for the help, but I can't understand this part: "double (double double)"
03:47:25 <wto> Javran: (double double) becomes (\f. f f f f)
03:47:29 <Javran> I'd like to find a description of what "double (double double)" does
03:47:52 <wto> Javran: and double that will become (\f. f f f f) (\f. f f f f), which essentially becomes 4x4
03:48:38 <wto> Javran: 4x4 function calls, that is. When applied to inc that becomes 16 increments.
03:48:39 <Javran> wto: is that essentially apply "f" (2^(2^2)) times?
03:48:48 <Rogach> Javran: Yes.
03:48:55 <monoidal> more like (2^2)^2
03:49:08 <Rogach> Javran: double has type ((a -> a) -> (a -> a)), if that helps.
03:49:40 <Javran> and "double double" has exactly the same type :)
03:50:25 <Javran> seems i've got it, thank you all
03:51:04 <Rogach> Javran: You're welcome :)
03:52:26 <Rogach> Q: Still, is there some way to read those doubles from a file? Haskell is a great language for category theory stuff, but I was under the impression that it could be possible to use it for some practical causes.
03:52:50 <Rogach> Or was I wrong, since I'm trying to read a file for already half an hour without much luck?
03:53:28 <pete_> "Read doubles from a file"?
03:54:05 <Rogach> pete_: There is a file on disk, containing exactly 1000000 double-precision floating-point values (8 bytes for each).
03:54:16 <pete_> ok
03:54:21 <Rogach> pete_: I want to read them into a Vector of doubles.
03:54:29 <Javran> @pl double f = f.f
03:54:29 <lambdabot> double = join (.)
03:54:45 <typoclass> Rogach: 'readFile'?
03:54:48 <typoclass> @type readFile
03:54:50 <lambdabot> FilePath -> IO String
03:55:01 <Rogach> typoclass: I don't need a string.
03:55:15 <Rogach> typoclass: I need doubles.
03:55:18 <typoclass> Rogach: given the String, you can then use 'reads' to convert it to Double
03:55:31 <Rogach> typoclass: No, that would parse the number.
03:55:45 <Rogach> typoclass: And that file contains them in binary.
03:55:51 <Rogach> typoclass: No need to parse.
03:56:36 <pete_> Rogach: A character is conceptually a byte
03:56:43 <pete_> Rogach: So you want to read 8 bytes at a time
03:56:50 <typoclass> Rogach: i see. have you checked this? http://stackoverflow.com/questions/4643135/converting-bytes-to-int64s-floats-doubles-in-haskell
03:56:51 <pete_> Rogach: converting them in to another format
03:57:26 <Guest___> Is it possible to apply runtime compilation as in System.Eval.Haskell directly on closures instead of String source code?
04:03:04 <noteventime> Rogach: Can't you use attoparsec?
04:04:21 <noteventime> Maybe Vector even has the appropriate Binary instance
04:05:45 <noteventime> Rogach: http://hackage.haskell.org/package/vector-binary-instances
04:06:32 <Rogach> noteventime: Binary instance for vector doesn't work - it stores size alongside, so I can't just read an array.
04:06:50 <Rogach> noteventime: Haven't looked at attoparsec, will do it now.
04:08:00 <noteventime> Rogach: Well, you could do a hack and just write binary 1000000 to the top of the file
04:09:29 <noteventime> Rogach: You could also copy paste the code from the vector binary instance and change the line that reads the length
04:11:03 <noteventime> Rogach: http://hackage.haskell.org/packages/archive/vector-binary-instances/0.2.1.0/doc/html/src/Data-Vector-Binary.html
04:12:00 <noteventime> You can execute the Get on a bytestring with http://hackage.haskell.org/packages/archive/binary/0.7.1.0/doc/html/Data-Binary-Get.html#g:1
04:12:52 <pete_> I don't understand what aspect of this you're finding so difficult
04:13:19 <pete_> You have a file with binary data that you want to read 64 bits from
04:14:42 <pete_> and it looks like you're reading in little enough information that you don't even need to be clever about reading it in piecemeal
04:17:37 <pete_> http://stackoverflow.com/questions/8350814/converting-64-bit-double-to-bytestring-efficiently
04:17:40 <pete_> lots of hints in there
04:19:40 <merijn> pete_: FYI, haskell characters are *not* conceptually bytes
04:20:33 <pete_> merijn: In a theoretical sense, or in a sense that matters here?
04:21:00 <merijn> In both
04:21:01 <Garyuutensei> Hello, I'm having some trouble wih creating a function for accessing nested lists...could someone possibly help me out?
04:21:29 <merijn> Haskell Char's are unicode codepoints, so you can't assume reading String from file will give you them unmangled
04:21:30 <noteventime> Garyuutensei: Just ask, I'm sure someone can figure it out
04:21:30 <pete_> merijn: I assumed that if you'd read one from a file with getChar, you'd be reading in 8 bits of information, and ord would tell you which
04:21:50 <merijn> No, getChar reads a unicode codepoint in whatever encoding is specified
04:22:16 <pete_> Is "no encoding" the default?
04:22:18 <merijn> Garyuutensei: You might want to paste the code, input, error and what you expected at hpaste.org
04:22:29 <Garyuutensei> so, I want to create a function which takes a list with the indices (e.g. [i,j,k]) and returns the element at that index).
04:22:40 <merijn> The default should be whatever LC_foo specifies
04:23:08 <Garyuutensei> in principle it should look something like: foldr (.) id (map myIndex [i,j,k])
04:23:10 <merijn> LANG/LC_ALL/LC_CTYPE should specify encodings, maybe default to UTF-8?
04:23:21 <Garyuutensei> where myIndex is : flip (!!)
04:23:48 <noteventime> Garyuutensei: \indxs lst -> map (!! lst) indxs ?
04:23:58 <Garyuutensei> of course, I can't use foldr because the accumulated function is different at every step
04:24:00 <noteventime> Oh, nevermind
04:24:03 <noteventime> I understand now
04:24:13 <pete_> interesting
04:24:21 <merijn> Garyuutensei: Should work if you recurse manually, without fold
04:25:18 <Garyuutensei> merijn
04:25:20 <typoclass> pete_: Char means "one unicode thingy". there are much more than 256 of those, and a Char won't generally fit in 1 byte. if you'd convert a Char to bytes with the old utf-16 encoding, it'll most likely show up as 2 bytes, but certain Chars show up as 4 bytes. with utf-8, a Char can be anything from 1 to 5 or 6 bytes (i think)
04:25:24 <Garyuutensei> thanks, I'll try that
04:26:14 <Peaker> utf-16, combine the complexity of utf-8 with extra 100% non-compactness and lose ASCII compatibility along the way :P
04:26:39 <noteventime> Wouldn't you have to make it a type class?
04:26:48 <merijn> Garyuutensei: Hmm, it might be less trivial than I first implied...
04:27:10 <typoclass> Peaker: yeah, well, afaik it was designed when unicode actually would fit in that. it was straightforward, but they later expanded unicode and it wouldn't fit anymore, requiring the complexity
04:27:46 <Peaker> typoclass, they thought Unicode will only cover a few languages at first?
04:27:53 <merijn> typoclass: Unicode never fit in 16bit, it's just that people thought "meh, screw the asians"
04:29:46 <typoclass> Peaker: who knows
04:29:53 <Garyuutensei> I tried using manual recursion and got the same error
04:30:05 <noteventime> Garyuutensei: The problem is that the type checker can't know that the length of the index list is the same as the depth of the second list
04:30:15 <Garyuutensei> Occurs check: cannot construct the infinite type: c0 = [c0] Expected type: [c0] -> [c0]   Actual type: [c0] -> c0
04:30:19 <Garyuutensei> yes
04:30:23 <noteventime> Or even that the list of indexes is finite
04:31:06 <merijn> Garyuutensei: This is possible, but you'd probably have to use a special Vector type for the indices to encode the length
04:31:15 <merijn> Maybe there's some lens voodoo you could use here?
04:31:20 <noteventime> Garyuutensei: You migth be able to get around it using statically "sized" lists
04:31:21 <Garyuutensei> any work around or should I just do it by hand i.e. nestedIndex [i, j, k] = myIndex k . myIndex j . myIndex i ?
04:31:49 <Peaker> merijn, "screw the asians" by making programs that crash if asian codepoints are used, or by adding complexity to handle asian anyway? I don't get it
04:32:07 <Garyuutensei> yes, in principle I'm protyping using lists, in the future I want to use some other kind of container
04:32:10 <noteventime> You should then be able to have a type family that associates index list of a certain length to nested lists of that depth
04:32:34 <merijn> Peaker: By not allowing asian codepoints
04:32:52 <merijn> Peaker: Just limit what you can encode and substitute the rest with "character missing" symbol
04:32:59 <Garyuutensei> noteventime: You mean using something like a vector?
04:33:06 <Peaker> merijn, oh
04:33:51 <merijn> Garyuutensei: I can think of ways to implement this using type functions + vectors that encode their length or typeclasses but it'd be a bit tricky, so it depends how comfortable you are with haskell
04:33:51 <noteventime> Garyuutensei: What kind of vector are you talking about? Data.Vector?
04:34:16 <typoclass> merijn: http://en.wikipedia.org/wiki/UTF-16 seems to say that at the time (17 years ago, unicode 1.x), 16 bits were sufficient to represent all existing codepoints
04:34:19 <Garyuutensei> yes
04:35:06 <Garyuutensei> noteventime: This is actually my first project. I'm trying to port a Monte Carlo Simulation I've written in C.
04:35:28 <Rogach> noteventime: I tried copying & changing the code from that vector binary instance, but now it gives me "too few bytes. Failed reading at byte position 8000001" even if I try to read a list of length 1.
04:35:41 <typoclass> anyway, nobody is saying that utf-16 is state of the art. in my opinion nobody should use it, it's superseded
04:36:15 <noteventime> Rogach: Could you pastebin exactly the code you used?
04:36:21 <Rogach> noteventime: Sure.
04:37:19 <hpaste> Rogach pasted “readMilDoubles” at http://hpaste.org/87563
04:37:25 <noteventime> Garyuutensei: Then it might be a little tricky. I can throw something together (though I'm far from an expert on this), so that you can see kinda how it'd work, but it requires some language extensions (type families and GADTs)
04:37:50 <noteventime> And you couldn't use regular lists for you indices
04:38:04 <noteventime> You'd have to use a special kind where the length of the list is encoded in the type
04:38:40 <merijn> Might wanna chant edwardk three times and see if he can solve your problem with a simple lens expression ;)
04:38:42 <noteventime> (It'd be a little bit like having an int template argument encoding length in C++)
04:39:19 <Garyuutensei> noteventime: Thanks a lot but I don't think I want to go so deep into haskell yet
04:40:03 <Garyuutensei> I guess I'll go with something simpler for now. I just wanted to know if I'm possibly missing some way using Monads
04:40:09 <merijn> Garyuutensei: Do you ever need to go nested deeper than just a handfull of arguments?
04:40:23 <merijn> Btw, nested lookups like !! are going to perform abysmally
04:40:28 <Garyuutensei> merijn: No, just 3 levels
04:40:29 <merijn> !! is O(n) complexity
04:40:49 <merijn> Garyuutensei: ok, then I'd just say writing them by hand will be simplest
04:41:01 <Garyuutensei> yes, I know. I'm gonna use Data.Vector after having something functioning correctly
04:43:13 <hpaste> noteventime pasted “Static size lists and funny recursion” at http://hpaste.org/87564
04:43:50 <noteventime> Garyuutensei: See the paste if you're still curious
04:45:24 <noteventime> Rogach: That's not the binary instance from vector-binary-instances though
04:47:26 <Garyuutensei> noteventime: Thanks, that looks interesting although I don't understand much :P
04:47:54 <merijn> noteventime: Seems overly complex
04:47:54 <Rogach> noteventime: Sorry, I can't see the difference between their code and my code. I copied the "getMany" method, and then got a Get instance for a list of doubles.
04:48:23 <Rogach> noteventime: Doing V.fromList inside Get monad doesn't help, either.
04:49:09 <merijn> hmm, maybe not
04:49:15 <noteventime> merijn: Well, it's the first type family things I've written :P so there's probably an easier way to do it. At least it works though
04:49:26 <merijn> noteventime: Needs more DataKinds ;)
04:50:03 <noteventime> And it wrote it only to illustrate kinda how it'd work
04:50:43 <noteventime> Rogach: Perhaps this is me being daft, but http://hackage.haskell.org/packages/archive/vector-binary-instances/0.2.1.0/doc/html/src/Data-Vector-Binary.html <- That contains a bunch of unsafe* trickery
04:50:57 <hpaste> “Anonymous Coward” annotated “Static size lists and funny recursion” with “Static size lists and funny recursion (annotation)” at http://hpaste.org/87564#a87566
04:51:19 <merijn> noteventime: See that one :p
04:51:47 <Rogach> noteventime: You're right, I was looking on outdated version :(
04:52:03 <noteventime> Rogach: I'm not saying your version shouldn't work
04:52:13 <Rogach> noteventime: Well, it doesn't ;)
04:52:25 <noteventime> Give the new one a try
04:52:35 <noteventime> Just replace n <- ... with let n = 1000000
04:53:46 <noteventime> merijn: You're right! I'd forgotten about DataKinds :)
04:55:03 <noteventime> Garyuutensei: Are you using nested lists for three dimensional arrays?
04:55:08 <merijn> noteventime: Now even your types get typechecked there ;)
04:55:20 <noteventime> Indeed
04:55:35 <doaitse> Is it possible to have more than one .cabal file in the same directory?
04:55:50 <merijn> doaitse: I don't think so, but why would you need to?
04:55:52 <Garyuutensei> Garyuutensei: Yes
04:56:31 <doaitse> So I can have several packages in a single source tree and test them together using ghci
04:56:36 <noteventime> Garyuutensei: Was that directed at me or are you talking to yourself? :)
04:56:55 <Garyuutensei> noteventime: Yes :P
04:57:19 <noteventime> Garyuutensei: The interface isn't entiretly non-trivial, but you might want to check out Repa
04:57:32 <Garyuutensei> I haven't used irc for over a decade so I'm just jcopy pasting names, is there an easier way?
04:57:44 <noteventime> Many clients have tab completion
04:57:53 <Garyuutensei> ah, ok
04:58:28 <noteventime> Garyuutensei: I'm not sure how up to date it is: http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Repa_Tutorial
04:58:32 <noteventime> But that might be of interest
04:59:55 <Garyuutensei> noteventime: Is Repa just a parallel Data.Vector or are they totally different?
05:00:30 <noteventime> Garyuutensei: It uses Data.Vector, but adds a bunch of things on top of it, such as "multidimensional" arrays
05:00:44 <Rogach> noteventime: This is beginning to get funny. New version, pasted & used almost verbatim, still gives me the same error.
05:00:49 <noteventime> In the sense that the dimension of the array can be seen in the type, and you don't have to compute the indexes
05:00:52 <Rogach> noteventime: I'll repaste the complete code.
05:00:54 <Athas> I have a Haskell source file that uses a lot of quasiquotation.  For some reason, it is very slow to compile.  It's plenty fast to load and interpret in GHCi, but native code generation takes forever.
05:01:14 <Athas> I am quite certain that code generation is what takes a long time, as it's quite fast at providing type errors.
05:01:24 <noteventime> Rogach: Just to be absolutely sure, you know the file not to be corrupt?
05:01:24 <hpaste> Rogach pasted “readMilDoubles2” at http://hpaste.org/87567
05:01:27 <Athas> How could this be?  In case it matters, I'm using the quasiquoters from language-c-quote.
05:01:41 <Garyuutensei> noteventime: Thanks that looks as an interesting candidate to replace my nested list
05:02:49 <Rogach> noteventime: How *can* it be corrupt?
05:02:58 <Rogach> noteventime: It's just numbers?
05:03:00 <noteventime> Rogach: I mean, you know it to be large neough
05:03:24 <noteventime> Garyuutensei: The parallel part feels a little like using OpenMP, if you're familiar with that
05:03:41 <Rogach> noteventime: Yes, it's exactly 8000000 bytes.
05:03:45 <noteventime> Hmm
05:04:07 <Rogach> noteventime: But I'm currently trying to read only 10 doubles, so even if I messed up my math, it still should work.
05:05:17 <Rogach> noteventime: Actually. I tried feeding in a file consisting of zeroes, and it worked.
05:05:55 <noteventime> Rogach: Try writing a file first
05:05:55 <Rogach> noteventime: But when I try feeding in the file with numbers, it thinks for 1-2 seconds, than fails. How could that be? After all, it should be looking only at first bytes?
05:06:17 <noteventime> i.e. try reading a file created by haskell
05:06:58 <Rogach> noteventime: Ugh? How can doubles in haskell be different from any other doubles?
05:07:41 <Rogach> noteventime: Correct me if I'm wrong, but I'm under assumption that *any* 8 bytes, lumped together, should be representing valid double.
05:07:43 <noteventime> Rogach: Well, it accepts some files and not others, so I figured it might be worth checking whether it's actually 0 files in specific it likes, or if it just happens to disagree with the one you have
05:07:46 <hamid> :t (.|.)
05:07:48 <lambdabot> Bits a => a -> a -> a
05:07:56 <hamid> @src (.|.)
05:07:56 <noteventime> Rogach: I thought so too
05:07:57 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
05:08:05 <typoclass> Rogach: i don't know, but could it be something like "Data.Binary prefixes things with their length"? this would explain why reading a file consisting of zeroes worked
05:08:18 <hamid> lol
05:09:20 <Rogach> typoclass: That would be strange - Data.Binary has no way of knowing the length of the data beforehand?
05:09:59 <noteventime> Well, in theory it would reserve space for size beforehand, and fill it in when run
05:10:12 <noteventime> Not that I think that is what it does
05:11:19 <noteventime> And it seems strange, considering it's, I think, supposed to be able to do lazy output
05:11:21 <typoclass> Rogach: i don't know. for lists, it indeed wouldn't know the size beforehand. for e.g. a Char, it would know
05:11:58 <Rogach> typoclass: It can't. It uses Get and Put monads for input/output - all byte mangling happens inside them.
05:12:39 <Rogach> typoclass: For example, Get instance for Vector indeed stores the length as first (8?) bytes, then stores the contents - but that info doesn't go anywhere.
05:13:15 <typoclass> Rogach: who knows. i have no clue about Data.Binary, i was just speculating
05:13:36 <typoclass> Rogach: regarding your original problem, have you seen this package http://hackage.haskell.org/packages/archive/data-binary-ieee754/0.4.3/doc/html/Data-Binary-IEEE754.html ?
05:16:37 <Rogach> typoclass: O! That helps.
05:17:26 <noteventime> Rogach: Not that it helps, but it doesn't work here either :)
05:17:38 <Rogach> noteventime: :)
05:22:02 <Breadmonster> Is Jane Street still hiring?>
05:22:29 <noteventime> Rogach: I tried just using 'runGet get', same error
05:22:48 <pete_> Breadmonster: I thought they were always hiring
05:22:53 <noteventime> Looks like the Binary Double instance doesn't work the way I thought
05:23:11 <Breadmonster> I hope so.
05:24:35 <noteventime> Rogach: I found something that might be strange
05:24:46 <noteventime> Or actually, the Double instance is quite weird
05:24:52 <noteventime> It uses encodeFloat
05:25:04 <Rogach> noteventime: typoclass's suggestion helps a bit - it is now able to load 10 floats, but the full file overflows the stack :(
05:25:27 <noteventime> Rogach: Well, I think I found the problem at least
05:25:49 <noteventime> get for doubles is defined by 'liftM2 encodeFloat get get'
05:26:02 <noteventime> where encodeFloat :: RealFloat a => Integer -> Int -> a
05:26:43 <noteventime> Rogach: Are you using the vector instance from vector-binary-instances""
05:26:45 <noteventime> ?*
05:26:45 <lambdabot> Maybe you meant: . ? @ v
05:27:02 <Rogach> noteventime: I'll paste the full code, to avoid misunderstanding.
05:27:03 <noteventime> Just replace the call to get with the call to getFloat64*
05:28:28 <hpaste> Rogach pasted “readMilDoubles3” at http://hpaste.org/87569
05:29:07 <Rogach> noteventime: If I replace "get" at line 40 with getFloat64be, I get 20-line long compiler error.
05:30:27 <hpaste> noteventime revised “readMilDoubles3”: “once more...” at http://hpaste.org/87569
05:30:47 <Zariel> When using parsec is it possible to parse a subset of the document using lookAhead and then parse it again ?
05:31:15 <noteventime> Rogach: Did you make sure to change the signature? (it can't parse general a any longer, only doubles now)
05:33:16 <typoclass> Rogach: don't worry about long compiler errors. they can be intimidating at first, but usually they tell you fairly precisely what's wrong. if it's difficult to figure out, feel free to paste the error message and relevant code to hpaste.org
05:33:33 <noteventime> Rogach: See if my final paste works, I havne't tried it. I have to go, sorry I couldn't be of more help :/
05:35:17 <Rogach> noteventime: Thanks a lot! (that paste works for 999999 doubles out of 1000000, the last double still fails)
05:36:30 <Rogach> typoclass: I already understood that message, thanks! (it was saying that "a" is not a "Double" in that case)
05:36:42 <typoclass> Rogach: alright :-)
05:37:42 <Peaker> did anyone notice hlint becoming much slower at some point? It takes ages to go through my code-base with 1.8.43
05:40:34 <Rogach> noteventime: By the way, skipping all that "toFloat" stuff with unsafeCoerce makes run-time 2 times faster.
05:52:51 <jbackus> @gwern could I pm you real quick?
05:52:52 <lambdabot> Unknown command, try @list
05:55:31 <hpaste> jermey pasted “jermey” at http://hpaste.org/87574
05:56:31 <noteventime> Rogach: Neat, there's also a type CDouble for, as it were, C doubles, in the foreign interface, dunno if it's of any use
05:57:11 <jermey> hey guys i am unsure difference between untyped and typed
05:57:11 <jermey> http://hpaste.org/87574
05:57:14 <jermey> thats untyped
05:57:18 <jermey> anyone have some good links?
05:57:33 <jermey> searching myself didn't help
05:59:27 <Rogach> noteventime: Well, I thought that if stuff really gets sad, I will just put the bytes into memory using C and then unwrap them for haskell.
06:00:06 <Rogach> noteventime: But hey, c'mon, it's just numbers! Bytes here, bytes there, why should I need to spend 3 hours juggling some "Get monad" to get them into an array?
06:00:26 <Rogach> noteventime: Even C, grumpy grandmother of all languages, does that like a breeze.
06:01:15 <Rogach> That said, I like haskell a lot - it only gets messy when I try to do something with files or guis.
06:01:52 <typoclass> Rogach: i agree that Data.Binary is hard to figure out. the documentation didn't make things clear to me
06:07:31 <noteventime> Rogach: "even C", I'd say that's what C is good at
06:07:57 <noteventime> Well, one of its main strengths anyway
06:08:11 <noteventime> Rogach: I kinda agree though, numeric stuff is rather fiddly
06:08:38 <noteventime> As far as I've been able to tell there aren't any sparse linear algebra libraries
06:10:18 <noteventime> Rogach: What happens if you unsafeCoerce a bunch of word64's in attoparsec?
06:11:04 * hackagebot scion-browser 0.2.16 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.2.16 (JeanPhilippeMoresmau)
06:11:52 <typoclass> noteventime: oh wait, couldn't we just unsafeCoerce a Word64 to Double?
06:11:57 <typoclass> (attoparsec or not)
06:14:00 <noteventime> typoclass: I think that's what Rogach has been doing
06:14:11 <noteventime> But someone it stops early
06:14:13 <noteventime> somehow*
06:14:19 <Peaker> Rogach, Doing a read from a file and a binary decode in Haskell into arbitrary data is much easier than in C
06:14:28 <Rogach> Peaker: Sure.
06:14:36 <Rogach> Peaker: But that's when it's decode.
06:14:43 <jermey> hey does anyone here offer haskell tutoring online? (i m willing to pay)
06:14:48 <Peaker> if you just want a byte array you can do a ByteString.get ?
06:14:53 <Peaker> pretty easy, isn't it?
06:15:04 <Rogach> Peaker: No, it isn't.
06:15:05 <typoclass> noteventime: oh sorry. haven't been looking at the hpastes :-/
06:15:11 <Rogach> Peaker: O
06:15:25 <aristid> jermey: maybe not exactly what you want but take a look at this: https://www.fpcomplete.com/
06:15:27 <noteventime> typoclass: :) Didn't mean to sound harsh
06:15:39 <typoclass> noteventime: ok no worries =)
06:15:50 <Peaker> Rogach, hGet :: Handle -> Int -> IO ByteString
06:15:52 <Rogach> Peaker: I may be not smart enough, I may not have enough experience, but still, I don't consider myself to be in 10% worst programmers group.
06:16:19 <jermey> thanks aristid but i am kinda after someone who i can just chat to and ask questions
06:16:28 <noteventime> jermey: You can do so for free here
06:16:29 <Rogach> Peaker: And when I spend 3 hours getting doubles from disk to memory, I believe that something was not *easy enough*.
06:16:39 <Rogach> Peaker: Sure, that's for bytes.
06:16:41 <typoclass> Peaker: Rogach and the channel have been talking for several hours about reading some Doubles from a binary representation
06:16:42 <Peaker> Rogach, withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r          so:   withFile "foo" ReadMode $ \handle -> do { myArray <- hGet handle 20 ; ... }
06:17:07 <Rogach> Peaker: Now, can you get a Vector of Doubles from that? (without looking at my solution :) )
06:17:26 <noteventime> Peaker: The problem has been in parsing the bytestring
06:17:29 <Peaker> Rogach, let me :bro Vector
06:17:47 <noteventime> Preferably, I think, into a Vector
06:17:54 <aristid> Peaker: does :bro amuse you every time you use it? :)
06:18:05 <noteventime> Haha
06:18:21 <Rogach> ;)
06:18:33 <Peaker> Rogach, BSL.readFile "foo" >>= runGet get :: IO [Double] ?
06:18:39 <Peaker> oops:
06:18:46 <Breadmonster> A CS question: how enabling is Turing completeness?
06:18:46 <Rogach> Peaker: Now, try running that :)
06:18:48 <Peaker> runGet get <$> BSL.readFile "foo" :: IO [Double] ?
06:19:06 <Peaker> Rogach, first I need some Doubles written to a file in this format
06:19:07 <Breadmonster> Can you, for instance, write a load balancer in Brainfuck?
06:19:15 <fizbin> I seem to have screwed up writing my cabal file.
06:19:41 <Rogach> Peaker: There's no format - double is simply 8 bytes, after all. So you have a 8000000-byte file, containing 1000000 doubles.
06:19:45 <noteventime> Breadmonster: Google for total functional programming
06:19:56 <Rogach> Peaker: If you are on linux, "head -c 8000000 > file" will give you that file.
06:20:02 <typoclass> Breadmonster: i guess turing completeness is the bare minimum?
06:20:05 <noteventime> brett: Or do you mean something specific by "enabling"?
06:20:12 <fizbin> Help? I wrote my cabal file and included a build-depends line that says "build-depends: base, xml, lens, mtl, containers, hxt, fgl"
06:20:16 <Rogach> Peaker: Sorry, head -c 8000000 /dev/urandom > file
06:20:23 <fizbin> Now Setup.hs configure tells me:
06:20:32 <fizbin> Setup.hs: At least the following dependencies are missing:
06:20:32 <fizbin> lens -any, xml -any
06:20:40 <Peaker> Rogach, Double is not "simply 8 bytes"
06:20:43 <fizbin> But I have those packages installed.
06:20:47 <Peaker> Rogach, there are many ways to encode a Double
06:20:54 <fizbin> I mean, I've been coding with them for months.
06:20:57 <Rogach> Peaker: Let's assume IEEE754 double here.
06:20:59 <Breadmonster> typoclass: No, my question had basically two parts.
06:21:01 <Peaker> Rogach, I just wrote some doubles with runPut/put/writeFile, then read them, no problem
06:21:10 <Peaker> Rogach, ok
06:21:19 <Breadmonster> typoclass: If I give you a Turing incomplete language, how much useful stuff can you do with it?
06:21:26 <supki> fizbin: are you using runhaskell Setup.hs configure?
06:21:35 <fizbin> Yes.
06:21:52 <Breadmonster> typoclass: And if I gave you a bare bones language that's Turing complete (think brainfuck), how much useful stuff can you do with it?
06:21:53 <Rogach> Peaker: I had no problem reading a single double, either. Fun began when I tried to read a lot of them and store into Vector.
06:21:54 <supki> fizbin: it searches in global database by default, try with --user
06:21:55 <geekosaur> fizbin, you probably want to use 'cabal install' (no package). otherwiise, add the --user option
06:21:57 <noteventime> Breadmonster: Well, Agda, Coq, Epigram, e.t.c. aren't (unless you cheat) turing complete, and they're quite useful
06:22:19 <fizbin> Is that a consequence of using runhaskell?
06:22:24 <Peaker> Rogach, replicateM to read them?
06:22:30 <Peaker> Rogach, or loop until Get monad says EOF?
06:22:30 <supki> fizbin: cabal configure, on the other hand, searches in --user by default
06:22:33 <Breadmonster> noteventime: Hmm, alright, that's the first part of the question solved.
06:22:37 <Peaker> Rogach, and then Vector.fromList ?
06:22:43 <geekosaur> Setup.hs defaults to global, cabal install defaults to local
06:22:51 <typoclass> Breadmonster: hmm, i see. my hunch is that turing-completeness and usefulness are pretty independent
06:22:52 <Breadmonster> noteventime: But as I said, can you use Brainfuck to write a load balancer?
06:22:57 <geekosaur> if you install global, then only global packages can be deps
06:23:10 <Breadmonster> typoclass: Okay, that's what I was looking for.
06:23:10 <Peaker> Rogach, http://hackage.haskell.org/package/data-binary-ieee754-0.4.3
06:23:14 <Rogach> Peaker: I did replicateM + V.fromList, and got error "too few bytes. Failed reading at byte position 8000001"
06:23:18 <Breadmonster> Thanks guys :)
06:23:44 <noteventime> Breadmonster: You could do it in Brainfuck, as long as it has some kind of IO ability
06:23:50 <noteventime> Well, "could"
06:23:55 <noteventime> In a theoretical sense
06:23:59 <Peaker> Rogach, what was the get computation?
06:24:10 <geekosaur> fizbin, basically running Setup.hs directly uses an older default which has been found to be less than helpful in practice, therefore cabal-install uses a more sensible default. but for historical reasons we cant really change the old default
06:24:24 <fizbin> ok
06:24:35 <Breadmonster> noteventime: Alright, but even with IO I can't do system critical tasks, right?
06:24:39 <Rogach> Peaker: That's my original attempt: http://hpaste.org/87563
06:25:09 <Rogach> Breadmonster: Why is that?
06:25:29 <merijn> Breadmonster: You could, but you probably don't want to
06:25:36 <Breadmonster> Ah, forget it, I've confused my argument.
06:25:57 <Breadmonster> merijn: I don't; just wanted to know what was theoretically possible.
06:26:15 <merijn> Breadmonster: Sure, you just need some way to do system calls and you could do that
06:26:27 <Peaker> Rogach, in ghci: runGet (replicateM 10 getFloat64le) <$> LBS.readFile "/tmp/foo"    on /dev/urandom:  [-8.0223299043666e250,-5.876914614098716e-263, ...]
06:26:27 <Rogach> Peaker: I can paste my current code, if you would be able to make it shorter, I would be very grateful :)
06:26:38 <Breadmonster> merijn: Ah, alright.
06:26:44 <merijn> Breadmonster: In fact, it should be relatively simple to write a linux kernel module that's a brainfuck interpreter and can control any OS task
06:26:45 <Peaker> Rogach, this didn't take long... but I do practice Haskell many hours every day for a while now
06:27:08 <Rogach> Peaker: Let me try this on my file.
06:27:15 <noteventime> Breadmonster: Well, I don't know how standardised Brainfuck is, so it depends on much it can interact with the machine. Given a brainfuck interpreter, though, you could write an operating system on top of it
06:27:28 <Breadmonster> noteventime: Alright.
06:27:31 <Peaker> Rogach, getFloat64le is from Data.Binary.IEEE754 from the data-binary-ieee754 package
06:27:36 <merijn> Breadmonster: Let's say an afternoon to a day of work to get a brainfuck interpreter in the kernel, then you only need to write some stuff to make it control kernel things :)
06:28:01 <noteventime> merijn: "only"
06:28:10 <Kinnison> noteventime: BF is (typically) defined to have an infinite byte tape and a non-rewindable bytewise input/output stream
06:28:28 <merijn> noteventime: Well, you just need to define a brainfuck IO to do system call stuff
06:28:30 <Kinnison> noteventime: that's all that is "standard" in terms of its IO
06:28:52 <merijn> It's conceptually very easy, just hard to make it do something useful :)
06:29:15 <Rogach> Peaker: I use "fmap unsafeCoerce getWord64", instead. 2 times faster.
06:29:29 <Rogach> Peaker: getWord64be, that is.
06:30:14 <noteventime> So I guess you could just write it up so that the IO stream produces syscalls
06:30:17 <noteventime> I guess the obvious follow up question is whether we can implement device drivers in Malbolge
06:30:56 <merijn> noteventime: Probably not
06:30:58 <Peaker> Rogach, I tend to avoid "unsafeCoerce" in my code :P
06:31:10 <Rogach> Peaker: Of course. But 2 times?
06:31:53 <merijn> Breadmonster: Anyhoo, that should answer both sides of your question ;)
06:31:53 <Peaker> Rogach, sounds like a patch for that package is due :)
06:32:10 <Breadmonster> merijn: Indeed.
06:33:09 <notdan> I have a question about type families. If I have the following class: http://paste.lisp.org/display/137089 , how do I enforce n ~ CoNode (CoNode n)?
06:33:11 <Breadmonster> merijn: Thank you, once again.
06:33:22 <notdan> Well, not enforce, but allow the compiler to deduce that
06:33:38 <Rogach> Peaker: "Stack space overflow: current size 8388608 bytes"
06:33:56 <merijn> Breadmonster: For a non-brainfuck (C, actually, but it should probably illustrate "silly ways to do systems stuff with just IO") example: http://www.dunkels.com/adam/twip.html
06:34:17 <hpaste> Rogach pasted “readDoubles” at http://hpaste.org/87576
06:34:29 <merijn> Breadmonster: That uses just read/write, so if you map brainfuck IO to read/write calls you could easily do the same in brainfuck
06:34:38 <Rogach> Peaker: ^^ that's the code I used (LBS => BS)
06:34:59 <Rogach> Peaker: And it gives stack overflow.
06:34:59 <Breadmonster> Oh, okay.
06:35:18 <noteventime> notdan: Couldn't you write an instance for Node CoNode?
06:35:27 <Rogach> Peaker: That's exact problem I had with replicateM previously.
06:36:02 <merijn> noteventime: You want to implement equality for types?
06:36:30 <noteventime> merijn: ?
06:36:38 <merijn> noteventime: Depending on your GHC version that's either *really* complicated or *really* simple
06:36:39 <noteventime> Oh, it's a type CoNode
06:36:57 <merijn> Wait
06:37:04 <merijn> I maybe should have read more :p
06:37:29 <notdan> noteventime: I tried the follwing: http://paste.lisp.org/+2XS1/1
06:37:37 <no-n> @src >>=
06:37:37 <lambdabot> Source not found.
06:37:39 <notdan> but it doesn't compile: Illegal type synonym family application in instance: CoNode n
06:37:40 <notdan> In the instance declaration for `Node (CoNode n)'
06:37:42 <no-n> @src (>>=)
06:37:43 <lambdabot> Source not found. You untyped fool!
06:37:43 <merijn> noteventime: What would "n ~ CoNode (CoNode n)" mean?
06:37:49 <merijn> That seems nonsensical
06:37:51 <hpaste> fizruk pasted “traversing leaves problem” at http://hpaste.org/87577
06:38:03 <noteventime> merijn: Why, it jsut says CoNode is involutive
06:38:05 <notdan> merijn: that doesn't seem nonsensical at all :S
06:38:39 <fizruk> hi! how can I resolve problems in the code, marked with XXX? http://hpaste.org/87577
06:38:44 <merijn> How can "n" unify with "CoNode (CoNode n)"?
06:38:48 <notdan> In fact, right now in order to make my functions more generic I have to add manually (Node n, Node (CoNode n), n ~ CoNode (CoNode n)) typing context to my type signature
06:39:04 <notdan> merijn: well, why can't it?
06:39:06 <noteventime> merijn: It's a type, not a data/newtype
06:39:33 <noteventime> Actually, it would be pretty typical for anything called Co
06:39:36 <notdan> merijn: see my paste, it's an associated type
06:40:55 <noteventime> notdan: I think this won't work though
06:41:01 <noteventime> Since implementing any Node
06:41:09 <noteventime> Would automatically create a new instance
06:41:15 <noteventime> (since it's the dual to its dual)
06:42:05 <noteventime> instance Node n => instance Node (CoNode n) => instance Node (CoNode (CoNode n)) == instance Node n
06:42:33 <noteventime> So you'd need to ensure both those instances coincide, and somehow get GHC to accept that
06:42:51 <fizruk> I'm no expert, but wouldn't it be neater to define Node and CoNode in a multiparam type class? like class DualNodes n m | n -> m, m -> n where …
06:43:02 <noteventime> afaik that would, at best, require something like undecidable instances
06:43:18 <noteventime> fizruk: Sounds reasonable
06:44:19 <hpaste> jermey pasted “jermey ” at http://hpaste.org/87578
06:44:35 <notdan> noteventime: yeah it's not allowed, http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/type-families.html see 7.7.2.4 :(
06:44:36 <noteventime> fizruk: You'd still run into the problem that you'd want to derive an "instance DualNodes m n" from an "instance DualNodes n m"
06:45:24 <noteventime> I have to go
06:45:43 <Peaker> Rogach, replicateM/sequence have a problem in strict monads, iirc
06:45:47 <noteventime> notdan: The multiparameter type class approach sounds, I think, more promising
06:46:51 <notdan> noteventime: why?
06:47:07 <notdan> (Genuine question tho, I don't want to rewrite my codes :p )
06:47:17 <Peaker> Rogach, you might need to use a tail-recursive definition to avoid stack overflows
06:47:57 <noteventime> notdan: Because it would, as far as I can see, work? :) You'd need two instances for every Node/CoNode pair though
06:48:00 <mm_freak> :t foldr (flip $ liftA2 maybe id (flip (:))) []
06:48:04 <lambdabot> [Maybe a] -> [a]
06:48:12 <notdan> noteventime: yeah, a lot of boilerplate code
06:48:25 <Rogach> Peaker: That's what I did, yes.
06:48:32 <notdan> noteventime: using type families approach only adds additional boilerplate type signature stuff :D
06:48:39 <noteventime> True
06:48:45 <notdan> which is not perfect, but whatever
06:49:00 <noteventime> notdan: Wasn't there some way to have contexts aliases nowadays?
06:49:07 <notdan> I am really liking all those slick GHC extensions
06:49:13 <noteventime> If so, it could at least reduce the boilerplate
06:49:15 <notdan> noteventime: oh, that's a nice question, I am not sure actually
06:49:16 <notdan> yeah
06:49:20 <noteventime> Anyway, I really have to leave
06:50:44 <notdan> ah, bye
06:58:04 <jermey>  http://hpaste.org/87578
07:24:23 <Sculptor> yo
07:24:38 <jermey> yo
07:26:55 <fizbin> @type let fp f x = (f . (<*>)) . x in fp id pure
07:26:57 <lambdabot> Applicative f => (a -> b) -> f a -> f b
07:27:14 <fizbin> @type let fp f x = (f . (<*>)) . x in (fp . fp . fp) id pure
07:27:16 <lambdabot> Applicative f => (a -> a1 -> a2 -> b) -> f a -> f a1 -> f a2 -> f b
07:27:34 <fizbin> @type let fp f x = (f . (<*>)) . x in (fp . fp . fp . fp . fp) id pure
07:27:37 <lambdabot> Applicative f => (a -> a1 -> a2 -> a3 -> a4 -> b) -> f a -> f a1 -> f a2 -> f a3 -> f a4 -> f b
07:28:14 <fizbin> Does fp as I've used it there have a name? I think it should, given that it does something basic like that.
07:29:02 <simpson> :t (<$>)
07:29:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:29:27 <simpson> I think that's what you're getting at?
07:29:53 <ocharles> or :t fmap
07:29:56 <ocharles> :t fmap
07:29:58 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:30:21 <t7> fmap should be called map in haskell 2.0
07:30:25 <fizbin> Well, <$> could be defined as "fp id pure". The point is that fp can build, from id and pure, fmap and all the liftA* functions.
07:30:27 <ocharles> we all know that
07:30:46 <ocharles> (that was to t7)
07:33:30 <fizbin> E.g., liftA3 is (fp . fp . fp) id pure
07:34:00 <fizbin> @type let fp f x = (f . (<*>)) . x in fp
07:34:03 <lambdabot> Applicative f => ((f a1 -> f b) -> c) -> (a -> f (a1 -> b)) -> a -> c
07:34:12 <fizbin> @hoogle ((f a1 -> f b) -> c) -> (a -> f (a1 -> b)) -> a -> c
07:34:13 <lambdabot> No results found
07:34:36 <simpson> fizbin: So, this result is known, and this is why the Applicative class only requires fmap, pure, and <*>.
07:35:53 <fizbin> Well, I guess I knew that it was possible to build fmap, liftA* from just pure and (<*>), I just hadn't seen a way of building it in pointfree style that didn't get amazingly ugly quickly.
07:36:35 <fizbin> @pl let fp f x = (f . (<*>)) . x in fp
07:36:36 <lambdabot> (.) . (. (<*>))
07:37:54 <fizbin> Also, the other attempts I'd seen to write it in pointfree style never managed to make the result into a nice pattern.
07:46:17 <monoidal> fizbin: fwiw you don't need parens: f . (<*>) . x
07:50:27 <gwern> blackdog: no idea
07:51:02 <tomejaguar> Is there a formatting library that will put thousands separtors when it formats numerical values?
07:51:10 <tomejaguar> *separators
07:52:24 <mm_freak> > intercalate "," . reverse . map show . takeWhile (not . null) . map (`mod` 1000) . iterate (`div` 1000) $ 12345678
07:52:26 <lambdabot>   No instance for (GHC.Real.Integral [a0])
07:52:26 <lambdabot>    arising from a use of `GHC.Real...
07:52:48 <simukis_> mm_freak: Doesn't account for locale settings.
07:52:57 <mm_freak> i'm just experimenting
07:53:28 <mm_freak> > intercalate "," . reverse . map show . takeWhile (> 0) . map (`mod` 1000) . iterate (`div` 1000) $ 12345678
07:53:30 <lambdabot>   "12,345,678"
07:55:24 <fizruk> > intercalate "," . reverse . map show . takeWhile (> 0) . map (`mod` 1000) . iterate (`div` 1000) $ 12345678.9123
07:55:27 <lambdabot>   Ambiguous type variable `a0' in the constraints:
07:55:27 <lambdabot>    (GHC.Real.Fractional a0...
07:55:38 <fizruk> > intercalate "," . reverse . map show . takeWhile (> 0) . map (`mod` 1000) . iterate (`div` 1000) $ 12345678.9123 :: Double
07:55:40 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
07:55:40 <lambdabot>              with actual ty...
07:56:04 <fizruk> > intercalate "," . reverse . map show . takeWhile (> 0) . map (`mod` 1000) . iterate (`div` 1000) $ (12345678.9123 :: Double)
07:56:06 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
07:56:06 <lambdabot>    arising from a use ...
07:56:06 * hackagebot groundhog-postgresql 0.3.0.2 - PostgreSQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-postgresql-0.3.0.2 (BorisLykah)
07:57:24 <Araneidae> Can I match more than one constant value in a case selection, eg: in case x::Int of { 1-> "yes";  2->"yes"; _->"no"} can I avoid repeating "yes"?
07:57:46 <monoidal> of k | k `elem` [1,2] -> "yes"
07:58:01 <monoidal> but in full generality haskell does not have or-patterns
07:58:06 <Araneidae> Ah well
07:58:22 <Araneidae> So I can use a guard to do more complex checking, but not a pattern match
07:58:37 <fizruk> monoidal: this requires Eq k instance?
07:58:48 <monoidal> fizruk: pattern matchin on numbers also requires Eq
07:59:13 <monoidal> Araneidae: you can also write of 1 -> a; 2 -> a; _ -> "no"; where a = <something complicated>
07:59:18 <Araneidae> Surely not -- I can pattern match on a data constructor without an Eq instance, can't it?
07:59:32 <monoidal> integer literals are not data constructors, though
07:59:33 <Araneidae> monoidal, yes, I'm doing that at the moment
07:59:40 <Araneidae> ah.  huh
08:00:31 <monoidal> :t \x -> case x of 0 -> ()
08:00:35 <lambdabot> (Eq a, Num a) => a -> ()
08:00:44 <Araneidae> gosh
08:01:10 <fizruk> can anyone help me with this? http://hpaste.org/87577
08:01:18 <Araneidae> and boo, too.  Ah well, for finite data Eq is trivial anyway
08:02:07 <Araneidae> fizruk, what's the problem (apart from the hlint messages, which are trivial)?
08:02:23 <fizruk> Araneidae: marked with XXX
08:02:39 <Araneidae> Ah yes, line 35
08:02:49 <fizruk> Araneidae: basically — traversing through leaves of a tree
08:03:00 <fizruk> Araneidae: and line 52
08:03:46 <Araneidae> I'm not familiar with lenses (they seem terribly fashionable at the moment).  Somebody else
08:04:40 <edwardk> fizruk: what is the goal of leaf_?
08:04:58 <fizruk> actually, leaf = singular leaves, so the problem is defining leaves
08:05:09 <fizruk> edwardk: just any single leaf
08:05:17 <edwardk> so your goal is to go find all the leaves in the tree that have no children?
08:05:30 <fizruk> yes
08:05:33 <edwardk> technically you'll have a problem with that isn't technically a valid traversal
08:05:51 <edwardk> because since i given you the leaf you can edit the children of it, so if you then do the traversal again, fusion fails to find the same elements
08:06:03 <edwardk> thats why its hard to define =)
08:06:18 <supki> :t singular
08:06:22 <lambdabot> (Functor f, Conjoined p) => Over p (Control.Lens.Internal.Bazaar.BazaarT p f a a) s t a a -> Over p f s t a a
08:06:40 <edwardk> you can still cheat and define it though. its easier to define recursively than the way you are doing it
08:07:52 <edwardk> leaves f n@(Node a Nothing Nothing) = f n; leaves f (Node a l r) = Node a <$> traverse (leaves f) l <*> traverse (leaves f) r
08:08:02 <fizruk> edwardk: how do I implement it recursively?
08:08:12 <edwardk> like that =)
08:08:28 <supki> > [1..10] ^. singular folded
08:08:30 <lambdabot>   1
08:08:33 <supki> aha
08:09:27 <fizruk> edwardk: is it somehow related to the plate function? looks similar to me
08:09:48 <edwardk> fizruk: its very similar to plate, but plate _is_ a valid traversal
08:09:55 <edwardk> you can make a plate for your nodes easily
08:10:40 <edwardk> instance Plated (Node a) where plate f (Node a l r) = Node a <$> traverse f l <*> traverse f r
08:10:43 <fizruk> edwardk: so, leaf is also invalid traversal?
08:10:47 <edwardk> correct
08:11:10 <edwardk> you can traverse the values at the leaves, but not the leaves themselves safely. its an improper traversal of the first kind
08:11:20 <edwardk> in that later fusion passes will skip some of your targets
08:12:31 <fizruk> edwardk: what if I need to pick value at leaf and remove that leaf from the tree?
08:13:08 <fizruk> edwardk: should I do that with cheat-fasion leaves or some other way?
08:13:14 <edwardk> personally i'm fine with illegal traversals so long as they are documented as such
08:14:24 <fizruk> edwardk: ok. And what are the consequences of using invalid traversals in general?
08:15:01 <edwardk> that you can't reason about them with the fusion laws. thats it
08:15:14 <edwardk> all the combinators do what you'd expect
08:15:21 <elliott> also, roconnor comes for you.
08:15:24 <edwardk> yeah
08:15:35 <edwardk> roconnor has been known to go after people who use them with a wrench
08:15:44 <edwardk> but if you live far away from canada you should be okay
08:16:12 <fizruk> is moscow far enough?
08:22:39 <mm_freak> is there a way to do darcs push --set-default without actually pushing?
08:23:08 <mm_freak> or some other way to set a remote repository without having to push to it
08:25:42 <fizbin> > 1 *78
08:25:44 <lambdabot>   78
08:28:08 <fizbin> > 56*78
08:28:11 <lambdabot>   4368
08:28:37 <fizbin> > 78*78
08:28:40 <lambdabot>   6084
08:29:02 <armlesshobo> > 78^2
08:29:05 <lambdabot>   6084
08:29:44 <Araneidae> > (-1)::Word16
08:29:47 <lambdabot>   65535
08:30:10 <dolio> mm_freak: Have you tried running it with --set-default and then saying 'no' to all patches?
08:30:18 <bartavelle> Hello, I have a graph-theoritic question, which is not the topic of this channel, but I suppose many people would be able to answer : in a directed graph, there might be a *lot* of possible pathes from node A to node B. Is there a good algorithm that gives the list of nodes all thoses pathes have in common ?
08:31:11 <mm_freak> dolio: the problem is that darcs still tries to connect to the repo, which doesn't and shouldn't exist at that point
08:31:17 <bartavelle> basically, the list of nodes that can't be avoided when going from node A to node B
08:31:24 <mm_freak> even with --set-default and --dry it does that
08:31:27 <dolio> Oh.
08:32:25 <dolio> mm_freak: You can also edit _darcs/prefs/defaultrepo.
08:32:32 <dolio> And _darcs/prefs/repos
08:32:39 <dolio> Although that's somewhat manual.
08:33:02 <dolio> Anyhow, I don't know how to do it, but it may exist.
08:33:04 <tromp> bartavelle: try removing each node and testing if B still reachable from A?!
08:33:16 <mm_freak> dolio: is it portable?
08:33:21 <Araneidae> How do I avoid an Orphan Instance when the instance I want to provide is too large to comfortably fit in the file containing the type definition?
08:33:48 <bartavelle> tromp : this sounds like a perfectly good idea
08:33:54 <bartavelle> and not too expensive for me
08:33:55 <bartavelle> thanks
08:33:58 <mm_freak> Araneidae: write a separate module for the type itself?
08:34:05 <Araneidae> I've done that.
08:34:26 <mm_freak> Araneidae: is it your own class?
08:34:27 <jodaro> hrm
08:34:31 <Araneidae> But of course I now have two modules:: MyType and MyShow which defines show_mytype
08:34:33 <dolio> mm_freak: I don't know.
08:34:38 <jodaro> i think i'm standing just outside the gates of cabal hell
08:34:42 <Araneidae> where do I put instance Show show_mytype ?
08:34:46 <mm_freak> dolio: ok, thanks for your help
08:34:48 <dolio> mm_freak: They aren't very complex files.
08:34:53 <Araneidae> I can't put it in MySHow because that's an orphan
08:35:04 <Araneidae> I can't put it in MyType because then I get a circular import ...
08:35:18 <mm_freak> Araneidae: when a class instance gets too large what i do is to have an internal module that defines the necessary functions
08:35:22 <jodaro> i've got haskell-platform-2012.4.0.0 installed (OS X)
08:35:30 <tromp> bartavelle: you only need to remove nodes that are both reachable from A, and which can reach B,  but that's probably gonna be most nodes anyway
08:35:31 <jodaro> which version of base should i have?
08:35:42 <mm_freak> Araneidae: then just write instance Show Blah where showsPrec = blahShowsPrec
08:35:48 <Araneidae> I probably don't understand modules well enough: there's a notion of internal module which will solve my problem?
08:35:59 <mm_freak> Araneidae: nothing technical
08:36:00 <Araneidae> At the moment my modules are all just top level
08:36:16 <Araneidae> Literally (with different names) what I said: MyType and MyShow
08:36:24 <mm_freak> Araneidae: just a module you name .Internal and mention in other-modules instead of exposed-modules in your cabal file
08:36:32 <jodaro> base-4.5.1.0 is whats installed
08:36:39 <Araneidae> Haven't got any cabal structure yet
08:36:40 <bartavelle> tromp : yes in my case that will be almost all nodes
08:36:44 <jodaro> but i have a library with a .cabal file wanting 4.6
08:36:45 <mm_freak> Araneidae: in your .Types module you just reexport the type
08:36:50 <supki> jodaro: you can't reinstall base anyway
08:37:05 <jodaro> yeah
08:37:21 <supki> jodaro: base 4.6 means ghc 7.6
08:37:31 <monoidal> bartavelle: My intuition tells me there should be an O(V+E) algorithm, though I can't think of it.
08:37:39 <mm_freak> Araneidae: module Data.Blah.Types (Blah(..)) where import Data.Blah.Internal (Blah(..))
08:37:49 <jodaro> ok
08:37:51 <mm_freak> Araneidae: that works without a cabal file, too
08:37:58 <jodaro> but haskell platform has 7.4.2
08:38:11 <jodaro> (is what i'm guessing)
08:38:15 <supki> yes
08:38:20 <monoidal> bartavelle: Perhaps computing biconnected components containing the 2 vertices might help
08:38:21 <geekosaur> you could try the beta of the next hp
08:38:25 <mm_freak> Araneidae: but there is nothing wrong with cabalizing even small projects
08:38:29 <geekosaur> actually, release candidate
08:38:36 <mm_freak> even my xmonad configuration is cabalized =)
08:38:44 <Araneidae> I'll put together a trivial example, I've not quite got the hang of how Haskell modules behave, mm_freak
08:38:46 <jodaro> so do i want 7.6 if i'm a relative n00b?
08:38:52 <dolio> tromp, bartavelle: You should probably start by finding _a_ path from A to B (ideally the shortest, I guess), and then removing only those nodes. Because the necessary nodes will be at most the shortest path.
08:38:52 <jodaro> or is 7.4.2 fine
08:39:04 <bartavelle> monoidal, there are only ~ 370 nodes, no need for high efficiency
08:39:14 <geekosaur> if the library wants base 4.6 then you must install ghc 7.6
08:39:15 <bartavelle> dolio : ah yes !
08:39:20 <monoidal> bartavelle: ah, in this case, simpler is better
08:39:35 <monoidal> bartavelle: (btw is the graph directed?)
08:39:38 <bartavelle> yes
08:39:40 <mm_freak> Araneidae: modules import, define and export things…  you can reexport imported things, too…  the only rule is that module dependencies may not be cyclic
08:39:55 <jodaro> (well the truth is that i'm just playing around and copied that over from something else)
08:39:57 <jodaro> so
08:40:06 <jodaro> 4.5 may be fine
08:40:17 <bartavelle> I am trying to solve a gamebook, so I'm looking for "choke points" to solve each parts independently
08:40:24 <mm_freak> Araneidae: the basic syntax is:  module Name (exportList) where importList
08:40:33 <jodaro> i guess i'll build it and find out
08:40:50 <mm_freak> if export list is optional…  if you don't write it, everything is exported (which is fine for executables, but usually a bad idea for libraries)
08:40:56 <Araneidae> mm_freak, I'm happy with all this.  It's the fact that you seem to be saying that I can have a notion of "internal" module that's puzzling me
08:41:20 <mm_freak> Araneidae: as said, there is nothing technical to it…  haskell doesn't have a notion of internal modules
08:41:23 <Araneidae> Presumably that means I have to put my files in a subdirectory, corresponding to the dotted path
08:41:35 <dolio> It's just a naming and exporting convention.
08:41:43 <dolio> And maybe not even the latter.
08:41:50 <mm_freak> Araneidae: the convention is that in a cabalized project a module is "internal", when it isn't exposed to the library user
08:42:39 <mm_freak> Araneidae: ".Internal" was really meant like "*.Internal" =)
08:42:47 <mm_freak> like Data.Text.Internal
08:42:59 <mm_freak> sorry for the confusion
08:43:09 <akegalj> About yesod if someone knows. On my system(arch) yesod devel uses ~30% cpu and more when idle. I google some tickets about it but didnt quite find solution. Can i fix this?
08:44:05 <Araneidae> So in my example, with modules called MyType (defining MyType) and MyShow (definining showMyType) would I be able to declare  instance Show MyType where show = showMyType ?
08:44:06 <mm_freak> akegalj: you need to disable the idle garbage collection…  see +RTS --help
08:44:41 <mm_freak> Araneidae: sure, why not
08:44:49 <mm_freak> if the types fit, that is
08:45:09 <Araneidae> Well, I can't put the instance declaration in MyShow without getting an Orphan Instance warning
08:45:23 <Araneidae> And I can't put it in MyType without a circular import
08:45:35 <akegalj> mm_freak: tnx, will try that
08:46:19 <mm_freak> Araneidae: yeah, you can't really do anything about it, but you can at least keep the instance short
08:46:39 <mm_freak> data …; instance Show … where show = myShow; myShow = …
08:46:51 <Peaker> often the .Internal is exported anyway just in case some functionality is missing
08:47:05 <Araneidae> Yes .. and here myShow is so long I don't want it in the same module as ...
08:47:35 <mm_freak> Araneidae: well, you can have circular module dependencies by using boot-files
08:47:38 <mm_freak> it's an ugly approach, but it works
08:48:07 <Peaker> Araneidae, I just disable orphan warnings in modules I know it's ok
08:48:20 <bartavelle> dolio, monoidal : thanks a lot, works like a charm now
08:48:29 <mm_freak> Araneidae: the other option is to go with the orphan instance and disable the warning
08:48:33 <Araneidae> Fair enough ... but it sounds like a proper problem then.  Ho hum
08:48:48 <mm_freak> Araneidae: orphan instances aren't wrong in general…  they are just wrong in many cases
08:48:59 <Araneidae> Reading up on orphan instances suggests they're good to avoid.
08:49:43 <Araneidae> How can I quickly convert numbers to hex?
08:50:13 <dolio> If you divided your modules in three, one for the type definition, and one for the show instance, and then a third that exported both, which is the intended use, then it'd probably avoid most of the bad qualities.
08:50:17 <dolio> If that's acceptable.
08:50:54 <Araneidae> dolio ... how does that work?  The third which is doing the exporting has to import the other two, so the cycle isn't avoid, is it?
08:51:09 <dolio> There's no cycle.
08:51:17 <dolio> Just 3 -> 2, 1, 2 -> 1
08:51:26 <dolio> Er, 3 -> (2, 1) and 2 -> 1
08:51:32 <monoidal> Araneidae: Numeric.showHex
08:55:26 <mm_freak> Araneidae: an orphan is bad when you define an instance in a package that defines neither the type nor the class
08:55:38 <mm_freak> note that i'm saying "package", not "module"
08:56:48 <mm_freak> it's like undecidable instances…  in general you would want to avoid them, but in some cases it's fine to use them
09:05:15 <Palmik> Hmm, did anyone here ever experienced criterion being slow? I mean, the benchmarked function has for example 6us mean execution time, but the benchmakr (100 samples) takes 15+ seconds.
09:06:05 <Palmik> Aaah, I see now... older versions had -G as default, but now -g is the default.
09:09:12 <akegalj> mm_freak: about idleing GC it says to pass "+RTS -I0 -RTS" to app which turns GC off or "-I2" by idleing with bigger time. Do you know how to pass those arguments to my app which yesod devel runs? (and how to tell yesod to compile my app with -threaded option, which is necesery for -RTS options as i founded)
09:14:01 <mm_freak> akegalj: you can set the default RTS options by passing, say, -with-rtsopts=-N to GHC
09:14:36 <mm_freak> akegalj: in your cabal file you can use something like this:  ghc-options: -W -threaded -rtsopts -with-rtsopts=…
09:19:15 <tomejaguar> Is there a version of "chunksOf :: Int -> Text -> [Text]" that works on [a] instead of Text?
09:19:55 <mm_freak> :t \n -> takeWhile (not . null) . unfoldr (Just . splitAt n)
09:19:58 <lambdabot> Int -> [a] -> [[a]]
09:20:13 <mm_freak> > (\n -> takeWhile (not . null) . unfoldr (Just . splitAt n)) 3 "abcdefgh"
09:20:19 <lambdabot>   ["abc","def","gh"]
09:20:21 <geekosaur> tomejaguar, check Data.List.Split module?
09:20:54 <tomejaguar> Thanks
09:22:16 <akegalj> mm_freak: thnx... it didnt work but that was right info... i'll play with  GC parameters now :)
09:30:27 <bad_alloc> Hello, I've got a list of two-tuples and I need to get the tuple with the largest snd. So far I've got max = foldl (\ x y -> if snd x > snd y then x else y) [(1,2), (3,4), (5,6)]  But this fails with the error "Couldn't match expected type `(a, b)' against inferred type `[a1]'   In the second argument of `foldl', namely   `[(1, 2), (3, 4), (5, 6)]'. Where is my mistake? Where does [a1] come from?
09:31:04 <mm_freak> bad_alloc: see maximumBy and comparing
09:31:09 <elliott> bad_alloc: you need one more argument to foldl
09:31:10 <elliott> :t foldl
09:31:13 <lambdabot> (a -> b -> a) -> a -> [b] -> a
09:31:20 <elliott> the "initial" value
09:31:26 <elliott> or use foldl1
09:31:32 <mm_freak> > maximumBy (comparing snd) (zip [1,2,3] [2,4,1])
09:31:35 <lambdabot>   (2,4)
09:32:06 <bad_alloc> elliott: that works, thanks :)
09:32:20 <elliott> mm_freak: I suspect it's an assignment where using maximumBy would defeat the point :P
09:32:31 <bad_alloc> mm_freak: We're not allowed to import stuff just yet (college course)
09:32:37 <bad_alloc> ah ditto.
09:32:39 <mm_freak> i see…  sorry =)
09:33:04 <bad_alloc> mm_freak: academia, yay :D
09:33:41 <mm_freak> bad_alloc: nothing wrong with that though =)
09:33:51 <mm_freak> you will reinvent lots and lots of stuff while learning haskell ;)
09:36:55 <bad_alloc> mm_freak: our professor collects awesome, strange and stupefyingly bad code in a folder in hos office. I hope my reinventions won't make it into the last two sections.
09:38:44 <mm_freak> bad_alloc: you used foldl
09:38:50 <mm_freak> can't be that bad ;)
09:39:30 <mm_freak> bad_alloc: as a performance note you may want to use foldl' instead of foldl, but it requires an import of Data.List
09:39:50 <Taneb> Is there any time you'd prefer foldl to foldl'? (for [])
09:40:22 <bad_alloc> mm_freak: as soon as imports are allowed :)
09:40:46 <monoidal> Taneb: http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl' - see Conclusion
09:41:33 <Taneb> Thanks, monoidal
09:44:07 <philed> Any parsec experts about? I'm trying to implement my own instance of Stream for yesod's conduits, but the behaviour has got weird.
09:45:28 <philed> hpaste.org/87584
09:48:35 <raid> can I somehow "look" at the implementation of the instance that is automatically generated when I derive some typeclass?
09:50:27 <supki> -ddump-deriv flag to ghc
09:50:55 <raid> supki: awesome, thanks
10:04:06 <jfischoff> what is something that free monads solve that I can't solve another way
10:04:27 <jfischoff> for instance if I want to implementation of something I can use type class
10:04:42 <jfischoff> do I just want free monads if I want to solve the expression problem?
10:04:45 <Cale> jfischoff: Nothing.
10:04:56 <Cale> There are always other solutions to any problem you might face
10:05:50 <jfischoff> cool
10:06:14 <jfischoff> is there a time they are particularly appriopiate?
10:06:45 <Cale> When you have a language that you want to interpret in more than one way, perhaps.
10:10:56 <eacameron1> I'm trying a simple example from "Real World Haskell": let eol = string "\\n\\r" <|> string "\\n"     Yet with the newest version of Parsec, it doesn't compile (No instance for (Text.Parsec.Prim.Stream s0 m0 Char) arising from a use of `string'"    Thoughts?
10:11:47 <eacameron> I'm still here
10:12:12 <Cale> import Text.Parsec.String
10:12:26 <Cale> ?
10:13:01 <eacameron> Now it says string and <|> are not in scope ??
10:13:11 <eacameron> I need a tutorial that still works ;)
10:13:58 <Cale> wait, did you import Text.Parsec?
10:14:09 <Cale> <|> should definitely be in scope
10:14:22 <philed> eacameron: You might have to give it a type signature.
10:14:40 <philed> Try eol :: Parsec String u String
10:14:41 <Cale> Text.Parsec reexports Text.Parsec.Prim, which exports (<|>)
10:20:43 <monoidal> has anyone made a table what monad transformer combinations form monad? for example, ListT [] is not a monad
10:20:53 <elliott> ListT is the only one special like that
10:20:58 <elliott> (only standard one)
10:21:09 * hackagebot authenticate-oauth 1.4.0.6 - Library to authenticate with OAuth for Haskell web applications.  http://hackage.haskell.org/package/authenticate-oauth-1.4.0.6 (HiromiIshii)
10:21:19 <Cale> ListT probably shouldn't be in the mtl in its given form
10:21:31 <monoidal> elliott: so all others, like ContT ... (StateT ... (ReaderT ... (WriterT ...)) are monads?
10:21:34 <Cale> yeah
10:21:48 <elliott> ListT m is only a monad if m is commutative
10:22:06 <Cale> Normally to be a monad transformer, the thing has to send monads to monads, but ListT m has the condition that elliott gave.
10:22:35 <eacameron> Cale: your first suggestion (Text.Parsec.String) didn't work, but what I reported was wrong. Apparently I didn't know how :m worked ;)
10:23:00 <tac> elliott: When you say m must be commutative, what must it commute with?
10:23:11 <elliott> itself :P
10:23:17 <monoidal> tac: m must be a commutative monad
10:23:58 <monoidal> tac: one way of looking at it is that in a do block, x <- a; y <- b can be exchanged as long as b does not refer to x
10:24:00 <tac> Does a commutative monad need to commutate with any other monad n?
10:24:14 <tac> So m (n a) = n (m a) for all monads n?
10:24:15 <elliott> it's really (>>=) that must be commutative
10:24:20 <elliott> no
10:24:27 <tac> oh
10:24:28 <tac> I see
10:24:31 <tac> It commutes with itself
10:25:35 <tac> I'm guessing that is a computer science notion, not a category theory notion
10:25:52 <monoidal> "commutative monad" is a category-theoretical notion.
10:26:18 * tac shuts up until he learns more about monads 
10:28:43 <mm_freak> i'm not sure what a "commutative monad" is
10:28:57 <mm_freak> a >=> b = b >=> a makes no sense in general
10:29:28 <sipa> :t (>=>)
10:29:31 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
10:29:32 <elliott> it's not a statement about (>=>)
10:29:35 <mm_freak> is it a monad, where liftA2 f x y = liftA2 (flip f) y x?
10:29:50 <Cale> yes
10:29:58 <mm_freak> i see
10:30:05 <mm_freak> so like Reader e and Identity
10:30:09 <xivix> I was reading some stuff on the State monad and came across the definition of the class MonadState:  `class Monad m => MonadState s m | m -> s where` .
10:30:11 <Cale> That's right
10:30:27 <xivix> What does the  `| m -> s`  mean?
10:30:34 <monoidal> mm_freak: also Writer w is a commutative monad iff m is a commutative monoid.
10:30:35 <Cale> xivix: It's a functional dependency
10:30:40 <mm_freak> xivix: it means that 's' follows from 'm'
10:30:53 <mm_freak> Int follows from State Int
10:30:59 <Cale> It means that for any choice of m, there is at most one s for which there is an instance MonadState s m
10:31:03 <monoidal> mm_freak: (m should be w)
10:31:17 <mm_freak> monoidal: ?
10:31:25 <Cale> and hence, given m, the compiler is allowed to use that instance to infer what type s must be
10:31:29 <dolio> Cale: I think it finally actually means that again, too.
10:31:34 <Dodek> mm_freak: well, as monad is a monoid object in the endofunctor category, probably commutative monad means that this monoid object is commutative.
10:31:36 <dolio> Or, maybe not until 7.8.
10:31:42 <Cale> dolio: Oh, did it not mean that for a while?
10:31:45 <monoidal> mm_freak: i was correcting myself
10:32:09 <mm_freak> monoidal: ah =)
10:32:21 <dolio> Cale: Yeah, for a while you've been able to write instances like 'class C a b | a -> b ; instance C Int a'.
10:32:24 <dolio> But they fixed it.
10:32:42 <elliott> broke it, in edwardk's mind :p
10:33:10 <mm_freak> the category of endofunctors again…  i never really thought about it, but it seems to me like such a category only contains a bunch of monoids, right?
10:33:17 <mm_freak> i.e. all arrows are endomorphisms
10:33:19 <dolio> If you want them to work like that, you need to call them something other than functional dependencies.
10:33:40 <elliott> fun dependencies
10:33:46 <Dodek> mm_freak: no, it's the objects that are endomorphisms. the arrows are natural transformations.
10:33:55 <PatrickRobotham> What's the name of the pragma for Existential Types?
10:33:57 <mm_freak> ah, ok
10:34:16 <mm_freak> PatrickRobotham: {-# LANGUAGE ExistentialQuantification #-}
10:34:18 <monoidal> PatrickRobotham: -XExistentialQuantification
10:34:21 <PatrickRobotham> Cheers :)
10:34:32 <monoidal> PatrickRobotham: you need not remember that; just write an existential definition and GHC will suggest the flag
10:34:39 <Dodek> mm_freak: and in order to talk about monoid object, first you need to have a monoidal category
10:35:11 <Cale> dolio: Oh, right, I always thought that was weird.
10:35:11 <Dodek> mm_freak: for instance, monoidal structure on the category of sets is just a product of sets
10:35:22 <mm_freak> Dodek: i'm not sure how liftA2 f x y = liftA2 (flip f) y x maps to such a category
10:35:42 <Dodek> mm_freak: but in category of endofunctors, the monoidal structure is composition of endofunctors.
10:35:43 <dolio> Cale: Apparently that was originally ruled out, but the check went missing at some unknown point (it's been missing a while).
10:36:05 <monoidal> PatrickRobotham: also, you can try this: in GHCi, type :set -XExi and press tab, it will autocomplete
10:36:07 <Dodek> mm_freak: http://en.wikipedia.org/wiki/Monoid_object
10:36:16 <Dodek> mm_freak: look at this diagram. this is a definition of a monoid object
10:36:23 <Cale> mm_freak: Such a category is itself a monoid.
10:36:56 <mm_freak> Cale: that's what i thought
10:37:03 <Dodek> mm_freak: a monoid object will be commutative if there exists another commutative diagram expressing commutativity of mu: M (x) M -> M
10:37:26 <Cale> mm_freak: If C is any (locally small) category at all, and X is some object of C, then End(X), the set of all arrows f: X -> X, forms a monoid under composition.
10:37:36 <Cale> mm_freak: In this case, C is Cat, and X is the category in question.
10:38:25 <dolio> mm_freak: The definition of a commutative monad in category theory uses, I think, (m a, m b) -> m (a, b) commuting, regardless of which way you decide to do it.
10:38:40 <dolio> Pull out either one first.
10:38:46 <mm_freak> dolio: thanks, that makes most sense
10:38:51 <mm_freak> to me
10:41:49 <Cale> hmm
10:43:24 <Cale> Actually, I'm not sure I've ever seen commutative monads come up in a purely category theoretical setting, though it obviously makes sense to speak of them there.
10:43:39 <dolio> I feel like it's on nlab, at least.
10:44:32 <monoidal> Dodek: that definition requires a swap :: M (x) M -> M (x) M. I don't think in general it is guaranteed to exist.
10:44:33 <dolio> Yeah, it's in the monoidal monad article.
10:44:38 <Cale> They formulate it for strong monads like you said
10:44:51 <Dodek> monoidal: hmm, yeah.
10:44:53 <Cale> http://ncatlab.org/nlab/show/commutative+algebraic+theory
10:46:40 * tac doesn't want to work. He wants to do more Algebra.
10:47:14 <scriptor> if pi were normal, is it possible that it would contain all digits of pi?
10:47:55 <opqdonut> in a non-trivial manner?-)
10:48:03 <Cale> http://arxiv.org/pdf/0704.2030v1.pdf uses them outside of computer science :)
10:48:18 <Cale> (and refers to them as generalised rings)
10:49:18 <tromp> yes, if any x is normal, it contains pi as a subsequence
10:49:22 <scriptor> opqdonut: I think?
10:49:35 <scriptor> tromp: thought so, thanks
10:49:54 <tromp> yes, if any x is normal, it contains any y as a subsequence
10:50:15 <Dodek> tromp: this is bullshit.
10:50:33 <tromp> normality is MUCH stronger than what you for that
10:50:35 <Dodek> tromp: it contains every finite subsequence of y as a subsequence, but obviously not the whole y.
10:50:51 <tromp> obviously the whole y
10:51:10 <monoidal> Dodek: subsequence need not be contignous
10:51:15 <Dodek> ah.
10:51:22 <monoidal> that's a substring
10:51:31 <immanuelkant> any links to well commented haskell code to get familiar with haskell idioms.. things like how i can use monads, functors in practical code.. at present i understand what they are, thankfully..
10:51:38 <Dodek> monoidal: ah, yes, i thought about substring.
10:51:42 <Dodek> tromp: sorry
10:51:46 <tromp> np:-)
10:52:05 <Cale> I'm not sure we even know that, for instance, there isn't some M such that whenever n > M, we have that the nth digit of pi in base 10 is either 3 or 7.
10:52:58 <Cale> (It would be silly to expect this to be the case, but I don't know how to rule it out)
10:53:06 <tromp> no; we don't know that
10:53:25 <bitonic> immanuelkant: there’s this somewhat outdated list <http://stackoverflow.com/questions/6398996/good-haskell-source-to-read-and-learn-from>, which won’t teach you about the current idioms but about good programming
10:53:58 <tromp> we don't know whether it contains the Bible as a substring either
10:54:23 <tromp> although all normal numbers obviously do
10:54:31 <immanuelkant> bitonic: that question is perfect.. that guy worded it much better than me :)
10:54:45 <tac> Now, is it the case that normal numbers contain all sequences or that they almost surely contain them?
10:55:06 <Dodek> tac: all of them
10:55:07 <Gilly> tac: what do you mean by 'almost surely'?
10:55:09 <tromp> they contains every length k substring with frequency 10^-k
10:55:13 <Cale> tac: They absolutely must contain all finite sequences infinitely often
10:55:13 <Gilly> tac: (the answer is all of them)
10:55:25 <tromp> for all k
10:55:40 <applicative> immanuelkant: what sort of examples are you looking for?
10:56:14 <immanuelkant> applicative: https://github.com/andrewdougherty/svm/blob/master/SVM.hs something like this
10:56:19 <tromp> where the almost surely comes in is that the probability of a number being normal is 1
10:56:51 <immanuelkant> but the above implementation is fairly straight forward.. like it has list comprehensions.. guards, where, etc
10:57:47 <applicative> immanuelkant: I see what you mean, all those [Double] should probably be using Data.Vector.Unboxed which is just as easy
10:57:56 <immanuelkant> some of your githubs will be appreciated too..
10:58:18 <bitonic> immanuelkant: again those examples will be good code, but they probably aren’t idiomatic in the sense that they redefine stuff instead of using the HP
10:58:23 <applicative> immanuelkant: but machine learning-ish things are your domain interest -- not that I know anything about it.
10:59:10 <immanuelkant> as far as the code about is not too hard, its okay..
10:59:23 <immanuelkant> like graph searches for exampls..
11:00:18 <chrisdotcode> guys can I get a little help? my data declaration isn't working, "data action = Jumping | Running".  I get "Malformed head of type or class declaration: action"
11:00:24 <bitonic> immanuelkant: but they should be inspirational—functional peals are another good resource
11:00:35 <armlesshobo> data Action = ...
11:00:38 <armlesshobo> chrisdotcode: ^
11:00:38 <bitonic> actually there is a nice pearl about depth first graph traversal
11:00:39 <applicative> immanuelkant: tibbe is always emphatic about modern style and libraries, you might look at some of his https://github.com/tibbe
11:00:41 <immanuelkant> i can't think of many examples.. as far as it is well documented..
11:01:00 <applicative> immanuelkant: he also has a number of tutorials on 'high performance haskell' which are must-reads
11:01:04 <chrisdotcode> Amadiro: oh, data types are *always* capitalized?
11:01:06 <chrisdotcode> thanks :-)
11:01:11 <armlesshobo> chrisdotcode: types should always begin with a capital letter
11:01:14 <armlesshobo> yes
11:01:15 <armlesshobo> :)
11:01:32 <immanuelkant> pearls?
11:02:29 <applicative> pearls are short essays illustrating techniques
11:02:36 <bitonic> immanuelkant: yeah, ‘functional pearls’, some short piece of code that does something neat, with nice prose describing it
11:02:59 <applicative> immanuelkant: here's the wiki out of data as usual http://www.haskell.org/haskellwiki/Research_papers/Functional_pearls
11:03:14 <fizbin> I need some Template Haskell help. Anyone good at that?
11:03:18 <bitonic> but really those are more about computer science and inspiration rather than software engineering and ‘getting things done’, and I don’t know what you’re after :)
11:03:23 <bitonic> fizbin: don’t ask to ask etc.
11:03:46 <fizbin> Right, right. I just figured if there were a #haskell-th channel or something like that...
11:04:00 <bitonic> not that I know of.  this is the best place to ask anyway
11:04:02 <immanuelkant> thanks, now i got enough links,, i will look into them..
11:04:06 <monoidal> immanuelkant: here is a list I compiled some time ago http://www.reddit.com/r/haskell/comments/dka2o/help_me_find_something_interesting/c10tsn2
11:04:42 <immanuelkant> hehe i blocked reddit in my hosts file..
11:04:54 <applicative> monoidal: those are awesome. I thought immanuelkant was looking for practical illustrations though, not sure
11:05:16 <fizbin> So I'm trying to do something in template haskell where I compute a larger expression and then do "let $(name_I_made) = (something i'll put here) in $(larger_expression)" and I'm getting an error that I didn't understand, so I've reduced it to the smallest case that still doesn't work:
11:05:19 <fizbin> runQ $ do { nm <- newName "f"; [| let $(varP nm) = 5 in $(varE nm) |] }
11:05:19 <immanuelkant> but i sooon realized i can access it with es.reddit.com, fr.reddit.com.. etc..
11:05:24 <applicative> immanuelkant: oh good work
11:05:34 <applicative> oh, not so good work
11:05:36 <fizbin> That errors with "Parse error in pattern: $(varP nm)"
11:06:07 <fizbin> > runQ $ do { nm <- newName "f"; [| let $(varP nm) = 5 in $(varE nm) |] }
11:06:12 <lambdabot>   <hint>:1:33: parse error on input `|'
11:06:21 * fizbin suspects lamdabot doens't do TH.
11:06:26 <fizbin> Which is fine.
11:06:34 <simpson> It's true, she doesn't.
11:06:47 <monoidal> fizbin: AFAIK you can't splice patterns
11:07:19 <fizbin> Then what am I supposed to do, construct a LetE manually?
11:07:56 <fizbin> I don't understand what all the arguments to LetE even mean.
11:08:15 <monoidal> fizbin: I think I would do this. perhaps there's a better option, but I'm not aware of it.
11:08:42 <monoidal> fizbin:  LetE :: [Dec] -> Exp -> Exp - that's easy, no?
11:08:59 <monoidal> fizbin: list of declarations in let and the "in" expression
11:09:14 <Kaidelong> I need a good library for *generating* XML
11:09:29 <Kaidelong> what I've read of HaXML and HXT seem to indicate that they are not really focused on that
11:09:29 <immanuelkant> monoidal: thanks.. prior to haskell, i never relly cared about types.. but i realized there is soo much more that goes on with types.. i came across algebra of types.. etc.. so now i want to know how all these apply to in practical projects.. your links seems perfect
11:09:41 <Kaidelong> rather on parsing and reading it
11:10:22 <fizbin> monoidal: oh, I guess the extra arguments that were confusing me were actually arguments to ValD...
11:10:41 <mm_freak> monoidal: there are xmlhtml and blaze-html…  the names are slightly misleading as they are perfectly capable of generating XML
11:10:57 <fizbin> I was trying to decipher how (LetE [ValD (VarP a_1) (NormalB (LitE (IntegerL 5))) []] (VarE a_1)) came out of (let a = 5 in a)
11:11:20 <mm_freak> monoidal: but they don't stream, so you still can't do something like XMPP with them
11:11:30 <monoidal> immanuelkant: several of those papers are more theory-oriented, but all of them inspired me to write a lot of code
11:11:32 <Kaidelong> HSXML seems to be what I want, scary though, oleg made it and what I can find of it documentation wise is "open the tar.gz and peek at the examples"
11:11:33 <monoidal> mm_freak: not me
11:12:12 <Kaidelong> knowing oleg it's either stunningly simple and that's really all I'll have to do or eldritch horrors that'll drive me insane, or both
11:12:57 <monoidal> fizbin: I believe ValD takes a variable to define, clauses (guarded or not) with bodies and "where" part
11:13:00 <Kaidelong> oh the link to it is broken anyway
11:13:16 <Kaidelong> http://okmij.org/ftp/Haskell/HSXML/
11:15:46 <mm_freak> monoidal: sorry
11:15:50 <mm_freak> Kaidelong: but they don't stream, so you still can't do something like XMPP with them
11:15:53 <mm_freak> uh
11:15:57 <dEPy> anyone can explain this non-determinism ? :S
11:16:00 <mm_freak> Kaidelong: there are xmlhtml and blaze-html…  the names are slightly misleading as they are perfectly capable of generating XML
11:16:06 <mm_freak> (swap the order of those two lines)
11:16:46 <Kaidelong> mm_freak: that's fine, this is for a "compiler" of a sort for a decent language that boils down to awful XML, so any concerns about streaming isn't a big deal
11:16:58 <Kaidelong> I'll look at those
11:17:13 <Kaidelong> HSXML is full of polyvaryadic function calls
11:17:38 <Kaidelong> which I don't really know how to work with
11:18:36 <immanuelkant> what is !String
11:19:25 <elliott> immanuelkant: a strict String field
11:19:27 <simukis_> immanuelkant: Strict string.
11:19:35 <applicative> immanuelkant: that just means it should be strictly evaluating, which in the case of string means little
11:20:18 <immanuelkant> difference between strict string and string
11:20:22 <Kaidelong> it essentially seems to be a way to convert haskell code that represents SXML into XML, but that just winds up shifting the problem to "how do I generate the SXML?" when all oleg's data declarations are in the form of "data Foo /r/n"
11:20:28 <applicative> that is data X = Y !String | Z !Int -- this means a Y cant be constructed without knowing whether it is [] of c:cs
11:20:44 <applicative> but it means a Z can't be constructed unless you actually have your hands on the Int
11:20:56 <Kaidelong> so it's not just a simple matter of generating some tree out of a primitive data type
11:20:57 <applicative> the whole Int , so to say
11:21:07 <Kaidelong> unless I am misunderstanding something important
11:21:39 <monochrom> !String means the author doesn't understand String
11:21:49 <applicative> immanuelkant: it is a bit silly to do it with !String, since it can't force complete evaluation, since lists are lists
11:22:28 <applicative> it's kind of like he or she is save themselves one characters' worth of thunk
11:22:37 <immanuelkant> https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md its from here
11:22:37 <applicative> saving themselves
11:23:21 <applicative> haha, I was praising tibbe to you a minute ago, now I'm turning gloomy ;)
11:23:57 <monochrom> I am wary of "style guides" anyway
11:24:20 <monochrom> "style guides" are the result of herd psychology
11:24:46 * applicative agrees completely
11:24:58 <tibbe> monochrom: style guides are to make sure you can have engineering projects with more than 10 ppl :)
11:25:09 <Kaidelong> in some contexts they really make a lot of sense, for example that "Text" is a property or an immutable static field but "text" is not
11:25:11 <Mortomes_> herd projects
11:25:14 <simpson> monochrom: And yet you use things that other people built.
11:25:22 <tibbe> try a 150M line code base and come back and tell me it's good that everyone uses their own style
11:25:30 <immanuelkant> @roulette
11:25:30 <lambdabot> Unknown command, try @list
11:25:36 <Kaidelong> it's like hungarian notation, adding extra semantics that are not enforced but that people agree on
11:25:50 <applicative> immanuelkant: further down we see data Array e = Array     {-# UNPACK #-} !Int     !ByteArray here the bang patterns are meaninful.  unpacking in theory is done with optimization but he is insisting
11:26:25 <applicative> also here in a different way, immanuelkant data Tree a = Branch !a !(Tree a) !(Tree a)  | Leaf
11:26:52 <Kaidelong> looks like it'd be better just to have Data.Vector do that for you
11:27:02 <applicative> immanuelkant: Im not sure i'd like such Trees but the idea is, you can't have a Branch .... on your hands without it being completely evaluated down to the leaves
11:27:30 <otters> @pl \x -> zip (init x) (tail x)
11:27:30 <lambdabot> liftM2 zip init tail
11:27:40 <applicative> oh tibbe you're here, we dont like !String in your style guide
11:28:51 <Kaidelong> xmlhtml depends on blaze-html
11:29:25 <tibbe> applicative: I don't like String :)
11:29:35 <Kaidelong> and it also happens to be exactly what I want
11:29:38 <c_wraith> hmm.  !String seems pretty pointless
11:29:46 <tibbe> applicative: but I'm not going to complicate my rules because of it being a bad idea
11:29:47 <Kaidelong> thanks mm_freak
11:30:12 <monochrom> then don't even use String in your examples
11:30:24 <c_wraith> tibbe: is it really a complication to say "don't make non-strict recursive data types strict fields"?
11:30:40 <c_wraith> I mean, since it's basically pointless to try, that doesn't really sound more complicated.
11:30:41 <tibbe> c_wraith: I don't know if that's the right thing
11:30:59 <tibbe> let s = really_big_thunk_that_returns_String in C s
11:31:06 <tibbe> you want to force that thunk, even if the String is lazy
11:31:09 <applicative> tibbe: I see you say use strict fields by default. I will send a patch to change it to Text
11:31:37 <applicative> tibbe: but whnf will reveal one character
11:31:40 <tibbe> now, you might still have problems with stuff that's held onto by the lazy computation that generates the String
11:31:44 <tibbe> applicative: it will
11:32:05 <Kaidelong> for future reference, xmlhtml seems to be a simple frontend to blaze so go ahead and recommend that one
11:32:25 <Kaidelong> wheras blaze is several different packages on hackage and is big and intimidating
11:32:35 <applicative> I think I oppose it in a style guide as giving a magical impression about !
11:33:17 <applicative> do you advise !(String -> String) ...
11:34:16 <tibbe> applicative: I think so, yes
11:34:42 <tibbe> think of a parser that constructs such a continuation, without forcing it might hold on to an unused branch
11:35:03 <tibbe> generally it's too easy to create leaks by misstakes with lazy-by-default fields
11:35:16 <applicative> oh, I see. I was just thinking though that you have enough data definitions on that page that you could implicitly impart a decent idea of when its likely to amount to something and when not
11:36:52 <tibbe> it's hard to tell, that's the problem
11:36:53 <fizbin> Okay, still struggling with TH here. WTF is "NormalB"?
11:37:09 <tibbe> if you have to think hard about if it matters, you've already lost
11:37:26 <tibbe> you could say the same about C, just think hard about everything you do and you won't have any problems! ;)
11:37:48 <tibbe> I want to write my program, not think hard about if this particular constructor application will lead to a leak
11:38:24 <tibbe> I'm afraid work calls, we will have to have this discussion over beer some day
11:38:46 <applicative> I'm with c_wraith, I'm not sure it's that hard; but maybe its not true
11:41:27 <Kaidelong> okay so, working through my plan I'm fine up until I get to render
11:41:33 <Kaidelong> where I end up with something of the type Builder
11:41:54 <Kaidelong> looking at blaze-builder I see nothing of the form Builder -> String or Builder -> String -> IO () or anything
11:42:02 <Kaidelong> so I have no idea what to do with that
11:42:48 <Kaidelong> all the functions I'm seeing are in the form XXXX -> Builder
11:43:37 <Kaidelong> ah, nevermind, found toByteString
11:44:41 <Kaidelong> Okay, I'm set then
12:01:12 <kayloos> Say you wanted to find the first occurrence of a special character in a big blob of text, and then parse something, what would be faster? Using parsec to eat up any character `but` the one you're searching for, or using Data.Text.elemIndex to find the special character?
12:05:20 <mm_freak> kayloos: that's something attoparsec can do pretty quickly
12:05:40 <mm_freak> it has combinators specifically for skipping characters until a certain one is reached
12:06:08 <mm_freak> and it does that by using efficient ByteString/Text functions
12:06:34 <kayloos> wow
12:06:46 <kayloos> thanks, i did not know about attoparsec
12:07:44 <eacameron> philed: I think you're right, running parse (my parser) "" "data" works
12:08:09 <eacameron> philed: but saying let myParser = <my parser> does not
12:08:32 <eacameron> How can I figure out what GHCI is implicitly figuring out for me so I can use the let expr?
12:22:31 <applicative> eacameron: what were you asking about 'let'?
12:23:23 <eacameron> applicative: I am trying to learn parsec3 and I'm also not very good at Haskell. When I type "parse (someparser) "" "data"" it works. But when I type "let x = (someparser)" it fails
12:23:43 <eacameron> I don't know what the type inference is doing so I can't figure out how to assign my parsers to names
12:23:44 <applicative> is it that there is a type error?
12:24:09 <applicative> eacameron: with Parsec it is probably well to :set -XNoMonomorphismRestriction
12:24:27 <eacameron> why is that?
12:24:55 <applicative> try that, and then try let x = many anyChar or whatever
12:25:45 <applicative> eacameron: someone else can do better explaining the 'dreaded monomorphismrestriction'
12:26:11 <monochrom> because someparser is very polymorphic, while the default meaning of "x = blah" wants monomorphic
12:28:36 <applicative> you would probably do well to write {-#LANGUAGE NoMonomorphismRestriction#-} at the type of a file if youre using Parsec, at least at first. You can specialize types if you find ghci is too general
12:28:44 <eacameron> applicative: it works!
12:28:55 <applicative> eacameron: oh good.
12:30:06 <applicative> eacameron: you can also put :set -XNoMonomorphismRestriction in your .ghci file, but occasionally this has a downside.  I think it's pretty commonly done though.
12:30:49 <eacameron> applicative: gotcha...I ask the Google for more info on that
12:31:08 <monochrom> it is a fairly long story
12:36:51 <NihilistDandy> applicative: Is there a good record of common settings in .ghci? I've been trying to figure out what to add, but I'm usually not confident enough to commit :D
12:38:03 <chrisyoung> NihilistDandy, have you see this? https://www.youtube.com/watch?v=QpDQhGYPqkU
12:38:13 <chrisyoung> The first bit of it goes into one bit of customization.
12:38:18 <JoeyA> A couple good ones:  :set prompt "> "  ;  :set -XImplicitParams
12:38:37 <JoeyA> ImplicitParams sort of lets you do what type holes does
12:38:40 <chrisyoung> A lot of people like to customize the prompt so it's a pretty lambda.
12:38:47 <JoeyA> > "hello" ++ ?whattypeisthis
12:38:51 <lambdabot>   mueval-core: internal error: PAP object entered!
12:38:51 <lambdabot>      (GHC version 7.4.2 fo...
12:38:55 <chrisyoung> But the problem with the lambda prompt for me is that emacs ghci would hang with it
12:39:21 <JoeyA> Unbound implicit parameter (?whattypeisthis::[Char])
12:39:24 <chrisyoung> (And I'm not the only one)
12:39:26 <bjackman> Does anyone know if there's a typeclass for types that can index a list?
12:39:28 <geekosaur> :t "hello" ++ ?wat
12:39:32 <lambdabot> (?wat::[Char]) => [Char]
12:39:42 <JoeyA> bjackman: Ix ?
12:39:51 <JoeyA> (used to index array, mind you)
12:39:56 <NihilistDandy> chrisyoung: Saw that. I've been hoogling in ghci for a bit, along with pointfree, and that's been a pretty good deal
12:40:05 <JoeyA> :t (!)
12:40:07 <NihilistDandy> I used to use GoA, but I haven't built lambdabot in a bit
12:40:07 <chrisyoung> Cool.
12:40:08 <lambdabot> Ix i => Array i e -> i -> e
12:40:14 <Kaidelong> so when doing IO should I avoid lazy bytestrings like the plague?
12:40:20 <bjackman> JoeyA: Yeah, I saw that in a page about Arrays, but it isn't in the prelude so I wasn't sure if the same thing applied to lists?
12:40:30 <chrisyoung> I tried installing lambdabot and ended up in cabal hell. Which was frustrating.
12:40:35 <amindfv> In practice the Ix constraint is usually annoying
12:40:35 <bjackman> oooh
12:40:37 <bjackman> :t (!!)
12:40:44 <lambdabot> [a] -> Int -> a
12:40:45 <chrisyoung> It clashed with . . . yesod maybe? Can't remember.
12:40:49 <amindfv> (^^ bjackman)
12:40:55 <JoeyA> Kaidelong: A lazy bytestring is basically a list of strict bytestrings.
12:40:57 <geekosaur> afaik lists are always indexed by Int? (and there are generic* list ops but they just use fromIntegral to produce an int)
12:41:02 <NihilistDandy> chrisyoung: cabal-dev 4 lyfe
12:41:14 <Kaidelong> JoeyA: but when I call hPut it forces the whole list?
12:41:18 <bjackman> ah ok awesome I'll just stick with Int then! Thanks
12:41:24 <geekosaur> or something like that
12:41:27 <amindfv> NihilistDandy: don't get that tattoo till you try hsenv...
12:41:28 <chrisyoung> Ah yes, I'm trying to do that more.
12:41:36 <JoeyA> Kaidelong: yes.
12:41:51 <JoeyA> Now if that forcing is causing I/O to be performed, then it's lazy IO
12:41:51 <Kaidelong> okay, thanks a lot
12:41:59 <chrisyoung> Part of my problem with cabal-dev for me is that I haven't got it working with the ghci prompt in emacs yet.
12:42:00 <NihilistDandy> amindfv: I actually used hsenv for a bit, cabal-dev was just easier to throw in my path for common stuff like ghc-mod and hlint
12:42:01 <Kaidelong> umm
12:42:06 <JoeyA> And lazy IO can cause weird problems if you don't understand it well.
12:42:08 <monoidal> geekosaur: I don't believe so. generic* functions they work just as normal list functions, via pattern matching
12:42:13 <monoidal> @src genericLength
12:42:13 <lambdabot> genericLength []    = 0
12:42:13 <lambdabot> genericLength (_:l) = 1 + genericLength l
12:42:17 <Kaidelong> well, that might be a problem, I don't want the program to exit before it finishes writing the file
12:42:24 <chrisyoung> Yes, I've been experimenting with hsenv too, but run into similar problems around tooling.
12:42:36 <NihilistDandy> amindfv: I'll have to look into it again, though. I imagine it has been improving
12:42:40 <chrisyoung> There's hsenv.el, but I'm not sure if it works on os x
12:42:43 <amindfv> chrisyoung: what problems have you had?
12:42:44 <Kaidelong> on the other hand it may be nice to render the XML in bits and append using a lazy bytestring from the builder rather than making a strict bytestring and putting the whole thing in memory
12:42:47 <geekosaur> hm, ISTR some of those just did fromIntegral, but yes genericLength at least ought to do it "right"
12:42:50 <NihilistDandy> chrisyoung: It does, last I used it
12:42:54 <JoeyA> Kaidelong: you don't have to worry about that.  hPut's job is to traverse the whole list and write it.  It will do its entire job before returning.
12:43:09 <JoeyA> But hGetContents will return immediately, and only perform the I/O upon request.
12:43:22 <Kaidelong> ah I see
12:43:33 <Kaidelong> which means hGetContents can cause trouble if you mess with its handle
12:43:47 <JoeyA> Well, it can cause trouble if you don't consume all the files you read.
12:43:51 <chrisyoung> Hmmm, probably n00b errors. Story of my life. Let's see. When I finally got around to the fork everyone uses of hsenv.el it would tell me that it loaded the env properly, but ghci couldn't find a package I had installed in the hsenv.
12:44:31 <JoeyA> If you read 2000 or so files with hGetContents without forcing all the lists, your program will run out of file descriptors.
12:44:33 <Kaidelong> Mm, wouldn't another problem be that hGetContents would not close the handle after returning?
12:44:49 <JoeyA> Kaidelong: it puts the handle in a "semi-closed" state.
12:44:51 <NihilistDandy> chrisyoung: Last I used it was a year or so ago, so don't take my testimony as truth :D
12:45:27 <amindfv> is there a reason why there's no option to turn on non-exhaustive pattern-match warnings for do-notation?
12:45:54 <amindfv> e.g. `(Foo a b) <- bar` if `Foo` is part of a sum type
12:46:09 <chrisyoung> Ah, I see. I've read conflicting things. The README suggests it isn't confirmed to work on a mac, but that may be just because it hasnt' been updated from the forked repo's README.
12:46:19 <gwern> @quot readme
12:46:19 <lambdabot> No quotes match. Take a stress pill and think things over.
12:46:20 <simpson> amindfv: IIRC it's because the spec says that the pattern match may fail, and it will call the Monad's `fail` method to be invoked.
12:46:40 <amindfv> or `(x:xs) <- foo` in the case of an empty list
12:46:43 <JoeyA> Kaidelong: From a quick test, if you hClose a handle after calling hGetContents, it will truncate the list returned.
12:46:59 <simpson> amindfv: If you'd like GHC to care about this, draw from the action without a pattern match and then use a case-of.
12:47:00 <amindfv> simpson - ahhh, right - in the case of `Maybe` it's actually useful...
12:47:09 <simpson> amindfv: Yeah, it's a little cheap for Maybe. :3
12:47:26 <simpson> do { thing <- action; case thing of ... }
12:47:32 <JoeyA> So when you say xs <- hGetContents, the value of xs can change as a result of side effects like hClose.
12:47:49 <JoeyA> Unless you consume xs before calling hClose, then the list will be in memory, and xs won't change.
12:48:49 <JoeyA> I like to use partial patterns in IO when writing tests.
12:48:59 <JoeyA> Right db <- open ":memory:"
12:49:08 <JoeyA> If the pattern match fails, I'll get an error telling me what line failed.
12:50:10 <Eduard_Munteanu> JoeyA: that's what 'fail' is for
12:50:18 <JoeyA> Right
12:50:37 <Eduard_Munteanu> Yeah, I guess it could report stuff more nicely.
13:03:11 <elliott> Cale: lambdabot is broken
13:03:12 <elliott> > 123
13:03:14 <Kaidelong> flushToFile builder path = withFile WriteMode path >>= Builder.toByteStringIOWith . ByteString.appendFile
13:03:17 <Kaidelong> this looks right to me
13:03:18 <lambdabot>   mueval: ExitFailure 1
13:03:19 <lambdabot>  mueval: Prelude.undefined
13:03:33 <Kaidelong> oh no it isn't
13:03:46 <Six> hey there, I have a question concerning datatype constructors
13:04:01 <Taneb> > 123 :: Int
13:04:02 <Kaidelong> didn't pass builder to toByteStringIOWith
13:04:06 <lambdabot>   mueval: ExitFailure 1
13:04:07 <lambdabot>  mueval: Prelude.undefined
13:04:12 <Six> data Maeppchen = Maeppchen Farbe [Stift] (Lineal | None)
13:04:19 <Taneb> > Prelude.fromInteger 123
13:04:28 <Six> the part (Lineal | None) won't work
13:04:32 <Taneb> > 123
13:04:43 <lambdabot>   mueval: ExitFailure 1
13:04:53 <Taneb> > 123
13:04:54 <Six> how is it possible to have different constructors for one datatype?
13:05:01 <Kaidelong> flushToFile builder path = withFile WriteMode path >>= (`Builder.toByteStringIO` builder) . ByteString.appendFile
13:05:01 <lambdabot>   123
13:05:12 <Kaidelong> this should work, anyone see anything wrong with it?
13:05:15 <typoclass> Six: hello, yes that's not possible. "|" is a top-level thing: "data ... = ... | ... | ...". you can't put it in parens
13:05:46 <Six> so is there another possibility?
13:06:08 <Six> I need to check whether the Maeppchen has a Lineal or not
13:06:15 <monoidal> Maybe Lineal?
13:06:27 <typoclass> Six: you could use "data Foo = Lineal | None" and then "data Maeppchen = Farbe [Stift] Foo". however, there's a predefined type Maybe that can represent "none"
13:06:46 <Six> Ohh, I didn't thought about Maybe
13:06:58 <Six> thanks, I guess that'll do
13:06:59 <aavogt> Bool can probably work too
13:07:08 <typoclass> > [Just "x", Nothing] -- 2x the same type (Maybe String)
13:07:20 <lambdabot>   mueval: ExitFailure 1
13:07:33 <Six> Lineal has 2 attributs, so I guess Bool won't work
13:07:42 <typoclass> oh excellent. i think it will work :-)
13:11:15 <Ralith> Is there any way to look up the size of Int in a program?
13:11:27 <typoclass> > maxBound :: Int -- Ralith, try this
13:11:30 <Ralith> ah, right
13:11:32 <lambdabot>   9223372036854775807
13:11:46 <noteventime> Ralith: I believe there's a sizeof in the Storable type class
13:12:08 <Jeanne-Kamikaze> indeed
13:12:30 <typoclass> Ralith: standard disclaimer -- if you need to rely on that, you may be doing it wrong(TM)
13:14:15 <JoeyA> Note that if you're doing FFI stuff, the C type corresponding to Int is HsInt, which you can get with #include "HsFFI.h"
13:14:26 <JoeyA> (in C code)
13:15:02 <Ralith> handy, though not relevant in this case
13:21:14 * hackagebot hmemdb 0.3.1.0 - In-memory relational database  http://hackage.haskell.org/package/hmemdb-0.3.1.0 (MiguelMitrofanov)
13:21:30 <Kaidelong> is there a library out there that will give me a withFile that can create and modify files inside of zip archives and return a handle System.IO can use?
13:22:09 <Kaidelong> I don't know if that's an unreasonable thing to want or not, but whether or not it is it would be nice
13:22:56 <adimit> Does anybody have (good) experience with Emacs haskell-mode's interactive-mode? It's amazingly buggy for me, to the point where it's entirely unusuable… :-(
13:26:14 * hackagebot wai-static-pages 0.1.0.0 - generate static html pages from a WAI application  http://hackage.haskell.org/package/wai-static-pages-0.1.0.0 (GregWeber)
13:26:17 <Kaidelong> did not find that but Codec.Archive.Zip does what I need
13:29:42 <ParahSailin> i dont have to use any special mode in a text editor for haskell
13:30:14 <ParahSailin> concise language ftw
13:31:14 <noteventime> Has anyone here tried using Hakyll with bib(la)tex?
13:32:46 <lpvb> are there any downsides to using GADTs everywhere instead of normal ADTs?
13:33:06 <lpvb> it seems like GADTs are more powerful and replace normal ADTs
13:34:01 <noteventime> lpvb: The could would be less portable
13:34:11 <lpvb> besides that?
13:34:19 <geekosaur> newtype deriving still an issue?
13:34:35 <geekosaur> (didn't someone determine that it was unsafe in general?)
13:34:36 <Six> how can I overwrite Show for my datatype?
13:34:47 <Six> tried this: http://codetidy.com/5545/
13:35:11 <geekosaur> and what happened?
13:35:26 <noteventime> Six: What's wrong with it?
13:35:32 <Six> but I get an error because of the Maybe
13:35:51 <Six> "No instance for (Show (Maybe Lineal -> Maeppchen))
13:36:04 <Six> arising from a use of 'show'"
13:36:26 <noteventime> Six: Are you sure it's your instance that's incorrect?
13:36:32 <noteventime> and not some other part of your code
13:36:56 <noteventime> It sounds like you're trying to show a Maeppchen where you forgot to supply the Maybe Lineal
13:37:20 <Six> m1 = Maeppchen Schwarz [Stift Bleistift Blau 2, Stift Kugelschreiber Gruen 3, Stift Bleistift Blau 5]
13:37:24 <Six> tried it with this one
13:37:31 <noteventime> Yes, and it's lacking the Maybe Linear :)
13:37:32 <Six> so there is no lineal
13:37:44 <noteventime> data Maybe a = Nothing | Just a
13:37:51 <noteventime> So you need to give it  Nothing
13:38:03 <Six> adding nothing worked^^
13:38:13 <Six> I thought nothing = no argument
13:38:17 <noteventime> Maybe is still a type like any other
13:38:24 <noteventime> There's no magic about it :)
13:38:34 <Six> alright, thanks :)
13:38:43 <noteventime> If it wasn't there, you could have defined it yourself just like I did above
13:39:29 <Six> No idea why, but the Maybe stuff is still strange to me
13:39:57 <Kaidelong> haskell has type holes now, right?
13:40:05 <Kaidelong> does lambdabot do that?
13:40:14 <Kaidelong> Also was it ? for a hole?
13:40:15 <noteventime> Six: Do you understand the notion of Sum types? (i.e. those where you have multiple constructors delimited by | )
13:40:28 <Six> yup
13:40:39 <noteventime> kaictl: I thought so to, but last time I tried to find out the syntax and/or extension I couldn't fin it
13:40:54 <geekosaur> lambdabot doesn't have holes. ?foo is an implicit type, which is sort of a value-level hole; the holes in recent ghc are type level
13:40:57 <quchen> Kaidelong: Type holes are only in HEAD right now. They're probably going to be in 7.8.
13:40:58 <noteventime> Six: So 'Maybe a' is just a data with two constructors, 'Just a' and 'Nothing'
13:41:17 <quchen> Eh, "typed holes", pardon.
13:41:37 <Six> and Nothing is a type itself?
13:41:42 <Kaidelong> @ty (<$>) :: (r -> j) -> ?foo
13:41:43 <Six> or just something like null
13:41:45 <lambdabot> parse error (possibly incorrect indentation)
13:41:52 <adimit> Six: Nothing is just a constructor of the Maybe type.
13:41:53 <noteventime> Six: No, it's a value of the type, just like False is a value of type Bool
13:42:04 <Kaidelong> oh
13:42:12 <Kaidelong> I see what you mean
13:42:15 <Kaidelong> value level so I have to
13:42:23 <quchen> Six: You can see it this way: Bool is the most basic 2-type-constructor-type: data Bool = True | False. Maybe now extends on this concept, allowing you to add a value to the "True" part.
13:42:42 <quchen> So you can see Maybe as a Bool where True has a label attached :-)
13:42:48 <Kaidelong> @ty (f : (r -> j)) <$> g `seq` g
13:42:53 <noteventime> And adding a value to the False part gives you an Either
13:42:57 <lambdabot> Pattern syntax in expression context: r -> j
13:43:05 <Six> that makes sense
13:43:06 <Kaidelong> @ty (f :: (r -> j)) <$> g `seq` g
13:43:08 <raid> Six: but you can attach anything, not just a string
13:43:13 <lambdabot>     Could not deduce (Show r, FromExpr j) arising from a use of `f'
13:43:14 <lambdabot>     from the context (FromExpr a)
13:43:14 <lambdabot>       bound by the inferred type of it :: FromExpr a => a at Top level
13:43:28 <noteventime> lambdabot: Calm down
13:43:47 <Kaidelong> needs lambda abstractions I suppose
13:44:16 <noteventime> So the holes are available without any language extension?
13:44:27 <Kaidelong> in ghc head
13:44:46 <Kaidelong> oh
13:45:04 <Kaidelong> {-# LANGUAGE TypeHoles #-}
13:45:05 <Kaidelong> so noi
13:45:11 <Kaidelong> you need an extension
13:45:38 <Kaidelong> oh wait nevermind, that example was meant as a motivating example
13:46:11 <Kaidelong> although the same haskell wiki page (http://www.haskell.org/haskellwiki/GHC/TypeHoles) says you need to enable it with TypeHoles
13:47:23 <Kaidelong> also looks like type holes do not mean "infer the rest" but "always fail to compile and suggest what I should put in the whole"
13:48:27 <c_wraith> the hole thing
13:48:44 <mm_freak> it would be great to have agda-style holes in haskell
13:48:49 <noteventime> Indeed
13:49:22 <quchen> mm_freak: Aren't the upcoming holes somewhat similar?
13:49:37 <quchen> (I'm not familiar with Agda, so all I've heard is hearsay)
13:52:32 <NihilistDandy> Sort of similar, though I think Agda's are more powerful, so to speak
13:52:52 <NihilistDandy> Though it might lay the groundwork for similar code derivation as is seen in Agda
13:56:59 <monoidal> Kaidelong: you can -defer-type-errors and it will compile with hoesl
14:01:14 * hackagebot prizm 0.1.0.0 - A haskell library for computing with colors  http://hackage.haskell.org/package/prizm-0.1.0.0 (ParnellSpringmeyer)
14:09:13 <hidenori> does anyone know a website to check an order of each prelude function?
14:09:43 <jocolloman> hidenori: What do you mean order?
14:10:11 <hidenori> jocolloman: O(n) or sth like that
14:11:15 * hackagebot prizm 0.1.0.1 - A haskell library for computing with colors  http://hackage.haskell.org/package/prizm-0.1.0.1 (ParnellSpringmeyer)
14:13:38 <jocolloman> hidenori: I don't know of a place that has that information directly available. I imagine most of the functions over lists are going to be O(n) due to the nature of lists.
14:14:06 <jocolloman> hidenori: Is there a particular function you were wondering about?
14:14:13 <hidenori> jocolloman: I see. yes
14:14:18 <hidenori> jocolloman: (!!)
14:14:41 <simpson> hidenori: It's O(k) where k is the index you want to look up.
14:15:07 <hidenori> simpson: it does not depend on the length of the list?
14:15:32 <monoidal> hidenori: no
14:15:45 <hidenori> monoidal: I see. Thank you guys!
14:15:50 <jocolloman> hidenori: (!!) iterates down the list until it gets to that element.
14:16:14 <noteventime> hidenori: Often complexity is mentioned in the haddock docs
14:16:28 <noteventime> Though I'm not sure how iften it is for Prelude
14:16:56 <hidenori> jocolloman: I see. thank you!
14:18:04 <hidenori> noteventime: wherecan i find haddock?
14:18:56 <jocolloman> hidenori: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
14:19:42 <hidenori> jocolloman: thank you!
14:24:20 <monochrom> hidenori: it also comes with GHC, therefore on your own disk
14:24:40 <simpson> hidenori: Also consider the definition of (!!).
14:24:42 <Kaidelong> why on earth is there no "getUNIXTimestamp :: IO Int" in the base libraries, or similar
14:24:43 <simpson> @src (!!)
14:24:43 <lambdabot> xs     !! n | n < 0 = undefined
14:24:44 <lambdabot> []     !! _         = undefined
14:24:44 <lambdabot> (x:_)  !! 0         = x
14:24:44 <lambdabot> (_:xs) !! n         = xs !! (n-1)
14:25:22 <hidenori> monochrom: Im not too familiar with GHC...
14:25:55 <monoidal> hidenori: you use a different compiler?
14:26:02 <hidenori> simpson: aww i see. yea it makes sense
14:26:23 <hidenori> monoidal: I'm still a beginner and only have used GHCi
14:26:27 <monoidal> ok.
14:26:49 <monochrom> Kaidelong: IMO getCurrentTime :: IO UTCTime is better. find it in Data.Time.Clock. the package name is "time". there is probably a unix time in the package "unix", but I'll too lazy to find it
14:27:53 <noteventime> hidenori: Haddock is the standard haskell document generator (kinda like javadoc, doxygen, or pydoc if you're familiar with any of those)
14:27:59 <Eduard_Munteanu> @hoogle getPOSIX
14:27:59 <lambdabot> Data.Time.Clock.POSIX getPOSIXTime :: IO POSIXTime
14:28:06 <noteventime> documentation*
14:28:45 <hidenori> noteventime: actually haskell is my first language so im not sure about them... what is "document generator"?
14:29:31 <troydm> hidenori: first functional language or first programming language?
14:29:44 <hidenori> troydm: first programming language
14:30:07 <troydm> hidenori: i'm not sure if it's a bad or good
14:30:12 <Kaidelong> what am I supposed to do with that though, ">>= fromIntegral" doesn't work because NominalDiffTime doesn't implement Integral
14:30:34 <Kaidelong> floor?
14:30:44 <troydm> sure
14:30:47 <troydm> do floor
14:30:53 <noteventime> hidenori: The most common use is to have them extract documentation from your code (usually written in special comments) and generate an easy to browse document from it
14:30:57 <monoidal> hidenori: haddock is a tool that generates a file looking like this: http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html
14:31:10 <troydm> Kaidelong: if u you are not interested in millisecond precision
14:31:34 <Kaidelong> I need to give Codec.Archive.Zip an mtime
14:31:38 <hidenori> noteventime : I got it. thanks
14:31:53 <noteventime> hidenori: That's pretty cool btw, what made you choose Haskell?
14:31:54 <hidenori> monoidal: thank you
14:32:02 <scriptor> hidenori: a document generator like haddock or javadoc looks at code, specifically at the comments, and generates HTML files (or other formats) for documentation
14:32:37 <hidenori> noteventime: my friend recommended me. i tried C for a few days before but haskell looks easier to me so far actually
14:32:48 <Kaidelong> it expects an Integer
14:32:56 <noteventime> Well, they both have their quirks :)
14:33:09 <hidenori> scriptor : I see thanks!
14:33:39 <scriptor> yep, he went for na
14:33:42 <scriptor> goddammit kevin
14:33:58 <hidenori> noteventime: i think GHCi is helpful for beginners like me.
14:34:11 <noteventime> hidenori: Not only for beginners :)
14:34:29 <jocolloman> hidenori: What resources are you using to learn Haskell?
14:34:49 <hidenori> noteventime: i thought ppl who are good at haskell use ghc
14:34:59 <scriptor> they have different purposes
14:35:01 <noteventime> hidenori: GHCi is part of GHC
14:35:02 <hidenori> jocolloman: Learn you a haskell for great good
14:35:27 <Eduard_Munteanu> @where lyah
14:35:27 <lambdabot> http://www.learnyouahaskell.com/
14:35:28 <jocolloman> hidenori: Awesome, that is where I started. You may also find FPComplete useful. https://www.fpcomplete.com/school/basics-of-haskell
14:35:29 <scriptor> ghci helps you quickly test a function you made
14:35:56 * bgamari wishes there was a shorter alias for DeriveFoldable, et al.
14:36:00 <hidenori> noteventime: ohh i see didnt know that
14:36:01 <noteventime> hidenori: But as scriptor said, they have different purposes, you wouldn't run large programs from ghci, but I think most people have it around for testing small aspects of their code while writing it
14:36:15 <bgamari> by the time you've written the LANGUAGE pragma you could have just written the damn instances ;)
14:36:46 <hidenori> jocolloman: yea that is very helpful for beginners. i will check the link. thanks :)
14:36:55 <Dacto> hidenori: ghci is also nice tool for learning as it allows you to check types and do other neat things.
14:37:01 <scriptor> hidenori: is there anything in lyah so far that you find confusing or difficult as a beginner?
14:37:21 <hidenori> noteventime:aw i see. for C i had to write whole codes and it depressed me lol
14:37:32 <Kaidelong> @ty floor
14:37:39 <lambdabot> (Integral b, RealFrac a) => a -> b
14:38:20 <mauke> :t get `on` floor
14:38:23 <lambdabot> (Integral b, RealFrac a, MonadState (b -> c) ((->) b)) => a -> a -> c
14:38:28 <hidenori> Dacto: i think so. its really a good tool
14:38:29 * mauke opens the door
14:38:45 <noteventime> hidenori: I know the feeling, I'm writing a bunch of C code at the moment, and I really miss being able to continually load it into something like ghci.
14:39:12 <hidenori> scriptor: i think it should include more discriptions on folds and scans but overall its very good
14:39:26 <scriptor> how far into it are you?
14:39:31 <Dacto> noteventime: just imagine how i feel writing asm.. :P
14:39:59 <doomlord> http://pastebin.com/QnJ0ik21 <<< what am i doing wrong :(  "vadd is not a visible method of class Vec3" the intent here is 'vadd' could be implemented for different types,not just 'Vec3 a'
14:40:10 <mauke> The paste QnJ0ik21 has been copied to http://hpaste.org/87611
14:40:17 <Kaidelong> so I wound up with
14:40:18 <hidenori> im done with chapter 6
14:40:23 <Kaidelong> getTimestamp = fmap floor getPOSIXTime :: IO Integer
14:40:51 <monochrom> yeah I think that works
14:40:51 <Dacto> hidenori: curious, are you learning for a course or on your own?
14:40:58 <Kaidelong> as NominalDiffTime implements RealFrac that should work
14:41:32 <arkeet> doomlord: instance Num a => VecOps (Vec3 a) where ...
14:41:36 <arkeet> is probably whwat you meant
14:41:50 <hidenori> Dacto: On my own.
14:41:52 <noteventime> Dacto: Fell, in that particular aspect you aren't any worse off :P
14:41:53 <doomlord> arkeet,  thanks
14:42:06 <doomlord> that wasn't clear to me though
14:42:16 <Dacto> hidenori: very nice
14:42:19 <arkeet> "if a is an instance of Num, then Vec3 a is an instance of VecOps"
14:42:56 <doomlord> i found myself fumbling around throwing Num a  in various places in response to other errors... and i never tried it there lol
14:43:02 <hidenori> Dacto: it's fun but nobody around me knows haskell which often makes me sad
14:43:17 <arkeet> doomlord: well, you should stop fumbling around and think :p
14:44:43 <doomlord> i gave up on haskell  last time i tried it... things that were easy in C++ seemed harder... but i'm coming back after having seen 'traits' in rust, which i get..
14:45:56 <noteventime> hidenori: Many of the more mainstream languages are getting Haskell-inspired features
14:46:03 <noteventime> So it might change in the near-ish future
14:46:14 <jocolloman> doomlord: If you are able to get over the hump and write in haskell enough that you think in it first, C++ will feel extremely cumbersome.
14:46:20 <doomlord> trait VecOps {}         impl VecOps for Vec3<f:Num> { ...... }
14:46:21 <jocolloman> doomlord: Atleast, that is my experience.
14:46:32 <doomlord> stockholm syndrome :)
14:46:32 <noteventime> I still give a self satisfied chuckle every time a Java programmer speaks of anonymous functions as a "new feature" :P
14:46:40 <doomlord> everything else i try has me going back to C++.
14:46:46 <hidenori> noteventime: i hope so. at least i hope my school bookstore will have haskellbook sometime soon
14:46:50 <hidenori> lol
14:46:57 <doomlord> i got furthest liking Rust .. but still miss straightforward overloading in C++
14:47:02 <scriptor> noteventime: not that anonymous functions are haskell features :)
14:47:19 <scriptor> well, not that java's were specifically inspired by haskell
14:47:49 <noteventime> scriptor: Well, if you think of them as Java's version of first class functions
14:48:00 <hpc> scriptor: java generics were designed by SPJ iirc?
14:48:01 <noteventime> That's an answer to the first point, not the second one
14:48:08 <blackdog> gwern: i think i worked it out in the end - for some reason, it happens with a stripped binary, but not the original one.
14:48:18 <noteventime> hpd: Was it SPJ, I thought it was one of the other wizards
14:48:18 <doomlord> well I liked Rust traits, and reading that they are aparently inspired by haskelltypeclasses i figure i should try haskell again
14:48:20 <gwern> blackdog: huh. strip is supposed to be very safe
14:48:58 <noteventime> Great, now that I finally got Hakyll to accept my Bibtex references it no longer interprets my mathematics
14:49:35 <doomlord> it does confuse me that the type constraint in the 'instance' goes at the front - i would have thought it relates to the second part of that declaration
14:49:51 <hpc> doomlord: the first key step to getting comfortable in haskell, i think, is passing functions to functions whenever possible
14:50:05 <doomlord> hpc ... that side of it i'm sold on
14:50:09 <arkeet> it is?
14:50:10 <hpc> or putting functions in data structures
14:50:15 <doomlord> i really like the HOF's approach
14:50:27 <doomlord> i totally despise idiomatic C++ code with iterators
14:50:35 <ion> The next step is unsafeCoerce. At that point you’re halfway into implementing lens.
14:51:15 <noteventime> The only thing that tends to make me use C once in a while is for array operations
14:51:23 <noteventime> of the pointer twiddling kind
14:51:57 <noteventime> And now that I need a sparse linear algebra library
14:52:02 <scriptor> doomlord: what were some of the things you tried last time in haskell?
14:52:18 <blackdog> gwern: *helpless shrug*
14:52:22 <doomlord> i got some asteroids flying around with gl bindings
14:52:58 <hpc> doomlord: neat; which package did you use for opengl? there's a ton of them at varying levels of abstraction
14:53:08 <doomlord> not sure i remember but i still have it lying around
14:53:15 <hpc> some are as miserable as opengl itself, some are quite nice
14:53:15 <alexyk> let's say cabal configure shows missing dependencies.  How do I install all of them?  In a source checkout of a Haskell project from darcs.
14:53:15 <doomlord> glut bindings i think
14:53:22 <blackdog> i'll try to get a test case together - it doesn't happen when calling getProtocolByName directly, only in the context of my program atm
14:53:29 <hpc> doomlord: yep, miserable :P
14:53:40 <doomlord> i figure gluts' interface is very anti-haskell
14:53:49 <hpc> extremely
14:53:56 <doomlord> its even clumsy in C++, you can't pass a state object pointer in
14:54:10 <doomlord> but its widespread and works
14:54:27 <doomlord> i found glut hugely portable, i have a glut based sourcebase compiling fine everywhere
14:54:33 <jocolloman> noteventime: For an assignment this semester, we had to implement this virtual machine: http://www.boundvariable.org/um-spec.txt I chose to do it in Haskell. At the end of the assignment there was a speed competition. I was able to win with my haskell implementation BUT I ended up using creating a very small 10 line C file for doing mallocs. This "doubled" the speed from 1:30 to 0:45.
14:55:02 <doomlord> hpc, where i gave up was trying to do a model loader, i had my C++ code to do that and..
14:55:18 <doomlord> didn't really fully understand how to use the state monad etc..
14:55:20 <noteventime> jocolloman: That's interesting, did try to figure out why it wouldn't reach that kind of performance in Haskell?
14:55:36 <hpc> doomlord: just getting a working program is farther than i have gotten
14:55:53 <fizbin> @hoogle (a -> m [b]) -> [a] -> m [b]
14:55:54 <lambdabot> No results found
14:56:05 <jocolloman> noteventime: It was actually quite fast in Haskell using Data.Vector.Unboxed.Mutable.
14:56:06 <doomlord> also something else that made me give up on that was: a big feature i miss in C++ is reflection , and i'm not sure if haskell is any better at that sort of thing
14:56:13 <fizbin> @djinn (a -> m [b]) -> [a] -> m [b]
14:56:14 <lambdabot> Error: Undefined type []
14:56:38 <simpson> :t mapM
14:56:40 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
14:56:41 <simpson> :t sequence
14:56:43 <lambdabot> Monad m => [m a] -> m [a]
14:57:02 <hpc> doomlord: lemme try and find a good piece of code i have written as an example of something haskell is stronger at
14:57:04 <jocolloman> noteventime: I was using a Vector of Vectors to keep track of the arrays in the VM. This was where the slowdown was coming from
14:57:32 <doomlord> hpc i do like the elegance of haskell where it works, its can be awesome
14:57:36 <ion> @type traverse `asTypeIn` \f -> f undefined (undefined :: [a])
14:57:42 <doomlord> i like the type inference, and tuple destructuring
14:57:43 <lambdabot> Applicative f => (a -> f b) -> [a] -> f [b]
14:57:44 <fizbin> simpson: So I had written (sequence $ map func lst) but that gave me m [[b]]
14:57:44 <jocolloman> noteventime: I am almost positive if I wrote a malloc like function that just used one giant Vector it would have been just as fast as the version using an FFI to do mallocs.
14:57:54 <doomlord> and partial application
14:58:01 <simpson> :t \f xs -> do { xss <- mapM f xs; return $ concat xss }
14:58:08 <lambdabot> Monad m => (a -> m [a1]) -> [a] -> m [a1]
14:58:16 <simpson> fizbin: ^^ ?
14:58:22 <fizbin> Maybe...
14:59:21 <doomlord> hpc at the minute "rust" looks like the most promising 'next language' for me - but one nagging doubt - if its so close to C++,maybe i'm just better off sticking with C++ and trying to find something else taht just complements it instead of trying to replace it.
14:59:22 <noteventime> jocolloman: Vector of vectors wouldn't be unboxed, right?
14:59:36 <jocolloman> noteventime: That is exactly right.
15:00:13 <simpson> doomlord: It's really not that close to C++.
15:00:18 <noteventime> jocolloman: I ran into that issue when I trying to have it as an intermediate represenation in some Repa code
15:00:41 <sm> alexyk: cabal install --only-dep [--dry]
15:01:17 <hpc> doomlord: http://hpaste.org/87612 -- here's something i have forgotten to put on github
15:01:36 <fizbin> simpson: I went with (liftM concat $ mapM func lst)
15:01:38 <alexyk> sm: when I do it in a source checkout for project x, it tells me cannot find x-0.2, just like plain cabal install.
15:01:45 <doomlord> simpson its very close IMO. C++11 .. with everything const by default.. and a better OO system
15:01:51 <fizbin> :t liftM concat . mapM
15:01:57 <lambdabot> (a1 -> [a]) -> [a1] -> [a]
15:01:58 <hpc> doomlord: it takes a url like http://imgur.com/XYgz2 and tries other capitalizations; it's a fairly silly script
15:02:02 <alexyk> do I have to explicitly say cabal install x --onlly-dep?
15:02:03 <doomlord> overloaded functions have to have been grouped into a trait.
15:02:05 <sm> alexyk: have you done cabal update ?
15:02:13 <jocolloman> noteventime: I'm looking into using repa for an image processing library I'm working on. Do you like it?
15:02:24 <simpson> doomlord: And yet C++ is still horrid.
15:02:25 <noteventime> jocolloman: Most of it is very nice
15:02:31 <alexyk> sm: yes, the source project is not in hack age.  I need to get all its deps from hack age to build it.
15:02:34 <troydm> jocolloman: the one mentioned on reddit?
15:02:35 <hpc> the algorithm is roughly, generate all permutations of the slug "XYgz2", then for each permutation fetch the page in a separate thread
15:02:43 <doomlord> simpson, I like *my* version of C++ :)
15:02:47 <troydm> jocolloman: named unhm-it or something like that
15:02:49 <jocolloman> troydm: Yes.
15:02:58 <hpc> at the end, evaluation joins the threads and it prints which URLs didn't 404
15:02:58 <troydm> jocolloman: cool project
15:03:04 <troydm> jocolloman: g'luck
15:03:06 <simpson> doomlord: Where the memory models are made-up and the access modifiers don't matter? >:3
15:03:07 <sm> alexyk: oh.. does the package depend on itself ? (an executable depending on the library ?) maybe the cabal file is bad
15:03:38 <doomlord> simpson  whenever i try any other language i still find myself missing C++ features here and there.
15:03:42 <jocolloman> troydm: Thanks! I had a lot of fun writing the Boxed stuff as purely functional image processing
15:03:51 <simpson> doomlord: I'm so very sorry. :c
15:04:03 <noteventime> jocolloman: I haven't been able to figure out how to do some "columnwise" operations (e.g. transform an Array DIM2 a by applying an Array DIM1 a -> Array DIM1 b on each column)
15:04:07 <doomlord> rust still lacks function overloading, traits are nearly tthere but you ended up needing macros for n-ary function calls
15:04:12 <hpc> doomlord: the big feature i exploited for that script was first-class IO
15:04:27 <suppi> hello, is www.learnyouahaskell.com a good source to learn from?
15:04:27 <jocolloman> troydm: But if it is to be used for anything that needs high performance an Unboxed Parallelized version is a must.
15:04:48 <hpc> suppi: the best
15:04:51 <noteventime> suppi: Many seem to think so
15:05:07 <doomlord> why would you say C++ and Rust *aren't* similar - i think they're similar because Rust explicitely has the goal of being able to replace C++
15:05:11 <suppi> thanks. that is good to know.
15:05:13 <jocolloman> noteventime: Have you looked at repa-algorithms? I don't know if they have what you're asking for but a friend told me there are good resources there.
15:05:24 <doomlord> its a hugely cleaned up syntax, and has some extra features for concurency of course...
15:05:57 <pikhq_> doomlord: Similar in intent perhaps. Not in structure.
15:05:58 <ion> hpc: I would propose a personal tutor who’s good in both tutoring and Haskell would be a better resource. :-P
15:06:13 <pikhq_> C++ is designed to be similar to C.
15:06:18 <hpaste> fizbin pasted “Request for style comments” at http://hpaste.org/87615
15:06:20 <alexyk> sm: seems no self-dependency…
15:06:25 <hpc> ion: probably :P
15:06:29 <pikhq_> People say "superset", but they lie. C and C++ just have a decent-sized common subset.
15:06:41 <doomlord> I much prefer struct/traits/impls to the C++ idea of classes
15:06:41 <alexyk> sm: http://hub.darcs.net/position/weshift/browse/weshift.cabal
15:06:54 <fizbin> (In particular, style comments from people who know Template Haskell)
15:06:55 <doomlord> my C++ style is to use non-member functions alot, because i despise classes
15:07:45 <noteventime> jocolloman: I've seen it, but I think it mostly implements some "standard" algorithms (sorting, some linear algebra and the likes)
15:07:45 <suppi> why, doomlord?
15:08:09 <simpson> doomlord: Uh, Rust's goal isn't to supplant C++, it's to provide a platform for things on the scale of Firefox.
15:08:16 <noteventime> What I'm missing are a bunch of higher order functions
15:08:22 <doomlord> they are targetting C++ programmers
15:08:28 <simpson> IYSS.
15:08:33 <simpson> Clearly this isn't gonna go anywhere.
15:08:35 <doomlord> they are trying to create a viable C++ replacement
15:09:51 <doomlord> suppi i like the abilty to just bolt "methods" on, non-member functions are better at decoupling... C# has extention methods to get around the problem, D has "uniform call syntax".
15:10:01 <noteventime> Let's hope Carmack's wolf3d port is successfull and he convinces all the good C++ programmers to go Haskell instead ;)
15:10:10 <doomlord> C++ useed how i think is correct looks inconsistent because you have to mix method syntax and function syntax
15:10:16 <fizbin> doomlord: I'm not sure that "targeting C++ programmers" is identical to "trying to create a viable C++ replacement".
15:10:24 <suppi> i mean, why do you despise classes in c++?
15:10:32 <doomlord> for the above reason
15:10:53 <doomlord> the conflict between making things functions and class methods
15:11:11 <fizbin> It could well mean "they think C++ has too large a niche, and they want to replace its use _in particular domains_"
15:11:15 <doomlord> functions are usually better.  but the syntax & culture herds you to make methods
15:11:41 <doomlord> well i know what I want and Rust ticks a lot of boxes
15:11:48 <noteventime> doomlord: Why are you using C++ over C?
15:11:52 <noteventime> Templates?
15:12:00 <doomlord> templates + overloading + RAII
15:12:05 <fizbin> That is, there's a difference between "want to replace C++ everywhere" and "want to replace C++ somewhere".
15:12:11 <doomlord> but the OOP "culture" just annoysme
15:12:46 <simpson> doomlord: I bet that you can't actually define any objective linguistic traits that make a language "object-oriented."
15:12:53 <noteventime> doomlord: Especially when it start speaking of design patterns :P
15:13:02 <doomlord> probably, but there's definitely an OOP "culture" that annoys me :)
15:13:16 <doomlord> and it generally centres on the word "class"
15:13:34 <simpson> Really? I have seen object-based languages that don't have classes.
15:13:41 <noteventime> Or on "object", which is a usually described as a dog
15:13:45 <doomlord> maybe they wouldn't annoy me
15:13:48 <johnw> doomlord: is Rust trying to be both "oop" and functional?
15:14:01 <doomlord> Rust is multi-paradigm, like My version of c++
15:14:07 <fizbin> Would it be better if object were described as a burrito?
15:14:07 <hpc> johnw: "is rust trying to be scala" ;)
15:14:20 <noteventime> fizbin: But then objects would be monads :o
15:14:24 <johnw> one of my favorite things about Haskell has been my appreciation of its "remorseless purity", as SPJ terms it, which sort of makes us single-paradigm, but in a good way I think
15:14:25 <doomlord> let me find a liink...
15:14:36 <doomlord> which describes my specific frustration more eloquently
15:14:37 <Ankhers> Is there a function that will see if the elements in a list are unique?
15:14:47 <noteventime> And I'm not sure what coalgebras of monads look like
15:14:50 <alexyk> so, given a cabal file, how do I install all deps from it?
15:14:56 <doomlord> http://www.drdobbs.com/cpp/how-non-member-functions-improve-encapsu/184401197
15:14:57 <quchen> johnw: Haskell is multiparadigm. It also supports a functional programming style! :-)
15:15:06 <tgeeky> johnw: and purity => every equational reasoning trick in the book
15:15:07 <simpson> Ankhers: That's not a common thing to want; usually you want the uniquified list.
15:15:07 <fizbin> noteventime: Okay, what if we describe an object as a co-burrito?
15:15:07 <doomlord> ^^^^ i showed this to OOP C++ progammers and they said "nonsense"
15:15:10 <johnw> quchen: but isn't that its only paradigm?
15:15:16 <simpson> Ankhers: Which is `nub`.
15:15:19 <simpson> Ankhers: What are you building?
15:15:35 <doomlord> http://www.drdobbs.com/cpp/uniform-function-call-syntax/232700394 <<< this is "D"'s solution to my problem,
15:15:37 <quchen> johnw: That was just a(n intended) joke on it being a fine imperative language ;-)
15:15:38 <johnw> Ankhers: isuniq = nub x == x?
15:15:44 <c_wraith> So...  Anyone want to run http://hpaste.org/87617 with profiling and -hy ?  I'm curious if other people get the same behavior I did. (you wouldn't *think* that should leak memory..)
15:15:45 <doomlord> and Rusts' solution is struct/trait/impl, which i like
15:16:03 <doomlord> basically i like to seperate code/data
15:16:20 <johnw> :t uncurry (==) `on` (nub &&& id)
15:16:21 <arkeet> then haskell is for you
15:16:25 <lambdabot>     Couldn't match expected type `(b0, b0) -> c0'
15:16:25 <lambdabot>                 with actual type `Bool'
15:16:25 <lambdabot>     Expected type: b0 -> b0 -> (b0, b0) -> c0
15:16:30 <Ankhers> simpson: I'm attempting to port a two way encryption algorithm to haskell. I need to know that the pool of characters to choose from a unique.
15:16:46 <noteventime> fizbin: Fine by me, but then Monads are co-dogs
15:17:04 <hpc> c_wraith: leak?
15:17:17 <simpson> Ankhers: Considered using Data.Set?
15:17:27 <hpc> c_wraith: it should print 0
15:17:34 <c_wraith> hpc: it's an infinite loop.
15:17:36 <hpc> and then terminate without going deeper
15:17:39 <hpc> hmm
15:17:46 <hpc> er, derp
15:17:54 <c_wraith> hpc: the problem is that it should be an infinite loop in finite memory, not grow indefinitely
15:17:55 <sm> alexyk: I think cabal install -v3 shows the reason: unknown package: snap-less . I think it shouild have given a better explanation without -v3, and the cabal devs would be interested in this case
15:18:26 <doomlord> haskell can't replace C++ because it doesnt have precise control over memory. Rust *does*
15:18:37 <Ankhers> simpson: Thanks.
15:18:37 <alexyk> sm: ah!  thx… I'll get snap-less from dip's github I guess
15:18:59 <johnw> "precise control of memory" to me reads, "The program has to get everything right, rather than the machine"
15:19:07 <johnw> programmer*
15:19:16 <doomlord> yes, but thats why C++ is used, situations where that is essential
15:19:17 <hpc> c_wraith: i really don't see where it could be leaking
15:19:29 <johnw> the evolution from punch-cards to today has been one of ceding more and more control to the machine in getting things right in our programs
15:19:39 <c_wraith> hpc: which is why I was so shocked that it was...
15:19:48 <doomlord> sure, but someone needs to implemnt the lower levels..
15:19:59 <hpc> it is... very easy to imagine it leaking though
15:20:03 <johnw> you can always import C code into your Haskell program, if you really need to
15:20:06 <doomlord> even c++ relies on new/delete implementations
15:20:09 <johnw> C is the new assembler
15:20:14 <doomlord> sure
15:20:23 <c_wraith> hpc: how's this for an added twist: it didn't leak if I made f simpler
15:20:28 <doomlord> i like C for waht it is more than i like C++
15:20:30 <hpc> if i had to guess, it's leaking g
15:20:56 <c_wraith> hpc: did you try running it with profiling to see if it's really leaking?
15:21:01 <monochrom> at this point, someone should say, "I use FPGA because I want precise control of logic gates"
15:21:14 <elliott> is this some kind of haskell vs. c++ argument
15:21:18 <doomlord> no
15:21:22 <c_wraith> I use two rocks because I want precise control of the time they make sound.
15:21:26 <johnw> elliott: isn't it always? :)
15:21:31 <johnw> #haskell-vs-c++
15:21:38 <doomlord> i dont think haskell competes with C++
15:21:53 <tgeeky> well that certainly solves it. They are incomparable.
15:21:56 <simpson> elliott: Well, yes, on Thursdays we stop bashing PHP and pay attention to C++ for a day.
15:22:05 <tgeeky> next question!
15:22:07 <hpc> c_wraith: no leak in ghci with no profiling
15:22:34 <c_wraith> hpc: might be GHC version dependent.  It has all the feeling of a bug
15:22:44 <sellout> doomlord: Perhaps you haven’t seen http://research.microsoft.com/en-us/um/people/simonpj/papers/ndp/haskell-beats-C.pdf yet ;)
15:23:07 <lispy> sellout: Did you notice the part where C++ beats ghc?
15:23:26 <hpc> c_wraith: it's also possible that profiling changes how it runs?
15:23:33 <hpc> run without profiling, watch it in top
15:23:45 <c_wraith> hpc: possible, but the code I derived that from would crash with "out of stack space"
15:23:51 <hpc> hmm
15:23:59 <hpc> i am using 7.4.1 to test
15:24:23 <hpc> i assume you are on 7.6.2?
15:24:55 <c_wraith> hpc: actually, 7.0.4
15:25:01 <hpc> heh
15:25:08 <hpc> i will try with -hy and profiling
15:25:29 <sellout> lispy: I hadn’t gotten that far yet, but I winked for a reason.
15:26:06 <hpc> c_wraith: what compile flags did you use?
15:26:12 <jamil_1> hi all, if I have functions f1:: Integer -> a and f2 :: Float -> a,   (f1 10) and (f2 10) both work
15:26:14 <jamil_1> why is it?
15:26:17 * hpc doesn't remember everything you need to do proper profiling
15:26:26 <fizbin> Anyone with TH experience care to take a look at http://hpaste.org/87615 and tell me if I'm doing anything weird in there, or if I'm doing things the hard way with no reason?
15:26:38 <hpc> jamil_1: (10 :: Num a => a)
15:26:44 <c_wraith> hpc: ghc -O2 -prof -auto-all -rtsopts
15:26:44 <hpc> Integer is an instance of Num, and so is Float
15:26:54 <c_wraith> hpc: then ran it with +RTS -hy
15:27:20 <hpc> still no leaking afaict
15:27:40 <jamil_1> right so sort of implicit cast
15:28:05 <noteventime> jamil_1: It isn't really cast "from" anything though
15:28:40 <noteventime> jamil_1: Rather the symbol "10" is polymorphic
15:29:00 <c_wraith> hpc: hmm.  I get lovely results like this: http://imgur.com/nAh3t43
15:29:08 <monochrom> it is not cast. it is choose.
15:29:12 <hpc> c_wraith: https://dl.dropboxusercontent.com/u/37707/test.hp
15:30:18 <hpc> i don't have hp2hs somehow
15:30:22 <arkeet> jamil_1: numeric literals are polymorphic. 10 really means fromInteger (10 :: Integer)
15:30:24 <arkeet> :t fromInteger
15:30:26 <lambdabot> Num a => Integer -> a
15:30:41 <arkeet> :t 10
15:30:43 <lambdabot> Num a => a
15:31:13 <jamil_1> I see
15:33:07 <k0ral> @hoogle m (a -> b) -> a -> m b
15:33:08 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
15:33:08 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
15:33:08 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
15:40:32 <dmwit> Has anybody done some kind of randomized amortized time analysis?
15:41:01 <noteventime> dmwit: Like sampling complexity and applying statistical methods?
15:41:21 <tgeeky> dmwit: I've asked about it in a much less concise way than that before, and got nowhere
15:41:25 <dmwit> Example: one way to do functional arrays update badly is to have a list of versions. To look at an index, you take the value from the latest version.
15:41:50 <dmwit> Nice because it's O(1) to update, but O(u) to do lookup where u is the number of updates.
15:42:48 <dmwit> Slightly better: do that, but put an upper bound (say, 20) on the number of updates you keep before you allocate a fresh array.
15:43:02 <k0ral> @hoogle m (a -> m b) -> a -> m b
15:43:03 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
15:43:03 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
15:43:03 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
15:43:09 <dmwit> Still bad because then if you store the 19th version, and do a lot of updates on it, you pay for a lot of allocations.
15:43:19 <k0ral> @hoogle m (a -> m b) -> m a -> m b
15:43:20 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
15:43:20 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
15:43:20 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
15:43:34 <dmwit> So I wonder whether anybody's thought about randomizing whether you allocate a fresh array or keep the old one and do a cheap update.
15:43:37 <tgeeky> k0ral: all of lambdabot's functions work in private message
15:43:57 <k0ral> oh, sorry for the noise :S
15:44:02 <dmwit> (Or, if random things make you nervous, hashing the number of updates and freshly inserted value to use as a "random" but deterministic number.)
15:44:25 <dmwit> tgeeky: Okay, bummer!
15:44:41 <tgeeky> dmwit: after hearing what you are describing, I retract what I said. Not what I was thinking about :o
15:47:21 <tgeeky> dmwit: having read what you said; what do you want to do with it? Performance testing?
15:47:34 <tgeeky> what is the time analysis part
15:47:51 <dmwit> I'm reading the fgl paper and... musing, I guess.
15:48:20 <dmwit> It has a longish paragraph complaining about the state of the art in functional arrays. =)
15:48:53 <derek_c> exi
15:48:54 <derek_c> exit
15:49:22 <dmwit> Answering this question is probably six steps removed from dealing with the problem I'm having right now. =P
15:50:14 <SrPx> Hey guys, what's your preferred convention? "ends_with prefix str" or "ends_with str prefix"? (ends_with is just a random example)
15:51:20 <cmccann> SrPx: order arguments by decreasing likelihood of partial application being useful
15:51:21 <hpc> > "this" `isSuffixOf` "I prefer it like this"
15:51:23 <lambdabot>   True
15:51:40 <cmccann> or for 2-argument functions, the order that reads properly when written infix style
15:52:04 <skyflash> Any cute tricks for a function to coerce either an Int or a Double to a Double?... or do I have to create a new type class (for Num n) to achieve this?
15:52:23 <arkeet> what do you mean by "either an Int or a Double"?
15:52:44 <arkeet> :t either fromIntegral id
15:52:46 <lambdabot> (Integral a, Num c) => Either a c -> c
15:52:52 <arkeet> :t either fromIntegral id :: Either Int Double -> Double
15:52:53 <lambdabot> Either Int Double -> Double
15:53:00 <skyflash> I want to pass it an Int and get a Double, or a Double and get a Double
15:53:04 <hpc> skyflash: the most effective trick is to know statically which one of Int or Double you have?
15:53:05 <cmccann> :t realToFrac
15:53:07 <lambdabot> (Fractional b, Real a) => a -> b
15:53:27 <skyflash> hpc: if I were to set that aside?
15:53:41 <hpc> skyflash: javascript :P
15:53:47 <skyflash> hpc: hehe
15:53:47 <arkeet> skyflash: you could make like a ToDouble class. and write Int and Double instances for it
15:53:59 <SrPx> hpc: cmccann exactly, you both just said my internal conflict. str `ends_with` prefix is pretty, but (ends_width prefix) fn is beautiful too, because partial.
15:54:00 <skyflash> In CAL we have "toDouble" as a method on Num
15:54:04 <skyflash> not do in Haskel
15:54:34 <skyflash> arkeet: yeah, that's what I figured.
15:54:38 <cmccann> SrPx: (`endsWith` prefix) works
15:55:26 <cmccann> arkeet: a ToDouble class wouldn't do anything realToFrac doesn't already do
15:55:31 <SrPx> cmccann: I see, so `endsWidth str prefix` wins?
15:55:37 <SrPx> wops
15:55:42 <SrPx> endsWith prefix str
15:55:59 <arkeet> cmccann: does Int have a Real instance?
15:56:01 <skyflash> :t realToFrac
15:56:02 <lambdabot> (Fractional b, Real a) => a -> b
15:56:06 <arkeet> oh it does
15:56:13 <cmccann> arkeet: Real is the worst named type class ever, yes
15:56:15 <geekosaur> (endsWith str prefix) is (str `endsWith` prefix)
15:56:28 <SrPx> Wait no, I'm consufed.
15:56:36 <arkeet> skyflash: so yeah, use realToFrac everywhere.
15:56:36 <johnw> I confus!
15:57:04 <skyflash> Hmm.. OK, I'll take a look.  Thanks!
15:57:07 <SrPx> Oh nevermind, alright.
16:00:56 <doomlord> is + a member of a particular typeclass, can i derive/instantiate that for custom types
16:01:45 <noteventime> doomlord: Num?
16:01:58 <johnw> use: :i (+) in ghci
16:02:08 <noteventime> doomlord: You can always check with :t or :i :)
16:02:21 <cmccann> :t (+)
16:02:23 <lambdabot> Num a => a -> a -> a
16:02:29 <cmccann> @src Num
16:02:30 <lambdabot> class  (Eq a, Show a) => Num a  where
16:02:30 <lambdabot>     (+), (-), (*)           :: a -> a -> a
16:02:30 <lambdabot>     negate, abs, signum     :: a -> a
16:02:30 <lambdabot>     fromInteger             :: Integer -> a
16:02:35 <doomlord> that was my next question :)
16:02:36 <doomlord> thanks
16:03:10 <doomlord> damn its got "fromInteger" in it aswell
16:03:25 <FreeFull> Anyone here with experience using the Haskell SDL bindings?
16:03:49 <doomlord> so to instantiate "Num" for Vector { x,y,z} might not make much sense
16:04:14 <doomlord> what i want to express is "lerp" :  lerp should work for scalars, or vectors, but the last parameter is a scalar.
16:04:59 <doomlord> C++ , no type constraints ... template<typename T,typename T>  T lerp(T a, T b, F f) { return (b-a)*f+a;} <<< how does this concept translate into haskell, it at all
16:05:15 <doomlord> C++: if i provide overloads of + - *, lerp works
16:05:23 <mauke> did you mean: typename F
16:05:30 <doomlord> yes i did
16:05:56 <doomlord> rust: you can be a bit more precise as T,F would themselves have traits
16:06:12 <arkeet> haskell: if you provide Num instances of + - *, lerp works
16:06:14 <blackdog> huh. did --disable-executable-stripping go away?
16:06:18 <arkeet> er
16:06:20 <mauke> depends on what exactly you're trying to do
16:06:24 <arkeet> Num instances for uh
16:06:41 <mauke> lerp a b f = (b - a) * f + a  -- works but may not be what you want
16:06:43 <doomlord> i guess i could do that, but the whole of Num doesn't make sense for a Vector because it has "fromInteger"
16:06:50 * lispy isn't sure what fromInteger would be for vectors
16:06:58 <doomlord> exactly^^^
16:07:14 <arkeet> well, you should write what you mean then. there are vector space classes and such
16:07:16 <doomlord> although initializing a vector from scalar, its common to just put that scalar in all  the components
16:07:23 <mauke> lerp (*) (+) a b f = (b - a) * f + a  -- now parameterized on the actual operations
16:07:50 <lispy> doomlord: you could probably express what you want in terms of these typeclasses: http://hackage.haskell.org/package/vector-space-0.7.1
16:08:06 <noteventime> doomlord: Well, depends
16:08:16 <doomlord> i only know the language when i can recreate that from scratch, thats cheating at this point in the excercise
16:08:19 <noteventime> You could argue that fromInteger x = fromList [x]
16:08:22 <NihilistDandy> I'm not sure, but if I remember correctly a minimal Num instance doesn't require fromInteger
16:08:37 <cmccann> I think the only halfway sensible Num instance for vector-y types is the pointwise, zippy one.
16:08:49 <mauke> NihilistDandy: what
16:08:55 <noteventime> doomlord: In the sense that fromList [x] is the natural injection if you consider Vector as the free monad :)
16:09:07 <cmccann> in which case fromInteger x = pure (fromInteger x) = repeat x
16:09:09 <jocolloman> NihilistDandy: I believe you get a warning if fromInteger is not implemented.
16:09:14 <noteventime> monoid*
16:09:20 <NihilistDandy> I could be totally wrong, mauke. I looked at the report the other day about that, but I definitely don't remember clearly
16:09:36 <noteventime> cmccann: Sure, repeat x doesn't work for vector though
16:09:58 <NihilistDandy> mauke: Oh, nevermind
16:10:01 <NihilistDandy> I was wrong
16:10:05 <doomlord> it was interesting to be involved inthe rust IRC channel for a bit - they were inviting peopel to give feedback in designing their numeric traits :) (with lessons from haskell)
16:10:06 <FreeFull> * would have to be the cross product
16:10:16 <FreeFull> Or maybe not
16:10:30 <doomlord> at this point we'd be suggesting fromInteger is seperated from + * - negate
16:10:30 <FreeFull> Oh wait, yeah it would have to be the cross product
16:11:07 <FreeFull> Well, if you make * the dot product, you can write something like   5 * [x,y,z]
16:11:10 <arkeet> which is why you use a proper vector space class.
16:11:17 <noteventime> doomlord: I think most people consider Num to be somewhat broken
16:11:25 <lispy> doomlord: There have been a number of efforts to improve the numeric typeclasses in Haskell. It's not that hard to think of a better system. The hard part is going back in time and fixing it in Haskell before it gets adopted :)
16:11:35 <doomlord> hhaaha yes
16:11:38 <NihilistDandy> I've implemented up to Euclidean domains and fields. I should try to implement vector spaces, at some point
16:11:49 <arkeet> vector spaces are just modules over a field
16:12:04 <lispy> doomlord: vector-space is one such attempt
16:12:05 <doomlord> can it not be broken down and inherited from 2 components... Num : Arithmetic , Scalar
16:12:07 <cmccann> lispy: thinking of a better system that would not be a pain to use in Haskell is harder than it seems.
16:12:21 <NihilistDandy> Right, I know. I just haven't tried anything module-y, yet, in the code I've been playing with
16:12:31 <cmccann> at minimum, you'd need to change the way defaulting works, which means changing the language (if only via extensions).
16:12:33 <FreeFull> Haskell doesn't like ad-hoc overloading like some other languages do
16:12:33 <arkeet> modules are just vector spaces, except not necessarily over a field.
16:12:39 <doomlord> i dont know what Rust does explicitely here but they do things liike that, the traits derive from eachother
16:12:58 <FreeFull> It'd be nice to be somehow able to define your own + for your data type without having to use Num
16:13:09 <NihilistDandy> FreeFull: Make it a monoid
16:13:23 <NihilistDandy> Or a group, if your prefer
16:13:33 <cmccann> it's also tricky to make things as granular as desired without proliferating a million type classes that make writing instances for arithmetic take roughly infinity hours.
16:13:34 <noteventime> doomlord: I think most people (read me) would like something like Additative, Multiplicative with Num just containing fromInteger
16:13:35 <FreeFull> But that doesn't give you +
16:13:42 <FreeFull> It gives you <> or whatever
16:13:45 <doomlord> right that sounds much more like what they're doing in Rust
16:14:02 <alexyk> I get conflicting requirements with incompatible dependency version ranges: http://codepad.org/CvGjEI75
16:14:23 <noteventime> Though I guess you might wish to call Additative something like Abelian
16:14:29 <alexyk> when trying to build a project from source.  How are these usually resolved?  By building a dependency locally with a hacked .cabal?
16:14:41 <NihilistDandy> FreeFull: What's the difference between (+) and (<>)? Given two elements of one type, you get an element of the same type.
16:14:42 <doomlord> the point at whcih i jumped in they were seperating out the operations on real numbers...   Real : Transcendental, Algebraic   ... Transcendental: Exponential,Trigonometric,Hyperbolic... etc
16:14:53 <alexyk> sm: this is what happened next after I installed snap-less from source :)
16:15:03 <FreeFull> NihilistDandy: Well, + is addition, <> could be anything monoidal
16:15:28 <NihilistDandy> FreeFull: + is a special case of <>, from a theory standpoint
16:15:33 <FreeFull> NihilistDandy: And if you want to add multiplication and other operations..
16:15:42 <cmccann> FreeFull: that quickly leads to having three or four copies of Monoid using different names
16:15:44 <NihilistDandy> FreeFull: If you want to add those, you're not in a Monoid
16:15:44 <noteventime> I've always found it slightly annoying that <> looks like what a lot of people use for the unit of the free monoid :/
16:15:46 <FreeFull> I'm talking in practical terms
16:16:10 <doomlord> so should i make my own typeclass containing "add sub mul" ... in the abscence of a standard library one - and the go ahead and implement those for basic numbers to get my "lerp" - or should i implement Num for vectors and just do the fromInteger that initializes components...
16:16:11 <cmccann> noteventime: I still prefer (++) for mappend and will never give in. >:[
16:16:17 <noteventime> To be frank, I don't quite see the point of the Monoid type class
16:16:25 <doomlord> which way sucks less
16:16:36 <FreeFull> It's nicer to + two vectors together and then * the result by a scalar than to <> and then *****
16:16:37 <cmccann> doomlord: neither, they suck in different ways
16:16:57 <wilfredh> I have a trivial mean function `mean xs = (sum xs) / (fromIntegral (length xs))`. Is it possible to write this in a point-free way? I reference the argument twice.
16:16:57 <cmccann> doomlord: there's no non-sucky solution that's practical in the short or medium term I think
16:17:00 <NihilistDandy> FreeFull: If you want multiplication, you need at least a semiring. It's just a Monoid with multiplication, adter all
16:17:03 <NihilistDandy> *after
16:17:09 <FreeFull> cmccann: Do you like . for fmap too?
16:17:24 <doomlord> i dont mind having a slightly extraneous "fromInteger". quick initialize from 0 or 1
16:17:25 <FreeFull> NihilistDandy: The types aren't the same
16:17:27 <hpc> (<$>) is best fmap
16:17:31 <FreeFull> Vector multiplied by a scalar
16:17:40 <NihilistDandy> Then you can add additive negation and multiplicative identity and you get a Ring
16:17:52 <FreeFull> And you'll want scalar by vector too
16:17:53 <NihilistDandy> FreeFull: Types of what?
16:18:01 <NihilistDandy> Ah
16:18:19 <cmccann> FreeFull: no, I prefer (.) for the one in Category
16:18:28 <cmccann> FreeFull: I'd accept "map" for "fmap" though.
16:18:57 <doomlord> hmmm. if i implement "num" do the types for * have to be the same
16:18:58 <cmccann> so many good names are wasted on list-specific functions for no sensible reason >:[
16:19:06 <doomlord> because i do need vector* scalar for lerp
16:19:09 <FreeFull> doomlord: Yeah, what I was talking about
16:19:09 <cmccann> doomlord: yes, all the types must be the same
16:19:14 <noteventime> doomlord: Yes
16:19:20 <cmccann> doomlord: that's why the pointwise implementation is least awful most of the time
16:19:29 <cmccann> because then numeric literals can pretend to be scalar multiplication
16:19:31 <cmccann> but it still sucks
16:19:43 <FreeFull> cmccann: The reason is that there was no way to know that a more general implementation could be possible back when they were implemented
16:19:59 <FreeFull> And now we're stuck with it unless we use an alternative Prelude
16:20:00 <cmccann> FreeFull: I'm pretty sure the actual history is exactly the opposite of that
16:20:03 <noteventime> doomlord: Have you seen the vector-space package?
16:20:06 <cmccann> but I wasn't around for that
16:20:16 <arkeet> vector-space even comes with lerp
16:20:27 <jermey> http://hpaste.org/87578 anyone mind having a look at this and giving me a pointer or 2?
16:20:38 <doomlord> no, i should take a look, but at the same time i would only consider i "know"the language when i can write that myself... its cheating :)
16:20:49 <doomlord> i mean i should be able to figure out the way to express it
16:21:11 <doomlord> of course i'll take a look if eventually and use it
16:21:38 <doomlord> but right now if i can't figure out somehting similar myself, i dont know haskell really.
16:21:43 <noteventime> jermey: Do you know GADT syntax?
16:21:48 <cmccann> jermey: what's giving you trouble? are you familiar with how GADTs work?
16:22:04 <FreeFull> In Idris you'd define    (+) : (Num a) => Vec a -> Vec a -> Vec a     (*) : (Num a) => Vec a -> a -> Vec a      (*) : (Num a) => a -> Vec a -> Vec a      and be done
16:22:22 <cmccann> doomlord: just be warned that you can sink an unbounded amount of time into trying to solve this in Haskell as it stands without ending up with something useful at the end :[
16:22:23 <FreeFull> Where Vec is your vector type or whatever
16:22:34 <arkeet> but what if I don't like your vector type?
16:22:38 <Nisstyre-laptop> Is it a good idea to make use of the MonadComprehensions syntax with parsec?
16:22:42 <Nisstyre-laptop> it makes some things more concise
16:22:44 <doomlord> cmcann - this sort of thing is second nature to me in C++
16:22:47 <FreeFull> arkeet: Roll your own?
16:22:54 <jermey> cmccann: yes i m familiar
16:22:54 <arkeet> but then I can't use your +
16:23:02 <jermey> i m trying to think on make that to GADT
16:23:03 <FreeFull> arkeet: You can define your own +
16:23:06 <arkeet> or is your point that--ok
16:23:07 <FreeFull> And it will work for your type
16:23:15 <wilfredh> ah, got it.
16:23:29 <wilfredh> mean = sum &&& length >>> uncurry (/)
16:23:44 <acube> idris has function overloading?
16:23:53 <FreeFull> wilfredh: I bet that transverses the list twice
16:23:56 <johnw> :t id &&& nub >>> uncurry (==)
16:23:58 <lambdabot> Eq a => [a] -> Bool
16:23:59 <FreeFull> :t (>>>)
16:24:01 <noteventime> jermey: Have you figured out any of the constructors (say, for example, Con?)?
16:24:01 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
16:24:04 <Nisstyre-laptop> FreeFull: I don't think it does
16:24:06 <johnw> that's the formulation I was looking for before
16:24:08 <Nisstyre-laptop> :t uncurry
16:24:08 <doomlord> cmcann - the ease with which i can reason about this in C++ makes it a good comparison/benchmark for "how well do i know this language.."
16:24:09 <lambdabot> (a -> b -> c) -> (a, b) -> c
16:24:33 <jermey> noteventime: thats my problem
16:24:40 <lightquake> the maybe function corresponds to the Maybe type constructor in the same way that foldr does for [], right?
16:24:52 <jermey> i thought maybe somewhere here could point me in the right direction
16:25:15 <johnw> lightquake: yes, you can view it as a fold for Maybe
16:25:23 <noteventime> jermey: So the point is that you want to use the parameter 't' to give a "native" type to each term, right?
16:25:28 <cmccann> doomlord: don't get me wrong, it's fun to experiment with and may very well be a good learning experience
16:25:38 <jermey> noteventime: yeap
16:25:49 <cmccann> doomlord: just that you don't want to go down that rabbit hole if you want practical results sooner rather than later
16:26:14 <doomlord> equally using things i only half understand is bad
16:26:16 <lightquake> johnw: oh, that makes sense; maybe z f = foldr (\_ x -> f x) z
16:26:18 <lightquake> or something
16:26:22 <johnw> lightquake: since 'maybe' has type Maybe a -> a, then 'maybe' is an algebra for 'Maybe', for which the catamorphism is equal to the algebra since there it is not a recursive type.  Hence, it is also the fold for Maybe.
16:26:42 <arkeet> maybe has that type?
16:26:47 <FreeFull> :t maybe
16:26:48 <lambdabot> b -> (a -> b) -> Maybe a -> b
16:26:48 <lightquake> @type maybe
16:26:49 <lambdabot> b -> (a -> b) -> Maybe a -> b
16:27:02 <doomlord> this is an area i'm intimately familiar with, i've done vector implementations for a very long time :)
16:27:03 <johnw> I was thinking of the type of "maybe f g", sorry
16:27:05 <noteventime> jermey: So what would an appropaite type for a boolean constant be?
16:27:10 <arkeet> yes, maybe f g does it.
16:27:29 <arkeet> :t maybe ?n ?j
16:27:33 <lambdabot> (?n::b, ?j::a -> b) => Maybe a -> b
16:27:50 <FreeFull> :t maybe ?n id
16:27:51 <lambdabot> (?n::b) => Maybe b -> b
16:28:02 <mauke> :t fromMaybe ?n
16:28:04 <lambdabot> (?n::a) => Maybe a -> a
16:28:28 <tac> What is that ?n for?
16:28:37 <mauke> :t maybe ?clu ?st
16:28:38 <lambdabot> (?clu::b, ?st::a -> b) => Maybe a -> b
16:28:42 <FreeFull> maybe is in the Prelude
16:28:44 <arkeet> =)
16:28:44 <jermey> noteventime: would it be t -> bool ? i kinda feel stupid here
16:28:50 <FreeFull> tac: Is a hole
16:28:51 <cmccann> doomlord: then have fun! maybe you'll come up with a nicer approach than most...
16:29:01 <doomlord> can the typeclasses "derive" from eachother - eg could i make my own Num'   with + *  - ... but also "scale" which takes one scalar argument
16:29:02 <tac> oOOooooo holes
16:29:20 <noteventime> jermey: What about 'ConBool :: Bool -> Term Bool'?
16:29:24 <arkeet> doomlord: you can make subclasses.
16:29:27 <doomlord> cmcann i've still got a lot to learn in haskell land
16:29:31 <tac> :t lookup "hello my darling" ?xs
16:29:33 <lambdabot> (?xs::[([Char], b)]) => Maybe b
16:29:38 <johnw> doomlord: that actually a fun place to be :)
16:29:38 <tac> neat!
16:29:39 <arkeet> but that may not be what you want.
16:29:44 <arkeet> for what you have in mind.
16:30:01 <noteventime> jermey: If you want to keep the Val type, you'll want to make it a GADT too
16:30:14 <acowley> GHC is a quiter: "My brain just exploded"
16:30:19 <cmccann> doomlord: you'll probably end up wanting some language extensions before you're done here
16:30:23 <jermey> noteventime: could you please explain that line ConBool :: Bool -> Term Bool like i m 3?
16:30:29 <cmccann> acowley: stop being mean to GHC then!
16:30:40 <tac> :t zipWith ?f [1..] [2..]
16:30:41 <lambdabot> (?f::a -> b -> c, Enum b, Enum a, Num b, Num a) => [c]
16:30:49 <noteventime> jermey: So when writing GADTs you write the constructors as if you were writing type signatures for a function, right?
16:30:51 <tac> That is so cool
16:30:59 <mauke> tac: your face is so cool
16:31:03 <jermey> noteventime: yeap
16:31:04 <doomlord> cmcann, language extentions or just library modifications ( i seem to have unearthed a Num issue here, with talk of alternatives)
16:31:06 <cmccann> acowley: also, I seem to recall that the brain in question is SPJ's, because he didn't want to figure out how to make whatever you tried work.
16:31:06 <Nisstyre-laptop> doomlord: anything is possible, some things are just prohibitively painful
16:31:19 <noteventime> jermey: Instead of "data Foo = Bar Int Int" you'd do "data Foo where Bar :: Int -> Int -> Foo"
16:31:20 <tac> :t all ?myFace ?isItCool
16:31:22 <lambdabot> (?myFace::a -> Bool, ?isItCool::[a]) => Bool
16:31:24 <acowley> Some nonsense about binding GADTs in funny ways
16:31:31 <FreeFull> Is it me or is Data.Tree missing some convienience functions that are rather easy to write
16:31:36 <tac> mauke: that only left me with even more questions....
16:31:37 <tac> heh
16:31:39 <cmccann> acowley: GADTs and existentials and pattern bindings I think
16:31:40 <tac> anyway, I'm out
16:31:49 <acowley> When SPJ's brain is your hammer, some nails explode.
16:31:50 <doomlord> actually is there anything to stop me just making another class containing + * -
16:32:02 <doomlord> <let me try..>
16:32:04 <mauke> it's about naked existentials
16:32:09 <FreeFull> :t ?a
16:32:11 <lambdabot> (?a::t) => t
16:32:26 <cmccann> doomlord: make sure to import Prelude hiding the standard definitions
16:32:30 <noteventime> jermey: Now, your Term type has a type variable, so you need to indicate in the constructor what vlues it takes
16:32:36 <lightquake> FreeFull: such as?
16:32:37 <arkeet> FreeFull: like what?
16:32:47 <doomlord> oh if i do, it wont co-exist with prelude?
16:32:51 <acowley> Hmm, so GHC is a bit of prude when it comes to types
16:32:53 <FreeFull> doomlord: The compiler will error saying that + * - are already in a different class
16:32:56 <cmccann> doomlord: and possibly RebindableSyntax if you want literals to desugar using your code
16:33:05 <mauke> doomlord: it will, but any use will complain about ambiguous names
16:33:10 <cmccann> doomlord: nope, welcome to being incompatible with everything
16:33:16 <doomlord> ok... that would appear to put an end to that idea
16:33:20 <noteventime> jermey: So in your case a constant boolean term should require you to supply a boolean and would then produce a Term Bool, with me?
16:33:39 <FreeFull> lightquake: trim n, which gets rid of all levels below n, and which I have written
16:33:43 <jermey> noteventime: yeap
16:33:51 <noteventime> jermey: Which translates to ConBool having type "Bool -> Term Bool"
16:34:03 <FreeFull> trim 0 (Node a _) = Node a []; trim n (Node a xs) = Node a (map (trim (n-1)) xs)
16:34:11 <noteventime> jermey: That is to say, in that particular constructor you have t == Bool
16:34:13 <cmccann> doomlord: you can still make your own to use in your own code
16:34:26 <cmccann> doomlord: it just makes it difficult to interoperate with other code
16:34:31 <doomlord> conflicts with + *  - for standard library sounds like far too much trouble,
16:34:39 <doomlord> it would be better to have named add sub mul scale
16:34:42 <doomlord> in my own class
16:34:43 <cmccann> doomlord: in fact, I habitually import my own alternate Prelude in all my code
16:34:50 <noteventime> jermey: If you wanted to allow constants of any type you could do "Con :: a -> Term a"
16:34:59 <Nisstyre-laptop> FreeFull: here it just raises an ambiguous occurence error if you try to use it without specifying the Prelude version or not
16:35:06 <cmccann> doomlord: that changes some far less drastic things I dislike
16:35:25 <acowley> Dammit, stop exploding!
16:35:33 <noteventime> jermey: There's nothing "special" about the value you choose for the parameter, you could do something silly like "ConBool :: Bool -> Term Int"
16:35:37 <arkeet> doomlord: or your own operator names. vector-space uses ^+^ for vector addition and *^ for (left) scalar multiplication
16:35:52 <arkeet> (mnemonic: ^ appears on the side with a vector)
16:35:58 <doomlord> oh then you get the benefit of infix i guess
16:36:02 <jermey> noteventime: ah
16:36:40 <doomlord> is it just stockholm syndrome on my part, or is C++ overloading actually Good ?
16:36:56 <cmccann> it can be convenient, certainly
16:37:02 <noteventime> jermey: Is that enough of a pointer to get you started?
16:37:03 <arkeet> it can be pretty evil.
16:37:07 <cmccann> that too!
16:37:24 <arkeet> foo operator+(foo a, foo b) { launchMissiles(); return poop; }
16:37:25 <jermey> noteventime: so would the next line be And :: t  -> t?
16:37:29 <jermey> noteventime: maybe
16:37:44 <noteventime> jermey: Well, the constructor would always have to return a Term
16:37:45 <doomlord> heh yeah. ambiguous syntax too
16:37:47 <doomlord> a*b;
16:37:49 <Nisstyre-laptop> arkeet: that's more the ability to define impure functions that look like pure ones
16:37:55 <arkeet> sure
16:38:05 <arkeet> your fault for not using haskell.
16:38:09 <noteventime> jermey: And doesn't And take two things?
16:38:12 <arkeet> :p
16:38:16 <doomlord> a*b; /* launch the missiles as a side effect, did i mean declare a b as a pointer to a */
16:38:36 <jermey> noteventime: so like this? And :: Term -> Term -> Term?
16:38:40 <doomlord> c++ overloading .. who would think of overloading bitwise shift operators for file io. that would be silly woulnd't it.
16:38:53 <noteventime> jermey: Well, you can't do that, because Term takes an argument :)
16:39:18 <noteventime> jermey: So you could do "And :: Term t -> Term t -> Term t", but do you really want to allow application of "And" to Terms of arbitary type, or do you want to be more specific about the t?
16:39:50 <jermey> specific as in define if there Bool or string etc?
16:40:14 <noteventime> jermey: Well, I suspect you only want to accept it for t == Bool?
16:40:25 <jermey> noteventime: right
16:40:43 <noteventime> jermey: So then the type would be?
16:41:05 <jermey> so would that be And :: Term Bool -> Term Bool -> Term Bool?
16:41:08 <noteventime> Exactly
16:41:55 <caryatid> hello all! Was wondering about a simple bit of code to continue reading from a file after EOF is hit. Something that would act like `tail -f`.  Any ideas would be much appreciated.
16:42:12 <lispy> > nub "calculus"
16:42:14 <lambdabot>   "calus"
16:42:18 <jermey> noteventime:  ah got you man, so similar can be done for the other 3
16:42:26 <noteventime> jermey: In case it makes things easier to understand, you could have a type like "Pair :: Term a -> Term b -> Term (a,b)"
16:42:31 <noteventime> jermey: Yes
16:42:33 <jermey> also basic syntax question in GADT do the tab line up or is it the ::
16:42:58 <arkeet> the start of the lines have to line up.
16:43:06 <arkeet> I think.
16:43:39 <noteventime> yes
16:44:12 <lispy> caryatid: hWaitForInput? http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
16:45:01 <mauke> ಠ_ಠ
16:46:17 <jermey> hey noteventime at the hpaste i linked earlier, the Data Val thing at the bottom. i am confused on what that meant
16:47:00 <caryatid> lispy: thanks .. was looked right over that and was getting all messy with checking hIsEOF.
16:47:04 <lispy> caryatid: on closer inspection, hGetBuf is better for your purpose
16:47:15 <noteventime> caryatid: They had a separate type for constant values
16:47:19 <lispy> caryatid: the wait for input function can still raise an EOF
16:47:26 <noteventime> err, jermey*
16:47:40 <lispy> caryatid: but hGetBuf blocks when there is nothing to read, never returns EOF, and tells you how many things it read
16:47:48 <noteventime> jermey: Probably to avoid cluttering up the term type
16:47:52 <lispy> caryatid: sounds just about ideal :)
16:47:57 <caryatid> lispy: indeed. that looks just right
16:48:14 <arkeet> fwiw, tail -f doesn't work by keeping the same handle to the file open
16:49:45 <noteventime> jermey: That way you can cover all "constant term" cases with a single pattern match, instead of having to do separate ones for ints and bools
16:51:01 <caryatid> arkeet: interesting -- does tail -f remember seek position; reopen and read from previous seek pos?
16:51:09 <arkeet> I think so.
16:51:20 <arkeet> I haven't actually looked.
16:51:28 <lispy> strace would let you figure it out
16:51:37 <lispy> the seeking would show up in the log
16:53:29 <Cale> http://git.savannah.gnu.org/cgit/coreutils.git/tree/src/tail.c
16:53:38 <jermey> noteventime: so i wouldn't need to worry about that, as long as i define my And, Or etc correctly as in bool/int etc
16:54:23 <caryatid> yep I get a series of open/seek/closes [ with some other calls in the middle ]
16:54:37 <Cale> Looks like it uses inotify to detect changes too
16:55:01 <caryatid> lots of fstats too -- maybe checks size for changes
16:56:37 <arkeet> yeah, recent versions of gnu tail use inotify
16:56:45 <noteventime> jermey: You could just go for "Con :: a -> Term a"
16:56:52 <noteventime> That way you can create constant terms of any type
16:58:00 <noteventime> which wouldn't pose a problem, since you make your And/Or e.t.c. type safe by only accepting the right types (so if you create a constant term of some really weird type you won't be able to use it for anything anyway).
16:59:50 <lispy> if you define nub' xs = Data.Set.toList (Data.Set.fromList xs), you'd pick up an Ord constraint, but it would be O(n log n), right?
17:00:25 <copumpkin> yes
17:00:26 <noteventime> Yes
17:00:52 <copumpkin> or rather n * log(unique items in xs)
17:00:53 <lispy> interesting, Bird gives a rather long derivation of nub that is O(n log n) and uses Data.Set
17:01:05 <lispy> But he doesn't use my version
17:01:07 <copumpkin> lispy: it probably preserves order?
17:01:13 <lispy> no
17:01:19 <lispy> I'll hpaste it
17:01:26 <lispy> give me a minute
17:03:24 <jermey> noteventime: the definition "data Term t where"
17:04:59 <jermey> nvm
17:05:02 <jermey> i got it
17:05:26 <jermey> was going to ask would it be Con :: t -> term  t instead of a?
17:05:39 <noteventime> jermey: Both work
17:07:18 <jermey> i was just curious
17:07:24 <jermey> as t is in the definition
17:07:40 <jermey> is it better to use t, or in haskell there is no convention
17:08:28 <arkeet> t is fine. a is also fine.
17:08:42 <noteventime> jermey: t might be short for "type" here
17:08:56 <noteventime> You could also use "type -> Con type"
17:09:01 <arkeet> but please don't.
17:09:13 <noteventime> err, right X-D
17:09:36 <noteventime> arkeet: Took me a second to understand the violent reaction :P
17:14:12 <hpaste> lispy pasted “Nub by Bird” at http://hpaste.org/87625
17:14:27 <lispy> copumpkin: ^^
17:15:02 <lispy> I suspect the point is that he wanted to give a complicated real-world example of deriving an algorithm for the sake of the book and not because he would actually do it this way
17:15:21 <copumpkin> yeah, beats me
17:15:30 <copumpkin> I do like preserving order
17:15:37 <copumpkin> in which case I'd probably use a foldr
17:16:07 <lispy> heh, the version in my comment is backwards
17:16:09 <noteventime> Is 'nub' considered a real-world example? :D
17:16:30 <hpaste> lispy revised “Nub by Bird”: “fix a typo” at http://hpaste.org/87625
17:17:23 <lispy> noteventime: he says that calculating a version of nub with the designed big-O represents the same challenges that you face in practice with other algorithms
17:17:29 <lispy> desired*
17:17:41 <lispy> and his derivation is actually pretty complicated
17:17:54 <lispy> (and that seems to bring him pain)
17:20:47 <noteventime> lispy: I was mostly joking :)
17:21:22 <noteventime> Seems reasonable that you'd run into the same kind of problems when doing something like scheduling algorithms
17:21:38 <noteventime> Which I guess people would consider "real world"
17:22:05 <lispy> It's interesting to me that Data.List.nub is lazy but the Ord based nubs are all strict (I think)
17:22:15 <lispy> > take 1 (nub [1..])
17:22:17 <lambdabot>   [1]
17:22:32 <lispy> > take 1 (S.toList (S.fromList [1..]))
17:22:37 <lambdabot>   mueval: ExitFailure 1
17:22:38 <lambdabot>  mueval: Prelude.undefined
17:23:55 <edwardk> @remember ion The next step is unsafeCoerce. At that point you’re halfway into implementing lens.
17:23:55 <lambdabot> I will remember.
17:24:07 <lispy> heh
17:30:45 <Hidenori> I'm using Data.Map and wondering if I can insert data to map without using "insert"
17:31:21 <Clint> how do you mean?
17:33:04 <Hidenori> I want to add data to map and I know that it will come to the end of map. so I dont want to use insert and spend some time on searching where to insert.
17:33:42 <Hidenori> hard to explain... am I making sense?
17:34:03 <copumpkin> I know what you mean, but the cost to "search where to insert" is the same cost as inserting
17:34:11 <copumpkin> it's not like inserting at the end is easier
17:34:25 <copumpkin> you want to save on the comparison costs?
17:34:35 <Hidenori> yes
17:35:00 <copumpkin> I don't think there's any way to do that, but there is fromAscList that will build a map from an ascending list
17:35:09 <copumpkin> that's the only place they provide a "trust me" sort of API call though
17:35:45 <Hidenori> is it more troublesome to build map?
17:36:08 <lispy> ?hoogle fromAscList
17:36:08 <lambdabot> Data.IntMap fromAscList :: [(Key, a)] -> IntMap a
17:36:08 <lambdabot> Data.IntSet fromAscList :: [Int] -> IntSet
17:36:08 <lambdabot> Data.Set fromAscList :: Eq a => [a] -> Set a
17:36:17 <lispy> > fromAscList [1,2,3]
17:36:20 <lambdabot>   Not in scope: `fromAscList'
17:36:20 <lambdabot>  Perhaps you meant one of these:
17:36:20 <lambdabot>    `IM.fromAsc...
17:36:30 <copumpkin> Hidenori: are your comparisons really expensive or something? because the time spent comparing is usually super tiny
17:36:43 <copumpkin> it's log(n) comparisons and then you have your inserted map
17:37:32 <Hidenori> Im solving project euler and want to make use of map, but it will contain 1 million elements so...
17:37:40 <copumpkin> that's comparatively small
17:37:43 <copumpkin> what are your keys?
17:37:51 <Hidenori> Just integers
17:38:01 <copumpkin> then there is no real cost
17:38:09 <lispy> > log (10^6)
17:38:12 <lambdabot>   13.815510557964274
17:38:25 <copumpkin> if they're Ints, you can use Data.IntMap
17:38:28 <Hidenori> ohh i see.
17:38:30 <copumpkin> and that's a little more efficient
17:38:43 <Hidenori> actually its Integer
17:39:05 <copumpkin> :k Mu IntMap
17:39:06 <lambdabot>     Not in scope: type constructor or class `IntMap'
17:39:06 <lambdabot>     Perhaps you meant `IM.IntMap' (imported from Data.IntMap)
17:39:10 <copumpkin> :k Mu Im.IntMap
17:39:11 <lambdabot> Couldn't find qualified module.
17:39:17 <copumpkin> :k Mu IM.IntMap
17:39:18 <lambdabot> *
17:39:21 <copumpkin> fuck you, lambdabot
17:39:25 <noteventime> :P
17:39:25 <Hidenori> lol
17:39:42 <noteventime> I wonder what mystrious IntMap that is
17:39:51 <copumpkin> anyway, type IntegerMap = Mu IntMap
17:39:52 <copumpkin> >_>
17:40:05 <noteventime> Oh, what's the Mu here?
17:40:20 <copumpkin> type-level fixed point
17:40:34 <noteventime> Neat
17:40:40 <copumpkin> IntMap (IntMap (IntMap (IntMap (IntMap forever
17:40:48 <noteventime> Yea, I get it
17:41:11 <noteventime> Terminal algebra kind of thing
17:41:16 <nkpart> can I get a haskell platform 2013.2.0.0 RC somewhere?
17:41:40 <noteventime> err, coalgebra
17:42:15 <noteventime> Or terminal coalgebra in category with the right kind of omega-limits anyway X-D
17:43:02 <geekosaur> nkpart, the only binary installers I've seen yet are for OS X
17:43:10 <lispy> nkpart: http://www.ozonehouse.com/mark/platform/
17:45:49 <nkpart> Awesome, thanks
17:45:56 <nkpart> mac os x suits me just fine
17:51:12 <tgustaf> @help *
17:51:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:52:22 <tgustaf> @help if
17:52:22 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:52:38 <tgustaf> @help list
17:52:38 <lambdabot> list [module|command]
17:52:38 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
17:53:44 <hpc> tgustaf: lemme give you some advice for dealing with lambdabot
17:53:51 <hpc> tgustaf: the help commands all lie
17:54:10 <hpc> you must gain a deep understanding of it through the hidden art of /query lambdabot
17:54:40 <hpc> but beware! some secrets are deep and dark, and cannot be divined in such a controlled setting
17:55:17 <hpc> (but seriously, @help is uselessly terse and most commands will work in PM)
17:59:14 <zRecursive> What does "You are on the Featured tab." mean ?
18:00:14 <monochrom> does it refer to a tab called "Featured"? where "tab" refers to a GUI thing
18:06:41 <ccc>  /query
18:06:41 <ccc>                 lambdabot
18:10:54 <zRecursive> monochrom: thx
18:13:20 <acowley> Is there a canonical StateT built on strict tuples?
18:13:23 <doomlord> can typeclasses be implemented for multiple types, e.g.  class Renderable    .. Render...   instantiate 'Render' for different types of object (rect,elipse)into different types of canvas (eg bitmap,vector)
18:14:22 <zeta-> I'm trying to find functions that take an Int and return an ordinal String or Roman numerals?
18:14:24 <zeta-> The numerals package won't install unless I also install base <4.5 which is more than a year old :P
18:14:25 <zeta-> But I don't need it to be so comprehensive. Is there a more basic library?
18:15:10 <noteventime> j\\\\\
18:15:15 <noteventime> Ops, sorry
18:15:25 <acowley> doomlord: I'm not sure I'm understanding you right, but you can definitely use MPTC to have "instance Renderable Bob OilPaint" and "instance Renderable Bob Pastel"
18:15:25 <geekosaur> doomlord, multiparameter typeclasses are an extension. but (a) they're really not very usable without a way to infer the type of one parameter from the type of the other; (b) this sounds rather like you're trying to use them for OOP, which is a route that ends in tears
18:16:25 <geekosaur> zeta-, you can't install a different base anyway, it's baked into the compiler. I don't know of a packge for Roman numerals offhand, but for ordinary numbers:
18:16:27 <geekosaur> :t show
18:16:30 <lambdabot> Show a => a -> String
18:16:36 <geekosaur> (and other things)
18:16:57 <noteventime> Generating roman numerals sounds fiddly
18:17:03 <monochrom> it certainly ends in *my* tears. haven't you heard the idiom: "___ makes monochrom cry"? :)
18:19:03 <zeta-> Ok, thanks -- I've got show, and some hand-written conversions for limited cases
18:19:46 <zeta-> why does numerals specify base<4.5?
18:20:22 <wollw> I'm trying to figure out the best way to take a tree of filled with coordinates with each child node's coordinate being offset from the parent and draw objects at those coordinates.
18:20:31 <wollw> I assume I want some sort of fold
18:21:16 <monochrom> zeta-: it is always a good idea to specify a bound on base (and every dependency), but perhaps some bounds are too conservative
18:21:16 <Nisstyre-laptop> wollw: check out Control.Monad.Loops perhaps
18:21:24 <wollw> Nisstyre-laptop: I will, thanks.
18:21:48 <monochrom> I have seen "base < 10" which will last for a long while but there is also a risk
18:21:50 <geekosaur> you'd have to ask the maintainer, but it may be related to recentish changes in Num
18:22:04 <noteventime> wollw: Could you use traverse?
18:22:09 <acowley> It's frustrating how much slower pushing a pure computation through StateT s Identity is than just applying the thing.
18:22:57 <wollw> noteventime: taking a loot at Data.Traversable right now
18:23:02 <wollw> look*
18:23:13 <zeta-> can I tell cabal to 'relax' that constraint, just to try it out?
18:23:50 <monochrom> no, but you can "cabal unpack", "cd ____", edit a file, then "cabal install"
18:24:37 <zeta-> monochrom: Ah yes! might try that -- thanks
18:49:41 <zeta-> monochrom: numerals & numerals-base installed fine :-) now to try it out ...
19:08:26 <lispy> doomlord: typeclasses provide a way to say that a set of types all have something in common
19:09:15 <lispy> doomlord: in that regard, they're similar-ish to an interface
19:09:23 <lispy> doomlord: (but, not really the same thing)
19:09:54 <doomlord> i've never used an OO language with interfaces, but i've dabled with rust a little - they say its traits are like interfaces
19:11:56 <lispy> A common anti-pattern from Haskell beginners (who already know an OO language) is to use typeclasses as if they are OO classes. So you'll see a lot of people here quickly point out that it's a bad idea.
19:12:21 <doomlord> i dont like OO classes if it helps, i much prefer the seperation of types and functions as per Rust
19:12:30 <lispy> If you do need some implementation polymorphism, records get the job done in most cases.
19:16:28 <lispy> I guess it's not always clear when I want a typeclass vs. record for simulating some OO idea
19:16:42 <lispy> I was sitting here trying to think of how to describe my decision process
19:17:26 <lispy> One of the big things is that you can only have one instance per type if you're using a typeclass. With records you can have an 'instance' per value.
19:18:12 <doomlord> here, i'm trying to do the equivalent of function overloading in C++
19:18:29 <lispy> and that's the original case for typeclasses.
19:18:37 <lispy> Things like Eq
19:22:52 <joe9> Any suggestions on how I can convert Int to Second, please? http://codepad.org/nrXi0ETi
19:23:05 <joe9> line 14, I seem to be doing something wrong.
19:23:43 <joe9> forget it, got it.
19:23:46 <joe9> sorry for the bother.
20:05:50 <BonSequitur> Is it possible to use pattern matching as a test in an if clause/header? E.g. if I have a compound data type and I want to test for how it's shaped but I don't care about every part of it?
20:07:50 <BonSequitur> *if clause/guard, rather.
20:07:58 <Rotaerk> BonSequitur, use case-of
20:09:31 <BonSequitur> Ahh, of course. Thank you.
20:13:32 <lanchongyizu> hi!what does "." mean  in "unlines . takeWhile (/="42") . words"?
20:14:02 <dmwit> ?src (.)
20:14:02 <lambdabot> (f . g) x = f (g x)
20:14:02 <lambdabot> NB: In lambdabot,  (.) = fmap
20:14:29 <dmwit> It is function composition, as in math class.
20:15:04 <cmccann> ∘ is better.
20:15:11 <dmwit> But easier to type than ∘. =)
20:15:15 <cmccann> pf.
20:15:39 <cmccann> ∘ takes three keystrokes in my editor! and one of them is a modifier key.
20:15:50 <lanchongyizu> wwhy sqrt . succ 1 cause error in prelude?
20:15:54 <Rotaerk> cmccann, which editor?
20:16:05 <c_wraith> I like ∘, but 3 keystrokes is 2 too many
20:16:06 <dmwit> lanchongyizu: Because "succ 1" is not a function. =)
20:16:31 <dmwit> (except in certain special circumstances)
20:16:36 <cmccann> Rotaerk: I use SciTE, with an abbreviations file full of stupid unicode symbols
20:16:48 <Rotaerk> ah
20:16:53 <cmccann> Rotaerk: so ctrl-B does substitutions based on whatever is behind the cursor
20:17:11 <cmccann> (i.e., in this case it turns . into ∘)
20:17:35 <Kaidelong> I'm extremely tempted to use this: http://hackage.haskell.org/packages/archive/MissingH/1.2.0.0/doc/html/System-IO-HVFS.html to make an "easy" interface over Codec.Archive.Zip
20:18:58 <Kaidelong> it may just boil down to making archives an instance of HVFS
20:20:27 <lanchongyizu> why sqrt . sqrt 1 cause error?
20:20:46 <Rotaerk> lanchongyizu, for the same reason that sqrt . succ 1 does
20:20:48 <dmwit> lanchongyizu: Because "sqrt 1" is not a function. (Again, except in certain special circumstances.)
20:21:30 <Kaidelong> > sqrt (sqrt 1)
20:21:32 <lambdabot>   1.0
20:21:36 <doomlord> http://pastebin.com/W7ChQQNr <<<< i can get this to work if i only use 1 type parameter for my 'Arithmetic', and make f explicitely 'Float' and make another funcction constructing 'Vec3 Float' explicitely - but I can't seem to make it work leaving the types generic
20:21:39 <Rotaerk> lanchongyizu, note that there's a difference between "sqrt . sqrt 1" and "(sqrt . sqrt) 1"
20:21:50 <mauke> The paste W7ChQQNr has been copied to http://hpaste.org/87631
20:22:06 <lanchongyizu> why "unlines . takeWhile (/="42") . words" is ok?
20:22:09 <pdxleif> What's the state of the art of web input validation these days?  Formlets / digestive functors / etc?
20:22:10 <doomlord> i'm not even sure if i should be able to do this or not... is it possible to have type parameters in "instance"
20:22:26 <Kaidelong> @ty takeWhile (/="42")
20:22:29 <lambdabot> [[Char]] -> [[Char]]
20:22:33 <Kaidelong> @ty sqrt 1
20:22:36 <lambdabot> Floating a => a
20:22:45 <Kaidelong> @ty (.)
20:22:49 <lambdabot> (b -> c) -> (a -> b) -> a -> c
20:23:09 <Kaidelong> (the => does not matter there, just think of it as "a")
20:23:33 <pdxleif> > foldl1 (.) (replicate 1000 sqrt) $ 1
20:23:36 <lambdabot>   1.0
20:24:19 <Kaidelong> since . only works on things in the form "a -> b" and sqrt 1 isn't in that form it doesn't match
20:24:29 <Kaidelong> sqrt, however, is in that form
20:24:31 <Kaidelong> @ty sqrt
20:24:33 <lambdabot> Floating a => a -> a
20:24:43 <Kaidelong> hence why you can still do (sqrt . sqrt) 1
20:25:19 <lanchongyizu> another fuction for "->"?
20:25:44 <Kaidelong> "a -> b" represents a function from a to be
20:25:49 <Kaidelong> b...
20:26:03 <zRecursive> @ty (***)
20:26:05 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
20:26:21 <lanchongyizu> give me another functon for "->",then i can practice
20:26:57 <Kaidelong> actually for practice it might be best for you to think of functions that can be composed together
20:27:02 <dmwit> :t (+1)
20:27:03 <lambdabot> Num a => a -> a
20:27:13 <Kaidelong> like if you want the square root of the length of a string:
20:27:16 <dmwit> :t realToFrac
20:27:18 <lambdabot> (Fractional b, Real a) => a -> b
20:27:18 <Kaidelong> @ty sqrt . length
20:27:19 <lambdabot>     No instance for (Floating Int)
20:27:20 <lambdabot>       arising from a use of `sqrt'
20:27:20 <lambdabot>     Possible fix: add an instance declaration for (Floating Int)
20:27:30 <dmwit> :t sqrt . genericLength -- subtleties
20:27:32 <Kaidelong> oh well
20:27:34 <Kaidelong> yeah
20:27:34 <lambdabot> Floating c => [b] -> c
20:27:55 <dmwit> :t fst
20:27:59 <lambdabot> (a, b) -> a
20:28:05 <dmwit> :t divMod
20:28:06 <lambdabot> Integral a => a -> a -> (a, a)
20:28:11 <lanchongyizu> thx
20:28:52 <doomlord> how do i make a literal *float*
20:29:02 <Kaidelong> 10.0
20:29:18 <doomlord> this seems to be *Fractional*
20:29:22 <dmwit> doomlord: All number literals can have type Float.
20:29:30 <Kaidelong> if you need it to specifically be of a certain type you can just go (10 :: Double) or something
20:29:37 <doomlord> ah thats what i'm after
20:30:01 <dmwit> I'm... pretty sure Float is an instance of teh Fractional class.
20:30:01 <Kaidelong> usually you don't but there are some contexts where you might have to disambiguate, they are not even that rare
20:30:29 <byorgey> doomlord: note that Fractional is a type class, not a type.
20:30:31 <dmwit> I think doomlord is confused, and Kaidelong's flippant easy answers aren't helping that.
20:30:36 <byorgey> Float and Double are both instances of Fractional.
20:30:43 <doomlord> this relates to the code i'm pasting - it seems when i try to make the type generic, it thinks the literals are *Frctional* not *Float*
20:31:01 <dmwit> ?instances Fractional
20:31:03 <lambdabot> Double, Float
20:31:10 <doomlord> i can make a code path which is *Float* based ok, but when i try to make it generic driven by the literals it all falls down
20:31:19 <doomlord> but let me try with the cast..
20:31:20 <byorgey> doomlord: that just means your code works for both Float and Double.
20:31:35 <dmwit> Maybe you should ask your real question.
20:31:35 <doomlord> part was specialized to float , i think..
20:32:04 <doomlord> the real question is in my paste above; i have 2 versions, one working with Floats, one where i've tried to parameterize more .. and i can't get that working yet
20:32:10 <doomlord> http://pastebin.com/W7ChQQNr
20:32:11 <mauke> The paste W7ChQQNr has been copied to http://hpaste.org/87631
20:32:40 <applicative> doomlord: I think the problem is that you are going to need FunctionalDependencies or something.
20:32:59 <doomlord> does what i'm trying to do make any sense
20:33:08 <doomlord> is it even possible ... i figured it should be
20:33:41 <doomlord> in the 2 parameter version , the first could be anything (scalar, vector), the other needs to be a scalar
20:34:01 <lispy> doomlord: not to sound like a broken record here, but the vector-space package solves this problem. They use a language extension to od it.
20:34:13 <doomlord> a *language extension*.. oh.
20:34:30 <lispy> Maybe they solve a slightly different problem actually
20:34:48 <doomlord> yeah - and if i can't write code like this myself, i dont know haskell.
20:34:48 <lispy> They made a distinction between the vector space and the field it is over
20:35:25 <doomlord> if i dont understand how to write this - something i can do with ease elsewhere - i'm likely to trip up more with other things :)
20:35:59 <doomlord> (* when i say Elsewhere, i mean C++ really lol)
20:36:03 <lispy> Figuring out which methods go in a typeclass is hard. I've tried to do something similar to what you're doing and my /opinion/ is that the primitives you chose are not ideal :)
20:36:14 <dmwit> Yes, I agree with applicative. I think you would like a functional dependency (or associated type family) to encode the fact that the type "a" determines the type "f" uniquely in your "Arithmetic a f" class.
20:36:34 <doomlord> that does sound like it makes sense,
20:36:43 <lispy> What I discovered, is that for vectors you really want the type class to provide accessors for the elements and pointwise operations on them. You can build the rest from that.
20:36:50 <doomlord> i wondered if you could make a functoin "ScalarOf" .. taking a type , returning a type.. ?!
20:37:00 <dmwit> You can enable them with the FunctionalDependencies language extension; that is, add {-# LANGUAGE FunctionalDependencies #-} at the top of your file.
20:37:13 <applicative> doomlord: even if you convince the compiler that you are using Vec3 Float and Float as the scalar in main, it still wont know what the return type of add is
20:37:16 <dmwit> Then the syntax for the dependency I suggested is like "class Num f => Arithmetic a f | a -> f where".
20:37:22 <lispy> doomlord: you can make such a function with type families (vector-space does just that)
20:38:05 <lispy> doomlord: https://github.com/dagit/lin-alg/blob/master/src/Numeric/LinearAlgebra/Vector.hs#L18
20:38:13 <Kaidelong> personally I've gotten functional dependencies but I haven't quite yet got the handle on type families, in terms of which extension I think is more difficult to learn about
20:38:13 <lispy> doomlord: those are the vector primitives I settled on
20:38:30 <doomlord> i'll take a look but it feels like cheating
20:39:08 <dmwit> doomlord: After adding FunctionalDependencies and the dependency I suggested, the file compiles without error (but with warning).
20:39:08 <applicative> note that the instance you make means that you wont be able to use scalars of another type than you use  for Vector3 with FunctionalDependencies
20:39:15 <lispy> doomlord: if it makes you feel any better, my design is still not great :)
20:39:28 <applicative> there's a missing method
20:39:43 <doomlord> i was also trying to do this with scale defining its own second type parameter
20:39:48 <aavogt> doomlord: you don't need fundeps http://hpaste.org/87631
20:40:07 <aavogt> oops, that's not the right version
20:40:08 <doomlord> scale :: Num f => a -> f->a  ... but that didn't work
20:40:26 <doomlord> aavogt - i can make it work if i lower my ambition on how parameterized it is
20:40:30 <aavogt> if you scroll down you get it
20:41:22 <doomlord> aaah.
20:42:19 <dmwit> You might also consider just "class Arithmetic f where scale :: Num a => a -> f a -> f a" or some such thing.
20:42:20 <aavogt> so now the f takes a parameter
20:42:27 <doomlord> class Num a=> Arithmetic f a where ....  is this relying on the ability to "take a template as a template parameter"   (f=Vec3  , a=Float, whichi you could not do in C++)
20:44:23 <doomlord> aavogt,  thanks, but i wouldn't have found that :(
20:44:54 <doomlord> is that the method haskell's vectorspaces uses ?
20:45:36 <doomlord> expressed like this it certainly handles the cases i had in mind, although it would still be nice to use a different scalar optionally
21:02:24 <aavogt> doomlord: you could do that with    class Scale f a b where scale :: b -> f a -> f a, but then you'll likely need annotations to fix the type of the scalar
21:02:48 <aavogt> since you'll get different results if b is Int, Integer, Double etc.
21:03:19 <doomlord> you're suggesting move Scale out into a different typeclass?
21:03:43 <doomlord> (and i could put 'lerp' in there too perhaps)
21:03:57 <johnw> lerp herp derp
21:04:08 <aavogt> if you never expect to have a specialized lerp definition, it doesn't have to be in a class
21:04:35 <wavewave> hi
21:04:39 <doomlord> i've already discovered i can't just write it like in C++ :)
21:06:31 <wavewave> hoodle now has touch support .
21:06:44 <cmccann> wavewave: oh hey, I finished getting the essentials done for gtk extended input devices, finally.
21:06:47 <cmccann> if you're still interested in that
21:07:01 <wavewave> cmccann: great! that's exactly what I need.
21:07:11 <wavewave> cmccann: so did you make it work with gtk3?
21:07:27 <wavewave> cmccann: to support multitouch, we have to move to gtk3
21:07:36 <cmccann> the API changed in some not entirely trivial ways, so there's only partial gtk3 support
21:07:59 <cmccann> basically everything that stayed the same is there, but I didn't add anything that's new in gtk3
21:08:01 <wavewave> cmccann: that sounds good. for touch, it needs significant change.
21:08:51 <wavewave> cmccann: would you remind me of where I can find some code?
21:09:09 <cmccann> wavewave: haha, on my hard drive? :]
21:09:18 <wavewave> haha I see.
21:09:30 <cmccann> I was going to toss it at dmwit to go in a future release of the gtk package
21:09:50 <cmccann> once I add a few more haddocks and test it a bit
21:09:52 <wavewave> cmccann: sounds great..
21:10:00 <carter> cmccann howdy!
21:10:27 <cmccann> wavewave: if you'd like to help with the gtk3 portion, I can toss my modified version on github temporarily or something
21:10:39 <cmccann> I'm not really doing anything with gtk3 so don't feel like spending a lot of time on that :T
21:10:41 <cmccann> carter: yo
21:11:21 <wavewave> cmccann: yes. I can try to help. that's my great interest.
21:11:23 <carter> cmccann i've gone off the deepend
21:11:28 <carter> i htink
21:11:44 <wavewave> multitouch in gtk is supported from gtk 3.4
21:12:38 <wavewave> I was looking for every possible workaround with gtk2hs with gtk2, but not successful.. now my program can recoginize only one finger.
21:12:55 <wavewave> but still useful.. panning, zooming with hands.
21:13:12 <cmccann> right now I'm only worried about the stylus on my wacom tablet, so it's not an issue for me
21:13:26 <carter> in a good way
21:13:40 <wavewave> cmccann: yes. that was my status until a few days ago.
21:13:40 <cmccann> carter: which deep end is it? :D
21:13:49 <carter> THE AWESOME ONE
21:13:56 <johnw> carter: oh, do tell!
21:13:56 <cmccann> hells yeah awesome
21:14:01 <carter> well
21:14:08 <wavewave> cmccann: now with finger touch, it's greatly more powerful. ;-D
21:14:23 <carter> a) i realized a week or so ago "welp, i want all the SIMDs, llvm runtime code gen would be easier than patching ghc"
21:14:31 <wavewave> when pen movement detected, hoodle automatically change back to wacom mode.
21:14:33 <carter> or waiting till 7.8
21:14:59 <cmccann> carter: sounds reasonable
21:15:04 <wavewave> sometime, I am going to take a video of this. ;-)
21:15:06 <carter> yes
21:15:27 <carter> the part where to keep it sane and focused i'm writing a compiler to only generate matrix mult kernels
21:15:37 <carter> thats the only kinda code i'm going to optimize
21:15:39 <carter> thres some neat tricks
21:15:45 <lispy> carter: I assume you've seen's mainland's most recent submission to ICFP?
21:15:45 <cmccann> interesting
21:15:48 <carter> yes
21:15:51 <carter> its not relevant
21:15:53 <carter> :)
21:16:13 <lispy> it's all about SIMD, how is it not relevant?
21:16:17 <carter> lispy the mainland stuff only works on read once stuff
21:16:21 <carter> dot product things etc
21:16:25 <carter> you're only reading each dude ones
21:16:27 <carter> matrix mult
21:16:29 <bos> why doesn't "cabal configure --enable-benchmarks" followed by "cabal build" build a benchmark suite? life is mysterious!
21:16:39 <carter> bos that works for me...
21:17:20 <lispy> carter: ah, interesting
21:17:24 <carter> lispy its much more subtle when you're reading each entry of the nxn array N times :)
21:17:27 <bos> carter: huh
21:17:43 <carter> bos lemm dig up my fugglye cbal file
21:18:00 <wavewave> cmccann: when you toss your new input interface code on github, just let me know.
21:18:46 <cmccann> wavewave: tossing is in progress as we speak
21:18:53 <wavewave> sweet!
21:19:06 <hpaste> carter pasted “cabal file” at http://hpaste.org/87633
21:19:11 <carter> bos i pasted the file
21:19:26 <bos> carter: thx
21:19:33 <robonerd> is it considered poor language design for functions to have multiple return values?
21:19:35 <carter> its also the one where i hit the criterion barfs if i set the sample size to 2 bug :)
21:19:45 <robonerd> i don't mean a list, i mean like named out params
21:20:05 <carter> lispy when i'm optimizing a KxK matrix kernel
21:20:10 <wavewave> robonerd: just make a new datatype for that.
21:20:12 <carter> i'm using the value from each entry k times
21:20:25 <robonerd> didn't answer my question
21:20:31 <wavewave> with record.
21:20:54 <wavewave> robonerd : would you elaborate it?
21:21:01 <lispy> carter: how does that change the instructions you use?
21:21:49 <carter> lispy, well, for one thing, hes using the wrong prefetch instruction for a dot product
21:22:00 <wavewave> cmccann: okay I see your repo now.
21:22:15 <carter> theres a prefetch that says "i won't be looking at this again for a while, forget it from cache after i read from it"
21:22:53 <carter> also, most cpus are good at prefetching when you're sequentially scanning
21:23:13 <johnw> bos: this doesn't mean that life isn't mysterious, though
21:23:14 <carter> the real trick is how you're using the registers
21:23:23 <carter> johnw life IS mysterious
21:23:57 <carter> lispy theres some beautiful tricks you can do with SIMD operations
21:24:02 * lispy has spent all day debugging C++ without source. Everything is mysterious and requires questoning.
21:24:13 <carter> i was actually just reading the AVX manual earlier today...
21:24:27 <carter> FMA + AXV2 + BMI2 = magic party of fast codes time
21:24:32 <cmccann> wavewave: ok I think I did that properly
21:24:44 <lispy> carter: have you benched your stuff against blitz++?
21:24:51 <cmccann> wavewave: you'll need to enable the GTK3 flag in the .cabal file, let me know if you have any problems
21:24:58 <carter> lispy ask me once i've gotten the next iteration working in a few week
21:25:12 <bos> carter: johnw: this is the source of my confusion: https://github.com/haskell/cabal/issues/1323
21:25:31 <wavewave> cmccann: great.. thanks. I am going to experiment with it soon.
21:25:40 <johnw> bos: interesting
21:25:52 <cmccann> wavewave: you may need to get the latest version of gtk from darcs and install the build tools from there
21:25:59 <carter> bos someone else was complaining about the --enable-tests / --enable-benchmarking not always working
21:26:02 <lispy> bos: sounds like typical cabal to me.
21:26:04 <cmccann> if they've changed in any significant ways, dunno
21:26:07 <bos> lispy: heh
21:26:18 <carter> i am getting into my patch happy mode
21:26:19 <wavewave> cmccann: okay.
21:26:33 <bos> lispy: if it's any consolation, i ran into a github bug while trying to report the cabal bug
21:26:35 <carter> bos has probably noticed lots of llvm pull request noise form me recently :)
21:26:40 <carter> *from
21:26:48 <carter> partly to work around a cabal problem
21:26:49 <bos> carter: i haven't been looking, honestly
21:26:51 <carter> ah
21:26:59 <bos> carter: did i add you as a committer?
21:27:04 <carter> nope..
21:27:13 <carter> i've only recently realized llvm is important for what i'm doing
21:27:22 <carter> like 2 weeks ago
21:27:41 <carter> my pull request this week is to make llvm build with both cabal 1.16 and head
21:27:48 <wavewave> cmccann: I see eventPressure and eventTilt in Gdk.EventM. sweet!!!
21:27:50 <cmccann> wavewave: assuming I can use github correctly I just gave you write access to that repo
21:27:53 <carter> theres an api change that breaks the setup.hs
21:28:06 <dmwit> That is a very annoying API change.
21:28:11 <cmccann> feel free to make whatever changes you need and when it all works one of us can deal with making a proper patch
21:28:11 <dmwit> I have had to deal with it, too.
21:28:22 <carter> lispy i'll be benchmarking against atlas
21:28:25 <bos> carter: added. play nice with Ralith and nathanhowell!
21:28:29 <carter> i will
21:28:40 <carter> i'm already pestering them nicely :)
21:28:40 <Ralith> \o/
21:28:43 <lispy> bos: haha. But seriously. I write little 2 line makefiles now and use them as wrappers to invoke cabal with all the necassry flags
21:28:54 <carter> Ralith did you test my patch yet?
21:29:05 <carter> :)
21:29:09 <wavewave> dmwit: oh.. hey. you are here. :-)
21:29:10 <cmccann> lispy: that sounds like a worthwhile use of make
21:29:18 <carter> bos i will use this power for good and not for evil
21:29:44 <carter> to aid and abet haskell being the premier tool for building awesome tech and associated businesses
21:29:50 <carter> i hope
21:29:52 <carter> ish
21:30:05 <carter> or make fast math high level and vroom vroom
21:30:15 <carter> i mean high level math fast
21:30:35 <lispy> carter: when will you start porting the dsl syntax from idris? ;)
21:30:57 <carter> lispy in a few months when i get frustrated with soeone
21:31:00 <carter> *something
21:31:04 <carter> or another
21:31:17 <carter> by then i'll either have customers
21:31:17 <lispy> there are a number of things that I'd love to see make it into haskell from idris
21:31:22 <carter> list em
21:31:26 * hackagebot yesod-text-markdown 0.1.1 - Yesod support for Text.Markdown.  http://hackage.haskell.org/package/yesod-text-markdown-0.1.1 (ArashRouhani)
21:31:34 <lispy> Like how you can overload constructors (that could be a nightmare in a large code base?)
21:31:34 <cmccann> wavewave: here's a bunch of it https://github.com/isomorphism/gtk-inputdevice/blob/master/Graphics/UI/Gtk/Gdk/InputDevice.chs
21:31:50 <carter> thats also in agda
21:31:51 <lispy> And how you can give one function and multiple concrete types for it
21:32:00 <carter> ehhh?
21:32:04 <carter> whats an example of htat?
21:32:14 <carter> i've not played much with idris yet
21:32:17 <carter> i keep on wanting to
21:32:17 <lispy> you can write map for Vec and [a]
21:32:27 <lispy> without needing at type class, IIRC
21:32:27 <carter> without a type class?
21:32:32 <cmccann> wavewave: also there's a Storable instance for DeviceAxis but I think that's gone in gtk3 anyway
21:32:33 <wavewave> dmwit: cmccann has an iput device extension for gtk2hs. code is isomorphism/gtk-inputdevice on github.
21:32:45 <cmccann> he's aware of it :]
21:32:46 <lispy> carter: I think it works because the type resolution is more precise
21:33:09 <lispy> carter: or something. Maybe it's just straight up magic?
21:33:10 <carter> lispy thats some serious engineering to add to ghc yer asking for
21:33:20 <wavewave> cmccann: Okay.. I am getting it.. The code looks neat!
21:33:36 <lispy> well, I don't know if Haskell could support that. It also means you have to work a lot harder to figure out what's going on.
21:33:48 <lispy> (as a programmer) and that's a serious hit against it
21:33:58 <carter> bos -- did you add cartazio or carter?
21:34:03 <Nisstyre-laptop> You know what would be cool? A course on philosophy of science that used Haskell. You could explain falsifiability perfectly using QuickCheck.
21:34:06 <carter> oh
21:34:08 <carter>  nevm
21:34:13 <carter> got the email
21:34:26 <carter> i will use the commit bit for good and not for evil
21:34:39 <carter> who admins the llvm list?
21:34:45 <lispy> carter: I think the multiple type signature thing works precisely in the case where you have multiple overloads for the same constructors, but I'm not certain.
21:34:59 <carter> lispy hrm
21:35:02 <johnw> carter: university of indiana
21:35:11 <carter> i mean the haskell llvm list
21:35:14 <johnw> ah
21:35:29 <cmccann> wavewave: the biggest thing I think is missing from gtk3 is the stuff for getting information about available devices
21:35:48 <cmccann> because that changed significantly (for the better, it looks like)
21:36:31 <carter> http://projects.haskell.org/cgi-bin/mailman/listinfo/haskell-llvm
21:36:38 <lispy> carter: page 13: http://www.cs.st-andrews.ac.uk/~eb/writings/idris-tutorial.pdf
21:36:39 <carter> who's the admin for it?
21:36:47 <johnw> lispy: aren't you?
21:36:57 <wavewave> cmccann: yeah.. that's according to change in Xinput extension 2
21:36:59 <cmccann> wavewave: in particular https://github.com/isomorphism/gtk-inputdevice/blob/master/Graphics/UI/Gtk/Gdk/InputDevice.chs#L174 is a hack to fake the gtk2 api
21:37:20 <lispy> johnw: hmm?
21:37:23 <carter> lispy we do have overloaded lists coming soon to ghc though
21:37:28 <johnw> aren't you guys the admin for that mailing list?
21:37:31 <carter> lispy http://projects.haskell.org/cgi-bin/mailman/listinfo/haskell-llvm
21:37:39 <carter> gimme membership
21:37:44 <carter> oh gate keepers
21:37:50 <apples> what's an overloaded list? like heterogeneous or what?
21:38:00 <Nisstyre-laptop> I don't think so
21:38:08 <lispy> johnw: I'm not the admin for anything.
21:38:14 <carter> http://hackage.haskell.org/trac/ghc/wiki/OverloadedLists
21:38:17 <cmccann> wavewave: anyway, feel free to pester me about it via IRC, github, or email
21:38:17 <apples> thanks
21:38:18 <johnw> lispy: i meant, you guys
21:38:21 <carter> syntax for ordered ish collections
21:38:21 <Nisstyre-laptop> I think it means that [a,b,c] can denote something other than a list
21:38:24 <johnw> you Galois-type people
21:38:27 <carter> Nisstyre-laptop apples  http://hackage.haskell.org/trac/ghc/wiki/OverloadedLists
21:38:36 <carter> ghc 7.8
21:38:38 <lispy> johnw: I thought the haskell-infrastructure list took care of h.o but I could be mistaken
21:38:40 <apples> interesting
21:38:48 <wavewave> cmccann: thanks for this work. this is very valuable to me!
21:38:48 <carter> so you can [1,2] :: Vector Double
21:38:52 <Nisstyre-laptop> carter: it's analogous to OverloadedStrings right?
21:38:57 <carter> EXACTLY
21:39:03 <Nisstyre-laptop> yeah, seems cool
21:39:10 <carter> jah
21:39:10 <apples> indeed :)
21:39:12 <johnw> next we need OverloadedTuples
21:39:15 <cmccann> wavewave: don't thank me yet, not until you see whether I messed up the gtk3 stuff :P
21:39:19 <carter> johnw what would tha tmean?
21:39:25 <lispy> it's still not as powerful as overloading constructors, but it is still very powerful
21:39:25 <carter> or be used for
21:39:29 <johnw> (a,b) because fromPair a b
21:39:32 <carter> ahhh
21:39:34 <cmccann> I've been using the gtk2 version but all I can say is that it compiles with gtk3
21:39:37 <carter> WOAHHH
21:39:38 <johnw> s/because/becomes
21:39:53 <carter> johnw just the dual causal arrow
21:39:56 <lispy> OverloadedBooleans would be nice too
21:39:58 <Nisstyre-laptop> johnw: would Either be an instance of that?
21:39:59 <lispy> fromBool True
21:40:06 <cmccann> -XOverloadedWhitespace cmon lets go go go
21:40:12 <lispy> OverloadedBultins
21:40:19 <Nisstyre-laptop> OverloadedEverything
21:40:20 <johnw> Nisstyre-laptop: if you can define a fromPair that goes to Either
21:40:33 <carter> Ralith could you just test that cabal configure ; cabal build
21:40:39 <carter> works for llvm base in my pull request
21:40:42 <carter> on your machine
21:40:50 <Nisstyre-laptop> johnw: would it make sense to do that?
21:40:51 <cmccann> {-# LANGUAGE OverloadedLanguagePragma #-}
21:40:54 <Nisstyre-laptop> assuming you could
21:41:04 <wavewave> cmccann: ;-)
21:41:15 <johnw> Nisstyre-laptop: I don't know, but with OverloadedTuples it would be up to you!
21:41:18 <carter> {-# LANGUAGE OverloadedLanguagePerl #-}
21:41:29 <johnw> OverloadedOverloads
21:41:33 <carter> parse that
21:41:35 <carter> i dare
21:41:37 <carter>  you
21:41:40 <johnw> until we get to the pragma MaximumOverload
21:41:58 <carter> copumpkin … happy bday in order?
21:42:52 <carter> johnw didyou make a dr who reference in there?
21:43:22 <johnw> ooh, didn't intend to
21:43:54 <Nafai> yay doctor who
21:43:59 <Ralith> carter: sure
21:44:07 <carter> Ralith yay
21:44:19 <carter> then i can push the merge button
21:44:46 <lispy> If I needed help understanding haskell's antiquotation, is there a document for that?
21:45:04 <BMeph> carter: In the New russia, the merge button push... okay, I'll stop now. ;)
21:45:13 <lispy> It seems poorly documented, but I might be missing something
21:45:16 <Ralith> carter: appears to
21:45:18 <cmccann> lispy: well, there's the GHC source... does that count? :P
21:45:21 <carter> lispy you mean the [|  BLA |] stuff?
21:45:35 <carter> and the quasiquoting therein
21:45:40 <carter> and the 'x and ''x stuff?
21:45:42 <aavogt> lispy: http://www.haskell.org/haskellwiki/Template_Haskell ?
21:45:44 <lispy> carter: the [mycoolparser| $lolwhat:(blah) |] stuff actually
21:45:48 <carter> Ralith it looks good?
21:45:55 <cmccann> in general TH-related stuff is not as well documented as one might like :[
21:45:57 <lispy> jsut a sec, brb
21:46:04 <Ralith> carter: idk how it looks, but it configures and builds
21:46:13 <carter> Ralith its fuggly as helll
21:46:36 <carter> but theres no other way without adding more complexity to the build / configure story i think
21:46:45 <Ralith> we'll be able to kill it once 1.16 becomes widespread
21:46:46 <aavogt> cmccann: well there are more than enough examples... maybe repetition from looking at different sources makes it easier, rather than more difficult to learn
21:46:53 <Ralith> and I don't expect to do any heavy refactoring in there before then
21:47:02 <cmccann> aavogt: it's not even that hard to figure out
21:47:12 <carter> Ralith which part can be killed?
21:47:16 <cmccann> but you kinda have to just look at examples then jump in and hope for the best
21:47:17 <carter> i'm using cabal head
21:47:26 <Ralith> cer
21:47:27 <Ralith> er
21:47:29 <Ralith> 1.17
21:47:32 <Ralith> or whatever the next release is
21:47:34 <carter> you mean 1.18
21:47:36 <carter> yeah
21:47:37 <Ralith> okay
21:47:46 <carter> so in like 6 months - year
21:48:01 <Ralith> yep
21:48:16 <carter> or for the 3.3 version that tracks llvm?
21:48:35 <carter> if someone is tracking llvm aggressively, they're ok with tracking cabal aggressively right? :P
21:48:39 <carter> i kid
21:48:49 <Ralith> I think we already build against 3.4svn
21:48:56 <carter> OOOOO
21:48:58 <Ralith> llvm doesn't break compatibility for the C API very much
21:49:05 <carter> but what about that other thing  i hit with 3.3 ealrier?
21:49:13 <carter> when i was pestering you about build errors?
21:49:16 <lispy> back
21:49:20 <carter> welcome
21:49:24 <carter> we held our breath
21:49:50 <carter> lispy the main point from earlier is dot product is a "blas level 2 op"
21:49:51 <lispy> aavogt: one of the things I'm running into might be the specific to the quasiquoter I'm using.
21:49:56 <carter> that does N work on N data
21:50:04 <Ralith> carter: I was unable to reproduce it
21:50:14 <carter> Ralith well, i'll dig into it soon
21:50:26 <carter> i do like over powering my power tools
21:50:30 <lispy> aavogt: my read of the documentation makes me thing antiquotation is supported, but my attempts keep ending in failed parses
21:50:53 <carter> lispy and matrix mult does n^3 work on n^2 data
21:51:05 <cmccann> lispy: I don't think you can splice inside a QQ'er
21:51:05 <aavogt> lispy: you're expecting TH to parse stuff for you?
21:51:11 <carter> wait
21:51:13 <carter> is my math right
21:51:16 <carter> i'm tired
21:51:21 <cmccann> a QQ'er just gets a string and spits out an AST
21:51:26 <carter> lispy cmccann  is right
21:51:34 <carter> would be cool if you coold
21:51:36 <cmccann> you want regular TH quotations if you intend to nest quoting and antiquoting
21:51:37 <carter> but i think no
21:51:58 <carter> thats a problem with teh current TH architecture,, but one you're stuck with :)
21:52:07 <carter> i can't spell at this hour
21:52:13 <carter> Ralith so its safe for me to press merge?
21:52:14 <lispy> http://hackage.haskell.org/packages/archive/language-c-quote/0.7.1/doc/html/Language-C-Quote.html
21:52:18 <aavogt> cmccann: no you can have things like  [| f $( blah ) + xy + $z |] in the quasiquoter
21:52:34 <Ralith> carter: it doesn't obviously break on my system and it won't affect the stable release, so I won't say no
21:52:39 <carter> Ralith ok
21:52:49 <carter> since supporting new cabal and old cabal has value
21:52:53 <carter> i say merge
21:52:56 <carter> button time!
21:53:23 <lispy> I want to work with char2, char3, char4, char8, and char16. I want to do something like map (\n -> [cty|char$(show n)|]) [2,3,4,8,16]
21:54:11 <cmccann> aavogt: in a quasiquoter? are you sure?
21:54:19 <cmccann> your example looks like a plain expression quotation
21:54:26 <carter> aavogt i think cmccann  is right
21:54:35 <aavogt> cmccann: quoteExp :: String -> Q Exp
21:54:39 <carter> yes
21:54:42 <carter> exactly
21:54:50 <lispy> I want to apply cty to char2, char3, ...
21:54:54 <aavogt> while   [| expression |] :: Q Exp
21:55:05 <carter> huh
21:55:23 <cmccann> aavogt: that's not the input to the QQer though
21:55:24 <carter> lispy you want multiple levels of staging
21:55:31 <carter> you want metahaskell
21:55:31 <aavogt> cmccann: yeah, in the definition of it
21:55:36 <cmccann> obv you can use quotations to construct the output of the QQer
21:56:01 <cmccann> at least until TH gets obnoxious and picky and fragile and you resort to manual AST construction in the end
21:56:05 <cmccann> :T
21:56:28 <carter> cmccann i just had to do that to make sure llvm builds on cabal > 1.16 and <= 1.16
21:57:05 <lispy> aavogt: Does my problem make sense?
21:57:31 <lispy> (I also want to this for float2, float3, ..., int2, int3, ... and so on)
21:57:32 <carter> lispy it sounds like you actually want meta haskell
21:57:36 <carter> not template haskell
21:57:50 <carter> lispy might be easier with raw ast
21:57:55 <doomlord> http://pastebin.com/sCsLSNPr <<< my current iteration of vec maths
21:58:10 <mauke> The paste sCsLSNPr has been copied to http://hpaste.org/87634
21:58:37 <cmccann> lispy: I think you might be doing things a bit backwards
21:58:45 <cmccann> the charN identifiers are what you want in the final code, right?
21:59:58 <lispy> doomlord: You might think about what primitives all vectors share and see if you can rewrite your long list of operations in terms of those primitives. If you can, it's equivalent to a C++ class that has a few methods combined with a namespace that is chalk full of operations on that class. Eg., it's a nicer design to maintain and to make new instances for
22:00:08 <lispy> cmccann: yeah
22:00:09 <aavogt> lispy: yes that should be doable
22:01:04 <doomlord> lispy more so than what i've done - i've made 'binary op, unary op', and most of the operations are implemented as defaults in the type class
22:01:05 <cmccann> lispy: you probably want something like $(mkCharNs [2,3,4,8,16]) in the actual code
22:01:12 <cmccann> splices create things that get compiled
22:01:18 <cmccann> quotations are like AST literals
22:01:18 <lispy> My failed attempt at this was to use antiquotation to turn a String into an identifier and then feed that to the cty quasiquoter
22:01:26 <doomlord> ^^^ so each instacnce just needs to implement: Splat, UnaryOp, BinaryOp,SumElems
22:01:32 <aavogt> lispy: you'll basically have to pass the string that's between $( ) to haskell-src-meta to convert to Exp
22:01:52 <cmccann> quasiquoters are for feeding arbitrary strings into a function that spits out AST, if you're sticking to Haskell syntax the QQer is probably not what you want
22:02:08 <cmccann> QQing is quasi because it's not really quoting anything
22:03:20 <lispy> cmccann: if I use that mkCharNs then I'll also want to make mkIntNs, mkShortNs, mkFloatNs, is there a way to generalize that bit too?
22:03:48 <cmccann> lispy: as a rule of thumb with TH you only see splices in client code, quotations are for constructing ASTs in the library that provides the TH magic
22:03:50 <aavogt>  mkBlahNs blah n
22:04:15 <cmccann> lispy: mkCharNs can be whatever you want as long as it produces an expression that does what you want
22:04:30 <hpaste> wavewave pasted “error when compiling gtk with -fgtk3 option” at http://hpaste.org/87635
22:04:45 <cmccann> where by expression I mean an AST describing an expression
22:04:52 <cmccann> which gets turned into actual code during compilation
22:04:59 <aavogt> cmccann: now I see your point
22:05:13 <lispy> Part of the problem, is that othre than using [cty||] I don't really know the right way to construct one of these: http://hackage.haskell.org/packages/archive/language-c-quote/0.7.1/doc/html/Language-C-Syntax.html#t:Type
22:05:26 <lispy> and I'd rather not remiplement the logic for it
22:05:49 <wavewave> cmccann: i had this error when trying to compile gtk with -fgtk without changing gtk2hs-buildtools.
22:06:15 <wavewave> cmccann: now I am going to try to install buildtools from darcs source as you suggested.
22:06:34 <cmccann> wavewave: yeah try that, and make sure to do cabal clean as well
22:06:41 <cmccann> it can be weirdly touchy
22:06:51 * zRecursive like sexp as direct AST :)
22:07:09 <aavogt> lispy: you can call    quoteExp cty "char" in the splice
22:07:37 <cmccann> lispy: a quasiquoter is generally a parser + AST builder
22:08:07 <cmccann> lispy: if the library provides the parser you don't need to do QQing unless you want the syntax being parsed to appear directly in your source
22:08:28 <lispy> \n -> quoteExp cty ("char" ++ show n) and then that goes inside what?
22:08:41 <aavogt> maybe try something like:  mkCharNs ns = listE $ mapM (\n -> quoteExp cty ("char"++ show n)) ns
22:08:58 <aavogt> maybe try something like:  mkCharNs ns = listE $ map (\n -> quoteExp cty ("char"++ show n)) ns
22:09:13 <fruitFly> what's the job market like for Haskell?
22:09:21 <lispy> fruitFly: good?
22:09:30 <lispy> aavogt: thanks. I'll try that
22:09:58 <johnw> fruitFly: that sort of depends
22:10:12 <lispy> aavogt: do I need a runBlah somewhere if I use that? (I assume mkCharNs has a typue like :: [Int] -> M a)
22:10:15 <cmccann> lispy: what context do you want to use it in?
22:10:18 <johnw> if you have good Haskell skills, there are plenty of jobs out there; if you have mediocre Haskell skills, it's not as good as if you have mediocre Java skills
22:10:24 <lispy> cmccann: huint :)
22:10:37 <cmccann> no I mean an expression, declaration, what
22:10:45 <cmccann> you can look at the implementation of cty and grab whatever function(s) you care about
22:10:51 <cmccann> and use them directly
22:10:55 <cmccann> if that makes more sense
22:11:30 <cmccann> wavewave: I vaguely recall getting similar errors at one point before upgrading the build tools
22:11:44 <lispy> what I'm doing is adding test cases to language-c-quote to make sure that the OpenCL support can parse all the special-to-OpenCL types. Then I'll add that support.
22:11:53 <cmccann> I think I installed new versions of everything in the gtk repo
22:12:05 <lispy> So I really just want to force the cty parser to run for all the special types inside an hunit test
22:12:11 <fruitFly> johnw nice to know :)..  are there any popular Haskell projects that demand labour? what are some?
22:12:27 <lispy> cmccann: make more sense?
22:12:33 <aavogt> lispy: I don't think you need runBlahs anywhere. That mkCharNs I wrote should work like (mkCharNs [2,3,4,8,16])
22:12:38 <aavogt> err $(mkCharNs [2,3,4,8,16])
22:12:49 <johnw> fruitFly: you mean, in the open source community?
22:12:54 <cmccann> lispy: so http://hackage.haskell.org/packages/archive/language-c-quote/0.7.1/doc/html/src/Language-C-Quote-OpenCL.html#cty is what you want?
22:13:14 <johnw> fruitFly: Cloud Haskell, any of the FRP frameworks, Yesod or any of the web frameworks, just to name a few
22:13:15 <lispy> cmccann: yes
22:13:26 <fruitFly> johnw and elsewhere... just nice utilitarian projects
22:13:34 <wavewave> cmccann : I see. now I am trying to do that with only gtk2hs-buildtools upgrade first.
22:13:46 <johnw> fruitFly: the aws library could use contributors
22:13:49 <johnw> so could the github library
22:14:05 <lispy> aavogt: okay. I think I understand
22:14:15 <wavewave> cmccann: probably I may need reinstall cairo, pango etc.
22:14:20 * lispy disappears to try some things
22:14:26 <cmccann> lispy: P.parseType is probably all you care about there
22:14:31 <aavogt> maybe you can use runIO, if those sizes are to be read from some outside file
22:14:41 <cmccann> wavewave: that shouldn't be necessary unless the other upgrades break them (which they might)
22:14:56 <carter> fruitFly theres so many great projects going on in haskell land that don't have enough love / man power
22:15:35 <cmccann> aavogt: for bonus fun use the GHC API to read in Haskell programs so you can compile while you compile!
22:15:47 <cmccann> (nb. that didn't work when I tried, it blew up)
22:15:51 <fruitFly> Carter OK nice :)...  any pay
22:15:59 <carter> fruitFly projects? no
22:16:01 <carter> work yes
22:16:17 <carter> fruitFly are you a student ?
22:16:22 <lispy> aavogt: actually, the sizes are fixed in the opencl spec as are the base types so I'm happy to hardcode it.
22:16:44 <fruitFly> OK.. cater what's the Haskell job market like?
22:16:52 <carter> fruitFly are you a student or what?
22:17:06 <fruitFly> independently learning
22:17:07 <carter> your question has different answers depending on the context :)
22:17:23 <lispy> fruitFly: some haskell companies are pretty much always hiring talented folks: http://corp.galois.com/blog/2011/7/20/galois-is-hiring.html
22:17:28 <carter> being a loud active contributor to the haskell community doing cool shit does lead to job offers ;)
22:17:53 <carter> though any visibility on the internet doing cool stuff loudly leads to job offeres
22:18:08 <cmccann> watch edwardk and do things like he does is a good start
22:18:13 <cmccann> not for the faint of heart though
22:18:22 <carter> cmccann exactly, loud and does cool great work
22:18:26 <carter> :)
22:18:45 <lispy> aavogt: which version of listE do I need?
22:18:47 <bos> i'm not sure edwardk is a good model to follow. (a) because you won't be able to, and (b) because you won't be able to.
22:18:48 <lispy> @hoogle listE
22:18:48 <lambdabot> Language.Haskell.TH.Syntax ListE :: [Exp] -> Exp
22:18:48 <lambdabot> Language.Haskell.TH ListE :: [Exp] -> Exp
22:18:48 <lambdabot> Language.Haskell.TH.Lib listE :: [ExpQ] -> ExpQ
22:19:02 <cmccann> bos: pf, implementation details
22:19:07 <lispy> bos: not to mention, because it's an impossible lead to follow
22:19:09 <carter> fruitFly point being: the optimal job strategy is actively visibly involve your self in a in community you are excited about, and do great work
22:19:17 <aavogt> there's only one listE. Or you could use ListE . mapM
22:19:23 <bos> maybe a slightly less clever edwardk who writes documentation.
22:19:35 <carter> bos lispy cmccann  he does set the standard for neat libs
22:19:37 <aavogt> err   fmap ListE . mapM
22:19:43 <elliott> edwardk writes documentation sometimes these days!
22:19:45 <carter> that take forever to understand
22:19:45 <elliott> I'm worried about him.
22:19:47 <carter> elliott true!
22:19:48 <lispy> aavogt: oops. You're right. I thought those were all lowercase ls
22:19:49 <aavogt> anyways, the lowercase versions are much nicer
22:19:59 <carter> elliott you mean how he sleeps lke a normal person now sometimes?
22:19:59 <cmccann> @remember bos i'm not sure edwardk is a good model to follow. (a) because you won't be able to, and (b) because you won't be able to.
22:20:00 <lambdabot> It is forever etched in my memory.
22:20:09 <carter> YES
22:20:19 <carter> + the clone army
22:20:29 <cmccann> @quote elliott documentation
22:20:30 <lambdabot> elliott says: <edwardk> elliott: now its almost exactly like one of my packages ;)  <elliott> edwardk: no, i'm writing documentation
22:20:44 <cmccann> how times have changed
22:20:46 <doomlord> http://pastebin.com/TsurgBcy << seem to have got rid of the annoying constructor..
22:20:47 <johnw> if you try to follow edwardk, he moves so fast that soon you'll find him behind you
22:20:59 <mauke> The paste TsurgBcy has been copied to http://hpaste.org/87638
22:21:24 <fruitFly> who is edwardk lol.. I'll look him up
22:21:32 <carter> he has been nerd sniped lately by analytics design https://github.com/ekmett/
22:21:56 <carter> fruitFly he's written  a huge fraction of nice libs that have strongly influenced modern haskell
22:21:59 <johnw> i love how that picture of him makes it seem like he has a coding entourage
22:22:29 <carter> anyone else really excited about intel haswell?
22:22:31 <cmccann> plus he looks vaguely malevolent, lit by the monitor that way
22:22:42 <cmccann> some sort of evil mastermind thing going on there
22:22:48 <johnw> carter: I'm rather excited, although I hear that hardware transactions may not speed up Haskell's STM as much as I'd hoped
22:22:51 <carter> cmccann will you be at hackphi?
22:23:05 <cmccann> carter: if I ever remember to make my reservations yeah
22:23:34 <carter> johnw i don't care abou that :) , the parallel bit extract / deposit are HUGE for me
22:23:39 <carter> cmccann tell byorgey
22:23:41 <fruitFly> will haswell release have some 11.6 inch notebooks?
22:23:51 <johnw> carter: and the 256-bit SIMD?
22:24:00 <carter> johnw yeah
22:24:03 <carter> the widder paths are nice
22:24:14 <carter> but i have some fancy matrix layouts i want to use by default going forward
22:24:20 <dmwit> cmccann: Do it now! You're not doing anything useful being on IRC anyway. ;-)
22:24:32 <lispy> aavogt: It's pretty close now, but Ineed a way to convert from ExpQ to [Assertion]
22:24:36 <carter> and the bit manipulation stuff will make those fancy layout calculuations MUCH faster
22:24:45 <carter> like the same complexity as row / col major
22:24:50 <carter> 2-5 instructions
22:24:55 <aavogt> lispy: $( ) probably
22:24:58 <carter> rather than 20+
22:25:08 <carter> which i have to amortize with large blocks
22:25:29 <cmccann> dmwit: yeah but I'm a cheapskate and spending money is inordinately difficult for me :T
22:25:48 <lispy> aavogt: to make it easier to talk about: http://hpaste.org/87639
22:25:50 <cmccann> lispy: splices convert an ExpQ into whatever expression it describes
22:25:52 <carter> johnw so yes, the double lanes will be SEXY
22:26:13 <carter> but the easier bit fiddling for fancy memory layouts will bring me cache obvlivious joy
22:26:18 <carter> such joy
22:26:37 <dmwit> cmccann: 1. Plan trip to Europe. 2. Look how cheap it is to go to Philadelphia instead!
22:26:38 <Ralith> carter: prof of mine is doing some sweet SIMD parsing stuff that the new instructions will benefit
22:26:48 <carter> simd parsing?
22:26:51 <carter> explain pray tell
22:27:07 <cmccann> lispy: yeah $( ) will splice it in, but I don't think it will work like that
22:27:13 <cmccann> because of the stage restriction bs
22:27:23 <carter> btw: would anyone like to be intro'd for a vp of eng of profititable data api company thats opening an office in nyc?
22:27:30 <carter> they kinda want me… but i'm kinda busy
22:27:31 <aavogt> @hoogle (@=?)
22:27:31 <lambdabot> Test.HUnit.Base (
22:27:36 <carter> though the code is currenly ruby mostly
22:27:42 <cmccann> TH code's usually gotta be in a separate file
22:27:51 <carter> but they're not hung up on sticking with ruby
22:27:57 <lispy> aavogt: that refl this is just a hack I have in at the moment to force it to be an hunit thingy. Don't worry to much about it. I'll probably change it later.
22:28:32 <lispy> aavogt: if I replaced the splice with a list of ints this type checks
22:28:34 <aavogt> or put it in a $(let ... in mkCharNs [2,5] )
22:28:36 <carter> acfoltzer pdep and pext will make me happy
22:28:54 <Ralith> carter: lemme dig up the paper...
22:29:01 <carter> Ralith thankee
22:29:03 <lightquake> so one thing I've noticed a lot of interfaces will do in stuff like Javascript is they'll have listeners
22:29:08 <aavogt> since that will avoid that stage restriction
22:29:16 <lightquake> where objects fire off change/insert/whatever events and listeners register callbacks
22:29:40 <Ralith> carter: http://parabix.costar.sfu.ca/export/901/docs/EuroPar2011/europar-cameron.pdf
22:29:55 <hpaste> wavewave annotated “error when compiling gtk with -fgtk3 option” with “error when compiling gtk with -fgtk3 option (annotation)” at http://hpaste.org/87635#a87640
22:30:20 <cmccann> wavewave: well that looks like my mistake
22:30:21 <carter> fruitFly idk if there theres going to be netbook/ small machines with haswell
22:30:25 <wavewave> cmccann: second round. now InputDevice.chs has an error with -fgtk3
22:30:26 <carter> but i might spring for one if there is
22:30:39 <cmccann> wavewave: probably something I changed since last time I tested the gtk3 compile
22:30:41 <lightquake> you can't really do that in haskell, so what's the analogous thing?
22:30:52 <lispy> aavogt: http://hpaste.org/87639
22:30:55 <cmccann> wavewave: you'll need to fix that with more #ifdef junk
22:31:10 <lispy> aavogt: I'm not hiting a stagging restriction, I'm getting a type error. That's why I thought I might need to 'run' something
22:31:23 <cmccann> wavewave: it needs to be hidden when gtk3 is used because GdkDeviceAxis was removed
22:31:43 <carter> fruitFly yup, there'll be laptop one http://en.wikipedia.org/wiki/Haswell_(microarchitecture)
22:31:49 <cmccann> lispy: are you splicing it?
22:31:52 <wavewave> cmccann: i got it. I will try to fix it.
22:32:12 <lispy> cmccann: http://hpaste.org/87639
22:32:42 <carter> lispy whats the opencl hacking for (though i appreciate / value it)
22:33:04 <wavewave> cmccann : okay made it passed.
22:33:08 <lispy> carter: hobby. an experiment to see if I can make my ray-tracer real-time
22:33:15 <carter> lispy neat!
22:33:22 <carter> wheres that repo again?
22:33:33 <lispy> carter: https://github.com/dagit/haray
22:33:36 <cmccann> lispy: dumb question, do you actually have TH enabled
22:33:38 <carter> i really want to get around to playing with graphics some time
22:33:51 <carter> cmccann isn't quasi quoting seperate flag too?
22:34:03 <cmccann> lispy: because that looks like it's not parsing the splice syntax correctly
22:34:16 <lispy> cmccann: Not a dumb question at all. I have QuasiQuotes turned on. Do I need TH as well?
22:34:16 <aavogt> In the second argument of `($)', namely `(mkCharNs [2])'
22:34:22 <cmccann> yes, they're separate
22:34:24 <cmccann> I think
22:34:26 <lispy> thanks
22:34:30 <cmccann> you're not using QQs anyway
22:35:00 * lispy is an idiot :)
22:35:09 * dmwit too
22:35:10 <lispy> Well, the rest of the file does use QQs
22:35:37 <cmccann> lispy: like I said TH is a bit lacking in nice approachable intro material
22:35:43 <cmccann> ok, fair enough
22:35:52 <wavewave> cmccann: I created gtk3 branch and pushed the change now.
22:35:52 <lispy> now I'm hitting the stagging restriction :(
22:36:01 <cmccann> toldja!
22:36:07 <carter> lispy write your asts by hand
22:36:09 <cmccann> wavewave: :D!
22:36:10 <carter> which staging?
22:36:10 <lispy> I added a let around it but that didn't help
22:36:31 <wavewave> cmccann: now trying to build hoodle against it ;-D
22:36:32 <carter> i should crash some time
22:36:34 <carter> night all
22:36:40 <carter> cmccann COME TO THE HACKPHI
22:36:48 <carter> i'm even more annoying and distractable in person
22:36:50 <cmccann> lispy: inline all the TH into the splice and see if that works?
22:36:50 <carter> ish
22:36:54 <cmccann> carter: hahaha
22:37:05 <carter> cmccann ask anyone who was there last year
22:37:10 <carter> i got NO code done
22:37:14 <hpaste> aavogt annotated “a” with “a (annotation)” at http://hpaste.org/87639#a87642
22:37:47 <lispy> carter: this is the error if you really want to see it: http://hpaste.org/87639
22:37:49 <wavewave> cmccann: hmm. Gtk-ERROR **: Gtk+ 2.x symbols detected. Using GTK+ 2.x and GTK+ 3 in the same process is not supported .
22:38:07 <wavewave> as usual
22:38:26 <carter> lispy put the where in the splice
22:38:27 <lispy> aavogt: thanks
22:38:28 <carter> :)
22:38:43 <carter> oh
22:38:57 <aavogt> where doesn't go in expressions very easily
22:39:11 <carter> aavogt you made the last edit?
22:39:14 <aavogt> yes
22:39:16 <Nisstyre-laptop> aavogt: I sometimes have trouble mixing where and let
22:39:29 <carter> aavogt yeah, i hit the where in expression problem recently at some point
22:39:37 <aavogt> > let x = y where y = 1 in x
22:39:39 <lambdabot>   1
22:39:42 <cmccann> wavewave: I'm not sure what that would be about :[
22:39:52 <cmccann> like I said haven't really tried to use the gtk3 code myself
22:40:15 <Nisstyre-laptop> aavogt: yeah, I just can't tell which way to line them up sometimes when I'm putting stuff on more than one line
22:40:27 <lispy> sweet!
22:40:28 <lispy> it works
22:40:31 <lispy> thanks everyone
22:41:03 <wavewave> cmccann : somewhere in my code, I guess I use gtk2 only code...
22:41:08 <carter> night all
22:41:45 <cmccann> wavewave: maybe dmwit could help? I dunno.
22:41:59 <dmwit> bwuh?
22:42:20 <cmccann> dmwit: you should figure out why wavewave's gtk code isn't working
22:42:25 <dmwit> =(
22:42:38 <cmccann> since you are clearly responsible for all issues involving gtk forever and an expert on all such matters. clearly.
22:42:57 <dmwit> Oh, is gtk3hs not working properly?
22:42:58 <wavewave> cmccann: anyway worth to get rid of all gtk2-specific codes for the future. hope it's not very difficult.
22:43:02 <dmwit> I guess that doesns't surprise me too much.
22:43:30 <wavewave> dmwit: yeah. me, too.
22:43:34 <dmwit> If there's something gtk3hs is doing Wrong, we should figure it out.
22:43:38 <cmccann> is there a separate gtk3hs? or do you just mean enabling the gtk3 flag.
22:43:49 <dmwit> Do you have a smallish example that demonstrates the problem?
22:43:54 <dmwit> cmccann: I just mean the gtk3 flag, yeha.
22:43:59 <dmwit> Yeeehaw!
22:44:04 <Eduard_Munteanu> Heh.
22:44:06 <dmwit> I really meant yeah, but it came out AWESOME instead.
22:44:17 <Eduard_Munteanu> It sure did, son.
22:44:25 <wavewave> cmccann, dmwit: I was about to ask about that. how about having gtk3 as a separate package?
22:44:52 <aavogt> next people will think c2hs is for that language c2
22:44:53 <dmwit> Yeah, I'm not sure.
22:45:20 <dmwit> On the one hand, I imagine there will be a *lot* of duplicated code. On the other hand, not having to support gtk back to 1985 would be nice.
22:45:20 <cmccann> c 2: electric boogaloo
22:45:31 <arkeet> gtk2 is that old?
22:45:36 <dmwit> no =)
22:45:46 <dmwit> I admit it: sometimes I exaggerate for comedic effect.
22:45:51 <arkeet> :P
22:45:57 <cmccann> dmwit: you mean you ALWAYS exaggerate.
22:46:05 <cmccann> </meta>
22:46:05 <elliott> gtk was invented in 1328 by shakespeare
22:46:06 <arkeet> gtk+ 2.0 in 2002, apparently.
22:46:06 <dmwit> LITERALLY every single time.
22:46:13 <wavewave> clearly if it has so many #if statement, that's a good sign to separate them at all.
22:46:20 <elliott> and then grew to five billion lines of code.
22:46:31 <arkeet> only five billion?
22:46:44 <cmccann> yeah some way to contain the #ifdef crud better would be nice, if nothing else. it's so ugly :[
22:48:06 * dmwit sighs
22:49:01 <dmwit> I wish there was a way to get things done that didn't involve work.
22:49:16 <Eduard_Munteanu> So do I...
22:49:17 <Eduard_Munteanu> :)
22:49:28 <wavewave> i prefer to have gtk3 as a separate package since debian packages are usually just named as libghc-xxx-dev  with xxx as simple hackage package name.
22:49:56 <dmwit> Yeah. Making the interface dependent on a cabal flag has been making me uneasy for a while, and it's just getting worse and worse.
22:50:14 <dmwit> I guess making a real gtk3 package really is the only sane way.
22:50:22 <cmccann> dmwit: look on the bright side, at least you're not stuck being responsible for some massive deprecated old abandoned edwardk package or anything, that would just be awful
22:50:35 <dmwit> Hah!
22:50:42 <dmwit> I do tend to stick my nose in it, don't I? =P
22:51:05 <Eduard_Munteanu> gtk2hs has a few problems anyway, like not being able to read any non-ancient Glade files.
22:51:21 <cmccann> Eduard_Munteanu: and being gtk, but I guess that's harder to fix :P
22:51:40 <cmccann> (not that the alternatives are better, gui libs all suck)
22:51:41 <dmwit> Eduard_Munteanu: patches welcome ;-)
22:52:06 <Eduard_Munteanu> cmccann: eh, in my short experience with it, I was positively surprised. I expected C-ish stuff, but things turned out better.
22:52:34 <cmccann> dmwit: if it helps motivate you, I don't think the extended input stuff can have a sane and useful API that's consistent between gtk2 and gtk3
22:52:56 <dmwit> I wonder whether I can convince CPP to do my work for me.
22:53:04 <cmccann> Eduard_Munteanu: it's no worse than anything else I've used, and better than some.
22:53:22 <cmccann> as far as gui libraries go gtk is tolerable enough.
22:53:41 <Eduard_Munteanu> cmccann: not sure there is much else, in Haskell :). Well, there's wxHaskell but not quite complete either.
22:54:28 <aavogt> Eduard_Munteanu: there's an even less finished QT binding somewhere too
22:54:52 <cmccann> dmwit: and since wavewave and I intend to use the extended input device support from gtk3 and gtk2 respectively it'd be nice if they could coexist without horrible dependency issues
22:55:27 <cmccann> is it even possible to install two copies of the same package/version with different flags set?
22:55:29 <wavewave> yeah. gtk2hs is in fact awesome. I am in fact very pleased with it. it manages to have consistency with power.
22:55:32 <bos> hey folks, i have an experiment in mind: https://github.com/bos/critbit
22:55:39 <dmwit> cmccann: don't think so
22:56:12 <cmccann> dmwit: bet lotsa stuff is gonna break if you keep them in one package then
22:56:29 <cmccann> the APIs are not compatible, so unless you want to EOL the gtk2 support...
22:56:32 <simpson> bos++
22:56:34 <dmwit> I am already convinced. You needn't cook up any more arguments.
22:56:39 <cmccann> haha, ok.
22:56:44 <dmwit> It is now merely a matter of dmwit cycles.
22:56:54 <cmccann> consider it an effort to help you not regret that decision then
22:57:07 <dmwit> =)
22:58:19 <Nisstyre-laptop> is there a function like replicate, except Int -> [a] -> [a], i.e. f n = join . replicate n
22:58:32 <Nisstyre-laptop> or do I just have to define that myself?
22:58:54 <Nisstyre-laptop> or is there some arcane combination of operators that will give rise to it?
22:59:11 <dmwit> The combination of operators you wrote looks pretty cromulent to me.
22:59:19 <Nisstyre-laptop> true
22:59:32 <dmwit> Hoping to go much less than four tokens seems a bit greedy.
23:01:24 <dmwit> bos: Tweet this at John Carmack...
23:01:29 * hackagebot critbit 0.0.0.0 - Crit-bit maps and sets  http://hackage.haskell.org/package/critbit-0.0.0.0 (BryanOSullivan)
23:01:30 <dmwit> eh
23:01:41 <dmwit> Actually, I guess he sort of already has chosen his project.
23:01:43 <dmwit> So never mind.
23:05:52 <bos> please to be upvoting on teh redditses, if you like the idea: http://bit.ly/17Q3l7I and http://bit.ly/196zYgk
23:06:23 <Eduard_Munteanu> I should get a Reddit account sometime.
23:07:08 <capisce> sneaky little redditses
23:07:51 <kosmikus> bos: done
23:08:25 <tero-> I'm writing a code generator that outputs several files or a list of errors. Would State-monad be a good fit for this?
23:09:00 <elliott> the Either monad sounds better.
23:09:01 <Eduard_Munteanu> tero-: well, what state would you have?
23:10:16 <tero-> Eduard_Munteanu: the DSL that is the input has some local scoped variables
23:10:39 <tero-> and I want to touch the output files only if the result is different to avoid recompiling the same stuff
23:11:29 * hackagebot list-tries 0.5.1 - Tries and Patricia tries: finite sets and maps for list keys  http://hackage.haskell.org/package/list-tries-0.5.1 (MattiNiemenmaa)
23:11:57 <tero-> Eduard_Munteanu: and I thought of the list of errors as state but now it does not seem like a good idea anymore..
23:12:17 * dmwit has an idea for a mythical-beast themed YATI library
23:12:24 <dmwit> Yet Another Trie Implementation
23:12:25 <Eduard_Munteanu> If you just want to log errors, perhaps Writer is better.
23:12:34 <dmwit> ...but this time, with MONOIDS
23:12:36 <dmwit> ?yow!
23:12:36 <lambdabot> Couldn't find fortune file
23:12:38 <dmwit> aww
23:14:08 <tero-> in the scope where local variables (=SQL table join aliases) are used, the order matters
23:14:51 <dmwit> I'm not sure how State is going to help your recompilation checking.
23:17:10 <tero-> the output has to be kept in memory somehow before writing it to disk. I agree that State is probably not the best fit
23:20:52 <dmwit> I wondered briefly why my browser was turning '?' into '´' before discovering that it was merely making alert boxes a tiny bit too small and cutting off most of the '?'s.
23:21:08 <applicative> tero-: you mean, you just want to compare the old file and the new file before overwriting?
23:21:14 <tero-> applicative: yep
23:22:14 <tero-> the errors and the output could well be accumulated in a Writer monad, but this still leaves open how to handle scoped local variables where the order matters
23:22:41 <dmwit> Scoped local variables are typically handled with Reader and the "local" action.
23:23:04 <Eduard_Munteanu> He means variables in his DSL.
23:23:11 <lispy> aavogt, cmccann: thanks for your help here is the pull request that came of it: https://github.com/mainland/language-c-quote/pull/19
23:23:23 <dmwit> I'm pretty sure I do, too?
23:23:34 <Eduard_Munteanu> Oh, alright.
23:23:34 <cmccann> lispy: hooray!
23:23:44 <tero-> dmwit: ah, interesting
23:23:53 <tero-> so is the solution to combine Reader and Writer?
23:24:03 * lispy heads to bed
23:24:05 <dmwit> Sure.
23:26:10 <tero-> thanks. I'll try it
23:27:00 <applicative> @unmtl ReaderT loc (WriterT doc IO) r
23:27:01 <lambdabot> loc -> IO (r, doc)
23:28:20 <applicative>  @unmtl ReaderT loc (ErrorT err (WriterT doc IO)) r
23:28:35 <applicative> @unmtl ReaderT loc (ErrorT err (WriterT doc IO)) r
23:28:36 <lambdabot> loc -> IO (Either err r, doc)
23:28:44 <tero-> nice
23:58:32 <hpaste> “Dharmender Kumar” pasted “Pilates Course in Mumbai” at http://hpaste.org/87646
