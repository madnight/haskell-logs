00:01:34 <Ghoul_> bopt d = (>0) <$> opt (d :: Int) -- no instance for (Ord(IO Int)) ?
00:05:18 <johnw> aren't you missing an argument?
00:05:24 <johnw> I thought "opt" took two
00:06:00 <Ghoul_> It does, but its a partial application
00:06:35 <johnw> then that function definition will not work
00:06:39 <johnw> you need this:
00:06:51 <johnw> bopt d = fmap (>0) . opt d
00:07:03 <shachaf> Hooray for eta-expansion!
00:07:07 <johnw> or, even more pointless: bopt = (fmap (>0) .) . opt
00:07:12 <shachaf> :-(
00:07:17 <johnw> just for you, shachaf!
00:07:20 <johnw> :)
00:07:28 <johnw> I did say "pointless", to be fair
00:07:52 <shachaf> Yes. If someone asked how to convert so-and-so to such-and-such, you might say "even more efficient: unsafeCoerce"
00:08:02 <johnw> lol
00:08:07 <Ghoul_> I am too dumb for this.
00:08:11 <cmccann> unsafeCoerce is very efficient, that is true.
00:08:14 <johnw> Ghoul_: bopt d = fmap (>0) . opt d
00:08:17 <johnw> that is the one you want
00:08:21 <johnw> or, do this:
00:08:27 <Ghoul_> Yeah, it worked perfectly thanks
00:08:28 <johnw> bopt d x = (>0) <$> opt d x
00:08:40 <shachaf> Perhaps that one is even better.
00:08:42 <Ghoul_> its just always nothing like I would have expected the solution to look like :P
00:08:46 <arkeet> bopt = fmap fmap fmap (>0) opt
00:08:48 <johnw> adding points can sometimes make your code easier to read
00:09:20 <Ghoul_> d has to be restrained to Int
00:09:26 <Ghoul_> so that won't work arkeet :P
00:09:33 <johnw> then above that line, add:
00:09:42 <fruitFly> johnw: it says "to download x code I need 10.6.6" .. so should I just upgrade then?
00:09:50 <johnw> bopt :: Int -> <whatever the type of x is> -> <whatever the return type should be>
00:10:16 <johnw> fruitFly: I guess so.  Without Xcode, you can't do much development-wise on that machine
00:11:07 <fruitFly> does xcode provide dev tools... cause I just want to use a text editor for dev right now
00:12:03 <johnw> it provides everything for doing C/C++/Objective-C development
00:12:20 <shachaf> C/C++/Objective-C is my favorite language.
00:12:28 <johnw> oh, and Objective-C++
00:12:30 <johnw> can't forget that one
00:26:16 <bitonic> I like Java/JavaScript
00:38:09 <pxqr`> thats interesting that ghc show concrete inferred polykinds as arguments of ty constructors. at least 7.4.1 does. i never notice that before ._.
00:38:40 <pxqr`> for example: Foo * a b C
00:38:53 <pxqr`> where C : *
00:39:25 <shachaf> λ> data Foo k a ; λ> :i Foo
00:39:53 <pxqr`> data Foo m a b = Foo (a -> m b)
00:58:46 <johnw> :t Kleisli
00:58:52 <lambdabot> (a -> m b) -> Kleisli m a b
01:04:28 <no-n> :t no-n
01:04:33 <lambdabot>     Not in scope: `no'
01:04:33 <lambdabot>     Perhaps you meant one of these:
01:04:33 <lambdabot>       `not' (imported from Data.Bool),
01:31:19 <fruitFly> are gaurds interchangable with case expressions? is one more ideal than the other
01:31:20 <fruitFly> ?
01:32:22 <johnw> guards can be used with case expressions
01:32:26 <johnw> they suit different needs
01:32:39 <johnw> case expressions do a pattern match, guards evaluate a prediction expression
01:32:48 <johnw> there are even guard patterns
01:32:55 <arkeet> you mean pattern guards?
01:33:00 <johnw> i mean pattern guards
01:33:28 <fruitFly> oooh ok.. didn't know that distinction.. thanks. I remember lyah haskell saying case expressions was syntactic sugar for gaurds.. mayb I'm remembering wrong
01:33:31 <fruitFly> johnw: Thanks
01:33:32 <johnw> case mfoo of Just x | True <- x > 10 -> print "mfoo was a Maybe Int that's greater than 10"
01:33:33 <fruitFly> :)
01:33:44 <johnw> (note that that pattern guard is totally unnecessary)
01:33:48 <arkeet> that's a pretty silly example
01:34:24 <johnw> fruitFly: in the end, everything is sugar for let, case and function application
01:35:46 <johnw> which is another way of saying that Haskell is based on the typed lambda calculus
01:36:06 <adimit> System F :-)
01:36:09 <adimit> (actually, FC)
01:48:45 <notdan_> @hoogle (Monoid m, MonadState ms m) => m -> ms m ()
01:48:46 <lambdabot> Control.Applicative Const :: a -> Const a b
01:48:46 <lambdabot> Data.Functor.Constant Constant :: a -> Constant a b
01:48:46 <lambdabot> Prelude Left :: a -> Either a b
01:48:58 <notdan_> Hm, is there anything like `tell` but for State?
01:49:43 <supki> @ty (<>=)
01:49:47 <lambdabot> (Monoid a, MonadState s m) => ASetter' s a -> a -> m ()
01:49:52 <supki> @ty (id <>=)
01:49:56 <lambdabot> (Monoid s, MonadState s m) => s -> m ()
01:50:02 <notdan> thanks
01:50:23 <shachaf> tell x -- modify . (<> x)
01:50:49 <shachaf> Er.
01:50:55 <shachaf> No .
01:51:06 <notdan> shachaf: yeah, just thought there might be a function in standard library
01:56:27 <johnw> just modify (<> x), isn't it?
01:57:11 <johnw> :t modify (<> x)
01:57:13 <lambdabot> MonadState Expr m => m ()
02:02:37 * hackagebot accelerate 0.13.0.0 - An embedded language for accelerated array processing  http://hackage.haskell.org/package/accelerate-0.13.0.0 (TrevorMcDonell)
02:02:39 * hackagebot accelerate-cuda 0.13.0.0 - Accelerate backend for NVIDIA GPUs  http://hackage.haskell.org/package/accelerate-cuda-0.13.0.0 (TrevorMcDonell)
02:02:41 * hackagebot accelerate-examples 0.13.0.0 - Examples using the Accelerate library  http://hackage.haskell.org/package/accelerate-examples-0.13.0.0 (TrevorMcDonell)
02:02:43 * hackagebot accelerate-io 0.13.0.0 - Read and write Accelerate arrays in various formats  http://hackage.haskell.org/package/accelerate-io-0.13.0.0 (TrevorMcDonell)
02:02:45 * hackagebot accelerate-fft 0.13.0.0 - FFT using the Accelerate library  http://hackage.haskell.org/package/accelerate-fft-0.13.0.0 (TrevorMcDonell)
02:09:22 <savask> Hello. I have been messing with my HaskellNN project for a while, and found one weird bug: it doesn't work under linux i686, throwing "Illegal instruction" error. I have tried to trace it in gdb and it said that "fromRows applied to [] or to vectors with different sizes" What can be the problem? It works under 64bit linux.
02:20:08 <fruitFly> what is the advantage of using [Word8] over int for binary?
02:23:55 <savask> fruitFly: I think [Word8] can be turned to ByteString or vice versa, and ByteStrings are faster for some things.
02:25:02 <donri> fruitFly: correctness
02:28:12 <SrPx> Is every function written in Haskell automatically adjusted by the compiler as to be tail-call optimized?
02:29:40 <fruitFly> savask: donri what operators work with word8? I want to conver hex to binary and am going to do it character by character.... so how do I convert 'a' to word8? ... 1+0+1+0?
02:31:14 <plhk> > (fromIntegral $ fromEnum 'a') :: Word8
02:31:20 <lambdabot>   mueval: ExitFailure 1
02:31:20 <lambdabot>  mueval: Prelude.undefined
02:31:35 <plhk> ):
02:31:37 <savask> fruitFly: Do you want to turn letters to 0 and 1 binary? Like 01010001...
02:31:59 <fruitFly> savask: yes... hex... so only 0-f
02:32:07 <savask> Oh
02:32:20 <savask> fruitFly: Isn't it better to use [Bool] or something?
02:32:25 <donri> fruitFly: might want to use a bytestring builder for that
02:32:29 <fruitFly> savask: not sure how to build it though... and I only have ideone.com and tryhaskell.org to work with
02:33:16 <fruitFly> savask: a list of bools lol?... could work... but my guess is that it isn't as efficient as bytestingbuilder, right donri ?
02:33:41 <donri> probably no
02:34:23 <donri> fruitFly: are you sure you mean bits though not bytes?
02:34:33 <fruitFly> donri: ok .... but what's wrong with word8 and it's advantages? ... what's correct? the most efficient? I'm a noob and have had soo many diff recommendations
02:34:37 <donri> bytes are bits of course but not all bits are bytes
02:35:35 <donri> what is your input and what output do you want
02:36:29 <fruitFly> donri: savask Input is a hexadecimal string eg. 14656ac24672... out put is binary equivalent... eg. 01010100101100
02:37:14 <donri> fruitFly: there's probably a library for that. is this for fun and learning?
02:37:22 <mniip> can't you just replace each hex digit with it's 4-bit sequence
02:37:58 <fruitFly> donri: for learning... I'm implimenting this from scratch for a series of cryptography challenges
02:38:00 <donri> fruitFly: what do you mean by binary equivalent though? literally the string "010100..."? or the bits? or the bytes?
02:38:36 <fruitFly> mniip: yes ... but what is the most efficient output type... and if it's [word8] how do I build the binary string?
02:39:23 <fruitFly> donri: I mean the conversion... so... 21-> 00100001
02:40:05 <mniip> fruitFly, you mean "21" -> "00100001", right?
02:40:29 <savask> concat . catMaybes . map (\x -> lookup x $ zip "0123456789abcdef" (map (concat . map show) . sequence $ replicate 4 [0, 1])) $ "21"
02:40:36 <donri> also i wouldn't worry about making it efficient, at least not now
02:40:38 <savask> That's the thing I got.
02:41:01 <fruitFly> mniip: yes ... but should the binary be in quotes? I'm not sure what type it should be... what's efficient?
02:41:12 <savask> > concat . catMaybes . map (\x -> lookup x $ zip "0123456789abcdef" (map (concat . map show) . sequence $ replicate 4 [0, 1])) $ "21"
02:41:17 <mniip> fruitFly, by quotes i mean that it's a string
02:41:17 <lambdabot>   "00100001"
02:41:21 <savask> Yay
02:41:39 <savask> fruitFly: Try my code
02:43:06 <leggo> hello. I am trying to split a string by <letter>:\, so "fooc:\\tmp" would be split into ("foo", "c:\tmp"). could Data.List.Split be used for this?
02:43:15 <fruitFly> mniip: With my noob brain I was thinking of making it a string... but I was told I should make it Word8 ... then was proposed a list of bools... I'm not sure what's best. At this point I'm going to go with a string
02:43:43 <fruitFly> savask: thanks
02:43:57 <fruitFly> savask: I'm gonna create my own implementation though
02:43:59 <savask> fruitFly: Not a problem. Btw, what are you going to do with that? Just output or something else?
02:44:14 <leggo> here is my attempt at doing it manually. was wondering if it could be made a bit cleaner.  http://hpaste.org/87729
02:44:27 <fruitFly> savask: I'm doing it for learning.. it will then be converted to base64
02:44:40 <savask> Oh
02:50:13 <leggo> what it is doing basically is, parse "fooc:\\tmp" => ("foo","c:\\tmp")
02:58:48 <klrr> i've written something like "main = putStr "> " >> getLine >>= putStrLn >> main", but when i run it i get the "> " after getline not before, i want it so it looks like a prompt
02:58:51 <klrr> any ideas?
03:00:39 <Javran> klrr: take a look at http://www.haskell.org/haskellwiki/Seq
03:00:53 <savask> klrr: Maybe you should try to do hFlush after ">"
03:01:05 <savask> klrr: It's located in System.IO
03:02:34 <klrr> savask: what' does hFlush?
03:03:03 <savask> klrr: Outputs things in the buffer, I guess.
03:03:07 <byorgey> you should call  hFlush stdout  in particular
03:03:11 <savask> Yeah
03:03:14 <klrr> i know
03:03:23 <klrr> but what does hFlush, what does "flush" mena?
03:03:25 <klrr> mean*
03:03:28 <byorgey> it makes sure that any output which is buffered is output immediately before continuing
03:03:36 <byorgey> oh, hehe
03:04:00 <klrr> so it makes the putStr happen before getLine?
03:04:08 <byorgey> klrr: "flush" means to empty something
03:04:12 <byorgey> it is what you do to a toilet
03:04:27 <byorgey> but it can be used in other contexts too
03:04:31 <savask> klrr: When you do putStr it actually puts the string in the special place, called buffer
03:04:54 <savask> klrr: hFlush throws buffer contents to the screen -_-
03:05:06 <kennyd> klrr stdout is usually line buffered by default, so nothing would be printed until the newline or until hFlush was called manually
03:05:39 <klrr> okey, now i get an error though
03:05:47 <klrr> oct: <stdin>: hFlush: illegal operation (handle is not open for writing)
03:05:49 <klrr> runtime error
03:05:59 <savask> stdout
03:06:23 <klrr> wtf im stupid xD
03:06:42 <donri> probably not
03:06:53 <donri> perhaps overwhelmed :)
03:07:03 <klrr> it doesnt work though, gonna paste the code..
03:08:10 <leggo> klrr do block might make it a bit more readable too
03:09:21 <klrr> it works now :DDDD!!!!!!!!!!!!
03:09:21 <donri> is there a tool to parenthesise the precedences in an expression?
03:09:51 <donri> [that knows about infix[rl]]
03:10:53 <Javran> I know `seq` might work ... but I don't know how to achieve this ...
03:10:58 <donri> klrr: btw for a prompt you might want to look at readline or haskeline
03:11:13 <hiptobecubic> donri, a good question
03:11:25 <Javran> putStr need to be forced before getLine
03:11:38 <donri> Javran: that's not it here
03:12:22 <mauke> Javran: wrong
03:12:54 <donri> AFAIK putStr doesn't use lazy IO
03:13:11 <Javran> well ..
03:13:39 <klrr> donri: will check them :)
03:13:53 <mauke> even if it did, seq would do nothing
03:14:04 <donri> that too
03:14:56 <Javran> so I've misunderstood seq ...
03:14:59 <fruitFly> Can I use else in my gaurds like this? or do I have to use otherwise or some other construction? http://ideone.com/ai4P6P#view_edit_box
03:15:08 <fruitFly> http://ideone.com/ai4P6P
03:15:20 <donri> Javran: possibly, or you've misunderstood lazy IO :)
03:15:32 <mauke> let's forget about lazy IO first
03:15:38 <mauke> normal IO is enough
03:16:06 <donri> mauke: i think the reason Javran is confused is because of having read about gotchas with lazy IO
03:16:12 <donri> that's what i'm on about
03:16:13 <mauke> I don't think so
03:16:16 <donri> ok
03:17:26 <Javran> donri: I didn't heard of lazy IO before ..
03:17:29 <fizruk> is it that any Monad actions (m >>= f) don't ever change behaviour with `seq`? m `seq` (m >>= f) ~ m >>= f
03:17:35 <donri> Javran: ah
03:18:11 <mauke> http://c-faq.com/stdio/fflush.html :-)
03:18:16 <donri> fruitFly: you need | otherwise as the last guard and you can only have one (well only the first will match)
03:18:55 <donri> fruitFly: you can't do 'else' like that. and which of your two elses would it pick? if the first matches, none of your other guards would
03:19:00 <Javran> donri: and thought simply force getLine would made the trick (of course without trying) ...
03:19:21 <Javran> s/getLine/putStr/
03:19:39 <mauke> Javran: evaluating an IO something has no effect
03:20:13 <mauke> > length [putStr "a", putStr "b", putStr "a"]
03:20:19 <lambdabot>   mueval: ExitFailure 1
03:20:19 <lambdabot>  mueval: Prelude.undefined
03:20:20 <mauke> > length [putStr "a", putStr "b", putStr "a"]
03:20:26 <lambdabot>   mueval: ExitFailure 1
03:20:26 <lambdabot>  mueval: Prelude.undefined
03:20:29 <mauke> ...
03:20:32 <mauke> > ()
03:20:37 <lambdabot>   mueval: ExitFailure 1
03:20:37 <lambdabot>  mueval: Prelude.undefined
03:20:43 <mauke> preflex: seen Cale
03:20:44 <preflex>  Cale was last seen on #haskell 16 hours, 28 minutes and 30 seconds ago, saying: no problem
03:20:54 <donri> ...but there is a problem!
03:21:01 <fruitFly> donri: one cant use else in gaurds?
03:21:37 <fruitFly> donri: I see a fault in my example disregard it... but basically I understand the flow of the gaurds... I want a condition in each gaurd
03:21:42 <hiptobecubic> > 3
03:21:46 <lambdabot>   3
03:21:56 <hiptobecubic> ^.^
03:21:57 <donri> fruitFly: nope. what you do is have an always-matching guard at the end. 'otherwise' is just an alias for 'True', ie. always matching
03:22:23 <mauke> > length [putStr "a", putStr "b", putStr "a"]
03:22:28 <lambdabot>   3
03:22:48 <Javran> mauke: I know even "length [undefined]" works ...
03:22:54 <mauke> true
03:23:00 <Ghoul_> I have to convert (1,5,2) to "1.5.2" any ideas?
03:23:02 <mauke> > putStr "a" `seq` 42
03:23:06 <lambdabot>   42
03:23:11 <mauke> Ghoul_: yeah, just do it
03:23:25 <fruitFly> donri: 0 at the top is the always matching gaurd in this case. Makes more sense to have it at the top in this case.
03:23:39 <fruitFly> donri: actually it's not always matching... but it will eventually match
03:23:52 <Ghoul_> > let d = (1,5,2) in (a,b,c) <- d
03:23:54 <lambdabot>   <hint>:1:1: Parse error in pattern: let d = (1, 5, 2) in (a, b, c)
03:24:11 <savask> > (\(a, b, c) -> show a ++ "." ++ show b ++ "." ++ show c) (1, 5, 3)
03:24:14 <lambdabot>   "1.5.3"
03:24:24 <savask> Ghoul_: ^
03:24:32 <Ghoul_> Oh, forward pattern matching
03:24:40 <mauke> > let (a, b, c) = (1,5,2) in "1.5.2"
03:24:46 <lambdabot>   mueval: ExitFailure 1
03:24:46 <lambdabot>  mueval: Prelude.undefined
03:25:02 <hiptobecubic> > (\(a,b,c) -> intercalate "." [a,b,c]) (1,5,2)
03:25:05 <donri> > intersperse '.' $ (1,5,2) ^.. each.to show
03:25:06 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
03:25:06 <lambdabot>    arising from the literal ...
03:25:08 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
03:25:08 <lambdabot>              with actual type...
03:25:20 <hiptobecubic> oops
03:25:24 <donri> > intercalate "." $ (1,5,2) ^.. each.to show
03:25:28 <hiptobecubic> > (\(a,b,c) -> intercalate "." $ map show [a,b,c]) (1,5,2)
03:25:29 <lambdabot>   mueval: ExitFailure 1
03:25:30 <lambdabot>  mueval: Prelude.undefined
03:25:33 <lambdabot>   "1.5.2"
03:28:59 <b__> @pl (\(Sample l r) -> putWord16le l >> putWord16le r)
03:29:00 <lambdabot> (line 1, column 11):
03:29:00 <lambdabot> unexpected "l"
03:29:00 <lambdabot> expecting operator or ")"
03:30:20 <mauke> no patterns allowed
03:31:05 <fizruk> @pl (\f x -> fromMaybe x (f x))
03:31:06 <lambdabot> ap fromMaybe
03:31:30 <fizruk> :t ap
03:31:33 <lambdabot> Monad m => m (a -> b) -> m a -> m b
03:31:49 <fizruk> :t ap fromMaybe
03:31:52 <lambdabot> (b -> Maybe b) -> b -> b
03:32:06 <b__> @pl (putWord16le l >> putWord16le r)
03:32:06 <lambdabot> putWord16le l >> putWord16le r
03:32:08 <mauke> > ap f x
03:32:14 <lambdabot>   Couldn't match expected type `m0 a0'
03:32:14 <lambdabot>              with actual type `Debug.S...
03:32:27 <mauke> > ap f g x
03:32:32 <lambdabot>   Ambiguous type variable `a0' in the constraints:
03:32:33 <lambdabot>    (GHC.Show.Show a0)
03:32:33 <lambdabot>     ...
03:32:51 <mauke> > ap (f :: Expr -> Expr -> Expr)  g x
03:32:56 <lambdabot>   f x (g x)
03:32:58 <fizruk> mauke: is ap in ap fromMaybe dealing with ((->) b) Monad?
03:33:02 <mauke> yes
03:33:12 <fizruk> interesting
03:33:38 <mauke> @pl \(l, r) -> pw l >> pw r
03:33:38 <lambdabot> uncurry ((. pw) . (>>) . pw)
03:37:43 <b__> @pl (\x -> putWord16le (x ^. left)  >> putWord16le (x ^. right))
03:37:44 <lambdabot> ap ((>>) . putWord16le . (^. left)) (putWord16le . (^. right))
03:37:54 <b__> yeah mauke, I could use a tuple instead of the data type
03:42:37 <fruitFly> I'm trying to build a 2-d grid of gaurds or ifs like in my last function.. how to accomplish? http://ideone.com/ai4P6P
03:42:40 <FreeFull> What's the simplest haskell library for outputting audio?
03:43:38 <Ghoul_> @pl a $ b $ c
03:43:39 <lambdabot> a (b c)
03:43:46 <Ghoul_> Woah, that's awesome.
03:44:09 <Ghoul_> @pl show a ++ "." ++ show b ++ "." ++ show c
03:44:10 <lambdabot> show a ++ '.' : show b ++ '.' : show c
03:44:30 <FreeFull> lambdabot, that's not pointless at all
03:44:46 <nooodl> FreeFull: write bytes to stdout and pipe to /dev/audio!
03:44:59 <FreeFull> @pl \a b c -> show a ++ "." ++ show b ++ "." ++ show c
03:45:00 <lambdabot> (. ((('.' :) .) . (. (('.' :) . show)) . (++) . show)) . (.) . (++) . show
03:45:05 <FreeFull> Ghoul_: There you go
03:45:07 <Ghoul_> LOL
03:45:25 <FreeFull> nooodl: I don't even have a /dev/audio though =P
03:45:28 <Ghoul_> thanks lambdabot :)
03:45:50 <FreeFull> Also I'd like to do it without having to do piping on the outside
03:46:57 <Ghoul_> @pl \opt x d = lookupDefault d cfg x
03:46:58 <lambdabot> (line 1, column 10):
03:46:58 <lambdabot> unexpected "="
03:46:58 <lambdabot> expecting pattern or "->"
03:47:19 <b__> @pl \opt x d -> lookupDefault d cfg x
03:47:20 <lambdabot> const (flip (flip lookupDefault cfg))
03:47:45 <b__> @pl \opt x d -> lookupDefault cfg x d
03:47:45 <lambdabot> const (lookupDefault cfg)
03:48:17 <Ghoul_> @pl \opt x d -> lookupDefault d cfg x
03:48:17 <lambdabot> const (flip (flip lookupDefault cfg))
03:48:24 <b__> @pl opt x d = lookupDefault d cfg x
03:48:25 <lambdabot> opt = flip (flip lookupDefault cfg)
03:49:36 <Ghoul_> it doesn't seem to come out the same
03:50:06 <Ghoul_> or maybe it does, hmm.
04:01:40 <FreeFull> With C, SDL allows you to use an audio callback to fill the buffer and generate the audio, but the Haskell interface doesn't seem to have anything like that
04:02:41 <savask> It would be cool to have functional sound haskell library. So you could compose different sounds, put one after another one or mix them together...
04:04:00 <latermuse> savask: im actually working on something like that
04:04:09 <latermuse> savask: still a bit too early to release though
04:04:59 <savask> latermuse: It will be released later, huh? :-P Were you looking at some existing libraries when creating your own?
04:08:11 <latermuse> no, i didnt find a lot of existing libraries
04:14:27 <hiptobecubic> There are libraries for *music* at least. But I don't know how easy they are to work with
04:15:54 <b__> I wrote a pretty decent synth this week
04:15:58 <b__> read: WAV generator
04:16:16 <no-n> in haskell?
04:16:18 <no-n> neato
04:16:18 <b__> It's pretty easy to write
04:16:24 <no-n> mind if I see?
04:16:38 <b__> I can send some code yeah
04:16:59 <b__> pm
04:17:26 <hiptobecubic> b__, hpaste it
04:17:45 <b__> ok sure
04:20:30 <hpaste> b__ pasted “Some WAV related code” at http://hpaste.org/87731
04:21:07 <b__> it's just the basics, but enough to generate/merge basic waveforms (and their .wav)
04:21:35 <b__> I have some more stuff like envelope etc, but I'm rewriting it atm
04:23:00 <b__> basic usage: main = BS.writeFile "tri.wav" . quickWAV . looped 10 $ sinusoid . Sharp (A 4)
04:23:13 <b__> 10 second sinewav A4#
04:23:52 <b__> note: the paste is not the actual synth
04:24:04 <b__> but enough to play with if you are interested
04:24:14 <no-n> cool, thanks =]
04:24:19 <b__> np
04:24:48 <b__> if anyone sees any obvious improvements, feel free to tell me
04:30:19 <b__> it is based on 16bit 44.1khz stereo LCPM WAV, but it can easily be generalised
04:35:48 <absence> are there any active "functional gui" efforts?
04:36:41 <donri> absence: reactive-banana-wx perhaps
04:37:57 <dons> boing
04:38:58 <donri> absence: also perhaps look at lgtk if you didn't mean frp specifically
04:44:55 <typoclass> donri: that's the "lens gtk" thing, right? (first google hit for me is a common lisp gtk thing called lgtk)
04:45:06 <donri> yes
04:45:10 <donri> @hackage lgtk
04:45:10 <lambdabot> http://hackage.haskell.org/package/lgtk
04:45:18 <typoclass> donri: thanks :)
04:47:38 <fizbin> morning
04:48:09 <typoclass> fizbin: hai
04:48:28 <fruitFly> maybe Int is not matching up with my int... what's the simple fix?
04:49:42 <absence> donri: thanks, i didn't specifically mean frp, but anything that doesn't involve calling an imperative gui library directly from IO
04:49:52 <typoclass> fruitFly: if you have a number, you can use "Just 42", which will match the type Maybe Int. alternatively, you can use "Nothing" (also matches that type)
04:50:37 <FreeFull> :t Just
04:50:42 <lambdabot> a -> Maybe a
04:51:02 <donri> absence: also maybe https://twdkz.wordpress.com/2012/05/10/composable-value-editors/
04:51:19 <fruitFly> typoclass:  I don't get how it work and how to apply it
04:53:14 <donri> > Nothing :: Maybe (Either (Maybe Int) (Maybe Double, Maybe Float))
04:53:16 <lambdabot>   Nothing
04:53:19 <typoclass> fruitFly: could you share the problematic code? if it's more than 1 line, use hpaste.org
04:53:51 <fruitFly> typoclass: line 10 http://ideone.com/ai4P6P
04:54:28 <typoclass> @type elemIndex
04:54:30 <lambdabot> Eq a => a -> [a] -> Maybe Int
04:54:37 <donri> absence: Elm is also interesting, although it's neither haskell nor gui in the classical sense ;)
04:54:56 <typoclass> > elemIndex 'a' "lolcats"
04:54:58 <lambdabot>   Just 4
04:54:59 <typoclass> > elemIndex 'p' "lolcats"
04:55:03 <lambdabot>   Nothing
04:55:53 <typoclass> fruitFly: see how elemIndex uses Maybe? it needs to indicate that the element wasn't found in the list
04:56:09 <fruitFly> typoclass: yeah :)
04:57:54 <fruitFly> typoclass so do I need to put "Just 10 +" ... will that return a type of just Int?
04:58:11 <kennyd> :t Just 10
04:58:15 <lambdabot> Num a => Maybe a
04:58:35 <kennyd> :t Just (10 :: Int)
04:58:38 <lambdabot> Maybe Int
04:59:53 <fruitFly> :t (Just 10) : Int
04:59:57 <lambdabot>     Not in scope: data constructor `Int'
04:59:57 <lambdabot>     Perhaps you meant one of these: `In' (line 124), `InR' (line 131)
05:00:09 <typoclass> fruitFly: ok :) so you're using elem to if h is one of "abcdef". if yes, you're using elemIndex to get the index. (this will always be "Just x", never "Nothing", because we just checked with elem.) in general, this pattern "check then fetch" isn't very good for a variety of reasons. it's usually better to simply "fetch"
05:00:37 <typoclass> fruitFly: hang on while i'm annotating your code
05:00:54 <fruitFly> typoclass: Thanks :D
05:02:35 <typoclass> fruitFly: check this. i've removed elem. it's now fetching directly, instead of "check then fetch" http://ideone.com/B0Nn4V
05:02:57 <typoclass> fruitFly: and there's a remaining problem with your code
05:05:37 <typoclass> fruitFly: do you have any ideas about the current problem?
05:05:42 <fruitFly> typoclass: ok that makes sense :)
05:05:49 <fruitFly> typoclass: gonna take a look now
05:05:55 <typoclass> fruitFly: sure
05:09:19 <fruitFly> typoclass: yes I see it :) ... i need to convert it from a char to an int
05:10:53 <typoclass> fruitFly: more or less. the question is: when someone calls charNum 'k' or charNum 'q', what do you want to happen?
05:11:38 <fruitFly> typoclass: will never happen lol... but i'd like for it to say not a hex string
05:11:38 <typoclass> fruitFly: for example, you could crash the program with an error message. it's maybe not the prettiest solution, but effective
05:12:00 <hpc> typoclass: obviously it returns 0 and sets *error to "number error"
05:12:00 <hpc> ;)
05:12:57 <fruitFly> typoclass:  the error catching aside... how to convert a char to an int... not show... that takes an array?
05:13:13 <Botje> there's Data.Char.ord
05:13:17 <Botje> or read . return
05:13:37 <typoclass> fruitFly: i suggest the 'error' function. you could use something like «Nothing -> error ("OMG invalid hex string. Expected a..f, but actually got " ++ show h)»
05:14:34 <fruitFly> typoclass: ok sure.
05:14:36 <hpc> > read "0xfdcba" :: Integer
05:14:37 <fruitFly> :t read
05:14:40 <lambdabot> Read a => String -> a
05:14:41 <lambdabot>   1039546
05:15:14 <fruitFly> I want to turn '8' into an Int 8
05:15:42 <typoclass> fruitFly: for that, try 'read' (or 'reads')
05:15:49 <hpc> @let digit = read . (:[])
05:15:53 <hpc> > digit '8'
05:15:55 <typoclass> > read "123" :: Integer
05:15:55 <lambdabot>  Defined.
05:15:58 <lambdabot>   mueval: ExitFailure 1
05:15:59 <lambdabot>  mueval: Prelude.undefined
05:15:59 <lambdabot>   123
05:16:03 <hpc> blargh
05:19:32 <fruitFly_> I got dc .. back in now!
05:19:37 <fruitFly_> @type reads
05:19:40 <lambdabot> Read a => ReadS a
05:19:47 <fruitFly_> WHAT IS THAT?!
05:20:13 <hpc> @src ReadS
05:20:14 <lambdabot> Source not found. Maybe if you used more than just two fingers...
05:20:45 <hpc> :t (reads "hi")
05:20:50 <lambdabot> Read a => [(a, String)]
05:21:48 <typoclass> fruitFly_: don't worry, ReadS is just a type synonym for String -> [(a, String)]
05:22:16 <fruitFly_> can I do something like:
05:23:35 <fizbin> > reads "5 4 3" :: [(Int, String)]
05:23:39 <lambdabot>   [(5," 4 3")]
05:23:40 <typoclass> fruitFly_: the basic difference is: 'read' converts, and if it can't convert it'll crash the program with an error message that isn't very helpful. 'reads' converts in the same way, but if the conversion fails, it'll give you an empty list. you can then check for the empty list and print out a more useful error message
05:24:03 <fizbin> > reads "not an int" :: [(Int, String)]
05:24:06 <lambdabot>   []
05:24:14 <typoclass> > read "meow" :: Int
05:24:19 <lambdabot>   mueval: ExitFailure 1
05:24:20 <lambdabot>  mueval: Prelude.undefined
05:24:33 <hpc> > read "5 4 3"
05:24:39 <lambdabot>   mueval: ExitFailure 1
05:24:39 <lambdabot>  mueval: Prelude.undefined
05:24:48 <hpc> this is silly
05:25:00 <hpc> mueval doesn't have that much overhead that it times out so soon
05:25:12 <hpc> on so simple an expression
05:25:15 <typoclass> fruitFly_: i don't know why lambdabot didn't print that, but usually the message from 'read' is "Prelude.read: no parse". it's not very helpful. it doesn't even show you the String that didn't work
05:25:25 <fizbin> > reads "5garbage" :: [(Int, String)]
05:25:30 <lambdabot>   [(5,"garbage")]
05:26:33 <typoclass> hpc: i don't know what's up with lambdabot this morning. there was a "whisky 50% off" thing at the irish pub yesterday
05:26:39 <fruitFly_> what about this?
05:26:41 <fruitFly_> ...
05:27:08 <fizbin> Essentially, read is equivalent to taking fst of the first element of reads that has "" as its snd.
05:27:11 <hpc> even my bot isn't this slow, and it runs on a core2 laptop from 2006
05:27:15 <fruitFly_> charToInt c = read (c:[]) : Int?
05:27:34 * fizbin thinks the box lamdabot is on may need kicking.
05:28:20 <fizbin> fruitFly_: Okay, but you want (:: Int), not (: Int)
05:28:38 <fizbin> Also, I'd put the type on charToInt instead, as in:
05:28:48 <fizbin> charToInt:: Char -> Int
05:29:03 <fizbin> charToInt c = read (c:[])
05:29:22 <fruitFly_> Ok thanks fizbin :D
05:29:33 <fruitFly_> fizbin: is there a more efficient way
05:29:34 <fruitFly_> ?
05:29:48 <fruitFly_> fizbin: ^ typoclass hpc ?
05:30:35 <fizbin> Oh, sure.
05:30:51 <fizbin> > fromEnum "9"
05:30:55 <lambdabot>   No instance for (GHC.Enum.Enum [GHC.Types.Char])
05:30:56 <lambdabot>    arising from a use of `...
05:30:58 <fizbin> > fromEnum '9'
05:31:03 <lambdabot>   57
05:31:25 <mekeor> "thr*" is hard to pronounce, imo; e.g. "three".
05:31:47 <typoclass> fruitFly_: well, there are pre-defined functions for converting to/from hex. but i assumed you were implementing this yourself as an exercise :-)
05:31:56 <fruitFly_> typoclass: yes
05:31:58 <fizbin> > let charToInt c = if isDigit c then (fromEnum c - fromEnum '0') else error "Not a digit" in charToInt '5'
05:32:03 <lambdabot>   5
05:32:12 <fizbin> > let charToInt c = if isDigit c then (fromEnum c - fromEnum '0') else error "Not a digit" in charToInt 'q'
05:32:18 <lambdabot>   mueval: ExitFailure 1
05:32:18 <lambdabot>  mueval: Prelude.undefined
05:32:20 <FreeFull> I'd personally convert more directly rather than converting to a number, and then back to string
05:32:33 <typoclass> tangentially, 'read' takes a String, so the argument is always Showable isn't it? we could make the «Prelude.read: no parse» message at least a little more helpful. «Prelude.read: Couldn't parse string "lolcats"»
05:32:49 <typoclass> (... ideally, it would also include the line number of the call to 'read' ...)
05:33:09 <fizbin> typoclass: Except "no parse" is only one of the ways read can fail to parse a string.
05:33:14 <hpc> sadly haskell doesn't have caller() info like perl does
05:33:29 <mekeor> (oops, that was for -blah, sorry.)
05:33:54 <fruitFly_> @type fromEnum
05:33:57 <lambdabot> Enum a => a -> Int
05:34:00 <fizbin> Also, if you want the line number where stuff blew up, that's what the facilities around getting a debugging stack trace are for.
05:34:14 <FreeFull> :info Char
05:34:18 <fruitFly_> Enum '3'
05:34:34 <FreeFull> fruitFly_: Enum is a typeclass
05:34:38 <Reiser> :info ReadS
05:34:50 <FreeFull> @info Char
05:34:51 <lambdabot> Char
05:34:55 <typoclass> fizbin: how do you mean, there's other ways 'read' can fail? 'read' is always being called with a String, and that can be shown in an error message, can't it?
05:34:55 <fizbin> typoclass: Though it seems to use the "no parse" message for both kinds of errors. Huh.
05:34:57 <mauke> FreeFull: ಠ_ಠ
05:35:11 <fruitFly_> FreeFull: o right
05:35:16 <Reiser> @info ReadS
05:35:17 <lambdabot> ReadS
05:35:19 <fizbin> typoclass: There's "no parse" and "ambiguous parse".
05:35:27 <mauke> Reiser: ಠ_ಠ
05:35:29 <Reiser> I would've thought @info might've shown the type synonym?
05:35:37 <mauke> there is no @info command
05:35:40 <hpc> does ambiguous parse ever come up?
05:35:41 <Reiser> o
05:35:43 <Reiser> h
05:35:46 <fizbin> Though I'm going to have to write my own ReadS instance to get ambiguous parse.
05:35:59 <FreeFull> > fromEnum 'a'
05:36:02 <typoclass> fizbin: oh that's what you mean. hm i have to look up the source
05:36:05 <lambdabot>   mueval: ExitFailure 1
05:36:05 <lambdabot>  mueval: Prelude.undefined
05:36:16 <FreeFull> Oh come on lambdabot
05:36:26 <mauke>  97
05:36:30 <hpc> lambdabot is a lambda butt
05:36:58 <FreeFull> Some day someone will get fed up enough to write a lambdabot replacement
05:37:02 <fizbin> I think lambdabot needs to be run in its own virtual machine that's rebooted every hour or so.
05:37:15 <typoclass> Reiser: @src ShowS gives a useful result, but not @src ReadS. seems to be an odd oversight. @info is a weird command that has never done anything useful, as far as i've seen
05:37:21 <fizbin> FreeFull: I suspect lambdabot's issue is crap we've asked it to do.
05:37:25 <hpc> FreeFull: i have one on another network; im too lazy to write the necessary configuration for multi-networking
05:37:27 <mauke> typoclass: there is no @info command
05:37:41 <Reiser> typoclass: ah, thank you
05:37:46 <fizbin> :info whatever
05:37:58 * hackagebot here 1.2.1 - Here docs & interpolated strings via quasiquotation  http://hackage.haskell.org/package/here-1.2.1 (TaylorHedberg)
05:38:17 <FreeFull> @blabla bla
05:38:18 <lambdabot> Unknown command, try @list
05:39:02 <mauke> @quake
05:39:03 <lambdabot> Data.Strict.Maybe says: Note that strict Maybe is not a monad since return _|_ >>= f = _|_ which is not necessarily the same as f _|_.
05:39:07 <FreeFull> lambdabot doesn't even do unicode
05:39:52 <FreeFull> f could be const (Just 3)
05:39:59 <typoclass> FreeFull: yeah :-( it worked in the past, but then they did an upgrade and that introduced a problem
05:41:42 <FreeFull> > val "\u444"
05:41:47 <lambdabot>   <hint>:1:7:
05:41:47 <lambdabot>      lexical error in string/character literal at character 'u'
05:42:15 <FreeFull> > val "\10004"
05:42:20 <lambdabot>   mueval: ExitFailure 1
05:42:20 <lambdabot>  mueval: Prelude.undefined
05:42:25 <FreeFull> > 3
05:42:31 <lambdabot>   mueval: ExitFailure 1
05:42:31 <lambdabot>  mueval: Prelude.undefined
05:42:35 <FreeFull> It's completely borked
05:42:41 <Reiser> I think you killed it
05:43:22 <typoclass> please don't refer to her as 'it'
05:43:46 <Reiser> Oh damn, now I'm a misogynist D:
05:44:07 <FreeFull> I will refer to everybody as it
05:46:35 <fizbin> lambdabot needs her own VM.
05:46:42 <fruitFly_> I'm proud of my bullshit hex to binary converter if anyone wants to test drive it haha lol... :P .. gonna make sure it's correct now
05:46:44 <fruitFly_> http://ideone.com/ai4P6P
05:48:28 <fizbin> And that VM needs regular reboots.
05:48:55 <FreeFull> fizbin: That would mean lambdabot regularly coming and leaving
05:49:13 <FreeFull> I think lambdabot needs to retire
05:49:34 <FreeFull> Or be improved
05:50:05 <no-n> no :[
05:50:08 <fizbin> fruitFly_: Actually, what we need is a lamdabot that uses mueval hosted in one of two VMs, and the mueval VMs get regularly rebooted.
05:50:12 <no-n> lambdabot is our friend
05:50:22 <typoclass> FreeFull: so, you're volunteering for a major cleanup? did i hear you correctly? :-)
05:50:44 <fruitFly_> fizbin: right up!
05:50:52 <fizbin> That would mean that @let expressions would disappear regularly, but I don't know that that's a bad thing.
05:51:07 <fizbin> Or maybe they could be stored and replayed.
05:51:29 <FreeFull> VM does sound interesting
05:51:41 <FreeFull> Maybe could let people do more without it being a security issue
05:56:58 <mm_freak> fruitFly_: you misunderstood "binary"
05:57:08 <fizbin> fruitFly_: What level of comments are you looking for on your hex->binary thing?
05:57:11 <mm_freak> binary means, encode hex strings to bytes
05:57:45 <mm_freak> also:  intercalate [] = concat
05:57:59 <mm_freak> > intercalate [] ["abc", "def", "ghi"]
05:58:03 <lambdabot>   "abcdefghi"
05:58:14 <fruitFly_> mm_freak: is the code you're looking at working?
05:58:34 <hpc> oh, while we are talking about lambdabot cleanup
05:58:47 <hpc> i had made a bunch of bugfixes a while back and could never find anyone to give my patch to
05:58:55 <hpc> so.... good luck with that
05:59:08 <mm_freak> fruitFly_: according to the compiler output on that site it's not =)
05:59:09 <fruitFly_> why isn't this working now... all I changed was the import statment? http://ideone.com/ai4P6P
05:59:29 <mm_freak> fruitFly_: because it's "import"
05:59:33 <mm_freak> not "Import"
05:59:48 <fruitFly_> lol
05:59:50 <fruitFly_> ok
06:00:10 <typoclass> hpc: kids these days seem to just fork it all on github. afterwards you only need to convince cale to compile and run "lambdabohpc"
06:00:31 <typoclass> hpc: but yes. it's unfortunate that lambdabot is so unmaintained
06:00:32 <fruitFly_> mm_freak: try it now http://ideone.com/ai4P6P
06:00:54 <fruitFly_> mm_freak: I know what intercalate does... my code matches other hex to binary converters??? what gives?
06:01:12 <hpc> typoclass: or i could... not do that :P
06:01:26 <mm_freak> fruitFly_: intercalate [] = concat
06:01:32 <mm_freak> > concat ["abc", "def", "ghi"]
06:01:38 <lambdabot>   mueval: ExitFailure 1
06:01:38 <lambdabot>  mueval: Prelude.undefined
06:01:41 <mm_freak> > concat ["abc", "def", "ghi"]
06:01:46 <lambdabot>   mueval: ExitFailure 1
06:01:46 <lambdabot>  mueval: Prelude.undefined
06:01:51 <no-n> :o
06:01:55 <mm_freak> lambdabot: poor little buddy
06:02:11 <fizbin> @tell Cale lambdabot really needs a reboot.
06:02:12 <mm_freak> you need a person to take care of you
06:02:12 <lambdabot> Consider it noted.
06:02:20 <mm_freak> @botsnack
06:02:21 <lambdabot> :)
06:02:26 <no-n> lol
06:02:36 <fruitFly_> mm_freak: I used intercalate because I converted each char to a nibble and got a result like this ["0011","0100","0110"]
06:02:57 <mm_freak> fruitFly_: ok, now replace "intercalate []" by "concat" ;)
06:03:07 <fruitFly_> I get it mm_freak  :D
06:03:09 <hpc> fruitFly_: those should be 8 bits, not 4
06:03:11 <fizbin> fruitFly_: Right, but what mm_freak is saying is that (intercalate "") means the same as (concat)
06:03:22 <hpc> i think
06:03:25 <fizbin> hpc: He's doing a nibble at a time, not a full byte.
06:03:31 <hpc> ah
06:03:33 <fruitFly_> mm_freak: is concat in prelude?
06:03:39 <hpc> oh right, because hex
06:03:48 <fizbin> fruitFly_: concat is in the Prelude.
06:03:48 <typoclass> fruitFly_: yes it is
06:03:58 <mm_freak> fruitFly_: the problem with your code is that it solves a related, but different problem
06:04:14 <mm_freak> the challenge wants you to write a function of this type:  hexToBin :: String -> [Word8]
06:04:23 <mm_freak> (or whatever representation you use for the byte string)
06:05:08 <mm_freak> you literally just recoded the hex digit representation into binary digits
06:05:23 <fizbin> mm_freak: Of course, I'm not sure how to output that given that he's working on ideone.com
06:05:35 <fizbin> How would he output arbitrary binary data?
06:05:42 <mm_freak> fizbin: they certainly give you access to Data.Word
06:05:55 <mm_freak> and the output would look like this:
06:05:57 <fizbin> mm_freak: Sure, but then what do you do with it?
06:06:13 <mm_freak> > BS.unpack (BSC.pack "blah")
06:06:16 <lambdabot>   [98,108,97,104]
06:06:41 <fizbin> mm_freak: I mean, it isn't as though you can open an arbitrary file locally, write to it, and offer that file for download.
06:06:54 <mm_freak> fizbin: i don't understand
06:07:05 <fruitFly_> mm_freak: i dn't get what differently I need to do
06:07:21 <fruitFly_> mm_freak: I though I could just convert binary to base 64
06:07:21 <mm_freak> fruitFly_: your result is a list of binary digits
06:07:26 <mm_freak> it should be a list of bytes
06:07:53 <fizbin> mm_freak: Suppose I have a program that creates an arbitrary binary blob. How do I run that program on ideone to demonstrate that my program did what I wanted it to do, and created the correct binary blob?
06:08:01 <fruitFly_> mm_freak: isn't my answer a concation of nibbles... i.e. half bytes... why does it have to be bytes?
06:08:12 <mm_freak> fizbin: by using Show?
06:08:36 <fizbin> I suppose I could output the list BS.unpack does to my bytestring...
06:09:29 <mm_freak> in the challenge you find the following note:
06:09:31 <mm_freak>   Always operate on raw bytes, never on encoded strings. Only use hex
06:09:31 <mm_freak>   and base64 for pretty-printing.
06:09:43 <mm_freak> that's why you need bytes
06:10:12 <fizbin> I wonder if ideone.com would allow me to output html - that'd probably be full of XSS issues, though.
06:10:21 * fizbin is thinking data: urls.
06:10:23 <hpc> protip: instead of a hex editor, make a byte editor where your interface to bytes is "hh" pairs
06:11:46 <fruitFly_> mm_freak: can I just concat 2 nibbles and convert that to word8 and call that a byte?
06:12:19 <fruitFly_> mm_freak: I think I'm getting it... we're simulating shit as it would come through the pipes, right?
06:13:46 <mm_freak> fruitFly_: my suggestion is to meet the following type signature:  String -> Maybe [Word8]
06:13:53 <fruitFly_> hello?
06:13:58 <fruitFly_> ok.. i'm working
06:14:05 <mm_freak> if you meet it and the result is raw bytes, then you can use whatever implementation you want =)
06:14:10 <mm_freak> you can still improve the implementation later
06:14:40 <mm_freak> and don't forget the Maybe…  not every String is a valid hex string
06:14:54 <mm_freak> in particular this one is wrong for this particular purpose: "fff"
06:17:20 <fruitFly_> mm_freak: so the number of hex chars MOD 2 must = 0?
06:20:24 <fruitFly_> mm_freak: I have some more questions... I'l hit u up soon
06:20:46 <fizbin> fruitFly_: I would suggest you approach this with a second subfunction "oneByte" of type Char -> Char -> Maybe Word8 and then if your main function convert the empty string to (Just []), a string that matches (x:y:rest) into (do {r <- convertHexString rest; s <- oneByte x y; return (s:r)}) and anything else into Nothing.
06:22:27 <fizbin> So rather than enforce "number of hex chars MOD 2 must = 0" directly, you instead enforce it as a consequence by turning empty string into (Just []) and something with at least two chars into Just (what those two chars mean):(what the rest means)
06:22:51 <fizbin> And then if you have a single char at the end, of course for that return Nothing.
06:27:43 <mm_freak> fruitFly_: what fizbin said
06:40:50 <no-n> @src sum
06:40:50 <lambdabot> sum = foldl (+) 0
06:40:57 <no-n> @src product
06:40:58 <lambdabot> product = foldl (*) 1
06:47:44 <no-n> > product []
06:47:49 <lambdabot>   mueval: ExitFailure 1
06:47:50 <lambdabot>  mueval: Prelude.undefined
06:48:10 * no-n slaps lambdabot
07:12:55 <lpsmith> @tell byorgey thanks,  I wrote up a discussion of subsequences once:  http://blog.melding-monads.com/2010/04/04/on-powersets-and-folds/    The final version of powerset is equivalent to subsequences.
07:12:56 <lambdabot> Consider it noted.
07:13:04 * hackagebot strict-base-types 0.2 - Strict variants of the types provided in base.  http://hackage.haskell.org/package/strict-base-types-0.2 (SimonMeier)
07:23:04 * hackagebot linux-blkid 0.2.0.0 - Linux libblkid  http://hackage.haskell.org/package/linux-blkid-0.2.0.0 (NicolaSquartini)
07:26:16 <t4nk202> I have written this:
07:26:19 <t4nk202> x <- getStdGen
07:27:01 <t4nk202> how do I create a infinite list of random numbers from "x <- getStdGen"?
07:27:37 <no-n> :t randoms
07:27:42 <no-n> :t randomRs
07:27:43 <lambdabot> (RandomGen g, Random a) => g -> [a]
07:27:50 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> [a]
07:29:19 <t4nk202> when I did this: "let rs = randoms x :: [int]" i got error "No instance for (Random int1)  arising from a use of `randoms'"
07:30:09 <no-n> Int, not int
07:32:29 <t4nk202> thanks
07:33:08 <no-n> np
07:41:12 <no-n> @src fromJust
07:41:12 <lambdabot> fromJust Nothing  = undefined
07:41:12 <lambdabot> fromJust (Just x) = x
07:41:28 <jeff_s1> Are there any compilers that target Haskell?
07:41:50 <Eduard_Munteanu> jeff_s1: Agda does
07:41:54 <typoclass> jeff_s1: i think there are a few. afaik agda is one
07:42:28 <no-n> @src undefined
07:42:29 <lambdabot> undefined =  error "Prelude.undefined"
07:42:29 <Eduard_Munteanu> jeff_s1: google for Alonzo or MAlonzo
07:42:34 <jeff_s1> Hm, I should be more specific. How about compilers from imperative languages to Haskell?
07:42:43 <jeff_s1> eduard - THanks, I'll do that
07:43:09 <Eduard_Munteanu> Ah, dunno about that.
07:45:28 <klrr> is there any function that can read a integer from a string, aka String -> Int
07:45:33 <klrr> for example
07:45:45 <klrr> no int to string i mean
07:45:47 <klrr> so
07:45:58 <klrr> foobar 123 returns "123"
07:46:02 <monochrom> that's show
07:46:04 <jeff_s1> show
07:46:07 <klrr> thanks
07:46:59 <Fuuzetsu-> @hoogle a -> String
07:47:00 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
07:47:00 <lambdabot> Prelude show :: Show a => a -> String
07:47:00 <lambdabot> Text.Show show :: Show a => a -> String
07:51:54 <no-n> @src (>>=)
07:51:55 <lambdabot> Source not found.
07:56:01 <jmcarthur> lispy: any improvements to juicypixels is a win for sure
08:06:12 <Cale> > concat ["abc", "def", "ghi"]
08:06:16 <lambdabot>   "abcdefghi"
08:06:17 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
08:07:44 <Brongue> What is a good way to model a chessboard?
08:09:46 <typoclass> Brongue: a big list? or a list of lists?
08:10:06 <monochrom> a sparse array
08:10:35 <typoclass> Brongue: (trying the easiest solution :-) until there's good reason for something more elaborate)
08:12:34 <Brongue> typoclass: Well that is the easiest and most obvious solution i guess...
08:13:54 <Fuuzetsu-> Brongue: There's no reason why you couldn't replace it later with something else
08:17:36 <nooodl> Map (Int, Int) Piece?
08:20:30 <Hermit> I'm making a file monitor with inotify. Since inotify forks to handle events, the main process should wait indefinitely for it to work. What is the most idiomatic way to make this process wait? calling getLine in a loop works but seems dirty
08:21:19 <typoclass> Hermit: you could use "forever (threadDelay maxBound)"
08:21:47 * Hermit looks for threadDelay
08:24:27 <Hermit> it's more idiomatic than getLine since it doesn't deppend on io, but isn't getLine more lightweight than threadDelay? (no need to schedule, count microseconds. Just wait for a more-input-available event)
08:24:47 <Hermit> should be trivial anyways
08:27:31 <typoclass> Hermit: well, if i recall correctly maxBound is something like 35 minutes on a 32-bit system. it could possibly be a problem if you did this (minimal) computation say 200 times per second, but honestly, 1 time per half-hour ... :-)
08:28:18 <Hermit> yeah...
08:59:28 <black_joe> I have a compile error that I've been trying to fix all morning, but I'm not even making headway on it. Can someone take a peak at this?
08:59:31 <black_joe> http://hpaste.org/87736
08:59:43 <black_joe> I'm getting the error: Main.hs:18:10: parse error on input `let'
08:59:56 <black_joe> My best guess is something with formatting, but I've rearranged that plenty of times.
09:01:55 <black_joe> oh what the hell? I see a problem with the paste not present in the code.
09:02:23 <fizruk> black_joe "((length args) == )" should be what?
09:02:34 <black_joe> It should be a 1.
09:02:39 <black_joe> I put it in, but still the same error.
09:03:44 <fizruk> black_joe: "if c then m else return ()" can be rewritten as when c x
09:03:52 <fizruk> when is from Control.Monad
09:04:05 <madjestic> hey guys.  I've been thinking: is right-fold for a data-tree possible? (to be clear: I mean folding of a tree in leaf->root direction)
09:04:41 <black_joe> Okay, thanks. I still have to learn about Monads in depth this weekend.
09:05:34 <fizruk> black_joe: just one more second
09:05:50 <hpc> madjestic: that's a left fold, i think
09:06:01 <hpc> in the sense that for lists, left folds go tail to head
09:07:09 <fizruk> black_joe: I think you should name variables appropriately, rspnc, bfr, bfrt are not very comprehensive
09:07:24 <black_joe> I know, they're for testing purposes right now. Sorry about that.
09:07:50 <monochrom> black_joe: you have a lot of misalignment errors. what is with shifting some lines to the left or right by 1 column?
09:08:25 <black_joe> Honestly, I haven't found out what's doing that yet. I've opened the file in multiple editors to try and fix this, but something is screwing formatting up.
09:08:27 <madjestic> hpc: ok, maybe fold analogy is bad.  I like scanr1 analogy more. in the sense tail->head
09:08:41 <black_joe> In fact, at one point some code got pushed past column 1,000 by tabs.
09:08:56 <hpc> oh wow
09:08:58 <hpc> https://github.com/joachifm/acme-omitted/blob/master/src/Acme/Omitted.hs
09:09:01 <hpc> this is rather handy
09:13:13 <monochrom> black_joe: I see. I won't be imposing on how you should set up your editors. just bear in mind that GHC sees exactly what hpaste displays. not what editors display.
09:13:49 <mauke> hpc: heh. stolen from perl?
09:13:50 <black_joe> Yeah, I really didn't know it was that bad until I pasted it. I'm going to rewrite it with attempted better formatting to see if that works.
09:14:45 <monochrom> but 1000 is a tad extreme haha
09:18:31 <eikke> if I am 'inside' some 'RWS r w s0 a', and now I want to eval some action of type 'RWS r w s1 a' using some starting state s1 derived from my current state s0, how should I eval this?
09:18:50 <black_joe> Thanks channel. Formatting was the issue apparently.
09:20:10 <Taneb> eikke, I'd say Control.Lens.Zoom, but there has got to be an easier way
09:20:34 <eikke> Taneb: using lens is ok (using it already, and its introduction is what gives me this 'issue' :-))
09:20:58 <eikke> Taneb: will give it a spin, thanks
09:21:14 <Taneb> If you've got a lens from s0 to s1, just use "zoom lenss0tos1 $ do..."
09:21:49 <eikke> hmh, will need to write it using some custom function I guess
09:21:52 <eikke> (the lens, I mean)
09:22:12 <Taneb> What are the types?
09:22:49 <eikke> data State s a where Follower :: FollowerState -> State Follower a (and some more of those)
09:23:02 <eikke> s0 is 'State Follower a', s1 is 'FolloweState a'
09:23:16 <eikke> (hmh, typo in the above: Follower :: FollowerState a -> State Follower a'
09:24:04 <eikke> so the lens to be used with zoom should unpack FollowerState out of the Follower constructor, and that's it I guess
09:25:05 <Taneb> It looks like you want to make a Prism, I think
09:25:41 <eikke> didnt use those yet :)
09:25:58 <eikke> (what's with all the joins and leaves?!)
09:27:07 <eikke> Taneb: no, dont think I need a prism -> in the code path I'm in, I can be 100% certain (eg) Follower will be the only possible constructur for my input state
09:27:19 <eikke> (100% -> type-checked correct etc)
09:27:30 <Taneb> Oh, cool
09:27:56 <Taneb> And the joins and leaves look like a netsplit?
09:28:22 <eikke> I think I need some lenslike thing which only allows get, no set
09:28:56 <Taneb> That would make things trickier
09:29:25 <eikke> Taneb: why would set be required for zoom?
09:29:28 <Taneb> (btw, that's called a "getter", it's isomorphic to a function, and doesn't work with zoom)
09:29:35 <Taneb> So you can put the state back in
09:29:41 <Taneb> When you're done
09:29:56 <eikke> ah, right
09:30:13 <eikke> well, I can still wrap back in order to get a full lens, but that function won't be used in my code
09:30:39 <Taneb> You'd be surprised where it could come in handy
09:38:12 * hackagebot reactive-banana 0.7.1.2 - Practical library for functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.7.1.2 (HeinrichApfelmus)
09:41:11 <fruitFly_> mm_freak: MY BOY!
09:41:54 <Taneb> I'm trying to install ghc-mod from source, but I don't seem to have a ~/.emacs.el file
09:42:43 <Fuuzetsu-> Taneb: Your init file will do
09:43:01 <Fuuzetsu-> also, it might be in ~/.emacs.d/emacs.el or something
09:43:07 <geekosaur> that's (one possible name for) emacs's user config file. just create it
09:43:30 <elliott> Taneb: you might have an ~/.emacs
09:43:40 <Taneb> elliott, I do habe a ~/.emacs
09:43:52 <elliott> put whatever it is in there
09:44:58 <eikke> Taneb: if my actual monad is not RWST, but some custom FooT (newtype wrapper around RWST, I need to provide a Zoom instance for it
09:45:12 <eikke> but kinda stuck there it seems :)
09:46:38 <eikke> GHC says: Couldn't match type `Zoomed (TransitionT s z)' with `Zoomed (TransitionT t z)' NB: `Zoomed' is a type function, and may not be injective In the instance declaration for `Zoom (TransitionT s z) (TransitionT t z) s t'
09:46:47 <eikke> (any typos in the above are mine)
09:49:13 <joe9> I have a program that reads input from a usb device at regular intervals. I want to compare the new input with the previous input and do some calculations. The simple solution would be to read/use the state monad. I stumbled upon yampa and frp and am wondering if they would be relevant to my context or if they are only for gui's.
09:52:41 <joe9> I also read about arrows and they seem to be more useful/expressive than monads.
09:53:00 <hpc> joe9: look up arrow notation
09:53:04 <hpc> you'll quickly change your mind ;)
09:53:13 <hpc> *arrow-do notation
09:54:30 <joe9> hpc, from what I read, arrows seem to be the next generation monad. Is that wrong?
09:54:55 <joe9> :vsp
09:55:07 <geekosaur> arrows and monads solve different problems
09:55:13 <elliott> arrows aren't used much nowadays
09:55:21 <elliott> they tend to be very clunky to use in practice
09:55:31 <elliott> and they aren't nearly as flexible as they could be, which means that even if
09:55:33 <hpc> the hipsters have gone on to lenses, and the real programmers have just stuck with monad/applicative/functor
09:55:36 <hpc> ;)
09:55:44 <elliott> monads are too strong to reprsent what you're doing, arrows are likely to be too
09:55:52 <elliott> (because of the reliance on "arr")
09:55:58 <Eduard_Munteanu> @arr
09:55:58 <lambdabot> Aye Aye Cap'n
09:56:05 <hpc> @quote yarr
09:56:06 <lambdabot> No quotes match. Just try something else.
09:56:10 <elliott> lenses don't even fit into the remotely the same hierarchy :P
09:57:07 <hpc> Arrow tries to be way too much
09:57:20 <hpc> it has its own re-implementation of Category
09:57:25 <joe9> hpc, sticking with monad/applicative/functor, which would be a good library for state manipulations that I have.
09:59:28 <elliott> hpc: huh?
09:59:33 <elliott> Arrow has Category as a superclass
10:00:02 <hpc> elliott: (>>>), (<<<), returnA
10:00:08 <elliott> @hoogle (>>>)
10:00:09 <lambdabot> Control.Category (>>>) :: Category cat => cat a b -> cat b c -> cat a c
10:00:09 <lambdabot> Control.Arrow (>>>) :: Category cat => cat a b -> cat b c -> cat a c
10:00:16 <elliott> hpc: just a re-export
10:00:40 <elliott> it's true that returnA's type could be more general, though
10:00:50 <elliott> but (<<<) and (>>>) are both defined in Control.Category
10:01:16 <hpc> oh, pah
10:20:20 <cschneid> as I keep reading about haskell, it seems like Prelude isn't the best way to do many things.  for instance, folding via prelude, and folding via Data.Foldable.  ++ vs, mappend. Is that accurate? That mostly prelude is outdated, and overly simplistic?
10:21:12 <cschneid> or fmap vs. map for instance.
10:21:21 <dwcook> I'd say it's good until you learn enough to move beyond
10:21:32 <simpson> cschneid: The Prelude's just stuff that all Haskell implementations have.
10:21:32 <dwcook> fmap is in the Prelude, by the way
10:21:40 <cschneid> oh? hmm. cool
10:21:55 <ParahSail1n> prelude is there so that beginners dont need to understand "hard" stuff like typeclasses at the beginning
10:22:03 <elliott> ??
10:22:04 <cschneid> not useless, but "the simplest thing that works". which falls over when you get to fancy stuff
10:22:06 <elliott> Prelude contains typeclasses
10:22:16 <simpson> What? Prelude's got Functor, Monad, Num...
10:22:30 <elliott> it is true that Prelude has functions that are generalised elsewhere.
10:22:33 <Saizan> but it also has a bunch of monomorphised versions of functions
10:22:38 <elliott> there is no reason not to use the Prelude's functions when they work for you
10:22:49 <elliott> you can argue as a language design thing whether it should have the more advanced versions or not
10:22:57 <dwcook> You could even use map even if you know about fmap, if you're working specifically with lists
10:23:00 <Saizan> and that was made so specifically in haskell98 for teaching reasons like ParahSail1n said
10:23:04 <elliott> in practice, there's no reason to use the fancier versions when you don't need them. you pay in more import lines to maintain, and often less clear error messages
10:23:08 <cschneid> elliott: so if I know I have a list, no worries if I use map? Does that limit me later to refactoring to other data structures
10:23:20 <ParahSail1n> "hard" and "optional" typeclasses typeclasses like traversable, foldable etc
10:23:33 <elliott> uh, it depends on your code. I think that's rarely a relevant consideration
10:23:47 <dwcook> I think I tend to do the least general thing that works for my purposes
10:23:57 <dwcook> I don't factor things out into more general functions until I realize I need to
10:24:30 <dwcook> so if I know I'm working just with lists, using map is fine, and later I can change it if it turns out my program would work just fine with more general structures
10:24:58 <cschneid> dwcook: ok. seems viable, and you don't find much difficulty in doing that refactoring later when you decide to make that leap? I suppose haskell is really succinct, so there's not that much mechanical typing involved.
10:25:12 <cschneid> dwcook: I do like the idea of doing the simplest thing that works
10:25:38 <dwcook> Refactoring stuff can be hard, depends. But usually in Haskell I find it's not
10:26:01 <Saizan> if you ask edwardk generalizing is a way of life, to catch bugs via parametricity even
10:26:21 <tero-> writing unnecessarily general code is a bit like optimizing before profiling
10:26:49 <dwcook> There was this one decision I had to make recently where, to relieve a circular dependency that cropped up in some modules, I could've chosen either to move my types to a separate module, or add a type parameter to every type I'd written. The latter seemed more "right" but definitely harder to do. So I just did the former
10:26:49 <cschneid> dwcook: do you usually have a base of tests to help you refactor w/o breaking things?
10:27:17 <dwcook> No, but if I'm being honest I probably ought to :P
10:27:21 <cschneid> I'm trying to get an idea of the dev process in haskell. (sorry for the overly inflammatory ways to start discussions...)
10:27:43 <newbie_Yosemite> Hi geeks, newbie question... is there a standard function or idiom to reduce a list to a set of unique  elements?
10:27:45 <tero-> refactoring Haskell code is a joy compared to other languages
10:27:52 <dwcook> I'm actually relatively new to Haskell. I have been doing it less than a year and haven't got into many of the deeper concepts yet
10:28:04 <monoidal> newbie_Yosemite: if the list is sorted, Data.List.nub
10:28:15 <Saizan> even if it's not sorted
10:28:22 <djahandarie> monoidal, that will work even if it isn't sorted
10:28:24 <arkeet> if it's sorted, map head . group
10:28:25 <cschneid> dwcook: you're way more experienced than I am. Actually, you're in an awesome spot to help me out. Since you haven't internalized all the fancier concepts. You remeber what it's like to have just finished reading RWH
10:28:28 <djahandarie> You are probably thinking of map head . group
10:28:31 * djahandarie sighs
10:28:39 <dwcook> cschneid, I actually haven't read that yet :) But I've read LYAH
10:28:47 <cschneid> dwcook: yeah, that too. :)
10:28:51 <monoidal> djahandarie: ew, right
10:29:07 <cschneid> dwcook: I did most learning in lyah, and then jumped to the end of RWH for a few MonadTransformer tricks which lyah didn't cover
10:29:19 <monoidal> newbie_Yosemite: you can also use Data.Set.fromList to construct a set.
10:29:23 <jmcarthur> i typically write code with the most generic types possible
10:29:36 <djahandarie> > map head . group . sort $ [6,2,3,4,1,8,4,3,4,3,3,2,1,4,5,3,2,1,7,8,6,4,5,3,9]
10:29:41 <lambdabot>   mueval: ExitFailure 1
10:29:41 <lambdabot>  mueval: Prelude.undefined
10:29:43 <jmcarthur> the reason is that it constrains my implementation more and i'm more likely to write correct code that way
10:29:47 * djahandarie kicks lambdabot
10:29:49 <djahandarie> > map head . group . sort $ [6,2,3,4,1,8,4,3,4,3,3,2,1,4,5,3,2,1,7,8,6,4,5,3,9]
10:29:53 <jmcarthur> the fact that it's more useful is actually just a byproduct of that
10:29:54 <lambdabot>   mueval: ExitFailure 1
10:29:54 <lambdabot>  mueval: Prelude.undefined
10:30:01 <newbie_Yosemite> Thanks Saizan!
10:30:11 <dwcook> jmcarthur, same here, but what I meant before was that if I have to use a more general *implementation*, I generally will avoid doing it if it's not immediately necessary
10:30:42 <jmcarthur> you mean things like map vs. fmap?
10:30:48 <dwcook> Yeah
10:30:59 <newbie_Yosemite> and thanks Monoidal
10:31:00 <dwcook> It might not be obvious how my program generalizes to functors as opposed to just lists
10:31:08 <jmcarthur> if i am required to use lists due to some other part of the function i might just use map, but if it can have an affect on the type i will use fmap, every time
10:31:16 <dwcook> Good point
10:31:27 <cschneid> jmcarthur: most generic type possible meaning "[a] -> [(a,b)]" or whatever if you can, rather than [String] -> [(Char, String)]?
10:31:57 <jmcarthur> cschneid: or even further, if possible, e.g.:   Functor f => f a -> f (a, b)
10:32:24 <jmcarthur> cschneid: it's harder to screw up the implementation that way
10:32:36 <cschneid> jmcarthur: hmm, interesting. I need to get better at reasoning about things like that. It's one step away from the "shape" of the data, which hasn't clicked with me yet
10:33:05 <cschneid> jmcarthur: so you lean on the type system to help you out, which presumably lowers the need for testing, and avoids certain classes of bugs?
10:33:06 <tero-> that kind of generality makes sense. I was thinking over-engineering for features that might be needed
10:33:07 <jmcarthur> cschneid: for example, if i know that the input elements are strings that allows me to do stuff like take the head to generate the Char in the result, but if my function has to work with any type then i can't do that
10:33:47 <jmcarthur> cschneid: also, the type you generalized that to i know has very few implementations
10:34:08 <jmcarthur> cschneid: it can basically only be:   const []
10:34:15 <jmcarthur> cschneid: unless you allow undefined in the result
10:34:27 <cschneid> jmcarthur: well, I just made it up without thinking, but yeah.
10:34:31 <jmcarthur> cschneid: my further generalization is impossible without undefined
10:34:44 <jmcarthur> cschneid: no this is a point i'm trying to make. the more general types are easier to reason about
10:34:55 <jmcarthur> cschneid: it's harder to tell from a more specific type whether it even makes sense
10:34:57 <dwcook> let f :: a -> b; f _ = undefined -- :)
10:35:25 <jmcarthur> cschneid: let alone with it's supposed to do, assuming it does make sense
10:35:29 <jmcarthur> *what it's supposed
10:35:55 <monochrom> more general type => less leeway (error) in code
10:35:58 <tero-> error works, too :)
10:36:14 <cschneid> jmcarthur: ok. I need to go reread sections of books on functor and friends I think. I like that generalizing to the point any impl becomes mostly-or-completely clear.
10:36:47 <jmcarthur> it's just the way any contract works. the more i promise, the more i'm constrained
10:36:47 <cschneid> any time you turn coding from cleverness to machine-assisted-clear-steps you remove opportunities for bugs.
10:37:29 <cschneid> it is so different than doing programming in ruby, where without contracts, you write what you want, then wrap tests around it to prove the boundaries that it works
10:38:53 <monochrom> a combination of type and testing is particularly powerful
10:40:07 <Garyuutensei> @type map
10:40:15 <jmcarthur> cschneid: in a dependently typed language you can even write your tests in your types. and they can be very general (that is, they can actually be proofs rather than tests)
10:40:19 <lambdabot> (a -> b) -> [a] -> [b]
10:40:25 <monochrom> suppose I give you f::[a]->Maybe a. that type still allows many possibilities. but suppose you do one test: f [1,2,3] = Just 2. then you don't need to test f ['a','b','c']. you already know it's Just 'b'
10:40:29 <tero-> I wonder if all specifications could be expressed with a powerful type system rendering testing useless
10:40:43 <Garyuutensei> @pl (\x y -> fromIntegral x / y)
10:40:43 <lambdabot> (/) . fromIntegral
10:40:56 <cschneid> tero-: isn't that the basis of proof languages?
10:41:06 <elliott> tero-: you can express any property of a function with dependent types. but then you have to supply a proof
10:41:09 <elliott> testing is much easier
10:41:58 <jmcarthur> the fact that proofs are harder to write than tests always makes me sad
10:42:56 <tero-> question rephrased: could proof assistants be made smart enough to provide proofs for most real-world program properties
10:43:03 <Saizan> jmcarthur: there's no free lunch (only theorems!)
10:43:42 <jmcarthur> tero-: if they could do that they could just write the code for us
10:43:49 <Saizan> tero-: with domain specific tactics they might be, ur/web is supposedly an exaple of that
10:44:22 <dwcook> There's nothing fundamental stopping it, right? We just haven't got there?
10:44:39 <dwcook> I mean, a sufficiently complex machine could do anything a human can do.
10:44:46 <lispy_> It's undecidable isn't it?
10:45:04 <dwcook> Well, things like halting are. But not every property about a program.
10:45:09 <jmcarthur> dwcook: sure, but there are probably programs that humans can't realistically write either
10:45:45 <jmcarthur> s/are probably/might be/
10:45:48 <hpc> i trust computers to write programs more than i trust humans :P
10:46:00 <dwcook> That's what compilers are for \o/
10:46:01 <monochrom> tero-: the answer is yes, and the field "formal methods" is working on it.
10:46:06 <Saizan> the problems start to arise when you can't tell if proof search is taking long or the typechecker went into a loop :)
10:46:12 <klrr_> what's a rigid type variable?
10:46:14 <klrr_> GeDaMo: i used ":: Parser a -> String -> Foobar" in my type signature, and it that a is rigid or sth
10:46:36 <hpc> klrr_: can you paste the whole section of code?
10:46:38 <hpc> @where hpaste
10:46:38 <lambdabot> http://hpaste.org/
10:46:39 <jmcarthur> > () :: a
10:46:44 <lambdabot>   mueval: ExitFailure 1
10:46:45 <lambdabot>  mueval: Prelude.undefined
10:46:50 <jmcarthur> not what i expected
10:46:57 <hpc> it's what i expected
10:46:59 <Botje_> klrr_: very probably it means you're assuming that Parser a returns something more definite than just a.
10:47:00 <hpc> it's been doing that all morning
10:47:02 <jmcarthur> ah
10:47:14 <dwcook> klrr_, probably a is too general a type based on the function's definition
10:47:31 <lispy> Cale: I think lambdabot needs a reboot.
10:47:36 <lispy> > 1
10:47:41 <lambdabot>   mueval: ExitFailure 1
10:47:41 <lambdabot>  mueval: Prelude.undefined
10:47:59 <klrr_> hpc: Botje_ dwcook http://hpaste.org/87738
10:48:09 <dwcook> Well, now we can prove whether lambdabot's computations will halt with a value. The answer is no
10:48:12 <dwcook> :P
10:51:06 <Botje_> klrr_: exactly what I thought.
10:51:12 <Botje_> klrr_: you say that parser :: Parser a
10:51:13 <Saizan> klrr_: anyhow to directly answer your question: a rigid type variable is one that is only equal to itself, and yeah 'a' there is rigid because the type signature of reader promises the function works for all 'a'
10:51:33 <Botje_> klrr_: you then execute the parser, and if it returns Right y, you write return y
10:51:47 <Botje_> so you'd expect your return type to be ErrorOr a
10:52:01 <Botje_> klrr_: except you said the return type of reader is ErrorOr Expr.
10:52:17 <Botje_> klrr_: which is clearly an error if I would pass in a Parser Int, for example.
10:53:34 <tero-> but then again, even with a proof assistant oracle, specifications would be vefy laborious and equally prone to errors as code
10:54:30 <mekeor> isn't there is a way to make ghc(i) say me the type of a function which I didn't implement yet (using question marks?)?
10:54:56 <coppro> mekeor: just define it to undefined
10:54:59 <hpc> mekeor: give it "undefined"
10:55:39 <mekeor> hpc, coppro: that's what i do but then? i want the type signature!
10:55:59 <monochrom> code is laborous. specification is laborous. but what is the alternative?
10:56:01 <elliott> you can say ?foo
10:56:06 <elliott> with ImplicitParams
10:56:11 <elliott> and get an appropriate error
10:56:14 <mekeor> yeah, that's what i was looking for :)
10:56:20 <mekeor> thanks, elliott :)
10:56:26 <monochrom> one alternative is to have no code. not writing code is easy. but nothing gets done.
10:57:07 <mekeor> hpc, coppro: :P ↑
10:57:08 <tero-> computer writes the specifications, too
10:57:10 <monochrom> another alternative is to have code but no specification. which is the status now. but then you have the question "is it a bug or a feature?" (a specification settles that)
10:58:13 <hpc> pppsh, specifications are for customers
10:58:24 <hpc> just make a perfectly generic rules engine and let them write their own programs!
10:58:37 <Fuuzetsu-> Like a compiler?
10:58:52 <tero-> so it seems that tests will be around..
10:59:26 <Fuuzetsu-> > 1
10:59:31 <lambdabot>   mueval: ExitFailure 1
10:59:31 <lambdabot>  mueval: Prelude.undefined
10:59:57 <monochrom> even when I write specifications, I will certainly test them, yes
11:00:12 <tero-> combining symbolic execution with concrete tests might be interesting in Haskell
11:00:43 <coppro> mekeor: you can't really get it
11:00:50 <tero-> it has been done for C at least
11:01:15 <coppro> mekeor: because you either need to tell Haskell what you want the type signature to be, or give it some way to guess what the signature is
11:01:27 <coppro> :t undefined
11:01:37 <lambdabot> a
11:01:47 <coppro> so Haskell just sees that and says "it type-checks!"
11:02:44 <jmcarthur> :t ?foo ++ "bar"
11:02:48 <mekeor> coppro: ImplicitParams does what i do. it gives me the most precise type signature inferred from the applications of the function.
11:02:52 <lambdabot> (?foo::[Char]) => [Char]
11:03:01 <jmcarthur> ^^ "the type of foo is [Char]"
11:03:29 <jmcarthur> we have holes coming soon in ghc, too
11:03:29 <mekeor> s/what i do/what i want/ :)
11:03:42 <mekeor> jmcarthur: what are holes? O.o
11:04:14 * mekeor reads http://hackage.haskell.org/trac/ghc/wiki/Holes
11:04:22 <jmcarthur> mekeor: basically a way to explicitly tell ghc "this is a place i haven't implemented yet" and it can give you a bunch of information about it
11:04:26 <monochrom> holes are omissions in types you write, the compiler figures them out
11:04:28 <elliott> unfortunately ghc's holes are not as good as implicitparams, last I tried them
11:04:40 <jmcarthur> elliott: in what way?
11:04:46 <arkeet> I would like holes in types.
11:04:52 <elliott> I forget. I think the error messages for implicitparams was better.
11:04:53 <hpaste_> giogadi pasted “sim loop” at http://hpaste.org/87740
11:05:22 <mekeor> jmcarthur: neat
11:05:35 <hpaste_> giogadi revised “sim loop”: “sim loop” at http://hpaste.org/87740
11:05:36 <hpaste_> giogadi revised “sim loop”: “sim loop” at http://hpaste.org/87740
11:06:07 <monochrom> my types are holer than yours :)
11:07:50 <chrisdone> DAS COMPILERMASCHINE IST NICHT FÜR DER HOLENPOKEN UNT MITTENGRABEN
11:08:07 <mekeor> ?
11:08:14 <monochrom> haha
11:08:44 <natnayr> hi, i need to output a null, like an empty where True = (), otherwise = _
11:08:53 <natnayr> what is a null character in haskell?
11:09:18 <monochrom> mekeor: it's a reference to http://en.wikipedia.org/wiki/Blinkenlights
11:09:33 <Rotaerk> natnayr, https://www.google.com/search?q=null+character+haskell&aq=f&oq=null+character+haskell&aqs=chrome.0.57j62l3.2337j0&sourceid=chrome&ie=UTF-8
11:12:08 <natnayr> Rotaerk: heys, its not what im looking for
11:12:37 <mekeor> natnayr: i don't understand what you wanna do.
11:13:01 <natnayr> so im building a list of items, if the first item is True then it gives [()], else it gives []
11:13:02 <mekeor> natnayr: maybe you are looking for "Maybe"?
11:13:18 <natnayr> mekeor: nope, it cant be a maybe datatype
11:13:23 <arkeet> > guard True :: [()]
11:13:36 <monochrom> lambdabot is not well
11:13:38 <arkeet> oh
11:13:44 <monochrom> but the answer is []
11:13:47 <arkeet> well that would be [()], and guard False is []
11:13:51 <natnayr> yes
11:14:04 <mekeor> natnayr: f (True:_) = [()]; f _ = [] -- ?
11:14:08 <monochrom> so, problem solved
11:14:21 <arkeet> f x = guard (head x)
11:14:38 <natnayr> ummm.. i'm using the helper function
11:14:48 <arkeet> woohoo netsplit
11:14:59 <natnayr> what happened?
11:15:05 <natnayr> overloaded?
11:15:10 <mekeor> apocalypse..
11:15:11 <Sculptor> comeone pressed an emergency button
11:15:25 <natnayr> ok
11:15:40 <natnayr> glad thats over, lambdabot not well, and now this
11:15:55 <natnayr> so umm, im using a helper function to build my list
11:15:56 <mekeor> natnayr: it sometimes happens. (<http://en.wikipedia.org/wiki/Netsplit>)
11:16:08 * mekeor listens to natnayr.
11:16:39 <natnayr> it has to give True = () and False = (some empty value here)
11:17:01 <monochrom> that cannot be done
11:17:35 <mekeor> i think you are either looking for Either or maybe Maybe.
11:17:39 <lispy> ?djinn Bool -> Void
11:17:44 <monochrom> not all problems can be solved
11:17:52 <natnayr> monochrome: otherwise haskell will be broken? impure and not strong type
11:18:05 <natnayr> okok, i'll build the list iteratively..
11:18:13 <elliott> what is the helper function you are using?
11:31:22 --- mode: adams.freenode.net set +o ChanServ
11:37:38 <chrisdone> woah
11:37:54 <chrisdone> cabal init now does some clever figuring out what stuff i'm already using?
11:38:12 <chrisdone> i had some .hs file using hse and did cabal init and got
11:38:13 <chrisdone>   build-depends:     base ==4.5.*, haskell-src-exts ==1.13.*
11:38:22 <chrisdone> (●´∀｀●) it's beautiful …
11:42:48 <neothemachine> hey, does anyone know how the expression [42 | i == j] is desugared? I'm just experimenting and couldn't find the equivalent do-notation code
11:43:15 <dcoutts__> neothemachine: the Haskell report explains is quite clearly
11:43:17 <elliott> @undo [42 | i == j]
11:43:17 <lambdabot> if i == j then [42] else []
11:43:31 <neothemachine> oh well, ok, so it's a special case
11:43:32 <elliott> equivalent to do { guard (i == j); return 42 }
11:43:40 <elliott> the special case doesn't involve (==)
11:44:29 <neothemachine> I actually tried it with guard but got an ambiguous type variable error
11:44:35 <dcoutts__> neothemachine: I hadn't realised this corner case until a few years ago, but actually I find it's rather useful
11:45:02 <monoidal> :t do { guard (i == j); return 42; }
11:45:05 <jmcarthur> that's because it's more general than lists
11:45:09 <lambdabot> (Num b, MonadPlus m) => m b
11:45:27 <dcoutts__> neothemachine: that's not because it's wrong, just that you can't evaluate it until you decide which monad
11:45:51 <monoidal> jmcarthur: more general than lists?
11:47:12 <tero-> Saizan: I hadn't heard of ur/web. the goals seem similar to those of Yesod and Happstack (and other Haskell web frameworks)
11:47:15 <neothemachine> so, does [42 | 1 == 2] have an equivalent in do-notation or is it because of the special case that it's just if.. else
11:47:38 <dcoutts__> neothemachine: elliott already said:  do { guard (i == j); return 42 }
11:48:38 <monochrom> turn on {-# LANGUAGE MonadComprehensions #-}. then [42 | i==j] is general too :)
11:48:39 <elliott> in fact you can rewrite [e | ..., bool, ...] as [e | ..., () <- guard bool; ...]
11:48:52 <arkeet> guard (1 == 2) >> return 42
11:48:52 <arkeet> yeah
11:48:56 <arkeet> oh do notation
11:49:15 <arkeet> same thing
11:49:31 <arkeet> > guard (1 == 2) >> return 42
11:49:32 <neothemachine> No instance for (GHC.Show.Show (m0 b0)) says tryhaskell.org, what was the command of lambdabot again to run code?
11:49:36 <lambdabot>   mueval: ExitFailure 1
11:49:36 <lambdabot>  mueval: Prelude.undefined
11:49:38 <arkeet> > guard (1 == 2) >> return 42 :: [Int]
11:49:43 <lambdabot>   mueval: ExitFailure 1
11:49:43 <lambdabot>  mueval: Prelude.undefined
11:49:45 <arkeet> lol
11:49:54 <arkeet> neothemachine: you have to tell it which monad to use
11:50:09 --- mode: adams.freenode.net set +o ChanServ
11:52:03 <neothemachine> ok got it
11:52:05 <neothemachine> thanks! :)
12:01:49 <ded> I want to write a very simple web server as a beginner's exercise. What should I use for the HTTP server?
12:03:23 <ded> It doesn't need to handle high traffic, I don't want it to run behind apache. I basically just want to run a development server from the command line.
12:03:56 <ded> I just need to be able to define a couple of routes and return a JSON response. Don't think I even need auth.
12:03:58 <elliott> well, yesod, snap and happstack all have integrated "dev server" things, I think"
12:04:05 <elliott> s/"$//
12:04:13 <elliott> and they can all do that :P
12:04:15 <Nisstyre> Yesod is kind of overkill though
12:04:16 <lambdabot> Nisstyre: You have 1 new message. '/msg lambdabot @messages' to read it.
12:04:29 <luite> ded: scotty is pretty simple
12:04:32 <elliott> warp, snap-server and happstack-server are the underlying HTTP servers, I think, if you really want to roll your own routing and stuff
12:04:37 <elliott> scotty uses warp right?
12:04:39 <luite> built on wai and warp
12:04:40 <ded> This is mainly a beginners exercise -- I'm learning
12:04:40 <luite> yeah
12:04:42 <joe9> what is a good library to represent on/off values on a 2-dimensional array? there seems to be a bunch of choices.
12:04:45 <ded> have hardly written and haskell.
12:04:55 <Nisstyre> ded: avoid Yesod then
12:04:59 <ded> ok
12:05:00 <luite> so it's also pretty fast, and you don't need to learn conduits and wai immediately
12:06:29 <sm> ded: scotty is the simplest
12:06:55 <ded> ok thanks all, I'll look at scotty first and the others, and avoid yesod for now
12:07:28 <luite> yesod works if you like to follow the examples without fully understanding them
12:07:44 <Entroacceptor> ded: want to chip in to my mpd frontend written with happstack?
12:07:46 <luite> if you want to understand everything, yeah then it's not a great choice :)
12:08:03 <Nisstyre> Entroacceptor: you're writing an MPD thing too?
12:08:26 <Entroacceptor> Nisstyre: I tried to find a web frontend for my raspi, but none worked as I'd like it
12:08:38 <Entroacceptor> but I'm always open to try another one..
12:08:44 <Nisstyre> Entroacceptor: is it basically a frontend to the MPD library on hackage?
12:08:49 <Entroacceptor> yeah
12:08:55 <Entroacceptor> basically just converts the reply to json
12:08:56 <Nisstyre> yeah I'm doing something different
12:09:02 <Entroacceptor> what are you doing?
12:09:18 <Nisstyre> it's going to track what you listen to and then construct new playlists based on that
12:09:22 <Entroacceptor> nice
12:09:25 <Nisstyre> using a markov model
12:09:29 <stavrosh1> Entroacceptor: have you installed ghc on rapsi?
12:09:33 <aranea> How to apply a function to the second element of a tuple, leaving the first one untouched? (b -> c) -> (a, b) -> (a, c)
12:09:33 <lambdabot> aranea: You have 1 new message. '/msg lambdabot @messages' to read it.
12:09:40 <stavrosh1> raspi *
12:09:41 <cmccann> :t first
12:09:46 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
12:09:48 <Entroacceptor> stavrosh1: not yet, I was trying to setup cross compiling first
12:09:52 <Nisstyre> Entroacceptor: it's requiring me to write a parser for the mpd database
12:09:54 <Nisstyre> which is a pain
12:09:59 <Nisstyre> since there's no spec anywhere
12:10:02 <Entroacceptor> but that howto I found seems to be too old
12:10:16 <cmccann> > first (+ 1) (2,5)
12:10:21 <lambdabot>   mueval: ExitFailure 1
12:10:22 <lambdabot>  mueval: Prelude.undefined
12:10:24 <Entroacceptor> Nisstyre: why don't you write it as an auxillary client?
12:10:26 <cmccann> > first (+ 1) (2,5)
12:10:32 <lambdabot>   mueval: ExitFailure 1
12:10:32 <lambdabot>  mueval: Prelude.undefined
12:10:35 <Entroacceptor> don't access the db directly :(
12:10:40 <Nisstyre> Entroacceptor: it sort of is, but I also want to store everything in a database
12:10:43 <aranea> thanks, I already though it had something to do with arrows
12:10:46 <Nisstyre> so I want to be able to clone the mpd database
12:10:53 <Nisstyre> and put it in JSON format in couchdb
12:10:56 <aranea> never used them before, so I couldn't work it out
12:10:59 <Nisstyre> I already have most of that done
12:11:02 <cmccann> aranea: don't worry about arrows
12:11:03 <aranea> I tried something with ^<<
12:11:15 <cmccann> the only arrow you need to worry about is (->) here
12:11:34 <cmccann> unfortunately lambdabot is being recalcitrant today so I can't demonstrate :[
12:11:40 <aranea> aww
12:12:03 <aranea> thanks, cmccann
12:12:18 <elliott> cmccann: lambdabot is recalcitrant because you're using words like "recalcitrant".
12:12:30 <Nisstyre> put down the thesaurus
12:12:31 <cmccann> elliott: you're recalcitrant.
12:12:36 <cmccann> it's a fine word.
12:12:42 <cmccann> I don't even own a thesaurus.
12:12:48 <aranea> simplifies my code a lot :)
12:13:02 <elliott> cmccann: that's because you gave away all your totally legit moneys.
12:13:07 <cmccann> yes :[
12:13:21 <cmccann> elliott: oh, you've seen vinyl, right?
12:13:24 <elliott> cmccann: if you figure out your language thing I'll give you some back.
12:13:27 <aranea> (I'm implementing the D'Hondt election method)
12:13:28 <elliott> yes.
12:13:37 <cmccann> I hacked it to support sum types. it is now even scarier.
12:13:38 <elliott> I don't think hacking this sort of stuff into Haskell is a good idea. it's too noisy
12:13:58 <cmccann> I'm undecided whether it's worthwhile or not.
12:14:40 <typoclass> cmccann: you mean you're indecisitrant
12:14:58 <joe9> any thoughts on a haskell 2-dimensional array to store on/off values, please?
12:15:13 <elliott> fixRecord :: (forall f. Applicative f => Rec rs f) -> PlainRec rs
12:15:15 <elliott> what a pointless function.
12:16:19 <joe9> repa seems complicated.
12:16:54 <augustss> yo
12:17:18 <BMeph> joe9: My thought: whichever one works.
12:18:05 <cmccann> augustss: nice to see you on IRC more regularly these days :D
12:18:27 <augustss> It's because I'm on vacation. :)
12:18:33 <typoclass> joe9: a list of lists with Bools in them? i'd try the simplest thing you can get away with. if you run into problems, you can always switch to something more complicated
12:19:03 <BMeph> augustss: Howdy! Say, have you given any thought to Cayenne, lately? :)
12:19:59 <augustss> BMeph: None, really.  :)  The world is still catching up.
12:20:00 <stavrosh1> guys, is there a book like SICP in Haskell?
12:20:15 <augustss> stavrosh1: I wish there were!
12:20:22 <Nisstyre> stavrosh1: depends what you mean by "like"
12:20:28 <Nisstyre> there's no exact clone
12:20:46 <Nisstyre> I don't know of any books that teach the same concepts all in one book for Haskell though
12:20:50 <BMeph> augustss: Be Careful what you wish for...someone may want YOU to fulfill it! ;)
12:20:51 <cmccann> stavrosh1: you should ask shachaf. he knows someone who claims they're going to write a book like that eventually.
12:20:57 <joe9> typoclass: BMeph : thanks
12:21:11 <elliott> structure and interpretation of cmccann
12:21:22 <elliott> 's psomething.
12:21:30 <cmccann> procrastination?
12:21:37 <Nisstyre> cmccann: personally I don't see the point of doing that, unless they do it in such a way that it's actually more useful.
12:21:37 <stavrosh1> Nisstyre: i don't want an exact clone :D i just loved that book though
12:21:42 <BMeph> pulchritude! ;p
12:21:43 <Nisstyre> imo clone PLAI instead
12:21:55 <Nisstyre> PLAI actually explains unification and type inference
12:22:00 <monochrom> SICP is too long
12:22:00 <augustss> The great thing about SICP (for me) is that it's full of little extra tidbits even if you know all of the subject matter.
12:23:02 <monochrom> PLAI is probably a whole different subject
12:23:11 <Nisstyre> monochrom: it's a subset of SICP, the PLT subset
12:24:06 <Nisstyre> it would be nice if you took some aspects of both SICP and PLAI and put them in a book
12:24:27 <cmccann> augustss: I spent better part of an afternoon figuring out how to do church numeral subtraction because of an exercise in SICP. it was fun.
12:24:52 <madjestic> can 2 different type signatures have the same (function) name via some language rules? E.g.: foo :: a -> a; foo :: a -> a -> a
12:25:22 <Nisstyre> madjestic: yes, you can do that with type classes
12:25:24 <typoclass> madjestic: do you mean typeclasses?
12:25:43 <augustss> cmccann: And I learnt why my prime number program actually terminates.  (Because for every prime p there is a prime between p and p^2)
12:25:56 <typoclass> madjestic: you'd use one typeclass, and two instances. one for "a -> a", one for "a -> a -> a"
12:26:37 <Nisstyre> I think it requires FlexibleInstances
12:29:10 <madjestic> typoclass: does it actually allow different number of arguments per instance?  I thought that only parameter types may vary, not the number of parameters.  Likely I am wrong.  I'll look further
12:29:33 <aranea> I've got a list like [0,1,2,0,1,1] (only numbers from 0 to 2 allowed) and I want to count the occurences of the individual numbers, in this example [2,3,1]. How to do that? My current solution is a fold, is there a shorter way?
12:29:59 <madjestic> Nisstyre: that may be it.
12:30:32 <Fuuzetsu-> aranea: Shorter than a single-line fold? Probably not.
12:30:39 <monochrom> I would fold too
12:30:51 <typoclass> aranea: 'sort', then 'group' and 'length'?
12:30:51 <Nisstyre> madjestic: a good exercise is to implement variadic functions using the same sort of idea
12:31:30 <augustss> madjestic: Something like what you want can certainly be done.
12:32:10 <aranea> Fuuzetsu-: the problem with my current fold is that it hard-codes the allowed number range
12:32:14 <typoclass> aranea: i tried this in ghci and it gave [2,3,1]: let count = map length . group . sort in count [0,1,2,0,1,1]
12:32:39 <aranea> great, thanks, typoclass
12:32:51 <aranea> I didn't know group
12:32:54 <stavrosh1> aranea: there's an example in "learn you a haskell" as far as i remember
12:33:05 <monoidal> aranea: for [1,1] do you want just [2] or [0,2]?
12:33:18 <aranea> monoidal: the latter
12:33:23 <aranea> aww
12:33:33 <tromp> :t toList
12:33:36 <aranea> you're right, that's a problem
12:33:38 <lambdabot>     Not in scope: `toList'
12:33:38 <lambdabot>     Perhaps you meant one of these:
12:33:39 <lambdabot>       `Data.Foldable.toList' (imported from Data.Foldable),
12:33:39 <typoclass> aranea: monoidal is right, my thing is sloppy in that regard. but it's fixable
12:34:25 <aranea> Hmm. I could do ++ [0,1,2] and then map (-1) over the result
12:34:32 <Fuuzetsu-> as a hack, you could append [1 .. max] and then -1 over the res
12:34:34 <monoidal> aranea: you can use a monoid
12:34:37 <Fuuzetsu-> …~
12:34:43 <typoclass> aranea: urgh, that sounds a bit kludgy :-)
12:35:06 <tromp> > accumArray (+!) . zpWith [0,1,2,0,1,1] repeat 1
12:35:11 <lambdabot>   mueval: ExitFailure 1
12:35:11 <lambdabot>  mueval: Prelude.undefined
12:35:13 <monoidal> aranea: define f 0 = (Sum 1, Sum 0, Sum 0), f 1 = (Sum 0, Sum 1, Sum 0), f 2 = (Sum 0, Sum 0, Sum 1) and then your function is concat . map f
12:35:21 <monoidal> * mconcat . map f
12:35:29 <tromp> > accumArray (+) . zpWith [0,1,2,0,1,1] repeat 1
12:35:34 <lambdabot>   mueval: ExitFailure 1
12:35:34 <lambdabot>  mueval: Prelude.undefined
12:35:44 <monoidal> only it gives a tuple, but that's minor
12:36:20 <typoclass> aranea: here is a modification that gives [(0,2),(1,3),(2,1)], telling you what element and how often. -- let count = map (head &&& length) . group . sort in count [0,1,2,0,1,1]
12:37:28 <monoidal> > let f 0 = (Sum 1, Sum 0, Sum 0); f 1 = (Sum 0, Sum 1, Sum 0); f 2 = (Sum 0, Sum 0, Sum 1) in mconcat $ map f [0,2]
12:37:33 <lambdabot>   mueval: ExitFailure 1
12:37:33 <lambdabot>  mueval: Prelude.undefined
12:37:46 <aranea> monoidal: I can't use your approach in that form because I need the number range to be dynamic
12:37:47 <typoclass> monoidal: she's on the fritz
12:38:20 <ded> How should I install scotty? I initially tried cabal but it told me it was likely to break a posix-regex and haskell-platform. So now I'm trying `runhaskell Setup configure` which gives me a list of missing dependencies. I used cabal to install some of those dependencies, but configure still says they are missing. (does manual installation not know about packages installed by cabal?)
12:38:24 * hackagebot type-equality 0.1.2 - Type equality, coercion/cast and other operations.  http://hackage.haskell.org/package/type-equality-0.1.2 (ErikHesselink)
12:38:34 <aranea> the lower bound is always 0, but the upper bound is input-dependant
12:39:52 <madjestic> typoclass: how does a definition for a multivariadic type class can look like, for a class, instances of which may have 1 or more type parameters?
12:40:40 <madjestic> typoclass: that is I am familiar with a definition of a type class, instances of which have the same number of parameters
12:41:32 <Nisstyre> madjestic: your type class has one parameter
12:41:38 <monoidal> madjestic: in this case I would create an array or map and just fold
12:41:42 <aranea> tromp: something's not right with your accumArray thingy
12:41:44 <Fuuzetsu-> aranea: how about folding with a ‘\acc x -> replace x (1 + (acc !! x)) acc’ with initial accumulator of replicate maxRange 0
12:42:02 <Nisstyre> madjestic: the types that you are instantiating that class with may have more than one parameter
12:42:04 <aranea> I suspect you meant zipWith, but there's no zip function there
12:42:11 <tromp> yes, but lambdabot not very helpful pinpointing the prob
12:42:25 <tromp> > accumArray (+) . zipWith [0,1,2,0,1,1] repeat 1
12:42:30 <lambdabot>   mueval: ExitFailure 1
12:42:30 <lambdabot>  mueval: Prelude.undefined
12:42:35 <Nisstyre> madjestic: you can have multi parameter type classes, but you don't need them for what you want
12:42:41 <Fuuzetsu-> lambdabot is broken at the moment
12:42:42 <Fuuzetsu-> > 1
12:42:47 <lambdabot>   mueval: ExitFailure 1
12:42:47 <lambdabot>  mueval: Prelude.undefined
12:42:53 <monoidal> tromp: "zipWith []" is a type error.
12:42:54 <typoclass> tromp: she's had a few whiskies
12:42:55 <tromp> i'd also have to convert Arra yback to list
12:43:05 <tromp> > accumArray (+) . zip [0,1,2,0,1,1] repeat 1
12:43:10 <lambdabot>   mueval: ExitFailure 1
12:43:10 <lambdabot>  mueval: Prelude.undefined
12:43:23 <tromp> > accumArray (+) . zip [0,1,2,0,1,1] $ repeat 1
12:43:28 <lambdabot>   mueval: ExitFailure 1
12:43:28 <lambdabot>  mueval: Prelude.undefined
12:43:31 <Fuuzetsu-> :t accumArray
12:43:35 <lambdabot> Ix i => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
12:43:55 <tromp> > accumArray (+) 0 (0,2) . zip [0,1,2,0,1,1] $ repeat 1
12:44:00 <lambdabot>   array (0,2) [(0,2),(1,3),(2,1)]
12:44:02 <mm_freak> > runST (return ())
12:44:07 <lambdabot>   mueval: ExitFailure 1
12:44:07 <lambdabot>  mueval: Prelude.undefined
12:44:10 <madjestic> Nisstyre: thanks
12:44:13 <mm_freak> > runST (return ())
12:44:18 <lambdabot>   mueval: ExitFailure 1
12:44:18 <lambdabot>  mueval: Prelude.undefined
12:44:56 <Nisstyre> madjestic: the type parameter a can be instantiated with a -> a or a -> a -> a
12:44:58 <Nisstyre> and so on
12:44:59 <typoclass> madjestic: hm ... hang on
12:45:09 <ctrl> > 1
12:45:15 <lambdabot>   mueval: ExitFailure 1
12:45:15 <lambdabot>  mueval: Prelude.undefined
12:45:21 <ctrl> what the
12:45:23 <ctrl> ahahah
12:45:43 <Nisstyre> lambdabot forgot what numbers are
12:46:01 <ctrl> That's cute.
12:46:26 <Nisstyre> s/parameter/variable/
12:47:40 <typoclass> i has teh dumb. i cant haskell todays
12:48:12 <aranea>  oops, typoclass, looks like I missed your [(0,2),(1,3),(2,1)] solution
12:48:20 <aranea> that's actually great
12:48:35 <typoclass> aranea: you're welcome =)
12:50:14 <typoclass> i have the dumb. this solution to madjestic's question is not working http://hpaste.org/87744 (error message included)
12:52:01 <coppro> :t print
12:52:03 <monochrom> I would explicitly print (foo "" :: Int -> String) or print (foo "" :: String)
12:52:05 <lambdabot> Show a => a -> IO ()
12:52:22 <madjestic> typoclass: yes, that's kind of what I am looking for
12:52:41 <coppro> typoclass: it can't infer String in the first example
12:52:58 <coppro> or the second, I think
12:55:51 <hpaste_> hseg pasted “Getting radically different parses from two seemingly identical parsers” at http://hpaste.org/87745
12:55:59 <Taneb> Is ListT (State s) a monad or is a stupid not-monad
12:57:06 <elliott> State isn't a commutative monad, unless I'm seriously confused
12:57:15 <monoidal> Taneb: it is not a monad.
12:57:31 <Taneb> Okay, thank you
12:57:59 <typoclass> monochrom: hm good point! ((foo "") :: String) works
12:59:00 <monochrom> because when the computer sees foo"", it thinks foo::String->???, and nothing says ??? should be String or Int->String or Void.
12:59:17 <monoidal> quick poll: ghci -XDatatypeContexts gives "-XDatatypeContexts is deprecated: It was widely considered a misfeature, and has been removed from the Haskell language." Should the same hold for -XNPlusKPatterns? I think the message describes them too.
13:01:20 <monochrom> yes
13:01:33 <hseg> I have no idea why swapping the order of the parsers causes the global parser to fail.
13:01:37 <typoclass> monoidal: you mean they want to remove the extension as well? not only turn off by default
13:01:52 <Nisstyre> typoclass: wow I managed to cause GHC to panic while messing around with the same idea
13:01:59 <monoidal> typoclass: I don't know if they want to remove it. I want to add a warning message like the one for DatatypeContexts.
13:01:59 <Nisstyre> well, ideone's version of GHC
13:02:03 <monochrom> parsers are clearly not meant to swap orders
13:02:07 <typoclass> Nisstyre: oh. excellent :-/
13:02:23 <Nisstyre> typoclass: http://ideone.com/CGOOIg
13:02:27 <hseg> I'm trying to parse (identifier '.')? identifier, where there may be any amount of spaces between the two identifiers and the period.
13:02:28 <geekosaur> I think there's one clear difference: NPlusKPatterns does what it appears to
13:02:44 <monoidal> Nisstyre: "instance ([String] -> String)" is enough
13:02:45 <geekosaur> DatatypeContexts looks like it does something different from what it actually does
13:03:02 <typoclass> Nisstyre: oh great :-)
13:03:15 <Nisstyre> obviously my code is incorrect, but still, wow
13:03:15 <typoclass> Nisstyre: (problem is missing "Foo" in line 9. just to be sure)
13:03:30 <Nisstyre> yeah
13:03:39 <monoidal> it's fixed in 7.6. one of the more commonly found bugs.
13:03:50 <typoclass> Nisstyre: i recall that certain ghc versions will panic if you forget the "=>" in "instance Something => Something where". could even be related
13:03:57 <hseg> monochrom, while in general parsers are non-commutative, in this case the order swapping plus the slight modifications I added should have allowed it to parse.
13:04:42 <monoidal> geekosaur: I agree with you, but do you think the difference is enough not to actively discourage n+k? (I want to file a patch.)
13:05:37 <geekosaur> I do, just because there's less interest in n+k patterns as a result. datatype contexts are actively misleading, so need the extra hint
13:05:44 <typoclass> hseg: i tend to agree that it's weird!
13:05:54 <monoidal> geekosaur: (note that like DatatypeContexts also has crazy cases, like (n+5) = ... vs n+5 = ...)
13:06:09 <hpaste_> hseg revised “Getting radically different parses from two seemingly identical parsers”: “Slightly correcter way to write this” at http://hpaste.org/87745
13:07:19 <monoidal> geekosaur: I don't completely understand; by "I do" you mean that you agree with me to add the warning or not?
13:07:45 <geekosaur> you clearly want that warning, so go ahead and add it. I just don't think it's really necessary
13:07:51 <monoidal> ok.
13:08:28 <typoclass> hseg: optionMaybe is documented as "tries to apply the parser; if it fails without consuming input, it returns Nothing, otherwise it returns Just the value returned by p."
13:08:58 <hseg> Possible explanation: Since (optionMaybe p) only works if p fails w/o consuming input, and in the second case it parses the identifier first, it will have consumed input, and therefore will fail.
13:09:21 <hseg> Pity. Means I'll have to left-factor my grammar.
13:09:58 <typoclass> hseg: yes. in line 5, "identifier jackStyle" consumes input, so optionMaybe won't give you Nothing anymore, it will definitely give you Just or die trying. then "dot jackStyle" can't find a dot, and hence it all goes blerg
13:10:34 <aranea> Hmm. Looks like I found a counterexample for the "if it type-checks, it's correct" idiom :/
13:10:47 <monochrom> according to a recent poll on #haskell, a poll on #haskell yields only 2 answers on average, with 1 answer being a simple "yes" and 1 answer being a long "no but I don't mind"
13:11:02 <aranea> I'm trying to implement the D'Hondt election method (see wikipedia)
13:11:03 <hseg> Right. So I should split it into withPrefixIdent and woPrefixident and then the global parser is just (try withPrefixIdent) <|> woPrefixIdent
13:11:05 <typoclass> monochrom: no but i don't mind
13:11:17 <hseg> monochrom, yes
13:11:23 <geekosaur> :p
13:13:00 <hpaste_> aranea pasted “d'hondt” at http://hpaste.org/87747
13:13:08 <monochrom> nonetheless, analysts say that it is still better than polling on reddit, where on average it yields 0 simple answers and 100 digressional answers
13:13:14 <natnayr> hi, need help for list comprehension..
13:13:17 <hpaste_> natnyr pasted “natnyr” at http://hpaste.org/87748
13:13:52 <aranea> here's my code, could someone look at it?
13:13:53 <Fuuzetsu-> aranea: If it type-checks, it's most likely correct. You can use unsafeCoerceIO to have a program that type-checks but isn't correct as a trivial example.
13:13:54 <natnayr> in my line 7, i need to output the built list
13:14:00 <Fuuzetsu-> Haskell is not a proof assistant~
13:14:21 <aranea> Fuuzetsu-: it doesn't do the thing I want it to do
13:14:49 <Fuuzetsu-> aranea: and you suspect that it's the language's fault how?
13:15:02 <BMeph> aranea: That is correct. Perhaps you simply don't want to do the correct thing? ;p
13:15:05 <Fuuzetsu-> The ‘correct’ doesn't mean ’does what you want it to do’.
13:15:52 <aranea> Fuuzetsu-, BMeph: I suspect I'm a jerk
13:16:14 <aranea> but I don't find the mistake
13:16:26 <aranea> haven't used haskell for a rather long time
13:16:42 <Fuuzetsu-> Well, that's just the problem with your logic and not the type-system or the language~
13:16:55 <aranea> sure, I just wanted to make a joke
13:17:10 <Fuuzetsu-> Oh.
13:17:17 * Fuuzetsu- is tired and trying to not fail the year
13:17:30 <natnayr> anyone looking at mine?
13:18:01 <Fuuzetsu-> natnayr: [Show t] is not a thing
13:18:17 <Fuuzetsu-> if you want to print then at the very least it's going to be IO ()
13:18:18 <natnayr> Fuuzetsu: wat should it be?
13:18:25 <aranea> natnayr: Show t => [t]
13:20:05 <Fuuzetsu-> you probably just want solutions to be :: Formula ts -> [ts] and then have a function :: [ts] -> IO ()
13:20:31 <aranea> is there a way to access the functions in a where clause from ghci for debugging?
13:20:31 <natnayr> Fuuzetsu: nah, i need to compute that list again..
13:20:34 <typoclass> what extension is that? "data F ts where Body :: ..." it's among the heavy guns, isn't it
13:20:45 <geekosaur> -XGADTs
13:20:51 <aranea> I can't globalize them, they use some of the function arguments
13:21:00 <typoclass> geekosaur: er, oh
13:21:03 * typoclass scratches his head
13:21:08 <geekosaur> (or is it spelled out? hm)
13:21:30 <Fuuzetsu-> aranea: You can globalise them. Just pass the values as arguments.
13:21:38 <monoidal> typoclass: note that usually GHC will suggest missing pragmas, so you can check it inside GHCi
13:21:52 <geekosaur> no, short name is right
13:21:57 <typoclass> monoidal: right. should've done that
13:24:49 <hseg> After finding that the obvious location for the bug I'm seeing isn't the cause, I now find that some code that seemed correct to me was the cause. D'oh!
13:26:10 <typoclass> aranea: hm ... that code is a little hard to follow. the wikipedia page is also hard to follow :-/
13:27:36 <aranea> typoclass: I admit my names aren't very self-describing
13:27:52 <aranea> I'm debugging it atm
13:31:18 <aranea> up to divVotes, everything works
13:31:28 <aranea> descDivs doesn't work anymore
13:32:23 <sarfraz_> HI, I just read about usenet and was wondering if it was actively used by haskellers like irc or the mailing lists
13:33:17 <sarfraz_> does anyone here post about post over there?
13:35:47 <typoclass> sarfraz_: not sure. there seems to be a group comp.lang.haskell, but it's not really much-used groups.google.com/group/comp.lang.haskell
13:37:45 <sarfraz_> yeah that is what I found at firt and since it was not used I thought maybe some more used group existed
13:37:58 <elliott> well, the mailing lists are effectively that
13:39:16 <monochrom> I am on comp.lang.haskell. but there is nothing to say lately
13:40:46 <monochrom> haskell-cafe mailing list is pretty active
13:41:22 <monochrom> comp.lang.functional is still pretty active I guess, but I have not really checked
13:41:54 <monochrom> but since comp.lang.haskell already exists, you won't find much haskell in comp.lang.functional
13:42:55 <aranea> ahh, solved it
13:43:06 <sarfraz_> Oh well that's that. I was drawn by the old school feel but seems that I will stay on the lists
13:49:07 <madjestic> typoclass: I've adopted your variant to: http://hpaste.org/87749 .  It compiles, but I can't figure out how to use it the way I think it's supposed to be used.  I expect to be able to call: foo 1::Int (or foo 1) and get 1 as a return... I must be missing something
13:50:16 <typoclass> madjestic: does it work when you do "(foo :: Int -> Int) 123" ?
13:50:39 <elliott> do you mean foo (1::Int)?
13:52:21 <madjestic> typoclass: yes, that's it
13:52:31 <madjestic> elliott: I am afraid not
13:52:44 <madjestic> elliott: i.e. it does not work that way either
13:53:12 <elliott> try
13:53:18 <elliott> instance a ~ Int => Foo (a -> Int) where
13:53:26 <elliott> instance (a ~ Int, b ~ Int) => Foo (a -> b -> Int) where
13:53:27 <Fuuzetsu-> Does anyone know what's going on with Haddock's issue tracker? Are all these 2008 bugs still valid?
13:54:36 <sm_> sarfraz_: read the lists via gmane.org and keep that old school feel
14:01:42 <ded> In the docs for Network.HTTP ty is used as the name of the input. Why ty?
14:03:22 <arkeet> ded: probably short for type
14:03:54 <arkeet> it is indeed unconventional though
14:05:19 <ded> arkeet: thanks (ty...)
14:05:32 <klrr_> Botje_: thanks! :D
14:06:47 <arkeet> ded: heh.
14:08:41 <monochrom> HTTP.Network wants to thank you!
14:08:52 <monochrom> err, Network.HTTP
14:11:29 <madjestic> elliott: it looks like a step in the right direction: http://hpaste.org/edit/87749
14:11:53 <madjestic> any ideas how to make foo (1::Int) (2::Int) work?
14:12:34 <klrr_> §what's the difference between using "space" and "skipmany1 space" ?
14:12:43 <klrr_> in parsec parsercombinators
14:12:59 <elliott> madjestic: that second instance is not what i said
14:13:04 <madjestic> elliott: sorry, just submitted
14:13:16 <elliott> is the error still there if it's corrected?
14:13:43 <madjestic> elliott: could you refresh the page, please, so that we are on the same page?
14:13:56 <elliott> I did; it stayed the same
14:14:06 <elliott> the instance is still not the one I said
14:14:15 <elliott> <elliott> instance (a ~ Int, b ~ Int) => Foo (a -> b -> Int) where
14:14:34 <madjestic> elliott: I see.  My mistake
14:14:44 <madjestic> elliott: let me try fixing it
14:15:53 <hseg> klrr_, space parses a single ws char and returns it. skipMany1 space parses a nonempty sequence of ws chars, discarding the result.
14:16:10 <klrr_> okey
14:16:29 <klrr_> why do GHC keep throwing illogical errors at me ? ?!?! :X
14:16:53 <hseg> Because you're giving it illogical inputs?
14:18:02 <klrr_> hseg: http://hpaste.org/87753 i dont get the logic, it says i pass a function something wrong but it's not wrong
14:21:34 <klrr_> http://hpaste.org/87753 any ideas, some weird type error...
14:23:15 <madjestic> elliott: omg it works
14:23:21 <elliott> :)
14:24:41 <madjestic> elliott: what should I read to get a better idea on how this magic works?
14:25:03 <madjestic> elliott: for instance the "a ~ Int" construction and alike
14:25:39 <ctrl> The `interpret' functions expects a String, but the type of `readExprFile str' is `ErrorOr [Expr]'
14:25:39 <ctrl> What's wrong with the message?
14:25:40 <ctrl> Should `interpret' accept `ErrorOr [Expr]' or should `ErrorOr [Expr]' return a String?
14:25:47 <elliott> well, the GHC documentation describes type equalities. but the basic idea is to et it to commit to an instance sooner, and then fill in the types as obligations of using that instance.
14:26:19 <klrr_> ctrl: true my logic is not logical
14:27:18 --- mode: adams.freenode.net set +o ChanServ
14:30:37 <hseg> Odd. I can't send messages to NickServ, in particular, I can't identify.
14:30:43 <sipa1024> same
14:30:47 <coppro> see the global notice that *just* went out
14:30:48 <sipa1024> chanserv is gone to
14:30:53 <Fuuzetsu-> Freenode is dicking up
14:31:02 <coppro> services are temporarily down
14:31:05 <ctrl> webchat.freenode.net is down
14:31:08 <ctrl> in particular
14:31:10 <sipa1024> coppro: must have missed it because of being disconnected
14:31:22 <monochrom> now is a good time to steal other people's nicks temporarily! :)
14:31:33 <Fuuzetsu-> -tomaw- [Global Notice] Hi all. We're just completing some administrative tasks after services extended tea break. They'll return shortly. Sorry for the outage!
14:31:35 <coppro> and risk losing my +i? not a chance :P
14:32:22 <hseg> Damn. So I won't have voice on #vim or #archlinux until services are restored.
14:32:39 <Fuuzetsu-> Nothing of value was lost.
14:32:40 <monochrom> oh, yikes
14:32:42 <ctrl> Is there a lense-like package without use of Template Haskell?
14:32:50 <coppro> worse is that you can't *talk* in #vim
14:32:54 <coppro> much less get +v
14:33:06 <coppro> ctrl: Control.Lens does not require TH
14:33:06 <arkeet`> ctrl: what do you mean? you don't have to use TH to use lens.
14:33:13 <arkeet`> sometimes, you don't have to use lens to use lens.
14:33:25 <monochrom> now that's deep :)
14:33:37 <piezo> What is the meaning of this constrain : (~ * site' site, ~ (* -> *) IO m, ~ * a ()) => ToWidget site' (WidgetT site m a) ?
14:33:38 <Fuuzetsu-> lens, you lens have to use lens to use lens
14:33:38 <typoclass> ctrl: afaik, lens is the last word in lenses. and i don't think you have to use TH if you don't want to
14:33:48 <piezo> this part : ~ kind TV TV' ?
14:33:54 <monochrom> you don't have to understand co-recursion to understand co-recursion
14:34:04 <arkeet`> piezo: it's being explicit about kind variables
14:34:07 <arkeet`> it's more like
14:34:08 <ctrl> I don't have to use TH, yet the package itself uses it.
14:34:12 <arkeet`> (site' ~ site, IO ~ m, a ~ ())
14:34:19 <arkeet`> time to go.
14:34:20 <ctrl> makeLenses is pretty much a template function, is it not?
14:34:21 <typoclass> monochrom: but you do to counderstand corecursion
14:35:14 <coppro> typoclass: of course
14:35:21 <coppro> counderstanding corecursion is just understanding recursion
14:36:04 <typoclass> ctrl: well yes, but as far as i know, you could write those lenses yourself and not use makeLenses. TH doesn't seem integral to lens, it just automates a few things you could also do manually. anyway, i don't know much about lens
14:36:39 <piezo> arkeet`: ok, less scaring that I thought. thank you
14:40:43 <ctrl> The thing I actually want is handling of records without redundancy. I have a type `data State = State { source :: String, level :: Integer }', and where I do `state' = state { source = f (source state) }' I would like something that would not mention `source state' twice
14:41:33 <blackdog> ctrl: look at lenses, perhaps?
14:42:34 <ctrl> I did. They are implemented with TH, which I am not overfond of.
14:42:50 <coppro> lenses themselves are not implemented with TH
14:43:01 <coppro> but you need TH to avoid a little bit of redundancy
14:43:06 <acube> ctrl: You can use lens to create your lenses
14:43:13 <acube> @ty lens
14:43:15 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
14:43:25 <typoclass> ctrl: you could have a look at this http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio it was written before ekmett's lens package took shape, so it reflects the state of the art before lens
14:43:45 <mgsloan> TH is merely a convenience to reuse record syntax.  Definitions for "lens" lenses are actually pretty concise - the getter and setter aren't even separated like most lens libraries
14:43:54 <applicative_> TH is totally irrelevant.
14:44:11 <acube> > let l = lens (\(x,_) -> x) (\(_, y) x -> (x,y)) in (1,2) ^. l
14:44:15 <lambdabot>   1
14:44:25 <acube> > let l = lens (\(x,_) -> x) $ \(_, y) x -> (x,y) in (1,2) ^. l
14:44:31 <lambdabot>   mueval: ExitFailure 1
14:44:31 <lambdabot>  mueval: Prelude.undefined
14:44:42 <acube> > let l = lens (\(x,_) -> x) $ \(_, y) x -> (x,y) in (1,2) ^. l
14:44:44 <applicative_> the lens library itself only uses TH in one module the one on IOError
14:44:45 <lambdabot>   1
14:45:34 <typoclass> ctrl: as a user of the library, you don't have to turn on TH. and if you have some deep moral objection to TH, you could modify lens fairly easily so that it doesn't even offer any TH functions. you'd just remove some utility stuff. and what applicative_ says
14:45:53 <Fuuzetsu-> > 1
14:45:55 <lambdabot>   1
14:46:03 <Fuuzetsu-> Oh, it's fixed.
14:46:37 <staafl> what are some useful combinators like curry, uncurr, on?
14:46:46 <applicative_> indeed as arkeet` said above I see "sometimes, you don't have to use lens to use lens"
14:46:54 <monochrom> (.) is very useful
14:47:12 <staafl> monochrom, :-D
14:47:14 <applicative_> meaning, you can write what you advertise as lenses to your uses, without any dependence on the lens package at all
14:47:26 <monochrom> <$>, <*>, <*, *>
14:47:39 <typoclass> staafl: good question
14:47:45 <ctrl> Thanks, so it seems if I don't use TH, I only need to provide some instances myself. That's nice.
14:48:21 <typoclass> > ((==) <*> reverse) "radar" -- staafl: the (->) instance for Applicative lets you use <*> in this way. it's a palindrome checker
14:48:26 <lambdabot>   mueval: ExitFailure 1
14:48:26 <lambdabot>  mueval: Prelude.undefined
14:48:31 <typoclass> ... or not ...
14:48:48 <applicative_> ctrl, you just need to write the lenses themselves, for which you can use the lens function.  it sounds like you will also want some kind of classes for your use case.
14:48:49 <typoclass> staafl: anyway, it works on days when lambdabot has not been out drinking
14:48:51 <staafl> typoclass, cool
14:49:11 <ctrl> (==) <$> reverse <*> id
14:49:18 <ctrl> That is a palindrome checker.
14:49:31 <johnw> reverse &&& id >>> uncurry (==)
14:49:39 <jmcarthur> staafl: everything in the lens library
14:49:40 <ctrl> `liftA2 (==) reverse id' is simpler, though
14:50:00 <typoclass> yes yes, but mine is the shortest
14:50:02 <typoclass> :)
14:50:19 <ctrl> I don't get how it works, though :D
14:50:40 <staafl> excellent, I'll make sure I examine them all
14:50:42 <staafl> thanks yall
14:51:09 <applicative_> ctrl there is #haskell-lens I'm not sure how often it is active
14:51:16 <jmcarthur> quite often
14:51:18 <acube> :t (reverse >>= (==))
14:51:20 <lambdabot> Eq a => [a] -> Bool
14:51:24 <applicative_> well there you are
14:51:34 <acube> > reverse >>= (==) $ [1,2,3,3,2,1]
14:51:39 <lambdabot>   True
14:51:41 <acube> > reverse >>= (==) $ [1,2,3,3,2]
14:51:46 <lambdabot>   False
14:52:11 <acube> @src (->) r (>>=)
14:52:11 <lambdabot> Source not found. stty: unknown mode: doofus
14:52:28 <acube> @src (->)  (>>=)
14:52:28 <lambdabot> Source not found. Are you on drugs?
14:52:32 <acube> @src (-> r) (>>=)
14:52:32 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:52:39 <jmcarthur> @src ((->) r) (>>=)
14:52:40 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
14:52:41 <typoclass> ctrl: it becomes clear when you look at the (->) instance for Applicative. the definition is (<*>) f g x = f x (g x), i.e. just the thing we need :-) pass x into g; and call f with the original x and the result that g x gave
14:52:47 <typoclass> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Applicative.html
14:53:01 <ctrl> Wow, that's smart.
14:53:07 <Garyuutensei> Does anyone know why there isn't a Monad instance for Data.Vector.Unboxed?
14:53:21 <ctrl> :t (<*>)
14:53:22 <jmcarthur> Garyuutensei: try writing it and you'll see
14:53:24 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:53:48 <acube> Garyuutensei: It's because you cannot change the types of of the elements freely (it neeeds an Unboxed a constraint for type a in Vector a)
14:54:55 <typoclass> ctrl: yup. and in that type, you can mentally replace "f something" with "(x -> something)"
14:55:36 <typoclass> ctrl: (as always, don't get confused: ((->) a) is the same as (a ->) )
14:56:20 <ctrl> Yes, that's pretty much obvious
14:58:13 <ctrl> Still seems hackish to me, though :D
15:04:14 <Garyuutensei> jmcarthur: So I tried it and indeed it needs the Unbox condition. I didn' know this before. Is there any work around?
15:08:10 --- mode: adams.freenode.net set +o ChanServ
15:08:11 <ctrl> Is there GTK3 binding for Haskell already or it's GTK2 only for now?
15:10:58 <hseg> I'm unsure of the appropriate structure to represent a sequence of terms separated by operators
15:11:03 <hseg> Any suggestions?
15:11:27 <hseg> All operators are binary, nofix, and no relative priority
15:12:00 <ctrl> data Expression = Primary Integer | Expression Operator Expression
15:12:18 <ctrl> data Operator = Plus | Minus
15:12:25 <ctrl> Would that do?
15:13:12 <ctrl> Ahem, sorry, I meant
15:13:14 <ctrl> data Expression = Primary Integer | Expression Operator Integer Expression
15:13:18 <hseg> It would definitely beat my current data Expression = Expr Term [(Op, Term)]
15:13:30 <hseg> Thanks.
15:17:21 <amalloy> so i wrote http://hpaste.org/87762, which modifies the first item in a list that matches a predicate. simple enough function, but it seems to me there ought to be some prettier way to write it as a fold or an unfold, and i don't see it
15:19:45 <kludgy> amalloy: If I'm reading that correctly, is it not a sort of map-if?
15:20:21 <ctrl> Nope, it changes only the first occurrence
15:20:31 <dario1> you could do a map-if with state, the state containing "have i replaced one yet?"
15:20:31 <kludgy> oh i see
15:20:40 <dario1> that wouldn't be simpler though..
15:21:10 <ctrl> :t foldl
15:21:14 <lambdabot> (a -> b -> a) -> a -> [b] -> a
15:21:29 <coppro> you could do it sensibly with conduits, but that's still probably overkill
15:21:49 <ewifji> I'm wondering if using constA or similar is less efficient than a value itself, or if ghc optimizes as I expect. should something like constA (3, 4) >>> arr (uncurry (*)) be equivalent in performance to something like constA (3 * 4)?
15:22:12 <coppro> ah, right, knew there was something
15:22:22 <coppro> amalloy: use mapAccumL
15:22:36 <amalloy> :t mapAccumL
15:22:41 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
15:22:44 <acube> @src constA
15:22:44 <lambdabot> Source not found. That's something I cannot allow to happen.
15:22:51 <acube> @ty constA
15:22:54 <lambdabot>     Not in scope: `constA'
15:22:54 <lambdabot>     Perhaps you meant one of these:
15:22:54 <lambdabot>       `const' (imported from Data.Function),
15:23:14 <ewifji> it's something like constA x = arr (\_ -> x)
15:23:47 <ewifji> ah, returnA
15:23:59 <ewifji> sorry, constA = returnA in the library i'm using
15:24:05 <typoclass> amalloy: i'd use 'break' (or 'span') on the predicate, and go from there
15:24:31 <ewifji> that's  alie
15:24:45 <ewifji> but it's constA x = arr (\_ -> x)
15:27:02 <ewifji> rephrased, should (\_ -> (4, 3) >>> arr (uncurry (*)) be more expensive than arr (\_ -> (4 * 3))?
15:27:07 <hseg> I need some form of the many combinator that instead of constructing a list, folds the newly parsed result into the previous results.
15:27:18 <ctrl> amalloy, you could use mapAccumL from Data.List, though your version is perfectly nice
15:27:20 <typoclass> > let g pred f xs = case break pred xs of (a, "") -> a ; (a,b:c) -> a ++ f b : c ; in g isUpper toLower "lolCAT" -- amalloy, here is an example. i think it didn't really work :-) it didn't really become much shorter, compared to your version
15:27:25 <lambdabot>   mueval: ExitFailure 1
15:27:25 <lambdabot>  mueval: Prelude.undefined
15:28:07 <ewifji> meant  (\_ -> (4, 3)) >>> arr (uncurry (*)) of course
15:28:12 <typoclass> ... it would work if lambdabot would stop drinking scotch
15:28:13 <hseg> Case in point: Expression to be parsed: term (op term)*
15:31:03 <amalloy> hm, thanks guys. i know the manual/recursive version is fine, i'm just on the lookout for places where haskell's laziness lets me write folds that wouldn't be possible in a stricter language
15:31:10 <amalloy> guess this wasn't one of them!
15:31:20 <ctrl> Try using mapAccumL
15:31:52 <hseg> Thus, I'd need to have something like do { a <- Atom term; manyFold ((,) <$> op <*> term) (\acc (o,t) -> Op acc o t)} where Expr = Atom Term | Op Expr Op Term and where manyFold :: ParsecT s u m a -> (b -> a -> b) -> ParsecT s u m b
15:32:57 <hseg> ctrl: Me?
15:33:08 <ctrl> nope, amalloy
15:33:14 <hseg> Ah.
15:33:19 <ctrl> updateFirst p f = mapAccumL (\acc x -> if acc && p x then (False, f x) else (acc, x)) True
15:33:21 <alcatraz63_> is there a nice way in parsec to do many p but with maximum length?
15:34:06 <ctrl> It returns a tuple of (Bool, [a]), where [a] is updated list and the boolean value is True when nothing was changed
15:34:36 <ctrl> Surely you should do `import Data.List'
15:34:43 <ctrl> in order to use it
15:36:45 <koninkje> I have a cabal configuration issue... the .cabal/config file doesn't recognize with-haddock:. So how can I specify a custom path to the haddock executable?
15:38:33 <ctrl> hseg, why don't you use the sep combinator from parsec?
15:38:43 <hseg> Idea! Wouldn't this function I described be just foldl1 <$> many
15:40:12 <hseg> Because I didn't hear of it, nor can I find it in http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/doc-index-S.html
15:40:56 <hseg> Close matches don't fit use case, as the summary value depends both on the values separated and the separators
15:41:27 <ctrl> I was thinking of sepBy, though it wouldn't do because it omits the separator, sorry
15:42:17 <fizbin> So here
15:42:27 <applicative_> wow, Functor, Inc. ; high time. http://www.functor.se/careers/openings/
15:43:11 <fizbin> So here's an odd question. Best app for doing Haskell on an android phone?
15:43:34 <Fuuzetsu-> fizbin: define ‘doing Haskell’
15:43:40 <jmcarthur> fizbin: not much in that world yet. official arm support is coming soon in ghc
15:43:43 <hseg> Right. How about do { a <- Atom term; fold (flip $) a <$> many ((\o t -> \e -> Op e o t) <$> op <*> term); }
15:43:49 <hseg> ?
15:43:53 <jmcarthur> fizbin: you can get it to work right now, but it takes effort
15:44:26 <FreeFull> fizbin: ssh client
15:44:54 <Fuuzetsu-> ^
15:45:06 <ctrl> hseg, I would not use the many combinator in that case.
15:45:18 <hseg> ctrl, why not?
15:45:18 <ctrl> You can avoid folding if you don't
15:45:47 <fizbin> Fuuzetsu: well, that's an interesting question. Let's say, best app for when I'm far away from my computer but have just had an idea I'd like to test in Haskell.
15:46:11 <hseg> How?
15:46:22 <Fuuzetsu-> fizbin: ssh client ~
15:46:52 <Fuuzetsu-> alt. a web browser to an online compiler or similar
15:46:57 <ctrl> hseg, how about implementing parsers for Atom and Expression and combining them with (<|>)?
15:47:00 <hseg> fizbin, codepad.org or ideone.com, although they *have* caused some problems in the past to me
15:47:37 <hseg> ctrl, only problem being that the parser for Expression is dependent upon prior values.
15:48:19 <ctrl> That's not a problem really. I never used parsec, but I did write my own parser combinator library. Give me 10 minutes to take a look at parsec and I will think of something
15:48:56 <FreeFull> fizbin: Get a netbook, then you can be never away from haskell
15:48:57 <monochrom> "Atom term" should be "Atom <$> term" probably. I don't know about the rest.
15:49:07 <hseg> ctrl, Right. IIRC, that's the whole point with using monads as the backbone of the parser
15:49:38 <ctrl> monochrom, yes, obviously
15:53:16 <FreeFull> That's a lot of people joining and leaving
15:53:33 * hackagebot hyakko 0.6.3 - Literate-style Documentation Generator  http://hackage.haskell.org/package/hyakko-0.6.3 (JeremyHull)
15:53:35 <Rotaerk> freenode's having spasms
15:53:37 <ctrl> expr = Expr <$> op <*> term <*> expr <|> Atom <$> term
15:53:42 <ctrl> Does that work?
15:53:49 <blackdog> is it legit to catch KilledThread in order to do cleanup?
15:53:54 <ctrl> Pretty straightforward
15:54:00 <blackdog> blah, ThreadKilled i mean.
15:54:38 <FreeFull> Could almost mistake it for some sort of weird flood
15:54:48 <FreeFull> But why would someone be flooding #haskell
15:54:56 <_jmcarthur> you talking about disconnects?
15:55:05 <_jmcarthur> freenode is having some issues i think
15:55:08 <_jmcarthur> a ddos
15:55:12 <FreeFull> I see
15:55:37 <FreeFull> I didn't know Randall came in here
15:55:41 <blackdog> _jmcarthur: ah, freenode, that famously strategic target :)
15:55:45 <_jmcarthur> "We're having some issues stemming from a DDoS attack but we're working with our sponsors on attack mitigation."
15:56:02 <FreeFull> Ouch
15:56:22 <FreeFull> jmcarthur: Looks like a server got badly hit
15:56:25 <ctrl> wait, no
15:56:29 <ctrl> that can't work
15:56:33 <ctrl> try this
15:56:35 <ctrl> expr = flip Expr <$> term <*> op <*> expr <|> Atom <$> term
15:58:33 * hackagebot hyakko 0.6.4 - Literate-style Documentation Generator  http://hackage.haskell.org/package/hyakko-0.6.4 (JeremyHull)
15:58:49 <ctrl> hseg, so does it work?
15:58:51 <ctrl> expr = flip Expr <$> term <*> op <*> expr <|> Atom <$> term
16:00:18 <ctrl> It is also possible to write a monadic (not applicative) version in order to make only one attempt of parsing term
16:00:34 <hseg> Wait, why the flip?
16:01:13 <ctrl> Because Expr takes operator first, then term
16:01:54 <jmcarthur> the effects occur in order "term then op" but it is desired for them to be supplied to Expr in order "op then term"
16:01:54 <ctrl> look at its type
16:02:18 <jmcarthur> at least that is why i would use flip there
16:02:20 <hseg> No. data Expression = Expr Term Op Expression | Atom Term
16:02:26 <hseg> At least in my code.
16:02:33 <hseg> Modulo name changes
16:02:40 <jmcarthur> ah then the flip shouldn't be there i guess
16:02:40 <ctrl> Then no flip. I did use
16:02:42 <ctrl> Expr Op Term Expression
16:02:55 <hseg> And no, it doesn't work. I'm not sure why but although the term and op parsers work, expr doesn't recognise an atom I give it
16:03:45 <hseg> i.e. I do parse expr "" "someTerm", and it claims that it
16:03:53 <hseg> 's expecting an operator...
16:03:57 <jmcarthur> i'm not sure what the precedence of <|> is relative to <$> and <*>
16:04:01 <jmcarthur> lower i'm guessing?
16:04:05 <hseg> Wait, we're missing a try here.
16:04:08 <ctrl> Lower, yep
16:04:10 <hseg> jmcarthur, yes
16:04:59 <hseg> Since the Expr parse contains a prefix of the Atom parse, what expr sees as a failed Expr parse might have been a correct Atom parse.
16:05:08 <jmcarthur> i normally use liftA* and fmap. i use <$> occasionally, and <*> only when i already have something of type f (a -> b)
16:05:36 <jmcarthur> well, or i use (<*>) when i need liftAN for large N
16:05:57 <hseg> jmcarthur, I prefer to write out the <$> <*> part of the liftA*
16:06:14 <acube> I use <*> / <$> to avoid parentheses
16:06:15 <hseg> I'm getting a parse! Now, to check that it's correct...
16:06:29 <jmcarthur> liftA3 Expr term op exp <|> fmap Atom term
16:06:54 <jmcarthur> oh i'll use operators to avoid parens. it's just that those particular operators seems to rarely save me parens anyway
16:07:03 <jmcarthur> also, fmap and liftA* are composable
16:07:23 <acube> fmap (a . b) c vs a . b <$> c
16:07:40 <jmcarthur> sure, i'll do that
16:09:18 <ctrl> > Since the Expr parse contains a prefix of the Atom parse, what expr sees as a failed Expr parse might have been a correct Atom parse
16:09:20 <lambdabot>   <hint>:1:40: parse error on input `of'
16:09:29 <ctrl> That's why we use <|>
16:09:41 <ctrl> If the first attempt fails, we try to parse it as an Atom
16:09:45 <jmcarthur> on the other hand:    (liftA2.liftA2) f x y   vs.   (\a b -> f <$> a <*> y) <$> x <*> y
16:10:24 <ctrl> Let me know if it parses corretrly, I have a monadic version that is optimized to make only one attempt of parsing term
16:10:44 <elliott> jmcarthur: well, (<$>) and (<*>) are composable too. just in a different way.
16:10:56 <hseg> Parses correctly after wrapping the Expr parser in a try.
16:11:04 <lispy> liftM and ap, all the way
16:11:47 <jmcarthur> elliott: sure. they scale to arbitrary numbers of arguments, whereas liftAN and fmap scale to arbitrary numbers of functors
16:12:01 <hseg> <|> only works if the left-hand parser didn't consume input. Thus, if both parameters have a common prefix and the left-hand parser might have consumed said prefix, that parser must be wrapped in a try
16:12:12 <hseg> Anyhow, thanks a lot.
16:12:30 <acube> :t liftA9 . liftA9
16:12:36 <lambdabot>     Not in scope: `liftA9'
16:12:36 <lambdabot>     Perhaps you meant one of these:
16:12:36 <lambdabot>       `liftA' (imported from Control.Applicative),
16:12:42 <acube> :t liftA5 . liftA5
16:12:46 <hseg> Now, to further trim my data types, so as to make output more readable
16:12:48 <lambdabot>     Not in scope: `liftA5'
16:12:48 <lambdabot>     Perhaps you meant one of these:
16:12:48 <lambdabot>       `liftA' (imported from Control.Applicative),
16:12:58 <jmcarthur> acube: i think it only goes to 3 or 4
16:13:02 <ctrl> Does it consume input when it fails?
16:13:03 <acube> :t liftA3 . liftA3
16:13:07 <lambdabot> (Applicative f1, Applicative f) => (a -> b -> c -> d) -> f (f1 a) -> f (f1 b) -> f (f1 c) -> f (f1 d)
16:13:14 <ctrl> I thought it didn't.
16:13:21 <jmcarthur> ctrl: parsec does
16:13:27 <acube> :t liftA3 . liftA3 . liftA3 . liftA3
16:13:29 <ctrl> How do I prevent it?
16:13:31 <lambdabot> (Applicative f3, Applicative f2, Applicative f1, Applicative f) => (a -> b -> c -> d) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b))) -> f (f1 (f2 (f3 c))) -> f (f1 (f2 (f3 d)))
16:13:44 <jmcarthur> ctrl: you have to use try
16:13:48 <acube> :t liftA3 liftA3 liftA3 liftA3
16:13:52 <lambdabot> Applicative f => (((f c -> f d) -> b -> c -> d) -> f (f c -> f d) -> f b -> b) -> ((f c -> f d) -> b -> c -> d) -> (f (f c -> f d) -> f b -> c) -> f (f c -> f d) -> f b -> d
16:13:58 <acube> :O
16:14:01 <ctrl> expr = term >>= \term_v -> try (Expr term_v <$> op <*> expr) <|> return (Atom term_v)
16:14:19 <elliott> jmcarthur: I think the former is more common
16:14:26 <acube> :t liftA3 liftA3 liftA3 liftA3 liftA3
16:14:28 <elliott> (<$>) and (<*>) are so noisy is my real problem :(
16:14:29 <lambdabot> Applicative f => ((f c -> f d) -> (f c -> f d) -> c -> d) -> (f (f c -> f d) -> f (f c -> f d) -> c) -> f (f c -> f d) -> f (f c -> f d) -> d
16:15:16 <acube> :t liftA liftA liftA
16:15:20 <lambdabot> (Applicative f1, Applicative f) => (a -> b) -> f (f1 a) -> f (f1 b)
16:15:30 <jmcarthur> :t liftA liftA3 $ liftA liftA3 $ liftA liftA3 $ liftA3
16:15:33 <lambdabot> (Applicative f3, Applicative f2, Applicative f1, Applicative f) => (a -> b -> c -> d) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b))) -> f (f1 (f2 (f3 c))) -> f (f1 (f2 (f3 d)))
16:15:37 <BMeph> acube: Woould you please do that in a separate /msg to lambdabot?
16:15:42 <ctrl> hseg, does the monadic version work?
16:15:57 <ctrl> I'm not sure if I used `try' properly.
16:16:25 <BMeph> jmcarthur: You're not helping, either.... ;)
16:16:28 <acube> @ty 2liftA2 -- what?
16:16:31 <lambdabot>     Ambiguous type variable `f0' in the constraint:
16:16:31 <lambdabot>       (Applicative f0) arising from a use of `liftA2'
16:16:31 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
16:16:35 <jmcarthur> BMeph: sorry :)
16:16:36 <hseg> ctrl, As said above, the applicative version with the Expr parser wrapped in a try works, and resembles my style.
16:16:48 <ctrl> The monadic version is optimized.
16:16:59 <ctrl> It makes only one attempt to read term.
16:17:09 <ctrl> The applicative one does it twice (for Expr and for Atom)
16:17:39 <BMeph> ctrl: As it should; that's how Applicatives work.
16:17:48 <ctrl> Yep.
16:17:53 <acube> @ty 2id
16:17:54 <ctrl> That's why monad is needed.
16:18:17 <ctrl> You read the term and then make an attempt to extend it to an Expr. If it fails, then yield Atom
16:18:42 <hseg> Right, and while it might be more optimal, I prefer the applicative style for this case. It more clearly expresses what's going on.
16:18:58 <acube> @ping
16:20:10 <ctrl> Since Expr is basically an Atom with Op and other Atom attached, the monadic version is clearer, in my opinion (though I'm still not sure if it works, I'm not good at Parsec)
16:20:31 <jmcarthur> on a related note, i discovered that sequence can be written in a tail recursive way, but sequenceA cannot
16:20:58 <ctrl> with Op and other Expr attached, I meant.
16:22:38 <hpaste_> hseg pasted “Unpack data constructors?” at http://hpaste.org/87765
16:24:00 <ctrl> hseg, how shoud it deduce the names?
16:24:26 <hseg> Seeing as A and B are only used once, it could just use their names.
16:24:53 <hseg> Basically, what i'd like is sth like a where clause for data constructors.
16:25:31 <ctrl> A1 and A2 are literals of A, B1 and B2 are literals of B.
16:25:44 <ctrl> Literals of Foo cannot be called that way.
16:26:02 <hseg> Oh.
16:26:03 <ctrl> If you use A and B only while declaring Foo, then I should ask you why?
16:26:18 <ctrl> It is pretty pointless.
16:26:34 <hseg> Because they are conceptually differrent
16:26:56 <ctrl> Then why do use combine them in one type Foo?
16:27:23 <hseg> I'm expressing myself unclearly.
16:27:52 <ctrl> The example given in hpaste is pretty clear.
16:28:23 <hseg> I have several constructors that are doing nothing else than wrapping values of type A into type B. They cause clutter when being constructed and printed.
16:29:33 <hseg> Ah, forget it. Just realised that I'm asking for something unreasonable.
16:29:33 <ctrl> Then don't use the A and B types.
16:29:37 <ctrl> Use only Foo.
16:30:07 <ctrl> Or if you need all three of them, stick with `Foo = FooA A | FooB B'
16:31:26 <hseg> Right. It's just that it's a bloody clutter when constructing and printing.
16:31:52 <ctrl> Define your own Show instance
16:32:07 <ctrl> for Foo
16:32:23 <ctrl> instance Show Foo where
16:32:25 <ctrl> show (FooA a) = show a
16:32:28 <ctrl> show (FooB b) = show b
16:33:08 <ctrl> Have a good time when (if) the names in A and B accidentally clash! ;)
16:33:17 <hseg> Hm. Isn't it some law somewhere that read . show = id ?
16:33:50 <ctrl> And do you have a Read instance? :)
16:33:54 <ctrl> If not, forget it.
16:34:09 <ctrl> In the case you have it, rewrite it too.
16:34:10 <geekosaur> hseg: shpould be true, but since types drive the parsing, you can define Read and Show instances for your type which match those of some other type. it's just bad form
16:34:54 <hseg> geekosaur, so in general, I shouldn't define Show instances to pretty-print my values?
16:35:12 <geekosaur> not really, no. better to define your own pretty printing typeclass
16:35:25 <geekosaur> with some moderately evil extensions you can even fall back on Show for most values
16:35:46 <hseg> What extensions?
16:36:15 <ctrl> By the way, it is true. Show/Read are not intended to make pretty printing. Choose a library you like http://stackoverflow.com/questions/9761507/which-pretty-print-library
16:36:24 <ctrl> And write an instance for your own type
16:36:55 <hpc> they are for uglyprinting, as it were
16:36:59 <geekosaur> OverlappingInstances, mostly. (since in instance Show a => Pretty a, a matches any type and the Show part is "realized" by the match. so it overlaps your explicit Pretty instances, but as those are more specific OverlappingInstances will prefer them)
16:37:22 <geekosaur> (but this is Really Not A Good Idea)
16:37:29 <blaenk> hey is it possible to do something like: (- 1) $ someFunction someParameter? because it's erroring out with some sort of syntactic negation or something
16:37:38 <blaenk> it works when I do (1 -) $ though
16:37:52 <geekosaur> it's an idiosyncrasy of haskell, yes
16:37:59 <blaenk> oh okay, so not possible that way
16:38:16 <blaenk> thanks
16:38:18 <ctrl> use the `negate` function
16:38:24 <hseg> blaenk, If all you want is to pass -1, you can use negate
16:38:31 <geekosaur> for the section, use (subtract 1) or (flip (-) 1) or etc.
16:38:31 <centrinia> :t negate
16:38:33 <lambdabot> Num a => a -> a
16:38:37 <blaenk> cool thanks I'll look that up
16:39:35 <ctrl> subtract, not negate. Yes, sorry
16:40:00 <blaenk> yeah subtract seems to work thanks!
16:40:05 <centrinia> :t add
16:40:07 <lambdabot>     Not in scope: `add'
16:40:07 <lambdabot>     Perhaps you meant one of these:
16:40:07 <lambdabot>       `odd' (imported from Prelude), `and' (imported from Data.List),
16:40:26 <geekosaur> add isn't needed. subtract exists solely because of this oddity
16:40:41 <centrinia> @let add = (+)
16:40:44 <lambdabot>  Defined.
16:40:48 <ctrl> :t add
16:40:50 <lambdabot> Num a => a -> a -> a
16:40:53 <geekosaur> where you can't use (-1) as a section because it's read as a numeric literal
16:41:06 <ctrl> Uh oh, so anyone can define whatever he wants. Not good.
16:41:44 <ctrl> @let add = (-) -- happy debugging
16:41:46 <lambdabot>  <local>:3:1:
16:41:46 <lambdabot>      Multiple declarations of `add'
16:41:46 <lambdabot>      Declared at: <local>:2...
16:42:35 <blaenk> is there a convention/preference for using $ ? so I have subtract 1 $ someFunction (anotherFunction argument), should I just make that a $ after the someFunction ?
16:42:48 <blaenk> subtract 1 $ someFunction $ anotherFunction argument
16:42:55 <blaenk> or is there a better way?
16:43:04 <Cale> I would recommend using composition if you're going to eliminate parens
16:43:17 <Cale> subtract 1 . someFunction . anotherFunction $ argument
16:43:20 <jmcarthur> i prefer   subtract 1 . someFunction $ anotherFunction argument   or even better   subtract 1 . someFunction . anotherFunction
16:43:43 <jmcarthur> the latter assuming you can get rid of argument on the left side like that
16:43:59 <blaenk> ohh okay, I get it now. composition has always confused me when using it when I already know the argument (like, it's not being passed in as a parameter or whateveR)
16:44:34 <ctrl> If you need to make clear what is passed, use type declarations.
16:44:44 <jmcarthur> blaenk: even if you already have the argument in scope, composition is still a good way to think about your code
16:44:48 <ctrl> Arguments should be used only when needed.
16:45:02 <blaenk> oh yeah, what I meant to say was I had trouble figuring out how to use it in that situation
16:45:12 <jmcarthur> blaenk: for one, if you have   f . g . h . i . j . k    you can extract any part of that into its own function that you want. easy refactoring
16:45:14 <blaenk> but now I just realized you just use a $ argument after the compose chain right
16:45:36 <jmcarthur> blaenk: just because it's associative
16:45:40 <ctrl> >> but now I just realized you just use a $ argument after the compose chain right
16:45:53 <ctrl> Because compositions creates a giant do-it-all function
16:45:58 <blaenk> right :)
16:45:59 <ctrl> and we need to apply it
16:46:07 <lizzinn> how would you guys write this in haskell? im having trouble of thinking how this would be done in a functional manner http://pastie.org/private/vlqjghfnljaq4nqq6nza
16:46:12 <ctrl> but if we do not use $, then the priority is wrong
16:46:18 <ctrl> and only the last function is applied
16:46:22 <ctrl> That's not good.
16:46:23 <blaenk> yeah
16:46:24 <jmcarthur> lizzinn: what does it do?
16:46:51 <hpc> haha, that's such a damning thing to say about code
16:46:57 <hpc> "hey, here's my source for this thing"
16:46:59 <hpc> "what does it do?"
16:47:09 <jmcarthur> no offense intended
16:47:19 <vermeille> Hey guys !
16:47:20 <hpc> i know, it's just funny
16:47:32 <jmcarthur> i am unused to reading very imperative code, and to top it off it's very low level bit manipulation stuff
16:47:43 <lizzinn> jmcarthur: its for reversing the mersenne twister tempering
16:47:52 <hpc> ooh, neat
16:47:58 <lizzinn> http://pastie.org/7896795
16:48:11 <Cale> Well, I could write you a very very direct translaction...
16:48:17 <hpc> ^
16:48:20 <jmcarthur> oh i don't know enough about that to really help. i could offer a "straightforward" translation, but it won't necessarily be decomposed meaningfully the way good functional code would be
16:48:21 <hpc> honestly, i would write that in ST
16:48:23 <lizzinn> just looking to reverse those operations
16:48:29 <lizzinn> hpc: ST?
16:48:32 <hpc> but i don't know the math
16:48:38 <jmcarthur> why would you use ST?
16:48:50 <jmcarthur> i doubt the mutation is even necessary
16:48:57 <hpc> or something
16:49:14 <Cale> oh, what is >>> here? (Presumably it's some kind of bit shift or rotation?)
16:49:19 <jmcarthur> a simple tail recursive loop should be fine, and i only suggest a loop because i don't know the problem well enough to suggest something higher level
16:49:32 <vermeille> Guys, I'm trying to implement a compiler in Haskell, so, my parser is done and generates my AST. Now, I want to realize a "binder", ie, for each node, have a reference to its definition's node. Since references does not exists, how would you od ?
16:49:35 <hpc> Cale: sign extended shift?
16:50:17 <Eduard_Munteanu> vermeille: why a "reference"?
16:50:32 <jmcarthur> vermeille: there are tons of way to do references, actually. to top it off, in interpreters there are a million styles for handling binders.
16:50:58 <vermeille> I'm listening to you, teach me, masters :D
16:51:03 <jmcarthur> and it's not clear which is best :)
16:52:01 <jmcarthur> i think we need some questions answered. for one, why "references"? what are you binding? do you need mutation? do you *really* need mutation?
16:52:14 <Eduard_Munteanu> I suspected that.
16:52:18 <jmcarthur> not that references are inherently mutable
16:52:41 <lizzinn> >>> bit shifts to the right filling in the new bits with zeros
16:53:08 <ctrl> Some low-level black magic
16:53:25 <hseg> Started looking through pretty printers, and I can't find a description of how to define a pretty-printer for my type.
16:53:36 <lizzinn> jmcarthur: would you mind writing the first one with the loop you hand in mind?
16:53:42 <quchen> Redefining operators used in standard libraries is maybe not such a good idea. Category already has >>>.
16:53:46 <jmcarthur> lizzinn: i'm not going to translate that whole thing, but here are some thoughts
16:53:51 <hseg> Although I'm getting the feeling it's going to be more trouble than its worth
16:54:05 <ctrl> Anyway, the while cycle conversion into a recursive function is pretty straightforward.
16:54:09 <hseg> Similarly for trying to restructure the types to be nicer
16:54:20 <jmcarthur> lizzinn: i see "i += 1" in a while loop. my gut reaction is to use   zipWith something someotherstuff [0..]   where the [0..] is all the values that i will take
16:54:32 <vermeille> jmcarthur: I don't need mutability all. Say, I have a node "FunCall", I should have an easy way to jump to its "FunDef" node
16:54:42 * nejucomo wishes ghci had a comment to show doc strings associated with a function or type...
16:55:02 <jmcarthur> lizzinn: probably the structure of the main loop would be something involving scanl or something, and the whole thing would be terminated with a takeWhile
16:55:02 <ctrl> Why not make the syntactic node a part of the semantic one?
16:55:12 <ctrl> i. e. attach a value. No reference needed
16:55:27 <ctrl> Since all the data is immutable, it won't consume the memory.
16:55:37 <jmcarthur> lizzinn: that is, the takeWhile is your while loops condition. the scanl is the loop itself with accumulation
16:55:41 <ctrl> GHC is able to optimize that
16:55:48 <ctrl> it operates on references internally
16:56:26 <jmcarthur> vermeille: what ctrl means is that    let x = someBigDataStructure in (x, x)   only results in the big data structure appearing in memory in one place, not two
16:56:44 <lizzinn> jmcarthur: sounds like what i had in mind too. thanks
16:56:47 <jmcarthur> vermeille: and that generalizes even to very complicated graphs
16:57:01 <vermeille> Hum, interesting
16:57:41 <jmcarthur> vermeille: this is how it's possible to represent infinite lists and other things like that, btw
16:57:48 <jmcarthur> vermeille: they are actually just cyclic lists in memory
16:57:55 <jmcarthur> well, at least they can be
16:58:09 <jmcarthur> [1..] is also an infinite list even though it isn't cyclic
16:58:21 <jmcarthur> but   let xs = 1:xs in xs  is cyclic
16:58:23 <ctrl> Just make sure to use the `let' statement corretly. While `let a = bigThing' and `let b = bigThing' creates to big things, you could do `let b = a' instead.
16:58:52 <hseg> I had this crazy idea today. Since the CT definition of monads is a functor F:C->D, equipped with natural transformations eta and mu, one could claim that monad transformers are just the monads themselves over the Kleisli category of the wrapped monad.
16:58:55 <jmcarthur> ctrl: well, assuming "bigThing" is some expression that does computation and not just the same binding as it appears to be
16:59:23 <ctrl> yep
16:59:25 <jmcarthur> hseg: not crazy at all! but they aren't all monads, i think
16:59:29 <hseg> i.e. MaybeT IO a is just the Maybe monad over the IO category.
16:59:41 <jmcarthur> hseg: http://hackage.haskell.org/packages/archive/category-extras/0.53.1/doc/html/Control-Monad-HigherOrder.html
17:00:20 <ctrl> the funny thing is that ListT is not always a monad
17:00:23 <ctrl> sadly
17:00:25 <ctrl> lol
17:00:31 <ctrl> look at the "ListT done right" proposal
17:00:35 <jmcarthur> ctrl: ListT "done right" is, isn't it?
17:00:52 <ctrl> I guess so :D
17:01:02 <jmcarthur> ctrl: but this isn't what hseg is talking about
17:01:32 <vermeille> Okaaaaaaaaaaaaay, it's really an idea that I need to explore
17:01:36 <hseg> That package is way to dense for me to read.
17:01:37 <vermeille> Thank you guys
17:02:19 <ctrl> what is :~>
17:02:21 <hpaste_> Cale pasted “Initial translation of imperative code” at http://hpaste.org/87766
17:02:23 <ctrl> in this package?
17:02:27 <jmcarthur> ctrl: he suggests (inaccurately, i think) that it may be that for any monad transformer t, there is a function  hbind :: (Functor f, Functor g) => (forall a. f a -> t g a) -> (forall a. t f a -> t g a)
17:02:50 <jmcarthur> ctrl: type :~> f g = forall a. f a -> g a
17:03:03 <jmcarthur> ctrl: hreturn would just be lift, i think
17:03:11 <jmcarthur> :t lift
17:03:13 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
17:03:27 <jmcarthur> but monad transformers do not have hbind in general
17:03:34 <elliott>  Cont doesn't admit that, for example
17:03:47 <Cale> lizzinn: There's a very direct translation of sorts, where we represent various points in the imperative code by separate functions that take the values of local variables as parameters, and call each other with updated parameters in accordance with how the control structures work.
17:03:55 <elliott> (I find (forall a. f a -> g a) -> (forall a. f a -> g a) easier to reason about; you can recover hbind with join)
17:03:56 <hseg> elliott, How so?
17:04:02 <Cale> lizzinn: Once we've done this, we can start to simplify things
17:04:07 <elliott> hseg: well, try and write it
17:05:13 <jmcarthur> elliott: is that the way you meant to write it?
17:05:34 <elliott> uh, I didn't write anything
17:05:40 <elliott> (am I being confused for another Elliott again?)
17:05:44 <jmcarthur> (forall a. f a -> g a) -> (forall a. f a -> g a)
17:05:49 <elliott> er. oops
17:05:54 <elliott> (forall a. f a -> g a) -> t f a -> t g a
17:05:55 <elliott> of course :)
17:06:16 <jmcarthur> (forall a. f a -> t g a) -> t f a -> t g a  ?
17:06:19 <hpaste_> ctrl pasted “Tr” at http://hpaste.org/87767
17:06:22 <lizzinn> Cale: just noticed the link. looking over it now
17:06:28 <ctrl> Any suggestions how to simplify this?
17:06:37 <ctrl> It's a parsing library
17:06:46 <hseg> Hm. I regret raising the question at this late hour, and will continue discussing it tomorrow. Suffice it to be said that for any transformer t, the definition of lift won't work for t Cont?
17:06:47 <ctrl> Quite little, though
17:07:28 <Cale> lizzinn: I'm just writing an annotation now where we simplify that into something a bit saner
17:07:31 <hseg> Or did you mean that one cannot write lift for ContT?
17:07:54 <jmcarthur> ctrl:    newtype Trap x m a = Trap { runTrap :: ReaderT x m a } deriving (Functor, Applicative, Alternative, Monad, MonadPlus);  instance MonadPlus m => Monoid (Trap x m a) where mempty = mzero; mappend = mplus
17:08:43 <jmcarthur> ctrl: also, i suspect,   newtype Tr x m a = Tr { runTr :: StateT x m a }
17:08:51 <jmcarthur> deriving all that stuff
17:09:08 <jmcarthur> or were you intentionally reimplementing?
17:09:27 <ctrl> I'm using only the standard library and no language extensions
17:09:35 <ctrl> mtl is not the case
17:09:36 <jmcarthur> ah
17:09:56 <zRecursive> @unmtl StateT x m a
17:09:57 <lambdabot> x -> m (a, x)
17:10:12 <jmcarthur> transformers is haskell98 isn't it?
17:10:49 <hseg> So what do you mean when saying that Cont doesn't have hbind? That ContT doesn't have a working hbind, or that there are transformers t s.t. t Cont doesn't work with hbind
17:10:50 <hpaste_> Cale annotated “Initial translation of imperative code” with “Initial translation of imperative code (annotation)” at http://hpaste.org/87766#a87768
17:10:53 <jmcarthur> but yeah, that deriving stuff would at least need GeneralizedNewtypeDeriving
17:11:12 <jmcarthur> hseg: ContT doesn't have a working hbind, i think
17:11:57 <hseg> OK. I'll try and figure out why that's true in the next few days. Probably should understand the intuition behind Cont first, though.
17:11:57 <lizzinn> netsplits :(
17:12:14 <Cale> lizzinn: if you refresh the paste, you should see I've annotated it
17:12:23 <Cale> lizzinn: But the key piece is that initial translation
17:12:34 <Cale> lizzinn: We turn each mutable variable into a function parameter
17:12:53 <Cale> and each "line" (or convenient group of lines acting on separate mutable variables) becomes a separate function.
17:13:18 <ctrl> jmcarthur, I'm not limited to Haskell 98, I just don't like to use things I do not understand, because this is my project 'just for fun'
17:14:15 <Cale> lizzinn: Each of these functions takes the values of all the variables in scope as its parameters, and it produces as its result the function for the next line of code to be executed with whatever new values those mutable variables have.
17:14:49 <Cale> lizzinn: make sense?
17:15:19 <Cale> Anyone know what's up with all the netsplits? DDoS?
17:15:36 <hpc> 14:34 [freenode] -kloeri(~kloeri@freenode/staff/exherbo.kloeri)- [Global Notice] Hi all, apologies for the continued netsplits. We're having some issues stemming from a DDoS attack but we're working with our sponsors on attack mitigation. Thank you for using freenode.
17:16:14 <lizzinn> Cale: you're quick! reading it now
17:16:21 <jmcarthur> Cale: yeah it's a ddos
17:16:29 <ctrl> jmcarthur, if I use mtl, is there any reason `newtype' and not simply `type'?
17:16:34 <Cale> lizzinn: Well, it was mostly copy/pasting and making small adjustments
17:16:50 <hpc> ctrl: "newtype" is closer to "data" than "type"
17:16:52 <jmcarthur> ctrl: in case you want to abstract it out or distinguish it from its representation at all
17:17:08 <Eduard_Munteanu> It's close to both actually. :)
17:17:47 <hpc> ctrl: "newtype" defines a type in the same way "data" does, except it can only have one constructor and one field
17:18:03 <Eduard_Munteanu> And like 'type', it means nothing at runtime :)
17:18:43 <hpc> or if you are one of those report-reading quiche-eaters, it means that the newtype is the same size as the underlying field
17:18:48 <hpc> with no extra values or bottoms
17:18:48 <ctrl> yep, I know that, I'm actually asking would it be convenient for a hypothetical user of my library if those types are wrapped or not?
17:19:02 <Cale> lizzinn: You'll also note that we never use the value of z anywhere except inside the z argument to undoRS1 after all that.
17:19:22 <Cale> lizzinn: which means that we'll never have to compute that argument
17:19:33 <Cale> (lazy evaluation ftw?)
17:19:34 <hpc> ctrl: if you intend for your library to be for the underlying type, you'd use "type"
17:19:38 <Cale> It will however use up memory
17:19:53 <Cale> So it might be better just to eliminate the z argument altogether
17:20:15 <ctrl> I'm just asking what is more common practice. I understand that both versions would work
17:20:20 <Cale> (which is probably true of the original imperative code)
17:20:27 <hpc> ctrl: "make your code look like what it does", is my rule
17:21:00 <hpc> decide if you want your library to be extending the abilities of an existing type, or if you are defining something new
17:21:36 <hpaste_> ctrl pasted “Tokenizer” at http://hpaste.org/87770
17:21:36 <hpc> it's hard to just say one or the other
17:21:44 <ctrl> That's how I use the library
17:22:37 <hpc> i assume the type we are talking about is Tr.Tr?
17:22:51 <Cale> lizzinn: It's usually a good idea after something like this to check that all the numerical parameters to the loop are being evaluated on each step. i will be because of the guard. result however won't because there's nothing that is demanding it be evaluated, so a bang pattern for that might be a good idea since we *will* end up returning it, and the expression might be quite large by that point.
17:23:02 <hpc> or Tr.Trap?
17:23:15 <ctrl> they both can be converted using mtl
17:23:23 <ctrl> or can't they?
17:23:30 <hpc> i think for that code, i would go with newtype
17:23:56 <hpc> i don't see anything in that paste that implies some kind of knowledge of the underlying representations of things
17:24:08 <hpc> (by which i mean, i have no idea how those types are implemented just from reading your code)
17:24:30 <hpc> ctrl: so, newtype is what i would do
17:24:49 <ctrl> Thanks, I'll stick with newtype in that case
17:25:41 <ctrl> by the way, is there a way to get rid of Tr.Trap constructor on the line 58 and replace it with Tr.trap function?
17:25:51 <ctrl> I was thinking about it yet found no solution
17:26:12 <ctrl> though it seems pretty intuitive to be done
17:27:57 <lizzinn> Cale: thanks! took me a sec to follow it since im kinda new to haskell. but thats pretty neat
17:28:40 <Cale> lizzinn: So, is the fact that z isn't used a bug?
17:29:18 <lizzinn> it shouldnt be
17:29:57 <lizzinn> Cale: that was my main gripe with the code i posted
17:31:32 <ctrl> Tr.Tr stands for a step of parsing, i. e. it consumes some input, yields a value and the unconsumed input
17:31:49 <ctrl> Tr.Trap is meant to be the final step. It should consume input completely
17:32:12 <ctrl> So a user can chain some of Tr.Tr and put a Tr.Trap on top
17:35:53 <ctrl> Tr.Trap can be made a monad, but semantically it is not.
17:36:01 <ctrl> it is not used as such
17:36:18 <ctrl> nor was meant to
17:38:32 <monochrom> every trap can be made a monad :)
17:39:52 <ctrl> It becomes a monad ones you apply runTrap to it, though
17:39:57 <ctrl> once*
17:40:06 <monochrom> http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg#!i=960526421&k=tSKXkj9
17:40:39 <ctrl> Lol.
17:40:50 <ctrl> That's why ST is better.
17:41:10 <ctrl> runST and here it is, freedom :D
17:44:45 <ctrl> http://spl.smugmug.com/Humor/Lambdacats/i-8gBC6Wb/7/O/ceiling%20cat%20is%20watching%20you%20unsafePerformIO.jpg
17:47:36 <arbn> Nothing wrong with a little unsafePerformIO here and there. Depending on where "here" and "there" are, but you know.
17:48:21 <dwcook> > unsafePerformIO (return "Hello, world")
17:48:24 <lambdabot>   Not in scope: `unsafePerformIO'
17:48:36 <no-n> I think >>= should have lower precedence than $ too
17:49:36 * dwcook realizes there are extremely good reasons that unsafePerformIO is not loaded by lambdabot :P
17:49:49 <mm_freak> i think (>>=) should have much higher precedence than it currently has
17:49:55 <mm_freak> in particular higher than (<*>)
17:50:49 <mm_freak> > runST (return ())
17:50:53 <lambdabot>   ()
17:51:10 <ctrl> > import System.IO.Unsafe
17:51:13 <lambdabot>   <hint>:1:1: parse error on input `import'
17:51:18 <ctrl> :(
17:52:03 <mm_freak> > runST (unsafeIOToST (return ()))
17:52:05 <lambdabot>   Not in scope: `unsafeIOToST'
17:52:23 <ctrl> That's a hack
17:52:59 <ctrl> ST is safe to be run because all its side effects are limited to its own state.
17:53:28 <ctrl> Whilst IO can change the environment
17:53:48 <ctrl> Because it should be able to perform IO, that's why
17:54:05 <c_wraith> ST is only safe until you start using "unsafe" functions inside it. :)
17:54:14 <c_wraith> holy crap is unsafeInterleaveST unsafe.
17:54:59 <ctrl> ST itself is safe. Unsafe functions will make anything unsafe.
17:55:20 <ctrl> Even non-monadic code.
17:55:26 <jermey> hey
17:55:43 <jermey> is anyone willing to help me in private message (willing to pay for tutoring)
17:56:51 <ctrl> jermey, fine. write me a personal message
18:04:59 <cmccann> c_wraith: Oh, I tried to figure out how to make a useful ParST monad the other day, after a previous discussion in here.
18:05:19 <c_wraith> come up with anything?
18:05:33 <cmccann> not something usable.
18:05:57 <cmccann> where usable means 1) can actually do anything in parallel 2) doesn't require writing everything in CPS style
18:07:38 <cmccann> c_wraith: the basic structure amounted to nesting runST-like functions using two phantom types instead of one
18:10:13 <c_wraith> Seems like it'd be impossible to design things such that a nested action can perform mutations on a shared mutable structure so that you can guarantee they don't collide in the type system
18:10:43 <nejucomo> I have some unicode blues.
18:10:43 <cmccann> c_wraith: but I couldn't manage a way to ensure a safe fork-then-collect operation without requiring horrific CPS-style nesting with lots of higher-rank type crap
18:11:00 <c_wraith> yeah, that's the use case I was thinking of
18:11:19 <c_wraith> I guess it's saying something that there is *some* crazy type hackery that can do it
18:11:29 <c_wraith> Even if it's not useable crazy type hackery
18:11:34 <nejucomo> In emacs, I have a utf-8 haskell source file, and inside a string literal, there is the U+1d706 𝜆 "MATHEMATICAL ITALIC SMALL LAMDA" character.
18:11:37 <cmccann> c_wraith: and yes, the other pain point is that splitting a shared mutable structure between branches has to be a primitive
18:11:44 <cmccann> there's almost certainly no generic way to do that
18:11:51 <nejucomo> It renders fine in emacs.  (But not in this irc client, incidentally.)
18:12:05 <cmccann> my testing was using mutable vectors, with a "parSlice" function
18:12:17 <c_wraith> nejucomo: amusingly, your client sent it as proper UTF-8
18:12:31 <nejucomo> Parsec fails to parse that string and calls that character "\8594".
18:12:41 <nejucomo> That's in decimal, right?
18:12:46 <c_wraith> it is
18:12:58 <c_wraith> Hmm.  Is your system encoding UTF-8?
18:12:59 <nejucomo> So that corresponds to some completely unrelated unicode character.
18:13:09 <c_wraith> GHC relies on that when it attempts to decode the file
18:13:13 <nejucomo> I have no idea.  8-o
18:13:21 <c_wraith> run "locale" in a terminal
18:13:25 <nejucomo> On linux is that locale stuff?
18:13:36 <c_wraith> yes
18:13:43 <nejucomo> So, incidentally my terminal cannot display that character, but I had thought this was because my terminal did not have the proper font...
18:13:49 <nejucomo> Maybe it's locale though...
18:14:53 <cmccann> c_wraith: anyway, I gave up when it looked like the only thing that would work would end up needing some horrible monadic-pointfree-CPS'd style to use
18:15:03 <nejucomo> All of my LOCALE settings are en_US.UTF-8, except for LANGUAGE and LC_ALL which are empty, and LC_TIME which is en_DK.utf8 as all good civilized folk should have it.
18:15:07 <cmccann> and even then I'm still not 100% certain that something worthwhile is possible
18:15:30 <c_wraith> nejucomo: then I don't have any ideas
18:15:39 * nejucomo investigates how to upgrade fonts for his terminal.
18:15:55 <Saizan> nejucomo: what exactlyb
18:16:10 <Saizan> nejucomo: what exactly is failing?
18:16:32 <Saizan> nejucomo: what you described seems fine behaviour to me
18:16:34 <nejucomo> Oh…  I'm idiot.
18:16:57 <nejucomo> Parsec isn't failing on *that* character, it's referring to a different character.  It's a parser bug, not a locale/encoding problem (I hope).
18:17:40 <cmccann> c_wraith: since I did have something that "worked", in that it didn't allow anything interesting enough to cause problems, heh
18:18:11 <c_wraith> I guess that is some sort of achievement.
18:19:00 <Nisstyre-laptop> which is better: choice [p1,p2,...] or p1 <|> p2 <|> ... ?
18:19:13 <nejucomo> Aha…  I bet it's because of this:
18:19:15 <nejucomo> > isLetter '\120582'
18:19:16 <lambdabot>   True
18:19:32 <nejucomo> I had hoped the "math" lamdas would not be considered letters.
18:19:56 <nejucomo> Where "hoped" meant "assumed and wrote software based on said assumption."  :-/
18:20:42 <cmccann> c_wraith: the only thing it allowed beyond using Par and ST as they are is that an STRef-like thing could be created as an empty IVar-like thing.
18:21:57 <cmccann> there was always a strict and deterministic order on all writes because once something became a full mutable reference nobody else could read or write it
18:22:24 <c_wraith> Huh. That's an interesting solution to that.
18:25:09 <cmccann> c_wraith: it also allowed turning a mutable reference into a "final result" so that it could be consumed by another computation as such. again, absolute ordering because the original computation would be done
18:26:17 <cmccann> c_wraith: so basically, each thread could receive some number of references it could block on until they were ready, use them as mutable references, then provide a (single) mutable reference as output
18:26:35 <cmccann> c_wraith: with runST-like trickery to ensure things didn't cross over in other ways
18:27:53 <cmccann> c_wraith: the part I got stuck on was taking a "final result" which was a mutable vector, slicing that into separate mutable vectors, then recombining the final results of multiple threads using a fake parConcat that was just the original vector
18:27:55 <cmccann> if that makes sense
18:29:08 <cmccann> it still fit into the general approach being used, the problem was ensuring statically that parConcat was always and only used on vectors "created" with parSlice
18:31:01 <cmccann> c_wraith: anyway if I'd gotten that last part working I was gonna clean it up and then ask you to try and break it
18:31:03 <cmccann> but oh well :[
19:07:30 <otters> I'm guessing #yesod is my best bet for yesod help, although it's dead
19:08:38 <monochrom> I don't know yesod
19:09:00 <monochrom> a live channel is not a better channel
19:34:47 <jekor> Why does `error "Something"` result in an exception but `return $ error "Something"` result in printing the error to stdout and termination of the thread?
19:39:07 <Saizan> jekor: it's all a matter of when (error "Something") gets forced
19:39:48 <Saizan> jekor: wrapping it in return makes it slip past catch for example
19:40:37 <Nisstyre-laptop> > take 2 [1,2,error "woops"]
19:40:39 <lambdabot>   [1,2]
19:45:54 <jekor> Saizan: Thanks.
19:46:20 <zRecursive> @ty [1,2,"a"]
19:46:21 <lambdabot>     No instance for (Num [Char])
19:46:22 <lambdabot>       arising from the literal `1'
19:46:22 <lambdabot>     Possible fix: add an instance declaration for (Num [Char])
19:48:41 <rfw> hm, i'm not entirely sure about GADTs, but in a program i've been writing i've had to supplement all my functions with typeclass contexts when i want to use them with my data type
19:48:55 <rfw> does using GADTs mean i can move the typeclass context into the data type and then eliminate all the typeclass contexts from my functions?
19:49:54 <elliott> sometimes, yes
19:50:01 <elliott> though it's often not a good idea
19:50:30 <rfw> hm, could you elaborate?
19:50:54 <elliott> well, often you don't need the same context for every operation and weaker constraints will suffice for some, etc.
19:51:02 <elliott> and you lose that granularity with a dictionary packing GADT approach
19:51:17 <elliott> it also has some operational details (in terms of it stores an extra pointer to the dictionary and stuff in practice, I think)
19:51:23 <elliott> (might hurt class method inlining? not sure)
19:51:24 <rfw> ah, i see
19:52:01 <rfw> yeah i just want to carry an HDBC connection around without having to specify it everywhere
19:55:27 <Nisstyre-laptop> gah, why doesn't Attoparsec have sepEndBy1?
19:59:33 <jermey> yo
19:59:43 <jermey> anyone want to help a soul with GADT in private chat
19:59:49 <jermey> willing to pay for your time
20:00:03 <jermey> i just want bounce questions etc off you
20:02:46 <jekor> Oh, I forgot I was working with MonadCatchIO...
20:08:27 <Watabou> hmm I'm trying to implement my own version of take and have this type signature: take' :: (Int a) -> [a] -> [a]. ghci says that Int is applied for too many arguments.
20:08:48 <Watabou> I checked :t take and it just has
20:08:51 <Watabou> :t take
20:08:52 <lambdabot> Int -> [a] -> [a]
20:09:06 <Watabou> that without (Int a) like I have
20:09:16 <luite> why do you want (Int a) ?
20:09:19 <Watabou> what's the difference and why can't I put an a there?
20:09:43 <luite> Int is a type, it doesn't have any parameters
20:10:15 <Watabou> Oh oops then that should be (Int a) =>
20:10:33 <Watabou> wait but why does :t take show it with ->... hmm this is confusing
20:10:34 <luite> oh, then you might want Integral a =>
20:11:11 <Watabou> hmm okay but what's the difference if I use Integral vs Int?
20:11:26 <sellout-1> But if you’re defining take, you don’t want Integral a =>, you want Int.
20:11:43 <sellout-1> Or, Integral a => a -> [b] -> [b]
20:11:45 <luite> Watabou: Integral is a typeclass, Int is a type (which happens to be an instance of Integral)
20:12:09 <Watabou> hmm okay
20:12:18 <sellout-1> * you want Int ->
20:12:33 <Watabou> but why instead of Integral, I'm confused on that part
20:13:05 <sellout-1> "Integral a =>" is not a parameter, it’s a constraint. "Int ->" is a parameter of type Int.
20:14:30 <Watabou> oh right but can't I just write a -> [a] -> [a] and add a type constraint for a?
20:14:50 <luite> Watabou: you can, but do you really want the first a to be the same as the other two?
20:15:01 <sellout-1> Watabou: Yeah, that was the "Integral a => a -> [b] -> [b]" – but what luite said.
20:15:23 <Watabou> oh hmm that makes sense.
20:16:55 <Watabou> okay cool, I get it now, thanks luite and sellout-1.
20:18:15 <Watabou> hmm I got it pretty similar to what the author has on LYAH book, although I missed the base case for <= 0. I just had 0.
20:18:35 <BufferUnderpants> Hello, I'm having a rather noobish problem here...
20:18:49 <BufferUnderpants> Anyone mildly familiar with the FunGEn library?
20:18:53 <Watabou> And his version of take has Num i, Ord i as a type constraint too.
20:19:01 <BufferUnderpants> I'm mostly having typecheck problems, anyway
20:19:09 <luite> those are not necessary since they're superclasses of Integral
20:19:29 <Aetherspawn_> BufferUnderpants, people can probably help you if you just hpaste.org the problem
20:19:33 <Aetherspawn_> Otherwise, it's impossible.
20:19:38 <luite> Watabou: the function is known as genericTake in the base library by the way, Data.List
20:19:47 <luite> so you can also check your result there
20:19:52 <oio> hey i want to make a function that may take 2 or 3 arguments, so far sumlist xs xz xa 	| null xa = show (sum $ xs ++ xz) 	| otherwise = show (sum $ xs ++ xz ++ xa)  but when third arguments isnt supplied if wont work
20:20:01 <Watabou> hmm okay thanks
20:23:03 <dmj> newtype (Monad m) => MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
20:23:19 <dmj> What does this error mean?     Illegal datatype context (use -XDatatypeContexts):
20:24:31 <dmj> nevermind
20:27:33 <elliott> dmj: it means don't do that :P
20:27:55 <Aetherspawn_> (or use the language extension)
20:30:02 <elliott> Aetherspawn_: no, that's what it doesn't mean
20:30:12 <elliott> they were removed from the language and have a scary warning in GHC for a reason
20:30:31 <Aetherspawn_> :o
20:32:03 <ezyang_> I wonder, do exotic recursion schemes have good category theoretic accounts
20:33:56 <doomlord> does haskell have an equivalent of c++ std::array<T,N>
20:34:13 <hpaste_> “Some guy, taken from Andre Furtado” pasted “bastardized pong” at http://hpaste.org/87783
20:34:39 <BufferUnderpants> Well, I'm "Some guy"
20:35:01 <BufferUnderpants> The question may be a bit too open
20:35:29 <BufferUnderpants> More details in the source code
20:35:54 <ezyang_> doomlord: Data.Array. Maybe also consider looking at the 'uvector' package
20:37:41 <dolio> uvector is old.
20:37:47 <dolio> vector is the new one.
20:38:09 <ezyang_> oh, right-o
20:39:04 <doomlord> at the lowest level, it would be a tuple perhaps
20:39:36 <doomlord> isn't Array a synamic array- i''m after something which has no size information: the size is infered at compile time
20:39:52 <doomlord> isnt' Array a Dynamic array^
20:40:15 --- mode: adams.freenode.net set +o ChanServ
20:40:35 <doomlord> i could implement it manually for the N's i need... and look into template haskell to generate..
20:45:11 <jmcarthur> doomlord: there's the deprecated and unmaintained vector-static package. it's better as a proof of concept than as anything usable
20:45:57 <JoeyA> doomlord: Compile-time array length means type-level numbers.  GHC is on the verge of supporting them, but I don't know what the current status is.
20:46:30 <doomlord> i think i can fudge it, i dont need many cases
20:48:31 <hpaste_> natnyr pasted “natnayr” at http://hpaste.org/87784
20:49:26 <natnayr> hi, i have a problem with my line 26 in that link.. need to pick off a single type from a GADT datatype
21:10:50 <natnayr> hello, anyone there?
21:13:27 <shachaf> There is only silence and some second-hand clothes.
21:13:52 <natnayr> lol
21:13:58 <shachaf> (And about a thousand other people. If you have a question, you should just ask.)
21:14:18 <natnayr> Couldn't match expected type `Formula t0' with actual type `Term a -> Formula as'
21:14:47 <natnayr> so um i need to get "Formula as" from the "Formula t0"
21:15:16 <natnayr> not sure how to split a GADT
21:15:22 <shachaf> @paste your code and full error message when you ask a question like that. :-)
21:15:23 <lambdabot> Haskell pastebin: http://hpaste.org/
21:15:34 <natnayr> kk
21:15:36 <natnayr> hold on
21:15:37 <shachaf> It sounds like you're not passing an argument to a function.
21:15:49 <shachaf> Look at those two types carefully and work out why they are what they are.
21:16:10 <natnayr> yeah ur right, its a function but i need to pass it an arguement
21:16:15 <natnayr> to get the Formula as
21:17:37 <shachaf> Is an ur-right something more fundamental than a regular right?
21:18:16 <hpaste_> natnyr pasted “natnyr” at http://hpaste.org/87788
21:18:57 <natnayr> line 65
21:19:22 <natnayr> yeah i would say so.. i know how to build GADTs but not how to deconstruct them..
21:19:59 <seenah> I'm just learning haskell, and I'm working on a problem listed here: http://www.haskell.org/haskellwiki/99_questions/1_to_10 (question 3). I'm looking at the solutions they list, and I'm not sure why you can't just do: elementAt x y = x !! (y-1)
21:20:53 <tikhonjelvis> wait, why (y - 1)?
21:21:00 <seenah> zero indexing?
21:21:14 <tikhonjelvis> > [1,2,3] !! 0
21:21:17 <lambdabot>   1
21:21:24 <tikhonjelvis> it already does 0 indexing
21:21:41 <natnayr> seenah: think there are plenty of index getting functions in haskell
21:21:50 <tikhonjelvis> or does the problem want you to start with 1?
21:21:54 <natnayr> elem?
21:21:57 <Cale> seenah: you can do that? They list that as the first solution, don't they?
21:21:59 <seenah> well the problem states " Find the K'th element of a list. The first element in the list is number 1"
21:22:03 <tikhonjelvis> ah
21:22:04 <tikhonjelvis> right
21:22:18 <tikhonjelvis> the main reason not to do that is that it won't really teach you anything
21:22:27 <tikhonjelvis> !! is itself a normal function from the standard library
21:22:30 <seenah> Cale: well, not really, they try to reimplement it w/o using the !!
21:22:41 <Cale> elementAt :: [a] -> Int -> a
21:22:42 <Cale> elementAt list i    = list !! (i-1)
21:22:51 <Cale> ^^ copy/pasted from the solutions pag3e
21:22:53 <Cale> -3
21:23:29 <tikhonjelvis> I mean, all the actual list logic is hidden away in the implementation of !!
21:23:42 <seenah> Cale: ha, you're right, sorry. I must have misread that this wasn't supposed to work based on skimming the text above it.
21:24:06 <tikhonjelvis> coincidentally: in practice, the !! operator is very rarely used
21:24:11 <Cale> huh, no solution using lookup :)
21:24:37 <seenah> tikhonjelvis: really? Is there a reason for that?
21:24:46 <tikhonjelvis> a couple of reasons, yes
21:24:52 <tikhonjelvis> for one, people don't like runtime errors
21:24:57 <tikhonjelvis> > []  !! 0
21:24:58 <natnayr> hi, anyone able to look at mine?
21:25:00 <lambdabot>   *Exception: Prelude.(!!): index too large
21:25:02 <shachaf> > preview (ix 3) "hello"
21:25:04 <shachaf> > preview (ix 10) "hello"
21:25:06 <lambdabot>   Just 'l'
21:25:06 <lambdabot>   can't find file: L.hs
21:25:16 <tikhonjelvis> also, if you need random access, chances are you don't want to use a list
21:25:33 <seenah> tikhonjelvis: makes sense.
21:25:35 <Cale> natnayr: I don't understand what you're asking
21:25:51 <natnayr> natnyr pasted “natnyr” at http://hpaste.org/87788
21:26:01 <Cale> Yes, I saw that
21:26:12 <natnayr> line 65, i need the function eqn (which is )
21:26:18 <tikhonjelvis> Haskell programmers tend to be far more wary of runtime errors than most people
21:26:34 <natnayr> "Term a -> Formula as", and i need to derive just the "as" bit
21:26:56 <seenah> tikhonjelvis: not that I'm going to dispute that... but why is that the case?
21:27:00 <natnayr> its like spliting a function to get the data
21:27:00 <shachaf> natnayr: 21:15 <shachaf> @paste your code and full error message when you ask a question like that. :-)
21:27:05 <Cale> natnayr: ?
21:27:10 <seenah> (if you don't mind me asking)
21:27:23 <Cale> natnayr: Do you have a value of type Term a?
21:27:38 <tikhonjelvis> well, in Haskell, you can catch many of those potential errors at compile time
21:27:47 <natnayr> Cale: yeah it does
21:27:59 <tikhonjelvis> also, in normal code, dealing with exceptions (like the out of index exception) is very awkward
21:28:19 <tikhonjelvis> you could write a safe version that returned a Maybe value instead, if you really wanted to
21:28:22 <Cale> natnayr: where?
21:28:24 <seenah> tikhonjelvis: as opposed to a language like java? (to your first statement)
21:28:33 <hpaste_> natnyr revised “natnyr”: “natnyr” at http://hpaste.org/87788
21:28:40 <tikhonjelvis> oh yes, definitely
21:28:47 <seenah> tikhonjelvis: interesting.
21:28:49 <natnayr> shachaf: ok, ive pasted the error
21:28:58 <Cale> natnayr: Do you know what the type A -> B means?
21:29:11 <tikhonjelvis> the most immediate example is null-pointer errors: in Haskell, you can't have them by default
21:29:25 <seenah> wut? wow.
21:29:33 <tikhonjelvis> if something can be null you explicitly use wrapper to represent that
21:30:04 <seenah> so what happens if it is acually null?
21:30:13 <tikhonjelvis> well, it can't be
21:30:19 <seenah> I see.
21:30:24 <natnayr> i do know that if i do Con A, it gives the Term t
21:30:42 <shachaf> natnayr: Don't tell me. I'm not volunteering to help you with the problem. I'm just helping with asking questions that people can hope to answer.
21:30:45 <Cale> natnayr: I'm confused about what you're confused about, and I'm not sure what your program is supposed to do
21:30:50 <seenah> tikhonjelvis: is this a consequence of strong typing?
21:31:12 <tikhonjelvis> "strong" typing isn't really a well-defined term
21:31:21 <tikhonjelvis> it *is* a consequence of having a *static* type system
21:31:30 <natnayr> shachaf: okok
21:31:36 <tikhonjelvis> and also not having nullable values by default
21:31:42 <Cale> natnayr: eqn is a function which expects an Term a as its argument, and you're giving none
21:31:55 <seenah> ah,  well sorry for my confused nomenclature. That is awesome though
21:32:12 <tikhonjelvis> it's nice not to worry about that sort of thing
21:32:25 <Cale> natnayr: Does that make sense?
21:32:29 <tikhonjelvis> honestly, I think that might be the main reason I like Haskell: there are just fewer things to worry about
21:32:34 <natnayr> Cale: yeah it does
21:32:59 <natnayr> Cale: so if i do "Term eqn", will it give me the Formula as?
21:33:37 <natnayr> Cale: that shouldnt work..
21:33:41 <seenah> tikhonjelvis: I can def relate. I intially loved java for its typing ... I can see it has nothing on haskell though
21:34:01 <seenah> ... forgetting about no side effecting  entirely
21:34:08 <seenah> <3
21:35:38 <seenah> well in either event, thanks so very much for the clarification!
21:37:01 <tgeeky> hm. it seems as if freenode lost a few US servers! Just so happened to be the first two servers I had in my list :(
21:37:19 <Cale> natnayr: If you have a function f :: A -> B, and you have a value x :: A, then f x :: B
21:37:29 <fruitFly> What's wrong with this? Using Data.Bits? http://ideone.com/ai4P6P
21:37:53 <Cale> fruitFly: Int x
21:38:07 <Cale> fruitFly: Int isn't a data constructor, so you can't pattern match against it
21:38:37 <luite> tgeeky: they've been ddossed a bit, perhaps they made them unreachable from your ip
21:38:44 <Cale> Perhaps you just wanted x, y :: Int
21:38:45 <fruitFly> Cale: then what the hell...
21:38:46 <Cale> x = 0
21:38:49 <Cale> y = 1
21:38:49 <Cale> ?
21:39:15 <fruitFly> Cale: perhaps... what's the difference?
21:39:28 <Cale> If you write
21:39:32 <Cale> C x = y
21:39:37 <Cale> where C is a data constructor
21:39:41 <fruitFly> Cale: how does one just initialize an Int value in a single line?
21:40:06 <Cale> then it pattern matches away the constructor, defining x to be the thing which C is applied to
21:40:13 <Cale> in the value y
21:40:26 <Cale> For example...
21:40:31 <Cale> > lookup 4 [1,2,3]
21:40:33 <lambdabot>   Nothing
21:40:36 <Cale> > lookup 2 [1,2,3]
21:40:38 <lambdabot>   Just 2
21:40:48 <Cale> heh...
21:40:57 <Cale> > lookup 2 (zip [1..] "hello"
21:40:58 <Cale> > lookup 2 (zip [1..] "hello")
21:40:59 <lambdabot>   <hint>:1:28: parse error (possibly incorrect indentation)
21:41:01 <lambdabot>   Just 'e'
21:41:11 <Cale> > let Just x = lookup 2 (zip [1..] "hello") in x
21:41:14 <lambdabot>   'e'
21:41:35 <Cale> (sorry about the mess -- I should probably be asleep)
21:42:11 <Cale> But you see, we pattern match the pattern Just x against the expression lookup 2 (zip [1..] "hello") which is equal to Just 'e'
21:42:14 <Cale> and it binds x to 'e'
21:42:18 <fruitFly> Cale: lol.. me too. I'm not even sure what a data constructor is..
21:42:40 <fruitFly> Cale: I see that
21:42:41 <Cale> If you just want to define values of type Int, you can just write x = 0 :: Int
21:43:12 <fruitFly> Cale: so if I write Int x = 0 it thinks Int is a function when it really isn't?
21:43:24 <Cale> http://ideone.com/lGZKUd
21:43:28 <Cale> yes
21:43:39 <Cale> It thinks Int is a special kind of function called a data constructor
21:43:59 <natnayr> Cale: hey, thanks for that last one, it makes sense but with the code i currently have i dont really see a solution..
21:45:11 <fruitFly> Cale: well that (.&.) didn't do what I wanted... how do I combine to bits (or ints) ... like 1 + 0 + 1 = 101?
21:45:31 <Cale> .&. is bitwise and
21:45:46 <fruitFly> so why is my output 0?
21:45:47 <Cale> What result were you expecting?
21:45:54 <Cale> Because the bitwise and of 0 and 1 is 0
21:47:02 <Cale> false AND true is false.
21:47:51 <fruitFly> Cale: how do I concatenate bits?
21:48:22 <Cale> You could do a shift and then a bitwise OR
21:48:55 <Cale> But how many bits do you want to shift by?
21:50:12 <fruitFly> Cale: i dn't know... I will have to look at those functions first... I just want to be able to convert 2 hex chars to a byte efficiently.
21:50:14 <natnayr> Cale: do u know of any examples i could read up? sry to bother u mate, im just not really getting it
21:50:31 <Cale> natnayr: Examples of what?
21:50:39 <Watabou> is there a way to view the source code of built in functions? I thought :list would do it and I tried doing :list map but it didn't work
21:50:47 <Watabou> in ghci I mean
21:50:52 <Cale> fruitFly: Use the stuff in Numeric
21:51:06 <natnayr> function f :: A -> B, value x :: A, then f x :: B
21:51:19 <Cale> > readHex "b6"
21:51:22 <lambdabot>   [(182,"")]
21:51:54 <Cale> natnayr: sure...
21:51:58 <Cale> :t chr
21:52:00 <lambdabot> Int -> Char
21:52:05 <Cale> > chr 5
21:52:07 <lambdabot>   '\ENQ'
21:52:11 <Cale> :t chr 5
21:52:15 <lambdabot> Char
21:52:46 <fruitFly> Cale: I'm creating the implementation from scratch for learning purposes and a series of challenges... I was advised to convert 2 hex chars to type [Word8]
21:52:54 <fizruk> > chr 33
21:52:57 <lambdabot>   '!'
21:55:21 <Cale> fruitFly: Well, in that case, you'll want to write a mapping from a single hex Char to a Word8 value between 0 and 15 first.
21:55:55 <Cale> fruitFly: Then to do a pair of Chars, apply that function to each of them, and multiply the result of one by 16 before adding to the other.
21:56:37 <Cale> Watabou: no, in fact, it might not even be anywhere on your machine
21:56:54 <Cale> Watabou: The libraries are compiled to machine code
21:57:01 <fruitFly> Cale: I know how to convert hex char to base 10... but I don't know how to build a Word8 ?
21:57:04 <Watabou> oh
21:57:11 <Cale> Watabou: However, in the documentation, there are links to source
21:57:21 <fruitFly> I was advise to look at Data.Word and Data.bits ... but I'm not sure where to start?
21:57:59 <Cale> fruitFly: Word8 is just another numeric type like Int, you can just tell it to use that type instead of Int, and all the usual numeric operations will work.
21:58:14 <Cale> You don't need Data.Bits
21:58:21 <Cale> You just need to know how to multiply by 16
21:58:37 <Watabou> okay great, where is the documentation again? Is it possible to get that in the terminal similar to perldoc?
21:58:49 <Cale> Watabou: For which library?
21:59:10 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html -- a lot of the basic stuff is here
21:59:14 <Watabou> Oh, the ghci's default one. I think it's called Prelude?
21:59:32 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/Prelude.html
21:59:45 <fruitFly> what is numeric? ... Data.Numeric or something? modules vs packages vs instances classes etc. confuse me... i dn't understand all the relationships yet.
22:00:28 <Cale> fruitFly: I just mean it's an instance of Num
22:00:56 <Cale> I wasn't using the word numeric in a formal sense there, I just mean a type of numbers.
22:01:01 <Watabou> Cale: thanks but I don't see the default function that ghci has in there...
22:01:09 <Watabou> functions*
22:01:11 <Cale> Watabou: which function?
22:01:19 <Watabou> for instance, how can I view the source code of tail
22:01:22 <Watabou> or map
22:01:30 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/src/GHC-List.html#tail
22:01:34 <fruitFly> Cale: what is an instance of Num?
22:01:45 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/Prelude.html#v:tail
22:01:53 <Cale> ^^ tail *is* listed there
22:02:08 <Cale> You may find it more comfortable to read the Report's version of the Prelude
22:02:20 <mauke> @where report
22:02:20 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
22:02:22 <Cale> http://www.haskell.org/onlinereport/standard-prelude.html
22:02:49 <Cale> It's written for clarity rather than efficiency
22:03:00 <Cale> The real implementations of many things are messier
22:03:07 <fizruk> fruitFly: Word8 is an instance of Num, just as Int is. So you can use basic numeric operations such as (+), (*), etc.
22:03:27 <Watabou> hmm okay, I think this will do for now, not as nice as perldoc is though but oh well
22:03:40 <mauke> perldoc doesn't show you the source at all
22:03:47 <fruitFly> fizruk: ok thanks.
22:03:56 <mauke> perldoc doesn't do hyperlinks either
22:04:00 <Watabou> Yeah but I like how it shows you examples and a clear definitions
22:04:02 <Cale> fruitFly: Num is a type class which defines the operations (+), (-), (*), negate, abs, signum, and fromInteger
22:04:07 <mauke> Watabou: ...
22:04:34 <Cale> fruitFly: fromInteger in particular is used to interpret numeric literals, like when you write 6 in your code, what it really means is  fromInteger (6 :: Integer)
22:04:34 <mauke> that's like saying you prefer wordpad over acroread because it has better stories
22:05:02 <dmwit_> Examples come from the person writing the documentation, not from the tool used to generate the HTML.
22:05:10 <fruitFly> Cale: fizruk is there a way to concatenate Nums? like 1111 + 0000 = 11110000 ?
22:05:22 <Watabou> well perldoc is pretty convenient
22:05:26 <Cale> fruitFly: multiply by 16 and add
22:05:47 <dmwit> (How do you know there are four zeros?)
22:06:01 <mauke> THERE ARE FOUR ZEROES!
22:06:05 <fruitFly> Cale: aah... is that really the most efficient way? I guess so, right?
22:06:34 <sellout> fruitFly: Well, you _could_ do something like: snocBit xs x  = shift xs 1 + x
22:06:40 <Cale> fruitFly: If it's too inefficient, you'll find out from the profiler
22:06:49 <sellout> foldl snocBit 0 [1,1,1,1,0,0,0,0]
22:06:55 <sellout> … but, you probably don’t want to :)
22:06:58 <Cale> Just write the code and find out if it's efficient enough or not
22:07:17 <fruitFly> Cale: Will do Master Cale!
22:07:20 <tikhonjelvis> My usual rule of thumb is that if it terminates, it's efficient enough
22:08:45 <fruitFly> Cale: where can I read about Num and the things attached to it?
22:08:50 <fruitFly> Cale: functions etc.?
22:09:07 <dmwit> ?where report
22:09:07 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
22:09:08 <fizruk> > foldl (\xs x -> shift xs 1 + x) 0 [1,1,1,1,0,0,0,0]
22:09:11 <lambdabot>   240
22:09:12 <Cale> fruitFly: Well, it's defined in the Haskell Prelude
22:09:22 <Cale> fruitFly: Also, most Haskell tutorials should talk about it
22:09:25 <fruitFly> Cale: ok .. what about this http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Num
22:09:37 <Cale> fruitFly: yes, that's it
22:09:38 <fizruk> > foldl (\xs x -> shift xs 1 + x) 0 [1,1,1,1,0,0,0,1]
22:09:41 <lambdabot>   241
22:09:51 <fruitFly> Cale: what about hackage? what's a package in the first place?
22:09:57 <sellout> fizruk: Do you doubt my function? ;)
22:10:17 <fizruk> sellout: I thought there was one extra shift
22:10:39 <Cale> fruitFly: Hackage is http://hackage.haskell.org/packages/archive/pkg-list.html
22:11:01 <mauke> a package is a collection of modules
22:11:24 <Cale> http://www.haskell.org/cabal/users-guide/#whats-in-a-package -- description of what a package consists of
22:12:28 <fruitFly> Cale: thanks!
22:15:06 <blaenk> if you guys had a list of numbers, how would you structure that list or what would you do to eventually generated a table of contents with nesting?
22:15:22 <blaenk> I've been stuck on this for a while. I was thinking a tree
22:15:22 <elliott> I would nest it in the first place
22:15:37 <elliott> the tree type in Data.Tree may be good
22:15:37 <blaenk> no choice, I'm just getting the list of numbers
22:15:44 <blaenk> cool thanks will look at that
22:16:22 <Cale> Are the elements of the list actually numbers or lists of numbers?
22:16:29 <Cale> (separated by dots)
22:16:32 <blaenk> just a flat list of numbers :(
22:16:35 <blaenk> no, yeah numbers
22:16:44 <blaenk> the numbers reflect the level of headers in an html document
22:16:54 <blaenk> so <h3> would be a number 3 in the list
22:17:01 <Cale> ah, okay
22:18:10 <Cale> > groupBy (<) [1,2,3,4,3,4,1,2,4,6,1,3]
22:18:13 <lambdabot>   [[1,2,3,4,3,4],[1,2,4,6],[1,3]]
22:18:24 <Cale> ^^ you might want to abuse groupBy in this way :)
22:18:36 <blaenk> haha nice, hadn't thought of that
22:18:48 <elliott> that violates the Report's specification of groupBy >:(
22:19:02 <Cale> I really wish the Report simply specified groupBy to work the way that it actually does
22:19:04 <blaenk> how does that even work lol, gonna check the docs
22:19:35 <elliott> or at least base's
22:19:38 <elliott> The predicate is assumed to define an equivalence.
22:19:48 <blaenk> ohhhh
22:20:45 <Cale> groupBy f xs satisfies the property that concat (groupBy f xs) = xs, and that all (not . null) (groupBy f xs), and such that for each list (y:ys) in groupBy f xs, we have all (f y) ys
22:21:09 <Cale> and the list of lengths of the lists produced by groupBy is lexicographically maximal
22:21:23 <Cale> among all those satisfying the previous properties
22:21:55 <Cale> That's how I'd specify it, anyway
22:22:07 <elliott> it's so wrong though. :(
22:22:15 <Cale> oh?
22:22:38 <blaenk> I think I might look into a tree though. so Data.Tree is what I should look at?
22:22:48 <blaenk> or should I just make my own make-shift tree type etc.
22:22:52 <mauke> or just define your own, yeah
22:23:01 <blaenk> alright
22:23:02 <mauke> I love trees. they're so easy
22:23:16 <Cale> I've solved this same problem before and I used groupBy in order to make a Data.Tree
22:23:24 <blaenk> I'm thinking I'll make a tree type and then initialize it from the list of numbers and then somehow map over that to generate html with either blaze or pandoc
22:23:26 <Cale> One of the few times I've ever actually used Data.Tree
22:23:40 <mauke> :t Node
22:23:44 <lambdabot> a -> Forest a -> Tree a
22:25:13 <mauke> :t let flomp = map (\(x : xs) -> Node x (flomp xs)) . groupBy (<) in flomp
22:25:19 <lambdabot> Ord a => [a] -> [Tree a]
22:25:45 <mauke> > let flomp = map (\(x : xs) -> Node x (flomp xs)) . groupBy (<) in flomp [1, 2, 1, 2, 3]
22:25:47 <lambdabot>   [Node {rootLabel = 1, subForest = [Node {rootLabel = 2, subForest = []}]},N...
22:27:16 <mauke> :t let flomp = map (liftA2 Node head (flomp . tail)) . groupBy (<) in flomp
22:27:18 <lambdabot> Ord a => [a] -> [Tree a]
22:31:13 <blaenk> I just realized, would a tree work in this situation? say I have two number 1's, but each one has different text to be shown in that table-of-contents item (corresponding to a different header). in the tree, wouldn't they become merged?
22:31:32 <elliott> you would have a "number 0" node above them all
22:31:40 <elliott> and then all the number 1s as children
22:32:00 <blaenk> ah okay that makes sense
22:32:10 <mauke> a Data.Tree is a list of nodes anyway
22:32:15 <mauke> well, a forest is
22:32:19 <blaenk> cool
22:32:36 <mauke> (and that's what my function gives you)
22:32:50 <blaenk> nice, thanks a ton mauke I'll play around with that
22:36:36 <fruitFly> is Num a type or typeclass? And Int is a data type under Num?
22:36:46 <blaenk> mauke: excuse my ignorance but why can't I bind flomp in ghci and then play with it like flomp [1, 2, 3] etc.? I get a 'No instance for (Num ()) arising from literal '1'
22:37:05 <blaenk> I just did: let flomp = map (\(x : xs) -> Node x (flomp xs)) . groupBy (<)
22:37:14 <mauke> monomorphism restriction, probably
22:37:18 <blaenk> thought so
22:37:20 <blaenk> thanks
22:37:26 <mauke> do you know how to work around?
22:37:45 <mauke> fruitFly: Num is a class, Int is a type that is an instance of Num
22:37:45 <fruitFly> Is Int a type of the typeclass Num?
22:37:46 <blaenk> nope, heh, was gonna get the type and then create a type annotation
22:37:58 <blaenk> but I don't know if that works in ghci
22:38:06 <mauke> blaenk: ghci -XNoMonomorphismRestriction
22:38:06 <blaenk> creating a type annotation that is
22:38:11 <blaenk> oh, okay thanks
22:38:21 <fruitFly> mauke: Thanks... and a typeclass would be like Eq, ord etc.?
22:38:23 <mauke> blaenk: or let flomp x = (map (\(x : xs) -> Node x (flomp xs)) . groupBy (<)) x
22:38:25 <blaenk> hey there's no way to enable those extensions once already in ghci right? because the runtime is up by then?
22:38:33 <blaenk> oh yeah, forgot about that particular workaround. thanks!
22:38:41 <mauke> blaenk: or add an explicit signature (but that doesn't help when that's what you're trying to figure out)
22:39:04 <blaenk> works now :)
22:39:16 <mauke> fruitFly: yes, examples of classes include: Eq, Ord, Num, Show, Read, Monoid, Functor, ...
22:39:46 <fruitFly> mauke: OOOh Ok.. so a class and type class are the same.. thanks )
22:39:47 <fruitFly> :)
22:40:49 <mauke> er, yes
22:41:04 <mauke> type classes are the only kind of classes Haskell has
22:42:01 <blaenk> mauke: this works perfectly :) now I just need to make it conform to my data structure but that shouldn't be a problem
22:42:33 <mauke> .oO( unsafeCoerce )
22:42:33 <blaenk> mauke: just need a groupBy definition for my data structure I think?
22:42:47 <mauke> @src unsafeCoerce
22:42:47 <lambdabot> Source not found. Just what do you think you're doing Dave?
22:42:51 <mauke> @src groupBy
22:42:52 <lambdabot> groupBy _  []       =  []
22:42:52 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
22:42:52 <lambdabot>     where (ys,zs) = span (eq x) xs
22:42:59 <mauke> blaenk: or convert your data structure to a list
22:43:22 <blaenk> oh, what I mean is, I do have a list, but it's not simply [Int] but [SomeStruct Int Blah]
22:43:29 <fruitFly> mauke: So Int is contained in prelude but Word8 isn't? How do I know what instances are in and excluded from prelude?
22:43:56 <mauke> blaenk: groupBy (comparing theIntField)
22:44:02 <blaenk> right :) jsut realized that
22:44:04 <blaenk> thanks a ton mauke
22:45:12 <blaenk> hey how can I find out what mapping over a Data.Tree is? I'm looking at the docs but I only see that there's an instance for it
22:45:15 <blaenk> *is like
22:45:27 <mauke> fruitFly: I think an instance is only in the Prelude if both the type and the class are
22:45:51 <mauke> blaenk: isn't there only one thing it could be?
22:46:03 <blaenk> rootLabel?
22:46:08 <mauke> ?
22:46:17 <mauke> I'm assuming you mean Functor, btw
22:46:23 <blaenk> yeah functor
22:46:34 <fruitFly> mauke: So is Data.Word the class? And is there a Data.Int?
22:46:42 <blaenk> all I'm wondering is when I map over the tree, what value/type I get, I guess it's something obvious but it's escaping me
22:46:47 <mauke> fruitFly: Data.Word is a module, not a class
22:46:53 <blaenk> oh the Node right
22:46:53 <mauke> @index Int8
22:46:53 <lambdabot> Data.Int, Foreign
22:46:54 <blaenk> heh -_-
22:47:00 <mauke> fruitFly: yes, there's a Data.Int
22:48:48 <fruitFly> maiso what class is in prelude for Int?
22:49:10 <fruitFly> mauke: if data.int is only a module?
22:49:26 <fruitFly> mauke: read the comment above that 1 first
22:49:28 <mauke> I don't understand the question
22:52:58 <fruitFly> mauke: you said something is in prelude if the type AND class are in prelude... Where is the Int type AND class in the prelude doc?
22:53:30 <mauke> I didn't say "something", I said "instance"
22:53:33 <parahsailin> Int is an instance of many classes in prelude
22:53:39 <mauke> which class are you talking about here?
22:54:31 <parahsailin> @instances Ix
22:54:32 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
22:54:39 <parahsailin> @instances Ord
22:54:40 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
22:54:44 <mauke> Int is in Prelude, Eq is in Prelude, Ord is in Prelude, Show is in Prelude
22:55:00 <mauke> 'instance Eq Int' is in Prelude, 'instance Ord Int' is in Prelude, 'instance Show Int' is in Prelude
22:57:24 <fruitFly> mauke ooh ok... so is Num Word8 in the prelude?
22:57:41 <parahsailin> @instances Num
22:57:43 <lambdabot> Double, Float, Int, Integer
22:57:52 <parahsailin> nope?
22:58:04 <mauke> no, because Word8 is not in the Prelude
22:58:47 <fruitFly> mauke:  parahsailin why not? I see it as an instance of Num in the documentation?
22:58:59 <cmccann> hm. adding bang patterns to function arguments that I expect to always be forced made the program slower.
22:59:09 <cmccann> clearly GHC is smarter than I am about optimizing.
22:59:46 <dmwit> Perhaps it is not clear that "prelude" is a technical term here.
23:00:04 <dmwit> "in the prelude" doesn't mean merely "available", it means "you get it without explicitly writing 'import ...'".
23:00:07 <parahsailin> @faq does ghc have congress with the beast?
23:00:07 <lambdabot> The answer is: Yes! Haskell can do that.
23:01:20 <Hafydd> Hahah.
23:01:48 <Hafydd> @instances Show
23:01:50 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
23:02:03 <Hafydd> > (1,2,3,4,5)
23:02:07 <lambdabot>   (1,2,3,4,5)
23:02:14 <Hafydd> Lies!
23:03:44 <fruitFly> dmwit: so how do I know what I need to import versus not import?
23:03:52 <fruitFly> dmwit: trial an error?
23:03:55 <natnayr> Hi, i need help with this, http://hpaste.org/87788, on line 65, i need to get the Formula as from there.. Could someone correct my code pls?
23:04:02 <fruitFly> dmwit: because that's what I've been doing as a nub
23:04:03 <parahsailin> open ghci, type :browse
23:04:10 <parahsailin> thats what you dont need to import
23:04:15 <parahsailin> everything else, you do
23:04:18 <dmwit> fruitFly: ...read the documentation?
23:05:52 <fruitFly> dmwit: I'm in prelude doc.. I'll look harder I guess
23:06:45 <dmwit> I am not confident I have understood what information you want yet.
23:07:43 <cmccann> but are you confident that you haven't understood?
23:08:00 <fruitFly> dmwit: I was just wondering where shows me what instances of typclasses are available in prelude without importing
23:08:23 <dmwit> The Prelude documentation shows that.
23:09:16 <dmwit> ah
23:09:23 <dmwit> The Prelude documentation does not show that.
23:10:22 <dmwit> Answering that question in general (i.e. replacing "Prelude" with an arbitrary module name) is quite a subtle question that we don't really have a tool for, so far as I know.
23:10:56 <fruitFly> dmwit: actually I think it does? You see Int, double etc. and then below you see the num typeclass with it's instances (that are not included in prelude like the above ones) ??? http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#g:6
23:11:35 <dmwit> The Prelude documentation shows what instances are available with *some* set of imports, but not what instances you would get without any imports.
23:12:01 <dmwit> For example, the documentation for Maybe says there's an instance of Typeable1, which is true, but you must import Data.Typeable to even be able to mention Typeable let alone access the instance.
23:12:21 <no-n> liftM is like fmap but only works on monads?
23:12:28 <dmwit> yes
23:12:38 <cmccann> it should be identical to fmap, in fact.
23:12:44 <dmwit> ...but slower
23:12:50 <dmwit> As has been pointed out to me. =)
23:13:17 <no-n> :>
23:14:07 <natnayr> anyone looking at mine?
23:14:17 <cmccann> dmwit: in the same way that ap is slower than (<*>), or something else?
23:14:18 <fruitFly> dmwit: are the only things included without imports are the things with peach headers? or am I wrong?
23:14:28 <Taneb> Just out of curiosity, when the Haskell' committee meets, do they literally meet? Like, face to face?
23:14:38 <fruitFly> dmwit: grey headers wadeva
23:14:57 <fruitFly> Taneb: Yes, and around a round table.
23:15:03 <zomg> Taneb: more like beard to beard
23:15:21 <fruitFly> zomg: lol
23:15:51 <natnayr> ive a type "Forall :: Show a => [a] -> (Term a -> Formula as) -> Formula (a, as)" and my function eqn is of type (Term a -> Formula as), how do u pluck the "Formula as" and return it?
23:16:07 <natnayr> its here on http://hpaste.org/87788
23:16:19 <dmwit> fruitFly: I'm hesitant to answer yes there, because under "instances" there are gray boxes, some of which are included and some of which aren't.
23:16:27 <natnayr> need help pls, spent tooo long on it..
23:16:42 <dmwit> In this specific case: as mauke says, exactly the instances for which both the class and type are in Prelude.
23:16:48 <parahsailin> @src ap
23:16:48 <lambdabot> ap = liftM2 id
23:17:02 <fruitFly> dmwit: right, not all the little grey boxes are included... I was guessing only the big grey headers... maybe. Thanks :)
23:17:17 <dmwit> cmccann: I'm not sure I understand your question. Perhaps in part because I don't know in what way ap is slower than (<*>).
23:17:35 <dmwit> I don't know what qualifies as a big grey header, that's my problem.
23:17:59 <cmccann> dmwit: in that case, why is liftM slower?
23:18:20 <dmwit> fruitFly: If the instances count, then your statement is incorrect because not all gray headers are included. If instances don't count, then your statement is incorrect because some instances are included, but they aren't gray headers.
23:18:39 <dmwit> cmccann: "why" questions are out of my league :3
23:18:44 <fruitFly> dmwit: aah. ok thanks.
23:18:53 <cmccann> dmwit: pf, fine.
23:19:30 <dmwit> cmccann: But I know by Science that it is true. =P
23:19:46 <parahsailin> in many instances (<*>) = ap
23:19:55 <cmccann> dmwit: that said, ap is (potentially) slower because it requires more operations (ignoring later optimization) and, more importantly, is forced to ignore useful properties that would allow better static analysis
23:20:02 <cmccann> in many cases it doesn't matter
23:20:33 <cmccann> but there are some cases where ap is forced to be horrifically inefficient compared to the obvious implementation of (<*>)
23:20:36 <dmwit> I'm not sure it's anything so sophisticated as that. fmap is faster than liftM even for dumb data types like []
23:21:11 <dmwit> ...which surprised me a lot!
23:22:06 <Watabou> wouldn't this work for reverse? myReverse (x:xs) = myReverse xs : x
23:22:07 <cmccann> well, all else equal would you expect "concat $ map ((:[]) . f) xs" to be slower than "map f xs"? :P
23:22:28 <dmwit> Watabou: (:) is not symmetric
23:22:37 <dmwit> Watabou: It takes an element first and a list second, always.
23:23:07 <dmwit> cmccann: Not fair. I would expect concatMap to be faster than concat . map (:[])
23:23:12 <Watabou> oh so my approach wouldn't work at all then
23:23:16 <Watabou> hmm
23:23:45 <dmwit> make that concatMap vs (concat .) . map, of course
23:24:13 <cmccann> I think the implementation of those is basically the same
23:24:39 <dmwit> ...and I wouldn't expect map f to be significantly faster than concatMap ((:[]) . f) after GHC got done with it.
23:25:47 <cmccann> I also wouldn't expect a monomorphic liftM to be slower than a monomorphic fmap. optimizers work in mysterious ways.
23:27:35 <dmwit> I wonder whether some rewrite rules could fix that.
23:27:41 <dmwit> "probably"
23:36:25 <cmccann> dmwit: more interesting is if you consider the Monad instance for stuff like infinite streams
23:37:48 <cmccann> or worse, things that behave like the automaton arrow (e.g., arrow-based FRP stuff)
23:40:42 <no-n> @src sequence
23:40:42 <lambdabot> sequence []     = return []
23:40:42 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
23:40:42 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
23:48:35 <no-n> what's a good way to turn a [Maybe a] into a Maybe [a]
23:48:54 <cmccann> ... sequence?
23:49:12 <no-n> thanks =)
23:49:22 <cmccann> unless you want something besides that
23:49:42 <cmccann> but I dunno what else you'd want with that type
23:51:09 <elliott> cmccann: Just . catMaybes???
23:51:15 <elliott> const $ Just []
23:51:19 <cmccann> yes good
23:51:26 <cmccann> that is excellent
23:51:34 <cmccann> wait wait I have it
23:51:36 <cmccann> unsafeCoerce
23:51:44 <cmccann> ok problem solved.
23:54:21 <Taneb> How complete is Sunroof?
23:54:42 <dmwit> You could want mplus or whatever?
23:54:49 <dmwit> mconcat
23:55:21 <cmccann> that wouldn't have the Maybe in the result though.
23:55:36 <cmccann> er
23:55:41 <cmccann> the [] in the result
23:55:42 <hpaste_> natnyr revised “natnyr”: “natnayr” at http://hpaste.org/87788
23:55:49 <natnayr> ignore that..
23:55:51 <natnayr> sry
