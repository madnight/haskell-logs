00:52:37 * hackagebot x509 1.4.2 - X509 reader and writer  http://hackage.haskell.org/package/x509-1.4.2 (VincentHanquez)
00:52:39 * hackagebot x509-validation 1.4.2 - X.509 Certificate and CRL validation  http://hackage.haskell.org/package/x509-validation-1.4.2 (VincentHanquez)
00:54:28 <adnap> In GHCI, if I run ":m + Data.Time.Clock", "t <- getCurrentTime", and "t", it says there's no instance for (Show UTCTime), but the Hackage doc says otherwise: http://hackage.haskell.org/packages/archive/time/1.4.0.2/doc/html/Data-Time-Clock.html
00:55:25 <shachaf> Did you check the version?
00:56:04 <adnap> "ghc-pkg list | grep time" shows "time-1.4"
00:56:34 <adnap> I think there has been an instance of (Show UTCTime) for many versions
00:56:43 <adnap> ... judging from the Hackage docs
01:07:37 * hackagebot slice-cpp-gen 0.2.3.0 - Generate C++ skeletons from slice files  http://hackage.haskell.org/package/slice-cpp-gen-0.2.3.0 (PaulKoerbitz)
01:11:02 <supki_> adnap: you need to import Data.Time.LocalTime too
01:13:09 <adnap> supki_: Oh, I see. The instance is in another module. Thank
01:13:13 <adnap> ... s
01:20:27 <no-n> I love haskell
01:20:46 <liyang> It's so easy?
01:21:26 <no-n> well, lots of reasons. it's kind of a long story :3
01:22:15 <slack1256> I love monoids, etc...
01:22:28 <no-n> yeah monoids
01:22:37 <liyang> Bit painful...
01:23:02 <no-n> that's haemorrhoids
01:23:04 <no-n> :P
01:23:14 <liyang> Oh yeah. So easily confused.
01:23:21 <slack1256> @quote monoids
01:23:21 <lambdabot> shachaf says: edwardk will try to get you addicted to monoids. The first one is always free.
01:23:29 <no-n> lol
01:23:42 <liyang> The first one is kinda pointed.
01:26:18 <fosskers> 1
01:28:02 <fosskers> Been wondering about style lately.
01:28:29 <fosskers> Which feels better:
01:28:37 <fosskers> f `fmap` g >>= h
01:28:40 <fosskers> or
01:28:44 <fosskers> g >>= h . f
01:28:54 <johnw> definitely the latter
01:29:05 <fosskers> hands down?
01:29:09 <johnw> the first one makes me have to think why you're not doing the other one :)
01:29:23 <johnw> yeah, hands down
01:30:12 <supki> > ("f `fmap` g >>= h", "g >>= h . f") & both %~ length
01:30:16 <lambdabot>   (16,11)
01:35:13 <johnw> fosskers: plus, you're adding another type class requirement when it's not meaningful to do so.  It would have to be `liftM`
01:37:24 <mm_freak> fosskers: i prefer the former for concrete monads
01:37:42 <mm_freak> for non-concrete ones i still prefer to former, but liftM instead of fmap
01:37:57 <mm_freak> also i prefer fmap in prefix syntax:  fmap f c >>= h
01:38:39 <johnw> there you have it: people differ :)
01:38:52 <mm_freak> the reason is that "h . f" is opaque to the underlying monad…  fmap is transparent
01:39:22 <johnw> i guess it really depends on what h and f are doing
01:39:26 <mm_freak> so i feel that the former style arises from my desire to write composable code
01:39:42 <johnw> how is the use of composition less composable than using fmap?
01:40:03 <mm_freak> johnw: it isn't
01:40:30 <mm_freak> it's just this:  when i think of mapping functions over monadic values, i think of fmap
01:41:01 <johnw> then I bet you wish the prelude had Functor as a superclass of Monad :)
01:41:11 <mm_freak> yes
01:41:15 <johnw> me too
01:56:31 <mmaruseacph2> hello, does anybody know if http://www.haskell.org/haskellwiki/Haskell is hosted on a haskell specific wiki?
01:56:41 <mmaruseacph2> that is, the software behind is in haskell
01:59:02 <fosskers> mm_freak and johnw, thank you
01:59:22 <fosskers> I always assume all Monads are Functors
01:59:36 <fosskers> and `fmap` is one character shorter than `liftM`. Plus liftM requires an import.
02:01:48 <fosskers> I suppose in the end `g >>= h . f` is just cleaner.
02:02:04 * johnw cheers
02:02:38 * hackagebot monadiccp 0.7.5 - Constraint Programming  http://hackage.haskell.org/package/monadiccp-0.7.5 (MaikRiechert)
02:03:23 <mm_freak> fosskers: in that simple case maybe
02:03:39 <fosskers> What about effects though?
02:03:44 <fosskers> Is there any case where:
02:04:01 <fosskers> `g >>= h . f` /= `fmap g >>= h` ?
02:04:21 <mm_freak> fosskers: ignoring the type error no
02:04:26 <mm_freak> that's a law
02:04:38 <fosskers> of monads or functors?
02:04:43 <fosskers> Monads I imagine.
02:05:10 <mm_freak> monads of course
02:05:30 <fosskers> Time to dig out the monad laws...
02:05:42 <fosskers> fmap f xs  =  xs >>= return . f  =  liftM f xs
02:05:45 <fosskers> yup, there it is
02:06:53 <mm_freak> the categorical reason is that 'join' is a natural transformation
02:08:37 <mm_freak> so:  fmap f . join = join . fmap f
02:08:57 <fosskers> :t join
02:08:58 <lambdabot> Monad m => m (m a) -> m a
02:09:28 <mm_freak> fmap f . join = join . fmap (fmap f)
02:09:29 <mm_freak> rather
02:09:40 <c_wraith> yeah, that looks better
02:09:41 <fosskers> yeah, I was like "hmm?"
02:10:43 <fosskers> What's the connection to above stuff then?
02:12:38 * hackagebot adp-multi 0.2.2 - ADP for multiple context-free languages  http://hackage.haskell.org/package/adp-multi-0.2.2 (MaikRiechert)
02:12:59 <keep_learning> Hello all,
02:13:16 <keep_learning> I am trying to write a simple calculator using parsec http://hpaste.org/88151
02:13:24 <keep_learning> but getting this compiler error.
02:13:45 <keep_learning> Could some one please tell me what is wrong with this code.
02:14:35 <johnw> try adding this:
02:14:41 <johnw> {-# LANGUAGE OverloadedStrings #-}
02:14:44 <fosskers> Do you have to be using Tokens specifically?
02:14:53 <archblob> hi guys
02:14:54 <johnw> otherwise, "foo" is a [Char], not the type you need
02:15:32 <archblob> i have a Word16 type, with , for example a value of 495
02:15:41 <archblob> and i want to get the complement
02:16:17 <supki> > complement (495 :: Word16)
02:16:18 <lambdabot>   65040
02:16:28 <fosskers> @type complement
02:16:29 <lambdabot> Bits a => a -> a
02:16:38 <archblob> yeah
02:16:49 <archblob> but it should be 16
02:17:02 <archblob> from what i understand
02:17:12 <supki> > complement (495 :: Word8)
02:17:14 <lambdabot>   16
02:17:14 <keep_learning> fosskers: Not specifically but just learning parsec so trying to use it.
02:17:46 <archblob> oh
02:17:57 <archblob> that's really stupid of me
02:18:12 <archblob> thank you
02:18:58 <fosskers> keep_learning: What are the capabilities of your calculator?
02:20:01 <keep_learning> fosskers: Addition , Multiplication , Division , Subtraction and exponentiation
02:20:45 <fosskers> Looks to be standard infix style?
02:22:56 <keep_learning> fosskers: yes, plain simple "1+2*3+4"
02:23:44 <fosskers> I've never written a calculator. Maybe I'll try.
02:23:57 <johnw> let's write a color TI calculator
02:24:29 <fosskers> Will the game `falldown` run on it?
02:24:38 <johnw> and portal
02:24:42 <fosskers> oh snap
02:26:34 <fosskers> 'scuse me, just going to do some pointfree tests here.
02:26:51 <fosskers> f p = x p
02:26:57 <fosskers> @pl f p = x p
02:26:57 <lambdabot> f = x
02:27:26 <mm_freak> fosskers: you can /query lambdabot
02:27:27 <fosskers> @pl f p = ask >>= g p
02:27:27 <lambdabot> f = (ask >>=) . g
02:27:30 <mmaruseacph2> fosskers: you can also try /query lambdabot  and try there :P
02:27:39 <fosskers> lol thnks
02:27:54 <Ndit> I am laying in bed with my laptop next to me, and because my head is on the pillow, I have to read all the text sideways, so I have Haskell open and I am just opening my eyes barely and watching this channel, but nobody says anything
02:27:54 <no-n> but lambdabot use is such a great conversation piece!
02:28:09 <Ndit> So you should write tons of stuff here fosskers
02:28:24 <fosskers> So be it. Ndit needs material.
02:28:43 <fosskers> @pl install' custom subConflict bh pacOpts pkgs = ask >>= \ss -> do
02:28:43 <lambdabot> install' = const (const (const (const (const (ask >> do)))))
02:28:44 <fosskers>   let toInstall = pkgs \\ ignoredPkgsOf ss
02:28:44 <fosskers>       ignored   = pkgs \\ toInstall
02:28:44 <fosskers>       mainPkgs  = initialPF bh
02:28:44 <fosskers>   reportIgnoredPackages ignored
02:28:44 <johnw> anything
02:28:46 <fosskers>   (_,okay,nons) <- badPkgCheck toInstall >>= divideByPkgType ignoreRepos mainPkgs
02:28:49 <fosskers>   reportNonPackages nons
02:28:51 <fosskers>   handler <- pbHandler
02:28:54 <fosskers>   toBuild <- mapM custom okay >>= pkgbuildDiffs >>= handler
02:28:56 <fosskers>   notify install_5
02:28:59 <fosskers>   (subDeps,mainDeps) <- catch (depsToInstall subConflict bh toBuild) depCheckFailure
02:29:02 <fosskers>   reportPkgsToInstall bh subDeps mainDeps toBuild
02:29:04 <fosskers>   continue <- optionalPrompt install_3
02:29:07 <fosskers>   if not continue
02:29:09 <fosskers>      then scoldAndFail install_4
02:29:12 <fosskers>      else do
02:29:14 <fosskers>        unless (null subDeps) $ subBuild bh subDeps
02:29:17 <fosskers>        storePkgbuilds $ toBuild ++ mainDeps
02:29:19 <elliott> uh.
02:29:19 <fosskers>        mapM_ (buildAndInstallDep pacOpts) mainDeps
02:29:22 <fosskers> well that didn't work
02:29:35 <elliott> don't do that :P
02:29:35 <no-n> what are you doing :S
02:29:44 <fosskers> Ugliest function in my code base. It needs to die or be revamped in a big way.
02:29:53 <Ndit> i got more than i bargained for
02:30:00 <fosskers> Haha then I apologize
02:30:12 <elliott> for a start, you can /msg lambdabot in private. for a follow-up, lambdabot's commands only take one-line input
02:30:23 <elliott> for another follow-up, do you have any idea how hideous the output of running @pl on that would be?!
02:30:36 <fosskers> It was for science, elliott.
02:31:06 <mm_freak> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
02:31:08 <lambdabot> (Functor f1, Functor f) => (a1 -> a -> b) -> f a1 -> f (f1 a -> f1 b)
02:31:24 <no-n> filter (/='m') it
02:31:27 <mm_freak> hmm
02:31:44 <fosskers> now now no-n
02:31:51 <no-n> :>
02:32:20 <mm_freak> that used to cause pages of a type…
02:32:36 <Mortomes>  > filter (/='m') it
02:33:03 <elliott> mm_freak: you're probably thinking fo some other expression
02:33:05 <fosskers> I guess it reduces better now?
02:33:06 <jobseeker> Why can't I in ghci "import Data" while I can yes "import System.IO"? I want to practice the "Either" construct.
02:33:25 <fosskers> Either is in prelude, no?
02:33:51 <mm_freak> elliott: not sure
02:34:05 <mm_freak> but it was something with fmap, i'm sure about that
02:34:48 <elliott> jobseeker: who told you you need to "import Data"?
02:35:03 <plhk> jobseeker: import Data.Either ?
02:35:32 <jobseeker> ah ok thanks works
02:36:49 <fosskers> trying to do `import Data` would be like trying to do `import System` wouldn't it?
02:36:56 <mm_freak> funny…  flip, flip flip, flip flip flip and flip flip flip flip all have different types, but then you can add as many additional flips as you like, the type doesn't change…  so it some point flip flips into a const =)
02:37:04 <jobseeker> I need to write something to effect of let x = Either 5 6 in Left x or am I completely misled?
02:37:20 <mm_freak> it → at
02:37:54 <jobseeker> need to write --> want to write *
02:37:59 <mm_freak> jobseeker: "Either 5 6" would a type, if 5 and 6 were types
02:38:22 <jobseeker> mm_freak: ah.
02:38:30 <mm_freak> you probably want Either Integer Integer or something like that
02:38:36 <mm_freak> then Left 5 and Right 6 would be values
02:39:09 <fosskers> Yeah, Either is the Type name, not the constructor.
03:00:05 <johnw> Either is not the type name
03:00:10 <johnw> Either Integer Integer is the type name
03:00:19 <johnw> Either is a type function, aka constructor
03:00:32 <elliott> Either is a type name per some definitions of type
03:00:52 <johnw> a concrete type has kind *
03:00:57 <johnw> Either has kind * -> * -> *
03:02:03 <fosskers> yeah, pardon me
03:02:12 <elliott> sure. some people take type to mean "type-level value of kind *", others take it to mean "type-level value"... good arguments both ways (awkward to have differing terminology from the "0-parameter" case (e.g. imagine if we said functions weren't values because their types looked like (a -> b)...), but also awkward to not have a concise way to say "thing that can have values")
03:02:39 <johnw> that's a good point, elliott
03:02:44 <johnw> the functions vs. values thing
03:02:54 <fosskers> I'd consider Either to be a "type" but not a "concrete type"
03:09:31 <keep_learning> Hello all,
03:10:11 <keep_learning> I manage to write the calculator using String and trying to write it using ByteString. http://hpaste.org/88152
03:11:15 <keep_learning> but getting compiler error. I am bit confused with how Parsec works with ByteString
03:11:58 <merijn> johnw: Ugh...just woke up, -c16 failed for rehoo too >.<
03:12:24 <johnw> i'm sorry merijn, I'm afraid i'm not sure what's going on there
03:12:35 <johnw> -c4 would be the last thing to try tomorrow :(
03:12:47 <johnw> hoogle's database combiner is a memory gobbler
03:12:54 <johnw> rehoo is just shelling out to it
03:14:40 <merijn> Are the result files architecture/OS dependent in some way?
03:18:19 <keep_learning> Any one please ?
03:18:35 <adnap> I just realize the limitation with Applicative is that pure traps a value in the Applicative forever. map pure :: (Applicative f) => [a] -> [f a], pure :: [a] -> f [a], but I can't write (Applicative f) => f [a] -> [f a]
03:18:48 <johnw> keep_learning: I gave you a suggestion long ago
03:19:01 <keep_learning> Overloaded string ?
03:19:14 <johnw> yes
03:19:26 <johnw> you are mixing ByteStrings and Strings
03:19:51 <keep_learning> I put that but it was still error.
03:19:56 <johnw> ah, ok
03:20:06 <johnw> let me look again
03:20:40 <johnw> i don't see OverloadedStrings in your new paste
03:22:45 <keep_learning> johnw: Now posted http://hpaste.org/88152. I tried at that but it shows the error then I removed it.
03:23:20 <johnw> what line is the error on now?
03:23:22 <johnw> still 58?
03:24:12 <keep_learning> yeah line 58
03:24:13 <johnw> oh, and using fromJust is pure evil, just so you know
03:24:39 <FreeFull> fromJust defeats the point of Maybe
03:24:58 <johnw> yeah, the type is "this might fail" and fromJust says "this will never fail"
03:25:04 <johnw> is like your function is arguing with the type!
03:25:31 <johnw> and Maybe is like, "Dude, I'm seriously, I could return Nothing on you at any time, capice"?
03:25:54 <keep_learning> johnw: Yes. I am not able to get the intuition about byte string.
03:25:55 <FreeFull> adnap: I don't think you can do that with just Applicative, but you probably would be able to do it with Monad
03:26:43 <johnw> keep_learning: doesn't the char '(' parser return a Char?
03:26:58 <keep_learning> I am taking string , converting it to bytestring and processing it ( by different parsec functions )
03:27:14 <adnap> FreeFull: I know. 'Cause Monads imlement bind
03:27:23 <keep_learning> johnw: Yes but it's not going to return
03:27:34 <johnw> it doesn't matter, it can still affect type inference
03:27:36 <keep_learning> it's matching
03:27:49 <johnw> although, that shouldn't matter here
03:27:59 <johnw> it's matching what?  you said this code doesn't compile
03:28:21 <johnw> somewhere, you are using a [Char] type where you need to have a ByteString
03:28:37 <johnw> and you are using a parser that yields a Char
03:29:17 <johnw> anyway, i'd need to download this and compile it myself to get further, but it's too late for me
03:29:21 <johnw> i concede
03:29:51 <keep_learning> johnw: No problem. Thank you for your valuable suggestion :)
03:39:33 <FreeFull> adnap: I'm not actually certain a   m [a] -> [m a]   function is possible
03:39:41 <johnw> it's not
03:39:45 <johnw> there's a stack overflow question on that
03:40:05 <johnw> you can distribute the monad out, but not in
03:41:12 <FreeFull> You could easily do  m [a] -> m [m a]
03:42:19 <ion> That doesn’t really get you any closer to [m a].
03:42:39 <fosskers> Why not just join it after that?
03:42:46 <ion> @type join
03:42:48 <lambdabot> Monad m => m (m a) -> m a
03:43:10 <fosskers> A, pardon me
03:43:26 <fosskers> hm?
03:44:03 <johnw> join won't type check if you apply it to m [m a]
03:44:10 <fosskers> Right
03:46:11 <fosskers> wait...
03:46:44 <fosskers> @type Just [1..10] >>= map return
03:46:45 <lambdabot>     Couldn't match expected type `Maybe b0' with actual type `[b1]'
03:46:45 <lambdabot>     Expected type: [t0] -> Maybe b0
03:46:45 <lambdabot>       Actual type: [t0] -> [b1]
03:47:26 <FreeFull> :t (>>=)
03:47:28 <lambdabot> Monad m => m a -> (a -> m b) -> m b
03:48:54 <johnw> you'd need to use mapM return
03:49:20 <fosskers> yeah
03:49:44 <fosskers> But we're still stuck in Monad land after that.
03:49:48 <johnw> yes
03:49:52 <fosskers> > Just [1..10] >>= mapM return
03:49:53 <lambdabot>   Just [1,2,3,4,5,6,7,8,9,10]
03:49:55 <johnw> once in, never out, at least not using the Monad interface
03:50:18 <johnw> > [Just 1, Just 2, Just 3] >>= mapM id
03:50:20 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a0'
03:50:21 <lambdabot>              with actual...
03:50:26 <johnw> > [Just 1, Just 2, Just 3] >>= mapM return
03:50:28 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a0'
03:50:28 <lambdabot>              with actual...
03:50:32 <fosskers> > map (return :: a -> Maybe a) `fmap` Just [1..10]
03:50:34 <lambdabot>   Just [Just 1,Just 2,Just 3,Just 4,Just 5,Just 6,Just 7,Just 8,Just 9,Just 10]
03:50:53 <johnw> @src sequence
03:50:53 <lambdabot> sequence []     = return []
03:50:53 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
03:50:53 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
03:51:07 <johnw> > sequence [Just 1, Just 2, Just 3]
03:51:09 <lambdabot>   Just [1,2,3]
03:51:25 <fosskers> wait
03:51:30 <merijn> fosskers: You can never get out using only monad, specific monads (like Maybe or []) might give you a way to get things out, though
03:51:47 <fosskers> Yeah
03:52:22 <fosskers> > join $ fmap sequence $ map (return :: a -> Maybe a) `fmap` Just [1..10]
03:52:25 <lambdabot>   Just [1,2,3,4,5,6,7,8,9,10]
03:52:37 <fosskers> Oh, that's what I started with.
03:52:44 <johnw> :)
03:52:50 <johnw> if you can find a way out of the monad, I'll e-mail you a biscuit
03:53:05 <johnw> just turn Just [1] into [Just 1]
03:53:06 <merijn> Hell, I'll fly to you to hand it to you :p
03:53:07 <fosskers> Didn't need to be out of the monad.
03:53:31 <johnw> merijn: lol
03:53:31 <merijn> Also, can I be a co-author when you do find it? :p
03:53:32 <fosskers> Just wanted to m [a] -> [m a]
03:53:48 <fosskers> actually wait, yeah
03:53:54 <fosskers> That is "getting of the of the monad"
03:54:05 <fosskers> because [] is the top-most type
03:54:24 <merijn> fosskers: And that's the feeling of enlightenment :)
03:54:34 <fosskers> ahhhh feels good
03:55:03 <fosskers> The only way out of the Monad might be to just smash the computer and stop using Haskell.
03:55:09 <johnw> fosskers: see http://stackoverflow.com/questions/14432883/how-to-make-a-io-a-b-function-from-a-io-b-in-haskell/14447349#14447349
03:55:16 <johnw> this is asking the exact same question
03:55:22 <johnw> just in the context of functions, rather than lists
03:56:43 <fosskers> yeah
04:05:31 <no-n> :>
04:06:39 <no-n> what does unsafe mean?
04:07:17 <johnw> usually that it violates things your reading was thinking he could depend on
04:07:19 <fosskers> @src unsafe
04:07:19 <lambdabot> Source not found.
04:07:27 <fosskers> @type unsafe
04:07:30 <lambdabot> Not in scope: `unsafe'
04:07:40 * hackagebot fixed-vector 0.4.3.0 - Generic vectors with statically known size.  http://hackage.haskell.org/package/fixed-vector-0.4.3.0 (AlexeyKhudyakov)
04:07:53 <johnw> like, using unsafePerformIO in pure code means that it might not be pure anymore.  You're depending on the user of unsafePerformIO to guarantee for you that it's pure, hence it's "unsafe"
04:08:02 <johnw> not the same as disastrous, though, just... unsafe
04:08:08 <johnw> use with caution!
04:08:14 <typoclass> no-n: "think twice before using this. if you use this, you need to know exactly what you're doing"
04:08:23 <Cale> It could be disastrous, depending on what you do with it
04:08:35 <johnw> yes, could be anything at all, in fact
04:08:38 <Cale> After all, you can write unsafeCoerce with it fairly easily
04:08:53 <Cale> and then start executing arbitrary parts of memory as code
04:08:58 --- mode: Cale set -o Cale
04:09:02 <fosskers> great
04:09:20 <no-n> :o
04:09:24 <johnw> i figure that 9/10 times that I use any functions starting with "unsafe", I'm doing it work
04:09:30 <johnw> s/work/wrong
04:09:53 <no-n> what kind of software do you have to use unsafe stuff to write?
04:09:58 <johnw> FFI code
04:10:13 <no-n> FFI?
04:10:15 <fosskers> johnw: Ah, alright. Then the guy in the function you listed above was trying to commit pure evil, yeah?
04:10:17 <johnw> FFI code is always in IO, but sometimes you *know* that it's actually non-mutating code
04:10:21 <johnw> Foreign Function Interface
04:10:24 <johnw> calling C code
04:10:27 <no-n> ah
04:10:50 <johnw> i believe that's why unsafePerformIO was originally created, isn't that right Cale?
04:11:02 <Cale> FFI? Yeah, pretty much.
04:11:20 <Cale> In general, you should think of unsafePerformIO as being something which saves you from having to modify the compiler.
04:12:12 <Igloo> johnw: Do you mean that you literally have unsafePerformIO in your program, or that the compiler implicitly uses it when you don't use an IO type on a foreign decl?
04:12:15 <fosskers> Quick confirmation: If you have a function of say a -> a
04:12:16 <johnw> and then we have Safe Haskell, which I feel like was invented to undo the unintended consequences of unsafePerformIO :)
04:12:39 <fosskers> and that function has an unsafePerformIO call in it
04:12:52 <johnw> Igloo: since I use c2hsc, which maps all functions to IO, I actually use it myself in pure "wrapers" for those functions I know to be pure
04:13:01 <Igloo> Ah, OK
04:13:07 <fosskers> Will memoization do its job properly and skip recalculating if the input is the same?
04:13:22 <johnw> fosskers: that is the definition of memoization
04:13:23 <Cale> fosskers: If you memoise the function somehow
04:13:29 <johnw> are you asking if some particular memoization library will do that?
04:13:30 <Cale> Then presumably
04:13:57 <johnw> fosskers: was your memoization function related to your unsafePerformIO question?
04:14:03 <Cale> Or maybe not, depending
04:14:05 <johnw> you don't need unsafePerformIO to memoize
04:14:09 <fosskers> nono
04:14:13 <Cale> Depends on where the unsafePerformIO is
04:14:15 <typoclass> fosskers: you possibly meant 'sharing'
04:14:26 <Cale> and how the memoiser works
04:14:38 <fosskers> Can I start my question over?
04:14:43 <Cale> (functions are not memoised by default in Haskell)
04:14:47 <fosskers> ah
04:14:51 <johnw> are you asking if the IO will be done twice?
04:15:02 <fosskers> Maybe I've got my terminology mixed up then.
04:15:07 <Cale> (If they were, the garbage collector would never have anything to collect)
04:15:20 <johnw> then we'd need to unmemoize functions ;)
04:15:52 <fosskers> Say I have a function `solveTheUniverse :: a -> a`
04:16:12 <Cale> g'night!
04:16:17 <johnw> night!
04:16:20 <fosskers> night
04:16:31 <fosskers> And I give it 1, and after 19 years of calculation it spits out 42.
04:16:50 <fosskers> Then I give it 1 again.
04:17:03 <fosskers> How long until 42 is spit out again?
04:17:06 <fosskers> Instantly, no?
04:17:14 <johnw> if it's not memoized, it'll take 19 years
04:17:22 <johnw> functions are not memoized by default
04:17:37 <fosskers> I thought they were. Hm.
04:18:08 <fosskers> Does compiling with -02 or -03 change that?
04:18:16 <johnw> no
04:18:22 <johnw> you'd need to use a memoization library
04:18:36 <gds> If you do f = .... where x = solveTheUniverse 1
04:18:41 <johnw> memoizes is not always a benefit, so it's hard to know when to automatically apply it
04:19:13 <fosskers> gds: then yeah, calling x would give me 42 instantly
04:19:17 <gds> Yup.
04:19:44 * gds stops saying things everyone already knows :S
04:19:59 <fosskers> No, it was valid to point that out.
04:20:09 <gds> :)
04:20:28 <fosskers> Well I had been coding on some serious false conceptions then.
04:20:36 <johnw> ah, maybe your question was about sharing, fosskers, not memoziation
04:20:45 <bitonic> is there an easy way to get code coverage if I already have tests with cabal ‘test-suite’?
04:20:56 <johnw> if you use let to bind the result of calling solveTheUniverse, then it will only be evaluated once
04:21:13 <johnw> if you don't, and call it twice in the same expression, then *maybe* GHC will apply common subexpression elimination and only call it once
04:21:24 <johnw> but you can't be guaranteed that
04:21:25 <fosskers> Ahhhh
04:21:27 <typoclass> fosskers: haskell does have sharing (as i mentioned before). in "let x = longComputation in x + x", the longComputation will be evaluated only once
04:21:32 <johnw> bitonic: yes, use hpc
04:21:46 <fosskers> typoclass: yeah, that should be expected
04:22:27 <johnw> GHC does do some CSE, but I've heard it's not too aggressive about it yet
04:22:37 <fosskers> cse?
04:22:41 <johnw> common subexpression elimination
04:22:54 <fosskers> ah, right, the word you just said a moment ago
04:22:56 <johnw> realizing that two expressions will yield the same value always
04:22:58 <bitonic> johnw: can you elaborate?
04:23:16 <johnw> bitonic: just yesterday someone was linking to a GHC plugin someone was working on to improve CSE detection
04:23:25 <fosskers> I thought that was the whole point of lazy evaluation.
04:23:29 <bitonic> johnw: I was talking about ‘use hpc’
04:23:29 <fosskers> Or rather, half the point of it.
04:23:33 <johnw> http://hackage.haskell.org/packages/archive/cse-ghc-plugin/0.1.1/doc/html/CSE-Plugin.html
04:23:38 <elliott> common misconception
04:23:41 <johnw> bitonic: oh, hpc is built-in to GHC
04:23:48 <johnw> let me show you an example of using it
04:24:01 <johnw> flag hpc
04:24:02 <johnw>     default: False
04:24:05 <johnw>   if flag(hpc)
04:24:06 <johnw>       ghc-options: -fhpc -hpcdir dist/hpc
04:24:08 <johnw> that's all you need
04:24:20 <johnw> then just cabal configure -fhpc, build and test
04:24:31 <bitonic> johnw: thanks, let me try
04:24:42 <johnw> here's the reporting script I use: https://gist.github.com/5604108
04:24:50 <fosskers> elliott: was that directed to me?
04:24:51 <johnw> change where needed
04:25:01 <staafl> what's a more educated way to write this: scale (a,b,c) k = (k*a,k*b,k*c)
04:25:40 <johnw> fosskers: lazy evaluation is something else, it implements non-strict semantics, it has nothing to do with not duplicating work, just not evaluating work that is never used
04:25:45 <fosskers> @pl scale (a,b,c) k = (k*a,k*b,k*c)
04:25:46 <lambdabot> (line 1, column 18):
04:25:46 <lambdabot> unexpected " "
04:25:46 <lambdabot> expecting operator
04:26:28 <gds> fosskers: I thought the point of lazy evaluation was to be able to do stream-style stuff like "take n $ map f [1..]"
04:26:29 <typoclass> fosskers: see also http://www.haskell.org/haskellwiki/Sharing
04:26:36 <bitonic> johnw: your config doesn’t seem to work with the Paths_ module
04:26:43 <johnw> bitonic: ah, doesn't surprise me
04:26:44 <fosskers> Hence my correction, "half the point"
04:26:54 <gds> Ah :)
04:26:59 <fosskers> The major point being never evaluating what's never used.
04:28:10 <elliott> foobarbaz: re: automatic memoisation of functions being the point of lazy evaluation, yes
04:28:40 <johnw> elliott: ?
04:28:56 <fosskers> i think he tab completed on the wrong name
04:29:03 <johnw> i'm ?'ing his text
04:29:16 <fosskers> nono, elliot
04:29:17 <johnw> lazy evaluation does let you implement automatic memoisation of functions
04:29:31 <johnw> but it's being the *point* of lazy evaluation, I wonder what elliott meant
04:30:02 <fosskers> I guess I had just always assumed that functions were memoized all the time.
04:30:27 <fosskers> I should probably read that sharing article
04:30:42 <typoclass> fosskers: it's really just a few lines of text, but they clarify things
04:30:43 <johnw> no, for the same reason that pure functions are not automatically made parallel all the time
04:30:46 <elliott> johnw: <fosskers> I thought that was the whole point of lazy evaluation.  <fosskers> Or rather, half the point of it.  <elliott> common misconception
04:30:50 <johnw> because the programmer needs to decide when the cost is worth it
04:31:16 <johnw> if memoization were perfectly free of all costs, then it would be a different story :)
04:32:31 <typoclass> fosskers: and yes, suppose that a long-running function is called eleventy million times, but each time with different arguments. ghc couldn't know the arguments at compile time. making a big table with all the arguments and results would be a waste of time in this case. you'll never find a match in the table, since all the arguments are different
04:33:19 <typoclass> fosskers: in other words, the way things are, the programmer has to decide "yes i'll start using a memoization library on my function". ghc can't decide that
04:34:16 <fosskers> question: the making of said table is something that occurs at runtime?
04:34:33 <johnw> it is built lazily, at runtime
04:35:07 <johnw> fosskers: http://stackoverflow.com/questions/3208258/memoization-in-haskell
04:35:13 <johnw> that's a rather good thread on the subject
04:35:49 <staafl> I apologize for repeating myself :-) is there a way to combine a simple operation over a tuple?  scale (a,b,c) k = (k*a,k*b,k*c)
04:36:08 <johnw> lens would be the easiest way
04:36:40 <typoclass> fosskers: my point was, half the time, this memoization table is a waste. ghc doesn't automatically know if it's promising to memoize function f, or if it's likely wasteful. ghc needs the programmer's guidance on this
04:36:59 <fosskers> right, okay
04:37:08 <staafl> johnw, hmm, ok
04:37:11 <typoclass> staafl: it looks fair enough to me
04:37:18 <elliott> staafl: with lens, it can be: scale t k = t & each *~ k
04:37:25 <elliott> (or if you flip the args, scale k = each *~ k)
04:37:32 <elliott> nothing wrong with how you wrote it though
04:37:37 <johnw> > (1,2,3) ^.. traverse.to (+1)
04:37:38 <staafl> I've been hearing about lens but haven't read up on them yet
04:37:40 <lambdabot>   No instance for (Data.Traversable.Traversable ((,,) t0 t1))
04:37:40 <lambdabot>    arising from...
04:37:44 <fosskers> @type t & each *~ k
04:37:46 <lambdabot> (Each Mutator Expr b Expr Expr, Index b ~ Index Expr) => b
04:37:52 <fosskers> Sweet jesus
04:37:55 <staafl> well, it's pretty naive
04:38:07 <elliott> nothing wrong with naive
04:38:15 <fosskers> @type each *~ k
04:38:16 <elliott> fosskers: that type is misleading. it's because of lambdabot's predefined "t" and "k"
04:38:16 <lambdabot> Each Mutator s t Expr Expr => s -> t
04:38:19 <elliott> so it outputs nonsense.
04:38:27 <staafl> sure, but if there's a more sophisticated way, I would like to be aware of it
04:38:32 <elliott> @type \k -> each *~ k
04:38:34 <lambdabot> (Num a, Each Mutator s t a a) => a -> s -> t
04:38:44 <elliott> which gets a lot friendlier as its specialisation
04:38:52 <elliott> @type (\k -> each *~ k) :: Int -> (Int,Int,Int) -> (Int,Int,Int)
04:38:54 <lambdabot> Int -> (Int, Int, Int) -> (Int, Int, Int)
04:39:01 <fosskers> Oh.
04:39:32 <johnw> cool, I hadn't used each befgore
04:39:34 <johnw> > > (1,2,3) & each *~ k
04:39:35 <lambdabot>   <hint>:1:1: parse error on input `>'
04:39:40 <johnw> > (1,2,3) & each *~ k
04:39:42 <lambdabot>   (1 * k,2 * k,3 * k)
04:40:08 <johnw> for a list its traverse
04:40:15 <johnw> > [1,2,3] & traverse *~ k
04:40:17 <lambdabot>   [1 * k,2 * k,3 * k]
04:40:21 <fosskers> I'm still working my way through the core type classes. Lenses and Arrows are still off in some mystical paradise.
04:40:50 <elliott> heh, if only arrows were a paradise
04:40:53 <johnw> fosskers: Arrows are really deserving of too much attention these days, I wouldn't fret about them until somebody tells you you really need them
04:41:14 <johnw> s/are/aren't
04:41:40 <johnw> FRP and the hxt library are the only real uses of arrows I've come across
04:41:42 <fosskers> Well, if they allow for some nice abstraction I'm all for them.
04:42:06 <johnw> it's a bit cumbersome of an abstraction
04:42:38 <johnw> applicatives are generally much more interesting
04:42:45 <fosskers> I like applicatives.
04:42:54 <fosskers> They feel good.
04:43:05 <no-n> what's the difference between a functor and an applicative functor?
04:43:47 <johnw> no-n: an applicative functor lets you apply a function "in the functor" to another functorial argument
04:43:50 <johnw> fmap will not allow this
04:43:56 <johnw> i.e., f (a -> b) -> f a -> f bm
04:44:00 <typoclass> no-n: basically, the Applicative typeclass has one additional function. Functor has one function, Applicative has two. typeclassopedia explains the details
04:44:04 <typoclass> @where typeclassopedia
04:44:04 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
04:44:14 <elliott> ...are we forgetting about pure? :)
04:44:19 <johnw> oh yeah!
04:44:36 <johnw> and it lets you lift values into the functor ;)
04:44:42 <typoclass> elliott: indeed we seem to be
04:44:55 <johnw> thanks elliott
04:45:02 <fosskers> As for what applicatives _do_, they let you collect values across multiple functions in an anonymous way.
04:45:18 <fosskers> Less powerful than a Monad, more so than just a Functor.
04:45:43 <fosskers> I should have said "multiple function applications" ;)
04:46:09 <johnw> i'm reading a paper on applicatives right now, actually
04:46:17 <johnw> it's quite a good one
04:46:26 <johnw> let me look up the title
04:47:49 <johnw> here it is: http://www.cs.ox.ac.uk/publications/publication1409-abstract.html
04:47:55 <johnw> "The Essence of the Iterator Pattern"
04:48:07 <typoclass> johnw: oh thanks
04:49:37 <johnw> good night all
04:50:10 <fosskers> cool! I'll have to read that
04:50:56 <typoclass> johnw: good night
04:52:03 <fosskers> night
05:03:06 <mm_freak> fosskers: what?  that seems to be what the '(->) a' applicative does
05:03:20 <mm_freak> not what applicatives do in general
05:04:38 <mm_freak> :t foldr (liftA2 (:)) (pure [])
05:04:39 <lambdabot> Applicative f => [f a] -> f [a]
05:05:49 <fosskers> neat, join for applicatives
05:05:53 <fosskers> pardon me
05:05:56 <fosskers> sequence
05:07:06 <magicman> @type sequenceA
05:07:08 <lambdabot>     Not in scope: `sequenceA'
05:07:08 <lambdabot>     Perhaps you meant one of these:
05:07:08 <lambdabot>       `Data.Traversable.sequenceA' (imported from Data.Traversable),
05:07:17 <magicman> @type Data.Traversable.sequenceA
05:07:18 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
05:07:32 <fosskers> why not -> sequenceA (a:as) = (:) <$> a <*> sequenceA as
05:08:24 <magicman> That's what it is when you specialize sequenceA to lists.
05:09:18 <sarfraz> Hi, can someone help me with my paste?
05:09:23 <sarfraz> http://hpaste.org/88159
05:14:36 <magicman> I think that's because it doesn't know what type "From: (.+)\\n" has, because of the OverloadedStrings extension.
05:14:55 <fosskers> :quit
05:15:35 <magicman> (=~) doesn't require the left and right side to have the same type. There's quite some typeclass juggling going on there.
05:16:29 <sarfraz> that was it the OverloadedStrings confused the compiler
05:17:13 <sarfraz> had to explicit what output type I wanted (:: B.ByteString)
05:17:18 <sarfraz> thanks
05:17:46 <sarfraz> but it doesn't get me the From: header
05:18:02 <sarfraz> do you know a better way of parsing email?
05:19:37 <typoclass> sarfraz: you could use one of the parsec variants, or you could just go with calling 'lines' and 'words'. it's what i usually end up doing
05:20:03 <magicman> I wouldn't be surprised if there's a library for parsing email on hackage.
05:20:13 <typoclass> > "From: " `isPrefixOf` "From: <deedle@doodle.org>"
05:20:16 <lambdabot>   True
05:20:32 <typoclass> sarfraz: or the functions from Data.List, e.g. isPrefixOf
05:20:37 <typoclass> magicman: good point
05:21:51 <sarfraz> thanks will look this way
05:30:43 <supki> > "From: <deedle@doodle.org>" ^. strippingPrefix "From: "
05:30:45 <lambdabot>   "<deedle@doodle.org>"
05:32:48 <magicman> "lens did it" is Haskell's version of "Simpsons did it", isn't it :p
05:35:08 <mgsloan> magicman: Nono, that's edwardk did it ;)
05:35:46 <mgsloan> Lens is:  Anything records can do, lens can do better
05:37:03 <magicman> Fair enough.
05:37:15 <mgsloan> (Not to continue the misconception that lens is only a record replacement - much more than that)
05:37:18 <magicman> Oh, right. And "oleg did it, in the type system".
05:37:34 <mgsloan> Yeah, that's definitely the one
05:38:13 <mgsloan> And then edwardk implemented it 10x as efficiently
05:38:49 <aristid> @quote oleg
05:38:50 <lambdabot> oleg says: The implementation of RSA on type level is left for future work.
05:39:32 <typoclass> "the implementation of type checker on type level is left for future work"
05:42:34 <Chousuke> following the various Haskell communities, I get the impression that all problems can be solved with pipes and lenses
05:43:13 <typoclass> Chousuke: well you also need monads, but obviously every of the haskell community agrees on that
05:43:51 <Chousuke> typoclass: when applicative is not enough, yes
05:43:58 <merijn> You also need GADTs, TypeFamilies and DataKinds!
05:44:34 <typoclass> merijn: lately i've become quite fond of functions
05:44:44 <Chousuke> I should find all the questions on Haskell SO where Tekmo has replied with "You can do that with Pipes"
05:45:04 <Chousuke> I'm sure it would form quite a chunk of useful Pipes documentation
05:45:05 <merijn> Functions are for noobs :p
05:46:16 <typoclass> functional programming -> lensical programming, pipesean programming
05:46:21 <Chousuke> "My program solves the problem before it even runs"
05:47:05 <magicman> And then there's Agda. "Huh, programs can be run?"
05:47:54 <Chousuke> Or maybe "I know you've never run this, but it will work so don't bother"
05:54:07 <hio> Why is haskell so complicated? Can't you make a language that's good and not complicated?
05:54:45 <int_index> Haskell is simple.
05:55:04 <typoclass> hio: in my opinion it's a problem of teaching. lyah and other materials have done really a lot, but i think there's still room for improvement
05:55:23 <hio> In my opinion it is not. That's like saying Scala is a problem of teaching
05:55:49 <typoclass> hio: i'm not sure what you mean?
05:56:05 <hio> Scala is like Haskell, way overcomplicated with dubious use
05:56:14 <int_index> Scala is overcomplicated. It ignores the Occam's Razor
05:56:17 <Jeanne-Kamikaze> what do I hear
05:56:43 <Chousuke> hio: I think first you should tell us why you think Haskell is complicated
05:56:46 <elliott> (why is trolling irc so complicated? ...)
05:56:48 <typoclass> hio: do you have an example? what about haskell is overcomplicated and has no clear use?
05:57:24 <Eduard_Munteanu> hio: some of Haskell's complexity arises from its expressivity. Other languages can "become" more complex too if you try to express certain abstractions and models in them (e.g. OOP in plain C). But that's not a bad thing.
05:57:25 <Jeanne-Kamikaze> how is scala like haskell, when in scala everything is an object ?
05:57:48 <hio> Chousuke, well first of all I tried running some haskell and I couldn't even find a way so I looked forever for an IDE and it was terribly complicated and then when I finally installed it, I tried writing a hello world program but I couldnt
05:57:53 <Jeanne-Kamikaze> stop calling languages with lambdas functional languages
05:58:09 <Chousuke> hio: that sounds like just not doing your homework
05:58:12 <Jeanne-Kamikaze> it is blasphemy
05:58:20 <elliott> hio: if you're looking for help with the language, then you should ask for help, not try and complain about its flaws to get people to help you.
05:58:29 <elliott> are you reading a haskell tutorial or book?
05:58:34 <int_index> hio, so you call Haskell complicated becasue you couldn't properly install an IDE? Brilliant
05:58:47 <hio> i did install it properly
05:58:51 <typoclass> elliott, int_index: be nice
05:58:56 <hio> but then I couldnt even figure out how to run a single thing
05:59:09 <Iceland_jack> hio: Is that a problem with the language?
05:59:12 <typoclass> hio: most people here use a regular text editor. the ide offerings for haskell (as far as i know) are indeed not too great
05:59:15 <Eduard_Munteanu> hio: the simplest way to get started is to install the Haskell Platform and poke around in the interpreter, ghci.
05:59:27 <elliott> typoclass: I am being perfectly civil. someone who joins the channel to say "Can't you make a language that's good and not complicated?" is being considerably less so
05:59:37 <Jeanne-Kamikaze> there's even a try haskell thing online
05:59:46 <Chousuke> hio: it's really no more complicated than starting with any other language.
05:59:47 <Eduard_Munteanu> @google tryhaskell
05:59:49 <lambdabot> http://tryhaskell.org/
05:59:49 <lambdabot> Title: Try Haskell! An interactive tutorial in your browser
06:00:02 <Jeanne-Kamikaze> yeah, that
06:00:11 <hio> ok it doesn't say how to print anything
06:00:15 <Jeanne-Kamikaze> was googling it manually, didn't know lambdabot had google
06:00:17 <hio> i went on tryhaskell.org
06:00:25 <elliott> typoclass: it is a common strategy to say "X sucks!" on IRC in an attempt to get help with it. I find this strategy grossly inappropriate, so I disrecommend its use whenever I notice it.
06:00:35 <Eduard_Munteanu> hio: sure, because it won't let you execute arbitrary code on a public service
06:00:36 <typoclass> elliott: i don't think it makes sense to view it as a race to the bottom. "that guy started it, so i can continue it"
06:00:59 <Eduard_Munteanu> hio: try doing it in ghci, e.g. putStrLn "Hi there"
06:01:12 <typoclass> elliott: i don't know, i haven't noticed the "x sucks" strategy on #haskell ...
06:01:44 <elliott> ok. if you don't notice, that is fine. you are lucky, even
06:01:49 <hio> see what I mean? I can't even execute "hello world" in your tryhaskell website. How is haskell not complicated?
06:02:09 <elliott> hio: have you learned to write a hello world program in haskell? if not, of course it will not work
06:02:12 <typoclass> hio: anyway, a minimal hello world for haskell is a file containing 'main = print "ohai world"'. you can execute it by doing "runhaskell file.hs"
06:02:12 <Eduard_Munteanu> Is it just me or all lolcats suck? :P   <prompts typoclass to post cute kittens>
06:02:38 <hpc> haskell is just a category over the set of computable objects! what's so complicated?
06:02:41 <hpc> :P
06:02:47 <typoclass> Eduard_Munteanu: one more word and the ops will kick you!!!1! lolcats are great
06:02:55 <Eduard_Munteanu> :D
06:03:05 <hpc> lolcats < photoshop comics
06:03:07 * hpc ducks
06:03:21 * Iceland_jack has heard people call Haskell complicated but never for these reasons..
06:03:23 <hio> i cant find haskell for opensuse
06:03:32 <Chousuke> install haskell-platform
06:03:32 <elliott> hio: you should, say, read the first few chapters of http://learnyouahaskell.com/. and then if you have problems, ask for more specific help.
06:03:43 <Chousuke> but I think you're just trolling now so I won't help any more
06:04:00 <elliott> https://build.opensuse.org/project/show?project=devel:languages:haskell indicates openSUSE packages Haskell
06:04:26 <elliott> as for how to use your system's package manager, best to consult distro-specific resources, since haskellers aren't likely experts on arbitrary package management systems
06:04:27 <plhk> well, he has a point
06:04:28 <plhk> No instance for (GHC.Show.Show (GHC.Types.IO ()))
06:04:30 <plhk> arising from a use of `M877802579.show_M877802579'
06:04:33 <plhk> is not very helpful
06:04:38 <hio> it's too weird, I don't understand it. Look at that: succ 9 + max 5 4 + 1
06:04:51 <elliott> if it's too weird, that's fine. you don't have to use haskell.
06:05:04 <elliott> if you don't want to like it, nothing will make you.
06:05:05 <Iceland_jack> hio: Have you studied haskell for more than a day?
06:05:14 <Chousuke> or more than 5 minutes, more likely
06:05:25 <hio> no, but I know other programming languages and I am very quick learner. I just cant grok haskell
06:05:32 <elliott> but this channel is for people who care about haskell, want to learn haskell, etc. if you just don't think it has any value, then you won't get much out of the channel
06:05:38 <Chousuke> hio: Okay, have you even tried?
06:05:46 <Iceland_jack> Can't grok it after less than a day of trying..
06:05:50 <typoclass> hio: reading and writing files, i/o, networking, many basic things will not work on a website that executes code (tryhaskell.org). that's for security reasons. but i bet a site that lets you use another programming language will have the same restrictions. it's not a haskell thing
06:05:54 <hio> yes, I look for how to write a function but I cant find anything
06:05:57 <Eduard_Munteanu> hio: to be fair, many languages out there are rather similar, and Haskell is a bigger step outside that paradigm
06:06:04 <Chousuke> hio: Haskell is very different from most languages. You can't just expect to *know* how things work outright.
06:06:12 <merijn> hio: "f x = x" there you go, a function
06:06:19 <Chousuke> it's not complicated, nor is it difficult. it's just different
06:06:22 <elliott> hio: you've been pointed to several resources, such as the free online Learn You a Haskell book -- have you considered using them?
06:06:22 <int_index> hio, probably you'd like the C++ version more? "(9+1) + (5>4?4:4) + 1"
06:06:27 <elliott> they are better at teaching Haskell than IRC.
06:06:28 <int_index> How is it simpler?
06:06:51 <hpc> int_index: because everyone knows what (?:) is, duh!
06:06:56 <typoclass> hio: ok first thing: in haskell, "f 123" is a function call. (in other languages it might be written as "f(123)")
06:07:02 <merijn> :t (?:) -- :p
06:07:04 <lambdabot>     Not in scope: `?:'
06:07:04 <lambdabot>     Perhaps you meant one of these:
06:07:04 <lambdabot>       `??' (imported from Control.Lens),
06:07:17 <elliott> ...as we are about to find out, apparently...
06:07:34 <merijn> typoclass: He could just read LYAH instead of having us repeat it for him in here
06:07:40 <hio> so how do I know it's a function call instead of a variable
06:07:52 <int_index> Because there's no variables.
06:07:55 <Eduard_Munteanu> _?_:_ :: Bool -> a -> a -> a   -- :P
06:07:56 <typoclass> hio: second thing: function calls bind tighter than anything else. "succ 9 + max 5 4 + 1" is a call "succ 9", a call "max 5 4", and then "... + ... + 1"
06:07:57 <int_index> Enjoy
06:08:12 <elliott> something tells me hio isn't interested in reading a tutorial, anyway. they haven't answered my question as to whether they have been reading one
06:08:22 <elliott> another question might be, where did you find the code (succ 9 + max 5 4 + 1)?
06:08:27 <elliott> perhaps wherever it is from will provide an explanation
06:08:52 <hio> I did read a tutorial, but it makes no sense
06:08:54 <plhk> it's from lyah
06:08:56 <hio> they dont even mention classes
06:09:00 <typoclass> hio: that'd be the direct explanation of your code sample. having said that, you should check out lyah. it's a good book available for free
06:09:02 <typoclass> @where lyah
06:09:02 <lambdabot> http://www.learnyouahaskell.com/
06:09:04 <Iceland_jack> lol
06:09:06 <magicman> XD
06:09:06 <doomlord_> classes suck
06:09:08 <noteventime> b
06:09:10 <doomlord_> in OO
06:09:11 <noteventime> Err, sorry
06:09:15 <elliott> in fact LYAH does mention classes!
06:09:40 <elliott> (of a different kind, of course.)
06:09:44 <int_index> Haskell has classes, even more, a Monad is a class in Haskell.
06:09:52 <int_index> And it is in LYAH
06:09:56 <int_index> try reading it
06:10:00 <int_index> way better than any tutorial
06:10:03 <int_index> and with pictures!
06:10:08 <hpc> hio: people were programming for 60 years before "classes" became a thing :P
06:10:22 <doomlord_> the fad of OO
06:10:24 <hio> Every time I read into the tutorial, I just go like "wat". Here is something: A type is a kind of label that every expression has. It tells us in which category of things that expression fits.
06:10:39 <hio> a label to an expression? why would an expression need a label?
06:10:41 <typoclass> hio: when in other languages you would do something in an object-oriented way, it's done in other ways in haskell
06:10:44 <hio> whats a category in relation to expressions?
06:10:50 <noteventime> hio: Why would anything need a lable?
06:10:54 <Iceland_jack> This is too good
06:10:55 <hpc> hio: you don't know what a type is? :P
06:11:03 <elliott> hio: here is another free online tutorial you can read if you do not find LYAH to your liking, as seems to be the case: http://book.realworldhaskell.org/read/
06:11:15 <int_index> hio, those labels are used to treat sequences of bytes differently.
06:11:21 <Chousuke> seriously, my troll-o-meter is going off the charts :|
06:11:23 <elliott> hio: and here is its explanation of types: http://book.realworldhaskell.org/read/types-and-functions.html
06:11:24 <doomlord_> pure FP is probably less insane than pure OOP, but the best languages are hybrid IMO
06:11:34 <hio> a type is like a class, like a schema. So it by itself should be similar to a "label". so haskell doesnt conceptually make sense to me even on a theoretical level
06:11:38 <elliott> try reading that and if you have any questions about what it says, ask
06:11:44 <noteventime> doomlord_: What part of OO do you find useful?
06:12:08 <noteventime> hio: On a theoretical level it's all just category theory ;D
06:12:19 <elliott> hio: haskell is not like object oriented languages. this is intentional. if the words used have connotations like that to you, you should try to forget them.
06:12:21 <noteventime> Where a type is just an object
06:12:32 <doomlord_> in haskell i miss C style structs. but i'm not an OO fan - i despise the style of C+ or java where people try to force everything into classes
06:12:49 <hpc> doomlord_: C++ doesn't really force you to use classes
06:12:51 <doomlord_> i do prefer separating code & data
06:12:53 <hpc> you still have structs and such
06:12:55 <noteventime> doomlord_: How are C style structs different from just records?
06:12:59 <merijn> doomlord_: What do you miss about C style structs?
06:13:04 <Chousuke> classes are a very limited way of thinking about types
06:13:11 <doomlord_> hpc it doesn't, but there is an OOP culture to fight
06:13:16 <hio> doomlord_ I agree with you, I don't like classes just for the sake of classes. But haskell feels like different just for the sake of different
06:13:29 <hio> you cant seriously expect me to accept that this syntax was the best thing
06:13:35 <typoclass> hio: which tutorial have you been looking at? which part of the text is giving you trouble?
06:13:40 <doomlord_> haskell records seem like a bit of a hack, having said that i can see the value of function acessors
06:13:44 <noteventime> hio: What's wrong about the syntax?
06:14:07 <merijn> hio: You don't have to accept it, but trolling about it here by disagreeing with all the people who *do* think it makes sense/is worth it is kinda counterproductive
06:14:08 <Chousuke> hio: Haskell is different because it takes an entirely different approach to programming
06:14:08 <doomlord_> ( and yes the object.member syntax for acess is very convinient.. )
06:14:13 <Jeanne-Kamikaze> hybrid languages are inherently flawed
06:14:16 <merijn> doomlord_: Just use lens!
06:14:19 <doomlord_> :)
06:14:28 <Jeanne-Kamikaze> imagine a hackage with half the packages written in OO and the others in FP
06:14:34 <Chousuke> hio: it has its benefits, but it also means that many things you've learned from other languages simply don't apply
06:14:42 <doomlord_> somtimes functions make sense, sometimes objects make sense... a hybrid langauge lets you use the right tool for the job
06:14:47 <merijn> Alternatively, row type polymorphic records with dependent types! (Ha, look who's been reading the Ur stuff :p)
06:15:03 <noteventime> doomlord_: Well, it kinda makes sense if your basic operation is function abstraction and function application, don't you think?
06:15:24 <merijn> doomlord_: Well, you can have record subtyping even without sacrificing functional purity or having classes
06:15:32 <Chousuke> hio: however, if you do decide to learn haskell for real instead of complaining how unfamiliar and alien it seems to you, I guarantee you will like it.
06:15:43 <doomlord_> i still need to try templatehaskell
06:16:08 <doomlord_> record subtypeing would help, if i understood it correctlly..
06:16:28 <hio> there isnt even an IDE like qtcreator or visual studio.
06:16:32 <int_index> Well, anyway... I'm writing a server for an online game. And I have a question: what is the proper way to implement the game loop with respect to dealing with clients asynchroniously?
06:16:32 <doomlord_> hio haskell is worth learning, its very elegant
06:16:36 <hio> so I have to use vim?
06:16:41 <Jeanne-Kamikaze> there's leksah
06:16:52 <typoclass> Chousuke: btw, thanks for making productive comments
06:16:53 <doomlord_> ghci and hoogle are great tools
06:16:54 <hio> yeah that's what I tried last time
06:16:59 <hio> leksah
06:17:02 <Jeanne-Kamikaze> you don't have to use vim, real men use emacs
06:17:16 <typoclass> hio: you can use any text editor you like
06:17:19 <elliott> nobody said anything about vim. why are you bringing up vim?
06:17:22 <Chousuke> typoclass: I try my best :P
06:17:26 <merijn> doomlord_: Structural subtyping on records is just this: If you consider a record as a set of field, then a function "Record -> Foo" that requires a record with fields A, B and C will also work on all records whose fields are a superset of A, B and C
06:17:46 <merijn> doomlord_: i.e. you can pass a record with field A, B, C and D to a function expecting a record with fields A, B and C
06:18:19 <doomlord_> does that actually work in haskell
06:18:27 <merijn> doomlord_: Not in haskell, no
06:18:39 <int_index> guys..? a game loop? I'm stuck
06:18:41 <doomlord_> its a shame
06:18:42 <Iceland_jack> You can make it work with compdata!
06:18:42 <merijn> doomlord_: ocaml has it, though. And so do some other functional languages
06:18:51 <doomlord_> is it on the wishlist
06:18:57 <merijn> int_index: Stuck? In what sense?
06:19:03 <noteventime> Well, you could have a type class with a lens?
06:19:24 <int_index> I have no idea how to express it properly.
06:19:25 <merijn> doomlord_: You could probably fake it with GADTs + DataKinds + TypeFamilies, if you wanted, but it won't be as efficient
06:19:25 <Chousuke> I think Elm does structural subtyping
06:19:44 <noteventime> int_index: What exactly is the problem?
06:19:44 <doomlord_> thats where haskell feels odd - when you have to jump hoops to do something that C does easily. the rest of the time, its super elegant
06:19:44 <int_index> I could use some hacks like asking OS how much time has passed, but that's incredibly ugly
06:19:48 <merijn> int_index: Well, presumably you have a world state and you're doing some IO and changing it, right?
06:20:18 <int_index> Yes. The world updates with fixed frequency
06:20:23 <hio> ok I will give it another try, I will read a little and ask later
06:20:27 <int_index> say 60 times per second
06:20:29 <merijn> int_index: So propably you want like "(a -> m a) -> a -> m b" (i.e. infinite loop continuously passing the new state to the next iteration
06:20:33 <int_index> Not any faster.
06:20:41 <doomlord_> i like haskell tuples though..
06:20:48 <int_index> I'm troubling with dealing with time.
06:20:49 <Chousuke> hio: Just keep in mind that there's usually a reason for any weirdness you encounter
06:20:50 <Iceland_jack> hio: Good idea
06:20:59 <merijn> int_index: Asking the OS for how much time has passed is the usual implementation, though
06:21:08 <merijn> int_index: Whether that's in C or in haskell is irrelevant
06:21:14 <hpc> int_index: the most simplified way of doing a game loop is to have some sort of (IO Inputs) action that you run repeatedly
06:21:26 <hpc> int_index: and feed that to gameLoop :: Inputs -> State -> State
06:21:26 <doomlord_> definitely seems to be the case that currying and tuples save a lot of the cases where you create srtucts/classes
06:21:38 <hpc> int_index: and then perform other actions by reading from the state
06:21:50 <typoclass> hio: glad to hear it. keep lyah in mind (see link above). next time, even if you're frustrated, be sure to come in here with a specific question about some haskell code :-) that way you can avoid the accusations of trolling and the unproductive people
06:22:09 <int_index> merijn, sounds horribly hackish, though
06:22:09 <mm_freak> int_index: to get a time delta, keep a UTCTime (see Data.Time.Clock)
06:22:15 <merijn> int_index: Why?
06:22:28 <int_index> Dunno. I heard I could use FRP?
06:22:40 <mm_freak> int_index: gameLoop t' = do t <- getCurrentTime; let dt = diffUTCTime t' t; …; gameLoop t
06:22:51 <merijn> Ah, but that's an entirely different way of doing things, which will probably be tricky in its own ways
06:22:57 <mm_freak> that's how i get the time deltas in a real-time clockSession in netwire
06:23:41 <mm_freak> the result is a NominalDiffTime…  to get a Double of seconds, just apply realToFrac
06:23:49 <int_index> Okay thanks, I'll look into Data.Time.Clock
06:24:02 <hio> i cant find cabal-install
06:24:42 <typoclass> hio: so when you run "cabal", do you get a message "file not found"?
06:25:23 <mm_freak> int_index: if you want to get started with FRP, look into netwire =)
06:25:31 <hio> ok no wait, it is here. I tried it in the haskell prompt
06:25:34 <mm_freak> the Control.Wire module contains a quickstart tutorial
06:25:47 <int_index> Why not reactive banana?
06:25:53 <doomlord_> hio although there is no IDE, hoogle is an awesome tool that can do things IDE's in other languages cant ... haskel types are a really useful search tool
06:26:02 <merijn> int_index: Also: http://hpaste.org/83098 <- simple netwire example
06:26:27 <Chousuke> hio: btw, many Haskell abstraction come from category theory and so they have weird unintuitive names, but once you start to grok them you'll find that despite the initial weirdness, most of the abstractions are very practical.
06:26:30 <mm_freak> int_index: reactive-banana is currently better for widget-based UIs
06:26:44 <mm_freak> mainly because there is a wx binding for it
06:26:53 <Chousuke> abstractions
06:27:37 <doomlord_> i guess no one in the haskell comunity makes an IDE because (a) ghci/hoogle do what they want and (b) they have more interesting things to do..
06:27:49 <elliott> doomlord_: there is an IDE.
06:27:51 <elliott> @where leksah
06:27:51 <lambdabot> http://www.leksah.org/
06:27:54 <doomlord_> ahhh
06:28:19 <mm_freak> int_index: netwire on the other hand is designed for real time applications with complicated reactive systems, like games and simulations
06:28:25 <Iceland_jack> Every Haskeller I know just uses Emacs + ghci + some minor extensions
06:28:36 <hamid> Iceland_jack, no vim? :P
06:28:37 <mm_freak> that's why it has many predefined dynamic switching combinators and it's very easy to define your own
06:28:37 <Chousuke> hio: and you can just delay understanding Monads until you're more familiar with other haskell constructs. :P
06:28:51 <int_index> mm_freak, thank you. I hope arrows are not too complicated
06:29:00 <Iceland_jack> hamid: One person at my school uses vim for Haskell, that's it though
06:29:06 <mm_freak> int_index: you don't need the arrow interface most of the time
06:29:32 <mm_freak> its main style is applicative/categorical
06:29:32 <Jeanne-Kamikaze> mm_freak, so on your opinion netwire would be the best choice for games ?
06:29:38 <Jeanne-Kamikaze> *in
06:29:39 <mm_freak> Jeanne-Kamikaze: yes
06:29:45 <Jeanne-Kamikaze> what about yampa for example ?
06:30:19 <mm_freak> yampa is fine for simple cases, but its lack of an underlying monad makes certain kinds of applications really difficult to write
06:31:08 <mm_freak> for example you need to pass scene values around to construct a scene…  this is not necessary in netwire
06:31:13 <int_index> mm_freak, will it play well with event-based input from network?
06:31:31 <mm_freak> int_index: yes, all FRP frameworks should work well with that
06:31:54 <mm_freak> writing the main loop is still up to you
06:32:23 <doomlord_> is a monad just a wrapper for a type.
06:32:33 <hio> so what do I need as a top scrope to make putStrLn "Hi there" work in a file? tutorial goes on forever with 3+1 and interpreter stuff
06:32:36 <doomlord_> (a wrapper with other functoinality ..)
06:32:38 <hio> scope*
06:32:45 <hio> Parse error: naked expression at top level
06:32:56 <mm_freak> Jeanne-Kamikaze: btw, strictly speaking netwire is a generalization of yampa, so technically you can write a functor from SF to (Monad m) => Wire e m
06:33:12 <typoclass> hio: try "main = putStrLn ..."
06:33:28 <mm_freak> doomlord_: try to understand functors first
06:33:38 <hio> I dont get how "realworldhaskell" tutorial can start with an interpreter. Nobody writes haskell for real in the interpreter right
06:34:02 <typoclass> hio: here is another hello world http://hpaste.org/88161
06:34:03 <Jeanne-Kamikaze> in emacs you can always load your code in the repl and play around with it
06:34:14 <hio> I use runhaskell now
06:34:18 <Jeanne-Kamikaze> interactive programming or whatever it's called
06:34:22 <doomlord_> i think i can understand things when i do them, its just the unfamiliar jargon..
06:34:34 <Chousuke> hio: an interpreter is a good way to just try things out freely
06:34:53 <hio> but it removes all the familiar concepts of other programming languages
06:34:57 <hio> it's not good for teaching
06:35:02 <Iceland_jack> hio: You mean like ‘functions’?
06:35:04 <elliott> suspect your credulity. we haskellers do everything you can think of and worse.
06:35:07 <typoclass> hio: the interpreter is useful for trying out simple expressions (which is likely what beginners do), and for interactively poking around in a library (beginners + intermediates alike)
06:35:07 <hio> yes
06:35:08 <Reite> i strongly disagree
06:35:19 <mm_freak> doomlord_: it really pays off to understand functors first
06:35:21 <merijn> Python starts with an interpreter
06:35:22 <hio> no, beginners dont care about 1+1
06:35:25 <elliott> hio: didn't you say you were going to try learning haskell before passing judgement again?
06:35:26 <merijn> I'm pretty sure ruby does too
06:35:34 <Chousuke> hio: the point is to use the interpreter as a support, not for doing all of your programming
06:35:39 <merijn> Hell, one of my friends is working on a C interpreter in gdb
06:35:43 <hio> I'm simply giving you feedback immediately, I didnt pass judgement on anything
06:36:06 <mm_freak> doomlord_: to expand, every monad is a functor with some additional information
06:36:09 <hamid> :t (~<)
06:36:11 <lambdabot>     Not in scope: `~<'
06:36:11 <lambdabot>     Perhaps you meant one of these:
06:36:11 <lambdabot>       `<' (imported from Data.Ord),
06:36:21 <Iceland_jack> The two aren't mutually exclusive..
06:36:30 <arrivaloftime> anyone know the use of a quantity semaphore(increment/decrement with a value >= 1)?
06:36:33 <Chousuke> hio: you can eg. write one-off functions, check the types of expressions (extremely useful with haskell) and just try out ideas in general without the hassle of compiling a source file
06:36:41 <merijn> doomlord_: It helps to start thinking of simple Monads first, like Maybe
06:36:44 <merijn> :t (>>=)
06:36:46 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:36:52 <mm_freak> arrivaloftime: QSemN?
06:36:54 <merijn> :t (>>=) `asAppliedTo` (Just 1)
06:36:56 <lambdabot> Num a => Maybe a -> (a -> Maybe b) -> Maybe b
06:37:03 <hamid> i don't get this :| "data Wire e (>~) a b" ! where's the "=" ?!
06:37:04 <typoclass> hio: it's true that haskell is different from the mainstream languages, but 90% of those differences are intentional. for example, i prefer haskell's "f 123" because it's less clutter than other languages' "f(123)"
06:37:07 <merijn> :t (>>=) `asAppliedTo` (Just 'c')
06:37:08 <lambdabot> Maybe Char -> (Char -> Maybe b) -> Maybe b
06:37:27 <mm_freak> hamid: are you reading the haskellwiki tutorial?
06:37:38 <hamid> mm_freak, yeah about the netwire
06:38:05 <mm_freak> hamid: sorry, the tutorial is outdated…  you should visit the netwire package on hackage and look into the Control.Wire module
06:38:08 <mm_freak> @hackage netwire
06:38:08 <Chousuke> hio: you can also load your source file in the interpreter and run/test each of your functions separately, without actually writing a main function
06:38:09 <lambdabot> http://hackage.haskell.org/package/netwire
06:38:27 <typoclass> arrivaloftime: hello, you mean the package SafeSemaphore?
06:38:34 <Chousuke> hio: see the :load and :edit commands in ghci
06:38:47 <hamid> mm_freak, hmm ok then. but what's "data Wire e (>~) a b" ? is this a real piece of code?
06:38:51 <Chousuke> (:edit launches $EDITOR)
06:39:03 <mm_freak> hamid: it used to be
06:39:18 <merijn> doomlord_: I hope that type somewhat clarifies things?
06:39:42 <mm_freak> hamid: conceptually Wire as exported by netwire 4 is defined like this:  newtype Wire e m a b = Wire (a -> m (Either e b, Wire e m a b))
06:40:14 <merijn> arrivaloftime: They can be used in producer consumer situations
06:40:18 <hamid> mm_freak, oh! thank you :)
06:40:44 <mm_freak> you're welcome =)
06:40:50 <hio> how do I pass something to a function and execute it? doesnt work: http://collabedit.com/2ehsy
06:41:10 <merijn> arrivaloftime: i.e. producer increase the semaphore for every value it produces, consumers decrement it when they try to take a value. If the semaphore is already 0 consumers block on the semaphore until the producer increments it (at which point one consumer is woken up)
06:41:12 <hpc> hio: nice infinite redirect there ;)
06:41:19 <exicer> Say I want to do some web-scraping (using css selectors) - what should I be looking at? Is this a viable thing to do in Haskell ?
06:41:42 <merijn> exicer: You want to scrape the HTML?
06:41:43 <mm_freak> arrivaloftime: btw, semaphores are usually a bad choice…  MVar locking is more semantically meaningful
06:42:00 <exicer> merijn: Yes
06:42:00 <hpc> arrivaloftime: or TVars, or other things
06:42:08 <merijn> exicer: I've had pleasant experience using http-conduit for fetching pages and html-conduit for parsing html
06:42:25 <arrivaloftime> typoclass etc: i just mean a quantity semaphore in general. not a general/counting semaphore. just the usage of a semaphore that could be inc/dec with  a value that isnt 1.
06:42:32 <typoclass> hio: i've fixed your collabedit thingy
06:42:41 <merijn> exicer: That lets you specify things like "grab all h1 tags directly in a p tag" and that type of thing
06:42:50 <exicer> merijn: Cheers, I'll take a look. How accessable would you say it is for someone without much haskell experience ?
06:42:53 <mm_freak> arrivaloftime: QSemN did that, but i'm not sure whether it's still there
06:43:17 <typoclass> arrivaloftime: i see. i checked Control.Concurrent.QSem, but the docs say it'll be removed, and that people should start using SafeSemaphore
06:43:35 <merijn> exicer: http/html conduit are trivial, just glue types together. The cursor stuff used to select things was a bit confusing at first, but pretty easy to figure out with some playing around/experimenting
06:44:22 <exicer> merijn: Excellent - thanks. I'll have a play!
06:44:39 <hoyang> any haskell primer like c++ primer?
06:44:55 <hoyang> where can get it?
06:44:59 <hpc> @where lyah
06:44:59 <lambdabot> http://www.learnyouahaskell.com/
06:45:11 <elliott> hoyang: I know nothing about C++ or its primers. but try learn you a haskell or real world haskell
06:45:21 <hoyang> thank you!
06:45:26 <elliott> they are good introductions, free online or in dead tree form
06:45:48 <merijn> exicer: Simplest scenario: 'fromDocument . parseLBS <$> simpleHttp "http://www.example.com"' that gives you a Cursor (from Text.XML, works on HTML too) and then you use those to get the stuff you want
06:50:00 <prophile> is there a MonadPlus instance for the reader monad when it produces a monoid result or is that impossible in haskell's type system?
06:50:03 <hoyang> Learning haskell can make me smarter? aha!
06:50:36 <mm_freak> prophile: it's possible, but not defined, because it would be an arbitrary instance
06:50:55 <mm_freak> prophile: however, there is a Monoid instance for (Monoid b) => a -> b
06:50:55 <hoyang> seems this
06:51:07 <mm_freak> and '(->) a' is isomorphic to Reader a
06:51:07 <prophile> ah, interesting
06:51:20 <prophile> thanks mm_freak
06:51:39 <hoyang> seems it's will not be too simple, for me...
06:52:16 <sj4nz> learning haskell control structures is like learning the names of colors of the rainbow for the first time (there's more than just red and blue, there's everything in between). there's so much more than just if-then-else and functions with tail recursion.
06:53:26 <hoyang> i love if-then-else, but i poisoned by some language like php...
06:53:45 <hpc> if-then-else is a poor man's version of case-of
06:53:56 <typoclass> hio: the in-browser chat doesn't work very well for me -- type declarations are optional. you can provide them as a double-check (= the compiler will alert you when the type signature doesn't match the implementation) and as orientation for humans (= other readers of your code, or yourself in 3 months)
06:54:17 <sj4nz> hoyang: There isn't a single source or book I could rely on for the iceberg of haskell, you have to read it all. :)
06:54:36 <hio> why does it need "do" that doesnt make much sense. In every other language you can just put multiple statements, each line is a new one
06:54:48 <typoclass> hio: the general convention is that most people will write down type signatures for top-level definitions, and not bother writing them down for lower-level definitions
06:54:50 <prophile> is haskell not just function application and pattern matching? :)
06:54:52 <merijn> haskell doesn't have statements
06:54:54 <hoyang> errrr. read it all....
06:55:25 <typoclass> hio: 'do' starts a do block. it'll end based on indentation
06:55:26 <hoyang> ok, first book, i will read http://www.learnyouahaskell.com/, this.
06:55:47 <Iceland_jack> hio: It does make sense, but it's possible that you don't know why it makes sense
06:55:48 <typoclass> hio: yeah ... many c-like languages use "{" to start and "}" to end things
06:55:48 <sj4nz> hio: Haskell was first a purely functional language, the do came later when they needed a way to simplify imperative code with side effects
06:55:54 <hiptobecubic> hoyang, it's a good book.
06:55:55 <int_index> mm_freak, the diff trick with time works just fine, you have my thanks!
06:56:08 <mm_freak> you're welcome
06:56:40 <applicativer> ah the new 'google app engine' language; they're really advancing the cause of humanity.
06:57:12 <mm_freak> int_index: one thing to note about that approach is that it's quite slow…  on my machine i can perform around 40k diffUTCTimes per second
06:57:18 <hoyang> i use emacs, so i know a little of elisp, haskell is much like lisp?
06:57:29 <Iceland_jack> hoyang: Not really
06:57:30 <applicativer> not much like lisp
06:57:32 <typoclass> applicativer: haven't heard of that language. are they using go-lang for that?
06:57:32 <sj4nz> For any Haskell book, LearnYour or RealWorld, be ready to do close-reading (slow reading), it is far too easy think you "get it" if you read too fast.
06:57:39 <hpc> hoyang: it's only tenuously like lisp, and nothing like elisp
06:57:43 <mm_freak> int_index: if you need something faster and you're writing a game anyway, you can use SDL's getTicks action
06:57:50 <hiptobecubic> typoclass, I thought python was the main app-engine language
06:57:56 <applicativer> typoclass: php?
06:58:13 <typoclass> applicativer: oh, they offer that now? that seems like a bad idea :-)
06:58:22 <hoyang> php is evil.
06:58:25 <typoclass> hiptobecubic: i have no idea, applicativer just mentioned it
06:58:32 <merijn> typoclass: Had to compete with Azure Cloud, I guess?
06:58:38 <hiptobecubic> https://developers.google.com/appengine/   php and go are experimental
06:59:12 <sj4nz> hoyang: Be warned, once you "get it," programming in weakly-typed languages forever after will feel like working with punch cards. Send in your program to the nodejs interpreter and hope for a result to come back.
06:59:24 <applicativer> typoclass: yeah, java, php, ... why not something rational like a scheme or ... I won't suggest anything else.
06:59:37 <typoclass> sj4nz: ha, nicely put :-)
06:59:56 <sj4nz> That was my experience this week. Frustrating.
07:00:42 <applicativer> hiptobecubic: yeah, php was just announced; there was a period of excited anticipation I had come across where people were hoping they might support something genuinely interesting, but then ... php
07:01:00 <hoyang> sj4nz, you are right.
07:01:07 <hiptobecubic> well there's Go. That's something
07:01:36 <sj4nz> That's my other tip, slowly read type errors, they're essentially precog-debugging of your program before it runs. Don't fiddle with types and calls and keep throwing it at GHC until it "compiles."
07:02:15 <sj4nz> I like Go, but I'm thinking that Go isn't as expressive as Haskell without the advanced control structures.
07:02:50 <hoyang> thank you sj4nz!
07:03:23 <typoclass> @remember sj4nz Programming in weakly-typed languages forever after will feel like working with punch cards. Send in your program to the nodejs interpreter and hope for a result to come back.
07:03:23 <lambdabot> Nice!
07:04:08 <eikke> I dislike Go. Had to read some code recently, and had a "what have they been smoking"-feeling, and "why do people go wild about this"
07:04:11 <sj4nz> typoclass: Thank you!
07:04:28 <typoclass> sj4nz: ;-)
07:05:17 <sj4nz> Go compile-times I suspect are the secret sauce to that. I was enchanted by them. But then, you know, its still an imperative-style language. You still end up doing oodles of boilerplate to do simple things.
07:05:52 <hpc> the only reason you would spend so much effort getting go to compile quickly is if you are constantly compiling
07:05:58 <hpc> which... seems suspect to me
07:06:00 <eikke> sj4nz: if compile-time matters, try ocaml
07:06:40 <eikke> yeah! using things like ghc-mod you get close-to-immediate feedback about compilation success/failure
07:06:46 <typoclass> hio: yes, Show is a typeclass. we call it a typeclass to be clear that it's not like a class in an object-oriented language
07:06:58 <ParahSai1in> not much excuse for a language created in modern days to not have map, foldl/reduce etc
07:07:02 <elliott> hpc: not that suspect, it's common in Haskell after all
07:07:03 <int-e> hpc: have you ever renamed a function and used compile errors to find its occurrences?
07:07:21 <hpc> int-e: yes
07:07:31 <hpc> int-e: i compile once, then cover all the errors at once
07:07:34 <eikke> int-e: ghc isn't that slow for only that part of compilation
07:07:35 <sj4nz> I'm happy enough with Haskell and rationalize away GHC's "apparent" slowness as a debugging time-machine simulating my code execution in the near future to warn me that my plan to kill Hitler isn't going to work the way I thought it was.
07:07:57 <typoclass> hio: in principle, you can come up with your own symbols as you want. several of them are of course pre-defined, like + and * and ++ . you're of course right that it'll become confusing if someone goes bananas with this
07:08:16 <prophile> GHC can do all the type checking in the world and it still won't be able to tell you hitler's already dead
07:08:27 <hio> it seems like syntax means different things depending on context, maybe thats why everybody thinks haskell is complex
07:08:36 <sj4nz> profile: Lazy evaluation... lazy eval...
07:08:57 <int-e> eikke: I know. Otherwise I wouldn't be doing that anymore, I think.
07:09:06 <prophile> ah, so you're saying hitler's actually just lazily sleeping on the job?
07:09:13 <int_index> hio, it's true for almost every language
07:09:15 <typoclass> hio: uh, yes you could theoretically define + to be something else, but that of course might get confusing. to yourself, but especially to other people
07:09:49 <merijn> I used to think that the Gentle Introduction to Haskell was brutal, but after reading the 2nd chapter of the Ur tutorial, I might have to revise my classification of brutal...
07:09:54 <typoclass> hio: could you post an example for syntax meaning different things in different contexts? if it's >1 line of code, use hpaste.org please
07:10:09 <hpc> merijn: no, it is brutal
07:10:19 <eikke> anyone happens to work as an FP dev in some financial company in London?
07:10:22 <merijn> hpc: The Gentle Intro you mean?
07:10:25 <hpc> both
07:10:33 <sj4nz> search-and-destroy team is having an extended stay at the Paris Holiday Inn Express... they never seem to leave, something about the fresh cream cheese and brie in the time of war... they never get past that.
07:10:43 <merijn> The Gentle Intro is very Gentle compared to the Ur 2nd chapter :p
07:11:13 <plhk> what's Ur?
07:11:26 <merijn> plhk: Dependently typed pure functional language for writing web apps
07:11:36 <merijn> plhk: http://www.impredicative.com/ur/
07:11:50 <merijn> Check out the chapter 2 of the tutorial :p
07:12:52 <applicativer> what makes a man or woman choose (fn x => ... x ...) ?
07:13:10 <merijn> applicativer: ML based syntax
07:13:16 <int_index> mm_freak, I'm writing a server for a game, so I am in no need of handling graphics or sound
07:13:23 <int_index> So I don't think to use SDL
07:13:30 <applicativer> yes, common sense decided against it years ago.
07:14:00 <eikke> applicativer: ocaml uses (fun x -> ... x ...) and is still in use ;-)
07:14:13 <hpc> @quote defun
07:14:13 <lambdabot> defun says: [defun] conal: you seem knowledgable on the subject of FRP ... [conal] defun: btw, i invented frp.
07:14:25 <applicativer> yes, but it is a version of ml as racket is a lisp
07:14:28 <hpc> @quote without.defun
07:14:29 <lambdabot> djahandarie says: <Veinor> can't spell -funbox without fun!  <djahandarie> Veinor, can't write LISP without defun :-(
07:14:39 <merijn> applicativer: Ur is written in SML, though
07:14:45 <Eelis> merijn: heh
07:14:58 <applicativer> merijn: yes, what does that have to do with its syntax
07:15:10 <merijn> applicativer: Presumably the author likes that syntax? :p
07:16:18 <elliott> to be fair, (\x -> ...) is kind of ugly.
07:16:52 <supki> yeah, that \ should be λ
07:16:53 <applicativer> elliott: yes, but we have where too
07:17:02 <applicativer> no, its the -> that should go
07:17:08 <int_index> It's nice with unicode syntax, (λx → ...)
07:17:11 <applicativer> \x.x*x
07:17:35 <applicativer> \x y. x*y+x
07:17:39 <eikke> \(*). \x. (*) x x
07:17:44 <sj4nz> \x.++#^%#^%#&#NO CARRIER :)
07:17:45 <Eelis> (x → ...)
07:17:55 <typoclass> hio: it's somewhat common to make no distinction between trees and "subtrees". (whether in haskell or not)
07:18:00 <applicativer> \(*) x y.x*y
07:18:20 <typoclass> hio: and yes, a type can have many constructors
07:18:22 <elliott> int_index: GHC does not support that syntax.
07:18:29 <elliott> even if you turn on UnicodeSyntax
07:18:36 <int_index> It's up to IDE / editor
07:18:47 <int_index> eye candy, all that stuff
07:18:48 <hio> but just calling Leaf, doesnt create the type then I guess, I have to call them all
07:18:51 <applicativer> the lambda is already taken by the greeks darn them!
07:19:49 <applicativer> funny, there isn't a plain mathematical 'lambda' in unicode?
07:20:39 <arrivaloftime> anyone know the use of a quantity(not general/counting) semaphore(increment/decrement with a value other than 1)?
07:20:43 <typoclass> hio: could you rephrase that? it is possible do e.g. do "print (Leaf 123)". this will construct one Leaf, containing the number 123, of type Tree
07:20:44 <Iceland_jack> hio: Leaf is a function that expects a value
07:20:49 <arrivaloftime> oops wrong channel¨
07:21:03 <Iceland_jack> “Leaf 'a'” creates a value of type Tree Char
07:21:19 <applicativer> arrivaloftime: we can reformulate the question, maybe ...
07:21:28 <hio> I think I don't get the meaning of |
07:21:30 <Iceland_jack> “Leaf True” creates a value of type Tree Bool, ...
07:21:36 <Iceland_jack> hio: Just read it as “either or”
07:21:41 <hio> I thought it was to enumerate the values of what a type can consist of
07:21:59 <Iceland_jack>   data Bool = True | False means “the type Bool is either True or False”
07:22:09 <typoclass> hio: inside of "data ... = ... | ... | ...", the | just separates the constructors. you can read it as "or"
07:22:23 <applicativer> 'constructors of the type Bool are of the form True, or False'
07:22:24 <typoclass> hio: it's also possible that a type has only one constructor: "data ... = ..."
07:22:25 <eikke> Iceland_jack: no. a value of type Bool is either True or False
07:22:42 <applicativer> 'constructors of the type Bool are of the form: True, or else: False'
07:22:50 <Iceland_jack> eikke: Right, I was being inexact
07:22:57 <hio> and InnerNode is a constructor which creates two Nodes again? but wouldnt that be impossible recursion?
07:23:04 <apple_GT_orange> liftM :: (Monad m) => (a -> b) -> (m a -> m b) | liftM f = \a -> do { a' <- a; return (f a') } .... so if this is the definition of liftM, what the hell does "a' <- a" do? Unpacks a non-monadic value into itself?
07:23:18 <Iceland_jack> hio: The ‘recursion’ ends with a Leaf
07:23:44 <prophile> the do is equivalent to a >>= (\a' -> return (f a'))
07:24:05 <hio> so how do you create a Node now, which constructor do you use
07:24:37 <Iceland_jack> 14:21 < Iceland_jack> “Leaf True” creates a value of type Tree Bool, ...
07:24:43 <Iceland_jack> ↑ is that what you're asking?
07:24:48 <merijn> apple_GT_orange: a' is not the same a, in the same way that b is not the same as a
07:24:52 <typoclass> hio: you're right that this is a recursive data structure (well done). InnerNode (Node a) (Node a) doesn't create two more Nodes, it takes them as arguments. (Node a) here indicates a type, like Int, String, or Maybe String (if you're a little more advanced)
07:24:55 <Iceland_jack> granted the types have changed since then..
07:25:24 <merijn> apple_GT_orange: And as prophile points out do notation is just syntactic sugar for >>= and >>
07:25:44 <merijn> @undo do { foo; x <- bar; return (f x) }
07:25:44 <lambdabot> foo >> bar >>= \ x -> return (f x)
07:26:17 <apple_GT_orange> merijn: so to get to the punch, what is the value of 'a then if I pass in some value, like a char, as a
07:26:32 <jmcarthur> just something i want to note:
07:26:41 <prophile> apple_GT_orange: char isn't a monad, so a compile error :)
07:26:52 <jmcarthur> having seen tons of people learn ocaml by now, they have not had much trouble with monads. i suspect it is due to the lack of syntax sugar
07:27:06 <merijn> apple_GT_orange: A simple example:
07:27:12 <merijn> :t (>>=)
07:27:14 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:27:23 <merijn> :t (>>=) `asAppliedTo` (Just 'c')
07:27:25 <lambdabot> Maybe Char -> (Char -> Maybe b) -> Maybe b
07:27:31 <eikke> jmcarthur: using monads while *learning* ocaml?
07:27:43 <apple_GT_orange> Maybe I'm not reading this right, doesn't (Monad m) => (a -> b) -> (m a -> m b) imply that the given "a" value is not a monadic value to begin with?
07:27:43 <aristid> jmcarthur: where do you get to observe people learning ocaml?
07:27:52 <jmcarthur> aristid: oh you know where i work by now
07:27:56 <eikke> aristid: I do, actually, at work :-)
07:28:10 <int_index> apple_GT_orange, it doesn't matter.
07:28:12 <jmcarthur> eikke: who are you? :P
07:28:32 <merijn> apple_GT_orange: No, what it says is "given a function (a -> b), and an "m a", I can give you back an "m b""
07:28:39 <jmcarthur> eikke: but yeah, while learning ocaml usually
07:29:02 <eikke> jmcarthur: interesting. We use some monad stuff in our ocaml projects, but that's not really 'learner-level' code
07:29:03 <applicativer> couldnt they build in something like do notation maybe like our rebindable syntax one?  it makes a lot of sense
07:29:09 <merijn> :t liftM (=='a')
07:29:11 <lambdabot> Monad m => m Char -> m Bool
07:29:18 <eikke> applicativer: there's an existing syntax-extension for it
07:29:20 <jmcarthur> eikke: usually it comes a bit later as it would in haskell, but we certainly don't try to hide it up front or anything
07:29:22 <merijn> :t liftM (=='a') `asAppliedTo` (Just 'c')
07:29:24 <lambdabot> Maybe Char -> Maybe Bool
07:29:30 <applicativer> eikke: ah.
07:29:34 <typoclass> hm ... this collabedit thingy would be quite nice if it was a bit more reliable and had some haskell syntax highlighting. and minimal awareness of indentation
07:29:36 <eikke> applicativer: and Lwt, which is monad-style, has its own syntax extension as well, providing something do-like
07:29:36 <jmcarthur> applicativer: such an extension exists, but we actually prefer not to use it
07:29:45 <int_index> apple_GT_orange, if `a' is actually monadic, say `Monad n => n k', so the type becomes `(Monad m, Monad n) => (n k -> b) -> (m (n k) -> m b)
07:29:58 <typoclass> btw, where is shapr's ghc live project? is it running anywhere?
07:30:01 <merijn> int_index: That's not really helpful for his question, I think
07:30:27 <int_index> It proves that `a' can be monadic.
07:30:49 <merijn> apple_GT_orange: liftM takes a function that works on a value and turns it into a function that works on monads returning that type of value
07:31:11 <merijn> > liftM (=='a') (Just 'c')
07:31:13 <lambdabot>   Just False
07:31:29 <merijn> (In fact, liftM is secretly just fmap)
07:32:02 <eikke> :t liftM
07:32:04 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
07:32:07 <eikke> :t fmap
07:32:08 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:32:23 <eikke> let's wait till the typeclass-hierarchy for Monad is fixed ;-)
07:32:37 <merijn> eikke: So...never? :>
07:32:39 <applicativer> there's nothing broken about it.
07:32:50 <typoclass> :t "quiggle"
07:32:51 <lambdabot> [Char]
07:33:07 <apple_GT_orange> merijn: Okay, I'm fixed now. Thanks for bringing it home. I see where I went wrong.
07:33:32 <eikke> merijn: lots of proposals again on the lists lately
07:33:35 <typoclass> hio: you can also use :t in here. lambdabot will evaluate it very similar to ghci. [Char] means "list of Char", and that is the same as String (they are synonyms)
07:34:11 <applicativer> @type cycle ("quiggle" :: String)
07:34:12 <lambdabot> [Char]
07:34:23 <merijn> apple_GT_orange: It helps to take "do" code like that and desugar it by hand on paper to get a better feeling for it
07:34:31 <merijn> apple_GT_orange: Or you can use @undo with lambdabot
07:35:28 <applicativer> @undo do {x <- [1,2,3]; y <- "abc"; return (x,y)}
07:35:28 <lambdabot> [1, 2, 3] >>= \ x -> "abc" >>= \ y -> return (x, y)
07:35:45 <applicativer> > [1, 2, 3] >>= \ x -> "abc" >>= \ y -> return (x, y)
07:35:47 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
07:36:10 <applicativer> mzero hi!
07:36:20 <mzero> goood morning
07:36:32 <arrivaloftime> if a mutex is locked does that mean that no other task can execute at all?
07:36:36 <typoclass> hio: to "bundle" functions and datas, you can use a module. the relation is simply that one haskell source file contains one module. this may or may not be what you need in any particular case
07:37:08 <arrivaloftime> with a binary semaphore jsut the task that Waits on it when it is 0 is blocked. is a mutex the samre or are all tasks blocked when a mutex is locked?
07:37:09 <applicativer> mzero: are we supposed to be testing platform things?
07:37:32 <mzero> there are release candates for the srouce tar ball and the mac build up
07:37:42 <mzero> still waiting for the windows RC build
07:37:49 <merijn> arrivaloftime: A mutex is a semaphore with a maximum value of 1
07:37:59 <applicativer> ah
07:38:24 <elliott> typoclass: (I can't help but feel I'm missing something...)
07:39:03 <applicativer> mzero, who does the windows packaging? it must be an immense task
07:39:26 <typoclass> elliott: true :-) there's a couple of people talking on http://collabedit.com/2ehsy . the chat function doesn't work too well in my browser, so i've occasionally talked in here
07:39:42 <typoclass> elliott: is it bothering people?
07:39:45 <mzero> Mikhail Glushenkov does it - and I imagine it is!
07:39:50 <elliott> oh, I see.
07:40:26 <mzero> the mac one, even while 95% automated with a giant make script, is a pretty big undertaking as well
07:40:45 <applicativer> ah, hail Mikhail
07:41:05 <applicativer> yes the mac one is familiar to me
07:41:41 <jmcarthur> wow, a collabedit link in #haskell sounds like a disaster
07:42:38 <typoclass> jmcarthur: i've always wanted to walk all over other people's text, sometimes accidentally, sometimes intentionally ;-)
07:43:09 <int_index> if netwire supports only the Kleisli arrow, does it mean it could be rewritten with Monads and not Arrows?
07:43:25 <int_index> with the same functionality, of course
07:43:41 <applicativer> int_index: yes, but he's always insisting arrows are irrelevant, no?
07:44:16 <int_index> I mean, why use something you don't need?
07:45:03 <typoclass> hio: foo :: Int -> Int -> Player means that foo will take an Int argument, another Int argument, and give back something of type Player
07:45:34 <hio> ah ok, weird that it uses the same syntax for parameter and return value
07:45:52 <int_index> hio, it does not.
07:46:06 <typoclass> hio: and yes, it is allowed to write "data Foo = Foo ...", i.e. using the same name for the type and for the constructor of that type. i don't really recommend that for beginners because i think it can be confusing. i'd rather use "data Player = P ..."
07:46:22 <hio> but that's how other languages do it
07:46:25 <hio> it would make more sense
07:46:29 <haasn> hio: “A -> B” means a function that takes something of type A and returns something of type B
07:46:32 <hio> constructor name is always class name
07:46:35 <typoclass> hio: yeah, it's a bit influenced by mathematics i guess. they say things like "function from Int to Int" ... "Int -> Int"
07:47:05 <haasn> hio: “A -> (B -> C)” means it takes something of type A and returns another function, which itself has type “B -> C”. That's how the syntax is formally justified
07:47:23 <hio> haasn, that by itself would be fine, but int -> int -> Player, would mean int returns an int, but instead it really means two ints return player
07:47:27 <typoclass> hio: hm ... you're right. in java you get a "default constructor" with no arguments, which has the same name as the class
07:47:43 <typoclass> (... i hope i remember that correctly. been a while)
07:47:46 <Chousuke> hio: actually, it means one int returns a function from int to Player
07:47:46 <Hafydd> hio: -> is right-associative
07:47:47 <hio> not just the default
07:47:49 <haasn> hio: that's the exact same as Int -> (Int -> Player); the parentheses are optional because (->) associates to the right
07:47:53 <hio> every constructor has to have the same name
07:47:55 <int_index> hio, "int -> int -> Player" means "int -> (int -> Player)" and "->" stands for a function
07:47:55 <hio> as the class
07:47:57 <applicativer> hio dont worry, it all makes perfect sense.  except for the bits that only sort of make sense
07:48:15 <haasn> hio: it, technically, does *not* mean “takes two parameters”, it still means “takes one parameter and returns another thing, which is a function” - taking two parameters is just how we tend to think of it
07:48:19 <Chousuke> hio: so you can call that function as (f 1) and you will have a new function that only takes one int and results in a Player
07:48:37 <Chousuke> so you can eg. do map (f 1) [1, 2, 3] to get a list of three players
07:48:46 <applicativer> > let incr = (+1) in incr 3
07:48:48 <lambdabot>   4
07:49:11 <Hafydd> > succ 3
07:49:13 <lambdabot>   4
07:49:19 <hio> yeah i dont know why we would need 'let', we were fine till now.
07:49:20 <Chousuke> hio: it takes some getting used to, but it's very powerful when you work with functional combinators.
07:49:39 <hio> every tutorial introduces 'let', but we got very far without it ever coming up
07:49:46 <haasn> hio: ‘let’ is just used to introduce temporary definitions that are only valid within the scope of that expression
07:49:49 <typoclass> hio: yes, in haskell, you can view "f :: Int -> Int -> Foo" as a function that takes two Ints and gives a Foo, or equivalently as a function that takes one Int and gives a function of type Int -> Foo
07:49:58 <Hafydd> (does (+1) necessarily have to be the same as succ?)
07:50:01 <applicativer> let is kind of ugly, sort of ... ML ish
07:50:04 <Chousuke> :t succ
07:50:06 <lambdabot> Enum a => a -> a
07:50:08 <typoclass> hio: it's a bit weird but it allows you to do neat things
07:50:15 <Chousuke> :t (+1)
07:50:18 <lambdabot> Num a => a -> a
07:50:20 <haasn> like so: “let <definitions> in <expression>” -- normally you could also put definitions on the top level of the file, which you're probably familiar with, but lambdabot is only (hey lambdabot is back) an expression evaluator
07:50:29 <hio> typoclass, I think it makes sense, the 'right associate' bit someone mentioned makes it clearer
07:50:48 <applicativer> @type foldr
07:50:50 <haasn> Hafydd: you can have Enum without Num
07:50:51 <lambdabot> (a -> b -> b) -> b -> [a] -> b
07:50:57 <applicativer> @type foldr (+)
07:50:59 <lambdabot> Num b => b -> [b] -> b
07:51:00 <Hafydd> I know, but assuming you have both Enum and Num.
07:51:05 <applicativer> @type foldr (+) 0
07:51:06 <lambdabot> Num b => [b] -> b
07:51:18 <applicativer> @type foldr (+) 0 [1..10]
07:51:20 <lambdabot> (Enum b, Num b) => b
07:51:24 <hio> haasn, there isn't a default block scope? we need to use let to have block scope?
07:51:28 <Hafydd> In what situation would it make sense for succ x /= (+1) x?
07:51:29 <haasn> > succ (maxBound :: Word8)
07:51:30 <Chousuke> hio: yeah, you can read a -> b -> c -> d as a -> (b -> (c -> d))
07:51:30 <lambdabot>   *Exception: Enum.succ{Word8}: tried to take `succ' of maxBound
07:51:36 <haasn> > (+1) (maxBound :: Word8)
07:51:37 <lambdabot>   0
07:51:42 <Hafydd> Hmm.
07:51:50 <Chousuke> haasn: succ works for things that are not numbers
07:52:00 <Chousuke> > succ 'a'
07:52:02 <lambdabot>   'b'
07:52:03 <applicativer> > succ 'a'
07:52:03 <applicativer> ha
07:52:04 <lambdabot>   'b'
07:52:04 <haasn> Chousuke: yes I mentioned that
07:52:16 <Chousuke> haasn: oops I was supposed to say that to Hafydd
07:52:24 <Hafydd> :i Char
07:52:29 <haasn> :i does not exist here
07:52:41 <Hafydd> @src Char
07:52:41 <lambdabot> data Char = C# Char#
07:53:14 <typoclass> Hafydd: Char has an instance for Enum, therefore succ 'x' works
07:53:37 <typoclass> Hafydd: 'x' + 1 of course won't work
07:53:44 <applicativer> > succ LT
07:53:45 <lambdabot>   EQ
07:54:11 <haasn> hio: I'm not sure what you mean by “a default block scope”; there are a few other ways to introduce definitions only valid within a certain scope, one of them is a ‘where’ clause eg. “f x = go x 0 where go x n = ...”; which is more or less equivalent to “f x = let go x n = ... in go x 0” but cleaner (where also spans multiple lines of the function definition, whereas let only spans one
07:54:13 <haasn> expression)
07:54:15 <applicativer> > [LT .. GT]
07:54:17 <lambdabot>   [LT,EQ,GT]
07:54:33 <Hafydd> This is tangential to my question.
07:55:09 <Hafydd> > succ 0.1
07:55:12 <lambdabot>   1.1
07:55:24 <haasn> hio: and, inside a ‘do’ block, you can introduce local expressions like do { n <- foo; let f = (+n); bar (f 3); ... } -- which is functionally equivalent to do { n <- foo; let f = (+n) in do { bar (f 3); ... }}
07:55:25 <Hafydd> > succ (0.1 :: Double)
07:55:27 <lambdabot>   1.1
07:55:31 <geekosaur> there's several longish mailing list rants about that
07:55:46 <Hafydd> Is that even right?
07:55:50 <elliott> geekosaur: if they're longish, hate to see what you'd consider long
07:55:55 <elliott> Hafydd: it lets you say [1.0,1.2..10]
07:55:58 <elliott> and stuff.
07:56:04 <elliott> > [1..10] :: Int
07:56:04 <elliott> er
07:56:05 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
07:56:06 <lambdabot>              with actual type ...
07:56:07 <elliott> > [1..10] :: [Int]
07:56:08 <elliott> > [1..10] :: [Double]
07:56:08 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
07:56:10 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
07:56:18 <hio> sorry haasn, that's a little too much to take in, I just wanted to know if there really isn't something like a normal block scope like you get with c# where memory gets reclaimed after the variable falls out of it
07:56:18 <Hafydd> > [1.0, 1.2, ... 10]
07:56:20 <lambdabot>   A section must be enclosed in parentheses thus: (... 10)Not in scope: `...'...
07:56:21 <typoclass> Hafydd: the Enum instance for Double is weird. arguably it shouldn't even have an Enum instance
07:56:21 <haasn> hio: but apart from that exception (which is technically just syntax sugar), Haskell is based on expressions and not on control flow or execution blocks; so ‘let’ is the natural way to introduce new definitions
07:56:32 <geekosaur> elliott, indeed you would :)
07:56:33 <Hafydd> > [1.0, 1.2 .. 10]
07:56:35 <lambdabot>   [1.0,1.2,1.4,1.5999999999999999,1.7999999999999998,1.9999999999999998,2.199...
07:56:39 <Hafydd> Heh.
07:56:47 <Chousuke> floatsssss
07:57:06 <geekosaur> been some years since the last time I saw a 6-month-plus thread, although that is in part because I've usually dumped the communities that spawned them as dysfunctional
07:57:10 <haasn> > [1, 1.2 .. 10 :: CReal]
07:57:11 <lambdabot>   [1.0,1.2,1.4,1.6,1.8,2.0,2.2,2.4,2.6,2.8,3.0,3.2,3.4,3.6,3.8,4.0,4.2,4.4,4....
07:57:42 <haasn> typoclass: don't get me started on Bounded :)
07:57:42 <typoclass> hio: haskell is lazy, that means stuff only gets evaluated if you actually need it. it's also garbage-collected like most modern languages
07:58:03 <haasn> hio: haskell doesn't have ‘variables’ in that sense
07:58:04 <Hafydd>  > succ (sqrt 2 :+ sqrt 2)
07:58:10 <Hafydd> > succ (sqrt 2 :+ sqrt 2)
07:58:11 <lambdabot>   No instance for (GHC.Enum.Enum (Data.Complex.Complex a0))
07:58:12 <lambdabot>    arising from a...
07:58:17 <haasn> hio: the closest thing to a variable would be a function parameter
07:58:19 <Hafydd> Well, at least there's that.
07:59:03 <Chousuke> hio: "blocks" of code don't usually make sense since you rarely execute things "one after another" unless you're actually using IO
07:59:14 <typoclass> my conclusion: floats are weird and sneaky. the Enum instances for floats are weird and sneaky
07:59:26 <Chousuke> hio: rather, you should consider most haskell code  as consisting of definitions
07:59:28 <typoclass> Chousuke: we have do blocks, of course
07:59:32 <haasn> once something is defined, it's immutable within that scope; and once the scope is no longer needed most haskell interpreters would generally garbage collect unneeded definitions and so on; which would make ‘let ... in ...’'s behavior be analogous to “falling out of the scope”
07:59:41 <Hafydd> So enumFromTo should actually be Num a => arithmeticSequenceFromTo
07:59:45 <Hafydd> Or something.
07:59:55 <Chousuke> typoclass: yeah, but that's just a syntactic thing :)
08:00:06 <haasn> typoclass: blocks of definitions :)  (of course there's also ‘do’ blocks but I don't think we should discuss these quite yet for fear of confusion)
08:00:24 <Hafydd> Or probably something that is neither Num nor Enum.
08:00:51 <haasn> Hafydd: Num/Enum/Bounded has many warts
08:00:56 <Chousuke> hio: so for example when you say sum = map (+) you're literally stating that the definition of "sum" is a partial application of "map" to the function (+)
08:01:00 <haasn> and any attempt to fix them is likely to introduce new ones
08:01:06 <Chousuke> er, wait
08:01:15 <Chousuke> that was supposed to be a fold...
08:01:19 <hio> + can be a function? wat
08:01:23 <haasn> (+) is a function
08:01:28 <Chousuke> :t +
08:01:29 <merijn> hio: + *is* a function
08:01:30 <lambdabot> parse error on input `+'
08:01:31 <haasn> :t (+)
08:01:32 <lambdabot> Num a => a -> a -> a
08:01:35 <Chousuke> eh
08:01:40 <Chousuke> I clearly need a break
08:01:43 <Hafydd> Everything's a function!
08:01:44 <Chousuke> oh well
08:01:47 <merijn> :t map (+) [1..]
08:01:49 <haasn> Hafydd: not everything :)
08:01:49 <lambdabot> (Enum a, Num a) => [a -> a]
08:01:53 <Hafydd> (nullary or otherwise)
08:01:53 <Iceland_jack> hio: (hey, I'm one of the people writing on collabedit)
08:01:56 <Chousuke> merijn: yeah, not very useful
08:01:57 <hio> ghci doesnt take ' + 1 2'
08:02:02 <Iceland_jack> another way of defining plus is: plus = (+)
08:02:04 <hio> so it cant be a function
08:02:05 <haasn> Hafydd: nullary functions don't exist in Haskell. That's an ideological thing
08:02:05 <merijn> > (+) 1 2
08:02:05 <Chousuke> hio: syntactic thing
08:02:07 <lambdabot>   3
08:02:25 <Hafydd> haasn: how can you justify that they "don't exist"?
08:02:30 <Chousuke> hio: + is an operator as well so to treat it as a function you wrap it in parens
08:02:31 <hio> so haskell has a special extra syntax just to make people like doing math more?
08:02:33 <applicativer> > map (\f -> f 2) $ map erwise)
08:02:34 <merijn> Hafydd: You'll give Conal a heart attack saying that
08:02:36 <lambdabot>   <hint>:1:29: parse error on input `)'
08:02:38 <Chousuke> hio: pretty much
08:02:45 <Chousuke> hio: you can also define your own operatos
08:02:45 <hio> ok
08:02:46 <haasn> Hafydd: the Haskell report clearly defines what functions are and nullary ones are not included
08:02:49 <applicativer> > map (\f -> f 2) $ map (+) [1..10]
08:02:51 <lambdabot>   [3,4,5,6,7,8,9,10,11,12]
08:02:54 <merijn> Hafydd: http://conal.net/blog/posts/everything-is-a-function-in-haskell
08:02:59 <geekosaur> hio: compiler assymes things with symbolic names are infix. wrap those in parens to make them prefix or standalone. conversely, wrap a prefix function (alphanumeric+_+') in `` to make it infix
08:02:59 <Chousuke> hio: and use a regular function as an operator by wrapping it in backticks
08:03:00 <mzero> hio: the function is named (+) with parenthesis.... when used as an operator  3 + 4    it is just syntatic sugar for  (+) 3 4
08:03:04 <Iceland_jack> merijn: Not everyhting is a function in Haskell
08:03:14 <Iceland_jack> *everything
08:03:27 <elliott> Iceland_jack: ...maybe click the link :P
08:03:31 <typoclass> > map toUpper "lol"
08:03:33 <lambdabot>   "LOL"
08:03:35 <Chousuke> hio: this actually works with constructors too
08:03:43 <Chousuke> a -> b is equivalent to (->) a b
08:03:48 <Hafydd> But isn't Haskell isomorphic to a language defined with nullary functions instead of values?
08:03:54 <typoclass> > toUpper `map` "lol" -- same as above! with backticks, you can write the function between its 2 arguments
08:03:57 <lambdabot>   "LOL"
08:04:02 <haasn> hio: operators (anything that consists of symbols instead of letters, roughly) have special syntax in Haskell, you can call them infix with two parameters, like so: (3 + 4); if you want to call them ‘normally’ ie. like normal functions, you have to enclose the operators in parentheses: (+) 3 4
08:04:14 <Hafydd> It doesn't really matter what the language report says.
08:04:17 <elliott> "nullary function" can be meaningful in some contexts. it doesn't mean that every value is a function.
08:04:24 <elliott> for instance, you wouldn't refer to Int as being a "depth-0 nested list".
08:04:27 <haasn> hio: the reverse is also possible, ie. you can call a normal function infix as if it were an operator: plus 3 4  becomes (3 `plus` 4)
08:04:29 <elliott> even though it's technically true.
08:05:03 <Hafydd> But I see I'm having a conversation which has been had before, so nevermind.
08:05:05 <Chousuke> hio: as an aside, there's more syntax for something called operator sections (I think?), ie you can do (+1) and it's equivalent to \x -> x + 1
08:05:12 <applicativer> Int is also a depth 0 Maybe, a depth 0 infinite stream ...
08:05:14 <typoclass> elliott: when the police stopped Int the other day, the shady fellow claimed he was the root of a tree that just happened to have no children
08:05:24 <Chousuke> hio: which leads to a small wart in the language when you try to do (-1)
08:05:37 <haasn> hio: in reality, there's really no distinction between them other than the syntax, operators and functions behave exactly the same
08:05:51 <elliott> Hafydd: wow, where's your IRC spirit?? :P
08:05:54 <typoclass> Chousuke: i'd just call it "section", but yes
08:05:58 <Hafydd> Hahah.
08:06:40 <haasn> I think prefix negation is a wart :(
08:06:48 <Chousuke> hio: so yeah, there's some syntactig sugar and a bit of weirdness relating to it, but no-one said Haskell is perfect
08:06:53 <haasn> though I'm not quite sure (negate 3) or (0-3) would be much better
08:07:20 * applicativer writes (0-3) since he can never remember the rule
08:07:33 <mzero> I've learned to accept it --- and write (\x -> x - 1) as   (-1+)    !!!!
08:07:42 <haasn> mzero: nice
08:07:45 <mzero> :-)
08:07:50 <haasn> I prefer (subtract 1) for clarity
08:07:53 <haasn> but that's a neat trick
08:08:02 <hio> I guess my whole point about haskell is that the syntax is not intuitive, in a sense that you can explore it just by typing and trying things out
08:08:06 <typoclass> mzero: thanks for making things clear :-)
08:08:10 <hio> can't*
08:08:12 <mzero> hio - have you ever used a shell?
08:08:16 <typoclass> 'clear' in the sense of 'unclear', of course
08:08:24 <hio> yes, bash isn't intuitive either
08:08:26 <haasn> hio: haskell's syntax is intuitive to people who've used languages with similar syntax ;)
08:08:29 <applicativer> > (-1+) 2
08:08:30 <lambdabot>   1
08:08:36 <mzero> have you taken trig?
08:08:42 <Chousuke> hio: what you consider "intuitive" syntax might just be something you've learned previously and just *know* by now
08:08:42 <applicativer> well, you learn something new every day on #haskell....
08:08:56 <elliott> first you're surprised haskell lets you write (1 + 2) instead of (+ 1 2) and now you think it's unintuitive? :)
08:08:58 <ClaudiusMaximus> live-sequencer's syntax doesn't have prefix -, i used 0-1 there...
08:09:10 <mzero> so why is      map toUpper    not clear    but     grep '*.hs'    clear     and     sin 2x     clear?
08:09:12 <hio> well it's all about congruity
08:09:23 <hio> and in haskell it's hard to see it
08:09:28 <haasn> mzero: he just said bash isn't intuitive :P
08:09:40 <Chousuke> hio: it just takes a bit of learning, but ultimately it's just syntax. As long as it works well with the language itself (and in Haskell's case that is true), it's pretty irrelevant to compare it to other languages.
08:09:52 <typoclass> hio: it's true that haskell is different from other languages, particularly the mainstream ones. but in my opinion, for 90% of differences, haskell has good reasons
08:09:54 <mzero> well - I think "intuitive" in this context is nonsensical
08:09:54 <haasn> hio: it just takes some time
08:10:02 <mzero> there is nothing  intuitive about     sort(x)
08:10:12 <mzero> it is just a notatino due to Gauss
08:10:19 <ClaudiusMaximus> but live-sequencer doesn't support sharing, so i might give up on it until it does (eg: implementing Data.List.transpose explodes in a shower of filters)
08:10:22 <hio> what do you mean by sort(x)
08:10:26 <mzero> exactly
08:10:36 <hio> what language, I mean the context
08:10:36 <applicativer> hah
08:10:44 <mzero> that is what you'd write in, say, PHP
08:10:54 <Hafydd> What does sort(x) do in PHP?
08:10:57 <hio> yeah, and I would intuitively know "it will sort x somehow"
08:10:58 <mzero> or   x.sort()   in some languages      or    x.sort   in a few others
08:11:04 <Demos> seems like haskell takes some time to learn but once you understand it you can use it to create really clear powerfull code, kinda like math notation in that way
08:11:12 <applicativer> x.sort() is so intuitive
08:11:15 <Chousuke> hio: the thing about haskell not using foo(x,y,...) for a function call is that with currying and other things, it would lead to a lot of unnecessary parens.
08:11:35 <applicativer> to say nothing of commas
08:11:36 <mzero> and       sort x      is not the same?  why not?   you learned     sin x      long before you learned    sort(x)
08:11:58 <Chousuke> so in haskell's case, the "unintuitive" paren-free, slightly ambiguous-looking syntax actually works much better
08:12:01 <hio> well first its called sin(x)
08:12:02 <haasn> new ArraySorterFactory().GenerateSorter(SortingAlgorithms.QuickSort).Sort(new SortableContainer(x));
08:12:04 <haasn> in others
08:12:08 <mzero> no hio, it is not
08:12:19 <mzero> in math, you write it     sin x     without the parenthesis
08:12:20 <Hafydd> LOL
08:12:23 <hio> and secondly math isn't intuitive either, far from it. It's very much like haskell, in a sense that there are tons of different symbols
08:12:30 <hio> and lots of syntax variations
08:12:36 <haasn> mzero: it's worth noting that in my school system we have always used sin(x)
08:12:46 <Chousuke> hio: actually, from one viewpoint Haskell is math
08:12:52 <applicativer> x.sort() is really a case of symbolism eating itself
08:12:53 <haasn> all programming languages are math
08:12:54 <Chousuke> just something you can execute
08:13:03 <mzero> really? and what did you do when you got to calculus?
08:13:03 <jmcarthur> sort(x) is perfectly valid haskell, too
08:13:04 <hio> i dont know where you learned math, but in my schools we always wrote sin(x)
08:13:10 <Chousuke> haasn: in Haskell it's just more explicit
08:13:15 <merijn> "The only intuitive interface is the nipple, after that it's all learned."
08:13:25 <Jaxan> it is the same with log n, nobody write the parens there (about complexity)
08:13:34 <Hafydd> If you write "sin(x)" enough times, you start to see the benefit of writing "sin x".
08:13:35 <mzero> you guys are killing me!    you went to schools where sin x   was written sin(x)   ? That is very sad
08:13:40 <Jaxan> O(log log n) is very common to write...
08:13:57 <hio> no it isnt cmon
08:14:03 <mzero> how did you cope when you got to calculus   - or do you write parents after an integral too?
08:14:08 <haasn> mzero: no
08:14:10 <jmcarthur> mzero: sin x,  but f(x)
08:14:20 <Jaxan> exactly this ^
08:14:21 <haasn> mzero: we just appended ‘ dx’ like you normally would
08:14:27 <haasn> or whatever
08:14:29 <mzero> actually, in many texts, if f has one argument    just   f x
08:14:30 <hio> theres parens in integral: https://en.wikipedia.org/wiki/Integral
08:14:32 <Chousuke> mzero: a particularly nasty integral might make you long for your mom. :P
08:14:32 <applicativer> at my school we wrote x.sin() to prepare us for the business world
08:14:39 <haasn> we did f(3) as well
08:14:47 <Hafydd> Hahah.
08:15:05 <Demos> I think that fighting over parens is pretty pointless, like argueing about {} style in C
08:15:22 <mzero> but in any event - as much study into the effectivness of programming language syntax has shown -- "intuitive" is a totally false sense ---- none of them are intuitive
08:15:35 <mzero> in the sense that you can "intuit" what they mean, even approximately
08:15:38 <Demos> and I dont think that anyone would argue that a(a(a())) is better than a $ a $ a
08:15:53 <Jaxan> a^n is better ;)
08:16:07 <Chousuke> haasn: we did f(3) for most functions but things like sin and log were written without parens.
08:16:18 <Demos> yes mzero this is true, if it we could intuit what they mean we would all be writing COBOL
08:16:22 <typoclass> hio: in summary, for calling functions, some languages use the syntax of comma-separated arguments with parens around them. haskell uses the syntax of space-separated arguments. it's just one difference. if you haven't learned this yet, it's frustrating (that's understandable). on the upside, it's not difficult to learn, and most books explain it clearly
08:16:35 <Hafydd> So a :: () -> (), a () = ()
08:16:54 <haasn> come to think of it, we don't have a generalized (^) anywhere, do we? the closest is foldr b (f) (replicate n x)
08:16:55 <Jaxan> ;D
08:17:04 <mzero> on the downside - once you've learned it and written about 500 lines of Haskell.... You'll hate writing in all other programming languages!  :-)
08:17:06 <Hafydd> I'd then argue that () is better than a(a(a()))
08:17:12 <applicativer> the situation is a little more theoretical than that typoclass
08:17:22 <haasn> Hafydd: :)
08:17:48 <Demos> mzero, and 500 lines of haskell is like 1500 lines of C
08:17:57 <haasn> Hafydd: what about a :: a -> Int; a = const 3
08:17:57 <mzero> easily
08:17:59 <applicativer> we have tuples too, the contrast with space separated arguments is part of the theory
08:18:06 <typoclass> applicativer: sure. i'd argue that haskell has good reasons for this part of the syntax
08:18:09 <Chousuke> hio: Trust me, you'll come to like the paren-free syntax once you get more comfortable working with higher-order functions.
08:18:36 <Hafydd> haasn: okay, replace () with 3.
08:18:50 <hio> okay, thanks for all your help guys. I can get into haskell now if I want. I was not convinced it is better than other languages though.
08:18:55 <_just> wait..there are parens in haskell?
08:19:08 <hio> I mean, what does all this extra syntax allow me to do?
08:19:15 <hio> different*
08:19:23 <Chousuke> hio: It's better at a lot of things, but not as good at others.
08:19:24 <elliott> what language are you comparing to anyway?
08:19:33 <elliott> haskell's syntax is much simpler than many
08:19:38 <haasn> hio: imagine Haskell used f(x)-like syntax, you'd have to use eg. sum(x) = foldr((+))(0)(x) -- instead of sum = foldr (+) 0
08:19:41 <hio> C, java, etc
08:19:46 <Hafydd> > let a = const 3 in a(a(a()))
08:19:48 <lambdabot>   3
08:19:53 <elliott> you should see C++'s grammar :)
08:20:06 <haasn> type-checking C++ can be a nightmare ;)
08:20:10 <Hafydd> I suppose with type classes you could come up with even more examples.
08:20:14 <Chousuke> hio: C and java are not languages where working with higher-order functions is common
08:20:19 <elliott> i suggest the issue is one of familiarity more than complexity.
08:20:22 <jmcarthur> what extra syntax
08:20:25 <elliott> as far as syntax goes.
08:20:28 <jmcarthur> i didn't actually mean to send that
08:20:30 <Chousuke> hio: though you can do it with Java somewhat okay
08:20:35 <hio> fine, then take javascript: functions are very easy to use there
08:20:38 <typoclass> hio: anyway, i get that at first glance, haskell frustrates you. that's understandable :-) i think everyone in here had that feeling at some point
08:20:43 <hio> What does haskell help me to do that javascript cant
08:20:54 <jmcarthur> that's not a very fair question
08:21:00 <Demos> hio: think functinally and write better javascript
08:21:00 <haasn> Chousuke: really?
08:21:14 <jmcarthur> you can write any program in any equivalently powerful programming language
08:21:14 <haasn> Chousuke: what does that look like, in java? I was under the impression that java doesn't have higher-order functions at all
08:21:20 <Chousuke> haasn: Sure, it just looks like foo.each(new Runnable {{ run() {doStuff()} }});
08:21:34 <haasn> ah
08:21:37 <Chousuke> Java 8 will have lambda syntax though
08:21:39 <hio> Demos, that's what I don't get about the recent trend to promoting functional programming. It's shorter, sure. But it's not simpler, so there is a compromise instead of a clear win-win
08:21:55 <Chousuke> hio: I contest that it is simpler
08:22:01 <eikke> hio: it's simpler (and more composable/reusable) in the long end
08:22:01 <exicer> Probably stupid question - why would you need case when you have guards and pattern matching ?
08:22:12 <elliott> exicer: case is pattern matching
08:22:17 <Chousuke> hio: it just takes some exposure to it to see why
08:22:21 <elliott> exicer: consider pattern matching on "compare x y" where x and y are two arguments
08:22:23 <jmcarthur> hio: one is not qualified to make such claims before even understanding it
08:22:27 <hio> oh cmon, you can't tell anyone that these whole map() functions are intuitive
08:22:28 <Iceland_jack> hio: Honestly, you don't know enough Haskell to make that judgement call from what I've seen on collabedit
08:22:30 <hio> to read or write
08:22:32 <jmcarthur> yes
08:22:32 <Demos> in c++ you can do thinks like std::bund([&](){return fn();}, stuff, std::placeholders::_1, std::placeholders::_2); but nobody really wants to when in haskell that would jusst be f(something)
08:22:33 <elliott> not a guard, and not a pattern match on an argument
08:22:34 <jmcarthur> very
08:22:34 <Chousuke> hio: they are
08:22:44 <elliott> hio: "intuitive" is more or less meaningless.
08:22:53 <hio> ok fine, then explain to me how map() makes it obvious what maps to what
08:22:58 <Chousuke> hio: you just need to be comfortable with the fact that you can use functions as values just like everything else.
08:22:58 <hio> it is never clear
08:22:59 <elliott> if you start from the assumption that haskell is innately more complex, yes it will seem to be that way.
08:23:01 <eikke> hio: Python devs have no trouble understanding 'map'
08:23:07 <Chousuke> hio: you can look at the type signature
08:23:22 <Chousuke> map :: (a -> b) -> [a] -> [b]
08:23:23 <elliott> however you may want to consider that it is lack of imagination: you can't see what haskell looks like when you understand it. and that is okay, but you should be honest about that
08:23:50 <elliott> if you start from the assumption that it's all hopeless complexity, it will be very frustrating
08:23:51 <hio> yes, so what you are saying is that I have to look at the map function defintion to undestand it
08:23:52 <Chousuke> hio: given a function from a to b, and a list of as, you will get a list of bs
08:23:58 <Iceland_jack> hio: no?
08:23:59 <Chousuke> hio: no, the type is enough
08:24:01 <hio> so I could just as well keep writing normal code and just make a helper func
08:24:01 <typoclass> hio: my experience is that it's hard to get something to compile in haskell, but once it does, there's not many bugs in it anymore. in dynamic languages, it's very different. things start running immediately, but misbehave constantly, for a very long time
08:24:04 <Hafydd> I list of bees!
08:24:09 <haasn> hio: I can tell you what Haskell offers me, personally: It offers me the ability to write less code to do the same things as compared to other languages, furthermore that code is more easily readable (to me). I use Haskell because it offers me a great deal of code re-use through abstractions and generalizations, without sacrificing the benefits of a type-system
08:24:28 <haasn> hio: whether or not you share this viewpoint is up to you, it's a personal thing and nobody can force you to use any language
08:24:38 <eikke> and GHC brings a rather great RTS (compared to several other RTSs out there)
08:24:39 <Chousuke> hio: it should be pretty intuitive what map does if you just read the type signature out loud as I just did
08:24:43 <jmcarthur> hio: i can tell from the type what   (a -> b) -> F a -> F b   does without knowing that it's map
08:25:07 <typoclass> Chousuke: yeah ... in principle yes, but that requires some knowledge of haskell already
08:25:26 <Chousuke> typoclass: I suppose so
08:25:26 <EvanR> map is not a haskell-specific concept
08:25:27 <Demos> even if you done use haskell on a regular basis knowing it will help you write better code
08:25:45 <eikke> typoclass: just like you can't just figure out what "int a = 0; *(&a) = 5;" means ;-)
08:25:45 <geekosaur> there is nothing particularly intuitive about programming, period. there are conventions, and those conventions are different in different domains. Prolog conventions would look utterly bizarre to someone whose primary exposure is Javascript
08:25:47 <haasn> hio: there's a reason haddock documentation only includes the type signatures, the implementation is generally irrelevant, and often you don't even need extra documentation to understand the function
08:25:56 <hio> anyway, I think my input wasn't totally useless. If someone would write a tutorial for haskell which goes the path of what I went now, it would help more people understand it. Start with how to write a function, then how to call it, then how to call it with parameters
08:26:02 <andrea__> " (a -> b) -> F a -> F b " is this a functor ? ( sorry i'm new to haskell
08:26:15 <eikke> hio: isn't that what LYAH does?
08:26:18 <Chousuke> andrea__: it's fmap, except F should be f
08:26:21 <Iceland_jack> That's what LYAH does
08:26:24 <Demos> hio: that tutorial is called LYAH, or learn you a haskell for great good
08:26:25 <EvanR> :t fmap
08:26:26 <jmcarthur> hio: there are not functions without parameters in haskell
08:26:26 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:26:43 <hio> absolutely not. LYAH starts with the interpreter
08:26:44 <jmcarthur> hio: if a value has no arguments it's just not a function
08:26:46 <hio> for about 10 pages
08:26:51 <haasn> “how to call it” and “how to call it with parameters” is the same thing, no?
08:26:57 <Demos> haskell has a unit type correct, like ()
08:27:03 <jmcarthur> Demos: yes
08:27:06 <hio> haasn, no absolutely not
08:27:08 <haasn> every function, by definition, requires a parameter
08:27:22 <typoclass> hio: anyway, it'll be difficult or impossible to learn haskell by assuming it's like c or like javascript with just minimal differences. i think you're going to be endlessly frustrated if you input "for (int i = 0; i < 123; i++)" in ghci and then curse why it doesn't work. you do need to read a tutorial, otherwise it'll be frustrating
08:27:23 <hio> it is not obvious how to add parameters to a function call
08:27:24 <typoclass> @where lyah
08:27:24 <lambdabot> http://www.learnyouahaskell.com/
08:27:27 <hio> and how to use them
08:27:28 <Chousuke> hio: in haskell there are no functions without parameters
08:27:28 <jmcarthur> Demos: but if you mean to imply that a function that takes () is a function with no arguments, i disagree. it takes () as an argument
08:27:29 <Demos> there a function that takes no parameters and returns nothing takes 1 parameter of () and returns a ()
08:27:30 <eikke> hio: so? working with the REPL is a good first introduction, no need to start with edit/compile/run-cycles
08:27:33 <typoclass> hio: anyway, here is the lyah link again, just to be sure
08:27:47 <andrea__> i don't understand the difference between map and fmap
08:27:48 <Chousuke> hio: a function "without a parameter" is a value instead
08:27:59 <EvanR> fmap works with any functor
08:28:01 <Chousuke> andrea__: fmap is a generalisation of map
08:28:02 <haasn> let x = 3 in x -- ‘x’ is not a function here
08:28:13 <EvanR> :t map
08:28:13 <jmcarthur> andrea__: fmap is just a generalization. anywhere you use map you can use fmap instead (sometimes requiring an explicit type signature, perhaps)
08:28:14 <lambdabot> (a -> b) -> [a] -> [b]
08:28:15 <haasn> andrea__: fmap = map; for one instance of Functor
08:28:20 <eikke> andrea__: map is fmap but specific to lists, i.e. less general
08:28:32 <jmcarthur> @quote contrapuntal
08:28:32 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
08:28:35 <Hafydd> > fmap (+1) (1,2,3)
08:28:37 <lambdabot>   No instance for (GHC.Base.Functor ((,,) t0 t1))
08:28:38 <lambdabot>    arising from a use of `e...
08:28:38 <eikke> andrea__: you could replace every occurrence of 'map' with 'fmap', and things will still work (not the other way around)
08:28:42 <Hafydd> Oh no.
08:28:55 <Chousuke> how did asAppliedTo work again?
08:29:01 <hio> for Gods sake, just look at the first page of LYAH. Down in the middle of the first page you present to haskell learners, are things like: zip [1,2,3,4,5] [5,5,5,5,5]  . This is a utility function nobody cares about. It's a neat trick. People who want to learn a language, don't want to learn neat tricks, they need to understand grammar and how to code real things
08:29:01 <jmcarthur> :t asAppliedTo
08:29:03 <lambdabot> (t -> b) -> t -> t -> b
08:29:12 <jmcarthur> hio: you are wrong. that's a very useful function
08:29:15 <Chousuke> hio: zip is a very useful function
08:29:15 <Iceland_jack> hio: It's useful
08:29:19 <hio> hahaha
08:29:19 <eikke> hio: zip is very useful
08:29:21 <hio> yes it is
08:29:24 <jmcarthur> hio: you just don't understand haskell style yet. you are not in a place to criticize yet.
08:29:24 <hio> but not to beginners
08:29:28 * elliott sigh
08:29:29 <hio> to learn haskell
08:29:33 <eikke> it is
08:29:34 <andrea__> Chousuke: i don't undesrstand it because i have no idea to use a map to a differnt thing
08:29:37 <EvanR> hio: zip is not very haskell-specific either
08:29:40 <andrea__> different to a list
08:29:50 <haasn> hio: what the function doesn't matter when you're still learning the syntax
08:29:53 <haasn> does doesn't*
08:30:01 <elliott> hio: you're being persistently disingenuous about haskell and its learning materials, always assuming that it's the most complex or the most badly written at every turn.
08:30:06 <jmcarthur> hio: look, your claims are backed by ignorance. please stop talking about things you don't understand
08:30:08 <eikke> andrea__: you know what map does to a list. now consider a tree-like datastructure, or an array
08:30:18 <elliott> what do you want people to do, given that nothing said has convinced you of anything?
08:30:18 <eikke> andrea__: you could do the same as what map does to lists on those
08:30:28 <hio> oh ok, I'm ignorant
08:30:28 <jmcarthur> hio: ask questions here. don't just complain complain complain
08:30:45 <jmcarthur> hio: no offense intended by that. i meant it by the dictionary definition of the word
08:30:46 <andrea__> eikke : what structure ? a binary trey by example ?
08:30:54 <andrea__> tree
08:30:58 <eikke> andrea__: yeah. or an array, or anything at all. some structure
08:30:59 <Chousuke> hio: it's like you're asking for the tutorial to tell you how to write a GUI application off the bat
08:31:18 <hio> holy shit, yes that would be perfect
08:31:22 <eikke> andrea__: basically, map (or fmap) 'modify' the values contained in some structure, whilst preserving the 'shape' of the structure
08:31:23 <Iceland_jack> hio: No..
08:31:23 <EvanR> gross
08:31:25 <Chousuke> hio: before you even understand what functional programming is and what style of programming is suitable for Haskell
08:31:30 <jmcarthur> 'Lacking knowledge, information, or awareness about something in particular: "ignorant of astronomy".'
08:31:32 <andrea__> eikke: do you know an exaple listing ?
08:31:49 <elliott> if you want that out of a tutorial, there are other languages probably more suited to it. like visual basic or something. haskell isn't in that market
08:31:54 <haasn> > fmap (*10) (Node 3 [Node 4 [], Node 5 [Node 6 [], Node 7 []]]) -- andrea__
08:31:54 <Chousuke> hio: you'd be building a house on sand. no foundation
08:31:56 <lambdabot>   Node {rootLabel = 30, subForest = [Node {rootLabel = 40, subForest = []},No...
08:32:15 <eikke> andrea__: what haasn said ^^ :)
08:32:16 <haasn> > fmap (*1) (Just 3) -- andrea__
08:32:18 <lambdabot>   Just 3
08:32:20 <haasn> err
08:32:24 <haasn> meant (*10 ) :D
08:32:34 <haasn> but you get the idea
08:32:46 <andrea__> ok, i will start the ghci and try it ,
08:32:46 <hio> a gui application tutorial would instantly tell you all the important building blocks of using haskell for real things. How to call functions (= display a message box) How to add parameters to function calls (=show your own text in the message box) . Everything I just talked abuot. All the other language tutorials do it that way. Only haskell users somehow find that beneath them
08:33:07 <Iceland_jack> hio: Then the GUI introduction would inevitably bring up the a bazillion things and then you would complain about it introducing too many things at once
08:33:08 <elliott> hio: ok, you're just trolling now. stop assuming bad faith on the part of everyone involved in the haskell community, it's ridiculous.
08:33:09 <EvanR> zipping is more often useful than building an entire gui application
08:33:11 <Chousuke> hio: except that's not how you'd do it in haskell
08:33:24 <Chousuke> hio: you don't display a message box by calling a function in haskell
08:33:26 <jmcarthur> hio: all the things you are rejecting as useless in the tutorial you are reading *are* useful. you are just being stubborn
08:33:29 <hio> what, I can't display message boxes in haskell?
08:33:36 <haasn> hio: the problem is, a tutorial like that would leave you more confused than at the beginning
08:33:41 <Chousuke> hio: you can, you just don't do it by calling a function
08:33:41 --- mode: ChanServ set +o elliott
08:33:49 <eikke> haskell might not be the best language to write purely gui applications, unless you use advanced concepts like FRP which you wouldn't understand as a novice anyway
08:33:51 --- mode: elliott set +q hio!*@*
08:33:53 <jmcarthur> ah beaten by elliott
08:34:06 * Iceland_jack heavy sigh
08:34:15 <haasn> eikke: or ugly do blocks reminiscent of imperative code ;)
08:34:34 <haasn> and who would want to show newcomers abominations like those? :D
08:34:42 <Chousuke> hio: haskell is not like other languages. that's why you can't just show people how to program imperatively in haskell and call it a day.
08:34:50 <snhmib> because do blocks are where the usefull stuff happens!
08:34:52 * snhmib runs
08:34:54 <eikke> haasn: if 99% of your app is do-blocks, you might as well use something better-suited for gui stuff
08:34:57 <Chousuke> because then they would be coding horrible code in haskell
08:34:58 <elliott> hio: only the slightest bit of charity is being asked for here. the soapboxing is tedious. I'll give the discussion a few minutes to cool off.
08:35:00 <jmcarthur> eikke: disagree
08:35:05 --- mode: ChanServ set +o copumpkin
08:35:07 --- mode: copumpkin set +z
08:35:17 <copumpkin> >_>
08:35:20 <haasn> eikke: in practice, perhaps, in principle, no - Haskell can be a great imperative language
08:35:33 <haasn> sure, you retain a more error-prone style, but you still get the benefits of abstraction generality
08:35:37 <eikke> haasn: agree, but I tend to think in 'practical' terms :)
08:35:39 <geekosaur> frp is no longer quite in its infancy but it's not quite up to tutorials level yet
08:35:39 <haasn> abstraction and*
08:35:40 <Fuuzetsu> I see that silly discussions are in full power today again.
08:35:41 <wonderer111> Is there a way to fix the definition for'Ex2' in http://hpaste.org/88165 ?
08:35:47 <jmcarthur> eikke: even if 90% of your functions are written in do notation, 90% of your code in general is still not in do notation. every function application is still just normal function application
08:35:57 --- mode: copumpkin set -o copumpkin
08:36:01 <wonderer111> It'd be nicer to not have to separately define 'Foo'
08:36:11 <jmcarthur> eikke: and you still benefit from all the things haskell has to offer even when using monadic styl
08:36:13 <jmcarthur> *style
08:36:23 --- mode: elliott set -q hio!*@*
08:36:26 --- mode: elliott set -o elliott
08:36:31 <haasn> jmcarthur: the only drawback is that Haskell doesn't have the best library support for that style, compared to languages like python
08:36:39 <jmcarthur> haasn: for what style?
08:36:40 <Fuuzetsu> wonderer111: data Ex2 = Ex2 Foo?
08:36:48 <jmcarthur> haasn: monadic style? python has *no* support for that
08:36:54 <EvanR> python has pretty terrible support for that style
08:36:59 <EvanR> imperative style
08:37:04 <jmcarthur> that either
08:37:07 <andrea__> is haskell faster than python ?
08:37:08 <haasn> jmcarthur: imperative style
08:37:10 <Demos> err so I have a question, how can I write classic FORTRAN code in haskell :D
08:37:15 <Fuuzetsu> You can't specify constructors as types
08:37:18 <jmcarthur> python is stuck in imperative style. haskell allows you to choose when to use it and when not to
08:37:26 <magneticduck> wonderer111: if you're doing something of the form data Foo = {f :: Bar}
08:37:38 <typoclass> i agree that it'd be worth a shot to try a new haskell tutorial in a kind of reference style (think lyah but without the prose text, just well-chosen code and comments). i think it'd be useful for beginners and intermediates alike, and maybe even for experts occasionally
08:37:40 <magneticduck> wonderer111: it's always going to be nothing more than a wrapper
08:37:42 <Demos> andrea: "faster" means very little
08:37:43 <Chousuke> haskell has superior support for functional programming, great support for imperative programming, and mediocre support for object-oriented programming
08:38:00 <jmcarthur> no language has good "support" for OO
08:38:13 <Chousuke> smalltalk probably dodes
08:38:14 <Chousuke> does
08:38:23 <haasn> haskell has better support for object oriented programming than “object oriented languages” like Java
08:38:30 <Demos> Chouskue: well what the hell is Object oreanted programming good for when you have essentially no state?
08:38:39 <jmcarthur> Demos: a lot
08:38:48 <Chousuke> Demos: StateT all the things?
08:38:49 <EvanR> i have a hard to doing OO with haskell (as I define it)
08:38:58 <EvanR> hard time*
08:39:00 <jmcarthur> Chousuke: you can still use pure objects
08:39:03 <typoclass> andrea__: very roughly yes, haskell is often faster than python. check the language shootout for some benchmark numbers
08:39:04 <jmcarthur> oop
08:39:06 <jmcarthur> s
08:39:08 <andrea__> perhaps the support for graphical programming is not better
08:39:08 <jmcarthur> Demos: ^^
08:39:40 <Chousuke> It seems GUIs require an imperative style in haskell
08:39:48 <Chousuke> since FRP is not quite a solved problem yet
08:39:49 <typoclass> andrea__: here you go, haskell vs python http://benchmarksgame.alioth.debian.org/u32/benchmark.php?test=all&lang=ghc&lang2=python3&data=u32
08:39:56 <jmcarthur> Demos: OO is not really about hiding state. it's more about hiding implementation details.
08:39:59 <haasn> wonderer111: in your line 9, you seem to be introducing new values (Bar and Baz) that haven't been defined before. If that's what you mean, then no, it's not possible - you won't get around defining data Foo = Bar | Baz
08:40:02 <typoclass> andrea__: take it with a grain of salt, obviously =)
08:40:03 <andrea__> thx, typoclass
08:40:23 <Chousuke> pure functions in haskell hide implementation details perfectly
08:40:28 <jmcarthur> sure
08:40:35 <Chousuke> which is actually very interesting
08:40:37 <EvanR> right, that characterization of OO doesnt distinguish it from anything else
08:40:46 <jmcarthur> EvanR: exactly why it's overrated
08:41:03 <jmcarthur> i don't know of any characterization of OO that really distinguishes it from anything else
08:41:05 <haasn> wonderer111: that said, if you have something like data Foo = Bar Int | Baz String then you could do data Ex2 = Ex2 {f :: Either Int String} -- but then you lose the information possibly provided by the ‘Bar’ and ‘Baz’ tags
08:41:10 <Demos> jmcarther: no I think OO is about handling state, it is about having a way of defining things that have a reference to their scope
08:41:21 <Chousuke> though I suppose with laziness the implementation details can leak through :/
08:41:27 <jmcarthur> Demos: the second thing you said doesn't support the first thing you said
08:41:32 <Chousuke> eg. foldl' vs foldl
08:41:43 <jmcarthur> Demos: "a way of defining things that have a reference to their scope" is precisely about hiding implementation details
08:41:46 <haasn> OO is about objects passing messages to eachother to induce behavior
08:41:53 <jmcarthur> Demos: it's also equivalent to a closure
08:41:55 <haasn> as I understand it, at least
08:42:05 <wonderer111> haasn magneticduck Fuuzetsu : ok, my question boils down to: can I write the following hpaste more succinctly (one one line) http://hpaste.org/88165
08:42:09 <Demos> jmcarther, OK I can agree with that
08:42:25 <jmcarthur> haasn: message passing is a fine thing, but there are many message passing styles that are not commonly called OO
08:42:26 <EvanR> haasn: oo is about objects is circular, behavior is not well defined, if the 'behavior' was that of a pure function we have functional programming
08:42:34 <haasn> wonderer111: http://hpaste.org/88165
08:42:36 <haasn> done
08:42:48 <magicman> >_>
08:43:12 <andrea__> after many years with c and jaya , i was curious to haskell
08:43:22 <Hafydd> > let oo = oo in oo
08:43:24 <eikke> andrea__: tha'ts a good thing :)
08:43:37 <lambdabot>   thread killed
08:43:38 <EvanR> Hafydd: C++
08:43:45 <wonderer111> haasn: :-) I meant: can the definition of Foo be written within the definition of Ex2 ?
08:43:47 <eikke> andrea__: make sure not to give up too early though. might take some time until you get things done which seem trivial in e.g. Java
08:43:52 <Chousuke> Demos: Mutable state is also not a problem in haskell, you just need to be explicit (until you explicitly abstract it out of sight)
08:43:52 <magneticduck> wonderer111: nope, and I don't really see why you'd want to
08:43:54 <haasn> wonderer111: no :)
08:44:00 <Hafydd> EvanR: are you saying something good about C or something bad about C++?
08:44:04 <eikke> andrea__: but after a while the mental effort does pay off (and actually makes you a better C/Java/whatever dev as well)
08:44:10 <typoclass> andrea__: good call :-) if you give it enough time to get past the learning curve, i think you'll be very surprised and excited
08:44:16 <EvanR> Hafydd: lol
08:44:17 <magneticduck> wonderer111: unless there's some weird thing that I don't know of already
08:44:20 <haasn> wonderer111: that's as succinct as you can get, and looks like good style to me
08:44:36 <haasn> well
08:44:39 <haasn> no, let's not go down that route
08:44:45 <eikke> andrea__: do you understand the relation between map and fmap now, and is it somewhat clear what fmap is all about?
08:44:55 <magneticduck> wonderer111: if you're going to make something as data Foo = {f :: Bar}, you might as well make it a newtype
08:44:57 <haasn> but purely of esoteric interest: Either (Sing "Bar") (Sing "Baz") -- would do the same thing
08:45:07 <haasn> but you don't want that :)
08:45:12 <andrea__> eikke: perhaps I understand it now
08:45:13 <magneticduck> wonderer111: newtypes are more efficient at putting a little wrapper on something
08:46:11 <andrea__> thanks for aour help
08:46:14 <andrea__> your
08:46:15 <eikke> andrea__: the way I tend to think about it: fmap is a function which, for some container containing values, allows applying a ffucntion on the values contained in some container, whilst preserving the shape of the container (where container is a list, a tree, a graph, some Maybe value, ...)
08:46:32 <EvanR> though its not necessarily about containers
08:46:44 <Chousuke> andrea__: the basic idea of a functor is that it's both a way to add structure to another type, and to map functions of the old type to another to a matching function in the realm of "extended" types
08:46:47 <eikke> EvanR: true
08:47:09 <Aly_> hi
08:47:11 <Aly_> allz
08:47:13 <andrea__> eikke: i want understand what a functor is, my next step is to tra understanding monads
08:47:23 <eikke> andrea__: read the typeclassopedia!
08:47:30 <eikke> andrea__: that might simplify things a lot
08:47:38 <Hafydd> http://acm.wustl.edu/functional/io-monad.jpg
08:47:38 <Aly_> whats going on....???
08:47:39 <haasn> yeah the typeclassopedia is a good resource
08:47:39 <Chousuke> andrea__: so Maybe is a functor because it takes an Int to Maybe Int, and if you implement fmap for Maybe you can "lift" Int -> Bool to Maybe Int -> Maybe Bool
08:47:44 <Iceland_jack> Someone asks “Explain [Maybe type] like I'm 5” and the top-rated answer starts with “Technically it's a "strictly positive functor" type, but please ignore that...”
08:47:47 <EvanR> andrea__: monoids are fun too
08:47:48 <Iceland_jack> ffs
08:48:03 <elliott> Iceland_jack: yikes
08:48:12 <typoclass> Aly_: hello, this channel is about the programming language haskell
08:48:18 <wonderer111> haasn magneticduck : thanks for your help!
08:48:20 <haasn> Hafydd: needs a follow-up: “Halp I unsafePerformIO'd” showing a cat swimming in a thoroughly flooded apartment
08:48:26 <Hafydd> Hahahah.
08:48:29 <magneticduck> wonderer111: np
08:48:43 <Iceland_jack> and then procedes to explain typed containers “using newtype Identity a = Identity { runIdentity :: a }”
08:48:47 * Iceland_jack smh
08:48:51 <Chousuke> andrea__: in the same way, [] is a functor because you can take Int to [Int], and its fmap lifts Int -> Bool to be [Int] -> [Bool]
08:49:21 <Chousuke> the behaviour for different functors is obviously different, but the principle is the same
08:49:27 <magneticduck> Aly_: lol, this is what's called an action channel
08:49:32 <magneticduck> *active
08:49:51 <andrea__> i read many tutorials, and i own a book obout haskel
08:49:53 <magicman> Chan (IO ())
08:49:59 <magicman> Action channel >_>
08:50:01 <typoclass> haasn: awww :-) excellent idea
08:50:05 <haasn> > fmap (*10) (+3) 5
08:50:07 <lambdabot>   80
08:50:14 <eikke> andrea__: for things like functor, monoid, applicative, monad,... the typeclassopedia is a must-read
08:50:29 <eikke> haasn: that's just confusing :P
08:50:31 <magneticduck> magicman: ACTIVCHANNEL
08:50:39 <andrea__> eikke what's url ?
08:50:41 <magneticduck> the channel you go to to loose weight
08:50:43 <Chousuke> andrea__: if you want, you can think of type constructors of one parameter like Maybe as functions from type -> type
08:50:48 <haasn> fmap :: (a -> b) -> (c -> a) -> (c -> b) -- in this context ;)
08:50:54 <eikke> @where typeclassopedia
08:50:55 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
08:50:57 <EvanR> Chan (IO ()) looks ominous as shit
08:50:59 <Hafydd> Loose weight? That sounds like something you'd do on a ship.
08:50:59 <eikke> andrea__: ^^
08:51:08 <andrea__> thx
08:51:19 <Chousuke> andrea__: so Maybe the function applied to a type Int gives you a new type Maybe Int
08:51:28 <Hafydd> Or a hot-air baloon, more likely.
08:51:56 <Chousuke> andrea__: it gets pretty weird since you can then apply that function again and get Maybe Maybe Int :P
08:52:00 <magneticduck> Hafydd: or perhaps an airplane
08:52:04 <alexrvov> Don't you think guys, that C# is the best language?
08:52:05 <elliott> Chousuke: Maybe (Maybe Int)
08:52:05 <magneticduck> Hafydd: how did this start
08:52:07 <elliott> big difference
08:52:12 <Chousuke> elliott: oh, right.
08:52:12 <EvanR> alexrvov: yes
08:52:18 <elliott> alexrvov: nope. that was easy, next question?
08:52:25 <andrea__> a different question: what makes more fun, haskell or ( python c++, java etc) ?
08:52:25 <haasn> alexrvov: I tend to prefer English in day-to-day usage
08:52:26 <Hafydd> magneticduck: Aly_ started it, I believe.
08:52:41 <EvanR> haskell is more fun
08:52:49 <magneticduck> Hafydd: let's slap him around, he started this mess
08:52:50 <haasn> andrea__: Haskell is lots of fun :)
08:52:53 <haasn> moreso once you get to lens
08:53:10 <EvanR> dwarf fortress fun
08:53:17 <haasn> andrea__: though I can't comment on python or C++. Java, in my experience, is not very fun :(
08:53:43 * eikke got a Fortress tshirt somewhere from a tutorial at JavaOne
08:53:50 * magneticduck has not learned how to use lenses because MagneticDuck is a lazy duck
08:53:56 <magneticduck> :<
08:54:17 <haasn> @faq Can lenses help magneticduck learn how to use lenses?
08:54:17 <lambdabot> The answer is: Yes! Haskell can do that.
08:54:22 <magneticduck> yay
08:54:29 <magneticduck> I like incursive teaching
08:54:30 <edwardk> eikke: nice
08:54:34 <haasn> edwardk: we need a revised version of @faq that answers “Yes! Lenses can do that.”
08:54:37 <Chousuke> andrea__: basically, people who use and research Haskell and PLs try to find structure and patterns everywhere and then codify that as typeclasses or even more advanced abstractions
08:54:44 <magneticduck> as long as you understand the french revolution, you'll understand the french revolution
08:55:18 * magneticduck has not learned about the french revolution either
08:55:19 <haasn> as long as you understand the french revolution, germany borders china
08:55:27 <eikke> edwardk: it was :) tshirts were for the first 5 who completed the exercises or something, so I was pretty proud ;-)
08:55:33 <magneticduck> reductio ao absurdium
08:55:39 <magneticduck> that should be a teaching approach
08:55:53 <Chousuke> andrea__: and since it's all founded on Category theory they have a lot of maths research to lean on and see if it applies to practical programming
08:55:59 <andrea__> make it sense to program a interactive game , by example a puzzle simulator in haskell
08:56:24 <andrea__> i programmed a simulator in java , for rubiks cube like puzzles
08:56:44 <haasn> I don't think Haskell being founded on ‘Category Theory’, if anything, is relevant to actually using it
08:56:58 * magneticduck is perhaps more accurately not ignorant of the french revolution, but merely in the dark as to how it actually..worked?
08:57:20 <magneticduck> haasn: something else I'd reccomend is a briefing in lambda calculus..?
08:57:23 <magneticduck> I thought it was cool.
08:57:34 <haasn> as far as I'm aware, the closest you really get to CT in Haskell's theory is being able to succinctly express the type inferencing algorithms using CT
08:57:45 <haasn> or something like that
08:57:53 <magneticduck> although it's a whole world from church datatype encodings to typed lambda calculuses
08:57:54 <magneticduck> :l
08:58:02 <magneticduck> calclui*
08:59:06 <haasn> yeah I think untyped LC is a bit alien from Haskell
08:59:37 <magneticduck> recursion is a whole different mechanism too
08:59:40 <magneticduck> ..mostly
08:59:47 <magneticduck> there's no definition in church LC
08:59:50 <Chousuke> haasn: I mean, because haskell has CT foundations, people get to look at stuff already discovered in CT and see if they can do something useful with it in actual programs
09:00:13 <haasn> Chousuke: you can do that in many languages, eg. C#
09:00:21 <magneticduck> or, technically you could "define" something using (\x.xx)
09:00:33 <magneticduck> *theoretically
09:00:45 <Chousuke> haasn: It's easier in Haskell
09:00:48 <haasn> perhaps
09:01:18 <elliott> haskell has relations to CT but i think "foundations" may be overstating it a little
09:01:19 <haasn> (\x.Y)(z) -- let x = z in Y
09:01:36 * magneticduck is not an authority on church lambda calculus, the realitive meanings of "theoretically" vs "technically", or the functioning of the french revolution
09:01:41 <magneticduck> so much to learn :<
09:02:21 <magneticduck> haasn: but you can't say for instance "let x y = x y in x y"
09:02:31 <magneticduck> because x loses its binding in the first transformation
09:02:33 <magneticduck> right?
09:02:54 <magneticduck> ..........
09:03:02 <haasn> (\x.x y)(Y id)
09:03:12 * magneticduck shuts his mouth to make sure no more stupid gets out
09:03:34 <haasn> this goes on x y = x y -> x = fix (\x y -> x y)
09:03:49 <magneticduck> mm
09:04:22 <haasn> though it gets slightly trickier with something like let x = y; y = x in ...
09:04:33 <magneticduck> yeah
09:05:26 <Chousuke> elliott: I guess if you go too deep here you'll just end up with a variation fo the "all programming languages are equivalent" argument
09:05:34 <magneticduck> well ima go and intersect some circles
09:06:12 <magneticduck> and then forget about the algorithm I used
09:06:14 <haasn> the transformation is let (x, y) = fix (\(x, y) -> (y, x)) in ...
09:06:16 <haasn> which means you need church-pairs :D
09:06:16 <Hafydd> magneticduck: TMI.
09:06:18 <haasn> (got disconnected there, sorry if I duplicated a message)
09:07:01 <applicativer> > let multiples_of n = [n,n*2..] in take 5 $ multiples_of 5
09:07:02 <lambdabot>   [5,10,15,20,25]
09:07:23 <applicativer> I had forgotten this was possible. I will now forget it again.
09:07:46 <haasn> > let multiplesOf = zipWith (*) [1..] in take 5 (multiplesOf 5)
09:07:47 <lambdabot>   No instance for (GHC.Num.Num [a0])
09:07:47 <lambdabot>    arising from a use of `e_1155'
09:07:47 <lambdabot>  Possi...
09:07:54 <haasn> oh
09:07:59 <haasn> > let multiplesOf = zipWith (*) [1..] . repeat in take 5 (multiplesOf 5)
09:08:01 <lambdabot>   [5,10,15,20,25]
09:08:10 <haasn> not quite as clean as I'd hoped :(
09:08:34 <haasn> oh
09:08:42 <andrea__>     infixr 5 :-:      data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)
09:08:45 <haasn> > let multiplesOf n = map (*n) [1..] in take 5 (multiplesOf 5)
09:08:46 <lambdabot>   [5,10,15,20,25]
09:08:48 <applicativer> iterate (+n)
09:08:52 <andrea__> what does :-: mean ?
09:09:07 <haasn> andrea__: it's simply a definition here, a name
09:09:10 <Chousuke> andrea__: it's an infix constructor
09:09:19 <prophile> > [n*5 | n <- Just 2]
09:09:20 <haasn> andrea__: you could think of it as: data List a = Empty | Cons a (List a)
09:09:21 <lambdabot>   Couldn't match expected type `[t0]'
09:09:21 <lambdabot>              with actual type `Data.May...
09:09:21 <raid> andrea__: its often used for defining some custom operator
09:09:24 <haasn> but here Cons is named :-:
09:09:27 <prophile> :<
09:09:50 <haasn> prophile: needs MonadComprehensions, unfortunately :(
09:09:55 <prophile> haasn: yeah :<
09:10:08 <applicativer> you have to put : in front of an infix constructor, or used to.
09:10:18 <haasn> applicativer: still do
09:10:26 <Hafydd> @pl \n -> map (*n) [1..]
09:10:26 <lambdabot> flip map [1..] . (*)
09:10:30 <applicativer> whats wrong with MonadComprehensions
09:10:46 <prophile> lambdabot doesn't have them
09:10:57 <applicativer> oh, something wrong with lambdabot!
09:11:03 <haasn> shame on Cale
09:11:04 <andrea__> haasn: the previous line was :     data List a = Empty | Cons { listHead :: a, listTail :: List a} deriving (Show, Read, Eq, Ord)
09:11:37 <andrea__> the line with Cons i understand, the line with :-: i don't understand
09:11:45 <applicativer> that will give the ugliest imaginable representation of [1.. 10]
09:11:50 <haasn> hey, that makes me wonder; and I'm pretty sure I ought to know this, does record syntax work with operator constructors?
09:11:59 <applicativer> andrea__: it's the same as Cons
09:12:00 <elliott> yes
09:12:11 <andrea__> ok
09:12:18 <applicativer> andrea__: its like the difference between add 2 3 and 2 + 3
09:12:30 <Chousuke> andrea__: do you understand infix operator definitions? eg x <¤%¤#> y = ...
09:12:31 <haasn> andrea__: think of it as the difference between “plus x y = ...” and “x + y = ...”
09:12:46 * hackagebot adp-multi-monadiccp 0.2.0 - Subword construction in adp-multi using monadiccp  http://hackage.haskell.org/package/adp-multi-monadiccp-0.2.0 (MaikRiechert)
09:12:53 <Chousuke> andrea__: it's the same thing, except for data constructors
09:13:08 <haasn> “Cons 3 Empty” <=> “3 :-: Empty”
09:13:28 <haasn> the usual tricks apply: “3 `Cons` Empty”, “(:-:) 3 Empty”
09:13:48 <magneticduck> I'm doing what humans do best; checking geometry routines via GHCi
09:13:54 <andrea__> i though infix operator are with backtiks `div` by example
09:14:06 <applicativer> > let cons x xs = x : xs in (cons 1 [2,3], 1:[2,3])
09:14:07 <lambdabot>   ([1,2,3],[1,2,3])
09:14:14 <haasn> if you're asking why :-: in particular, it's just an arbitrary name - the only restriction is that it must start with a : for constructor, so you could have done :+ or :!!! or whatever
09:14:34 <andrea__> ok
09:14:37 <haasn> andrea__: that's when using a non-operator (eg. div) infix
09:14:39 <applicativer> andrea__: you wouldn't believe some of the infix constructors some of these people come up with ....
09:14:48 <haasn> andrea__: when using an operator (eg. +) infix, you don't need the backticks
09:15:24 <haasn> my favorite infix constructor is :> and my least favorit is :<
09:15:31 <magneticduck> :<
09:15:38 <magneticduck> *searches on hackage*
09:16:01 <Chousuke> I suppose you can't have :( and :) as infix constructors?
09:16:05 <haasn> no
09:16:07 <haasn> ( and ) are reserved
09:16:10 <Chousuke> though :O or :| and :D would probably work
09:16:19 <magneticduck> >:D
09:16:22 <haasn> :O and :D do not work
09:16:24 <prophile> i'd imagine :O and :D wouldn't work
09:16:26 <haasn> because O and D are not operator characters
09:16:27 <monochrom> no, can't mix symbols with letters
09:16:28 <applicativer> haasn: it came back to me, it's type constructors that don't need : anymore ... I think
09:16:37 <haasn> applicativer: yes
09:16:40 <Chousuke> ah, I see. damn
09:16:46 <magneticduck> that's no fun
09:16:51 <applicativer> you can do data x + y = Nil
09:16:54 <magneticduck> >:| still works
09:17:04 <prophile> if you have a nullary constructor D you could legitimately have :======D in your code though
09:17:05 <haasn> applicativer: with the new TypeOperators, every operator on the type level is parsed as a concrete type, not a variable
09:17:20 <magneticduck> prophile: that's not what we were thinking of
09:17:27 <magneticduck> xD
09:17:29 <haasn> magneticduck: but >:| is not a constructor, note
09:17:36 <applicativer> haasn: yes, thats an obnoxious feature
09:17:42 <magneticduck> yes
09:18:11 <magneticduck> it could be an error value
09:18:17 <magneticduck> if x < 0 then >:|
09:18:35 <magneticduck> where >:| = error ..
09:18:41 <magneticduck> that would be cool
09:18:42 <haasn> magneticduck: syntax error, needs (>:|)
09:18:45 <haasn> or two parameters
09:18:56 <magneticduck> in that case
09:19:07 <magneticduck> oh, I have a great idea
09:19:19 <magneticduck> if you don't use : as cons
09:19:26 <magneticduck> darn
09:19:29 <magneticduck> actually, that wouldn't work
09:19:32 <magneticduck> ..
09:19:32 <EvanR> (:[])
09:19:39 <haasn> can't (:) be redefined with Re..somethingSyntax?
09:19:41 <magneticduck> I use that all the time
09:19:43 <magneticduck> xD
09:19:44 <applicativer> data X a = D | a :======= X a
09:19:47 <haasn> RebindableSyntax
09:20:00 <applicativer> the (:[]) becomes (:=========D) not bad
09:20:08 <haasn> that's one = too many
09:20:09 <magneticduck> x|
09:20:15 <applicativer> ha
09:20:19 <applicativer> the (:[]) becomes (:========D) not bad
09:20:20 <haasn> two, actually :D
09:20:26 <applicativer> the (:[]) becomes (:=======D) not bad
09:20:27 <magneticduck> and it's still pretty small for what it is
09:20:29 <magneticduck> :D
09:20:30 <haasn> there we go
09:20:38 <magneticduck> xD
09:21:06 * magneticduck notices that I'm using up all the space
09:21:12 <haasn> instance Monad X where return = (:=======D); ...
09:21:36 * magneticduck notices that *he* didn't use /me grammer correctly
09:21:36 <monochrom> why are you people so obsessed with genitals
09:21:40 <magneticduck> ikr
09:21:45 <magneticduck> it's terrible
09:21:50 <magneticduck> I can only hope that we're all male
09:21:55 <applicativer> ha, monochrom is that the emoticon for this?
09:22:05 <haasn> magneticduck: oh don't get us started on (.).(.)
09:22:09 <magneticduck> lol
09:22:15 <magneticduck> -_-
09:22:24 <elliott> perhaps this is -blah material
09:22:25 * applicativer regrets helping with the new list constructors
09:22:32 <Chousuke> :P
09:22:40 <haasn> this is all in the interest of helping andrea__ understand infix operators
09:22:45 <magneticduck> I'm suprised I only got disciplined a few times about my channel space usage
09:22:59 <magneticduck> I'm still trying to get over my addiction of using the enter key as punctuation
09:23:12 <magneticduck> sry guys
09:23:15 <magneticduck> :<
09:23:22 <Chousuke> this thread of discussion is not stable and won't converge
09:23:30 <magneticduck> nope
09:23:41 <andrea__> thanks hassn and other, but my brain is bamboozled
09:23:46 * magneticduck shuts up until the channel space usage gets back to colors other than white on my client
09:23:55 <haasn> just remember: “infix operators are like phalli. or something”
09:23:59 <Chousuke> better terminate it before things get bad
09:24:31 * applicativer studies up on emoticons :###.. 
09:24:48 <Chousuke> andrea__: it's just another syntax thing.
09:25:22 <Chousuke> andrea__: haskell treats non-alphanumeric constructors that start with : as infix
09:25:33 <Chousuke> that's all
09:25:39 <andrea__> how many jears do you programm in haskell?
09:25:53 <andrea__> years
09:25:54 <applicativer> the only one in the Prelude is lists :
09:26:42 * applicativer felt that he had always known haskell, even before he first tried to use it
09:27:08 <Chousuke> I first tried learning haskell some years ago
09:27:13 <eikke> andrea__: IIRC I started learning Haskell (after Scala) about 3 years ago, but I think it took at least 2 years until I felt really comfortable, and now I still come across new things to discover/learn
09:27:33 <Chousuke> didn't get far, took a tour through Python and Clojure and then back to Haskell.
09:27:44 <haasn> my earliest #haskell logs are dated 2011-06-01
09:27:55 <haasn> so since then, give or take a month
09:28:20 <haasn> though I took a break of a few months sometime between 2011 and 2012
09:28:24 <eikke> oh, I had some haskell at uni as well (using hugs), but couldnt see any use back then (mainly since it wasnt an engineering course, but about logics & lambda calculus only)
09:28:55 <haasn> yeah, when I first started I thought Haskell was cool but lacked any actual real-world uses to apply it to
09:29:08 <Chousuke> Clojure is a really good language to start functional programming with IMO
09:29:14 <haasn> one day I just decided to switch all of my day-to-day programming over to Haskell, for some reason, and I've been using it ever since
09:29:23 <prophile> I started learning haskell in 1832, being sure it would be the next big thing after this newfangled electricity
09:29:27 <Chousuke> you get to do stuff and the runtime won't complain if your code is dirty
09:30:02 <andrea__> i began learning haskell ca 6 days ago, *rofl*
09:30:03 <Chousuke> but once you get enough exceptions bang your head against the wall because imperative code is such a pain, you'll start to appreciate the functional aspects of it
09:30:09 <Chousuke> +and
09:30:12 <eikke> prophile: that's about when my country was founded :p
09:30:32 <applicative_> good work andrea__ !
09:31:55 <applicative_> the other case of infix constructors in the standard libraries are :< and :> in Data.Sequence.
09:32:11 <applicative_> I can't think of others so central
09:33:44 <haasn> come to think of it, why exactly does it have to be illegal to rebind (:)?
09:34:00 <_just> @type (:>)
09:34:02 <lambdabot>     Not in scope: data constructor `:>'
09:34:02 <lambdabot>     Perhaps you meant one of these:
09:34:02 <lambdabot>       `Seq.:>' (imported from Data.Sequence),
09:34:19 <_just> @type (Seq.:>)
09:34:21 <lambdabot> Seq.Seq a -> a -> Seq.ViewR a
09:34:35 <hpc> haasn: you can't rebind anything in haskell
09:34:42 <applicative_> @type (Seq.:<)
09:34:45 <lambdabot> a -> Seq.Seq a -> Seq.ViewL a
09:34:55 <andrea__> cu & bye guys
09:35:03 <applicative_> be good, andrea__
09:35:13 <eikke> good luck andrea__
09:35:13 <haasn> hpc: yes but I mean, wouldn't it work just fine if you could rebind (:) like any normal operator?
09:35:21 <andrea__> thx
09:35:26 <haasn> import Prelude hiding ((:))
09:36:08 <edwardk> haasn: it gets too much special consideration w.r.t. syntax desugaring, etc.
09:36:18 <edwardk> haasn: same with []
09:36:19 <haasn> edwardk: but you can rebind (>>=) without ‘do’-desugaring being affected
09:36:27 <arrivaloftime> If a mutex is locked, are all other threads blocked then? Or does it work like a binary semaphore where code trying to move past the semaphore/mutex inq uestion is blocked?
09:36:35 <haasn> so I don't see why rebinding (:) would make []-desugaring any difficult
09:36:37 <applicative_> import Prelude hiding (([])(..)) ?
09:36:55 <haasn> applicative_: oh, right, yeah, that might get a bit tricky
09:37:29 <haasn> I keep forgetting that you have to mention the type name to hide constructors
09:37:39 <haasn> which I'm not convinced is a good thing either
09:37:44 <edwardk> haasn: list comprehensions, etc.
09:38:04 <haasn> list comprehensions don't even desugar to anything involving (:) do they?
09:38:22 <haasn> and even if they would, the same argument applies as for (>>=) and do-blocks
09:38:34 <haasn> the way the desugaring is done in GHC, it's fixed to GHC's version of (>>=), and not whatever is in scope
09:39:01 <elliott> report says so
09:39:05 <elliott> not just ghc
09:40:41 <haasn> report for [] just mentions “... where : and [] are constructors for lists, as defined in the Prelude” <- the same way it's defined for ‘do’-desugaring
09:41:18 <haasn> so even if you redefine it locally, based on the definition it would still work using the actual list constructor when desugaring
10:02:46 <nooodl_> imagine if you could write (:) = (+), and then [1,2,3,4] == 10
10:03:11 * Eelis imagines it
10:03:13 <Eelis> wow, scary!
10:03:17 * Eelis stops imagining it
10:05:21 <dwcook> > foldr (+) 0 [1,2,3,4]
10:05:24 <lambdabot>   10
10:06:27 <dwcook> nooodl_ basically just described foldr
10:06:32 <prophile> nooodl_: you need to define [] as 0 for that
10:07:20 <eyebloom> I'm curious if anyone knows of a way of unifying the definition of ext(n) in this example code:
10:07:51 <eyebloom> http://hpaste.org/88170
10:09:31 <eyebloom> And possibly making things generic such that the arity of the first parameter can be generic.
10:15:29 <magicman> eyebloom: Arbitrary arity is kinda tricky to pull off, but those are pure, fmap, liftA2, and liftA3 for (State g).
10:16:05 <magicman> Wait, no. Not really.
10:16:26 <eyebloom> Hmmm...
10:16:26 <magicman> It does look like something applicative. Hrm.
10:17:39 <simukis_> ??? :: (a -> Maybe b) -> a -> [b] -- Stops at first Nothing
10:18:45 <supki> :t unfoldr
10:18:48 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
10:19:20 <simukis_> awesome.
10:21:26 <magicman> eyebloom: Actually, yes. That's the Applicative instance for State. I was confused by the shadowing of g.
10:22:27 <eyebloom> But with the state it's still boilerplate.
10:22:41 <eyebloom> *state monad
10:22:47 <jmcarthur> you could define a new combinator that just does the same thing without the wrapping
10:23:05 <jmcarthur> the same things as (<$>) and (<*>) that is
10:23:15 <jmcarthur> so two new combinators
10:24:02 <eyebloom> I think the issue is that we'd like to select ext(n) based on the arity of the first parameter.
10:24:09 <jmcarthur> that's tougher
10:24:16 <magicman> I have seen an actual implementation of "Idiom brackets".
10:24:20 <jmcarthur> and i think fragile
10:24:48 <jmcarthur> how is it to know what arity you intend? what if you want to result to be a function?
10:25:02 <magicman> Where you'd write "iI f a b c d Ii", which corresponds to "f <$> a <*> b <*> c <*> d". But yeah, fragile.
10:25:32 <arkeet> eyebloom: pure.pure, fmap.fmap, liftA2.liftA2, liftA3.liftA3
10:25:34 <haasn> magicman: she has them
10:25:48 <arkeet> assuming P g is applicative
10:26:08 <arkeet> maybe
10:26:26 <haasn> she desugars (| f a1 a2 a3 a4 |) to f <$> a1 <*> a2 <*> a3 <*> a4
10:26:28 <arkeet> nope.
10:26:31 <jmcarthur> P g is not unless g is a monoid, but g ~> P g is because it looks like the state monad
10:26:31 <arkeet> never mind.
10:26:39 <arkeet> yeah.
10:26:51 <jmcarthur> fortunately, the latter is what we're actually dealing with
10:28:43 <eyebloom> Thanks I'll research idiom brackets
10:30:55 <magicman> It's not pretty. Generally anything with a variable amount of arguments does not make for pretty Haskell code.
10:31:03 <magicman> printf pulls it off, but brrr.
10:31:08 <arrivaloftime> Can someone give an example of synchronization which isn't mutual exclusion?
10:32:12 <roconnor> arrivaloftime, a blocking read to some MVar
10:32:55 * arnsholt goes to look at the implementation of printf
10:36:14 <roconnor> @hoogle :->
10:36:14 <lambdabot> Test.QuickCheck.Function data (:->) a c
10:36:22 <arrivaloftime> roconnor: a non haskell example?
10:37:22 <roconnor> arrivaloftime, lowering a semaphore that isn't raised yet.
10:41:07 <arrivaloftime> a binary semaphore can be used for everything a mutex can and more but the mutex provide some extra safety sinc eonly the lokcing thread cna unlock?
10:41:13 <arrivaloftime> that is all the difference?
10:41:41 <monochrom> is that even true? only the locker can unlock?
10:41:58 <monochrom> oh, I guess so
10:42:09 <roconnor> arrivaloftime, that seems like a odd charactarization
10:42:22 <roconnor> arrivaloftime, a mutex is associated with a critical section
10:43:01 <roconnor> arrivaloftime, but a semaphore is just a value
10:43:08 <roconnor> and isn't associated with any sort of code
10:43:42 <roconnor> I mean, you can use a semaphore to implement a mutex. ... and I guess you can implement a semaphore using a mutex.
10:43:56 <roconnor> hmm, not sure about that last bit
10:45:23 * roconnor isn't sure why arrivaloftime is looking for a non haskell example on #haskell
10:48:32 <typoclass> arrivaloftime: do you have a specific problem that you want to solve with haskell code, and are wondering if semaphores or mutexes are more appropriate? or are you just trying to learn the approaches in general?
10:48:36 <arrivaloftime> # because arrivaloftime is trying to understand the principle, not trying to apply it #
10:55:19 <tij> i have a rather beginner ish question (sorry!)
10:55:36 <tij> when I run getArgs in main, it does not wait for user input
10:55:40 <tgeeky> tij: don't ask to ask, and don't apologize. we are all noobs at 99% of things in life
10:56:06 <Hafydd> tij: what user input do you expect getArgs to wait for?
10:56:21 <typoclass> tij: hello :-) getArgs gives you the arguments from the command line. i.e. when you started your program as "myprogram --something -f -x 123"
10:56:41 <tij> OH
10:56:44 <typoclass> tij: getArgs has nothing to do with user input directly
10:56:44 <tij> that makes sense
10:56:58 <typoclass> tij: possibly you're looking for getLine or somesuch
10:57:01 <Shou> tij, you want `getLine' for input after the program has been run
10:57:10 <Shou> well, while it's running
10:57:39 <tij> that makes sense
10:57:42 <tij> thanks so much everyone
11:00:12 <typoclass> tij: you're welcome. please have your virgin goat ready. sacrifice day is coming up
11:00:50 <supki> mm_freak: if I want bigger delay between instants, should I just use threadDelay in stepSession loop or there is another way to do it?
11:17:48 * hackagebot haxr 3000.9.3 - XML-RPC client and server library.  http://hackage.haskell.org/package/haxr-3000.9.3 (BrentYorgey)
11:17:50 * hackagebot mcmc-synthesis 0.1.2.1 - MCMC applied to probabilistic program synthesis  http://hackage.haskell.org/package/mcmc-synthesis-0.1.2.1 (TikhonJelvis)
11:18:19 <hiptobecubic> For an 8 bit signed integer using 2's complement, why is the range -128-127? If the msb is the sign bit, how can it represent 128?
11:18:34 <Fuuzetsu> it can't
11:18:46 <Fuuzetsu> you get 256 values, one of them being 0
11:19:08 <typoclass> hiptobecubic: well it has 255 values. 128 negative values, 0, and 127 positive ones
11:19:14 <typoclass> *256 dammit
11:20:31 <Saizan> > minBound :: Int8
11:20:35 <lambdabot>   -128
11:20:36 <geekosaur> hiptobecubic, in 1s comp, if only the sign bit is set then you get negative zero. 2s comp defines that to be the next available negative number instead, hence -128
11:21:28 <geekosaur> floating point has negative zero too and the resulting ickiness is one reason to avoid floating point...
11:21:32 <monochrom> use fewer bits to see. 10, 11, 00, 01.  that's -2, -1, 0, 1
11:21:35 <hiptobecubic> sorry i mean -128
11:22:04 <hiptobecubic> hm
11:22:50 <hiptobecubic> Well how I've learned it, (using c syntax) is a negative value (-x) is represented as (~x + 1)
11:22:53 <hiptobecubic> correct?
11:23:11 <skuggi> yes
11:23:13 <hiptobecubic> and this operation can be applied again to get the original back
11:23:25 <skuggi> yes
11:23:55 <monochrom> clearly, no. there is -2 but not 2. unless you accept -2 = 2, which is fine by me.
11:24:11 <hiptobecubic> So if we have a 2-bit, signed number  1 0, it ends up as 01+1 = 10 to negate it.
11:24:32 <dwcook> > (0 :: Float) == -1
11:24:33 <dwcook> > (0 :: Float) == -0
11:24:35 <lambdabot>   False
11:24:36 <lambdabot>   can't find file: L.hs
11:24:36 <skuggi> well, obviously it won't work with the largest negative number
11:24:48 <hiptobecubic> Well that's what i'm asking about
11:24:50 <typoclass> hiptobecubic: well you can negate most values. negating -128 won't work, 128 cannot be represented
11:25:01 <dwcook> lambdabot what
11:25:02 <dwcook> > (0 :: Float) == -0
11:25:05 <lambdabot>   True
11:25:48 <hiptobecubic> well if the number is all zeros and then the sign bit
11:26:08 <hiptobecubic> For positive numbers we're stuck at 011, for 3bit numbers
11:26:29 <hiptobecubic> for negative numbers, it would be 100
11:27:34 <hiptobecubic> which, after twos complement negation, gives itself again
11:28:17 <hiptobecubic> but then we get the actual value of "100" in binary, as a negative
11:28:48 <hiptobecubic> So it seems as if it first checks the sign bit to see if the result will be negative or not, then does two's complement if necessary and takes whatever it gets
11:29:01 <geekosaur> hm?
11:29:20 <skuggi> hiptobecubic: what's the "it" in that sentence?
11:30:36 <typoclass> hiptobecubic: i lost track, sorry. what's the question?
11:31:51 <geekosaur> hiptobecubic, you may be missing implicit modulus. on a signed 2s-complement 8-bit value, every calculation is implicitly mod 128
11:33:19 <arrivaloftime> isnt mutual exclusion==a form of synchronization? so isnt it a bit wrong to say mutexes for mutual exclusion and smeaphores for synchronization?
11:33:45 <hiptobecubic> skuggi, the processor?
11:34:14 <monochrom> I don't know about "==". I would just say "is".
11:34:15 <hiptobecubic> aren't semaphores usually implemented via mutexes anyway?
11:34:16 <typoclass> arrivaloftime: not sure where you read that. i'd definitely say semaphores and mutexes are variants of the same thing
11:34:56 <hiptobecubic> typoclass, -128 - 127.  Why that and not -127 - 127 or -127 - 128 ?
11:35:03 <monochrom> synchronization is a form of communication. therefore, I say that mutual exclusion, synchronization, and messages are all forms of communication.
11:35:05 <roconnor> hiptobecubic, are they?  I usually think of mutexes implemented with locks which are implemented by semaphores
11:35:12 <skuggi> hiptobecubic: when it's doing what?
11:35:45 <geekosaur> hiptobecubic, 2s complement is designed to be implementable via bit operations. -128 .. 127 is what falls out of that
11:35:59 <hiptobecubic> roconnor, i think of semaphores as counters implemented with locks implemented by mutexes. Maybe i'm not remembering them clearly
11:36:16 <geekosaur> it would take more work to declare the extra value invalid or give it a different meaning
11:36:18 <roconnor> hiptobecubic, I suspect we are both right.
11:36:29 <hiptobecubic> roconnor, i hope so. Otherwise my understanding is totally wrong.
11:36:33 <typoclass> hiptobecubic: -127..128 could work, but it'd mean that binary 00000000 isn't decimal 0, it's decimal -1. -127..127 would be a possibility
11:36:57 <hiptobecubic> typoclass, why would it mean that? And why does this sound contradictory to what geekosaur just said?
11:37:09 <skuggi> -127..127 would meean you're throwing away one bit-value
11:37:17 <geekosaur> if it sounds contradictory to you then you failed to understand something
11:37:42 <typoclass> skuggi: true. back when dinosaurs roamed, they would have hated the waste of storage
11:37:54 <skuggi> so what happens if you encounter that value? also, arithmetic would probably have to be complicated
11:38:01 <geekosaur> typoclass said the same thing I did, more or less. (-127..127 is a possibility, just not an optimal one; that's how what typoclass said relates to what I said)
11:38:17 <skuggi> typoclass: also, you have to handle that value specially somehow
11:38:21 <geekosaur> you might want to study 1s comp vs. 2s comp
11:39:11 <geekosaur> hiptobecubic, you are more or less reaching toward 1s complement notation
11:39:20 <skuggi> hiptobecubic: one reason 2's complement is used is that arithmetic operations are the same for unsigned and signed integers.
11:39:25 <monochrom> there is a reason I toss out "use fewer bits to see" and show you 10, 11, 00, 01. with concrete exhaustive enumeration, you see there is no place for 2, as long as you insist "MSB is sign bit". whatever abstract algorithms you impose later, you cannot change this.
11:40:16 <typoclass> hiptobecubic: scroll back :-) monochrom's 2-bit example was excellent. 10, 11, 00, 01 == -2, -1, 0, 1. now if you nudge it over by one place, it'd be -1, 0, 1, 2. this would mean decimal 0 is binary 11, isn't it? and binary 00 is decimal 1. (and initially i was wrong btw, i mixed up left and right. sorry)
11:40:18 <geekosaur> last time I checked (granting this can change) wikipedia's writeup on 1s comp was a reasonable discussion of it
11:41:29 <hiptobecubic> ok reading
11:41:32 <hiptobecubic> thanks
11:41:41 <geekosaur> hiptobecubic, early computers *did* use 1s comp, by the way, because it seemed more natural in the way you're talking about. but it turned out that was only "seemed" so 2s comp won out
11:41:44 <typoclass> hiptobecubic: it just looks a bit odd if with unsigned ints, binary 0 == decimal 0, but when you go to signed ints, binary 0 == decimal 1. that's all i guess. it's weird and confusing and they said, let's avoid that
11:41:50 <monochrom> actually, if you wanted +2, I would re-assign this way: 10, 11, 00, 01 = +2, -1, 0, +1. but you would have to give up "MSB is sign bit". it is now "MSB is sign bit except 10 is positive"
11:42:34 <hiptobecubic> monochrom, right, but as it is I'm saying that we normally don't count the value of the signed bit... unless it's the only bit
11:42:45 <hiptobecubic> then it counts
11:43:14 <monochrom> I don't understand that sentence. I clearly pay attention to the sign bit all the time.
11:44:01 <geekosaur> they mean the sign bit acts like a value bit in one particular case. which is correct if you're viewing 2s comp through 1s comp glasses
11:44:09 * typoclass invents some signed integers that do not have a 0. it'll be -128..-1, then 1..128. it's all nicely symmetric, and who needs zero anyway
11:44:11 <mewalz> How close can I get to dependent typing w/ ghc?
11:44:44 * Hafydd constructs a Maybe instance of typoclass's type, to add zero.
11:44:54 <typoclass> Hafydd: excellent call!
11:45:07 <monochrom> I would include 0 and omit 1. 1 is the only singular number. :)
11:45:08 <typoclass> geekosaur: when does the sign bit act like a value? something about bitshifting? i'm not really familiar with those operations
11:45:21 <typoclass> monochrom: how about -1?
11:45:57 <monochrom> I don't know
11:46:34 <geekosaur> typoclass, maybe you're falling into the same trap hiptobecubic is. the value with only the sign bit set is unusual in that in 1s comp it's negative zero and in 2s comp it's an apparently "out of range" (as seen through 1s comp glasses) value
11:47:02 <typoclass> mewalz: it depends ... we like to think that ghc is in a pretty sweet spot. it's restricted enough that type inference can work very well, but powerful enough that you can express tons of stuff
11:47:54 <monochrom> anyway it's mod-4 arithmetic. you can call it +2, +3, 0, +1. or you can call it -2, -1, 0, +1. or you can call it +2, -1, 0, -3.
11:47:56 <typoclass> geekosaur: the value with only the sign bit set is -128 in the example, isn't it
11:48:12 <geekosaur> so, seen through 1s comp, it looks like the sign bit has suddenly become a value bit (to see this, try working it as 1s comp, then adding an extra bit on)
11:48:20 <geekosaur> typoclass, yes
11:48:40 <hiptobecubic> geekosaur, what you're describing sounds like what i'm thinking, yes
11:49:15 <geekosaur> in 1s comp it looks something like you moved to a 9-bit representation but aren't showing the (set) sign bit
11:50:49 <geekosaur> in any case, that particular value is anomalous in both representations; it's just a more tractable and useful anomaly in 2s comp (an additional negative number) than in 1s comp (negative zero)
11:51:00 <geekosaur> but it's confusing if you're taking the 1s complement view
11:54:51 <typoclass> tangentially, here is an interesting article http://blog.regehr.org/archives/593 . the guy analyzed firefox for weaknesses, and one weakness was negating a number that might be -128
11:55:23 <monochrom> wait, it uses only 8 bits?!
11:55:44 <monochrom> I mean, this is firefox, not netscape, not mosaic, right? :)
11:55:46 <typoclass> monochrom: well no, i was just staying within the example that we've been using earlier
11:56:01 <monochrom> oh ok haha
11:56:27 <typoclass> monochrom: the blog post mentions -2147483648, which is moar difficult to type than -128
11:57:02 <monochrom> would be funny for modern software to have an 8-bit problem instead of a 32-bit problem :)
11:59:26 <typoclass> monochrom: i recall building long-ass tunnels in the old transport tycoon deluxe, just to burn large amounts of money. if i overflowed it i'd be so deep in the negative i'd never get out again
12:00:55 <monochrom> yikes
12:01:22 <monochrom> what a good way to "punish the rich" haha
12:02:06 <dmj> why does [] : [] give [[]], [5] : [5], errors
12:02:15 <dmj> why are empty lists the exception
12:02:47 <typoclass> dmj: hm ... they aren't an exception, i think. (:) just takes one element (left side) and one list (right side)
12:02:59 <typoclass> > 5 : [1,2,3]
12:03:02 <lambdabot>   [5,1,2,3]
12:03:03 <eikke> dmj: you want [] : [] vs. 5 : [5]
12:03:05 <typoclass> > 5 : []
12:03:08 <lambdabot>   [5]
12:03:17 <typoclass> @type (:)
12:03:19 <lambdabot> a -> [a] -> [a]
12:04:51 <dmj> typoclass: but in the case of [] : [], there are no elements on the left. So it works because its adding no elements to the right side?
12:05:11 <eikke> dmj: the 'element on the left' is [],
12:05:11 <typoclass> dmj: no, there is an element :-) it's an empty list
12:05:13 <eikke> empty list
12:05:13 <nimish> dmj: if you look at the type of (:) you can work out why [] : [] = [[]]
12:05:29 <typoclass> > [] : [[17,37], [], [42]]
12:05:33 <lambdabot>   [[],[17,37],[],[42]]
12:05:53 <nimish> :t ([] :)
12:05:59 <lambdabot> [[a]] -> [[a]]
12:06:15 <typoclass> dmj: see above. when you use "[] :" you're talking about a list inside a list. which is perfectly alright, but not compatible with [5]
12:06:28 <monochrom> [5] : [blah] requires [blah] :: [[a]] therefore blah :: [a] therefore blah cannot be 5
12:06:58 <dwcook> instance Num [a] where …
12:07:12 * dwcook giggles gleefully
12:07:24 <dmj> the type of (:) is a -> [a] -> [a], in the case of [] : [], it looks like its trying to do [a] -> [a] -> [[a]], which should conflict...
12:07:40 <monochrom> but perhaps more importantly you should know the precise job of ":". instead of imprecise "understanding" such as "it appends things"
12:07:59 <monochrom> Haskell is a precise language, not an imprecise language
12:08:12 <byorgey> dmj: in  [] : []  the two  []  have different types
12:08:32 <byorgey> dmj: [] has type  [a]  for any a.  a could itself be a list type.
12:08:38 <typoclass> dmj: yes almost correct, the type is a -> [a] -> [a], and if you set 'a' to [a], it'll be [a] -> [[a]] -> [[a]]
12:08:47 <monochrom> > ([] :: [Int]) : ([] :: [[Int]])
12:08:50 <lambdabot>   [[]]
12:08:57 <monochrom> you're looking at something like that
12:08:57 <arrivaloftime> can someone give an example of a problem that can be solved with a binary semaphore and not with a mutex?
12:09:28 <typoclass> dmj: just to reiterate, [5] does not fit into type [[a]], hence the error
12:11:34 <dmj> typoclass, byorgey, my confusion comes from the fact that the left [] and the right [] have two different types. [a] becomes a on the left, and [] becomes [a] on the right. Is this correct?
12:11:50 <Intensity> @where ttfp
12:11:50 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
12:11:51 <schell> has anyone written a tutorial on using openglraw?
12:12:01 <byorgey> dmj: if you meant "[] becomes a on the left", then yes
12:12:39 <dmj> byorgey: yes, ok cool.
12:12:44 <monochrom> I would use different variables. "a" is not the only type variable available to humankind
12:12:59 <monochrom> []:[] forces a=[b]
12:13:09 <dmj> monochrom: Isn't it idiomatic to use 'a' in type signatures tho and x,y,z in functional declarations
12:13:21 <dmj> oh
12:13:25 <typoclass> monochrom: yes please, good point, i shouldn't've written it like that
12:14:15 <monochrom> it isn't idiomatic to re-use the same name for everything
12:14:52 <roconnor> @djinn (A -> A)
12:14:53 <lambdabot> Error: Undefined type A
12:14:58 <roconnor> @djinn (a -> a)
12:14:58 <lambdabot> f a = a
12:15:00 <monochrom> but I guess it is idiomatic in highschool
12:15:45 <monochrom> "f(x) = x+1. g(x) = x^2. compute f(g(x)). so x=g(x)=x^2 lolwut?"
12:15:47 <roconnor> @djinn (a -> b) -> (b -> c) -> (a -> c)
12:15:47 <lambdabot> f a b c = b (a c)
12:16:01 <roconnor> can we get a lambdabot in bayhac?
12:16:08 <monochrom> if only you allowed yourself to say "g(y) = y^2"
12:16:24 <Garyuutensei> Hello, I have a piece of code and want to know if each element of the resulting list is generated lazily or whether the whole list is evaluated instead. How could I check this?
12:16:55 <typoclass> Garyuutensei: a simple way could be putting in an 'undefined'
12:17:06 <typoclass> > head [1,2,undefined,3,4]
12:17:09 <lambdabot>   1
12:17:10 <typoclass> > tail [1,2,undefined,3,4]
12:17:19 <lambdabot>   [2,*Exception: Prelude.undefined
12:17:44 <eikke> huh
12:17:58 <eikke> ah, that's the show failing
12:18:19 <roconnor> @djinn Not (Not (((a -> b) -> a) -> a))
12:18:19 <lambdabot> f a =
12:18:20 <lambdabot>     void (a (\ b -> void (a (\ _ -> b (\ c -> void (a (\ _ -> c)))))))
12:18:34 <Garyuutensei> I will try it out although I don't know if it possible
12:20:06 <monochrom> there is also 1:undefined
12:20:12 <monochrom> > head (1 : undefined)
12:20:18 <lambdabot>   1
12:20:28 <monochrom> lambdabot is slow!
12:20:37 <shanse> he's not webscale
12:20:51 <shanse> or irc scale
12:21:09 <hiptobecubic> > tails [1..]
12:21:11 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
12:21:26 <eikke> > threadDelay 5000000
12:21:28 <lambdabot>   Not in scope: `threadDelay'
12:21:32 <hiptobecubic> ;)
12:23:13 <tuxhat> hey
12:23:19 <hiptobecubic> it's amazing to think anyone thought COBOL was an improvement over lisp and fortran
12:24:05 <tuxhat> i want to have a like a transparent tint on my xmobar i read up on it abit with , alpha = 0 but it doesnt work with my xmobar , do i need like a special xmboar or do i need to do other configs ?
12:25:22 <hiptobecubic> tuxhat, try #xmonad
12:25:40 <tuxhat> ok thanks
12:27:24 <monochrom> hiptobecubic: COBOL is an improvement over cabal. http://www.vex.net/~trebla/haskell/siCp.xhtml
12:27:46 <hiptobecubic> monochrom, well that's not *too* hard
12:27:52 <monochrom> haha
12:28:33 <monochrom> COBOL install COBOL-install
12:29:13 <typoclass> cobol cat? awww
12:29:15 <typoclass> =)
12:29:39 <monochrom> I'm too lazy to edit the picture :)
12:30:57 <typoclass> i'm trying to think of a "cobol cat" joke, but i don't know anything about cobol. except that everyone finds it terrible
12:31:15 <typoclass> is cobol the one where everything is written in caps?
12:32:32 <monochrom> I think this helps: http://me.veekun.com/blog/2012/09/07/heteroglot-number-15-in-cobol/
12:33:09 <monochrom> it is no longer all-caps. but that's superficial anyway.
12:33:42 <monochrom> apparently it is only a bit more predictable than php
12:35:33 <pharaun> "Haha, and people complain that Python has significant whitespace. You assholes. Guess what I’m linking you next time I hear that."
12:36:47 <hpc> trwtf is that everyone agrees that all code should be properly indented, but everyone agrees that improper indentation should not be a compile error
12:37:28 <monochrom> well, he did choose the "fixed" mode.
12:39:43 <pharaun> i find it amusing
12:39:54 <pharaun> this is the same guy as the php is bad post
12:40:17 <pharaun> hpc: i think one of the contributing factor is tabs vs spaces, both being "invisible" whitespace and that leading to issues
12:40:33 <pharaun> with differing interpretation of what a tab = ? (at least in programming languages)
12:40:49 <typoclass> "MOVE 1 TO n-choose-r-result". "PERFORM VARYING i FROM 1 BY 1 UNTIL i > r" did cobol predate c, or vice versa?
12:41:15 <monochrom> I don't know. but they certainly never cross-pollinated
12:42:14 <monochrom> or cross-pollinated the wrong way? I don't know
12:43:04 <typoclass> i was going to suggest that "n-choose-r-result = 1" is a step up from "MOVE 1 TO ...", and that a c-ish for loop with parens and symbols is more readable than the stream of words used by cobol
12:43:50 <Demos> anyone know of any good libraries to compress and decompress files (haskell libraries obviously) I only need to compress to one format but I need to be able to decompress as many formats as possible?
12:44:04 <a-gjp> typoclass: Cobol's from the late 50's I think. What scares me though is that there are still companies who teach it to people on an internship.
12:44:11 <a-gjp> Those poor people are scarred for life.
12:44:44 <Demos> COBOL is a fun time, apperently it is still maintained
12:45:56 <arrivaloftime> http://en.wikipedia.org/wiki/Producer-consumer_problem <- why couldnt mutexes be used ofr that? it doesnt need to use semaphores does it?
12:46:08 <burp> people still write fortran programs…
12:46:24 <pharaun> people still write lisp programs... :)
12:46:29 <hpc> Demos: http://hackage.haskell.org/package/zlib/
12:46:33 <dmj> Demos: Codec.Compression.GZip, should be included int he haskell platform
12:46:44 <burp> actually, collegues of me, and I always have laugh when I hear them talking about common block conflicts :P
12:47:53 <a-gjp> arrivaloftime: Mutexes wouldn't allow parallel reading and writing. With semaphores, you can still add to the end of the queue while the consumer reads the beginning.
12:47:55 <Demos> hps: do those libraries support formats such as zip, 7zip, rar, tar, and so on (those are the big ones)
12:48:08 <hpc> Demos: rar is proprietary
12:48:21 <hpc> not sure about 7zip
12:48:35 <hpc> tar is done by the package "tar"
12:49:08 <Demos> so if I want to extract a tarbal I have to use Codec.Compression.GZip to get my tar then use the tar package to extract the files
12:49:10 <hpc> zip is done by libzip
12:49:33 <hpc> Demos: dunno; whatever zlib does is what that module does
12:49:51 <Demos> my point is that I dont want to have to go through and figure out what sort of file I am extracting, I want the library to look at the file header and figure it out
12:49:59 <naz_> Can anybody tell me what the simplest way is to make a http get request? Is the http package a good start or is it overkill ?
12:50:44 <burp> naz_: I'd use http-conduit
12:50:49 <hpc> @hoogle simpleHTTP
12:50:49 <lambdabot> Network.HTTP.Stream simpleHTTP :: Request_String -> IO (Result Response_String)
12:50:49 <lambdabot> Network.HTTP simpleHTTP :: HStream ty => Request ty -> IO (Result (Response ty))
12:50:49 <lambdabot> Network.HTTP.HandleStream simpleHTTP :: HStream ty => Request ty -> IO (Result (Response ty))
12:50:55 <hpc> Demos: that's the simplest way
12:51:16 <monochrom> which means the http package
12:51:37 <burp> simpleHttp :: MonadIO m => String -> m ByteString
12:51:38 <monochrom> it comes with Haskell Platform. you probably don't have to install anything
12:51:44 <burp> this is from http-conduit :)
12:51:52 <Demos> hpc: the simplest way is just looking at the file and essentially having a big case select :D
12:51:55 <monochrom> oh, that's neat too
12:52:12 <burp> used to be http-enumerator
12:52:15 <Demos> pretty sure the functions in 7z.dll on windows did this for me
12:52:43 <monochrom> Demos, someone has to write that code, and I don't think anyone did
12:52:44 <hpc> Demos: i am not finding anything on hackage to automagically extract things
12:53:33 <hpc> such all-in-one extraction is really only useful in client programs, though
12:53:51 <hpc> an API or dedicated program will generally know exactly what archive it is getting
12:54:08 <typoclass> Demos: how about runProcess "tar xf file.tar.gz"? it might be the easiest route
12:54:59 <monochrom> you forgot "z"
12:55:11 <Demos> typo: thing is that on windows I dont have tar, I may try and bind the library 7z uses to haskell
12:55:23 <hpc> monochrom: newer versions don't need it
12:55:38 <hpc> monochrom: i generally go with "tar xvf" and it magically does everything
12:55:38 <pharaun> i found that by accident one day its really nifty
12:55:44 <burp> and you can use bsdtar, then you don't have to specify the compression type, it will figure it out automatically, and it supports a low more compression types, basically bsdtar is the thing you want
12:55:45 <typoclass> monochrom: i could have sworn it autodetects that nowadays. not really sure
12:56:03 <naz_> will look into them, ty all !
12:56:09 <burp> typoclass: maybe you are on BSD, and meant bsd tar
12:56:19 <Clint> GNU tar autodetects
12:57:04 <typoclass> burp: i'm on linux, but probably they looked at bsd tar and replicated those features
12:57:42 <k0ral_> Hello, at run time, I'd like to read some xdg file paths (as defined in System.Environment.XDG.BaseDir), and use them as default values for several things using the Data.Default class; problem is: I need IO to retrieve them, and I can't define instance (Default IO A) for a particular A as it overlaps with an existing instance Default (IO a) (for any a)
12:58:10 <k0ral_> is it the kind of situation where unsafePerformIO is justified ?
12:59:17 <thetallguy1> k0ral_: Do you really need them at run time?
12:59:38 <hpc> k0ral_: i would just allow the overlapping instance
13:00:42 <k0ral_> thetallguy1: yeah, as those directory paths depend on the platform/OS where the program is run
13:01:12 <typoclass> k0ral_: how about the standard solution of main = do p <- retrieveThePaths; yourFunction p
13:01:12 <supki> I can't understand why second ^C always kills it: http://hpaste.org/88177 Any insights?
13:01:37 <hpc> supki: the second ^C goes to the RTS
13:01:48 <hpc> it's a safeguard to make sure haskell programs are always killable
13:01:50 <burp> supki: I don't think its an exception
13:01:59 <burp> you need posix-something for it
13:02:05 <supki> oh
13:02:14 <hpc> you likely want a signal handler
13:02:21 <burp> System.Posix.Signals & co
13:02:27 <k0ral_> typoclass: I'd like to use the Data.Default class; I used to write what you've just wrote, creating a lot of "defaultX :: IO X" functions
13:03:04 <supki> thanks, I'll look it up
13:03:36 <k0ral_> hpc: should I rest peacefully if I allow these overlapping instances ? I heards terrible things about them, I'm afraid a beast might come out of my computer and eat me
13:03:47 <k0ral_> s/heads/heard
13:04:26 <hpc> overlapping is relatively tame
13:04:29 <roconnor> k0ral_, I think that only gets you to the 3rd level of hell.  Incoherent Instances is much lower
13:05:12 <hpc> k0ral_: if it's for an executable, you can really do whatever you want
13:05:17 <hpc> you are the only consumer of your modules
13:05:36 <mm_freak> supki: yes, just delay the main loop
13:06:07 <k0ral_> well, I'm exposing an API for dynamic reconfiguration using Dyre, so users may write Haskell code using my API
13:07:11 <k0ral_> roconnor: waw, first time I hear about IncoherentInstances, sounds really mean
13:07:34 <roconnor> I actually don't know what it is.  But I'm told it is really bad.
13:09:18 <hpc> roconnor: if something has two or more instances that it can use
13:09:29 <hpc> roconnor: incoherent lets it use any of them, without any kind of predictability
13:11:42 <k0ral_> can't believe there are programs actually using this extension
13:12:25 <monochrom> hpc, typoclass: I see. thanks! just tried and it's exactly what you said.
13:12:57 <monochrom> I am an old-geezer and do not know some modern developments
13:13:16 <pharaun> monochrom: i found out about it by accident one day when i forgot the z/j
13:13:29 <arrivaloftime> A really cant come up with an example of where a binary semaphore can be used and not a mutex, anyone?
13:13:55 <hpc> monochrom: you should see my boss sometime; he predates visual mode in vim
13:14:02 <hpc> constantly does weird things in terminal
13:14:32 <hpc> in fact... i have a list somewhere of his misspellings of ls -la
13:14:49 <hpc> one of them is l- sl
13:15:17 <pharaun> heh
13:15:53 <int-e> k0ral_: I suspect that they all started out using OverlappingInstances alone.
13:16:40 <ocharles> Hey, can anyone help me understand wtf is going on with λ. h <- openFile "/home/ollie/Downloads/change-sets.tar" ReadMode
13:16:43 <ocharles> λ. BS.length <$> BS.hGetSome h 1024
13:16:45 <ocharles> 1024
13:16:47 <ocharles> λ. BS.length <$> BS.hGetSome h 18432
13:16:50 <ocharles> 7072
13:16:52 <ocharles> λ. h <- openFile "/home/ollie/Downloads/change-sets.tar" ReadMode
13:16:55 <ocharles> λ. BS.length <$> BS.hGetSome h (18432 + 1024)
13:16:58 <ocharles> 19456
13:17:03 <ocharles> ARGH
13:17:10 <typoclass> ocharles: please use hpaste.org for code >1 line
13:17:15 <ocharles> sorry, computer fail today
13:17:20 <ocharles> I know
13:17:25 <ocharles> I hit Ctrl-K instead of Ctrl-c in irssi
13:17:35 <ocharles> http://hpaste.org/88180 is what I *meant* to paste
13:17:40 <ocharles> there we go
13:19:09 <typoclass> ocharles: hm. so you haven't written to the file between the first and second openFile?
13:19:20 <ocharles> nope
13:19:30 <monochrom> ocharles: is that lazy bytestring? I want to reproduce
13:19:41 <ocharles> it's Data.ByteString, I forget what that is
13:19:49 <ocharles> let me get the version
13:20:14 <ocharles> bytestring-0.9.2.1
13:21:14 <int-e> ocharles: Actually I don't see anything wrong with that. Surprising, maybe, but not wrong. To demonstrate a wrong result you have to demonstrate that an empty string is returned too early.
13:23:49 <ocharles> it does seem to work with hGet
13:23:53 <typoclass> int-e: i think the problem that he meant is that when he calls read twice, it'll read about 8k total, whereas when he calls read once, it'll give about 19k
13:23:54 <ocharles> it's just hGetSome that is weird
13:24:05 <ocharles> "weird" by my intuition
13:24:32 <ocharles> I guess hGetSome fills up the bytestring and then just does take on that
13:24:57 <int-e> typoclass: I know. I was surprised. It's not even a full 8k, 8096 is not even a nice number in base 2 :)
13:25:42 <typoclass> ocharles: what happens if you do another call to hGetSome after line 5 in the test case?
13:26:15 <ocharles> 'BS.append <$> BS.hGet h 1024 <*> BS.hGet h 18432' matches 'BS.hGet h (18432 + 1024)' which is what I'm expecting
13:26:38 <ocharles> typoclass: hard to say, I'm looking at a binary file
13:26:49 <ocharles> "what happens" is more data is read, but I'm not sure it's continuous
13:27:17 <int-e> ocharles: hGetSome is probably only useful for reading from pipes and sockets.
13:27:26 <typoclass> ocharles: hm i see
13:28:12 <ocharles> right. I'm trying to use pipes-bytestring to parse a large tar file in roughly constant memory, and it only provides a hGetSome wrapper. I guess I'll need to give a pull request for just hGet
13:28:51 <ryantanjunming> Hi, any cs people out there?? I wanna build a tree of nodes and edges to calculate all possible moves for a path-finding algo.. I did that and it works but when i expand the list of possible moves my memory craps out.. Is there a tree building algo out there that limits the number of nodes created and prunes itself??
13:29:02 <arrivaloftime> can someone give an example of an application where two tasks switch back and forth. like task/thread 1 do x then task/thread 2 do y then task1...
13:30:34 <monochrom> ByteString hGetSome calls System.IO.hGetBufSome
13:32:07 <typoclass> ryantanjunming: i don't know details, but the people who write computer programs that play the go board game had problems with insanely growing trees, and made real progress a few years ago when they adopted upper confidence bounds (ucb)
13:32:35 <ocharles> monochrom: you mean System.IO.hGetSome?
13:32:40 <ocharles> oh wait
13:32:41 <ocharles> wrong file
13:33:18 <monochrom> I have no typo there.
13:33:30 <ocharles> I know, my mistake
13:36:25 <ocharles> Woohoo, pipes-tar is finally able to dump out a table of contents :)
13:37:20 <ryantanjunming> typoclass: hmm, are there limitations to implementing that kinda tree?? im using A* to source for the shortest path of a courier delivery route..
13:38:42 <typoclass> ryantanjunming: i have no clue. ucb was just something that came to mind when you asked your question. i don't know details
13:39:05 <ryantanjunming> typoclass: thanks, i'll look into it, hopefully its not too complicated..
13:39:54 <monochrom> System.IO.hGetBufSome re-exports GHC.IO.Handle.Text.hGetBufSome. it's the only who decides "since my current buffer isn't exhausted, I'll just give you that much"
13:40:30 <arrivaloftime> what is a good real name for a tick-tack pattern? two threads executing in a tic-tac manner = two threads executing in a ____ manner?
13:40:44 <plhk> round-robin?
13:40:47 <monochrom> co-routine
13:41:24 <int-e> ping-pong
13:41:36 <arrivaloftime> a more understandable manner co-routine
13:41:46 <roconnor> shachaf taught me prisms!
13:41:55 <edwardk> yay!
13:41:56 <arrivaloftime> does anyone have an example of such an application?
13:42:06 <edwardk> roconnor: what do you think?
13:42:54 <roconnor> I think I know the laws for inject and match (or whatever you name the functions)
13:42:56 <monochrom> tic-tac-toe with number of human players: 0
13:43:21 <roconnor> edwardk, I want to work out how the laws translate to the van Laarhoven representation
13:44:07 <roconnor> edwardk, I don't quite know how I'd use it yet, but I'll keep an eye out for uses.
13:44:45 <edwardk> they are documented in the lens library iirc
13:44:49 <edwardk> > _Left # 4
13:44:51 <lambdabot>   Left 4
13:45:00 <mm_freak> arrivaloftime: many examples if you don't insist on threads as in haskell threads
13:45:01 <edwardk> > Left 4 ^? _Left
13:45:03 <lambdabot>   Just 4
13:45:10 <typoclass> arrivaloftime: the average laptop has tons of processes running in parallel. one process will run for a fraction of a second, then another one, and so on
13:45:26 <edwardk> you match with just the same ^? you can use for any fold.
13:47:26 <mm_freak> arrivaloftime: for example in most stream processing abstractions control is handed back and forth between producer and optionally with a middleman
13:47:54 <mm_freak> between producer and consumer
13:48:12 <ocharles> prisms++
13:48:39 <ocharles> or maybe I mean prisms ~+$@!= 1
13:48:47 <edwardk> =P
13:49:03 <arrivaloftime> mm_freak: ok and such an example cant be solved with a mutex? it has to use a semaphore?
13:49:24 <mm_freak> arrivaloftime: huh?  i think nobody uses semaphores in haskell
13:49:36 <mm_freak> arrivaloftime: also you may be confusing concurrency with parallelism
13:49:40 <ocharles> I think the last time I wanted a semaphore a channel turned out to be a better fit
13:49:46 <ocharles> it was a bit like replacing a boolean with Either
13:52:39 <mm_freak> i guess there is such a thing as "locking blindness" similar to "boolean blindness"
13:53:36 <mm_freak> semaphores, mutexes and other low level abstractions are meaningless in the same sense a boolean value is meaningless
13:54:06 <arrivaloftime> with multiple producers and one consumer would a mutex work then+ or would a binary semaphore have to be used. say several tasks can produce something which the consumer should send to another system. if any task could signal the semaphore it would work but it wouldnt work with a mutex, would it?
13:55:08 <mm_freak> arrivaloftime: are you listening?  look at MVar…  you don't need semaphores or mutexes at all
13:55:46 <typoclass> arrivaloftime: i'm not an expert on that stuff, but the way i remember it, a semaphore is an extension of a mutex. it's pretty straightforward. mutex has the states 0 and 1, semaphore has 0, 1, 2, 3 and so on. i'm not sure what the big confusion is :-)
13:56:26 <mm_freak> maybe this is not a haskell question, but a C or assembly question…
13:56:50 <ocharles> Any pipes users around? I wanted to use pipes-zlib and 'decompressD', but decompressD seems to make me lose any upstream requests.
13:56:58 <arrivaloftime> typoclass: thats a counting semaphore that can have any value. im tryin to understand if there is any use of a binary semaphore where a mutex can be used?
13:57:20 <ocharles> To be more specific, hGetS_ listens for downstream 'Int' requests, and responds with a ByteString, which I want to decompress
13:57:27 <typoclass> arrivaloftime: binary semaphore and mutex sounds identical to me *shrug*
13:57:34 <Nisstyre> typoclass, arrivaloftime: the way I understand it mutexes and semaphores are both part of the broader concept of synchronization
13:57:59 <ocharles> so 'hGetS_ someHandle >-> decompressD defaultWindowBits >-> myThingy' - but 'decompressD' isn't compatible with the upstream request from myThingy
13:58:08 <arrivaloftime> typoclass: a mutex has an owner, bin sem hasnt
13:58:22 <dmj> does anyone have sample code of using DataD in template haskell to dynamically make data declarations? Would yesod have sample code for this?
14:01:02 <dmj> nm I think I got it
14:07:22 <arrivaloftime> anyone know an application with multiple producers and one consumer?
14:07:56 * hackagebot gulcii 0.2.0.1 - graphical untyped lambda calculus interactive interpreter  http://hackage.haskell.org/package/gulcii-0.2.0.1 (ClaudeHeilandAllen)
14:09:40 <hpc> arrivaloftime: RSS reader?
14:11:37 <arrivaloftime> hpc: ty
14:11:56 <arrivaloftime> hpc: but would that be one, multithreaded application?
14:28:15 <Demos> so what does c2hs actually do, if I just wnat to write a haskell funciton that calls a bunch of C functions do I need c2hs
14:28:16 <FreeFull> Is there a list somewhere of which libraries lambdabot has imported?
14:29:26 <geekosaur> Demos, it is one way to interface C libraries with Haskell. (hsc2hs is another; it's lower level with corresponding finer control)
14:30:26 <johnw> and c2hsc and yet another
14:30:45 <johnw> it converts C to hsc files, so you can then use hsc2hs
14:31:13 <geekosaur> and ghc2hsc2hs is a customized c2hs that handles certain gtk-isms better than plain c2hs
14:31:32 <FreeFull> :t (:[]) . fmap head
14:31:33 <lambdabot> Functor f => f [b] -> [f b]
14:31:52 <geekosaur> (but can handle some other things incorrectly, probably by thinking they're gtk-isms when they aren't)
14:32:12 <wagle> @seen nominolo
14:32:12 <lambdabot> Unknown command, try @list
14:32:46 <edwardk> you can also just use ffi if you want to write some glue yourself most likely
14:33:21 <geekosaur> yeh, for simple stuff the ffi is good enough, when you want the others is usually when you are working with struct pointers
14:33:36 <edwardk> i use the more complicated stuff when i want to access constants and macros and what not
14:33:53 <geekosaur> or those, yes
14:34:24 <shurikas> a = [1,2,3,4,5]
14:34:27 <shurikas> somefunction a
14:34:36 <shurikas> [[1,2], [2,3], [3,4], [4,5]]
14:34:38 <Demos> yeah I need struct pointers I think, but I may be able to write a C function that takes a string and goes to call all the stuff I need
14:34:38 <shurikas> how to achieve that?
14:34:45 <Demos> actually that is a fantastic idea
14:34:50 <int-e> FreeFull: http://code.haskell.org/lambdabot/State/L.hs should be a good approximation.
14:35:38 <byorgey> shurikas: \a -> zipWith (\x y -> [x,y]) a (tail a)
14:37:12 <arkeet> zipWith (\x y -> [x,y]) `ap` tail
14:39:45 <int-e> > cake !! 5
14:39:46 <lambdabot>   "Three slash four cups butter or margarine."
14:39:50 <int-e> oh my.
14:42:34 <arkeet> > transpose cake
14:42:39 <lambdabot>   ["OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT","nnhonhnwoiiiiiuianlniniwnnww...
14:43:20 <int-e> ASCIICAT
14:43:50 <geekosaur> toot-toot ascii cat, even
14:44:20 <Nisstyre> > take 20 $ reverse cake
14:44:23 <lambdabot>   ["That will deodorize and preserve putrid tissue.","And it contains proven ...
14:44:35 <Rembane> Oo
14:45:00 <int-e> again, the link, before we spill it all over the channel and dozens of private messages: http://code.haskell.org/lambdabot/State/L.hs
14:45:41 <FreeFull> :t M.map
14:45:43 <arkeet> > cake >>= take 1
14:45:43 <lambdabot> (a -> b) -> M.Map k a -> M.Map k b
14:45:47 <lambdabot>   "OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT"
14:46:00 <FreeFull> :t cake
14:46:02 <lambdabot> [[Char]]
14:49:35 <FreeFull> > cake
14:49:37 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
14:50:57 <FreeFull> Wow
14:51:27 <FreeFull> > fromChuch map
14:51:29 <lambdabot>   Not in scope: `fromChuch'
14:51:47 <tromp> add an 'r'
14:52:48 <FreeFull> > fromChurch map
14:52:50 <lambdabot>   Not in scope: `fromChurch'
14:52:50 <lambdabot>  Perhaps you meant `BSLC.fromChunks' (imported f...
14:53:01 <FreeFull> tromp: Well, it's fromChuch in the L.hs
14:53:29 <tromp> what is a chuch?
14:53:44 <Fuuzetsu> a typo presumably
14:53:44 <int-e> (Of course the bot owner can modify the L.hs file. That's why I called it an approximation.)
14:53:52 <int-e> tromp: it has toChurch and fromChuch
14:55:09 <FreeFull> I'm assuming church numerals
14:55:33 <Fuuzetsu> > concat cake
14:55:33 <FreeFull> :t flip
14:55:35 <lambdabot> (a -> b -> c) -> b -> a -> c
14:55:35 <lambdabot>   "One 18.25 ounce package chocolate cake mix.One can prepared coconut pecan ...
14:56:11 <Fuuzetsu> > reverse cake
14:56:14 <lambdabot>   ["That will deodorize and preserve putrid tissue.","And it contains proven ...
14:56:17 <doomlord> its a shame a tuple element extractor can't work on tuples with any number of elements ... eg getY working for x,y , x,y,z,  x,y,z,w ...
14:56:37 <FreeFull> doomlord: Maybe you're looking for lensees
14:56:39 <FreeFull> lenses*
14:56:48 <Fuuzetsu> The universal answer.
14:57:07 <doomlord> i'm going to have to check lenses out it seems :)
14:57:11 <doomlord> no avoiding it
14:57:41 <doomlord> but could template-haskell (macros) patch over this sort of thing
14:57:57 * hackagebot test-framework-program 1.1 - Test framework support for running simple test programs.  http://hackage.haskell.org/package/test-framework-program-1.1 (AdamWick)
14:57:59 * hackagebot modular-arithmetic 1.0.0.0 - A type for integers modulo some constant.  http://hackage.haskell.org/package/modular-arithmetic-1.0.0.0 (TikhonJelvis)
14:58:05 <geekosaur> you could do it with just a typeclass if you really wanted to
14:58:14 <doomlord> and someone said ML could deal with 'subtyping' (deriving /extending structures?) ... could they add that to haskell without breaking anything ?
15:00:05 <merijn> doomlord: That was me, and probably. The biggest issue is syntax. In haskell it'd be really hard to do it without having weird syntax that feels forced, probably
15:00:07 <Fuuzetsu> I believe that work is being done over summer on records which will allow extending.
15:00:25 <Fuuzetsu> Not fully sure though.
15:00:37 <merijn> doomlord: i.e. there's no theoreticla/conceptual reason for it not to work, there's practical reasons though
15:01:58 <mm_freak> > splitAt 7 . drop 27 . map head $ cake
15:02:00 <lambdabot>   ("TOOTOOT","ASCIICAT")
15:02:06 <mm_freak> toot toot
15:02:36 <FreeFull> Too toot
15:02:52 <no-n> > cake
15:02:54 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
15:02:57 * hackagebot modular-arithmetic 1.0.0.1 - A type for integers modulo some constant.  http://hackage.haskell.org/package/modular-arithmetic-1.0.0.1 (TikhonJelvis)
15:04:31 <questioner001> hi
15:05:38 <applicative_> hi questioner001
15:05:54 <carter> the javascript in the default criterion html template is terrible
15:07:46 <applicative_> did you have a question questioner001 ?
15:07:49 <questioner001> could you tell me why this works: (ghci):  map (\k -> [5,6,7] !! k) [0,1,2] , but when i define x,i to be [0,1,2] and [0,1,2] code like this : map (\k -> x !! k) i  , spits error "Couldn't match type `Integer' with `Int'"
15:08:01 <questioner001> my question ^ :)
15:08:25 <applicative_> the thing after !! is an Int
15:08:35 <applicative_> @type (!!)
15:08:37 <lambdabot> [a] -> Int -> a
15:08:59 <applicative_> but ghci default to construing the literals in [0,1,2] as Integers
15:09:03 <tromp> what type is your i?
15:09:07 <applicative_> I think that's the answer questioner001
15:10:10 <questioner001> ghci sets type, im defining x by: let x = [0,1,2] , wchich is werd because its the same
15:10:27 <arkeet> that's the monomorphism restriction
15:10:38 <arkeet> @where dmr
15:10:38 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
15:10:49 <applicative_> you can do :set -XNoMonomorphismRestriction inside ghci
15:10:55 <applicative_> or put it in your .ghci file
15:11:13 <applicative_> then you won't have this problem, though others do crop up
15:11:43 <applicative_> questioner001: or you can define x by let x :: Int; x = [0,1,2,3]
15:12:01 <applicative_> questioner001: you are seeing, I take it, how different Int and Integer are
15:12:12 <questioner001> I'll try that
15:12:16 <applicative_> > maxBound :: Int
15:12:18 <lambdabot>   9223372036854775807
15:12:35 <applicative_> Int is machine numbers, Integer is the real article, so to say
15:13:14 <applicative_> since you are unlikely to be doing !! n with a list with more than 9223372036854775807 elts, its uses Int
15:13:32 <applicative_> similarly length xs returns an Int and similarly with some other Prelude familiars
15:14:07 <applicative_> but ghci assumes a preference for Integer, which makes sense...
15:14:44 <applicative_> questioner001: sorry above I should have written let x :: Int; x =  [0,1,2,3]
15:14:50 <applicative_> questioner001: sorry above I should have written let x :: [Int]; x =  [0,1,2,3]
15:14:51 <applicative_> bah
15:15:05 <applicative_> its a list of Ints, [Int]
15:15:41 * applicative_ cant think without his prosthetic type checker
15:16:48 <questioner001> thanks, it's working
15:17:38 <dmj> Template Haskell can only be used at compile time? Is there a way to compile types on the fly and use them?
15:18:15 <c_wraith> What do you want to do at runtime with TH?
15:18:31 <dmj> example: I parse a csv with a variable number of header arguments, could I use TH to generate a data declaration for it
15:18:31 <c_wraith> (there are a bunch of different possible answers to your question, depending on what you want to do)
15:19:01 <Fuuzetsu> dmj: I believe emacs' ghc-mode written by Kazu can expand TH definitions at edit time
15:19:07 <Fuuzetsu> I'm not sure though, I haven't use id.
15:19:08 <Fuuzetsu> it*
15:19:13 <c_wraith> That...  Doesn't work too well. You would also need TH for all your code handling the parse results
15:19:21 <johnw> Fuuzetsu: we found code doing so in his source just last night
15:19:35 <c_wraith> Because the type has to exist at the time the code that uses it is compiled
15:19:44 <Fuuzetsu> johnw: Can you pass me a link? It'd be interesting to have a look.
15:20:12 <johnw> i wasn't the one doing the looking, my co-worker was
15:20:18 <dmj> c_wraith: Why doesn't it work too well. I'd have to use TH to make custom Show instances as well.
15:20:35 <Fuuzetsu> Eh, too bad. I'd love to see it.
15:20:49 <Fuuzetsu> Surely your co-worker must idle here though, right?~
15:20:52 <c_wraith> dmj: If all you want to do is show the data, there are far simpler approaches. If you want to actually do something interesting with it, you need to write code *for the type*
15:21:02 <johnw> he's not in now
15:22:00 <Fuuzetsu> Feel free to message me with a link later if you can be bothered and remember to do so, that'd be awesome.
15:22:28 <NemesisD> hey guys. i'm writing a client library for a REST api. trying to boil it down to some generic functions, i can't figure out if this is possible
15:22:38 <johnw> NemesisD: I've been working on the exact same thing
15:22:42 <johnw> I call it rest-client
15:22:53 <questioner001> would you recommend good editor/IDE for beginner?
15:22:57 <c_wraith> dmj: after all, if all you're doing is converting the input to strings, you might as well just write code to compile the input to strings.
15:23:09 <c_wraith> er, *convert* the input to strings
15:23:16 <NemesisD> so far my idea was like: indexResource :: HasResourceName a -> IO [a]; indexResource = get ("/" ++ resourceName ??)
15:23:34 <NemesisD> but obviously  that wouldn't work because resourceName cannot be based on the return value of the function
15:24:03 <dmj> c_wraith: I would, but I'm going to use parsec to determine their types. So an all string solution wouldn't be too helpful.
15:24:23 <NemesisD> it works well for the create case: createResource :: HasResourceName a -> IO (); createResource a = post ("/" ++ resourceName a) (toJSON a) or something
15:24:24 <c_wraith> dmj: well, then, now you're doing something far more complicated than you said. So what are you doing?
15:25:38 <NemesisD> basically, if i've got a resource User, the index and create functions both will generate a url like "/users" but index has no sensible value it can use to generate the URL
15:25:58 <questioner001> could you recommend a good editor or IDE for Haskell? (sorry, my english sucks)
15:26:15 <c_wraith> questioner001: there's nothing standard. A lot of people don't even use IDEs.
15:26:30 <c_wraith> questioner001: Things like emacs, vim, and textmate are probably the most used.
15:26:38 <NemesisD> johnw: that's funny. there's a ruby library with the exact same name. but it sucks
15:26:53 <NemesisD> johnw: my use case isn't really generic. it is an API client for a particular service
15:26:56 <dmj> c_wraith: In a nutshell. I want to read in a file format (.csv for example). Use TH to construct a custom data declaration for it. (i.e. each header entry would get its own constructor), generate the data type, then add all the data from the body into it. Since .csv's can have a variable number of header arguments it has to be dynamic. But If dynamic generation is relegated to compile time I'm sol.
15:27:08 <johnw> I'm in the process this week of reworking my API a bit, but once that's done we (FP Complete) should be ready to release it into the wild
15:27:13 <johnw> ah, I see
15:27:26 <johnw> my library is for helping people like yourself building clients for particular services
15:27:30 <c_wraith> dmj: but why do you need a *type*? How are you going to process it?
15:27:50 <johnw> I use it for talking to GitHub at the moment (for the use cases that the github library doesn't support)
15:27:53 <geekosaur> dmj, that doesn't make a lot of sense to me, are you also generating the code to *access* these runtime-generated types at runtime? if not, no point in generating the types at runtime. if so, why are you using a compiled language?
15:27:59 <johnw> but it's intended to be fully general
15:28:11 <NemesisD> johnw: any ideas for my use case of generating urls?
15:28:25 <dmj> geekosaur: exactly. I would create a query language as well that could perform lookups / joins on the .csvs
15:28:31 <johnw> I still don't quite understand your problem
15:28:49 <dmj> geekosaur: then write to disk in a binary format, read back into memory on the fly
15:28:50 <geekosaur> that doesn't sound like something that necessarily requires runtime types
15:28:58 <c_wraith> dmj: but why do you need a *type*?
15:29:06 <c_wraith> dmj: you haven't given a reason for that yet.
15:29:06 <NemesisD> johnw: basically i want a few generic functions: indexResource, createResource, updateResource, deleteResource
15:29:12 <geekosaur> also, *runtime* types would be for if they are actually creating new *kinds* of columns on the fly
15:29:19 <johnw> ok
15:29:30 <dmj> geekosaur: Types are necessary if I wan't to convert it to other data formats. Let's say .xls
15:29:32 <geekosaur> strings, various numbers, dates, ... what is the use case for adding to this list?
15:29:48 <geekosaur> xls doesn't do dynamic types either
15:30:02 <geekosaur> columns have dynamically chosen types from a fixed list
15:30:19 <NemesisD> johnw: if my resource is User for example, i need to figure out some typeclass (i think) for generating a base url, indexResource for user will GET /users, createResource for user will POST /users
15:30:40 <dmj> geekosaur: The data is not fixed, there could be differing amounts of headers from file to file
15:30:42 <geekosaur> the dynamically chosen type does not require anything special at all. altering the fixed list is where you might need dynamic typing
15:30:51 <dmj> its not fixed
15:30:59 <geekosaur> exacmple?
15:31:23 <geekosaur> (I suspect it will in fact turn out to be fixed in the ways that matter)
15:31:37 <johnw> NemesisD: ah, I see
15:31:39 <geekosaur> in particular, varying length is not a reason for a dynamic type
15:31:41 <johnw> you want type-indexed urls
15:31:46 <NemesisD> i suppose i could create a data UserResource = UserResource a; instance ResourceName (UserResource a) where resourceName = const "/users"
15:32:09 <NemesisD> then on create I'd use UserResource User, for index i could use UserResource ()
15:32:18 <geekosaur> it's a reason for a list or a tree or a vector, but those are not dynamic in this sense
15:32:28 <NemesisD> johnw: that sounds about right
15:32:53 <johnw> that's a good idea for a custom API lib
15:33:18 <geekosaur> dmj, seriously, eithger you are describing your needs poorly or you are understanding them poorly. either way, we need to see actual examples to understand
15:33:30 <geekosaur> because you have yet to describe anything that requires runtime generated types
15:34:09 <geekosaur> dmj, let me put it this way: what are you doing that is so much more dynamic than JSON?
15:34:12 <roconnor> edwardk, what I mean is that I don't have a use case for composable prisms yet.  If I just need to match and inject, there is not much point in using prims.
15:34:24 <roconnor> edwardk, but I don't doubt there are use cases.
15:34:29 <geekosaur> than *arbitrary* JSON?
15:34:36 <geekosaur> (which aeson handles quite well)
15:35:11 <NemesisD> not sure how nice this is, but indexResource :: HasResourceName t a => t -> IO [a]; indexUsers :: IO [User]; indexUsers = indexResource ... haven't quite figured out the types yet
15:36:15 <questioner001> what do you think of Leksah editor?
15:37:46 <Fuuzetsu> geekosaur: Heh, funny how there's currently an issue with Aeson being seemingly arbitrary on haskell-cafe right now.
15:38:10 <geekosaur> Fuuzetsu, only on one platform, from what I saw. and it appears to be a bug in hashable, which is known to have some bugs
15:39:18 <dmj> geekosaur: Given a CSV file, I want to mimic database tables in memory let's say. Not all database tables have fixed column counts. Types would be necessary on joins.
15:39:53 <geekosaur> dmj, types, yes, but not dynamically generated ones
15:40:12 <geekosaur> this is an application of Data.Dynamic at worst, which requires no runtime type or code generation
15:40:46 <dmj> geekosaur: When using template haskell ConT Name, name being the name of the type
15:40:52 <dmj> you can use*
15:41:01 <geekosaur> the kind of runtime type generation you are describing is this: you want to dynamically create a completely new type that is not a string, not a number, not a date, not a list of something, not a dictionary of something, ...
15:41:19 <geekosaur> oh, I see, you have confused TH with Data.Dynamic
15:41:23 <geekosaur> study the latter
15:42:10 <dmj> I think ConT is in Language.Haskell.TH. Why do I need Data.Dynamic
15:42:13 <geekosaur> TH is the wrong "kind" of Dynamic
15:42:17 <geekosaur> you think wrong
15:42:18 <dmj> I'm already generating data declarations on the fly
15:42:25 <dmj> i mean at compile time*
15:42:54 <Fuuzetsu> ah, hashable seems to be fixed now
15:43:16 <geekosaur> unless you are generating Haskell programs at runtime from your data, which is the hard way to do this kind of thing in most cases
15:43:57 <geekosaur> you found a hammer and you want to use it on a screw. consider using a screwdriver instead
15:44:06 <geekosaur> it's easier and it does less damage
15:44:36 <dmj> geekosaur: I just want to know if I can use Template Haskell any time other than compile time.
15:44:44 <geekosaur> no
15:44:52 <hpc> dmj: clearly you want something like this - http://hpaste.org/88185
15:45:01 <hpc> ;)
15:45:03 <geekosaur> the whole *point* of TH is compile time. you want Data.Dynamic
15:45:28 <Fuuzetsu> Pretty sure that's valid C
15:45:44 <dmj> hpc :)
15:45:56 <dmj> geekosaur: Ok I will study up on Data.Dynamic. I appreciate the help really.
15:45:59 <Peaker> dmj, why do you need to generate types from the CSV? What are you trying to do?
15:46:11 <Fuuzetsu> Peaker about 30 minutes late
15:47:30 <geekosaur> there are a lot of kinds of "dynamic". some can be addressed with simple lists. some can be addressed with Data.Dynamic. some can be addressed with generics. a few specialized cases can be addressed with TH
15:48:07 <dmj> Peaker: Create an in-memory database table from a file. It wouldn't have to be limited to .CSV's it would be limited by the kinds of parsers that could be written for it. Allowing new types to be created on the fly is a requirement though, then saved to disk and loaded again
15:48:12 <hpc> honestly, if you are using TH you already lost
15:48:26 <geekosaur> this sounds like Dynamic and maybe generics
15:48:40 <geekosaur> but probably not generics
15:49:28 <dmj> ok well I don't know either of those, so I have work to do
15:50:56 <Peaker> dmj, so you have the database format at compile-time?
15:51:01 <Peaker> dmj, i.e: your TH reads the CSV?
15:55:32 <dmj> Peaker: Parsec would read the CSV into something like data DB = DB [Header] [Body], then use header to generate a data declaration, instantiate, then fill it with body.
15:58:17 <Peaker> dmj, that means your database content is all available at compile-time, and not just the headers/types?
15:58:36 <Peaker> dmj, or do you mean to compile the generated data declarations at runtime?
16:00:12 <Fuuzetsu> Is there a point of being signed up to the haddock mailing list? 100% of the messages I got so far have been spam.
16:00:25 <Fuuzetsu> I thought there was an admin e-mail address verification required…
16:00:45 <dmj> Peaker: runtime
16:04:15 <Peaker> dmj, so if the thing fails to type-check, you just handle it as a runtime error?
16:05:03 <Peaker> dmj, if I understand it correctly, it sounds to me like you are using code generation and type checking (which are very heavy hammers, not easy to use) to do simple runtime schema validation that could alternatively be done by more straightforward means
16:05:28 <geekosaur> that's how I'm readin it too, fwiw
16:14:12 <dmj> Peaker, geekosaur: Ok I see what you're saying. If I just tried to do everything as json. Yea, you're right. You are right. Yep.
16:40:22 <roconnor> is there an (a -> b) -> (a -> c) -> (a -> (b,c)) combinator somewhere?
16:40:36 <copumpkin> :t (&&&)
16:40:37 <Fuuzetsu> :t (&&&)
16:40:38 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
16:40:38 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
16:40:43 * copumpkin glares at Fuuzetsu 
16:40:51 <Fuuzetsu> dealwithit.gif
16:41:01 <shachaf> it's (&&&) hth
16:41:11 <copumpkin> I bet the stereo quote is gone
16:41:17 <shachaf> Yep. I took it out.
16:41:21 <copumpkin> asshole!
16:41:32 <Fuuzetsu> What was it?
16:42:40 <geekosaur> "Welcome to #haskell, where your questions are answered in majestic stereo!"
16:43:02 <Fuuzetsu> Oh, pretty sure that got replaced with something similar…
16:43:21 <Fuuzetsu> I don't remember how to trigger it. It was posted yesterday during the holy war of tabs vs spaces
16:43:29 <geekosaur> "...contrapunctal fugues!"
16:43:30 <Fuuzetsu> @quote frugal
16:43:30 <lambdabot> No quotes match. Sorry.
16:43:33 <Fuuzetsu> yeah, that
16:43:37 <Fuuzetsu> @quote fugues
16:43:37 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
16:43:55 <Mortomes> I've got my mind on my monads and my monads on my mind.
16:43:57 <lispy> spaces, btw
16:44:58 * Fuuzetsu says nothing
16:46:01 <lispy> Are there any programming languages where \t is a lexical error when used as whitespace?
16:46:36 <lispy> (the whitespace language being a notable special case of whitespace handling)
16:46:56 <rgrinberg> lispy: fsharp
16:46:59 <Fuuzetsu> I don't think so. I'm sure you could find some.
16:47:02 <geekosaur> don't know of any current ones. fortran used to not like it much
16:47:07 <monochrom> majestic stereo is not enough. contrapuntal fugue is much grander
16:47:10 <shachaf> lispy: YAML
16:47:13 <Fuuzetsu> rgrinberg: Really? Based F#, might be worth learning after all.
16:47:30 <shachaf> Well, not an error as whitespace. An error as indentation.
16:47:50 <rgrinberg> Fuuzetsu: i don't like that behaviour actually
16:47:51 <monochrom> http://www.youtube.com/watch?v=N2JFgfc7c70 "so you want to write a fugue?"
16:48:17 <Fuuzetsu> rgrinberg: Why? It solves the age old debate and it gets you spaces everywhere like it should be.
16:48:33 <shachaf> Are people seriously talking about tabs vs. spaces again?
16:48:50 <Mortomes> Next topic: Opening curly braces on the same line or the next line.
16:49:05 <Fuuzetsu> shachaf: Not really. No one is arguing for tabs this time.
16:49:24 <lispy> oh, I'll play devil's advocate then
16:49:29 <Fuuzetsu> Mortomes: Same line~
16:49:36 <Fuuzetsu> ~≈≋
16:49:52 <rgrinberg> Fuuzetsu: i actually don't know why
16:50:00 <rgrinberg> maybe becasue the first time i've encountered i was really surprised
16:50:03 <^|{`-}^{> I feel sad that Haskell does not allow my nick as an operator
16:50:50 <lispy> > let lispy x y = "this works" in text (0 `lispy` 1)
16:50:52 <lambdabot>   this works
16:50:58 <lispy> I must have a better nick
16:51:12 <Fuuzetsu> You will never find a perfect nickname.
16:51:33 <lispy> does the ordering of nicks create a category at least?
16:52:00 <Fuuzetsu> Wouldn't it just be the same as ordering of strings?
16:52:57 <shachaf> lispy: Infix? How unlispy.
16:53:32 <lispy> (/me (hangs '(head shame))
16:53:47 <Fuuzetsu> shachaf: I have defined a macro which let me do infix in Lisp recently. I felt dirty and deleted it straight away…
16:56:32 <lispy> seriously, no one is complaining about my dropped paren...
16:56:48 <lispy> I guess the spaces vs. tabs debate really took the fight out of everyone
16:56:51 <monochrom> I don't like to complain. it's too easy.
16:57:19 <monochrom> I don't actually participate in space vs tab "debate"s. what is there to debate?
16:57:25 <Fuuzetsu> You're right. I'm going to run rainbow delimiters for #haskell from now on.
16:57:42 * geekosaur drops so many parens that when he dies, people will be notified by thousands of close parens appearing all at once
16:57:49 <lispy> what are rainbow delimiters?
16:58:24 <geekosaur> "everything you can think of and then some" (cf. indigo)?
16:58:25 <lispy> oh, I found a link at the emacswiki, n/m
16:58:39 <Fuuzetsu> (these (are (rainbow (delimiters)))) http://i.imgur.com/HMkmwWt.png
16:59:29 <lispy> Fuuzetsu: reminds me of this: https://si0.twimg.com/profile_images/2399752109/pukingunicorn.jpg
16:59:38 <Mortomes> Coding on LSD. A beginner's guide by Fuuzetsu.
16:59:57 <Fuuzetsu> Mortomes: Hey, it's useful ;;
17:00:24 <monochrom> Fuuzetsu: I regret to tell you that the channel mode +C here was my idea :)
17:00:48 <Fuuzetsu> monochrom: It's client-side anyway.
17:01:08 <Fuuzetsu> I mean, it's not even meant to send colours.
17:01:23 <monochrom> ok!
17:01:48 <lispy> monochrom: do you mean +c ?
17:01:54 <lispy> http://docs.dal.net/docs/modes.html#2.2
17:01:54 <Fuuzetsu> Your name is fitting though…
17:01:57 <monochrom> I have no typo
17:02:25 <lispy> what is +C as a channel mode?
17:02:46 <monochrom> damn, I am mistaken. it is +c
17:02:54 <Fuuzetsu> There isn't one.
17:03:19 <int-e> lispy: freenode has one, it blocks CTCP messages to channels. http://freenode.net/using_the_network.shtml
17:03:29 <monochrom> http://freenode.net/using_the_network.shtml
17:03:47 <lispy> thanks. I was finding documents like that but not the one for the freenode server.
17:27:35 <Garyuutensei> Hi, I have the following polymophic type 'data Vec3 a = Vec3 !a !a !a'. Is there any way to tell the compiler to unpack the values? I only want to use this type for Double and Int.
17:28:23 <shachaf> Nope. :-(
17:30:05 <tinyghost> :t (:+)
17:30:06 <lambdabot> a -> a -> Complex a
17:30:10 <tinyghost> oh
17:34:26 <lispy> shachaf: -funbox-strict-fierds will do it, won't it?
17:34:37 <shachaf> lispy: Do what?
17:34:37 <geekosaur> for polymorphic fields?
17:34:56 <lispy> shachaf: unpack them
17:35:26 <shachaf> lispy: Unpack what?
17:35:34 <shachaf> I suspect the answer is no but I'm not sure I understand the question.
17:35:38 <lispy> shachaf: re: Garyuutensei
17:35:49 <Garyuutensei> lispy: No, it doesn't work
17:36:32 <lispy> then maybe a SPECIALIZE UNPACK <some type> pragma would be nice
17:36:40 <Garyuutensei> shachaf: I probably need to check how something like Vector.Unboxed is implemented
17:36:52 <lispy> so that when Vec3 Double is used it does unpack them
17:37:17 <barrucadu> I'm having difficulty understanding coproducts, could anyone point me to some resource that's better than wikipedia? Specifically, I'm looking at the example on the F-algebra article, trying to figure out what the coproduct of two functions actually is
17:37:19 <shachaf> Garyuutensei: With a type family.
17:37:24 <lispy> Garyuutensei: Vector.Unboxed stores things at a foreign pointer.
17:37:39 <shachaf> lispy: For polymorphic functions?
17:39:10 <lispy> shachaf: I'm not sure exactly how to make the notation of the pragma work well, but I'm just imagining that you could tell ghc, "Hey, when this Vec3 holds Doubles, you should unpack them". But yeah, it would have to specialize the functions too.
17:40:12 <Garyuutensei> lispy: what do you mean with SPECIALISE UNPACK? I thought SPECIALISE is only for functions.
17:40:31 <lispy> Garyuutensei: I was suggested a hypothetical pragma
17:40:36 <lispy> suggesting*
17:40:46 <Garyuutensei> lispy: Oh, I see :P
17:41:11 <tswett> @index par
17:41:12 <lambdabot> GHC.Conc, Control.Parallel, Graphics.HGL.Utils, Graphics.HGL
17:42:00 <tswett> I'm trying to do something in GHCi that will use up all my CPU. Unfortunately, I have four cores.
17:42:33 <tswett> I guess the solution is straightforward. Open four instances of GHCi.
17:42:48 <Nisstyre> tswett: four instances of parallel Ackermann
17:42:56 <Nisstyre> (if that's even a thing)
17:43:02 <tswett> Well, last [1..] is doing fine for the moment.
17:43:38 <tswett> Running Starcraft causes my Internet connection to be too slow to feasibly run Starcraft.
17:43:53 <tswett> My connection is fast enough to play Starcraft, but only when I'm not playing Starcraft.
17:44:24 * geekosaur reminded of winmodems
17:44:44 <Entroacceptor> tswett: sounds like hardware troubles
17:45:00 <tswett> All right, using up all the CPU doesn't affect my Internet at all. Time to try reverse [1..].
17:45:05 <tswett> Oops, it crashed.
17:45:35 <geekosaur> you were expecting?
17:45:47 <tswett> I was expecting it to use more than 20% of my memory before crashing.
17:46:14 <Fuuzetsu> If memory usage is what you want, just try to do anything on a >30MB file with HXT
17:46:42 <Fuuzetsu> I see my swap is still not fully released since I last tried that about 4 days ago
17:47:01 <Fuuzetsu> Correction, 5 days ago.
17:47:10 <Demos> if I have a function like fun :: a -> String -> IO () can I match based on the type of a
17:48:15 <Fuuzetsu> Demos: I'm not sure what you're asking but I'm going to go with ‘no’.
17:48:54 <tswett> So I've established that the packet loss is not caused by downloading, or uploading, or CPU usage, or memory usage. So... uh...
17:49:05 <Fuuzetsu> Maybe a typeclass is what you want. class Foo a where fun :: a -> String -> IO ()
17:49:12 <lispy> tswett: could be traffic shaping
17:49:23 <tswett> lispy: traffic shaping between me and my router?
17:49:33 <Fuuzetsu> tswett: You and your ISP.
17:49:46 <Entroacceptor> but why would they block SC?
17:49:53 <tswett> I'm getting bad latency and packet loss between me and my router.
17:50:06 <Fuuzetsu> Maybe they are just blocking that type of traffic. Who knows.
17:50:13 <Fuuzetsu> Oh.
17:50:14 <lispy> tswett: are you having packet loss or low throughput when playing the game? And where does that occur in the network?
17:50:40 <lispy> tswett: wireless?
17:51:04 <tswett> lispy: while I have "ping" running, pinging my router continuously, and I'm in a Starcraft game, there's packet loss and latency. And yeah, it's a wireless card in a desktop computer.
17:51:06 <Entroacceptor> tswett: have you tried rebooting the router? Maybe it is confused and tries some connection tracking
17:51:32 <Entroacceptor> which fails with that connection and leads to weird behavoir.
17:52:06 <lispy> tswett: looks like you're not alone: http://us.battle.net/sc2/en/forum/topic/8414822203
17:52:09 <Entroacceptor> but that is a bit way to OT here
17:52:19 <Entroacceptor> let's take it to -blah
17:52:23 <tswett> *nod*
17:58:00 * hackagebot modular-arithmetic 1.0.1.0 - A type for integers modulo some constant.  http://hackage.haskell.org/package/modular-arithmetic-1.0.1.0 (TikhonJelvis)
18:04:19 <Demos> does System.Directory's findFile function support wildcards?
18:05:41 <geekosaur> no, it's not /usr/bin/find, it's /usr/bin/which
18:07:37 <diamondShovel> From Hoogle regarding "$" : It is also useful in higher-order situations, SUCH AS MAP ($ 0)
18:07:57 <diamondShovel> what the hell does that mean? Where would this be useful? What is their angle, what are they driving at?
18:08:05 <lispy> :t map ($ 0)
18:08:07 <lambdabot> Num a => [a -> b] -> [b]
18:08:08 <Demos> is there any function that is like findAll:: [FilePath] -> String -> Maybe [FilePath]?
18:08:21 <lispy> diamondShovel: does that type help?
18:08:28 <shachaf> > map ($ 5) [(\x -> x ^ 2), (\x -> x * 10), (\x -> x - 20)]
18:08:30 <lambdabot>   [25,50,-15]
18:08:59 <lispy> :t zipWith ($ 0)
18:09:00 <lambdabot> Num a => [a -> b -> c] -> [b] -> [c]
18:09:06 <diamondShovel> shachaf: I see.....
18:09:08 <Botje> Demos: how is that different from filter?
18:09:35 <geekosaur> Botje, they want /usr/bin/find, recursive directory search with wildcards
18:09:51 <Botje> oh. brrr :)
18:10:08 <Demos> or well I am moving these files so mv ./*.bla ./dest would work
18:10:25 <johnw> aristid: with my last breath, I ping at thee
18:11:17 <mikeplus64> > filter (".bla" `isSuffixOf) ["asdf.bla","foo","bar","dsfgn.txt"]
18:11:19 <lambdabot>   <hint>:1:27: parse error on input `)'
18:11:29 <mikeplus64> > filter (".bla" `isSuffixOf`) ["asdf.bla","foo","bar","dsfgn.txt"]
18:11:30 <lambdabot>   ["asdf.bla"]
18:11:40 <mikeplus64> Demos: something like that?
18:11:57 <Demos> that sounds good, just need to get everything in the directory though
18:13:58 <geekosaur> getDirectoryContents
18:14:45 <johnw> if you're using shelly, it's just "ls"
18:15:00 <johnw> and listDirectory, if you're using system-fileio
18:15:02 <benzrf> hellO!
18:15:10 <lispy> or lsT (I find it a bit easier to work with text)
18:15:10 <benzrf> what's the best way to rotate or shift a list?
18:15:24 <johnw> lispy: is that in shelly now?
18:15:51 <lispy> johnw: I've been using shelly more and I feel that it has a pretty ad-hoc cruddy API to be brutally honest. I still use it though, better than nothing and all.
18:16:26 <johnw> yeah, it could be improved upon
18:16:30 <lispy> johnw: http://hackage.haskell.org/packages/archive/shelly/0.15.3.1/doc/html/src/Shelly.html#lsT
18:16:32 <johnw> but it's awfully effective
18:16:36 <lispy> I don't like that they use a special FilePath
18:16:49 <lispy> And redefine <$> and some other stuff
18:16:50 <johnw> it's just a re-export from system-filepath
18:17:01 <johnw> I hate FilePath = String
18:17:10 <lispy> it creates a lot of unnecessary conversions
18:17:20 <johnw> but it's type safe, and more accurate
18:17:27 <johnw> i use system-filepath in 100% of my projects now
18:17:38 <johnw> it's what ClassyPrelude uses too
18:19:02 <lispy> Are you trying to give me more reasons to avoid it? :)
18:19:27 <johnw> embrace the FilePath, luke
18:19:45 <johnw> like many things, the pain pays off
18:19:47 <lispy> classy prelude was a bad idea when proposed and I haven't followed it since. I assume that hasn't changed.
18:20:02 <johnw> for the reasons you thought it was a bad idea, probably not
18:20:22 <johnw> it can be nice to just use "length" when you want the length of something, though
18:20:25 <perdent> Figured I'd start off a fun little challenge, so here goes. What is a Quine? Essentially, a quine is a self-reproducing program that when run, produces itself. I'll start off with one I made in C a while ago.
18:20:27 <johnw> instead of length, T.length, B,length, etc.
18:20:29 <perdent> Code: main(){char*x="main(){char*x=%c%s%c;int y='%c';printf(x,y,x,y,y);}";int y='"';printf(x,y,x,y,y);}
18:20:49 <perdent> Let's see who can make (or find) the smallest quine, you can make it in any language you like,
18:23:52 <Fuuzetsu> perdent: empty program
18:24:43 <perdent> What?
18:25:05 <Darkflux> Can you run an empty program though?
18:27:30 <Fuuzetsu> Darkflux: sure. ‘echo "" > quine.sh; chmod +x quine.sh; ./quine.sh’
18:27:45 <johnw> awesome
18:27:54 <johnw> seeing as how that cannot be beat, I concede
18:28:36 <perdent> Is that even a valid Quine?
18:31:34 <Darkflux> Seems to be considered valid, but against the spirit of it, according to the wikipedia article on quines
18:31:43 <doomlord> a quine in asm ?
18:34:40 <perdent> hmmm, what about <?php echo file_get_contents(__FILE__); ?>
18:37:04 <Darkflux> if that's doing what I think it's doing, then it's not a quine perdent.  It's not allowed to take input apparently.
18:37:18 <Darkflux> cat $0 is cited as being illegal for the same reason
18:37:47 <perdent> Source code that displays itself
18:43:03 <benzrf> here's the simplest quine:
18:45:03 <bitonic> benzrf: doesn’t work in Haskell
18:45:31 <bitonic> I wonder what the shortest is in Haskell + Prelude
18:46:00 <benzrf> bitonic: you sure?
18:46:12 <bitonic> benzrf: pretty sure yeah.
18:46:13 <benzrf> oh you're right :<
18:46:27 <benzrf> ok, it's the simplest *scripting language* quine
18:46:28 <benzrf> ;p
18:47:20 <Fuuzetsu> That 11 language quine is pretty cool
18:47:55 <benzrf> whichone?
18:48:12 <Fuuzetsu> There's a link to it on the bottom of the Wiki article I think…
18:48:29 <Fuuzetsu> http://asiajin.com/blog/2009/09/22/uroboros-programming-with-11-programming-languages/
18:48:48 <bitonic> whoah.
18:48:57 <bitonic> unlambda.  what the
18:49:16 <benzrf> unlambda?
18:49:27 <bitonic> brainfuck?
18:49:32 <bitonic> no he must be joking
18:49:34 <benzrf> sounds like the name of a supervillian
18:49:42 <benzrf> [unlambda]
18:49:57 <cmccann> benzrf: it's a combinator-based esoteric language
18:50:03 <arkeet> how about lazy K
18:50:09 <cmccann> lazy K is far more elegant
18:50:11 <benzrf> weerd
18:51:22 <bitonic> Unlambda <= Whitespace <= brainfuck <= Java <= Haskell <= Lua <= Perl <= Python <= Ruby.  if it’s not a joke, this guy has some time on his hands.  I guess it’s doable
18:51:47 <benzrf> holy fuck!!!!!
18:51:48 <edwardk> @remember xplat if you want to carry your machete all the time and not make people nervous, you need to constantly blaze trails
18:51:48 <lambdabot> Done.
18:52:20 <benzrf> logical next step: turn that quine into a shell script that does the relaying and outputs the original shell script
18:53:19 <benzrf> fuck, it took him 3 hours
18:53:20 <benzrf> -.-
18:54:48 <bitonic> once you get the foundations going (e.g. generating a piece of brainfuck code that prints an arbitrary string) it’s probably not terribly difficult
18:55:01 <benzrf> ublublu
18:57:24 <Fuuzetsu> Step 1: Be Japanese
18:57:42 <Fuuzetsu> (There's no step 2)
18:57:42 <benzrf> so rasist
18:58:03 <Fuuzetsu> I forgot that a mention of race is considered racist nowadays.
18:58:08 <benzrf> :D
18:58:40 <benzrf> CLEARLY you are being racist against white peoplez by claiming that japanese peoplez are better at the codes
18:58:43 <benzrf> :DDDD
18:58:49 <cmccann> maybe this counts as a video game? because it is a scientific fact that asians are always best at all video games.
19:00:05 <nimdAHK> man, if someone has all those environments set up, please paste the Whitespace code.
19:00:08 <benzrf> I demand that somebody rewrite the quine relay so that instead of outputting the source for the next step, it outputs a valid bash command that results in the next step
19:00:30 <benzrf> that way you can just eval it recursively
19:00:31 <benzrf> :D
19:01:17 <benzrf> so something like 'echo foo > bar && gcc bar && ./bar'
19:02:13 <benzrf> I don't recall, does haskell tail recurse?
19:02:31 <lispy> benzrf: we have tail call optimization
19:02:35 <enthrops> Why doesn't haskell do automatic memoization?
19:02:38 <lispy> (which is more general)
19:02:38 <benzrf> excellent
19:02:44 <benzrf> enthrops: does it not?
19:02:57 <benzrf> I'd imagine to conserve memory
19:03:00 <enthrops> benzrf: doesn't seem like it. does it?
19:03:02 <benzrf> but who knows
19:03:14 <lispy> enthrops: it does automatic sharing, but not automatic memoization
19:03:23 <Fuuzetsu> Just yesterday Cale explained that TCO actually doesn't apply to Haskell because of something or the other.
19:03:34 <benzrf> tco?
19:03:41 <benzrf> oh
19:04:00 <lispy> the actual details are a bit complicated, but you can program like it has tail call optimization
19:04:08 <benzrf> maybe it's like
19:04:11 <Cale> It doesn't make much sense to talk about tail call optimisation, when you don't have a call stack at all.
19:04:13 <benzrf> functions return thunks
19:04:23 <benzrf> and then recursing just evals the thunk
19:04:24 <geekosaur> tail recursion implies a strict call graph. haskell's lazy evaluation works differently (graph reduction)
19:04:24 <lispy> If you add accumulator parameters, you have to be careful about building up huge thunks
19:04:26 <benzrf> and there's no callstack?
19:04:29 <Cale> There's no call stack to not add tail calls to
19:04:48 <geekosaur> pattern matching is what builds stacks, not function calls
19:04:53 <benzrf> what's the best way to handle looping a certain number of times?
19:05:07 <lispy> benzrf: depends on the loop
19:05:09 <benzrf> I'm trying to generate a fractal and I want to put a limit on what level of detail it calculates
19:05:17 <lispy> map, zip, and foldr all "loop" in a sense
19:05:18 <benzrf> each recurse improves it
19:05:22 <Cale> Yeah, there's a stack that GHC uses to keep track of pattern matches which are waiting for their scrutinee to be sufficiently evaluated to match a pattern.
19:06:00 <Cale> benzrf: take n . iterate?
19:06:08 * benzrf headdesks
19:06:12 <benzrf> of course >_>
19:06:20 <cmccann> benzrf: yeah, generate an infinite list of successive approximations, take what you want
19:06:27 <benzrf> although, I only really want the last one
19:06:33 <cmccann> use (!!)
19:06:42 <cmccann> that's like one of the few times where (!!) makes sense really
19:07:22 <Cale> Though you might want to be cautious about strictness here
19:08:39 <Cale> If you use  iterate f x !! n  for large n you'll end up with a large expression which if f pattern matches on its argument may cause you stack problems.
19:09:38 <cmccann> the strictness analyzer might be smart enough to patch things up.
19:09:50 <Cale> It might, yeah
19:10:02 <cmccann> but assuming this is something like Julia set iteration n will be pretty small I expect
19:34:37 <carter> loooks like the benzrf dudes gone
19:35:17 <carter> > :t  (!!)
19:35:18 <lambdabot>   <hint>:1:1: parse error on input `:'
19:35:26 <carter> @type  (!!)
19:35:27 <lambdabot> [a] -> Int -> a
19:35:33 <mikeplus64> :t (!!)
19:35:35 <lambdabot> [a] -> Int -> a
19:46:38 <DiegoNolan> out of Snap, Yesod, and Happstack, which framework is the most mature?
19:48:06 <carter> DiegoNolan depends on what your goal is
19:48:11 <t4nk331> what is the meaning of defining a type inside a class?
19:49:54 <blaenk> t4nk331: can you show an example?
19:50:16 <t4nk331> I have this code http://hpaste.org/88190 but I am not sure what role FactoredRepr is playing
19:50:52 <blaenk> can't help you sorry, was just interested in what you were talking about
19:50:57 <blaenk> I'm not sure what it means
19:51:20 <cmccann> t4nk331: look up "type families"
19:51:38 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-families.html#assoc-decl
19:51:44 <cmccann> but basically it's a type synonym that depends on the class parameter
19:58:02 * hackagebot labyrinth 0.1.5.0 - A complicated turn-based game  http://hackage.haskell.org/package/labyrinth-0.1.5.0 (AlexeyKotlyarov)
20:00:33 <NemesisD> anyone know how i would turn a pure function foo :: a -> b into Lens' a b ?
20:02:53 <edwardk> NemesisD: you can't 'really'. you can make a getter out of it though
20:02:54 <mikeplus64> edwardk: http://hpaste.org/88191
20:02:56 <edwardk> using 'to'
20:03:17 <edwardk> mikeplus64: can you try linear HEAD and see if its still a problem? if not i'll push
20:03:24 <mikeplus64> OK
20:03:53 <Ndit> lol try going to powerball.com
20:04:08 <NemesisD> edwardk: i guess i'll just change the type signature then to a -> b. i think that may work
20:04:26 <NemesisD> i'm trying to compose a pure function in with a few lenses
20:04:40 <NemesisD> Lens' es
20:05:36 <mikeplus64> edwardk: it works in git (but it's pretty bad it's broken on hackage (is it?))
20:05:53 <edwardk> > (1,"hello")^._2.to length
20:05:55 <lambdabot>   5
20:06:05 <edwardk> mikeplus64: i'll update hackage
20:06:30 <blaenk> are type families kind of like, well they seem complicated to me so far but one example, the impression I get is where it defines: class Graph g where; type Vertex g; type Edge g
20:06:59 <mikeplus64> edwardk: thanks
20:07:06 <blaenk> so that's saying that when an instance is created for that type, 'Vertex g' will serve as a synonym for whatever g ends up being?
20:07:14 <edwardk> blaenk: thats pretty much exactly what i do in my graphs package
20:07:14 <blaenk> reference: http://research.microsoft.com/en-us/um/people/simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf section 2.3
20:07:32 <blaenk> haha, am I correct?
20:07:46 <edwardk> blaenk: that says 'g' is a type. 'Vertex g' is another type, determined by g, but which may be different from g.
20:07:57 <blaenk> yup, think I got that much
20:08:04 <blaenk> what I mean is what effect does that have when an instance is created
20:08:32 <edwardk> you can say newtype G = G [(Int,Int)] instance Graph G where type Vertex G = Int; type Edge G = (Int,Int)
20:08:51 <edwardk> now if you had a method in Graph that said something like
20:09:33 <edwardk> class Graph g where type Vertex g; type Edge g; start :: g -> Edge g -> Vertex g; end :: g -> Edge g -> Vertex g
20:10:02 <edwardk> you might define start _ (x,y) = x; end _ (x,y) = y in that example.
20:10:31 <edwardk> but if i had a completely different graph type, it might not use Int as the vertex type or (Int,Int) as the edge type. it could be radically different
20:10:46 <edwardk> and start and end would use the appropriate types
20:11:16 <blaenk> nice, thanks :D
20:14:30 <edwardk> @tell mizu_no_oto http://gafferongames.com/2013/05/19/virtual-go-beta-work-in-progress/ its starting to actually render
20:14:30 <lambdabot> Consider it noted.
20:22:04 <benzrf> hi!
20:22:51 <benzrf> if I want to match a list with at least three elements and get a variable that contains the first three, why doesn't (r3@(ra:rb:rc):rows) work?
20:23:28 <Nisstyre> benzrf: rc is the tail of the list
20:23:35 <benzrf> o
20:23:39 <benzrf> derp
20:24:27 <benzrf> what's the best way to go about this?
20:24:53 <benzrf> should I match xs@(_:_:_:_) and then take 3?
20:24:58 <benzrf> that seems silly
20:25:57 <Nisstyre> > let ((r3@(ra:rb:rc:[])):rows) = [[1],[2],[3]] in r3
20:25:59 <lambdabot>   *Exception: <interactive>:3:5-45: Irrefutable pattern failed for pattern ((...
20:26:02 <Nisstyre> oops
20:26:11 <Nisstyre> > let (r3@(ra:rb:rc:[])) = [[1],[2],[3]] in r3
20:26:12 <lambdabot>   [[1],[2],[3]]
20:26:39 <benzrf> hmm
20:26:52 <benzrf> the thing is that the tail may have lots of elements in it
20:27:16 <benzrf> > let (r3@(ra:rb:rc:[])) = [[1],[2],[3],[4]] in r3
20:27:18 <lambdabot>   *Exception: <interactive>:3:5-42: Irrefutable pattern failed for pattern (r...
20:27:25 <benzrf> > let (r3@(ra:rb:rc:[]):rem) = [[1],[2],[3],[4]] in r3
20:27:27 <lambdabot>   *Exception: <interactive>:3:5-46: Irrefutable pattern failed for pattern (r...
20:27:43 <Nisstyre> > let (r3@(ra:rb:rc:[])):xs = [[[1],[2],[3]], []] in r3
20:27:44 <lambdabot>   [[1],[2],[3]]
20:27:49 <Nisstyre> > let (r3@(ra:rb:rc:[])):xs = [[[1],[2],[3]], []] in xs
20:27:49 <benzrf> oohhh
20:27:50 <lambdabot>   [[]]
20:27:53 <benzrf> :D
20:28:14 <Nisstyre> etc...
20:28:20 <benzrf> > let (r3@(ra:rb:rc:[])):rem = [[1],[2],[3],[4]] in r3
20:28:22 <lambdabot>   *Exception: <interactive>:3:5-46: Irrefutable pattern failed for pattern (r...
20:28:24 <benzrf> htm
20:28:25 <benzrf> *hrm
20:29:04 <Nisstyre> benzrf: the type you're matching against is [[[a]]]
20:29:06 <benzrf> whatever I'll just do ra:rb:rc:rows and then [ra, rb, rc]
20:29:08 <benzrf> D:
20:29:12 <benzrf> that's true
20:29:34 <Nisstyre> so, xs/rows must be of type [[[a]]]
20:29:36 <benzrf> but I'm treating it like [[a]] and passing off the a to other stuff
20:29:47 <benzrf> that in turn treat it as [a]
20:30:02 <benzrf> no wait
20:30:12 <benzrf> no I'm working with [[a]] but treating it like [a]
20:30:21 <benzrf> then handing off each row to other funcs
20:30:38 <Nisstyre> well, any way you have to make the type checker happy
20:30:44 <benzrf> yh
20:31:31 <Nisstyre> well this isn't strictly a type problem
20:31:42 <Nisstyre> it's an "oops this pattern failed" problem
20:31:54 <benzrf> basically I want to pass [1, 2, 3, 4, 5, 6] to a functino
20:31:56 <benzrf> *function
20:32:12 <benzrf> and have it pattern match so that [1, 2, 3] is one arg and the remainder is the rest
20:32:18 <benzrf> also it only matches if there are at least three
20:32:28 <benzrf> *the other, not the rest
20:33:17 <Nisstyre> > let xs = [1, 2, 3, 4, 5, 6] in let first3 = take 3 xs; rem = drop 3 xs in (first3, rem)
20:33:19 <lambdabot>   ([1,2,3],[4,5,6])
20:33:31 <benzrf> :\
20:33:31 <Nisstyre> I believe there is a function to do this in Data.List
20:33:44 <benzrf> I was hoping patterns could solve my problems
20:33:52 <Nisstyre> it probably could
20:33:56 <benzrf> anyway if I want it to only match 3 or more...
20:33:59 <Nisstyre> but it's probably not the most elegant solution
20:34:05 <benzrf> <benzrf> should I match xs@(_:_:_:_) and then take 3?
20:34:42 <cmccann> > splitAt 3 [1..6]
20:34:43 <lambdabot>   ([1,2,3],[4,5,6])
20:34:45 <benzrf> wait shit I can just use guards
20:34:46 <benzrf> -.-
20:34:49 <benzrf> dammit
20:34:52 <benzrf> ok thanks anyway :D
20:35:04 <ParahSai1in> > let (a:b:c:d) = [1,2,3,4,5,6] in ([a,b,c],d)
20:35:05 <lambdabot>   ([1,2,3],[4,5,6])
20:35:11 <benzrf> :\
20:35:12 <benzrf> ok
20:35:21 <benzrf> I thought that seemed a liitle crude
20:35:50 <cmccann> a prefix of a list is not a part of the list
20:35:57 <cmccann> you can't pattern match for it, you need to construct a new list
20:36:09 <cmccann> you can only re-use tails in a cons list
20:36:57 <cmccann> the elegant solution here would be view patterns if view patterns were actually elegant.
20:39:16 <johnw> cmccann: they can be
20:39:44 <cmccann> usually not for simple stuff though :T
20:41:51 <johnw> cmccann: http://hpaste.org/88192
20:42:03 <johnw> shows the symmetry of cata and ana-morphisms
20:42:16 <cmccann> ok that is cute I will agree
20:42:17 <johnw> (that's from Tim Williams' slides on Recursion Schemes)
20:42:56 <johnw> that won a round of applause when he showed it :)
20:43:13 <cmccann> yeah it's nice
20:53:53 <mark-andrus> Anyone here have experience using cabal with hugs?
20:54:45 <mark-andrus> It seems like cabal isn't looking in ~/.cabal/lib/hugs/ for dependencies it has already installed
20:59:09 <schell_> is there a way to construct a tuple with Control.Applicative?
20:59:28 <schell_> I'm thinkin something like (,) <$> 1 <*> 2
20:59:41 <byorgey> mark-andrus: no one uses hugs; it has not been maintained in ~7 years at this point.  If Cabal works with it at all that is just an accidental bonus at this point.
20:59:49 <monochrom> > (,) 1 2
20:59:51 <lambdabot>   (1,2)
20:59:58 <byorgey> mark-andrus: in particular no one has been testing and maintaining it with hugs for quite a while.
20:59:58 <schell_> is that it?
21:00:20 <schell_> whiskey <$> haskell
21:00:26 <schell_> don't use it!
21:00:35 <Nisstyre> hmm, too bad lambdabot doesn't seem to have TupleSections enabled
21:00:37 <byorgey> @type  (,) <$> 1 <*> 2
21:00:38 <lambdabot> (Num (f a), Num (f a1), Applicative f) => f (a1, a)
21:00:42 <mark-andrus> byorgey: i figured as much. i'm on an ARM machine so i don't have access to GHCi : (
21:01:01 <mark-andrus> byorgey: know of any alternative haskell REPLs?
21:01:19 <mark-andrus> preferably w/ some kind of cabal integration
21:01:53 <papyrus_> class (Monoid w, Monad m) => MonadWriter w m | m -> w where
21:02:13 <byorgey> mark-andrus: no idea, maybe check out http://www.haskell.org/haskellwiki/UHC  or  http://repetae.net/computer/jhc/
21:02:13 <papyrus_> i don't understand MonadWriter w m (m->w) ?
21:02:31 <byorgey> papyrus_: the  m -> w  is a functional dependency
21:02:37 <mark-andrus> byorgey: thanks, will review
21:02:40 <byorgey> papyrus_: it means that the choice of m determines the choice of w
21:03:26 <papyrus_> hmm.. thanks byorgey.
21:03:48 <papyrus_> where i find it ? i am readding learnyouhaskell. but it don't mention it.
21:04:41 <byorgey> papyrus_: http://www.haskell.org/haskellwiki/Functional_dependency
21:05:06 <byorgey> papyrus_: however, if you are just reading LYAH you really don't need to worry about it much at this point
21:05:55 <papyrus_> i am also reading All about monad.
21:06:28 <papyrus_> thanks a ton byorge. you helped me. :-)
21:07:12 <Flaeme>  /grep Flaeme
21:07:18 <Flaeme> Blah. :P
21:07:34 <zerokarmaleft> > Right 1 >>= \x -> return (x + 100)
21:07:36 <lambdabot>   Right 101
21:07:51 <zerokarmaleft> how come this doesn't require an explicit type sig?
21:09:06 <geekosaur> :t Right 1 >>= \x -> return (x + 100)
21:09:07 <lambdabot> Num b => Either a b
21:09:48 <geekosaur> Right tells it the monad, 1 goes through defaulting
21:10:36 <zerokarmaleft> right, but how is a inferred?
21:10:41 <geekosaur> (note that defaulting did not come into play when I requested the type, but did when it actually evaluated it)
21:11:06 <zerokarmaleft> er, I'm not familiar with defaulting
21:11:25 <geekosaur> as it's not used, it can be anything; this is expressed by a being a new type variable with no other use
21:12:06 <byorgey> zerokarmaleft: good question.  Type variables which are literally unused are replaced by a special type called Any
21:12:09 <byorgey> because it doesn't matter
21:12:47 <byorgey> that is, the choice can't affect the behavior of the program at all
21:13:16 <byorgey> in other cases (where the choice could affect the program behavior) you get an error about an ambiguous type variable.
21:13:29 <geekosaur> http://stackoverflow.com/questions/6165049/why-does-haskell-appear-to-default-to-reading-int-when-reading-num
21:14:30 <Nisstyre> zerokarmaleft: generic type variables (like a in that example) fall naturally out of the method Haskell uses to infer types
21:15:42 <geekosaur> http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-790004.3.4
21:15:58 <geekosaur> ^ the haskell language report on defaulting
21:16:31 <zerokarmaleft> byorgey, geekosaur, Nisstyre: hmm, makes sense...thanks for the links!
21:17:18 <geekosaur> basically it means you don't have to annotate every blipping number with a type
21:17:38 <geekosaur> (since numberic literals are polymorphic)
21:17:41 <geekosaur> *numeric
21:17:53 <Nisstyre> zerokarmaleft: before inferring the type of anything Haskell begins with one or more type variables, e.g. f a b = ... starts out with f :: t -> t1 -> t2
21:19:31 <Nisstyre> if one of them is left uninstantiated during inference, then it's going to be allowed to be any type
21:19:31 <zerokarmaleft> so what happens if the wrong type is defaulted?
21:20:48 <byorgey> zerokarmaleft: what do you mean "wrong"?
21:21:02 <geekosaur> you get a type error and have to either annotate with the right type, or more likely adjust what you're doing (can't use an Integral type with (/), for example; use div or apply fromIntegral (input) / ceiling / floor / etc. (result) as neede
21:21:13 <geekosaur> d)
21:21:20 <byorgey> it's not possible for defaulting to cause a type error, is it?
21:21:37 <cmccann> sort of?
21:21:50 <cmccann> I think you can get errors that basically amount to conflicting defaults
21:22:09 <cmccann> when you have constraints that can't be satisfied
21:22:34 <cmccann> can't remember a good example off the top of my head though
21:23:14 <zerokarmaleft> byorgey: well, I can't think of an example that would disambiguate the type anyway
21:30:05 <Saizan> i think you need a module boundary (or ghci) to get errors from defaulting
21:43:04 * hackagebot yesod-auth-oauth 1.2.0 - OAuth Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-oauth-1.2.0 (HiromiIshii)
22:02:27 <dav> Is there a good soul out there that could help me make sense out of this type error ? -> http://paste.debian.net/5104/
22:02:50 <benzrf> lookin dav
22:02:54 <benzrf> not an expert by any means tho
22:03:19 <dav> thanks benzrf
22:03:31 <benzrf> I think I see the issue
22:03:39 <benzrf> functoin application is left-associative
22:03:58 <benzrf> that means that opposite compare x is the same as ((opposite) compare) x)
22:04:17 <benzrf> (opposite compare) doesn't work because compare isn't the type opposite wants
22:04:32 <benzrf> try either 'opposite (compare x)' or 'opposite $ compare x'
22:04:42 <benzrf> wait
22:04:45 <benzrf> actually
22:04:57 <benzrf> since you're using partial application, try 'opposite . compare x'
22:05:17 <dav> good point
22:05:37 <benzrf> does it work now?
22:05:51 <dav> nope: http://paste.debian.net/5105/
22:06:04 <schell_> yeah - i think you're on the right track though
22:06:06 <schell_> do
22:06:10 <benzrf> notice '     The function `opposite' is applied to two arguments,'
22:06:16 <schell_> :t opposite . compare
22:06:18 <lambdabot> Not in scope: `opposite'
22:06:18 <dav> but  :t \x -> opposite . compare x
22:06:21 <dav> does work
22:06:21 <benzrf> that should be a red flag if you're only trying to pass it one
22:06:22 <dav> howw??
22:06:43 <benzrf> infix operators cannot be partially applied other than with sections
22:06:55 <benzrf> so 'opposite $ compare x' will try to evaluate
22:07:03 <benzrf> compare x is not the right type for opposite
22:07:11 <benzrf> instead, you want to compose compare x and opposite
22:07:33 <benzrf> if you really like your dollar sign, you *could* partially apply it using '(opposite $) compare x'
22:07:36 <benzrf> I think
22:08:33 <copumpkin> lol
22:08:37 * benzrf goes back to watching atla
22:09:48 <dav> I don't understand why I need to have an x in there at all?
22:09:56 <benzrf|afk> you don't
22:09:59 <dav> why isn't opposite . compare valid?
22:10:01 <benzrf|afk> you could do 100% point-free form
22:10:06 <benzrf|afk> isn't it?
22:10:14 <benzrf> did you try it?
22:10:21 <benzrf> show me what you're doing
22:10:28 <dav> no: http://paste.debian.net/5105/
22:11:26 <benzrf> what are the types of opposite and compare again?
22:11:39 <dav> *Main Data.List Data.List Data.Ord> :t compare
22:11:39 <dav> compare :: Ord a => a -> a -> GHC.Types.Ordering
22:11:39 <dav> *Main Data.List Data.List Data.Ord> :t opposite
22:11:40 <dav> opposite :: GHC.Types.Ordering -> GHC.Types.Ordering
22:11:52 <benzrf> hmmm]
22:12:05 <benzrf> oh, I see
22:12:08 <dav> I'm expecting opposite . compare to be of the same type signature as compare
22:12:27 <benzrf> the output of compare is (a -> Ordering), not ordering
22:12:35 <benzrf> you need to partially apply compare
22:12:46 <benzrf> sorry
22:13:13 <benzrf> there's probably a way around it, but that's the problem
22:13:24 <dav> thx I see the problem now
22:13:25 <benzrf> @type (.)
22:13:26 <lambdabot> (b -> c) -> (a -> b) -> a -> c
22:13:30 <benzrf> there you go
22:13:40 <benzrf> ok, gl :)
22:13:48 <benzrf|afk> (this time ferreal)
22:13:50 <dav> thanks ;-)
22:15:54 <NemesisD> given a lensed type like data Foo a = Foo { _bar :: a }, i thought the type changing properties of lenses would allow you to do: foo = Foo (); foo2 = foo & bar .~ "somethingelse"
22:15:59 <NemesisD> yet it doesn't seem to work
22:16:18 <edwardk> that works fine
22:16:29 <edwardk> > ("hello","world") & _2 .~ 23
22:16:30 <lambdabot>   ("hello",23)
22:16:54 <edwardk> do you only have that one field with the 'a' in it or are there others?
22:17:19 <NemesisD> hmm i'm getting couldn't match () with Unit when functional dependencies combine yadda yadda
22:17:21 <edwardk> if there are others you have a problem because you can't 'cross a chasm in two jumps'
22:17:22 <NemesisD> edwardk: there are other fields
22:17:32 <edwardk> NemesisD: do any of them mention the type 'a'?
22:17:36 <Demos> is there a way to mirror hackage such that cabal can install from my disk?
22:17:40 <dav> what's interesting is that 'oppositeCompoare x y = opposite $ compare x y' is valid but 'oppositeCompoare = opposite $ compare' isn't. I thought you could always remove the variables from the end of the expressions on both side of the = sign ?
22:17:43 <NemesisD> edwardk: nope
22:18:02 <edwardk> data Pair a = Pair { _foo, _bar :: a }   is a problem because you can't change the type of foo or bar without changing the other too
22:18:24 <NemesisD> data PaginatedRequest a = PaginatedRequest { _requestPagination :: PaginationOptions, _requestQuery :: a }, trying to write PaginatedRequest () -> PaginatedRequest Unit
22:19:03 <Saizan> dav: being at the end is not the right condition
22:19:15 <edwardk> dav: oppositeCompare x y = opposite $ compare x y ; oppositeCompare x = opposite . compare x;  oppositeCompare = (.) opposite . compare
22:19:51 <edwardk> NemesisD: that should work fine. is this with makeLenses or makeClassy?
22:20:21 <NemesisD> edwardk: makeClassy ''PaginatedRequest (don't mention a in that makeClassy call, not sure if that's a problem)
22:20:24 <edwardk> ah
22:20:30 <edwardk> makeLenses will work
22:20:36 <edwardk> makeClassy doesn't give you type changing lenses
22:21:04 <edwardk> there is an open issue to support them, its not 100% trivial to implement though
22:21:10 <dav> edwardk: that's interesting but it doesn't work:
22:21:16 <NemesisD> edwardk: ahh ok. the only reason why i'm using makeClassy is because makeLenses makes it more difficult to have an explicit export list in a module
22:21:22 <dav> *Main Data.List Data.List Data.Ord> :t oppositeCompare
22:21:22 <dav> oppositeCompare :: Ord a => a -> a -> Ordering
22:21:22 <dav> *Main Data.List Data.List Data.Ord> let oppositeCompare2 = (.) opposite . compare
22:21:25 <dav> oppositeCompare2 :: () -> () -> Ordering
22:21:34 <dav> I feel so handicapped being new to this :(
22:21:35 <Saizan> dav: the RHS needs to be a simple application of an expression to the variable for that to work, while in opposite $ compare x y the application of (compare x) to 'y' is nested inside $
22:21:53 <edwardk> @pl \x y -> opposite $ compare x y
22:21:53 <lambdabot> (opposite .) . compare
22:22:10 <edwardk> which is the same as (.) opposite . compare
22:22:14 <Saizan> dav: that's because of the MonomorphismRestriction, which forces definitions with no explicit arguments to not have typeclass contexts
22:22:32 <Saizan> dav: you can get aroud it with a type signature
22:22:36 <dav> edwardk: my bad, I should have done :t (.) opposite . compare
22:22:50 <Saizan> *around
22:23:15 <edwardk> NemesisD: sure. just explaining why type changing didn't work =)
22:23:31 <edwardk> NemesisD: the explicit export list is part of why makeClassy bundles all the lenses into the class =)
22:23:55 <dav> Saizan: could you explain what you mean by that last statement? How does a type signature change things?
22:24:25 <Saizan> dav: let oppositeCompare2 :: Ord a => a -> a -> Ordering; oppositeCompare2 = (.) opposite . compare -- that will work
22:24:45 <NemesisD> ah cool. thanks for clarifying. thankfully this type is pretty easy to manually export
22:24:58 <Saizan> dav: because the MonomorphismRestriction (MR) won't apply in that case, you've explicitly told the compiler you're fine with the polymorphism
22:25:22 <Saizan> dav: people often disable it entirely in ghci, :set -XNoMonomorphismRestriction
22:26:14 <edwardk> Saizan: on a sufficiently recent compiler, NMR is even the default
22:27:14 <dav> Saizan: I see I just got the -XNoMonomorphismRestriction error now. I can't see I'm on top of all this but at least I can see what you're talking about :)
22:28:40 <edwardk> (for ghci)
22:29:26 <dav> Saizan: so this is the same reason why "sort l = sortBy compare l" is fine but "sort = sortBy compare" isn't?
22:30:16 <dav> edwardk: I'm using The Glorious Glasgow Haskell Compilation System, version 7.6.2
22:37:03 <dav> So, is this the "best" way of implementing revSort? => http://paste.debian.net/5106/ -- I'm having a hardtime believing this isn't a one-liner..
22:44:12 <copumpkin> dav: nope
22:44:27 <Saizan> dav: sortBy (flip compare)
22:44:33 <copumpkin> :)
22:45:27 <Saizan> instead of mangling the Ordering you can just flip the order of the arguments
22:45:45 <mark-andrus> Followup to my hugs/cabal issue earlier: `ln -s ~/.cabal/lib ~/lib` will fix `cabal install ${pkg} --hugs --user`.
22:54:12 <_mike_> hello. why does map ($10) $ map (+) [1..4] work, but map (+) [1..4] and then after map ($ 10) it doesn't?
22:54:40 <_mike_> I am getting :    Couldn't match expected type `a0 -> b0' with actual type `Integer':
22:56:36 <dav> Saizan: lol :)
22:56:39 <dav> Saizan: thx
23:00:22 <Saizan> _mike_: show the actual code or log from ghci
23:09:12 <dav> good night all
23:19:56 <jkarni> any easy way to do something like iterateWhile?
23:21:26 <c_wraith> jkarni: what type signature do you want?
23:22:15 <jkarni> (a -> Bool) -> (a -> a) -> a -> [a]
23:22:56 <jkarni> but something like \x y z -> takeWhile x $ iterate y z wouldn't work
23:23:18 <c_wraith> it looks close.
23:23:22 <c_wraith> Why doesn't it work?
23:23:24 <jkarni> well, actually
23:23:29 <jkarni> it might
23:24:26 <jkarni> right now i head (iterate . (head . ) . suc)
23:24:34 <jkarni> where suc is a function a -> [a]
23:25:10 <jkarni> so I want to stop execution before head is called on an empty list (which it eventually will be)
23:25:37 <jkarni> so I can't do just takeWhile over (iterate . (head .) . suc)
23:25:56 <jkarni> the check has to happen before the iterate, right?
23:26:22 <c_wraith> well, is over just an alias for null?
23:26:28 <c_wraith> Or does it do something else?
23:26:47 <jkarni> sorry, over was just english
23:27:09 <jkarni> and poorly choosen english
23:27:12 <c_wraith> ok, then I'll re-ask in english..  Is your check for completion that the resulting list is empty, or is it more sophisticated?
23:28:09 <jkarni> I currently have no check, but I wanted it to be that the last element of the resulting list is the last one that's not empty
23:28:38 <jkarni> so I know this could be done recursively in a somewhat more verbose way
23:29:15 <c_wraith> There are a number of things you could do.
23:29:41 <c_wraith> hmm.
23:30:24 <c_wraith> This really is asking for a primitive like mapWhile :: (a -> Maybe b) -> [a] -> [b]
23:30:57 <jkarni> yeah
23:30:59 <c_wraith> Now I'm trying to figure out if that can be built easily from existing parts
23:32:01 <fosskers> I seem to be having some type woes.
23:33:10 <c_wraith> I'm not familiar with pieces that give the desired semantics. *shrug*. It's not too tough to write.
23:33:24 <c_wraith> but the nice thing about that is that you could pass it listToMaybe, and you'd be done
23:33:24 <fosskers> Let's say I have three effectual functions, which all return `f String` where `f` is some (Applicative) Functor
23:33:56 <djahandarie> :t \f -> catMaybes . takeWhile isJust . map f
23:33:57 <lambdabot> (a1 -> Maybe a) -> [a1] -> [a]
23:34:01 <fosskers> What's the best way to concat their results non-Monadically?
23:34:10 <c_wraith> djahandarie: yeah, I really didn't want to use isJust though.
23:34:13 <fosskers> f `mappend` g `mappend` h `mappend` ?
23:34:20 <fosskers> woops, one too many mappends there
23:34:36 <c_wraith> djahandarie: it's just wasting effort to use isJust and then later extract the value as a second pass.
23:35:10 <u_> is there a left-associative version of $!?
23:35:21 <u_> so i don't have to type out stuff like "(go xs $! (s+x)) $! (l+1)"
23:35:26 <johnw> `seq`?
23:35:27 <u_> when i just want to pass some arguments strictly
23:35:36 <u_> seq is heavy compared to $!
23:35:46 <lispy> bang pattern
23:35:48 <shachaf> u_: Alas, no.
23:35:48 <u_> i would have to do let a = blah in a `seq` f a
23:36:01 <u_> rats
23:36:06 <djahandarie> c_wraith, needs primitive recursion then.
23:36:15 <shachaf> ($!) should probably be the left-associative version of ($!).
23:36:24 <u_> you mean !$?
23:36:26 <c_wraith> yeah
23:36:32 <zRecursive> @src ($!)
23:36:32 <lambdabot> f $! x = x `seq` f x
23:36:40 <c_wraith> @ty let mapWhile _ [] = [] ; mapWhile f (x:xs) = maybe [] (:mapWhile f xs) $ f x in mapWhile
23:36:41 <lispy> Not !$? just !$, BTW, Who is on first?
23:36:42 <lambdabot> (t -> Maybe a) -> [t] -> [a]
23:36:50 <jkarni> wow, nice, @src gives the def?
23:37:00 <fosskers> yeah
23:37:03 <lispy> jkarni: not reliably, but for somet hings it does
23:37:05 <c_wraith> well, @src gives a possible definition, for a few things
23:37:21 <zRecursive> @src ($)
23:37:21 <lambdabot> f $ x = f x
23:37:43 <zRecursive> the difference is exiplicit
23:37:59 <zRecursive> between ($!) and ($)
23:38:37 <lispy> u_: anyway, it's likely that the syntatically simplest thing here is to put bangs on the last two parameters of go
23:39:47 <u_> lispy sometimes i want to give a function a strict argument, instead of have the function demand a strict argument
23:39:57 <u_> in this case not
23:39:59 <c_wraith> @ty let mapWhile _ [] = [] ; mapWhile f (x:xs) = maybe [] (:mapWhile f xs) $ f x in mapWhile listToMaybe
23:40:01 <lambdabot> [[a]] -> [a]
23:46:07 <fosskers> hey guys
23:46:17 <arkeet> @ty let mapWhile _ [] = [] ; mapWhile f (x:xs) = maybe [] (:mapWhile f xs) $ f x in mapWhile
23:46:18 <lambdabot> (t -> Maybe a) -> [t] -> [a]
23:46:38 <arkeet> :t let mapWhile f = catMaybes . map f in mapWhile
23:46:39 <lambdabot> (a1 -> Maybe a) -> [a1] -> [a]
23:46:45 <c_wraith> different semantics
23:46:47 <arkeet> true
23:46:58 <fosskers> a = return "1" >>= \x -> return "2" >>= \y -> return "3" >>= \z -> return (x++y++z)
23:47:06 <fosskers> How would one write this non-monadically?
23:47:27 <shachaf> I don't know what it means to write something non-monadically.
23:47:30 <c_wraith> "123"
23:47:38 <shachaf> But that's the same as return ("1"++"2"++"3")
23:47:39 <fosskers> Say, as an Applicative Functor instead
23:47:47 <shachaf> ?
23:47:50 <fosskers> The numbers are just examples
23:48:00 <shachaf> It sounds like you have a solution in search of a problem.
23:48:12 <fosskers> The idea is that there are multiple effectful functions.
23:48:26 <shachaf> What is your goal?
23:48:28 <fosskers> I want their inner String concated
23:48:37 <fosskers> Strings, rather
23:48:46 <jkarni> inner string?
23:49:23 <fosskers> In the example above, String could be in the context of any Monad
23:49:26 <c_wraith> fosskers: do you want something like (\x y z -> x ++ y ++ z) <$> f1 <*> f2 <*> f3
23:49:41 <c_wraith> That's my best guess of what you could mean
23:49:41 <fosskers> c_wraith: yes, but point free
23:49:52 <fosskers> forgive my bad explanation
23:49:53 <c_wraith> why does that matter?
23:49:57 <johnw> @pl \x y z -> x ++ y ++ z) <$> f1 <*> f2 <*> f3
23:49:58 <lambdabot> (line 1, column 22):
23:49:58 <lambdabot> unexpected ')'
23:49:59 <lambdabot> expecting letter or digit, variable, "(", operator, ":", "++", "<+>" or end of input
23:50:31 <c_wraith> :t liftA3
23:50:32 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
23:50:33 <arkeet> fosskers: what are you actually trying to accomplish?
23:50:33 <shachaf> There is no "inner String".
23:50:38 <c_wraith> hey, look, that is defined
23:50:41 <arkeet> you're not telling us something.
23:51:03 <ion> @type (<+>)
23:51:03 <c_wraith> :t liftA3 ((++) .: (++))
23:51:04 <lambdabot>     Ambiguous occurrence `<+>'
23:51:04 <lambdabot>     It could refer to either `Control.Arrow.<+>',
23:51:04 <lambdabot>                              imported from `Control.Arrow' at State/L.hs:5:1-20
23:51:04 <lambdabot>     Not in scope: `.:'
23:51:05 <lambdabot>     Perhaps you meant one of these:
23:51:06 <lambdabot>       `.' (imported from Prelude),
23:51:27 <c_wraith> oh, I got that all wrong anyway
23:51:31 <c_wraith> but whatever
23:51:34 <c_wraith> It's not an interesting question
23:51:37 <fosskers> shachaf: That was just terrible wording on my part.
23:51:38 <c_wraith> liftA3 exists
23:52:05 <c_wraith> Which reduces it to "make a lambda expression with 3 arguments point-free".  If being point-free actually mattered for anything
23:52:18 <arkeet> pointless
23:52:42 <shachaf> fmap concat . sequenceA $ [a,b,c]
23:52:50 <Jaxan> @pl \f1 f2 f3 -> (\x y z -> x ++ y ++ z) <$> f1 <*> f2 <*> f3
23:52:51 <lambdabot> (((((. (++)) . (.) . (++) <$>) .) . (<*>)) .) . (<*>)
23:52:59 <Jaxan> I like this feature :)
23:53:07 <johnw> lol
23:53:12 <fosskers> Basically, I just wanted the cleanest way to concat the results of three Parsers.
23:53:39 <johnw> @pl is sometimes more of a cryptographic algorithm than anything else
23:53:40 <lambdabot> (line 1, column 66):
23:53:40 <lambdabot> unexpected reserved word "else"
23:53:40 <lambdabot> expecting variable
23:53:50 <c_wraith> concat3Parsers = liftA3 (\x y z -> x ++ y ++ z)
23:53:52 <c_wraith> there you go
23:53:57 <c_wraith> reduced to a single name
23:54:35 <fosskers> c_wraith: yeah, that would do it
23:54:44 <arkeet> what if you want to concat 4 parsers?
23:54:46 <fosskers> The point-free looks ugly as hell.
23:54:58 <arkeet> @pl (\x y z -> x ++ y ++ z)
23:54:58 <lambdabot> (. (++)) . (.) . (++)
23:55:02 <arkeet> @pl (\x y z -> (x ++ y) ++ z)
23:55:02 <lambdabot> ((++) .) . (++)
23:55:07 <c_wraith> arkeet: then you should reconsider what it is you're actually doing. :)
23:55:12 <fosskers> Actually, I suppose that is the greater question.
23:55:15 <arkeet> c_wraith: :)
23:55:28 <arkeet> let's go with WriterT
23:55:31 <fosskers> How would you concat all the results of an arbitrary amount of Parsers?
23:55:31 <c_wraith> fosskers: and shachaf already answered it
23:55:40 <c_wraith> look at the last thing shachaf said
23:55:51 <arkeet> that's better
23:55:58 <arkeet> better to take a list of parsers
23:56:09 <arkeet> @pl fmap concat . sequenceA
23:56:09 <lambdabot> fmap join . sequenceA
23:56:12 <arkeet> oops
23:56:13 <fosskers> Ah, alright.
23:56:14 <arkeet> @ty fmap concat . sequenceA
23:56:15 <c_wraith> haha
23:56:16 <lambdabot>     Not in scope: `sequenceA'
23:56:16 <lambdabot>     Perhaps you meant one of these:
23:56:16 <lambdabot>       `Data.Traversable.sequenceA' (imported from Data.Traversable),
23:56:18 <fosskers> I missed it up there.
23:56:19 <arkeet> @ty fmap concat . Data.Traversable.sequenceA
23:56:21 <lambdabot> Applicative f => [f [a]] -> f [a]
23:57:27 <fosskers> thanks guys
23:57:37 <fosskers> I'll play around with sequenceA
23:58:39 <johnw> it turns your [Parser a] into Parser [a], and fmap concat turns that into Parser a
23:59:08 <fosskers> yeah
23:59:39 <shachaf> joneshf-laptop: ...When a = [b], anyway.
23:59:50 <shachaf> That was meant for johnw.
23:59:52 <joneshf-laptop> shachaf: clearly
23:59:56 <joneshf-laptop> ;)
