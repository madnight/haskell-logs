00:12:18 <Aetherspawn> Anyone know how to get f out of IO? http://hpaste.org/88997
00:12:50 <Aetherspawn> I declared "instance FromJSON Properties where" but it wants instance IO Properties FromJSON... :(
00:13:43 <hcaulfield57> Why doesn't the following function work? http://hpaste.org/88998
00:14:06 <Aetherspawn> Your type is wrong
00:14:23 <Aetherspawn> :t (Just x
00:14:24 <Aetherspawn> )
00:14:24 <lambdabot> parse error (possibly incorrect indentation)
00:14:28 <Aetherspawn> :t (Just x)
00:14:29 <lambdabot> Maybe Expr
00:14:47 <Aetherspawn> :t (\x -> Just x)
00:14:48 <lambdabot> a -> Maybe a
00:15:01 <llkkk> What is meant by an 'overloaded function'?
00:15:20 <hcaulfield57> Aetherspawn: can't 'b' just be an abritrary type though?
00:15:44 <Aetherspawn> I dont think so
00:15:50 <Aetherspawn> I think you can use typeclass conversion stuff though
00:16:08 <Aetherspawn> like, f x = fromIntegral x
00:16:17 <Aetherspawn> f :: (Num a, Num b) => a -> b
00:16:19 <Aetherspawn> or something like that
00:16:25 <Aetherspawn> (I'm a noob, sorry)
00:18:04 <hcaulfield57> Aetherspawn: Yea me too :), I figured 'b' could take any type, so Maybe Whatever would work
00:19:26 <hcaulfield57> In this case, making it "f :: a -> Maybe a" fixes it, but that doesn't really answer my question I suppose.
00:21:34 <johnw> hcaulfield57: can you phrase the question a bit more exactly?
00:22:28 <hcaulfield57> johnw: Why can't I do something like "f :: a -> b" "f x = "Hello""
00:22:41 <hcaulfield57> Can't the type variable 'b' just be an abritrary type?
00:22:53 <haasn> ‘b’ doesn't mean you can insert any type when writing the function, it means you can insert any type when /calling/ the function
00:22:53 <johnw> it means *every* arbitrary type
00:23:01 <haasn> so I could, if I wanted to, use your :: a -> b function to convert Int to String
00:23:05 <johnw> it also means that your function can't know the type
00:23:14 <johnw> there are only two ways to implement a function typed a -> b
00:23:24 <johnw> one is f x = undefined
00:23:31 <johnw> there other is f x = unsafeCoerce x
00:23:37 <applicative> llkkk: any expression can be 'overloaded'
00:23:50 <johnw> because given the type a -> b, your f by definition does not know *anything* about a, or about b
00:23:56 <haasn> unsafeCoerce is very unsafe, though
00:24:00 <hcaulfield57> So type variables are only good insofar as calling a function, not necessarily returning.
00:24:01 <haasn> so you don't want to be using it
00:24:09 <johnw> right, you don't want anything to do with either definition
00:24:13 <applicative> llkkk in general it just means the expression can be used in different senses
00:24:23 <johnw> hcaulfield57: that's not so
00:24:30 <haasn> johnw: also isn't f = undefined technically different from f x = undefined?
00:24:32 <johnw> take for example: f :: (a -> b) -> [a] -> [b]
00:24:35 <haasn> I keep forgetting these things
00:24:39 <johnw> that uses type variables quite meaningfully
00:24:54 <hcaulfield57> But the compiler needs to know those values, it can't guess like in the example I provided.
00:25:09 <hcaulfield57> Which it would be provided with in your exmaple johnw
00:25:23 <applicative> llkkk its just an ugly computer-people word for things otherwise expressed in actual english
00:25:24 <johnw> hcaulfield57: needs to know which values?
00:25:24 <haasn> the compiler can infer the type in most cases
00:25:43 <haasn> but that's not much different from you supplying it
00:26:03 <hcaulfield57> The type variables, if you use "f :: (a -> b) -> [a] -> [b]", it knows the type of a and b
00:26:15 <johnw> the definition won't
00:26:21 <johnw> they will be inferred at the point where it is used
00:26:25 <hcaulfield57> Right
00:26:37 <johnw> so, the use of type variables in this way restricts what the function can do
00:26:40 <johnw> that can be a very good thing
00:26:55 <hcaulfield57> But in my example "f :: a -> b", it can't possibly know what 'b' is, so it doesn't work?
00:27:17 <johnw> right, how is your function going to "manufacture" a value of any arbitrary type?
00:27:18 <Ralith> hcaulfield57: a free type variable is not a *specific* type; it is, potentially, *any* type.
00:27:21 <johnw> it doesn't know what the constructors are!
00:27:31 <haasn> if I'm writing a function that is polymorphic (that has a type variable in its type), I have to make sure my function works for /all/ types, which basically means I can't do anything with the polymorphic values I'm operating on
00:27:48 <johnw> haasn: right
00:27:51 <Ralith> hcaulfield57: you are saying "for any types at all a and b, this function takes an a and return s ab"
00:27:58 <Ralith> returns a b"*
00:28:03 <haasn> (unless I add a type-class constraint, like (+) :: Num a => a -> a -> a; which works for all types ‘a’ provided they implement the methods contained in ‘Num’)
00:28:04 <Nisstyre> haasn: you can use other polymorphic functions on them
00:28:10 <johnw> in fact, this restriction on arbitrary types is so powerful, you can derive theorems for free just from the type alone
00:28:41 <Nisstyre> haasn: yeah it's best to think of type class constraints as set membership for types
00:29:06 <hcaulfield57> Okay, I think I understand better, thanks guys.
00:29:49 <Nisstyre> @type (\a -> undefined)
00:29:51 <lambdabot> t -> a
00:30:42 <haasn> ‘a -> something that doesn't involve a’, for example, can only be a ‘const’ function (excluding unsafeCoerce which you shouldn't really consider a part of Haskell for this)
00:31:07 <arkeet> @free a -> b
00:31:08 <lambdabot> Extra stuff at end of line
00:31:10 <arkeet> @free f :: a -> b
00:31:11 <lambdabot> h . f = f . g
00:31:32 <johnw> it can't be a const function either, haasn
00:31:39 <johnw> then you'd know something about the return type
00:31:41 <arkeet> it can be const undefined
00:31:46 <johnw> yes, it can be that
00:31:58 <haasn> :t const "foo"
00:31:59 <lambdabot> b -> [Char]
00:32:16 <arkeet> that's not polymorphic in the return type
00:32:30 <arkeet> @free f :: b -> [Char]
00:32:31 <lambdabot> $map $id . f = f . g
00:32:35 <haasn> I never included that constraint in my statement
00:32:36 <arkeet> lol
00:32:47 <arkeet> that's basically f = f . g
00:33:02 <arkeet> which implies f can't tell anything about its input
00:33:09 <haasn> yeah
00:33:38 <haasn> I wonder if $map $id should be cleaned from @free's output :)
00:33:51 <hcaulfield57> Oh, and since 'f :: a -> b', 'f x = "Hello"', "Hello" cannot be every type in the case of b, it doesn't work.
00:34:00 <haasn> yes
00:34:11 <johnw> you've got it!
00:34:14 <haasn> but ‘f :: a -> String’ would work, and is what GHC would infer
00:34:22 <hcaulfield57> Great I definitely have it now, thanks everyone.
00:34:27 <arkeet> in the earlier "h . f = f . g", it also means that f can't produce any information in its output.
00:34:32 <arkeet> probably assuming h is strict
00:34:48 <Aetherspawn> okay I'm really stuck on this one, I would really appreciate someone give me a little nudge: http://hpaste.org/89002 :)
00:35:22 <hcaulfield57> #haskell is always helpful :)
00:35:44 <Aetherspawn> ;\ I wrote my cry for help right before the huge netsplit
00:35:46 <Nisstyre> hcaulfield57: Foo a => b -> a is valid though
00:35:56 <haasn> missing ‘return’?
00:36:03 <haasn> Aetherspawn ^
00:36:07 <johnw> Aetherspawn: you're returning x directly
00:36:07 <haasn> n line 4
00:36:10 <Nisstyre> since a will be specified somewhere
00:36:20 <johnw> you need return $ fromMaybe warn x
00:36:21 <Aetherspawn> Ohh, sec
00:36:24 <haasn> or
00:36:34 <haasn> loadC f = fromMaybe warn <$> decodeFile f
00:36:40 <johnw> Aetherspawn: an easier way to write that is... what haasn just wrote :)
00:36:41 <haasn> loadC = fmap (fromMaybe warn) . decodeFile
00:36:50 <gaze__> hey guys! How mature are type level naturals?
00:36:51 <hcaulfield57> As long as 'a' is within the Foo class though
00:36:51 <haasn> point-free bonus points
00:36:57 <gaze__> would you use them for a big project?
00:36:58 <hcaulfield57> ?
00:37:00 <Nisstyre> hcaulfield57: yes as long as it is an instance
00:37:08 <hcaulfield57> Right, okay, thanks Nisstyre
00:37:32 <Aetherspawn> building, thanks for helping :)
00:37:35 <haasn> gaze__: you can't do an awful lot with them yet
00:37:43 <haasn> gaze__: right now they're nothing more than pretty labels
00:37:46 <hcaulfield57> Is reading the Haskell Report worth it for understanding the nitty gritty details of the language?
00:38:02 <gaze__> haasn: So the thing to do is to define peano numbers?
00:38:02 <Nisstyre> hcaulfield57: not until you understand a lot of other stuff really
00:38:07 <haasn> so in that context, I guess you could use them for a big project, but be wary that they're subject to lots of change still
00:38:15 <Nisstyre> hcaulfield57: it's written for people who already understand the topics more or less
00:38:17 <haasn> gaze__: right now, that's pretty much the only choice you have, yeah
00:38:39 <gaze__> derp.
00:38:41 <hcaulfield57> Nisstyre: Okay
00:38:50 <Nisstyre> hcaulfield57: but if you're into reading language specs go right ahead
00:38:53 <Nisstyre> don't let me stop you
00:38:57 <haasn> gaze__: some GHC branch has a solver for them, but last time I checked (a few months ago) it wasn't complete
00:39:04 <Nisstyre> there are certainly some helpful tidbits in there
00:39:15 <hcaulfield57> Nisstyre: I might just use it as a jumping off point, if I can't understand something, research more.
00:39:34 <haasn> which would allow you to solve certain forms of type constraints involving natural numbers, plus a hard-coded injective type-class to pattern match on them like peanos
00:39:41 <haasn> type family*
00:39:47 <Nisstyre> hcaulfield57: I recommend the book PLAI (PL: Application and Interpretation)
00:39:57 <Nisstyre> it goes over some of the concepts that Haskell has like type inference
00:40:09 <Nisstyre> it's free to read online too
00:40:28 <haasn> hcaulfield57: I assume you've gone through LYAH already?
00:40:46 <hcaulfield57> Just noticed, it's a haskell only book?
00:41:01 <ski> @where LYAH
00:41:01 <lambdabot> http://www.learnyouahaskell.com/
00:41:02 <hcaulfield57> err no
00:41:10 <haasn> then you might want to check that out
00:41:18 <johnw> sometimes I think that a good way to learn Haskell is to learn Agda.  It's like swinging a training bat: when you afterwards go to step up to the plate, the real things feels strangely light and easy
00:41:31 <haasn> some people like it, some people don't, but lots of people in here started that way, including myself
00:41:35 <Aetherspawn> Now I think warn is the wrong type. It's returning IO b0, even though I'm using a return?
00:41:47 <haasn> johnw: hehe
00:41:51 <hcaulfield57> haasn: Most of LYAH, parts of RWH and some other tutorials
00:41:56 <johnw> Aetherspawn: right
00:41:58 <Nisstyre> johnw: my next big book is going to be http://www.cis.upenn.edu/~bcpierce/sf/
00:42:00 <haasn> johnw: why agda, in particlar? what about eg. idris, which I believe is closer to HAskell?
00:42:00 <hcaulfield57> Kind of sick of those at the moment though
00:42:03 <Aetherspawn> Sec, I'll paste it.
00:42:17 <johnw> Aetherspawn: maybe warn return x
00:42:19 <johnw> that's what you need
00:42:28 <johnw> haasn: Idris is good too
00:42:40 <johnw> Nisstyre: nice!  That's such a fun book to work through
00:43:04 <johnw> i'm on chapter 6 myself; the only problem with it is that it became too addictive, and I was losing sleep!
00:43:17 <Nisstyre> johnw: nice, sounds fun then
00:43:24 * hackagebot HLearn-algebra 1.0.1 - Algebraic foundation for homomorphic learning  http://hackage.haskell.org/package/HLearn-algebra-1.0.1 (MikeIzbicki)
00:43:26 * hackagebot HLearn-algebra 1.0.1.1 - Algebraic foundation for homomorphic learning  http://hackage.haskell.org/package/HLearn-algebra-1.0.1.1 (MikeIzbicki)
00:43:33 <ski> @where SF
00:43:33 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages",
00:43:33 <Nisstyre> I also have "Mathematical Logic" by Stephen Kleene, but that book is insane
00:43:34 <lambdabot> "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof assistant."
00:43:49 <johnw> I just started Pierce's Types and Programming Languages
00:43:49 <ski> Nisstyre : hehe
00:43:54 <haasn> oh, didn't see that his ‘warn’ was in IO as well
00:43:58 <ski> TaPL is nice
00:44:00 <haasn> yeah what johnw said
00:44:14 <johnw> haasn: I missed that too
00:44:32 <johnw> i just wish now that prooftree had idris support
00:44:41 <johnw> i mean, Proof General
00:45:01 <johnw> (prooftree is something I use with Proof General)
00:45:02 <haasn> does idris require the ability to type out lots and lots of unicode characters in the way agda does?
00:45:13 <johnw> haasn: the tutorial uses almost none of them
00:47:29 <Aetherspawn> johnw, can you add brackets to "maybe warn return x" so I can understand better
00:47:33 <Aetherspawn> please :)
00:47:48 <johnw> brackets?
00:47:56 <johnw> :t maybe
00:47:57 <lambdabot> b -> (a -> b) -> Maybe a -> b
00:48:08 <Aetherspawn> did you mean maybe warn (return x) ?
00:48:13 <supki> (maybe warn return x)
00:48:21 <johnw> no, it's really maybe warn return x
00:48:26 <blackdog> (maybe) (warn) (return) (x)
00:48:35 <johnw> call warn if it's Nothing, call return with y if x is Juts y
00:48:37 <blackdog> bracket isolationism at its finest
00:48:46 <ski> ((((maybe) (warn)) (return)) (x))
00:48:50 <haasn> ((((maybe) warn) return) x)
00:48:53 <Aetherspawn> Oh, sorry, I misunderstood
00:48:53 <johnw> ski: perfect
00:48:58 <Aetherspawn> lol
00:49:05 <haasn> ah, ski outdid me :(
00:49:18 <Nisstyre> blackdog: I don't think there's a better way to do it and keep the lack of parentheses overall
00:49:20 <johnw> s/call/evaluate
00:50:01 * Aetherspawn lets out a great sigh of relief
00:50:09 <ski> @type ?warn `maybe` return
00:50:11 <Aetherspawn> Thanks alot :) decodeFile f >>= \x -> maybe warn return x works perfectly
00:50:11 <lambdabot> (?warn::m a, Monad m) => Maybe a -> m a
00:50:25 <haasn> the \x -> ... x is superfluous
00:50:28 <johnw> fmap (maybe warn return) . decodeFile
00:50:36 <ski> Aetherspawn : or `maybe warn return =<< decodeFile f'
00:50:47 <johnw> oh, that won't work
00:50:48 <johnw> ski is right
00:50:58 <johnw> maybe warn return <=< decodeFile
00:51:17 <haasn> what johnw said
00:55:47 <Aetherspawn> @pl return $ fromJust $ decode ""
00:55:47 <lambdabot> return (fromJust (decode []))
00:55:59 <johnw> really, don't ever use fromJust
00:56:13 <Aetherspawn> It's in a function where if the fromJust fails I can't do anything
00:56:34 <Aetherspawn> so it's like the user has demented the server so hard there's nothing useful I can do :\
00:56:51 <Aetherspawn> I guess I could sprout an error saying they need to give the server write privs..
00:56:55 <johnw> well, you are going to do something: you're going to throw an exception
00:57:08 <Aetherspawn> I guess I'll throw a useful one then :)
00:57:10 <johnw> yes, a more meaningful exception even would be better
00:59:10 <ski> Aetherspawn : better to use `fromMaybe (error "server panic : frobozz fubared")' then
00:59:45 <shachaf> Also possible sometimes: Instead of let x = fromJust ..., use let Just x = ...
00:59:58 <ski> (or, throwing an exception, if in `IO')
01:00:15 <johnw> isn't error just throwing an exception ala userError?
01:00:21 <haasn> shachaf: when that pattern match fails, the runtime error will contain the source location, won't it?
01:00:22 <tdammers> shachaf: I always wondered... what is the advantage of let Just x = m over let x = fromJust m?
01:00:45 <shachaf> tdammers: What haasn said.
01:00:56 <tdammers> hmm, yeah. read that too late
01:01:15 <Jookia> Is it possible to accomplish something like this: http://sprunge.us/CcPM ? It doesn't compile but I'm a newbie
01:01:44 <Nisstyre> Jookia: yes but your function has the wrong type
01:01:47 <haasn> Jookia: I have no idea what you're trying to accomplish
01:01:54 <shachaf> Jookia: "doesn't compile" is not very useful to people trying to help you learn. :-)
01:02:27 <Jookia> I'm trying to make a function that takes a function call and adds one to the first parameter and returns the new call. Kinda like wrapping it
01:02:30 <shachaf> You should generally specify: * what you did; * what you expected (and maybe why); * what happened
01:02:36 <haasn> like uh
01:02:41 <haasn> (.) (+1) -- ?
01:02:46 <shachaf> (:) is for lists. How did (:) get involved?
01:02:51 <haasn> or other way round
01:03:02 <Jookia> shachaf: I don't understand pattern matching outside of lists
01:03:34 <shachaf> But this isn't a list. :-)
01:03:36 <johnw> haasn: and it's a two argument function, so he'd need: replaceFirst (f:fs) = (f .) . (+1) : replaceFirst fs
01:04:02 <johnw> and replaceFirst [] = []
01:04:12 <johnw> oh, wait
01:04:15 <johnw> he's not even receiving a function
01:04:20 <shachaf> johnw: Double no.
01:04:28 <johnw> Jookia: you can't pattern match apart the argument to a function like that
01:04:40 <johnw> replaceFirst f = (f .) . (+1)
01:04:43 <johnw> I think that's what you meant
01:04:49 <shachaf> Single no.
01:05:04 <Jookia> This is all very confusing but interesting
01:05:16 <shachaf> (I really wish you'd stop spreading the (f .) . g thing for people who don't even know how (.) works at all.)
01:05:17 <haasn> mostly unrelated: is there some lensy thing for contravariant functor-like things?
01:05:23 <shachaf> (That was a bit rude.)
01:05:38 <johnw> you want to turn a function Int -> Int -> IO () into a function that's the same, except it's first argument is incremented by 1, right?
01:05:59 <Jookia> johnw: Correct. It's kind of 'hijacking' it.
01:06:04 <haasn> foo originalFunc x y = originalFunc (x+1) y
01:06:07 <johnw> that definition I just gave does exactly that
01:06:16 <johnw> or haasn's much clearer example
01:06:23 <shachaf> > let f x y = (x,y) in (f . (+1)) 5 10
01:06:25 <lambdabot>   (6,10)
01:06:28 <shachaf> > let f x y = (x,y) in ((f .) . (+1)) 5 10
01:06:30 <lambdabot>   *Exception: show: No overloading for function
01:06:32 <johnw> thanks haasn, pointless syntax had me in a swoon
01:06:34 <shachaf> (That's the other no.)
01:06:42 <Finnfinn> Good mornin'
01:06:57 <adnap> Can someone explain what "ghc -x" does? man just says "Override default behaviour for source files"
01:07:10 <haasn> > let f = flip (.) (+1) in f (,) 5 10
01:07:12 <lambdabot>   (6,10)
01:07:45 <Jookia> haasn'
01:07:48 <Jookia> woops
01:08:03 <johnw> Finnfinn: hi
01:08:24 <Jookia> haasn's example makes the most sense to me, I didn't know types were being curried like that. However, I'm interested in how the composition example works.
01:08:38 <shachaf> adnap: The GHC User's Guide says more.
01:08:43 <haasn> foo f x y = f (x+1) y
01:08:47 <haasn> foo f x = f (x+1)
01:08:58 <haasn> foo f x = f ((+1) x)
01:09:05 <haasn> foo f = f . (+1)
01:09:12 <haasn> remember (f . g) x = f (g x)
01:09:12 <Nisstyre> Jookia: think of a -> a -> a as ((->) ((->) a a) a)
01:09:30 <quchen> ^ I'm sure that's helpful.
01:09:53 <haasn> then for the extra step I added: foo f = (.) f (+1); foo f = flip (.) (+1) f; foo = flip (.) (+1)
01:10:12 <haasn> any steps that are unclear?
01:10:22 <adnap> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/modes.html#overriding-suffixes
01:10:24 <johnw> ah, my (f .) was just wrong
01:10:31 <shachaf> johnw: Evidence for my "(f .) . g is too complicated" claim is that you got it wrong. :-)
01:10:41 <Jookia> Uhh, I'm still working it out. I come from C++ land where this isn't normal
01:10:56 <Jookia> Nisstyre: How does that help exactly?
01:11:06 <shachaf> ((f .) . g) x y = f (g x y)
01:11:08 <Nisstyre> Jookia: because functions only have a single parameter
01:11:35 <haasn> (f .) . g) = f .: g
01:11:53 <Jookia> Nisstyre: Oh I know that, but, oh I didn't see the ellipses properly
01:12:01 <haasn> Nisstyre: then it might have helped to instead think of it as a -> (a -> a) instead of the confusing prefix notation :)
01:12:10 <Jookia> The prefix notation got me off guard
01:12:12 <shachaf> haasn++
01:12:27 <shachaf> The only helpful person in here, apparently.
01:12:31 <Jookia> Haha
01:12:34 <Nisstyre> > uncurry ((+1) <$>) $ 1 0
01:12:35 <lambdabot>   2
01:13:08 <Nisstyre> yay for impenetrable code
01:13:23 <shachaf> No, not yay for being unhelpful when someone is actually trying to understand something.
01:13:25 <haasn> > fmap (+1) (3, 4) -- wrong parameter?
01:13:26 <lambdabot>   (3,5)
01:13:29 <Jookia> Ohh, the composition operator and +1 makes sense
01:14:24 <haasn> > 1 0 -- I didn't realize this was still here
01:14:25 <lambdabot>   1
01:14:53 <Jookia> Right now I'm pretty much hijacking my Setup.hs to add custom Cabal stuff, based on existing commands
01:14:59 <haasn> I just realized what was actually happening in Nisstyre's code
01:15:02 <Nisstyre> haha
01:15:04 <haasn> > 1 :: (Int -> Int, Int)
01:15:05 <lambdabot>   (*Exception: showsPrec: No overloading for function
01:15:59 <adnap> I don't understand ((f .) . g) x y = f (g x y)
01:16:21 <adnap> I know . is something like (a -> b) -> (b -> c) -> (a -> c)
01:16:29 <haasn> ((f .) . g) x y = (f .) (g x) y = (f . g x) y = f (g x y)
01:16:36 <Jookia> yes that makes sense
01:16:37 <adnap> so f . is (b -> c) -> (a -> c)
01:16:45 <shachaf> It's something like that, but it's not that.
01:17:01 <Jookia> i understand all of that i am not bleeding out of my ears
01:17:04 <shachaf> So start by looking at what it is. :-) Although in this case looking at the definition is more helpful than looking at the type.
01:17:14 <shachaf> Jookia: Hooray!
01:17:25 <Jookia> i imagine this is like proving code
01:17:37 <haasn> reducing, rather
01:17:41 <haasn> but proving follows similar principles
01:17:47 <Jookia> code golf as well
01:17:50 <adnap> I don't understand ((f .) . g) x y = (f .) (g x) y = (f . g x) y = f (g x y) either
01:17:55 <haasn> applying lots of symmetries in order to transform one expression into another, for example
01:18:38 <haasn> essentially, I've proved that ‘foo f x y = f (x+1) y’ and ‘foo = flip (.) (+1)’ are identical
01:18:56 <Jookia> haasn: ... uh-huh
01:19:13 <johnw> @pl \f x y = f (x+1) y
01:19:13 <lambdabot> (line 1, column 8):
01:19:13 <lambdabot> unexpected "="
01:19:13 <lambdabot> expecting pattern or "->"
01:19:17 <haasn> it is a good skill to have simply because sometimes, code can be made a lot clearer by reducing it to something simpler
01:19:18 <johnw> @pl \f x y -> f (x+1) y
01:19:18 <lambdabot> (. (1 +))
01:19:19 <haasn> though you can go overboard
01:19:24 <shachaf> Jookia: Important thing to know: When I say "blah = blue", that means that any time you see "blah", you can replace it with "blue".
01:19:29 <haasn> personally I wouldn't write the flip (.) (+1) in actual code
01:19:29 <adnap> I think I understand ((f .) . g) x y = (f .) (g x) y = (f . g x) y = f (g x y) now
01:19:36 <Finnfinn> haasn: Yet, one could argue if that's a valid proof.
01:19:36 <Jookia> shachaf: I figured.
01:19:39 <shachaf> So if I say "foo x = x + 1", that means that if you see "foo 5", you can replace it with "5 + 1"
01:19:55 <haasn> Finnfinn: well, I certainly ignored ⊥
01:19:57 <shachaf> All functions work this way. This is what evaluating a program is. Doing that a lot.
01:20:04 <johnw> adnap: yep, (f .) . g is composing f with the function returned by applying g to its argument
01:20:33 <Finnfinn> haasn: Mathematical proving, ho! :3
01:20:37 <Jookia> ⊥ ?
01:20:43 <adnap> johnw: Ah, that makes sense. Surprisingly, the English explanation is the most clear
01:20:57 <Jookia> Ah
01:20:58 <adnap> Whoa
01:20:59 <haasn> Jookia: undefined; either as a runtime error (think ‘error "foo"’) or as an infinite loop, think “foo = foo”
01:21:06 <adnap> Netsplit?
01:21:13 <haasn> the technical term for ⊥ is bottom
01:21:18 <Jookia> haasn: I just read the wiki page. I was expecting horrible maths that I'm no good at but the page makes sense
01:21:24 <Jookia> Well, the Haskell wiki page
01:21:35 <haasn> okay time for me to hold my presentation and hopefully win this competition
01:21:41 <adnap> 17 people just joined the channel on my end
01:21:49 <adnap> all at once
01:21:54 <Jookia> adnap: Same.
01:22:12 <Kinjen> Hello all. I am haskell beginner. where do i start?
01:22:18 <johnw> @where lyah
01:22:18 <adnap> Is that the aftermath of a netsplit?
01:22:18 <lambdabot> http://www.learnyouahaskell.com/
01:22:28 <Jookia> adnap: ¯\_(ツ)_/¯
01:22:28 <adnap> Also, A Gentle Introduction to Haskell
01:22:31 <haasn> adnap: there was one earlier
01:22:35 <Finnfinn> haasn: Uhm... ⊥ is "bottom", or in other words false.
01:22:52 <shachaf> Finnfinn; No, not false.
01:22:52 <adnap> It's not that Gentle after the first few chapters though
01:23:18 <dpwright_> I liked "learn haskell fast and hard"
01:23:27 <johnw> Finnfinn: _|_ is not false
01:23:36 <adnap> Is that the one targeted to web programmers?
01:23:38 <dpwright_> I'm a beginner too, though, so can't comment on its merits or faults
01:23:38 <shachaf> Finnfinn: ⊥-meaning-False and ⊥-meaning-bottom are sort of unrelated.
01:23:44 <adnap> With bad English?
01:23:45 <shachaf> Well, they're both the bottom of some semilattice. :-)
01:23:48 <adnap> And... Neo?
01:23:49 <haasn> ⊥ is false in the context of boolean algebras
01:23:55 <johnw> ah, ok
01:23:58 <bz> hi all. i am haskell intermediate. where do i start?
01:23:59 <haasn> it's an overloaded symbo
01:24:01 <haasn> l
01:24:14 <haasn> bz: have you checked out the typeclassopedia?
01:24:23 <dpwright_> erm, there is the odd english mistake, it wasn't horrible though
01:24:32 <bz> haasn: you mean hoogle? i use that a lot when coding
01:24:37 <Kinjen> thanks, anyoune doing web programming with hask?
01:24:39 <adnap> bz: Do you understand Functors, Applicatives, and Monads?
01:24:39 <dpwright_> and I don't know who it's targetted too.  I'm not a web programmer though
01:24:41 <haasn> no, it's a short text
01:24:46 <haasn> @where typeclassopedia
01:24:46 <adnap> Kinjen: I learned Yesod
01:24:46 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
01:24:54 <shachaf> @where web -- there's a channel for it.
01:24:54 <lambdabot> #haskell-web | #happs - http://happstack.com/ | #snapframework - http://snapframework.com/ | #yesod - http://yesodweb.com/
01:24:56 <Finnfinn> haasn: Yep. Which is one of the reasons why I dislike using it for undefined, it can be confusing.
01:24:59 <bz> adnap: yes, no, no
01:25:08 <adnap> bz: I would read LYAH then
01:25:10 <bz> lambdabot: thanks
01:25:17 <adnap> bz: To understand Applicatives and Monads
01:25:25 <shachaf> Finnfinn: In Haskell, ⊥ always means bottom, the value.
01:25:30 <quchen> ⊥ isn't very "overloaded" in Haskell.
01:25:31 <shachaf> (Unless your author is being weird.)
01:25:33 <bz> panda: thanks
01:25:42 <Finnfinn> Oh boy, monads... just. Monads.
01:25:46 <haasn> yeah ⊥ is used often in haskell
01:25:50 <haasn> might as well get used to it
01:25:51 <Jookia> Monads are scary
01:25:59 <adnap> Why do people always say that?
01:26:01 <haasn> monads are easy (but not as easy as monoids ;)
01:26:07 <haasn> don't think of them as scary
01:26:07 <Jookia> Because they're like the pointers of Haskell
01:26:09 <haasn> it's just a silly name
01:26:16 <adnap> wtf
01:26:47 <adnap> Just pay close attention to type signatures of the monad operators
01:26:51 <adnap> :t (>>=)
01:26:53 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:27:00 <adnap> :t return
01:27:01 <lambdabot> Monad m => a -> m a
01:27:10 <adnap> :t join
01:27:11 <lambdabot> Monad m => m (m a) -> m a
01:27:16 <haasn> I would go through LYAH or the typeclassopedia to understand Monads
01:27:23 <Finnfinn> Monads are complicated to understand. The concept, that is. Once you got that down it's all good.
01:27:24 <adnap> Not that scary
01:27:25 <haasn> don't fall for the ‘monad tutorials’ ;)
01:27:32 <haasn> Finnfinn: I don't think so
01:27:43 <haasn> the purpose is harder to understand than the concept, at first
01:27:46 <haasn> until you work through some examples
01:28:10 <adnap> I don't think I understand monads in every case. Every one behaves differently, but I understand the laws
01:28:29 <Jookia> Yeah, the purpose makes me a little puzzled.
01:28:30 <adnap> And how they work with some monads, like IO and Maybe
01:28:40 * mjrosenb figured out monads by writing a monad implementation for some datastructures.
01:28:46 <adnap> and LYAH taught me a few more that I never use
01:28:48 <Jookia> I know that using monads with Maybe can be good for error handling?
01:28:55 <adnap> No
01:28:58 <adnap> That's Either
01:29:13 <adnap> Well...
01:29:19 <johnw> Maybe can be used for error handling, if you don't care what the error was
01:29:20 <Jookia> Well, not error error handling
01:29:21 <adnap> Maybe is for when you might not get a result
01:29:22 <Finnfinn> haasn: Now that's a matter of opinion. At university though... well, not a good example. My comrades didn't really want to understand/learn Haskell. Half of them were just complaining about how it's nothing like what they usually do.
01:29:26 <Jookia> more like 'DID IT WORK' error handling
01:29:29 <mjrosenb> well, for handling errors, Maybe will work.  if you want to do anything past say "there was an error", then Either is useful.
01:29:32 <adnap> Like, querying a map
01:29:52 <adnap> :t lookup
01:29:53 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
01:30:00 <adnap> :t Data.Map.lookup
01:30:01 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
01:30:33 <adnap> If the key isn't in the map, you get Nothing. Otherwise, you just Just a
01:30:53 <quchen> Understanding individual monad instances is fairly easy, but they feel very different. Once you've used a couple of different ones, you start seeing similarities, and then you realize that they all do similar things in a certain sense. I would say it's much more likely that when people say "Monads are hard herp" what they actually mean is that they may seem a little weird or unnecessary when you first encounter them.
01:31:08 <Jookia> I guess monad Maybes are like the 'all' for function chains
01:31:23 <adnap> I don't agree that they all do similar things
01:31:31 <adnap> Only in the sense that they obey the laws
01:31:40 <Jookia> monads are open for interpretation, the best way to program
01:31:42 <adnap> But what they actually do in each case is very different
01:31:49 <quchen> adnap: that's what the "certain sense" was for.
01:32:01 <quchen> adnap: return puts in, >>= pipes on, join flattens etc.
01:32:52 <adnap> I think IO is the easiest monad to learn, even though I have read that many people don't think it's a true monad
01:33:11 <quchen> adnap: IO is terrible to learn as a Monad because you can't read the instance.
01:33:16 <quchen> ... definition
01:33:21 <adnap> So...
01:33:25 <adnap> The action of bind is so simple
01:33:30 <gspr> adnap: I disagree. You can't really make IO yourself (without hacking on the compiler)
01:33:32 <adnap> That's why it's easy
01:33:32 <t7> you can never escape the IO monad
01:33:34 <quchen> So it's a black box that "does stuff"
01:33:48 <adnap> Well, I learned it by example
01:34:00 <Jookia> Is it possible to prove imperative code?
01:34:04 <Finnfinn> I like to think of monads as containers. That helped me initially.
01:34:07 <Finnfinn> Jookia: Yes.
01:34:08 <t7> Jookia: yar
01:34:08 <adnap> And yeah, I can't implement it, but it's easy to see how the laws are working with ti
01:34:31 <adnap> Finnfinn: Yeah, me too. That's the metaphor LYAH uses
01:34:42 <gspr> adnap: At least for me, learning monads came down to re-making one myself and being told "look how neat this becomes when considered as a monad"
01:34:51 <gspr> adnap: That experience is unavailable with IO
01:34:55 <adnap> I have never made a monad
01:35:15 <adnap> I don't know if I'm smart enough. I've never thought of something that could be a monad. I just use existing ones
01:35:34 <gspr> adnap: Right. But re-inventing the common ones is what I meant.
01:35:41 <Nisstyre> Finnfinn: I dislike the container analogy personally, because it doesn't really capture all possible monads afaict
01:35:50 <supki> @quote monads.*containers
01:35:50 <lambdabot> kmc says: [After discussing monads, containers, and tortillas] therefore the key difference between a container and a monad is delicious carne asada
01:35:54 <supki> hmm
01:35:59 <Jookia> I'm going to fly to Japan and consult one of the Haskell elder monks on Monads.
01:36:04 <supki> @quote monads.are.like.containers
01:36:04 <lambdabot> kmc says: monads are like containers, as long as you forget everything you know about the meaning of the word "container" and take it to be a totally abstract word synonymous with "monad"
01:36:09 <quchen> Nisstyre: Well, you can adjust the box analogy to fit even the weirder monads ;-)
01:36:16 <mjrosenb> Jookia: aren't they all in redmond?
01:36:20 <adnap> Perhaps more appropriate than "container" is a "context"
01:36:21 <Finnfinn> Nisstyre: It helps grasping the concept, that's what's important.
01:36:48 <Nisstyre> Finnfinn: http://xkcd.com/895/
01:37:01 <adnap> The idea of a container or context explains the idea that your can't escape monads
01:37:04 <mgsloan> mjrosenb: Definitely not.  SPJ, for example, is in Cambridge
01:37:18 <Jookia> mjrosenb: I get the feeling I need to have some form of spiritual enlightenment to understand monads. Maybe a small zen garden I can rake at my desk.
01:37:32 <MrWoohoo> Would the statement "Monads are about making things that compose like functions" a fair description of monads?
01:37:41 <adnap> Just read LYAH
01:37:51 <johnw> Jookia: just keep reading about them, and try re-implementing some of them too
01:37:55 <johnw> it will come
01:37:58 <adnap> You're making it a big deal
01:37:59 <Nisstyre> MrWoohoo: that sounds more like monoids to me
01:38:01 <t7> monads are algebraic groups that follow 3 laws
01:38:08 <t7> algebraic*
01:38:10 <quchen> Jookia: The only thing that makes monads scary is people repeating the mantra that monads are scary.
01:38:22 <adnap> quchen: Agreed. Where does that come from?
01:38:26 <quchen> Jookia: Break the vicious circle!
01:38:51 <Jookia> adnap: I must have Queen Elizabeth bestow knighthood upon to me before I can even understand the word 'monad'.
01:38:54 <adnap> I guess it's just word-of-mouth with no distinct origin
01:39:21 <adnap> Jookia: Clearly you are having fun making monads a big deal
01:39:28 <johnw> Jookia: how comfortable are you with Functors?
01:39:30 <Jookia> adnap: I am. :P
01:39:31 <Nisstyre> Jookia: you must be Gottfried Leibniz
01:39:37 <Nisstyre> or as smart as him
01:39:38 <Finnfinn> adnap: "You can't escape monads" sounds more like a threat. .__.
01:39:53 <Jookia> johnw: I haven't really done much which is why I'm kinda just writing stuff to learn.
01:40:03 <quchen> Finnfinn: The Donad never forgets
01:40:16 <Finnfinn> #
01:40:34 <Finnfinn> And then #haskell came up with a new algebraic group - the Donad.
01:40:44 <Finnfinn> It's round and has a big hole in the middle.
01:40:51 <t7> its a ring
01:40:52 <adnap> Monads are a group?
01:40:52 <mjrosenb> I think it comes from people that "Know Java" looking at haskell, and freaking out because they can't modify anything
01:40:53 <t7> :D
01:40:59 <adnap> What is the group action?
01:41:06 <Finnfinn> t7: Lel.
01:41:15 <mjrosenb> then people start chanting "monad", and they run away in fear.
01:41:28 <Jookia> How hard is it to write an extension to allow me to write hash tags directly in to Haskell?
01:41:31 <Kinjen> I have chosen to study huskell because it provides me with familiar style, i am better in maths and i am grasping concepts functional easier than imperative. every choice has a conseque,What can't i do with haskell so that i can know from the start.
01:41:33 <Finnfinn> Yeahno.
01:41:57 <mjrosenb> Jookia: huh?
01:42:06 <quchen> Jookia: # should be treated as a reserved character in Haskell. You shouldn't use it yourself as a beginner.
01:42:07 <Nisstyre> Jookia: # is a valid identifer
01:42:16 <Nisstyre> but yeah it's used for other stuff
01:42:39 <adnap> Kinjen: You can't write programs that run as fast as C. That's the only thing I thought of
01:42:41 <quchen> Jookia: "#" things stand for "close to the machine" symbols.
01:42:56 <Jookia> quchen: Hash tags are close to my heart. Does that count?
01:43:24 <blueonyx> hi, anyone feeling adventurous and willing to help me investigate https://github.com/yesodweb/yesod/issues/557?
01:43:47 <Finnfinn> adnap: Yeah, but you can write programs that don't annoy the everlasting crap out of the programmer and look good. I've yet to see readable C code.
01:44:11 <Nisstyre> Finnfinn: the hello world example in K&R
01:44:24 <adnap> Finnfinn: Sounds like you aren't comfortable with C
01:44:26 <Jookia> blueonyx: You should really try to make a test case.
01:44:29 <johnw> int main() { printf("Goodbye, Finnfinn!\n"); }
01:44:32 <Finnfinn> Hello World and similar testcode does not count .__.
01:44:32 <quchen> Is it meta language discussion time again?
01:44:51 <adnap> Like 70% of the time
01:44:58 <Nisstyre> johnw: you didn't return an int, *glares*
01:44:59 <adnap> it's meta language discussion time
01:45:10 <Jookia> IMHO with the advent of asm.js we should start making CPUs that run directly on JS, much like Lisp machines
01:45:12 <blueonyx> Jookia: yea, but they all work :(
01:45:19 <johnw> Nisstyre: oh, I'm used to C++'s implied return 0
01:45:21 <Finnfinn> But yes, C does not suite me. I have no doubts that other people can read it and that's fine then. I guess I should've said that different.
01:45:27 <Nisstyre> johnw: oh neat, I didn't know that
01:45:30 <Finnfinn> *suit
01:45:36 <adnap> quchen: I think I'll take my cue
01:45:44 <Jookia> blueonyx: Well clone your project and just start removing parts of it that are unrelated until it either works or you have a test case?
01:45:56 <mjrosenb> johnw: that is only for main, right?
01:46:00 <johnw> yes
01:46:09 <mjrosenb> *magic*
01:46:35 <Kinjen> so haskell is faster than java?
01:46:41 <quchen> Here we go.
01:46:50 <Jookia> Kinjen: It doesn't matter
01:47:08 <johnw> Kinjen: questions like that are not language questions, they are programmer and machine questions
01:47:20 <t7> smallest crashing C program:  main = 0;
01:47:27 <Iceland_jack> t7: main;
01:47:27 <fosskers> hey gents
01:47:37 <Finnfinn> Kinjen: Java is on par with C++ (look for benchmarks of the newer VM versions), so ask yourself if Haskell's on par with C++. Which is something I'd like to know.
01:47:46 <t7> Iceland_jack: ah yeah
01:48:20 <Jookia> Finnfinn: Haskell is probably slower than C++?
01:48:35 <johnw> guys, languages are not slower than other languages
01:48:42 <johnw> infinite loops in all languages are equally fast
01:48:47 <t7> Jookia: idiomatic haskell is slower than C++
01:49:07 <Jookia> Why does speed even matter?
01:49:15 <t7> you asked....
01:49:20 <mgsloan> A sufficiently smart compiler will make Haskell faster than a sufficiently dumb C compiler
01:49:23 <hiptobecubic> Jookia, because some applications need to be fast?
01:49:26 <Jookia> That was kinda rhetorical.
01:49:47 <quchen> Just in case people are still wondering: guys yelling out their opinions about unprovable stuff, that's how Monads become "hard", Haskell becomes "slow compared to" and Friday the 13th become "dangerous".
01:50:10 <Nisstyre> quchen: unprovable stuff?
01:50:15 <Finnfinn> Gotta go fast.
01:50:18 <Jookia> hiptobecubic: Yes but with our processing power the differences aren't going to be easily visible
01:50:21 <Jookia> Finnfinn: Hahaha
01:50:30 <hiptobecubic> Jookia, that depends entirely on the problem.
01:50:36 <Aetherspawn> Haskell is often faster than C when pro's get to it
01:50:42 <Aetherspawn> with stricting, unboxing, raw core, etc
01:50:47 <Aetherspawn> Examples of it all over Stack Overflow
01:51:07 <Kinjen> ok . appart from preference and productivity reasons, why do you program in haskell? what can be done with haskell and not other languages
01:51:14 <Nisstyre> Aetherspawn: GHC does unboxing anyway though right?
01:51:23 <Jookia> Kinjen: Safety first!
01:51:36 <mgsloan> Yeah, you either have a sufficiently smart compiler (and GHC is pretty darn smart), or you write low level code
01:51:39 <Aetherspawn> Uh, yes, but ocassionally they must manually unbox or unpack because GHC decides not to
01:51:46 <Kinjen> <jookia>agree safety is critical
01:51:53 <johnw> Kinjen: I use it because I enjoy it more, that's really the end of the story.
01:51:56 <Nisstyre> Aetherspawn: oh okay, so the heuristic fails sometimes then I guess
01:52:01 <shachaf> Nisstyre: It does simple CPR-style unboxing, and it does -funbox-strict-fields if you ask, but those are just local things.
01:52:14 <Nisstyre> shachaf: okay that makes sense
01:52:34 <Jookia> Does Haskell support -funroll-loops
01:52:40 <Aetherspawn> Do we get to see sse2 in the ncg any time soon?
01:52:50 <Aetherspawn> Looking forward to that..
01:53:22 <Aetherspawn> I read that paper on fusion and how haskell was faster than C that I think simon wrote
01:54:03 <shachaf> Haskell is not faster than C: Haskell is two syllables and C is only one.
01:54:06 <shachaf> Also:
01:54:09 <shachaf> @quote einstein
01:54:09 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
01:54:34 <Jookia> Ahahahaha
01:54:46 <Aetherspawn> heh, took me a while to get that
01:55:18 <Nisstyre> Einstein was involved in early computers more than I thought. I'm reading George Dyson's book "Turing's Cathedral" which talks about him a bit.
01:55:31 <quchen> shachaf: That's because of the IO Monad. Without it, Haskell could not transmit information, and therefore could be faster than C.
01:55:56 <startling> quchen, wow, I thought monads were *good*
01:56:01 <Jookia> Pfft
01:56:02 <shachaf> quchen: No, Haskell could do IO just fine without "the IO Monad".
01:56:33 <quchen> s/the IO Monad/IO
01:56:37 <jpcooper> I can't for the life of me figure out how to set the interpreter used by haskell-mode in Emacs. Can anyone give me a tip?
01:56:50 <johnw> I think it may be truish to say that (1) naive Haskell often beats naive C, for reasons that are particular to pure, functional languages; (2) expert Haskell is often not as far off from naive Haskell as expert C is from naive C; (3) expert Haskell is hard to compare to expert C, because the domains of expertise are hard to quantify
01:56:50 <lambdabot> johnw: You have 1 new message. '/msg lambdabot @messages' to read it.
01:57:02 <Aetherspawn> Haskell'
01:57:27 <Aetherspawn> *Haskell's style of tail recursion can sometimes generate faster loops when compared with idiomatic C/C++
01:57:29 <Kinjen> ok whos doing some serious project with haskell at the moment.
01:57:42 <Jookia> Kinjen: John Carmack
01:57:56 <t7> Kinjen: haskell is only used to academics
01:58:00 <t7> by*
01:58:09 <mgsloan> t7: I hope you're joking
01:58:13 <t7> :3
01:58:13 <quchen> @quote Jafet research
01:58:13 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatic
01:58:14 <lambdabot> s, phone apps, and web services.
01:58:26 <Jookia> hahahahha
01:58:26 <Nisstyre> Haskell is only used to write programs that calculate factorials using type checkers
01:58:39 <adnap> Is it possible to import https://github.com/ghc/ghc/blob/master/ghc/Main.hs?
01:59:10 <fosskers> Hey guys, I got higher order functions, partial application, and lambdas implemented in my accidental Lisp
01:59:21 <Nisstyre> hmm he forgot compiler research
01:59:44 <Jookia> Haskell doesn't have Lisp macro powers though
01:59:51 <t7> @hoogle [(a, b)] -> a -> [b]
01:59:52 <lambdabot> Language.Haskell.TH.Syntax RecConE :: Name -> [FieldExp] -> Exp
01:59:52 <lambdabot> Language.Haskell.TH RecConE :: Name -> [FieldExp] -> Exp
01:59:52 <lambdabot> Language.Haskell.TH.Syntax RecP :: Name -> [FieldPat] -> Pat
01:59:54 <Nisstyre> Jookia: it does have AST macros
02:00:06 <Jookia> Nisstyre: Say what
02:00:15 <Nisstyre> Jookia: Template Haskell does AST macros
02:00:18 <mgsloan> Jookia: They just aren't needed very much
02:00:59 <Jookia> but lisp macros
02:00:59 <Kinjen> haskell has been academic for very long. wonder why doesnt cross the other side of the river.
02:01:11 <fosskers> https://github.com/fosskers/hisp
02:01:15 <mgsloan> Jookia: They're nice for introducing syntactic domain specific languages and for doing reflection on datatypes.  Beyond that, not too much
02:01:25 <Jookia> Kinjen: Because it confuses people
02:01:29 <blueonyx> http://downforeveryoneorjustme.com/http://holumbus.fh-wedel.de/ :((
02:01:35 <mgsloan> Jookia: What's so special about lisp macros?
02:01:42 <Jookia> mgsloan: ¯\_(ツ)_/¯
02:02:13 <Nisstyre> Jookia: some things that lisp macros would be used for can be accomplished by higher order functions that rely on laziness
02:02:36 <Jookia> That makes sense.
02:02:53 <Nisstyre> the typical example used to introduce scheme macros is an "if" macro, which can be a function in Haskell because the parameters don't immediately get evaluated
02:02:56 <arajan> Hi! I'm having issues with cabal. Can someone please help me?
02:03:54 <supki> arajan: not if you don't ask your question
02:03:56 <latermuse> arajan: whats the problem?
02:04:01 <arajan> ah, thank you.
02:04:03 <Nisstyre> Jookia: you can use macros to introduce lazy evaluation too though, e.g. you can use macros to construct streams in lisp
02:04:13 <Nisstyre> obviously that's unnecessary in Haskell
02:04:15 <arajan> soo...I used ghc-pkg unregister to unregister an older version of bytestring
02:04:23 <arajan> and I suspect I broke a bunch of stuff
02:04:30 <arajan> in particular, I was trying to install ghc-vis
02:04:45 <arajan> it wasn't installing before with cabal install ghc-vis on account of the two different versions of bytestring
02:04:53 <arajan> now it doesn't work for mysterious dependency reasons that I cannot divine
02:05:12 <blueonyx> ups wrong channel
02:05:44 <Aetherspawn> I think Haskell is going to get a huge speed boost when the improved CSE is done
02:05:45 <supki> @hpaste
02:05:45 <lambdabot> Haskell pastebin: http://hpaste.org/
02:05:52 <supki> arajan: paste your error
02:05:53 <Aetherspawn> the 12% on nofib is really impressive!
02:06:07 <arajan> I get "rejecting: ghc-7.4.2/installed-eca ... (package broken)"
02:06:07 <Jookia> I'm still amazed at how concise Haskell code is
02:06:23 <arajan> Resolving dependencies...
02:06:24 <arajan> cabal: Could not resolve dependencies:
02:06:24 <arajan> trying: ghc-vis-0.7.0.1 (user goal)
02:06:24 <arajan> next goal: ghc-heap-view (dependency of ghc-vis-0.7.0.1)
02:06:24 <arajan> rejecting: ghc-heap-view-0.4.2.0/installed-a68... (conflict: ghc-vis =>
02:06:26 <arajan> ghc-heap-view==0.5.*)
02:06:28 <arajan> trying: ghc-heap-view-0.5.0.1
02:06:30 <blueonyx> any1 knows, which module exports widgetFile?
02:06:31 <arajan> next goal: ghc (dependency of ghc-heap-view-0.5.0.1)
02:06:33 <arajan> rejecting: ghc-7.4.2/installed-eca... (package is broken)
02:06:46 <blueonyx> oh hayoo is back
02:07:30 <supki> arajan: ok, but next time use hpaste, don't paste into channel, please
02:07:45 <arajan> oops, sorry.
02:08:06 <arajan> for future reference, how do I use the hpaste bot?
02:09:21 <supki> arajan: ok, so you unregistered bytestring that came with ghc
02:09:32 <arajan> correct. I believe it was version 0.9.2.1 or some such
02:09:34 <supki> arajan: not sure what to do to fix it except reinstall
02:09:42 <arajan> wellp. all righty then.
02:10:05 <arajan> um...how then do I avoid the issue of bytestring-0.9.2.1 and bytestring-0.10.1.0 (or whatever the exact version numbers are)
02:10:08 <arajan> overlapping?
02:10:45 <functorfun> Hi, I been wondering about this for awhile. Some very commonly used packages on haskage come up with rather scary warnings due to more recent versions of GHC I assume. However does one going about reporting these, are they seen too enough?
02:10:47 <supki> generally advice is to not having several bytestring versions installed at once
02:11:00 <leroux> Or sandbox.
02:11:14 <arajan> OK. But GHC comes with its own (older) version of bytestring.
02:11:19 <leroux> Sorry, that's the wrong word.
02:11:23 <adnap> So... I got a darcs repo of a package that is already installed. I made some changes. How can I install this modified package so that it doesn't interfere with the currently installed one, or any projects that rely on it?
02:11:24 <arajan> I do not want the old version. Nevertheless, I cannot unregister it
02:11:26 <supki> that's the one use should use
02:11:29 <arajan> oh, ok
02:11:39 <leroux> cabal-dev ?
02:11:53 <arajan> Thanks for your help!
02:11:55 <supki> upgrading packages that come with ghc does not end well :)
02:12:05 <arajan> I can see that now. Will not do so in future.
02:12:52 <adnap> leroux: Talking to me?
02:13:01 <arajan> well, thanks again! Good night.
02:13:05 <adnap> The description of cabal-dev seems to fit my situation
02:13:11 <leroux> adnap: Yeah.
02:14:18 <functorfun> MonadCatchIO-transformers and HStringTemplate are the examples I am thinking of in particular. Some warnings look simple to fix, how can i fix them and upstream a patch?
02:14:36 <adnap> leroux: So... if I understand right, cabal-dev creates a sandbox where the modified package takes precedence, but all other installed packages are available, right?
02:17:23 <merijn> functorfun: "cabal unpack MonadCatchIO-transformers" edit the source and use "cabal build" etc to test, then submit a patch?
02:17:38 <merijn> functorfun: Also, you might want to check if hackage lists a repository/maintainer for them?
02:18:24 <latermuse> hey, is there a pragma to prevent the type checker from spitting out this error? Couldn't match expected type `GHC.Int.Int64' with actual type `Int'
02:19:09 <latermuse> im trying to pass an Int into the Data.ByteString.drop function
02:19:20 <blueonyx> what language extension do i need to make this line parse? staticRoot conf = [st|#{appRoot conf}/static|]
02:19:30 <blueonyx> i get  parse error on input `{'
02:19:34 <Pranz> latermuse, try fromIntegral
02:19:44 <latermuse> thanks, ill give it a shot
02:19:58 <startling> latermuse: n.b. that might overflow on 32-bit platforms
02:20:07 <functorfun> merijn: thanks, where is the standard place to submit patches? is there like a github thing I can do a pull request to?
02:20:19 <latermuse> im not using 32 bit platform, so it doesnt matter to me. is there any way to force it?
02:20:30 <functorfun> or is it mailing list only
02:20:48 <startling> latermuse: fromIntegral will just make it happen; no reason to force it.
02:20:59 <supki> adnap: only --global packages are available in cabal-dev sandbox
02:21:24 <supki> adnap: (besides those you installed with cabal-dev install of course)
02:21:39 <latermuse> so i change Data.ByteString.drop 3 string into Data.ByteString.drop (fromIntegral 3) string?
02:22:02 <merijn> functorfun: It depends on the library, there should be a maintainer listed on hackage
02:22:03 <Pranz> latermuse, yes
02:22:04 <startling> latermuse: sure.
02:22:14 <latermuse> No go. still getting that type error
02:22:18 <startling> latermuse: (actually, no, I think that will give an ambiguity error)
02:22:36 <startling> latermuse: (assuming you're actually using the literal 3 in that place)
02:22:37 <merijn> functorfun: http://hackage.haskell.org/package/MonadCatchIO-transformers lists a maintainer e-mail and darcs repository
02:22:46 <Pranz> latermuse, where do you get the type error?
02:22:58 <latermuse> okay the error was in my declared type
02:23:03 <latermuse> i commented it out, and it compiled
02:23:09 <startling> latermuse: cool!
02:23:13 <latermuse> yep. thanks guys!
02:23:17 <merijn> functorfun: Usually I just e-mail the maintainer with a diff of my changes if the change is small
02:23:52 <quchen> Is there a way I can tell Cabal to reinstall a library and all its dependencies? 'cabal install --reinstall --only-dependencies PACKAGE' tells me all deps are already present, and I should use '--reinstall'.
02:23:56 <functorfun> merijn: OK, many thanks!
02:24:16 <merijn> quchen: Never use --reinstall, just manually uninstall before continuing
02:24:28 <merijn> quchen: "ghc-pkg unregister <pkg-name>"
02:24:49 <quchen> merijn: I'm going to have to do this for each dependency manually?
02:24:52 <merijn> quchen: Then you can manually delete ghc-7.x.x/lib/pkg-name-0.1.0
02:25:25 <merijn> quchen: That's the way I've always done it, but I'm not sure it's the best way
02:25:29 <dcoutts> quchen: not really because it's not a well defined problem "all of its dependencies" includes things like base etc but you don't want that, so you have to select which deps somehow
02:25:42 <merijn> you could probably grep+sed your way to automation
02:26:20 <quchen> Alright, thanks
02:26:40 <functorfun> also, does cabal have something that says "update all my cabal packages to current versions in one go, i.e. upgrade or is that really broken still?"
02:27:20 * merijn just only upgrades when the new platform is released or he hits a bug/dependency
02:27:23 * functorfun dam, need to setup irssi properly
02:27:33 <functorfun> ok
02:27:38 <dcoutts> functorfun: it exists but it's not helpful for the same reason, because it doesn't have a way to distinguish between the ones you want to upgrade and the ones you want to keep fixed.
02:28:02 <merijn> functorfun: Is there a specific reason you feel you need to upgrade everything that frequently?
02:28:19 <merijn> Seems easier just to upgrade when you need a bugfix/new feature
02:28:51 <functorfun> oh i didn't mean frequently.. however sometimes I switch between jobs and come back to haskell after many months and go "right need a fresh cabal.."
02:29:00 <functorfun> if you know what I mean
02:29:12 <merijn> functorfun: Oh, then I just usually nuke my install and install the latest Platform :p
02:29:19 <functorfun> cool ok
02:29:37 <functorfun> maybe I should put .cabal under version control
02:29:45 <startling> you can just rm ~/.ghc
02:29:45 <functorfun> could be a useful idea?
02:29:47 <merijn> Incidentally, unlike all the redditors that seem to be whining about "caball hell" I've never run into a problem, ever
02:29:51 <fosskers> merijn: hey, was it you i was talking to yesterday about implementing lambdas?
02:30:09 <merijn> fosskers: Nope, although I vaguely recall seeing that conversation
02:30:11 <functorfun> no its not too much a issue, I just thought I would ask
02:30:16 <startling> lots of m names around here.
02:30:42 <fosskers> merijn: haha sorry, must have been another active user with an "m" username
02:30:49 <functorfun> just playing with this at the moment https://github.com/biegunka
02:31:09 <functorfun> making all my dotfiles into profiles for the different machines, pretty cool
02:31:37 <functorfun> m for monoids :p
02:31:49 <startling> @quote monoids
02:31:50 <lambdabot> monochrom says: <mauke> monoids are simple  <elliott> And as we all know, monads are basically just monoids!  <monochrom> haskell is basically just ascii
02:31:53 <functorfun> a whole list of them
02:32:11 <startling> @quote beaky
02:32:11 <lambdabot> beaky says: why did they settle on bitshiftrightassign (>>=) for monadic bind?
02:32:11 <functorfun> lol wat! ^
02:32:21 <startling> :<
02:32:28 <hiptobecubic> good old beaky
02:32:34 * functorfun pats
02:33:34 <merijn> I wish lambdabot had a way for me to grep for all my quotes >.>
02:33:45 <merijn> That way I could be more narcisistic
02:33:54 <Botje> can't you still download the quotes database?
02:34:00 <hiptobecubic> merijn, you're doing a pretty good job right here
02:34:02 <merijn> Botje: Not a current one
02:34:35 <startling> @remember merijn <merijn> I wish lambdabot had a way for me to grep for all my quotes >.> <merijn> That way I could be more narcisistic
02:34:35 <lambdabot> I will remember.
02:35:06 <merijn> That one doesn't really seem worth remembering...
02:35:13 <merijn> @forget merijn <merijn> I wish lambdabot had a way for me to grep for all my quotes >.> <merijn> That way I could be more narcisistic
02:35:13 <lambdabot> Done.
02:35:43 <startling> @quote HST
02:35:43 <lambdabot> merijn says: I run on HST (Hacker Standard Time) which is essentially current time zone -3
02:36:33 <adnap> Argh, it is annoying navigating through old GHC docs
02:36:58 <adnap> I can't find a Hackage page that lets me browse different versions of documentation like other packages
02:37:11 <adnap> Everything seems to be here: http://www.haskell.org/ghc/docs/
02:37:21 <adnap> And it's hard to get to the actual page I want
02:37:28 <startling> http://hackage.haskell.org/package/base ?
02:37:51 <startling> typically I just type http://hackage.haskell.org/package/ and append the package name
02:38:17 <adnap> http://hackage.haskell.org/package/ghc-6.0 doesn't work
02:38:34 <startling> adnap, "ghc" is not a package
02:39:15 <startling> adnap, "base" is the main package that comes with ghc, is that what you want?
02:39:39 <haasn> According to HST, every time is Haskell time
02:39:44 <merijn> Why do many functions like readFile not advertise which exceptions they can throw :(
02:39:49 <haasn> because they are bad
02:39:56 <adnap> I'm just trying to figure out when "FileOption" was introduced
02:40:06 <adnap> dhttp://www.haskell.org/ghc/docs/6.10.3/html/libraries/ghc/DynFlags.html#v%3AFileOption
02:40:25 <haasn> and exceptions are bad
02:40:29 <haasn> and you should feel bad for using them
02:41:33 <startling> dependent types would be so nice here. :<
02:41:57 <merijn> haasn: That is 1) completely unhelpful and 2) just not true for IO errors
02:42:05 <startling> readFile :: ThrowT [FileDoesntExist] IO String
02:43:48 <merijn> startling: Except that it can also throw: ELOOP EACCESS EFAULT ENAMETOOLONG and *many* other issues
02:44:12 <startling> sure; those would just go in the list argument to ThrowT (or whatever)
02:44:42 <merijn> It wouldn't even have to list all errors, just a note "this can throw exceptions" would be nice
02:46:21 <supki> I particularly like how http-conduit throws exceptions on 404
02:46:25 <supki> totally not abuse
02:50:49 <m3ga> supki: http-conduit lets you changed the 404 behaviour
02:53:37 <haasn> startling: readFile :: IO (Either String Bool); data Bool = True | False | FileNotFound
02:54:07 <bartavelle> lazy IO and delayed errors
02:54:41 <startling> haasn: yes, good idea, we'll redefine Bool
02:56:40 <bartavelle> (you must have something like exceptions because of lazy IO)
02:56:44 <startling> not sure what True False would mean in that situation, either.
02:56:47 <Tinned_Tuna> I really don't know if you guys are serious or what these days...
02:57:26 <bartavelle> startling, it would depend on what's in the string
03:00:15 <haasn> oh sorry, I wasn't being serious
03:00:18 <haasn> in case it caused any confusion
03:00:38 <haasn> there are like half a dozen serious ways of dealing with errors and all of them have their pros and cons
03:01:04 <haasn> even ‘error’ has its uses
03:02:23 <quchen> Did anyone else recently have problems updating cabal-install? It tells me there's a "catch" function missing. http://hpaste.org/89008
03:02:56 <quchen> (The result of 'cabal install cabal-install', which I successfully used two days ago.)
03:04:51 <dcoutts> quchen: your current cabal-install is too old, built against an old Cabal lib, so the Paths_ module it's generating now doesn't work with the ghc/base version you've got
03:06:36 <quchen> dcoutts: Sounds odd. I'll mark it as unfixable and start from scratch.
03:07:29 <dcoutts> quchen: basically the version of your existing cabal-install cannot work with the version of base you have now.
03:08:34 <quchen> dcoutts: I'm just surprised, because I installed GHC half an hour ago, followed by the Platform, followed by cabal install cabal-install.
03:08:52 <dcoutts> quchen: check you're using the versions you think you are
03:09:06 <dcoutts> what version of cabal-install are you using? (not building)
03:09:07 <merijn> Fun fact: Bash will cache symlinks!
03:09:44 <hpc> merijn: oh god what
03:09:44 <typoclass> quchen: o hai. i assume the relevant 'catch' change is when they removed Control.OldException in ghc 7.6. maybe you're using 7.4? iirc the change also caused removal of one function from Prelude
03:09:48 <merijn> Yesterday I ran "cabal install" on Cabal and cabal-install and after that "cabal --version" reported the old version, had to exit my shell to update it
03:10:01 <merijn> hpc: Well, it's the only explanation I can think of for the above problem I had
03:10:21 <Lethalman> merijn, more probably it doesn't update things under */bin, but that's a zsh problem rather than bash
03:10:32 <Lethalman> in PATH that's it
03:10:32 <quchen> dcoutts: Too late, already started over :-( (It's probably the leat painful way anyway)
03:10:36 <merijn> (because which showed the right path, but that path was just a symlink to the current cabal version)
03:10:36 <functorfun> One thing I still have to do before I die :p make a login manager to go with XMonad in Haskell to replace SLiM. I seen SLiM crash, I never seen XMonad crash.. `Rediculous' !
03:10:37 <typoclass> merijn: yes i think so. also paths to binaries. there's some "hash -n" command or whatever to clean the caches while running
03:11:14 <merijn> typoclass: No, that's (t)csh, bash doesn't have a rehash command
03:11:37 <typoclass> merijn: yes perfectly possible, i'm quoting from memory
03:13:36 <quchen> dcoutts: Oh, found the error. Too late to fix it, but I still had a very old cabal in another dir, and probably used that one.
03:13:45 <quchen> Thanks for the "check your sources" hint :-)
03:13:52 <dcoutts> quchen: that makes sense
03:14:18 <quchen> Time to ransack in /usr/bin a bit so this doesn't happen again
03:14:48 <t7> can ghc generate binary instances by itself yet?
03:15:05 <quchen> You mean Binary?
03:15:20 <t7> if not, why not? the people demand this feature
03:15:24 <t7> yeah Binary
03:15:34 <quchen> http://hackage.haskell.org/packages/archive/binary/0.7.1.0/doc/html/Data-Binary.html#g:3
03:15:43 <quchen> So yes. :-)
03:15:56 <t7> :D
03:16:29 <t7> thank you based simon(s)
03:16:47 <quchen> ?
03:17:58 <functorfun> merijn: So I am fixing these warnings.. In Text/StringTemplate/QQ.hs:27:8: there is a warning about strings not being initialised. Fields of `QuasiQuoter' not initialised: quoteType, quoteDec
03:18:29 <functorfun> merijn: What should happen here, does one init to a empty string by default?
03:18:51 <functorfun> this is in regards to HStringTemplate
03:19:23 <merijn> I have no clue? I've never used that code?
03:19:30 <merijn> Are you sure the warnings need fixing?
03:20:13 <fruitFly> What do you guys think of elm for web development? How fast do you think it will mature now that google guy is full time on it?
03:22:40 <latermuse> really fast
03:22:40 <typoclass> functorfun: that warning shows up if you have a record type, and you're creating a value, but you're not giving values for each field. (in my opinion it's a bit unfortunate that haskell allows this at all. it should be an error, not a warning.) example: "data Record = R { foo :: Int, bar :: Int } ; someValue = R { foo = 42 }"
03:22:59 <merijn> typoclass: why?
03:23:17 <merijn> It's very useful for providing records with defaults filled in?
03:23:34 <functorfun> typoclass: yes, well uninit types make me uneasy.. this is why I was looking at this package..
03:24:50 <typoclass> functorfun: solutions would be to initialize all fields in one place "R { foo = ..., bar = ... }", or using a default record that has all fields set to a sensible value, and then overwriting just a few of them. "someValue = defaultR { foo = 42 }" (<- no warning if defaultR is defined and has both fields set
03:26:22 <typoclass> merijn: hm ... how do you mean, 'defaults filled in'? if i remember correctly, after "x = R { foo = 42 }" there'll be a runtime error when accessing "bar x"
03:26:35 <merijn> typoclass: bar is initialised to undefined
03:26:45 <merijn> Any unspecified field is initialised to undefined
03:27:35 <merijn> Which can be useful if the field will be initialised later somehow (for example you use the record with State and something else is responsible for initialising that field, etc)
03:28:06 <functorfun> actually on closer study i don't understand the warning because everything does look initialised..
03:28:37 <typoclass> functorfun: the message mentioned the two field names that ghc thinks are not being initialized
03:30:25 <ectospasm> I'm having trouble with Haskell on Debian Sid.  I have been doing an "unsafe interleave install" (according to this http://www.vex.net/~trebla/haskell/sicp.xhtml#storage) by mixing Debian packages, and cabal install --global incantations.  After a GHC update (via apt), DBus.Client is no longer found.  I'd like to wipe my entire GHC install and start fresh, but I can't seem to figure out how to do that
03:30:26 <typoclass> merijn: well yes, it has a use :) null pointers in c also have a use. the question is just if that use is proportional to the harm they can cause
03:30:26 <ectospasm> globally.
03:31:21 <merijn> ectospasm: Simplest solution, nuke ~/.ghc
03:31:39 <ectospasm> merijn: that won't nuke the global installation, though, will it?
03:31:48 <merijn> I think that should be all, but I'm not sure...
03:31:57 <merijn> tbh I've never used --global >.>
03:33:03 <typoclass> ectospasm: have a look at 'ghc-pkg list'. it will tell you the directories where the packages are. on my system, it's /usr/lib/ghc-7.4.2/
03:34:28 <ectospasm> typoclass: I did that, but then I couldn't install any packages with cabal install, something about missing "base"
03:35:16 <typoclass> ectospasm: erm yes, that's expected :-(
03:36:13 <typoclass> ectospasm: first of all, installing things with --global is not recommended. though that warning is a bit too late and doesn't help you now
03:36:26 <ectospasm> yes, I'm finding that out.
03:37:36 <typoclass> ectospasm: maybe try to re-install ghc via apt? i'd assume apt will detect that the package is installed partially, i.e. some files are there, but some files (like the base package) are missing
03:38:39 <merijn> Well, if he was looking to wipe his GHC install just wiping everything under the path given by ghc-pkg list should work
03:38:48 <merijn> Then it'll be sorted when he reinstalls
03:38:56 <ectospasm> typoclass: I don't think apt will detect that ghc is installed partially.  As far as apt is concerned, everything is fine.  The recent update via apt seems to have broken all my cabal installed packages.
03:40:02 <merijn> Look at the dirs in ghc-pkg list, nuke everything under those, force uninstall ghc in apt, reinstall, go from there
03:40:13 <merijn> (also nuke ~/.ghc)
03:40:54 <Aetherspawn> is there a lockless read data structure but locking write
03:41:09 <Aetherspawn> for something with high read contention and infrequent writes from only one source
03:41:19 <merijn> What do you mean by "locking write"?
03:41:29 <merijn> i.e. no one can read while updating?
03:41:39 <merijn> Why not stuff it in a TVar?
03:41:47 <Aetherspawn> Uh, it makes sure that reads don't get messed up by writes I guess
03:41:48 <typoclass> ectospasm: yes, but the cabal-installed packages are all deleted now anyway, aren't they? so if you reinstall ghc via apt, you should be able to start reinstalling the packages using the new updated ghc
03:41:49 <Aetherspawn> is what I meant.
03:42:09 <Aetherspawn> Hmm, TVar
03:42:17 <typoclass> ectospasm: (i'm not really familiar with debian. i hope i'm not giving out bad advice. please check what i'm saying)
03:43:04 <merijn> Aetherspawn: STM guarantees that an operation (such as read) can never see another transaction "mid-progress" i.e., they will either see your write as completely finished, or as not happened yet
03:43:12 <ectospasm> typoclass, merijn:  I had not actually deleted anything in /var/lib/ghc/*, just moved it (then restored it).  Now I'm moving it again, and will try reinstalling ghc...
03:43:27 * hackagebot hruby 0.0.3 - Embed Ruby in your Haskell program.  http://hackage.haskell.org/package/hruby-0.0.3 (SimonMarechal)
03:43:44 <typoclass> ectospasm: yes, moving instead of deleting is a sensible precaution
03:43:45 <merijn> Aetherspawn: Just use "readTVarIO" for accessing the data and then you use an STM transaction for writing
03:44:04 <Aetherspawn> merijn, thanks!
03:44:15 <Aetherspawn> Reading this paper by simon, explains a lot too : http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/lock-free-flops06.pdf
03:46:05 <haasn> STM retries transactions that failed because of a value being written to in the middle of an operation
03:46:19 <haasn> instead of blocking
03:46:43 <haasn> the advantage being that transactions are super composable, and deadlock is much harder
03:46:57 <startling> isn't deadlock impossible with STM?
03:47:04 <merijn> startling: Of course it's not
03:47:17 <haasn> you can construct some situations in which STM deadlocks
03:47:22 <startling> oh, hm
03:47:46 <merijn> "do { tvar <- newEmptyTVarIO; forkIO (readTVarIO tvar); forkIO (readTVarIO tvar) }" <- deadlock
03:47:48 <haasn> I think the solution to the thinking philosophers deadlocks unless you give them different timings
03:48:57 <Aetherspawn> merijn, why is that a deadlock
03:49:39 <startling> we should just do parallelism by only having blocking operations happen on times that are multiples of primes
03:53:33 <merijn> Aetherspawn: They're both blocked trying to read from tvar?
03:53:51 <merijn> Nothing if writing to tvar
03:53:56 <merijn> s/if/is
03:54:15 <Aetherspawn> if TVar was written to once
03:54:20 <Aetherspawn> an initial value
03:54:24 <Aetherspawn> would they still block?
03:54:29 <Aetherspawn> (Sorry, I haven't read up on TVar)
03:55:27 <ectospasm> typoclass, merijn:  reinstalling ghc (and libghc-dbus-dev) resolved my issue.  My xmonad.hs file now compiles, and I didn't have to install anything with cabal!  Thanks!
03:56:11 <ectospasm> Hopefully next time I'll remember to search apt for the right package, and if I can't find it install it using a cabal install --user invocation!
03:56:42 <supki> --user is the default
03:56:43 <Nimatek> Guys, what's the status of template haskell on arm? Is it going to work anytime soon?
03:57:07 <ectospasm> supki: I realize this now, but I had been doing --global.
03:58:32 <typoclass> ectospasm: you're welcome :) those occasional cabal package screw-ups are really unfortunate. but the good news is, they're working on it and it's getting better. for the record, i don't use the distro's haskell packages (arch linux), i install everything via cabal, and it's been quite a long while since i last had trouble
03:59:14 <typoclass> ectospasm: here is further information for you http://i.imgur.com/4owJPOp.jpg
03:59:48 <merijn> Aetherspawn: No, if it's not empty they wouldn't block
04:00:04 <Nimatek> typoclass: That cat doesn't look regretful. Source: I have a cat.
04:00:11 <merijn> ectospasm: --user is the default, you can just run "cabal install"
04:00:27 <ectospasm> typoclass: I'm going to stick with the Debian packages if I can.  That pic is on the article I linked to earlier (-;
04:00:45 <typoclass> Nimatek: right. she looks more like "oh damn, it'll take me forever to clean this off"
04:01:37 <Nimatek> typoclass: Even worse, it's the playful/aggressive "I'ma fuck shit up" stance.
04:02:22 <ectospasm> Nah, that's the "I didn't do it" look
04:02:48 <Nimatek> ectospasm: Dogs do that, cats don't give a fuck.
04:04:25 <Nimatek> So on that note, can I haz template haskell on arm?
04:05:40 <danr> Aetherspawn: TVars don't block. Maybe you're thinking of MVars or TMVars
04:06:47 <merijn> Oh, duh
04:06:54 <merijn> Typo in my STM deadlock example
04:07:01 <merijn> Or thinko
04:08:31 <haasn> Nimatek: interprateCat = const I'maFuckShitUp
04:08:42 <haasn> interpret*
04:08:49 <Nimatek> Hah.
04:21:41 <FreeFull> merijn: Can you link to your example?
04:26:04 <merijn> FreeFull: It was just 1 line if you scroll back up a little :p
04:26:14 <merijn> Except read TMVar everywhere instead of TVar
04:30:14 <FreeFull> merijn: Usually deadlock implies two threads stopping each other from working
04:30:22 <FreeFull> merijn: But in your example, it wouldn't even work with just one thread
04:33:10 <merijn> Well, yes
04:33:40 <merijn> I was just making the point that the remark "STM prevents deadlock" is trivially false
04:34:30 <hpc> funny thought: using unsafe IO inside STM to execute an infinite loop
04:34:49 <hpc> by deliberately triggering a retry
04:46:30 <merijn> hell
04:46:31 <merijn> Just
04:46:57 <merijn> :t forever retry
04:46:57 <lambdabot> Not in scope: `retry'
04:53:21 <socumbersome> Hi. What  does"{ .. }" mean in this example - newtype State s a = State { runState :: s -> (a, s) }  ? I mean, what is the notion of curly brackets there?
04:53:38 <merijn> socumbersome: Record syntax
04:54:07 <merijn> socumbersome: It basically says the State constructor has one field, named "runState" which has type "s -> (a, s)"
04:54:22 <typoclass> socumbersome: hello, the curlies are enclosing the field that the record has. (a newtype always has only one field.) inside the name and type of the field are specified
04:55:08 <merijn> socumbersome: It's the same (well, almost)  as writing "data State s a = State (s -> (a, s)); runState :: State s a -> (s -> (a, s)); runState (State x) = x"
04:55:20 <socumbersome> ah, okay, thanks : )
04:55:37 <typoclass> socumbersome: it's essentially similar to "data Person = P { name :: String, age :: Int }"
04:55:44 <merijn> socumbersome: (Note that I glossed over the fact that newtype and data are subtley different from eachother, the wiki has some stuff about that)
04:58:22 <Hafydd> It's time to panic: the language report is down.
05:01:43 <FreeFull> Code used to use the State constructor directly, but now it's not exported and you have to use the state function instead
05:01:53 * typoclass meows and runs through the channel wildly, jumping from table to table and knocking over various beverages
05:02:41 <Hafydd> Hahahah.
05:03:44 <ski> because now `type State s = StateT s Identity'
05:07:14 <magneticduck> @pl (\x -> (f x) && (g x))
05:07:14 <lambdabot> liftM2 (&&) f g
05:07:21 <magneticduck> mmm, yes the lift
05:07:30 <magneticduck> lambdabot seems pretty snappy today
05:07:35 <magneticduck> @botsnack
05:07:35 <lambdabot> :)
05:14:06 <FreeFull> > Identity 3
05:14:07 <lambdabot>   No instance for (GHC.Show.Show (Data.Functor.Identity.Identity a0))
05:14:08 <lambdabot>    aris...
05:14:59 <applicative> FreeFull: someone left out the most obvious thing ...
05:17:07 <FreeFull> a Show instance for Identity is really easy too
05:17:21 <FreeFull> instance (Show a) => Show (Identity a) where show = show . runIdentity
05:19:28 <elliott> FreeFull: that's the clear, simple and wrong instance
05:19:45 <elliott> it misses out the Identity constructor
05:20:34 <applicative> the derived show instance would be a little icky since its newtype Identity a = Identity { runIdentity :: a }
05:20:53 <applicative> Identity {runIdentity = 17}
05:21:50 <applicative> somehow thinking of the Identity functor as having fields is a little strange.
05:22:36 <Taneb> > runIdentity undefined {runIdentity = "hello"}
05:22:38 <lambdabot>   "hello"
05:22:50 <FreeFull> elliott: Oh, you are right
05:23:39 <elliott> applicative: right, a non-derived instance would be nicer
05:23:44 <FreeFull> instance (Show a) => Show (Identity a) where show = ("Identity ("++) . (++")") . show . runIdentity
05:24:18 <elliott> that isn't quite right either.
05:24:24 <elliott> you want to use showsPrec/showParens/etc.
05:24:33 <applicative> somehow a repo buried on darcs get http://code.haskell.org/~ross/transformers
05:24:44 <applicative> doesn't seem very patch friendly anymore
05:26:09 <weebl> i have a framework that receives a function which can be executed on the relevant type, however i use the framework with different types, one is a list of things and the other a self-defined datatype
05:26:21 <weebl> how do i tell haskell that it can actually use the function on the arguments in both cases
05:26:30 <weebl> as it now tries to assume it should be a list because the first one is
05:26:44 <FreeFull> elliott: I'm lazy
05:27:28 <typoclass> weebl: do you have a couple of lines of example code for hpaste.org?
05:27:50 <maxorator> what's the best way to find out which line/statement causes an exception?
05:27:56 <applicative> weebl: that's a little opaque, but it sounds like you need a typeclass that covers both cases?
05:27:57 <elliott> ?where xc
05:27:58 <lambdabot> I know nothing about xc.
05:28:00 <elliott> ?where rts-xc
05:28:00 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
05:28:15 <elliott> maxorator: ^ is about as good as it gets
05:29:06 <applicative> what exception does it say happened?
05:29:31 <applicative> > head []
05:29:32 <lambdabot>   *Exception: Prelude.head: empty list
05:29:36 <typoclass> maxorator: there's a few rules of thumb ("don't use the head function", etc.) to avoid exceptions in the first place. but if you've already got the code, then try the "-xc" thing
05:29:43 <maxorator> thanks lambdabot, works perfectly :)
05:30:21 <weebl> let's see
05:31:01 <applicative> maxorator: the best way to keep missing case exceptions from happening is -Wall
05:31:12 <klugez> maxorator: http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/ghci-debugger.html - I see you already found out, but section 2.5.6 in here would have been a second possibility.
05:31:33 <merijn> @quote spryng
05:31:33 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
05:31:54 <typoclass> merijn: also, [a] -> [a] :-)
05:31:56 <typoclass> > tail []
05:31:58 <lambdabot>   *Exception: Prelude.tail: empty list
05:32:22 <maxorator> klugez, with :trace it's so slow I'd have to wait 20 minutes for it to reach the code where it throws an exception though
05:33:25 <schoppenhauer_> hello. I am currently converting Word8 to Int using fromIntegral (toInteger _), but I am quite sure there is a function for doing this directly, I just cannot find it. does anybody know it?
05:34:04 <elliott> schoppenhauer_: er, um, it's fromIntegral :P
05:34:09 <elliott> > fromIntegral (3 :: Word8) :: Int
05:34:11 <lambdabot>   3
05:34:36 <applicative> there may be a dedicated function buried in GHC.***
05:34:38 <haasn> fromIntegral = fromInteger . toInteger
05:35:11 <applicative> schoppenhauer_: but unless you are using a negative optimization flag it will come to the same, no?
05:35:31 <merijn> applicative: Probably he just wants something more readable?
05:35:34 <applicative> maybe what you need is fi x = fromIntegral x
05:35:42 <applicative> which is pretty common.
05:35:55 <schoppenhauer_> elliott: ah ok.
05:36:15 <schoppenhauer_> elliott: thank you
05:36:24 <elliott> :)
05:36:27 <schoppenhauer_> applicative: I did not understand your question.
05:36:47 <applicative> or PostfixOperators, (#) = fromIntegral ; (x #)
05:37:09 <schoppenhauer_> applicative: I did not know that fromIntegral could be applied to Word8
05:37:14 <schoppenhauer_> applicative: that was the main problem
05:37:14 <applicative> schoppenhauer_: I thought you were objecting to fromIntegral as too indirect
05:39:28 <merijn> schoppenhauer: In ghci you can type ":i Word8" and it will tell you what classes it's an instance of
05:39:41 <typoclass> merijn: he's gone
05:39:44 <merijn> AH
05:39:55 <weebl> http://www.weebl.me/weebl/error.hs <- that is the problem basically
05:39:58 <merijn> That always happens, curse of PARTS being off :p
05:40:02 <schoppenhauer> merijn: sorry, had connection problems
05:40:06 <applicative> schoppenhauer: no hes back
05:40:13 <weebl> another function gets both an appropiate join and what to execute it on, so it shouldn't be a problem
05:40:25 <weebl> i need to define some types somewhere i think
05:40:56 <merijn> schoppenhauer: In ghci you can type ":i Word8" and it will tell you what classes it's an instance of
05:41:12 <schoppenhauer> merijn: nice. thx!
05:41:15 <merijn> (Well, at least of the classes you have in scope in ghci)
05:41:54 <applicative> weebl: the sixth argument of 'main' ... this sounds like a recipe for disaster
05:42:00 <merijn> Usually I just blindly try and rely on the typechecker to tell me "fromIntegral someWord" is a type error :p
05:42:02 <applicative> weebl: join has been taken too
05:42:35 <typoclass> @type fromIntegral
05:42:36 <lambdabot> (Integral a, Num b) => a -> b
05:42:42 <applicative> weeble State is also taken. This is very very very hard to read
05:42:56 <applicative> > let fmap = 4 in fmap + fmap
05:42:58 <lambdabot>   8
05:43:18 <applicative> > let fmap = 4; map = even in map fmap
05:43:20 <lambdabot>   True
05:43:30 <typoclass> schoppenhauer: ^^ this means it's fairly general. it can take anything for which there's an Integral instance (= all sorts of Ints and Words), and produce any sort of Num
05:43:53 <applicative> let (>>=) = (+) ; fmap = 4 ; join = 3 in fmap >>= join
05:44:03 <applicative> > let (>>=) = (+) ; fmap = 4 ; join = 3 in fmap >>= join
05:44:04 <lambdabot>   7
05:44:20 * applicative feels like Lyndon LaRouche or something
05:44:43 <applicative> > let (>>=) = (+) ; fmap = 4 ; join = 3 in fmap >>= join >>= fmap
05:44:44 <lambdabot>   11
05:45:00 <typoclass> applicative: lambdabot is also available privately via "/query lambdabot"
05:45:23 <elliott> i'm sure applicative knows that...
05:45:41 <applicative> typoclass: I was illustrating the dangers of shadowing everything in base simulataneously in a single module
05:46:15 <applicative> but it was indeed a little silly
05:46:30 <typoclass> elliott: what i meant is, i didn't understand what he was trying to show. he has now explained it
05:47:36 <typoclass> weebl: apart from the names being redefined (join, main, State, ...), the problem is that "join a b = DL.intersect a b", assuming DL is Data.List, will cause join to be the same signature as intersect. and that is incompatible with your earlier definition of join as being State -> State -> State
05:47:48 <typoclass> @type intersect
05:47:49 <lambdabot> Eq a => [a] -> [a] -> [a]
05:48:29 <weebl> yes that is a problem
05:48:32 <typoclass> weebl: a solution would be to have two functions, joinList and joinState
05:49:01 <weebl> typoclass: any other way around, without having to create class instances?
05:49:43 <weebl> basically they both get a function join a b which works on an (Eq a) => a -> a -> a but one case a is a list of things and in the other case a is another datatype that is not a list
05:50:14 <typoclass> weebl: yes you could use a typeclass and two instances of it, but i recommend you try the basic solution first
05:50:29 <merijn> Or you could just pass the join function as extra argument?
05:50:54 <weebl> well, the framework is executed by two different functions each giving their own set of parameters
05:51:13 <weebl> so there is only one join at a time
05:52:01 <typoclass> weebl: if the join function is being called from two places, it shouldn't be difficult to change one place to joinList and the other place to joinState ...?
05:52:08 <quchen> What do Handles generated by Network do if the server connected to just dies (cable unplugged)? Will the C socket API issue a timeout, will there be an exception?
05:52:24 <weebl> typoclass: i'm not following
05:52:37 <quchen> Or do I have to test the handle with hIsOpen every now and then
05:52:38 <merijn> quchen: They throw an exception (argh!)
05:52:51 <weebl> in one place the join function is defined as joining two states and producing another, in the other place the join function is defined as joining two lists and producing another
05:52:59 <quchen> merijn: Dammit. Well, catchall to the rescue.
05:53:10 <merijn> quchen: Writing to a closed/disconnected socket is an error, reading from one returns a succesful read that returns an empty string (in C/everything)
05:53:45 <merijn> But somehow someone decided that reading from a closed socket should throw in haskell >.<
05:54:02 <typoclass> weebl: right. so wouldn't it be clearer to use a new function joinStates :: State -> State -> State in one place, and a new function joinLists :: [a] -> [a] -> [a] in the other place?
05:54:24 <quchen> merijn: Alright, hIsOpen and catchall it is. Hackidy hack
05:55:24 <weebl> typoclass: that's only a matter of naming
05:55:48 <typoclass> weebl: yes. it seems like an easy change to make
05:55:57 <weebl> but it won't fix the typing problem
05:56:21 <weebl> i don't think i've explained it clearly 1 sec
05:57:53 * merijn doesn't see a typing problem?
05:59:46 <weebl> http://www.weebl.me/weebl/hmm.hs
06:00:16 <weebl> merijn: i think i need something like join :: (Eq a) => a -> a -> a
06:00:22 <weebl> so it knows it can perform the join in both cases
06:01:15 <merijn> I have no clue what you're trying to do
06:01:44 <weebl> merijn: basically a monotone framework with different analyses
06:02:44 <applicative> in MF.hs, 'stuff is done with join', but it's somehow indifferent between lists and State's?
06:03:36 <typoclass> weebl: ah. could you give the type signature for MF.main? i think you'll see the problem then
06:03:48 <mr-> Suppose you have data Tree a = LeafType | Node (NodeType a) (ContainerType (Tree a)) where NodeType a = A a | B a and ContainerType a = [a] | [(a,a)]. Is there a (nice) way to constrain the ContainerType on the chosen NodeType? E.g. Node (A a) [a] is allowed, but not Node (B a) [a] ?
06:04:15 <weebl> typoclass: yes there lies the problem
06:04:16 <mr-> (I would really like to keep the tree-structure in that format, to allow for a minimal amount of boilerplate in an associated Zipper.)
06:04:19 <weebl> main wants a lot of [a]
06:04:29 <weebl> but in case of state is just a
06:04:33 <weebl> so i guess no other way than typeclass?
06:05:06 <applicative> why not NodeContainer a = A a [a] | B a [(a,a)]  , for example, mr-
06:05:24 <weebl> http://www.weebl.me/weebl/type.hs
06:05:37 <weebl> (MF.main is just something that calls run)
06:05:50 <applicative> no, that's not right; i'm not sure Im seeing it mr-
06:07:31 <mr-> applicative: I'll try a clearer hpaste
06:07:43 <weebl> typoclass: I want State and [OtherDataType] to be the same (Eq a), but I have never worked with classes before
06:07:59 <weebl> any good guide?
06:10:07 <merijn> Given [a] is there a good way to get all possible selection of 3 items from that list?
06:10:14 <merijn> :t permutations
06:10:16 <lambdabot> [a] -> [[a]]
06:11:09 <merijn> hmmm, maybe "nub . sort . map (take 3) . permutations"...
06:11:30 <merijn> oh, wait sort is redundant
06:11:46 <weebl> merijn: depends if you want combinations or permutations
06:11:57 <weebl> i.e. does the order matter
06:12:29 <merijn> :t nub . map (sort . take 3) . permutations
06:12:30 <lambdabot> Ord a => [a] -> [[a]]
06:12:50 <supki> merijn: http://stackoverflow.com/a/12872133/972985
06:13:26 <typoclass> weebl: the thing about typeclasses is that it's easy to overuse them. when first hearing about them, many beginners think "fantastic! i need to use typeclasses all over the place". but the intermediate haskeller doesn't use them all that much
06:13:38 <supki> should be trivial to modify to exclude repetitions
06:14:08 <merijn> Somehow I expect my version is simpler? :p
06:14:10 <weebl> typoclass: well an easy fix would be to copy MF.hs to MF2.hs, but this is undesirable
06:14:35 <typoclass> weebl: here's what i'd suggest: in MF.hs, turn on NoMonomorphismRestriction and write down the signature for MF.main. i suspect you'll end up with something similar to map
06:14:35 <supki> merijn: your version needs Ord
06:14:36 <typoclass> @type map
06:14:38 <lambdabot> (a -> b) -> [a] -> [b]
06:15:10 <typoclass> weebl: map does not know or care about what's in the list [a], it just cares that it gets a compatible function that can take an 'a'
06:16:01 <typoclass> weebl: i suspect it'll be the same for MF.main. it doesn't process the arguments itself, it doesn't need to know if that's a State or a list or whatnot. it only cares that it got a compatible function that can take two of those
06:16:07 <typoclass> weebl: does that make any sense?
06:16:15 <mr-> applicative: hope that makes more sense http://hpaste.org/89014
06:16:16 <weebl> yes very much sense
06:16:29 <weebl> so i guess something is probably wrong with the code or it actually is expecting some list in MF.hs
06:16:59 <typoclass> weebl: possibly it's the dmr. try {-# LANUGAGE NoMonomorphismRestriction #-}
06:17:02 <typoclass> @where dmr
06:17:03 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
06:17:13 <typoclass> weebl: ^^ here is some background information, if you want
06:18:12 <mr-> applicative: but maybe your first answer actually solves it already
06:18:34 <typoclass> weebl: anyway, explicitly writing down the type signature for MF.main is a good idea anyway. you can probably copy-paste it from type.hs and only make some edits
06:20:14 <mr-> applicative: no, not really, I think
06:20:51 <arborist> is it possible to have a value that is also a type, for example a function of type ([1,2] -> Integer ) ?
06:22:38 <typoclass> arborist: not really. (you might be able to approximate it if you have a new ghc and turn on all the latest stuff.)
06:23:29 <arborist> hm, thats too bad
06:24:11 <arborist> is it somehow possible to parameterize on values and only on types (like you can with templates in c++)?
06:24:29 <arborist> *not only on types
06:25:41 <arborist> so that for example you have a type (array of size n)
06:26:21 <Nimatek> arborist: Pattern matching and guards?
06:28:45 <arborist> would that be really a type? i mean you cant pass a number to a type contructor, can you?
06:30:53 <applicative> mr-: here's a maximally debauched version http://hpaste.org/89014
06:31:50 <merijn> arborist: No, you can't have dependent types in Haskell
06:32:17 <merijn> arborist: You can get pretty close if you like, but that's more the type of thing Agda/Coq/Idriss do
06:32:22 <elliott> you can have a type for array of size n
06:32:26 <elliott> that's not necessarily dependent types at all
06:32:33 <merijn> Sure
06:32:34 <applicative> arborist: you can have a type for array of size n
06:32:35 <elliott> GHC has specific support for type-level naturals these days, in fact
06:32:43 <applicative> you just can't prove any good theorems
06:32:51 <merijn> elliott: I know, but parameterising those over values is non-trivial
06:33:02 <mr-> applicative, thanks! (That will take a while to understand :-)
06:33:06 <arborist> how would i do that, or where can i read about it?
06:33:19 <elliott> you don't have the dependent function arrow, but that's not the same thing
06:33:23 <typoclass> arborist: i think it'd help if you could specify some more what you're planning
06:33:28 <elliott> arborist: I think the GHC manual describes type literals and such
06:33:33 <elliott> the support is kind of incomplete in 7.6
06:33:39 <elliott> I think GHC HEAD has better stuff
06:33:46 <merijn> arborist: DataKinds, TypeFamilies, promoted literals, etc. are all good places to start
06:33:52 <Nimatek> arborist: Depending on what you're trying to do, you might not need it.
06:34:03 <applicative> arborist: you need it!
06:34:09 <Nimatek> Make sure your problem is not of the type
06:34:17 <Nimatek> > let f [] = "empty"; f [a,b] = show a ++ show b; f _ = "wrong size" in f [] ++ f [1,2,3] ++ f [1,2]
06:34:18 <lambdabot>   "emptywrong size12"
06:34:20 <Nimatek> "emptywrong size12"
06:34:27 <Nimatek> Err yeah.
06:35:33 <applicative> arborist: implementations of 'length indexed vectors' in Haskell are all over the internets
06:35:34 <arborist> typoclass, im basically just trying to have a function which takes n arguments, and builds on that with other functions
06:35:35 <typoclass> arborist: since you initially mentioned [1,2], you could also simply use a tuple to say "something that has two parts"
06:36:37 <Hodapp> weeee, just picked up the O'Reilly book, 'Real World Haskell'
06:36:43 <arborist> i mean, an n-tuple would basically be enough, but i want the length to be compiler enforced
06:36:45 <Hodapp> apologies ahead of time for the stupid questions I'll ask here
06:36:54 <applicative> arborist: http://hackage.haskell.org/packages/archive/VecN/0.0.2/doc/html/src/Data-VecN.html
06:36:57 <arborist> otherwise i could just use something like Integer->a
06:37:07 <elliott> don't worry. we specialise in stupid questions
06:37:18 <arborist> applicative, thanks
06:37:20 <applicative> we love 'stupid' questions Hodapp here; the other ones just cause a fight to break out
06:37:56 <arborist> i was just trying to do the naive mathematical way of having an n-tuple to be a funcion {1,..,n} -> a
06:37:59 <Hodapp> long as you don't kickban me for not using $your_favorite_build_system
06:38:04 <t7> whats hodapp?
06:38:04 <applicative> we like to scamble to words in our sentences too, keeps the CIA off the scent
06:39:49 <typoclass> arborist: there's also the "printf" wizardry to get varargs functions in haskell. not sure if that's what you're looking for
06:40:16 <typoclass> arborist: i guess it's jumping in at the deep end, but you could start with http://hackage.haskell.org/trac/ghc/wiki/TypeNats/Basics
06:42:37 <arborist> typoclass, thanks, ill read it, these things seem to be much easier if you dont have to specify the type in advance
06:43:51 <Fuuzetsu> @package vector
06:43:52 <lambdabot> http://hackage.haskell.org/package/vector
06:44:54 <Hodapp> t7: hodapp is... me.
06:45:20 <arborist> typoclass, actually this looks like its doing what i want
06:45:26 <t7> oh i thought it might be like hadoop
06:47:15 <quchen> I've got a ton of actors that should all be able to print stuff to the console. I'm assuming the best way of making this play out nicely is by having a channel to a dedicated printing thread, am I right?
06:48:24 <quchen> Basically this: printer chan = forever . join $ readChan chan
06:48:38 <quchen> printer :: IO (IO ())
06:48:53 <Hodapp> t7: I predate Hadoop!
06:50:00 <quchen> Disregard the eta reduction and the wrong type above :s
06:50:02 <typoclass> quchen: i'd use an MVar or similar and a thread that does takeMVar and prints it in a forever loop
06:50:34 <quchen> typoclass: That would also work. I was just wondering whether there's a better approach.
06:50:36 <applicative> quchen: I dont know that youve described something more than is in reminder.hs here though http://ofps.oreilly.com/titles/9781449335946/sec_forking.html
06:52:27 <Hodapp> t7: but no, Hodapp is just a last name of German origin.
06:53:21 <t7> ah ok
06:53:33 <Fuuzetsu> How can I check my base version?
06:53:40 <applicative> Hadoop was invented by Meredith Hodapp
06:53:45 <quchen> applicative: That code has the same issues I'm trying to avoid ;-)
06:54:18 <typoclass> Fuuzetsu: ghc-pkg list?
06:54:19 <applicative> right
06:54:45 <applicative> quchen: the issues were the part that went unstated
06:55:29 <supki> quchen: I use TQueue for that task
06:55:59 <quchen> Alright, dedicated printer thread it is. Thanks guys.
06:56:25 <Fuuzetsu> Right. Data.Vector seems to want Typeable1 from Data.Typeable even though that seems to have been removed in February in the newest base (4.7) and Data.Vector has base 4.* dependency. This should be reported, right?
06:57:26 <typoclass> Fuuzetsu: i suppose so!
06:57:27 <mauke> http://www.haskell.org/haskellwiki/Type_arithmetic#A_Really_Advanced_Example_:_Type-Level_Lambda_Calculus  <- this looks pretty easy, actually
06:57:46 <Fuuzetsu> Just checking~
06:58:31 * hackagebot cabal-rpm 0.8.0 - RPM package creator for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.8.0 (JensPetersen)
07:01:03 <merijn> argh
07:01:33 <merijn> ok, my functions for getting a bunch of triplets has a runtime of infinity (well, not really, but close!)
07:02:09 <applicative> Fuuzetsu: it seems the hackaged version has base==4.*, others   Build-Depends: base >= 4 && < 5
07:02:19 <applicative> e.g. https://github.com/rleshchinskiy/vector/blob/master/vector.cabal
07:02:49 <merijn> Given a list of elements I want to find every selection of 3 elements from that list
07:02:52 * applicative is having trouble with 'not really infinite, but close'
07:02:56 <Fuuzetsu> It still fails on 4.7. The fix seems to be here http://trac.haskell.org/vector/ticket/91
07:03:12 <merijn> applicative: Long enough that I SIGINT'ed the computation
07:03:12 <Fuuzetsu> It seems that the bug tracker is being ignored by the maintainers though.
07:03:18 <merijn> applicative: i.e. too long to wait
07:03:35 <merijn> @hoogle [a] -> Int -> [[a]]
07:03:35 <lambdabot> Prelude drop :: Int -> [a] -> [a]
07:03:35 <lambdabot> Data.List drop :: Int -> [a] -> [a]
07:03:35 <lambdabot> Prelude take :: Int -> [a] -> [a]
07:03:53 <Fuuzetsu> In fact, they even have an issue on GitHub https://github.com/rleshchinskiy/vector/pull/1
07:04:02 <applicative> Fuuzetsu: yes, I think the library is in a giant state of flux
07:04:38 <applicative> isn't it a boot library for ghc these days, or something like one?
07:04:46 <Aetherspawn> Heads up, 400 bounty is still available on this question; http://stackoverflow.com/questions/16757060/haskell-conduit-one-processing-conduit-2-io-sources-of-the-same-type
07:04:57 <Aetherspawn> 15 upvotes, 5 favs and its still a virgin question ;__;
07:05:54 <applicative> Fuuzetsu: what module is the Typeable instance in?
07:05:55 <supki> I upvote questions where I didn't understand anything
07:06:05 <Fuuzetsu> applicative: Data.Typeable
07:06:16 <Fuuzetsu> oh, for vector?
07:06:59 <paullik> Hi. I'm currently transforming a list of Ints into a String like this: foldl (\acc x -> acc ++ show x) "" [1,2] Is there any better way?
07:07:35 <supki> > concatMap show [1,2]
07:07:37 <lambdabot>   "12"
07:07:43 <Fuuzetsu> applicative: You're right, the vector in ghc boot does seem to have the patch applied
07:08:37 <applicative> Fuuzetsu: this is indeed a little confusing ...
07:08:57 <supki> > [1,2] ^.. folded . to show . folded
07:08:59 <lambdabot>   "12"
07:09:45 <paullik> supki, wtf is the second method? :)) thanks I;'ll use the first
07:11:05 <Aetherspawn> "folded . to show . folded" lol'd
07:11:10 <Aetherspawn> could it get any more english'ey
07:11:15 <supki> paullik: that's lens
07:11:36 <supki> paullik: main difference between your way and concatMap is that concatMap is lazy
07:11:39 <supki> > concatMap show [1..]
07:11:41 <lambdabot>   "12345678910111213141516171819202122232425262728293031323334353637383940414...
07:11:57 <paullik> supki, oh, that's good then
07:20:01 <magicman> > [1..] ^.. folded . to show . folded
07:20:03 <lambdabot>   "12345678910111213141516171819202122232425262728293031323334353637383940414...
07:20:38 <Cale> paullik: Another reason to prefer foldr is that fully computing xs ++ ys takes O(length xs) steps
07:20:41 <magicman> Some day, I'll learn lens. And conduit/pipes/whateverees.
07:21:07 <shachaf> > [1..]>>=show
07:21:08 <lambdabot>   "12345678910111213141516171819202122232425262728293031323334353637383940414...
07:21:17 <paullik> omg
07:21:41 <paullik> so many possibilities
07:22:15 <Cale> paullik: So if you left-associate like that, you end up with an operation that's more or less O(n^2)
07:23:02 <Cale> magicman: Well, lens is a good bit separate from those others.
07:23:22 <Cale> paullik: >>= in the list monad is exactly concatMap
07:23:39 <Cale> (well, flip concatMap if we want to be picky)
07:23:51 <paullik> Cale, I'm not that advanced, yet
07:24:14 <Cale> For lists, (>>=) :: [a] -> (a -> [b]) -> [b]
07:24:41 <startling> :t \x -> ((x :: [Integer]) >>=)
07:24:42 <lambdabot> [Integer] -> (Integer -> [b]) -> [b]
07:24:44 <paullik> though I;m thinking about what you said regarding foldr, why is it that it takes onle O(length xs) to append two lists?
07:26:13 <h4199> sidenote: [1..]>>=show is Champernowne's constant
07:26:50 <h4199> err the fraction
07:27:30 <paullik> oh, ok I get what >>= is and how it's analogous to flip concatMap
07:28:28 <enigmuriatic> http://stackoverflow.com/questions/16846584/parse-error-on-input-in-haskell-if-then-else-conditional        can anyone help me out with this? the only answer i got didn't work.
07:31:03 <Cale> enigmuriatic: In what way didn't it work?
07:31:44 <supki> enigmuriatic: that might not be obvious but if-then-else does not inherit do notation
07:31:47 <Cale> enigmuriatic: Did you get the alignment right on subsequent lines? It's important that they start in the same column as the 'l' in 'let' if you write it like that.
07:33:12 <Cale> enigmuriatic: What error message are you getting, and what's your current code?
07:33:24 <enigmuriatic> hi, sorry Cale, just saw this
07:33:26 <enigmuriatic> hold on a sec
07:33:45 <enigmuriatic> Cale, the full description is in the StackOverflow post
07:33:55 <enigmuriatic> when i made the suggested change I still got the same error
07:33:59 <Cale> Well, the answer that you got from sclv should be correct
07:34:14 <Cale> That suggests your alignment is screwed up
07:34:54 <Cale> Make sure that (1) there are no tab characters in your file, and that (2), the c in "conn <-" is in the same column as the 'l' in "let myTrades ..."
07:36:08 <enigmuriatic> it worked! thanks Cale
07:36:13 <Cale> no problem
07:36:19 <enigmuriatic> you were right, it was the alignment with let
07:36:27 <enigmuriatic> that's a weird syntax rule
07:36:57 <Cale> The first non-whitespace character after 'let', 'do', 'of', or 'where' sets the column for that block of code
07:37:10 <Cale> any line which starts in a shallower column closes the block
07:37:39 <sclv_> https://en.wikipedia.org/wiki/Off-side_rule
07:37:57 <Cale> In this case, you want the subsequent lines to belong to the do-block, so they need to start in the same column as the first non-whitespace character after the 'do', which was the 'l' in 'let'
07:38:28 <Cale> If you wanted to put some more definitions into the 'let', you'd have to align them an additional 4 spaces deeper
07:38:49 <Cale> any deeper than that, and it would be a continuation of the definition of myTrades
07:38:52 <enigmuriatic> Cale, can you do me a favor and describe to me why I needed that second do block
07:39:04 <Cale> Because if/then/else is an expression form
07:39:21 <Cale> This entire if/then/else is all one statement of the containing do-block
07:39:34 <merijn> @hoogle [a -> b] -> a -> [b]
07:39:35 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
07:39:35 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
07:39:35 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
07:40:05 <Cale> and we're writing an expression which needs to be a single IO action
07:40:19 <sclv_> merijn: sequence!
07:40:22 <sclv_> ?ty sequence
07:40:23 <lambdabot> Monad m => [m a] -> m [a]
07:40:25 <Cale> do-notation serves to glue IO actions (among others) together into a single one
07:40:36 <sclv_> if you're in the unwrapped reader then that gives you what you want
07:40:54 <enigmuriatic> thanks Cale, i think i get it
07:40:56 <sclv_> i am dissapoint in hoogle not catching that
07:41:08 <Cale> There's no special rule for when if/then/else occurs inside do
07:41:34 <Cale> If there were, maybe we could avoid the need to put another do there, but it's not a big deal :)
07:42:04 <geekosaur> enigmuriatic, you might note that 'do' is not actually a block in the sense of other languages; it's syntactic sugar for an expression. the 'if' is another expression, and if you want to use 'do' syntax in one expression-leg of the 'if' then you need to switch back into the 'do' syntactic sugar for that expression
07:44:03 <Cale> Yeah, you should think of it as being that the outermost do-expression is gluing a bunch of IO actions together, one of which is "if ... then ... else (do ...)"
07:44:57 <Cale> and then the inner do is also gluing some more together, because each branch of the if needs to be an IO action, in order for the if expression itself to be an IO action
08:03:30 <enigmuriatic> say I'm using an Either type in a main do block. what's the best way to handle the error?
08:04:14 <tazjin> @type either
08:04:16 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
08:04:33 <elliott> enigmuriatic: case ... of
08:04:35 <tazjin> enigmuriatic: You can use that function to pass two "handlers" (one for left, one for right) and the value and then execute the appropriate one
08:05:18 <tazjin> Do we have any aeson gurus here? I feel like I'm not using it correctly in the bindings I'm writing to Google's Admin SDK. It seems much to verbose, repetitive and redundant: https://github.com/tazjin/hs-google-adminsdk/blob/master/Google/AdminSDK/Users/JSON.hs
08:05:19 <shachaf> case-of is the default. Learn to use the primitive first, and then you can use either etc.
08:06:28 <applicative> or are you thinking you want some sort of 'error monad' enigmuriatic
08:06:49 <tazjin> Basically what I'm asking is: Is there anything like stepcut's boomerang for aeson? (parsing and printing in the same definition)
08:08:56 <enigmuriatic> applicative, i don't know what a monad is
08:08:59 <enigmuriatic> so i'm not sure
08:09:10 <latermuse> how do i set GHC to use a different character encoding?
08:09:47 <latermuse> so instead of utf8, i can use shift-jis or big5
08:09:50 <applicative> tazjin: you are avoiding the aeson template haskell machinery on high principle?
08:09:53 <enigmuriatic> tazjin, i was using Aeson yesterday and found this helpful: http://blog.raynes.me/blog/2012/11/27/easy-json-parsing-in-haskell-with-aeson/    however, only trust the code at the end, some of the stuff in the middle has mistakes
08:10:02 <applicative> I know I do
08:10:48 <tazjin> applicative: No, but there are some things in Google's API that I probably can't represent in a way that their TH would pick up correctly
08:11:35 <tazjin> applicative: For example, in their directory service a phone number / IM / address / mail etc. has a "type", which can be "home, work, other, custom". If custom is selected you need to render an additional field in the JSON object that is not usually there and stuff like that
08:12:42 <monochrom> latermuse: in System.IO, look for hSetEncoding etc. there is a whole section on it
08:17:58 <enigmuriatic> Couldn't match expected type `BS.ByteString'
08:17:59 <enigmuriatic>                 with actual type `Data.ByteString.Internal.ByteString'
08:18:04 <enigmuriatic> how are those different?
08:19:28 <enigmuriatic> BS is an alias for Data.Bytestring.Lazy.Char8
08:20:28 <KSkrzet> by default GHC uses block-buffering when output is file (but also pipe |), can I somehow override this with environment? I want this behaviour to apply to cabal and cabal-dev when piping the output to tee
08:22:04 <dcoutts_> KSkrzet: there might be a trick with a ptty, since the default for a terminal is line buffering
08:23:32 <magicman> @type local
08:23:33 <monochrom> enigmuriatic: that's exactly it. Data.Bytestring is not Data.Bytestring.Lazy
08:23:33 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
08:24:15 <magicman> @type \f g -> local f (ReaderT g)
08:24:16 <lambdabot> Monad m => (r -> r) -> (r -> m a) -> ReaderT r m a
08:24:50 <magicman> Any particular reason why that has a Monad constraint?
08:24:59 <enigmuriatic> monochrom, how are they substantially different, though? can i just cast one into another?
08:25:07 <elliott> what do you mean by cast?
08:25:25 <merijn> magicman: ReaderT is only a MonadReader if m is a monad
08:25:29 <magicman> I don't think it needs it. Isn't its definition basically "local f (ReaderT $ \r -> runReaderT (f r))?
08:25:30 <KSkrzet> dcoutts_: do you mean there is a bug somewhere or that I should do some tricks with tty settings or something else?
08:25:55 <magicman> Ah, and it's a method of MonadReader.
08:25:56 <merijn> magicman: It's because it's using Control.Monad.Reader.local instead of Control.Monad.Trans.Reader.local
08:25:56 <magicman> Mneh.
08:26:05 <merijn> :t Control.Monad.Reader.local
08:26:06 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
08:26:11 <merijn> :t Control.Monad.Trans.Reader.local
08:26:13 <lambdabot> Monad m => (r -> r) -> ReaderT r m a -> ReaderT r m a
08:26:22 <dcoutts_> KSkrzet: no bug, I just mean you might be able to do some unix tricks with running the program connected to a pseudo tty
08:26:23 <merijn> whoops, nope. Still a Monad :p
08:26:46 <merijn> dcoutts_, KSkrzet: Sounds like a good use for the "posix-pty" library I'm working! ;)
08:27:07 <merijn> Granted, that's nowhere near finished enough to be actually used for anything >.>
08:27:18 <enigmuriatic> elliott, explicitly convert with ::
08:27:25 <elliott> enigmuriatic: :: never does any conversion
08:27:31 <merijn> enigmuriatic: "::" doesn't convert
08:27:36 <elliott> (a :: t) is only well-typed if t is a specialisation of a's type
08:27:36 <enigmuriatic> what does it do?
08:27:50 <elliott> (e.g. (3 :: Int) works because 3 has type Num a => a, and Int is a specialisation of that)
08:27:57 <merijn> enigmuriatic: It's just a type annotation, it tells the compiler to be less polymorphic than possible
08:28:01 <elliott> (or (undefined :: Int -> Int -> String) works because undefined has type a)
08:28:20 <elliott> :: only "casts" from some type to the same type :)
08:28:38 <merijn> :t (id :: Int -> Int)
08:28:39 <lambdabot> Int -> Int
08:28:50 <enigmuriatic> well, say i have a value of type Data.ByteString.Internal.ByteString and i want it to be BS.Bytestring
08:28:54 <elliott> you can imagine doing, e.g. asTypeOf :: a -> a -> a; a `asTypeOf` b = a. and then saying 3 `asTypeOf` (undefined :: Int) all the time
08:28:54 <enigmuriatic> how do i do that?
08:28:58 <elliott> and that's exactly the same as using :: directly
08:29:29 <merijn> enigmuriatic: That name sounds like you shouldn't be getting things of that type...
08:29:41 <elliott> enigmuriatic: if BS is Data.ByteString then those are the same type
08:29:49 <elliott> Data.ByteString re-exports ByteString from Data.ByteString.Internal
08:30:12 <enigmuriatic> it's data that's coming out of one module and into another so i don't have much choice
08:30:48 <enigmuriatic> BS is Data.ByteString.Lazy.Char8
08:31:14 <elliott> ew, you shouldn't be using Char8 :) but anyway, there is a toStrict function in Data.ByteString.Lazy.
08:31:19 <elliott> http://hackage.haskell.org/packages/archive/bytestring/0.10.2.0/doc/html/Data-ByteString-Lazy.html#g:2
08:31:26 <elliott> note its disclaimer
08:31:41 <elliott> also note that lazy bytestrings can be infinite in length. you can't convert those to strict bytestrings
08:31:54 <FreeFull> > 'a' :: Double
08:31:55 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
08:31:56 <lambdabot>              with actual ty...
08:32:54 <KSkrzet> dcoutts_: I did a bit of Googling but it looks rather complex. I wish there would be simple env variable or similar way of controlling the defaults that GHC picks
08:33:31 <dcoutts_> KSkrzet: it's following the same default behaviour as libc I think, and that's not configurable either from outside the program
08:33:44 <dcoutts_> obviously the program itself can always set the buffering mode
08:43:52 <Sculptor> yo
08:46:41 <quchen> What's the difference between `newTChanIO` and `atomically newTChan`?
08:47:01 <quchen> The types would match, but why would there be a dedicated function for it if they were identical?
08:48:05 <enigmuriatic> is there any obvious reason why Network.Download would return "Failed to connect: network is unreachable"? i couldn't find anything substantial on Google
08:48:38 <merijn> quchen: Nothing
08:48:55 <quchen> merijn: Excellent, thanks.
08:49:13 <merijn> quchen: The former exists because its shorter/cleaner and it's so incredibly common to want to create one in IO
08:49:40 <quchen> merijn: Yet there's no analogon for dupTChan(IO)
08:49:46 <quchen> That's what I need
08:49:48 <merijn> Oh
08:49:54 <merijn> The docs says why
08:49:55 <simukis_> enigmuriatic: Well… you failed to establish connection to target. That can fail any way from your internet link being unavailable to failed DNS lookup.
08:49:58 <merijn> "IO version of newTChan. This is useful for creating top-level TChans using unsafePerformIO, because using atomically inside unsafePerformIO isn't possible."
08:50:29 <quchen> Aaah, I didn't understand that sentence.
08:50:32 <quchen> Now I do.
08:50:39 <merijn> quchen: It lets you write "foo :: TChan a; foo = unsafePerformIO newTChanIO {-# PRAGMA NOINLINE #-}"
08:50:40 <quchen> So if you're not doing dirty hacking, they are the same. :-)
08:50:57 <geekosaur> enigmuriatic, "network is unreachable" comes from the OS and suggests some connectivity issue. At a guess, you need to use a proxy; this is not automatic, because proxies are generally somewhat complex and I doubt Network.Download contains a Javascript interpreter to deal with PAC
08:52:08 <geekosaur> simukis_, "network unreachable" is not failed DNS lookup
08:52:43 <simukis_> geekosaur: but DNS lookup can be a cause…
08:52:48 <geekosaur> it means the OS network stack does not have a route that can reach the target address
08:53:49 <adas> i have a hex string and i need a way to represent it as a sequence of 4 bit nibbles (1 set of 4 bits per hex char). Does anyone have a suggestion or hint as to how I might accomplish this?
08:54:36 <merijn> Wait...GHC can automarshall Int to CInt on FFI calls?! Why have I been doing this manually all this time?! >.<
08:56:02 <tromp> > map digitToInt "1234ABCF"
08:56:04 <lambdabot>   [1,2,3,4,10,11,12,15]
08:56:04 <dcoutts_> merijn: no no, it will turn Int into HsInt on the C side
08:56:27 <dcoutts_> merijn: HsInt is defined in HsFFI.h and is not the same as C's int.
08:56:38 <dcoutts_> merijn: so don't do that, use CInt
08:56:51 <merijn> Aww :(
08:57:01 <dcoutts_> HsInt is only suitable for C code where you know you're working with Haskell code
08:57:20 <merijn> What is HsInt's C type?
08:57:36 <dcoutts_> depends on your Haskell implementation and platform
08:58:41 <merijn> Meh, I'm just calling out to my code anyway, I can just change that to use HsInt and then rely on C to convert that to appropriate C type
08:58:55 <dcoutts_> merijn: it has to allow a round trip, so it's easy to guess what it is
08:59:08 <dcoutts_> ghc's Int is 32 or 64bit signed, so ...
08:59:20 <adas> tromp: that does solve a part of the problem - )
09:00:38 <supki> > "12ef" ^.. folded . to ((fromIntegral :: Int -> Word8) . digitToInt) . dropping 4 (backwards bits)
09:00:40 <merijn> dcoutts_: In my case I'm just passing smallish integers to my own code (smallish being <10k)
09:00:40 <lambdabot>   [False,False,False,True,False,False,True,False,True,True,True,False,True,Tr...
09:01:22 <supki> adas: does it look like what you want? ^
09:01:28 <dcoutts_> merijn: so it'll be a typedef for either int or long int
09:02:30 <acube> dropping
09:02:34 <acube> @ty dropping
09:02:35 <lambdabot> (Applicative f, Conjoined p) => Int -> Over p (Control.Lens.Internal.Indexed.Indexing f) s t a a -> Over p f s t a a
09:02:56 <acube> @ty dropping 4 id
09:02:58 <lambdabot> Applicative f => Over (->) f t t t t
09:03:38 <acube> base 16 # "12ef"
09:03:42 <acube> > base 16 # "12ef"
09:03:43 <lambdabot>   No instance for (GHC.Real.Integral [GHC.Types.Char])
09:03:43 <lambdabot>    arising from a use ...
09:03:59 <acube> > "12ef" ^? base 16
09:04:01 <lambdabot>   Just 4847
09:04:19 <adas> supki: that looks way beyond me
09:05:04 <applicative> adas see http://hackage.haskell.org/packages/archive/bytestring/0.10.0.1/doc/html/Data-ByteString-Lazy-Builder-ASCII.html maybe?
09:06:01 <acube> > "12ef" ^?! base 16 . dropping 4 (backwards bits)
09:06:03 <lambdabot>   *Exception: stack overflow
09:06:07 <acube> :O
09:06:14 <antoineB> is hakell the typed lisp?
09:06:26 <supki> @ty base
09:06:27 <lambdabot> (Integral a, Applicative f, Choice p) => Int -> p a (f a) -> p String (f String)
09:06:32 <tromp> @let nibble  n = tail $ showIntAtBase 2 intToDigit (16+n) ""
09:06:34 <lambdabot>  Defined.
09:06:37 <supki> acube: I think it picks Integer
09:06:51 <tromp> > "1234ABCF" >= (nibble . digitToInt)
09:06:53 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
09:06:53 <lambdabot>              with actual ty...
09:07:14 <tromp> > nibble 12
09:07:15 <lambdabot>   "1100"
09:07:18 <acube> > "12ef" ^?! (base 16 :: Prism' String Int) . dropping 4 (backwards bits)
09:07:20 <lambdabot>   False
09:07:25 <adas> applicative: yes. thats what i was looking at earlier. thanks
09:07:31 <applicative> adas toLazyByteString $ word16HexFixed 200 = "00c8"
09:07:33 <applicative> oh
09:07:46 <acube> > "12ef" ^.. (base 16 :: Prism' String Int) . dropping 4 (backwards bits)
09:07:47 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
09:08:12 <adas> its just that .. i need to do some bit manipulation
09:09:27 <tromp> > "1234ABCF" >= return
09:09:28 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
09:09:29 <lambdabot>              with actual ty...
09:11:14 <applicative> adas what kind of manipulation?  and where are you getting the hex things from?
09:11:43 <applicative> > "1234ABCF" >>= return
09:11:45 <lambdabot>   "1234ABCF"
09:13:30 <applicative> > "1234ABCF" >>= show
09:13:32 <lambdabot>   "'1''2''3''4''A''B''C''F'"
09:14:13 <adas> the hex string is just a random hex string to learn how to convert hex to base64
09:15:18 <antoineB> i asked this yesterday, is hackell template comparable to lisp macro?
09:15:37 <merijn> antoineB: Define comparable
09:15:50 <Clint> define "hackell"
09:16:10 <antoineB> lisp macro are function that take an ast and return an ast
09:16:19 <antoineB> is haskell template behave the same
09:17:09 <antoineB> hackell ic a cuper language?
09:18:51 <tromp> > "1234ABCF" >>= (nibble . digitToInt)
09:18:53 <lambdabot>   "00010010001101001010101111001111"
09:23:35 * hackagebot monomorphic 0.0.3.0 - Library to convert polymorphic datatypes to/from its monomorphic represetation  http://hackage.haskell.org/package/monomorphic-0.0.3.0 (HiromiIshii)
09:24:16 <applicative> @elite haskell is a super-language
09:24:16 <lambdabot> |-|asxeLl I$ 4 $UpEr-|ANguage
09:26:15 <antoineB> is haskell vm support change of a function on the fly?
09:26:37 <applicative> oh yeah, you just give it an extra parameter
09:26:56 <applicative> like, it can be (+1) or (+2) depending on what the second argument is
09:27:13 <applicative> WHO n33dS 1isP whEN tHEY caN |-|aVE ha5x311?
09:28:12 <applicative> main = getArgs >>= \[x] -> print $ 3 + read x
09:28:31 <applicative> it totally decides on the fly what function to apply to 3
09:29:16 <applicative> @can haskell runtime support change of a function on the fly?
09:29:16 <lambdabot> Maybe you meant: faq map run wn
09:29:23 <applicative> @faq can haskell runtime support change of a function on the fly?
09:29:23 <lambdabot> The answer is: Yes! Haskell can do that.
09:29:32 <mingsping> hello. what would you suggest to program when i want to encounter monads? i already saw arithmetic evaluators. now i want to program a good example for monads by myself, for a better understanding
09:29:36 <mingsping> can someone help?
09:30:10 <applicative> there's a lot of monads out there mingsping
09:30:19 <antoineB> ok
09:30:21 <applicative> be careful!!
09:30:45 <elliott> mingsping: you can "encounter monads" in very disparate, practically unrelated settings. but: an interpreter for a language with state and/or errors, or a parser, are two good examples.
09:30:53 <applicative> mingsping: make a parser type
09:30:54 <bergey> mingsping: I liked writing a parser (using the parsec library) to get hands-on with monads
09:30:55 <elliott> really you "encounter monads" whenever you write an IO program using do notation.
09:31:32 <applicative> data Parser a = Parser {runParser:: String -> [(String, a)]} is the priceless classic
09:31:47 <mingsping> elliott, yes thats right, IO is a monad
09:32:15 <kryft> That reminds me that I should probably finish slogging through chapter 10 of RWH at some point
09:32:26 * elliott thinks Maybe (String, a) is more obvious to people
09:32:31 <elliott> and matches what people do in practice better
09:32:37 <mingsping> and the others.. I already saw parsers and interpreters. they're, as you said, the classics
09:32:55 <elliott> then I'd say: you know enough
09:33:20 <elliott> no use waiting for the magic moment where you "understand" "monads"; you've seen how they're a useful abstraction, a deeper intuition about them will develop in time
09:33:20 <applicative> newtype Parser a = Parser {runParser :: String -> Maybe (String, a)}
09:33:45 <applicative> instance Monad Parser where return a = Parser (\string -> Just (string, a))
09:33:59 <applicative> see mingsping we're monad-mad here
09:34:40 <applicative> parse (Parser parser string) = parser string
09:35:13 <elliott> that parse is a bit off :)
09:35:18 <kryft> Was there a list of ideas for first haskell projects somewhere?
09:35:27 <acube> parse = runParser
09:35:33 <applicative> ooh bad brackets
09:35:53 <applicative> parse (Parser parser) string = parser string
09:36:05 <applicative> or you can take the low road like that acube  character
09:36:44 <merijn> @where exercises -- kryft: like these?
09:36:44 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
09:37:32 <merijn> kryft: Implementing a simple compiler is also a good start
09:38:29 <applicative> i think we should recommend that to mingsping .  Start with arithmetical expressions, soon enough you are writing a compiler.  It's a gateway drug.
09:38:30 <kryft> merijn: You mean a simple compiler for some other language, like the 'write yourself a scheme' tutorial?
09:38:59 <mingsping> yes, that would be interesting,
09:39:03 <mingsping> the scheme thing
09:39:34 <applicative> mingsping: it has a nice use of the bread and butter parser machinery, the write a scheme tutorial
09:39:43 <mingsping> i think that'll be the next project
09:39:49 <mingsping> thank you guys :-)
09:40:30 <merijn> kryft: Yeah
09:40:35 <applicative> mingsping: our comrades are here to explain opaque type errors and depraved type-system extensions at all hrs
09:40:57 <merijn> kryft: Or like a simple C inspired language (I say inspired, since C has lots of hairy and tricky corners)
09:41:23 <merijn> kryft: You could even write a simple lambda calculus implementation to learn more about haskell
09:41:44 <applicative> first write a parser that can tell whether the curly brackets are matched
09:41:46 <mingsping> thank you
09:41:49 <applicative> then move on to the semicolon
09:43:25 <merijn> hmm, is there a cleaner alternative for code like this? "alloca $ \ptr1 -> alloca $ \ptr2 -> do {- stuff -}"?
09:43:28 <kryft> merijn: I've never written a compiler in any language, so I guess that would be two birds with one stone. :P
09:44:05 <merijn> kryft: I think it's something that's 1) easier/simpler than you'd expect and 2) infinitely helpful in understanding programming
09:44:18 <applicative> let alloca2 phi = alloca $ \ptr1 -> alloca $ \ptr2 -> phi ptr1 ptr2
09:44:45 <merijn> applicative: That's not much better, tbh
09:44:53 <applicative> @pl alloca2 phi = alloca $ \ptr1 -> alloca $ \ptr2 -> phi ptr1 ptr2
09:44:54 <lambdabot> alloca2 = alloca . (alloca .)
09:45:08 <applicative> yeah but what if @pl it?
09:45:12 <kryft> merijn: I've kind of had a hunch that at least 2 is true (and probably 1 as well), and that's why it's been on my todo list for a while.
09:45:57 <merijn> kryft: Fortunately compilers are mostly parsing and AST manipulation and haskell has parsec for the former and ADTs for the latter
09:46:28 <merijn> @pl alloca $ \ptr1 -> alloca $ \ptr2 -> foo ptr1 ptr2
09:46:28 <lambdabot> alloca (alloca . foo)
09:46:53 <merijn> yeah, that doesn't really work if foo is a do block instead of a function :\
09:47:39 <applicative>  alloca . (alloca .) $ \phi1 phi2 -> do {- some stuff -}
09:47:40 <kryft> merijn: It would kind of be nice to understand how parsing actually works under the hood, but maybe learning how to use parsec first is a good stepping stone? (I did read a bit about parsing in a compiler textbook, but I didn't get to the actual parsing yet. :)
09:48:37 <merijn> There isn't much "under the hood"
09:48:48 <kryft> merijn: (Although it seems that parsec uses a different parsing paradigm from the traditional approaches)
09:48:55 <kryft> merijn: Oh?
09:49:11 <merijn> Implementing your own minimal Parser monad is simple
09:49:13 * applicative looks under the hood of newtype Parser a = Parser (String -> [(String,a)]) etc
09:50:00 <applicative> @elite newtype Parser a = Parser (String -> Maybe (String, a))
09:50:01 <lambdabot> NeW7yPe p4rseR 4 = paRs3R (string -> m4y8E (s+rinG, A))
09:50:36 <barrucadu> …the combination of @pl and @elite could be horrific
09:50:57 <merijn> kryft: Start with "newtype Parser a = Parser (String -> Maybe (a, String))" and start defining commbinators and Functor/Monad/Applicative instances
09:51:27 * elliott advocates: (String, a) instead
09:53:19 <merijn> kryft: "parseChar :: String -> Maybe (a, String); parseChar [] = Nothing; parseChar (c:cs) = Just (c, cs); charParser :: Parser Char; charParser = Parser parseChar"
09:54:11 <merijn> "instance Functor Parser where fmap :: (a -> b) -> Parser a -> Parser b"
09:54:49 <merijn> "instance Monad Parser where return :: a -> Parser a; (>>=) :: Parser a -> (a -> Parser b) -> Parser b"
09:55:27 <merijn> kryft: Hell, start with that and build your own simple parser if you wanna do everything from scratch :p
09:55:40 <merijn> kryft: It won't be a feature rich/efficient as parsec, but it's certainly not hard :p
09:56:29 <kryft> merijn: Ok, so basically parseChar tries to parse a char and either succeeds or fail, and then you can combine simple parsers like these to produce parsers for more complicated structures
09:56:41 <merijn> kryft: Yes
09:57:17 <merijn> kryft: Which the same as parsec, except that it comes with a ton of predefined parsers and things like the ability to parse types other than String (think Text, ByteString, arbitrary lists)
09:58:01 <kryft> merijn: Right
09:58:33 <merijn> Something like "newtype Parsec a s b = Parsec (([a], s) -> (Maybe (b, [a]), s)" (s is a parser state, basically building State into your parser)
09:59:04 <merijn> Letting you store something like line numbers in the parser state for nicer errors
09:59:27 <merijn> Anyway, weekend!
09:59:39 <kryft> merijn: But you still need something to work with context-free grammars (or however you specify the syntax for your language)
09:59:55 <kryft> merijn: Anyway, thanks
09:59:57 <merijn> kryft: You specify the grammer by building parser combinators
10:00:16 <kryft> merijn: Oh, hmm
10:00:19 <merijn> Do you know the term BNF?
10:00:53 <kryft> merijn: Yeah
10:01:39 <kryft> merijn: I read a compiler textbook more or less up to left-recursive grammars and right-recursive grammars before I got distracted :)
10:01:54 <merijn> As soon as you have a combinator for "try this first, if it fails, try the second" you can almost directly translate BNF into one combinator per label in your BNF
10:02:09 <merijn> Anyhoo, like I said, gotta run
10:02:16 <kryft> merijn: Right, thanks a lot
10:17:46 <josephle> from my experience with compilers, it's hard to make a parser built with Parsec compete with one generated by happy+alex :/
10:18:00 <josephle> but assume this is for learning haskell, rather than actually building a compiler
10:19:17 <Fuuzetsu> I think I really screwed up my Haskell environment… http://hpaste.org/89028 Ideas?
10:20:21 <c_wraith> Fuuzetsu: doesn't look broken, exactly.  looks like you're trying to compile a dynamically linkable version of vector
10:20:36 <c_wraith> Fuuzetsu: and you haven't installed dynamically-linkable versions of all its dependencies
10:20:55 <Fuuzetsu> I tried to cabal install the vector available in ghc/libraries/vector because all the other ones are not patched for Typeable
10:21:16 <Fuuzetsu> c_wraith: how do I dynamically install them? --ghc-option=-dynamic?
10:21:50 <c_wraith> Fuuzetsu: I'd just set the appropriate flag in ~/.cabal/config
10:22:02 <c_wraith> Fuuzetsu: and then do something like cabal reinstall world
10:22:10 <Fuuzetsu> Right. What should the flag be?
10:22:32 <c_wraith> Fuuzetsu: though I'd add a --dry-run flag to the latter, and make sure it doesn't change versions of anything, before actually running that.
10:22:51 <c_wraith> Fuuzetsu: honestly, I can't remember the name of the flag. I'd have to look it up.
10:23:04 <Fuuzetsu> I have a ‘-- executable-dynamic: False’ in here as the only mention of dynamic…
10:23:57 <applicative> why does vector want 'dyn'
10:24:07 <applicative> i mean, when primitive didn't
10:24:08 <c_wraith> that's a good question, too
10:24:36 <c_wraith> actually, here's one more...  doesn't primitive come with ghc?
10:24:47 <Fuuzetsu> I have no idea what I'm doing… My setup is a mess of global packages (through package manager) and local stuff through cabal.
10:24:56 <Fuuzetsu> Is there an Easy Way™ to just start clean?
10:25:34 <edwardk> preflex: xseen byorgey
10:25:34 <preflex>  byorgey was last seen on freenode/#haskell 19 hours, 30 minutes and 26 seconds ago, saying: but it should.
10:25:46 <c_wraith> Oh, looks like primitive is not part of ghc
10:25:52 <c_wraith> so that's not an issue
10:26:16 <c_wraith> Fuuzetsu: removing  (or renaming) ~/.ghc will start you clean
10:26:26 <applicative> Fuuzetsu: the globally installed things may be a problem, but you can get rid of everything local with ghc-pkg unregister kerfuffle-0.0.0
10:26:56 <c_wraith> unless you've been installing things globally
10:27:01 <c_wraith> you should never install things globally
10:27:07 <applicative> this is equivalent to eliminating  ~/.ghc but more instructive...
10:27:31 <applicative> the global things were from the package manager.
10:27:40 <applicative> Fuuzetsu seemed to be saying.
10:28:29 <Fuuzetsu> yes, it was stupid
10:28:30 <c_wraith> oh.  I'd also never trust the OS package manager to install haskell packages.
10:28:37 <applicative> why not rename ~/.ghc and see what e.g. ghc-pkg check says
10:28:56 <applicative> c_wraith: well what about the haskell platform packages...
10:29:09 <c_wraith> in fact, I don't trust anything about os package managers when it comes to installing GHC. I'd much rather install it from a binary distribution.
10:29:11 <Fuuzetsu> I'm thinking of just unmerging everything from dev-haskell globally and then deleting ~/.ghc locally and starting fresh
10:29:13 <applicative> i'm not sensing anything stupid so far
10:29:17 <c_wraith> applicative: I also don't trust the platform
10:29:52 <Fuuzetsu> c_wraith: unfortunately the GHC folk don't have any builds in their dist directories online
10:30:03 <c_wraith> Fuuzetsu: for what OS?
10:30:10 <Fuuzetsu> Any. I'm running Gentoo
10:30:33 <Fuuzetsu> http://www.haskell.org/ghc/dist/current/dist/
10:30:37 <c_wraith> http://www.haskell.org/ghc/download_ghc_7_6_3  the "unknown linux" package should work
10:30:43 <Fuuzetsu> I need nightly
10:31:00 <c_wraith> If you need nightly, you should probably just build from source
10:31:07 <Fuuzetsu> Yeah, that's what I did
10:31:22 <c_wraith> ah, ok.  in that case, *definitely* don't trust any os package installers.
10:31:41 <Fuuzetsu> c_wraith: it should be fine to just let it install GHC from git, right?
10:31:52 <applicative> I see, you need advice on maintaining a version of ghc-head
10:31:56 <Fuuzetsu> I mean, I'd very much like my system to know that I have GHC
10:32:57 <c_wraith> Fuuzetsu: The thing is, new version of GHC often include minor breaking changes. Even if your system knew about your build of head, there's a good chance things it has wouldn't compile with it, due to minor tweaks
10:33:19 <c_wraith> Fuuzetsu: you should almost certainly be keeping your build in a separate parallel install to some other GHC
10:33:46 <applicative> yes, thats certainly the only way I have been able to comprehend it
10:33:59 <Fuuzetsu> Hmm, right. That's what I did initially but I had some issues with library includes
10:34:20 <applicative> certainly you wont want to be building half of hackage with ghc-head either...
10:34:50 <Fuuzetsu> I can symlink to ghc, ghc-pkg etc. but cabal will still point to whatever global libs I'll have from 7.6.3 or whatever I'll have globally
10:34:58 <applicative> Fuuzetsu: oh yes, that can be a distinct pain.
10:35:05 <c_wraith> that's why I don't install globally
10:35:22 <c_wraith> I install to my home directory, ghc-version subdirectories
10:35:33 <c_wraith> then I create a ghc symlink to point to whichever one I want at the moment
10:35:42 <c_wraith> and then I put ~/ghc/bin in my path
10:35:49 <applicative> then alias kabal = cabal install {with secret ghc} etc
10:36:00 <c_wraith> nah, no need for that.
10:36:07 <c_wraith> the .ghc stuff is versioned
10:36:14 <c_wraith> so it doesn't care
10:36:18 <Fuuzetsu> how will everything know where my includes are?
10:36:52 <Fuuzetsu> if I configure ghc with prefix=~/myghc, the libs go into myghc/lib
10:37:17 <applicative> it can't be as bad as with os x, these includes.  therefore I predict that it will take less than three years to figure it out ;)
10:37:24 <c_wraith> Fuuzetsu: it just works
10:37:47 <Fuuzetsu> c_wraith: Right… I'll try it, hopefully I have more luck this time.
10:37:54 <Fuuzetsu> Time to purge everything from my system first…
10:40:09 <c_wraith> Fuuzetsu: as to how it works, ghc, ghc-pkg, etc...  they're all shell scripts with the install path built into them by make install
10:40:13 <Fuuzetsu> should I delete .cabal/packages/* too?
10:40:21 <c_wraith> nah, you can leave everything in .cabal
10:41:04 <Fuuzetsu> c_wraith: Right. The issue seemed to occur when gcc was compiling some C files in some project and it had includes in the global directories instead of pointing to libs that were installed locally
10:41:24 <Fuuzetsu> I think.
10:41:54 <c_wraith> Well, linking to system libraries is certainly something that ghc will do.
10:42:06 <c_wraith> but it shouldn't cause problems if the ghc install is local
10:42:57 <kryft> josephle: You mean compete in terms of performance?
10:47:41 <Fuuzetsu> To reiterate that, I shouldn't have _any_ GHC installed globally, right? Or is it fine to have stable installed locally and maintain HEAD locally?
10:47:54 <josephle> yes
10:48:15 <c_wraith> It's often easiest to control things with global GHC install
10:48:24 <c_wraith> and it's fine to have multiple parallel local builds
10:48:36 <c_wraith> err, *without a global GHC install*
10:48:44 <c_wraith> man, I'm doing that too much these days
10:49:16 <Fuuzetsu> I kind of don't like the idea of my system not knowing about any GHC but OK, I'll try to just hold everything locally
10:51:25 <kryft> josephle: Well, this is primarily for understanding compilers, parsing and haskell, so yes, performance isn't that important
10:52:34 <josephle> kryft: that's fine with me. At least you don't have a person who makes iphone jailbreaks writing your compiler tests.
10:52:37 * josephle shudders
10:53:41 <kryft> josephle: Huh? :)
10:54:32 <josephle> kryft: Let's just say I learned how slow Parsec can be firsthand from a certain person who Sony has a restraining order against.
10:56:11 <kryft> josephle: Ok, 'nuff said :)
10:59:51 <josephle> but parsec as a teaching tool is pretty good, and it's a lot easier to work with parsec if your grammar isn't context-free
11:02:45 <edwardk> nomeata: around?
11:02:50 <edwardk> preflex: xseen nomeata
11:02:51 <preflex>  nomeata was last seen on freenode/#haskell 1 day, 18 hours, 53 minutes and 13 seconds ago, saying: *monad
11:03:09 <nomeata> edwardk: around.
11:04:07 <Taneb> Does anyone know the reasoning of the folding in of StateVar etc into OpenGL?
11:04:10 <amyers> What does  the warning "Too strict if" mean?
11:04:30 <amyers> What does it mean for something to be too strict?
11:04:51 <tac> amyers: Strictness means you evaluate things that might not be needed
11:05:02 <tac> Or it might mean you evaluate so much, your program gets stuck in an infinite loop
11:05:10 <tac> (full laziness avoids infinite loops whenever it's possible to do so)
11:05:39 <elliott> tac: I think tac is referring to a specific warning
11:05:51 * tac slinks away
11:05:59 <amyers> elliott: If you mean I am, yes :)
11:06:02 <elliott> er, amyers, yes
11:06:23 <amyers> I have an if in monadic code which is of the form
11:06:26 <elliott> amyers: ah, it's how hlint suggests replacing if a then f b else f c with f (if a then b else c), apparently
11:06:41 <elliott> my advice: hlint often produces noise. takes its advice with a grain of salt
11:06:42 <amyers> if (check for a specific constructor) then <do one thing> else <do another>
11:07:05 <elliott> it's more strict because if a is _|_, then (if a then f b else f c) is _|_
11:07:05 <c_wraith> oh.  Yeah, putting the branch before the constructor is more strict
11:07:10 <elliott> but f (if a then b else c) is f _|_
11:07:11 <amyers> elliott: ah, I see
11:07:21 <elliott> that's not even necessarily too strict though! it could be just what you want
11:07:30 <elliott> a bit of a silly suggestion I think
11:07:33 <c_wraith> yes.  It's more strict. But maybe you want more strict.
11:07:35 <amyers> elliott: It is a duplication, but it would be really ugly to pull it outside the if
11:07:51 <elliott> so don't :)
11:07:57 <elliott> what is the actual expression anyway?
11:08:28 <amyers> The entire if statement or the boolean expression it's checking?
11:08:33 <elliott> former
11:10:33 <amyers> http://hpaste.org/89032
11:11:21 <elliott> amyers: what you have looks fine, yes
11:12:16 <amyers> elliott: Okay, It didn't seem like anything untoward
11:12:31 <amyers> Thanks for the explanation :)
11:13:02 <Kinjen> why are arbitrary precision integers slower than fixed precision in haskell.
11:13:54 <simukis_> Kinjen: because fixed size integers (32, 64 bits) are supported by cpu directly, while to have arbitary size integers some additional calculations are required.
11:13:56 <geekosaur> aren't they slower in all languages? fixed precision is direct CPU operations, arbitrary precision is calls to arbitrary precision library
11:14:49 <Kinjen> thanks simukis
11:15:52 <Kinjen> thaks geekosaur
11:16:07 <c_wraith> sometimes Integer is faster than Int64 in 32-bit GHC
11:20:05 <edwardk> preflex: xseen mzero
11:20:05 <preflex>  mzero was last seen on freenode/#haskell 12 hours, 42 minutes and 55 seconds ago, saying: well - yes, HalVM uses just the xen primitives- but one could imagine porting it to bare metal
11:24:01 <Fuuzetsu> c_wraith: What do I have to link to jump between ghc-versions? ghc, ghc-pkg…?
11:24:37 <c_wraith> Fuuzetsu: I just put a symlink to the appropriate ghc/bin in my path
11:25:00 <Fuuzetsu> Ah, that will work. Thanks.
11:32:53 <gwern> @quote
11:32:53 <lambdabot> bfig says: i have been reborn as a haskell programer after finding Debug.Trace
11:33:27 <quchen> ^ Makes printing so much easier! *ducks*
11:33:27 <Hafydd> @quote
11:33:27 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
11:37:41 <fruitFly_> where should I put my haskell files I want to compile>
11:37:43 <fruitFly_> ?
11:38:38 * hackagebot hsbencher 1.1.0.1 - Flexible benchmark runner for Haskell and non-Haskell benchmarks.  http://hackage.haskell.org/package/hsbencher-1.1.0.1 (RyanNewton)
11:39:23 <kwelle> fruitFly_: hm?
11:40:01 <Fuuzetsu> I'm trying to install cabal-install but I'm getting ‘Setup: At least the following dependencies are missing: base >=4 && <3 && >=2 && <5, unix >=2.0 && <2.6’. ghc-pkg list shows ‘base-4.6.0.1’ and ‘unix-2.6.0.1’ though. Where am I screwing up?
11:40:01 <Fuuzetsu>  
11:40:23 <fruitFly_> kwelle: i dn't even know how to compile? I have a .hs file with a main method, does that mean it needs to be compiled or could I do :l or something?
11:40:34 <kwelle> fruitFly_: there's a typo, i think
11:40:43 <kwelle> base >=4 && <3 -- this is impossible
11:40:50 <kwelle> you probably meant "base >=4 && <5" ?
11:41:21 <kwelle> fruitFly_: generally, if you only have one file, you can just do "ghc --make Sourcecode.hs"
11:41:40 <kwelle> fruitFly_: or, afaik, "ghc --make Sourcecode.hs -o executable"
11:41:50 <Fuuzetsu> That was copied and pasted right from the output of ‘ ghc --make Setup && ./Setup configure --user && ./Setup build && ./Setup install’
11:42:07 <kwelle> dafuq
11:42:30 <kwelle> dunno…
11:42:41 <kwelle> what are you doing?
11:43:02 <kwelle> Fuuzetsu: you don't need cabal(-install) for a one-source-file project
11:43:07 <fruitFly_> I have this and I want to run it on my local machine
11:43:10 <fruitFly_> http://ideone.com/IlQ7A
11:43:15 <fruitFly_> kwelle: ^^
11:43:28 <Fuuzetsu> http://hpaste.org/89033
11:43:33 <kwelle> fruitFly_: just do "ghc --make SourceCode.hs -o executable"
11:43:35 <Fuuzetsu> kwelle: I need cabal-install on my system
11:43:39 <kwelle> and then do "./executable"
11:43:50 <Fuuzetsu> As in, I don't have it right now.
11:43:51 <kwelle> kwelle: you need packages?
11:44:07 <kwelle> Fuuzetsu: are you on windows/linux/osx?
11:44:10 <Fuuzetsu> Linux
11:44:15 <kwelle> distro?
11:44:18 <Fuuzetsu> Gentoo
11:44:38 <fruitFly_> kwelle: does the file need to be in a certain folder?
11:44:42 <kwelle> did you install haskell-platform (with emerge or building it yourself)?
11:44:48 <kwelle> fruitFly_: no
11:44:59 <fruitFly_> ok thanks
11:45:16 <Fuuzetsu> kwelle: I just wiped everything to do with Haskell from my global installations. I need to juggle multiple versions of GHC, including HEAD so I'm installing everything locally
11:45:35 <Fuuzetsu> So now I'm in a situation where I have 7.6.3 (locally) and nothing else
11:45:49 <kwelle> wtf
11:46:33 <dmwit> Fuuzetsu: (Multiple versions of GHC work together just fine, even when installed globally.)
11:46:35 <kwelle> i don't really understand what you want actually... :/
11:46:59 <Fuuzetsu> dmwit: I had a bad case of mixing global and local packages
11:47:17 <kwelle> anyways... got a question too ;) :P :  does http://www.haskell.org/platform/linux.html#build-from-source not include ghc?
11:47:21 <dmwit> Fuuzetsu: That's completely orthogonal to having multiple GHC instances.
11:47:33 <dmwit> Fuuzetsu: Since each package database is specific to a particular GHC version.
11:47:41 <fruitFly_> kwelle: not in scope 'ghc'
11:47:50 <Fuuzetsu> dmwit: My system only has one slot for GHC so if it's global, I have to choose a single version
11:47:52 <kwelle> wait.
11:48:01 <kwelle> Fuuzetsu and fruitFly_ are two different people?
11:48:04 <jodaro> i'm totally late to the conversation, but ... hsenv has been working well for me
11:48:06 <Fuuzetsu> kwelle: yes
11:48:09 <dmwit> I'm not sure I understood what that meant.
11:48:13 <kwelle> crap
11:48:25 <kwelle> :D
11:48:29 <kwelle> hehehehe
11:48:31 <Fuuzetsu> dmwit: Installing GHC with my package manager makes me choose only a single version of it at any one time.
11:48:36 <fruitFly_> kwelle: i think i got it
11:48:40 <fruitFly_> --make blah.hs
11:48:50 <kwelle> yep
11:49:00 <kwelle> oh god, i was mixing up you too all time :D heheheh
11:49:08 <kwelle> *two (omg)
11:49:12 <Clint> Fuuzetsu: that's what chroots are for
11:49:30 <Fuuzetsu> Clint: Overkill.
11:49:34 <fruitFly_> kwelle: im loggen in on ircs in diff rooms
11:49:56 <fruitFly_> i'll just stay on Fuuzetsu now
11:50:11 <kwelle> so you are really the same person??? O.o
11:50:16 <Fuuzetsu> kwelle: no, he's not
11:50:23 <kwelle> hehehe
11:50:28 <kwelle> lmao
11:50:55 <fruitFly_> r u familiar with gentoo kwelle ?!
11:51:14 <kwelle> fruitFly_: a bit
11:51:53 <fruitFly_> kwelle: how to run the executable on a win machine?
11:52:17 <kwelle> fruitFly_: dunno
11:52:32 <fruitFly_> i think i know
11:52:43 <fruitFly_> how to quit prelude?
11:53:09 <fruitFly_> source.exe is not working :S
11:53:12 <kwelle> <http://www.haskell.org/ghc/download_ghc_7_6_3> says "The Haskell Platform release includes a recent GHC release […]."; <http://www.haskell.org/platform/linux.html#build-from-source> says "Get and install GHC 7.6.3 prior to building the platform"
11:53:47 <kwelle> so which is true?
11:53:56 <elliott> binary platform includes ghc
11:53:58 <elliott> source platform does not
11:54:07 <elliott> monochrom has an article on the topic
11:54:08 <kwelle> ah oh i see
11:54:35 <kwelle> i'm not sure whether an article on this is relevant? is it?
11:55:02 <kwelle> elliott: i mean, you just explained everything necessary, didn't you? :D
11:55:47 <fruitFly_> elliott: how do I run this on my win machine? http://ideone.com/IlQ7A
11:55:53 <elliott> I mean ont he whole topic of compiling HP
11:55:55 <fruitFly_> elliott: and how do I exit prelude?
11:56:24 <elliott> fruitFly_: by compiling it and running the resulting executable, and if you mean how to exit GHC then type in :q or :quit
11:56:35 <kwelle> *GHCI
11:56:40 <elliott> er, yes *GHCi
11:56:54 <elliott> (btw, please don't repeat questions addressed directly to people just because they didn't get an answer...)
12:00:46 <Fuuzetsu> Well, I solved my problem. Seems that one of the main cabal pages was linking to an ancient cabal-install source.
12:00:59 <elliott> oops, *you didn't, sorry
12:03:38 * hackagebot katt 0.1.0.0 - Client for the Kattis judge system.  http://hackage.haskell.org/package/katt-0.1.0.0 (DavidNilsson)
12:05:06 <fruitFly_> elliott: how do I compile?
12:05:15 <fruitFly_> elliott: haskell.org says "And compile it with:      $ ghc -o hello hello.hs: ?
12:05:35 <dmwit> ...or just ghc hello
12:05:37 <geekosaur> note that the $ there represents a shell prompt, you don't type it
12:05:47 <elliott> have you read the GHC manual? it should cover compilation (I think both Learn You a Haskell and Real World Haskell do too, though not sure about the former)
12:05:59 <elliott> (as well as many otherthings, of course)
12:06:19 <fruitFly_> the former hasn't (at least not yet)
12:06:49 <fruitFly_> elliott: i did :?
12:07:13 <fruitFly_> elliott: don't see anything about compilation
12:08:35 <fruitFly_> elliott: not in scope 'o' ...
12:09:10 <Fuuzetsu> fruitFly… you don't put it into GHCi
12:09:15 <Fuuzetsu> do it from the command line
12:09:18 <elliott> 4.1. Getting started: compiling programs: http://www.haskell.org/ghc/docs/latest/html/users_guide/using-ghc.html#idp34450864
12:10:40 <fruitFly_> elliott:  Fuuzetsu figured it out thanks!
12:26:09 <foxnewsnetwork> haskell n00b here, I'm trying to wrap my head around arrows; can some haskell jedi master please give me some context as to when I might use ArrowLoop and ArrowApply in an example?
12:26:25 <troydm> http://dawood.in/if-carpenters-were-hired-like-programmers/ <- so true
12:29:38 <b2coutts> troydm: ++
12:30:09 <troydm> most my interview exp were like that
12:30:50 <troydm> and the only ones that weren't like that (where i met technicly sensible ppl) were the ones i got hired
12:37:06 <kwelle> elliott: monochrom's tutorial states that libgmp.so.3 is needed and that you can install libgmp3c2 for that purpose. but recent versions of debian (and ubuntu) do not have that package included. i tried "sudo ln -s /usr/lib/libgmp.so /usr/lib/libgmp.so.3" but that didn't help either. what can i do?
12:37:25 <elliott> kwelle: i think newer ghc works fine with newer gmp
12:37:35 <elliott> though i also think the binary packages are built with the older version
12:37:39 <elliott> (btw, I suggest removing that symlink, just in case)
12:37:44 <kwelle> okay
12:37:53 <kwelle> elliott: so, what do you recommend?
12:38:13 <kwelle> compiling GHC is problematic for me :/
12:39:15 <monochrom> kwelle: the directory is not /usr/lib, but /usr/lib/i385-linux-gnu or /usr/lib/x86_64-linux-gnu or something
12:39:26 <shachaf> kwelle: Don't compile GHC.
12:39:42 <shachaf> Well, only as a last resort.
12:40:38 <kwelle> shachaf: why not? i want the latest version...
12:40:42 <shachaf> Oh, HEAD?
12:41:12 <shachaf> Hmm, I have libgmp3c2 and libgmp10 in Debian.
12:41:18 <shachaf> Did I do something evil to get them both?
12:41:19 <kwelle> shachaf: no, just 7.6.3
12:41:23 <shachaf> (Very possible.)
12:41:50 <shachaf> I have GHC 7.6.2 in Debian (jessie, testing). I installed from the binary package.
12:42:06 <kwelle> shachaf: there's no package called libgmp3c2 on debian unstable (on amd64 or x86).
12:42:14 <Clint> no, it's not in unstable anymore
12:42:23 <Clint> you have to get it from squeeze
12:42:35 <kwelle> Clint: how?
12:42:38 <shachaf> kwelle: Hmm. Did I install the .deb manually or something?
12:42:43 <Clint> kwelle: why do you want to?
12:42:45 <kwelle> shachaf: might be, yep
12:42:47 <Clint> we have ghc 7.6.3 in sid
12:42:57 <kwelle> Clint: do we??
12:42:59 <kwelle> since?
12:43:01 <kwelle> O.o
12:43:05 <Clint> three days now?
12:43:06 <shachaf> http://ftp.us.debian.org/debian/pool/main/g/gmp/ has a bunch of .debs for libgmp
12:43:13 <kwelle> Clint: oh
12:43:17 <kwelle> :D
12:43:20 <shachaf> http://ftp.us.debian.org/debian/pool/main/g/ghc/ has 7.6.3, indeed.
12:43:40 <kwelle> well. that makes things easier indeed :)
12:43:47 <kwelle> thank you very much guys :) :D heh
12:43:49 <Clint> should be in jessie by the end of the month
12:43:55 <shachaf> By the way, 7.6.3 is almost the same as 7.6.2.
12:43:56 <kwelle> Clint: cool
12:44:06 <shachaf> Just one (important) bugfix.
12:46:06 <kwelle> so, should i install haskell-platform using apt or just ghc?
12:48:46 <kwelle> i'll go for haskell-platform
12:49:35 <kwelle> i mean, manually installing haskell-platform wouldn't have additionally advantages...
12:49:41 <kwelle> -ly
12:50:07 <elliott> HP from distro is reasonable
12:54:17 <kwelle> wow http://hdiff.luite.com/ is awesome!
12:57:15 <arajan> hello. I'm running into some strange cabal issues that I can't figure out. Could someone please help me?
12:57:34 <arajan> I've hpasted the errors here:
12:57:39 <arajan> http://hpaste.org/89034
12:59:42 <arajan> I am certain that I have bytestring installed (ghc-pkg list bytestring produces non-empty output)
12:59:47 <arajan> so I have no idea why I'm getting this error message.
13:00:50 <kwelle> arajan: the first thing i try if there's trouble with cabal is "cabal update"... probably won't help though
13:01:20 <byorgey> arajan: what version of bytestring do you have installed?
13:01:37 <byorgey> I note that the ghc-heap-view.cabal file uses bogus syntax in the dependencies list
13:01:44 <byorgey> bytestring (>= 0.10)
13:02:19 <byorgey> my guess is that cabal ignores the part in parens, and you have an older version of bytestring installed
13:02:25 <arajan> ok
13:02:37 <arajan> yes, i have the older version of bytestring
13:02:46 <arajan> but, if i were to install bytestring-0.10.2 or whatever the lates tversion is
13:02:53 <arajan> then it would conflict with the older version
13:02:55 <arajan> what do?
13:03:00 <byorgey> no, it wouldn't conflict
13:03:08 <arajan> oh?
13:03:10 <arajan> ok.
13:03:14 <arajan> so i should cabal install bytestring
13:03:16 <arajan> and then try again?
13:03:21 <arajan> (with cabal install ghc-heap-view that is)
13:03:32 <byorgey> but it could potentially lead to problems later if you have some things built against bytestring-0.9 and some against 0.10.
13:03:39 <arajan> yes, that's what i was referring to
13:03:48 <byorgey> cabal install ghc-heap-view --constraint='bytestring >= 0.10'
13:03:59 <arajan> ok, thank you
13:04:00 <arajan> i'll try that now
13:04:26 <byorgey> we should also tell nomeata
13:04:33 <byorgey> but it seems he's not around at the moment
13:05:01 <arajan> hmm
13:05:08 <arajan> got more errors, here: http://hpaste.org/89035
13:05:21 <byorgey> @tell nomeata ghc-heap-view.cabal uses wrong syntax for the bytestring dependency version constraint, so cabal is ignoring it
13:05:21 <lambdabot> Consider it noted.
13:05:36 <dmwit> Maybe a bug report to the cabal-install guys wouldn't go amiss, either.
13:05:36 <byorgey> ohhh
13:05:42 <byorgey> dmwit: indeed
13:06:07 <byorgey> arajan: well, ghc-heap-view depends on the ghc package, which is tied to the bytestring version you already have installed
13:06:23 <arajan> ok...how do I get around that?
13:06:26 <byorgey> arajan: and it is a really really bad idea to install a new ghc package.  In fact I think cabal refuses to try.
13:06:30 <byorgey> you can't.
13:06:32 <arajan> OK.
13:06:36 <kwelle> maybe just modify it and push it to hackage? :D
13:06:37 <arajan> So...nuke it from orbit and start over?
13:06:45 <byorgey> arajan: basically what this means is that ghc-heap-view is only available with ghc 7.6.
13:06:49 <arajan> ah, gotcha.
13:07:00 <arajan> wellp, I can install that from source I suppose
13:07:23 <byorgey> you don't need to install it from source.  You can use a binary distribution.
13:07:27 <arajan> oh?
13:07:31 <arajan> i'm on linux mint right now
13:07:37 <arajan> i'm not seeing ghc 7.6 in an apt repository
13:07:45 <byorgey> arajan: http://www.haskell.org/ghc/download_ghc_7_6_3#binaries
13:07:52 <arajan> oh cool, thanks
13:08:14 <byorgey> unpack, make configure, make install
13:08:20 <arajan> got it
13:08:26 <arajan> will cabal automatically recognize the new
13:08:28 <arajan> ghc compiler?
13:08:33 <arajan> do i have to uninstall the current version of ghc that I have?
13:08:44 <dmwit> You do not need to uninstall your current version.
13:08:49 <arajan> OK
13:08:59 <arajan> awesome possum. Thanks so much for your help!
13:09:14 <arajan> Will let this download and check back later to let you know if this works out.
13:09:33 <arajan> thanks again, byorgey and dmwit
13:16:37 <edwardk> byorgey: heya
13:16:45 <byorgey> hi edwardk
13:18:51 <robde> hello. I’m trying to zip an [Int] and a [Bool] and then I want to only extract snd of those tuples that have a True:  foldr (\ (x, f) -> if f == True then (x :) else ([]++) ) [] $ zipWith (\ x f -> (x * x, f))
13:19:48 <dmwit> [x * x | (x, f) <- zip xs fs, f]
13:20:24 <dmwit> "f == True" better written "f"
13:20:50 <dmwit> "([]++)" better written "id"
13:21:11 <tac> dmwit: only extensionally!
13:21:35 <dmwit> Haskell does not have an intensional equality.
13:21:37 <robde> but this function somehow does not match this signature: [Int] -> [Bool] -> [Int]
13:21:58 <dmwit> robde: You probably wanted (.) instead of ($) in between your foldr and zipWith.
13:22:20 <dmwit> :t foldr (\(x, f) -> if f == True then (x:) else ([]++)) [] . zipWith (\x f -> (x * x, f))
13:22:22 <lambdabot>     Couldn't match expected type `[(a0, Bool)]'
13:22:22 <lambdabot>                 with actual type `[b0] -> [c0]'
13:22:22 <lambdabot>     Expected type: [a1] -> [(a0, Bool)]
13:22:22 <robde> *fst
13:22:46 <dmwit> oh, even more exciting than (.)
13:22:53 <dmwit> :t (.:)
13:22:54 <lambdabot>     Not in scope: `.:'
13:22:54 <lambdabot>     Perhaps you meant one of these:
13:22:54 <lambdabot>       `.' (imported from Prelude),
13:23:04 <dmwit> :t (foldr (\(x, f) -> if f == True then (x:) else ([]++)) [] .) . zipWith (\x f -> (x * x, f))
13:23:06 <lambdabot> Num a => [a] -> [Bool] -> [a]
13:24:13 <elliott> what this function needs is more points.
13:25:05 <dmwit> robde: What you wrote is applying foldr to the function "zipWith (\x f -> (x * x, f))" as its third argument.
13:25:26 <shachaf> I,I if (if f then True else False) == True
13:25:27 <dmwit> robde: What you *wanted* was for foldr to be applied to the result of running "zipWith (\x f -> (x * x, f))" on two arguments.
13:26:00 <robde> but it works: foldr (\ (x, f) -> if f == True then (x :) else ([]++) ) [] $ zipWith (\ x f -> (x * x, f)) [1,2] [True, False]
13:26:03 <dmwit> shachaf: You're five minutes late!
13:26:13 <dmwit> robde: Yes, that works. It's also very different.
13:26:17 <adnap> Can you create a module which exports module A, where module A is defined by importing it from another package?
13:26:25 <ion> if (f == True) == True
13:26:29 <adnap> I am looking at some code that seems to do this
13:26:34 <dmwit> robde: As you can see there, foldr is being applied to the result of running "zipWith (\x f -> (x * x, f))" on two arguments.
13:26:34 <robde> (I know there are better ways to do it, but I want to make use of foldr)
13:27:03 <dmwit> (those two arguments being [1,2] and [True, False], of course)
13:27:18 <monochrom> byorgey: this is why I never say "it's ok to have two versions, there is no conflict". in practice there is always conflict. this is why I scaremonger about it.
13:28:39 <byorgey> monochrom: yeah, you definitely have a point.
13:28:42 <dmwit> robde: Cutting out the nonsense, "f $ g x y" is "f (g x y)", but "f $ g" is "\x y -> f g x y".
13:28:48 <robde> dmwit: using foldr
13:29:09 <dmwit> robde: Forget the foldr. If you can understand this last point, you will understand why your code is not working.
13:29:33 <dmwit> (and how to fix it)
13:30:49 <dmwit> That is, you might think naively that "f $ g" is "\x y -> f (g x y)", but it ain't.
13:32:19 <nooodl_> [x * x | (x, True) <- zip xs bs] maybe?
13:32:28 <dmwit> nooodl_: You're 12 minutes late!
13:32:30 <nooodl_> oh dmwit already wrote something like that
13:32:51 <dmwit> Though I like your refinement better anyway. =)
13:33:02 <dmwit> Pattern matching on True that way is cute.
13:33:16 <monochrom> nice
13:33:36 <robde> but $ is function application, right? I want to apply the foldr to the result of zipWith
13:33:51 <dmwit> robde: Yes, you want to apply foldr to *the result* of zipWith. Not to zipWith itself.
13:34:25 <elliott> f $ x = f x. there is no special rule
13:34:36 <elliott> whenever you see f $ x, rewrite it as f (x). parens to keep the precedence
13:34:41 <elliott> if what you rewrite it as is wrong, then the original is wrong too
13:34:42 <tabemann> you want (.), not ($)
13:34:52 <dmwit> tabemann: As I discovered above, he wants (.) . (.), not ($).
13:35:08 <robde> that should be the same as the composition, no?
13:35:30 <tabemann> f $ g is passing g itself as an argument to f
13:35:43 <tabemann> not the result of g, but the function g
13:36:11 * elliott submits: if an expression with ($) or (.) is confusing you, rewrite it to use explicit parameters and parentheses
13:36:43 <mkscrg> @pl \x y -> x:y:[]
13:36:43 <lambdabot> (. return) . (:)
13:37:07 <tabemann> the main thing one gets from ($) and (.) is that code with them often look nice, as long as they are not used to excess; when used to excess, though, they often hurt clarity
13:38:13 <dmwit> robde: Compare: "f $ g = \x -> (f $ g) x = \x -> (f g) x", but "\x -> f $ g x = \x -> f (g x)". So you are probably thinking that "\x -> f $ g x" can be reduced to "f $ g", but it can't.
13:38:53 <dmwit> ?pl \x y -> [x, y] -- how smart is ?pl?
13:38:54 <lambdabot> (. return) . (:)
13:38:57 <dmwit> p. smart
13:39:12 <dmwit> ?pl \x y -> do { x; y }
13:39:12 <lambdabot> (line 1, column 12):
13:39:12 <lambdabot> unexpected '{'
13:39:13 <lambdabot> expecting variable, "(", operator or end of input
13:39:23 <dmwit> well, smart, anyway
13:39:33 <dmwit> ?info [x, y]
13:39:34 <lambdabot> [x, y]
13:40:39 <elliott> .@pl does something clever that surprised me but I forget what
13:40:57 <dmwit> ?info [x | x <- xs, y]
13:40:57 <lambdabot> concatMap (\ x -> if y then [x] else []) xs
13:41:16 <dmwit> Perhaps you're thinking of this trick that I just recently learned ?undo will do.
13:41:33 <elliott> I knew it did that already
13:41:36 <elliott> I think
13:41:39 <dmwit> ok =)
13:41:58 <dmwit> ?pl [x | x <- xs, y] -- ?pl isn't as clever about this =P
13:41:58 <lambdabot> [x | x <- xs, y]
13:42:07 <dmwit> ?pl \xs y -> [x | x <- xs, y] -- ?pl isn't as clever about this =P
13:42:07 <lambdabot> (. return) . (:) . ((x | x) <-)
13:42:15 <dmwit> ((x | x) <-) -- uh huh
13:42:32 <elliott> it's not @pl's fault Haskell isn't advanced enough to handle that
13:43:22 <dmwit> :t \f g x -> (. return) . (:) . g (f x x)
13:43:24 <lambdabot> (t1 -> t1 -> t) -> (t -> a -> a1) -> t1 -> a -> a1 -> [a1]
13:44:02 <adnap> I am having trouble figuring out why I get "`ldInputs' is not a (visible) constructor field name". It seems like DynFlags is exported here: https://github.com/ghc/ghc/blob/master/compiler/main/DynFlags.hs
13:45:54 <dmwit> adnap: That module isn't exported by the package...
13:46:46 <dmwit> I'm wrong.
13:49:18 <adnap> dmwit: Did you see my first question?
13:49:25 <adnap> "Can you create a module which exports module A, where module A is defined by importing it from another package?"
13:49:50 <dmwit> I did, but don't see why it's relevant here.
13:50:18 <adnap> It's not. It's a separate question
13:50:24 <dmwit> Yes, you can do that.
13:50:37 <dmwit> module Foo (module A) where import A
13:51:25 <dmwit> To be specific: you can export all the symbols defined in module A, even when module A is provided by a different package.
13:52:03 <tabemann> I know the GL packages, both HOpenGL and HOpenGLRaw, are like that - you can import *everything* in them just by importing the top-level package
13:52:25 <tabemann> rather than having to import the packages they contain piecemeal
13:52:27 <dmwit> tabemann: Perhaps you are confusing "package" and "module"?
13:52:32 <tabemann> s/package/module
13:53:03 <dmwit> tabemann: Then that property of HOpenGL and HOpenGLRaw is irrelevant to adnap's question, since adnap's question explicitly talks about two separate packages.
13:53:24 <maxorator> how do I check if some value of type "Maybe a" is Nothing?
13:53:30 <dmwit> maxorator: use "case"
13:53:37 <quchen> :t isNothing
13:53:38 <lambdabot> Maybe a -> Bool
13:53:40 * hackagebot hsbencher 1.1.0.2 - Flexible benchmark runner for Haskell and non-Haskell benchmarks.  http://hackage.haskell.org/package/hsbencher-1.1.0.2 (RyanNewton)
13:53:46 <dmwit> isNothing is a code smell.
13:53:49 <tabemann> or pattern-matching in function-definition
13:54:01 <tabemann> foo Nothing = ...
13:54:09 <tabemann> foo (Just x) = ...
13:54:28 <fizbin> dmwit: it's better than fromJust or a non-exhaustive pattern.
13:54:47 <quchen> dmwit: when (isNothing foo) $ ...
13:55:09 <dmwit> quchen: What's in "..."? I bet it's got a fromJust. I can tell because of my code nose.
13:55:19 <quchen> If isNothing is a code smell, why isn't null?
13:55:32 <dmwit> What makes you think null isn't a code smell?
13:55:43 <quchen> My code nose :>
13:55:43 <tabemann> null? if you mean nullPtr, the only place one should be using that is in marshaling code
13:55:58 <dmwit> :t null -- tabemann
13:55:59 <lambdabot> [a] -> Bool
13:56:05 <tac> quchen: I try to stick to case-matching whenever possible
13:56:37 <tac> but both are better than using head and tail...
13:56:49 <tac> or fromJust
13:57:40 <tabemann> the question is why would one, for any of these situations, use *anything* other than pattern-matching?
13:57:48 <tabemann> with exhaustive patterns, of course
13:58:05 <tac> terseness or readability, perhaps
13:58:15 <tac> If you need a one-liner, then null is fine
13:58:30 <quchen> filter isNothing xs
13:58:37 <quchen> ... to count nothings
13:58:42 <tabemann> okay that kind of thing makes sense
13:58:45 <quchen> Stuff like that.
13:58:58 <dmwit> length [() | Nothing <- xs]
13:59:03 <tac> ewww
13:59:24 <dmwit> Can't imagine why you'd want to know how many Nothing's there were, though. =P
13:59:25 <tabemann> dmwit: o_0
13:59:26 <quchen> Preferring isNothing/null over pattern matching is a code smell, yes. But there are some legitimate use cases.
13:59:44 <supki> > lengthOf (folded . _Nothing) [Just 3, Nothing, Nothing]
13:59:45 <lambdabot>   2
13:59:53 <tac> more importantly, you generally want to stay away from partial projections
14:00:00 <tac> head : [a] -> a    is a bloody lie!
14:00:17 <edwardk> > filter (isn't _Just) [Nothing, Just 2, Nothing]
14:00:18 <quchen> tac: null/isNothing/isJust are total.
14:00:19 <lambdabot>   [Nothing,Nothing]
14:00:23 <tac> quchen: right
14:00:29 <dmwit> > (length "[() | Nothing <- xs]", length "filter isNothing xs", length "filter (isn't _Just)")
14:00:30 <lambdabot>   (20,19,20)
14:00:34 <tac> quchen: I'm just saying, they are just a stylistic thing.
14:00:39 <arajan> byorgey, dimwt: if you're still here, installing ghc7.6 did the trick. Thanks a ton!
14:00:52 <dmwit> arajan: great!
14:00:58 <tac> But partial functions lead to bottoms. And bottoms are the null pointers of FP.
14:01:17 <dmwit> ?quote sprynge
14:01:17 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
14:04:22 * tabemann is kind of embarrassed that the normalize function he is using to construct rotate transforms is almost certainly a partial function, which means it'll just fall over when fed V3 0 0 0 unless he bothers to check for it, and make his return type Maybe (V3 Float)
14:04:28 <josephle> tac: correction, bottoms are the null pointers of *lazy* FP. Can't have bottom if you're strict. :P
14:04:55 <tac> josephle: You can. You just crash your programs.
14:04:58 <quchen> Huh? main = main
14:05:05 <tac> (or cause them to loop...)
14:05:05 <quchen> That's bottom even if you're strict.
14:05:20 <tac> quchen: that's also a value restriction error in Ocaml, iirc
14:05:27 <tabemann> the analog I can think of in strict FP is exceptions and divide by zero
14:05:44 <robde> dmwit: so it must be: foldr (\ (x, f) -> if f then (x :) else ([]++)) [] . zipWith (\ x f -> (x * x, f))?
14:07:15 <tabemann> hmm... is it better to have a rotate function that chokes when fed V3 0 0 0 for the axis of rotation or one that forces the user to do case rotate theta axis of Just matrix -> ...?
14:07:43 <josephle> quchen: main = main is also a value restriction error in SML
14:08:09 <tac> josephle:  <tac> quchen: that's also a value restriction error in Ocaml, iirc
14:08:14 <adnap> if module A has data A = A { foo :: Int }, then module A ( A(..) ) exports foo, right?
14:08:21 <quchen> tabemann: Just a remark,  ([] ++) = id
14:08:26 <josephle> tac: I was just corrobating your claim
14:08:35 <josephle> is that the right word/spelling?
14:08:35 <dolio> adnap: Yes.
14:08:41 <adnap> I thought ".." means "everything"
14:08:45 <tac> gotcha
14:08:58 <nooodl_> robde: you want (.).(.)
14:09:06 <robde> dmwit: ghci still complains about it: Couldn't match expected type `a0 -> [(a1, Bool)]' with actual type `[c0]' In the return type of a call of `zipWith'
14:09:19 <quchen> nooodl_: Nobody wants dotdotdot. :<
14:09:21 <nooodl_> and whenever you want (.).(.) you actually want to stop writing things point free.
14:09:22 <nooodl_> yeah
14:09:49 <quchen> (.)((.))(.)
14:10:28 <nooodl_> but robde is just wondering why his function isn't working. the real solution is [x * x | (x, True) <- zip xs bs]
14:10:37 <Fuuzetsu> I think that if you are ever composing function composition, you probably want to rethink what you're doing before the next developer breaks into your house
14:11:38 <dolio> It doesn't matter if 'main = main' is disallowed. Because people have been complaining about partial functions, which can still exist in strict languages, and are still bad.
14:12:05 <nooodl_> quchen: (.)((.)(.)(.))(.)
14:12:14 <robde> dmwit: sry, that was an old error message. the new one is: Couldn't match expected type `[Bool] -> [Int]' with actual type `[a0]' Expected type: ([Bool] -> [Int]) -> [Bool] -> [Int] Actual type: [a0] -> [a0] In the expression: (x :) In the expression: if f then (x :) else ([] ++)
14:12:35 <quchen> Fuuzetsu: To be fair, (.).(.) is somewhat understandable when you already know it. I mean it's not as bad as @pl \a b c -> [a,b,c].
14:13:03 <quchen> Fuuzetsu: I kind of like (.:) = (.).(.), although I wouldn't use it because others don't.
14:13:18 <saml> hey, how can I execute some function 10% of time?
14:13:22 <Fuuzetsu> quchen: Once you already know it, yeah. .: just happens to be very popular though
14:13:30 <quchen> (even .: gcd) 10 5
14:13:32 <saml> 90% of time, i want the function to be id. 10% of time, something else
14:13:47 <quchen> saml: You need a random number generator for that. Do you know how to do that?
14:14:01 <saml> https://github.com/mongodb/mongo-java-driver/blob/master/src/main/com/mongodb/ConnectionStatus.java#L213   like this?
14:14:15 <saml> how would you do that in haskell?
14:14:17 <quchen> Java? No, not like this.
14:14:26 <josephle> dolio: sometimes I wish exhaustiveness checking didn't only create warnings...
14:14:46 <dmwit> robde: No. See my correct code posted a minute or two after you originally asked the question.
14:14:54 <quchen> saml: Have a look at System.Random. If you don't need lots of random numbers, that module should be fine.
14:15:07 <dmwit> robde: As I observed then, (.) isn't exciting enough.
14:15:26 <saml> thanks
14:15:30 <JoeyA> :t let (.:) = (.).(.) in (:.) .: (:.)
14:15:31 <lambdabot>     Not in scope: data constructor `:.'
14:15:31 <lambdabot>     Perhaps you meant one of these:
14:15:31 <lambdabot>       `:+' (imported from Data.Complex),
14:16:36 <dmwit> saml: Can you explain why you would want to do that?
14:16:55 * tabemann can't tell why anything more than one (.) would be considered a good idea
14:16:59 <JoeyA> n <- randomRIO (1,10); if n == 1 then ... rare ... else ... often ...
14:17:05 <tabemann> maybe two (.)s
14:17:11 <saml> i don't know. i just looked that mongodb code and was wondering how haskell would do
14:17:22 <dmwit> I can tell you what *I* would do. =)
14:17:38 <quchen> A pretty good RRNG is opening N threads reading from an MVar. Fill the MVar, register which thread takes it. It's a random random number generator: you can't even be sure it's random. ;-)
14:18:10 <JoeyA> Challenge: try to detect the version of GHC doing that.
14:18:35 <tabemann> you probably want to use that to seed your PRNG rather than using it directly to create random numbers
14:18:46 <dmwit> I have a RNG that draws from a truly lousy distribution...
14:18:48 <dmwit> let rng = 10
14:19:04 <JoeyA> Not sufficiently random
14:19:07 <JoeyA> - let rng = 10
14:19:10 <JoeyA> + let rng = 4
14:19:15 <quchen> let rng = return 10 :: IO Int -- Remember, randoms are impure
14:19:25 <nooodl_> quchen: hahaha
14:19:35 <solrize> 10 isn't random
14:19:37 <solrize> use 4 or 17
14:19:37 <nooodl_> "rngIO"
14:19:38 <tabemann> I've seeded PRNGs with the system clock, with seconds and milliseconds shifted to use as many bits as possible
14:19:39 <dmwit> let rng = $(roll_a_d20)
14:19:58 <monochrom> 4++
14:21:33 <dmwit> :t \hash f x -> when (hash x `mod` 10 == 0) (f x)
14:21:34 <lambdabot> (Integral a, Monad m) => (t -> a) -> (t -> m ()) -> t -> m ()
14:22:48 <dmwit> That's probably strictly worse that picking a (pseudo) random number, though.
14:23:09 <dmwit> I stick with my original plan: don't randomly log errors. Just log all errors.
14:23:52 <nooodl_> what is mongodb even doing there
14:24:09 <quchen> nooodl_: I was wondering the same. Is that legitimate Java code?
14:24:25 <nooodl_> it seems to be legitimate lousy java code
14:25:06 <Fuuzetsu> Oh, someone just posted this snippet yesterday. Hold on a second.
14:25:16 <robde> dmwit: do you have another hint for me?
14:25:21 <quchen> I'm not very familiar with Java, but that looks worse than how Haskell looked like before I could read it.
14:25:36 <dmwit> robde: I gave you the answer. What more do you want?
14:26:09 <Fuuzetsu> https://github.com/mongodb/mongo-java-driver/commit/d51b3648a8e1bf1a7b7886b7ceb343064c9e2225#L1R212 they were getting swamped with errors or something
14:26:44 <mkscrg> @pl \b x y -> if b then x else y
14:26:44 <lambdabot> if'
14:26:55 <dmwit> Solution one: fix the errors. Solution two: stop reporting the errors.
14:27:00 <dmwit> Notice something funny about what they decided?
14:27:06 <quchen> Fuuzetsu: "I got a wide screen and wants to test how much I can pack in a line"
14:27:54 <tabemann> one solution would be to only report the first N errors, and *then* report only the Nth error, with the frequency being the inverse of the logarithm of the number of errors so far
14:27:55 <quchen> dmwit: Wait, WAT - I didn't read the comments until you said that
14:27:59 <Fuuzetsu> quchen: Keeping Java to <80C is extremely hard.
14:28:27 <Fuuzetsu> Especially if you have Enterprise Quality Names™ that are 50C each.
14:29:18 <JoeyA> Here's where it started, by the way: https://jira.mongodb.org/browse/PYTHON-532
14:30:23 <mkscrg> where is lambdabot finding if'?
14:30:28 <elliott> itself
14:31:12 <mkscrg> i.e. it's not doing package lookups?
14:31:13 <dmwit> Prelude.Dmwit
14:31:44 <dmwit> if'    p x y = if p then x else y
14:31:44 <dmwit> bool   f t p = if p then t else f
14:38:42 <bobry> is there a mode for editing Alex files?
14:39:02 <bobry> (an Emacs mode)
14:39:18 <quchen> dmwit: What does your code smell say about using Unix time in Haskell? (Opposed to ModifiedGregorianTypeCalendar)
14:39:30 <quchen> s/smell/nose
14:49:22 <robde> nooodl_:  could you provide a little example for this?
14:49:28 <enigmuriatic1> if i make a shell command using System.Cmd, the program will wait for it to finish no matter how long it takes, right?
14:50:20 <hpc> enigmuriatic1: it is a blocking call, so yes
14:50:27 <hpc> enigmuriatic1: how else to produce an exit code at the end?
14:50:39 <quchen> enigmuriatic1: Yes. The docs specify in what cases it may fail (and how): http://hackage.haskell.org/packages/archive/process/latest/doc/html/System-Process.html#v:system
14:50:54 <hpc> i like how the docs mention COMMAND.COM
14:51:01 <nooodl_> robde:
14:51:08 <quchen> hpc: Like GHC is multiplatform :>
14:51:12 <nooodl_> > let f xs bs = [x * x | (x, True) <- zip xs bs] in f [1,2,3,4,5] [True, False, False, True, False]
14:51:13 <lambdabot>   [1,16]
14:51:47 <hpc> quchen: more the way it dates that module
14:51:56 <robde> nooodl_: (.) is a partially applyied function?
14:52:16 <nooodl_> which "this" were you talking about?
14:56:36 <robde> nooodl_: where can I read about this notation you are using? (.).(.)?
14:57:32 <augur> robde: (.).(.) is just a mix of infix and prefix notation
14:57:54 <augur> robde: any infix operator, such as + or * or . can be turned into a prefix function (like a normal function) by putting it in parens
14:58:01 <augur> robde: so 1 * 2 is the same as (*) 1 2
14:58:23 <tabemann> and when referring to infix functions by themselves, as functions, you have to refer to them that way
14:58:36 <augur> . is the compose function, so (.) is the prefix version of this. (.).(.) means compose "compose" with "compose"
14:58:47 <augur> :t (.).(.)
14:58:49 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
14:59:50 <augur> robde: as it happens, (.).(.) is another way of writing compose2, defined as:   compose2 f g x y = f (g x y)
15:00:51 * tabemann 's brain fails to parse (.).(.) besides the obvious
15:01:10 <augur> im told they're boobs but they look like eyes to me
15:01:25 <tabemann> boobs would be (.)(.)
15:01:42 <hpc> (.).(.) is idiomatically written (.)(.)(.)
15:01:44 <robde> dmwit: sorry, my chat history does not reach that far
15:01:45 <augur> i assume . in the middle is the navel, and its just really weird
15:01:46 <augur> but
15:01:48 <hpc> and is called the total recall operator
15:01:53 <augur> hpc: :D
15:02:21 <nooodl_> ((.).(.)) f g x y = (.) ((.) f) g x y = ((f .) . g) x y = (f . g x) y = f (g x y)
15:02:33 <nooodl_> wow that looks *really* intimidating and useless on one line
15:02:59 <augur> nooodl_: you just need more spaces around the ='s
15:03:03 <augur> two more on either side should do it
15:03:18 <augur> ((.).(.)) f g x y   =   (.) ((.) f) g x y   =   ((f .) . g) x y   =   (f . g x) y   =   f (g x y)
15:03:47 <augur> ahhhh! D:
15:04:06 <augur> nooodl_: i usually use 3 or 4 spaces around  operators like that
15:04:17 <nooodl_> augur: that looks pretty good
15:04:48 <augur> you need to create visual separation between the things you're talking about -- the terms in haskell -- and the means of talking -- the ='s
15:05:03 <augur> theres also some kind of analogy to how you'd say these things
15:05:26 <augur> when you say something like "f x y = g z w = ..." you dont just say it as one big blur
15:05:47 <augur> effeckswhyequalsgeezeedoubleyouequals...
15:05:54 <augur> you put pauses for people to process, right
15:05:57 <tabemann> this whole discussion has yet to convince me why anyone would ever think that (.).(.) was a good idea
15:06:03 <augur> and maybe add some extra verbiage
15:06:25 <augur> f applied to x then y ... is equal to .. g applied to z then w ... which is equal to ..
15:06:55 <augur> tabemann: i dont think anything things it is, except for lulz
15:07:22 <augur> im not sure anyone actually uses it. i think people probably just write out the lambda
15:07:42 <augur> \x y -> f (g x y)
15:07:57 <dmwit> quchen: Unix time is sometimes unavoidable when interfacing with other tools.
15:08:06 <augur> im not sure anyone has ever actually needed to use (.).(.) itself
15:08:11 <dmwit> Other than that, I feel it's kind of preferable to use Data.Time's other mechanisms.
15:08:12 <robde> dmwit: could you send it again, maybe I overlooked it?
15:08:33 <dmwit> robde:
15:08:35 <dmwit> :t (foldr (\(x, f) -> if f == True then (x:) else ([]++)) [] .) . zipWith (\x f -> (x * x, f))
15:08:36 <lambdabot> Num a => [a] -> [Bool] -> [a]
15:08:57 <nooodl_> i'm not sure what robde's goal is
15:10:52 <dmwit> I think his goal is probably "understand Haskell a bit more".
15:10:57 <quchen> dmwit: I'm kind of looking for a timestamp I can easily send via Binary. It's painful.
15:11:11 <dmwit> hm
15:11:20 <quchen> dmwit: I think I'll just go with a type conversion battlefield.
15:11:39 <dmwit> Why is UTCTime hard to send?
15:11:44 <dmwit> (for example)
15:11:51 <quchen> No binary instance.
15:12:09 <dmwit> heh
15:12:17 <quchen> I'm looking for some data type I can send as canonical as possible. :-)
15:12:46 <dmwit> Well, a UTCTime is just an Integer and a Rational.
15:12:55 <dmwit> That should be easy to write an instance for.
15:13:42 <dmwit> :t realToFrac
15:13:43 <lambdabot> (Fractional b, Real a) => a -> b
15:14:06 <quchen> Yeah that's what I was talking about when mentioning the type conversion battlefield.
15:14:11 <quchen> Was just wondering whether I'm overlooking something.
15:15:39 <dmwit> So, get = (\i f -> UTCTime (ModifiedJulianDay i) (realToFrac f)) <*> get <$> get
15:15:55 <dmwit> put (UTCTime (ModifiedJulianDay i) f) = put i >> put (realToFrac f)
15:16:02 <dmwit> code's done =)
15:16:27 * tabemann didn't know you could easily decompose UTCTimes like that
15:17:09 <quchen> dmwit: ooooh UTCTime also has 10^-12 accuracy
15:17:16 <dmwit> mmm
15:17:27 <quchen> The "0 <= t < 86401s" made me think it would only be seconds
15:17:29 <dmwit> Only if your computer does. =)
15:17:39 <dmwit> I mean, only if your computer's clock does.
15:17:39 <tabemann> quchens: as did I
15:17:51 <quchen> dmwit: Well, I don't need picos, just sub-second.
15:18:03 <dmwit> Yes, it does have sub-second resolution.
15:18:05 <dmwit> So that's nice.
15:18:10 <tabemann> hopefully getCurrentTime is implemented in terms of clock_gettime on here...
15:19:27 <dmwit> Actually, I guess you'd want to write instances of the get and put classes for Day and DiffTime; then the instance for UTCTime is even more boring, just get = UTCTime <$> get <*> get and put (UTCTime i f) = put i >> put f
15:19:47 <dmwit> That's just pushing the realToFrac's and newtype tagging into the other instances, though. =)
15:20:41 <dmwit> quchen: You might consider petitioning the maintainer to add Binary instances.
15:20:46 <dmwit> I think he goes by yitz in here?
15:21:41 <dmwit> They might go in time-extras, for example.
15:22:52 <robde> dmwit: sorry, my chat history is very limited
15:27:05 <quchen> dmwit: DiffTime is evil.
15:27:23 <dmwit> ?
15:27:27 <quchen> newtype DiffTime = MkDiffTime Pico
15:27:31 <quchen> Ctrl+F pico
15:27:34 <quchen> ... nothing
15:27:38 <dmwit> Who cares?
15:27:50 <dmwit> realToFrac :: Rational <-> DiffTime
15:28:19 <quchen> Isn't that one way only?
15:28:24 <dmwit> nope
15:28:36 <quchen> Oh.
15:28:49 <elliott> Pico is from Data.Fixed
15:30:34 <dmwit> elliott: (...but that isn't really helpful, because Data.Fixed doesn't export Pico's constructors and Data.Time.Clock doesn't export what you need to turn a DiffTime into a Pico anyway.)
15:30:53 <elliott> right
15:31:44 <tabemann> does a Double provide enough resolution to handle all the time since the epoch in picoseconds?
15:31:59 <tabemann> if it doesn't... what's the use in DiffTime measuring time in picoseconds?
15:32:08 <dmwit> DiffTime doesn't use Double.
15:32:10 <tabemann> (not that the system clock has anywhere near that resolution anyways)
15:32:11 <dmwit> Next question, please.
15:32:27 <tabemann> I mean when using realToFrac time :: Double
15:32:41 <dmwit> Nobody is using realToFrac :: DiffTime -> Double.
15:33:20 <thoughtpolice> can i ask why you'd ever do that?
15:33:42 <dmwit> What is "that"?
15:33:54 <thoughtpolice> realToFrac :: DiffTime -> Double
15:33:57 <quchen> ................. DiffTime's data constructors aren't exported.
15:34:06 <dmwit> quchen: correct
15:34:09 <tabemann> umm... when you want to expose some time interval to arbitrary calculations, e.g. taking a time interval between frames and turning it into a frame rate (its reciprocal)
15:34:26 <dmwit> thoughtpolice: can't think of a reason; maybe to interface with something external that use CDouble or something...?
15:34:53 <quchen> dmwit: Oh wait, nevermind, silly me
15:34:59 <quchen> dmwit: sorry for the dumb.
15:35:00 <dmwit> tabemann: The functions you might want to use for that are polymorphic enough to handle DiffTimes.
15:35:50 <dmwit> e.g. recip :: DiffTime -> DiffTime
15:36:09 <tabemann> well I partially used it also so that I could strip off the "s" that DiffTime adds when feeding it into show (because a framerate doesn't make sense in terms of seconds)
15:37:03 <tabemann> as the unit for a framerate is 1/s
15:37:15 <dmwit> Solution: don't use "show" for that.
15:38:01 <dmwit> Double is just the type you're most familiar with munging. But that doesn't mean everything should be converted to Double before munging.
15:39:57 <poco> hi
15:40:28 * dmwit waves
15:41:03 <tabemann> so random stupid question: is there a general Num a => a -> String conversion routine which won't do things like add "s" to my String when used with DiffTime?
15:41:21 <poco> i'm using the repa library. i splitted a 3d array into 2d slices, apply some operations on them, and now i want them joined back. is there any operation for that?
15:41:35 <hpc> tabemann: no
15:41:44 <elliott> well, you can convert to Double and then show
15:41:50 * dmwit sighs
15:41:52 <hpc> elliott: no such function exists
15:41:53 <tabemann> elliott: what I was doing
15:42:02 <dmwit> Don't convert to Double.
15:42:04 <hpc> what would it be for Complex?
15:42:09 <dmwit> Convert to something else. Like Pico, for example.
15:42:12 <hpc> what would it be for Num a => b -> a?
15:42:17 <elliott> hpc: what?
15:42:23 <dmwit> Pico is a good choice, because DiffTime is like Pico.
15:42:34 <hpc> elliott: a general function has to work for ALL numbers
15:42:36 <elliott> the function I mentioned certainly exists. it may not be a good idea. it exists. it is true that it isn't "Num a =>"
15:42:40 <hpc> and that's the question that was asked
15:42:40 <dmwit> Rational is a good choice because it's always lossless.
15:42:44 <dmwit> Double is not a good choice.
15:42:50 <elliott> but you can find that out just by looking at the resulting type.
15:45:29 <tabemann> from looking at it, Pico is a fixed-point type... I'm not sure if that's what I would want, if I want to, say, turn seconds between frames into frames per second and spit it out to the user
15:46:04 <tabemann> well, it might work
15:46:05 <hpc> Pico is pretty damn small
15:46:41 <hpc> excepting situations of minutes per frame, i expect rounding error will be much less than timing error
15:46:59 <tabemann> the system clock certainly doesn't have *nearly* that amount of resolution anyways
15:47:16 <hpc> CPU is microseconds per op
15:47:29 <hpc> pico is at least a million times smaller
15:48:17 <troydm> word pico was permamently damaged in my brain after watching certain japanese animation
15:48:27 <troydm> nvm
15:48:32 <tabemann> and considering I'm taking the reciprocal of it... I only really care about the part before the decimal point after that
15:48:49 <tabemann> where we are talking about values in the range of approximately 0 < x < 100
15:49:35 <tabemann> I'm pretty sure that a Double representing the time in seconds since midnight is all the resolution I need
15:49:44 <dmwit> Okay then!
15:51:56 <tabemann> for other purposes (e.g. transmitting dates over the wire, as mentioned before)... I don't see any good way to deconstruct a DiffTime into an Integer and a Pico in the documentation; it doesn't seem any constructor is exported for DiffTime
15:52:18 <dmwit> realToFrac :: DiffTime -> Pico
15:52:55 <dmwit> The secret of the time library is that 90% of the functionality is in the instances.
15:54:01 <dmwit> More helpfully, realToFrac :: DiffTime -> Rational (since everything you can do with a Pico you can already do with a DiffTime anyway).
15:55:26 <dmwit> If you literally want what you said, though, there's second realToFrac . properFraction :: DiffTime -> (Integer, Pico).
15:56:35 <quchen> dmwit: How can I be sure that realToFrac is a bijection?
15:56:47 <dmwit> It's not.
15:57:22 <quchen> So when you said "realToFrac :: Rational <-> DiffTime", that was just a type-based statement?
15:57:27 <dmwit> yes
15:57:40 <quchen> Hmpf.
15:57:54 <dmwit> However, it should be true that "realToFrac :: Rational -> DiffTime . realToFrac :: DiffTime -> Rational" is id.
15:57:58 <dmwit> Which is all you need.
15:58:17 <dmwit> If you want to be sure of that, you'll need to look at the instance implementations for Pico.
15:59:15 <tabemann> okay, I was just wondering how to escape from the DiffTime type while not losing resolution, that's all
15:59:38 <dmwit> Escape to a type that has at least as much resolution as DiffTime.
16:01:21 <dmwit> quchen: (That is to say: converting from a Rational to a DiffTime and back can't be the identity, because DiffTime only has picosecond accuracy. So the rational that represents, say, half a picosecond cannot roundtrip. The other direction of roundtrip is perfectly fine, though.)
16:01:33 <tabemann> ack - hSelect blocks *all* Haskell threads while waiting - well, there goes one of my favorite tools in imperative coding...
16:01:50 <quchen> dmwit: Right. One-way id. ;-)
16:01:57 <dmwit> What is hSelect?
16:02:20 <tabemann> it is the Haskell wrapper around the select() call, for waiting on file descriptors and/or waiting a given amount of time
16:02:34 <dmwit> You definitely should not need to call this.
16:02:40 <dmwit> The GHC runtime includes an IO manager.
16:03:01 <elliott> we use threads for that in GHC
16:03:06 <dmwit> ...which I think probably uses epoll or similar instead of select in the background, but the effect is the same.
16:03:26 <dmwit> So, to wait for an amount of time: threadDelay amountOfTime
16:03:33 <dmwit> To wait for a file descriptor, just use it.
16:03:54 <tabemann> I've always been used to using select(), poll(), or epoll() for managing multiple file descriptors rather than trying to devote a thread per file descriptor, which I've always found to be less efficient
16:04:06 <elliott> GHC threads are different.
16:04:09 <dmwit> GHC threads are not OS threads.
16:04:09 <elliott> they are not OS threads
16:04:16 <elliott> (though they can run on multiple OS threads)
16:04:21 <magicman> Green threads ftw. How many? Thousands? Pfft.
16:04:41 <elliott> it is ok to start thousands, even millions of threads, and the IO you do from those threads will use the equivalent of select under the hood.
16:04:46 <hpc> as many threads as your memory has room for :D
16:05:09 <magicman> It's pretty badass.
16:05:15 <elliott> I would say this is even GHC's "killer app" for networking stuff. write in a simple threaded style, and get node.js-style performance without CPS-transforming all your code.
16:05:27 <dmwit> tabemann: http://stackoverflow.com/q/11744527/791604
16:05:49 <dmwit> tabemann: also, http://dmwit.com/gtk2hs but skip the gtk stuff
16:06:25 <dmwit> So, like, the "Why Threading is Hard", "Conventions", "Foreign Imports", and maybe "The Non-Threaded Runtime" sections.
16:06:34 <dmwit> I really should make a version of that post that's just the non-gtk bits.
16:06:50 <elliott> it's like a choose your own adventure
16:07:02 <elliott> "if you care about gtk, go to section 3"
16:07:11 <dmwit> yeah =)
16:07:26 <tabemann> okay, I've always been used to environments with relatively expensive threads, and with things quickly slowing down with (OS) threads if you try to use too many of them
16:08:06 <tabemann> I'd forgotten that GHC threads were green threads (even though I do remember that there's a compiler option to make it use more than one OS thread)
16:08:15 <elliott> it's a runtime option, actually
16:08:26 <dmwit> It's a compiler option.
16:08:26 <elliott> btw, you probably want to be compiling with -threaded, even if you only run with one OS thread, IIRC
16:08:38 <elliott> dmwit: well, -N is an rts flag
16:08:44 <dmwit> -N does not control the number of threads.
16:08:54 <dmwit> See the "Common Myths" section at http://dmwit.com/gtk2hs =)
16:09:00 <tabemann> okay, so -threaded doesn't force it to do a one-GHC thread to one-OS thread correspondance, just allows it to have more than one OS thread
16:09:10 <dmwit> correct
16:09:11 <elliott> bah, looks like I need to do some choose your own adventuring myself then :)
16:09:20 <tabemann> okay, I need to get going now
16:09:22 <magicman> I will now read that page, and choose an appropriate adventure.
16:09:49 <elliott> dmwit: ok, right. I claim that my previous understanding of -N was "close enough" :P
16:09:53 <dmwit> =)
16:10:06 <tabemann> see ya
16:15:59 <Dacto> Is there a trick to using parList with mapping a list?
16:17:02 <dmwit> Maybe you should tell us what you tried, what you expected to happen, and what happened instead.
16:17:07 <hpc> dmwit: neat! so the number of OS threads is -N plus active forkOS calls plus active safe ffi calls?
16:17:26 <dmwit> hpc: Well, that gives a lower bound on the number of OS threads.
16:17:35 <Dacto> essentially I did this: (map f hugelist `using` parList rdeepseq)
16:17:47 <dmwit> hpc: I'm pretty sure that GHC currently doesn't have any code for releasing threads from its pools back to the OS.
16:17:57 <hpc> that's a bummer
16:18:01 <hpc> will it reuse threads?
16:18:01 <dmwit> hpc: So if at some point in the past one of the pools needed to allocate a lot of threads, they'll still be around.
16:18:03 <Dacto> and when the stats from +RTS -s report that no sparks or anything were created
16:18:07 <elliott> does GHC even release memory to the OS yet?
16:18:07 <dmwit> hpc: Yes, absolutely.
16:18:08 <Dacto> then*
16:18:38 <Dacto> and runtime without parList is about the same as with
16:18:44 <dmwit> hpc: Each capability tries to take an unused thread from its pool before it expands the pool.
16:18:51 <hpc> i know that fairly recently it became possible to change the number of capabilities
16:19:02 <hpc> er, change it downward
16:19:22 <dmwit> Ah, that's true. I guess it must release threads in that case.
16:19:48 <dmwit> Dacto: huh, strange
16:19:50 <Fuuzetsu> I'm trying to install lifted-based but cabal fails during linking. Here's the build log with --verbose http://hpaste.org/89046 . Any ideas?
16:20:11 <hpc> http://hackage.haskell.org/packages/archive/base/latest/doc/html/GHC-Conc-Sync.html#v:numCapabilities
16:20:52 <dmwit> I wonder what happens if you "setNumCapabilities 0". =)
16:20:59 * dmwit runs off
16:21:40 <hpc> dmwit: compare with http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/GHC-Conc.html#v:getNumCapabilities
16:21:47 <hpc> that note about increasing has been removed
16:21:55 <hpc> so it seems you can reclaim capabilities
16:22:01 <hpc> could be a neat thing to try and automate
16:22:18 <Dacto> dmwit: does it matter if the result is being assigned to a let in do block?
16:22:36 <Hodapp> I am interested in the concurrency capabilities of Haskell; I don't know anything about them at the moment, but I have dealt with the pain of a C++ app that thinks it can do things concurrently.
16:22:57 <hpc> Hodapp: might as well learn it the right way first; start with STM
16:23:59 <Hodapp> hpc: software transcational memory?
16:24:02 <Hodapp> s/cat/act/
16:30:15 <Hodapp> hpc: what about STM makes it the 'right' way?
16:32:01 <hpc> Hodapp: it's cool :P
16:34:03 <hpc> oh hey, finally more implementations of STM
16:34:16 <hpc> i remember last i checked haskell had the only one listed on wikipedia
16:34:25 <Hodapp> hmmm
16:43:46 <dmwit> Dacto: You might want to make a minimal example that people here can try out on their own.
16:46:30 <Dacto> dmwit: I figured it out >.< I'm new to parallel haskell and I was calling rts on the wrong thing..
16:46:35 <Dacto> doh..
16:46:37 <satshabad> could someone help me understand how this function is compsed?
16:46:40 <satshabad> repli = flip $ concatMap . replicate
16:46:50 <satshabad> I've tried drawing it out
16:47:13 <satshabad> let concatMap = f(x, y)
16:47:32 <satshabad> repli = g(w, z)
16:47:39 <satshabad> so what is f of g?
16:48:04 <satshabad> f(g(w,z),y) ?
16:48:15 <dmwit> concatMap and replicate do not take tuples.
16:48:23 <dmwit> ?src (.)
16:48:23 <lambdabot> (f . g) x = f (g x)
16:48:23 <lambdabot> NB: In lambdabot,  (.) = fmap
16:48:39 <dmwit> So: concatMap . replicate = \x -> concatMap (replicate x)
16:48:46 <dmwit> ?src ($)
16:48:46 <lambdabot> f $ x = f x
16:49:03 <dmwit> So: flip $ concatMap . replicate = flip (\x -> concatMap (replicate x))
16:49:03 <satshabad> hmmmm
16:49:13 <dmwit> ?src flip
16:49:13 <lambdabot> flip f x y = f y x
16:49:24 <satshabad> is there a command I can use to translate functions to lamdas?
16:49:32 <satshabad> so I can see them like you're explaining?
16:49:53 <dmwit> I'm not sure I understand. Isn't ?src that command?
16:50:09 <satshabad> oh?
16:50:14 <satshabad> i'll try it
16:50:41 <satshabad> I mean on ghci
16:50:46 <dmwit> ah
16:50:51 <dmwit> Not really. =)
16:50:56 <dmwit> You can install lambdabot locally.
16:51:04 <dmwit> Rumor has it that this is now something even a non-expert can do.
16:51:22 <dmwit> But I would just recommend using lambdabot on IRC.
16:51:32 <dmwit> You can /msg lambdabot if you don't want to clutter the channel.
16:51:44 <satshabad> ah cool. thanks.
16:51:46 <elliott> also, don't trust @src.
16:51:50 <elliott> it isn't perfect :P
16:52:05 <satshabad> OK so let me see if I understand the original thing
16:52:19 <satshabad> yeah I bet I will get better faster if I try to do it myself
16:52:28 <dmwit> For sure!
16:52:32 <dmwit> Let us know if you get stuck.
16:52:34 <elliott> well, @src doesn't do something you can do by hand.
16:52:41 <elliott> it looks up source code of standard definitions
16:52:47 <elliott> (by hand = without looking it up yourself)
16:53:03 <satshabad> ah, i see. What I meant was this:
16:53:04 <satshabad> concatMap . replicate = \x -> concatMap (replicate x)
16:53:34 <satshabad> turning partials and other functions into lamda representations
16:53:41 <elliott> @unpl concatMap . replicate
16:53:41 <lambdabot> (\ c -> concatMap (replicate c))
16:53:46 <elliott> voila :)
16:53:53 <satshabad> ah, exaclty
16:54:01 <satshabad> unpl? what does that stand for?
16:54:05 <dmwit> But you can do this just by looking at the source of (.).
16:54:07 <elliott> unpointfree
16:54:11 <elliott> aka unpointless
16:54:17 <elliott>  @pl does the opposite
16:54:18 <satshabad> a lambdabot thing only?
16:54:22 <elliott> yes
16:54:25 <satshabad> ohhh
16:54:26 <dmwit> (f . g) x = f (g x) -- or, equivalently, f . g = \x -> f (g x)
16:54:26 <satshabad> cool
16:54:28 <elliott> there is a command line tool though
16:54:31 <elliott> maybe not for the un version
16:54:37 <dmwit> Now substitute in "concatMap" and "replicate" instead of "f" and "g".
16:54:54 <satshabad> sweet
16:55:46 <satshabad> @unpl flip $ concatMap . replicate
16:55:46 <lambdabot> (\ b c -> concatMap (replicate c) b)
16:55:57 <satshabad> yey for lamdabot!
17:06:58 <yogert> Hey all, I'm having some trouble with using the State Monad with Parsec. I'm not sure whether I'm simply approaching the problem wrong, or don't understand Parsec / State. The paste is a bit wordy… http://hpaste.org/89047
17:07:19 <yogert> The question is towards the bottom
17:07:21 <yogert> : )
17:13:26 <Luke_> does haskell have any mechanism for knowing what exceptions may be thrown by any given function?
17:13:59 <Botje> yogert: it seems kind of overkill to use the state monad there.
17:13:59 <elliott> no, other than reading it
17:14:53 <Botje> yogert: if you know you're always going to get lines like 1. ... ..., 2. ... ..., just incorporate them into your parser
17:16:02 <Botje> parseAction = do { turn <- parseTurn; spaces; move1 <- parseMove turn; spaces; move2 <- parseMove turn; return (move1, move2) }
17:17:49 <Botje> yogert: and then parseActions = parseAction `sepBy` newline
17:17:58 <Botje> with some magic to catch 0-1 and 1-0 at the end.
17:19:20 <yogert> Botje: Well I initially parsed each one that way, but I wasn't such how I'd put it into a recursive datatype afterwards without storing them in a flat list and processing them later. Also, that method (I think) has the problem of inconsistent types. For example "20. Qxh7# 1-0" would only return one action when two are expected.
17:20:21 <yogert> I suppose I could add a "NoAction" type constructor but that seems kinda ugly
17:20:49 <Botje> yogert: nobody's stopping you from chaining the turns together yourself
17:21:09 <Botje> just return something smarter than (move1, move2) :)
17:21:22 <Botje> but the other thing is true, yes.
17:21:59 <yogert> Botje: so return a each as a partially applied type constructor, then flatten the list, and nest it with foldr or something?
17:22:11 <yogert> err
17:22:12 <yogert> wait
17:22:42 <Botje> yogert: parseActions = do {move1 <- ...; move2 <- ...; rest <- parseActions; return (move1 `chain` move2`chain`rest }
17:22:50 <Botje> for suitable implementations of chain and parseactions
17:23:21 <yogert> is chain from parsec?
17:23:30 <Botje> no, chain would be something you implement yourself.
17:23:41 <yogert> oh ok
17:23:54 <yogert> that would be pretty straight forward
17:24:14 <Botje> I gotta go sleep now though, otherwise i'd be more proactive
17:24:31 <yogert> alright, well thanks for your input. It is much appreciated :
17:24:32 <yogert> : )
17:32:06 <Aetherspawn> Let's say I need to store an obscene amount of data and look it up fairly quickly based on a number
17:32:22 <c_wraith> how much is obscene?
17:32:30 <Aetherspawn> like, say, 5000 items
17:32:36 <c_wraith> that's...  hardly anything
17:32:48 <Aetherspawn> I didn't get to state the next part :)
17:32:48 <c_wraith> unless each item is hundreds of megabytes
17:32:55 <Aetherspawn> Each item is a few kb
17:33:08 <Aetherspawn> Anyhow, the next requirement is that I need to be able to graft concurrancy over it
17:33:15 * elliott thinks your notion of obscenity needs recalibrating
17:33:22 <c_wraith> we have different definitions of obscene, that's for sure
17:33:29 <c_wraith> I don't consider a couple megabytes to be obscene :P
17:33:31 <Aetherspawn> so that when items get added it doesn't mess up everyone's reads
17:33:46 <Aetherspawn> What would be an appropriate structure for this
17:33:50 <c_wraith> anything
17:34:24 <c_wraith> like, seriously.  That isn't much data.  And haskell data structures have an awesome property called persistence.
17:34:43 <Aetherspawn> It's quite performance critical; each item might get accessed 20 times per second
17:34:51 <c_wraith> ...  20 times per second is also nothing
17:34:56 <Aetherspawn> ;_;
17:35:31 <c_wraith> We have a system that can handle several hundred full user login events per second.  Each of those consists of a ton of various lookups and updates. >_>
17:35:53 <c_wraith> and that's talking to a an external backing relational database.
17:36:06 <hpc> c_wraith: i assume it consists of bcrypt? :P
17:36:21 <c_wraith> hpc: it can, but that requires more machines in the cluster
17:36:36 <Aetherspawn> is there like a binary tree structure I can use
17:36:46 <c_wraith> Aetherspawn: in any case, let's start with the simplest possible answer, and say Data.IntMap
17:37:03 <c_wraith> It's got a simple interface designed for Int keys
17:37:31 <c_wraith> (it's a patricia trie as the backing structure, if you care)
17:38:16 <c_wraith> Aetherspawn: if you need to update it in a concurrent environment, there are a couple of things to do with it.
17:38:44 <Aetherspawn> The items can be locked induvidually, I think
17:39:02 <c_wraith> Aetherspawn: if you expect writes to be rare, reads to be common, and don't need strict ordering, you can store the structure in an IORef and update it with atomicModifyIORef
17:39:03 <Aetherspawn> It's just when adding or removing from the list that I really need to lock the whole thing
17:41:24 <elliott> or just use STM.
17:41:58 <Hodapp> I should read about STM.
17:42:15 <Hodapp> It seems people here like it, which mostly just means that I've had two people today mention it favorably.
17:52:29 <quidnunc> How do I convert from a string to a hexadecimal string representation of that string?
17:53:44 <c_wraith> quidnunc: step 1. convert to a sequence of bytes that represent that string, via whatever unicode encoding you like.  step 2. convert each byte to a 2-character string  step 3. concatenate them together
17:53:48 <chrisdotcode> hi all :)
17:57:04 <dmwit> I have an alternate strategy.
17:57:11 <dmwit> od -x
17:58:04 <dmwit> or xxd or whatever
18:03:28 <pqmodn> what's the name for the logical theorem (a -> b -> c) -> (b -> a -> c)?
18:03:37 <elliott> flip
18:03:58 <pqmodn> right, but what would it be referred to in a book on logic?
18:04:23 <pqmodn> is it commutativity of some sort?
18:05:25 <canta> can I just specify one case of instance Show and let the rest be auto-derived?
18:07:44 <dmwit> canta: Sorry, no.
18:08:01 <dmwit> canta: (I'm assuming you mean like give an instance of Show for just one of the constructors or something like that.)
18:09:02 <dmwit> pqmodn: I'm not sure that theorem has a standard name.
18:09:40 <dmwit> pqmodn: But (a /\ b) <-> (b /\ a) might reasonably be called commutativity of /\
18:10:30 <pqmodn> dmwit: thanks
18:12:48 <canta> dmwit: yes, thanks.
18:18:33 <pferor> hello
18:18:52 <pferor> does GHC and/or HUGS compile lsh files by default without any extension
18:18:53 <pferor> ?
18:19:04 <pferor> *lhs
18:19:12 <dmwit> yes, both
18:19:14 <Cale> pferor: they'll work with such files
18:19:25 <pferor> thanks Cale and dmwit
18:20:48 <hpc> pferor: oh god, avoid hugs
18:21:04 <hpc> pferor: it's been almost 10(?) years since the last release
18:21:07 <pferor> hpc: I always use GHC
18:21:20 <pferor> but my teacher is old-fashion
18:21:54 <pferor> and he installs hugs only
18:27:23 <pqmodn> dmwit: aha, i think it's just the associative property: f a (f b c) -> f (f a b) c, in the example f is (->)
18:27:51 <dmwit> what
18:27:58 <pqmodn> dmwit: nevermind, forgot i switched the as and bs earlier. darn
18:28:14 <dmwit> a -> b -> c does not imply (a -> b) -> c
18:28:50 <pqmodn> yeah, that too. damnit
18:38:38 <philipdexter> > succ ()
18:38:39 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
18:38:43 <philipdexter> what does that error mean?
18:39:09 <geekosaur> that there is no successor
18:39:21 <Cale> philipdexter: The instance of Enum for () has an implementation of succ which just errors
18:39:30 <pqmodn> > succ False
18:39:31 <lambdabot>   True
18:39:32 <pqmodn> > succ True
18:39:33 <lambdabot>   *Exception: Prelude.Enum.Bool.succ: bad argument
18:39:53 <elliott> succ maxBound must be an error, and so it is
18:40:02 <Cale> I don't think succ and pred belong in Enum
18:40:12 <philipdexter> ah, alright, I made my own data type and it gave a slightly different error when the last value was met, so I had to check
18:40:21 <geekosaur> they don't, but that's an old argument and one of the things that will probably never be fixed
18:40:22 <Cale> Enum should really just be a class for defining what the various list enumeration syntaxes mean, imo
18:41:00 <Cale> I don't think it would have a *huge* impact to move them into their own class
18:41:02 <pqmodn> Cale, like the [n..] and [n..m] syntaxes?
18:41:05 <Cale> yes
18:41:06 <philipdexter> thanks all
18:41:12 <elliott> Cale: Enum overlaps with Ix too
18:45:19 <tomjack> I hope the comonad reader is not gone forever!
18:45:39 <edwardk> no. it shall be reborn
18:45:51 <edwardk> i just need to figure out how to manage my time better. =)
18:47:27 <tomjack> edwardk: I just want the existing articles, e.g. I go back to 'representing applicatives' maybe weekly :). google cache seems to have lost them - but I didn't check the wayback machine yet
18:48:21 <edwardk> i just need to finish setting wordpress and all that crap back up
18:48:27 <quidnunc> What is the right way to fold a "shows"?
18:49:17 <tomjack> ah, I misunderstood
18:54:42 <philipdexter> i know what the term `instance' normally means in Haskell, but I'm wondering what you would call a variable with type, for example, Shape. Would it be an `instance' of Shape?
18:55:23 <byorgey> philipdexter: no, you just say it has type Shape.
18:55:59 <philipdexter> byorgey: thanks! I had a hunch since I didn't see it mentioned in the literature
18:56:02 <elliott> I would say it's "a Shape"
18:56:11 <elliott> or "a value of Shape" or "a value of type Shape" if I want to be verbose
18:57:18 <quidnunc> Is there a better way to do this? (foldl (\sofar x -> sofar . (showHex x)) (showHex 23) (map ord "zwyx")) ""
18:58:59 <dmwit> > foldl (\sofar x -> sofar . showHex x) (showHex 23) (map ord "zwyx") ""
18:59:01 <lambdabot>   "177a777978"
18:59:31 <dmwit> > showHex 23
18:59:32 <lambdabot>   *Exception: show: No overloading for function
18:59:37 <dmwit> > showHex 23 ""
18:59:38 <lambdabot>   "17"
18:59:44 <dmwit> > showHex (ord 'z') ""
18:59:46 <lambdabot>   "7a"
19:00:13 <dmwit> :t readIntAtBase
19:00:14 <lambdabot> Not in scope: `readIntAtBase'
19:00:17 <dmwit> :t readInt
19:00:19 <lambdabot> Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
19:00:50 <dmwit> > readInt 26 (\x -> x `elem` ['a'..'z']) (\x -> ord x - ord 'a') "zwyx"
19:00:51 <lambdabot>   [(454919,"")]
19:01:12 <dmwit> > readInt 255 (\x -> ord x < 256) ord "zwyx"
19:01:14 <lambdabot>   [(2030696700,"")]
19:01:22 <dmwit> > showHex 2030696700 ""
19:01:24 <lambdabot>   "7909f8fc"
19:01:46 <dmwit> derp
19:01:50 <dmwit> > readInt 256 (\x -> ord x < 256) ord "zwyx"
19:01:51 <lambdabot>   [(2054650232,"")]
19:01:58 <dmwit> > showHex 2054650232
19:01:59 <lambdabot>   *Exception: show: No overloading for function
19:02:02 <dmwit> > showHex 2054650232 ""
19:02:03 <lambdabot>   "7a777978"
19:02:18 <dmwit> quidnunc: How about this way? =)
19:03:17 <dmwit> > "zwyx" >>= \c -> showHex (ord c) ""
19:03:19 <lambdabot>   "7a777978"
19:03:24 <dmwit> or this way, I guess
19:04:30 <quidnunc> dmwit: thanks
19:15:02 <Aetherspawn> is there any downside in wrapping an object that would prefferrably be interfaced like a "pointer" in an IORef?
19:15:48 <Aetherspawn> (in the context of many threads having a handle to it and using atomicModifyIORef to prevent losing changes)
19:18:21 <elliott> you should not use atomicModifyIORef unless you have a good reason
19:18:26 <elliott> at the very least use an MVar
19:18:30 <elliott> but I'd default to TVar.
19:21:38 <Aetherspawn> elliott, if I copy a tvar out of a hash table, for example
19:21:41 <Aetherspawn> and then another thread does the same
19:22:05 <Aetherspawn> and they both atomically update it, are the changes reflected or do I end up with 2 different tvars
19:22:23 <Aetherspawn> ie: what will a third thread grabbing the tvar out of the hash table see?
19:23:09 <tabemann> that should only result in a single TVar...
19:24:16 <elliott> Aetherspawn: what do you mean by copying a TVar?
19:25:10 <Aetherspawn> var <- lookup x -- maybe
19:25:45 <elliott> where's the copying?
19:25:49 <tabemann> making new references to something doesn't make new underlying instances...
19:26:03 <elliott> if one thread gets a value out of a hash table, and another thread gets the same value out of a hash table, of course it's the same value
19:26:11 <elliott> (unless you inserted a different value in the interim)
19:26:30 <Aetherspawn> That's what I was looking to find out :) thanks
19:27:19 <geekosaur> that's largely the point of IORef, STRef, MVar, TVar, ec.
19:28:05 <Aetherspawn> Maybe, just so I don't get it wrong, is the only way to "copy" a TVar through newTVar with a value given by an existing one?
19:28:42 <geekosaur> yes
19:28:45 <Aetherspawn> That's really convenient!
19:28:48 <Aetherspawn> thanks
19:29:48 <geekosaur> again, that's largely the point; the TVar contains a reference to a mutable "cell", the TVar itself may be "copied" but the copy contains the same reference to the same "cell"
19:35:18 <Hodapp> this O'Reilly book is making some interesting points on the usefulness of pure functions and lazy evaluation
19:41:22 <tabemann> RWH?
19:46:20 <geekosaur> @where rwh
19:46:20 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
19:50:31 <Hodapp> didn't realize that book was online... oh well, I'll have a print copy soon
19:53:52 <elliott> @where lyah
19:53:52 <lambdabot> http://www.learnyouahaskell.com/
19:53:54 <elliott> also online :)
19:54:06 <Hodapp> I've read a bit of that one
19:54:14 <Hodapp> but now I have an actual project I'm doing
19:58:46 <barrucadu> Hodapp: What is your project?
20:04:56 <zRecursive> @ty format
20:04:57 <lambdabot>     Not in scope: `format'
20:04:57 <lambdabot>     Perhaps you meant `fromRat' (imported from Numeric)
20:06:31 <zRecursive> what's the canonical way to implement (format nil '~s' "foo") in haskell ?
20:09:43 <roconnor> zRecursive: what does that do?
20:10:31 <zRecursive> roconnor: (format nil '~s=~s' "foo" "bar") => "foo=bar"
20:10:41 <elliott> the canonical way is "foo"
20:11:50 <zRecursive> same as sscanf in C ?
20:12:17 <zRecursive> (format nil '~s=~s' "foo" "bar") => 'foo=bar'
20:12:41 <elliott> I don't understand the question.
20:12:44 <roconnor> > (\a b -> showString a . showString "=" . showString b $[]) "foo" bar"
20:12:46 <lambdabot>   <hint>:1:70:
20:12:46 <lambdabot>      lexical error in string/character literal at end of input
20:12:52 <roconnor> > (\a b -> showString a . showString "=" . showString b $ []) "foo" bar"
20:12:53 <lambdabot>   <hint>:1:71:
20:12:54 <lambdabot>      lexical error in string/character literal at end of input
20:13:15 <roconnor> > (\a b -> showString a . showString "=" . showString b $ []) "foo" "bar"
20:13:16 <elliott> I reckon (a ++ "=" ++ b) to be simpler :P
20:13:17 <lambdabot>   "foo=bar"
20:13:28 <elliott> > printf "%s=%s" "foo" "bar"
20:13:29 <lambdabot>   Ambiguous type variable `a0' in the constraints:
20:13:29 <lambdabot>    (GHC.Show.Show a0)
20:13:29 <pqmodn> it's printf, which takes a format string. you probably can't do quite that in Haskell
20:13:29 <lambdabot>     ...
20:13:32 <elliott> > printf "%s=%s" "foo" "bar" :: String
20:13:33 <lambdabot>   "foo=bar"
20:13:46 <pqmodn> hmm
20:14:09 <pqmodn> > printf "%u" 'x' :: String
20:14:09 <zRecursive> @ty printf
20:14:10 <lambdabot>   "120"
20:14:10 <lambdabot> PrintfType r => String -> r
20:14:57 <zRecursive> ok, it is printf
20:15:06 <roconnor> > printf "%d" "hello" :: String
20:15:07 <lambdabot>   "*Exception: Printf.printf: bad argument
20:15:22 <roconnor> no one really uses printf because it is partial.
20:15:25 <pqmodn> > printf "%u" (-1) :: String
20:15:27 <lambdabot>   "*Exception: Char.intToDigit: not a digit -1
20:15:46 <elliott> roconnor: haha, and I suppose nobody uses head either? :)
20:15:47 <roconnor> it impeds the point of type safety
20:15:54 <roconnor> elliott: of course
20:16:07 <Hodapp> roconnor: partial?
20:16:14 <zRecursive> roconnor: "it is partial" means what ?
20:16:32 <pqmodn> it's not defined for all inputs... it throws an exception sometimes
20:16:51 <zRecursive> oh, it is too bad
20:17:09 <zRecursive> what is an alternative way ?
20:17:37 <roconnor> zRecursive: just convert things to string with "show" and append them together.
20:17:53 <zRecursive> roconnor: ok
20:19:03 <zRecursive> ((modm, xK_x), inputPrompt myXPConfig "Eval" >>= flip whenJust (\expr-> spawn $ "~/bin/clisp.sh '" ++ expr ++ "'"))   seems ok ?
20:20:00 <roconnor> @hoogle whenJust
20:20:01 <lambdabot> No results found
20:20:18 <elliott> should be hardcoded to tell you about forM-
20:20:20 <elliott> *forM_
20:20:55 <roconnor> zRecursive: I don't understand much of that, but the string part seems reasonable.
20:21:49 <zRecursive> roconnor: it gets the inputted expr and eval it by clisp.sh
20:22:35 <zRecursive> the expr is Common Lisp expression
20:23:49 <zRecursive> roconnor: it works great, thx
21:55:59 <satshabad> could some one take a look at this and help me understand where I've gone wrong?
21:56:04 <satshabad> http://hpaste.org/89052
21:56:48 <satshabad> I can't quite parse the errors it's giving me. And I don't understand why it insistes that the Num ([a], [a]) constraint must be there
21:57:18 <amosr> satshabad: you probably want to put parens around (n-1)
21:57:28 <satshabad> oh?
21:57:39 <amosr> because it's parsing as (split xs n) - 1
21:57:48 <tabemann> I was just about to say the same
21:57:53 <amosr> and it knows split returns a tuple of ([a],[a])
21:58:18 <amosr> so it tries to treat that as a number
21:58:40 <satshabad> well I'll be damned
21:58:43 <satshabad> that worked
21:58:56 <satshabad> and how did you figure that out again?
21:59:01 <satshabad> by the suggested type sig?
21:59:14 <amosr> yep, because it wanted "Num ([a],[a])"
21:59:29 <tabemann> functions always associate more tightly than operators in Haskell
21:59:34 <amosr> I assumed there was a number operation on tuples somewhere
22:00:00 <tabemann> foo x y - z is always (foo x y) - z
22:00:19 <satshabad> hmmmm ah! because of Num ([a], [a])
22:00:37 <satshabad> ok cool! I'm still getting the hang of where the parens go
22:00:53 <satshabad> is that the same for all infix ops?
22:00:59 <tabemann> yes
22:01:16 <satshabad> ok, I'll remember that
22:01:17 <satshabad> thanks!
22:10:06 <neersighted> anyone seen BONUS?
22:10:38 <elliott> neersighted: not in something like a year, IIRC
22:10:44 <neersighted> lol
22:10:49 <neersighted> just wanted to say his book is pretty good
22:11:45 <neersighted> question: for open source software, is it worth using haskell giving all the overhead of the haskell platform on build slaves?
22:12:14 <neersighted> I love the features, but downloading + installing the haskell platform on all build slaves is a bit painful (for me)
22:13:14 <Ralith> nobody can answer that question but you
22:13:41 <elliott> seems like a pretty minor thing to base a language choice on
22:15:28 <tabemann> most languages you're going to install are going to have some kind of runtime environment to install, and if it doesn't, that's only because it's already installed
22:16:08 <tabemann> most languages you're going to use are*
22:16:57 <latermuse> neersighted: its a pain in the ass to install haskell on some builds more than others
22:49:29 <nrook> oh no! the haskell platform makefile doesn't appear to do any sort of incremental build; if it fails to build a late package, it'll start right over the next time you make
22:49:56 <nrook> and it takes 4 hours to install on this machine... and I was missing a prereq for the 2nd-to-last package :(
22:53:06 <FreeFull> nrook: Ouch
22:53:40 <adnap> I have experienced this with cabal install. It sucks
22:55:39 <nrook> ah well, I'll live :p
23:02:29 <adnap> How would I write a stand-alone deriving instance of Typeable for "data T t a = T a"?
23:05:51 <adnap> First, I treid "deriving instance Typeable T" and GHC said, "Expecting two more arguments to `T'". Then I tried "deriving Typeable (T t a)" and GHC said, "Derived typeable instance must be of the form (Typeable2 T)". Then I tried "deriving instance Typeable2 (T t a)" and GHC said, "Kind mis-match The first argument of `Typeable2' should have kind `* -> * -> *', but `T t a' has kind `*'"
23:06:37 <roconnor_> deriving instance Typeable2 T ??
23:06:39 <adnap> Ah
23:06:39 <adnap> Yes
23:06:46 <adnap> I just tried that and it works :)
23:06:54 <adnap> roconnor_: Thanks
23:10:21 <zRecursive> roconnor_: can "deriving instance Typeable2 T" add those functions in Typeable2 automatically ?
23:10:53 <adnap> zRecursive: Yes
23:11:18 <adnap> zRecursive: You have to use DeriveDataTypeable and StandaloneDeriving extensions
23:11:47 <zRecursive> adnap: how is it general for all different types ?!
23:11:50 <adnap> Someone said the other day that the new GHC is going to derive Typeable instances automatically for every type
23:12:17 <adnap> zRecursive: Because all types are defined with type or data constructors
23:12:36 <adnap> And that's all the info GHC needs to define a Typeable instance
23:13:04 <zRecursive> adnap: but all types  may have different type parameters
23:13:05 <fractalsea> I have a function with type Int -> Int -> Maybe Int. How do I make it return Nothing if a division I do returns a fractional number?
23:13:19 * roconnor_ actually knows nothing about typable
23:14:31 <zRecursive> @hoogle Typeable2
23:14:31 <lambdabot> Data.Typeable class Typeable2 t
23:16:41 <FreeFull> fractalsea:    yourDiv x y = if (x `mod` y) /= 0 then Nothing else Just (x `div` y)
23:16:58 <kurenai> such a peculiar function
23:17:20 <kurenai> what is it for?
23:17:22 <fractalsea> thank you, I will try that out now
23:19:08 <fractalsea> To learn haskell I'm doing a brute force search for combinations of a 4 numbers using combinations of operators +, -, *, / that will == 10
23:19:12 <fractalsea> if that makes sense
23:19:40 <fractalsea> so obviously with division I only want to count results that would be an integer
23:21:03 <FreeFull> Note I wrote that function entirely out of my mind and didn't test it at all
23:22:32 <fractalsea> No worries, I'm testing it now.
23:32:58 <savask> Hello. When I'm compiling a simple program with JHC, it returns: "WARNING: Wrapper still exists at grin transformation time: theMain$28::Jhc.Type.Basic.Integer::* -> Jhc.Prim.Prim.Bool::*" and the compiled binary falls with segfault. What does that warning mean?
23:32:58 <lambdabot> savask: You have 1 new message. '/msg lambdabot @messages' to read it.
23:36:41 <SrPx> @pl \a b -> a*a + b*b + 2*b
23:36:41 <lambdabot> (`ap` (2 *)) . ((+) .) . (. join (*)) . (+) . join (*)
23:36:47 <SrPx> woow
23:37:13 <Iceland_jack> @pl \a -> a * a
23:37:13 <lambdabot> join (*)
23:37:36 <FreeFull> :t join
23:37:37 <lambdabot> Monad m => m (m a) -> m a
23:38:11 <FreeFull> > join (*) 3
23:38:12 <lambdabot>   9
23:38:22 <FreeFull> What monad is that
23:38:27 <SrPx> @pl \x -> (fn (filter (< (head x)) (tail x)) ++ [p] ++ (fn (filter (>= (head x)) (tail x))))
23:38:27 <lambdabot> ap ((++) . fn . ap (filter . flip (<) . head) tail) ((p :) . fn . ap (filter . flip (>=) . head) tail)
23:38:30 <Iceland_jack> ((->) r) monad
23:38:38 <FreeFull> Ah, reader
23:39:02 <SrPx> that's absolutelly awesome
23:39:05 <Iceland_jack> so join ∷ (r → r → a) → r → a
23:39:24 <Iceland_jack> @ty join (>>)
23:39:25 <lambdabot> Monad m => m a -> m a
23:39:29 <Iceland_jack> @ty join (>>) (print "HI")
23:39:30 <lambdabot> IO ()
23:39:53 <fractalsea> If I need to compute a function in a boolean test, and want to return its result if the test passes. What is the best way of doing this? (so that I avoid re-computing)
23:40:19 <Iceland_jack> fractalsea: What do you want to return if the test fails?
23:40:28 <fractalsea> Nothing
23:40:50 <Iceland_jack> let result = f x in if result == 10 then Just result else Nothing?
23:41:10 <fractalsea> yeah that's what I was looking for!
23:42:52 <FreeFull> fractalsea: That will only produce either Nothing or Just 10
23:43:16 <FreeFull> Might as well skip the Maybe wrapping and return a Bool
23:43:21 <Iceland_jack> The predicate was just arbitrary though
23:43:39 <Iceland_jack> it could've been … if result > 10 then …
23:43:54 * hackagebot language-puppet 0.4.2 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.4.2 (SimonMarechal)
23:43:56 <FreeFull> True
23:43:57 <fractalsea> OK hang on I'll paste in what I want to do...
23:47:20 <fractalsea> solve (digit1:digit2:otherDigits) (op:otherOps)
23:47:20 <fractalsea>   | isJust (solve ((subsolve digit1 digit2 op):otherDigits) otherOps) && isJust (subsolve digit1 digit2 op) = solve ((subsolve digit1 digit2 op):otherDigits) otherOps
23:47:20 <fractalsea>   | otherwise = Nothing
23:48:00 <fractalsea> So I obviously want to avoid computing the results multiple times
23:48:11 <Iceland_jack> fractalsea: You can use a where clause
23:48:17 <fractalsea> OK
23:48:32 <fractalsea> I'll look into that, thanks
23:48:43 <Iceland_jack> You're welcome
