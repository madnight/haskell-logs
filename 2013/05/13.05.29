00:31:28 <hiptobecubic> Morning everyone
00:32:55 <hiptobecubic> I'm on linux trying to play with opengl via GLUT. It "works" but I get *massive* flickering when I use an idle callback. here is my example program http://john.bitsurge.net/public/gltest.tar.gz, ghc --make Main, is enough to check. Can anyone verify?
00:34:43 <Lethalman> hiptobecubic, do you double buffer?
00:35:28 <hiptobecubic> Lethalman, i think so? I'm using swapbuffers instead of flush
00:57:14 <shachaf> There are too many Haskell Bens.
01:00:17 <Ralith> shachaf: we are the future
01:04:41 <shachaf> Hmm, I don't remember saying this.
01:04:43 <shachaf> @quote AbstractAlgebra
01:04:43 <lambdabot> shachaf says: type AbstractAlgebra a = Abstract a -> a
01:05:10 <shachaf> Clearly the hidden meaning is that an abstract algebra is a mechanism for generating papers from their abstracts.
01:05:42 <danr> shachaf: by inhabiting AbstractAlgebra Doc? :)
01:14:32 <hiptobecubic> I guess no one tried that OpenGL example?
01:15:07 <killy9999> I have project using C code via FFI and I'm using cabal for building
01:15:22 <killy9999> how can I rebuild necessary files when I modify C source code?
01:15:38 <killy9999> it seems that cabal doesn't notice the change and links the old .o file
01:19:00 <killy9999> I take that back
01:19:18 <killy9999> it seems that it does notoce the changes, just doesn't print any information about compiling C code
01:44:09 * hackagebot robots-txt 0.1.0.0 - Parser for robots.txt  http://hackage.haskell.org/package/robots-txt-0.1.0.0 (MarkWotton)
01:44:11 * hackagebot hs-bibutils 5.0 - Haskell bindings to bibutils, the bibliography  conversion utilities.  http://hackage.haskell.org/package/hs-bibutils-5.0 (AndreaRossato)
01:44:13 * hackagebot robots-txt 0.1.0.1 - Parser for robots.txt  http://hackage.haskell.org/package/robots-txt-0.1.0.1 (MarkWotton)
01:46:30 <blackdog> man, calling Hackage "Haskell's CPAN wanna-be" is a bit brutal
01:47:57 <Cale> blackdog: heh
01:48:34 <hiptobecubic> Hackage has a lot of the same problems that make CPAN a disgusting wreck, unfortunately. :(
01:48:53 <Ralith> those are?
01:49:09 * hackagebot robots-txt 0.1.0.2 - Parser for robots.txt  http://hackage.haskell.org/package/robots-txt-0.1.0.2 (MarkWotton)
01:49:12 <tsinnema> anyone here happen to know whether on freenode there might be some highly active but very obscurely named channel for general discussion about databases that i have just happened to not have found?
01:49:24 <Ralith> I wish someone would make a writeup on all the mistakes made by existing package managers so that a new effort can know what to avoid
01:53:19 <bartavelle> is there a package that makes it easy to dynamically run code from user supplied .hs files ?
01:53:34 <blackdog> bartavelle: perhaps look at HINT
01:53:52 <blackdog> it's not precisely easy, but it's easier than using the ghc api directly.
01:54:07 <bartavelle> ah I already saw that, IIRC I can't feed it easily with my data
01:54:11 * bartavelle checks again
01:54:53 <Kinnison> Taffybar uses dyre
01:55:03 <Kinnison> @hoogle dyre
01:55:03 <lambdabot> package dyre
01:55:09 <Kinnison> @hackage dyre
01:55:09 <lambdabot> http://hackage.haskell.org/package/dyre
01:55:34 <bartavelle> OK I'll look at tgat too
01:55:43 <Kinnison> dyre is configuration in the style of Xmonad
01:55:54 <Kinnison> if that's not what you're after, then it may yet be helpful
02:04:10 <t7> someone port xmonad to wayland
02:12:40 <h4199> Are they even done with breaking changes yet?
02:25:24 <jonkri> for testing of my haskell package, should i compile it with all versions of the haskell platform, or all versions of ghc? (i want to support ghc 7 and above)
02:25:49 <merijn> jonkri: It depends on how thorough you wanna be
02:26:16 <merijn> The lazy mans approach is to test with 7.0 and whichever recent version you use, then wait for people to file bug reports ;)
02:26:17 <blackdog> jonkri: this'd be the sort of thing it'd be really nice to have multiple versions of ghc on something like travisci for
02:27:15 <supki> travisci does not even have real haskell platform
02:29:16 <blackdog> supki: do you think many people take notice of the haskell platform?
02:29:32 <blackdog> maybe i should, but usually i just specify my dependencies and go.
02:29:33 <supki> I don't know
02:29:35 <t7> @pl \pts i -> Set.foldr (\(is, t) s -> if Set.member i is then s + t else s) 0 pts
02:29:35 <lambdabot> flip (flip Set.foldr 0 . (`ap` snd) . (. fst) . flip flip id . ((flip . (ap .)) .) . flip flip (+) . (((.) . (.) . if') .) . Set.member)
02:29:45 <supki> I don't use HP myself
02:29:56 <t7> @pl (\(is, t) s -> if Set.member i is then s + t else s)
02:29:56 <lambdabot> uncurry (flip flip id . (ap .) . (. (+)) . (.) . if' . Set.member i)
02:30:43 <supki> It would be ok if they had just ghc or some real released haskell platform instead of weird pseudo-release they have
02:31:32 <jonkri> merijn: i assume that i will be using cabal (cabal-dev), so i guess that i should test different versions of cabal too
02:31:42 <jonkri> blackdog: thanks, i was not aware of that project
02:31:49 <blackdog> supki: you might blame me for that, actually, i think the existing support is there because i complained in #travisci
02:31:59 <merijn> jonkri: travisCI is nice, integrates with github too :)
02:32:16 <blackdog> jonkri: it's pretty nice - echo 'language: haskell' > .travis.yml and you're pretty much done
02:32:38 <blackdog> (well, you have to turn the repo on in the travisci site, and auth it to github)
02:33:43 <jonkri> blackdog: nice, thanks. what ghc version(s) will it use?
02:34:06 <blackdog> 7.4.1
02:36:45 <jonkri> ok
02:37:01 <blackdog> it works out quite well for me because i usually have the latest version locally, so it gets two tests
02:37:14 <blackdog> but a wider range would certaintly be nice, and i think worth paying for.
02:41:04 <jonkri> blackdog: so... a wider ghc range, integration with git, cabal compilation and e-mail notification on failures... would that be the features that you'd want?
02:43:15 <jonkri> and execution of tests, of course
02:54:10 * hackagebot conduit 1.0.6 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.6 (MichaelSnoyman)
03:04:11 * hackagebot http-conduit 1.9.4 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.9.4 (MichaelSnoyman)
03:16:01 <dav> My 2nd Haskell program: http://paste.debian.net/7289/ -- feedback and suggestions on the coding appreciated :)
03:17:19 <jonkri> dav: i'd put `where' on the next line, with two spaces indentation
03:17:37 <shachaf> Please don't use Data.ByteString.Char8 :-(
03:18:10 <shachaf> Anyway, if you'd used hpaste.org, it would have given you several suggestions.
03:18:15 <jonkri> dav: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
03:19:58 <MercurialAlchemi> shachaf: what's wrong with Data.ByteString.Char8 ?
03:20:21 <shachaf> MercurialAlchemi: It's broken. It pretends that Char = Byte.
03:20:36 <shachaf> This means that it works fine for people who use English but breaks for everyone else.
03:21:07 <tomejaguar> Is there a date/time parsing library that actually uses parser combinators rather than unHaskelly format strings?  If not, why not?  Is it just that no one has decided to do it, or is it somehow problematic?
03:21:15 <dav> shachaf: http://hpaste.org/88807
03:21:36 <shachaf> dav: Why are you telling me? The suggestions are at the bottom of that page.
03:21:58 <dav> shachaf: oh sorry I read 'it'
03:22:05 <dav> shachaf: ... as 'I'
03:22:16 <MercurialAlchemi> shachaf: There are cases where it can be useful
03:22:54 <dav> shachaf: seems like just redundant brackets
03:22:56 <shachaf> MercurialAlchemi: Yes, cases where you don't mind having broken code that doesn't handle Unicode.
03:23:08 <MercurialAlchemi> shachaf: sometimes you have plain ASCII data, in which case you don't need to reach for the Unicode beast
03:23:17 <shachaf> dav: Redundant brackets and concatMap. Oh well. Sometimes it has more.
03:23:19 <shachaf> MercurialAlchemi: :-(
03:23:32 <shachaf> MercurialAlchemi: Unicode is not a "beast". It's the standard, and it should be the default.
03:23:46 <FreeFull> I guess you want Data.ByteString.UTF8
03:23:48 <shachaf> Data.ByteString.Char8 is a bad library because it makes it easier to write bad broken code than good code.
03:24:03 <shachaf> FreeFull: Or Data.Text, for text.
03:24:25 <MercurialAlchemi> shachaf: It's *a* standard
03:24:34 <shachaf> Data.ByteString is kind of badly named. It's not suitable anywhere you would use a String. It's suitable where you would use [Word8].
03:24:48 <shachaf> MercurialAlchemi: It's *the* standard.
03:24:57 <ion> what shachaf said
03:25:17 <shachaf> It's not great -- it has a lot of problems --but it's much better than any of the alternatives, like people fighting over which standard to use.
03:25:19 <MercurialAlchemi> shachaf: but I agree Unicode should be the default, with the option of switching to char=byte if you know what you're doing
03:25:50 <FreeFull> Maybe it should be called Data.ByteList
03:25:57 <shachaf> "i have ascii text" is no excuse, because ascii=utf8 at bytes/codepoints below 128.
03:26:06 <shachaf> So you should be using UTF8.
03:26:09 <ion> ByteArray
03:26:46 <FreeFull> Ah, yeah, ByteArray would be better
03:27:05 <shachaf> I,I ByteString.Lazy -> ByteArrayList
03:27:09 <dav> shachaf: so I get a type error if I use Data.ByteString instead of Data.ByteString.Char8
03:27:22 <dav> shachaf: I think because of Text.ShellEscape?
03:27:33 <shachaf> dav: Right, because you're using "pack", which is a function that has the type [Word8] -> ByteString.
03:27:48 <shachaf> You have a String, so you probably want to encode it (with UTF-8) or something.
03:27:54 <FreeFull> If you want String -> ByteString, use encode from Data.ByteString.UTF8
03:28:02 <shachaf> Do you know how Unicode/UTF-8/encoding/bytes/characters/etc. works?
03:28:06 <dav> ok let me try that
03:28:19 <shachaf> Data.ByteString.UTF8 is one option. You can also go via Text.
03:28:32 <dav> all I (think I) know is it uses 2 bytes for every char?
03:28:43 <shachaf> Nope.
03:28:43 <FreeFull> You could use Text. That wouldn't give you a ByteString of course
03:28:55 <shachaf> Data.Text.Encoding would.
03:29:15 <shachaf> dav: You should take a detour either now or sometime soon to acquaint yourself with this topic. It's important.
03:30:15 <dav> shachaf / FreeFull - Text.ShellEscape expects something like Data.ByteString.Internal.ByteString
03:30:45 <shachaf> dav: Data.ByteString.Internal.ByteString is the same type as Data.ByteString.ByteString.
03:30:49 <shachaf> I.e. ByteString.
03:31:03 <shachaf> (There's also a second type, Data.ByteString.Lazy.ByteString, but you don't need to worry about it here.)
03:31:15 <shachaf> You have a String, and you want to convert it to a bunch of bytes, it seems.
03:32:10 <Entroacceptor> http://kunststube.net/encoding/ is a nice read
03:32:15 <shachaf> This process is called "encoding".
03:33:08 <shachaf> It's probably broken for Text.ShellEscape to operate on a ByteString, anyway.
03:35:21 <ion> Well, to be fair, (non-interactive) shells and Unix mostly operate in terms of bytes, ignoring the encoding (as long as it doesn’t have \0s everywhere or a BOM in the start).
03:35:49 <dav> shachaf: I don't see any function that will produce a ByteString from a String in http://hackage.haskell.org/packages/archive/bytestring/0.9.2.1/doc/html/Data-ByteString.html or in Hoogle?
03:36:00 <merijn> Text.Encoding
03:36:22 <merijn> @hoogle decodeUtf8
03:36:23 <lambdabot> Data.Text.Encoding decodeUtf8 :: ByteString -> Text
03:36:23 <lambdabot> Data.Text.Lazy.Encoding decodeUtf8 :: ByteString -> Text
03:36:23 <lambdabot> Data.Text.Encoding decodeUtf8' :: ByteString -> Either UnicodeException Text
03:36:34 <shachaf> Data.Text.Encoding will work, though it's a little bit roundabout.
03:36:46 <shachaf> Data.ByteString.UTF8 also has a function for this, as FreeFull mentioned.
03:36:48 <dav> I see..
03:38:00 <FreeFull> @hoogle encode
03:38:01 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
03:38:01 <lambdabot> package Encode
03:38:01 <lambdabot> GHC.IO.Encoding.Types encode :: BufferCodec from to state -> Buffer from -> Buffer to -> IO (Buffer from, Buffer to)
03:38:14 <FreeFull> :t Data.ByteString.UTF8.encode
03:38:16 <lambdabot> Not in scope: `Data.ByteString.UTF8.encode'
03:38:35 <FreeFull> @hoogle Data.ByteString.UTF8.encode
03:38:35 <lambdabot> package Encode
03:38:35 <lambdabot> package bencode
03:38:35 <lambdabot> package haskell-qrencode
03:38:46 <FreeFull> Well, lambdabot is useless here
03:40:02 <shachaf> dav: I'm sorry that this is more trouble. :-( I wish the Haskell standard library was the opposite, made the right thing easy to do.
03:40:47 <blackdog> shachaf: occurs to me -  can you have UTF8 text in a URL?
03:41:01 <blackdog> i have been blithely using .Char8, and am now stricken with guilt
03:41:05 <merijn> blackdog: You can have unicode URLs, but not UTF8, I think
03:41:23 <blackdog> merijn: huh. what's the distinction?
03:41:27 <merijn> blackdog: https://en.wikipedia.org/wiki/Internationalized_domain_name
03:41:44 <merijn> blackdog: That IDNs use an entirely different encoding?
03:42:05 <dav> shachaf: so is this what you'd suggest? escape = T.unpack . TE.decodeUtf8 . ESC.bytes . ESC.sh . TE.encodeUtf8 . T.pack
03:42:23 <dav> shachaf: (where T = Data.Text and TE = Data.Text.Encoding)
03:45:01 <Aetherspawn> I've been thinking -- monads that don't use IO are pure, aren't they?
03:45:16 <FreeFull> dav: If you have B8 = Data.ByteString.UTF8   you could do      escape = B8.decode . ESC.bytes . ESC.sh . B8.encode
03:45:17 <dav> even monads that use IO are pure :)
03:45:53 <Aetherspawn> Since the fundamental of monads is nested data structures using Haskells type system are they not?
03:45:58 <shachaf> dav: That would work.
03:46:20 <dav> shachaf: I guess you're right I need to read up on UTF8
03:46:34 <shachaf> dav: Yep.
03:46:35 <dav> FreeFull: thanks
03:46:40 <shachaf> I think there might be links in the FAQ
03:46:41 <blackdog> merijn: ok. so it's actually ASCII, but there's a translation between that and umlaut-enriched text?
03:46:41 <shachaf> @where faq
03:46:42 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
03:46:46 <shachaf> Aetherspawn: "pure" is a close-to-meaningless word
03:46:46 <blackdog> god i hate encoding.
03:47:14 <blackdog> (context: just wrote a robots.txt parser on the assumption that it's always going to be ascii)
03:47:28 <dav> alright I did not expect the comments to revolve around char encoding :)
03:47:28 <shachaf> Oops, never mind.
03:47:36 <shachaf> dav: You have to learn sometime!
03:47:40 <shachaf> Besides, I didn't read the rest of the code.
03:47:42 <merijn> blackdog: blackdog It use punycode as encoding which encodes to ASCII
03:48:21 <shachaf> blackdog: No, you can't have UTF8 in a URL, but you can have Unicode in a URL. I guess merijn already answered.
03:48:32 <Aetherspawn> ;__; nobody has had a crack at my SO question. Looks like I might have to make a huge hack using stm-conduit or something.
03:48:38 <shachaf> blackdog: Note that this doesn't excuse you from using Char8. A valid representation of the URL might be Unicode.
03:49:11 <dav> shachaf: but am I know killing UTF8 support by using "Strings" anyway?
03:49:20 <dav> s/know/not/
03:49:29 <shachaf> dav: "String" is a Unicode string.
03:49:33 <shachaf> I.e. a list of Unicode codepoints.
03:49:38 <dav> shachaf: so Char is a unicode char?
03:49:45 <FreeFull> Yes
03:49:49 <shachaf> Char is a Unicode codepoint. Close enough.
03:49:59 <FreeFull> > val '\10000'
03:50:01 <lambdabot>   Not in scope: `val'
03:50:01 <lambdabot>  Perhaps you meant one of these:
03:50:01 <lambdabot>    `var' (imported fro...
03:50:04 <FreeFull> > var '\10000'
03:50:05 <lambdabot>   Couldn't match expected type `GHC.Base.String'
03:50:05 <lambdabot>              with actual typ...
03:50:10 <FreeFull> > var "\10000"
03:50:12 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (invalid character)
03:50:12 <blackdog> shachaf: yeah, sloppiness in this area is sort of contagious. a good chunk of the alexa top 500 don't have valid robots.txt anyway.
03:50:36 <merijn> > minBound :: Char
03:50:36 <shachaf> You should learn the distinction between characters and codepoints too, but maybe that's less immediately relevant.
03:50:38 <lambdabot>   '\NUL'
03:50:46 <merijn> > maxBound :: Char
03:50:47 <lambdabot>   '\1114111'
03:51:00 <shachaf> > 65536*17-1
03:51:02 <lambdabot>   1114111
03:51:15 <blackdog> hrm. can you set your username & password somewhere so cabal upload doesn't ask every time?
03:51:30 <merijn> blackdog: Password manager in your browser? :p
03:51:32 <shachaf> Yes, in your .cabal/config
03:51:47 <blackdog> merijn: command line app
03:51:53 <blackdog> shachaf: ah, glorious.
03:52:07 <shachaf> @google cabal upload username password
03:52:08 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalUpload
03:52:08 <lambdabot> Title: CabalUpload – Hackage
03:52:50 <blackdog> shachaf: cheers, all set up now.
03:54:12 * hackagebot robots-txt 0.1.0.3 - Parser for robots.txt  http://hackage.haskell.org/package/robots-txt-0.1.0.3 (MarkWotton)
03:54:13 <dav> FreeFull: are you sure about your use of B8?
03:54:23 <t7> is there an extension for haskell that tries to solve ambiguous names (could be from 2 modules) ?
03:54:34 <dav> FreeFull: decode :: ByteString -> Maybe (Char, Int)
03:54:37 <dav> FreeFull: and there's no encode
03:55:12 <shachaf> dav: There's toString and fromString.
03:55:14 <dav> FreeFull: I think it's toString and fromString
03:55:15 <dav> yes
03:55:17 <FreeFull> Oh
03:55:20 <FreeFull> Wrong function names
03:55:23 <FreeFull> Yeah, you're right
03:55:30 <shachaf> Note that toString fails silently when it sees an invalid byte sequence.
03:55:33 <FreeFull> I got a bit confused =P
03:56:54 <FreeFull> :t fromString
03:56:55 <lambdabot>     Not in scope: `fromString'
03:56:56 <lambdabot>     Perhaps you meant `showString' (imported from Prelude)
03:56:57 <eikke> is there a way to actually calculate operations on type-level literals?
03:57:11 <eikke> now I get: Couldn't match type `3 + 5' with `8'
03:57:37 <dav> shachaf / FreeFull - alright so fairly simple diff in the end: http://paste.debian.net/7296/
03:57:58 <dav> shachaf: I guess I need to read about UTF8 before understanding how these failures could happen
03:58:43 <dav> actually BS8 is a horrible alias for something that's UTF8
03:59:03 <dav> which makes me think that UTF8 is a horrible name for something that's not 8bits
04:00:15 <shachaf> UTF8 encodes a string of codepoints to a string of 8-bit bytes.
04:00:23 <Entroacceptor> the official name is UTF-8, and the name is okay-ish. They should just have called it unicode
04:00:33 <shachaf> A codepoint can turn into 1-4 bytes, depending on what it is.
04:00:38 <Entroacceptor> and don't even think about the other stuffs :)
04:01:09 <shachaf> Entroacceptor: UCS-2.625 forever!
04:01:39 <shachaf> dav: UTF-8 is simple. I can explain how it works if you like, or you can look it up somewhere. It's a clever scheme.
04:02:10 <dav> shachaf: I can read. If I'm going to make you type it might as well be about something that I can't trivially lookup :)
04:02:19 <dav> shachaf: but thanks!
04:02:57 <shachaf> https://en.wikipedia.org/wiki/UTF-8
04:03:52 <shachaf> Note that some Unicode codepoints are bigger than 65535, so you can't use 2 bytes even if you wanted to.
04:04:03 <shachaf> Even UTF-16 sometimes uses a pair of 2-byte "code units" to represent one codepoint.
04:07:18 <ocharles> dcoutts_: is your bzip library able to handle streams of ByteStrings? I see a comment about checksumming, so I'm thinking perhaps not
04:08:52 <dav> is there a better way of doing this? ghc -Wall -o rename-smart rename-smart.hs && strip rename-smart && rm -v *.hi *.o
04:09:52 <Jaak_> cabal?
04:09:54 <FreeFull> dav: A makefile or a script?
04:12:00 <dav> FreeFull: alright thx ;-)
04:13:03 <ion> dav: No, use cabal. I think --enable-executable-stripping is the default.
04:17:04 <FreeFull> https://twitter.com/mwotton/statuses/339697660984438784
04:17:37 <FreeFull> Was just browsing haskellnews.org
04:18:13 <example> @map
04:18:13 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
04:19:03 <ion> freefull: :-D
04:19:29 <example> someone could explain how i use the type Maybe ?
04:19:32 <example> @Maybe
04:19:32 <lambdabot> Unknown command, try @list
04:19:37 <Entroacceptor> harassed?
04:19:42 <example> @src maybe
04:19:42 <lambdabot> maybe n _ Nothing  = n
04:19:42 <lambdabot> maybe _ f (Just x) = f x
04:20:00 <Aetherspawn> Is it safe to do "strip -p --strip-unneeded --remove-section=.comment -o" on Haskell executables? I observe a half in size and they /seem/ functional afterwards
04:20:38 <example> @src map
04:20:38 <lambdabot> map _ []     = []
04:20:38 <lambdabot> map f (x:xs) = f x : map f xs
04:21:00 <Cale> Aetherspawn: I don't know what the other arguments mean, but it's usually okay to strip the binaries...
04:21:36 <ion> example: LYAH describes Maybe.
04:21:40 <ion> @where lyah
04:21:40 <lambdabot> http://www.learnyouahaskell.com/
04:21:55 <Cale> example: You use the type Maybe often when you have a function which might not provide an answer to something.
04:22:45 <FreeFull> @hoogle Maybe
04:22:46 <lambdabot> Prelude data Maybe a
04:22:46 <lambdabot> Data.Maybe data Maybe a
04:22:46 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
04:23:01 <Cale> example: For example, from the Data.Map library, there is a function  lookup :: (Ord k) => k -> Map k a -> Maybe a
04:23:16 <FreeFull> Oh, Data.List has a lookup too
04:23:18 <FreeFull> :t lookup
04:23:19 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
04:23:24 <satc> For HDBC is it possible to create a Table from SqlColDesc ??
04:23:28 <Aetherspawn> Cale, thanks
04:23:32 <Cale> This says "If you give me a key of type k, and a Map from keys of type k, to values of type a, then I might produce a value of type a"
04:23:44 <satc> I mean from [(String,SqlColDesc)]
04:24:05 <Cale> Well, really it'll either produce the value Nothing, or it'll produce something of the form Just v where v is of type a.
04:24:08 <example> i will read LYAH
04:25:05 <Cale> The reason it only produces a Maybe a, is that the key might not be in the Map, so it needs some way to say that it didn't find it.
04:25:40 <FreeFull> > lookup 3 [(1,'a'),(4,'b')]
04:25:41 <lambdabot>   Nothing
04:25:45 <FreeFull> > lookup 1 [(1,'a'),(4,'b')]
04:25:47 <lambdabot>   Just 'a'
04:27:15 <Cale> example: Another example is if you were writing a function to solve the quadratic equation  a*x^2 + b*x + c == 0  -- from the quadratic formula, you know that whenever b^2 - 4*a*c is negative, this has no real valued solutions, so you might use Maybe to handle that case, if you didn't want to give complex number results.
04:27:23 <Aetherspawn> I can't figure out how to do post-build actions through my .cabal file, anyone know how?
04:28:33 <shachaf> Cale: Sounds like you should use [], not Maybe.
04:28:50 <Cale> shachaf: Perhaps, but Maybe (Double, Double) would also work.
04:29:17 <shachaf> Not if you add another ±, though!
04:29:37 <Cale> example: Or in a database, every employee might or might not have a secretary, who is another employee, so we might have some function  secretary :: Employee -> Maybe Employee
04:30:06 <Cale> shachaf: True :)
04:30:19 <example> nice
04:30:30 <example> @src fromListWith
04:30:30 <lambdabot> Source not found. It can only be attributed to human error.
04:30:46 <Cale> The @src function doesn't have everything
04:31:29 <Cale> http://hackage.haskell.org/packages/archive/containers/0.5.1.0/doc/html/src/Data-Map-Base.html#fromListWith
04:31:44 <Cale> If you browse the documentation, you'll find source links along the right side though
04:32:48 <Cale> They're sort of in medium grey on a grey background, presumably because the designer of the stylesheet thought that source code was not very important. ;)
04:34:36 <Cale> (http://hackage.haskell.org/packages/archive/containers/0.5.1.0/doc/html/Data-Map-Lazy.html for the doc)
04:40:53 <example> @src fromList
04:40:53 <lambdabot> Source not found. Do you think like you type?
04:41:20 <example> :t fromList
04:41:22 <lambdabot>     Not in scope: `fromList'
04:41:22 <lambdabot>     Perhaps you meant one of these:
04:41:22 <lambdabot>       `IM.fromList' (imported from Data.IntMap),
04:41:51 <example> @src IM.fromList
04:41:51 <lambdabot> Source not found. Are you on drugs?
04:42:07 <Kneiva> :i Data.Map.fromList
04:42:08 <example> :t IM.fromList
04:42:09 <lambdabot> [(IM.Key, a)] -> IM.IntMap a
04:42:34 <example> :i Nothing
04:42:41 <Kneiva> M.fromList :: Ord k => [(k, a)] -> M.Map k a -- Defined in `Data.Map'
04:48:58 <kartlos> do you guys use an IDE for Haskell programming? Like Leksah? or just a text-editor and the command line?
04:49:13 <merijn> kartlos: I just use vim+ghci (and tmux)
04:49:26 <kartlos> merijn: that's my setup as well :)
04:49:28 <typoclass> kartlos: i use gvim, but there's also a large number of emacs users
04:49:30 <merijn> kartlos: Most people here seem to use vim/emacs
04:49:41 <kartlos> are there any yi users here?
04:50:39 <kartlos> it looks kinda promising being extensible in haskell and supporting vim and emacs keymaps...
04:51:01 <shachaf> Use whatever editor you like. It won't make a difference. Just please don't start an editor war.
04:51:04 <merijn> I have better hopes for lamdu :p
04:51:27 <kartlos> I tried using the FP plugin for eclipse which was a total disaster
04:51:30 <tomejaguar> kartlos: I use emacs and ghci
04:52:13 <kartlos> shanse: sorry, not trying to start an editor war here :-)
04:52:34 <Twey> Does Leksah work now?  Last I heard it was broken and nobody was working on it
04:52:36 <typoclass> kartlos: hm interesting. i've heard here and there that eclipsefp is fairly good. haven't tried it myself though
04:53:14 <kartlos> typoclass: it freezed my eclipse 4.2 on os x several times :(
04:53:47 <kartlos> could be that a combination of plugins that I have installed just don't play well together
04:54:48 <kartlos> oh and another question: tabs or spaces? and how many? :-)
04:56:18 <Entroacceptor> I'm using emacs with ghc-mod, works fine
04:57:17 <jonkri> according to <http://en.wikipedia.org/wiki/Haskell_Platform>, the 2011.2 version of the haskell platform included ghc 7.0. does that refer to ghc 7.0.1? there are no X.Y(.0) versions listed on <http://www.haskell.org/ghc/>
04:57:27 <Twey> kartlos: Haskell uses alignment-based indentation, so ‘how many’ is often not relevant — it's however many you need to line up with what's on the previous line, and that has to be spaces.  If you're willing to do some editor setup you can use tabs for those cases where it's indentation, not alignment, that matters, but opinions are divided as to whether that's a good idea.
04:59:05 <kartlos> Twey: thanks, I've configured vim to use 4 spaces for a tab
04:59:21 <ocharles> Can use*
04:59:26 <ocharles> it can also use braces
04:59:32 <typoclass> kartlos: oh i see
04:59:33 <Twey> Aye
04:59:44 <Twey> But pretty much everyone's sure that's a bad idea :þ
04:59:46 <ocharles> 99% of us use whitespace though
05:00:22 <Twey> Braces are nice for posting code snippets across IRC.  That's what I always miss about them in e.g. Python.
05:03:19 <bitonic> Twey: Haskell has braces
05:03:26 <ocharles> bitonic: I just said that
05:03:30 <Twey> bitonic: Yes
05:03:35 <bitonic> oh OK :P
05:03:38 <no-n> Lisa needs braces
05:03:38 <bitonic> I just read the last line
05:03:53 <startling> Twey: people in #python at least tend to notate it with semicolons
05:03:53 <no-n> dental plan
05:03:55 <Twey> bitonic: The last line was talking about Haskell's braces :þ
05:04:08 <startling> if a: b; c; d;;
05:04:10 <t7> can i use cabal over proxy?
05:04:24 <Twey> startling: Yeah, but it's not always clear, and even when it is you often can't paste it into an interpreter
05:04:37 <startling> Twey, my, you're being thorny today
05:04:59 * Twey groans.
05:05:08 <startling> >:(
05:05:12 <dcoutts_> t7: yes, just set the http proxy env var
05:05:12 <startling> I mean
05:05:16 <startling> >:)
05:07:25 <t7> dcoutts_: tankyou kindly
05:10:46 <t7> > fst <$> [(1, 2)]
05:10:47 <lambdabot>   [1]
05:11:27 * t7 wonders why Functor is Data.Functor
05:11:52 <Twey> t7: Because the Data/Control distinction is largely arbitrary
05:16:18 <Aetherspawn> Just a noob question, but; wouldn't it make more sense for all monads to be transformers?
05:16:54 <Aetherspawn> Why do we explicitly have ReaderT, Reader etc when [I think] they serve (almost) exactly the same pourpose minus the more specific type
05:16:56 <typoclass> Aetherspawn: oh heh, interesting idea
05:17:16 <mauke> Aetherspawn: you can't use ReaderT directly
05:17:17 <quchen> Aetherspawn: That's how the monads are commonly defined
05:17:26 <t7> Aetherspawn: Reader is just ReaderT IdMonad or something
05:17:31 <merijn> Aetherspawn: Reader = ReaderT Identity
05:17:39 <Aetherspawn> Oh, okay
05:17:41 <Aetherspawn> So it's ease of use
05:17:43 <quchen> Aetherspawn: Look at the source, Reader r a = ReaderT r Identity a
05:17:57 <t7> @src Reader
05:17:57 <lambdabot> Source not found. :(
05:18:00 <Aetherspawn> Hah, it makes so much more sense now :P
05:18:03 <Aetherspawn> Thanks.
05:18:06 <mauke> Aetherspawn: no, it's ability to use
05:18:15 <quchen> Note that this doesn't always work, for example ListT is not well-behaved in the straightforward implementation.
05:18:35 <quchen> So some monads are not easily turned into transformers.
05:20:20 <Aetherspawn> :t Identity
05:20:21 <lambdabot> a -> Identity a
05:20:26 <quchen> (ListT is only a transformer if the base monad is commutative. Reader is commutative, State is not.)
05:20:35 <Aetherspawn> :t Identity Int
05:20:36 <lambdabot>     Not in scope: data constructor `Int'
05:20:37 <lambdabot>     Perhaps you meant one of these: `In' (line 124), `InR' (line 131)
05:20:42 <quchen> newtype Identity a = Identity { runIdentity :: a }
05:21:08 <quchen> instance Monad Identity where return = Identity; (Identity a) >>= f = f a
05:28:27 <jonkri> anyone else get a "the connection is untrusted error" against https://github.com ?
05:29:11 <Spockz> A while back I came across a great explanation of the difference(s) between shallow and deep embedding. Does anyone know which one I'm talking about?
05:29:40 <mauke> jonkri: what does your certificate look like?
05:30:20 <jonkri> mauke: i don't know. it worked a few minutes ago
05:30:20 <quchen> Spockz: Embedding? Shallow and deep are usually used in terms of strictness of evaluation in Haskell
05:30:39 <mauke> quchen: wat
05:30:49 <Spockz> quchen: it was this one: http://www.cse.chalmers.se/~josefs/DSLTutorial/tutorialSlides.html
05:31:19 <quchen> mauke: Well, shallow evaluation (seq, WHNF) vs deep evaluation (deepseq, NF)
05:31:34 <mauke> I've never heard WHNF being called shallow evaluation
05:31:38 <quchen> ... but as it turns out I just don't know what Embedding is.
05:31:40 <Spockz> quchen: in the context of DSLs
05:31:57 <quchen> Well then I missed your question by a mile and apologize. :-)
05:32:24 <Spockz> data Expr a = Plus (Expr a) (Expr a) | Const a  << simple example
05:32:48 <quchen> mauke: Deepseq talks about shallow multiple times: http://hackage.haskell.org/packages/archive/deepseq/latest/doc/html/Control-DeepSeq.html
05:33:04 <quchen> Well, twice.
05:33:37 <mauke> and the first occurrence is used to define the term
05:34:39 <quchen> mauke: I've heard it in other places as well.
05:35:47 <quchen> On a related note, now I finally know how to call the "how do I layot my data in a DSL" problem :-)
05:36:06 <Spockz> quchen: how then?
05:37:06 <quchen> Spockz: Well, shallow and deep embedding, as mentioned by your link
05:37:36 <Spockz> quchen: did you write it down already?
05:39:12 <quchen> I don't understand. What I meant to say was "hey the link you posted taught me something".
05:39:43 <Spockz> quchen: ash I though you had a problem written down somewhere and now had a different name for it :)
05:40:32 <quchen> Spockz: No, I was aware of the problem, but didn't know how to call it, so until now I was making up names on the fly.
05:40:48 <quchen> Unsurprisingly, those names sounded like a 3 year old tries to explain a bicycle.
05:41:24 <Spockz> quchen: great, you have learned something today then! :)
05:59:00 <eikke> when I have 'newtype I (n :: Nat) = I Int' and a value 'i = I 10 :: I 5', how can I retrieve the '5'? Been toying with 'sing' and 'fromSing' for some time, but can't get it sorted out
06:00:15 <magicman> @hoogle (a -> Either c (b,a)) -> a -> ([b],c)
06:00:16 <lambdabot> No results found
06:01:26 <merijn> eikke: What do you mean by "retrieve 5"?
06:01:44 <eikke> given a value of type "I n", retrieve 'n' as a value-level integer
06:01:53 <merijn> I'm not sure that's possible atm
06:02:06 <eikke> that's what 'sing' and 'fromSing' should allow to do
06:02:17 <merijn> Unless there's a conversion method built in I'm not aware of?
06:02:25 <eikke> :t fromSing (sing :: Sing 1)
06:02:27 <lambdabot> parse error on input `1'
06:02:38 <eikke> (-> 1 :: Integer)
06:02:40 <typoclass> the ghc wiki says "fromSing :: Sing (a :: Nat) -> Integer", which looks as if it'd allow you to get an Integer. but i have little to no clue
06:02:48 <merijn> oh, neat
06:03:10 <eikke> the problem is I don't know this '1', it's an 'm' for which I know it's a 'Nat'
06:04:11 <shachaf> λ> newtype I (n :: Nat) = I Int
06:04:11 <shachaf> λ> let foo :: forall n. SingI n => I n -> Integer; foo _ = fromSing (sing :: Sing n)
06:04:12 <eikke> huh, what I tried before seems to work in ghci now, wth
06:04:14 <shachaf> λ> foo (I 100 :: I 5)
06:04:38 * shachaf has never used Sing before, but that looks working.
06:04:40 <shachaf> Ah, OK.
06:04:51 <merijn> Magic :)
06:04:56 <shachaf> My work here is done.
06:05:01 <eikke> hmh, could it be the SingI constraint must be provided explicitly?
06:05:41 <Twey> shanse: Defining types at a prompt?  What magic is this?
06:05:52 <typoclass> Twey: he's gone
06:05:56 <eikke> Twey: that worked for a while already
06:05:56 <Twey> Ack.
06:05:59 <Twey> Sorry, shanse
06:06:01 <elliott> I think that's worked forever
06:06:03 <elliott> as long as you use the let syntax
06:06:10 <elliott> it's worked in do blocks forever, after all
06:06:10 <eikke> > newtype I = I Int deriving Show; print I 10
06:06:12 <lambdabot>   <hint>:1:1: parse error on input `newtype'
06:06:17 <Twey> I meant the newtype, elliott
06:06:21 <elliott> oh, ah
06:06:23 <eikke> hmh, maybe not on lambdabot :P
06:06:25 <elliott> that's a 7.6 feature I think
06:06:27 <elliott> or maybe 7.4
06:06:36 <Twey> Wow
06:06:43 <Twey> I should really read those changelogs.
06:06:59 <typoclass> magicman: i'm not sure what you were looking for. do you have a usage example?
06:07:29 <elliott> looks like a generalised unfold
06:07:32 <elliott> :t unfoldr
06:07:33 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
06:07:59 <typoclass> elliott: oh good point, it'd keep calling that function
06:08:58 <eikke> right, all I needed was the explicit forall
06:09:01 <eikke> bleh
06:09:15 <fizbin> Huh. Apparently someone came up with a good way to do a heterogenous map in Haskell about a week ago: http://hpaste.org/88390
06:09:51 <fizbin> Still doesn't _quite_ do what was wanted last night, but it's close.
06:09:52 <magicman> typoclass, elliott: Yeah, unfoldr, but with some sort of accumulation.
06:10:22 <magicman> I'd be happy with (a -> Either b (b,a)) -> a -> [b], too.
06:10:34 <magicman> (of course, defining it myself is easy enough)
06:10:45 <merijn> I forgot, does HP have an uninstaller on OSX?
06:10:46 <typoclass> eikke: yes, i suppose otherwise it wouldn't know that the n in "fromSing (sing :: Sing n)" is meant to be the same n as in the signature
06:11:15 <eikke> I'm always mistaken in that
06:11:26 <magicman> But when I unfoldr, I occasionally want to express "And this is the last value I generate". Which gets kind of ugly with regular unfoldr.
06:11:29 <eikke> *bugged by it (same for functions in a 'where' clause)
06:12:40 <eikke> bummer, now the 'SingI n' constraint goes all the way up, whilst it shouldn't be required at all since 'n' is always of 'Nat' kind
06:12:48 <fizbin> @src unfoldr
06:12:48 <lambdabot> unfoldr f b  = case f b of
06:12:48 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
06:12:48 <lambdabot>    Nothing        -> []
06:14:08 <elliott> eikke: that's a limitation of the way it's done right now I think
06:14:25 <magicman> So I guess I really want an apomorphism. Yeah, I'll just write the thing myself v_v
06:15:34 <fizbin> magicman: The annoying bit is avoiding being accidentally strict in the snd of the output just to get some of the fst of the output.
06:15:36 <typoclass> fizbin: what magicman was referring to is that you use Nothing to indicate "i'm done producing", but with unfoldr there's no direct way to express "this is the last element, and *then* i'm done producing"
06:15:57 <eikke> elliott: that becomes problematic when ghc all of a sudden also wants me to prove 'n + n' is also a SingI instance :-P
06:17:20 <magicman> *nod*, turns out I don't really need the tupled-version, but that accidental strictness can be solved with either ~patterns, or let-binding the recursive call.
06:17:57 <fizbin> :t set _1
06:17:58 <lambdabot> Field1 s t a b => b -> s -> t
06:18:34 <typoclass> fizbin: (btw sorry, i hope i wasn't stating the obvious now) :-)
06:26:16 <p2147483647> is there a name for the structure consisting of two sets, X and Y, an injective function f : X -> Y, and a partial function g : Y' -> X ?
06:26:40 <p2147483647> also: is that a Prism?
06:27:01 <Spockz> Would someone care to take a look at the following question? http://stackoverflow.com/questions/16815037/determining-implementation-of-method-based-on-available-constraints
06:27:39 <elliott> p2147483647: well, you need laws.
06:27:42 <elliott> a prism is that + laws.
06:27:47 <elliott> (+ type changing, but that doesn't matter)
06:28:28 <p2147483647> oh yeah I forgot about the laws :D
06:28:39 <p2147483647> is there a corresponding ... mathematical thingy to a prism?
06:29:11 <fizbin> @type let unfld' f a = either ((,) []) (\x -> _1 %~ (fst x :) $ unfld' f (snd x)) (f a) in unfld'
06:29:12 <lambdabot> (b -> Either a (a1, b)) -> b -> ([a1], a)
06:29:13 <elliott> probably just what you said
06:29:44 <fizbin> @pl let unfld' f a = either ((,) []) (\x -> _1 %~ (fst x :) $ unfld' f (snd x)) (f a) in unfld'
06:29:44 <lambdabot> (line 1, column 41):
06:29:44 <lambdabot> unexpected "_"
06:29:44 <lambdabot> expecting lambda abstraction or expression
06:29:45 <eikke> looks like there's no sensible way to define 'instance (SingI n, SingI m, o ~ (n + m)) => SingI o' :-(
06:29:48 <typoclass> Spockz: hm ... i notice you've listed Eq first in the case-of. so if something has an Eq and an Ord instance, you want to prefer Eq and invoke memoEq?
06:30:08 <Spockz> typoclass: no, I should clarify that maybe
06:30:12 <p2147483647> elliott: heh, fair enough. I'm seeing prisms everywhere now =)
06:30:26 <typoclass> Spockz: fair enough :)
06:30:32 <Spockz> typoclass: the point is that I cannot even write that, so writing the three cases down is pointless
06:30:48 <typoclass> Spockz: sure, it's pseudo-code to illustrate your intention
06:32:07 <Spockz> typoclass: refresh :)
06:32:09 <typoclass> Spockz: but i think it's an important side question to think about. "what happens if the hypothetical memo function is called with an argument for which we have two or even all three instances"
06:32:34 <Spockz> typoclass: than I want to pick the 'best'
06:32:50 <Spockz> typoclass: or rather what is defined as the best in that piece of code
06:33:31 <typoclass> Spockz: ok, fine. so you have a defined order. "if there's a choice, prefer memoFoo over the others"
06:33:46 <Spockz> typoclass: exactly.
06:34:09 <ocharles> how do I provide better errors with Get and cereal? is that what 'label' is for?
06:35:31 <Spockz> typoclass: I even have a different scenario but the same problem. A general function isSame :: a -> a -> Bool, if there is an instance for Eq a than isSame should be (==) otherwise (\ _ _ -> False).
06:35:37 <Spockz> Maybe I should've used that example :)
06:35:53 <ocharles> ok, it seems it is
06:35:59 <elliott> Spockz: you can't do that
06:36:05 <elliott> it would violate the open world assumption™
06:36:35 * Spockz googles
06:36:55 <elliott> Spockz: basically, just adding a new instance shouldn't change the meaning of a program
06:37:01 <elliott> (or cause it to fail to compile)
06:37:11 <Spockz> elliott: right that makes sense
06:37:22 <elliott> in this case, adding an Eq instance would change isSame
06:37:48 <Spockz> elliott: although the adding of an instance might change a non-compiling program into a compiling program. :)
06:37:49 <elliott> (another thing that isSame would break is parametricity, but that's harder to explain (although actually more important))
06:37:59 <eikke> elliott: unless you use UndecidableInstances and IncoherentInstances etc? (just asking, never actually used those except when I got in trouble because of them :P )
06:38:02 <elliott> Spockz: right :)
06:38:18 <elliott> eikke: yeah, it is possible to violate the open world assumption with GHC, it is just a bad idea
06:38:37 <eikke> just ran into that while trying to get the 'n + n' instance to work -> Context reduction stack overflow; size = 201
06:38:39 <typoclass> Spockz: yeah, you would be in the position that your program does "print (isSame x y)", displaying True, then you only add "import Foo.Bar" with an appropriate instance in it, and that import line alone causes the code to display False
06:38:40 <Spockz> elliott: that is why I wonder whether it is possible with template haskell
06:39:06 <elliott> if you had to say $(isSame [|x|] [|y|]) or whatever you could probably do it, yeah
06:39:08 <Spockz> typoclass: yes I am aware of that
06:39:13 <typoclass> Spockz: so, what are you planning? maybe there's another way to sidestep all of that
06:39:15 * hackagebot graph-serialize 0.1.5.2 - Serialization of data structures with references.  http://hackage.haskell.org/package/graph-serialize-0.1.5.2 (ThomasSchilling)
06:40:09 <Spockz> typoclass: basically I want to use it as a macro (should I start running?). It should indicate: however you do please memo, I don't care how you do it!
06:40:30 <Spockz> but in the implementation I actually care and I want to pick a decent implementation
06:41:49 <elliott> since it's statically known whether it will actually do any memoisation when you do $(memo ...), why would you ever do it on a function without the relevant Eq instance?
06:42:12 <typoclass> Spockz: i see. so it's necessary that the user of the library will write only "memo", not "memoEq" or "memoOrd"?
06:42:44 <Spockz> typoclass: if you read necessary as 'strongly desired' :)
06:43:58 <typoclass> Spockz: could you maybe make a compromise here and say, e.g.: "memo = memoEq", i'll assume 80% memoizable things have an Eq instance, and in the 20% of cases where the dear user gets a compiler error, switching to memoOrd or memoHash is necessary
06:44:20 <typoclass> Spockz: not as pretty, not as fancy, but easy to implement and (i guess) much clearer for the user
06:44:28 <typoclass> Spockz: so, just a suggestion :)
06:46:46 <Spockz> typoclass: in this case the 'user' might also be a rewriting engine. I have a deep-embedding of arrow (with additional Typeable constraints on the two type arguments). The rewriter/optimizer could decide there should be a memo somewhere.
06:48:04 <typoclass> Spockz: oh i see. yes, then the 'rewriter' would have to know about the function's type signature with all its constraints
06:48:35 <Spockz> typoclass: but it cannot my problem shows.
06:48:51 <Spockz> typoclass: because the 'rewriter' is just another Haskell function
06:49:15 * hackagebot adp-multi 0.2.3 - ADP for multiple context-free languages  http://hackage.haskell.org/package/adp-multi-0.2.3 (MaikRiechert)
06:49:24 <typoclass> Spockz: oh ok. i assumed it was some sort of ghc plugin, or something parsing haskell source code (haskell-src-exts, etc.)
06:49:47 <Spockz> typoclass: no, I'm being difficult here :D
06:53:53 <t7> whats a good pattern for a function that may need more input or may return a result?
06:54:15 <flebron> printf does that
06:54:17 <t7> a -> Either (a -> b) b
06:54:19 <Spockz> typoclass: no further ideas?
06:54:42 <t7> a -> Either (a -> a) b     sorry
06:54:56 <t7> @hoogle a -> Either (a -> a) b
06:54:57 <lambdabot> No results found
06:55:08 <mux> ==> Upgrading 2 outdated packages, with result:
06:55:09 <mux> ghc 7.6.3, haskell-platform 2013.2.0.0
06:55:11 <mux> yay
06:55:49 <typoclass> Spockz: not really, sorry =) as elliott says, in plain haskell it's impossible
06:56:28 <Spockz> typoclass: ok. I wonder elliott has any idea whether it should be possible with Template Haskell?
06:57:27 <Twey> t7: I'd write it a → Either b (a → a)
06:57:29 <Spockz> I'm also not convinced that you have everything you need at compile time. (Inherent to the cast)
06:57:45 <elliott> as I said, it sounds possible if you accept writing $(memo 'foo) or something instead of memo foo, but the result will be determined statically, so I personally don't see the point
06:57:49 <Twey> t7: Makes more sense with Either's monad instance
06:57:52 <elliott> memoEq/memoOrd/memoHash seem fine to me
06:58:19 <t7> Twey: yeah, have you seen this kinda thing before?
06:58:44 <Twey> t7: It sounds like you might want conduit
06:59:27 <Spockz> elliott: indeed because it is determined statically it cannot used in my 'rewriter' anyway
06:59:27 <typoclass> t7: yes i think they codify that. conduit, pipes, or another of the iterateeish thingies
06:59:50 <t7> i will look
07:00:10 <Spockz> elliott: Do you feel like writing an answer to the stack overflow question? I can accept it and then it is closed
07:01:23 <elliott> Spockz: a bit busy right now, but I'll see if I can take a look later
07:02:09 <Spockz> elliott: no worries. :)
07:06:12 <merijn> What was the "cabal config that stops things from breaking" thing I see linked here occasionally?
07:07:36 <geekosaur> http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml ?
07:08:41 <geekosaur> or maybe http://www.vex.net/~trebla/haskell/sicp.xhtml
07:09:17 <byorgey> oh dear, I seem to have just written the line of code "getLabelTypes [] = Proxy' (Proxy :: Proxy '[])
07:09:36 <merijn> geekosaur: The first one, thanks!
07:11:57 * typoclass has little to no clue what these Proxies are, and neither what '[] is
07:12:03 * typoclass purrs in a happy and confused way
07:13:12 <byorgey> typoclass: '[] is the empty list lifted to the type level
07:13:15 <byorgey> using -XDataKinds
07:13:21 <quchen> typoclass: If you don't know any proxies (as opposed to only those merijn mentioned), have a look at pipes. It's a really nice library, and the only thing nicer than itself is its documentation. :-)
07:13:42 <typoclass> byorgey: oh i see. fancy new fanciness
07:13:45 <byorgey> yep
07:13:57 <elliott> er, I am pretty sure pipes's Proxy thing has nothing to do with the Proxy type
07:14:43 <byorgey> the Proxy I am talking about is just   data Proxy a where Proxy :: Proxy a
07:14:58 <byorgey> it's a sneaky way to pass types around as values
07:15:23 <byorgey> and with -XPolyKinds, we even have  Proxy :: forall k. k -> *
07:15:45 <byorgey> so you can pass not just types like 'Int' but also 'Maybe' or 'State' or whatever
07:16:52 <elliott> or 3.
07:17:00 <byorgey> actually you can even have 'Proxy Monad' =D
07:17:06 <typoclass> quchen: i think cale complained how type signatures of several functions in pipes are difficult to read and have tons of type variables
07:20:00 <Entroacceptor> byorgey: and you are sure that that's a good way to write your code?
07:20:17 <Entroacceptor> I'm suddenly scared of Haskell again (instead of just confused)
07:20:26 <byorgey> Entroacceptor: nope!
07:20:46 <byorgey> Entroacceptor: don't worry.  I really should be writing this in Agda.
07:21:12 <elliott> if you're not scared, you need to stare at it some more. that's my rule.
07:21:46 <byorgey> You can now pretty well encode most any dependent type in Haskell.  But it's not necessarily pretty.
07:21:47 <typoclass> byorgey: so erm ... when you said oh dear, you meant it looks funny? or it looks obviously nonsensical?
07:21:59 <byorgey> typoclass: it just looks funny
07:22:08 <byorgey> it type checks, so it can't be nonsensical ;-)
07:22:13 <typoclass> byorgey: ah ok =) then i understood correctly
07:22:37 <quchen> typoclass: Well, there are lots of things that look like `type Client p a' a = p a' a () C`. But those actually make sense, as long as you remember the general order of parameters to `p` and that `C` is an uninhabited type. In `(Proxy p) => p a' a b' b m r`, `a'` sends things upstream and `a` receives from upstream. `b'` receives from downstream, `b` sends to downstream. The Tutorial module explains it quite nicely with box drawings that
07:22:37 <quchen>  are a lot easier to look at.
07:23:13 <elliott> byorgey: too bad you can't lift GADTs and stuff to the kind level
07:23:32 <elliott> so we can't fully have types of equalities of (type-level) values and stuff
07:23:41 <typoclass> quchen: yes i've looked at the Tutorial to some extent, and found it all reasonable in the end
07:23:55 <elliott> I think that's the main blocker for expressing fully dependent stuff, maybe combined with the limitations of type families for lifting functions
07:23:56 <byorgey> elliott: oh, but with GHC HEAD, you can!
07:24:06 <byorgey> at least I'm pretty sure it's been merged
07:24:10 <byorgey> if not, it will be soon
07:24:11 <fizbin> t7: What you were asking about half an hour ago looks like stuff I've seen done with ContT
07:24:41 <quchen> typoclass: Of all the looong type sigs, I found those to be the easiest to make sense of so far.
07:24:58 <elliott> byorgey: nice, so you can have data a == b where Refl :: a == a, and then say (undefined :: (Refl :: '[] == '[]) == (Refl :: '(1,2) == '(1,2)))?
07:25:19 <elliott> oh, I guess no, that's a heterogeneous equality
07:25:23 <elliott> but you get the idea.
07:25:26 <elliott> s/'(1,2)/'[]/g
07:25:32 <byorgey> elliott: yes, I think so
07:25:46 <elliott> I wonder if you can do JMeq with GADTs + PolyKinds, actually
07:25:56 <byorgey> hmm, I'm not sure
07:26:11 <elliott> in my experience PolyKinds is almost unusable. I wonder if it's better in HEAD.
07:26:19 <byorgey> you'd have to ask Richard Eisenberg
07:26:59 <beaky> hello
07:27:14 <typoclass> beaky: hi
07:27:18 <beaky> why is automatic currying good? is it just facilitating partial function application?
07:27:27 <beaky> or pointfree
07:28:05 <byorgey> beaky: both, and also it is elegant and consistent to have only one-argument functions
07:28:09 <Taneb> beaky, it means you can have a much lighter-weight function application syntax
07:28:14 <beaky> ah
07:28:16 <byorgey> also what Taneb said.
07:28:22 <byorgey> so many reasons!
07:28:25 <tdammers> haskell doesn't automatically curry. It just so happens that writing functions fully-curried is really the easiest (and technically the only) way of writing them in haskell
07:28:38 <beaky> I wish scala had that kind of thing
07:28:42 <beaky> spaces for function application :D
07:28:57 <Taneb> It's possible to curry in Python, but it needs something like "foo(bar)(baz)(quux)", which is kinda cumbersome
07:29:07 <beaky> ah
07:29:16 * hackagebot adp-multi-monadiccp 0.2.1 - Subword construction in adp-multi using monadiccp  http://hackage.haskell.org/package/adp-multi-monadiccp-0.2.1 (MaikRiechert)
07:29:18 <beaky> it's impossible in C too :(
07:30:37 <Sculptor> yo
07:31:25 <typoclass> Sculptor: hello
07:31:32 <Sculptor> hello
07:33:15 <tdammers> optional arguments and partial function application - you can't have both with nice syntax
07:33:36 <beaky> ah so that's the tradeoff :(
07:33:45 <satc> I am getting this error  and I am not sure should I define the Monadstate instance for this => No instance for (MonadState (Maybe [Char]) IO)
07:33:46 <satc>       arising from a use of `get'
07:34:30 <paullik> Hello. I have a user-provided number and a list, the number is processed like so: "n = read user_n", I'm using this to get an element out of the list using the list index operator, but the user may supply a floating point value, or even something that cannot be "read" by haskell, so how can I check the valitity of the user's input?
07:34:55 <paullik> I only want to allow Ints...
07:35:23 <geekosaur> use reads instead, it will try to parse like read but returns the things it can parse and the leftover
07:35:25 <byorgey> beaky: OCaml tries to have both, but the result is somewhat horrific
07:36:12 <byorgey> satc: you cannot make that instance.   IO is not a state monad.
07:36:30 <byorgey> satc: if you paste your code along with the error on hpaste.org perhaps someone could help you figure out what you're doing wrong.
07:36:36 <companion_cube> come on, ocaml's syntax for optional/named arguments is quite nice
07:36:49 <paullik> geekosaur, ok, but what about the floating point number scenario? it will be able to parse something like 1.1 but I cannot use it with !!, what should I do regarding this?
07:36:52 <companion_cube> althoug indeed you have to specify that the optional argument is absent, in a few cases
07:37:08 <geekosaur> paullik, you can't do that anyway, you need *a* type
07:37:08 <byorgey> companion_cube: I wasn't talking about the syntax.  I agree the syntax is nice.
07:37:20 <companion_cube> ah
07:37:31 <byorgey> I guess that wasn't clear from context.
07:37:38 <byorgey> I mean the whole system is confusing and full of strange corner cases.
07:37:46 <companion_cube> for partial applications where the optional argument is ambiguous, you can always wrap in an anonymous function
07:37:50 <paullik> geekosaur, I don;t understand
07:37:52 <geekosaur> you can't say "give me whatever type you can pull out of this"
07:37:54 <Entroacceptor> :t reads
07:37:55 <lambdabot> Read a => ReadS a
07:38:00 <geekosaur> you must say "give me an Int" or etc.
07:38:04 <companion_cube> (also, optional arguments are best located as first arguments)
07:38:10 <merijn> :t Text.Read.readMaybe
07:38:11 <lambdabot> Not in scope: `Text.Read.readMaybe'
07:38:46 <merijn> Ignore lambdabot's lies, use Text.Read.readMaybe
07:38:48 <geekosaur> (well, there are ways to force the "whatever type" but in this case that is almost certainly not what you want, and they're not particularly simple because it goes against strong typing)
07:39:35 <geekosaur> merijn, readMaybe requires a fairly recent ghc, that's why lambdabot doesn't have it
07:39:54 <quchen> > reads "1" :: [(Int, String)] -- paullik
07:39:56 <lambdabot>   [(1,"")]
07:39:58 <geekosaur> (it's in some earlier ones as well but in an internal ghc module)
07:39:58 <quchen> > reads "1.1" :: [(Int, String)] -- paullik
07:39:59 <lambdabot>   []
07:40:18 <Spockz> dreixel: I need a instance Typeable1 (Modifiable IO IOref) but it cannot be automatically derived as Modifiable isn't kind *->*. Is there anyway to do this manually? (TypeRep is an internal type)
07:40:47 <paullik> quchen, geekosaur oh, man I was using read without typecasting, I get what you're saying now
07:41:03 <geekosaur> it's not a cast, it's a specifier
07:41:04 <merijn> paullik: There is no typecasting
07:41:23 <geekosaur> ("cast" implies converting. you are not converting anything here, you are telling it the type it must work with)
07:41:28 <barrucadu> paullik: In that case, it's just using whatever type it could derive automatically - which is probably Int, if that's what you're using it as
07:41:41 <byorgey> Spockz: if you look at the Data.Typeable module, it gives you lots of functions which you can use to construct TypeRep values
07:41:45 <byorgey> Spockz: even though TypeRep is abstract
07:42:17 <Spockz> byorgey: ah yes that is true
07:42:18 <byorgey> Spockz: in an upcoming version of GHC it will be able to automatically derive Typeable for a much wider range of data types
07:42:32 <paullik> ok, it makes sense
07:42:36 <Spockz> byorgey: I knew that. But that doesn't help me in my current situation
07:42:49 <byorgey> I know, I just thought it was worth mentioning =)
07:43:02 <paullik> is it safe to say that typecasting cannot occur ins haskell since it's pure?
07:43:24 <Twey> Taneb: I don't think the invocation syntax is the cumbersome thing about currying in Python :þ
07:43:25 <paullik> I cannopt change the type of a variable because I'd have to reassign it, right?
07:43:26 <Spockz> byorgey: Are there some examples as how to use those functions?
07:43:54 <merijn> > cast 1 :: Maybe Char
07:43:56 <lambdabot>   Nothing
07:44:00 <merijn> > cast 1 :: Maybe Int
07:44:01 <lambdabot>   Nothing
07:44:04 <merijn> > cast 1 :: Maybe Integer
07:44:06 <lambdabot>   Just 1
07:44:42 <typoclass> merijn: where is 'cast' from?
07:44:55 <byorgey> Spockz: I don't know of any examples.  Last time I needed it I just read the documentation and figured out which functions I needed to use.
07:45:02 <quchen> @index cast
07:45:02 <lambdabot> Data.Typeable, Data.Dynamic, Data.Generics.Basics, Data.Generics
07:45:03 <quchen> :-)
07:45:34 <paullik> ok, so I'm wrong
07:45:41 <typoclass> quchen: hm thanks
07:46:13 <merijn> typoclass: It lets you do horrible things like
07:46:21 <typoclass> paullik: so, Data.Dynamic and Data.Typeable and all that is not exactly a beginner-level thing
07:46:37 <merijn> > let eq x y = cast x == Just y in eq 'a' 1
07:46:39 <lambdabot>   False
07:46:50 <merijn> > let eq x y = cast x == Just y in eq 'a' 'a'
07:46:52 <lambdabot>   True
07:47:15 <quchen> paullik: What sometimes looks like typecasting in Haskell is actually using a conversion function. For example, things like fromIntegral would maybe be typecasts in other languages. The `cast` function merijin used is a very general interface to these conversion functions.
07:47:39 <elliott> ?
07:47:42 <Spockz> byorgey: do you know whether you can have Typeable instances for datatypes with type parameters of kind (* -> *)?
07:47:43 <elliott> cast doesn't do any conversion like that.
07:48:42 <typoclass> paullik: in principle, haskell has no typecasting. it has nothing like "this is declared to be an Int, but i'll now do some magic, which may or may not fail at runtime". for very specific cases (parsing json and that kind of thing) there's something that looks slightly similar, but i think that's not really important if you're just starting out with haskell :)
07:48:56 <quchen> elliott: Well, it converts one type into another (modulo Maybe), doesn't it?
07:49:24 <Spockz> quchen: but it isn't casting, casting is 'magically' saying Tada there you go now it has some other type
07:49:29 <elliott> no, it converts one Typeable type into itself
07:49:35 <elliott> it will never transport between unequal types
07:49:43 <ocharles> :t cast
07:49:44 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
07:49:44 <Spockz> quchen: or more like an assume
07:49:49 <byorgey> Spockz: yes, I think so
07:50:39 <paullik> well, I think I got the gist of the discussion
07:50:42 <merijn> If I have a haskell program that calls a C FFI function that uses fork internally, will that break anything once control flow returns to haskell world?
07:51:06 <typoclass> paullik: for more concrete advice, feel free to put your code on hpaste.org =) doesn't matter if it works or not
07:51:27 <Tinned_Tuna> merijn: I would assume that it depends what happens after the fork in C-land
07:51:28 <paullik> thanks guys, you shed a bit of light
07:52:00 <Twey> :t unsafeCoerce
07:52:01 <quchen> elliott: I see. It could cast Newtype Int to Newtype Int', but never Int to Integer.
07:52:01 <lambdabot> Not in scope: `unsafeCoerce'
07:52:03 <merijn> Tinned_Tuna: Lets assume that after the fork both process happily return control flow to haskell
07:52:04 <paullik> typoclass, I will, a bit later after I use "reads" to parse th input, I'll ask for some code review for the todo program started on lyah.com
07:52:14 <quchen> Eh, I meant Newtype' Int there.
07:52:30 <elliott> quchen: no
07:52:41 <elliott> Newtype Int and Newtype' Int will have different TypeReps
07:52:45 <elliott> because Newtype is not Newtype'
07:53:20 <typoclass> paullik: sure! =) go ahead and do that. good luck
07:54:12 <paullik> typoclass, thank
07:54:16 * hackagebot OptDir 0.0.3 - The OptDir type for representing optimization directions.  http://hackage.haskell.org/package/OptDir-0.0.3 (MasahiroSakai)
07:54:16 <paullik> thanks*
07:54:28 <Tinned_Tuna> merijn: without going and poking around, I couldn't say for sure
07:54:43 <merijn> Maybe more of a runtime question, I guess?
07:55:04 <typoclass> paullik: here is a short example how to use reads. basically, you usually put it in a "case of" http://www.haskell.org/haskellwiki/FAQ#How_do_I_catch_the_error_thrown_by_read_on_a_parse_failure.3F
07:55:21 <quchen> elliott: Well then I'm confused. What would be a practical cast example then?
07:55:29 <paullik> typoclass, will look into it
07:55:42 <Spockz> quchen: when you use existentials for example
07:55:49 <elliott> quchen: for instance, Dynamic can be implemented with cast
07:55:55 <merijn> quchen: Existential quantification where the Typeable dictionairy is stored with the value, but you don't know *what* value it is
07:55:56 <elliott> as a Typeable existential
07:56:15 * Twey knows of no type that actually returns multiple values from read
07:56:22 <andrea__> after several days i try to understand "applicative". it's more difficult than "monads" , i think. can someone help me with a little example ? what are applicatives ?
07:56:23 <Twey> (s)
07:56:24 <t7> its awkward to use guards and patternmatching with stuff in the state monad
07:56:39 <merijn> andrea__: The only thing applicatives "do" is
07:56:43 <merijn> :t (<*>)
07:56:44 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
07:57:06 <dreixel> Spockz: can you repeat your question?
07:57:07 <Twey> andrea__: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
07:57:18 <Spockz> dreixel: I need a instance Typeable1 (Modifiable IO IOref) but it cannot be automatically derived as Modifiable isn't kind *->*. Is there anyway to do this manually? (TypeRep is an internal type)
07:57:30 <quchen> Spockz, elliott, merijn: Ah, okay, thanks
07:57:52 <dreixel> Spockz: have you tried StandaloneDeriving?
07:57:54 <typoclass> andrea__: Applicative is essentially Functor (with its function 'fmap') plus two more functions ('pure' and (<*>)). have you seen typeclassopedia? it's fairly good at explaining it
07:57:58 <ion> Don’t trust that article when it talks about a function returning a monad. Those are not monads, they are monadic values.
07:57:58 <typoclass> @where typeclassopedia
07:57:59 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
07:58:07 <Spockz> dreixel: and Modifiable is from the Adaptive package (a newtype)
07:58:38 <dreixel> Spockz: what's the kind of Modifiable?
07:58:42 <Spockz> dreixel: yes it tells me that it cannot derive it because of this: Can't make a derived instance of `Typeable1 (Modifiable IO IORef)':
07:58:45 <Spockz>       `Modifiable' must only have arguments of kind `*'
07:59:04 <_Andrea_> typoclass, i will search there,
07:59:10 <Spockz> (* -> *) -> (* -> *) -> * -> *
07:59:16 * hackagebot delaunay 0.1.0.2 - Build a Delaunay triangulation of a set of points  http://hackage.haskell.org/package/delaunay-0.1.0.2 (MarcelRuegenberg)
07:59:31 <barrucadu> _Andrea_: I recommend perhaps reading "Applicative programming with effects", by McBride & Paterson. It's quite accessible if you're already familiar with monads and functors.
07:59:36 <_Andrea_> why i'm grey
07:59:37 <Spockz> dreixel: (* -> *) -> (* -> *) -> * -> *
07:59:58 <dreixel> Spockz: deriving instance (Typeable1 f, Typeable1 g) => Typeable 1 (Modifiable f g) ?
08:00:48 <Spockz> dreixel: same error
08:01:24 <dreixel> Spockz: right. I'm afraid you'll have to give a manual instance, then
08:01:26 <barrucadu> _Andrea_: Also, "The Essence of the Iterator Pattern", by Gibbons and Oliveira, uses applicatives to construct the Traversable class, showing how applicatives can be used to do iteration in a functional context. It's longer than "Applicative programming with effects", but worth a read if you're interested.
08:01:32 <dreixel> and your code will break with GHC 7.8.
08:02:37 <nickm> Newbie question: I've just written my first attempt at haskell in 15 years.  It's an attempt to do an independent implementation for the specification of a DPRNG I'm working on, so that the DPRNG will be easier to test and review.
08:02:47 <nickm> I've gotten the code writte, but it's dreadfully unidiomatic, I'm sure.
08:03:20 <nickm> I'm hoping somebody could give me a pointer or two about what I should learn next to write it better: https://github.com/nmathewson/libottery/blob/master/test/ottery.hs
08:04:05 <Spockz> dreixel: are there examples I could follow? I have the TyCon now, but I'm not sure how I should construct the TypeRep in such a way that it makes sense
08:04:58 <Spockz> nickm: just at first glance, use the hex conversion functions that are availabe
08:05:09 <Spockz> nickm: and use type synonyms for the pairs of Word32
08:05:55 <barrucadu> nickm: Also, `hlint` (available on hackage) is pretty good for suggesting improvements; I tend to run it over all of my code
08:07:58 <_Andrea_> Twey, thanks for the link with the pictures
08:08:08 <typoclass> nickm: hello. you may be interested in this:
08:08:11 <typoclass> > showHex 123 ""
08:08:12 <lambdabot>   "7b"
08:08:45 <dreixel> Spockz: I believe the time package (comes with ghc) has some...
08:09:02 <dreixel> Spockz: http://hackage.haskell.org/packages/archive/tagged/0.6/doc/html/src/Data-Tagged.html might not be exactly the problem you have
08:10:57 <Spockz> dreixel: as far as I can see they only declare the constructor, they don't do anything with the types of the arguments...
08:12:07 <Spockz> dreixel: and that feels odd to me
08:12:31 <dreixel> sorry that I'm just giving you slightly related examples, but I have to disconnect for a while now
08:12:47 <enigmuriatic> if I wanted to to parse this JSON feed, what's the easiest way? https://data.mtgox.com/api/1/BTCUSD/trades?since=0
08:13:03 <dreixel> but btw, Typeable doesn't care about the constructor arguments.
08:13:13 <Spockz> dreixel: oh it doesn't?
08:13:13 <dreixel> it only looks at the LHS of the datatype declaration, not the RHS.
08:13:14 <Clint> enigmuriatic: aeson?
08:13:28 <dreixel> Spockz: indeed. there's actually a bug report about this
08:14:05 <Spockz> dreixel: doesn't the LHS also include the type parameters?
08:14:25 <zomg> enigmuriatic: use json or aeson or something
08:14:34 <Spockz> dreixel: okay, have a nice flight?
08:15:20 <Twey> _Andrea_: No problem
08:16:47 <_Andrea_> perhaps this helps, in my opinion applicative and functor are harder to understand than monads
08:17:02 <Spockz> _Andrea_: why?
08:17:03 <typoclass> nickm: hm ... i think it'd help reduce clutter if you changed the 16-tuples into simple lists (in function tworounds). this would mean that theoretically someone could pass in a list of length 17 or 300 or 0 (the type system won't check that anymore), but i think it's justifiable since tworounds seems to be an internal function not being exported. it is easy enough to ensure the input is a list of the right length since there's only one
08:17:58 <typoclass> nickm: and -- you wrote all of this code after a long absence from haskell? that's quite impressive. so congratulations on that :)
08:18:00 <nickm> typoclass, barrucadu, Spockz: Thank you!
08:18:04 <_Andrea_> Spockz, monads i read a exaple step by step to simulate monads with normal function
08:18:14 <Spockz> typoclass: http://www.haskell.org/hoogle/?hoogle=(a%2Ca%2Ca)+-%3E+(b%2Cb%2Cb)+-%3E+(a+-%3E+b+-%3E+c)+-%3E+(c%2Cc%2Cc) << that's unfortunate
08:18:52 <nickm> typoclass: (Also, the haskell I did wasn't really haskell; it  was http://csg.csail.mit.edu/projects/languages/ph.shtml )
08:18:52 <Twey> _Andrea_: I'm not sure what that means
08:18:54 <typoclass> Spockz: hm ... you mean like (&&&), but for 3-tuples? i'm not aware of a function like that
08:19:16 <Spockz> typoclass: for the 16 tuple thingy of nickm
08:19:17 <Twey> _Andrea_: Monads don't use anything ‘special’ (apart from do-notation, which isn't necessary)
08:19:28 <Twey> _Andrea_: Simulating a monad using normal functions is just… writing a monad :þ
08:19:30 <elliott> nickm: I suggest defining a new data type, not using a list.
08:19:38 <Spockz> _Andrea_: maybe this helps http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
08:19:55 <_Andrea_> Twey, ok, i cannot explain t better
08:21:11 <_Andrea_> moment, brb
08:21:26 <Twey> It would be a lot easier to grasp if the classes were structured nicely, I think.
08:22:26 <typoclass> nickm: another thing. you can in general use "f y = let x = 42 in x*y", or equivalently "f y = x*y where x = 42". it could be more readable in some cases. most people use a linebreak before "x = 42" (same for 'where' and 'let ... in')
08:24:55 <typoclass> > iterate (*2) 42
08:24:56 <lambdabot>   [42,84,168,336,672,1344,2688,5376,10752,21504,43008,86016,172032,344064,688...
08:25:23 <tswett> > last . takeWhile (/= 0) . iterate (/2) $ 1.0
08:25:24 <lambdabot>   5.0e-324
08:25:43 <int-e> > fix ((1:) . map sum . inits)
08:25:44 <lambdabot>   [1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
08:26:08 <tswett> > 5.0e-324 / 2
08:26:09 <lambdabot>   0.0
08:26:15 <typoclass> > (iterate (*2) 42) !! 10
08:26:17 <lambdabot>   43008
08:26:38 <typoclass> nickm: if you wish, you can use iterate (see above) for implementing nTimes
08:27:22 <andrea__> re
08:27:31 <applicative_> enigmuriatic: the minimal aeson parser is main = BL.interact $ BL.pack . show . (decode :: BL.ByteString -> Maybe Value)
08:28:15 <applicative_> http://hpaste.org/88825 works fine
08:34:21 <andrea__> > fmap (+3) (Just 5)
08:34:22 <lambdabot>   Just 8
08:35:48 <nickm> Is there a showHex variant that does 0-padding, so that I can format [1,2,3] as 010203 rather than 123 ?
08:38:47 <bartavelle> nickm : this might be overkill in your case, or exactly what you need: http://hackage.haskell.org/package/base16-bytestring
08:39:19 <andrea__> :t (<$>)
08:39:20 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:40:11 <typoclass> > let pad s = '0' : s in map (pad . flip showHex "") [1,2,3] -- nickm, this is the simplest variant i guess
08:40:13 <lambdabot>   ["01","02","03"]
08:40:36 <typoclass> nickm: do you want to pad by one 0, or always to a certain length, or ...?
08:41:28 <andrea__> :t (<*>)
08:41:29 <nickm> I want to take a list of bytes, potentially several hundred of them, and encode them as a hex string. I want to be able to reverse that encoding. I don't care about efficiency; this program is for testing another program.
08:41:30 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:42:06 <bartavelle> nickm : then base16-bytestring will do this for you. It is easy to use and efficient, provided that you encode your bytes into a bytestring
08:42:57 <typoclass> bartavelle: he was working with [Word8], so converting to ByteString is presumably not a problem
08:43:18 <nickm> neat; thanks!
08:44:31 <nickm> Finally, my PRNG code currently manages state by having every function take a PRNG state as input and return a PRNG state as one output.  I gather that I want to use one of those interesting Haskell functional-programming features to handle this pattern properly.  I don't remember any of them.  Which one should I learn, and how should I learn it?
08:44:57 <andrea__> > (* 5) <$> (Just 5)
08:44:58 <lambdabot>   Just 25
08:45:19 <bartavelle> nickm probably a State monad ?
08:45:25 <elliott> nickm: if you have functions like MyState -> (MyState, result) you can use the State monad
08:45:57 <elliott> nickm: State s a (where s is the state and a the output) is actually just a packaged function s -> (a, s), and you get nice combinators for working with it (including the Monad methods)
08:46:23 <bartavelle> (and the do notation)
08:46:27 <nickm> okay. Now suppose I have a lot of functions like MyState -> input -> (MyState, result), and I want to write some code that tests those functions by dumping the 'result' value to stdout.  Am I still on the right track with State ?
08:46:28 <typoclass> nickm: you could have a look at this https://en.wikibooks.org/wiki/Haskell/Understanding_monads/State i'm not sure if it's a good text, but glancing over it, it seems decent
08:47:18 <sellout-> Why did infix type variables disappear in GHC 7.6?
08:47:46 <byorgey> sellout-: because people wanted to use infix type constructors instead.
08:48:38 <applicative_> it's pretty annoying, but I guess it was worth the cost
08:49:36 <sellout-> Ok, thanks.
08:49:38 <typoclass> applicative_: i guess there could have been a switch? {-# LANGUAGE TheOldBehaviorPleaseForTypeVariables #-}
08:50:42 <applicative_> the use of them to express generality over (* -> * -> *) things was a giant win; a b c -> a c d -> a b d is unreadable blather
08:50:45 <byorgey> A switch might have been nice.
08:50:48 <typoclass> sellout-: but you're right that there seems to be some disagreement. in particular, cale has once or twice argued against that change, if you want to check ircbrowse.net ...
08:51:02 <byorgey> applicative_: at least you can still write  b `a` c -> c `a` d -> b `a` d
08:51:02 <enigmuriatic> applicative_, in that function you gave me what does "BL" represent?
08:51:08 <applicative_> conal argued against it on the lists but no one responded
08:51:23 <byorgey> yes, unfortunately Conal argued too late.
08:51:24 <elliott> applicative_: at least Arrow will be less popular now :P
08:51:33 <applicative_> enigmuriatic: import qualified ByteString.Lazy.Char8 as BL
08:51:42 <byorgey> on the other hand, having arbitrary infix type constructors is a win for people doing generic programming kind of stuff
08:51:48 <andrea__> i don't understand the difference between <*> and <$>
08:51:54 <byorgey> since you can write e.g.  data (f + g) a = Inl (f a) | Inr (g a)
08:52:03 <sellout-> elliott: Heh, yeah – Arrow is (of course) where I bumped into it.
08:52:30 <applicative_> profunctor, category etc. etc.  arrows are irrelevant
08:52:44 <applicative_> it's a disaster pure and simple
08:53:46 <byorgey> andrea__: can you write down their types without peeking?
08:53:47 <applicative_> enigmuriatic: here is the module http://hpaste.org/88825 of course you want to define an appropriate type like https://github.com/bos/aeson/blob/master/examples/Simplest.hs
08:53:49 <typoclass> weird. some things get discussed for years, but this (apparently?) was implemented so quickly that conal's opinion came too late
08:53:59 <sellout-> Ok, so it is actually contentious :D
08:54:27 <paullik> Hi again, I've completely written the todo application that is also implemented on lyah.com, I just added input validation and played around with exceptions, can someone please tell be what can be written in a more readable way and maybe more optimal (see the comments) and how would you do the input validation? http://hpaste.org/88827
08:54:32 <applicative_> yes, I think it came very quickly.
08:54:35 <andrea__> byorgey, no
08:54:52 <byorgey> andrea__: well, that's where you should start. =)
08:55:03 <dolio> Changes to GHC extensions don't typically take years to change.
08:55:03 <byorgey> andrea__: memorize their types and think about them for a while.
08:55:09 <dolio> Er.
08:55:14 <byorgey> andrea__: then come back and ask for more help if you still don't understand the difference.
08:55:23 <andrea__> :t <*>
08:55:24 <lambdabot> parse error on input `<*>'
08:55:32 <ocharles> :t (<*>)
08:55:33 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:55:35 <typoclass> sellout-: i don't have much of an opinion, but i think maybe should add that switch that reverts to the traditional syntax
08:55:35 <andrea__> :t <$>
08:55:36 <lambdabot> parse error on input `<$>'
08:55:44 <elliott> it's not as simple as adding a switch
08:55:48 <elliott> libraries can export the infix names
08:56:12 <andrea__> :t (<$>)
08:56:13 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:56:43 <applicative_> paullik: well, hlint seems to like it :) good work.
08:56:58 <typoclass> dolio: right. i was thinking about things like the Num hierarchy
08:57:10 <typoclass> (i.e., not ghc or syntax issues)
08:57:20 <sclv> i thought the proposal was eventually we'd now make :-> :~ etc be infix
08:57:30 <sclv> be infix type variables i mean
08:57:44 <sclv> dual to the use of (:) a the value level
08:58:00 <dreixel> Spockz: yes, it includes the type parameters.
08:58:02 <sclv> of course huge disruption to get there etc etc
08:58:05 <paullik> applicative_, oh, thanks for telling me about hlint, but to be honest I was expecting some human..ly advice
08:58:10 <dreixel> and yes, flying soon...
08:58:39 <typoclass> sclv: right, using the first char to decide if it's an operator or not. i've heard of it but i'm not sure if it's a proposal, or a wild idea, or agreed on, etc.
08:58:43 <applicative_> paullik: it looks generally sound. I'm not sure what comment to make.
08:59:26 <applicative_> paullik: a tiresome but worthwhile effort would be to translate from String to Text, though this won't have practical benefits in this case.
08:59:37 <dolio> Seems like a hard sell.
08:59:45 <dolio> "Lets make type operator the exact opposite of value operators."
09:00:13 <dolio> Well, not quite exact.
09:01:01 <geekosaur> I thought the idea was to keep symbol = infix but prefix : acts like uppercase letter indicating a typey thing instead of a valuey thing?
09:01:08 <applicative_> paullik: I wonder if you could get more of the top level stuff out of IO, note that every signature has IO in it.  It may be that this is because there isn't a mass of significant pure calculation
09:01:53 <andrea__> byorgey, Spockz, typoclass,and all other  thanks for your help.
09:02:11 <andrea__> cu
09:02:18 <paullik> applicative_, ok, I'll read about Text, my main concern was in the read and bump functions, where if the number of the task is invalid I still copy the file, this is not optimal and if I use if's or case's then I think the code would become somewhat spaghetti
09:02:19 <Spockz> dreixel: the example from time seems to ignore them
09:05:00 <paullik> applicative_, about the IO issue, I don't know what to say, I'll think about it, maybe factor out some functions that modify the contents and only use the existing functions to wrap those ...
09:05:29 <applicative_> paullik: ah yes. I'm not sure I see what's desired. You can do without reads if you use readMaybe from Text.Read
09:06:23 <dreixel> Spockz: if you need help, just send me an email with the relevant information
09:06:30 <Spockz> dreixel: I will
09:06:33 <dreixel> that's more reliable
09:06:46 <Spockz> dreixel: thanks. I'll see you tomorrow anyway I guess?
09:06:58 <dreixel> Spockz: was just about to ask if you'd be there tomorrow :)
09:07:00 <dreixel> yes
09:07:30 <Twey> zw 1
09:08:21 <applicative_> paullik: with readMaybe the first complicated case will be fromMaybe (length tasks) (readMaybe num), I think
09:08:52 <applicative_> that is, its length tasks unless the num string is readable
09:10:00 <paullik> applicative_, ok, I'll read about that later and try to use it, thank you for your feedback, I'll be back with questions if something comes up
09:11:23 <Spockz> dreixel: is your gmail address fine or do you want it somewhere else/
09:12:27 <pmade> The -hT RTS option seems to missing in GHC 7.4.2 and google isn't helping me find a suitable replacement.  What's a good way for me to see if I have a lot of unevaluated thunks?
09:16:52 <typoclass> pmade: hm. the documentation suggests it should be present http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/runtime-control.html#rts-profiling
09:17:39 <pmade> typoclass: strange.  When I run with -hT it prints RTS usage and quits.  Looking at the usage it outputs I don't see a T option to -h.
09:18:24 <monochrom> did you link your program with option "-rtsopts"?
09:18:40 <typoclass> pmade: there was a change at some point (7.4? don't remember). after the change the RTS options were unavailable by default, you need to turn them on with an extra ... er yeah that =)
09:18:59 <dreixel> Spockz: gmail is fine
09:19:13 <Spockz> dreixel: allright :)
09:19:19 <monochrom> most +RTS things are disabled by default. you have to ask for them at link time with -rtsopts. you can also be specific about what you ask for.
09:19:56 <nickm> holy moley. I used a monad and it actually worked.  Thanks again, elliott, bartavelle, typoclass.
09:19:59 <Ankhers> Anyone using emacs to write Haskell that I could ask a question or two?
09:20:07 <elliott> nickm: :)
09:20:12 <pmade> monochrom: Yes, I'm linking with that option.  I can already profile and generate other -h graphs.
09:20:19 <barrucadu> Ankhers: Go for it
09:20:34 <monochrom> yikes, then I don't know
09:21:04 <monochrom> move to 7.6.3 and the latest Haskell Platform anyway :)  just released two days ago
09:21:45 <Ankhers> barrucadu: I recently updated to the latest platform, and can no longer use inf-haskell mode. I was just wondering if you are seeing the same thing, or if I changed something in my config somewhere.
09:24:02 <typoclass> pmade: so, when you run "./yourProgram +RTS -hT -RTS", you get only the usage message, but with some other switch it works?
09:24:19 <pmade> typoclass: That's correct.
09:25:41 <barrucadu> Ankhers: I'm afraid I can't help; I don't use inf-haskell (although it sounds pretty neat), I just use haskell-mode
09:26:28 <typoclass> pmade: that sounds pretty much like a compiler bug to me. put a ticket on the ghc trac?
09:26:52 <pmade> typoclass: I'm building 7.6.3 now to test again.
09:27:05 <Ankhers> barrucadu: would you just be able to try and open it? I get the error upon starting the mode (C-c C-b)
09:27:38 <typoclass> pmade: ah, alright. though on most systems you can just download the binary (and save the compilation time) =)
09:27:47 <barrucadu> Ankhers: Although, I've just tried it out, and it seems to work.
09:28:35 <Ankhers> barrucadu: damn, thanks. Time to start digging.
09:29:02 <pmade> typoclass: I'm on Debian Linux, last I checked the only binary packages were from apt-get and tend to be old.
09:29:42 <typoclass> pmade: right, but there's also binaries to be downloaded from http://www.haskell.org/ghc/download_ghc_7_6_3
09:30:53 <pmade> typoclass: Thanks for the tip.
09:31:28 <typoclass> pmade: you're welcome. people generally don't recommend building ghc from source unless you have a good reason
09:32:39 <monochrom> it takes 1-2 hours
09:33:27 <monochrom> and now the cool kids are going to flame me because they have 16 cores and can get it done in 1/4 hours.
09:33:40 <monochrom> and insult my computer
09:34:03 <Ankhers> apframework
09:34:07 <elliott> poor monochrom
09:34:07 <Ankhers> sigh...
09:34:18 <elliott> poornochrom
09:35:19 <Tesseraction> well if you got a multicore computer you'd have to change your name to polychrom
09:35:31 <Tesseraction> so really the lack of speed is brand protection
09:35:34 <FreeFull> monochrom: My old laptop took over 4 hours to compile a linux kernel, and that's with the stuff I didn't need disable
09:35:37 <FreeFull> disabled*
09:43:13 <jnerula> Anyone have any good resources on Lenses?
09:45:41 <fizbin> jnerula: #haskell-lens
09:46:00 <typoclass> jnerula: here are 2 links https://github.com/ekmett/lens/wiki/Overview -- https://github.com/ekmett/lens/wiki/Examples
09:46:24 <fizbin> Plus the video that's linked to in the #haskell-lens channel message: http://youtu.be/cefnmjtAolY?hd=1
09:46:50 <elliott> I think the github wiki is out of date
09:46:55 <elliott> http://lens.github.com/ less so
09:47:17 <jnerula> fizbin typoclass Thanks
09:48:09 <typoclass> elliott: oh i see. that's unfortunate
10:01:21 <gilligan_> evening
10:02:07 <example> @src !
10:02:07 <lambdabot> arr@(Array l u _) ! i = unsafeAt arr (index (l,u) i)
10:04:59 <photex> hi folks, I'm getting a cabal error when trying to build haskell-platform 2013.2.0.0 with cabal 1.16.0.2
10:05:10 <photex> specifically, after configuring, I run make, and HUnit bails
10:05:35 <photex> stating: Setup: Use of GHC's environment variable GHC_PACKAGE_PATH is incompatible with Cabal. Use the flag --package-db to specify a package database
10:05:48 <photex> ghc is 7.6.3
10:05:51 <photex> freshly built
10:05:55 <dcoutts_> photex: yes, the error message explains the problem
10:06:08 <photex> I realize that yes, this is true
10:06:14 <photex> but I'd like to know *why*
10:06:21 <dcoutts_> so, don't use the GHC_PACKAGE_PATH stuff
10:06:27 <photex> I have just downloaded these
10:06:31 <photex> I haven't set an environment
10:06:39 <photex> this is a vanilla build and install I'm attempting
10:06:42 <jnerula> photex: Are you building it in a virthualenv or something?
10:06:43 <dcoutts_> photex: are you sure? check
10:07:03 <amyers> photex: Is this with virthualenv?
10:07:05 <photex> printenv | grep GHC is empty
10:07:08 <photex> amyers: no
10:07:28 <amyers> photex: cabal-dev or hsenv?  I've seen this before just can't remember which one
10:07:39 <jnerula> amyers: Me too but only with virthualenv
10:07:44 <jnerula> hsenv seems to work alright with 7.6.2
10:07:58 <amyers> jnerula: hmm yeah I think that's where I saw it as well.
10:08:21 <photex> amyers: I'm not doing anything other than: tar zxf haskell-platform.x.x.x.tar.gz; cd haskell-platform.x.x.x.tar.gz; ./configure; make
10:08:42 <photex> I did make sure that I had the latest cabal-install after installing ghc
10:08:55 <dcoutts_> photex: have you checked the env? echo $GHC_PACKAGE_PATH
10:09:20 <amyers> dcoutts_: He said printenv |grep GHC was empty.
10:09:24 <photex> dcoutts_: that what printenv does, but trying the echo aabove is also empty
10:09:49 <kennethmosquera> how could i print something on terminal and make it editable?
10:10:29 <photex> I'm running this all on Fedora17
10:10:38 <amyers> photex: What if you open a fresh terminal and re-run the command?
10:11:52 <photex> same error amyers
10:13:01 <dcoutts_> it must be coming from somewhere, e.g. some wrapper script
10:13:40 <amyers> photex: What OS are you on?  I just downloaded the 2013 Linux tarball for HP and am trying it now
10:14:03 <photex> Fedora 17
10:14:10 <photex> 64-bit
10:14:19 <photex> dcoutts_: scripts/build.sh sets it at one point
10:14:34 <photex> grep -R GHC_PACKAGE *
10:14:42 <photex> from the untarred package directory
10:15:26 <dcoutts_> photex: from the HP tarball?
10:15:32 <photex> yep
10:15:36 <dcoutts_> oh, that's not good
10:15:42 <photex> in build_pkg()
10:17:26 <pmade> Strange, after upgrading to 7.6.3 cabal seems to be ignoring ghc-prof-options.
10:27:37 <example> what the ! do in a Map type
10:27:50 <geekosaur> strictness annotation
10:28:03 <example> Map a(Float) ! a = ??
10:28:22 <elliott> that's not valid code. I'm not sure what you're asking.
10:28:47 <example> @paste
10:28:47 <lambdabot> Haskell pastebin: http://hpaste.org/
10:29:26 <example> i submited the code
10:29:27 <ion> “data Foo = Bar !Baz”: whenever a “Bar something” value is evaluated, the contained value of type Baz is evaluated as well.
10:29:45 <example> http://hpaste.org/88831
10:30:01 <example> i am trying to understand this implementation
10:30:14 <elliott> example: ok, then (!) is an operator which looks up a value in a map
10:30:21 <elliott> (!) :: Ord k => Map k a -> k -> a
10:30:34 <elliott> so in (m ! k), m is a map, k is the key to look up.
10:30:54 <ion> example: Ignore what i said. I thought you meant something in the definition of the type.
10:31:05 <example> ok
10:31:27 <example> i would like to understand this line
10:31:29 <example> m = K.minimum (fst . (ds !)) q
10:31:38 <ion> @unpl fst . (ds !)
10:31:38 <lambdabot> (\ d -> fst (ds ! d))
10:31:49 <ion> Those two are equivalent.
10:31:49 <geekosaur> (ds !) is a section, meaning a partially applied infix operator
10:31:59 <elliott> example: have you read a haskell tutorial like Learn You a Haskell or Real World Haskell?
10:32:07 <example> yes
10:32:11 <elliott> it will be very difficult to understand this code without familiarity with things like infix operators and function composition
10:32:19 <ChongLi> does GHC ever decide to unpack strict fields on its own (without the UNPACK pragma)?
10:32:38 <amyers> ChongLi: With 7.8 that's becoming the default IIRC.
10:32:43 <amyers> ChongLi: But not currently
10:32:48 <ChongLi> ahh
10:32:52 <example> the Data.List.Key is not in default haskell package?
10:32:53 <ion> example: You’re a pretty fast reader. LYAH in six hours?
10:32:53 <elliott> ChongLi: if you pass -funbox-strict-fields
10:33:03 <ChongLi> I was wondering what the advantage of having boxed strict fields would be
10:33:05 <elliott> example: Data.List.Key?
10:33:19 <example> i don't read the entire book
10:33:26 <amyers> ChongLi: It can prevent space leaks
10:33:26 <geekosaur> perhaps you should
10:33:27 <frihd> ion that's the time to understand the pictures ;)
10:33:28 <elliott> I suggest reading the entire book.
10:33:33 <elliott> it will make understanding Haskell code a lot easier
10:33:43 <elliott> and maybe help you ask more effective questions :P
10:33:43 <ChongLi> amyers: ahhhh
10:33:49 <example> Data.List.Key
10:34:02 <geekosaur> where are you finding this?
10:34:30 <ChongLi> does GHC ever turn a WHNF back into an unevaluated thunk?
10:34:48 <elliott> ChongLi: no
10:35:25 <monochrom> photex: I can't reproduce the problem. in fact, upon carefully reading build.sh, it is very careful in never letting Setup see GHC_PACKAGE_PATH
10:35:55 <ChongLi> ah, so if you're always making things strict and unboxing all over the place
10:36:00 <example> when i write ghc test.hs in the console with the code above i see this error message:  Could not find module `Data.List.Key':
10:36:06 <ChongLi> you may end up with huge objects being allocated unnecessarily
10:36:20 <photex> monochrom: that's what it *looks* like, but well... I can't build the latest haskell platform and this is the error
10:36:28 <photex> I'm not sure what else to try
10:36:35 <monochrom> but I can, I get no error
10:36:36 <ChongLi> and of course, you're not getting the benefit of laziness
10:36:54 <photex> monochrom: on Fedora 17?
10:37:00 <monochrom> ubuntu 13.04
10:37:01 <photex> bash
10:37:10 <elliott> example: that seems to be in the utility-ht package. where is this code from? does it contain a Cabal package file or documentation which describes its dependencies?
10:37:18 <geekosaur> example, the only "code above" I see from you is a single function which doesn't include any imports?
10:37:48 <example> Oh i'm sorry
10:38:41 <example> http://hpaste.org/88831
10:38:48 <example> i put the complete code now
10:39:31 <elliott> where did you get this code from?
10:39:53 <amyers> ChongLi: Yeah, that's the other side of the space leak coin
10:40:07 <amyers> ChongLi: This is an interesting blog post on the subject
10:40:09 <amyers> ChongLi: http://blog.ezyang.com/2011/05/an-insufficiently-lazy-map/
10:40:13 <photex> so what do you suggest monochrom? any ideas for how to figure out why this doesn't work on my system but does on yours?
10:40:18 <example> elliott i get the code from here : http://bonsaicode.wordpress.com/2011/01/04/programming-praxis-dijkstra%E2%80%99s-algorithm/
10:40:29 <photex> my environment is clean, and this is a freshly unpacked HP
10:40:31 <ChongLi> checking it out now
10:40:53 <photex> I had a previous build out there in /usr/local and I'm running XMonad
10:40:57 <elliott> hm, curious that it doesn't mention where it gets the Data.List.Key module from.
10:41:04 <elliott> oh
10:41:07 <elliott> it's mentioned in the comments
10:41:10 <photex> I'm running the build as root from /tmp
10:41:31 <photex> so it's not using any of my environment
10:43:21 <amyers> ChongLi: Found the matching article about a space leak problem: http://blog.ezyang.com/2011/05/anatomy-of-a-thunk-leak/
10:43:26 <example> hum , i will need to implement this K.minimum from Data.List.Key because i can't use non-standard modules
10:43:42 <elliott> is this homework?
10:43:51 <example> yet
10:43:58 <ChongLi> amyers: thanks, this is great stuff
10:44:01 <elliott> I personally recommend not cheating on homework by using other people's code
10:44:22 <sleepynate> oh man the gloves are comin' off
10:44:56 <photex> I've added an echo statement to build.sh to make sure that that var is not set in my environemtn
10:45:00 <photex> and it's not
10:45:12 <amyers> ChongLi: Yeah, there is a lot of good stuff on his blog.
10:45:24 <photex> so *something* is happening in this build script or some other part of the HP build that is causing this error
10:45:43 <example> i agree with you, but i'm trying to understand the details of the implementation to produce alone
10:45:47 <viller> let's say I want to find the maximum and minimum in a list of integers. I can do one traversal and return a pair. Let's say I now have to recursively traverse some data structure and return n values. Is there a solution other than tuples or lists? Tuples feel very inconvenient for this.
10:45:56 <example> i don't want to copy the code
10:46:11 <photex> right at the top of build.sh I added 'echo "GHC_PACKAGE_PATH=${GHC_PACKAGE_PATH}"'
10:46:24 <photex> all that's printed is "GHC_PACKAGE_PATH="
10:46:37 <elliott> viller: it's possible to "zip" together multiple independent folds of a list and run them in one go (they form an Applicative). you might find this useful if you're doing it a lot
10:47:26 <viller> elliott that sounds interesting. Any links you could provide?
10:48:41 <elliott> viller: I think conal has a blog post about it. the basic idea is: data Fold a b = Fold b (a -> Fold a b), which forms an Applicative, Comonad, etc. (it's also the same as type Fold a = Cofree ((->) a), with the "free" package, which gives you all those instances for free). then to run it you feed all the elements through the functions recursively switching to the new fold each time, and then take out the b
10:48:53 <elliott> then you can do things like (/) <$> sumF <*> lengthF
10:48:56 <ChongLi> amyers: wow, this first article is great
10:49:31 <elliott> viller: here's one I made earlier™ with Cofree: http://hpaste.org/88834
10:49:57 <ChongLi> who woulda thought a head and tail thunk were a lot smaller than keeping the entire structure around in memory? :)
10:50:01 <viller> I'm a haskell beginner so going through this will take a bit of time
10:50:01 <viller> thanks elliott
10:50:13 <elliott> yeah, you probably don't want to use that form directly just for this :P
10:50:14 <viller> are you related to conal?
10:50:21 <elliott> nope, we just share a name
10:50:23 <jonkri> how can i specify the path to ghc in cabal-dev? i want to write a script that compiles my project with different versions of ghc
10:51:22 <elliott> viller: -- after you define that though, you can use things like sequenceA (from Data.Traversable, generalisation of the monadic sequence), passing in a list of the folds you want to run over a list and getting a fold that produces a list
10:51:34 <geekosaur> jonkri, I think you've gone beyond what cabal-dev supports and may want to look into hsenv?
10:51:48 <elliott> viller: note that you will do duplicate comparisons if you use this to get the minimum and maximum, so if you are worried about performance then it might be best to do something uglier
10:52:51 <jonkri> geekosaur: thanks
10:53:24 <viller> maybe there really is no problem, maybe it's just the way I'm programming this thing that causes the need to return many values
10:55:14 <viller> maybe after the traversal I could call a function for what needs to be done next like in CPS. Maybe that would result in nicer code :P
10:55:30 <viller> that was a lot of maybes
11:00:18 <photex> monochrom, amyers dcoutts_: if I comment out the line in build.sh that sets GHC_PACKAGE_PATH in build_pkg the build works fine
11:00:54 <monochrom> what is that line verbatim? in fact I only see an unset line.
11:01:03 <photex> look a few lines below
11:01:17 <photex> before the call to tell
11:01:39 <monochrom> that one only lets GHC see it and it works fine
11:01:45 <photex> GHC_PACKAGE_PATH="${ORIG_GHC_PACKAGE_PATH}" \
11:01:53 <photex> monochrom: it clearly *doesn't* work fine
11:02:11 <photex> maybe you need to prefix that with the env command?
11:02:32 <monochrom> sorry, I don't understand the question.
11:02:54 <photex> didn't mean to use a '?'
11:03:09 <monochrom> then I don't understand the instruction
11:03:32 <photex> change GHC_PACKAGE_PATH="${ORIG_GHC_PACKAGE_PATH}"  to: env GHC_PACKAGE_PATH="${ORIG_GHC_PACKAGE_PATH}" \
11:04:28 <photex> that won't work with tell though
11:04:32 <monochrom> you are effectively saying, your /bin/sh is broken
11:04:48 <photex> I'm saying that /bin/sh on Fedora 17 operates this way
11:05:03 <photex> and that HP doesn't build as a result
11:05:06 <quchen> photex:  Someone wrote about having a similar problem on Reddit: http://www.reddit.com/r/haskell/comments/1f8730/basic_guide_on_how_to_install_ghcplatform_manually/ca85u3p
11:05:35 <photex> could be worth adding to the docs. I'm sorry if this is aggravating anyone. I'm not trying to bother any of you.
11:05:55 <monochrom> could you perform an experiment for me?
11:05:59 <photex> sure
11:06:26 <monochrom> launch /bin/sh. don't quit it yet.
11:06:50 <monochrom> enter: YYZ=yyz true
11:06:52 <photex> ok
11:06:56 <monochrom> enter: echo $YYZ
11:07:09 <monochrom> what is the output of echo $YYZ ?
11:07:15 <photex> empty
11:07:20 <amyers> ChongLi: It all depends on how big the fully evaluated data structure is compared to the thunk required to create it
11:07:35 <photex> but if you set a variable in a script will work differently.
11:07:58 <amyers> ChongLi: Strictness also plays a big role if you want to do parallelism.  Simon Marlow is working on a book that's available on O'Reilly OFS right now
11:08:14 <amyers> ChongLi: This is the section about strictness and how it impacts parallel evaluation: http://ofps.oreilly.com/titles/9781449335946/sec_par-eval.html
11:08:15 <geekosaur> photex, not exactly
11:08:35 <geekosaur> foo=bar command # sets foo=bar in the environment for that command ONLY
11:08:44 <monochrom> ok, suppose you were to enter this two lines. line 1: YYZ=yyz \  line 2: true .  Do you understand that this is the same as YYZ=yyz true ?
11:08:50 <geekosaur> foo=bar # by itself, sets a shell variable for the current session
11:08:51 <monochrom> note the \
11:09:00 <photex> yep, I understand all of this
11:09:01 <ChongLi> amyers: as always, the details get more complicated as you go along
11:09:10 <monochrom> build.sh has that \
11:09:16 <photex> yes it does
11:09:22 <ChongLi> I really like that Haskell folks are working on this so diligently
11:09:22 <photex> but if I comment that out
11:09:26 <photex> HP will build
11:09:31 <photex> if I leave it, it won't build
11:09:45 <ChongLi> most languages just throw it all away and go with strict evaluation everywhere
11:10:02 <photex> so there is a problem here with this line
11:10:13 <photex> *why* there is a problem I can't say
11:10:23 <monochrom> where did you get GHC?
11:10:46 <amyers> ChongLi: Yeah, and GHC's profiling tools help a lot with finding problems.
11:10:49 <photex> built from source
11:11:04 <photex> used 7.4.2 for the bootstrap
11:11:15 <monochrom> ok that's fine
11:11:16 <ChongLi> amyers: will garbage collecting scale to hypothetical many-core machines in the future?
11:11:39 <monochrom> perhaps I'll have to try Fedora 17 some other day
11:11:50 <ChongLi> for some reason I have this intuition that highly parallel GC is really hard to do
11:11:57 <elliott> GHC has a parallel GC
11:12:19 <ChongLi> right, but I don't believe that's a binary choice
11:12:39 <photex> it might just be worth noting on the HP download page
11:13:01 <photex> as evidenced by the reddit post I'm not the only person whose had this problem and resolved it by commenting out that line
11:13:03 <ChongLi> will it scale to a thousand cores? NUMA architectures? or will we have to move to separate heaps with actor-style message passing?
11:13:09 <elliott> photex: put an issue on ghc trac
11:13:16 <photex> elliott: will do
11:15:37 <amyers> ChongLi: I don't know.  GHC does quite well up to 64 cores at least, which is a lot more than I have access to on one machine :)
11:15:49 <ChongLi> amyers: that's really cool
11:17:18 <preyalone> How can I runRVar over a tuple of distributions to sample?
11:18:18 <amyers> ChongLi: hmm, I can't remember where I saw that 64 number.  maybe I'm thinking of something else
11:18:25 <amyers> ChongLi: It does well at least up to twenty
11:18:37 <amyers> ChongLi: I remember Simon Marlow discussing that on G+ a while back
11:19:32 <ChongLi> the other question I have is this: are we in a chicken-and-egg situation regarding many-core systems?
11:19:58 <ChongLi> it seems like intel has scaled back their previously-aggressive pursuit of these machines
11:20:42 <amyers> ChongLi: How do you mean chicken and egg situation?
11:21:04 <ChongLi> well if intel (or any other chipmaker) believes that the software world isn't ready to utilize these machines
11:21:16 <ChongLi> then maybe demand will be too low to warrant investment
11:21:38 <amyers> ChongLi: ah.  I think it's more a power vs performance trade off
11:21:51 <ChongLi> likewise, if advancement in multi-cores slows, what is the incentive for developing software to take advantage
11:22:00 <amyers> ChongLi: Right now lowering power consumption is more important than increasing cores > 4 or 8
11:22:17 <ChongLi> ah
11:22:26 <amyers> ChongLi: Some people think we will see more heterogenous computing because of power constraints.  Which seems to be born out with GPU computing somewhat
11:22:28 <monochrom> go with IBM if you want many, many cores. they also like STM, though they're in the more difficult imperative setting.
11:22:28 <ChongLi> I guess once that avenue has dried up they'll come back to it?
11:23:10 <ChongLi> I'm actually intrigued by AMD's shared memory architecture
11:23:26 <luite> ChongLi: intel tried to use their manycore design as a graphics thing, but it failed to deliver the expected performance
11:23:35 <ChongLi> eliminating the expensive copy could really make GPUs a lot more viable
11:23:56 <ChongLi> since you won't have to structure your workloads for bulk transfer
11:25:49 <ChongLi> speaking of memory
11:26:22 <ChongLi> anyone think we'll ever get dramatically lower latency memory?
11:26:48 <ChongLi> cause that would really speed up situations with less-than-ideal locality
11:28:20 <geekosaur> there are lower latency RAMs, see: L2 cache. but only up to a point since addressing takes time
11:29:06 <ChongLi> hmm
11:30:29 <kennethmosquera> edit a print on terminal?
11:30:41 <elliott> wat
11:30:43 <ion> ok
11:31:25 <monochrom> use a library such as haskeline
11:32:00 <geekosaur> kennethmosquera, can you re-ask that with more detail? but in general once you have output something to the screen, it's not actually "there" any more (the terminal has it, the program that did the output does not)
11:32:06 <monochrom> (it was <kennethmosquera> how could i print something on terminal and make it editable? )
11:32:30 <geekosaur> (and while x11 based stuff lets you get at the terminal window, what you get is *bits* not characters)
11:32:31 <kennethmosquera> yes
11:32:37 <monochrom> if no one answered, I expect the question would be further compressed in the future.
11:32:59 <kennethmosquera> for example i have a line "I am worng"
11:32:59 <elliott> monochrom: and eventually end up having negative length and eating up other people's messages?
11:33:02 <monochrom> http://captionsearch.com/image.php?id=244
11:33:12 <kennethmosquera> print line "i am wront"
11:33:18 <monochrom> eventually becoming philosophical and meta :)
11:33:40 <kennethmosquera> edit it in terminal "i am wrong" send it back as a getline
11:33:52 <elliott> I second monochrom's suggestion then
11:35:04 <geekosaur> not clear, readline is input, not output
11:35:37 <geekosaur> possibly it's in the realm of hscurses/ncurses/nanocurses
11:35:44 <elliott> geekosaur: you can pre-fill the line with readline
11:35:48 <elliott> to allow editing it
11:36:00 <elliott> same way bash history etc. work
11:36:05 <monochrom> perhaps there is provision for initializing the input buffer, mimicking output
11:36:07 <geekosaur> yes, but it's not a default behavior operative on random output
11:36:17 <geekosaur> so it depends on what exactly they're looking for
11:36:27 <elliott> oh, if it's wanted for random lines in the program then that's less clear, right
11:37:12 <aristid> monochrom: heh seems like Nietzsche is a difficult word to write (it's correct in the image and wrong in the caption)
11:37:48 <monochrom> I keep mixing up Deustche Deutche Deutsche etc.
11:37:59 <monochrom> I used to mix up freunde and freude
11:38:08 <mauke> you need to memorize Scheiße
11:38:11 <mauke> it's a great word
11:38:30 <mauke> (I was just thinking about that)
11:38:48 <sleepynate> it's synonymous with Dinge
11:39:21 <ion> > execWriter . (`runStateT` mkStdGen 42) $ mapM_ (\c -> do b <- state random; when b $ tell [c]) "edit a print on terminal?"
11:39:23 <lambdabot>   "ediapint ter"
11:40:18 <monochrom> O Freude, nicht diese Töne! ...  Freunde schöner Göttenfunken...
11:40:20 <mauke> it's great because it shows 'sch', 'ei', 'ß', and 'e', all of which are german specialties
11:40:39 <mauke> Götte*r*funken
11:40:44 <mauke> :-D
11:40:55 * mauke wanders off to #haskell-blah
11:40:57 <monochrom> German is hard
11:41:06 <monochrom> Haskell is so much easier
11:41:23 <elliott> > randoms (mkStdGen 42)
11:41:23 <kennethmosquera> mother of
11:41:24 <lambdabot>   [-3907187990116499535,-2519438828217931933,-8264534369199619667,86887135830...
11:41:31 <tsinnema> hefe-weißbier!
11:41:37 <ion> I love Haskell. It’s so easy.
11:43:17 <cjay> I'm also glad that types don't have a mandatory gender associated with them ;)
11:43:47 <ion> tsinnema: I wish i had some.
11:44:28 <ChongLi> I'm also glad that Haskell is written in latin (sometimes greek) characters rather than traditional chinese or something crazy like that!
11:44:51 <mauke> >implying I don't use chinese characters for my identifiers
11:45:08 <tsinnema> ion, i was about to say 'i just did' but turns out there's still a couple of mouthfuls in the can!
11:45:15 <mauke> actually, I wonder why mathematicians haven't started using chinese yet
11:45:29 <ChongLi> too hard I guess
11:45:47 <monochrom> it's all Chinese to me
11:45:51 <mauke> they're so opposed to multi-character identifiers that they'd rather plunder foreign alphabets or put weird accents on things
11:46:17 <ChongLi> plus chinese mathematicians might be annoyed that words with random unrelated meanings are shoved into a bunch of math notation
11:46:22 <mauke> γ̇ ℵ
11:56:05 <example> 2src key
11:56:09 <example> @src key
11:56:09 <lambdabot> Source not found. I feel much better now.
11:56:47 <example> @src keys
11:56:47 <lambdabot> Source not found. You speak an infinite deal of nothing
11:56:58 <kqr> @src keys
11:56:58 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:57:04 <kqr> where does the last part come from?
11:57:20 <ion> That looks very similar to the sudo insults.
11:57:30 <kqr> true
11:58:00 <Cale> http://hackage.haskell.org/packages/archive/containers/0.5.1.0/doc/html/src/Data-Map-Base.html#keys
11:58:45 <heath> is this the recommended method for sandboxing cabal-dev environments? https://github.com/lightquake/sandboxer
11:59:00 <sm> the mac HP installer has completed successfully.. uh, where can I see its effects ?
11:59:10 <jonkri> i want to use the ghc 7.6.3 binary on debian 7, but the binary was built for debian 6 and requires libgmp.so.3, which seems not to be available in debian 7. what are my options?
12:00:10 <Cale> heath: isn't that just cabal-dev -s?
12:00:17 <sm> the download page said "Follow the instructions.". The installer warned that older ghc's were installed - maybe it terminated early ?
12:00:24 <kennethmosquera> \query lambdabot > 1+1
12:00:33 <Cale> Or maybe I misunderstand the goal of this script
12:00:42 <byorgey> heath: There is also  hsenv
12:01:25 <byorgey> jonkri: unfortunately, the options are: find a binary built for debian 7, or build it from source yourself
12:01:51 <jonkri> byorgey: oh :( thanks byorgey
12:01:53 <byorgey> (building GHC from source is not hard, actually, it just takes a while)
12:02:15 * byorgey has run into issues with versions of libgmp before
12:03:18 <jonkri> ok :)
12:04:32 <jonkri> anyone knows if the ghc binaries work on a recent fedora system?
12:04:57 <ChongLi> the real trouble comes when you try to build packages on windows which have C dependencies
12:06:33 <enigmuriatic1> where should i learn how to use MariaDB with Haskell?
12:07:29 <ChongLi> http://book.realworldhaskell.org/read/using-databases.html
12:07:39 <enigmuriatic1> thanks ChongLi
12:08:35 <enigmuriatic1> hmm, none for MariaDB
12:08:47 <enigmuriatic1> whatever, i suppose. As long as it isn't MySQL
12:08:50 <ChongLi> mariaDB is renamed mysql
12:09:06 <ChongLi> it's the open source fork
12:09:29 <ChongLi> thanks to oracle's fine work
12:09:30 <enigmuriatic1> i know, ChongLi. i don't use MySQL anymore out of principle :D
12:10:15 <enigmuriatic1> they have differences at this point, though, albeit minor ones, because they're developed by different people
12:10:44 <ChongLi> yeah, same goes for libreoffice, right?
12:11:27 <enigmuriatic1> is that not open source anymore, ChongLi?
12:11:31 <enigmuriatic1> i just use Google Docs
12:14:11 <Fuuzetsu> Putting things on Google * effectively means that Google owns those things.
12:14:21 * hackagebot disjoint-sets-st 0.1 - Imperative ST/IO based disjoint set data structure.  http://hackage.haskell.org/package/disjoint-sets-st-0.1 (PetrPudlak)
12:14:26 <ChongLi> libreoffice is open source
12:14:38 <ChongLi> it's diverged from the original quite heavily
12:14:49 <geekosaur> pracle gave openoffice to the apache foundation, is that not good enough?
12:14:54 <geekosaur> *oracle
12:15:04 <ChongLi> that was after the fork
12:16:36 <mauke> geekosaur: too little, too late
12:19:12 <ChongLi> I'm still reading through this chapter from Simon Marlow's book
12:19:26 <ChongLi> one interesting thing I thought of just now
12:19:51 <ChongLi> due to overhead, the parallelism he uses here actually increases CPU time vs the sequential algorithm
12:20:17 <ChongLi> so while it may reduce wall clock time, it may not be what you want if the computer is under high load
12:21:56 <sm> aha, mystery solved - the HP mac installer opened a doc page in safari, which I never saw
12:22:26 <enigmuriatic1> is there a sqlite library widely considered to be the fastest and most reliable?
12:29:21 * hackagebot family-tree 0.5 - A family tree library for the Haskell programming language.  http://hackage.haskell.org/package/family-tree-0.5 (NathanVanDoorn)
12:33:08 <example> How i find a min element in a Map?
12:33:31 <shachaf> minView?
12:33:51 <example> @src minView
12:33:51 <lambdabot> Source not found. Just what do you think you're doing Dave?
12:36:11 <example> i have an element in the value to compare eg Map a (Float,a) and want the key of the min based on the Float value in the value
12:36:48 <shachaf> OK, then the Map isn't sorted, so you have to scan the whole thing.
12:36:58 <shachaf> So toList?
12:37:18 <shachaf> Or some kind of fold, or something.
12:40:46 <nan`> if i do mapM id [Just 1, Just 2, Just 3, Nothing, Just 4]
12:40:55 <nan`> is the 4 ever taken out of just 4?
12:41:14 <shachaf> What does it mean to take something out?
12:41:22 <shachaf> (mapM id is also called sequence.)
12:41:41 <nan`> yes i was trying to think of the right way to say that
12:41:55 <shachaf> Are you asking if forcing "sequence [Just 1, Just 2, Nothing, x]" forces "x"?
12:41:58 <c_wraith> > sequence [Just 1, Just 2, Nothing, undefined] -- nan` this is a better example
12:42:00 <lambdabot>   Nothing
12:42:09 <nan`> actually what i mean here is, is
12:42:30 <nan`> how about this, is id (Just 4) ever evaluated
12:42:39 <c_wraith> nan`: didn't I just answer that?
12:42:49 <nan`> not directly, no
12:42:55 <c_wraith> nan`: yes, I did
12:43:07 <c_wraith> nan`: take a look at that example
12:43:14 <nan`> c_wraith: ok
12:43:28 <nan`> but that is still an indirect answer
12:43:46 <c_wraith> it's pretty darn direct. If undefined was evaluated, the result would be an exception
12:44:13 <c_wraith> So it directly indicates whether the subexpression was evaluated.
12:50:45 <test_> Hello
12:54:04 <merijn> dcoutts_: Is there any reason why cabl only automatically runs missing steps when you hit "cabal install" and not for the other commands? i.e. why do I have to manually configure to run "cabal build"?
12:54:26 <griswold1> c_wraith: sorry i got disconnected. Yes, that answers it fine i hadn't convinced myself that mapM id was exactly the same as sequence in all cases
12:57:21 <griswold1> net spleet
12:57:31 <merijn> To answer my own question from earlier: The haskell runtime *really* doesn't like you forking in C code and then returning to haskell code :>
13:22:53 <merijn> For executables should I just have Main.hs in the top level with modules in MyExecutable.ModuleName ?
13:30:54 <Cale> merijn: Generally you name your main file  executableName.hs  but it still defines  module Main where  (or you can leave the decl out and Main is the default module name)
13:31:42 <merijn> Cale: Sure, I was just wondering whether "main at top level, rest in MyExecutable directory" was a common layout
13:31:59 <merijn> And if not, what *is* a common layout :p
13:32:09 <Cale> If the stuff is really specific to that executable, then that probably makes sense.
13:32:27 <Cale> I'd say do whatever makes sense to you.
13:32:44 <acowley> Isn't there an issue of rebuilding things if you have a lib and an exe?
13:33:02 <Cale> If it makes sense that certain modules go under Control.Monad.* or something, then you can just build those paths inside your project tree
13:36:34 <merijn> Completely unrelated issue. Is there a wrapper for stat/fstat somewhere? I can't find it in System.Posix
13:37:11 <merijn> oh, getFileStatus. I'm blind
13:37:36 <Clint> even better than lua's
13:37:52 <enigmuriatic1> so, say i have a JSON feed that gives me the first n data points after the Unix timestamp i supply it. I want to start at the timestamp 0 and work my way up from there, taking the last timestamp and getting all transactions from that time on. what's the best way to do this in Haskell? should I write the code using curl or wget in bash and then have Haskell parse the data? or should I use a Haskell library that does the downloading?
13:38:40 <Cale> enigmuriatic1: Both of those seem reasonable to me. There are certainly good Haskell libraries for downloading things and dealing with HTTP connections.
13:39:07 <enigmuriatic1> what's the most common library used for that?
13:39:07 <merijn> http-conduit has been very easy to use so far
13:39:49 <Cale> http://hackage.haskell.org/package/download is rather simple to use, I like it for quick things
13:40:35 <merijn> "simpleHttp :: MonadIO m => String -> m ByteString"
13:40:39 <Cale> There's also http://hackage.haskell.org/package/download-curl which handles a few more protocols
13:41:06 <joelteon> so $() isn't really a function
13:41:08 <joelteon> it's syntax sugar
13:41:27 <Cale> joelteon: It's real syntax
13:41:44 <merijn> I'm slightly annoyed that many IO functions in System.Posix don't specify which errors are thrown by it...
13:41:45 <Cale> joelteon: er, if you're talking about Template Haskell
13:41:48 <joelteon> yeah, I am
13:41:52 <joelteon> huh
13:41:57 <joelteon> so can lambdabot's quotes be re-attributed?
13:42:10 <Cale> joelteon: That's the primitive thing which is used to insert a splice into your code.
13:42:15 <joelteon> right
13:42:37 <elliott> re-attributed howso?
13:42:43 <joelteon> like, I was otters
13:42:45 <elliott> you can forget a quote and re-remember it with another attribution
13:42:48 <joelteon> and there are a couple of my quotes in there
13:43:31 <tomejaguar> Cale: download looks nice.  I wish I'd known about it before.  simpleHttp is problematic for me because it throws exceptions.
13:43:49 <joelteon> I mean, obviously it's not that important
13:47:20 <nomeata> Hi. How do I import a module when I run code via "ghc -e 'foo'"?
13:48:08 <supki> ghc -e 'import M' -e 'foo'
13:48:42 <wilfredh> I'm trying to get a string display of a small double without scientific notation
13:48:43 <tomejaguar> This (http://www.haskell.org/cabal/users-guide/developing-packages.html) say "
13:48:50 <tomejaguar> "having both a library and executables in a package does not work very well"
13:48:54 <tomejaguar> is that still true?
13:48:54 <shachaf> Note that each -e is just a ghci line. So you could -e ':m + ...' etc. -- anything ghci can do.
13:49:00 <wilfredh> show 0.0825 -- gives "8.25e-2"
13:49:06 <tomejaguar> because immediately afterwards it says "Fortunately, starting with Cabal 1.8.0.4, executables can also declare the package that they are in as a dependency"
13:49:26 <wilfredh> how would I get "0.0825" out?
13:49:59 <shachaf> wilfredh: Try showFFloat or similar from Numeric?
13:50:31 <shachaf> > showFFloat Nothing 0.0825 ""
13:50:32 <lambdabot>   "0.0825"
13:50:40 <shachaf> > showFFloat (Just 1) 0.0825 ""
13:50:43 <lambdabot>   "0.1"
13:51:25 <acowley> tomejaguar: I've had success of late having an exe depend on a lib without having to rebuild the lib needlessly
13:51:34 <enthropy> > printf "%f" 0.0825 :: String
13:51:35 <lambdabot>   "0.0825"
13:52:09 <wilfredh> perfect, thanks
13:52:15 <shachaf> printf just calls showFFloat (but with less type safety)
13:56:21 <tomejaguar> acowley: Thanks, is there anything in particular I should be doing/watching out for?
13:56:47 <acowley> tomejaguar: You need to make sure the lib code isn't in the include path for the executable
13:57:47 <acowley> For one package, I have "hs-source-dirs: src" in the lib section, and "hs-source-dirs: src/executable" in the executable section.
13:58:09 <acowley> The executable lists the lib in its build-depends section.
13:58:43 <tomejaguar> So if it was "hs-source-dirs: src/lib" for the lib, and "hs-source-dirs: src" for the executable, it wouldn't work?
13:59:02 <acowley> I think that would be fine, too.
13:59:22 <acowley> You can just watch what cabal build does to see if things are working right
14:00:11 <tomejaguar> So what problems arise?
14:00:16 <tomejaguar> It rebuilds the lib when it doesn't need to?
14:00:50 <acowley> That was at least one of the issues in the past
14:01:13 <tomejaguar> OK, I'll try it and see.  Seems strange that building libraries and executables from the same source would be difficult.
14:01:45 <acowley> I think the issue was just that you couldn't refer to the lib in the executable section
14:02:10 <acowley> They were effectively independent, and you ended up rebuilding things repeatedly.
14:02:29 <tomejaguar> OK
14:02:40 <tomejaguar> I'll try it and see what happens.  Thanks.
14:03:04 <eikke> you can refer to the lib from an executable section nowadays
14:03:18 <acowley> Yes, that's what we've been talking about
14:03:19 <eikke> (although I just drop in so I missed the conversation)
14:03:32 * eikke appologises
14:03:50 <acowley> tomejaguar was asking what gotchas remain, so I mentioned that sharing an include path can still lead to spurious rebuilds.
14:04:57 <tomejaguar> No need to apologise, eikke, thanks for your input :)
14:08:19 <tomejaguar> acowley, eikke: so when you have a package "MyPackage" do you make your executable "build-depends: MyPackage" and then you don't have to explicitly list all the modules from MyPackage that the executable requires?
14:08:32 <acowley> tomejaguar: right!
14:10:12 <tomejaguar> Cool, that sounds easy.
14:12:44 <eikke> tomejaguar: yeah, only the lib name & whatever else the executable needs
14:12:57 <eikke> (so you will at least need 'base' stuff etc in there as well)
14:13:59 <Nimatek> Is the author of the cmdargs package here? I'm trying to build cmdargs-0.10.3 on armhf and it says "Template Haskell bracket illegal in a stage-1 compiler" even though this supposed to be fixed in 0.9.x according to the Debian bug tracker.
14:14:18 <tomejaguar> Yeah that makes sense.  I was just trying to understand if I had to list all the modules from "MyPackage" because the cabal user guide says so, but I think that's outdated.
14:15:25 <heath> from cabal-dev --help: -s DIR     --sandbox=DIR              The location of the development cabal sandbox (default: ./cabal-dev)
14:15:48 <heath> i have a question, but i'll just fire up an instance in virtualbox and find out
14:38:38 <Nik05> woho haskell thingy compiled without errors :P
14:38:50 <Fuuzetsu> as does an empty file
14:38:56 <acowley> Nik05: Ship it!
14:38:59 <Nik05> well its not empty :D
14:39:11 <Fuuzetsu> What did you makeV
14:39:12 <Fuuzetsu> ?*
14:39:12 <lambdabot> Maybe you meant: . ? @ v
14:39:28 <sellout-> lambdabot: That is unlikely.
14:39:28 <Nik05> need to make a program in matlab for my numerical math course, but tried it in haskell...
14:39:42 <Fuuzetsu> MATLAB is the worst.
14:39:47 <Fuuzetsu> I hate it.
14:40:11 <Nik05> but never saw haskell before today... so had some difficulties
14:40:40 <josephle> If it typechecks, it works!™
14:40:53 <Nik05> ok :P
14:41:00 <Automorphism> I am trying to use -XImpredicativeTypes with -XMultiParamTypeClasses together, to make a list of arbitrary (x :: a, y :: b)s such that they satisfy some type class constraint (SomeClass a b), but for some reason GHC does not accept my code, could anyone please have a look at it? http://ideone.com/1NBGGZ
14:41:36 <Fuuzetsu> Do you want a heterogeneous list? This is usually the sign of Something Wrong.
14:42:04 <Nik05> :( it compiled witouth errors, but when i try to run it :P
14:42:17 <Automorphism> Fuuzetsu: I am just doing it for the sake of pushing the type system to its limits.
14:43:03 <Fuuzetsu> Automorphism: I'd hardly classify that as the limits of the type system~ Have you had a look at http://www.haskell.org/haskellwiki/Heterogenous_collections ?
14:47:37 <Nik05> oh noes got ambiguous thingies
14:48:04 <Automorphism> Oh, turns out I just had to make my own tuple type instead of using Haskell's (,). :-P
14:49:01 <Nik05> ho do i make a anonymous function that does exp(-x^2 / 2)?
14:49:14 <Nik05> i tried (\x -> exp (-x^2 / 2))
14:49:24 <Fuuzetsu> and that didn't wark?
14:49:24 <hpc> :t (^)
14:49:25 <lambdabot> (Integral b, Num a) => a -> b -> a
14:49:27 <Fuuzetsu> work*
14:49:28 <hpc> :t (/)
14:49:29 <lambdabot> Fractional a => a -> a -> a
14:49:34 <sipa> > 4^5
14:49:35 <ion> > (\x -> exp (-x^2 / 2)) 42
14:49:36 <lambdabot>   1024
14:49:37 <lambdabot>   0.0
14:49:45 <hpc> that... should work
14:49:48 <ion> > (\x -> exp (-x^2 / 2)) 0.001
14:49:49 <lambdabot>   0.999999500000125
14:50:16 <ag90> I think he got an ambiguous type constraints error.
14:50:21 <Fuuzetsu> is that -(x^2) or (-x)^2?
14:50:36 <Nik05> -(x^2) ofcourse
14:51:03 <Fuuzetsu> thought so
14:51:12 <Fuuzetsu> So, what's your error?
14:51:15 <Nik05> No instance for (Num a0) arising from a use of syntactic negation
14:51:39 <ion> Please hpaste your full code and the full error message.
14:52:57 <Nik05> ok let me paste it
14:53:12 <Fuuzetsu> @where hpaste
14:53:12 <lambdabot> http://hpaste.org/
14:53:20 <Nik05> yes i know ;)
14:53:34 <tabemann> :t **
14:53:35 <lambdabot> parse error on input `**'
14:53:38 <Fuuzetsu> Just checking. Better safe than 80 lines in the IRC window~
14:53:52 <Nik05> its not 80 lines :p
14:53:59 <Nik05> oh wait with the error probably...
14:54:25 <tabemann> :t (**)
14:54:26 <lambdabot> Floating a => a -> a -> a
14:54:29 <luite> conal: do you want the new import to change the meaning of existing bindings, or just add new nodes from that import?
14:54:48 <conal> luite: just add nodes from the import
14:55:04 <tabemann> hmm.. what is the difference between ^ and ** except that ^ takes an integer exponent and is probably faster?
14:55:24 <ion> > x^5
14:55:25 <lambdabot>   x * x * (x * x) * x
14:55:27 <Heffalump> tabemann: the underlying algorithm, which would affect numeric precision
14:55:37 <mauke> ^ works by repeated multiplication
14:55:45 <luite> conal: ah so the problem is getting the import loaded in the name cache?
14:55:46 <Fuuzetsu> > x ** 5
14:55:46 <mauke> it works on any number
14:55:48 <lambdabot>   x**5
14:55:58 <ion> > x**5  -- uses the floating-point function
14:55:59 <lambdabot>   x**5
14:56:05 <mauke> ^^ can do negative exponents but requires fractional support
14:56:06 <hpc> > x^^5
14:56:08 <lambdabot>   x * x * (x * x) * x
14:56:10 <Fuuzetsu> How is lambdabot achieving this Prolog-like variable magic?
14:56:13 <mauke> ** doesn't give a fuck
14:56:15 <hpc> > x^^(-5)
14:56:16 <lambdabot>   recip (x * x * (x * x) * x)
14:56:21 <Fuuzetsu> (the source is scary)
14:56:25 <mauke> Fuuzetsu: it doesn't
14:56:29 <mauke> it comes from a moudle
14:56:31 <conal> luite: i guess so, though i'm failing even to import "id" from base.
14:56:37 <hpc> Fuuzetsu: there's a datatype that fakes it
14:56:42 <ion> fuuzetsu: The source of what?
14:56:44 <geekosaur> :t x
14:56:45 <lambdabot> Expr
14:56:48 <geekosaur> ^^
14:56:52 <Fuuzetsu> ion: lambdabot
14:57:01 <ion> @hackage simple-reflection or something like that
14:57:02 <lambdabot> http://hackage.haskell.org/package/simple-reflection or something like that
14:57:15 <ion> I lost.
14:57:18 <mauke> http://hackage.haskell.org/package/simple-reflect
14:57:27 <no-n> :>
14:57:35 <Nik05> sorry im adding some comments ;)
14:57:44 <Fuuzetsu> That's pretty cool
14:57:58 <Fuuzetsu> Yes, I like this~
14:57:59 <luite> conal: ah, i'll see if i can get some result playing with your code
14:58:16 <conal> luite: that'd be great. thanks much!
14:58:58 <luite> conal: i think base is a wired-in package, which gets renamed to a non-versioned package when loading
14:59:23 <conal> luite: oh! poor choice then.
14:59:32 <merijn> How do I tell cabal that my main file is a C file and not a haskell file?
14:59:53 <Fuuzetsu> …can you even do that?
14:59:55 <conal> luite: i was looking for something i could count on having been loaded already.
14:59:59 <merijn> Fuuzetsu: Why not?
15:00:07 <Fuuzetsu> I just never thought about it.
15:00:14 <merijn> Fuuzetsu: The C FFI works both ways :)
15:00:15 <ion> Write a Main.hs that just calls the C code via FFI. ;-) (Sorry, i don’t know.)
15:00:18 <conal> luite: … as a first try.
15:00:28 <luite> conal: right
15:00:37 <merijn> ion: I have a C function as main file precisely because that won't work
15:00:53 <ion> You can’t call that function from Haskell?
15:01:25 <merijn> ion: I'm messing with daemon(), fork() and other low level stuff. The RTS doesn't like being forked :p
15:01:38 <merijn> The child will just hang in definitely
15:02:00 <merijn> So I'm having a minimal C wrapper doing the fork/daemon thing and then call the main haskell program
15:02:06 <ion> merijn: hehe
15:02:35 <merijn> I can compile it by hand using ghc, but I dunno how to tell cabal to play nice with it
15:03:02 <mauke> .oO( write a Main.hs that executes the C program )
15:03:44 <monochrom> merijn: someone has to tell ghc "-no-hs-main". but I haven't looked up how to do that under cabal.
15:04:16 <merijn> Maybe if I chant dcoutts_ dcoutts_ dcoutts_ he'll show up and tell me :p
15:04:24 <ion> Perhaps ghc-options: that?
15:04:35 <monochrom> yeah, I think that's the best way now
15:04:49 <Fuuzetsu> dcoutts_ is the eternal cabal wizard
15:06:10 <merijn> Awww
15:06:14 <merijn> "Error: The 'Main-Is' field must specify a '.hs' or '.lhs' file"
15:06:38 <luite> conal: GHC has a built-in package id for base: Module.basePackageId, unfortunately using that doesn't help
15:06:39 <Fuuzetsu> .lhs file that compiles to a C file
15:06:54 <monochrom> oh, maybe cabal is not designed for that
15:07:18 <Nik05> http://hpaste.org/88839 here it is guys :p
15:07:52 <Nik05> hintv, equidist, tadd, fx, those functions work correctly
15:07:54 <monochrom> ok, get dcoutts to answer :)
15:09:25 * hackagebot haskell-spacegoo 0.1 - Client API for Rocket Scissor Spacegoo  http://hackage.haskell.org/package/haskell-spacegoo-0.1 (JoachimBreitner)
15:10:19 <Nik05> how bad is my code? :)
15:10:35 <Fuuzetsu> Nik05: it's not that bad but it shows it's your first time
15:11:00 <Nik05> :P
15:11:15 <Fuuzetsu> (\x -> x) is the same as just writing ‘id’; ‘f g x y = g x y’ is the same as just ‘f g = g’ etc.
15:11:34 <Fuuzetsu> As to your problem, you need some type signatures to guide the compiler
15:11:41 <Nik05> oops
15:11:44 <Nik05> \x <- ?
15:11:55 <Nik05> no no
15:11:56 <Fuuzetsu> Furthermore, you seem to be trying to print a function
15:11:58 <Nik05> huh i dont get it :p
15:12:08 <FreeFull> (sum (tadd (fx f a b n)) / 2) * (hintv a b n)  is the same as   sum (tadd (fx f a b n)) / 2 * hintv a b n
15:12:38 <Nik05> ok brackets later :P
15:12:46 <haasn> lots of unnecessary parens
15:12:54 <ion> nik05: You need one more parameter to trapimpl in the definition of trapint.
15:12:56 <Fuuzetsu> (which would become clear if you had type signatures as you'd get outright warned that your function is not doing what it should be)
15:13:03 <monochrom> this_is_a_name is a cool name :)
15:13:15 <ion> nik05: what fuuzetsu said about type signatures
15:13:18 <FreeFull> Nik05: Try   :t trapint
15:13:18 <Nik05> oops...
15:13:25 <Nik05> i see it lol
15:14:02 <Nik05> w00t that was everything
15:14:20 <ion> nik05: Use pattern matching instead of head/tail: tadd (a0:a1:as) = (a0 + a1) : tadd as
15:14:43 <Nik05> hm looks like im in a infinite loop
15:14:45 <ion> Actually, that isn’t the same code.
15:14:56 <h4199> the last line of tadd could be rewritten using pattern matching  tadd (x:xs) = (x + head xs) : (tadd xs)
15:15:08 <peterjoel> hi, how do I found out which GHC version is included in a given haskell platform version, without having to install it first?
15:15:13 <merijn> h4199: Parens are unnecessary there
15:15:14 <Nik05> ok thanks
15:15:26 <h4199> yes
15:15:41 <hpc> peterjoel: the quickest way is to ask in #haskell :D
15:16:07 <ion> h4199: That’s still using head.
15:16:21 <hpc> peterjoel: http://www.haskell.org/platform/changelog.html
15:16:29 <haasn> ion: tadd (a0:as@(a1:_)) = (a0 + a1) : tadd as -- ?
15:16:35 <h4199> yes you could add the additional match, I was keeping in the spirit of what he wrote
15:16:39 <peterjoel> hpc: thanks!
15:16:59 <merijn> haasn: Why not "tadd (a0:a1:as) = a0 + a1 : tadd as"?
15:17:04 <hpc> follow the other links in the top-right of the platform main page
15:17:06 <haasn> not the same code
15:17:23 <ion> haasn: Looks okay.
15:18:32 <Nik05> but guys how can i do y_n = x_n + x_n+1 ?
15:18:55 <ion> > let tadd (a0:as@(a1:_)) = (a0+a1):tadd as; tadd' xs@(_:ys) = zipWith (+) xs ys in zip (tadd [42..]) (tadd' [42..])
15:18:57 <lambdabot>   [(85,85),(87,87),(89,89),(91,91),(93,93),(95,95),(97,97),(99,99),(101,101),...
15:19:02 <nan`> is there a way to write guards based on constructor without binding it as a parameter, as in http://hpaste.org/88842
15:19:10 <haasn> > let xs = [1..10] in zipWith (+) xs (tail xs)
15:19:11 <lambdabot>   [3,5,7,9,11,13,15,17,19]
15:19:31 <Peaker> nan`, why do you want that?
15:19:32 <haasn> :t zipWith (+) . tail
15:19:33 <lambdabot> Num c => [c] -> [c] -> [c]
15:19:36 <_{^_^}__> someone asked me what the crowning difference between observer pattern and frp was
15:19:40 <haasn> :t join (zipWith (+) . tail)
15:19:41 <lambdabot> Num c => [c] -> [c]
15:19:43 <ion> tail again. :-P
15:19:44 <nan`> Peaker: just for style
15:19:46 <_{^_^}__> i couldn't answer and now im curious
15:20:01 <haasn> nan`: you have an awesome name! but don't let shachaf see
15:20:06 <Peaker> nan`, you could write a function like "maybe" for your type. IMO explicit pattern matching is nicer though
15:20:17 <Nik05> oh help what is zipWidth :p
15:20:29 <ion> @src zipWith
15:20:29 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
15:20:30 <lambdabot> zipWith _ _      _      = []
15:20:31 <Peaker> nan`, if the function *only* does pattern matching like "maybe" does
15:20:35 <nan`> Peaker: the function would need to take it as a parameter, though. Guards expect straight bool
15:20:38 <nan`> haasn: ? hah
15:20:54 <Fuuzetsu> _{^_^}__: ‘observer pattern’ usually means you're using a language completely not suited for it ;)
15:21:19 <Nik05> oh haasn thatnks got it
15:21:25 <Peaker> nan`, yeah it won't be a guard, guards don't do that
15:21:48 <ion> nik05: See my tadd', that uses pattern matching instead of tail.
15:22:08 <Nik05> so (zipWidth (+) xz (tail xs))
15:22:17 <Nik05> oh ok ion
15:22:31 <nan`> ok, how about this, a function that passes a value through a filter, and takes as an argument a binary function for combining the value as passed with the eventual result of the filter, monads ok
15:22:32 <hpc> _{^_^}__: a half-answer might be that a pattern is an unfactored abstraction
15:22:36 <merijn> Peaker: I upgraded to the new haskell platform and now I can't build the latest Lamdu revision :\ I'll run it again with -v3 to see if I can paste the error
15:22:52 <ion> nik05: And remember to compile with -Wall. You’ll get the appropriate warning about a missing pattern (that you wouldn’t if you use tail).
15:22:52 <Nik05> ion i dont get yours :P
15:23:04 <Nik05> ok
15:23:07 <Peaker> merijn, ok, the "newest" is the towards_get_field branch
15:23:14 <Nik05> -Wall -Wextra -Wpedantic -std=c++11 :D
15:23:20 <Peaker> significantly more advanced than master
15:23:32 <merijn> Peaker: I was trying to build master, I think. Lemme try that branch
15:24:05 <ion> The pattern xs@(_:ys) matched against 0:1:2:3:[] results in both xs and _:ys being 0:1:2:3:[] which means ys is 1:2:3:[], that is, [1,2,3]
15:24:41 <merijn> Peaker: The only error I get seems to be: "link(batch): upsweep (partially) failed OR Main.main not exported; not linking."
15:24:49 <Peaker> merijn, weird
15:24:58 <Peaker> never saw that one
15:25:04 <Peaker> in a clean build?
15:25:12 <merijn> Yeah
15:25:39 <ion> > let f xs@(_:ys) = (xs, ys) in f [0..5]
15:25:41 <lambdabot>   ([0,1,2,3,4,5],[1,2,3,4,5])
15:26:02 <Peaker> merijn, gotta go, can't help
15:26:04 <Nik05> ok thanks guys for help, will look into it again after some sleep
15:26:15 <Peaker> tomorrow (in 10-12 hours I can, maybe)
15:26:42 <merijn> Peaker: ok, no hurry
15:27:08 <nan`> :w
15:27:43 <luite> conal: hmm, the cache does contain GHC.Base.id
15:39:54 <nomeata> bos: Hi. I was just about to try to use Parser as a MonadFix instance, but it seems that instace was removed at some point. Why is that the case?
15:42:48 <bos> nomeata: i don't recall it ever being an instance?
15:43:24 <nomeata> Luckily we have VCS: http://hg.serpentine.com/haskell/attoparsec/rev/ebadc61c21c1 :-)
15:44:27 <Fuuzetsu> Someone actually uses mercurial?
15:44:56 <nomeata> Fuuzetsu: depending on your particular community, it might even be the default
15:45:08 <nomeata> e.g. most stuff related to Isabelle is in mercurial repostories
15:45:35 <Fuuzetsu> nomeata: Does it offer anything over git?
15:46:24 <nomeata> Fuuzetsu: the difference are small enough so that personal preference matters more
15:46:27 <chirpsalot> Fuuzetsu: I find that the interface for mercurial is a little nicer, but otherwise they are mostly equivalent. I think git is noticeably faster, if that matters.
15:46:43 * nomeata agrees.
15:47:49 <bos> nomeata: it looks for all the world like it disappeared by accident
15:47:52 <Fuuzetsu> Cool. I looked at darcs a while back and I don't think I'd be able to make a switch very easily…
15:48:26 <Fuuzetsu> ah, it's bos himself~ bos, that mercurial repository seems to have last been updated in 2009. Is there much point keeping it around?
15:48:28 <chirpsalot> Darcs won't install for me :C. It gets angry.
15:48:41 <nomeata> bos: probaby not a often-used feature, but right now it would be the perfect fit (parsing into a datastrcutre with a lots of tight knots)
15:48:45 <bos> Fuuzetsu: i didn't even know that host was still running
15:48:56 <bos> Fuuzetsu: i've long since migrated everything to bitbucket and github
15:49:06 <nomeata> Fuuzetsu: its what google turned up
15:49:14 <merijn> Hmm, looks like a fix for a C file as main was merged into cabal 6 months ago, but the cabal of the latest Platform is apparently to old?
15:49:29 <elliott> Fuuzetsu: bos wrote the book on Mercurial :p
15:49:43 <nomeata> and its search function is better than github’s, which does not find anything: https://github.com/bos/attoparsec/search?q=Monadfix&ref=cmdform
15:51:35 <bos> nomeata: you're welcome to revive the instance and send in a pull request, if you'd find it useful
15:52:11 <nomeata> bos: it would be too late for this project, but I’ll have a quick look
15:53:30 <merijn> argh
15:54:20 <merijn> afaict, my problem should've been fixed 6 months ago, but apparently something is broken on my system and causing it to not work :(
15:56:35 <Fuuzetsu> nomeata: Hmm, I would have imagined it would be possible to search diffs or something but I can't find anything on it. I think I'll have to ask around
15:56:59 <josephle> speaking of version controls, does anyone have a good link on the algebra of darcs?
15:58:02 <shachaf> Perhaps #darcs has.
15:58:34 <josephle> shachaf: I find a new channel everyday
16:02:05 <josephle> hmm, on a more haskell-related note, is there any documentation on what GHC does after compilation to the Core IR?
16:02:22 <shachaf> Beyond the commentary?
16:02:35 <josephle> shachaf: there's commentary?
16:03:20 <shachaf> @google what GHC does after compilation to the Core IR
16:03:20 <lambdabot> http://www.scs.stanford.edu/11au-cs240h/notes/ghc-slides.html
16:03:20 <lambdabot> Title: A Haskell Compiler
16:03:29 <shachaf> Ah, those slides were good too, if I remember correctly.
16:03:34 <shachaf> And they link to the commentary. :-)
16:04:14 <josephle> shachaf: thanks! I was trying to get into understanding ghc. I suspect madness lies down this path, though...
16:09:33 <nomeata> bos: hmm, I guess the instance got dropped because its tricky to create one in a continuation passing style monda
16:09:37 <nomeata> *monad
16:10:39 <bos> nomeata: that seems plausible, i wish the disappearance was more explicit :-(
16:15:00 <romanandreg> does anyone know how to use ghci with cabal sandbox, I'm really missing the cabal-dev ghci
16:15:38 <romanandreg> I tried doing "ghci -package-db .cabal-sandbox/conf.d -idist/build/autogen" with no luck
16:15:40 <romanandreg> :-/
16:19:26 * hackagebot prelude-safeenum 0.1.0 - A redefinition of the Prelude's Enum class in order to render it safe.  http://hackage.haskell.org/package/prelude-safeenum-0.1.0 (WrenThornton)
16:31:47 <L-a-g-o-s> !help
16:32:00 <Shamar> guys, what's the fastest way to locate a head over an emtpy list?
16:32:39 <shachaf> @where rts-xc might help
16:32:40 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
16:32:48 <shachaf> But, really, you should get in the habit of never using "head".
16:33:12 <Shamar> thanks shachaf
16:33:20 <Shamar> what are the alternatives?
16:33:28 <shachaf> Also, if you're asking about an error message, quote it exactly and put it in quotes. It took me a while to figure out what you meant.
16:33:46 <shachaf> What alternatives? I just gave you two good options.
16:33:49 <Shamar> sorry
16:34:40 <L-a-g-o-s> i have smtp trade with nailer or rdp if you have let deal
16:35:14 <shachaf> What?
16:35:16 <merijn> Shamar: Pattern matching instead of head
16:39:15 <shachaf> Shamar: Oh, sorry.
16:39:20 <shachaf> Shamar: Yes, you should use pattern-matching instead of head.
16:39:38 <kennethmosquera> check if something is a Char?
16:40:02 <Shamar> with such profiling options, ghc complains with this error "Could not find module `Prelude"  Perhaps you haven't installed the profiling libraries for package `base'?"
16:40:12 <no-n> why isn't head :: [a] -> Maybe a
16:40:18 <geekosaur> ...this is Haskell, you should know the type already
16:40:20 <shachaf> @ty maybeToList
16:40:22 <lambdabot> Maybe a -> [a]
16:40:31 <shachaf> @ty listToMaybe -- one of those
16:40:32 <lambdabot> [a] -> Maybe a
16:41:05 <Shamar> how can I install "profiling libraries for package base"?
16:41:19 <shachaf> It depends on how you installed GHC etc.
16:41:23 <shachaf> It's supposed to come with GHC.
16:41:35 <Shamar> apt-get install haskell
16:41:54 <Shamar> but libraries comes from cabal
16:42:03 <jmcarthur> base doesn't come from cabal-install
16:42:06 <jmcarthur> it comes with ghc
16:42:09 <shachaf> Debian doesn't have a package named "haskell".
16:42:15 <shachaf> So I wonder which distribution you're using that has it?
16:42:59 <Shamar> sorry, apt-get install ghc
16:43:12 <Shamar> now I'm installing ghc-proof
16:43:13 <shachaf> Maybe try installing ghc-prof, then?
16:43:17 <Shamar> now I'm installing ghc-prof
16:43:43 <Shamar> shachaf, right... sorry for my dumbness... :-)
16:44:25 <Fuuzetsu> If shachaf had a rifle capable of shooting online, we'd all be dead by now.
16:44:31 <Shamar> ehm... and for packages installed with cabal install?
16:44:41 <shachaf> @where cabal-cabal
16:44:41 <lambdabot> I know nothing about cabal-cabal.
16:44:48 <shachaf> @where sicp
16:44:48 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml | "Storage and Identification of Cabalized Packages"
16:44:54 <NihilistDandy> quchen: You around?
16:44:58 <geekosaur> you need to reinstall them after enabling cabal's profiling options
16:45:01 <shachaf> @where+ cabal-cabal http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
16:45:01 <lambdabot> I will never forget.
16:45:05 <quchen> NihilistDandy: Yes
16:45:07 <shachaf> Shamar: Read that page.
16:45:35 <Shamar> shachaf, thanks
16:45:41 <NihilistDandy> I was reading your article about installing the platform manually, and I wondered if you'd found a way to install the documentation in the same process
16:46:00 <elliott> isn't monochrom the one with the article about installing the platform manually?
16:46:18 <monochrom> yeah, http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
16:46:27 <monochrom> quchen has another one on his github
16:46:39 <NihilistDandy> I've been building everything from scratch for a few months to get the whole documentation stack, and I've been hoping for a better way to do it with the platform instead
16:46:58 <shachaf> If monochrom has an article about installed the platform manually, I recommend monochrom's article.
16:47:08 <quchen> Oh, I didn't know about monochrom's version. I basically rewrote my dirty text file to markdown and decided to upload it.
16:47:52 <monochrom> for "reinstall everything because no profiling", cabal-cabal.xhtml is best
16:48:07 <NihilistDandy> I've just skimmed monochrom's (also quite good), though it doesn't seem to offer any help on the documentation front when installing the platform
16:48:28 <monochrom> however, Haskell Platform build script already enables profiling. you have to ./configure --disable-profiling manually
16:48:44 <irene-knapp> you should have profiling anyway
16:48:45 <monochrom> it also already builds doc
16:48:45 <irene-knapp> heh
16:48:49 <irene-knapp> oh
16:48:49 <NihilistDandy> My current strategy is 1. Install GHC from bindist, 2. Grab Cabal from git, build, 3. cabal install everything in the platform
16:48:50 <tmiw> hi
16:48:55 <irene-knapp> this isn't -blah.  I shan't kibitz :)
16:49:17 <monochrom> "cabal install" is exactly why you have no profiling and no docs. cabal defaults.
16:49:24 <NihilistDandy> Actually, I suppose what I should say is that I want the doc-index file to include all the installed packages
16:49:38 <irene-knapp> you can change its defaults though, in ~/.cabal/config
16:49:49 <NihilistDandy> Currently, it only shows the ghc libs and the one's I've cabal'd
16:49:50 <irene-knapp> of course you have to do that before you install anything else if you want it to work
16:50:21 <monochrom> oh that's easy. the doc-index is updated every time you add a user package.
16:50:24 <NihilistDandy> transformers, for instance, does not show up in the index file
16:50:42 <NihilistDandy> The documentation has been generated, it's just not linked into the index
16:50:52 <monochrom> "updated" means it also takes global package docs into account
16:51:02 <monochrom> (if you have them)
16:51:21 <quchen> NihilistDandy: Hm. Well I don't know where all the docs are. I just generate them for the worst case scenario.
16:51:28 <quchen> (i.e. Hoogle/Hackage down)
16:51:33 <NihilistDandy> Actually, scratch that, the docs weren't generated
16:51:34 <monochrom> I keep around a dummy package to "cabal install --user --enable-documentation dummy" for updating the doc index
16:51:41 <monochrom> well there you go
16:52:06 <monochrom> I have verified and tested everything, so just believe me.
16:52:33 <NihilistDandy> So, that brings me back to my original question: is there a way to configure the platform so that it will generate the docs?
16:52:46 <monochrom> I keep around that dummy package because sometimes I put packages into --global
16:52:53 <merijn> Man, don't you hate it when software maintainers aren't at your beck and call 24/7? >.>
16:53:00 <quchen> NihilistDandy: Pass --enable-documentation when building?
16:53:14 <monochrom> Haskell Platform build script already builds docs
16:53:14 <NihilistDandy> Tried. Unfortunately, it's not a recognized flag
16:53:53 <NihilistDandy> Well, it didn't, so I think I have a counterargument
16:54:15 <monochrom> I just tried it earlier today and it built docs
16:54:29 <quchen> monochrom: I just have text files in my platform doc dir
16:54:36 <NihilistDandy> I used the procedure explained on your page. I don't have them.
16:54:39 <quchen> (Licenses basically)
16:54:40 <NihilistDandy> Just LICENSE files
16:55:01 <quchen> Hm. Looks like I forgot about that and never got bitten by it.
16:55:15 <NihilistDandy> I'm curious as to why, but in the meantime I guess I can go back to my usual system
16:55:44 <NihilistDandy> It's not a huge issue, it's just something that struck me as odd
16:56:21 <quchen> I guess I'll keep an eye open for that.
16:56:43 <quchen> Last time I needed local docs was on a plane half a year ago, so I never really noticed they were missing.
16:57:05 <NihilistDandy> I like to read docs locally. Just a preference
16:57:08 <quchen> (And that was for some non-standard package, so Cabal built it for me)
16:57:21 <Shamar> what does "/usr/bin/ld: cannot find -lHSsplit-0.2.2_p" means?
16:58:39 <monochrom> Haskell Platform build script also skips packages you already have
16:58:57 <hpc> Shamar: have you been giving linker flags to ghc or cabal?
16:59:09 <monochrom> "cabal install mtl" and then "./configure; make; make install" will not get you mtl docs. mtl is not re-built.
16:59:49 <NihilistDandy> I wiped my ghc dir, .ghc, and .cabal beforehand
17:00:03 <Shamar> hpc, I'm using this flags -prof -fprof-auto -rtsopts -osuf .p_o
17:00:29 <Shamar> but, ehm... actually... I don't know what they means... :-)
17:00:53 <Shamar> (I just want to fix a broken "head" call... :-()
17:01:17 <hpc> Shamar: -prof says compile with profiling, -fprof-auto says to automatically assign cost points, -rtsopts enables runtime options (necessary for profiling)
17:01:23 <hpc> -osuf changes the file extension of the output
17:01:25 <NihilistDandy> Did you build HSSplit with profiling?
17:08:42 <Shamar> now I'm getting "Warning: 'ghc-options: -prof' is not necessary and will lead to problems when
17:08:42 <Shamar> used on a library. Use the configure flag --enable-library-profiling and/or
17:08:42 <Shamar> --enable-executable-profiling."
17:12:18 <kennethmosquera> how could i check if a polymorphic variable is a char?
17:12:42 <Hafydd> kennethmosquera: why?
17:13:20 <hpc> kennethmosquera: if you know it's a char, it's a char
17:13:25 <hpc> kennethmosquera: the compiler checks, not your code
17:14:43 <monochrom> NihilistDandy: the build script calls "Setup haddock --hyperlink-source", therefore absence of hscolour fails it
17:14:58 <monochrom> and quchen too
17:15:17 <kennethmosquera> trying to build a function that deletes duplicates but '\n'
17:15:41 <jmcarthur> kennethmosquera: chars don't carry around type information at runtime. there are ways to carry around type information at runtime, but you might as well just know what the type is anyway
17:15:52 <johnw> kennethmosquera: then your function will need to be [Char] -> [Char]
17:16:26 <NihilistDandy> monochrom: Ah, that could be it, then. Is there a workaround for that?
17:16:33 <kennethmosquera> i want to keep the function with polymorphic variable
17:16:40 <kennethmosquera> *wanted
17:16:44 <jmcarthur> kennethmosquera: why? it will only work for chars anyway
17:16:57 <monochrom> edit scripts/build.sh, comment out HADDOCK_FLAG="--hyperlink-source"
17:17:51 <NihilistDandy> I'll give it a shot. Thanks for looking into it.
17:18:37 <kennethmosquera> ok.. ..
17:18:49 <kennethmosquera> just being picky
17:18:51 <jmcarthur> kennethmosquera: maybe a more productive question is: what should your function do if it finds that you gave it something that isn't a char?
17:19:44 <kennethmosquera> find duplicates if is a Int list etc lists
17:20:30 <jmcarthur> so the reason you want to see if it's a char is just so you can do this special case check against '\n'?
17:21:12 <kennethmosquera> yes
17:21:30 <johnw> kennethmosquera: the way that Haskell can do what you're asking (although, I'm not sure what you're asking is a good idea), is to make a type class called "HasNewline", with a method "isNewline" with a default of False.  Then you can make a function HasNewline a => [a] -> [a], and an instance HasNewline char where isNewline = (== '\n').  But then you'll have to make an instance for every single type you're ever going to pass to this
17:21:31 <johnw> function.
17:21:41 <jmcarthur> maybe you could decompose your function into two separate functions, one of which is specialized to chars and the other of which is not
17:22:05 <johnw> plus you'll need to have an Eq a constraint in your type class definition
17:22:07 <johnw> it gets very messy
17:22:49 <jmcarthur> e.g., your dedup function could be something like   Eq a => [Maybe a] -> [Maybe a],  where Nothing would stand in place of the things you don't want to dedup. then you could compose that with a function that wraps every element in Just except for '\n' (which is replaced by Nothing)
17:22:58 <jmcarthur> and then at the end you convert everything back into Chars
17:23:30 <kennethmosquera> better write two functions
17:23:40 <johnw> yes, I think so
17:24:12 <blackdog> does anyone know the right way to deal with UTF8 in web pages?
17:24:23 <blackdog> looking at the functions in http-conduit, they all seem to return lazy bytestrings
17:25:00 <johnw> :t Data.Text.Encoding.decodeUtf8
17:25:01 <lambdabot> BSC.ByteString -> Data.Text.Internal.Text
17:25:11 <johnw> :t Data.Text.Lazy.Encoding.decodeUtf8
17:25:13 <lambdabot> BSLC.ByteString -> Data.Text.Lazy.Internal.Text
17:25:37 <jmcarthur> blackdog: http://hackage.haskell.org/packages/archive/conduit/0.0.1.1/doc/html/Data-Conduit-Text.html#v:decode  ?
17:27:44 <Hafydd> kennethmosquera: although I don't really recommend it, you could also do something like this: http://hpaste.org/88849
17:28:37 <johnw> yeah, that kind of a hack to avoid writing two functions isn't worth it
17:28:43 <johnw> it will just confuse any Haskeller who reads your code in future
17:28:52 <johnw> and you have to write two functions!
17:30:41 <Hafydd> Yeah, they don't call them IncoherentInstances for nothing.
17:31:00 <blackdog> johnw: hm, ok. so i should be manually checking the charset in the headers, then decoding to the appropriate charset, then presumably converting to utf8?
17:31:24 <kennethmosquera> lol
17:33:00 <johnw> blackdog: yes
17:33:59 <johnw> i'm surprised there's not a higher-level function to do all of that for you
17:34:17 <blackdog> johnw: yes, me too.
17:35:07 <johnw> sounds like a library opportunity to me.  http-conduit-text!
17:40:29 <mike300> how i generate a Map using a specific data? maybe a function like df :: [Car] -> Map a [(a , Float)] ?
17:40:52 <johnw> either: generate a list, and call fromList
17:40:53 <geekosaur> :t M.fromList
17:40:54 <lambdabot> Ord k => [(k, a)] -> M.Map k a
17:40:58 <johnw> or fold using insert
17:41:24 <dmwit> Map a [(a, Float)] is a very strange type.
17:41:30 <dmwit> I don't believe in it.
17:42:37 <mike300> i try something like this:
17:42:40 <mike300> df g = fromListWith (++) $ g >>=
17:42:40 <mike300>                  \(a,b,c,d) -> [(a,[(b,c)])]
17:43:01 <mike300> considering my Car data like (a,b,c,d)
17:43:10 <mike300> but i think this is wrong
17:43:21 <mike300> oh yeah its wrong
17:43:33 <dmwit> Why do you think it's wrong?
17:43:37 <mike300>    Couldn't match expected type `Car'
17:43:38 <mike300>                 with actual type `(t0, t1, t2, t3)'
17:43:48 <mike300> i give this error on ghc
17:43:59 <dmwit> Perhaps you would like to pattern match on a Car instead of a tuple if Car is not a type alias for a tuple.
17:44:12 <dmwit> If you want more specific advice,
17:44:19 <dmwit> ?hpaste enough code that we can reproduce your error
17:44:19 <lambdabot> Haskell pastebin: http://hpaste.org/
17:44:20 <mike300> data Car = Car Char Char Float Float
17:44:58 <mike300> my code is just what i wrote
17:45:07 <dmwit> You can match like this: \(Car a b c d) -> ...
17:47:13 <mike300> i give another error
17:47:25 <mike300> Couldn't match type `a' with `Char'
17:47:25 <mike300>       `a' is a rigid type variable bound by
17:47:25 <mike300>           the type signature for adjacentNode :: [Car] -> Map a [(a, Float)]
17:47:48 <mike300> with  \(Car a b c d) -> [(a,[(b,c)])]
17:48:36 <mike300> i change the function name to adjacentNode
17:51:56 <dmwit> mike300: Your type signature claims you can return a Map with any type of keys, but you can't. You can only return a Map with Char keys.
17:52:26 <copumpkin> I always forget the char keys
17:52:47 <dmwit> (Similarly, you can't return a map with lists of tuples with anything in the first part, only lists of tuples with Char in the first part.)
17:53:03 * dmwit engages troll mode
17:53:10 <dmwit> "You forgot to put a ~ Char in your context."
17:53:24 <kennethmosquera> edit printed terminal ?
17:53:48 <dmwit> kennethmosquera: I don't understand the question.
17:54:04 <kennethmosquera> like a terminal text editor
17:54:29 * hackagebot memoize 0.6 - A memoization library  http://hackage.haskell.org/package/memoize-0.6 (JesseTov)
17:54:55 <dmwit> vim and emacs are favorites.
17:55:39 <dmwit> I think I still don't understand.
17:56:01 <mike300> changed to Map Char [(Char,Float)] morks
17:56:05 <mike300> *works
17:56:20 <kennethmosquera> lets say putStrnLn "edit me"
17:57:07 <kennethmosquera> the line gets printed and you edit it in terminal and then send it back as getLine
17:57:44 <geekosaur> didn't we go through this before? dependoing on what exactly you want it's readline or one of the curses bindings
17:57:47 <blackdog> johnw: i just released robots-txt because it didn't exist yet - i think my boss might get a bit cranky if i launched into another open source project without providing extra features for the app :)
17:57:55 <dmwit> Perhaps you want to use curses, ncurses, readline, or just '\b'.
17:57:58 <geekosaur> or are you still expecting that every program can dig in its encosing terminal and find what it output
17:58:42 <geekosaur> if you putStrLn something, it is *gone*.
17:58:58 <geekosaur> no longer under control of your program, no longer accessible to your program.
17:59:21 <geekosaur> there are other things you could do which would let your program still "have" it in some way
17:59:46 <no-n> like what
17:59:59 <dmwit> Like store it in memory.
18:00:05 <dmwit> Stick it in a ref cell or a closure.
18:00:17 <elliott> <kennethmosquera> how could i print something on terminal and make it editable? [...] <kennethmosquera> edit a print on terminal? [...] <kennethmosquera> edit printed terminal ?
18:00:17 <dmwit> Or emulate a terminal. =)
18:00:24 <elliott> it seems monochrom's compression hypothesis holds true
18:00:37 <geekosaur> use something like vty or an ncurses interface which has an image of the terminal contents in memory at all times
18:00:49 <geekosaur> so it does
18:01:10 <dmwit> I wonder whether there's any sadistic terminals out there that choose to censor each character with, say, a 1/10 chance. Or something like that.
18:01:14 <geekosaur> also the nice complete lack of comprehension at the answers, since they jeep coming back
18:01:17 <geekosaur> *keep
18:01:27 <dmwit> Well, that part may be excusable.
18:01:34 <dmwit> It seems like English is not kennethmosquera's first language.
18:01:45 <dmwit> Isn't there a #haskell-br or something like that, though?
18:02:15 <dmwit> (They speak Portuguese in Colombia, right?)
18:02:23 <tabemann> Spanish
18:02:25 <kennethmosquera> colloquy ...
18:02:39 <kennethmosquera> used my name..
18:03:19 <dmwit> kennethmosquera: /join #haskell.es ?
18:03:34 <dmwit> ...a bit empty =P
18:03:35 <dmwit> never mind
18:03:37 <kennethmosquera> rather lonely
18:04:15 <elliott> anyway, if you don't understand the answers, then you should ask and we can help explain them better. asking again just leads to the same unhelpful answers :P
18:04:15 <kennethmosquera> ok have a good night
18:04:29 * hackagebot egison 3.0.6 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-3.0.6 (SatoshiEgi)
18:04:51 <kennethmosquera> yeah i am going to take a look at ncurses
18:05:10 <kennethmosquera> it just hooks… not nice but well..
18:05:33 <geekosaur> ncurses is pretty bad, actually. vty/vty-ui might be preferable
18:11:23 <dmwit> huh
18:11:30 * geekosaur is used to curses' foibles by now, but that's after years of use. and, well, there's always been the story that Bill Joy called it Curses for a reason
18:11:32 <dmwit> vty is a pure-Haskell implementation of one of the VT specs?
18:11:33 <dmwit> neat
18:11:42 <elliott> I don't think it follows much of a spec
18:11:47 <elliott> probably just "what xterm does" :)
18:11:53 <dmwit> yes, well
18:16:06 <mike300> how i remove the smallest element of the type Map Char [(Char,Float)] considering the Float value inside the value of the element ?
18:16:33 <dmwit> There is no better way than iterating through the entire map.
18:16:39 <dmwit> Use a different data structure if you need to do that a lot.
18:17:04 <dmwit> (For example, a priority queue.)
18:18:00 <mike300> how i implement a priority queue?
18:18:07 <dmwit> You don't. =)
18:18:10 <dmwit> You take one from Hackage.
18:18:19 <mike300> haha nice
18:18:22 <dmwit> http://new-hackage.haskell.org/packages/find?name=priority
18:18:58 <elliott> beware! those are all written by people who ignore dmwit's advice
18:19:02 <geekosaur> priority queues and priority search queues are "interesting" eenough that it's far preferable to use someone else's well tested implementation
18:19:57 <dmwit> elliott: hahaha
18:21:01 <mike300> how i do iteranting in the map ?
18:21:22 <mauke> convert it to a list
18:21:34 <mike300> because i don't know how to return the key
18:21:47 <dmwit> It's an instance of Foldable.
18:22:10 <dmwit> Or use assocs or similar, as mauke suggests.
18:23:05 <dmwit> Oh, there's also foldrWithKey.
18:23:49 <dmwit> ...and FoldableWithKey from the keys package.
18:23:52 <dmwit> so many ways to do it!
18:24:32 <dmwit> I think I should use the keys package more.
18:24:32 <mm_freak> how do i get type-level string literals again?
18:24:35 <mike300> foldrWithKey looks interesting
18:25:00 <elliott> dmwit: lens sort of obsoletes keys.
18:25:05 <elliott> (cue "and every other package")
18:25:17 <dmwit> oh
18:25:29 <dmwit> ...really?
18:25:54 <mm_freak> ah, got it:  GHC.TypeLits
18:26:45 <elliott> dmwit: there's the IndexedFoo stuff and the typeclasses in uh, Control.Lens.Indexed or somewhere
18:27:08 <mm_freak>     Cons :: forall a as (f :: Symbol). a -> Tuple as -> Tuple ('(f, a) ': as)
18:27:17 <mm_freak> haskell isn't that far away from dependent types =)
18:27:38 <mike300> i tried something i take on the web and changed some things
18:27:48 <mike300> i defined
18:27:56 * tabemann tries to parse that type expression and fails
18:28:05 <mike300> minimum' :: Map Id (Id, Float) -> Id
18:28:05 <mike300>      minimum' = fst . (minimumBy comp) . Data.Map.toList
18:28:05 <mike300>     where
18:28:05 <mike300>       comp (_, (x, _)) (_, (y, _)) = compare x y
18:28:31 <mike300> but i receive Map Id [(Id, Float)] as param
18:28:42 <mike300> and this give me an error
18:29:29 * hackagebot yesod-paginator 0.4.0 - A pagination approach for yesod  http://hackage.haskell.org/package/yesod-paginator-0.4.0 (PatrickBrisbin)
18:29:38 <dmwit> mike300: For pastes longer than one line, please use hpaste.org (or a similar pastebin) in the future.
18:29:55 <mike300> ok
18:30:22 <dmwit> Also, perhaps you should try running through a tutorial.
18:30:36 <dmwit> Knowing how to write a function that consumes lists is a pretty basic skill.
18:31:42 <mike300> i am learning haskell
18:32:54 <Clint> aren't we all
18:33:17 <geekosaur> @where lyah
18:33:18 <mike300> if you could write a function who do that i would be grateful dmwit
18:33:18 <lambdabot> http://www.learnyouahaskell.com/
18:33:33 <mike300> i am reading this book
18:34:30 * hackagebot yesod-markdown 0.8.0 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.8.0 (PatrickBrisbin)
18:34:37 * tabemann never got the, um, unique syntax used in the title of that book
18:36:31 <Cale> mike300: Does the function you wrote not typecheck? (I haven't really thought about it or tried it) Or are you looking for a similar function which works for that other type?
18:39:33 <mike300> i don't understand your question Cale
18:39:57 <adnap> Can I pass an argument to GHCI on the command line that will be immediately interpreted when GHCI runs?
18:40:09 <Fuuzetsu> adnap: you can put things in .ghci
18:40:25 <adnap> I mean somthing like "ghci "2 + 2""
18:40:42 <dmwit> you can ghc -e "2 + 2"
18:40:46 <dmwit> but you won't be in a REPL afterwards
18:41:51 <Cale> mike300: I was asking what you were actually asking about.
18:42:26 <adnap> Does -e invoke the interpreter? The man page just says "evaluate"
18:42:49 <Cale> adnap: try it?
18:42:57 <adnap> Cale: I did
18:42:58 <Cale> adnap: It does what it says on the tin
18:43:00 <tabemann> what's the difference if it does or does not - it *does* execute it
18:43:01 <dmwit> I'm pretty sure it does. But does it really matter whether it interprets or compiles?
18:43:06 <adnap> Yeah
18:43:14 <adnap> Not practically, but I want to know what's going on
18:43:41 <dmwit> Pretty sure it interprets your code, yes.
18:44:06 <adnap> The reason is so I can make an inference about GHCI based on the result of ghc -e
18:44:30 * hackagebot unix-bytestring 0.3.6 - Unix/Posix-specific functions for ByteStrings.  http://hackage.haskell.org/package/unix-bytestring-0.3.6 (WrenThornton)
18:44:36 <dmwit> There may be different results between -e and ghci.
18:44:46 <dmwit> What with extended defaulting and all that.
18:45:18 <geekosaur> it's using the same backend but the language options and such may differ, and in particular I suspect ghc -e doesn't read .ghci
18:45:46 <Cale> You could always look at the ghc source :)
18:46:06 <hasone> hello!
18:46:08 <shachaf> ghc -e reads .ghci
18:46:22 <NemesisD> any of you guys have experience transferring project maintainership? i'm about to take over a project and i'm wondering whether i need to set up an organization on github or just have the maintainer just send me the project directly
18:47:28 <dmwit> That seems like it's very much up to you.
18:48:07 <hasone> i'm new to haskell and I'm trying to get htf to play nice and i'm really frustrated.
18:48:20 <Fuuzetsu> Ask your question.
18:49:49 <fluffynukeit> hi all.  Is there a way for me to unpin a ByteString in memory?  I think my program is suffering from heap fragmentation because I have many small bytestrings, and they are pinned so GC can't move them nicely.
18:50:17 <Ralith> why do you think your program is suffering from heap fragmentation?
18:50:18 <shachaf> fluffynukeit: ByteStrings are just allocated by calling malloc() via the FFI.
18:50:25 <shachaf> They won't move.
18:51:11 <tabemann> they're *supposed* to be pinned, because there's a function that, in the FFI, can directly convert a strict ByteString to a Ptr without copying
18:51:28 <fluffynukeit> I think the memory is fragmented because the memory usage in the Task Manager is much higher than the memory usage in the profiler graph (more than just profiling overhead and such).
18:51:49 <fluffynukeit> Task manager has 80+ MB, while the profiler says 22 MB.
18:52:32 <hasone> let's say i want to test a function that takes an arbitrary number.
18:52:50 <fluffynukeit> So is there any way I can unpin a bytestring to test my hypothesis, or failing that, some alternative to BS that is unpinned?
18:52:55 <hasone> i have prop_fun :: Num -> Bool
18:53:05 <tabemann> Num is a type class, not a type
18:53:18 <tabemann> what you want is prop_fun :: Num a => a -> Bool
18:53:26 <adnap> dmwit: Thanks
18:53:29 <dmwit> fluffynukeit: Perhaps there is a way to deep copy ByteStrings.
18:53:54 <dmwit> fluffynukeit: Then you could deep copy all the ByteStrings you have hanging around and let the garbage collector deal with the old ones.
18:54:01 <dmwit> But... it seems kind of like a hack to me.
18:54:43 <fluffynukeit> dmwit: anything that keeps unnecessarily large amounts of memory reserved is something I'll try.  Do you know of a deep copy?
18:55:51 <dmwit> I dunno. cons <$> uncons bs ?
18:56:05 <dmwit> uncurry cons <$> uncons bs, I mean
18:56:17 <tabemann> There's copy for ByteStrings
18:56:40 <tabemann> checked hackage and it says that copy :: ByteString -> ByteString creates a new ByteString with its own storage
18:56:48 <dmwit> You mean fluffynukeit asked me this before checking the documentation??
18:56:51 <dmwit> booooo
18:57:08 <fluffynukeit> I am using copy already.  I don't think it works for this case
18:57:53 <dmwit> extraordinary claims, extraordinary evidence, et.c
18:58:52 <fluffynukeit> Copy is used for shrinking the tail of the bytestring allocation e.g. your bytestring is only 10 bytes long but you have 64k bytes allocated for it.  I need something that unpins the BS so the GC can get the heap compacted better.
18:59:46 <fluffynukeit> I am pretty liberally using copy as it stands to fix my over-allocation problem, but the fragmentation issue (if that's the problem) is still there
19:00:15 <tabemann> the problem is that all bytestrings are pinned by design
19:00:29 <dmwit> Perhaps I have been misunderstood.
19:00:42 <fluffynukeit> I'm open to an unpinned alternative to BS, if possible
19:00:50 <hasone> i'm trying to get quickchek (via htf) to select arbitrary numbers and then test for an equality. defining my property as type (Eq a, Num a) => a -> Bool won't do it, will it? is there any way to make htf automagically grab numbers for me?
19:00:56 <dmwit> My proposal is that, at some point in your program after doing a bunch of stuff, you do a pass over *all* your bytestrings, deep copying them.
19:01:07 <koninkje> fluffynukeit: what about Data.Text?
19:01:19 <dmwit> Because this calls malloc, and malloc generally returns contiguous memory on subsequent calls, this should result in all of the deep copies being contiguous in memory. Roughly.
19:01:25 <koninkje> fluffynukeit: ...assuming you're dealing with text rather than bytes
19:01:46 <fluffynukeit> koninkje: thanks for the suggestion, but I am dealing with bytes
19:01:57 <dmwit> Calling copy on arbitrary individual ByteStrings at arbitrary points in your program likely won't help much.
19:02:41 <fluffynukeit> dmwit: hmm I understand your suggestion I think. What should I keep in mind when deciding when to do this batch copy?
19:02:42 <koninkje> in that case, the only option really is to collect all the bytestrings, allocate a large hunk for their concatenation, and then split it
19:03:15 <dmwit> Ah, that's much better. Less hacky. I like it.
19:04:03 <koninkje> fluffynukeit: as for scheduling the manual compactification, probably the same as other times for doing manual GC: when there's lots of garbage and things will be consistent for a while
19:04:30 * hackagebot ghc-mod 2.0.3 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-2.0.3 (KazuYamamoto)
19:05:13 <koninkje> also, you needn't concatenate all the bytestrings into a single hunk; if there's a fair deal of churn, then you may want to consider doing it in "pages" ---or if you know the approximate lifetimes, then in regions
19:05:52 <fluffynukeit> dmwit, koninkje thank you for your suggestions.  I will try them out and hope they improve things
19:06:43 <koninkje> if you get something that works and is fairly tidy, it'd make for a good package
19:06:49 <mike300> I think a little about my question, see my code and now i know what i want to do. My function receive a list of keys q, and I need to found in the original Map who is the key contained in q who have the minimum value on the field Float, being that i have a Map Id (Id,Float)
19:07:09 <tabemann> ack... HOpenGL doesn't seem to support glUniformMatrix*fv
19:07:45 <dmwit> Why (Id, Float) instead of Float?
19:08:31 <tabemann> because he needs the key, not just the minimum value
19:09:36 <dmwit> So?
19:13:19 <tabemann> welp, time to rewrite my code to use HOpenGLRaw
19:26:31 <jkarni> anyone familiar with automatic derivations for data.binary or data.serialize?
19:27:32 <jkarni> I get some fairly mysterious warnings and errors when trying to derive either for some types
19:29:01 <dmwit> ?hpaste code and errors
19:29:01 <lambdabot> Haskell pastebin: http://hpaste.org/
19:30:26 <jkarni> http://hpaste.org/88855
19:30:43 <jkarni> these are the warnings when deriving generic
19:31:09 <jkarni> I feel like I kind of understand what they say, but not at all why
19:33:57 <dmwit> code pls
19:35:00 <jkarni> so it's just "instance Generic (Gr a Int)"
19:35:20 <jkarni> where Gr is the fgl tree graph
19:35:26 <jkarni> http://hackage.haskell.org/packages/archive/fgl/5.4.2.4/doc/html/src/Data-Graph-Inductive-Tree.html#Gr
19:35:26 <dmwit> Don't you normally derive instances of Generic?
19:35:40 <jkarni> I'm importing Gr
19:35:46 <dmwit> StandaloneDeriving
19:37:10 <tabemann> okay very stupid question - I can't remember what keyword to use when importing modules when I want to exclude something
19:37:19 <johnw> hiding
19:37:28 <tgeeky> tabemann: there are no stupid questions, only stupid people asking them. You are safe, for now!
19:37:52 <tabemann> thanks
19:38:33 <tgeeky> tabemann: for future reference, haskell keywords: http://www.haskell.org/haskellwiki/Keywords
19:38:38 <jkarni> dmwit: data constructors not all in scope...
19:38:46 <jkarni> they aren't exported
19:39:01 <dmwit> I'm pretty sure you're out of luck, then.
19:39:03 <zRecursive> what's the canconical way to run a term program and get its output ?
19:39:20 <tabemann> term program?
19:39:33 <jkarni> ugh
19:39:34 <jkarni> thanks
19:39:41 <johnw> runProcess is the most "standard" way, but I prefer to use Shelly
19:39:45 <zRecursive> no UI, i.e. run in xterm
19:39:57 <dmwit> jkarni: I mean, you can implement the functions of the Generic class yourself.
19:40:09 <dmwit> But you can't just write "instance Generic (Gr a b)".
19:40:17 <tabemann> well you can always do foo > bar if it isn't interactive
19:40:42 <jkarni> yeah, what gave me hope was that it was compiling, just with warnings
19:40:42 <zRecursive> johnw: how about runInteractiveProcess ?
19:40:57 <johnw> never used it
19:41:01 <dmwit> You can't possibly hope for it to do something good without writing code...
19:42:40 <jkarni> but that's really unfortunate - that if a library doesn't export the constructors and doesn't derive generics itself, you're out of luck, even though the solution is so close...
19:42:58 <elliott> well, many libraries want to maintain data abstraction
19:43:34 <dmwit> If the abstraction doesn't provide the operations you want, I'd be really upset if writing "instance Generic" all by its lonesome gave you those operations.
19:43:55 <jkarni> (Standlone deriving also works fine, and you can use it for types you have not defined yourself, but are imported from somewhere else.)
19:43:58 <dmwit> You'd be breaking some serious boundaries, possibly invalidating carefully-maintained invariants.
19:44:01 <jkarni> from the haskellwiki
19:44:15 <jkarni> on ghc.generics
19:44:32 <dmwit> If there's some operation you need that's missing, well, with a library as complete as fgl there's probably a reason it's missing.
19:45:58 <jkarni> dmwith/elliott: do you mean deriving clauses themselves are breaking the abstraction layer? I don't see that
19:46:08 <jkarni> sure, keep the operations unexported
19:46:40 <jkarni> but if automatic deriving for something comes along and needs to look at the constructors, I'm not sure that's the same case
19:46:43 <dmwit> No, deriving clauses don't break the abstraction layer, because when the appropriate things aren't exported you can't derive anything. =)
19:47:06 <jkarni> hehe, sure
19:47:19 <dmwit> I'm saying that if deriving worked despite not having the constructors, that YES that would be breaking an abstraction layer.
19:47:35 <jkarni> yeah, I *kind* of see that
19:48:10 <jkarni> but also think the abstraction was more likely not there with that goal in mind
19:48:21 <dmwit> disagree
19:50:38 <jkarni> I certainly wouldn't have thought of either exporting the constructor or deriving generic before
19:51:18 <dmwit> But if you didn't export what was needed to implement Generic, I bet you also would not want to provide a Generic instance.
19:52:14 <jkarni> I would likely not even have thought of whether someone wanted to make a binary or serializable instance of it
19:52:26 <dmwit> You're not picking up what I'm putting down.
19:52:30 <jkarni> maybe not
19:52:49 <jkarni> do you mean with generic you can loop around the abstraction?
19:52:58 <dmwit> If you thought about your API and what you wanted to provide, and then later somebody asked whether you should provide a Generic instance, one way you could answer that would be by asking, "Can it be implemented with what I already provided?".
19:53:30 <jkarni> ok, it can
19:53:41 <jkarni> so what, though?
19:53:58 <dmwit> eh?
19:53:59 <jkarni> everything they wrote can be implemented with nothing at all provided
19:54:04 <jkarni> just rewrite the library
19:54:28 <tgeeky> jkarni: that solutions is available to anyone without contacting the author
19:54:41 <dmwit> Who is "they"?
19:54:43 <tgeeky> s/solutions/solution/
19:55:07 <jkarni> but I now have to have a much better sense for how the graph is represented so I can serialize it
19:55:18 <jkarni> when the point kind of was to keep me naive and ignorant
19:55:31 <dmwit> no
19:55:36 <jkarni> (or more positively, let me focus on other things)
19:55:39 <dmwit> My point is that you *don't* have to know how it's represented.
19:55:47 <jkarni> how so?
19:55:59 <dmwit> You've got an API. If it provides enough stuff to serialize it, you can serialize it.
19:56:04 <dmwit> No poking around in the internals at all.
19:56:13 <jkarni> but it doesn't
19:56:37 <dmwit> If it doesn't provide enough stuff to serialize it, then *even had the author thought about serializing* it still wouldn't be possible.
19:56:54 <dmwit> (Under the assumption that the author has been thoughtful about what things to include and intentionally exclude to begin with.)
19:57:04 <dmwit> *That* is my point.
19:57:08 <jkarni> yeah, but that's the assumption I'm questioning
19:57:49 <tgeeky> what package are we talking about? I'll ejudicate on the thoughtfullness of the author
19:57:59 <jkarni> haha, now I'm in trouble
19:58:00 <jkarni> fl
19:58:02 <dmwit> Are you arguing that the current graph API does not make it possible to serialize graphs, and furthermore that with some thought an extended API could allow that without breaking abstraction barriers?
19:58:03 <jkarni> fgl
19:58:07 <dmwit> Because I find the first part very wrong.
19:58:19 <tgeeky> haha. Martin Erwig? You're screwed. He's pretty thoughtful.
19:58:53 <jkarni> I just wonder whether the abstraction layer should have this single standard
19:58:54 <jkarni> i.e.
19:59:12 <jkarni> either export the constructor and get automatic deriving
19:59:16 <dmwit> Likewise, are you arguing that the current graph API does not make it possible to create a Generic instance for graphs, and furthermore that with some thought an extended API could allow that? Because I find the first very unlikely, and even if you convince me that it's true I find the latter even unlikelier still. The fgl API is very complete with respect to what you could hope to want.
19:59:17 <jkarni> or get neither
19:59:28 <dmwit> jkarni: Yes, it definitely should.
19:59:57 <dmwit> My point being that there's no reason to believe serialization you would get from the derived instance would preserve the abstraction boundary.
20:00:06 <jkarni> again, I don't mean to criticize fgl or martin erwig
20:00:10 <dmwit> Whereas if you force somebody to write some code for the serialization that uses the API, you do get that guarantee.
20:00:42 <tgeeky> I think GHC.Generics was implemented pretty late after fgl was constructed
20:00:46 <jkarni> yeah, I know, but the abstraction boundary isn't that strict to being with, is it? I mean, if I really wanted the constructor, I could just copy the code and change the exports
20:00:58 <jkarni> surely we shouldn't hide the source?
20:01:22 <jkarni> likewise, not exporting the constructor makes it clear the author thinks you shouldn't use it
20:01:26 <elliott> if I don't export something from a module, nobody else should be able to get at it. this isn't just some pedantic point: if it is broken, type safety goes out the window
20:01:49 <dmwit> jkarni: No, you should not be allowed to make my code crash just because you want convenience.
20:02:29 <zRecursive> @hoogle waitForProcess
20:02:29 <lambdabot> System.Process waitForProcess :: ProcessHandle -> IO ExitCode
20:03:26 <jkarni> elliott: could you elaborate?
20:03:55 <elliott> jkarni: many modules implement a safe API by unsafe means
20:04:15 <elliott> if you could go beyond that API, you could write code importing a safe module, doing a safe derivation, and then getting a broken type system out of it
20:04:27 <jkarni> fair enough
20:05:40 <jkarni> dmwit: in the best case scenario I think you're right
20:06:22 <jkarni> but again, as mentioned before, fgl antedates automatic generic/binary deriving
20:06:40 <jkarni> hard to have had that particular case in mind...
20:06:53 <dmwit> The question at hand is this: can you implement Generic with the API that exists?
20:07:03 <tgeeky> jkarni: you should just e-mail Martin with your concerns. You'll get a very thoughtful reply in two days.
20:07:14 <dmwit> If so, petition to have a Generic instance added, perhaps by deriving or perhaps by the code you wrote.
20:07:36 <dmwit> If not, I expect you will find that this is because Generic allows you to violate some internal assumptions of the graph type.
20:07:49 <jkarni> thanks - Gr implements show, so it's fine, of course
20:09:04 <jkarni> and I now get there are fairly good reasons for not giving a side-door for automatic deriving into the code
20:09:13 <jkarni> but at first it seemed pretty strange to me
20:11:49 <hasone> okay, I'm trying to test the doubleMe function (from learrn you a haskell  (doubleMe x = x+x) with quickcheck just to get a feel for quickcheck. it's been hours and I can't figure out how to do this.
20:12:08 <dmwit> Yikes!
20:12:17 <dmwit> What have you tried, and what error did you get?
20:12:19 <dmwit> ?hpaste
20:12:19 <lambdabot> Haskell pastebin: http://hpaste.org/
20:12:26 <hasone> okay, just a sec
20:14:33 <monochrom> http://www.vex.net/~trebla/haskell/so.xhtml  calling haskell shared libraries from C (linux)
20:14:48 <hasone> http://hpaste.org/88856
20:14:54 <hasone> i'll start with that.
20:15:38 <dmwit> The simplest fix is to add a type signature like "prop_doubleMe :: Integer -> Bool".
20:15:45 <monochrom> @tell chrisdone http://www.vex.net/~trebla/haskell/so.xhtml  calling haskell shared libraries from C (linux)  (you were missing -lHSrts-ghc7.6.3)
20:15:45 <lambdabot> Consider it noted.
20:16:29 <dmwit> Until you learn a bit about type classes, it may be a bit difficult to explain this error message. But the jist of it is that there are many different number types, and the compiler doesn't want to pick the wrong one.
20:16:38 <hasone> yeah.
20:16:54 <dmwit> If you give it a bit of a hint about which one it should pick, it'll be much happier. =)
20:17:22 <dmwit> hm, perhaps s/jist/gist/
20:17:37 <hasone> if I want it to pick among all of them, I have to write ... what? a prop for ecah type?
20:17:53 <dmwit> Well.
20:18:39 <dmwit> One way would be to write "prop_doubleMe :: (Eq a, Num a, Show a, Arbitrary a) => a -> Bool" and then "prop_doubleMeInteger :: Integer -> Bool; prop_doubleMeInteger = prop_doubleMe", etc.
20:19:07 <dmwit> Or wherever you're calling prop_doubleMe just give the type signature there.
20:19:20 <dmwit> (I guess there must be some more code that we can't see here.)
20:19:46 <tgeeky> dmwit: gotta protect those doubleMe trade secrets!
20:20:03 <dmwit> tgeeky: ...I meant to run the tests. -_-
20:20:11 <blueonyx> anyone here alive who can help with this yesod problem? http://hpaste.org/88857
20:20:22 <blueonyx> s/alive/awake/
20:20:50 <tgeeky> dmwit: you know I don't even read what is said before commenting! Purple monkey elevator!
20:21:02 <dmwit> lol so random! ~<3~
20:21:16 <hasone> and...
20:21:26 <hasone> i'm gonna go reread the definition of arbitrary and get right back to you
20:22:00 <dmwit> hm
20:22:08 <dmwit> an interesting plan; what lead to it?
20:24:24 <nrook> ack, I tried to install a package, chan-split, using cabal and I got compile errors---any idea what that could signify? (I'm on debian) (http://pastie.org/7982268)
20:25:28 <hasone> is this with leaving the def of prop_doubleMe as I had it before?
20:25:37 <hasone> that's what I'm thinking about
20:25:40 <hasone> i feel like there's something obvious I'm missing
20:26:00 <dmwit> Your definition of prop_doubleMe looks fine, yes.
20:26:39 <hasone> if I define those helper functions for each instance of Num the compiler's aware of, it should be happy?
20:26:44 <dmwit> nrook: Sounds like chan-split hasn't been updated in a while, and its actual dependencies are stricter than its claimed dependencies.
20:27:02 <dmwit> nrook: Complain to the maintainer, or open up the source and fix it yourself.
20:27:09 <hasone> i don' know if that said what I meant to say
20:27:27 <hasone> but if I define it for real, double, float, etc.?
20:27:33 <dmwit> no, no
20:27:41 <dmwit> The compiler is always going to pick one type.
20:27:48 <hasone> ok
20:29:18 <hasone> i think maybe where i'm getting confused is htf is making quickcheck with each prop. if I don't call it prop_doubleMe so it doesn't do that, and just define a property for each type i'm interested in, I think I'm good.
20:29:27 <hasone> maybe
20:29:36 <hasone> i feel so dumb right now
20:30:07 <dmwit> That sounds reasonable to me.
20:30:29 <hasone> i'm going to try it.
20:30:29 <dmwit> All I meant with my comments before was that you don't need to copy the definition of prop_doubleMe a lot of times.
20:30:30 <zRecursive> without using temporary file, can i get the output of 'runProcess "ls" ...' ?
20:30:40 <dmwit> You can define it once, polymorphically, and just call it from your monomorphic properties.
20:30:42 <hasone> okay.
20:30:48 <hasone> okay.
20:30:57 <nrook> dmwit: ah, ok---makes sense! Actually, I think it's the other way around; I'm on debian, and apparently my ghc is 6.12.1, so I think chan-split is actually too new to work
20:31:20 <dmwit> Ah, okay. Perhaps so.
20:31:21 <elliott> I suggest not using 6.12.
20:31:36 <geekosaur> zRecursive, did you actually read the documentation for runProcess?
20:31:44 <hasone> another question.
20:31:46 <nrook> yes... I was unaware that this was 6.12 until now. Going to go upgrade now
20:32:06 <zRecursive> geekosaur: yeah
20:32:27 <geekosaur> then the next question might be whether you understand how POSIX-like processes work
20:32:39 <dmwit> zRecursive: Perhaps you will enjoy readProcess.
20:32:52 <geekosaur> because the documentation tells you the answer to what you asked, if you understand the process model
20:33:06 <geekosaur> (hint: there is a thing called stdout. Learn about it)
20:33:10 <zRecursive> dmwit: thanks
20:33:39 <dmwit> geekosaur: The documentation does not say how to create a fresh pipe. Using the existing stdout may not be what you want.
20:34:11 <dmwit> ...however, it would be difficult to read the documentation without noticing the other functions in the module, which do what zRecursive needs and more...
20:34:11 <zRecursive> now i am using temp. file to get its output
20:34:23 <geekosaur> no, it does give you a way to pass a handle. admittedly figuring out where that handle comes from is not covered there, but *is* by the standard POSIX references
20:34:34 <dmwit> Right.
20:35:17 <zRecursive> @hoogle readProcess
20:35:17 <lambdabot> System.Process readProcess :: FilePath -> [String] -> String -> IO String
20:35:17 <lambdabot> System.Process readProcessWithExitCode :: FilePath -> [String] -> String -> IO (ExitCode, String, String)
20:35:23 <geekosaur> also, since you've also been asking questions in #xmonad, I should warn you that subprocesses don't behave quite as you would expect under xmonad because it ignores children
20:36:00 <dmwit> Oh, is this in xmonad?
20:36:04 <dmwit> http://hackage.haskell.org/packages/archive/xmonad-contrib/0.11.1/doc/html/XMonad-Util-Run.html
20:36:06 <zRecursive> geekosaur: ok, i will test it
20:36:06 <geekosaur> I don't know if it is or not
20:36:09 <geekosaur> hence the warning
20:36:10 <dmwit> Don't use the raw stuff.
20:36:38 <hasone> thanks, mr. wit.
20:36:41 <hasone> you've been awesome
20:36:41 <geekosaur> *if* this is under xmonad, you need to do things differently as the standard process things will generally throw exceptions
20:36:52 <dmwit> hasone: You're very welcome. =)
20:37:04 <tgeeky> dmwit++ -- from hasone
20:37:10 <Clint> nrook: you'll want to get off that version of debian in any case
20:37:12 <geekosaur> they don't expect the dirty trick that xmonad plays on them :)
20:38:11 <zRecursive> geekosaur: what i want is: running a dictionary app and get its output in xmonad
20:38:27 <dmwit> zRecursive: See the module I posted above.
20:38:33 <zRecursive> then dispplay it using dzen2
20:38:38 <dmwit> oh what
20:38:50 <dmwit> Why do you need its output in xmonad if all you're going to do is pass it on to dzen2?
20:39:17 <nrook> Clint: What's wrong with squeeze? Other than this, of course
20:39:32 <Clint> nrook: well, it'll be unsupported in a few months
20:39:44 <hasone> random question, does this channel have a bot?
20:39:47 <zRecursive> dmwit: the user donot use xterm, it use inputPrompt to get input
20:39:52 <Fuuzetsu> hasone: more than one!
20:39:53 <tgeeky> hasone: several. lambdabot, preflex, kappbato
20:40:02 <nrook> Clint: ah, I'll upgrade at some point then
20:40:02 <Fuuzetsu> < 1
20:40:12 <Fuuzetsu> where did < go ;_;
20:40:15 <hasone> excellent. i'm probably going to download and play with them.
20:40:17 <dmwit> goodfellow isn't on at the moment, one sec
20:40:37 <tgeeky> hasone: lambdabot is troublesome to build. I would recommend not trying to do it without a free day.
20:40:47 <tgeeky> hasone: the one that's in here is very full featured and it can be used in PM
20:40:47 <dmwit> < 1
20:40:48 <goodfellow>   1
20:40:57 <hasone> okey doke. thanks for the heads up.
20:40:57 <Fuuzetsu> goodfellow strong~
20:41:13 <geekosaur> zRecursive, you probably want to execute a command with spawn "ls | dmenu" or similar, rather than connecting the pipe within xmonad
20:42:04 <geekosaur> in particular, it's a bad idea to handle lots of data inside xmonad like that because any time spent doing that is time *not* spent servicing X events, and if you block those for too long you can potentially deadlock the entire desktop session. (window managers are important...)
20:42:21 <dmwit> hasone: I am a Haskell expert (do I get to call myself that yet? =) and it took me approximately 3.5 hours to build lambdabot.
20:42:51 <zRecursive> geekosaur: thanks
20:42:51 <lispy> dmwit: oh my
20:42:55 <hasone> please tell me it was all straight up compile time.
20:42:55 <dmwit> And I just happened to have one of the GHC versions that's known to work lying around... =P
20:43:00 <dmwit> hasone: nope
20:43:02 <lispy> dmwit: which lambdabot ? the new shiny one or the one we run here?
20:43:04 <hasone> heh :)
20:43:09 <dmwit> maybe 15-20 minutes compile time total
20:43:15 <geekosaur> I am far from being a Haskell expert and building lambdabot has always been a hair-tearing experience. (I used to run one.)
20:43:30 <dmwit> lispy: shiny one?
20:43:40 <dmwit> lispy: I just cabal unpack'd him.
20:43:42 <Clint> i just apt-get install lambdabot
20:43:46 <dmwit> ...I think
20:43:57 <dmwit> Clint: That's well and good until you want to make changes. =)
20:44:04 <dmwit> her?
20:44:04 <dmwit> her
20:44:06 <lispy> dmwit: https://groups.google.com/forum/?fromgroups#!topic/haskell-cafe/3j96a2l6ZAA
20:44:09 <Fuuzetsu> A distro is just not good if it doesn't come with lambdabot in its repos.
20:44:44 <lispy> mokus: ping
20:44:57 <tgeeky> Fuuzetsu: yikes! I'll switch if you tell me which :O
20:44:59 <dmwit> lispy: I built it about a month or two ago, so not that.
20:45:27 <Fuuzetsu> tgeeky: heh, what are you using that doesn't have it?
20:45:32 <lispy> dmwit: if you happen to build again with mokus's lambdabot, I would appreciate hearing about your experience
20:45:56 <tgeeky> Fuuzetsu: Ubuntu previous LTS right now. I don't know what I'm going to use when I reinstall on an SSD. Maybe Arch.
20:46:01 <dmwit> lispy: I'm pretty sure I'm not interested in building lambdabot again. =P
20:46:12 <lispy> dmwit: fair enough :)
20:46:18 <Fuuzetsu> tgeeky: funny way to spell Gentoo
20:46:19 <tgeeky> it's a damn shame, too, because lambdabot does so many amazing things out of the box
20:46:33 <tgeeky> Fuuzetsu: oh, typo! The keys are like right next to each other.
20:46:46 <Fuuzetsu> happens more than one would have thought possible
20:47:35 <ivoscc> i'm trying to install cabal-dev and getting http://hpaste.org/88859 . Seems like it can't find HStar-0.4.0.1 nor HSsetenv-0.1.0, should this libraries be provided by haskell-platform or where should i look for them?
20:48:17 <tgeeky> ivoscc: no, they won't be provided with haskell-platform, and like all packages, they are on Hackage (or they aren't)
20:48:49 <dmwit> ivoscc: ghc-pkg check, please
20:51:38 <ivoscc> tgeeky: can't seem to find them there
20:52:08 <ivoscc> dmwit: http://hpaste.org/88861 i'm using debian and have compiled ghc7 directly into /usr/local/
20:52:40 <ivoscc> maybe it's breaking because i have both ghc7 and debian's 6?
20:53:04 * tgeeky vomits a little bit at this hpaste
20:53:16 <dmwit> ivoscc: It looks to me like (at a guess) you have removed ~/.cabal at some point without also removing ~/.ghc.
20:53:34 <dmwit> Reinstall tar, setenv, and the other broken packages before you proceed.
20:53:54 <dmwit> Having multiple versions of GHC installed is no problem.
20:55:54 <ivoscc> dmwit: so rebuilding ghc should provide reinstall those right? sorry if I'm beeing too noobish
20:56:03 <dmwit> what, no
20:57:08 <dmwit> cabal install --reinstall tar setenv --constraint "tar installed, setenv installed" # for example
20:57:20 <dmwit> (I wonder if that works.)
20:57:51 <dmwit> nope
20:58:07 <dmwit> Okay, just cabal install --reinstall tar setenv, then.
20:58:10 <dmwit> Forget the constraints.
20:58:32 <dmwit> You should probably unregister all those broken packages, too.
20:59:00 <dmwit> for i in yesod yesod-auth yesod-form yesod-persistent ... SHA; ghc-pkg unregister $i
20:59:19 <dmwit> Once ghc-pkg check is clean, then you can start installing things again.
21:00:11 <ivoscc> nice, i'll give it a try
21:00:55 <ivoscc> also, what would be the cleanest way to install sandboxed packages, i'm kind of spoiled by python's virtualenv?
21:01:26 <ivoscc> if i understand correctly running cabal without --global will install everything in ~/.cabal
21:03:34 <blackdog> ivoscc: there's hsenv - same approach as virtualenv
21:03:37 <blackdog> also cabal-dev
21:04:40 <Clint> virthualenv
21:06:43 <ivoscc> nice, had read about virthualenv, didn't know if it was the right way to start
21:07:15 <johnw> hsenv is pretty good nowadays
21:07:29 <johnw> i like that you can construct your environment from an installer tarball
21:07:29 <blackdog> Clint: isn't hsenv the evolution of virthualenv?
21:09:30 <Clint> blackdog: makes sense
21:15:16 <ivoscc> thanks all, i'll try to understand cabal-dev first, it seems to be the default way
21:16:14 <tgeeky> ivoscc: whatever you do, don't ever use --global
21:17:00 <tgeeky> ghc itself or haskell-platform should be in --global, and nothing else, imho
21:17:12 <ivoscc> tgeeky: yeah, having almost messed up my system with multiple versions of python thaught me never to do that again
21:18:32 <ivoscc> since i'm using xmonad from debian's repos i figured i should compile ghc and haskell-platform into /usr/local and then install eveything else locally
21:18:42 <ivoscc> don't want to break my wm
21:19:20 <ivoscc> tgeeky: thanks :)
21:19:54 <Fuuzetsu> I don't think you can break it. Worst case, you won't be able to compile a new binary
21:20:40 <hcaulfield57> I have some questions about instance declarations, the following doesn't work because 'info' has no way to confirm that it will return a string right? http://hpaste.org/88862
21:25:47 <mokus> lispy: pong
21:25:47 <lambdabot> mokus: You have 2 new messages. '/msg lambdabot @messages' to read them.
21:34:47 <dmwit> hcaulfield57: right
21:37:54 <lispy> mokus: hey. We were just talking about how hard it can be to build lambdabot.
21:38:02 <lispy> mokus: but your new lambdabot is easy to build?
21:38:16 <mokus> in my experience it "cabal install"s cleanly
21:38:36 <mokus> though it does have a lot of dependencies so cabal hell is certainly a possible outcome if you already have a lot of stuff
21:39:18 <hcaulfield57> dmwit: Okay thanks, can you only have class constraints in instances if the type is * -> *, for example "instance Foo a => Bar (Baz a) where"
21:40:47 <dmwit> hcaulfield57: You can only have constraints of kind Constraint.
21:41:15 <dmwit> I'm not sure I understand the question, to be honest.
21:41:46 <nan`> ello
21:41:57 <hcaulfield57> dmwit: I'm not sure I understand it either haha
21:43:15 <dmwit> You could try again if you wanted.
21:43:17 <dmwit> Or not.
21:43:41 <geekosaur> instance Eq a => Ord a where -- exists
21:44:05 <geekosaur> but I don't think an instance is even meaningful for kind *
21:44:13 <hcaulfield57> ^
21:44:23 <hcaulfield57> I was trying to ask that, but yea I don't think it makes sense
21:44:25 <geekosaur> well, suppose it might be
21:46:33 <hcaulfield57> Okay, I think I got it, thanks dmwit and geekosaur
21:47:34 <geekosaur> I don't think you can do much of interest with such an instance. if you meant more complex kinds, we have constraints for those
21:48:46 <hcaulfield57> With * ?
21:49:05 <geekosaur> instances for types of kind * are kinda useless
21:49:30 * tgeeky thinks of all of the instance you could have for ()
21:49:35 <hcaulfield57> geekosaur: yea just something I ran into, trying to get the syntax down.
21:49:36 <geekosaur> there are a number of kinds other than * -> * which have instances in the mtl, and I think someof them have constraints
21:50:04 <geekosaur> hm, I guess () has Enum and Bounded instances, at that
21:50:12 <geekosaur> not especially interesting ones, mind
21:50:39 <dmwit> I am so confused.
21:50:57 <dmwit> Aren't all instances of Num, Eq, Ord, Monoid, etc. of kind *?
21:50:59 <geekosaur> and it has an Ord instance which means there's an instance Eq () => Ord () somewhere
21:51:14 <tgeeky> dmwit: yep. All of the built-in ones are.
21:51:20 <dmwit> No. All of them are.
21:51:23 <dmwit> built-in or otherwise
21:51:30 <tgeeky> well, I mean, everything that is built-in has kind *
21:51:38 <geekosaur> mm, I guess.
21:51:40 <dmwit> Maybe does not have kind *.
21:51:45 <dmwit> Maybe is built-in.
21:51:46 <tgeeky> that's not native
21:51:55 * tgeeky means things that are in GHC.xxx
21:51:56 <lispy> dmwit: oh, did you see what mokus said. It should install cleanly.
21:52:10 <geekosaur> I was thinking mostly of Int and such, which are not quite normal ADT types
21:52:12 <amosr> Int# doesn't have kind *
21:52:17 <amosr> ha ha ha (sorry)
21:52:17 <dmwit> tgeeky: Okay, [] does not have kind *.
21:52:24 <geekosaur> and in which they do make sense.
21:52:29 <tgeeky> dmwit: [] is that one exception to everything :o
21:52:42 <tgeeky> dmwit: I think you're right, though. There are lots of things with kind *.
21:53:19 <dmwit> I just... don't really understand what spawned the whole line of questioning.
21:54:47 <elliott> State# doesn't have kind *
21:55:03 <elliott> I'm sure there's soemthing that doesn't end with # that has a non-* kind
21:55:13 <amosr> tuples?
21:55:19 <elliott> arguable how built-in they are
21:56:24 <amosr> I think they're pretty stuck in there
21:59:41 <amosr> why would you say tuples aren't built-in?
22:01:58 <copumpkin> elliott: (#,#)? :P
22:02:19 <elliott> amosr: well, they are defined in a "plain old" .hs in GHC.
22:03:09 <amosr> ah. I haven't seen that. I've only seen all the stuff in TysWiredIn or something for constructing tuples
22:04:43 <elliott> right. it's a fake kind of not built in :P
22:06:24 <amosr> oh hey are you conal elliott? I sent an email to you / the list but got an error (my fault but lazy)
22:06:32 <elliott> nope, conal is conal on IRC :)
22:06:36 <amosr> aha!
22:07:06 <copumpkin> by the transitivity of names, conal's last name is elliott's
22:08:17 * tabemann is finding the OpenGLRaw library to be very un-haskell-like
22:09:49 <cmears> I think that's why it's called "Raw"
22:10:16 <NemesisD> has anyone developed a tool for haskell that can rewrite complete module imports into limited imports
22:10:38 <tabemann> the part that gets me is that just about any function that returns anything requires me to call alloca or allocaBytes to allocate data for a Ptr to feed into it, and then use peek to get the data out of that
22:10:49 <dmwit> NemesisD: I think GHC can do that?
22:10:59 <dmwit> There's like a warning or something you can turn on that will tell you what to import.
22:11:22 <dmwit> tabemann: dude, don't you want to be in control of when allocation happens
22:11:25 <NemesisD> oh cool
22:11:30 <dmwit> (But yes, that is why it's called Raw.)
22:12:01 <tabemann> I'm using it only because the HOpenGL library is incomplete, for claiming to support OpenGL 3.1
22:12:20 <elliott> i think you can mix opengl and openglraw
22:12:23 <elliott> the latter only for parts you need?
22:13:06 <tabemann> because I've only started on the code using this, I've figured I might as well be consistent rather than trying to mix and match the two
22:13:11 <dmwit> NemesisD: Hm, actually... maybe I'm misremembering.
22:13:19 <dmwit> Since I can't find it in the GHC manual.
22:14:09 <dmwit> NemesisD: I think I was thinking of -fwarn-missing-import-lists.
22:15:15 <tabemann> a plus side of OpenGLRaw is that it seems much easier to find functions in it, from looking at OpenGL code written in C, because they're named almost identically to their C OpenGL counterparts
22:18:03 <dmwit> dang
22:18:07 <dmwit> I know I've seen a tool for this.
22:22:12 <NemesisD> dmwit: yeah totally seems doable
22:22:57 <zRecursive> @google dmenu+utf8
22:22:58 <lambdabot> http://crunchbang.org/forums/viewtopic.php?id=3874
22:22:58 <lambdabot> Title: [Resolved] font in dmenu (Page 1) / Help & Support (Stable) / CrunchBang Linux F ...
22:23:29 <NemesisD> i'm also in need of another tool but its a bit tricker. i have an executable project that does full module exports
22:23:48 <NemesisD> trying to reduce that to specific imports
22:23:51 <NemesisD> exports*
22:25:00 <dmwit> NemesisD: :browse in ghci, then cut -d' ' -f1
22:25:34 <NemesisD> nice
22:25:40 <ChongLi> the Simon Marlow book is great
22:25:46 <ChongLi> I'm really enjoying it
22:26:07 <NemesisD> simon marloww book?
22:26:19 <ChongLi> Parallel and Concurrent Programming in Haskell
22:26:34 <Fuuzetsu> Heh, I love that you can meet a lot of important people that write all the books and libraries simply by going to #haskell or posting on the mailing lists.
22:26:35 <blackdog> oh, is it out?
22:26:47 <ChongLi> no, just reading it on O'Reilly OFPS
22:27:10 <blackdog> Fuuzetsu: SPJ Is Gregarious So We Are Gregarious? SIGSWAG has a ring to it.
22:27:13 <ChongLi> http://ofps.oreilly.com/titles/9781449335946/index.html
22:27:59 <Fuuzetsu> I have no idea what gregarious means I think. It's half past 6 in the morning here zzz
22:29:33 <NemesisD> blackdog: enjoy your spot in the quotes section of the haskell weekly news
22:29:50 <Fuuzetsu> blackdog is becoming a regular member
22:30:13 <blackdog> NemesisD: ha, nice :)
22:30:20 <Fuuzetsu> The real question is whether he can beat shachaf this week.
22:30:36 <NemesisD> blackdog: i don't have the power to make that happen but if there is any justice it shuld be
22:30:36 <blackdog> Fuuzetsu: dude, i've been here at least ten years.
22:30:49 <Fuuzetsu> blackdog: I mean in the weekly news quote section.
22:31:22 <shachaf> blackdog: 10 years this August. :-)
22:31:39 <blackdog> shachaf: time flies when you're having fun :)
22:32:04 <blackdog> Fuuzetsu: ... i was in the quotes section?
22:32:11 <NemesisD> i actually met some haskellers from here IRL for the first time last week at my first meetup
22:32:12 <shachaf> blackdog: And also when you're on IRC.
22:32:16 <blackdog> oh, acowley's reference to me. bah, that hardly counts :)
22:32:40 <shachaf> NemesisD: Seattle?
22:33:00 <NemesisD> shachaf: bingo. i'm gonna be embarassed if you were there and I didn't realize it was you
22:33:08 <blackdog> NemesisD: I haven't met any for years. think i met a few like shapr and tim chevalier in 2003 at icfp
22:33:20 * shachaf is everywhere.
22:33:39 <shachaf> blackdog: You should come to SF more often!
22:33:40 <NemesisD> o.O
22:33:54 <blackdog> lambdajam was bizarre, in a good way. i'm used to being the only one crapping on about type safety, i think i'm a bit of a running joke to the local rubyists.
22:34:05 <blackdog> shachaf: will be back soon, i hope.
22:34:14 <NemesisD> shachaf: it was a cool meetup
22:34:23 <NemesisD> blackdog: are you a rubyist by day, haskeller by night like me?
22:34:34 <blackdog> but a hundred haskell programmers in a conference? fun times.
22:34:38 <amosr> to be fair, the rubyists are a running joke to us too, aren't they?
22:34:43 <blackdog> NemesisD: actually, i'm a haskeller by day and by night too now.
22:34:47 <shachaf> blackdog: Come to one of the bahaskell meetings!
22:35:04 <blackdog> shachaf: i will - still in sydney now, though, and had no transport last time i was out.
22:35:20 <shachaf> NemesisD: I've never been to the Seattle Haskell thing, though I once missed it by a few hours.
22:35:32 <NemesisD> cool
22:35:32 <shachaf> I think this topic is more #haskell-blah -appropriate.
22:36:37 <NemesisD> shachaf: very well
22:38:34 * tabemann wishes he could be a functional programmer by day, when he's got a job that is
22:39:35 <blackdog> tabemann: i started a company to do it. surprisingly easy.
22:40:35 <NemesisD> i like being an employee most of the time
22:40:53 <tabemann> somehow I'm not sure if I'd want to have to manage a business
22:41:20 <nan`> ;join #haskell-blah
22:41:22 <nan`> oops
22:41:24 <blackdog> thankfully my co-founder's pretty good at the management side.
22:42:31 <tabemann> of course that means I settle for being a C, C++, or Java programmer by day
22:44:16 <nan`> blackdog: what is your company called
22:45:18 * hackagebot network-protocol-xmpp 0.4.5 - Client library for the XMPP protocol.  http://hackage.haskell.org/package/network-protocol-xmpp-0.4.5 (JohnMillikin)
22:45:37 <blackdog> nan`: meanpath
22:46:32 <nan`> 2 days until launch
22:47:03 <blackdog> nan`: hey, it says _in_ june
22:47:13 <blackdog> you sound like adam now
22:47:32 * blackdog needs to get launch done so he can hire more haskellers to mock his code
22:47:39 <NemesisD> what does it do
22:47:47 <nan`> [2, 31] days until launch
22:48:01 <shachaf> #haskell can mock your code for free!
22:48:15 <blackdog> NemesisD: scrapes the web every day and dumps the results into a queryable database
22:48:24 <shachaf> (And #-blah can mock everything else. But we don't usually.)
22:48:29 <blackdog> shachaf: unfortunately #haskell won't sign NDAs :)
22:48:32 <NemesisD> blackdog: scrapes it for what?
22:48:36 <blackdog> everything.
22:48:42 <blackdog> at least, the front page of everything.
22:48:47 <NemesisD> the whole web?
22:48:54 <NemesisD> oh my
22:48:58 <blackdog> front page of every domain. got about 150million atm.
22:49:08 <NemesisD> oh wow
22:49:09 <blackdog> it's a really fun project :)
22:49:28 <dmwit> > 150000000/24/60/60
22:49:28 <NemesisD> have you come across a good html parser then?
22:49:29 <lambdabot>   1736.111111111111
22:50:05 <nan`> So you are building a search engine?
22:50:12 <blackdog> sort of.
22:50:35 <dmwit> Pump him, boys!
22:50:42 <nan`> but only for front pages. How do you find them
22:51:04 * shachaf gestures toward -blah
22:51:11 <nan`> lol
22:51:18 <DigitalKiwi> no i don't want to go there but i want to hear about this!
23:04:50 <adnap> Can (\x -> print x >> someOtherIO) be written without explcitly specifying x?
23:05:38 <Fuuzetsu> f = someOtherIO << print
23:05:40 <Fuuzetsu> maybe?
23:05:45 <Fuuzetsu> :t (<<)
23:05:46 <lambdabot>     Not in scope: `<<'
23:05:46 <lambdabot>     Perhaps you meant one of these:
23:05:46 <lambdabot>       `=<<' (imported from Control.Monad.Writer),
23:06:00 <shachaf> Fuuzetsu: ?
23:06:05 <Aetherspawn> Anyone know the lens equivalent for \x d -> d { someField = x }
23:06:39 <adnap> Fuuzetsu: Oh, thanks
23:06:47 <Fuuzetsu> adnap: does that actually work?
23:06:50 <ChongLi> no
23:06:52 <arkeet> someOtherIO <* print
23:07:01 <Fuuzetsu> :t (<*)
23:07:02 <lambdabot> Applicative f => f a -> f b -> f a
23:07:12 <shachaf> ?
23:07:13 <arkeet> nope
23:07:23 <adnap> Fuuzetsu: I'm trying it and I can't figure out wher << is
23:07:25 <shachaf> (>> someOtherIO) . print ?
23:07:27 <arkeet> @pl \x -> print x >> someOtherIO
23:07:27 <lambdabot> (>> someOtherIO) . print
23:07:27 <johnw> Aetherspawn: d & someField .~ x
23:07:33 <ChongLi> << doesn't exist
23:07:37 <adnap> Okay
23:07:40 <johnw> if you've used makeLenses
23:07:45 <Fuuzetsu> adnap: it doesn't exist, I just made a potshot. flip (>>) should do
23:07:46 <Aetherspawn> Ah, thanks
23:07:56 <joelteon> I believe it's cause (<<) has the opposite semantics of what you'd expect
23:08:00 <Aetherspawn> @pl (\x d -> d & someField .~ x)
23:08:01 <lambdabot> (line 1, column 25):
23:08:01 <lambdabot> unexpected "~"
23:08:01 <lambdabot> expecting white space
23:08:01 <lambdabot> ambiguous use of a right associative operator
23:08:04 <arkeet> set someField x d
23:08:21 <adnap> Have lenses always been popular? I am noticing a lot of talk about lenses lately
23:08:25 <Aetherspawn> Oh, that's the shorter one I was looking for :)
23:08:36 <arkeet> .~ is just infix set
23:08:46 <dmwit> adnap: print >=> const someOtherIO
23:08:59 <adnap> :t (>=>)
23:09:01 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
23:09:21 <ChongLi> adnap: they've exploded in the last few months, thanks to edwardk's new lens library
23:09:33 <arkeet> new? it's approaching a year old
23:09:38 <arkeet> :p
23:09:45 <ChongLi> pretty new
23:09:58 <johnw> yeah, I recall the lens talk being even more heated a few months ago
23:10:20 <arkeet> the lensplosion was so last year.
23:10:27 <Aetherspawn> @pl (\x y -> set config x y)
23:10:27 <lambdabot> set config
23:10:34 <adnap> I can't imagine a use for them. I know they are supposed to make it so that when you records in records, it's easier to get at the inner records, but my types are usually not so nested
23:10:38 <Aetherspawn> I thought so, so that must not typecheck how I assumed.
23:10:48 <adnap> *you have
23:10:58 <shachaf> Then they are not for you.
23:11:02 <ChongLi> adnap: the lens library does a lot more than that
23:11:06 <arkeet> Aetherspawn: maybe you are confusing a field accessor with a lens
23:11:14 <ChongLi> it generalises a bunch of different things
23:11:22 <mzero> (as if running git rebase -i weren't scary enough... I just ran it inside the very software it was rebasing: developing your own shell is crazytime!)
23:11:30 <ChongLi> folds, traversals etc.
23:11:43 <adnap> Once someone posted a video lecture by edwardk and I got the slides for it
23:11:46 <adnap> I got about halfway through
23:11:54 <Aetherspawn> I'm writing the command line parser for my program and I thought the table would be much shorter if I could use lens for the getters/setters
23:11:57 <adnap> It didn't even talk about lenses most of the time
23:12:00 <Aetherspawn> Its structured the same way as the getopt tutorials
23:12:05 <arkeet> adnap: that wasn't the goal of the talk
23:12:07 <arkeet> :p
23:12:10 <elliott> lens isn't about lenses.
23:12:15 <adnap> Well, it was a bad talk for introducing lenses
23:12:31 <arkeet> of course.
23:12:34 <arkeet> that wasn't its goal.
23:12:38 <adnap> He had some really mind-bending examples involving traverable
23:12:44 <adnap> *traversable
23:12:55 <adnap> arkeet: Well, it seemed like it was the goal at the beginning
23:12:56 <mzero> Aetherspawn: I suspect lens isn't going to give you much benefit there.... but then again, I don't know what your code looks like!  :-)
23:13:04 <arkeet> the goal was to introduce lens.
23:13:16 <adnap> arkeet: You just contradicted yourself
23:13:23 <arkeet> lens /= lenses
23:13:31 <Aetherspawn> Hmm, well, I may as well show you :P http://hpaste.org/88865
23:13:45 <Aetherspawn> Type error is included. I suspect "set" may have not been exactly what I needed.
23:13:45 <arkeet> lens the library.
23:13:46 <adnap> So, you're just being pedantic, or do both words have meaning in Haskell?
23:13:55 <arkeet> not lenses as in getter/setters.
23:13:58 <elliott> <elliott> lens isn't about lenses.
23:14:06 <elliott> and lens wouldn't be as popular a topic if it was just about lenses.
23:14:10 <elliott> since they're not that interesting.
23:14:22 <johnw> there have been many "just lens" libraries in the past
23:14:23 <Aetherspawn> Wait
23:14:26 <Aetherspawn> Ooops!
23:14:26 <johnw> at least 3 that I can think of
23:14:35 <johnw> but the "lens" library takes it to a whole 'nother level
23:14:35 <arkeet> data-lens, fclabels, ???
23:14:44 <mgsloan> though a few of them also had Isos!
23:14:51 <mgsloan> some even had prism-ey things (yall)
23:14:51 <adnap> Well, is edwardk's lecture the best intro to the lens library?
23:15:01 <johnw> the best currently existing, I think
23:15:06 <mgsloan> the best intro to the best lens library ;)
23:15:07 <elliott> maybe. there's also a tutorial on lens.github.com
23:15:11 <adnap> Crap
23:15:14 <adnap> Okay
23:15:14 <johnw> lens really does need a lot more good intro material; like, an O'Reilly book
23:15:21 <mzero> oh - you mean the table of options? No lens isn't going to help you there a bit
23:15:34 <shachaf> Hmm, I should finish writing my thing.
23:15:39 <mzero> well - maybe
23:15:42 <arkeet> shachaf: yes, me too
23:15:44 <mzero> okay - I'll shut up no
23:15:47 <mzero> shut up now
23:15:51 <shachaf> arkeet: You should finish writing my thing too?
23:15:54 <shachaf> Sounds good!
23:15:56 <adnap> It took me a long time to work through each example in the lecture, and which I think I was able to type check everything, I didn't understand the point of the examples
23:16:00 <arkeet> shachaf: I know.
23:16:02 <adnap> *while
23:16:05 <Aetherspawn> (I'm an idiot and was looking at the wrong line! Thanks everyone for being patient and helping me learn more about lens :])
23:16:16 <mzero> adnap - the problem with that lecture is that it is lacking in motivating examples
23:16:44 <mzero> actually - I wonder - just how much of the Lens library do people use?
23:16:45 <shachaf> lens is its own reward.
23:16:47 <adnap> And I think it took longer because I was unfamiliar with some of the idioms in the lecture
23:16:56 <adnap> Something about . . .
23:17:01 <adnap> Oh
23:17:02 <mzero> there are a lot of exotic species in there - but I only hear people talk about a few of them
23:17:04 <adnap> (.).(.)?
23:17:16 <DigitalKiwi> that'd distract me too
23:17:16 <adnap> I can't remember anymore
23:17:26 <shachaf> mzero: That depends. lens contains (a faster implementation of) most of Uniplate, for instance.
23:17:47 <shachaf> Do you count that as a part of lens people don't use?
23:18:07 <mzero> LIke Iso and Prism - or Review --- how often do those come into play?
23:18:09 <adnap> I guess that if lots of people are talking about lens lately, it must be useful...
23:18:24 <adnap> So I want to understand it so I might be better at Haskell
23:18:30 <shachaf> mzero: Yes, those are useful.
23:18:40 <elliott> wait, we found a use for Review? :P
23:18:49 <shachaf> Well, for "review", at least.
23:18:54 <arkeet> understanding lens is a fun thing to try.
23:19:00 <mzero> adnap - in the Haskell community, that isn't necessarily a good test!
23:19:01 <arkeet> does anyone understand lens?
23:19:01 <shachaf> Review is like Getter.
23:19:05 <arkeet> in its entirety?
23:19:17 <arkeet> well, no one understands Action, so I suppose not
23:19:39 <nan`> I'm gonna do some melatonin tonight
23:19:46 <arkeet> I can't believe there hasn't been a new lens version on hackage in 2 months. ;)
23:20:09 <arkeet> ooh, new HP
23:20:46 <mzero> why yes, yes there is a new HP!  :-)
23:21:14 <adnap> It is hard for me to get interested in something abstract without seeing it used in something practical
23:21:27 <dmwit> There's that pong thing.
23:21:42 <adnap> It is hard to understand without working out examples I guess
23:21:46 <arkeet> lens on github has a few full examples
23:22:03 <arkeet> https://github.com/ekmett/lens/tree/master/examples
23:22:18 <arkeet> including a full pong game
23:23:01 <johnw> arkeet: here are a few more: https://gist.github.com/5676021
23:23:03 <johnw> all taken from this channel
23:23:37 <arkeet> well, those are a different kind of example.
23:24:02 <arkeet> but sure
23:24:44 <arkeet> some of those are non-lawful uses of things though
23:24:51 <arkeet> like line 22
23:25:09 <elliott> also some of them are an affront to decency, like the upon ones.
23:25:30 <arkeet> upon is eeeeeevil
23:25:30 <shachaf> upon *is* decency.
23:25:35 <johnw> i'm not entirely sure which still work either
23:25:42 <johnw> these were taken over many months
23:26:13 <shachaf> > over (upon (!!4)) toUpper "abcdefghijk"
23:26:14 <lambdabot>   "abcdEfghijk"
23:26:36 <adnap> "makeLenses ''Pong"
23:26:41 <arkeet> > over (ix 4) toUpper "abcdefghijk"
23:26:41 <adnap> What's with these "''"?
23:26:43 <lambdabot>   "abcdEfghijk"
23:26:50 <arkeet> adnap: template haskell
23:26:54 <adnap> Ew
23:27:04 <shachaf> > over (upon last) toUpper "abcdefghijk"
23:27:06 <lambdabot>   "abcdefghijK"
23:27:16 <arkeet> uh
23:27:44 <shachaf> (This is the part where you mention _last.)
23:27:49 <arkeet> yeah
23:27:55 <arkeet> > over _last toUpper "abcdefghijk"
23:27:56 <lambdabot>   "abcdefghijK"
23:28:10 <arkeet> I haven't been around in a while.
23:28:14 <mzero> I admit - I don't find the examples in that gist ... compelling!
23:28:24 <arkeet> me either
23:28:46 <johnw> they weren't really collected for that purpose
23:28:53 <shachaf> Yep. Those are toys to show off weird things you can do.
23:28:54 <johnw> i just copied whatever edwardk and shachaf pasted here from time to time
23:28:59 <shachaf> The goal of lens is not to do weird things.
23:29:17 <mzero> one couldn't tell that from the library!
23:29:19 <shachaf> Not the main goal, anyway.
23:29:27 <Fuuzetsu> I can't tell anything from the library…
23:30:37 <shachaf> johnw: What's with that "iwhere" example?
23:36:43 <adnap> lol
23:36:56 <adnap> What I was just talking about: https://www.youtube.com/watch?v=cefnmjtAolY&t=1h47m35s
23:37:41 <adnap> "... I really should have named the library "traverals", but then nobdoy would have looked at it."
23:37:56 <johnw> now we look, but we don't see
23:39:44 <johnw> I like lens for things like: someMap & at key.non value %~ (+ 2)
23:39:55 <johnw> that increments the value at key by 2, or if it doesn't exist sets the key to value+2
23:40:10 <johnw> saying that without lens is a lot more verbose
23:40:15 <shachaf> Or, if the key is value - 2, it deletes it.
23:40:19 * hackagebot thumbnail 0.7 - generate thumbnail image  http://hackage.haskell.org/package/thumbnail-0.7 (KatsutoshiItoh)
23:41:04 <shachaf> Er, not the key, the value associated with the key. "value" is a confusing name here.
23:45:19 * hackagebot pcap-enumerator 0.4 - Convert a pcap into an enumerator.  http://hackage.haskell.org/package/pcap-enumerator-0.4 (KatsutoshiItoh)
23:50:19 * hackagebot data-util 0.3 - utilities for handle data  http://hackage.haskell.org/package/data-util-0.3 (KatsutoshiItoh)
