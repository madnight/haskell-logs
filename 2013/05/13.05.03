00:07:15 * hackagebot cgi 3001.1.8.4 - A library for writing CGI programs  http://hackage.haskell.org/package/cgi-3001.1.8.4 (AndersKaseorg)
00:08:32 <shachaf> ThandersKaseorg
00:15:29 <ion> CGI still exists?
00:15:44 <ion> Launch a new system process for each request? What a brilliant idea.
00:16:04 <latermuse> ion: I hear some people still use it.
00:16:41 <dyreshark> ion: but it's scalable!
00:16:50 <dyreshark> soon, we'll launch a new system process for each function call
00:16:52 <Boney> although it has known scalability issues it's very simple.
00:17:04 <Boney> CGI is great because of this simplicity.
00:17:16 <ion> Simpler than just talking HTTP over a socket?
00:17:21 <Boney> yep.
00:17:39 <simpson> Sockets *are* harder than stdio, it's true.
00:17:40 <Boney> you don't have to write a HTTP deamon.
00:18:01 <Boney> good engineering keeps things simple.
00:18:01 <mauke> stdio is sockets
00:18:05 <Kinnison> A lot of shared hosting platforms don't let you run daemons but do let you run CGIs
00:18:21 <ion> What’s the major difference between using a CGI library and using an HTTP daemon library from the programmer’s point of view?
00:18:39 <Kinnison> ion: if the http library fork()s for every new request, very little
00:18:41 <Boney> why do you need a library for CGI?
00:18:43 <mauke> ion: CGI is much easier to debug
00:18:58 <mauke> Boney: because doing everything manually is tedious and error prone
00:19:04 <ion> boney: You don’t need a library for either.
00:19:15 <Boney> if both libraries already exist, sure pick either, (pick the one you know is maintained/debuged)
00:19:22 <mauke> see also: every old CGI script from the 90s written in perl4
00:19:38 <ion> &hello;
00:19:46 <mauke> subroutines? I wish
00:19:57 <Boney> but if you have neither library already available, then try to avoid wasting your time writing a HTTP daemon.
00:20:36 <Recursive> seems mighttpd2 is a haskell CGI server
00:20:51 <Recursive> @google mighttpd2
00:20:53 <lambdabot> http://mew.org/~kazu/proj/mighttpd/
00:20:53 <lambdabot> Title: Redirect
00:52:05 <kwstas> hi! Is it possible to define a parametrized type like "type stack = [a]"?
00:52:47 <quchen> kwstas: type stack a = [a]
00:52:59 <quchen> kwstas: type Stack a = [a]
00:53:00 <mauke> type Stack a = [a]
00:53:08 <quchen> Pardon the typo.
00:53:20 <kwstas> nice! thanx a lot!!
00:58:34 <shachaf> We need type-level ImplicitParams.
01:00:07 <Hafydd> You are not defining a type there, however.
01:04:59 <stingray-> some haskell-related paper made a casual suggestion that instead of having a single sinful monad for effects (IO), it would be useful if we had more monads, i.e. FileIO for file-system related effects, SocketIO, and so on.  that way we could for example have an action that can only print to stdout, but can't write to files or connect to some server. what do you think about that?
01:05:32 <c_wraith> stingray-: people consider it from time to even.  even implement bits of it
01:05:53 <c_wraith> stingray-: it's kind of doomed to failure as long as IO is still an option to do everything
01:06:08 <stingray-> that is true
01:07:24 <c_wraith> But I don't think anyone would object to the IO system being more principled in some ways - it's just a matter of finding something so convincingly better that people will willingly leave what's there now behind.
01:08:29 <sgronblo> I'm trying to code up a generic solution to solving Google Code Jam problems. But I am getting a bit stuck with putting it all together. Somehow I can't seem to figure out how to indicate that the parser I defined actually returns cases of a certain type.
01:09:19 <Recursive> seems #freebsd and #openbsd donot work today ?
01:10:16 <sgronblo> I have a class for the Parser which requires the instantiating type to define a parse method and a class for problem cases which requires a solve method.
01:21:06 <b__> Is it possible to have a type as a value?
01:21:42 <shachaf> That depends on what you mean.
01:22:45 <b__> like: data Sample = Sample { sampleType :: Type, sampleData :: [TheActualType] }
01:23:08 <shachaf> Ah. It still depends on what you mean.
01:23:27 <shachaf> The answer might an existential type. But you should expand on how you want to use it.
01:25:11 <b__> I think I can actually use data Sample a = Sample { leData :: [a] }, and then set the type variable when I am parsing the input
01:27:23 <hpaste> b_ pasted “wafwaf” at http://hpaste.org/87127
01:28:10 <b__> I have this for getting a .wav header, but I will need to parse the data based on bitsPerSample
01:29:07 <b__> I guess I could just use a type variable for this
01:42:17 * hackagebot putlenses 0.0.3 - Put-based lens library  http://hackage.haskell.org/package/putlenses-0.0.3 (HugoPacheco)
01:50:01 <t7> does anyone use STM in real life?
01:50:07 <t7> (anyone in here)
01:50:16 <mauke> sure
02:07:54 <hpaste> b_ pasted “Is there an idiom for this?” at http://hpaste.org/87133
02:10:36 <no-n> what do <$> and <*> do?
02:11:05 <Lethalman> no-n, best time to ask a question, whole server split :P
02:11:21 <DigitalKiwi> i think he caused the split
02:11:25 <no-n> ah, I have join/part messages turned off ;)
02:12:12 <mm_freak> no-n: <$> is just fmap
02:12:29 <no-n> ok
02:12:59 <mm_freak> in combination with <*> it gives you a way to apply regular functions to results of computations in applicative functors (if you are a beginner, it's sufficient to think of them as monads)
02:13:16 <mm_freak> > (+) <$> Just 3 <*> Just 4
02:13:18 <lambdabot>   Just 7
02:13:44 <merijn> :t (<*>)
02:13:47 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
02:14:08 <mm_freak> > replicate <$> Just 15 <*> Just 'a'
02:14:10 <lambdabot>   Just "aaaaaaaaaaaaaaa"
02:14:26 <merijn> no-n: You can think of Applicatives as "A functor where you can apply an argument to a function inside that functor"
02:14:54 <no-n> hmm, okay :)
02:15:08 <no-n> the chapter I'm up to in lyah is about this stuff
02:15:28 <no-n> haven't really started it though ;p
02:15:40 <mm_freak> no-n: keep it simple…  you have a (Int -> Char -> [Char]), a Maybe Int and a Maybe Char
02:15:44 <mm_freak> and you want a Maybe [Char]
02:15:57 <mm_freak> > replicate <$> Just 15 <*> Just 'a'
02:15:59 <lambdabot>   Just "aaaaaaaaaaaaaaa"
02:16:03 <mm_freak> that's what <*> is about =)
02:16:41 <no-n> =)
02:17:18 * hackagebot clay 0.6 - CSS preprocessor as embedded Haskell.  http://hackage.haskell.org/package/clay-0.6 (SebastiaanVisser)
02:19:54 <Lethalman> no-n, <*> is function application but within functor
02:20:07 <Lethalman> :t <$>
02:20:10 <lambdabot> parse error on input `<$>'
02:20:14 <Lethalman> :t ($)
02:20:17 <lambdabot> (a -> b) -> a -> b
02:20:21 <Lethalman> :t <*>
02:20:24 <lambdabot> parse error on input `<*>'
02:20:25 <Lethalman> :t (<*>)
02:20:28 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
02:20:42 <Lethalman> no-n, ^^ see same signature except for the functor
02:52:19 * hackagebot Strafunski-ATermLib 1.6.0.3 - An abstract data type designed for the exchange of tree-like data structures  http://hackage.haskell.org/package/Strafunski-ATermLib-1.6.0.3 (JamesKoppel)
02:59:58 <Jaxan> I have a question about the monad transformers. I want to have two statefull operations, and combine them, like this: http://hpaste.org/87134. But this doesn't compile (Couldn't match expected type `State Int'    with actual type `Data.Functor.Identity.Identity), because g has the wrong type
03:00:03 <Jaxan> How would I achieve this?
03:02:27 <Jaxan> I feel like missing something abvious...
03:04:48 <k00mi> Jaxan: the base monad for g is Identity, while for both it is (State Int)
03:05:03 <k00mi> just make g :: Monad m => StateT String m Int
03:05:07 <Jaxan> k00mi: So I should make g more general?
03:05:16 <Jaxan> like g :: StateT String m Int ?
03:05:19 <Jaxan> oh ha
03:05:37 <k00mi> don't forget the monad constraint
03:05:38 <mauke> StateT Strong mInt
03:06:12 <Jaxan> So it would be wise to do this with all functions which use State?
03:06:55 <Jaxan> (and why can't haskell infer this constraint :(, clean does it ;D.)
03:07:04 <Jaxan> k00mi: thanks :)
03:07:20 * hackagebot Strafunski-Sdf2Haskell 1.0.0.2 - Converts SDF to Haskell  http://hackage.haskell.org/package/Strafunski-Sdf2Haskell-1.0.0.2 (JamesKoppel)
03:07:55 <k00mi> it won't hurt, but if it's a concrete function usually State is good enough
03:12:11 <merijn> Jaxan: Haskell can infer the constraint, as long as you don't specify a type at all
03:12:25 <merijn> Jaxan: If you specify the type, you have to specify *all* of it
03:13:06 <Jaxan> ah ok, makes sense
03:13:37 <merijn> (Man, I wish Haskell had type holes and constraint holes, that'd be great!)
03:14:08 <Jaxan> or that every monad is also a functor -.-
03:14:44 <Ghoul_> how can I repeat a function (monadic) n times
03:15:16 <mauke> what is a monadic function and what does it mean to repeat a function?
03:15:18 <Ghoul_> and have the result of each run stored in a list
03:15:29 <merijn> :t replicateM
03:15:31 <lambdabot> Monad m => Int -> m a -> m [a]
03:15:39 <Ghoul_> Does replicate evaluate the function though?
03:15:45 <Ghoul_> It doesn't guarantee to give the same result each time
03:16:21 <merijn> replicateM is just "replicateM n = sequence . replicate n"
03:16:29 <mauke> evaluating a function does give you the same function each time
03:17:25 <Ghoul_> mauke: its a function applying the Parser monad
03:18:06 <mauke> what
03:18:18 <mauke> stop making things up
03:19:24 <Jaxan> There is `mapM :: Monad m => (a -> m b) -> [a] -> m [b]` and `mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)`, who does the first one exist?
03:19:48 <quicksilver> Jaxan: history.
03:20:09 <Jaxan> history sucks :(, stupid ambiguouties...
03:20:15 <Jaxan> but it's nice that there is mapM :D
03:20:49 <quchen> Jaxan: mapM is redundant due to traverse. :P
03:21:10 <Jaxan> oh I see ;D
03:21:12 <Jaxan> awesome
03:21:17 <merijn> :t traverse
03:21:19 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
03:21:52 <mauke> it's a traversity
03:22:57 <Jaxan> and we can derive Traversable?
03:23:38 <merijn> Jaxan: With an extension, I think?
03:23:53 <Jaxan> hmm I need Foldable first
03:27:45 <quchen> This reminds me of that I should learn about Generic.
03:27:52 <cinimod> @seen dcoutts
03:27:53 <lambdabot> Unknown command, try @list
03:27:57 <cinimod> @list
03:27:58 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
03:28:03 <quchen> ?seen dcoutts
03:28:04 <lambdabot> Unknown command, try @list
03:28:45 <cinimod> seen dcoutts
03:28:50 <typoclass> preflex: seen dcoutts
03:29:20 <typoclass> cinimod: another bot provides that function, but apparently it's not here today
03:29:45 <merijn> quchen: I recently saw a decent talk on Generic, but I'm not sure I remember the link
03:30:22 <quchen> merijn: Sounds great, if you find the URL let me know!
03:31:18 * quchen just googled "generic haskell talk"
03:32:25 <typoclass> cinimod: anyway, he was here yesterday :-) http://ircbrowse.net/browse/haskell?q=dcoutts
03:34:58 <akamaus> hi, did anyone compile haste (haskell -> js compiler) with ghc-7.6?
03:35:50 <merijn> quchen: http://skillsmatter.com/podcast/home/a-haskell-lecture-with-leading-expert-andres-loh/te-6918
03:36:12 <kosmikus> merijn: glad you like it :)
03:37:15 <merijn> You should always be positive about haskell talks and papers in here, because you never know when those sneaky presenters/authors sneak up on you in here :p
03:39:34 <quchen> merijn: Ah, that was my first Google hit.
03:39:45 <quchen> Now that it's got your seal of quality it's bookmarked. :-)
03:51:31 <schoppenhauer> Hello. http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/ext-core.html says "Currently (as of version 6.8.2), GHC does not have the ability to read in External Core files as source.". Does this still apply?
03:52:06 <quicksilver> I believe it odes.
03:52:23 <schoppenhauer> meh.
03:53:27 <Darkproger> is it possible to ignore 'thread blocked indefinitely in an MVar operation'?
03:53:28 <schoppenhauer> thx.
03:53:44 <Darkproger> i'd like to make the main thread sleep until everything else works
03:54:17 <quicksilver> Darkproger: if you want it to sleep forever, you can just do forever (threadDelay 10000000) ?
03:54:52 <t7> has anyone read 'making ad-hoc polymorphism less ad hoc' ?
03:55:23 <Darkproger> i thought there was a cleaner way than just a sleep loop :)
03:55:48 <mauke> forever $ threadDelay maxBound
03:57:22 * hackagebot grid 5.0 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-5.0 (AmyDeBuitleir)
04:03:06 <byorgey> t7: I read it a long time ago
04:04:15 <merijn> Darkproger: What do you mean by "until everything else works"?
04:05:24 <t7> byorgey, I thought the rules for OVER and INST would introduce predicates, but i think its only GEN that will give a type scheme (with predicates) right?
04:05:42 <t7> if you can remember :)
04:08:24 <byorgey> t7: I don't remember enough to be able to answer that question quickly, sorry =)
04:08:58 <t7> somebody make a hindley-milner channel
04:09:01 <t7> +damas
04:12:53 <mo1> What does eg 'String -> Int' means in 'type TT = String -> Int'
04:13:08 <danr> it means when you see TT in the program, it really means String -> Int
04:13:14 <danr> it's just a type synonym
04:13:30 <danr> (when you see TT at the type level (i.e in a type signature))
04:13:38 <typoclass> mo1: it's a function from String to Int. it takes a String and gives you an Int
04:13:59 <mo1> and if i have newtype TT = String -> Int, it is still a function from String to Int
04:14:01 <typoclass> mo1: by the way, lyah is a good book that you can read online :-)
04:14:04 <typoclass> @where lyah
04:14:05 <lambdabot> http://www.learnyouahaskell.com/
04:14:10 <mo1> lyah ?
04:14:12 <merijn> mo1: No, then it's a syntax error
04:14:29 <merijn> mo1: Newtype's require exactly one constructor
04:14:30 <mo1> merijn: did i miss a constructor
04:14:37 <mo1> Thanks guys
04:14:39 <mo1> ^^=
04:15:27 <ramses_> t7: doesn't PRED introduce predicates?
04:16:08 <t7> yes its does... when is it used though?
04:16:14 <ramses_> I read that paper a while ago, but I'm not too familiar with this stuff yet, so I might not be of much help
04:21:14 <t7> @tell bitonic have you read 'making ad-hoc polymorphism less ad hoc' ?
04:21:15 <lambdabot> Consider it noted.
04:21:21 <ramses_> t7: have you tried doing the derivation from fig.6 to fig.11? That might shed some light.. otherwise I can't immediately tell either
04:21:48 <t7> no i should go through that
04:23:55 <ramses_> I guess pred is used to remove the predicate when doing the derivation, right? given that you have a suitable dictionary in the context
04:25:27 <fryguybob> t7: Yes, real people use STM in real life.
04:25:44 <sgronblo> So I would be very happy if somebody could help me figure out how to get my "generic google code jam solver" to work.
04:26:28 <sgronblo> I am trying to define two classes in the solver module, one Parser class and one InputCase class.
04:27:07 <sgronblo> But I can't really figure out how to tie the case and parser together
04:27:39 <sgronblo> To make Haskell understand that the instantiating parser produces inputcases of the related type so that it can call solve on them
04:36:52 <typoclass> sgronblo: do you have any code that you could post on hpaste.org? be sure to include the relevant compiler error messages
04:39:48 <sgronblo> typoclass: Yeah I could hpaste it. I'm just going through the slides for Eric Meijers parsing lecture again to see if I can get some inspiration.
04:40:43 <Ghoul_> Can anyone suggest ways to golf or optimize this code? http://hpaste.org/87139
04:41:10 <Iceland_jack> Ghoul_: liftM2 (:)
04:41:26 <Ghoul_> :t liftM2
04:41:28 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
04:41:35 <Iceland_jack> @src liftM2
04:41:35 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
04:41:37 <sgronblo> Ah in this presentation a parser is simply a function like I considered doing it initially, but then I switched to trying to put the function inside of a typeclass instead.
04:42:29 <Iceland_jack> so: liftM2 (:) m1 m2 is really: do cind ← m1; after ← m2; retrun $ cind : after
04:42:40 <sgronblo> But I think this code is not meant to generalize the parsing itself like I am trying to do.
04:42:54 <merijn> Ghoul_: FYI you can start a do block on the right of <-
04:43:39 <Ghoul_> Hmm, still processing the liftM2 thing
04:43:48 <merijn> Ghoul_: The single long line is a bit ugly
04:44:17 <Ghoul_> if then else was my poor excuse for not knowing how to use a recursion function to handle that countdown properly
04:45:01 <Ghoul_> OH I just got the relevance of liftM2
04:45:04 <Ghoul_> thanks Iceland_jack !
04:45:10 <Iceland_jack> No problem
04:45:14 <hpaste> merijn annotated “Build smarter not harder” with “Alternative way to write the same” at http://hpaste.org/87139#a87140
04:45:19 <Iceland_jack> Ghoul_: also note that you're basically counting down from n to 1
04:46:13 <merijn> Ghoul_: Also, might want replicateM
04:46:15 <Iceland_jack> so instead of recursing on that parameter, you can generate a list from [n,n-1..1] and do some work on that
04:46:16 <merijn> :t replicateM
04:46:18 <lambdabot> Monad m => Int -> m a -> m [a]
04:46:19 <Iceland_jack> right
04:46:39 <merijn> replicateM 2 {- your parser -}
04:47:41 <Ghoul_> merijn: the reason I didn't use replicateM was because I couldn't wrap my head around how to do an interesting piece of logic I have going on there
04:48:08 <b__> can I create a ByteString from a Word16?
04:48:13 <merijn> ah, right
04:48:22 <Ghoul_> where the next parser only becomes valid if the previous has the comma after it
04:48:48 <Ghoul_> so I'd need a way to exit out of the replicate or a replicate with a predicate or something like that
04:49:38 <Ghoul_> I do like the more vertical one better than my long line -- thanks
04:50:02 <b__> ah with Put
04:50:27 <merijn> Ghoul_: "foo $ do" is a nice pattern to use
04:54:19 <Ghoul_> is there a way to repeat an action a certain # of times unless it somehow fails
04:54:39 <Ghoul_> Like, a fold or map function with a predicate
04:55:01 <typoclass> Ghoul_: takeWhile? filter?
04:56:14 <Ghoul_> typoclass: thanks, both of those are useful :)
04:57:10 <mauke> Ghoul_: use a monad that supports throwing exceptions?
04:58:27 <Ghoul_> I think I can use takeWhile and replicate (and abuse laziness). I'm testing it out now
05:00:15 <byorgey> "abuse" laziness?
05:00:28 <Ghoul_> /s/abuse/use
05:00:33 <byorgey> =)
05:01:36 <eikke> related to the thread about backward compat on Cafe: wouldn't having something like Coccinelle for Haskell help here?
05:02:39 <eikke> so when a new version of base (and whatnot) is released, a semantic patch is delivered with it
05:02:55 <typoclass> eikke: do you mean this? http://coccinelle.lip6.fr/
05:03:00 <eikke> to ease upgrade paths and reduce boring manual boilerplate work
05:03:32 <eikke> typoclass: yes ( http://en.wikipedia.org/wiki/Coccinelle_(software) )
05:03:48 <eikke> I read some GSoC proposal of an 'AST-aware refactoring tool for Haskell', that could work as well
05:06:52 <eikke> I imagine using such tool automatic pull requests could be generated for packages hosted on GH/BB as well
05:06:54 <eikke> and whatnot
05:07:30 <Ghoul_> I think Data.Maybe is missing foldMaybe
05:07:45 <merijn> Ghoul_: See also monad-loops
05:07:49 <eikke> Ghoul_: what would that do?
05:07:54 <Ghoul_> it has a few utils, including mapMaybe, but foldMaybe would be useful
05:07:59 <quicksilver> maybe itself is not recursive
05:08:01 <Ghoul_> foldMaybe would fold until Nothing is returned and then break out
05:08:02 <merijn> eikke: Presumably the same the stuff in monad-loops does :p
05:08:11 <Ghoul_> uh, how do I monad loop
05:08:41 <merijn> @hackage monad-loops
05:08:42 <lambdabot> http://hackage.haskell.org/package/monad-loops
05:08:57 <merijn> Something like whileJust or something?
05:09:19 <Ghoul_> Just saw that one, thanks :) whileJust is perfect
05:10:50 <merijn> Because writing code for your programs is for imperative suckers :p
05:13:27 <Ghoul_> some of the stuff I see here amazes me :P
05:13:51 <Ghoul_> people can lego together huge things into very small clever function composition
05:14:04 <Ghoul_> /s/some/all
05:18:40 <dmwit> Ghoul_: See also
05:18:42 <dmwit> :t unfoldr
05:18:44 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
05:18:48 <dmwit> perhaps?
05:23:07 <Ghoul_> dmwit: that's very helpful, thanks
05:23:21 <Ghoul_> Infact, I think it prototypes my existing function almost exactly
05:24:12 <eikke> there's quite a difference between a fold and an unfold, no?
05:26:41 <Eduard_Munteanu> eikke: they're opposite things
05:27:08 <eikke> Eduard_Munteanu: I know :) point it that Ghoul_ was asking for foldMaybe before, but now seems to look for unfoldr
05:27:15 <Eduard_Munteanu> eikke: folds collapse lists to a value, while unfolds generate a list from a seed
05:27:28 <Eduard_Munteanu> Ah.
05:29:51 <k00mi> you could simulate the unfold by folding a list generated with iterate, right?
05:31:03 <Eduard_Munteanu> k00mi: yeah
05:31:15 <applicative> k00mi: you mean the unfold function? hm
05:31:58 <k00mi> applicative: yes
05:32:55 <JigxorAndy> would anyone be able to point me in the direction of a tutorial to simply store an Int in a State monad and retrieve it ?
05:33:25 <Botje> runState (put 42 >> get) 5
05:34:23 <Eduard_Munteanu> flip runState 5 $ do ...     is a common form if you want to use do notation
05:35:11 <JigxorAndy> hmm
05:35:13 <JigxorAndy> thank you
05:35:16 <gelisam> hi! I want to represent something like Hoare triples in Haskell. Is there a library I need to look into, or should I roll my own?
05:37:15 <applicative> k00mi: I was looking for such a thing in http://www.cs.ox.ac.uk/jeremy.gibbons/publications/origami.pdf but dont quite see it.  It is noted from time to time, I feel.
05:39:21 <gelisam> I was thinking of something like
05:39:21 <gelisam> typeclass Hoare p q a where
05:39:21 <gelisam>   skip :: a -> Hoare p q a
05:39:21 <gelisam>   (>>.) :: Hoare p q a -> (a -> Hoare q r b) -> Hoare p r b
05:39:45 <Eduard_Munteanu> s/type//
05:40:15 <byorgey> gelisam: you might want to look for a library for indexed monads.  There are several, I think, but not sure what their status is
05:40:16 <Eduard_Munteanu> gelisam: wait... that's an indexed monad
05:40:37 <gelisam> "indexed monad", thanks! I'll look it up
05:40:45 * typoclass . o O ( ... magnificent stereo ... )
05:41:25 <k00mi> applicative: I was saying that in response to eikke's comment, but that looks interesting, thanks :)
05:45:43 <hiptobecubic> Maybe i'll have more luck here. I have a sequence that I defined programmatically. I want to discuss it in a math paper i'm writing, but I don't know how to *write* about it
05:45:59 <sm> #if MIN_VERSION_directory(1,2,0)time cabal-dev install hledger-web --dry
05:46:16 <hiptobecubic> for example how would i say something like  "sequence x is sequence y minus the min of y"
05:46:40 <sm> oops.. morning all. How do you make  "#if MIN_VERSION_directory(1,2,0)" acceptable to haddock ?
05:46:48 <applicative> k00mi: yeah, I was just wondering about it
05:47:07 <hiptobecubic> x = map (subtract (min y)) y -- but in "traditional" looking math notation and not haskell
05:47:49 <hiptobecubic> x_i = y_i - min(y_j), j \in [0, n] ?
05:48:04 <hiptobecubic> and also i \in [0, n}
05:48:04 <hiptobecubic> n]*
05:48:15 <applicative> oh gelisam vanished before we could tell him or her about 'the kleisli arrows of outrageous fortune' :(
05:49:21 <applicative> is the css or something wrong on the parallel/concurrent haskell site http://ofps.oreilly.com/titles/9781449335946/sec_par-strategies.html
05:50:44 <applicative> oh if i view it as for 'mobile' the lines are less than 1000 words long ....
05:52:05 <Ghoul_> > Nothing >>= Just 1
05:52:08 <lambdabot>   Couldn't match expected type `a0 -> Data.Maybe.Maybe b0'
05:52:08 <lambdabot>              with ...
05:52:18 <Ghoul_> > Just 2 >>= Just 1
05:52:19 <sm> ah, by adding: --optghc='-optP-include' --optghc='-optPhledger/dist/build/autogen/cabal_macros.h'
05:52:20 <lambdabot>   Couldn't match expected type `a0 -> Data.Maybe.Maybe b0'
05:52:21 <lambdabot>              with ...
05:52:34 <applicative> > Nothing >>= Just
05:52:38 <lambdabot>   mueval-core: Time limit exceeded
05:52:41 <FireFly> @ty (>>=)  -- surely the right operand can't be `Just 1`
05:52:43 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:52:50 <applicative> > Just 1 >>= Just
05:52:52 <lambdabot>   Just 1
05:53:05 <applicative> >> Just 1 >> Just 2
05:53:09 <applicative> > Just 1 >> Just 2
05:53:12 <lambdabot>   Just 2
05:53:35 <Mortchek> I want to write my own instance but it would be a duplicate. How can I make the other one go away?
05:53:41 <Ghoul_> Is there something that expresses the logic "If the last thing I did wasn't Nothing, return the next thing, else return nothing"
05:53:56 <Mortchek> I'm doing this for learning purposes, so I'll probably be writing one that has the same behavior.
05:53:59 <applicative> Mortchek: you can't, is the short answer.
05:54:12 <applicative> oh, then just keep it out of scope
05:54:22 <Mortchek> It's declared by the same module as the class I want.
05:54:42 <applicative> or is the instance in the the module that defines the class to start with?
05:54:45 <Mortchek> Yes.
05:54:49 <applicative> woops
05:55:34 <Mortchek> Hmm, I suppose I could write the class declaration myself as well.
05:55:39 <Mortchek> Thanks, applicative.
05:55:45 <applicative> its viewed as irksome, but theres no mechanism for hiding them
05:56:33 <applicative> yes, I was thinking either an equivalent class or isomorphic type. The standard procedure when this is a 'real' program or whatever is of course newtyping
05:56:38 <Ghoul_> :t (>>?)
05:56:40 <lambdabot>     Not in scope: `>>?'
05:56:40 <lambdabot>     Perhaps you meant one of these:
05:56:40 <lambdabot>       `>>=' (imported from Control.Monad.Writer),
05:57:18 <Ghoul_> Does >>? exist
05:57:26 <Ghoul_> or is it something real world haskell defined somewhere
05:57:46 <applicative> By now I think every 3 char combination has been take at least once....
05:58:05 <Taneb> $&%
05:58:10 <Ghoul_> lol
05:58:12 <applicative> What library are they talking about?
05:58:44 <applicative> Taneb, yeah that's flip const
05:58:48 <Taneb> Bah
05:58:51 <Ghoul_> haha
05:59:01 <Ghoul_> And dw, it doesn't exist -- hoogle can't find it.
05:59:11 <Taneb> Ghoul_: hoogle doesn't do every package
05:59:13 <Taneb> Try Hayoo
05:59:32 <applicative> > let ( $&%) = flip const in 1 $&% 2
05:59:34 <lambdabot>   2
06:01:30 <applicative> @type (<?>)
06:01:35 <lambdabot>     Not in scope: `<?>'
06:01:35 <lambdabot>     Perhaps you meant one of these:
06:01:35 <lambdabot>       `<>' (imported from Data.Monoid),
06:01:43 <applicative> :(
06:01:50 <dmwit> eikke: One type's fold is another's unfold.
06:02:10 <dmwit> A fold for X can produce any type; an unfold for X can consume any type.
06:03:53 <applicative> dmwit: i think that means, one type's fold is any type's unfold ?
06:04:27 <dmwit> Your statement implies mine. =)
06:04:50 <applicative> yes, I was going with the stronger
06:22:50 <yezariaely> How can I combine several pattern matchings for a function? e.g. myFun (Ctor1 c) = c \n myFun (Ctor2 c) = c  and I want myFun (Ctor1/2 c)  = c
06:23:06 <Mortchek> Wasn't there an article that suggested that the notion that typeclasses are like Java interfaces was wrong? If so, what was it called / what is the url?
06:23:39 <byorgey> yezariaely: you can't
06:23:46 <merijn> Mortchek: There was, but I don't remember the URL, I can give you the executive summary, if you like
06:24:09 <Mortchek> merijn, I'm really more interested in the url so I can share it.
06:24:12 <yezariaely> byorgey: hmm really? Thought that worked somehow. Thanks
06:25:00 <Mortchek> merijn, actually, go ahead, maybe it'll include some key terms.
06:25:08 <shelf> i'd love an executive summary
06:25:10 <shelf> of that
06:27:12 <merijn> 1) Java interfaces don't support defining values (for example, minBound/maxBound) 2) Java interfaces can only be polymorphic in the arguments, not in the result (see Read) 3) You can't have interfaces that are polymorphic in two different types (i.e. MultiParameterTypeClasses)
06:27:36 <typoclass> yezariaely: if the situation is "f (Ctor1 ...) = complicatedExpression ; "f (Ctor2 ...) = complicatedExpression", it might help to do "c = complicatedExpression" ...
06:27:44 <Eduard_Munteanu> I guess 1 can be worked around using a phony parameter?
06:28:25 <Eduard_Munteanu> But minBound/maxBound are actually instances of problem 2 too.
06:28:26 <typoclass> Eduard_Munteanu: you could always call a functionWithNoArgs()
06:28:30 <yezariaely> typoclass: that is exactly what I just wrote. Thing is that there are many variables, so it ends up like c a b c d e f = complicated expression :/
06:30:27 <typoclass> yezariaely: by the way, feel free to put something on hpaste.org if you want :-) it's a bit hard to discuss this in the abstract
06:31:17 <hpaste> yezariaely pasted “Case combination” at http://hpaste.org/87147
06:31:25 <yezariaely> typoclass: there you go.
06:31:54 <yezariaely> so the only difference between line 4 and 5 is TT instead of TNT
06:33:28 <typoclass> Mortchek: here is a link to the blog post + some #haskell discussion http://ircbrowse.net/browse/haskell?id=15533351&timestamp=1366399234&events_per_page=100#t1366399234
06:34:07 <Mortchek> merijn, typoclass, thanks!
06:34:41 <typoclass> Mortchek: (just to be sure, i don't entirely agree with the blog post myself. it's all a bit exaggerated, and maybe not phrased very clearly)
06:34:42 <merijn> I think the entire "nothing like interfaces" thing is a bit overstated
06:34:55 <typoclass> merijn: yup, absolutely
06:35:48 <typoclass> Mortchek: anyway, one certain difference is that interfaces are types, but typeclasses aren't types
06:36:15 <typoclass> ... not sure how relevant that is going to be in practice
06:36:34 <merijn> It is if you're going to use fancy stuff like ConstraintKinds :p
06:40:45 <typoclass> merijn: i was thinking about "SomeInterface foo() { ... }", which afaik is possible in java. "foo :: SomeTypeclass" is not possible in haskell, but there's of course "foo :: (SomeTypeclass a) => a". on some level, you could consider it a minor syntactic thing
06:41:46 <typoclass> merijn: the remaining difference is of course that in java, foo will choose what to return (as long as it implements SomeInterface), while in haskell, foo's caller will choose that. but i guess that's just haskell's polymorphism
06:42:26 <merijn> typoclass: That's point two of my earlier remark
06:42:42 <merijn> Java can only be polymorphic in the interface arguments, not the results
06:43:20 <typoclass> merijn: ah right. you mean "polymorphic" as in "caller chooses types"
06:46:40 <ptek> Hi guys, I need help with my cabal file. We have 7 executables in our project and a long list of library dependencies (53 in total) for each of them. I wonder if it is possible to specify the common dependencies only once (as shown for HUnit here: http://www.haskell.org/cabal/users-guide/developing-packages.html#example:-a-package-containing-a-library-and-executable-programs) or does one always have to repeat the dependencies for each executable? If I do
06:46:42 <ptek>  something like the code in example, cabal complains about missing package base
06:50:38 <typoclass> ptek: i think newer cabal versions allow an executable that depends on a library that is defined in the same *.cabal file. not sure what the first version was which supported that. you could do "library L ... build-depends: ... 53 thingies ..." and then "executable E1 build-depends: L", "executable E2 build-depends: L", etc.
06:50:58 <typoclass> ptek: this is a wild idea :-) not sure if that even makes sense
06:51:23 <ptek> typoclass: I try the following: https://gist.github.com/ptek/3025b45973c8d461857d
06:52:16 <typoclass> ptek: oh yes, i think that's what i mean. does cabal accept that?
06:52:17 <ptek> And get the error:
06:52:19 <ptek>     Could not find module `Prelude'
06:52:21 <ptek>     It is a member of the hidden package `base'.
06:52:32 <ptek> for one of the executables
06:52:46 <ptek> can I name the library?
06:53:21 <ptek> no :) library expects no argument
06:53:53 <ghorn> is it normal to use Text.XML.Light to parse a 50MB xml file and see 4GB of memory usage?
06:54:19 <supki> ptek: no, all sections must list all their dependencies
06:55:52 <ptek> supki: typoclass: I see. Its a pity… It gets complicated to manage on the long run…
06:56:07 <ptek> supki, typoclass - thank you anyway!
06:56:08 <typoclass> ptek: right, i was thinking wrong. if executable E1 depends on library L, which depends on D, then E1 can't just use D
06:57:15 <dmwit> ptek: I have a cunning plan.
06:57:36 <ptek> typoclass: it makes sense now as I think of it… Would be really bad to get all the dependencies of the 53 libraries populated for my own code
06:57:36 <latermuse> ghorn: that looks like a memory leak
06:58:17 <ptek> dmwit: tell me :)
06:59:04 <dmwit> ptek: Make a library with 53 dependencies, and modules re-exporting everything from those dependencies. e.g. module Ptek.Data.List (module Data.List) where import Data.List
06:59:50 <ghorn> latermuse: I don't think the leak is on my end, I'm loading the file with Text.IO ( readFile ) and calling Text.XML.Light ( parseXML ), filtering the list of elements in a simple way, and printing out the length
07:01:10 <ptek> dmwit: hrm. sounds complicated too actually… But maybe worth a try.
07:01:32 <dmwit> please don't; it was meant as a joke
07:02:06 <typoclass> what is this syntax? "module Ptek.Data.List (module Data.List) where"
07:02:14 <dmwit> It's Haskell.
07:02:34 <byorgey> it's a module which re-exports another module
07:02:36 <typoclass> dmwit: urgh wait, that's just the export list
07:02:37 <dmwit> It re-exports every name that's available both unqualified as foo and qualified as Data.List.foo.
07:02:39 <typoclass> thanks
07:03:44 <ptek> dmwit :)
07:04:41 <latermuse> ghorn: your filter might be causing the leak. post your code on hpaste
07:04:43 <dmwit> "I hate managing 53 package dependencies. You know what would be better than that? Managing 258 module dependencies!" ;-)
07:08:29 <hiptobecubic> if [1..] is a linear space, what kind of space is   map (** (1/p)) [1..]
07:08:53 <hiptobecubic> I would say "a pth root space"
07:09:14 <hiptobecubic> But that seems like the kind of thing someone would say when they don't know what they are talking about
07:09:20 <hiptobecubic> :)
07:09:46 <hpaste> ghorn pasted “xml memory leak?” at http://hpaste.org/87149
07:11:03 <yezariaely> does the deriving (Eq) statement create an Eq what one would expectc?
07:11:20 <mauke> yes, but only if your expectations are correct
07:11:22 <yezariaely> i.e. Something is equivalent if all parts are equivalent and such? structural equivalency?
07:11:25 <Cale> yezariaely: yes
07:11:27 <mauke> yes
07:11:29 <yezariaely> thx
07:11:35 <ghorn> latermuse: my main just calls "loadXML" with a filename and then returns ()
07:12:03 <Cale> yezariaely: and deriving Ord gives you a lexicographical ordering of sorts
07:12:14 <simpson> yezariaely: The report's language is helpful here: http://www.haskell.org/onlinereport/derived.html
07:12:26 <yezariaely> Cale: thx, I don't need it right now ;-)
07:12:33 <yezariaely> but good to know
07:12:57 <yezariaely> simpson: ah very nice. Was looking for something like that.
07:13:03 <Cale> (where the constructors are ordered how they're listed in the data declaration, and then matching constructors are compared by comparing each of the components in turn, and taking the first result where they're not equal)
07:14:04 <yezariaely> can one create the instance from a deriving (...) somehow? e.g. code?
07:14:23 <simpson> You mean, can you write it yourself?
07:14:37 <yezariaely> hmm bad sentence: Can one generate the code that would be equivalent to the automatically generated derivation
07:14:47 <latro`a_> sure
07:14:55 <latro`a_> tedious, but straightforward
07:15:18 <latro`a_> Foo x == Foo y = x == y
07:15:21 <simpson> Ah. Yes, but I'm not sure if there are any standalone tools that do it for the builtin typeclasses like Eq. Maybe DERIVE can do it?
07:15:24 <latro`a_> all the way down the constructor list
07:15:33 <latro`a_> then _ == _ = False
07:15:35 <latro`a_> at the bottom
07:15:40 <facepalm> http://hpaste.org/87156
07:15:43 <facepalm> I am trying to write a function targetShip but having difficulty getting it to work. i am probably thinking of it wrong. it is to accept a Ship and target address as its 2 params if ship has a cell with target address  that cell is marked sunk. updated cversion of the ship is returned if ship is empty empty ship returned
07:16:00 <donri> yezariaely: you can see what ghc generates with some -ddump flag, see man ghc
07:16:12 <typoclass> yezariaely: how about passing the -ddump-deriv switch to ghc?
07:16:17 <yezariaely> ah, sure. thank you all!
07:16:27 <donri> that's the one
07:17:26 <Cale> facepalm: btw, probably areSunk = all isSunk
07:17:50 <dmwit> facepalm: You know you don't have to name the type of the patterns on the left-hand side of an equality, right?
07:17:56 <Cale> facepalm: I think the first thing you should do for targetShip is to work out precisely which type signature it should have
07:18:56 <facepalm> i did nt know that dmwit
07:19:47 <facepalm> Cale: for type sig it is targetShip :: Ship and i am not sure what target address is..is it just Address?
07:20:23 <Botje> targetShip :: Ship says that "targetShip is of type Ship"
07:20:25 <facepalm> maybe just a pair (Int, Int)
07:20:31 <Botje> I thought you said it needed to be a function?
07:20:55 <facepalm> it does. These last 4 are all functions
07:21:02 <Cale> If targetShip is a Ship, then it's always the same Ship :)
07:21:12 <Botje> facepalm: if there's no -> in the type, it's not a function.
07:21:14 <Chousuke> facepalm: so then its type can't be Ship
07:22:06 <Cale> facepalm: So, one thing which would help me help you is to know that the Bool inside of each Cell means.
07:22:11 <Cale> what*
07:22:51 <Cale> Is that roughly "whether or not that cell has been attacked"?
07:22:59 <facepalm> I think the bool is used for the issunk function
07:23:14 <facepalm> because if there is a hit then the cell will be marked
07:24:02 <acube> There are a lot of available FRP libraries (netwire, reactive banana just to name some). What are the differences between those?
07:25:12 <Cale> facepalm: Okay, so targetShip is probably going to take an address which is being targeted, and a Ship, and produce another Ship as its result.
07:25:29 <Cale> facepalm: which would mean  targetShip :: Address -> Ship -> Ship
07:26:04 <facepalm> and i wont have to declare a bool in there correct? because its already apoart of Ship
07:26:23 <Cale> facepalm: and the idea is that if a Cell with the given address occurs in the Ship, then we have to mark it.
07:26:48 <Cale> (I think!)
07:28:05 <Cale> Personally, I think it'd just be a bit easier to represent ships by lists of addresses, and delete addresses from the ships as they're attacked. You could keep the information about which locations had been attacked in the past somewhere else (and probably have to anyway)
07:28:12 <facepalm> yeah if ship has a cell with the target address then it marked
07:29:11 <Cale> facepalm: So, without changing the design of the program here, I would recommend writing the resulting list of cells in the new ship using a list comprehension:
07:29:16 <dmwit> Cale: That might not be so good if you wanted to render the ships on-screen differently from empty spaces or something. =)
07:30:26 <Cale> dmwit: yeah, it really depends to some extent on what you're displaying -- it'd always be possible to hang on to the initial locations of the ships separately somewhere for that purpose of course, and just keep the remaining locations in the game state because that's what matters for evaluating who wins
07:32:07 <facepalm> do i need some sort of if statement
07:32:14 <Cale> facepalm: So we'll have   targetShip loc ship = [(addr, ...) | (addr, hit) <- ship]  -- where we need to fill in the ... with something
07:32:15 <facepalm> or bool expression
07:32:44 <facepalm> i forget what is the <- I haven't used it a whole lot
07:33:04 <Cale> That means that we're drawing the pairs (addr, hit) from the list ship
07:33:16 <Cale> ship is a list of pairs of addresses and boolean values
07:33:17 <facepalm> and the ... ?
07:33:24 <Cale> the ... is something for us to fill in
07:33:33 <facepalm> oh haha okay
07:33:35 <Cale> (this isn't done yet)
07:33:47 <facepalm> it wouldnt suprise me if it was syntax in haskell lol
07:34:10 <Hermit> it could be defined...
07:34:45 <facepalm> oh i see your comment next toit now saying exactly that sorry
07:35:46 <facepalm> wont that need to be a bool
07:35:53 <Cale> that's correct
07:36:31 <Cale> This boolean value is supposed to represent whether the ship is hit at the address addr
07:36:47 <facepalm> so isHit?
07:36:48 <Cale> Of course, if it's already hit there, we're not going to change that, so:
07:36:59 <Cale> targetShip loc ship = [(addr, hit || ...) | (addr, hit) <- ship]
07:37:06 <Cale> || means "or"
07:37:37 * hackagebot simplex 0.3.5 - A simple markup language that translates to LaTeX  http://hackage.haskell.org/package/simplex-0.3.5 (JulianFleischer)
07:37:40 <Cale> We want it to be hit there if either it was already hit, or if addr is equal to the location we're targetting
07:37:45 <facepalm> is that an additional case or a revised of the previous one
07:37:49 <Cale> i.e. if addr == loc
07:37:55 <Cale> revised
07:38:10 <Cale> This is going to be a one line function :)
07:38:37 <Cale> targetShip loc ship = [(addr, hit || addr == loc) | (addr, hit) <- ship]
07:39:15 <Cale> So this says the new ship is hit at the location addr when either the old ship was hit at addr, or addr == loc
07:40:06 <facepalm> this breaks so let me look at it again to see why
07:40:39 <facepalm> Couldn't match expected type `Ship' with actual type `[t0]'
07:41:14 <Cale> facepalm: ... are your type declarations still the same as the ones in your paste?
07:41:29 <Cale> facepalm: In your paste, you have  type Ship = [Cell]
07:41:43 <Cale> and so  Ship and [t0]  should unify with t0 = Cell
07:41:45 <facepalm> no I changed it to targetShip :: Address -> Ship -> Ship
07:41:58 <Cale> I mean the declarations of your data types
07:42:05 <Cale> The definition of Ship, especially
07:42:22 <facepalm> oh i changed it back to the data ones
07:42:33 <Cale> okay...
07:42:41 <facepalm> because doig the type it wouldnt let me put the derive statement in it
07:43:00 <Cale> You wouldn't have to derive any instances for type synonyms
07:43:46 <facepalm> oh i need to use data then because I am supposed to be using deriving
07:44:35 <Cale> Okay, well, paste your updated definitions, and we'll alter the definition of the function to pattern match away and produce the constructors appropriately.
07:45:30 <hpaste> facepalm revised “haskell function”: “haskell function” at http://hpaste.org/87156
07:45:52 <Cale> okay, cool
07:46:30 <facepalm> maybe i dont need Cell in rhs
07:46:59 <facepalm> it just say write type class Cell with one contructor named Cell taking addr and a bool
07:47:16 <Cale> So, targetShip is going to get an address and a Ship. Since we're only going to check the equality of the location being targetted and not mess around with its insides, we can just match that part with a variable as I did above.
07:47:37 <Cale> But the Ship, we're going to want to inspect its list of cells, so we'll want to pattern match away the Ship data constructor.
07:47:55 <Cale> targetShip loc (Ship cells) = ...
07:48:59 <Cale> We need to produce a Ship as the result too, and the primitive way to do that is to use the Ship data constructor, and apply it to a list of Cells.
07:49:02 <Cale> targetShip loc (Ship cells) = Ship ...
07:49:36 <Cale> Similarly to before, we'll want to use a list comprehension to inspect each of the cells and decide what the cell in our new ship is going to be
07:49:37 <facepalm> im looking at it and thinking sorry
07:49:49 <Cale> targetShip loc (Ship cells) = Ship [ ... | ... ]
07:50:29 <facepalm> ship and cell and find if cell == addr
07:50:31 <Cale> Now, we want to pull apart each of the cells, pattern matching its Address and the Bool which says whether it's hit:
07:50:41 <Cale> targetShip loc (Ship cells) = Ship [ ... | Cell addr hit <- cells ]
07:50:57 <Cale> and the resulting ship will have a corresponding cell...
07:51:05 <Cale> targetShip loc (Ship cells) = Ship [ Cell addr (...) | Cell addr hit <- cells ]
07:51:32 <Cale> and that cell will be hit if either the original cell was hit, or addr is equal to the location we're targetting
07:51:49 <Cale> targetShip loc (Ship cells) = Ship [ Cell addr (hit || loc == addr) | Cell addr hit <- cells ]
07:52:12 <Cale> Make sense?
07:52:26 <facepalm> except for where hit is defined
07:52:33 <facepalm> or is that just the bool
07:52:49 <Cale> 'hit' is the Bool from the cell in the original ship that we're modifying
07:52:57 <facepalm> ok that makes sense then
07:54:00 <klrr> is it possible to have a global mutable variable that points to a list of strings?
07:54:04 <facepalm> for targetShips i think is supposed to be targetShips = map targetShip (list of ships)
07:54:30 <Cale> facepalm: Well, what's the type of targetShips?
07:54:41 <Cale> Get that right first, and then worry about writing the code for it :)
07:55:03 <Cale> Presumably it'll be like targetShip, but instead of one ship, operate on a list of Ships
07:55:12 <Cale> and yes, it'll probably involve map
07:55:17 <facepalm> targetShips accepts a list of Ships and target addr as params it attempts to sink each ship in list
07:55:37 <facepalm> it returns list up updated ships if no ships present empty list is returned
07:55:51 <Cale> I recommend taking the target address first in these cases, because of what we'll see in a moment :)
07:56:07 <facepalm> do i need type sig for this?
07:56:25 <Cale> You don't *need* one
07:56:29 <Cale> but you should write one anyway
07:56:43 <Cale> Because 1) it helps you keep everything straight in your head
07:56:51 <Cale> and 2) it helps the compiler give you better error messages
07:57:56 <Cale> So, targetShips is going to take an Address, and a [Ship], and produce a [Ship]
07:58:14 <Cale> targetShips :: Address -> [Ship] -> [Ship]
07:58:31 <facepalm> yes
07:58:42 <Cale> targetShips loc ships = ...
07:59:08 <klrr> ?type State
07:59:10 <lambdabot>     Not in scope: data constructor `State'
07:59:10 <lambdabot>     Perhaps you meant `StateT' (imported from Control.Monad.State)
07:59:37 <dmwit> klrr: Not really, no. However, it is possible to have a local mutable variable that points to a list of strings.
07:59:50 <Cale> klrr: Are you perhaps thinking of writing a State [String] computation?
07:59:59 <dmwit> There are hacks to make global variables, but each of them has weaknesses that make them not quite global variables.
08:00:04 <facepalm> map targetShips
08:00:20 <Cale> facepalm: You'll notice that this is a type error if you write it like that though
08:00:21 <sclv__> ./join #hardcorefp Comonad
08:00:28 <sclv__> doh!
08:00:30 <klrr> im reading about Sate now, i want basically a list of pairs where i can hold the variables of the lisp program my program inteprets
08:00:34 <facepalm> well is not finished
08:00:44 <Cale> targetShip :: Address -> (Ship -> Ship)
08:01:16 <Cale> So  map targetShip :: [Address] -> [Ship -> Ship],  which isn't quite what we want
08:01:55 <Cale> i.e. it would take a list of addresses and produce a list of functions for modifying ships
08:02:17 <facepalm> i want to map the old list with the new list
08:02:21 <Cale> However, if we apply targetShip to the address we're targetting, we get:
08:02:23 <klrr> is a hash table a list of pairs? does haskell has some type that's a hash table?
08:02:29 <Cale> targetShip loc :: Ship -> Ship
08:02:45 <Botje> klrr: you very probably don't want a hash table.
08:02:53 <Cale> and so  map (targetShip loc) :: [Ship] -> [Ship]
08:02:56 <FireFly> klrr: Data.Map implements a map structure, but it's not backed by a hash table internally
08:02:58 <Botje> klrr: why not Data.Map ?
08:03:41 <geekosaur> klrr, I would guess you want Data.Map. hash tables require mutability, there are some implementations but in most cases you don;t actually want them
08:05:39 <parcs> > (60+55)/(60+25)
08:05:41 <lambdabot>   1.3529411764705883
08:08:22 <klrr> Botje:  FireFly geekosaur ill check out Data.Map, if it's mutable, does that mean i can change it even if i dont return it ?
08:08:41 <FireFly> Data.Map isn't mutable (to my knowledge)
08:08:45 <bartavelle> it is not
08:09:12 <geekosaur> Map isn't mutable, it's hash tables that require mutability
08:09:28 <bartavelle> Data.HashMap.{Strict,Lazy} offers an immutable interface
08:09:34 <bartavelle> not sure what's going on underneath
08:09:46 <bartavelle> (from unordered-containers)
08:10:03 <acube> Why do hash tables require mutation?
08:10:41 <luite> bartavelle: it uses a hamt
08:11:13 <CaptainLex> acube: I think it is to deal with hash collisions appropriately
08:11:22 <sproingie> it's not like we don't have mutable data structures as it is
08:11:27 <luite> not with collisions, with efficient updates
08:11:48 <acube> are there hashtable implementations using ST?
08:12:25 <sproingie> not sure how useful ST would be there, you can't expose it
08:12:35 <fizbin> acube: http://hackage.haskell.org/package/hashtables
08:13:25 <Botje> for doing bulk updates, perhaps
08:23:17 <parcs> > 5 / (60+50)
08:23:20 <lambdabot>   4.5454545454545456e-2
08:28:29 <sclv__> nominolo: http://stackoverflow.com/questions/16353659/murmurhash-2-results-on-python-and-haskell
08:58:48 <Zouppen> which one to use for running multiple IO actions concurrently? http://hackage.haskell.org/package/async or http://hackage.haskell.org/package/threads ? or is there even better alternatives?
09:01:01 <typoclass> Zouppen: if you "just" want to run some stuff concurrently, the most basic choice is forkIO and the Control.Concurrent module (it comes with ghc)
09:01:39 <arkeet> async and friends are when your concurrent things return results that you want to wait for.
09:01:47 <arkeet> are for when
09:02:23 <arkeet> but those are built on top of forkIO and such
09:04:17 <jfischoff> trying to get lambdabot running, getting: Initialising plugins ............exception:
09:04:18 <jfischoff> fd:9: hClose: resource vanished (Broken pipe)
09:04:23 <jfischoff> any ideas?
09:05:13 <Zouppen> typoclass: yes, i know i'd like to collect the results, too. i have done that myself before with stm or mvars but noticed that thereare good libraries for it 
09:05:30 <typoclass> Zouppen: ah ok, fine :-) just double-checking
09:06:24 <jfischoff> mokus: was able to build lambdabot from your branch but it crashes when trying to load plugins. Any ideas?
09:10:39 <mokus> jfischoff: any messages when it crashes?
09:11:21 <Zouppen> typoclass: the diversity of available libraries is a bit confusing. :) what library do you prefer for the job?
09:12:12 <mokus> jfischoff: oh, i see, the hClose thing. hm, not sure - one of the things i wanted to do before releasing is add some better debugging tools
09:12:29 <jfischoff> hmm
09:12:36 <typoclass> Zouppen: i don't have an opinion on that. 'threads' on the hackage page claims it has various advantages over async and two others. *shrug*
09:13:15 <mokus> jfischoff: it kinda sounds like a network failure - do you maybe have a firewall that is blocking the irc connection?
09:13:23 <jfischoff> perhaps
09:13:31 <mokus> jfischoff: i know that's unlikely since you're here, but maybe it's a per-app blocker
09:14:54 <mokus> jfischoff: does it run in offlinerc mode?
09:15:08 <jfischoff> mokus: same error in offline mode
09:15:08 <Zouppen> the best for me would be something which allows me to pick a timeout for the IO operation and it returns the result immediately (something like interleaved io). that would keep te source very readable even it has threaded io
09:15:23 <jfischoff> mokus: have to fix the build real quick brb
09:15:46 <mokus> jfischoff: hm, i have some time today - i'll work on getting some proper logging and failure-location reporting in
09:15:52 <Zouppen> if there is no library for that already, it's easy to implement it on top of async or threads...
09:15:57 <jfischoff> that would be awesome
09:17:11 <Zouppen> typoclass: maybe i go with threads then, thank you :)
09:17:16 <mokus> jfischoff: if you have a github acct, you should probably open an issue (or just email me) - irc isn't a very reliable way to get me these days
09:17:30 <typoclass> Zouppen: you're welcome
09:17:58 <tromp> is there a haskell module that helps with solving equations like x^2+1 = 0 mod N ?
09:20:50 <int-e> tromp: I have code at home that does this for primes = 1 (mod 4); can't access it right now, but if there are no other suggestions I can dig it up later.
09:21:35 <tromp> my N is product of 4 primes
09:21:49 <NihilistDandy> tromp: Depending on what sort of objects you're working with, you may need something more heavy duty like Sage or Magma
09:21:53 <tromp> i'll just brute force it with a small c program for now
09:22:46 <int-e> tromp: or perhaps just use http://hackage.haskell.org/packages/archive/arithmoi/0.4.0.3/doc/html/Math-NumberTheory-Moduli.html
09:23:02 <int-e> (which has a sqrtModP thing)
09:23:47 <NihilistDandy> Jesus, there's a library for everything. That's pretty neat
09:26:06 <supki> there's more than one library for everything
09:27:41 <typoclass> there isn't one library for everything, however. that'd be terrible
09:28:01 <c_wraith> don't say that in front of edwardk.  he might add everything else to lens
09:29:46 <Chousuke> Or just prove that it's already isomorphic to everything else.
09:33:20 <typoclass> c_wraith: or possibly he'll give an ad-hoc lecture how lens already offers much of what you're asking for, because everything is a profunctorial retrograde wheelbarrow, and therefore you can just do ((anything ^.^) % (id' <-> .._Right <*>))
09:33:59 <edwardk> c_wraith: i already did add everything to lens. you just need to rummage around in there long enough to figure out how to express it
09:40:30 <fruitFly> Why does map (negate . abs) [5,-3,-6,7,-3,2,-19,24]   work, but not without the dot?
09:41:03 <c_wraith> fruitFly: the dot means something. Asking why it means something else (that happens to not typecheck) when it's not there is.. odd
09:41:09 <c_wraith> :t negate
09:41:13 <lambdabot> Num a => a -> a
09:41:15 <c_wraith> :t abs
09:41:20 <lambdabot> Num a => a -> a
09:41:40 <c_wraith> :t negate abs
09:41:44 <lambdabot> Num a => a -> a
09:41:47 <c_wraith> hehe
09:41:54 <c_wraith> lambdabot strikes again
09:42:07 <c_wraith> > negate abs 4
09:42:10 <lambdabot>   -4
09:42:18 <c_wraith> that's...  really funny
09:42:20 <Estrellas> why does that work for lambdabot
09:42:23 <Estrellas> lol
09:42:25 <geekosaur> that would cause confision, if they were testing it in caleskell
09:42:27 <fruitFly> c_wraith: YOU SEE!
09:42:44 <c_wraith> Estrellas: because lambdabot has a Num instance for functions
09:42:48 <h4199> lambdabot is drunk
09:42:50 <geekosaur> fruitFly / Estrellas, lambdabot has some nonstandard extensions loaded
09:42:54 <Estrellas> oh
09:43:09 <geekosaur> which have the result of causing utter confusion when you get the idea they're standard and then try to use them elsewhere
09:43:37 <elliott> :(
09:43:51 <c_wraith> fruitFly: most of the time, functions aren't numbers.  So "negate abs" means you're trying to negate a function
09:44:23 <fruitFly> c_wraith: Yes thanks.. I just got it :)... I'm learning and sometimes I briefly overlook the silliest of things :)
09:44:44 <c_wraith> fruitFly: excellent.  And darn that lambdabot for showing me up! :)
09:45:03 <fruitFly> c_wraith: HAHA lol
09:47:00 <kqr> is there a way to enable type checking for type synonyms?
09:48:00 <merijn> kqr: Use newtype
09:48:10 <kqr> merijn, oh
09:48:30 <merijn> kqr: That's what it's for ;)
09:49:08 <kqr> merijn, but it's just a special case of data, so you still have to write the constructor everywhere>
09:49:11 <kqr> ?*
09:49:12 <lambdabot> Maybe you meant: . ? @ v
09:50:40 <bjackman> hi there, is there a "standard library" function that takes a list and a function and returns the item in that list which maximises the function?
09:50:51 <merijn> kqr: It's not really a special case of data, newtype constructors don't exist at runtime, so "newtype Money = Money Integer" has the exact same performance as just using Integer directly would
09:50:52 <c_wraith> :t maximumBy
09:50:55 <lambdabot> (a -> a -> Ordering) -> [a] -> a
09:51:06 <ijp> kqr: if you want to ensure that only they only use your type synonym, you're going to need to provide a function to go from Old -> Synonym, anyway
09:51:06 <merijn> kqr: You do have to wrap/unwrap manually, in the source, though, yes
09:51:45 <bjackman> :t maximumBy
09:51:47 <lambdabot> (a -> a -> Ordering) -> [a] -> a
09:52:13 <bjackman> c_wraith: I don't seem to have that in my namespace - do I need to import it from somwhere?
09:52:22 <c_wraith> it's in Data.List
09:52:23 <kqr> ijp, i was hoping the compiler would be a little smarter, and automatically promote literal Olds to Synonyms wherever it requires that
09:52:24 <bjackman> (GHCi)
09:52:30 <bjackman> c_wraith: thank you!
09:52:35 <c_wraith> bjackman: also, it doesn't solve your problem directly
09:52:44 <kqr> ijp, kind of like the bytestring packing pragma works
09:53:12 <c_wraith> bjackman: it lets you supply a custom comparison function between two elements, but that's not exactly what you asked for
09:53:13 <xivix> Can you use a  "where"  to add to the scope of a pattern-matched function?
09:53:13 <bjackman> c_wraith: can i pass a lambda as the first argument that compares the values for each a of the function i want to maximise?
09:53:14 <merijn> kqr: If it did that, how would you prevent it from accidentally promoting where it shouldn't?
09:53:26 <bjackman> c_wraith: ah yeah, I see what you're getting at!
09:53:44 <merijn> xivix: yes, but I think it needs a separate where clause per pattern
09:53:57 <xivix> So they can't share them? Dang.
09:54:05 <quchen> I'm trying compile GHC right now, is there a way I can do the build in parallel easily? make -j doesn't help, presumably because the makefile is just a wrapper around GHC's --make or something
09:54:24 <kqr> merijn, as long as it keeps to promoting literal Olds, I don't see anywhere it shouldn't but still would think it could
09:54:29 <quchen> ... or maybe it'll start the parallel part at some later compiler stage
09:54:33 <c_wraith> bjackman: you might find it easier (and more efficient) to work with something like snd . maximum . map (\x -> (f x, x))
09:54:34 <luite> quchen: make -j does help
09:54:37 <kqr> merijn, as far as i know, the bytestring pragma doesn't do the wrong thing
09:54:40 <kqr> merijn, but i could be wrong
09:54:47 <luite> quchen: but some parts in the beginnen aren't parallel
09:54:50 <quchen> luite: Oh. I'll just have to wait a little longer then I suppose. Thanks for the info.
09:54:54 <c_wraith> bjackman: that only applies the function to each element once, instead of every time two elements are compared
09:55:10 <quchen> luite: Is it safe to abort compilation and then restarting it with more jobs?
09:55:16 <quchen> (As in ^C)
09:55:18 <epta> Is there some special latex symbols for >>= and >=>? Where they could be found?
09:55:18 <luite> yeah should be safe
09:55:30 <c_wraith> bjackman: but it does require that the original elements in the list are comparable, while using maximumBy wouldn't
09:55:31 <bitonic> epta: look at what lhs2tex does
09:55:31 <lambdabot> bitonic: You have 1 new message. '/msg lambdabot @messages' to read it.
09:55:45 <quchen> luite: Thanks. Parallelism has started now, yipee
09:55:59 <xivix> so instead of  'f C1 = util "c1"\nf C2 = util "c2"\n  where util = whatever' ,  I'll need to use  'case' ?
09:58:51 <bjackman> c_wraith: ah yeah that is nice actually. I had something fairly similar (although less elegantly expressed) but it resulted in a 3-tuple (i'm doing the knapsack problem so there's also a function i want to minimise), and that got a bit ugly
09:59:45 <klrr> type errors =o
10:02:15 <merijn> xivix: Well, alternatively you could make a show instance of the datatype and do "f c = util (show c)"
10:03:04 <xivix> merijn: That's not actually what I'm doing, I was making a minimal example. Thanks for trying though.
10:03:04 <klrr> https://gist.github.com/klrr/5511304 (error and code in paste) anyone got an idea how to solve these two type errors? would really appriciate help
10:04:52 <Philippa> epta: it's all done with negative hspacing, IIRC
10:06:18 <elliott> hspace sounds like a haskell library for astronomy, or something.
10:06:57 <fruitFly> just curious... where is idris relative to haskell in terms of development and applicability?
10:07:25 <Iceland_jack> fruitFly: Idris is a research language
10:07:26 <bitonic> fruitFly: what’s ‘development and applicability’?
10:07:50 <Philippa> "how well-developed is it, how widely can it be applied?"
10:08:01 <bitonic> fruitFly: anyway, in terms of ‘how good it is to write real world software’ Idris is not comparable to Haskell
10:08:16 <Iceland_jack> It's fairly well developed but you don't use it in real world software
10:08:22 <bitonic> I wouldn’t say that Idris is ready to be used in the wild yet
10:08:42 <c_wraith> it does have real-world use as a goal, though. Which is nice. :)
10:08:54 <fruitFly> bitonic: Thanks :)
10:09:22 <fruitFly> c_wraith: Yes, I noticed that. Iceland_jack it's intended to be a general purpose language more than just a theorem prover.
10:09:27 <bitonic> c_wraith: well Agda/Coq have ‘real-world’ use as a goal too
10:09:44 <bitonic> just that they’re more oriented towards the ‘proving things correct’ real world :P
10:09:48 <c_wraith> bitonic: I guess I should have been more clear. They don't have "software development" as a goal :)
10:09:51 <tromp> :t showAtBase
10:09:54 <lambdabot>     Not in scope: `showAtBase'
10:09:54 <lambdabot>     Perhaps you meant `showIntAtBase' (imported from Numeric)
10:09:58 <tromp> :t showIntAtBase
10:10:00 <lambdabot> (Integral a, Show a) => a -> (Int -> Char) -> a -> ShowS
10:10:24 <tromp> > showIntAtBase 2 intToDigit 502011 ""
10:10:25 <bitonic> c_wraith: I think that’s unfair.  again, Coq is the only one of the lot that has produced ‘real world’ software (if we don’t count Agda’s parsing libraries)
10:10:28 <lambdabot>   mueval-core: Time limit exceeded
10:10:32 <epta> https://raw.github.com/kosmikus/lhs2tex/master/Examples/HelloWorld.lhs is this a valid literate haskell code? And if it's not, why this package called lhs2tex if it gets non lhs as a input?
10:10:34 <tromp> > showIntAtBase 2 intToDigit 502011 ""
10:10:39 <lambdabot>   mueval-core: Time limit exceeded
10:10:40 <quchen> Is the Prelude simply what libraries/base/Prelude.hs exports, or is there more to take care about?
10:10:48 * tromp kicks lambdabot
10:11:11 <bitonic> quchen: the standard defines a Prelude.  GHC diverges a bit from that.  for what concerns what GHC thinks you have to look at ‘base’ yeah
10:11:27 <tromp> > showIntAtBase 2 intToDigit 502011 ""
10:11:31 <lambdabot>   "1111010100011111011"
10:11:49 <tromp> > length "1111010100011111011"
10:11:52 <lambdabot>   19
10:11:52 <quchen> bitonic: My plan is making my own little GHC with a modified Prelude right now, so I'm really looking for messing around somewhere in GHC.
10:12:00 <c_wraith> quchen: note that GHC lets you override Prelude locally. If you have a Prelude module in your source tree (not in a library), GHC uses it by default instead of the one from base
10:12:01 <benzrf> hello!
10:12:05 <Iceland_jack> fruitFly: Dependent types still have a long way to go for general-purpose, real-world applications
10:12:21 <merijn> quchen: You can just hide the builtin Prelude and import your own?
10:12:26 <benzrf> I don't have a wonderful grasp on monads and monadic IO and do-notation yet, so could somebody tell me what's wrong with http://paste.pound-python.org/show/32875/ ?
10:12:27 <fruitFly> Iceland_jack: Yeah, thanks. :)
10:12:35 <benzrf> the error is     Couldn't match expected type `IO [String]' with actual type `[a0]'
10:12:58 <c_wraith> benzrf: that error message means you're putting a list where it expects an IO action
10:13:01 <merijn> benzrf: Last line
10:13:14 <benzrf> hmm
10:13:18 <merijn> benzrf: "return line:lines" == "(return line):lines"
10:13:20 <benzrf> shouldn't the return make it into an IO though?
10:13:22 <c_wraith> oh, that's sneaky.
10:13:22 <benzrf> oh
10:13:24 <benzrf> are you sure?
10:13:27 <c_wraith> it would if it was IO's return
10:13:28 <merijn> You probably meant "return (line:lines)"
10:13:30 <benzrf> ok
10:13:31 <c_wraith> but it's using the list return
10:13:35 <quchen> c_wraith, merijn: This is the first time I'm looking into modifying GHC's internals. What my ultimate goal is is having a GHC with "Applicative => Monad" so I can test-build libraries and see how large the compatibility issues are.
10:13:36 <benzrf> how about return $ line:lines
10:13:50 <supki> > 502011 ^. re (base 2) . to length
10:13:54 <lambdabot>   19
10:13:56 <benzrf> ugh
10:13:57 <merijn> quchen: {-# LANGUAGE NoImplicitPrelude #-} ?
10:14:00 <merijn> benzrf: That works too
10:14:01 <benzrf> I could've sworn I tried that...
10:14:02 <Iceland_jack> benzrf: Doesn't matter
10:14:06 <c_wraith> quchen: ah, what I mentioned doesn't change that, because it doesn't affect compiled libraries
10:14:07 <benzrf> ok, thanks :C
10:14:08 <quchen> Basically, if you give me a way of doing this without recompiling GHC after each change I do in the base libraries that would be pretty cool.
10:14:09 <benzrf> I mean :D
10:14:14 <benzrf> have a nice day!
10:14:24 <elliott> recompiling GHC is a good idea anyway
10:14:24 <c_wraith> quchen: nor does the NoImplicitPrelude extension
10:14:32 <Iceland_jack> fmap succ (Smiley ":C") ↝ Smiley :D
10:14:33 <elliott> since it checks whether GHC ITSELF will work with your new base
10:14:40 <elliott> *itself
10:14:43 <elliott> good accidental caps lock.
10:14:44 <c_wraith> quchen: to do that, you really are going to need to modify the base package, and recompile everything
10:15:17 <quchen> Is there need to compile dynamic objects and profiling libraries to test for compatibility issues, or is that redundant?
10:15:24 <ParahSai1in> :t null
10:15:26 <lambdabot> [a] -> Bool
10:15:27 <c_wraith> you can pass on those
10:15:36 <typoclass> quchen: the first step will be making the change in the base package (checked out from github or whatever), and testing if that itself can compile, right?
10:15:43 <quchen> Wonderful. Compilation HAAAAALT
10:16:04 <fizbin> :t uncurry . uncurry
10:16:06 <quchen> typoclass: Yes. Well, first I'd like to compile the normal GHC 7.6.3 to see whether it works, and then I can start messing around
10:16:07 <lambdabot> (a -> b1 -> b -> c) -> ((a, b1), b) -> c
10:16:16 <typoclass> quchen: next steps would be to build other stuff, including ghc, against that modified base package
10:16:27 <typoclass> quchen: hm sure
10:16:40 <fizbin> @djinn (a -> b1 -> b -> c) -> (a, (b1, b)) -> c
10:16:41 <lambdabot> f a (b, (c, d)) = a b c d
10:16:50 <xivix> merijn: I figured out a way to do it.
10:17:09 <fizbin> @pl \a (b, (c, d)) = a b c d
10:17:10 <lambdabot> (line 1, column 16):
10:17:10 <lambdabot> unexpected "="
10:17:10 <lambdabot> expecting pattern or "->"
10:17:24 <fizbin> @pl \a (b, (c, d)) -> a b c d
10:17:25 <lambdabot> (`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .)
10:17:29 <fizbin> Ew.
10:18:20 <quchen> Does anyone know how to disable shared/profiling libs in the ./configure?
10:18:32 <quchen> For Cabal it's --disable-shared etc, but that won't be recognized
10:18:40 <quchen> Should I just edit my .cabal temporarily?
10:18:53 <fizbin> @pl \a -> let f (b, (c, d)) = a b c d in f
10:18:54 <lambdabot> (`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .)
10:19:10 <bjackman> How do you remove something from the namespace?
10:19:19 <flebron> So I know that when I have a .hs compiled to a binary in a director, in order to be able to call functions of it from ghci, I must first ":l *BinaryName". What am I doing when I do this?
10:19:25 <xivix> merijn: 'f = _f\n  where\n    _f C1 = util "c1"\n    _f C2 = util "c2"\n    util = whatever'
10:19:28 <flebron> *directory.
10:20:55 <FreeFull> Why is  case a of {x->y; y->x; _->a}  a bad idea?
10:21:21 <elliott> what do you mean?
10:21:31 <fizbin> :t let f = undefined::(a->b->c->d) in uncurry f
10:21:33 <lambdabot> (a, b) -> c -> d
10:21:42 <fizbin> :t let f = undefined::(a->b->c->d) in uncurry . f
10:21:43 <FreeFull> When I use it, it doesn't produce the expected result
10:21:45 <lambdabot> a -> (a1, b) -> c
10:22:17 <fizbin> :t let f = undefined::(a->b->c->d) in uncurry $ uncurry . f
10:22:19 <lambdabot> (a, (a1, b)) -> c
10:22:21 <quchen> FreeFull: It's valid code, as long as x and y are in scope.
10:22:37 <quchen> Oh wait.
10:22:39 <elliott> FreeFull: ok, how about show the real code?
10:22:45 <elliott> without placeholders like x and y, since they matter
10:22:48 <elliott> @paste
10:22:49 <lambdabot> Haskell pastebin: http://hpaste.org/
10:23:19 <geekosaur> er, wait. case ... of x -> ? that is an irrefutable that binds x to ...
10:23:45 <elliott> I don't believe the code shown is the real code. I believe x and y are placeholders.
10:23:47 <geekosaur> shadowing whatever, if anything, binding for x might have existed prior
10:23:47 <FreeFull> geekosaur: I see
10:24:04 <FreeFull> elliott: I made fake code just for you
10:24:13 <kosmikus> epta: yes, that's valid lhs. lhs2TeX takes indeed lhs files as input, but note that not all valid lhs files produce valid tex as output ...
10:24:22 <FreeFull> So, guards?
10:24:25 <fizbin> :t let f = undefined::(a->b->c->d) in (uncurry . (uncurry .)) f
10:24:27 <lambdabot> (a, (a1, b)) -> c
10:24:56 <fizbin> :t let f = undefined::(a->b->c->d->e) in (uncurry . (uncurry . (uncurry .))) f
10:24:58 <lambdabot> ((a, (a1, b1)), b) -> c
10:25:05 <epta> kosmikus: ok
10:25:07 <fizbin> Drat.
10:25:13 <elliott> FreeFull: it's impossible to answer with guesswork.
10:25:23 <elliott> the solution could be any number of things depending on what x and y are.
10:25:32 <FreeFull> They're chars
10:25:35 <FreeFull> From user input
10:25:57 <elliott> ok, so x, y :: Char are variables in scope?
10:26:02 <elliott> then geekosaur's explanation is correct.
10:26:10 <FreeFull> Yeah
10:26:11 <elliott> you can use (==) to compare for equality:
10:26:14 <kosmikus> epta: lhs2tex isn't intended to be an auto-formatter for arbitrary Haskell code; it's intended to be an easy way to typeset Haskell code in a TeX document.
10:26:24 <elliott> if a == x then y else if a == y then x else a
10:26:28 <elliott> a guard will also work, yes
10:26:38 <elliott> a' | a == x = y
10:26:42 <elliott>    | a == y = x
10:26:44 <elliott>    | otherwise = a
10:27:09 <bjackman> Could anyone tell me - in this code http://pastebin.com/xTdiYUxf would it be better if I hadn't used type parameters
10:27:11 <bjackman> ?
10:27:12 <FreeFull> Alright, guards worked
10:27:14 <mauke> The paste xTdiYUxf has been copied to http://hpaste.org/87162
10:27:27 <FreeFull> elliott: Yeah, I already did that in my code
10:27:36 <FreeFull> Except I used an inline guard in a let expression
10:27:55 <akegalj> about Maybe monad: (>>=) :: Monad m => m a -> (a -> m b) -> m b.    Now if we have "Nothing >>= \z->Just z" What is mapped to z? Im a bit confused, how can that and "Just 5 >>= \z-> Just z" both be valid? I mean, it is a great feature but can't understand where it comes from?
10:28:14 <epta> kosmikus: so as Philippa said, there is no single latex symbol for >>= or >=>?
10:28:31 <merijn> akegalj: It comes from the implementation of >>= for Maybe
10:28:43 <otters> akegalj: Nothing >>= _ is Nothing
10:29:01 <merijn> akegalj: The implementation of >>= for maybe is: "Just x >>= f = f x; Nothing >>= _ = Nothing"
10:29:21 <Philippa> epta: why would there be? It's not hard to define, though
10:29:53 <akegalj> merjin otters, thnx
10:30:52 <otters> :t \f x -> x ( f x )
10:30:56 <lambdabot> ((t1 -> t) -> t1) -> (t1 -> t) -> t
10:32:23 <tdammers> akegalj: the monad instance for Maybe is actually quite straightforward if you start out disregarding the entire monad concept
10:32:28 <fizbin> :t let uncurryr 1 f = f; uncurryr n f = \(a, b) -> (uncurryr (n - 1) (f a)) b in uncurry 5
10:32:32 <lambdabot>     Occurs check: cannot construct the infinite type:
10:32:33 <lambdabot>       t0 = (t1, t2) -> t0
10:32:33 <lambdabot>     In the return type of a call of `f'
10:32:38 <tdammers> imagine a situation where you have a function that takes a value and returns a Maybe
10:32:43 <tdammers> f :: a -> Maybe b
10:32:43 <FreeFull> Almost as straightforward as Identity
10:33:13 <tdammers> but you have a Maybe a, not an a
10:33:36 <akegalj> how can i see how Maybe.>>= is implemented? Is there any (:info) command for ghci?
10:33:39 <tdammers> so you want something that takes a Maybe a, applies f to it if it's a Just value, and bails with Nothing if its' Nothing
10:34:06 <tdammers> iow, if you have something, you want to apply your function; if you don't, just return Nothing
10:34:25 <tdammers> so you want a function that turns (a -> Maybe b) into (Maybe a -> Maybe b)
10:34:45 <FreeFull> akegalj: http://www.haskell.org/onlinereport/standard-prelude.html  Look for   instance  Monad Maybe
10:34:47 <quchen> akegalj: You can't look up source in GHCi. The standard monads are defined in Control.Monad, so hoogle that and look through the source
10:34:59 <tdammers> I think you should be able to implement that function yourself
10:35:37 <tdammers> here's the trick: >>= for Maybe is exactly the same function.
10:35:45 <tdammers> :t (>>=)
10:35:48 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:36:06 <akegalj> FreeFull, tnx... i found it
10:36:38 <quchen> Oh, it's actually defined in Data.Maybe.
10:36:41 <quchen> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-Maybe.html#Maybe
10:37:17 <akegalj> tnx quchen
10:38:00 <akegalj> tdammers, y... i know all that... but just wanted to see source. I think it is good way to learn stuff
10:38:15 <geekosaur> @src Maybe (>>=)
10:38:16 <lambdabot> (Just x) >>= k      = k x
10:38:16 <lambdabot> Nothing  >>= _      = Nothing
10:38:32 <geekosaur> not that the @src database is anything like comprehensive
10:40:01 <kosmikus> epta: not if you want it to looks similar :)
10:40:16 <kosmikus> epta: you can of course choose a single LaTeX symbol ...
10:40:28 <akegalj> tnx geekosaur
10:40:42 <akegalj> @src Maybe (>>=)
10:40:42 <lambdabot> (Just x) >>= k      = k x
10:40:43 <lambdabot> Nothing  >>= _      = Nothing
10:41:32 <tdammers> akegalj: and what lambdabot just gave you should be the exact thing you could have come up with yourself ;)
10:42:00 <akegalj> yes, i just dont beleave myself any more. Had to see it!
10:42:08 <clahey> I love how you can just write out what values should be.
10:42:25 <clahey> If you pass it this, the value is that.  Done!
10:46:15 <fizbin> @pl \f -> let g (a, (b, (c, d))) = f a b c d in f
10:46:16 <lambdabot> id
10:46:51 <fizbin> :type \f -> let g (a, (b, (c, d))) = f a b c d in f
10:47:02 <fizbin> @pl \f -> let g (a, (b, (c, d))) = f a b c d in g
10:47:04 <lambdabot> (`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .)
10:47:35 <dario> fizbin: why would you do that?!
10:48:13 <fizbin> Basically, I've got some functions that take multiple values, and I want to feed them things I put together with &&&
10:48:42 <fizbin> And &&& builds (up, (pairs, (nested, (like, this))))
10:49:22 <fizbin> @pl \f -> let g (a, (b, c)) = f a b c  in g
10:49:23 <lambdabot> (`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .)
10:49:23 <aristid> johnw: ping?
10:49:42 <fizbin> So @pl apparently doesn't really care much for using "uncurry"
10:50:50 <fizbin> :type uncurry . (uncurry .)
10:51:10 <fizbin> @type (`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .)
10:51:12 <lambdabot> (b1 -> a -> b2 -> b) -> (b1, (a, b2)) -> b
10:51:18 <fizbin> @type uncurry . (uncurry .)
10:51:21 <lambdabot> (a -> a1 -> b -> c) -> (a, (a1, b)) -> c
10:52:22 <benzrf> hello!
10:52:59 <benzrf> if I have somelist :: [Just foo], how do I get unpackedlist :: [foo]?
10:53:04 <benzrf> wait
10:53:06 <benzrf> that's not valid
10:53:08 <benzrf> whatever, you know what I mean]
10:53:25 <Botje> benzrf: catMaybes
10:53:51 <typoclass> benzrf: it's in Data.Maybe
10:54:06 <benzrf> ok, thanks :)
10:54:20 <benzrf> so it's usually more appropriate to find a library function for what you want to do than just DIY?
10:55:05 <simpson> benzrf: Well, is there a good reason to write that function yourself?
10:55:12 <benzrf> ok that is a good point
10:55:25 <simpson> (Do you know how to write that function?)
10:55:28 <typoclass> benzrf: if you're a beginner, it can be good exercise to write some simple functions yourself. as you get more advanced, you'll get to know the standard library better
10:55:32 <benzrf> ok
10:55:35 <benzrf> simpson: I think
10:55:39 <benzrf> let me consider
10:55:45 <benzrf> how about...
10:55:53 <benzrf> map (\Just foo -> foo) [maybes]
10:56:12 <simpson> > map (\Just x -> x) [Just 42, Nothing, Just 42]
10:56:16 <lambdabot>   Constructor `Data.Maybe.Just' should have 1 argument, but has been given none
10:56:29 <benzrf> yes, but in my case I'm guaranteed to not have any Nothings
10:56:39 <simpson> Then why do you have Maybe at all? :3
10:56:46 <benzrf> I'm using elemIndex on sorted/unsorted list
10:56:56 <benzrf> which are guaranteed to be the same set
10:56:56 <simpson> > map fromJust [Just 42, Nothing, Just 42] -- also
10:57:00 <lambdabot>   mueval-core: Time limit exceeded
10:57:04 <benzrf> did not know about fromJust
10:57:06 <benzrf> nvm
10:57:39 <benzrf> if I do let foo = bar in whatever and I put whatever on its own line, do I indent it to match foo?
10:58:06 <typoclass> benzrf: fromJust (not to be confused with fromMaybe) is kind of smelly. it will crash the program it you give it a Nothing, and you'll not get the line number. think twice before using
10:58:14 <benzrf> ok
10:58:16 <simpson> If you like. Normally you would put `in result` on the next line, and indent that.
10:58:22 <benzrf> oh, ok
10:58:38 <simpson> > catMaybes [Just 42, Nothing, Just 42]
10:58:41 <lambdabot>   [42,42]
10:58:47 <simpson> @src catMaybes
10:58:47 <lambdabot> catMaybes ls = [x | Just x <- ls]
10:58:52 <benzrf> urgh
10:58:56 <benzrf> I totally forgot list comps
10:59:01 <simpson> Ha, oh Haskell.
11:00:20 <simpson> benzrf: Also, although this is unrelated, I would recommend that you focus on either Python or Haskell, and be confident in one before learning the other. Trying to learn multiple languages at a time can be a headache if you don't already know a handful.
11:00:42 <benzrf> simpson: I'm pretty confident in python
11:00:58 <benzrf> I don't speak it fully idiomatically, but I have a good grip
11:01:13 <benzrf> anyway I'm pretty great at grasping abstract concepts if I do say so myself
11:01:17 * benzrf braces for criticism
11:01:44 <benzrf> oh, also: I already knew a few :P
11:03:15 <benzrf> bluh, looks like I'm going to have to get used to immutable lists
11:03:49 <Chousuke> benzrf: If you decide to learn Haskell you will find many things that make you doubt that statement.
11:04:04 <benzrf> I'm sorry?
11:04:32 <benzrf> but... you can't have mutable data types and maintain referential transparency, can you?
11:04:41 <typoclass> benzrf: haskell has a steep learning curve, he means
11:04:44 <benzrf> oh
11:04:48 <benzrf> well, yeah
11:04:55 <Chousuke> benzrf: I mean the statement about grasping abstract things
11:04:57 <typoclass> benzrf: yes, stuff in haskell is generally immutable
11:05:05 <benzrf> Chousuke: try me (:
11:05:11 <Chousuke> the more common things are generally pretty straightforward
11:05:12 <typoclass> benzrf: what is giving you trouble about immutable lists?
11:05:16 <Iceland_jack> ugh
11:05:20 <benzrf> nothing is giving me trouble
11:05:23 <Chousuke> but I tried to understand wtf profunctors are about the other day
11:05:28 <Chousuke> and didn't get much anywhere
11:05:31 <benzrf> I just realized I can't write it the usual way
11:05:34 <benzrf> well I
11:05:46 <benzrf> I just really started learning about monads like two days ago
11:05:47 <typoclass> benzrf: ok :-) i just understood it that way when you said you needed to get used to them
11:05:52 <benzrf> and I already grasp them like 25%!
11:05:57 <Iceland_jack> benzrf: Congratulations
11:05:57 <benzrf> maybe
11:06:03 <Chousuke> heh
11:06:24 <typoclass> benzrf: monads really are not as mysterious as people paint them
11:06:28 <benzrf> mhm
11:06:41 <benzrf> well, I think the real issue is that you need a good grasp of other FP concepts first
11:06:48 <benzrf> and people trying to learn about monads often don't know those yetr
11:06:49 <Chousuke> today it hit me that in Haskell an imperative program is a plain old value and that's why it's possible to do imperative programming in a pure functional context :/
11:06:58 <benzrf> Chousuke: HA ALREADY KNEW THAT
11:07:01 * benzrf cheers
11:07:09 <Iceland_jack> wow
11:07:21 <Chousuke> benzrf: you know it, but do you understand what it means?
11:07:24 <benzrf> mostly
11:07:47 <benzrf> instead of performing actions as the program runs, you create descriptions of actions and bind them to each other
11:07:59 <benzrf> then you return the result from main, and it gets executed
11:08:11 <typoclass> benzrf: that's pretty good
11:08:27 <benzrf> monads allow you to defer function application until you evalutate the monad itself
11:08:36 <benzrf> which lets you stick a bunch of functions together without applying any of them
11:08:56 <typoclass> benzrf: yeahhhhh well laziness for example also allows you to defer function application
11:09:04 <benzrf> I know, but in a different way
11:09:08 <benzrf> not exactly deferring
11:09:26 <simpson> Deferring computation is only in the job description of a handful of monads, like Cont.
11:09:32 <Chousuke> benzrf: yep. Now how do you represent a bit of code with side-effects as a pure value?
11:09:35 <simpson> (And Deferred is a great example, if not in Haskell.)
11:09:47 <benzrf> Chousuke: can you rephrase that?
11:10:07 <benzrf> I don't quite get what you meanj
11:10:09 <benzrf> *mean
11:10:19 <Chousuke> benzrf: if you have a piece of code that performs a side-effect when executed, how do you get a pure value out of it?
11:10:33 <benzrf> you return an action that can be evaluated for the side effect
11:10:50 <Chousuke> yeah, but concretely, what is that action
11:10:56 <benzrf> a monad
11:11:12 <Chousuke> no, being a monad is a property of the thing
11:11:14 <benzrf> ok
11:11:16 <benzrf> well
11:11:21 <benzrf> I guess I don't know
11:11:22 <benzrf> :)
11:11:32 <benzrf> tell me?
11:11:39 <Chousuke> you wrap it in a lambda
11:11:50 <benzrf> erm
11:11:52 <benzrf> what do you mean
11:12:11 <benzrf> wait, are you talking about how do-notation is sugar for >>= (\foo
11:12:30 <benzrf> or are you talking about IO objects
11:12:40 <Chousuke> benzrf: if you have \x -> effects, you can copy that lambda and do whatever you want with it without actually executing the effects
11:12:43 <hpaste> djanatyn pasted “Rock, Paper, Scissors” at http://hpaste.org/87163
11:12:48 <benzrf> that's kinda what I said...
11:12:49 <benzrf> >_>
11:12:50 <Chousuke> benzrf: ie. it's pure.
11:12:53 <djanatyn> hello! I'm playing around with implementing typeclasses and I made a type for Rock, Paper, Scissors
11:13:04 <benzrf> g2g, bbl
11:13:06 <benzrf> have a nice day :)
11:13:07 <djanatyn> and I tried messing around with the maximum function after getting it working, and came up with this: http://hpaste.org/87163
11:13:13 <elliott> benzrf: it's not about evaluation.
11:13:23 <elliott> putStrLn "foo" `seq` () doesn't do anything.
11:13:25 <elliott> oh well.
11:13:34 <Taneb> djanatyn: that's a yucky ord instance
11:13:37 <djanatyn> maximum gives a different answer depending on the ordering of the elements in the list!
11:13:45 <djanatyn> Taneb: it's my first instance :)
11:13:53 <djanatyn> I'm not sure of the best way to do it
11:13:55 <Taneb> Ideally, Ord should be transitive
11:14:06 <Taneb> I'd make a completely separate function
11:14:13 <elliott> if your Ord instance is wrong then maximum is wrong too
11:14:24 <djanatyn> ...hello elliott
11:14:31 <geekosaur> where's your EQs?. also the case of rock/paper/scissors is going to be oddball because it's deliberately circular
11:14:40 <djanatyn> *nod*
11:14:49 <Taneb> (unfortunately, the type I'd make this function is the same as the type of compare)
11:14:58 <elliott> the docs say "The Ord class is used for totally ordered datatypes.", so you have to obey the laws of a total ordering
11:15:03 <djanatyn> ah, okay
11:15:14 <djanatyn> I guess I was just being too much of a rebel
11:16:42 <sproingie> is there a class for partially ordered types?
11:17:33 <klrr> could someone help me with this error? https://gist.github.com/klrr/5511304 i tried solve one of them with mapM but didnt work :/ any ideas?
11:20:52 <Chousuke> klrr: return x instead of x?
11:20:56 <dmwit> sproingie: I don't know of a standard one, but it ought to be very easy to cook one up.
11:21:48 <sproingie> sure, though then nothing existing takes advantage
11:22:22 <dmwit> I think nothing existing takes advantage of the existence of something that doesn't exist.
11:22:32 <dmwit> Whether or not it's easy to instantiate the non-existing thing.
11:22:34 <sproingie> i guess one could map to the subset of total ordering and sort with that
11:22:41 <sproingie> sort of a decorate-sort-undecorate thing
11:22:41 <elliott> sproingie: somewhere on hackage there is one
11:22:43 <elliott> I've seen it
11:22:52 <klrr> Chousuke: will try thanks! :)
11:23:16 <dmwit> klrr, Chousuke: mapM (\something -> return somethingElse) seems like a code smell to me
11:23:35 <dmwit> klrr, Chousuke: Why not map (\something -> somethingElse) <$> instead?
11:23:58 <dmwit> klrr: Also, something >>= return . somethingElse is a code smell. Why not somethingElse <$> instead?
11:24:08 <dmwit> uh, somethingElse <$> something, I mean
11:24:58 <dmwit> So: arith f params = Num . foldl f . (\(Num x) -> x) <$> params -- for example
11:25:06 <klrr> dmwit: wait, <$> is like `fmap` right?
11:25:12 <dmwit> yes
11:25:19 <dmwit> You can spell it as fmap or liftM if you prefer.
11:25:33 <dmwit> or liftA... I think that's all the standard spellings.
11:25:40 <Chousuke> dmwit: right
11:25:51 <klrr> dmwit: thank you, you got experience :)
11:26:31 <dmwit> klrr: Completely unrelated to learning how monads and friends work: foldl should probably be foldl', or possibly foldr if laziness matters.
11:29:21 <Chousuke> klrr: oh, and the second error is because zip returns a list of pairs, but eqvPair takes two parameters instead of one that is a pair
11:33:08 <klrr> Chousuke: thanks! didnt notice that
11:33:11 <akegalj> @src Control.Monad guard
11:33:11 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:33:41 <akegalj> @src Control.Monad (guard)
11:33:41 <lambdabot> Source not found. Just what do you think you're doing Dave?
11:34:06 <FireFly> @src Control.Monad.guard
11:34:06 <lambdabot> Source not found. Just try something else.
11:34:12 <dmwit> ?src guard
11:34:12 <lambdabot> guard True  =  return ()
11:34:12 <lambdabot> guard False =  mzero
11:34:31 <akegalj> tnx
11:34:38 <dmwit> The ?src command is dum. It don't know modules.
11:34:48 <Taneb> I think guard should be in Control.Applicative and take an Alternative rather than a MonadPlus
11:34:52 <dmwit> It's barely more than ?where.
11:35:15 <geekosaur> when I invoked it before, it was not using a module, it was showing a typeclass instance for a particular type
11:38:26 <Facepalm> I am having troubles getting last two functions of my program to work properly. Could someone take a peek please? http://hpaste.org/87164 it's the is and areSunk functions
11:43:05 <klrr> i changed the functions as adviced but now i get two new errors, the first that it's something wrong with the fmap(<$>) expression, it returnes a Int instead of a [Int], also there's still some error with lines 119 :x, https://gist.github.com/klrr/5512527 any ideas?
11:43:15 <dmwit> Facepalm: Can you phrase your question in the form "I do X, expecting Y, but Z happens instead."?
11:43:26 <dmwit> (What do you mean by "work properly"?)
11:44:13 <dmwit> klrr: Ah, yes, my translation was a bit wrong: it didn't include the "map".
11:44:27 <dmwit> klrr: as in map (\(Num x) -> x)
11:44:59 <Facepalm> IsSunk takes a Ship if ship is empty return true otherwise return true if all cells marked sunk
11:45:30 <Facepalm> I can't figure out how to do that. Correctly
11:45:46 <dmwit> What's wrong with what you have there?
11:46:10 <dmwit> Oh, I see.
11:46:18 <klrr> dmwit: what you mean? (sry that i dont understand)
11:46:24 <dmwit> You need to pattern match to get rid of the Ship type's Ship constructor.
11:46:31 <Facepalm> I think areSunk is correct but says out of scope on ships but. I think that's because isSunk isn't correct
11:47:38 <dmwit> klrr: Where you have "(\(Num x) -> x)" you should probably have "map (\(Num x) -> x)".
11:48:05 <klrr> dmwit: a map and a <$> or a map instead of <$>?
11:48:18 <dmwit> My statement was precise.
11:48:42 <dmwit> Also, you should be able to figure out the answer to that on your own with a bit of thought.
11:49:59 <Facepalm> Dmwit can you tell what my error is?
11:50:29 <dmwit> Yes, you need to pattern match to get rid of the Ship type's Ship constructor.
11:50:40 <johanneslippmann> Hi there, I want to write a new show function for my binary Tree.
11:51:10 <johanneslippmann> And I wanted to to do it with a new line for every branch
11:51:23 <johanneslippmann> so I tried something like:
11:51:42 <johanneslippmann> lambdabot print "Hello \n world"
11:51:46 <dmwit> Facepalm: Do you know what the declaration "data Ship = Ship [Cell]" does? If not, it might be tricky to understand how to use values of type Ship.
11:52:04 <klrr> marsam: will try!
11:52:45 <johanneslippmann> but the \n doesn't seem to work in print in ghci
11:53:04 <Mortchek> johanneslippmann, putStrLn
11:53:07 <dmwit> johanneslippmann: Perhaps you would prefer the behavior of putStr to that of print.
11:53:20 <dmwit> Or putStrLn, as Mortchek says, depending.
11:53:27 <johanneslippmann> but that gets me an IO (), not a string
11:53:32 <geekosaur> and?
11:53:35 <Mortchek> print also gets you an IO ()
11:53:37 <dmwit> print also gets you an IO ()
11:53:37 <geekosaur> that's what you want
11:53:45 <Mortchek> @type print
11:53:48 <lambdabot> Show a => a -> IO ()
11:53:48 <Mortchek> @type putStrLn
11:53:50 <lambdabot> String -> IO ()
11:53:52 <geekosaur> (note that if you're doing this in lambdabot, IO is blocked)
11:54:12 <typoclass> johanneslippmann: you are right that a 'show' function is pure and produces a String, and shouldn't be IO ()
11:54:15 <mr-> > unlines ["a","b","c"]
11:54:17 <lambdabot>   "a\nb\nc\n"
11:54:42 <mr-> johanneslippmann: you could build up a list of lines and unlines it
11:55:10 <johanneslippmann> I am confused now.
11:55:16 <dmwit> Me, too.
11:55:17 <Mortchek> @type show
11:55:21 <lambdabot> Show a => a -> String
11:55:24 <typoclass> johanneslippmann: in other words, don't put print or putStr inside of show. which part is giving you trouble?
11:55:28 <dmwit> What were you hoping 'print "hello \n world"' would do?
11:55:33 <Mortchek> show gives you a String; print and putStrLn both give you IO actions
11:56:17 <johanneslippmann> If I want to create a new show function I need to produce a String
11:56:24 <typoclass> johanneslippmann: «"hello \n world"» is an acceptable String. «print "hello \n world"» is an IO action
11:56:49 <dmwit> You've told us the X (and we know the Z) of "I did X, expecting Y, but Z happened instead", but not the Y yet. =)
11:56:51 <johanneslippmann> But a String doesn't seem to be able to have multiple lines.
11:56:58 <johanneslippmann> Is that correct?
11:56:59 <tgeeky> > "hello \n tgeeky"
11:57:02 <lambdabot>   "hello \n tgeeky"
11:57:05 <dmwit> johanneslippmann: That is not correct.
11:57:13 <jfischoff> mokus: I'll open an issue. Thanks for the help so far
11:57:19 <typoclass> johanneslippmann: no, it can have multiple lines. you can represent them as "\n"
11:57:29 <Mortchek> "\n" is a string containing just a line break
11:57:44 <johanneslippmann> But these multiple lines are not printed as multiple lines in ghci?
11:57:48 * hackagebot hquery 0.1.0.3 - A query language for transforming HTML5  http://hackage.haskell.org/package/hquery-0.1.0.3 (TychoAndersen)
11:57:49 <Mortchek> You're confused, I think, because print does something you don't expect, namely, show the character escaped
11:57:55 <geekosaur> johanneslippmann, you are probably being confused by the fact that many things (including ```print```) use show, and show makes newlines and other control characters in source form (e.g. the sequence "\n" instead of a newline character)
11:58:11 <Mortchek> In fact that's a consequence of show, which does that
11:58:13 <dmwit> johanneslippmann: The Show instance for String does not produce strings with newlines in them, even if the string itself has newlines.
11:58:15 <geekosaur> ghci also defaults to doing that with a non-IO resulty
11:58:18 <Mortchek> > show "foo\nbar"
11:58:20 * tgeeky types \n\n\n\n many times to hide geekosaur's correct comment
11:58:21 <lambdabot>   "\"foo\\nbar\""
11:58:49 <dmwit> johanneslippmann: ghci shows everything before displaying it. Conclusion: ghci will not print multiple lines of text for any String value (though some lines may wrap onto the next if your terminal is short).
11:59:10 <typoclass> johanneslippmann: try this -- start ghci and compare «print "abc\ndef"» versus «putStrLn "abc\ndef"»
11:59:21 <dmwit> > "a\nb"
11:59:23 <lambdabot>   "a\nb"
11:59:25 <dmwit> > show "a\nb"
11:59:27 <lambdabot>   "\"a\\nb\""
11:59:31 <dmwit> > show (show "a\nb")
11:59:33 <lambdabot>   "\"\\\"a\\\\nb\\\"\""
11:59:43 <dmwit> > text "a\nb"
11:59:45 <lambdabot>   a
11:59:45 <lambdabot>  b
11:59:46 <johanneslippmann> So do I have a chance to test my show function and see the multiple lines?
11:59:52 <Mortchek> > show . show . show . show . show $ "a\nb"
11:59:55 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"a\\\\\\\\\\\...
11:59:57 <benzrf> hey,
12:00:05 <typoclass> dmwit: my ghci doesn't ...? putStr "abc\ndef" prints two lines
12:00:06 <dmwit> Yes. Use putStr, as has been suggested at least four times now. =)
12:00:06 <Mortchek> johanneslippmann, yes, use putStrLn
12:00:10 <Mortchek> or putStr
12:00:12 <Mortchek> Either one
12:00:17 <dmwit> typoclass: putStr does not call show.
12:00:24 <typoclass> dmwit: yes
12:00:34 <dmwit> typoclass: Alternately, conceptually the Show instance for IO a executes the action and returns an empty string.
12:00:35 <typoclass> dmwit: right, ok
12:02:05 * dmwit . o O ( :set -XFlexibleInstances -XIncoherentInstances; instance Show String where show = id )
12:02:49 * hackagebot hsdns-cache 1.0.3 - Caching asynchronous DNS resolver.  http://hackage.haskell.org/package/hsdns-cache-1.0.3 (VladimirShabanov)
12:02:50 <johanneslippmann> So I will say: putStrLn $ showTree exampleTree
12:02:50 <Mortchek> That intuition doesn't explain the output in GHCi of: putStrLn (show "foo") >> return "bar"
12:03:01 <dmwit> johanneslippmann: perfect
12:03:09 <Mortchek> It suppresses output only of IO (), I believe
12:03:22 <dmwit> Mortchek: You're right. I retract my conceptual explanation.
12:03:39 <johanneslippmann> No, the output is: 4/n2/n1/n/n/n3/n/n/n6/n5/n/n/n7/n/n
12:04:01 <dmwit> johanneslippmann: Perhaps you typed /n instead of \n in your String literals.
12:04:06 <johanneslippmann> (The exampletree has Ints from 1 to 7 as values)
12:04:33 <dmwit> If not, well...
12:04:35 <dmwit> ?hpaste
12:04:35 <lambdabot> Haskell pastebin: http://hpaste.org/
12:04:51 <johanneslippmann> Oh damn! Its that easy isn't it?
12:04:56 <johanneslippmann> Ha!
12:05:11 <tgeeky> humansnack dmwit
12:05:17 <dmwit> =D
12:05:42 <hpaste> dmwit pasted “let's confuse the newcomers!” at http://hpaste.org/87166
12:06:07 <Mortchek> :D
12:06:18 <hpaste> Kaligule pasted “show me the tree” at http://hpaste.org/87167
12:06:43 <bjackman> A question: Does partial application make parameter order more significant? If you want a function that maps any function over a list, you can do "\f -> map f theList". But there is no way around the issue for type constructors. Do you guys agree or am I missing something?
12:07:06 <dmwit> Just in case this is not just an exercise to practice Haskell (which I understand is a slim chance): Data.Tree already offers drawTree.
12:07:33 <dmwit> bjackman: Correct: parameter order is very significant, especially at the type level where there is no lambda.
12:07:34 <Mortchek> bjackman, yes, it means you tend to leave the parameters that "change" more often for last.
12:07:42 <bjackman> The data-constructor equivalent of my example would be something like "\T -> Either T ConcreteType" (but obviously that doesnt make sense)
12:07:53 <johanneslippmann> dmwit:
12:07:57 <typoclass> bjackman: when writing functions, i do consider which parameters are more likely to vary, and place them last (if it makes sense)
12:07:59 <bjackman> Okay awesome, glad I understood that right!
12:08:04 * tgeeky tries to think of other cases where the paramter order is really problematic except partial application
12:08:06 <dmwit> bjackman: Of course, more exciting languages do have type-level lambda. And then it doesn't matter again. =)
12:08:09 <typoclass> bjackman: of course we have flip and so on
12:08:13 <johanneslippmann> dmwit : It is an exercise, but thank you very much.
12:08:27 <dmwit> right
12:08:37 <bjackman> Ok so is there any way to partially apply a type constructor according to a different parameter order?
12:08:47 <dmwit> bjackman: You can make a type which is isomorphic to \T -> Either T ConcreteType, of course.
12:08:55 <bjackman> And which languages have a type-level lambda? And what is it called? That sounds about as meta as it gets!
12:08:58 <dmwit> newtype Flip f a b = Flip (f b a)
12:09:03 <typoclass> bjackman: "\f -> map f theList" is the same as "flip map theList" is the same as "(`map` theList)"
12:09:05 <thoughtpolice> well, i mean, you can just use another type to flip the type variables
12:09:08 <thoughtpolice> as dmwit showed
12:09:15 <dmwit> bjackman: Any good dependently typed language has type-level flip, e.g. Agda, Idris, Coq
12:09:18 <thoughtpolice> Flip is already defined somewhere too, IIRC
12:09:26 <thoughtpolice> probably an edwardk library
12:09:46 <bjackman> dmwit: ah yeah so type-level flip is simple
12:09:47 * tgeeky objects that the examples in question only have two paratmers
12:10:06 <bjackman> but to re-order more complex sets of type parameters you'd have to make a more-complex "flip" type for each size
12:10:07 <tgeeky> even with three, there are several flip functions
12:10:08 <dmwit> You can also write type family Flip f b a; type instance Flip f b a = f a b
12:10:23 <dmwit> tgeeky: The type family one doesn't. =)
12:10:31 <dmwit> But of course it's basically useless, since you can't write instances for it, etc.
12:10:44 <bjackman> haha thanks guys!
12:10:49 <dmwit> bjackman: Yes. And also the new type doesn't carry along all the fun stuff from the old one, like instances of type classes and such.
12:10:50 <bjackman> haskell is definitely expanding my mind!
12:11:07 <bjackman> dmwit: ah... so is there any way to propagate the typeclasses automaticall?
12:11:14 <dmwit> newp
12:11:32 <dmwit> It may not even be possible, automatically or otherwise. =)
12:11:55 <dmwit> e.g. Monad instances require the final type parameter to be the one that's polymorphic in the methods.
12:12:05 <facepalm> dmwit: I changed it to this http://hpaste.org/87164
12:12:06 <typoclass> > let (~~) = flip ; m = map ~~ [0..3] in m succ -- bjackman: this doesn't really solve anything, but sometimes it's a cute trick for 2-argument functions
12:12:08 <lambdabot>   [1,2,3,4]
12:12:24 <typoclass> bjackman: i like to use ␣ instead of ~~, but lambdabot doesn't like unicode :-)
12:12:37 <dmwit> facepalm: Actually, that's quite close!
12:12:45 <dmwit> facepalm: You just need a bit more parenthesization around (Ship []).
12:12:49 * hackagebot haggis 0.1.1.1 - A static site generator with blogging/comments support  http://hackage.haskell.org/package/haggis-0.1.1.1 (TychoAndersen)
12:13:08 <bjackman> wow
12:13:10 <bjackman> haha
12:13:25 <dmwit> < let (␣) = flip in map ␣ [0..3] (+1)
12:13:29 <goodfellow>   mueval-core: Time limit exceeded
12:13:33 <dmwit> urk
12:13:48 <typoclass> dmwit: oh! but at least it didn't choke on the unicode :-) thanks, very good
12:14:00 <dmwit> < let (␣) = flip in (map ␣ [0..3]) (+1)
12:14:03 <goodfellow>   [1,2,3,4]
12:14:03 <facepalm> dmwit: it says  Couldn't match expected type `[Ships]' with actual type `Ships'
12:14:30 <dmwit> goodfellow takes a few transactions to warm up each time I restart it. =P
12:14:44 <ryant5000> is there any way to list all the threads that are currently running?
12:15:09 <dmwit> ryant5000: You probably have to keep track of them yourself as you spawn/exit them.
12:15:24 <dmwit> That said, I don't positively know that there's no way to get such a list.
12:15:46 <ryant5000> dmwit: yeah, that's what i normally do, but i've got a group of threads, and i'm trying to determine which of them is hanging/dying
12:16:00 <dmwit> facepalm: I guess that's because you should write areSunk :: Ships -> Bool -- ?
12:16:27 <dmwit> facepalm: Right? Since areSunk takes a Ships, i.e. a bunch of Ship, not a bunch of Ships, i.e. a bunch of bunch of Ship.
12:17:05 <facepalm> areSunk takes a list of ships
12:17:10 <facepalm> Ships
12:17:42 <tgeeky> facepalm: This is a list of ships: [Ship]
12:17:46 <byorgey> @oeis 1 1 2 3 5 9
12:17:54 <lambdabot>  Number of n-bead necklaces with beads of 2 colors and primitive period n, wh...
12:17:54 <lambdabot>  [1,1,1,1,2,3,5,9,16,28,51,93,170,315,585,1091,2048,3855,7280,13797,26214,499...
12:18:22 <byorgey> @oeis 1 1 2 3 5 9 15
12:18:26 <lambdabot>  Number of fountains of n coins.
12:18:26 <lambdabot>  [1,1,1,2,3,5,9,15,26,45,78,135,234,406,704,1222,2120,3679,6385,11081,19232,3...
12:18:58 <dmwit> facepalm: areSunk takes a single Ships, which is a list of Ship
12:19:15 <dmwit> s/is a list of Ship/has a list of Ship inside/
12:20:51 <sclv__> no preflex is about!
12:20:51 <jfischoff> what would be involved with getting ghc to build in parallel?
12:21:11 <luite> one gsoc project ;)
12:21:20 <jfischoff> true that
12:21:32 <jfischoff> has anyone looked into before?
12:21:37 <luite> yeah simon marlow
12:21:42 <luite> but it was unfinished
12:21:59 <jfischoff> I wonder how much work was left?
12:22:03 <tgeeky> jfischoff: and Neil ... <brainfart> who wrote shake, etc
12:22:05 <geekosaur> go digging in the glasgow-haskell-users archive for the discussion about it
12:22:12 <dmwit> sclv__: I guess the guy to complain to is mauke?
12:22:32 <bwr> Hi, I'm trying to parse some XML and running into trouble with memory and I was wondering if anybody can point me in the right direction for making this not-lazy which is what I think I need to do to not run out of memory. http://hpaste.org/87170
12:22:33 <Botje> tgeeky: mitchell
12:22:38 <jfischoff> geekosaur: yeah good idea
12:22:42 <sclv__> mauke: seen: preflex
12:22:56 <sclv__> i'm pinging marlow about it now
12:23:13 <luite> jfischoff: dunno, parcs thinks most of the work is already done, i hope that's true :)
12:23:32 <jfischoff> that would be awesome
12:23:36 <facepalm> dmwit: I think it worked. im just debugging now. http://hpaste.org/87164 thisis targetShip and it is saying  In the return type of a call of `Ship'     In the first argument of `targetShip', namely `(Ship [])'     In the third argument of `assertEquals', namely       `(targetShip (Ship []) (Address A One))'
12:24:00 <facepalm> http://hpaste.org/87164
12:24:02 <Botje> bwr: won't holding on to events like that prevent GHC from garbagecollecting it?
12:25:03 <timthelion> Are there any current GHC extensions that support patter grouping? IE case compare 4 5 of GT or EQ -> doThis ; LT -> doThat ?
12:25:07 <bwr> Botje: I don't really know what I'm doing (also looks like my test data didn't cover enough cases and my code doesn't actually entirely work)
12:25:27 <timthelion> and no, I don't want patter gards or let
12:25:36 <byorgey> timthelion: no
12:25:42 <timthelion> Pitty
12:26:05 <timthelion> And has anyone written up the TH for it?
12:26:11 <byorgey> I doubt it.
12:26:23 <byorgey> because everyone just uses guards or let.
12:26:41 <timthelion> byorgey: but they aren't as pretty :(
12:26:53 <byorgey> boo hoo
12:26:59 <timthelion> byorgey: :D
12:27:14 <fryguybob> timthelion: This? http://www.haskell.org/haskellwiki/MultiCase
12:27:19 <tgeeky> aren't as retty as what?
12:27:19 <sclv__> the problem would i think be when the patterns do bindings...
12:27:25 <Botje> bwr: also, you're compiling with ghc -O2, right?
12:27:27 <sclv__> like how do you translate that.
12:27:27 <tgeeky> s/retty/pretty/
12:27:32 <byorgey> | compare 4 5 `elem` [GT, EQ] = ...  | otherwise = ...   looks lovely.
12:27:37 <bwr> Botje: no, i've just been doing ghc --make
12:27:44 <Botje> try adding -O2 then
12:27:59 <Botje> can't hurt, might fix it.
12:28:00 <timthelion> sclv__: that is true :)
12:28:01 <bwr> I just tried it and I still run out of memory
12:28:38 <Botje> bwr: oh. uh.
12:28:46 <Botje> why are you doing mapM instead of mapM_?
12:29:13 <Botje> that will construct a huge list full of ()s :]
12:29:14 <bwr> oh good point
12:29:24 <timthelion> sclv__: but there is an obvous fix to that. Make case x of L y z or Y m o -> anError ; L y z or Y y z -> notACompileErrorIfTheTypesMatch
12:29:36 <mauke> preflex: version
12:29:37 <preflex>  7.042
12:30:03 <bwr> Botje: still run out of memory but that was probably one of the problems
12:30:27 <bwr> Botje: is there any way to do a fold in there instead of map?
12:30:29 <sclv__> "obvious fix"
12:30:43 <sclv__> preflex: seen jaffacake
12:30:44 <preflex>  jaffacake was last seen on #ghc 57 days, 2 hours, 18 minutes and 11 seconds ago, saying: when they said "best for developers" they meant something else beginning with "b", but not "best"
12:30:44 <bwr> or would that not make any difference since i am discarding the result with mapM_
12:30:49 <mauke> sclv__: ur desires r now met
12:30:56 <timthelion> sclv__: well, it's obvious in that it is the only possible way to solve the problem reasonably.
12:30:59 <Botje> bwr: well, my second guess is still on keeping a reference to events. try inlining it into the execWriterT thing
12:31:06 <sclv__> life is good
12:31:08 <Botje> bwr: or maybe just scoping the events thing to the execwriterT.
12:31:26 <bwr> Botje: sorry i'm not sure what you mean by those suggestions
12:31:30 <Botje> y <- let events = parse ... in execWriterT ...
12:31:44 <bwr> Botje: this is my first experience with monad transfomers
12:32:03 <Botje> but even that may be too broad a scope.
12:32:30 <Botje> bwr: you're keeping a reference to events, which will grow quite big
12:32:31 <bwr> hmm
12:32:35 <bwr> yea
12:32:46 <Botje> if you don't keep a reference haskell can eat the list as it is generated, resulting in constant memory usage
12:33:16 <bwr> that would be ideal, but i'm not sure how to go about that
12:33:41 <Botje> the first way to be absolutely sure is to replace events on line 21 with its definition
12:33:46 <Botje> (and then drop the let events = ..., obviously)
12:33:54 <bwr> ok
12:34:23 <bwr> yea, thta didn't change anything
12:34:35 <Botje> of course, that's under the assumption that your SAXEvent stream is actually the cause of the leak :/
12:35:28 <Botje> then you'll need to profile and ask someone who's more familiar with that sax library, sorry
12:36:08 <bwr> Botje: thanks for your time anyway
12:39:04 <quchen> Alright, compilation of GHC fails with error messages I can't make much sense of ... http://hpaste.org/87172
12:39:09 <quchen> Those are the last couple of lines.
12:39:13 <quchen> I have no idea what to do. :s
12:40:12 <tgeeky> google search parts of error messages
12:40:23 <Botje> bwr: something else that might cause trouble is your tell [text]
12:40:28 <tgeeky> quchen: these are warnings, about documentation
12:40:31 <tgeeky> I think?
12:40:39 <Botje> I think the writerT might be building up a _huge_ thunk
12:40:56 <geekosaur> looks like haddock warniungs, yes
12:41:04 <quchen> tgeeky: That may be, some docs were generated before.
12:41:27 <tgeeky> quchen: those are documentation warnings. Perhaps for your code, probably not.
12:42:03 <quchen> tgeeky: That brings me down to "there's no error message at all" :-/
12:42:14 <tgeeky> quchen: which is a good place to be!
12:43:08 <quchen> tgeeky: Alternatively everything went alright and I can't find the executable in the directory tree.
12:43:08 <tgeeky> quchen: Your hpaste is perhaps not as complete as it could be, but it looks like compilation does not fail
12:43:28 <quchen> I don't want to "make install" though to keep my dirs clean :-)
12:43:46 <quchen> I'll just look for executable files named ghc then :s
12:44:16 <bwr> Botje: but tell [text] should just be the titles
12:44:21 <bwr> it shouldn't be a huge amount
12:44:23 <geekosaur> generally it's in a stage dir e.g. stage1/ghc
12:44:39 <quchen> geekosaur: Oh. What are those stages?
12:44:42 <dmwit> ls **/ghc # ;-)
12:45:03 <Botje> okay, no idea then.
12:45:10 <geekosaur> (although that may be a script in which case it will contain a path t the ghc executable. note that you probably want the script though as it tells ghc where to find its butt)
12:45:40 <bwr> i mean, i'm running it on a small subset of wikipedia's xml export
12:45:54 <quchen> geekosaur: So that basically means running configure again with a prefix and then recompiling
12:45:59 <geekosaur> quchen, ghc normally builds 3 stages. stage 1 is built with the native compiler, stage 2 is built from stage 1, stage 3 is built from stage 2; the latter two are then tested to verify they produced the same result
12:46:06 <tgeeky> geekosaur: and as http://www.aosabook.org/en/ghc.html tell us , the butt is the most important part of GHC!
12:46:10 <bwr> around 140 mb of xml so probably like 1000+ articles
12:46:50 <quchen> geekosaur: I've got files in the "tmp" directories of stage 1 and 2.
12:46:54 <tgeeky> bwr: you can speculate all you want, but until you profile and get evidence, we're all just wizards here
12:46:55 <quchen> There's no stage 3 though.
12:47:19 <parcs> luite: yah, it's true. i even fixed the last race condition that i mentioned before.
12:47:22 <quchen> geekosaur: So basically compiling GHC compiles it twice: once with my GHC, and then again with itself to check for consistency?
12:47:35 <bwr> tgeeky: i'll have to research how to profile then
12:47:42 <luite> parcs: so you have nothing to do this summer? ;)
12:47:45 <simpson> Hey, does anybody familiar with UnicodeSyntax know why U+2731 (HEAVY ASKTERISK) is not used for * instead of U+2605 (BLACK STAR) ?
12:47:54 <simpson> I mostly ask because a coworker inquired.
12:48:26 <typoclass> simpson: you, mean in kinds?
12:48:29 <parcs> luite: that's why i put in those auxiliary goals ;)
12:48:31 <simpson> typoclass: Yeah.
12:49:00 <dmwit> It's probably closer to the symbol that's traditionally used in academic papers.
12:49:24 <typoclass> simpson: randomness? or maybe they looked up 'heavy asterisk' in 3 fonts and discovered 'black star' has more support
12:49:31 <dmwit> ...which is probably \star
12:49:44 <simpson> Mm.
12:50:31 <simpson> I made a joke ("We got both kinds: * and * -> *") and used UnicodeSyntax to say it, and got this response. Just figured that if there had been a bikeshed before, y'all would know about it. :3
12:51:02 * tgeeky thinks it's homage to Simon & Simon's late 80s heavy metal band Black Star
12:51:37 <simpson> Not to mention the Malmsteen song of the same name.
12:52:26 <tgeeky> simpson: I don't know that song, but I had a good time picturing SPJ and Simon in KISS paint
12:52:55 <byorgey> simpson: it is traditional to typeset kinds using the LaTeX \star command which generates something that looks like BLACK STAR and not HEAVY ASTERISK
12:53:09 * dmwit feels validated
12:53:13 <byorgey> oh, dmwit already said that =)
12:53:18 <simpson> tgeeky: Ha!
12:53:22 <geekosaur> @check dmwit -- :p
12:53:24 <lambdabot>   Not in scope: `myquickcheck'Not in scope: `dmwit'
12:53:30 <dmwit> hehe
12:53:35 <simpson> byorgey: That's what I've always seen too.
12:53:41 <typoclass> magnificent stereo today is a magnificent echo ...?
12:53:54 <simpson> I mean, * -> * is spoken as "The kind of star returning star," right?
12:54:10 <tgeeky> hysterical raisins: 3,428;  well-reasoned argument: 18;
12:54:17 <byorgey> I would pronounce it as "star to star" or maybe "star arrow star"
12:55:26 <typoclass> "twinkle pointy twinkle"
12:56:00 <dmwit> For maximum clarity, it's a good idea to get in the habit of making up a fresh name on each invocation. "twinkle pointy star"
12:56:23 <simpson> I'm used to talking to beginners, so I guess I try to spell things out as well as I can.
12:57:47 <typoclass> simpson: there's nothing wrong with that
12:58:01 <quchen> If I run "make install" after compiling GHC, will it do anything outside the PREFIX directories? For example, should I backup my ~/.ghc?
12:58:13 <byorgey> simpson: well "star returning star" sounds weird/wrong to me.  Maybe something like "taking star returning star".
12:58:40 <simpson> byorgey: Yeah, it does sound wrong out loud. Clearly I don't talk about kinds enough. :3
12:59:27 <DigitalKiwi> i have no idea what * -> * is but "star arrow star" sounds best to me
12:59:31 <byorgey> quchen: it might do something in ~/.ghc, but there's a different subdirectory in there for each version of GHC
12:59:33 <dmwit> You might consider avoiding the "star" jargon and calling it "type" instead, maybe?
12:59:52 <byorgey> you shouldn't have to back anything up
12:59:55 <DigitalKiwi> only cause i can't pronounce asterisk
13:00:14 <quchen> byorgey: Oh right, there's multiple folders in there, silly question, sorry
13:00:27 <quchen> byorgey: I somehow thought about .cabal
13:02:18 <simukis_> Hi, I'm struggling with Attoparsec a bit. I want to parse unicode escape sequence which might be something like '\\[0-9a-fA-F]{1,6}'. I'm having a problem finding how would one take UP TO 6 characters instead of until the parser fails.
13:03:09 <simpson> dmwit: I thought about that. Naming kinds sounds reasonable to me, maybe because there's a name for GHC's sort. (And seriously, what isn't awesome about the sort being named "BOX"?)
13:03:50 <dmwit> simukis_: I'm not sure if this is the best way, but maybe something like replicateM 6 digit <|> replicateM 5 digit <|> ... <|> replicateM 1 digit -- ?
13:04:04 <Chousuke> DigitalKiwi: it's a kind signature, one for an ordinary single-argument type constructor
13:04:05 <mauke> upto n p | n <= 0 = pure [] | otherwise = ((:) <$> p <*> upto (n - 1) p) <|> pure []
13:04:34 <dmwit> Right, or factor more as mauke suggests.
13:04:48 <mauke> there's probably a combinator for that
13:05:01 <elliott> @quote box
13:05:02 <lambdabot> elliott says: <elliott> I like how edwardk's answer to every question always goes "most abstract solution to the problem possible --> microoptimisation details". <elliott> I swear I've seen him go
13:05:02 <lambdabot> from category theory to unboxed types and unsafeCoerce in a single line of IRC.
13:05:07 <elliott> no! wrong quote about boxes.
13:05:13 <elliott> bad lambdabot.
13:06:17 <hpc> unsafeCoerce is just a hylomorphism in the category of bitwise parsing!
13:06:18 * simukis_ is sad. /me thought thoughtful library authors would've thought about it already :)
13:06:22 <dmwit> simukis_: There's also e.g. manyTill, though this will not stop when it reaches some number of successful parses.
13:09:59 <facepalm> dmwit: sorry I had to disconnect... my only real errors are coming from targetShip and targetShips http://hpaste.org/87164 and they are type errors
13:10:15 <quchen> Alright, did the recompilation and make install, result is a decent size of nerdy terminal output and a make error :-E http://hpaste.org/87175
13:10:23 <quchen> This makes you realize how useful Cabal is sometimes ;-)
13:10:41 <sclv__> @quote elliott box
13:10:41 <lambdabot> elliott says: (regarding existentials) <acowley> Haven't you ever wanted to put something in a box and never think about it? <elliott> children
13:10:46 <simukis_> ok, I'll try doing the way mauke suggested with some changes of my own. Thanks
13:12:16 <elliott> sclv__: hey hey, it wasn't my quote.
13:12:24 <elliott> I'm no self-quoter!
13:13:14 <sclv__> it was the best box quote i could find
13:13:41 <elliott> @quote it.is.box
13:13:42 <lambdabot> byorgey says: The box does not care whether you think it is stupid.  It is box.
13:13:45 <elliott> that one.
13:18:09 <simpson> Ha.
13:18:28 <simpson> @quote herding.cats
13:18:28 <lambdabot> stephen_turnbull says: First Principle of Herding Cats: Put the cats in a box, then herd the box.
13:18:56 <lispy> :k Cats :: BOX
13:18:58 <lambdabot> parse error on input `::'
13:19:54 <Twey> What's a nice, non-hacky way to talk about ‘if length list < n then … else …’ that doesn't involve taking the length of the whole list?
13:20:35 <facepalm> would someone be able to look at this for me please?   and assist me with fixing my type errors http://hpaste.org/87164
13:21:39 <lispy> Twey: you could recurse on the list and n until you get to 0 or the end of the list
13:21:44 <Botje> facepalm: why do you think (Ships ships) is value of type [Ship] ?
13:22:32 <Twey> lispy: Yeah, I was just looking for a solution that doesn't involve direct recursion.  Seems like something that should exist or be easily composable from parts.
13:22:35 <parcs> Twey: if null (drop (n-1) list) then ... else ..
13:22:47 <Twey> parcs: Cute, thanks
13:22:53 <facepalm> Botje: Ship is a list of ships
13:23:12 <Botje> facepalm: come again?
13:23:20 <parcs> lol
13:23:29 <Botje> which 'Ship' are you talking about?
13:23:37 <Botje> the type constructor? the data constructor?
13:23:45 <Botje> or did you mean 'ships' the variable?
13:24:47 <sclv_> Twey: fmap void list < replicate n ()
13:24:53 <facepalm> I did targetShips (Ships ship) because the first param is a list of Ships I called ships
13:25:09 <sclv_> oh not fmap void, just void
13:25:12 <sclv_> ?ty void
13:25:15 <lambdabot> Functor f => f a -> f ()
13:25:16 <Botje> facepalm: where is this 'Ships' thing defined?
13:25:26 <sclv_> [()] is isomorphic to a lazy nat!
13:25:28 <facepalm> data Ships = Ships [Ship] deriving(Show)
13:25:38 <Twey> sclv_: Also neat, but less efficient
13:25:43 <Twey> It is :þ
13:25:55 <hpaste> facepalm revised “Functions”: “funcs” at http://hpaste.org/87164
13:26:07 <facepalm> there is all the data too
13:26:12 <Botje> facepalm: okay, so why are you claiming to receive a [Ship] and then pattern matching as if you received a 'Ships' value?
13:26:31 <Botje> [Ship] != Ships
13:27:00 <facepalm> oopd
13:27:03 <facepalm> oops
13:27:50 <Botje> (note: your Ships type does not add anything useful over [Ship], so I would just drop it and use [Ship] directly.)
13:28:44 <facepalm> targetShips :: [Ships] -> Address -> Ships targetShips (Ships ships) loc = Ships (map (targetShip loc)ships)  so like this
13:28:58 <Botje> what the ..
13:29:11 <Botje> facepalm: you have to choose.
13:29:16 <Botje> [Ship] or Ships. you can't have both.
13:29:48 <Botje> (well, you can, but this is getting pretty confusing.)
13:30:05 <Botje> targetShips ships loc = map (targetShip loc) ships
13:30:19 <Botje> that has type targetShips :: [Ship] -> Address -> [Ship]
13:32:45 <facepalm> now it complains about address
13:32:48 <facepalm> =/
13:33:40 <Botje> what do you mean 'complains'
13:34:17 <facepalm>  Couldn't match expected type `Ship' with actual type `Address'
13:34:29 <facepalm> Couldn't match expected type `Ships' with actual type `[Ship]'
13:34:50 <Botje> why do you still have a Ships somewhere... -.-
13:36:03 <facepalm> I have this --targetShips-- targetShips :: [Ship] -> Address -> Ship targetShips ships loc = map (targetShip loc) ships
13:36:47 <Botje> yes, that type is obviously wrong.
13:36:59 <Botje> what is the return type of the map in this case?
13:37:25 <facepalm> should be a list of ships
13:37:39 <Botje> and your type promises it's a single Ship.
13:39:23 <facepalm> I had Ships before
13:39:50 <Botje> yes, and you kicked that out.
13:39:51 <parcs> :t fmap void
13:39:53 <lambdabot> (Functor f1, Functor f) => f (f1 a) -> f (f1 ())
13:39:57 <Botje> so it's [Ship]
13:40:44 <facepalm> I still have my type class of Ships I didnt remove it from the program
13:41:37 <Botje> you have to standardise on Ships or [Ship].
13:41:51 <_just> remove it, it is super annoying to read with all those Ship Ships [Ship] :D
13:42:00 <Botje> don't mix the two, that just makes stuff confusing.
13:43:28 <facepalm> ok targetShips takes a list of Ships  type class Ships is a list of [Ship] 's and Ship[Cell]
13:43:32 <facepalm> so I have to have both in there
13:43:59 <hammond> Hey guys
13:44:13 <hammond> Haskell is an awesome programming language
13:44:25 <typoclass> hammond: yup :-)
13:44:32 <Botje> facepalm: make a choice, now. standardize on Ships or [Ship].
13:44:32 <hammond> I can't believe how much it improved my thinking abilities.
13:44:59 <hammond> I now see things differently.
13:45:15 <hammond> Botje you are actually a function. did you know that?
13:45:51 <hammond> I want to know so much haskell that I will eventually move into pure functionalism.
13:46:47 <typoclass> hammond: glad to hear it :-) a bold proclamation
13:47:15 <hammond> yes I'm happy yes.
13:47:22 <facepalm> for targetShips ill use Ships
13:49:07 <Botje> fine, then change your code accordingly.
13:49:53 <quchen> YEEEEEEEEAH GHC BUILD WORKS
13:50:04 <quchen> Sorry, I had to tell someone and my cat wouldn't listen.
13:50:13 <acowley> We hear you quchen. We hear you.
13:50:27 <acowley> I'll find another cat to tell.
13:50:33 <facepalm> now I have targetShips :: Ships -> Address -> Ships targetShips ships loc = (map (targetShip loc) ships
13:50:34 <acowley> They must know.
13:50:36 <typoclass> quchen: heheh :-) how cute. kitty does not give any sort of crap about ghc
13:50:37 <quchen> I feel like I have created something. I have crafted a compiler!
13:50:48 <quchen> Time for the painful part now I guess: modifying Prelude. :s
13:50:59 <otters> make (++) mappend
13:51:27 <acowley> We have to scrap GHC and start over so we can make (++) = mappend
13:51:48 <otters> and concat should be join
13:51:51 <otters> that is all
13:52:05 <quchen> Yes, that should fix all our current weird things.
13:52:16 <quchen> Actually I'm trying to get Applicative => Monad in right now.
13:52:17 <otters> I like the idea of concat-ing a nested monadic value
13:53:24 <typoclass> @remember acowley <quchen> YEEEEEEEEAH GHC BUILD WORKS! Sorry, I had to tell someone and my cat wouldn't listen. <acowley> I'll find another cat to tell. They must know.
13:53:25 <lambdabot> It is forever etched in my memory.
13:54:24 <quchen> Ratio of quotes by myself remembered by Lambdabot by Typoclass: 1
13:54:33 <quchen> You're like a librarian.
13:55:26 * typoclass purrs
13:56:40 <FireFly> The corresponding ratio for me isn't defined :<
13:56:55 <Chousuke> so success must be reported to cats and problems to ducks? okay.
13:57:22 <typoclass> FireFly: i didn't understand what that ratio is anyway, so mine is undefined as well. high five
13:57:32 <typoclass> Chousuke: yes, very good =D
13:57:48 <acowley> Shaved a yak, found a duck, shaved some more, told a cat.
13:57:52 <quchen> ALRIGHT GHC I JUST ADDED THE APPLICATIVE SUPERCLASS
13:57:54 <quchen> BRING IT ON
13:58:02 <facepalm> Botje: targetShips :: Ships -> Address -> Ships targetShips ships loc = (map (targetShip loc) ships) shouldnt this be correct now?
13:58:04 <FireFly> typoclass: mine is undefined since all the involved numbers are zero, and there's a division involved :p
13:58:18 <FireFly> But high five anyway!
13:58:36 <Botje> facepalm: according to your code, ships :: Ships.
13:58:49 <Botje> facepalm: does map accept a value of type Ships?
13:59:31 <Botje> (now, had you defined Ships as a type alias, this code would actually work.)
14:00:14 <facepalm> did you look at the ssecond hpaste I posted that has all the code in it?
14:00:48 <Botje> I have no idea how much of it is still current.
14:00:51 <facepalm> I will paste another with the actual instructions for it it too maybe that will make things more clear...perhaps I am explaining it wrong
14:01:31 <Chousuke> facepalm: you should simplify the code so that Ships is just a list of Ships instead of a completely new type that is just a list of Ships :)
14:03:28 <hpaste> facepalm revised “Functions”: “funcs” at http://hpaste.org/87164
14:03:47 <facepalm> there is my current code and the specs for each other of the functions
14:04:44 <Botje> facepalm: you should know the drill by now.
14:04:50 <Botje> you defined data Ships = Ships [Ship]
14:04:54 <Botje> map wants a [Ship].
14:04:57 <Botje> so you need to ... ?
14:05:34 <facepalm> thats why before I had Ships (map (targetShip loc)ships)
14:06:18 <Botje> now that you've chosen to use Ships instead of [Ship], add that pattern matching back in.
14:06:29 <acowley> What's the thinking behind making Ships a data type?
14:06:58 <Botje> it's more a case of not knowing about type aliases, I think.
14:07:17 <dlorant> say, i've got a (Monad m) => [(a -> m a)], and a base a value. Would folding be the best way to chain these together?
14:07:24 <_just> targetShip :: Ship -> Address -> Ship versus (map (targetShip loc)) with loc :: Address
14:07:58 <facepalm> ok so I just uncommented the one I had there
14:08:03 <Botje> dlorant: sure. look into foldM
14:08:06 <acowley> @type \x -> sequence . map ($x)
14:08:09 <lambdabot> Monad m => a1 -> [a1 -> m a] -> m [a]
14:08:14 <dlorant> awesome, thanks!
14:08:34 <acowley> Oops! I misunderstood the desired behavior.
14:08:47 <Botje> facepalm: okay, that seems sensible enough.
14:08:55 <Botje> @type foldM
14:08:58 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
14:09:40 <monoidal> :t foldr (<=<)
14:09:42 <lambdabot> Monad m => (a -> m b) -> [b -> m b] -> a -> m b
14:10:01 <Botje> ooh, nice.
14:10:46 <dlorant> Botje++
14:10:47 <monoidal> :t foldr (<=<) return
14:10:48 <lambdabot> Monad m => [b -> m b] -> b -> m b
14:11:16 <Botje> facepalm: so does it now compile? or are you still missing stuff?
14:11:52 <_just> Botje: how should map (targetShip loc) work if targetShip :: Ship -> Address ->  Ship
14:13:26 <Botje> _just: badly, I imagine :)
14:13:29 <int-e> _just: then use \s -> targetShip s loc  or   flip targetShip loc
14:14:01 <_just> int-e: yeah just wanted to point it out to faceplam
14:14:04 <int-e> (or (`targetShip` loc) but only if you like reading that as an infix operator)
14:14:32 <_just> now facepalm has a solution for his homework i guess
14:16:42 <sirspazzolot> huh. is haskell + microprocessors something that happens? gonna build a quadcopter, dunno if taking sensor input and controlling motors is very haskell-y
14:16:56 <sirspazzolot> haskellic? haskool?
14:17:46 <Botje> sirspazzolot: there's atom.
14:17:47 <typoclass> sirspazzolot: there's the atom package. haven't used it myself, but apparently you write haskell to make embedded software whatnots
14:18:00 <acowley> sirspazzolot: You can use Haskell to generate code for a microcontroller
14:18:08 <geekosaur> there's a not-fully-working port to ARM; nhc98 used to target embedded microprocessors; jhc produces portable ANSI C that can probably be compiled on various CPUs. atom is more likely, but you don't actually run Haskell on the targer
14:18:11 <geekosaur> *target
14:18:14 <typoclass> sirspazzolot: also, very good word choice :-) haskelly, haskellic, haskool
14:18:17 <acowley> sirspazzolot: Or you can use JHC
14:18:38 <sirspazzolot> heh haven't even touched haskell yet, I'll stick with plain ol' C
14:18:42 <thoughtpolice> geekosaur: we (GHC) are almost there on the ARM front at least :)
14:18:52 <sirspazzolot> thanks guys!
14:18:59 <typoclass> thoughtpolice: oh, kudos
14:19:01 <acowley> sirspazzolot: Taking sensor input and controlling motors is very haskelly. http://www.seas.upenn.edu/~acowley/papers/roshask.pdf
14:19:19 <sirspazzolot> (not that I've touched C... but it's more supported ie people can fix my bugs for me kekeke)
14:19:38 <acowley> thoughtpolice: Do any of the ARM dev boards have OpenCL drivers?
14:19:52 <thoughtpolice> acowley: i don't know of any. :( the parallella apparently will however!
14:19:57 <typoclass> sirspazzolot: ok, fair enough :-) but if you want to do yourself a favor, give haskell a try. in my opinion, you'll come out of it a better programmer, no matter what language you end up using
14:19:58 <thoughtpolice> i should get 2 of them in the next few months
14:20:43 <acowley> thoughtpolice: I really want a board that will DMA an input bus from a device to GPU memory and let me OpenCL all over it
14:20:56 <thoughtpolice> they're probably not *quite* powerful enough to do -GHC- development on, but certainly fast enough to write programs on
14:21:03 <sirspazzolot> typoclass: oh I totally want to. I read some stanford paper introduction to the lambda calculus, it sounded fantastically interesting. I'm busy finishing high school and senior project blah blah so I haven't gotten to it, but LYAH has been open in a tab in firefox for a few weeks now
14:21:05 <acowley> thoughtpolice: Are you getting the big parallela?
14:21:24 <sirspazzolot> hoping to get some haskell done while sensors are being shipped from china I guess B)
14:21:27 <thoughtpolice> acowley: i know. :( i really dislike the whole ARM SoC/GPU situation right now. the driver support is just non existant unless you're using Android
14:21:35 <thoughtpolice> acowley: no, just 2 16core boards
14:21:45 <acowley> Yeah the driver situation is insanely broken
14:21:46 <typoclass> sirspazzolot: heh, very good. remember that you can use tryhaskell.org, and you can do "/query lambdabot" and play around
14:21:55 <typoclass> > map pred [0..3]
14:21:57 <lambdabot>   [-1,0,1,2]
14:22:04 <typoclass> sirspazzolot: like this ^^
14:22:06 <thoughtpolice> right now i have a very nice Exynos 5 Dual i just got Ubuntu on, so I can try to get GHC building on it
14:22:09 <thoughtpolice> since it's fairly nice hardware
14:22:26 <thoughtpolice> unfortunately there's no accelerated graphics, so a WM is still fairly unusable performance/memory wise
14:22:33 <thoughtpolice> so i'm just stuck with a VGA framebuffer and tmux.
14:22:37 <thoughtpolice> nothing wrong with that though!
14:23:35 <sirspazzolot> super duper! thanks typoclass. I should get back to work now, kekeke. reports are done generating, time to break some javascript I mean sort some things
14:23:41 <aristid> thoughtpolice: plain X doesn't work? :/
14:24:03 <thoughtpolice> acowley: have you got anything just using OpenGL etc? I hear the Lima driver guys have made some good improvements in the past few months
14:24:07 <typoclass> sirspazzolot: alright then
14:24:21 <thoughtpolice> oh, apparently Limadriver supports the Exynos/Samsung Chromebook
14:24:33 <thoughtpolice> aristid: it does. it's just horribly slow
14:24:51 <thoughtpolice> actually all of the ubuntu desktop works, i even got xmonad working. it's all just insanely slow
14:25:14 <thoughtpolice> also the Chromebook is fairly new in the Linux/ARM SoC world relatively speaking, so some of the other hardware support could be better too
14:25:17 <thoughtpolice> touchpad, sound, etc
14:25:30 <acowley> thoughtpolice: Yeah, I can stick to OpenGL. It's disappointing that the upcoming Raspberry Pi camera board feeds camera data direct to the GPU, but you can only get it on the CPU.
14:25:32 <thoughtpolice> overall just not using a WM saves me annoyances and memory :P
14:25:34 <acowley> afaik
14:26:14 <hpc> acowley: i don't even understand how that's possible
14:26:14 <acowley> Maybe I should start hyping myself up regarding the parallela board.
14:26:22 <typoclass> thoughtpolice: not using a wm? you mean neither using x nor a wm?
14:26:35 <aristid> thoughtpolice: "even xmonad"?
14:26:40 <Ankhers> How is Haskell for concurrency?
14:26:45 <aristid> thoughtpolice: xmonad is much less resource hungry than unity :)
14:26:46 <acowley> hpc: It's due to really awkward fencing in of GPU functionality
14:26:47 <thoughtpolice> typoclass: yeah, i use neither
14:26:52 <typoclass> Ankhers: short answer -- excellent
14:26:54 <acowley> Ankhers: money
14:27:04 <hpc> haskell is money for concurrency?
14:27:07 <typoclass> thoughtpolice: ah :-) i was wondering what you were doing with an x server and no wm ;-)
14:27:20 <thoughtpolice> aristid: yes, it's still pretty slow actually, but i don't think this is really anything's fault in particular
14:27:27 <akegalj> @src Monad ([])
14:27:27 <lambdabot> Source not found. Are you on drugs?
14:27:36 <Ankhers> I've heard in the past that Erlang is the place to go for concurrency, but a coworker today told me that Haskell is actually as good, is that true?
14:27:45 <thoughtpolice> aristid: as much as it is "this is hardware which only very recently runs linux"
14:27:48 <aristid> thoughtpolice: i'm kind of surprised that these samsung socs don't all come with gpus
14:27:51 <geekosaur> @src [] (>>=)
14:27:51 <lambdabot> xs >>= f     = concatMap f xs
14:27:52 <thoughtpolice> so i expect performance issues and whatnot
14:27:52 <hpc> haskell is where you go when you don't need gratuitous amounts of concurrency
14:27:56 * hackagebot language-ecmascript 0.12 - JavaScript analysis tools  http://hackage.haskell.org/package/language-ecmascript-0.12 (AndreyChudnov)
14:27:58 <thoughtpolice> aristid: they do. just no open source driver
14:28:03 <aristid> thoughtpolice: oh :/
14:28:04 <akegalj> geekosaur, tnx
14:28:05 <hpc> https://www.youtube.com/watch?v=1yH_j8-VVLo
14:28:09 <thoughtpolice> the Chromebook actually comes with a very nice Mali GPU
14:28:17 <typoclass> Ankhers: yes it's as good, with the caveat that i don't know erlang very well
14:28:23 <thoughtpolice> there ARE drivers available for ChromeOS. Google licensed samsung for the drivers
14:28:25 <aristid> thoughtpolice: and no functioning binary driver for linux either?
14:28:35 <thoughtpolice> but what that means is the licensing isn't clear, so nobody has taken the time to create a package for the binary blob
14:28:36 <acowley> thoughtpolice: Can the lima drivers accelerate a WM yet?
14:28:52 <thoughtpolice> since it's one of those tricky "we cannot distribute the binary, but we can distribute a shell script that downloads it for you, etc"
14:28:59 <aristid> thoughtpolice: the world of mobile gpus is such a mess
14:29:03 <thoughtpolice> i think it's mostly an issue of effort
14:29:05 <thoughtpolice> aristid: indeed
14:29:15 <typoclass> what is lima anyway?
14:29:27 <thoughtpolice> acowley: haven't tried, the Chromebook/ODROID is the only hardware I have that Lima will support
14:29:32 <aristid> and when i say "mess" i say that with the accent of my icelandic roommate :D
14:29:40 <thoughtpolice> i mostly run my ARM SoCs headless, the chromebook is a bit special because it's an actual laptop
14:29:48 <thoughtpolice> so not really 'headless'
14:29:57 <thoughtpolice> typoclass: it's an open source driver for ARM Mali GPUs
14:30:05 <thoughtpolice> think of it like the nouveau equivalent for ARM systems
14:30:07 <typoclass> thoughtpolice: thanks
14:30:10 <acowley> reverse engineered
14:30:13 <thoughtpolice> because all ARM GPUs are proprietary front to end
14:30:24 <aristid> thoughtpolice: how many of these embedded computers do you have?
14:30:33 <simpson> thoughtpolice: A matter of effort and manpower. There are not many people out there that can write GPU drivers.
14:30:42 <thoughtpolice> enough to make a decent GHC build farm :)
14:30:56 <hpc> tegra is the closest i have seen to any kind of sanity in that space
14:30:58 <thoughtpolice> simpson: i'm not saying there are. i meant "effort to write that shell-script wrapper ubuntu package" :)
14:31:03 <thoughtpolice> i should have been more clear
14:31:05 <simpson> thoughtpolice: Ah, sure.
14:31:11 <hpc> but it won't win on sanity because it is slow
14:31:28 * simpson really would prefer if ARM manufacturers would just release spec sheets
14:31:35 <quchen> No instance for (GHC.Base.Applicative NoIO)   <==  Wat
14:31:39 <thoughtpolice> aristid: lemme see, uh, PandaBoard, ODROID-U2, Chromebook, and 2 RPIs, one I use for the GPIO programming, the other as a small network device at home
14:31:45 <facepalm> Botje: it compiles but when I run the final test scrip it says I have an empty list because I have a bad base case for areSunk
14:31:48 <thoughtpolice> so i've got 3 boards beefy enough for doing GHC dev
14:32:19 <thoughtpolice> my hopes are that i'll be able to distribute linux binaries for GHC 7.8.1, for ARMv7 platforms at least
14:32:36 <typoclass> thoughtpolice: oh wow, that would be cool
14:32:45 <acowley> thoughtpolice: That would be amazing!
14:32:47 <thoughtpolice> (and probably the RPi too, but that just takes so damn long i don't do it much)
14:33:21 <thoughtpolice> i need to take the time to turn my PandaBoard and ODROID into GHC build slaves, too
14:33:25 <facepalm> Botje:  Prelude.foldl1: empty list
14:33:39 <acowley> Compiling some libraries takes a long enough time on an x86 that I'm not really looking forward to building anything heavy on an ARM board.
14:33:59 <acowley> thoughtpolice: I thought the cross compiler future was at hand?
14:34:09 <hpaste> facepalm revised “Functions”: “funcs” at http://hpaste.org/87164
14:34:22 <facepalm> Botje: there is my current code
14:34:26 <aristid> thoughtpolice: rpis don't count :P
14:34:28 <thoughtpolice> acowley: it hopefully is! i'm just more familiar with fixing GHC bugs, as opposed to fixing GHC *build system* bugs, and build system bugs are some of the remaining bits
14:34:30 <cschneid> what is the reader monad good for? I get what it's doing, but don't see the immediate use case for it? Can somebody point me at a "real world" use of it?
14:35:04 <mm_freak> cschneid: a reader monad is just a type like ((->) e)
14:35:09 <mm_freak> so just regular functions
14:35:18 <mm_freak> what is useful in practice is ReaderT
14:35:24 <thoughtpolice> acowley: also, my boxes ARE powerful enough to build GHC in a 'reasonable' amount of time (ODROID can do it in < 1.5hrs for a full rebuild,) so doing some of the development there means i'm less likely to make my life harder
14:35:28 <thoughtpolice> by mixing cross compilation into the mix
14:35:35 <thoughtpolice> (there are still a few dynamic linking bugs etc on ARM)
14:35:48 <monoidal> cschneid: your program has a configuration file, then you can store it in the environment of the reader monad
14:35:55 <Philippa> thoughtpolice: I've sort of given up on my chromebook as a dev platform for now (partly because I just picked up a new x86 machine of a similar size if slightly heavier), mostly for lack of GHCi - but yeah
14:36:03 <acowley> I'm not completely sold on dynamic linking in 7.6 on x86 :/
14:36:11 <acowley> I still run into issues occassionally.
14:36:12 <cschneid> monoidal: interesting. Is there an example out there with that? (at the beginner level)
14:36:20 <mm_freak> cschneid: sometimes a reader monad like ((->) e) can be useful, too, for example when you use applicative style
14:36:34 <mm_freak> > liftA2 (+) sin cos 2
14:36:35 <thoughtpolice> Philippa: yeah, lack of GHCi sucks. since I put ubuntu on my Chromebook, i've been making a big effort to try and actually use it as a dev platform. like i said, so very close to my ideal laptop!
14:36:37 <lambdabot>   0.4931505902785393
14:36:51 <thoughtpolice> on that note, i had a fun process of writing a kernel driver to enable user-space access to the ARM performance monitor unit :P
14:36:59 <mm_freak> that's the reader monad ((->) Double) (slightly simplified type)
14:37:05 <Philippa> *nod*. I have use cases that want x86 more, but the passive cooling's lovely
14:37:19 <typoclass> cschneid: in principle, you could also not use Reader and just pass a number of extra arguments into all your functions that are Reader Something
14:37:25 <Philippa> (so the x86 machine spends an awful lot of time pretending to be multiple analogue synthesisers!)
14:37:29 <acowley> What's the battery life like on the ARM chromebook?
14:37:39 <Philippa> 4-6 hours
14:37:42 <thoughtpolice> acowley: like 6ish hours? seems to hold that in ubuntu as well
14:37:42 <typoclass> cschneid: but suppose it's 20 arguments or something :-)
14:37:44 <thoughtpolice> not just chromeos
14:38:00 <thoughtpolice> i just LOVE the lightweightness, no heat, no sound
14:38:02 <typoclass> Philippa: oh, what x86 chromebookish thing did you get?
14:38:19 <mm_freak> typoclass: Reader doesn't really help there…  you would use a record in either case, because you neither want 20 arguments, nor 20 readers ;)
14:38:22 <acowley> thoughtpolice: Yeah, it sounds very tempting for a travel machine.
14:38:23 <Philippa> typoclass: a cheap 11.6" Acer running a current-gen Core i3
14:38:31 <mm_freak> in fact 20 readers is probably worse than 20 arguments
14:38:33 <Philippa> (and win8, but can't have everything)
14:38:37 <typoclass> Philippa: hm thanks
14:38:38 <acowley> thoughtpolice: Really wish it was 6-8 hours of battery like my MBP
14:38:42 <mm_freak> lift . lift . lift . lift . lift . lift . …
14:38:49 <elliott> is compiling large haskell projects on a chromebook as slow as I'm envisioning in my head?
14:38:54 <thoughtpolice> acowley: agreed, but i think it's a good look at what's to come for ARM laptops
14:38:58 <typoclass> mm_freak: hm yeah ... right. record in both cases
14:39:03 <Philippa> so that's an ultrabook-class CPU, but the fan's still noticeable. But if I'm doing music work I'm wearing cans anyway
14:39:04 <acowley> thoughtpolice: I'm impatient :)
14:39:07 <Philippa> (the battery life sucks, btw)
14:39:16 <Philippa> (3.5 hours, maybe?)
14:39:24 <acowley> thoughtpolice: I can't justify an MBA just for travel, and the iPad isn't so hot for Haskelling.
14:39:35 <monoidal> cschneid: let's suppose you have a text editor and you can configure its settings - word wrap, syntax highlighting etc. in a file; then you can put those settings in a record X and then use Reader X
14:39:52 <acowley> Philippa: And the weight is an issue, too? 2lbs or bust!
14:39:55 <thoughtpolice> honestly i think the biggest diff in x86/ARM in terms of laptops is really just the CPU memory management. ARM's catching up in pure clock speeds, but not in memory units compared to intel
14:40:05 <thoughtpolice> the bus speeds for RAM are still horrifically slow on ARM SoCs, even high end ones
14:40:16 <monoidal> cschneid: some function will read the configuration and pass the X value, the monad will take care of passing the settings down so you don't have to do it explicitly
14:40:30 <mm_freak> cschneid: when you have a computation in ReaderT Config IO, then you can construct larger applications without ever having to pass that Config value around explicitly…  within the computation you can use 'ask' or 'asks' to retrieve the value or part of it
14:40:40 <thoughtpolice> anyway, time to leave the office. all this ARM talk has compelled me to try and fix some more bugs this weekend :)
14:40:58 <cschneid> so ReaderT is something I should be looking at instead of Reader itself. Time to go figure out wtf that is :)
14:41:05 <cschneid> :type ReaderT
14:41:09 <cschneid> err
14:41:12 <cschneid> :info ReaderT
14:41:27 <mm_freak> cschneid: 'Reader e' is just 'ReaderT e Identity'
14:41:38 <mm_freak> ReaderT e m a = e -> m a
14:41:42 <mm_freak> Reader e a = e -> a
14:41:48 <mm_freak> that's the difference
14:41:55 <mm_freak> (because of course Identity a = a)
14:42:03 <monoidal> cschneid: Reader is defined using ReaderT in libraries, but for pedagogy, you can forget about ReaderT for a moment
14:42:06 <cschneid> the T is for transformer right? or am I confused there?
14:42:09 <typoclass> cschneid: they are both variants of the same thing. handwavingly, ReaderT lets you bolt it onto another monad; Reader is used standalone
14:42:12 <monoidal> cschneid: yes
14:42:15 <acowley> You're not confused!
14:42:48 <cschneid> haven't looked into transformers yet, time to go find a tutorial, since I ran out the haskell book I had
14:43:32 <mm_freak> cschneid: transformers are a way to combine monads
14:43:46 <mm_freak> you need both IO and a Config environment?  use ReaderT Config IO
14:43:54 <Philippa> acowley: weight's 100g or so lighter than my previous machine, but that's got about double the battery life
14:44:21 <typoclass> cschneid: i think you can just use it a few times and you've got the hang of it. not sure if a tutorial will be much help
14:44:23 <acowley> Computer hardware offers the cruelest compromises
14:44:23 <Recursive> @unmtl ReaderT Config IO
14:44:24 <lambdabot> Plugin `unmtl' failed with: `ReaderT Config IO' is not applied to enough arguments, giving `/\A. Config -> IO A'
14:44:38 <mm_freak> cschneid: and i didn't simplify much above…  that's really how ReaderT works:  newtype ReaderT e m a = ReaderT (e -> m a)
14:44:52 <cschneid> typoclass: yeah, "tutorial" == "a bit of code and explanation." in my head at this point.
14:45:01 <mm_freak> you could probably implement it yourself
14:45:03 <mm_freak> and doing that actually helps =)
14:45:04 <cschneid> anyway, I'll play with it later
14:45:14 <Philippa> yeah. Like the previous machine's current tendency to do a good impression of a dying wasp! Still, I'll be... interested when the first Core chips meant for passively-cooled systems finally happen
14:45:31 <typoclass> cschneid: ah right :-) now that is very sensible. i don't know of any, unfortunately
14:45:41 <Philippa> (the dying wasp thing is why I've replaced it)
14:46:08 <cschneid> typoclass: I'm finding accessible examples hard to come by. Most "real" apps end up relying on a large number of semi-advanced techniques, which makes it hard to isolate the one I want to know
14:46:44 <typoclass> cschneid: true! i was quite bamboozled the first times i tried to make sense of any part of xmonad
14:46:58 <cschneid> hah, I read some of it. And uhh... looking for something else now :)
14:47:11 <cschneid> I should start a blog talking about what I find as I learn.
14:47:17 <cschneid> if something doesn't exist, make it myself.
14:47:58 <mm_freak> cschneid: are you ignoring me?
14:48:09 <mm_freak> because if you are i can save the time to write all this
14:48:31 <cschneid> mm_freak: not intentionally, also doing day-job.  And this is more generic finding my way forward questions than ReaderT in particular :)
14:49:02 <Ankhers> Does anyone know the name of the Haskell -> JS compiler off the top of their head?
14:49:04 <mm_freak> alright
14:49:12 <mm_freak> Ankhers: there are a number of them
14:49:15 <typoclass> Ankhers: fey or fay or something. also, ghcjs
14:49:20 <mm_freak> haste, GHCJS, fay (subset of haskell)
14:49:39 <monoidal> uhc had js compilation if my memory serves well
14:49:50 <mm_freak> yeah, UHC does that too
14:50:06 <mm_freak> Ankhers: http://www.haskell.org/haskellwiki/The_JavaScript_Problem
14:50:08 <Ankhers> mm_freak, typoclass: I was looking for ghcjs, thanks.
14:50:09 <cschneid> mm_freak: it's rough as I think I grok most of the core haskell stuff that's covered in the intro books, and now it's expanding into the next layer up which lets real applications get built. Transformers for instance, also other things I'm unaware of so far.
14:50:30 <merijn_> cschneid: Like lens! :p
14:50:52 <Recursive> @google uhc
14:50:54 <lambdabot> http://www.uhc.com/
14:50:54 <mm_freak> cschneid: i did actually give you advice how to approach learning these things in haskell
14:50:54 <lambdabot> Title: Health Insurance plans for employers, individual, family, medicare and dental |  ...
14:51:10 <mm_freak> cschneid: one that that helps most people is to implement stuff themselves
14:51:12 <merijn_> @google utrecht haskell compiler
14:51:14 <lambdabot> http://www.cs.uu.nl/wiki/UHC
14:51:15 <lambdabot> Title: WebHome < UHC < TWiki
14:51:20 <edwardk> @google utrecht haskell compiler
14:51:20 <merijn_> There you go
14:51:23 <lambdabot> http://www.cs.uu.nl/wiki/UHC
14:51:23 <lambdabot> Title: WebHome < UHC < TWiki
14:51:33 <cschneid> mm_freak: "implement it yourself"? The problem is I can only implement if I know it exists, and what it's supposed to do.
14:51:41 <cschneid> you're right that's useful for learning though.
14:51:59 <mm_freak> cschneid: you know that ReaderT exists and its purpose becomes pretty clear while implementing it =)
14:52:40 <monoidal> cschneid: If you look at types of return and >>= for reader monad, there's only one implementation (except those which create infinite loops or throw exceptions)
14:53:28 <monoidal> cschneid: for example, can you give functions of type a -> a and a -> b -> a? in both cases there's only sensible answer
14:53:35 <monoidal> *only one sensible answer
14:54:24 <Recursive> @djinn a -> a
14:54:25 <lambdabot> f a = a
14:54:32 <monoidal> hey! don't spoil!
14:54:47 <cschneid> sorry, distracted by real work today too. I'll come back to this
14:54:56 <Recursive> @djinn a -> b -> a
14:54:57 <lambdabot> f a _ = a
14:55:05 <dmwit> ?djinn (m a -> (a -> m b) -> m b) -> (r -> m a) -> (a -> r -> m b) -> (r -> m b)
14:55:05 <lambdabot> f a b c d = a (b d) (\ e -> c e d)
14:55:16 <dmwit> ?src (>>=) ReaderT
14:55:16 <lambdabot> Source not found. You speak an infinite deal of nothing
14:55:24 <dmwit> ?src ReaderT (>>=)
14:55:25 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:55:27 <dmwit> ah well
14:55:42 <elliott> could replace @src with a command that just says "not found" for any query
14:56:10 <cschneid> monad transformers look like a good next step to dig into, after understanding most of the "standard" monads and generally what's covered in LYAH and RWH?
14:56:22 <monoidal> (personally I don't find lambdabot's insults funny and I think they're against atmosphere of the channel)
14:56:39 <mm_freak> cschneid: did you learn applicative functors already?
14:56:59 <cschneid> applicative, yes, but probably haven't internalized it well enough yet
14:57:01 <monoidal> cschneid: yes, they're a good next step (you can do applicatives too)
14:57:28 <ramses_> cschneid: applicatives are covered both in lyah and rwh and transformers are in rwh
14:57:30 <mm_freak> i think that applicative functors are more important than monad transformers
14:57:46 <cschneid> ramses_: ahh, cool, I'll check out RWH, I've been in LYAH so far.
14:57:47 <typoclass> monoidal: i've thought the same some minutes ago. the "2001" quote is decent, but they really could be more towards the funny end of the scale
14:58:00 <ramses_> applicatives are great! :)
14:58:03 <parcs> i love monad transformers
14:58:26 <monoidal> also the insults could at least be haskell-related
14:58:26 <mm_freak> i hate monad transformers =)
14:58:50 <dmwit> I conclude that ?djinn got it right, after staring at the source for a while.
14:59:29 <monoidal> typoclass: do you know if there were there attempts to change it?
14:59:43 <typoclass> monoidal: no clue
15:01:22 <mm_freak> @djinn (Monad m) => a -> m a
15:01:23 <lambdabot> f = return
15:01:32 <elliott> @djinn (Monad m) => x -> m x
15:01:33 <lambdabot> -- f cannot be realized.
15:01:39 <mm_freak> lol
15:02:02 <mm_freak> @djinn (Monad m) => (e -> m a) -> (a -> e -> m b) -> e -> m b
15:02:02 <lambdabot> f a b c = a c >>= (\ d -> b d c)
15:02:14 <mm_freak> impressive
15:02:26 <mm_freak> i didn't know it knew about Monad
15:03:38 <tgeeky> it tells you what it knows about
15:03:44 <elliott> it only sort of does
15:03:55 <mm_freak> @djinn (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
15:03:57 <lambdabot> Error: Class not found: Applicative
15:04:00 <tgeeky> @djinn-names
15:04:00 <lambdabot> Either Left Right Maybe Nothing Just Bool False True Void Not Void Monad Eq Bool
15:04:08 <mm_freak> i see
15:04:22 <mm_freak> @djinn (Monad m) => String -> m a
15:04:22 <lambdabot> Error: Undefined type String
15:04:26 * tgeeky loves using djinn, pl, and unpl
15:04:37 * mm_freak prefers doing pl manually
15:04:40 <monoidal> typoclass: http://hackage.haskell.org/packages/archive/lambdabot-utils/4.2.2/doc/html/src/Lambdabot-Util.html#insult
15:04:41 <cmccann> tgeeky: pf, as if unpl is useful for anything
15:04:47 <monoidal> typoclass: here are the insults
15:05:27 <monoidal> perhaps I should message the maintainer
15:05:42 <monoidal> (or ask on cafe? i hope changing the messages is not that controversial.)
15:06:31 <Recursive> The most frequently used plugin should be @ty :)
15:06:37 <cmccann> is "maintain" really something that is ever done to lambdabot?
15:06:58 <tgeeky> cmccann: yes. It knows about edwardk's new stuff, which someone made happen :)
15:06:59 <typoclass> monoidal: i can come up with some less insulting stuff if you want. not right now, but give me a few hours
15:07:14 <monoidal> typoclass: ok.
15:07:27 * cmccann likes lambdabot's insults :[
15:07:27 <monoidal> typoclass: I'm going to sleep soon anyway.
15:07:30 <edwardk> Cale mostly
15:07:49 <Recursive> @ty (***)
15:07:52 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
15:07:53 <typoclass> monoidal: sure. we'll get this done in the next few days
15:08:00 <nade> Hey, I'm having some trouble with the Parsec library. I'm fairly new to haskell, so please throughly tear my code apart. :). I'm trying to write a program that will parse algebraic chess notation, and I'm stuck on a detail. Here is the code: http://hpaste.org/87181
15:08:03 <maxorator> how to "convert" a float to int? I want to take an int to power 1.2 and have the result as int too
15:08:27 <monoidal> maxorator: floor?
15:08:32 <sproingie> do it all as a float then floor it
15:08:37 <cmccann> oe round, truncate, ceiling...
15:08:41 <cmccann> s/oe/or
15:08:50 <cmccann> you have to pick how you want to "convert" it
15:08:58 <cmccann> since there's obviously no general-purpose conversion :P
15:09:16 <thoughtpolice> heh, the quotes being stolen from OpenBSD makes a lot of sense now, actually
15:09:40 <thoughtpolice> dons was a very heavy OpenBSD user for many, many years, and also (surprise!) wrote the original versions of lambdabot.
15:10:01 <Recursive> !quote dons
15:10:06 <Recursive> @quote dons
15:10:07 <lambdabot> dons says: "and haskell is not a lisp. correct?"
15:10:19 <cmccann> @quote lambdabot
15:10:20 <lambdabot> lambdabot says: I go and I come, counter your kidneys, and I retain myself
15:10:27 <cmccann> what
15:10:37 <thoughtpolice> *blink*
15:10:50 <Recursive> thoughtpolice: who is dons ?
15:11:02 <mm_freak> cmccann: people tend to overuse PF style from time to time, in which case you really need to get rid of it to understand the code
15:11:03 <tgeeky> Recursive: don stewart, a influential haskeller
15:11:06 <maxorator> monoidal, thanks, tried that before but I messed up something else so I didn't notice it fixed my actual problem
15:11:10 <mm_freak> so @unpl isn't necessarily useless =)
15:11:19 <Recursive> tgeeky: thx
15:12:28 <thoughtpolice> Recursive: Don Stewart. he's not around a lot publicly anymore, but he's been very heavily involved and influential in the community for nearly a decade at this point
15:12:31 <thoughtpolice> if not longer
15:12:36 <Recursive> In my ERC, erc-pals '("Hindley" "rhickey" "don stewart")
15:12:57 <monoidal> I remember times when dons was ~90% of /r/haskell's new content
15:13:14 <thoughtpolice> well, he's still on SO a lot i think. i guess it's more accurate to say he doesn't write lots of Haskell publicly anymore, or spend lots of time on IRC, the mailing lists, etc
15:13:30 <thoughtpolice> monoidal: dons was practically 90% of all haskell news everywhere, tbh :)
15:13:39 <cmccann> yeah dons used to be kinda omnipresent
15:13:53 <elliott> dons is like bourbaki
15:13:59 <elliott> not a single person, don't be naive.
15:14:21 <Recursive> dons is its IRC id ?
15:14:23 <thoughtpolice> who are the Simons, then?
15:14:45 <thoughtpolice> Recursive: yes
15:14:45 <Recursive> Hindley is one of the people responsible for Haskell's type system
15:14:47 <elliott> thoughtpolice: twins.
15:14:51 <blackdog> elliott: i shared a cubicle with him, if he's multiple people he's very quiet about it :)
15:14:58 <elliott> simon is actually the last name.
15:15:06 <thoughtpolice> elliott: i find all of this plausible.
15:15:21 <cmccann> also, elliott is obviously conal.
15:15:24 <typoclass> blackdog: with who?
15:15:45 <Facepalm> Botje: could you tell me what could be wrong with my base case for areSunk? http://hpaste.org/87182 my test script is giving me foldl1 empty error
15:16:09 <hpc> thoughtpolice: "simon says" is how children re-enact the invention of math
15:16:11 <hpc> true story
15:16:26 <blackdog> typoclass: dons
15:16:35 <Botje> @src and
15:16:36 <lambdabot> and   =  foldr (&&) True
15:16:39 <typoclass> blackdog: oh i see :-) i thought "bourbaki"
15:16:49 <monoidal> Facepalm: in your code foldl1 gets an empty list
15:16:49 <Botje> Facepalm: that can only happen if you're using the commented-out foldl1 version.
15:16:50 <thoughtpolice> hpc: lol
15:16:52 <benzrf> hello again!
15:17:17 <benzrf> how can I delete a single element from a list?a
15:17:25 <Botje> benzrf: with the delete function :]
15:17:30 * benzrf headdesks
15:17:44 <benzrf> is there usually a better way to do x without using delete, or is it a valid, used function?
15:17:48 <hpc> benzrf: as common in haskell, simple questions are answered with even simpler questions
15:17:51 <hpc> benzrf: which element?
15:18:04 <benzrf> an arbitrary one at a given index
15:18:14 <hpc> @hoogle [a] -> Int -> [a]
15:18:15 <lambdabot> Prelude drop :: Int -> [a] -> [a]
15:18:15 <lambdabot> Data.List drop :: Int -> [a] -> [a]
15:18:15 <lambdabot> Prelude take :: Int -> [a] -> [a]
15:18:24 <hpc> some combination of drop and take
15:18:27 <benzrf> :C
15:18:43 <benzrf> is there a reverse take
15:18:47 <benzrf> @hoogle rtake
15:18:49 <lambdabot> No results found
15:18:54 <hpc> benzrf: yes; drop
15:19:00 <benzrf> no, like from the other end
15:19:01 <hpc> > drop 5 [1..10]
15:19:03 <monoidal> take (n-1) x ++ drop n x or something like that
15:19:04 <lambdabot>   [6,7,8,9,10]
15:19:07 <hpc> > take 5 [1..10]
15:19:09 <lambdabot>   [1,2,3,4,5]
15:19:14 <geekosaur> if you mean take from the other end, think about what you're asking for and what lists are
15:19:15 <benzrf> oh wait
15:19:16 <benzrf> right
15:19:19 <benzrf> durp
15:19:24 <benzrf> ok, thanks C:
15:19:39 <hpc> benzrf: as is also common in haskell, the correct answer to your question is that you should do something completely unrelated to the question
15:19:40 <Facepalm> Botje: I'm using what I have there not commented out one. But is supposed to be similar to isSunk with empty list base case because it should return empty in some cases
15:19:48 <hpc> benzrf: why do you need to cut elements out of a list?
15:20:02 <benzrf> > let theList = [1, 2, 3, 4, 5] in drop 3 theList ++ take 2 theList
15:20:05 <lambdabot>   [4,5,1,2]
15:20:08 <benzrf> hrm
15:20:11 <benzrf> oops
15:20:19 <benzrf> > let theList = [1, 2, 3, 4, 5] in take 2 theList ++ drop 3 theList
15:20:21 <lambdabot>   [1,2,4,5]
15:20:22 <benzrf> goody
15:20:33 <monoidal> (benzrf: btw you can just write [1..5])
15:20:43 <benzrf> hpc: I'm rewriting a simple script to help sort a bookshelf in haskell for practice
15:21:08 <Botje> Facepalm: I don't see how you can get a foldl1 error then.
15:21:14 <benzrf> I have a list of authors that corresponds to the shelf. it sorts it, then gives you a series of instructions like:
15:21:24 <benzrf> 'take the book at location 5 by foobar and put it in front
15:21:32 <benzrf> take the book at location 23 by phooey and put it in front
15:21:48 <benzrf> so I need to pop the one that was moved so that the future indices are correct
15:21:58 <benzrf> I assume there's a better way to do it when using immutable lists
15:22:02 <benzrf> but I can't think of anything
15:22:20 <hpc> you want to sort a list of books?
15:22:23 <hpc> :t sortBy
15:22:25 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
15:22:45 <Facepalm> Botje: if you look at bottom I have the tester code below it and crashes around line 143
15:22:48 <benzrf> no, the thing is
15:23:03 <benzrf> after sorting them, I generate a list of instructions for the human to follow
15:23:12 <benzrf> take the book at location 23 by phooey and put it in front
15:23:15 <benzrf> 'take the book at location 5 by foobar and put it in front
15:23:19 <typoclass> > let (l,x:r) = splitAt 3 [1..7] in x : l ++ r -- benzrf, here is another possibility
15:23:21 <lambdabot>   [4,1,2,3,5,6,7]
15:23:24 <benzrf> thanks
15:24:14 <monoidal> good night
15:24:19 <_just> Facepalm: pasted code compiles and runs here
15:24:52 <Botje> Facepalm: the code -as written there- cannot throw an error related to foldl1.
15:25:50 <Facepalm> Ill check it again when I get home when I can run it again
15:26:03 <Facepalm> I'm currently on my tablet lol
15:26:18 <nade> Can anyone offer some help with Parsec? I realize my last request may have been too broad, here is a more simplified case: http://hpaste.org/87184
15:26:52 <acowley> Having to build twice using -osuf is super lame :(
15:29:17 <Clint> nade: what's your question?
15:30:21 <tgeeky> acowley: hm. when we "cabal install" a package, what we really ought to mean is: build/install quickly for me now, but queue up the variants (docs, profiling, thisflag, thatflag) for later
15:30:57 <kmels__> hello, is there a way I can tell GHC that the `a` in check is the same as the `a` in checkExpected? http://hpaste.org/87185
15:31:01 <acowley> tgeeky: I run into the most trouble when wanting one-off executables built outside of cabal
15:31:25 <luite> kmels__: yeah add forall a. to checkExpected
15:31:34 <luite> kmels__: and enable ScopedTypeVariables
15:31:45 <acowley> I suppose I should use cabal when profiling test programs, too
15:32:39 <nade> clint: Er, well I'm having trouble parsing a data format. Specifically, I'm looking for a good way to "lookAhead" with parsec. I am parsing Algebraic Chess Notation and there are cases where Nf4 becomes Nef4 to disambiguate between two possible pieces. In my case I want want to match [piecename],[file | rank],cell. But in doing so I have to make sure that I'm not treating the file of the cell as the disambiguation, thus the need to lookAhead
15:32:50 <tgeeky> acowley: and as soon as you can do that, you can just use the same harness to executable-build
15:33:07 <tgeeky> I don't know what you mean by outside of cabal, though.
15:33:18 <acowley> tgeeky: I just mean manually invoking ghc (or a Makefile)
15:33:23 <kmels__> luite: magnificent, thanks
15:33:55 <c_wraith> nade: do you know about the try combinator in parsec? It sounds likely to be what you need
15:33:55 <nade> clint: I'm sorry if that wasn't clear enough...
15:34:31 <nade> c_wraith: Well I'm using it in my paste, but I'm not sure I'm using it to the right affect.
15:36:05 <c_wraith> nade: well, char '\00' certainly doesn't match nothing. It matches a NUL byte (ascii value 0)
15:36:27 <c_wraith> nade: a parser action with no matching would be "return ()"
15:37:21 <nade> c_wraith: Yeah, I'm sure that is a bad way to reach the desired effect, but in the context it seems to be doing what I want.
15:37:46 <nade> oh
15:38:13 <nade> well I could remove that and replace it with a simple try i think, but that still wouldn't fix the parser
15:38:34 <c_wraith> nade: possibly not. That just struck me as something that would prevent that case from ever match on normal text input
15:38:46 <Recursive> Can you guys use #freebsd and #openbsd now ?
15:39:16 <typoclass> Recursive: how do you mean?
15:39:35 <Recursive> typoclass: i canot use them now
15:40:15 <Recursive> canot /join #freebsd, can /join #openbsd but cannot send message
15:40:26 <Rotaerk> I've found myself starting to have "execState $ do" in some of my code, when it seems easier to express in that form... is that normal?
15:40:31 <shachaf> Recursive: This isn't really the channel for that. Try asking in #freenode.
15:40:41 <hpc> Recursive: can join #netbsd but your drivers won't render the chat window?
15:40:41 <Recursive> ok
15:40:47 <nade> c_wraith: yeah I replaced it with (anychar >>= (\_ -> return $ Just NoHint))
15:41:15 <typoclass> Recursive: i can join both. haven't tried talking. it might be a problem with your registration with nickserv
15:42:13 <Recursive> typoclass: but #haskell, #netbsd works using same registration
15:42:44 <typoclass> Recursive: i don't know. you should ask in #freenode or another appropriate channel
15:42:59 <c_wraith> nade: is using lookahead a requirement? I'd really try doing it differently, if it's not
15:43:24 <Recursive> typoclass: ok
15:44:51 <nade> c_wraith: nope not at all... How else would you accomplish it. All that is important is that I can tell whether a character is a "file" of a square (eg e3) or if a character is meant to disambiguate a movement (eg Nef4)
15:46:40 <c_wraith> nade: I'd parse parse the first character, then use try to try parsing the remainder as the longer version, or the shorter version if the longer one failed
15:48:02 <nade> c_wraith: sorry, I'm not sure I understand. So in the case of Nef4 you would parse "N", and then ef4?
15:50:12 <Clint> nade: he's saying that once you deal with the N, you have 3 valid possibilities that you could try in turn
15:50:29 <c_wraith> nade: ok, a couple things going on..  Parsing the N first was just an optimization so that retrying would be a little faster.
15:50:30 <dp_> hello
15:50:58 <c_wraith> But the basic idea is try parsing the longest option, and if it fails, retry a shorter option
15:51:02 <dp_> anyone know what  Couldn't match expected type `[Bool]' with actual type `Bool' means?
15:51:23 <geekosaur> it wants a list, you didn't give it one
15:51:32 <shachaf> It means that the compile couldn't match the type it expected ([Bool]) with the actual type (Bool).
15:51:43 <shachaf> r
15:51:46 <dp_> a list of bools?
15:51:50 <geekosaur> yes
15:51:58 <shachaf> [Bool] is a list of Bools, yes.
15:52:20 <cmccann> that backcompat -cafe thread becomes increasingly silly.
15:52:27 <nade> c_wraith: yeah thats what I thought I was doing. It was my understanding that without using lookahead or try then what I wan to be parsed next ( the ef4) will have been "consumed"
15:52:30 <dp_> this should return just a bool -isSunk Ship {shipCells = cells} = (map(\Cell {cellAddress = a, bool = boo} -> if boo == False then False else True) cells)
15:52:34 <dp_> right?
15:52:50 <c_wraith> nade: no, "try" prevents the input it was looking for from being consumed if it didn't match
15:53:13 <c_wraith> nade: that's why I said "try" was probably what you were looking for at the very start
15:53:25 <geekosaur> dp_, no, because you're using it inside map
15:53:39 <dp_> map automatically returns a list?
15:53:44 <elliott> cmccann: cafe threads should have a predefined length and everyone has to stop replying when it reaches it.
15:53:47 <c_wraith> look at the type of map
15:53:49 <geekosaur> :t map
15:53:51 <lambdabot> (a -> b) -> [a] -> [b]
15:54:08 <dp_> is there a way around that using fold?
15:54:10 <cmccann> elliott: oh really
15:54:16 <cmccann> what length, though
15:54:21 <shachaf> "if boo == False then False else True" is an exciting new way of saying "boo"
15:54:26 <nade> c_wraith: er, am I not using try correctly in my code? I thought I was doing what you're suggesting.... : /
15:54:35 <geekosaur> possibly. what do you expect to have happen?
15:54:51 <elliott> cmccann: uh one second, I need to figure out how to make my reply a burn.
15:54:53 <dp_> I want to parse a list and if I found a false value then just return false, otherwise true
15:54:55 <hpc> shachaf: but it evalutes boo before returning true or false!
15:54:56 <hpc> ;)
15:55:14 <c_wraith> nade: forget lookahead.  Forget crazy logic.  Just use try, as simply as you can.
15:55:27 <dp_> boo already has a value, I just need to determine what it is.
15:55:34 <cmccann> elliott: too late, this conversation hit its predefined length.
15:55:36 <acowley> elliott: You're a predefined length?
15:55:41 <elliott> acowley: good one, good one.
15:55:56 <c_wraith> nade: don't try to figure out what you're parsing *before* you parse it. Just try to parse it, and if it fails, try something else
15:56:16 <acowley> I'm glad so many people refrained from chiming in on that thread. It could have been worse.
15:56:17 <nade> c_wraith: okay, I'll give that a shot
15:56:34 <amiller> ah man i just did the weirdest thing in haskell
15:56:39 <amiller> type level arithmetic for representing circuits
15:56:42 <geekosaur> dp_, if it has a value, it has a value. how is it you need to check and return the same value?
15:56:47 <amiller> like encoding stlc as boolean circuits
15:56:57 <geekosaur> dp_, also, you're actually missing only one thing in that
15:57:01 <amiller> the main idea is to annotate each type with the number of bits in its representation
15:57:12 <amiller> and in particular to have functional types represented as the exponential number of bits needed
15:57:18 <dp_> because it is a list of values, and if they are all true then I need to do something else, but if I find a false then I can just exit and return false
15:57:21 <nade> c_wraith: oh wait, there is another detail that may influence your thinking on the matter. The way I
15:57:33 <nade> 've been doing it is that
15:57:38 <dp_> what one thing?
15:58:06 <geekosaur> dp_, you don't seem to be thinking. I would suggest you go look over Data.List and you will find what you actually want
15:58:30 <geekosaur> I was wrong about it because you aren't actually doing anything with the map
15:58:38 <geekosaur> so lose the map and find the correct thing in Data.List
15:58:49 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/Data-List.html
15:59:36 <dp_> well I think fold would work but I'm not sure what I would accum
15:59:58 <nade> c_wraith: there are 2 actions. There is a Move which is (Nf4, Nef4), and there is capture ( Nxf4, Nexf4). so elsewher I have a parser that looks like [piece],cell (piece being the code I pasted) for move, and [piece],x,cell for capture
16:00:03 <dp_> going through the list isn't the problem, it's returning a value that isn't in a list. that's what I can't figure out.
16:01:02 <geekosaur> let me rephrase
16:01:02 <geekosaur> there is a function in Data.List that does exactly what you want. find it.
16:01:04 <geekosaur> unless you're supposed to be reinventing it, in which case map is not the answer
16:01:37 <c_wraith> nade: That really doesn't change anything. Just adds one more case.
16:01:42 <dp_> ok thanks. is it fold?
16:01:58 <geekosaur> the function I am talking about *uses* fold
16:02:55 <dp_> any?
16:03:03 <geekosaur> almost...
16:03:22 <c_wraith> I can guess, just based on geekosaur's hints! >_>
16:03:25 <Heffalump> lol
16:03:32 <dp_> so all?
16:03:44 <_just> oO
16:04:01 <geekosaur> now think about what you pass to it to make it do the right thing
16:04:03 <tgeeky> @src all
16:04:03 <lambdabot> all p =  and . map p
16:04:19 <geekosaur> or, there is that which is even more direct
16:04:25 <geekosaur> if you think abiut it
16:04:46 <geekosaur> in fact, if you grabbed onto any/all you missed something even more directly what you want
16:04:49 <geekosaur> so go back and look again
16:04:57 <dp_> ok
16:05:19 <geekosaur> it is in the same section
16:05:26 <acowley> I feel like I force edwardk into this same conversation with lens every other day.
16:06:02 <edwardk> ?
16:06:22 <dp_> and?
16:06:29 <dp_> foldl?
16:06:39 <edwardk> :t all
16:06:41 <geekosaur> finally :)
16:06:41 <lambdabot> (a -> Bool) -> [a] -> Bool
16:07:12 <dp_> ah so foldl?
16:07:18 <geekosaur> what?
16:07:19 <dp_> so I accum bool values?
16:07:22 <geekosaur> oy
16:07:32 <geekosaur> you jumped right over it AFTER BEING TOLD and went back to the folkds
16:07:51 <dp_> sorry, i said and? and foldl? and you answered after foldl, so i thought that
16:07:52 <geekosaur> ok, you desperately want fold, so let's reinvent the function you already found and apparently discarded
16:08:00 <dp_> lamdadot confused me a bit, sorry
16:08:10 <dp_> so we want to apply and to our entire list
16:09:38 <dp_> so I want to and my [bool]?
16:10:47 <haskell_pro> hello
16:10:49 <geekosaur> yes
16:11:01 <dp_> it seems to have compiled!
16:11:06 <haskell_pro> hello dp
16:11:09 <haskell_pro> how are you
16:11:17 <dp_> thanks very much for the help!!!
16:13:08 <facepalm> Botje: this is the error I get tester.hs: Prelude.foldl1: empty list
16:13:59 <acowley> Man, profiling is awesome. Took days to get this program working, then 10 minutes to make it 5x faster.
16:16:08 <lavorno> acowley: and as per peter principle, there is at least one in your users list that will make it 5x slower with some weird stuff
16:16:10 <cmccann> acowley: you know, industry best practice is to make it faster first, then spend 10 years making it mostly work.
16:17:18 <lavorno> cmcanncmccann: if it works for 10 years - already a record..
16:17:23 <acowley> cmccann: My next step is an OSGI retrofit
16:17:39 <cmccann> lavorno: no no, after 10 years of effort it STARTS working. hopefully.
16:17:46 <lavorno> :)
16:17:58 <cmccann> this is the software development industry we're talking about after all.
16:18:04 <lavorno> acowley: if you are usiing osgi - cmccann's premonition may come true..
16:18:55 <jagaj> I'm fairly new to both haskell and vim, could someone talk me through a reasonable workflow?
16:18:57 <cmccann> acowley: just be warned, if you leave your code to bitrot then in three years you might need to spend 20min to fix all the compatibility issues.
16:19:03 <cmccann> a dire fate, to be sure.
16:19:32 <acowley> This was actually a good test. I wrote this code and tested it with a 30k triangle mesh and it was okay. Then I gave it a 2M triangle mesh and my computer burst into confetti. Now it does the 2M triangle test in 13s.
16:19:46 <cmccann> yay, confetti!
16:19:48 <parcs> > (60 + 14) / (60 + 57)
16:19:51 <lambdabot>   0.6324786324786325
16:19:52 <acowley> cmccann: Imports need changing. You can't explain that.
16:20:21 <lavorno> acowley: that's great. what r u doing with osgi? i used to be a fan of it - but i eventually gave up
16:20:24 <tgeeky> that's funny. I writing a program to burst my computer into confetti, but all I get are fancy triangular meshes.
16:20:32 <acowley> lavorno: Sorry, that was a joke.
16:20:38 <lavorno> :)
16:20:43 <acowley> tgeeky: We need to pair program some time
16:21:01 <cmccann> then you'll both get fancy triangular confetti.
16:21:08 <acowley> dammit!
16:21:17 <lavorno> acowley: on haskell you can expect anything - even triangular confetti
16:21:38 <tgeeky> You don't want me. I have had a 0.00000% bursting into confetti rate. I'm a failure! </zoidberg>
16:21:44 <cmccann> acowley: what are you doing with all those triangles anyway
16:22:42 <acowley> cmccann: I put together some nifty new OpenGL code, and in the process of writing a tutorial decided I should include some fancy model rendering.
16:22:54 <cmccann> ooh.
16:23:03 * cmccann has been trying to figure out all this opengl stuff lately.
16:23:16 <acowley> cmccann: I really like what I've done with leveraging vinyl records to drive a lot of OpenGL bindings from types.
16:23:25 <acowley> cmccann: But then I didn't want to just draw a cube
16:23:50 <cmccann> cubes are like retro and stuff, though.
16:23:58 <lavorno> art deco
16:24:12 <cmccann> I've been trying to make sense of doing stuff with shaders
16:24:44 <elliott> acowley: ok come on, I realise it's a pun, but you can't go around calling them "vinyl records".
16:24:47 <acowley> cmccann: I highly recommend my code! It's cleaner than using raw OpenGL, but it's still close enough to OpenGL that all that resources on the web should still be useful!
16:24:52 <elliott> it took me about thirty seconds to figure out what you were on about.
16:25:06 <lavorno> cmccann: try this http://www.amazon.com/OpenGL-Shading-Language-Randi-Rost/dp/0321637631
16:25:15 <acowley> elliott: Blame Jon
16:25:31 <acowley> elliott: All I did was some optimization and storable instances for them
16:25:46 <acowley> so I can push vectors of vinyl records into OpenGL
16:26:06 <acowley> and now I can bind shader attributes and such most automatically
16:26:29 <cmccann> acowley: is your code on hackage and/or github?
16:27:12 <acowley> cmccann: The vinyl stuff isn't on github yet. I wanted to make sure it worked by writing this stupid tutorial before making it public :/
16:27:38 <acowley> Then I was like, "It's got to have a sports car! Made of … like… a billion polygons!"
16:28:37 <cmccann> I have no idea what vinyl is about anyway. other than records, and being a pun, which I approve of.
16:29:23 <acowley> cmccann: Not sure why you'd need anything more.
16:29:56 <cmccann> you make a forceful argument.
16:29:59 <cmccann> hm.
16:30:38 <acowley> cmccann: I'm sorry I don't have code up yet. I'll try to get it out as soon as I can. If the fancy model stuff isn't done I'll go the art deco route and just draw a stupid cube :(
16:31:23 <cmccann> no worries. I think I have the basic idea of this newfangled opengl figured out at this point.
16:32:04 <cmccann> it's been a couple weeks since I last discovered a brand new way to render a blank screen I think.
16:35:15 <acowley> cmccann: https://twitter.com/a_cowley/status/235179944441942016
16:35:48 <cmccann> ahahahaha yes
16:36:49 <typoclass> acowley: great, i looked at it and thought "hm lens is involved with opengl now? ekmett sure covers a lot of ground"
16:37:23 <edwardk> typoclass: we looked at opengl lenses/statevar stuff, it just didn't work very well
16:37:24 <acowley> The Khronos group is thinking about taking lens as a dependency on the OpenGL spec.
16:37:50 <edwardk> xplat has a proposal for something like a monadic approach that could be made to work with them though
16:37:52 <typoclass> edwardk: have you tried taking off the lens cap?
16:37:58 <cmccann> I wrote some super-simple lenses for types from the opengl bindings
16:38:04 <cmccann> that's about it
16:38:05 * hackagebot hyakko 0.5.2 - Literate-style Documentation Generator  http://hackage.haskell.org/package/hyakko-0.5.2 (JeremyHull)
16:38:10 <facepalm> I have my Haskell program finished but still have some bugs causing errors. would anyone be able to help me to get those worked out please?
16:38:17 <acowley> OpenGL tends to resist abstraction. I think the best you can do is package up useful units of functionality.
16:38:52 <edwardk> acowley: after the opengl 3 debacle i don't think i'll ever trust the khronos group ever again
16:39:08 <simpson> "Open"GL
16:39:33 <lispy> edwardk: what debacle?
16:40:23 <_just> facepalm: paste your code and the exact error message
16:41:14 <cmccann> edwardk: fortunately, my video card is so old it doesn't support OpenGL 3.0 anyway!
16:41:42 <hpaste> facepalm pasted “Haskell function” at http://hpaste.org/87192
16:41:47 <edwardk> lispy: just the "hey we're going to release a nice consistent mutlithreaded api based on sane immutable objects" thing which was not so promptly followed 6 months after their target deadline with a very quiet "Oh wait, that didn't go over very well with the CAD crowd, sorry, you get nothing"
16:41:49 <acowley> You need to do at least 3. For VAOs if nothing else.
16:42:11 <hpaste> facepalm pasted “tester” at http://hpaste.org/87193
16:42:15 <acowley> gotta run
16:42:24 <lispy> edwardk: ah
16:42:27 <xplat> actually i have two proposals with working code and one without, but only one that is taken at all seriously as of yet :)
16:42:37 <facepalm> _just: the second link is the test script for the entire program
16:42:48 <_just> facepalm: what is the error?
16:42:57 <lispy> edwardk: I'm not sure I would know what to do with a threadsafe opengl api :)
16:43:06 <edwardk> lispy: the fact that they went _completely_ silent for 6 months really caused them to lose all credibility with me and a lot of people in the industry on the library consumer side
16:43:13 <cmccann> lispy: render blank screens?
16:43:14 <facepalm> I have it in the first hpaste
16:43:29 <simpson> edwardk: Annoyingly, there aren't any useful competitors in the Linux space.
16:43:42 <facepalm> _just: tester.hs: Prelude.foldl1: empty list
16:43:43 <simpson> edwardk: And there aren't many non-Khronos APIs to work from.
16:43:46 <edwardk> simpson: sadly
16:43:58 <cmccann> hm, edwardk needs to invent an opengl replacement.
16:44:00 <lispy> linux support for DX11 anyone? :)
16:44:04 <simpson> Actually, there are some *wonderful* APIs, like Cairo, but people like to mock them needlessly.
16:44:06 <sproingie> openergl
16:44:07 <cmccann> that's only slightly more ambitious than the rest of his NIH projects.
16:44:09 <edwardk> cmccann: i'm NDA'd out of that space for a while ;)
16:44:14 <simpson> lispy: I used to hack Gallium.
16:44:19 <simpson> Dx is *stupid*.
16:44:46 <simpson> edwardk: What happened? ARM GPUs?
16:45:09 <elliott> edwardk just collects NDAs so that he can focus.
16:45:12 <cmccann> haha
16:45:23 <edwardk> simpson: to be fair there are enough ways to write code in direct3d that its hard to argue that its stupid. some dialects of how you can and should program with it are actually much better than what you get out of opengl. ;)
16:45:28 <elliott> he decides "ok, I want to do this analytics stuff. let's see how quickly I can get an NDA for everything else in the universe"
16:45:36 <sproingie> he'd tell you how many NDAs he has but there's an NDA covering that
16:45:59 <xplat> yeah, Dx is kind of 'API soup'
16:46:05 <edwardk> sproingie: nah, i'd just have to call my lawyer, and that gets expensive ;)
16:46:33 <edwardk> I know the general shape of what I can and can't do at least =)
16:46:35 <_just> facepalm: check your joinDiffs function
16:46:50 <cmccann> @remember elliott <edwardk> cmccann: i'm NDA'd out of that space for a while ;) <elliott> edwardk just collects NDAs so that he can focus.
16:46:51 <lambdabot> I will never forget.
16:46:57 <simpson> edwardk: Well, I like to not be limited by the APIs.
16:47:18 <simpson> edwardk: And when I hacked Mesa, I knew that we had an extension space if we needed to explore functionality that neither nV nor AMD had registered.
16:47:20 <facepalm> _just: it works with indivisual tests though so I cant think of what would be wrong with it
16:47:38 <edwardk> simpson: Fortunately, I don't use many APIs that I didn't write these days.
16:48:17 <_just> facepalm: joinDiffs [] []
16:48:24 <_just> "*** Exception: Prelude.foldl1: empty list
16:48:29 <simpson> edwardk: In about two or three years, when I'm no longer completely burnt out on writing GPU stuff, maybe we can write the next-generation graphics stack. :3
16:48:38 <simpson> Right now, though, I'm not sure that we have a good language to do it in.
16:49:08 <facepalm> _just: is that because foldl1 cant be empty?
16:49:31 <_just> you cannot fold an empty list
16:49:59 <edwardk> simpson: sounds good. by then i should be able to talk about metropolis light transport and hamiltonian monte carlo sampling with automatic differentiation and nice EDSLs for working with those things in Haskell, admittedly by then it should all be completely irrelevant to the industry once more ;)
16:50:17 <facepalm> _just: so how can I fix joinDiffs so it will work properly then?
16:51:01 <_just> facepalm: sorry but i believe this is your homework :)
16:51:17 <facepalm> _Just yes I know Im not looking for the answer
16:51:48 <_just> you could pattern match for empty lists i guess
16:51:54 <simpson> edwardk: Right now, in my spare time, I'm working on a language. If it ever becomes useful, I'll let you know. Elevator pitch: There are objects in a vat. They pass messages. Erlang but secure, E but easy to read, Python but pure, parsers are core, all I/O is async.
16:52:00 <edwardk> simpson: Well, I'd just plan on generating the assembly for nvidia chips using LLVM now they've officially blessed that aproach
16:52:08 <facepalm> _just: I am looking for a different way to think of this because my instruction for it says to use a foldl and lambda
16:52:12 <simpson> edwardk: Yeah, LLVM turned out to stop sucking for GPUs.
16:52:23 <simpson> I'm still quite skeptical, but whatever works for people.
16:52:28 <edwardk> simpson: remind me some day to give you my old Kata elevator pitch. Maybe you can recycle part of it
16:53:12 <_just> facepalm: what should joinDiff do?
16:53:33 <simpson> edwardk: Well, https://gist.github.com/MostAwesomeDude/5050663 should convince you that we're proper mad scientists. :3
16:53:36 <facepalm> accepts a mask and a data list and concatenates the data values that are dierent from the mask values, each separated by a newline. Assemble the results with a call to foldl and a lambda concatenator. For xample, joinDiffs ["a", "B", "Z"] ["A", "B", "C"]!"A\nC\n".
16:57:04 <ab9rf> good morning
16:57:36 <facepalm> ab9rf: morning
16:58:06 * hackagebot yesod-core 1.2.0.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.0.3 (FelipeLessa)
16:59:01 <simpson> edwardk: Also, I know that it's serious crap, but https://github.com/mostawesomedude/gemstone was an attempt at building a lens-based game library.
17:02:21 <Twey> The worst part about writing interpreters in Haskell is that you automatically try to capture the whole of the target language's type system in Haskell.  >.>
17:02:27 <ab9rf> heh
17:03:00 <BMeph> Twey: If that's the worst thing, then that sounds pretty darned good! ;)
17:04:16 <Twey> BMeph: I've scuppered three attempts at this damn language now because when I'm coding I keep subconsciously trying to capture all the invariants in the Haskell type system, and I can't, which makes me confused :þ
17:05:00 <elliott> the clear solution is to move up a level from Haskell so you can do that
17:05:20 <Twey> elliott: Maybe by writing some kind of language?
17:05:57 <cmccann> Twey: you must invent a language which can capture the invariants of your desired language, but whose own invariants can be captured in Haskell.
17:06:03 <cmccann> it's the only reasonable thing to do.
17:06:15 <Twey> I… think that might be mathematically impossible
17:06:21 * Twey considers.
17:07:21 <Philippa> Twey: if you really really want to, write a not-too-serious interpreter in something with a stronger type system, then derive a Haskell implementation from it?
17:07:40 <Twey> Philippa: Nice
17:08:13 <Philippa> (of course, we don't have the means to prove that the derivation is legit without lots of hard work in the "something with a stronger type system"...)
17:08:21 <Twey> I'm half tempted to write it in Lua, specifically so that I'm not tempted to do that :þ
17:09:05 <dmwit> "This type system is too good, I keep trying to use it."
17:09:17 <Rotaerk> heh
17:09:39 <cmccann> dmwit: I think you have that backwards. if your type system remains usable in practice, it clearly isn't good enough yet.
17:09:48 <Twey> Hahaha
17:10:16 <Philippa> Twey: stick to H2010?
17:11:10 <dmwit> Oooo, yeah, H2010 is almost as good as Lua.
17:11:22 <Twey> I am actually completely in H2010 at this point (well, with some syntactic niceties)
17:11:37 <Twey> I'm being strict this revision :þ
17:22:29 <facepalm> dmwit: how can I go about changing my joinDiffs function to avoid tester.hs: Prelude.foldl1: empty list error?  http://hpaste.org/87192
17:23:06 * hackagebot yesod-core 1.2.0.4 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.0.4 (FelipeLessa)
17:24:20 <facepalm> dmwit: this is the tester.hs http://hpaste.org/87193
17:28:07 * hackagebot yesod-eventsource 1.1 - Server-sent events support for Yesod apps.  http://hackage.haskell.org/package/yesod-eventsource-1.1 (FelipeLessa)
17:28:09 * hackagebot yesod-auth-deskcom 1.2 - Desk.com remote authentication support for Yesod apps.  http://hackage.haskell.org/package/yesod-auth-deskcom-1.2 (FelipeLessa)
17:28:11 * hackagebot yesod-fb 0.3 - Useful glue functions between the fb library and Yesod.  http://hackage.haskell.org/package/yesod-fb-0.3 (FelipeLessa)
17:28:13 * hackagebot yesod-auth-fb 1.6 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.6 (FelipeLessa)
17:28:15 * hackagebot yesod-recaptcha 1.2 - Dead simple support for reCAPTCHA on Yesod applications.  http://hackage.haskell.org/package/yesod-recaptcha-1.2 (FelipeLessa)
17:32:24 <dmwit> facepalm: I guess don't use foldl1?
17:32:27 <dmwit> seems like the best option to me
17:33:10 <facepalm> dmwit: I have to use foldl though, if I remove the 1 is that any different?
17:33:32 <dmwit> Yes, it's different.
17:33:32 <sipa> :t foldl
17:33:34 <lambdabot> (a -> b -> a) -> a -> [b] -> a
17:33:35 <sipa> :t foldl1
17:33:36 <lambdabot> (a -> a -> a) -> [a] -> a
17:33:39 <dmwit> What do you mean, "I have to use foldl"?
17:33:58 <facepalm> requirements for the function
17:34:22 <cmccann> dmwit: probably homework.
17:34:22 <dmwit> > foldl1 f [x,y,z]
17:34:23 <lambdabot>   f (f x y) z
17:34:29 <dmwit> > foldl f w [x,y,z]
17:34:31 <lambdabot>   f (f (f w x) y) z
17:34:37 <cmccann> poorly thought-out homework with weird arbitrary requirements, I suspect.
17:34:41 <dmwit> > foldl f x [y,z]
17:34:41 <cmccann> that seems to be the most popular kind.
17:34:42 <lambdabot>   f (f x y) z
17:35:21 <geekosaur> facepalm, have you looked at the difference between foldl and foldl1?
17:35:39 <facepalm> dmwit: when I use just foldl it crashes. and says Couldn't match expected type `[a0]' with actual type `[b0] -> a1'     In the return type of a call of `foldl'
17:35:53 <dmwit> facepalm: Yes, foldl is different than foldl1.
17:36:03 <dmwit> You need an extra argument saying what to do with the empty list.
17:36:13 <dmwit> I've tried to suggest above with my lambdabot queries how they behave.
17:36:50 <dmwit> sipa has also tried to suggest the difference with his queries.
17:37:01 <dmwit> If it's helpful, you can also see how foldl and foldl1 are implemented using ?src.
17:37:30 <Nisstyre> facepalm: foldl1 uses the first element of the list where foldl would require an initial element (usually an identity element)
17:38:33 <facepalm> so do I need an extra case for [] =[] or just an addition to the one line I already have
17:39:49 <geekosaur> you were told exactly what you were needed
17:42:08 <bjackman> Why is (3+) a valid data constructor but (Int ->) not a valid type constructor?
17:42:37 <bjackman> What I mean is why is it necessary to write "((->) Int)" instead of "(Int ->)"
17:43:03 <zzo38> Is there any Haskell->Verilog compiler?
17:43:16 <bjackman> Actually I think my terminology is totally wrong there, but hopefully you see what I'm asking!
17:43:50 <Nisstyre> bjackman: (3+) is a partially applied function
17:44:04 <Nisstyre> (Int ->) is a partially applied type constructor
17:44:04 <geekosaur> bjackman, because (->) isn't actually a normal operator but syntax; it was possible to "fake it" inside the compiler for ((->) Int), but not for the other
17:44:18 <Nisstyre> what geekosaur said
17:44:30 <luite> zzo38: conal elliott is working on something like that, at least haskell -> programmable logic
17:44:39 <ParahSail1n> @kind (->) Int
17:44:41 <lambdabot> * -> *
17:44:46 <Nisstyre> geekosaur: does TypeOperators allow it?
17:44:48 <Nisstyre> I forget
17:44:53 <ParahSail1n> @kind (Int ->)
17:44:55 <lambdabot> parse error on input `)'
17:44:55 <_just> facepalm: joinDiffs xs ys = foldl (\acc y -> if elem y xs then acc else acc ++ y ++ "\n") [] ys should work
17:45:08 <ParahSail1n> @kind (->)
17:45:10 <lambdabot> * -> * -> *
17:45:21 <geekosaur> I don't think so, it's still special syntax since on the type level it's a kind-level syntax (again, not operator)
17:45:35 <Nisstyre> oh right
17:45:36 <cmccann> I think the bigger problem is that (-> a) is nonsense for most purposes.
17:45:56 <cmccann> it can't mean (\x -> x -> a) because that's not a thing
17:46:33 <cmccann> it would have to be treated as some weird implicit partially applied type synonym
17:46:39 <cmccann> and that's just getting silly
17:46:39 <geekosaur> yes, and that's why it has to be syntax and not an operator or metaoperator
17:46:55 <zzo38> Yes, it would be an implicit type synonym, which Haskell doesn't have (but I think it ought to have).
17:47:08 <cmccann> plus then people would want to ask why they couldn't write "instance Functor (`Either` a)"
17:47:19 <geekosaur> people do ask that already...
17:47:48 <geekosaur> not precisely that one, but there was a question about type-level flip in here earlier today
17:47:59 <cmccann> yes, but at least the syntax doesn't allow using (`Either` a) in other contexts
17:48:09 <Nisstyre> geekosaur: as in flipping the arguments of a type function?
17:48:10 <cmccann> making it legal only in some cases would be even more confusing
17:48:13 <bjackman> Sorry if this sounds very newby but isn't "->" just an infix type constructor?
17:48:37 <cmccann> bjackman: the ways it isn't and sorta can't be just an infix type constructor is what we've been talking about :P
17:48:43 <geekosaur> what is the type constructor in a lambda expression?
17:48:46 <bjackman> as in "a 'Either' b" means "either an a or a b" and "a -> b" means " a function mapping from a to b"
17:49:05 <bjackman> cmccann: ah i see, that explains why i couldn't understand!
17:49:09 <facepalm> _just: yes but changing it to that form makes the previous function no longer work. so I need to keep it in the same format or change the previous filterDiffs function
17:49:20 <zzo38> I really think that using syntax like (x ->) should be allowed where ((->) x) is allowed
17:49:24 <zzo38> But it isn't
17:49:27 <geekosaur> facepalm, or you can add tje one extra parameter you were told to add
17:49:32 <bjackman> I think i should probably come back to this question when I grok Haskell!
17:49:35 <geekosaur> if you would actually consider thinking for a change
17:49:51 <cmccann> bjackman: anyway the short version is that (->) is special and that operator sections aren't allowed in types for somewhat arbitrary reasons
17:49:57 <bjackman> so is "->" a keryword?
17:50:09 <Nisstyre> it's a token
17:50:10 <_just> facepalm: i thin ku just need some type signatures :)
17:50:19 <Nisstyre> or lexeme/grapheme I guess
17:50:20 <geekosaur> read the type of foldl1. read the type of foldl. note the difference. determine from that what additional thing you need to add
17:50:22 <cmccann> I'm not sure if you'd call it a "word" but it is a reserved symbol
17:50:26 <geekosaur> this is not difficult
17:50:33 <facepalm> geekosaur: I was just responding to what he had told me and I am thinking all the time.
17:50:42 <bjackman> If it's a keyword, it seems a bit arbitrary that you can say "(->) a"
17:50:45 <bjackman> sorry not a keyword
17:50:51 <bjackman> but a syntax element of some kind
17:50:53 <geekosaur> it *is* arbitrary. as I said
17:51:03 <zzo38> I think -> is a keyword
17:51:08 <zzo38> Isn't it?
17:51:14 <zzo38> It is a reserved word, anyways.
17:51:15 <cmccann> bjackman: (->) is one of the handful of things that are special syntax with special rules
17:51:25 <tikhonjelvis> at some point, the difference between a "keyword" and a "syntax element" is somewhat arbitrary
17:51:47 <geekosaur> -> has too many special things about to to treat as anything but special syntax (you cn call it a keyword or reserved token or whatever)
17:51:56 <Nisstyre> BTW, it annoys me that XMonad uses --> since my text editor incorrectly parses it as a comment -_-
17:52:01 <bjackman> tikhonjelvis: I think you're probably right but it occured to me that the word "keyword" might be a, um key word in the programming-language-theory world!!
17:52:08 <geekosaur> so does mine
17:52:18 <geekosaur> I manage to survive somehow
17:52:26 <tikhonjelvis> PL theory people don't care about syntax, as a rule
17:52:34 <geekosaur> (mostly because I know my text editor's syntax highlighting is brainless.)
17:52:48 <cmccann> bjackman: e.g., consider that [a] means either a single-element list holding the value "a" or a list containing values of type "a" depending on context. that's another bit of special syntax
17:53:27 <tikhonjelvis> cmccann: The "mixfix" part of [] is clearly special, but the different context isn't
17:53:31 <geekosaur> (if you want some brain-twisting, go look at how cperl-mode does syntax highlighting to work around the double issue of emacs syntax support being very dumb and perl being a very difficult language ot parse)
17:53:33 <tikhonjelvis> e.g. Foo a could be either a type or a value as well
17:55:03 <zzo38> I don't really like all of these special syntax being built-in; these kind of things ought to be made-up using macros instead, in my opinion.
17:55:17 <cmccann> yeah, it's just that the same special syntax is used for two very different things. mixfix [_] on values isn't even a data constructor as such.
17:55:18 <tikhonjelvis> zzo38: yes!
17:55:29 <bjackman> ah yes, that is true. But I had thought that perhaps there is an underlying type for lists that conforms to the normal type semantics, and that "[]" and ":" were just syntactic sugar for functions that actually exist?
17:55:42 <bjackman> or is that exactly what you're sayin?
17:55:43 <zzo38> Especially do-notation, but also lists
17:55:48 <cmccann> [] and (:) are the actual constructors for list values
17:55:52 <cmccann> the list syntax is special
17:56:16 <tikhonjelvis> just to clarify: the list *syntax* is special, but the type itself isn't
17:56:17 <Nisstyre> zzo38: have you used Racket's contract system?
17:56:26 <bjackman> ah so yeah I actually had it right
17:56:35 <Nisstyre> it does have stuff like that, e.g. (listof whatever) instead of [whatever]
17:56:36 <cmccann> [] is also the type constructor for lists
17:56:40 <cmccann> :k []
17:56:42 <lambdabot> * -> *
17:56:47 <geekosaur> if [] were only usable as part of x:y:z:[] it would not necessarily bneed special syntax. but [x], [x,y,z], etc. force it to be special
17:56:49 <bjackman> but at the type level, "->" is more than just syntactic sugar for a type constructor
17:56:58 <geekosaur> likewise tuple syntax is extremely magic
17:56:59 <cmccann> > "a" :: [] Char
17:57:00 <bjackman> so therre is a difference
17:57:01 <lambdabot>   "a"
17:57:33 <zzo38> geekosaur: Well, it is still a special word, and those things, For example, -> is a lowercase type name, and [] is brackets so it is still special in that way.
17:58:00 <zzo38> (Although -> acts like it is capitalized, even though it isn't)
17:58:13 <geekosaur> except it's not actually a type name which is part of why it needs to be special cased...
17:58:14 <bjackman> Well, I have to say, Haskell is pretty fucking fantastic! I've just started learning it proper today after finishing a medium-size (maybe 10k lines max) project in Java and thinking "fuck, software development is hard"
17:58:19 <zzo38> And then -> is also a keyword used in other things like \x -> x ...
17:58:38 <bjackman> So thanks for all your help! I have a feeling I could become pretty enthusiastic about this language.
17:58:46 <cmccann> bjackman: it's a lot of fun :D
17:59:31 <_just> facepalm: joinDiffs xs ys = foldl (\acc y -> acc ++ y ++ "\n") [] (filterDiffs xs ys)
17:59:33 <bjackman> cmccann: And in your experience do the things people say about the functional paradigm actually translate into practical engineering gains?
17:59:39 <bjackman> or do you just enjoy it for its beauty?
17:59:42 <bjackman> I could believe both
17:59:56 <bjackman> I can certainly see how immutability could make life easier
18:00:01 <quchen> What was the URL to check the dependencies of a library on Hackage again? (The things that depend on a certain lib, that is)
18:00:01 <dainanaki> I think many people here would argue both.
18:00:03 <bjackman> but even if it didn't, I'm having a lot of fun!
18:00:10 <tikhonjelvis> it's certainly made *my* life easier
18:00:10 <cmccann> bjackman: both are true, and both are possibly overstated out of enthusiasm
18:00:16 <tikhonjelvis> that and laziness
18:00:17 <Nisstyre> zzo38: I don't think it's that bad from an implementation standpoint though since all of the special syntax still gets desugared, so it's not like it adds any real problems
18:00:21 <cmccann> but the benefits are certainly very real
18:00:27 <Nisstyre> just adds complexity to the grammar
18:00:58 <tikhonjelvis> Nisstyre: it also makes it harder to "extend" the language--you can't add your own construct that behaves like [] does.
18:01:07 <zzo38> Nisstyre: I still think it would be better as macros.
18:01:10 <bjackman> Anyway, night guys, thanks again
18:01:10 <facepalm> _just: thanks I had the empty list param in there as they said to add but didnt have the filterDiffs part
18:01:11 <Nisstyre> tikhonjelvis: true, but Haskell isn't lisp
18:01:12 <zzo38> tikhonjelvis: Yes, that is one reason.
18:01:21 <tikhonjelvis> Nisstyre: and that's the problem, sort of
18:01:28 <cmccann> just use TH!
18:01:36 <cmccann> (that was a joke)
18:01:36 <tikhonjelvis> instead, we get ugly language extensions like the arrow syntax
18:02:12 <zzo38> Yes, that is the problem, sort of. I agree.
18:02:23 <cmccann> if haskell had macros I bet lens could define even more arcane operators.
18:03:37 <tikhonjelvis> I've missed macros in some very concrete ways recently, especially when palying with DSLs
18:03:50 <tikhonjelvis> and also writing some relatively repetitive testing code
18:04:07 <tikhonjelvis> I ended up using implicit parameters for the testing code, but it was still pretty ugly
18:04:11 <tikhonjelvis> also, implicit parameters are a mess
18:04:29 <cmccann> this is when elliott would probably suggest using reflection.
18:04:44 <tikhonjelvis> instead of implicit params?
18:04:57 <Nisstyre> tikhonjelvis: maybe you should be using common lisp if you want implicit parameters
18:05:11 <cmccann> well, to be fair I don't think elliott is too picky about when he suggests the reflection package.
18:05:26 <tikhonjelvis> Nisstyre: except I like the type system, the purity, the abstractions and the infix operators of Haskell too much
18:05:37 <Nisstyre> I think there's a niche to fill there
18:05:42 <tikhonjelvis> it's much easier to port the one feature I like from lisp to Haskell than trying to recreate Haskell in lisp
18:05:53 <Nisstyre> fair enough
18:05:58 <tikhonjelvis> I would even be willing to compromise for something less powerful like mixifx syntax
18:06:44 <tikhonjelvis> also, doesn't common lisp have a different namespace for functions and values?
18:06:48 <cmccann> tikhonjelvis: http://hackage.haskell.org/packages/archive/reflection/1.3.1/doc/html/Data-Reflection.html if you're not familiar with the package btw
18:07:03 <cmccann> it's certainly code that does a thing.
18:07:04 <Nisstyre> tikhonjelvis: I'm not sure. It has different forms for them though.
18:07:21 <Nisstyre> I mostly use Scheme/Racket
18:07:27 <tikhonjelvis> actually, I do write a fair amount of elisp, which is like a degenrate version of common lisp
18:07:32 <tikhonjelvis> and that's not too bad
18:07:45 <tikhonjelvis> I used Racket for a while a couple of months back
18:08:04 <Nisstyre> It's probably my favourite language at the moment.
18:08:10 <tikhonjelvis> then I rewrote much of the same code in Haskell and it ended up being easier to write, shorter, more flexible and generally better.
18:08:33 <Nisstyre> naive Racket code is long
18:08:52 <tikhonjelvis> yes, it is
18:08:59 <tikhonjelvis> I like to think mine wasn't *that* naive though :P
18:09:15 <Nisstyre> well, I don't know how much knowledge you had/have of the stdlib
18:09:21 <tikhonjelvis> it was certainly both much shorter and easier to read than that of the people I was working with
18:09:24 <Nisstyre> there are quite a few macros in there that make things shorter
18:10:09 <tikhonjelvis> people who decided to do things like use mutable arrays all over the place instead of lists :/
18:10:40 <Nisstyre> I generally use lists for most things, or I define a new data type for it
18:10:49 <Nisstyre> (which you can do with struct)
18:10:54 <tikhonjelvis> but yeah, Racket is reasonably nice
18:11:04 <tikhonjelvis> out of the languages I know, I'd choose it over any except Haskell and OCaml
18:11:05 <Nisstyre> it also has subtyping, and you can match on the supertype
18:12:14 <Nisstyre> tikhonjelvis: Typed Racket is neat except it doesn't have global inference
18:12:28 <tikhonjelvis> also, I understand that it uses union types all over the place
18:12:44 <tikhonjelvis> and it doesn't have typeclasses, does it?
18:12:47 <Nisstyre> right
18:13:41 <zRecursive> tikhonjelvis: i heard of racket is a greedy RAM eater ?!
18:13:55 <tikhonjelvis> I didn't have any issues with Racket's memory usage
18:14:11 <tikhonjelvis> but my project offloaded all the difficult computation to an SMT solver anyhow
18:14:32 <zRecursive> RWin built with racket needs > 100M RAM :)
18:15:28 <facepalm> _just: thank you very much that actually solved the other problem too. I had it half right so im not as stupid as geekasaur thinks I am. I had the empty list added and in the correct spot
18:17:28 <Nisstyre> zRecursive: I think DrRacket uses a lot of memory, but I'm not sure about the actual binaries that racket can produce
18:17:47 <Nisstyre> I could check one of my larg-ish programs
18:18:03 <tikhonjelvis> ah, I never used DrRacket, so I can't really comment
18:21:48 <dmwit> I have a cabal file which builds two executables. Both use module X, which imports a module from package foo. Only one of the executables lists foo as a dependency, but both build.
18:21:52 <dmwit> Should I complain?
18:22:17 <cmccann> complaining is always a valid approach.
18:22:43 <Clint> yes
18:24:09 <dmwit> Well, I mean should I formally complain. Which takes work -- make a minimal test case, etc.
18:24:21 <dmwit> So I don't want to do it if it's intended behavior. =P
18:26:37 <cmccann> complaining about intended behavior is the best kind of complaining.
18:27:16 <Clint> i wouldn't intend it
18:29:20 <dmwit> okaaaay
18:31:18 <zzo38> What do you say about thing like this?  data IO_Act = Stop | Out Bool IO_Act | In (Bool -> IO_Act); type IO_Actions = Cont IO_Act;
18:35:52 <meretrix> Generally speaking, what kind of latency can one expect from GHC garbage collection?
18:36:16 <cmccann> hm. it seems a certain borderline /r/haskell troll has deleted their reddit account.
18:37:00 <cmccann> meretrix: latency in what sense? how much time the GC will take in one go?
18:37:19 <elliott> cmccann: the therapist?
18:37:40 <meretrix> cmccann: How long a can expect my process to be held up by a single GC collection.
18:37:46 <meretrix> *How long I
18:38:30 <meretrix> My application will be low load, but need to process small messages very quickly.
18:38:32 <cmccann> meretrix: a few milliseconds is plausible I think
18:38:46 <cmccann> but usually less
18:38:56 <meretrix> Hmm.. I was hoping for more like 100-250us.
18:39:07 <meretrix> Is that not realistic?
18:39:26 <cmccann> might be realistic as an average
18:39:55 <meretrix> The guys from Jane Street claim ocaml can do 10us average, 100us worst case.
18:39:57 <parcs> depends on how much garbage you create ;)
18:40:09 <meretrix> So you would say Haskell is maybe 10x worse?
18:40:51 <meretrix> I don't expect to create huge amounts of garbage.
18:41:13 <meretrix> Would that allow for frequent, but quicker collections?
18:41:28 <hpaste> “C. McCann” pasted “quick GC stats” at http://hpaste.org/87217
18:41:39 <meretrix> Thanks.
18:41:40 <cmccann> that's from an application I'm working on right now
18:42:12 <cmccann> obviously only ran it for a short time but it does most of its allocating early
18:43:12 <elliott> cmccann: your name is actually C. A. Cmccann, ight?
18:43:16 <elliott> r
18:43:25 <meretrix> cmccann: Would you say that your application creates large amounts of garbage?
18:44:03 <cmccann> meretrix: I'm not sure what counts as "large" but it does churn a modest amount
18:45:03 <cmccann> meretrix: I mean, you can see the actual allocation stats there
18:45:04 <parcs> meretrix: yes the less garbage you create the shorter the pause time
18:45:36 <meretrix> Ok, well the 100us average looks quite nice.
18:46:02 <scooty-puff> i'm having trouble lifting A -> Either String C into ArrowIf (or ArrowPlus, ArrowIf, ...) a => a A C
18:46:02 <lambdabot> scooty-puff: You have 1 new message. '/msg lambdabot @messages' to read it.
18:47:03 <cmccann> meretrix: I think the best I can say is that the average case will be well within the range you want
18:47:20 <cmccann> but if occasional slower GCs are an issue you might need to tune things a bit
18:47:50 <cmccann> elliott: anyway yes that is absolutely my real name, good job, you solved the mystery.
18:48:01 <elliott> cmccann: yeah well, that IS your real name.
18:48:12 <elliott> burn.
18:48:18 <cmccann> elliott: that's "ight"
18:48:24 <shachaf> Yes, Casey Cmccann.
18:48:26 <shachaf> Everyone knows that.
18:48:59 <cmccann> shachaf: I'm still pretty sure your real name must be fake.
18:49:01 <cmccann> it's too convenient.
18:49:32 <shachaf> cmccann: It's not so convenient that I was able to get shachaf.com or shachaf.org. :-(
18:49:43 <cmccann> what about funpuns.com
18:50:11 <shachaf> This sounds like a #haskell-blah topic.
18:50:28 <shachaf> I found the greatest account on Twitter, but I won't say its name in here.
18:50:32 <cmccann> no, because the topic involves me, and I am not in #haskell-blah.
18:50:43 <cmccann> logic: flawless
18:51:06 <shachaf> cmccann: You're on-topic in #-blah
18:51:14 <shachaf> Your name is in the /topic.
18:51:30 <cmccann> pf.
18:51:39 <cmccann> that doesn't even count.
18:51:59 <elliott> cmccann: you don't even count!
18:52:11 <shachaf> You're doing a good job turning this channel into #-blah. But that's not what it's for.
18:53:13 <cmccann> shachaf: ok, good point. back to coding.
18:59:51 <cmccann> meretrix: oh, and fwiw the application I'm working on creates and discards a lot of unboxed vectors, so is likely somewhat atypical in its memory use
18:59:57 <cmccann> but it's what I had on hand, sorry
19:08:46 <cmccann> augh, dafis has a legit photo as his avatar on SO now and it's weirding me out.
19:08:53 <cmccann> people shouldn't change their avatars, it is confusing.
19:09:06 <ryant5000> when ghci decides to recompile because flags changed, what flags does that include?
19:11:13 <hpc> ryant5000: all of them, i would assume?
19:11:55 <ryant5000> hpc: even stuff like -Wall, that doesn't affect the output?
19:12:06 <ryant5000> i was hoping it would filter that stuff out
19:12:43 <shachaf> -Wall affects the output if you have -Werror
19:12:59 <shachaf> But, no, the recompilation checker isn't affected by every flag. It's affected by some flags and not others.
19:14:08 <cmccann> shachaf: you're affected by some flags.
19:14:14 <parcs> ryant5000: language extension flags, profiling flags, safe haskell flags, -I, -D, -U, -hcsuf
19:14:35 <ryant5000> parcs: cool; that helps
19:14:52 <ryant5000> i have some stuff that can't be loaded in GHCi, unfortunately, due to issue 7878
19:15:11 <ryant5000> so i've got to make sure i can load the .o files
19:15:35 <shachaf> cmccann: Are you mixing me up with elliott?
19:15:55 <cmccann> shachaf: ah, perhaps. sorry.
19:16:44 <dmwit> Patriots are affected by some flags.
19:31:14 <copumpkin> Prelude Data.Number.CReal> pi**(pi**(pi**pi)) :: CReal
19:31:16 <copumpkin> Loading package numbers-3000.1.0.3 ... linking ... done.
19:31:18 <copumpkin> Segmentation fault: 11
19:31:59 <hpaste> Twey pasted “Duplication” at http://hpaste.org/87220
19:32:26 <Twey> Any idea how I can avoid this duplication?
19:32:41 <Twey> copumpkin: Neat
19:33:04 <Twey> Did you run out of memory?
19:33:25 <cmccann> copumpkin: most segfaults only go up to 10
19:34:19 <copumpkin> yeah, but this one is better
19:34:25 <copumpkin> see, it goes up to 11
19:34:45 <cmccann> amazing
19:35:02 <copumpkin> yeah, pretty good innit
19:35:21 <cmccann> it's ridiculous, it's not even funny
19:35:47 <Nisstyre> when I spend 20 minutes implementing an algorithm that turns out to be incorrect: http://i.imgur.com/TQXAlfD.gif
19:45:43 <lispy> hello my thunks! Are we getting categorial tonight?
19:46:46 <lispy> copumpkin: were you evaluating that because of sigfpe's tweet?
19:46:53 <copumpkin> yup
19:47:30 <lispy> open transcendental problems are the bestest
19:48:28 <cmccann> @quote CReal
19:48:28 <lambdabot> CReal says: cos(2/3*pi) :: CReal
19:48:33 <cmccann> @quote CReal
19:48:33 <lambdabot> CReal says: cos(2/3*pi) :: CReal
19:48:36 <lispy> copumpkin: there is an algorithm to compute the digits of pi in hex that has a really low complexit (was it O(1)?). Wonder if you could tweak that to compute digits of pi^pi etc
19:48:39 <cmccann> pf
19:48:50 <cmccann> @quote CReal
19:48:51 <lambdabot> CReal says: cos(2/3*pi) :: CReal
19:48:59 <cmccann> @quote creal
19:49:00 <lambdabot> gwern says: what was the multiple murderer's favorite numeric type? CReal!
19:49:09 <cmccann> that's better
19:49:13 <cmccann> @quote creal
19:49:14 <lambdabot> gwern says: *ponders Haskell nerdcore: 'I'm all about exact math, yo; I eat CReal for breakfast'*
19:49:15 <shachaf> @quote CReal
19:49:16 <lambdabot> CReal says: cos(2/3*pi) :: CReal
19:49:19 <cmccann> @quote creal
19:49:20 <lambdabot> gwern says: *ponders Haskell nerdcore: 'I'm all about exact math, yo; I eat CReal for breakfast'*
19:49:24 <cmccann> @quote creal
19:49:25 <lambdabot> gwern says: what was the multiple murderer's favorite numeric type? CReal!
19:49:31 <cmccann> so many puns
19:49:43 <shachaf> cmccann is just looking for the shachaf quote.
19:49:47 <cmccann> @quote byorgey creal
19:49:47 <lambdabot> byorgey says: I got this great pair of toy glasses in my breakfast CReal that make you CDouble.
19:49:52 <cmccann> that one's best
19:49:55 <cmccann> fyi
19:50:34 <shachaf> @quote cmccann
19:50:34 <lambdabot> cmccann says: some programmers have a problem to solve and think "I know, I need an existential type." now they have another problem, but can't solve it because all they know about it is that the
19:50:35 <lambdabot> problem exists.
19:50:42 <shachaf> @quote syntaxglitch
19:50:43 <lambdabot> syntaxglitch says: a monad is an endospacesuit on a burrito category
19:51:02 * gwern hopes his past puns have earned him a voting ring on https://news.ycombinator.com/newest ?
19:51:02 <lispy> shachaf: oh cute one about existential types. And also, wise words.
19:51:07 <shachaf> @quote syntaxglitch
19:51:08 <lambdabot> syntaxglitch says: writing DRM isn't possible in Haskell, since it doesn't actually do anything useful GHC simply optimizes it away
19:51:33 <shachaf> gwern: I don't think ithis is the channel for that.
19:51:45 <gwern> 'Predicting Google Shutdowns: Voice, Blogger, etc (gwern.net) ' https://news.ycombinator.com/newest go go submission! drive delicious traffic to the analysis I spent a month working on: http://www.gwern.net/Google%20shutdowns
19:51:53 <gwern> shachaf: dammit, this channel is whatever I say it is!
19:52:17 <gwern> (as long as cale etc don't disagree with me)
19:52:27 <cmccann> <gwern> I AM THE LAW
19:52:27 <lispy> is your server dying under load?
19:52:43 <cschneid> does anybody have a suggestion on which of the web frameworks I should play with? Yesod, and Snap seem decent so far. any real-world reactions to using each one, and what they're good for?
19:52:47 <lispy> I fought the gwern and gwern won
19:52:51 <shachaf> gwern: Maybe e.g. #-blah is better for that... Though, really, it's not that great for it either.
19:52:55 <gwern> lispy: if cloudflare+amazons3 dies under the load, I will be *very* impressed
19:53:01 <shachaf> @where web , cschneid
19:53:02 <lambdabot> #haskell-web | #happs - http://happstack.com/ | #snapframework - http://snapframework.com/ | #yesod - http://yesodweb.com/
19:53:09 <lispy> gwern: This webpage is not available
19:53:16 <cschneid> shachaf: yeah, but choosing between them :)
19:53:28 <lispy> cschneid: I've only used snap and it has worked well for my simple needs.
19:53:28 <cmccann> cschneid: I think both are developed by people who actively use them in real-world scenarios
19:53:38 <shachaf> Between #haskell-web and #haskell, for web questions?
19:53:40 <gwern> lispy: ? you must be doing something wrong
19:53:40 <shachaf> I'd say the former.
19:53:55 <cschneid> shachaf: didn't even know that channel existed :) joining
19:54:03 <lispy> gwern: The server at www.gwern.net can't be found, because the DNS lookup failed.
19:54:30 <cschneid> shachaf: well, it's got like 5 people. :-/
19:54:32 <gwern> lispy: you can't go to http://www.gwern.net/ at all?
19:54:34 <shachaf> lispy: That's a DNS failure.
19:54:42 <gwern> that doesn't make sense, my entire site is not down
19:54:46 <shachaf> Not gwern's server, I'd say.
19:54:46 <lispy> shachaf: agreed. I didn't know that initially.
19:55:12 * gwern paranoidly checks http://www.downforeveryoneorjustme.com/http://www.gwern.net just to be sure
19:55:14 <lispy> gwern: comcast has spastic dns servers.
19:55:18 <cmccann> gwern's site works fine for me.
19:55:33 <gwern> lispy: have you considered switching to opendns, or I think google runs a public dns system too
19:55:57 <lispy> nah, it's just for sites I don't care about ;)
19:56:10 <shachaf> Use one of 4.2.2.2 and 8.8.8.8 and 208.67.222.222
19:57:10 <lispy> I probably should. My dns doesn't break all that often.
19:57:55 <lispy> heh, now even gmail is not resolving. I wonder I'm able to IRC
19:58:40 <gwern> lispy: you're already connected (the freenode domain resolved to a specific IP). if you disconnected, you would probably have trouble reconnecting
19:59:01 <gwern> lispy: I discovered this a few months back as i puzzled over how the heck I was able to still irc while every page load or ssh out was failing
20:46:39 <mokus> @tell jfischoff there should now be sufficient logging to identify the failing plugin
20:46:40 <lambdabot> Consider it noted.
20:47:42 <DiegoNolan> is there a haskell library that does linear algebra and is entirely haskell, not bindings to blas or something?
20:48:18 <blackdog> DiegoNolan: i think @cartazio's building something like that
20:50:02 <DiegoNolan> i just wrote something to do gaussian elimianation but it doesn't consider a lot of edge cases and is probably really slow
20:59:01 <ParahSail1n> anyone have a favorite package for xml parsing?
20:59:34 <Clint> xml-conduit
21:02:22 <lispy> DiegoNolan: hmatrix is the best I've seen for fast matrix stuff in Haskell. It does use blas though.
21:02:51 <lispy> DiegoNolan: you might try edwardk's linear algebra library. http://hackage.haskell.org/package/linear
21:03:08 <lispy> DiegoNolan: I've never tried it but edwardk is pretty sharp so I just assume it works well.
21:03:56 <johnw> i think hmatrix is a more complete matrix manipulation library
21:04:09 <johnw> and linear is a good abstraction of dealing with vectors and vector spaces in a general way
21:04:38 <johnw> for example, linear will let you treat any Map as a vector space
21:05:12 <cschneid> can somebody help me figure out the right way to integrate the helper function bitDiffCount here: https://gist.github.com/cschneid/9a22d473cf6d5c234f90
21:05:27 <cschneid> I can't seem to get a solution that both typechecks and is right. :-/
21:05:34 <johnw> bitDiffCount = popCount . xor
21:05:40 <johnw> what do you mean by "integrate"?
21:05:47 <DiegoNolan> looking at the libraries, i don't think it solves linear systems. i could be missing it though
21:06:01 <johnw> hammingDistance' = sum . zipWith (popCount . xor)
21:06:09 <johnw> oh, no
21:06:13 <johnw> you'd have to use:
21:06:37 <johnw> hammingDistance' = (sum .) . zipWith ((popCount .) . xor)
21:06:40 <cschneid> johnw: un-extract that helper func.
21:07:11 <cschneid> johnw: what. I need an explaination. And I did update that gist with the error when I pull in (popCount . xor) in place of bitDiffCount
21:07:16 <lispy> DiegoNolan: I think you're right
21:07:20 <dmwit> DiegoNolan: hmatrix definitely solves linear systems.
21:07:23 <johnw> cschneid: it has to be (popCount .) . xor
21:07:28 <johnw> because xor wants two args
21:07:40 <dmwit> DiegoNolan: I'm pretty sure linear does not.
21:08:22 <johnw> f (g x y) = (f .) . g $ x y
21:08:36 <johnw> there is a combination out there call .: which makes that easier to use
21:08:41 <johnw> combinator
21:08:50 <BMeph> johnw:
21:08:58 <BMeph> (f .) . g $ x $ y
21:09:05 <johnw> oh, yeah, thanks
21:09:15 <johnw> can't type at the moment, clearly
21:09:17 <cschneid> johnw: hmm, interesting. let me go ponder the types for like an hour, hopefully reaching enlightenment at some point :)
21:09:21 <BMeph> johnw: Otherwise, it'll try to apply x to y. :)
21:09:30 <johnw> cschneid: think of it like this
21:09:46 <cschneid> the partial application of `.` isn't natural to me... :)
21:10:11 <johnw> (f .) . g = compose f with the function _returned_ by g
21:10:29 <johnw> f . g = compose f with g itself
21:10:42 <cschneid> ahh interesting.
21:10:45 <johnw> so, (f .) . g $ x = f . g x
21:10:58 <cschneid> and since xor wants two args, given only one, it returns a new func that takes one.
21:11:03 <johnw> exactly
21:11:13 <shachaf> You shouldn't use the (f .) . g idiom, though.
21:11:20 <shachaf> Just name the variable.
21:11:23 <johnw> i use it enough in my code now that it's clearer
21:11:38 <shachaf> Your code doesn't have to be clever to the point of being unreadable.
21:11:42 <cschneid> shachaf: name the variable? What do you mean? Extract it like I have now?
21:11:45 <johnw> i didn't say it was clever code
21:11:52 <johnw> just that the idiom is now transparent through common use
21:11:58 <cschneid> shachaf: or perhaps a lambda if it's sufficiently clear
21:12:05 <shachaf> I mean a lambda, yes.
21:12:07 <cschneid> johnw: sure. What's this :. operator?
21:12:14 <johnw> it's in Data.Function.Pointless
21:12:16 <shachaf> Keep in mind that not everyone learns Haskell via watching IRC golf.
21:12:19 <johnw> f .: g = (f .) . g
21:12:45 <shachaf> concatMap f = concat . map f
21:12:45 <cschneid> shachaf: `hammingDistance' a b = sum $ zipWith (\x y -> popCount $ xor x y) a b` -- for instance
21:12:52 <shachaf> Much better than concat = (concat .) . map
21:12:58 * BMeph does a rousing IRC golf clap...
21:13:20 <johnw> shachaf: yes, that's a good example
21:13:44 <cschneid> yeah, I've seen that point-free isn't a goal in itself.  Unless it's clearer .
21:13:57 <johnw> I kind of like the idea behind these combinators too: http://hackage.haskell.org/packages/archive/composition/latest/doc/html/Data-Composition.html
21:14:03 <johnw> they give you .: .:. .::, etc.
21:14:15 <johnw> you just count the number of periods after the first, and that's how many arguments the second function is expecting
21:14:43 <shachaf> They give you code which is too clever for its own good.
21:16:08 <cschneid> johnw: lol: "(.********)"
21:16:14 <cschneid> yeah, that's reasonable!
21:16:20 <cschneid> and totally self-explanatory!
21:16:33 <cschneid> johnw: shachaf: you're both super helpful, thank you.
21:17:16 <cschneid> the impression I have is that a $ in my code is a minor code smell. Is that right? Should I be attempting `.` based composition first before falling back
21:17:27 <johnw> $ is very handy
21:17:40 <johnw> I use $ mostly when the left side and right side address different aspects of a problem
21:17:46 <johnw> i don't use them purely to separate arguments, usually
21:17:52 <johnw> so, I say: return $ foo x
21:17:54 <johnw> but foo (x y)
21:18:15 <cschneid> even though `foo $ x y` is equivalent
21:18:19 <johnw> because in the first case, return is part of the monad operation, while foo x is a pure call, and in the second, x y is an argument to a pure function
21:18:21 <johnw> yes, equivalent
21:18:28 <johnw> but $ sort of calls out a "division of labor", to my mind
21:18:42 <monochrom> I avoid $
21:18:52 <cschneid> monochrom: a "weak code smell" to you?
21:19:03 <johnw> i dislike overuse of $
21:19:10 <johnw> i prefer overuse of () if required
21:19:18 <monochrom> I don't know what is code smell, and I don't to know. $ is almost pointless
21:19:19 <johnw> but I like good use of $ very much
21:19:29 <shachaf> johnw: You dislike overuse of anything by definition, almost.
21:19:34 * tgeeky only uses $ when I'm too lazy to type ( ... )
21:19:39 <johnw> shachaf: haha
21:19:40 <shachaf> The question is what overuse of $ is.
21:19:48 <johnw> my $ name $ is $ shachaf
21:19:54 <monochrom> zipWith ($) [f, g, h] [1, 2, 3] is one of the rare uses
21:20:11 <cschneid> so what would you then change in https://gist.github.com/cschneid/4f437726fcf789c3dbc6 -- the whole hammingDistance file. Any suggestions
21:20:27 <johnw> two $'s on the same line is rare, but it happens
21:20:34 <johnw> like: void $ liftIO $ atomically $ ...
21:20:49 <shachaf> void . liftIO . atomically $
21:20:57 <johnw> yeah, but somehow that obscures the intent a bit for me
21:21:03 <johnw> maybe I'm just too used to writing it the other way
21:21:09 <johnw> now, I _do_ use f . g . h $ x
21:21:17 <johnw> to avoid egregious paranthesis buildup
21:21:23 <shachaf> But not when f=void, g=liftIO, h=atomically?
21:21:27 <johnw> correct
21:21:36 <johnw> because in my mind, liftIO and atomically concerns different "domains" (see above)
21:21:48 * tgeeky has actually been convinced
21:21:48 <monochrom> parentheses are the most accurate to my intent
21:21:53 <shachaf> domain = do main
21:23:17 <cschneid> in my last gist (https://gist.github.com/cschneid/4f437726fcf789c3dbc6), what would you name the lambda args? Is something like `a'` and `b'` better?
21:23:25 <cschneid> ie, they're one byte of the list of bytes
21:23:35 <monochrom> I fully intend "f (g (h (expr)))". "f $ g $ h $ expr" is an encoding of my intention. it needs to be decoded. to decode, you must recall the fixity and precedence of $.
21:23:51 <cschneid> monochrom: do you ever use $?
21:23:59 <johnw> f . g . h $ expr is nice in that case
21:24:05 <monochrom> zipWith ($) [f, g, h] [1, 2, 3] is one of the rare uses
21:24:05 <johnw> it's easier for me to read the compositional intent
21:24:20 <cschneid> monochrom: so only when it's a true function, not just a shortcut to parenthesis
21:25:09 <monochrom> currently, I compromise with emacs haskell mode indenter by writing "withXXX $ \h -> do", but that will go away
21:25:32 <johnw> multi-line lambdas is a place where I cannot brook parentheses
21:26:22 <johnw> if parentheses are required, like the first arg to bracket, I consider factoring out a definition
21:29:00 <cschneid> I appreciate the talk of style here - it's rough to learn a new language's style, moreso than the technical "what works" level
21:30:17 <johnw> cschneid: it helps to assist on other projects that already have a style
21:30:23 <johnw> then you know whether you like it or not
21:30:54 <cschneid> johnw: I'm at the awkward level of learning that I'm done with books for the most part, and sorta understand them, but not quite to the point I can really read xmonad & similar level projects
21:31:02 <johnw> shachaf works on lens, so I'm sure he's used to always defining functions that are smaller than the type signatures
21:31:03 <cschneid> any suggestions on what to read out of real code?
21:31:22 <shachaf> cschneid: You probably shouldn't use Data.ByteString.Char8
21:31:29 <mgsloan> johnw: I believe that's lens design principle #1
21:31:30 <johnw> yeah, avoid Char8
21:31:36 <shachaf> .Char8 is the devil
21:31:49 <edwardk> yes most implementations should be 'id' or 'unsafeCoerce'
21:31:49 <lambdabot> edwardk: You have 3 new messages. '/msg lambdabot @messages' to read them.
21:31:58 <cschneid> it actually matches the problem statement exactly, but yes, I understand that it throws away unicode.
21:32:20 <shachaf> cschneid: You're not even using it, actually, just importing.
21:32:36 <cschneid> haha
21:32:37 <cschneid> damn it
21:32:42 <shachaf> strToWord8 is the evil function there.
21:33:08 <cschneid> shachaf: yes it is. It throws away anything beyond 0-255
21:33:12 <shachaf> I suggest that you actually want to encode as UTF8 or something instead.
21:33:45 <cschneid> shachaf: this is part of a larger encryption problem that explicitly states that it's all boring ascii, which lets me make that assumption
21:33:52 <cschneid> shachaf: otherwise, your'e entirely right
21:34:00 <shachaf> cschneid: OK, if it's all ASCII, then encode it as UTF8.
21:34:03 <shachaf> You get the same result.
21:34:46 <cschneid> hmm, as long as it has a Bits instance... or I can write one... :)
21:34:52 <shachaf> ?
21:35:07 <shachaf> encoding to UTF8 can have the same type: encode :: [Char] -> [Word8]
21:35:14 <lispy> Is anyone else having trouble with freenode tonight?
21:35:28 <johnw> lispy: with the people on it, perhaps
21:35:34 <cschneid> shachaf: ok. I'll go look
21:35:36 <shachaf> If you have codepoints past u+ff, the output list might be longer than the input list.
21:42:21 <monochrom> lispy: so, I just disconnected and re-connected successfully (I had to reboot the computer anyway)
21:44:45 <lispy> Sounds like freenode is working fine for others.
21:44:50 <lispy> Must have been a local issue with tmux
22:02:19 <mavam> what's the difference between 'pure' and 'return'? Is it only the typclass of the wrapper, Applicative vs Monad?
22:11:22 <jfischoff> mokus: hey just pulled and got the same error
22:11:23 <lambdabot> jfischoff: You have 1 new message. '/msg lambdabot @messages' to read it.
22:11:32 <jfischoff> @messages
22:11:32 <lambdabot> mokus said 1h 24m 53s ago: there should now be sufficient logging to identify the failing plugin
22:12:01 <jfischoff> I'm clean rebuilding.
22:12:25 <jfischoff> mokus: way to increase the log level? Does the logging get dumped to a file?
22:13:08 <jfischoff> crap same thing
22:13:38 <jfischoff> does anyone know if lambdabot where lambdabot tries to look for plugins?
22:13:53 <jfischoff> Cale: I'm looking at you ;)
22:14:36 <shachaf> Cale disclaims all knowledge of lambdabot. He just run the executable.
22:14:44 <jfischoff> @tell mokus Same error :(. Is there a way to increase the logging? Does it go a files?
22:14:45 <lambdabot> Consider it noted.
22:14:49 <jfischoff> ah
22:15:16 <jfischoff> maake maybe?
22:15:21 <jfischoff> mauke I mean
22:15:32 <shachaf> Why mauke?
22:16:06 <jfischoff> I saw sclv assume mauke knew how to fix preflex
22:16:43 <jfischoff> I don't know, how knows besides mokus?
22:16:50 <jfischoff> s/how/who
22:17:11 <sclv> don't bother him about this
22:17:16 <sclv> preflex is his bot
22:17:21 <sclv> no reason he'd be involved with \bot
22:17:42 * djahandarie bothers mauke and blames sclv
22:17:56 * cmccann bothers djahandarie and blames shachaf.
22:17:59 <shachaf> preflex is not lambdabot.
22:18:04 * jfischoff feels like he bothered sclv
22:18:09 <cmccann> shachaf: you're not lambdabot.
22:18:23 <shachaf> cmccann: Thank you.
22:18:23 <djahandarie> No, I am lambdabot!
22:18:28 <djahandarie> Wait... wrong thing?
22:18:38 <shachaf> Wrong channel.
22:18:40 <shachaf> (#-blah)
22:19:01 <djahandarie> Don't try to trick me into joining there! I know what goes on in there
22:19:15 <shachaf> There are new rules. For example a rule against inside jokes.
22:19:18 <shachaf> So I guess it's off-topic there too.
22:19:38 <cmccann> djahandarie: suggesting something belongs in #-blah is just shachaf's way of getting out of a conversation.
22:19:53 <cmccann> it doesn't mean he actually wants the conversation to continue there either.
22:20:10 <djahandarie> It's definitely a good way to kill a conversation. Sneaky.
22:20:20 <shachaf> cmccann: No. That would be suggesting that it's off-topic without suggesting a new channel.
22:20:37 <djahandarie> Inside jokes are off-topic on freenode
22:20:45 <shachaf> I like -blah for some bizarre reason. I don't want it ruined with bad conversations.
22:21:04 <cmccann> shachaf: you're right, that is bizarre.
22:24:37 <yogert> :b 1
22:33:31 * hackagebot cassy 0.5.1.0 - A high level driver for the Cassandra datastore  http://hackage.haskell.org/package/cassy-0.5.1.0 (OzgunAtaman)
22:36:24 <blackdog> ozataman: *big smiles*
22:36:49 <ozataman> blackdog: :)
22:36:50 <lambdabot> ozataman: You have 1 new message. '/msg lambdabot @messages' to read it.
22:37:54 <ozataman> Just got your message. I'd be interested and have in fact a semi-completed one in the works. See: https://github.com/ozataman/aws
22:38:01 <ozataman> Ops MT :)
23:03:32 * hackagebot network-simple 0.2.0.0 - Simple network sockets usage patterns.  http://hackage.haskell.org/package/network-simple-0.2.0.0 (RenzoCarbonara)
23:37:58 <Watabou_> hello
23:38:23 <Watabou_> I'm learning haskell with learn you a haskell
23:38:33 * hackagebot cabal-db 0.1.2 - cabal-db  http://hackage.haskell.org/package/cabal-db-0.1.2 (VincentHanquez)
23:38:35 <Watabou_> but I wish that book had some exercises to go along with it
23:39:44 <Watabou_> anyone know a good haskell book with exercises? I find that exercises reinforce what I just learned
23:39:59 <vamega> Watabou_ I agree
23:40:04 <Watabou_> I'm liking Learn You a Haskell though and I'm planning on finishing it
23:40:07 <vamega> I don't know of any though
23:40:15 <vamega> I just read until I was done with Monads
23:40:20 <vamega> And then started trying things out.
23:40:43 <Watabou_> yeah I'm experimenting a lot with ghci and trying to get comfortable
23:41:12 <vamega> I'm developing a Hakyll blog, and am having an issue with my types
23:41:33 <vamega> http://hpaste.org/87225 has the code section and the compiler output
23:43:02 <vamega> Love to hear ideas as to why it's breaking, I've spent over an hour trying to make make changes.
23:44:58 <Watabou_> hmm apparently the "haskell road to logic and programming" book has exercises. I doubt it's geared for beginners though so maybe I will stick with "learn you a haskell" for now
23:47:04 <arkeet> I thought some stuff on fpcomplete had exercises?
23:47:17 <Watabou_> fpcomplete?
23:47:37 <arkeet> school of haskell or whatever.
23:47:45 <Watabou_> oh, let me check that out
23:48:10 <arkeet> I might be wrong.
23:50:09 <Watabou_> yeah it does, thanks
23:51:34 <NihilistDandy> Watabou_: I'd also recommend HaskellCraft: http://amzn.com/0201882957
23:51:57 <arkeet> I saw that book in the bookstore once.
23:52:07 <arkeet> I don't remember anything about its contents.
23:52:30 <NihilistDandy> It gets into QuickCheck quite early on, which I appreciated
23:52:35 <Watabou_> cool thanks NihilistDandy
23:52:39 <Mercuria1Alchemi> vamega: you're missing $ do
23:52:47 <Mercuria1Alchemi> vamega: match "special_pages/about.rst" $ do
23:55:45 <Watabou_> hmm when I do :t (*), I get:
23:55:47 <Watabou_> (*) :: Num a => a -> a -> a
23:55:55 <Watabou_> I understand a -> a -> a part
23:56:14 <Watabou_> but I'm confused on (*) :: Num a part
23:56:35 <Watabou_> (*) is the function but what does Num a refer to?
23:57:07 <NihilistDandy> Watabou_: The type of a is an instance of the Num typeclass
23:57:23 <NihilistDandy> Do :i Num in ghci for some information
23:57:43 <shachaf> The type of (*) is Num a => a -> a -> a
23:58:00 <shachaf> "(*) :: Num a" by itself doesn't make sense.
23:58:13 <Watabou_> hmm okay I think I understand that
23:58:45 <Watabou_> so it's sort of saying the * function operates on a member of Num typeclass?
23:58:55 <shachaf> If you understand (*) :: a -> a -> a, that's a good start.
23:59:07 <shachaf> Num a => means it'll only work for types which are Num.
23:59:12 <shachaf> @instances Num
23:59:14 <lambdabot> Double, Float, Int, Integer
23:59:34 <shachaf> So you can't say "hi" * "ho" because String isn't (normally) Num.
23:59:49 <Watabou_> hmm okay
23:59:53 <Watabou_> thanks
