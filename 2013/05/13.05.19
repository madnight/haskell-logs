00:00:04 <ion> shaladdl1: indeed
00:00:19 <johnw> right
00:00:44 <johnw> i'm writing C++ at the moment, my neurons are misfiring all over the place
00:04:42 <enthrops> I hope stupid question are ok. 'repeat' x = [x] ++ repeat' x' why is that actually giving output in ghci if return value is never computed?
00:05:30 <shachaf> There is no reason that is actually giving output in ghci if return value is never computed.
00:05:44 <johnw> and to define a function in ghci, you need to use let
00:06:06 <shachaf> I suspect that is not the issue.
00:06:14 <shachaf> enthrops: ...However, the return value is clearly computed.
00:06:15 <enthrops> I define in a file and than load in ghci
00:06:24 <shachaf> Seeing as it's actually giving output in ghci.
00:07:50 <enthrops> I'm asking it for result of repeat'. To calculate it it needs to needs to calculate repeat' recursively and there's nothing stopping it. How does it know that 'repeat' 2' is supposed to output a whole bunch of 2s?
00:09:00 <enthrops> I just tried that in Ruby and it didn't show anything and stack overflowed, just like I expected
00:09:15 <shachaf> Haskell is non-strict.
00:09:23 <shachaf> You can have infinite lists.
00:09:41 <enthrops> I got that, but outputting output until it's ready seems surprising
00:10:02 <shachaf> ?
00:10:22 <enthrops> or can it deduce that when lists are concatenated and the first part can be computed, then it can output whatever is ready?
00:10:26 <Hanyou> Haskell returns output as soon as it can. Take a look at the difference between foldr and foldl for example.
00:11:34 <jkarni> try switching the order:
00:11:54 <jkarni> that is: repeat' x = repeat' x ++ [x]
00:12:06 <jkarni> that's not going to output anything, just as you expected
00:12:07 <enthrops> Yep, switching order does it
00:12:19 <enthrops> well, cool, thanks
00:12:49 <shachaf> There is no magic to evaluating Haskell.
00:13:34 <shachaf> There's no real "deduction". The implementation still follows simple mechanical rules one step at a time. It doesn't try to figure out anything.
00:13:39 <johnw> any technology, insufficiently understood, is indistinguishable from magic
00:13:49 <enthrops> I get that it's not magic
00:14:20 <ion> Also, Haskell [] is a different data structure.
00:14:35 <arkeet> enthrops: http://www.vex.net/~trebla/haskell/lazy.xhtml
00:14:37 <Hanyou> Aren't we talking about thunks? http://www.haskell.org/haskellwiki/Thunk
00:14:50 <enthrops> it's just seems weird that the the compiler knows what part of a return value is before it is calculated
00:15:00 <shachaf> It doesn't.
00:15:14 <shachaf> Hanyou: You don't need to talk about thunks.
00:15:28 <shachaf> Thunks will only mislead you.
00:16:30 <Hanyou> Isn't it just a way to think about Haskell's lazyness?
00:16:42 <ion> > case 42 : error "oh no" in x:_ -> x  -- This doesn't try to evaluate the part after the :
00:16:42 <enthrops> it doesn't? so that's just a special case for lists?
00:16:44 <lambdabot>   <hint>:1:25: parse error on input `in'
00:16:57 <ion> > case 42 : error "oh no" of x:_ -> x
00:16:59 <lambdabot>   42
00:17:10 <arkeet> 42 : unsafePerformIO launchMissiles
00:17:22 <ion> It might as well be an infinite list instead of error "oh no", it’s still not evaluated.
00:17:25 <latermuse> <3 unsafePerformIO
00:17:47 <enthrops> k, thanks guys
00:17:48 <jkarni> enthrops: if you type in [1..] in ghci, you'll get output
00:17:57 <jkarni> but ghci doesn't know what [1..]
00:17:58 <jkarni> is
00:17:59 <johnw> latermuse: unsafePerformIO is how little values get made
00:18:03 <jkarni> in all
00:18:04 <ion> > case error "head of list" : [1,2,3] of _:xs -> xs  -- this evaluates only the tail.
00:18:06 <lambdabot>   [1,2,3]
00:18:10 <latermuse> > zip [1..5] [1..]
00:18:13 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5)]
00:18:13 <Cale> Hanyou: Well, it's a way, but thunks (whatever they happen to be) are just a representation of expressions at runtime. You can just think in terms of expressions being reduced to other expressions most of the time.
00:18:30 <bartavelle> is there a specific configuration to be put in cabal files to use #size and #peek in chs files ?
00:18:36 <bartavelle> I get "Foreign/Ruby/Bindings.chs:14:17: Not in scope: `#'"
00:18:38 <ion> (:) isn’t special in this case, it applies to any nonstrict data constructor.
00:18:38 <enthrops> > [1..]
00:18:40 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
00:18:46 <bartavelle> (but #include works)
00:18:58 <latermuse> [1..] == [1..28]
00:19:03 * latermuse laughs
00:19:11 <arkeet> > 1..] == [1..28]
00:19:13 <lambdabot>   <hint>:1:2: parse error on input `..'
00:19:13 <arkeet> > [1..] == [1..28]
00:19:15 <lambdabot>   False
00:19:21 * arkeet
00:19:22 <enthrops> wanted to crash you guys :(
00:19:29 <enthrops> jk
00:19:32 <enthrops> thanks
00:19:41 <latermuse> > pi
00:19:42 <lambdabot>   3.141592653589793
00:19:42 <arkeet> enthrops: you should read the article I linked you.
00:19:45 <arkeet> > pi :: CReal
00:19:47 <lambdabot>   3.1415926535897932384626433832795028841972
00:19:48 <latermuse> > pi == 3.141592653589793
00:19:50 <lambdabot>   True
00:19:53 <enthrops> arkeet: I'll try :)
00:19:54 <latermuse> wahahaha
00:20:08 <jkarni> what?
00:20:21 <latermuse> sorry im a bit drunk atm... better sign off before i say something dumb
00:24:01 <Taneb> Does Text offer any advantages when I know that I'm gonna be storing pretty short things that only use the English alphabet and '_'?
00:24:22 <ion> Compared to?
00:24:25 <johnw> you mean, you wonder if you should use ByteString?
00:24:37 <Taneb> ion, String
00:24:43 <johnw> String is UCS-32, isn't it?
00:24:52 <Taneb> Or maybe ByteString, yeah
00:25:01 <johnw> UCS4, I think I mean
00:25:04 <johnw> UTF32
00:25:22 <johnw> Taneb: because you always end up with different requirements
00:25:33 <johnw> Text is pretty good, and then you won't ever get it wrong
00:26:17 <bartavelle> ok chs2hs seems to understand what is going on, but I believe cabal isn't running it. Anybody got a clue ?
00:26:58 <bartavelle> err
00:27:00 <bartavelle> hsc2hs
00:27:41 <bartavelle> ah got it
00:27:57 <arkeet> I thought you just needed to have a .hsc file
00:28:39 <shachaf> johnw: What does ByteString have to do with it? :-(
00:29:19 <bartavelle> arkeet, I has a chs file, which used another preprocessor (which worked until I needed #peek)
00:29:31 <bartavelle> renamed it to hsc, and not it works
00:29:41 <arkeet> yes, because that's a hsc file ;)
00:29:57 <bartavelle> heh
00:30:07 <ion> shachaf: He probably implied “with an implied encoding that will have to be decoded for processing as text”.
00:30:48 <arkeet> Text is stored as utf-16
00:32:51 <johnw> shachaf: storage characters as 8-bit bytes
00:33:03 <johnw> storing*
00:37:23 <ion> In what encoding?
00:37:40 <johnw> I assumed he meant 7-bit ascii
00:37:50 <johnw> you know, "the good old days"
00:50:33 <icarot> > map (+) [1,2,3]
00:50:35 <lambdabot>   *Exception: showList: No overloading for function
00:50:48 <johnw> > foldl1' (+) [1,2,3]
00:50:50 <lambdabot>   6
00:51:54 <enthrops> Why is this giving me 'No instance for (Ord a) arising from a use of `>'' when I have the type declaration line in place? https://gist.github.com/anonymous/dceb7ef067afdb677300
00:52:30 <shachaf> enthrops: Because the type declaration is wrong.
00:52:31 <arkeet> because your type is too general, and claims you can sort lists of any type.
00:52:42 <arkeet> not just lists of ordered things.
00:52:50 <shachaf> Try commenting it out and then using :t quicksort in ghci to see what the type really is.
00:53:00 <shachaf> (Also: This isn't quicksort.)
00:53:17 <icarot> > (+) \ x y -> x+y
00:53:18 <arkeet> depends on what exactly you mean by quicksort.
00:53:19 <lambdabot>   <hint>:1:5: parse error on input `\'
00:53:39 <icarot> dammit.
00:53:49 <enthrops> wait, it actually complains about being a type being too general?
00:54:16 <raymank26> Hi all. I am trying to define some Parser datatype for lexical analysis(compiler phase). So, I need some type of parser that allow me to handle state(line number) and make input string transformation in case of error. But this problem too hard for me. Any points or suggestions? I know about Parsec library, but I want to invent the circle :).
00:54:20 <icarot> (+) = \ x y -> x+y
00:54:30 <shachaf> The type makes a promise that the code doesn't keep.
00:54:33 <shachaf> Of course it complains.
00:55:13 <johnw> raymank26: pick an easier problem to do first
00:55:14 <enthrops> the type says function takes a list of some types and returns a list of same types
00:55:21 <arkeet> yes
00:55:22 <arkeet> for any type
00:55:33 <raymank26> johnw: for example?
00:55:34 <arkeet> even types that don't have an Ord instance
00:55:42 <johnw> raymank26: whatever else interests you
00:56:04 <enthrops> ok, I would understand if I said function takes strings, and then did a + on the arguments in the method body
00:56:12 <enthrops> then I would get the error
00:56:23 <arkeet> you would get a different error.
00:56:28 <raymank26> johnw: I have no choice. I implement compiler for self language in C++ but not I want to make it in haskell.
00:56:30 <enthrops> but too general? I'm either stupid or this is just too different
00:56:32 <arkeet> well, somewhat similar.
00:56:38 <shachaf> I wish + gave a unification error rather than an instance error. :-(
00:56:47 <raymank26> *now
00:56:53 <shachaf> That way beginners wouldn't be tricked into thinking about type classes so early.
00:56:59 <arkeet> enthrops: the type claims that your thing can sort a list of Wibbles.
00:57:04 <arkeet> I don't know how to compare two Wibbles.
00:57:43 <arkeet> or functions, say.
00:57:51 <enthrops> we are now talking about '>' and '<=' right?
00:57:54 <arkeet> yes
00:57:56 <johnw> raymank26: I'd use the trifecta library to do the parsing, why do you need to reinvent parsers if you just want to write a compiler for your language in Haskell?
00:57:58 <enthrops> ok hold on
00:58:02 <arkeet> those require an Ord constraint on the type
00:59:39 <enthrops> ok, now I forgot how C works
00:59:53 <arkeet> C doesn't have polymorphism.
01:00:26 <enthrops> right, I want to see what it throws at me if I apply > to an array
01:00:35 <arkeet> it will happily compare two pointers.
01:00:46 <raymank26> johw: I want to practice in haskell datatype, instance declarations, but not in using predefined Parsec functions. I want to reimplement some of them.
01:01:09 <johnw> raymank26: i think you may need more background before you go into that
01:01:13 <enthrops> arkeet: so haskell has polymorhism? type polimorphism?
01:01:44 <arkeet> as in you can write a single definition that works with multiple types.
01:01:45 <latermuse> raymanK26: you can reimplement the functions. use 'hiding'
01:01:49 <enthrops> I tried pattern matching on different types and that errored out
01:02:01 <arkeet> I don't know what pattern matching on types is.
01:02:32 <arkeet> <shachaf> Try commenting it out and then using :t quicksort in ghci to see what the type really is.
01:02:35 <enthrops> right, that's a quick stupid idea of mine
01:03:03 <enthrops> arkeet: so can you say hey haskell if this function is called with a list do this, and if it's called with a tuple do that
01:03:06 <enthrops> ?
01:03:40 <arkeet> well, that's a different kind of polymorphism.
01:03:45 <arkeet> parametric vs ad-hoc
01:03:49 <raymank26> johw: hm. For example? I yet reimplement Parsec with simple Parser datatype String -> Maybe (a, String) with Monad, Functor and Applicative instances with many combinators. But now I want to build more complex Parser, but I have no idea how to make it.
01:04:28 <arkeet> but your quicksort function should work the same way on any type, regardless of what the type is, as long as you are given a way to compare values of that type.
01:04:31 <raymank26> latermuse: it's much more simple problem.
01:04:33 <arkeet> i.e. as long as it has an Ord instance.
01:04:54 <enthrops> oh crap I just forgot everything about programming
01:05:27 <johnw> i wish I could do that sometimes
01:05:31 <johnw> and then learn it the right way
01:05:56 <enthrops> johnw: what's the right way?
01:06:12 <johnw> if I knew, I wouldn't be having this problem, would I?
01:07:02 <enthrops> johnw: well, I've seen people blaming their bad skills on having to learn Java first
01:07:20 <arkeet> unlearning is a valuable skill.
01:07:37 <johnw> i was just musing last night on how OO's over-emphasize on "everything is an object!" really sets you up to miss the point of category theory
01:07:38 <ion> unskill
01:07:53 <arkeet> everything is a morphism!
01:07:59 <enthrops> you kind of have to consider if it's a good idea to forget mainstream in order to learn what mostly is an academic language :)
01:08:31 <Saizan> @quote Jafet academic
01:08:31 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
01:08:46 <ion> You don’t actually forget the other languages. You become better in them, too. (Alas, also more annoyed about them.)
01:11:16 <enthrops> I'd really hope that's more than a hyped stereotype
01:11:44 <arkeet> the more annoyed part is certainly true.
01:11:47 <enthrops> I was just reading how haskell made a guy actually worse at his mainstream thing
01:12:19 <enthrops> or so he thinks
01:12:30 <arkeet> maybe he just got more annoyed at it.
01:13:37 <enthrops> http://lukeplant.me.uk/blog/posts/why-learning-haskell-python-makes-you-a-worse-programmer/
01:13:53 <enthrops> not sure what python's doing there
01:14:36 <jkarni> it's a great service we're doing to ourselves - actively seeking to become more annoyed at the languages we have to use daily...
01:14:48 <johnw> jkarni: somebody, we shall revolt
01:14:57 <johnw> "A thirsty man knows best how to find water."
01:15:03 <jkarni> johnw: someday?
01:15:39 <arkeet> wake me up when we write drivers in haskell
01:15:42 <ion> I only became adequate at separating the IO stuff from the pure stuff in other languages upon learning Haskell. In the past, it was difficult to get practice in that in the cultures of other languages. The semantics of Haskell’s IO also provided a good mental model about it.
01:15:45 <johnw> some people still think that not having a type checker is something new and inspiring
01:15:50 <johnw> so, maybe not just yet
01:16:37 <jkarni> saw a job post a week or so ago on hask-cafe
01:16:43 <jkarni> for a haskell-only shop
01:16:56 <jkarni> first time I heard of such a thing
01:17:31 <jkarni> before I forget, any @src equivalent for ghci?
01:17:57 <shachaf> ion: "semantics of Haskell's IO"?
01:17:59 <enthrops> Why is output a side effect btw?
01:19:08 <ion> shachaf: I mean, the difference between a -> b and a -> IO b existing in the first place.
01:20:14 <arkeet> enthrops: why wouldn't it be?
01:20:31 <enthrops> arkeet: well
01:20:55 <enthrops> arkeet: how is it impacting other code?
01:21:04 <arkeet> it's impacting the state of the word.
01:21:05 <arkeet> world.
01:21:13 <enthrops> is that a joke?
01:21:15 <arkeet> no.
01:21:43 <shachaf> arkeet never jokes.
01:21:48 <enthrops> haha I just googled that, awesome
01:22:10 <arkeet> I do, however, make many typos.
01:22:22 <johnw> enthrops: if it were not considered a side effect, how could you say that the outcome is different from not printing anything at all?
01:22:40 <arkeet> or printing twice, or printing two things in a different order, or ...
01:22:56 <enthrops> I'm decoding the sentence right now
01:23:45 <johnw> meaning that output vs. no output is different only in the side effects.  both actions have type IO ()
01:24:00 <johnw> (or IO whatever)
01:24:14 <ion> Or “effects”
01:24:24 <arkeet> I agree with ion.
01:24:35 <enthrops> I'm guessing you can't just say 'print "stuff"'?
01:24:38 <enthrops> in haskell
01:24:40 <ion> You can.
01:24:46 <ion> Run that in ghci. It’ll work.;
01:25:05 <enthrops> so we have a method 'f = print "stuff"'
01:25:09 <neutrino> but the ghci prompt is in the IO monad.
01:25:21 <arkeet> then f will have type IO ()
01:25:24 <bartavelle> with the FFI, I seem to be able to call functions, but I do not understand how to get variables
01:25:38 <arkeet> bartavelle: what do you mean by "get variables"?
01:26:04 <enthrops> I should probably read up instead of bugging you guys
01:26:08 <bartavelle> arkeet, extern VALUE rb_cObject;
01:26:23 <arkeet> global variables?
01:26:24 <bartavelle> hum
01:26:26 <bartavelle> yes
01:26:33 <arkeet> uh, I think you can.
01:26:34 <bartavelle> I believe I know what my problem is
01:26:49 <bartavelle> VALUE is usually a pointer in the ruby library, except when it isn't :)
01:27:20 <johnw> arkeet: I think a global int just has type IO CInt
01:27:28 <arkeet> johnw: no, it's a Ptr
01:27:36 <johnw> ah, thanks
01:27:40 <bartavelle> Ah it's a Ptr ?
01:27:46 <bartavelle> hum
01:27:47 <johnw> a pointer to the global variable's location
01:28:17 <arkeet> foreign import ccall "&" bar :: Ptr CInt
01:28:38 <arkeet> http://www.haskell.org/onlinereport/haskell2010/haskellch8.html
01:28:58 <bartavelle> ah thx
01:29:08 <arkeet> or presumably "&blah" if it was called blah in C.
01:29:14 <dibblego> colah: yo
01:30:05 <ion> bartavelle: I’d also recommend looking at bindings-dsl. It provides very nice macros for FFI.
01:30:49 <bartavelle> ion, will take a look then
01:31:15 <johnw> ion: and c2hsc, for getting started with bindings-dsl from existing C code
01:32:31 <arkeet> I don't know why I'm still awake.
01:33:24 <johnw> gotta lift you into the Dream monad
01:34:43 <bartavelle> arkeet, thanks, it works now
01:34:49 <arkeet> cool
01:43:00 <enthrops> Is there a good reason why haskell uses monads for side effects, as opposed to just in-code directives which mark which function is supposed to be pure and which is not
01:43:19 <centrinia> enthrops, because Haskell is always pure.
01:43:36 <enthrops> like, are monads more reliable / bug-free than the imperative approach?
01:43:49 <enthrops> centrinia: I get that, but is there a rationale for that?
01:44:55 <arkeet> purity is the point of haskell, really.
01:44:57 <arkeet> well, one of the points.
01:44:59 <CindyLinz> I think it's more theoretically consistent. Fewer special case on the language design.
01:45:38 <arkeet> in early versions of haskell (before 1.3) there was another mechanism for IO, but it was pretty awful.
01:46:05 <enthrops> if a language has means to do side effects, isn't it unfair to call it pure?
01:46:24 <arkeet> there's nothing impure about composing IO actions.
01:46:54 <enthrops> and about executing them ie getting time or random?
01:46:55 <arkeet> you could think of a haskell program as a description of how to compose IO actions.
01:47:43 <dibblego> enthrops: haskell does not use monads for side-effects; it uses values of a type constructor (IO) to perform I/O effects, which are pure
01:47:54 <Aetherspawn> :t map
01:47:56 <lambdabot> (a -> b) -> [a] -> [b]
01:47:56 <dibblego> IO just happens to be a monad, among many other things
01:48:05 <arkeet> that is, the values are pure. although I don't know what an impure value is.
01:48:11 <dibblego> haskell does IO effects, not side-effects
01:48:45 <Aetherspawn> @pl filter (\x -> type x)
01:48:45 <lambdabot> filter type
01:48:53 <Aetherspawn> :t filter
01:48:54 <lambdabot> (a -> Bool) -> [a] -> [a]
01:49:10 <enthrops> no idea what any of that is, but thanks :)
01:49:10 <Aetherspawn> @pl filter (\x -> (type x) == 1)
01:49:10 <lambdabot> filter ((1 ==) . type)
01:49:18 <arkeet> Aetherspawn: you are welcome to use lambdabot in private. (note, use @type instead of :t in pm)
01:50:09 <arkeet> or @ty
01:50:30 <dibblego> enthrops: think of IO as a sub-language, that allows you to specify IO instructions that will eventually run through an "IO interpreter", which is transparent to you -- it sits outside the main function and interprets the IO language
01:50:51 <arkeet> (main isn't a function)
01:51:14 <enthrops> ok a really stupid example
01:51:22 <enthrops> we have a connection to a db
01:51:39 <dibblego> main isn't a function, it is a value
01:51:46 <enthrops> and we have a function that reads a value from it
01:51:48 <dibblego> (all haskell functions accept one argument)
01:52:04 <enthrops> another function (with io or monad or I don't know what) changes state of db
01:52:10 <arkeet> http://stackoverflow.com/a/13538351 is a good read
01:52:25 <enthrops> then that first function will not be referentially transparent
01:52:29 <arkeet> although requires some thinking
01:52:32 <enthrops> but it probably wasn't in the first place
01:53:09 <dibblego> enthrops: whether or not it is a function is entirely up to how you model it — independent of what it does
01:53:14 <enthrops> I suspect you can't just read from a db with a library call right?
01:53:31 <dibblego> enthrops: e.g. I write pure-functional interpreters in lesser languages all the time — using the free monad usually
01:54:34 <dibblego> enthrops: reading from a database may or may not be as pure-functional as adding all the integers in a loop — some may do it by updating a global variable, others may use foldMap — it's entirely up to the model
01:55:20 <dibblego> in that stackoverflow link posted is this example of IO: data IO a = Done a | PutStr String (IO a) | GetLine (String -> IO a) | ...
01:55:23 <enthrops> there are globals?
01:55:32 <dibblego> this "way of thinking" is a specialisation of the free monad
01:55:42 <enthrops> ok, I really need to read up
01:55:52 <dibblego> enthrops: I just mean in general, but yeah, you can emulate global variables in haskell (it's unusual though)
01:56:07 <amosr> dibblego: I believe a friend of yours did a talk on the free monad last fp-syd. it was enlightening
01:56:08 <arkeet> can but shouldn't
01:56:26 <dibblego> enthrops: the point is, there is nothing extra-special about reading from a database" that somehow means that referential transparency appears or disappears
01:56:47 <dibblego> amosr: yeah Runar probably, and he has published a paper on it — also, I should be at fp-syd this Wednesday
01:57:06 <amosr> hmm. mark hibberd?
01:57:08 <dibblego> it's Wednesday right? I am flying to Sydney in the morning
01:57:10 <enthrops> dibblego: see, I can't understand that because in between your reads something might have changed data in the db
01:57:17 <dibblego> oh yeah Mark and I work together closely
01:57:17 <amosr> eek it isn't this wednesday, it's the week after :-(
01:57:38 <amosr> dibblego: it's usually the nth wednesday but it's pushed back a week this month
01:57:48 <dibblego> enthrops: yes, but you can say that about *any* program — there is nothing super-special about IO that changes anything — just model it pure functionally
01:58:03 <dibblego> amosr: oh boo, Jed told me it was on Wednesday so I said I should make it
01:58:08 <amosr> ah, the 29th
01:58:18 <dibblego> I will be in Sydney Hospital on that day
01:58:35 <amosr> ohh. is everything still progressing?
01:58:38 <jkarni> dibblego: what do you have in mind when you say you can emulate global variables in haskell?
01:59:13 <enthrops> is derivation a kind of higher order function?
01:59:13 <dibblego> enthrops: with IO, the language, you specify the IO instructions to perform — this is different to "updating the database", but rather, "specifying the IO program to the interpreter that updates the database"
01:59:26 <dibblego> amosr: yes progressing, long crappy story
01:59:43 <dibblego> jkarni: e.g. x :: STRef Int -- "global Int"
02:00:01 <amosr> I've heard bits. awful
02:00:03 <noteventime> enthrops: Depends a little on the setting, but in general I'd say yes
02:00:33 <dibblego> amosr: I have ended up being diagnosed with a condition that affects athletes only and can only be diagnosed by two people in Australia — took me 5.5 years to find them
02:00:33 <enthrops> ok, I'm leaving now to read
02:00:36 <enthrops> thanks everybody
02:00:42 <noteventime> (in the sense that you can consider it as a function between function spaces)
02:02:41 <jkarni> but doesn't that still have a "run" function (runST)?
02:03:40 <dibblego> sure, runST is safe
02:03:52 <dibblego> it's the rank-2 type that keeps it safe
02:05:44 <jkarni> I was briefly thinking about what it would take to really go all out in mimicking global variables
02:05:53 <jkarni> earlier today
02:06:13 <dibblego> I have used ST to demonstrate "looping" to people who are used to imperative languages
02:07:09 <dibblego> e.g. https://gist.github.com/tonymorris/5607151
02:07:13 <jkarni> wrapping everything in, say a runState or runST or whatever, but without making lifts necessary everywhere
02:07:30 <jkarni> but then I thought that that's kind of what ghci does
02:07:48 <dibblego> well ghci treats IO a bit differently
02:08:00 <dibblego> but ST doesn't get that treatment, even with runST — it stays pure
02:08:02 <jkarni> yeah, I'm curious to know more about that
02:08:16 <dibblego> there are some unsafe calls in Control.Monad.ST though
02:14:35 <bitonic> dibblego: what do you mean with ‘ghci treats IO a bit differently’?
02:15:37 <dibblego> it will interpret IO actions rather than "Show" them
02:16:40 <bitonic> fair enough
02:39:40 <aristid> johnw: pong?
02:40:09 <johnw> aristid: hello!
02:43:09 * hackagebot compdata 0.6.1.3 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.6.1.3 (PatrickBahr)
02:58:09 * hackagebot wai-routes 0.2.4 - Typesafe URLs for Wai applications.  http://hackage.haskell.org/package/wai-routes-0.2.4 (AnupamJain)
03:04:47 <mekeor> how would this picture/diagram look for foldl1?: http://www.haskell.org/wikiupload/5/5a/Left-fold-transformation.png
03:04:56 <mekeor> just replace z with []? O.o
03:06:33 <mekeor> no. – ?
03:08:13 <tem_> pls, provide some sample programs that use Data.ConfigFile to parse config files. I would like a small sample that is larger than the sample given at the Haskell.org
03:10:01 <mekeor> i'm not sure whether ConfigFile is even up-to-date. it was last uploaded in 2011 and was built using ghc-7.2... :/
03:10:51 <mekeor> also, tem_, there are usage examples on http://hackage.haskell.org/packages/archive/ConfigFile/latest/doc/html/Data-ConfigFile.html#g:10 ;) :P :)
03:14:03 <tem_> the "Combined Error/IO Monad Usage" doesn't work unless you change the "empty" to "emptyCP" and then it doesn't tell us how to initialize variables from config data, It would be great to see an example that illustrate variable (data) initialization from config file.
03:14:36 * mekeor is sorry for having no idea :(
03:15:49 <tem_> mekeor: what is a better alternative to Data.ConfigFile?
03:16:45 <mekeor> uhm, i don't know either. – does anybody know?
03:16:59 <bitonic> what’s the best way to create a ‘blaze-builder’ Builder from a ‘text’ Builder?
03:17:24 <jfischoff> mekeor: replace z with 1 and slide over all the numbers.
03:17:27 <mekeor> tem_: what is http://hackage.haskell.org/package/configurator ? maybe?
03:17:36 <mekeor> jfischoff: aah i see cool :)
03:19:30 <mekeor> tem_: http://stackoverflow.com/a/4617695
03:21:56 <Zenol> Hi, are there a beautiful way to combine a -> S -> b and S -> Maybe a looking at (->) S as a monade? (So combine a -> N b and N (Maybe a) ) ?
03:23:19 <tem_> mekeor: great, thanks.
03:32:03 <mekeor> tem_: :)
03:38:15 <merijn> hpaste is down? :(
03:53:10 * hackagebot iptables-helpers 0.5.0 - iptables rules parser/printer library  http://hackage.haskell.org/package/iptables-helpers-0.5.0 (EvgenyTarasov)
03:54:57 <rbeer> i'm a haskell novice, and am having difficulty compiling this simple pipes based tcp echo server: http://hpaste.org/88202
03:55:30 <rbeer> i found this code online from a recent reddit discussion.
03:59:09 <Reite> I want to make a program where the user can create arbitrary mappings between records so that they can be converted to each other. Im thinking the compiler could help my typecheck the mappings, but I have no idea how I would go about doing this at runtime. Any hints?
04:07:05 <Saizan> rbeer: check ghc-pkg list pipes, it looks like you've more than one version installed
04:07:33 <Saizan> rbeer: you want to keep only the one pipes-network uses
04:19:02 <rbeer> Saizan: that was it - thank you very much.
04:25:21 <exicer> How long does it take to get "used" to programming in Haskell, would you say?
04:25:41 <exicer> I've been playing around with tutorials for a while, but don't feel like I'm even close to being able to make a useful program
04:26:55 <Taneb> exicer, have you tried just diving in and trying to write a program?
04:27:21 <Taneb> It doesn't matter if it really sucks, the people here would be more than happy to help you improve
04:27:57 <exicer> Taneb: That is what I'm thinking of doing today - however, I don't really get I/O, which is a bit of a problem
04:28:08 <exicer> Maybe I'll just go over the IO in lyah again
04:28:40 <bitonic> exicer: you can write many useful programs without touching IO
04:28:45 <bitonic> just code and ghci
04:29:06 <bitonic> I don’t think I used IO for my first 2 months of Haskell lol.  maybe I used ‘print’.
04:29:16 <exicer> bitonic: I suppose I mean useful in the sense of being able to complete a project I've been thinking of - most of which involve webscraping and machine learning
04:29:25 <Saizan> http://www.haskell.org/haskellwiki/Introduction_to_IO
04:29:39 <bitonic> exicer: well, yeah, but that might be frustrating as a first program.
04:29:49 <bitonic> I’d gain confidence writing smaller things first
04:30:17 <exicer> bitonic: For stuff like project euler it's perfect
04:30:23 <bitonic> exicer: yeah exactly
04:30:57 <merijn> *queue PE hate*
04:31:00 <exicer> bitonic: It's just so small in focus when you compare it to eg python, where you can basically start making "real" programs from day one :P
04:31:02 <merijn> @where exercises
04:31:02 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
04:31:30 <merijn> The last two links make for better practice fodder than Project Euler, as they tend to be more like "real" programs
04:31:49 <exicer> merijn: Maybe I'll have a go then
04:31:57 <Taneb> I found rosalind.info to be quite nice for programming challenges
04:32:27 <merijn> r/dailyprogrammer even has them colourcoded by difficulty
04:33:51 <exicer> I guess it is just frustrating when you are a reasonably experienced imperative programmer - having to step back to toy problems and so on
04:36:41 <Aetherspawn> lol I honestly suggest you dont try something too deep for your first project
04:36:55 <Saizan> exicer: yeah, but it's normal, it's a very different paradigm and it's going to take a while
04:37:05 <Aetherspawn> a parser or something is a great way to learn about all the useful operators haskell has to offer.
04:37:50 <exicer> Can you guys at least give me the hope that, 6 months down the line, I will be shaking my head at ever thinking of using another language? :p
04:38:38 <DMcGill> that's where I am
04:39:02 <merijn> exicer: Yes
04:39:10 <DMcGill> so there's at least anecdotal evidence for it ;)
04:39:36 <Saizan> exicer: 9 months and you'll start wanting to use even more esoteric ones :)
04:39:47 <Saizan> fsvo esoteric
04:39:59 <merijn> exicer: I have to say it took me quite a while (couple of months after understanding the basics) before I was productive in haskell, but now that I am productive I'm much more productive than I used to be
04:40:20 <exicer> merijn: Good enough for me.
04:40:34 <exicer> I guess I'll grab some food, and dive into these toy problems.
04:40:53 <bitonic> Saizan is right.  it’s bad.
04:41:09 <bitonic> you might even get into maths and such
04:41:25 <bitonic> Haskell is one hell of a gateway drug to many things
04:41:25 <exicer> bitonic: Well I'm pretty familiar with applied maths, but pure stuff freaks me out
04:41:33 <exicer> bitonic: Maybe this will change..
04:42:08 <bitonic> exicer: I was relatively uninterested before, Haskell got me really into various subjects
04:42:14 <bitonic> Haskell and this channel :)
04:42:38 <exicer> Hehe
04:43:08 <DMcGill> I studied maths and Haskell seperately, probably the biggest initial thing that I liked was that list comprehensions are so much like set notation
04:43:26 <DMcGill> rather than mess around with loops I could just define what things WERE
04:43:41 <DMcGill> i.e. denotationally
04:44:37 <bitonic> well list comprehensions desugar to a rather loopy thing.  but it’s very nice sugar
04:44:45 <DMcGill> > [ x^2 | x <- [1..5], even x]
04:44:47 <lambdabot>   [4,16]
04:44:58 <ryantanjunming> Hi, asking a CS question here, im trying to make a priority queue and onto the more Maths side. whats the best way to rank xy cordinates are clustered together AND closer to origin?
04:45:14 <DMcGill> I know but the backends don't really matter to somebody learning the language, just the syntax
04:45:31 <bitonic> yeah, it’s nice syntax.
04:46:57 <arnsholt> @type <*>
04:46:59 <lambdabot> parse error on input `<*>'
04:47:12 <DMcGill> :t (<*>)
04:47:14 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
04:47:39 <DMcGill> arnsholt: (<*>) is the normal name for it, <*> is the infix version
04:47:47 <arnsholt> Oh, derp. Thanks =)
04:48:04 <DMcGill> i.e. `(<*>) mf mx' vs `mf <*> mx'
04:48:28 <arnsholt> Yeah. I forgot about operators needing parens
04:48:29 <DMcGill> all infix functions in Haskell are like this, and you can define your own in the same wat
04:48:32 <DMcGill> way*
04:56:26 <darkapp> hey
04:57:05 <DMcGill> darkapp: hey
04:57:17 <darkapp> so wats this channel about?
04:57:25 <darkapp> stumbled here on a /list
04:57:46 <DMcGill> the programming language Haskell
04:57:50 <DMcGill> @where Haskell
04:57:50 <lambdabot> http://haskell.org
04:58:04 <darkapp> whats it used for?
04:58:21 <DMcGill> same things as every other programming language
04:58:41 <darkapp> lol, well lots of languages serve more specific purposes
04:58:53 <darkapp> gaming, webdesign, etc etc etc
04:59:08 <darkapp> i know c++ and python myself
04:59:18 <darkapp> (not expertly btw)
05:00:00 <DMcGill> I'd say that most languages are general purpose and only a very few are actually designed for a specific task
05:00:24 <darkapp> ok
05:00:48 <DMcGill> if you're interested in an introduction to Haskell, check out
05:00:51 <DMcGill> @where lyah
05:00:51 <lambdabot> http://www.learnyouahaskell.com/
05:01:00 <darkapp> ya sure
05:01:21 <darkapp> im a student, so probaly good to get general purpose knowledge of as many used languages as possible
05:01:28 <DMcGill> it's very different from C++, and some of python's more functional features like list comprehensions were inspired by Haskell
05:01:51 <darkapp> does it compile, or is it like python?
05:02:06 <DMcGill> compiled, and also strong static typing
05:02:21 <DMcGill> unlike python
05:02:45 <darkapp> is there a name for when error messages dont show until you actually need that line?
05:02:53 <DMcGill> the most common compiler also has an interactive mode though
05:03:02 <DMcGill> there is, but I wouldn't recommend using it
05:03:14 <darkapp> darkapp> is there a name
05:03:22 <darkapp> highlight on the name part
05:03:28 <RoboTeddy> just learning haskell; read about functors; trying to fold up a list of functors; what am I doing wrong?: foldl (\a acc -> fmap acc a) id [(+3), ((-)10), (*2)] $ 2
05:04:06 <DMcGill> after all, surely it's better to know ahead of time that that line is wrong. The name of that is dynamic typing, and you can enable it in Haskell by compiling with '-fdefer-type-errors'
05:04:16 <merijn> :t foldl (\a acc -> fmap acc a) id
05:04:17 <lambdabot> [a -> a] -> a -> a
05:04:33 <darkapp> arguable, but i generally agree
05:04:41 <merijn> :t foldl (\a acc -> fmap acc a) id [(+3), ((-)10), (*2)]
05:04:42 <lambdabot> Num a => a -> a
05:04:51 <merijn> > foldl (\a acc -> fmap acc a) id [(+3), ((-)10), (*2)] 2
05:04:54 <lambdabot>   10
05:05:04 <DMcGill> RoboTeddy: what's the error you get?
05:05:32 <RoboTeddy> No instance for (Functor ((->) a0))
05:05:32 <RoboTeddy>       arising from a use of `fmap'
05:05:40 <merijn> RoboTeddy: Looks right to me
05:05:44 <merijn> RoboTeddy: oh!
05:05:56 <merijn> RoboTeddy: You don't have the Functor instance imported :)
05:06:04 <DMcGill> is there a module to import to get Function (->)?
05:06:05 <merijn> I forgot where it's defined, though
05:06:15 <quicksilver> Control.Monad.Instances
05:06:27 <DMcGill> that's exported by Control.Monad right?
05:06:27 <RoboTeddy> Oh. so, it doesn't know that functions are in the Functor typeclass, and doesn't have the fmap implementation for functors?
05:06:42 <RoboTeddy> * for functions
05:06:45 <quicksilver> precisely.
05:06:59 <RoboTeddy> gotchhhhha. thanks. haskell is bending my mind in fun ways :) thanks
05:07:07 <quicksilver> :)
05:07:18 <merijn> Control.Applicative exports it, at least
05:07:26 <darkapp> just curious, do u guys know if c is still commonly used?
05:07:31 <merijn> Control.Monad probably too
05:07:35 <merijn> darkapp: Yes
05:08:08 <darkapp> know any good tutorials, like books or torrents or something
05:08:16 <darkapp> got some free time over the summer
05:08:24 <darkapp> might as well be productive
05:08:44 <DMcGill> surely ##c would be a better place to ask? ;)
05:08:59 <darkapp> gotcha
05:09:14 <arnsholt> A monady question: Are "monad" and "applicative functor" equivalent, or is it just that Monad implies Applicative and Functor?
05:09:28 <merijn> arnsholt: The latter
05:09:54 <merijn> arnsholt: Any monad is (in the theoretical sense, it's not enforced by the language/libraries) an applicative and a functor, but not the other way around
05:09:55 <arnsholt> Good to know. Thanks
05:10:22 <raid> im trying to install zeno for ~2h but it always fails, http://sprunge.us/fHCQ someone got an idea?
05:10:23 <savask> Why doesn't haskell demand functor instance for ever monad then?
05:10:31 <savask> *every
05:10:34 <arnsholt> Yeah, intuitively, that's what I thought made sense (no need for a new term if A & B is sufficient)
05:10:51 <DMcGill> savask: it's a thorny issue. In short, it should but changing it will be a huge pain
05:10:56 <magicman> Hysterical raisins.
05:11:06 <arnsholt> But intuition isn't always right =)
05:11:08 <merijn> arnsholt: You can see this, for example in fmap f x = x >>= return . f
05:11:14 <merijn> pure = return
05:11:25 <savask> DMcGill: Hmm, something like a history mistake? :-P
05:11:30 <merijn> and you can implement <*> using >>= too
05:11:36 <DMcGill> pretty much, yes
05:11:45 <arnsholt> merijn: Right, right. That makes sense
05:11:52 <DMcGill> some efforts are being made to change it
05:12:13 <savask> Also as I remember every monad is a monoid
05:13:07 <savask> And things like MonadPlus look weird to me - why don't just make every MonadPlus monad a monoid...
05:13:21 <DMcGill> I'm not so sure about that savask, but I'm no expert
05:13:28 <DMcGill> consider Map for example
05:13:57 <savask> DMcGill: A monoid but not a monad, right?
05:14:03 <DMcGill> I think so
05:14:19 <savask> Well, I meant that if it's a monad, it's a monoid as well.
05:14:33 <savask> That doesn't work either way (un)fortunately :-P
05:14:37 <DMcGill> ah, consider IO?
05:14:48 <savask> Hmm
05:15:10 <DMcGill> definitely an applicative functor, not so sure about the monoid
05:15:20 <savask> DMcGill: IO is a foul example xD But consider mzero to be a useless operation which makes nothing.
05:16:56 <DMcGill> I'm looking it up, and I'm not convinced that Monoid m => Monad m
05:17:02 <DMcGill> look at http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem for example
05:17:15 <DMcGill> monad is an example of a monoid
05:18:11 <savask> So? A monad is an example of monoid, that's it.
05:18:29 <k00mi> in the haskell sense, a type m can't be Monad and Monoid at once, since the kind wouldn't match up, but MonadPlus is basically Monoid for kind * -> *
05:19:00 <Taneb> k00mi, I thought is was a sort of Monoid with return/(>=>)
05:19:09 <Taneb> And that's why
05:19:12 <DMcGill> that makes more sense
05:19:34 <Taneb> Except that's not a Monoid
05:19:46 <k00mi> Taneb: the binary function would be join
05:19:50 <savask> k00mi: Can you, please, explain the kind thing? Maybe is a Monad and Monoid.
05:20:10 <Taneb> savask, "Maybe a" is a monoid for any a
05:20:15 <Taneb> No
05:20:19 <Taneb> If a is a monoid
05:20:25 <Taneb> I'll start again
05:20:27 <k00mi> Taneb: if a is semigroup
05:20:29 <quchen> Monoid a => Monoid (Maybe a)
05:20:32 <quchen> This. :-)
05:20:42 <k00mi> Semigroup a is eneugh :)
05:20:48 <Taneb> k00mi, the definition in Data.Monoid uses Monoid, but theoretically, yeah
05:20:49 <savask> Oh
05:20:57 <k00mi> savask: kinds are like the next thing above types
05:21:32 <k00mi> savask: "Maybe" is not a type, it's like a function that expects a type a, then gives you a type Maybe a
05:21:37 <savask> k00mi: Well, I understand that a bit, but phrase "kind won't match up" confuses me.
05:21:40 <k00mi> so it has kind * -> *
05:22:06 <k00mi> savask: Monads always have kind * -> *, but Monoids have *
05:22:39 <savask> Right... That's why you apply Maybe to a monoid a in it's Monoid instance.
05:22:43 <DMcGill> Monad expects a type with kind (* -> *), that's why it's "instance Monad Maybe where". Monoid expects a type with kind *, that's why it's "instance Monoid (Maybe a)"
05:22:46 <k00mi> savask: right
05:22:49 <DMcGill> for some value of a
05:25:46 <savask> Hmm, it looks like Maybe instances for Monoid and MonadPlus are different.
05:26:47 <Taneb> savask, I think Maybe's MonadPlus is the First monoid
05:27:19 <Taneb> > getFirst $ mconcat [First Nothing, First "hi", First "bye", First Nothing]
05:27:19 <tranceholic> hi, id like someone's help...
05:27:21 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a0'
05:27:22 <lambdabot>              with actual...
05:27:29 <Taneb> tranceholic, ask away
05:28:01 <k00mi> Taneb: First (Just "hi")
05:28:03 <tranceholic> i pasted on hpaste 88205
05:28:18 <savask> Taneb: First monad? Does it output only the first thing?
05:28:24 <Taneb> > getFirst $ mconcat [First Nothing, First (Just "hi"), First (Just "bye"), First Nothing]
05:28:26 <lambdabot>   Just "hi"
05:28:30 <Taneb> savask, First MonadPlus
05:28:32 <savask> Oh
05:28:50 <Taneb> > Nothing `mplus` Just "hi" `mplus` Just "bye" `mplus` Nothing
05:28:52 <lambdabot>   Just "hi"
05:29:43 <savask> What a useless monoid xD
05:29:57 <Taneb> savask, it's used in Lens quite a lot
05:30:00 <Taneb> :t preview
05:30:02 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
05:30:28 <savask> Ah. After the word "lens" it is the dark matter for me.
05:30:41 <Taneb> I think it's one of the few Monoids that's useful because of its Monoid instance
05:30:52 <Taneb> Sum Int is pretty boring
05:31:50 <savask> Well, imagine an ideal world where (++) is mappend
05:32:04 <savask> map is fmap, etc
05:32:16 <savask> Everything would be so logic, yet complicated.
05:32:20 <savask> *cal
05:32:45 <Taneb> (++) == mappend == (<>) == mplus
05:32:52 <Taneb> concat == join, concatMap == (>>=)
05:33:06 <Taneb> I think tails == Data.Functor.Extend.duplicated
05:33:11 <Taneb> :t duplicated
05:33:13 <lambdabot>     Not in scope: `duplicated'
05:33:13 <lambdabot>     Perhaps you meant one of these:
05:33:13 <lambdabot>       `replicated' (imported from Control.Lens),
05:33:16 <Taneb> Bah
05:33:35 <Taneb> A lot of list functions also exist in other classes
05:34:03 <Taneb> Like traverse, sequence_, forM, foldr, etc
05:34:33 <Taneb> What makes the [] type really itself, isn't its Monoid instance, though
05:34:40 <Taneb> It's the fact that it has (:) and []
05:34:42 <savask> It's like in math, all those things get more unified.
05:34:56 <savask> Hmm, abstract, I mean.
05:35:03 <Taneb> savask, have you seen packages such as classy-prelude?
05:35:10 <savask> No.
05:35:19 <savask> I suppose it's the thing I suggested? :-P
05:36:07 <Taneb> @hackage classy-prelude
05:36:07 <lambdabot> http://hackage.haskell.org/package/classy-prelude
05:36:10 <Taneb> Give it a gander
05:37:13 <savask> I'm not "the user who knows haskell well" :-)
05:37:51 <stulli> Is classy-prelude the same as custom-prelude?
05:37:59 <Taneb> No
05:38:10 <Taneb> There are a whole bunch of similar packages
05:38:13 <haasn> the Maybe monoid is in use in my favorite version of fizzbuzz
05:38:24 <haasn> fizzBuzz x = fromMaybe (show x) $ ["fizz" | x `rem` 3 == 0] <> ["buzz" | x `rem` 5 == 0]
05:38:50 <Taneb> To quote myself,
05:39:01 <Taneb> @quote prelude alternative
05:39:01 <lambdabot> No quotes for this person. Your mind just hasn't been the same since the electro-shock, has it?
05:39:05 <Taneb> @quote prelude
05:39:05 <lambdabot> psychobot says: Prelude.Enum.().succ: bad heart in scope:
05:39:10 <Taneb> That's not me
05:39:16 <haasn> @quote prelude.alternative
05:39:16 <lambdabot> No quotes match. You speak an infinite deal of nothing
05:39:26 <haasn> @quote Taneb prelude
05:39:26 <lambdabot> Taneb says: I'm doing the thing that every bored haskeller does one day and rewriting Prelude
05:39:30 <Taneb> That's the one
05:39:53 <Taneb> That would have been so much awesomer if I could have done it on my first try, or even at all
05:39:58 <Taneb> haasn++
05:40:36 <haasn> as awesome as quoting oneself can get, anyhow ;)
05:41:02 <stulli> Taneb: Heh, i see. Just today i used a function from custom-prelude, that's why i was asking.
05:41:23 <Taneb> haasn, :P
05:41:30 <Taneb> Anyway, I'm gonna get some lunch now
05:41:31 <Taneb> Bye
05:41:32 <Taneb> !
05:54:16 <swissarmyspoon> anyone have an example usage of a quantity semaphore?
05:54:42 <swissarmyspoon> sorry I meant, anyone have an example usage of a counting/general semaphore?
05:59:29 <dcoutts> swissarmyspoon: there's one in Control.Concurrent.QSemN
05:59:47 <dcoutts> oh usage, sorry, misread you
06:02:19 <dcoutts> swissarmyspoon: the cabal-install --jobs code uses a QSem
06:02:34 <dcoutts> see cabal-install/Distribution/Client/JobControl.hs
06:03:01 <dcoutts> and then how the JobLimit is used in cabal-install/Distribution/Client/Install.hs
06:03:57 <swissarmyspoon> where can i see cabal-install
06:04:08 <dcoutts> cabal unpack cabal-install
06:10:59 <swissarmyspoon> could you explain how it is used?
06:11:14 <DMcGill> "cabal install <libname>"
06:11:39 <DMcGill> after installing Haskell platform. Or do you mean the cabal-install library?
06:11:48 <dcoutts> swissarmyspoon: it's used to make sure no more than a certain number of tasks are doing particular things at once
06:12:25 <Taneb> I wonder how hard it would be to write an MMO in Haskell
06:12:37 <dcoutts> swissarmyspoon: so when the --jobs=3 for example, the semaphore is initialised to 3, and each task that wants to do an install grabs the semaphore (decrementing it by one)
06:13:02 <Taneb> ...probably about as hard as any other language
06:13:06 <dcoutts> swissarmyspoon: when the semaphore hits 0 then no other threads can take it, until one of the ones doing an install finishes
06:13:40 <DMcGill> Taneb: so really unfeasably hard
06:13:42 <dcoutts> swissarmyspoon: you see the design there has potentially loads of threads ready to run a build/install at once, but we don't want to allow too many to run
06:14:01 <swissarmyspoon> why dont we want to run to many at once?
06:14:03 <DMcGill> ah, I see I missed most of this cabal-install discussion, sorry
06:14:46 <dcoutts> swissarmyspoon: think about it, you might have say 2 cores and 4 GB ram, each build/install might take 1 core and 2 GB ram...
06:14:57 <dcoutts> swissarmyspoon: why not run 10 of them at once...
06:15:08 <dcoutts> swissarmyspoon: ever used make -j ?
06:15:36 <swissarmyspoon> no
06:15:50 <dcoutts> swissarmyspoon: a semaphore is just perfect for allowing at most N threads to do something at once
06:15:54 <swissarmyspoon> dcoutts: yes why not run 10 at once?
06:16:05 <dcoutts> swissarmyspoon: you don't have enough resources to do that
06:16:10 <swissarmyspoon> ok
06:16:15 <geekosaur> if you have only 2 cores, that could be very painful
06:16:20 <Taneb> DMcGill, I could imagine some parts being easier in Haskell, some parts being a lot harder
06:16:38 <DMcGill> STM certainly seems like it would help
06:16:46 <swissarmyspoon> because each thread has some overhead?
06:17:22 <dcoutts> swissarmyspoon: it's not the thread itself, it's that that thread will go and invoke a rather expensive operation: compiling/building and installing a package
06:18:00 <swissarmyspoon> ok, i c. could you have an example of an embedded systems where we would like to limit the use of a resource. or only have N of a resource available?
06:18:05 <dcoutts> swissarmyspoon: so this example the resource limit is slightly fuzzy (cpu & memory), in other examples you might have a clear fixed sized resource collection, e.g. you might have 10 db connections
06:18:48 <dcoutts> physical bits of hardware (e.g. comms links) that can only be used for one thing at once
06:18:55 <dcoutts> where you have some number of them
06:19:37 <dcoutts> swissarmyspoon: do you have an example in mind>
06:19:40 <dcoutts> >/?
06:30:30 <swissarmyspoon> dcoutts: i want to come up with an example. preferrably for embedded systems which is my main study
06:32:46 <Garyuutensei> @pl \x y -> show x ++ "\t" ++ y
06:32:46 <lambdabot> (. ('\t' :)) . (++) . show
06:39:35 <savask> How do I link hmatrix statically? I provide -static -optc-static -optl-static -optl-pthread options, but it throws these errors: http://hpaste.org/88204
06:39:48 <DMcGill> Garyuutensei: look at
06:40:06 <DMcGill> > intersperse ' ' ["asd", "sdf"]
06:40:07 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
06:40:08 <lambdabot>              with actual type...
06:40:26 <DMcGill> > intercalate " " ["asd", "sdf"]
06:40:28 <lambdabot>   "asd sdf"
06:40:34 <danbst> Hello huys! Not on Haskell, but on math question. How to compute modulo of inverse numbers? E.g. 3^(-1) `mod` 5 = ?
06:40:52 <danbst> *guys, of course
06:41:07 <savask> > intersperse " " ["asd", "sdf"]
06:41:09 <lambdabot>   ["asd"," ","sdf"]
06:41:37 <Garyuutensei> DMcGill: I'm not using lists so I have to use a fold instead
06:41:38 <Eduard_Munteanu> huys == haskell guys? :)
06:42:05 <swissarmyspoon> lets say you have an embedded system and using sockets. is a socket expensive some way. like would be reasonable to only be handle say 4 sockets/connections at onc eso youd use a semaphore to restrict the nbr of threads? probably you wouldnt solve it that wya though? you just wouldnt spawn if >MAX_THREADS.
06:42:11 <Eduard_Munteanu> danbst: how do you define that for non-integer numbers?
06:42:33 <haasn> Eduard_Munteanu: I think that's his question
06:43:13 * hackagebot iptadmin 1.3.4 - web-interface for iptables  http://hackage.haskell.org/package/iptadmin-1.3.4 (EvgenyTarasov)
06:43:18 <dcoutts> swissarmyspoon: it'd make sense if you needed to use more than 4 threads at once, but only had 4 sockets
06:43:21 <DMcGill> isn't 3^(-1) in modulo 5 arithmetic an x such that x*3 == 1
06:43:23 <danbst> Eduard_Munteanu: here - http://en.wikipedia.org/wiki/Modulo_operation#Common_Misconceptions
06:43:23 <haasn> well, based on the definition I know, it would be 1/3
06:43:35 <DMcGill> i.e. 2*3 = 6 = 1 modulo 1
06:43:46 <DMcGill> modulo 5 I mean
06:44:17 <dcoutts> savask: so your question is really how do you statically link the various C/Fortran libs that hmatrix uses (since hmatrix itself will be statically linked anyway by default)
06:44:36 <DMcGill> modulo arithmetic is a bit tricky, I'd try ##math danbst
06:44:41 <dcoutts> savask: and as you found, trying to make a fully static lib on linux isn't really recommended, e.g. you don't want to statically link glibc
06:44:51 <Eduard_Munteanu> danbst: hm, in that context, I think 3^-1 is the inverse of 3, such that 3 * 3^-1 = 1 (mod 5)
06:45:15 <savask> dcoutts: Unfortunately I do want, cause the person who is going to use my prog can't run it this way.
06:45:28 <DMcGill> Yes, in modulo 5 arithmetic 2 is an inverse of 3
06:45:29 <Eduard_Munteanu> So 3^-1 = 2, because 3 * 2 = 6 = 1 (mod 5).
06:45:54 <swissarmyspoon> dcoutts: wouldnt it make more sense to just chekc if a variable current_n_threads > max_threads ?
06:45:58 <dcoutts> savask: so actually this is mostly a ghc/haskell independent question, the issue is how do you statically link those system libs (e.g. if you were writing a C prog)
06:46:05 <danbst> Eduard_Munteanu: oh thanks, modulo field
06:46:08 <haasn> but also 11/3, 16/3, 21/3 ... fulfill that property
06:46:12 <haasn> oh
06:46:15 <haasn> except 21/3 > 5
06:46:33 <haasn> 21/3 = 2 mod 5
06:46:59 <dcoutts> swissarmyspoon: you misunderstand, suppose you're already running 5 threads (because not all threads need to use sockets all the time)
06:47:04 <DMcGill> the only inverse of 3 in modulo 5 is 2, I don't know how you can a) prove that in general or b) prove that for a specific n other than by brute force
06:47:05 <haasn> looks like there are three such ‘x’: 1/3, 1/2 and 2
06:47:15 <DMcGill> isn't this the basic of encryption schemes?
06:47:17 <savask> dcoutts: Well, probably you're right. I was hoping that someone here has managed to link it statically.
06:47:48 <dcoutts> savask: what I recommend is not trying to link *everything* statically, and just link the specific C libs that you want statically.
06:47:59 <DMcGill> see http://en.wikipedia.org/wiki/Modular_multiplicative_inverse
06:48:01 <dcoutts> savask: as you can see, glibc doesn't like static linking
06:48:26 <DMcGill> "The modular multiplicative inverse of a modulo m can be found with the extended Euclidean algorithm"
06:48:31 <savask> dcoutts: How do I do that then?
06:48:31 <Eduard_Munteanu> DMcGill: inverses are unique in groups
06:48:43 <dcoutts> savask: you can see how ghc is calling gcc to link using -v
06:48:55 <dcoutts> savask: e.g. you'll see all the -lblah -lblah flag
06:49:13 <savask> dcoutts: And then link those libs myself?
06:49:19 <Eduard_Munteanu> (actually you don't need a group, you can prove that if only some elements have inverses, I think(
06:49:21 <dcoutts> savask: that's one option
06:50:13 <danbst> DMcGill: thanks. This question is part of problem to divide 8-byte number (given by two 4-byte) by a 4-byte with only 4-byte division
06:50:21 <dcoutts> savask: the system linker doesn't make it all that easy to selectively link some statically, the gcc -static flag is a hammer that tries to do them all
06:51:19 <dcoutts> savask: the typical issue is this: dynamic linking and static linking are somewhat different, dynamic linking automatically chases dependencies where as for static linking all transative deps must be linked in explicitly
06:51:43 <dcoutts> savask: so just changing from dynamic to static is not enough, all the transative lib deps have to be included
06:52:03 <dcoutts> (this is nothing to do with haskell, just how system linker works)
06:53:12 <savask> This is so complicated...
06:53:34 <dcoutts> savask: as a random example,
06:53:52 <dcoutts> look at the output of pkg-config --libs [--static] for a few C packages
06:54:09 <dcoutts> e.g. pkg-config --libs openssl  vs  pkg-config --static --libs openssl
06:54:22 <dcoutts> the latter lists extra indirect dependencies like -lz
06:55:02 <savask> Yes, it does.
06:55:05 <dcoutts> which are not needed in the dynamic case, because the openssl dynamic lib itself links to libz, but with static linking there's no such notion
06:55:41 <dcoutts> dynamic libs embed pointers to their deps, but static linking is a much older tech and doesn't have that kind of convenience
06:57:21 <phaul> I have a type synonym like type Comp a = a -> a -> Bool and I want to have a ToText instance like toText (<) = "less than". I had to enable SynonymInstances FlexibleInstances. It compiles and runs but I get scary warnings.. Is this safe / advisable at all?
06:58:12 <phaul> warning says on the instance decls that all (<), (<=) etc overlaps
06:58:26 <Eduard_Munteanu> phaul: you can't pattern-match on functions
06:58:38 <phaul> :(
06:58:39 <Eduard_Munteanu> Not sure what you actually wrote there.
06:58:43 <savask> dcoutts: So I must add all -llapack, -cblas myself?
06:59:02 <dcoutts> savask: take a look at the existing link command line
06:59:11 <dcoutts> savask: and at ghc-pkg describe hmatrix
06:59:31 <phaul> Eduard_Munteanu: ok, thanks
06:59:41 <dcoutts> savask: all the 'extra-libraries' translate into -l flags
07:00:40 <Eduard_Munteanu> > id == id id
07:00:42 <lambdabot>   *Exception: (==): No overloading for function
07:00:56 <dcoutts> savask: so you'll probably see that it does use -llapack, however I'm guessing that lapack links to other things, and those are the bits you're missing when you try linking statically
07:00:59 <Fuuzetsu> id ≡ id id
07:01:09 <savask> dcoutts: How do I write it in cabal file though? -llapack as -optl-lapack?
07:01:17 <Eduard_Munteanu> (and matching on non-inductive types translates to equality checking)
07:02:19 <dcoutts> savask: -optl, but note that that's rather fragile, will then only work for the static linking case
07:02:30 <dcoutts> savask: whole thing is just not really set up for it
07:03:29 <savask> dcoutts: Well, I included lapack, blas and gsl flags, but nothing.
07:03:41 <Eduard_Munteanu> :t let f 5 = True in f
07:03:43 <lambdabot> (Eq a, Num a) => a -> Bool
07:03:49 <savask> Same fortran errors -_- Who ever writes in fortran now.
07:05:38 <dcoutts> savask: looks like you need to link to some gcc fortran standard lib, based on _gfortran_compare_string etc
07:06:05 <savask> dcoutts: Ld says that it can't find -lgfortran.
07:06:39 <Eduard_Munteanu> savask: perhaps your distro splits that into a different package
07:07:26 <dcoutts> savask: you need to look up how this is supposed to work outside of the context of haskell: check what libs you're supposed to use and as Eduard_Munteanu says check if your distro has the static libs in separate packages
07:08:39 <dcoutts> savask: once you can get gcc dummy.c -static -llapack etc to work then getting that working with ghc will be doable
07:09:16 <dcoutts> savask: do you know that libgfortran.a is supposed to exist?
07:09:17 <Eduard_Munteanu> For binary distros it's likely they don't install static libs at all by default.
07:09:38 <dcoutts> savask: or is that just a wild guess? :-)
07:09:50 <savask> dcoutts: I don't know anything, haha
07:10:07 <savask> Well, now it doesn't swear at -lgfortran
07:10:23 <savask> But still gives errors about gfortran.
07:10:34 <bitonic> damn, I already asked this but I forgot... is there a way to refer to the local ‘Data-Dir’ instead of the ‘installed’ one (~/.cabal/...)?
07:10:56 <dcoutts> bitonic: yes, there's an env var you can use to override it
07:10:57 <bitonic> so basically I have an executable that uses the Paths_ module, and I want it to work even if I don’t install it
07:11:02 <dcoutts> right exactly
07:11:13 <bitonic> dcoutts: oh, are there any docs regarding this?
07:11:33 <Eduard_Munteanu> savask: what errors?
07:11:45 <dcoutts> bitonic: tbh, easiest reference is to look at dist/build/Paths_*, that has it in there
07:11:53 <savask> Eduard_Munteanu: http://hpaste.org/88204
07:12:03 <Peaker> did anyone ever try to enable an Applicative superclass constraint for Monad, and see how much pain ensues?
07:12:09 <savask> Eduard_Munteanu: It's a bit different now, but gfortran part is the same.
07:12:16 <dcoutts> bitonic: iirc it's pkgname_datadir
07:12:28 <bitonic> dcoutts: well in the Paths_ module all the *dir seem to be global
07:12:42 <bitonic> ah
07:12:45 <dcoutts> bitonic: but note it looks at an env var
07:12:48 <bitonic> you’re saying to manually override that?
07:12:53 <Peaker> I suspect it shouldn't be too bad -- it can be a two-stage process: A) generate (mechanically?) patches for all the packages that lack Applicative instances for their Monads  B) Add the superclass constraint
07:13:24 <dcoutts> bitonic: by setting the env var, e.g. pkgname_datadir=./thelocaldatadir/ ./dist/build/prog/prog
07:13:36 <bitonic> dcoutts: so you’re saying that I should do ‘setEnv ...’ in my executable
07:13:37 <bitonic> right
07:14:05 <dcoutts> bitonic: no no I'm not saying that, just for running it inplace in the build tree
07:14:31 <dcoutts> bitonic: if you always want to find data files relative to where the exe is then don't use the cabal paths mechanism
07:14:38 <dcoutts> so no, do not use setEnv
07:15:03 <Eduard_Munteanu> savask: did you install all the required gcc gfortran stuff? What distro is this, perhaps I can look it up?
07:15:52 <savask> Eduard_Munteanu: I have installed r-base-dev, and this is Debian Jessie.
07:15:53 <Eduard_Munteanu> I think those are some gcc-provided builtins.
07:16:29 <savask> Well, I have to go. Thanks for your pieces of advice, dcoutts and Eduard_Munteanu.
07:16:46 <bitonic> dcoutts: so you’re simply saying to set it in the shell (I was half asleep, just realised it’s an actual environmental variable...)
07:16:53 <bitonic> that’s OK actually, thanks
07:16:54 <dcoutts> bitonic: yes
07:17:07 <dcoutts> bitonic: if you had to change the code, then we'd have failed :-)
07:17:22 <bitonic> yeah :)
07:19:30 <Eduard_Munteanu> @tell savask You might need something among http://packages.debian.org/search?keywords=fortran&searchon=names&suite=testing&section=all  ... Perhaps libgfortran3? Hopefully they do provide static libs for that, but IDK.
07:19:30 <lambdabot> Consider it noted.
07:22:02 <Demos> hey, can I have generic types in a type synonym, like type config = (String, a)?
07:22:22 <Eduard_Munteanu> Demos: type Config a = (String, a)
07:22:39 <Demos> well yes, the capatalization was not important
07:22:56 <Eduard_Munteanu> Demos: notice the parameter to Config too
07:23:04 <Demos> oh hey
07:23:45 <Demos> so then I could have a string of Config () -> String
07:23:49 <Eduard_Munteanu> Otherwise, Config -> Foo == (forall a. (String, a)) -> Foo   which probably isn't what you want.
07:26:32 <Demos> now suppose I want to have a list of thses things but some configs are Config () -> Int and some are say, () -> IO ()?
07:26:58 <Demos> I suppose I would need a new data structure instead of just the list
07:27:11 <Eduard_Munteanu> Lists are collections of things of the same type.
07:28:14 <Demos> is there any type-fu I can pull to get what I want or should I just jump on some other type?
07:28:36 <Eduard_Munteanu> Well, there is, but you might do better without... what do you want to accomplish?
07:28:46 <hpc> Demos: the first solution is really to go up a level and decide what you really want to do
07:31:44 <Demos> so the idea is to have a config file written in haskell that would specify information so like [("version", 9000),("rootFolder", "/home"), ("install", installFun)]
07:31:44 <simukis_> why is Alternative [] => (<|>) = (++), and not something smarter like taking second list only if first is empty?
07:31:59 <simukis_> s/smarter/more intuitive/
07:32:17 <Demos> COBOL is intutiive!
07:34:31 <Saizan> simukis_: [] is asociated with angelic non-determinism, where you explore all the choices
07:34:42 <ion> > do a <- [0..3]; b <- [10..13]; (((a,b) <$ guard (even a)) <|> ((a,b) <$ guard (odd b))
07:34:44 <lambdabot>   <hint>:1:87: parse error (possibly incorrect indentation)
07:34:50 <ion> > do a <- [0..3]; b <- [10..13]; ((a,b) <$ guard (even a)) <|> ((a,b) <$ guard (odd b))
07:34:51 <lambdabot>   [(0,10),(0,11),(0,11),(0,12),(0,13),(0,13),(1,11),(1,13),(2,10),(2,11),(2,1...
07:35:05 <ion> Well, that wasn’t a very good example.
07:36:03 <ion> > do a <- ["foo", "bar"]; b <- ["baz", "quux"]; ((a,b) <$ guard (a == "foo")) <|> ((a,b) <$ guard (b == "quux"))
07:36:05 <lambdabot>   [("foo","baz"),("foo","quux"),("foo","quux"),("bar","quux")]
07:36:06 <enigmuriatic> how do i append a char to a string?
07:36:20 <ion> enigmuriatic: You are probably using the wrong data structure if you want to do that.
07:36:29 <Demos> enigmuriatic c:s
07:36:34 <ion> enigmuriatic: What are you trying to implement?
07:36:37 <enigmuriatic> a right
07:36:44 <ion> demos: That prepends it to the string.
07:36:51 <Demos> oh, derp
07:37:11 <Demos> you could "foo" ++ 'b':[]
07:37:28 <enigmuriatic> a function that appends any possible permutation of two letters to the end of a parameter string
07:38:06 <enigmuriatic> Demos, yeah, i was trying to use ++ and forgot that : could be used on either side
07:38:11 <dmwit> 'b':[] is a funny way to spell ['b'] which is a funny way to spell "b"
07:39:07 <dmwit> Generally speaking, though, the answer to the question "How to a append an element to a list?" is "don't".
07:39:26 <Demos> lists are singally linked right?
07:39:26 <ion> Ok, i suppose String isn’t too bad for that under certain conditions.
07:39:27 <enigmuriatic> okay, how would you implement it dmwit?
07:39:28 <dmwit> err... s/to a/do I/
07:39:32 <enigmuriatic> Demos, yeah
07:39:39 <dmwit> enigmuriatic: Implement what?
07:39:47 <enigmuriatic> a function that appends any possible permutation of two letters to the end of a parameter string
07:39:58 <ion> This isn’t homework, right? :-)
07:40:00 <enigmuriatic> returning all those possibilities in a list
07:40:01 <enigmuriatic> no
07:40:04 <enigmuriatic> ion
07:40:10 <dmwit> enigmuriatic: "don't"
07:40:24 <dmwit> (But... any permutation of two letters? There's only two permutations of two letters...)
07:40:34 <enigmuriatic> okay, well that's the problem i'm trying to solve but thanks
07:40:34 <ion> > (++) <$> pure "foo" <*> permutations "bar"
07:40:36 <lambdabot>   ["foobar","fooabr","foorab","fooarb","foorba","foobra"]
07:40:54 <enigmuriatic> i haven't learned the $ sign yet, i'll look into it though
07:40:55 <Fuuzetsu> @src permutations
07:40:55 <lambdabot> Source not found. Maybe you made a typo?
07:41:16 <mm_freak> > let append = foldr (:) . pure in append 'x' "blah"
07:41:18 <lambdabot>   "blahx"
07:41:32 <enigmuriatic> permutations isn't in the standard library from what i can tell
07:41:42 <mm_freak> enigmuriatic: Data.List
07:41:47 <enigmuriatic> neither is append
07:41:50 <dmwit> I mean, if that's really your top-level problem description, there really is nothing you can do that's better than \xs -> [xs ++ "ab", xs ++ "ba"]. But I don't believe that's really the top-level problem you're solving.
07:41:53 <Demos> dollar sign is just a way to put a ( at the $ and another ) at the end of the line
07:41:56 <Demos> essentially
07:41:59 <ion> > do { let { a = "foo" }; b <- permutations "bar"; return (a ++ b) }  -- This might be a more obvious way to put it for a beginner.
07:42:00 <lambdabot>   ["foobar","fooabr","foorab","fooarb","foorba","foobra"]
07:42:05 <Demos> <$> prolly does something else
07:42:11 <mm_freak> enigmuriatic: append is there…  you may know it with a slightly different type as (++)
07:42:21 <mm_freak> or <> or mappend or <|> or …
07:44:12 <Fuuzetsu> <$> is just applicative $
07:44:16 <Fuuzetsu> :t <$>
07:44:17 <Demos> anyone on how to represent config options as lists?
07:44:18 <lambdabot> parse error on input `<$>'
07:44:23 <Fuuzetsu> :t (<$>)
07:44:25 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:44:27 <dmwit> (I mean, what kind of boss walks into a room and says "find all the permutations of two things and append them to this string"? Even when you're your own boss you don't say stuff like that.)
07:44:29 <Guest55594> I'm a noob can someone help. How do I write something like the type (a -> m b) or (w a -> b) without any variables, like you can write (->) by itself
07:45:03 <Fuuzetsu> Guest55594: That doesn't really make sense. Can you provide an example of what you want?
07:45:03 <Guest55594> without the a or b I mean, I'd have to have m or w
07:45:21 <dmwit> Guest55594: This sounds like an XY problem.
07:45:32 <Guest55594> type Chain f q a b = (forall x y. q x y -> f x -> f y, f a -> f b)
07:45:42 <Guest55594> how do I write q for a monad or comonad
07:45:57 <Fuuzetsu> Monad q => …?
07:46:02 <copumpkin> impredicative types?
07:46:13 <Guest55594> q is like (a -> m b), f would be monad
07:46:17 <Fuuzetsu> or do you want to literally just write Monad
07:46:18 <dmwit> newtype WrapMonad m a b = WrapMonad (a -> m b)
07:46:25 <copumpkin> I think Guest55594 might want Kleisli
07:46:27 <mm_freak> Guest55594: my initial response is you can't without a newtype
07:46:28 <dmwit> aka Kleisly
07:46:29 <copumpkin> :t Kleisli
07:46:31 <lambdabot> (a -> m b) -> Kleisli m a b
07:46:31 <copumpkin> :k Kleisli
07:46:33 <lambdabot> (* -> *) -> * -> * -> *
07:46:34 <dmwit> Kleisli, I mean
07:46:48 <Guest55594> well you could with a regular aliasing type couldn't you?
07:46:59 <mm_freak> Guest55594: not really…  not the way you would like
07:47:01 <dmwit> Guest55594: No, because type aliases cannot be partially applied.
07:47:31 <Guest55594> oh yeah
07:47:41 <Guest55594> well that's annoying, it MUST be that type exactly
07:48:04 <Guest55594> so newtype can't work
07:48:07 <mm_freak> Guest55594: i don't believe you…  what's wrong with the newtype?
07:48:25 <Guest55594> Because that's used to fit the type signature of something else
07:48:36 <Guest55594> and it needs to use that type
07:48:37 <copumpkin> then that something else will need to change if you really need this
07:48:46 <Guest55594> but that something else then goes back to prelude
07:48:49 <Guest55594> eventually
07:48:55 <copumpkin> there can be interfacing layers
07:49:01 <copumpkin> this really isn't that big a deal in anything I've seen in years
07:49:14 <Guest55594> see I have this: (/>) :: (forall a b. q a b -> r a -> r b, r c -> r d) -> q d e -> (forall a b. q a b -> r a -> r b, r c -> r e)
07:49:29 <copumpkin> see, that type alone requires an extension in GHC that is unrelible
07:49:34 <copumpkin> so I don't think it's very promising
07:49:55 <Guest55594> but it works exactly the same for functors, applicatives, monads and comonads
07:50:26 <Guest55594> given the starting conditions, I just wanted to use Chain to simplify the writing of that type
07:50:40 <copumpkin> I don't see why you can't avoid relying on unpredictable behavior in GHC and not use pairs
07:50:57 <Guest55594> I suppose I could easily do anything else
07:51:10 <Guest55594> but wait just to be sure what do you mean by pairs
07:51:16 <Guest55594> do you mean the tuples? I could easily change that
07:51:28 <copumpkin> yeah, those require impredicative types
07:51:40 <Guest55594> do you have a suggestion for something else?
07:52:22 <copumpkin> data Mypair q r x y = Mypair (forall a b. q a b -> r a -> r b) (r x -> r y)
07:53:10 <Guest55594> oh wait that's also that type signature below
07:53:24 <copumpkin> and I still fail to see why you can't instantiate q to Kleisli m :)
07:53:59 <Guest55594> because it's not necessarily that
07:54:12 <Guest55594> Like it might not be a monad
07:54:16 <copumpkin> that would be true if q were a partially applied type synonym too
07:54:22 <copumpkin> q can be instantiated to anything
07:54:24 <dmwit> He means use Kleisli m when it's a monad, CoKleisli w, when it's a comonad, etc.
07:54:37 <Guest55594> oh
07:57:05 <Guest55594> wait so where are these Kleisli's
07:57:18 <dmwit> ?index Kleisli
07:57:18 <lambdabot> Control.Arrow, Control.Arrow
07:57:25 <Guest55594> oh lol
07:57:48 <dmwit> Why so redundant, lambdabot?
07:58:29 <dmwit> ?index left
07:58:29 <lambdabot> Control.Arrow
07:58:31 <dmwit> curious
07:58:46 <dmwit> Oh, I get it.
07:59:03 <dmwit> constructor + type
08:00:08 <enigmuri_> so, say you want to take all possible two-letter strings ("aa" through "zz") and return a list of them attached to a given prefix. how would you do it?
08:00:33 <Guest55594> double comprehension
08:00:34 <dmwit> ?src ShowS
08:00:34 <lambdabot> type ShowS = String -> String
08:00:35 <dmwit> perhaps
08:00:43 <copumpkin> > replicateM 2 ['a'..'z']
08:00:46 <Taneb> > ["prefix" ++ [a, b] | a <- "abc", b <- "abc"]
08:00:47 <lambdabot>   ["aa","ab","ac","ad","ae","af","ag","ah","ai","aj","ak","al","am","an","ao"...
08:00:50 <lambdabot>   ["prefixaa","prefixab","prefixac","prefixba","prefixbb","prefixbc","prefixc...
08:01:10 <Guest55594> I think copumpkin wins
08:02:53 <enigmuri_> haha thanks everyone, i had a feeling there would be all kinds of interesting solutions
08:04:02 <enigmuri_> @replicateM
08:04:02 <lambdabot> Unknown command, try @list
08:04:14 <enigmuri_> copumpkin, where do you get replicateM?
08:04:14 <Fuuzetsu> @src replicateM
08:04:14 <lambdabot> replicateM n x = sequence (replicate n x)
08:04:19 <copumpkin> Control.Monad
08:04:24 <Fuuzetsu> @hoogle replicateM
08:04:24 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
08:04:24 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
08:04:24 <lambdabot> Data.Sequence replicateM :: Monad m => Int -> m a -> m (Seq a)
08:14:42 <epta> Is there some ghc version variable to avoid import only for fresh ghc with #if or something?
08:15:57 <supki> __GLASGOW_HASKELL__
08:17:00 <haggar> Hello, let's say I have a library that supports borrowing and returning books. How do I write code that uses such a library, but supports different library implementations?
08:17:24 <Garyuutensei> Hello, I have a polymorphic type in my program (data Vec3 a = Vec3 !a !a !a) and wanted to unpack the variables. I used type families to do something similar to http://tinyurl.com/yj7nsn3 , but my program ended up being a little bit slower. Does anyone understand why this is the case?
08:17:26 <supki> epta: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#c-pre-processor
08:18:41 <epta> supki: thanks
08:19:21 <Garyuutensei> Here are the two versions btw, http://hpaste.org/88213 http://hpaste.org/88214
08:21:15 <ion> epta: MIN_VERSION_base might be useful as well. cabal generates that macro.
08:27:44 <neutrino> hi
08:28:12 <neutrino> what are some bijections that one can perform on a list of numbers, other than sorting, reversing, shuffling, and rotating?
08:28:20 <neutrino> and identity of course
08:29:43 <Eduard_Munteanu> neutrino: permutations are all the bijections you can get, for finite lists.
08:30:31 <Taneb> neutrino, adding a constant to each element?
08:31:11 <Eduard_Munteanu> I guess that does, but it restrict elements to Num.
08:31:11 <neutrino> not a bijection but still counts
08:31:25 <Eduard_Munteanu> It is a bijection.
08:31:28 <neutrino> Eduard_Munteanu: i'd hope numbers would be in Num.
08:31:42 <Eduard_Munteanu> Erm, oh. I missed "numbers".
08:31:45 <neutrino> Eduard_Munteanu: :)
08:32:04 <Eduard_Munteanu> neutrino: then that is a bijection too
08:32:05 <neutrino> what are other typical things you can do with a list?
08:32:22 <neutrino> well, list of numbers
08:32:31 <DMcGill> it depends on what exactly you mean by bijection. Are we treating the finite list as a set and we're just looking at different self-isomorphisms?
08:32:53 <DMcGill> i.e. from the set to itself
08:32:57 <neutrino> i have a list of n elements, i am looking for interesting operations that give you lists of n elements.
08:33:06 <neutrino> that's exactly what i'm looking for.
08:33:14 <DMcGill> to be clear: the same n elements?
08:33:28 <Eduard_Munteanu> So perhaps you don't want to restrict that to bijections?
08:33:34 <neutrino> one interesting thing i've noticed is "index after sorting", i.e. [1, 10, 5] -> [0, 2, 1]
08:33:37 <Eduard_Munteanu> Just to "interesting" stuff?
08:33:42 <neutrino> yeah.
08:33:55 <DMcGill> that's not bijections at all then, since there's no unique inverse
08:33:56 <poorhaskellguy> hey guys I'm trying to recurse over a list in haskell but i get matching type errors
08:33:58 <neutrino> DMcGill: n numbers, not necessarily the same.
08:34:18 <poorhaskellguy> here's the code √
08:34:24 <DMcGill> interesting injective functions from Z to Z then?
08:34:29 <DMcGill> that's much more varied
08:34:41 <neutrino> from Z^n to Z^n
08:35:13 <DMcGill> not if we're treating the list as a set
08:35:22 <neutrino> poorhaskellguy: that's very short and does not contain the main function. consider adding one.
08:35:35 <poorhaskellguy> sorry this is the link http://pastebin.com/hwrmdNgh
08:35:40 <mauke> The paste hwrmdNgh has been copied to http://hpaste.org/88215
08:35:40 <DMcGill> a function f from Z -> Z mean we have [x, y, z, ...] -> [f x, f y, f z, ...]
08:35:41 <neutrino> DMcGill: who ever said we'd treat it as a set?
08:35:58 <bitonic> is there a Data.List function to find the index of an infix?
08:36:06 <neutrino> DMcGill: i mean functions from Z^n to Z^n.
08:36:23 <Eduard_Munteanu> poorhaskellguy: what's the error?
08:37:04 <poorhaskellguy> http://pastebin.com/rmaHAj8s this is the error
08:37:09 <mauke> The paste rmaHAj8s has been copied to http://hpaste.org/88216
08:37:15 <kartlos> I'm trying to do the 99 haskell problems, for some problems random numbers are required, I'm kinda stuck there, how would one write a function that simply returns a random number?
08:37:29 <Eduard_Munteanu> :t genericLength
08:37:33 <lambdabot> Num i => [b] -> i
08:37:41 <Eduard_Munteanu> poorhaskellguy: you want to use that ^^
08:38:03 <Eduard_Munteanu> Instead of 'length'.
08:38:07 <Eduard_Munteanu> :t length
08:38:09 <lambdabot> [a] -> Int
08:38:20 <neutrino> (head cs) * ((length cs) - 1) : (ddx (tail cs))
08:38:21 <ion> @type randomIO
08:38:23 <lambdabot> Random a => IO a
08:38:25 <neutrino> you got your parens wrong
08:38:35 <poorhaskellguy> Eduard_Munteanu: what do you mean, sorry I'm kind of new to haskell
08:38:35 <neutrino> you want (head * len) : (rest)
08:38:52 <neutrino> at least i think so
08:39:17 <DMcGill> kartlos: you want your main to be `main = gen <- getStdGen; nums <- randoms gen; f nums'
08:39:24 <Eduard_Munteanu> poorhaskellguy: 'length' gives you an Int, but it seems you want it to work for arbitrary Nums
08:39:29 <ion> You’ll also want to use pattern matching instead of head and tail.
08:39:32 <DMcGill> where getStdGen and randoms are in System.Random
08:39:40 <DMcGill> and f takes an infinite list
08:40:05 <DMcGill> that's probably the easiest way anyway
08:40:25 <ion> dmcgill: getStdGen is rarely preferable to newStdGen.
08:40:27 <DMcGill> oops, there should be a "do" in there
08:40:32 <neutrino> Eduard_Munteanu: look at the parens. he got them wrong.
08:40:51 <DMcGill> ion: fair enough
08:41:05 <Eduard_Munteanu> neutrino: yes, that too
08:41:16 <neutrino> that's why he gets that error.
08:41:18 <kartlos> DMcGill: I've tried that but the result is always the same with the same 'gen', and getStdGen always returns the same gen, so the result is random but the same every time it's called...I'm probably missing something
08:41:19 <neutrino> fix one error at a time.
08:41:29 <Eduard_Munteanu> Yeah, fair.
08:41:35 <DMcGill> as ion said, newStdGen won't do that
08:41:43 <poorhaskellguy> Eduard_Munteanu: i tried that but then it says Occurs check: cannot construct the infinite type: a0 = a0 -> a0
08:41:54 <ion> kartlos: Also see randomIO and friends.
08:41:55 <DMcGill> BUT, that's by the nature of how random numbers and seeding works - you may want to read up on it
08:42:01 <Eduard_Munteanu> poorhaskellguy: right, do what neutrino says as well
08:42:25 <neutrino> 17:38 < neutrino> you want (head * len) : (rest)
08:42:51 <Taneb> Is it possible, with the newest GHC, to make a container with O(1) access and a type-determined size?
08:42:55 <kartlos> ion, DMcGill: thanks! do you know any good sources to read about this?
08:42:59 <Taneb> Like, with DataKinds or something
08:44:06 <Eduard_Munteanu> Taneb: would tuples do? :)
08:44:07 <DMcGill> Taneb: http://stackoverflow.com/questions/8332392/type-safe-matrix-multiplication
08:44:21 <DMcGill> the first answer lists a number of length-typed vector packages
08:44:34 <Taneb> Eduard_Munteanu, if I can sensibly have one with 1000+ elements
08:44:42 <poorhaskellguy> Eduard_Munteanu: i looked at the brackets but i can't find where exactly they are not matching
08:44:44 <Eduard_Munteanu> Oh, heh.
08:45:50 <Eduard_Munteanu> Actually wait, that's not the issue.
08:46:28 <Garyuutensei> Does anyone know when the new haskell platform will be released?
08:46:30 <DMcGill> kartlos: I can't really find one off the top of my head, but the idea is that you can't really get 'truely' random numbers with a computer and hence have a function that will just generate a big long list of numbers
08:46:39 <Eduard_Munteanu> poorhaskellguy: P requires a list of that particular Num, not a list of lists of...
08:46:43 <DMcGill> the function being sufficiently complicated that the list looks random
08:47:01 <Eduard_Munteanu> poorhaskellguy: so the outer parens shouldn't be square
08:47:12 <DMcGill> > map (\x -> (x+2)^2 + x) [1..5]
08:47:14 <lambdabot>   [10,18,28,40,54]
08:47:24 <kartlos> DMcGill: that does make sense :)
08:47:29 <DMcGill> that's a really bad example, but it's that kind of thing
08:47:39 <kartlos> I get the point, thank you!
08:47:41 <EvanR> rng's dont need to be particularly complicated
08:47:43 <Eduard_Munteanu> :t 1:[2]
08:47:45 <lambdabot> Num a => [a]
08:47:50 <Eduard_Munteanu> :t [1:[2]]
08:47:54 <lambdabot> Num a => [[a]]
08:47:54 <DMcGill> the 'seed' to a Random Number Generator (RNG) is the first number that is given to the function
08:48:07 <DMcGill> given the same seed, you get the same list of numbers
08:48:30 <DMcGill> calling getStdGen might well give two RNGs with the same see, yet newStdGed explicitly makes a new seed
08:48:32 <Eduard_Munteanu> Actually... there are multiple issues there.
08:48:43 <DMcGill> EvanR: I don't mean complicated as such, just hard to guess
08:48:59 <EvanR> the function itself doesnt need to be complicated
08:49:10 <DMcGill> no, but it does need to be hard to reverse engineer
08:49:27 <EvanR> having a very large state would make it hard to guess (im guessing youre talking about crypto rngs)
08:49:30 <DMcGill> and 'complicated' was an easier way to say this
08:49:34 <kartlos> DMcGill: so newStdGen just returns a new seed? not a new generator function?
08:49:52 <DMcGill> kartlos: it returns a new gen function which was given a new seed
08:49:58 <DMcGill> :t newStdGen
08:50:00 <lambdabot> IO StdGen
08:50:03 <DMcGill> :t getStdGen
08:50:05 <lambdabot> IO StdGen
08:50:08 <DMcGill> see how both return a StdGen
08:50:19 <kartlos> DMcGill: interesting!
08:50:32 <EvanR> hard to reverse engineer isnt necessarily a goal of rng's
08:51:20 <DMcGill> EvanR: true, but I was just trying to give an overview without getting bogged down
08:51:35 <DMcGill> then you use other functions from System.Random, like
08:51:38 <DMcGill> :t randoms
08:51:40 <lambdabot> (RandomGen g, Random a) => g -> [a]
08:51:42 <kartlos> I've read that new intel processors have a new special instruction for generating random numbers with more quality, would be something that is accessible from Haskell?
08:52:06 <poorhaskellguy> Eduard_Munteanu: i made some changes but there are still errors. new code:http://pastebin.com/atiQrnL6 .new error:http://pastebin.com/R9kqdfN9
08:52:10 <mauke> The pastes atiQrnL6 R9kqdfN9 have been copied to http://hpaste.org/88217 http://hpaste.org/88218
08:52:15 <DMcGill> which take a RandomGen (of which StdGen is one) and a number (sometimes) and generates an infinite list of random ones
08:52:37 <Demos> well kartlos, you can always just write the function in C, that said better to use the stuff built into haskell unless you need a lot of random numbers really fast
08:52:39 <EvanR> kartlos: haskell can use the ffi to do anything C can do
08:52:50 <DMcGill> kartlos: not currently to my knowledge, but there's nothing stopping GHC or you using ffi from implementing
08:53:09 <Eduard_Munteanu> @hoogle (^^)
08:53:09 <lambdabot> Prelude (^^) :: (Fractional a, Integral b) => a -> b -> a
08:53:13 <dcoutts> kartlos: and could easily be used for seeding an existing rng, so there's no need for apps to change any code, or change behaviour
08:53:17 <icarot> Anyone know if Integer/Char are implemented as disjoint unions? Hence why you can pattern match against them?
08:53:31 <elliott> icarot: they are "primitive"
08:53:32 <Eduard_Munteanu> ParadoxMuffin: what's the idea with (^^) there?
08:53:36 <elliott> pattern matching on numbers and Chars is a special case
08:53:39 <elliott> that desugars to equality tests
08:53:40 <DMcGill> for "primitive", read "magic"
08:53:50 <elliott> no, better: for "magic", read "primitive"
08:53:53 <Taneb> Eduard_Munteanu, it raises a number to an integral power, which MAY be negative
08:54:01 <dcoutts> icarot: Int and Char are internally single-constructor data types, and as elliott says the pattern matching is built-in
08:54:02 <Taneb> Wait
08:54:05 <Taneb> Ignore me
08:54:06 <elliott> there's nothing magical about them. GHC implements Integer in terms of machine words and GMP bignums for very large or very small integers
08:54:14 <elliott> Char in terms of a machine word
08:54:16 <Taneb> Wiat, don't ignore me, I was about to ask an unrelated question
08:54:17 <Eduard_Munteanu> Well, yeah, I wonder what that's got to do with the 'length' he had before. :)
08:54:21 <dcoutts> icarot: Integer is actually a two-constructor type, again pattern matching is built-in to the compiler
08:54:26 <elliott> but the Haskell Report says nothing on how they should be implemented
08:54:34 <DMcGill> that's what I mean though, 'magic' in Haskell are things implemented as behind-the-scenes stuff
08:54:43 <DMcGill> what else in Haskell would you call 'magic'?
08:54:45 <Taneb> Isn't pattern matching for numbers done with Eq?
08:55:00 <dcoutts> icarot: you can ask ghc about their internal representations, but yes that's going below what the Haskell language definition says
08:55:03 <Taneb> DMcGill, there's the obscure special case of ($) regarding ST
08:55:10 <dcoutts> :i Int
08:55:10 <DMcGill> List and Maybe are not magic, IO and Int are
08:55:13 <elliott> DMcGill: I wouldn't. I avoid that terminology because I believe it misleads and worries people by making it seem like they can't understand things that are considered magical
08:55:23 <DMcGill> elliott: that's a good point
08:55:29 <elliott> [] is "magic" by your definition; its constructors have names that ordinary data types cannot be defined with
08:55:48 <EvanR> elliott: "very small" integers like negative nine quadrillion?
08:55:55 <EvanR> doesnt seem that small ; )
08:56:00 <DMcGill> borderline though, since you can do everything that [] can do with your own Data List a def
08:56:25 <ab9rf> @pl \l x -> map (\f -> f x) l
08:56:25 <lambdabot> flip (map . flip id)
08:56:46 <Guest55594> how do you get a -> m b from Kleisli m?
08:56:52 <DMcGill> and Taneb: got a link to that?
08:56:55 <Taneb> Guest55594, runKleisli
08:56:59 <Taneb> DMcGill, alas, no.
08:57:01 <DMcGill> :t runKleisli
08:57:04 <lambdabot> Kleisli m a b -> a -> m b
08:57:07 <Taneb> I only heard about it in here the other day
08:57:20 <Taneb> Basically, it makes it work
08:57:32 <Taneb> Because otherwise you got monomorphism errors or something
08:57:48 <DMcGill> urgh, Rank2Types
08:58:04 <copumpkin> huh?
08:58:08 <Eduard_Munteanu> DMcGill: it's just GHC provides a special case for ($), since doing stuff like 'runST $ ...' requires impredicative instantiation. And it doesn't do that for (.), which doesn't work, e.g. runST . someSTAction
08:58:13 <copumpkin> Kleisli isn't rank 2
08:58:18 <DMcGill> no, ST is though
08:58:21 <copumpkin> oh, okay
08:58:31 <Eduard_Munteanu> It's not DMR-related.
08:59:19 <DMcGill> I see. Also, what is "DMR"?
08:59:30 <Eduard_Munteanu> DMcGill: dreaded monomorphism restriction :)
08:59:34 <DMcGill> aha
08:59:37 <copumpkin> Do Mot Resuscitate
08:59:41 <Eduard_Munteanu> Heh.
09:00:04 <Eduard_Munteanu> > let ($$$) = ($) in runST $$$ (return 5)
09:00:07 <lambdabot>   Couldn't match expected type `forall s. GHC.ST.ST s b0'
09:00:07 <lambdabot>              with a...
09:00:15 <Eduard_Munteanu> > runST $ (return 5)
09:00:21 <lambdabot>   5
09:00:32 <Eduard_Munteanu> (and it does so quite stupidly :D)
09:00:47 <Guest55594> ?CoKleisli
09:00:48 <lambdabot> Unknown command, try @list
09:00:50 <Guest55594> wait
09:00:55 <Guest55594> where is the CoKleisli thing
09:01:08 <DMcGill> @hoogle CoKleisli
09:01:09 <lambdabot> No results found
09:01:11 <Guest55594> I can't find either CoKleisli or Cokleisli in Control.Arrow
09:01:13 <Taneb> Guest55594, Control.Comonad in the comonads package
09:01:13 <Eduard_Munteanu> Guest55594: CoKleisli w a b = w a -> b
09:01:20 <Taneb> And it's a lower-case k
09:01:24 <Taneb> :t Cokleisli
09:01:27 <lambdabot> Not in scope: data constructor `Cokleisli'
09:01:29 <DMcGill> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Arrow-CoKleisli.html
09:01:31 <Taneb> Bah
09:01:43 <ab9rf> @pl \x -> floor (x/2)
09:01:43 <lambdabot> floor . (/ 2)
09:01:48 <Taneb> DMcGill, category-extras is very very deprecated
09:02:01 <DMcGill> ok, I just grabbed the first google result
09:02:03 <Taneb> http://hackage.haskell.org/packages/archive/comonad/3.0.2/doc/html/Control-Comonad.html#g:3
09:11:00 <Kneiva> how can I get "ok" to work here: http://hpaste.org/88219
09:13:08 <Taneb> Kneiva, that depends very heavily on what you want it to do
09:13:10 <Clint> Kneiva: what do you want it to be?
09:13:16 * hackagebot compdata 0.6.1.4 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.6.1.4 (PatrickBahr)
09:13:52 <Kneiva> I'm trying to use it in filter: result <- filterM (chainB) xs
09:14:58 <Taneb> It could be something as simple as "return True"
09:15:04 <Taneb> ..l
09:15:11 <Taneb> Or rather "\_ -> return True"
09:19:21 <Guest55594> isn't that const $ return True
09:19:35 <DMcGill> sure
09:20:48 <latermuse> "free applicatives" are the same as the applicative library, but without needing to import the Control.Applicative library. Am I correct?
09:22:34 <elliott> no
09:22:43 <elliott> free applicatives are to applicatives as free monads are to monads
09:23:06 <elliott> as for what free monads are, http://stackoverflow.com/questions/13352205/what-are-free-monads might help
09:23:11 <Taneb> They are a way of turning any Functor into a related, but sometimes very different, Applicative
09:23:15 <elliott> but also might not :)
09:23:36 <dmwit> "free X over Y" is what you get by taking Y, closing it under the operations of an X, and quotienting by the laws of an X.
09:23:55 <elliott> http://blog.omega-prime.co.uk/?p=34 may also help
09:25:55 <dmwit> I wonder if there's an audience for a blog post expanding this sentence for monoids, groups, applicatives, monads, and maybe one or two other algebraic structures.
09:27:01 <dolio> You could also expand my wiki article.
09:27:26 <dmwit> Which article? On which wiki?
09:27:57 <dmwit> http://www.haskell.org/haskellwiki/Free_structure ?
09:28:15 <dolio> Yes.
09:30:04 <dmwit> Yeah. You jump straight from what it means to be free to "_the_ free monoid is sequences".
09:30:26 <dmwit> Doesn't give a lot of intuition about how you go "from here to there", so to speak.
09:30:58 <dmwit> But lots of good stuff in here.
09:32:38 <dolio> Right.
09:32:48 <dolio> I never explained how to 'calculate' them, as it were.
09:32:59 * dmwit nods
09:33:00 <elliott> haha, this blog post about currying on /r/haskell is funny.
09:33:52 <joeyh> anyone familiar with bas's monad-control?
09:34:05 <dmwit> ?where justask
09:34:05 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
09:34:14 <Eduard_Munteanu> You could make an meme... provide that explanation, then the image with "boy, that escalated quickly". :P
09:34:21 <Eduard_Munteanu> s/an/a/
09:34:23 <elliott> joeyh: vaguely
09:34:37 <elliott> though I don't really like it, so i can't guarantee satisfactory answers :P
09:35:20 <joeyh> well, basically, I'm using it to do some exception handling in a StateT
09:35:43 <joeyh> and it seems that if I bracket, and the action fails, its state is getting thrown away
09:35:48 <elliott> yes
09:35:48 <Guest55594> anyone know what I was asking earlier
09:35:51 <elliott> that is fundamental
09:35:58 <Guest55594> with this thing: (/>) :: Chain r q a b -> q b c -> Chain r q a c
09:35:59 <elliott> if you look at the types, it cannot work any other way
09:36:06 <Guest55594> changed to that new type
09:36:10 <elliott> you have s -> IO (a, s)
09:36:15 <joeyh> because it never returns the new s
09:36:18 <elliott> yes
09:36:23 <Guest55594> I still actually have the problem with writing that a -> m b by itself,
09:36:28 <elliott> instead of StateT s IO, consider ReaderT (SomeVarType s) IO
09:36:34 <joeyh> ok, just checking my intuition that's the case. The docs don't seem to say that
09:36:38 <elliott> good SomeVarTypes are TVar, or IORef if you're single-threaded
09:36:43 <Guest55594> actually maybe not
09:36:48 <elliott> or MVar if you have a reason
09:36:53 <joeyh> interesting suggestion
09:37:00 <Guest55594> no no I do
09:37:07 <elliott> joeyh: see also e.g. http://blog.ezyang.com/2012/01/monadbasecontrol-is-unsound/
09:37:15 <Guest55594> if I use Kleisli I can't properly type the thing that goes into Kleisli
09:37:17 <joeyh> saw that. over my head ;)
09:37:23 <akamaus> greetings! Is there any library for converting between different character encodings which compiles under windows? Performance doesn't matter, only ease of installing.
09:37:31 <elliott> also, if you just want exception handling, you might prefer a simpler package like MonadCatchIO-transformers (although I hear that edwardk is working on a replacement since it's unmaintained now or something?)
09:37:36 <Guest55594> so it's unavoidable that everything I pass would have to have Kleisli inside it
09:37:46 <dmwit> akamaus: encoding certainly does
09:38:07 <dmwit> akamaus: Though I guess most people just use text and text-icu now. Do those not  work in Windows?
09:38:28 <joeyh> does monadcatchio-transformers avoid this somehow?
09:38:28 <akamaus> dmwit, does it? I've just tried, got the same error as in http://stackoverflow.com/questions/4701585/how-to-install-haskell-module-encoding-0-6-3-on-windows
09:38:29 <Guest55594> and any newtype I have is no different
09:38:57 <elliott> joeyh: no
09:39:22 <elliott> joeyh: you could write your own throw/catch that avoid it by specifically specifying (in a specificatory manner) this behaviour
09:39:23 <dmwit> akamaus: Ah, okay, that's easily fixed.
09:39:32 <edwardk> elliott: the issue is the api for monadcatchio-transformers can't work with head
09:39:45 <dmwit> akamaus: It's not really Windows-specific, either, so I'm a bit surprised nobody's complained to me about that yet.
09:39:48 <akamaus> dmwit, can you give a hint?
09:39:50 <edwardk> block/unblock are finally getting removed
09:40:04 <dmwit> akamaus: You just need to add extra-something-dirs: . in the .cabal file. Let me look up the right thing.
09:40:10 <elliott> joeyh: but once you do that you might as well just use the ReaderT solution
09:40:19 <edwardk> akamaus: try text-icu
09:40:32 <dmwit> akamaus: include-dirs: .
09:40:36 <joeyh> ok, now I understand why I've heard people promote the TVar idea!
09:40:57 <elliott> joeyh: another example of how this is very tricky is concurency :)
09:41:10 <elliott> there are lots of different behaviours you could want for state there
09:41:23 <dmwit> akamaus: Let me know if that works. If it does, I'll make a release with that fix in.
09:41:42 <akamaus> dmwit, ok, Will try right now
09:43:28 <dmwit> akamaus: um
09:44:29 <dmwit> akamaus: Well, that should at the very least change the error. You may have to -f-systemEncoding to get it to build.
09:44:33 <dmwit> =/
09:44:56 <dmwit> My memory is crap. This is why I write this stuff down. Apologies that I didn't go look this up before I responded from memory. =P
09:46:02 <swissarmyspoon> could you say that a mutex ensures that an action is atomic?
09:46:31 <ousado> hehe nice nick :)
09:46:54 <dmwit> That depends on your definition of atomic.
09:47:49 <dmwit> Also on what you think about exceptions.
09:47:53 <Fuuzetsu> I need help with getting GHC to compile: it seems to generate some junk in one of the C files. Do I got to ghc-users or ghc-dev for help?
09:48:03 <Fuuzetsu> go*
09:48:54 <ousado> swissarmyspoon: under the assumption that everything uses that mutex 'correctly' one could say so
09:50:03 <kartlos> let's say I have a function that returns IO a, how would one simply drop the IO part and get the a? For example: IO Int -> Int
09:50:13 <ab9rf> @pl \x -> (snd x) /= 0
09:50:13 <lambdabot> (0 /=) . snd
09:50:20 <dmwit> kartlos: One does not simply drop the IO part.
09:50:28 <Eduard_Munteanu> dmwit++
09:50:44 <dmwit> kartlos: Instead, one teaches one's consumers how to consume IO Ints instead of Ints.
09:50:50 <Eduard_Munteanu>  :t (>>=)
09:51:00 <dmwit> For example, via fmap or (>>=), as Eduard_Munteanu is pointing out.
09:51:27 <Cale> kartlos: Inside the do-block for another IO action, you can write  v <- x  and if x :: IO t then v :: t.
09:51:44 <ciaranm> once you're in an IO you can never escape!
09:51:45 <Cale> v <- x here should be read as "run the action x and call its result v"
09:51:58 <Cale> Well, this is a sort of escaping.
09:52:01 <dmwit> :t (>>=)
09:52:03 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:52:06 <dmwit> No escaping.
09:52:17 <Cale> You can then pass that v to anything you like, including things which know nothing about IO.
09:52:19 <dmwit> You're just teaching your (a -> m b) consumer how to be an (m a -> m b) consumer instead.
09:52:46 <dmwit> The idea that you can use things that know nothing about IO is just an illusion. You have taught them about IO.
09:52:48 <Cale> Sure, the result is another IO action, but the rest of your program doesn't need to care :)
09:52:57 <kartlos> wow my understanding of monads is very shaky
09:53:10 <Cale> Yeah, let's not talk about monads in general here
09:53:22 <dmwit> Agreed. Understanding monads is not necessary.
09:53:39 <ciaranm> right. let's start with some simple algebra and topology, so we can teach you category theory.
09:53:55 <Cale> guys, stop trolling for a few minutes please :)
09:54:02 <dmwit> Just pretend "(>>=) :: IO a -> (a -> IO b) -> IO b" instead and forget that IO is a monad and (>>=) is polymorphic for now.
09:54:14 <Cale> Or just use do-notation :P
09:54:16 <dmwit> I am 100% not trolling, and giving the very best advice I can think to give.
09:54:43 <Cale> kartlos: For example:  do x <- getLine; putStrLn (reverse x)
09:54:45 <kartlos> thanks guys your advice is helpful for me
09:54:49 <Cale> kartlos: x here is a String
09:55:04 <Cale> and reverse :: [a] -> [a] doesn't have to know that x came from doing IO
09:55:46 <ciaranm> i am trolling, for what it's worth
09:55:51 <kartlos> but I was thought to think of <- as "draw from", does that analogy also apply in this context?
09:56:09 <dmwit> It can apply.
09:56:13 <ciaranm> analogies are dangerous things
09:56:15 <dmwit> Analogies often have to stretch a bit.
09:56:21 <dmwit> But that's okay if you find it helpful.
09:56:38 <dmwit> (...but the moment it isn't helpful, and is confusing instead, you should drop it!)
09:56:38 <Cale> kartlos: In list comprehensions (or the list monad), that makes more sense, but it can apply here, in the same sense as you can draw a list of files from /bin/ls (by executing it)
09:57:56 <kartlos> thanks, I understand now that I was thinking in a totally wrong direction, just need to let these answers sink in
09:58:03 <Cale> getLine :: IO String  contains a string only in the sense that you can run it to produce a string
09:58:05 * jmcarthur vows to never teach do-notation-first
09:58:17 * hackagebot semigroups 0.9.2 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.9.2 (EdwardKmett)
09:58:21 <Cale> jmcarthur: why?
09:58:23 <copumpkin> @quote ls
09:58:23 <lambdabot> qwe1234 says: good developers will write good code in absolutely any language, while bad developers will develop crap no matter the tools they use.
09:58:33 * djahandarie doesn't like using do notation to teach stuff either
09:58:39 <copumpkin> undo notation
09:58:52 <djahandarie> unpumpkin
09:58:59 <elliott> 2quote /bin/ls
09:59:00 <elliott> @quote /bin/ls
09:59:00 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
09:59:00 <copumpkin> undjahandarie
09:59:01 <jmcarthur> Cale: allow me to deal with a distraction and then come back to formulate my reasoning
09:59:11 <Cale> jmcarthur: Sure :)
09:59:30 <kartlos> weren't some types of list comprehensions dropped because the same could be accomplished with do notation?
09:59:48 <Cale> kartlos: and then re-added?
09:59:59 <dmwit> -XMonadComprehensions
10:00:08 <Cale> kartlos: There's monad comprehensions, which generalise list comprehensions to any monad (for example, IO)
10:00:22 <Cale> (though IO would be an atypical use)
10:02:49 <kartlos> do you guys know what open source project would be the easiest (?) to read and understand for a beginner in haskell? I've tried reading XMonad but understood I wasn't ready for that...
10:03:12 <dmwit> Perhaps you could try one of the "build yourself an IRC bot" or "write yourself a scheme" tutorials.
10:03:19 <rgrinberg> kartlos: pandoc
10:03:29 <rgrinberg> look up the guide by jekor on youtube
10:04:34 <kartlos> nice! these videos by jekor look promising
10:04:40 <ciaranm> if i were teaching monads, i'd go the functor route, then explain pure and join, and then show how you can get bind from there
10:04:47 <Demos> what is the best way to dynamicly compile a haskell file and then proceed to call a function within it?
10:04:50 <hpc> kartlos: xmonad is hard even for more experienced haskellers
10:04:59 <hpc> kartlos: because it deals with X ;)
10:05:08 <Cale> Demos: Perhaps look into using hint?
10:05:49 <geekosaur> true dat. I'm no great shakes with haskell, it's knowing X11 well that makes me successful
10:05:50 <Cale> Demos: It'll normally interpret .hs files, but if you run ghc over the .hs file first so that a .o and .hi are present, it'll load the compiled object code instead.
10:06:04 <Demos> Cale: thank you! never heard of that, looks totally ideal
10:06:23 <kartlos> hpc: the xmonad source is compact though, I found it easier to read than awesome WM
10:06:36 <kartlos> but that doesn't say much I guess...
10:06:46 <Demos> can it output hs files, so I could say tell it to dump out some function?
10:07:28 <Demos> xmonad is great!
10:08:49 <Ndit> xgonad
10:09:50 <hpc> xmonoidinthecategoryofendofunctors
10:10:44 <ciaranm> i'm old-school. i just call it xtriple.
10:11:26 <jmcarthur> Cale: from what i've seen, do-notation-first (1) supports the misconception that IO and other monads are somehow special, (2) supports the misconception that to use a monad you "extract" values from actions, (3) doesn't help much when it comes time to learn about the underlying return and (>>=) operations (compare against the effort of learning those first and then only having to learn the syntax sugar
10:11:28 <jmcarthur> after)
10:12:00 <ciaranm> i'd add "4) makes you think monads are magic, rather than illustrating where they come from" to that
10:12:32 <jmcarthur> ciaranm: i could have probably worded (1) to more clearly include that
10:12:47 <ciaranm> jmcarthur: i think there's still a difference
10:13:22 <jmcarthur> i think i see the difference you are shooting for
10:13:26 <ciaranm> a class i was in taught the state monad through "here's how bind is implemented. now go understand it!"
10:13:31 <DMcGill> jmcarthur: on the other hand, not teaching IO first means that you can't do anything with user input until you've covered monads which is less than idea for a) teaching that Haskell is practical and b) holding interest
10:13:51 <DMcGill> "not teaching do-notation first" I should say
10:13:52 <jmcarthur> DMcGill: i don't think withholding IO is a great idea either
10:14:20 <akamaus> dmwit, adding the option to Library section didn't make any difference
10:14:31 <DMcGill> if you withhold do-notation but not IO, then you simply teach the cargo cult method of ">>= \x -> " that people don't understand any more than "<-"
10:14:44 <jmcarthur> DMcGill: i would consider teaching IO in terms of (>>=) and return early, with specialized types. this is not a direction i've seen any instructor take in earnest before, though
10:14:49 <akamaus> I also tried extra-lib-dirs, doesn't work either
10:15:21 <jmcarthur> DMcGill: i don't think it's fundamentally as hard to understand as <-
10:15:40 <ciaranm> if you're teaching haskell not as a first language, waiting a while for IO isn't a big deal
10:15:50 <jmcarthur> DMcGill: and at least with return and (>>=), continued exposure to it *will* eventually teach you what's going on, but with do notation the illusion stays in the way
10:16:01 <Igloo> jmcarthur: Really? I think people can much more easily get intuition for do notation, even if they don't exactly understand it in detail
10:16:12 <DMcGill> tbh I think withholding IO is the best of both worlds
10:16:29 <ciaranm> intuition instead of understanding encourages "expert beginners" who will never go on to understand
10:16:35 <jmcarthur> Igloo: i agree that do notation works as a way of quickly getting people to a point where they can write IO
10:16:41 <jmcarthur> Igloo: but i think it causes damage in the meantime
10:16:41 <DMcGill> or using IO and letting people think that "<-" is magic until you've covered monads
10:16:59 <DMcGill> depends on who you're aiming the course at
10:16:59 <Entroacceptor> the "Land of Lisp" book starts out without IO, and just uses the repl, works fine
10:17:23 <arnsholt> FWIW, for my recent noob-code, I've been quite happy to write imperative-style IO-code with do and then, once I'm fed up with it being ugly and verbose, going back and making it better with >>= and such
10:17:24 <DMcGill> a book on it, withholding IO seems better. A course for undergrads however needs to hold their interest
10:17:27 <jmcarthur> yeah, no IO at first is a fine approach depending on the goals of the learner
10:17:32 <Igloo> To me, this seems analogous to teaching 3 year olds about rings and fields, rather than counting apples
10:17:44 <KAction> Hello! Is it possible, having `a:: MaybeT IO String` and `fn :: String -> IO [String]` get `MaybeT IO [String]`?
10:17:53 <arnsholt> do notation has the benefit of making it easy to hack together something that works, which makes it easier to make sure the refactored code works as well
10:17:56 <ciaranm> Igloo: if you're teaching a first "how to program" course, maybe
10:18:04 <KAction> Sorry, I am new to transformers.
10:19:03 <jmcarthur> Igloo: that would be the case if i was insisting on teaching the Monad class first, but that's not what i'm arguing
10:19:06 <ParahSail1n> :ty lift
10:19:08 <Igloo> Well, most people learning Haskell will be seeing a lot of new stuff. I don't think that using strangely named operators that they are entirely unfamiliar with is a good idea until they are comfortable with the langauge in general
10:19:24 <ciaranm> KAction: 'lift', no?
10:19:26 <monoidal> KAction: you can use lift to transform IO [String] to MaybeT IO [String], and get fn :: String -> MaybeT IO [String]
10:19:43 <monoidal> KAction: then, you have a value a :: X String and fn :: String -> X String (where X = MaybeT IO), so you can use >>=
10:19:50 <ParahSail1n> @ty lift
10:19:52 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
10:20:07 <ab9rf> @pl \x y -> (x>0) && y
10:20:07 <lambdabot> (&&) . (> 0)
10:20:39 <DMcGill> ab9rf: if you're folding over a list, try "all (>0)"
10:20:54 <DMcGill> > all (> 0) [0,1,2,3]
10:20:56 <lambdabot>   False
10:21:02 <DMcGill> > all (> 0) [1,2,3]
10:21:04 <lambdabot>   True
10:21:25 <KAction> But `lift fn :: lift a :: MonadTrans t => t ((->) String) (IO [String])
10:22:21 <KAction> @ty lift . liftM
10:22:23 <lambdabot> (Monad m, MonadTrans t) => (a1 -> r) -> t ((->) (m a1)) (m r)
10:22:44 <jmcarthur> i've seen a lot of people in #haskell struggle over monads who started with do notation. by now i've worked with a lot of people learning OCaml who pick up our monadic libraries just fine. i am fairly confident that the lack of syntax sugar is a large part of that difference.
10:24:00 <DMcGill> are you in #ocaml?
10:24:07 <jmcarthur> no
10:24:11 <DMcGill> That seems pretty circumstantial
10:24:17 <DMcGill> anecdotal I mean
10:24:37 <jmcarthur> are any of use arguing from peer reviewed studies?
10:24:39 <jmcarthur> *us
10:24:45 <ParahSail1n> i didnt use do notation until i understood it using >>= and >>
10:24:58 <DMcGill> mm, fair enough
10:27:25 <cmccann> I think the thing that helped me the most was reimplementing State sans newtype and then translating that to the newtype and then re-sugaring it for do notation.
10:27:37 <cmccann> that and understanding how list comprehensions relate to do blocks.
10:28:49 <ab9rf> :t catMaybe
10:28:52 <lambdabot>     Not in scope: `catMaybe'
10:28:52 <lambdabot>     Perhaps you meant one of these:
10:28:52 <lambdabot>       `catMaybes' (imported from Data.Maybe),
10:28:59 <cmccann> do blocks are nice for writing imperative style code but I suspect the syntactic sugar is counterproductive to learning how it really works.
10:32:34 <schell> anyone have suggestions for a matrix math lib for games?
10:32:56 <hpc> hmatrix, most likely
10:33:07 <schell> cool - i'll look into that
10:33:13 <cmccann> hmatrix is a good default plan
10:33:25 <cmccann> I think most of it needs IO though? since it's a lot of FFI bindings.
10:33:26 <schell> thanks :)
10:33:31 <mm_freak> schell: if this is for graphics, opengl ;)
10:33:50 <cmccann> newschool GL expects you to have your own matrix math anyway.
10:34:08 <DMcGill> cmccann, schell: hmatrix doesn't need IO despite it using FFI
10:34:12 <schell> i've been using openglraw for displaying the graphics, but i'd rather not work with matrices in c
10:34:20 <DMcGill> things are implemented behind the scenes and exposed as normal types
10:34:31 <mm_freak> schell: why openglraw?
10:34:34 <hpc> schell: check out gpipe
10:34:35 <mm_freak> and why C?
10:34:35 <cmccann> DMcGill: ah ok I wasn't sure. obviously it all "should" be pure but that's not always easy to do with FFI libs.
10:34:40 <DMcGill> I've had good experiences with hmatrix
10:34:44 <hpc> er, not gpipe
10:34:48 <DMcGill> although I wish I'd used hmatrix-static
10:34:50 <hpc> graphics-drawingcombinators
10:34:55 <schell> i checked out gpipe, the example didn't work for me
10:35:02 <DMcGill> not that it really mattered given that I was only using length-3 vectors and 3x3 matrices
10:35:25 <schell> then i tried lambdacube but it's a little too complex
10:35:45 <mm_freak> too bad that HGamer3D is windows-only
10:36:01 <hpc> schell: try graphics-drawingcombinators; someone in here wrote tetris in an hour with that, sdl, and gloss
10:36:12 <hpc> from no prior knowledge
10:36:23 <schell> then i went with opengl and realized there aren't a lot of tutorials for opengl in haskell (let alone gpipe or lambdacube)
10:36:36 <DMcGill> schell:
10:36:40 <DMcGill> @where beautiful code
10:36:40 <cmccann> hpc: gloss must be pretty nice since it took me like 4hrs using just graphics-drawingcombinators and sdl :P
10:36:40 <lambdabot> I know nothing about beautiful.
10:36:49 <schell> so i settled on openglraw so i could follow nehe tuts and some of my old c/objc code
10:37:11 <DMcGill> http://www.renci.org/wp-content/pub/tutorials/BeautifulCode.pdf
10:37:16 <applicative_tmp> arent there a couple of repa/opengl examples in gloss-examples?
10:37:21 <DMcGill> that's a good tut to Haskell opengl
10:37:44 <hpc> cmccann: the first line of code in the haddock for gloss is
10:37:45 <hpc> main = display (InWindow "Nice Window" (200, 200) (10, 10)) white (Circle 80)
10:38:03 <cmccann> heh
10:38:07 <dmwit> akamaus: Yes, I know; see my later messages re: -f-systemEncoding
10:38:20 <applicative_tmp> is that a bad first line for a haddock for gloss?
10:38:21 <dmwit> akamaus: (And again, apologies for talking before I consulted my notes.)
10:40:30 <schell> DMcGill: thanks - reading it now
10:40:57 <mm_freak> schell: OpenGL is a very thin layer around OpenGLRaw
10:41:18 <mm_freak> just remember that state changes are done with ($=)
10:41:23 <cmccann> the OpenGL package also has other benefits, like the haddock index page being useful.
10:41:32 <mm_freak> right
10:42:12 <dmwit> I have a brilliant idea: Tetris, but with physics.
10:42:20 <dmwit> Miss by a little bit => game over, man, just game over.
10:42:27 <jmcarthur> that's been done
10:42:36 <dmwit> aw, nuts
10:42:36 <schell> mm_freak: i've never used ($=) - what package is it in (it's not in hoogle)
10:42:41 <cmccann> dmwit: would the pieces fall over and end up jammed diagonally?
10:42:50 <dmwit> cmccann: exactly
10:42:55 <dmwit> You think bastetris is hard.
10:43:00 <cmccann> dmwit: anyway, more subtly evil is--yeah that
10:43:03 <hpc> http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=%28%24%3D%29
10:43:08 <hpc> schell: ^
10:43:11 <jmcarthur> http://www.youtube.com/watch?feature=player_embedded&v=EaFzw_2vN7E
10:43:19 <mm_freak> schell: http://hackage.haskell.org/packages/archive/OpenGL/2.8.0.0/doc/html/Graphics-Rendering-OpenGL-GL-StateVar.html
10:43:53 <schell> is hayoo typically better than hoogle?
10:44:00 <jmcarthur> also http://www.youtube.com/watch?v=_giTK__WVOw
10:44:45 <dmwit> jmcarthur: Hilarious. I wonder whether there's even any code for removing pieces.
10:44:53 <DMcGill> schell: it has a wider search field by default but a worse interface. I usually try Hoogle first
10:44:54 <dmwit> "eh, nobody's going to successfully make a line anyway..."
10:45:06 <jmcarthur> dmwit: the second link actually does have that!
10:45:11 <jmcarthur> dmwit: and it's even eviler
10:45:27 <schell> DMcGill: cool - thanks
10:45:49 <applicative_tmp> schell: its hard to argue with the new fpcomplete hoogle https://www.fpcomplete.com/hoogle
10:47:09 <dmwit> Second one looks much less evil to me. It looks very generous about lines...
10:47:23 <schell> my favorite thing about hoogle/hayoo is that duckduckgo.com has bang-commands for them...
10:48:03 <schell> https://duckduckgo.com/?q=Int+-%3E+%5Ba%5D+-%3E+a+!hoogle
10:48:32 <elliott> pfft, HATETRIS is harder than bastet.
10:48:56 <schell> then with chrome set to duckduckgo as the default search, i can do hoogle/hayoo searches from the url bar
10:49:11 <int-e> elliott: look at the name. (hate)(tris).
10:49:46 <akamaus> dmwit, works like a charm! Many thanks. Built it under vista with ghc-7.4.2.
10:49:58 <elliott> int-e: you don't say :P
10:50:31 <akamaus> dmwit, could you please upload an update?
10:51:44 <dmwit> akamaus: No need for an update, right? It builds with -f-systemEncoding straight from Hackage.
10:51:57 <dmwit> The include-dirs: . thing was a complete red herring.
10:52:59 <schell> DMcGill: the opengl bindings do look pretty rad. i'm looking at all the shader stuff right now. i spent all yesterday doing "withCString blah $" and "alloca" to compile shaders...
10:53:16 <cmccann> dmwit: apparently it does remove lines http://www.youtube.com/watch?v=SMXmFF2hoY4
10:53:24 <DMcGill> Like I said, it's what I use for 3D stuff.
10:53:34 <dmwit> elliott: I got three lines.
10:53:36 <akamaus> dmwit, hmm, probably yes. but I'm not sure, I added it but it didn't make any difference until I added the -f flag
10:53:41 <DMcGill> Although some of the other linked things look really neat for 2D
10:54:00 <jmcarthur> the main reason i prefer openglraw is that the C opengl documentation applies
10:54:09 <jmcarthur> as well as pretty much every other opengl resource i could use
10:54:10 <cmccann> dmwit: by which I mean it chops out a line if it's dense enough, including slicing off corners of pieces
10:54:25 <jmcarthur> whereas with the opengl package i have to figure out what maps to what
10:54:41 <schell> jmcarthur: right - that's why i was going with openglraw
10:55:06 <akamaus> dmwit, maybe we should at least add a hint to the page on hackage? By the way, why this flag isn't default?
10:55:06 <jmcarthur> also openglraw supports a larger subset of opengl that the opengl package does, but that doesn't matter as much to me
10:55:14 <jmcarthur> *than
10:55:16 <FreeFull> Why are aeson's FromJSON instances incoherent?
10:55:27 <dmwit> akamaus: It's not default because getSystemEncoding is useful. =)
10:57:27 <akamaus> dmwit, is it possible to make it default just for windows?
10:57:45 <eikke> I could use some help getting my code to type-check/work... any takers? https://gist.github.com/NicolasT/4230251f4f87f110d197
10:57:52 <schell> DMcGill: what about for windowing? GLUT, GLFW or GLFW-b?
10:57:58 <eikke> maybe my approach si completely wrong and I should use some other way
10:58:06 <mm_freak> jmcarthur: once you know how to transkate between OpenGL and OpenGLRaw those apply to OpenGL, too
10:58:21 <dmwit> akamaus: It's not really possible to change the value of a flag based on operating system, no. =/
10:59:03 <mm_freak> schell: my personal favorite is SDL, mainly because it allows me to write the main loop myself, so i'm not trapped in vanilla IO
10:59:13 <DMcGill> I have used both GLUT and SFML. glut (and freeglut) have much more tutorials about them but sfml is more modern
10:59:17 <mm_freak> but it's more difficult to get SDL on windows
10:59:19 <DMcGill> have a little play with both imo
10:59:45 <jmcarthur> glfw also allows you to write your own loop
11:00:00 <DMcGill> also if you want to use SFML, the Haskell binding to use are https://github.com/jeannekamikaze/SFML
11:00:12 <DMcGill> and NOT what you get from googling HSFML
11:00:17 <schell> my main loop is essentially: forever drawscene
11:00:19 <jmcarthur> however not that while those are pretty recent bindings, they are abandoned afaik
11:00:22 <jmcarthur> *note
11:00:24 <jmcarthur> the sfml ones, i mean
11:00:26 <mm_freak> jmcarthur: any advantage over SDL?
11:00:42 <DMcGill> hmcarthur: the HSFML ones are, jeannekamikaze's aren't
11:00:47 <DMcGill> hence me recommending them
11:00:48 <jmcarthur> mm_freak: glfw is simpler, the bindings more cross platform
11:00:53 <jmcarthur> DMcGill: no, they are
11:01:08 <DMcGill> ah, I didn't know that. They currently work anyway
11:01:10 <jmcarthur> DMcGill: jeannekamikaze got frustrated with the sfml devs and basically quit working on them
11:01:12 <mm_freak> jmcarthur: then what would you use for audio?
11:01:15 <jmcarthur> DMcGill: it was recent
11:01:15 <DMcGill> whereas hsfml doesn't work at all
11:01:18 <mm_freak> OpenAL?
11:01:20 <jmcarthur> mm_freak: not sure
11:01:41 <jmcarthur> audio libraries is an ugly world
11:01:46 <mm_freak> right
11:01:50 <cmccann> I really need to look into that.
11:02:05 <mm_freak> ALSA is pretty easy to use, but gets awkward as soon as you want to do anything fancy
11:02:17 <mm_freak> OpenAL seems a good choice
11:02:24 <jmcarthur> mm_freak: i imagine alsa is not so cross platform though
11:02:30 <mm_freak> sure
11:02:31 <jmcarthur> mm_freak: openal is now under a prop license :(
11:02:38 <cmccann> which is so very wtf
11:02:44 <mm_freak> what?  really?
11:02:47 <cmccann> yes, really.
11:02:57 <schell> that seems...not very...open
11:03:01 <jmcarthur> mm_freak: we've been researching a lot of these libs as part of the haskell-game project
11:03:05 <mm_freak> ok, then it's off the list
11:03:15 <schell> ooh! what's the haskell-game project?
11:03:17 <cmccann> audio is probably the worst situation of the lot.
11:03:20 <mm_freak> jmcarthur: what did you think about SDL's audio stuff?
11:03:28 <cmccann> windowing being a close second in terms of annoyance level.
11:03:46 <elliott> jmcarthur: the haskell binding or OpenAL itself?
11:03:52 <cmccann> OpenAL itself
11:03:52 <mm_freak> windowing for OpenGL apps isn't in such a bad situation actually
11:03:53 <jmcarthur> mm_freak: i am not very educated on it yet, but my understanding is that it's... okay but not great. easy to use, not much to do with it, no 3d sound, etc.
11:04:11 <mm_freak> hmm
11:04:28 <cmccann> jmcarthur: that is my impression of SDL's audio yes
11:04:54 <cmccann> I've never done anything fancier than BGM + simple SFX though
11:05:05 <mm_freak> seems like you want to build your own audio abstraction
11:05:13 <jmcarthur> schell: the haskell-game project is an effort we've started recently to put together a set of libraries to make it easy to get started making complete games in haskell
11:05:30 <jmcarthur> schell: also, the #haskell-game channel is a thing
11:05:39 <schell> awesome! once that's in place, let's have an annual haskell game jam!
11:05:47 <jmcarthur> i would love thaqt
11:05:49 <jmcarthur> *that
11:05:52 <luite> \o/
11:06:00 <DMcGill> I'd certainly join in
11:06:06 <dmwit> Hipmunk is nice.
11:06:18 <mm_freak> me too if i find enough time =)
11:06:19 * cmccann did pyweek a few times, that was fun.
11:06:20 <DMcGill> I just wrote a physics engine in sfml and netwire
11:06:21 <jmcarthur> that would be a great way to promote haskell as a viable way to make games
11:06:35 <DMcGill> although it probably would have been better to just give it to Ogre
11:06:42 <jmcarthur> once it's, you know, more in line with something i'd be comfortable promoting heavily for that purpose
11:06:48 <schell> yeah - then we'd have the game jam and john carmack on our side!
11:06:53 <jmcarthur> heh
11:07:07 <mm_freak> yeah, mr. carmack for the concepts, us for the actual code =P
11:07:16 <jmcarthur> aw
11:07:28 <schell> has anyone actually seen his code?
11:07:31 <schell> i couldn't find it
11:07:51 <eikke> *bump*
11:07:54 <mm_freak> i don't think so…  but he'll surely open-source it
11:07:54 <jmcarthur> it might be released eventually, but i don't think it is anywhere yet
11:07:55 <schell> i'd love to follow along
11:08:18 * hackagebot rematch 0.2.0.0 - A simple api for matchers  http://hackage.haskell.org/package/rematch-0.2.0.0 (TomCrayford)
11:08:20 <schell> hopefully he's in here now lurking
11:08:28 <mm_freak> however, he's still climbing the learning curve
11:08:56 <schell> which is endless, btw ;)
11:09:02 <ceti331> what are the barriers to some sort of structure inheritance aand/or the ability to use the same field names atleast for the same element of a tuple ... e.g. an accesor function which is always the 2nd element,applicable to any tuple size at least 2
11:09:16 <jmcarthur> yeah one of my fears is that the code will appear and everybody will treat it as a good example of good haskell code just because he's carmack
11:09:17 <hpc> :t _2
11:09:22 <lambdabot> (Functor f, Field2 s t a b, Indexable Int p) => p a (f b) -> s -> f t
11:09:33 <hpc> ceti331: virtually none, if you use lens
11:09:39 <DMcGill> that type signature can be seen as the barriers to such a function
11:09:40 <mm_freak> ceti331: such a thing exists, but it's not like what you would expect =)
11:09:55 <mm_freak> hehe right
11:09:57 <DMcGill> thankfully those barriers were crossed by one brave man
11:10:06 <hpc> ceti331: you can't generically write such a function
11:10:17 <hpc> but apparently someone went and did it for some subset of tuples
11:10:27 <mm_freak> jmcarthur: on the other hand he is very open to suggestions, as far as i've seen
11:11:01 <mm_freak> he doesn't seem to learn haskell just for the practical benefit
11:11:10 <FreeFull> `? lens
11:11:51 <ceti331> i think this issue stops me genuinely liking haskell
11:11:56 <elliott> > (1,2) ^. _2
11:11:58 <elliott> > (1,2,3,4,5) ^. _2
11:11:58 <jmcarthur> ceti331: ?
11:11:59 <lambdabot>   2
11:12:01 <lambdabot>   2
11:12:11 <elliott> tuples aren't really very useful anyway.
11:12:15 <elliott> beyond 2-tuples.
11:12:21 <elliott> and it's rare you'd want to work generically on them.
11:12:29 <mm_freak> ceti331: no, there is a good reason why such a thing can't exist the way you would like
11:12:40 <ceti331> but 'structures' seem hacked in as tuples with sugar for making accesors - that why i relate my question to tuples
11:12:40 <mm_freak> lenses are about as close as you can get
11:13:00 <elliott> you have a weird definition of hacked in
11:13:02 <jmcarthur> ceti331: data types are not quite tuples. they are entirely different types
11:13:04 <FreeFull> > [1,2,3] ^. _2
11:13:08 <lambdabot>   Could not deduce (Control.Lens.Tuple.Field2 [t0] [t0] a a)
11:13:08 <lambdabot>    arising from ...
11:13:12 <mm_freak> ceti331: well, think about it:  how well defined is "the second element of a structure"?
11:13:18 * hackagebot hunit-rematch 0.1.0.0 - HUnit support for rematch  http://hackage.haskell.org/package/hunit-rematch-0.1.0.0 (TomCrayford)
11:13:20 * hackagebot quickcheck-rematch 0.1.0.0 - QuickCheck support for rematch  http://hackage.haskell.org/package/quickcheck-rematch-0.1.0.0 (TomCrayford)
11:13:22 * hackagebot bytestring-rematch 0.1.0.0 - Rematch support for ByteString  http://hackage.haskell.org/package/bytestring-rematch-0.1.0.0 (TomCrayford)
11:13:24 <FreeFull> What's the second element of a tree?
11:13:24 * hackagebot rematch-text 0.1.0.2 - `rematch` matchers for Data.Text  http://hackage.haskell.org/package/rematch-text-0.1.0.2 (TomCrayford)
11:13:48 <ceti331> well if  the structure has a constructor ,it could be the 2nd constructor argument:)
11:13:55 <jmcarthur> FreeFull: the second element that you visit in some traversal of the tree
11:14:04 <ceti331> the nthtuple accessor could implement something like inheritance
11:14:11 <mm_freak> ceti331: that's not well-defined…  what makes the second constructor "the second element"?  i mean, what type would such a function have?
11:14:19 <jmcarthur> :t (!! 1) . Data.Foldable.toList
11:14:19 <Twey> Then you've thrown away opacity for convenience
11:14:23 <lambdabot> Foldable t => t c -> c
11:14:24 <mm_freak> + field
11:14:26 <FreeFull> jmcarthur: A tree doesn't necessarily only have one transversal though
11:14:44 <jmcarthur> FreeFull: no, but it has at least one (and for things like Foldable, a canonical one)
11:15:05 <ceti331> when working in raw ASM, you had make equates for structure offsets... they needed the little prefixes to disambiguate - but you could at least do something like  inheritance where the same named element wasin the same slot... maybe that would help make the record system feel less weird
11:15:33 <mm_freak> ceti331: what i'm trying to tell you is that from time to time someone complains that a certain feature doesn't exist, even though we had more than 20 years to add it to the language…  the question you should be asking is:  "why wasn't it added?"
11:15:39 <mm_freak> there is often a good reason
11:15:44 <ceti331> the rest of the time haskell seems awesome, it does seem like currying , small adhoc tuples savequite a bit of the cases where one creates structs/clasese inC i guess
11:16:08 <Hafydd> You can use arrays in C for that.
11:16:20 <FreeFull> ceti331: If you want to just change some values and keep the rest, record syntax allows that
11:16:28 <FreeFull> Adding new fields isn't as easy though
11:16:39 <Twey> I heard one of the many record proposals was to be implemented soon
11:16:45 <doomlord> i know that, i've seen the record modify syntax, iits good
11:17:06 <mm_freak> to me "adding new fields" is the same as "creating a new type with the additional fields"
11:17:36 <doomlord> creating a new typewith additional fields is fine, its exactly what i'm suggesting as an improvement thatshouldnt break anything else
11:17:37 <mm_freak> that's the only well-defined way to do it…  even the extensible record systems of other languages follow that rule
11:17:40 <Taneb> elliott, three-tuples are used in RWST
11:17:45 <Hafydd> (For example, UNIX's pipe())
11:17:49 <elliott> Taneb: and RWST isn't very useful either :P
11:17:57 <Taneb> :P
11:18:03 <doomlord> eg if you have a type vx,vy...  making a type   vx,vy,vz that inherits vx,vy acessors would be nice
11:18:34 <elliott> doomlord: lens has stuff for that, if you make a type containing the vx,vy type and add a vz field.
11:18:39 <elliott> it's not in the language itself, no
11:18:45 <mm_freak> doomlord: well, the new accessors would be called v2 . vx, v2 . vy, vz
11:18:46 <elliott> (and is tricky to get right)
11:18:47 <doomlord> window: name, position,size.   then inherit some control.. name,position,size, value. etc
11:18:51 <elliott> (e.g. for type inference)
11:18:58 <mm_freak> and with a small type class trick you can even get vx, vy and vz
11:19:08 <mm_freak> that's what the 'linear' library does anyway
11:19:21 <doomlord> ah yes i was about to ask about typeclasses,
11:19:33 <doomlord> is there some template-haskel macros to assist building them ?
11:19:36 <elliott> doomlord: (are you ceti331?)
11:19:47 <doomlord> yes
11:19:50 <elliott> ah, ok
11:20:13 <joeyh> elliott: thanks for the advice. ReaderT on Mvar with MonadCatchIO-transformers seems to be working out!
11:20:22 <doomlord> I've tried the approach of using the little prefixes.. its ok
11:20:40 <doomlord> i've also tried using types with anonymos members and destructuring.
11:20:47 <elliott> joeyh: :)
11:21:19 <doomlord> still feels weird having such an elegant langauge but then having to fudge around something so basic :(
11:23:45 <exicer> Is there some equivilant of python's slices for lists in Haskell ?
11:24:05 <dmwit> take/drop
11:24:21 <dmwit> Generally speaking, though, doing things with indices indicates you shouldn't be using lists.
11:24:50 <applicative_tmp> exicer: what sorts of things are your lists holding?
11:24:51 <exicer> Ah
11:24:58 <exicer> It's a sorted list of tuples
11:25:19 <copumpkin> indices are always evil!
11:25:21 <copumpkin> even without lists
11:25:23 <copumpkin> >_>
11:25:47 <exicer> Why?
11:25:52 <applicative_tmp> hm, tuples of what, exicer ?
11:26:09 * applicative_tmp is forever attempting to make a convert to Data.Vector.Unboxed ...
11:26:13 <exicer> applicative_tmp: (name, count)
11:26:20 <dmwit> Use Data.Map.
11:26:22 <exicer> Sorted on count
11:26:24 <applicative_tmp> name is a string?
11:26:31 <exicer> applicative: yes
11:26:32 <applicative_tmp> hm yes sounds like a Map
11:26:41 <exicer> Map is a hashmap ?
11:26:47 <applicative_tmp> no
11:27:03 <dmwit> "close enough"
11:27:13 <copumpkin> minus the hash
11:27:17 <copumpkin> so map is a map
11:27:27 <dmwit> It's also possible you want a priority queue, if you're keeping them sorted on count.
11:27:58 <exicer> I'll paste it, and you can tell me how wrong I am :)
11:28:00 <exicer> Just as ec
11:29:00 <donri> @hackage multiset is what it sounds like to me
11:29:00 <lambdabot> http://hackage.haskell.org/package/multiset is what it sounds like to me
11:29:27 <dmwit> Many things are possible.
11:30:17 <Guest55594> data Chain r q x y = Chain { into :: (forall a b. q a b -> r a -> r b)
11:30:17 <Guest55594> 						   , chain :: (r x -> r y)}
11:30:17 <Guest55594> (/>) :: Chain r q a b -> q b c -> Chain r q a c
11:30:17 <Guest55594> Chain f r /> r' = Chain f (r & (f r'))
11:30:19 <Guest55594> help me do this
11:30:25 <Guest55594> I need to write a -> m b as the type
11:30:29 <Guest55594> and I tried Kleisli
11:30:51 <exicer> http://hpaste.org/88222
11:30:51 <Taneb> You could have just used Control.Monad.(>=>)
11:30:54 <Guest55594> but then I can't write the type of the function from a -> m b -> Kleisli m a b
11:30:58 <exicer> It is for http://www.reddit.com/r/dailyprogrammer/comments/1e97ob/051313_challenge_125_easy_word_analytics/
11:31:22 <schell> anyone know who writes arcadianvisions.com?
11:32:06 <Guest55594> no but it's not just monads
11:32:09 <Guest55594> I want it to remain general
11:32:25 <Guest55594> and work for monads, comonads, functors, applicatives and what have you
11:32:36 <Guest55594> but literally the only problem is the inability to write the types
11:32:53 <copumpkin> Guest55594: that type seems wrong?
11:32:59 <copumpkin> [14:30:46] <Guest55594>	 but then I can't write the type of the function from a -> m b -> Kleisli m a b
11:33:03 <dmwit> exicer: That code looks pretty good to me.
11:33:04 <copumpkin> it looks like you forgot parentheses?
11:33:11 <copumpkin> (a -> m b) -> Kleisli m a b
11:33:15 <Guest55594> I know
11:33:17 <Guest55594> it doesn't matter
11:33:26 <Guest55594> the point is I need to be able to write the (a -> m b) type without a or b
11:33:37 <exicer> dmwit: Hah, thanks - but the result of topWords is a sorted list of (word, count) tuples - how should I best extract the top 3 ?
11:33:38 <copumpkin> this feels remarkably like an XY problem
11:33:40 <Guest55594> if it's just (a -> b) I can do that easily, but not with the extra thing in there
11:33:48 <Guest55594> they said that before, and fixed some things
11:33:51 <dmwit> exicer: take 3
11:33:58 <copumpkin> Guest55594: this isn't a problem with kleisli, it's a problem with your design if it's a problem
11:34:06 <Guest55594> but then I was told to use Kleisli which creates the same problems
11:34:09 <Guest55594> I haven't said it was
11:34:10 <elliott> schell: the footer suggests acowley
11:34:10 <dmwit> > take 3 [10..30]
11:34:11 <exicer> dmwit: Unfortunatley it is sorted descending - can I change the sort order?
11:34:13 <lambdabot>   [10,11,12]
11:34:13 <copumpkin> ah okay
11:34:14 <elliott> though perhaps it is another acowley
11:34:22 <exicer> Or is there an equivilant of take for the end of a list ?
11:34:22 <Guest55594> I know, with certainty that it is perfect so long as i can write the type
11:34:29 <dmwit> exicer: Either use "flip compare `on` snd" or call reverse.
11:34:30 <exicer> Or should I just reverse it ?
11:34:40 <Guest55594> that's literally the only problem
11:34:44 <copumpkin> Guest55594: I think it'd help if you stepped back a bit and explained what you were trying to do. It's quite possible that what you're trying to do is broken in some way?
11:34:44 <exicer> dmwit: Cool, thanks!
11:35:00 <Guest55594> I know that it works first of all. It's not broken and it works if I can write the type
11:35:02 <Guest55594> Secondly
11:35:15 <Guest55594> it's a generalization of some q on a and b -> f a -> f b
11:35:18 <Guest55594> and the composition
11:35:38 <copumpkin> well, perhaps you need a Category instance on it?
11:35:45 <dmwit> "Kleisli m" is "a -> m b" without the "a" or "b"
11:35:45 <Guest55594> so like functors have (a -> b) -> f a -> f b, monads (a -> m b) -> m a -> m b, comonads (w a -> b) -> w a -> w b
11:35:47 <copumpkin> since how else will you know how to compose both functions and kleisli?
11:35:57 <Guest55594> yes but then I have to form Kleisli m since it's a newtype
11:36:02 <dmwit> Yes.
11:36:03 <dmwit> So?
11:36:05 <Guest55594> and then I need to type that formation, which makes the same problem
11:36:13 <dmwit> huh?
11:36:20 <copumpkin> you can form new Kleisli from a composition of existing Kleislis
11:36:26 <dmwit> :t \f -> runKleisli . f . Kleisli
11:36:28 <lambdabot> (Kleisli m1 a1 b1 -> Kleisli m a b) -> (a1 -> m1 b1) -> a -> m b
11:36:39 <Guest55594> no but I need it to not necessarily be Kleisly
11:36:42 <copumpkin> yes
11:36:43 <Guest55594> it could be Cokleisli
11:36:47 <copumpkin> that's why I say you want a Category instance
11:36:49 <copumpkin> to compose them generally
11:36:59 <Guest55594> that might be it
11:37:29 <copumpkin> it might not be Category, but if you need some common behavior across similar-but-not-quite-the-same types, chances are you need some typeclass
11:37:33 <copumpkin> describing what you need out of those types
11:37:35 <Guest55594> in fact I'm probably trying to make category similar
11:37:41 <applicative_tmp> very kleisly of you
11:37:49 <Guest55594> Originaly I tried to make a typeclass
11:37:57 <Guest55594> but then I ran into similar problems
11:38:34 <Guest55594> I really don't need a typeclass so long as I can write the type though
11:38:39 <Guest55594> the entire type checks out
11:39:05 <Guest55594> all of it functions just fine
11:39:11 <Guest55594> but I can't write the type of anything that uses it
11:39:18 <Guest55594> that isn't like functor
11:39:24 <Guest55594> where it's just (->)
11:39:42 <copumpkin> yes, but think of it this way
11:39:46 <copumpkin> I could pass in (,) as your q
11:39:50 <copumpkin> and that doesn't make sense, does it?
11:40:03 <ocharles> Is Tekmo (reddit), Tekmo on IRC too?
11:40:08 <ocharles> @seen Tekmo
11:40:08 <lambdabot> Unknown command, try @list
11:40:09 <copumpkin> ocharles: occasionally
11:40:09 <Guest55594> you can still do that
11:40:10 <ocharles> feh.
11:40:19 <Guest55594> it'll just be const stuff
11:40:30 <elliott> preflex: seen tekmo
11:40:31 <preflex>  tekmo was last seen on #haskell 11 days, 14 hours, 4 minutes and 45 seconds ago, saying: Yeah
11:40:41 <copumpkin> Guest55594: hmm
11:40:43 <ocharles> elliott: thanks
11:41:16 <Guest55594> you'd have to have it be fmap const b
11:41:25 <Guest55594> or something other than fmap
11:41:35 <Guest55594> however you want
11:41:42 <Guest55594> I'll write one
11:43:22 <Guest55594> constCh :: Functor f => Chain f (,) a a
11:43:22 <Guest55594> constCh = Chain (\(a, b) -> fmap (const b)) id
11:43:33 <Guest55594> this is the first instance, using /> you can compose it to other things
11:43:42 <Guest55594> but it won't change values
11:43:45 <Guest55594> or something
11:44:13 <skyflash_> Hmm... trying persistent for first time.  "runMigration" errors with "No instance for (MonadLogger IO), but I have Control.Monad.Logger imported.  What gives I wonder.
11:44:39 <copumpkin> Guest55594: fooling with your type right now, gimme a bit
11:44:54 <dmwit> skyflash_: Perhaps you are expected to use a logging monad transformer.
11:45:10 <dmwit> Don't know for sure -- not an expert on persistent.
11:45:49 <skyflash_> dmwit: Would that be a different module?  I see an instance declaration for MonadLogger IO in Control.Monad.Logger.
11:46:09 <Guest55594> what I had there fmaps const of the first value over whatever
11:46:14 <dmwit> Really? The Hackage docs don't agree.
11:46:30 <copumpkin> Guest55594: hmm, I have another definition of your operator that seems to work :P
11:46:49 <Guest55594> consting to the last value
11:47:29 <Guest55594> can I see it?
11:47:31 <copumpkin> Chain f r /> x = c f (f x . r)
11:47:37 <dmwit> There's an instance MonadIO m => MonadLogger (LoggingT m), which I expect is what you're supposed to use.
11:47:51 <copumpkin> err, replace c with Chain
11:48:02 <Guest55594> that appears superficially to be the same thing I had in another order
11:48:27 <Guest55594> yeah that's exactly the same thing I had
11:48:31 <Guest55594> where (&) was flip (.)
11:48:35 <copumpkin> oh
11:48:38 <copumpkin> and yours doesn't work?
11:48:44 <Guest55594> it works fine
11:48:48 <Guest55594> without a single hitch
11:48:53 <Guest55594> but I can't represent the types to use it
11:49:11 <copumpkin> I don't get it :(
11:49:12 <Guest55594> unless they're simple like (->) for functor
11:49:17 <Guest55594> I can use that just fine,
11:49:23 <Guest55594> but if I want it to use monads instead
11:49:28 <dmwit> skyflash_: (You seeing my messages?)
11:49:32 <Guest55594> I have to say (a -> m b) with no a or b
11:49:38 <Guest55594> just like I said (a -> b) without a or b
11:49:49 <skyflash_> dmwit: Yes, sorry, looking at the docs...
11:50:01 <copumpkin> Guest55594: yeah, that's what Kleisli does. Can you give me a type signature that you can't write?
11:50:11 <Guest55594> well that
11:50:21 <copumpkin> I mean a complete thing that you'd expect to be able to implement but can't
11:50:21 <Guest55594> you can try using Kleisli
11:50:28 <skyflash_> dmwit: Well the error is definitely talking about a lack of "MonadLogger IO" and I see that in http://hackage.haskell.org/package/monad-logger-0.2.1
11:50:28 <Guest55594> but you'll find that you have to pass a Kleisli at each step
11:50:38 <Guest55594> and since you do that, it should be something you can automate
11:50:43 <skyflash_> dmwit: but maybe things aren't as simple as they seem
11:51:00 <Guest55594> but you can't write the type of the type of Kleisli
11:51:16 <skyflash_> dmwit: I have cut/paste from the persistent docs, but my copy won't compile.
11:51:44 <copumpkin> Guest55594: I don't think we're communicating effectively. You have a working fully polymorphic definition of your type.
11:51:46 <Guest55594> like just try to get it to put the Kleisli in there without restricting it down to monads
11:52:03 <Guest55594> the easiest way to explain it is to ask you to do this
11:52:09 <copumpkin> yes! that's what I want :)
11:52:28 <Guest55594> make it automatically convert them to Kleisli's iff they're monad and you give it a Kleisli
11:52:34 <Guest55594> but remain polymorphic
11:52:40 <Guest55594> and try to write the type for that
11:52:58 <copumpkin> no, you can't do that
11:53:05 <applicative_tmp> exicer: with Data.Map, you make the word count with something like M.fromListWith (+) . map ((\x -> (x,1::Int)) . filter isAlphaNum) . words
11:53:16 <dmwit> skyflash_: ghc-pkg list monad-logger?
11:53:20 <applicative_tmp> ah vanished
11:53:23 <Guest55594> I'm not explaining it well
11:53:40 <copumpkin> Guest55594: you can't magically make it pretend that the Kleisli isn't there when it isn't, and make it apply when it is
11:53:41 <Guest55594> cause you're thinking you can't do it for a different reason than I am
11:53:47 <dmwit> applicative_tmp: That doesn't really get it in sorted order, though, so I'm not sure it's better.
11:53:51 <skyflash_> dmwit: having a look...
11:53:59 <Guest55594> just make a version of this with Kleisly
11:54:00 <dmwit> applicative_tmp: I feel like his solution was elegant and clean.
11:54:03 <Guest55594> and try to remove the boilerplate
11:54:13 <copumpkin> that removing boilerplate is what I'm saying can't be done
11:54:20 <Guest55594> yeah cause the types
11:54:22 <copumpkin> the Kleisli stays
11:54:24 <copumpkin> yeah
11:54:25 <Guest55594> you'd haev to add a function to remove it
11:54:27 <Guest55594> er, to add it
11:54:30 <Guest55594> and that's fine
11:54:35 <Guest55594> but then you can't type the function to add it
11:54:36 <skyflash_> dmwit: yes, monad-logger-0.3.1.1
11:54:44 <Guest55594> which is the same problem
11:54:47 <dmwit> skyflash_: So why are you looking at the documentation for 0.2.1? =)
11:55:07 <copumpkin> Guest55594: I just want a concrete haskell type that you claim can't be written
11:55:15 <copumpkin> so I can tell you whether it can be or why it can't be
11:55:26 <dmwit> copumpkin: You're asking the wrong question.
11:55:33 <dmwit> copumpkin: Ask him for a term that he can't write down the type for.
11:55:38 <skyflash_> dmwit: because I didn't realise I had that version, obviously.  But now I see that this instance is missing.  Grr.
11:55:47 <copumpkin> dmwit: that can be your question then :)
11:55:59 <Guest55594> Not sure how to explain this
11:56:12 <dmwit> Guest55594: Give us a term you can't write down the type for.
11:56:15 <Guest55594> given an arbitrary * -> * -> * type
11:56:20 <Guest55594> actually
11:56:50 <Guest55594> write the * -> * -> * type of a -> m b
11:56:59 <Guest55594> not the function, the type
11:57:18 <copumpkin> Kleisli m >_>
11:57:20 <dmwit> :k Kleisli m
11:57:23 <lambdabot> Not in scope: type variable `m'
11:57:24 <Guest55594> noting that the * -> * -> *  of a -> b can easily be written as (->)
11:57:25 <dmwit> :k Kleisli []
11:57:29 <lambdabot> * -> * -> *
11:57:31 <Guest55594> but not Kleisli because that newtypes over it
11:57:34 <copumpkin> yes
11:57:38 <copumpkin> that's what I keep saying isn't avoidable
11:57:40 <Guest55594> the type by itself in a vacuum with no boilerplate
11:57:48 <Guest55594> but it would be if I could just write the type by itsef
11:57:59 <FreeFull> Why isn't there an   splitOn :: a -> [a] -> [[a]]   in the standard library ):
11:58:05 <copumpkin> no, even if you didn't need the Kleisli constructor, you'd still have issues
11:58:06 <dmwit> ?hackage split
11:58:06 <lambdabot> http://hackage.haskell.org/package/split
11:58:11 <Guest55594> like what?
11:58:51 <skyflash_> dmwit: Alright, thanks for the prod there.  I guess the sample code I'm supposed to learn from is out of date.  This happens all too often.  Oh well..
11:58:58 <copumpkin> Guest55594: parametricity
11:59:01 <dmwit> skyflash_: Ah, bummer. Sorry about that.
11:59:02 <copumpkin> you can't magically figure out what type you got
11:59:35 <Guest55594> that's why you have the function to do stuff with it
11:59:38 <FreeFull> dmwit: This library is perfect, actually
11:59:40 <Guest55594> that you can pass just fine
11:59:42 <copumpkin> Guest55594: say I give you Agda, and you can instantiate Q to \x y -> x -> m y
11:59:44 <Guest55594> but you can't name the type of
11:59:51 <copumpkin> now what?
12:00:05 <Guest55594> what do you mean now what?
12:00:25 <copumpkin> say the type I just wrote was valid haskell
12:00:30 <copumpkin> now what would you do with it?
12:00:38 <Guest55594> wait I understand now
12:00:57 <Guest55594> need the a a -> Q a a type
12:00:58 <Guest55594> forgot about that
12:01:16 <Guest55594> that doesn't take anything to add
12:01:49 <binaryunary> hi, would anyone agree to explain how Parsec's 'chainl' works to a beginner?
12:01:59 <Guest55594> er
12:02:05 <Guest55594> (a -> a) -> Q a a
12:02:15 <t4nk233> what does type inside a class mean?
12:02:17 <t4nk233> http://hpaste.org/88224
12:02:21 <dmwit> binaryunary: The official tutorial discusses it, doesn't it?
12:02:41 <dmwit> t4nk233: Read about the TypeFamilies extension; for more Google juice: "associated type families".
12:02:57 <binaryunary> I suppose it does, but I'm still stuck
12:03:24 <geekosaur> someone with a very similar nick asked that earlier...
12:03:25 <t4nk233> dmwit: I know that it has to do with TypeFamilies but I do not understand IType in the code
12:03:39 <binaryunary> I'm trying to parse binary operations (+, - etc.) into an AST
12:04:08 <Guest55594> that actually makes (,) appear to be impossible
12:04:11 <dmwit> t4nk233: The last line says that IType m is just shorthand for FactoredRepr (FactoredOf m).
12:04:15 <Guest55594> well, not really
12:04:18 <Guest55594> but somewhat
12:05:00 <copumpkin> yeah, my basic point is that there is some common property that Kleisli m, (->), Cokleisli w share
12:05:05 <copumpkin> and that's what you're missing
12:05:28 <t4nk233> dmwit: Oh I see
12:07:10 <midfield> quick question : is anyone who is on the libraries@haskell.org mailing list allowed to vote on proposals?
12:08:19 <int-e> midfield: yes
12:08:23 <Guest55594> actually wait
12:08:26 <Guest55594> nvm I didn't even need to add that
12:08:42 <Guest55594> copumpkin I was mistaken in thinking I need that
12:08:53 <Guest55594> you have to supply m a -> m b to create it
12:08:59 <Guest55594> and then only use m a -> m b
12:09:09 <midfield> int-e: i was trawling the wiki and couldn't find anything that said that
12:09:34 <Guest55594> all you need is the first one, which might be like doCh and that has all the information you need
12:09:41 <Guest55594> and you'd just need to pass it' a -> m b's
12:10:06 <Guest55594> then chain would pull out a final m a -> m z or whatever
12:13:13 <neothemachine> is it possible to do an 'cabal install --only-dependencies --flags="buildBenchmark"' without the flags getting inherited to the depedencies? my problem is that a dependency has a flag with the same name but I only want to set it for my own cabal project
12:14:00 <binaryunary> the problem I'm stuck with is here: http://pastebin.com/BJ1kHuQL
12:14:03 <mauke> The paste BJ1kHuQL has been copied to http://hpaste.org/88225
12:14:51 <exicer> Is there a more sensible way of getting the number of digits in an integer than converting it to string and using length ?
12:15:35 <Guest55594> continue beckoning copumpkin since his suggestion was unnecssary
12:16:17 <dmwit> exicer: logBase 10?
12:16:39 <exicer> dmwit: ...yeah that is more like it :p
12:16:46 <int-e> midfield: I'm sure if people start spamming votes they'll find soon that they have weight zero :) It's just hard to quantify "consensus".
12:17:02 <copumpkin> Guest55594: I'm not sure I made a particularly concrete suggestion :) my point is that you need more knowledge about those types, somewhere
12:17:05 <copumpkin> they can't just be anything at all
12:17:11 <copumpkin> perhaps not for composing/chaining
12:17:15 <copumpkin> but when pulling out or putting in, you do
12:17:42 <copumpkin> a -> b, a -> m b, and w a -> b are all pretty different types
12:17:43 <Guest55594> I don't need knowledge about htem
12:17:45 <Guest55594> you can use them
12:17:56 <Guest55594> once you have the 'head' of it, you can compose it with whatever
12:18:02 <copumpkin> sure
12:18:08 <copumpkin> but to put the head in, you need something?
12:18:20 <Guest55594> what do you mean?
12:18:26 <Guest55594> I can make the head easily, I just can't type it
12:18:35 * copumpkin sighs
12:18:50 <Guest55594> I don't think we're communicating
12:19:02 <copumpkin> my question still stands
12:19:02 <Guest55594> if you give me arbitrary type, that is valid haskell, then a head can be made for it
12:19:10 <Guest55594> to put the head in, you need nothing
12:19:14 <copumpkin> if you did have the power to do without Kleisli or Cokleisli
12:19:16 <Guest55594> except the head
12:19:18 <copumpkin> how would you use that power?
12:19:30 <copumpkin> in Agda it's easy to avoid those newtypes
12:19:32 <Guest55594> you'd simply use /> to attach it to an a -> m b or w a -> b
12:19:36 <Eduard_Munteanu> World domination, clearly. :P
12:19:46 <Guest55594> like you can do with a -> b or (a, b) with that const
12:19:58 <copumpkin> how about b -> a?
12:20:18 <palmfrond_> is it bad to write code that looks like this? http://hpaste.org/88226
12:20:46 <copumpkin> this all feels vaguely yonedaish
12:20:54 <Guest55594> yonedaish?
12:21:08 <copumpkin> where does this come from?
12:21:25 <binaryunary> I understand the chainl examples in Parsec's docs but I'm not really sure how to transfer this to my custom types
12:21:47 <Guest55594> okay not sure about that b -> a thing
12:21:57 <Guest55594> resembles a backwards lens though
12:22:13 <dmwit> palmfrond_: Why not something like problem4 = undigitify . maxList . filter isPalindrome . ... . reverse $ [900 .. 999] ?
12:22:17 <copumpkin> what are exmaples of making new Chain values?
12:22:19 <Guest55594> of course that one's too generic to do anything with
12:22:28 <Guest55594> what do you mean new chain values
12:22:30 <dmwit> palmfrond_: If you want to name things, name (foo . bar) chunks, not applications of (foo . bar) to a value.
12:22:35 <Guest55594> f :: (Functor f, Num n) => Chain f (->) n n --(forall a b. (a -> b) -> f a -> f b, f n -> f n)
12:22:35 <Guest55594> f = Chain fmap id />
12:22:35 <Guest55594> 	(+1) />
12:22:35 <Guest55594> 	id
12:22:42 <Guest55594> there's a very simple fmap one
12:22:52 <osa1> is there a standard function for `map fromJust . filter isJust` ?
12:22:58 <palmfrond_> dmwit: ok, thanks
12:22:58 <Guest55594> ignore that comment
12:22:59 <copumpkin> Chain fmap id is what I'm talking about, thanks
12:23:20 <ion> > catMaybes [Nothing, Just 42, Nothing, Just 43]
12:23:22 <palmfrond_> dmwit: are the dots just function application or are they something different?
12:23:23 <merijn> osa1: catMaybes?
12:23:23 <lambdabot>   [42,43]
12:23:25 <Clint> osa1: mapMaybe?
12:23:25 <merijn> :t catMaybes
12:23:28 <Guest55594> they all have id for that, since fmap id == id
12:23:28 <lambdabot> [Maybe a] -> [a]
12:23:30 <Guest55594> and such
12:23:33 <osa1> ah, thanks
12:24:38 <Guest55594> the id at the end is inconsequential
12:25:18 <int-e> palmfrond_:  undigitify . maxList . filter isPalindrome . map digitify . concatMap expand . elemMult . reverse $ [900 .. 999] -- if I matched the names correctly
12:25:20 <dmwit> palmfrond_: dots are function composition
12:25:29 <dmwit> ?src (.)
12:25:29 <lambdabot> (f . g) x = f (g x)
12:25:29 <lambdabot> NB: In lambdabot,  (.) = fmap
12:25:52 <palmfrond_> dmwit: so it's okay to have huge chains of functions like that?
12:26:02 <dmwit> palmfrond_: It's not just okay -- it's encouraged!
12:26:03 <copumpkin> Guest55594: how would you build a Chain value for Kleisli, assuming you could avoid using the Kleisli newtype?
12:26:27 <int-e> palmfrond_: and that's the point, I think - introducing a fresh name for something that is only used once often does not improve readability.
12:28:29 <Guest55594> I had had it commented before
12:28:36 <Guest55594> but I must have deleted it, hodl on
12:28:52 <binaryunary> so, could anyone explain chainl like I'm five?
12:28:53 <copumpkin> into :: forall a b. (a -> m b) -> (r a -> r b), chain :: r x -> r y
12:28:59 <copumpkin> that's what it would expand to, right?
12:29:43 <Guest55594> no it would expand to : into :: forall a b. (Kleisli m a b) -> (m a -> m b), chain :: m x -> m y
12:29:54 <copumpkin> I'm saying if you didn't have to be shackled by the newtype :P
12:30:01 <copumpkin> which seems to be your main complaint?
12:30:03 <Guest55594> I still do have this: methodCh :: (Comonad m) => Chain m (Cokleisli m) a a
12:30:03 <Guest55594> methodCh = Chain ((extend) . runCokleisli) id
12:30:21 <Guest55594> since I never bothered changing tha tyet
12:30:41 <copumpkin> oh, so they have to be the same type
12:30:49 <copumpkin> Chain m (Cokleisli m)
12:30:54 <copumpkin> it's more restricted
12:31:14 <copumpkin> I can see how that would work, but the more general one had me stumped
12:31:21 <FreeFull> What's the easiest way to take a json string and extract some values from it?
12:31:25 <Guest55594> doCh :: (Monad m) => Chain m (Kleisli m) a a
12:31:25 <Guest55594> doCh = Chain ((=<<) . runKleisli) id
12:31:26 <Guest55594> while I'm at it
12:31:50 <Guest55594> but whenver you pass a monad you have to wrap Kleisli around it
12:32:08 <Guest55594> and in order to try to remove that boiler plate you'd have to type the type of Kleisli
12:32:18 <Guest55594> polymorphically
12:32:34 <copumpkin> yes, but do you see what I'm saying? you're forcing those two types to be the same there
12:32:42 <copumpkin> which isn't the case for the plain function
12:33:03 <Guest55594> ?
12:33:16 <copumpkin> this leads back to my broader point, which is that even without the Kleisli/Cokleisli boilerplate, you'd still need to decide what to do based on the type
12:33:25 <copumpkin> in one case you need extend, in another you need (=<<), in another you need just fmap
12:33:36 <Guest55594> yeah, those are in the head
12:33:40 <Guest55594> and are passed around by />
12:33:45 <Guest55594> and applied to each
12:33:46 <copumpkin> (Monad m) => Chain m (Kleisli m) a a vs. Functor f => Chain f (->) a a
12:33:58 <copumpkin> I don't doubt that
12:34:06 <copumpkin> you have a working definition of /> :P
12:34:07 <Guest55594> and ideally I'd pass Kleisli too, but I can't type it to pass it around
12:34:10 <dmwit> Chain f (->) a (f a), presumably
12:34:20 <Guest55594> it's Chain f (-> a a
12:34:23 <Guest55594> it's Chain f (->) a a
12:34:39 <Guest55594> the second type is also wrapped under f
12:34:59 <Guest55594> it's just that they're both a because this is effectively the mempty of the type as in id
12:35:08 <Guest55594> which other things are appended onto using />
12:35:21 <Guest55594> whose type depends on the initial type passed
12:35:34 <Guest55594> so for functors it's a -> b, monads it'd b ideally a -> m b, comonads w a -> b
12:35:48 <copumpkin> so I'm not sure what the problem is anymore :)
12:35:58 <Guest55594> I can't type a -> m b without a or b
12:36:08 <Guest55594> like I'd need to to give the type of the head
12:36:14 <copumpkin> yes, but what would you do if you could type that? :P
12:36:17 <copumpkin> is what I keep asking
12:36:21 <Guest55594> you append monads to it
12:36:34 <Guest55594> basically it's like >>= but for everything
12:36:50 <Guest55594> or do blocks
12:37:28 <copumpkin> yeah, but presumably when you tell me that it would work fine if you could just get the type in, you've tried this on paper and have worked through the details to see that it's literally just the newtype that's screwing you?
12:37:46 <Guest55594> pretty much
12:38:03 <nomeata> Hi. Is there a way to run a Cabal test suite against an installed instance of the library?
12:38:10 <Guest55594> I can see that the types work out at each step
12:38:16 <Guest55594> and I can know what the type is
12:38:21 <Guest55594> but the language won't let me express it
12:38:27 <Guest55594> and the logic works out
12:38:38 <copumpkin> Guest55594: so how would your "general doCh" look if you didn't have newtypes?
12:38:48 <exicer> Why is this invalid?  digits n = mod n 10 ^ (round $ logBase 10 n)
12:38:50 <copumpkin> can you put that in hpaste.org or something?
12:38:56 <Guest55594> I'm not sure what you mean how would it look
12:39:07 <Guest55594> doCh = Chain (=<<) id
12:39:11 <Guest55594> that would be the implementation
12:39:31 <Guest55594> you would have doCh /> something a-> m b /> something b -> m c
12:39:38 <copumpkin> ah, and Chain extend id and Chain fmap id ?
12:39:40 <geekosaur> :t logBase
12:39:42 <lambdabot> Floating a => a -> a -> a
12:39:43 <Guest55594> yup
12:39:45 <dmwit> exicer: Convert your "n" into something that you can take the log of first.
12:39:56 <dmwit> exicer: logBase 10 (fromIntegral n) or similar
12:40:02 <copumpkin> Guest55594: so you'd have three different functions to build the "initial" chain?
12:40:11 <Guest55594> yup
12:40:20 <Guest55594> or more, if you want to add other such types
12:40:27 <Guest55594> like that weird (,) one
12:40:31 <FreeFull> I think the problem with Aeson is that it's designed for efficiency
12:40:41 <FreeFull> Rather than the simplicity I want
12:40:45 <dmwit> exicer: Also, you probably want div, and more parentheses. But that's just a guess.
12:40:46 <Guest55594> which was really just weird typed consts
12:40:58 <Guest55594> since that was the only possible implementation
12:41:10 <dmwit> ...orr... never mind, I just have no idea what you're trying to do. =P
12:41:14 <copumpkin> Guest55594: okay, that helps me a bit, gimme a few to tinker some more
12:41:46 <exicer> dmwit: If I remove the mod stuff, it is fine - adding mod n makes it stop compiling ;s
12:41:56 <merijn> :t mod
12:41:58 <lambdabot> Integral a => a -> a -> a
12:42:03 <merijn> :t logBase
12:42:05 <lambdabot> Floating a => a -> a -> a
12:42:05 <dmwit> exicer: Yes. Did you see the suggestion I made for getting it to work?
12:42:08 <exicer> Ohhh
12:42:11 <exicer> Sorry, yes
12:42:12 <merijn> :t (^)
12:42:14 <lambdabot> (Integral b, Num a) => a -> b -> a
12:42:23 <merijn> :t round
12:42:27 <lambdabot> (Integral b, RealFrac a) => a -> b
12:42:30 <dmwit> exicer: Adding mod makes your n less polymorphic.
12:42:40 <Guest55594> it might even be possible to make it a monad itself in a way and steal do syntax for everyone
12:43:18 <Guest55594> probably not
12:46:44 <copumpkin> Guest55594: I think I have something that might work for you
12:48:20 * hackagebot hakyll-agda 0.1.4 - Wrapper to integrate literate Agda files with Hakyll  http://hackage.haskell.org/package/hakyll-agda-0.1.4 (FrancescoMazzoli)
12:48:24 <Guest55594> tension buildup
12:48:58 <copumpkin> try http://hpaste.org/88228
12:49:46 <Guest55594> yay, requires more work but yay
12:49:55 <copumpkin> my confusion was around the identity thing
12:50:05 <copumpkin> I thought you wanted that to be genric
12:50:14 <copumpkin> and while it can be, that doesn't really infer nicely here :)
12:50:35 <Guest55594> yeah I'm not going to bother putting that in the class
12:50:42 <copumpkin> yeah
12:50:57 <Guest55594> since it's just that the head doesn't have any functions on it
12:51:44 <k0ral_> Hello, say I have "class A m where f :: m Int; f = return 0", I'd like to define "class (A m) => B m where g :: m Int" such that for any instance of class B, f = g ?
12:52:44 <k0ral_> redefining f in the class B doesn't compile as duplicate definition of f
12:53:12 <Guest55594> now just to do the stuff and switch //> with /> for neatness
12:53:17 <redneckcoder> Does the haskell runtime system incorporat support to explicitly make a process to be executed on oone core and one process on another?
12:54:58 <luite> redneckcoder: yes
12:55:26 <geekosaur> k0ral_, I think you have your causality reversed. class B m where g :: m Int; instance B m => A m where f = g
12:55:42 <jmcarthur> redneckcoder: the threaded runtime does
12:55:46 <luite> redneckcoder: see forkOn, but you need to run your process with the right number of capabilities
12:55:50 <enigmuriatic> > [[x,y] | x <- ['a'..'z'], y <- ['a'..'z']]
12:55:53 <lambdabot>   ["aa","ab","ac","ad","ae","af","ag","ah","ai","aj","ak","al","am","an","ao"...
12:55:59 <geekosaur> um. do we mean process here, or thread?
12:56:00 <dmwit> k0ral_: Use a modern GHC and the default signatures extension.
12:56:17 <copumpkin> > replicateM 2 ['a'..'z'] -- enigmuriatic
12:56:19 <lambdabot>   ["aa","ab","ac","ad","ae","af","ag","ah","ai","aj","ak","al","am","an","ao"...
12:56:21 <jmcarthur> luite: doesn't forkOS create a new OS thread regardless of -N (as long as you linked with -threaded)?
12:56:31 <dmwit> jmcarthur: No.
12:56:31 <copumpkin> no
12:56:40 <enigmuriatic> why does that same list comprehension leave me with a bunch of weird backslashes when I do it in GHCi?
12:56:43 <copumpkin> it does very little of what most people expect it to do
12:56:45 <Guest55594> I should take chain onto the head
12:56:46 <enigmuriatic> > length [[x,y] | x <- ['a'..'z'], y <- ['a'..'z']]
12:56:47 <jmcarthur> oh it's just a bound thread
12:56:48 <copumpkin> it should be named something else
12:56:48 <lambdabot>   676
12:56:51 <dmwit> jmcarthur: forkOS promises that the code that's forked never changes OS thread, nothing more.
12:56:54 <Guest55594> so that it hides all the things away
12:56:55 <jmcarthur> right
12:57:00 <copumpkin> it's not even that
12:57:03 <copumpkin> it's just about FFI calls
12:57:10 <copumpkin> they're guaranteed to be made from the same OS thread
12:57:13 <shachaf> I think forkOS's implementation does always fork an OS thread, though?
12:57:14 <copumpkin> everything else is the same
12:58:12 <jmcarthur> i always relearn this fact every time i encounter forkOS
12:58:18 <jmcarthur> and then i promptly forget
12:58:19 <copumpkin> yeah, someone should propose renaming it
12:58:20 * hackagebot hakyll-agda 0.1.5 - Wrapper to integrate literate Agda files with Hakyll  http://hackage.haskell.org/package/hakyll-agda-0.1.5 (FrancescoMazzoli)
12:58:23 <yitz> k0ral_: even the way geekosaur says, it's still not a guarantee, only a default if a different instance is not supplied.
12:58:24 <copumpkin> like forkFFI
12:58:27 <copumpkin> :P
12:58:32 <jmcarthur> why not just forkBound
12:58:40 <copumpkin> because that isn't really what it is
12:58:45 <jmcarthur> "bound" is well-defined, isn't it?
12:58:46 <copumpkin> as I just pointed out :P
12:58:46 <elliott> forkReadTheDocs
12:58:51 <yitz> k0ral_: why do you want a different class? why not just use the method in the existing class?
12:59:03 <jmcarthur> i thought a bound thread really was just a thread which always uses the same OS thread for FFI calls
12:59:22 <copumpkin> oh, if you define it that way sure
12:59:29 <jmcarthur> that's what i thought the definition was
12:59:32 <copumpkin> but in general, I'd expect it to do all its work in a fixed OS thread
12:59:35 <copumpkin> which isn't the case
12:59:36 <yitz> elliott: it is ironic that that would be an impure function
12:59:47 <copumpkin> and performance-sensitive people might then overuse it expecting to do a better job than the scheduler
12:59:56 <geekosaur> if it is. could also be a thread which itself can migrate, but if it makes an FFI call that call is always migrated to a specific OS thread?
12:59:59 <jmcarthur> "A bound thread is a haskell thread that is bound to an operating system thread. While the bound thread is still scheduled by the Haskell run-time system, the operating system thread takes care of all the foreign calls made by the bound thread."
13:00:08 <copumpkin> sure, but that isn't the more general definition
13:00:13 <copumpkin> which is why I think it would be misleading
13:00:17 <k0ral_> geekosaur: this requires undecidable instances
13:00:26 <geekosaur> that would be correct
13:00:34 <geekosaur> you might want to think about why
13:00:36 <k0ral_> geekosaur: which is bad, isn't it ?
13:01:06 <geekosaur> k0ral_, what you are asking to do is dubious; the compiler is just informing you of that
13:01:11 <k0ral_> I mean, it basically says "anything shaped like "X m" is instance of A
13:01:19 <yitz> k0ral_: it is definitely naughty. whether it is bad depends on what you are doing with it
13:01:47 <k0ral_> dmwit: could you be a little more specific please ?
13:02:23 <k0ral_> geekosaur, yitz: basically, A is "Database", and B is "FileDatabase"
13:02:41 <geekosaur> this smells like typeclasses for OO all of a sudden
13:02:46 <k0ral_> geekosaur, yitz: Database only defines abstract commands like "readEntry" and "writeEntry"
13:03:08 <geekosaur> hint: this is not subclassing
13:03:10 <k0ral_> geekosaur, yitz: FileDatabase should implement them using filesystem
13:03:54 <yitz> k0ral_: FileDatabase sounds like a type, not a typeclass.
13:04:52 <dmwit> k0ral_: class A m where aGet :: m Int; aGet = bGet; class B m where bGet :: m Int -- this works with -XDefaultSignatures
13:05:08 <dmwit> ...I think.
13:05:28 <dmwit> Oh, you need to add
13:05:37 <dmwit> default aGet :: B m => m Int
13:05:43 <dmwit> in the class declaration for A
13:05:56 <yitz> > replicateM 2 ['a'..'z'] -- enigmuriatic
13:05:59 <lambdabot>   ["aa","ab","ac","ad","ae","af","ag","ah","ai","aj","ak","al","am","an","ao"...
13:07:21 <dmwit> ...and of course declare your subtyping however you want.
13:07:26 <dmwit> subclassing, I mean
13:07:51 <Guest55594> copumpkin: doCh :: (Monad m) => (Chained (Kleisli m) a b) -> m a -> m b
13:07:51 <Guest55594> doCh f = chain ((Chain ((=<<) . runKleisli) id) /> f)
13:07:56 <Guest55594> even better now
13:08:11 <Guest55594> I can just say doCh f /> g /> h/> and get m a -> m b out if
13:08:17 <Guest55594> like if it were do syntax
13:08:39 <Guest55594> without having to stick the extra chain on it
13:08:48 <Guest55594> or any other boiler plate
13:09:40 <Guest55594> it's so great
13:12:04 <k0ral_> yitz: I don't see why, basically, my FileDatabase only provides "getDataFile :: m FilePath", and I want that to be sufficient to derive "readEntry" and "writeEntry"
13:16:11 <copumpkin> Guest55594: cool :)
13:16:28 <Guest55594> thank you so much
13:16:36 <copumpkin> no problem, glad it worked!
13:16:56 <Zenol> Hi
13:17:59 <Zenol> Just to know, a * a' + b ' * b' with a, a', b, b' :: Double create thunks or not?
13:18:15 <jmcarthur> it might
13:20:48 <Zenol> jmcarthur> And if i was using a data SpecialType = SpecialType !Int, and building a SpecialType (a * a' + b' * b), then?
13:21:38 <Zenol> jmcarthur> I mean, the a * a' + b * b' will create a + thunks and "inside" two * thunks?
13:21:50 <jmcarthur> Zenol: assuming you meant data SpecialType = SpecialType !Double, it still might, or might not. it depends on context and optimizations.
13:22:02 <jmcarthur> Zenol: with optimizations, it is unlikely that each of those operations will create thunks
13:22:18 <jmcarthur> Zenol: the entire result might live under a thunk, though
13:23:12 <Zenol> jmcarthur> And if I do not use "strict" type, then with optimisation, does GHC will always compute thunks, or maybe not?
13:23:35 <jmcarthur> Zenol: it still depends on context and optimizations
13:23:54 <jmcarthur> Zenol: if you ever find yourself needing to know, you can always dump ghc core
13:24:40 <jmcarthur> Zenol: i recommend doing it in context though, since inlining can make even functions that look inefficient more efficient at call sites
13:24:51 <jmcarthur> Zenol: this is why it's hard to answer your question directly
13:27:04 <Zenol> jmcarthur> Hum, something like dotProduct (a, b, c) (a', b', c') = a * a' + b * b' + c * c', typed (Double, Double, Double) -> (Double, Double, Double) -> double. (Nb : I'm not trying to optimise anything, and I will not try tu use strict types untill ghc profiling show me that I realy need it. It's just for a better understanding of lazyness)
13:27:33 <jmcarthur> Zenol: actually i think using strict types when it makes semantic sense for them to be strict is wise
13:28:27 <jmcarthur> Zenol: if your dot product is not inlined, the result might be a thunk, and each field might be a thunk. if it's inlined, some of those thunks might be optimized away
13:28:40 <Zenol> jmcarthur> But I don't know if it should be struct or lazy. Maybe it's better for him to be lazy, maybe not.
13:28:52 <jmcarthur> Zenol: you get an intuition after a while
13:29:22 <jmcarthur> Zenol: but one way to think about it is just the straightforward question of whether you ever want the field to *not* be evaluated when the head of the data structure is evaluated
13:31:06 <Zenol> jmcarthur> Computing values of such fields can be really expensive, so I wan't to avoid to compute useless values. But I don't know that if I open the (), I'll always really need to compute the values.
13:34:12 <Zenol> jmcarthur> Anyway, thank you, I hope one day I'll understand how lazyness is working :)
13:47:15 <Zenol> Another question. If somewhere I call a function f, with some arguments, let's say f a b. And somewhere else, I also call f a b. Will GHC (with optimisation enabled) calculate only once the result?
13:47:51 <ATuin> where is defined >=>?
13:48:46 <monoidal> ATuin: Control.Monad
13:48:53 <monoidal> @hoogle (>=>)
13:48:53 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
13:48:58 <monoidal> ATuin: ^
13:49:01 <ATuin> oh :)
13:49:05 <ATuin> thanks
13:50:00 <ATuin> so looks like any kind of monad composer
13:51:05 <jmcarthur> Zenol: not in general
13:51:42 <Zenol> jmcarthur> So it's better that I call it once, and then use the returned value. Thanks :)
13:51:55 <jmcarthur> Zenol: you are probably either thinking of memoization or commen subexpression elimination. thunks aren't really memoization, and while ghc does do CSE, it only does so under very specific circumstances
13:52:05 <jmcarthur> Zenol: yes, it is better to make the sharing explicit
13:52:22 <jmcarthur> *common
14:09:34 <Kaidelong> I need a group typeclass. I could just mke my own but I figure it's way better if I import a library instead that provides it
14:09:49 <Kaidelong> what would you guys recommend?
14:10:38 <Zenol> La partie 2 progresse http://cochoy-jeremy.developpez.com/articles/haskell/haskell_rt_p2/ :)
14:10:47 <Zenol> Upse, sorry, wrong chan -_-
14:11:12 <Zenol> really sorry.
14:15:52 <jmcarthur> Kaidelong: there's always the algebra package
14:16:09 <jmcarthur> Kaidelong: it's pretty crazy though (but i've seen crazier for sure)
14:16:23 <Kaidelong> it is a shame nothing to do this is blessed by the prelude
14:16:30 <Kaidelong> err
14:16:33 <Kaidelong> by the haskell platform
14:18:58 <Kaidelong> also wow yes that's a little bit overkill for what I'm doing
14:19:03 <ATuin> to get overloaded methods is mandatory a type class, isnt it?
14:19:12 <Kaidelong> yes
14:20:00 <Kaidelong> it's not as powerful as some other overloading mechanisms but it also prevents the type inference algorithm from having to just stop wherever there is any overloading as in some things like F#
14:20:50 <ATuin> Kaidelong: ok, i suppose then that a function keeps just one signature
14:21:15 <Pranz> Can someone help me with a problem?
14:21:16 <Pranz> testDays :: [Int] -> [WeekDay]
14:21:16 <Pranz> testDays = map (getWeekDay . read . ("2013-05" ++) . show)
14:21:24 <Pranz> This function gives an error
14:21:42 <Pranz> at runtime
14:21:44 <Pranz> Exception: Prelude.read: no parse
14:22:04 <Kaidelong> hmm, should it be "2013-05-"?
14:22:23 <neutrino> yeah..
14:22:25 <Pranz> oh damn
14:22:28 <Pranz> i'm stupid
14:22:29 <Pranz> thanks
14:23:40 <Kaidelong> ugh well, I suppose I'll make my own Group library.
14:23:55 <Kaidelong> groups-instances I guess
14:23:59 <Kaidelong> I'll just import groups
14:24:03 <Kaidelong> and then add some instances
14:25:34 <zRecursive> @instances Monoid
14:25:35 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
14:26:18 <aristid> :t All
14:26:20 <lambdabot> Bool -> All
14:27:00 <zRecursive> what's the usage of 'Endo a' ?
14:27:12 <arkeet> zRecursive: newtype Endo a = Endo (a -> a)
14:27:42 <zRecursive> arkeet: why do we need it ?
14:27:54 <aristid> zRecursive: need?
14:27:59 <arkeet> maybe you want to use monoid stuff to compose functions.
14:28:09 <aristid> it's a valid monoid, isn't that enough? :)
14:28:22 <Chousuke> zRecursive: you will never know until you do, one day :P
14:28:37 <arkeet> > appEndo (foldMap Endo [(+1), (*2)]) 3
14:28:38 <zRecursive> for example ?
14:28:39 <lambdabot>   7
14:28:43 <arkeet> I dunno.
14:28:44 <Chousuke> aristid: that must be the reason for a lot of stuff in category-extras
14:28:52 <ocharles> http://ocharles.org.uk/blog/posts/2013-02-12-quick-dsls-with-endo-writers.html is Endo in action
14:28:58 <arkeet> thanks
14:28:59 <aristid> Chousuke: you realize that package is deprecated?
14:29:24 <ocharles> Endo can be very nice when paired with Writer (or really anything that is parameterized over a Monoid)
14:29:25 <Chousuke> aristid: I don't use it, I just happened upon it when googling some stuff today.
14:30:00 <Chousuke> I don't even know what half of the stuff there is, much less what you could use them for :P
14:30:03 <arkeet> :t Endo . mappend
14:30:05 <lambdabot> Monoid a => a -> Endo a
14:30:16 <arkeet> :t ($ mempty) . appEndo
14:30:20 <lambdabot> Monoid c => Endo c -> c
14:30:35 <edwardk> zRecursive: Endo is useful because it is how you recover things like foldr and foldl from foldMap. It also has a lot of other applications
14:30:45 <asante> is it expected behaviour, that "Data.Bits.popCount (-1)" does not terminate?
14:30:46 <shachaf> @ty Endo . flip mappend
14:30:49 <lambdabot> Monoid a => a -> Endo a
14:30:58 <edwardk> aristid: most of what was in there has been split out into other packages
14:31:01 <shachaf> asante: On Integer?
14:31:02 <zRecursive> edwardk: thanks
14:31:21 <edwardk> asante: how many 1's are there in the 2s complement representation of an arbitrary precision Integer?
14:31:34 <edwardk> asante: there are infinitely many, it takes a while to count them all ;)
14:31:35 <aristid> edwardk: i thought it was only a small fraction that was actually ported, so good to know it was the majority :)
14:31:59 <edwardk> :t popCount
14:32:01 <lambdabot> Bits a => a -> Int
14:32:04 <edwardk> > popCount (-1 :: Int)
14:32:06 <asante> edwardk: ah ok, so ghc does not use normal Int for (-1) by default?
14:32:06 <lambdabot>   64
14:32:13 <arkeet> Integer is the default.
14:32:18 <ocharles> asante: compile with -Wall and you'll see where it defaults
14:32:20 <shachaf> This is Haskell, not just GHC.
14:32:21 <asante> ok, thanks
14:32:27 <edwardk> asante: defaulting fired because the only constraint on there was Num, therefore 'Integer' was selected.
14:32:45 <edwardk> > 12313918230912830123102
14:32:47 <lambdabot>   12313918230912830123102
14:32:51 <edwardk> that way things like that get full precision
14:32:56 <arkeet> > 2^128
14:32:58 <lambdabot>   340282366920938463463374607431768211456
14:33:05 <asante> ^^ ok, i got it ;)
14:35:16 <Kaidelong> is there a package somewhere that people use that defines an instance Monoid m, Ord k => Monoid (Map k m)
14:35:58 * copumpkin fumes
14:36:03 <copumpkin> Kaidelong: no, and people don't want to change the default instance
14:36:05 <copumpkin> it pisses me off
14:36:06 <zenware> is anyone here familiar with artificial neural networks?
14:36:21 <ocharles> copumpkin: even though it's the one that (at least my) intuition expects
14:36:36 <jmcarthur> there are at least three possible instances for Monoid (Map k m)
14:36:38 <copumpkin> yes, the current one is basically that one with m = First m
14:36:40 * ocharles mappend the fuming
14:36:44 <ocharles> mappends*
14:37:05 <Kaidelong> oh god, do you mean to tell me Map already has a horribe monoid instance?
14:37:08 <copumpkin> yes
14:37:16 <edwardk> Kaidelong: it uses union not unionWith mappend
14:37:16 <ocharles> you could newtype it away though
14:37:27 <Kaidelong> doesn't sound like I have a choice
14:37:56 <copumpkin> yes
14:38:00 <copumpkin> join me in fuming
14:38:03 <Kaidelong> yeah, what were they thinking, really
14:38:12 <copumpkin> there's a fairly long thread on libraries
14:38:21 * hackagebot snap-predicates 0.3.0 - Declarative routing for Snap.  http://hackage.haskell.org/package/snap-predicates-0.3.0 (ToralfWittner)
14:38:22 <copumpkin> in which I (or someone else?) tried to argue for changing it
14:38:51 <aristid> change means incompatibility so i can kind of understand why they'd resist that
14:38:57 <aristid> but why is it this way to begin with?
14:39:17 <copumpkin> lack of foresight?
14:39:18 <copumpkin> same reason for all the shit we have to put up with now
14:41:05 <aristid> i guess Data.Map is not the best example of future-proof library design anyways
14:43:17 <Zenol> jmcarthur> Hum, I can't actualy call it once (without rewriting a big peace of code). I call a function stored un a data Object type, inside a function computeSomething :: Object -> b, by applying computeSomething on an [Object] list with map.
14:43:51 <Zenol> jmcarthur> Maybe this case have it's chance to be optimised?
14:44:04 <copumpkin> I'd want Data.Map :: (* -> *) -> *
14:44:24 <copumpkin> and then FixedMap (yay blast from the past) :: * -> * -> *
14:44:45 <jmcarthur> copumpkin: you mean where it takes a parameterized key or something?
14:44:49 <copumpkin> yeah :P
14:44:50 <jmcarthur> e.g. GADT?
14:44:52 <arkeet> copumpkin: why (* -> *) -> *?
14:45:03 <copumpkin> so I can store different kinds of values in it
14:45:06 <arkeet> hmm
14:45:08 <copumpkin> depending on the key index
14:45:30 <arkeet> how does that work
14:45:30 <copumpkin> then again, that goes and breaks the Monoid instance again :)
14:45:31 <jmcarthur> Zenol: i don't think it's likely to optimize this case away, at least at first glance
14:45:39 <aristid> copumpkin: doesn't your Data.Map need a second parameter?
14:45:44 <copumpkin> aristid: nope!
14:45:54 <aristid> copumpkin: why what where
14:45:55 <copumpkin> lookup :: Map f -> f a -> Maybe a
14:45:56 <jmcarthur> arkeet: http://hackage.haskell.org/packages/archive/dependent-map/0.1.1.1/doc/html/Data-Dependent-Map.html
14:46:04 <jmcarthur> aristid: ^^
14:46:18 <copumpkin> oh someone already made one
14:46:20 <copumpkin> oh it was mokus
14:46:43 <Kaidelong> why is the haskell library environment such a mess
14:46:58 <jmcarthur> it's not bad, really
14:47:10 <Kaidelong> I'm starting to think I should just re-implement Group myself
14:47:14 <Kaidelong> but
14:47:20 <Kaidelong> then I'd be contributing to the mess
14:47:20 <jmcarthur> certainly in better shape than a lot of other language libraries
14:47:22 <copumpkin> org.haskell.simple.library.fucked.up.reverse.domain.names.would.make.the.situation.much.better.I'm.sure
14:47:44 <Kaidelong> so much duplicated work and the haskell platform isn't big enough
14:48:44 <aristid> and the platform also contains some terrible crap *looks at "HTTP" package*
14:48:51 <Kaidelong> aww well screw it, I need to get this project done, and my project isn't writing a library for groups, so I guess off to reimplement groups
14:49:06 <Kaidelong> and we just covered a reason to hate containers, too
14:49:15 <jmcarthur> aristid: and GLUT of all things
14:49:17 <copumpkin> whatcha using groups for?
14:49:32 <aristid> jmcarthur: i'm not too familiar with opengl stuffs
14:49:48 <Kaidelong> copumpkin: a library to generate dungeons of dredmor mods, a lot of stuff in the game have group semantics of some sort
14:49:58 <copumpkin> interesting
14:50:01 <Kaidelong> like damage and mana scaling
14:50:34 <ocharles> are they not just (Nat, +) ?
14:51:28 <Fuco> @pl \(a,b) (c,d) -> (a+c, b:d)
14:51:28 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (:)) . flip . (((.) . (,)) .) . (+))
14:51:42 <Fuco> umh, really? :O
14:52:00 <copumpkin> it can be done better than that
14:52:23 <Fuco> I tried with fmap and applicatives but it's getting tricky
14:52:25 <arkeet> :t (+) *** (:)
14:52:28 <lambdabot> Num b => (b, b') -> (b -> b, [b'] -> [b'])
14:52:34 <Kaidelong> no they are actually kind of complicated due to the effects of software evolution
14:52:35 <arkeet> hmm
14:52:41 <arkeet> nope
14:52:59 <Kaidelong> you can think of it more as being a type like (Map Element Int, Map Element Float, Stat)
14:53:20 <Kaidelong> but the group semantics hold through all that
14:53:23 <ocharles> Kaidelong: I just wondered what the operation was
14:53:35 <ocharles> But now i'm not even sure what your set is :)
14:53:38 <copumpkin> Fuco: let me think, it seems quite possible
14:54:31 <jmcarthur> Kaidelong: are you sure you're not looking for more of an affine space than a group?
14:54:57 <Kaidelong> no, I was thinking of perhaps using AffineSpace
14:55:06 <Kaidelong> although
14:55:16 <Kaidelong> I'm not sure how you'd make something like fromInteger
14:55:25 <Aetherspawn> How do I use conduits with liftIO to have each client on their own thread?
14:55:52 <jmcarthur> i wish it was fromNatural instead of fromInteger
14:55:53 <Aetherspawn> /s/liftIO/forkIO
14:56:03 <jmcarthur> it uses negate anyway when it's negative, iirc
14:56:06 <arkeet> @ty liftA2 (***) fst snd . ((+) *** (:))
14:56:08 <lambdabot> Num c => (c, b') -> (c, [b']) -> (c, [b'])
14:56:41 <eikke> Aetherspawn: use network-conduit
14:56:47 <arkeet> > (liftA2 (***) fst snd . ((+) *** (:))) (a,b) (c,[d])
14:56:48 <lambdabot>   (a + c,[b,d])
14:56:50 <Kaidelong> Mmm, the type ends up being something like
14:56:56 <eikke> Aetherspawn: runTCPServer does the forkIO'ing for you
14:57:00 <Aetherspawn> eikke, is it automatic?
14:57:00 <Fuco> arkeet: nice ;P
14:57:02 <Aetherspawn> Oh sweet.
14:57:17 <eikke> Aetherspawn: "Run an Application with the given settings. This function will create a new listening socket, accept connections on it, and spawn a new thread for each connection.
14:57:30 <copumpkin> @ty uncurry (***) . ((+) *** (:))
14:57:35 <lambdabot> Num c => (c, b') -> (c, [b']) -> (c, [b'])
14:57:38 <arkeet> heh.
14:57:43 <eikke> (TBH I checked the source first, only then noticed the docs, but anyway)
14:57:45 <Kaidelong> Map Stat (Map Element (Int,Float))
14:57:49 <arkeet> :t uncurry (***)
14:57:51 <lambdabot> Arrow a => (a b c, a b' c') -> a (b, b') (c, c')
14:57:57 <arkeet> yeah.
14:57:59 <Kaidelong> does that give me free instances of Num with linear maps?
14:58:03 <Fuco> that seems like a nice trick to remember
14:58:08 <Kaidelong> Stat and Element are straightforward enums
14:58:12 <jmcarthur> :t uncurry
14:58:13 <lambdabot> (a -> b -> c) -> (a, b) -> c
14:58:18 <aristid> copumpkin: oh i see that this dependent map type uses mappend = union = unionWith const... fuming yet? :)
14:58:29 <copumpkin> WAH
14:58:43 <jmcarthur> ah. it looked funny for a sec and i was about to blame caleskell
14:58:51 <copumpkin> aristid: then again, I don't think you can do better
14:58:58 <aristid> copumpkin: why?
14:59:05 <copumpkin> because the value type can change
14:59:06 <jmcarthur> yeah that type has more constraints placed on it
14:59:14 <eikke> anyone who'd like to take a look at a design problem I'm facing?
14:59:30 <jmcarthur> on its implementation, i mean
14:59:36 <Kaidelong> @ty 5 + (undefined: Map Int (Map Int (Int,Float))
14:59:36 <eikke> (well, code doesnt compile, so I guess my design is wrong somehow)
14:59:37 <lambdabot> parse error (possibly incorrect indentation)
14:59:43 <Kaidelong> @ty 5 + (undefined :: Map Int (Map Int (Int,Float))
14:59:43 <aristid> copumpkin: ah true, unionWithKey exists but won't take mappend
14:59:45 <lambdabot> parse error (possibly incorrect indentation)
14:59:55 <Kaidelong> @ty 5 + (undefined :: Map Int (Map Int (Int,Float)))
14:59:56 <lambdabot>     Not in scope: type constructor or class `Map'
14:59:56 <lambdabot>     Perhaps you meant `M.Map' (imported from Data.Map)
14:59:56 <lambdabot>     Not in scope: type constructor or class `Map'
15:00:03 <copumpkin> aristid: the thing is, it could be done with a higher-rank constraint
15:00:10 <Kaidelong> @ty 5 + (undefined :: M.Map Int (M.Map Int (Int,Float)))
15:00:13 <copumpkin> aristid: since if the keys match so do the value types
15:00:16 <lambdabot>     No instance for (Num (M.Map Int (M.Map Int (Int, Float))))
15:00:17 <lambdabot>       arising from a use of `+'
15:00:17 <lambdabot>     Possible fix:
15:00:24 <Kaidelong> okay, so no
15:00:27 <aristid> copumpkin: right
15:00:38 <Kaidelong> unless lambdabot no longer has Data.LinearMap
15:00:45 <jmcarthur> Kaidelong: what would the behavior be?
15:01:01 <jmcarthur> Kaidelong: it would need some constraint on the key or something, no?
15:01:07 <aristid> copumpkin: unionWithKey :: GCompare k => (forall v. k v -> v -> v -> v) -> DMap k -> DMap k -> DMap k
15:01:14 <aristid> copumpkin: isn't that pretty much the correct type?
15:01:24 <jmcarthur> Kaidelong: i guess the appropriate semantics would be to make all possible keys to the number 5?
15:01:24 <aristid> copumpkin: just need a fancier Monoid variant i suppose
15:01:33 <copumpkin> yeah
15:01:34 <Kaidelong> yeah and then add them all
15:01:42 <jmcarthur> yeah that sounds tough to get right
15:01:46 <Kaidelong> : 5 + (5,5.0)
15:01:51 <Kaidelong> > 5 + (5,5.0)
15:01:52 <lambdabot>   (10,10.0)
15:02:11 <Kaidelong> that's not actually what I want
15:02:11 <copumpkin> @let foo = liftA2 (=<<) zip (tail . tails)
15:02:14 <lambdabot>  Defined.
15:02:18 <aristid> :t 5 + (5,5.0)
15:02:19 <lambdabot> (Fractional t1, Num t) => (t, t1)
15:02:21 <Kaidelong> so I'd need to wrap (Int,Float) in a newtype
15:02:33 <Kaidelong> well actually
15:02:47 <Kaidelong> it's not a big deal, in the programming language I could just translate 5 into (5,0)
15:02:48 <copumpkin> @let bar = iterate (sequence [length, head] <=< group) [1]
15:02:51 <lambdabot>  Defined.
15:04:04 <Kaidelong> @instances-importing Num
15:04:05 <lambdabot> Double, Float, Int, Integer
15:05:32 <dmwit> copumpkin: bar is very cute
15:05:42 <copumpkin> you don't like foo? :(
15:05:50 <dmwit> I haven't looked at it yet.
15:05:52 <dmwit> I read bottom to top.
15:06:09 <jmcarthur> :t bar
15:06:11 <lambdabot> [[Int]]
15:06:36 <copumpkin> @let baz = 1:fix((1%1:)>=>\x->[1+x,1/(1+x)])
15:06:36 <lambdabot>   ViewPatterns is not enabled
15:06:45 <copumpkin> wat
15:06:50 <aristid> :t bar
15:06:52 <lambdabot> [[Int]]
15:06:56 <aristid> > bar
15:06:58 <lambdabot>   [[1],[1,1],[2,1],[1,2,1,1],[1,1,1,2,2,1],[3,1,2,2,1,1],[1,3,1,1,2,2,2,1],[1...
15:07:18 <aristid> > map sum bar
15:07:23 <lambdabot>   [1,2,3,5,8,10,13,16,23,32,44,56,76,102,132,174,227,296,383,505,679,892,1151...
15:07:27 <enthrops> This wil run through the whole list right? 'elem' y = foldl (\acc x -> if x == y then True else acc) False'
15:07:37 <aristid> @. oeis run map sum bar
15:07:42 <copumpkin> enthrops: foldl will always
15:07:44 <shachaf> copumpkin: >=>\
15:07:45 <lambdabot>  Sequence not found.
15:07:47 <copumpkin> foldr has the option to stop
15:07:48 <dmwit> aristid: It's the see'n'say sequence.
15:07:51 <copumpkin> shachaf: dammit!
15:07:54 <enthrops> copumpkin: thanks
15:07:56 <aristid> dmwit: the what?
15:07:59 <copumpkin> @let baz = 1:fix((1%1:)>=> \x->[1+x,1/(1+x)])
15:08:01 <lambdabot>  <local>:8:15:
15:08:01 <lambdabot>      Not in scope: `%'
15:08:01 <lambdabot>      Perhaps you meant `R.%' (imported ...
15:08:07 <jmcarthur> aw
15:08:08 <copumpkin> @let baz = 1:fix((1R.%1:)>=> \x->[1+x,1/(1+x)])
15:08:11 <lambdabot>  Defined.
15:08:12 <shachaf> @arr .%
15:08:12 <lambdabot> Avast!
15:08:19 <shachaf> @arr.%
15:08:19 <lambdabot> Yo ho ho, and a bottle of rum!
15:08:23 <jmcarthur> > baz
15:08:25 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,2 ...
15:08:35 <dmwit> aristid: To go from one element to the next, you read it: "1" is "one one"; "11" is "two ones"; "21" is "one two, one one"; etc.
15:08:41 <copumpkin> these are random snippets I've collected from here over the years
15:09:09 <dmwit> I still haven't figured out foo. And I refuse to ask ghc. =P
15:09:28 <copumpkin> abandon all hope
15:09:32 <aristid> dmwit: ah!
15:09:52 <copumpkin> @let quux = map (map fst) . groupBy (((&&) . not) `on` snd) . (zip <*> ((False :) . (zipWith (<) <*> tail)))
15:09:55 <lambdabot>  Defined.
15:09:58 <copumpkin> :t quux
15:10:00 <lambdabot> Ord b => [b] -> [[b]]
15:10:08 <aristid> > quux "copumpkin"
15:10:13 <lambdabot>   ["copu","mp","k","in"]
15:10:59 <aristid> why.
15:11:04 <copumpkin> @let moo r = (x,y,z) where m = numerator r; n = denominator r; [x,y,z] = sort [2*m*n, m^2 - n^2, m^2 + n^2]
15:11:07 <lambdabot>  Defined.
15:11:24 <aristid> > quux (ord <$> "copumkin")
15:11:27 <lambdabot>   [[99,111,112,117],[109],[107],[105,110]]
15:11:28 <copumpkin> @let oink = map (moo . (+1)) baz
15:11:30 <lambdabot>  Defined.
15:11:43 <aristid> ah so quux collects ascending runs
15:12:29 <dmwit> Okay, I don't like foo.
15:12:47 <copumpkin> :(
15:12:49 <jmcarthur> :t foo
15:12:50 <lambdabot> [b] -> [(b, b)]
15:13:04 <aristid> > foo "copumpkin"
15:13:06 <lambdabot>   [('c','o'),('o','p'),('p','u'),('u','m'),('m','p'),('p','k'),('k','i'),('i'...
15:13:19 <jmcarthur> > foo [a,b,c]
15:13:22 <lambdabot>   [(a,b),(b,c),(a,c)]
15:13:39 <jmcarthur> > foo [a,b,c,d]
15:13:41 <lambdabot>   [(a,b),(b,c),(c,d),(a,c),(b,d),(a,d)]
15:14:13 <aristid> > let f xs = zip xs (tails xs) in f [a, b, c]
15:14:15 <lambdabot>   [(a,[a,b,c]),(b,[b,c]),(c,[c])]
15:14:17 <dmwit> I like baz.
15:14:27 <aristid> > let f xs = zip xs (tail xs) in f [a, b, c]
15:14:29 <lambdabot>   [(a,b),(b,c)]
15:14:44 <dmwit> The extra 1: at the beginning is a little disappointing.
15:14:45 <jmcarthur> i think foo is okay...  liftA2 (=<<)  just feels weird though
15:15:06 <aristid> when was foo defined?
15:15:16 <dmwit> Just a bit before bar.
15:15:19 <jmcarthur> i hate that it seems like (tail.tails) is as common as just tails
15:15:22 <Fuco> @pl \n a -> (f n a) : a
15:15:23 <lambdabot> join . ((:) .) . f
15:15:34 <Fuco> huh, join... how does that work
15:15:42 <copumpkin> join f x = f x x
15:15:53 <dmwit> (when f is a function)
15:16:02 <Fuco> right, it's for monads I guess
15:16:05 <Fuco> m m a -> m a?
15:16:06 <copumpkin> (when that expression is well typed, it's correct)
15:16:09 <copumpkin> :P
15:16:15 <Kaidelong> out of curiousity
15:16:17 <copumpkin> s/expression/definition/
15:16:20 <Kaidelong> has anyone forked the haskell platform
15:16:26 <Kaidelong> to try to deal with these warts
15:16:37 <mzero> which warts?
15:16:39 <jmcarthur> :t \n a -> ?f n a : a
15:16:41 <aristid> Kaidelong: there's stackage
15:16:41 <lambdabot> (?f::t -> [a] -> a) => t -> [a] -> [a]
15:16:55 <copumpkin> > oink
15:16:57 <lambdabot>   [(3,4,5),(6,8,10),(5,12,13),(8,15,17),(7,24,25),(20,21,29),(16,30,34),(10,2...
15:17:49 <jmcarthur> :t \n -> flip (:) =<< ?f n
15:17:54 <lambdabot> (?f::t -> a -> [a]) => t -> a -> [a]
15:18:01 <jmcarthur> i screwed something up
15:18:22 * hackagebot show 0.6 - 'Show' instances for Lambdabot  http://hackage.haskell.org/package/show-0.6 (JamesCook)
15:18:25 <Kaidelong> mzero: the one that was bothering me was the fact that there was a Monoid instance for Map that didn't require elements to be instances of Monoid themselves
15:18:37 <jmcarthur> :t \n -> (:) =<< ?f n
15:18:38 <lambdabot> (?f::t -> [a] -> a) => t -> [a] -> [a]
15:18:52 <jmcarthur> :t (:) <=< ?f
15:18:54 <lambdabot> (?f::a -> [b] -> b) => a -> [b] -> [b]
15:18:54 <Fuco> what is ?f ?
15:19:01 <aristid> Kaidelong: wait... doesn't containers come with ghc, not the platform?
15:19:08 <aristid> Fuco: evil
15:19:11 <Kaidelong> does it?
15:19:14 <Kaidelong> well in that case
15:19:16 <jmcarthur> Fuco: just a trick to allow me to avoid binding it. it's allowed by the ImplicitParams extension
15:19:33 <copumpkin> someone should revive the linear implicits extension :D
15:19:34 <mzero> well, platform includes ghc ---- but what you are talking about is a change to containers, not the platform as a whole
15:19:44 <copumpkin> just to make GHC's typechecker more complicated, since it's too simple
15:19:47 <jmcarthur> Fuco: anyway, my internal @pl results in    (:) <=< f   for your query
15:20:02 <aristid> copumpkin: sounds like a good reaso
15:20:36 <jmcarthur> Fuco: certainly easier to read than  join . ((:) .) . f   ...
15:20:57 <jmcarthur> still not the most obvious thing to follow though
15:21:33 <aristid> :t (:) <=< ?f
15:21:35 <lambdabot> (?f::a -> [b] -> b) => a -> [b] -> [b]
15:21:38 <Fuco> indeed, I don't think I follow. :d I've figured out the join, so now that ^
15:22:36 <jmcarthur> :t (<=<)
15:22:39 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
15:22:50 <jmcarthur> the monad in this case is   ((->) something)
15:22:54 <jmcarthur> so...
15:23:10 <jmcarthur> (<=<) :: (b -> z -> c) -> (a -> z -> b) -> a -> z -> c
15:23:23 * hackagebot lambdabot 4.3 - Lambdabot is a development tool and advanced IRC bot  http://hackage.haskell.org/package/lambdabot-4.3 (JamesCook)
15:23:27 <jmcarthur> :t ((:) <=<)
15:23:29 <lambdabot> (a -> [b] -> b) -> a -> [b] -> [b]
15:23:29 <Fuco> right.
15:23:32 <dmwit> Kaidelong: That really is a shame. If only we had a tool that could figure out how much of Hackage would break if we fixed it. =/
15:23:50 <dmwit> I suspect it's actually not all that much, but it's so hard to say.
15:24:51 <Fuco> now the function is using arrows, monads, lifts, and all sorts of things. 3 days later I won't understand any of it
15:24:58 <Fuco> but it's *so pretty* :D
15:27:08 <epta> printf :: PrintfType r => String -> r <- why there is no analog for Text?
15:28:07 <dmwit> Because printf is an abomination to begin with.
15:29:36 <epta> dmwit: is there any better tools for text formatting?
15:30:22 <shippi> when I want to format a text, i just write a function which gets some input strings and then outputs the string in the way I want.
15:30:29 <dmwit> epta: Is efficiency a concern?
15:30:34 <dmwit> If no, (<>) works pretty good.
15:30:36 <dmwit> If yes,
15:30:39 <dmwit> ?hackage blaze-builder
15:30:39 <lambdabot> http://hackage.haskell.org/package/blaze-builder
15:31:27 <Aetherspawn> Let's say I'm using network-conduits and I have my function wrapped in ReaderT State
15:31:50 <Aetherspawn> I want the forked threads for clients from runTCPServer to carry the ReaderT but I want them to make their own fresh state
15:33:08 <Aetherspawn> Actually, maybe I shouldn't use a transformer at all here.
15:36:28 <cmccann> printf is a useful abomination though. :T
15:36:36 <Fuco> is there a function [Int] -> [a] -> [a] that would return sublist with indices from the first argument? f [1,3,4] [a,b,c,d,e,f] -> [a,c,d]
15:37:32 <cmccann> Fuco: not that I know of and I can't think of a simple and sane way to implement it with standard functions either
15:38:30 <copumpkin> there's the inefficient one :P
15:38:38 <cmccann> that's not sane
15:38:43 <copumpkin> if golfing is the goal, it's quite pretty
15:39:00 <cmccann> it's also quite horrible in every other way
15:39:14 <Fuco> the one where you map (- head x) and drop that many things each time
15:39:18 <Fuco> and colllect it to a list
15:39:29 <Aetherspawn> use !!?
15:39:36 <Fuco> I would like it linear
15:39:40 <copumpkin> mapAccumL will do it but it'll be ugly
15:40:08 <cmccann> Fuco: yeah, anything using (!!) falls under my "not sane" clause
15:40:24 <copumpkin> :t mapM (flip (!!))
15:40:26 <lambdabot> [Int] -> [b] -> [b]
15:40:28 <copumpkin> >_>
15:40:32 <copumpkin> <_<
15:40:43 <djahandarie> Hah
15:40:51 <Fuco> that is pretty sweet :P
15:40:52 <copumpkin> oh wait
15:40:57 <Aetherspawn> That's quite cool.
15:40:58 <copumpkin> :t forM (!!)
15:40:59 <lambdabot>     Couldn't match expected type `[a0]'
15:41:00 <lambdabot>                 with actual type `[a1] -> Int -> a1'
15:41:00 <lambdabot>     In the first argument of `forM', namely `(!!)'
15:41:03 <copumpkin> oh whoops, wrong flippage
15:41:24 <copumpkin> I assume it actually does the right thing
15:41:28 <djahandarie> It does
15:41:30 <copumpkin> I have only stared at the types, not tested it
15:41:42 <copumpkin> and these types aren't particularly informative :)
15:42:02 <redneckcoder> what is a channel in haskell?
15:42:10 <redneckcoder> a socket?
15:42:22 <copumpkin> you mean Chan?
15:42:43 <copumpkin> it's closer to a pipe than a socket, but it only lives within your current process
15:44:06 <redneckcoder> what primitives is there for interprocesscomm in haskell? interthread comm
15:44:08 <redneckcoder> ?
15:44:59 <hcaulfield57> Hello everyone, I'm new to Haskell. Could someone help me with the following program http://ideone.com/B9alOU
15:45:38 <mauke> hcaulfield57: read takes a String, getLine is not a String
15:45:51 <hcaulfield57> mauke: Okay, lemme try again.
15:46:10 <hpc> interestingly, ghc isn't saying that in the error
15:46:27 <Aetherspawn> is it possible to pass a Reader monad without through forkIO without making a copy of it
15:46:42 <hpc> it's failing to pick an instance instead
15:46:54 <hpc> even though the equation that fails is (IO String) = String
15:46:56 <Aetherspawn> If I want the fork'd thing to have the "same" Reader without copying it.
15:47:03 <hpc> which has no instance resolution details
15:47:13 <arkeet> hcaulfield57: you may be interested in readLn
15:47:23 <arkeet> which is like getLine >>= read
15:47:32 <arkeet> (which would also work)
15:47:45 <mauke> liftM, not >>=
15:47:50 <arkeet> oops.
15:47:54 <arkeet> fmap read getLine
15:48:09 <arkeet> I was thinking getLine >>= readIO, then.
15:48:13 <mauke> Aetherspawn: you can't copy things in haskell
15:48:34 <arkeet> you can't not copy things in haskell.
15:49:10 <Aetherspawn> mauke, so if I just pass my configuration to the forked thread after I grab it from the reader, it won't make a copy?
15:49:33 <mauke> Aetherspawn: what's the difference?
15:49:36 <hcaulfield57> Thanks guys, that worked. I tried readLn arkeet
15:49:42 <monochrom> GHC-generated code will pass a pointer not a copy.
15:49:49 <hcaulfield57> I'm very very new to Haskell so I will probably be on this channel as I try to learn.
15:49:57 <Aetherspawn> ah, that's excellent
15:49:59 <arkeet> hcaulfield57: :)
15:50:01 <monochrom> Haskell the language standard doesn't say either way.
15:50:22 <Aetherspawn> I think monochrom answered that, thanks :)
15:50:36 <monochrom> however, it guarantees that you won't see a difference (until you measure time and memory)
15:51:17 <Aetherspawn> and I assume laziness means that if the config is changed and passed through something else then a copy /is/ made?
15:51:30 <monochrom> config cannot be changed
15:51:42 <monochrom> this is why whether pointer or copy, you won't know.
15:53:37 <monochrom> "change 5 to 6" makes as much sense as "change '5 equals 2+3' to '6 equals 2+3'".
15:53:44 <monochrom> unfortunately, some people will it.
15:54:15 <redneckcoder> soon, it will be possible to get current electric prize from an ftp server and then a lot of companies will create smart boxes that will schedule stuff in your home to run when the prize is low. for example run your washing machine maybe 2-3 in the night if the prize is low rather than you starting it when you go to bed. so im wondering if a linuxbox is good enough for this or if youd need an
15:54:15 <redneckcoder> rtos. if embedded linux is good enough then it would be easier to create obv. would haskell work to program this? obv not if it needs to be hard realtime but if soft realtime is good enough?
15:55:07 <Aetherspawn> monochrom, I explained it kinda sketchy but now I realise that if I grab the thing out of my readerT and change it then it's not the same thing anymore
15:55:32 <Aetherspawn> (ie: pattern match it to create a new thing and then pass that as an argument somewhere)
15:56:24 <kurama> Has this tutorial been deprecated? I noticed that for me at least, fib1.hs executes faster then fib2.hs, but it says it should be the opposite.
15:56:27 <kurama> http://www.yellosoft.us/evilgenius/
15:56:51 <merijn> kurama: Might be that GHC optimisations have becomes smarter since writing of the tutorial
15:57:41 <merijn> kurama: Also, are you compiling the code or running it using runhaskell?
15:57:54 <merijn> For best effect you probably want to compile with -O2 before comparing
15:58:02 <kurama> Yeah, I guess you're right.
15:59:06 <luite> for larger numbers, the memoized version will still be faster
15:59:47 <luite> it optimizes the first one to an unboxed recursive function with -O2
15:59:56 <luite> the second one probably does a lot more allocation
16:00:23 <kurama> Thanks.
16:07:28 --- mode: ChanServ set +o monochrom
16:07:34 --- mode: monochrom set -z
16:07:42 --- mode: monochrom set -o monochrom
16:23:37 <redneckcoder> soon, it will be possible to get current electric prize from an ftp server and then a lot of companies will create smart boxes that will schedule stuff in your home to run when the prize is low. for example run your washing machine maybe 2-3 in the night if the prize is low rather than you starting it when you go to bed. so im wondering if a linuxbox is good enough for this or if youd need an
16:23:37 <redneckcoder> rtos. if embedded linux is good enough then it would be easier to create obv. would haskell work to program this? obv not if it needs to be hard realtime but if soft realtime is good enough?
16:26:17 <shanse> @faq can haskell do realtime?
16:26:17 <lambdabot> The answer is: Yes! Haskell can do that.
16:27:22 <luite> doesn't sound like something where realtime scheduling is important at all
16:28:00 <typoclass> redneckcoder: hello, i think that you'd need a realtime system if you want to switch with millisecond precision
16:29:21 <typoclass> redneckcoder: a realtime system would be needed in this kind of case: "the software decides to switch at this moment, and the actual switching must be done within the next 100 milliseconds, and it's a catastrophe if it accidentally takes a second or two"
16:29:52 <typoclass> redneckcoder: so i can see how that may be needed if you're writing software to control a missile or a large industrial plant :-) but i think in your case you'll be just fine with a plain normal linux
16:30:06 <jmcarthur> haskell is fine for soft real time
16:30:26 <jmcarthur> for hard real time haskell can still offer some DSLs for generating C or something, but GHC-built binaries are probably less useful
16:30:49 <luite> typoclass: perhaps if the electricity market has an exchange, and your control device has to quickly react when a chunk of electricity is offered at a good price :p
16:31:50 <typoclass> luite: seems a bit far-fetched
16:33:21 <Ghoul_> :t (@.@)
16:33:23 <lambdabot> Not in scope: `@.@'
16:33:50 <Adam`> :t (($) . ($))
16:33:52 <lambdabot> (a -> b) -> a -> b
16:46:07 <Adam`> :t (@)
16:46:08 <lambdabot> parse error on input `@'
16:52:15 <acdc> How would I import a few symbols from a module unqualified, while importing the rest qualified?
16:53:04 <redneckcoder> luite: thats what it has but i dont think a second delay is an issue. but the factor is price. linux still demands a processor with some power which makes it more expensive. but i dont know the price of such a product
16:53:05 <typoclass> acdc: you can have two import lines referring to the same module. try "import Foo (this, that) \n import qualified Foo as F"
16:54:26 <luite> redneckcoder: should be under $20 for something that can run linux, and only getting cheaper
16:54:40 <blackdog> luite: the tp-links are quite good for that
16:55:44 <luite> blackdog: do they all run linux?
16:56:21 <blackdog> luite: the ones i'm using do. i put openwrt on them.
16:56:36 <Adam`> What would happen if you quilify import something like as Q.foo but then declare foo = Q.foo
16:56:43 <Adam`> would that work?
16:56:59 <blackdog> not a lot of space, so they're not great to develop on, but if you can cross-compile or use one as a dev machine with a usb disk on it, it works fine.
16:57:07 <blackdog> Adam`: how would you find out? :)
16:57:32 <arkeet> Adam`: it would work in the sense that your stuff would compile, but
16:57:41 <Adam`> Oh, I was just suggesting something for acdc
16:57:45 <arkeet> for example if someone else imported your module as well as Q, there would be a name conflict for foo
16:57:52 <Adam`> oh, right
16:57:57 <luite> blackdog: ah i got an asus router last year because i didn't feel like experimenting too much, and they didn't support ipv6 then
16:58:10 <arkeet> also you'd have to worry about stuff like the monomorphism restriction if you don't write a type signature, etc.
16:58:23 <blackdog> Adam`: oh, sorry. came in late :)
16:58:24 * hackagebot pipes-network 0.3.0.0 - Use network sockets together with the pipes library.  http://hackage.haskell.org/package/pipes-network-0.3.0.0 (RenzoCarbonara)
16:58:54 <blackdog> luite: hm. didn't try ipv6 on the tp-links. would be surprised if it wasn't there though.
16:59:07 <blackdog> i mean, it's just linux, right?
16:59:09 <luite> blackdog: they promised a firmware update
17:01:34 <luite> ah looks like some of the devices got it in december last year
17:02:07 <blackdog> redneckcoder: looking back on the channel - i worked on some similar stuff for this with ninjablocks. totally doable, and an interesting area - you don't need soft or hard realtime for 99.9% of it though
17:04:23 <Adam`> I'm looking to get involved in an open source project, but I'm relatively new to the open source thing, can anyone reccomend a project?
17:04:39 <luite> what are you interested in?
17:04:51 <Adam`> I'm not really sure
17:05:15 <Adam`> I'm not even so familiar with what's out there
17:05:39 <tij> hey guys, what are the practical uses of currying? - i understand that it leads to easy partial function application, but are there other "uses" (other than formalism)?
17:05:40 <Eduard_Munteanu> Adam`: try looking at the GSoC proposed ideas list
17:06:02 <Adam`> what/where is that?
17:06:11 * Eduard_Munteanu looks it up
17:08:10 <monochrom> well, every time I write "map f xs" I'm already using currying. sure, it is not partial application. but it is currying. I am using a curried function. I have to write "map f xs" not "map (f, xs)"
17:08:15 <Eduard_Munteanu> Adam`: http://www.google-melange.com/gsoc/accepted_orgs/google/gsoc2013   -- those are the enlisted orgs, each of those should have put up a list of project ideas
17:09:07 <Eduard_Munteanu> Adam`: even outside the GSoC, mentors are likely to be glad to show you around if you're interested
17:09:09 <tij> yes, but does the distinction matter for the programmer?
17:09:41 <Eduard_Munteanu> tij: yes, because we have functions which can return other functions.
17:09:48 <monochrom> consider the dual question: what are the practical uses of uncurrying? are there other uses than formalism?
17:10:04 <tij> sorry, what i meant was applications other than partial function application
17:10:11 <Adam`> I'm looking to do something in haskell. Are these GSoC projects in haskell>
17:10:21 <Eduard_Munteanu> Adam`: yes
17:10:43 <luite> unfortunately you can't submit your own project anymore
17:10:54 <luite> uh, i mean proposal
17:11:01 <luite> closed 2 weeks ago
17:11:01 <Eduard_Munteanu> Adam`: http://hackage.haskell.org/trac/summer-of-code/report/1
17:11:11 <Eduard_Munteanu> luite: sure, but if he just wants to get involved...
17:11:26 <Eduard_Munteanu> I mean outside GSoC.
17:11:40 <tij> @monochrom i dont think so?
17:11:40 <lambdabot> Unknown command, try @list
17:12:14 <luite> yeah but with GSoc he could get paid for it :p
17:12:23 <Eduard_Munteanu> Indeed. :)
17:12:31 <monochrom> ok. then do you accept this answer? since uncurrying doesn't have other practical uses, we choose currying.
17:12:46 <Eduard_Munteanu> Still, it could be good practice for next year's GSoC.
17:12:53 <luite> true
17:13:39 <luite> Adam`: what are you interested in making? something with algorithms or data structures? perhaps graphics, web, games?
17:14:01 <Eduard_Munteanu> You can use uncurry to generalize zipWith, zipWith3 etc using a plain map for applying arguments.
17:14:29 <tij> im not familiar with uncurry - explain?
17:14:43 <tij> i understand that its kinda like the inverse of curry
17:14:46 <monochrom> uncurrying means making you write like "map (f, xs)".
17:14:47 <jmcarthur> tij: currying is a very lightweight way to write function application. i see that as reason enough to like it. easy partial application is just another benefit on top of that
17:14:52 <Adam`> hasn't the deadline for GSoC passed
17:14:53 <Adam`> ?
17:14:57 <jmcarthur> tij: syntactically, i mean
17:15:25 <Eduard_Munteanu> Adam`: yeah, but you might want to take on projects nobody's working on... the mentors could help you even outside GSoC.
17:15:44 <Adam`> OK. I'll look into those
17:15:49 <luite> Adam`: yes but the mentors don't get anything for it anyway (well, a free t-shirt), so if you just want to work on something, they might still be interested in helping out
17:16:10 <Eduard_Munteanu> :t \f -> map (uncurry f $)
17:16:12 <lambdabot> (a -> b1 -> b) -> [(a, b1)] -> [b]
17:16:34 <tij> :t uncurry
17:16:35 <lambdabot> (a -> b -> c) -> (a, b) -> c
17:16:48 <Eduard_Munteanu> luite: they don't? I guess the $500 are kept by the org? :)
17:16:54 <luite> eah
17:17:01 <luite> to cover hosting for haskell.org etc
17:17:08 <Eduard_Munteanu> I see.
17:17:11 <jmcarthur> oh, i didn't know that
17:17:23 <tij> ah i see
17:17:24 <jmcarthur> oddly, that makes me more willing to mentor
17:17:27 <Eduard_Munteanu> jmcarthur: why, did you volunteer? :P
17:17:35 <Eduard_Munteanu> Ah, heh.
17:17:36 <jmcarthur> no
17:17:52 <jmcarthur> i just always felt like a mentor shouldn't be doing it for the personal rewards anyway
17:17:54 <tij> so uncurrying is basically like "other imperative" languages (i.e Java: Math.pow(5, 2))
17:18:00 <monochrom> yes
17:18:09 <jmcarthur> well, at least tangible rewards
17:18:09 <luite> jmcarthur: but free t-shirt!
17:18:20 <Eduard_Munteanu> Well, it's just up to the org what it does with those $500/student, some pay the mentors, others keep part of it etc.
17:18:26 <jmcarthur> yeah
17:18:53 <cmccann> jmcarthur: just think of them as "reified intangible rewards"
17:18:58 <jmcarthur> i just didn't even think about it being some per-organization thing. i always figured every mentor just got the $500
17:18:59 <Eduard_Munteanu> Oh, mentors get t-shirts too?
17:19:02 <Eduard_Munteanu> Cool.
17:19:14 <luite> i got one last year :p
17:19:20 <luite> and then a few more at the mentor summit
17:19:27 <tij> thanks monochrom, Eduard_Munteanu, and jmcarthur
17:20:01 <Eduard_Munteanu> Though they invite just 1 mentor from each org, IIRC.
17:20:15 <luite> 2 ppl from each org
17:20:29 <Eduard_Munteanu> luite: do they cover any expenses?
17:20:33 * Eduard_Munteanu just wondering
17:20:43 <luite> Eduard_Munteanu: only travel, and they pay a few hotel nights
17:21:02 <Eduard_Munteanu> Oh, nice... travel expenses are quite a big deal for e.g. Europe.
17:21:43 <Eduard_Munteanu> Who's managing the program now?
17:22:12 <luite> up top $2000 per organization, so one person from europe is probably the maxmimum, unless you manage to get cheap flights
17:22:21 <Eduard_Munteanu> Ah.
17:22:31 <dav> Is there a best practice ruling in favor of one of the two versions of this function (http://paste.debian.net/5266/), or maybe a 3rd version?
17:22:36 <luite> edwardk is doing most of the admin work again
17:22:44 <luite> he was also at the mentor summit last year
17:22:57 <Eduard_Munteanu> luite: ah, I know, I mean GSoC itself, on Google's end
17:23:46 <luite> oh, i think Carol Smith again
17:24:12 <Eduard_Munteanu> Ah.
17:25:11 <dav> (or maybe getFileSize3 filename = withFile filename ReadMode hFileSize)
17:25:15 <Eduard_Munteanu> The previous manager left the company altogether, IIRC.
17:26:21 <Eduard_Munteanu> dav: any of those 2 is fine IMO
17:27:46 <dav> Eduard_Munteanu: thanks.
17:30:18 <Cale> dav: The first two are 100% equivalent.
17:30:39 <Michael_> Is there a way to apply typeclasses to the individual constructors of GADT's
17:30:48 <dav> Cale: yes but isn't there a best practice from a readability standpoint?
17:31:45 <Cale> dav: But yeah, they both leave the filehandle open. I think it'll be closed when the Handle is GC'ed, but of course, it's harder to rely on when that'll be.
17:31:51 <Cale> So withFile is perhaps better.
17:33:00 <jmcarthur> Michael_: i don't understand the question
17:33:37 <monochrom> I pretend I understand the question. answer: no.
17:33:52 <Michael_> Where, this is a really contrived example, but I want to say Just :: a -> Maybe a is an instance of say, ord, but Nothing :: Maybe a is not?
17:34:29 <dav> Cale: thanks!
17:34:55 <dav> withFile filename ReadMode hGetContents -- seems to return an empty string. I would have expected it to work like readFile. What am I missing?
17:35:29 <geekosaur> hGetContents is lazy
17:35:44 <geekosaur> by the time you request the result, the withFile has already closed the handle
17:36:22 <monochrom> withFile closes the handle before any reading happens
17:36:44 <dav> but readFile is lazy too.. doesn't it close the handle as well?
17:36:48 <geekosaur> moral: put whatever processes the file contents *inside* the withFile and make sure it's evaluated there
17:37:05 <monochrom> at this point, you may like: http://www.vex.net/~trebla/photo/unorganized/dragon.jpg
17:37:17 <monochrom> readFile does not use withFile
17:37:24 <geekosaur> readFile reads lazily and closes the handle when it hits EOF.
17:37:58 <geekosaur> if you are using withFile, withFile will close the file; it's up to you to make sure the data you need are read before that
17:38:28 <jmcarthur> Michael_: but the type is still   Maybe a
17:38:30 <monochrom> "withFile ... hGetContents" is approximately equal to "openFile; x<-hGetContents; hClose; return x"
17:38:36 <jmcarthur> Michael_: type classes dispatch based on type, not value
17:38:53 <dav> monochrom: :)
17:38:56 <Michael_> yeah, I suppose just making what I thought a GADT might be better served as a typeclass
17:39:11 <jmcarthur> Michael_: with actual GADTs you can make the type vary with the constructor, so (with appropriate extensions like FlexibleInstances, at least), you can vary instances with constructor by their types
17:39:21 <dav> thanks I'll toy with this some more
17:39:31 <Michael_> Though, on that note, are there any good reosurce on using gatds in parsing/evaling?
17:39:54 <jmcarthur> GADTs are such a general tool that there are probably a million ways they could be used for that
17:39:58 <monochrom> I use lazy I/O sometimes. but I am very aware of the lazy evaluation order when I use it.
17:40:04 <jmcarthur> do you have a specific use in mind?
17:42:29 <Michael_> jmcarthur: Thanks for the help, I'm trying to implement a microlanguage for use in genetic expression programming, so really a classic interpreter use case
17:47:13 <jmcarthur> Michael_: sure, but in what part of the interpreter are you looking to use GADTs?
17:47:24 <jmcarthur> Michael_: the syntax tree?
17:47:43 <Michael_> for implementing the syntax tree, but also determining the types
17:48:09 <dav> ermmm, so I guess I'm unable to do something rather simple (I'm a real beginner). How can I read the first n bytes of a file?
17:48:10 <jmcarthur> a GADT isn't going to help you determine the types. the proof obligation is on you in order to be able to construct a type safe tree in the first place
17:48:10 <Nisstyre> Michael_: you're wanting to implement type operators with GADTs?
17:48:20 <Ghoul_> @pl (\l r -> max (longest l) (longest r))
17:48:20 <lambdabot> (. longest) . max . longest
17:48:46 <jmcarthur> Ghoul_: max `on` longest
17:48:55 <jmcarthur> Ghoul_: Data.Function.on
17:48:56 <Ghoul_> :t on
17:48:57 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
17:49:22 <jmcarthur> :t max `on` ?f
17:49:24 <lambdabot> (?f::a -> c, Ord c) => a -> a -> c
17:49:25 <Michael_> Nisstyre:  I want to use them to define types for the syntax tree, where I'm then inferring the types
17:51:18 <Nisstyre> Michael_: I suggest reading this: https://docs.google.com/file/d/1oTZkzY1MiQwUAdoW3E5Fsb7p6AYRU4ph9BrR17TC-Qrzh-6vHUS6mRatgZhL/edit?usp=sharing
17:51:19 <Ghoul_> jmcarthur: thanks
17:51:53 <Michael_> Nisstyre: Thanks
17:52:43 <monochrom> dav: I suggest hGet in Data.ByteString
18:04:57 <dav> I'm so bad at this... this is disconcerting
18:05:05 <dav> I can't even solve parse errors...
18:05:12 <dav> printFirst10Chars filename = withFile filename ReadMode myHandler
18:05:12 <dav>     where myHandler = do
18:05:12 <dav>         x <- hGetContents
18:05:12 <dav>         let y = take 10 x
18:05:12 <dav>         return print y
18:05:23 <dav> what's wrong here?
18:05:56 <monochrom> where is the handle?
18:05:57 <Nisstyre> dav: what's the error?
18:06:13 <typoclass> dav: one thing is that you can do "print y" instead of "return print y". also, for the future, please use hpaste.org for code >1 line :-) thanks
18:06:59 <dav> typoclass: ok sorry :)
18:07:01 <Nisstyre> dav: remember that return wraps your value back up in the monad (IO here), so no need to do return if you're already returning something in the IO monad anyway
18:07:04 <Nisstyre> (which print does)
18:07:14 <monochrom> this program, after correcting for error messages, will still not do a thing.
18:07:14 <typoclass> dav: don't worry about it
18:07:31 <Ghoul_> @pl take 10 $ map sum [ (take 3) . drop (j) $ [x | x <- [1..], odd x] | j <- [1..] ]
18:07:31 <lambdabot> take 10 [sum (take 3 (drop j ([x | x <- [1..], odd x] | j <- [1..])))]
18:07:37 <dav> Nisstyre: parse error on input `x' <= this is the error
18:07:51 <monochrom> oh wait, "print y" will cause it to do a thing. nevermind.
18:08:22 <Nisstyre> monochrom: assuming myHandler gets called
18:08:29 <Ghoul_> > take 10 [sum [1..5]]
18:08:30 <lambdabot>   [15]
18:08:33 <Nisstyre> which I think it does
18:08:39 <Ghoul_> > take 10 [sum [1..5]..]
18:08:40 <lambdabot>   [15,16,17,18,19,20,21,22,23,24]
18:08:47 <Ghoul_> mind .. blown.
18:09:12 <Nisstyre> Ghoul_: what's amazing about that?
18:09:22 <Nisstyre> > take 10 [34-10..]
18:09:23 <lambdabot>   [24,25,26,27,28,29,30,31,32,33]
18:09:27 <Ghoul_> Oh actually, its not what I thought it was
18:09:42 <Ghoul_> I thought it was a ton of the functions in a list
18:09:52 <Ghoul_> that's much less cool :(
18:09:59 <typoclass> Ghoul_: yup. "sum" binds very tightly, like all function applications. so "take 10 [sum [1..5]..]" comes out as "take 10 [15..]"
18:10:14 <applicative_tmp> you can have tons of functions in a list Ghoul_
18:10:15 <Nisstyre> > take 10 [sum [0..n] | n <- [1..20]]
18:10:19 <lambdabot>   [1,3,6,10,15,21,28,36,45,55]
18:10:21 <typoclass> Ghoul_: i guess you *could* write an Enum instance for functions ...?
18:10:35 <typoclass> Ghoul_: just kidding :-) don't let me give you crazy ideas
18:10:38 <Ghoul_> D: bombarded with scary solutions
18:10:59 <dav> I think it was an indenting issue. I was supposed to align the x with do ?
18:11:05 <Nisstyre> note these are just the sequence of triangular numbers
18:11:42 <typoclass> > map (\f -> f 123) [pred, negate, (*2)] -- Ghoul_: here's an example of several functions in a list, and using them
18:11:44 <lambdabot>   [122,-123,246]
18:11:55 <typoclass> > map ($ 123) [pred, negate, (*2)] -- alternate version
18:11:57 <lambdabot>   [122,-123,246]
18:12:16 <dav> wooohooo I got it to work
18:17:15 <orzo> I want to represent a vector as a magnitude paired with a unit vector.  Is there a name for that representation?
18:18:08 <monochrom> "magnitude-direction"
18:18:15 <orzo> hm
18:18:29 <orzo> not a very elegant sounding name
18:18:39 <mekeor> uhm, how do i get [a,c,e,g,i] from [a,b,c,d,e,f,g,h,i,j] best?
18:18:42 <jmcarthur> it'
18:18:44 <jmcarthur> err
18:18:47 <jmcarthur> it's precise at least
18:19:12 <typoclass> mekeor: heh, nice question
18:19:43 <jmcarthur> > let xs = [a,b,c,d,e,f,g,h,i,j] in [xs!!0, xs!!2, xs!!4, xs!!6, xs!!8]
18:19:45 <lambdabot>   [a,c,e,g,i]
18:19:49 <jmcarthur> that's one way
18:20:02 <mekeor> but that's stupid... :P :D
18:20:20 <jmcarthur> you only gave an input and an output
18:20:22 <JoeyA> > let xs = [a,b,c,d,e,f,g,h,i,j] in [x | (x,i) <- zip xs [1..], odd i]
18:20:23 <lambdabot>   [a,c,e,g,i]
18:20:26 <jmcarthur> i could try to infer what you want
18:20:32 <JoeyA> Or with parallel list comprehensions:
18:20:34 <mekeor> jmcarthur: i think it's clear what i want, isn't it?
18:20:40 <jmcarthur> maybe
18:20:41 <typoclass> > map ("abcdefghi"!!) $ filter odd [1..] -- good nuff ;-)
18:20:42 <lambdabot>   "bdfh*Exception: Prelude.(!!): index too large
18:20:46 <JoeyA> err, nvm
18:20:47 <jmcarthur> sometimes i make such assumptions and i'm wrong
18:21:04 <JoeyA> Be careful with !!.  It takes O(n) time
18:21:18 <JoeyA> So those solutions traverse the list again and again.
18:21:19 <monochrom> pronounce "magnitude-direction" as though it's French. then it sounds more elegant :)
18:21:28 <mekeor> yeah
18:21:34 <typoclass> JoeyA: yeah ... well he mentioned a list of 8 or 10 elements
18:21:43 <JoeyA> Oh
18:22:08 <jmcarthur> > map snd . filter (even . fst) . zip [0..] $ [a,b,c,d,e,f,g,h,i,j]
18:22:09 <lambdabot>   [a,c,e,g,i]
18:22:18 <mekeor> the list is quite big. 36*3 elements are there
18:22:22 <mekeor> > 36*3
18:22:23 <lambdabot>   108
18:22:27 <jmcarthur> that's not big
18:22:30 <JoeyA> f [a,b,c,d,e,f,g,h] = [a,c,e,g]; f [a,b,c,d,e,f,g,h,i] = [a,c,e,g,i]; f [a,b,c,d,e,f,g,h,i,j] = [a,c,e,g,i]; f _ = error "Pay me more"
18:22:31 <mekeor> yep
18:23:06 <jmcarthur> anyway, i have now given both a sarcastic and an actual solution
18:23:17 <mekeor> jmcarthur: nice one :)
18:23:19 <typoclass> mekeor: i would start worrying about (!!) being O(n) when you get to tens of thousands or thereabouts
18:23:20 <JoeyA> lol
18:23:24 <mekeor> jmcarthur: ill take yours :)
18:23:33 <mekeor> typoclass: of course
18:24:09 <JoeyA> f (a:_:xs) = a : f xs; f [a] = [a]; f [] = []
18:24:16 <mekeor> thanks guys, #haskell is always genius :)
18:24:19 <monochrom> but we always get to tens of thousands quickly
18:24:42 <mekeor> JoeyA: that's boring :P  – jmcarthurs solution is nice, imo :P :D
18:25:01 <JoeyA> But mine's shorter :-)
18:25:06 <JoeyA> Could be even more shorterer.
18:25:07 <mekeor> :D
18:25:39 <JoeyA> >length "f(a:_:s)=a:f s;f s=s"
18:25:44 <JoeyA> > length "f(a:_:s)=a:f s;f s=s"
18:25:46 <lambdabot>   20
18:25:55 <monochrom> please don't use numbers where booleans suffice
18:26:20 <monochrom> map snd . filter fst . zip (cycle [True,False])
18:26:20 <JoeyA> Given that sexiness is apparently a requirement, you could use foldr here.
18:26:46 <Nisstyre> What strategy does GHC use to do precedence parsing? Precedence climbing?
18:26:55 <cmccann> monochrom: booleans are practically numbers anyway.
18:26:59 <cmccann> Bool is just Word1.
18:27:20 <typoclass> cmccann: i want Int1
18:27:30 <JoeyA> Err, nevermind, can't use foldr for this (easily).
18:27:32 <monochrom> yes, but [0..] gets you to unbounded numbers
18:27:37 <cmccann> typoclass: sure but obviously that is completely different from Word1
18:28:36 <jmcarthur> i claim that monochrom's is superior to mine
18:28:43 <monochrom> thanks
18:31:10 <jmcarthur> > head . transpose . takeWhile (not . null) . iterate (drop 2) $ [a,b,c,d,e,f,g,h,i,j]
18:31:11 <mekeor> monochrom: thanks :)
18:31:11 <lambdabot>   [a,c,e,g,i]
18:31:54 <JoeyA> > head . transpose . takeWhile (not . null) . iterate (drop 2) $ []
18:31:56 <lambdabot>   *Exception: Prelude.head: empty list
18:31:59 <jmcarthur> > concatMap (take 1) . takeWhile (not . null) . iterate (drop 2) $ [a,b,c,d,e,f,g,h,i,j]
18:32:01 <lambdabot>   [a,c,e,g,i]
18:32:06 <jmcarthur> > concatMap (take 1) . takeWhile (not . null) . iterate (drop 2) $ []
18:32:08 <lambdabot>   []
18:32:10 * JoeyA made lambdabot fall on its head
18:32:27 <mekeor> *her
18:32:33 <jmcarthur> > concatMap (take 1) . iterate (drop 2) $ []
18:32:37 <lambdabot>   can't find file: L.hs
18:32:54 <jmcarthur> ah that won't work anyway
18:33:25 * hackagebot linear 1.1.2 - Linear Algebra  http://hackage.haskell.org/package/linear-1.1.2 (EdwardKmett)
18:33:50 <jmcarthur> ha. i only just now found out that package was broken and it's already fixed again
18:35:10 <monochrom> "there and back again"
18:36:00 <typoclass> > let f (a:_:b) = Just (a,b); f [a] = Just (a,""); f [] = Nothing in unfoldr f "abcdefghi"
18:36:01 <lambdabot>   "acegi"
18:36:16 <Adam`> :t unfoldr
18:36:18 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
18:36:26 <typoclass> JoeyA: if unable to use foldr, use unfoldr
18:36:29 <mekeor> how do i get [(a,b),(c,d),(e,f)] out of [a..f]?  -- one way would be "f $ zipWith (,) list (tail list)" where f = lookAbove
18:36:31 <typoclass> *cough* what a great guideline
18:36:47 <monochrom> general guideline: combine foldr and unfoldr
18:37:00 <mekeor> monochrom: talking to me?
18:37:01 <typoclass> mekeor: transpose or sumthin'
18:37:06 <monochrom> no :)
18:37:07 <mekeor> :t transpose
18:37:09 <lambdabot> [[a]] -> [[a]]
18:38:23 <JoeyA> typoclass: nice
18:38:32 <typoclass> Adam`: you give it 2 arguments: a function and an initial value. unfoldr will call the function repeatedly, collecting all its 'a' return values, until it produces Nothing
18:38:37 <monochrom> it's a useless guideline. every function can be rewritten as composing one foldr and one unfoldr. it is as useless as "general guideline: use lambda calculus"
18:39:29 <typoclass> monochrom: if you are referring to my guideline, it was not meant serious to start with
18:39:36 <monochrom> hehe
18:39:59 <monochrom> yeah I just want to take it to the extreme :)
18:40:11 <monochrom> the unseriousness to the extreme :)
18:40:23 <typoclass> monochrom: alright ;-)
18:40:52 <JoeyA> mekeor: boring answer: f (a:b:xs) = (a,b) : xs; f [] = []; f [x] = error "what do I do if the list has an odd number of items?"
18:40:54 <monochrom> "try foldr. then try unfoldr. then try both. must work. in theory!"
18:41:35 <Adam`> don't you mean f(a:b:xs) = (a, b) : f(xs)?
18:41:44 <JoeyA> Yes
18:41:49 <JoeyA> sorry
18:42:03 <Adam`> and also f (a:[]) = [] for the odd number of elements
18:42:05 <geekosaur> why the parens?
18:42:10 <mekeor> JoeyA: yeah, that's what i was doing :)
18:42:12 <Adam`> oh, my b
18:43:17 <typoclass> Adam`: note that in general, parens aren't used to call functions in haskell :-) you can just say "f xs". "f(xs)" is equivalent, but it'll work only for 1-argument functions
18:43:40 <monochrom> "map (f) (xs)" works too :)
18:43:51 <Adam`> right, i'm pretty familiar with that stuff, I just always worry about how cons associates
18:43:52 <monochrom> indeed Landin wrote like that all the time
18:44:01 <typoclass> monochrom: "map(f, xs);"
18:44:09 <JoeyA> :t let z = f(x,y) in f
18:44:11 <lambdabot> FromExpr a => a
18:44:15 <JoeyA> pfft
18:44:21 <monochrom> no no, he seriously wrote "f(x)(y)"
18:44:54 <mekeor> oh crap
18:45:08 <typoclass> Adam`: oh i see. well the ground rule is: function application is tighter than anything else. including (:)
18:45:17 <mekeor> ah okay
18:45:24 <JoeyA> cons isn't even that high up there.
18:45:25 <JoeyA> :i :
18:45:27 <monochrom> and I think Milner too, in the type inference paper
18:45:38 <JoeyA> infixr 5 :
18:45:57 <Adam`> right, so when pattern matching functions on lists can you say f x:[] or do you need parens?
18:46:17 <monochrom> yes, need f (x:[])
18:46:33 <Adam`> yeah, that's what I thought
18:46:45 <geekosaur> it was the f(xs) that I was talking about; we'd normally write: f xs
18:47:10 <geekosaur> if parens were needed there, they would not help as uyou had them; it would be: (f xs)
18:47:12 <Aetherspawn> >map(sum)([1..3]
18:47:20 <Aetherspawn> > map(sum)([1..3]
18:47:21 <lambdabot>   <hint>:1:16: parse error (possibly incorrect indentation)
18:47:24 <Aetherspawn> woops.
18:47:26 <Aetherspawn> > map(sum)([1..3])
18:47:28 <lambdabot>   No instances for (GHC.Enum.Enum [b0], GHC.Num.Num [b0])
18:47:28 <lambdabot>    arising from a u...
18:47:37 <Adam`> Oh, I haven't a clue why i wrote that
18:47:42 <Aetherspawn> Okay, I'm retarded
18:48:01 <Aetherspawn> [1..3] is clearly not a list of lists. Ignore and proceed.
18:48:01 <monochrom> map sum [1..3] = [sum 1, sum 2, sum 3] = what do you mean
18:48:17 <dav> All - What do you guys use to indent haskell code? All the vim plugins seem to not get indentation right..
18:48:29 <dav> Is there an external software I could use?
18:48:31 <monochrom> I use emacs. I am sorry.
18:48:35 <Aetherspawn> sublime text is good at haskell
18:48:40 <Mikicacarica> http://beac9b24.theseblogs.com
18:49:00 <Adam`> how do you get auto-indent to work in emacs, I always manually type spaces?
18:49:58 <monochrom> I install "haskell-mode" and tell it to use 'turn-on-haskell-indentation
18:50:16 <Adam`> thanks
18:50:42 <monochrom> my http://hpaste.org/47103/emacs_haskellmode_demo shows what it does
18:51:27 <typoclass> dav: i've set the tab key to produce 4 spaces *shrug* seems good enough. maybe i'm aiming too low
18:52:18 <monochrom> that already helps a lot
18:52:35 <monochrom> just needs a few manual adjustments
18:53:04 <dav> typoclass: :( I'm not familiar with the alignements with do etc. in haskell I was hoping some software would do this for me..
18:53:50 <typoclass> dav: don't worry, it'll become clear with just a little bit of practice
18:54:25 <monochrom> it is not so much "relative to do" as "relative to siblings"
18:55:42 <monochrom> after "do", the first thing may be on the same line or next line, and it must be on "o"s column or more right. that is all as far as "relative to do" is concerned.
18:56:14 <monochrom> the most important part: from the second thing onwards, everyone must align with the first thing.
18:57:25 <dav> what about some linting showing me libraries I'm importing but not using, etc. ?
18:57:27 <typoclass> dav: there's only 4 keywords that trigger layout: let, of, do, where. "of" is from "case ... of". the letter that follows these keywords determines how much you need to indent. "do something" means you need to align the next line so that you're under the "s". if you wish you can put newline(s) between "do" and "something". you still need to indent the following lines to start under "s"
18:58:09 <dav> typoclass: makes sense, thanks.
18:58:34 <typoclass> dav: "ghc -Wall" is a good thing to use, and if you want, hlint. for an impression of what messages hlint produces, check the yellow and red lines at the bottom of a hpaste.org page
18:58:48 <dav> I guess I'm going to keep let/or/do/where at the end of their respective lines so that I can indent everything by multiple of 4
18:59:04 <monochrom> yes, that works nicely
18:59:32 <typoclass> dav: yes, i do that as well
19:00:48 <typoclass> dav: random example of 2 hlint warnings: http://hpaste.org/88217 i'd say it's more or less useful :)
19:01:08 <Fuco> is there a built-in loop function? like: loop n f = last . take n . iterate f but not wasting space with intermediate list
19:01:32 <zRecursive> Can anybody inspire my confidence for app. developed with Haskell ?  In fact i am worrying "default lazy" will make me lose control of the app.
19:01:39 <Maxdamantus> Fuco: fix
19:01:49 <monochrom> normally, last . take n . iterate f does not waste space with intermediate list
19:02:11 <monochrom> fix is entirely different and unrelated
19:02:38 <Fuco> monochrom: hm, so is it safe to rely on compiler being smart enough? :P
19:02:38 <Maxdamantus> It loops.
19:03:17 <typoclass> zRecursive: hm ... with laziness, there will still be everything evaluated that you need. (e.g. for printing out, sending over the network, etc). you just will never be evaluating the stuff you don't need.
19:03:34 <monochrom> but because of laziness, it wastes spaces on storing n nestings of f's without evaluating them away
19:05:20 <typoclass> zRecursive: a form of laziness is lazy initialization, which you may know from c or java or similar. "if (thingy == null) { thingy = initThingy(); } ... use thingy ...". with this, you're not "losing control" of thingy either :-)
19:05:22 <monochrom> if you want less lazy evaluation, all in all you may as well write your own loop n f so you can say where to force evaluation
19:06:03 <xj54y> Hello! I've run into haskell a few times and I've given into taking a brief but serious understanding of Haskell as a computable language. I feel as though it's the expression of a language of a thinker, an artist whose to perfect their craft not only by seeking greater wisdom in the mechanic of the system, but also to strive for the inspiration of new ideas in their very craft. I do however wonder, does such a languages' back-end support micro-systems of var
19:06:03 <xj54y> ying sizes varying proportions by the luxury of efficiency, that is, to strike balance of what the utility of our great 3AC, C, as the instruction of ones necessity may be abound by the complexity of its logic and further determinants.; Could Haskell be utilized under systems of considerable constraint or at the very least, perhaps optimized though translation of other means?
19:07:25 <geekosaur> ...wat
19:07:39 <Adam`> I'm not sure I understood either
19:07:49 <monochrom> that is truly a question for thinkers
19:07:59 <monochrom> I use haskell as a programmer, not thinker
19:08:18 <monochrom> you see, I don't even play type-level tricks
19:08:18 <typoclass> xj54y: hello, some people are using atom to input haskell, but output code for embedded systems. for what it's worth. http://hackage.haskell.org/package/atom
19:08:19 <luite> xj54y: jhc/ajhc run on rather small systems
19:10:13 <geekosaur> that read like some new age screed. I'm not sure what lambda calculus has with new age foo
19:11:06 <Adam`> I'm not %100 sure what the lambda calculus is, but I've just been assuming it'b basically haskell and I haven't had a problem yet
19:12:02 <xj54y> typoclass, this'll do for now..
19:12:16 <xj54y> I thank all of you.
19:15:02 <zRecursive> It seems programmers cannot determine when those trunks to be evaluated ? then how to debug it step by step ?
19:17:25 * zRecursive how about "default strict"" and "lazy when needed" ?
19:39:44 <otters> trunks
19:39:46 <otters> heh
19:41:48 <zRecursive> otters: trunk ?
19:41:53 <zRecursive> :-D
19:41:56 <otters> thunks?
19:43:28 <zRecursive> otters: it is annoying to use '!' in source code, isnot it ?
19:43:36 <otters> ehh, I guess
19:59:28 <Cale> zRecursive: It's usually pretty easy to determine where you need strictness, once you've had some practice at it.
19:59:32 <applicative_tmp> zRecursive: you can study evaluation of simple things inside ghci with :sprint or :print
20:00:23 <t4nk141> Hi all - does anyone know much about the cloud haskell closure mechanisms? I'm playing around with the example given in Control.Distributed.Static   with the 'decodeDict' example,   $(mkStatic 'decodeDict) :: Typeable a => Static (SerializableDict a -> BSL.ByteString -> a)   and it gives me   Not in scope: `decodeDict__static'
20:00:34 <applicative_tmp> yipe
20:00:47 <Cale> zRecursive: Generally, it's sufficient to think in terms of expressions being rewritten at runtime, rather than the actual implementation in terms of thunks.
20:01:31 <zRecursive> Cale: seems reasonable
20:04:39 <Cale> Saulzar: I don't really know much about it, but where is mkStatic defined?
20:05:33 <Saulzar> It is Control.Distributed.Static  ... I guess I should dump the splice and see what it is actually doing
20:06:02 <applicative_tmp> https://github.com/haskell-distributed/distributed-process/blob/master/src/Control/Distributed/Process/Internal/Closure/TH.hs
20:07:52 <zRecursive> Cale: why "map (\n->take n! [1..]) [1..10]" error when using n! ?
20:08:20 <Cale> What is !?
20:08:43 <zRecursive> strict ?
20:08:47 <Cale> No.
20:09:29 <Cale> Perhaps you're thinking of $! though it has very low precedence (and is obnoxiously right associative)
20:09:48 <Cale> Also, take is already strict in its first argument, so you wouldn't need to force n, because take is going to.
20:10:06 <Michael_> What's the best way, if I want to encode more information about what a constructor (which is actually acting as a function in my language inside of haskell) accepts? For example, I'm currently storing more information in a map, with the name of the function/constructor as the key, and the signature, using my own defined operators as the value. Equal, in my language, is ( "equal"   , Signature [Eq A] [Class A,Class A, Bo
20:10:06 <Michael_> ol]) IS there a better way to use the typesystem to do this?
20:10:27 <Cale> Unless you meant to force the list, in which case, well, take is also strict in its second argument :P
20:10:43 <zRecursive> Cale: how to you know its 1st argument is strict ?
20:10:48 <Cale> @src take
20:10:48 <lambdabot> take n _      | n <= 0 =  []
20:10:48 <lambdabot> take _ []              =  []
20:10:48 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
20:11:02 <shachaf> take (-1) is not strict!
20:11:06 <Cale> The n <= 0 test will force n to be evaluated
20:11:17 <Cale> and the pattern matching on the list will force the list to be evaluated
20:11:44 <Cale> Well, that's true
20:12:43 <Cale> > take (-1) undefined
20:12:45 <lambdabot>   []
20:12:49 <Cale> > take 0 undefined
20:12:50 <lambdabot>   []
20:13:10 <centrinia> > take 1 undefined
20:13:10 <Cale> So it's not strict in the list for nonpositive numbers
20:13:12 <lambdabot>   *Exception: Prelude.undefined
20:13:22 <Cale> But will force the list to be evaluated for any other value of n
20:13:51 <centrinia> > undefined <= 0
20:13:52 <lambdabot>   *Exception: Prelude.undefined
20:13:55 <Cale> (and indeed, will force the first n cons cells to be evaluated, if the list is that long)
20:14:24 <Cale> Well, assuming you evaluate the resulting list fully :D
20:14:33 <zRecursive> then no trunks created using take ?
20:14:33 <monochrom> zRecursive: see my http://www.vex.net/~trebla/haskell/lazy.xhtml
20:14:37 <Cale> trunks?
20:14:42 <Aetherspawn> Would it be better to use lazy or strict state for representing a player's data in a server?
20:14:48 <zRecursive> thunks
20:15:01 <centrinia> What n :: Int satisfies n<=0 and does not look like your usual Int?
20:15:11 <zRecursive> monochrom: thx
20:15:16 <monochrom> "trunk" refers to trunk of a tree, an expression tree
20:15:24 <Cale> zRecursive: You can create an expression (implemented with a thunk) which involves an unevaluated application of take (or any function)
20:15:28 <centrinia> > (9223372036854775808 :: Int) <= 0
20:15:31 <lambdabot>   True
20:15:41 <applicative_tmp> zRecursive: are afraid of 'thunks'?
20:15:43 <centrinia> > take 9223372036854775808 undefined
20:15:46 <lambdabot>   []
20:15:53 <zRecursive> applicative_tmp: a bit
20:16:11 <Cale> zRecursive: Don't think in terms of thunks, think in terms of expressions reducing to other expressions.
20:16:25 <scooty-puff> does anything special need to be done when using ByteArray#s directly to avoid problems with the garbage collector?
20:16:28 * monochrom thinks in terms of trunks
20:16:49 <zRecursive> Cale: thunks is implementation relative ?
20:16:54 <breadthfirst> Can I put a typeclass in place of a type in a polymorphic data type? Like saying List (Eq a)?
20:16:58 <scooty-puff> if i used newPinnedByteArray# (instead of newByteArray#) of the same size, and do the same operations (readIntArray#, writeIntArray#), i avoid a segmentation fault
20:17:12 <scooty-puff> i also avoid it if i set +RTS -A<obscenely large>
20:17:14 <shachaf> breadthfirst: No. You can do something vaguely similar, but it's very likely that you don't actually want to.
20:17:33 <Cale> So if I write  take 3 [1..], the 3 is not less than or equal to 0, so the first case in the definition of take doesn't apply, and then to check if the second case applies, we need to evaluate [1..]
20:17:50 <Cale> and it evaluates to 1 : [2..], which is a cons, and so doesn't match []
20:17:53 <Aetherspawn> Would it be better to use lazy or strict StateT for representing a player's data in a server, do you think?
20:18:00 <Cale> but it does match (x:xs) in the third case
20:18:18 <monochrom> expression : thunk :: number : bit. you can talk low-level, but not always as low as bits
20:18:31 <Cale> and so  take 3 [1..] reduces to take 3 (1:[2..]) which reduces to 1 : take (3 - 1) [2..]
20:18:35 <Aetherspawn> Lazy it is, lol :P
20:19:00 <zRecursive> lazy ?
20:19:01 <Cale> and now if we were just interested in the head of the list, take would be finished here
20:19:20 <Cale> lazy evaluation is just outermost-first evaluation with sharing.
20:19:38 <Cale> But let's say we're printing the resulting list.
20:19:56 <Cale> Then we'll eventually want to see if there's another element in it
20:20:14 <Cale> at which point we'll need to evaluate this expression  take (3-1) [2..]
20:20:22 <applicative_tmp> Aetherspawn: isnt that the default?  ... but I think they introduced Control.Monad.Trans.State.Strict for a reason ...
20:21:07 <Cale> In order to determine whether n <= 0 is true in the first case of take, again, we'll have to evaluate 3-1, reducing the expression to take 2 [2..]
20:21:16 <Cale> and 2 is not less than or equal to 0
20:21:18 <zRecursive> Cale: thanks, need time to understand it
20:21:29 <centrinia> But 9223372036854775808 is less than or equal to 0.
20:22:12 <monochrom> State.Lazy is the default State. but you seldom want it. the only time you want it: see my http://hpaste.org/41790/
20:22:49 <Aetherspawn> strict it is
20:23:00 <Cale> centrinia: Only sometimes! It's legal for it not to be, because the size of Int is not completely determined by the standard.
20:37:32 <pygmalion> So the documentation for Data.Text briefly discusses "fusion" and then goes on to note which functions are "Subject to fusion." As I understand the introduction, this sounds like a *good* thing, because it's more space efficient and problem faster because their are fewer allocations. But the phrasing "subject to fusion" sounds almost like a warning of a negative thing. Am I missing something?
20:37:50 <applicative_tmp> no, its just plain good :)
20:38:04 <luite> is it possible to have long options with only the --option=value syntax with optparse-applicative? (instead of --option value) ?
20:38:40 <applicative_tmp> pygmalion: if f and g are both subject to fusion then f (g x) will not involve building g x
20:39:24 <pygmalion> applicative_tmp: which is good, right? Or is there a negative I'm missing here?
20:39:29 <geekosaur> pygmalion, you're confusing technical phrasing with vernacular usage
20:40:08 <applicative_tmp> its good; your hope is to get fusion, and not to impede it, so to say
20:40:14 <shachaf> If they objected to fusion, they would say "object to fusion".
20:40:19 <pygmalion> applicative_tmp: got it, that's what I thought.
20:40:33 <pygmalion> shachaf: Ah ok.
20:40:39 <applicative_tmp> pygmalion: it's pretty simple, if you look at relevant bits of source
20:40:40 <shachaf> pygmalion: Sorry, that was a joke.
20:40:55 <shachaf> pygmalion: Ignore it. I shouldn't have said that while you were asking a serious question.
20:41:13 <pygmalion> shachaf: Haha no worries! My first instinct was to laugh but then I was like "huh maybe that's true..."
20:41:23 <applicative_tmp> pygmalion: pygmalion: it basically means that f and g are defined in terms of f' and g' as unstream . f' . stream and unstream . g' . stream
20:41:51 <pygmalion> applicative_tmp: Ah ok so you can just put the application of g' and f' in between the same unstream/stream pair
20:41:51 <applicative_tmp> stream takes the underlying array and makes a little state machine with it; unstream writes a new array with the machine
20:42:46 <applicative_tmp> so f . g = stream . f' . stream . unstream . g' . stream
20:42:54 <d1323> hello. is there a function that combines two output Handle-s into a single Handle?
20:43:11 <applicative_tmp> fusion means getting rid of stream . unstream,  pygmalion
20:43:31 <pygmalion> applicative_tmp: Yup, got it. Thanks a lot! Seems simple enough.
20:43:55 <d1323> writing to the resulting Handle would write to both Handles
20:44:28 <applicative_tmp> so in a nicely fused composition f . g. h . j you  input an array to j (= unstream . j' . stream) and output one with f, but there are no arrays in between.
20:44:43 <applicative_tmp> pygmalion: when fusion fails, the array in the middle is written
20:45:53 <Aetherspawn> :S monads and transformers
20:46:09 <Aetherspawn> can someone help me make sense of what's going on http://puu.sh/2X8hr/f420bcb742.png
20:46:28 <Aetherspawn> serverApp :: Application SessionIO but the runTCPServer function wants Application IO
20:48:47 <pygmalion> applicative_tmp: Cool, thanks a lot for the explanation.
21:02:46 <lispy> applicative_tmp: the fact that they make a state machine with it, does that matter?
21:05:04 <carter> lispy hello!
21:05:06 <carter> how're you doing?
21:39:44 <NemesisD> anyone knoow how to get your local hoogle to index more packages or maybe all the ones you have installed?
21:40:03 <shachaf> Perhaps hoogle combine will help.
21:41:10 <NemesisD> how do you use it? hoogle help does not seem to document subcommands :(
21:41:38 <shachaf> hoogle subcommand --help
21:43:07 <NemesisD> i tried that. it just displays the main help for hoogle
21:43:28 <shachaf> ?
21:43:32 <shachaf> hoogle combine [OPTIONS] [DATABASE] Combine multiple databases into one
21:43:56 <NemesisD> what version do you have?
21:44:11 <shachaf> v4.2.16
21:44:52 <NemesisD> weird i don't get that specific command's help from hoogle combine --help, and i am using the same version as you
21:53:29 * hackagebot pipes-network 0.4.0.0 - Use network sockets together with the pipes library.  http://hackage.haskell.org/package/pipes-network-0.4.0.0 (RenzoCarbonara)
21:53:56 <binaryunary> hi all
21:54:25 <binaryunary> I'm a bit of stuck with Parsec's chainl
21:55:55 <binaryunary> I'm trying to parse a source code string into an AST
21:56:24 <binaryunary> can ayone check if my expression parser can even be used with chainl?
21:56:32 <binaryunary> http://hpaste.org/88225
21:57:59 <binaryunary> the problematic part is the 'bop' parser for binary operators
21:59:26 <NemesisD> is there a good way to specify default install options for cabal? i want it to use -j4 and --hoogle
21:59:56 <zRecursive> NemesisD: ~/.cabal/config ?
22:03:15 <binaryunary> anyone?
22:04:49 <hamid> :t (<|>)
22:04:50 <lambdabot> Alternative f => f a -> f a -> f a
22:05:45 <mstksg> does anyone know any good haskell podcasts or blogs?
22:06:04 <NemesisD> zRecursive: if that file is complete i don't see an option there that would do it
22:06:47 <NemesisD> except maybe flags
22:09:19 <Saulzar> Mm... mkStatic 'sendResult ======> sendResult__static    so it must be generated somewhere else,  and $(mkClosure 'sendResult)  refers to this sendResult_sdict  which only exists if sendResult is a monomorphic function
22:09:38 <Saulzar> (using remotable ['sendResult])
22:12:31 <orzo> is there a way to instruct ghc to import a module into scope even though there is no import statement in the scope?  Like a sort of local augmenting of the Prelude?
22:12:38 <NemesisD> is there no documentation for the .cabal/config file or am i just extremely bad at navigating the docs
22:12:43 <orzo> sorry, no import statement in the source
22:13:42 <dmj> if I want to pass around a Data.Map what are the pros/cons of using an IORef over the Reader Monad
22:15:22 <NemesisD> dmj: i have some idea but lack the technical understanding to express it. i'll let someone else answer ;)
22:16:47 <dmj> NemesisD: Since IORef is mutable I can assume it will most likely be more efficient, but maybe not as composable if I wanted to use Reader with IO let's say
22:16:57 <Saulzar> IORef only works in IO, and you need to pass the variable around where as reader will thread it for you...  (IORef is also more akin to State, because you can modify the variable, too)
22:17:42 <wereHamster> is it possible to install cabal packages into a custom directory (instead of ~/.cabal/lib)?
22:17:46 <Tekmo> ocharles: Are you there?
22:18:01 <Saulzar> I wouldn't expect it to be more efficient... but I wouldn't really know.
22:18:35 <Saulzar> The Map is not mutable regardless if you use a Reader/State or IORef
22:19:25 <Saulzar> modifying an IORef Map only replaces the Map at the IORef level
22:21:12 <dmj> Saulzar: Thank you, what I needed
22:25:44 <satshabad> hey could someone help me understand the order that this statement is evaluated in?
22:25:46 <satshabad> filter (not . any isSpace) . groupBy ((==) `on` isSpace) $ "hey guys its me"
22:26:04 <satshabad> I know that the thing to the right of $ is applied last
22:26:32 <satshabad> but what happens first? groupBy ((==) `on` isSpace) ? does that return a partial?
22:26:35 <shachaf> It's a string, it's not applied at all.
22:26:51 <shachaf> That's a big complicated expression. Do you maybe have a simpler one that could answer whatever question you have?
22:27:13 <satshabad> hmmmm
22:27:22 <satshabad> let me see
22:28:51 <satshabad> well I think the reason It's so complicated is making me confused. As soon as I simplify it, I see what's going on.
22:29:08 <Saulzar> Well, the string on the right of is applied to the function on the left last
22:29:13 <satshabad> OK
22:29:20 <Saulzar> (As you expect)
22:29:21 <shachaf> Saulzar: ?
22:29:23 <satshabad> but what happens first?
22:29:25 <arkeet> ??
22:29:43 <arkeet> I think everyone should read http://www.vex.net/~trebla/haskell/lazy.xhtml
22:29:51 <shachaf> arkeet: Should I?
22:30:00 <arkeet> well, unless you already know the material
22:30:14 <Saulzar> someExpression $ str   , the someExpression will be evaluated first and then   someExpression str   evaluated after that
22:30:24 <Saulzar> (Which is the point of using $
22:30:28 <satshabad> Saulzar: right, thats what I thought
22:30:45 <arkeet> but there isn't much to evaluate on the left
22:30:57 <satshabad> Saulzar: I think that  (not . any isSpace) or groupBy ((==) `on` isSpace happens next
22:31:00 <arkeet> it just gets turned into a lambda
22:31:13 <Saulzar> Hmm, maybe evaluated is the wrong term..
22:31:15 <satshabad> yes, but in what order?
22:31:42 <Saulzar> No, it is ... the things which are evaluated are the composition operators   (.)
22:32:17 <Saulzar> f . g $ "hey guys it's me"
22:32:27 <satshabad> and, why  don;t wee need a composition operator between any and isSpace?  (not . any isSpace)
22:32:35 <Saulzar> where f = filter (not . any isSpace)     and      g = groupBy ((==) `on` isSpace)
22:32:40 <satshabad> ahhhhh i see
22:33:01 <Saulzar> any takes a function argument (I guess)
22:33:09 <shachaf> satshabad: I suspect that exact evaluation order isn't the most important thing for you to figure out about this expression. :-)
22:33:37 <satshabad> shachaf: Maybe, but it's helping me figure out the rest
22:33:55 <satshabad> ohhh, right
22:34:09 <satshabad> any \x -> True [1,2,3]
22:34:59 <satshabad> right so we're filtering through the list and asking if any of the chars are spaces
22:35:03 <satshabad> cool
22:35:49 <dmj> liftIO is very verbose in transformers, is there anyway around it? putting it liftIO $ putStrLn, and liftIO getline seems a lot.
22:35:55 <dmj> in*
22:36:01 <NemesisD> i'm attempting to upgrade to Cabal 1.16.0.3, but i think i need to get rid of 1.16, cabal complains that ghc-7.6.3 depends on it. should i be scared?
22:36:16 <satshabad> Thanks guys
22:37:13 <zRecursive> lambdabot: > lines "hey guys its me"
22:37:34 <zRecursive> > lines "hey guys its me"
22:37:37 <lambdabot>   ["hey guys its me"]
22:37:47 <zRecursive> > words "hey guys its me"
22:37:50 <lambdabot>   ["hey","guys","its","me"]
22:38:33 <arkeet> satshabad: http://hpaste.org/88232
22:39:23 <satshabad> arkeet: Thanks!
22:39:47 <arkeet> note that if, say, you only ever use the first element of the resulting list, it won't evaluate any further than line 9
22:39:49 <arkeet> because of laziness
22:41:54 <arkeet> note that, for instance, we go from line 5 to 7 because filter pattern matches on its second argument, so that must get evaluated a bit before filter can do any work
22:42:10 <satshabad> that lazy haskell! never doing all the work...
22:42:47 <satshabad> cool
22:47:09 <zRecursive> @src words
22:47:09 <lambdabot> words s = case dropWhile isSpace s of
22:47:09 <lambdabot>     "" -> []
22:47:09 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
22:50:35 <dmj> can you use gaurds with do-syntax?
22:51:00 <dmj> guards?
22:52:26 <cmears> You can write "guard <condition>"
22:53:39 <cmears> > do { x <- [1..10] ; guard (even x) ; return x }
22:53:41 <lambdabot>   [2,4,6,8,10]
22:53:44 <cmears> like that
22:56:09 <zRecursive> > [1 .. 10] >>= \ x -> guard (even x) >> return x
22:56:12 <lambdabot>   [2,4,6,8,10]
22:57:01 <zRecursive> cmears: guard is same as assert in C ?
22:57:49 <zRecursive> @ty guard
22:57:51 <lambdabot> MonadPlus m => Bool -> m ()
22:57:55 <cmears> No, it's quite different
22:57:57 <luite> is it possible to find out the type of exception in a SomeException?
22:58:14 <cmears> C's assert is for finding programmer errors
22:58:24 <zRecursive> it seems guard will not cancel the execution when false ?
22:58:27 <cmears> guard is just a tool in the monad toolbox
22:59:18 <cmears> @src guard
22:59:18 <lambdabot> guard True  =  return ()
22:59:19 <lambdabot> guard False =  mzero
22:59:25 <zRecursive> > guard (2 > 1)
22:59:28 <lambdabot>   No instance for (GHC.Show.Show (m0 ()))
22:59:28 <lambdabot>    arising from a use of `M52913505...
22:59:33 <arkeet> > guard (2 > 1) :: Maybe ()
22:59:35 <lambdabot>   Just ()
22:59:39 <arkeet> > guard (2 < 1) :: Maybe ()
22:59:42 <lambdabot>   Nothing
22:59:52 <zRecursive> i see now
23:00:58 <dmj> but nothing like hey5 hey | hey == 5 = "hey" | otherwise = "nay" in do syntax tho
23:01:14 <dmj> too much lyah
23:18:27 <adnap> Can this be done more simply:
23:18:34 <adnap> > (fmap ((<*>) . pure . flip (,)) (Just 2)) <*> (Just (Just 3))
23:18:36 <lambdabot>   Just (Just (3,2))
23:19:12 <mauke> > fmap (fmap ((,) 2)) (Just (Just 3))
23:19:15 <lambdabot>   Just (Just (2,3))
23:19:20 <mauke> > fmap (fmap (flip (,) 2)) (Just (Just 3))
23:19:22 <lambdabot>   Just (Just (3,2))
23:20:30 <supki> > Just (Just 3) & _Just . _Just %~ flip (,) 2
23:20:33 <lambdabot>   Just (Just (3,2))
23:20:42 <adnap> The impotant thing is that 2 is in an Applicative
23:21:52 <adnap> > (fmap ((<*>) . pure . flip (,)) [2]) <*> [Just 3
23:21:54 <lambdabot>   <hint>:1:49: parse error (possibly incorrect indentation)
23:21:58 <adnap> > (fmap ((<*>) . pure . flip (,)) [2]) <*> [Just 3]
23:21:59 <lambdabot>   [Just (3,2)]
23:22:16 <adnap> I need to actually simplify...
23:22:31 <shachaf> > liftA (liftA ((,) 2)) (Just (Just 3)) -- Applicative!
23:22:36 <lambdabot>   Just (Just (2,3))
23:22:55 <adnap> > (\x y -> (fmap ((<*>) . pure . flip (,)) x) <*> y) [2] [Just 3]
23:22:57 <lambdabot>   [Just (3,2)]
23:23:33 <adnap> I need Applicative f => f a -> f (Maybe b) -> f (Maybe (a, b)
23:23:40 <adnap> )
23:24:02 <adnap> liftA (liftA ((,) 2)) (Just (Just 3)) [2] [Just 3]
23:24:04 <adnap> > liftA (liftA ((,) 2)) (Just (Just 3)) [2] [Just 3]
23:24:07 <lambdabot>   Couldn't match expected type `t0 -> t1 -> a0'
23:24:07 <lambdabot>              with actual type...
23:24:16 <adnap> > (liftA (liftA ((,) 2)) (Just (Just 3))) [2] [Just 3]
23:24:18 <lambdabot>   Couldn't match expected type `t0 -> t1 -> a0'
23:24:18 <lambdabot>              with actual type...
23:24:25 <adnap> Oh, whoops
23:24:31 <adnap> I'm not paying attention
23:24:54 <adnap> :t liftA
23:24:56 <lambdabot> Applicative f => (a -> b) -> f a -> f b
23:27:32 <supki> @ty liftA2 (fmap . (,)) ::  Applicative f => f a -> f (Maybe b) -> f (Maybe (a, b))
23:27:37 <lambdabot> Applicative f => f a -> f (Maybe b) -> f (Maybe (a, b))
23:28:17 <adnap> @ty liftA2 (fmap . flip (,)) ::  Applicative f => f a -> f (Maybe b) -> f (Maybe (a, b))
23:28:19 <lambdabot>     Could not deduce (a1 ~ b1)
23:28:19 <lambdabot>     from the context (Applicative f)
23:28:19 <lambdabot>       bound by the inferred type of
23:28:34 <adnap> :t liftA2 (fmap . flip (,))
23:28:37 <lambdabot> (Functor f1, Applicative f) => f a -> f (f1 a1) -> f (f1 (a1, a))
23:28:50 <adnap> @ty liftA2 (fmap . flip (,)) ::  Applicative f => f a -> f (Maybe b) -> f (Maybe (b, a))
23:28:52 <lambdabot> Applicative f => f a -> f (Maybe b) -> f (Maybe (b, a))
23:29:06 <adnap> supki: Thanks
