cardoso (~thiago@177.182.170.246) joined #haskell
11:16:24 <thoughtpolice> in practice this means every time you read/store to the global GC root, you incur an indirect call (like 'callq *%eax') so the slowdown is huge
11:16:44 <carter> thoughtpolice i meant couldn't you use an inline asm op to claim a register?
11:17:14 <carter> thoughtpolice is the approach different with gcc?
11:17:22 <carter> which rts file could i look at to see this?
11:17:40 <thoughtpolice> you need it pinned for the entire thread, otherwise you'd incur a load/store into the register every time you did 'evacuate()' which is pretty regularly
11:17:51 <thoughtpolice> yes, GCC supports global register variables
11:17:59 <thoughtpolice> so we just reserve a register to contain the GC root and nothing else
11:18:02 <thoughtpolice> so it never has to move
11:18:59 <thoughtpolice> anyway, i figured out how to hack around this, but it's not exactly pretty and i'm sure Apple would tell me to GDIAF if i asked them for support/help
11:20:24 <thoughtpolice> carter: the details are all here http://hackage.haskell.org/trac/ghc/ticket/7602
11:22:45 <carter> GDIAF?
11:22:51 <carter> go die in a fire?
11:23:12 <ntelford_> having some trouble installing hoogle via cabal - keeps complaining that "happy >= 1.17" can't be found, but I just installed it, manually, so it's definitely there!
11:23:20 <ntelford_> anyone familiar with this problem?
11:23:25 <thoughtpolice> carter: yes :P
11:23:26 <carter> ntelford_ try doing cabal install happy?
11:23:35 <monoidal> ntelford_: is it on ghc-pkg list?
11:23:57 <carter> thoughtpolice does llvm support a notion of register pinned variables?
11:24:07 <thoughtpolice> no.
11:24:23 <thoughtpolice> they will probably never support globally pinned registers, in all honesty.
11:24:39 <carter> makes a lot of things harder to optimize I suppose
11:24:47 <Clint> ntelford_: i think you're better off installing the .deb
11:25:06 <thoughtpolice> David Terei originally proposed something like this to Chris Lattner, when he was working on the GHC LLVM backend, and he rejected it. his suggestion was instead to define a custom calling convention instead
11:25:10 <geekosaur> ntelford, it's an executable, check $PATH
11:25:21 <geekosaur> probably you need to add $HOME/.cabal/bin to $PATH
11:25:24 <errrick> http://fidel.cast.ro < lol
11:25:31 <thoughtpolice> hence why GHC has it's own calling convention. it's less work for LLVM guys and probably works out on the whole better with their optimizers/infrastructure
11:25:36 <ntelford_> monoidal, no, and I've forced the install using "cabal install happy" and it definitely installed
11:25:48 <carter> thoughtpolice there is a customer calling convention
11:26:00 <thoughtpolice> yes, that's what i'm saying :P
11:26:09 <carter> thoughtpolice … the registers used in the calling convention seem to differ between 7.6 and head
11:26:25 <carter> https://github.com/ghc/ghc/blob/master/includes/stg/MachRegs.h vs https://github.com/ghc/ghc/blob/ghc-7.6.3-release/includes/stg/MachRegs.h
11:26:25 <ntelford_> oh, hang on
11:26:34 <ntelford_> am I expected to have ~/.cabal/bin on my PATH?
11:26:35 <carter> i'm trying to understand the difference
11:26:50 <carter> ntelford_ having the place binaries are installed be in your path
11:26:52 <carter> would help
11:27:03 * ntelford_ is a cabal newbie
11:27:12 <ntelford_> didn't realise the binaries were installed there :)
11:27:23 <carter> ntelford_ np
11:27:38 <carter> thoughtpolice i'm tryin to understand how the llvm / ghc calling convention stuf works
11:27:58 <Clint> pretty soon you will realize why apt is a better option
11:28:09 <carter> because if I am understanding it correctly, i can write some cmm shims for n ary functions, that have an n+1 paramter thats a fun pointer to jump to
11:28:30 <carter> and then use those to safely wrap up runtime generated code as normal functions
11:28:40 <carter> i'll be starting my experiments on that soon
11:28:47 <carter> but trying to make sure i understand that correclty
11:29:40 <carter> thoughtpolice : speaking of which time for coffee catchup with the llvm dude before he heads out west
11:29:50 <carter> if i can pester you more on this stuff later, that'd be great :)
11:30:56 <shergill> carter: what's the ghc ticket with the issue you're running into?
11:39:12 <amyers> ntelford: Before considering distro Haskell packages you should read this
11:39:13 <amyers> http://www.vex.net/~trebla/haskell/sicp.xhtml
11:39:22 <tomejaguar> What's the default implementation of fail if it's not specified in an Instance Monad"
11:39:25 <amyers> Just so you're aware of the ramifications of doing that
11:39:25 <tomejaguar> ?
11:39:43 <Heffalump> tomejaguar: error
11:39:52 <tomejaguar> Heffalump: makes sense, thanks
11:44:09 <beaky> hello
11:44:36 <beaky> how do i improve the performane of my haskell programs
11:44:58 <Rembane> beaky: How does your program look like now?
11:45:03 <tromp> buy faster computer?
11:45:12 <Rembane> beaky: Profile! Replace the slow parts with fast parts!
11:45:20 <beaky> http://hpaste.org/88491
11:56:43 * hackagebot set-extra 1.3 - Functions that could be added to Data.Set.  http://hackage.haskell.org/package/set-extra-1.3 (DavidFox)
12:01:03 <monochrom> beaky: probably just because System.Random is slow
12:01:17 <beaky> ah, i guess thats the culprit
12:01:43 * hackagebot set-extra 1.3.1 - Functions that could be added to Data.Set.  http://hackage.haskell.org/package/set-extra-1.3.1 (DavidFox)
12:04:26 <dmwit> DavidFox: any, all, or, and for Set are in Data.Foldable...
12:05:26 <quchen> Is Applicative the same as Coapplicative? The laws are different because there's extract/<@> instead of return/<*>, but does it conceptually do the same thing?
12:05:54 <beaky> why is there a CoFoo for every Foo typeclass?
12:06:09 <beaky> e.g. Monads and Comonads
12:06:18 <dmwit> Some typeclasses have many Co versions.
12:06:37 <Heffalump> What's CoShow? Read?
12:06:54 <monoidal> isn't CoShow Read?
12:07:15 <dmwit> beaky: Type classes based on category theory have co- versions because duals are a fundamental construction in category theory.
12:07:16 <monoidal> ah, misunderstood. I mean, yes, CoShow could be Read
12:07:40 <monoidal> on the other hand, Show and Read might make more sense if they were fused
12:07:48 <quchen> Oh, hi dmwit. I still haven't recovered.
12:08:03 <dmwit> Oh, hi quchen.
12:08:33 <dmwit> It's dangerous to recover alone. Take this. http://i.imgur.com/slrFgNV.jpg
12:08:49 <monoidal> but I don't think classes like Eq, Ord, Bounded have duals.
12:09:16 <beaky> I found uses for Functors, Monoids, Applicatives, Monads, and Arrows, but I still haven't touched their covariants...
12:09:19 <beaky> where can I learn about them? :D
12:09:28 <acube> Is it possible to get the name of the module where a TH Dec is spliced from TH
12:09:36 <acube> There are coarrows? :O
12:09:47 <dmwit> sigfpe and edwardk write about the duals sometimes.
12:10:00 <monoidal> beaky: probably comonads would be a good place to start. see typeclassopedia for a collection of materials.
12:10:12 <beaky> so comonads are like the opposite of monads?
12:10:15 <acube> Is there a dual of monoids?
12:10:15 <beaky> or reverse*
12:10:42 <monoidal> acube: a comonoid object is a monoid object in a dual category
12:10:52 <dmwit> acube: Yes, but they're not useful in Haskell. But I don't understand why, so don't ask me.
12:11:13 <monoidal> acube: so, comonoids have a -> (a,a) and a -> (), which is not interesting in Hask
12:11:22 <quchen> dmwit: But they exist in Haskell?
12:11:29 <quchen> dmwit: Or is Monoid = Comonoid in Hask
12:11:40 <byorgey> definitely not =
12:11:45 <dmwit> I don't think anybody has bothered to write down a CoMonoid class... because it's not useful.
12:12:03 <monoidal> class Comonoid w where wappend :: a -> (a,a); wempty :: a -> ()
12:12:08 <dmwit> I am 30% sure of this claim.
12:12:48 <dmwit> monoidal: By itself, that doesn't look useless to me. I think it's the laws that kill you.
12:13:00 <quchen> a -> (a,a) makes me think of RNGs
12:13:01 <dmwit> I had trouble last time I tried to work out what the laws say, though.
12:13:23 <dmwit> Right, "split" was going to be my suggestion for how it could be useful, too.
12:13:26 <byorgey> class Comonoid w where puǝddɐɯ :: a -> (a,a); ʎʇdɯǝɯ :: a -> ()
12:13:37 <quchen> dmwit: but wempty for generators?
12:13:54 <quchen> Take out all the entropy? :-D
12:13:59 <monoidal> dmwit: probably the laws are x -> (x,x) -> ((x,x),x) and x -> (x,x) -> (x,(x,x)) give the same thing up to parentheses
12:14:17 <byorgey> right, but that law is super restrictive
12:14:20 <dmwit> I suppose that seems reasonable, and split doesn't do that.
12:14:21 <acube> monoidal: and how do you reverse the mempty law
12:14:28 <byorgey> basically it means wappend can't do anything interesting
12:14:51 <quchen> Can we invent a new name for wappend? It is creepy.
12:15:02 <byorgey> what's wrong with puǝddɐɯ
12:15:14 <quchen> Unicode is wrong with it
12:15:17 <dmwit> Let's overload split, that will make the conversation easy to follow.
12:15:17 <beaky> why are comonoids not useful?
12:15:18 <monoidal> wappend x = (wappend1 x, wappend2 x)
12:15:31 <dmwit> beaky: That is exactly the question we are exploring together right now.
12:15:35 <beaky> ah
12:15:50 <beaky> so monoids unify things, while comonoids break things apart?
12:16:01 <quchen> Maybe. :-)
12:16:12 <dmwit> monoidal: I see, so we get a law like wappend1 (wappend2 x) = wappend2 (wappend1 x) -- ?
12:16:24 <monoidal> dmwit: yes
12:16:38 <quchen> So composition is commutative? Hm
12:17:04 <acube> So it seems like nobody knows an answer to the question "Is it possible to get the name of the module where a TH Dec is spliced from TH?"
12:17:05 <monoidal> dmwit: and probably wempty (wappend1 x) = x
12:17:19 <dmwit> So for example if wappend1 and wappend2 were inverse, this law could be satisfied.
12:17:21 <acube> monoidal: wempty is always ()
12:17:25 <monoidal> ah right
12:17:38 <acube> that's at least one reason for it being useless
12:18:02 <monoidal> but I'd like to write out the unit law.
12:18:09 <dmwit> Oh, wait, no.
12:18:17 <dmwit> We also get a law saying wappend1 (wappend1 x) = wappend1 x
12:18:30 <dmwit> Yikes, that's a rough law.
12:19:35 <quchen> FINALLY something idempotent in Haskell
12:19:46 <monoidal> ah right
12:19:46 <acube> Or at least get the module name in which a given name or dec is defined from TH?
12:20:18 <dmwit> Okay, so the only things we can get from x are wappend1 x, wappend2 x, and wappend1 (wappend2 x); all other values from any splittings are equal to one of these.
12:20:18 <quchen> dmwit: If you find an involution somewhere in there I'll make it my duty to use it in every single module.
12:21:17 <enthropy> acube: does "location" do it for you?
12:21:26 <enthropy> Language.Haskell.TH.location
12:21:52 <monoidal> A commutative comonad is where wappend1 = wappend2
12:22:15 <acube> enthropy: Thanks alot! Exactly what I was searching for ... How could I overread that? :O
12:22:29 <dmwit> so, data FreeComonoid a = V a | W1 a | W2 a | W12 a; wappend1 (V a) = W1 a; wappend1 (W2 a) = W12 a; wappend1 w = w -- ?
12:22:35 <monoidal> dmwit: I believe wappends must be ids
12:22:42 <monoidal> from the identity law
12:22:44 <beaky> http://hpaste.org/88503 why is this code much more efficient than this version: http://hpaste.org/88491 , even though they look identical?
12:22:49 <dmwit> What is the identity law?
12:22:53 <beaky> I guess replicateM_ is replicating the vector
12:22:59 <beaky> in the frst version
12:23:33 <monoidal> dmwit: if I understand it correctly, x -> (wappend1 x, wappend2 x) -> (wappend1 x, wempty (wappend 2x)) must be the same as x -> (x, ())
12:24:06 <dmwit> hmmmm
12:24:23 <dmwit> not sure I feel as convinced about that one
12:24:36 <monoidal> dmwit: for a monoidal object, going from A*I -> A can be done via lambda or via A*I -> A*A -> A, where first you use monoidal unit then monoidal multiplication
12:25:00 <exFalso1> Hi, is there a way to lazily evaluate an (non-destructive) IO action so that it is only executed when needed?
12:25:01 <dmwit> Ah, I see.
12:25:02 <dmwit> Okay.
12:25:16 <monoidal> dmwit: now, reverse the arrows: to get from A to A*I there are two ways
12:25:22 <dmwit> Yep, got it.
12:25:43 <dmwit> Okay, now not only can I say that Comonoid is useless in Haskell, I can also say I understand why (for a few hours at least).
12:25:55 <monoidal> So while this makes comonoids useless, we can think about cosemigroups!!!
12:26:04 <dmwit> exFalso1: unsafeInterleaveIO, I guess
12:26:32 <dmwit> exFalso1: ...but you might also want to look into pipes/conduits/iteratees/whatever, which are all the rage these days.
12:26:43 <exFalso1> dmwit: uh ok, i'd rather clutter my code then
12:26:51 <exFalso1> no it would've been just for convenience
12:27:11 <monoidal> A cosemigroup is a pair of functions f,g such that f . g = g . f, f . f = f, g . g = g
12:27:39 <dmwit> monoidal: Perhaps my FreeComonoid above is really a FreeCosemigroup, then.
12:27:47 <dmwit> Since I wrote it before I knew what the identity law was. =)
12:31:24 <acube> What is the GHC option for dumping the derivied instances?
12:31:29 <monoidal> -ddump-deriv
12:31:55 <acube> Oh, I tried -fdump-deriv :P
12:35:50 <monoidal> dmwit: or, in other words, FreeCosemigroup m = (m, Bool, Bool) where wappend1 = second (const True), wappend2 = third (const True)
12:36:19 <acube> What does GHC want to say me when it says "Use deriving( Typeable ) on a data type declaration" ? Is deriving Typable1 useless?
12:36:30 <dmwit> monoidal: Ah, even better.
12:37:16 <monoidal> acube: I don't know if GHC can derive Typeable1 via normal deriving. In HEAD, TypeableN are gone (we have kind-polymorphic Typeable)
12:38:32 * dmwit nailed it
12:38:54 <monoidal> acube: deriving (Typeable) should derive Typeable1
12:42:32 <monochrom> beaky: System.Random is not so slow. randomRIO is. I think it's because randomRIO is a lot of readIORef and writeIORef. I have switched to randomRs and it's 200 times faster. see the paste that will come up next, or just reload your hpaste in a moment
12:44:28 <dmwit> monoidal: (The background here, I think, is that acube wants Typeable for data Fix f = Fix (f (Fix f)).)
12:44:32 <monochrom> eh? no announcement from the bot?
12:44:41 <Jookia> dcoutts: ping?
12:44:59 <dcoutts_> Jookia: hello?
12:45:35 <Jookia> dcoutts_: i was told you know things about cabal
12:45:48 <dcoutts_> yep
12:45:54 <monochrom> oh, hpaste is muted
12:46:23 <Jookia> dcoutts_: is it possible to add custom commands, like 'cabal lint' which would run hlint?
12:47:00 <dcoutts_> Jookia: not without adding it into the cabal-install src
12:47:32 <Jookia> dcoutts_: ah. is there a build system that can?
12:47:33 <monoidal> dmwit/acube: You might be able to write instance Typeable (Fix f) manually - I'm not sure. You can have instance Typeable ((* -> *) -> *) Fix in head.
12:47:43 <johnw> @tell typoclass The adding of haddock html pages is something I added to cabal-install itself; it should appear in the next release
12:47:43 <lambdabot> Consider it noted.
12:48:26 <dcoutts_> Jookia: the issue is that it needs access to all the info and to the library of functions for handling the build, and that code is in the cabal-install program
12:48:46 <dcoutts_> Jookia: you can add custom code into the Setup.hs
12:48:56 <Jookia> dcoutts_: i was told that's bad practice
12:49:59 <dcoutts_> Jookia: adding custom code into cabal-install in a user-extensible way would face similar issues
12:49:59 <dmwit> If you're talking about our conversation, I said it would confuse users, not that it was bad practice.
12:51:02 <dmwit> Perhaps hlint should be part of your revision control rather than your build system, though.
12:51:06 <dmwit> e.g. it's run on commits or something
12:51:31 <dmwit> I think xmonad-contrib used to do something similar -- darcs record would check that the code built before committing.
12:51:31 <dcoutts_> Jookia: in the specific case of hlint, it'd be perfectly reasonable to submit a patch to cabal-install
12:51:46 <dcoutts_> it's useful functionality that is not package-specific
12:51:49 <dcoutts_> useful to many people
12:52:05 <Jookia> dmwit: eh, that's not the only issue i'm having with cabal: i can't use 'cabal haddock' on a test-suite, or use code coverage on it
12:52:11 <dcoutts_> like the support for haddock & hoogle
12:52:27 <dcoutts_> Jookia: you can use code coverage on test suites
12:52:38 <jacco> Does anybody known a nice way of doing: (a -> Maybe a) -> a -> [a] ?
12:52:51 <dcoutts_> Jookia: --enable-library-coverage
12:53:06 <dcoutts_> along with --enable-tests
12:53:10 <Jookia> dcoutts_: apparently it doesn't count the test suite's code
12:53:44 <supki> jacco: unfoldr
12:53:47 <dcoutts_> Jookia: you're interested in the coverage of the test suite itself, rather than the thing the test suite is testing?
12:53:55 <Jookia> dcoutts_: both
12:54:11 <dcoutts_> Jookia: ok, never seen that kind of requirement
12:54:54 <FreeFull> :t unfoldr
12:54:55 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
12:55:23 <Jookia> dcoutts_: most of these problems can be fixed by making the tests an executable, but then i can't run 'cabal test'. on top of that, i've never been able to get code coverage to work, so i'm considering just moving to another build system that's more flexible
12:55:28 <monoidal> jacco: unfoldr is much better, but alternatively you can iterate (>>= f) + takeWhile isJust
12:56:01 <dcoutts_> Jookia: it's true that cabal's build system isn't very flexible
12:56:32 <FreeFull> I'd think what what'd he want would be     foo f x = case f x of (Just a) -> [a]; Nothing -> []
12:57:14 <Jookia> dcoutts_: mmm. i'm new to haskell, and i know there's probably good reasons for most of this and that i probably should use cabal, i'm just a little annoyed. is it possible/good practice to have wrapper scripts that can invoke cabal?
12:58:42 <monoidal> > (maybeToList .) -- FreeFull
12:58:44 <lambdabot>   *Exception: show: No overloading for function
12:58:51 <monoidal> :t (maybeToList .) -- FreeFull
12:58:52 <lambdabot> (a -> Maybe a1) -> a -> [a1]
12:58:58 <FreeFull> Ah
12:59:23 <FreeFull> I didn't know there was a maybeToList
12:59:26 <FreeFull> I should have known =P
13:00:05 <dcoutts_> Jookia: it's somewhat historical accident: cabal was designed initially for packaging/distribution not as a developers' build system, so it automates all the stuff with ghc & packages etc, but it's not built on an extensible build system library
13:00:24 <dcoutts_> Jookia: and yes people do sometimes make wrapper scripts
13:01:16 <Jookia> dcoutts_: Hmm... How would you suggest doing that? In a cross platform manner? (Windows doesn't like running scripts)
13:01:51 <dcoutts_> Jookia: yes cross-platform is harder, and that is one of the things cabal-install does reasonably well
13:02:10 <dcoutts_> Jookia: Haskell is a decent shell scripting language
13:02:28 <Jookia> dcoutts_: but windows
13:02:33 <dcoutts_> but Haskell
13:02:45 <dcoutts_> is portable
13:02:59 <FreeFull> I don't see the draw of Windows
13:03:10 <Jookia> dcoutts_: windows is the opposite of portability, which is the problem here
13:03:53 <dcoutts_> Jookia: I'm saying you can write your "scripts" in Haskell. That mostly solves portability issues
13:03:53 <Jookia> dcoutts_: you can't shebang scripts, so the only real way to launch things is by including a .bat file or an executable (i'm not putting executables in git), and i suppose the only real way to figure out if runhaskell works in windows
13:04:10 <dcoutts_> Jookia: runghc/runhaskell does work yes
13:04:10 <jacco> monoidal: so the best I can come up with (for the (a -> Maybe a) -> a -> [a]) is generate f e = let f' x = (,) <$> f x <*> f x in  unfoldr f' e
13:04:31 <jacco> although this creates a list that does not contain the initial a
13:04:47 <monoidal> jacco, well, you can do e:unfoldr f' e
13:04:53 <Jookia> dcoutts_: if cabal isn't really designed to be a build system, would it be worth using another system?
13:05:00 <jacco> right
13:05:02 <jacco> ok, thanks
13:05:31 <monoidal> jacco: aren't you missing Just anywhere? unfoldr requires Maybe
13:05:38 <johnw> Jookia: cabal can be told to invoke whatever other system you want to use, but then you are responsible for platform compatibility, if you wish it
13:05:42 <jacco> I'm using the Maybe applicative
13:05:43 <monoidal> jacco: ah, never mind
13:05:46 <dcoutts_> Jookia: there are not many alternatives in practice, that have all the support for building Haskell packages without you having to code all that from scratch
13:05:56 <monochrom> cabal-dev etc are wrapper scripts that call ghc and cabal-install etc
13:06:08 <Jookia> ah. i suppose i'll wrap cabal then
13:06:17 <monochrom> and cabal-install is a script (understatement!) that calls ghc and ghc-pkg
13:06:37 <monoidal> jacco: let diag x = (x,x), f' = liftA2 diag . f in unfoldr f' e
13:07:00 <Jookia> how do i actually measure code coverage though?
13:07:48 <johnw> Jookia: hpc?
13:07:58 <Jookia> johnw: well yes, but there's no tutorials on how to actual use it
13:08:10 <johnw> the Internet contains sufficiently information
13:08:16 <monoidal> jacco: alternative: generate f x = takeWhile isJust $ iterate (>>= f) $ Just x
13:08:31 <dcoutts_> Jookia: the Haskell wiki has some examples
13:08:41 <Jookia> johnw: i'm sure it does
13:08:50 <Jookia> dcoutts_: none of them actually work from my experience though
13:08:57 <jacco> monoidal: right, thanks! I like the arrow solution
13:12:14 <NemesisD> anyone know how i could get the pid off of a ProcessHandle?
13:14:24 <`^_^v> im working on an interpreter where functions are curried and can take 0 or more arguments. is there a way i could write the apply function to leverage haskell's currying (what would the signature be?), or do i have to add a constructor representing 1 curried argument, 2, etc
13:15:43 <monoidal> do you want apply :: Expr -> [Expr] -> Expr?
13:19:51 <hcaulfield57> Why are monads considered a difficult concept? Either I don't get them at all, or they weren't that complicated.
13:20:04 <merijn> hcaulfield57: They're not that complicated
13:20:23 <FreeFull> They definitely are not that complicated
13:20:32 <aluink> ^^
13:20:36 <merijn> hcaulfield57: They're not considered a difficult concept by most haskellers. The problem is people try to understand them before grokking types and typeclasses
13:20:41 <merijn> And then they get confused...
13:20:51 <hcaulfield57> I saw stuff all over the internet about how bad they were and they were much easier then other stuff
13:20:53 <`^_^v> monoidal, how would i apply a (Expr -> Expr) to an Expr then?
13:20:57 <FreeFull> The way to understand monads is to look at what actually happens
13:21:24 <FreeFull> With Haskell's monads, most of what happens will be in >>= and return
13:21:35 <hcaulfield57> Thinking recursively is much more difficult in my opinion, coming from procedural programming
13:21:43 <monoidal> `^_^v: apply f [x]?
13:21:57 <FreeFull> If you understand what >>= and return do for a monad, you understand that monad
13:22:07 <aluink> I think that's partly because procedural programming makes it difficult. IMO
13:22:15 <hcaulfield57> FreeFull: Yea, not that complicated.
13:22:25 <hcaulfield57> aluink: Yea recursion is much easier in Haskell
13:22:50 <monoidal> `^_^v: I am not completely sure about your requirements, datatypes etc. - perhaps you might reformulate the question.
13:23:05 <aluink> I remember a professor in college telling me he taught recursion 2nd semester of Freshman year, cause it was an advanced topic.  I LOLed.
13:23:30 <FreeFull> > do {a <- [4,5,6]; [1+a]}
13:23:32 <lambdabot>   [5,6,7]
13:23:40 <aluink> Wasn't it MIT at one time, maybe still today, that teaches it within the first week.
13:23:56 <hcaulfield57> I'm glad I'm learning Haskell, impression was it would be impossible, but I think people make it out to be harder than it is in the internet
13:24:17 <FreeFull> I saw many lecturers explain recursion by substitution
13:24:46 <chrisdotcode> hey guys, is there a downloadable reference of the stdlib?
13:25:15 <FreeFull> chrisdotcode: You should have it already on your computer in ghc's doc directory
13:25:31 <FreeFull> Are you on Windows, Linux or Mac?
13:25:38 <chrisdotcode> FreeFull: linux
13:25:46 <hcaulfield57> I do wish there were man pages for Haskell, favorite thing about C
13:26:38 <johnw> if only pandoc could extract Haddocks....  then I could use texinfo
13:27:40 <chrisdotcode> FreeFull: would you happen to know where the doc is under linux? :)
13:27:55 <FreeFull> chrisdotcode: /usr/share/doc/ghc/html  I think
13:28:58 <chrisdotcode> FreeFull: no "html" under that dir. just "ANNOUNCE  changelog.Debian.gz  copyright  README"
13:29:28 <FreeFull> Ah, it must be different under Debian/Ubuntu/whatever
13:29:40 <hcaulfield57> May be a distro issue, I have the html directory
13:30:01 <FreeFull> I don't know if you'll have it somewhere then
13:31:44 <byorgey> it's a separate package I think
13:31:48 <dschoepe> chrisdotcode: Did you install ghc-doc too?
13:31:54 <byorgey> try ghc-doc or haskell-doc or something like that
13:31:56 <chrisdotcode> dschoepe: no, I'll do that now
13:32:28 <chrisdotcode> okay, it's ghc-doc
13:32:34 <chrisdotcode> it's installing nwo
13:32:50 <chrisdotcode> although, both haskell-doc and ghc-doc both exist
13:35:27 <`^_^v> monoidal, i guess the root of my problem is that a valid expression can be a primitive, (Expr -> Expr), (Expr -> Expr -> Expr) ad infinitum
13:35:54 <`^_^v> maybe i'm just not thinking about it correctly though
13:36:14 <beaky> @pl \x y z -> x <$> y <*> z
13:36:14 <lambdabot> (. (<*>)) . (.) . (<$>)
13:36:39 <johnw> yeah, that's just lovely!
13:36:47 <johnw> no one will be confused
13:37:01 <johnw> beaky: liftA2 x y z
13:37:03 <johnw> is that what you wanted?
13:37:25 <beaky> yes
13:37:37 <js6i> `^_^v: data Func = Func (Expr -> Fun) | Filled Expr -- ?
13:37:40 <beaky> :t (. (<*>)) . (.) . (<$>)
13:37:41 <lambdabot> Applicative f => (b -> b1) -> f (a -> b) -> f a -> f b1
13:37:46 <beaky> :t liftA2
13:37:47 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
13:38:24 <beaky> liftA2 because i have a binary function I want to operate on two applicatives
13:38:29 <johnw> yes
13:38:29 <beaky> to apply*
13:41:22 <JoeyA> What would you call a "side effect" that does not actually modify anything?  Examples: readIORef, getPOSIXTime
13:41:44 <JoeyA> "Idempotent" is close, but allows an affect at least once (I think).
13:42:11 <sclv> i'd call it a side effect
13:42:31 <sclv> getPOSIXTime is a bad example
13:42:35 <johnw> i think he's suggesting that there is no actual effect
13:42:35 <shachaf> ACIO's terminology might be relevant.
13:42:37 <enthropy> JoeyA: nullipotent?
13:42:47 <sclv> because it has an observable effect
13:42:49 <merijn> JoeyA: Idempotent says that running an action more than once is the same as running it exactly once
13:42:50 <sclv> which is that it takes tiime!
13:42:58 <JoeyA> ACIO?
13:43:02 <sclv> and you can observe it by asking for the time!
13:43:08 <sclv> ACIO isn't related
13:43:09 <merijn> And yeah, getPOSIXtime is not idempotent in that sense
13:43:17 <sclv> i'd call it a commutative effect
13:43:32 <sclv> which is different, but captures what's interesting about only a set of reads
13:43:47 <sclv> anything that's only a set of reads can also be called a "representable" effect
13:43:52 <johnw> JoeyA: readIORef does have a side-effect, because it's not referentially transparent: the IORef could contain something different at another point in time
13:43:54 <JoeyA> Context: I'm using postgresql-simple's withTransactionSerializable, which may repeat the I/O action.
13:43:59 <sclv> because its iso to r -> a :-)
13:44:16 <JoeyA> Thus, a callback given to withTransactionSerializable must be idempotent (that's actually more precise in this case).
13:44:23 <sclv> (i'm assuming the reads are over things that don't change over the course of the action)
13:44:48 <sclv> anyway i think representable effect is a good notion for something conceptually isomorphic to r -> a
13:45:00 <shachaf> «b) affine  -- their effect is not directly observable, and can be discarded.»
13:45:20 <sclv> hrm, actually yeah that's not bad.
13:45:46 <johnw> exponentially effective :)
13:46:11 <sclv> its a pretty rough abuse of the term affine tho :-)
13:46:20 <JoeyA> Actually, my "definition" can be abused
13:46:32 <JoeyA> writeIORef is "idempotent" since it only changes the value once.
13:46:36 <shachaf> "central" is also a pretty odd word to use for "commutative".
13:46:37 <JoeyA> readIORef of course doesn't do anything
13:47:01 <JoeyA> Therefore, readIORef ref >>= writeIORef ref . (+1) is idempotent (but it's not)
13:47:14 <aluink> i'm having trouble with what would seem a simple Template Haskell example.  Someone care to help? http://goo.gl/c0Ip4
13:48:35 <shachaf> Please use the full URL in here rather than mysterious shortened URLs in the future. :-)
13:49:04 <Hafydd> :---)
13:50:15 <aluink> ok, it was pretty long. i was trying to be nice.
13:50:33 <aluink> https://gist.github.com/shangaslammi/1524967#comment-834615
13:50:42 <shachaf> Sure. People are just worried it'll go somewhere other than github.
13:50:46 <shachaf> aluink: Anyway, that file compiles fine and prints «foo = "bar", bar = 5» for me.
13:50:55 <aluink> hmmm
13:51:11 <aluink> it crashes GHC for me
13:51:17 <aluink> i'm on Mac
13:51:18 <shachaf> ExitFailure 11 probably means a segmentation fault, which could mean a lot of things.
13:51:31 <shachaf> Maybe GHC is running out of memory or something?
13:51:36 <aluink> right, i know. which is why I had no idea what i was looking for
13:51:58 <aluink> i tried to watch for that, but top wasn't updating quickly enough. better way to watch memory usage?
13:52:17 <shachaf> I don't know much about OSX.
13:52:36 <shachaf> I would say to try to strace it to see what's going on -- I think OSX has a rough equivalent of that.
13:52:39 <shachaf> dtruss?
13:54:26 <aluink> ok, that gave me more info. let me paste it
13:54:59 <aluink> http://hpaste.org/88505
13:55:21 <aluink> i just pasted the last bit of build on main.hs
13:56:13 <chrisdotcode> when you isntall packages with cabal, do you als oget their doc?
13:56:42 <Adeon> I think documentation is turned off by default
13:56:45 <chrisdotcode> * install, also get
13:56:52 <Adeon> you can turn it on by modifying the config file
13:56:58 <Adeon> documentation: True or something
13:57:15 <Adeon> ~/.cabal/config
13:57:21 <aluink> chrisdotcode: i don't believe you. you can configure that in your ~/.cabal/config with documentation : True
13:57:49 <aluink> yikes...that came out wrong. i meant to say I don't believe so*
13:58:06 <chrisdotcode> aluink: so then after doing that, can I reinstall everything *with* doc?
13:58:43 <aluink> yeah, when you install a package, it'll and install the docs for you
13:59:08 <aluink> oh, you mean one command that will go fetch all docs for installed packages? idk about that. out of my league now
13:59:34 <chrisdotcode> aluink: would I need to use --reinstall?
13:59:39 <chrisdotcode> and target everything?
14:00:16 <aluink> idk about a global target.  i don't know mch about cabal. just knew the answer to your question cause I've turned it on recently
14:02:10 <aluink> chrisdotcode: this looks helpful, http://stackoverflow.com/questions/6563769/haskell-cabal-regenerate-documentation-for-all-installed-packages
14:02:20 <chrisdotcode> aluink: thanks, I'll try that now :D
14:09:37 <ntelford> is there a way to add a docs directory to hoogle without re-compiling it?
14:09:46 <aluink> shachaf: the stacktrace errors out on "invalid address", nothing really more than that
14:13:58 <aluink> shachaf: what version of GHC are you using?
14:14:22 <shachaf> 7.6.2, x86_64-unknown-linux
14:42:57 <FreeFull> What's the craziest thing written in Haskell?
14:44:31 <pooya72> GHC?
14:44:52 <mm_freak> category-extras…
14:46:01 <edwardk> category-extras wasn't that bad. i've learned how to write much crazier stuff since then.
14:46:38 <FreeFull> Hmm, is GHC really that crazy? I thought it was one of the less crazy compilers, other than the optimisations it does
14:46:44 <FreeFull> But optimisations are always crazy
14:51:46 <beaky> is it possible to read a vector from a file, but end up with a pure vector free from IO?
14:52:31 <cmccann> beaky: so you want to do I/O without using IO?
14:52:35 <geekosaur> you have been working with haskell for how long now?
14:52:39 <cmccann> pretty sure that's the opposite of how it works
14:52:51 <beaky> ah
14:53:02 <beaky> I think my thing can be more efficient
14:53:06 <beaky> but for some reason it is slow
14:53:55 <sclv> FreeFull: DoCon ?
14:53:56 <genisage> beaky, read in the vector from the file, write out a new program with that vector hard coded in, then run the new program.
14:54:23 <cmccann> or read the vector with TH I suppose.
14:54:23 <FreeFull> Yeah, compiling it in will work
14:54:40 <beaky> hah right
14:54:56 <beaky> but that is like cheating... alright I will use unsafePerformIO
14:55:04 <cmccann> why
14:55:19 <cmccann> that doesn't make any sense.
14:55:35 <cmccann> how on earth is TH or code generation like cheating but unsafePerformIO is not?
14:55:42 <beaky> hehe just kidding I will just figure out why my thing is slower than what I think
14:55:57 <FreeFull> IO shouldn't automatically make it slower I think
14:56:25 <chrisdotcode> so guys, I'm have some dep-hell issues install hlint
14:56:30 <beaky> http://ideone.com/gqsHkp
14:56:47 <beaky> maybe it is reading from the file more than once, or generating multiple PRNG engines
14:56:58 <beaky> How do I test for that?
14:56:59 <chrisdotcode> I tried hpasting my dep issues, but no luck.
14:57:21 <chrisdotcode> (as in, the hpaste stil lhasn't been posted here)
14:57:39 <k00mi> chrisdotcode: you can post the link directly
14:57:46 <k00mi> chrisdotcode: did you specify #haskell?
14:57:50 <chrisdotcode> indeed
14:58:17 <FreeFull> beaky: That looks like lazy IO to me
14:58:20 <beaky> ah
14:58:36 <chrisdotcode> http://hpaste.org/88509 <- I'm trying to install hlint, but I'm in dep-hell
14:58:41 <byorgey> I think the hpaste bot isn't working
14:58:43 <FreeFull> Maybe if you use a streaming library, you'll be certain about when what is being read in
14:59:17 <byorgey> chrisdotcode: what version of GHC do you have?
14:59:31 <chrisdotcode> byorgey: 7.4.2
15:00:01 <FreeFull> I think the latest stable is 7.6.3
15:00:04 <byorgey> chrisdotcode: can you hpaste the output of  cabal install -v3 hlint ?
15:00:25 <byorgey> FreeFull: yes, but 7.4.2 is what comes with the latest Haskell Platform
15:00:41 <byorgey> (though a new HP is coming out shortly)
15:00:58 <byorgey> chrisdotcode: and also the output of   ghc-pkg list
15:01:05 <FreeFull> I'd wait until the new HP is out then
15:01:07 <chrisdotcode> okay, grabbing that one too
15:02:32 <hiptobecubic> "shortly"
15:02:45 <chrisdotcode> byorgey: okay, here it is: http://hpaste.org/88510
15:02:58 <byorgey> hiptobecubic: I mean it
15:03:09 <hiptobecubic> I hope so :)
15:03:15 <chrisdotcode> it's telling me I have broken packages, but elm, yesod and opengl (which are the ones I care about right now) are working
15:03:21 <chrisdotcode> er, or they seem to be at least...
15:04:58 <byorgey> chrisdotcode: no, it's not telling you that you have broken packages
15:05:18 <byorgey> chrisdotcode: it's telling you that you *would* have broken packages if you proceeded with that installation plan for hlint
15:05:42 <chrisdotcode> byorgey: so is there a workaround/fix? it wouldn't let me install hlint nor aeson, but I want them...
15:06:31 <byorgey> chrisdotcode: for hlint, since it is an executable, I recommend just building it using a sandbox
15:06:32 <dmwit> chrisdotcode: List all the top-level packages you want to install.
15:06:42 <byorgey> cabal install cabal-dev; cabal-dev install hlint
15:07:00 <byorgey> then copy the generated executable from dist/bin/hlint/hlint (I think) to wherever you want it installed.
15:07:23 <dmwit> chrisdotcode: Instead of "cabal install hlint", write "cabal install hlint cabal-dev pandoc Elm Cabal" or whatever.
15:07:36 <chrisdotcode> dmwit: gloss, hlist, aeson, quickcheck, yesod, elm, and maybe a few more
15:07:39 <byorgey> ugh don't do that
15:07:40 <chrisdotcode> dmwit: ah, okay. I'll try that
15:07:57 <chrisdotcode> don't?
15:08:05 <chrisdotcode> I don't think I could install cabal-dev either...
15:08:09 <byorgey> you'll just have to rebuild everything again next time you install something that needs unix-2.6
15:09:12 <hiato> Hey guys, I may be in a tad over my depth here but I just cannot figure out how RVar's work in Data.Random.RVar, their type signatures don't mean much to me and, well, all I want to do is shuffle a list :P
15:09:17 <chrisdotcode> is there any other workaround? because I might end up having to go with that, if I can't find something else...
15:09:23 <dmwit> We need multiple isntallations of a single version with different dependencies. =/
15:09:35 <byorgey> dmwit: indeed.  there has been some work on that.
15:09:41 <byorgey> not sure what the status is though.
15:09:43 <dmwit> The right thing to do is figure out why it's picking unix-2.5 and fix the dependencies of the package that's forcing that.
15:10:02 <dmwit> Try adding --constraint "unix installed" and see what it says.
15:10:24 <byorgey> good idea
15:10:36 <cmccann> reinstall everything every time!
15:10:39 <cmccann> problem solved.
15:10:43 <cmccann> also, don't listen to me.
15:10:46 <dmwit> I mean reinstalling directory and process is...
15:10:49 <chrisdotcode> still got an error...
15:10:51 <dmwit> Well, you're not gonna have a good time.
15:10:52 <chrisdotcode> I'll hpaste it
15:11:09 <byorgey> it looks like hashable might be the culprit
15:11:18 <byorgey> I wonder if reinstalling hashable with unix-2.6 will fix it
15:11:34 <chrisdotcode> http://hpaste.org/88511
15:11:34 <byorgey> err, I mean hashable built with bytestring-0.19
15:11:40 <byorgey> 0.10, agh
15:12:05 <dmwit> chrisdotcode: (That command was expected to fail. You're only running it for the error message.)
15:12:14 <byorgey> uhh, that looks it didn't use the "unix installed" constraint
15:12:18 <byorgey> is that the right syntax?
15:12:30 <chrisdotcode> dmwit: ah, okay xD
15:12:32 <dmwit> Yeah, it doesn't look like it indeed.
15:12:39 <byorgey> well, actually, there are multiple installed versions of unix
15:12:42 <dmwit> Unless he has both a unix-2.5 and a unix-2.6 installed already?
15:12:46 <byorgey> yes, he does
15:12:52 <dmwit> aha
15:12:53 <byorgey> 2.5 in global, 2.6 in user db
15:13:08 <dmwit> Wait, that means he has a directory and a process installed in the user db?
15:13:12 <byorgey> yes
15:13:23 <dmwit> Yeah, reinstalling those, well... you're not gonna have a good time. =P
15:13:28 <byorgey> he actually has much of the HP duplicated in user db
15:13:40 <chrisdotcode> which is not a good thing, I'm assuming?
15:13:50 <byorgey> no, it's fine
15:14:27 <dmwit> Okay, well, if the constraint we really meant was "unix-2.6", perhaps we should have said that instead of "unix installed". =)
15:14:32 <byorgey> for yesod etc. you need newer versions of those packages than what comes in the user DB
15:14:35 <byorgey> indeed =)
15:14:39 <dmwit> --constraint "unix==2.6.0.1"
15:15:09 <byorgey> *than what comes in the HP
15:16:22 <chrisdotcode> dmwit: http://hpaste.org/88512
15:16:27 <chrisdotcode> now the errors seem to be with bytestring
15:16:52 <dmwit> oh lol
15:17:09 <dmwit> unix-2.6.0.1 (reinstall) <- this is what we were trying to avoid with the "unix installed" constraint
15:17:28 <dmwit> I wonder if you can use both constraints...?
15:17:45 <dmwit> --constraint "quit breaking my stuff pls"
15:17:54 <chrisdotcode> heh.
15:18:20 <chrisdotcode> so I really just want hlint so I can learn from my own mistakes and whatnot
15:18:45 <chrisdotcode> (and aeson to work with JSON)
15:19:34 <byorgey> chrisdotcode: try  'cabal install hashable --constraints "unix==2.6.0.1, bytestring==0.10.0.2" --dry-run'
15:19:53 <josephle> oh man, aeson + Data Parallel haskell is fun
15:19:57 <byorgey> My theory is that hashable is the real bottleneck here but the cabal solver just happens to be picking other things
15:19:59 <josephle> parse ALL the large JSON files!
15:20:40 <zRecursi`> byorgey: what --dry-run means ?
15:20:58 <byorgey> zRecursi`: it means, don't actually do anything, just output the plan of what it *would* do
15:21:12 <byorgey> I've got to run, good luck!
15:21:13 <zRecursi`> pretend ?
15:21:23 <dmwit> yes
15:21:44 <zRecursi`> thx
15:21:55 * wallbrik Image Share -> http://picshare.web.vu
15:22:30 <chrisdotcode> dmwit: so byorgey gave me a command, but there's no "contraints"
15:22:37 <chrisdotcode> should I --constraint twice?
15:22:50 <dmwit> I think so, yes.
15:23:22 <geekosaur> not sure you actually need separate --constraint parameters though
15:24:55 <chrisdotcode> dmwit: okay, this is what happened: http://hpaste.org/88513
15:27:49 <dmwit> okaaaay, suppose you do the same as that but install both hashable and conduit? Keep adding things from the "likely to be broken" list until it's empty or cabal says the constraints are unsatisfiable.
15:28:32 <chrisdotcode> dmwit: okay, thanks. I'll work on that
15:28:49 <Jookia> Hello! How do I use code coverage in cabal?
15:30:45 <chrisdotcode> dmwit: yesh. adding everything to that list just gave me another list. is there a way to reinstall *everything*, such that everything isn't broken?
15:32:20 <dmwit> I don't really know. There's "cabal install world" but that has drawbacks that I don't fully understand, so I can't say whether that would be something worth trying here or not.
15:32:24 <conal> Anyone here worked with the GhcPlugins interface? I'm wondering how people learned the rather large API. I'm struggling with basics, like how to introduce uses of names that will be imported from another module.
15:32:56 <chrisdotcode> dmwit: I'll try a dry run of that...
15:33:49 <ChongLi> conal: wow, you aren't kidding
15:35:20 <chrisdotcode> dmwit: I get, "cabal install world --dry-run
15:35:21 <chrisdotcode> Warning: The following 'world' packages will be ignored because they refer to
15:35:21 <chrisdotcode> packages that cannot be found: quickcheck, elm, opengl
15:35:21 <chrisdotcode> You can suppress this warning by correcting the world file.
15:35:21 <chrisdotcode> "
15:35:30 <chrisdotcode> and no errors with that
15:36:03 <chrisdotcode> hi cmccann
15:37:21 <sclv> I think you basically just need an open chat line with max b :-)
15:37:23 <luite> conal: do you mean generating the names, or adding them to the module? the module is some list of decls i think (i don't really know what data structures you get with a plugin though)
15:37:24 <sclv> w/r/t plugins
15:37:36 <cmccann> chrisdotcode: yo
15:37:40 <dmwit> ...presumably you would want "cabal install world hlint", not just "cabal install world".
15:37:44 <luite> conal: and i find a local hoogle installation with ghc indexed very useful :)
15:39:22 <luite> i could remove so many imports by replacing them with GhcPlugins :p
15:39:30 <conal> luite: i have a library module X that defines & exports several names. i want my plugin to transform another module Y in such a way that Y now imports X and uses the names exported from X.
15:39:33 <mm_freak> chrisdotcode: notice that the packages are named QuickCheck and OpenGL
15:39:38 <mm_freak> not quickcheck and opengl
15:39:48 <mm_freak> (exercise:  find the difference)
15:40:16 <dmwit> (...and Elm)
15:40:33 <chrisdotcode> mm_freak:  isn't that a type error? ;-)
15:40:35 <chrisdotcode> > "quickcheck" - "QuickCheck"
15:40:37 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
15:40:37 <lambdabot>    arising from a use of `GH...
15:40:50 <dmwit> > "quickcheck" \\ "QuickCheck"
15:40:51 <lambdabot>   "qc"
15:41:02 <chrisdotcode> :t (\\)
15:41:04 <lambdabot> Eq a => [a] -> [a] -> [a]
15:41:10 <chrisdotcode> array difference?
15:41:21 <Hafydd> "array"
15:41:22 <dmwit> list, but yes
15:41:34 <mm_freak> chrisdotcode: "difference" can be in relation to other orders than numeric value =)
15:41:41 <mm_freak> > compare "quickcheck" "QuickCheck"
15:41:42 <lambdabot>   GT
15:41:48 <chrisdotcode> huh. I learn more about haskell every day
15:41:56 <luite> conal: but X already exists, unchanged? sounds like something for mkExternalName
15:41:57 <dmwit> "difference" doesn't really imply ordering to me at all.
15:42:21 <mm_freak> "difference" as in "to be different"
15:42:32 <conal> luite: yes, X already exists.
15:42:38 <mm_freak> (given a total order)
15:42:38 <dmwit> ...still no implication of ordering. =)
15:42:46 <chrisdotcode> okay, it's only two packages. I'm just going to build them from source. I should be able to do that, correct?
15:42:55 <conal> luite: how do you get the Unique that mkExternalName wants?
15:43:23 <mm_freak> dmwit: well, a total order gives rise to an equivalence relation, and with respect to that non-equalivalent values would be, well, "different" =)
15:43:25 <dmwit> chrisdotcode: What exactly do you think cabal is building them from if not source?
15:43:35 <mm_freak> to give a somewhat precise definition =)
15:43:47 <chrisdotcode> dmwit: er, you're right.
15:43:49 <dmwit> But you certainly don't need a total order to get an equivalence relation, is what I'm saying.
15:43:53 <mm_freak> "equalivalent"…  wow
15:43:58 <luite> conal: does the plugin rewrite core to core?
15:44:01 <mm_freak> s/equalivalent/equivalent/
15:44:05 <conal> luite: yes
15:44:47 <mm_freak> dmwit: sure, but when you have a total order, you get an equivalence relation for free…  and as a haskeller you certainly like free stuff =P
15:45:00 <luite> conal: ah ok, names have been resolved then, i think they should be available already then in the namecache
15:45:02 <dmwit> As a human, I am irrationally attracted to free stuff.
15:45:31 <conal> luite: ah, sounding good. what's the namecache?
15:45:37 <chrisdotcode> so at this point, I'd just rather recompile everything from source if I can get both hlint and aeson. I don't mind the 20 minute wait. how would I go about doing that?
15:46:23 <luite> conal: it contains the names loaded by reading the .hi files of dependencies. it's stored in the HscEnv global environment
15:46:31 <chrisdotcode> `cabal install world hlist aeson --force-reinstalls'?
15:46:42 <dmwit> Something like that.
15:46:59 <dmwit> I have to run now, too.
15:47:10 <Jookia> Is it really possible to use HPC with 'cabal test'?
15:47:20 <chrisdotcode> dmwit: well thanks for all the help :)
15:47:35 <beaky> what is the inverse of lines?
15:47:36 <beaky> :t lines
15:47:37 <lambdabot> String -> [String]
15:47:39 <beaky> :t words
15:47:41 <lambdabot> String -> [String]
15:47:50 <conal> luite: Ah. i see. I forgot about looking there. thanks. i'll poke around and see what i can figure out from here.
15:47:50 <k00mi> unlines
15:48:06 <luite> conal: i'm not terribly familiar with this part of GHC though :) IfaceEnv seems to have some interesting functions as well
15:48:38 <Jookia> Do I have to make a library instead of an executable? HPC is looking in the wrong directory
15:48:45 <conal> luite: super. i hadn't found IfaceEnv. looks very helpful.
15:50:37 <hpc> Jookia: it's not my fault! :P
15:51:19 <Jookia> hpc: No, it's Cabal's fault. :(
15:59:37 <_{^_^}__> whats the point of making aliases for common classes? e.g. FilePath is just type FilePath = String
15:59:53 <_{^_^}__> s/classes/types/
16:00:18 <enthropy> doesn't it help you understand what the String is for?
16:00:18 <napping> to at least try to indicate what the argument is used for
16:00:32 <napping> writeFile :: String -> String -> IO () would be confusing
16:04:15 <slack1256> also, when you don't have control of the under representation (network sockets as handles, file handles) is kind of nice having them aparently different on the type system
16:04:47 <steven_is_false> Hi! How can I write a secure password comparison function that isn't vulnerable to timing attacks. I don't believe seq is the only thing that is needed because I think that can still leak the length of the password.
16:05:05 <_{^_^}__> ah good answers, thanks
16:06:57 <napping> steven_is_false: are you thinking of a string compare against the raw password?
16:07:14 <steven_is_false> napping: Yes, an is_password_correct function.
16:08:25 <napping> Why?
16:08:51 <steven_is_false> napping: I was just curious to find out what the right way to write a secure comparison function would be.
16:09:37 <napping> if you actually want to do passwords right, you'll only store hashes of the correct passwords, which are all the same length
16:09:53 <steven_is_false> napping: That is actually a good point.
16:09:58 <k00mi> salted, please
16:10:00 <napping> so then you just need to avoid returning early in the string compare
16:10:34 <beaky> why is the worker wrapper pattern useful
16:10:40 <glguy_> if you're comparing hashes it's not a big deal to return early on the compare
16:10:57 <steven_is_false> napping: The hash would only need to be a small type like Int right? Not a big number like Integer right?
16:11:08 <napping> see e.g. scrypt on hackage
16:11:26 <slack1256> hashed should have its own datatype, at least in some package.
16:11:45 <steven_is_false> slack1256: Yes that would make things easier.
16:11:59 <slack1256> cryptography is one of those things where we should use battle-tested packages instead of build our own.
16:12:10 <slack1256> the screw up is just too big.
16:12:16 <napping> 64 bit hashers are too small so it will be ByteString
16:12:57 <steven_is_false> Shouldn't one use some kind of unboxed reference type to a Hashed value, and not Hashed? So one can overwrite the old value in memory when done with it?
16:14:16 <slack1256> steven_is_false: maintaining the old value in memory shouldn't be a concern?. or there is a security reason why you don't want to keep it?
16:14:22 <slack1256> I can't think of one.
16:14:45 <slack1256> (also crypto stuff of any kind doesn't go with me)
16:15:46 <napping> steven_is_false: don't you have the expected hash stored in a database or something anyway?
16:15:57 <steven_is_false> slack1256: I recall an explanation that some Java libraries used char[] instead of String so that could be done. I don't know if that's a real concern or not though.
16:16:47 <napping> I don't see how a computer could end up with a hash in memory and not on disk in a way that having the value in memory is a bigger worry than whatever mechanism let it receive the hash in the first place
16:17:07 <steven_is_false> napping: Can't it retrieve from a server, or a dongle?
16:17:38 <napping> and then anyone who sufficiently compromises the machine to read the RAM can presumably request whatever hashes they like from the same source
16:17:38 * slack1256 heh, sorry that last word has grown in me.
16:18:04 <steven_is_false> napping: Fair enough.
16:18:39 <slack1256> that is a non solved problem. reading directly from the ram that is.
16:19:28 <slack1256> once I saw a guy recovering a password from a recently shutdown computing, because the bits in the ram keep flop for sometime after shutdown
16:19:46 <steven_is_false> slack1256: yep
16:19:49 <napping> yeah, but the thing to worry about there is the raw password
16:20:18 <shanse> there are all sorts of attack vectors if you have physical access to the machine
16:20:21 <napping> I'm not sure how you can know you have the only copy
16:20:30 <slack1256> true. I oversaw that.
16:20:51 <steven_is_false> So there are no other timing attacks on the hashed password comparison other the early return? No GC thingies, or cache effects?
16:21:08 <napping> more like it doesn't matter
16:22:08 <k00mi> steven_is_false: early return when comparing hashes doesn't matter
16:22:16 <napping> or rather, if you use a proper library it's probably taken care of
16:23:35 <steven_is_false> napping: Oh sure but someone has to make these proper libraries.
16:23:42 <slack1256> use a library as napping say, is the safest bet here.
16:24:44 <slack1256> yeah, but crypto is college-level stuff. with years of preparation or study.
16:24:47 <napping> It's easy enough to compare two fixed-size strings with a fixed instruction sequence
16:25:19 <slack1256> probably you do those before implementing correctly crypto.
16:25:31 <napping> being sure your CPU doesn't have data-dependent execution times on those instructions is less trivial
16:26:26 <steven_is_false> napping: I wonder, I know there are facilities for random number generation in a lot of CPUs. Is there some kind of support for other crypto stuff?
16:26:51 <napping> http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html
16:27:00 <steven_is_false> napping: If the CPU knows what I intend to do then it'd be a lot safer.
16:27:14 <k00mi> steven_is_false: some modern CPUs have built-in AES
16:27:25 <steven_is_false> k00mi: cool.
16:28:48 <steven_is_false> napping: I really struggle with reading Intel's manuals even though they're supposed to be pretty good for hardware manuals. What would you suggest I read first?
16:30:42 <napping> There's nothing in CPUs that makes implementing your own crypto a good idea
16:32:01 <napping> If you're just messing around, I only recall AES-NI and some newer random number generation instruction
16:32:38 <steven_is_false> napping: Fair enough.
16:33:16 <napping> might be interesting to try to benchmark whether using SSE to compare strings has data-dependent execution time
16:33:42 <steven_is_false> napping: That would be an interesting exercise.
16:33:56 <napping> anyway, there's little point to writing things where you care about timing attacks in Haskell
16:34:38 <steven_is_false> I wonder can this sort of thing be formalized in theorem provers like Coq, or Agda?
16:36:38 <steven_is_false> Anyways thank you for the information.
16:46:21 <monochrom> @tell beaky reload your paste http://hpaste.org/88491 for my suggestion, it's about 200 times faster. I think it's just randomRIO being slow, not all of System.Random
16:46:21 <lambdabot> Consider it noted.
16:46:25 <beaky> ah thanks
16:46:25 <lambdabot> beaky: You have 1 new message. '/msg lambdabot @messages' to read it.
16:46:53 <monochrom> randomRIO has a pair of readIORef and writeIORef. they can be slow.
16:58:55 <slack1256> @quote life
16:58:56 <lambdabot> ddarius says: When a programmer has a problem and says "I'll use regular expressions," they have two problems.  When the programmer says "I'll use Haskell," they have a lifetime of problems.
16:59:43 <mysticc> Is it necessary to use explicit forall to be able to use ScopedTypeVariables extension ?
16:59:50 <Hafydd> I don't understand the regular expressions version. What is wrong with regular expressions?
17:01:13 <geekosaur> difficult for most people to understand
17:01:44 * geekosaur has no trouble with it... but he's been using them since 1982. with enough experience, anything can become easy
17:01:50 <monochrom> yes mysticc
17:02:07 <geekosaur> mysticc, yes; forall indicates which types are to scope over the definitions
17:02:10 <Hafydd> Then the problem being solved is also probably "difficult to understand".
17:02:27 <mysticc> monochrom: Why is that restriction?
17:02:31 <peodjtg> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldyucnl nmdbdekwca ge zsmhwykt sbp
17:02:31 <peodjtg> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldortjx
17:02:31 <tlret> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldyucnl nmdbdekwca ge zsmhwykt sbp
17:02:31 <tlret> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldortjx
17:02:33 <peodjtg> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldmyjwfsi dqr ajssn
17:02:33 <peodjtg> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldsm ilij wlofuux egvhc rwpijfub uuvwwkwx jep tadkkp
17:02:33 <tlret> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldmyjwfsi dqr ajssn
17:02:33 <tlret> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldsm ilij wlofuux egvhc rwpijfub uuvwwkwx jep tadkkp
17:02:35 <peodjtg> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldgo yfloioa f avk eeso ojuost pi lgpdd y
17:02:35 <peodjtg> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldiagx jdlquawipe a avudhklba gsihzsjlfy
17:02:35 <tlret> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldgo yfloioa f avk eeso ojuost pi lgpdd y
17:02:35 <tlret> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldiagx jdlquawipe a avudhklba gsihzsjlfy
17:02:37 <peodjtg> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldbi
17:02:37 <peodjtg> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldg b
17:02:37 <tlret> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldbi
17:02:37 <tlret> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldg b
17:02:39 <peodjtg> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldhwsgo vnptzv onwn
17:02:39 <peodjtg> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldikczijwfg vax rabz hw nlzhnbybb
17:02:41 --- mode: ChanServ set +o geekosaur
17:02:44 --- mode: ChanServ set +o shachaf
17:02:51 <peodjtg> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldjpzqdtxphy szdbnrna fwqdf sjmaj ncrgl
17:02:51 <peodjtg> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldoiu ewhacqqidx bb lkjqwjq gjfwgen
17:02:51 <tlret> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldjpzqdtxphy szdbnrna fwqdf sjmaj ncrgl
17:02:51 <tlret> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldoiu ewhacqqidx bb lkjqwjq gjfwgen
17:02:52 --- mode: geekosaur set +b *!*fqhtb@86.96.226.*
17:02:52 --- kick: peodjtg was kicked by geekosaur (peodjtg)
17:02:53 <tlret> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldalcjkbj oejeo tmgftwhd qtwvjwzlix zsamwnndm yves zzq urdzhgepsz ura
17:02:53 <tlret> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldsu p uahydbp ymyi
17:02:55 <tlret> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldionzczinx h mqrsjl ksiensvy i pbgroyplss kzbxckxptp dmkpcsnbk
17:02:55 <tlret> i my name is GamerKitten, I'm 40 years old and I'm mother of two children. I have HIV and I would like to invite you to my channel #wrongplanet. If you don't come I will kill myself. Thank you -- Michelle Enfieldvivjptwmao qrb aigjsodtor ssebscj hfqkeggv wfd gdneipuy bqxij dzvv
17:02:56 --- mode: geekosaur set +b tiret!*@*
17:03:10 --- mode: shachaf set +b *!*@86.96.226.14
17:03:21 <S11001001> geekosaur: tl
17:03:49 <monochrom> Hafydd: there is a famous quote about people choosing regular expressions and turning one problem into two
17:04:43 --- mode: geekosaur set -o geekosaur
17:05:07 <Hafydd> monochrom: yes; I'm concerned about the people who keep repeating the quote.
17:05:11 --- mode: shachaf set -o shachaf
17:05:12 <Hafydd> *more concerend
17:05:19 <Eduard_Munteanu> Someone named tiret might feel left out.
17:05:23 <monochrom> alright, then I have no answer
17:05:39 <geekosaur> there's also a tendency by people to use regex for the wrong thing
17:05:48 <geekosaur> (infamously, parsing HTML)
17:06:14 <Hafydd> Oh, I suppose so - but the right abstraction for that is a strict generalisation of regular expressions.
17:06:36 <geekosaur> not really, no; HTML in the wild fails at regularity
17:06:39 <koninkje> regexes are for recognizing languages, not for parsing them
17:06:43 <Eduard_Munteanu> geekosaur: if that wasn't clear, you might want to remove the ban on "tiret", since it's not "tlret"
17:06:48 <geekosaur> the most popular HTML processor is called tagsoup for a reason
17:06:59 <geekosaur> oops
17:07:06 <Hafydd> If you can't understand regular expressions, you can't really understand any representation of a context-free language in general.
17:07:32 --- mode: ChanServ set +o geekosaur
17:07:37 --- mode: geekosaur set -b tiret!*@*
17:07:47 --- mode: geekosaur set -o geekosaur
17:10:58 <monochrom> and if you understand regular expressions, everything looks like a regular expression :)
17:12:03 <mysticc> @pl (\i -> f . g i)
17:12:03 <lambdabot> (f .) . g
17:12:06 <Hafydd> "If all you have is a deterministic finite automaton", everything looks like a regular language."
17:12:11 <Hafydd> -"
17:12:31 <monochrom> if all you have is a CCC, everything looks like both an object and a morphism
17:12:55 <dolio> Yup.
17:13:17 <shachaf> Some objects look like just objects.
17:13:37 <Hafydd> If all you have is smalltalk, everything looks like an object.
17:13:44 <dolio> Yeah, it's more everything looks like objects.
17:13:47 <dolio> Not vice versa.
17:14:08 <dolio> You need an M-category (or something like that) for all objects to look like morphisms.
17:14:22 <Eduard_Munteanu> Right, it would be strange to have objects look like everything. :P
17:14:59 <shachaf> If all you have is one joke, everything looks like that joke.
17:15:04 <Hafydd> If all you have is a language with null references, null is an object which looks like everything.
17:15:08 <Hafydd> Hahah.
17:15:31 <monochrom> of course null is the initial object.
17:15:39 <Eduard_Munteanu> That would be a really depressing joke... a terminal one. :P
17:17:38 <dolio> Maybe it's not M-category...
17:18:19 <shachaf> better ask mLab
17:18:27 <dolio> I'm trying.
17:18:35 <dolio> Their server is slow.
17:18:43 <shachaf> Hmm, so is nLab's.
17:18:50 <Eduard_Munteanu> (m,n)Lab might help you differentiate the two.
17:19:10 <monochrom> what is the gcd of mLab and nLab?
17:19:28 <Eduard_Munteanu> (m,n) of course, hm...
17:29:03 <wavewave> is edwardk around??
17:29:16 <Eduard_Munteanu> wavewave: looks like he isn't
17:29:18 <shachaf> He is not.
17:29:24 <wavewave> hi.
17:30:24 <slack1256> @seen edwardk
17:30:25 <lambdabot> Unknown command, try @list
17:30:48 <slack1256> lambdabot please don't make me look dumb
17:37:40 <wavewave> @list
17:37:40 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
17:39:25 <zRecursive> #haskell spammed ?
17:39:42 <wavewave> zRecursive: what does it mean?
17:40:57 <zRecursive> wavewave: My ERC received many messy messages
17:41:15 <zRecursive> @quote tlret
17:41:16 <lambdabot> No quotes match.
17:41:26 <zRecursive> ok now
17:41:51 * hackagebot wai-routes 0.3.0 - Typesafe URLs for Wai applications.  http://hackage.haskell.org/package/wai-routes-0.3.0 (AnupamJain)
17:47:39 <acube> Is it possible to get a splice error: <some error> while splicing <some code> that disappears when one copy-pastes the code given in <some code> directly to the target location?
17:47:50 <acube> (TH)
17:49:53 <acube> http://hpaste.org/88516 that's the error I get
17:50:32 <acube> when I copy the code that "failed", the compile passes (after removing the GHC.Err before the undefined and the Data.Typeable.Internal because those modules are not imported)
17:54:55 <byorgey> acube: yes, that's possible
17:55:04 <byorgey> the internal splicing mechanism seems wonky sometimes
17:55:33 <byorgey> it seems like it doesn't use the same code paths as code which is literally pasted in
17:55:54 <byorgey> I've recently gotten some errors where the splicing code hasn't been updated to reflect changes in the syntax that GHC accepts
17:56:16 <acube> byorgey: I found the error. I used conT instead of varT for a type variable in one place
17:56:32 <byorgey> aha
17:56:38 <byorgey> that would do it
17:56:47 <acube> The resulting code looked correct, but wasn't
17:56:50 <acube> :P
17:56:51 <byorgey> hehe
18:11:46 <pchiusano_> the Crypto.Hash functions take an Int as the first argument, what does that mean? http://hackage.haskell.org/packages/archive/cryptohash/0.9.0/doc/html/src/Crypto-Hash-SHA3.html#hash
18:12:03 <pchiusano_> source says it is hash length, but then what are the valid values for that?
18:14:06 <shachaf> For Keccak/SHA3? I think it can be any multiple of 8.
18:15:13 <pchiusano_> shachaf: is that documented anywhere?
18:15:45 <pchiusano_> like, is that hash length a property of the hash function
18:16:26 <shachaf> Well, I don't know much about it. There is https://en.wikipedia.org/wiki/SHA-3 -- it seems that it's not properly standardized yet.
18:17:09 <pchiusano_> shachaf: yea, was reading that
18:17:34 <pchiusano_> but like, for the SHA hash functions in Crypto.Hash, I could do 256, 384, or 512
18:17:42 <pchiusano_> but not, like 217
18:17:48 <copumpkin> it's in bits, I think
18:18:27 <shachaf> For which SHA functions?
18:19:10 <shachaf> SHA-1 is defined to give you 160 bits. SHA-2 gives you 224/256/384/512.
18:19:45 <pchiusano_> shachaf: ahh. ok, I was confused - it looks like sha3 is the only one that takes that int param
18:19:45 <shachaf> Keccak can give you any multiple of 8. Maybe when SHA-3 is standardized there'll be some standard digest sizes.
18:20:25 <pchiusano_> shachaf: ok that clears things up
18:20:26 <shachaf> Right. SHA3 works differently from SHA1 and SHA2.
18:21:25 <shachaf> (SHA-1 and SHA-2 are Merkle-Damgård, for one.)
18:26:48 <ToTheInternet> So I installed haskell-platform on debian. Starting ghci works as root, but when i start it as a normal user it gives a "Bus error"
18:27:39 <Clint> that's disturbing
18:27:50 <ToTheInternet> Clint: why is that
18:28:19 <Clint> ToTheInternet: what version of debian, what architecture, how'd you install haskell-platform?
18:30:28 <ToTheInternet> Clint: Debian 6.0.7 running in a VirtualBox VM, i installed it with apt-get
18:30:49 <LAMMJohnson> Clint: Eastwood
18:31:05 <LAMMJohnson> Wait, I'm in the wrong channel. Excuse me.
18:31:14 <ToTheInternet> ok, i just saw that i have 0 MB of space left on /
18:31:30 <ToTheInternet> maybe that has someting to do with it
18:31:50 <Clint> ToTheInternet: you also might want to upgrade to 7.. 6 is pretty old
18:32:09 <dmwit> It can't be that old if it has the Haskell Platform.
18:32:20 <ToTheInternet> Clint: yeah, i usually don't use this VM, it's just for testing purposes
18:32:41 <Clint> dmwit: it's 2010.1.0.0.1
18:33:01 <dmwit> Anyway, if you have no space left on /, I would worry that you have a partial installation or something.
18:33:23 <dmwit> I doubt it's Debian's fault, except in the roundabout sense that it probably should have warned you that you didn't have enough space to install the platform.
18:34:50 <ToTheInternet> dmwit: thats what i am so surprised about. usually apt-get will return an error if this happens
18:34:53 <gaze__> how could I provide global variables in a haskell eDSL?
18:35:02 <gaze__> or provide some syntax that acts like a global variable
18:35:18 <Clint> ToTheInternet: if it didn't, it installed
18:35:38 <dmwit> gaze__: Stick a StateT in your transformer stack somewhere.
18:36:07 <gaze__> alright. How about if I want the eDSL itself to define global variables?
18:36:31 <ToTheInternet> Clint: well it did install, after all root can start it, only a user can't. i'll try and free some space and see what happens
18:36:32 <ChongLi> or use StateVar
18:36:41 <gaze__> and I want something a little syntactically nicer and type safe than looking up variables in a hashtable?
18:36:47 <ChongLi> http://hackage.haskell.org/package/StateVar-1.0.0.0
18:37:07 <Clint> ToTheInternet: root gets reserved space on the filesystem
18:37:13 <dmwit> gaze__: That's trickier.
18:37:42 <gaze__> dmwit: yeah! I can think of a few ways to do it. I don't mind template haskell, really.
18:37:45 <dmwit> gaze__: You can use Dynamic and Typeable to get something vaguely okay. Use a Map String Dynamic or similar.
18:38:11 <gaze__> dmwit: Without a map/hashtable/etc.
18:38:12 <ToTheInternet> Clint: yeah now it works, sorry for the commotion
18:38:16 <gaze__> something that statically type checks :D
18:38:44 <dmwit> You want to statically type check something that picks a type dynamically?
18:39:27 <dmwit> Use Agda, I guess.
18:39:38 <dmwit> Have fun with those proofs.
18:39:47 <gaze__> hahaha
18:40:05 <gaze__> dmwit: What I want is something like http://stackoverflow.com/questions/16708700/bind-monadic-variables-over-several-functions but without the weird syntax.
18:40:38 <gaze__> I wanna be able to bind Concurrent.Chans over a bunch of eDSL functions
18:42:01 <gaze__> the stuff after the "Here's the syntax I settled on" is the best I could come up with
18:42:04 <dmwit> gaze__: Your approach is flawed. Think harder.
18:43:15 <gaze__> can I get a clue as to what's wrong?
18:43:39 <dmwit> Globals don't exist.
18:44:14 <gaze__> ohh... you're saying I need to change the way I'm trying to solve the problem
18:44:23 <dmwit> Yes.
18:45:15 <gaze__> yeah alright. I think though... that it's reasonable to have some static symbol that I can refer to within an eDSL that are defined perhaps at compile time, which allow me to refer to places where I can route messages
18:45:35 <gaze__> I mean, it's not a variable
18:46:16 <gaze__> I shouldn't have said variable
18:48:45 <dmwit> You have said what you want, but not why you want it. The former is not possible, and the latter makes it impossible to suggest an alternative.
18:51:58 <Sgeo_> Gloss or FreeGame? (or other?)
18:52:11 <shachaf> dmwit: I want a hug.
18:52:38 <gaze__> Okay. I have a series of forkIO'd servers which process messages. However, the messages are either generated by sources, or I want there to be an eDSL which can unpack the message from one server and repack it with a continuation for another server. The continuation determines which function in the eDSL gets the message from the finishing server
18:53:26 <gaze__> does that make sense?
18:55:14 <gaze__> that was kinda word soup, hahaha
18:57:05 <gaze__> Say you have servers A, B, C. Server A accepts messages of type AIn and outputs messages of type AOut. Functions in the eDSL take messages of type AOut, BOut, or COut and output messages of type AIn, BIn, CIn paired with the next function in the eDSL to run on the finished server's message
18:57:50 <gaze__> the problem I'm trying to solve is really of just how to refer to the server itself.
19:03:18 <dmwit> gaze__: Okay, so you want to implement some kind of typed pi calculus?
19:03:29 * dmwit hugs shachaf
19:04:07 <dmwit> *delivery may be delayed 2-4 business years
19:04:54 <dmwit> Forget the pi calculus comment.
19:05:07 <dmwit> So, I'll propose a strawman and you tell me why it sucks.
19:05:15 <shachaf> dmwit: How many years is that in human years?
19:05:33 <copumpkin> Mu MVar?
19:05:35 <gaze__> yeah I don't think that's quite what I want
19:06:00 <Sgeo_> Mu?
19:06:09 <Sgeo_> :t lens
19:06:11 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
19:06:20 <copumpkin> Mu f = f (Mu f)
19:06:28 <dmwit> shachaf: That depends. Which is the next hackathon we'll be co-attending? =)
19:06:42 <Sgeo_> :t traverse
19:06:43 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
19:06:44 <shachaf> dmwit: Precedent suggests Boston, but who knows.
19:06:53 <Sgeo_> :t (&)
19:06:55 <lambdabot> a -> (a -> b) -> b
19:06:57 <copumpkin> precedent obama?
19:07:04 <Sgeo_> Is & from lens or from elsewhere?
19:07:17 <edwardk> lens
19:07:46 <dmwit> gaze__: So what's wrong with server A holding onto an MVar AIn and MVar AOut and the EDSL being of type Either AOut (Either BOut COut) -> (Either AIn (Either BIn CIn), EDSL term) ?
19:07:58 <Sgeo_> edwardk, is there any particular reason you chose Gloss over other libraries for the Pong example?
19:08:00 <shachaf> dmwit: If you arrange for me to be at hacphi, then it could be soon!
19:08:18 <shachaf> Sgeo_: edwardk didn't write the Pongxample.
19:08:28 <hcaulfield57> If you have something like class Foo a where a b -> ... you can assume that a must be a type constructor?
19:08:59 <dmwit> Yes, and furthermore GHC will assume it has type * -> * unless it infers a more exciting kind for b.
19:09:02 <Sgeo_> shachaf,:,:,: I may switch to Quassel at some point
19:09:05 <shachaf> That depends on what you mean by "type constructor".
19:09:09 <dmwit> uh, s/type/kind/
19:09:18 <shachaf> If (Either a) is a type constructor, then sure.
19:09:30 <hcaulfield57> shacaf: Yea or Maybe a
19:09:35 <hcaulfield57> That's what I meant.
19:09:40 <shachaf> ?
19:09:47 <dmwit> Maybe a is not a type constructor in the same sense Either a is.
19:10:15 <dmwit> I think you should say what you mean by type constructor.
19:10:18 <Sgeo_> shachaf :: who wrote the Pong example?
19:10:24 <dmwit> Do you mean something with an arrow in the kind?
19:10:28 <dmwit> Or something else?
19:10:37 <hcaulfield57> dmwit: I mean like Maybe a = Just a | Nothing
19:10:41 <hcaulfield57> Maybe a
19:11:06 <dmwit> No, you cannot assume that "a" in "class Foo a where a b -> ..." is "Maybe a".
19:11:07 <hcaulfield57> Yea * -> *
19:11:22 <hcaulfield57> Can you assume it's * -> *
19:11:32 <shachaf> No.
19:11:42 <gaze__> dmwit: That seems fine... actually
19:11:49 <gaze__> but let's say there are a LOT of servers.
19:13:03 <gaze__> I guess at that point you'd have a data ServersIn = A AIn | B BIn ..., data ServersOut = A AOut, yada yada blah blah blah
19:13:11 <gaze__> but then
19:13:28 <gaze__> how do you quickly match that message type up with the Chan?
19:13:43 <dmwit> What does "quickly" mean?
19:14:02 <dmwit> Case statements with more than 9 branches compile to jump tables in GHC.
19:15:20 <gaze__> so what you're saying is that a function that's literally a <- newChan; b <- newChan... bazillion of these... some routing logic, then a huge case statement switching over all of these
19:15:38 <gaze__> is a reasonable way to solve this
19:15:47 <gaze__> I'll totally accept that
19:15:51 <gaze__> just wanted to make sure
19:15:57 <shachaf> I think that's what *you* are saying.
19:16:01 <dmwit> Reasonable in some sense.
19:16:49 <dmwit> If you absolutely can't have a Data.Map somewhere (which seems to be one of your requirements for some reason...?), then, yep, this is kind of reasonable.
19:18:46 <gaze__> okay that was kinda arbitrary. I just didn't wanna map from strings onto some data type, blah blah
19:19:21 <gaze__> say data.map is acceptable, everything goes, whatever
19:20:24 <gaze__> but you have these functions of form Either AIn (Either BIn CIn -> (Either AOut (Either BOut COut), EDSLTerm) and you wanna route to the proper chanel
19:20:31 <gaze__> how would you do it?
19:21:39 <gaze__> or even... is that reasonable? Honestly part of the reason I'm asking these questions is I'm trying to learn how someone experienced would solve this problem, what is considered reasonable, etc.
19:22:15 <dmwit> Well, I would point out that we still don't even know what the problem is yet, just what you think a solution might be. =)
19:24:11 <gaze__> haha okay. I've been bombarding this channel with this same problem over and over again... lemme write it up and hpaste it real quick
19:39:13 <lispy> hello
19:39:25 <byorgey> hey lispy
19:45:08 <gaze__> dmwit: http://hpaste.org/88522 here's the dream
19:47:34 <monochrom> you will find some surprises: http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
19:47:40 <hcaulfield57> Whats some good Haskell code to read that's not super long, I'm trying to expand my learning
19:58:02 <carter_> darinmorrison yo
19:58:15 <darinmorrison> carter_: hey
20:01:09 <lispy> byorgey: how's it going?
20:01:23 <carter> darinmorrison to better explain what I was saying earlier: if i pretend i have unlimited SIMD registers, I can model the AVX SIMD  instructions as just being functional operations
20:01:41 <lispy> it seems that when I changed my irssi theme to solarized I broke nick highlighting :(
20:01:51 <carter> hey lispy
20:02:21 <carter> darinmorrison so by model, I really just wanna treat the simd instructions as operations on low dimensional vectors
20:02:26 <darinmorrison> carter: okay, but that still involves an (idealized) ISA model, right?
20:02:31 <carter> darinmorrison not really
20:02:45 <carter> because llvm does the actual register allocation
20:03:00 <lispy> format strings are hard (aparently)
20:03:17 <carter> as long as I  (roughly) have no more live variables than there are registers, llvm seems to do ok
20:03:29 <carter> that holds with C code!
20:03:44 <carter> which has a lot less precise info that I hope to be able to pass in...
20:03:50 <carter> *than I
20:03:56 <darinmorrison> Guess I don't get it. Why aren't your low dimensional vectors serving as your idealized model?
20:04:02 <carter> yes
20:04:16 <lispy> that wasn't a yes/no question :)
20:04:32 <carter> I thought you asked if i was doing that
20:04:35 <carter> or planning to do that
20:04:40 <carter> yes I am taking that stance
20:04:49 <carter> of what i'll be doing
20:04:54 <lispy> ah, you're saying "they are"
20:05:07 <carter> its also friday evening and i've had a long week
20:05:32 <lispy> likewise, actually
20:05:44 <carter> didn't have AC setup till wednesday was the reall killer
20:05:58 <lispy> it's been cold/rainy here
20:06:19 <carter> its now like that here
20:06:26 <darinmorrison> All I was basically saying is you need to have some sort of model, whatever that is. CompCert would be one (accurate) starting point. You could use LLVM, or you could just use higher level mathematical objects. But the proof techniques are similar regardless of the model I think, just they will probably be more painful the more accurate you get
20:06:41 <carter> darinmorrison no… i'm not proving anything
20:07:26 <carter> more like for a operation where I know all the work is commutative
20:07:45 <carter> i want to search the space of ways of orderign it with reads and writes etc
20:08:39 <carter> that minimizes # of writes, # of reads, maximizes the fraction of reads and writes that are aligned, maximizes the fraction of algebraic ops that are SIMDized
20:08:47 <carter> and has low circuit depth
20:08:50 <carter> and a few othe rthings
20:09:05 <carter> this won't be for a few months
20:09:12 <lispy> I think darinmorrison's point still applies.
20:09:28 <lispy> Having a model will help you.
20:09:30 <carter> true
20:09:40 <lispy> Having a more precise model will make it more cumbersome
20:09:48 <carter> that too
20:09:54 <carter> i don't care about the intel memory model for this work
20:10:00 <lispy> (and hopefully give better results modulo computational complexit)
20:10:01 <carter> because there won't be any contention between cores
20:10:06 <darinmorrison> carter: it depends on what you mean by "proof" to some extent too. A constructive proof could end up giving you a way of navigating that kind of space
20:10:20 <carter> darinmorrison: all i need is a cost model in this case
20:10:22 <dmwit> gaze__: I can't helping thinking you just want "make". Or, since you're a Haskell dude, shake.
20:10:33 <lispy> compiler optimizations, powered by Z3!
20:10:48 <dmwit> ?hackage shake
20:10:48 <carter> lispy ok, if z3 were commercial friendly, yes
20:10:48 <lambdabot> http://hackage.haskell.org/package/shake
20:10:54 <lispy> carter: http://www.cs.umd.edu/~saurabhs/pubs/saurabh-srivastava-thesis-9pt.pdf
20:11:12 <gaze__> yeah but this is supposed to run for quite a long time.
20:11:30 <carter> lispy darinmorrison  for the problems i want to optimzie, i can just use brute force dynamic programming and it'd still be fast
20:12:33 <carter> lispy darinmorrison  like, i'm just wanting to do something like dynamic programming over some language of simd ops treated as functional vectors to compute the min complexity circuit for a 4x4 matrix mult or something
20:12:36 <lispy> carter: I'm mostly teasing about z3, fwiw
20:12:40 <dmwit> gaze__: Nah. You just fire it up when you get a "message" that you're about to kick off a new job.
20:12:47 <carter> lispy its alsi 11pm on a friday night
20:13:15 <Sgeo_> edwardk, I think you misspoke in NYC
20:13:17 <carter> i'm annoyed about the clang + ghc + simd code story, so i'm going to so terrible hack of a build tool for driving the co code
20:13:30 <carter> Sgeo_ he spoke well, i was there
20:13:33 <Sgeo_> "giving a new a" when I think you meant "giving a new s"
20:13:36 <dmwit> gaze__: Anyway, if you want to know how an experienced Haskeller tackles the "I have a web of dependencies and jobs to do" problem, "shake" is the answer to that question.
20:13:37 <Sgeo_> http://www.youtube.com/watch?v=cefnmjtAolY
20:13:43 <Sgeo_> Around 4 to 4:06
20:13:58 <lispy> carter: limitations of things you want to use is super common. I feel your pain.
20:14:01 <gaze__> there's not really a dependency thing going on here
20:14:13 <carter> lispy i'm not planning on using z3
20:14:35 <gaze__> I'm trying to basically do continuation passing style where the function calls are serialized.
20:14:41 <carter> seriously, for my purposes i'll probably be perfectly happy with dynmic programming style brute forcing
20:14:43 <lispy> carter: understood.
20:15:02 <carter> lispy darinmorrison  : so this weekend is me writing a toy c code driver
20:15:08 <gaze__> and every other call is in tail position.
20:15:38 <carter> but what i can do for ""free""  (or at least easily)  is also do the alpha heavy hack to use C as CMM
20:15:38 <lispy> carter: I sent you the pdf mostly to share some research that is interesting. I doubt it would apply to your work, but it is an example of taking a specification and generating efficient code with a proof of correctness. Those tasks might be related to the problem you're solving.
20:15:51 <carter> lispy remind me in a few months
20:16:04 <carter> the next month or 2 is just me doing a C code version that i ffi to
20:16:14 <carter> and getting tha tout
20:16:20 <lispy> ya, that's reasonable
20:16:42 <darinmorrison> nice
20:18:17 <carter> darinmorrison lispy  if i can get the build driver hack working nicely + the alpha heavy trick systematically working, i'm going to call it C4hs,
20:18:22 <carter> for explosively fast primops
20:20:17 <carter> HOLY AWESOME, i could support ghc 7.4 even
20:20:42 <carter> (the register calling convention for 7.6 and 7.4 are the same)
20:20:49 <carter> ghc head / 7.8 is a teeny bit different
20:23:30 <zRecursive> Can ghc team make money by developing GHC which is a so big project ? just by donation as some other Open Source projects ?
20:24:09 <carter> zRecursive not really, the core team is al working on ghc as part of their associated jobs
20:24:10 <dmwit> I think Microsoft Research does a pretty big chunk of the GHC development and is not funded by donations.
20:24:37 <zRecursive> carter: the core team got paid ?
20:25:28 <carter> zRecursive they have day jobs whose duties coincide with ghc work
20:25:45 <carter> they're already working on it full time
20:25:52 <carter> whats more important is more people helping out
20:26:09 <zRecursive> carter: paid by micosoft ?
20:26:30 <carter> zRecursive depends on who
20:26:35 <carter> whatever their job is
20:26:40 <carter> some are at microsoft
20:26:42 <carter> some aren
20:26:44 <carter> t
20:27:27 <carter> zRecursive whats the goal in this line of questions?
20:28:00 <zRecursive> feel that haskell is much active than CommonLisp
20:28:17 <carter> zRecursive thats becuse people use it :)
20:28:21 <carter> and the language changes
20:28:24 <carter> and grows
20:29:29 <zRecursive> curious for more reason ...
20:31:00 <zRecursive> then what motivate the core team ,etc.
20:31:32 <carter> zRecursive you could ask them
20:31:43 <carter> generally people do things because they enjoy them
20:31:58 <zRecursive> for example, the thread support in CLISP is experimental for many years :(
20:32:42 <zRecursive> carter: enjoy is NOT enough as people need living
20:32:55 <carter> zRecursive they are paid
20:32:57 <carter> done
20:33:01 <zRecursive> ok
20:33:25 <carter> so both :)
20:34:04 <carter> at the endof the day, being able to work on what you care about + paid well = pretty darn awesome
20:34:15 <zRecursive> so CLISP needs donation ...
20:34:30 <carter> zRecursive ask their devs why they're not wokring
20:34:38 <carter> we don't know them
20:34:40 <carter> go ask them
20:34:41 <zRecursive> no money i guess
20:34:53 <zRecursive> from its website
20:35:06 <carter> zRecursive people find a way if they care
20:35:18 <carter> theres much nicer common lisps that are open source
20:35:30 <zRecursive> sure
20:35:46 * lispy *cough* sbcl *cough*
20:35:50 <carter> lispy that one
20:36:03 <carter> also with better licenses
20:36:11 <zRecursive> lispy: why *cough* ?
20:36:28 <lispy> CLISP doesn't even bother with the language standard. (that's not exactly fair, but they do intentionally violate it in places)
20:36:40 <applicative> zRecursive: he doesnt want anyone to know he knows anything about lisps and lisp implementations
20:36:49 <lispy> :)
20:37:27 <zRecursive> that is good to know lisper here
20:37:35 <Sgeo_> :t [1,2,3].mapped
20:37:36 <lambdabot>     Couldn't match expected type `b0 -> c0' with actual type `[t0]'
20:37:36 <lambdabot>     In the first argument of `(.)', namely `[1, 2, 3]'
20:37:37 <lambdabot>     In the expression: [1, 2, 3] . mapped
20:37:38 <Sgeo_> erm
20:38:08 <zRecursive> [1,2,3].mapped :)
20:38:44 <zRecursive> @ty mappend
20:38:45 <lambdabot> Monoid a => a -> a -> a
20:40:03 <zRecursive> > [1,2,3] `mappend` [4,5]
20:40:04 <lambdabot>   [1,2,3,4,5]
20:44:36 <zRecursive> How to understand that haskell uses unification as prolog does ?
20:44:46 <breadthfirst> If my cabal installation got messed up, what's the best way of uninstalling then reinstalling?
20:45:15 <Sgeo_> zRecursive, it doesn't
20:45:28 <Sgeo_> > let f a a = True; f a b = False in f 5 5
20:45:30 <lambdabot>   Conflicting definitions for `a'
20:45:30 <lambdabot>  Bound at: <interactive>:1:7
20:45:30 <lambdabot>            <in...
20:45:31 <applicative> breadthfirst: what platform are you using; how did you install ghc
20:46:06 <zRecursive> Sgeo_: sure ?
20:46:49 <dmwit> Sgeo_: Think about the type level... =)
20:47:19 <Sgeo_> dmwit, oh...
20:47:33 <zRecursive> maybe guard it ?
20:48:30 <applicative> breadthfirst you can kill everything using ghc-pkg unregister , getting rid of the things listed as locally installed things
20:48:31 <jmcarthur> zRecursive: haskell pattern matching is not unification
20:49:16 <zRecursive> jmcarthur: then does there exist unification in haskell ?
20:49:33 <applicative> type inference is a unification problem
20:49:36 <jmcarthur> the type checker uses unification by necessity
20:49:50 <jmcarthur> there are libraries for working with unification in haskell
20:50:01 <jmcarthur> they are not as convenient as prolog unification, afaik, though
20:50:55 <zRecursive> thanks
20:53:08 <dmwit> ?hackage unification-fd
20:53:09 <lambdabot> http://hackage.haskell.org/package/unification-fd
20:59:20 <nwf> Hey all.  Has anybody made a library out of "Computational Effects Across Generated Binders" yet?  I didn't see one on Hackage in a quick scan...
21:04:46 <Sgeo_> :t (%=) id
21:04:47 <lambdabot> MonadState s m => (s -> s) -> m ()
21:14:13 <necrobious> can anyone recommend a hackage for sending email?
21:32:36 <carter> lispy: i'll be using language-c-quote for a hoepfully successful crazy hack this weekend
21:32:50 <carter> i hope
21:41:36 <Aetherspawn> I added -with-rtsopts="-N" to my cabal GHC-options line
21:41:54 <Aetherspawn> but now I get "unexpected RTS argument -N" when I run the output exe
21:42:00 <Aetherspawn> Can anyone spot the problem?
21:43:03 <shachaf> Does it work when you just use +RTS -N?
21:43:19 <Aetherspawn> let's try
21:43:56 <shachaf> You haven't tried? So you've never had -N working?
21:46:16 <Aetherspawn> It works without -with-rtsopts=
21:46:48 <Aetherspawn> Maybe I need to add +RTS to the -with-rtsopts. I'll try that now.
21:49:31 <Aetherspawn> Well, I can't build it with the +RTS
21:49:40 <shachaf> ?
21:49:47 <Aetherspawn> My full command line options to the compiler are: -Wall -O2 -threaded -feager-blackholing -rtsopts -with-rtsopts="+RTS -N"
21:49:53 <Aetherspawn> however GHC says unexpected -N
21:49:54 <shachaf> You should read in the GHC user's guide how rtsopts work.
21:50:15 <shachaf> +RTS -N is passed to the executable when you run it, not to the compiler.
21:50:44 <shachaf> Anyway, thanks for giving your command line. Saying what you did is a good habit. :-)
21:50:58 <Aetherspawn> -with-rtsopts="-N" confuses the runtime executable
21:51:18 <Aetherspawn> (even though the docs show the correct way to do it like that)
21:51:20 <shachaf> ?
21:51:56 <Aetherspawn> if I use the following command line; -Wall -O2 -threaded -feager-blackholing -rtsopts -with-rtsopts="-N"
21:52:00 <lispy> carter: fun
21:52:26 <Aetherspawn> sec, I'll try a few more things.
21:52:27 <shachaf> OK. And if you don't use -with-rtsopts at all, but pass the executable (not the compiler) +RTS -N, what happens?
21:52:31 <shachaf> What about +RTS --help?
21:52:34 <Aetherspawn> It works
21:52:51 <Aetherspawn> to both questions
21:55:17 <Aetherspawn> giving -with-rtsopts="-N" to ghc at compile time through cabal gives me "Unexpected RTS argument:"-N"" when I run the final binary
21:56:17 <shachaf> What does it mean for +RTS --help to work?
21:57:35 <Saizan> Aetherspawn: try without the quotes
21:57:50 <shachaf> Hmm. Are you using Windows?
21:58:05 <Saizan> i.e. -with-rtsops=-N
21:58:23 <shachaf> Saizan++
21:58:36 <Aetherspawn> shachaf, I get this help output with +RTS --help
21:58:47 <Aetherspawn> (even though it says --help is not a known option)
21:58:49 <Aetherspawn> http://puu.sh/30D5O/9f587291a2.png
21:59:01 <shachaf> OK, that answers that.
21:59:12 <shachaf> The GHC user's guide is written for a UNIX shell, which handles quotes differently.
21:59:47 <Aetherspawn> ah
22:00:05 <Aetherspawn> I'm trying Saizan's suggestion now
22:01:01 <Aetherspawn> It won't build without quotes
22:01:12 <Aetherspawn> I get unrecognised option "-with-rtsopts=-N"
22:01:20 <lispy> Aetherspawn: you could try single quotes, -with-rtsopts='-N', I don't know if that wil lhelp
22:01:49 <lispy> It could be this is not possible with cmd.exe
22:02:02 <Aetherspawn> Nah, same thing
22:02:03 * lispy uses mintty + mingw for command line stuff on windows
22:02:21 <lispy> that way I'm able to use bash
22:02:28 <lispy> and things behave more like unix
22:02:33 <Aetherspawn> Would I be correct in calling this a bug?
22:03:03 <shachaf> I wouldn't call it a bug.
22:03:26 <lispy> Aetherspawn: I'm missing some scroll back, does +RTS --info work?
22:03:57 <shachaf> I have no idea what's going on with cmd.exe but it's weird.
22:04:03 <Aetherspawn> Moment
22:04:07 <frankbro> Quick question. Fairly new to haskell. Im trying to make a function that returns a number of random whatever in a list. I use getStdGen to get a seed but with every calls of the function, I get the same random numbers. This is my function http://hastebin.com/saboxepovu.coffee . I understand why this is happening but was looking for guidance for a best way of doing this. Should I return the seed?
22:04:16 <Aetherspawn> I'll try +RTS --info with -Wall -O2 -threaded -feager-blackholing -rtsopts
22:04:18 <frankbro> God, sorry for that wall of text.
22:04:27 <shachaf> If I remember correctly Windows programs are expected to do argument parsing by themselves rather than rely on the shell. Maybe in that sense ghc is behaving like a UNIX program and breaking its Windows contract. I don't know.
22:04:44 <lispy> frankbro: wall of text is okay (esp. if you're asking a question)
22:05:27 <frankbro> lispy, it's my canadian side acting up ;)
22:05:41 <lispy> frankbro: You need to thread the seed around. Otherwise you'll just be working with the same gen
22:05:44 <Aetherspawn> Sorry about the pictures rather than text. Selecting the terminal on windows is really hard to do
22:05:45 <Aetherspawn> http://puu.sh/30DhM/41d4ebe4a1.png
22:06:01 <shachaf> I think it's just right-click -> select or something like that?
22:06:04 <lispy> Aetherspawn: there is a menu in the top left that has an option to 'mark'
22:06:20 <lispy> Aetherspawn: okay, good. So at least one rts command works.
22:06:21 <Aetherspawn> Ah, "Mark" does the trick
22:06:44 <shachaf> burrito.exe? :-(
22:06:47 <Aetherspawn> All +RTS options work if I don't use the compile time -with-rtsopts=".."
22:07:19 <Aetherspawn> http://hpaste.org/88531
22:08:02 <Aetherspawn> /s/all/-N, -H, and everything I've tried manually/
22:08:07 <lispy> frankbro: search for 'random' http://book.realworldhaskell.org/read/monads.html
22:08:46 * shachaf wonders whether the / in /s/blah/blah/ comes from.
22:09:00 <shachaf> s/ther/re/
22:09:31 <lispy> :%s/shachaf/pedantic/g ;)
22:09:41 <frankbro> vim master race reporting in
22:09:54 <blaenk> someone call
22:10:03 <Aetherspawn> So uh
22:10:09 <Aetherspawn> Should it be put up as a bug on the trac
22:10:28 <Aetherspawn> (because as far as I know Windows is a primary platform)
22:10:32 <shachaf> First you should figure out what's going on.
22:10:49 <shachaf> Why did -with-rtsopts=-N not work?
22:11:08 <Aetherspawn> ghc took the whole thing as the name of a command line argument, I think
22:11:15 <Aetherspawn> I'll give you the output
22:11:30 <blaenk> --
22:12:06 <lispy> http://hackage.haskell.org/trac/ghc/search?q=windows+with-rtsopts&noquickjump=1&ticket=on&milestone=on&wiki=on&blog=on
22:12:09 <lispy> I don't see any bugs about this
22:14:07 <blaenk> a while back I wanted to generate a table of contents with nesting, given a list of numbers denoting header levels. someone suggested I build a tree by first doing groupBy (<), whoever said that here?
22:14:22 <blaenk> it did/does work, but I'm curious as to why. they explained at the time but I forgot -_-
22:14:31 <blaenk> why
22:14:32 <blaenk> > groupBy (<) [1, 2, 3, 2, 3, 1, 2, 2, 3]
22:14:33 <lambdabot>   [[1,2,3,2,3],[1,2,2,3]]
22:14:35 <Aetherspawn> Uh, -rtsopts -with-rtsopts=-N is working for me
22:16:06 <Saizan> yay
22:16:24 <shachaf> OK.
22:16:29 <Aetherspawn> I think theres another problem now though
22:16:39 <shachaf> How about -rtsopts "-with-rtsopts=-N", by the way?
22:17:19 <Aetherspawn> Sec, trying
22:18:03 <Aetherspawn> Yes, that works.
22:18:12 <shachaf> OK then.
22:18:36 <shachaf> There is no bug. The Windows shell treats quotes differently.
22:18:46 <shachaf> Perhaps the documentation should be updated.
22:19:37 <Aetherspawn> Yes, that would prevent confusion
22:19:39 <Aetherspawn> thanks.
22:20:11 <Aetherspawn> is this going to work on UNIX: "-with-rtsopts=-N" ?
22:20:40 <mauke> yes
22:20:48 <shachaf> So would the version without the quotes.
22:21:24 <Aetherspawn> OK
22:21:41 <Aetherspawn> we're back in action :P
22:21:48 <croikle> blaenk: take a look at the source. http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#groupBy
22:25:59 <blaenk> croikle: did, guess I'm just having trouble understanding it
22:26:12 <blaenk> so it uses span, which takes the longest sequence that satisfies the predicate
22:26:33 <blaenk> > groupBy (<) [1, 2, 3, 2, 3, 1, 2, 2, 3]
22:26:35 <lambdabot>   [[1,2,3,2,3],[1,2,2,3]]
22:26:49 <blaenk> ohhh I see how it works now
22:27:23 <blaenk> I was thinking it was running the predicate on each pair, so 1 < 2, 2 < 3, but it's not. it's just comparing to the first element
22:27:26 <blaenk> makes sense
22:28:56 <lispy> imo, groupBy can be a bit surprising
22:29:42 <croikle> yeah, it doesn't make a lot of sense. I was confused until I checked the source
22:35:26 <arkeet> it would be nice if groupBy could say in its type that it returned a list of nonempty lists.
22:35:28 <alang__> I think you're meant to give groupBy an equivalence relation
22:35:44 <arkeet> you are, but sometimes it's convenient to give it something else.
22:36:06 <arkeet> > groupBy (const id) [False,True,True,False,True,False,False,True,True,True]
22:36:07 <stevejb> hello, I am trying to get accelerate-cuda and accelerate-examples to run on Ubuntu 12.10. I am not familiar with LLVM, but apparently it is needed?
22:36:07 <lambdabot>   [[False,True,True],[False,True],[False],[False,True,True,True]]
22:36:15 <shachaf> arkeet: It would be nice if there was a non-awkward way to say that in Haskell.
22:36:20 <arkeet> I agree
22:47:46 <mauke> business logician
22:56:14 <latermuse> can someone help me figure out why this function isnt working correctly? http://hpaste.org/88533
22:56:34 <latermuse> its for shuffling a list, without using monads
22:56:50 <lispy> stevejb: I don't think those libraries are widely used. You might get the fastest answer by pinging the authors on twitter, email, or stackoverflow.
22:57:45 <lispy> did someone give out a homework assignment involving randoms and lists?
22:57:56 <latermuse> no. i dont have homework
22:58:12 <lispy> ah, perhaps it's a coincidence
22:58:14 <latermuse> im just curious. this script has worked very well before. but stopped working correctly lately
22:58:20 <lispy> hmm
22:58:33 <lispy> latermuse: have you seen Oleg's articles about shuffling?
22:58:39 <latermuse> i use it in a lot of my programs, and it worked without flaw for a long time
22:58:49 <lispy> latermuse: http://okmij.org/ftp/Haskell/perfect-shuffle.txt
22:58:54 <latermuse> yes: http://okmij.org/ftp/Haskell/perfect-shuffle.txt
23:00:26 <lispy> latermuse: it looks like you don't thread the modified random state around
23:00:36 <lispy> latermuse: you pass the original seed to all the recursive calls?
23:01:11 <lispy> :t randomR
23:01:13 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
23:01:44 <lispy> latermuse: you should try to initialize your RandomGen once using seed
23:01:47 <latermuse> yes, the original seed is being passed to the recursive calls
23:01:52 <latermuse> ys' = shufflePure seed (len - 1) ys
23:02:18 <lispy> latermuse: that's like doing this: http://xkcd.com/221/
23:03:08 <lispy> > randomR (0,1) (mkStdGen 4)
23:03:09 <lambdabot>   (1,200070 40692)
23:03:10 <lispy> > randomR (0,1) (mkStdGen 4)
23:03:12 <lambdabot>   (1,200070 40692)
23:03:13 <lispy> > randomR (0,1) (mkStdGen 4)
23:03:14 <lambdabot>   (1,200070 40692)
23:03:17 <lispy> (see what I mean?)
23:03:32 <latermuse> i see
23:03:49 <latermuse> but, this script worked correctly for at least half a year
23:03:52 <latermuse> and it stopped recently
23:04:15 <latermuse> im more concerned about it not working correctly anymore
23:04:35 <lispy> I'm not sure what you mean by correctly
23:04:44 <latermuse> making a new shuffle function isnt too difficult, but having one that worked successfully for so long just stop working is strange
23:04:45 <lispy> What is it failing to do?
23:05:03 <lispy> Does it cause an error, does it not permute the list, ?
23:05:21 <Aetherspawn> @src return
23:05:21 <lambdabot> Source not found. It can only be attributed to human error.
23:05:48 <latermuse> hmm, strange
23:05:48 <Aetherspawn> :t return
23:05:50 <lambdabot> Monad m => a -> m a
23:06:11 <latermuse> it just started working correctly again
23:06:30 <latermuse> i guess it turns out to be a user problem
23:06:36 <latermuse> thanks for the help lispy :)
23:07:05 <lispy> latermuse: you're welcome, but I would still try to rewrite it so that it actually threads the new randomgen state to the recursive call :)
23:07:14 <latermuse> yes, I see the flaw in that now
23:07:20 <latermuse> I will rewrite it to have such functionality
23:07:28 <lispy> cool, good luck
23:07:47 <latermuse> thanks, have a good evening
23:07:53 <lispy> likewise
23:08:14 <shachaf> Transhumanist: What's all this?
23:13:49 <no-n> @src (/)
23:13:49 <lambdabot> Source not found. Are you on drugs?
23:28:49 <stevejb> lispy: thank you for the message. I ended up compiling LLVM and then got accelerate-examples to build
23:29:18 <stevejb> quick question, as I am very new to Haskell
23:29:25 <stevejb> the Accelerate docs say:
23:29:31 <stevejb> For a list of available options and test programs, run:
23:29:31 <stevejb> > accelerate-examples --help
23:29:31 <stevejb>  
23:29:32 <lambdabot>   Not in scope: `accelerate'
23:29:43 <stevejb> when they say this, do them mean run that from ghci?
23:30:07 <mauke> no
23:31:10 <stevejb> mauke: okay, so I did a `cabal install` inside the directory, and then a make
23:31:30 <stevejb> and, the make seems like it was successful, but I do not see that it has left me with anything executable
23:31:54 <stevejb> mauke: nevermind, found it
23:33:57 <stevejb> I now have Haskell making CUDA programs via Accelerate! Awesome
23:38:54 <zRecursive> stevejb: what's the usage of Accelerate ?
23:42:47 <stevejb> zRecursive: trying to write some code to solve some recursive equations that my advisor needs solved
23:42:54 <stevejb> his matlab code is really slow
23:43:07 <stevejb> I want to pair accelerate with par monad, and perhaps meta-par
23:43:31 <stevejb> the code involves calculating a bunch of numeric integrals, so that seemed like a natural fit for accelerate
23:43:57 <zRecursive> thx
23:44:09 <stevejb> zRecursive: have you used it?
23:45:35 <zRecursive> nope
