00:01:15 <gaze__> I mean I get now that Q represents the operation of building up a list of Exps now
00:01:24 <gaze__> once you mentioned runQ
00:01:47 <gaze__> printing Q a itself doesn't make sense
00:04:48 <gaze__> I am reasonably convinced that TH is the proper attack for this problem. If it's appropriate in Yesod, it's appropriate here
00:05:07 <gaze__> that is, describing some record while endowing each element of the record with additional properties
00:05:27 <gaze__> or rather, allowing syntax to endow certain elements of the record with certain properties
00:05:59 <shachaf> Many of Yesod's uses of TH are arguably inappropriate. :-)
00:06:08 <shachaf> Not that I want to make that argument.
00:10:12 <gaze__> no I definitely get that TH is considered pretty sketchy
00:40:34 <arnsholt> Are any of you folks aware of a Haskell implementation of the Zhang-Shasha tree edit distance algorithm?
00:43:57 * hackagebot iter-stats 0.1.0.1 - iteratees for statistical processing  http://hackage.haskell.org/package/iter-stats-0.1.0.1 (JohnLato)
01:06:55 <kwstas> hello there! I'm implementing an algorithm that should hold a state. So I'm going to use State Monad. The problem is that some of the functions get as input some state and return a list of possible states. How do I define it using a State monad? Is the type State MyState [MyState] the right solution or should I  implement it differently?
01:08:33 <shachaf> kwstas: That depends on the algorithm.
01:09:00 <shachaf> The fact that you can describe it using state doesn't mean that State is the right way to implement it.
01:09:55 <Botje> kwstas: "list of possible states" hints at the list monad instead.
01:10:16 <shachaf> @unmtl StateS s [] a
01:10:17 <lambdabot> StateS s [] a
01:10:19 <shachaf> @unmtl StateT s [] a
01:10:20 <lambdabot> s -> [(a, s)]
01:10:24 <shachaf> That is another option.
01:10:30 <shachaf> But really it depends on what you're doing.
01:10:49 <kwstas> shachaf: yes tha is true. But almost all my functions takes as input a state...so I thought it is normal to use a ste monad to get rid some of the verbocity...
01:11:00 <shachaf> It's possible.
01:11:26 <arnsholt> This might be easier to answer if you said a little bit about what kind of problem you're solving
01:11:56 <arnsholt> To me it sounds like you might be doing some kind of non-deterministic search (a la NFA matching)
01:13:45 <kwstas> yes it's something like a non-deterministic search... It's the tableaux algorithm (http://en.wikipedia.org/wiki/Method_of_analytic_tableaux) where from a given state (path) you can produce one or more new states that you can traverse
01:16:30 <bitonic> wow.  linking pandoc adds a full 20MB to my executable.
01:17:01 <shachaf> That's even worse than a partial 20MB!
01:17:06 <bitonic> it is.
01:21:38 <tdammers> pandoc does have a dependency or two
01:23:35 <russellw> Given a program compiled with GHC, how can the program obtain and print information about what GHC version it was compiled with?
01:23:57 <blackdog> russellw: http://hackage.haskell.org/packages/archive/ghc-paths/0.1.0.9/doc/html/GHC-Paths.html ?
01:24:19 <blackdog> bit hacky, but you can probably pull it out of the path
01:24:32 <Saizan> russellw: +RTS --info
01:24:45 <Saizan> russellw: if compiled with rtsopts
01:25:41 <Saizan> oh, the program itself, then i don't know
01:26:26 <Saizan> > System.Info.compilerName
01:26:27 <lambdabot>   Not in scope: `System.Info.compilerName'
01:26:43 <Saizan> russellw: http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/System-Info.html
01:28:00 <russellw> Saizan, ah that looks right - it says not in scope, is there some kind of include or import statement needed?
01:28:54 <Saizan> russellw: yeah, import System.Info
01:29:24 <russellw> great, thanks!
01:38:27 <russellw> hmm, how do you convert compiler version into a string suitable for printing?
01:38:56 <russellw> .versionBranch doesn't do it
01:38:56 <Botje> Version has a Show instance
01:39:15 <russellw> Botje, so what's the syntax to access that?
01:39:29 <Botje> show compilerVersion
01:39:51 <Botje> there's also a showVersion function, which probably is the show implementation.
01:40:45 <Botje> > showVersion compilerVersion
01:40:45 <Botje> "7.4"
01:40:46 <lambdabot>   Not in scope: `showVersion'Not in scope: `compilerVersion'
01:40:48 <russellw> ah, so show is basically the Haskell to-string function.
01:41:12 <Botje> whereas the Show instance is just the automatically derived show
01:41:18 <russellw> But showVersion gets me not in scope, even when I prefix it with System.Info?
01:41:31 <russellw> I think that's the one I want since the generic show gets me output suitable for debugging but not production
01:42:50 <supki> russellw: showVersion is from Data.Version
01:43:31 <russellw> supki, ah, thanks!
01:43:55 <supki> @hoogle showVersion
01:43:55 <lambdabot> Data.Version showVersion :: Version -> String
01:52:54 <ntelford> ghc seems to be inferring the type of a lambda incorrectly - is there a way to coerce it to the correct type without having to extract the lambda to a named function?
01:53:40 <dario> you sure that's the problem?
01:53:43 <XexonixXexillion> turn off the monomorphism restriction
01:54:08 <dario> have you put the lambda in ghci and checked that ghci can/cannot infer the type correctly?
01:54:44 <shachaf> ntelford: When asking a question like that, you should post: 1) what you did; 2) what you expected; 3) what happened.
01:54:50 <shachaf> Then people are able to help you much better.
01:55:28 <DigitalKiwi> shachaf: i don't get the clean glass joke
01:55:40 <DigitalKiwi> but I think it is a jewish joke?
01:56:14 <DigitalKiwi> all my googling attempts for an explanation showed it being told as them being jewish :/
01:56:26 <Sgoettschkes> Hi
01:56:34 <shachaf> Is it? I wouldn't know.
01:57:00 <shachaf> But that was six hours ago.
01:57:09 <DigitalKiwi> lol
01:57:15 <DigitalKiwi> that recent? ;p
01:58:24 <Saizan> ntelford: you can use type annotations in expressions
01:58:40 <Saizan> ?type (\x -> x) :: () -> ()
01:58:41 <lambdabot> () -> ()
01:59:29 <Saizan> but yeah, if you have code it's easier to tell what's the best route
02:02:37 <ski> i've seen them referred to as "type ascriptions", when they adorn an expression (or pattern)
02:07:49 <Sgoettschkes> man, haskell is hard
02:08:43 <tdammers> Sgoettschkes: it depends
02:09:04 <Sgoettschkes> tdammers: I guess I just need to dig a bit deeper
02:09:13 <tdammers> that's not what I meant
02:09:24 <tdammers> the initial learning curve *is* much harder than, say, Python
02:09:53 <tdammers> but given a complex enough problem, you'll benefit
02:09:54 * ski suspects it depends on whether Python was your first programming language or not
02:10:11 <tdammers> neither Haskell nor Python were my first language
02:10:18 <tdammers> more like sixth and seventh
02:10:22 <Sgoettschkes> I always find it difficult to wrap my head around the functional way of doing things
02:10:37 <Sgoettschkes> especially as I'm doing most of my programming object oriented
02:11:06 <ski> tdammers : but had you learned any other FP language before ? Scheme,Erlang,SML,OCaml,Clean ?
02:11:16 <tdammers> ski: not really, no.
02:11:33 <tdammers> The functional parts of Javascript and C#
02:11:51 <tdammers> but they only really started making sense after learning Haskell and playing with Scheme
02:11:55 <ski> they say that learning a new programming paradigm (like FP) is a bit like learning to program all other again from the start
02:12:02 <tdammers> definitely
02:12:30 * earthy nods
02:12:38 <tdammers> although even Haskell isn't different enough to not give you a head start from other languages
02:12:58 <ski> Sgoettschkes : so you shouldn't necessarily think of it as Haskell being *that* hard, but that you (probably) have to learn FP at the same time as learning Haskell
02:13:17 <Sgoettschkes> I actually know a bit Racket and Scala
02:13:34 <ski> tdammers : *nod* some things carry over
02:14:10 <merijn> Must be that time of the month, I start my email client, 15 billion mails from libraries@ >.>
02:14:13 <ski> Sgoettschkes : Racket could help, at least in case you weren't using `set!' and `set-car!',`set-cdr!',`set-vector!',`set-box!' all the time
02:14:35 <Sgoettschkes> ski: Nope, nothing like that
02:14:44 <Sgoettschkes> ski: Tried to really learn how to do things the right way
02:14:49 * ski nods
02:15:05 <Sgoettschkes> ski: Biut I only player around with it, so I'm still at a beginner level
02:15:14 <ski> aye
02:16:22 <ski> Sgoettschkes : .. so, are you battling with types or laziness or recursion, or even expressing basic things ?
02:16:38 <tdammers> anyway, I guess even with a functional background, learning Haskell takes longer than learning Python from an imperative background
02:16:41 <tdammers> but
02:17:09 <tdammers> with Python, you have to bring a fuckload of discipline and experience to the table to keep things maintainable
02:17:14 <Sgoettschkes> ski: I just started this morning, so I'm battling the basic things ;)
02:17:21 <ski> ok
02:17:26 <ski> have fun :)
02:17:46 <ski> (and don't hesitate to ask e.g. here if you wonder about anything)
02:18:03 <dalaing1> I took a look at this recently - http://www.seas.upenn.edu/~cis194/lectures.html - and thought it looked like a pretty good resource
02:18:13 <dalaing1> I might have lost my "beginner eyes" though
02:19:18 <dalaing1> the fact it has a decent amount of homework is a huge plus
02:20:13 <Sgoettschkes> ski: Thanks, will do. As said, I'm fighting the basics problems which are best solved reading the documentation, but I guess I'll come back for some advice on "the haskell way" :)
02:21:45 <bartavelle> to me the hardest part for getting started was not knowning the important modules and why I should bother with all those typeclasses
02:22:55 <tdammers> bartavelle: absolutely. Something like a "these are the standard libraries people use for common stuff", kind of a libraropedia, would be nice
02:23:10 <tdammers> but then, these things tend to go out of date quickly
02:23:14 <bartavelle> there was a "one module a day" serie of posts once, it was really nice
02:23:19 <tdammers> yheah
02:23:27 <tdammers> but that's kind of the reverse
02:23:39 <tdammers> "here's some great modules, and you can use them for X"
02:24:03 <tdammers> what I'd love to see is a guide where you can look up X, and it'll tell you what the usual libraries are
02:24:15 <tdammers> e.g., you'd say "JSON", and it'd point you at Aeson.
02:24:27 <supki> "these are 7 standard libraries people use to do X"
02:24:29 <bartavelle> what should it say for XML ? :)
02:24:56 <tdammers> supki: sure, that's bound to happen, but still
02:25:18 <ski> @tell dav someone mentioned <http://www.seas.upenn.edu/~cis194/lectures.html> which contains a link to some Haskell Style guidelines, which appear to be sensible
02:25:19 <lambdabot> Consider it noted.
02:26:46 <tdammers> I mean, yes, for some things, several alternatives exist, but even then, some of them are typically either outdated, or highly experimental, and people do settle on maybe two or three alternatives
02:27:19 <tdammers> I'm not talking about a comprehensive list of all packages that may or may not do X - we already have that.
02:29:04 <bsrk> I need to install hsp >= 7 < 8
02:29:13 <bsrk> but I am using ghc 7.6
02:29:31 <bsrk> it requires me to have a package called old-exception
02:29:37 <bsrk> where can I find it?
02:30:58 <bsrk> http://hackage.haskell.org/package/hsp-0.7.2
02:31:36 <XexonixXexillion> is there an equivalent for c2hs for c++ ?
02:31:48 <shachaf> Well, old-exception is not available for GHC 7.6
02:31:55 <shachaf> Use hsp 0.8.
02:32:39 <bsrk> That will require me to port the codebase to the new API. I was hoping for a quicker solution :-)
02:32:49 <bartavelle> bsrk, downgrade the compiler :)
02:33:27 <bsrk> bartavelle: I could do that, I guess. :-)
02:33:39 <bartavelle> that certainly qualifies as a quick solution
02:39:59 <adnap> > let { f x 0 g x_ = x_ :: Applicative f => f [a] -> Int -> (a -> IO ()) -> f (IO ()) -> f (IO ()); f x n g x_ = f (init <$> x) (n - 1) g (liftA (>>) ((g . head) <$> x) x_) }
02:40:00 <lambdabot>   not an expression: `let { f x 0 g x_ = x_ :: Applicative f => f [a] -> Int ...
02:40:43 <supki> mm_freak: can I lift  Wire e m X X  to  Functor f => Wire e m (f X) (f X)  ?
02:43:08 <merijn> supki: Not without a newtype, otherwise that's not a valid functor
02:44:06 <supki> merijn: hmm, what newtype?
02:45:04 <merijn> "newtype FunctorWire e m f a = WF (Wire e m (f a) (f a)); instance Functor f => Functor (FunctorWire e m f) where"
02:45:31 <adnap> How do I do a multi-line let with lambdabot?
02:45:49 <merijn> > let foo = 1; bar = 2 in foo + bar
02:45:50 <lambdabot>   3
02:46:03 <supki> merijn: ew
02:46:14 <adnap> > let f x 0 g x_ = x_ :: Applicative f => f [a] -> Int -> (a -> IO ()) -> f (IO ()) -> f (IO ()); f x n g x_ = f (tail <$> x) (n - 1) g (liftA2 (>>) ((g . head) <$> x) x_)
02:46:16 <lambdabot>   not an expression: `let f x 0 g x_ = x_ :: Applicative f => f [a] -> Int ->...
02:46:49 <adnap> What's going on?
02:47:05 <merijn> supki: Wires are already functors and the type you wrote doesn't make sense as a functor otherwise
02:48:35 <supki> merijn: hmm, I have  Wire e m X X  and want to use it as  Functor f => Wire e m (f X) (f X). I don't particularly care for that lifting function to be named fmap :)
02:49:11 <adnap> > let f x 0 g x_ = x_ :: Applicative f => f [a] -> Int -> (a -> IO ()) -> f (IO ()) -> f (IO ()); f x n g x_ = f (tail <$> x) (n - 1) g (liftA2 (>>) ((g . head) <$> x) x_) in f [[2, 3]] 2 (putStrLn . show) [return ()]
02:49:13 <lambdabot>   Couldn't match expected type `GHC.Types.Int -> a0'
02:49:13 <lambdabot>              with actual...
02:49:28 <merijn> supki: Isn't "Wire e m X X" the trivial identity wire anyway? What would that signature even mean?
02:49:40 <supki> since if I have X -> X I can have Functor f => f X -> f X I think that operation can make sense for Wire too
02:50:34 <merijn> Maybe? WHat are you trying to actually do?
02:51:52 <adnap> > let f x 0 g x_ = x_ :: Applicative f => f [a] -> Int -> (a -> IO ()) -> f (IO ()) -> f (IO ()); f x n g x_ = f (tail <$> x) (n - 1) g (liftA2 (>>) ((g . head) <$> x) x_) in sequence_ $ f [[2, 3]] 2 print [return ()]
02:51:53 <lambdabot>   Couldn't match expected type `[m0 a0]'
02:51:54 <lambdabot>              with actual type `f0 [a...
02:52:21 <supki> I'm trying to decompose Wire e m (f X) (f X) into Wire e m X X and lifting operation :)
02:52:49 <supki> because Wire e m X X is useful by itself and I don't feel like copypasting code
02:53:18 <adnap> > let f 2 = 5; f x = 4 in (f 2, f 42)
02:53:20 <lambdabot>   (5,4)
02:58:21 <supki> I guess I'm not making sense =(
02:59:42 <shirt> what's the best way to have a mutex? so that two threads can execute two separate blocks of IO actions that should not overlap?
03:00:04 <merijn> shirt: Use an MVar?
03:00:16 <merijn> shirt: Empty it before you execute, refill when done?
03:00:51 <shirt> merijn: is that the recommended way? what should i fill it with?
03:01:31 <merijn> do { mvar <- newMVar (); forkIO (takeMVar mvar >> doStuff >> putMVar mvar ()); forkIO (takeMVar mvar >> doOtherStuff >> putMVar mvar ()) }
03:01:42 <Cale> shirt: Usually something which is needed to execute whatever code you'd be executing.
03:01:59 <Cale> But you can use () if there's nothing appropriate
03:02:02 <merijn> Well, if you really need only a mutex () should be sufficient
03:03:19 <shirt> thanks! another question:
03:04:16 <shirt> in STM, if an atomically block only ever reads a single TVar, then it will never have to be retried, and should always be efficient, right? (it never calls retry/orElse)
03:04:46 <Cale> If it doesn't write to anything.
03:05:07 <shirt> right
03:05:46 <Reite> \j bitcoin-otc
03:05:48 <supki> shirt: there also is readTvarIO if you only read a TVar
03:05:48 <Cale> Actually, no...
03:05:53 <Reite> -.-
03:06:15 <Cale> If your transaction reads from a TVar, but some other thread writes to that TVar before the transaction commits, then it may retry.
03:06:42 <russellw> If you're writing a Haskell program with multiple source files e.g. main.hs and foo.hs where main wants to call functions defined in foo, what's the technique? 'import foo' doesn't seem to be right?
03:06:51 <Cale> Though, that is somewhat unlikely.
03:07:03 <doomlord__> import foo as f ?
03:07:15 <Cale> russellw: Name the file Foo.hs, and put  "module Foo where" at the top of it
03:07:20 <Cale> then  import Foo
03:07:33 <Cale> (capitalisation matters)
03:07:59 <Cale> The filename matching the module name is only required to ensure that GHC can find it automatically.
03:08:24 <Cale> and module names are required to begin with an uppercase letter
03:10:47 <russellw> Cale, hmm that doesn't seem to work - does it only check the current directory from which the compiler was called? Like if the actual files in question are src/main.hs and src/Foo.hs is that a problem?
03:11:54 <russellw> That does seem to be the case because if I 'cd src' first, it does seem to work
03:12:22 <russellw> Is there a way around that or do you just have to 'cd src' before running the compiler?
03:12:31 <supki> -isrc
03:13:10 <russellw> ah perfect, thanks!
03:14:12 <shirt> supki: can readTVarIO ever retry?
03:16:30 <merijn> shirt: Yes, but it's very unlikely
03:16:33 <merijn> Why?
03:16:59 <shirt> just curious about performance and the implementation of STM
03:23:23 <adnap> Can someone help me evaluate the let expression I posted with lambdabot? It works in ghci
03:25:27 <russellw> hmm this is curious... If I open a file, read the contents, close the file and then print the contents, I just get the empty string, whereas if I swap the order of the last two steps, it works correctly
03:26:21 <russellw> Am I guessing correctly that this is because of the lazy semantics of Haskell evaluation interacting badly with file I/O such that getting the contents isn't actually evaluated until you try to print them, and if that doesn't happen until after the file is closed, then the file contents are not available anymore?
03:26:54 <nlogax> russellw: Yes
03:26:58 <shachaf> The semantics of lazy I/O, which is its own thing.
03:27:11 <shachaf> getContents does evil tricks to get this behavior.
03:27:16 <shachaf> Read about semi-closed handles.
03:27:53 <shachaf> This should probably go in the FAQ because it comes up so often. "semi-closed" and "lazy I/O" and "getContents" would be keywords to search for to understand what's going on (you should understand what's going on).
03:28:18 <russellw> Okay now my next intended step is using parsec to parse the contents. Does parsec count as demanding the contents, such that I could close the file after parsing, or is parsec itself still lazy so that I had better keep the file handle open until ultimate output?
03:29:03 <nlogax> I think it is automatically closed after read
03:29:19 <shachaf> You should read about how lazy I/O works. It would answer your question.
03:29:38 <russellw> Where is the best place to read about that?
03:30:40 <russellw> I've been reading the chapter in learn you a Haskell, but it doesn't seem to go into detail about that aspect of things
03:30:56 <shachaf> I don't know.
03:30:59 <shachaf> @google haskell semi-closed
03:31:00 <lambdabot> http://www.haskell.org/hoogle/?hoogle=hGetContents
03:31:00 <lambdabot> Title: hGetContents - Hoogle
03:31:08 <shachaf> http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#v:hGetContents looks like a good start.
03:31:20 <russellw> Okay thanks
03:55:43 <adnap> Hello?
03:56:49 <acube> adnap: What did you post?
03:57:00 <adnap> > let f x 0 g x_ = x_ :: Applicative f => f [a] -> Int -> (a -> IO ()) -> f (IO ()) -> f (IO ()); f x n g x_ = f (tail <$> x) (n - 1) g (liftA2 (>>) ((g . head) <$> x) x_) in sequence_ $ f [[2, 3]] 2 print [return ()]
03:57:01 <lambdabot>   Couldn't match expected type `[m0 a0]'
03:57:01 <lambdabot>              with actual type `f0 [a...
03:58:38 <acube> adnap: You cannot do IO in lambdabot
04:00:43 <adnap> > let f x 0 g x_ = x_ :: (Applicative f, Monad m) => f [a] -> Int -> (a -> m b) -> f (m b) -> f (m b); f x n g x_ = f (tail <$> x) (n - 1) g (liftA2 (>>) ((g . head) <$> x) x_) in sequence_ $ f [[2, 3]] 2 print [[]]
04:00:45 <lambdabot>   Couldn't match expected type `[m0 a0]'
04:00:45 <lambdabot>              with actual type `f0 [a...
04:01:03 <adnap> > let f x 0 g x_ = x_ :: (Applicative f, Monad m) => f [a] -> Int -> (a -> m b) -> f (m b) -> f (m b); f x n g x_ = f (tail <$> x) (n - 1) g (liftA2 (>>) ((g . head) <$> x) x_) in sequence_ $ f [[2, 3]] 2 [[]]
04:01:05 <lambdabot>   Couldn't match expected type `[m0 a0]'
04:01:05 <lambdabot>              with actual type `f1 (G...
04:02:16 <adnap> acube: Okay, but it seems, from the above, like there is another issue
04:03:12 <adnap> Oh! I forgot my g function
04:03:39 <adnap> > let f x 0 g x_ = x_ :: (Applicative f, Monad m) => f [a] -> Int -> (a -> m b) -> f (m b) -> f (m b); f x n g x_ = f (tail <$> x) (n - 1) g (liftA2 (>>) ((g . head) <$> x) x_) in sequence_ $ f [[2, 3]] 2 return [[]]
04:03:41 <lambdabot>   Couldn't match expected type `[m0 a0]'
04:03:41 <lambdabot>              with actual type `f0 [a...
04:03:47 <acube> @more
04:04:11 <adnap> :more
04:04:28 <acube> Doesn't work in non-private chat :(
04:05:41 <acube> adnap: The type signature is wrong
04:06:53 <acube> When you say f x 0 g x_ = x_ :: T then this is interpreted as f x 0 g x_ = (x :: T), so your f x 0 g x_ has the type (Applicative f, Monad m) => f [a] -> Int -> (a -> m b) -> f (m b) -> f (m b), which is not what you want (that should be the type of f alone, without all the arguments already passed in)
04:07:45 <adnap> Oh, I see
04:08:11 <HugoDaniel> it would be nice to be able to define data types inside where clauses
04:08:25 <adnap> How do I specifiy the type of f?
04:08:33 <HugoDaniel> where data MyTmpData = Blah1 | Blah2
04:09:05 <byorgey> adnap: let f :: blah blah; f x 0 g x_ = ...
04:09:24 <adnap> Ah
04:09:32 <acube> adnap: But in this example, you could just leave out the type signature, lambdabot will infer it for you
04:09:37 <byorgey> HugoDaniel: yes, that would be neat
04:09:44 <adnap> Yeah
04:12:25 <acube> When will haskell-platform 2013 (with ghc-7.6.3) will be officially released? (There is RC1 right now?)
04:13:19 <merijn> acube: There's an RC now, so Real Soon (TM)
04:13:39 <Kneiva> might happen even this year!
04:13:44 <acube> :D
04:14:52 <adnap> > let f x 0 g x_ = x_; f x n g x_ = f (tail <$> x) (n - 1) g (x_ ++ ((g . head) <$> x)) in sequence_ $ f [[2, 3]] 2 return [[]]
04:14:53 <lambdabot>   []
04:15:09 <adnap> Huh...
04:15:26 <adnap> I expected [[2, 3]]
04:15:47 <adnap> :t f
04:15:48 <lambdabot> FromExpr a => a
04:17:23 <merijn> adnap: That's not the f you defined
04:17:24 <acube> > let f x 0 g x_ = x_; f x n g x_ = f (tail <$> x) (n - 1) g (x_ ++ ((g . head) <$> x)) in sequence $ f [[2, 3]] 2 return [[]]
04:17:25 <lambdabot>   []
04:17:29 <merijn> > f a
04:17:30 <lambdabot>   Ambiguous type variable `a0' in the constraints:
04:17:30 <lambdabot>    (GHC.Show.Show a0)
04:17:30 <lambdabot>     ...
04:17:33 <merijn> aww
04:17:40 <acube> > let f x 0 g x_ = x_; f x n g x_ = f (tail <$> x) (n - 1) g (x_ ++ ((g . head) <$> x)) in sequence $ f [[2, 3]] 2 return [[]]
04:17:42 <lambdabot>   []
04:17:44 <acube> >  f 3
04:17:45 <lambdabot>   Ambiguous type variable `a0' in the constraints:
04:17:46 <lambdabot>    (GHC.Show.Show a0)
04:17:46 <lambdabot>     ...
04:17:48 <acube> >  f "hello"
04:17:50 <lambdabot>   Ambiguous type variable `a0' in the constraints:
04:17:50 <lambdabot>    (GHC.Show.Show a0)
04:17:50 <lambdabot>     ...
04:17:52 <acube> :O
04:17:57 <acube> >  f "hello" :: Expr
04:17:58 <lambdabot>   f "hello"
04:18:25 <acube> > let f x 0 g x_ = x_; f x n g x_ = f (tail <$> x) (n - 1) g (x_ ++ ((g . head) <$> x)) in f [[2, 3]] 2 return [[]]
04:18:27 <lambdabot>   [[],[2],[3]]
04:19:13 <acube> adnap: when you sequence that, it ends up as [] >> [2] >> [3], which is []
04:19:24 <adnap> Huh...Oh
04:19:27 <adnap> Right
04:19:31 <acube> > let f x 0 g x_ = x_; f x n g x_ = f (tail <$> x) (n - 1) g (x_ ++ ((g . head) <$> x)) in concat $ f [[2, 3]] 2 return [[]]
04:19:33 <lambdabot>   [2,3]
04:19:34 <adnap> Well, anyway
04:19:44 <adnap> My main question is... :)
04:20:03 <adnap> Can this function be written without 'n'?
04:20:12 <HugoDaniel> perhaps in Haskell 3000 it will be possible to define datatypes inside where clauses :D
04:20:25 <adnap> Or is there no way within the Applicative to know when we have reached the end of the list?
04:20:53 <acube> adnap: Try to write the function without the applicative
04:21:04 <acube> adnap: Then use that function on the applicative?
04:21:11 <acube> (Not sure if that will work)
04:21:57 <adnap> Monad m => [a] -> (a -> m b) -> m b -> m b ?
04:24:04 <acube> > let f [] _ x_ = x_; f (h:t) g x_ = f t g (x_ >> g h) in liftA2 (\x y -> f x 2 print y) (http://en.wikipedia.org/wiki/Special:Search?go=Go&search=2,3) ([return ()])
04:24:05 <lambdabot>   <hint>:1:135: parse error on input `='
04:24:05 <adnap> let f [] _ m = x; f (x:xs) g m = f xs g (m >> g x)
04:24:26 <adnap> let f [] _ m = m; f (x:xs) g m = f xs g (m >> g x)
04:24:29 <acube> > let f [] _ x_ = x_; f (h:t) g x_ = f t g (x_ >> g h) in liftA2 (\x y -> f x 2 print y) ([ [ 2,3 ] ] ) ([return ()]) -- Stupid irc client
04:24:30 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.IO ()))
04:24:31 <lambdabot>    arising from the literal...
04:24:39 <russellw> I look at the documentation for parsec and the sample code uses things like <$ which require an import. It doesn't say what the import should be. a hoogle search finds...
04:24:45 <russellw> @hoogle <$
04:24:45 <lambdabot> Data.Functor (<$) :: Functor f => a -> f b -> f a
04:24:46 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
04:24:46 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
04:25:02 <adnap> It's Applicative
04:25:12 <russellw> So the question is, since there seem to be two versions of it in different modules, which one should be - ah great, thanks!
04:25:34 <adnap> They do the same thing
04:26:12 <acube> adnap: Try this one in GHCi:  let f [] _ x_ = x_; f (h:t) g x_ = f t g (x_ >> g h) in sequence_ $ liftA2 (\x y -> f x print y) ([[ 2,3 ]]) ([return ()])
04:26:18 <merijn> russellw, adnap: They don't just do the same thing, they *are* the same, just reexported from 2 different modules
04:26:46 <russellw> If they are the same thing, what's the basis for saying which module is the right one to import?
04:26:58 <adnap> Nothing
04:27:03 <adnap> Use either one
04:27:23 <russellw> okay
04:27:33 <adnap> If you are working with Applicatives, then use the Applicative module
04:27:38 <acube> russellw: Data.Functor is smaller afaik, so if you only need (<$), (<$>) and fmap, Data.Functor is enough
04:27:44 <adnap> If you only need Functors, then use the Functor module
04:29:49 <adnap> acube: Thanks!
04:30:04 <merijn> russellw: The right one is probably Control.Applicative, because as you go further you probably want a lot of stuff from there anyway
04:30:08 <merijn> (Like <*>)
04:30:22 <russellw> merijn, yeah that makes sense
04:31:00 <adnap> I usually import the minimum I need
04:34:45 <russellw> I'm looking at example parsec code that uses readFloat and trying to modify it for integers instead. I correctly  guessed there is a corresponding readInt function... Except it seems to have an utterly different type, which generates a compile time error message
04:34:55 <russellw> What am I doing wrong?
04:34:59 <mauke> :t readFloat
04:35:01 <lambdabot> RealFrac a => ReadS a
04:35:02 <mauke> :t readInt
04:35:03 <lambdabot> Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
04:35:14 <mauke> what the heck is readFloat
04:35:33 <merijn> mauke: ReadS a is "String -> (a, String)" I think
04:35:37 <mauke> merijn: I know
04:35:44 <mauke> russellw: what are you using readFloat for?
04:36:08 <russellw> Well the parsec documentation http://book.realworldhaskell.org/read/using-parsec.html uses it in example code
04:36:23 <mauke> that's not the parsec documentation
04:36:27 <merijn> russellw: Ah..the RWH haskell chapter is a bit old
04:36:39 <merijn> russellw: Most of the basics still apply, but not every detail might be correct
04:36:56 <merijn> (I think it covers Parsec 2, the latest version is Parsec 3)
04:37:08 <mauke> merijn: irrelevant
04:37:18 <russellw> merijn, what would you suggest reading instead? That was the best link a Google search found
04:37:18 <mauke> > readFloat "3e2"
04:37:20 <lambdabot>   [(300.0,"")]
04:37:24 <mauke> > readFloat "3.1e2"
04:37:25 <lambdabot>   [(310.0,"")]
04:37:28 * mauke sighs
04:37:41 <mauke> > readFloat "3"
04:37:43 <lambdabot>   [(3.0,"")]
04:37:47 <mauke> > read "3" :: Double
04:37:49 <lambdabot>   3.0
04:38:02 <russellw> But actually looking at the type signature for readInt some more, I think I can guess what might be going on, maybe it wants an extra couple of arguments for saying what base to read
04:38:08 <merijn> russellw: I'd read it and then refer to the Haddocks on Hackage for actual reference
04:38:34 <merijn> @hackage parsec
04:38:34 <lambdabot> http://hackage.haskell.org/package/parsec
04:38:46 <mauke> russellw: readDec is the equivalent integer function
04:38:54 <russellw> ah, thanks!
04:39:07 * hackagebot wai-extra 1.3.4.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.3.4.1 (MichaelSnoyman)
04:39:08 <mauke> ... except it's not integer?
04:39:09 * hackagebot warp-tls 1.4.1 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-1.4.1 (MichaelSnoyman)
04:39:11 * hackagebot Chart 0.17 - A library for generating 2D Charts and Plots  http://hackage.haskell.org/package/Chart-0.17 (TimDocker)
04:39:13 <Aetherspawn> is a duplicated ChantT immutable -- can I put it in a ReaderT without it breaking?
04:39:13 * hackagebot Chart-gtk 0.17 - Utility functions for using the chart library with GTK  http://hackage.haskell.org/package/Chart-gtk-0.17 (TimDocker)
04:39:14 <mauke> > readDec "123"
04:39:15 <lambdabot>   [(123,"")]
04:39:18 <mauke> > readDec "12.3"
04:39:19 <lambdabot>   [(12,".3")]
04:39:23 <adnap> This might be helpful too: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing
04:39:29 <merijn> russellw: Hold on...readInt is from base, are you sure that's parsec?
04:39:30 <mauke> > readDec "12.3" :: [(Double, String)]
04:39:31 <lambdabot>   [(12.0,".3")]
04:39:37 <mauke> would you look at that
04:39:44 <adnap> russellw: ^
04:40:04 <mauke> merijn: <russellw> I'm looking at example parsec code that uses readFloat
04:40:11 <merijn> ah
04:40:12 <russellw> looks good ^.^
04:40:18 <merijn> I need to pay more attention :p
04:41:10 <merijn> russellw: Also, just hoogling the name readInt turns up the documentation: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Numeric.html#v:readInt
04:44:05 <Aetherspawn> is a duplicated ChantT immutable -- can I put it in a ReaderT without it breaking?
04:47:58 <Zeev> anyone know of simple haskell image manipulation library that allows file format conversion (.bmp, .png, .ico) and overlaying one image on top of another
04:49:27 <fryguybob> shirt: readTVarIO can never "retry" but it can actively spin.
04:51:21 <fryguybob> shirt: So if you only need to read the value of a single TVar it is much more efficent then  atomically . readTVar
04:52:46 <shirt> fryguybob: ok, makes sense. thanks
04:53:48 <fryguybob> shirt: If you have a bunch of threads doing  readTVarIO  and there is contention with a write it isn't going to perform as well as it could with a scalable lock.
04:55:56 <shirt> fryguybob: couldn't readTVarIO be internally optimized so it doesn't need to touch any locks at all, and never have to worry about retry?
04:56:40 <shirt> or i guess that might cause some unexpected behavior related to memory barriers
04:57:11 <fryguybob> shirt: The lock is the value field of the TVar in the current implementation.
04:58:01 <fryguybob> If you separated those then it could be just a read.
04:58:52 <fryguybob> shirt: The locks are never held for long so their implmenetation is optimistic about spinning.
05:00:33 <fryguybob> shirt: But depending on the architecture you would want to spin in a way that doesn't cause a great deal of overhead with the lock cache line bouncing all around.  For just a read it isn't bad, but the same spin is used when locking which could be improved.
05:02:49 <shirt> fryguybob: interesting
05:04:29 <weebl> hey guys, was wondering if there is a function for difference like Data.Set.difference for plain lists
05:04:33 <weebl> couldn't find it in Data.List
05:04:57 <mauke> > "hello" \\ "world"
05:04:58 <lambdabot>   "hel"
05:05:17 <weebl> > [1,2,3] \\ [2\
05:05:19 <lambdabot>   <hint>:1:14: parse error on input `\'
05:05:19 <weebl> > [1,2,3] \\ [2]
05:05:21 <lambdabot>   [1,3]
05:05:22 <weebl> thx
05:05:43 <XexonixXexillion> is there anyway to do something like "newtype Strict a = Strict !a"?
05:05:51 <Entroacceptor> > [1,2,3,2] \\ [2]
05:05:53 <lambdabot>   [1,3,2]
05:06:08 <weebl> Entroacceptor: any way to get around that?
05:06:26 <weebl> or would it require writing my own difference function
05:06:28 <fryguybob> weebl: Use Data.Set :P
05:06:37 <weebl> that's not an option
05:06:42 <weebl> it makes me cry
05:06:44 <mauke> XexonixXexillion: what would be the point of that?
05:06:52 <mauke> Strict a ~ a
05:07:13 <mauke> > nub [1,2,3,2] \\ [2]
05:07:14 <lambdabot>   [1,3]
05:07:16 <XexonixXexillion> except it would be strict, wouldn't it?
05:07:24 <mauke> XexonixXexillion: what does that even mean?
05:07:35 <XexonixXexillion> so (assumining an applicative instance) f <$> x <*> y would be strict
05:08:19 <merijn> XexonixXexillion: "Strict !a" would be strict in a, but newtypes are already strict in a
05:08:51 <weebl> O(n²), gotta love it
05:08:52 <weebl> <3
05:09:04 <mauke> XexonixXexillion: I don't think you understand what strict means
05:09:26 <XexonixXexillion> I just want something to be evaluated and not kept as a thunk
05:10:05 <XexonixXexillion> I don't really care if it's only to whnf
05:10:17 <mauke> "just"
05:11:08 <weebl> mauke: any smart tricks for doing subsets in lists?
05:11:20 <XexonixXexillion> ?
05:11:38 <XexonixXexillion> am I misusing English?
05:11:44 <merijn> weebl: toList and Set.fromList?
05:11:47 <weebl> :x
05:11:56 <Entroacceptor> > filter (\a->notElem a [2]) [1,2,3,2]
05:11:58 <lambdabot>   [1,3]
05:11:58 <weebl> that would be fastest probably
05:13:16 <weebl> > nub [2] \\ [1,2,3] == []
05:13:18 <lambdabot>   True
05:13:21 <weebl> that works ;x
05:20:48 <quchen> mauke: Maybe XexonixXexillion's problem is more with newtype than with strictness?
05:21:12 <quchen> If he replaced newtype with data, the question makes sense to me (unless I'm making the same mistake)
05:22:02 <mauke> quchen: no, ignore the type
05:22:13 <mauke> the additional attempt is part of the attempted solution, not the problem
05:22:16 <mauke> argh
05:22:22 <mauke> the additional type is part of the attempted solution, not the problem
05:22:41 <quchen> I am confused.
05:22:53 <weebl> anyone here ever worked with monotone frameworks in haskell?
05:23:35 <XexonixXexillion> I was hoping for something functionally equivalent to
05:23:55 <quchen> mauke: The way I understand it is that his "Strict a ~ StrictPair a ()", where "data StrictPair a b = StrictPair !a !b".
05:24:17 <mauke> quchen: yeah, that makes no sense
05:24:23 <XexonixXexillion> ... is hpaste not working?
05:24:30 <merijn> quchen: XexonixXexillion wants to make a strict by inventing the Strict a type, which makes no sense
05:24:48 <mauke> XexonixXexillion: works fine
05:24:56 <quchen> The bot may not work
05:24:59 <XexonixXexillion> http://hpaste.org/88288
05:25:14 <quchen> mauke, merijn: Care to explain?
05:25:54 <quchen> I'm not even sure where I misunderstand something now, whether it's the question or your answers :s
05:25:55 <mauke> XexonixXexillion: I'm sure that breaks a law or two
05:27:36 <XexonixXexillion> fmap id x = x (as x is already evaluated)
05:27:47 <XexonixXexillion> what law does that break?
05:30:32 <exicer> Does lines work with carriage returns?
05:30:54 <mauke> return a >>= f = Strict a >>= f = runStrict (fmap f (Strict a)) = runStrict (a `seq` Strict (f a)) = a `seq` f a
05:31:04 <mauke> /= f a
05:31:18 <applicative_> exicer: yes
05:31:46 <exicer> applicative_: Cool, thanks.
05:32:17 <quchen> exicer, applicative_: I don't think so, Data.List.lines uses \n only: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#lines
05:32:41 <acube> > lines "123\r123"
05:32:42 <lambdabot>   ["123\r123"]
05:32:47 <acube> > lines "123\n123"
05:32:48 <lambdabot>   ["123","123"]
05:33:19 <acube> Woo, lambdabot compiles on GHC 7.6 again? Nice
05:33:46 <applicative_> quchen: I was revising my view, yes.  I remember a complicated account of what it did somewhere, but was thinking of how one decides when to treat material as a haskell '\n'
05:34:34 <exicer> Ah, bugger.
05:34:43 <exicer> Okay, is there some equivilant that works with both?
05:34:44 <applicative_> a Haskell '\n' is a new line; but of course different things count as new lines in different systems etc.
05:35:00 <applicative_> exicer: this is haskell, it's not too hard to define ...
05:35:17 <exicer> applicative_: I'm sure I could, but I'm also sure it would be slow as hell!
05:35:27 <exicer> Given that I barely know what I'm doing :p
05:35:37 <applicative_> @src lines
05:35:37 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
05:35:40 <quchen> exicer: Data.List.Split may be helpful. It's in the Platform.
05:35:48 <applicative_> that's not very nice lambdabot
05:35:59 <exicer> quchen: Excellent, thanks.
05:36:10 <exicer> How much of haskell is written in haskell, by the way ?
05:36:25 <exicer> And is there somewhere I can view the sources online ?
05:36:34 <quchen> exicer: Also note that when you read files, there may be some implicit EOL conversion (specifically, from \r\n to \n) depending on the system.
05:36:54 <quchen> Haskell aims to have "\n" everywhere for consistency I think.
05:36:59 <quchen> Eh, coherency.
05:37:08 <exicer> quchen: If I'm just piping the output of cat into haskell, nothing should change though, right ?
05:38:19 <applicative_> quchen: right, that's what I was thinking of when I gave my too-quick response to exicer
05:38:41 <quchen> exicer: IO does these implicit conversions, so you should be careful.
05:38:50 <quchen> exicer: Do you have a file with \r EOLs?
05:38:52 <exicer> quchen: Hmm.. okay
05:39:03 <exicer> quchen: I have a file with \n\r eols
05:39:15 <exicer> and will potentially have a file with \r eols
05:39:22 <quchen> Oh boy. Who does that :s
05:39:24 <applicative_> exicer: are they appearing that when when read into a haskell string?
05:39:28 <exicer> I'm used to python just dealing with all this for me :P
05:39:41 <exicer> applicative_: So with the \n\r, yes
05:40:02 <XexonixXexillion> mauke: So there's no way I can do this http://hpaste.org/88289 without the overhead of a constructor (i.e infiniteList should not terminate)
05:40:07 <applicative_> ah, amazing
05:40:25 <merijn> exicer: The entire compiler (well, for GHC haskell) and large parts of the runtime are haskell, although the runtime also has some C/Cmm in it
05:40:28 <mauke> XexonixXexillion: why do you want things to not terminte?
05:40:49 <applicative_> termination is an effect
05:40:49 <exicer> merijn: That is cool. Presumably the source is a good place for me to read good quality haskell code then ?
05:41:14 <exicer> Or is it optimised in such a way that it would confuse a beginner ?
05:41:49 <Botje> no, it's pretty clear
05:41:54 <merijn> exicer: As a beginner I would avoid GHC itself, the Prelude and base should mostly be understandable, although occasionally optimised
05:41:55 <XexonixXexillion> mauke: Because in this case it means it's evaluating the tail of the list, which is something I want
05:41:57 <Botje> but you have to hold a *lot* in your head to make sense of it
05:42:28 <merijn> exicer: Xmonad is probably pretty good too, being a "real world" popular program, while still only being like 1.2k lines of code
05:43:07 <exicer> merijn: Okay... don't suppose Xmonad runs on osx does it?
05:43:13 <exicer> I suspsect not...
05:43:21 <merijn> It does
05:43:23 <blackdog> exicer: it sorta does
05:43:26 <exicer> Haha
05:43:39 <merijn> But it'll only manage X windows, not native GUI windows
05:43:40 <applicative_> there is osxmonad of course
05:43:49 <exicer> Hmm
05:43:49 <blackdog> brian mckenna got osxmonad working - last time i looked it didn't do multi-monitor very well though
05:44:03 <exicer> I've been thinking of just booting to linux on this laptop anyway
05:44:10 * hackagebot ghc-mod 2.0.2 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-2.0.2 (KazuYamamoto)
05:44:13 <exicer> Might be sufficient motivation to do so!
05:46:23 <merijn> exicer: Also, if I remember correctly you knew quite a bunch of languages already, right?
05:46:43 <merijn> exicer: Might want to take a look at Write Yourself a Scheme in 48 Hours
05:46:59 <applicative_> exicer, in any case with the files mentioned above, you should probably use 'Data.Text', there is a lines function there, and various break functions so it will be easy to make a my_lines
05:48:46 <quchen> merijn: I still don't understand what's wrong with a "Strict !a" type (constructor).
05:49:06 <quchen> (And nobody answered before) :-(
05:49:15 <Botje> quchen: it doesn't make sense for a newtype, at least
05:49:17 <quchen> And I meant data constructor ^^^
05:49:30 <quchen> Botje: Yes, that is true. But for data?
05:49:53 <quchen> The argument was "the error here is strictness, and not data vs newtype".
05:49:57 <quchen> That's the part that confused me.
05:50:03 <merijn> ok, hold on this'll be a while
05:50:04 <Botje> then you have the same semantics as a newtype, i'd say
05:50:10 <merijn> I'll write it out
05:50:11 <exicer> merijn: I know a few languages, yes. I'm very new to functional stuff though. Will check it out.
05:50:15 <Bor0> can you beta reduce λf.(λx.f (x x)) (λx.f (x x))? i.e. apply (λx.f (x x)) to (λx.f (x x))
05:50:16 <exicer> applicative_: Will have a look - thanks
05:50:16 <mauke> Botje: not quite
05:50:16 <quchen> merijn: Appreciate it, I'll be here :-)
05:51:15 <applicative_> exicer: but if you want to work with String, someone mentioned the very straightforward Data.List.Split
05:52:52 <applicative_> Data.List.Split has a function linesBy :: (a -> Bool) -> [a] -> [[a]]
05:53:55 <exicer> So it does
05:54:40 <exicer> The stupid way I was thinking of doing it was to just apply all three splits - eg \r\n then \r then \n
05:54:46 <exicer> Do you see some problem with this ?
05:55:03 <exicer> Other than being kinda hacky :p
05:55:36 <OODavo> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html doesn't seem to define a generic version of mapM or sequence---or any sequencer, applicative or monadic, that doesn't throw away the results of each action. Is it not possible to define such a thing generically for any Foldable, or does Data.Foldable just not do that?
05:57:59 <quchen> OODavo: mapM requires Traversable.
05:58:07 <quchen> mapM_ can be done using Foldable.
05:58:42 <shachaf> ...But note that where you can, you should use traverse instead of mapM and traverse_ instead of mapM_.
05:58:43 <quchen> (mapM *is* traverse from Traversable, and there because of the Applicative-Monad issue.)
05:58:59 <OODavo> Oh, aha. Is that needed because the ability to create a new data structure isn't implied by Foldable?
05:59:07 <shachaf> They have the same behaviour except they use Applicative instead of Monad.
05:59:48 <shachaf> OODavo: Yes. Foldable is, more or less, toListable. Traversable is, more or less, MapMable.
06:00:34 <merijn> quchen: http://hpaste.org/88290
06:01:09 <quchen> merijn: Thanks!
06:02:06 <OODavo> Hmm. I find it weirdly unintuitive that folding is "simpler" than mapping. Not sure why.
06:02:08 <merijn> btw, someone should check that to make sure I didn't miss up my newtype/strictness explanation
06:02:19 <merijn> s/miss/mess
06:02:28 <shachaf> merijn: Thunks to describe semantics. :-(
06:02:34 <merijn> shachaf: Shush
06:02:45 <merijn> If you have a better explanation, let's hear it
06:02:55 <shachaf> Note that StrictData is still different from Newtype.
06:03:49 <shachaf> That explanation looks rather confusing to me, really. Halfway to being operational but not really there.
06:03:52 <shachaf> @google strict data vs newtype
06:03:53 <lambdabot> http://www.haskell.org/haskellwiki/Newtype
06:03:53 <lambdabot> Title: Newtype - HaskellWiki
06:05:51 <quchen> shachaf: The question wasn't about data vs newtype, I think. What I'm asking about here is the following: A user brought up "newtype Strict a = Strict !a". I then thought "well, he's confused about newtype vs data", but others said that's not the misunderstanding, but rather a wrong conception of strictness.
06:06:17 <shachaf> Or of newtype.
06:06:26 <shachaf> I would say of newtype.
06:06:34 <quchen> I would have said the same.
06:06:36 <mauke> newtype is not enough
06:06:37 <shachaf> Well, most likely both.
06:06:56 <mauke> it's analogous to 'seq x x' to "force" x right there
06:07:05 <mauke> just with 'Strict x'
06:08:00 <shachaf> Yes.
06:08:18 <shachaf> It's odd how often (seq x x) comes up independently.
06:08:34 <merijn> quchen: Did the explanation at least help for you? >.>
06:08:42 <quchen> merijn: Still working on it :s
06:09:02 <quchen> merijn: What do you mean with line 23?
06:09:13 <merijn> The parallel with "seq x x" is good, I should've thought of that
06:09:23 <quchen> "The 'a' in 'newtype a' is already strict"
06:09:39 <merijn> quchen: As in, when you look at the Newtype a version
06:09:45 <merijn> quchen: What is the extra ! supposed to do?
06:10:23 <merijn> The !a in StrictData only affects the a inside StrictData, but the a in Newtype a is already strict, what would adding ! to it do?
06:11:14 <quchen> I think I found the problem. Why is the "a" in "Newtype a" already strict? I understand that the newtype wrappers are compiled away, but why shouldn't there be a thunk in "a" anyway?
06:11:29 <shachaf> I think perhaps you are begging the question there a bit. Isn't that text supposed to be an explanation of newtype?
06:11:37 <merijn> shachaf: No
06:11:47 <shachaf> quchen: It's like (seq x x).
06:11:58 <shachaf> Do you understand seq x x?
06:11:59 <merijn> It was only supposed to show why "newtype Strict a = !a" is senseless
06:12:11 <quchen> shachaf: Yes.
06:12:14 <quchen> It's x.
06:12:18 <merijn> That text'd be worthless as newtype explanation
06:12:19 <shachaf> OK then.
06:12:30 <shachaf> Apply that understanding to this newtype.
06:12:58 <mauke> quchen: there is no 'in "a"' where there could be a thunk
06:13:30 <merijn> quchen: Newtypes don't exist at runtime. "Newtype 1" = "1"
06:13:35 <quchen> Oh. Wait. I stopped seeing "!" as "conveniently add seqs" and thought it makes things strict instead.
06:13:55 <quchen> I'll recurse using this and see where it gets me ;-)
06:14:11 * hackagebot minioperational 0.1 - fast and simple operational monad  http://hackage.haskell.org/package/minioperational-0.1 (FumiakiKinoshita)
06:14:20 <mauke> values aren't strict, functions are
06:16:07 <quchen> So at runtime, "Newtype a" is "a", which is the point of newtype in the first place. By analogy, "Newtype !a" is "!a" at runtime, which is like "seq (x :: a) x" ..?
06:16:35 <shachaf> What?
06:17:16 <mauke> "!a" is not a thing
06:17:50 <quchen> I'm using the "let's pretend" notation merijn introduced in line 5 there.
06:18:02 <shachaf> "!a" is still not a thing.
06:18:15 <shachaf> "data Foo = Foo Char" contains a Char. By analogy, "data Foo = Foo Char Int" contains a Char Int.
06:19:08 <mauke> how do I extract the | from 'Left a | Right b'?
06:19:11 <merijn> quchen: Even in my pretend notation "!a" is not a thing
06:19:11 * hackagebot prizm 0.1.0.4 - A haskell library for computing with colors  http://hackage.haskell.org/package/prizm-0.1.0.4 (ParnellSpringmeyer)
06:19:28 <quchen> merijn: Well crap.
06:19:56 <shachaf> Why is (seq x x) the same thing as x?
06:20:08 <exicer> Trying to create a program to filter a list of words based on the the fact that the word contains all of the vowles in order, or not.
06:20:11 <exicer> http://hpaste.org/88291
06:20:17 <exicer> This doesn't work - what have I misunderstood ?
06:20:45 <quchen> shachaf:  Because of seq's definition. seq bot x = bot, seq _ x = x.
06:20:45 <mauke> exicer: "doesn't work" is not a problem description
06:20:46 <merijn> exicer: head & tail :(((
06:21:09 <shachaf> exicer: I don't know. You said what you did. You didn't say what happened, or what you expected.
06:21:12 <Botje> exicer: needs parens around vh:f and vh:vs, at the least.
06:21:15 <merijn> quchen: That's not an answer, *why* is that
06:21:16 <exicer> Ah sorry - it does not compile
06:21:34 <mauke> exicer: you should fix the error
06:21:42 <merijn> exicer: Maybe pastebin the error next time :)
06:21:46 <Botje> line 12 parses as (checkOrder vs vh) : (f ws)
06:21:49 <exicer>     Couldn't match expected type `Bool' with actual type `[a0]'
06:21:51 <Botje> which is very probably not what you want
06:21:51 <merijn> exicer: But yes. parens around :
06:22:05 <exicer> merijn: Hah, yes good point :p
06:22:24 <quchen> merijn: ..? There are two cases of "seq x x": 1. x is bottom, then seq x x = bottom = x. 2. x is not bottom, then seq _ x = x. Therefore, "seq x x = x".
06:22:36 <exicer> merijn: I used head and tail because I couldn't use vh:vs etc in the match for some reason..
06:22:54 <merijn> quchen: No. What are the operational semantics of seq?
06:23:01 <merijn> exicer: Sure you can
06:23:04 <Botje> exicer: again, parens :)
06:23:23 <Botje> checkOrder (vh:vs) f (wh:ws) = ...
06:23:29 <exicer> Bah, ok good :p
06:23:35 <shachaf> merijn: :-(
06:23:35 <quchen> merijn: I don't know what 'operational semantics' means (despite hearing it in here every now and then). :-\
06:24:04 <Botje> exicer: it's a very common hold-up among new haskellers, don't worry :)
06:24:19 <shachaf> Well, whatever. Operational semantics is a valid way to explain this and get an intuition for it, to an extent.
06:24:33 <merijn> exicer: http://hpaste.org/88291
06:25:00 <shachaf> But Haskell is non-strict. You can understand everything discussed here by assuming that it's call-by-name, not lazy. No thunks to be forced!
06:25:09 <merijn> exicer: Note, I just did that by blind following your code and no type checking, so no guarantees on it compiling
06:25:10 <quchen> merijn: I would have said "the definition of seq" I wrote above is what defines it. Is it not?
06:25:16 <shachaf> And then, when you want to talk about laziness, you can understand everything necessary by talking about graph reduction. Still no thunks.
06:25:22 <exicer> merijn, Botje - thanks !
06:25:23 <merijn> quchen: "Operational semantics" == "what does this do when executed"
06:26:14 <quchen> merijn: Well, it's defined as being bottom if the first argument is bottom, otherwise it's the second argument. That doesn't assume anything about execution, does it?
06:26:16 <merijn> shachaf: I just have an operationally focussed mind, that's where all my intuition comes from :(
06:26:30 <merijn> quchen: How it's defined is irrelevant to the issue we're discussing
06:26:51 <merijn> What is it supposed to do? *Why* would you use seq at all in code?
06:27:11 <merijn> According to your definition seq is completely superfluous
06:27:13 <quchen> To avoid unnecessary thunks?
06:27:18 <merijn> Aha
06:27:25 <merijn> And how does seq help?
06:27:36 <shachaf> merijn: Also, people's operational understanding of seq, especially under optimization, is pretty wrong compared to what code gets generated.
06:27:45 <shachaf> Well, somewhat wrong, sometimes.
06:27:46 <merijn> shachaf: I know
06:28:08 <merijn> quchen: seq doesn't just sprinkle "thunk dissolving fairy dust"
06:28:13 <shachaf> It's not really a function at all. It's a hint (well, something a bit stronger than a hint) to GHC about an expression.
06:28:13 <quchen> If the compiler can prove that the first argument isn't bottom, it can use the second argument. If the first argument turns out to have a value "Box a", then it's not bottom.
06:28:23 <shachaf> What?
06:28:37 <merijn> quchen: The compiler doesn't prove anything
06:28:43 <quchen> Well, finds out
06:29:04 <merijn> quchen: seq is an instruction to the compiler in which order things should be forced/evaluated
06:29:14 <shachaf> merijn: The trouble with this operational semantics approach here -- if that's what you want to do that -- is that you're compiling into fairy dust.
06:29:24 <shachaf> s/that //
06:29:36 <merijn> So my question to you is, what are you telling GHC to do?
06:30:51 <quchen> seq says "hey this whole expression (seq a b) makes sense only if a makes sense". Correct?
06:31:05 <quchen> Or better, "may only make sense".
06:31:21 <supki> merijn: where does seq claim anything about order?
06:31:25 <shachaf> What is making sense?
06:31:38 <quchen> shachaf: make sense = not be bottom.
06:31:46 <merijn> supki: In its internal compiler builtin fairy dust
06:31:52 <mauke> sense and sensibility
06:31:58 <shachaf> You're rephrsaing your old thing, then.
06:32:05 <quchen> :-(
06:32:10 <quchen> Wasn't trying to.
06:32:11 <shachaf> merijn: No, seq a b doesn't say anything about a being evaluated before b.
06:32:21 <merijn> shachaf: I didn't say that
06:32:31 <merijn> Because I already learned that was wrong
06:32:59 <shachaf> OK.
06:33:14 <merijn> I just said it's an instruction about the ordering, not what the instruction was, because I'm not 100% sure I correctly get everything there :p
06:33:18 <quchen> ... can someone give me the "operational semantics" of seq please? I feel like I'm only poking around in guesses here.
06:33:37 <shachaf> No, there is nothing to give the operational semantics of seq in terms of.
06:34:12 <shachaf> Come up with some machine that you're compiling Haskell to, and then you can come up with something that you can compile seq to.
06:34:19 <shachaf> Right now "thunk" sounds like fairy dust.
06:34:29 <mm_freak> supki: see the Profunctor instance
06:35:22 <shachaf> Anyway, you don't need to say the word thunk even once to understand this.
06:36:06 <quchen> shachaf: What you say may be right, but it's not helping on my level. If I came in here asking for how to build a car without wheels, "try building it, it won't work" may be correct, but it won't help me understand the real issue.
06:36:51 <shachaf> I'm not saying that to you.
06:37:13 <merijn> shachaf: If I understood it right (big if!) it's just that forcing "seq a b" forces a too, right? Which says nothing about whether a will ever be forced
06:37:38 <shachaf> Understood what right?
06:37:52 <merijn> seq or things, or I dunno!
06:38:02 <shachaf> Well, forcing seq a b might never force a.
06:38:08 <quchen> I'm willing to RTFM if you can point me in the right direction. I am lost, and all I'm hearing is what parts are wrong, not how to get it right.
06:38:16 <shachaf> @where lazy -- did you read that?
06:38:16 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
06:38:19 <merijn> http://img.pandawhale.com/42255-Im-not-a-smart-man-Forrest-Gum-W2X0.jpeg
06:38:55 <sj4nz> Is this seq the same as www.haskell.org/haskellwiki/Seq ?
06:39:04 <shachaf> The very.
06:39:08 <applicative_> hm, arguments about seq? ... a perennial favorite
06:39:32 <shachaf> merijn: In particular, the guarantee that seq gives you is the one that quchen said above.
06:39:34 <applicative_> there's no bore quite like a domain theory bore
06:40:29 <quchen> shachaf: Was that "lazy" link for me?
06:40:35 <shachaf> Yes.
06:40:47 <quchen> Alright, thanks.
06:40:53 <shachaf> quchen: The "lazy" link was for you, as was the "Yes.".
06:41:17 <quchen> shachaf: I didn't ask whether the link was "for me or merijin", because I feared the answer would be "yes" :-)
06:42:13 <shachaf> merijn: Semi-operationally, you might implement (seq a b) by forcing b, then forcing a, then "returning" b.
06:42:18 <dmwit> quchen: If a and b are both bottom, seq a b may evaluate to either bottom; if b is not bottom, a will certainly be forced.
06:42:24 <shachaf> If b is ⊥, then a never gets forced.
06:42:58 <sj4nz> UNICODE fail. I'm guessing it's _|_
06:43:01 <shachaf> It might even evaluate to a whole different bottom!
06:43:12 <shachaf> ⊥ is _|_, yes.
06:43:16 <merijn> shachaf: Right
06:43:19 <dmwit> Yes, the point is that all bottoms are the same.
06:43:42 <dmwit> I suppose the right way to say it is "if a is bottom, seq a b is bottom; otherwise, seq a b is b".
06:43:52 <merijn> shachaf: As usual my intuition is fairly reasonable, just not exactly expressed in words
06:45:27 <quchen> dmwit: That's the operational semantics of seq, I assume? So operational semantics stands for "what the computer will actually do" then? (Wikipedia isn't very helpful)
06:45:42 <mauke> FSVO "computer"
06:45:58 <dmwit> An operational semantics does indeed stand for "what the computer will actually do"; however, what I gave was not an operational description of seq.
06:46:34 <dmwit> Since what I said does not tell you how to pick a value for seq a b; it only gives a "promise" about what choice will be made.
06:46:54 <shachaf> dmwit: Yes, merijn was rejecting that definition and insisting on an operational one earlier.
06:47:04 <dmwit> okay
06:47:20 <dmwit> There are many good choices for how seq operates.
06:47:32 <dmwit> Where "good" means "satisfies the promise".
06:47:44 <sj4nz> so `seq` is kind of like a anti-or in the imperative pattern, say if it was javascript: "a || b = a", in this javascript, b is never "forced" if a is "truthy", `seq` here prefers to force a and return a if it is not "truthy" (aka _|_) otherwise it will force and return b.
06:47:50 <dmwit> One good choice is for "seq a b" to force "a" first, then return "b".
06:48:09 <dmwit> sj4nz: Nope.
06:48:26 <sj4nz> b is not forced?
06:48:27 <dmwit> sj4nz: The whole point is that the operation you're giving there is just one of many good implementation choices for seq.
06:48:54 <dmwit> Another good choice is for "seq a b" to force "b"; then force "a"; then return "b".
06:49:05 <sj4nz> ah ok
06:49:09 <dmwit> Another good choice is to look at a qubit to decide what order to force things in. =)
06:49:15 <sj4nz> lol
06:49:31 <sj4nz> my desktop d-wave is too busy mining litecoin
06:49:33 <shachaf> Or to reduce a and b to WHNF twice, for good measure.
06:50:02 <dmwit> sj4nz: Anyway, Javascript-style || is just plain laziness.
06:50:34 <dmwit> sj4nz: See also the last bullet point in http://stackoverflow.com/a/7868790/791604
06:50:50 <shachaf> When I can get away with it, I like to pretend my code is evaluated with call-by-name.
06:51:08 <sj4nz> I was using js:|| as a pattern of code-- I knew it does not acting like `seq`
06:51:15 <shachaf> code++
06:51:48 <dmwit> sj4nz: I am using it as indicative of a pattern, too. And that pattern is laziness.
06:52:36 <dmwit> ...but I now see that I misread your statement, which essentially reads "seq is the anti-laziness", which is right.
06:52:39 <dmwit> I apologize.
06:52:57 <merijn> Right, after that link I can conclude that my intuition is correct and it's just the fact that I didn't really account for multiple valid implementations in seq when I tried to write out my intuition
06:53:07 <sj4nz> it's hard to switch "languages" when they're using the same line-noise for syntax
06:53:37 <merijn> Which fortunately doesn't seem to impact my intuition about seq's denotational semantics
06:55:51 <supki> mm_freak: not sure how Profunctor instance helps, I would need both (f X -> X) and (X -> f X) functions then?
06:56:53 <mm_freak> supki: the Profunctor instance is basically a better 'arr' from Arrow
06:57:02 <mm_freak> so it all depends on your functor f
06:57:26 <mm_freak> for f X -> X you need comonad and for X -> f X you need Applicative/Monad
06:57:44 <sj4nz> perhaps quasiquoting in IRC [language|CODE|] e.g. [hs|a `seq` b|] [js| !(a) ? b : b|]  (another try at `seq` in js, and this one is also wrong because it doesn't return a if it is _|_ )
06:58:47 <shachaf> You're not going to get anywhere very deep with analogies like that. They break easily.
06:59:04 <dmwit> Have we mentioned pseq yet?
06:59:23 <dmwit> pseq has the same promise as seq but also promises a specific operational behavior: it definitely forces its first argument before touching its second one.
07:02:09 <supki> mm_freak: well, I guess that'll work with Pointed/Copointed but I wanted something more akin to fmap
07:02:58 <acube> @index pseq
07:02:58 <lambdabot> GHC.Conc
07:03:04 <acube> @hoogle psec
07:03:04 <lambdabot> package leapseconds-announced
07:03:04 <lambdabot> Data.Time.Clock.TAI type LeapSecondTable = Day -> Integer
07:03:30 <mm_freak> supki: that doesn't really seem to make sense though
07:04:01 <quchen> Alright, so the denotational semantics of seq is what the Report states; the operational semantics is (are?) how GHC chooses to implement it, subject to satisfying the denotational semantics. Right?
07:05:03 <quchen> (Also I read the "lazy" link shachaf gave me. It was interesting on its own, but I still can't bridge the gap to the "!a" issue I'm having here.)
07:05:32 <quchen> (And I called it the "!a" issue because that's a nice abbreviation for ... well something wrong I'd like to understand.)
07:05:41 <dmwit> quchen: To your non-parenthetical: that sounds right to me.
07:06:11 <mm_freak> supki: given a Wire e m X X you can turn it into a (Applicative f, Comonad f) => Wire e m (f X) (f X) with this function:  lmap extract . fmap pure
07:06:12 <dmwit> Can you remind me what the "!a" issue is?
07:06:17 <circle> in the defintiion Nat = Zero | Succ Nat, does "Succ" have speical meaning in haskell or could it be replaced with "Succ1"?
07:06:20 <mm_freak> supki: but i really wonder why you would do that
07:06:29 <mm_freak> circle: the latter
07:06:30 <enthropy> can anybody tell what this package has been replaced by: http://hackage.haskell.org/package/control-monad-failure-0.7.0.1 ?
07:06:36 <circle> mm_freak: k, thanks
07:06:55 <quchen> dmwit: The question is basically why "newtype Strict = Strict !a" doesn't make any sense.
07:07:03 <enthropy> it's quite convenient of them to say "this package is obsolete", but then there's no suggestion as to what I should use instead
07:07:14 <dmwit> quchen: Does "type Strict a = Strict !a" make sense to you?
07:07:46 <mm_freak> quchen: newtype constructors are always strict
07:08:35 <merijn> quchen: If I'm not completely wrong again "data Foo a = Foo !a" results in "Foo x" behaving like "seq x (Foo x)"
07:08:38 <quchen> dmwit: Hm. Not sure. It looks odd, I know you'll tell me it's wrong, but I wouldn't be able to tell you why exactly.
07:08:38 <dmwit> enthropy: Perhaps you could find the package on new-hackage and browse what other packages the last uploader has uploaded.
07:08:56 <shachaf> merijn: Yes.
07:08:58 <merijn> \o/
07:09:02 <shachaf> quchen: "!a" is not a thing.
07:09:08 <supki> enthropy: looks like haddocks point to failure package
07:09:10 <dmwit> quchen: Well, what would you expect to be the effect of this declaration?
07:09:17 <shachaf> Also, type synonyms can't be recursive.
07:09:18 <supki> mm_freak: yeah, that doesn't seem useful
07:09:48 <enthropy> supki: thanks
07:10:02 <dmwit> ?where revdeps
07:10:02 <lambdabot> http://packdeps.haskellers.com/reverse
07:10:28 <quchen> dmwit: The naive answer is of course "make a strict a", in the sense that "a" is always in WHNF.
07:10:35 <quchen> I'll go with that for the lack of something better.
07:10:52 <dmwit> quchen: What change should be made to the source of your program to make that happen?
07:11:13 <shachaf> Every value is strict.
07:11:14 <quchen> data.
07:11:57 <circle> I'm trying to follow along in my book, and I typed in their program and tested it and it didn't work
07:11:57 <circle> http://pastebin.com/vAHxXJ1U
07:11:58 <dmwit> quchen: For example, suppose I write "foo :: Strict Int; foo = 3". How should foo be rewritten by the compiler?
07:12:00 <circle> there's the code
07:12:02 <mauke> The paste vAHxXJ1U has been copied to http://hpaste.org/88293
07:12:40 <shachaf> circle: "f x y" means "(f x) y"
07:12:43 <mauke> circle: nat2int only takes one argument
07:12:51 <dmwit> circle: Perhaps you meant "nat2int (Succ Zero)".
07:12:58 <shachaf> mauke: How unusual.
07:13:02 <circle> there you go!
07:13:03 <circle> thanks
07:13:04 <circle> haha
07:13:19 <quchen> dmwit: Rewritten? "foo" is a pointer to a memory call containing "3".
07:13:42 <quchen> s/call/cell/
07:13:52 <dmwit> quchen: Here's another way to ask this question. What should be different about "foo" and "bar" in "foo :: Strict Int; foo = 3; bar :: Int; bar = 3".
07:14:00 <dmwit> s/\.$/?/
07:14:35 <quchen> Nothing? :s
07:14:43 <dmwit> Right.
07:14:50 <dmwit> So "Strict Int" doesn't make sense.
07:14:54 <dmwit> Tada! You understand now. =)
07:15:00 <quchen> You wish! :P
07:15:40 <shachaf> There is still fairy dust here, whether denotational or operational.
07:16:17 <dmwit> quchen: Okay, perhaps you at least understand why "type Strict a = !a" doesn't make sense. Have we gotten that far yet?
07:17:26 <ion> foo = let x = 3 in x `seq` x? Whenever someone wants to get x evaluated, make sure x is evaluated first.
07:17:28 <dmwit> shachaf: There's always fairy dust. The only question is how deep you have to dig to find it.
07:17:48 <ion> s/first/too/
07:18:04 <shachaf> @quote SaulGorn
07:18:04 <lambdabot> SaulGorn says: A formalist is one who cannot understand a theory unless it is meaningless.
07:18:35 <dmwit> quchen: Perhaps it would help if we explain what the ! in "data Foo = Foo Char !Int" means.
07:18:46 <quchen> dmwit: I was about to write about that. :-)
07:18:54 <merijn> I just wrote that, though
07:18:54 <akamaus> hi. I've implemented a simple thread pool. http://hpaste.org/88294. Unfortunately, I'm having troubles with getting the results out of it. I want to return a lazy stream of results for later consuming, but if I add unsafePerformIO to line 24 I get thread infinitely blocked on MVar error. Any ideas?
07:19:07 <dmwit> quchen: Okay. Soo Foo is a function, right? And Foo 'a' is, too.
07:19:16 <quchen> Maybe I'm wrong about how Bang...things are interpreted in types. (I should have given this some thought earlier.) Does "data Foo a = Foo !a" mean that "when a function encounters Foo, it adds a 'seq (what Foo contains)'"?
07:19:19 <merijn> 15:08 < merijn> quchen: If I'm not completely wrong again "data Foo a = Foo !a" results in "Foo x" behaving like "seq x (Foo x)"
07:19:28 <dmwit> quchen: This is fortunate, because functions can be either lazy or strict, so it makes sense to differentiate.
07:19:48 <dmwit> quchen: Yes, that's exactly right. "Foo x" gets translated to "x `seq` Foo x" by the compiler.
07:19:49 <merijn> According to shachaf I was indeed not completely wrong :p
07:20:15 <dmwit> quchen: or "Foo $! x" if that's your cup of tea =)
07:20:17 <shachaf> quchen: Not "when a function". It specifically only changes the constructor, Foo.
07:20:44 <shachaf> merijn: Well, you're shadowing Foo here. Foo x = seq x (OldFoo x)
07:20:50 <quchen> merijn: Oh, I didn't see that line.
07:21:05 <quchen> merijn: It looks what I tried to say above ("Maybe I'm wrong ...").
07:21:06 <Sculptor> yo
07:21:27 <dmwit> quchen: This is why several people have said above that the thing you're missing is that data can't be strict; only functions can.
07:21:40 <merijn> Verify my correctness for the future: "seq x y" means that "if neither x nor y are bottom, then forcing "seq x y" forces both x and y"
07:21:51 <quchen> dmwit: Oh, so *that* is what they meant.
07:22:11 <merijn> (in some indeterminate order)
07:22:19 <dmwit> quchen: So in the declaration "data Foo = Foo !Int", what this really means is that the function "Foo" is made strict.
07:22:21 <quchen> So I can see "Foo !a" as a rewrite rule: "\x -> Foo x" ==> "\x -> x `seq` Foo x"?
07:22:42 <dmwit> quchen: Or even more simply, "Foo" ==> "(Foo $!)".
07:22:43 <shachaf> merijn: That's not a definition, but that's the effect, yes.
07:23:03 <quchen> dmwit: Wonderful! First success in an hour.
07:23:10 <mm_freak> supki: what are you trying to do?
07:23:11 <shachaf> It's not really a rewrite rule. Well, not in the usual sense.
07:23:31 <quchen> shachaf: Yes, I should have added a disclaimer, I know.
07:23:59 <dmwit> shachaf: Yes, I'm sure both quchen and I appreciate that.
07:23:59 <dmwit> Sometimes being fuzzy is good for the soul.
07:24:16 <dmwit> quchen: Okay. Now let's talk a bit more.
07:24:35 <dmwit> quchen: In "data Foo = Foo Int", to begin with "Foo" is lazy because it introduces an extra normal form, namely "Foo undefined".
07:24:47 <quchen> Yes.
07:24:54 <quchen> Aaaah.
07:25:00 <dmwit> quchen: However, in "newtype Foo = Foo Int", the internal representation is still "Int", so "Foo undefined" and "undefined" are represented the same way -- there is no new extra normal form.
07:25:23 <quchen> So there is no "Foo :: a -> Foo a" function at runtime that can be made strict.
07:25:32 <dmwit> quchen: ...that is to say, "Foo" is already strict, hence "Foo" and "Foo $!" are the same, hence "newtype Foo = Foo !Int" is pointless.
07:26:02 <dmwit> There is a function at runtime, but it is *already* strict. So there's no need to make it strict.
07:26:24 <dmwit> (Whether that function gets erased at compile time is an implementation detail.)
07:26:41 <dmwit> (Similar to asking whether "id" is erased at compile time or not. Sometimes yes, sometimes no.)
07:27:15 <quchen> Ah, I see. I always pictured "newtype" as "can be removed", but it's a little more.
07:27:43 <dmwit> ?quote newtype.*figment
07:27:43 <lambdabot> No quotes match. :(
07:28:23 <shachaf> sorrymwit
07:28:55 <dmwit> I forgichaf
07:29:22 <quchen> In other words, (exactly) because "data Foo a = Foo a" introduces a new value (namely 'Foo bot'), it is non-strict in a?
07:29:32 <dmwit> yes
07:29:45 <dmwit> "f is strict" means "f undefined = undefined", nothing more or less
07:29:47 <exicer> Is there a built in data structure appropriate for representing a graph ?
07:29:54 <dmwit> ?hackage fgl
07:29:54 <lambdabot> http://hackage.haskell.org/package/fgl
07:30:32 <quchen> dmwit: I should write that down. (And while I'm at it I should look up what else laziness is.)
07:31:39 <dmwit> I'm not sure there's solid agreement on what laziness is.
07:33:12 <quchen> dmwit: In any case, thanks for finding out how to teach me this in 15 minutes. I was on the edge of giving up before.
07:33:32 <dmwit> \o/
07:34:07 <quchen> dmwit: The issues is 2 hours old. Not funny. ;-(
07:34:56 <piezo> hi, I have a dumb question :
07:35:02 <piezo> I spawn a pool of threads performing jobs fetched from a Chan
07:35:07 <dmwit> Don't worry, we've got tons of dumb answers!
07:35:07 <piezo> I want to end them simultaneously when they are all waiting on readChan
07:35:26 <hseg> Doing a bit of list processing. First, why aren't more functions from http://hackage.haskell.org/packages/archive/MissingH/0.18.6/doc/html/Data-List-Utils.html exported from Data.List?
07:35:37 <piezo> because jobs evaluation can push new jobs
07:35:38 <circle> is \/ "or"?
07:35:41 <circle> or is it "and"
07:35:42 <circle> always forget
07:35:53 <shachaf> /\ looks like A. It's And.
07:35:59 <circle> hmm, that'll help
07:36:17 <quchen> circle: \/ is a bucket. It collects good things and leaves out the bad ones. :-)
07:36:24 <hseg> Second, why are the default versions of drop,take,split,... the ones that take Int?
07:36:27 <circle> lol
07:37:14 <hseg> Wouldn't it be more friendly to have the more total function be the default, with the optimized, hand-crafted version available for those that need speed?
07:37:39 <dmwit> piezo: I think you should get an exception if every reference to a Chan is from a thread waiting on the same end of the Chan.
07:37:40 <shachaf> "more total"?
07:38:06 <hseg> Defined for more inputs.
07:38:14 <hseg> A made-up term, sorry.
07:38:22 <quchen> hseg: MissingH isn't part of Base, Data.List is. Therefore, none of its functions are exported from Data.List. (MissingH is an ordinary library by a user.)
07:38:49 <applicative_> hseg: knows that, he wants to know why such functions arent defined in Data.List
07:38:49 <piezo> dmwit: oh, I will try that
07:39:10 <applicative_> hseg knows that, rather
07:39:32 <applicative_> which MissingH functions are you linking are so great hseg ?
07:39:42 <applicative_> thinking
07:39:48 <piezo> so far my tests used a lot of MVars so I missed the case
07:39:48 <hseg> Especially considering that stuff like split, join, replace are commonplace in other languages. Not that it's hard to define them, but it's annoying.
07:39:50 <applicative_> man I need a typist
07:40:15 * fizbin keeps trying to improve his typing. He keeps failing
07:40:28 <dmwit> hseg: split is done better by the split package; join is done by intercalate
07:41:08 <applicative_> hseg: I was going to say, maybe Data.List.Split is what you want.
07:41:26 <applicative_> hseg: it is in the Haskell Platform, or the upcoming one
07:41:42 <hseg> Ha. "Once upon a time the standard Data.List module held no function for splitting a list into parts according to a delimiter. Many a brave lambda-knight strove to add such a function, but their striving was in vain, for Lo, the Supreme Council fell to bickering amongst themselves what was to be the essential nature of the One True Function which could cleave a list in twain (or thrain, or any required number of parts)." :-D
07:41:51 <hseg> Thanks.
07:43:40 <supki> mm_freak: that would be long story =)
07:43:53 <mm_freak> supki: i thought so =)
07:44:27 <hseg> Anyway, what about making foo = genericFoo, and have optimizedFoo = the current version of foo?
07:44:55 <shachaf> genericLength is a very bad choice for length.
07:45:12 <hseg> Wouldn't it be more useful, as the function would be defined over more values, all of which make sense for the function?
07:46:01 * applicative_ is forever trying to find the element at index 2 ^ 30000  in his lists
07:46:02 <shachaf> No, it would be less useful, because it would stack-overflow rather than giving a length.
07:46:06 <fizbin> I don't suppose there's a package in haskell that handles boring real-world concerns like time zone conversions taking into account daylight savings time rules?
07:46:11 <shachaf> @src genericLength
07:46:11 <lambdabot> genericLength []    = 0
07:46:11 <lambdabot> genericLength (_:l) = 1 + genericLength l
07:46:18 <supki> mm_freak: in few words, I have Wire e m () (Maybe a), that generates "events" and Wire e m (Maybe a) (Maybe a) that does some IO with them and passes them through. Actually it would be enough to have Wire e m a a (I do nothing with Nothing) and lift it somehow, but without lifting I don't have nice composition with (.)
07:46:54 <mm_freak> supki: any reason you use event signals instead of netwire events?
07:47:12 <hseg> It's just that having the parameters/return types of a function be bounded seems wrong to me...
07:47:53 <applicative_> > genericIndex [1..] (2 ^ 64 ::Integer)
07:48:08 <lambdabot>   thread killed
07:49:22 <hseg> Point taken. We're working on finite, non-ideal Turing machines, not the abstract, I-don't-care-about-efficiency Turing machihnes.
07:50:05 <geekosaur> of course, indexing a list is kinda bad anyway
07:50:53 <klrr> why do i get this type error? http://hpaste.org/88295
07:51:14 <hseg> geekosaur: Because of the repeated O(n) complexity?
07:51:21 <armlesshobo> klrr: the return types dont' match
07:51:23 <armlesshobo> don't*
07:51:29 <klrr> armlesshobo: how so?
07:51:39 <ski> circle : `∨' is also similar to `∪', while `∧' is similar to `∩'
07:51:46 <geekosaur> hseg: more or less, yes. indexing makes sense for vectors, not so much for singly linked lists
07:51:59 <armlesshobo> you're returning a type of IOErrorOr a0
07:52:00 <Botje> klrr: str :: String, why are you doing str >>= ... ?
07:52:03 <circle> ski: so? :)
07:52:06 <hseg> Right. The pointer-chasing problem, right?
07:52:07 <circle> ski: not seeing the link
07:52:29 <geekosaur> yes, aided and abetted by having to chase through thunks
07:52:38 <hseg> For the same reason, repeatedly descending a tree would be inefficient, which is why we have zippers?
07:52:40 <scooty-puff> i am having a lot of trouble with segmentation faults - the code is straightforward and given here:
07:52:43 <geekosaur> see String vs. Text/ByteString
07:52:45 <ski> circle : as an aid for recalling which is which of `∨' and `∧'
07:52:47 <scooty-puff> http://hpaste.org/88297
07:52:50 <klrr> armlesshobo: i used "(liftIO $ readFile file) >>= liftErrorOr . readScript" before and it worked but now it doesnt :x
07:52:55 <klrr> Botje: sry will change that
07:53:01 <klrr> Botje: but i still get same
07:53:03 <klrr> error
07:53:32 <ski> circle : assuming you already know `∪' is for union and `∩' for intersection, and that you know how those are related to disjunction and conjunction
07:53:59 <circle> ski: I didn't make the link to union
07:54:02 <circle> ski: :)
07:54:05 <armlesshobo> why do you need to do liftIO?
07:54:12 <armlesshobo> @type readFile
07:54:13 <lambdabot> FilePath -> IO String
07:54:15 * hackagebot json-fu 0.1.0 - Generic JSON serialization / deserialization  http://hackage.haskell.org/package/json-fu-0.1.0 (SimonHengel)
07:54:24 <klrr> armlesshobo: to lift it into a monad i guess,
07:54:54 <hseg> How do I add a typeclass to the export list of a module?
07:55:01 <Botje> klrr: you fixed it? how?
07:55:08 <piezo> dmwit: apparently this doesn't throw any exception: newChan >>= replicateM 10 . forkIO . readChan
07:55:11 <hseg> I'm defining the typeclass in module A, and the instances in module B
07:55:29 <Botje> isn't it always imported
07:55:30 <Botje> ?
07:55:39 <Botje> (exported)
07:55:58 <hseg> I guess, but apparently GHCi doesn't like it....
07:56:13 <klrr> Botje: i havent fixed it still same error
07:56:30 <Botje> klrr: the error is caused by you doing str >>= ...
07:56:36 <hseg> No. You need to export it explicitly...
07:56:40 <Botje> >>= requires the monads on both sides to be the same.
07:56:43 <klrr> Botje: well i fixed what you said doiing "exp <- liftErrorOr $ readExpr str
07:56:44 <klrr> "
07:57:03 <scooty-puff> does anyone know if hackage's "primitive" requires optimizations to be disabled for proper functioning?
07:57:05 <Botje> klrr: but your error is on str >>= liftErrorOr . readScript
07:57:25 <klrr> Botje: okey >>= is unsafe i guess
07:57:32 <armlesshobo> really, there is no need for str >>= ..
07:57:34 <klrr> kidding sry!
07:57:35 <hseg> Success! You not only need to export the typeclass, but also the functions it defines.
07:57:40 <armlesshobo> @type String
07:57:41 <lambdabot> Not in scope: data constructor `String'
07:57:44 <armlesshobo> oops
07:57:57 <armlesshobo> String is really [Char]
07:58:02 <Botje> klrr: just think about it, >>= requires both sides to be in the same monad
07:58:08 <geekosaur> @src String
07:58:08 <lambdabot> type String = [Char]
07:58:14 <armlesshobo> that
07:58:16 <armlesshobo> :P
07:58:21 <Botje> if the left side is String (= [Char]), then the right hand side must be in the [] monad as well
07:58:43 <armlesshobo> Botje: it doesn't have to be the same. it just needs to be a monad
07:58:49 <armlesshobo> @type (>>=)
07:58:50 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:59:07 <quchen> klrr: Your "str" has type String, which is [Char], a list of Char. Therefore, "str >>=" says "the >>= is a list monad operator". (str >>=) then has type (Char -> [t0]) -> [t0], and "liftErrorOr . readScript" does not match that type.
07:59:45 <quchen> s/match/does not fit in/
08:00:25 <hseg> How do I make String the instance of a typeclass? GHC mutters something incomprehensible about FlexibleInstances, which I don't understand well enough to like
08:01:00 <shachaf> You can't, not in Haskell 98.
08:01:07 <shachaf> String = [Char]
08:01:25 <hseg> Right. I get similar errors when trying for [Foo]
08:02:35 <geekosaur> hseg: this is one of the smaller annoyances of standard Haskell. FlexibleInstances is not a particularly evil extension and is well worth consideration in this case
08:02:54 <monochrom> FlexibleInstances is an extension for allowing that.
08:03:33 <geekosaur> (standard Haskell has a somewhat absurdly restrictive notion of what an instance may look like. FlexibleInstances switches it for a more sensible notion.)
08:03:42 <monochrom> but beware of ambiguity. "instance C [Char]" and "instance C [a]" co-existing is ambiguous.
08:03:48 <quchen> hseg: If you make a type constructor an instance of something, all variables used must be type variables. For example, you can make "Foo" an instance of a class, because all its (zero) arguments are type variables. Similarly, you can make "Foo a" an instance of a typeclass, because "a" is a type variable. "Foo Int" however does not work, because Foo is not applied to a type variable (but a type).
08:03:56 <applicative_> you make [a] an instance
08:04:17 <hseg> OK. What happens if both [Foo] and [a] are instances?
08:04:38 <monochrom> then it is rejected. you can only have one.
08:04:59 <applicative_> or you can turn on OverlappingInstances ...
08:05:00 <monochrom> unless you turn on another extension, OverlappingInstances.
08:05:04 <geekosaur> (without an additional extension which should cause you to stop and think)
08:05:18 <monochrom> notice the rabbit hole. it's rabbit holes all the way down.
08:05:19 <applicative_> but then you and your children will have no place in the world to come
08:05:35 <monochrom> until you hit turtles...
08:05:46 <shanse> c/,,\
08:06:03 <geekosaur> but even so, Overlapping can be useful sometimes. it's when GHC suggests IncoherentInstances that you really need to stop and think about what you're trying to do; the name means just what it ays
08:06:05 * monochrom ♥ ω^3
08:06:05 <geekosaur> *says
08:06:50 <monochrom> wait, ω×3
08:07:12 <hseg> Of course, keep going on long enough and you'll reach CthulhuInstances. If you activate that, we lose all mercy for you.
08:07:30 <geekosaur> Incoherent's pretty much that
08:07:32 <fizbin> Suppose you want to just make a certain instance method behave slightly differently on one type for efficiency reasons. Aren't there ways to do that just for ghc with some sort of replacement rule?
08:07:44 <monochrom> we haven't mentioned UndecidableInstances
08:08:14 <monochrom> how about writing GHC core by hand :)
08:08:39 <fizbin> That is, the instance of MyClass for [Foo] means the same as the instance for [a], but takes a few shortcuts for efficiency.
08:09:12 <monochrom> then FlexibleInstances and OverlappingInstances
08:09:25 <fizbin> Or do you in that case need OverlappingInstances?
08:09:52 <quicksilver> fizbin: you simply can't do that.
08:09:58 * fizbin should go read up on ghc replacement rules, as he currently knows little about them.
08:10:10 <quicksilver> polymorphic code can be compiled with a type signature for [a]
08:10:11 <monochrom> and in the doc swear to God what you just said about them meaning the same
08:10:30 <quicksilver> and if there is an instance for [a], it will just use that instance
08:10:33 <hseg> OK, gotta go. Thanks guys!
08:10:35 <quicksilver> it will never look for more specific ones.
08:10:40 <applicative_> the one that is surprisingly awesome but scarily named is UndecidableInstances
08:13:02 <supki> mm_freak: does not knowing about "netwire events" count as reason?
08:13:50 * applicative_ suddenly remembers the curse laid upon Spinoza as apt for InstanceExtensionAbuse
08:13:51 <mm_freak> supki: signal inhibition mainly
08:14:16 <applicative_> cursed be he by day, cursed be he by night; cursed be he when he comes in , cursed be he when he goes out; etc
08:14:27 <mm_freak> supki: every wire is a netwire event, and an event counts as not occurred, if the wire inhibited
08:14:54 <mm_freak> supki: and then you have the following semantics:  if either w1 or w2 happened, then w1 <|> w2 happened
08:14:55 <supki> mm_freak: ah, Nothing is actually valid event, not the absense of it
08:15:05 <mm_freak> if both w1 and w2 happened, then w1 . w2 happened
08:15:15 <mm_freak> so (<|>) acts like "or" and (.) acts like "and"
08:15:23 <mm_freak> ah, i see
08:16:09 <mm_freak> supki: in that case remember that Wire is a family of applicative functors
08:16:42 <mm_freak> given f : Maybe a -> Maybe a you can do this:  pure f <*> w
08:16:52 <mm_freak> which of course is equivalent to f <$> w
08:17:21 <mm_freak> and since Maybe is itself a functor you know how to turn an a -> a into a Maybe a -> Maybe a
08:17:40 <mm_freak> fmap f <$> w
08:18:57 <ski>   (f <$>) <$> w  -- aka
08:19:08 <mm_freak> that's ugly =)
08:19:16 * hackagebot multiarg 0.16.0.0 - Combinators to build command line parsers  http://hackage.haskell.org/package/multiarg-0.16.0.0 (OmariNorman)
08:19:17 <armlesshobo> lolo
08:19:18 <armlesshobo> l
08:19:58 <ski>   (fmap . fmap) f w  -- and this ?
08:20:19 <mm_freak> also ugly =)
08:20:24 <applicative_> @pl g f w = (fmap . fmap) f w
08:20:24 <lambdabot> g = fmap . fmap
08:20:27 <supki> mm_freak: well, if I had f :: a -> a I could just do arr f and arr (fmap f) to get Wire e m a a and Wire e m (f a) (f a). I have something like (a -> IO a) really
08:20:33 <applicative_> :(
08:21:00 <mm_freak> supki: what's the relationship between 'm' and IO?
08:23:02 <scooty-puff> ok, found out the problem - newByteArray# is the size in bytes, while write<...>Array#, read<...>Array# index by the size of what is read (not in bytes)
08:23:07 <supki> mm_freak: hmm, let it be (m ~ IO)
08:23:49 <applicative_> > let instantiate 'm' = "IO" ; instantiate x = [x] in concatMap instantiate "Wire e m (f a) (f a)"
08:23:50 <lambdabot>   "Wire e IO (f a) (f a)"
08:26:00 <mm_freak> supki: in that case see mkFixM or .Prefab.Effect
08:26:49 <mm_freak> supki: the execute* wires are exception-aware
08:29:03 <klrr> is there a function that let me run something without letting it return anything?
08:29:29 <dmwit> piezo: Hm, you're right; it only seems to trigger here if the main thread also tries to readChan.
08:29:36 <dmwit> I wonder what the real promise is.
08:30:00 <mm_freak> klrr: "without returning anything"?
08:30:27 <mm_freak> there is (() <$), but i doubt that's what you're asking for
08:30:28 <klrr> mm_freak: yes, i wanna run a function simply to modify the state, but not return its actually value since that conflicts with my functions type
08:30:34 <Eduard_Munteanu> klrr: ... -> ()
08:30:41 <dmwit> piezo: But e.g. try "main = newChan >>= readChan" to see the exception. Feel free to throw in some forks if you want.
08:30:43 <klrr> Eduard_Munteanu: how you mean?
08:30:46 <merijn> klrr: Do you have something in the State/IO monad?
08:30:52 <mm_freak> klrr: so you have a state computation…  in what monad?
08:30:59 <klrr> merijn: i use IORef
08:31:02 <sipa> :t (<$)
08:31:03 <lambdabot> Functor f => a -> f b -> f a
08:31:07 <merijn> klrr: void
08:31:08 <Eduard_Munteanu> :t modifyIORef
08:31:08 <merijn> :t void
08:31:09 <lambdabot>     Not in scope: `modifyIORef'
08:31:10 <lambdabot>     Perhaps you meant `modifySTRef' (imported from Data.STRef)
08:31:10 <lambdabot> Functor f => f a -> f ()
08:31:14 <Eduard_Munteanu> @hoogle modifyIORef
08:31:15 <lambdabot> Data.IORef modifyIORef :: IORef a -> (a -> a) -> IO ()
08:31:15 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
08:31:16 <merijn> Or modifyIORef_
08:31:19 <klrr> merijn: thanks
08:31:28 <merijn> oh, modify is already IO ()
08:31:33 <mm_freak> klrr: "without returning anything" does not make sense in haskell
08:31:51 <mm_freak> but you can change the return type of a monadic action using fmap/void/(<$)
08:32:25 <Eduard_Munteanu> Yeah, use void to simply ignore results
08:32:34 <Eduard_Munteanu> :t void get
08:32:36 <lambdabot> (Functor f, MonadState a f) => f ()
08:32:39 <klrr> mm_freak: it does
08:32:41 <klrr> :D
08:32:42 <Eduard_Munteanu> (well, that's useless)
08:33:02 <mm_freak> klrr: ?
08:33:31 <klrr> may i ask, is there a way to check if a string/lists first few elements is something and then retriving the rest in a case expressions?
08:33:34 <klrr> experssion*
08:33:53 <Clint> what?
08:33:54 <mm_freak> klrr: case str of a:b:c:d:rest ->
08:34:00 <klrr> thankks!
08:34:17 * hackagebot black-jewel 0.0.0.1 - The pirate bay client.  http://hackage.haskell.org/package/black-jewel-0.0.0.1 (DmitryBogatov)
08:34:45 <mm_freak> you may find span/break more useful in certain cases
08:34:58 <mm_freak> case span isLetter str of (letters, rest) ->
08:35:04 <chrisdotcode_> hello everyone :)
08:35:10 <Eduard_Munteanu> chrisdotcode_: hi
08:35:14 <exFalso> Hi, i have the following idea: i'd like to create a library for a ghci-compatible "shell" that can "attach" to a running process using a pipe and give commands to it. When initialising a handle is created for the pipe and i was wondering whether it is safe to use unsafePerformIO to lazily do this?
08:35:23 <chrisdotcode_> hi, Eduard_Munteanu
08:35:59 <circle> is haskell good for web dev?
08:36:03 <mm_freak> circle: yes
08:36:10 <circle> I shall use it, then.
08:36:13 <mm_freak> see happstack/snap/yesod
08:36:22 <circle> since I've started to hate python after getting fimilar with haskell
08:36:30 <mm_freak> apparently people also like scotty for very simple web apps
08:36:38 <exFalso> circle: we've all been there
08:36:42 <supki> mm_freak: hmm, execute* looks interesting, thanks
08:37:10 <mm_freak> supki: my initial response is that having IO at the bottom of your monad stack is probably a bad idea to begin with
08:37:26 <mm_freak> but yes, since you already have IO there, you can just as well use 'execute' =)
08:37:46 * ski thinks `void' ought to be renamed to `ignore' ..
08:37:59 <supki> mm_freak: what do you suggest instead?
08:38:02 <mm_freak> ski: or 'unit' or …
08:38:10 <supki> mm_freak: I mean, I get "events" from "IO" anyway
08:38:18 <mm_freak> ski: there isn't really a good name for such an arbitrary function
08:38:38 <mm_freak> supki: what about Reader and/or Writer?
08:38:48 * supki thinks void should not exist
08:38:50 <mm_freak> your main loop can fetch the events
08:38:58 <supki> hmm
08:39:01 * ski isn't really happy with `unit' either
08:39:29 <exFalso> i'll rephrase my question: i'd like to initialise a file handle and use it throughout my program without having to refer to it explicitly in ghci. Is it safe to to create an (IORef Handle) using unsafePerformIO for this?
08:39:46 <mm_freak> exFalso: no
08:39:51 <Hafydd> "Is it safe to... using unsafe...?""
08:39:57 <ski> @type Data.List.stripPrefix  -- klrr
08:39:59 <lambdabot> Eq a => [a] -> [a] -> Maybe [a]
08:40:16 <mm_freak> exFalso: but you can do this in GHCi:  "h <- openStuff"
08:40:28 <exFalso> mm_freak: why not? will it evaluate the io action at will?
08:40:38 <mm_freak> exFalso: in code you would use "withStuff" instead most of the time
08:40:39 <exFalso> i know, but thats what i'm trying to avoid
08:40:53 <Eduard_Munteanu> exFalso: where would you actually use it, in IO code? Because if you're using it outside IO there's going to be more trouble ahead.
08:40:54 <merijn> Hafydd: unsafePerformIO can be safe, I frequently use it with IORef/MVars
08:41:12 <mm_freak> exFalso: because global state is itself unsafe
08:41:14 <Eduard_Munteanu> Yeah, I don't think the global handle is the problem per se.
08:41:23 <mm_freak> exFalso: that?
08:41:31 <merijn> Hafydd: The notion of having a handle in there probably won't be safe, though
08:41:32 <exFalso> the whole point of this library would be hidden global state
08:41:47 <ski> exFalso : are you fine with the initialization possibly happening several times ?
08:42:00 <mm_freak> exFalso: consider this GHCi session:  "putStrLn <- fmap hPutStrLn (openFile fp m)"
08:42:07 <merijn> mm_freak: "because global state is itself unsafe" <- that's an overexaggeration...
08:42:14 <mm_freak> then you can use putStrLn as you're used to
08:42:26 <mm_freak> the same you can do for your own handle
08:42:47 <mm_freak> merijn: my assertion is that you don't need it
08:43:04 <ski> @wiki Global variables
08:43:04 <lambdabot> http://www.haskell.org/haskellwiki/Global_variables
08:43:04 <ski> @wiki Top level mutable state
08:43:05 <lambdabot> http://www.haskell.org/haskellwiki/Top_level_mutable_state
08:43:15 <ski> exFalso : see those ^
08:43:15 <mm_freak> one thing people often forget about monadic I/O is that I/O actions are first class
08:43:41 <merijn> mm_freak: Sure, but sometimes it can be a lot cleaner, though
08:43:51 <exFalso> ski: i'll check those out, thanks
08:44:05 <mm_freak> merijn: really?  i've yet to encounter such a case after about five years of haskell
08:44:28 <ski> exFalso : and also what mm_freak says
08:45:19 <mm_freak> merijn: really?  i've yet to encounter such a case after about five years of haskell
08:45:33 <merijn> i.e. one example is my code that wraps dealing with threads where I have a top level TVar which increments on every spawn and a "waitUntilExit" that blocks until the TVar hits zero. I could have a "context" data structure returned and pass that along on every fork and to block, but that is a lot of hassle to thread that object around in the using code, whereas the global TVar is a matter of just "fork" and "wait" in the using code
08:46:03 <merijn> You will never convince me that threading a useless context object through my code is "cleaner" than just a nice simple top level TVar
08:46:15 <merijn> It's a lot of hassle for no gain
08:46:28 <mm_freak> merijn: how about composability?  your code is effectively noncomposable
08:46:35 <mm_freak> and it's not a lot of hassle
08:46:37 <mm_freak> not in haskell
08:46:44 <mm_freak> i do it all the time
08:47:06 <merijn> Not composable in what sense?
08:47:22 <exFalso> ski: ok there was nothing new there... i';; try to explain what i'm trying to do in more detail
08:47:46 <mm_freak> merijn: in "x >> y", y needs to be aware of what x did to the TVar
08:47:50 <merijn> Why?
08:48:23 <mm_freak> because y may depend on it?
08:48:27 <merijn> It can't
08:48:45 <mm_freak> what do you mean?  x can surely change the TVar's contents
08:49:10 <merijn> Sure, but I don't expose the TVar outside the module, I only expose "fork" and "waitUntilEverythingsDone"
08:49:45 <mm_freak> merijn: did you remember to 'mask' properly?
08:49:50 <merijn> Yes
08:50:10 <merijn> Don't ask, I have obscene amounts of masking in that code to get some other stuff working right
08:50:29 <mm_freak> merijn: and i prefer 'bracket'
08:50:33 <mm_freak> it's a clean and easy approach
08:51:01 <mm_freak> withThreadManager = bracket init done where …
08:51:25 <exFalso> i'd like to do the following: load an "interface" module in ghci that will act as an interface to a running process. This module would contain IO actions that will interact with the running process. This would be done with a pipe(s) that the process and ghci reads/writes. I would like to avoid having to refer to this handle in ghci all the time, but i would like to initialise it only once. Is there a way to do this? I cannot create my own monad stack as i
08:51:30 <mm_freak> and instead of passing the TVar you pass the fork action to the continuation
08:51:34 <mm_freak> can't possibly get any cleaner
08:51:46 <mm_freak> and that's properly composable in that you can have many interleaved thread managers
08:52:26 <geekosaur> exFalso, you got chopped off at irc's 512 byte limit " my own monad stack as i"
08:52:41 <exFalso> 'd like to be able to use all functions in ghci
08:52:44 <merijn> s/irc's/freenode's
08:52:48 <exFalso> geekosaur: thanks
08:52:55 <mm_freak> merijn: IRC's
08:53:03 <mm_freak> the 512 byte limit is standard
08:53:09 <geekosaur> merijn, freenode can't bend that limit, sadly
08:53:11 <merijn> The IRC protocol doesn't have a message limit, afaik?
08:53:15 <geekosaur> yes, it does
08:53:17 <merijn> hmm, might be wrong
08:53:18 <geekosaur> 512 bytes
08:53:30 <Hafydd> It does, but lots of IRCDs disobey the protocol.
08:53:38 <mm_freak> merijn: 511 bytes if you follow the standard closely, and 510 in most cases
08:54:10 <exFalso> so i think its clear that this needs global state, i'm just not sure how to do this safely
08:54:12 <mm_freak> Hafydd: interestingly they do obey the line limit
08:54:32 <mm_freak> exFalso: no, that's not clear to me…  i showed you above how to do it without global state
08:55:02 <geekosaur> the problem with disobeying the limit is you can crash some clients that way, which is why freenode obeys it
08:55:06 <Hafydd> mm_freak: I suppose it would be one the worse things to not obey, causing data corruption and buffer overflows and such.
08:55:14 <geekosaur> ^^
08:55:57 <mm_freak> probably "some clients" = "mirc users"
08:55:57 <mm_freak> =)
08:56:19 <Ankhers> I'm sure ERC would also die (emacs).
08:56:41 <mm_freak> although ERC would rather space-leak-die
08:57:14 <Ankhers> I'm unfamiliar with that...
08:57:24 <Fuuzetsu> ERC stronk
08:57:36 <exFalso> mm_freak: you showed me a cumbersome way to do it... again, i would like to only have IO actions that will interact with the running process, no passing around of Handles
08:57:47 <mm_freak> well, i've seen many text protocol implementations, where people would just do something akin to hGetLine
09:03:44 <yitz> exFalso: why do you feel it awkward to have a single paramater which specifies what you addressing with your commands? global state would be far more ugly and awkward.
09:05:29 <yitz> exFalso: you could have many different running threads, and many kinds of state that is shared between them in various ways. you can interact with them passing information into the various pieces of state.
09:05:49 <exFalso> yitz: because the whole point would be to hide the underlying mechanism of communicating with the running process
09:06:01 <yitz> exFalso: i didn't see what mm_freak told you, but i am quite confident that it was nice :)
09:06:03 <exFalso> i'd like a simple shell that i can open to my process
09:06:52 <exFalso> this could be done if i reimplemented ghci to use my monad stack instead of simple IO
09:07:21 <bartavelle> if anybody knows why my library takes forever to compute the haddocks, I'm interested. Does it require a full compilation ?
09:08:21 <yitz> exFalso: you mean that instead of simple shell that allows you to specify who you are talking to, you want a complicated one that assumes magical things happening in the background?
09:08:28 <fizruk> bartavelle: doesn't it only compile changed modules and dependent modules?
09:08:50 <exFalso> yitz: pretty much
09:08:54 <yitz> :)
09:09:46 <exFalso> lets say i have a server and i want to see stats or do some complicated action on the current state of it
09:10:03 <exFalso> what i'd like to do is just open ghci and issue commands to the server
09:10:31 <yitz> exFalso: well sure you could do that. define MVars or IORefs or STVars or whatever, and hard-code their names inside functions that you use to interact with them.
09:10:33 <bartavelle> fizruk, probably, but it seems noticeably slower than what I am used to, and I am not sure if it is related to some environmental change, bad memories, or just that it is supposed to be slow
09:10:54 <exFalso> right, and how do you create those IORefs?
09:11:39 <yitz> exFalso: you could set all that up in a "dot-ghci" initialization file. there's a trick that allows you to set up a shell command to run that initialization automatically at the beginning of your ghci session.
09:12:30 <yitz> exFalso: you probably want an MVar (right mm_freak?)
09:12:49 <fizruk> bartavelle: does "slower that what I am used to" mean it started to compile slow suddenly (and it was ok before)?
09:12:55 <exFalso> or TVar rather
09:13:03 <yitz> exFalso: ok
09:13:19 <bartavelle> it was always slow to compile, but it seems the haddocks are now taking twice the compile time
09:13:19 <exFalso> never heard of this .ghci thing, will check it out
09:13:57 <mm_freak> exFalso: i'd rather SSH to the server
09:14:32 <exFalso> mm_freak: by "server" i meant some daemon-like process doing stuff in the background
09:14:38 <mm_freak> exFalso: me too
09:14:45 <exFalso> :
09:14:46 <exFalso> :)
09:14:48 <yitz> exFalso: something like tv <- newTVar ...; proc <- forkIO ... tv ...; let sendMessage m = ... tv ... m; then if you say sendMessage m, it sends message m to your running process.
09:15:24 <yitz> exFalso: you could also use GNU screen or equivalent ;)
09:15:50 <ChongLi> tmux!
09:16:06 <yitz> right tmux, i had forgotten the name
09:16:34 <exFalso> yitz: yes, something like that, but instead of sendMessage i want to conveniently invoke commands straight from the ghci interpreter
09:16:44 <fizruk> bartavelle: I've just checked (cabal install) and (cabal configure; cabal haddock) after removing dist/
09:16:54 <yitz> exFalso: well sendMessage is invoking a command, isn't it?
09:17:18 <fizruk> bartavelle: haddock seems to take approximately twice as much as a simple install takes
09:17:43 <bartavelle> so it might be normal
09:17:46 <fizruk> bartavelle: my project is small enough though (~5 secs for install, ~10 sec for haddock)
09:17:47 <bartavelle> ok thanks for checking !
09:18:00 <bartavelle> mine takes tens of seconds
09:18:17 <fizruk> bartavelle: it should be normal, I think
09:18:36 <exFalso> yitz: i meant top level functions. So in my process i'd have (stats :: MyState Stats) that implements stats and my TH would generate a (stats' :: IO Stats) that connects to the process and invokes stats
09:19:19 <exFalso> so i can just say "stats'" in ghci and it would do all the connection-parsing hassle in the background
09:19:36 <applicative_> is my impression right that haddock takes longer and longer the more stuff you have indexed?
09:20:35 <bartavelle> applicative_, this makes sense
09:20:42 <fizruk> applicative_: that would be an expected behaviour, whouldn't it?
09:21:00 <yitz> fizruk: i think applicative_ meant a non-linear longer and longer
09:21:10 <applicative_> fizruk: yes, I just have a feeling it is sort
09:21:17 <applicative_> right like yitz says
09:21:33 <applicative_> there is an exponential or quadratic sort of feeling to it
09:23:43 <yitz> exFalso: that certainly could be set up manually on a per-application basis. you are thinking of a TH wrapper to automate? this is a common enough case that it would be worth automating?
09:24:01 <bitonic> yitz, exFalso: <http://hackage.haskell.org/package/safe-globals>
09:24:07 <exFalso> yitz: i think so, also i would enjoy doing it:)
09:24:08 <bitonic> well, exFalso already knows by now.
09:24:15 <exFalso> bitonic: yes, thanks
09:24:43 <yitz> exFalso: not everyone enjoys working in TH. but yes, i see.
09:24:45 <bitonic> it is safe to have a monomorphic top level IORef or similar
09:25:46 <Enigmagic> bitonic: if it's marked as NOINLINE
09:25:53 <exFalso> yitz: well i'll try to do it first with generic-metaprogramming magic
09:26:05 <exFalso> yitz: the "right way" ;_
09:26:06 <bitonic> Enigmagic: the usual unsafePerformIO caveats apply, yes.
09:26:07 <exFalso> ;)
09:26:16 <yitz> bitonic: it happens to be safe in the current implementation of ghc. but even with NOINLINE it is theoretically unsafe.
09:26:29 <yitz> bitonic: there have been proposals to add a new pragma for this.
09:26:45 <yitz> bitonic: many people are very uncomfortable with that idea.
09:27:18 <bitonic> yitz: well, unsafePerformIO’s semantics are quite poorly specified yes
09:27:41 <bitonic> so yeah I was clearly referring to this implementation, since there is no standard
09:27:54 <yitz> bitonic: before properly specifying the semantics of unsafePerformIO, we'd first have to properly specify the semantics of IO
09:28:19 <fizruk> had anyone have problems with installation of 'layers' package?
09:28:33 <bitonic> yitz: sure.  the current state of things doesn’t prevent unsafePerformIO to be used successfully ehe
09:28:50 <exFalso> yitz: in this case is the only problem with unsafePerformIO that it may execute the IO action several times (theoretically)?
09:29:13 <johnw> fizruk: it requires GHC 7.6
09:29:31 <yitz> exFalso: that's one of the main problems, yes.
09:29:32 <bitonic> exFalso: yeah
09:30:03 <exFalso> so the haskell runtime will garbage collect the previous allocated ioref right?
09:30:23 <exFalso> so all i have to do is make sure that the IO action has no non-read side effects
09:30:32 <oio> how could i find matches on a string ? like findMatches if (3 consecutive a's) print that else no print findMatches "bcshajsjfnAaanininniaaAijjijaaa" = AaaaaAaaa
09:30:51 <bitonic> exFalso: in the current state of things you’ll have one reference.  and it’ll never go out of scope (if you include the module...), so never garbage collected
09:31:26 <exFalso> bitonic: no, i mean that if you have globalRef = unsafePerformIO (newIORef Nothing)
09:31:42 <exFalso> and globalRef happens to be evaluated twice
09:31:44 <fizruk> johnw: that's a pity :(
09:31:56 <exFalso> will the first allocated IORef be gc'd
09:32:01 <fizruk> johnw: thanks though :)
09:32:09 <bitonic> exFalso: ‘first’?  what’s the second?
09:32:30 <yitz> oio: it depends. just that you could do easily using functions in Data.Text. For more complicated parsing, you would use a parsing library like parsec, attoparsec, etc.
09:32:31 <merijn> bitonic: Global scope can still be garbage collected!
09:32:46 <exFalso> well, theoretically the runtime can evaluate globalRef twice
09:32:48 <fizruk> yitz: Haskerl?
09:33:09 <bitonic> exFalso: well the point is that in the current state of things it won’t (if you use NOINLINE and all that)
09:33:25 <exFalso> i think this does not happen currently (which is why "safe-global" is "safe")
09:33:32 <merijn> exFalso: Also you need a {-# NOINLINE globalRef #-} pragma
09:33:34 <bitonic> exFalso: yes
09:34:17 <exFalso> ok, will try thatm thanks everyone
09:34:35 <oio> yitz: ok going to get a look at it
09:36:26 <yitz> oio: using Text instead of String is often a good idea. When you do that, it is helpful to use {# LANGUAGE OverloadedStrings #} at the top of your program file
09:36:38 <yitz> oio: and :set -XOverloadedStrings in GHCi
09:37:16 <yitz> oio: that allow using regular double-quoted string literals for Text instead of String.
09:37:35 <Fuuzetsu> (and ByteString)
09:37:47 <fizruk> any IsString instance?
09:38:41 <Fuuzetsu> >Class for string-like datastructures; used by the overloaded string extension (-foverloaded-strings in GHC).
09:38:43 <Fuuzetsu> so it would seem
09:38:46 <yitz> Fuuzetsu: that's less often the right thing to do. ByteString represents binary bytes. Text represents text. Sometimes you do need to us ByteString for text, but best to avoid that whenever possible.
09:39:20 <applicative_> oio people might give better advice if you said more about what you mean by matching and so on
09:39:20 * hackagebot moo 1.0 - Genetic algorithm library  http://hackage.haskell.org/package/moo-1.0 (SergeyAstanin)
09:39:25 <Fuuzetsu> Hey, I never said it was The Right Thing To Do™. Just thought I'd throw it up there for more complete information.
09:39:26 <johnw> fizruk: what do you want layers for?
09:39:46 <yitz> applicative_: yeah. sorry. i'll be quiet until oio says more. :)
09:40:14 <applicative_> oio: there regular expression libraries of course, for example, though haskellers tend to diss regexen a bit
09:40:54 <yitz> applicative_: hey we have nothing against *-semirings.
09:41:35 <applicative_> right, oio, I'm sure that we especially love regular expressions, properly understood ...
09:41:42 <oio> something like this
09:41:45 <monochrom> I like Kleene algebras
09:42:13 <mauke> I like regexes
09:42:18 <oio> import Text.Regex.Posix
09:42:26 <mauke> I don't like posix regexes
09:42:36 <oio> match xs = xs =~ "[^A-Z][A-Z]{3}[A-Z]{2}[^A-Z]"
09:42:53 <elliott> the haskell regex libraries have quite an awful API. so much overloading.
09:43:11 <mauke> oio: that looks wrong
09:43:16 <fizruk> johnw: experimenting, I'm good with monad transformers for now :)
09:43:34 <johnw> fizruk: are you familiar with monad-control and lifted-base and mmorph?
09:43:36 <mauke> "(?<![A-Z])[A-Z]{5}(?![A-Z])"
09:43:51 <johnw> the former two I use quite a bit
09:43:57 <johnw> mmorph can be quite handy sometimes too
09:45:49 <fizruk> johnw: yeah, I've seen mmorph
09:46:19 <fizruk> johnw: actually, I don't *need* layers, just wanted to try it out
09:46:26 <yitz> mauke: still, in simple cases i sometime don't bother with typing -E for sed.
09:47:10 <applicative_> hm, the frisby library doesn't build with recent base
09:47:40 <fizruk> johnw: although there was a time, when I needed something like hoist on monad transformers (switch a monad in the middle of the monad stack)
09:47:42 <applicative_> it has a pleasantly simple regex reader
09:47:47 <yitz> mauke: aren't extended regexes actually part of POSIX now?
09:48:05 * ski . o O ( irregexen )
09:48:56 <geekosaur> yitz, a little confusion, POSIX always had both BREs and EREs but did not require e.g. sed to support both for vendor compatibility reasons.
09:49:52 <yitz> geekosaur: i see. but also, hasn't the notion of "extended" expanded now to include most or all of perl 5 regexes, even in POSIX?
09:50:36 <geekosaur> POSIX sed still doens't do EREs, in fact
09:50:51 <chrisdotcode_> guys, is a predicate a function that returns true or false, or the actual expression? i.e.: "f x y = x < y" or "x < y"
09:51:34 <geekosaur> and no, POSIX EREs still don't do most perl extensions
09:51:37 <exFalso> chrisdotcode_: ehh "predicate" is a pretty overloaded term
09:51:48 <tommd> tibbe: Would you accept a patch adding "sendWithFlags" to network?
09:51:51 <chrisdotcode_> exFalso: so I'm both right and wrong? :-)
09:51:54 <ChongLi> chrisdotcode_: typically it's just a function
09:51:54 <tommd> (Issue 93)
09:52:09 <exFalso> chrisdotcode_: well f is a preficate in your case, its a binary predicate
09:52:21 <chrisdotcode_> ChongLi: but if I said, "the predicate x < y", would I also be right?
09:52:34 <exFalso> chrisdotcode_: x < y  is also a predicate, its a nullary predicate
09:52:40 <ChongLi> sure
09:52:49 <chrisdotcode_> huh
09:52:51 <chrisdotcode_> I see...
09:53:12 <ChongLi> but if you're actually referring to a predicate used with some higher order function (such as filter)
09:53:24 <applicative_> hm, frisby understands "(?<![A-Z])[A-Z]{5}(?![A-Z])" not bad
09:53:25 <ChongLi> then you need a specific type
09:53:30 <tibbe> tommd: probably, we should think about how to add options for other operations as well, so we follow a pattern when we add such functions
09:53:43 <ChongLi> typically (a -> Bool)
09:53:47 <tibbe> tommd: and think about how many extra functions we will have to add
09:54:03 <tibbe> tommd: but in principle we should allow precise control of the underlying sockets
09:54:06 <tommd> tibbe: Makes sense.
09:54:10 <chrisdotcode_> because I heard the condition in a list comphrension being referred to as a predicate.
09:54:11 <tibbe> tommd: gotta get off the shuttle, bbl
09:54:18 <tommd> tibbe: Ok, I'll think on this some.
09:54:42 <ChongLi> a list comprehension can be used as a kind of filter
09:54:46 <tibbe> tommd: thanks
09:54:50 <ChongLi> so predicate would make sense
09:54:54 <tibbe> sendWith is a bit shorter
09:55:14 <chrisdotcode_> okay, sweet. I get it now, thanks guys :)
09:56:18 <ChongLi> anyone use opengl or openglraw?
09:56:40 <ChongLi> I find myself preferring openglraw :(
09:57:38 <oio> >:m +Text.Regex.Posix ; let matches xs = xs =~ "[^A-Z][A-Z]{2}[A-Z]{2}[^A-Z]" in matches "abcdeAAAAaaa"
09:59:49 <oio> > let matches xs = xs =~ "[^A-Z][A-Z]{2}[A-Z]{2}[^A-Z]" in matches "abcdeAAAAaaa"
09:59:51 <lambdabot>   Not in scope: `=~'
09:59:51 <lambdabot>  Perhaps you meant one of these:
09:59:51 <lambdabot>    `==' (imported from ...
10:08:19 <dontdoMDMA> what layer in the tcp/ip layer do sockets operatoe on? transport and internet?
10:11:01 <sclv_> haha omg didn't realize scotty used overloaded strings to define routes
10:11:07 <sclv_> best abuse yet
10:12:44 <johnw> dontdoMDMA: IP identifies the host for the socket, and TCP identifies the port
10:13:48 <typoclass> dontdoMDMA: if i remember correctly, a socket is either a tcp connection, or a udp connection (or others). so it's above ip. it's at the level of tcp and udp
10:14:21 <chrisdotcode_> :t zip
10:14:22 <lambdabot> [a] -> [b] -> [(a, b)]
10:14:23 <johnw> typoclass: thanks, I forgot about the other protocols that identify ports
10:14:36 <tommd> Sockets can be at many different layers.  You can get sockets to send layer 2 data (ARP), layer 3 data (IP), layer 4 data (TCP,UDP).
10:14:43 <tommd> They are not about any one layer.
10:14:54 <seliopou> see <sys/socket.h> for more details
10:16:07 <seliopou> I think you can write raw IP packets to a socket as well
10:16:14 <dontdoMDMA> so where would you say this lies: we have written an abstraction layer on top of a tcp/ip stack that provides among other functions a serverloop that can handle incoming connections and other events. this is on top of tcp or still on the same layer? would it be in application layer of the tcp/ip stack/model? it does not abstract communication on a higher level mut merely dispatches socket
10:16:14 <dontdoMDMA> events.
10:16:15 <tommd> Yes, you can.
10:16:23 <dontdoMDMA> mut->but
10:16:30 <johnw> wait, why is this in #haskell again?
10:16:44 <seliopou> ah, tommd, didn't see the end of your message
10:17:08 <tommd> seliopou: That's fine.  Stating facts seems to be a reasonable use for IRC.
10:17:14 <seliopou> ha
10:17:21 * elliott seconds johnw :p
10:17:33 <seliopou> this is a spin-free zone?
10:19:30 <elliott> dontdoMDMA: if you don't know, this channel is about the haskell programming language
10:20:24 <tommd> I'm surprised to see the backlash.  There's often some banter on #haskell when things are quiet and socket programming is at least programming.
10:21:16 <johnw> we do try to keep it on topic
10:21:21 <elliott> tommd: true, but dontdoMDMA did join to ask a different off-topic question yesterday as well
10:21:30 <tommd> I see.
10:21:33 <elliott> so I felt it worth pointing out
10:21:40 <monochrom> the person in question has never talked about haskell.
10:22:00 <seliopou> to the logs!
10:22:03 <ChongLi> woah, I thought this was a friendly place :)
10:22:52 <seliopou> ChongLi: there's nothing friendly about static typing ;)
10:23:05 <ChongLi> seliopou: I find it very friendly
10:23:05 <seliopou> it's a harsh mistress
10:23:13 <monochrom> it's a friendly place to reasonable people.
10:23:13 <ChongLi> a nice, friendly dialogue with the compiler
10:23:43 <FreeFull> I find static typing awesome
10:23:45 <FreeFull> Catches my errors
10:24:03 <typoclass> dontdoMDMA: as a conclusion to the discussion, i think this is a good reference http://support.microsoft.com/kb/103884 (based on 5 minutes of looking around online). however, the osi model is a bit of a theoretical thing, a teaching method. it's not like tcp/ip fit into it perfectly
10:25:45 <WarzoneCommand> quick question: I'm tring to fiddle with the FFI, but if I try to include ``local'' header files I keep ketting ``undefined symbols'' errors when compiling. I must be making some very silly mistake. Anyone an idea what?
10:26:50 <WarzoneCommand> (so i have a file lib.h, with some function test, and I try to access that file from haskell using foreign import "lib.h test" )
10:27:07 <elliott> WarzoneCommand: are you linking to the library that defines test when you compile?
10:28:03 <seliopou> WarzoneCommand: are the function definitions in the header?
10:28:27 <mm_freak> perhaps "dontdoMDMA" should follow his own advice =)
10:29:06 <mm_freak> on certain drugs "#haskell" might look like "#networking" =P
10:29:25 <WarzoneCommand> elliott / seliopou : yes
10:29:57 <elliott> WarzoneCommand: perhaps hpaste your .hs, .h, compile command, error?
10:29:58 <elliott> @hpaste
10:29:58 <lambdabot> Haskell pastebin: http://hpaste.org/
10:30:07 <WarzoneCommand> http://pastebin.com/Vifw7H95
10:30:13 <mauke> The paste Vifw7H95 has been copied to http://hpaste.org/88303
10:30:19 <monochrom> yesod is the server-loop abstraction that dontdoMDMA is looking for
10:31:10 <gallais> hi all. a quick question about ghc: are -fno-code and -fwarn-incomplete-patterns incompatible?
10:31:29 <WarzoneCommand> (iif I uncomment the import for test, than everything compiles/runs fine
10:32:50 <WarzoneCommand> (running mac os X 10.7 here with haskell platform 1202.4 (64 bit) )
10:33:33 <elliott> WarzoneCommand: perhaps ghc --make foo.hs lib.h would work
10:33:48 <elliott> but generally, .h does not contain implementations, only prototypes, and lib.c or lib.o or lib.so or whatever would contain the actual implementations
10:33:52 <elliott> so this situation is unusual
10:34:16 <elliott> also, I believe GHC won't actually read lib.h by default here, but I may be mistaken
10:34:22 * seliopou goes and tries to use libboost via Haskell's ffi
10:36:02 <WarzoneCommand> I can try putting it in a separate file. But I kind of ended up with this minimum test case with the implmeentation in the header since c2hs aslo seems to do this
10:36:16 <steven_is_false> Hi! Is there a Haskell package on Hackage available that supports circular double linked lists? I'd code it myself but tying the knot is even more confusing to me than category theory.
10:36:48 <elliott> steven_is_false: generally, tying-the-knot-style doubly linked lists aren't that useful; perhaps you'd find a zipper more useful
10:37:24 <c_wraith> It's useful if somehow you need to traverse the list in circular fashion in both directions in constant memory. And never modify it.
10:37:35 <Jeanne-Kamikaze> mm_freak, there ?
10:37:46 <c_wraith> That isn't a case that comes up very often
10:38:03 <Jeanne-Kamikaze> mm_freak, would you mind finishing your intro to arrows and netwire anytime soon :) ?
10:38:17 <Jeanne-Kamikaze> I'm talking about http://ertes.de/new/tutorials/arrows.html
10:38:34 <steven_is_false> elliott I'm not sure how one would make a circular list zipper.
10:38:50 <monochrom> WarzoneCommand: it is "lib.c" and the ghc command is "ghc --make foo.hs lib.c" or "ghc --make foo.hs lib.o" depending on whether you already have compiled lib.c
10:39:09 <steven_is_false> ls
10:39:10 <elliott> steven_is_false: well, you'd probably have to pay a cost when you reach the "end" to rebuild it
10:39:21 <steven_is_false> oops*
10:39:26 <Fuuzetsu> steven_is_false: a blind guess could be when one of the sides is empty, reverse and swap
10:39:49 <elliott> right
10:40:12 <c_wraith> I think you can actually do better than that, if you base it on one of Okasaki's double-ended queue structures
10:40:16 <c_wraith> Since that's really what it is
10:40:24 <steven_is_false> elliott: So you think in most cases the amortized almost constant cost would be worth it?
10:40:32 <c_wraith> You just push to the end opposite of what you popped from, every time
10:40:53 <yogert1> hey all, how would I provide a default value for an argument with GetOpt? I can think of a a way, but it hardly seems right. http://hpaste.org/88307
10:41:05 <c_wraith> since Okasaki's dequeues use laziness to pay the reversing cost incrementally
10:41:15 <yogert1> In this case I would like bar to default to a number if not explicitly supplied
10:41:19 <elliott> steven_is_false: I would try it before assuming it isn't, at least; I've done it in practice to implement a round-robin scheduling type thing, and it was faster than using a fancy Data.Sequence-based thing
10:41:39 <WarzoneCommand> hmm ty monochrom that seems to work indeed
10:41:51 <typoclass> yogert1: random remark -- i haven't tried it yet myself, but all the cool kids are using optparse-applicative now :-)
10:42:14 <yogert1> hmm
10:42:36 <typoclass> yogert1: here's is some examples to look at https://github.com/pcapriotti/optparse-applicative#applicative-option-parser just to see if you find it nice
10:43:45 <luite> typoclass: do you know if it's possible to make optparse-applicative only accept the --option=value long syntax, and not --option value?
10:43:58 <ChongLi> optparse-applicative is quite nice
10:44:43 <steven_is_false> Thank you for your help.
10:45:09 <yogert1> hmm okay. I'll give it a shot. GetOpt always seemed needlessly complex to me, but then again, I'm new to Haskell so perhaps I shouldn't be making those sorts of judgements
10:45:44 <WarzoneCommand> so another quick question: I'm acutally using these c functions as wrapper functions around some existing functions. What would now be a good place to put this wrapper code (in terms of in the cabal package?) in a separate c_src/ directory or so ?
10:46:30 <yogert1> would I be able to find it on cabal under optparse-applicative?
10:47:02 <typoclass> yogert1: you would be able :-)
10:47:08 <ChongLi> http://hackage.haskell.org/package/optparse-applicative
10:47:11 <yogert1> : ) sorry. dumb question
10:47:41 <nejucomo> I just started using TemplateHaskell, but I get this error when compiling a module with splices in it: cannot find normal object file `...' while linking an interpreted expression
10:47:43 <typoclass> yogert1: no, i didn't mean that. as far as i can see the readme doesn't have a link to hackage
10:47:59 <ChongLi> speaking of which, are there any good plugins for vim to do layout/indentation that way?
10:48:08 <nejucomo> After a quick google, I see several issue tickets with this error, but I haven't found an explanation of what conditions cause it, or how to work around it.
10:48:19 <yogert1> typoclass: yeah but still, I asked right before a quick search confirmed it for me.
10:48:20 <nejucomo> Does anyone here have experience / advice with this error?
10:49:26 <yogert1> typoclass: all searches on the topic of arg parsing pointed me to GetOpt. Is GetOpt just an old, awkward method that should probably be avoided now?
10:49:57 <Fuuzetsu> Should go full power and parse the command line arguments with parsec~
10:50:12 <yogert1> hah
10:50:14 <viller> is there a standard implementation of state transformers in haskell?
10:50:19 <yogert1> that was a joke right?
10:50:22 <Fuuzetsu> yes
10:50:24 <Fuuzetsu> :t StateT
10:50:25 <yogert1> : )
10:50:25 <lambdabot> (s -> m (a, s)) -> StateT s m a
10:50:30 <monochrom> I recommend optparse-applicative. it's pretty slick because of Applicative
10:50:30 <Fuuzetsu> (yes to both)
10:50:50 <monochrom> other getopt libs are adequate. just adequate.
10:51:20 <typoclass> luite: i don't have much clue, but just to cover the basics: https://github.com/pcapriotti/optparse-applicative#regular-options sez "is specified as '--output filename' or '--output=filename'". sounds like it's built in. it'd be a legitimate patch to send to them :-)
10:51:46 <yogert1> Well this seems somewhat similar to Parsec… Is that just a symptom of "applicative" design?
10:51:47 <typoclass> monochrom: oh you've used it? did you see luite's question?
10:51:52 <viller> Fuuzetsu: what package is that? Google says Control.Monad.State something. Is this correct?
10:52:16 <c_wraith> that module exists.  In multiple packages
10:52:17 <monochrom> I haven't used it enough to answer. but I bet the answer is no.
10:52:28 <Fuuzetsu> ?index StateT
10:52:28 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.State, Control.Monad.RWS
10:52:38 <c_wraith> @hoogle mtl
10:52:39 <lambdabot> package mtl
10:52:39 <lambdabot> package mtl-tf
10:52:39 <lambdabot> package mtlparse
10:52:45 <c_wraith> @hackage mtl
10:52:45 <lambdabot> http://hackage.haskell.org/package/mtl
10:52:46 <Fuuzetsu> Control.Monad.State is what you want indeed
10:52:49 <c_wraith> sorry, that's what I meant
10:52:56 <viller> what's Control.Monad.ST?
10:53:34 <Fuuzetsu> >This library provides support for strict state threads, as described in the PLDI '94 paper by John Launchbury and Simon Peyton Jones Lazy Functional State Threads.
10:53:35 <monochrom> slick libraries are not meant to be customizable down to that level. would contradict the definition of slick. does lens give you a flag for "don't use unsafeCoerce here"?
10:53:39 <Fuuzetsu> Look these things up man.
10:53:57 <glguy_> monochrom: yeah, it's "safe"
10:54:03 <monochrom> darn
10:54:04 <glguy_> (the flag, that is)
10:54:15 <viller> I did look it up. I'm just new and that sentence doesn't give me an understanding of the differences between these two :)
10:54:23 <monochrom> but I bet not to the point of customizing each call site
10:54:38 <Fuuzetsu> viller: Well then, you're most likely not looking for it then.
10:54:43 * elliott doesn't think "strict state threads" is a useful explanation of ST anyway.
10:54:45 <typoclass> Fuuzetsu: please be civil. it's not like ST's haddocks are well-written. i find viller's question legitimate
10:54:53 <luite> typoclass: yeah i foudn that, but didn't really feel like digging in the internals. the --x=y option makes it much easier to filter some options to parse with optparse-applicative, and send the rest to a different option parser
10:54:54 <Fuuzetsu> Am I not being civil?
10:54:55 <seliopou> WarzoneCommand: Have you checked out the CPP language option?
10:55:01 <Fuuzetsu> Sorry.
10:55:09 <c_wraith> viller: ST gives you true mutable data, with all of the benefits and downsides, with an externally pure interface. State wraps explicit state-passing to make it easier to use
10:55:10 <seliopou> that together with hsc2hs might help
10:56:04 <viller> thank you Fuuzetsu and c_wraith
10:56:07 <typoclass> Fuuzetsu: accepted. thanks, very good
10:56:31 <monochrom> viller: Control.Monad.ST gives you mutable cells. newSTRef to create a cell, readSTRef and writeSTRef to read and write.
10:57:05 <c_wraith> viller: note that mutable references have some bad interactions with the garbage collector in GHC, and so they aren't a performance win in a lot of situations. But when they are, they generally are a big win.
10:57:07 <monochrom> and also mutable arrays (Data.Array.ST)
10:57:45 <c_wraith> mutable vectors, too...  If you prefer that api.
10:58:05 <viller> I don't care much about performance right now. Is there a good reason why I should use Lazy? For me Strict sounds more sensible for this kind of thing
10:58:23 <typoclass> luite: i'm thinking of something like «strOption ( long "output" <> metavar "FILE" <> onlyEq )» with onlyEq being the hypothetical new thingy that would require "--opt=file", disallowing "--opt file". not sure if that even fits into optparse's implementation at all
10:58:24 <c_wraith> viller: you almost certainly want Strict unless you already know why you'd want Lazy
10:58:35 <monochrom> yes please use Strict for this
10:58:55 <viller> ok thanks again
10:59:09 <monochrom> Lazy is for trying to understand http://hpaste.org/63925 :)
10:59:55 <c_wraith> Note that even Control.Monad.Strict isn't actually strict in the state value being passed around - it can still stack overflow if you chain a bunch of modify calls without using the result
10:59:56 <luite> typoclass: perhaps a different kind of long
11:00:21 <monochrom> Control.Monad.State.Strict
11:00:26 <c_wraith> err, yes, thanks
11:00:28 <c_wraith> that's what I meant
11:00:33 <typoclass> luite: yes that's also possible. "longWithEq" or something
11:01:51 <luite> typoclass: i've already hacked around it though, and i'm busy implementing STM now, but if you want to submit a patch i'd use it! :p
11:02:31 <typoclass> tangentially, what's going on with the diamonds? «strOption ( long "output" <> short 'o' <> metavar "FILE")» if they stand for mappend, i can't find the relevant Monoid instance
11:03:00 <c_wraith> they are mappend, in the newest version of base
11:03:12 <c_wraith> But I can't tell you where the instance is
11:03:20 <Cale> typoclass: Where is this code?
11:03:26 <luite> Monoid (Mod f a) in Options.Applicative.Builder.Internal
11:03:41 <yitz> monochrom: i recently tried out optparse-applicative for something. wow, it is really really nice.
11:03:42 <typoclass> Cale: see here https://github.com/pcapriotti/optparse-applicative#applicative-option-parser
11:04:11 <yitz> @hackage optparse-applicative
11:04:11 <lambdabot> http://hackage.haskell.org/package/optparse-applicative
11:04:13 <ChongLi> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Monoid.html#v:-60--62-
11:04:37 <typoclass> c_wraith: yes. i was wondering if optparse uses base's (<>), or if they defined their own thing that just happens to have the same name
11:04:52 <luite> nah it's Monoid, see ^
11:04:53 <Cale> typoclass: http://hackage.haskell.org/packages/archive/optparse-applicative/0.5.2.1/doc/html/Options-Applicative-Builder-Internal.html#t:Mod
11:05:05 <yitz> monochrom: but I saw that some people are advocating a different applicative opts parser, cmdtheline. do you know what the differences are?
11:05:25 <Cale> Note that there's a monoid instance for Mod f a, and that this is the sort of thing which 'long' etc. seem to produce.
11:05:35 <ChongLi> well, they did "define their own" insomuch as they wrote an instance of Monoid
11:05:37 <monochrom> I don't know
11:05:39 <typoclass> Cale: oh! thanks a lot. i had only seen http://hackage.haskell.org/packages/archive/optparse-applicative/0.0.1/doc/html/Options-Applicative-Builder.html#t:Mod , which only mentions a Category instance (?)
11:05:45 <luite> :( no one listens to me
11:06:00 <Cale> typoclass: Ah, I see, you seem to have ended up at an old version
11:06:06 <ChongLi> luite: hey, how is ghcjs going?
11:06:09 <Cale> (in fact, the oldest version)
11:06:21 <typoclass> Cale: argh :-/ you're right
11:07:00 <luite> ChongLi: ah it's ok, I'm working on finalizing the Cabal and GHC patches, and implementing STM
11:07:09 <typoclass> luite: and thank you
11:07:16 <ChongLi> ahhh, cool
11:07:17 <yitz> luite: what you wrote earlier scrolled off my screen, sorry. did you address my question?
11:07:21 <luite> typoclass: aww. good kitty ;p
11:07:53 <luite> yitz: oh no, sorry, only typoclass', but i didn't highlight his name so i guess he missed it
11:08:13 <stepkut`> how do I decide between MVar and TMVar ?
11:08:40 <johnw> stepkut`: I prefer ot use TMVar until I know I need MVar
11:08:40 <ChongLi> stepkut`: do you need consistency?
11:08:44 <yitz> luite: i was asking about cmdtheline vs optparse-applicative. i only know the latter, and i love it. know anything about the other one?
11:08:46 <luite> ChongLi: still a bit of work remaining to reduce the code size
11:08:55 <luite> yitz: oh haven't used it
11:09:09 <beaky> hello
11:09:12 <ChongLi> luite: that's a never-ending battle
11:09:17 <johnw> hi beaky!
11:09:44 <luite> ChongLi: and i think possibly another scheduler would be useful, to be able to write libraries in haskell, call them easily from javascript
11:10:06 <ChongLi> that would be really useful
11:10:08 <yitz> luite: ok. truthfully, the sample code i've seen for cmdtheline isn't nearly as clean and immediately readable as optparse-applicative, but that could be just cosmetic.
11:10:24 <ChongLi> the goal, of course, is for haskell to take over the world!
11:10:44 <luite> ChongLi: the current scheduler is really asynchronous, so only the (in javascript common) pattern of call(function, callback) works
11:11:40 <luite> which enables nice things like mvars, waiting for ajax results in haskell threads, threaddelay etc, but a simpler synchronous scheduler could work with more limited functionality and direct calls
11:12:30 <ChongLi> hmmm
11:12:57 <luite> mixing them would be tricky though, if the async scheduler produces black holes, threads would have to wait for them
11:13:12 <ChongLi> yeah
11:13:30 <ChongLi> gah, just give me the ghc RTS in the browser :)
11:14:12 <ChongLi> it's so frustrating to deal with these bad tradeoffs when what we have is so much better
11:14:12 <luite> well the async scheduler that's currently in there, supports most of what the GHC RTS does, but because JS is single threaded we have to do it with callbacks
11:14:31 <luite> oh you meant in native code :p
11:14:37 <ChongLi> yeah
11:14:49 <luite> yeah not very likely :)
11:15:00 <luite> unless you count some chrome experiments
11:15:20 <ChongLi> I think google shares this frustration
11:15:28 <ChongLi> hence nacl/pnacl
11:15:44 <luite> yeah, but mozilla likes asm.js better :(
11:16:11 <ChongLi> there are good arguments on all sides
11:17:13 <beaky> How do I do logic programming in haskell?
11:17:43 <ChongLi> a number of different ways
11:17:49 <applicative_> haskell is the worlds finest logic programming language
11:18:08 <beaky> I like the prolog paradigm of telling the computer facts about your domain and then querying it stuff; seems verry powerful if haskell can easily do that kind of thing (it's difficult in C++ and other programming languages)
11:18:16 <beaky> very*
11:18:42 <ChongLi> the list monad is a pretty simple way to get started
11:19:02 <elliott> @hackage logict
11:19:02 <lambdabot> http://hackage.haskell.org/package/logict
11:19:08 <elliott> beaky: ^
11:19:27 <ChongLi> yeah, that'd be the next logical step
11:19:33 <beaky> logical; hah :D
11:19:50 <beaky> so list comprehensions are like a mini-DSL for logic programming?
11:20:10 <ChongLi> they're for building lists
11:20:48 <ChongLi> but the way they work gives you some basic properties of logic programming
11:21:08 <ChongLi> the key is the function guard
11:21:27 <ChongLi> http://www.haskell.org/haskellwiki/Logic_programming_example
11:22:29 <applicative_> >  [x | x <- [1..100], odd x , x * 3 < 200 , x + 10 < x * 3]
11:22:30 <lambdabot>   [7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,5...
11:23:51 <otters> x + 10 < x * 3 == fancy version of x > (10/3)
11:24:44 <applicative_> otters: yes, I was just making arbitrary predicates
11:24:49 <otters> oh
11:24:50 <applicative_> arbitrary assertions!
11:25:01 <otters> > [x | x <- [1..10], True]
11:25:02 <Fuuzetsu> Are monad comprehensions in yet?
11:25:02 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
11:25:05 <otters> > [x | x <- [1..10], False]
11:25:07 <lambdabot>   []
11:25:13 <applicative_> to exhibit half-baked logic programming
11:25:17 <applicative_> Fuuzetsu: yes
11:25:37 <applicative_> {-#LANGUAGE MonadComprehensions #-}
11:26:17 <applicative_> Fuuzetsu: they say not to mix them with list comprehensions, since list comprehensions proper have special optimizations
11:26:30 <applicative_> which go out the window with the generic desugaring
11:26:33 <Fuuzetsu> I'll have to play around with it later.
11:27:28 <Fuuzetsu> Unrelated: How fine is it to put up packages on hackage that rely on language pragmas?
11:27:43 <johnw> lots of packages do, Fuuzetsu
11:27:59 <fruitFly> mm_freak: yo
11:28:26 <Fuuzetsu> k
11:28:54 <dmwit> otters: Wouldn't it be a fancy version of x > 5?
11:28:55 <dmwit> =)
11:29:06 <otters> dmwit: :<
11:29:16 <dmwit> > (4 > 10/3, 4 + 10 < 4 * 3)
11:29:18 <lambdabot>   (True,False)
11:29:25 * hackagebot git-annex 4.20130521 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-4.20130521 (JoeyHess)
11:30:01 <Fuuzetsu> Will GHC optimise away constant arithmetic expressions such as 7 ^ 9 at compile time?
11:30:31 <dmwit> I don't think it can.
11:30:37 <Fuuzetsu> Why not?
11:30:46 <dmwit> Because polymorphism.
11:30:46 <yogert1> hrm… I still seem to be having trouble supply a default value to an argument. even with optparse-applicative. http://hpaste.org/88318
11:30:57 <beaky> because polymorphic literals :D
11:32:04 <Fuuzetsu> beaky: foo ∷ Integer; foo = 4 ^ 2; will always be 16 no matter what you try
11:32:34 <supki> yogert1: <> value "default"
11:32:35 <applicative_> Fuuzetsu: I think the answer is no, as there is a plugin that does it for you..
11:32:40 <dmwit> Yep, with a type signature it might be possible. I'm not sure whether GHC tries that, but I sort of doubt it.
11:32:41 * applicative_ roots around
11:33:04 <luite> fryguybob: does STM check collect all read TVars from the subtransaction every time an invariant check is run?
11:33:05 <Fuuzetsu> I just don't see a reason why it shouldn't…
11:33:05 <applicative_> Fuuzetsu: http://hackage.haskell.org/package/const-math-ghc-plugin
11:33:23 <supki> yogert1: http://hackage.haskell.org/packages/archive/optparse-applicative/0.5.2.1/doc/html/Options-Applicative-Builder.html#v:value
11:33:25 <yogert1> supki: huh, did I miss that in the docs?
11:33:32 <applicative_> I think people agree it is possible, since the plugin is possible
11:33:43 <dmwit> Fuuzetsu: Just the usual one: nobody's done it yet.
11:34:03 <dmwit> Fuuzetsu: (Except that applicative_ seems to be claiming that somebody has indeed done it yet. So. =)
11:34:21 <yogert1> supki: oh. I was reading the github readme and didn't see it. For future reference, is there something else that maybe should have tipped me off?
11:35:12 <Fuuzetsu> Well, as applicative_ shows, it's has already been done so I don't see why it shouldn't be put in by default. I wonder if there's a ticket for this already.
11:35:58 <elliott> well, (^) isn't primitive. it has a definition
11:36:01 <elliott> GHC just works with that
11:36:39 <Fuuzetsu> @src (^)
11:36:40 <lambdabot> x ^ 0            =  1
11:36:40 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
11:36:40 <lambdabot>   where f _ 0 y = y
11:36:40 <lambdabot>         f x n y = g x n
11:36:40 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
11:36:41 <luite> (^) has some rewrite rules to rewrite it to (*) applications for small fixed exponents
11:36:42 <lambdabot>                       | otherwise = f x (n-1) (x*y)
11:36:44 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
11:36:48 <ski> beaky : logic variables requires more
11:37:00 <luite> which might trigger some optimizations
11:38:39 <dmwit> Looks like "main = print (7^3)" gets optimized away to "print 343", but "print (7^9)" doesn't get optimized.
11:38:42 <supki> yogert1: not sure, I'm not that experienced with optparse-applicative
11:39:19 <dmwit> up to 7^5 gets optimized away, but 7^6 doesn't
11:39:25 * hackagebot prizm 0.2.0.0 - A haskell library for computing with colors  http://hackage.haskell.org/package/prizm-0.2.0.0 (ParnellSpringmeyer)
11:39:29 <dmwit> so
11:39:31 <dmwit> that's fun
11:40:09 <joeyh> Control.Exception.bracket_ catches Async exceptions too, right?
11:40:41 * joeyh stares at code where it just seems like it's letting them through. Probably missing something.
11:41:05 <applicative_> Fuuzetsu: oh here's a bit of reddity discussion of the constant math question http://www.reddit.com/r/haskell/comments/11cujs/ghc_plugin_for_evaluating_math_expressions_at/
11:41:42 <elliott> joeyh: perhaps the exception only happens when you force part of the result
11:41:45 <elliott> outside of the bracket_
11:41:56 <elliott> async exceptions are tricky things
11:41:56 <dmwit> joeyh: I wonder, what's the type of your handler?
11:41:57 <luite> joeyh: have you masked async exceptions?
11:42:37 <joeyh> I have not explicitly masked them, no
11:42:41 <johnw> luite: why would he want to mask them?  I think he wants the bracket to free the resource in case they occur
11:43:30 <luite> johnw: they might be masked implicitly without him knowing, for example `catch` runs the handler in an interruptible mask
11:43:35 <johnw> joeyh: I have almost all of my personal filesets under git-annex now :)
11:43:42 <luite> or perhaps the whole thread was masked
11:43:50 <joeyh> hmm, yeah, it could be the thunk
11:43:57 <johnw> luite: ah yes, I just learned that threads inherit the parent's mask
11:44:45 <joeyh> if they're masked, does that mean the bracket doesn't catch them? So when whatever did the masking clears it, it'll get the exception there?
11:44:47 <luite> johnw: i spent some time getting al async masking edge cases correct in the ghcjs runtime last week :)
11:44:53 <johnw> joeyh: yes
11:45:36 <luite> joeyh: the exception sits in the queue until the thread unmasks (and the sending thread is suspended until the exception is dilevered)
11:46:07 <luite> joeyh: so if you only unmask outside the handler, the handler will never see it
11:46:14 <dmwit> This whole discussion just reminds me how little I understand about exceptions.
11:46:24 <dmwit> What should I read?
11:46:36 <luite> for me, implementing this stuff helped most ;p
11:47:49 <johnw> dmwit: you want to learn more about async exceptions, or just exceptions overall?
11:47:50 <luite> dmwit: there's some haddock comments near throwTo, and a link to the original paper
11:47:55 <johnw> http://community.haskell.org/~simonmar/papers/async.pdf
11:48:00 <johnw> ^-- is good for async exceptions
11:48:29 <luite> dmwit: with some description of the differences. the main difference is that throwTo now blocks until the exception has been delivered to the target thread
11:48:41 <joeyh> hmm, I am almost entirely using Control.Exception stuff. I do no explicit masking of my own, and its docs seem to say catch etc restore before running the action
11:48:41 <dmwit> johnw, luite: thanks
11:48:59 <dmwit> luite: hum, that doesn't sound very asynchronous =P
11:49:25 * hackagebot ghc-parmake 0.1.2 - A parallel wrapper for 'ghc --make'.  http://hackage.haskell.org/package/ghc-parmake-0.1.2 (MikhailGlushenkov)
11:49:37 <johnw> dmwit: basically, when you are reading code, think of what might happen if an exception occurred at any time, at any point.  This is why I like using ResourceT, beacuse it's often cleaner than littering the code with uses of bracket
11:49:55 <luite> dmwit: but this is strictly more powerful, and avoids some race conditions. you can always forkIO a new thread to do the throwIO
11:50:06 <dmwit> I see.
11:50:12 <johnw> dmwit: it's asynchronous because the receiving thread will exeprience an exception at a location where the code would not otherwise be capable of causing one
11:50:12 <luite> to do the throwTo i mean
11:50:32 <dmwit> johnw: ah, right
11:51:06 <luite> dmwit: async exceptions are also handled differently, all thunks under evaluation when a synchronous exception happened, will be overwritten by that exception
11:51:20 <luite> dmwit: since the next time you'd evaluate the same thunk, it would result in the same exception anyway
11:51:21 <johnw> here's a question: would you also call the displaced exceptions caused by lazy I/O an asynchronous exception?  some of the properties are similar
11:51:46 <luite> dmwit: for async exceptions, the thunk's computation gets suspended, so it can be restarted
11:52:07 <monochrom> yes johnw
11:52:27 <luite> dmwit: i should say resumed, it doesn't restart from the beginning (that's impossible since the runtime has thrown out the data for that)
11:52:59 <monochrom> but wait, most lazy I/O just tells you [] when the I/O has a problem
11:54:06 <applicative_> dmwit: there is also the laborious account in http://ofps.oreilly.com/titles/9781449335946/sec_conc-overlap-io.html#sec_exceptions akin to what johnw linked
11:54:14 <luite> hmm, arent IOExceptions thrown synchronously usually?
11:54:32 <c_wraith> yes
11:55:08 <c_wraith> they are *usually* thrown using throwIO, which is both synchronous and precise.
11:55:21 <c_wraith> throw is technically synchronous, but it's imprecise
11:55:46 <c_wraith> as far as I know, throwTo is the only primitive that is asynchronous
11:55:59 <luite> applicative_: that doesn't say anything about async exceptions though
11:56:44 <sclv_> i think we're getting all confused with our word things
11:56:45 <luite> c_wraith: yeah that's true, it's a wrappwr for the killThread# primop
11:56:47 <applicative_> that passage no
11:56:55 <dmwit> Hey, there was a question the other day.
11:56:57 <sclv_> classic exceptions are thrown and caught in IO
11:57:07 <sclv_> imprecise exceptions are thrown from pure code
11:57:20 <sclv_> and async exceptions are raised by external events
11:57:32 <sclv_> that's how you distinguish afaik, full stop
11:57:37 <dmwit> How come "do { throwIO {- some exception -}; let [] = [()]; return () }" can result in a pattern match failure?
11:58:00 <pooya72> what's the haskell alternative to using regular expressions? I know haskell has them, but they don't seem to be the standard approach. Is something like parsec over kill? I just want to find a list URL's on a webpage.
11:58:23 <Fuuzetsu> ?index css
11:58:23 <lambdabot> bzzt
11:58:24 <geekosaur> use a real html parser, please
11:58:27 <Fuuzetsu> ^
11:58:39 <mauke> pooya72: that's not even a regex problem in the first place
11:58:42 <applicative_> luite: i was pointing to the first discussion of exceptions in the book , see e.g. http://ofps.oreilly.com/titles/9781449335946/sec_cancellation.html#sec_catching-async-exceptions
11:58:47 <geekosaur> http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags
11:59:10 <Fuuzetsu> TONY THE PONY
11:59:15 <luite> sclv_: you can throwTo an async exception to the current thread though
11:59:20 <applicative_> pooya72: tagsoup?
11:59:29 <luite> which will get delivered immediately, regardless of masking state
11:59:34 <sclv_> right but why does that matter?
11:59:39 <pooya72> mauke: geekosaur: I don't need to parse the whole webpage
11:59:46 <geekosaur> doesn't matter
11:59:46 <mauke> pooya72: yes, you do
11:59:47 <luite> they're still a bit different in how they're handled
11:59:50 <sclv_> ah
11:59:51 <Tehnix> is there a function to throw a normal int -> IO int?
11:59:56 <pooya72> just find anything that's "http://"
11:59:57 <mauke> Tehnix: return
12:00:02 <mauke> pooya72: wrong
12:00:07 <geekosaur> you may not need the data, but you will grab things you don't want otherwise
12:00:16 <pooya72> yeah I meant I don't need to parse the tags
12:00:20 <luite> sclv_: but from proper pure code there shouldn't be a difference
12:00:21 <mauke> pooya72: yes, you do
12:00:29 <Tehnix> mauke: ah, thanks :)
12:00:43 <geekosaur> seriously, everyone thinks that and they always end up finding out the hard way that it's not that simple
12:00:49 <geekosaur> don't argue with it
12:00:56 <monochrom> why do you even need regex? a simple Knuth-Morris thing will find "http://" for you
12:01:01 <mauke> hrhr
12:01:22 <mauke> spoilers: perl's regex engine uses boyer-moore under the hood IIRC
12:01:25 <pooya72> mauke: well, i wrote it ruby. just a regex to find "http://..." then put it in an array
12:01:31 <mauke> pooya72: yes, that's wrong
12:01:44 <pooya72> mauke: trying to do the same thing in haskell. How is that wrong?
12:01:52 <mauke> if you have to ask ...
12:03:14 <monochrom> I like that quote from the movie Phone Booth too. "if you have to ask, you are not ready to know." but I wouldn't even say that in this case. I am tired of arguing and correcting people. you want "http://", cool, it doesn't even need regex.
12:03:25 <enigmuriatic> can someone explain to me (or link me to one) why you can map a parameter across functions using $ but not without it? Learn You A Haskell is really vague about that
12:03:29 <Fuuzetsu> consider reading http://adit.io/posts/2012-04-14-working_with_HTML_in_haskell.html
12:03:30 <Fuuzetsu>  
12:03:40 <pooya72> hey, I'm cool without regex. That's what my question was.
12:03:46 <geekosaur> yes, you can easily write the wrong thing in ruby or perl or haskell or whayever
12:03:52 <Fuuzetsu> enigmuriatic: look up sections
12:03:52 <pooya72> how to do it without regex
12:03:57 <sclv_> dmwit: that behavior is truly puzzling to me
12:04:03 <geekosaur> if you ask the experts on those languages, they weill attempt to tell you why you shouldn't write the wrong thing
12:04:09 <steven_is_false> Hi! Where's the most correct place to import unsafeCoerce from?
12:04:11 <geekosaur> of course, you probably know better than they do...
12:04:14 <Fuuzetsu> ($ 5) is just λx → x $ 5
12:04:31 <mauke> Fuuzetsu: your use of λ is terrible
12:04:32 <typoclass> enigmuriatic: hm ... do you have a code example about what's unclear?
12:04:42 <Fuuzetsu> mauke: Feel free to suggest an alternative
12:04:47 <mauke> Fuuzetsu: \
12:04:54 <Fuuzetsu> Why?
12:05:01 <mauke> Fuuzetsu: because it's better than λ in every way
12:05:02 <monochrom> just use simple recursion on strings. f ("http://":s) = what you need to do; f (c:cs) = f cs
12:05:13 <Fuuzetsu> ‘It's better’ is hardly an argument.
12:05:19 <mauke> Fuuzetsu: why not?
12:05:21 <luite> applicative_: ah good point. that also has a good example fo the implicit catch mask :)
12:05:35 <dmwit> sclv_: Phew, I'm not the only one, then. =D
12:05:41 <Fuuzetsu> The only argument (where λ is a valid name for a function) doesn't even hold here
12:05:48 <FreeFull> ("http://":s) would match an array of strings though
12:05:50 <mauke> Fuuzetsu: that's not the only argument
12:05:51 <Fuuzetsu> mauke: Because anyone can claim something is better.
12:05:57 <mauke> Fuuzetsu: yes, but no one did
12:06:01 <Fuuzetsu> mauke: So far I've seen 0 aarguments.
12:06:02 <monochrom> oh, right
12:06:04 <Fuuzetsu> arguments*
12:06:08 <sclv_> you should ask on SO
12:06:12 <FreeFull> Well, not array, list
12:06:18 <FreeFull> Brain scrambled
12:06:43 <mauke> Fuuzetsu: first off, there's the general ascii > rest-of-unicode thing
12:06:51 <monochrom> f cs = if "http://" `isPrefixOf` cs then (what you need to do) else f (tail cs)
12:06:54 <FreeFull> :t \("http://":x) -> x
12:06:55 <Fuuzetsu> Oh, so it's just opinions.
12:06:55 <lambdabot> [[Char]] -> [[Char]]
12:06:56 <mauke> Fuuzetsu: displays everywhere, can be typed everywhere
12:07:01 <sclv_> > find ("http://" `isPrefixOf`) . tails $ "asdf asdf asdfhttp://asdfdfd"
12:07:03 <lambdabot>   Just "http://asdfdfd"
12:07:11 <mauke> Fuuzetsu: then, λ is a fucking letter. 'λx' is an identifier
12:07:30 <Fuuzetsu> mauke: Unless the person I'm addressing can't read λ for some reason, there's absolutely no issue here.
12:07:31 <mauke> Fuuzetsu: \ is free for use as a reserved symbol
12:08:04 <typoclass> pooya72: hello. the module Data.List has some basic functions for working with Strings, among them isInfixOf, isPrefixOf, stripPrefix. unfortunately there's no function for finding a substring that i know of. but check sclv's example, it might be the simplest solution here
12:08:06 <monochrom> linear algebra people would like to use λ for eigenvalues
12:08:17 <Fuuzetsu> It's okay. I'll just claim that λ is better. That seems to work as an argument for you.
12:08:26 <mauke> Fuuzetsu: did you just ignore everything I said?
12:08:51 <Fuuzetsu> mauke: You said that you can type it everywhere and read it everywhere (\ that is)
12:08:52 <mauke> Fuuzetsu: the time for just claiming that λ is better is over
12:09:02 <pooya72> typoclass: sclv_: mauke: ok thanks guys. let me dig in to this. I'm just a programming noob so thanks for your help.
12:09:08 <mauke> Fuuzetsu: yes, that was re: the general ascii thing
12:09:24 <Fuuzetsu> Maybe you should like, you know, deal with the fact that I wanted to use λ here?
12:09:47 <^|{`-}^{> hi, how do I use haskell and regex to solve Project Euler #15?
12:09:53 <mauke> Fuuzetsu: why did you want to use λ?
12:09:55 <^|{`-}^{> just kidding!
12:10:18 <Fuuzetsu> mauke: because I felt like it…?
12:10:29 <mauke> so far I've seen 0 arguments
12:10:34 <Fuuzetsu> I don't see why I have to justify my choice. Everyone clearly knew what I meant.
12:10:51 <Fuuzetsu> ‘I'm right until you prove me wrong’ – mauke
12:10:52 <typoclass> mauke: ok, "i like ascii more than unicode" etc. is a valid argument. but why did you need to troll for a couple minutes? why didn't you say rightaway "in my opinion, ascii is better than unicode"?
12:11:10 <Fuuzetsu> typoclass: A valid opinion. Not an argument.
12:11:29 <mauke> typoclass: because ascii isn't better than unicode
12:11:32 <mauke> that doesn't even make sense
12:11:37 <typoclass> Fuuzetsu: yes personally i don't find the point very strong, but whatever
12:11:48 <mauke> also, why are you all concentrating on the ascii thing?
12:11:56 <Fuuzetsu> but you just claimed: Fuuzetsu: first off, there's the general ascii > rest-of-unicode thing
12:11:59 <typoclass> mauke: you said "ascii > rest of unicode"
12:12:09 <johnw> Fuuzetsu: you can get your editor to display \ as λ, problem solved.  that's what I do
12:12:11 <mauke> typoclass: yes, as a minor/general thing
12:12:27 <monochrom> what is this "debate" about?
12:12:27 <mauke> johnw: why?
12:12:36 <johnw> mauke: is pretteh
12:12:37 <typoclass> mauke: so, you're saying you needed to troll for the first two minutes "because ascii isn't better than unicode"?
12:12:43 <Hafydd> johnw: what if you want to use λ as a variable name?
12:12:48 <Fuuzetsu> johnw: Sure I can. I just didn't think anyone would become so… inclined to jump on me for using it in the wild.
12:12:49 <nooodl> urgh take this thing elsewhere
12:12:55 <mauke> typoclass: I don't think I was trolling
12:12:56 <johnw> i don't use greek letters as variable names, so I haven't run into an issue
12:13:08 <mauke> I literally don't get it
12:13:21 <mauke> I think the desire to use λ for functions is some kind of memetic disease
12:13:30 <Fuuzetsu> I don't get why you feel the need to jump on a half-a-line expression involving λ
12:13:50 <monochrom> ok, you should continue in pm
12:13:51 <mauke> because it irks me
12:14:23 <Fuuzetsu> monochrom: Nah, I'll just stop here. It seems to just be the case of ‘Stop liking what I don't like!’.
12:14:24 <enigmuriatic> why can't haskell deduce Eq from Num?
12:14:34 <mauke> enigmuriatic: because Num no longer subclasses Eq
12:14:35 <Fuuzetsu> :i Num
12:14:38 <Hafydd> mauke: I can imagine someone doing that if they wanted it to look like mathematical notation.
12:14:43 <Fuuzetsu> @info Num
12:14:44 <lambdabot> Num
12:14:46 <monochrom> some Num users don't want Eq
12:14:48 <Fuuzetsu> th-thanks
12:14:49 <mauke> Fuuzetsu: there never has been an @info command
12:14:53 <Hafydd> After all, that's what motivated the use of \ and -> and ::, too.
12:15:02 <mauke> Hafydd: \ is mathematical notation
12:15:04 <Fuuzetsu> I swear we had a command to do the equivalent of :i for the first few lines at least…
12:15:12 <c_wraith> enigmuriatic: and more generally, because there are some numeric types for which equality is not computable.  Like CReal
12:15:12 <mauke> Fuuzetsu: no
12:15:18 <ski> @src Num
12:15:18 <lambdabot> class  (Eq a, Show a) => Num a  where
12:15:18 <lambdabot>     (+), (-), (*)           :: a -> a -> a
12:15:18 <lambdabot>     negate, abs, signum     :: a -> a
12:15:18 <lambdabot>     fromInteger             :: Integer -> a
12:15:21 <ski> does something else
12:15:21 <mauke> Fuuzetsu: we have @src and @hoogle
12:15:25 <Hafydd> mauke: yes. What is your point?
12:15:32 <Fuuzetsu> @src will do for small classes I guess
12:15:32 <lambdabot> Source not found. I am sorry.
12:15:51 <mauke> Hafydd: so if all you want is to make it look mathy, why pick λ specifically?
12:16:11 <ski> @where src
12:16:11 <lambdabot> The fixed database for the `src' lambdabot command is at <http://code.haskell.org/lambdabot/State/source>
12:16:13 <Hafydd> mauke: are we talking about lambda abstractions or variable names?
12:16:16 <Fuuzetsu> …because \ stands for lambda, that is λ
12:16:22 <mauke> Fuuzetsu: I disagree
12:16:37 <Fuuzetsu> mauke: That doesn't change anything
12:16:39 <typoclass> Hafydd: if he has a point, he'll be as difficult as he can before he will reveal it. you'll have to ask tons of questions before he'll state his point
12:16:48 <mauke> typoclass: stop trolling
12:16:59 <monochrom> ok, take this to pm. no, not even #haskell-blah, this is garbage.
12:17:07 <elliott> typoclass: there is no need to make this personal
12:17:35 <chrisdotcode_> join #haskell-blah
12:17:38 <chrisdotcode_> oops xD
12:17:48 <FreeFull> They're called lambdas probably because lisp called them lambdas, and some relation to lambda calculus
12:18:05 <chrisdotcode_> but while attention has been drawn to myself, how can you tell what typeclasses a type is a part of?
12:18:15 <Hafydd> :i
12:18:17 <mauke> chrisdotcode_: you can't really
12:18:26 <mauke> chrisdotcode_: instances could be hidden in every module
12:18:30 <monochrom> in ghci, :info Int (for example)
12:18:33 <elliott> you can use :i in GHCi to see the ones in scope
12:18:36 <chrisdotcode_> mauke: I figured that, at a certain point, that was the case
12:18:39 <chrisdotcode_> elliott: yeah, okay
12:18:41 <chrisdotcode_> that's what I was looking for
12:18:46 <chrisdotcode_> `:i`
12:18:47 <chrisdotcode_> thanks guys
12:18:50 <chrisdotcode_> :i Integer
12:18:52 <monochrom> you can also :info Num
12:18:58 <monochrom> but lambdabot won't do it
12:19:01 <chrisdotcode_> gah...
12:19:01 <FreeFull> :info Integer
12:19:08 <FreeFull> Yeah, lambdabot doesn't do it
12:19:17 <elliott> haddock has instance lists, though
12:19:17 <chrisdotcode_> okay, but cool
12:19:24 <chrisdotcode_> that's awesome though
12:19:25 <tippenein> ".ghci is writable by someone else, IGNORING"  <-- I fixed this once, remind me how again?
12:19:27 <chrisdotcode_> \thanks guys :D
12:19:40 <mauke> tippenein: chmod 0644 ~/.ghci
12:19:44 <elliott> tippenein: perhaps chmod 644 ~/.ghci
12:19:48 <tippenein> thanks ;)
12:20:16 <monochrom> the "someone else" is "group-writable"
12:20:20 <boothead> Anyone got any experience with io-streams? I'm getting my self in a pickle!
12:20:37 <tippenein> yah, I always forget the 0 in 0644
12:20:49 <mauke> tippenein: that 0 usually doesn't do anything
12:20:59 <monochrom> I never needed the 0. "chmod 644 .ghci" here literally and works
12:21:07 <mauke> C habit
12:22:07 <monochrom> but every time I do have to convert binary to octal
12:22:31 <Earnestly> The '0' number is sticky or not
12:22:50 <FreeFull> I tend to use the  u+rw etc syntax
12:22:53 <Earnestly> https://en.wikipedia.org/wiki/Sticky_bit
12:22:58 <monochrom> true, it could be 2 or something instead
12:22:59 <mauke> Earnestly: yeah, but it's implicit in chmod(1)
12:23:03 <Earnestly> Indeed
12:23:16 <mm_freak> Jeanne-Kamikaze: right now i'd like to focus on implementation rather than tutorializing…  i'm working hard on a new major version
12:23:20 <mauke> FreeFull: I never use relative modes
12:23:40 <Jeanne-Kamikaze> oh I see
12:28:26 <steven_is_false> Hi! Am I missing something, or does this code entirely reimplement GADTs in pure Haskell without any extensions (at possible a slight performance cost, and less syntactic sugar?) https://gist.github.com/sstewartgallus/5622481
12:28:42 * elliott confidentaly predicts the former, and then clicks.
12:28:57 <elliott> post-clicking: unsafeCoerce is not part of pure Haskell
12:29:01 <johnw> it's not that hard to implement GADTs without extensions
12:29:03 <elliott> it's not in the standrd
12:29:12 <johnw> see http://www.haskellforall.com/2012/06/gadts.html
12:29:15 <elliott> sure it is, it's impossible :P
12:29:31 <steven_is_false> Shoot. Okay, so aside from unsafeCoerce though which is a tiny extension.
12:29:32 <johnw> elliott: which extension is required?
12:29:37 <elliott> that post uses rank2types, it says so at the top
12:29:48 <johnw> doh
12:29:55 <johnw> i need an extension, clearly
12:30:02 <elliott> steven_is_false: it's a really terrible extension -- of course you can do whatever you want with the type system if you break it completely :P
12:30:13 <elliott> however, consider Rank2Types, and this definition of Is:
12:30:18 <elliott> type Is a b = forall p. p a -> p b
12:30:33 <elliott> another thing is that GADTs let you do existentials as well, but luckily rank-2 types can encode those as well
12:30:54 <elliott> btw, I think you mean to call reflexive "symmetric" or the like instead
12:31:04 <elliott> ("reflexive" would be the name for "Is a a")
12:31:04 <dolio> It also uses existential quantification.
12:31:17 <dolio> Despite saying that rank-2 types cover that, I don't think they do.
12:31:34 <dolio> Unless you encode them as higher-rank types.
12:31:39 <steven_is_false> elliot: Your probable right about reflexive, and symmetric. I can never keep the name of algebraic properties straight in my head.
12:31:50 <elliott> oh, I guess you need rank-3 for GADTs
12:32:12 <elliott> Rank2Types is deprecated in favour of RankNTypes anyway
12:32:18 <elliott> or, er, wait, never mind me.
12:33:29 <steven_is_false> elliot: I don't view unsafeCoerce as a terrible bad thing. I view as a way to extend the type system. The rank2types way of implementing GADTs is elegant though.
12:37:24 <mm_freak> johnw: you need GADTs for type refinement, which is part of the GADTs extension
12:38:14 <mm_freak> steven_is_false: i view unsafeCoerce as a hack to implement Dynamic and SomeException
12:38:19 <mm_freak> nothing else
12:38:24 <johnw> lens? :)
12:38:45 <steven_is_false> So in the style of the rank2Types implementation an Oop language like Vala (it's like C# but I forget if C# has higher order generics) one could implement GADTs with an Is <A, B> interface, and a F <B> is <F> (F <A> value) method?
12:39:08 <enigmuriatic> say you want to take a list of ints and return a list of lists, the original list split at zeroes. ex myfunc [1,2,0,4,6,0,0,3,4] = [[1,2],[4,6],[3,4]]
12:39:17 <mm_freak> steven_is_false: no, because that still doesn't give you type refinement
12:39:18 <enigmuriatic> how would you do it?
12:39:24 <enigmuriatic> (no, this is not homework)
12:39:31 <mm_freak> one of the core features of GADTs is pattern-matching with type refinement
12:39:49 <mm_freak> example:  f :: X a -> a
12:39:53 <mm_freak> f (X x) = x + x
12:40:11 <ski> mm_freak : .. and `reflection'
12:40:33 <steven_is_false> nm_freak: I don't follow. Shouldn't passing around proofs of whether or not a type A is a type B just work?
12:40:34 <elliott> unsafeCoerce isn't needed for Dynamic
12:40:34 <steven_is_false>  
12:40:38 <FreeFull> enigmuriatic: I'd use splitOn from the split library
12:40:40 <elliott> Dynamic is just an existential
12:40:49 <elliott> mm_freak: you can do that with rank 2
12:41:10 <dolio> elliott: It is if you want to get something out without a better typeable than GHC has.
12:41:16 <mm_freak> elliott: data Dynamic = forall a. (Typeable a) => D a
12:41:17 <mm_freak> right?
12:41:21 <elliott> dolio: you can just use cast, no?
12:41:23 <ski> enigmuriatic : not `[[1,2],[4,6],[],[3,4]]' ?
12:41:29 <dolio> elliott: How are you going to implement cast?
12:41:32 <elliott> I think I've done this as a proof of concept
12:41:36 <elliott> dolio: Typeable provides cast.
12:41:37 <enigmuriatic> ah thanks FreeFullski, no
12:41:49 <dolio> With unsafeCoerce.
12:41:52 <enigmuriatic> (that was meant to be two messages
12:41:52 <elliott> sure
12:41:53 <enigmuriatic> )
12:41:53 <dmwit> sclv_: http://stackoverflow.com/q/16678165/791604
12:41:59 <elliott> but Data.Dynamic's implementation uses additional unsafeCoerces on top of that
12:42:00 <enigmuriatic> (that was mean to be one :P )
12:42:02 <elliott> but it doesn't have to
12:42:03 <enigmuriatic> *meant
12:42:06 <dolio> It does?
12:42:08 <elliott> yes
12:42:11 <dolio> Geeze.
12:42:11 <dmwit> ?tell frerich You might be interested in following http://stackoverflow.com/q/16678165/791604, where I asked your question from the other day.
12:42:11 <lambdabot> Consider it noted.
12:42:15 <elliott> it's like Dynamic !TypeRep !Any
12:42:19 <elliott> for, I don't know, performance ors omething
12:42:23 <mm_freak> elliott: using 'cast' from Data.Typeable isn't exactly "without unsafeCoerce" ;)
12:42:37 <dolio> Oh, checks the type reps and then coerces directly.
12:42:50 <mm_freak> steven_is_false: i don't follow
12:43:02 <elliott> mm_freak: anyway: type Is a b = forall p. p a -> p b; data Expr a = EConst a | EAdd (Is a Int) (Expr a) (Expr a) | EShow (Is a String) (Expr Int). you can write eval :: Expr a -> a with this
12:43:44 <elliott> and the translation from normal GADT code is mechanical
12:44:29 <mm_freak> elliott: that's not really type refinement…  you're actually keeping a casting function
12:44:32 <elliott> actually, the recursive arguments to EAdd should be (Expr Int) to better reflect how you'd write it as a GADT, though it doesn't matter
12:45:13 <mm_freak> f (X x) = x + x  -- still wouldn't work
12:45:18 <mm_freak> f (X cast x) = …
12:45:21 <mm_freak> that's your variant
12:45:27 <elliott> of course the syntax is different.
12:45:35 <dolio> That is a superficial difference.
12:45:43 <dolio> You can also encode Expr differently.
12:45:46 <steven_is_false> nm_freak: What's the difference between newtype Is a b = Is (forall p. p a -> p b), and interface Is <A, B> { public F <B> is <F> (F <A> value); } in terms of power? I don't doubt that some of the automatic inference, and syntax sugar for GADTs is nice but that's something that is a matter of preference.
12:45:53 <elliott> you also cannot say "data ... where ..." without the GADTs extension, but that's also irrelevant
12:45:57 <ski> @hoogle (forall a. Typeable a => a -> o) -> o -> (Dynamic -> o)
12:45:59 <lambdabot> Data.Generics.Aliases mkQ :: (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
12:45:59 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
12:45:59 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
12:46:17 <mm_freak> you can also say that brainfuck has support for higher order functions
12:46:39 <mm_freak> this is not type refinement, period
12:46:53 <elliott> that comparison is nonsense. the question is "can GADTs be reduced to rank-2 + existentials?" the answer is yes
12:47:07 <elliott> and the translation is very simple and direct
12:48:23 <steven_is_false> elliott: Thank you for helping me out with this. In particular, the forall p. p a -> p b formulation of the Is type was quite interesting.
12:48:30 <mm_freak> elliott: the point is that GADTs makes the type system smarter in that it allows some inference to happen automatically…  that's type refinement
12:48:58 <elliott> steven_is_false: it's due to leibniz :)
12:49:12 <elliott> steven_is_false: edwardk's http://hackage.haskell.org/package/eq is based on it
12:49:56 <dmwit> I guess the point is that the compiler is doing nice things for you by constructing, destructing, and applying casts for you at appropriate points.
12:49:57 <elliott> mm_freak: ok, well, I don't really know what your point is. I agree the GADTs extension gives a less noisy syntax, though one that can be simply translated into the rank-2 form
12:50:16 <steven_is_false> elloitt: Thanks. I've always meant to look more closely at edwardk's stuff but it's a pretty big stack to learn.
12:50:16 <dolio> You can encode in such a way that 'f e = e (\x -> x + x)' is the expression you write.
12:50:23 <dolio> No applying coercions.
12:50:34 <dmwit> cool!
12:50:39 <mm_freak> dmwit: rather that you don't cast at all…  the compiler is smart enough to /know/ that a given type is actually more concrete
12:51:03 <dmwit> mm_freak: I guess the Core still does coercions, no?
12:51:08 <mm_freak> no
12:51:18 <dolio> There are some things that GHC does that you can't just do with existentials and rank-n types.
12:51:18 <dmwit> um
12:51:31 <dolio> But we haven't had anyone mention them yet.
12:51:50 <mm_freak> just like the core doesn't coerce for polymorphic functions
12:52:01 <mm_freak> f :: (forall a. (Random a) => m a) -> m (Int, Integer)
12:52:02 <elliott> dolio: like how -XGADTs lets you prove (forall p. p Bool -> p Foo) -> Void given data Foo = A | B?
12:52:09 <mm_freak> no coercion going on there
12:52:13 <elliott> (but -XRankNTypes doesn't)
12:52:15 <dolio> Yes.
12:52:32 <elliott> right
12:52:54 <elliott> in the rank-2 form those correspond to where you'd put error "help this is impossible" under the assumption that nobody wrote a univalent Haskell implementation
12:52:54 <dolio> Injecitivity/disjointness of type constructors is a separate thing that gets bundled in.
12:53:01 <Eduard_Munteanu> Err... I don't see how that's provable. :/
12:53:36 <elliott> Eduard_Munteanu: http://stackoverflow.com/questions/14273235/can-gadts-be-used-to-prove-type-inequalities-in-ghc/14277376#14277376
12:53:51 <elliott> (easy to reformulate that to use a GADT rather than TFs)
12:54:44 <enigmuriatic> what's the edge case when you're generating a list of lists?
12:54:57 <enigmuriatic> if i use myfunc [] = [] i just get an endless string of []
12:55:05 <enigmuriatic> *list
12:55:08 <Hafydd> elliott, does that mean "help! this is impossible!", or "helping this is impossible."?
12:55:22 <monochrom> I don't understand the question
12:55:56 <elliott> Hafydd: the former, but the latter applies too :P
12:56:10 <dolio> enigmuriatic: It's going to depend on your function.
12:56:35 <mm_freak> after all that's my whole point…  when type-refining no coercion is going on at all, because the type system /knows/ the type
12:57:08 <chrisdotcode_> can you guys help me with this:
12:57:08 <chrisdotcode_> "main = do
12:57:09 <chrisdotcode_> a <- [1, 2, 3]
12:57:09 <chrisdotcode_> return $ show a"
12:57:09 <chrisdotcode_> I keep getting "Couldn't match expected type `IO t0' with actual type `[String]'"
12:57:10 <dolio> No coercion goes on in my encoding, either.
12:57:50 <ski> chrisdotcode_ : `main' should have type `IO Foo', for some type `Foo'
12:57:53 * elliott can roughly see how dolio's encoding would work but is interested in the details
12:57:55 <FreeFull> chrisdotcode_: main has to be an IO a, but your main is a [String]
12:58:02 <chrisdotcode_> that much I know
12:58:07 <chrisdotcode_> so how do I get that?
12:58:10 <otters> let a = [1,2,3]
12:58:24 <chrisdotcode_> OHHH
12:58:28 <FreeFull> chrisdotcode_: I think you want   main = print [1,2,3]    or something like that
12:58:33 <chrisdotcode_> because a <- unwraps a monad?
12:58:48 <chrisdotcode_> FreeFull: yeah, that is what I wnat
12:58:51 <otters> <- is sugar for >>=
12:58:57 <chrisdotcode_> otters: okay, that's what I figured
12:58:59 <johnw> yes, <- does not unwrap a monad
12:59:01 <monochrom> I disagree that it is "unwrap", but you can say that for now
12:59:06 <otters> which binds the result of a monadic "computation" or whatever you like to call it
12:59:12 <chrisdotcode_> I'm using a pure fuction for the value of a, so I wouldn't need the monad
12:59:13 <ski> `<-' is how you "sequence" an execution of a monadic action, in a `do'-block
12:59:14 <mm_freak> dolio: yes, your encoding seems to be more sensible…  that's what i would do if GADTs weren't there
12:59:24 <chrisdotcode_> okay, thanks guys :-)
12:59:37 <johnw> an easy #haskell troll move: compare monads with containers somehow :)
12:59:41 <FreeFull> chrisdotcode_:    a <- [1,2,3]   is valid code when you are operating in the list monad
13:00:08 <chrisdotcode_> FreeFull: right, but here I just wanted to print said list
13:00:13 <mm_freak> dolio: but wait, your f e = e (\x -> x + x), would be a type error
13:00:15 <dolio> elliott: It's the same construction as Church encoding, but in a category of indexed types.
13:00:28 <FreeFull> chrisdotcode_: You can use the print function to print most things
13:00:37 <steven_is_false> elliott: I got a question about my original implementation of GADTs versus some of the alternatives shown here. Which encoding of GADTs is fastest?
13:00:44 <otters> johnw: I just try not to think about what monads are and instead just about how to use them
13:00:47 <otters> heh
13:00:50 <dolio> mm_freak: What GADT are we talking about?
13:00:55 <chrisdotcode_> FreeFull: does print wrap show?
13:00:59 <ion> johnw: so monads are just a special case of foldr?
13:01:11 <quchen> chrisdotcode_: print = putStrLn . show
13:01:21 <johnw> ion: lol
13:01:28 <ski> @src print
13:01:28 <lambdabot> print x = putStrLn (show x)
13:01:35 <mm_freak> dolio: i'm assuming this representation:  data X a = X ((forall b. (Num b) => b -> a) -> a)
13:01:41 <chrisdotcode_> well that's convinient :)
13:01:51 <dolio> mm_freak: What's the original GADT?
13:01:57 <chrisdotcode_> :t putStrLn
13:01:58 <lambdabot> String -> IO ()
13:02:02 <chrisdotcode_> thought so
13:02:06 <mm_freak> dolio: data X :: * -> * where X :: (Num a) => a -> X a
13:02:14 <elliott> steven_is_false: presumably the unsafeCoerce one if any
13:02:32 <mm_freak> dolio: and a function:  f :: X a -> a
13:02:38 <mm_freak> that, for X x would return x + x
13:02:52 <steven_is_false> elliott: Well I guess I'll have to benchmark then.
13:03:16 <dolio> Okay. The encoding for that is: X a = forall (r :: * -> *). (forall b. Num b => b -> r b) -> r a
13:03:22 <dolio> Unless I messed something up.
13:03:54 <elliott> steven_is_false: but also there's a chance the casting function will be optimised away, since it's just id always
13:03:56 <mm_freak> dolio: i have to digest that, but doesn't that require CPS-transforming f as well?
13:03:59 <elliott> depends how well things get inlined
13:04:39 <dolio> It is encoding X by its eliminator.
13:04:53 <dolio> So you have to use an eliminator instead of case analysis.
13:04:56 <enigmuriatic> why doesn't this implementation of splitOn work? http://hpaste.org/88320
13:05:22 <steven_is_false> elliott: So a real implementation should have lots of {-# INLINE #-} junk, and such?
13:05:28 <dolio> You could write 'elimX = id' and then use 'elimX e (\x -> x + x)' or something.
13:05:33 <quchen> enigmuriatic:  "Doesn't work" is not an error description we can help you much with.
13:05:37 <dolio> Instead of 'case e of X x -> x + x'
13:06:26 <mm_freak> dolio: i understand the basic idea…  i just don't think it would work the way you wrote it
13:06:29 <johnw> enigmuriatic: don't you just want groupBy?
13:06:31 <monochrom> enigmuriatic: what is it supposed to do?
13:06:32 <mm_freak> remember escaping type variables
13:06:35 <steven_is_false> I'm going to go out on a limb, and guess that the built in compiler extension is the fastest implementation probable.
13:06:57 <dmwit> enigmuriatic: Perhaps you meant first : splitOn (tail second)
13:07:13 <monochrom> > break (/= 0) []
13:07:14 <lambdabot>   ([],[])
13:07:27 <steven_is_false> Thanks.
13:07:28 <monochrom> > tail []
13:07:29 <lambdabot>   *Exception: Prelude.tail: empty list
13:07:41 <mm_freak> dolio: in '\x -> x + x' the type variable escapes, so you need some form of wrapper
13:07:47 <dmwit> Yes, there are other bugs, too. =)
13:07:59 <monochrom> there are many things wrong with this
13:08:16 <dolio> The only thing wrong with that example is that '\x -> x + x' doesn't have type forall b. Num b => b -> r b
13:08:31 <dolio> Because GHC isn't a system where you can fill in an r that will make that work.
13:08:36 <dolio> So you'd need to use Identity.
13:08:53 <dmwit> > break (/= 0) [0]
13:08:54 <lambdabot>   ([0],[])
13:09:07 <dolio> Not that I want them to 'fix' that situation.
13:09:14 <mm_freak> dolio: that would work, but then you need to CPS-transform f
13:09:23 <mm_freak> or use an existential wrapper
13:09:25 <dolio> What?
13:09:36 <dolio> You just write f :: Expr a -> Identity a.
13:09:48 <dolio> f e = e (\x -> Identity $ x  + x)
13:10:31 * elliott doesn't see where the CPS comes in
13:10:52 <mm_freak> elliott: dolio's representation is CPS-transformed
13:10:59 <dolio> Or f :: Expr a -> a ; f e = runIdentity $ e (\x -> Identity $ x + x)
13:11:00 <johnw> > foldr (\x ys -> if x == 0 then []:ys else (x:head ys):tail ys) [[]] [1,2,3,0,4,0,5]
13:11:02 <lambdabot>   [[1,2,3],[4],[5]]
13:11:03 <johnw> enigmuriatic: ^^%
13:11:09 <monochrom> oh well, I guess he/she wants a spin doctor to give a mysterious fix. I am a scientist and engineer, I don't give mysterious fixes.
13:11:34 <enigmuriatic> me?
13:11:38 <dolio> Okay. Then foldr is the cps-transformed way of writing recursive functions with pattern matching on lists.
13:11:43 <johnw> isn't that the kind of function you wanted?
13:11:49 <enigmuriatic> yeah, thanks
13:11:53 <mm_freak> dolio: i have to digest that…
13:12:35 <mm_freak> anyway, i'm glad that we have GADTs ;)
13:12:49 <Eduard_Munteanu> egadts
13:13:10 * Eduard_Munteanu wants ZOMGs
13:13:25 <mm_freak> hmm…  "GADTs"…  "gadgets"…
13:13:33 <typoclass> Eduard_Munteanu: please refer to https://i.chzbgr.com/maxW500/602488064/h6FE9E0EA/
13:13:42 <dmwit> > map (map read) . map words . lines . unwords . map (\x -> if x == 0 then "\n" else show x) $ [1,2,3,0,4,0,5]
13:13:43 <lambdabot>   [[*Exception: Prelude.read: no parse
13:13:53 <Eduard_Munteanu> Yay.
13:13:56 <dmwit> > map (map read) . map words . lines . unwords . map (\x -> if x == 0 then "\n" else show x) $ [1,2,3,0,4,0,5] :: [[Integer]]
13:13:58 <lambdabot>   [[1,2,3],[4],[5]]
13:14:32 <dmwit> This is the PHP way.
13:15:00 <dolio> I think doing this with GADTs is far superior, as well.
13:15:23 <dolio> I don't like working with encodings like that, but you can do it.
13:16:16 <monochrom> haha dmwit
13:16:37 <mm_freak> dolio: it's an interesting encoding nevertheless…  the funny thing is that i have used encodings like that in the past, but never quite seen the relationship with GADTs
13:17:05 <dolio> mm_freak: It's the same kind of way of encoding a list.
13:17:20 <dolio> forall r. (a -> r -> r) -> r -> r ~ [a]
13:17:33 <mm_freak> dolio: yeah, i know that one
13:17:44 <dolio> Except since you're encoding an indexed type, you use an indexed type for the 'result'.
13:17:53 <dolio> forall (r :: * -> *). ...
13:18:15 <dolio> And then you can refine the index of r in each 'constructor'.
13:18:18 <johnw> dolio that shouldn't be (a -> r -> r) -> [r -> r]?
13:18:36 <mm_freak> dolio: now i get what you mean by "indexed"…  inductive families, where the index is to the right of the ":"
13:19:06 <dolio> johnw: I don't think so.
13:19:15 <johnw> you can change the functor in yoneda like that?
13:19:20 <arkeet> johnw: nope.
13:19:25 <mm_freak> johnw: type List a = forall r. (a -> r -> r) -> r -> r
13:19:32 <mm_freak> does that make more sense?
13:19:34 <johnw> yes
13:19:36 <johnw> thank you
13:19:47 <johnw> i thought he was expresses yoneda's lemma for the [] functor
13:19:51 <johnw> ing
13:19:54 <dolio> Ah, no.
13:20:15 <johnw> it's an interesting coincidence then
13:20:22 <mm_freak> is it actually "yoneda's lemma" or rather the "yoneda lemma"?
13:20:22 <dolio> That'd be [a] ~ forall r. (a -> r) -> [r]
13:20:28 <johnw> that (->) r can stand in for [] on the left side and still be isomorphic
13:20:52 <johnw> mm_freak: I've read both, so I've never been sure.  I prefer yoneda's actually
13:21:26 <arkeet> I've never seen "yoneda's lemma"
13:21:41 <mm_freak> i remember reading that it was named after yoneda, but it didn't imply that mr. yoneda actually came up with it
13:23:09 <aristid> johnw: didn't you want to make a release? :)
13:23:20 <johnw> aristid: I did, 0.7.6.4, two nights ago
13:23:33 <johnw> aws is now in Stackage, btw
13:23:48 <aristid> johnw: why does it not show up in the stable branch?
13:23:56 <johnw> let me make sure I pushed
13:23:59 <johnw> i did push my tag
13:24:12 <johnw> doh
13:24:15 <johnw> pushing now
13:24:16 <johnw> done
13:25:16 <mm_freak> btw, what's the most general formulation of the yoneda lemma that applies to haskell?  forall f. (Functor f) => f a ~ forall r. (a -> r) -> f r?
13:25:32 <johnw> that's the one that I know
13:25:37 <aristid> johnw: hmm i remember there being some problem with meteficha's pull request if you had an older version of some package... but i don't remember in detail and my setup is a bit of a mess right now
13:27:09 <enigmuriatic> splitOn = foldl (\acc x:xs -> if x == 0 then []:acc else (x:head acc):tail acc) [[]]
13:27:24 <enigmuriatic> why can't this parse at the semicolon?
13:27:44 <dmwit> add parentheses around the list
13:27:54 <dmwit> otherwise it's trying to parse it as (acc x) : xs, which isn't a real pattern.
13:28:32 <enigmuriatic> i used to understand how Haskell parsing works. i don't anymore. :/
13:28:46 <enigmuriatic> $ threw me off big-time
13:29:04 <ion> $ is just an operator.
13:29:06 <quchen> $ is like an opening parenthesis that reaches to the end of the line.
13:29:11 <dmwit> Function application binds tighter than almost everything else.
13:29:14 <int-e> enigmuriatic: do you wat  \acc (x:xs) -> .. ?
13:29:15 <quchen> (Or subexpression)
13:29:18 <johnw> enigmuriatic: why would you want that to be foldl, anyway?  you're dealing with lists and foldr will give you a lazy result
13:29:24 <Cale> also to the beginning of the line
13:29:38 <quchen> Huh?
13:29:39 <Cale> f $ x is f x, but with really low precedence
13:29:47 <ion> f $ x = f x; infixr 0 $  -- 0 is the lowest precedence
13:29:53 <dmwit> Cale: unfortunately, that's not true in current Haskell
13:30:05 <Cale> So, it's a bit like putting parens around f as well
13:30:06 <sclv_> the yoneda lemma is in fact due to yoneda
13:30:07 <dmwit> f $ g $ x isn't like (f $ g) (x). =)
13:30:22 <sclv_> but it was derived from an informal conversation he had with mac lane i think
13:30:23 <int-e> dmwit: hah
13:30:36 <sclv_> so mac lane presented it formally for the first time, attributing it to yoneda
13:30:50 <int-e> dmwit: I disagree with the "unfortunately" though; I sort of like being able to write   return $ f . h . h $ x :)
13:30:51 <sclv_> yoneda, incidentally, went on to do computer science and worked on the specs for algol
13:30:53 <Cale> dmwit: Well, yeah, but the assumption here is that you don't have anything else at that precedence level :)
13:31:10 <Cale> int-e: What's wrong with  return . f . h . h $ x?
13:31:14 <sclv_> there's v. little material regarding his work and career available in english, unfortunately
13:31:26 <mm_freak> sclv_: interesting, thanks
13:31:43 <mekeor> how is it possible that on hackage there's highlighting-kate-0.5.3.9 while on the official git-repository the cabal-file (<https://github.com/jgm/highlighting-kate/blob/master/highlighting-kate.cabal>) still states "0.5.3.8" (and there aren't even other (relevant) branches).
13:32:03 <quchen> Cale: I like my "return $". Or maybe "return $!".
13:32:06 <mekeor> *?
13:32:07 <int-e> Cale: there's nothing wrong with it. But I think of the $ as a kind of full stop, "return what follows" and the rest as the value being returned.
13:32:11 <enigmuriatic> splitOn = foldr (\acc (x:xs) -> if x == 0 then []:acc else (x:head acc):tail acc) [[]]
13:32:18 <dmwit> mekeor: Easy. Somebody did some coding without pushing to the official repo.
13:32:27 <int-e> the $! option is a better point.
13:32:27 <mekeor> dmwit: AH!
13:32:28 <enigmuriatic> Occurs check: cannot construct the infinite type: a0 = [a0]
13:32:29 <enigmuriatic>     In the first argument of `(:)', namely `x'
13:32:30 <dmwit> mekeor: Ain't DVCS grand?
13:32:31 <enigmuriatic> its telling me that
13:32:41 <johnw> enigmuriatic: foldr reverses the arguments to the function
13:32:49 <mekeor> dmwit: crap
13:33:17 <Cale> (relative to foldl)
13:33:21 <johnw> enigmuriatic: so, \(x:xs) acc.  and call it rest instead of acc, because it's more accurate
13:33:29 <mm_freak> consider the following functor class:  class (Category c, Category d) => Functor f c d where fmap :: c a b -> d (f a) (f b)
13:33:42 <mm_freak> does the same formulation apply to these functors?
13:33:49 <dmwit> acc seems fine to me
13:34:00 <mm_freak> f a ~ (a -> r) -> f r
13:34:08 <johnw> eh, shachaf has complained to me about acc before, and I saw his point
13:34:12 <Cale> dmwit: It's not accumulating anything though.
13:34:15 <int-e> Cale: and I honestly don't know which choice would be better. I've seen enough people trip over  foo $ bar $ baz  not meaning  foo bar baz.
13:34:23 <dmwit> It's the accumulated value from the remainder of the fold.
13:34:28 <quchen> Well, "go" isn't "going" anything either.
13:34:40 <quchen> acc is somewhat standard and recognized.
13:34:49 <typoclass> johnw: oh, very good point by the way
13:34:56 <mm_freak> (add the missing forall r)
13:35:01 <Cale> int-e: Yeah, I think $! is pretty significantly more useful as a left associative operator, and it wouldn't make sense for it to have a different associativity from $
13:35:08 <mekeor> dmwit: if i install a new version of the package A which package B depends on, do i have to reinstall B such that it uses the new version of A? yes, right?
13:35:21 <dmwit> yes
13:35:26 <dmwit> or rather, maybe
13:35:27 <mekeor> dmwit: thanks :)
13:35:30 <mekeor> O.o
13:35:38 <mekeor> dmwit: or rather, probably?
13:35:44 <dmwit> If you install a new copy of A at the same version as before, you have to reinstall B.
13:35:57 <Cale> dmwit: Except that if you're thinking operationally, you have it backward then, that "accumulation" has yet to occur.
13:35:58 <dmwit> If you install a new copy of A at a different version than it ever has had before, B will be fine.
13:36:02 <mekeor> dmwit: it's a new version
13:36:08 <dmwit> Cale: Solution: don't think operationally.
13:36:08 <user123abc> does hackage not have any special format for specifying the fixity of operators?
13:36:11 <mekeor> dmwit: oh okay
13:36:17 <mekeor> dmwit: even it's an older version O.o
13:36:23 <mekeor> *?
13:36:24 <Cale> dmwit: Well, it's hard to think about it as accumulating then
13:36:25 <dmwit> mekeor: even then
13:36:28 <Cale> I dunno
13:36:30 <user123abc> new to haskell and looking at $ docs to confirm that it's infixr
13:36:33 <user123abc> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:-36-
13:36:42 <user123abc> only mentioned in text - should I expect that in general
13:36:45 <dmwit> Cale: That is why I said it is an accumulation, not that it is accumulating. =)
13:36:50 <quchen> user123abc: use :i in GHCi. Other than that I think you have to look at the source.
13:36:58 <Cale> user123abc: That's right, it is infixr, but this is a point of minor contention. Some of us view that fact as a mistake.
13:37:03 <dmwit> Cale: Saying what it is rather than what it's doing is a denotational rather than operational statement. =)
13:37:04 <typoclass> user123abc: i think not directly. you'd have to click "source" on the right hand side of the haddocks, and with any luck the infixr/infixl statement will be close by the function definintion
13:37:06 <mekeor> dmwit: but does B *use* the most recently installed A?
13:37:14 <user123abc> typoclass, ah, thanks!
13:37:19 <dmwit> mekeor: It doesn't.
13:37:48 <user123abc> Cale, well, I was trying to understand why it works, and if I saw that it was infixr, I'd know that my understanding of the issues are correct
13:37:57 <user123abc> wouldn't it not work otherwise?
13:38:05 <user123abc> (supposing you wanted some operator to make parens go away)
13:38:06 <mekeor> dmwit: i see, got it, thanks :
13:38:11 <mekeor> *)
13:38:20 <typoclass> user123abc: if i'm writing code, i just put in some more parens. i generally can't be bothered to memorize tons of operator precedence :-) but if you're reading code someone else has written, you're probably out of luck
13:38:23 <Cale> user123abc: It wouldn't work the same way, but it would actually let you get rid of more parens if it were left associative
13:38:48 <Cale> user123abc: Presently, whenever you have f $ g $ h $ x, you can generally rewrite that as f . g . h $ x
13:39:00 <c_wraith> yeah, darn the the f (g x) y case!
13:39:07 <Cale> user123abc: so the right associativity can be made not to matter
13:39:16 <Cale> (because there's only one $ at that point)
13:39:31 <dolio> mekeor: bos updated one of my packages once, so there was a version by him on Hackage newer than anything I had. :)
13:39:35 <Cale> But if you have an expression like f (g x) (h y) (k z)
13:39:42 <otters> we should make a new operator
13:39:44 <user123abc> it seems like it wouldn't be any different from regular old function application then, but I'm just learning so maybe I should go read stuff before making you explain further
13:39:56 <Cale> If $ were left associative, we could have written that as  f $ g x $ h y $ k z
13:40:05 <Cale> But we can't because it isn't.
13:40:10 <dmwit> :t let (f .! g) x = f $! g x in (.!)
13:40:10 <mekeor> dolio: yeah that'd be also a possibility... :)
13:40:14 <lambdabot> (a -> b) -> (t -> a) -> t -> b
13:40:14 <dolio> Oh yeah. Are we going to fix that when we burn our bridges?
13:40:20 <Cale> and adding yet another kind of function application is... kind of ridiculous
13:40:44 <quchen> Cale: flip (.)? :-)
13:40:44 <chrisdotcode_> factorial 24
13:40:47 <chrisdotcode_> > factorial 24
13:40:49 <lambdabot>   Not in scope: `factorial'
13:40:52 <dmwit> Cale: How about letting ($!) be infixl, too, and adding (.!)? =)
13:40:52 <typoclass> Cale: we're doing functional programming. we should have dozens of function applications
13:40:54 <Cale> (not to mention there aren't many good symbols left for it, and using one of the remaining symbols up is annoying)
13:40:54 <typoclass> =)
13:40:58 <chrisdotcode_> @hoogle factorial
13:40:58 <lambdabot> No results found
13:41:00 <FreeFull> $$$$
13:41:11 <dmwit> > product [1..24]
13:41:12 <Cale> dmwit: I would love for $! to be infixl too
13:41:13 <lambdabot>   620448401733239439360000
13:41:29 <chrisdotcode_> dmwit: thanks (should have thought of that...)
13:41:35 <typoclass> Cale: so, on a more serious note, € ?
13:41:36 <Cale> dmwit: That's actually one of the main reasons why left associative $ is nice, because it works well with a left associative $!
13:41:42 <Cale> typoclass: I can't type that
13:41:49 <Cale> or, maybe I can...
13:41:52 <typoclass> Cale: oh i see
13:41:52 <Cale> €
13:41:56 <FreeFull> $^ maybe?
13:42:00 <otters> what about £
13:42:01 <Cale> yes, but it's three keystrokes
13:42:05 <otters> or ∞
13:42:07 <typoclass> Cale: it's altgr-e for me, but who knows if you even have altgr ...
13:42:12 <Cale> I don't
13:42:19 <quchen> Let me get my snowman out from the unmaintainable code file
13:42:21 <Cale> I have compose, but many people don't have compose either
13:42:28 <FreeFull> altgr-4 for me, and shift+altgr for compose
13:42:29 <otters> ☃
13:42:33 <otters> is a good operator
13:42:38 <quchen> Jesus, why did you have to bring compose up again.
13:42:40 <Fuuzetsu> compose + Agda mode reporting in
13:42:41 <quchen> I just recovered.
13:43:11 <typoclass> £ would be a possibility, it's mapped by default for me (german layout)
13:43:25 <FreeFull> ǻ
13:43:40 <Fuuzetsu> £ is horrible to type for me ;;
13:43:41 <otters> •
13:43:43 <FreeFull> shift+3 is £ for me (UK layout)
13:43:53 <FreeFull> # is its own key
13:44:07 <chrisdotcode_> otters: hahaha
13:44:09 <Fuuzetsu> Region-specific symbols are pretty bad for syntax
13:44:25 <FreeFull> How about ¬%
13:44:28 <quchen> Non-ASCII is pretty bad for syntax. But that's pretty much the same argument.
13:44:35 <otters> how about †
13:44:44 <FreeFull> How about ←
13:44:53 <chrisdotcode_> livescript uses "|>" and "<|", which look like what's they're supposed to do for "$", indicating left and right associativity, respectively.
13:44:59 <FreeFull> One problem is that lambdabot doesn't do unicode
13:45:05 <Cale> chrisdotcode_: er, are you sure?
13:45:15 <Cale> chrisdotcode_: doesn't at least one of those also flip the parameters?
13:45:33 <Cale> i.e. x <| f = f x or something?
13:45:36 <typoclass> ah, does anyone know what f# does? maybe we can borrow something in the direction f# -> haskell, for a change ;-)
13:45:46 <Cale> (I don't know which convention they use)
13:45:50 <chrisdotcode_> Cale: looks like "[1 2 3] |> map (* 2) |> filter (> 3) |> fold1 (+)"
13:46:02 <Cale> chrisdotcode_: Yeah, that's not just flipping associativity
13:46:07 <FreeFull> So   x |> f = f x
13:46:08 <Cale> that's flipping the actual sense of the parameters
13:46:16 <quchen> > [1,2,3] >>> map (*2) >>> filter (>3) >>> foldl1 (+)
13:46:18 <lambdabot>   Couldn't match expected type `cat0 a0' with actual type `[]'
13:46:29 <quchen> :-(
13:46:32 <Peaker> is it new that ghc-prof-options needs to explicitly list -prof?
13:46:40 <otters> (|>) is already taken by lens
13:46:56 <FreeFull> > map (*2) >>> filter (>3) >>> sum $ [1,2,3]
13:46:57 <lambdabot>   10
13:46:59 <dolio> Does F# have the correct associativity on |>?
13:46:59 <chrisdotcode_> Cale: huh, oops. but x |> f and f |> x look "intuitive" to me
13:47:05 <quchen> Oh, right.
13:47:09 <Fuuzetsu> f# would interfere with anything already using MagicHash I believe
13:47:20 <dolio> Is x |> y |> f = x |> (y |> f)?
13:47:21 <otters> heh, F# is just the unboxed version of F
13:47:48 <dmwit> < let (←) = mappend in "the source for lambdabot " ← "is perfectly Unicode-friendly, FreeFull"
13:47:49 <goodfellow>   <hint>:1:6: parse error on input `←'
13:47:53 <dolio> I suspect not.
13:48:01 <typoclass> @remember otters heh, F# is just the unboxed version of F
13:48:02 <lambdabot> I will remember.
13:48:13 <dmwit> But ← is not a valid operator name. =)
13:48:29 <chrisdotcode_> a haskell-unicode would be nice...
13:48:29 <typoclass> < let (␣) = mappend in "the source for lambdabot " ␣ "is perfectly Unicode-friendly, FreeFull"
13:48:30 <goodfellow>   "the source for lambdabot is perfectly Unicode-friendly, FreeFull"
13:48:33 <otters> going to put "lambdabot remembers two of my quotes" on my résumé now
13:48:34 <Peaker> doh! cabal clean && cabal configure --enable-{executable,library}-profiling && cabal build   is building without profiling
13:48:58 <FreeFull> ← is a valid operator according to ghc
13:49:02 <dmwit> Peaker: It builds twice, once with and once without.
13:49:04 <dmwit> no?
13:49:04 <chrisdotcode_> remapping caps lock to compose should be too much trouble
13:49:19 <Peaker> dmwit, yeah, it builds my .o files with profiling, but the final executable is without
13:49:30 * hackagebot noise 0.0.1 - A friendly language for graphic design  http://hackage.haskell.org/package/noise-0.0.1 (TomBrow)
13:49:34 <typoclass> < "←" == "←"
13:49:35 <goodfellow>   True
13:49:47 <FreeFull> Prelude> let (←) = (+)     Prelude> 3 ← 4      7
13:49:53 <typoclass> FreeFull: hm, you used the same arrow as dmwit ... how weird
13:50:05 <dmwit> That is a bit odd.
13:50:10 <dmwit> Perhaps mueval has a bug.
13:50:14 <Fuuzetsu> we need a →↑↓← operator
13:50:16 <FreeFull> > "æ"
13:50:17 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
13:50:20 <dmwit> Or perhaps some fun extensions are enabled.
13:50:25 <dmwit> Like the UnicodeSyntax one or something.
13:50:30 <chrisdotcode_> > 3 ← 4
13:50:30 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
13:50:30 <Fuuzetsu> dmwit: mueval having a bug? Impossible.
13:50:45 <dmwit> < "æ"
13:50:45 <Peaker> hmm, in fact I have a Library and Executable sections in my .cabal.  Only the Library part is being built with .p_o's
13:50:46 <goodfellow>   "\230"
13:50:58 <otters> hackagebot, are you telling me that hackage is case sensitive and cabal isn't?
13:51:07 <typoclass> dmwit: probably UnicodeSyntax. i copy-pasted your code, only editing out the arrow and putting in the hole
13:51:09 <dmwit> otters: correct
13:51:14 <otters> oh, good
13:51:36 <FreeFull> < let («) = (+) in 3 « 4
13:51:37 <goodfellow>   <hint>:1:6: lexical error at character '\171'
13:51:46 <FreeFull> < let («) = (+) in « 3 4
13:51:47 <goodfellow>   <hint>:1:6: lexical error at character '\171'
13:51:55 <FreeFull> < let («) = (+) in («) 3 4
13:51:56 <goodfellow>   <hint>:1:6: lexical error at character '\171'
13:51:59 <FreeFull> Nope, won't work
13:52:13 <dmwit> I get the same error in ghci.
13:52:22 <dmwit> For that particular one.
13:52:31 <FreeFull> You're right
13:52:37 <chrisdotcode_> > let æ = 4
13:52:37 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
13:52:44 <FreeFull> > "\171"
13:52:45 <typoclass> otters: it's funky. cabal has to run on operating systems that have case-sensitive filesystems, and also case-insensitive ones. the reasonable thing is to only use lowercase all the time, but for a while, people didn't realize that/hadn't been told yet
13:52:46 <lambdabot>   "\171"
13:52:57 <chrisdotcode_> otters: what is "☃"?
13:52:58 <otters> typoclass: so I see
13:53:03 <FreeFull> > Val "\171"
13:53:04 <lambdabot>   Not in scope: data constructor `Val'
13:53:07 <FreeFull> > Var "\171"
13:53:08 <lambdabot>   Not in scope: data constructor `Var'
13:53:09 <typoclass> otters: at least that's how i understood it
13:53:10 <otters> chrisdotcode_: proposed left-associative version of $
13:53:16 <dmwit> > var "\171"
13:53:18 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (invalid character)
13:53:21 <dmwit> > text "\171"
13:53:22 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (invalid character)
13:53:31 <dmwit> < var "\171" -- hmm
13:53:32 <goodfellow>   «
13:53:33 <FreeFull> Ah
13:53:33 <chrisdotcode_> otters: hahaha, I meant what the actual character is. it looks like a snowman to me...
13:53:39 <otters> chrisdotcode_: it's a snowman
13:53:46 <FreeFull> It seems it's having a problem with the « after the in
13:53:49 <FreeFull> Not the one before
13:53:52 <chrisdotcode_> unicode snowmen in unicode; who knew?
13:53:57 <typoclass> < "☃"
13:53:58 <goodfellow>   "\9731"
13:54:06 <typoclass> chrisdotcode_: here you go ^^
13:54:08 <FreeFull> < let («) = (+); x = 3 « 4 in x
13:54:09 <goodfellow>   <hint>:1:6: lexical error at character '\171'
13:54:11 <otters> < "\128169"
13:54:12 <goodfellow>   "\128169"
13:54:14 <dmwit> < generalCategory '«'
13:54:15 <otters> oh
13:54:15 <goodfellow>   InitialQuote
13:54:16 <FreeFull> Or not
13:54:16 <chrisdotcode_> typoclass: :-D
13:54:22 <otters> haha, yeah
13:54:28 <dmwit> FreeFull: InitialQuote is not one of the categories that are OK for operators.
13:54:30 <otters> iTerm can't handle U+1F4A9 (PILE OF POO)
13:54:34 <FreeFull> Fair enough
13:54:44 <dmwit> < generalCategory '←'
13:54:45 <goodfellow>   MathSymbol
13:54:49 <FreeFull> Where is generalCategory in?
13:54:55 <dmwit> ?index generalCategory
13:54:55 <lambdabot> bzzt
13:55:01 <dmwit> ?hoogle generalCategory
13:55:01 <lambdabot> Data.Char data GeneralCategory
13:55:02 <lambdabot> Data.Char generalCategory :: Char -> GeneralCategory
13:55:10 <chrisdotcode_> otters: xD who decided to put these into unicode?
13:55:16 <otters> good question
13:55:24 <chrisdotcode_> > 0x1F4A9
13:55:25 <dmwit> PILE OF POO is in because Japan
13:55:25 <lambdabot>   128169
13:55:35 <otters> yeah, the japanese use piles of poo a lot
13:55:41 <chrisdotcode_> < "\128169"
13:55:42 <goodfellow>   "\128169"
13:55:44 <chrisdotcode_> drat
13:55:45 <dmwit> texting is a hell of a thing
13:55:50 <dmwit> < var "\128169"
13:55:52 <goodfellow>   💩
13:55:57 <chrisdotcode_> hahaha
13:56:04 <chrisdotcode_> and does Japan really use it? >_> <_<
13:56:10 <FreeFull> < let (¡) = (+) in 3 ¡ 4
13:56:11 <goodfellow>   7
13:56:14 <FreeFull> \o/
13:56:21 <dmwit> chrisdotcode_: Some carriers allowed it in their SMSs.
13:56:30 <dmwit> And then suddenly there was precedent, and it had to go in the spec. =/
13:56:34 <chrisdotcode_> dmwit: huh. that's... unusual at the least.
13:56:36 <chrisdotcode_> gah
13:56:44 <Peaker> I'm pretty sure cabal-install 1.16.0.2+Cabal 1.16.0  is being buggy and ignoring my --enable-executable-profiling flag
13:56:55 <Peaker> gonna try a newer Cabal+cabal-install
13:57:02 <chrisdotcode_> poor guy implementing that, I can imagine: "uh, pile of poo?" manager: "do you want to get fired? put it in!"
13:57:10 <dmwit> < var "\x1f61c"
13:57:11 <goodfellow>   😜
13:57:19 <user123abc> is it right to say that a left-associative $ would work solely because of a lower precedence than function application?
13:57:54 <dmwit> chrisdotcode_: See also http://www.fontspace.com/unicode/block/Emoticons
13:58:51 <chrisdotcode_> dmwit: oh boy...
13:59:01 <dmwit> ...and of course http://www.fontspace.com/unicode/block/Miscellaneous+Symbols+and+Pictographs
13:59:10 <otters> "FACE SAVORING DELICIOUS FOOD"
13:59:13 <otters> that's pretty specific
13:59:18 <Luke> dmwit: just registered for HacPhi. Why's it so early this year?
13:59:46 <dmwit> Thank goodness there are 24 clock faces, amirite?
13:59:59 <chrisdotcode_> hahaha
14:00:01 <user123abc> my browser refuses to display anything but the animals
14:00:11 <chrisdotcode_> otters: hahaha
14:00:13 <dmwit> Luke: To avoid the organizers' holidays, miscellaneous academic deadlines, and days where no room is available.
14:00:15 <user123abc> ergo you should restrict future extensions to animal glyphs
14:00:25 <Luke> ah
14:00:29 <otters> I find it incredible that there are like 300,000 unicode characters and not one of them is an otter
14:00:41 <chrisdotcode_> otters: we have snowmen?
14:00:48 <otters> snowmen are kid stuff
14:00:52 <otters> there's a rat emoticon
14:01:29 <mauke> CAT FACE WITH WRY SMILE
14:01:31 <chrisdotcode_> here's all of them: http://www.isthisthingon.org/unicode/allchars1.php (warning, huge page, obviously)
14:01:34 <Peaker> dmwit, turns out it was a Cabal/cabal-install bug.. updated both and now it builds my executable with profiling properly
14:01:48 <otters> that doesn't look like a wry smile at all.
14:02:06 <dmwit> Peaker: excellent
14:02:15 <ion> putStr [minBound..]
14:02:26 <dmwit> < universe :: String
14:02:27 <goodfellow>   Couldn't match expected type `GHC.Base.String'
14:02:27 <goodfellow>              with actual typ...
14:02:31 <enigmuriatic> why does the compiler assume that this takes [[Int]] instead of [Int]?  splitOn = foldr (\(x:xs) acc -> if x == 0 then []:acc else (x:head acc):tail acc) [[]]
14:02:35 <dmwit> < U.universe :: String
14:02:37 <goodfellow>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
14:02:48 <mauke> enigmuriatic: (x:xs)
14:03:01 <otters> :t U.universe
14:03:02 <lambdabot> Couldn't find qualified module.
14:03:09 <otters> where is universe
14:03:11 <dmwit> U.universe :: Universe a => [a]
14:03:13 <ion> Data.Universe
14:03:16 <otters> of course
14:03:17 <mauke> otters: where isn't it?
14:03:20 <dmwit> ?hackage universe
14:03:20 <lambdabot> http://hackage.haskell.org/package/universe
14:03:25 <Peaker> could be a nice feature for cabal-install to not say "newer version available" but say "CRITICAL BUGS FIXED: .... recommend installing new version.."
14:03:37 <Peaker> (that way I'd waste less time)
14:03:59 <dmwit> hm
14:04:04 <dmwit> < typeOf U.universe
14:04:05 <goodfellow>   Ambiguous type variable `a0' in the constraints:
14:04:05 <goodfellow>    (Data.Typeable.Internal...
14:04:08 <dmwit> yeah
14:04:11 <dmwit> how about
14:04:15 <dmwit> < [U.universe, ()]
14:04:16 <goodfellow>   Couldn't match expected type `[a0]' with actual type `()'
14:04:23 <dmwit> Well, it gives a hint, sort of.
14:05:07 <chrisdotcode_> test
14:05:38 <chrisdotcode_> > product [1..24]
14:05:40 <lambdabot>   620448401733239439360000
14:05:48 <chrisdotcode_> sheesh that's a huge number...
14:05:55 <ion> < (&&)
14:05:57 <goodfellow>   [(False,[(False,False),(True,False)]),(True,[(False,False),(True,True)])]
14:06:20 <dmwit> < (&&) `elem` U.universe
14:06:21 <goodfellow>   True
14:07:22 <chrisdotcode_> dmwit: what's U?
14:07:28 <ion> Data.Universe
14:07:32 <dmwit> import qualified Data.Universe as U
14:08:05 <acube> @hoogle Data.Universe.universe
14:08:05 <lambdabot> No results found
14:08:11 <acube> @hoogle universe
14:08:12 <lambdabot> No results found
14:08:13 <dmwit> ?hackage universe
14:08:13 <lambdabot> http://hackage.haskell.org/package/universe
14:10:15 <Peaker> The universe package is very optimistic about functions
14:10:22 <ion> < (id :: Word8 -> Word8) `elem` U.universe
14:10:30 <goodfellow>   mueval-core: Time limit exceeded
14:10:34 <ion> < ((*0) :: Word8 -> Word8) `elem` U.universe
14:10:36 <goodfellow>   True
14:10:54 <acube> :O Is that the universe of all functions? XD
14:11:11 <mauke> totally
14:11:18 <Peaker> > text "< text \"> 0\""
14:11:19 <dmwit> Peaker: Yes, it's really only feasible to use most of the instances for functions over small inputs.
14:11:20 <lambdabot>   < text "> 0"
14:11:30 <acube> < universe :: Void
14:11:32 <goodfellow>   Not in scope: type constructor or class `Void'
14:11:40 <dmwit> < U.universe :: Data.Void.Void
14:11:41 <goodfellow>   Not in scope: type constructor or class `Data.Void.Void'
14:11:41 <goodfellow>  Perhaps you meant...
14:11:55 <dmwit> Anyway, it's [].
14:12:12 <ion> Is goodfellow an instance of lambdabot?
14:12:17 <dmwit> yes
14:12:20 <enigmuriatic> how do you filter a list of lists based on length?
14:12:31 <mauke> filter (\x -> ...)
14:13:03 <edwardk> > filter (\xs -> length xs == 2) ["ab","cd","efg"]
14:13:04 <lambdabot>   ["ab","cd"]
14:13:51 <dmwit> Peaker: (Is that what you meant by "optimistic"?)
14:13:58 <chrisdotcode_> > filter(\xs y -> length xs == y)["ab","cd","efg"] 2
14:13:59 <lambdabot>   The function `GHC.List.filter' is applied to three arguments,
14:13:59 <lambdabot>  but its type...
14:14:01 <Peaker> dmwit, yeah
14:14:05 <chrisdotcode_> hrm...
14:14:11 <Peaker> Eq instance over Finite functions sounds nuts :)
14:14:29 <edwardk> > (\y -> filter(\xs -> length xs == y)["ab","cd","efg"]) 2
14:14:29 <dmwit> yep =)
14:14:30 <lambdabot>   ["ab","cd"]
14:14:40 <chrisdotcode_> edwardk: thought as much...
14:14:49 <chrisdotcode_> is there a "cleaner" way, though?
14:14:49 <dmwit> Word8 isn't too bad, but Word16 or higher starts to heat your CPU up a bit =)
14:15:06 <dmwit> < const 0 == (* (0 :: Word8))
14:15:07 <goodfellow>   True
14:15:17 <dmwit> < const 0 == (* (0 :: Word16))
14:15:18 <goodfellow>   True
14:15:26 <dmwit> ooo, impressive
14:15:32 <dmwit> < const 0 == (* (0 :: Word32))
14:15:36 <goodfellow>   mueval-core: Time limit exceeded
14:15:44 <ion> < const "" == take 0
14:15:45 <goodfellow>   No instance for (Data.Universe.Class.Finite [GHC.Types.Char])
14:15:46 <goodfellow>    arising fr...
14:15:59 <mekeor> what's "<"? the same as ">" ?
14:16:05 <edwardk> mekeor: different bot
14:16:07 <shachaf> No, the opposite.
14:16:07 <dmwit> Yes, but for goodfellow instead of lambdabot.
14:16:10 <mekeor> oh, it's yeah
14:16:40 <chrisdotcode_> does lambdabot need assistance?
14:17:08 <dmwit> > U.universe :: [()] -- dunno, maybe my patches got in by now!
14:17:11 <lambdabot>   Not in scope: `U.universe'
14:17:13 <dmwit> nope =)
14:17:28 <chrisdotcode_> dmwit: so why is goodfellow also here?
14:17:43 <dmwit> < U.universe :: [()] -- because this
14:17:44 <goodfellow>   [()]
14:17:53 <edwardk> chrisdotcode_: because dmwit likes to play with his universe
14:17:54 <chrisdotcode_> that crashes lambdabot?
14:17:57 <chrisdotcode_> haha
14:18:03 <edwardk> chrisdotcode_: just isn't installed on it
14:18:04 <dmwit> crashes? what, no.
14:18:52 <dmwit> edwardk: My universe is a fun toy. =)
14:19:15 <monochrom> does your universe have a universal property? :)
14:19:30 <otters> < U.universe :: Studio
14:19:31 <goodfellow>   Not in scope: type constructor or class `Studio'
14:19:38 <otters> meh, that wasn't funny
14:19:47 <enigmuriatic> > filter (\xs -> (>0) $ length xs) [1,0,2,0,0,3]
14:19:48 <lambdabot>   No instance for (GHC.Num.Num [a0])
14:19:49 <lambdabot>    arising from a use of `e_10102003'
14:19:49 <lambdabot>  P...
14:19:52 <enigmuriatic> why doesn't that work?
14:19:55 <enigmuriatic> if this does:
14:20:06 <enigmuriatic> > (>0) $ length []
14:20:07 <lambdabot>   False
14:20:14 <otters> because
14:20:19 <otters> :t filter (\xs -> (>0) $ length xs)
14:20:21 <lambdabot> [[a]] -> [[a]]
14:20:27 <dmwit> > (>0) $ length 1
14:20:28 <otters> :t [1,0,2,0,0,3]
14:20:29 <lambdabot>   No instance for (GHC.Num.Num [a0])
14:20:29 <lambdabot>    arising from the literal `1'
14:20:30 <lambdabot>  Possibl...
14:20:30 <lambdabot> Num t => [t]
14:20:41 <otters> you're passing a [t] to something that wants a [[t]]
14:20:49 <ion> < sequence U.universe :: IO [()]
14:20:50 <goodfellow>   No instance for (Data.Universe.Class.Universe (GHC.Types.IO ()))
14:20:50 <goodfellow>    arising...
14:20:50 <otters> Num t => [[t]] more specifically
14:20:51 <monochrom> but you have (>0) $ length 0, (>0) $ length 1 etc
14:20:54 <shachaf> kappabot: @undefine
14:20:55 <enigmuriatic> ah right
14:21:02 <shachaf> > U.universe :: [()]
14:21:03 <lambdabot>   Not in scope: `U.universe'
14:21:03 <kappabot>   [()]
14:21:14 <shachaf> @yarr
14:21:14 <lambdabot> What be a priate's favourite cheese?
14:21:14 <kappabot> Well me 'earties, let's see what crawled out of the bung hole...
14:21:14 <lambdabot> Yarrlsburg!
14:21:29 * dmwit high-fives shachaf
14:21:32 <otters> priate's?
14:21:37 <fizbin> @src U.universe
14:21:37 <lambdabot> Source not found. Maybe you made a typo?
14:22:07 <chrisdotcode_> does haskell work well with socket programming?
14:22:13 <monochrom> hrm! what is kappabot doing here?
14:22:13 <otters> yes
14:22:16 <ion> yes
14:22:31 <shachaf> monochrom: Nothing.
14:22:38 <otters> except you'll have to get accustomed to hWaitForInput if you want to time out after a reasonable period
14:22:42 <ion> monochrom: Just a
14:22:49 <chrisdotcode_> otters: is there an issue with lazystreams too, or what?
14:22:49 <dmwit> ?hackage universe -- fizbin
14:22:50 <lambdabot> http://hackage.haskell.org/package/universe -- fizbin
14:23:10 <otters> chrisdotcode_: that might be related, tbh I'm not specific on the details, but I once wrote a bot and would read lines from an IRC server using hGetLine
14:23:18 <otters> and if the connection was lost, it would just sit there indefinitely waiting for a line
14:23:27 <shachaf> Nothing | Just ice
14:23:35 <otters> so eventually I had to write a hGetLineTimeout that used hWaitForInput and time out manually myself
14:23:41 <dmwit> shachaf: TANJ
14:24:02 <chrisdotcode_> otters: well, it sounds more or less like something evented...
14:24:17 <chrisdotcode_> "wait for input, react when input is recieved"
14:24:37 <otters> right
14:24:46 <otters> which is what most languages do with I/O
14:26:23 <acube> Why is comonad.com unreachable???
14:26:47 <shachaf> edwardk: Hmm, someone was saying that the other day too. What happened?
14:28:25 <ion> dmwit: Wouldn’t CPP and a couple of ifdefs be more convenient than the defsigs/nodefsigs thing?
14:30:07 <dmwit> I really dislike CPP. I try to avoid it whenever possible.
14:30:15 <dmwit> Oh yeah, and it can't be used here!
14:30:17 <dmwit> So there's that.
14:30:38 <dmwit> You can't choose whether to use an extension or not based on a CPP flag. =)
14:31:24 <ion> #ifdef foo, {-# LANGUAGE DefaultSignatures #-}, #endif
14:31:36 <dmwit> Yes, and where do you enable CPP?
14:31:46 <ion> On the first line
14:32:00 <elliott> CPP beats TH, at least
14:32:08 <elliott> dmwit: btw, you can
14:32:10 <elliott> lens does it
14:33:13 <dmwit> Huh, neat.
14:33:36 <dmwit> I *thought* I tested that. Has this always been true?
14:33:38 <monochrom> or horrible :)
14:35:09 <dmwit> ion: https://github.com/dmwit/universe/issues/5
14:37:26 <hpc> dmwit: with your account image, i read it in capslock
14:37:32 <hpc> THERE'S CODE DUPLICATION!!!!1!
14:39:32 <geekosaur> ISTR it changed at some point specifically so that CPP could be used to conditionalize other extensions?
14:46:38 <enigmuriatic> splitOn delim xs = filter (\ys -> (>0) $ length ys) $ foldr (\x acc -> if x == delim then []:acc else (x:head acc):tail acc) [[]] xs
14:46:48 <enigmuriatic> is there any way to remove the xs from both sides of that?
14:47:22 <elliott> enigmuriatic: yes, simply remove it
14:47:28 <elliott> f x = g x --> f = g
14:47:31 <mauke> beware the $
14:47:33 <elliott> oh
14:47:45 <elliott> ok, drop it and replace the ($) with a (.). but now it sounds magical rather than obvious.
14:47:53 <elliott> the reason is that (f . g) x = f (g x) = f $ g x
14:47:55 <monochrom> splitOn delim = filter (\ys -> (>0) $ length ys) . foldr (\x acc -> if x == delim then []:acc else (x:head acc):tail acc) [[]]
14:48:00 <enigmuriatic> maybe if i swap the parameters in the declaration?
14:48:01 <ski>   splitOn delim = filter (...) . foldr (...) [[]]
14:48:24 <ski> enigmuriatic : `not . null' is better than `\ys -> (>0) $ length ys'
14:48:38 <monochrom> ski's shows the structure
14:49:11 <enigmuriatic> that worked ski, thanks
14:49:44 <ski> `null' only checks the first constructor, instead of (computing the whole list) and counting the number of elements as `length' does
14:49:46 <monochrom> it is unnecessary to remove parameters. unless you can consistently do it
14:50:52 <mauke> inb4 @pl
14:50:54 <ski> enigmuriatic : however, i would perhaps try an `unfoldr' here (with `span' or `break')
14:51:47 <ion> dmwit: https://github.com/ion1/universe/commit/4eca5001c766e83019e95e584c70f0f3672d1590
14:52:34 <ion> dmwit: Is there a reason for it not being universe = universeDef?
14:53:00 <ion> That would eliminate the rest of the duplication.
15:04:56 <ion> dmwit: https://github.com/ion1/universe/commit/9322ce
15:08:47 <hiptobecubic> carter, ... schonwald?
15:08:52 <carter> yes?
15:08:57 <carter> who are you?
15:10:10 <hiptobecubic> I just stumbled on a post by you a year ago on HN talking about well posed, and then searching for it found your linked in page, and then took a wild guess that you might be here.
15:10:19 <carter> well
15:10:26 <carter> thats easy to figure out
15:10:34 <carter> :0
15:10:36 <carter> :)
15:10:54 <carter> finally getting stuff in shape for a first release in a month or so
15:10:59 <luite> \o/
15:11:10 <luite> and you're a celebrity even before shipping ;)
15:11:26 <carter> luite nope, i'm just loud on the internet and recursively fractal technical
15:11:41 <carter> and a tad daft
15:11:50 <hiptobecubic> :)  Yes, I'm not pretending to be a detective. I just wanted to ask how your company was going because it looked interesting
15:11:57 <hiptobecubic> who isn't
15:12:05 <carter> hiptobecubic most of humanity
15:12:16 <carter> the best way to stay appraised is to sign up for the announce link on my site
15:12:26 <carter> anything else may require nda's :p
15:12:37 <carter> or waiting for some of the open bits to hit hackage
15:13:00 <carter> the next month or so i'm trying to just work on getting release v0 of the lin alg / solver layer out
15:13:06 <carter> and signing a first few customers
15:13:09 <carter> speaking of which
15:13:11 <carter> ttyl :P
15:14:26 <hiptobecubic> good luck!
15:14:59 <typoclass> hiptobecubic: carter: what is the company doing, roughly?
15:15:18 <carter> typoclass read the blurb on wellposed.com first
15:15:20 <carter> then ask me
15:15:51 <carter> the v0 thing i'll be release will be a bsd3 lin alg suite thats nice to use
15:15:59 <typoclass> carter: thanks for the link, will look
15:16:13 <carter> the entire web site is 2 paragraphs
15:16:15 <carter> with link
15:16:17 <carter> s
15:18:21 <hiptobecubic> typoclass, Here is the original HN post I was talking about. https://news.ycombinator.com/item?id=4054370
15:18:50 <typoclass> hiptobecubic: thank you
15:19:07 <carter> typoclass thats ollddddd
15:19:17 <carter> i'm just doing the data analysis machine learning stuff
15:19:25 <carter> lemme linke you to a more recent hn remark
15:19:56 <nimish> carter: are you hiring? ;)
15:19:59 <carter> https://news.ycombinator.com/item?id=5552109
15:20:12 <carter> not yet
15:20:16 <carter> first i have to sign some customers
15:20:22 <carter> but looks like i may be able to
15:20:32 <carter> sign customers
15:20:53 <nimish> also what's the status of those bindings to lapack ?
15:21:05 <carter> nimish i'm not using lapack
15:21:08 <carter> i'm rolling my own stuff
15:21:13 <nimish> i basically ran into the problem you did--no good lin algbra libs in haskell
15:21:14 <carter> lapack and blas have the wrong layouts
15:21:22 <nimish> carter: what, column-major?
15:21:26 <carter> either
15:21:29 <carter> both are wrong
15:21:44 <nimish> so what's right? the funky layout scalapack uses?
15:21:50 <carter> nimish wait and see
15:21:57 <carter> :)
15:22:04 <carter> it'll be easy to figure out once i've got the core libs out
15:22:38 <carter> but i've some tricks that let me just loop through things that otherwise need a recursive block decomposition routine
15:22:53 <carter> g2g
15:23:08 <hiptobecubic> yes, back to work. we want to see these libs
15:23:14 <enthropy> there are some bindings to (parts of?) lapack in hmatrix
15:23:21 <carter> enthropy that doesn't matter
15:23:36 <carter> 1) lapack and blas don't have teh best layouts, just the ones you can easily write loops for
15:23:45 <carter> 2) alberto refuses to change the license
15:23:55 <carter> so i may as well take over that niche
15:24:03 <nimish> carter: alberto can't, AFAICT; gsl is gpl
15:24:05 <carter> nope
15:24:16 <carter> the core bits dont need gsl
15:24:25 <carter> nimish go look at the tickets
15:24:28 <carter> i've tried to get it to change
15:24:34 * hackagebot network-simple 0.2.0.1 - Simple network sockets usage patterns.  http://hackage.haskell.org/package/network-simple-0.2.0.1 (RenzoCarbonara)
15:24:35 <carter> he's a nice guy
15:24:49 <carter> but its like farting on a brick wall, no noise or smell will motivate him
15:25:09 <carter> and since i seem to have stuff that gets me as fast MKL, but with support for sparse too
15:25:11 <carter> i win
15:25:14 <carter> ttyl all
15:26:12 <carter> interest appreciated
15:26:23 <carter> and the fastest way to find out more is to wait till its out :)
15:26:32 <carter> i'm really distractable, so asking sooner is a bad idea ;)
15:30:30 <dmwit> I guess changing the PVP should allow me to keep A.B.C the same if I only remove a non-exported module, right?
15:33:00 <dmwit> s/changing/
15:34:05 <cmccann> dmwit: I'm sure that by changing the PVP you could allow anything you like.
15:34:27 <dmwit> non-monotonic version numbering, here I come!
15:34:35 * hackagebot universe 0.4.0.1 - Classes for types where we know all the values  http://hackage.haskell.org/package/universe-0.4.0.1 (DanielWagner)
15:34:49 <cmccann> dmwit: I want complex version numbers.
15:34:55 <dmwit> I'll be releasing universe version -5.i.XVIII shortly.
15:35:04 <typoclass> dmwit: maybe, but i think it's very likely you'll end up confusing yourself. i always confused myself if i changed something without bumping the version
15:35:06 <otters> irrational version constants
15:35:08 <cmccann> the imaginary component could represent features that aren't fully implemented.
15:35:19 <dmwit> typoclass: Of course the version *changes*. Just A.B.C stays the same.
15:35:26 <otters> version π.3i.e^(2i) is coming out next week
15:35:42 <typoclass> dmwit: A.B.C isn't the version number?
15:35:51 <dmwit> A.B.C is the first three parts of the version number.
15:36:00 <dmwit> Version numbers can be as long as you like!
15:36:16 <typoclass> dmwit: oh, you mean 4th level or lower
15:36:23 * dmwit nods
15:36:37 <cmccann> when I hack a package to modify something locally I use a version number like A.B.C.D.E.F and use E.F as my local version number.
15:36:49 <dmwit> It doesn't matter what you answer now, anyway, I've already made a release. Whatever I've screwed up is public now. =P
15:37:51 <cmccann> that's why my installed version of gtk is 0.12.4.0.3 right now for example
15:38:29 <quchen> Random question: I wrote a mail to the Libraries mailing list today, and I wonder whether it actually made it to the list. I've had trouble with this in the past. Is there some way I can check it? Can't find it on MarkMail.
15:39:03 <Cale> quchen: What's the title?
15:39:06 <dmwit> I bet libraries is managed by mailman, and therefore has an archive available online that you can check.
15:39:10 <Cale> er, or subject line
15:39:12 <cmccann> if it doesn't show up in the list archive it probably didn't show up anywhere.
15:39:19 <quchen> Cale: "Re: Burning bridges"
15:39:27 <arkeet> http://www.haskell.org/mailman/listinfo/libraries
15:39:35 * hackagebot pipes-network 0.4.0.1 - Use network sockets together with the pipes library.  http://hackage.haskell.org/package/pipes-network-0.4.0.1 (RenzoCarbonara)
15:39:44 <cmccann> more specifically http://www.haskell.org/pipermail/libraries/2013-May/thread.html
15:40:16 * dmwit high fives RenzoCarbonara
15:40:19 <dmwit> Good version number, mate!
15:40:28 <quchen> Ah, seems like it's in there. Thanks, bookmarked.
15:42:25 <cmccann> I didn't see a mail from "quchen" so I wasn't sure :P
15:42:42 <monochrom> it is like not SPJ :)
15:43:05 <quchen> cmccann: cmccann, there's a dark secret about my name on IRC.
15:43:28 <ion> quchen: quchen, okay. okay.
15:43:36 <monochrom> it is also likely not cmccann :)
15:43:36 <quchen> Yeah that didn't come out half as funny as I played it out in my head. I'll just be quiet :s
15:43:54 * typoclass . o O ( man, i wish those websites showed a thread per page, instead of a message per page. so much useless clicking )
15:44:14 <shachaf> hi cmccann
15:44:19 <cmccann> hi shachaf
15:44:25 <shachaf> It turns out you really did subscribe to libraries@. We are all lost.
15:44:26 <monochrom> and not edwardk. there are still 5 possibilities. :)
15:44:35 <cmccann> yes and I'm sure you all regret that by now.
15:44:47 <cmccann> this is why you can't have nice things.
15:45:21 <quchen> typoclass: There are no threads. Mails are grouped heuristically and that's it. 1990 style! :D
15:45:41 <ion> Your his were isomorphic to the NOT truth table.
15:46:07 <monochrom> actually, it's 1990-style that had threads. today's style is flat sequence and a lot of "@monochrom"
15:46:43 <cmccann> monochrom: usenet4ever amirite
15:46:44 <geekosaur> or is in pictures and has a lot of "foo liked this"
15:46:52 <ion> and #hashtags
15:49:08 <Peaker> Which is nicer of these two: http://i.imgur.com/9vaojxX.png   and how would you improve the latter?
15:49:18 <typoclass> Peaker: add kitty
15:49:40 <cmccann> Peaker: needs lens flare
15:49:55 <cmccann> and bloom effects
15:50:10 <typoclass> Peaker: how about "if x == 0 {" and two lines "then ...", "else ..."
15:50:15 <monochrom> Peaker: neither. almost the 2nd, but I don't want the condition to be a branch.
15:50:28 <ocharles> cmccann: I believe you mean sepia filter
15:50:32 <ocharles> this is 2013 after all
15:50:36 * typoclass . o O ( ... magnificent stereo ... )
15:50:45 <cmccann> ocharles: nah I like the retro look
15:50:56 <ocharles> i like how sepia isn't retro now :p
15:50:58 <monochrom> but I guess you mean if' is an arbitrary function that happens to take 3 parameters. then ok, the 2nd.
15:51:17 <Peaker> monochrom, yeah, maybe "if" is a bad example
15:51:26 <cmccann> ocharles: it's double-retro or something, which cancels out. I think.
15:51:37 <Peaker> monochrom, we just did a lot of work to make our conventional parameter passing be records for >=2 params
15:51:50 <ocharles> Peaker: the general way to write that in maths is f(x) = { something (condition) ; something else (otherwise) }
15:51:53 <adnap> > let f :: (Applicative f, Monad m) -> f [a] -> Int -> (f a -> f (m b)) -> f (m b) -> f (m b); f _ 0 _ y = y; f x n g y = f (tail <$> x) (n - 1) g (liftA2 (>>) (g (head <$> x)) y) in f [[2, 3]] 2 (fmap return) [[]]
15:51:54 <lambdabot>   Predicate `(Control.Applicative.Applicative f,
15:51:54 <lambdabot>              GHC.Base.Monad ...
15:51:55 <Peaker> (i.e: the UI makes it look like Haskell syntax but uses records behind the scenes, so that callers see named params rather than positional)
15:51:58 <ocharles> Peaker: I wonder if that would render well?
15:52:02 <luite> Peaker: the condition after the { looks a bit odd
15:52:19 <otters> adnap: what's that, exactly
15:52:29 <ocharles> http://en.wikipedia.org/wiki/Factorial#Definition like that recurence relation
15:52:32 <adnap> otters: Just a function I'm trying to write
15:52:53 <luite> oh i see that monochrom already mentioned that
15:53:01 <typoclass> Peaker: oooh i see, it's about arbitrary functions. i like how the argument names (cond then else) are shown in option 2. have you thought about putting those annotations below the line, similar to how there's "Int" there?
15:53:23 <Peaker> typoclass, that space is reserved for inferred types/examples (which are turned off in the screenshot)
15:53:54 <typoclass> Peaker: tangentially, have you thought about using dark grey instead of black for the background? i think it'd be more readable, given the flashy colors
15:53:56 <adnap> > let f :: (Applicative f, Monad m) => f [a] -> Int -> (f a -> f (m b)) -> f (m b) -> f (m b); f _ 0 _ y = y; f x n g y = f (tail <$> x) (n - 1) g (liftA2 (>>) (g (head <$> x)) y) in f [[2, 3]] 2 (fmap return) [[]]
15:53:57 <lambdabot>   [[]]
15:54:07 <adnap> Can this function be written without the Int argument?
15:54:38 <otters> > let f _ _ _ x = x in f [[2, 3]] 2 (fmap return) [[]]
15:54:39 <lambdabot>   Ambiguous type variable `f0' in the constraint:
15:54:39 <lambdabot>    (GHC.Base.Functor f0) ar...
15:54:59 <Peaker> typoclass, hmm... I think it'd constraint our dynamic range/contrast
15:55:21 <quchen> adnap: That function is very hard to read. Put it on HPaste, write some comments, give the bindings appropriate names.
15:56:01 <adnap> quchen: It's abstract. What should I name the bindings?
15:56:12 <Peaker> typoclass, http://i.imgur.com/f4mtBIO.png <-- with inferred types enabled
15:56:39 <quchen> adnap: I don't know. Because I don't understand the function.
15:56:50 <Peaker> the question is basically if anyone has any suggestions on how to make the 2nd option less cluttered/noisy
15:56:51 <typoclass> Peaker: well it would reduce contrast, because very high-contrast text is harder to read. (e.g. those 1996 web pages that had terribly green text on terribly red background)
15:56:54 <adnap> http://hpaste.org/88325
15:57:15 <Peaker> typoclass, ah, we'll experiment with that then...
15:57:22 <typoclass> Peaker: oh i see, thanks
15:57:22 <Peaker> typoclass, but it's too preliminary for such fine tuning :)
15:57:34 <Peaker> we still don't even have sum types.. we just added products!
15:57:35 <cmccann> moderate-to-large value contrast is important for reading
15:57:41 <cmccann> hue and saturation contrast are mostly cosmetic
15:58:23 <monochrom> use CPS to convert sums to products anyway :)
15:58:32 <cmccann> with the caveat that perception matters more than what a program might think the HSV is
15:58:40 <Peaker> We would if there wasn't a complexity hit there :)
15:58:42 <cmccann> yellow is brighter than blue all else equal &c.
15:58:59 <_{^_^}__> why doesn't  {{read "4" :: String}} work?
15:59:13 <Peaker> (can't pattern match on multiple things at the same time with CPS sums, without doing awful trickery)
15:59:24 <cmccann> > "4"
15:59:25 <lambdabot>   "4"
15:59:29 <monochrom> because it has to be {{read "\"4\"" :: String}}
15:59:29 <cmccann> > show "4"
15:59:30 <lambdabot>   "\"4\""
15:59:31 <quchen> adnap: Now it's 3 lines, but I still don't know what the function is supposed to do. All I can tell is that you can make the Monad constraint an Applicative one by replacing (>>) with (*>).
15:59:36 <Peaker> > read "\"4\"" :: String
15:59:38 <lambdabot>   "4"
15:59:50 <luite> Peaker: I've also tried to do similar type displays, i settled for showing something similar to the "stack" of types in a popup, relative to the thing pointed at (or where the cursor is)
16:00:08 <Peaker> luite, in what context were you working on that?
16:00:13 <luite> might not be ideal, but these take up a huge amount of space
16:00:37 <luite> Peaker: oh this was just for haskell in a text editor, no fancy structured editing involved
16:00:37 <adnap> quchen: The function is supposed to take the a's out of f [a], use the (f a -> f (m b)) function to turn each a into an f (m b), and then combine all these f (m b)'s into a single f (m b)
16:01:15 <Peaker> we're thinking of having the first record param of functions optionally be hidden, because it is very common that the first param is the "obvious" param, and only the next params need names
16:02:59 <Peaker> so that:   if <foo> \n then bar \n else baz
16:03:07 <Peaker> (if is an ordinary function)
16:03:20 <typoclass> Peaker: how about option 1, but with a visual marker that shows the extent of the arguments? it might be 1px-wide lines that separate them, or alternating backgrounds (in "if x y z", e.g. x dark grey, y black, z dark grey). or you could get funkier, e.g. in the png, moving the "Bool" down 2 slots, the "Int" that spans the 1 down by 3 slots, so that they are all in one line with the "Int" that spans the 3rd arg
16:03:39 <quchen> adnap: That sounds like you're combining many functions into one.
16:03:48 <Peaker> typoclass, we want the names visible though, at least for the 2nd/3rd params
16:04:12 <NemesisD> if i'm using a fresh hsenv in a process ,is it safe to ignore the warnings it gives me about reinstalling?
16:04:12 <Peaker> typoclass, a friend suggested putting the names on top of arg spans, like the types are on bottom. and I like that. but we also want to use vertical space
16:04:16 <typoclass> Peaker: sure, that's not precluded
16:04:41 <Peaker> if we only span horizontally, then our layout will be 1 dimensional
16:04:48 <Peaker> (there's no manual formatting)
16:04:48 <adnap> quchen: Uh... sorry? I don't know how to make it any simpler. I want to get rid of the Int argument.
16:05:29 <otters> I don't think you can necessarily join a Functor
16:05:48 <luite> Peaker: doest it reflow your code if you resize the window?
16:06:15 <typoclass> Peaker: are other annotations needed, besides the argument type and argument name?
16:06:56 <Peaker> luite, we are worried about things moving around too much
16:06:59 <quchen> adnap: I still don't understand what the function is supposed to do. Documentation please. Tell us what you're trying to do, not how you want to do it.
16:07:01 <Peaker> luite, you can zoom in/out
16:07:11 <Peaker> luite, but we're thinking/hoping that a more static layout will be nicer
16:07:28 <Peaker> typoclass, the type we're not sure should be shown by default, it might be too noisy.  Only the name, perhaps
16:07:37 <Peaker> typoclass, we have a shortcut key to enable/disable the inferred types
16:07:47 <typoclass> Peaker: yes, sounds plausible
16:08:14 <adnap> quchen: You're starting to make me crazy. I don't know what you mean by "trying to do". I can't explain something so abstract any better
16:08:17 <luite> Peaker: hmm, i'm kind of worried that that would not work well with larger real world code. what kind of test programs are you using with it?
16:08:52 <Peaker> luite, it's too preliminary to write anything :)  Our running examples are: euler1 solution (with some where extraction), factorial, flip, and some corner cases for the type system
16:09:13 <adnap> quchen: Do you understand what the function is doing currently?
16:09:16 <Peaker> luite, I agree that it isn't clear this will work/scale, but perhaps it will encourage small expressions with lots of extraction into intermediate variables
16:09:24 <quchen> adnap: No.
16:09:33 <adnap> quchen: Well, maybe you're not the best person to help me
16:09:37 <Peaker> luite, (extracting to an intermediate variable is just a single key stroke+naming it)
16:09:53 <quchen> adnap: Yeah, sorry for that.
16:09:57 <Peaker> or maybe 3-4 key strokes first to climb up/down the expr tree to figure out which subexpr to extract
16:10:00 <luite> Peaker: ah that's possible. otherwise i guess dynamic layout could always be added in later
16:10:38 <Peaker> yeah, we'll obviously not get everything usable/nice on the first try -- once we actually try to work with it we'll figure out what to fix
16:11:38 <typoclass> Peaker: just to through around more ideas, how about option 1, and with a new row inserted, containing three boxes "cond -- then -- else", with appropriate widths, as the second-last row
16:13:03 <Peaker> typoclass, that's the friend's suggestion, i.e: " putting the names on top of arg spans, like the types are on bottom "
16:13:06 <typoclass> Peaker: also, how about if the type annotation boxes were vertically aligned to the bottom? as the 2nd-to-last row, they'd form a row "Bool -- Int -- Int" that indicates the extent of the arguments
16:13:12 <adnap> quchen: Look at "f x n g y = f (tail <$> x) (n - 1) g (liftA2 (>>) (g (head <$> x)) y)" "tail <$> x" takes f [a] and makes f [a], chopping off the first element. "head <$> x" makes an f a from f [a] by taking the first element, and g turns this f a into an f (m b). "liftA2 (>>)" takes the result of "g" and the accumulator "y", and combines them into a new accumulator. The function recurses with the new accumulator, and a decremented "n".
16:13:47 <_{^_^}__> haha, learning haskell and found a cute trick: {{ [9223372036854775805 .. ] :: [Int] }}
16:13:48 <typoclass> Peaker: yes, but i meant below ...
16:13:50 <Peaker> typoclass, Yeah, that's nice as it emphasizes sibling relationships, but might be slightly bad because it puts stuff further away from what it annotates
16:14:06 <typoclass> Peaker: true
16:14:31 <Peaker> typoclass, but we're semi-satisfied with the way inferred types are visible.. just wondering about how to display the args to funcs
16:16:06 <typoclass> Peaker: right. the benefit of option 2 is that it's so obvious which argument is which. what i was getting at with all the suggestions is trying to replicate that benefit in option 1
16:17:00 <Hafydd> > [9223372036854775805 .. ] :: [Int]
16:17:01 <lambdabot>   [9223372036854775805,9223372036854775806,9223372036854775807]
16:17:06 <Peaker> typoclass, thanks :) the problem with that kind of approach is that it doesn't use vertical space.. we're thinking that we have some things that span horizontal space, and by making multi-param applications span vertical space, that we'll get better use of screen real estate
16:17:50 <Peaker> typoclass, codeveloper just gimp'd this: https://lh5.googleusercontent.com/-SI11AOrC2x0/UZv9D85VF9I/AAAAAAAABLc/z65pCXknWuc/w958-h376-no/howabout.png
16:18:08 <Peaker> (mock screenshot)
16:18:29 <Hafydd> > [False, True ..]
16:18:31 <lambdabot>   [False,True]
16:18:43 <Peaker> I guess it'd need () around the condition there, not sure why he removed them
16:18:43 <typoclass> Peaker: hm ok. that depends on how vertical space (linebreaks) will be managed in your language. when writing haskell, i stick to the 80-column limit and manually manage linebreaks to make it as readable as possible
16:18:44 <otters> > [()..]
16:18:46 <lambdabot>   [()]
16:18:48 <Hafydd> LOL
16:19:17 <Peaker> typoclass, there's no text or line breaks, just widgets that show certain language constructs, and each widget has its layout logic
16:19:19 <Hafydd> > [(),()..]
16:19:21 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
16:19:42 <typoclass> Peaker: ok, i'm taking that to mean "teh computer will manage all of that"
16:19:45 <typoclass> =)
16:20:06 <Peaker> typoclass, so: apply positional does horizontal juxtaposition -- apply-with-conventional-record-of-args will do the magic we're discussing now.. apply-infix will do horizontal layout
16:20:06 <Hafydd> > [LT,GT..]
16:20:08 <lambdabot>   <hint>:1:9: parse error on input `]'
16:20:28 <cmccann> > [LT, GT .. ]
16:20:30 <lambdabot>   [LT,GT]
16:20:51 <applicative_> > [LT..]
16:20:52 <typoclass> Peaker: i can't tell if the first argument of a multi-arg function is always the "most obvious", meaning that you don't need to show it (as with cond in the googleusercontent screenshot)
16:20:53 <lambdabot>   <hint>:1:6: parse error on input `]'
16:21:00 <applicative_> > [LT ..]
16:21:01 <lambdabot>   [LT,EQ,GT]
16:21:03 <Peaker> behind the scenes, what's stored is the low-level SystemF which is "Sugared" into a higher-level representation, which is then converted into widgets, which are then displayed
16:21:13 <otters> > [1,1..]
16:21:15 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:21:22 <Peaker> typoclass, it's probably going to be an attribute of the function -- whether its first arg is "obvious"
16:21:26 <typoclass> Peaker: probably depends on the design of the standard library. i guess i can imagine a library where the obviousest argument is always the first
16:21:40 <Peaker> I think sometimes none of the arguments are "obvious"
16:22:20 <Peaker> in single-dispatch OO, there's the "object" arg
16:22:38 <Peaker> which coincidentally is also the name of the grammatic position of the condition in an "if <condition>"
16:30:24 <typoclass> Peaker: random new idea. please appreciate the ascii art mightily :-D http://hpaste.org/88326
16:31:11 <Peaker> why reverse the inferred types lines?
16:31:42 <Peaker> the outer-most type is probably less informative than subexpression types in most cases
16:31:56 <Peaker> so it's probably better to have the subexpression types nearer the expression itself
16:32:38 <Peaker> placing the names in an aligned row is a nice idea, I like it, whether above or below or in between the inferred types, and we might go for it at some point, but again it has the problem of code not spanning vertical space
16:35:37 <typoclass> adnap: i can't pretend i really understand your function, but when an initial value to a function is needed, sometimes i do "f = go 0 where go n x y z = ... (n-1) ...". maybe even using pointless style for f, if that makes any sense
16:36:28 <adnap> typoclass: It makes sense. Notice the function I posted already has an accumulator. The real function would have one less argument and call the helper with the initial accumulator
16:36:34 <typoclass> Peaker: yeah ... i wonder about largest-first or smallest-first. i was thinking you often want to know the "bottom line", what's coming out of it at the end of the day, i.e. the single big box saying "Int". it might be justified to put that information at the top, with the less important (arguably?) information towards the bottom
16:37:09 <Peaker> typoclass, I think the closeness of the big "Int" is less important since it's delimiting a huge expression anyway, it won't be hard to match it up
16:37:16 <typoclass> Peaker: but i got the idea because this way, line 3 of the paste neatly shows the types of the arguments. in your pngs, they were more scattered
16:37:26 <Peaker> and the type information in the outer-most expression is typically more coarse, since exported types tend to be simpler than intermediate types
16:38:11 <typoclass> Peaker: (this last point could be done with the smallest-first layout by just aligning everything to the bottom, but that moves stuff further away from its expressions)
16:38:29 <Peaker> it might be better to bottom-align them despite making them further.. or maybe expand the inferred type boxes vertically
16:38:32 <typoclass> Peaker: it's a balancing act. i'm not sure what to think
16:38:33 <Peaker> to span all the space they can
16:39:19 <typoclass> Peaker: hm yes. expanding vertically might be worth a shot if it's not too much work. but it might come out as cluttered ... don't invest too much work :-)
16:39:21 <dwcook> Oh dear. The latest Mint/Ubuntu seem to be missing the Haskell Platform package.
16:39:34 <Peaker> but our GUI composition is done using pretty restrictive Box layouts -- we decided to postpone fancy layout to later
16:39:46 <typoclass> Peaker: ... maybe quickly draw it in a drawery program or something
16:40:00 <dwcook> Would I get roughly the same thing just by installing ghc and cabal-install and then whatever other packages I need?
16:40:03 <Peaker> typoclass, no worries, we have other focuses right now w.r.t inferred types.. i.e: right now we're going to worry about how function application with record-of-args looks like
16:40:19 <cmccann> dwcook: pretty much yeah
16:40:20 <dwcook> s/packages/Haskell packages/
16:40:29 <dwcook> All right, thanks
16:40:43 <cmccann> dwcook: in fact that's all I ever do
16:44:01 <Peaker> typoclass, my gimp skills are lacking, I discover :)
16:44:11 <Peaker> the UI is cluttered with a bazillion advanced options I don't need
16:44:21 <Peaker> If you know the shortcuts for everything I guess that can be efficient
16:44:56 <typoclass> Peaker: the moar options and buttons a program has, the better. use some common sense, man
16:44:59 <typoclass> :-)
16:45:48 <typoclass> dwcook: i'm not sure about the platform, but if you ever find a distro's ghc package too old or something, the ghc website offers universal binary packages that are up to date and easy to install. not sure if the platform does the same
16:46:14 <monochrom> the platform itself is always a bit old :)
16:46:20 <geekosaur> not for linux :( points to distro packages, or there's a source installer
16:46:23 <Peaker> For now, our only layout tool is the Grid, which takes a bunch of statically-sized widgets, each with a statically-determined point of alignment inside it, and puts all the widgets in the given grid form, such that the alignment points are aligned horizontally and vertically
16:46:38 <dwcook> What geekosaur said
16:47:08 <Peaker> so can't easily do something like an auto-vertically-expanding inferred type box
16:47:14 <monochrom> but consider 2013.4.0.0's RC2: http://trac.haskell.org/haskell-platform/wiki/ReleaseCandidates
16:47:16 <dwcook> Oh never mind, GHC does have that it seems
16:47:51 * geekosaur is checking his mint install, just in case something vanished?
16:48:08 <dwcook> I'm probably not going to bother with anything not in my distro repo unless I find that I'm more limited than I'm okay with
16:48:34 <dwcook> geekosaur, I just upgraded to Mint 15 RC. haskell-platform is not in the repo for that
16:48:48 <geekosaur> oh :(
16:48:55 <dwcook> ghc and cabal-install are though
16:49:01 <dwcook> which I suppose will suffice
16:49:05 <monochrom> ubuntu 13.04 does not have the haskell-platform metapackage but it has enough constituent packages
16:49:17 <dwcook> I wonder why they even removed that package though
16:49:26 * geekosaur may consider not updating his mint install for a while...
16:50:40 <typoclass> > splitAt 1 "lolcats" -- do we have a thingy that does head and tail simultaneously? splitAt 1 is _nearly_ it. it'd just have to give ('l',"olcats")
16:50:42 <monochrom> err, 2013.2.0.0
16:50:42 <lambdabot>   ("l","olcats")
16:51:35 <monochrom> typoclass: you need to see my ...crossroad.xhtml :)
16:51:51 <Hafydd> @hoogle [a] -> (a,[a])
16:51:51 <lambdabot> Data.Char readLitChar :: ReadS Char
16:51:51 <lambdabot> Language.Haskell.TH.Ppr split :: Type -> (Type, [Type])
16:51:51 <lambdabot> Numeric readFloat :: RealFrac a => ReadS a
16:51:54 <Hafydd> @hoogle [a] -> Maybe (a,[a])
16:51:55 <lambdabot> Language.Haskell.TH.Ppr split :: Type -> (Type, [Type])
16:51:55 <lambdabot> Data.Generics.Twins gmapAccumQ :: Data d => (forall e. Data e => a -> e -> (a, q)) -> a -> d -> (a, [q])
16:51:55 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
16:52:02 <Hafydd> @hoogle [a] -> (a,Maybe [a])
16:52:03 <lambdabot> No results found
16:52:19 <Fuuzetsu> I'm sure some combinator exists…
16:52:20 <typoclass> monochrom: heh, your site is google's #1 hit for "crossroad.xhtml" :)
16:52:26 <monochrom> actually parsec's uncons is close to what you want
16:53:11 <typoclass> monochrom: right. i was thinking "un:"
16:53:40 <monochrom> apart from parsec's uncons there is none in the usual libs. because pattern-matching!
16:53:47 <geekosaur> interestingly, bytestring and text have that
16:53:54 <geekosaur> yeh
16:53:57 <zxs> Is there an accepted name for the function f :: a -> a -> Bool -> a? (I'm currently calling it bool)
16:54:02 <Hafydd> @pl \h:t -> (h,t)
16:54:02 <lambdabot> liftM2 (,) head tail
16:54:08 <elliott> zxs: bool is the common name.
16:54:18 <zxs> okay
16:54:21 <typoclass> monochrom: you're of course right that pattern matching is much more the cat's pajamas than things that are not the cat's pajamas. however, here it's a case of replacing "head <$> x" and "tail <$> x"
16:54:30 <elliott> zxs: to perfectly match maybe, either, etc., the first argument should be the False case, mind
16:54:42 <elliott> (foldr violates this, but isn't called "list")
16:54:47 <adnap> Can I repost my question?
16:55:01 <monochrom> then perhaps write it yourself. behead (x:xs) = (x, xs) or something
16:55:04 <zxs> I see
16:55:17 <adnap> Is it possible to make this function work without the Int argument? http://hpaste.org/88325
16:55:17 <typoclass> adnap: i found it hard to understand the first time, but fine by me :-)
16:55:53 <elliott> zxs: not a big deal if you swap it though
16:56:11 <elliott> zxs: if' is a common name for the version that takes the Bool then the True case then the False case, for obvious reasons
16:56:14 <elliott> e.g. @pl uses it
16:56:40 <zxs> What about the function f :: (a -> b) -> (a -> b) -> (a -> Bool) -> a -> b? Is there a name for that? Is there a formal term for the relationship between that and bool?
16:57:34 <typoclass> adnap: fwiw, check the annotation on your paste *shrug*
16:58:17 <monochrom> @type on
16:58:18 <typoclass> @type either
16:58:19 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
16:58:20 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
16:58:38 <cmccann> elliott: you should send a proposal to libraries@ for swapping the arguments and renaming foldr to list.
16:58:52 <elliott> zxs: that looks like liftA3 bool
16:59:07 <elliott> cmccann: how many +s will you give it?
16:59:15 <cmccann> all of them
16:59:38 <typoclass> zxs: either does something quite like that. and i guess i'd call it simply bool' or something :-/
17:00:20 <zxs> I think I'll just liftA3 bool whenever I need it
17:00:30 <typoclass> zxs: ("does something like it" meaning, it runs either the left or the right function, which both need to give the same type)
17:00:37 <ski> zxs : i'vs seen `cond :: (a -> Bool) -> (a -> b) -> (a -> b) -> (a -> b)'
17:01:26 <zxs> typoclass, yeah, I got that
17:01:27 <adnap> typoclass: That will not work. In f, you called go with 0 bound to n, so it's just going to return y'
17:02:08 <typoclass> adnap: you're right
17:02:12 <zxs> ski, every time I see these the arguments are switched around!
17:02:32 <typoclass> @type liftA3 (undefined :: (a -> a -> Bool -> a))
17:02:33 <lambdabot> Applicative f => f d -> f d -> f Bool -> f d
17:02:39 <ski> from what i said or from what you said ?
17:02:44 <ski> @type let foo = flip . foldr in foo . foo
17:02:45 <lambdabot> (a -> c -> c) -> [[a]] -> c -> c
17:02:47 <typoclass> that's missing a 'd', compared to the one zxs gave, isn't it
17:03:04 <zxs> they're just always different from the last way I saw them
17:03:41 <ski> @pl \a b c -> if a then b else c
17:03:41 <lambdabot> if'
17:03:44 <monochrom> hi, I am writing this function cool :: a -> Bool -> a -> a; cool x True y = y; cool x False y = x
17:03:59 <elliott> monochrom: guido, is that you?
17:04:14 <elliott> (ok, guido swaps x and y)
17:04:15 <monochrom> no, I'm Cool
17:04:38 <monochrom> guido's is called dool in my library!
17:04:39 * hackagebot Elm 0.8 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.8 (EvanCzaplicki)
17:04:41 * hackagebot elm-server 0.8 - The Elm language server.  http://hackage.haskell.org/package/elm-server-0.8 (EvanCzaplicki)
17:04:42 <zxs> is if' actually defined somewhere?
17:04:58 <elliott> depends what you consider to be somewhere :P
17:05:13 <monochrom> is it on hackage?
17:06:03 <zxs> I mean, where does lambdabot get it from?
17:06:10 <cmccann> it is defined in our hearts
17:06:21 <cmccann> zxs: from Cale, probably.
17:06:28 <elliott> .@pl gets it from axiom
17:06:29 <cmccann> that's where lambdabot gets most things.
17:07:35 <adnap> If I had a function f :: Applicative => f [a] -> [f a], then I could write a function g :: (Applicative f, Monad m) => f [a] -> (f a -> f (m b)) -> f (m b) as g x h = (foldl1 (>>)) <$> (sequenceA $ map h (f x)
17:07:41 <typoclass> i think the danger with bool and related functions is that you can swap the order of the values by mistake, and the type checker can't help you. this is different from maybe and either
17:07:46 <adnap> )
17:08:01 <zxs> indeed
17:08:36 <cmccann> data True = True; data False = False; type Bool = Either False True
17:08:37 <cmccann> problem solved.
17:08:46 <zxs> you could manually wrap them with an identity functor though
17:09:04 <zxs> but that would be unnecessarily ugly
17:09:56 <ski> @type Data.Traversable.sequenceA
17:09:57 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
17:10:21 <shachaf> @ty Data.Distributive.distribute
17:10:23 <lambdabot> (Functor f, Data.Distributive.Distributive g) => f (g a) -> g (f a)
17:12:41 <ski> @type \g x h -> foldl1 (>>) `fmap` Data.Traversable.sequenceA (map h (Data.Distributive.distribute x))
17:12:42 <lambdabot>     No instance for (Data.Distributive.Distributive [])
17:12:42 <lambdabot>       arising from a use of `Data.Distributive.distribute'
17:12:42 <lambdabot>     Possible fix:
17:12:50 <ski> mhm
17:25:06 <gwern> @quote
17:25:06 <lambdabot> desp says: [monochrom]: It is, however, hard to demand other people to be open-minded. [desp]: not if you've got a big enough axe
17:26:50 <Rembane> :D
17:27:22 <cmccann> johnw: break everything and embrace the future is a philosophy I can support
17:28:37 <monochrom> if you break everything, I am not sure you have a future
17:29:24 <typoclass> 'support' is of course in the sense of 'not support'
17:29:47 <_{^_^}__> whats the difference between foo :: (Char a) => a -> a and  foo :: Char -> Char ?
17:29:57 <cmccann> well, support more in the sense of "actually support a not-humorously-exaggerated version".
17:30:04 <cmccann> if you want to be picky about it.
17:30:21 <typoclass> "this software doesn't support the files it wrote yesterday anymore. it supports only hypothetical future files in the one ultimate format, which we are bound to discover any year now"
17:31:10 <cmccann> sounds good to me!
17:32:18 <typoclass> _{^_^}__: one doesn't work, the other one does :-/ on the left side of "=>", you can use (nearly) only typeclasses. Char is a type, not a typeclass. but you could use "(Num a) =>" or "(Eq a) =>" for example
17:32:47 <_{^_^}__> typoclass: ah im a newb still grokking diff between types and typeclasses thnx
17:32:51 <monochrom> a type class does not give you a type
17:34:32 <cmccann> we need type orders, which would clearly be halfway between type classes and type families.
17:36:57 <blaenk> hey, I'm pretty confused with the different (and some now obsolete?) methods of catching exceptions. what function shoudl I look up to catch exceptions thrown by openFile?
17:37:05 <P1RATEZ> i was struggling to take two inputs from the prompt and perform a simple calculation with it, how many instances of main = do can one perform?
17:37:06 <elliott> Control.Exception.catch
17:37:10 <blaenk> thanks
17:37:10 <elliott> or something else from that module
17:37:36 <byorgey> P1RATEZ: you can have only one main
17:37:54 <byorgey> but main can contain as many actions as you like
17:38:46 <typoclass> P1RATEZ: hello, you can have only one main function (as with all function definitions). but you can have multiple lines in main. here's an example http://hpaste.org/88161
17:38:56 <blaenk> elliott: in the case of openFile it returns an IO Handle, what should the exception handler return?
17:39:16 <typoclass> P1RATEZ: (note how the indentation makes the two "print" lines part of the do block)
17:39:19 <elliott> blaenk: well, it depends how you want to handle the exception, somewhat uselessly :P
17:39:20 <P1RATEZ> oh i meant, number of things i can do in main, i want a simple example where i can ask for two input eg. print "enter a number:" then.. x <- getLine and ...print "enter another number" y <- getLine
17:39:41 <cmccann> P1RATEZ: have you tried actually doing that?
17:39:46 <P1RATEZ> and I wanted to define a function to do a basic calculation with it and compile it as an exe yep
17:39:53 <blaenk> elliott: what I mean is, for now I just want to print a message, but wouldn't the return value of catch expect the same type as if it had succeeded?
17:39:58 <cmccann> P1RATEZ: because that should work just fine.
17:40:02 <blaenk> so I have: catch (openFile blah) (exception handler)
17:40:08 <blaenk> shouldnt both things return the same type?
17:40:11 <elliott> yes
17:40:14 <elliott> you can also do:
17:40:21 <elliott> catch (openFile blah >>= myprogramthatusesthefile) (handler)
17:40:21 <blaenk> so I'm wondering how I would return a Handle if I didn't get one at all
17:40:23 <elliott> or
17:40:30 <elliott> catch (openFile blah) exitFailure
17:40:35 <blaenk> like is there a dummy Handle or something
17:40:38 <elliott> also, consider using withFile instead of openFile
17:40:42 <elliott> blaenk: no
17:40:48 <blaenk> for example in that case
17:40:53 <blaenk> catch (openFile blah) exitFailure
17:41:50 <elliott> there, exitFailure terminates the program instead of returning anything
17:41:59 <elliott> so it can claim to be able to return something of any type.
17:42:03 <blaenk> oh okay, but otherwise it would have to return the same time right
17:42:55 <P1RATEZ> i wanted to take the inputs for this with a prompt, using winghci to compile it. The input example on learnusomehaskell.com doenst give an example where I can pass it into a function within the main = do.. just wanted to know if someone can demo an example BMI = ( Weight in Pounds / ( Height in inches x Height in inches ) ) x 703
17:43:14 <fluffynukeit> hi all.  When I run my program, the memory usage in the task manager reports at a steady 75 MB, but when I look at the memory profile with -hc, the memory used only goes to about 25 MB max.  Anyone know why the discrepancy?
17:43:20 <elliott> blaenk: anyway, the advantage of withFile is that it ensures the file gets closed properly
17:43:55 <P1RATEZ> let calcBMI weight height = (weight / (height * height)) * 703) this valid?
17:44:04 <zRecursive> @ty bracket
17:44:06 <lambdabot>     Not in scope: `bracket'
17:44:06 <lambdabot>     Perhaps you meant one of these:
17:44:06 <lambdabot>       `brackets' (imported from Text.PrettyPrint.HughesPJ),
17:44:07 <blaenk> elliott: yeah I was going to use that. basically what I want to do right now is open a file, and if it throws an exception like isPermissionError or isAlreadyInUseError, threadDelay a few milliseconds then try again
17:44:29 <blaenk> but I don't want to do anything with said handle, I just want to get to a point where I'm able to open it
17:44:39 <blaenk> so I want to keep trying to open it, and once I'm able to, I want to close the handle then continue with my program
17:44:50 <elliott> then something like
17:44:56 <blaenk> I'm trying to debug a third-party win32 fs event package
17:45:05 <blaenk> ;_;
17:45:16 <monochrom> blaenk: you should heed the advice of http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/Control-Exception.html#g:3
17:45:17 <elliott> foo name = openFile name `catch` \e -> if ... then threadDelay n >> foo name else throwIO e
17:45:20 <elliott> or something along those lines. you get the idea.
17:45:26 <zRecursive> @ty Control.Exception.bracket
17:45:28 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
17:45:41 <elliott> oh, I guess catch is bad for that, maybe
17:45:42 <blaenk> thanks zRecursive I'll take a look at that
17:45:43 <elliott> as opposed to try
17:45:47 <elliott> per monochrom's link
17:45:57 <monochrom> please don't recurse inside the handler. please just don't.
17:46:12 <monochrom> it is both expensive and wrong behaviour
17:47:00 <monochrom> totally the sweat spot of the "correct vs efficient" tradeoff
17:47:23 <shachaf> this is sweat dreams
17:47:36 <zRecursive> @ty System.IO.withFile
17:47:37 <lambdabot> FilePath -> GHC.IO.IOMode.IOMode -> (GHC.IO.Handle.Types.Handle -> IO r) -> IO r
17:47:45 <zRecursive> @ty System.IO.withBinaryFile
17:47:46 <lambdabot> FilePath -> GHC.IO.IOMode.IOMode -> (GHC.IO.Handle.Types.Handle -> IO r) -> IO r
17:47:50 <typoclass> P1RATEZ: yes, i think you're on the right track. i've written up a few more lines for the example http://hpaste.org/88161
17:48:03 <fluffynukeit> hi all.  When I run my program, the memory usage in the task manager reports at a steady 75 MB, but when I look at the memory profile with -hc, the memory used only goes to about 25 MB max.  Anyone know why the discrepancy?
17:48:24 <blaenk> monochrom: do you have a suggestion for my situation?
17:48:30 <typoclass> fluffynukeit: not much clue, sorry
17:48:32 <monochrom> if you want to "wait a bit and try again", use try, use case-of Left _ -> threadDelay; recurse.
17:48:41 <blaenk> ah okay
17:48:46 <blaenk> that's what I was going to do heh, thanks
17:50:48 <blaenk> you can't use do-notation in case handlers?
17:50:53 <blaenk> blah -> do
17:50:57 <monochrom> can
17:51:01 <blaenk> ok
17:51:10 <blaenk> ohh
17:51:11 <blaenk> :)
17:51:22 <monochrom> but on IRC we want one-liners that's all
17:51:47 <EvanR> do{foo; bar; baz} ;)
17:51:54 <monochrom> also I'm lazy
17:52:29 <monochrom> I used ";" so I certainly had do-notation in mind. I forgot to write "do"
17:53:04 <zxs> Is there a reason to prefer one or the other between liftA3 f x y z and f <$> x <*> y <*> z?
17:53:08 <otters> can $ do
17:53:23 <benzrf> otters: can it do what?
17:53:35 <otters> understand humor
17:53:43 <benzrf> ;)
17:54:18 <monochrom> I don't have a reason to prefer either one
17:54:53 <typoclass> otters: please refer to https://i.chzbgr.com/maxW500/407287040/hFA77D993/
17:58:09 <P1RATEZ> typoclass: thanks... i see how it was typed, i'm guessing the indentation affects this?
17:59:26 <cmccann> > can $ do anything -- benzrf: this is what
17:59:28 <lambdabot>   I sure can!
17:59:36 <typoclass> P1RATEZ: indentation is significant in haskell. for example, it defines where the end of a do block is
18:00:18 <arkeet> :t can
18:00:21 <lambdabot> String -> Doc
18:00:21 <benzrf> ahah
18:00:30 <arkeet> > anything
18:00:31 <P1RATEZ> and that's where i screwed up :) i put all stuff under main = doo and kept indentation the same
18:00:33 <lambdabot>   "I sure can!"
18:00:41 <benzrf> bwa ha ha
18:01:03 <elliott> zxs: liftA3 f partially applies better
18:01:09 <elliott> it's mostly down to taste
18:01:19 <cmccann> arkeet: pay no attention to the @let behind the curtain
18:01:21 <Aetherspawn> Hey I have a question about runTCPServer and network conduits
18:01:26 <monochrom> indentation affects parsing rather than types. unless you say "but parsing affects types".
18:01:45 <Aetherspawn> Let's say I have ## runTCPServer (serverSettings port HostAny) serverApp
18:02:39 <Aetherspawn> Okay, this is better ; http://hpaste.org/88331
18:02:43 <zxs> elliott, I guess liftM3/liftA3 is entirely down to taste then? :)
18:03:00 <Aetherspawn> if I duplicate my TChan where shown, will it get duplicated many times or just once in the sockets lifetime?
18:03:29 <Aetherspawn> I'm confused as to whether serverApp returns a conduit chain which is looped repeatedly or whether serverApp is actually a kind of callback
18:05:21 <elliott> zxs: well, if you have to work on any Monad then the choice is obvious :P
18:05:24 <elliott> otherwise I'd prefer liftA3
18:05:30 <elliott> but YMMV
18:06:44 <zxs> it's the stuff from before... (->) a and Maybe
18:06:56 <shachaf> f `liftM` x `ap` y `ap` z
18:07:02 <zxs> things get ugly when you have two layers of monads though
18:07:55 <zxs> so my code looks like (<|>) <$> (f <=< g) <*> h <*> p
18:09:17 <elliott> yikes
18:10:17 <cmccann> pf. the code is point-free so obviously it is as elegant as can be.
18:11:03 <monochrom> haha fun
18:11:18 <zxs> sorry, no <*> p on that one
18:12:00 <lispy> johnw: I'm sure we can find people who would oppose the change. There was a vocal minority wrt removing n+k afterall.
18:12:11 <zxs> but yeah, it's getting a bit write-only
18:12:23 <lispy> johnw: ghc already has a reputation for breaking everyone's code
18:12:37 <cmccann> n+k patterns were something that should be nice and sensible. they just were defined in a way that was dumb.
18:12:38 <shachaf> We can find people who would oppose the change in that very mailing list thread.
18:12:42 <shachaf> We don't have to look far.
18:12:44 <lispy> johnw: people tend to be shocked when 2-3 year old haskell code still compiles
18:13:11 <monochrom> people tend to be shocked either way :)
18:13:19 <cmccann> it would be nice if there was a more principled and generic way to "pattern match" on reversible function application.
18:13:35 <elliott> cmccann: you should read /The view from the left/. it does stuff like that.
18:13:38 <elliott> shachaf will now kill me.
18:13:48 <copumpkin> why will shachaf kill you?
18:13:55 <cmccann> why wouldn't shachaf kill him?
18:14:02 <shachaf> help
18:14:04 <shachaf> what's going on
18:14:11 <copumpkin> shachaf is a cold-blooded assassin
18:14:13 * copumpkin cowers
18:14:16 <monochrom> why wouldn't shachaf be shocked? :)
18:14:19 <cmccann> shachaf: stop murdering people plz
18:14:27 <cmccann> shachaf: you're scaring copumpkin
18:14:34 <copumpkin> oh I thought this was -blah
18:14:37 <Aetherspawn> shachaf is a murderer?
18:14:38 <Aetherspawn> O
18:14:40 <shachaf> I don't blame you.
18:14:41 <copumpkin> shachaf: fix (1:)
18:14:43 <copumpkin> err
18:14:50 <copumpkin> back on topic
18:14:51 <Aetherspawn> *:O it explains everything.
18:14:57 <cmccann> copumpkin: no no
18:15:01 <cmccann> > fix shachaf
18:15:03 <lambdabot>   Yeah... good luck with that. Sounds hopeless if you ask me. :(
18:15:05 <elliott> copumpkin: well you see, I've been telling shachaf to read it for weeks.
18:15:06 <shachaf> I murder only those who do not murder themselves.
18:15:06 <monochrom> why 1? why not 0? fix (0:)
18:15:10 <Aetherspawn> Is anyone able to answer my question about network-conduit up there ^
18:15:13 <copumpkin> > fix show
18:15:14 <monochrom> or even better, fix (():)
18:15:15 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
18:15:22 <lispy> the murder's paradox
18:15:27 <monochrom> shachaf++
18:15:29 <shachaf> Aetherspawn: Maybe #yesod is an expert in network-conduit.
18:15:37 <Aetherspawn> Ah, good idea
18:15:40 <amosr> dumb question, but unboxed tuples are allowed in unboxed tuples, right? (or should I ask in ghc)
18:15:54 <amosr> ie (# Int# , (# Int#, Int# #) #)
18:16:04 <shachaf> Try it!
18:16:23 <copumpkin> > map (succ . head . tail) . iterate (drop 2) . map length . group . fix $ show
18:16:31 <lambdabot>  Terminated
18:16:38 <copumpkin> > map (succ . head . tail) . iterate (drop 2) . map length . group . fix $ show
18:16:42 <amosr> > (# 1#, 2# #)
18:16:45 <shachaf> Whoops. Looks like I got to lambdabot first.
18:16:46 <lambdabot>   mueval-core: L.hs: removeLink: does not exist (No such file or directory)
18:16:47 <copumpkin> > take 5 . map (succ . head . tail) . iterate (drop 2) . map length . group . fix $ show
18:16:49 <lambdabot>   [2,4,8,16,32]
18:16:56 <lambdabot>  Terminated
18:16:57 <elliott> that L.hs error is a new one.
18:17:05 <cmccann> that's a nice error.
18:18:18 <amosr> I don't actually know how to construct unboxed tuples. oh well
18:18:46 <elliott> (# a, b #)
18:19:00 <lispy> Clearly the filesystem should be synchronous.
18:19:05 <lispy> So many problems would be avoided.
18:19:19 <amosr> hmm with -XMagicHash?
18:19:28 <copumpkin> not only
18:20:50 <amosr> ah. sorry. I needed -fglasgow-exts
18:21:00 <copumpkin> noooo
18:21:13 <copumpkin> -XUnboxedTuples
18:21:18 <_{^_^}__> is there a way to define an operator to be defaultly infix like + for example?
18:21:20 <copumpkin> glasgow-exts is super deprecated
18:21:55 <amosr> copumpkin: ah! thanks
18:22:04 <cmccann> _{^_^}__: as opposed to what?
18:22:18 <cmccann> anything with symbols for a name is infix by default.
18:22:28 <_{^_^}__> oh yeah?
18:22:32 <_{^_^}__> ah, didn't know that
18:23:11 <cmccann> > let (!?!?) = (++) in "foo" !?!? "bar"
18:23:26 <lambdabot>   thread killed
18:23:28 <cmccann> hm.
18:23:55 <cmccann> > let (!?!?) = (++) in "foo" !?!? "bar"
18:23:57 <lambdabot>   "foobar"
18:24:03 <cmccann> lambdabot is weird.
18:24:48 <cmccann> _{^_^}__: you can also use alphanumeric names infix with backticks like `this`
18:24:56 <cmccann> > 11 `mod` 3
18:24:57 <lambdabot>   2
18:25:04 <shachaf> You can also use alphanumeric names for your nick in IRC.
18:25:08 <shachaf> It's a little-known feature.
18:25:25 <cmccann> shachaf: no
18:25:32 <cmccann> you can only use SOME alphanumeric names.
18:25:38 <cmccann> it won't let me use anything interesting :[
18:26:03 * cmccann just wants a fraktur nick is that so much to ask
18:27:00 <shachaf> Casey C. Cmccann
18:27:32 <_{^_^}__> ^|{`-}^{: hello rival
18:27:32 <^|{`-}^{> you can use use something like my nick
18:27:33 <cmccann> now THAT is a nick.
18:27:39 <cmccann> I am impressed.
18:27:46 <^|{`-}^{> unfortunately it is not a valid haskell operator
18:27:54 <^|{`-}^{> TTYL
18:28:03 <{-_-}> this isn't me
18:28:12 <Clint> no one is
18:28:33 <monochrom> yeah, you are co{-_-} instead
18:28:42 <elliott> /mode +b *{*}*
18:28:57 <eliot> ^_^
18:28:59 <cmccann> haha yes good
18:28:59 <_{^_^}__> lol
18:29:08 <elliott> ooooh, now you've done it.
18:29:34 <[^___^]> hi
18:29:37 <shachaf> Oh, come on.
18:29:41 <[^___^]> oops.
18:29:50 <shachaf> This is enough.
18:30:05 <arkeet> well, [^_^] and [^__^] were registered
18:30:11 * eliot hands shachaf: the mjolnir
18:30:37 <elIiott> this is a good idea.
18:30:48 <arkeet> l and I are quite distinguishable here.
18:30:55 <monochrom> oh yikes, we're now playing nickname musical chair
18:31:03 <elIiott> arkeet: lame!
18:31:38 <elliott> my existing tools are inadequate.
18:31:45 <elliott> I am going to have to invent entirely new IRC modes to punish you lot.
18:32:05 <elliott> /mode +suffering cmccann
18:32:43 <monochrom> /mode +MonomorphismRestriction
18:33:11 <monochrom> it means the recipient is forbidden from using polymorphism
18:33:35 <monochrom> it is also a bit long
18:44:39 <Aetherspawn> @pl (\x -> liftIO . atomically $ dupTChan x)
18:44:40 <lambdabot> liftIO . atomically . dupTChan
18:46:08 <EvanR> unsafePerformIO . atomic . launchMissiles
18:48:49 <Aetherspawn> @pl (ssBroadcastCh .= tch
18:48:49 <lambdabot> (line 1, column 22):
18:48:50 <lambdabot> unexpected end of input
18:48:50 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or ")"
18:48:59 <Aetherspawn> @pl (\x -> ssBroadcastCh .= x)
18:48:59 <lambdabot> (ssBroadcastCh .=)
18:49:29 <elliott> (assign ssBroadcastCh), I believe.
18:52:30 <Aetherspawn> I found it nicer to just do (.=) ssBroadcastCh
18:52:34 <Aetherspawn> but thanks
18:53:35 <Aetherspawn> I was able to golf the 3-line procedure into what I think is a much nicer, but still readable, format
18:53:39 <Aetherspawn> use ssBroadcastCh >>= liftIO . atomically . dupTChan >>= (.=) ssBroadcastCh
18:54:18 <shachaf> That is not readable. Add points. hth
18:55:13 <Aetherspawn> I dont understand
18:55:21 <Aetherspawn> are you trolling or giving a suggestion ;_;
18:56:07 <monochrom> suggestion
18:56:17 * elliott finds (use ssBroadcastCh >>= liftIO . atomically . dupTChan >>= assign ssBroadcastCh) readable
18:56:42 <shachaf> That's better than prefix (.=), sure.
18:57:06 <blackdog> shachaf: maybe a section for (.=) ?
18:57:17 <shachaf> Also possible.
18:57:19 <Aetherspawn> guess where my ruler 80 line is http://puu.sh/2Yvod/d662deda56.png
18:57:23 <Aetherspawn> ;___; lol
18:57:50 <monochrom> this is why I use 90 columns
18:58:06 <shachaf> This is why I use multiple rows.
18:58:30 <monochrom> I am also fond of row polymorphism
18:58:34 <elliott> you can just linebreak after the (>>=) or such. nothing wrong with that.
18:58:59 * Aetherspawn chopped Ch off of ssBroadcast
18:59:02 <monochrom> oh, speaking of which, this is what people wrote before do-notation:
18:59:11 <monochrom> getLine >>= \cs ->
18:59:36 <monochrom> getContents >>= \xs ->
18:59:38 <monochrom> etc etc
19:00:14 <Aetherspawn> @pl (\x -> initState x . initReader $ prop)
19:00:15 <lambdabot> flip (. initReader) prop . initState
19:01:10 <elliott> Aetherspawn: a tip: if you have to put all your code through @pl to know what its point-free form is, you should not be using its results
19:10:09 <Aetherspawn> has it been considered to give 'flip' an operator?
19:10:37 <byorgey> Aetherspawn: Control.Lens exports (??) = flip
19:10:47 <Aetherspawn> oh, awesome.
19:11:56 <arkeet> :t (??)
19:12:05 <lambdabot> Functor f => f (a -> b) -> a -> f b
19:12:19 <byorgey> I guess it's actually a generalized flip
19:12:36 <Aetherspawn> Anything that does the same as f -> (. f) ?
19:13:09 <arkeet> like  flip (.)  ?
19:13:30 <byorgey> (>>>)
19:13:44 <byorgey> from Control.Arrow
19:13:46 <Aetherspawn> @src (>>>)
19:13:46 <lambdabot> Source not found. Where did you learn to type?
19:13:49 <arkeet> or that
19:13:51 <Aetherspawn> Oh, arrow.
19:13:57 <byorgey> @type (>>>)
19:13:58 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
19:16:49 <_{^_^}__> is there a more terse way to do this? https://gist.github.com/4fea4918e3b721154dd2
19:19:31 <Hafydd> > (\first last -> [head first] ++ ". " ++ [head last] ++ ".") "Horatio" "Nelson"
19:19:32 <blaenk> _{^_^}__: I think you can replace (x:_) with [x] etc.
19:19:33 <lambdabot>   "H. N."
19:19:46 <_{^_^}__> thnx
19:19:53 <Hafydd> I disagree with blaenk.
19:20:04 <blaenk> Hafydd: I'm not saying he should, I'm saying I think it's syntactically correct
19:20:06 <blaenk> I don't prefer it myself
19:20:08 <lispy> yeah [x] changes the meaning
19:20:11 <blaenk> but he did ask for making it more terse
19:20:25 <blaenk> it's not equivalent then?
19:20:25 <_{^_^}__> Hafydd: keeping the where clause. its not for production im just trying to learn where clauses better
19:20:30 <lispy> > case [1,2,3] of [x] -> x
19:20:30 <EvanR> you can replace (x:[]) with [x]
19:20:32 <lambdabot>   *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
19:20:37 <blaenk> aaah okay
19:20:38 <kennyd> [x] will match just match a list with single element
19:20:40 <enthropy> > let initials ((toUpper -> f):_) ((toUpper -> l):_) = f : ". " ++ l : "." in initials "Horatio" "Nelson"
19:20:41 <blaenk> thanks :)
19:20:43 <lambdabot>   "H. N."
19:21:04 <Hafydd> Oh, I forgot the toUpper.
19:21:20 <enthropy> > let initials (f:_) (l:_) = toUpper f : ". " ++ toUpper l : "." in initials "Horatio" "Nelson"
19:21:21 <lambdabot>   "H. N."
19:22:15 <Hafydd> @hoogle (a -> b) -> (a, a) -> (b, b)
19:22:18 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
19:22:18 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
19:22:18 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
19:23:09 <Hafydd> @hoogle (a -> b) -> a -> a -> c
19:23:10 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
19:23:10 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
19:23:11 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
19:24:02 <blaenk> > let initials (f:_) (l:_) = mconcat [[toUpper f], ". ", [toUpper l], "."] in initials "Horatio" "Nelson"
19:24:04 <lambdabot>   "H. N."
19:24:07 <blaenk> forgive me ;_;
19:24:46 <blaenk> can replace mconcat with just concat lol
19:24:57 <blaenk> obvious I just read more about monoids
19:26:36 <Hafydd> > ((\f l -> f ++ ". " ++ l ++ ".") `on` map toUpper . take 1) "Horatio" "Nelson"
19:26:38 <lambdabot>   "H. N."
19:26:46 <blaenk> cool what's on from
19:26:58 <Hafydd> Data.Function
19:27:00 <blaenk> @hoogle on
19:27:00 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
19:27:00 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
19:27:00 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
19:27:54 <Hafydd> > printf "%s. %s." "Horatio" "Nelson"
19:27:55 <lambdabot>   Ambiguous type variable `a0' in the constraints:
19:27:56 <lambdabot>    (GHC.Show.Show a0)
19:27:56 <lambdabot>     ...
19:28:08 <Hafydd> > printf "%s. %s." "Horatio" "Nelson" :: String
19:28:10 <lambdabot>   "Horatio. Nelson."
19:28:43 <Hafydd> > (printf "%s. %s." `on` map toUpper . take 1) "horatio" "nelson" :: String
19:28:44 <lambdabot>   can't find file: L.hs
19:28:49 <Hafydd> > (printf "%s. %s." `on` map toUpper . take 1) "horatio" "nelson" :: String
19:28:50 <lambdabot>   "H. N."
19:29:36 <Hafydd> > (printf "%s. %s." `on` toUpper . head) "horatio" "nelson" :: String
19:29:38 <lambdabot>   "*Exception: Printf.printf: bad argument
19:29:44 <Hafydd> > (printf "%c. %c." `on` toUpper . head) "horatio" "nelson" :: String
19:29:46 <lambdabot>   "H. N."
19:30:54 <rgrinberg> wrong channel I know, but is there an algorithm to find the dual of a planar graph?
19:31:03 <rgrinberg> i can't seem to google something concrete
19:33:26 <blaenk> that on function is pretty cool
19:33:34 <blaenk> it shows an example of using it like sortBy (compare `on` fst)
19:33:39 <blaenk> I used to do (comparing fst)
19:33:42 <blaenk> similar thing it seems
19:33:56 <dav> In ghci, if I do let f = readFile "blah", how can I turn f from an IO String to a String so that I can pass it to pure functional code?
19:33:56 <lambdabot> dav: You have 1 new message. '/msg lambdabot @messages' to read it.
19:34:08 <blaenk> dav f <- readFile "blah"
19:34:31 <dav> blaenk: works :) thanks -- didn't know that was valid ghci syntax
19:34:35 <elliott> I think comparing is even defined with on
19:34:48 <byorgey> @src comparing
19:34:49 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
19:34:52 <blaenk> I don't think it is, at least I remember looking at its source it just applies the parameter to both functions
19:35:13 <blaenk> comparing :: (Ord a) => (b -> a) -> b -> b -> Ordering
19:35:13 <blaenk> comparing p x y = compare (p x) (p y)
19:35:25 <byorgey> blaenk: maybe not, it is equivalent though.  comparing = (compare `on`)
19:35:27 <sj4nz> rgrinberg: it's C++... https://github.com/aaw/boost_planar_graph_dual   no idea if this helps.
19:35:43 <blaenk> byorgey: yeah that's what I was thinking, cool
19:36:01 <byorgey> blaenk: I still tend to use 'comparing' in that situation, but 'on' is more generally useful
19:36:07 <blaenk> yeah seems like it
19:36:20 <blaenk> haha man what is this
19:36:22 <blaenk> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Ord.html
19:36:33 <blaenk> (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h, Ord i, Ord j, Ord k, Ord l, Ord m, Ord n, Ord o) => Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
19:36:35 <blaenk> ?
19:36:45 <blaenk> theres many more like it too
19:36:46 <rgrinberg> sj4nz: thanks seems like it would be
19:36:57 * rgrinberg hates reading c++
19:36:57 <byorgey> blaenk: what, you never want to sort 15-tuples?
19:36:58 <dav> where does lambda bot get its @src ? I hope it's not from the prelude :)
19:37:05 <blaenk> oh haha it's for that?
19:37:07 <blaenk> oh duh
19:37:12 <blaenk> lol
19:37:18 <blaenk> just noticed that's a tuple
19:37:39 <blaenk> seems pretty arbitrary like people get tired after a few arbitrarly
19:37:44 <blaenk> guy who made zipWith up to like what, 7
19:37:46 <blaenk> got tired after 7
19:37:48 <blaenk> this guy got tired after 15
19:37:54 <byorgey> blaenk: indeed =)
19:38:05 <blaenk> haha
19:38:07 <byorgey> blaenk: but you have to stop somewhere
19:38:11 <blaenk> yeah
19:38:30 <byorgey> blaenk: in practice, if you are using 16-tuples, you have way bigger problems than the lack of an Ord instance
19:38:36 <Hafydd> Hahah.
19:38:37 <EvanR> how tired are you at the end of a list
19:38:37 <blaenk> yeah haha
19:39:14 <Hafydd> Doesn't Template Haskell have a way to define functions like that on tuples of arbitrary length?
19:39:40 <dav> @src sortBy
19:39:41 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
19:39:41 <sj4nz> > take 26 ["Ord "++[x] | x <- ['a'..]] -- how could you get tired doing that?
19:39:43 <lambdabot>   ["Ord a","Ord b","Ord c","Ord d","Ord e","Ord f","Ord g","Ord h","Ord i","O...
19:39:59 * sj4nz winces at the extra quotes. :)
19:40:00 <dav> this looks like an insertion sort which I'm pretty sure isn't what's in the prelude, where is this stuff from?
19:40:35 <blaenk> I think that is indeed from prelude, at least I remember that definition from somewhere
19:40:43 <blaenk> *from prelude
19:40:54 <byorgey> dav: @src takes its definitions from a text file stored with lambdabot
19:41:06 <byorgey> most of those are taken from the Haskell Report
19:41:26 <byorgey> but the Report is understood as specifying the *semantics* of Prelude functions, not the implementation
19:41:32 <byorgey> so a more efficient implementation is used in practice
19:41:37 <blaenk> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v:sortBy
19:41:41 <dav> byorgey: ah, that makes a lot of sense. thanks.
19:41:42 <blaenk> #ifdef USE_REPORT_PRELUDE
19:41:42 <blaenk> sort = sortBy compare
19:41:42 <blaenk> sortBy cmp = foldr (insertBy cmp) []
19:41:42 <blaenk> #else
19:42:05 <blaenk> check the source
19:42:11 <blaenk> under that it shows another implementation
19:44:32 <dav> blaenk: yep, I see it now, thanks.
19:44:37 <blaenk> yup
19:48:09 <blaenk> is this the correct use of try? res <- try $ openFile path ReadMode
19:48:22 <blaenk> cause I'm getting an 'ambiguous use of e0' error
19:48:50 <blaenk> ambiguous type variable 'e0' in the constraint: (Exception e0) arising from a use of 'try'
19:49:01 <blaenk> it says to add a type signature, I would, but I don't know which exception in particular I'm gonna get
19:49:30 <blaenk> so I did :: IO (Either e Handle) since I do know I'll get a Handle if it does work
19:49:31 <EvanR> if you dont know, then you shouldnt catch
19:49:42 <blaenk> alright so
19:50:05 <EvanR> bracket, finally, etc instead
19:50:07 <blaenk> more accurately, what should I do if there are two exceptions I want to handle
19:50:13 <EvanR> theres catches
19:50:14 <blaenk> for which I want the same behavior
19:50:16 <blaenk> ah alright
19:50:17 <blaenk> thanks
19:52:33 <blaenk> openFile says it fails with "isPermissionError" ( http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#v:openFile )
19:52:49 <blaenk> how do I check against that, becuase I looked that up and its a function that returns a Bool (as the name would suggest)
19:53:02 <blaenk> defined here http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Error.html#v:isPermissionError
19:53:17 <EvanR> yeah dont use isPermissionError
19:53:30 <EvanR> theres an exception type with a similar name
19:53:30 <blaenk> is there an alternative?
19:53:33 <blaenk> oh okay
19:53:36 <blaenk> hmm
19:53:55 <blaenk> I guess permissionErrorType
19:54:03 <blaenk> its type is IOErrorType though
19:54:06 <EvanR> no
19:54:45 <EvanR> heh, when i get permission errors, i fix the permissions and reboot ;)
19:55:11 <blaenk> yeah I'm afraid it's not that simple. I'm in windows
19:55:30 <blaenk> I'm trying to fix a bug in a third party, 2 levels deep (dependency to a dependency) package
19:55:33 <EvanR> there should be a WindowsOS exception
19:55:35 <blaenk> that performs file system notifications
19:55:45 <EvanR> occurs if attempting to run on windows
19:55:49 <blaenk> everything works perfectly fine on linux of course but I have to get this working on windows ;(
19:56:14 <blaenk> harhar slamming on windows never gets old does it
19:56:20 <EvanR> still, fix the permissions
19:56:25 <blaenk> it's not a permissions issue
19:56:27 <blaenk> is what I'm saying
19:56:34 <blaenk> this is just how the error manifests in haskell
19:56:41 <EvanR> o_O
19:56:47 <EvanR> oh youre doing real work
19:56:59 <blaenk> it's very confusing, like I said I'm trying to fix a bug in a 2-level deep dependency for my project
19:57:10 <blaenk> basically it's a file system notification package
19:57:20 <blaenk> to tell me when the user modifies a file
19:57:42 <monochrom> the type is IOException or IOError (aliases). you try/catch for that. when you get the exception value, use isPermissionError or similar predicates to test.
19:57:43 <blaenk> but with that package, when I read the file after getting the notification, it could be that the program that modified it still has the file handle or something
19:57:52 <blaenk> and so if you try to open the file, it gives a permission error
19:58:06 <blaenk> monochrom: aaaahhh I understand now, thank you!
19:58:34 <blaenk> so I'm trying to make it so that it keeps trying to open the file until it no longer presents that error
19:59:30 <blaenk> thanks monochrom, got it compiling :)
20:00:14 <EvanR> if it compiles its perfect
20:00:19 <blaenk> haha
20:01:38 <blaenk> yesss my fix works
20:01:43 <blaenk> thank you very much
20:05:08 <blaenk> does System.IO.Error re-export 'try
20:05:10 <blaenk> '?
20:05:29 <blaenk> I don't see mention of it in the docs for it, but when I import ghc tells me of the collision/ambiguity
20:05:49 <elliott> perhaps differing versions
20:05:57 <blaenk> ah okay
20:06:46 <blaenk> lame haha, I replaced Control.Exceptino with System.IO.Error but now it tells me System.IO.Error is deprecated
20:06:51 <blaenk> but that's where isPermissionError is defined
20:07:12 <blaenk> ah it's only referring to try it seems
20:07:16 <blaenk> I'll just hide ioerror's try
20:08:42 <blueonyx> hi, how to get an Int from a CInt?
20:08:58 <EvanR> fromIntegral
20:09:06 <blueonyx> :t fromEnum
20:09:07 <lambdabot> Enum a => a -> Int
20:09:12 <blueonyx> :t fromIntegral
20:09:14 <lambdabot> (Integral a, Num b) => a -> b
20:09:18 <EvanR> fromEnum
20:09:19 <blueonyx> ah thanks
20:12:36 <blaenk> is there a built-in function for trying to acquire a file handle until it can? that is, in case some other program has a file locked or whatever. I rolled my own version which simply tries to open it, or sleeps then retries (recursing) but I don't know if there's another built in way
20:13:47 <blaenk> seems like that's the way to do it
20:16:21 <td123> blaenk: sounds like flock(2)
20:19:10 <blaenk> td123: well the file isn't actually locked, I don't think, it's just that another program has it open, and so I can't open it. but thanks I'm looking into that, and what windows' equivalent is
20:20:42 <EvanR> its locked
20:21:14 <blaenk> it's opened by sublime text, if that says anything
20:21:39 <td123> oh this is a windows issue
20:24:15 <td123> blaenk: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IO-FD.html#line-195 looks interesting
20:25:00 <blaenk> td123: thanks, reading
20:25:58 <blackdog> blaenk: oh, that kinda sucks. i wrote a little c program to show there's no problem writing to the same file from different processes, but i know nothing about windows filesystem semantics
20:26:07 <td123> System.IO openFile -> System.IO openFile'-> GHC.IO.FD openFile
20:26:21 <blaenk> blackdog: yeah it does suck :(
20:26:32 <blaenk> it seems it's a common problem with windows' file system notification API
20:26:37 <blaenk> http://stackoverflow.com/a/14040978/101090 last paragraph mentions it
20:26:50 <blaenk> and this question mentions it, and asks for the workaround I came up with http://stackoverflow.com/questions/50744/wait-until-file-is-unlocked-in-net
20:26:57 <blaenk> which is to simply keep trying with sleep intervals
20:27:11 <td123> blaenk: this looks promising http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IO-Handle-FD.html#line-159
20:27:12 <blaenk> excerpt: "I have a service that uses a FileSystemWatcher to look for files that are to be transmitted to an FTP site, but the file created event fires before the other process has finished writing the file."
20:27:44 <blaenk> td123: thanks, reading
20:36:59 <kfish> https://docs.google.com/forms/d/1lKckA0pA6K4uQ-UnnmjRR32PKHph0WeZoQeVTTQJZ4I/viewform
20:52:21 <blaenk> is there a way to see which imports are unnecessary? I know GHC sometimes says that one is redundant, but is there a way to see which are not necessary at all?
20:53:18 <bobajett> I have a list of kids who play tennis, and I'd like to pair them by closest age.
20:53:37 <bobajett> so for example:   ages = [6, 7, 7, 9, 10, 11] should transform to
20:53:56 <bobajett> [ (7, 7), (9, 10), (6, 11) ]
20:54:18 <bobajett> any hints on how to do this? I think this is a hard problem because
20:54:21 <EvanR> is that the most optimal
20:54:30 <ParahSail1n> why not (6,7), (7,9), (10,11)
20:54:35 <EvanR> need more criteria
20:55:08 <bobajett> because difference_in_age(7,7) = 0 [optimal]
20:55:16 <EvanR> 6 and 11 ?
20:55:18 <bobajett> difference_in_age(9,10) = 1 [optimal]
20:55:29 <blackdog> if it's just about difference between them, i think sorting then taking pairs is best
20:55:33 <bobajett> difference_in_age(6,9) = 2 (2 > 1 not optimal)
20:55:44 <blackdog> bobajett: where does that leave the poor little 6yo against the 11yo?
20:56:34 <bobajett> @blackdog :-) I know that's unfair to the 6yo, but unfortunately that's the constraint on the problem :-)
20:56:34 <lambdabot> Unknown command, try @list
20:56:39 <EvanR> so 6,7 7,9 and 10,11 makes more sense
20:56:53 <blackdog> bobajett: the problem is that you haven't specified the constraint yet.
20:57:20 <cmears> bobajett, I'd do it like this: find the closest pair (x,y), delete x and y from the list, repeat
20:57:22 <blackdog> if you want to phrase it as "give me the maximum number of pairings where there's a hard limit on the disparity", that's a different question.
20:57:56 <EvanR> for all configurations of pairs, pick the one (or one of the ones) with lowest maximum difference
20:58:15 <bobajett> @blackdog yeah I understand what you're saying, the hazy constraint in my head is that the function should maximize the number of pairs with the least age difference between them.
20:58:15 <lambdabot> Unknown command, try @list
20:59:05 <blackdog> bobajett: perhaps try to come up with a numerical formula for assessing the goodness of a particular matching
20:59:18 <bobajett> @cmears that sounds about right, I actually solved this problem in a non-functional language, I didn't know how to solve it with non-mutable variables in haskell
20:59:18 <lambdabot> Unknown command, try @list
20:59:23 <blackdog> and then you can work backwards from that structure to see if there's a clever way of computing it.
21:01:36 <blackdog> bobajett: if you have an existing implementation, you could post that in a gist and people could suggest translations?
21:02:30 <bobajett> @blackdog will do.
21:02:30 <lambdabot> Unknown command, try @list
21:03:28 <blackdog> bobajett: also, every time you use the @ symbol, lambdabot gets confused :)
21:03:45 <blackdog> (and in general, people won't get notified)
21:03:46 <bobajett> sheesh! twitteritis
21:05:03 <chrisdotcode> hello everyone :)
21:07:05 <enthropy> blaenk: -ddump-minimal-imports
21:07:15 <blaenk> thanks enthropy
21:07:58 <enthropy> it doesn't directly say which ones are unnecessary, but chances are you can drop the imports that just have () instead of a list of things coming from that module
21:09:48 <blaenk> beautiful thanks
21:09:59 <blaenk> needed the module directive at the top, which I didn't have haha
21:27:01 <carter> lispy damn you :P
21:27:28 <lispy> carter: :)
21:27:38 <lispy> carter: I've stopped using that word as a result
21:27:44 <carter> lispy i'm adding moving fail into monad plus to the proposal
21:27:46 <carter> :)
21:27:59 <lispy> even though the modern meaning really cares none of that baggage
21:28:13 <lispy> oh, removing fail is cool
21:28:29 <lispy> Improving monad/functor/applicative is something I'm kind of interested in.
21:28:33 <shachaf> fail should go into MonadZero, not MonadPlus
21:28:39 <lispy> Putting more stuff in the prelude is not interesting to me
21:28:40 <shachaf> If it exists at all.
21:28:41 <shachaf> The way it was in Haskell 1.4
21:28:46 <lispy> We have a module system
21:28:53 <startling> :t fail
21:28:54 <lambdabot> Monad m => String -> m a
21:28:55 <lispy> shachaf: yes, thanks for catching that
21:29:02 <startling> with default fail = const mzero ?
21:29:11 <lispy> shachaf: whichever place...
21:29:14 <carter> shachaf ok, MonadZero makes more sense?
21:29:23 <shachaf> MonadZero should be its own thing, yes.
21:29:23 <Cale> Or perhaps there ought to be a MonadFail for it
21:29:32 <carter> Cale what would have instances then?
21:29:38 <Cale> (in addition to MonadZero and MonadPlus)
21:29:46 <startling> > fail "goodbye" :: Maybe String
21:29:47 <lambdabot>   Nothing
21:29:48 <shachaf> Cale is mostly making a sort of pun, I think.
21:29:52 <shachaf> Or maybe not.
21:29:56 <Cale> No, I'm serious
21:29:58 <carter> what monads have fail instances
21:30:09 <startling> carter: all of them!
21:30:14 <carter> that people actually define
21:30:20 <carter> or use
21:30:22 * startling fries up some Kale
21:30:24 <shachaf> I hope you're not going to make one big megaproposal for "what to change".
21:30:25 <lispy> Cale: which, if any, monad classes will have MonadFail as a constraint?
21:31:02 <startling> > fail "goodbye" :: Reader String String
21:31:04 <lambdabot>   No instance for (GHC.Show.Show
21:31:04 <lambdabot>                     (Control.Monad.Trans.Rea...
21:31:23 <Cale> lispy: Well, the ones which would have MonadZero instances for the most part -- it should probably be a subclass of MonadZero for that reason.
21:31:33 <startling> > runReader (fail "goodbye") :: String
21:31:35 <lambdabot>   Couldn't match expected type `GHC.Base.String'
21:31:36 <lambdabot>              with actual typ...
21:31:44 <carter> Cale could you write up an email to for that for libraries
21:31:51 <startling> man, I've spent too much time away from haskell.
21:31:59 <carter> so its seperate from the other stuff?
21:32:09 <Cale> carter: Uh, what?
21:32:34 <lispy> Cale: he wants you to propose MonadFail to whatever library it would belong in
21:32:43 <carter> to the haskell-libraries list
21:32:43 * lispy has no idea which one that would be...base?
21:33:07 <lispy> MonadPartial?
21:33:08 <carter> lispy since its called on monad pattern match failure, probably
21:33:12 <Cale> base, I would expect, because it's stuff which directly affects the translation of do-notation
21:33:44 <lispy> MonadNonExhaustedPatternMatch
21:33:45 <carter> yeah, and if we get the other stuff through, getting that in as a small related proposal would be easy
21:33:52 <lispy> +BuilderFactor
21:33:55 <Cale> What's the other stuff?
21:34:04 <Cale> I haven't really been watching that list closely in a long time
21:34:07 <carter> Cale theres two things
21:34:09 <Cale> Beacuse nothing ever happens
21:34:32 <carter> 1) replace the list only versions of all the foldable / traversable stuff with the generic type classe versions
21:34:41 <carter> 2) fix up the functor / applicative / monad relations
21:34:44 <Cale> Not sure if I agree with 1
21:34:47 <lispy> carter: I don't want to tell you how to do things, but I suspect that if you push too hard for changes that don't have a clear need you will not make a lot of friends.
21:34:57 <lispy> carter: want != need, and all that
21:35:03 <Cale> I don't entirely believe in Foldable
21:35:07 <carter> fair enough
21:35:12 <carter> Cale how so?
21:35:29 * shachaf guesses that Cale will say that it picks an arbitrary ordering.
21:35:44 <carter> the functor / applicative / monad one is reasonable though
21:35:52 <carter> because theres no work around for that
21:35:58 <carter> ok, i'll only restart that one
21:36:31 <Cale> Monad being a subclass of Applicative, and moving them all up into the Prelude would make sense.
21:36:32 <lispy> you can simulate it now with flexible and overlapping instances
21:36:42 <carter> lispy how?
21:36:56 <lispy> I don't have the code handy but we prototyped it today at work
21:37:08 <shachaf> I used to believe in Foldable less than I do now.
21:37:10 <Cale> carter: One thing I *would* support is generalising map to Functor
21:37:10 <startling> why does do notation need to use fail? it'd be much nicer imo if it just error'd
21:37:15 <lispy> We used flexible instances so we could write instance Monad m => Functor m where ...
21:37:21 <shachaf> startling: No, that would be awful.
21:37:26 <carter> Cale i'm happy to push for that
21:37:29 <carter> ok
21:37:50 <startling> shachaf: do people actually use the implicit bad-pattern-match-uses-fail thing? ew.
21:37:56 <shachaf> @src catMaybes
21:37:57 <lambdabot> catMaybes ls = [x | Just x <- ls]
21:38:05 <carter> lispy doesn't that mess with usability for mortals?
21:38:12 <shachaf> Traversable made me believe in Foldable.
21:38:16 <lispy> carter: the instance was something like fmap f m = return . f =<< m
21:38:37 <lispy> carter: and then to make a more specific Functor instance you need overlapping instances
21:38:41 <Cale> carter: and I don't altogether hate Foldable, it's hard to put my finger on exactly why I'm a bit uneasy about, say, putting it in the Prelude.
21:38:48 <lispy> carter: yes, it's not great. I don't encourageit.
21:38:56 <Cale> I also feel like lists are a bit more important than many people give them credit for.
21:39:06 <carter> they do have the easiest fusion
21:39:29 <shachaf> Cale: Yes, but mapM should be traverse in the same way map should be fmap.
21:39:29 <carter> well, i'll push for the one i can justify on technical grounds
21:39:38 <startling> I want "fold" in the Prelude at least
21:39:58 <shachaf> The only reason to care about what's in the Prelude is when it conflicts with something else.
21:40:02 <startling> but then you'd need Monoid, too (which should be in it, too)
21:40:05 <shachaf> Otherwise y'all should stop caring about one extra import.
21:40:09 <carter> shachaf Cale : cant yah always newtype to get a  different instance of foldable
21:40:11 <shachaf> It's not worth fighting about.
21:40:19 <shachaf> What?
21:40:27 <carter> for the different order
21:40:41 <carter> or am i not understanding
21:41:13 <Cale> I think Listable would be a better name for the class, and just define   class Listable t where toList :: t a -> [a]
21:41:37 <shachaf> Cale: No, that's not good. It should keep the monoid structure.
21:41:49 <shachaf> Yes, lists are free monoids, but that's not how things behave in Haskell.
21:41:50 <Cale> shachaf: ?
21:42:06 <Cale> Which instances are you thinking of?
21:42:39 <shachaf> For example if you have a Foldable instance for a balanced tree, you can fold with Last and get the rightmost leaf in logarithmic time.
21:42:50 <shachaf> Even if the tree is infinite in the middle, for that matter.
21:42:54 <shachaf> Lists don't give you that.
21:43:13 <Cale> Well, that's true.
21:43:25 <shachaf> Also: Foldable should reflect Traversable.
21:43:34 <Cale> Do people use those instances?
21:43:38 <shachaf> It's just a write-only restriction of Traversable.
21:43:40 <shachaf> Yes.
21:43:53 <shachaf> s/write/read/ depending on your perspective. :-)
21:44:29 <carter> ok
21:45:04 <shachaf> I didn't really believe in Foldable until I started believing in Traversable. Now I believe in Foldable more.
21:45:21 <bobajett> how can I make pairs out of a list? xs = [1,2,3,4] should give me [(1,2), (3,4)] ? I tried:
21:45:25 <bobajett> pairs [] = []
21:45:27 <bobajett> pairs (x:xs) = (x, head xs) : pair xs
21:45:29 <shachaf> It still doesn't really have any laws (it's not even guaranteed to be covariant). It's not great. But it's pretty good.
21:45:53 <blackdog> bobajett: you probably want to match the first two elements of the list
21:45:56 <bobajett> but that fails and doesn't account for lists of odd size
21:45:57 <liyang> kfish: where'd you get that survey from?
21:45:58 <shachaf> bobajett: Don't use head. Pattern-match.
21:46:28 <carter> so since it looks like other people may or may not be playing infantry for the foldable traversable thing, i'll retry the other bits
21:46:31 <blackdog> and then decide what to do with odd-sized lists
21:46:36 <carter> http://www.haskell.org/haskellwiki/index.php?title=Functor-Applicative-Monad_Proposal&oldid=38102 seems to crystalize it welll
21:47:14 <bobajett> blackdog: shachaf: damn that was easy. sheesh.
21:47:32 <bobajett> ok now onto odd sized lists
21:47:39 <carter> blackdog hello
21:47:46 <shachaf> By pattern-matching, rather than using an unsafe function like head, GHC will tell you that you're missing a case.
21:47:51 <shachaf> More proposals: Semigroup! Apply!
21:48:22 <carter> shachaf where would we add semigroup?
21:48:28 <blackdog> carter: g'day mate:)
21:48:30 <shachaf> "where"?
21:48:38 <shachaf> G'dackdog.
21:48:51 <carter> shachaf its late, humor me
21:48:57 <shachaf> I don't understand the question.
21:48:59 <blackdog> funny combination of newb-vs-abstruse haskell in here today :)
21:49:05 <shachaf> In the package base, in the module Data.Semigroup, probably?
21:49:10 <carter> ah
21:49:10 <shachaf> As a superclass of Monoid?
21:49:13 <carter> ok
21:49:15 <carter> you propose that
21:49:22 <carter> i'll sit on the people who say no
21:49:24 <kfish> liyang: what do you mean?
21:49:25 <shachaf> No, I don't think these proposals should be so chaotic.
21:49:35 <carter> oh
21:49:39 <carter> what do you suggest then?
21:49:46 <liyang> kfish: did you make it?
21:49:50 <carter> should i not push on the applicative thing?
21:50:00 <kfish> liyang: yes
21:50:08 <liyang> :yes:
21:50:22 <kfish> john and i were discussing what pissed us off about the current useless discussions
21:50:27 <shachaf> It should be proposed at one point. I think some thought should be put into it before proposing.
21:50:32 <shachaf> The current discussions are indeed useless.
21:51:00 <carter> shachaf I suppose you're right
21:51:36 <shachaf> @ty getLast . foldMap (Just . Last)
21:51:38 <lambdabot>     Couldn't match expected type `Last a0' with actual type `Maybe b0'
21:51:38 <lambdabot>     Expected type: b0 -> Last a0
21:51:38 <lambdabot>       Actual type: b0 -> Maybe b0
21:51:43 <shachaf> @ty getLast . foldMap (Last . Just)
21:51:44 <lambdabot> Foldable t => t a -> Maybe a
21:52:14 <carter> shachaf ok, i'll add it to my calendar 2-3 months from now
21:52:51 <shachaf> I'm not sure that's the right thing to do either. :-)
21:53:26 <shachaf> But at least there's no enormous hurry, especially in the current libraries@ climate. I agree with the proposal but it should be made once and argued reasonably.
21:53:29 <Cale> carter: The annoying thing about improving all this stuff is that while many things (like the Foldable thing) would probably be improvements, the process to get anything changed is such a big deal that nobody wants to see a change happen that they're not 100% sure is the right one.
21:54:17 * shachaf contemplates @remembering edwardk's libraries quotes from -lens.
21:54:29 <carter> Cale shachaf  if i'm still doing wellposed and have actual customers, and i find i really want these changes, i'll be willing to tolerate the flack needed to make it happen
21:54:48 <carter> shachaf which quotes?
21:55:34 <shachaf> I'm not saying not to make it happen. It should happen.
21:56:30 <kfish> we should aim for a target like haskel2015, in which functor/applictaive/monad are consistent and prelude doesn't have a random monomorphic subset of functions
21:56:34 <kfish> oh and semigroup
21:56:50 <bobajett> Cale: curious why is the process such a big deal? takes too long to go through the process or requires lots of justifications to have something changed?
21:57:07 <carter> bobajett politics
21:57:10 <carter> committees
21:57:32 <carter> certain crazy peple who have crazy ass opininions and don't maintain libs that anyone uses dont like change
21:57:34 <carter> or something
21:57:38 <kfish> carter: inactive committees?
21:58:40 <bobajett> heh. gotcha. I wonder if any other language community has some solution that solves/bypasses this problem that we could adopt?
21:59:13 <bobajett> well let me extricate myself out of "we", I just figured out how to write a "pair" function :-)
21:59:13 <carter> bobajett its moreso about one of the people who wants the change being willing to deal with the flak
21:59:45 <carter> bobajett i may well be wearing a metaphorical flak jacket soon if i find i want to make some of this happen
21:59:46 <Cale> carter: The fact that Henning Thielemann is active on Libraries scares me in and of itself :)
21:59:52 <carter> Cale OMG
21:59:56 <carter> DONT GET ME STARTED
21:59:59 <Cale> So perhaps it's a good thing that there's a bit of bureaucracy :)
22:00:09 <shachaf> I,I Prelude.T
22:00:16 <Cale> shachaf: lol
22:00:18 <carter> i've seen his requests for a lib i'm now helping maintain
22:00:23 <carter> I SHARTED
22:00:26 <carter> in horror
22:00:31 <Cale> Don't let him touch anything.
22:00:38 <carter> before the other maintainers explalined "ignore him"
22:00:40 <carter> i will never
22:00:42 <carter> everrr
22:00:46 <carter> let him ever
22:00:48 <carter> ever
22:00:59 <Cale> I've actually seriously considered writing a tool to help undo the specific sort of vandalism he carries out.
22:01:09 <carter> Cale which libs has he fucked?
22:01:17 <Cale> Haskore, for one
22:02:01 * shachaf thinks this isn't quite the right thing to have in this channel, even if you strongly disagree with someone.
22:02:22 <carter> shachaf  its badddd.
22:02:27 <carter> like stuff that would break libs bad
22:03:03 <pqmodn> i've never heard of him, but googling his name brings up IRC logs joking about a "Henningskell translator" :)
22:03:07 <Cale> Oh, right, and numeric-prelude
22:03:16 <Cale> http://hackage.haskell.org/package/numeric-prelude
22:03:18 <carter> he didn't want template haskell in the setup.hs for llvm because it would break hugs
22:03:27 <Cale> It's *really* sad that this is Henninged.
22:04:01 <carter> not adding the template haskell would mean llvm bindings as writ would only work on pre cabal 1.17 or only >= 1.17
22:04:09 <Cale> http://hackage.haskell.org/packages/archive/numeric-prelude/0.4.0.1/doc/html/Algebra-IntegralDomain.html
22:04:13 <Cale> class C a => C a where
22:04:29 <shachaf> That's a Haddock issue.
22:04:37 <Cale> You could say that
22:04:42 <carter> he wanted no TH and a different version pushed to hackage with support for the two cabal version ranges
22:04:47 <Cale> But it's also a usability issue.
22:04:59 <carter> yes
22:05:26 <Cale> In fact, it's almost a good thing that Haddock has this bug
22:05:46 <pqmodn> looks like there are many classes named "C" in there
22:05:48 <carter> yeah, type classes should have words in them
22:05:52 <bobajett> I present my (noob) pairs function!
22:05:53 <bobajett> pairs :: [a] -> [(a, Maybe a)]
22:05:54 <bobajett> pairs [] = []
22:05:54 <bobajett> pairs (x:[]) = [ (x, Nothing) ]
22:05:54 <Cale> because it means that people won't generally put up with this kind of insane naming scheme which forces everyone to import everything qualified
22:05:57 <bobajett> pairs (x:y:xs) = (x, y) : pair xs
22:06:01 <Cale> pqmodn: yes
22:06:01 <bobajett>  
22:06:21 <copumpkin> bobajett: that doesn't typecheck does it?
22:06:36 <Cale> pqmodn: It seems the first thing that Henning Thielemann does when he takes over maintainership on a package is to rename every type to T and rename every class to C.
22:06:53 <carter> Cale theres more than one lib that hes done this to?
22:06:54 <johnw> carter: that google docs poll is pretty funny :)
22:06:58 <Cale> carter: yes
22:06:59 <bobajett> copumpkin: it does
22:07:17 <bobajett> *Main> :t pairs
22:07:18 <bobajett> pairs :: [a] -> [(a, Maybe a)]
22:07:22 <Cale> http://hackage.haskell.org/packages/archive/haskore/0.2.0.3/doc/html/Haskore-Composition-Chord.html
22:07:29 <carter> ffuckkkk
22:07:32 <Cale> Okay, it seems not *every* type
22:07:36 <lispy> even if you fixed haddock I still wouldn't like Henning code
22:07:36 <Cale> But nearly
22:07:43 <copumpkin> bobajett: that makes no sense to me :)
22:07:47 <Cale> Haskore used to be beautiful
22:07:51 <copumpkin> it should be (x, Just y)
22:08:08 <bobajett> copumpkin: you're absolutely write, typo on my part
22:08:12 <Cale> In fact, it was incidentally what brought me to Haskell in the first place.
22:08:16 <copumpkin> oh okay
22:08:41 <Cale> (I mentioned to a friend of a friend that I was interested in algebraic formalisations of music theory, and he pointed me at Haskore.
22:08:42 <Cale> )
22:10:12 <pqmodn> oh, did Haskore start from Haskell School of Expression?
22:10:37 <Cale> pqmodn: It was a paper by Hudak originally.
22:11:08 <pqmodn> ah, seemed familiar
22:12:13 <carter> yup
22:13:37 <Cale> http://haskell.cs.yale.edu/wp-content/uploads/2011/02/HaskoreMusicTutorial-Springer.pdf
22:13:43 <pqmodn> thanks :)
22:13:52 <Cale> This is not quite the original paper, but I can't find that online
22:14:14 <Cale> But it's close enough and documents the content of the library fairly well as it was before...
22:14:48 <bobajett> how can I take the list xs = [1,7,3] and make pairs so that each element is paired with the other elements in the list but not itself? [(1,7),(1,3), (7,1),(7,3), (3,1),(3,7)] -- [(1,1), (3,3), (7,7) are not elements of the resulting list?]
22:14:49 <Cale> http://haskell.cs.yale.edu/?post_type=publication&p=127 -- apparently this one is in JFP
22:15:35 <Cale> bobajett: I frequently like to define the following operation (another thing which I've proposed to libraries@ and gotten no traction:
22:15:37 <pqmodn> this is tangential, but how do most people obtain access to JFP? from their university?
22:15:57 <Cale> select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
22:16:09 <cmears> bobajett, you could do it the lazy way and stick "filter (uncurry (/=))" on the front
22:16:38 <bobajett> cmears: would that work for the list [1,7,3,3] ?
22:17:01 <cmears> not if you still want (3,3), with the "first 3" and "second 3"
22:17:07 <liyang> I actually don't mind the importing everything qualified approach. It's just annoying that Haddock currently strips off the qualifier parts.
22:17:11 <Cale> bobajett: In terms of that, you could write  offDiagonal xs = [(x,y) | (x,ys) <- select xs, y <- ys]
22:17:43 <bobajett> Cale: wow, cool, I'll try that.
22:17:52 <liyang> So instead of "import Data.Map (Map); import qualified Data.Map as Map" I'd just write "import qualified Data.Map as Map".
22:18:40 <Cale> liyang: For whatever reason, I generally can't bring myself to write qualified names in types
22:19:06 * lispy is with Cale
22:19:07 <Cale> Sometimes I find myself really missing being able to just write  import FiniteMap
22:19:13 <liyang> IIRC lots of O'Caml code uses that scheme; and I've partially used it in our production code.
22:19:56 <liyang> So instead of naming type ModuleType I'd name it Type and import said module qualified. Within the module it's just Type; outside I write Module.Type.
22:21:07 <Cale> liyang: Yeah, I've heard that's where it comes from. I really dislike it.
22:21:28 <dolio> Also Haskell doesn't have various features that OCaml has that might make it less horrible.
22:21:37 <dolio> Like locally opening modules.
22:21:38 <Cale> liyang: It might make more sense in O'Caml though because modules are, if not first class, at least higher class than they are in Haskell.
22:21:51 <Cale> right
22:21:56 <carter> lets get that merged into ghc this summer
22:22:22 <dolio> But naming it "Type" is still bad in that respect.
22:22:41 <dolio> Because then you locally open, and you're talking about 'Type -> Type'.
22:23:23 <dolio> Or, you can't locally open two modules at the same time.
22:24:32 <Cale> bobajett: A related one is  separate [] = []; separate (x:xs) = ([],x,xs) : [(x:ys,y,zs) | (ys,y,zs) <- separate xs]
22:25:05 <Cale> Or I guess I've sometimes called that pick.
22:25:28 <Cale> (It can be hard to come up with not-entirely-generic names for things like this)
22:26:15 <Cale> and Conor McBride has some lovely generalisations
22:26:44 <Cale> > let separate [] = []; separate (x:xs) = ([],x,xs) : [(x:ys,y,zs) | (ys,y,zs) <- separate xs] in separate [1..4]
22:26:46 <lambdabot>   [([],1,[2,3,4]),([1],2,[3,4]),([1,2],3,[4]),([1,2,3],4,[])]
22:27:14 <bobajett> Cale let me ask you this. :-) how long does it take to go from noob to being able to write real world haskell? Im 50% of the way int LYAH and RWH, but makes my brain hurt to write simple functions like this.
22:27:34 <Cale> bobajett: For me, it was about a year.
22:27:42 <blaenk> for me 20
22:27:54 <bobajett> blaenk: lol!
22:28:04 <blaenk> can't get jobs where they ask for 25 years experience with haskell :(
22:28:12 <Cale> After about 2 months, I started to get the sense that I could actually do useful things.
22:28:25 <Cale> and it was about a year before I was really comfortable
22:28:52 <Cale> I've been programming in Haskell since around 2001-2002 or so.
22:29:07 <amiller> quick linear logic quetion
22:29:13 <amiller> when i see something of the form !A -o B
22:29:18 <bobajett> I go between: fuck this is awesome (when a function works and somehow almost always looks very elegant) to fuck I can't even figure out how to write this basic thing.
22:29:21 <amiller> should i read that as !(A -o B) or (!A) -o B
22:29:30 <amiller> (sorry that's not really haskell but i can't think of where else to ask)
22:29:38 <blaenk> bobajett: that's just a matter of practice I think, of getting you used to thinking in the way that haskell requires
22:29:39 <Ndit> Cale will you ever be as serious about another language?
22:29:52 <Cale> amiller: I would read it as the latter
22:29:59 <Cale> Ndit: Probably.
22:30:12 <Cale> Ndit: Probably a dependently typed language.
22:30:13 <Ndit> one we dont know exists yet, I suppose
22:30:24 <bobajett> agda?
22:30:33 <Cale> Agda is cool, I just hate unicode syntax.
22:30:46 <adnap> w00t! http://hpaste.org/88334
22:30:50 <Ndit> yeah that won't work
22:31:01 <Cale> also, the strict-by-default thing is questionable to me
22:31:16 <dolio> What strict-by-default thing?
22:31:17 <blaenk> for me I don't mind laziness I just wish it was easier to understand it
22:31:28 <liyang> I love Unicode in Agda. It's so easy!
22:31:34 <carter> idris is intriguing to me
22:31:38 <blaenk> like whnf and nf and all these things I get the impression I have to learn the g-machine or w/e its called and graph reduction to understand it
22:31:39 <Ndit> liyang how do you remember all the unicode numbers
22:31:51 <bobajett> I suppose I'll follow Norvig's Teach Yourself Programming (Haskell) in Ten Years. http://norvig.com/21-days.html
22:31:54 <liyang> Ndit: I use the LaTeX-like input method.
22:32:00 <blaenk> in vim theres plugins where you type it in ascii and it replaces it with unicode
22:32:02 <carter> blaenk i try to write really strict code i smy trick
22:32:06 <adnap> Is Ocaml like Haskell?
22:32:06 <blaenk> so like -> gets replaced with the unicode arrow
22:32:19 <liyang> Ndit: so you're stuck with the Emacs IDE unfortunately.
22:32:21 <carter> adnap if you don't want to user all your cores , yes
22:32:36 <blaenk> carter: smy?
22:32:39 <adnap> I learned Haskell early, and I don't see the point of learning another language like it
22:32:40 <blaenk> ohh
22:32:42 <blaenk> got it
22:32:44 <Cale> dolio: Maybe I'm wrong about this, but it seems that most dependently typed systems seem to think that because you can prove everything terminates, it's a good idea to evaluate everything innermost-first?
22:32:48 <carter> yes, late night spelling typoes
22:33:03 <adnap> I am interested in learning a language much better than Haskell, like perhaps Agda, but it looks like Agda is immature
22:33:03 <blaenk> what's haskell hive mind's opinion on erlang
22:33:25 <adnap> I read what little bit of the Learn you an Agda there is
22:33:26 <dolio> Well, agda's open evaluation doesn't do that, at least.
22:33:28 <Cale> blaenk: It has nice features which we are poaching and improving on :)
22:33:34 <liyang> Ndit: and placing the cursor over a character and pressing "C-u C-x =" gives you a mini buffer that tells you what the LaTeXy name is.
22:33:35 <dolio> I don't know what any of the compiler backends do.
22:33:41 <blaenk> Cale: that's the impression I get
22:33:44 <dolio> Presumably the one that compiles to Haskell is going to be lazy.
22:33:59 <Cale> dolio: hmm!
22:34:01 <adnap> Cale: Do you work on GHC?
22:34:06 <Cale> adnap: No.
22:34:13 <carter> adnap i'm trying to start
22:34:18 <carter> (working on ghc)
22:34:24 <Cale> (though I'll open up its source code and read stuff from time to time)
22:34:44 <carter> the ghc source code is pretty readable
22:34:46 <carter> HUGE project
22:34:47 * liyang wants to steal O'Caml's modules. :<
22:34:47 <dolio> With epic it's probably up for grabs, and I don't know what they picked.
22:34:48 <carter> but readable
22:34:54 <adnap> carter: Are you the person who was talking about a math lib earlier?
22:35:11 <carter> adnap which haskeller out there doesn't talk about math?  :p
22:35:15 <liyang> Or rather, steal Agda's records and modules.
22:35:16 <carter> probably me
22:35:18 <Cale> adnap: One thing which recently happened to me is that I discovered that I already know how to program in Coq.
22:35:26 <carter> Cale cool
22:35:44 <blaenk> Cale: hows that
22:35:51 <blaenk> (don't know anything about that language)
22:36:07 <adnap> Coq is dependently typed, right?
22:36:18 <carter> adnap yes
22:36:19 <Cale> blaenk: It's similar enough to Haskell that I can just program in it by hammering on my keyboard until the proof assistant accepts things.
22:36:26 <blaenk> haha
22:36:31 <bobajett> lol
22:36:31 <adnap> How do you pronounce "Coq"?
22:36:40 <dolio> Like a French person.
22:36:45 <carter> rooster
22:36:46 <blaenk> sounds like the rite of passage
22:36:51 <adnap> I don't know any French people
22:37:00 <blaenk> coe-q
22:37:02 <blaenk> coke
22:37:04 <blaenk> ?
22:37:07 <adnap> I imagine "cock" and "coke"
22:37:11 <arkeet> adnap: I think idris is supposed to be more geared toward actually being useful.
22:37:15 <carter> blaenk i may have said "Coq is hard" it at a shitty lightning talk i gave a week ago
22:37:18 <arkeet> but it's quite young
22:37:29 <blaenk> carter: haha
22:37:30 <bobajett> carter: lol!
22:37:34 <carter> arkeet indeed, promising though
22:37:34 <sipa> 'cock' certainly comes closest to the french pronounciation
22:37:34 <luite> carter: you were working on the compilation pipeline, right? do you know if there's an easy way to determine whether a module needs to be recompiled if you have a module graph?
22:37:50 <arkeet> I don't know anything about these dependently typed things.
22:38:06 <carter> luite oh, you mean how ghc's c->s->o thing is wrong?
22:38:06 <liyang> Cale: PROGRAM?
22:38:12 <Cale> http://hpaste.org/88335
22:38:15 <adnap> Haskell is as far as I am going on the idealistic axis because it is pretty useful
22:38:17 <Cale> I recently wrote that
22:38:20 <adnap> .. for now
22:38:27 <arkeet> liyang: haha
22:38:28 <Cale> It's pretty inexpertly written, but it works!
22:38:30 <carter> adnap i'm trying to have a biz around it
22:38:36 <dolio> It is possible to program in Coq. Just not very nice.
22:38:52 <dolio> Better than it used to be.
22:38:52 <liyang> Cale: PROGRAM is fairly recent; its tactics language is incomprenehsible to me.
22:38:55 <adnap> I don't like capitalism
22:39:01 <Cale> liyang: oh, what?
22:39:15 <Cale> liyang: Oh, yeah, I don't know much of anything about PROGRAM.
22:39:43 <sipa> adnap: i'd argue that capitalism is discrimination based on capitalization; sounds exactly what you're doing :p
22:39:56 <adnap> sipa: I don't understand you
22:39:57 <liyang> Cale: I thought PROGRAM was the extension that allowed you to write proofs (and programs) the way you would in Agda. Before that you had to learn its arcane tactics language.
22:40:07 <Cale> liyang: Oh, no, you can do that anyway
22:40:29 <Cale> PROGRAM is this funny thing which lets you defer certain proof obligations about your programs until later
22:40:39 <dolio> Doesn't it do other stuff?
22:40:39 <Cale> and I don't know much more about it than that
22:40:44 <sipa> adnap: racism is discrimination based on race, sexism based on gender... capitalism would be discriminations based on capitalization? :p
22:40:46 <liyang> I'm misremembering things again.
22:40:49 <dolio> Like, Coq doesn't have full dependent pattern matching.
22:40:57 <adnap> sipa: And how am I doing that?
22:41:02 <dolio> Because it lacks some axioms that are required for it.
22:41:06 <adnap> sipa: By typing English?
22:41:23 <dolio> So PROGRAM adds it back in with an obligation or something, I thought.
22:41:24 <carter> dolio which axioms?
22:41:35 <sipa> adnap: i assumed you were trying to say that you didn't like 'PROGRAM' because of its capitals
22:41:35 <dolio> carter: Axiom K.
22:41:41 <Cale> Yeah, I don't really know what I'm doing when I program in Coq, or even what full dependent pattern matching is. I just type stuff and it magically gets accepted.
22:41:48 <luite> carter: no because i only have a module graph in ghcjs, compilation needs some specific settings (targetPlatform JavaScript etc, NCG disabled), so it compiles the modules one by one, but it should be able to skip the unchanged ones
22:42:02 <carter> luite i'm not familiar with that part
22:42:13 <adnap> sipa: No, I was using the obvious definition of capitalism
22:42:15 <carter> nudge me during afternooon time one of the next few days
22:42:22 <carter> luite and i'm happy to dig around to figure that out
22:42:29 <carter> its kinda late for me
22:42:31 <Cale> It's very much like programming directly in System F for me.
22:42:37 <luite> carter: k, i'll dig some more later then, it's not terribly important
22:42:44 <carter> luite but if you want help
22:42:45 <Cale> Though now I know a little more about implicit parameters, so it's a bit nicer than that :)
22:42:54 <carter> you know who to hassle
22:42:55 <luite> carter: well if you already knew how to do it
22:42:59 <carter> luite no clue
22:43:06 <carter> i was looking at the compilation driver
22:43:09 <luite> i'm busy implementing STM first :)
22:43:18 <carter> and convicing Igloo that i'm making sense at all :)
22:43:21 <adnap> I never learned lambda calculus. Every example I see of it looks like ghibberish
22:43:48 <luite> carter: it's later for me btw ;)
22:43:55 <carter> luite well
22:43:59 <Cale> adnap: You learned Haskell, so the simply typed lambda calculus is just a subset of that.
22:44:00 <liyang> I taught I herd sum1 mension System F: http://www.youtube.com/results?search_query=system+f
22:44:12 <carter> luite we can laugh at everyone else
22:44:21 <carter> because we're also going to be gsoc mentoring and stuff
22:44:28 <lispy> @localtime luite
22:44:29 <lambdabot> Local time for luite is Wed May 22 07:44:20 2013
22:44:43 <carter> plus rolling out tools people are bothering us nicely about
22:44:47 <adnap> Cale: I read that before. Then I thought, it must just be the syntax, but what's the point of learning it if I essentially understand it by understanding Haskell?
22:44:52 <carter> though i think more people will want yours than min
22:44:54 <carter> e
22:45:02 <carter> because of the pretty web things
22:45:06 <luite> carter: hm, today accepted projects are announced, right?
22:45:12 <carter> luite shit
22:45:15 <Cale> adnap: Well, learning ways to encode data types as lambdas is nice.
22:45:20 <Ndit> carter: did I bother nicely?
22:45:21 <carter> i need tostart acting like a mentor
22:45:25 <carter> Ndit eh?
22:45:28 <carter> i don't understand
22:45:35 <Cale> adnap: If you already understand Haskell, that's pretty much the whole thing...
22:45:35 <carter> i'm teasing
22:45:44 * Ndit tries to bother nicely about 1 thing
22:45:59 <carter> Ndit i was saying ghcjs >>>> magically better math libs
22:46:01 <carter> ish
22:46:03 <Cale> adnap: Well, apart from some funny stuff which goes on in untyped lambda calculi you might care to understand at some point, like the definition of Y
22:46:08 <carter> in terms of scope of people who can understand it
22:46:19 <carter> or be a first order enjoyer of it
22:46:38 <adnap> Cale: Do you have a suggetion for how to learn it?
22:46:44 <Cale> adnap: If we have a value which belongs to an algebraic data type with some constructors, we can encode it as a lambda which takes the constructors of that data type as parameters.
22:46:49 <carter> more people will appreciate magically better webapps in front of them than better numerical computing tools
22:46:51 <carter> and thats ok :)
22:46:56 <Cale> For example:
22:46:58 <carter> i can still hopefully make a fun wee biz out o fit
22:47:02 <Cale> data Bool = False | True
22:47:23 <Cale> So, we can represent boolean values by lambdas which take false and true as parameters, and produce one or the other.
22:47:25 <luite> carter: hm, dunno, i feel ghcjs is kind of a pointless excercise, reimplementing lots of stuff in a worse way than already exists... but i do really want to use the result...
22:47:32 <Cale> (\false true -> false) and (\false true -> true)
22:47:35 <carter> luite i want to
22:47:41 <Cale> Similarly,
22:47:48 <carter> especially after writing my first js code last fri-sat
22:47:55 <Cale> data List a = Nil | Cons a (List a)
22:48:03 <carter> js is WEIRD
22:48:10 <Cale> So we can represent a list such as   Cons 1 (Cons 2 (Cons 3 Nil))  as the lambda:
22:48:15 <carter> i'd be open to writing browser based apps then
22:48:21 <Cale> (\nil cons -> cons 1 (cons 2 (cons 3 nil)))
22:48:34 <Cale> Or for that matter, numbers:
22:48:36 <adnap> Why aren't you capitalizing false, true, nil, and cons?
22:48:41 <Cale> data Nat = Zero | Succ Nat
22:48:48 <carter> luite think of the impact on the would i could have writing a ghcjs based thick client p2p socialnetwork for cat owners
22:48:49 <arkeet> adnap: they're just arguments
22:48:50 <Cale> So we can represent 5 as:
22:48:55 <liyang> adnap: those are not the False and True you are looking for.
22:49:01 <arkeet> Bool  ~  forall r. r -> r -> r
22:49:05 * adnap sighs
22:49:06 <carter> itd make some onion article fact instead of fiction at least
22:49:07 <pqmodn> adnap: only Haskell cares about capitalization, plain lambda calculus makes no distinction
22:49:09 <Cale> (\zero succ -> succ (succ (succ (succ (succ zero)))))
22:49:18 <liyang> You represent a data type as its destructor function.
22:49:18 <Cale> adnap: because they're variables
22:49:22 <arkeet> [a]  ~  forall r. r -> (a -> r -> r) -> r
22:49:37 <carter> point being
22:49:37 <adnap> You went to fast for me
22:49:44 <carter> yes, ghcjs may be hacky now
22:49:49 <carter> but its also the first serious new backend
22:49:54 <carter> and we can tease out those bits
22:49:55 <adnap> Scrolling up
22:49:58 <carter> and make it more principled
22:50:11 <carter> and hopefully even figure out how to make new backends a cabalizable affair
22:50:16 <Cale> adnap: The idea is that we can obliterate all the data constructors, replacing the values of each type with functions which take the constructors of that type as parameters
22:50:17 <carter> that would be magic
22:50:18 <pqmodn> adnap: this is very gentle http://www.amazon.com/Introduction-Functional-Programming-Calculus-Mathematics/dp/0486478831
22:50:22 <tikhonjelvis> adnap: try thinking about how you would store data if you *only* had lambdas and nothing else
22:50:39 <Cale> adnap: which basically means that we end up representing a list by the foldr over that list
22:50:43 <carter> i should crash
22:50:45 <carter> night all
22:51:08 <arkeet> Nat  ~  forall r. r -> (r -> r) -> r
22:51:15 <arkeet> or (r -> r) -> (r -> r)
22:51:27 <Cale> adnap: You can think of a lambda in general as something which allows you to assume the existence of something.
22:51:28 <arkeet> the latter is Church encoding
22:51:30 <liyang> adnap: you can represent a "Bool" as functions of the type "a -> a -> a"; a "Maybe a" as "r -> (a -> r) -> r", and Nats as show above.
22:51:32 <Cale> adnap: (locally)
22:51:42 <luite> carter: hm, well, Cabal itself isn't terribly modular, ghcjs adds its own compiler flavor. there's a haskell-packages project in the haskell-suite that aims to make a pluggable compiler thing for Cabal, but it's a bit more limited in functionality
22:51:52 <Cale> adnap: and so we assume the existence of these constructors  nil and cons, and then build the list we wanted to build with them.
22:52:02 <liyang> In the Maybe case, you already have Data.Maybe.maybe which turns a Maybe to its destructor.
22:52:06 <luite> oh he gone
22:52:23 <adnap> Are "cons" and "nil" functions in "(\nil cons -> cons 1 (cons 2 (cons 3 nil)))"?
22:52:36 <arkeet> cons is, but nil may not be
22:52:36 <Cale> cons definitely is a function
22:52:41 <Cale> nil is less certain to be
22:52:47 <adnap> What is the definition of "cons"?
22:52:52 <Cale> It's just a parameter
22:52:56 <Cale> to that lambda
22:53:01 <arkeet> in f x = x + 5, what is the definition of x?
22:53:02 <Cale> It comes into scope right there
22:53:03 <arkeet> ???
22:53:03 <liyang> cons is more of a function than nil. By 1 argument.
22:53:04 <adnap> But it takes two arguments
22:53:04 <arkeet> :p
22:53:12 <liyang> *two arguments.
22:53:18 <Cale> Functions can take other functions as parameters
22:53:31 <adnap> "cons" was the antecedent of "it"
22:53:39 <liyang> Functions *all* *the* *way* down.
22:53:46 <adnap> "cons" takes two arguments
22:53:51 <Cale> In the untyped lambda calculus "everything is a function"
22:53:56 <arkeet> adnap: but cons is a parameter
22:54:05 <adnap> akraut: I know. What's your point?
22:54:11 <mm_freak> > let f (+) = 5 + 5 in f (*)
22:54:13 <lambdabot>   25
22:54:13 <arkeet> it doesn't have a definition.
22:54:18 <Cale> So, when you apply a function to a function, you get another function which you can always continue to apply, and so on.
22:54:51 <arkeet> :t \nil cons -> cons 1 (cons 2 (cons 3 nil))
22:54:52 <lafyn> :t (<|>)
22:54:53 <lambdabot> Num a => t -> (a -> t -> t) -> t
22:54:53 <lambdabot> Alternative f => f a -> f a -> f a
22:54:53 <lafyn> imangine the thing to be the other way than actually be nicer alternative f => echo outputs to a book and then you need slow log only have one with the actual content of articles reminds me
22:54:57 <Cale> But we'll discipline ourselves to locally treat these nil and cons as if they had the types the data constructors have in Haskell when we're writing the body of the lambda.
22:54:58 <adnap> I don't think I can evaulate any of your examples
22:54:58 <lafyn>   looks like 1,000,000 examples on the fault is the scheule in a number up with back state change.
22:55:00 <arkeet> > (\nil cons -> cons 1 (cons 2 (cons 3 nil))) [] (:)
22:55:01 <lambdabot>   [1,2,3]
22:55:05 <arkeet> > (\nil cons -> cons 1 (cons 2 (cons 3 nil))) 0 (+)
22:55:05 <lafyn> > (\nil cons -> cons -> cons 1 (cons 2 (cons 3 nil))) [] (:)
22:55:07 <lambdabot>   6
22:55:07 <lambdabot>   can't find file: L.hs
22:55:11 <Cale> adnap: You can't reduce any of my examples because they're all lambdas
22:55:18 <lispy> lambdabot: try harder
22:55:22 <adnap> And some of them are undefined
22:55:28 <adnap> Like "cons" and "nil"
22:55:35 <pqmodn> > foldr cons nil [1,2,3]
22:55:37 <lambdabot>   Not in scope: `nil'
22:55:44 <mauke> adnap: \ introduces function parameters
22:55:47 <pqmodn> > foldr f z [1,2,3]
22:55:47 <arkeet> adnap: they're just as undefined as the x in \x -> x
22:55:48 <lambdabot>   f 1 (f 2 (f 3 z))
22:55:52 <Cale> adnap: (\x -> y) introduces something called x in the context of y
22:56:00 <lafyn> adnap: you can't reduce any isspace)
22:56:07 <pqmodn> > foldr cons' nil' [1,2,3]
22:56:07 <arkeet> maybe the multi-letter names are confusing you. :p
22:56:08 <lambdabot>   Not in scope: cons'
22:56:08 <lambdabot>  Perhaps you meant one of these:
22:56:09 <lambdabot>    BSL.cons' (imported...
22:56:15 <pqmodn> what...?
22:56:18 <lafyn> any \x -> f a -> f (a1, a) -> f (a1, f a) -> both cases the limit comes from internal hdd, lvm stuff, etc..
22:56:21 <arkeet> pqmodn: there is no cons or nil
22:56:28 <pqmodn> > f
22:56:30 <lambdabot>   Ambiguous type variable `a0' in the constraints:
22:56:30 <lambdabot>    (GHC.Show.Show a0)
22:56:30 <lambdabot>     ...
22:56:33 <pqmodn> ah
22:56:37 <adnap> Okay, so you actually get values which correspond to typed values when you finally apply arguments to your lambdas
22:56:54 <adnap> Which is never in your examples
22:57:00 <Cale> adnap: Of course, we're going to end up representing pretty much everything by lambdas eventually.
22:57:02 <adnap> They're just the constructors
22:57:10 <Cale> yeah
22:57:17 <adnap> Okay, it makes sense now
22:57:20 <arkeet> :t \f -> f [] (:)
22:57:21 <lambdabot> ([a] -> (a1 -> [a1] -> [a1]) -> t) -> t
22:57:39 <arkeet> :t \l c n -> foldr c n l
22:57:40 <lambdabot> [a] -> (a -> b -> b) -> b -> b
22:57:43 <arkeet> er
22:57:54 <arkeet> :t \l n c -> foldr c n l
22:57:55 <lambdabot> [a] -> b -> (a -> b -> b) -> b
22:57:55 <Cale> adnap: So, if we want to do arithmetic, for instance,
22:58:08 <lafyn> any place and they'll bring it in purchasing 3 nil))) [] (:)
22:58:08 <lafyn> i cant store my json data store, not deduce (a1 ~ b1)
22:58:09 <adnap> Wait
22:58:11 <adnap> don't spoil it
22:58:14 <adnap> I'll try this one
22:58:15 <pqmodn> :t f
22:58:16 <lambdabot> FromExpr a => a
22:58:31 <arkeet> pqmodn: the single-letter things are things from SimpleReflect
22:58:40 <Cale> adnap: Say we want to add a pair of numbers. You might like to try that :)
22:58:56 <pqmodn> yeah, neat
22:59:08 <adnap> (\plus x y -> plus x y)?
22:59:10 <lafyn> for execution: could not and directory / (l^4t^2) = (m * l * l^2)/(l^3 * [ticker --last]*1.08
22:59:29 <arkeet> lafyn: are you ok?
22:59:31 <Cale> Okay, so plus is going to take two parameters
22:59:50 <Cale> each of which we'll assume is a function which takes zero and succ as its parameters
23:00:00 <adnap> plus (plus x y) (plus x y)
23:00:05 <Cale> and it's going to produce a function of zero and succ, similarly
23:00:08 <Cale> So...
23:00:18 <Cale> plus = \n m -> \zero succ -> ...
23:00:22 <lafyn> xeriliext: wait wait for dom is loaded
23:00:23 <lafyn> i'll let someone mangled it in each case
23:00:52 <arkeet> can we mute lafyn or something.
23:01:00 <adnap> Cale: I dpm'
23:01:03 <adnap> Cale: I don't understand
23:01:05 <Cale> lafyn: are you a bot?
23:01:16 <Cale> ... okay
23:01:32 <arkeet> adnap: first we have to agree on what a natural number is.
23:01:55 <Cale> adnap: So, remember, each natural number by convention is a function of some parameters zero and succ
23:02:02 <adnap> A set of sets
23:02:02 <Cale> and will apply succ some number of times to zero
23:02:14 <arkeet> and it has type  forall r. r -> (r -> r) -> r
23:02:18 <adnap> {} {{}} {{{}}}
23:02:21 <arkeet> :t \zero succ -> succ (succ zero)
23:02:22 <lambdabot> t -> (t -> t) -> t
23:02:31 <arkeet> that is 2, for instance.
23:02:43 <arkeet> > (\zero succ -> succ (succ zero))  0 (+1)
23:02:44 <lambdabot>   2
23:02:45 <Cale> adnap: This isn't set theory (and that's an unusual approach to the naturals in set theory, but it can work)
23:02:50 <arkeet> > (\zero succ -> succ (succ zero)) z f
23:02:51 <lambdabot>   f (f z)
23:03:13 <adnap> arkeet: That makes sense
23:03:45 <arkeet> it's prettier if we put succ first, so that our type is  (r -> r) -> r -> r
23:04:10 <Cale> Yeah, the main reason I put nil first was just because I wrote Nil first in the data declaration for Nat
23:04:28 <Cale> (and wanted to keep the translation as straightforward as possible)
23:04:31 <adnap> So, how does plus work?
23:04:45 <Cale> Okay, so plus is going to take our two numbers n and m as parameters
23:04:51 <adnap> It takes two functions which are functions of succ and nil
23:04:57 <arkeet> @let zero = \z s -> z; one = \z s -> s z; two = \z s -> s (s z); three = \z s -> s (s (s z)); showNat n = n 0 (+1)
23:04:59 <Cale> and then it's going to produce a number, so it needs to take zero and succ as additional parameters
23:04:59 <lambdabot>  Defined.
23:05:01 <arkeet> > showNat two
23:05:07 <lambdabot>   2
23:05:25 <johnny934759> anyone has plans to write a sparse matrix library?
23:05:32 <arkeet> @let four = \z s -> s (s (s (s z))); five = s (s (s (s (s z))))
23:05:34 <lambdabot>  <local>:6:40:
23:05:34 <lambdabot>      The function `s' is applied to one argument,
23:05:34 <lambdabot>      but its...
23:05:38 <adnap> arkeet: Dude, I get it
23:05:39 <Cale> and the idea is that we want to replace the zero in our first number n with the number (m zero succ)
23:05:39 <arkeet> @let four = \z s -> s (s (s (s z))); five = \z s -> s (s (s (s (s z))))
23:05:44 <lambdabot>  Defined.
23:05:45 <lispy> johnny934759: I think carter is working on that
23:05:46 <arkeet> yes, I'm just defining stuff for convenience. :p
23:05:52 <Cale> and each succ in n will be implemented by *our* succ
23:06:01 <arkeet> adnap: now make a function plus, such that plus two two = four. (extensionally)
23:06:14 <arkeet> and so on.
23:06:17 <johnny934759> lispy: oh cool anything online yet?
23:06:20 <adnap> Well, Cale is explaning plus
23:06:21 <Cale> So,  plus = \n m -> \zero succ -> n (m zero succ) succ
23:06:26 <arkeet> sure.
23:06:36 <lispy> johnny934759: not that I know of
23:06:43 <adnap> Cale: Oooh!
23:06:53 <arkeet> @let plus = \n m -> \zero succ -> n (m zero succ) succ
23:06:55 <lambdabot>  Defined.
23:06:55 <lispy> johnny934759: if you have a C library that does a good job of it, writing an FFI binding is not so hard.
23:06:57 <arkeet> > showNat (plus two two)
23:06:59 <lambdabot>   4
23:07:01 <lispy> johnny934759: or fortran for that matter
23:07:01 <mauke> tou can also think in terms of 'data Nat = Zero | Succ Nat'
23:07:16 <mauke> write the code; then eliminate the type afterwards
23:07:17 <lispy> johnny934759: does the C lib under numpy do what you want? Maybe you could make a binding to that?
23:07:32 <arkeet> adnap: ok, now do multiplication. :p
23:07:46 <adnap> I don't get "plus = \n m -> \zero succ"
23:07:58 <arkeet> that's not how you parse it.
23:07:59 <shachaf> Now do Ackermann!
23:08:03 <adnap> I imagined "plus = \n m zero succ"
23:08:04 <arkeet> plus = \n m -> (\zero succ -> n (m zero succ) succ)
23:08:12 <Cale> adnap: You can write it that way too
23:08:13 <johnny934759> lispy: yeah i think so just don't want to reinvent the wheel
23:08:28 <Cale> adnap: I only grouped the parameters like that to indicate a certain way of thinking about it
23:08:40 <adnap> Cale: I don't understand it
23:08:44 <Cale> adnap: \x y -> ... is shorthand for \x -> \y -> ... anyway
23:08:47 <mauke> adnap: (\x -> (\y -> ...)) == (\x y -> ...)
23:09:00 <adnap> Oh, wait1
23:09:04 <adnap> Now I understand
23:09:05 <Cale> (though in Haskell with more complicated patterns and seq, that's not quite true)
23:09:15 <arkeet> exercise: write (++) using foldr
23:09:32 <lispy> johnny934759: I've never seen a haskell binding to the numpy stuff (and we tend to strongly prefer BSD3/MIT over GPL, is it numpy GPL?), but having a binding might be a cool thing to have.
23:09:36 <amosr> @hoogle State# -> a
23:09:36 <lambdabot> Did you mean: State# a -> a
23:09:37 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
23:09:37 <lambdabot> Prelude id :: a -> a
23:09:52 <amosr> @hoogle State# a -> a
23:09:53 <lambdabot> Prelude id :: a -> a
23:09:53 <lambdabot> Data.Function id :: a -> a
23:09:53 <lambdabot> GHC.Exts breakpoint :: a -> a
23:09:53 <lispy> johnny934759: there is hmatrix and it binds to BLAS, but I don't think it supports sparse computations
23:09:58 <Cale> adnap: The idea is that n and m are what we'd normally think of as parameters to plus, while zero and succ are parameters to the number which is the result of plus
23:10:01 <amosr> @hoogle State# a -> State a
23:10:02 <lambdabot> Did you mean: State# a -> State a a
23:10:02 <lambdabot> Data.Graph.Inductive.Graph delNode :: Graph gr => Node -> gr a b -> gr a b
23:10:02 <lambdabot> Data.Graph.Inductive.NodeMap delMapNode :: (Ord a, DynGraph g) => NodeMap a -> a -> g a b -> g a b
23:10:13 <amosr> sorry *stops spamming*
23:10:15 <adnap> Cale: That makes sense
23:10:46 <Cale> adnap: Okay, so would you like to try multiplication on your own, or shall I do it?
23:11:12 <shachaf> I think that this is a good exercise but that adnap is not quite ready for it.
23:11:16 <adnap> I'll try it
23:11:47 <Cale> (multiplication would be easier if I'd chosen the other parameter convention for numbers)
23:11:56 <Cale> (but only slightly)
23:13:35 <arkeet> exercise: figure out why my previous exercise was relevant
23:14:12 <luite> amosr: you can't get an a out of a State# a, it doesn't have any runtime representation
23:14:24 <shachaf> I,I unsafePerformState#
23:14:44 <amosr> luite: yes, I was confused. I actually wanted a boxed state
23:14:55 * hackagebot Buster 0.1.1 - Hits a set of urls periodically to bust caches  http://hackage.haskell.org/package/Buster-0.1.1 (MichaelXavier)
23:14:58 <shachaf> State# is completely unrelated to State.
23:15:21 <amosr> I may be doubly confused though: STRep s a = State# s -> (# State# s, a #)
23:15:25 <luite> amosr: State# is just some implementation detail of IO, ST, STM and such, you don't want it :)
23:15:26 <amosr> does that mean 'a' must be unboxed there?
23:15:33 <shachaf> No.
23:15:37 <shachaf> The tuple is unboxed.
23:15:40 <Cale> amosr: What are you trying to accomplish overall?
23:15:50 <amosr> but unboxed tuples can contain boxed things? OK, cool
23:16:04 <shachaf> Yes. They're just pointers.
23:16:13 <amosr> ah
23:16:26 <shachaf> An unboxed tuple probably means that the value will be returned in two registers or something like that?
23:16:42 <shachaf> Write some code, compile it, look at the Core and Cmm.
23:17:03 <luite> amosr: yes, but unboxed tuples are much more limited in what you can use them for than boxed values (or unboxed primitives)
23:17:04 <tikhonjelvis> or at least the two values will be passed around directly on the stack
23:17:23 <amosr> okay. I am boxing too many things, then
23:17:25 <shachaf> Right. It depends on the exact code.
23:17:38 <Cale> amosr: What are you actually doing?
23:17:43 * shachaf notes that there are unboxed 1-tuples.
23:18:10 <amosr> well… we have this ghc plugin that converts ghc core to ddc core, then does some stuff, then converts back to ghc
23:18:17 <Cale> ah, okay
23:18:46 <amosr> I'm trying to convert boxed tuples to ddc core and back to ghc
23:19:00 <Cale> (I was just concerned that you were actually writing a Haskell program and worrying about unboxed tuples and such quite as much as this.)
23:19:36 <luite> shachaf: i think it had something to do with seq primops or something, that they're different from nontuples, do you remember?
23:19:38 <amosr> yes it is a very strange request
23:19:57 <shachaf> luite: I think it has to do with forcing, yes.
23:20:15 <shachaf> Something like you can do case tuple of _ { ... } without forcing the value inside it?
23:20:18 <shachaf> I don't remember.
23:20:28 <liyang> So no one wanted to spoon/spork with me? D: https://github.com/liyang/spoon
23:20:33 <luite> right, that's what i thought, seems likely
23:21:03 <shachaf> liyang: I find it sad that NFData gets preferential treatment to WHNFData.
23:21:06 <amosr> however I tried to do "let i = 2 :: Int " "(# 2#, i #)" in ghci and it's a kind error
23:21:09 <shachaf> NFData is the devil.
23:21:38 <luite> amosr: they're really limited in how you can use them, you can return an unboxed tuple and immediately pattern match on it
23:21:44 <shachaf> amosr: No it's not.
23:22:07 <shachaf> Well, there's a kind error when you try to print the tuple.
23:22:09 <shachaf> Try :t ...
23:22:17 <amosr> doh!
23:22:23 <luite> ghc 7.6 did lift some restrictions, so maybe what you want is allowed
23:22:25 <amosr> thanks!
23:22:33 <shachaf> ghci and unboxed tuples don't mix well
23:22:47 <shachaf> In fact there's a horrible special case just for IO.
23:22:51 <shachaf> It's really quite awful.
23:22:52 <luite> oh right, that's true too (quite annoying...)
23:24:15 <shachaf> The special case is this, I think: ghci doesn't support unboxed tuples. IO is implemented as an unboxed tuple. But the runtime representation of (# State# s, a #) is the same as that of (a).
23:24:27 <shachaf> So ghci handles that particular unboxed tuple.
23:24:57 <shachaf> I might be misremembering.
23:25:40 <luite> the part about the runtime representation is correct at least :)
23:26:07 <shachaf> Yes, I know that much.
23:29:03 <liyang> shachaf: why do you see spoon/teaspoon as preferential treatment for NFData? (I agree that it's evil.) The names make sense here: a teaspoon catches fewer things than a spoon.
23:29:17 <shachaf> OK, then call it tablespoon and teaspoon.
23:29:29 <shachaf> A teaspoon is a spoon. teaspoon is a better spoon than spoon.
23:29:49 <liyang> Point.
23:30:13 <tikhonjelvis> I wonder what would have happened had we used a similar naming convention for functors/monads/etc, back in the day...
23:30:24 <liyang> Anyway, I only put it on GitHub because I wanted Handles on my spoons, tea- or otherwise.
23:30:35 <shachaf> The handles go on the tea*cups*.
23:31:12 <liyang> Next you'll want soupLadles.
23:32:17 <Cale> You could call the package cutlery
23:32:44 <liyang> I'm afraid that I was not responsible for calling it spoon. :<
23:33:30 <liyang> But I'll consider the rename if someone wants to write spork.
23:33:40 <Cale> http://upload.wikimedia.org/wikipedia/en/a/af/Splayds.jpg
23:34:34 <luite> liyang: you automatically assume responsibility by forking the spoon
23:34:43 <liyang> … OMG.
23:35:50 <luite> sorry :(
23:37:44 <adnap> Cale: \mult n m -> \zero succ -> n zero (mult zero)
23:38:15 <liyang> The original author disappeared. :( And copumpkin doesn't want to maintain it.
23:38:28 <shachaf> What!
23:39:33 <adnap> Cale: Oops. Meant \mult n m -> \zero succ -> n zero (m zero)
23:44:15 <Cale> adnap: mult should be the thing being defined, rather than a parameter
23:44:35 <Cale> adnap: also, it should be suspicious that you haven't used succ
23:44:46 <adnap> >_<
23:47:52 <adnap> Cale: How about mult = \n m -> \zero succ -> m zero (plus n)
23:48:06 <adnap> No...
23:48:10 <adnap> I didn't use succ again
23:48:45 <adnap> Wait..
23:49:01 <adnap> If I use "m" and "n", aren't I using succ and zero?
23:49:12 <adnap> Since they're functions that take succ and zero
23:49:41 <Cale> They're functions of some succ and zero which you have to plug in
23:49:42 <shachaf> You are getting an argument and not using it.
23:49:52 <Cale> (different succ and zero)
23:49:57 <shachaf> You may as well write: \n m -> \zero _ -> ...
23:49:58 * hackagebot wai-logger 0.3.1 - A logging system for WAI  http://hackage.haskell.org/package/wai-logger-0.3.1 (KazuYamamoto)
23:50:08 <adnap> mult's zero and succ are getting plugged into n and m's plus and suzz
23:50:10 <adnap> *succ
23:50:10 <shachaf> (By the way, the arguments are backwards!)
23:50:27 <Cale> Yes, the arguments are "backwards", but it doesn't really matter
23:50:56 <Cale> (this is a good bit easier with the other convention in the end, but one should be able to do it either way)
23:52:14 <Cale> adnap: they are not
23:52:18 <Cale> well, zero is...
23:53:17 <Cale> adnap: Okay, so the idea we should have is this: we want to take m and replace the zero in it with our parameter zero, and replace each succ in it with a function which applies our succ to a number n times.
23:53:47 <shachaf> jmcarthur: Should ST be marked Trustworthy?
23:54:04 <Cale> adnap: Given some number x, how do we apply succ to x, n times?
23:55:23 <Cale> Well, n itself is a lambda (\zero succ -> succ (succ ... (succ zero) ...)) which does this to some arbitrary number zero
23:55:34 <adnap> Cale: Argh! Shhhh
23:55:39 <Cale> okay :)
23:55:44 <adnap> GEEZ
23:55:51 <adnap> I didn't ask you to spoil anything
23:59:33 <Cale> adnap: Well, I didn't quite write it :)
