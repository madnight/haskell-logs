00:00:09 <eflister> saizan: is it possible when Reader is on the inside?
00:04:35 <Saizan> there doesn't seem to be a good way to turn a ParsecT over some monad into a ParsecT over some other
00:04:55 <Saizan> maybe you can use the intrinsic "user state" feature of Parsec instead
00:05:39 <Saizan> or patch parsec
00:06:04 <Saizan> oh
00:06:12 <Saizan> you can use runParsecT and mkPT
00:07:24 <eflister> saizan: ha ha, i was frightened off by the docs saying 'you really shouldn't have to use mkPT' -- i figured i must be missing something.  isn't this kind of thing fairly common?
00:09:58 <Saizan> well, mtl has combinators like mapFooT :: (m a -> n a) -> FooT m a -> FooT n a
00:10:20 <Saizan> so it's not that uncommon, but it's not that common either
00:12:32 <eflister> saizan: hm, maybe edwardk's parsers facilitates this case, i'll check.  is there something about the problem that makes you prefer ReaderT Parsec despite my arguments above?
00:16:45 <Saizan> i think if you prefer Reader inside you shold go for it
00:17:27 <Saizan> there's nothing wrong about implementing your mapParsecT
00:18:15 <eflister> saizan: it would mean using mkPT and understanding that reply/consumed stuff, right?
00:19:02 <Saizan> you don't need to understand much, just let the types guide you
00:23:58 <Saizan> though you'll probably need the input function to be (forall a. m a -> n a), or you could do something specific to Reader
00:27:59 <numberten> anyone know if it's possible to fmap printf?
00:30:49 <Saizan> yeah
00:32:20 <flebron> > fmap (printf "%.4f" :: Float -> String) [0.4, 0.1]
00:32:21 <lambdabot>   ["0.4000","0.1000"]
00:33:25 <numberten> ah
00:33:32 <numberten> i didn't put the explicit type annotation
00:33:39 <numberten> thanks Saizan
00:33:51 <numberten> flebron rather
00:35:37 <Iceland_jack> > fmap (printf "%.4f") [0.4, 0.1 :: Float] :: [String] -- also works
00:35:38 <lambdabot>   ["0.4000","0.1000"]
00:36:09 <Iceland_jack> > fmap (printf "%.4f") [0.4, 0.1] :: [String]
00:36:10 <lambdabot>   ["0.4000","0.1000"]
00:37:40 <Iceland_jack> > printf"%.4f"<$>[0.4,0.1]::[String] -- ‚Ä¶
00:37:41 <lambdabot>   ["0.4000","0.1000"]
00:41:35 <numberten> probably a neater way of doing this but for multiple arguments:
00:41:39 <numberten> > fmap (uncurry $ printf "%.4f %s" :: (Float,String) -> String) [(0.4,"String1"), (0.1,"String2")]
00:41:40 <lambdabot>   ["0.4000 String1","0.1000 String2"]
00:55:35 <ReinH> well, you can replace the $ with a .
00:55:46 <skypers_> hello
00:56:03 <ReinH> er no, you can't
00:56:05 <ReinH> sorry
00:56:16 <skypers_> > lines "hi\ntest"
00:56:17 <lambdabot>   ["hi","test"]
00:56:57 <skypers_> > sortTee :: FilePath -> FilePath -> IO (); sortTee ifile ofile = (lines `liftM` readFile ifile) >>= write ofile (concat . sort)
00:56:59 <lambdabot>   <hint>:1:41: parse error on input `;'
00:57:15 <skypers_> :t sortTee ifile ofile = (lines `liftM` readFile ifile) >>= write ofile (concat . sort)
00:57:16 <lambdabot> parse error on input `='
00:57:23 <skypers_> arf?
00:57:36 <skypers_> can‚Äôt we declare functions that way in lambdabot?
00:58:18 <eflister> saizan: hm, i came up with mapParsecT f p = mkPT $ f <$> runParsecT p, but then runPTReader v p = mapParsecT (flip runReaderT v) p doesn't compile...
00:58:31 <k00mi> :t \ifile ofile -> (lines `liftM` readFile ifile) >>= write ofile (concat . sort)
00:58:31 <lambdabot>     Not in scope: `write'
00:58:32 <lambdabot>     Perhaps you meant `writer' (imported from Control.Monad.Writer)
00:58:33 <skypers_> :t \ifile ofile -> (lines `liftM` readFile ifile) >>= write ofile (concat . sort)
00:58:33 <lambdabot>     Not in scope: `write'
00:58:34 <lambdabot>     Perhaps you meant `writer' (imported from Control.Monad.Writer)
00:58:44 <skypers_> :t \ifile ofile -> (lines `liftM` readFile ifile) >>= writeFile ofile (concat . sort)
00:58:45 <lambdabot>     Couldn't match expected type `[String] -> IO b0'
00:58:45 <lambdabot>                 with actual type `IO ()'
00:58:45 <lambdabot>     In the return type of a call of `writeFile'
00:59:23 <skypers_> :t \ifile ofile -> (lines `liftM` readFile ifile) >>= writeFile ofile . concat . sort
00:59:24 <lambdabot> FilePath -> FilePath -> IO ()
00:59:28 <skypers_> :)
00:59:47 <skypers_> could I write that with liftM3 (>>=)¬†?
01:00:02 <Saizan> eflister: what's the typeof mapParsecT there?
01:00:25 <skypers_> :t \ifile ofile -> lines `liftM` readFile ifile >>= writeFile ofile . concat . sort
01:00:25 <lambdabot> FilePath -> FilePath -> IO ()
01:00:31 <arkeet> :t liftM3 (>>=)¬†
01:00:32 <lambdabot> Not in scope: data constructor `¬'
01:00:36 <arkeet> :t liftM3 (>>=)
01:00:36 <lambdabot> Monad m => m (a3 -> a) -> m (a -> a3 -> b) -> m a3 -> m b
01:00:36 <skypers_> oh it works without ( )
01:00:51 <arkeet> sometimes, yes.
01:00:54 <eflister> > :t \f p ->  p = mkPT $ f <$> runParsecT p
01:00:55 <lambdabot>   <hint>:1:1: parse error on input `:'
01:01:07 <eflister> :t \f p ->  p = mkPT $ f <$> runParsecT p
01:01:08 <lambdabot> parse error on input `='
01:01:10 <skypers_> arkeet: it‚Äôs hard for me to use liftM(2+) functions
01:01:15 <skypers_> I know what is liftM
01:01:19 <arkeet> liftM is fmap
01:01:20 <eflister> :t \f p ->  mkPT $ f <$> runParsecT p
01:01:21 <lambdabot> Not in scope: `mkPT'
01:01:21 <lambdabot> Not in scope: `runParsecT'
01:01:27 <eflister> ha ha
01:01:29 <skypers_> it lifts up a "pure" computation as monadic
01:01:30 <skypers_> but hm
01:01:36 <skypers_> binary computation is hard for me to get
01:01:36 * hackagebot authoring 0.3.1 - A library for writing papers  http://hackage.haskell.org/package/authoring-0.3.1 (TakayukiMuranushi)
01:01:41 <skypers_> like that one:
01:01:44 <skypers_> :t liftM2 (>>)
01:01:45 <lambdabot> (Monad m, Monad m1) => m (m1 a) -> m (m1 b) -> m (m1 b)
01:01:49 <arkeet> liftA2 turns a -> b -> c into f a -> f b -> f c
01:01:54 <arkeet> for Applicative f
01:01:57 <arkeet> and so on.
01:01:57 <skypers_> yes
01:02:07 <skypers_> it takes a binary functions
01:02:11 <skypers_> two Applicative
01:02:34 <eflister> saizan: (m1 (Consumed (m1 (Reply s u a1)))       -> m (Consumed (m (Reply s u a))))      -> ParsecT s u m1 a1 -> ParsecT s u m a
01:02:35 <skypers_> extracts each Applicative‚Äôs values and outputs the function applied
01:02:56 <skypers_> for liftM2 (>>), I noticed something nice
01:03:23 <skypers_> liftM2 (>>) print print
01:03:28 <Saizan> eflister: right, you've to do quite a bit more than just <$>
01:03:28 <skypers_> it will take a String
01:03:48 <skypers_> and pass it along both the two monadic functions
01:03:49 <skypers_> why?
01:05:58 <eflister> saizan: is it obvious to you and you're being pedagogical (ie, any hints?), or...
01:06:27 <monoidal> skypers_: for the reader monad, liftM2 f x y r = f (x r) (y r), e.g. liftM2 (+) sin cos 4 is sin 4 + cos 4
01:06:35 <Saizan> eflister: i didn't have parsec installed, got it now and i'm writing the code
01:06:57 <eflister> saizan: :) thx!
01:07:50 <skypers_> [09:59] <monoidal> skypers_: for the reader monad, liftM2 f x y r = f (x r) (y r), e.g. liftM2 (+) sin cos 4 is sin 4 + cos 4
01:07:52 <skypers_> woah
01:07:56 <skypers_> that‚Äôs just impressive
01:07:59 <monoidal> hm?
01:08:15 <skypers_> I don‚Äôt get why there :D
01:08:33 <skypers_> :t liftM2 (+) sin cos
01:08:33 <lambdabot> Floating a => a -> a
01:08:38 <skypers_> huh
01:08:53 <skypers_> what‚Äôs the monad there?
01:09:05 <skypers_> (Floating a) => (->) a
01:09:05 <skypers_> ?
01:09:06 <monoidal> (->) a
01:09:07 <Flonk> skypers_: ( (->)r ), Functions are an instance of Monad
01:09:17 <skypers_> ok, got it then :)
01:09:36 <skypers_> I might need to read the >>= definition for (->) r
01:09:37 <FireFly> @ty liftM2 `asAppliedTo` (+)
01:09:38 <lambdabot> (Monad m, Num r) => (r -> r -> r) -> m r -> m r -> m r
01:09:49 <monoidal> skypers_: don't read it
01:10:01 <skypers_> once again, I don‚Äôt know asAppliedTo :D
01:10:02 <monoidal> skypers_: the type is (r -> a) -> (a -> r -> b) -> r -> b. figure it out.
01:10:48 <skypers_> :t liftM2 (+)
01:10:49 <lambdabot> (Monad m, Num r) => m r -> m r -> m r
01:10:59 <skypers_> hm
01:11:15 <Reite> How can I write foo2 in point free style? https://gist.github.com/reite/7038067
01:11:17 <skypers_> :t (>>=) (+)
01:11:17 <lambdabot> Num a => ((a -> a) -> a -> b) -> a -> b
01:11:21 <skypers_> holy shit
01:11:22 <skypers_> :D
01:11:23 <Saizan> eflister: http://lpaste.net/94407
01:11:49 <skypers_> so it takes a function that takes a function
01:11:51 <skypers_> damn
01:11:51 <cinimod> I need to use days of the week: where do I get e.g. data Day = Monday | ... | Sunday?
01:12:04 <cinimod> Couldn't see it in data.time
01:12:40 <monoidal> @pl \a b -> Bar (Foo2 a b)
01:12:41 <lambdabot> (Bar .) . Foo2
01:12:51 <monoidal> Reite: ^ as you see, it's not really readable
01:13:01 <monoidal> more readable
01:13:05 <cinimod> monoidal: Better is (.).(.)
01:13:13 <monoidal> agreed
01:13:16 <johnw> how is that better?
01:13:31 <Reite> @pl \a b c -> Bar (Foo2 a b c)
01:13:32 <lambdabot> ((Bar .) .) . Foo2
01:13:43 <cinimod> (.).(.).(.)
01:13:45 <derdon> cinimod: one question: am I the only one who calls it the boobs function?
01:13:47 <skypers_> :t return (+)
01:13:48 <lambdabot> (Monad m, Num a) => m (a -> a -> a)
01:13:53 <ReinH> derdon: please stop doing that
01:13:56 <derdon> sorry
01:13:59 <cinimod> I didn't dare say it
01:14:06 * derdon hides
01:14:07 <Flonk> :t ( (.).(.) )
01:14:08 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
01:14:20 <Flonk> ‡≤†_‡≤†
01:14:56 <Flonk> > ( (.).(.) ) (+1) (+) 10 100
01:14:57 <lambdabot>   111
01:15:25 <ReinH> let (.:) = fmap fmap fmap
01:16:15 <skypers_> ReinH: I‚Äôm not sure that would work
01:16:18 <Flonk> ReinH: It took me so long to figure out that fmapping a function onto another is just (.)
01:16:29 <skypers_> wouldn‚Äôt it fmap . fmap . fmap?
01:16:31 <cinimod> It seems a shame to invent my own datatype for Monday | ... | Sunday
01:16:36 <cinimod> Ah well
01:16:51 <skypers_> Flonk: :D
01:16:51 <Flonk> > (fmap fmap fmap) (+1) [[1],[2]]
01:16:55 <lambdabot>   [[2],[3]]
01:17:35 <skypers_> how should we read that?
01:17:43 <skypers_> oh
01:17:43 <skypers_> yes
01:17:49 <skypers_> nevermind
01:17:52 <ReinH> skypers_: why not?
01:18:56 <skypers_> :t fmap fmap
01:18:56 <lambdabot> (Functor f, Functor f1) => f (a -> b) -> f (f1 a -> f1 b)
01:19:06 <skypers_> hm
01:19:15 <skypers_> is it evaluated from right to left?
01:19:27 <skypers_> because fmap takes a function then two Functors
01:19:44 <skypers_> so I thought that would result in a compiler error
01:19:44 <skypers_> like
01:19:54 <skypers_> well
01:19:57 <skypers_> not error
01:19:59 <skypers_> but not that type
01:20:09 <skypers_> :t fmap (fmap)
01:20:09 <lambdabot> (Functor f, Functor f1) => f (a -> b) -> f (f1 a -> f1 b)
01:20:16 <skypers_> what
01:20:18 <monoidal> you have a function (a -> b) -> (f a -> f b), apply fmap to this, you get g (a -> b) -> g (f a -> f b)
01:20:27 <skypers_> yeah
01:21:06 <skypers_> ok
01:21:07 <skypers_> got it
01:21:23 <skypers_> I always use that to go through nested list as well
01:21:32 <skypers_> lists*
01:22:43 <skypers_> :t fmap . fmap
01:22:44 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
01:23:32 <fizruk> <\$>
01:24:02 <Flonk> :t (<\$>)
01:24:03 <lambdabot>     Not in scope: `<\$>'
01:24:03 <lambdabot>     Perhaps you meant `<$>' (imported from Control.Applicative)
01:24:47 <fizruk> sorry, ignore that
01:29:07 <cinimod> Anyone know why [1..2] compiles, [False..True] doesn't but [False .. True] does
01:30:16 <fizruk> > [False..True]
01:30:17 <lambdabot>   A section must be enclosed in parentheses thus: (False.. True)Not in scope:...
01:30:22 <monoidal> cinimod: False.. is the operator . from module False
01:30:23 <johnw> False. is taken to be a module prefix
01:32:36 <cinimod> But 1. is not a module prefix I guess
01:32:51 <quchen> Modules start with capital letters.
01:32:52 <monoidal> right. module names have to start upcase
01:33:05 <fizruk> > let n = False in [n..True]
01:33:06 <lambdabot>   [False,True]
01:33:14 <cinimod> Thanks
01:33:40 <cinimod> Always nice to know why something doesn't work even if you know how to fix it
01:36:11 <fizruk> guys, what IRC client do you use? Nettalk eats < $ > (infix fmap) and I can't figure out why (I think it tries to interpret  as a variable somehow) :(
01:36:35 <cinimod> erc in emacs
01:36:45 <Flonk> Freenode webchat
01:37:22 <elliott> from the sounds of it, I recommend any client but Nettalk.
01:37:27 <alexander__b> weechat.
01:38:24 <tiffany> hexchat
01:40:44 <eflister> saizan: totally works, thanks a lot!  so far i haven't understood why but will keep at it...
01:44:28 <fizruk_> > (+) <$> id <*> tail $ [1..10]
01:44:29 <lambdabot>   No instance for (GHC.Show.Show a0)
01:44:29 <lambdabot>    arising from a use of `M1690043939.sh...
01:45:14 <fizruk> tiffany: hexchat seems good for me!
01:45:19 <fizruk> thanks, guys!
01:45:55 <eflister> saizan: my instinct was to try to use =<< somehow for the problem (needing to chain states), is it easy to explain why i shouldn't have thought that?
01:54:25 <quchen> I just heard a guy claim that types can't be polymorphic, but "polymorphic use of similar types". Is there something I'm missing or is this nonsense?
01:55:07 <quchen> There's a verb missing in the quoted part, but the main question is more whether claiming that types can't be polymorphic is wrong.
01:57:01 <elliott> I say, regrettably pedantically but necessarily: define "polymorphic".
01:59:52 <quchen> elliott: Hm, good point. Is there a definition?
02:00:20 <quchen> Or is it just a vague description of some idea
02:02:07 <quchen> My Haskell gut feeling of polymorphism is that "a -> a" can be used in many different contexts, hence id is polymorphic
02:02:24 <quchen> ‚Ä¶ to take the simplest non-‚ä• example
02:03:18 <kenkku> why not just read the wiki? http://www.haskell.org/haskellwiki/Polymorphism
02:04:31 <Saizan> eflister: (=<<) is not a general operator to chain states, its behaviour depends on the monad you're using it in
02:04:54 <Saizan> eflister: also, by itself it won't mix different monads
02:07:46 <Saizan> runRP makes use of the specifics of Reader and ParsecT to show you only need an 'r' to embed that stack in a plain Parser
02:09:17 <eflister> saizan: i guess i mean why wouldn't parsec's =<< chain states?
02:09:50 <Saizan> it doesn't know anything about what you consider states here
02:12:20 <Saizan> eflister: have you looked at the implementation of Reader and State?
02:12:46 <Saizan> it's a good exercise to learn how un-magical this stuff is
02:13:13 <eflister> saizan: i mean parsec's state, like where it is in the input, if there's an error, etc.  that's what was breaking from the way i did it at first -- not the reader part...
02:13:49 <Saizan> eflister: oh, it does do that
02:14:15 <eflister> saizan: ok, cool, that's why i was thinking it was what i needed :)
02:14:49 <cpa> :t (***)
02:14:49 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
02:16:11 <Flonk> What can I do with Arrows that I can't do with regular functions?
02:16:26 <Saizan> eflister: what code were you trying at first?
02:17:27 <eflister> saizan: that runPTReader at http://lpaste.net/94401
02:18:06 <donri> Flonk: the -> is opaque, the "a" may not be
02:18:41 <donri> plus the "a" may carry side effects
02:19:19 <Flonk> donri: I see, makes sense
02:19:45 <Saizan> eflister: yeah, the problem there is that runParserT has already stepped out of the ParsecT monad, and on top of that the result doesn't give you back all the info
02:21:41 <merijn> Flonk: For example, "newtype Kleisli m a b = Kleisli (a -> m b)" is an Arrow too (i.e. the Kleisli arrow) which lets you compose monadic functions, rather than just "normal" ones
02:21:45 * hackagebot amqp 0.7.0 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.7.0 (HolgerReinhardt)
02:24:19 <eflister> saizan: i thought fmap'ing it all into getState's ParsecT would keep the state, sort of...  but anyway, why isn't there a way to use parsec's =<<?  i do see that wouldn't allow changing the inner monad, i guess that's the problem...
02:25:52 <Saizan> eflister: no, in that expression you have two layers of ParsecT, you do feed the state from one to the other through getState/getInput put you don't put it back
02:28:49 <cinimod> :r
02:28:52 <cinimod> sorry
02:29:09 <elliott> *Main>
02:29:37 <Saizan> *but you
02:30:52 <Saizan> eflister: and yeah, that's the problem of (>>=)
02:31:59 <eflister> saizan: hrm, so i would have just had to add a setInput . setState?  but with what arguments?  that getState/setState is just the user state though, not the parsec internals, is that included in input?
02:33:07 <eflister> saizan: this is interesting: http://ircbrowse.net/browse/haskell?events_page=302888 -- stepcut's mapParsecT is a lot simpler, is it wrong then?
02:34:34 <Saizan> eflister: stepcut's one does less and it's so harder to use, it's basically your last attempt
02:34:42 <Saizan> *so it's
02:36:18 <Saizan> eflister: i don't know if getInput gives yo the whole internal state, but anyhow runParserT doesn't give back the resulting one
02:37:12 <eflister> saizan: but if it's fmap'ed into getInput?  :)
02:38:07 <Saizan> you ascribe too much magic to fmap :)
02:38:47 <Saizan> fmap is supposed to leave the surrounding structure alone, and touch only the "elements"
02:38:59 <Saizan> so it won't mess with parsec's internal state
02:39:49 <eflister> eflister: i must be thinking about it backwards, i thought i meant "existing within that state" rather than messing with it..
02:40:38 <eflister> saizan: i meant saizan.  oh i see now i think, it won't *update* that state...  got it...
02:40:40 <Saizan> the state of the parsec layer you're calling fmap at is the same you got from getInput
02:42:34 <eflister> saizan: although updating the state feels like touching elements, not structure, to me...
02:43:45 <eflister> saizan: i guess it could change its shape into an error or something, again more what you'd expect from bind...
02:44:40 <Saizan> eflister: in fmap :: Functor f => (a -> b) -> f a -> f b what i meant by elements are the values of type 'a' or 'b'
02:45:30 <Saizan> iow fmap id = id
02:50:07 <eflister> saizan: well i'm not meaning to change f, right, it's still ParsecT s u m (ignoring the need to change inner monad ftm).  even tripping into an error state doesn't change that...
02:51:06 <kraiskil> Is it possible to run multithreaded programs on ghci? I can get only 100% usage on one core, and find instructions only on how to enable in in ghc, not ghci.
02:51:08 <Saizan> eflister: but you're not allowed to mess with the shape of the same 'f' either
02:51:31 <Saizan> eflister: e.g. fmap for [] can't give you a list with a different length
02:52:25 <Saizan> kraiskil: try starting ghci with "ghci +RTS -N"
02:52:38 <eflister> saizan: good example...
02:52:53 <mr-> Is it true that "Free [] Int" has as typical members something like [3,[[4,5],[3]] which can be interpreted as a tree?
02:53:50 <Horatio> fucking niggers
02:53:55 <Horatio> haskell is a piece of shite
02:54:01 <Horatio> virgin fucking cunts
02:54:02 --- mode: ChanServ set +o elliott
02:54:04 --- mode: elliott set +b *!*521c9b26@*.82.28.155.38
02:54:04 --- kick: Horatio was kicked by elliott (Horatio)
02:54:05 --- mode: elliott set -o elliott
02:54:10 <Reite> haha
02:55:21 <elliott> mr-: yes
02:56:08 <Saizan> yeah, leaf-labelled tree with variable-branching leaves
02:56:19 <Saizan> s/leaves//
02:56:26 <mr-> Thanks :-)
02:57:25 <kraiskil> Saizan, right. the same as for ghc it self...  And, yes, it works. Thanks!
02:58:00 <quchen> mr-: I picture Free as a type-level list, where "cons" corresponds to type nesting. So Free [] is arbitrarily nested lists.
03:01:02 <quchen> mr-: So Free Identity is a long string of NOOPs with a terminating value, Free (a,) is [a] (I think?)
03:01:40 <linduxed> hey guys, i had some guys help me yesterday with a rewrite of an expression, but i'd need help with recreating that
03:01:44 <quchen> Wait, Free (a,) is more like Stream a
03:01:51 <linduxed> right now the expression looks like the following:
03:02:03 <mr-> quchen: no, it can stop, I think
03:02:06 <FireFly> Free (a,) couldn't terminate, it sounds like?
03:02:10 <FireFly> Hm
03:02:14 <Reite> where can I find this Free?
03:02:21 <quchen> mr-: Woops, right, Stream wasn't the right name.
03:02:23 <quchen> I meant NonEmpty.
03:02:25 <Taneb> @hackage free Reite
03:02:25 <lambdabot> http://hackage.haskell.org/package/free Reite
03:02:27 <mr-> Reite: For example https://www.fpcomplete.com/user/dolio/many-roads-to-free-monads
03:02:36 <Reite> thanks
03:02:47 <linduxed> allBut7thPot x = (take 6 (generateBoard x)) ++ (drop 7 (generateBoard x))
03:03:02 <mr-> quchen: Yeah, I aggree
03:03:04 <Saizan> FireFly: it can, there's always the constructor corresponding to return
03:03:16 <linduxed> i tried using the Applicative operators, but it just didn't work out for me :-(
03:03:20 <Taneb> I want to do something cool with my RPi but I don't know where to begin
03:03:41 <quchen> Taneb: LED blinking? Light the LED when your name is mentioned on IRC?
03:03:47 <linduxed> just "generateBoard x" always returns a [Pot] with length 13
03:03:47 <fizruk> linduxed, (++) <$> take 6 <*> drop 7 $ generateBoard x ?
03:03:50 <mr-> quchen: Thanks for the examples, I think it's clicked now. (At least easy cases seem clear :-)
03:04:06 <linduxed> fizruk: oh thx! you helped me yesterday
03:04:20 <linduxed> i'm still a bit rusty on these things
03:04:30 <Taneb> quchen, as in, I'm at this stage where I'm thinking "What are these pin things?"
03:04:32 <fizruk> linduxed, take 6 <> drop 7 $ generateBoard x -- using monoids
03:04:53 <quchen> Taneb: Not sure on what level you're asking this
03:04:59 <linduxed> fizruk: i tried doing "(take 6) <*> (drop 7) <$> generateBoard x"
03:05:14 <elliott> quchen: you are missing a parameter to Free.
03:05:17 <linduxed> fizruk: apparently i've completely forgotten how those things work
03:05:26 <elliott> (Free (a,) b) is not quite [a]
03:05:27 <quchen> mr-: Exercise, what's `Free (Const a)`, where `data Const a b = Const a`, `instance Functor (Const a) where fmap _ (Const x) = Const x`?
03:05:29 <mr-> Taneb: I suppose you are aware of https://github.com/WJWH/HPi ?
03:05:29 <fizruk> :t (<*>)
03:05:30 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:05:33 <elliott> it's closer to ([a],b) but not exactly
03:05:36 <elliott> (Free (a,) ()) is [a] though
03:06:02 <quchen> elliott: Thanks for mentioning that, right
03:06:05 <Taneb> mr-, yeah, looking at that and system-gpio right now
03:06:13 <fizruk> linduxed, take 6 :: f [a], drop 7 :: f [a], where f == ([a] ->)
03:06:34 <fizruk> linduxed, so you can't combine them with <*> (check it's type)
03:06:36 <mr-> quchen: a ?
03:07:00 <quchen> mr-: Note that I forgot the second argument to Free again :-s
03:07:07 <gogostop> What are you Haskellellians' opinions on Go and Rust?
03:07:17 <fizruk> linduxed, so these are just to boxed lists which you can combine using (++) <$> ...
03:07:35 <Kinnison> gogostop: Rust is hilarious and Go has awful awful traceability cockups
03:07:41 <donri> gogostop: rust is cool. don't like go much
03:07:43 <Kinnison> gogostop: otherwise they're not awful
03:08:14 <gogostop> Is Haskell a suitable replacement to both?
03:08:55 <donri> in every case? probably not
03:08:58 <quchen> Haskell is a suitable replacement for most general purpose languages, because it's a general purpose langauge.
03:09:03 <mr-> quchen: is it Either a ?
03:09:19 <linduxed> gogostop: that's an extremely broad question that you probably won't get a good answer to
03:09:37 <linduxed> gogostop: simply because you're not being specific enough
03:09:53 <quchen> mr-: I'm not sure actually to be honest :-P
03:10:14 <fizruk> quchen, ([a], b) ?
03:10:16 <quchen> "Free (Const Void) a" is "a" if I'm not mistaken. It's a version of Free that you cannot nest.
03:10:24 <chrisdone> Taneb: blinken lichten?
03:10:47 <linduxed> gogostop: haskell is good for a lot of stuff, so are the other two (ok, rust isn't finished, but if it was), you just have to pick the language that suits the task the best
03:10:56 <gogostop> linduxed: fair enough. If I were to learn one of the three, which is most useful for networking and concurrency? This seems to be a big advantage of Go, although I'm not sure how the other two fair.
03:11:00 <mr-> quchen: Pure b | Roll (f (Free f b)) = Pure b | Roll (Const a ...) = Pure a | Roll b
03:11:14 <linduxed> but as said, they're all "general purpose" languages, so you'll probably be able to achieve whatever you want to do in all of them
03:11:15 <mr-> (here f = Const a.. I should have just written that)
03:11:28 <donri> gogostop: i would say go with haskell or erlang for networking and concurrency
03:11:44 <quchen> mr-: That looks reasonable.
03:11:58 <mr-> quchen: I would say Free (Const Void) a = Maybe a
03:12:03 <linduxed> gogostop: go makes concurrency very easy and lightweight, but i haven't written any of it myself, so i can't speak much on the topic
03:12:06 <mr-> Or.. is Void inhabited? ;-)
03:12:07 <Taneb> chrisdone, I'd like to
03:12:12 <Taneb> But a) I don't have any lights
03:12:20 <Taneb> and b) Wouldn't know how to attach them
03:12:22 <linduxed> gogostop: rust isn't finished, so i wouldn't recommend that
03:12:24 <bjz> gogostop: Rust is good for concurrency, but less at the networking, although rust-http is getting better
03:12:35 <quchen> mr-: No, not Maybe. As you just mentioned, Free (Const Void) a = Pure a | Roll Void, and that's Pure a.
03:12:47 <bjz> gogostop: Erlang would be great for that
03:12:48 <Taneb> and c) Don't know how to make them blink
03:12:50 <quchen> mr-: You can't make a Nothing with "Right Void".
03:12:52 <donri> gogostop: rust is supposed to be designed from the ground up for concurrency too, although don't know how good the networking support is at this time. it's all under heavy development
03:13:05 <mr-> quchen: Yeah.. I was confused and thought I Void had one member
03:13:07 <linduxed> gogostop: and haskell is definitely a good choice
03:13:08 <merijn> gogostop: I would say that Haskell can do anything Go can do, but there's lots of things Go can't do that Haskell can
03:13:16 <bjz> donri: still has a way to go for the networking side
03:13:37 <quchen> mr-: () has one member.
03:14:01 <donri> gogostop: haskell has great concurrency and networking stuff anyway
03:14:12 <quchen> mr-: Free (Const ()) a  =  Pure a | Roll (Const () ...) = Maybe a
03:14:13 <linduxed> gogostop: i'd say that most importantly, you seem to be at a level where you have to ask these things and don't already know them. my guess would be that at that level it doesn't matter which language you choose, you'll do fine with either one
03:14:14 <bjz> gogostop: rust is basically the best out of the three for close to the metal systems programming, but that doesn't sound like what you'd be focused on
03:14:20 <merijn> gogostop: For example, Haskell has lightweight threads and channels too, I would say it's a great language for networking and concurrency
03:14:37 <donri> gogostop: the new io manager scales linearly up to some 32 or so cores, trivially handling hundreds of thousands of requests per second for a http server
03:15:35 <quchen> donri: Do you know how it scales beyond 32? Nonlinear can also mean O(n^1.1)
03:15:42 <donri> no idea :)
03:15:54 <mr-> quchen: ah, Ok. So Free (Const Void) = Identity. (the second argument to Free is confusign sometimes :-) I was worried that Free (Const Void) a = a is not a monad ;-)
03:16:01 <donri> quchen: go dig http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
03:16:16 <gogostop> erlang/haskell sound promising. thanks for the answers
03:17:12 <quchen> mr-: Unicode to the rescue! a ‚âÖ Identity a so Free (Const Void) a ‚âÖ a
03:18:16 <quchen> mr-: In case that wasn't obvious, I was shamelessly bouncing ideas to you and back, and now I think I learned something about Free. :-D
03:18:27 <mr-> Now my pedantic self would like to argue, but I get it :-)
03:18:31 <mr-> hehe
03:19:03 <quchen> mr-: My physicist self uses ‚âÖ for whatever is suitable in a certain context. :-P
03:19:09 <fizruk> anyone used something like Free (Free f) ?
03:19:25 <quchen> Free matrix? :-s
03:20:18 <fizruk> I'm actually interested in Free (Free f :+: t (Free f))
03:20:58 <chrisdone> quchen: are you typing that with Compose?
03:21:16 <bjz> gogostop: elixir is also interesting - built on top of the rlang vm: http://elixir-lang.org/
03:21:24 <quchen> chrisdone: I wish, but no. I've got some Latex-style autoreplacements in XChat.
03:21:37 <quchen> \cong is ‚âÖ
03:21:50 <quchen> ‡≤†_‡≤†
03:23:27 <chrisdone> ahh
03:24:03 <chrisdone> if i enable agda-mode in a buffer and then switch modes, the \ unicode thing still activates =)
03:24:05 <quchen> chrisdone: I tried getting some sort of Chinese-writing-style program to work but it just made me angry. It would be really nice to have a button that pops up a window in which you can type "a with dots on it" and it inserts an "√§".
03:24:08 <quchen> Anyway, lunch.
03:24:20 <quchen> ^^ Haskell project for grabs by the way :-P
03:25:12 <chrisdone> quchen: Compose is pretty good for me. √§ is: Compose " a
03:25:57 <chrisdone> Compose , c -> √ß, Compose o o -> ¬∞, etc. it's kind of descriptive
03:27:20 <elliott> try Compose c c cp
03:27:40 <elliott> s/cp/c p/
03:29:05 <absence> anyone know how that summer of code qt bindings project went?
03:30:06 <cinimod> > -.1
03:30:07 <lambdabot>   <hint>:1:1: parse error on input `-.'
03:30:12 <cinimod> -0.1
03:30:20 <cinimod> > -0.1
03:30:21 <lambdabot>   -0.1
03:30:26 * chrisdone blinks
03:30:43 <chrisdone> cinimod: what were you expecting?
03:30:55 <cinimod> I have a file with longitudes in the form -.16896424
03:31:08 <cinimod> Clearly I would like to read them
03:31:34 <cinimod> So I would like -.1 to parse
03:32:05 <fizruk> > - .1
03:32:06 <lambdabot>   <hint>:1:3: parse error on input `.'
03:33:27 <cinimod> I am using cassava http://hackage.haskell.org/package/cassava-0.2.2.0
03:33:33 <latermuse> chrisdone: haha
03:33:48 <latermuse> cinimod: just prepend a 0
03:33:54 <cinimod> Indeed
03:34:06 <cinimod> But I don't have to in python or R
03:34:44 <cinimod> latermuse: did you mean preprocess the file and add 0s?
03:35:19 <latermuse> cinimod: well its a hack to do it that way, but would work. you could also stream the numbers and add 0s before using the number
03:35:46 <latermuse> um there is likely an easy way to do it using types, but i dont use floating or fractional numbers very often, so its out of my scope
03:35:46 <cinimod> latermuse: I have streamed the numbers and added 0s
03:36:10 <cinimod> latermuse: seems sub-optimal
03:36:57 <latermuse> its sub-optimal to preprocess the file, for sure. but there is likely a way to do it with the type system. i am just unfamiliar with that space at the moment
03:37:20 <cinimod> chrisdone: am I wrong to expect Haskell to parse commonly occurring formats for doubles?
03:37:26 <cinimod> Sorry that sounds a bit loaded
03:37:31 <cinimod> It wasn't meant to be
03:38:11 <Iceland_jack> cinimod: You kind of are, there are a billion choices when deciding on literal syntax and you can't expect them all to transfer between languages
03:38:47 <chrisdone> cinimod: what do you want, efficiency or convenience?
03:39:08 <cinimod> Iceland_jack: I will tell the R and Python communities they are wrong ;-)
03:39:18 <Iceland_jack> cinimod: That is absolutely not what I said
03:39:19 <cinimod> chrisdone: both of course
03:40:35 <vraid> cinimod: and lisp
03:41:02 <cinimod> Iceland_jack: I know - I did put the ;-) at the end - apologies
03:45:50 <otulp> cinimod: I'm with you. Also, why do almost none of these so-called "modern" languages support Common Lisp FORMAT's ~r directive? Using plain english instead of confusing "numbers" is of course the most sensible way to encode data portably. /s :)
03:46:24 <chrisdone> cinimod: does cassava parse ‚Äú0.28‚Äù properly?
03:46:35 <otulp> Note that I put :) at the end, so no offense can be taken. :)
03:46:49 <cinimod> chrisdone: yes
03:46:54 * hackagebot optparse-applicative 0.7.0.1 - Utilities and combinators for parsing command line options  http://hackage.haskell.org/package/optparse-applicative-0.7.0.1 (PaoloCapriotti)
03:47:05 <Iceland_jack> hehe yes, if Common Lispers come to other languages expecting something like FORMAT there will be hell to pay
03:47:08 <chrisdone> cinimod: ok, then we can implement an instance of Double for the format we want
03:48:46 <cinimod> otulp: :-)
03:49:49 <chrisdone> cinimod: hold up a minute
03:50:05 <cinimod> I am trying to demonstrate that Haskell is a good language for doing data analysis
03:50:24 <cinimod> But sadly data comes in all sorts of formats
03:51:11 <cinimod> chrisdone: I have this at the moment: (LaxDouble . read . f . T.unpack) <$> parseField s
03:51:28 <cinimod> LaxDouble is a newtype for Double
03:51:47 <cinimod> Oh where f adds in the missing 0
03:56:01 <fizruk> cinimod, why not make instance FromField LaxDouble where ... ?
03:56:52 <cinimod> fizruk: LaxDouble is an instance
03:56:55 * hackagebot whois 1.0.0 - WHOIS client library.  http://hackage.haskell.org/package/whois-1.0.0 (RickyElrod)
03:57:05 <fizruk> so you can do just (parseField s :: Parser LaxDouble)
03:57:15 <fizruk> cinimod, derived, I suppose?
03:57:51 <cinimod> fizruk: no - I add in the missing 0 and then do a read
03:58:14 <cinimod> fizruk: I have an explicit method
03:58:34 <fizruk> why (LaxDouble . read . f . T.unpack) then?
03:58:48 <cinimod> fizruk: what should I do?
03:59:39 <fizruk> I guess it should be something like instance FromField LaxDouble where parseField = LaxDouble . parseField . addMissingZero
04:01:39 <cinimod> fizruk: so addMissingZero would be ByteString -> ByteString?
04:01:49 <fizruk> yes
04:02:52 <fizruk> I guess you just check if first two symbols are "-." and replace them with "-0."
04:03:10 <cinimod> That is exactly what I am doing
04:04:06 <fizruk> ok, so you if you have FromField instance for LaxDouble, you can do just (parseField s :: Parser LaxDouble)
04:05:17 <cinimod> Indeed - it now forms part of a big record
04:05:46 <cinimod> , latitude         :: Double
04:05:47 <cinimod>      , longitude        :: LaxDouble
04:06:17 <cinimod> And I have a FromRecord instance for my big record
04:06:44 <fizruk> btw, it might be worth making newtypes Longtitude/Latitude and keep values in bounds
04:07:16 <fizruk> or, maybe check if parsed values are in bounds (and raise an error otherwise)
04:08:13 <cinimod> For this particular analysis I am creating a map of London with parking bays overlaying it
04:08:28 <cinimod> So I can see if my data are duff when I do the plotting
04:08:42 <cinimod> But good idea
04:09:55 <cinimod> It's in my notebook for the next time I do this
04:14:20 <cinimod> Thanks everyone for your help
04:14:30 <ocharles> The function `Pipes.lift'ghc: panic! (the 'impossible' happened)
04:14:32 <ocharles> noooooooooooooooooooo
04:14:43 <ocharles> I think this is already fixed in HEAD
04:15:02 <cinimod> I am now about to try and analyse a 1.3G file of parking payments
04:17:08 <lpaste> chrisdone pasted ‚ÄúLDouble for cinimod‚Äù at http://lpaste.net/94417
04:17:29 <chrisdone> cinimod: if keep it in bytestring and use the attoparsec parser it should be more performant
04:18:36 <cinimod> chrisdone: thank you
04:18:43 <chrisdone> cinimod: does that give any speed difference to the string/read version?
04:18:55 <cinimod> chrisdone: I haven't tried yet
04:19:39 <cinimod> chrisdone: I will try this afternoon
04:19:52 <danilo2> Hello! I'm generating Haskell code and I've got a problem. Here is a part of the generated code (all the instances are generated automaticaly by TH). Could somebody please tell me why there is an compilation error, when both lines 42 and 43 are uncommented (but they both work without the other) ? What is causing such error? They are simply meant to print "7" and "hello world".
04:20:15 <danilo2> I know it could be hard to deduce everything from this coee, but every tip is very important to me :)
04:20:20 <danilo2> http://lpaste.net/94418
04:23:33 <Eduard_Munteanu> Have you seen a function like   (Monad m, Monad m', MonadTrans t) => m' a -> t m (t m' a)   for specific 't's such that it copies context (e.g. Reader environment) from t over m to t over m'  ?
04:24:59 <hpc> Eduard_Munteanu: not every monad has the ability to "copy context" like that
04:25:09 <hpc> it's easy for Reader and State with ask/get, but what about WriterT?
04:25:16 <hpc> or ContT?
04:25:19 <Eduard_Munteanu> For example, it would be useful to do stuff like   cloneContext >>= forkIO . runInContext ioAct
04:25:27 <hpc> (ContT might work actually)
04:25:38 <Eduard_Munteanu> hpc: yes, sure, for particular monads.
04:25:45 <Eduard_Munteanu> Erm, transformers.
04:26:02 <hpc> Eduard_Munteanu: the one i find myself wanting a lot is stuff like Maybe a -> MaybeT m a
04:26:26 <Eduard_Munteanu> Hm.
04:26:30 <hpc> perhaps if there was some kind of "instance MonadTransBase MaybeT Maybe where ..."
04:26:55 <Eduard_Munteanu> There's MaybeT :: m (Maybe a) -> MaybeT m a
04:27:10 <hpc> class MonadTransBase t m | t -> m where liftBase :: Monad m' => Monad m a -> t m' a
04:27:24 <hpc> Eduard_Munteanu: yeah...
04:27:59 <hpc> this seems like a helpful thing to have as generic
04:28:04 <hpc> or something
04:28:34 <Eduard_Munteanu> Yeah, I want to forkIO some threads but it's annoying having to re-feed it the context.
04:29:25 <hpc> probably going to have to write it yourself :(
04:29:40 <hpc> "programming would be so easy if i just didn't have to program!" ;)
04:29:45 <Eduard_Munteanu> :P
04:30:26 <Eduard_Munteanu> I could make those part of my Reader context and have them preapplied when the context is created, though.
04:30:42 <elliott> this kind of thing is what monad-control tries to do (not so well)
04:30:44 <Eduard_Munteanu> Then it's just a matter of let-binding the runReader and applying it on multiple things.
04:30:45 <chrisdone> that's definitely what monadbase/control are for. but transformers‚Ä¶ um
04:31:25 <Eduard_Munteanu> (it breaks if I 'local' the env though, but probably not much of an issue)
04:31:32 <BlimblomHuhu> Is there any socket API for Haskell that provide recv/send function with MSG_* options? I always assumed that haskell/network support this until I found out that it does not.. Now I dont know what to do.. Someone with similar expierence?
04:31:39 <chrisdone> Eduard_Munteanu: if you can fit it into base/control then you can import from lifted-base Control.Concurrent.Lifted and just use 'fork' instead of forkIO
04:32:04 <Eduard_Munteanu> Oh, hm, I should look at that.
04:32:22 <Eduard_Munteanu> BTW, are there any MonadIO-polymorphic redefinitions of IO functions?
04:32:46 <chrisdone> i would like such a wrapper, too
04:33:22 <danilo2> Hello :) Could somebody look please at this 2 lines of code and tell me why they can cause such error, that each of them works but together they do not compile? http://lpaste.net/94422
04:34:24 <chrisdone> danilo2: (Proxy :: Proxy "add") -- you're using singletons?
04:35:29 <chrisdone> anyway, something like that usually comes from a local let binding that isn't explicitly declared to be polymorphic
04:35:48 <alexander__b> I have three classes. ScreenElement, Entity and Paddle. Paddle is an instance of Entity -- instance Entity Padle where... -- how do I make Entity a ScreenElement? if you get what I mean
04:35:53 <Eduard_Munteanu> danilo2: seems like you're breaking the fundep, i.e. given the dep x -> y, you're declaring multiple instances x y, x y' etc. for same x.
04:36:22 <chrisdone> actually get2 is that binding, i expect
04:36:28 <chrisdone> danilo2: what is the type of get2?
04:36:29 <Eduard_Munteanu> alexander__b: Paddle is a type there
04:36:41 <alexander__b> Eduard_Munteanu: right now I have this http://lpaste.net/4664048889605652480
04:36:45 <lpaste> ghorn pasted ‚Äúphantom functor type checking‚Äù at http://lpaste.net/94424
04:36:50 <danilo2> chrisdone: something like that. This is only a type - a replacement for standard typeclasses. (if you want to see a broader context, please look here) - I'm sorry that thuis code snippets could be a little hard to read, but it is generated code,. I've tried hard to clean it but it could still be not easy to dfollow: http://lpaste.net/94418
04:37:04 * hackagebot hakyll 4.4.1.1 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.4.1.1 (JasperVanDerJeugt)
04:37:07 <alexander__b> so do I need to then do entity instance ScreenElement Entity Paddle where ... in Paddle.hs?
04:37:29 <alexander__b> sorry, just -- instance ScreenElement Entity Paddle
04:37:30 <ghorn> is there anything fundamentally wrong with using * -> * in phantom types? (see above link)
04:37:42 <danilo2> Eduard_Munteanu: No, I'm not breaking it. If I break them then commenting one line will nto make the other work. But each of these lines works, but they do not work together.
04:38:18 <chrisdone> danilo2: maybe _v_49 is the issue
04:38:25 <donri> ghorn: i imagine it infers by default as *; may need PolyKinds and maybe KindSignatures
04:38:27 <Eduard_Munteanu> alexander__b: I'm not sure I get it... do you have 'instance Entity Paddle' and you want 'Entity' to be a subclass of 'ScreenElement'?
04:38:36 <elliott> danilo2: it would help to specify what "both lines" means
04:38:49 <elliott> are they being used as part of the same do block or whatever? what is the type signature on the definition of that do block? etc.
04:38:51 <chrisdone> class Get0 m f |  m -> f where get0 :: m -> f
04:38:51 <chrisdone> class Get2 m f |  m -> f where get2 :: m -> f
04:38:51 <chrisdone>      print =<< get2 (member (Proxy :: Proxy "add") (get0 _v_49)) ‚Üê
04:38:51 <chrisdone>      print =<< get2 (member (Proxy :: Proxy "add") (get0 _v_49)) ‚Üê
04:39:07 <ghorn> donri: adding -XPolyKinds gets it to typecheck, thanks!
04:39:14 <donri> magic!
04:39:24 <danilo2> chrisdone, elliott: Ok so _v_49 is in this example always (Pure Main). elliott: you're ight, I'll write it in the code snippet brb
04:39:29 <alexander__b> Eduard_Munteanu: yes, exactly! I have http://lpaste.net/1908662240614023168 but now I want to move "move" and "render" to a class ScreenElement, and make Entity be a ScreenElement.
04:39:46 <Eduard_Munteanu> danilo2: I mean what happens is it's trying to unify y with y' in something like x -> y. Might be just a type error somewhere.
04:40:51 <chrisdone> i always forget which way round functional dependencies work, i have to look it up every time
04:41:03 <chrisdone> m -> f  -- m uniquely determines f,  or f uniquely determines m?
04:41:06 <hpc> chrisdone: this -> determines these
04:41:10 <Eduard_Munteanu> alexander__b: then you just want a superclass constraint in Entity's definition... class (ScreenElement a) => Entity a where <define Entity>
04:41:30 <hpc> chrisdone: in a (one -> to many) relationship
04:41:37 <alexander__b> Eduard_Munteanu: ohhh that's nice. thanks!
04:41:39 <chrisdone> hpc: then get0 _v_49 on both lines probably violates it
04:41:46 <chrisdone> because class Get0 m f |  m -> f where get0 :: m -> f
04:42:13 <chrisdone> hence the error Couldn't match type `Int' with `String'
04:42:13 <chrisdone>     When using functional dependencies to combine ‚Ä¶
04:42:18 <alexander__b> Eduard_Munteanu: so I don't need to specify the move and render inside the "where"?
04:42:33 <hpc> chrisdone: that's the error you would get with that, yeah
04:42:41 <chrisdone>  Get2 m0 (Pure Int -> Pure Int -> IO a1),  ‚Ä¶
04:42:41 <chrisdone>       Get2 m0 (Pure String -> Pure String -> IO a1), ‚Ä¶
04:42:52 <chrisdone> ^ the m0 is the same, but what is determined isn't. hence: error
04:42:57 <Eduard_Munteanu> alexander__b: you'll have to move that to ScreenElement, both the declaration and instance definition.
04:43:18 <alexander__b> Eduard_Munteanu: I meant whether I need move and render in the instance definition of Entity
04:43:34 <Eduard_Munteanu> alexander__b: then you'll first have to make Paddle an instance of ScreenElement, then make it an instance of Entity.
04:43:48 <Eduard_Munteanu> alexander__b: no, that would be an error
04:44:04 <alexander__b> Eduard_Munteanu: OK so how do I make Paddle an entity of both?
04:44:14 <Eduard_Munteanu> alexander__b: if those belong to ScreenElement, then that's where they have to be defined.
04:44:20 <Eduard_Munteanu> alexander__b: yes
04:44:21 <danilo2> chrisdone, elliott, Eduard_Munteanu: I've written some clarifications here  http://lpaste.net/94422
04:45:13 <danilo2> Eduard_Munteanu: I hope it is a type error somwhere and not a logical error in the code generator, but still I'm trying to solve it for over 2 days without success :/
04:45:31 <alexander__b> Eduard_Munteanu: I tried just doing instance ScreenElement Entity Paddle where [...], but then I get "foo is not a (visible) method of class ScreenElement" on each of the Entity functions that Paddle implements
04:45:51 <alexander__b> Eduard_Munteanu: so I guess I need to instance Entity Paddle where... and then instance ScreenElement Paddle where...
04:45:51 <danilo2> Eduard_Munteanu: I simply do not know, what can cause this error. I know it tries to see y -> y', but I do not know where it comes from
04:46:03 <Eduard_Munteanu> danilo2: if you have a fundep saying your monad uniquely defines another type and you're calling get* at the same monad with different types, then that's the problem.
04:46:31 <Eduard_Munteanu> alexander__b: logically the other way around
04:46:36 <alexander__b> Eduard_Munteanu: true
04:47:01 <Eduard_Munteanu> alexander__b: to be able to make Paddle an instance of Entity, it first has to be an instance of ScreenElement because the latter is a superclass for Entity.
04:47:09 <alexander__b> I see
04:47:35 <Eduard_Munteanu> danilo2: remember (>>=) can't change the monad
04:47:56 <alexander__b> Eduard_Munteanu: right now I have http://lpaste.net/2193455328668942336 but this gives me `render' is not a (visible) method of class `Entity' and same for move
04:47:59 <danilo2> Eduard_Munteanu: Ok, (I think) this is eactly what is happening, but look, I'm talking that this monad (m) defines uniquely a function of type (something like) "a -> a -> a", (the add function is defined as (add a b = a.add b)), so why it is infering the types of int and string there?
04:48:20 <alexander__b> vim/ghc-mod doesn't highlight any error, but cabal spits out those errors
04:48:33 <alexander__b> also, of course, I have class (ScreenElement a) => Entity a where
04:49:27 <chrisdone> danilo2: did you try a trivial test-case to reproduce the code? no TH, no special code?
04:49:44 <Eduard_Munteanu> alexander__b: did you move 'move' and 'render' to ScreenElement?
04:49:46 <danilo2> Eduard_Munteanu: Ehhh :( But look - each of these lines work, because it simply should call a function of type (a->a->a), so why it is still trying to infer some precise types? I know I do not understand where it is coming form and I do not compeltely understand what you're suggesting
04:50:01 <alexander__b> class ScreenElement a where
04:50:04 <alexander__b>   move   ::  a -> Float -> a
04:50:06 <alexander__b>   render ::  a -> Picture
04:50:07 <alexander__b> Eduard_Munteanu: yes, ^
04:50:34 <Eduard_Munteanu> danilo2: because you promised for any 'm', there's a unique type involved in your function.
04:51:01 <Eduard_Munteanu> danilo2: do you have m -> a as a fundep.
04:51:12 <Eduard_Munteanu> s/\./?/
04:51:13 <danilo2> chrisdone: I've tried no TH code (I simply copied the generated code) - that are some instances (like these in the code I put here). And I'm trying right now to create "minimal working example". I think this would be the best way, but it will take time. But after I create it I'll post it here again maybe?
04:51:36 <danilo2> Eduard_Munteanu: yes I've got fundep m -> a
04:51:57 <chrisdone> danilo2: yeah. a trivial 10 liner demonstrating the problem that we can paste in a file and compile is obviously much easier
04:52:06 <Eduard_Munteanu> danilo2: and is 'a' Int in one case and String in the other?
04:52:09 <danilo2> Eduard_Munteanu: hmm, hmm , hmm ok I see the point with "foreach m". Not cleary yety, but maybe there is a problem
04:52:17 <danilo2> Eduard_Munteanu: but can we somehow "fix" it ?
04:52:36 <Eduard_Munteanu> danilo2: remove the fundep, if you don't need it. :)
04:53:34 <danilo2> Eduard_Munteanu: I nneed the funcdep. Look, it SHOULD behave like an OO language. So the fundep is used to IDENTIFY the function based on a "class <- this word is used from imperative world". So If I write a.add I'm using funcdep to determine "which" add we're talking about
04:53:34 <Eduard_Munteanu> danilo2: why is it there? You clearly want multiple 'a's for a given 'm'.
04:54:50 <danilo2> Eduard_Munteanu: Is it clear now what I'm trying to do ?
04:55:54 <Eduard_Munteanu> danilo2: mm, I'm unsure you need it. If you're getting ambiguous type errors, it's because you're not fixing the types.
04:56:13 <Eduard_Munteanu> danilo2: in any case, why 'm' on the lhs of '->'?
04:57:36 <danilo2> Eduard_Munteanu: Basically I've got: class Member (name :: Symbol) cls func | name cls -> func where member :: proxy name -> cls -> func
04:57:52 <Eduard_Munteanu> Hm, I see.
04:58:13 <danilo2> Eduard_Munteanu: and "class GetX m f |  m -> f where getX :: m -> f" (where X) is the number of arguments provided to a function (because functions can have default args)
04:59:00 <danilo2> Eduard_Munteanu: Would you be so nice and look at a minimnal working example if I prepare it ?
04:59:49 <Eduard_Munteanu> danilo2: yeah... but I think the problem is you're using the same 'm' for different f's, which is precisely what 'm -> f' promises you will *not* do. :)
05:00:48 <danilo2> Eduard_Munteanu: Ok, but if it is the real problem, can we make it working? I want to simulate OO function caloling mechanism with default arguments here.
05:00:50 <Eduard_Munteanu> danilo2: is 'm' a monad there?
05:02:05 <Eduard_Munteanu> danilo2: mm... I think you might have to make a tuple to define all the different types, or use a heterogenous list.
05:02:37 <danilo2> Eduard_Munteanu: no, because I think we are talking about fundeps in "class Get2 m f |  m -> f where get2 :: m -> f", where m is simply an newtype wrapping "self" or "this" (imperative world) - something like "newtype Main_add = ..."
05:02:49 <Eduard_Munteanu> danilo2: because you want something like m -> (a, b, c ...) where all those define the types of your environment.
05:03:51 <danilo2> Eduard_Munteanu: If I understand correctly it is impossible, because user can define own types. But "m" is this newtype wrapping "this" object, so such newtype definition is generated "per class declaration"
05:04:47 <Eduard_Munteanu> danilo2: the issue is get2 is a projection and you're promising the result of the projection is the same, which is false. You want to promise 'm' uniquely defines all projections.
05:05:46 <danilo2> Eduard_Munteanu: Yes, it seems to be it. How can I do it ? It looks like simply deleting the fundep, am I right? But it will broke something else here (I'm checking it)
05:07:09 <danilo2> Eduard_Munteanu: yeah, without the fundep it does not work, because the type inferencer does not know what does "get2 ..." mean. (Could not deduce (Get2 m (Pure Int -> Pure Int -> IO a0)))
05:07:24 <alexander__b> Eduard_Munteanu: I figured it out. I was being silly. the error was of course from the *other* Entity I have, not the one I fixed.
05:07:42 <danilo2> Eduard_Munteanu: But can we simply say that such type "exist" but not for ALL types?
05:07:46 <semithin`> good morning everyone
05:09:48 <Eduard_Munteanu> danilo2: a simple one conceptually is to make  get2 :: m -> FieldsOf m   where FieldsOf is an associated type synonym that maps 'm' to a big tuple, then you can project it out some other way.
05:10:16 <danilo2> Eduard_Munteanu: By the way, the fundep is true, but not for types like Int and String. See, this fundep should be handled like that - if I use get2 and the first arg has type of "Main_add", the second is a function "a->a->a" (and not Int->Int->Int) or String. This would work perfectly
05:11:41 <danilo2> Eduard_Munteanu: What such tuple should containt? get2 should simply take 3 arguments (the newtype wrapper and 2 args to a function, which should be called)
05:11:48 <Eduard_Munteanu> danilo2: or you can make wrappers for each 'f' such that you never have two fields with the same type, then you can make smarter projections.
05:13:23 <Eduard_Munteanu> danilo2: class Get2 m f where get2 :: m -> f  would work if you had newtypes for each unique "thing", rather than reuse Int, String ...
05:14:19 <Eduard_Munteanu> danilo2: I meant the tuple will give you all projections, not just one thing
05:14:58 <Eduard_Munteanu> Assuming you can promise never to have the exact same fields for another class.
05:16:23 <danilo2> Eduard_Munteanu: Hmm I think I've got unique "things" - I'm generating a newtypewrapper for each function in each class. So this wrappers are like "Vector_add". And each wrapper "defines" only one unique function. See. In the example the get2 was poiunting to a UNIQUE function processing "a->a->a", so we can tnen
05:16:45 <danilo2> call it with Ints or strings, but haskell still tried to match the Int and String types.
05:16:50 <Eduard_Munteanu> danilo2: consider newtype Year = Year Int, newtype Month = Month Int etc. and the class without the fundep. Then you also get names for fields without singleton types.
05:17:13 <danilo2> Eduard_Munteanu: I think I'll make the minimum example and If I'll not solve It I would be very thnakful If I could then show it to you and ask you more :)
05:17:48 <Eduard_Munteanu> danilo2: mm, if 'a' somehow got tied to your 'f', then that has to be unique too.
05:19:17 <danilo2> Eduard_Munteanu: Ok, I'll try to figure it out Thank you for al lthe tips. I'll hope I'll make an "small" sample code if it would still not work :)
05:19:31 <Eduard_Munteanu> Alright, have fun. :D
05:21:17 <BlimblomHuhu> anyone familiar with network programming with Haskell?
05:21:34 <simpson> BlimblomHuhu: Becoming more familiar by the day. What's up?
05:21:51 <Eduard_Munteanu> BlimblomHuhu: possibly but they like direct questions, instead of polls. :P
05:22:48 <BlimblomHuhu> Im using network socket API. But they dont support MSG_* options on send/recv function.. is there any workaround?
05:23:21 <BlimblomHuhu> those option are really important. I dont understand why they are not implemented...
05:24:06 <simpson> BlimblomHuhu: Which flags did you want to seT?
05:24:14 <BlimblomHuhu> I need to do recvFrom with MSG_PEEK
05:24:43 <merijn> BlimblomHuhu: What does MSG_PEEK do?
05:25:14 <Eduard_Munteanu> Look at a packet without consuming it, IIRC.
05:25:18 <simpson> merijn: It keeps the internal pointer on the stream from advancing.
05:25:27 <simpson> So a subsequent recv() will see the same data again.
05:26:05 <simpson> BlimblomHuhu: This particular flag is not very important. Why can't you structure your program so that it internally buffers that information?
05:26:21 <merijn> BlimblomHuhu: I've never heard of this option, are you sure it's portable?
05:26:34 <alexander__b> can I name modules whatever I want?
05:26:41 <merijn> What C function takes MSG_PEEK as argument?
05:26:53 <Eduard_Munteanu> setsockopt()?
05:26:55 <BlimblomHuhu> recvFrom for instance
05:26:57 <simpson> merijn: recv() takes it as a flag.
05:26:58 <merijn> alexander__b: Anything that starts with a capital letter, matches the file name and is a valid identifier
05:27:28 <Eduard_Munteanu> Actually it's probably a recv thing.
05:27:36 <merijn> Ah, yeah, you're right
05:27:37 * Eduard_Munteanu late
05:27:47 <alexander__b> I have a Paddle that's an instance of ScreenElement and Entity. I have this in a directory, TAngibles. so I want to name it Tangible.Paddle, but when I do import Tangible.Paddle elsewhere, it can't import it
05:27:58 <alexander__b> "Could not find module `Tangible.Paddle'  "
05:28:12 <alexander__b> I have added Tangible.Paddle to myprogram.cabal FTR.
05:28:47 <Eduard_Munteanu> alexander__b: so you have Tangible/Paddle.hs ?
05:28:59 <merijn> Probably there should be a recv' added to Network.Socket that allows this
05:29:05 <alexander__b> Eduard_Munteanu: no. I see that that's what cabal is looking for. I have Tangibles/Paddle.hs.
05:29:24 <BlimblomHuhu> merijn: i dont know, but winsock2 and posix support those MSG_* flags.
05:29:30 <Eduard_Munteanu> alexander__b: no, the module filename must match the module name
05:29:31 <alexander__b> yes, that works. thanks.
05:29:51 <merijn> BlimblomHuhu: Yeah, should be portable enough. The short answer is "this appears to be an unfortunate oversight in the API"
05:30:23 <merijn> BlimblomHuhu: So I would either file a bugreport or submit a patch for it yourself. Fortunately implementing a replacement yourself should be fairly easy, by the looks of the Network.Socket docs
05:31:17 <merijn> (Depending on your haskell comfort level, that is.)
05:32:01 <BlimblomHuhu> There is already an issue, but it seams noone really cares about.. I have never done anything with c-haskel bindings
05:32:58 <BlimblomHuhu> by issue I mean bugreport
05:33:47 <merijn> Ah, looks like it's mostly community maintained. I would wager someone just filed the bug and didn't email the maintainer either. Might be worth dropping an email to libraries@haskell.org
05:34:57 <BlimblomHuhu> merijn: ok i will ask them
05:35:16 <merijn> BlimblomHuhu: If you're comfortable with C, C-haskell bindings are actually really painless (as long as you don't need to access custom structs), I have some simple examples in work-in-progress code on github: https://github.com/merijn/posix-pty/blob/master/System/Posix/Pty.hs#L222-L256
05:35:43 <merijn> BlimblomHuhu: (Note that the capi stuff I use to access CPP macros is only in GHC 7.6 and newer, though)
05:36:15 <prophile> does anyone know of a type similar to Cofree but formulated as T f a = f (a, T f a) rather than (a, f (T f a))?
05:37:27 <BlimblomHuhu> merijn: yes im comfortable with C. I will check your code. Thank you.
05:39:04 <merijn> BlimblomHuhu: The stuff in http://hackage.haskell.org/package/base-4.6.0.1/docs/Foreign.html is also mostly obvious for anyone with a C background
05:41:02 <BlimblomHuhu> ok
05:41:33 <merijn> BlimblomHuhu: Network.Socket has "fdSocket :: Socket -> CInt" which lets you access the underlying fd for direct use with recv, then you just need to do some wrapping/marshalling/error handling to get something safe to use from within Haskell
05:42:26 <merijn> Also important: "threadWaitRead :: Fd -> IO ()" which lets you safely block (i.e. your thread will be unscheduled inside haskell)
05:43:38 <BlimblomHuhu> merijn: yes about error handling, I see that all is done with errnoToIOError. What is IOError, an error or exception?
05:46:05 <lieven_> my program gets Killed on large inputs without any warnings about stack use. What other stuff can be leaking to cause this?
05:46:48 <mr-> Does anyone have nice examples for cofree comonads?
05:46:56 <merijn> BlimblomHuhu: IOError is an exception
05:46:59 <vraid> lieven_: too much memory used perhaps?
05:47:16 <lieven_> vraid: I don't think so. I rearranged it so it should run in constant space
05:47:30 <merijn> BlimblomHuhu: Uncaught they'll kill the thread (and program, if it's the main thread) you can catch/handle them using the stuff in Control.Exception
05:47:54 <geekosaur> "Killed" is the OOM killer sending signal 9, you can't trap it. And this would be heap, not stack
05:48:20 <BlimblomHuhu> merijn: I mean by "all is done" that the network library is using errnoToIOError. They are difficult to catch. I mean the most exception are "failure", i cannot differentiate errors with this network library.
05:48:21 <lieven_> see http://lpaste.net/94427
05:48:26 <geekosaur> (that is, assuming you just get the message "Killed" and a shel lprompt)
05:48:36 <lieven_> geekosaur: indeed.
05:48:50 <t7> hackage2 :O
05:48:56 <Eduard_Munteanu> lieven_: check dmesg as well
05:49:14 <lieven_> geekosaur: lines is a few thousand telco lines. I do an SNMP read for each line, process the result and print that out.
05:49:17 <BlimblomHuhu> merijn: e.g. how cann i differentiate between "message to long" and "shutdown" exception?
05:49:49 <lieven_> geekosaur: shouldn't mapM_ throw away the results?
05:50:14 <Eduard_Munteanu> BlimblomHuhu: match on it, if it's the same exception type
05:51:03 <merijn> BlimblomHuhu: There's some here: http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO-Error.html#v:isEOFError
05:51:04 <BlimblomHuhu> Eduard_Munteanu: they have all the same pattern...
05:51:26 <Eduard_Munteanu> BlimblomHuhu: link?
05:51:33 <Eduard_Munteanu> Nevermind, I'll check the above.
05:51:35 <BlimblomHuhu> merijn: yes EOF is on that I can catch, but all the others... no way.. :-(
05:52:43 <merijn> BlimblomHuhu: You can define your own exception if you wrap something yourself. I'm not too familiar with all the details of what network throws for which error
05:52:49 <alexander__b> BTW -- kind of off-topic, but I just had my first "OH MY GOD HASKELL IS AMAZING" in a while. I had a bunch of functions that I thought that "hey, logically the world should do this, not the entity itself" -- so I cut and paste them and uh... then I was... done. haskell<333.
05:53:36 <danilo2> elliott, Eduard_Munteanu: I've got here a short exampel demonstrating the problem of calling the functions, we've talked about. Could you look at it please and tell me If you;ve got any ideas how can we make it working without loosing performance of final binaries? : http://lpaste.net/94428
05:54:35 <danilo2> chrisdone: I've posted shorter version of the coede here: http://lpaste.net/94428
05:56:57 <Eduard_Munteanu> danilo2: I'd probably use newtypes instead of those singleton types, unless you need to reflect/reify arbitrary strings
05:57:24 <BlimblomHuhu> merijn: yes I can define my own exception by changing the network library... I will check if I have the time or knowledge to do it.. There is so much that must be done..  Is there any plan on GHC unix (System.Posix) on supporting sockets?
05:57:51 <Eduard_Munteanu> danilo2: also since you're providing signatures anyway, so a GADT might do as well.
05:58:25 <Eduard_Munteanu> And/or DataKinds.
05:58:51 <danilo2> Eduard_Munteanu: I do not think newtypes will change anything (I'm making right now exampel with newtypes isntead of sigleton types).
05:59:36 <danilo2> Eduard_Munteanu: I'm sorry, I'm not providing signatures for functions. I've fixed it in the code. The signatures in instancves are generated by TH.
06:00:02 <Eduard_Munteanu> danilo2: I mean in 'f v = do ...'
06:00:48 <merijn> BlimblomHuhu: I think no one had a need for it so far. I think low level bindings to APIs like this tend to be a "just-in-time" thing where they get added once someone asks for it or has the time to provide a patch.
06:02:21 <nstdloop> @paste
06:02:21 <lambdabot> Haskell pastebin: http://lpaste.net/
06:03:02 <danilo2> Eduard_Munteanu: Ok the example now does not use singleton types: http://lpaste.net/94428 . Could you please tell me more how I can use GADs there? I  knowe whqat GADs are, but I've newer used them and I do not cleary see how they could help here :/
06:03:22 <nstdloop> I'm working on a simple bst
06:03:23 <nstdloop> http://lpaste.net/94433
06:03:46 <nstdloop> And I have one lazy method, cpb, that I would like to transform into a strict foldl
06:03:53 <BlimblomHuhu> merijn: yes probably, I will check the links you send me.
06:04:29 <nstdloop> because right now it overflows at [1..5000] where the dumb foldl' insert does 100,000 in just a second or two
06:05:07 <Eduard_Munteanu> danilo2: you can make Member a data/newtype too, if you're generating code. Then store it in a Map String (Member cls) and it's easy to look up.
06:06:18 <danilo2> Eduard_Munteanu: I do not want to use any Map's, because it produces slower final binary. Right now everything could be optimized by ghc, am I right?
06:07:21 <merijn> danilo2: How do you know it will be slower? Have you benchmarked?
06:08:10 <Cale> Slower than what?
06:08:30 <danilo2> merijn: looking for a function definition using string from a map will be slower than optimized by ghc code - always, am I wrong?
06:08:45 <danilo2> merijn: * will be slower than simply calling the function
06:09:03 <Eduard_Munteanu> danilo2: for example define a class by   data Class k = Class [k]   and make    data Member :: Class * -> * where projectNil :: 'Member ('Class '[])   projectCons :: f -> Member ('Class fs) -> Member ('Class (f ': fs))
06:09:05 <merijn> danilo2: The question is, does that matter?
06:09:16 <Cale> Well, that's quite likely. Of course, it's also quite a different thing entirely.
06:09:27 <nstdloop> Anyone
06:09:29 <nstdloop> ?
06:09:47 <merijn> danilo2: Also, have you looked at IntMap? It has far better complexity than Map (assuming you can convert your keys to Int somehow)
06:09:47 <danilo2> merijn: Yes it does - I really want the code to be as fast as possible. Really, relly, really :)))
06:09:49 <Cale> nstdloop: I'll have a look
06:10:11 <nstdloop> Thanks. cpb is what is causing the slowdown/memory overflow
06:10:13 <Eduard_Munteanu> danilo2: AFAICT you're just generating code, no? Or interpreting stuff?
06:10:15 <nstdloop> as far as I can tell
06:10:45 <danilo2> merijn: But theoretically it can be optimized in compile time. If I know the type of "a" variable and each type has got only ONE associated function by given name, than we should be able to optimize it without using any Map's
06:10:51 <Sagi> if I find myself repeatedly writing functions of type  :: database -> queryparam -> result, where the database is not changing throughout my code, should I start using the Reader monad of some other trick to avoid manually threading the 'database'?
06:11:03 <Sagi> s/of/or/
06:11:04 <danilo2> Eduard_Munteanu: generating codde. No interpretation is ninvolved here
06:11:44 <Eduard_Munteanu> danilo2: then what do you want to run fast, the generated code or the code generator? :)
06:11:48 <Eduard_Munteanu> Sagi: yeah.
06:11:49 <Sagi> somehow it feels nice if I were ablet to 'just get the database' where I need it :-)
06:12:57 <danilo2> Eduard_Munteanu: Of course the binary outputed from the generated code. Ahhhhh I'm sorry! I was thinking that you;ve told to use the Map's in final (generated) code, not as a solution to lookup for names in generator! My bad
06:13:03 <Sagi> okay, on to refresh my understanding of the Reader monad then :-)
06:13:28 <Eduard_Munteanu> Sagi: and make wrapper functions for database queries like  withDB :: (MonadReader Database m, MonadIO m) => (Database -> DB a) -> m a
06:13:41 <FreakyPe1guin> Hey guys. Could someone tell me what "| m -> w" means in "class (Monoid w, Monad m) => MonadWriter w m | m -> w where ..."?
06:13:46 <danilo2> merijn: I'm sorry  - I was thniking you're talking not about the "genration" but about the generated code. Idurign generation I can of course handle the names in a map
06:13:47 <Cale> nstdloop: I'm sure the fact that it's quadratic time isn't helping. What's the goal of this?
06:13:47 <Eduard_Munteanu> Oh, that might be too complex if you're not comfortable with it.
06:13:51 <merijn> Sagi: Basically, my advice is to just try it and see how well it works out. It too me a bunch of trial and error approaches to figure out what works well for reader and what doesn't
06:14:16 <nstdloop> Cale: to construct a balanced binary tree from a list.
06:14:18 <merijn> FreakyPe1guin: It's a FunctionalDependency, it means that there can only be 1 m for every w
06:14:29 <nstdloop> ctree just constructs a tree by inserting in order
06:14:45 <nstdloop> ctreePB should insert so that the tree is balanced at the end
06:14:48 <danilo2> Eduard_Munteanu: Coudl you please tell me how this "Class" definitoon provided by you works? And how it solves the problem ?
06:14:50 <FreakyPe1guin> merijn: Thanks :)
06:14:53 <Eduard_Munteanu> FreakyPe1guin: in the case of Monad* classes, 'm' already incorporates the 'w', since m :: * -> *
06:14:59 <merijn> FreakyPe1guin: i.e. "MonadWriter Int someM" means that there can't be "MonadWriter Double someM"
06:15:28 <Sagi> merijn: basically I just wrap the type of the function 'needing' the database in Reader, right? And the others get lifted whn required.
06:15:42 <merijn> FreakyPe1guin: There's some articles explaining more if you google for "haskell functional dependency" or "haskell fundep"
06:15:52 <merijn> Sagi: Yeah
06:16:10 <Sagi> so query :: database -> queryparam  -> result
06:16:10 <Eduard_Munteanu> danilo2: it requires DataKinds. It defines a kind Class *, whose inhabitant is a type Class parametrized by a list of the types of the fields.
06:16:10 <FreakyPe1guin> merijn: Yeah I'm already looking into those, I just needed the keyword to google. Thanks. ;-)
06:16:14 <Sagi> pff
06:16:24 <Cale> nstdloop: I suppose the usual approaches to keeping trees balanced all involve somehow keeping track of some amount of information about the sizes of subtrees.
06:16:29 <Sagi> so query :: database -> queryparam  -> result would become query :: Reader (queryparam -> result)
06:16:51 <Eduard_Munteanu> danilo2: now if you're generating code, you can use that GADT instead of typeclasses since you can easily do "instance resolution" manually.
06:16:52 <Sagi> oh, Reader probably takes params itself
06:16:58 <nstdloop> Cale: Ya, this isn't supposed to be a balanced tree implementation - I just wanted a method to construct a not-terrible tree from a sorted list like [1..x]
06:17:41 <Eduard_Munteanu> Sagi: no, it would be something ... ->  ReaderT Database IO result
06:17:46 <nstdloop> Cale: I'm sure the Data.List.delete is not helping, but I'm not sure how else to do it.
06:17:52 <t7> whats a half turn in chess (engines) called again?
06:17:53 <Eduard_Munteanu> Sagi: assuming you do need IO.
06:17:58 <Sagi> I don't
06:18:16 <Eduard_Munteanu> Sagi: well, how are you talking to the DB then? :)
06:18:32 <Sagi> it's not 'a DB'
06:18:42 <Sagi> perhaps I should've chosen a different term
06:18:49 <danilo2> Eduard_Munteanu: Ok, that sounds really interesting. Maybe this question is very very nooby, but how can I use it? (I'll read deeply about GAD's, but right now I dont "feel" them)
06:18:50 <Sagi> e.g. "knowledge base"
06:18:51 <Eduard_Munteanu> danilo2: by manual I mean you can just make a   Map Name Member   and look it up.
06:19:23 <danilo2> Eduard_Munteanu: Ok, generating the code will be no problem - I'm very interested how the FINAL code will look like
06:20:23 <Eduard_Munteanu> danilo2: oh, then there isn't much to say. I thought this was about getting some sort of type safety or nice properties for your generator.
06:21:05 <Eduard_Munteanu> danilo2: you don't need those types at all, you can just represent types and expressions as an AST
06:21:17 <Eduard_Munteanu> Just a tree-like normal data declaration.
06:21:35 <danilo2> Eduard_Munteanu: I think we missunderstand right now eeach other. I'll make a clarification
06:21:59 <Eduard_Munteanu> danilo2: mmm, do you want an EDSL?
06:22:04 <danilo2> Eduard_Munteanu: I've got parser, ast, some passes and code generator implemented. The generation process is (and I hope will) be no rpoblem for me
06:22:42 <danilo2> Eduard_Munteanu: I'm generating Haskell CODE and then compiling it to a binary. The coede I've rpovided (http://lpaste.net/94428) is an handwritten MIMIC of such GENERATED code, which I want to compile
06:23:22 <Eduard_Munteanu> danilo2: oh, then clearly you don't need typeclasses for one thing. Typeclasses are just convenience for programmers. :)
06:23:34 <danilo2> Eduard_Munteanu: The porblem is, this code does not compile because lines 36-37 are somehow "broken" - The question is - how can I fix it , to be able to generate code , which is like "Haskell assembler" code for OO language
06:24:07 <Eduard_Munteanu> danilo2: yes, you want to look at lower-level stuff, not type trickery.
06:25:02 <danilo2> Eduard_Munteanu: Ok, good to know :) Do you have any idea how can I accomplish this task ? I was very long searching for any solution and it seems, you know "the key" to the solution :D
06:25:04 <Eduard_Munteanu> danilo2: if you want to implement OOP classes I suspect you just want to implement a vtable yourself.
06:25:54 <danilo2> Eduard_Munteanu: Why I would have to implement vtable by hand? I can simply use typeclasses etc (look at this code: http://lpaste.net/94428) - it "does everything I need, but it does not work" ;)
06:26:45 <Eduard_Munteanu> danilo2: a vtable might be easier than trying to fit a C++-like typesystem into the Haskell one
06:27:12 <danilo2> Eduard_Munteanu: I'm not trying to create C++ type like system. Just Haskells type system with some OO convention
06:27:19 <Eduard_Munteanu> danilo2: you likely know what functions you need to call, no need for instance resolution
06:27:38 <Eduard_Munteanu> danilo2: especially since it involves dict passing at runtime.
06:27:46 <danilo2> Eduard_Munteanu: the solution in my code is perfect - except it does not work with multiple types (line 36-37) - If we can fix it someghow, it will be perfec
06:28:18 <Cale> nstdloop left
06:28:27 <nstdloop> Cale: sorry I'm back
06:28:28 <Eduard_Munteanu> danilo2: you can fix it if you generate unique newtype wrappers for fields
06:28:32 <nstdloop> internet disconnected
06:28:46 <Cale> ah, okay
06:28:53 <danilo2> Eduard_Munteanu: I do not know what functions I want to call. Look, I've got a function "test x = x.a()", the "a" depends on type of x, which cannot be resolved at compile time (ok it can be, but only in the places where test is USED
06:28:54 <danilo2> )
06:29:01 <Cale> nstdloop: If your goal is just to construct a balanced tree with a range of numbers in it
06:29:11 <Cale> nstdloop: Then it would be easier not to work with a list at all
06:29:30 <nstdloop> How would I do that?
06:30:05 <danilo2> Eduard_Munteanu: I'm generating newtype for EACH field and EACH method of the class - look, the CF_Vector_add is a newtype for a function "add" in Vector "class".
06:30:20 <lpaste> Cale pasted ‚ÄúPerhaps like this‚Äù at http://lpaste.net/94438
06:31:03 <Eduard_Munteanu> danilo2: well then if you know that a given class has a given field, you don't need that fundep
06:31:12 <Cale> nstdloop: That'll generate a tree with all the natural numbers less than n in it.
06:31:43 <Eduard_Munteanu> danilo2: and you can use an existential wrapper to move data around if you need to
06:32:01 <Cale> nstdloop: (which will be reasonably well-balanced)
06:32:08 <Cale> oh, right, fmap
06:33:15 <danilo2> Eduard_Munteanu: I think I need the fundep. Lets consider a function (in a pseudo language, before generation): "test x = x.f()" - I have to get know what is f (it is Vector.f or X.f) and additional I know it is called without arguments, so I need to provide default arguments (if user declared it has default arguments) - so the fundep is needed here?
06:33:17 <Cale> instance Functor Tree where fmap f Nil = Nil; fmap f (Node l x r) = Node (fmap f l) (f x) (fmap f r)
06:33:47 <danilo2> Eduard_Munteanu: what is existential wrapper?
06:34:07 <Eduard_Munteanu> danilo2: existential types, I meant
06:35:35 <Cale> nstdloop: If n is sufficiently large, you might worry a little about the space leak because of sharing. That can be eliminated by inlining the definition of t from the where clause in each case.
06:35:36 <danilo2> Eduard_Munteanu: hm, ok, but am I wrong, that I need this fundep? If I've got a variable "a" and a function nanme "x" I'have to get the REAL "x" function bound to the type of a. so for "a::Vector" I want to get "(pseudocode): Vector.x" function
06:35:40 <Eduard_Munteanu> danilo2: the thing is the fundep doesn't magically solve the "figuring out types at runtime" problem at all. Can you type those things statically at all? (e.g. fields instead of complete types)
06:35:48 <Cale> nstdloop: However, I doubt it'll be a problem.
06:37:09 <danilo2> Eduard_Munteanu: Oh :( I do not think there is any **runtime** type resolution there. Every type should be resolved at compile time. If I can ask you once more to llook at (http://lpaste.net/94428) : if we comment out 36 or 37 - everything works AND types are known in compile time.
06:37:37 * hackagebot bamstats 0.4 - A program to extract various information from BAM alignmnet files.  http://hackage.haskell.org/package/bamstats-0.4 (KetilMalde)
06:37:55 <danilo2> Eduard_Munteanu: (getCF_Vector_add $ member Func_add v) can be resolved (if we know the type of v and we KNOW it when we use the function) to a SIGNGLE functiopn declaration from line 25)
06:39:02 <Eduard_Munteanu> danilo2: does the Member fundep fail?
06:40:25 <Eduard_Munteanu> danilo2: if so, your 'func' should be tied to 'name' and 'cls', it can't be the same type in multiple contexts.
06:40:36 <danilo2> Eduard_Munteanu: If you run this code - weverything works ONLY if you comment out line 36 OR 37. Then the fundep works great. I dfo not know why both lines do not work. Hmm, see the code "(getCF_Vector_add $ member Func_add v)" should give function "a->b->(a,b)" so it SHOULD work with both Ints and Strings
06:41:25 <Eduard_Munteanu> danilo2: well, it won't because you promised  SomeName SomeClass -> Int  and you also have   SomeName SomeClass -> String.
06:41:37 <nstdloop> Cale: That looks good. Thanks
06:41:53 <danilo2> Eduard_Munteanu: ok and can I "promise" only SomeClass -> a ?
06:42:26 <Eduard_Munteanu> danilo2: er, no, because your 'a' is Int and then it's String.
06:43:10 <Eduard_Munteanu> danilo2: you can make 'func' an asstype
06:43:35 <Eduard_Munteanu> Or actually an associated data family.
06:43:44 <danilo2> Eduard_Munteanu: Hmmm, so why iuf we insert before line 36 "let v = con_Vector 0 0 0" it works? It seems that then lines 36 and 37 BOTH are working
06:44:04 <danilo2> Eduard_Munteanu: Ok - I'l read about type families - btw what is "asstype" ?
06:45:14 <danilo2> Eduard_Munteanu: ash asstype is associated data family :) Ok I'll look into it :)
06:46:20 <Eduard_Munteanu> danilo2: class Member name cls where  data Func name cls   member :: name -> cls -> Func name cls    instance Member Func_add ... where data Func Func_add (Pure Vector) where ...
06:52:14 <Eduard_Munteanu> danilo2: actually you can do this... class Member name cls where  type Func name cls  member :: name -> cls -> Func name cls
06:53:31 <Eduard_Munteanu> danilo2: err, you can't, because you'd have to unify different types. You should really handle this more systematically and consider another approach.
06:54:17 <Eduard_Munteanu> danilo2: unless you do stuff like   data CF_Vector_add = forall a. CF_Vector_add { ... :: a }
06:54:42 <Eduard_Munteanu> But print won't be able to inspect it unless you also say (Show a)
06:57:04 <fionnan>  /j ycombinator
07:03:33 <Eduard_Munteanu> Hm, I find myself using apostrophes in var names more and more often, not to define variants like foldl', but as a separator.
07:04:00 <Eduard_Munteanu> It's a lot nicer than '_'.
07:05:01 <Eduard_Munteanu> And more convenient when you reserve camelCase for the global scope.
07:05:50 <Eduard_Munteanu> (camelCase also seems a bit ugly with very short names)
07:05:51 <quchen> As a separator it looks pretty'awkward if you ask me.
07:06:21 <merijn> I have a can'tHappen name somewhere in my code, grammatical correctness \o/
07:06:23 <donri> ListStyleType'DecimalLeadingZero  -- actual constructor in my TH generated CSS lib experiment :P
07:06:29 <Eduard_Munteanu> quchen: I'm using variable names like  m'f  for a Maybe Foo, for example.
07:06:45 <Eduard_Munteanu> mf looks to crowded.
07:06:47 <Eduard_Munteanu> *too
07:06:56 <quchen> Eduard_Munteanu: I think you invented Romanian notation there :-D
07:07:23 <Eduard_Munteanu> Hah, Hungary is around the corner, I guess. :)
07:07:47 <lieven_> Pernian notation :)
07:07:57 <quchen> But yeah, as a Hungarian separator it's not that bad actually.
07:08:36 <Eduard_Munteanu> Well, I want to avoid shadowing names when I unpack a Maybe.
07:09:03 <Eduard_Munteanu> I've used  f'  for that before.
07:09:15 <donri> f'f? :P
07:09:30 <quchen> donri: That's Swedish notation.
07:09:35 <donri> hah
07:09:48 <Eduard_Munteanu> Heh, no... case f' of (Just f) -> ...
07:09:55 <donri> Eduard_Munteanu: why do you need the Maybe at all?
07:09:58 <donri> LambdaCase! :)
07:10:08 <Eduard_Munteanu> donri: to give an example :)
07:10:55 <Eduard_Munteanu> Lambdas in parens with constructor application are a bit ugly though.
07:11:13 <donri> i'm lazy, i tend to just slap a prime at the end of each nesting
07:11:15 <Eduard_Munteanu> (\(Just a) ... -> ...)
07:11:23 <donri> so i start with an f and end up with an f''' xD
07:11:32 <Eduard_Munteanu> Ouch.
07:12:23 <donri> but rarely more than two anyway
07:12:47 <Eduard_Munteanu> I think the idea that using descriptive names is good practice, from C and other languages, still holds. 'a', 'b', 'xs' are fine, but only if you're polymorphic or not using complex types.
07:12:57 <quchen> Lambdas in parens with constructors are pretty unsafe.
07:13:07 <Eduard_Munteanu> Well, that too.
07:13:16 <Eduard_Munteanu> He mentioned LambdaCase though.
07:13:17 <donri> Eduard_Munteanu: sure, but you need it for named variables too :P
07:13:20 <quchen> Hm, my sentence is a bit scrambled up.
07:13:38 <donri> http://hub.darcs.net/dag/snowball/browse/src/NLP/Snowball/IO/Unsafe.hs#92 is an example of mine where i start with word and end up with word''
07:14:04 <Eduard_Munteanu> Type families are awful in some ways.
07:14:24 <Eduard_Munteanu> A rather big offender in that department.
07:14:29 <danilo2> Eduard_Munteanu: Ehh I'll try to find a solution :) Thank you for all your help
07:15:03 <quchen> donri: Unary encoding gets a little awkward sometimes. But in that case you can abuse shadowing.
07:15:41 <donri> sure you can shadow just fine, but it's not a good idea :P
07:15:41 <quchen> m >>= (\a -> n a >>= (\a -> o a))
07:16:32 <quchen> http://lpaste.net/94441
07:16:58 <quchen> I believe that's called the State' Monad.
07:17:19 <donri> what happens if you make it one single let?
07:17:37 <quchen> > let a = 1; a = 2 in a
07:17:38 <lambdabot>   Conflicting definitions for `a'
07:17:39 <lambdabot>  Bound at: <interactive>:1:5
07:17:39 <lambdabot>            <in...
07:17:47 <donri> good :P
07:18:11 <donri> > do let { a = 1; a = 2; }; return a
07:18:12 <lambdabot>   Conflicting definitions for `a'
07:18:12 <lambdabot>  Bound at: <interactive>:1:10
07:18:12 <lambdabot>            <i...
07:19:46 <quchen> It's a shame you can't do "a ^= b ^= a ^= b" because of Haskell pedantism (is that the right word?)
07:20:14 <donri> what is ^=
07:20:22 <quchen> xor
07:20:40 <quchen> a ^= b  ==  a = `xor` b
07:20:44 <quchen> a ^= b  ==  a = a `xor` b
07:20:46 <quchen> That way.
07:21:01 <donri> oh
07:21:06 <quchen> Not sure whether it exists in C, but it does in C++.
07:21:07 <donri> i've wanted that for other things
07:21:16 <donri> it exists in python
07:21:20 <donri> at least for some operators
07:21:27 <mauke> ^= is in C
07:21:45 <quchen> It's probably in Lens as well.
07:21:46 <donri> oh the op? i thought you meant the "chaining"
07:21:47 <quchen> :t (^=)
07:21:48 <lambdabot> (Integral e, Num a, MonadState s m) => ASetter' s a -> e -> m ()
07:21:56 <mauke> the chaining is illegal in C and C++
07:22:03 <quchen> Is it? :-(
07:22:15 <mauke> sequence point rule violation
07:22:21 <quchen> Is it illegal and you get away with it?
07:22:32 <mauke> it has undefined behavior so you don't know if you got away with it
07:22:39 <mauke> it has no semantics
07:22:58 <quchen> This is C we're talking about, unsafety is not an argument ;-)
07:23:13 <donri> in particular, i tend to find myself writing stuff like, a <> mempty == mempty <> a == a, for quickcheck
07:23:13 <Eduard_Munteanu> Because (a ^= b) ^= a uses a value for an lhs?
07:23:21 <mauke> Eduard_Munteanu: it's right associative
07:23:22 <Eduard_Munteanu> Er.
07:23:36 <Eduard_Munteanu> mauke: then what's the issue?
07:23:48 <Sagi> @djinn (a->b)->[m a]->[m b]
07:23:49 <lambdabot> Error: Undefined type []
07:23:57 <Eduard_Munteanu> a += a  would work ?
07:24:16 <mauke> Eduard_Munteanu: a ^= b ^= a ^= b modifies a twice without an intervening sequence point
07:24:21 <Sagi> @djinn (a -> b) -> [m a] -> [m b]
07:24:21 <lambdabot> Error: Undefined type []
07:24:31 <Eduard_Munteanu> Hm, I wasn't aware of that issue.
07:25:23 <Eduard_Munteanu> mauke: you mean it has undefined results wrt to how the actual writes occur, even in the presence of 'volatile'? Or it doesn't make sense at all? (not sure why though)
07:25:23 <danilo2> Hi! :) Why in the following code (http://lpaste.net/94442) in line 38 the instance is not matched to the one declared in 32? Doesn't the (~) tell to "match anything" ?
07:26:12 <quchen> danilo2: No, "~" does not mean "match anything". It just delays the matching and changes strictness properties. Look for "irrefutable pattern".
07:26:38 <Eduard_Munteanu> quchen: he's using a type equality
07:26:44 <quchen> Woops.
07:26:57 <danilo2> quchen: Ok, I'm looking into it right now. But if we are delaying the mathcing, then why it is not matched? It should be imo :/
07:27:36 <quchen> danilo2: Sorry, it has nothing to do with irrefutable patterns, I thought you were talking about something else.
07:27:52 <Eduard_Munteanu> danilo2: that is meaningless
07:28:02 <Eduard_Munteanu> danilo2: you're saying a type is equal to a value
07:28:03 <danilo2> quchen: yeah, irrefutable patterns are used b pattern matching - I'm talking about GADTs feature
07:29:06 <danilo2> Eduard_Munteanu: the code i pasted is meaningless? Shouldnt it match the instance and after match try to match "x" ?
07:29:38 <Eduard_Munteanu> danilo2: no, it's equivalent to writing it the RHS of '~' in place of 'x'
07:30:30 <danilo2> Eduard_Munteanu: Oh, ok. So whats the difference btween writing it with (~) and the one in place of x ?
07:30:33 <Eduard_Munteanu> danilo2: secondly, '~' takes types. You meant the data constructor presumably, but it picked up the type constructor.
07:30:46 <Eduard_Munteanu> danilo2: no difference, AFAIK
07:31:49 <danilo2> Eduard_Munteanu: I'm almost sure that couple of days ago someone was talking here that ~ delays match and "x" is handled as if it is a "general" type and after matching to instance it is matched by (~). I could be wrong, but I'm lamost sure of it
07:31:53 <Eduard_Munteanu> danilo2: '~' takes types. Another issue is you're mentioning types in a context, but those types don't occur in the instance head.
07:32:48 <Eduard_Munteanu> I don't think it does anything like that in this case. It might do in other contexts.
07:33:16 <Eduard_Munteanu> If you add it to the class method, for example.
07:35:00 <danilo2> Eduard_Munteanu: ehh, ok :( I'm still looking for ways to use Haskell type system to mimic the oop behaviour, we were talking before :)
07:35:09 <supki_> Eduard_Munteanu: instance x ~ T => C x where  is different from  instance C T where
07:35:57 <supki_> Eduard_Munteanu: the latter instance cannot be used until GHC proves that x ~ T
07:36:04 <supki_> in the former case GHC can just assume that
07:37:32 <danilo2> supki_: So is it possible to make this code working: http://lpaste.net/94442 ? Line 32 declares instance, but it still isnt matched :(
07:37:34 <Eduard_Munteanu> supki_: you mean as far as the instance itself is concerned?
07:38:20 <Eduard_Munteanu> Yeah, I suppose that's reasonable, though it won't help the fundep issue.
07:39:19 <danilo2> Eduard_Munteanu: I think someone told me here (also couple days ago) that (~) could replace every fundep, but again, I can be wrong
07:40:25 <Eduard_Munteanu> danilo2: well the issue is the fundep is wrong, really. I wrongly suggested an associated type synonym above, but that won't work for the same reason the fundep doesn't.
07:41:17 <danilo2> Eduard_Munteanu: Ok, so what would you seggest me to do? How can I mimic oop behaviour using haskell type system and using its inferencer?
07:43:05 <Eduard_Munteanu> danilo2: you need a data family or some other way to tie your func type to name and cls.
07:44:27 <danilo2> Eduard_Munteanu: you mean type family? (or really data family) ? I just started to learn the type families and GADTs to understand them good.
07:44:39 <user123abc> how come hoogle won't search in the vector package?
07:44:44 <user123abc> http://www.haskell.org/hoogle/?hoogle=unsafeFreeze
07:44:48 <user123abc> http://hackage.haskell.org/package/vector-0.10.9.1/docs/Data-Vector.html#v:unsafeFreeze
07:45:27 <Eduard_Munteanu> danilo2: data family, basically a data declaration that can be instantiated for different parameters.
07:45:37 <Eduard_Munteanu> (each instance is a constructor)
07:47:41 <danilo2> Eduard_Munteanu: Ok, thank you :) I'm reading about it :)
07:48:40 <Eduard_Munteanu> danilo2: oh, I didn't look too carefully... your latest paste should work. You're just missing a show instance and perhaps a type signature.
07:49:25 <donri> user123abc: try adding +vector to the search
07:49:27 <Eduard_Munteanu> But really, you just want   instance Member Func_add (Pure Vector) YourNewtypeWrapper
07:49:40 <user123abc> donri, thanks!
07:50:08 <Eduard_Munteanu> danilo2: and you can solve ambiguities by providing a type sig, if needed.
07:51:26 <danilo2> Eduard_Munteanu: I know I can use "instance Member Func_add (Pure Vector) YourNewtypeWrapper" but it does not solve the issue we were talking before (code: http://lpaste.net/94428). Anyway if my last paste (http://lpaste.net/94442) should work, why it isnt? I was sure it will :/
07:56:46 <stolaruk> I would like to try using lenses (lens library)... looks like I'll end up in StateT as a result of using lens. I'm already in a transformer called InputT (ie, InputT IO ()), from the System.Console.Haskeline library. Can someone give me guidance regarding in what order I should stack the transformers?
07:57:26 <stolaruk> This will be my first time stacking more than one transformer
07:58:26 <merijn> stolaruk: It depends on what the transformer does, I'm not familiar with InputT
07:58:42 <merijn> stolaruk: For the "default" transformers lambdabot has an unmtl command
07:58:59 <merijn> @unmtl StateT Int (ReaderT Char IO) ()
07:58:59 <lambdabot> Int -> (ReaderT Char IO) ((), Int)
07:59:10 <merijn> pffft
07:59:28 <stolaruk> merijn: Well it is a library for console IO, with history, so for example user can press up arrow to loop thru command history, like Bash
07:59:28 <merijn> Since when doesn't that fully expand the stack?
08:00:27 <merijn> stolaruk: StateT is just "s -> m (a, s)" so you need to decide whether that should be "s -> InputT IO (a, s)" or something else
08:01:05 <stolaruk> merijn: I am writing a text adventure game and my idea is to put the game state object in the State monad
08:02:04 <merijn> stolaruk: My point is, that it's hard to figure out what the effect of ordering is (if any) if you don't know what InputT does/is
08:02:59 <stolaruk> ok
08:03:36 <stolaruk> I guess I will have to investigate that more
08:04:52 <merijn> stolaruk: It might be that the order doesn't matter in this case
08:06:35 <stolaruk> merijn: Will do more research. I appreciate your help.
08:18:15 <shiona> I have now in my simple calculator three nested liftA's. Is there a neater way?
08:18:35 <merijn> liftA is just fmap
08:18:41 <merijn> :t liftA
08:18:42 <lambdabot> Applicative f => (a -> b) -> f a -> f b
08:18:46 <merijn> :t fmap
08:18:47 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:19:14 <merijn> shiona: Whether it can be done cleaner depends on the exact code, paste an example on lpaste?
08:20:06 <Lethalman> where is map fusion defined? is it hardcoded in ghc?
08:20:17 <flebron> Hi. I have a bunch of .hs files, defining one function each. Is it possible to have GHCi load all of them at once, or do I manually have to join them into a single .hs? If I do it with :load, I get that "main" is defined in multiple files (when it's defined in none of them).
08:21:03 <merijn> flebron: You probably want to turn them into proper modules and then use load
08:21:19 <merijn> flebron: The problem is that files that don't contain a module are assumed to define a main action
08:21:36 <`^_^v> @djinn (a -> b) -> a -> b
08:21:37 <lambdabot> f a = a
08:21:48 <merijn> flebron: Modules on the other hand do not have to define main
08:21:59 <flebron> merijn: The code files are handed in by students as their assignment, this group just handed in one .hs per exercise. I should create a module on each file, then?
08:22:30 <merijn> flebron: Yeah, just add "module Blah where" at the top of each file (make sure the filename matches the module name)
08:22:42 <Lethalman> for example where is this rule defined? http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html
08:22:48 <flebron> :s their files start with numbers. Ugh. OK. Thanks :)
08:22:49 <Lethalman> I can't see it in Data.List or such
08:22:58 <merijn> flebron: And then sent out an email that from now on any students whose files can't be simply imported get their grades docked :)
08:24:11 <merijn> Lethalman: That's because map is not defined in Data.List
08:24:13 <merijn> Lethalman: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Base.html#map
08:24:48 <Lethalman> ooh
08:25:01 <Lethalman> ok awesome
08:25:21 <Sculptor> friday! hi!
08:25:24 <merijn> Lethalman: Use the source link in haddocks ;)
08:26:49 <Lethalman> oh I would have expected map f . map g $ xs = map (f.g) xs
08:27:18 <Lethalman> mh where is it
08:27:31 <user123abc> how can I use the where keyword to intrudoce values that depend on things previously bound in a monad context?
08:28:22 <user123abc> in do notation
08:28:23 <k00mi> user123abc: you can't, use let
08:28:24 <merijn> user123abc: You can't, use "let x = <expr>" syntax
08:28:28 <user123abc> thanks
08:28:34 <user123abc> do I have to use the parentheses with that?
08:28:54 <merijn> i.e. "do { x <- blah; let foo = x + 1; bar foo }"
08:29:30 <user123abc> it's no type that you omit the in?
08:29:32 <user123abc> that's neat
08:29:37 <user123abc> typo
08:29:39 <user123abc> speaking of which
08:30:34 <Lethalman> mh where's the fusion rule map f . map g $ xs = map (f.g) xs
08:30:38 <Lethalman> just curious
08:30:41 <merijn> user123abc: "let x = y in z" is an expression, "let foo = bar" is syntactic sugar in do notation
08:31:15 <user123abc> oh, I see
08:43:03 <adinapoli> guys, do you know if http-conduit supports url in this form? (look at req' host). https://gist.github.com/adinapoli/7043319 I'm getting an InternalIOException getAddrInfo, which is typical of when the host was rejected
08:49:00 <zebr> which versions of GHC allow +RTS -xc stack traces?
08:53:12 <f-a> hello channel. I sent a bug report to a package maintainer (the package is: haste) and he replied back writing "Do you have some setting to cause GHC to use LLVM for code generation by default?" <-- how do I check this?
08:55:00 <enthropy> f-a: maybe you pass in -fasm which should override any default -fllvm?
08:57:29 <f-a> enthropy: I don't pass anything to ghc. I wonder if my architecture (armhf) plays tricks on me.
08:57:42 <f-a> *any flag (apart from the occasional -O)
08:58:54 <enthropy> well I'm saying you can request a different code generator
09:02:30 <f-a> mhh, I see enthropy. Thanks for the tip. http://packages.debian.org/sid/ghc <-- probably this means I am screwed.
09:06:10 <trotha01> I'm very new to Haskell and QuickCheck. Are there any good resources with examples of using coarbitrary to test functions that take in functions as arguments?
09:09:17 <sclv_> preflex: seen acowley
09:09:17 <preflex>  acowley was last seen on #haskell 1 day, 14 hours, 49 minutes and 8 seconds ago, saying: I wish I had a clown suit
09:20:05 <monochrom> <3 haskell
09:22:42 * hackagebot polysoup 0.2.0 - Online XML parsing with polyparse and tagsoup  http://hackage.haskell.org/package/polysoup-0.2.0 (JakubWaszczuk)
09:23:08 <Eduard_Munteanu> Is hPutStr h "" supposed to be a no-op?
09:26:15 <prophile>  /w 12
09:31:29 <gauthier_> by chance, any f# practitioner here? what would be equivalent of "let a = (==) 1" in f#?
09:34:56 <fryguybob> gauthier_: Are you asking how to write that in Haskell or F#?
09:35:08 <bentnib> gauthier_: Dunno about F#, but in OCaml you can write let a = (=) 1, I guess it is the same in F#
09:35:19 <gauthier_> fryguybob: sorry :) I'm looking for f# expression
09:36:19 <gauthier_> bentnib: right: "let a = (=) 1" :) thanks
09:40:55 <osa1> in the paper "memoization in top-down parsing" the author describes a way to memoize functions written in CPS style to prevent non-termination caused by left recursive grammars. can anyone familiar with the idea help me how to do similar thing in Haskell? basically the mutable table structure created for every memoized CPS function is problem.
09:43:25 <lpaste> ghorn pasted ‚Äúwhy is ScopedTypeVariables needed?‚Äù at http://lpaste.net/94449
09:43:51 <ghorn__> i'm running into a use of ScopedTypeVariables that i can't convert to `asTypeOf`, and I don't understand why
09:44:41 <Eduard_Munteanu> ghorn__: ret isn't an 's'
09:45:14 <Eduard_Munteanu> ghorn__: so   n :: s   n = undefined `asTypeOf` ret   doesn't really make sense
09:45:16 <monochrom> ret :: (Int, s)
09:45:40 <ghorn__> oh jeez, that's a bug
09:46:14 <lpaste> ghorn revised ‚Äúwhy is ScopedTypeVariables needed?‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/94449
09:49:07 <osa1> okay, here's a more general question: how to do memoization without using unsafe functions?
09:49:09 <Eduard_Munteanu> ghorn__: Vec xs  can have any 's'. So undefined `asLengthOf` Vec xs has any 's' as well.
09:53:45 <osa1> is there a timing command in ghci?
09:53:56 <zebr> in ghci, how does one 'unbreak' and resume evaluation?
09:54:15 <Eduard_Munteanu> ghorn__: btw, why not do a deeply-indexed Vec? Like  data Vec :: Nat -> * -> * where Nil :: Vec 0 a; Cons :: a -> Vec n a -> Vec (n + 1) a   ?
09:55:12 <ghorn__> I want the performance of using Data.Vector
09:55:29 <ghorn__> the real code is here https://github.com/ghorn/hascm/blob/master/TypeVecs.hs
09:55:35 <Eduard_Munteanu> ghorn__: oh, so it's a length-indexed array
09:55:46 <ghorn__> yes
09:56:00 <Eduard_Munteanu> Yeah, that's alright then.
09:57:05 <ghorn__> do you understand why the type checker accepts it when i do scoped type variables, but not without?
09:58:06 <Swineflu> ls
09:58:09 <Eduard_Munteanu> ghorn__: I wouldn't call it unsafeVec... rather you want an  forall a, exists s. [a] -> Vec s a
09:58:20 <Eduard_Munteanu> Well, assuming my use of 'exists' isn't confusing.
09:58:20 <Swineflu> Is there away i can have more than one "where"
09:58:38 <bentnib> osa1: under certain conditions, you can use arrays and recursion to get pure memoisation
09:58:42 <monochrom> yes, but in what sense? show actual example
09:58:47 <Swineflu> I want to zip someFunc1 and someFunc2 that are both declared by where
09:58:48 <bentnib> osa1: let memo f i = let arr = array (0,i) (map (\i -> (i, f (arr !) i)) [0..i]) in arr ! i
09:58:52 <Swineflu> :t where
09:58:53 <lambdabot> parse error on input `where'
09:59:12 <bentnib> osa1: E.g., memo (\rec x -> if x == 0 then 0 else if x == 1 then 1 else rec (x-1) + rec (x-2)) 8
09:59:19 <bentnib> osa1: is the 8th fibonacci number
10:00:09 <osa1> bentnib: it looks hard to have a general solution like Schemers have (wrapping functions with another function which does memoization -- works for all functions)
10:00:30 <ghorn__> Eduard_Munteanu: the way you write it, it's not a runtime assertion anymore right?
10:01:45 <bentnib> osa1: yeah, you'd need an effect system with masking that knew when certain effects were not visible to callers
10:02:36 <enthropy> ghorn__: noBrainer = case undefined of ret -> (toInt ret, ret)
10:02:45 <pavonia> Swineflu: What do you mean by zip?
10:02:48 * hackagebot GLUtil 0.7.1 - Miscellaneous OpenGL utilities.  http://hackage.haskell.org/package/GLUtil-0.7.1 (AnthonyCowley)
10:02:53 <sajapa> how do I use a file name that I got from a command line argument (?) ( csvFilePath:xs <- getArgs) in one function, and change extension of it (from .csv to .svg) to use in a different function?
10:02:59 <enthropy> that needs no type signatures / scopedtypevariables
10:03:17 <Eduard_Munteanu> ghorn__: yeah, it gives you any Vec with the right length, but which is hidden. If you want to assert, you can define instances to say "this vec has length 10" or using reflected Nats, I think.
10:03:22 <enthropy> because patterns in case expressions are monomorphic, patterns in where/let are generalized
10:03:43 <ghorn__> enthropy: does that compile for you? it doesn't compile for me
10:04:02 <enthropy> it does
10:04:16 <enthropy> what kind of ghc do you have?
10:04:37 <ghorn__> 7.6.3
10:04:56 <enthropy> ok I have 7.6.2 which is pretty much the same thing
10:05:13 <pavonia> sajapa: System.FilePath has functions for modifying file names/paths
10:05:26 <enthropy> ghorn__: did you leave off the type signature completely and have the monomorphism restriction enabled?
10:05:40 <enthropy> (which is the default)
10:05:41 <ghorn__> enthropy: sorry, that does compile for me, i had an error somewhere else
10:05:46 <ghorn__> my bad
10:05:49 <ghorn__> thanks!!!
10:06:23 <enthropy> actually I think I lied about "patterns in case expressions are monomorphic"
10:06:24 <Eduard_Munteanu> ghorn__: more precisely, fromList :: forall a. [a] -> (forall s. Vec s a) or using a data existential wrapper. You can then use a typeclass or something like that to "match" on the hidden 's' if you ever need a specific length.
10:06:56 <enthropy> but the idea is that if you have a  "x -> ... " all occurences of x on the right-hand-side have the same type
10:07:03 <elliott> Eduard_Munteanu: you want exists not forall there
10:08:05 <Eduard_Munteanu> elliott: I do? Isn't that  forall a. exists s. [a] -> Vec s a  ?
10:08:14 <enthropy> > let x = 1 in fromIntegral (x :: Int) + x / x :: Double
10:08:15 <lambdabot>   2.0
10:08:18 <elliott> no
10:10:50 <ghorn__> enthropy: that is a little scary
10:11:27 <staafl> what's the shortest haskell to generate all pairwise products of numbers in 1..10
10:11:29 <staafl> not homework
10:11:30 <Eduard_Munteanu> elliott: data ExistsVec a = forall s. ExistsVec (Vec s a)  and you have a projection  ExistsVec a -> (forall s. Vec s a). So if you make a  forall a. [a] -> ExistsVec a   composing in the projection gives   forall a. [a] -> (forall s. Vec s a), no?
10:12:02 <monochrom> [ x*n | x<-[1..10], n<-[1..10] ]
10:12:16 <ghorn__> > [(x,y) | x <- [1..3], y <- [1..3]]
10:12:18 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
10:12:30 <ghorn__> too slow >_<
10:12:34 <elliott> Eduard_Munteanu: you do not have that projection
10:12:55 <Eduard_Munteanu> Oops, yeah, that'd be a rank-2 field.
10:12:55 <monochrom> if you don't want both 3*4 and 4*3, [ x*n | x<-[1..10], n<-[x..10] ] or something
10:12:57 <elliott> data T = forall a. C ... is not data T = C (forall a. ...)
10:13:10 <elliott> data T = forall a. C ... means C :: forall a. ... -> T
10:13:15 <elliott> so you get T -> (exists a. ...)
10:13:57 <ghorn__> monochrom: or the lazy way: Set.toList . Set.fromList
10:14:05 <staafl> hmm, how about map (*) [1..10] <*>[1..10]
10:14:17 <staafl> or is there anything cleverer
10:14:24 <monochrom> @type map (*) [1..10] <*>[1..10]
10:14:24 <Eduard_Munteanu> elliott: mm, there was a way to translate exists in a data to a naked one using forall, but I'm a bit hazy right now
10:14:25 <lambdabot> (Enum b, Num b) => [b]
10:14:53 <monochrom> that looks good
10:15:01 <elliott> Eduard_Munteanu: (exists a. ...) ~ (forall r. (forall a. ... -> r) -> r)
10:15:05 <monochrom> I do not do clever
10:15:10 <pavonia> :t join (zipWith (*)) [1..3]
10:15:11 <lambdabot> (Enum t, Num t) => [t]
10:15:16 <Eduard_Munteanu> Doh, I forget that.
10:15:31 <monochrom> I only do: so simple it's obviously correct
10:16:09 <staafl> monochrom, it's just an exercise
10:16:14 <Eduard_Munteanu> Yeah, you want 'a' NOT quantified outside that parens if it's existential.
10:16:26 <staafl> pavonia, neat :-)
10:17:34 <Eduard_Munteanu> In retrospect it's sort of obvious mine was just a rank-2 type, and it wasn't even rank-2. (you can move the forall s. back to the forall a.)
10:18:55 <staafl> pavonia, but that's just the squares
10:19:30 <elliott> Eduard_Munteanu: you need a forall in negative position for rank-2
10:19:57 <glguy> > join (liftM2 (*)) [1..3] -- if the goal is to only be usable in IRC
10:19:58 <lambdabot>   [1,2,3,2,4,6,3,6,9]
10:20:12 <Eduard_Munteanu> Yeah.
10:20:52 <pavonia> Aww right, I meant liftM2 :S
10:23:38 <glguy> > (join . (zipWith const =<< iterate =<< zipWith (+))) [1..3]
10:23:39 <lambdabot>   [1,2,3,2,4,6,3,6,9]
10:25:50 <staafl> glguy, whoa
10:26:05 <glguy> That's probably the one you were looking for
10:26:43 <staafl> well, I'm looking to learn something interesting - so yeah
10:27:01 <glguy> just never write that in code you save to an actual file :)
10:27:24 <staafl> upon my honor :D
10:32:51 * hackagebot nerf 0.5.0 - Nerf, the named entity recognition tool based on linear-chain CRFs  http://hackage.haskell.org/package/nerf-0.5.0 (JakubWaszczuk)
10:37:29 <linduxed> ok now that i know how to write tests with it
10:37:38 <linduxed> Hspec + QuickCheck is fucking amazing
10:37:41 <linduxed> it's SOOO nice
10:39:43 <linduxed> speaking of which
10:40:17 <linduxed> i get the impression that the Hspec package isn't particularly well used
10:40:25 <linduxed> as in, most people go with Hunit instead
10:40:51 <donri> hspec uses hunit
10:40:58 <linduxed> is that exclusively due to the fact that it's been around for a longer time?
10:41:17 <linduxed> donri: well yes, i know, but hspec is the sugar that makes it that much nicer
10:41:19 <linduxed> i think
10:41:19 <donri> i wouldn't call hspec unused http://packdeps.haskellers.com/reverse/hspec
10:41:34 <linduxed> or maybe it's just the fact that i write ruby during the day :-P
10:41:51 <linduxed> oh wow!
10:41:57 <linduxed> that changes my perspective
10:42:13 <donri> well HUNit has 417 revdeps http://packdeps.haskellers.com/reverse/HUnit
10:42:22 <donri> but that'll include all the ones from hspec since it depends on HUNit
10:42:25 <linduxed> i just asked some people that i know that code haskell and they all unanimously said that HUnit was what was used
10:43:02 <donri> i think these days people rarely use hunit alone/directly
10:43:09 <donri> usually via something like hspec, test-framework, tasty
10:43:11 <donri> HTF
10:43:25 <sajapa> I'm trying to change a file path extension from a file name I get from the main function  http://lpaste.net/94455 -- (note that i did not come up with the main function but am trying to use it. it is beyond my skill level). I would like to make the csvFilePath have the .svg extension - any help?
10:43:27 <linduxed> well i've only just recently gotten into Haskell testing
10:43:47 <donri> sajapa: try the filepath package
10:43:48 <linduxed> and coming from Rspec, Hspec was a nice way to get going
10:44:01 <linduxed> also made trying out QuickCheck _really_ easy
10:44:10 <sm> I think there's some doubt that hspec's english-like DSL is really worth the trouble
10:44:13 <donri> sajapa: it has a replaceExtension function for one
10:44:28 <sajapa> how do I use it in the d function?
10:44:29 <sm> (in answer to why it's not more widely used)
10:44:35 <sajapa> I don't know how to structure it
10:44:45 <linduxed> sm: there are people who raise that concern in the ruby-community from time to time as well (against Rspec)
10:44:50 <sajapa> :donri ?
10:45:11 <glguy> sajapa, System.FilePath has some helpers: let asSvg fn = takeBaseName fn <.> "svg" in asSvg "example.csv"
10:45:14 <chrisdotcode> where can I get a better understanding of combinators?
10:45:26 <linduxed> they say that the frameworks MiniTest and TestUnit are closer to code, so they're therefore preferrable
10:45:39 <linduxed> sm: atm i'd say i like the readability though
10:45:53 <donri> sajapa: renderSVG (replaceExtension csvFilePath "csv") ...
10:46:29 <donri> uh, "svg"
10:46:44 <sm> I need to try it some time
10:46:46 * glguy missed that function :)
10:47:40 <haasn> > "example.csv" & extension .~ "svg"
10:47:42 <lambdabot>   Not in scope: `extension'
10:47:42 <lambdabot>  Perhaps you meant `extensions' (imported from La...
10:47:47 <Eduard_Munteanu> Can I specify -package as a {-# #-} pragma?
10:47:48 <haasn> @let import System.FilePath.Lens
10:47:49 <lambdabot>  Defined.
10:47:50 <haasn> > "example.csv" & extension .~ "svg"
10:47:52 <lambdabot>   "example.svg"
10:48:15 <donri> Eduard_Munteanu: don't be crazy, use cabal :P
10:48:24 <Eduard_Munteanu> I'm writing myself some tools / scripts and I don't feel like making a whole project.
10:48:27 <Eduard_Munteanu> Hm. :)
10:48:30 <glguy> or without the confusing operators
10:48:30 <glguy> > set extension "svg" "example.csv"
10:48:32 <lambdabot>   "example.svg"
10:48:36 <sajapa> donri: thanks! that worked! :D
10:48:58 <donri> \o/
10:49:00 <haasn> glguy: pft, ‚Äúconfusing‚Äù :(
10:49:14 <haasn> uhm
10:49:24 <donri> Eduard_Munteanu: OPTIONS_GHC anyway, if anything
10:49:36 <haasn> > view extension (set extension "foo.bar" "example.txt")
10:49:38 <lambdabot>   ".bar"
10:49:40 <haasn> ILLEGAL
10:49:45 <haasn> Somebody call the lens police
10:49:57 <donri> :O
10:50:27 <haasn> > view extension "example.txt" -- why does this include the .?
10:50:28 <lambdabot>   ".txt"
10:51:03 <donri> > takeExtension "example.txt"
10:51:04 <lambdabot>   Not in scope: `takeExtension'
10:52:47 <glguy> haasn: because splitExtension "a.b.c" = ("a.b",".c")
10:53:04 <glguy> (not that it necessarily should)
10:54:06 <supki_> > "example.csv" & extension .~ ".svg"
10:54:08 <lambdabot>   "example.svg"
10:54:34 <johnw> > replaceExtension "example.csv" "svg"
10:54:35 <lambdabot>   Not in scope: `replaceExtension'
10:55:13 <glguy> the 'addExtension' function is a bit magical and drops the leading '.' on the provided extension
10:56:35 <donri> > System.FilePath.addExtension "" "svg"
10:56:36 <lambdabot>   Not in scope: `System.FilePath.addExtension'
10:56:36 <lambdabot>  Perhaps you meant `System.Fil...
11:05:59 <maaku> anyone know how hard it would be to add 1-element tuples to GHC?
11:06:25 <prophile> maaku: why would you want them?
11:06:27 <chrisdone> what's a 1-element tuple?
11:07:03 <tac> chrisdone: it's a tuple, like (1,2)... but with no comma and no 2.
11:07:15 <Kinnison> ick
11:07:24 <chrisdone> tac: what's the difference between that and just 1?
11:07:31 <maaku> tac: well you might need the comma to resolve the grouping ambiguity
11:07:33 <maaku> (1,)
11:07:35 <maaku> like python
11:07:47 <tac> chrisdone: It's an isomorphic type. "Essentially the same", but different.
11:07:56 <tac> It plays the same role as a newtype declaration.
11:08:00 <chrisdone> so just a newtype
11:08:01 <chrisdone> i see
11:08:03 <w0rm_x> > let (+) = (+) in 4 + 5
11:08:10 <lambdabot>   mueval-core: Time limit exceeded
11:08:18 <johnw> chrisdone: I think it is the same thing as Identity
11:08:28 <maaku> it's a tuple. it behaves like a tuple
11:08:32 <tac> chrisdone: but it's somewhat of an oddity that haskell supports 2+-ary tuples, and 0-ary tuples (which we call the 'unit' type, denoted ()
11:08:36 <chrisdone> maaku: what behaviour does a tuple have?
11:08:38 <tac> but not unary tuples
11:08:42 <johnw> maaku: how does it "behave like a tuple"?
11:09:02 <chrisdone> i feel like i'm missing some really obvious background that makes 1-ary tuples interesting
11:09:20 <johnw> chrisdone: if you are, I'm totally missing it too
11:09:26 * Kinnison too
11:09:27 <tac> chrisdone: It's just nice to have for completeness..... it's like having a number system without 0
11:09:27 <maaku> e.g, `fst (1,)` would return 1
11:09:35 <maaku> not a compiler error
11:09:40 <johnw> maaku: but the types don't match
11:09:43 <tac> not quite, maaku
11:09:45 <elliott> maaku: but fst (1,2,3) is an error too
11:09:46 <simpson> maaku: fst only works on 2-tuples.
11:09:55 <maaku> yes, ok sorry
11:10:02 <maaku> but i hope you see where i was going?
11:10:08 <johnw> I don't yet
11:10:13 <chrisdone> fst1 :: (a,) -> a?
11:10:17 <tac> It's important to have in your theory
11:10:18 <maaku> polymorphic functions/macros which operate on tuples
11:10:20 <johnw> maybe _1 could be made to work
11:10:22 <tac> But it's not very useful pragmatically
11:10:42 <maaku> i'm actually not sure if haskell can do that, but i'm making a language which compiles to haskell which does
11:10:53 <simpson> Aha.
11:10:55 <maaku> so the lack of a single-tuple is an annoying assymetry
11:10:58 <chrisdone> macros which operate on tuples ‚Üê i can see the use-case in that
11:11:37 <chrisdone> or in ASTs when a Tuple takes a list but you have to check the ==1 case
11:11:58 <chrisdone> oh! there's a use-case
11:12:03 <chrisdone> in postgresql-simple
11:12:11 <chrisdone> it has Only for a 1-ary tuple
11:12:22 <chrisdone> query "select x where i = ?" (Only i)
11:12:32 <maaku> yeah
11:13:26 <chrisdone> yep, i see the utility
11:13:37 <maaku> that's actually the context i was thinking of it
11:13:43 <maaku> the language i'm making is datalog-like
11:13:47 <chrisdone> ahh
11:13:56 <maaku> so a single-tuple result of a query makes sense
11:14:20 <maaku> a lot more sense than a special, asymetrical type used just for that purpose...
11:14:22 <johnw> I still don't get why calling it a tuple makes a difference?
11:14:46 <johnw> if the type is different from every other n-ary tuple, then why is Only not just a good?
11:14:52 <maaku> well i guess i could suitably hide that complexity
11:19:10 <jfischoff> the single tuple in the postgresql-simple if just there to make a base case for the type class induction I think
11:20:07 <chrisdone> jfischoff: yeah, but i suppose if we already _had_ tuples then it would be a (a,b,c) -> (a,b) -> (a,) -> () and no one would think anything of it
11:20:21 <chrisdone> jfischoff: er, if we already had 1-tuples
11:20:54 <chrisdone> so from that perspective the consistency would be nice, even if you can emulate it with a disparate type
11:21:54 <jfischoff> chrisdone: eh
11:22:03 <jfischoff> :)
11:22:36 <chrisdone> this might be the case of the monkeys in the cage with the water =)
11:25:59 <chrisdone> monkeys are put in a cage, with a banana dangling at the top. whenever a monkey reaches for the banana, the monkeys are sprayed with cold water. eventually the monkeys stop trying to get the banana. a new monkey is put in the cage, when he reaches for the banana, the other monkeys prevent him with threatening behaviour. add more new monkeys and take out old monkeys until the cage is filled with monkeys who have never been sprayed but
11:25:59 <chrisdone> know that for some reason we're not supposed to touch the banana
11:26:21 <Clint> i remember that experiment
11:26:30 <chrisdone> they don't know why things are the way they are, but they defend it
11:26:38 <chrisdone> sometimes communities act a bit like that
11:26:46 <jfischoff> is that what is going on?
11:27:03 <chrisdone> possibly!
11:27:11 <maaku> i think so :)
11:27:11 <johnw> some days I feel like a sprayed monkey
11:27:16 <chrisdone> maybe maaku is the new monkey =p
11:27:18 <frx> is there something like takeUntil in prelude?
11:27:32 <chrisdone> (takeWhile . ) . not  ?
11:27:45 <chrisdone> takeWhile (not . p)
11:28:07 <frx> yeah that will work
11:28:14 <chrisdone> there isn't a function named like that in base, afaik
11:30:28 <jfischoff> Asking about the one tuple is like asking about the single argument multiplication operator. You can define something, but why bother calling multiplication anymore?
11:30:51 <jfischoff> s/calling/calling it
11:31:15 <chrisdone> why bother with a single element list? </devil's advocate>
11:31:45 <jfischoff> but a single element list is still a cons cell right a:[]?
11:32:34 <quchen> Identity is the 1-tuple.
11:32:40 <quchen> Identity is useful.
11:32:43 <jfischoff> sure
11:33:00 <jfischoff> but is didn't a product of two types?
11:33:05 <jfischoff> err
11:33:08 <jfischoff> is identity
11:33:46 <chrisdone> no, why?
11:33:48 <quchen> It's the product of () and "a".
11:33:55 <quchen> (Go play elsewhere, ‚ä•!)
11:34:22 <frx> @pl (\x -> x `mod` 7 == 3)
11:34:25 <lambdabot> (3 ==) . (`mod` 7)
11:34:25 <lambdabot> optimization suspended, use @pl-resume to continue.
11:35:33 <jfischoff> except it is not that
11:41:10 <quchen> Not sure what to answer here.
11:44:45 <frx> why doesn't this work? do { x <- [2,5,10]; y <- [8,10,11]; return x*y }
11:44:57 <frx> > do { x <- [2,5,10]; y <- [8,10,11]; return x*y }
11:44:58 <lambdabot>   No instance for (GHC.Show.Show b0)
11:44:58 <lambdabot>    arising from a use of `M808137587.sho...
11:45:23 <simpson> > do { x <- [2,5,10]; y <- [8,10,11]; return x*y } :: [Int]
11:45:24 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Int])
11:45:24 <lambdabot>    arising from the literal `...
11:45:34 <simpson> Oh, derp.
11:45:42 <Eduard_Munteanu> Weird.
11:45:45 <simpson> > do { x <- [2,5,10]; y <- [8,10,11]; return (x*y :: Int) }
11:45:46 <lambdabot>   [16,20,22,40,50,55,80,100,110]
11:45:46 <Eduard_Munteanu> > show [1,2,3]
11:45:48 <lambdabot>   "[1,2,3]"
11:45:50 <chrisdone> return *x*
11:45:53 <chrisdone> er
11:45:55 <chrisdone> return x*x
11:46:01 <chrisdone> dat precedence
11:46:06 <Eduard_Munteanu> Oh, duh.
11:46:10 <frx> ah :)
11:46:32 <simpson> > do { x <- [2,5,10]; y <- [8,10,11]; return (x*y) }
11:46:33 <lambdabot>   [16,20,22,40,50,55,80,100,110]
11:46:40 <simpson> Ah, I guess that MR does work there.
11:46:48 <staafl> is the haskell wikibook any good?
11:47:21 <Eduard_Munteanu> staafl: yes, some topics are pretty well done, if you favor a technical / mathy approach
11:47:26 <merijn> staafl: It varies
11:47:35 <merijn> staafl: Some bits are great, some mediocre
11:47:48 <merijn> staafl: If you're looking for a beginners book, there are better ones
11:48:10 <merijn> (FYI: Those are also freely available online)
11:48:13 <staafl> part great part mediocre sounds pretty good
11:48:24 <staafl> merijn, i judge myself lower intermediate
11:48:37 <staafl> other than LYAH and RWH
11:48:42 <chrisdone> staafl: a first level mage?
11:48:44 <staafl> and "The Gentle"
11:48:47 <merijn> staafl: Ah, so I take it your past LYAH then
11:49:11 <staafl> merijn, more or less
11:49:13 <merijn> staafl: Do you understand the State/Reader/Writer monads?
11:49:21 <staafl> I see he's added some new chapters now
11:49:40 <staafl> merijn, I think so
11:49:58 <monoidal> there are no new chapters of LYAH since a very long time
11:50:25 <staafl> monoidal, I don't remember the zippers one
11:51:24 <staafl> never mind, I guess I should spend more time reading than looking for the best thing to read
11:51:39 <merijn> staafl: You could try implementing the monad instances for those yourself as practice and then play with monad transformers at which point your best bet is probably to practice by writing more and more code (although, if you're interested in more advanced hackery, there's some neat things to investigate)
11:52:02 <staafl> merijn, ok, like what?
11:52:21 <merijn> staafl: what code or what more advanced things? :)
11:52:31 <staafl> the advanced hackery part, i want to take a note
11:52:37 <staafl> in my haskell.txt
11:52:39 <satc> @src replicate
11:52:40 <lambdabot> replicate n x = take n (repeat x)
11:52:53 <merijn> staafl: GADTs and typefamilies are really cool things
11:53:01 * hackagebot optparse-applicative 0.7.0.2 - Utilities and combinators for parsing command line options  http://hackage.haskell.org/package/optparse-applicative-0.7.0.2 (PaoloCapriotti)
11:53:23 <merijn> staafl: The GADT chapter in the wikibook is really good, and for type families I would recommend the original paper, "Fun with Type Functions" it's really accessible
11:53:24 <staafl> merijn, useful cool or complicated cool?
11:54:01 <merijn> staafl: I would say both GADTs and type families are, of themselves, fairly simple. The way you use them tends to be more complicated, though
11:54:33 <S_J> why isnt (=/=) used instead of (/=) ? one char more i guess?
11:54:44 <satc> @src repeat
11:54:44 <lambdabot> repeat x = xs where xs = x : xs
11:54:49 <merijn> staafl: I think they're good things to know exist, even though you will mostly only need them when doing "complicated cool" things. They're occasionally useful for simple things
11:55:03 <merijn> S_J: Historical reasons of copying ML, most likely
11:55:45 <klugez> Or Fortran! :)
11:56:12 <staafl> merijn, noted, thank you for the input :-)
11:56:19 <merijn> staafl: As for practice, as I said, implementing Functor, Applicative and Monad instances for State, Reader and Writer is good intermediate practice
11:56:57 <johnw> I'd suggest doing it for Writer first
11:57:00 <staafl> merijn, yeah, I will do that
11:57:48 <merijn> staafl: Use these datatypes as starting point: "newtype MyState s a = MyState { runState :: s -> (a, s) }", "newtype MyReader r a = MyReader { runReader :: r -> a }" and "newtype MyWriter w a = MyWriter (a, w)"
11:57:55 <johnw> staafl: it may help too to first write 'join' before writing '>>="
11:58:08 <johnw> i tend to think of monads in terms of join, and then translate it to >>= after I understand that
11:58:23 <chrisdone> join writerly
11:58:48 <johnw> so, if writer's type is Monoid w => (w, a), join is: (w, (w, a)) -> (w, a), whose implementation should almost be obvious at that point
11:58:49 <staafl> johnw, interesting
11:59:26 <merijn> staafl: In addition to Functor, Applicative and Monad you'll want to implement "get :: MyState s s", "put :: s -> MyState s ()", "ask :: MyReader r r"
11:59:51 <merijn> staafl: If you get stuck, try manually expanding the types on paper
11:59:53 <Eduard_Munteanu> 'join' might be confusing, IMO. (>>=) is easier to understand in many cases because it's just lifted application.
11:59:57 <staafl> johnw, but join only strips nested monads?
12:00:09 <johnw> staafl: it doesn't strip anything, it merges them
12:00:28 <johnw> so join for writer is join (w1, (w2, a)) = (w1 <> w2, a)
12:01:33 <merijn> staafl: i.e. replace "MyState s a" with the "s -> (a, s)" innards (I kinda assumed you were familiar with record syntax)
12:01:53 <staafl> merijn, yeah, I get it
12:02:02 <staafl> i've actually done it before
12:02:34 <staafl> it was kind of hard to grasp initially
12:03:05 <staafl> anyway, I'm saving this log
12:03:09 <staafl> thanks haskellers
12:03:32 <johnw> we live to haskell :)
12:05:14 <chrisdone> yay my hse now has traversable instances. thanks, mgsloan!
12:06:16 <Lethalman> reading this: https://www.google.it/url?sa=t&rct=j&q=&esrc=s&source=web&cd=15&ved=0CEsQFjAEOAo&url=http%3A%2F%2Fwww.cse.unsw.edu.au%2F~chak%2Fhaskell%2Fgtk%2Fihaskell.ps.gz&ei=PYRhUpabHMaHtAajloH4DQ&usg=AFQjCNH6SBQdChYYJA3zqJUog08xAogcvw&sig2=Lbb_K6zfGKYrZ-liGKpfFw
12:06:26 <chrisdone> Lethalman: ciao amico!
12:06:49 <Lethalman> how can they say: "-- obtain the time series of values as a lazy stream; listenToPort :: Port a -> IO [a]"
12:07:04 <Lethalman> as I know, the resulting [a] can't be a stream
12:07:13 <chrisdone> could be a lazy list?
12:07:14 <Lethalman> chrisdone, ciao!
12:07:23 <Lethalman> chrisdone, but not stream
12:07:25 <johnw> Lethalman: unsafeInterleavedIO?
12:07:31 <Lethalman> johnw, ah
12:08:34 <Lethalman> thought that paper did something revolutionary, in the end it seems a mix of frp and hand written widgets uhm
12:10:33 <chrisdone> Lethalman: di dove sei? il sud? sto cercando per haskellers italiani. =) non ci sono tanti (credo, mi sembra)
12:11:13 <Lethalman> chrisdone, ora sono a Roma, sono ultra beginner in haskell :P sto lavorando full time, ma disponibilissimo a fare part time 2 ore al giorno, full sabato e domenica
12:12:04 <Lethalman> chrisdone, no in italia non c'√® proprio cultura di linguaggi funzionali gi√† a partire dalle universit√†, solo imperativi e logici
12:12:12 <chrisdone> ahaa. anche alfredo di napoli (Roma)
12:12:39 <Lethalman> :)
12:12:43 <chrisdone> b√®, s√¨, ci sono solo java o ‚Ä¶ php
12:13:18 <quchen> chrisdone: That's offensive to say in a Haskell channel.
12:13:39 <Lethalman> :O
12:15:27 <tomejaguar> Is there a way of suppressing "no-warn-unused-binds" on some names only, i.e. not on everything defined in the module?
12:15:49 <monoidal> tomejaguar: start the names with _?
12:15:57 <Clint> haha/win 23
12:16:00 <Clint> dammit
12:16:20 <tomejaguar> monoidal: These are lenses derived with makeLenses
12:16:26 <tomejaguar> so that would be a double underscore!
12:16:29 <tomejaguar> but I guess I could do ...
12:16:50 <lonecub2131> :topic
12:16:56 <tomejaguar> In fact this is a general problem with makeLenses
12:17:37 <tomejaguar> Maybe I'll just use makeLensesFor again
12:26:44 <tomejaguar> Hmm this approach is not scalable.
12:27:06 <tomejaguar> Definitely need some way to selectively turn off warning about unused binds
12:27:22 <johnw> i love RankNTypes
12:28:12 <chrisdone> johnw: you could say you‚Ä¶ (‚åê‚ñ†_‚ñ†) rank them highly
12:28:20 <johnw> indeed I do!
12:31:44 <Rarrikins> How do I get rid of any nonerror messages (like "Loading package...") when compiling?
12:32:02 <chrisdone> possibly with the verbosity settings
12:32:04 <chrisdone> try -v0
12:35:16 <Rarrikins> chrisdone: That works. Thanks
12:35:59 <frx> how to do this without list comprehensions or do block?
12:36:30 <frx> > [(x,y) | x <- [2,5,10], y <- [8,10,11]]
12:36:31 <lambdabot>   [(2,8),(2,10),(2,11),(5,8),(5,10),(5,11),(10,8),(10,10),(10,11)]
12:37:52 <elliott> @undo [(x,y) | x <- [2,5,10], y <- [8,10,11]]
12:37:52 <lambdabot> concatMap (\ x -> concatMap (\ y -> [(x, y)]) [8, 10, 11]) [2, 5, 10]
12:38:07 <elliott> > liftA2 (,) [2,5,10] [8,10,11]
12:38:08 <lambdabot>   [(2,8),(2,10),(2,11),(5,8),(5,10),(5,11),(10,8),(10,10),(10,11)]
12:38:24 <frx> nice thanks
12:40:24 <radu> hi, I cannot do :m Control.Monad.Writer in ghci ->     Could not find module `Control.Monad.Writer' -> Perhaps you meant -> Control.Monad.Fix (from base..
12:41:34 <radu> I can do :m Control.Monad though
12:41:34 <wandernauta> Hi all! Is there a way to do postfix functions/operators in Haskell? I'd like to be able to do "print $ 10 squared" but I can't find how to do it. Is it just uncommon to want to do such a thing, or a bad idea, or something else? Thanks in advance!
12:41:58 <haasn> ‚Äú10 squared‚Äù is doable for different reasons ;)
12:42:06 <Eduard_Munteanu> wandernauta: there's PostfixOperators IIRC
12:42:16 <haasn> instance Num a => Num ((a -> b) -> b)
12:42:20 <Eduard_Munteanu> An extension, that is.
12:43:10 <wandernauta> Eduard_Munteanu: Hmm, but won't that only work for binary operators?
12:43:58 <Eduard_Munteanu> wandernauta: yes, you need to use operators, not functions
12:45:27 <blume> @undo [if elem x ys then x else '-' | x <- xs]
12:45:27 <lambdabot> concatMap (\ x -> [if elem x ys then x else '-']) xs
12:45:30 <wandernauta> Eduard_Munteanu: I'll check out the extension, thanks a lot :)
12:47:45 <blume> in this list comprehension: [if elem x ys then x else '-' | x <- xs] isn't 'ys' always the same? i don't get why it works.
12:48:08 <blume> it's printing out the letters that are in ys which also are in xs
12:48:09 <Eduard_Munteanu> blume: it is
12:48:09 <monoidal> it's the same for each element of the list
12:48:49 <blume> > let asd = "test"
12:48:50 <lambdabot>   not an expression: `let asd = "test"'
12:48:58 <monoidal> > [if elem x "aceg" then x else '-' | x <- "abcdefg"]
12:48:59 <lambdabot>   "a-c-e-g"
12:49:15 <monoidal> ys is constantly "aceg"
12:51:50 <blume> > [if elem x "abca" then x else '-' | x <- "aaaa"]
12:51:51 <lambdabot>   "aaaa"
12:52:30 <blume> alright then, the function just doesn't work as i thought it should :-)
12:53:26 <haasn> > "aaaa" ^.. (filtered (`elem` "aceg") `failing` to (const '-'))
12:53:27 <lambdabot>   Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
12:53:28 <lambdabot>  Expected type...
12:53:33 <haasn> > "aaaa" ^.. folded.(filtered (`elem` "aceg") `failing` to (const '-'))
12:53:35 <lambdabot>   "aaaa"
12:54:30 <briennetheblue> :t failing
12:55:44 <carter> :t undefined
12:55:45 <lambdabot> a
12:55:55 <carter> :t undefined undefined undefined
12:55:56 <lambdabot> t
12:56:12 <carter> :t undefined . undefined . undefined
12:56:12 <lambdabot> a -> c
12:56:20 <carter> mwahahahahah
12:56:28 <carter> i hope no one ever writes that for real :)
12:56:38 <fizruk> :t undefined :: a -> c
12:56:39 <lambdabot> a -> c
12:57:04 <carter> :t undefined (a-b)-> a -> ((d->e)->f)->a
12:57:05 <lambdabot> parse error on input `->'
12:57:13 <carter> :t undefined ::  (a-b)-> a -> ((d->e)->f)->a
12:57:14 <lambdabot> parse error on input `-'
12:57:28 <prophile> carter: (a-b)?
12:57:35 <carter> :t undefined ::  (a->b)-> a -> ((d->e)->f)->a
12:57:36 <lambdabot> (a -> b) -> a -> ((d -> e) -> f) -> a
12:57:38 <carter> good catch
12:57:40 <carter> i can't write today :)
12:58:46 <briennetheblue> noo hayoo is down :(
12:58:48 <blume> i thought that list comprehension was supposed to work like zipWith (\x y -> if x == y then x else '-') "abca" "aaaa"
12:59:40 <blume> i'm glad it doesn't.
13:00:25 <S_J> > zipWith (\x y -> if x == y then x else '-') "abca" "aaaa"
13:00:26 <lambdabot>   "a--a"
13:01:11 <S_J> > [(x,y) | x <- [1..10], y <- [1..10]]
13:01:12 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,2),(...
13:01:15 <monochrom> that looks like part of a word-guessing game :)
13:01:53 <briennetheblue> hangman but the gallows is a Œª :)
13:02:32 <S_J> > [(x,x,x) | x <- [1..10]]
13:02:33 <lambdabot>   [(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5),(6,6,6),(7,7,7),(8,8,8),(9,9,9),(1...
13:03:16 <Kaidelong> @hoogle [a] -> [(a,a)]
13:03:17 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
13:03:17 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
13:03:17 <lambdabot> Data.Graph.Inductive.Query.Monad apply :: GT m g a -> m g -> m (a, g)
13:03:32 <Kaidelong> no pairwise for haskell?
13:03:55 <Kaidelong> I guess you could do zip x (tail x)
13:04:11 <blume> monochrom: indeed :) although simply extracted from erik meijer's C9 lecture
13:04:37 <Kaidelong> @pl \x -> zip x (tail x)
13:04:37 <lambdabot> ap zip tail
13:04:45 <Kaidelong> zip`ap`tail
13:05:08 <ReinH> zipWith f <*> tail is super useful
13:05:19 <Kaidelong> pairwise is probably clearer than zip`ap`tail
13:05:51 <Eduard_Munteanu> Cool, GHC accepts a definition of Exists that lets you write stuff like  type Foo a = Exists (forall b. (Bar a b))   which is a constraint.
13:05:51 <ReinH> > let pairwise f = zipWith f <*> tail in and $ pairwise (<=) [1,2,4,3]
13:05:52 <lambdabot>   False
13:05:57 <Narvius> Is "ap" the same as (<*>)?
13:06:00 <ReinH> Narvius: yes
13:06:04 <Narvius> k, thanks.
13:06:05 <Eduard_Munteanu> Narvius: for monads
13:06:25 <Eduard_Munteanu> It needs LiberalTypeSynonyms though.
13:06:36 <monoidal> Eduard_Munteanu: ?
13:06:41 <Narvius> Oh, I see. <*> is for Applicatives.
13:06:54 <monoidal> ah, I confused two threads
13:07:01 <Kaidelong> but all monads are applicatives
13:07:08 <Eduard_Munteanu> Oh.
13:07:14 <Kaidelong> so strictly speaking you can use <*> wherever you can use ap
13:07:14 <Kaidelong> and
13:07:20 <Kaidelong> thus <*> is more general
13:07:33 <ReinH> > let pairwise f = zipWith f <*> tail in take 10 $ fix $ (0:) . (1:) .  pairwise (+)
13:07:35 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
13:07:41 <Kaidelong> zip`ap`tail is just nice because it sounds like some kind of aztec demon god
13:08:19 <blume> Behold the mighty FOLDRONE!
13:08:47 <Narvius> zip`ap`tail xD
13:10:12 <Eduard_Munteanu> Actually with LiberalTypeSynonyms I don't even need the Exists. Hm.
13:23:16 <saml> hello
13:23:23 <saml> i'm lonely so i need to ask question
13:23:43 <saml> ["a", "b", "c", ..]  => ["a", "a/b", "a/b/c", ..]  how do I do that?
13:23:52 <saml> it's like fibonacci but for paths
13:23:59 <saml> ah i got it working
13:24:12 <alkabetz> Hooray, we helped somebody! :)
13:24:15 <saml> i think eevrything is fibonacci
13:24:21 <johnw> > map (intercalate '/') $ inits ["a", "b", "c"]
13:24:22 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
13:24:23 <lambdabot>              with actual ty...
13:24:44 <alkabetz> > map (intercalate "/") $ inits ["a", "b", "c"]
13:24:45 <lambdabot>   ["","a","a/b","a/b/c"]
13:25:03 <johnw> thanks
13:25:10 <alkabetz> Not a problem, I do that all the time
13:25:26 <johnw> i don't think i'll ever remember when to use intersperse vs. intercalate, and which types to use
13:25:29 <johnw> i always just hunt-and-peck
13:25:41 <sipa> :t intersperse
13:25:42 <lambdabot> a -> [a] -> [a]
13:25:46 <sipa> :t intercalate
13:25:47 <lambdabot> [a] -> [[a]] -> [a]
13:26:08 <sipa> > intersperse '1' "234"
13:26:09 <lambdabot>   "21314"
13:26:36 <sipa> > intercalate "123" ["234","567","890
13:26:37 <lambdabot>   <hint>:1:36:
13:26:37 <lambdabot>      lexical error in string/character literal at end of input
13:26:39 <sipa> > intercalate "123" ["234","567","890"]
13:26:40 <lambdabot>   "234123567123890"
13:26:48 <saml> var x = ""; arr.map(function(y) { x = x + "/" + y; return x;} );
13:27:39 <johnw> sipa: ok, making a note of those examples I can paste somewhere prominent
13:27:56 <alkabetz> Wait, when did we get JavaScript support‚ÄΩ
13:31:54 <monoidal> > scanl1 (</>) ["a","b","c"] -- saml
13:31:55 <lambdabot>   Not in scope: `</>'
13:31:55 <lambdabot>  Perhaps you meant one of these:
13:31:55 <lambdabot>    `<>' (imported from...
13:32:18 <monoidal> </> is in System.FilePath
13:53:28 <pantsman> writing drunk haskell and leaving non-exhaustive matches, YOLO
13:54:35 <alkabetz> ‚ÄúWarning: Pattern match(es) are non-exhaustive.  Are you too drunk to be coding right now?‚Äù
13:55:42 <monochrom> there is a common case of non-exhaustive pattern very hard to catch (because it's totally unintended)
13:55:53 <hpc> alkabetz: link in ncurses and have it wobble your term
13:56:04 <monochrom> myfunction [] = whatever
13:56:17 <monochrom> myfucntion (x:xs) = whatever
13:56:33 <hpc> oh wow
13:56:34 <fizruk> monochrom: you mean letters swapped?
13:56:44 <monochrom> or generally typos
13:57:01 <hpc> that's wasted an hour of my time before
13:57:12 <fizruk> oh, is there a warning for top-level definitions without type signature?
13:57:18 <haasn> fizruk: I think so
13:57:23 <alkabetz> Yeah, that usually saves me from typos like that
13:57:40 <haasn> -fwarn-missing-signatures ?
13:59:10 <fizruk> oh, I have -Wall for my projects that includes that one
14:01:01 <numberten> :t takeUntil
14:01:01 <lambdabot> Not in scope: `takeUntil'
14:01:14 <Iceland_jack> :t takeWhile
14:01:15 <lambdabot> (a -> Bool) -> [a] -> [a]
14:01:23 <Iceland_jack> :t dropWhile
14:01:24 <lambdabot> (a -> Bool) -> [a] -> [a]
14:01:25 <texasmynsted> Is there an english way to describe a functor?
14:01:56 <numberten> what if you want up to a specific character and that character?
14:02:00 <monochrom> must it be english?
14:02:06 <Iceland_jack> texasmynsted: I have a feeling you're looking for a concrete answer to an abstract question
14:02:17 <numberten> seems inefficient to have to do both just to grab 1 extra char
14:02:31 <numberten> takeWhile (/= ' ') xs ++ (take 1 $ dropWhile (/= ' ') xs)
14:02:34 <hpc> texasmynsted: same as the regular way, but carrying tea and crumpets
14:02:36 <texasmynsted> I am really trying to define a glossary of FP terms and am finding it "challenging".
14:02:56 <Iceland_jack> texasmynsted: You could say ‚Äúthey allow you to lift functions to some context‚Äù
14:02:56 <texasmynsted> https://gist.github.com/mmynsted/7046872
14:03:05 <monochrom> I recommend not doing it altogether
14:03:05 <monoidal> numberten: use span/break instead of takeWhile + dropWhile
14:03:08 <texasmynsted> ok, can you define lift?
14:03:16 <numberten> :t span
14:03:17 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
14:03:24 <chrisdone> can u even define lift?
14:03:27 <numberten> :t break
14:03:28 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
14:03:28 <Iceland_jack> lol
14:03:32 <hpc> bro, do you even define lift?
14:03:33 <Iceland_jack> texasmynsted: You have a function that adds one (+1) ‚à∑ Int ‚Üí Int, OK?
14:03:36 <monoidal> numberten: the same thing except the predicate is negated
14:03:36 <numberten> will take a look, thanks monoidal
14:03:38 <chrisdone> :D
14:04:04 <texasmynsted> iceland_jack, that is not english
14:04:05 <monochrom> numberten: it seems like if you steal the code of takeWhile and modify it, it is not too bad
14:04:18 <Iceland_jack> texasmynsted: erm, I'm not trying to explain it in what ever you define as ‚ÄúEnglish‚Äù
14:04:43 <Iceland_jack> Do you yourself understand functors?
14:05:06 <numberten> yeah i considered it, but span/break looks even neater
14:05:08 <texasmynsted> Ok, for a glossary, I need to define the concept.  I can show "examples" of a functor, but can not seem to use words to correctly describe what makes a functor a functor
14:05:29 <texasmynsted> iceland_jack yes
14:05:51 <Iceland_jack> Well OK, you take a normal function and you want it to work in different settings without having to rewrite it
14:05:59 <Iceland_jack> and functors allow you to do that
14:06:23 <texasmynsted> so it seems that since I know what a functor is, and how to use one it should be possible for me to describe what one is rather than how to recognize one.
14:06:25 <monoidal> texasmynsted: a type which has an associated fmap function and the function obeys two laws fmap id = id, fmap (f.g) = fmap f . fmap g
14:06:25 <Hodapp> Iceland_jack: What constitutes the 'setting' a function runs in?
14:06:46 <monochrom> Hodapp, that's the point of using english.
14:06:48 <Iceland_jack> texasmynsted: No that doesn't follow
14:07:07 <Iceland_jack> Hodapp: Are you asking because you don't understand functors or because you disagree with my explanation?
14:07:21 <briennetheblue> more like do you even (lift . lift . lift)
14:07:22 <Iceland_jack> Of course if you're going to describe a technical term to a layman things get lost in the translation
14:08:04 <Hodapp> Iceland_jack: I don't know that it's disagreeing with it, but 'setting' is a little vague.
14:08:25 <Iceland_jack> It most certainly is Hodapp
14:08:32 <Iceland_jack> because I'm trying to define something abstract
14:08:33 <monochrom> guess what? theoretically, you could translate the types and the law formulas into english, symbol for symbol. theoretically.
14:08:43 <texasmynsted> ok, can you describe lift?
14:09:20 <Iceland_jack> texasmynsted: It sounds like you're demanding something of me, I'd personally say that the clearest way to show lifting is via examples
14:09:46 <monochrom> Iceland_jack, you should not have answered :)
14:10:03 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #3 :)
14:10:34 <Hodapp> Iceland_jack: 'vague' and 'abstract' aren't necessarily the same thing. If you're going to use a term like 'function', I think it might be good to take a few more words and explain 'setting' a little further.
14:10:35 <briennetheblue> lift is super vague, just write down the laws
14:11:26 <numberten> monochrom monoidal: ended up solving it with uncurry (\a -> \b -> a ++ (take 1 b)) (span (/= ' ') xs) thanks for the help
14:11:49 <monochrom> yeah that works, just a bit slow
14:11:52 <monoidal> numberten: let (a,b) = span (/= ' ') in a ++ take 1 b?
14:11:55 <hpc> Functor is what it is, you aren't going to get any "simpler" than that
14:12:00 <hpc> teach the definition
14:12:04 <Hodapp> Iceland_jack: If it's a pure function, can't I already run it in whatever setting I want to?
14:12:18 <glguy> thanks monoidal, my face just untwisted
14:12:27 <glguy> except yours doesn't type check
14:12:45 <monoidal> ah, right, there should be an arg to span
14:12:47 <monochrom> you forgot xs. that's all
14:13:47 <numberten> would it be faster with the let? or just more compact?
14:13:56 <monoidal> more readable
14:13:59 <numberten> sure
14:14:00 <glguy> numberten: Also, don't forget that \a -> \b -> is \a b ->, and a ++ (take 1 b) is a ++ take 1 b
14:14:21 <numberten> yeah I see the equivalence, was just curious if the let bindings made it faster
14:14:28 <numberten> since monochrom said 'just a bit slow'
14:14:49 <monochrom> after changing to let, it is still the same just a bit slow
14:15:23 <monoidal> numberten: your predicate is more complicated than /= ' ', right? (otherwise you always append a space or nothing.)
14:15:44 <numberten> yea
14:16:56 <monoidal> numberten: (in general, there's no point in writing uncurry (\a -> \b -> ...); it's simpler to write \(a,b) -> ..., and here, since you apply this to something, it's equivalent to let.)
14:17:13 <numberten> makes sense
14:18:33 <numberten> thanks for all the help, it's always really fun to brush up on haskell
14:20:19 <Iceland_jack> @let numberten = 10
14:20:20 <lambdabot>  Defined.
14:22:39 <glguy> > let f = toListOf (beside folded (taking 1 folded)) . break (==' ') in f "ab cd"
14:22:41 <lambdabot>   "ab "
14:23:21 <monochrom> the ListOf substitutability principle :)
14:23:50 <glguy> What're the specifics of that principle?
14:24:40 <apples> haha
14:25:00 <monochrom> every haskell, python, perl beginner uses lists instead of real data structures :)
14:25:17 <hpc> python doesn't have lists, only dictionaries
14:25:20 <haasn> :t beside
14:25:28 <haasn> :t Control.Lens.beside
14:25:29 <lambdabot> (Applicative (Data.Profunctor.Rep.Rep q), Applicative f, Data.Profunctor.Rep.Representable q) => Overloading p q f s t a b -> Overloading p q f s' t' a b -> Overloading p q f (s, s') (t, t') a
14:25:30 <lambdabot> b
14:25:30 <briennetheblue> :t (beside)
14:25:31 <lambdabot> (Applicative (Data.Profunctor.Rep.Rep q), Applicative f, Data.Profunctor.Rep.Representable q) => Overloading p q f s t a b -> Overloading p q f s' t' a b -> Overloading p q f (s, s') (t, t') a
14:25:31 <lambdabot> b
14:25:33 <alkabetz> hpc: Uh, wat
14:25:33 <hpc> perl does not have lists, only dollar signs
14:26:03 <fizruk> hpc: haskell doesn't have lists, only unevaluated thunks?
14:26:08 <briennetheblue> :t (failing)
14:26:09 <lambdabot> Applicative f => Traversing (->) f s t a b -> Traversing (->) f s t a b -> Over (->) f s t a b
14:26:33 <hpc> fizruk: haskell has lists but only at the type level
14:27:20 <glguy> beside folded (taking 1 folded) :: Fold ([a],[a]) a
14:27:25 <glguy> in this case
14:29:32 <haasn> > "ab cd" ^.. to (break isSpace).beside folded _head
14:29:33 <lambdabot>   "ab "
14:31:10 <glguy> > let f = toListOf (to (break (== ' ')) . beside folded _head) in f "ab cd"
14:31:11 <lambdabot>   "ab "
14:31:15 <glguy> thanks haasn , much clearer ^_^
14:31:38 <haasn> we need breaking :)
14:32:48 <fizruk> :t _head
14:32:49 <lambdabot> Cons (->) f s s a a => LensLike' f s a
14:33:37 <Rarrikins> What is a good channel for help with esqueleto?
14:33:58 <johnw> #yesod maybe?
14:34:02 <johnw> or here
14:34:18 <Rarrikins> Ahh, OK. Thanks.
14:34:35 <chrisdone> i gotta convert lpaste, ircbrowse and haskellnews to esqueleto. it's too cool
14:34:40 <ijp> I'm reading Gibbons' Origami Programming and most of it is pretty straightforward, except for the fusion laws for rose trees/forests.
14:35:12 <donri> chrisdone: acid-state FUCK YEAH
14:35:17 <chrisdone> lol
14:35:23 <glguy> language please
14:35:23 <chrisdone> donri: i've only got 16gb of memory
14:35:27 <ijp> since the defintions of fold on them are mutually recursive, should I be assuming that the fusion law for forests holds when proving the one for trees, and vice versa?
14:35:40 <donri> glguy: sorry
14:36:11 <ijp> if feels unsatisfyingly circular
14:37:17 <ParahSailin> python doesnt have lists?
14:37:26 <donri> chrisdone: i wonder how much memory lpaste and ircbrowse would need with acid-state
14:37:34 <donri> chrisdone: (guessing haskellnews doesn't use much)
14:38:25 <alkabetz> ParahSailin: Python has lists; hpc was being sarcastic.
14:39:29 <donri> chrisdone: maybe don't want to run a persistent pastebin in-memory without any "time to live" for pastes... OTOH i guess text doesn't use much memory. could store them as compressed bytestrings too ;)
14:39:33 <srhb> Has anyone gotten haskell-mode to play nice with cabal repl?
14:40:54 <donri> chrisdone: did you get fedora set up? how much did you hate it? i bet you hated it.
14:41:25 <ijp> I guess the problem is with the universal property I wrote down, I should probably change it
15:10:50 <dmj`> can Haskell records perform inheritance, w/o unboxing/reboxing? Any GHC or some special magic that allows this? Something like, data Cat { name :: String }, data Cat => PersianCat { persianName :: String }, and PersianCat would have both name and persianName field records
15:11:57 <Eduard_Munteanu> dmj`: you're looking for extensible records, try googling that, but no, that's not explicitly supported.
15:11:57 <Rarrikins> dmj`: No. Types don't have inheritance.
15:12:06 <alkabetz> You can get something similar with 'makeFields' from the lens package.
15:13:28 <dmj`> alkabetz: yes, but that uses Template Haskell right? So those functions would need to be exported. I'm in a situation where a data type exists, and I wan't to add fields to it, w/o rebuilding the package.
15:14:05 <glguy> dmj`: Unless the data type already supports extension you can't extend it
15:14:05 <Eduard_Munteanu> Normally you'd just make it a field of your datatype.
15:14:12 <glguy> and still use the old methods on it
15:17:40 <dmj`> glguy: Is it a common extension?
15:18:20 <Cale> dmj`: He's not talking about a language extension
15:18:29 <glguy> I mean the type would need to be parameterized, say like parsec which has a user-state field that parsec doesn't use
15:19:47 <dmj`> Cale: extensible records is not a ghc extension, its a pkg?
15:20:08 <Eduard_Munteanu> dmj`: it's a concept
15:20:23 <Eduard_Munteanu> Which can be implemented in a number of ways.
15:21:16 <glguy> data Widget extension = NormalCase | OtherNormalCase | ExtraCase extension, or: data Thingy extension = MkThingy extension SomeType OtherType
15:21:36 <Cale> Hugs had TRex which was a system of extensible records, and Ermine is a Haskell-like language with polymorphic extensible records, but GHC Haskell doesn't have any sort of built in extensible records.
15:23:08 <zomg> "Doing an ermine" is finnish slang for playing CS very poorly (can be applied to other games as well) :D
15:23:09 <Cale> But yeah, what glguy is talking about is just adding a type parameter for whatever sort of extra stuff you might want to add on.
15:24:24 <Cale> dmj`: However, there are some packages which implement extensible records, usually through sizeable amounts of type hackery
15:32:41 <chrisdotcode> hi everyone :)
15:32:48 <Cale> hi!
15:33:49 <dmj`> Cale: will have to read more on it, me thinks data C = C { d : String }, data C => A = A { g :: String } would be cool
15:34:29 <Cale> dmj`: It doesn't exactly make sense what would happen there when there are multiple cases. Also, what type should the field names have?
15:34:42 <Cale> dmj`: Normally when you define a data type like:
15:34:54 <Cale> data Cat = Cat { name :: String, age :: Integer }
15:34:59 <Cale> you get:
15:35:03 <Cale> name :: Cat -> String
15:35:07 <Cale> age :: Cat -> Integer
15:36:15 <Cale> While this might not be an ideal type (one might prefer a lens), even in this simple case, it's hard to imagine how to extend the types of the field extractor functions.
15:37:12 <Cale> You might introduce a new typeclass implicitly, but then you have to know to do so ahead of time. Type level string literals might help the situation, but it's complicated, and I'm not sure you'd want to deal with that all of the time.
15:38:06 <dmj`> Let's say the type would remain C. so test = A { g = "a", d = "b" }, :t String -> String -> C, so somehow, g would be C -> String...
15:38:51 <Cale> dmj`: But then you couldn't use it with values of type A
15:39:18 <dmj`> what if type A was a synonym for C
15:39:34 <Cale> Nope, that doesn't work, because that would mean they're the same type
15:40:02 <Cale> What you're looking for is some kind of subtyping, but subtyping makes type inference really bad generally.
15:41:07 <dmj`> data A = A { g :: String, c :: C } is what I'll have to do I guess.
15:41:28 <Cale> Something like that is probably a sensible way to go about it.
15:41:54 <Cale> Usually you can just factor your types into smaller parts
15:44:35 <user123abc> is there a way to use higher order functions to avoid the outermost parens around each argument to map in this simplified example?
15:44:36 <user123abc> http://lpaste.net/9027455995546173440
15:45:07 <monoidal> user123abc: use a section: map (+1)
15:45:21 <monoidal> user123abc: and infix syntax: [1] ++ [2]
15:45:33 <fizruk> > map (1+) $ [1] ++ [2]
15:45:34 <user123abc> those are meant to stand in for regular functions
15:45:34 <lambdabot>   [2,3]
15:45:42 <user123abc> just to have a simple example
15:45:56 <fizruk> user123abc, perhaps, it's too simple?
15:46:13 <user123abc> unless you're saying that infixing functions will help me avoid outermost parens in such a case
15:46:25 <user123abc> that's not the case though, right?
15:46:37 <fizruk> > map succ $ [1] `append` [2]
15:46:38 <lambdabot>   Not in scope: `append'
15:46:38 <lambdabot>  Perhaps you meant one of these:
15:46:38 <lambdabot>    `BSC.append' (im...
15:46:42 <monoidal> user123abc: for outermost, use $
15:46:43 <fizruk> > map succ $ [1] `mappend` [2]
15:46:44 <lambdabot>   [2,3]
15:47:07 <fizruk> > map succ $ concat [[1], [2]]
15:47:08 <lambdabot>   [2,3]
15:47:31 <user123abc> > map $ (+) 1 $ (++) [1] [2]
15:47:33 <lambdabot>   Couldn't match expected type `a0 -> b0' with actual type `[a1]'
15:47:38 <user123abc> something of this form
15:47:48 <jfischoff> > map (+ 1) $ [1] ++ [2]
15:47:49 <lambdabot>   [2,3]
15:47:50 <fizruk> user123abc, f $ g $ x == f (g x)
15:48:04 <user123abc> jfischoff, I can't use a section with regular functions
15:48:16 <jfischoff> so?
15:48:18 <xenocons> slightly offtopic, what licensing is mostly used for haskell open source projects?
15:48:59 <monoidal> user123abc: it would be much better if you gave the example you face, it seems that one is oversimplified
15:49:16 <user123abc> tns <- liftM (flip S.map tns (fst . dealias_ ag')) $ MV.freeze ag
15:49:41 <user123abc> it would be nice to avoid the parens around flip, or at least to see how that feels
15:50:00 <monochrom> BSD3 is the most popular
15:50:02 <monoidal> user123abc: tns <- MV.freeze ag; let tns' = flip S.map tns (fst . dealias_ ag') tns
15:50:24 <monoidal> user123abc: that flip is unneccessary - why not just flip the arguments?
15:50:50 <monoidal> oh, is that a recursive do?
15:50:58 <user123abc> because it's a big function and I was hoping to keep it to fewer lines
15:51:06 <user123abc> using ; could work
15:51:31 <user123abc> (or just keeping parens)
15:51:36 <user123abc> but no option to get rid of them?
15:51:37 <Rarrikins> In esqueleto, do I need to tell it if a table has a Word8 primary key (rather than Int64 or whatever)? If so, how do I do that?
15:51:42 <monoidal> user123abc: I mean, you can write tns S.map (fst . dealias_ ag') instead of flip S.map tns (...)
15:52:33 <monoidal> user123abc: (I would use a let intead of liftM.)
15:52:37 <user123abc> uh, because I wanted to bind the freeze as an argument to dealias
15:53:01 <user123abc> which actually might not be happening in what I pasted anyway
15:53:24 <glguy> user123abc: if it's a big function you have all the more reason not to make it unreadable
15:54:31 <user123abc> I see where you're coming from, though I'm the only one reading it and I tend to handle longer lines better than more
15:55:28 <glguy> user123abc: if it's throwaway code then that's fine. But if your going to be the one reading it later you'll thank your past self for not making extra work for yourself
15:57:08 <monoidal> user123abc: if (flip S.map tns (fst . dealias_ ag')) is something that you can feel intuitively, maybe you can give it a name and then it's liftM dealias_set $ MV.freeze ag or something like tht
15:58:25 <monoidal> there's surely a balance between having long lines and many lines - if you go too far in the first direction, you will need more parentheses
15:58:55 <user123abc> valid style advice which I might take, though I still want to know about the original question, since it's something that I wonder about fairly often
15:59:03 <user123abc> let me try another simplified example
15:59:24 <user123abc>  map (fa  1) $ fb [1] [2]
15:59:45 <user123abc> how can I avoid parens around fa 1 here?
16:00:08 <monochrom> fa 1 `map` fb [1] [2]
16:00:09 <glguy> fa 1 <$> fb [1] [2] --
16:00:37 <monochrom> let x = fa 1 in let y = fb [1] [2] in map x y
16:00:39 <user123abc> ah, interesting
16:00:39 <ion> Both also being answers to the even better question ‚Äúhow can I avoid $ here?‚Äù
16:01:07 <glguy> [fa 1 x | x <- fb [1][2]]
16:01:24 <monochrom> that adds "[" and "]"
16:01:31 <glguy> I'm not golfing it :-p
16:01:37 <ion> ‚Äúthat adds let‚Ä¶in‚Ä¶‚Äù
16:01:38 <user123abc> lol
16:01:59 <user123abc> trying these out now, thanks
16:02:25 <monoidal> user123abc: in your original example, do you have a recursive do?
16:02:30 <user123abc> no
16:02:44 <monochrom> "let x = fa 1 in let y = fb [1] [2] in map x y" is why fortran was invented
16:02:45 <user123abc> the suggestions with separate binds would work, if that's why you ask
16:02:47 <monoidal> ok. you might consider renaming tns, since it is shadowed.
16:03:07 <user123abc> yeah, I'm aware, was just moving stuff around so it happened
16:03:09 <monochrom> because people wanted to write "map (fa 1) (fb [1] [2])" instead
16:03:53 <user123abc> thanks for the help, all
16:04:06 <monochrom> parentheses was supposed to represent advancement. instead, now people want to trash it
16:04:39 <ion> I wish people wanted to write that. Instead they wanted to write map(fa(1),fb([1],[2]))
16:04:54 <monochrom> and go back to 1940's "tmp1 = fa 1; tmp2 = fb [1] [2]; final_answer = map tmp1 tmp2"
16:05:00 <user123abc> I'm still trying to find a balance, but I just want to know what my options are in terms of parens
16:05:21 <monochrom> you have almost infinitely many options
16:05:21 <user123abc> when ))) starts building up, I feel funny inside
16:05:39 <monochrom> have I told you this other trick in my sleeve?
16:05:45 <user123abc> surely not
16:06:03 <ion> I don‚Äôt see any of the parens in map (fa 1) (fb [1] [2]) as extraneous. Feel free to get rid of them one way or another if you want to, but that expression is just fine as it is.
16:06:06 <monochrom> define "...+..." to be the same as "+", except it's infixl 9
16:06:27 <monochrom> define "......*......" to be the same as "*", except it's infixl 3
16:06:35 <user123abc> uh
16:06:37 <briennetheblue> beautiful :p
16:07:01 <monochrom> now you can eliminate parentheses in "(3+4)*5" by "3 ...+... 4 ......*...... 5"
16:07:08 <user123abc> ion, for that example, I agree
16:07:11 <glguy> maybe put that trick back in your sleeve?
16:07:28 <monochrom> you can *always* eliminate parentheses. you have enough rope to hang yourself.
16:07:36 <ion> monochrom: Please make a proposal out of that for Prelude.
16:07:51 <monochrom> coming next April 1
16:08:07 <monoidal> the number of dots should be the same as priority
16:08:16 <briennetheblue> so Haskell, you show your true form!
16:09:03 <monoidal> or, 9-priority. so in 3 ...+... 4 ......*...... 5  you can see that 3 and 4 are closer than 5
16:09:15 <monochrom> yes, 9-priority
16:09:32 <simpson> Why can't we all just move to Forths of some sort? 5 4 3 + *
16:10:24 <monochrom> for that to work, the parser has to know arities, and arities must be fixed
16:10:57 <monochrom> but haskell parsers cannot easily know arities, and arities are not fixed. consider "id id id 5"
16:11:06 <monochrom> @quote monochrom curry
16:11:06 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
16:11:40 <dwcook> Arity is only fixed at runtime anyway, when ad hoc polymorphism is involved. cf. printf
16:11:45 <dwcook> Wait no
16:11:50 <dwcook> That's not right
16:11:59 <dwcook> The type system is aware of the arity
16:12:12 <dwcook> So there'd have to be feedback from the type system to the parser?
16:12:38 <sshine> if a monad instance behaves like a combination of State, Writer and Error, would it make sense to say that it has these prototypical behaviours?
16:12:45 <monoidal> it should be possible to create a quasiquote [rpn|5 4 3 + *|].
16:12:56 <monochrom> you have a chicken-egg problem. the parser asks the type checker for arities. the type checker asks the parser for trees.
16:13:36 <quchen> sshine: Not sure what you mean with "prototypical behaviour".
16:13:37 <monochrom> in fact, you don't even know whether 5 has 0-arity or not.
16:14:09 <monoidal> sshine: you can say that a monad is a MonadState/MonadWriter/MonadError
16:14:15 <monoidal> *instance of ...
16:15:10 <ion> RWST
16:27:10 <watermind> ok regarding this functor-applicative-monad proposal,  they say Functor will be a *superclass* of Monad
16:27:29 <monoidal> Applicative will (and in turn, Functor)
16:27:57 <watermind> does that mean "class Functor m => Monad m where  "?
16:28:12 <monoidal> class Applicative m => Monad m, yes
16:28:28 <watermind> right which makes sense
16:28:43 <watermind> but how then is functor/applicative automatically derived from monad?
16:28:56 <monoidal> it isn't. you should define your own
16:29:03 <monoidal> in GHC 7.8 you will get a warning
16:29:04 <watermind> ok
16:29:17 <watermind> got it, I must have misread something
16:29:28 <monoidal> of course, fmap = liftM, (<*>) = ap, pure = return always work
16:29:47 <geekosaur> you may have been confused by a recent (I think it was on cafe) message where someone thought it worked the other way
16:30:10 <watermind> maybe
16:30:20 <watermind> monoidal: yes I understand that
16:33:55 <sshine> monoidal, but those are actual types, I presume. I'm just mimicking them.
16:35:14 <monoidal> sshine: I would just say that the monad works as the combination of State, Writer, Either. "prototypical behaviors" might be not understood by everyone, though I see what you could mean by that.
16:35:28 <sshine> monoidal, yeah, I don't want to invent my own lingo.
16:35:31 <sshine> monoidal, thanks. :)
16:37:41 <srhb> sshine: Would be archetypical if anything. But yeah, bad lingo - bad! :P
16:38:13 <sshine> thanks, srhb ;)
16:38:32 <sshine> I just noticed that you're collecting StackOverflow points, too!
16:38:46 <srhb> Can't sleep, pissy over getting dumped for a night out! :P
16:39:24 <srhb> But I liked the question even if it demanded a very artificial solution (as mine is, too)
16:51:06 <Dennis_> hi
16:51:23 <Dennis_> im just having a hard time overriding a Method can someone maybe help me?
16:51:25 <Dennis_> http://pastebin.com/QVAjt8Vj
16:51:29 <mauke> The paste QVAjt8Vj has been copied to http://lpaste.net/94465
16:51:54 <Dennis_> it says that rnf is not a visable Method of NFData
16:52:23 <Dennis_> but how can i then oiverride such class Methods?
16:52:57 <srhb> Without qualifying them, I believe.
16:53:45 <Dennis_> same effect :(
16:54:41 <monoidal> import Control.DeepSeq instead.
16:54:49 <monoidal> it's weird.
16:56:28 <Dennis_> thats realy weird oO i found an article to that which used the other one like this
16:58:35 * hackagebot http-common 0.7.0.1 - Common types for HTTP clients and servers  http://hackage.haskell.org/package/http-common-0.7.0.1 (AndrewCowie)
16:58:59 <Dennis_> but thx for your help :=
16:59:48 <srhb> Oh, it's an actual API change..
17:00:13 <monoidal> Dennis_: Control.Parallel.Strategies exports NFData but not the method
17:00:24 <srhb> Used to though.
17:00:28 <srhb> Didn't it?
17:00:50 <Dennis_> Its good that it doesnt though i think thats the wrong api anyways xD
17:01:49 <srhb> Dennis_: Yes.
17:03:35 * hackagebot http-streams 0.7.0.1 - An HTTP client using io-streams  http://hackage.haskell.org/package/http-streams-0.7.0.1 (AndrewCowie)
17:04:59 <monoidal> suppose a module exports a function Class a => a, should it also export Class even though if not defined there? and if then, what about methods of Class?
17:07:02 <monoidal> (for example, I don't think every module should export String/Show etc.)
17:07:19 <fizruk> monoidal, I do not reexport for instance Applicative with its methods if I use it
17:08:12 <monoidal> no problem with using; problem with exporting
17:08:35 <monoidal> someone imports your module containing a function f :: Applicative f => a -> f a. Now he writes g = f
17:08:49 <monoidal> it's pathological you can define a function, but not write its signature
17:09:55 <fizruk> I don't see the problem here..
17:10:32 <monoidal> I would expect, that if you define a value, you can give it a type signature. and here you need an additional import.
17:11:14 <lpaste> Dennis pasted ‚Äúrnf ‚Äù at http://lpaste.net/94467
17:11:23 <Dennis_> Another one :)
17:11:41 <Dennis_> No instance for (NFData a) arising from a use of `rnf' Possible fix:   add (NFData a) to the context of the instance declaration
17:11:59 <monoidal> Dennis_: the compiler told you what to do.
17:12:03 <srhb> Dennis_: You're short => ?
17:12:04 <Dennis_> i don't realy understand where i need to add that declaration
17:12:19 <monoidal> instance NFData a => NFData (TestCons a) where
17:12:53 <Dennis_> Ok that was easy thanks im not very familiar with that class stuff ;)
17:13:00 <fizruk> monoidal, one can write g = f and give g a type signature like a -> [a]
17:13:40 <monoidal> fizruk: sure, but the point is about g polymorphic in the applicative.
17:13:41 * hackagebot http-streams 0.7.0.2 - An HTTP client using io-streams  http://hackage.haskell.org/package/http-streams-0.7.0.2 (AndrewCowie)
17:13:51 <fizruk> monoidal, if he would like to extend the API with some other functions on Applicative, he should import Control.Applicative
17:14:16 <monoidal> fizruk: if that's true, "g = f" without a sig should give an error/warning
17:15:14 <fizruk> monoidal, top-level functions without a signature give warning with -Wall (or -fwarn-missing-signatures)
17:15:30 <monoidal> right, but that's a different warning.
17:15:31 <fizruk> monoidal, not sure about nested
17:16:03 <fizruk> monoidal, more general I would say
17:16:41 <begriffs> I'm having trouble installing monad-control-0.3.2.1 on a mac. Any ideas?
17:17:05 <srhb> begriffs: Without more details? :P
17:18:30 <fizruk> monoidal, so I think one should not reexport Class unless it is intended to be a part of API
17:19:10 <monoidal> I think Class could be reexported. its methods, no.
17:20:15 <fizruk> monoidal, what about type families?
17:20:45 <fizruk> e.g. class Class a where type Type a :: * ...
17:21:02 <monoidal> fizruk: if an exported signature contains Type, then Type should be exported.
17:21:16 <begriffs> srhb: it says "invalid preprocessing directive #-}"
17:22:16 <geekosaur> you have xcode 5 installed
17:22:32 <monoidal> fizruk: it's true that you can't export a family, forbidding adding new instances
17:23:44 <monoidal> fizruk: (btw note that in g = f case, the warning would concern different modules.)
17:24:37 <monoidal> fizruk: (the missing signature error applies to the importing module. however, I  would like a warning in the exporting module.)
17:25:44 <fizruk> monoidal, so it tells you that not all types used in signatures are exported?
17:26:24 <monoidal> fizruk: yes. it is true, however, that literal execution would mean you need to reexport String, Applicative etc. in many modules, which is not what I want.
17:29:55 <fizruk> monoidal, I still think being able to write type signatures without extra imports is not worth reexporting classes/families
17:30:33 <monoidal> just for clarity, I am also talking about reexporting types
17:31:01 <monoidal> my philosophical principle is that if you can write x, then you should be able to write the type of x
17:32:46 <fizruk> monoidal, I can't see the origin of this principle (and it is not intuitive to me, because I mostly write signatures first)
17:35:04 <volko> does anyone have experience with GPipe vs. Accelerate?
17:35:51 <fizruk> I can't say I have a working principle, but I think anything should be exported if it is intended to be a part of the interface
17:36:20 <fizruk> (everything else ‚Äî exported in .Internal)
17:38:02 <monoidal> well, if you count that "f :: Int -> Int" is interface, then I claim "Int" is a part of the interface
17:38:16 <monoidal> but I don't want to argue semantics.
17:38:29 <monoidal> here is a GHC bug http://ghc.haskell.org/trac/ghc/ticket/2135
18:00:46 <user123abc> http://hackage.haskell.org/package/vector-0.10.9.1/docs/Data-Vector.html#v:modify
18:01:09 <user123abc> could somebody give me some idea of when it might be "safe" to do a destructive operation on a vector?
18:01:32 <user123abc> I'm wondering if I can use modify to pretty up some code that goes back and forth between mutable and immutable vectors
18:08:35 <Cale> user123abc: Probably the rule being referred to is "clone/new [Vector]" forall p. clone (new p) = p
18:08:57 <Cale> modify p = new . New.modify p . clone
18:09:35 <user123abc> I don't know enough to make sense of that yet - could you explain it like I'm 5?
18:10:01 <Cale> For example, if you had two modifies next to each other, it could avoid the intermediate clone
18:10:50 <Cale> modify p . modify q = new . New.modify p . clone . new . New.modify q . clone
18:11:04 <Cale> and then the clone/new rule will remove the intermediate clone
18:11:10 <user123abc> do they have to be textually next to each other? I'm thinking of using this to fold a vector over a list
18:11:39 <Cale> Well, rules only apply to things which actually occur in the source code, not at runtime
18:11:46 <Cale> There are a bunch of rules though
18:12:06 <Cale> Probably to really know what's going on, you'd have to look at the generated core
18:12:30 <Cale> But better still, just write it and see if it's fast enough?
18:12:39 <user123abc> it should be clear from my memory usage - I was just hoping someone could give me some idea of how this works in general
18:12:45 <user123abc> indeed, better
18:12:52 <user123abc> and now I have some idea of how it works
18:13:10 <user123abc> thanks
18:18:51 <Cale> user123abc: You can look in the Vector source code for things like {-# RULES  ... #-}  to see the replacement rules that the compiler will use to simplify computations written using the library's functions.
18:19:51 <user123abc> thanks
18:20:20 <Cale> and I believe the commandline option to give to GHC to see which ones are firing is -ddump-simpl-stats
18:32:52 <t4nk551> Wondering if anyone can help me with the "isPrefixOf" function
18:33:19 <t4nk551> trying to see if the first string is a prefix of a second (it's homework, not looking for an answer, just some pointers)
18:35:01 <fizruk> t4nk551, define what does that mean for a string to a prefix for another string, then encode that in Haskell :)
18:36:47 <user123abc> t4nk551, what sort of library functions can you use?
18:36:49 <t4nk551> Yeah I managed it, but it's failing the quickCheck that's already been coded
18:37:00 <t4nk551> So I don't think they want us to use isPrefixOf
18:37:14 <t4nk551> user123abc:  it doesn't actually state, we can use whatever we like I guess
18:37:42 <ubikation> hey what's wrong with this code? http://lpaste.net/94468
18:38:10 <Cale> :t randomR
18:38:11 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
18:38:24 <Cale> :t getStdRandom
18:38:25 <lambdabot> (StdGen -> (a, StdGen)) -> IO a
18:38:40 <Cale> ubikation: What problem are you having with it?
18:38:50 * hackagebot monoid-extras 0.3.2.3 - Various extra monoid-related definitions and utilities  http://hackage.haskell.org/package/monoid-extras-0.3.2.3 (BrentYorgey)
18:38:52 <ubikation> I added the error to the paste
18:38:55 <monoidal> ubikation: maybe you want liftA3 (,,) (...) (...) (...)
18:39:18 <Cale> oh, right
18:39:29 <Cale> yes
18:41:59 <ubikation> what?
18:42:33 <monoidal> ubikation: liftA3 (,,) (SR.getStdRandom (SR.randomR ...)) (SR.getStdRandom (SR.randomR ...)) (SR.getStdRandom (SR.randomR ...))
18:42:45 <monoidal> ubikation: (,,) is a -> b -> c -> (a,b,c)
18:43:11 <monoidal> ubikation: liftA3 takes a function a -> b -> c -> d, you were passing a tuple
18:43:33 <ubikation> doesn't work for me:
18:43:34 <ubikation> * MercurialAlchemi (~Mercurial@sopona.idm.fr) has joined #haskell
18:43:40 <ubikation> http://lpaste.net/94470
18:43:42 <ubikation> sorry
18:45:04 <monoidal> ubikation: add a type signature - something like (0::Int,100)
18:45:46 <monoidal> ubikation: or, return a should also work
18:49:31 <ubikation> monoidal: thank you! that helped clear things up!
19:03:34 <ubikation> what function should I use if I want to call another function a bunch of times and cons them all together?
19:03:50 <monoidal> replicate/replicateM
19:06:05 <ubikation> monoidal: thanks!
19:06:44 <sinclair|work> are there any low level networking experts in here?
19:12:28 <ezyang> I discovered something very mysterious today, which is that when you write bind for the Cont monad w/o newtype wrappers, there is a more general type it can be given.
19:14:00 <sinclair|work> i need some help with NAT traversal, namely STUN servers
19:14:10 <sinclair|work> for connecting two P2P applications
19:14:17 <monoidal> ezyang: the same way what happens with state and indexed state?
19:14:46 <ezyang> monoidal: Oh, I haven't tried that out
19:15:12 <monoidal> ezyang: afair IxCont s r a = (a -> s) -> r is an indexed monad, like IxState s t a = s -> (t,a)
19:15:27 <monoidal> I might have messed the indices order
19:15:55 <ezyang> Oh, I see, the generalized type doesn't have a monad class, but it has an indexed monad class. Fascinating!
19:16:39 <AshyIsMe> yo
19:16:54 <AshyIsMe> oops ww
19:18:18 <monoidal> ezyang: http://blog.sigfpe.com/2009/02/beyond-monads.html
19:19:49 <ezyang> Great, Dan Piponi's on it!
19:19:57 <ezyang> (and Wadler, and everyone else :)
19:35:47 <shelf> how does one pronounce (>>)
19:36:03 <jmcarthur> ezyang: it's a nice type, really
19:36:12 <jmcarthur> ezyang: can encode delimited continuations and all that
19:36:33 <jmcarthur> shelf: i don't normally pronounce it, but i guess something like "and then" might work
19:37:32 <shelf> i'm doing a presentation on constrained monads, and i'm blushing three days in advance at the idea of saying 'and this sequencer thing'
19:38:02 <jmcarthur> you could maybe overload "bind"... unless you need to actually verbally distinguish it from (>>=)
19:39:14 <shelf> i am resigned to calling it 'this guy'
19:39:15 <ubikation> how do I call replicate on (SR.getStdRandom (SR.randomR (0::Int, vertexes)))?
19:47:57 <ubikation> hello?
19:48:13 <Kaidelong> hello
19:48:39 <Kaidelong> @hoogle getStdRandom
19:48:40 <lambdabot> System.Random getStdRandom :: (StdGen -> (a, StdGen)) -> IO a
19:49:09 <Kaidelong> oh, IO
19:49:23 <Kaidelong> the best you could do is map replicate over that result because
19:49:25 <Kaidelong> @ty replicate
19:49:26 <lambdabot> Int -> a -> [a]
19:49:34 <monoidal> ubikation: just replicateM n (SR.getStdRandom ...)
19:49:42 <monoidal> ubikation: though this is probably not the best way to do it.
19:49:52 <Kaidelong> @ty replicateM
19:49:53 <lambdabot> Monad m => Int -> m a -> m [a]
19:50:10 <ubikation> but I want to call replicate based on the random number
19:50:43 <Kaidelong> well have you considered random-fu?
19:51:07 <monoidal> ubikation: do you mean that n is generated randomly? if so, do n <- ...; replicateM n ...
19:51:13 <Kaidelong> because you could make an RVar (a -> [a]) by using fmap replicate x where x is your random variable
19:51:23 <Kaidelong> and then use applicative to apply it to some value
19:51:42 <Kaidelong> in fact you could write it something like
19:52:02 <Kaidelong> replicate <$> randomNumberOfElements <*> randomElementToRepeat
19:52:22 <Kaidelong> and you don't end up in IO
19:52:27 <Kaidelong> until you actually need to
19:53:35 <monoidal> Kaidelong: won't that give a constant list?
19:54:20 <Kaidelong> monoidal: it'd give an RVar list, which could be sent into IO or generated constantly from a fixed seed
19:54:25 <Kaidelong> RVar [a]
19:54:51 <monoidal> Kaidelong: I mean, won't the random list always have the same thing?
19:55:03 <monoidal> Kaidelong: (that's my gut instinct.)
19:55:07 <Kaidelong> yeah? Is that not what ubikation wants?
19:55:38 <ubikation> Kaidelong: thank you! that's exactly what I wanted!
19:55:48 <Kaidelong> I figured he was trying to generate a random length list of the same, randomly chosen element
19:55:52 <monoidal> ok
20:44:00 <dmj`> when doing 'real world' haskell apps that produce a binary (not a library), is it good practice to lock in the package versions in the cabal file? Like filepath == 1.3, etc, for each dependency
21:04:17 <johnw> dmj`: no, it is not
21:04:37 <johnw> minimum dependencies are OK, fixed and upper-bound dependencies are to be avoided unless you really need them, in my experience
21:10:57 <rohan^> Hi.  Is there a way to create an IORef that stores unboxed Ints?
21:16:35 <rohan^> (or something equivalent)
21:23:20 <Kaidelong> there is Vector.Mutable
21:24:33 <rohan^> I could use a ByteArray#, but even that has unnecessary overhead.
21:51:01 <jh_> @pl \x -> x
21:51:02 <lambdabot> id
21:51:22 <jh_> @pl \x -> f (g x) x
21:51:22 <lambdabot> f =<< g
21:52:29 <halvorgb> anyone using haskell-mode in ubuntu 13.10? Indentation is really weird for me now after I've upgraded.
21:52:35 <halvorgb> in emacs24
21:55:54 <gienah> no, but I can give a pointer to the docs: http://haskell.github.io/haskell-mode/manual/latest/
21:56:12 <gienah> which might help if its using a recent haskell-mode
21:57:08 <gienah> there's a screencast from a while ago that might help: http://www.youtube.com/watch?v=E6xIjl06Lr4
21:58:26 <halvorgb> Thanks, i'll check out the manual
21:58:34 <halvorgb> the screncast doesn't exist though
21:58:45 <Kron> I do
21:58:54 <Kron> I'm using ubuntu 13.10 with emacs24 haskell-mode
21:59:06 <Kron> however I use simple-indent, the 'stupid' indentation mode
21:59:10 <Kron> so I'm not sure I can help you
22:00:51 <halvorgb> Oh OK, I really liked the default indentation from 13.04, turn-on-haskell-indent comes close, but is worse imo
22:01:57 <Kron> I've never really tried it! ^_^
22:02:06 <Kron> I'm kinda new to 13.10 and new to haskell and everything
22:02:30 <halvorgb> : )
22:02:34 <Kron> I had a mid life crisis moment like a few months ago where I realized I didn't have enough coding in my life
22:02:48 <Kron> so I dumped my windows and now i'm sitting in xmonad on the latest ubuntu being taught haskell by my gf
22:02:53 <Kron> fun :D
22:03:04 <Kron> I plan to dive into prolog too
22:05:13 <Kaidelong> prolog is surprisingly useful for understanding haskell but that kind of discussion should probably be in #haskell-blah
22:05:27 <Kaidelong> which is slow right now so I'd be kind of you to liven it up
22:06:06 <Kron> oh
22:06:09 <Kron> what's haskell-blah?
22:06:23 <Kaidelong> it's a general chat channel filled with #haskell people
22:06:38 <ion> A channel for offtopic discussion.
22:06:48 <Kaidelong> so as not to end with the support channel having conversations in it that make it hard to actually ask questions about haskell
22:06:54 <Kron> gotcha
22:07:58 <ion> Well, this channel is for other Haskell-related discussion as well.
22:08:35 <Kron> <Kron> I'm trying to grok this one example of point free programming by partially applying dot operators
22:08:35 <Kron> <Kron> and I have no idea what's going on
22:08:35 <Kron> <Kron> http://en.wikipedia.org/wiki/Tacit_programming#Functional_programming the stuff here
22:08:35 <Kron> <Kron> x_x
22:08:35 <Kron> <Kaidelong> and that is a haskell question so you could discuss it in #haskell!
22:08:40 <Kron> nobody wants me ;_;
22:10:15 <Kaidelong> anyway what's going on is that foldr is a function that already exists that handles list recursion
22:10:24 <Kron> I know how foldr works, thankfully
22:10:30 <Kron> but this:
22:10:30 <Kron> p = (f .) . g
22:10:36 <Kron> that bit completely blew my mind away
22:10:38 <Kaidelong> oh, do you know about sections?
22:10:42 <Kron> ... sections?
22:10:44 <Kaidelong> @ty (+)
22:10:44 <lambdabot> Num a => a -> a -> a
22:10:48 <Kron> i know about currying
22:10:50 <Kaidelong> @ty (5+)
22:10:51 <Kron> do you mean currying?
22:10:51 <lambdabot> Num a => a -> a
22:10:55 <Kron> that looks like a curried function
22:11:02 <Kron> yeah I know how to curry functions
22:11:04 <Kaidelong> it is essentially a curried function!
22:11:09 <Kaidelong> it's just a special syntax for it
22:11:12 <Kron> ahh
22:11:12 <Kron> okay
22:11:13 <Kron> yeah
22:11:18 <Kaidelong> so when you see (f .) . g
22:11:22 <Kron> so (f .) and (. g) are basically curries
22:11:40 <Kaidelong> you could rewrite it (.) ((.) f) g
22:11:59 <Kaidelong> as if though (.) was just a regular prefix function
22:12:22 <Kron> hmmm
22:12:43 <mm_freak> i'd rewrite it to (.) f . g
22:13:03 <Kron> how does...how does the dot operator work, associativity-wise and stuff
22:13:09 <Kron> I can't mentally parse that
22:13:20 <Kaidelong> :i (.)
22:13:25 <Kron> (f . g . h) is what?
22:13:28 <mm_freak> Kron: (.) is associative
22:13:33 <Kron> f . (g . h)? (f . g) . h?
22:13:38 <mm_freak> (f . g) . h = f . (g . h)
22:13:41 <Kron> oh
22:13:42 <Kron> huh
22:13:45 <Kron> I didn't realize
22:14:01 <Kron> I guess that makes sense in a kind of "I'll have a moment of enlightenment 30 minutes from now" sort of way
22:14:17 <Kron> okay
22:14:25 <Kron> so...
22:14:26 <thebnq> its composition  :D
22:14:32 <Kron> p x y z = f (g x y) z
22:14:33 <Kron> hmmm
22:14:34 <mm_freak> for some reason i don't understand (.) is right-associative
22:14:41 <jrw> Kron, think about applying each to an argument: they're both f(g(h(x)))...
22:14:46 <Kron> g x y is (g x) y because currying
22:14:53 <mm_freak> so f . g . h is read as f . (g . h)
22:14:57 <mm_freak> it doesn't matter for the result
22:15:03 <Kron> so it's f ((g x) y) z
22:15:30 <Kron> then...
22:15:46 <Kron> yeah I don't know how to move to the next step o_o'
22:15:50 <mm_freak> Kron: i find composition with multiple arguments extremely confusing, even after > 5 years of haskell
22:16:07 <Kron> I understand that i'll almost never ever have to do this or even read this in realistic haskell programming
22:16:29 <Kron> it's just... overly unreadable and stinks of 'cleverness' in that sort of ugly unmaintainable kind of clever
22:16:30 <Kron> but still.
22:16:43 <Kron> I want to learn how this works because I think it'll make me a better functional programmer
22:16:47 <Kron> it's the principle of the thing D:
22:17:07 <Kron> besides I've seen my gf do things with applicative functors that boggle my mind
22:17:21 <mm_freak> better write "(f .) . g" as "\x -> f . g x"
22:17:23 <Kron> I think she made a point free quicksort once just because
22:17:27 <thebnq> its quite useful, you can think of:  f . g . h  as like a pipeline function, it those functions in order
22:17:56 <mm_freak> Kron: the better you understand "(f .) . g" the worse a functional programmer you will probably become =)
22:18:17 <thebnq> oh partially applied nevermind thats pretty confusing
22:18:31 <Kron> forbidden knowledge. You know just how to make me curious. D:
22:18:39 <pharaun> ha
22:18:55 <mm_freak> Kron: if you want something mind-boggling, look at this:
22:19:05 <mm_freak> > filterM (const [False, True]) "abc"
22:19:06 <lambdabot>   ["","c","b","bc","a","ac","ab","abc"]
22:19:07 * Kron braces mind
22:19:19 <Kron> ... that would be impressive if I knew what const or filterM did
22:19:24 <Kron> o.o
22:19:27 <Kaidelong> const x = x
22:19:31 <Kron> so id?
22:19:33 <mm_freak> const x y = x
22:19:34 <Kaidelong> err
22:19:36 <Kaidelong> yes
22:19:39 <Kaidelong> that's what I meant!
22:19:39 <monochrom> (const 4 . (g . h)) x = const 4 ((g . h) x) = 4 without even caring about g, h, x. this is a benefit of infixr (.)
22:20:41 <mm_freak> it's winning-the-shortest-code-contest-at-all-costs for the subsequences function =)
22:20:52 <Kron> okay what does filterM do?
22:21:22 <Kaidelong> @src filterM
22:21:22 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
22:21:28 <mm_freak> > filterM(pure[1<0..]) "abc"
22:21:29 <lambdabot>   ["","c","b","bc","a","ac","ab","abc"]
22:21:41 <mm_freak> Kron: it's the monadic variant of 'filter'
22:21:43 <mm_freak> :t filterM
22:21:44 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
22:21:55 <Kron> I wish that explained anything to me
22:21:58 <mm_freak> replace IO to get a feel for it
22:22:04 <mm_freak> replace m by IO to get a feel for it
22:22:04 <Kron> but at this moment monads are still basically a codeword for 'magic'
22:22:16 <Kron> "Why does it happen?" "Because monads." "Ah. D:"
22:22:36 <Kaidelong> well do you understand how lists are constructed?
22:22:42 <Kron> conses
22:22:45 <Kron> o.o
22:22:51 <mm_freak> Kron: ok, you've got a list of file names and you want to remove everything but regular files
22:22:57 <Kron> okay
22:23:00 <mm_freak> why can't you use 'filter' to do that?
22:23:04 <Kron> so all the .stuff?
22:23:07 <Kron> why can't we?
22:23:16 <Kron> filter with a lambda that takes a file name and returns a boolean
22:23:17 <mm_freak> :t filter
22:23:18 <lambdabot> (a -> Bool) -> [a] -> [a]
22:23:28 <mm_freak> there is no such lambda
22:23:37 <Kron> why wouldn't there be
22:23:51 <Kron> isn't it just any filename not starting with a .?
22:23:58 <mm_freak> no
22:24:06 <Kaidelong> @hoogle FilePath -> Bool
22:24:07 <lambdabot> System.FilePath.Windows hasDrive :: FilePath -> Bool
22:24:07 <lambdabot> System.FilePath.Posix hasDrive :: FilePath -> Bool
22:24:07 <lambdabot> System.FilePath.Windows hasExtension :: FilePath -> Bool
22:24:11 <mm_freak> regular file = non-directory, non-link, non-socket, ‚Ä¶
22:24:21 <Twey> Is there a package that provides a typeclass over typelevel naturals?
22:24:34 <mm_freak> Twey: what type of class?
22:24:41 <Kron> okay, so make a lambda that checks if something is a drive or link or socket or whatever?
22:24:41 <Twey> mm_freak: Singleton
22:24:53 <mm_freak> Twey: what about GHC.TypeLits?  it uses type families though
22:25:13 <mm_freak> Kron: what would be the type of that function?
22:25:25 <Kron> FilePath -> Bool
22:25:46 <Kron> it takes a FilePath and does repeated checks on it and returns the not . any I guess
22:25:47 <mm_freak> Kron: ok, say you pass "blah.txt" to that function
22:26:03 <mm_freak> blah.txt is a regular file right now, but a second later it's a socket
22:26:06 <mm_freak> what happens?
22:26:21 <Kron> ... files can become sockets?
22:26:26 <Twey> mm_freak: Doesn't seem to have an IsNat class; am I missing something?
22:26:35 <mm_freak> Kron: the user deletes the file and replaces it by a socket
22:26:53 <Twey> (or family)
22:26:55 <mm_freak> Twey: you don't need IsNat, you just need :: Nat
22:27:24 <Kron> well... if this whole function is lazily evaluated I guess it's not even going to be run until we start to do anything to those files, so I'm not sure... this will matter?
22:27:47 <Kron> I mean more generally, what if he just deletes the file
22:27:49 <mm_freak> Kron: ignore laziness for now
22:27:53 <Kron> doesnt' even have to make a socket
22:27:57 <Kron> if he deletes the file we'll have a bad list
22:28:08 <Kron> then i'm not sure
22:28:17 <mm_freak> your program is just an infinite loop:  main = forever (print (isRegularFile "blah.txt"))
22:28:27 <Kron> oh?
22:28:29 <Kron> how so?
22:28:38 <Kron> why not just print it once
22:28:39 <mm_freak> assuming‚Ä¶
22:28:41 <Twey> mm_freak: Slightly bigger picture: what's the translation of Agda {n : ‚Ñï} ‚Üí Foo n ?  I thought it went something like IsNat n ‚áí n ‚Üí Foo n
22:28:46 <mm_freak> Kron: to make my point =)
22:28:53 <mm_freak> where isRegularFile is your hypothetical function
22:28:57 <Twey> Or s/‚áí n/‚áí/ rather
22:29:08 <mm_freak> Kron: what would happen, when the user replaces the file by a socket?
22:29:25 <Kron> then it would start printing "False" after a while I guess
22:29:26 <mm_freak> Twey: forall (n :: Nat). Foo n
22:29:31 <Twey> Oh, right!
22:29:37 <Twey> Thanks
22:30:34 <mm_freak> Twey: or just construct Foo such that it can only be indexed by Nats, then the kind is inferred =)
22:30:39 <mm_freak> Kron: exactly
22:30:44 <mm_freak> Kron: there, you just proved True = False =)
22:31:21 <Kron> ?
22:31:37 <Kron> that... isn't... special?
22:31:48 <Kron> lik even if we keep printing random numbers and passing the new state tail recursively
22:31:53 <Kron> we'll get random numbers right?
22:32:00 <Kron> the function will print 1, 2, 1, 1, 2, 2, 2
22:32:03 <Kron> is this really special?
22:32:03 <mm_freak> Kron: a function can't change its mind and return something else on the second evaluation with the same argument
22:32:09 <mm_freak> Kron: remember that haskell is pure
22:32:17 <Kron> how can a system call be pure
22:32:24 <Kron> that's like the classic example of impure IO
22:32:30 <Kaidelong> a system call can't return a Bool though
22:32:33 <mm_freak> Kron: most of them can't be pure‚Ä¶  the system call itself is impure
22:32:40 <Kaidelong> so you can't use system calls to prove True = False
22:32:44 <mm_freak> Kron: however, the action (the recipe) for a syscall is pure =)
22:33:01 <Kron> oh
22:33:04 <mm_freak> getLine :: IO String
22:33:05 <Kron> just say that then
22:33:09 <Kaidelong> you can't even prove program = program because IO doesn't have an Eq instance
22:33:13 <mm_freak> getLine :: TheRecipeForGettingA String
22:33:14 <Kron> I haven't gotten used to putting IO before everything
22:33:24 <Twey> mm_freak: GHC disagrees: The first argument of `Term' should have kind `Nat', but n has kind `*'
22:33:39 <Kaidelong> AProgramThatReturnsA
22:33:39 <Kron> this hardly proves anything beyond that i'm not used to type declarations I guess
22:33:42 <Kaidelong> is probably better
22:33:47 <mm_freak> Twey: lpaste it
22:34:08 <mm_freak> Kaidelong: i agree
22:34:25 <mm_freak> Kron: you can read "IO" as "Program"
22:34:34 <mm_freak> and a Program String is a program that returns a String
22:34:51 <mm_freak> Kron: now to answer the question:  that's where filterM comes in
22:34:53 <Twey> mm_freak: Oh, I was missing the GADTs extension and I think it got syntactically confused
22:34:54 <mm_freak> :t filterM
22:34:54 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
22:34:59 <Kaidelong> haskell allows you to put programs together using the >>= operation
22:35:02 <mm_freak> Twey: you also need DataKinds
22:35:07 <Twey> I had DataKinds
22:35:12 <Kaidelong> and then you bind a program to the special handle "main"
22:35:17 <Kaidelong> and that's the one that gets run
22:35:19 <mm_freak> Twey: and KindSignatures
22:35:35 <mm_freak> Twey: (TypeFamilies implies KindSignatures, though)
22:36:03 <Twey> Oh, that's useful
22:36:32 <mm_freak> Twey: newtype ByteVec (n :: Nat) = ByteVec ByteString
22:36:39 <Kron> but you can't put filterM inside a normal function anyway, can you?
22:36:40 <mm_freak> length-indexed ByteString
22:36:44 <Kron> it has to be an IO function then
22:36:56 <Kaidelong> naah filterM is actually more general than that
22:37:02 <lpaste> Twey pasted ‚ÄúKind Mis-Match‚Äù at http://lpaste.net/94477
22:37:03 <mm_freak> Twey: that way you don't have to spill foralls all over the place
22:37:03 <Kron> so filterM hardly magically fixes anything, it's just a tool to simplify this sort of thing
22:37:15 <Twey> mm_freak: It still has to have trouble with this
22:37:18 <Kron> i mean, in this case, filterM doesn't do anything special
22:37:20 <Twey> s/has/seems/
22:37:34 <Kron> it's not like filterM magically makes it lock down to a non-IO list of results after
22:37:41 <mm_freak> Twey: TBound doesn't make sense
22:37:52 <mm_freak> Twey: Nat types are uninhabitated
22:37:57 <Kaidelong> but an IO list is exactly what you want
22:38:03 <Twey> Aha
22:38:06 <Kron> well if you want an IO list
22:38:09 <Kron> can't you just use an IO lambda?
22:38:29 <mm_freak> Kron: exactly, filterM is just a tool‚Ä¶  it solves your filter-by-file-type problem
22:38:35 <Kron> hmmm
22:38:46 <mm_freak> Kron: however, it's filterM, not filterIO‚Ä¶  it works for any monad, including the list monad
22:38:49 <mm_freak> that's what makes it magic
22:39:08 <mm_freak> > filterM (const [False, True]) "abc"
22:39:09 <lambdabot>   ["","c","b","bc","a","ac","ab","abc"]
22:39:13 <mm_freak> in this case m = []
22:39:43 <Kron> I still don't know what that's doing
22:39:45 <johnw> > filterM (const [True, False]) "abc"
22:39:46 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
22:39:53 <Kron> eh, it doesn't matter
22:39:58 <mm_freak> Kron: don't worry about that
22:40:24 <Kaidelong> why not? the list monad is kind of interesting and lets you do nondeterministic stuff like in prolog
22:40:36 <Kron> I don't fully understand the list monad
22:40:45 <Kron> I'll have to get to it eventually
22:40:48 <mm_freak> worry about the list monad, but don't worry about filterM in the list monad for now =)
22:41:06 <Kaidelong> @ty concatMap
22:41:06 <mm_freak> Kron: you probably already used the list monad without noticing ;)
22:41:07 <lambdabot> (a -> [b]) -> [a] -> [b]
22:41:09 <Kron> but I fail to be suitably impressed by something when I have no idea what's going on anyway
22:41:16 <Kron> yes yes I use every monad without noticing or something
22:41:22 <Kron> something about list comprehensions also being monads
22:41:30 <mm_freak> Kron: exactly
22:41:34 <Kaidelong> essentially if you have say
22:41:39 <Kron> whether it's a monad on some deep low level or not, i'm not conceptually designing code around an understanding of the list monad
22:41:42 <Kron> so the point is moot
22:41:47 <mm_freak> > do x <- [1..3]; y <- [10,20,30]; return (x + y)
22:41:48 <lambdabot>   [11,21,31,12,22,32,13,23,33]
22:42:04 <mm_freak> > [ x + y | x <- [1..3], y <- [10,20,30] ]
22:42:05 <lambdabot>   [11,21,31,12,22,32,13,23,33]
22:42:30 <mm_freak> one interpretation for both of these is:  x represents the values 1, 2 and 3
22:42:34 <Kaidelong> > "abc" >>= \x -> [x, toUpper x]
22:42:35 <lambdabot>   "aAbBcC"
22:42:43 <mm_freak> that's why the list monad is often associated with nondeterminism
22:42:57 <mm_freak> and all the monadic combinators are basically just shortcuts
22:42:57 <Kaidelong> and then the other function you need is (:[]), which is return for lists
22:43:04 <Kaidelong> > 'a':[]
22:43:05 <lambdabot>   "a"
22:43:12 <mm_freak> > replicateM 4 "01"
22:43:13 <lambdabot>   ["0000","0001","0010","0011","0100","0101","0110","0111","1000","1001","101...
22:43:51 <mm_freak> this is just a shortcut for:  do a <- "01"; b <- "01"; c <- "01"; d <- "01"; return [a,b,c,d]
22:43:54 <Kaidelong> so a list could be seen as returning many values like a nondeterministic result in prolog
22:44:08 <mm_freak> if you rewrite that to list comprehension, it should be easy enough to understand
22:44:22 <Kaidelong> concatMap has the effect of taking each nondeterministic result and running a nondeterministic computation on it
22:45:26 <mm_freak> Kron: in other words, monads aren't something magic, they are really just tools =)
22:45:34 <Kron> well obviously :$
22:45:37 <Kron> nothing's magic
22:45:56 <johnw> well, except magic ;)
22:45:58 <Kron> but when something is outside my ability to consistently mentally model, it's functionally magic
22:46:21 <Kaidelong> monads are a general model for contexts in which functions can deliver their results
22:46:22 <mm_freak> > sequence ["mM", "a4", "g", "i1", "c"]
22:46:23 <lambdabot>   ["magic","mag1c","m4gic","m4g1c","Magic","Mag1c","M4gic","M4g1c"]
22:46:44 <Kron> hmmmm
22:46:48 <Kron> unrelated question
22:46:52 <Kaidelong> results can be randomly distributed, nondeterministic, partial, or impure
22:47:05 <Kron> how often does haskell actually dump entire objects and build new ones in proper compiled code?
22:47:16 <mm_freak> Kron: all the time
22:47:24 <Kron> if I had a function on a big array that 'changed' one element of the array by returning a new array with a single element changed
22:47:29 <Kaidelong> it's garbage collected so it's more like it cleans up whenever it needs memory
22:47:33 <Kron> does ghc literally dump the entire array and build a new one?
22:47:40 <mm_freak> Kron: yes
22:47:50 <lpaste> Twey pasted ‚ÄúCouldn't match type `n0 + 1' with `1'‚Äù at http://lpaste.net/94478
22:47:53 <Kron> this strikes me as very inefficient
22:48:02 <thebnq> array? or list?
22:48:02 <mm_freak> Kron: yes, /this/ is inefficient =)
22:48:11 <Kron> array
22:48:30 <mm_freak> Kron: i use arrays all the time, but not where i would change single elements
22:48:36 <Twey> mm_freak: Can I get GHC to understand types like the above?  Or do I need to use IsSucc?
22:48:56 <mm_freak> Kron: for most things you would use data structures designed for immutability, like trees
22:48:56 <Kron> changing multiple elements can be abstracted into changing a single element multiple times
22:49:05 <Kron> ultimately modifying the array involves a repeated set of singular modifications
22:49:22 <mm_freak> Twey: "the above"?
22:49:22 <Kron> most trees I know in real life are meant to be mutable though
22:49:32 <Kron> self balancing trees and stuff with insertion and retrieval and deletion
22:49:39 <Twey> mm_freak: http://lpaste.net/94478
22:49:45 <mm_freak> Kron: no, they can be used in both paradigms
22:49:53 <mm_freak> Kron: they are not /designed/ for mutation
22:50:00 <mm_freak> it just happens that you can use them with mutation
22:50:18 <monoidal> Twey: the typenat solver requires GHC 7.6+
22:50:22 <monoidal> Twey: 7.7+
22:50:26 <Kron> does haskell really never compile away abstract functional code into state modifications?
22:50:33 <Kron> is it really impossible to do an in-place quicksort?
22:50:36 <Twey> Oh, there's my problem; thanks, monoidal
22:50:49 <monoidal> Twey: your example works in HEAD
22:51:00 <Kaidelong> well with immutable linked lists, yes, in principle, and no sort can be done in place
22:51:04 <mm_freak> Twey: also i'm not quite sure that your Fin type is correct
22:51:06 <monoidal> Twey: (though, unfortunately, even 7.8 will have a rather weak solver)
22:51:15 <Twey> Aw.
22:51:28 <mm_freak> Kron: it's very possible, and there are very fast implementations of that
22:51:29 <monoidal> Kron: you can use mutable data structures (see ST)
22:51:43 <mm_freak> Kron: for example in the vector-algorithms package
22:52:11 <Kron> but outside of using ST none of my code actually reuses any space?
22:52:11 <monoidal> Twey: (for example, GHC will not infer from x + 2 ~ 5 that x ~ 3.)
22:52:26 <mm_freak> Kron: that's a different question, and the answer is:  wrong
22:52:29 <Kron> even with tail recursive calls and the like? o_o
22:52:45 <monoidal> Twey: (essentially the only thing which is supported is addition of literals, like 2 + 3, and some degenerate simplifications such as 0 + x ~ x)
22:53:04 <Twey> monoidal: Why is that?  If you're going to make type-+ magic you might as well add special cases for that, no?
22:53:15 <mm_freak> Kron: tail recursion has nothing to do with that‚Ä¶  consider Data.Map, which is a balanced-tree-based implementations of key-value-mappings
22:53:32 <monoidal> Twey: I don't know the details, but it proved to be compilcated
22:53:36 <Twey> Ah
22:53:40 <Twey> That's a shame
22:53:50 <mm_freak> Kron: a new tree will be built, when you insert an item‚Ä¶  however, only one path of that tree will be different, so the tree rebuilding is actually a proper logarithmic operation
22:53:53 <monoidal> > tails [1,2,3,4]
22:53:54 <lambdabot>   [[1,2,3,4],[2,3,4],[3,4],[4],[]]
22:54:00 <Kron> i'm honestly not sure why people would use a balanced tree implementation with modern hash tables anyway, but I'm open to being educated on that matter
22:54:04 <monoidal> Kron: this takes O(n) memory
22:54:18 <Kron> hmmm
22:54:22 <Kron> I see
22:54:32 <Kron> a list of pointers to positions in the pre-existing list
22:54:33 <Twey> Kron: Sharing happens
22:54:35 <mm_freak> Kron: because hash tables are inherently imperative‚Ä¶  we do use HashMaps though
22:54:35 <Kron> because it's immutable
22:54:46 <Kron> that's quite neat
22:54:47 <mm_freak> Kron: which is basically Map with hashes as keys
22:55:06 <mm_freak> HashMap is about twice as fast as Map in most scenarios
22:55:28 <mm_freak> Kron: about space reuse:  this is called sharing
22:56:01 <mm_freak> Kron: here is an example:  when you write (x, x), then the value x in memory will be reused for both items of the tuple
22:56:25 <Kron> that's... quite interesting
22:56:43 <Kron> so basically haskell passes everything by reference because everything is immutable so it can
22:56:44 <Kron> ?
22:56:53 <mm_freak> Kron: it's natural‚Ä¶  since all regular values are immutable, they can as well be reused arbitrarily often
22:57:00 <Kron> fascinating
22:57:06 <johnw> immutability is amazingly useful
22:57:12 <Kron> i'll really have to re-evaluate the space efficiency of my code then
22:57:20 <Kron> I kind of assumed the data would be duplicated
22:57:22 <Kron> like in lisp
22:57:30 <mm_freak> that's why rebuilding a tree is an O(log n) operation and really just drops the old path and replaces it by the new one
22:57:35 <mm_freak> almost in-place
22:57:47 <Kron> hmm
22:57:52 <Kron> when you make a new tree
22:57:55 <Kron> how does that even work?
22:58:01 <Kron> it cant' directly link to the earlier tree can it
22:58:14 <Kron> or I guess it can for most branches
22:58:21 <mm_freak> Kron: just like adding an item to a list works
22:58:24 <Kron> a new tree with one tiny line of new branches to the one spot you changed
22:58:31 <Kron> and then links to the previous tree for every other branch
22:58:37 <mm_freak> say you have a list "abde", and you want to insert a 'c' in the middle
22:59:18 <mm_freak> that's 'a' : 'b' : xs, where xs = "de"
22:59:28 <mm_freak> you traverse the list and return 'a' : 'b' : 'c' : xs
22:59:56 <Twey> Kron: Laziness means it has to be done this way: xs might not even be evaluated yet
22:59:59 <mm_freak> the old prefix "ab" is dropped and replaced by "abc", the remainder of the list is reused
23:00:07 <Kron> iiiiiiinteresting
23:00:10 <Kron> hmmm
23:00:15 <Kron> which is why you avoid arrays
23:00:20 <Kron> you'd have to dump the whole thing
23:00:23 <mm_freak> not at all
23:00:23 <Twey> (likewise with the actual characters)
23:00:26 <mm_freak> arrays are very useful
23:00:26 <Kron> you can't reuse a part of it
23:00:31 <mm_freak> but not as a random-access data structure =)
23:00:46 <Kron> well I find it very conspicious that LYAH avoids talking about arrays and hash tables
23:00:51 <triliyn> Arrays are fine for random access, just not random updating, right?
23:00:55 <Kron> every other tutorial for every other language i've run into has talked about them
23:01:00 <mm_freak> triliyn: yeah, right
23:01:04 <Kron> random access?
23:01:07 <Kron> I don't understand o.o
23:01:14 <triliyn> Reading the nth value
23:01:16 <Kron> oh I see
23:01:20 <Kron> O(1) read time
23:01:21 <Kron> okay
23:02:16 <Kron> hmmm
23:02:18 <mm_freak> Kron: changing individual elements
23:02:19 <Twey> Kron: It's achieved by the hardware magic of having all the elements together in memory.  That's fine for reading, but it means that if you update it you have to copy the whole array (you can't copy just part of it, because that part won't be in the same place relative to the rest of the array)
23:02:40 <Kron> right
23:02:51 <Kron> either you copy the whole thing or create a kind of alternate lambda mask thing
23:03:13 <Kron> where it checks if you're accessing a modified variable and if not it references the old array
23:03:13 <triliyn> I've read about updatable arrays that store like a tree of diffs against the original array, but then access takes O(number of updates)
23:03:18 <Twey> Kron: The latter leads to O(n) lookup
23:03:23 <mm_freak> Kron: not just the O(1) read time‚Ä¶  arrays have another interesting quality in haskell they don't have in other languages:  arrays are lazy =)
23:03:23 <triliyn> Which can become unmanageable
23:03:23 <nisstyre> triliyn: zippers
23:03:31 <Kron> tell me
23:03:35 <Twey> Just so
23:03:42 <mm_freak> Kron: so you can construct an array in terms of itself
23:03:42 <Kron> is it possible to make mutable arrays and mutable Maps?
23:03:49 <nisstyre> zippers can update part of a data structure without copying the rest of it
23:03:50 <Twey> triliyn: But you can flatten it
23:03:53 <Kron> because I tried to make one earlier and kind of badly failed
23:03:57 <mm_freak> Kron: sure
23:04:08 <mm_freak> Kron: but you don't "make" them‚Ä¶  they are there and you use them
23:04:13 <mm_freak> if you want to
23:04:18 <Kron> right, you define one
23:04:20 <triliyn> Twey: yeah, I'm sure there are all kinds of refinements of the basic idea, but the naive implementation wouldn't be very useful
23:04:26 <nisstyre> and the nice thing is that you can create a zipper from any recursive data type (as far as I know)
23:04:31 <Kron> but while I know how to sort of define an arbitrary infinite linked list of things
23:04:46 <Kron> i don't know how to define an arbitrary infinite Map where each key has a value 2 x the key
23:04:53 <Kron> I tried to formulate one and just didnt' know how to do it
23:05:24 <Twey> Kron: Map.fromList [ (k, 2 * k) | k ‚Üê [0 ..] ]
23:05:27 <mm_freak> Kron: trees are generally strict in their structure, so you can't have infinite trees a la Data.Map
23:05:35 <mm_freak> Twey: that's bottom
23:05:42 <Twey> But yes, you get bottom
23:06:15 <triliyn> Is there a reason trees are usually strict?
23:06:23 <monoidal> it should be possible to have an unbalanced infinite tree
23:06:24 <triliyn> Is it just usually inefficient if they're not?
23:06:25 <Kron> o_o
23:06:29 <mm_freak> triliyn: spine-strict, and yes
23:06:30 <Twey> triliyn: It's useful if you're not going to update very often
23:06:31 <Kron> hmmm
23:06:44 <monoidal> but once you add rotation, there's no hope
23:06:47 <Twey> triliyn: Because trees are ordered by their keys
23:06:51 <mm_freak> triliyn: firstly the balancing makes it spine-strict, secondly it's a very useful strictness invariant
23:06:52 <triliyn> spine-strict basically meaning that they must be finite, right?
23:06:53 <triliyn> ahhh
23:06:54 <Athan> weird, i was just thinking about this exact topic....
23:07:04 <Kron> hmmmmmm
23:07:12 <Twey> triliyn: Key n + 1 might be the new root
23:07:13 <Kron> but the k <- [0..] thing tells me that if you search for k
23:07:16 <Kron> it'll generate 0 to k
23:07:21 <Kron> not just generate just k
23:07:26 <Kron> which is not what I wanted :(
23:07:40 <mm_freak> > [ (k, 2*k) | k <- [0..] ]
23:07:42 <lambdabot>   [(0,0),(1,2),(2,4),(3,6),(4,8),(5,10),(6,12),(7,14),(8,16),(9,18),(10,20),(...
23:07:54 <mm_freak> Kron: it's just an infinite list
23:07:56 <Twey> Kron: It's an infinite list of pairs (k, 2k)
23:08:11 <Athan> Dude!!!!!!!
23:08:11 <mm_freak> Kron: the M.fromList is the problem‚Ä¶  it would create a Map from that list
23:08:31 <Kron> right
23:08:44 <Kron> but can we make a thunk that generates exactly what we ask for and not extra stuff before or after it...
23:09:05 <mm_freak> Kron: depends
23:09:11 <mm_freak> (literally)
23:09:15 * Twey chuckles.
23:09:18 <Kron> do tell
23:09:45 <mm_freak> Kron: when the thing you want is in a substructure of that "extra stuff", then no
23:09:58 <Kron> hmmm
23:09:59 <Kron> right
23:10:08 <mm_freak> for example if that thing is a leaf of a tree, then asking for the thing will evaluate at least the path up to that thing
23:10:15 <Twey> Kron: You can generate a thunk for (e.g.) (2, 4), but the difficult part is how to find out where that thunk is
23:10:23 <mm_freak> > last (repeat 0)
23:11:00 <mm_freak> also i think it's a bad idea to think in terms of thunks
23:11:16 <mm_freak> think in terms of strictness and pattern-matching
23:11:22 <Kron> isn't that the proper way to think of haskell?
23:11:29 <mm_freak> far from it
23:11:35 <Kron> to understand how your code truly performs, in an O() sense, you need to understand how it thunks
23:11:44 <mm_freak> thunks are an implementation detail
23:11:44 <Kron> otherwise you'd just think [1..] would crash your program
23:11:58 <mm_freak> no, you wouldn't think that
23:12:03 <mm_freak> (:) is nonstrict
23:12:13 <Kron> implementation details have an annoying way of sneaking up on you when you make programs incredibly structurally inefficient
23:12:13 <mm_freak> so [1..] alone can't crash your program
23:12:23 <thebnq> the point of high level languages isn't to think about implementation :)
23:12:24 <Kron> you say strict and I say thinks and we mean the same thing
23:12:33 <Kron> we mean a knowledge of where haskell will stop and leave a calculation unfinished
23:12:36 <Kron> *thunks
23:12:37 <mm_freak> Kron: we don't
23:12:44 <mm_freak> Kron: strictness is a denotational feature
23:13:06 <Kron> I feel like bogosort shouldn't be implemented in any language, even haskell
23:13:20 <mm_freak> Kron: let me offer you a better perspective
23:13:36 <mm_freak> say you have a tuple:  tpl = (3, undefined)
23:13:51 <mm_freak> this is just a definition, nothing more‚Ä¶  it may not even end up in memory
23:14:13 <mm_freak> it gets interesting once you pattern-match on it:  the strictness of (,) plays a role here
23:14:57 <mm_freak> if you pattern-match it as "(x, y) -> z", at the point when z is evaluated it is ensured that tpl is a (,), but nothing more
23:15:29 <Kron> while you say that it's not important to think about thunks you've demonstrated a really phenomenal understanding of them so far, y'know?
23:15:38 <Kron> all the stuff about sharing and all the talk about things being strict or not
23:15:52 <Kron> you have a very exact knowledge of when something will necessarily be evaluated and when it won't
23:15:59 <Kron> that's ultimately what matters to me
23:15:59 <mm_freak> if you pattern-match as "(x, Just y) -> z", then at the point when z is evaluated, it is ensured that tpl is a (,), and the second component is a 'Just y' for some y, but nothing more
23:16:18 <Kron> I don't want haskell to just be magic, i want it to be a reliable deterministic system I can understand in my head
23:16:26 <mm_freak> in that case denotationally z = bottom
23:16:33 <mm_freak> because Just y = bottom
23:16:39 <pharaun> does ghc do some filesystem access caching?
23:17:01 <mm_freak> Kron: no, i don't think about thunks at all‚Ä¶  i don't even know how they are implemented
23:17:17 <Kron> but you know where they are
23:17:23 <mm_freak> Kron: yet i write very fast haskell code (i'm actually known for fast code) that behaves exactly like i want =)
23:17:46 <Kron> you also know that you can't have a thunk that generates substructures with uncomputed values for a value you want from it
23:18:04 <Kron> I think you know thunks very well, far better than me
23:18:17 <Kron> i don't really care about it on the kind of core 'bit model' machine code level
23:18:26 <mm_freak> i know semantics
23:18:34 <Kron> I do care about... y'know, the graph diagram of things being generated in the bowels of the system
23:18:40 <Kron> when and how things are evaluated and processed
23:18:45 <mm_freak> and it boils down to statements like this:  "x is known implies that y is known"
23:18:50 <mm_freak> this is really all you need
23:18:55 <mm_freak> ‚Ä¶ in haskell
23:19:15 <mm_freak> Kron: you are a C programmer, aren't you?
23:19:18 <Kron> I'm not
23:19:23 <Kron> i'm actually learning C right now
23:19:28 <Kron> my language of choice is common lisp
23:19:37 <Kron> I find C to be extremely ugly, to be honest
23:19:47 <Kron> but I can understand its purpose
23:20:09 <mm_freak> ok, in either case you really need to get as far away as you can from operational details‚Ä¶  they will stand in your way of learning haskell
23:20:37 <Kron> you've also told me that learning how to properly parse an elaborate tacit programming expression will stand in the way of me learning haskell
23:20:43 <mm_freak> operational details will make you write ugly code that doesn't even perform very well
23:20:48 <Kron> I don't see how learning anything will hurt me learn haskell
23:20:52 <Kaidelong> writing haskell people generally seem to place generality and composability above performance and readability over it as well at first
23:21:49 <mm_freak> Kron: it is hurting you right now‚Ä¶  you're translating clisp concepts to haskell
23:21:49 <pharaun> ^
23:21:52 <Kaidelong> usually you don't really have to worry about performance unless you're doing something wrong or you profile your program and find a particular issue is causing trouble
23:22:18 <Kron> if I said I studied C you'd say i was translating C concepts to haskell
23:22:23 <Kron> I'm simply translating programming concepts
23:22:29 <Twey> ‚ÄòRoot af all evil‚Äô, &c.
23:22:31 <mm_freak> Kron: imperative programming concepts
23:22:58 <Kaidelong> common lisp is functional, supposedly, although my experience with it didn't speak strongly to that
23:23:08 <mm_freak> common lisp is very imperative
23:23:10 <Kron> while I love functional programming, I do feel a need to at least acknowledge that ultimately what I make is built on an imperative core
23:23:15 <Kron> common lisp is very imperative, sadly
23:23:28 <mm_freak> Kron: exactly, and that's where you're wrong
23:23:47 <mm_freak> Kron: and i know how unbelievable this sounds!
23:23:48 <Kaidelong> well mm_freak it does become assembler eventually
23:23:56 <Kron> I don't see how I'm wrong
23:24:03 <mm_freak> after all i came from C++, where full control over every detail is the default =)
23:24:14 <Kaidelong> GHC is built on top of this conceptual machine that I forgot the name of
23:24:25 <Kaidelong> which allows fundamentally functional computation
23:24:30 <Kron> we live in a hardware called reality built on an operating system of physics
23:24:35 <Kron> ultimately, stuff is pretty imperative
23:24:42 <Kron> bogosort is always going to be bad
23:24:50 <Kron> (without a lot of memoization I guess)
23:24:50 <Kaidelong> quantum bogosort
23:24:51 <mm_freak> Kron: the execution of stuff is imperative, but the denotation is not
23:25:00 <Kron> yeah qbogo is quite funny
23:25:15 <mm_freak> Kaidelong: spineless tagless g-machine
23:25:34 <Kron> I don't know what you mean by denotation
23:25:59 <mm_freak> Kron: the source code that defines your program
23:26:34 <mm_freak> Kron: obviously "map sin [0..3]" will eventually get executed using FSIN instructions, following a linked list of pointers, etc.
23:26:39 <Kaidelong> but no short of using something like Harpy you and the compiler are both generally thinking functionally
23:26:42 <mm_freak> but all that is irrelevant to your haskell coding
23:26:53 <Kaidelong> which is what allows techniques like deforestation, fusion, rewrite rules, etc
23:27:02 <mm_freak> to a haskell coder "map sin [0..3]" is the list of sin mapped over [0..3]
23:27:14 <Kron> I hardly think it's irrelevant. I'd love to know about deforestation, fusion, rewrite rules
23:27:33 <Kaidelong> they're all functionally defined as far as I know
23:27:36 <Kron> I'd love to learn about... normal head form or whatever it is the system uses to evaluate expressions lazily
23:27:47 <ibid> Kron: graph reduction
23:27:54 <mm_freak> Kron: weak head normal form, and that's indeed something you should care about =)
23:28:04 <Kron> and I'd love to not define a fibonacci function the naive way, which I'm pretty sure would generate bad results even in haskell without memoization
23:28:05 <ibid> Kron: weak head normal form is just the name for a value
23:28:09 <mm_freak> graph reduction you shouldn't care about‚Ä¶  that's implementation again
23:28:24 <Kron> weak head normal form is one of those 'implementation' details that I think should be learned
23:28:30 <Kaidelong> knowing how GHC is implemented is not something most of us know
23:28:37 <mm_freak> Kron: no, it's not
23:28:42 <mm_freak> WHNF is semantics!
23:28:44 <ibid> mm_freak: graph reduction is the canonical semantics for lazy evaluation.  it's actually not used by implementations because it's so damned slow
23:28:45 <Kaidelong> actually weak head normal form is important for writing haskell programs and optomizing them
23:29:01 <Kron> thank you :$
23:29:32 <pharaun> i'll like to learn how core/ghc is implemented someday but for now i can program basics without that
23:29:34 <Kaidelong> haskell has this concept of non-strictness by default which is a real snag you don't generally get with most other programming languages because the only way for things to be non-strict is for them to be an uninvoked function
23:29:43 <mm_freak> ibid: "so damned slow" is exaggerated‚Ä¶  my toy G-machine compiler produced quite decent code =)
23:30:11 <ibid> mm_freak: yeah, but G-machine is already beyond basic graph reduction :)
23:30:17 <Twey> I want mass-produced Reducerons ‚òπ
23:30:22 <mm_freak> ibid: it's not really ;)
23:30:30 <mm_freak> ibid: STG is beyond
23:30:33 <Kaidelong> so if you don't evaluate things in the right place, sometimes a massive mass of uninvoked function calls builds up
23:30:51 <Kaidelong> it's the actual reason why foldl is worse than foldr
23:30:58 <Kron> I'm not an idiot or some wayward lost child because I'm a bit curious about what's actually happening under the hood and I'd like to learn more '^^
23:31:04 <Kaidelong> and why people use foldl' instead
23:31:05 <pharaun> eventually :)
23:31:09 <Kron> that's actually why I started learning about the whnf and stuff
23:31:11 <mm_freak> Kron: anyway, i ignore implementation details completely‚Ä¶  if you feel that you can't ignore them, that's your choice, but you /will/ write bad haskell code, because you ignored important stuff and paid attention to irrelevant details
23:31:12 <Kron> folding
23:31:19 <pharaun> Kron: but for now its probably more usefull to learn haskell and then once you have better feeling
23:31:25 <mm_freak> Kron: and again, i'm known for high performance haskell code
23:31:26 <pharaun> start learn the deeper implementation detail.
23:31:33 <Kaidelong> there is #ghc with people who probably know about this stuff
23:31:37 <ibid> mm_freak: both are.  all the G-machines are attempts to make graph reduction compile decently.  the distinction i'm trying to make here is between graph reduction as the abstract semantics of lazy eval and G-machine which is a compilation scheme for it
23:31:41 <mm_freak> Kron: code that sometimes outperforms C =)
23:31:53 <Kron> I wish you wouldn't talk down to me like this
23:32:04 <Kron> like I understand the implication when you ask me if I'm a C programmer
23:32:10 <ibid> mm_freak: graph reduction for me is what Wadsworth talked about in his PhD thesis :)
23:32:20 <Kron> no I'm not some idiot who can't possibly fathom anything not fitting into a neat imperative programming paradigm :$
23:33:03 <ibid> (yes, i've had the thesis as a interlibrary loan)
23:33:07 <mm_freak> Kron: i'm not talking down to you‚Ä¶  this is just something that happens all the time
23:33:35 <Kron> yes, and you're known for high performance haskell code and I /will/ write bad code
23:33:48 <Kaidelong> I think part of the problem is that GHC is a huge, complex, optomizing compiler and I'm not sure there are many people with a very comprehensive understanding of how it works
23:34:06 <Kaidelong> kind of like GCC or SBCL
23:34:34 <mm_freak> Kron: you may be taking this the wrong way‚Ä¶  read those as separate statements, please
23:35:10 <Kaidelong> he was saying if you don't learn higher level concepts you'll write bad code because you won't know of the gajillion different ways there are to do things, I guess
23:35:38 <Kron> I can't learn which of those gajillion different ways are good ways to do things unless I start learning what's actually happening
23:35:52 <Kron> I didn't understand code sharing until the explanation you've all given me today, in this channel
23:36:16 <mm_freak> Kron: if you think imperatively, then idiomatic haskell will intuitively feel slow and quirky, when in fact it's the proper, efficient way to do it
23:36:20 <Kron> and prior to today I figured haskell's obsession with trees and lists was possibly more than a little unwarranted and ridiculously space inefficient. I know better now
23:36:44 <mm_freak> Kron: the reason i made those statements is that i wanted to provide some reasoning why you shouldn't ignore my advice
23:36:45 <Kaidelong> I think the obsession with lists is not actually a good idea
23:36:49 <Kron> everyone says their pet language is the 'proper' way to do stuff so I'll take that with a grain of salt
23:37:15 <Kaidelong> although they are a great way to represent nondeterministic computation, not the best data structure
23:37:19 <mm_freak> Kron: this is not about the pet language‚Ä¶  you are already programming in haskell, so this isn't about language choice
23:37:26 <Kron> I assumed haskell lists weren't real lists
23:37:36 <Kron> they seem more like... abstract contracts of linear chains of data?
23:37:39 <mm_freak> Kron: depends on what you mean by "real lists" =)
23:37:44 <Kron> I donno, lisp made it seem more explicit that were conses
23:37:51 <mm_freak> Kron: the line between data structure and control structure is very thin in haskell =)
23:37:58 <Kron> it's even thinner in lisp, I assure you
23:38:10 <Kaidelong> Kron: the way I think of it is that it's like a button you can push that says "get another value"
23:38:11 <Kron> the line between data structure and control structure is gapingly wide in comparison
23:38:15 <Kaidelong> until eventually it's like
23:38:17 <Kaidelong> "I'm out"
23:38:51 <Kaidelong> lists in haskell were easy for me to grasp because my dad made me learn a language called Icon, descended from SNOBOL
23:39:06 <Kaidelong> which was an imperative language where you could "suspend" instead of return
23:39:17 <Kaidelong> returning a value but not losing where you were
23:39:17 <Kron> I found lists reasonably easy to grasp from my lisp background, but lists are homogenous here which is interesting
23:39:19 <triliyn> Like coroutines?
23:39:20 <Kron> interesting
23:39:22 <Kron> continuations?
23:39:27 <Kron> sounds like scheme's call/cc
23:39:31 <Kaidelong> coroutines or generators, yeah
23:39:34 <Kron> nice!
23:39:41 <Kaidelong> continuations are one way to implement coroutines
23:39:53 <Kron> I don't fully understand continuations or coroutines, so I'll take your word for it
23:40:13 <Kaidelong> a continuation is really very simple and I thought LISP used them everywhere, OCaml people do
23:40:16 <Twey> Kron: It's a little different than the Lisp syntax.  Lisp has *code* that is data, whereas Haskell has *control* that is data
23:40:16 <dolio> The sense in which Haskell data structures can also be control structures is not really the same as the way that lisp data structures are so.
23:40:27 <mm_freak> Kaidelong: scheme, not lisp =)
23:40:29 <triliyn> I know generators from python, but I don't really understand coroutines in full generality
23:40:58 <Kron> lazily evaluated haskell data structures as implicit code is really a lot less generic and powerful than lisp I think. It is very expressive though
23:41:05 <Twey> Kron: When you say code and data are the same in Lisp, you're talking about syntactic similarity, whereas in Haskell data structures are actually directly used for control flow
23:41:05 <Kaidelong> a continuation is essentially just a function generated at runtime that has all the information you need to "continue" the task that was interrupted to do whatever
23:41:06 <mm_freak> triliyn: python generators : coroutines = exceptions : general continuations
23:41:20 <mm_freak> generators are a useful special thing
23:41:24 <mm_freak> coroutines are the general thing =)
23:41:32 <Kaidelong> Kron: but lisp has literally no type safety and that's part of the price you pay for powerful metaprogramming features
23:41:42 <Kaidelong> a price I personally think is worth it
23:41:43 <Twey> Kron: Laziness doesn't totally replace templates (Haskell has Template Haskell) but it goes a long way
23:41:45 <triliyn> mm_freak: yeah, I know what they are, it's just that... I don't have an intuitive sense of what you can do with them
23:41:49 <Kron> I like that price too, to be honest
23:41:52 <Kron> but I'm biased
23:41:55 <Kaidelong> I'm actually not a big fan of strong static typing
23:42:03 <Kron> i'm here to learn a new style so I won't talk about type systems
23:42:03 <mm_freak> triliyn: have you used conduits, iteratees or pipes? ;)
23:42:09 <mm_freak> triliyn: or free monads? =)
23:42:33 <triliyn> mm_freak: I don't think I've used any of those things
23:42:56 <mm_freak> triliyn: have you generated a list in an unfold/iterate and then consumed it in a fold?
23:42:56 <Twey> Kron: Particularly, Haskell ‚Äòprograms‚Äô (in IO) are built up as first-class objects, which is much the same as happens in Lisp but with more type-safety
23:42:59 <triliyn> (actually, the set of things I've "used" is very small, especially compared to the set of things that I feel familiar with)
23:43:13 <Kaidelong> however haskell/ML data structures are useful even when they have nothing to do for control, because they're extremely easy to reason about
23:43:17 <Twey> Kron: (but IO is opaque, so not quite as powerful there)
23:43:25 <johnw> one thing I don't hear mentioned often about "strong" static type systems is how much easier they make it to heavily refactor legacy code
23:43:43 <Twey> johnw: Do you not?  That's the main advantage I hear touted :√æ
23:43:45 <johnw> I say this because I've been doing that for the past 3 days, and I don't know how I would do this without lots of types constraining my actions
23:43:56 <Kaidelong> they allow for the pattern matching syntax which lets you do the equational reasoning thing ML-likes are so well known for
23:44:11 <johnw> I fractured this code to the point that I had to comment out 90% of it, and I'm just working now to bring it back to life under the new regime
23:44:19 <mm_freak> johnw: my favorite feature of haskell changes every week
23:44:19 <Kron> in languages like common lisp you could constrain yourself voluntarily
23:44:36 <Kron> set up compiler assertions that certain values have to be obey certain rules
23:44:40 <Kron> but it's all up to you really
23:44:47 <Kaidelong> the problem is that because other code you're interfacing with may not, your equational reasoning rules may be worthless
23:44:52 <Kron> right
23:44:53 <Kron> like
23:44:57 <johnw> Kron: assertions don't really help in this particular case
23:45:01 <Kron> no other language on the planet quite has Haskell's IO data type
23:45:05 <johnw> otherwise I'd be spending weeks, not days, tracking down assertion failures
23:45:14 <Kron> in Haskell you can just look at a type declaration of a function and immediately know if its safe
23:45:15 <Kaidelong> Agda?
23:45:16 <mm_freak> Kron: agda, idris, ‚Ä¶
23:45:19 <Kron> safe from external attack and stuff
23:45:25 <Kaidelong> also mercury has a kind of IO annotation
23:45:26 <Kron> ah true
23:45:27 <Kron> o.o
23:45:27 <Twey> Agda literally has Haskell's IO type :√æ
23:45:29 <johnw> yeah, I like agda a lot too
23:45:34 <Kron> I didn't think of agda OR Idris
23:45:42 <Kron> I shall amend to 'most'
23:45:45 <triliyn> I don't know about agda, but isn't idris like a direct descendent of haskell?
23:45:46 <Kaidelong> also .NET, internally, has something kind of like IO
23:45:48 <Kaidelong> or so I heard
23:45:50 <Twey> triliyn: Yes
23:45:52 <mm_freak> Twey: not quite‚Ä¶  agda has two IO types, none of which is exactly haskell's IO
23:45:52 <Kron> idris is built in haskell I think
23:45:54 <Kron> but it still coutns
23:45:56 <Kron> *counts
23:45:56 <Kaidelong> but it's for the benefit of the compilers, not the languages
23:46:07 <Twey> mm_freak: Really?  I thought Agda's IO monad was just an FFI binding to the Haskell one
23:46:13 <mm_freak> Twey: one is inductive, programs being finite, the other is coinductive, so you need guarded corecursion
23:46:20 <dolio> Twey: No. It can't be, really.
23:46:24 <Twey> Hrm.  Okay.
23:46:26 <triliyn> oh, speaking of idris
23:46:30 * Twey has never actually done IO in Agda
23:46:44 <triliyn> or well, I don't know, maybe that's off topic for here
23:47:01 <Twey> ATS has purity control too, and even C nowadays :√æ
23:47:15 <triliyn> Is ATS that thing I've heard of with "linear types"?
23:47:15 <dolio> I suppose it could be, but then you wouldn't be able to write productive, potentially infinite programs.
23:47:26 <dolio> At least, not without turning off the termination checker.
23:47:26 <mm_freak> Twey: C as purity annotations, but it doesn't properly check them
23:47:30 <Kron> ATS is that super haskelly C thing
23:47:32 <Twey> Aye
23:47:35 <Twey> Kron: Err
23:47:38 <Kaidelong> haskell has weak metaprogramming facilities in the traditional sense but conventional ML style programming is basically something like metaprogramming already
23:47:46 <mm_freak> Twey: and it's not really C that has them, it's GCC-C =)
23:47:50 <Kaidelong> and haskell is out of the ML tradition
23:47:54 <Twey> mm_freak: Yeah, I was about to say :√æ
23:47:59 <pharaun> johnw: i love the type safeness with refactoring, i do *heavy* amount of refactoring at work in python
23:48:08 <Twey> Kron: ATS is its own thing.  I don't think it's apt to compare it to Haskell.
23:48:19 <mm_freak> Kron: the next super-haskelly C thing is idris =)
23:48:19 * Kron laughs
23:48:19 <pharaun> johnw: and that experience has made me really like the strong static typing of haskell *lots*
23:48:25 <mm_freak> it has dependent types and all the fancy stuff
23:48:27 <johnw> pharaun: yeah
23:48:29 <Kron> I guess I'm suffering from that hindu-kush mountains effect
23:48:30 <Twey> Though they do converge in places, they come there rather differently.
23:48:44 <Kron> to me practically every super functional super strongly typed programming language is "haskelly"
23:48:45 <johnw> Kron: what is that?
23:48:50 <dolio> It kind of has dependent types, if you squint.
23:48:51 <Twey> mm_freak: Except it has mandatory GC ‚òπ
23:48:51 <Kron> everything is viewed through the lens of haskell
23:49:04 <Kron> the british first ran into india through the northwest and the hindu kush mountains iirc
23:49:06 <Twey> dolio: What, Idris?
23:49:09 <dolio> ATS.
23:49:13 <Twey> Ah, yes
23:49:17 <Kron> so the entirely of india, all the billion people and like fifty nations and zillions of ethnic groups
23:49:21 <mm_freak> Kron: lazy, non-strict by default, statically typed
23:49:22 <Kron> became "hindustan"
23:49:24 <Kaidelong> Haskell has become something like what LISP was once, a common language for expressing ideas in a programming language independent ways
23:49:31 <johnw> Kron: ahh
23:49:33 <triliyn> Dependent types look really cool but so weird
23:49:35 <Kron> they just kind of blanket labelled the whole zone past the mountains as "more hindus, we guess"
23:49:47 <Twey> Kron: That's not an unusual story :√æ
23:49:49 <triliyn> I've read the Idris tutorial thing like three times and each time my eyes have simply glazed over
23:49:52 <Kron> so yeah from where I'm coming from, it's all haskell to me
23:49:54 <Kron> D:
23:49:55 <pharaun> johnw: i think some of the finer point with some of this just comes with breadth of experience with heavy amount of refactoring/upkeeping/maint project which often lots of people neglict to pay attention to
23:49:57 <triliyn> (but each time, there is slightly less glaze than the last)
23:49:58 <Twey> See also: ‚ÄòAmerica‚Äô, ‚ÄòThe Orient‚Äô
23:50:02 <pharaun> when they are comparing and considering languages :)
23:50:02 <Kron> lol yes
23:50:20 <Twey> triliyn: Do you know Agda?
23:50:24 <Kaidelong> there is Disciple, which is supposedly just a different haskell compiler, but in practice works more like an imperative language
23:51:00 <mm_freak> Kaidelong: that applies to the first drafts of disciple
23:51:02 <triliyn> Twey: I don't know Agda, but I read a bit about it once and didn't find it any less mind-boggling than Idris
23:51:13 <mm_freak> Kaidelong: but it doesn't really work that way
23:51:18 <triliyn> I think I'm close to getting dependent typing, really... but "close", not "there"
23:51:20 <Kaidelong> actually one area where haskell is very different from the MLs is that imperative programming in haskell feels less like a kludge, even though you'd expect the opposite, exactly because of the restriction of imperative stuff to an IO context where you can treat things in an imperative way
23:51:31 <Twey> triliyn: It's not, but it's more stable, it has less magic, and there's more information to help you get started
23:51:43 <Kaidelong> in the MLs it feels like you're doing something naughty
23:51:44 <triliyn> hmmm
23:51:47 <mm_freak> Kaidelong: here is an interesting reasoning:  haskell critically depends on non-strict semantics for its IO system
23:52:08 <triliyn> I actually really like the treatment of IO stuff in haskell and I wish more languages would do it
23:52:15 <Twey> triliyn: Andres L√∂h has a nice tutorial on implementing the dependent lambda calculus, too, which is quite enlightening in its lack of complexity
23:52:19 <triliyn> Though I've heard it's kinda controversial for reasons I don't understand?
23:52:22 <Kaidelong> and disciple's big thing was strictness by default, right?
23:52:26 <pharaun> triliyn: i do kind of wish that IO was broken up a bit more
23:52:33 <pharaun> such as read/write, network/etc
23:52:37 <Twey> Kaidelong: Effect-typed functions
23:52:37 <mm_freak> Kaidelong: exactly
23:52:47 <pharaun> but there are some stuff out there to assist with that *shrugs*
23:53:17 <Kaidelong> disciple actually looked really cool back when I was peeking at it, I wonder if it is still alive
23:53:22 <Twey> pharaun: It's difficult to do, though
23:53:31 <dolio> It is still alive.
23:53:33 <triliyn> pharaun: I got the impression that the complaints were more about representing it as a monad as opposed to... something else
23:53:34 <mm_freak> pharaun: you can have that
23:53:59 <triliyn> But it's been a long time since I read about it and the arguments against haskell's system were mostly blog post comments, so not very informative
23:54:03 <mm_freak> IO is the catch-all everything-impure-monad
23:54:05 <Twey> pharaun: You have to guarantee the well-behavedness of the interfaces you're trying to compartmentalize, that e.g. ‚Äònetwork‚Äô won't ever let you write a file (which is obviously not true if an FTP server is running)
23:54:14 <Kaidelong> triliyn: the other major concept is the one mercury uses, which is evaluating things using linear logic
23:54:46 <Kaidelong> which I think makes less sense to me than encapsulated, but reusable values in programs
23:54:59 <Kaidelong> but I can see the appeal of having a perfectly normal value restricted to only be used once
23:55:00 <dolio> Uniqueness types for I/O doesn't actually make any sense, really.
23:55:11 * Twey blinks.
23:55:13 <Twey> dolio: Why not?
23:55:13 <dolio> But it's effective.
23:55:31 <triliyn> Are uniqueness types and linear types the same thing?
23:55:33 <dolio> For the same reason that World -> (a, World) doesn't make sense as an IO implementation.
23:55:40 <dolio> No, not exactly.
23:55:43 <Twey> triliyn: Uniqueness types are a weaker form of linear types
23:55:52 <Twey> You can ignore them
23:55:54 <triliyn> hmm, okay
23:56:01 <Twey> Linear types have to be used (i.e. destroyed)
23:56:07 <mm_freak> Twey: because it replaces a proper temporal model by an "ok, i just promise that i won't look again" hack
23:56:25 <triliyn> I read a very small amount about uniqueness types because a paper I was reading mentioned Clean
23:56:28 <Twey> Mmm
23:56:42 <triliyn> And they didn't seem particularly interesting
23:57:00 <triliyn> I still haven't found a nice explanation of linear types, though I don't remember if I've looked very hard
23:57:03 <mm_freak> uniqueness types are interesting for some things
23:57:09 <mm_freak> but not for the I/O system
23:57:11 <Twey> They're interesting for resource management
23:57:12 <Kaidelong> linear logic is hard enough to grasp on its own
23:57:26 <Kaidelong> at least I never quite managed
23:57:30 <Kaidelong> I should try again
23:57:31 <triliyn> hmmm
23:57:44 <triliyn> I might try looking up "linear logic" instead of "linear types"
23:57:44 <Twey> triliyn: The basic idea is that operations can ‚Äòuse up‚Äô a value, so it no longer exists
23:57:55 <mm_freak> Kaidelong: don't‚Ä¶  it just makes you sad that haskell doesn't have them =)
23:57:58 <Twey> (and must, with linear types)
23:58:04 <Twey> Hehe
23:58:10 <Kron> o.o
23:58:11 <Kron> huh
23:58:16 <Kron> using up values? that's kinda cool
23:58:43 <pharaun> Twey: i know, but i guess for me, for ex if i am writing a network library i would like to assert that it does not write to a file for ex
23:59:00 <Twey> Kron: Rust has the basic idea down, as does ATS
23:59:06 <pharaun> mm_freak: yeah i know there are some libraries and um free monads that i can use to break it up a bit
23:59:12 <Kron> hmmm
23:59:17 <Twey> And‚Ä¶ FORTH, I guess
23:59:20 <Kron> while I'd love to keep discussing this this is way past my bedtime
23:59:30 <mm_freak> Twey: except that ATS has a sensible type system =)
23:59:31 <donri> are STRefs uniqueness types?
23:59:31 <Kron> seeya folks
23:59:42 <Kron> had a nice discussion :D
23:59:56 <mm_freak> but i don't want to start another language-bashing session =)
