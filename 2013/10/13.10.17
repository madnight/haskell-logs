00:00:40 <earthy> even though we're doing a greenfields development currently
00:01:16 <sopvop> You should abuse your team until they learn haskell, or commit suicide.
00:01:51 <earthy> sopvop: we do C#, which has Linq and lambdas, and I consistently push the use of immutable data structures and lazy evaluation
00:02:19 <sopvop> lazy evaluation is overrated
00:02:36 <earthy> yes, I run into limitations of the type system, quite regularly. but not quite so regularly as to make the switch to haskell make business sense
00:02:45 <earthy> sopvop: yes and no
00:03:01 <Kaidelong> lazy evaluation is incredibly useful when it is not the default
00:03:09 * earthy is with kaidelong
00:03:38 <earthy> C# is strict by default. adding laziness tends to improve code clarity as well as performance
00:03:53 <earthy> ofcourse, you have to use good judgement as to when
00:04:38 <davesq> earthy: try f# as a gateway drug? :)
00:04:51 <sopvop> Sounds like trying to crossbreed snake and a hedgehog to get a barbed wire
00:05:45 <earthy> davesq: good idea. now I have to go learn F# on top of having to learn C#. :)
00:06:21 <davesq> you can write very c#ish f#, then adopt more FP-like features as everyone becomes comfortable
00:06:22 <earthy> (I was hired with *no* C# knowledge but on the basis of a.o. my haskell knowledge)
00:06:35 <Kaidelong> F# pretty much is C# with a different syntax, the main difference is in the libraries, although it does have some cool features like workflow syntax, which I think is nicer than linq syntax
00:06:49 <earthy> I don't do linq syntax, actually
00:07:09 <Kaidelong> davesq: why not just use C# functionally?
00:07:21 <Kaidelong> C# is actually quite good as a functional language
00:07:30 <Kaidelong> and that's how I generally used it
00:07:38 <earthy> to my mind in C# the .Select ( i.e. >> ) and .SelectMany ( >>= ) and .Aggregate (fold) are clearer
00:08:00 <Kaidelong> .Select is fmap not >>
00:08:03 <sopvop> can F# do higher-rank polymorphism?
00:08:08 <davesq> Kaidelong: agree, but for f#: 1) immutable by default 2) no nulls 3) curried functions 4) sum types 5) terser than c#, esp for functional stuff
00:08:11 <earthy> yah, I've not done Haskell for too long ;)
00:08:17 <Kaidelong> .NET type system doesn't allow it unfortunately
00:08:38 <Kaidelong> so we can't have a proper monad typeclass equivalent, but we get close enough to have an equivalent of do notation
00:08:42 <earthy> davesq: all true. but only 3 I've found to be truly an issue
00:09:12 <earthy> (but that can be alleviated by introducing lambdas)
00:09:56 <earthy> what I *have* missed (more than once) is existential types and higher rank polymorphism
00:10:22 <earthy> mostly existential types though
00:10:39 <Kaidelong> davesq: value types in C# are immutable by default and in any .NET language, and if you're doing it functionally you're generally getting parameters passed by value, not references, so 1) isn't that big an issue. F# doesn't guarantee non-nullable variables when interacting with foreign code which is a lot of the time, and C# now supports non-nullable variables. 3, 4, 5 are all quite strong though
00:11:19 <earthy> non-nullable variables of reference types? that's new to me
00:11:50 <Kaidelong> I think it was around when they were adding the static testing stuff in System.Diagnostics
02:12:09 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://j.mp/GOh7za'
02:12:09 --- topic: set by johnw!~johnw@c-98-214-70-173.hsd1.il.comcast.net on [Mon Oct 14 14:29:26 2013]
02:16:18 <Saizan> mercwithamouth: RWH has some worked examples which should include structuring of code i think
02:19:12 <AshyIsMe> so what's a well written open source haskell project that's worth reading the source of?
02:19:29 <companion_cube> AshyIsMe: you can try XMonad
02:19:48 <AshyIsMe> ah yeap, cool
02:19:56 <Saizan> i guess there are some FP or Haskell specific patterns we should collect, like trying to structure libs as (E)DSLs or using polymorphism for correctness on top of abstraction
02:20:00 <AshyIsMe> i should get around to dual booting linux on this macbook too
02:23:50 <pxqr> fromString = myFn . Data.ByteString.Char8.pack
02:23:57 <pxqr> i'm doing this wrong?
02:24:39 <startling> pxqr, please don't use Char8. That should work, though, for a limited value of "work".
02:25:06 <pxqr> oh, I can just fromString = myFn . fromString
02:25:10 <pxqr> :>
02:29:12 <danilo2> Hi! Im playing with haskell generics and I've found something very strange. Why one of the following codes work and the second not? import Generics.Deriving.Show;
02:29:16 <danilo2> works: instance (GShow a, GShow b) => GShow (a,b)
02:29:33 <danilo2> does not work:  instance (GShow v1, GShow v2, GShow v3, GShow v4, GShow v5, GShow v6, GShow v7, GShow v8) => GShow (v1,v2,v3,v4,v5,v6,v7,v8)
02:29:55 <danilo2> throwing:  Could not deduce (Generics.Deriving.Show.GShow' (GHC.Generics.Rep (v1, v2, v3, v4, v5, v6, v7, v8)))
02:33:28 <fizruk> danilo2: I guess that's because gshowsPrec has default implementation using GShow' (Rep a) instance
02:33:54 <fizruk> danilo2: so you probably should define gshowsPrec yourself
02:34:22 <fizruk> danilo2: see http://hackage.haskell.org/package/generic-deriving-1.6.2/docs/src/Generics-Deriving-Show.html#GShow
02:36:10 <danilo2> fizruk: Ok, but could you please tell a little more why it does not work? Why I can make instances for tuples up to 7 elements and from 8 it fails?
02:37:26 <fizruk> that's because you have Generic instances for tuples up to 7: http://hackage.haskell.org/package/base-4.6.0.1/docs/GHC-Generics.html#t:Rep
02:39:15 <sopvop> I remember there was a proposal to add (&) to Data.Function, and there was no consensus  on it. Are there any news about it?
02:39:20 <fizruk> I guess, you can write standalone deriving like deriving instance Generic ((,,,,,,,) a b c d e f g h)
02:39:43 <fizruk> danilo2: and then your GShow instance should work
02:39:46 <sopvop> I'm tired of putting it anywhere I don't use lens
02:39:50 <danilo2> fizruk: Ah ok thank you! I was searching for that and it is defined in GHC.Generics :) Btw is there a way to check in ghci where an instance was declared?
02:40:57 <startling> I wish someone would add for :: Functor f => f a -> (a -> b) -> f b somewhere.
02:41:15 <fizruk> danilo2: I don't know of such a feature
02:42:45 <elliott> startling: it's in lens
02:42:47 <elliott> :t (??)
02:42:48 <lambdabot> Functor f => f (a -> b) -> a -> f b
02:42:51 <elliott> oh.
02:42:54 <elliott> :t (<&>)
02:42:55 <lambdabot> Functor f => f a -> (a -> b) -> f b
02:42:56 <elliott> it's in lens.
02:43:10 <startling> elliott, neat, I haven't seen that one.
02:43:24 <startling> I still think "for" is the natural name for it, though.
02:43:37 <startling> :t forM -- in analogy to this
02:43:37 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
02:43:43 <elliott> :t for
02:43:44 <lambdabot>     Not in scope: `for'
02:43:44 <lambdabot>     Perhaps you meant one of these:
02:43:44 <lambdabot>       `T.for' (imported from Data.Traversable),
02:43:46 <elliott> :t T.for
02:43:47 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
02:43:55 <danilo2> fizruk: Thank you :)
02:43:58 <startling> oh, I've never seen that.
02:44:13 <startling> That should be "forA". >.>
02:44:14 <elliott> I guess in your regime that would be forA :)
02:44:18 <startling> heh.
02:44:30 <elliott> and you want map to be fmap too, presumably
02:44:57 <startling> map /is/ fmap. I want fmap to be map. :)
02:47:14 <AshyIsMe> companion_cube: apparently xmonad works on osx too: http://vimeo.com/53482928  wow
02:56:55 <joelmo> if i have a type like this declared how do i access for example the first string? data MolSeq = DNA String String | Protein String String deriving Show
02:57:55 <opqdonut> joelmo: pattern matching, basically
02:58:14 <merijn> AshyIsMe: It does, but only for X11 apps (i.e. the ones almost no one uses normally)
02:58:29 <donri> joelmo: if you make them records, you get an accessor. if you makeLenses the type, you get traversals for the partial accessors
02:58:37 <opqdonut> joelmo: getFirstString :: MolSeq -> String; getFirstString (DNA x y) = x; getFirstString (Protein x y) = x
02:58:49 <donri> joelmo: i would probably m.ove out DNA and Protein to an enum type though
02:58:59 <opqdonut> or you can name the fields using record syntax like donri suggested
02:59:19 <joelmo> ok thank you
02:59:24 <opqdonut> so data MolSeq = DNA {firstDNAString :: String, secondDNAString :: String} | ...
02:59:45 <donri> well you'd need to use the same name for the DNA and Protein fields
03:00:27 <donri> but be careful about multi-constructor records; if not all constructors have the same fields, the accesors are partial
03:00:35 <donri> (lens solves that problem)
03:10:12 <alexander__b> how do I structure this: http://lpaste.net/7021441874422398976 -- when one of those returns Just Something, I want to return (Something, p1 or p2). i.e. if #1 returns Something, I'll return (Something, p1). but if #4 returns Something, I want to return (Something, p2).
03:11:26 <donri> alexander__b: and if they're all Nothing?
03:11:43 <AshyIsMe> merijn: oh, in his video he's got chrome and Terminal working with it
03:11:53 <AshyIsMe> merijn: http://vimeo.com/53482928
03:12:18 <alexander__b> donri: then Nothing
03:12:52 <donri> alexander__b: the Alternative for Maybe might help
03:13:12 <alexander__b> oh, worth mentioning, heh, the collide functions all return Maybe Normals
03:13:14 <donri> > Nothing <|> Nothing <|> Just 3 <|> Nothing
03:13:15 <lambdabot>   Just 3
03:13:41 <alexander__b> so if b `collideCorners` p1 returns, I get Just Normal, and want to return Just (Normal, Paddle)
03:14:09 <alexander__b> donri: I know about that. it originally just returned Maybe Normal, so I used msum.
03:14:28 <alexander__b> donri: wait, I'll paste a bit more context to make it make sense, heh
03:15:38 <alexander__b> OK, so I want the top function in here: http://lpaste.net/3512739827390873600 to return the paddle it collides with as well. so the result should be Maybe (Normal, Paddle).
03:15:39 <donri> alexander__b: you can always fmap over them
03:16:51 <fizruk> alexander__b: so you want to get collision point together with the p*, b collides with?
03:16:58 <donri> > fmap (,a) Nothing <|> fmap (,b) (Just 2)
03:16:59 <lambdabot>   Illegal tuple section: use -XTupleSectionsIllegal tuple section: use -XTupl...
03:17:21 <alexander__b> fizruk: yes, if there is a collision, I want Just (Normal, Paddle). if not I want Nothing.
03:17:31 <no-n> @src (.)
03:17:31 <lambdabot> (f . g) x = f (g x)
03:17:32 <lambdabot> NB: In lambdabot,  (.) = fmap
03:17:49 <ion> @type (.)
03:17:49 <lambdabot> (b -> c) -> (a -> b) -> a -> c
03:18:05 <donri> > fmap ((,) a) Nothing <|> fmap ((,) b) (Just 2)
03:18:06 <lambdabot>   Just (b,2)
03:18:19 <alexander__b> fizruk: I annotated the reasoning http://lpaste.net/3512739827390873600
03:19:08 <donri> > (,) <$> pure a <*> Nothing <|> (,) <$> pure b <*> pure 2
03:19:09 <lambdabot>   Just (b,2)
03:19:47 <fizruk> msum [ fmap (,p) (b `collides` p) |p <- [p1, p2], collides <- [collideCorners, collideEdges] ]
03:21:33 <fizruk> <$
03:21:49 <fizruk> anyone know why nettalk is eating < $ > ?
03:22:00 <alexander__b> fizruk: error| Illegal tuple section: use -XTupleSections
03:22:05 <alexander__b> at (,p)
03:22:30 <donri> alexander__b: yeah, either use that extension or use a lambda or normal section
03:22:43 <alexander__b> donri: what's "normal section"?
03:23:03 <alexander__b> lamda seems excessive/verbose/noisy
03:23:12 <donri> (,p) == \x -> (x,p) == flip (,) p
03:23:33 <donri> (p,) == \x -> (p,x) == (,) p
03:24:19 <donri> normal section doesn't apply here, sorry
03:24:30 <alexander__b> ok
03:24:32 <alexander__b> that won't work though
03:24:47 <donri> a section is e.g. (++ xs)
03:24:54 <alexander__b> that'll be (Maybe Normal, Paddle), instead of Maybe (Normal, Paddle), I think
03:24:57 <alexander__b> oh, right
03:25:17 <donri> no it'll be what you want
03:25:21 <donri> note the fmap
03:26:06 <fizruk> > fmap (,b) (Just a)
03:26:07 <lambdabot>   Illegal tuple section: use -XTupleSections
03:26:20 <donri> elliott: we want tuple sections!
03:26:29 <fizruk> > fmap (\x -> (x, b)) (Just a)
03:26:30 <lambdabot>   Just (a,b)
03:26:36 <alexander__b> donri: could you paste the thing in its entirety? I'm sorry, I'm not following
03:27:05 <donri> fizruk: could you?
03:27:26 <fizruk> yeah, sec
03:27:43 <companion_cube> :t mapM
03:27:44 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
03:28:12 <alexander__b>   msum [fmap (flip (,) p) (b `collides` p) | p <- [p1, p2], collides <- [collideCorners, collideEdges]]
03:28:15 <alexander__b> ?
03:28:25 <alexander__b> that looks right to me.
03:28:38 <mjrosenb> hrmm.  cabal install fft is failing :-(
03:29:07 <fizruk> alexander__b: right
03:29:17 <alexander__b> fizruk: donri: thanks a lot guys
03:29:25 <donri> np
03:29:53 <mjrosenb> I'm trying to run the configure/ build commands manually, but it can't find the path to the .cabal directory where some deps were built.
03:30:32 <alexander__b> I made it a bit more clever by returning the velocity of the Paddle instead of the entire Paddle, and then I do fst/snd (fromMaybe (0, 0) collision). great!
03:31:43 <mjrosenb> any ideas how to proceed?
03:31:53 <donri> alexander__b: maybe 0 fst/snd collisions
03:36:59 <xpika> how to i get all the paths through a list of lists? e.g. [[1,2],[3,4]] -> [[1,3],[2,4]
03:38:55 <fizruk> > transpose [[1,2],[3,4]]
03:38:56 <lambdabot>   [[1,3],[2,4]]
03:39:14 <fizruk> xpika: if that's what you mean by all paths ^
03:40:45 <xpika> > transpose [[1,2],[3,4],[5,6,7]]
03:40:46 <lambdabot>   [[1,3,5],[2,4,6],[7]]
03:41:22 <xpika> no dice
03:42:49 <fizruk> xpika: what's the expected outcome?
03:43:17 <xpika>  [[1,2],[3,4],[5,6,7]] should convert to [[1,3,5],[1,3,6],[1,3,7],[1,4,5],[1,4,6],[1,4,7],[2,3,5],[2,3,6],[2,3,7],[2,4,5],[2,4,6],[2,4,7]]
03:43:46 <fizruk> oh, so [[1,2],[3,4]] -> [[1,3],[1,4],[2,3],[2,4]] ?
03:44:24 <fizruk> :t concatMapM
03:44:25 <lambdabot>     Not in scope: `concatMapM'
03:44:25 <lambdabot>     Perhaps you meant one of these:
03:44:25 <lambdabot>       `concatMap' (imported from Data.List),
03:45:21 <supki_> > sequence [[1,2],[3,4],[5,6,7]]
03:45:22 <lambdabot>   [[1,3,5],[1,3,6],[1,3,7],[1,4,5],[1,4,6],[1,4,7],[2,3,5],[2,3,6],[2,3,7],[2...
03:46:43 <fizruk> oh, that simple...
03:47:59 <fizruk> xpika: see what supki_ wrote ^
03:48:59 * hackagebot ewe 0.1.0.23 - An language to teach a programming  http://hackage.haskell.org/package/ewe-0.1.0.23 (JuanFranciscoCardonaMcCormick)
03:52:33 <Cale> This person perhaps has the rule for 'an' and 'a' reversed.
03:53:07 <Cale> No, that wouldn't explain it...
03:53:17 <Cale> Weird :)
03:53:37 <chrisdone> maybe the author is a cat
03:54:00 <donri> maybe they're going for childishness a la "learn you a"
03:54:34 <chrisdone> or it's mario
03:54:44 <chrisdone> an-a language to teach-a programming
03:54:44 <donri> mama mia!
03:55:19 <chrisdone> in italy mario doesn't speak with a funny accent, he just speaks regular italian
03:59:09 <chrisdone> Cale: what happen? http://ircbrowse.net/nick/Cale
03:59:14 <mjrosenb> so how do I specify the location of the libraries that cabal has installed locally?
03:59:54 * chrisdone . o O ( the great #haskell mystery of why activity of major chatters dropped so sharply almost across the board after 2008 )
04:00:19 <chrisdone> mjrosenb: specify to what?
04:00:50 <dcoutts> mjrosenb: you mean you want to control specifically where the files are installed? if so use the args to configure, --prefix etc
04:01:08 <dcoutts> or are you talking about finding files that are already installed?
04:01:37 <mjrosenb> dcoutts: finding files that are already installed via cabal-install
04:01:45 <dcoutts> by what?
04:02:12 <chrisdone> ghc-pkg list gives you the packages and the directories
04:03:03 <mjrosenb> I know the files are in ~/.cabal/lib/foobar
04:03:10 <dcoutts> mjrosenb: in what context do you need to find them? some other tool, custom code?
04:03:17 <mjrosenb> but runhaskell ./Setup.hs configure doesn't know where they are.
04:03:24 <dcoutts> ah
04:03:32 <dcoutts> mjrosenb: use --user
04:03:44 <mjrosenb> ahh.  thanks.
04:03:57 <dcoutts> by default runhaskell ./Setup.hs will do a global install, and global packages cannot depend on user ones
04:04:07 <mjrosenb> makes sense.
04:04:50 <mjrosenb> hrmm, cabal install fft fails, but when I manually run configure and build, it succeeds.
04:05:11 <dcoutts> it's probably picking different deps
04:05:21 <dcoutts> would need to see the details
04:05:43 <dcoutts> mjrosenb: constraint failure or build failure?
04:05:59 <mjrosenb> https://gist.github.com/7022971
04:06:15 <donri> chrisdone: maybe they all got jobs!
04:08:50 <Cale> chrisdone: ?
04:08:51 <dcoutts> mjrosenb: hmm, interesting, that's a hsc2hs failure
04:09:16 <dcoutts> mjrosenb: is that repeatable? try with -v or -v3
04:09:37 <chrisdone> Cale: http://ircbrowse.net/nick/Cale?recent=false
04:10:02 <Cale> Law of large numbers?
04:10:39 <mjrosenb> dcoutts: https://gist.github.com/7023029
04:11:49 <quchen> Cale: As time grows, Cale's activity is on average going to be Cale's average?
04:12:06 <dcoutts> mjrosenb: can we compare that with the runhaskell ./Setup.hs configure -v3 && runhaskell ./Setup.hs build -v3  ?
04:12:40 <chrisdone> Cale: explain?
04:12:59 <Cale> Well, I don't really know what feature of these things you're trying to point out
04:13:35 <chrisdone> Cale: after 2008 your activity decreases
04:13:53 <chrisdone> Cale: so what happened? =p
04:13:58 <mjrosenb> dcoutts: https://gist.github.com/anonymous/7023067
04:14:27 <Cale> Work, probably
04:15:06 <quchen> chrisdone: What event in 2013 made you suddenly chat much more than 2012? http://ircbrowse.net/nick/chrisdone?recent=false
04:15:10 <ocharles> When I try to install snap with cabal, I get a conflict. Cabal seems to reject comonad 4 because snap requires < 4, which is fine. But earlier it chose semigroupoids-4, which conflicts because comonad < 4 requires semigroupoids < 4. Does cabal not backtrack?
04:15:16 <ocharles> I'm on cabal 1.14
04:15:18 <quchen> (Why are we analyzing IRC logs again?)
04:15:25 <chrisdone> quchen: getting a job at fp complete? =p
04:15:37 <donri> ocharles: y u on ancient cabal :(
04:15:53 <ocharles> i know :(
04:16:06 <dcoutts> ocharles: the newer cabal-install does backtrack
04:16:09 <ocharles> that's what the build machine has, so I'm hesitant to upgrade it. But i suppose that wouldn't be a bad idea
04:16:16 <alpounet> chrisdone, oh you did? cool
04:16:17 <ocharles> dcoutts: ah cool, I'll upgrade then
04:17:02 <dcoutts> ocharles: if you're stuck with it you can persuade it to find the right answer by adding constraints manually, e.g. --constraint="semigroupoids < 4"
04:17:05 <ocharles> is there a cabal-install changelog anywhere?
04:17:21 <ocharles> dcoutts: right, but this is ran from jenkins, so I want to have it just figure things out if possible
04:17:30 <chrisdone> quchen: nerding out about haskell is a lot easier when you work for a company specifically aimed at improving haskell =)
04:17:52 <ocharles> http://www.haskell.org/cabal/release/cabal-1.18.1/changelog aha
04:18:08 <ocharles> nice to see the changelog stops at 0.11
04:18:48 <quchen> chrisdone: I can imagine. Is being on IRC part of your fpcomplete job description?
04:18:56 <alpounet> hah
04:19:20 <fizruk> ocharles: here it stops at 0.14: https://github.com/haskell/cabal/blob/master/cabal-install/changelog
04:19:47 <chrisdone> quchen: haha, not as such =)
04:20:05 <quchen> chrisdone: So it's part of *your* job description ^^
04:20:43 <ocharles> 1.18 doesn't seem to backtrack sufficiently either
04:20:55 <mgsloan> Nono, it's part of chrisdone's mission description
04:21:19 <chrisdone> ;)
04:21:37 <quchen> First FPComplete, then the world!
04:23:06 <chrisdone> ヽ (＾▽＾) ﾉ
04:23:35 <ocharles> woohoo, the topdown solver in cabal correctly identifies the problem
04:24:11 <dcoutts> ocharles: the new solver can do full backtracking
04:24:34 <dcoutts> ocharles: by default it does limited backtracking, you can lift the limit with --max-backjump=-1
04:24:43 <chrisdone> can i do logic programming with cabal's solver?
04:24:44 <ocharles> ah, maybe that was the problem
04:25:01 <dcoutts> chrisdone: if you lift the backjump limit yes
04:25:19 <ocharles> dcoutts: nope, topdown still works better
04:25:23 <ocharles> let me paste what I'm seeing
04:25:26 <dcoutts> chrisdone: it's an NP complete problem
04:25:43 <chrisdone> it does seem salesmanny
04:25:51 <donri> SAT solving?
04:25:57 <ocharles> chrisdone: I want to see 'salesmanny' used more in real research
04:26:06 <chrisdone> =p
04:26:34 <ocharles> http://lpaste.net/8991075938921873408 topdown vs modular with max-backjump=-1
04:26:50 <ocharles> the topdown one is more useful, as it indicates that my acid-state dependency is on acid-state is too tight
04:28:59 <ocharles> hum, though when solving that it still breaks on comonad
04:29:44 <ocharles> aha, and with that solved the modular solver can get a plan
04:30:27 <dcoutts> mjrosenb: when you're doing it with runghc Setup, is that from clean? It does not appear to be running hsc2hs at all
04:30:43 <dcoutts> mjrosenb: which would only happen if the target .hs file exists already
04:31:49 <dcoutts> mjrosenb: it calls hsc2hs on Math/FFT/Base.hsc to generate dist/build/Math/FFT/Base.hs
04:32:22 <dcoutts> mjrosenb: except that in your log for runghc Setup build it's not doing that
04:33:17 <dcoutts> ocharles: the modular solver doesn't have great error messages but it does find solutions in a lot more cases than the old one
04:34:07 <ocharles> yea, I got it to find a solution that doesn't upgrade template-haskell now :)
04:34:13 <ocharles> thanks for the --max-backjump trick!
04:35:22 <dcoutts> ocharles: you can also fix particular deps if you need, e.g. --constraint='template-haskell installed'
04:35:48 <ocharles> oh, I didn't know you could say 'installed'
04:35:58 <ocharles> but that's what I did - except I chose the version in ghc-pkg list
04:45:51 <quchen> So the naive free monad with `Free x >>= f = Free ((>>= f) <$> x)` is inefficient because every >>= has to traverse the entire list. In his talk, Löh mentions there are equivalent, but more efficient implementations. Does someone know more about those?
04:47:40 <donri> quchen: the way i understood it is it's not inefficient in the normal case
04:48:04 <donri> quchen: but see http://hackage.haskell.org/package/free-4.1/docs/Control-Monad-Free-Church.html
04:48:10 <donri> operational does it too i think
04:49:43 <quchen> donri: Thanks!
04:50:28 <mjrosenb> dcoutts: that run wasn't on a clean tree, but it obviously succeeded at one point or other.
04:51:00 <dcoutts> mjrosenb: to work out what's going on we'd need to compare the logs for a clean build
04:51:12 <dobblego> I recently saw a discussion about do-notation desugaring to Applicative in the event that there are no dependencies, but I cannot find it again — any pointers?
04:51:25 <quchen> dobblego: Look on reddit/haskell
04:51:39 <dobblego> quchen: yeah I think I saw it there, but I cannot see it again
04:52:13 <quchen> dobblego: http://www.reddit.com/r/haskell/comments/1o7lpm/proposal_for_applicative_donotation/
04:52:21 <dobblego> nice thanks
04:52:25 <dobblego> gseitz: ^
04:52:31 <quchen> Not sure how much of a proposal that is though. Haven't seen it on the mailing lists.
04:53:00 <gseitz> dobblego: I've seen it already
04:53:04 <dobblego> ok
04:53:16 <mjrosenb> dcoutts: https://gist.github.com/7023486 : from a clean untarring.
04:56:22 <mr-> Hi, is there a clever way to write a function Monad m => (m a, m b) -> m (a, b) ? (Cleverer than somthing like \x y -> do x' <- x; y' <- y; return (x',y'))
04:57:37 <dcoutts> mjrosenb: interesting, so it's invoking the same hsc2hs binary with exactly the same flags
04:57:45 <dcoutts> but in one case it works and in the other it fails
04:58:09 <dobblego> mr-: liftA2 (,)
04:58:11 <alpounet> quchen, i think there's a thread on ghc-users
04:58:14 <dcoutts> mjrosenb: are you running on a very memory constrained system?
04:58:19 <dobblego> @type uncurry (liftA2 (,))
04:58:20 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
04:59:37 <mr-> dobblego: of course! Thanks!
05:01:22 <mjrosenb> dcoutts: nope, 8G memory.
05:02:18 * ion posted to the thread: http://www.reddit.com/r/haskell/comments/1o7lpm/proposal_for_applicative_donotation/cctijyl
05:05:57 <SwineFlu> I'm looking at Data-List and it has findIndices
05:06:15 <SwineFlu> but its not in scope on my haskell so im guessing its not part of the standard prelude
05:06:38 <SwineFlu> but i want to look at the code so i can plagiarise it for my program
05:07:00 <dobblego> SwineFlu: click the source link
05:07:31 <alpounet> SwineFlu, you have to "import Data.List" to use it, and you can view its code on hackage, see the "Source" links here: http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-List.html
05:07:40 <SwineFlu> ahh
05:07:41 <SwineFlu> Thanks
05:07:54 <SwineFlu> I can't import it but I can implement my own i guess
05:07:59 <alpounet> why can't you?
05:08:07 <alpounet> oh, homework?
05:09:33 <dcoutts> mjrosenb: I've run out of ideas for the moment, perhaps you can file a ticket with those two logs
05:09:55 <dcoutts> mjrosenb: the fact it's returning 127 is what made me think that it was hitting an OS limit
05:10:29 <SwineFlu> alpounet: Yeah homework :(
05:14:31 <alexander__b> how would you guys organise collideEdges in http://lpaste.net/3512739827390873600 ? and I just mean formatting-wise. it's a bit... wide.
05:15:19 <alexander__b> (ignore the other functions, they have been reworked and reformatted already)
05:17:16 <Philonous> Can I get cabal to pass custom flags along to dependencies?
05:17:20 <cronject> First of all, YOU'RE 15, STOP LOOKING AT THIS GUY'S DICK.
05:17:39 <Philonous> cronject, Excuse me?
05:17:44 <chrisdone> oh man, ever write "<" insteaad of "<-"?
05:18:18 <chrisdone> "x < getLine" "not in scope x" "huh?"
05:18:41 <Philonous> chrisdone,
05:18:46 <fizruk> alexander__b: right b > left b && left b < right b ? why?
05:18:48 <Philonous> And then you stare at it for hours?
05:18:55 <chrisdone> Philonous: at least a minute
05:20:19 <fizruk> alexander__b: nevermind
05:20:36 <donri> chrisdone: or if it is in scope, you get the reader monad? :P
05:21:00 <merijn> alexander__b: Where clauses scope over multiple guards, so rather than repeat "centre b" all the time, I'd put that in a where clause
05:22:29 <alexander__b> merijn: OK
05:22:44 <chrisdone> donri: in some of the codebase i'm working on, a single type error like () /= Int will make ghc spit out 5-6 other totally unrelated errors due to type families
05:22:48 <merijn> alexander__b: btw, you might want to look at the pattern guards extension
05:22:59 <alexander__b> merijn: I also think I'll have a collideEdge that collideEdges calls
05:24:09 <staafl> is there an analogue to system() in haskell?
05:24:21 <chrisdone> System.Process.system
05:24:39 <chrisdone> :t System.Process.system
05:24:40 <lambdabot> String -> IO GHC.IO.Exception.ExitCode
05:29:10 * hackagebot type-level-numbers 0.1.1.1 - Type level numbers implemented using type families.  http://hackage.haskell.org/package/type-level-numbers-0.1.1.1 (AlexeyKhudyakov)
05:29:16 <linduxed> hey guys, i was wondering if there's some way to shorten line 18 in this file? https://gist.github.com/linduxed/276210dd2d06cdfd4b55
05:29:40 <linduxed> unless i'm missing something i can't use "where" on that line, since it's a lambda function
05:30:11 <staafl> chrisdone, many thanks
05:31:24 <fizruk> > (++) `fmap` take 6 <*> drop 7 $ [1..10]
05:31:26 <lambdabot>   [1,2,3,4,5,6,8,9,10]
05:31:52 <linduxed> fizruk: hmm, that's a good idea
05:32:04 <Iceland_jack> Why `fmap` rather than <$> ?
05:32:24 <fizruk> nettalk eats my < $ >, I can't fix it :-\
05:32:29 <Iceland_jack> aw poo
05:33:17 <linduxed> not in scope `<&>'
05:33:20 <linduxed> sorry
05:33:22 <linduxed> <*>
05:33:32 <Iceland_jack> :t (<*>)
05:33:32 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
05:33:34 <linduxed> appartently my Board is not Applicative
05:33:35 <Iceland_jack> :t (<$>)
05:33:35 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:34:01 <linduxed> this confuses me though...
05:34:03 <fizruk> linduxed: import Control.Applicative
05:34:17 <linduxed> Board is just [Pot]
05:34:22 <merijn> linduxed: You could just define a function in a where clause and use that rather than a lambda for line 18 :)
05:34:24 <fizruk> < $ > and <*> act on functions, not Board
05:34:36 <linduxed> so i would expect it to already have that, since [] is Applicative
05:34:42 <linduxed> oooh
05:35:20 <fizruk> > (+) `fmap` (+3) <*> (*2) $ 1
05:35:21 <linduxed> merijn: would you care to fork that gist and give me an example?
05:35:22 <lambdabot>   6
05:35:30 <linduxed> merijn: i can't seem to get it right
05:37:53 <merijn> linduxed: Something like this? https://gist.github.com/merijn/3bdc951628d804a51616
05:38:04 <merijn> linduxed: Still a bit long
05:38:22 <merijn> linduxed: But you can also use all the fancy applicative tricks there
05:38:26 <linduxed> oooh down there
05:38:39 <linduxed> yeah, this combined with the applicative operators will probably do the trick
05:38:41 <linduxed> thx
05:38:54 <fizruk> > take 6 <> drop 7 $ [1..10]
05:38:56 <lambdabot>   [1,2,3,4,5,6,8,9,10]
05:39:01 <merijn> linduxed: Yes, just make it a where clause of main (also note that where clauses are allowed to have nested where clauses for their functions :)
05:39:22 <linduxed> yes, that i know
05:39:26 <fizruk> linduxed: monoid version is shorter ^
05:39:30 <linduxed> (about the nested wheres)
05:39:42 <linduxed> fizruk: i had forgotten completely about <>
05:39:50 <linduxed> gotta read up on that one again
05:40:06 <linduxed> i remember the applicative operators, and some monad things
05:40:10 <fizruk> linduxed: it also has neat infix notation (since we don't have idiom brackets for applicatives...)
05:40:12 <linduxed> but the monoid ones escape me
05:40:13 <merijn> linduxed: Alternatively you could use "let ... in ..." or the do-sugar "let ..."
05:40:27 <Iceland_jack> > "hello" <> " " <> "world" -- linduxed
05:40:28 <lambdabot>   "hello world"
05:40:37 <Iceland_jack> > Sum 2 <> Sum 2 -- linduxed
05:40:38 <linduxed> merijn: i want to do the fancy stuff :-D
05:40:38 <lambdabot>   Sum {getSum = 4}
05:40:49 <linduxed> merijn: shit like this makes me happy, since i code ruby all day
05:41:04 <linduxed> merijn: past time haskell needs to have the fancy stuff ;-)
05:41:23 <merijn> linduxed: Be careful you don't regret it when you have to maintain it ;)
05:41:47 <linduxed> haha, i won't
05:41:53 <linduxed> besides, it's only for me anyway
05:42:22 <tdammers> linduxed: future you also qualifies as "someone else"
05:42:59 <Flonk> :t (<>)
05:43:00 <lambdabot> Monoid m => m -> m -> m
05:43:18 <Flonk> ಠ_ಠ
05:43:31 <fizruk> Flonk: just an associative operation with neutral element
05:43:42 <fizruk> :t mempty
05:43:43 <lambdabot> Monoid a => a
05:43:45 <linduxed> tdammers: yeah i guess
05:44:00 <linduxed> tdammers: but i expect of future me to be comfortable with Applicative :-)
05:44:26 <merijn> Flonk: Monoids are easy! :) I can bet you know at least 3 already
05:44:26 <Flonk> fizruk: I see
05:44:34 <Iceland_jack> > (mempty, mempty, mempty) :: (Sum Int, String, Product Double)
05:44:35 <lambdabot>   (Sum {getSum = 0},"",Product {getProduct = 1.0})
05:44:46 <Flonk> merijn: I came across the definition, but haven't used them much yet
05:45:16 <Flonk> It's a structure that folds well or something
05:45:30 <chrisdone> it's just any old structure that you can append or get an empty thing of
05:45:50 <Iceland_jack> A structure that folds well sounds more like Foldable
05:45:55 <merijn> Flonk: Specifically, addition on integers is a monoid (associative operation is +, neutral element is 0), multiplication on integers is a monoid (associative operation is *, neutral element is 1) and haskell lists (associative operation is ++ (appending), neutral element is [])
05:46:07 <chrisdone> text, bytes, lists, buffers, mostly
05:46:19 <Flonk> Iceland_jack: touché
05:46:24 <chrisdone> i think Sum and Product are obscure use-cases
05:46:52 <merijn> Flonk: The rules of monoids are just, there is a "zero" element 'e' and an associative operation * such that (monoid laws!) 'a * (b * c) = (a * b) * c' and 'e * a = a = a * e'
05:46:53 <Flonk> merijn: We learned about that at uni, yes
05:46:54 * elliott thinks only thinking of sequency monoids undersells their power
05:46:56 <chrisdone> Flonk: other languages call monoid a "sequence"
05:47:02 <elliott> eh.
05:47:05 <Iceland_jack> chrisdone: Yes but everyone ’gets’ that a + 0 = a etc.
05:47:12 <fizruk> Flonk: functions make interesting monoid: f <> g actually uses <> on the return values
05:47:12 <elliott> even mempty/mappend are quite bad names.
05:47:13 <chrisdone> elliott: it depends who you're selling it to
05:47:14 <Iceland_jack> But lists are probably a better showcase in Haskell
05:47:37 <mauke> Endo
05:47:48 <Lethalman> :t (f :: a -> b) <> (f :: a -> c)
05:47:49 <lambdabot>     Could not deduce (FromExpr b1) arising from a use of `f'
05:47:49 <lambdabot>     from the context (Monoid b)
05:47:49 <lambdabot>       bound by the inferred type of it :: Monoid b => a -> b at Top level
05:48:23 <fizruk> :t (f :: a -> b) <> (f :: a -> b)
05:48:24 <lambdabot>     Could not deduce (FromExpr b1) arising from a use of `f'
05:48:24 <lambdabot>     from the context (Monoid b)
05:48:24 <lambdabot>       bound by the inferred type of it :: Monoid b => a -> b at Top level
05:48:25 <Lethalman> :t \f g = f <> g :: a -> b
05:48:26 <lambdabot> parse error on input `='
05:48:29 <Lethalman> :t \f g -> f <> g :: a -> b
05:48:29 <Flonk> > id <> id $ "a" "b"
05:48:30 <lambdabot>     Couldn't match expected type `t' with actual type `a1 -> b1'
05:48:30 <lambdabot>       `t' is a rigid type variable bound by
05:48:30 <lambdabot>           the inferred type of it :: t -> t1 -> a -> b at Top level
05:48:30 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> a0'
05:48:32 <lambdabot>              with act...
05:48:42 <Lethalman> :t \f g -> f <> g :: Monoid b => a -> b
05:48:42 <lambdabot>     Could not deduce (t ~ (a1 -> b1))
05:48:43 <lambdabot>     from the context (Monoid b)
05:48:43 <lambdabot>       bound by the inferred type of it :: Monoid b => t -> t1 -> a -> b
05:48:47 <Lethalman> ok stop i suck
05:48:54 <fizruk> Flonk: f <> g $ x == f x <> g x
05:49:11 <fizruk> > id <> id $ "hi"
05:49:12 <lambdabot>   "hihi"
05:49:20 <kuribas> What's <>?
05:49:27 <fizruk> <> == mappend
05:49:27 <chrisdone> mappend
05:49:33 <kuribas> ah
05:49:35 <alexander__b> goddamnit I apparently can't wrap my head around writing this correctly
05:49:37 <Iceland_jack> > (id `mappend` id) "hi"
05:49:38 <lambdabot>   "hihi"
05:50:04 <dwcook> > const "Hello, " <> const "world." $ undefined
05:50:05 <lambdabot>   "Hello, world."
05:50:07 <alexander__b> I have a "Maybe (Normal, Velocity)". now I want to set n to the normal and v to the velocity, but I can't keep my tongue straight
05:50:22 <Iceland_jack> ..tongue
05:50:23 <Flonk> fizruk: I needed a function like that a minute ago. Neat!
05:50:37 <alexander__b> n  = fst (fromMaybe (0, 0) c) -- this compiles and works
05:50:42 <fizruk> Flonk: Endo is another monoid on functions, this time of type (a -> a)
05:50:59 <bitonic> is there a way to ask cabal what the current `dist' directory is?
05:51:05 <Krook> Hey there! I need help with haste!
05:51:16 <dcoutts> bitonic: from within the Setup.hs code, yes.
05:51:22 <alexander__b> but surely that's not correct? fromMaybe (0, 0) c would mean fromMaybe (0, 0) (Just Normal, Just Velocity) -- and so shouldn't it be... fromMaybe ((0, 0), (0, 0) c) or something?
05:51:49 <bitonic> dcoutts: I meant using the command line utility, `cabal'
05:51:57 <Flonk> fizruk: What does this tell me?
05:52:09 <dcoutts> bitonic: no, you tell it what dist dir to use, not the other way around.
05:52:34 <quchen> alexander__b: What should happen for Nothing?
05:52:48 <quchen> Is "c" some default value?
05:52:53 <alexander__b> quchen: I'll paste context
05:53:17 <Krook> Can anyone help me with haste?
05:53:19 <alexander__b> quchen: http://lpaste.net/6327821286231769088
05:53:22 <fizruk> Flonk: thought it might be of some interest to you
05:53:23 <bitonic> dcoutts: well but if I simply type `cabal build' it will automatically pick up a dist folder
05:53:33 <chrisdone> Krook: i don't know anyone using it. what's your problem?
05:53:46 <dcoutts> bitonic: the default one, but if it's not the default one then you have to tell it which one to use
05:53:50 <alexander__b> quchen: note that this works. it compiles, it runs, everything works. but... isn't it wrong? because (0, 0) isn't a ((Float, Float), (Float, Float)) at all!
05:54:04 <Krook> I'm trying to import Haste,Graphics.Canvas and it's telling me the module is missing...
05:54:07 <merijn> alexander__b: Ah, it might be...
05:54:10 <Krook> But i don't think it is,
05:54:18 <merijn> alexander__b: If you've imported a Num instance for tuples...
05:54:32 <quchen> alexander__b: If it typechecks the types are right. :-)
05:54:34 <Flonk> fizruk: I'll check out the docs
05:54:44 <quchen> alexander__b: You can write it a lot shorter though.
05:54:47 <merijn> alexander__b: You'll need to paste the source for anyone to know
05:54:57 <alexander__b> quchen: but (Normal, Vector) is ((Float, Float), (Float, Float)), not (Int, Int)
05:55:02 <alexander__b> merijn: I did
05:55:07 <alexander__b> merijn: : http://lpaste.net/6327821286231769088
05:55:08 <quchen> http://lpaste.net/6327821286231769088
05:55:44 <alexander__b> quchen: neat! thanks
05:55:48 <merijn> alexander__b: That doesn't have datatype definitions/type aliases for Ball, Paddle, Normal or Velocity...
05:56:19 <alexander__b> merijn: Velocity and Normal are gloss vectors
05:56:40 <merijn> Ah, but if Gloss has Num instances for those....
05:56:42 <quchen> alexander__b: Not sure why you worry about Int here.
05:56:56 <quchen> :t 0 -- "0" is not an Int.
05:56:57 <lambdabot> Num a => a
05:57:13 <quchen> It's `fromIntegral 0`, which works for any Num.
05:57:15 <bitonic> dcoutts: right but I might not know the default one, for example if the cabal config specifies it
05:57:20 <merijn> alexander__b: Open ghci, import gloss, type ":i Velocity", check whether it has a Num instance
05:57:23 <bitonic> specifies something which is not `dist'
05:57:42 <dcoutts> bitonic: the ~/.cabal/config cannot specify it. I'm not sure about the local one.
05:58:00 <dcoutts> bitonic: in principle you shouldn't have to poke into it anyway, it's layout is not specified or stable.
05:58:11 <alexander__b> merijn: Velocity is mine. Vector is Gloss's. Vector is defined to be a Point. a Point is (Float, Float).
05:58:16 <alexander__b> merijn: type Point = (Float, Float)
05:58:19 <alexander__b>   -- Defined in `Graphics.Gloss.Data.Point'
05:58:35 <bitonic> dcoutts: yeah I meant the local one---in my specific case I'm working with an hsenv
05:58:49 <merijn> alexander__b: Try "0 :: (Float, Float)" in ghci, see what happens?
05:59:07 <alexander__b> merijn: uhm "No instance"
05:59:33 <dcoutts> bitonic: the answer is no, there is no command line feature to get it.
05:59:33 <merijn> hmmm
05:59:35 <alexander__b> merijn: ah. I just did 0 :: Vector. interesting. thanks.
05:59:43 <merijn> :)
05:59:46 <bitonic> dcoutts: OK, thanks.
06:00:14 <dcoutts> bitonic: what do you want to do?
06:00:41 <fizruk> :t ala
06:00:46 <bitonic> dcoutts: I'm writing a shell script that does stuff with the executable after running `cabal build'
06:00:55 <supki_> :t (ala)
06:00:56 <lambdabot> Wrapped s s a a => (s -> a) -> ((s -> a) -> e -> a) -> e -> s
06:01:01 <bitonic> executables, actually
06:01:48 <dcoutts> bitonic: ok, well be aware that we're likely to change their locations in the build tree
06:02:07 <fizruk> supki_: why?
06:02:13 <dcoutts> bitonic: the only thing you can really rely on is where they are in an installed image, ie cabal copy --destdir=./image/
06:02:23 <supki_> fizruk: blame elliott :)
06:03:00 <Krook> ANyone present that's familiar with haste?
06:03:17 <bitonic> dcoutts: right... yeah right now it's a bit hacky here :P
06:03:20 <fizruk> > ala Min foldMap [1..10]
06:03:21 <lambdabot>   Not in scope: data constructor `Min'
06:03:26 <bitonic> the problem is that
06:03:36 <fizruk> oops
06:03:56 <bitonic> I'm writing a framework to run integration tests, and the `testsuite' stuff in cabal is not flexible enough
06:03:58 <Flonk> :t appEndo
06:03:58 <lambdabot> Endo a -> a -> a
06:04:04 <dcoutts> bitonic: how so?
06:04:25 <Flonk> > appEndo (Endo (+1)) 4
06:04:26 <lambdabot>   5
06:05:09 <bitonic> dcoutts: well, I need to pass a lot of configuration in, and when I tried it was clumsy to do so with `testsuite'---e.g. passing command line arguments or picking up local environmental variables
06:05:22 <fizruk> :t Data.Semigroup.Min
06:05:22 <lambdabot> a -> Data.Semigroup.Min a
06:05:44 <dcoutts> bitonic: hmm, you can pass extra flags or env vars, what's the issue?
06:06:50 <Philonous> Can i set an option in the cabal config to always pass a flag to packages that define it (for example -f-no-th) or can I configure cabal to pass flags along to dependencies?
06:08:07 <bitonic> dcoutts: how?  last time I tried if I did `FOO="bar" cabal test' FOO wouldn't be set, iirc
06:08:20 <bitonic> dcoutts: `cabal help test' doesn't say much about passing arguments in
06:08:57 <bitonic> and I also need to pass different arguments to different targets
06:10:17 <dcoutts> bitonic: it lists --test-option=
06:11:17 <fizruk> oh, seems lens's Wrapped class lacks instances for Semigroups
06:11:38 <bitonic> dcoutts: right, the problem I had is that I needed different flags for  certain testsuites
06:11:50 <dcoutts> bitonic: then run them one at a time
06:12:11 <dcoutts> bitonic: ie specify which testsuite to run
06:12:20 <dcoutts> cabal test blah
06:14:24 <dcoutts> bitonic: as for the env, the code looks like it extends the env, but it does use the current env. So if you can show it's not using the current env somehow then file a ticket as it's certainly trying to do that.
06:14:38 <bitonic> dcoutts: oh, I had no idea you could do that!  if the env stuff works that should be enough
06:16:27 <dcoutts> bitonic: I'm a bit concerned that you looked at cabal help test but didn't see the relevant option. Can you suggest an improved presentation there so people will see it? (I'm not blaming you, if you missed it it's likely other people will too)
06:17:23 <dcoutts> bitonic: it's true that it doesn't say that it accepts the testsuite name, could file a ticket about that
06:19:21 <bitonic> dcoutts: I have no idea, I was probably scanning the help text looking for `--options' or `-o'.  probably just lack of sleep and such :P
06:19:49 <alexander__b> any ideas on how to make this http://lpaste.net/3833037425806934016 look less puke-like? ugh
06:22:27 <bartavelle> :Tab /)
06:22:48 <SwineFlu> Wow its taken me all morning to write 8 lines of haskell
06:23:57 <chrisdone> congratulations on getting to 8 lines, it must've been hard work =)
06:24:03 <ikarus> SwineFlu: but now you can calculate the true value of the universe ?
06:24:09 <ikarus> that tends to be my Haskell
06:24:34 <ikarus> very few lines, that take a while to write, but then suddenly work better then anything ever did before
06:24:54 <chrisdone> the number 42 thing isn't realistic
06:25:18 <ikarus> chrisdone: it's just the true value
06:25:26 <chrisdone> real programmers would make programs that they can run on their laptop in five minutes to compute approximations like 41.89
06:25:30 <ikarus> so we can then sell it on
06:25:45 <chrisdone> and after a few months they'd decide 43.2 was accurate enough
06:26:07 <SwineFlu> Haskell development process -> write some code -> Change some types -> write some code -> change some types -> write comments for a hour
06:26:35 <Fuuzetsu> most people seem to get lost at the comments part
06:26:43 <thebnq> you missed pretty alignments :3
06:26:50 <kbotnen> and bragging on irc :)
06:27:10 <ikarus> Fuuzetsu: self documenting code :P
06:28:35 <Fuuzetsu> ikarus: My lecturer didn't like the idea of me not including any comments and claiming it should be clear from the code.
06:28:37 <fizruk> alexander__b
06:28:48 <ikarus> Fuuzetsu: hrm, mine did
06:28:50 <fizruk> alexander__b: what's U S D?
06:28:59 <ikarus> Fuuzetsu: but it's Jan van Eijck so I am hardly surprised
06:29:08 <alexander__b> fizruk: data Direction = U | D | S
06:29:14 <alexander__b> (up/down/stop)
06:29:17 <ikarus> although you can compile and run his entire lectures
06:29:22 <ikarus> it's all literate haskell
06:32:10 <Hodapp> ikarus: that's kind of neat.
06:40:51 <alexander__b> hey vimmers, have block comments hightlighting broke for you? they broke here some time ago. quite annoying.
06:42:36 <donri> alexander__b: are you using something like rainbow parenthesis?
06:42:43 <alexander__b> donri: yes... oh...
06:42:47 <donri> :)
06:45:07 <alexander__b> donri: any advice on uhm avoiding that?
06:45:28 <donri> alexander__b: i don't use it so don't know. maybe there's a way to disable it per filetype
06:45:45 <alexander__b> donri: there is, but I want it for haskell. just not for block comments, heh.
06:46:01 <donri> don't know then, sorry
06:46:03 <donri> bbl
07:04:01 <Flonk> So is Monad+Monoid == MonadPlus?
07:04:35 <quchen> Nah, the kinds don't match.
07:04:45 <quchen> But conceptually MonadPlus is something like a Monoid for Monad, yes.
07:04:58 <quchen> That, plus MonadPlus it's linked to (>>=).
07:05:12 <fizruk> Flonk: it's rather Monad + Applicative = MonadPlus, I thnk
07:05:13 <quchen> s/it's/is
07:05:54 <quchen> fizruk: Alternative, not Applicative
07:06:02 <fizruk> yeah, Alternative
07:06:03 <Flonk> fizruk: I heard that every Monad can be made an instance of applicative by doing (<*>)=ap and pure=return though
07:06:05 <Flonk> Oh okay
07:06:28 <quchen> Yeah that's right. Applicative + Monad == Monad :-)
07:07:11 <Flonk> I don't think I've heard of Alternative before though
07:07:30 <donri> honestly i'm still not sure what MonadPlus allows you to do that (Monad,Monoid) would not, seeing as they're all "m a"
07:07:34 <quchen> Alternative is pretty much the same as MonadPlus, but Applicative-based instead of Monad.
07:07:46 <Clint> it's very good
07:08:01 <quchen> donri: Yeah I'm not sure why we have MonadPlus (and keeping it)
07:08:12 <quchen> donri: On the other hand, Alternative has no laws with <*>
07:08:24 <quchen> So MonadPlus adds some laws. And then implementations violate them.
07:08:33 <donri> laws eh?
07:08:48 <donri> couldn't those laws be part of monoid "if it's also a monad"
07:09:03 <donri> we already have cross-class laws like that elsewhere
07:09:07 <donri> e.g. enum+bounded
07:09:07 <elliott> donri: you get it forall'd
07:09:13 <donri> ?
07:09:15 <elliott> no need to (Monoid (m Foo), Monoid (m Bar), ...)
07:09:46 <donri> Monoid (m a) ?
07:10:32 <elliott> doesn't work
07:10:38 <elliott> you need forall a. Monoid (m a) which you can't express
07:10:41 <elliott> in constraints
07:24:33 <quchen> Got a question regarding exceptions in this scenario: http://lpaste.net/94375
07:25:13 <quchen> What happens when I cancel the `foo` thread by calling `cancel fooAsync`? Since the `bar` thread is cancelled in the process, it throws a ThreadKilled exception on its own
07:25:39 <quchen> I'm not sure how many and which exception propel out of the entire thing in this scenario
07:27:21 <quchen> I basically have a server loop that spawns a sub-thread that listens on an `MVar ()`. When the MVar is filled, the server cancels its own thread.
07:27:59 <quchen> (Reason: got multiple server loops, and I'd like to be able to cancel/restart them one after another. Concurrent fairness seems like a solution.)
07:48:02 <Sagi> < Twey> Sagi: You can certainly newtype NumList = Num a ⇒ NumList [a]
07:48:09 <Sagi> actually, that seems not to compile
07:48:48 <Sagi> I get "Not in scope: type variable `a'"
07:49:05 <fizruk> newtype Num a = ...
07:49:44 <Sagi> I don't want to have a type parameter.
07:49:48 <fizruk> s/Num/NumList/
07:49:54 <donri> Sagi: i think you need DatatypeContexts or ExistentialQuantification for that, but you probably don't want this at all
07:50:26 <Sagi> I'll describe my use-case, so you can judge.
07:50:40 <Sagi> I'm going to write a lot of code that processes Path'
07:50:43 <Sagi> grr
07:52:01 <Sagi> I'm going to write a lot of code that processes Path's. A Path can consist of a number of NetworkObject's, which can be of four distinct types. Currently, all those types are an instance of NetworkObject.
07:52:21 <fizruk> donri: ghc 7.4 says "A newtype constructor cannot have an existential context", is there a reason for that?
07:52:54 <Sagi> I wanted to define Path as a list of NetworkObject, so the compiler will prevent me from putting nonsensical stuff that list.
07:52:57 <donri> fizruk: possibly that a newtype has the same representation as the oldtype
07:53:02 <edwardk> fizruk: yes
07:53:38 <Sagi> but now I run into the problem that you apparently cannot make a list with members of a class.
07:53:41 <edwardk> fizruk: its an annoying consequence of the way newtypes are implemented
07:53:53 <fizruk> oops, that was stupid question, sorry! :)
07:54:06 <Twey> Sagi: Paste code at lpaste.net
07:54:27 <fizruk> just messed existential with constrainted
07:54:34 <donri> Sagi: popular link http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
07:56:18 <fizruk> edwardk: btw, may I bother you to accept/discard/comment on wrapT issue for your free package? :)
07:56:28 <donri> Sagi: i think what you think you want is data Object = forall a. NetworkObject a => Object a  and then you could have [Object]
07:56:50 <edwardk> fizruk: hah. how about after i get back from CA? i'll go back through with dolio. i completely forgot about it
07:57:20 <fizruk> edwardk: when should I remind you about that?
07:57:24 <edwardk> fizruk: you have my permission to hound me from wednesday until i give you an answer
07:57:56 <fizruk> edwardk: ok :)
07:58:11 <donri> Sagi: but most of the time, if you reach for existentials, it's a hint you should maybe redesign the API
07:58:29 <alexander__b> I'm at another impasse. I want to pause my world given a key. so I have "handle (EventKey (SpecialKey Space) Up _ _) w                      = pause w". how on earth does the pause function have to look? what does it have to do?
07:58:54 <alexander__b> in OOP/procedural, I would just make it set a variable, running, to false, and then in my step procedure (in which the world updates), I would do if not running: return.
07:59:06 <alexander__b> so, I want something... like that.
07:59:21 <donri> alexander__b: what is that code for?
07:59:28 <donri> are you using any frp lib?
07:59:33 <alexander__b> donri: no, just gloss
07:59:42 <alexander__b> it's... well ATM it's just pong, really.
08:00:13 <simpson> alexander__b: At some point, take a look at edwardk's lens-driven pong. (Or mine, but I like edwardk's more.)
08:00:31 <alexander__b> simpson: I have looked a bit at it, but it's mostly above my head since I'm a complete newbie.
08:00:34 <lpaste> Twey pasted “NetworkObject, for Sagi” at http://lpaste.net/94376
08:00:34 <edwardk> technically its haasn's ;)
08:00:44 <Twey> Sagi: I think you want something like this ↑
08:01:04 <alexander__b> does it have pausing though? I wasn't aware
08:01:34 <simpson> alexander__b: The main approach that I used is to have a single large, structured type that represents all game state, and then use StateT MyLargeState IO to implement a game loop.
08:01:58 <simpson> Pausing is just a Bool flag that, when set, causes input to be disregarded and draws a pause screen.
08:02:35 <alexander__b> looks like I need to learn the state monad by now
08:04:01 * simpson wishes he had a pastebin or log of Cale's awesome explanation of State
08:04:38 <donri> http://ircbrowse.net/browse/haskell?q=cale+state
08:05:03 <Cale> simpson: I'd take you through it myself, but I'm just about to sleep
08:05:23 <simpson> Cale: No worries. I just really like how you lay out all of the pieces.
08:05:38 <donri> put caleToSleep
08:05:42 <lpaste> Sagi pasted “NML.hs for Twey, donri” at http://lpaste.net/94378
08:05:58 <Sagi> this is what I currently have and what I wanted to define a Path for
08:06:11 <donri> Sagi: why not just capture the dictionary in a record
08:06:43 <Sagi> pardon?
08:06:48 <donri> although you'd still need existentials to get a hlist of those...
08:07:40 <Sagi> let me get a picture of the thing I'm trying to model in the first place
08:07:47 <Twey> Sagi: Is NetworkObject actually supposed to be extensible?  Do you want to be able to add different NetworkObjects later?
08:08:32 <Sagi> hmm, that chance is very low
08:08:44 <Sagi> I have four types of NetworkObject, plus groups of those
08:09:38 <Sagi> Twey, donri: http://redmine.ogf.org/projects/nml-wg/repository/revisions/master/entry/NML-hierarchy.pdf
08:09:47 <Twey> Sagi: You probably just want to have NetworkObject be a sum type
08:10:00 <donri> Sagi: data NetworkObject = Node { guid :: Text, name :: Text } | Port { guid :: Text, name :: Text } ...?
08:10:13 <Twey> Like that
08:10:27 <Sagi> how would the Group fit in?
08:10:50 <Twey> Sagi: | Group { nodes :: [Node], guid :: Text, name :: Text }
08:11:10 <Sagi> oh, of course, it can be recursive
08:11:20 <Twey> Er, yes
08:11:26 <donri> beware that "nodes" (or "members", whatever) becomes partial
08:11:29 <Twey> I meant NetworkObject, not Node, of course :þ
08:11:29 <merijn> [NetworkObject], presumably :p
08:11:36 <donri> you can call it on a Node and it throws an error
08:11:59 <Twey> Yeah, you can have infinite NetworkObjects
08:12:00 <donri> a workaround is to use lens, which generates traversals for partial record fields
08:12:25 <Twey> Oh, like that; yes, never mind
08:12:33 <Sagi> hmm
08:12:46 <Sagi> but the compiler catches that, right?
08:12:53 <Twey> No
08:12:55 <donri> nope
08:12:59 <Twey> You could also have a separate type NetworkObjectInfo
08:13:17 <Sagi> I feel like lens is above my level at this moment.
08:13:17 <Twey> data NetworkObjectInfo = NetworkObjectInfo { guid ∷ Text, name ∷ Text }
08:13:37 <donri> without lens, i'd probably just write it without record syntax, then write the accessors manually, with Maybe for partial ones
08:13:43 <Twey> Then you can write: data NetworkObject = Node NetworkObjectInfo | Port NetworkObjectInfo | Group [Node] NetworkObjectInfo
08:13:58 <donri> members Node = Nothing; members (Group m _ _) = Just m
08:14:01 <donri> or something like that
08:14:03 <Twey> s/\[Node\]/[NetworkObject]/ again :þ
08:14:14 <Sagi> donri: that sounds quite nice actually
08:14:44 <donri> data NetworkObject = Node Text Text | Port Text Text | Group [NetworkObject] Text Text
08:14:51 <donri> or if all constructors will have two text
08:14:54 <Sagi> and if define | Group a { .. } | .. I can later do type PortGroup = Group Node, right?
08:15:11 <Sagi> if I
08:15:23 <Sagi> to make the code more readable
08:15:30 <Twey> Sagi: Your syntax doesn't make sense; what are you trying to do?
08:15:34 <donri> data NetworkObject = Node | Port | Group [NetworkObject]; data ObjectInfo = ObjectInfo Object Text Text
08:16:26 <Sagi> Twey: I was changing your proposed 17:07 < Twey> Then you can write: data NetworkObject =
08:17:07 <Twey> Sagi: Group a { … } isn't valid syntax: you can't mix record syntax and normal constructor syntax like that
08:17:24 <Sagi> meh
08:17:43 <Twey> If you're distinguishing these types at compile-time there's no point in using a sum
08:17:47 <Sagi> I guess that's what you get when you read lots of Haskell books and papers, but don't do much actual coding. It all mixes up in your head :-)
08:18:17 <Twey> We suggested the sum because you were asking how to throw the type information away, which means you probably didn't want to have it there in the first place
08:18:18 <Sagi> Twey: I'm not sure if I understand
08:18:46 <Twey> You can have that information or not have it, but it's not usually a good idea to have it and then immediately throw it away :þ
08:20:18 <Sagi> well, my goal is to write functions that create paths given some [NetworkObject]. So I expect to have to pattern match on the 'current' NetworkObject and then extend the path
08:21:41 <donri> Sagi: thing is [forall a. NetworkObject a => a] is isomorphic to [(Text,Text)] because the only thing you can do is call guid and name on those
08:22:13 <Sagi> ah, that makes sense
08:22:16 <donri> for example, you can't call members on an item in that list even if it is a group
08:22:26 <Sagi> so my original idea of using class doesn't actually work
08:22:27 <Twey> Sagi: You have two options: you can have a type ‘NetworkObject’ that doesn't contain compile-time information about what type of object is in the value, or you can have a class ‘NetworkObject a’ that lets you know that this particular NetworkObject holds an object of type ‘a’ (i.e. Node, Group Node, Port, &c.)
08:23:25 <Twey> Sagi: If you're going to be writing functions on e.g. ‘Group Port’ that shouldn't work on e.g. ‘Node’, then you should use the class (and keep the types around, so you can use those functions)
08:24:08 <Twey> If you aren't going to be writing those functions, there's no point in keeping that information at compile-time, and you can just use a sum type ‘NetworkObject’ that encompasses all the different object types
08:24:24 <Sagi> I think I will write functions on NetworkObject which will simply return an empty list in that case.
08:24:34 <Twey> What you were originally asking to do was to do the former and then throw away the type information so that you get the latter
08:24:51 <Sagi> hmm, okay
08:24:55 <Twey> Which is roundabout and pointless
08:25:06 <osa1> I just realized some other return types for main function is also supported .. like IO GHC.IO.Exception.ExitCode
08:25:08 <Sagi> I think I'm beginning to understand, thanks for the elaborate explanation :-)
08:25:51 <Sagi> Twey: so how should I decide which one I want. Should I write all the function types in advance?
08:26:09 <Sagi> I mean, is there some trick to this data type design?
08:26:31 <Twey> (if you want the type information but don't want to have your type be extensible with new instances, you can use a GADT with a phantom type, which is functionally equivalent to the class but guarantees that only a fixed set of ‘instances’ can exist)
08:26:38 <donri> osa1: i don't think it uses the ExitCode though
08:26:58 <Twey> Sagi: It's all about the operations you want to do on the data
08:27:01 <donri> osa1: if you use runghc, it'll print the return value. but if you compile, it's ignored. i think.
08:27:26 <Twey> If you have operations on a ‘Port’ then you want the former; if you only ever have operations on a whole NetworkObject, you use the latter
08:28:37 <osa1> donri: hmm I was trying with runhaskell, let me check
08:29:19 <osa1> donri: you're right. when I run it with runhaskell it printed the ExitCode but return type is just ignored when compiled
08:29:35 <Sagi> I could imagine having 'partial' functions, e.g. to extract information which is only available for a port.
08:30:00 <Sagi> but that leaves me with the problem of Path, right?
08:30:39 <elliott> int-e: re SafeHaskell lens: some tedious annotations that I meant to push to the repo but never did
08:31:21 <int-e> elliott: ah, you should really go ahead and do that ;-)
08:31:33 <elliott> int-e: but, but, I'm on Windows :/
08:33:34 <Sagi> although implementing that specific function with a Maybe result to cover the 'partial' nature helps to deduplicate code, because I can actually match for multiple constructors.
08:33:37 <Sagi> choices choices
08:33:54 <int-e> elliott: It's just sad to see that work go to waste.
08:34:34 <elliott> int-e: agreed. the diff is http://sprunge.us/PCKB if edwardk has tortured you with commit access yet :P
08:35:15 <donri> isn't HEAD supposed to infer Safe
08:35:17 <edwardk> elliott: those aren't in? damnit
08:35:34 <edwardk> safe haskell is too damn hard to mantain
08:35:57 <elliott> thankfully lambdabot is the only known user of safe haskell
08:36:02 <donri> ... when you tend to unsafeCoerce all the things ;)
08:37:42 <int-e> safe haskell is invisible. for example, how do I list the modules of a package to find out which are trusted or safe? I ended up enabling safe haskell in ghci and importing one module after the other -- that can't be the right way.
08:37:46 <Twey> Sagi: Partiality is undesirable; if you must cover it with a Maybe then do so, but it's generally more cruft (to use) than designing your types so that it doesn't occur
08:37:56 <int-e> (browsing haddock is even worse)
08:38:05 <elliott> int-e: you can also get ghc to spew out debug info about your modules or something I think that contains the info
08:38:10 <elliott> but yeah I just used trial and error
08:38:23 <elliott> that's why I don't feel like updating that for current lens HEAD or anything :P
08:40:51 <Sagi> Twey: I think I slowly get a feeling for the trade-off. But that leaves me with the question of how I would define Path in the case I choose to keep the type information.
08:41:25 <donri> int-e: there's :issafe in ghci
08:41:53 <fizruk> :t mapped
08:41:54 <Sagi> i.e. use typeclasses or GADT's
08:42:03 <fizruk> :t (mapped)
08:42:04 <lambdabot> (Functor f, Settable f1) => (a -> f1 b) -> f a -> f1 (f b)
08:42:21 <Twey> Sagi: You can use an hlist
08:42:46 <Twey> Which is basically a list with a list of associated types
08:42:57 <Twey> So that you always know the types of everything stored in the list
08:42:59 <turiya> hi
08:43:20 <turiya> parse ((many (noneOf ("aeiou"))) >> (many (noneOf ("aeiou")))) "u" "cdefghij" gives Right  ""
08:43:22 <Twey> Or you can impose more structure on your topology
08:43:24 <turiya> why?
08:43:43 <Twey> turiya: Because that's a valid parse
08:43:56 <Sagi> I'll hoogle for hlist
08:44:00 <turiya> i was expecting Right fgh
08:44:01 <Twey> ‘many’ can be empty
08:44:08 <int-e> donri: thanks, that's a bit better.
08:44:38 <Twey> turiya: That isn't a valid parse
08:44:39 <mauke> turiya: your expectations are wrong
08:44:47 <turiya> i am bit confused about what happens to the stream once many is applied
08:44:59 <mauke> the obvious thing :-)
08:45:15 <turiya> parse (many (noneOf ("aeiou"))) "u" "cdefghij"
08:45:19 <Twey> turiya: You're starting at the beginning of the stream.  So the first many can only match ["", "c", "cd"]
08:45:20 <turiya> gives Right "cd"
08:45:30 <mauke> the first part consumes "cd", leaving "efghij"
08:45:38 <mauke> the second part consumes "", leaving "efghij"
08:45:52 <Twey> Because 'e' doesn't match noneOf "aeiou"
08:46:11 <Twey> So only the empty parse is valid
08:46:19 <turiya> aha..ok
08:46:38 <turiya> parse ((many (noneOf ("aeiou"))) >> (char 'e') >> (many (noneOf ("aeiou")))) "u" "cdefghij" gives Right  ""
08:46:54 <turiya> will give me Right "fgh"
08:47:25 <Twey> It does, yes
08:47:30 <turiya> ok..nice
08:48:12 <Twey> As an aside, most of those brackets aren't necessary: parse (many (noneOf "aeiou") >> char 'e' >> many (noneOf "aeiou")) "u" "cdefghij"
08:49:22 <turiya> i am never sure about those things, so i use a lot of brackets
08:49:40 <turiya> but yeah the lesser the better
08:50:03 <donri> > ('y'):('a'):('y'):([])
08:50:04 <lambdabot>   "yay"
08:50:44 <donri> > (('y'):(('a'):(('y'):([]))))
08:50:45 <lambdabot>   "yay"
08:53:20 <Twey> turiya: Function application binds more tightly than anything else that doesn't have special syntax (qualified module names, record syntax)
08:53:36 <Twey> turiya: You never need brackets around a single value like "aeiou"
08:54:52 <turiya> Twey: i see.. thanks.. i only program now and then, still need to learn a lot of haskell
08:55:47 <danharaj> Cale: I summon thee
09:05:23 <identity> I am interested in writing a small genetic programming(e.g. evolutionary algorithms) library for learning purposes. Data is often represented using a binary encoding, so that crossover(mating) and mutation can happen with more entropy so to speak
09:06:11 <identity> So my question is -- how can I do this in Haskell for some datatype? Is there some typeclass that will do this or something practically equivalent?
09:08:35 <identity> I have taken a look at other genetic programming libraries, and some of them seem to make use of DeriveDataTypeable, but I am not sure how this helps me
09:17:00 <Nimatek> identity: Is this what you want, maybe? http://hackage.haskell.org/package/binary-0.7.1.0
09:18:00 <Sculptor> hello everyone!
09:19:06 <identity> Nimatek: hmm, perhaps it might.
09:19:12 <identity> not sure
09:29:46 * hackagebot active 0.1.0.8 - Abstractions for animation  http://hackage.haskell.org/package/active-0.1.0.8 (BrentYorgey)
09:39:47 * hackagebot networked-game 0.1.0.0 - Networked-game support library  http://hackage.haskell.org/package/networked-game-0.1.0.0 (EricMertens)
09:48:04 <xico> is there an existing typed Data.Map, which could store and provide typed values (storing their type)?
09:48:51 <jfischoff> xico: I would say Data.Map does store typed values. Maybe you are interested in Dynamic?
09:49:01 <donri> xico: maybe you want vault
09:49:04 <donri> @hackage vault
09:49:05 <lambdabot> http://hackage.haskell.org/package/vault
09:49:37 <xico> jfischoff: ah. i forgot about dynamic.
09:49:45 <xico> donri: thanks, i was not aware of that one.
09:49:49 <ZsoL> hi
09:49:53 * hackagebot Ninjas 0.1.0.0 - Ninja game  http://hackage.haskell.org/package/Ninjas-0.1.0.0 (EricMertens)
09:50:11 <ZsoL> hi
09:50:27 <jfischoff> xico: the path of Dynamic leads to pain, but sometimes it is still the best way :p
09:51:17 <xico> seems the only way to avoid unsafeCoerce from ghc too
09:51:37 <ZsoL> has anyone seen something like this before? I do cabal install yesod-bin, it installs it fine and immediately afterwards i do a ghc-pkg list | grep yesod-bin and it's not there
09:51:49 <jfischoff> under the hood Typeable is using unsafeCoerce … not surprising
09:52:22 <donri> well cast doesn't actually let you coerce (assuming derived Typeable)
09:55:35 <ZsoL> oh coz it's an executable not a library. cool
09:55:39 <NihilistDandy> ZsoL: Many binaries don't register a library, so ghc-pkg list doesn't pick them up
09:55:44 <ZsoL> yep gotit
09:55:45 <ZsoL> thanks :)
09:55:45 <NihilistDandy> Right
10:20:23 <Rarrikins> What are some recommended MySQL libraries?
10:32:35 <haasn> Rarrikins: persistent?
10:33:27 <Rarrikins> No, just a quick task that exits after it's done.
10:33:40 <Rarrikins> (if that's what you mean by persistent)
10:34:56 <haasn> @hackage persistent <- what I mean by persistent
10:34:56 <lambdabot> http://hackage.haskell.org/package/persistent <- what I mean by persistent
10:35:40 <Rarrikins> I didn't know you could get lambdabot to include that :D
10:37:46 <Rarrikins> haasn: Oh, I see what you mean. I'll check that out. Thanks
10:43:25 <donri> @hackage doesn't actually look if the package exists, it's just string append (as evidenced by this)
10:43:25 <lambdabot> http://hackage.haskell.org/package/doesn't actually look if the package exists, it's just string append (as evidenced by this)
10:46:24 <Rarrikins> donri: Ahh :)
10:50:05 * hackagebot optparse-applicative 0.7.0 - Utilities and combinators for parsing command line options  http://hackage.haskell.org/package/optparse-applicative-0.7.0 (PaoloCapriotti)
10:54:56 <P1RATEZ> :)\
10:59:17 <lispy> http://www.reddit.com/r/haskell/comments/1onnab/haskellorg_committee_is_looking_for/
10:59:23 <monochrom> oh haha, I didn't know a new CCC was out
11:00:32 * monochrom attempts "cabal install --dry-run lens" to verify the comics!
11:01:18 <monochrom> well, it is not that bad, considering how powerful it is, but heh
11:01:45 <hargard> please i do need to join an hacking forum i need one asap
11:02:02 <hargard> if you happen to know anyone let me know
11:02:07 <monochrom> it is not even half of yesod :)
11:03:31 <NihilistDandy> hargard: This is a hacking forum
11:07:36 <hargard> NihilistDandy, any other one
11:08:01 <NihilistDandy> I hear #oz is all hackers
11:08:24 <monochrom> consider http://reddit.com
11:08:46 <ypaq> hey, is there a library function with type [Maybe a] -> Maybe [a] that takes a list of maybe types and returns a maybe of all Just's or Nothing if there was a Nothing in the given list?
11:09:13 <ypaq> i know how to implement it myself, question is just if i have to
11:09:16 <donri> :t catMaybes
11:09:17 <lambdabot> [Maybe a] -> [a]
11:09:17 <zebr> i'm actually quite surprised there isn't already a function in hackage (that i could find) :: (Monad m, Monoid n) => (a -> m n) -> [a] -> n
11:09:18 <zomg> ypaq: iirc there was something like that in the Data.Maybe module
11:09:19 <jfischoff> sequence
11:09:29 <ypaq> catMaybes drops Nothing, right?
11:09:30 <jfischoff> :t sequence
11:09:31 <lambdabot> Monad m => [m a] -> m [a]
11:09:39 <briennetheblue> :t sequenceA
11:09:40 <lambdabot>     Not in scope: `sequenceA'
11:09:40 <lambdabot>     Perhaps you meant one of these:
11:09:40 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
11:09:40 <donri> oh yeah you want sequence in this case
11:09:51 <briennetheblue> :t T.sequenceA
11:09:51 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
11:09:56 <supki_> zebr: how would that work?
11:10:14 <jfischoff> :t mapM
11:10:15 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
11:10:19 <zebr> oops, i meant :: (Monad m, Monoid n) => (a -> m n) -> [a] -> m n
11:10:45 <jfischoff> > sequence [Just 'a', Just 'b']
11:10:46 <lambdabot>   Just "ab"
11:10:47 <donri> :t foldMap
11:10:48 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
11:11:02 <NihilistDandy> Oh, I always forget about sequence
11:12:37 <ypaq> sequence it is. thanks!
11:12:52 <unequation> (please don't give me the answer to my question, just tell me if my solution is right or not -- if it's not right, i'd like to have another try) there are 4 cards on a table, showing D, E, 2 and 3. every card has a digit on one side and a letter on another. which cards do i need to turn over in order to confirm that every D has a 3 on the other side? My answer: i need to turn them all over, in order to confirm that E does not ha
11:12:57 <zebr> i think basically i mean a 'foldMapM'
11:13:42 <AdrianG> hi
11:13:50 <donri> :t fold . F.mapM
11:13:51 <lambdabot> Couldn't find qualified module.
11:14:07 <hargard> why was i removed
11:14:19 <briennetheblue> unequation i don't think that's right... i'm not great at logic though
11:14:21 <hargard> jnix, be carefull
11:14:38 <ParahSailin> unequation: you only need to turn over one
11:15:16 <unequation> ParahSailin: urmm, i'll try and figure that out then. no more answers please -_- just wanted to know if i was right or not -- are you SURE that i am wrong?
11:15:28 <briennetheblue> i'm fairly sure that you're wrong
11:15:32 <ParahSailin> unequation: yeah this is one of those common interview questions
11:15:41 <unequation> sounds good, thank you!
11:15:43 <ParahSailin> unequation: i memorized a book of them once
11:15:52 <chrisdone> ParahSailin: interviewing at google?
11:16:05 <ParahSailin> chrisdone: something like that
11:22:37 <NihilistDandy> unequation: Keep in mind, the real thing you're validating is "If D then 3"
11:23:18 <enthropy> there could be a D on the other side of the 2
11:23:36 <enthropy> or a 5 on the other side of the face-up D
11:23:54 <acomar> enthropy: the only thing you're asked to verify though is that D => 3
11:23:58 <monochrom> unequation: spikedmath has a video on that on youtube
11:24:29 <enthropy> acomar: and D means face-up D?
11:24:32 <ParahSailin> unequation: http://en.wikipedia.org/wiki/Wason_selection_task
11:24:45 <monochrom> yes, face-up D
11:25:07 <acomar> enthropy: that's the argument :)
11:25:10 * hackagebot zip-archive 0.1.4 - Library for creating and modifying zip archives.  http://hackage.haskell.org/package/zip-archive-0.1.4 (JohnMacFarlane)
11:25:24 <enthropy> well they tell you the number-face-up cards have letters on the back
11:25:50 <monochrom> http://www.youtube.com/watch?v=qNBzwwLiOUc
11:26:50 <Rarrikins> The Wason selection task is easy enough if you use modus tollens and modus ponens.
11:32:50 <ParahSailin> does ghc ever infer strictness of data constructors?
11:35:21 <Vamp> When there stands IO infront of for instance Rational (IO Rational), what does this actually mean?
11:36:20 <monochrom> Rational (IO Rational) has a meaning for sure. but most likely arises from programmer error.
11:36:36 <simpson> Vamp: Could you give a concrete example?
11:36:55 <jgross> Does djinn deal with typeclasses?  e.g., can I ask djinn for "instance Functor f, Functor g => Functor (f . g)"?
11:37:21 <levi> It means it's the IO type parameterized by Rational; you can interpret it as being an IO action that deals with the Rational type.
11:37:55 <Rarrikins> Vamp: If you mean IO Rational, it means that you have an IO action that produces a Rational value.
11:38:03 <monochrom> oops, Rational (IO Rational) is a type error
11:38:03 <gp5st> I'm doing something wrong and I have no idea what:(
11:38:05 <gp5st> http://pastebin.com/uPAQzyQC
11:38:10 <mauke> The paste uPAQzyQC has been copied to http://lpaste.net/94381
11:38:20 <gp5st> I'm trying to work on this http://learnyouahaskell.com/starting-out
11:38:31 <NihilistDandy> gp5st: Add let to the beginning
11:38:34 <briennetheblue> put a let infront of that
11:38:54 <gp5st> oh
11:39:12 <unequation> ParahSailin: you need to turn over two cards, not one.
11:39:13 <scriptor> gp5st: notice that in LYAH doubleMe is defined in a file called 'baby.hs'
11:39:15 <Vamp> simpson: http://lpaste.net/7175773569924726784, I want to calculate the fraction of games won of n times a game of chance played
11:39:24 <NihilistDandy> unequation: Correct
11:39:30 <scriptor> gp5st: if you want to define it in ghci, you'll have to use let
11:39:39 <ParahSailin> unequation: yeah i lied
11:40:07 <Rarrikins> Vamp: It would be better to have that as Outcome -> Integer -> Rational.
11:40:08 <unequation> ParahSailin, NihilistDandy lol
11:40:10 <gp5st> oh isee
11:40:48 <gp5st> thanks
11:40:58 <Rarrikins> Vamp: Unless you're specifically doing IO in it.
11:45:00 <Vamp> Rarrikins: Hmm I see
11:45:05 <xico> i want to add (optional) IO facilities to my monad. is the easiest (best?) way to make the monad a transformer and then use it as MyMonadT IO? if i do so, how can i avoid liftIO? re-exporting the io functions i want in my transformer?
11:45:56 <Rarrikins> Vamp: In any case, there's little reason to have IO Outcome rather than Outcome as the first argument.
11:46:46 <glguy> Rarrikins: perhaps he intends to run the (IO Outcome) a few times?
11:47:05 <Rarrikins> glguy: Hmm, that's a good point.
11:48:04 <Rarrikins> glguy: I think replicateM or something would still be better, though.
11:48:35 <Vamp> Rarrikins: What about sequence?
11:48:48 <Rarrikins> @type sequence
11:48:49 <lambdabot> Monad m => [m a] -> m [a]
11:49:49 <Rarrikins> That with mapM or something would work, but be a bit more verbose.
11:53:21 <meow45> ghci says the type of "meow" is [Char], but the type of Prelude.words is String -> String. Why [Char] in one case, but String in the other?
11:53:49 <simpson> meow45: type String = [Char]
11:53:53 <simpson> Same type.
11:54:05 <meow45> Yes, but why isn't ghci consistent? Why not say "meow" is of type String?
11:54:21 <meow45> Why not simplify and say [Char] in both cases?
11:54:29 <meow45> Or String?
11:55:09 <simpson> Oh. It tries to show type synonyms when it can, but reversing from an expanded type to the synonym is difficult. There could be multiple possibilities, for example.
11:56:09 <meow45> I think I see. Thanks! What causes it to expand a type, though?
11:56:19 <Rarrikins> meow45: I think that the source for words probably has an explicit type signature, which ghci will display.
11:56:24 <meow45> For example, why does it expand "meow"?
11:56:35 <Vamp> Rarrikins: I Somehow have to simulate the IO Outcome Integer times, and thought about then finding how many Wins there were and divide this with that Integer (total games simulated)
11:56:42 <NihilistDandy> :t "meow" :: String
11:56:43 <lambdabot> String
11:56:57 <meow45> Ah, okay! I'll go check.
11:57:00 <Rarrikins> meow45: Whereas with yours, you didn't give an explicit type signature, so it will go with [Char], which is the default way to write it.
11:57:03 <Rarrikins> :t "meow"
11:57:04 <lambdabot> [Char]
11:57:43 <Vamp> Rarrikins: So Outcome in IO Outcome is Win | Lose
11:57:55 <Rarrikins> @type replicateM
11:57:55 <lambdabot> Monad m => Int -> m a -> m [a]
11:58:15 <Rarrikins> Vamp: results <- replicateM 57 outcomeThingy
11:58:15 <meow45> I see. So, if given no alias as an explicit type, it'll show the fully expanded type. But if given one, it'll use it.
11:58:21 <Rarrikins> Vamp: That'll give you a list of 57 outcomes.
11:58:59 <Rarrikins> Vamp: You can then deal with either each outcome or the entire list using pure functions.
11:59:13 <Rarrikins> meow45: Yeah.
11:59:43 <Rarrikins> meow45: Because using type synonyms is work and, if there are multiple type synonyms for a type, which should it use?
11:59:56 <Rarrikins> meow45: Best to avoid the work and the arbitrariness.
12:00:14 * hackagebot http-types 0.8.2 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.8.2 (AristidBreitkreuz)
12:03:43 <enthropy>  :t "meow" might be better off if it was String
12:03:48 <jfischoff> has anyone used constraint kinds to make a open union of constraints? I'm wondering if you emulate subtyping with that approach.
12:04:26 <monochrom> @type "meo"
12:04:26 <lambdabot> [Char]
12:04:59 <blume> @pl \xs n -> drop n xs ++ take n xs
12:05:02 <lambdabot> ap (ap . ((++) .) . flip drop) (flip take)
12:05:02 <lambdabot> optimization suspended, use @pl-resume to continue.
12:05:27 <blume> alright. not that beautiful
12:05:58 <Rarrikins> @pl \(xs, ys) -> ys ++ xs
12:06:02 <lambdabot> ap (flip (++) . fst) snd
12:06:02 <lambdabot> optimization suspended, use @pl-resume to continue.
12:07:39 <blume> @t ap
12:07:39 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
12:07:46 <blume> @type ap
12:07:47 <lambdabot> Monad m => m (a -> b) -> m a -> m b
12:07:51 <Rarrikins> > uncurry (flip (++)) . splitAt 5 $ "Hello there"
12:07:52 <lambdabot>   " thereHello"
12:07:55 <Rarrikins> blume: ^
12:08:37 <acomar> blume: if you run that on the command line, you get "flip =<< join . flip flip take . flip drop"
12:08:58 <acomar> flipping the argument order yields: "join . (flip =<< flip flip take . drop)"
12:09:42 <Rarrikins> How do you run it on the command line?
12:09:49 <xico> what does ~(a,b) mean?
12:09:58 <xico> (in a pattern)
12:10:00 <acomar> Rarrikins: install the pointfree command
12:10:21 <xico> (lazy pattern match)
12:10:57 <Rarrikins> xico: http://www.haskell.org/tutorial/patterns.html#tut-lazy-patterns
12:11:49 <acomar> blume: nevermind, I had a typo in the commandline
12:12:13 <acomar> blume: flipped arguments yield "ap (ap . ((++) .) . drop) take"
12:12:27 <xico> Rarrikins: thanks
12:12:28 <blume> acomar: alright, was still staring at it
12:12:54 <blume> quite confusing, i'll stay with the points this time
12:13:30 <acomar> yea, that's usually much clearer
12:15:15 * hackagebot snap 0.13.0.4 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.13.0.4 (DougBeardsley)
12:30:18 <Vamp> Rarrikins: I tried something like this now, but the it isn't type correct yet http://lpaste.net/8396020709825970176
12:31:42 <fizruk> Vamp: what's % for?
12:32:10 <Vamp> Oops I also forgot length infront of the filtered list
12:32:20 <Rarrikins> Vamp: proportion (== Win) . replicateM plays $ game
12:32:22 <Rarrikins> Vamp: Then, write proportion.
12:32:41 <Rarrikins> No, that's not quite right.
12:33:12 <Rarrikins> Vamp: do { results <- replicateM plays $ game; print (proportion (== Win) results) }
12:33:16 <Rarrikins> Vamp: Something like that.
12:33:29 <Vamp> fizruk: I thought I needed % for the rational
12:33:52 <Rarrikins> Vamp: Then, the only thing you really need is to write proportion.
12:34:53 <monochrom> I don't understand the meaning of "list % number". do you?
12:34:54 <Vamp> Rarrikins: Okay, I'm on it
12:35:22 <Vamp> monochrom: Yeah it had to my length list % number
12:35:27 <Vamp> my = be
12:35:45 <Vamp> So with that I thought I could get the fraction of wins of the total games
12:35:54 <hargard> i need a partner
12:36:10 <fizruk> hargard: leader or follower?
12:36:39 <hargard> fizruk: am nt gay !!
12:37:03 <monochrom> ?
12:38:42 <zebr> is there a 'safe' !! :: [a] -> Int -> Maybe a ?
12:38:55 <fizruk> :t lookup
12:38:56 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
12:39:05 <haasn> :t preview . ix
12:39:06 <lambdabot> (MonadReader s m, Ixed (Accessor (First (IxValue s))) s) => Index s -> m (Maybe (IxValue s))
12:39:25 <haasn> > preview (ix 2) "hello"
12:39:26 <lambdabot>   Just 'l'
12:39:34 <haasn> > preview (ix 2) "hi"
12:39:35 <lambdabot>   Nothing
12:39:40 <zebr> that is quite a type constraint you've got there.
12:39:53 <zebr> what package is that?
12:40:09 <haasn> :t (\x i -> x ^? ix i) `asAppliedTo` []
12:40:11 <lambdabot> [a] -> Int -> Maybe a
12:40:15 <haasn> zebr: lens
12:40:18 <zebr> ahh
12:40:29 <fizruk> > listToMaybe . drop 2 $ "hello"
12:40:30 <lambdabot>   Just 'l'
12:41:07 <Twey> Vamp: simulate :: IO Outcome → Int → IO Rational; simulate game plays = (% fromIntegral plays) . genericLength . filter (== Win) <$> replicateM plays game
12:41:43 <Twey> Vamp: It's dangerous to let your users think that you're using an Integer when actually you're truncating it to an Int anyway
12:42:31 <Twey> > fromIntegral (maxBound + 1 :: Int) :: Integer
12:42:33 <lambdabot>   -2147483648
12:42:47 <Rarrikins> @type replicateM
12:42:48 <lambdabot> Monad m => Int -> m a -> m [a]
12:43:09 <Twey> Might be nicer to use/write a genericReplicateM
12:43:24 <Vamp> Twey: I see, yeah I did that because replicateM wanted an Int and not an Integer
12:43:34 <Twey> genericReplicateM = (sequence .) . genericReplicate
12:43:54 <Twey> :t (sequence .) . genericReplicate
12:43:54 <lambdabot> (Integral a, Monad m) => a -> m a1 -> m [a1]
12:45:10 <Twey> Vamp: genericReplicateM ∷ (Integral n, Monad m) ⇒ n → m r → m [r]; genericReplicateM = (sequence .) . genericReplicate; simulate ∷ IO Outcome → Integer → IO Rational; simulate game plays = (% plays) . genericLength . filter (== Win) <$> genericReplicateM plays game
12:46:10 <Rarrikins> @type iterate
12:46:11 <lambdabot> (a -> a) -> a -> [a]
12:46:15 <Rarrikins> Hmm
12:46:33 <Vamp> Rarrikins: I found that one too, but didn't know how to use it
12:47:35 <moto9> hi all,
12:47:36 <Rarrikins> @type join . map snd . takeWhile ((<= n) . fst) . zip [1..]
12:47:37 <lambdabot> [[a]] -> [a]
12:48:20 <moto9> i'm trying to use GLFW, and i'm having difficulties converting Double to GLfloat
12:50:56 <moto9> using GHC.Float.double2Float results in Couldn't match expected type `GLfloat' with actual type `Float'
12:51:32 <Rarrikins> @hoogle a -> GLfloat
12:51:32 <lambdabot> Prelude id :: a -> a
12:51:32 <lambdabot> Data.Function id :: a -> a
12:51:32 <lambdabot> GHC.Exts breakpoint :: a -> a
12:51:46 <Rarrikins> Lovely
12:52:03 <moto9> huh
12:52:09 <geekosaur> isn't it easiest to use CDouble?
12:52:16 <Rarrikins> moto9: http://stackoverflow.com/a/12168349/463897
12:52:47 <Rarrikins> moto9: A comment on that recommends realToFrac.
12:55:55 <monochrom> likely GLfloat = CFloat
12:56:27 <geekosaur> CDouble, I believe (not a lot of stuff actually uses C's (float))
12:56:30 <monochrom> anyway you may be able to use GLfloat all the way in the whole program
12:56:42 <monochrom> well, GLdouble = CDouble
12:57:51 <moto9> big thanks
12:58:05 <moto9> well GLFW itself uses Double for giving me mouse coords
12:58:15 <Vamp> Twey: It's complaining about the types, expecte type : [Outcome] actual : [[Outcome]] and expected [Outcome] actual IO Outcome
13:00:14 <Twey> Vamp: Then you didn't use the code I gave you :þ
13:01:35 <Twey> You can also use foldM like so: simulate game plays = (% plays) <$> foldM (\ t x → (t +) . bool 0 1 . (== Win) <$> x) 0 (genericReplicate plays game)
13:01:42 <Twey> Which might be a little faster
13:02:06 <_fudvasu_> hi guys
13:02:13 <_fudvasu_> quick question
13:02:24 <_fudvasu_> I want to define  a data type
13:02:33 <Twey> (where bool f t p = if p then t else f)
13:02:34 <Vamp> I only changed the % part by using it infix
13:03:03 <_fudvasu_> whose constructor takes any variable a of type t1 and a list of t2
13:03:06 <Twey> Vamp: It's an operator section there; unless you introduced a new variable, you can't use it infix
13:03:27 <_fudvasu_> but i want the list to be of atleast length 4
13:03:43 <Vamp> Twey: Aha I see
13:03:53 <_fudvasu_> how can I encode that?
13:03:59 <Twey> Vamp: You can use do-notation to assign a variable to the result and use an extraneous ‘return’, if you want: do wins ← foldM (\ t x → (t +) . bool 0 1 . (== Win) <$> x) 0 (genericReplicate plays game); return $ wins % plays
13:04:32 <Twey> _fudvasu_: The easy way is to have the constructor take four t2's and a list of t2's
13:04:33 <_fudvasu_> I just don't want to define Cell a b = Cell (a,(b,b,b,b))
13:04:48 <Twey> _fudvasu_: Do you mean ‘at least’ or ‘exactly’?
13:04:48 <Vamp> Twey: I think I'll do that, but then with the other solution, without the fold
13:04:54 <Twey> Vamp: Sure
13:04:57 <_fudvasu_> atleast
13:05:26 <_fudvasu_> that means I have to pass 3 parameters to the constructor
13:07:07 <Twey> _fudvasu_: Then you can do that.  You could also use a Vec: http://hackage.haskell.org/package/Vec which is a type that encodes its length in its type; then you can have your constructor take a proof that the Vec is at least 4 long
13:07:25 <Twey> That's nicer, but more effort for not much (non-syntactic) gain.  ☺
13:07:31 <Vamp> Twey: Btw, what is <$> actually?
13:08:04 <Twey> Vamp: <$> is infix fmap
13:09:27 <Vamp> Twey: Aha I see
13:10:20 <Twey> Vamp: f <$> x = do x' ← x; return $ f x
13:10:22 <Twey> (for monads)
13:10:34 <Twey> Er, $ f x'
13:12:00 <Vamp> Twey: Aha, yeah I didn't see the <$> yet, only the fmap :)
13:12:54 <xico> i'm re-building with NoMonomorphismRestriction, and suddenly a line which was "size = 9" got its type changed. any idea about that?
13:13:29 <Hermit> xico: type changed to what exactly?
13:13:52 <jle`> hi all; on this wikipedia article http://en.wikipedia.org/wiki/Monad_(functional_programming) it mentions that in the early days of Haskell, sequential IO was implemented/structured as a lazy list.  anyone have any links to articles and stuff that detailed how this worked "back in the day"?  i can kind of imagine it, but it'd be nice to see the details on what actaully happened
13:14:23 <xico> Hermit: good question :)
13:15:06 <xico> previously it was an Integer, now it is not even a Dynamic
13:15:21 <xico> on an unrelated note, how do i enable NoMonomorphismRestriction in ghc code?
13:15:42 <xico> (found that)
13:15:43 <Rarrikins> xico: {-# LANGUAGE NoMonomorphismRestriction #-} at the top.
13:15:50 <dcoutts> jle`: you can get an impression of how it worked by writing all your programs using main = interact (...)
13:15:55 <dcoutts> :t interact
13:15:55 <lambdabot> (String -> String) -> IO ()
13:16:22 <dcoutts> jle`: that gives you a stdin -> stdout program as a String -> String function
13:17:20 <dcoutts> jle`: even interactive progs can actually be written this way, though it's tricky :-)
13:18:42 <hmmh> Hi. Can anyone recommend a good lib for prng's for crypto. Cabal really spoils you for choice
13:19:28 <jle`> dcoutts: hm.  you're saying that it was like having a list of IO ()'s where every next element was a function of stdin
13:19:46 <jle`> and the Runtime environment basically was focused on evaluating each element one after another
13:21:17 <fizruk2> jle`: you might be interested in http://www.haskell.org/haskellwiki/History_of_Haskell
13:21:43 <xico> Hermit: type changed to "size :: Num a => a". is there a way to convert that to a, let's say, Double?
13:21:55 <Hermit> add a type signature...
13:22:01 <jle`> xico: :: Double ?
13:22:12 <xico> i cannot modify the source
13:22:28 <xico> i mean the declaration
13:22:28 <Rarrikins> xico: It already is a Double.
13:22:42 <xico> ok. let me rephrase.
13:22:59 <xico> i have that type in a Dynamic
13:22:59 <Hermit> xico: it's a polymorphic value... it will be whatever it needs to wherever you use it
13:23:05 <augur> are ICFP videos available yet?
13:23:23 <xico> and i cannot use fromDynamic with it, it only works with Double and such
13:23:57 <geekosaur> I don't think a Dynamic value can be polymorphic you'd need to store a monomorphic version
13:24:23 <geekosaur> (that is supposedly coming at some point, I believe)
13:24:35 <lpaste> glguy pasted “old-style IO” at http://lpaste.net/94383
13:25:23 <fizruk2> jle`: chapter 7 of "History of Haskell" is about some other i/o implementations
13:26:06 <geekosaur> anyway, xico: you can refine a type. if you have size :: Num a => a, you can store (size :: Double)
13:26:17 <geekosaur> requesting specifically that instance
13:26:42 <xico> geekosaur: not sure i understand how to refine the type.
13:26:54 <Hermit> add - a - type - signature
13:26:59 <xico> the dynamic, i got it from ghc, parsing a file with nomomorphicrestriction
13:27:10 <xico> Hermit: i cannot change the code
13:27:37 <geekosaur> xico, you keep saying that. either explain the full situation or stop building an impossibility
13:28:19 <geekosaur> "you cannot change the code" you mean someone has miswritten garbage and you are required to make it typecheck without fixing it?
13:28:26 <geekosaur> or so you mean... what?
13:28:31 <geekosaur> *do you
13:28:42 <xico> geekosaur: do you imply that writting "size = 9" is garbage
13:28:53 <Hermit> as a toplevel definition, yes, it is garbage
13:29:02 <geekosaur> xico, I mean you have not told us what's really going on
13:29:05 <geekosaur> and you still haven't
13:29:08 <Hermit> (without a type signature, that is..>)
13:29:16 <xico> Hermit: why?
13:29:18 <hmmh> Anyone recommend a good library for prng for crypto?
13:29:18 <geekosaur> and you xpect us to read your mind and figure out a solution
13:29:50 <Hermit> xico: top level definitions must have a type signature, period
13:29:51 <geekosaur> I am tossing out nonsense to demnstrate that *you* are tossing out nonsense.
13:30:19 <geekosaur> because what I am describing fits what you have told us. because you haven't told us your real problem
13:31:54 <xico> geekosaur: well, i am sorry to hear that. to rephrase: assume that i am writing a compiler with the ghc api. someone typed "size = 9" in the interpreter. how do i get a value from that, *in* the ghc api?
13:32:06 <xico> since ghci let me do that, i assumed it was ok
13:32:13 <xico> contrarily to what hermit said
13:32:26 <geekosaur> xico: if you made it polymorphic, you can't until the next or next+1 version of ghc
13:32:34 <geekosaur> Dynamic must currently have a concrete type
13:32:56 <xico> geekosaur: what do you mean? works fine with ghci
13:32:59 <geekosaur> ghci gives it some kind of type, via defaulting
13:33:08 <xico> yeah, that's my question
13:33:12 <xico> how do i do that
13:33:25 <xico> since the type given by ghci is Num a => a
13:33:47 <xico> i guess i will have to look at ghci code
13:34:27 <geekosaur> I don't know how you do it eactly with ghc-api, but conceptually it asks for a concrete type from the inference engine which uses defaulting to get a monomorphic type
13:35:39 <xico> ghci> (size::Int,size::Double)
13:35:40 <xico> (9,9.0)
13:35:47 <xico> no defaulting here
13:35:47 <geekosaur> if you turn off the MMR you can have polymorphic top levels, but a value is necessarily monomorphic
13:36:06 <xico> *that* is what i want
13:36:07 <geekosaur> (unless it's magic in the compiler, like a numeric literal is a function call)
13:36:19 <xico> no literals do not matter
13:36:28 <xico> nor defaulting
13:36:49 <geekosaur> you just muisunderstood what I was saying and are back to "you haven't told us what you're doing"
13:37:05 <geekosaur> or else you misunderstood that a value has A type.
13:37:10 <geekosaur> not "many types"
13:37:57 <geekosaur> if you ask for your `size`, you can only have it at some particular single type.
13:38:11 <geekosaur> let me put it this way: take your setup. instead of size...
13:38:15 <geekosaur> :t maxBound
13:38:15 <lambdabot> Bounded a => a
13:38:28 <geekosaur> give me the answer you want if I ask for that.
13:38:37 <geekosaur> *tell me...
13:38:58 <xico> yep, that is exactly what i want to do. instantiating for a given particular type. in ghc code.
13:39:03 <jle`> fizruk: thanks for the link.  i wonder if my university provides me with a subscription
13:39:21 <geekosaur> xico: that si what defaulting does.
13:39:28 <geekosaur> except ou just insisted defaulting has nothing to do with it
13:40:00 <geekosaur> which is the same thing you did a couple minutes ago "I demand you solve a contradiction while keeping it ocntradictory"
13:41:09 <Sagi> :t (join . ap [\a->[a]] . return)
13:41:10 <lambdabot> a -> [a]
13:41:21 <tac> @type join . join . (,)
13:41:21 <lambdabot>     Couldn't match type `(->) b0' with `(,) a0'
13:41:22 <lambdabot>     Expected type: a0 -> b0 -> b0 -> b0 -> a1
13:41:22 <lambdabot>       Actual type: a0 -> b0 -> (a0, b0)
13:41:54 <Sagi> having both join and return in the same pointfree expression gives me the impression that I should be able to simplify, anyone? :-)
13:43:39 <Rarrikins> @type ap
13:43:40 <lambdabot> Monad m => m (a -> b) -> m a -> m b
13:44:14 <meow45> Where is String defined? Is it in GHC.Base of the base package?
13:45:07 <meow45> Yes, it is. http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Base.html#String
13:45:13 <briennetheblue> isn't that just return?
13:45:46 <Rarrikins> Sagi: Isn't that (:[])?
13:45:59 <briennetheblue> or more specifically that ^^
13:46:21 <Rarrikins> > (join . ap [\a -> [a]] . return) 50
13:46:22 <lambdabot>   [50]
13:46:28 <Rarrikins> > (:[]) 50
13:46:29 <lambdabot>   [50]
13:46:43 <jle`> > return 50 :: [Int]
13:46:45 <lambdabot>   [50]
13:46:47 <briennetheblue> i think return looks nicer than (:[]) though
13:46:59 <briennetheblue> or pure, w/e
13:47:50 <Sagi> yeah, it is. But I mean to replace \a->[a] with an actual list of useful functions
13:48:00 <Sagi> I included it here just as a means to force the type
13:48:04 <jle`> in that case isn't it just bind
13:48:12 <Sagi> :t \x -> (join . ap x . return)
13:48:13 <lambdabot> Monad m => m (a1 -> m a) -> a1 -> m a
13:48:24 <Sagi> it looks an awful look like it
13:48:28 <Sagi> :t (>>=)
13:48:28 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:48:32 <jle`> er not quite bind
13:49:53 <Sagi> ah well, it's nice enough as it is.
13:50:10 <arkeet> @quote (:[
13:50:10 <lambdabot> Plugin `quote' failed with: user error (parseRegex for Text.Regex.TDFA.String failed:"(:[" (line 1, column 4):
13:50:10 <lambdabot> unexpected end of input
13:50:10 <lambdabot> expecting "^", "]", "-" or Failed to parse bracketed string)
13:50:12 <arkeet> er
13:50:33 <arkeet> @quote \(:\[
13:50:33 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
13:50:43 <briennetheblue> lol
13:51:39 <arkeet> :t \f -> join . f . return
13:51:40 <lambdabot> (Monad m, Monad m1) => (m1 a -> m (m a1)) -> a -> m a1
13:51:53 <arkeet> =(
13:52:43 <Rarrikins> @type flip concatMap [\a -> [a]] . flip ($)
13:52:43 <lambdabot> b -> [b]
13:52:51 <Rarrikins> flip concatMap [\a -> [a]] . flip ($) $ 5
13:52:56 <Rarrikins> > flip concatMap [\a -> [a]] . flip ($) $ 5
13:52:57 <lambdabot>   [5]
13:59:33 <enthropy> :k (->)
13:59:34 <lambdabot> * -> * -> *
13:59:45 <enthropy> did arrow at some point have kinds ?? and such
13:59:57 <enthropy> to signify when unboxed things are allowed
13:59:58 <hpc> yes
14:00:02 <enthropy> does it still have that?
14:00:05 <hpc> many ghcs ago
14:00:17 <hpc> (ghc is a unit of time)
14:00:19 * enthropy can't get that printed out
14:00:25 <enthropy> roughly a year
14:04:17 <mgccl> so I found how to use finger tree to replace a extension of fenwick tree(some people call segment tree)... and I went online... no one in the world has described this before...
14:05:13 <enthropy> there might be some synonyms for "finger tree" to look for
14:07:10 <S_J> > pair 4
14:07:11 <lambdabot>   Not in scope: `pair'
14:08:24 <pavonia> > join (,) 4
14:08:25 <lambdabot>   (4,4)
14:09:53 <S_J> @src join
14:09:53 <lambdabot> join x =  x >>= id
14:10:03 <hmmh> Hey. I'm trying to generate a vector of random nums like so: [v <- uniformR (1,10000) gen | _ <- [1..5]]. Any idea why this fails?
14:10:51 <S_J> > join 5
14:10:52 <lambdabot>   No instance for (GHC.Show.Show (m0 a0))
14:10:52 <lambdabot>    arising from a use of `M67565734...
14:11:07 <S_J> > join (+) 8
14:11:08 <lambdabot>   16
14:11:13 <S_J> > join (+) 5
14:11:14 <lambdabot>   10
14:11:19 <jle`> :t uniformR
14:11:19 <lambdabot> Not in scope: `uniformR'
14:11:21 <S_J> > join (-) 5
14:11:22 <lambdabot>   0
14:11:27 <S_J> > join (*) 5
14:11:28 <lambdabot>   25
14:11:41 <hmmh> uniformR is in System.Random.MWC
14:11:43 <S_J>  > (*) >>= id 5
14:11:49 <S_J>  > ((*) >>= id) 5
14:12:09 <S_J> i dont get join
14:12:25 <arkeet> :t join
14:12:26 <lambdabot> Monad m => m (m a) -> m a
14:12:37 <arkeet> the type basically tells you
14:12:38 <hmmh> Maybe a better question: what is the haskell equivalent of the [i for i in range(blah)] syntax of python?
14:13:01 <arkeet> hmmh:
14:13:02 <arkeet> > [1..10]
14:13:03 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
14:13:09 <arkeet> S_J: join :: (r -> r -> a) -> (r -> a)
14:13:12 <arkeet> join :: [[a]] -> [a]
14:13:16 <arkeet> and so on
14:13:32 <jle`> hmmh: well, it's [ i | i <- [1..5] ]
14:13:40 <arkeet> ok, sure
14:13:55 <arkeet> > [chr i | i <- [48..57]]
14:13:56 <lambdabot>   "0123456789"
14:14:03 <jle`> but list comprehensions are rarely idiomatic haskell; usually you do better with things like map
14:14:19 <jle`> > map chr [48..57]
14:14:20 <lambdabot>   "0123456789"
14:14:32 <jle`> your problem is that you can't really use it to generate random numbers like that
14:14:44 <jle`> because of issues of purity and state and stuff like that.
14:15:10 <arkeet> and because of types
14:15:14 <hmmh> jle`: ugh. Ok so how would I fill a list with some random numbers on the interval (a,b)
14:15:23 <arkeet> how many random numbers?
14:15:25 <arkeet> :t replicateM
14:15:25 <lambdabot> Monad m => Int -> m a -> m [a]
14:15:45 <arkeet> :t randomR
14:15:46 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
14:15:48 <hmmh> arkeet: 5 maybe. n ideally
14:16:40 <jle`> first of all, do you understand the fundamental reasoning why it's slightly non-trivial in a pure language?
14:17:18 <companion_cube> edwardk: what was the lattice-valued datalog you talked about once?
14:17:20 <arkeet> :t getRandomR
14:17:20 <arkeet> :t (getRandomR)
14:17:20 <lambdabot> Not in scope: `getRandomR'
14:17:21 <lambdabot> Not in scope: `getRandomR'
14:17:37 <arkeet> bleh
14:17:38 <arkeet> :t randomRIO
14:17:38 <lambdabot> Random a => (a, a) -> IO a
14:17:40 <arkeet> :t replicateM 5 (randomRIO (1,10))
14:17:41 <lambdabot> (Num a, Random a) => IO [a]
14:17:55 <hmmh> jle`: yeah I do, I just find it irritating that a simple task like that should be so complicated
14:19:40 <arkeet> :t randomRs
14:19:41 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> [a]
14:19:53 <arkeet> will make an infinite list of random numbers
14:19:59 <hmmh> arkeet: where is randomR found?
14:20:12 <arkeet> ask hoogle
14:20:24 <jle`> if you are comfortable with monads it's only slightly more complicated.  but i guess it is a little silly that something so simple in another language requires hoops at all in haskell.  but the benefit is a type system that actually encapsulates side effects
14:20:27 <arkeet> I don't know what uniformR is.
14:20:38 <jle`> also there usually is a library function that makes things easier
14:20:54 <hmmh> arkeet: uniformR is found in System.Random.MWC
14:21:10 <edwardk> companion_cube: well, its a generalization of the work that nwf and those guys have ben doing on dyna to get a version that works for unification under omega-continuous semirings, rather than just star-semirings.
14:21:19 <edwardk> companion_cube: its not a completed thing though
14:21:37 <companion_cube> edwardk: but didn't you cite a p-logic stuff or something?
14:21:50 <companion_cube> some theory of lattice-valued logic programming?
14:21:53 <ReinH> :t randomRs
14:21:54 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> [a]
14:22:03 <companion_cube> btw, do you use bottom-up or top-down evaluation?
14:22:04 <hmmh> jle`: fair enough. I get the advantages of the type system, but I'm starting to wonder if all the trouble is worth it beyond the 'gee-whiz' factor for doing simple tasks
14:22:50 <jle`> what's the point of the type system at all?
14:23:27 <hmmh> If the purpose is to allow individuals to reason about the program and for the compilers to optimize, why can't the language let users play in the impure sandbox in a less fiddlesome way
14:23:46 <edwardk> companion_cube: "yes". its a bit of both currently.
14:23:56 <ReinH> > take 10 $ randomRs (1,10) (mkStdGen 1)
14:23:58 <edwardk> companion_cube its for a datalog so thats valid.
14:23:58 <lambdabot>   [8,9,8,10,1,10,7,8,3,1]
14:24:21 <edwardk> companion_cube: the reason for both is mainly because http://www.cs.stonybrook.edu/~liu/papers/RuleQueryBeat-SIGMOD11.pdf
14:24:32 <ReinH> It's really not that hard. You just need IO for newStdGen.
14:24:41 <edwardk> companion_cube: anyways i was mostly doing bottom up and aheller was focused on top down
14:24:43 <hmmh> ReinH: thanks! :)
14:24:58 <edwardk> companion_cube: i've since been rather distracted by other things
14:25:33 <ReinH> hmmh: mkStdGen takes a seed, you use newStdGen to split a new generator from the global random generator. This requires IO.
14:26:11 <companion_cube> looks pretty sophisticated
14:26:26 <companion_cube> I'm starting to like regular top-down with tabbling actually (with stratified negation)
14:27:02 <AlexRussia> hello!
14:27:14 <jle`> ah i guess there is a pure monadless solution that handles the seed passing for you
14:27:27 <AlexRussia> You can ask a question about Yi?
14:28:05 <ReinH> jle`: well you can use getStdRandom
14:28:08 <ReinH> :t getStdRandom
14:28:09 <lambdabot> (StdGen -> (a, StdGen)) -> IO a
14:28:19 <ReinH> :t random
14:28:19 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
14:28:48 <hmmh> thanks
14:28:50 <jle`> yeah, but if you want to chain a sequence of random generations from the same seed, it gets slightly hairier
14:28:51 <hmmh> :q
14:29:05 <zerokarmaleft> hmmh: once you tackle other problems using monadic style, what seems like hoop-jumping now will end up as a generalized abstraction that works across a swath of different types of effectful problems
14:29:19 <ReinH> jle`: well you can use MonadRandom
14:29:26 <ReinH> For simple stuff it's often easy to just use IO
14:29:39 <jle`> ReinH: yeah, that's what i meant.  you have to jump into monads if you want to chain operations in a pure way
14:29:49 <ReinH> you don't *have* to
14:29:57 <ReinH> but it's easier to
14:30:15 <zerokarmaleft> guess I missed him :-/
14:30:19 <jle`> well, you do if you want to take advantage of all of the neat library monad functions
14:30:23 <jle`> but yes, you do'nt have to :P
14:30:50 <jle`> admittedly in one of my first haskell projects (a monte carlo simulator) i did all of the seed passing explictly ...
14:30:58 <SwineFlu> I always think its really dumb when my instuctor uses recursion for things that could just use a list comprehension
14:31:02 <AlexRussia> Sorry, easy it error in install in cabal http://pastebin.com/thUKkii1
14:31:07 <mauke> The paste thUKkii1 has been copied to http://lpaste.net/94386
14:31:39 <ryant5000> is there a reason "cabal init" doesn't add a main-is field to the executable section?
14:31:54 <ikarus> if I need a list of n 0's I assume I can do something saner then [0 | x <- [0..n]]
14:31:57 <jle`> SwineFlu: well ... most fp courses just use recursion as a learning thing.  who actually uses explicit recursion in real life
14:32:05 <zebr> ikarus: duplicate
14:32:12 <zebr> or.. replicate rather
14:32:53 <SwineFlu> Is there any time that using explicit recursion is best practice
14:32:58 <AlexRussia> Okay.
14:33:14 <jle`> they just really do it as a flashy way to say, "hey look!  you can do looping ... without loops!"
14:33:19 <ryant5000> it seems a bit odd that "cabal init" results in an unbuildable project
14:33:26 <ryant5000> (owing to the missing main-is)
14:33:42 <SwineFlu> Also we learned about recursion in CS101 but our level 3 functional programming class spends so many lectures on it
14:33:43 <SwineFlu> lame
14:33:43 <Sagi> is there a way to pattern match a constructor without wildcarding all its fields?
14:33:56 <jle`> Sagi: you can use the empty record
14:34:03 <jle`> Just {}
14:34:06 <simpson> SwineFlu: Yes, explicit monadic recursion is pretty common.
14:34:16 <jle`> er ... that's probably not the actual name of the construct
14:34:18 <Sagi> does that work even if I don't use record syntax in de the definition?
14:34:20 <cschneid> zebr: is there a "make me an infinite list of a constant value"? like replicate but infinite list
14:34:31 <arkeet> repeat
14:34:37 <simpson> jle`: Clojure has recur as a primitive form. I guess people like Clojure?
14:34:51 <cschneid> arkeet: cool
14:35:24 <jle`> > let isJust = case m of Just {} -> True; Nothing -> False
14:35:25 <lambdabot>   not an expression: `let isJust = case m of Just {} -> True; Nothing -> False'
14:35:26 <SwineFlu> I've not learned monads yet and we don't do it on my course lol
14:35:33 <arkeet> > repeat 2
14:35:34 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
14:35:40 <jle`> > let isJust = case m of Just {} -> True; Nothing -> False in (m (Just 5), m Nothing)
14:35:41 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
14:35:42 <lambdabot>              w...
14:35:44 <SwineFlu> I think I need to learn some category thoery first
14:35:58 <cschneid> > take 5 $ repeat 2
14:35:59 <lambdabot>   [2,2,2,2,2]
14:36:12 <cschneid> @src replicate
14:36:12 <lambdabot> replicate n x = take n (repeat x)
14:36:17 <arkeet> :-)
14:36:19 <Ralith> > let isJust = case m of { Just {} -> True; Nothing -> False } in (m (Just 5), m Nothing)
14:36:20 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
14:36:20 <lambdabot>              w...
14:36:23 <loadedanvils> hey haskell guys
14:36:32 <arkeet> jle`: surely you mean isJust (Just 5) etc.
14:36:36 <Ralith> of course, 'm' is undefined
14:36:38 <ReinH> loadedanvils: and ladies :)
14:36:51 <Ralith> but that resolves your syntax issues anyway
14:36:52 <loadedanvils> yep
14:36:56 <jle`> arkeet: yes, heh. i slipped.
14:37:10 <Sagi> jle`: thanks
14:37:16 <arkeet> it's too bad english doesn't have any non-awkward gender-neutral pronouns and such.
14:37:28 <cschneid> hey ya'll.
14:37:30 <cschneid> that can work
14:37:37 <arkeet> non-awkward
14:37:37 <jle`> Sagi: ghc-mod actually tips you off to this
14:37:38 <arkeet> ;)
14:37:53 <simpson> arkeet: One can easily work their way through any conversation they please with a careful consideration of their words.
14:38:04 <cschneid> hah. I swear I saw an article about the word 'yo' being picked up by certain small groups of kids for that use. But that seems awkward too
14:38:10 <cschneid> but who knows, maybe I'm old and grumpy
14:38:15 <jle`> simpson: yes but you do sacrifice expressiveness
14:38:20 <arkeet> anyway, -blah
14:38:49 <simpson> jle`: One would think that being in #haskell is an indication of one's beliefs on the importance of expression and sacrifice. :3
14:38:54 <loadedanvils> is haskell as fast as they say it is? (I'm new)
14:38:57 <jle`> > let isJust = case m of { Just {} -> True; Nothing -> False } in (isJust (Just 5), isJust Nothing)
14:38:58 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
14:38:58 <lambdabot>              w...
14:39:01 <loadedanvils> particularly with scraping
14:39:48 <jle`> loadedanvils: how fast is fast
14:40:10 <eflister> is there any way use parsec combinators (like 'many') with transformed parsers (where ParsecT is not outer-most)?  would this need some kind of mtl-ish class like MonadParsec?  does this mean switching to Trifecta?  and does Trifecta call it "Parsing" instead of "MonadParsec"?
14:40:22 <chrisdone> jle`: back to the future fast
14:40:42 <edwardk> @hackage parsers
14:40:42 <lambdabot> http://hackage.haskell.org/package/parsers
14:40:46 <edwardk> eflister: ^- that
14:41:07 <edwardk> eflister: parsers provides monad-transformer-liftable versions of the parsec combinators basically
14:41:09 <eflister> edwardk: thanks!
14:41:09 <jle`> i guess it wans't fast enough for him
14:41:52 <edwardk> and MonadParsec isn't precisely accurate, and the class doesn't require Monad, merely Applicative since there are several folks using this for applicative parser combinator libraries.
14:41:59 <edwardk> so MonadFoo wouldn't be appropriate
14:42:26 <Sagi> jle`: I'm unfamiliar with that term, I'll google it
14:42:30 <eflister> edwardk: is Trifecta more for streaming parsers?
14:42:46 <donri> edwardk: ah you uploaded new parsers. should probably do parsec-parsers too ;)
14:42:52 <simpson> eflister: Trifecta's for the kind of pretty colorized output you get when you use e.g. clang.
14:43:34 <jle`> > let isJust x = case x of { Just {} -> True; Nothing -> False } in map isJust [Just 1, Nothing]
14:43:35 <lambdabot>   [True,False]
14:43:38 <edwardk> eflister: trifecta builds on parsers, its actually the opposite of a streaming parser, more about how you can have a rope of all historical entry and do nonstandard things like jump around to reparse
14:43:55 <Sagi> bravo :-)
14:44:04 <edwardk> eflister: parsers however, is now independent of trifecta, because folks wanted to use the fact that most of the trifecta combinators worked over monad transformers but they wanted it for parsec, etc.
14:44:56 <eflister> edwardk: ok great, thanks!
14:45:04 <cschneid> jle`: what's the {} in `Just {}` there?
14:45:33 <cschneid> jle`: I'd have written it as something like (Just _) -> True, at least I thought so?
14:46:34 <jle`> cschneid: it's trivial in this case, but sometimes you have data types with many fields where you have to do Something _ _ _ _ _ _ _
14:46:44 <jle`> so instead of Something _ _ _ _ _ _ _ you can just use Something {}
14:46:57 <cschneid> jle`: ahh, sweet. So it's record syntax where you capture nothing into a local name.
14:46:58 <peder> does @@ in comments mean anything?
14:47:21 <jle`> cschneid: that's it
14:47:48 <jle`> but it works even if the original type is not defined using record syntax
14:47:53 <cschneid> that's cool
14:48:11 <cschneid> jle`: although presumably in that case you'd have to fall back to `Something _ _ _ _ x _ _` if you wanted that x field
14:48:22 <cschneid> jle`: although I suppose the moral of the story is to not do that.
14:48:22 <Sagi> is there a simple way to access the first field in sum type?
14:48:32 <Sagi> I know the answer is probably 'lenses'
14:48:34 <arkeet> peder: haddock uses @...@ for code
14:48:44 <Sagi> but I haven't found time to get my head around those :-\
14:48:49 <arkeet> Sagi: which sum type?
14:48:57 <Sagi> my own
14:49:03 <jle`> cschneid: yeah, true; you probably have bigger problems if you have to do that.
14:49:04 <peder> arkeet: the lines i have here are just -- @@ bla bla
14:49:09 <arkeet> peder: hmm
14:49:25 <arkeet> Sagi: you'll have to do it manually I guess?
14:49:33 <Sagi> data Frop = Foo String String | Bar String String | ..
14:49:41 <jle`> oh you mean "some" type
14:49:51 <jle`> er
14:49:54 <jle`> or are they actually called sum types
14:49:56 <jle`> and i sound stupid
14:49:59 <arkeet> jle`: yep ;)
14:50:03 <jle`> haha.
14:50:05 <arkeet> Either a b is the "sum" of a and b
14:50:24 <arkeet> (because its values are the values of a + the values of b)
14:50:24 <blume> i do understand why "join $ Just (Just 2) == Just 2" but why does "join (,) 2" replicate the 2 ?
14:50:32 * hackagebot unix-time 0.2.1 - Unix time parser/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.2.1 (KazuYamamoto)
14:50:36 <arkeet> blume: join :: (r -> r -> a) -> (r -> a)
14:50:44 <arkeet> for that particular monad
14:50:59 <arkeet> :t join
14:51:00 <Sagi> so basically that'd mean that I'm looking for a simple way to write getFirst :: Frop -> String :-)
14:51:00 <lambdabot> Monad m => m (m a) -> m a
14:51:03 <arkeet> :t join `asAppliedTo` (,)
14:51:04 <lambdabot> (a -> a -> (a, a)) -> a -> (a, a)
14:51:24 <arkeet> Sagi: consider
14:51:29 <arkeet> data T = Foo | Bar | ...
14:51:33 <arkeet> data Frop = Frop T String String
14:51:49 <xrdb> :t join
14:51:49 <lambdabot> Monad m => m (m a) -> m a
14:51:55 <arkeet> assuming that works for you
14:52:06 <arkeet> take m = (r ->) in this ^
14:52:52 <cschneid> Sagi: afaik, you cannot write a general purpose function that does that. But lens + the template haskell creation of lenses would make that easy.
14:53:08 <blume> arkeet: thanks
14:53:38 <enthropy> @wiki syb
14:53:39 <lambdabot> http://www.haskell.org/haskellwiki/syb
14:53:45 <Sagi> arkeet: hmm, it might, I'm not sure yet. I can use it until I run into trouble though :-)
14:54:40 <pxqr> I guess yesod always print "Internal Server Error" on exceptions for security reasons, even if I throw (error "holy ****!"). But is it possible to get more detailed error message? e.g. configure logger, or... ?
14:54:51 <enthropy> Sagi: the actual page is http://www.haskell.org/haskellwiki/Generics
14:54:52 <jle`> what does the monad instance of (,) even mean
14:55:00 <NihilistDandy> zenhob:
14:55:01 <jle`> is it related at all to the functor instance
14:55:06 <Sagi> arkeet: clutters the pattern matching with Frop though
14:55:08 <zenhob> sup NihilistDandy
14:55:17 <arkeet> Sagi: =(
14:55:29 <arkeet> Sagi: another thing you could do is
14:55:33 <quchen> jle`: "join (,)" uses the Monad instance for functions, not for tuples.
14:55:40 <arkeet> data Frop = Foo { a :: String, b :: String } | Bar { a :: String, b :: String } | ...
14:55:47 <Sagi> enthropy: hmm?
14:55:48 <arkeet> then a and b work like you'd think
14:55:51 <quchen> jle`: (,) is not a tuple but it's a function that creates one.
14:56:10 <enthropy> well I think the "lens" solution involves using plated or somthing like that
14:56:12 <jle`> quchen: ah.  thanks for the insight. not back to ghci
14:56:16 <jle`> *now
14:56:24 <quchen> jle`: (Tuples do have a Monad instance, but that's unrelated to what you talked about earlier.)
14:56:29 <pxqr> ok, it turns out that exception thrown somewhere from persist layer
14:56:37 <enthropy> whose implementation is probably the GHC.Generics
14:56:50 <Sagi> ah
14:56:52 <Sagi> I
14:56:56 <pxqr> though I have no clue why
14:56:59 <Sagi> I'll put it on my reading list
14:57:09 <Sagi> found https://www.fpcomplete.com/user/tel/a-little-lens-starter-tutorial as well
14:57:18 <enthropy> @let data Frop = Foo String String | Bar String String deriving (Data)
14:57:19 <lambdabot>  .L.hs:151:20:
14:57:19 <lambdabot>      No instance for (Typeable Frop)
14:57:19 <lambdabot>        arising from the '...
14:57:23 <enthropy> @let data Frop = Foo String String | Bar String String deriving (Data, Typeable)
14:57:24 <lambdabot>  Defined.
14:58:16 <blume> :t join `asAppliedTo` (->)
14:58:17 <lambdabot> parse error on input `->'
14:58:25 <blume> :t join `asAppliedTo` (*)
14:58:25 <lambdabot> Num a => (a -> a -> a) -> a -> a
14:58:38 <blume> :t join `asAppliedTo` (r ->)
14:58:39 <lambdabot> parse error on input `)'
14:59:05 <blume> i really should read more and program less.
14:59:19 <enthropy> > gmapQi 1 (fromMaybe "ERROR!" . cast) `map` [Foo "abc1" "def2", Bar "bar1" "bar2"]
14:59:23 <lambdabot>   ["def2","bar2"]
14:59:24 <Sagi> blume: oh, we complement nicely then
14:59:31 <enthropy> > gmapQi 0 (fromMaybe "ERROR!" . cast) `map` [Foo "abc1" "def2", Bar "bar1" "bar2"]
14:59:34 <lambdabot>   ["abc1","bar1"]
15:00:10 <jle`> hm. what is the monad instance for function supposed to mean then.  i can't think of a meaningful bind
15:00:33 * hackagebot lio 0.11.3.0 - Labeled IO Information Flow Control Library  http://hackage.haskell.org/package/lio-0.11.3.0 (DavidMazieres)
15:00:49 <simpson> jle`: Reader.
15:01:28 <donri> :t return return return return
15:01:29 <lambdabot>     Could not deduce (Monad m0) arising from a use of `return'
15:01:29 <lambdabot>     from the context (Monad m, Monad m1)
15:01:29 <lambdabot>       bound by the inferred type of
15:02:00 <blume> :t join `asAppliedTo` ((->) r)
15:02:01 <lambdabot> parse error on input `->'
15:02:07 <Sagi> enthropy: that's cool
15:02:23 <arkeet> :t const const const const
15:02:24 <lambdabot> b -> a -> b1 -> a
15:02:44 <briennetheblue> :t asAppliedTo
15:02:45 <lambdabot> (a -> b) -> a -> a -> b
15:03:20 <simpson> I mean, we're talking about join :: (e -> e -> a) -> e -> a
15:03:23 <simpson> It's not that fancy.
15:03:31 <arkeet> there's also only one way to write it.
15:03:50 <arkeet> @free join :: (r -> r -> a) -> r -> a
15:03:50 <lambdabot> (forall x. g . h x = k (f x) . f) => g . join h = join k . f
15:04:03 <arkeet> hm
15:04:07 <Sagi> :t cast
15:04:08 <lambdabot> (Typeable a, Typeable b) => a -> Maybe b
15:04:34 <simpson> :t \f e -> f e e
15:04:35 <lambdabot> (t1 -> t1 -> t) -> t1 -> t
15:04:46 <arkeet> @djinn join :: (r -> r -> a) -> r -> a
15:04:47 <lambdabot> Cannot parse command
15:04:51 <arkeet> @djinn (r -> r -> a) -> r -> a
15:04:51 <lambdabot> f a b = a b b
15:05:33 * hackagebot snap-elm 0.1.1.2 - Serve Elm files through the Snap web framework.  http://hackage.haskell.org/package/snap-elm-0.1.1.2 (KyleCarter)
15:05:35 <Sagi> :t gmapQi 0
15:05:35 <lambdabot> Data a => (forall d. Data d => d -> u) -> a -> u
15:05:39 <jle`> can someone help me understand why this is the same as (* 3)
15:05:53 <jle`> > let f = (* 2) >>= (+) in map f [1..10]
15:05:54 <lambdabot>   [3,6,9,12,15,18,21,24,27,30]
15:06:45 <jle`> oh. do you do x * 2 then + x?  like (x * 2) + x
15:06:48 <briennetheblue> because 3x = x + 2x i would think
15:07:06 <Rarrikins> jle`: It gets *2, then it applies + to both the unmodified input and the output of the other function.
15:07:29 <arkeet> (m >>= f) x = join (fmap f m) x = join (f . m) x = (f . m) x x
15:07:29 <arkeet> ((*2) >>= (+)) x = ((+) . (*2)) x x = (+) ((*2) x) x
15:07:29 <arkeet> = (x*2) + x
15:07:35 <jle`> so the monad instance for a function creates a new function that repeatedly applies the composed-of functions with x?
15:08:18 <arkeet> f = (*2) >>= \a -> (a+)
15:08:18 <jle`> ah, this is the key: ((+) . (*2)) x x
15:08:36 <arkeet> = do { a <- (*2); b <- (a+); return b }
15:08:48 <arkeet> so when you give f an argument,
15:08:50 <jle`> ^^ that makes sense too
15:08:52 <arkeet> yeah
15:09:10 <jle`> the do notation made things clear. how weird
15:09:10 <arkeet> it gets twice the argument, then gets the sum of the argment with that.
15:09:12 <arkeet> heh
15:10:15 <jle`> is this useful
15:10:31 <arkeet> yes, if you're trying to confuse someone ;)
15:11:31 <jle`> another item for my toolbox
15:13:35 <briennetheblue> > reverse >>= (==) $ "racecar"
15:13:36 <lambdabot>   True
15:16:46 <arkeet> :t on
15:16:47 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
15:16:48 <arkeet> :t (=<<)
15:16:49 <lambdabot> Monad m => (a -> m b) -> m a -> m b
15:17:09 <arkeet> not quite.
15:17:21 <kuribas> Why would the function monad be useful?
15:17:26 <arkeet> @let f .: g = \x y -> f (g x y)
15:17:27 <lambdabot>  Defined.
15:17:34 <arkeet> kuribas: it's the Reader monad
15:17:38 <arkeet> :t on .: join
15:17:39 <lambdabot> (t3 -> t3 -> b -> b -> c) -> t3 -> (a -> b) -> a -> a -> c
15:17:41 <arkeet> er
15:17:42 <arkeet> :t join .: on
15:17:43 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> c
15:17:58 <arkeet> still not quite.
15:18:50 <kuribas> The reader monad is the same as the function monad?
15:20:22 <arkeet> yes
15:20:33 <arkeet> Reader r a = r -> a
15:23:00 <briennetheblue> ((->) a) as an applicative is pretty cool, you can use liftA2 to turn a boolean operator into an operator on predicates or liftA2.liftA2 to turn it into an operator on relations
15:23:39 <ReinH> briennetheblue: examples?
15:24:57 <arkeet> liftA2 (+) f g = \x -> f x + g x
15:26:24 <briennetheblue> ReinH http://lpaste.net/94391
15:27:15 <Eduard_Munteanu> Is there a type-level lambda? It seems sort of doable.
15:27:53 <Eduard_Munteanu> Worst case you could generate a string of combinators to get that.
15:27:59 <arkeet> no
15:28:16 <kuribas> Eduard_Munteanu: No, because it wouldn't terminate.
15:28:34 <arkeet> someone who knows more about type theory can explain.
15:28:36 <Eduard_Munteanu> kuribas: mm, why?
15:28:59 <Eduard_Munteanu> You can already *try* to write 'fix'.
15:29:53 <kuribas> Eduard_Munteanu: Well, type inference should terminate, so I think that's why lambda is not possible at the type level.
15:30:08 <blume> how would you translate "join (,) 2" into >>= when join is just "x >>= id" ?
15:30:23 <Iceland_jack> @undo join (,) 2
15:30:23 <lambdabot> join (,) 2
15:30:36 <Iceland_jack> bah
15:31:00 <Eduard_Munteanu> kuribas: why wouldn't it terminate? AFAICT you can always translate a lambda to app/abs, and at type-level it's a STLC without recursion.
15:31:07 <arkeet> join (,) 2 = ((,) >>= id) 2
15:31:48 <Iceland_jack> Or you can just write (\a -> (a, a))
15:33:14 <blume> thanks. should have asked earlier. has been bugging me for the last hour
15:33:16 <Iceland_jack> @undo (do x <- (,); x) 2
15:33:16 <lambdabot> ((,) >>= \ x -> x) 2
15:34:37 <blume> glad i'm able to sleep now :) good night.
15:34:53 <kuribas> Eduard_Munteanu: Would it be a typed lambda or untyped?  AFAIK an untyped lambda expression may not terminate.
15:35:02 <Iceland_jack> blume: Was join keeping you up? :)
15:35:10 <Iceland_jack> ah, missed them
15:35:13 <arkeet> (\x -> x x) (\x -> x x)
15:35:18 <Eduard_Munteanu> kuribas: yes, typed. Or "kinded" you might say. :)
15:35:59 <kuribas> Eduard_Munteanu: In that case, I don't know...
15:36:52 <itsme_> Hi, is there a short syntax for: foldr (\x y -> x+10*y)? something like foldr (+10*) ?
15:37:07 <latro`a> @pl \x y -> x+10*y
15:37:10 <lambdabot> flip ((.) . (+)) (10 *)
15:37:11 <lambdabot> optimization suspended, use @pl-resume to continue.
15:37:25 <latro`a> or in other words, no, not really
15:37:47 <latro`a> that particular one can be done with <*>, I think, but you don't gain much brevity
15:38:04 <Rarrikins> @type foldr
15:38:05 <lambdabot> (a -> b -> b) -> b -> [a] -> b
15:38:07 <Iceland_jack> itsme_: It's quite possible that you can abstract over this
15:38:23 <Iceland_jack> for example it seems like you're trying to make something into base-10?
15:39:18 <itsme_> 10 is just an example
15:39:23 <Rarrikins> foldl`
15:39:26 <Rarrikins> foldl'
15:39:38 <Iceland_jack> Right, but for that particular example, something like
15:39:38 <Iceland_jack> > sum (zipWith (*) [1,2,3,4,5,6] (reverse [ 10^i | i <- [0..]]))
15:39:38 <Iceland_jack> might be a solution
15:39:40 <colluphid> do you ever really need 'if' statments in haskell? can't you use guards instead?
15:39:45 <Rarrikins> > foldl' ((+) . (10*)) [1,2,3,4]
15:39:46 <lambdabot>   mueval-core: Time limit exceeded
15:39:48 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable t0)
15:39:48 <lambdabot>    arising from a use ...
15:39:54 <Iceland_jack> > sum (zipWith (*) [1,2,3,4,5,6] (reverse [ 10^i | i <- [0..]]))
15:39:54 <Rarrikins> > foldl' ((+) . (10*)) 0 [1,2,3,4]
15:39:55 <lambdabot>   can't find file: L.hs
15:40:01 <lambdabot>   mueval-core: Time limit exceeded
15:40:03 <Iceland_jack> sigh
15:40:07 <Eduard_Munteanu> colluphid: or 'case of', so yeah, you don't really need that.
15:40:12 <Iceland_jack> oh damn, the reverse
15:40:18 <Rarrikins> > foldl' ((+) . (10*)) 0 [1,2,3,4]
15:40:19 <lambdabot>   1234
15:40:21 <Eduard_Munteanu> colluphid: it's annoying because of the indentation.
15:40:30 <Iceland_jack> > sum (zipWith (*) (reverse [1,2,3,4,5,6]) [ 10^i | i <- [0..]])
15:40:31 <lambdabot>   123456
15:40:38 <Rarrikins> > foldr (flip ((+) . (10*))) 0 [1,2,3,4]
15:40:40 <lambdabot>   4321
15:40:50 <Iceland_jack> itsme_: Yes, and that's just an example of how you could decompose it
15:40:56 <Iceland_jack> I can't give you a general way
15:41:13 <itsme_> That was already very helpful, thanks!
15:41:14 <Iceland_jack> colluphid: No you don't really need if_then_else_'s, but they are nice sometimes
15:41:48 <colluphid> Iceland_jack: would it be frowned upon to put if_then_else inside a list comprehension?
15:41:59 <Iceland_jack> not at all, at least not in general
15:42:32 <Iceland_jack> > [ if ch == '1' then 1 else 0 | ch ← "01011110101111011" ]
15:42:37 <lambdabot>   [0,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1]
15:42:43 <Iceland_jack> as a silly example
15:43:57 <colluphid> thanks :)
15:45:52 <Eduard_Munteanu> How do you refer to (':) properly? Namely the type-lifted cons, i.e. DataKinds.
15:46:05 <Eduard_Munteanu> I'm getting a parse error with that.
15:46:47 <chrisdone> any flycheck users?
15:47:43 <Iceland_jack> Eduard_Munteanu: They don't appear to give it a specific name at a quick glance
15:47:56 <Iceland_jack> “promoted cons” may be it? it's called '(:) in the paper at least
15:48:45 <Eduard_Munteanu> Iceland_jack: hmm... '(:) still gives me a parse error
15:48:49 <khyperia> Lambdabot is whining about no source found on filterM... why?
15:48:57 <Eduard_Munteanu> I do have TypeOperators on.
15:49:07 <Iceland_jack> Do you have… I was just about to ask that :)
15:49:09 <arkeet> try ':
15:49:19 <Eduard_Munteanu> khyperia: lambdabot has a limited selection of source definition
15:49:21 <simpson> khyperia: lambdabot's source tool is hand-curated. If she doesn't know the source, it's probably just because she was never given the source.
15:49:23 <Eduard_Munteanu> *definitions
15:49:23 <arkeet> @where src
15:49:24 <lambdabot> The fixed database for the `src' lambdabot command is at <http://code.haskell.org/lambdabot/State/source>
15:49:25 <khyperia> ah
15:49:42 <khyperia> is there a way that I can find the source on my own?
15:49:43 <Iceland_jack> You should be able to use '(:) as a prefix though?
15:49:53 <arkeet> khyperia: hackage will have it probably
15:49:54 <Eduard_Munteanu> arkeet: I tried (':) already.
15:49:55 <Iceland_jack> khyperia: You can go on Hackage and click source
15:49:58 <arkeet> Eduard_Munteanu: hm
15:50:15 <Eduard_Munteanu> arkeet: oh, I should mention I want to refer to it as prefix, not apply it.
15:50:19 <chrisdone> simpson: giving objects under service female pronouns, so progressive
15:50:26 <Eduard_Munteanu> a ': b is fine.
15:50:43 <simpson> chrisdone: Sorry, I thought that lambdabot was female.
15:50:58 <Eduard_Munteanu> And I want to avoid a type synonym because those can't easily be partially applied.
15:51:10 <chrisdone> simpson: it's a bot. what are you talking about?
15:51:11 * Eduard_Munteanu isn't sure why though
15:51:48 <Eduard_Munteanu> chrisdone: she's a botgirl
15:51:53 <Eduard_Munteanu> :P
15:51:54 <mgsloan> chrisdone: simpson: Probably from here http://www.haskell.org/haskellwiki/Lambdabot
15:51:57 <khyperia> Found it, thanks
15:52:26 <simpson> chrisdone: All other bots that I've interacted with that have had lasting presences have had gendered pronouns, and I have heard other people use female pronouns for lambdabot. It's not a big deal.
15:52:30 <Eduard_Munteanu> Maybe a "botette"? :P
15:53:20 <chrisdone> simpson: you're welcome to your fetishes, i didn't say it was a big deal =p
15:53:56 <simpson> chrisdone: Wow. Well, clearly it's time to go to dinner.
15:54:04 <ryant5000> is there a chatroom for cabal maintenance discussion?
15:54:24 <dcoutts_> ryant5000: we usually use either #ghc or #hackage
15:54:38 <ryant5000> ok, cool
15:55:29 <nanicoar> Hello. Is a monad an instance?
15:55:43 <chrisdone> sure
15:55:52 <nanicoar> chrisdone: Awesome.
15:55:58 <chrisdone> \o/
15:56:31 <letrec> Hi
15:56:36 <Eduard_Munteanu> nanicoar: 'Monad' is a typeclass, and it *has* instances.
15:56:37 <chrisdone> the type itself which instantiates the class instance is the monad
15:57:00 <chrisdone> Eduard_Munteanu: he said 'is *a* monad …' [emphasis mine]
15:57:08 <arkeet> more importantly
15:57:09 <arkeet> a monad is nothing more
15:57:09 <Eduard_Munteanu> Ah.
15:57:14 <arkeet> (provided the instance satisfies the laws...)
15:58:10 <Sagi> donri, Twey: huge thanks to you both, I've rewritten my library to use the simplified sumtypes you guys proposed. I'm really happy with the result! And I learned a lot in the process \o/
15:59:00 <donri> \o/
15:59:34 <chrisdone> nanicoar: in as much as [a] is a monoid, or (), or as 1 or 'a' are orderables
16:00:01 <arkeet> chrisdone: but 1 and 'a' are values, not types
16:00:03 <chrisdone> (e.g. Int, Char, ())
16:00:20 <nanicoar> If a monad is an instance of itself, it has to be both single and plural.
16:00:54 <letrec> My latest random thought is that a polymorphic function of type (b -> c) -> (a -> b) -> a -> c   must be equal to (.). Can someone give me an implementation of such a function that wouldn't be equivalent to (.) to prove me wrong by any chance?
16:00:57 <chrisdone> nanicoar: If a monad is an instance of itself -- huh?
16:01:16 <hpc> letrec: undefined
16:01:36 <mjhoy> is there a way to point a .cabal file at a github repository for a certain package?
16:01:43 <chrisdone> hpc: presumably he means a total implementation
16:01:44 <nanicoar> chrisdone: So that is not a correct statement? I heard someone saying it in a video on what monads are.
16:02:08 <chrisdone> nanicoar: i can't tell what it means, sounds pretty nonsensical
16:02:10 <donri> mjhoy: nope, but i think cabal-meta or cabal-src does that
16:02:10 <Eduard_Munteanu> nanicoar: the typeclass 'Monad' defines what a monad provides. Monads are instances of the 'Monad' typeclass; we're using the same word with different meanings.
16:02:26 <letrec> hpc: it's not an actual implementation
16:02:46 <arkeet> class Strange (a :: * -> Constraint) where ..
16:02:46 <arkeet> instance Strange Strange
16:02:59 <arkeet> er
16:03:00 <hpc> chrisdone: unsafeCoerce? ;)
16:03:03 <arkeet> that's a kind error
16:03:10 <mjhoy> donri: thanks
16:03:37 <chrisdone> nanicoar: there's nothing special about monads here. you can swap out the word for other things: Num is a type-class, instances of it are said to be numbers. Ord -> orderables, Monoid -> monoids, Monad -> monads
16:04:42 <Eduard_Munteanu> I think he was confused by phrases like "a monad is an instance of Monad".
16:05:03 <chrisdone> that phrase seems ok to me
16:05:07 <nanicoar> Eduard_Munteanu: Pretty much yeah.
16:05:08 <Eduard_Munteanu> 'monad' and 'Monad' have different meanings.
16:05:26 <nanicoar> oh...
16:05:31 <arkeet> what about :a Monad"
16:05:34 <arkeet> "a Monad"
16:05:44 <chrisdone> “a readable is an instance of Read”
16:05:52 <Iceland_jack> nanicoar: Do you know how type classes work (Eq, Num, Ord, …)? If you don't you shouldn't bother figuring out how the Monad type class works
16:06:02 <Eduard_Munteanu> nanicoar: "Monad" is a typeclass, but "monad" in that context isn't.
16:06:32 <nanicoar> Iceland_jack: Classes yes, types yes. Type classes no.
16:06:44 <Iceland_jack> If you're thinking classes from OOP they are irrelevant here
16:06:46 <chrisdone> monad lower-case is just plain english, it doesn't have any meaning in Haskell
16:06:46 <Eduard_Munteanu> nanicoar: typeclasses == classes in #haskell
16:07:12 <nanicoar> Ack. My mortal enemy.,
16:07:13 <Iceland_jack> So nanicoar, I suggest you learn how type classes work and then you can re-address this question :)
16:07:33 <Eduard_Munteanu> Sounds like it's more of a language issue.
16:07:41 <Iceland_jack> Indeed
16:07:51 <chrisdone> yeah, once you grok how type-classes work properly the rest isn't a big deal
16:08:52 <nanicoar> Turns out that there are an nearly infinite number of wrong ways to write JavaScript and C++.
16:08:55 <Iceland_jack> Motivating question nanicoar:
16:08:56 <Iceland_jack> > 5    == 10
16:08:56 <Iceland_jack> > 5*pi == 10*pi
16:08:56 <Iceland_jack> Do you think these two expressions use the ‘same’ equality function?
16:08:57 <lambdabot>   can't find file: L.hs
16:08:57 <lambdabot>   False
16:09:03 <Iceland_jack> > 5 == 10
16:09:04 <lambdabot>   False
16:09:08 <Iceland_jack> > 5*pi == 10*pi
16:09:09 <lambdabot>   False
16:09:52 <nanicoar> Depends on your implementation of pi.
16:10:06 <Iceland_jack> nanicoar: what do you mean?
16:10:09 <arkeet> 5 == 10
16:10:10 <arkeet> 'a' == 'b'
16:10:14 <arkeet> probably a better example.
16:10:16 <Iceland_jack> Yes
16:10:38 <Iceland_jack> nanicoar: so 5 and 10 are Int's (for sake of example) and 'a' and 'b' are Char's
16:10:38 <nanicoar> integers, lists
16:10:39 <chrisdone> really, haskell is the only language i've worked in that gets equality right
16:10:49 <nanicoar> ack
16:10:59 <nanicoar> So all chars are not lists of chars?
16:11:06 <Iceland_jack> nanicoar: Chars are just Chars.
16:11:09 <jfischoff> chrisdone: true that
16:11:10 <Iceland_jack> Strings are lists of Chars.
16:11:25 <hpc> nanicoar: "depends on your implementation of pi" http://hackage.haskell.org/package/acme-php-0.0.3/docs/src/Prelude-PHP.html#line-72
16:11:55 <Iceland_jack> hpc: Not sure how helpful that is ;)
16:12:28 <chrisdone> hpc: that file tickled me more than i expected it to
16:12:45 <Iceland_jack> nanicoar: It sounds like you need to revisit some basic Haskell, going into Haskell thinking “I need to understand monads!” without familiarity without knowing the basics isn't going to be fruitful
16:12:53 <chrisdone> data Bool = TRUE | FALSE | FILE_NOT_FOUND
16:12:56 * chrisdone giggles
16:13:11 <hpc> chrisdone: there's a really cool thing in that file that i think is actually a bug in the spec
16:13:14 <Iceland_jack> nanicoar: http://learnyouahaskell.com/chapters this is a nice start :)
16:13:19 <arkeet> 'a' and "a" have different types.
16:13:23 <Iceland_jack> Indeed
16:13:24 <hpc> where if you import Prelude hiding (Bool), True and False are still in scope
16:13:26 <Iceland_jack> :type 'a'
16:13:27 <chrisdone> notElem x ys = elem (not x) ys
16:13:31 <chrisdone> hahaha
16:13:34 <Iceland_jack> :t 'a'
16:13:35 <lambdabot> Char
16:13:39 <Iceland_jack> :t "a"
16:13:39 <lambdabot> [Char]
16:13:40 <nanicoar> hpc: That defintion of a unique truth is maybe what I was getting at.
16:14:15 <thebnq> strong design principles of php..hah
16:14:28 <nanicoar> hpc: Does it graph the result and brilliantly apply OpenCV?
16:14:39 <mgsloan> the strong odor of php's design principles
16:15:00 <nanicoar> arkeet: Thank you.
16:15:29 <hpc> anyhoo, i didn't mean to hijack the conversation with that
16:15:40 <Iceland_jack> no prob
16:16:25 <chrisdone> i had a dream the other night that i was a kid and using join to unwrap christmas presents
16:16:29 <nanicoar> hpc: No prob here either. I ask questions, expecting simple answers when I should know better...
16:16:33 <Eduard_Munteanu> Haha.
16:16:41 <hpc> how does one report a bug in hackage?
16:16:49 <hpc> the generated haddock contains file:// links
16:16:50 <chrisdone> hpc: the github issue tracker
16:17:01 <Iceland_jack> nanicoar: How much have you studied of Haskell though?
16:17:22 <Iceland_jack> If you don't know the difference between a Char and a list of Char's then explaining monads is going to be tricky
16:17:53 <arkeet> :t join join join join
16:17:54 <lambdabot>     Occurs check: cannot construct the infinite type:
16:17:54 <lambdabot>       m0 = (->) (m0 (m0 ((m1 (m1 a0) -> m1 a0) -> t0)))
16:17:54 <lambdabot>     Expected type: (m0 (m0 ((m1 (m1 a0) -> m1 a0) -> t0))
16:17:57 <arkeet> heh
16:18:03 <hpc> oh god, github you suck
16:18:15 <hpc> i somehow hit a rate limit with three clicks
16:18:24 <Iceland_jack> arkeet: Not sure if that's a good dream or a nightmare
16:18:27 <chrisdone> hpc: assigning tags?
16:18:27 <hpc> because it takes so many to get to looking for duplicate issues
16:18:48 <nanicoar> Iceland_jack: The way I understood it is that a string is a list of chars. To me that makes sense if your lists always end up in the same order.
16:19:08 <Iceland_jack> Lists are ordered, yes
16:19:43 <nanicoar> And if I compare that to for example C, I think it's brilliant.
16:20:15 <chrisdone> it's theoretically-convenient
16:20:29 <chrisdone> not so efficient
16:20:30 <nanicoar> mmh. Simple.
16:20:42 <Iceland_jack>     […] a list or sequence is an abstract data type that implements a
16:20:42 <Iceland_jack>     finite *ordered* collection of values […]
16:20:42 <Iceland_jack>         http://en.wikipedia.org/wiki/List_(abstract_data_type)
16:20:42 <Iceland_jack>  
16:20:51 <Iceland_jack> emphasis mine
16:21:16 <chrisdone> ADTs can be minimally defined as something with a "current" and "rest" operation, i think
16:21:40 <ubikation> hey I have a simple problem I want to do 'putStrLn "total: " ++ (end1 - start1)" but it doesn't seem like that works.... how do I do something like that?
16:21:50 <Ghoul_> so I have a list of keys, and a map with some keys in it, and I want to extract from the Map all the keys that are in the list
16:22:15 <Eduard_Munteanu> ubikation: function application binds tighter than infix operator application
16:22:16 <Ghoul_> Data.Map is really really really huge ;_;
16:22:24 <nanicoar> But thank you for saving me the time of looking through peoples' guides to monads, language unspecified. I'll use it wisely. :)
16:22:36 <chrisdone> ubikation: i think you're missing a parenthesis
16:22:55 <Iceland_jack> nanicoar: I'd personally advice you to ignore all ‘guides to monads’ :) it has become ridiculous
16:23:02 <ubikation> putStrLn "total: " ++ (end1 - start1)
16:23:07 <ubikation> sorry that's what I have
16:23:15 <chrisdone> Ghoul_: ok?
16:23:18 <hpc> well, this file:// bug seems to be only affecting acme-php
16:23:28 <chrisdone> hpc: i've seen it in a bunch of places
16:23:29 <hpc> if that's deliberate, then well done!
16:23:32 <hpc> ah
16:23:36 <Ghoul_> chrisdone: yeah `ok` is about what I was expecting.
16:23:38 <hpc> it's not in async or directory
16:23:52 <hpc> and it appears to only affect cross-package links
16:24:03 <chrisdone> Ghoul_: you can get all the keys from the map with `keys'
16:24:12 <Ghoul_> doesn't look like there's any kind of [a] -> Map a k -> Map a k type thing
16:24:34 <xrdb> nanicoar:
16:24:44 <ubikation> I'm getting:     Couldn't match expected type `IO a0' with actual type `[a1]'
16:24:45 <Ghoul_> Oh, I made a wording error. I want to take the intersection of the Map where the keys are in the list
16:24:50 <glguy> Ghoul_: You can do a filterWithKey
16:24:57 <glguy> and keep the elements that have keys in your list
16:24:57 <arkeet> Ghoul_: I'd turn the list into a set, get the keys of the map as a set, and then take the intersection
16:24:58 <arkeet> maybe
16:24:59 <nanicoar> xrdb: I didn't get that.
16:25:09 <chrisdone> Ghoul_: there're a few ways i can think of writing it. do you want efficiency or convenience?
16:25:24 <Ghoul_> convenience
16:25:48 <ubikation> Eduard_Munteanu: what's wrong with the newer version I posted? also is your comment suggesting I shouldn't be having a problem at all?
16:26:33 <Eduard_Munteanu> ubikation: what newer version?
16:26:36 <Ghoul_> filterWithKey (\k _ -> k `elem` l) map' -- is OK, unless theres one better than that.
16:27:08 <Eduard_Munteanu> ubikation: I was just saying   foo a ++ b   parses as    (foo a) ++ b
16:27:22 <Eduard_Munteanu> Not   foo (a ++ b)
16:27:29 <ubikation> Eduard_Munteanu: putStrLn "total: " ++ (end1 - start1)
16:27:36 <arkeet> Ghoul_: ok, well
16:27:42 <arkeet> Ghoul_: make a map from the list
16:27:43 <Eduard_Munteanu> ubikation: ah well, then it's the issue I described above
16:27:45 <ubikation> gives me  Couldn't match expected type `IO a0' with actual type `[a1]'
16:27:48 <arkeet> and then intersect
16:28:09 <Eduard_Munteanu> ubikation: yes, because that parses as   (putStrLn "total: ") ++ (end1 - start1)
16:28:15 <Ghoul_> arkeet: I've figured out an answer, but the reason that what you suggested wouldn't work is because the list is keys only
16:28:16 <briennetheblue> > [(1,'a'), (2, 'b'), (3, 'c')] `intersection` (fromList (map (,()) [1,2]))
16:28:17 <lambdabot>   can't find file: L.hs
16:28:25 <arkeet> Ghoul_: you can write [a] -> Map a ()
16:28:32 <briennetheblue> > [(1,'a'), (2, 'b'), (3, 'c')] `intersection` (fromList (map (,()) [1,2]))
16:28:33 <lambdabot>   Not in scope: `fromList'
16:28:33 <lambdabot>  Perhaps you meant one of these:
16:28:33 <lambdabot>    `IM.fromList' ...
16:28:37 <Ghoul_> oh I see what you mean
16:28:41 <chrisdone> > let ks = 8:[1..5]; m = M.fromList (zip [1..10] ['a'..]) in intersect ks (M.keys m)
16:28:42 <lambdabot>   [8,1,2,3,4,5]
16:28:44 <ubikation> Eduard_Munteanu: so I have to build the string before I print it?
16:29:01 <Eduard_Munteanu> ubikation: you just need some parens :)
16:29:12 <chrisdone> oh, i missed your update, you actually want the map values. n/m
16:29:13 <briennetheblue> > [(1,'a'), (2, 'b'), (3, 'c')] `Data.Map.intersection` (Data.Map.fromList (map (,()) [1,2]))
16:29:14 <lambdabot>   Not in scope: `Data.Map.fromList'Illegal tuple section: use -XTupleSections...
16:29:15 <arkeet> :t M.fromSet (const ()) . S.fromList
16:29:16 <lambdabot> Ord k => [k] -> M.Map k ()
16:29:23 <briennetheblue> argh
16:29:30 <xrdb> nanicoar: what is important about String, is that it is the free monoid on characters, the particular way how you represent it is less important.
16:29:32 <briennetheblue> > [(1,'a'), (2, 'b'), (3, 'c')] `Data.Map.intersection` (Data.Map.fromList (map (repeat ()) [1,2]))
16:29:33 <lambdabot>   Not in scope: `Data.Map.fromList'Not in scope: `Data.Map.intersection'
16:30:04 <arkeet> briennetheblue: multiple things going wrong there, try in lambdabot pm ;)
16:30:06 <arkeet> or ghci
16:30:10 <briennetheblue> oh well
16:30:47 <arkeet> > M.fromList [(1,'a'),(2,'b'),(3,'c')] `M.intersection` (M.fromSet (const ()) . S.fromList) [2,3]
16:30:49 <lambdabot>   fromList [(2,'b'),(3,'c')]
16:30:53 <briennetheblue> haskell is too hard
16:30:58 <Iceland_jack> xrdb: Do you think “free monoids” means anything to nanicoar?
16:30:59 <Ghoul_> lol
16:31:20 <xrdb> Iceland_jack: i don't know, maybe?
16:31:38 <hpc> briennetheblue: easier than EVE Online ;)
16:32:26 <Ghoul_> EVE is like a nerdmafia
16:32:42 <Iceland_jack> It doesn't
16:33:45 <nanicoar> Iceland_jack: To me it means you all probably use Emacs.
16:33:59 <chrisdone> <xrdb> nanicoar: what is important about String, is that it is the free monoid on characters, the particular way how you represent it is less important.
16:34:05 <chrisdone> you just said that to a haskell newbie?
16:34:11 <chrisdone> the free monoid on characters?
16:34:18 <Iceland_jack> chrisdone: Yes, par for the course on #haskell
16:34:24 * chrisdone shakes head
16:34:32 <nanicoar> chrisdone: Found this http://stackoverflow.com/questions/13352205/what-are-free-monads
16:34:35 <ubikation> Eduard_Munteanu: thank you!
16:35:03 <xrdb> chrisdone, a lot of people learn haskell in university, usually alongside with introductory algebra courses
16:36:14 <nanicoar> It's chill. Just means I need my 5th cup of tea.
16:36:33 <arkeet> xrdb: I don't think I can agree with "a lot".
16:36:34 <briennetheblue> maybe there could be a #haskell-beginners that has a bot which bans upon any mention of free XYZs or co-ABCs
16:36:34 <xrdb> so i thought he might be familiar with the term
16:36:39 <chrisdone> nanicoar: i see you're taking the haskell spirit and learning lazily. i think you've generated a pile of thunks about haskell basics and you're trying to evaluate the intermediates. expect a stackoverflow =p
16:36:47 <Iceland_jack> chrisdone: hurr
16:37:13 <arkeet> and the introductory algebra courses I know don't talk about free monoids.
16:37:17 <Iceland_jack> I think assuming that name dropping ‘free monoids’ to every Haskell newbie is going to help them is strange
16:37:43 <chrisdone> i remember when i started and i was in here trying to understand monads
16:37:43 <Iceland_jack> but if people think it will help…
16:37:44 <monochrom> math algebra courses focus on groups, rings, fields
16:38:09 <nanicoar> chrisdone: I feel so loved! \o/
16:38:11 <xrdb> arkeet, i think Langs algebra has it within the first two chapters
16:38:11 <chrisdone> and people started telling me about functors
16:38:41 <arkeet> xrdb: which Lang are you talking about?
16:38:59 <monochrom> Serge Lang
16:39:02 <arkeet> the undergraduate one or the graduate one?
16:39:07 <monochrom> oh, oops
16:39:07 <arkeet> monochrom: he wrote a lot of books.
16:39:16 <dolio> Artie
16:39:34 <xrdb> the graduate one, in germany you can read that after two semesters
16:39:52 <arkeet> the graduate one is hardly an introductory algebra text
16:41:01 <arkeet> it does make a pretty good thing to bonk people with though.
16:41:10 <xrdb> arkeet: :)
16:41:30 <nanicoar> I know what axiomatic set theory is, if that's any consolation. :b
16:43:09 <Ghoul_> oh god I made a frankencomplexity
16:44:10 <nanicoar> Well that's your choice. But honestly, did classes make it simpler?
16:53:36 <xrdb> nanicoar: in practice for string to be a free monoid on characters simply means that once you have picked a representation String, you get a function fromString :: String -> a for all other conceivable representations a, in particular fromString :: String -> [Char]
16:55:14 <nanicoar> xrdb: Stack overflow imminent.
16:56:37 <ubikation> if I understand haskell monads correctly, if I generate a random data structure it will forever be stuck in IO, right?
16:56:40 <xrdb> :t pack
16:56:41 <lambdabot>     Not in scope: `pack'
16:56:41 <lambdabot>     Perhaps you meant one of these:
16:56:41 <lambdabot>       `BS.pack' (imported from Data.ByteString),
16:57:13 <jfischoff> ubikation: yeah pretty much
16:57:21 <xrdb> :t BS.pack
16:57:22 <lambdabot> [Word8] -> BSC.ByteString
16:57:41 <monochrom> such that fromString (String's mempty) = a's mempty, fromString (x `String's mappend` y) = fromString x `a's mappend` fromString y
16:58:04 * monochrom provides the last straw for stack overflow :)
16:58:25 <ubikation> why does Haskell taint things like that? shouldn't a list of numbers be a list of numbers? Why do I have to lift functions just because data structure isn't preordained?
16:58:47 <chrisdone> you don't have to
16:59:08 <chrisdone> it's the entropy that needs to be in IO
16:59:13 <monochrom> ubikation: I love the property (\x -> x+x) (g 5) = g 5 + g 5. do you?
16:59:15 <chrisdone> you can generate what you want from it completely purely
16:59:18 <Eduard_Munteanu> ubikation: but it's not a list of numbers you have, you have a way to get a list of numbers.
17:00:10 <Eduard_Munteanu> ubikation: if you really had a list of numbers, you wouldn't do IO at all.
17:00:42 <ubikation> Eduard_Munteanu: what does that mean? what do I have if not a list of numbers?
17:00:54 <monochrom> but you are saying, "isn't a number a number?" your subtext: g 5 generates a random number every time you use it, g 5 + g 5 may become 3+2, whereas (\x -> x + x) (g 5) can only be 3+3.
17:01:06 <briennetheblue> it's more like a scheme for generating a list of numbers
17:01:20 <jfischoff> IO ~ random (whatever that means :))
17:01:37 <Jonatha__> What does this mean?
17:01:37 <Jonatha__>     Illegal datatype context (use -XDatatypeContexts): (Ord a, Eq a) =>
17:02:05 <Eduard_Munteanu> Jonatha__: stuff like   data (Ord a, Eq a) => Foo a = ...   isn't valid anymore
17:02:06 <jfischoff> that is an old feature of Haskell that is no longer supported
17:02:24 <jfischoff> you are probably compiling some old package
17:02:27 <monochrom> no one loves my property
17:02:33 <nstdloop> Just a basic binary tree
17:02:40 <nstdloop> How do I fix it?
17:02:52 <jfischoff> compile with language haskell98
17:03:05 <nstdloop> What's the correct way to do it in new Haskell
17:03:06 <jfischoff> or add that extension to fix it
17:03:16 <Raisdead> if I have an instance of a class x defined in module z.y, how do I only import the instance from the module?
17:03:18 <jfischoff> oh you changed your name
17:03:24 <monochrom> "use -XDatatypeContexts"
17:03:24 <nstdloop> Ya, sorry.
17:03:40 <xrdb> nanicoar: for instance you have Data.Text and a function pack :: String -> Text
17:03:45 <jfischoff> sure you can turn on the extension
17:03:53 <xrdb> Text is much more efficient
17:03:54 <jfischoff> but its probably not what you want
17:04:16 <jfischoff> it doesn't save you from having to add the constraint on all the functions that use the type
17:04:16 <monochrom> yeah, perhaps better to just delete "(Ord a, Eq a) =>"
17:04:20 <iamtakingiteasy> hello, could i implement some generic method from parent typeclass in more specific child typeclass, using this specific typeclass functions?
17:04:27 <monochrom> programmers add too much and delete too little
17:04:37 <jfischoff> heh
17:04:41 <monochrom> also the problem with wiki contributors
17:04:52 <iamtakingiteasy> like, i have a typeclass (Tree t), which has treeLeaf :: t  and treeNode :: a -> t
17:04:59 <iamtakingiteasy> now i want to make a binary tree typeclass
17:05:25 <jfischoff> for a second I thought you changed your name again ...
17:05:28 <iamtakingiteasy> and implement treeNode with something like bsTree x = bsTreeNode x treeLeaf treeLeaf
17:05:37 <Eduard_Munteanu> iamtakingiteasy: if you mean whether you can refer to methods of the same typeclass while you're defining it, yes.
17:05:41 <nstdloop> I deleted (Ord a, Eq a) => and now everything breaks
17:05:46 <nstdloop> get tons of type errors
17:06:05 <jfischoff> they were there before I bet
17:06:05 <iamtakingiteasy> Eduard_Munteanu: no, i wish to refer to method of parent type class
17:06:08 <jfischoff> the errors that is
17:06:12 <nanicoar> xrdb: I'll keep that in mind. Thanks. For now, I obviously have to find the real basics of Haskell.
17:06:17 <monochrom> fix those errors themselves. this is a shock treatment.
17:06:27 <Eduard_Munteanu> iamtakingiteasy: yes, that too
17:06:40 <jfischoff> nstdloop: what monochrom said
17:07:12 <Eduard_Munteanu> iamtakingiteasy: assuming you have   class (Parent ...) => Child ...
17:07:49 <nstdloop> Ya I get a bunch of these:
17:07:54 <Iceland_jack> nanicoar: Take the time to learn the foundations of Haskell, you don't need to heed all that extra stuff at all
17:07:54 <Iceland_jack> @whereis lyah
17:07:54 <lambdabot> Maybe you meant: where+ where
17:07:57 <Iceland_jack> nanicoar: Take the time to learn the foundations of Haskell, you don't need to heed all that extra stuff at all
17:07:57 <Iceland_jack> @where lyah
17:07:57 <lambdabot> http://www.learnyouahaskell.com/
17:08:02 <nstdloop> Could not deduce (a ~ Tree a) from the context (Ord a)
17:08:06 <monochrom> to verify what jfischoff says about "they were there before anyway", add -XDatatypeContexts to see that you get the same errors again, therefore -XDatatypeContexts would not be an improvement
17:08:53 <iamtakingiteasy> Eduard_Munteanu: how?
17:08:54 <monochrom> if you get an error on the like of a ~ Tree a, you have seriously conceptual problems
17:09:00 <iamtakingiteasy> Eduard_Munteanu: i am trying to do: http://paste.eientei.org/show/28/
17:09:07 <jfischoff> nstdloop: change the type signature to be Ord a => a -> … to Ord a => Tree a ….
17:09:12 <khyperia> Dummy question incoming: what is ~ ?
17:09:30 <Iceland_jack> khyperia: Equality on type level
17:09:35 <khyperia> Ah, alright, thanks.
17:09:48 <monochrom> the kind of conceptual problems possessed by the like of perl and php programmers, who think that Char, [Char], Bool, and trees are interchangeable.
17:10:02 <nstdloop> Ok I get no errors when I compile it with -XDatatypesContext
17:10:04 <jfischoff> nstdloop: I meant to say from …  to … I
17:10:09 <iamtakingiteasy> Eduard_Munteanu: am i inheriting Tree in BSTree (and thus all methods, i am free to implement) or not?
17:10:17 <jfischoff> really?
17:10:25 <nstdloop> Yup.
17:10:30 <jfischoff> heh alright
17:10:31 <nstdloop> Wait let me try something.
17:11:33 <monochrom> I have coined a term for that. type cavalierism. it is the opposite of type safety.
17:11:45 <nstdloop> Ok nevermind
17:11:52 <monochrom> http://lambda-the-ultimate.org/node/4816#comment-77080
17:11:55 <nstdloop> Now I get them all anyway
17:12:43 <iamtakingiteasy> aww
17:13:05 <jfischoff> nstdloop: paste the code
17:13:10 <jfischoff> @hpaste
17:13:10 <lambdabot> Haskell pastebin: http://lpaste.net/
17:13:50 <nstdloop> alright, one sec.
17:13:54 <glguy> monochrom: I like the dichotomy below: functional programming and dysfunctional programming
17:14:11 <monochrom> heh
17:14:11 * Clint claps.
17:14:55 <iamtakingiteasy> okay, let me try again: how it is possible to implement a parent typeclass' method in the child typeclass (if it is possible at all)?
17:15:01 <iamtakingiteasy> i am trying it as following: http://paste.eientei.org/show/29/
17:15:08 <iamtakingiteasy> (fixed the line numbering)
17:15:29 <nstdloop> http://lpaste.net/94396
17:15:33 <arkeet> iamtakingiteasy: it isn't.
17:15:36 <monochrom> cannot. write it in the parent. can call child's methods, but you have to write it in the parent.
17:15:50 <iamtakingiteasy> i see
17:15:53 <arkeet> well, you can do this:
17:15:58 <iamtakingiteasy> thank you
17:16:08 <glguy> iamtakingiteasy: Typeclasses aren't like OO classes
17:16:46 <arkeet> I think this works http://paste.eientei.org/show/30/
17:17:11 <arkeet> that Tree class has other problems though...
17:17:29 <monochrom> what? Tree class? why do we need the generality?
17:17:36 <arkeet> I think you really want that Tree to be a data structure
17:17:37 <arkeet> not a clas
17:17:37 <arkeet> s
17:17:41 <monochrom> @quote monochrom evil
17:17:41 <lambdabot> monochrom says: shae ericsson is shae erisson's evil twin who prefers erlang to haskell :)
17:17:44 <monochrom> err
17:17:47 <monochrom> @quote monochrom premature
17:17:47 <lambdabot> monochrom says: premature opinion is the root of all evil.
17:17:54 <monochrom> err nevermind :)
17:17:55 <arkeet> so, ignore my paste.
17:17:57 <iamtakingiteasy> arkeet: i have at least two types of trees
17:17:58 <arkeet> classes in haskell are not OO classes.
17:17:59 <nstdloop> jfischoff: http://lpaste.net/94396
17:18:06 <monochrom> (something about premature generalizations :) )
17:18:08 <arkeet> they are more like OO interfaces
17:18:09 <iamtakingiteasy> AVLTrees and regular BinarySearchTrees
17:18:19 <arkeet> you probably want to make the 'a' a class parameter.
17:18:31 <iamtakingiteasy> they are differ in type definition
17:18:34 <monochrom> ah ok then I agree you can have a Tree class
17:18:36 <iamtakingiteasy> but have many in common
17:18:43 <jfischoff> nstdloop: hpaste is not listing the errors, but where is the second arg in deleteRoot?
17:20:22 <nstdloop> Oh god
17:20:25 <nstdloop> That was it
17:20:34 <nstdloop> *facepalms self*
17:20:34 <monochrom> since you do not need a 2nd argument, change the type sig
17:21:04 <monochrom> but then I want to know what is deleteRoot Nil
17:21:10 <nstdloop> I implemented a mutable binary tree in python earlier
17:21:25 <nstdloop> Took like 200 lines to implement in-place and persistent additions and deletions
17:21:36 <monochrom> mutable trees are somewhat harder
17:21:38 <nstdloop> The whole thing takes 47 lines in haskell
17:21:47 <nstdloop> Though ya, not mutable.
17:21:55 <nstdloop> Actually mutability broke half the code in python
17:21:58 <nstdloop> that was easily the hardest part
17:22:25 <monochrom> @quote monochrom tree
17:22:25 <lambdabot> monochrom says: In an imperative curriculum you're like chapter 2 for-loops and chapter 10 binary search trees.  In a functional curriculum you're like chapter 2 binary search trees and chapter 10
17:22:25 <lambdabot> XML processing using arrows.  The difference in productivity is incredible
17:22:59 <iamtakingiteasy> but you're right
17:22:59 <nstdloop> Haha yes
17:23:07 <iamtakingiteasy> i indeed had a premature genralization
17:23:18 <iamtakingiteasy> i do not need generic Tree class, only BSTree one
17:23:34 <iamtakingiteasy> since both AVL and regular BST (duh) are BSTs
17:25:30 <koala_man> dibblego!
17:27:58 <ubikation> If I want to do fast IO I should be using strict right? Or is strict just for the programmer to know that certain things have occurred in a certain order?
17:28:40 <monochrom> strict is just to know that certain things occur in a certain order
17:29:12 <ubikation> monocrhom: so it isn't faster?
17:29:19 <monochrom> that order may give you fast or slow. there is no fast rule "strict is fast"
17:30:06 <ubikation> but I would think that a strict command would force behavior that might otherwise be paused? in that sense it's faster right?
17:30:33 <monochrom> it is slower if you won't be resuming anyway
17:30:45 <ubikation> monochrom: hmm... thanks
17:31:28 <jfischoff> when the compiler nows that argument for a function is strict it can use a unboxed version if available. This apply to things like Int and Double.
17:31:43 <monochrom> you have a file. it is 10MB long. you just want its first 10 bytes. "strict-read 10 bytes" is fast. "strict-read all 10MB bytes" is slow.
17:32:21 <monochrom> you have a file. it's 10TB long. you only have 4GB RAM. "strict-read all 10TB" is unconditionally slow.
17:33:20 <monochrom> programmers fail to understand http://www.vex.net/~trebla/humour/tautologies.html #5
17:34:12 <monochrom> it's pretty sad that humanity fails to grok even the most trivial tautologies
17:36:05 <monochrom> anyway, mmap on linux proves that imperative programmers want lazy I/O too
17:40:39 <fruitFly> i am interested in improving my haskell, but right now it isn't a priority. I am interested in making an online graphical database with pictures that people can add entries to it, and a chat room and other typical web stuff etc. I'm curious as to the learning curve of doing this in in a haskell webframework versus doing this in for example node.js, might it be helpful to learn node to learn js or would i learn that with a haskell we
17:40:47 <fruitFly> particularly of the difference in learning curve?
17:42:00 <zomg> fruitFly: if you're familiar with javascript that stuff is super easy in node. If you're good with haskell, it shouldn't be too difficult with it either, though there may be a lack of ready to use libraries for certain tasks.
17:42:46 <jfischoff> I do work on web stuff using Haskell at work, its going great. Your mileage may vary.
17:44:00 <fruitFly> zomg: i'm still a haskell noob, got to about the input and output chapter in haskell.
17:44:30 <fruitFly> zomg: learned about folds, scans, cases etc. basic stuff, but didn't get to monoids
17:45:13 <fruitFly> jfischoff: what do you think might decrease ones mileage?
17:46:29 <jfischoff> fruitFly: Not knowing Haskell particularly well. Most engineers here don't, but they have other engineers they can go for help
17:46:46 <hiptobecubic> fruitFly, you really can't develop for the web and not know javascript though
17:47:59 <fruitFly> hiptobecubic: so are you insinuating node may be a better way to not have to learn too much at once, i.e. just js instead of js AND haskell?
17:48:17 <startling> fruitFly, what languages do you know?
17:48:26 <zomg> fruitFly: I would imagine you to have a bit of a hard time doing that stuff with Haskell based on what you said about your experience with the language
17:48:30 <hiptobecubic> fruitFly, not necessarily. I'm just saying that not learning node doesn't mean you don't have to care about javascript
17:48:44 <zomg> However that's mainly due to your inexperience and not because the language was in some fashion worse than node/js
17:48:55 <zRecursive> fruitFly: I always regard Haskell as a good studying platform even if i never use it program real applications.  I'm frankly absorbed into Haskell by using xmonad :-)
17:49:19 <hiptobecubic> I don't do much webbing so I'm not in a position to rate frameworks
17:52:34 <fruitFly> startling: none well, last was I started learning haskell got up to the IO chap of LYAH and started doing matasano challenges and using the maybe monad but still don't know how monads work. I think haskell is a more powerful tool overall, but I'm not sure how much higher the learning curve for a haskell web framework will be over node and what's better for me.
17:53:48 <fruitFly> I really just think haskell is a nice computing skill if ever needed but I'm not sure how much I'll ever utilize it, I have ideas but not sure if I will ever put them into practice myself. If I want to do some relatively simple web stuff and don't know js already wheather it might be better to start with node startling
17:56:28 <fruitFly> zomg: how much haskell do  have to learn in order to use a web framework, might it be beneficial to bypass this with node and learn js and then maybe later return to haskell. my comments above tell you a little more about my position. I have some ideas about a protocol for documenting contracts and intertwining it with crypto currency, but at heart I'm a theorist, I'm not sure if I my self will write the code for any of my ideas if 
17:56:41 <fruitFly> intruiged by haskell as a languag zomg
17:57:10 <zRecursive> maybe Rails is good at web programming for a newbie ?
17:57:17 <volko> ew noooo
17:57:23 <volko> do not write more rails code
17:57:24 <volko> please
17:57:27 <fruitFly> zomg: for now i just want to create an online database for plants and the conditions they grow in etc. with pictures that people can add to, maybe a forum and chatroom, and better market my work. i'm just wondering if node might be for me
17:57:53 <volko> http://www.haskell.org/haskellwiki/Web
17:58:05 <volko> er, http://www.haskell.org/haskellwiki/Web/Frameworks
17:58:57 <volko> note: I haven't used any of these
17:58:58 <zRecursive> fruitFly: such a thing even can be done using Prolog/Erlang easily
17:59:10 <volko> if anyone knows more about these I'd like to know what to check out
17:59:13 <volko> I just use django :(
17:59:31 <zRecursive> or Rails/django, etc.
17:59:39 <hiptobecubic> if your web development language can't make a database, you should probably give up
18:00:03 <fruitFly> hiptobecubic: i don't know any webframework yet
18:00:05 <zomg> fruitFly: well it's a bit hard to say. The fastest way to do something would be to use something like Yesod which gives you a scaffolded site ready to go which you can then modify, but you would need some understanding of things to be able to do that
18:00:20 <zRecursive> mnesia is a 'built in' database using erlang :-)
18:01:51 <fruitFly> zomg: somethings pertaining to haskells internals? or yesod specific things, I don't necessarily want to deploy fast; if I'm going to do extra learning I'd like it to advance my haskell knowledge. Maybe I'll give yesod a try, but any idea of the curve difference between it and node?
18:02:15 * zRecursive YAWS/Mnesia is a nice combination for web programming.
18:02:56 <zomg> fruitFly: mostly things like monads etc., because otherwise it might be hard to understand how some things function and it will definitely be hard to understand error messages
18:03:41 <zomg> Node is a lot more straightforward assuming you have previous JS experience since it really is nothing that special, it's just a JS runtime on the server with a bunch of neat libs
18:04:44 <fruitFly> zomg: so does that mean I would have to complete the traditional LYAH a haskell route (and maybe more), or could I just read up on moads and jump in. I have a TAD of js experience, but I have look at some node code and it doesn't look complicated, and seems so easy to throw up a server and deploy
18:07:47 <fruitFly> zomg: and aren't there more freelance jobs for node than haskell? what's really the advantage of using a haskell webframework? to more easily integrate with haskell applications? higher performance?
18:09:33 <monochrom> personal taste.
18:10:46 <zorzar> I'm going through Real World Haskell and did some exercises from the 3rd chapter, dan anybody give me some feedback? https://gist.github.com/zoranzaric/af4f843fadeaca35fa92
18:10:53 * hackagebot higher-leveldb 0.1.0.1 - A rich monadic API for working with leveldb databases.  http://hackage.haskell.org/package/higher-leveldb-0.1.0.1 (jeremyjh)
18:11:05 <monochrom> I am unconvinced that generally these "how should I make decisions for myself" questions are productive.
18:11:14 <Iceland_jack> zorzar: What are you having trouble with?
18:11:36 <Iceland_jack> oh sorry, didn't see your link zorzar
18:11:49 <zorzar> Iceland_jack: I don't like that I used an explicit data type for the parameters of my steepness function
18:12:06 <zorzar> Iceland_jack: when I tried to us type variables it didn't compile
18:12:31 <startling> fruitFly, why not both? If you want to do web stuff, you'll almost definitely need to know js someday anyway.
18:12:41 <Iceland_jack> Right, because you're comparing them for equality and so on
18:13:03 <Iceland_jack> so you probably need something like:
18:13:04 <Iceland_jack>     steepness :: Num a => Point a -> Point a -> Point a
18:13:13 <zorzar> wow!
18:13:25 <copumpkin> steepth
18:13:28 <copumpkin> warmth
18:13:29 <copumpkin> coldth
18:13:43 <Iceland_jack> Does that answer your question?
18:14:31 <joelteon> @pl g f a = f (f a)
18:14:31 <lambdabot> g = join (.)
18:14:53 <Iceland_jack> Sorry that should've been:
18:14:53 <Iceland_jack>     steepness :: Integral a => Point a -> Point a -> Double
18:15:18 <Iceland_jack> You can also add a 'Fractional b' for the return value:
18:15:19 <Iceland_jack>     steepness :: (Integral a, Fractional b) => Point a -> Point a -> b
18:15:30 <Iceland_jack> which allows you to return Double, Float ...
18:15:30 <zorzar> Iceland_jack: great!
18:15:37 <Iceland_jack> :)
18:15:44 <zorzar> how would i've found Integral and Fractional?
18:15:55 <ion> :i Double
18:15:58 <ion> in ghci
18:16:06 <Iceland_jack> well you use fromIntegral
18:16:14 <Iceland_jack> so that implies Integral
18:16:16 <Cale> fruitFly: The number one reason to choose a Haskell web framework over something like node.js is bugs.
18:16:32 <Iceland_jack> zorzar: but the best way is to compile it without a type signature and let GHC work it out
18:17:05 <zorzar> Iceland_jack: oh ok, i thought giving type signatures was a good habit
18:17:10 <Iceland_jack> zorzar: Absolutely!
18:17:24 <fruitFly> Cale: is node buggy?
18:17:24 <Iceland_jack> But when figuring the type signature out, it's nice to let the compiler do the heavy lifting
18:17:47 <Cale> fruitFly: Node.js forces you to write your code in a frankly somewhat ridiculous way -- in a way that a compiler could easily translate much saner-to-write code into, and Javascript doesn't give you any of the leverage of a static type system, so you can write many more bugs, and have a much harder time finding them than with Haskell.
18:17:55 <zorzar> Iceland_jack: ok
18:17:58 <zorzar> Iceland_jack: thanks
18:18:00 <Cale> *Especially* with the concurrent nature of a webserver.
18:18:09 <Iceland_jack> zorzar: On a side-node, I wouldn't create explicit variables for x a, x b, y a, y b
18:18:10 <zorzar> Iceland_jack: the tests feel awkward, is there a nicer way?
18:18:46 <Cale> In fact, I have a hard time understanding why anyone takes node.js seriously at all.
18:19:57 <simpson> Cale: It's just like that other, serious framework, but in a language that is *hip* and *happening*.
18:20:10 <simpson> I don't get it either.
18:20:15 <Iceland_jack> zorzar: Hm, nothing immediately jumps out at me
18:20:20 <zorzar> Iceland_jack: ok
18:20:39 <Iceland_jack> If you prefer zorzar, you can pattern match on the Point
18:20:48 <zorzar> Iceland_jack: how would you have done the steepness function?
18:21:47 <Iceland_jack>     steepness (Point x₁ y₁) (Point x₂ y₂)
18:21:47 <Iceland_jack>         | y₁ == y₂  = 0
18:21:47 <Iceland_jack> 	| otherwise = …
18:21:50 <Iceland_jack> probably something like that, I think your version is rather clear
18:22:10 <zorzar> Iceland_jack: yes, right.. just got it
18:22:13 <zorzar> Iceland_jack: thanks a lot!
18:22:20 <Iceland_jack> no problem :)
18:22:27 <Iceland_jack> (happy Haskelling)
18:22:53 <fruitFly> Cale: well people take php seriously lol. node seems more elegant and I agree the imperative call back format is not ideal and there isn't the static type system so it's more difficult to debug and refactor code, but it seems to have a an easy learning curve, a high demand and an oppurtunity for me to learn js which I may come in handy later if I want to learn a haskell webframework; I'm realizing I'm very interested in the web, nod
18:23:03 <fruitFly> concur haskell is more elgant and powerful, however.
18:23:07 <fruitFly> cal ^
18:23:10 <Iceland_jack> zorzar: It's also worth noting that Direction is really the same as Ordering
18:23:10 <fruitFly> Cale: ^
18:23:29 <Cale> fruitFly: your first message was cut off at "I'm very interested in the web, no"
18:23:30 <zorzar> Iceland_jack: I don't understand that
18:23:35 <Iceland_jack> (where Ordering ≔ LT | EQ | GT)
18:23:55 <Iceland_jack> LeftTurn = LT, Straight = EQ, RightTurne = GT
18:24:06 <fruitFly> Cale: "node is kinda screaming at me. I do concur haskell is more elegant and powerful, however."
18:24:09 <zorzar> Iceland_jack: ok
18:24:25 <Iceland_jack> so you could use ‘comparing’ to get an Ordering and then translate from that
18:24:29 <zRecursive> fruitFly: www.swi-prolog.org is built using Prolog itself. And plweb source code cab be downloaded. I found it is fun doing web thing using Prolog
18:24:30 <fruitFly> Cale: I'm interested in the difference in learning curve between node and yesod from a fresh start.
18:24:37 <Iceland_jack> instead of having 3 cases for (==), (<) and (>)
18:24:45 <Iceland_jack> sorry, compare
18:24:48 <Iceland_jack> :t compare
18:24:49 <lambdabot> Ord a => a -> a -> Ordering
18:24:53 <Cale> fruitFly: Ideally, we'll eventually get Haskell compiling to Javascript working well enough that even the front end to web applications can be written in Haskell. That would have a real advantage in that the *same* algebraic datatypes could be used by the frontend and backend of the web application without the programmer needing to be aware of a bunch of awkward conversion to JSON or what-have-you.
18:25:06 <fruitFly> zRecursive: you're recommending all kind of stuff, why?
18:25:32 <zRecursive> fruitFly: just my experimence
18:25:43 <zRecursive> now i am using Prolog
18:25:58 <zorzar> Iceland_jack: i think having this Direction type makes it clearer
18:26:08 <zRecursive> because i cannot master Yesod thoroughly :(
18:26:08 <Iceland_jack> Yes I don't suggest changing the type
18:26:35 <simpson> fruitFly: If you haven't yet made the mistake of going down the road of Node, consider Twisted, in Python; it's a better language and a better library. Twisted was the inspiration for Node.
18:26:41 <fruitFly> Cale: I like that direction, but still, what do you think is the difference in learning curve now between node and the current state of haskell web dev?
18:27:04 <simpson> fruitFly: I don't care if you Haskell or not, but I advise you to not make the mistake of thinking that Node is good just because it's popular. :3
18:27:21 <Iceland_jack> zorzar: So directionForPoints can be:
18:27:21 <Iceland_jack>     directionForPoints a b c = getDirection (steepness a b `compare` steepness b c)
18:27:38 <fruitFly> simpson: i'm not considering what's good, I'm considering what's functional with a low learning curve, and I'm particularly interested in js
18:27:44 <fruitFly> and the web simpson
18:28:00 <Iceland_jack> where:
18:28:00 <Iceland_jack>     getDirection LT = LeftTurn ; getDirection EQ = Straight ; getDirection GT = RightTurn
18:28:12 <zorzar> Iceland_jack: AH!
18:28:14 <Iceland_jack> I haven't tested that and it's just an observation
18:28:15 <fruitFly> simpson: i feel python has a higher learning curve than node so would just rather learn haskell+yesod instead
18:28:18 <simpson> fruitFly: Do you mean "functional" as in "does what it says on the tin," or as in "languages that have functional characteristics"? You might be sorely disappointed in either case, but I'm just curious.
18:28:21 <zorzar> Iceland_jack: that's great, thanks
18:28:34 <Iceland_jack> :)
18:28:41 <zRecursive> fruitFly: you can ignore my info. i feel node.js is better for you
18:28:45 <fruitFly> simpson: i mean i can build something that works
18:28:47 <zorzar> Iceland_jack: and one last question: is there an easy way to run all tests in a haskell file form the command line?
18:29:04 * Clint squints.
18:29:06 <simpson> fruitFly: Ah. Then I'm not going to disabuse you of your preconceived notions. Best of luck.
18:29:07 <fruitFly> zRecursive: I appreciate your input
18:29:07 <Cale> fruitFly: Well, if you know Haskell well at all, it's not terribly hard to pick up, say, Snap or Happstack. Learning Yesod is kind of its own ordeal, but it seems to have some rather nice features of its own.
18:29:25 <startling> simpson: I heard it's really good for fibonacci servers.
18:29:35 <startling> :3
18:29:40 <Cale> fruitFly: I don't think it's really that big of a deal? Haskell is a nice language to use for web servers for the same reasons it's nice to use for anything though.
18:29:40 <Iceland_jack> Hm I'm not very familiar with your particular testing library zorzar
18:29:49 <Iceland_jack> (have you looked at QuickCheck incidentally?)
18:30:02 <simpson> startling: Today I'm not pro-Twisted, just anti-Node.
18:30:28 <fruitFly> Cale: I'm still new, got up to the IO chapter in LYAH and still need to refresh, don't understand monads yet.
18:30:30 <zorzar> Iceland_jack: just tried it a few times
18:30:33 <Iceland_jack> zorzar: http://stackoverflow.com/questions/3120796/haskell-testing-workflow this looks relevant to your question
18:30:40 <zorzar> Iceland_jack: thanks
18:31:45 <Cale> fruitFly: Okay, then maybe hold off a little bit. You could just dive in, but depending on what sort of person you are, it might put you a little off the deep end in places.
18:32:00 <fruitFly> Cale: I am a pretty meticulous programmer and am not build any huge applications at the moment, I don't think I would have THAT much of a nightmare debugging in node.
18:32:27 <simpson> fruitFly: You say this, but you admittedly don't know the language that you're talking about using.
18:32:27 <Cale> fruitFly: Well, perhaps you're just not used to how little time you'd spend debugging Haskell code yet though :)
18:33:10 <fruitFly> Cale: a little bit :) . I had fun starting the matasano challenges :).
18:33:28 <Cale> fruitFly: Personally, I find it *extremely* frustrating to spend hours tracking down some subtle issue with bad data only to discover that a decent type system would have caught it at compile time and told me what to fix before it had ever been a problem.
18:33:50 * zRecursive dubugging haskell code is a nightware ?!
18:34:30 <fruitFly> Cale: kinda what I'm getting at here is the learning curve (and maybe the demand to freelance a little and my general interest in the web for marketing). so you think then that it might be quicker for me to start deploying in node over haskell?
18:34:45 <thebnq> fruitFly: your best answer is to just start learning until you can do something basic in both frameworks :)
18:34:58 <Cale> fruitFly: Well, do whatever you like!
18:34:58 <thebnq> as to learning curve
18:35:42 <Cale> fruitFly: But I think that ultimately for most purposes you'll find that Haskell code is nicer to maintain.
18:36:14 <volko> fruitFly: at this rate it might be quicker for you to just try writing both :p
18:38:02 <fruitFly> Cale: I agree, I think haskell is more powerul and elegant and a time saver for the long time coder, but I'm interested in start up time, i.e. learning curve pertaining to faster deployment and a general interest in the web (and possibly some freelancing), what do you think pertaining to the difference in learning curve? Maybe I will just try because I'm not sure if people in here have the experience in both to truly comment on that
18:38:46 <startling> You can start writing web code in Haskell right now.
18:38:55 <johnw> fruitFly: if you use Haskell for Web at all, you will quickly build up a set of templates and recipes that can allow you to create new things thereafter *much* more quickly than the very first thing you will write
18:39:09 <johnw> but what I said is true in any language
18:39:19 <simpson> fruitFly: Hi! I've done JS, Haskell, and Python. Don't do JS. It's a hell of a drug.
18:39:54 <fruitFly> simpson: :P
18:40:01 <monochrom> I think we're about to beat a dead horse.
18:40:21 <startling> Well, it's better than losing to one.
18:41:41 <carter> yup
18:42:43 <fruitFly> johnw: I'm just trying to get an idea, HOW MANY HOURS to deploy a custom built database with pics by me that users can add entries to and just a polished site overall to market my work, vs HOW MANY HOURS to learn a haskell webframework and deploy the same thing? I read up to the IO chap in LYAH and need to refresh; looked at js code and doesn't looks straight forward.
18:42:51 <fruitFly> johnw: Cale monochrom ^
18:43:06 <johnw> how many hours for whom?
18:43:07 <monochrom> I have no answer.
18:43:37 <fruitFly> johnw: for the fastest learner
18:43:42 <startling> 0
18:43:58 <fruitFly> startling: practically speaking bro
18:44:09 <johnw> i'm going to say at least 200-300 hours, if you have just read up to the IO chap in LYAH, if you are a fast learning
18:44:13 <startling> fruitFly, you said "the fastest learner".
18:44:22 <monochrom> why don't we all just answer "I have no answer" and end this debacle.
18:44:26 <startling> Yes.
18:44:39 <Cale> fruitFly: That's impossible to estimate
18:44:51 <monochrom> this discussion is degenerating into noise now.
18:45:07 <fruitFly> Cale: I don't need exact hour counts, just an estimation of curve between the two languages. lol
18:45:13 <Cale> fruitFly: If you can estimate things like that for other people, then I have a multibillion dollar market for you.
18:45:21 <fruitFly> NO, this "DEBACLE" must go on! jk lol, it's soon over :P
18:46:13 <Cale> I wouldn't be surprised, depending on the individual, to see answers ranging from one side being much much longer than the other in either direction, to having them be about equal.
18:47:15 <fruitFly> Cale: wow, interesting perspective. I read one chapter in a node book and deployed a chat server inw eb in like an hour. I just imagine something like that would take me MUCH longer to learn in haskell.
18:47:16 <Cale> It's sort of the wrong question to ask, when you're going to spend at least 90% of the time on a project like that *after* that point updating and maintaining it and fixing issues.
18:47:27 <Cale> I don't think it would.
18:47:46 <Cale> In fact, there's a tutorial on creating a chat server in Haskell which shouldn't take any longer.
18:48:03 <Cale> But I don't know if that one is up to date...
18:49:00 <fruitFly> Cale: ok cool. so which web framework strikes a ncie balance between having an easier learning curve and learning practical haskell? yesod, happ stack, snap?
18:49:14 <Cale> I'd say either of the latter two.
18:49:26 <Cale> Yesod is kind of like learning a bunch of miniature separate languages.
18:49:59 <Cale> It might get you up and running pretty quickly too, but a lot of the code you'd be writing isn't strictly speaking Haskell.
18:50:49 <Cale> Personally I think I prefer Happstack conceptually.
18:51:11 <Cale> But at skedge.me, we use Snap, and it's fine too.
18:51:32 * copumpkin skedges Cale
18:51:45 <Cale> I say don't worry about minimum time to deployment, and just learn them all :)
18:52:18 <fruitFly> Cale: well for now I'm trying to squeeze my learning in between my other works.
18:52:20 <Cale> But then, learning stuff is kind of what I live for, much more than applying accumulated knowledge :P
18:55:20 <fruitFly> Cale: i design and build food forests and homes, I'm interested in sustainability and community building. I LOVE theory and learning, but I keep pretty busy with my work and want to build tools for interested partners and market my own work on the web.
18:56:22 <fruitFly> Cale: i love haskell fundamentally as a tool hence why I'm drawn to it, but I'm looking for practical solutions for myself considering I work and don't have the most time anymore to learn programming.
19:02:33 <johnw> fruitFly: I see it as where your costs will be spent.  Haskell has an up-front cost, but it has downstream payoffs.  If you don't want to pay the cost up front, my experience is that you'll just end up paying it later
19:03:22 <fruitFly> johnw: gitchya!
19:03:28 <fruitFly> gotchya*!
19:03:53 <newhaskelluser> hi everyone I'm an undergrad CS Major (Junior) at Rensselaer Polytechnic Institute, and I'd like to add a functional proglang to my belt.  Many of my classmates praise haskell a lot so I'd like to know a little more about the language.
19:04:13 <johnw> @where lyah
19:04:13 <lambdabot> http://www.learnyouahaskell.com/
19:04:17 <johnw> I'd recommend starting there
19:04:28 <Iceland_jack> Yes, LYAH is a great place to start
19:05:24 <leroux> newhaskelluser: I have a list of haskell resources I've used or would have wanted to use... https://gist.github.com/leroux/6395804
19:05:28 <newhaskelluser> One of my friends recommend LYAH to me!  It's pretty good, but after I finish it, where's a good next step?  My interests are in programming robots/hardware-side programming; I'm using C++/Matlab right now.  Does haskell support hardware-side systems?
19:05:40 <newhaskelluser> Ah thanks leroux; I'll look at that listnow
19:06:28 <Iceland_jack> So Haskell has ways of interacting with C, and I think you'll find it's often used for writing EDSL's (embedded domain specific languages) for exactly that sort of purpose
19:06:34 <arkeet> newhaskelluser: and this is an excellent place to ask questions and such too!
19:07:04 <carter> newhaskelluser: theres a fun haskell nyc talk now online about hardware
19:07:04 <monochrom> organize a haskell study group with your classmates, since they already praise haskell
19:07:07 <carter> and robitics
19:07:16 <newhaskelluser> Iceland_jack: Can haskell call unix system calls?
19:07:32 <Iceland_jack> Well sure
19:07:33 <johnw> newhaskelluser: yes, it can call most C functions
19:07:41 <Iceland_jack> but normally you use existing wrappers
19:07:43 <newhaskelluser> carter: I emailed one of the leaders of the NYC Haskell group about the talk and I'm still awaiting a response about when the talk is posted.
19:07:48 <Iceland_jack> newhaskelluser: http://www.cse.chalmers.se/~joels/writing/bb.pdf You may be interested in this
19:07:50 <monochrom> in fact, isn't it a little strange? you heard from your classmates, so why do you need ask anyone else than your classmates? I don't understand.
19:07:55 <carter> newhaskelluser: the talk should be onlien
19:08:08 <carter> https://vimeo.com/77164337 great talk
19:08:13 <carter> i closed my laptop during it
19:08:29 <Iceland_jack> Oh actually, ignore that PDF newhaskelluser
19:08:30 <newhaskelluser> monochrom: My classmates are more interested in the theoretical aspects of Haskell i.e. type theory; they don't usually use Haskell for real-world applications
19:08:44 <newhaskelluser> carter: thanks a lot!  been waiting for a month now to see it :D
19:09:10 * carter its like christmas every month with new haskell content :) 
19:09:12 <monochrom> that doesn't stop them from telling you information useful to you
19:09:25 <carter> newhaskelluser: i use it for both :)
19:09:34 <carter> the theory has good ideas
19:09:34 <Iceland_jack> newhaskelluser: There is nothing stopping you from doing both ;)
19:09:36 <carter> and patterns
19:09:37 <newhaskelluser> monochrom: guess that's true... definitely will look to find more haskell users at my school :D
19:09:59 <carter> being challenged and forced to grow intellectually while learning new things… always a good thing
19:10:01 <monochrom> I really don't understand people anymore.
19:10:17 <monochrom> they spend forever browsing the web and not one minute browsing their own disks
19:10:25 <newhaskelluser> i was intersted in haskell especially for robotics programming since as the robots become larger/powerful, the correctness of software is so important so you don't accidentally kill someone with the robot!
19:10:46 <monochrom> they spend forever talking on IRC and not one minute talking to people they see face to face everyone
19:10:51 <monochrom> s/everyone/everyday/
19:11:11 <carter> i like IRL interaction
19:11:15 <carter> i just wind up IRCing a lot
19:11:23 <newhaskelluser> well thank you very much to everyone for their help!  look forward to coming back here soon! :D
19:11:43 <Iceland_jack> Hope we could answer your questions newhaskelluser
19:11:54 <monochrom> and even on the web, when you see a blog post and have a question, it never occurs to them to ask the blog author. they must go to a whole different place and ask random strangers. they must. I can't understand this.
19:12:26 <johnw> monochrom: I'm starting a reddit thread to ask you why you've made that comment
19:12:33 <Iceland_jack> monochrom: Well you're more likely to get a quick answer from asking e.g. on #haskell than emailing the author
19:12:51 <monochrom> a quick and wrong answer
19:13:01 <Iceland_jack> Not quite so bleak :)
19:13:04 <monochrom> guess what, if it doesn't have to be right, I can answer all questions
19:13:27 <monochrom> in fact, I already did. http://www.vex.net/~trebla/humour/tautologies.html
19:13:43 <Iceland_jack> also, especially for opinion pieces, it's nice to get opinion from outside of the author's bubble about it
19:14:29 <monochrom> no no, the questions I saw aren't even about 2nd opinions
19:15:27 <monochrom> i.e., your reason can justify "he says X, but what you do think". but your reason cannot justify "he says X, why does he say that?"
19:15:43 <monochrom> why does he say X? why don't you ask him? I am not his brain.
19:16:24 <Iceland_jack> So ironically you're asking us (rhetorically) why don't ‘you’ ask him, instead of asking the person who asked the question :)
19:16:54 <monochrom> well, he is here, he can answer.
19:17:34 <johnw> monochrom: another one for your list: half of all people have below average intelligence
19:17:57 <thebnq> and half rounds to 1 right
19:18:29 <monochrom> um, you need to make it s/average/median/, unless you know much about the distribution :)
19:19:05 <monochrom> anyway, obtopic: I am working through parametricity
19:19:22 <monochrom> I am even reading Reynolds's paper in anger!
19:19:33 <Iceland_jack> Don't read papers while angry!
19:19:52 <monochrom> yes, it's quite archaic and so painful, but I'm coping.
19:20:09 <monochrom> (and no, Reynolds no longer lives, I can't just ask him :) )
19:20:58 <monochrom> I miss Reynolds! I really want to tell him I can answer a question he asked during a conference.
19:28:23 <ubikation> how would I generate a data structure that uses multiple random numbers but is IO (Int, Int, Int) instead of (IO Int, IO Int, IO Int)
19:28:41 <arkeet> Iceland_jack: neat paper =)
19:29:08 <arkeet> ubikation: take three things of type IO Int and smash them together with liftA3 (,,) or something
19:29:13 <enthropy> @type \(a,b,c) -> do a <- a; b <- b; c <- c; return (a,b,c)
19:29:13 <lambdabot> Monad m => (m t, m t1, m t2) -> m (t, t1, t2)
19:29:14 <Iceland_jack> arkeet: thanks :)
19:29:43 <arkeet> :t \(a,b,c) -> each id (a,b,c)
19:29:44 <lambdabot> Applicative f => (f b3, f b3, f b3) -> f (b3, b3, b3)
19:30:11 <arkeet> (each id = sequenceAOf each)
19:32:41 <ubikation> arkeet: I'm sorry but could you give me an example of liftA3 (,,)?
19:33:47 <Iceland_jack> ubikation: If you aren't familiar with Applicative Functors you should think in terms of do-notation first
19:34:09 <ubikation> where would be the best place to learn about applicative functors?
19:34:19 <Iceland_jack> LYAH
19:34:27 <Iceland_jack> but it's not necessary for what you want to do
19:35:13 <monochrom> use enthropy's line, although I don't like reusing names
19:35:26 <Iceland_jack> ubikation: So something like this is your current situation, no?
19:35:26 <Iceland_jack> :t (randomIO, randomIO, randomIO) :: (IO Int, IO Int, IO Int)
19:35:27 <lambdabot> (IO Int, IO Int, IO Int)
19:36:03 <monochrom> do x <- randomIO; y <- randomIO; z <- randomIO; ... now you can use (x,y,z) which has the desired type
19:36:45 <Iceland_jack> Yes, what monochrom said:
19:36:45 <Iceland_jack> > do first ← randomIO; second ← randomIO; third ← randomIO; return (first, second, third) :: IO (Int, Int, Int)
19:36:46 <lambdabot>   <IO (Int,Int,Int)>
19:36:57 <adnap> > liftA3 (\x y z -> x + y + z) (Just 0) (Just 1) (Just 2)
19:36:58 <lambdabot>   Just 3
19:37:21 <Iceland_jack> You're effectively ‘moving the IO’ out of the tripple
19:38:00 <Iceland_jack> And there are of course terser ways of achieving that
19:40:02 <adnap> > liftA3 (,,) (Just 0) (Just 1) (Just 2)
19:40:03 <lambdabot>   Just (0,1,2)
19:40:40 <unequation> (if A is a theorem implies that B is a theorem) and (A is a theorem) then B is a theorem
19:40:46 <unequation> the light shines upon me
19:41:00 <unequation> the symbols and the words synergize
19:41:56 <monochrom> you will find more shining light from http://www.vex.net/~trebla/humour/tautologies.html
19:42:48 <unequation> monochrom: are you suggesting that modus ponens is a tautology?!
19:43:04 <monochrom> yes
19:43:22 <unequation> monochrom: nay, it is a tool by which we might from a haystack find the truth
19:43:41 <monochrom> that does not contradict that it is a tautology
19:44:03 <unequation> monochrom: a tautology by its definition is that which is uselessly obvious in a circular manner
19:44:08 <arkeet> no
19:44:35 <unequation> arkeet: tautologies can be usefully obvious?
19:44:41 <monochrom> I use tautologies all the time. they are useful to me. don't speak for me.
19:44:48 <arkeet> they can also be non-obvious.
19:44:59 <monochrom> I also know that they are non-obvious to most of humanity.
19:45:06 <arkeet> any theorem of propositional logic, at least, is a tautology.
19:45:48 <monochrom> "the solution depends on the problem" is obvious to how many programmers? lurk in #haskell to find out how many askers fail to grok it.
19:45:51 <unequation> arkeet, monochrom ahhhhh
19:46:12 <arkeet> monochrom: :)
19:46:39 <unequation> the holy bible: http://www.cs.utoronto.ca/~hehner/FMSD/
19:47:34 <luke1> anyone know if hakyll is compatible with jekyll themes?
19:48:29 <unequation> luke1: are you in illinois, or israel?
19:48:49 <luke1> why?
19:48:58 <unequation> luke1: dead cat walking
19:49:09 <luke1> ?
19:49:12 <unequation> luke1: sorry, i mean, curiosity killed the cat*
19:49:32 <luke1> i still dont follow
19:50:16 <unequation> luke1: i am curious. like the curious cat, i too shall soon be dead. people who are on death row are often said to be "dead men walking". i am basically a "dead cat walking". so, illionois, or israel?
19:50:57 <luke1> why do you ask?
19:51:45 <unequation> luke1: i want to know whether the il in your ip-signature stands for illinois or israel. if it is israel, then that means comcast operates in israel too, which would be an interesting fact, to me at least.
19:53:34 <monochrom> Hehner is my thesis supervisor.
19:53:59 <arkeet> unequation: comcast does not operate in israel.
19:54:00 <Connorcpu> unequation: 99% sure that's Illinois :P
19:54:02 <arkeet> :p
19:54:09 <unequation> monochrom: no way.
19:54:15 <unequation> monochrom: i might know you then.
19:54:35 <Connorcpu> also, Comcast only operates in the US :P
19:54:38 <unequation> monochrom: are you a PhD candidate?
19:54:51 <unequation> Connorcpu: oh cool
19:54:52 <arkeet> /whois monochrom to see his name
19:55:06 <unequation> OMG NO WAYYYYYYYYYYYYYYYYYYYYyyyyyyyyyyyyyyyy
19:55:11 <monochrom> I am done. my thesis is at http://www.cs.utoronto.ca/~trebla/albert-thesis-ut.pdf . it adds lazy evaluation to Hehner's formal method.
19:55:30 <unequation> monochrom: you are of "If you choose to typeset your assignments in LaTeX, here is a helpful set of macros, courtesy of Albert Lai." fame!
19:55:32 <monochrom> it's Dr monochrom for you now
19:55:41 <monochrom> yes, that's me too
19:55:43 <unequation> Dr. Monochrom, Dr. Monochrom
19:55:53 <unequation> pleased to meet you
19:56:51 <unequation> the world is too small....
20:03:25 <edwardk> dr monochrom it is
20:03:43 <Kaidelong> drm ono chrom
20:03:59 <edwardk> i think they don't want DRM on chrome.
20:04:00 <Kaidelong> "dr mono" sounds like a name for an IDE
20:04:22 <startling> Is there an f such that "a `f` b = a >>= \a' -> b a' >> return a'"?
20:04:26 <startling> Kaidelong: heh.
20:04:38 <monochrom> and IDE that syntax-colours your code in black, white, silver, and gray :)
20:05:26 <startling> it highlights your 'l's in grey and your '1's in gray.
20:05:27 <monochrom> if you accept Applicative instead, I think it's <*
20:05:33 <startling> monochrom, not quite.
20:05:44 <monochrom> oh yikes, right
20:06:19 <unequation> so, dr. monochrom, what are you going to do next???
20:06:30 <Kaidelong> you could get the type and look it up on hoogle
20:07:41 <startling> @hoogle Monad m => m a -> (a -> m b) -> m a
20:07:42 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
20:07:42 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
20:07:42 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
20:07:49 <startling> useful !
20:07:59 <startling> I'm lucky it didn't give me "const".
20:08:11 <monochrom> haha
20:09:16 <Kaidelong> @hoogle m a -> (a -> m b) -> m a
20:09:16 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
20:09:16 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
20:09:16 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
20:09:25 <Kaidelong> still just >>=
20:09:36 <Kaidelong> nothing like that in applicative then
20:10:07 <startling> You can't do it with Applicative.
20:10:49 <unequation> good night everyone!
20:13:01 <monochrom> a `f` b = bracket a b return. but I am evil.
20:13:28 <monochrom> oh wait, bracket is good for IO only. nevermind
20:13:38 <monochrom> I am evil and stupid :)
20:13:44 <Kaidelong> @ty bracket
20:13:45 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
20:14:19 <monochrom> well, throw in an unsafeCoerce to generalize it to all monads. what can possibly go wrong :)
20:14:21 <Kaidelong> the idea is that if the first action fails the second still gets run?
20:15:06 <monochrom> no, the first action opens a file, then the third action uses that file handle, then the second action closes the file
20:15:25 <Kaidelong> oh okay
20:15:34 <monochrom> if the third action bombs, the second action is still run to close the file, so everyone is happy
20:16:17 <Kaidelong> that's a horrible abuse of bracket then
20:16:39 <joelteon> the quasiquoter backslash rules are pretty weird
20:17:07 <monochrom> it is not weird I think? the rule is simple: preserved.
20:18:00 <joelteon> but \b and \\b are the same thing
20:18:26 <joelteon> oh, no, wait
20:18:28 <arkeet> blame your particular quasiquoter then
20:19:27 <simpson> Is there a better monad than RWS for keeping track of state *and* writing a log? I was thinking maybe of Chronicle, but I'm not sure if that's the right thing to use.
20:20:03 <joelteon> yeah it was all my fault
20:25:13 <startling> simpson, StateT s (Writer w)?
20:25:23 <startling> simpson: (better how?)
20:25:33 <simpson> startling: Well, I was going to put IO on the bottom.
20:26:02 <simpson> So RWST () w s IO, or StateT s (WriterT w IO) ?
20:26:13 <simpson> @unmtl StateT s (WriterT w IO)
20:26:13 <lambdabot> Plugin `unmtl' failed with: `StateT s (WriterT w IO)' is not applied to enough arguments, giving `/\A. s -> (WriterT w IO) (A, s)'
20:26:30 <startling> simpson, there's not much difference. What's wrong with RWST?
20:26:46 <simpson> startling: Nothing except that my Reader state would be ().
20:26:58 <startling> Sure.
20:27:16 <startling> @unmtl State s (WriterT w IO) a
20:27:16 <lambdabot> Plugin `unmtl' failed with: `s -> ((WriterT w IO), s)' is not a type function.
20:27:35 <simpson> @unmtl StateT s (WriterT w IO) a
20:27:35 <lambdabot> s -> (WriterT w IO) (a, s)
20:27:43 <startling> oh oops
20:27:49 <simpson> @unmtl WriterT w (StateT s IO) a
20:27:50 <lambdabot> (StateT s IO) (a, w)
20:28:07 <raisdead> When I am in ghci and do :m +Data.Packed.Vector (hmatrix) I get the instances of Num (Vector Double), but if I import Data.Packed.Vector I do not get the instances of Num (Vector Double) Can anyone one help me understand why?
20:28:15 <startling> simpson, usually it's better to write your code for MonadState, MonadWriter, and MonadIO and let the caller decide anyhow.
20:29:03 <simpson> startling: Nah, this is pretty specific stuff; I'm building a network server.
20:29:08 <raisdead> the second is in a program, not in ghci. I should have said that sorry.
20:29:17 <simpson> startling: Anyway, I just realized that I don't need a writer; I'm gonna just write stuff instantly anyway.
20:30:00 <startling> simpson: I don't know how "building a network server" means that you need to be more specific, but OK.
20:30:19 <mjrosenb> is it possible to read a file in as a word16 array rather than a bytestring?
20:30:36 <simpson> startling: I mean that I'm not going to leave IO except to do STM work, and STM isn't an instance of MonadIO.
20:30:52 <Hermit> raisdead: :m +...  /=  import ...
20:34:08 <raisdead> Hermit: According to http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/ghci-commands.html "The form import mod is equivalent to :module +mod."
20:34:19 <Hermit> surprise!
20:35:35 <Hermit> let me grab that module myself...
20:35:57 <johnw> and "m" is all you need: :m +FOo
20:37:33 * Hermit got some compile error on hmatrix, trying to fix...
20:38:18 <startling> raisdead: I think the most likely possibility is that there's something else going on in your code.
20:38:36 <raisdead> Hermit: there are two system libraries I had to install first. I can't remember what they were...
20:38:46 <Hermit> got GSL right
20:38:53 <raisdead> Yes.
20:39:12 <Hermit> oops, same error after installing it
20:40:05 <raisdead> Hermit: Are you on windows? It doesn't work well on windows from my experience...
20:40:27 <Hermit> windows? lol, no, not a chance. Debian squeeze here
20:41:08 <raisdead> Hermit: I was hoping not, but that caused me a problem a while ago.
20:56:11 * hackagebot mega-sdist 0.2.10.2 - Handles uploading to Hackage from mega repos  http://hackage.haskell.org/package/mega-sdist-0.2.10.2 (MichaelSnoyman)
20:57:04 <Hermit> raisdead: Data.Packed.Vector does not seem to export hmatrix
20:57:25 <Hermit> and no, I don't get such instances (latest hmatrix)
20:58:01 <Hermit> are you sure your code isn't loading anything else?
21:05:27 <raisdead> Alright, so what happens is I `ghci file.hs` it fails to compile. I don't have the instance, but after I :m +Data.Packed.Vector then I have it. But if I `ghci` +m :Data.Paced.Vector then I don't have it.
21:08:39 <raisdead> well, it appears to work with Numeric.LinearAlgebra. Does ghci still import the libraries even if the file fails to compile? That is what it appears to be doing?
21:08:53 <Hermit> of course it does
21:09:20 <raisdead> well... now if feel dumb.
21:09:51 <Hermit> this is what happens when people do not ask while providing enough info of their case
21:10:12 * Hermit rephrases it
21:10:26 <Hermit> this is what happens when people asks without providing enough info of their case
21:10:50 <Hermit> you should have informed the way you were invoking ghci to start with
21:20:15 <Ghoul_> > join (,) 3
21:20:16 <lambdabot>   (3,3)
21:21:07 <flebron> So (-1) `rem` (-2) and (-1) `div` (-2) both give negative answers. Is there any operator which returns the mathematical notion of "remainder", that is, a number in [0..|b|-1], with b the divisor?
21:21:21 <flebron> Err. not `div`, but `mod` up there :)
21:23:21 <Ghoul_> :t sign
21:23:22 <lambdabot>     Not in scope: `sign'
21:23:22 <lambdabot>     Perhaps you meant `sin' (imported from Prelude)
21:23:31 <johnw> :t signum
21:23:32 <lambdabot> Num a => a -> a
21:23:49 <carter> noooooooooo, stop reminding me about the numerical type classes
21:24:12 <flebron> So \x -> liftM2 (*) signum (rem x)? :p
21:24:23 <Ghoul_> yeah flebron beat me t it
21:24:40 <Ghoul_> I was trying out join, but liftM2 works
21:26:17 <flebron> I was trying to teach a class on the extended euclidean algorithm, but seems there's no (reasonable, for freshmen eyes) way to have haskell do the same thing the proof of correctness does, that is, get the remainder between two numbers :s
21:26:49 <carter> flebron: have you looked at some of the numerical prelude stuff?
21:26:55 <carter> whats the issue
21:27:10 <flebron> Niet, but I can't really use that with them, we see as little of the vast Haskell plains as possible :)
21:27:20 <carter> ok
21:27:27 <carter> you could do a mini one
21:27:30 <carter> as you teach the math
21:27:36 <flebron> Sure, I could. :)
21:27:55 <carter> kinda like how some classes teach parser combinators
21:27:58 <carter> but in this case
21:28:24 <carter> you do the reveal, pulling the table cloth quickly off, to reveal: the cake of math is a lie
21:29:10 <flebron> I think I'll just prove it for natural numbers, and tell them the proof for integers is "straightforward" :p
21:31:37 <monochrom> flebron: both rem and mod fail you?
21:32:02 <flebron> Neither satisfy the mathematical definition of "remainder", which is always nonnegative.
21:32:16 <flebron> (i.e. an element of the canonical representation of Z/mZ)
21:33:19 <monochrom> mod gives more non-negative answers. it only becomes negative with (-ve) `mod` (-ve)
21:33:55 <monochrom> if you care about that, you can use mod plus a bit of your own logic to get the remainder you want
21:34:23 <monochrom> you can put that in a function, give it a name, and use it many places
21:35:13 <flebron> I know, I was just trying to make it as clean as possible :) I think the clean solution is to just do the N case instead of Z, since proof-wise it's the same, but the implementation might differ.
21:36:24 <monochrom> I think what I said is both clean and complete. you can prove properties of the homebrew remainder function, then use that property, you know.
21:37:11 <flebron> Right, that'd lengthen the class a bit (I'd have to prove correctness of that as well)
21:37:36 <monochrom> you can write "obvious" or "omitted"
21:37:40 <flebron> Heh
21:39:04 <Cale> It might actually be worth mentioning the possible variations on division
21:39:45 <monochrom> you are going to omit one of two things. proof of the property of the homebrew function. proof of the property of the main algorithm. it seems clear to me which one is the most harmless to omit.
21:40:06 <monochrom> s/homebrew function/homebrew remainder function/
21:40:23 <Cale> It's a bit sad that Euclidean division isn't in the Prelude, but rem gives you a remainder whose sign matches the product of the signs of the arguments, and mod gives you a remainder whose sign matches the sign of the denominator.
21:41:04 <monochrom> you can, generally, say that it is sad that Euclidean division isn't in any standard lib of any language
21:41:12 <monochrom> except I think pascal
21:41:47 <Cale> In all cases, you get a representative of some equivalence class in Z/mZ
21:42:24 <flebron> As the recent government shutdown has taught us, not all representatives are equal :)
21:42:34 <Cale> (recall, the elements of Z/mZ are cosets a + mZ = {a + m*k : k in Z})
21:44:07 <monochrom> actually, do you really need a non-negative remainder?
21:45:35 <flebron> I'm not sure myself :) I'd guess it works either way, but the proof is likely slightly more complicated.
21:46:20 <monochrom> it is not needed for partial correctness.
21:46:45 <monochrom> for termination you just need some kind of "the absolute value of something decreases to 0"
21:46:59 <monochrom> the "something" itself, who cares if it's + or -
21:48:05 <flebron> Well, I'm trying to use the notion of induction that they've seen as of now, which is proving (forall n' < n. P(n')) => P(n) and P(0).
21:48:33 <flebron> So I'm trying to get the P quite explicit and all the details filled in. They've only recently seen induction, so they're not comfortable with "winging it" or "it's clear that" :p
21:49:00 <monochrom> yes yes, that is compatible with everything I said
21:52:06 <monochrom> here is your n' < n: n' = |x `f` y|, n = |y|.  f could be mod, rem, euclidean remainder. it does not matter. works out.
21:52:28 <Athan> Does anyone know how to look up imported functions? I have no idea what module they belong to
21:52:41 <monochrom> I'm going to brush teeth and then write you the exact bloody P.
21:52:46 <Iceland_jack> Athan: Does :info do what you want?
21:52:54 <monochrom> meanwhile please enjoy my http://www.vex.net/~trebla/homework/extended-euclid.html
21:53:08 <Iceland_jack> Prelude> :i drop
21:53:09 <Iceland_jack> drop :: Int -> [a] -> [a]       -- Defined in `GHC.List'
21:53:26 <Athan> oh woah
21:53:50 <flebron> The one I'm using is let euclid 0 b = (b, 0, 1); euclid a b = let (d, n, m) = euclid (b `rem` a) a in (d, m - (b `quot` a) * n, n)
21:53:58 <Athan> :i requestHeaders
21:56:40 <jrw> I'm new to GADTs. is something like this possible/sane? http://lpaste.net/94400 I get a type error
21:57:05 <jmite> Can somebody help me update cabal in Ubuntu 13.10? I've done "cabal install cabal-install" but when I do "cabal --version" it still shows  1.16.0, not 1.18.02. Does anyone know how to fix this?
21:57:33 <acomar> jrw: Fun == fmap, Const is well... Const
21:57:45 <acomar> is there some reason you're trying to wrap it up this way?
21:57:52 <monochrom> jmite, play with PATH, and also read about "hash -r"
21:57:57 <acomar> sorry, Const is pure/return
21:58:10 <Iceland_jack> jrw: Add “Expr a -> a” as a type signature
21:58:12 <Iceland_jack> and it checks
21:58:16 <jmite> thanks, I've never heard of hash -r
21:58:21 <jrw> acomar, mostly for fun/curiosity
21:58:26 <jrw> Iceland_jack, oh, sweet. thanks!
21:58:39 <jrw> Iceland_jack, why is that...?
21:58:56 <Iceland_jack> Basically GHC cannot infer the type of it :)
21:59:01 <Iceland_jack> read the paper if you want details
21:59:08 <jrw> okay, thanks again
21:59:29 <Iceland_jack> No proble, just need to give the type checker a little nudge
22:01:16 <acomar> jrw: fair enough
22:03:52 <jrw> acomar, if you're curious, I'm working on something that compares various numerical expressions when they're evaluated over floats vs doubles. Fun lets me lift haskell functions into my expression language.
22:04:34 <acomar> jrw: wouldn't it work better to just give a Functor instance for Expr, and just fmap?
22:05:06 <jrw> no, that wouldn't quite work
22:05:16 <acomar> even if you use a GADT to restrict the target types?
22:05:34 <jrw> I want to allow things like "1 + sin(3 * x)"
22:05:56 <jrw> so I encode sin using Fun
22:06:46 <jrw> (the real eval also takes a map from variables to values, to evaluate things like "x")
22:07:48 <acomar> jrw: it really sounds to me like what you want is a Functor/Monad -- like a textbook case for the Free type
22:08:08 <acomar> there was a recent talk on it...
22:08:12 <acomar> let me see if I can dig up the link
22:08:29 <acomar> ah, found it: http://skillsmatter.com/podcast/home/monads-for-free/te-8320
22:09:21 <acomar> the talk is about implementing DSLs (like your expr language) in a way that preserves correctness and providing a monad instance
22:09:47 <acomar> the monad stuff might be unnecessary for you, but the Free Functor sounds pretty applicable/useful
22:09:57 <jrw> acomar, interesting, I'll take a look. what's the downside to my naive approach?
22:10:09 <acomar> jrw: you're doing it all by hand :)
22:10:29 <acomar> jrw: basically, this is a pretty common pattern that a lot of people have run into
22:10:37 <acomar> and there's a fairly canonical encoding for it
22:11:10 <jrw> ok. I don't have time to watch the video right now, but thanks for the pointer
22:15:15 <acomar> tl;dr is write out an Expr type that just encodes your expressions, wrap it in a Free monad, and get a DSL out
22:15:45 <acomar> he derives the wrapping and explains the motivations in the video
22:18:07 <jrw> acomar, maybe I'm still missing something, but I don't see how that let's me encode something like the sine function as an expression in my language
23:17:41 <ReinH> edwardk: ping
23:18:32 <zRecursive> pang
23:18:44 <zRecursive> pong
23:18:47 <edwardk> heya. next deep in slides and getting on a plane in 2 hours
23:18:50 <edwardk> er neck deep
23:19:31 <ReinH> edwardk: hahaha, how long are you in SF for?
23:19:44 <edwardk> keynote ate my first draft of my slides about 2 hours ago, so i've been frantically trying to repair
23:19:50 <ReinH> argh!
23:19:51 <edwardk> til monday night
23:19:52 <johnw> ouch
23:20:19 <ReinH> edwardk: you fucker, you aren't going to riconwest?
23:20:27 <ReinH> I'm going to miss you by a week
23:20:40 <edwardk> ah well
23:20:48 <ReinH> oh well
23:20:56 <edwardk> would have had to miss a wedding back in michigan
23:21:09 <ReinH> say hi to Lindsey Kuper for me. I think she's talking about LVars again
23:21:12 <edwardk> will do
23:21:16 <apples> hey, i look forward to seeing the talk tomorrow :)
23:21:17 <zRecursive> what does SD stand for ?
23:21:23 <zRecursive> s/SD/SF
23:21:29 <edwardk> san francisco
23:21:52 <ReinH> edwardk: she's like a broken record. Write a new paper already ;)
23:22:07 <ReinH> j/k I'm really looking forward to her ricon talk
23:22:13 <startling> edwardk, the dangers of mutable state, eh?
23:24:48 <edwardk> startling: =(
23:25:14 <edwardk> startling: i'll have the flight there to work on new slides, and now since i know what i want to say i can be much more organized
23:26:12 <startling> edwardk, aha, STM.
23:31:27 * hackagebot authoring 0.3 - A library for writing papers  http://hackage.haskell.org/package/authoring-0.3 (TakayukiMuranushi)
23:33:30 <lpaste> eflister pasted “parsecBind” at http://lpaste.net/94401
23:34:29 <eflister> i have p :: ParsecT s u (Reader b) a, which needs an environment that is parsed from earlier input in the same stream by q :: Parser b.  i want to combine q and p so that p picks up the Parsec state from where q left off (errors with correct line numbers, etc), and ideally, allows more parsers to follow where that leaves off.  it seems like i should use Parsec's =<< for this, but don't see how...  sketch at http://lpaste.net/94401
23:43:42 <eflister> anyone got time to help with my parsec question there?  :)
23:49:19 <monochrom> @tell flebron http://lpaste.net/94402
23:49:19 <lambdabot> Consider it noted.
23:49:43 <flebron> Haha for a second I thought that was a Coq proof :)
23:50:35 <flebron> Thanks :)
23:52:01 <Saizan> eflister: if you had ReaderT b (Parsec s u a) it'd be easy
23:54:16 <monochrom> flebron: I now go to sleep. if you need me, you will have to find me 12 hours later or something
23:54:29 <flebron> monochrom: Alright. Thanks again :)
23:59:06 <eflister> saizan: i started pursuing that but went back to this way cuz A) i wound up needing a zillion lifts everywhere, B) i would have needed edwardk's parsers package for combinators that work when ParsecT isn't the outermost monad, and C) i know it's isomorphic, but feel that this way, it isn't implied that different environments are available to different backtracking branches...
