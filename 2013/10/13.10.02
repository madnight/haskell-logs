00:00:01 <mm_freak_> a function type always involves "->"
00:00:14 <chexxor> but space means function application
00:00:26 <mm_freak_> well, juxtaposition means function application
00:00:55 <mm_freak_> chexxor: ok, i'll try again
00:00:59 <mm_freak_> Succ Zero :: Nat
00:01:18 <mm_freak_> Succ is applied to Zero to yield a Nat
00:01:20 <chexxor> Succ :: x -> Nat
00:01:23 <mm_freak_> yeah
00:01:31 <mm_freak_> but x is something specific
00:01:46 <mm_freak_> apparently Succ Zero worked, so there is really only one option
00:01:54 <chexxor> Succ :: Zero -> Nat
00:02:02 <mm_freak_> that's a type error
00:02:05 <mm_freak_> Zero is not a type
00:02:26 <chexxor> Succ :: Nat -> Nat
00:02:26 <mm_freak_> sin 3 :: Double
00:02:31 <mm_freak_> you don't say:  sin :: 3 -> Double
00:02:41 <mm_freak_> yeah, that's correct
00:03:14 <mm_freak_> so in a 'data' definition when you write "Succ Nat", it means that Succ is a value constructor with one Nat as its argument
00:03:59 <chexxor> ah, this is starting to make sense
00:04:12 <mm_freak_> data MaybeInteger = Nothing | Just Integer
00:04:15 <mm_freak_> what's the type of Just?
00:04:43 <chexxor> Just :: Integer -> MaybeInteger
00:04:46 <mm_freak_> yeah
00:04:53 <mm_freak_> data Maybe a = Nothing | Just a
00:04:57 <mm_freak_> what's the type of Just now?
00:05:06 <chexxor> Just :: a -> Maybe
00:05:12 <mm_freak_> that's a kind error
00:05:20 <mm_freak_> Maybe expects an argument
00:05:27 <chexxor> ah
00:05:34 <chexxor> Just :: a -> Maybe a
00:05:38 <mm_freak_> exactly
00:05:48 <mm_freak_> data WeirdMaybe a = Nothing | Just Integer
00:05:51 <mm_freak_> what's the type of Just?
00:06:16 <chexxor> Just :: Integer - > WeirdMaybe a
00:07:37 <mm_freak_> chexxor: yes, except for the syntax error =)
00:07:46 <chexxor> in "data Maybe a = Nothing | Just a"...
00:07:51 <leroux> mm_freak_: Isn't `a` just ignored?
00:07:52 <chexxor> a :: ?
00:08:00 <mm_freak_> leroux: "ignored"?
00:08:03 <sipa> forall a. a
00:08:15 <sipa> chexxor: a is any type
00:08:21 <mm_freak_> chexxor: 'a' is a type variable…  it can be any type
00:08:25 <chexxor> so, a :: * ?
00:08:25 <leroux> Right.
00:08:29 <sipa> chexxor: indeed!
00:08:39 <sipa> it can't be a (non-nullary) type constructor
00:08:55 <mm_freak_> chexxor: let x :: Integer, what's the type of Just x?
00:09:36 <sipa> basvandijk: hi!
00:09:45 <chexxor> Just (x::Integer) :: Maybe Integer ?
00:09:50 <mm_freak_> chexxor: yeah
00:09:56 <mm_freak_> chexxor: why is that?
00:10:06 <lesur> @hoogle div
00:10:07 <lambdabot> Prelude div :: Integral a => a -> a -> a
00:10:07 <lambdabot> Prelude divMod :: Integral a => a -> a -> (a, a)
00:10:07 <lambdabot> Data.Fixed div' :: (Real a, Integral b) => a -> a -> b
00:10:18 <mm_freak_> chexxor: shouldn't it be "Just x :: Maybe a"?
00:10:33 <chexxor> mm_freak_: not exactly sure... the type variable is the same
00:10:38 <sipa> chexxor: bingo
00:10:39 <mm_freak_> exactly!
00:10:44 <mm_freak_> a -> Maybe a
00:10:56 <mm_freak_> if a becomes Integer, then the whole type becomes Integer -> Maybe Integer
00:11:32 <chexxor> okay
00:12:01 <chexxor> so in "Maybe a = Nothing | Just a"...
00:12:07 <chexxor> Nothing is a value
00:12:12 <chexxor> Just is a value constructor
00:12:32 <mm_freak_> yes, that's right, although we refer to both as value constructors
00:12:47 <mm_freak_> both "construct" a value of type 'Maybe a'
00:12:49 <chexxor> mm_freak_: why is Nothing a constructor?
00:13:17 <chexxor> ok, so these are value constructors, where did the type constructors go?
00:13:26 <mm_freak_> Maybe is a type constructor
00:13:39 <chexxor> oh god
00:13:48 <chexxor> no, Maybe is a type
00:13:54 <mm_freak_> a type constructor is something of kind * -> …
00:14:01 <mm_freak_> Maybe :: * -> *
00:14:27 <mm_freak_> "type constructor" is really just a convenience term for a type that takes a type as argument to yield a type
00:15:02 <mm_freak_> Maybe is a type, a type constructor…  we usually refer to types of kind * as "concrete types"
00:15:07 <chexxor> ah, Maybe has an argument, so we say Maybe is a constructor
00:15:13 <mm_freak_> so Integer is a concrete type
00:15:17 <mm_freak_> Maybe is a type constructor
00:15:22 <mm_freak_> Maybe Integer is a concrete type
00:15:33 <mm_freak_> Integer :: *, Maybe :: * -> *, Maybe Integer :: *
00:15:37 <chexxor> ah!
00:15:49 <chexxor> if a type has a variable, it's a type constructor?
00:15:58 <mm_freak_> an argument
00:16:08 <chexxor> then, when we satisfy it's arguments, it becomes a type?
00:16:13 <lesur> john
00:16:19 <lesur> wups, sorry
00:16:42 <mm_freak_> chexxor: when we apply it enough to become a * then it becomes a concrete (!) type
00:16:46 <mm_freak_> all of these things are types
00:17:09 <chexxor> ah!
00:17:13 <mm_freak_> a type is something of a kind
00:17:15 <chexxor> this is so enlightening
00:17:21 <mm_freak_> a value is something of a type
00:17:21 <TallerGhostWalt> is it considered bad form / confusing to mix applicative and monadic styles?
00:17:32 <mm_freak_> TallerGhostWalt: not at all
00:17:39 <TallerGhostWalt> good cause I love it
00:17:51 <mm_freak_> TallerGhostWalt: use applicative style where applicable, use monadic style elsewhere
00:18:11 <TallerGhostWalt> mm_freak: Yeah I just worry about readability  at times
00:18:36 <mm_freak_> TallerGhostWalt: don't measure readability in how well a C# programmer would understand your code =)
00:18:45 <mm_freak_> TallerGhostWalt: to a haskell programmer both styles are pretty clear
00:19:01 <mm_freak_> including their combination
00:19:46 <TallerGhostWalt> gp
00:25:56 * hackagebot jsonrpc-conduit 0.2.1 - JSON-RPC 2.0 server over a Conduit.  http://beta.hackage.haskell.org/package/jsonrpc-conduit-0.2.1 (GabrieleSales)
00:27:59 <chexxor> mm_freak_: Thank you!
00:28:19 <chexxor> This definitely gives me a new way to approach my problems.
00:43:47 <mm_freak_> chexxor: you're welcome =)
01:09:46 <basvandijk> sipa: Hello
01:10:48 <johnw> basvandijk: hello!
01:10:56 <johnw> basvandijk: I sent you the e-mails about monad-control
01:12:08 <basvandijk> johnw: Ah yes of course
01:50:50 <profmakx> is there a way to tell whether ghc has been build registerised/unregisterise?
01:53:21 <int-e> ghc --info | grep Unregisterised
02:08:11 <profmakx> thanks, int-e
02:19:55 <LMolr> Why do MSB-first Bitstreams are called _Right_? I would call them left, as they are packed left-first ..
02:26:32 <Flonk> @src (->)
02:26:32 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
02:26:40 <Flonk> @src ((->) r)
02:26:40 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
02:27:11 <Flonk> How exactly is ap (or <*>) implemented for the ((->) r) Monad?
02:28:48 <haasn> (<*>) :: (r -> a -> b) -> (r -> a) -> r -> b
02:28:58 <quchen> Flonk:  f <*> g = \x -> f x (g x)
02:28:58 <haasn> Just follow the types :)
02:29:46 <quchen> > zip <*> tail $ [1..10]  -- the canonical example
02:29:47 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
02:30:19 <Flonk> quchen: Okay, that makes sense
02:30:19 <haasn> > (+) <*> (^2) $ 10
02:30:19 <lambdabot>   110
02:30:21 <Flonk> It looks just like the S combinator
02:30:26 <quchen> Because it is :-)
02:30:29 <haasn> it is the S combinator
02:30:48 <haasn> (and pure = K !)
02:30:50 <quchen> pure = K
02:30:51 <quchen> Eh.
02:32:02 <Flonk> How is pure K?
02:32:29 <quchen> K x y = x.   pure = const, therefore  pure x y = const x y = x.
02:33:03 <Flonk> pure = const?
02:33:10 <quchen> For (r ->), yes.
02:33:18 <Flonk> Oh
02:33:19 <c_wraith> oh, hey, that LVish thing looks pretty cool
02:33:21 <Flonk> Okay, thats cool
02:33:31 <quchen> instance Applicative ((->) r) where pure = const; f <*> g = \x -> f x (g x)
02:34:25 <Flonk> quchen, haasn: Thanks!
02:34:53 <quchen> Flonk: There was even some Hello World written in SKI around, and somebody translated it to Applicative ;-)
02:34:54 <bartavelle> c_wraith, I wish the haddocks would work on hackage :(
02:35:09 <quchen> https://gist.github.com/folone/3486644
02:36:10 <Flonk> lolwut
02:36:38 <c_wraith> bartavelle: I'm still just reading the paper.  If I'd got as far as looking at the library, I'd want the same thing.
02:37:02 <quchen> Flonk: It's a fork of https://gist.github.com/shangaslammi/3438688 with different names basically
02:37:54 <haasn> quchen: cute
02:37:56 <Flonk> quchen: Is it basically applying succ to '\n' a bunch of times?
02:37:59 <haasn> now write fizzbuzz
02:38:41 <haasn> Flonk: to produce characters, yes
02:38:52 <haasn> Or uh..
02:39:02 <haasn> That \n might be the terminator or something. I don't understand the source at a glance, unfortunately
02:39:16 <Flonk> > succ '\n'
02:39:17 <lambdabot>   '\v'
02:39:21 <Flonk> hmm
02:39:22 <haasn> Try modifying \n and see what happens :)
02:39:28 <quchen> haasn: SKI doesn't allow comments so he couldn't annotate his program ;-)
02:39:47 <quchen> The code doesn't call   succ '\n'.
02:39:51 <haasn> /tmp/runghcXXXX24023.hs:4:1:
02:39:53 <haasn>     parse error (possibly incorrect indentation or mismatched brackets)
02:39:55 <haasn> hmm..
02:40:00 <haasn> mismatched brackets? I don't think so
02:40:01 <quchen> These are two different parameters to the "hello" function.
02:40:37 <quchen> I somehow understood it at some point, but I don't anymore.
02:41:18 <quchen> But the general gist is just building up a long list of "succ" applications corresponding to ASCII and then printing that. The \n is just a trailing newline.
02:41:47 <haskellnoob> I have a function returning IO [[SqlValue]], instead I want to change it's return type to be IO [(String,String)], what should use to transform the results in this function?
02:42:00 <haasn> quchen: changing the \n seems to break the entire string, though
02:42:04 <quchen> Flonk: If it helps,  c = fmap = (.)  and  b = flip
02:42:12 <haasn> so it's not just a ‘trailing newline’, it actually seems to be used as the ‘base’ to succ
02:42:21 <quchen> Oh.
02:42:27 <johnw> haskellnoob: you would use fmap f, where f is some function [SqlValue] -> (String,String).  Do you have such a function?
02:42:29 <peteretep> > ord '\0' = 0
02:42:30 <peteretep> > ord x = 1 + ord (pred x)
02:42:31 <lambdabot>   <hint>:1:10: parse error on input `='
02:42:31 <lambdabot>   <hint>:1:7: parse error on input `='
02:42:43 <Flonk> Yep, that's what i I meant.
02:42:55 <quchen> haasn: Could be though, because there's nothing useful before \n in ASCII, hence he saves a couple of succ applications with it I guess
02:43:39 <haasn> quchen: well, otherwise he'd need an extra parameter '\0' or something - after all, SKI doesn't allow character literals!
02:46:01 <haskellnoob> johnw: ok I do have fmap, trying to fix my code using it
02:46:20 <quchen> haasn, Flonk: replacing IO with List, the call `hello (:) [] succ '\n'` results in "Hello world!\n". Not unexpected, but it verifies that this just builds up a successive list of characters.
02:47:19 <AlecTaylor> Tree grammars are interesting
02:47:39 <quchen> haasn: And when you replace 'succ' with 'id' you get a string "\n\n\n...", so it does indeed start calculating at \n.
03:00:57 <haskellnoob> http://lpaste.net/93741 is there a better way to write the lambda I pass to fmap?
03:01:40 <haskellnoob> having a _ seems odd
03:01:46 <johnw> that looks fine to me
03:02:28 <haskellnoob> johnw: thanks
03:31:22 * hackagebot jsonrpc-conduit 0.2.2 - JSON-RPC 2.0 server over a Conduit.  http://beta.hackage.haskell.org/package/jsonrpc-conduit-0.2.2 (GabrieleSales)
03:54:03 <anothernewhaskel> Hi there - I was making a reverse list function pastie.org/8371831 is what i was looking at, and was wondering why you assign (x:xs) to the function? Not quite understanding it.
03:55:07 <merijn> anothernewhaskel: There is no assignment? Are you maybe referring to the pattern match?
03:56:18 <anothernewhaskel> Maybe, I'm really new...I just meant the equals sign
03:56:22 <merijn> anothernewhaskel: Haskell lists have two constructors, [] (the empty list) and : which takes an element and a list and adds that element to the list
03:56:40 <haasn> In Haskell, = is not assignment
03:56:45 <merijn> anothernewhaskel: In functions you can pattern match on constructors and specify the behaviour for that pattern
03:57:02 <monoidal> anothernewhaskel: your code can be written as reverseList' a = case a of [] -> []; x:xs -> reverseList' xs ++ [x]
03:57:05 <merijn> anothernewhaskel: So essentially, what you're seeing here is "if the argument list is the empty list, return an empty list"
03:57:59 <monoidal> anothernewhaskel: pattern matching is another way of writing that case expression
03:58:03 <merijn> anothernewhaskel: "if the argument list is a non-empty list (i.e. at least one : constructor), refer to the added element as 'x' and the tail list as 'xs' in the code after the ="
03:59:02 <merijn> anothernewhaskel: i.e. while pattern matching (in function arguments or in case-of blocks) you can use constructors to do the reverse, i.e. taking things apart via pattern matches
03:59:58 <merijn> Another name for this is "destructuring assignment", you can compare it to Go/Python's ability to assign a list/tuple to different variables, like "x, y = [1,2]", resulting in x == 1 and y == 2
04:16:27 * hackagebot accelerate-cuda 0.13.0.4 - Accelerate backend for NVIDIA GPUs  http://beta.hackage.haskell.org/package/accelerate-cuda-0.13.0.4 (TrevorMcDonell)
04:17:00 <oddsignals> is there a quick way to show the value of an unboxed Ptr?
04:17:21 <oddsignals> trying to debug a ghci crash
04:19:34 <haasn> (of course, = is still not assignment)
04:26:34 <oddsignals> that is, the value of an Addr#
04:26:49 <chrisdone> http://spl.smugmug.com/Humor/Lambdacats/i-dVj9xxz/1/Th/recurcat-Th.gif
04:30:09 <quicksilver> oddsignals: I thought there was a show instance for Addr#, isn't there?
04:30:24 <quicksilver> if not you can probably unsafeCoerce it to Int#
04:31:20 <monoidal> quicksilver: there's isn't a show instance
04:32:34 <oddsignals> show (Ptr addr) works
04:40:14 <jmcarthur> ReinH: that article doesn't really fundamentally change the architecture of your game. converting lower level events into higher level events is good. using STM when there is no concurrency is overkill, but not harmful.
04:40:40 <Sagi> is there some kind of syntactic sugar for String -> Text? I'd be quite annoying if I have to write pack "foo" everytime I want to get Text :-\
04:40:52 <jmcarthur> Sagi: -XOverloadedStrings
04:41:22 <Sagi> oh, brilliant :-)
04:41:24 <Sagi> tnx
04:41:44 <jmcarthur> Sagi: basically just put the language pragma at the top of your file and then string literals are polymorphic (with a type class)
04:41:54 <jmcarthur> Text has an instance
04:42:31 <Sagi> will do. I have actually seen that pragma quite a few times, but didn't make the (simple) leap
04:44:24 <Kneiva> chrisdone: nice =)
04:49:58 <merijn> Sagi: essentially it turns string literals into "fromString <literal>" just like integer literals are "fromInteger <literal>"
05:12:00 <dwcook> How do I tell cabal build to use certain flags when invoking ghc?
05:13:44 <dwcook> More specifically, without having to specify them to cabal itself every time
05:19:41 <dwcook> Ah, was confused a bit by the documentation. --prog-option given to cabal configure seems to do it.
05:19:45 <DMcGill> Does Foldable or Traversable give some sort of zipWith function?
05:20:32 <DMcGill> I have an ADT that's isomorphic to a triple and I'd like zipWithT :: (a -> b -> c) -> (a,a,a) -> (b,b,b) -> (c,c,c)
05:20:50 <haskellnoob> is there anything that would make verbatim (mostly multiline) string nicer than escaping lines end/begin with \? ala @ in c#?
05:21:35 <sinclair|work> haskellnoob: have you tried "a" + "b" + "c"
05:21:43 <DMcGill> hmm, actually I think an Applicative instance will do what I want.
05:22:57 <dwcook> sinclair|work, wouldn't that use the Num method (+) (by default)?
05:23:56 <dwcook> (++) would work but I wonder whether ghc would ever optimize it away to a single string.
05:24:36 <sinclair|work> haha
05:24:37 <DMcGill> I would be astonished if GHC didn't constant fold like that
05:25:02 <sinclair|work> dwcook: i appreciate its inefficient,
05:25:20 <sinclair|work> dwcook: but to be perfectly honest, i know 0 haskell.
05:25:25 <ClaudiusMaximus> i generally > unlines [ "foo", "bar", "baz" ]
05:25:34 <dwcook> Well, that explains that. :P
05:25:40 <haskellnoob> sinclair|work: that wouldn't look handy with multiline literals
05:25:47 <sinclair|work> im only here to wade in the warm glow of functional programming knowledge that goes on in this place
05:26:10 <DMcGill> dwcook: at the end of the day, worrying about things like this is premature optimisation
05:26:31 <dwcook> DMcGill, fair enough.
05:26:55 <DMcGill> just use unlines or (++) yourself and, if performance is slow and that's a bottleneck only then should you concern yourself with it imo
05:28:02 <DMcGill> How bad is it to have instances of Applicative that don't satisfy the laws?
05:28:20 <Lethalman> ghc -O2 will merge "a" ++ "b" + "c" to ['a', 'b', 'c']
05:29:08 <donri> DMcGill: bad because it's the very reason they're forced to make the new applicative do desugaring opt-in :(
05:29:22 <DMcGill> My TripleP class, essentially (Ix, a, a, a) where Ix = First | Second | Third means that pure needs to provide an arbitrary index and that <*> will use the index of the first TripleP. Unfortunately this means that the first Applicative law, namely "pure id <*> v = v" isn't satisfied.
05:29:52 <DMcGill> On the other hand, I find myself writing exactly the functions pure and <*> for it anyway just with longer and more specific names
05:30:46 <donri> maybe that's an indicator you would benefit from changing the type to something that could be legal
05:31:09 <donri> or maybe you should look at Apply
05:31:21 <donri> @hackage semigroupoids
05:31:22 <lambdabot> http://hackage.haskell.org/package/semigroupoids
05:31:42 * hackagebot bitstream 0.2.0.3 - Fast, packed, strict and lazy bit streams with stream fusion  http://beta.hackage.haskell.org/package/bitstream-0.2.0.3 (MasatakeDaimon)
05:32:07 <donri> actually Apply still requires Functor and that's a functor law you're breakaing
05:33:27 <DMcGill> This is what I'm trying to do: http://lpaste.net/93749
05:33:48 <DMcGill> They're functors since fmap just replaces the elements and leaves the index alone though.
05:33:55 <DMcGill> fmap id = id
05:33:58 <chrisdone> donri: trivial haskell searcher =p  http://lpaste.net/93747
05:42:11 <alpounet> chrisdone, cool! how long did it take to answer?
05:43:32 <chrisdone> alpounet: 0.8s for both. so i imagine the parsing is the overhead, searching is peanuts
05:43:54 <alpounet> oh right that's perfectly reasonable for use in say haskell-mode
05:43:57 <chrisdone> (actually, probably searching is the same)
05:43:58 <chrisdone> yeah
05:44:24 <chrisdone> hse is known for being slow. a lexer would do much faster i think
05:48:11 <alpounet> ghc api may be better?
05:48:27 <Peaker> chrisdone: it would be really nice to have it be able to search things like "references to this constructor field" (positional or named)
05:48:37 <Peaker> (so need type-inferred search!)
05:49:14 <chrisdone> Peaker: hm, not type inferred?
05:49:29 <chrisdone> Peaker: surely just name-resolved search
05:50:37 <chrisdone> using haskell-names should be sufficient to do that
05:50:41 <Peaker> chrisdone: I guess if you don't use the resolve ambiguous record field names extension it would mostly work
05:51:12 <DMcGill> talking about GHC in general, is type-driven name resolution a 'never going to happen' or 'hasn't happened yet' thing? It seems like it'd essentially solve the problem that classy-prelude and co are trying to fix.
05:51:14 <chrisdone> ambiguous record field names doesn't require types does it?
05:51:25 <donri> chrisdone: oh cool
05:51:35 <chrisdone> Peaker: i can't remember how that feature works. not used it in years
05:51:45 * hackagebot http-querystring 1.0 - The HTTP query builder.  http://beta.hackage.haskell.org/package/http-querystring-1.0 (YusukeNomura)
05:51:50 <Peaker> chrisdone: I think it does typed-based disambiguation of record field names
05:52:18 <merijn> DMcGill: I think it's in between those
05:52:27 <Peaker> DMcGill: TDNR for records fields is being done I think (Similar approach to the HasFoo classes)
05:52:28 <chrisdone> Peaker: doesn't it have the "type" from the constructor being pattern matched?
05:52:39 <Peaker> chrisdone: x { y = 1 }
05:52:42 <donri> chrisdone: i wonder if you could throw more generics at it to generate the case that covers everything
05:53:00 <Peaker> chrisdone: (record update)
05:53:25 <Peaker> though I'm not actually sure it'd disambiguate this, so maybe I'm wrong and there's not type-based disambiguation there
05:53:30 <chrisdone> Peaker: i don't think it applies to record update
05:53:39 <DMcGill> One of the biggest problems with the type-class approach is that some functions have different number of value params (maps needing index) or type params (bytestring & co)
05:53:49 <Peaker> chrisdone: soon the TDNR thing might make it harder to find references to a specific field if they all go via a type-class
05:53:51 <DMcGill> Which TDNR wouldn't be affected by right?
05:54:06 <chrisdone> Peaker: i mean i've done record update with other things in scope without enabling that extension. although maybe someone else enabled it… /me tests
05:54:12 <Peaker> (in the general case, you probably can't, due to existentials/etc)
05:55:18 <Peaker> chrisdone: another useful search could be: "Find uses of this instance/method" which would require inside knowledge of GHC's instance resolution and of course the types involved
05:55:35 <chrisdone> yeah that would require ghc
05:55:37 <donri> DMcGill: i think TDNR wouldn't work very well for anything other than records
05:55:54 <chrisdone> Peaker: you can get that from looking at the core, at least
05:55:59 <Peaker> Though I guess you can do this search by deleting the instance temporarily and seeing what breaks (assuming no overlapping/etc)
05:56:04 <Peaker> chrisdone: ah, cool
05:56:20 <chrisdone> core has explicit dictionary passing (unoptimized)
05:56:26 <donri> DMcGill: e.g., k.insert a m, the resolution happens on the k, which is likely ambiguous
05:56:31 <donri> unless i've misunderstood TDNR
05:57:06 <donri> DMcGill: you want, m.flip (insert a) k, or something :P
05:57:07 <DMcGill> That's how I was thinking about it, why is the k likely ambiguous? Surely at some point in the program you'd instantiate it with concrete types
05:58:17 <donri> DMcGill: there may be multiple insert :: Ord k => k -> x in scope
05:58:36 <donri> i think it just looks at the first parameter, the LHS of the dot
05:58:39 <DMcGill> I was under the impression that (non-record) with TDNR you'd replace your (S.insert v s, M.insert k v m) with just (insert v s, insert k v m) and the compiler infers which 'insert' you mean
05:59:09 <donri> no, you do value.function and it looks up function based on value and calls it as function value
05:59:37 <DMcGill> Ah I see, what is the thing that I am thinking about called? Inference drived ambiguity resolution?
05:59:40 <DMcGill> driven*
05:59:58 <donri> i don't know of any such proposal for haskell
06:00:10 <donri> it could also be called TDNR, but that's not the existing proposal
06:00:18 <DMcGill> therein lying my confusion
06:00:23 <chrisdone> Peaker: just tested it, i don't think it uses the type system at all: x = 1; r = X 2; p = r { x = 3 }
06:00:23 <chrisdone> Peaker: if i import two modules with different records both with X, then the ambiguity warning says "could be either the local x, or either of these imports"
06:00:25 <donri> yeah, you're not alone
06:00:27 <DMcGill> thanks for your answers
06:00:31 <donri> most people miss this point about TDNR
06:00:37 <chrisdone> Peaker: which indicates to me that it just says "okay what are all the records that have a field `x'?"
06:00:59 <chrisdone> oh wait. so if i enable Disambiguate
06:01:38 <chrisdone> nope. it's still ambiguous even with DisambiguateRecordFields
06:02:01 <chrisdone> however, using an explicit constructor is unambiguous
06:02:12 <donri> "In record construction and record pattern matching it is entirely unambiguous which field is referred to, even if there are two different data types in scope with a common field name."
06:02:15 <chrisdone> which is consistent with the ghc manual
06:02:19 <donri> construction and pattern matching, not update
06:02:21 <donri> yeah
06:02:39 <donri> (of course update is construction, technically, but semantics :P)
06:02:59 <chrisdone> so yeah, you could use haskell-names for record fields
06:03:46 <Peaker> chrisdone: ah, sorry for the misleading info then
06:04:08 <chrisdone> Peaker: np, i wasn't sure either
06:04:12 <Peaker> chrisdone: sounds like you can go pretty far with type-less search in Haskell.. and core can fill in the gaps for instance/method searches that need types
06:05:12 <donri> doesn't ghc run its renamer before type checking, thus showing that type inference isn't needed for name resolution?
06:05:29 <Peaker> I guess one way to "find all references to a field" (positional or not) is to change its type to some superfluous Identity newtype wrapper, fix everything while adding the newtype wraps/unwraps, then just remove all the newtype references
06:05:53 <aiki6> Hello, #haskell.
06:05:58 <donri> i read RecordWildCards are annoying to resolve though
06:06:14 <donri> but haskell-suite might be able to do it by combining -{names,packages}?
06:06:22 <chrisdone> they were annoying to implement in fay
06:06:27 <chrisdone> but haskell-names handles it
06:06:31 <donri> ah cool
06:06:59 <aiki6> I'm trying to solve skyline problem in haskell and the very firt problem i've encountere is understanding of the expected output solution...
06:07:24 <aiki6> (1,11,5), (2,6,7), (3,13,9), (12,7,16), (14,3,25), (19,18,22), (23,13,29), (24,4,28)  =>  1, 11, 3, 13, 9, 0, 12, 7, 16, 3, 19, 18, 22, 3, 23, 13, 29, 0
06:08:00 <aiki6> I don't get it, are that output supposed to be highest height of building at some point X?
06:11:08 <aiki6> f [(0, 5, 5)] -> [5, 5, 5, 5, 5]
06:11:19 <aiki6> Is it correct?
06:11:43 <Rarrikins> That should probably be 0, 5, 5, 0
06:13:23 <aiki6> Rarrikins: Hm, why? That building width is 6(from x=0 to x=5), and its height is also 5, so for all X on 0..5 interval i should draw 5.
06:13:37 <t7> @djinn (a, b) -> Either a b
06:13:38 <lambdabot> f (a, _) = Left a
06:13:51 <Rarrikins> Rarrikins: At x = 0, go to height 5. At x = 5, go to height 0.
06:14:49 <aiki6> Ah, so it's more like f [(0, 5, 5)] -> [0, 5, 5, 5, 5, 5, 0] ?
06:15:10 <chrisdone> darn. fast-tags is specific to vim
06:15:22 <chrisdone> however. fast-tags has a fast lexer
06:15:26 <aiki6> But it don't match with sample input output at all!
06:15:33 <chrisdone> bytestring based. mm
06:15:34 <t7> @djinn Either a b -> Either b c -> Either (Either a c) b
06:15:34 <lambdabot> f a b =
06:15:34 <lambdabot>     case a of
06:15:34 <lambdabot>     Left c -> Left (Left c)
06:15:34 <lambdabot>     Right _ -> case b of
06:15:34 <lambdabot>                Left d -> Right d
06:15:35 <lambdabot>                Right e -> Left (Right e)
06:16:03 <aiki6> http://stackoverflow.com/questions/1066234/the-skyline-problem Look, for some reasone first number in output is 1...
06:16:54 <Rarrikins> Yeah, because at x = 1, go to height 11.
06:16:55 <merijn> aiki6: It explains it in the text
06:17:03 <merijn> aiki6: "The output should consist of the vector that describes the skyline as shown in the example above. In the skyline vector (v1, v2, v3, ... vn) , the vi such that i is an even number represent a horizontal line (height). The vi such that i is an odd number represent a vertical line (x-coordinate)."
06:17:21 <anothernewhaskel> pastie.org/8372093 I don't understand how Haskell knows what list I'm talking about when I call this method...I've not called it a or anything...how does it know I'm not talking about some other list?
06:17:50 <aiki6> merijn: I don't get what is "vi" it was "vn
06:17:55 <aiki6> "" doesn't it?
06:18:08 <ion> anothernewhaskel: You have called it (theHead:theList)
06:18:08 <Iceland_jack> anothernewhaskel: Not sure I understand what you mean
06:18:30 <haasn> anothernewhaskel: functions are applied to arguments
06:18:33 <Iceland_jack> Are you referring to the type signature ([a] -> [a]) or the definition (the lines below that)
06:18:40 <shiona> wait, stackoverflow and stackexchange are not one and the same?
06:18:40 <ion> > case 1:2:3:4:[] of theHead:theList -> (theHead, theList)
06:18:42 <lambdabot>   (1,[2,3,4])
06:18:53 <aiki6> "(v1, v2, v3, ... vn) , the vi" first it's vn then its vi. vn == vi?
06:18:58 <skittlez> Hmm how can you get the root of a rose tree? data Rose a = a :> [Rose a] the :> sign is an infix constructor
06:19:09 <haasn> anothernewhaskel: when you write a function application, like “reverseList' [1,2,3]”, that [1,2,3] is the parameter
06:19:17 <Rarrikins> shiona: Stack Exchange is the group of all the similar sites.
06:19:42 <Rarrikins> shiona: Stack Overflow is only the site for programming questions.
06:19:55 <anothernewhaskel> Carrying on from that, how do I refwrence the list in that method? Say I want to print it out after doing what it's doing there?
06:20:09 <haasn> skittlez: \(a :> _] -> a -- unless I'm grossly misunderstanding what you mean by ‘root’
06:20:10 <Iceland_jack> anothernewhaskel: Quick note, it's a "function" and not a method
06:20:42 <Iceland_jack> To answer your second question, you reference the list as [] or (theHead:theLIst) in your cast
06:20:42 <haasn> anothernewhaskel: Haskell is a pure functional language, there is no concept of ‘control flow’ or I/O, so your usage of ‘after’ is meaningless
06:20:44 <Iceland_jack> *case
06:21:07 <skittlez> haasn: Yeah the 'top' of the tree, where all the children come from
06:21:09 <shiona> Rarrikins: but there's codegolf.stackexchange.com.. if the pages fall inside the same group, then why are there code golf questions in the more common pages?
06:21:13 <haasn> things ‘are’. They don't ‘get done’. reverseList' (x:xs) ‘is’ reverseList' xs ++ (x)
06:21:18 <haasn> ++ [x] I mean
06:21:27 <Iceland_jack> If you define a function 'foo':
06:21:28 <Iceland_jack>     foo xs = …
06:21:28 <Iceland_jack> then ‘xs’ refers to the list passed in
06:21:58 <haasn> anothernewhaskel: (there is, however, a concept of ‘IO actions’ - things that can be done. You could construct an IO action from a list, for example)
06:22:00 <acomar> eanothernewhaskel: have you looked at "Learn you a Haskell for Great Good!"? It might be worth your time to work through.
06:22:07 <haasn> ^
06:22:08 <haasn> @where lyah
06:22:09 <lambdabot> http://www.learnyouahaskell.com/
06:22:45 <qwebirc987638> Right sorry
06:23:36 <anothernewhaskel> How would I change the method in http://pastie.org/8372093 to print out the list when its done
06:23:41 <anothernewhaskel> sorry to ask again
06:23:45 <Rarrikins> shiona: I don't know what you mean by the more common pages or the pages in the group. Stack Exchange is a group of sites rather than pages. Stack Overflow is a site.
06:24:27 <Iceland_jack> anothernewhaskel: You can define a new function (not method) as such:
06:24:27 <Iceland_jack>     reverseAndPrint xs = print (reverseList')
06:24:42 <Iceland_jack>     reverseAndPrint xs = print (reverseList' xs) *
06:24:55 <DMcGill> note that there reverseAndPrint xs :: [a] -> IO ()
06:24:59 <ion> without the *
06:24:59 <anothernewhaskel> Iceland_jack: but why can't I just print it inside the method I already have
06:25:07 <Iceland_jack> DMcGill: Missing Show, but yes
06:25:15 <Iceland_jack> anothernewhaskel: Have you looked at any Haskell resources?
06:25:15 <Rarrikins> shiona: Occasionally, people will post things on Stack Overflow that properly belongs on other Stack Exchange sites.
06:25:18 <anothernewhaskel> Iceland_jack: yes
06:25:20 <DMcGill> because of purity. Normal functions aren't allowed side effects.
06:25:23 <anothernewhaskel> Iceland_jack: learnyouahaskell
06:25:30 <shiona> Rarrikins: does sOverflow belong to the set of pages that is known as sExchange?
06:25:32 <DMcGill> LYAH explains this, how far through it did you get?
06:25:39 <anothernewhaskel> Iceland_jack: like the 3rd page
06:25:42 <Rarrikins> shiona: No. It belongs to the set of sites.
06:25:45 <anothernewhaskel> er DMcGill even
06:25:52 <anothernewhaskel> DMcGill: i decided to go to another site and try some exercises
06:25:59 <anothernewhaskel> DMcGill: http://www.haskell.org/haskellwiki/99_questions/1_to_10
06:26:02 <DMcGill> doesn't LYAH have exercises?
06:26:09 <anothernewhaskel> not as far as ive seen
06:26:15 <anothernewhaskel> then again i'm onloy on syntax in functions
06:26:18 <anothernewhaskel> only
06:26:20 <anothernewhaskel> im using hte online site
06:26:21 * haasn thinks anothernewhaskel ignored his messages :(
06:26:29 <DMcGill> it's very common for iterative coders to come to haskell any be frustrated that they can't do all the things they're used to
06:26:33 <anothernewhaskel> haasn: if you sent them before i reconnected i didnt see them
06:26:49 <anothernewhaskel> haasn: i was trying to use webchat on a phone and it wasnt working
06:26:55 <DMcGill> Those things can be done but they need to be done differently. And to do them, you need to start learning from scratch.
06:27:12 <anothernewhaskel> DMcGill: I've heard of side effects and stuff, and I'm fine with learning again
06:27:19 <DMcGill> I've seen a number of people say things like "ok so to learn Haskell I'm going to write a raytracer. I've written one in C and Java so I should be fine"
06:27:30 <Peaker> anothernewhaskel: What you know as "functions" from other languages is split into separate notions in Haskell: pure processing (functions) and effectful sequencing (IO).  So you still can do everything you did before, but you have to combine these two tools to do effectful processing. The benefit is that the types tell us much more about what kind of thing happens where
06:27:44 <anothernewhaskel> ah i see, so you cant have a function that does both processing and io?
06:27:49 <Peaker> anothernewhaskel: IOW, Haskell functions are actually functions! :-)
06:28:01 <anothernewhaskel> DMcGill: I'm not jumping in like that
06:28:04 <DMcGill> anothernewhaskel: io functions tend to call processing functions
06:28:05 <t7> DMcGill: well it is a nice functional problem
06:28:20 <haasn> anothernewhaskel: well, again, it's a meaningless question because there's no concept of control flow or I/O in haskell. Things don't get ‘done’, there is no ‘order’ to statements
06:28:23 <anothernewhaskel> DMcGill: i dont even know how to make a raytracer in java anyway :P im not a graphics programmer
06:28:29 <Peaker> anothernewhaskel: well, yeah, but it would be a function that returns an effectful program, e.g:  (Int -> IO String)  (function processing an Int into an effectful program that has a String result)
06:28:48 <DMcGill> like in the example case: we have reverseList which is processing, print which is IO and printAndReverse xs = print (reverseList xs) which does both
06:29:06 <anothernewhaskel> Peaker: IOW?
06:29:09 <Peaker> anothernewhaskel: it's not the function itself that does processing and IO, rather the function itself does processing and returns a value that describes the IO to be done
06:29:10 <anothernewhaskel> in other words?
06:29:13 <Peaker> anothernewhaskel: yeah
06:29:26 <DMcGill> note that all IO programs can do processing but it's considered good form to keep processing code out of IO
06:29:39 <anothernewhaskel> yea but that's generally true anyway
06:29:44 <anothernewhaskel> uhm
06:29:46 <Iceland_jack> anothernewhaskel: You should continue to read LYAH until you reach the chapter about I/O functions :)
06:29:47 <DMcGill> Haskell enforces this though
06:29:54 <DMcGill> hence why you can't print inside normal functions
06:30:06 <Iceland_jack> *actions
06:30:15 <Peaker> anothernewhaskel: well, most languages don't give you a separate tool for values that do pure mappings from one space to another (mathematical functions) and sequences of effectful instructions (procedures)
06:30:17 <anothernewhaskel> DMcGill: Iceland_jack so the problem is that because I'm *already* "returning" the reversed list, I can't then do something else as well
06:30:30 <DMcGill> pure functions don't "do" things
06:30:33 <DMcGill> they only return things
06:30:35 <Peaker> anothernewhaskel: having separate tools in Haskell means that when we see either one we know much more about it than when we see a "function" in some other language
06:30:37 <haasn> Like I said :{
06:30:50 <haasn> :(, even. (this new keyboard layout is confusing)
06:30:51 <anothernewhaskel> haasn: i did see what you said sorry
06:30:54 <DMcGill> anothernewhaskel: LYAH will answer all your questions :)
06:31:03 <anothernewhaskel> haasn: theres a lot of text and webchat is crap
06:31:28 <anothernewhaskel> DMcGill: =/ I wanted to do some simple stuff before continuing
06:31:37 <DMcGill> give it another try in a few chapters!
06:31:37 <haasn> There's a lot of text because everybody has a different ideology on how to approach teaching purity and functional programming to a complete newcomer, myself included
06:31:46 <anothernewhaskel> DMcGill: turns out even reversing a list or checking if its a palindrome isnt simple
06:31:47 <haasn> anothernewhaskel: You don't need I/O to do simple stuff
06:32:00 <merijn> anothernewhaskel: Think of the = sign in haskell as an *actual* equals sign, you're stating that the function f applied to x is equal to the right handside of the = sign
06:32:05 <DMcGill> haasn: yeah :( see also the monad blog tutorial problem
06:32:22 <Iceland_jack> anothernewhaskel: It is quite simple
06:32:30 <haasn> anothernewhaskel: Just stick to the REPL (it's great! and LYAH really deserves to be updated to show how to use its more recent features) for now
06:32:30 <mauke> if you're in firefox, chatzilla might be better than webchat
06:32:32 <merijn> anothernewhaskel: Your problem is in the remark "continuing", continue from where? None of that code describes control flow
06:32:51 <Peaker> anothernewhaskel: pure mapping of input space to output space (math functions) get you very very far..  you can write almost your entire program only with these, and only glue stuff up together with some procedures (IO)
06:33:01 <haasn> Giving different people different colors also helps with the amount of text, significantly. :)
06:33:07 <DMcGill> at least nobody here has suggested using trace yet :)
06:33:08 <merijn> anothernewhaskel: Did you mean "I want to do something with the returned list and return the result of that"?
06:33:53 <anothernewhaskel> so when I do (theHead:theList) = reverseList' theList ++ [theHead] I'm saying what?
06:33:59 <acomar> anothernewhaskel: wanting to solve some exercises is a good place to start, but the only way to get through them is to pretend you're learning to write code from scratch for a little while. Mimic what LYAH does, and try to modify, etc.
06:34:15 <acomar> anothernewhaskel: well, without a function name, nothing :)
06:34:23 <anothernewhaskel> http://pastie.org/8372093
06:34:31 <anothernewhaskel> @acomar:
06:34:32 <lambdabot> Unknown command, try @list
06:34:35 <anothernewhaskel> doh
06:34:45 <anothernewhaskel> I didn't want to trigger a bot
06:34:49 <Iceland_jack> anothernewhaskel: Do you know what (++) does?
06:34:56 <anothernewhaskel> adds it
06:34:59 <Iceland_jack> Right
06:35:08 <anothernewhaskel> i know what the right side does
06:35:12 <anothernewhaskel> and i know waht the left side does
06:35:14 <anothernewhaskel> but like
06:35:14 <acomar> anothernewhaskel: with a function name, you're saying "If I'm given a list that looks like (theHead:theList) then reverseList' is (reverseList' theList) added to [theHead]
06:35:15 <kwstas> hi there! I was looking the code of function Data.Char.IntToDigit. There are quite a few #-symbols like:.. (I#, >=#, 3#...). What exactly do they mean? Do they have some special meaning in Haskell or are they being used by some proprocessor?
06:35:20 <Iceland_jack> anothernewhaskel: The left side pattern matches
06:35:26 <merijn> anothernewhaskel: You're saying that "reverseList'" applied to a "non-empty list" is equal to the reverse of the remaining list with the head added behind it
06:35:45 <anothernewhaskel> acomar: how the heck does it know what (theHead:theList) looks like
06:35:47 <merijn> kwstas: Usually # refers to unboxed and/or primitive types
06:35:49 <anothernewhaskel> what does that even mean
06:35:54 <bearclaw> Being a noob I see his point, I need some IO, so I write a do-function returning IO foo. So caller must be a do function, and so on forever, it's not trivial to figure out good paterns to avoid putting all your code in do
06:36:06 <merijn> anothernewhaskel: It knows, because it's matching on the constructor
06:36:20 <merijn> anothernewhaskel: Let me try another approach, do you know C?
06:36:21 <anothernewhaskel> what constructor
06:36:22 <anothernewhaskel> merijn: I'm more familiar with java and ruby
06:36:27 <merijn> anothernewhaskel: The : is a constructor for lists
06:36:27 <anothernewhaskel> but done some c
06:36:45 <acomar> anothernewhaskel: There are two kinds of lists -- lists that look like x : xs and lists that look like []
06:36:50 <merijn> anothernewhaskel: All you need to know is structs and unions, is that within your realm of knowledge?
06:36:53 <DMcGill> bearclaw: if you write functions of type (a -> IO b) then you can chain them together in do-notation!
06:36:54 <acomar> anothernewhaskel: that's the implementation of singly linked lists
06:37:07 <anothernewhaskel> a struct is an object right?
06:37:15 <acomar> no :/
06:37:21 <Iceland_jack> This is just going to confuse anothernewhaskel
06:37:23 <anothernewhaskel> then no
06:37:23 <kwstas> merijn: Ok, it refers to them, but what does it mean? Is it something lang ! for strict evaluation?
06:37:25 <bearclaw> DMcGill: yes, but every intermediate function in my program ends up being a 'do'
06:37:32 <bearclaw> which sounds bad
06:37:33 <merijn> anothernewhaskel: Ok, nevermind that explanation, then :)
06:37:33 <DMcGill> bearclaw: another pattern is to seperate your pure functions (say, for example, reverse) from your IO - like do{list <- getLine; let rList = reverse list; print rList}
06:37:34 <Iceland_jack> All of this is covered in the first pages of LYAH
06:37:38 <merijn> kwstas: Yeah, ! is a strict field
06:37:39 <anothernewhaskel> i thought a struct was similar to an object
06:37:51 <anothernewhaskel> i've barely done any c
06:37:52 <Iceland_jack> which I suggest anothernewhaskel re-read
06:37:55 <bearclaw> DMcGill: yes that's vital, but it's tricky figuring out how
06:37:58 <acomar> structs define a type in terms of other types
06:38:01 <merijn> anothernewhaskel: Let's take a step back
06:38:02 <mauke> kwstas: # doesn't really mean anything but GHC uses it for its internal stuff
06:38:10 <anothernewhaskel> acomar: that's essentially an object
06:38:12 <Rarrikins> kwstas: All Ints are constructed with (I# unwrappedInt)
06:38:20 <anothernewhaskel> acomar: i define Employee as a collection of a string name and int id
06:38:25 <acomar> anothernewhaskel: no, there are several important differences :/
06:38:29 <DMcGill> bearclaw: that way you keep as many functions as possible pure. I.e. rather than having a function call readLine, perhaps have that function take a String? Then you can call readLine, pass the String to that function while that function stays pure
06:38:31 <Iceland_jack> @src genericLength -- anothernewhaskel: Do you understand this definition?
06:38:31 <anothernewhaskel> merijn: ok
06:38:31 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
06:38:31 <merijn> anothernewhaskel: Let's ditch the existing list and use this for now "data List a = Empty | Cons a (List a)"
06:38:44 <acomar> anothernewhaskel: it's very off topic for this channel so I'm going to avoid going there
06:38:54 <anothernewhaskel> Iceland_jack: er?
06:38:55 <kwstas> mauke, Rarrikins: oh! ok. I got it know... Thanks :)
06:39:00 <anothernewhaskel> merijn: data?
06:39:02 <Iceland_jack> anothernewhaskel: Never mind.
06:39:16 <anothernewhaskel> merijn: I dont think I've gotten that far yet
06:39:30 <acomar> anothernewhaskel: yea, this is going to be very difficult to follow till you get far enough in LYAH
06:39:33 <merijn> anothernewhaskel: hmm, what text are you reading then?
06:39:38 <anothernewhaskel> merijn: LYAH
06:39:42 <acomar> I promise your questions are covered in detail there, just stick with it for a while longer
06:39:47 <skittlez> If you have your own datatype:  data Rose a = a :> [Rose a] , how should you enter a rosetree as input into Ghci?
06:40:07 <merijn> anothernewhaskel: I suggest to keep reading then, I don't think any explanation of this stuff is going to make sense until you get to datatypes
06:40:09 <DMcGill> bearclaw: ideally in many programs that interact with the command line, you define your function over strings. It takes strings representing user input and returns the string that it should print. Then at the very top-level main you would read with readLine and print
06:40:23 <merijn> skittlez: "1 :> []"
06:40:24 <anothernewhaskel> acomar: =/ ok..I've been able to at least do simple stuff in other languages after a few pages, I really wanted to cement preludes, functions pattern matching etc with doing some excamples
06:40:38 <bearclaw> DMcGill: Yes, I think <$> is involved a lot in patterns that fix this issue :)
06:40:52 <acomar> skittlez: 5 :> [1 :> [], 2 :> [], 3 :> [], 4 :> []]
06:40:53 <anothernewhaskel> acomar: I work best like that
06:40:56 <DMcGill> anothernewhaskel: this is exactly what I was saying with learning Haskell involved going back to basics unfortunately
06:40:56 <merijn> anothernewhaskel: I don't think pattern matching will make a lot of sense without basic datatypes :)
06:41:09 <Iceland_jack> anothernewhaskel: Try to define "length" on your own, that is one of the simpler function definitions on lists
06:41:11 <anothernewhaskel> merijn: I've come across types
06:41:18 <acomar> anothernewhaskel: that's a fine approach, you just haven't gotten to a couple important concepts like abstract data types quite yet
06:41:23 <skittlez> Oh forgot the outer list, thanks :D
06:41:26 <bxc> any clues to what this "cabal: does not exist" message means? http://lpaste.net/93754
06:41:27 <DMcGill> bearclaw: are you familiar with what <$>/fmap does? It is indeed very useful in applying pure functions to values in IO :)
06:41:45 <anothernewhaskel> acomar: I see
06:42:03 <acomar> stick with it a little while longer
06:42:45 <anothernewhaskel> Uh...I was thinking about doing that Iceland_jack...was thinking that it would be something like stripping the head off the list and keeping count how many times you do that until you have an empty list left
06:42:52 <anothernewhaskel> Or is that completely bonkers
06:43:05 <Iceland_jack> anothernewhaskel: No that's kind of what you do
06:43:06 <acomar> that's correct sounding english :)
06:43:28 <Iceland_jack> anothernewhaskel: so if the list is empty, what is its length?
06:43:35 <anothernewhaskel> 0
06:43:35 <DMcGill> bearclaw: when you can't keep everything pure, the (a -> IO b), (b -> IO c) pattern is very common, done using (>>=) or do-notation. That way you keep things composable!
06:43:36 <haasn> except you don't have to ‘keep count’ of anything
06:43:53 <Iceland_jack> Right, and since the empty list is [] in Haskell we write:
06:43:53 <Iceland_jack>     length [] = 0
06:43:53 <haasn> that's the beauty of declarative code
06:43:59 <haasn> You say what things *are*, not how to get there
06:44:00 <acomar> anothernewhaskel: that definition looks like "length' [] = 0"
06:44:13 <bearclaw> DMcGill: I'm just starting to grasp that
06:44:24 <haasn> DMcGill: arrows :{
06:44:26 <haasn> :(, even
06:44:28 <anothernewhaskel> yea I got that far with it
06:44:30 <anothernewhaskel> I wasnt sure how to do the rest
06:44:34 <anothernewhaskel> cause I cant really do for loops
06:44:34 <merijn> anothernewhaskel: Essentially, in haskell you "know" that a list only has two constructors [] (for empty) or : (for at least one element), "f (x:xs) = x" says "if the list I'm looking at has at least one element, return the first element of that list"
06:44:44 <DMcGill> bearclaw: sometimes depending on your problem all your functions will be IO and every function will start with 'do'. That's just too bad.
06:44:50 <Iceland_jack> anothernewhaskel: OK, so in order to do the next step you need to understand what (x:xs) means
06:44:56 <DMcGill> haasn: you don't even need that thanks to (>->)
06:44:58 <anothernewhaskel> that means I assign the head to x
06:45:00 <anothernewhaskel> and the tail to xs
06:45:00 <Iceland_jack> yes
06:45:03 <Iceland_jack> let (x:xs) = "testing" in x
06:45:03 <Iceland_jack> let (x:xs) = "testing" in xs
06:45:05 <Iceland_jack> > let (x:xs) = "testing" in xs
06:45:07 <lambdabot>   "esting"
06:45:15 <anothernewhaskel> O.o
06:45:21 <anothernewhaskel> why so many pastas
06:45:24 <merijn> Iceland_jack: Might have wanted to use numbers
06:45:27 <DMcGill> haasn: err, (>=>)
06:45:31 <Iceland_jack> merijn: Maybe
06:45:31 <DMcGill> which is Kleisli composition anyway
06:45:41 <DMcGill> but it's specified for monads
06:45:52 <Iceland_jack> anothernewhaskel: So if you have a list that isn't empty
06:45:59 <Iceland_jack> but you have its tail, how do you find how long it is?
06:46:09 <acomar> anothernewhaskel: so you have the first element of the list, and the rest of the list -- how can you figure out the length of that list?
06:46:44 <Iceland_jack> So we have:
06:46:44 <Iceland_jack>     length (x:xs) = …
06:46:45 <acomar> (it's very similar to the reverse function you defined)
06:46:46 <anothernewhaskel> whilst the list is not empty, strip head, count++?
06:46:59 <bearclaw> http://lpaste.net/93755 <--how my brain figured out the callback <$> do_io if you're interested
06:47:02 <acomar> anothernewhaskel: think definitionally, not imperatively
06:47:14 <anothernewhaskel> ok one min then
06:47:17 <anothernewhaskel> let me think this
06:47:27 <Iceland_jack> anothernewhaskel: Sure
06:47:27 <acomar> anothernewhaskel: you're defining the value of the function for a given input, not telling the computer how to compute it
06:47:38 <haasn> DMcGill: yes, yes, I meant “we should all be using arrows, not monads!”
06:48:04 <mauke> there's a fairly mechanical transformation from loops with local variables to recursion
06:48:12 <DMcGill> haasn: I suppose Arrows is a much less scary word than Monad. I suppose it on that basis alone!
06:48:18 <mauke> so you could write pseudocode with a counter, then translate it to haskell
06:48:24 <haasn> DMcGill: hehe, yes
06:48:37 * haasn is scared of a world in which the “arrow tutorial fallacy” might exist
06:49:24 <anothernewhaskel> Iceland_jack: acomar ugh I dont know =/
06:49:33 <Iceland_jack> anothernewhaskel: What is the length of the tail?
06:49:42 <anothernewhaskel> length of the list - 1
06:49:58 <Iceland_jack> well.. we don't know the length of the list :)
06:50:02 <Iceland_jack> that's what we're trying to compute
06:50:13 <DMcGill> bearclaw: exactly. You define all your functions on a pure String or Bytestring, get an impure string or bytestring in a do-block and then use <$>!
06:50:15 <acomar> anothernewhaskel: ok, so what's the length of the list, knowing that? you're very close
06:50:22 <DMcGill> bearclaw: like: length <$> getLine
06:50:28 <acomar> anothernewhaskel: what's the length of the head?
06:50:33 <anothernewhaskel> acomar: 1
06:50:43 <anothernewhaskel> length of the list - length of the head
06:50:45 <Iceland_jack>     length (x:xs) = 1 + …
06:50:46 <anothernewhaskel> ?
06:50:55 <Iceland_jack> anothernewhaskel: other way arount :)
06:51:05 <DMcGill> bearclaw: wait until you find out about <*> ;)
06:51:05 <acomar> you're defining length of the list, not length of the tail
06:51:20 <Iceland_jack> *around
06:51:22 <anothernewhaskel> length (x:xs) = 1 + length xs ?
06:51:27 <Iceland_jack> right
06:51:27 <DMcGill> bearclaw: (,) <$> getLine <*> getLine :: IO (String, String)
06:51:27 <Iceland_jack> exactly.
06:51:29 <acomar> yep!
06:51:38 <anothernewhaskel> right
06:51:41 <anothernewhaskel> that makes total sense now ive written it
06:51:48 <Iceland_jack> So the entire definition of length is:
06:51:49 <Iceland_jack>     length []     = 0
06:51:49 <Iceland_jack>     length (x:xs) = 1 + length xs
06:51:49 <acomar> it usually does :)
06:51:49 <anothernewhaskel> dunno why i couldnt make that happen
06:51:52 <anothernewhaskel> yea
06:51:55 <anothernewhaskel> thats what ive got
06:51:59 <Iceland_jack> anothernewhaskel: It's a different way of viewing problems
06:52:10 <Iceland_jack> it takes time to adjust, but it will feel natural in no time
06:52:28 <anothernewhaskel> it feels like a step above what i've been doing
06:52:34 <anothernewhaskel> like...im defining the definitions of functions
06:52:39 <anothernewhaskel> rather than functions themselves
06:52:42 <acomar> that's exactly what you're doing
06:53:08 <anothernewhaskel> then haskell does all the pesky for loops or whatever
06:53:08 <anothernewhaskel> in its internal stuff
06:53:10 <DMcGill> anothernewhaskel: you're defining what functionare *are*, not what they *do*
06:53:13 <acomar> ^
06:53:15 <Iceland_jack> so anothernewhaskel, how would you define a list that "sums" all the numbers in a list?
06:53:21 <mauke> s/list/function/
06:53:24 <Iceland_jack> yes
06:53:32 <Iceland_jack> again, starting with the base case of the empty list
06:53:38 <anothernewhaskel> sum :: [a] -> b
06:53:41 <anothernewhaskel> sum [] = 0
06:53:54 <Iceland_jack> (wrong type by the way)
06:53:57 <anothernewhaskel> eh
06:54:01 <Iceland_jack> We can think of only using Int's for now :)
06:54:04 <Iceland_jack> to simplify
06:54:13 <DMcGill> 0 doesn't have type 'b', it has type 'Int'
06:54:13 <anothernewhaskel> i take a list and return a different type
06:54:14 <anothernewhaskel> oh
06:54:15 <anothernewhaskel> derp
06:54:30 <anothernewhaskel> sum (x:xs) = 1 + sum xs
06:54:32 <anothernewhaskel> ?
06:54:36 <DMcGill> yes!
06:54:36 <Iceland_jack> yes exactly
06:54:38 <haasn> no!
06:54:40 <DMcGill> wait
06:54:40 <Rarrikins> anothernewhaskel: Close.
06:54:41 <haasn> that's length
06:54:46 <Flonk> > 4+4
06:54:49 <lambdabot>   8
06:54:49 <Iceland_jack> oh hah
06:54:52 <Iceland_jack> yes, that's length :)
06:54:56 <anothernewhaskel> oops
06:55:02 <anothernewhaskel> 1 + sum x?
06:55:06 <Rarrikins> anothernewhaskel: You've got the break it apart and put it back together into the answer thing down, though.
06:55:14 <haasn> that doesn't even typecheck :(
06:55:29 <DMcGill> you need the sum of the head + the sum of the tail right?
06:55:29 <Iceland_jack> anothernewhaskel: Think about this problem a little more
06:55:31 <acomar> anothernewhaskel: you want to sum up the values of the list. the first value is x
06:55:39 <anothernewhaskel> er
06:55:40 <anothernewhaskel> humk
06:55:42 <anothernewhaskel> hum*
06:55:49 <ion> anothernewhaskel: Try evaluating it on paper or in your head with a concrete input list.
06:56:01 <ion> Say, [3,4,5]
06:56:11 <anothernewhaskel> sum (x:xs) = x + sum xs ?
06:56:15 <ion> bingo
06:56:45 <anothernewhaskel> hi noteventime :)
06:57:01 <Rarrikins> Can GHC automatically transform that to use an accumulator?
06:57:09 <DMcGill> hmm, is there a nice helper function for (\f g x -> g >> f x)?
06:57:13 <anothernewhaskel> ok cool thanks guys...I think this really helped me sort some stuff out
06:57:15 <opqdonut> Rarrikins: no
06:57:16 <DMcGill> something like (g >>) . f
06:57:19 <Rarrikins> Ahh
06:57:20 <acomar> as written, that wouldn't really help Rarrikins
06:57:23 <haasn> Rarrikins: no, because that would change the semantics (unless you do it lazily, which won't be any better)
06:58:15 <DMcGill> Rarrikins: this is why it's recommended to use the library functions rather than recurse yourself
06:58:23 <DMcGill> foldl' in this case
06:58:37 <DMcGill> for strict, and foldr for lazt
06:58:46 <Rarrikins> DMcGill: Ahh, I see.
06:59:18 <anothernewhaskel> areListsEqual :: [a] -> [a] -> (Boolean b)
06:59:20 <DMcGill> so sumLazy xs = foldr (+) 0 xs and sumStrict xs = foldl' (+) 9 xs
06:59:21 <anothernewhaskel> is that correct?
06:59:30 <anothernewhaskel> for a function checking if 2 lists are equal
06:59:36 <Rarrikins> anothernewhaskel: It's just Bool for the last one.
06:59:41 <anothernewhaskel> ah
07:00:02 <DMcGill> anothernewhaskel: but now you're going to run into another problem
07:00:08 <Iceland_jack> anothernewhaskel: a also needs to be an instance of the Eq type class
07:00:11 <mauke> DMcGill: off by 9 error!
07:00:22 <DMcGill> mauke: :)
07:00:32 <anothernewhaskel> Iceland_jack: oh I was reading about that earlier in LYAH...
07:00:38 <anothernewhaskel> Ima go read it again
07:00:48 <Iceland_jack> Yes, that sounds like a good idea
07:00:54 <mauke> you could also write the code first and then ask ghci for its type
07:01:08 <mauke> (advanced haskelling trick)
07:01:11 <DMcGill> @pl \f g -> (g >>) . f
07:01:12 <Iceland_jack> lol
07:01:16 <lambdabot> flip ((.) . (>>))
07:01:16 <lambdabot> optimization suspended, use @pl-resume to continue.
07:01:18 <DMcGill> @pl \g f -> (g >>) . f
07:01:18 <lambdabot> (.) . (>>)
07:01:28 <anothernewhaskel> areListsEqual :: (Eq a) => [a] -> [a] -> (Bool b)
07:01:37 <Iceland_jack> anothernewhaskel: Why do you add a "b" there?
07:01:54 <anothernewhaskel> i thought that was what you did for a return value
07:01:58 <Iceland_jack> no
07:01:59 <ion> data Bool = False | True
07:02:03 <ion> data Maybe a = Nothing | Just a
07:02:04 <Iceland_jack> Bool suffices
07:02:13 <ion> data Either l r = Left l | Right r
07:02:13 <anothernewhaskel> ok
07:02:16 <DMcGill> you know the return type ahead of time, it's a Bool. You only add variables like 'a' or 'b' when you don't want to specify one
07:02:25 <anothernewhaskel> oh yes
07:02:28 <anothernewhaskel> right
07:02:28 <ion> Some examples of types with zero or more type parameters.
07:02:31 <Iceland_jack> You can't write things like "Bool Int"
07:02:41 <anothernewhaskel> Iceland_jack: yea i get it now
07:02:42 <anothernewhaskel> :D
07:02:43 <Iceland_jack> since Bool is a type in its own right
07:02:45 <Iceland_jack> :) good
07:02:51 <Sagi> if I create a class and a subclass and make some type an instance of the subclass, then why does it complain if I implement a method of class for that instance?
07:02:54 <DMcGill> so your list can have any elements in, as long as they can be compared for equality (the Eq a => [a]) but you're definitely going to return a Bool always.
07:02:58 <Sagi> shouldn't there be some kind of inheritance?
07:03:12 <mauke> Sagi: what?
07:03:15 <ion> sagi: Please pastebin the code.
07:03:18 <Rarrikins> Sagi: You have to do it in the instance declaration.
07:03:26 <Sagi> yeah, I did
07:03:33 <Sagi> I can pastebin it, sure
07:03:35 <Rarrikins> Sagi: Like instance Show String where show "" = ...
07:03:38 <acomar> sagi: it sounds like you're thinking of typeclasses as OO classes, but I might be wrong
07:03:40 <merijn> Sagi: No, there is no inheritance. A subclass is not a subclass like in OO, it is a costraint
07:03:42 <mauke> Rarrikins: ಠ_ಠ
07:03:52 <Rarrikins> mauke: I can't see what that is.
07:03:59 <mauke> a look of disapproval
07:04:00 <merijn> Rarrikins: look of disapproval
07:04:03 <Rarrikins> Oh
07:04:05 <Rarrikins> :(
07:04:19 <mauke> more like :-[
07:04:37 <ion> or D-:
07:04:56 <merijn> Sagi: "instance Show a => Show [a] where" doesn't mean 'inherit Show from a', it means "'Show [a]' ONLY IFF 'Show a'"
07:05:17 <ion> only if and only if
07:05:19 <merijn> It's a requirement
07:05:23 <Sagi> hmm
07:05:32 <merijn> ion: Typing is hard!
07:05:39 <Sagi> yeah, I think I was kind of thinking of it as OO
07:05:51 <Sagi> so, what if I do want some kind of inheritance behaviour?
07:05:52 <shiona> ion: I would consider it more like "only (if and only if)"
07:05:57 <Sagi> http://lpaste.net/1299687078346358784
07:06:14 <DMcGill> does this mean that with the Functor Monad change, you can't implement Functor in terms of ( >>=)? Or is recursion like that allowed?
07:06:25 <merijn> Sagi: What do you want to inherit?
07:06:31 <merijn> DMcGill: Recursion like that is allowed
07:06:33 <ion> dmcgill: It’s not recursion, and it is allowed.
07:06:38 <Sagi> merijn: the toRDF function
07:06:47 <Sagi> or at least the obligation to implement one
07:07:06 * hackagebot hS3 0.5.8 - Interface to Amazon's Simple Storage Service (S3)  http://beta.hackage.haskell.org/package/hS3-0.5.8 (GergelyRisko)
07:07:07 <merijn> DMcGill: As long as the >>= then doesn't use fmap internally, of course
07:07:10 <DMcGill> Well, dependency recursion? You can only use (>>=) to make yourself a functor if you're already a monad which means you're already a functor
07:07:28 <haasn> Sagi: toRDF is a method of RDFRep, not Group
07:07:28 <acomar> Sagi: if you're looking for inheritence in Haskell, I think you've got an XY problem... what are you really trying to do?
07:07:30 <Sagi> I wanted to use subclassing as a way to avoid having to provide instance declarations for each of these classes
07:07:40 <haasn> Sagi: you can't do that.
07:07:43 <mauke> Sagi: that's not how it works
07:07:46 <Sagi> :-)
07:07:47 <DMcGill> merijn: of course. Like the good old defaults for Eq, where x == y = not (x /= y) and x /= y = not (x == y)
07:07:50 <haasn> You have to provide all of the instance declarations, even if they're empty
07:07:54 <merijn> DMcGill: There is no ordering on typeclass instances, so there is no "already" something is a Functor instance or not, and how it's defined doesn't matter :)
07:08:17 <Sagi> hmm, so why is subclassing useful again? What's the normal use case?
07:08:21 <merijn> DMcGill: The fact that the Functor instance depends on the Monad one isn't relevant, as long as both are in scope
07:08:37 <DMcGill> Sagi: you only have to write (Monad m) => rather than (Monad m, Functor m) =>
07:08:47 <Sagi> oh
07:08:50 <haasn> DMcGill: (except you don't)
07:08:50 <Sagi> that's the only thing?
07:09:08 <merijn> Sagi: It isn't all that useful, it usually used for things like "instance Show a => Show (Maybe a) where" so you can use show on the value inside a Just
07:09:28 <Sagi> hmm okay
07:09:38 <Sagi> guess I'll just provide lots of instance declarations then
07:09:55 <haasn> perhaps you don't want a bunch of classes/instances in the first place
07:10:00 <merijn> Sagi: Isn't there a TH/Generic thing for what you want?
07:10:06 <DMcGill> Sagi: to avoid code bloat you can usually provide only the most powerful (Monad) and implement the rest in terms of it.
07:10:13 <Sagi> hmm
07:10:19 <ion> sagi: If you can provide me an instance of Show for “a”, i can provide you an instance of Show for “Maybe a”. That is, “instance (Show a) => Show (Maybe a) where …”
07:10:22 <Sagi> I'm starting to wonder whether I want classes at all.
07:10:28 <merijn> Sagi: Probably not
07:10:29 <Sculptor> yo
07:10:43 <merijn> Sagi: The better you get at Haskell, the less you use custom classes
07:11:00 <merijn> Sagi: Nowadays I mostly only use them for type level hackery, rarely for polymorphism
07:11:07 <merijn> And even there I'm replacing them with type families
07:11:22 <haasn> merijn used type families before it was cool
07:11:24 <DMcGill> hmm, I should probably read about type familes
07:11:29 <Sagi> I don't know what type families are
07:11:30 <Sagi> yeah
07:11:31 <Sagi> :-)
07:11:39 <DMcGill> any good resources or should I just look though haskellwiki and google scholar?
07:11:44 * Sagi googles
07:11:47 <haasn> classes serve a purpose
07:11:53 <merijn> DMcGill: Read the "Fun with Type Functions" paper
07:11:58 <merijn> DMcGill: Very readable
07:11:58 <acomar> merijn: I'm starting to view typeclasses as a type -> value function, where as type families are type -> type functions
07:12:03 <ion> sagi: For classes, e.g. “class Eq a => Ord a” means you must implement Eq methods for something in order to implement Ord methods for it.
07:12:20 <haasn> acomar: that's quite accurate. type classes *are* a way to associate values with types
07:12:36 <haasn> acomar: oh, but MPTCs+FunDeps change that a bit. You can have type -> type implications (like type families) with them
07:13:01 <Sagi> ion: ah, that's clear. Thanks
07:13:13 <acomar> hassn: I've avoided FunDeps for a very long time
07:13:25 <merijn> DMcGill: I'd make sure to be familiar with GADTs, phantom types and DataKinds before that, though. That's where most of my type family use comes from :)
07:13:38 <acomar> haasn: I'll look into them when I can't get the type family to do what I want :D
07:13:51 <haasn> I think they might even be equivalent
07:14:05 <haasn> Well, I think the new GHC 7.8 type families might even be *more powerful*
07:14:15 <DMcGill> merijn: yeah, I am. My TripleP was originally implemented as having a Phantom Kind param to indicate whether or not it contained a pointer but I took that out to have a more easily pastable code.
07:14:20 <ion> I heard their power level may be over 9000.
07:14:22 <Sagi> my use case is trying to come up with a Haskell representation of knowledge described in RDF. I figured it'd be more readable if I created data types for all the different 'classes' (classes as in UML class diagram).
07:14:40 <acomar> haasn: because you can declare closed type families?
07:14:46 <DMcGill> merijn: that way I had lots of functions that would work on both pointed and unpointed triples while others could specify which one they wanted!
07:14:47 <haasn> acomar: yes
07:15:01 <haasn> acomar: oh, but you can do that with OverlappingInstances
07:15:01 <haasn> sort of.
07:15:12 <acomar> you can?
07:15:18 <haasn> I think?
07:15:20 <acomar> oh
07:15:22 <DMcGill> instance Functor (TripleP a); instance Applicative (TripleP Unpointed); instance Comonad (TripleP Pointed) and such
07:15:31 <acomar> I think I know what you're talking about. It requires undecidable as well, right?
07:15:54 <DMcGill> well, instance a ~ Pointed => Comonad (TripleP a) but whatever
07:15:54 <merijn> DMcGill: Oh, then the fun with type functions stuff should be a breeze
07:16:23 <haasn> acomar: UndecidableInstances is needed for both undecidable MPTC/FunDeps and undecidable TypeFamilies
07:16:33 <haasn> I think they may even use the same logic
07:16:39 <acomar> yea, probably
07:16:52 * Sagi heads back to his code
07:16:54 <Sagi> thanks everyone
07:17:34 <anothernewhaskel> http://pastie.org/8372224 I don't think this is quite it but I know I'm like half way there
07:17:46 <anothernewhaskel> and there may be syntax errors :p
07:17:55 <anothernewhaskel> if someone could check that out for me
07:18:03 <anothernewhaskel> please :)
07:18:24 <nycs> well, the base case returns a list, and not a bool, and you dont perform any checks on x and y
07:18:25 <acomar> anothernewhaskel: yea, you have a few syntax errors. Also, you don't actually do anything with the heads of the two lists
07:18:36 <acomar> nycs: that's [] == [], not [] = []
07:18:56 <nycs> it's 10 am alright
07:18:57 <acomar> anothernewhaskel: another case to consider -- what if one list is shorter than the other?
07:19:05 <acomar> lol
07:19:07 <anothernewhaskel> areListsEqual (x:xs) (y:ys) = (x == y) || areListsEqual xs ys
07:19:07 <anothernewhaskel> ?
07:19:15 <haasn> || means ‘or’
07:19:19 <acomar> and, not or, but yes
07:19:21 <anothernewhaskel> er yes
07:19:41 <haasn> man, this is why I really wish we'd use (∧) and (∨) instead of these confusing operators
07:19:52 <anothernewhaskel> so if at any point they are not equal
07:19:55 <monoidal> anothernewhaskel: also remember about the case when one list is empty and the other is not
07:19:56 <DMcGill> haasn: c portability
07:19:56 <anothernewhaskel> that method will exit, right?
07:20:03 <anothernewhaskel> function*
07:20:04 <DMcGill> or familiarity perhaps
07:20:20 <haasn> DMcGill: ∧ and ∨ have probably been around for a lot longer than C :)
07:20:36 <haasn> (I'm only half-serious)
07:20:43 <DMcGill> anothernewhaskel: try it. If your function fails to case, the callthrough is for your program to crash
07:20:48 <chrisdone> at least we use /= and not !=
07:21:03 <haasn> pft, ≠
07:21:08 <DMcGill> I was going to say
07:21:10 * haasn needs to go learn him some agda
07:21:12 <DMcGill> now I want to start using unicode
07:21:13 <anothernewhaskel> http://pastie.org/8372235 parse error =/
07:21:18 <chrisdone> one step at a time, unicoders
07:21:39 <acomar> anothernewhaskel: like I said, you still have syntax errors
07:21:41 <haasn> anothernewhaskel: haskell isn't that smart, ufortunately
07:21:45 <DMcGill> haasn: unicode and the appropriate module imports (UnicodePrelude or something) will give you your ≠
07:22:03 <chrisdone> or an editor that doesn't suck
07:22:04 <anothernewhaskel> what are my syntax errors
07:22:07 <anothernewhaskel> GHCI doesnt say
07:22:08 <haasn> anothernewhaskel: you can't just say [] == [], == isn't an equality statement. It's an equality *test*
07:22:11 <haasn> it evaluates to a Bool
07:22:20 <haasn> [] == [] = True
07:22:23 <anothernewhaskel> oh
07:22:34 <monoidal> anothernewhaskel: != cannot be used to define a function. Define the two cases as False
07:22:46 <anothernewhaskel> monoidal: yea was just doing tha t:D
07:22:47 <anothernewhaskel> that*
07:22:56 <DMcGill> the syntax for defining a function is <name> <pattern> = <defn>
07:22:56 <haasn> areListsEqual [] [] = True -- if you want to use that name instead of (==)
07:22:58 <ion> sagi: If you want a function to be able to use, say, (+) on any number type, you *could* have a data type like “data Num a = Num { (+) :: a -> a -> a }” and method dictionaries like “numInteger :: Num Integer; numInteger = Num { (+) = integerPlus }; numDouble :: Num Double; numDouble = Num { (+) = doublePlus }”. Then functions can take an explicit dictionary as in “double :: Num a -> a -> a; double
07:22:59 <ion> numDict n = (+) numDict n n”. You can then have something like “main = printInteger (double numInteger 21)”. Haskell type classes are equivalent to that, except that dictionary passing is implicit.
07:23:21 <haasn> also what DMcGill said
07:23:37 <anothernewhaskel> haasn: doh yea
07:23:46 <DMcGill> see how both areListsEqual [] == [] and areListsEqual [] != (x:xs) don't fit that?
07:24:05 <anothernewhaskel> :D:D:D it works
07:24:17 <ion> sagi: The equivalent to that example using type classes would look like: “class Num a where { (+) :: a -> a -> a }; instance Num Integer where { (+) = integerPlus }; instance Num Double where { (+) = doublePlus }; double :: Num a => a -> a; double n = (+) n n; main = print (double 21)”
07:24:19 <anothernewhaskel> http://pastie.org/8372245
07:24:32 <anothernewhaskel> do i need the 3rd AND 4th line
07:24:49 <anothernewhaskel> seems a bit strange to define both ways around
07:24:51 <DMcGill> anothernewhaskel: good! Remember to replace || with && though
07:25:01 <acomar> anothernewhaskel: what if you wanted to do something funky when one list was longer than the other
07:25:02 <ion> anothernewhaskel: Try removing them and see what happens when you input lists of different lengths.
07:25:05 <DMcGill> anothernewhaskel: the symbol '_' can be used to match to anything
07:25:26 <DMcGill> so line 3 could be areListsEqual [] _ = False
07:25:27 <DMcGill> with me so far?
07:25:49 <anothernewhaskel> DMcGill: ah yes i remember this
07:25:55 <DMcGill> since you never refer to anything in the second list, you don't need to 1) check if it's got values or 2) name them
07:26:13 <haasn> DMcGill: you can also move them to the end and squash them into a single base case; areListsEqual _ _ = False
07:26:16 <haasn> err anothernewhaskel
07:26:22 <ion> anothernewhaskel: Btw, i recommend compiling with -Wall. That will warn about missing cases.
07:26:24 <DMcGill> haasn: I was getting to that :)
07:26:33 <chrisdone> needs  mooar all . zipWith (==) =p
07:26:53 <DMcGill> chrisdone: one step at a time
07:27:00 <chrisdone> DMcGill: "=p"
07:27:03 <ion> s/all/and/; s/\./.:/ :-P
07:27:04 <anothernewhaskel> wat
07:27:11 <anothernewhaskel> how does areListsEqual _ _ = False work
07:27:21 <chrisdone> ion: or all id
07:27:22 <anothernewhaskel> that would mean any two things that are compared is false
07:27:26 <anothernewhaskel> even things that are the same
07:27:31 <DMcGill> anothernewhaskel: that's why you apply it at the end
07:27:41 <DMcGill> first you check for two empty lists with f [] [] = ...
07:27:45 <monoidal> anothernewhaskel: haskell reads declarations top to bottom, that case is applied only if the previous two did not match
07:27:54 <anothernewhaskel> oh of course
07:27:57 <DMcGill> then you check for two non-empty lists with f (x:xs) (y:ys) = ...
07:28:08 <DMcGill> and anything else will just be false
07:28:13 <DMcGill> hence the f _ _ = False
07:28:14 <anothernewhaskel> makes sense
07:28:46 <anothernewhaskel> I've just thought, this is kinda like doing digital electronics
07:28:47 <ion> Btw, in this case the order of the [] [] case and the (x:xs) (y:ys) case doesn’t matter because neither will match a pair of values the other one will match.
07:28:57 <DMcGill> think of it like providing a default: in c/java style case statements
07:29:25 <DMcGill> although in this case there's no fallthrough so no need to put "break;" everywhere
07:29:35 <anothernewhaskel> DMcGill: that crap is annoying
07:29:39 <DMcGill> oh yes
07:30:04 <anothernewhaskel> I program in java mostly atm but I prefer ruby...it's a little bit more functionally oriented
07:30:23 <anothernewhaskel> Unfortunately not many companies do ruby
07:30:28 <acomar> o.O
07:30:32 <anothernewhaskel> ruby kinda brought me here
07:30:37 <DMcGill> anothernewhaskel: now you have your working program! But consider some library functions. zipWith :: (a -> b -> c) -> ]a
07:30:38 <chrisdone> acomar: shh
07:30:42 <acomar> lol
07:30:46 <DMcGill> anothernewhaskel: now you have your working program! But consider some library functions. zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
07:31:02 <DMcGill> see how zipWith (==) :: Eq a => [a] -> [a] -> [Bool]?
07:31:15 <acomar> anothernewhaskel: there are a lot of companies out there using ruby... it's one of the most popular languages in the world atm...
07:31:18 <DMcGill> since (==) has type Eq a => a -> a -> Bool
07:31:35 <anothernewhaskel> acomar: not anywhere near as many using java
07:31:36 <DMcGill> @src zipWith
07:31:46 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
07:31:47 <lambdabot> zipWith _ _      _      = []
07:32:03 <acomar> anothernewhaskel: true, but if you're into webdev, there are countless ruby jobs
07:32:10 <DMcGill> then once you have a [Bool], you can use the library function all :: [Bool] -> Bool
07:32:12 <anothernewhaskel> acomar: im doing webdev atm
07:32:16 <DMcGill> > all [True, True]
07:32:20 <lambdabot>   Couldn't match expected type `a0 -> GHC.Types.Bool'
07:32:21 <lambdabot>              with actua...
07:32:24 <DMcGill> > and [True, True]
07:32:24 <lambdabot>   True
07:32:29 <anothernewhaskel> acomar: love mah RoR
07:32:53 <DMcGill> anothernewhaskel: so allEqual xs ys = and (zipWith (==) xs ys)
07:33:44 <acomar> DMcGill: typo :) I think you mean all, not and
07:33:48 <monoidal> acomar: no, and
07:33:50 <ion> acomar: He means and.
07:33:58 <acomar> ack, I missed something
07:34:02 <DMcGill> acomar: all :: (a -> Bool) -> [a] -> Bool
07:34:06 <monoidal> DMcGill: though if lists are of different lengths...
07:34:09 <DMcGill> and :: [Bool] -> Bool
07:34:23 <DMcGill> monoidal: oops, you're quite right
07:34:59 <DMcGill> anothernewhaskell: in this case the correct solution is the fact that if Eq a, then there is an instance for Eq [a]
07:35:03 <ion> If we’re going with library functions… areListsEqual :: (Eq a) => [a] -> [a] -> Bool; areListsEqual = (==)
07:35:14 <alpounet> and = all id
07:37:46 <FreeFull> > [3,4] == [3,4]
07:37:46 <lambdabot>   True
07:37:48 <FreeFull> > [3,4] == [3,4,5]
07:37:48 <lambdabot>   False
07:37:54 <quchen> ion: That's not the same function though, the zip-based one will yield a different result if the lists are of unequal length
07:38:06 <ion> quchen: That was a bug in the zip-based version.
07:38:12 <quchen> Oh. Nevermind then.
07:44:21 <applicative> oh quchen here is haxl done right http://lpaste.net/93757
07:44:36 <applicative> sorta
07:44:43 <quchen> Umm okay
07:45:01 <anothernewhaskel> DMcGill: didn't realy understand that zip stuff but ok :p
07:45:28 <DMcGill> anothernewhaskel: you'll get used to it. It's mostly about using library functions to encode your recursion for you.
07:45:38 <DMcGill> I wouldn't sweat it right now.
07:45:39 <quchen> applicative: Could you provide an abstract? "Marlow violated the Applicative laws for brevity in his talk"?
07:45:57 <applicative> no he didn't violate the laws
07:46:12 <anothernewhaskel> laws?
07:46:13 <applicative> that's the point
07:46:17 <quchen> Didn't you show that yesterday, ap /= <*>?
07:46:29 <anothernewhaskel> O.o
07:47:11 <applicative> his implementation of Applicative, taken by itself, is valid
07:47:44 <applicative> it's the applicative class that's wrong, to put it crudely ;)
07:47:57 <quchen> "ap /= <*>" means it's not a valid Applicative+Monad.
07:48:12 <anothernewhaskel> im just gonna ignore this stuff for now :p
07:48:35 <ion> anothernewhaskel: There are laws some constructions must follow so that us programmers can reason about them. For instance, you would expect (map (+1) . map (+2)) [0..10] == map ((+1) . (+2)) [0..10] and map id [0..10] == id [0..10]
07:48:37 <quchen> anothernewhaskel: It's not strictly beginner talk, no. :-)
07:49:14 <chrisdone> anothernewhaskel: if you think this is weird you should see when #haskell really gets its nerd on
07:49:24 <anothernewhaskel> chrisdone: I've lurked here a few times
07:49:26 <ion> anothernewhaskel: As a simpler example, you would expect that a + b == b + a
07:49:28 <applicative> quchen: the functor in question is 'laxly monoidal' in more than one way
07:49:31 <anothernewhaskel> chrisdone: I almost never understand any of it
07:49:35 <chrisdone> :D
07:49:37 <anothernewhaskel> ion: sure
07:49:43 <quchen> applicative: Yes.
07:49:49 <chrisdone> that's what's so fun about #haskell
07:49:53 <anothernewhaskel> :p
07:49:59 <int-e> nobody has brought up hylomorphisms yet.
07:50:06 <quchen> applicative: Nevertheless his Monad doesn't match that Applicative, but this is demanded by the Applicative laws.
07:50:19 <int-e> @quote category
07:50:19 <quchen> applicative: It's like having a ZipList Applicative but a List Monad by default.
07:50:19 <lambdabot> kmc says: Zagen, you'll need a zygohistomorphic prepromorphism from the bifunctorial Kleisli category of username-password pairs to a combinatory arrow calculus of php scripts
07:51:13 <anothernewhaskel> O.O
07:51:14 <applicative> quchen: yes, this is a defect of the Applicative class, as can be seen from the (slightly) more sensible class in the paste
07:51:33 <acomar> anothernewhaskel: if it helps, that one is a joke
07:51:42 <ion> anothernewhaskel: In this case, the expectation is that something you can ignore for now called (<*>) is the same as something you can ignore for now called ap.
07:52:13 <quchen> applicative: Stop moving goalposts. Your assertion that "it does not violate the Applicative laws" is *wrong*.
07:52:53 <anothernewhaskel> ion: I was more O.O 'ing at the @quote category :p
07:53:00 <applicative> it is consistent with them if there is no monad instance declared, but suddenly inconsistent if a monad is declared ;)
07:53:04 <carado> Hi. How can I separately "instance (A a, B b) => D (a,b)" and "instance (A a, C c) => D (a,c)" ? ghci tells me that I have duplicate instance declarations
07:53:15 <ion> anothernewhaskel: Aye, i was still responding to the “laws?” question. :-)
07:53:19 <Rylee> is there a .ghcirc or something that i can use to automatically set the default prompt in ghci?
07:53:19 <quchen> applicative: Yes.
07:53:19 <applicative> this is an amusing logic
07:53:42 <ion> rylee: ~/.ghci
07:53:48 <merijn> Rylee: Yes, ".ghci" :)
07:53:53 <quchen> applicative: Typically you would want that law to read "if there is a Monad definable for that type the Applicative has to match it", but the wording is a little lax in that respect.
07:54:01 <merijn> Rylee: You can also specify imports there :)
07:54:32 <chrisdone> carado: instance resolution of classes doesn't care about the constraints applied to your instance declaration, so adding them is only of use for your implementation of the instance, it doesn't help resolve that instance later
07:54:32 <Rylee> thank you!
07:54:33 <quchen> applicative: Also, if that was the law, then writing an Applicative without a Monad when you don't need the Monad would violate the laws, also not a good idea.
07:54:48 <ion> echo ':set prompt "H̑̊ͣ̏ͪ̋ͨͮ͋̆A̓̍͂͌̓̄͒̿͌̚S͊̾̃̎͏̷̧̠̤͘K̶̸̲̅̌̈́̃̊̚͢E̡̩͕̣̳͓ͤ̊͂ͩL̂͛̉ͬ̓͐ͯ͌͠͠L̆̍ͮ̐̽̌̌ͪ̓ͥ ̑ͩ̄ͧͧ̀́͆͊̈́H͋͊́ͫ̓̍̆̇͐̚E͛̓ͥ̄͊̀̽ͯ͊̄ ͧ̋͊̓ͪ́̏͑ͬ̈́C̅̄̂͒̉̈́͌̂ͫ́O͛̂͒ͪ͐̓̎̊͊̚M̎̾̄̽͊ͣ́͋̎̆Ẽ̜̠̦̺́̈̉̕͞S̛̈́͋͋ͬͤ̿͒͘͘>ͨ͛̔̉́ͤ́͗͗̂ "' >>~/.ghci  #
07:54:50 <ion> http://heh.fi/tmp/ghci-prompt.png
07:54:51 <quchen> That said, my answer to this will be "newtype".
07:54:54 <applicative> what is the law
07:55:04 <merijn> Rylee: Time to specify "import Control.Applicative" and all those other annoying ones you *always* end up importing ;)
07:55:13 <Rarrikins> carado: It won't do that, since what would happen if some type were both B and C?
07:55:20 <anothernewhaskel> ion: that printed some funky characters on my screen
07:55:24 <applicative> the law could only be 'if it is possible for there to be a monad instance then ...', which would rule out ZipList
07:55:45 <carado> Rarrikins, oh, right. hadn’t though about that.
07:56:08 <Rarrikins> carado: But what chrisdone said is a bit more accurate.
07:57:11 <quchen> applicative: The law could be "If a Monad is defined for an Applicative, ap=<*>pure=return". Right now the law is backwards because history.
07:57:42 <applicative> yes, my paste has this law as a definition ;)
07:58:08 <applicative> you are relying on a remark in the documents
07:58:16 <applicative> other remarks in the documents are transparently false
07:58:26 <applicative> e.g. that <*> means 'sequential application'
07:58:34 <applicative> which is the haddocked comment
07:59:25 <quchen> Send a patch.
07:59:45 <quchen> Or take "sequential" with a grain of salt.
07:59:55 <quchen> Of course it's not sequential when you're using the Concurrently Applicative.
08:00:04 <applicative> or ziplist
08:00:22 <applicative> and on and on for all tree types
08:00:55 <quchen> So call it "lifted application" or something?
08:01:02 <quchen> Would go well with liftA2 ($).
08:01:10 <applicative> yes, idiomatic application
08:01:37 <applicative> the idea is the application can be lifted
08:01:54 <applicative> which corresponds to the lifting of products
08:01:58 <quchen> That would probably be a better name here, yes.
08:02:05 <ocharles> ion: nice prompt
08:02:40 <haasn> that's how I write all my lens code
08:03:11 <carado> is there by any chance a "Natural integer" type in haskell, like Integer but with only positive values ?
08:03:23 <applicative> calling it sequential application basically means calling it monadic application, i.e. 'ap'
08:03:28 <haasn> carado: not built-in, there's a library that defines it (by using Integer internally)
08:03:43 <geekosaur> not to mention all the type level nats :p
08:03:44 <haasn> carado: http://hackage.haskell.org/package/naturals-0.2.0.2/docs/Data-Natural.html
08:03:51 <haasn> sort of
08:03:53 <carado> thank you.
08:03:59 <haasn> I'm sure there are a billion other libraries
08:04:06 <haasn> search ‘nat’ or ‘natural’ on hackage :)
08:04:11 <quchen> applicative: The Monad instance isn't necessarily sequential as well. Consider the backwards state Monad, in which m >>= f evaluates the state of f first, and then m.
08:04:30 <quchen> … in case "sequential" means "from left to right" here.
08:04:39 <haasn> oh, and it has NaN
08:04:49 <applicative> quchen: yes, of course that's right
08:04:50 <chrisdone> carado: fwiw, you can demonstrate it for yourself with this simple example:
08:04:50 <chrisdone> carado: class C a where foo :: C a => a -> String -- trivial class
08:04:50 <chrisdone> carado: data A a = A a; instance Show a => C (A a) where foo (A i) = show i -- now you implement an instance of the class for `A a', you add a constraint so that you can use show in the implementation
08:04:50 <chrisdone> carado: data Z = Z; demo = foo (A Z) -- then you call it with A Z. what happens? ghc sees that `A a' matches up with your C (A a) instance and chooses that. *then* it tries to type check the show (A Z) call -- but will error because Z doesn't have an instance of Show.
08:05:57 <chrisdone> carado: in fact another way of looking at it is that: instance Show a => C (A a) where foo (A i) = show i    is like    instance C (A a) where foo :: Show a => A a -> String; foo (A i) = show i
08:08:15 <ski> quchen : in an abstract sense, it is sequential
08:08:48 <ion> haasn: I did nat see that coming.
08:08:49 <ski> (similarly to how in Prolog `foo,bar', `foo' is executed before `bar' -- still the issue of backtracking complicates the "dynamic time" of this)
08:08:54 <chrisdone> (though class contexts do actually have meaning, specially in unification)
08:09:13 <carado> uh, i’m not sure I follow.
08:09:21 <quchen> ski: Not sure in what sense you mean that. Just because (a -> b) needs "a" and then applies it to the function?
08:09:35 <carado> in my example, A, B and C were all classes, I should have mentionned that
08:10:18 <carado> i’m trying to build Countable and InfiniteCountable classes
08:10:52 <carado> and the way of handling a (Countable,InfiniteCountable) pair is not the same as handling a (Countable,Countable) pair
08:11:06 <carado> and the way of handling a (Countable,InfiniteCountable) pair is not the same as handling an (InfiniteCountable,InfiniteCountable) pair*
08:11:30 <carado> even though the both result in an InfiniteCountable (a,b) pair.
08:12:00 <applicative> a monad instance is basically a specification of a sense of 'sequential' though it can go against other ways of applying the word to the material.
08:12:06 <ski> quchen : i distinguish between "static sequentiality" and "dynamic sequentiality", the latter having to do with data dependencies and order of evaluation
08:12:07 <carado> http://lpaste.net/93758
08:12:59 <nwf> Are there videos of Greg Morrisett's introduction for SPJ's talk last Thursday?  I want to make a coworker laugh. :)
08:13:07 <ski> (and the former having more to do with the syntactic form and shape of the code and the types (when structured as monadic layers))
08:13:37 <quchen> Ah, okay.
08:14:07 <quchen> That's kind of what my gut told me, only that you know the right words :-)
08:16:07 <applicative> @type join . join . join
08:16:07 <lambdabot> Monad m => m (m (m (m a))) -> m a
08:16:20 <chrisdone> @type fmap fmap fmap
08:16:22 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
08:16:35 <mauke> :t join`fmap`join`fmap`join
08:16:35 <lambdabot> Monad m => m (m (m (m a))) -> m a
08:16:42 <chrisdone> :D
08:16:57 <haasn> very join
08:17:08 <haasn> or perhaps, enthusiastically join
08:17:15 <ski> quchen : well .. i made up the words on the spot here, actually ;)
08:17:24 <applicative> so there is a sort of order or succession built into the monad idea
08:17:32 <ski> i think so, yes
08:17:47 <ski> (or at least, that's a useful angle from which to look at it)
08:18:20 <ski> in `join . join . join :: Monad m => m (m (m (m a))) -> m a' you in some sense has to interpret the outermost `m' layer before being able to get at the two inner ones
08:18:38 <FreeFull> You can think of monads as manipulating a data structure
08:19:09 <ski> hence, in `ma >>= amb = join (fmap amb ma)' executing `join' will first executing the `m' layer from `ma :: m a', and secondly the `m' layer from `amb :: a -> m b'
08:19:22 <quchen> Speaking of weird type signatures,
08:19:22 <quchen> (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
08:19:22 <quchen> seems to be a fixed point for repeated application of `flip`, starting at `flip flip flip flip`.
08:19:33 <quchen> Can someone explain this magic? :-)
08:19:48 <ocharles> @djinn (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
08:19:48 <lambdabot> f a b = a b (\ c d e -> c e d)
08:19:59 <ocharles> er
08:20:00 <FreeFull> > flip flip
08:20:01 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable c0)
08:20:01 <lambdabot>    arising from a use ...
08:20:05 <FreeFull> :t flip flip
08:20:05 <lambdabot> b -> (a -> b -> c) -> a -> c
08:20:09 <FreeFull> :t flip flip flip
08:20:09 <lambdabot> (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
08:20:13 <FreeFull> :t flip flip flip flip
08:20:13 <lambdabot> (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
08:20:17 <FreeFull> :t flip flip flip flip flip
08:20:18 <lambdabot> (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
08:20:25 <ion> freefull: THANKS
08:20:37 <FreeFull> I was proving quchen right
08:20:38 <ocharles> you've found the flipped-point!
08:20:43 <beaky> hello
08:20:51 <chrisdone> flipping doesn't create arguments it doesn't need to
08:20:56 <applicative> i think if there were rotate f a b c = rotate f b c a, it would have different fixed point
08:21:12 <beaky> http://lpaste.net/93760 how do I improve my script to find long lines in a file?
08:21:20 <Sagi> I think I'm going mad. how do I compose a function with type a -> b -> c with a function that does c -> d to obtain a -> b -> d?
08:21:40 <chrisdone> :t (.:)
08:21:40 <lambdabot>     Not in scope: `.:'
08:21:40 <lambdabot>     Perhaps you meant one of these:
08:21:40 <lambdabot>       `.' (imported from Data.Function),
08:21:46 <chrisdone> -_-
08:22:18 <applicative> haha, rotate has rotate rotate rotate rotate rotate :: a
08:22:22 <chrisdone> :t (subtract 5 .) . (+)
08:22:23 <lambdabot> Num c => c -> c -> c
08:22:29 <FreeFull> @pl let compose f g = \x y z -> f x y (g z)
08:22:30 <lambdabot> (line 1, column 40):
08:22:30 <lambdabot> unexpected end of input
08:22:30 <lambdabot> expecting variable, "(", operator, ";" or "in"
08:22:32 <ski> applicative,quchen : of course, in monads that are "commutative" (meaning `flip (liftM2 (,)) = liftM2 (flip (,))'), this apparent ordering actually disappears because you can reorder
08:22:32 <FreeFull> @pl let compose f g = \x y z -> f x y (g z) in compose
08:22:36 <lambdabot> id (fix (const (flip . (flip .) . (((.) .) .))))
08:22:36 <lambdabot> optimization suspended, use @pl-resume to continue.
08:22:49 <FreeFull> :tlet compose f g = \x y z -> f x y (g z) in compose
08:22:51 <FreeFull> :t let compose f g = \x y z -> f x y (g z) in compose
08:22:53 <lambdabot> (t1 -> t2 -> t3 -> t) -> (t4 -> t3) -> t1 -> t2 -> t4 -> t
08:23:07 <ski> @let infixr 9 .:; (.:) = (.) . (.)
08:23:09 <lambdabot>  Defined.
08:23:14 <FreeFull> Woops, too many arguments
08:23:22 <FreeFull> :t let compose f g = \x y -> f x (g y) in compose
08:23:23 <lambdabot> (t1 -> t2 -> t) -> (t3 -> t2) -> t1 -> t3 -> t
08:23:28 <ski> Sagi : `g .: f :: a -> b -> d', with `f :: a -> b -> c' and `g :: c -> d'
08:23:30 <quchen> Sagi: There's no built-in combinator to do that. But chrisdone mentioned (.:), which ski just defined in the @let above. That one does what you want.
08:23:49 <FreeFull> Oh, I was doing it the wrong way around
08:23:59 <quchen> Sagi: You can also write your composition function explicitly though, "foo f g x y = g (f x y)" for example.
08:24:01 <FreeFull> :t let compose f g = \x y -> g (f x y) in compose
08:24:02 <lambdabot> (t2 -> t3 -> t1) -> (t1 -> t) -> t2 -> t3 -> t
08:24:02 <chrisdone> FreeFull: next time experiment in /msg or something =)
08:24:09 <FreeFull> Ok, ok, I'll stop
08:24:10 <haasn> @@ Sagi @hackage pointless-fun
08:24:10 <lambdabot>  Sagi http://hackage.haskell.org/package/pointless-fun
08:24:15 <ski> it's not that hard to derive the definition of `(.:)' is you really want to
08:24:15 <Sagi> hmm
08:24:48 <quchen> ski: Easy to derive, hard to understand why it works though. ;-)
08:24:59 <ski> (i invented `(.:)' some odd years ago)
08:25:00 <Sagi> I was looking to simplify a definition and had the feeling that I should be able to do something related to pointfree. But now I'm not sure if the above actually increases readability :-)
08:25:22 <ski> the idea is that we'll also have `(.::) = (.) . (.) . (.)' and so one ..
08:25:36 <t7>  (a -> b) -> ((a -> b) -> c -> d) -> c -> d         how is that a valid sig
08:25:40 <haasn> .:.
08:25:48 <FreeFull> t7: Why wouldn't it be?
08:25:51 <haasn> and then (.).(.).(.).(.) would be .::
08:25:59 <t7> (a -> b) ->c -> d    is impossibru
08:26:00 <haasn> the number of dots would be the same!
08:26:13 <ski> haasn : the idea was that the number of dots would agree
08:26:15 <FreeFull> t7: But it isn't (a -> b) -> c -> d
08:26:31 <ski> haasn : so `(.).(.).(.).(.)' is then clearly `(.:::)', not `(.::)'
08:26:38 <t7> oh yeah i keep thinking its foralls
08:26:42 <t7> my bad
08:26:43 <FreeFull> Well, the second argument can be any function where a,b,c,d get substituted for something else
08:26:44 <applicative> somehow even .: (+) is just as unreadable as (even.) . (+)
08:26:45 <haasn> ski: oh, right, because of the ones in between
08:26:46 <FreeFull> Yeah
08:26:47 <haasn> ski: makes sense!
08:27:23 <FreeFull> applicative: In a concatenative language it'd just be   + even
08:27:28 <beaky> is sed or awk or perl faster than haskell for that script?
08:27:44 <applicative> even .:: foldr is even worse
08:27:47 <FreeFull> beaky: What script?
08:27:50 <ski> haasn : you can also say that the number of characters (both the `.' and the `:'s) in the operator name corresponds to the number of "arguments to pass to the right argument function"
08:27:54 <beaky> FreeFull: http://lpaste.net/93760
08:28:27 <haasn> ski: yes
08:28:59 <ski> (or s/pass/pass along/)
08:29:11 <FreeFull> beaky: Faster to write or faster when executed?
08:29:27 <beaky> faster when execute
08:29:41 <haasn> applicative: I think .: is quite readable, since I know what it does
08:29:50 <FreeFull> beaky: You'd have to benchmark to find out
08:29:56 <haasn> applicative: it's just a familiarity thing
08:30:06 <applicative> it's more readable than the other, i agree, I take it back
08:30:08 <haasn> I find it almost more readable than \x -> even . (+) x
08:30:20 <applicative> haha
08:30:45 <mauke> perl -nle 'print "$ARGV: $.: $_" if length() > 79'
08:31:15 <applicative> beaky: I think we could write a faster haskell version with something other than [String]
08:31:32 <beaky> ah
08:31:34 <applicative> does the perl count actual 'unicode characters'?
08:31:38 <beaky> ok I will use data.text and overloadedstring
08:31:53 <ion> With something like -Mutf8 -CS or whatever it probably does.
08:32:08 <mauke> applicative: depends
08:32:20 <mauke> I have PERL_UNICODE=SAL in my environment, so it does here
08:32:32 <mauke> -Mutf8 has no effect here
08:32:41 <mauke> your source code contains no unicode
08:33:05 * ion is cargo cult ircgramming Perl
08:33:31 <applicative> mauke: by a strange accident the file i tried it on contained the line -: 77: http://acis.openlib.org/dev/perl-unicode-struggle.html}\label{binmode-stdout-utf8-c.f.-httpacis.openlib.orgdevperl-unicode-struggle.html}
08:33:46 <mauke> hah
08:34:02 <arnsholt> mauke: For all things Perl and Unicode, see: http://www.perl.com/pub/2012/04/perlunicook-standard-preamble.html
08:34:29 <mauke> arnsholt: no, thanks
08:34:42 <arnsholt> And all the other prescriptions
08:35:12 <mauke> also, I'm pretty sure you don't want :utf8 as your decoding layer
08:35:20 <applicative> oh i know where it came from; i ran markdown.pl on markdown.pl ....
08:35:41 <applicative> no, it must be pandoc -r markdown -w latex markdown.pl ;)
08:35:56 <mauke> 'use strict;' is 100% redundant there
08:35:57 <anothernewhaskel> why is Num not a subclass of Ord?
08:35:59 * mauke rolls eyes
08:36:03 <anothernewhaskel> surely numbers can be ordered
08:36:06 <mauke> anothernewhaskel: complex numbers can't
08:36:10 <anothernewhaskel> oh
08:36:11 <anothernewhaskel> yea
08:36:23 <anothernewhaskel> true that :p
08:36:40 <applicative> anothernewhaskel: but note that here there is an answer; many similar questions about the Num class will have no answer ;)
08:36:56 <mauke> anothernewhaskel: also, functions can be an instance of Num
08:37:01 <mauke> can't compare functions
08:37:07 <beaky> are bytestrings faster than text
08:37:27 <applicative> beaky: certainly if you are counting 'characters', Id think
08:37:42 <beaky> how do i make overloadedstrings use bytestring
08:37:44 <elliott> is Word8 faster than Char?
08:37:50 <mauke> beaky: types have no speed
08:37:54 <beaky> oh right
08:38:03 <beaky> maybe operations on types have speed :D
08:38:04 <ibotty1> elliott: yes, it's smaller
08:38:16 <anothernewhaskel> mauke: wat
08:38:25 <anothernewhaskel> mauke: how can a function be an instance of Num
08:38:25 <applicative> text is Word16 or something
08:38:48 <elliott> text represents Char by properly handling surrogates afaik
08:38:56 <elliott> i.e. UTF-16 not UCS-2 or whatever
08:39:12 <Eduard_Munteanu> GHC thinks there is a notion of speed for types, e.g. FastString. :P
08:39:20 <haasn> anothernewhaskel: (+) :: Num a => (r -> a) -> (r -> a) -> r -> a
08:39:26 * ski . o O ( .. some people can type speedily )
08:39:30 <geekosaur> anothernewhaskel, http://hackage.haskell.org/package/NumInstances
08:40:15 <mauke> http://hackage.haskell.org/package/NumInstances-1.3/docs/src/Data-NumInstances-Function.html
08:40:16 <Eduard_Munteanu> I wonder if there's a law that says you can't go faster than the speed of newtypes in Void.
08:40:21 <anothernewhaskel> haasn: sorry what's that doing?
08:40:41 <haasn> anothernewhaskel: that's what the signature of (+) looks like when applied to functions
08:40:42 <sclv_> instantiate the `a` to e.g. Int to see things better
08:41:00 <elliott> ski: people like hindley-milner?
08:41:06 <sclv_> we 'add' functions all the time from fixed domains when doing math
08:41:06 <anothernewhaskel> haasn: what does (r -> a) mean
08:41:12 <anothernewhaskel> r is of type a?
08:41:14 <sclv_> its a function that sends r -> a
08:41:25 <anothernewhaskel> "sends"?
08:41:37 <sclv_> it takes a value of type r and returns a value of type a
08:41:55 <haasn> (r -> a) is the type of a function that takes parameters of type ‘r’ and evaluates to values of type ‘a’
08:42:06 <haasn> or s/evaluates to/returns/
08:42:27 <anothernewhaskel> haasn: why is it there in the parameter list?
08:42:38 <anothernewhaskel> haasn: does it transform the params to type a?
08:42:40 <anothernewhaskel> if they arent
08:42:41 <sclv_> its not a parameter list
08:42:44 <sclv_> its a type
08:42:50 <sclv_> if I say foo :: Int it means foo is of type int
08:42:51 <mauke> because (+) takes two functions and returns a function
08:43:03 <sclv_> if I say foo :: Int -> Int, it means foo is a function that sends Ints to Ints
08:43:05 <mauke> remember, our "numbers" are functions in this case
08:43:16 <anothernewhaskel> oh
08:43:20 <anothernewhaskel> so r is a function
08:43:22 <mauke> no
08:43:23 <anothernewhaskel> and returns type a?
08:43:25 <sclv_> if I say foo :: Int -> Int -> Int it means foo is a function that, given an int, returns _another_ function of type Int -> Int
08:43:26 <mauke> no
08:43:27 <acomar> r -> a is a function
08:43:28 <anothernewhaskel> >.<
08:43:34 <anothernewhaskel> oh i see
08:43:44 <anothernewhaskel> so it takes a function that sends r to a
08:43:48 <anothernewhaskel> or 2 functions
08:43:49 <anothernewhaskel> even
08:43:49 <mauke> r -> a is the type of a function
08:43:54 <sclv_> yes, and gives back _another_ function
08:44:06 <acomar> so (+) takes two functions of type (r -> a) and returns a function (r -> a)
08:44:11 <ski> @let instance Num a => Num (rho -> a) where (+) = liftA2 (+); (-) = liftA2 (-); (*) = liftA2 (*); negate = fmap negate; abs = fmap abs; signum = fmap signum; fromInteger = pure . fromInteger
08:44:12 <lambdabot>  Defined.
08:44:12 <anothernewhaskel> surely + can only ever give back a number? :S
08:44:27 <anothernewhaskel> when can it not
08:44:27 <acomar> you're defining functions of the form (r -> a) to be numbers
08:44:27 <ski> > ((^2) + (^3)) x
08:44:30 <lambdabot>   x * x + x * x * x
08:44:32 <sclv_> so just like I can visually "add" two functions on a graph by saying the result of the new one at some point is the result of the first at that point plus the result of the second at that point
08:44:36 <sclv_> that's what the num instance does
08:44:39 <anothernewhaskel> oh i see
08:44:49 <mauke> (f + g) x = f x + g x
08:44:56 <anothernewhaskel> ok yea
08:44:56 <quicksilver> the dual of a vector space is also a vector space; if the original vector space was a field so is the dual.
08:44:57 <ski> > (sin ^ 2  + cos ^ 3) `map` [0,pi/8 .. pi]
08:44:57 <anothernewhaskel> that makes senes
08:45:01 <lambdabot>   [1.0,0.9350271168814638,0.8535533905932737,0.9095960817392694,1.0,0.7975106...
08:45:05 <ski> > (sin ^ 2 + cos ^ 2) `map` [0,pi/8 .. pi]
08:45:09 <lambdabot>   [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0]
08:45:27 <anothernewhaskel> this bot is lovely
08:45:35 <ski> > (length + sum) [0,1,2,3]
08:45:38 <lambdabot>   10
08:45:45 <haasn> lovely but timid
08:45:45 <ski> anothernewhaskel : ok ?
08:45:49 <monoidal> > (2 + 4) 6
08:45:50 <lambdabot>   Could not deduce (GHC.Num.Num t)
08:45:50 <lambdabot>    arising from the ambiguity check for `e...
08:46:02 <anothernewhaskel> monoidal: O.o
08:46:07 <ski> > (2 + 4) 6 :: Integer
08:46:09 <anothernewhaskel> surely (2 + 6)*6
08:46:12 <lambdabot>   6
08:46:13 <anothernewhaskel> *2 + 4
08:46:20 <anothernewhaskel> wat
08:46:20 <ski> > (2 + 4) 100 :: Integer
08:46:22 * haasn wonders why GHC did not default that Num constraint to Integer
08:46:23 <lambdabot>   6
08:46:24 <ski> > (2 + id) 100 :: Integer
08:46:27 <lambdabot>   102
08:46:33 <anothernewhaskel> what
08:46:34 <haasn> :t (2 + 4) 6
08:46:36 <lambdabot> (Num (a -> t), Num a) => t
08:46:36 <anothernewhaskel> id isnt defined
08:46:39 <anothernewhaskel> how did that compile
08:46:40 <ski> > (id^2 - id + 1) 100 :: Integer
08:46:42 <haasn> aha
08:46:44 <lambdabot>   9901
08:46:47 <acomar> id :: a -> a, it means identity
08:46:47 <ski> @src id
08:46:47 <lambdabot> id x = x
08:46:51 <sclv_> remember (2 + 4) here is an function
08:46:56 <acomar> comes with the haskell Prelude
08:47:00 <sclv_> and we just calculate that new function, then apply it to 6
08:47:08 <ski> > (\x -> x^2 - x + 1) 100
08:47:08 <lambdabot>   9901
08:47:12 <haasn> > (2 + 4) ()
08:47:15 <lambdabot>   6
08:47:40 <FreeFull> > let x = id in (x^2 - x + 30) 10
08:47:43 <lambdabot>   120
08:48:12 <anothernewhaskel> "let x = (x = x)" ?
08:48:13 <beaky> when should I use lazy Text over normal text
08:48:19 <ski> > (fst^2 - fst*snd + snd^2) (10,1000)
08:48:21 <haasn> anothernewhaskel: syntax error
08:48:22 <lambdabot>   990100
08:48:23 <Sagi> okay, I think I understand (.) . (.) . (.) now
08:48:29 <ion> anothernewhaskel: let x = (\y -> y)
08:48:30 <anothernewhaskel> haasn: thats what FreeFull =just did
08:48:33 <Sagi> took me a while though, wow
08:48:37 <anothernewhaskel> let x = id
08:48:43 <anothernewhaskel> id === x = x
08:48:47 <monoidal> Sagi: IMO it's easiest to look via semantic editor combinators
08:48:47 <ski> Sagi : good to have done, once :)
08:48:49 <anothernewhaskel> therefore let x = id === let x = (x = x)
08:48:51 <haasn> anothernewhaskel: no. id = \x -> x
08:48:56 <haasn> id is not x = x
08:48:58 <anothernewhaskel> @src id
08:48:58 <lambdabot> id x = x
08:48:58 <acomar> id = \x -> x
08:48:58 <haasn> is x = x
08:49:01 <haasn> id x = x, even
08:49:09 <monoidal> Sagi: http://conal.net/blog/posts/semantic-editor-combinators
08:49:14 <haasn> ‘x = x’ isn't a valid expression
08:49:19 <anothernewhaskel> wait
08:49:19 <Sagi> monoidal, ski: now the followup question is, should I actually use this for readability?
08:49:19 <haasn> it's part of the syntax used to define names
08:49:23 <anothernewhaskel> id x just returns x
08:49:27 <acomar> yep
08:49:28 <anothernewhaskel> why the hell not just use x
08:49:30 <Sagi> it simplifies the code, but unless you know what it does, it's really weird
08:49:33 <ion> x = x is a valid definition, but not very useful one.
08:49:33 <anothernewhaskel> id is redundant
08:49:44 <acomar> cause you want a function that does nothing
08:49:51 <acomar> for one reason or another
08:49:52 <ski> Sagi : the SECs monoidal is talking about is `result :: (b0 -> b1) -> ((a -> b0) -> (a -> b1)); result = (.)' and `argument :: (a1 -> a0) -> ((a0 -> b) -> (a1 -> b)); argument = flip (.)'
08:50:00 <acomar> remember when we defined and = all id?
08:50:09 <ski> Sagi : depends ? does it get more readable, or less ?
08:50:18 <Sagi> it gets more compact for sure
08:50:29 <ion> And ski’s example involving id^2 - id + 1
08:50:29 <anothernewhaskel> > let x = in (x^2 - x + 30) 10
08:50:30 <lambdabot>   <hint>:1:9: parse error on input `in'
08:50:33 <Sagi> but I can also explicitly list the arguments of the function and just use $ and .
08:50:40 <anothernewhaskel> what the flipping heck is id doing
08:50:40 <ski> anothernewhaskel : consider `foldr (.) id'
08:50:46 <skittlez> Hmm can't find a way to count the leaves in a rose tree, only got a function that counts all nodes, someone has an idea?
08:50:46 <anothernewhaskel> > let x = id in (x^2 - x + 30) 10
08:50:51 <lambdabot>   120
08:50:57 <monoidal> Sagi: do you see the type of fmap . fmap . fmap? the one with (.) is a special case of fmap, for (->) r functor
08:51:00 <ski> > (sin . cos . tan) x :: Expr
08:51:02 <lambdabot>   sin (cos (sin x / cos x))
08:51:13 <ski> > foldr (.) id [sin,cos,tan] x :: Expr
08:51:14 <lambdabot>   sin (cos (sin x / cos x))
08:51:20 <ski> @type foldr (.) id
08:51:21 <lambdabot> [b -> b] -> b -> b
08:51:45 <ski> anothernewhaskel : `id' is useful as a "base case" (identity element) for `(.)'
08:51:55 <acomar> anothernewhaskel: how far into LYAH are you again? :P (I hope we're not all thoroughly confusing you)
08:52:07 <ski> anothernewhaskel : just like `0' is useful as identity element for `(+)', and `1' for `(*)'
08:52:13 <ski> @src sum
08:52:14 <lambdabot> sum = foldl (+) 0
08:52:16 <ski> @src product
08:52:17 <lambdabot> product = foldl (*) 1
08:52:29 <ion> and [] for (++)
08:52:32 <ski> yes
08:53:02 <Sagi> monoidal: guess I need some time to digest that :-)
08:53:35 <monoidal> Sagi: tldr version: http://stackoverflow.com/a/415154
08:53:54 <ski> @let result :: (b0 -> b1) -> ((a -> b0) -> (a -> b1)); result = (.)
08:53:55 <lambdabot>  Defined.
08:54:04 <ski> @let argument :: (a1 -> a0) -> ((a0  -> b) -> (a1 -> b)); argument = flip (.)
08:54:05 <lambdabot>  Defined.
08:54:14 <FreeFull> > (sin^2 + cos^2) 30
08:54:17 <lambdabot>   1.0
08:54:27 <ski> @let swap :: (a,b) -> (b,a); swap = arr snd &&& arr fst
08:54:29 <lambdabot>  Defined.
08:54:30 * hackagebot cassy 0.5.2 - A high level driver for the Cassandra datastore  http://beta.hackage.haskell.org/package/cassy-0.5.2 (OzgunAtaman)
08:54:36 <ski> @type mapAccumL
08:54:36 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
08:54:45 <ski> @type state
08:54:45 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
08:54:52 <ski> @type runState
08:54:52 <lambdabot> State s a -> s -> (a, s)
08:55:20 <FreeFull> :t runState . state
08:55:24 <lambdabot> (s -> (a, s)) -> s -> (a, s)
08:56:09 <ParahSai1in> odd: "cabal.exe: internal error when reading package index: could not read tar fileentryThe package index or index cache is probably corrupt. Running cabal update might fix it."
08:56:14 <S11001001> Is the kind Constraint exported from somewhere other than GHC.Prim?
08:56:43 <ski> @let arg = L.argument; res = L.result
08:56:44 <lambdabot>  Defined.
08:56:47 <monoidal> S11001001: Data.Constraint from constraints package
08:56:55 <S11001001> monoidal: thanks
08:57:16 <ski> @let swap_ = L.swap
08:57:17 <lambdabot>  Defined.
08:57:25 <ozataman> I still don't understand why cabal sometimes fixates on the latest version of some dependencies, when a manual intervention lets the install move forward: ci --only-dependencies --max-backjumps=-1 --constraint 'case-insensitive < 1.1' --constraint 'cryptohash < 0.11'
08:57:32 <ski> @type mapAccumL
08:57:33 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
08:57:35 <ski> @type (arg . res . res) swap_ mapAccumL
08:57:36 <lambdabot> (b -> a -> (a1, b)) -> b -> [a] -> (b, [a1])
08:57:40 <Sagi> monoidal: brilliant :) I got that one on the first read
08:57:46 <Sagi> thanks
08:58:18 <ski> @type arg (res (res swap_)) mapAccumL
08:58:19 <lambdabot> (b -> a -> (a1, b)) -> b -> [a] -> (b, [a1])
08:58:22 <ski> @type arg (res (res swap_ . runState)) mapAccumL
08:58:22 <lambdabot> (b -> State b a) -> b -> [b] -> (b, [a])
08:58:35 <ski> hm, no
08:59:03 <ski> @type arg (flip . res (res swap_ . runState)) mapAccumL
08:59:04 <lambdabot> (a -> State b a1) -> b -> [a] -> (b, [a1])
08:59:06 <ski> that looks better
08:59:29 <anothernewhaskel> acomar: like 4 or 5 pages
08:59:34 <anothernewhaskel> acomar: im up to recursion
08:59:38 <ski> @type (arg (flip . res (res swap_ . runState)) . res (res (state . res swap_). flip)) mapAccumL
08:59:39 <lambdabot> MonadState s m => (a -> State s a1) -> [a] -> m [a1]
09:00:00 <ski> @type (arg (flip . res (res swap_ . runState)) . res (res (state . res swap_). flip)) mapAccumL :: (a -> State s b) -> ([a] -> State s [b])
09:00:01 <lambdabot> (a -> State s b) -> [a] -> State s [b]
09:00:12 <ski> @type mapM :: (a -> State s b) -> ([a] -> State s [b])
09:00:12 <lambdabot> (a -> State s b) -> [a] -> State s [b]
09:00:50 <ski> Sagi : see how `arg' and `res' can be used to "focus" on the argument resp. the result of a function, and apply some "transformation" on it
09:01:14 <ski> Sagi : also `onFst :: (a0 -> a1) -> ((a0,b) -> (a1,b))' and similar stuff are useful here
09:01:20 <ski> @where SEC
09:01:20 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
09:01:37 <Eduard_Munteanu> How do you tell attoparsec a parser must fail?
09:03:02 <Eduard_Munteanu> I want something like fooP = mustFail barP (...parse foo here...)
09:03:28 <Eduard_Munteanu> (where fooP and barP :: Parser ...)
09:05:13 <fizruk> Eduard_Munteanu: should mustFail check if barP fails and if not - fail itself? otherwise do nothing?
09:06:25 <FreeFull> > (1,2) & (+1) %~ _1
09:06:26 <lambdabot>   Could not deduce (Control.Lens.Internal.Indexed.Indexable
09:06:27 <lambdabot>                  ...
09:07:00 <FreeFull> > (1,2) & _1 %~ (+1)
09:07:02 <lambdabot>   (2,2)
09:07:13 <FreeFull> Who needs onFst when you have lens
09:07:31 <ski> well that lens implements (the idea of) `onFst' :)
09:09:32 * hackagebot data-pprint 0.2.2 - Prettyprint and compare Data values  http://beta.hackage.haskell.org/package/data-pprint-0.2.2 (PeterDivianszky)
09:09:39 <Eduard_Munteanu> fizruk: mustFail succeeds iff barP fails
09:09:46 <Eduard_Munteanu> fizruk: and returns nothing
09:09:49 <FreeFull> ski: Works on more than just the 2-tuple though
09:10:11 <FreeFull> You could restrict it to be onFst
09:10:30 <Eduard_Munteanu> fizruk: actually that's not important... mustFail p q = q  if p fails
09:10:57 <ski> FreeFull : though imnsho, it ought to be `_0' ;)
09:11:02 <fizruk> Eduard_Munteanu: then p <|> q ?
09:11:11 <FreeFull> ski: shhh =P
09:11:48 <FreeFull> ski: Then it shouldn't be onFst, but onZrth
09:11:52 <fizruk> :t (<|>)
09:11:53 <lambdabot> Alternative f => f a -> f a -> f a
09:12:01 <Eduard_Munteanu> fizruk: that has the wrong type
09:12:26 <Eduard_Munteanu> fizruk: I want   f a -> f b -> f b
09:12:34 <Eduard_Munteanu> or a = (), anyway
09:12:45 <FreeFull> Eduard_Munteanu: And not just flip const?
09:12:49 * ski . o O ( "Why numbering should start at zero" by Edsger Wybe Dijkstra in 1982-08-11 at <http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html> )
09:12:51 <Taneb> (<$)?
09:13:00 <Taneb> (*>)?
09:13:12 <Taneb> No, never mind
09:13:15 <Eduard_Munteanu> Those don't work because they need both parsers to succeed.
09:13:22 <fizruk> Eduard_Munteanu: (p *> fail "") <|> q ?
09:13:25 <ski> FreeFull : yes, but afaics, "first" doesn't have a clear etymological connection to "one"
09:13:29 <ikarus> ski: Dijkstra said it, so he must be right
09:13:34 <ski> ikarus : exactly ;)
09:13:35 <Eduard_Munteanu> fizruk: yes, that's prety much what I want
09:13:36 <Taneb> Yeah, I didn't read up
09:13:38 <Eduard_Munteanu> *pretty
09:13:43 <fizruk> Eduard_Munteanu: I mean with proper error message
09:13:43 <ikarus> he even went to the same highschool as I did, he can't be wrong
09:14:02 <Eduard_Munteanu> FreeFull: well no, it must check the 'f a' part fails.
09:14:11 <FreeFull> ski: but third does have to three, and third is definitely succ succ first
09:14:19 <FreeFull> Eduard_Munteanu: What if it doesn't?
09:15:53 <Eduard_Munteanu> FreeFull: I need to check if the input contains a '/' at the start, and one of my parsers requires that condition to fail
09:16:41 <Eduard_Munteanu> FreeFull: so yes, they do overlap a tiny bit, it would be annoying to separate them though.
09:17:11 <fizruk> :t (*>)
09:17:12 <lambdabot> Applicative f => f a -> f b -> f b
09:17:36 <ski> FreeFull : yes, so we'd then need a word in between "second" and "third"
09:18:13 <Eduard_Munteanu> fizruk: that requires the 'f a' to succeed
09:18:22 <Eduard_Munteanu> Both have to succeed.
09:18:31 <Eduard_Munteanu> It just ignores the leftwards value.
09:18:48 <beaky> longlines <- filter ((> 79) . T.length . snd) . zip [(1 :: Int)..] . T.lines <$> T.readFile filename -- how do I improve this line?
09:18:49 <fizruk> Eduard_Munteanu: I know, just checked if I was using right symbol
09:18:55 <Eduard_Munteanu> Ah.
09:18:57 <pqmodn> :t (\a b -> a *> optional b)
09:18:58 <lambdabot> Alternative f => f a -> f a1 -> f (Maybe a1)
09:19:29 <Eduard_Munteanu> fizruk: anyway, I was wondering if there's a better way than calling 'fail' (manually).
09:19:35 <Jesin> hi beaky.  :p
09:20:00 <fizruk> Eduard_Munteanu: yeah, fail feels a bit hacky
09:20:23 <beaky> hello beaky
09:20:32 <fizruk> Eduard_Munteanu: how about empty?
09:20:39 <fizruk> :t empty
09:20:40 <lambdabot> Alternative f => f a
09:20:56 <Eduard_Munteanu> Hm.
09:20:57 <beaky> i love haskell it is so expressive yet so low-level and safe
09:21:25 <beaky> there are things that only static typing can acomplish
09:21:39 <FreeFull> How is Haskell low-level?
09:21:55 <beaky> it is compiled
09:22:06 * ski stares blankly
09:22:07 <FreeFull> That doesn't make it low-level
09:22:15 <beaky> oh
09:22:21 <fizruk> Eduard_Munteanu: it seems to be an alias for `fail "empty"`
09:22:26 <Maior> that's, er, not like any definition of low-level I've ever heard of
09:22:26 <beaky> but it feels more low level than ruby
09:22:35 <FreeFull> You can compile any language if you write a compiler for it
09:22:39 <FreeFull> Ruby too
09:22:41 <beaky> ah
09:22:53 <Eduard_Munteanu> fizruk: I guess   (char '/' *> empty) <|> usefulStuff   could work
09:22:55 <ski> FreeFull : `empty' or maybe `mzero' would be better than a `fail' call, yes
09:23:09 <ski> (unless you want to supply some interesting string to `fail')
09:23:43 <Eduard_Munteanu> ski: you mean fizruk or me :)
09:23:46 <fizruk> in Applicative setting empty suits better, I think
09:23:55 <ski> er, yes
09:24:03 <ski> fizruk ^
09:24:32 <beaky> is it possible to define a doubly linked list in haskell? i tried Data DLL a = DLL [a] a [a]
09:24:42 <beaky> but it seems that it something else
09:24:50 <FreeFull> fail should be part of Alternative
09:24:59 <Eduard_Munteanu> beaky: normally you'd use zippers, which is much like your DLL
09:25:01 <fizruk> ski: so (empty <?> "error occured") is prefered to (fail "error occured")?
09:25:27 <dfan> beaky: http://stackoverflow.com/questions/10386616/how-to-implement-doubly-linked-lists
09:25:59 <beaky> ah
09:26:04 <beaky> the zipper is still awesome
09:26:05 <Eduard_Munteanu> beaky: you can define infinitely-recursive doubly-linked lists, but they're pretty bad at updating. Look up "tying the knot" for details.
09:26:41 <beaky> and the finger tree is optimal for a deque (which one normal y use doubly linked list in a strict language)
09:26:43 <Yorick|2> Hi there. Can you help me with next: I can't run cabal install because it can't determine where my ghc compiler is. What should I do?
09:27:15 <merijn> Yorick|2: Check that GHC is in your path
09:27:16 <Yorick|2> windows 7, haskell platform,
09:27:19 <Eduard_Munteanu> beaky: if you want access to both ends use Seq, it quite list-like (even more so if you use ViewPatterns)
09:28:58 <Eduard_Munteanu> ski: btw, have you received my in-channel message from a few days ago, on the mapFocus thing? (the one saying I was wrong about it being another mapValues)
09:29:20 <beaky> what is a monomorphism restriction
09:29:38 <Eduard_Munteanu> beaky: http://www.haskell.org/haskellwiki/Monomorphism_restriction
09:29:58 <beaky> no polymorphic constant values allowed by default? wow why would that be like that
09:30:07 <FreeFull> For performance
09:30:22 <beaky> ah
09:30:35 <FreeFull> Monomorphic values tend to be faster than polymorphic ones
09:31:02 <Eduard_Munteanu> Also typeclasses involve passing a pointer to the dictionary at runtime.
09:31:03 <FreeFull> Because of sharing
09:31:10 <FreeFull> And no dictionary lookup
09:31:41 <beaky> so haskel typeclass are like lisp generic functions?
09:36:31 <haasn> Eduard_Munteanu: and lenses!
09:37:06 <Yorick|2> I add to PATH C:\Program Files (x86)\Haskell Platform\2013.2.0.0\bin in a different ways, but still have no required version of ghc>=6.2 when type a command. What's wrong?
09:37:50 <Yorick|2> excuse my french
09:40:24 <Yorick|2> (i have 7.6.3 but it can't find my ghc, how fix it?)
09:42:30 <pavonia> Yorick|2: Does it work if you call ghc with the full path?
09:44:08 <Yorick|2> ppavonia: I changed PATH to C:\Program Files (x86)\Haskell Platform\2013.2.0.0\bin
09:44:28 <Yorick|2> pavonia:
09:44:58 <pavonia> No, I mean what happens if you run "C:\Program Files (x86)\Haskell Platform\2013.2.0.0\bin\ghc.exe" in the command line?
09:46:30 <Yorick|2> it dont want to run because of long name of Program Files (x86), Thanks!
09:46:41 <beaky> why is my c++ code more eficient than my haskell
09:46:55 <solarus> Yorick|2: I think you also need to add " around the string if your path contains spaces btw
09:47:04 <quchen> Because your Haskell code is less efficient than your C++ code.
09:47:08 <quchen> Glad I could help.
09:47:10 <beaky> how do I improve the haskell efficiency
09:47:21 <beaky> it is more space efficient, but slower by a factor of 10
09:48:45 <Yorick|2> solarus: I'm trying, thx
09:49:07 <alpounet> beaky, where's the haskell code?
09:49:52 <beaky> http://lpaste.net/93764
09:52:38 <xico> hi
09:53:05 <beaky> hi
09:53:23 <ParahSai1in> hm: "Loading package Win32-2.3.0.0 ... linking ... ghc.exe: internal error: R_X86_64_PC32: High bits are set in 7fd84c75d29 for DefDlgProcW"
09:53:47 <xico> i want to generate instances for specific typeclasses. has anyone suggestions on that? i guess i could use Mitchell’s derive or juste template haskell.
09:54:12 <xico> (i suspect they would be almost equivalent)
09:54:14 <donri> xico: Generic is nice for deriving instances
09:54:14 <ParahSai1in> i suppose i should report this one?
09:54:28 <acomar> beaky: couple of suggestions -- switch to using Text instead of String, and Vector instead of []
09:54:35 <quchen> xico: -XStandaloneDeriving?
09:54:42 <ParahSai1in> could someone walk me through how i would get enough relevant information to file a report?
09:54:59 <donri> acomar: it is using Text
09:55:11 <donri> don't think vector would help here
09:55:11 <acomar> whoops, missed that
09:55:16 <acomar> yea, nvm
09:56:05 <xico> donri, quchen: thanks, i will check those out.
09:56:30 <beaky> maybe i should use bytestring
09:56:40 <donri> xico: http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-programming.html
09:56:55 <Yorick|2> solarus: pavonia:  No. Several other system variables were written in the same type. I reckon that deal is not in the Path - it's written right, ghc exists, in users patg i'd added it and in the system Path
09:58:11 <solarus> Yorick|2: ok were more or less guessing about the quotes. Basically assumed spaces had to be escaped somehow :)
09:58:51 <alpounet> beaky, are you benching on a big file?
09:58:57 <xico> donri: thanks. this is not only perfectly what i needed, but also extremely useful in general.
09:59:09 <solarus> Yorick|2: but you could try, similar to what pavonia suggested, to change to the bin directory and invoking ghc from there
09:59:25 <donri> beaky: bytestring's "lines" is only latin1-compatible
09:59:40 <beaky> yes i am benching ona  directory
10:00:00 <donri> beaky: and "length" will count bytes not characters
10:00:27 <beaky> ah maybbe my c++ version is using not unicode aware strings
10:00:36 <elliott> well, ByteString's lines _will_ split a bytestring containing UTF-8 into a bunch of UTF-8-encoded lines. but.
10:00:40 <Yorick|2> solarus: yeah, i can do this. But my Cabal can't
10:00:46 <beaky> bytestring has a lines?
10:00:48 <beaky> it seems not
10:00:56 <pavonia> Yorick|2: I suggested running it with the full path just to make sure the executable is really there and the path is correct
10:01:11 <Yorick|2> path is correct
10:01:29 <donri> beaky: also there are conveniences in Data.List like findIndices that could be faster too, not sure
10:02:13 <Yorick|2> cabal have problem on this machine: on another (with win 8 against win 7) i have not such trouble
10:02:21 <Yorick|2> *has
10:02:30 <donri> beaky: longlines <- findIndices ((> 79) . T.length) . T.lines <$> ...
10:02:59 <beaky> yay I switched to byestring and my haskell code is now faster than c++!
10:03:06 <donri> heh
10:03:51 <beaky> according to my unscientific benchmarks
10:04:08 <ski> Eduard_Munteanu : i only saw "<Eduard_Munteanu> ski: not sure if it's relevant, but it looks like the two notions of mapFocus combined generate an indexed store comonad and they also seem to be profunctorial: index :: (i -> s) -> (s -> o) -> w s a -> w__ i o a. You can also define a profunctor on  \i o -> w__ i o a which is almost identical to pairing the two mapFocuses."
10:04:31 <donri> beaky: you should try a pipes version :)
10:04:38 <quchen> elliott: Well you can split your BS at 0x20, that behaviour should be well-defined, so what's the "but"? That not every data has \n at 0x20?
10:04:52 <Yorick|2> Another question:
10:05:01 <beaky> what is a pipes version
10:05:06 <beaky> like parlleism?
10:05:08 <donri> @hackage pipes
10:05:08 <lambdabot> http://hackage.haskell.org/package/pipes
10:05:21 <quchen> elliott: I understand the general issue of treating BS as a string type, but \n is a very specific byte in UTF-8, no?
10:06:10 <donri> although I don't know if pipes will make it *faster*. the main attraction is that pipes can run with constant space
10:06:11 <elliott> the "but" is that you probably shouldn't be thinking these thoughts unless you don't need me to tell you them.
10:06:13 <Eduard_Munteanu> ski: yeah, that (dunno if it makes much sense). It looks a lot like a Hom functor, I mean.
10:06:24 <elliott> since it means you're about to use ByteString to represent text without knowing how UTF-8 works :p
10:06:55 <Yorick|2> cabal-dev(and just cabal) "can't link GSL". I know that there is GSL in Cygwin, i installed Cygwin - but anyway it can't link GSL
10:06:59 <donri> quchen: \n is very specifically not the same byte(s!) in, say, utf-16
10:07:32 <quchen> donri: Oh snap. Time to get in my time machine to 5 minutes ago.
10:08:29 <Yorick|2> Where I can get "appropriate -dev packages" for hmatrix
10:08:55 <donri> elliott: (this is why i said "latin1-compatible", which includes utf-8 for \n)
10:09:15 <Yorick|2> anyway, I need packs to work with matrixes - what you can advice?
10:09:45 <alpounet> Yorick|2, for now, I suppose hmatrix's the best
10:10:11 <Yorick|2> alpounet: How do you managed to install it?
10:10:38 <Eduard_Munteanu> ski: any idea if there's something more to that?
10:10:41 <alpounet> Yorick|2, I follow the indications I could find by googling
10:10:46 <alpounet> followed*
10:11:16 <alpounet> this comes up from time to time on haskell-cafe or a blog post or wiki entry or something
10:11:25 <elliott> donri: right
10:12:31 <Yorick|2> okay, i too: cabal install hmatrix    But problem with GSL. I can't understand what i have to do
10:12:52 <Yorick|2> Cygwin I installed
10:13:22 <Yorick|2> alpounet: And I know that GSL is the part of Cygwin
10:13:59 <alpounet> for OS X I've used http://www.haskell.org/haskellwiki/Hmatrix_on_Mac_OS_X
10:14:09 <alpounet> maybe you just have to point cabal to the right libdir or something?
10:15:10 <alpounet> but I don't see any post or email about hmatrix inside a cygwin env
10:15:31 <FreeFull> Haskell works best under linux
10:15:41 <FreeFull> Which is a bit ironic it started as a microsoft research project
10:16:38 <sm> FreeFull: s/Haskell/many Haskell packages/
10:17:52 <Yorick|2> I need "$ sudo apt-get install libgsl0-dev liblapack-dev gnuplot imagemagick"  but in Windows
10:18:12 <Yorick|2> or something like this
10:18:30 <joelteon> is there a shortcut to making a list in TH
10:18:38 <joelteon> just of string literals
10:19:32 <donri> joelteon: listE?
10:19:38 <joelteon> oh...maybe
10:19:47 <alpounet> Yorick|2, you have to get these libraries and then point cabal install to them using --extra-lib-dirs and --extra-include-dirs I think
10:19:48 <jfischoff> and stringE
10:20:16 <jfischoff> listE . map stringE
10:20:29 <Cale> FreeFull: It didn't start as a project at MSR. MSR just hired Simon Peyton Jones well after :)
10:21:09 <donri> joelteon: also in this case maybe simply "lift" (from .Syntax)
10:21:25 <jfischoff> ah good point
10:21:51 <FreeFull> Cale: I see
10:22:28 <donri> although you get lots of CharL instead of StringL heh
10:22:41 <donri> which affects OverloadedStrings
10:22:47 <joelteon> is there a shorthand for AppE etc. etc.
10:23:03 <donri> joelteon: [| quotes?
10:23:44 <jfischoff> `appE` or `AppE` is usually more clearer
10:23:50 <jfischoff> more clearer :p
10:24:03 <donri> depends on if you're in Q :)
10:24:06 <ramses_> has anyone else has had problems with literate haskell syntax highlighting in vim? It seems to be totally screwed up here
10:24:37 <donri> ramses_: what type of lhaskell are you using and what syntax provider in vim
10:25:32 <ramses_> donri: the one that came with my vim, it says version 1.04. How can I see my syntax provider? I don't know what that is
10:25:53 <donri> ramses_: i meant if you're using a plugin that ships a different syntax/haskell.vim
10:26:18 <donri> ramses_: and i meant, are you using bird tracks or latex style literate haskell
10:26:50 <ramses_> donri: I don't have any haskell syntax files in my .vim and it is ghc code, so latex style
10:27:08 <donri> ramses_: ok that should work then AFAIK. screenshot?
10:27:28 <ramses_> donri: comming up
10:31:04 <joejev> I am trying to learn about using ErrorT to catch errors instead of calling error, does throwError cause the function to return the error passed and stop or will it continue, also, I was wondering if someone could help me solve a No instance for (Error ExceptionType) problem
10:31:16 <aegis__> hey! could anyone tell me why evaluation is forced in this expression: "print "foo" >>= (\_ -> print "bar")" ? I couldn't find the haskell source for the Monad instance of IO
10:32:08 <FreeFull> aegis__: That code is equivalent to do { print "foo"; print "bar" }
10:32:11 <Eduard_Munteanu> joejev: unless you catch it, or runErrorT, it will abort the entire computation just like Maybe.
10:32:16 <danilo2> Hello! I'm using template Haskell and got a small question connected to this topic. Is it possible to return an ordinary Haskell value out of Template Haskell? I want for example to return a string and use it like "let a = $(thfunc)" ?
10:32:29 <FreeFull> aegis__: IO is built into the language because it's special
10:32:54 <donri> danilo2: see stringE
10:33:11 <ramses_> donri: http://postimg.org/image/a6b9yf27r/
10:33:13 <jfischoff> danilo2: let a = $(stringE "yo")
10:33:18 <donri> danilo2: for arbitrary Data you can use the functions in the .Quote module
10:33:31 <Eduard_Munteanu> aegis__, FreeFull: nevertheless, IIRC, >>= is strict in its first argument for IO
10:33:35 <ramses_> donri: from there one, a huge part of the file is printed almost entirely in that purple
10:33:49 <aegis__> FreeFull: well yeah but the do notation is only syntactic sugar; it doesn't tell me why evaluation is forced in this case. I guess there must be something in the implementation of the "bind" method on IO which forces evaluation of the arguments; If I take the bind method of the Maybe monad what I wrote is equivalent to (\_ -> print "bar") (print "foo"), which prints only "bar"
10:34:01 <joejev> Eduard_Munteanu: I am running the function through runErrorT, but I guess I am using a monad transform that is ErrorT DoormanError IO, so I have functions that have like, unless (bool) $ throw Error, and then the next line is an IO func, will that IO func be called if it throws the error?
10:34:02 <danilo2> jfischoff, donri: thank you! :)
10:34:06 <donri> ramses_: that doesn't look like valid latex
10:34:08 <ramses_> donri: it seems as if everything, including code, is highlighted as latex
10:34:10 <fizruk> aegis__: are you familiar with Writer monad?
10:34:12 <aegis__> Eduard_Munteanu: oh ok, so it could be like implementing "bind" for IO with a strictness flag
10:34:18 <aegis__> fizruk: nope
10:34:22 <jfischoff> donri: Wat! How did I not see dataToExpQ?!
10:34:32 <pqmodn> is there a reason state written as "s -> (a, s)" instead of "s -> (s, a)"?
10:34:36 <fizruk> aegis__: are you familiar with Maybe monad?
10:34:39 <donri> ramses_: yes, that's the point. only stuff between \begin{code} and \end{code} is haskell code
10:34:42 <aegis__> fizruk: yes
10:35:02 <FreeFull> > runWriter $ tell "Meow" >>= \_ -> tell " Moo!"
10:35:02 <lambdabot>   ((),"Meow Moo!")
10:35:06 <ramses_> donri: I know, but it doesn't highlight those parts as haskell
10:35:16 <fizruk> > Nothing >>= \_ -> Just 1
10:35:17 <lambdabot>   Nothing
10:35:29 <fizruk> aegis__: do you understand that ^
10:35:34 <donri> ramses_: looks to me like it does
10:35:39 <donri> ramses_: the imports at the top there
10:35:43 <ramses_> donri: but indeed that is not valid latex. Do you know whether I can tell it not to highlight the latex parts?
10:35:56 <ramses_> donri: it does there, but it doesn't furtherone in the file
10:36:10 <aegis__> fizruk: yep it makes sense
10:36:37 <donri> ramses_: let lhs_markup = "none", i think
10:36:59 <fizruk> aegis__: so you see how \_ -> Just 1 ignores the _result_, but not side effects?
10:37:14 <dav> Hi all. Has anyone thought about the implementation of an Excel-like computation graph in Haskell? (with dependencies, memoization, lazy evaluation, etc.)
10:37:16 <fizruk> :t tell
10:37:16 <lambdabot> MonadWriter w m => w -> m ()
10:37:35 <fizruk> > runWriter
10:37:36 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable1
10:37:36 <lambdabot>                     (Cont...
10:37:47 <fizruk> :t runWriter
10:37:47 <lambdabot> Writer w a -> (a, w)
10:38:06 <ramses_> donri: ah, perfect, I tried that with "set" instead of "let" which didn't work. I should work on my vim skills apparently :) Thanks
10:38:16 <fizruk> > runWriter (tell "hello" >>= \_ -> tell "world")
10:38:17 <lambdabot>   ((),"helloworld")
10:38:21 <aegis__> fizruk: I mean I understand the general idea of monads; I was just wondering how evaluation is force for the IO monad. Is it built-in or so? As far as I understand haskell is 100% lazy except in case of pattern matching, where evaluation is forced
10:38:34 <tac> Are there any good, extensive primers on the GHC core?
10:39:17 <alpounet> tac, mostly the commentary, GHC's code itself and a few pieces here and there on the internet
10:39:21 <alpounet> (AFAIK)
10:39:33 <tac> hmm
10:39:34 <tac> ty
10:39:50 <alpounet> it's also covered decently in http://research.microsoft.com/en-us/um/people/simonpj/Papers/inlining/inline.pdf
10:40:23 <dav> tac: http://alpmestan.com/2013/06/27/ghc-core-by-example-episode-1/ <- don't know that it's extensive but it is a primer..
10:40:30 <jfischoff> I'm finding playing with HERMIT is improving my understanding of Core
10:40:45 <jfischoff> but its also tricky learning two things at once :p
10:40:51 <krakrjak> +1 for HERMIT
10:41:10 <jfischoff> I'm pretty impressed with it so far
10:41:33 <tac> dav: thanks
10:41:33 <jfischoff> its presentation of core is much nicer than ghc-core for one
10:41:44 <fizruk> aegis__: in your example `print "foo"` is "forced" the same way Nothing is forced for Maybe example
10:41:51 <ramses_> aegis__: why exactly do you assume anything is forced?
10:41:57 <jfischoff> and is just a cool idea
10:42:46 <Eduard_Munteanu> joejev: for any monad transformer FooT, if you have FooT IO a, and a function in IO, you have to lift it to FooT IO a. That makes it a FooT IO computation, and it should be obvious how aborting influences that.
10:42:48 <alpounet> jfischoff, i have an online paste-y version of ghc-core, still have to secure it and all though
10:42:57 <dav> anyone on my computation graph question?
10:43:37 <Chousuke> aegis__: IO works pretty much like state. you get the side-effects in order because that's how the operations depend on each other.
10:44:14 <pqmodn> dav: functional reactive programming is receiving a lot of attention lately, and there is some overlap with your interest. i'd also suggest looking at visi.io, but that may be implemented in Scala
10:44:20 <Eduard_Munteanu> pqmodn: if anything, s -> (s, a) has more of a theoretical motivation. But I suppose (a,) is more convenient because you're primarily interested in the result type.
10:44:23 <jfischoff> alpounet: oh that's interesting. That could be useful
10:44:54 <dav> pqmodn: thanks for the pointer. will look!
10:44:55 <alpounet> jfischoff, however i haven't found a simple solution for running ghc in isolation and everything, with resource limits
10:44:57 <Eduard_Munteanu> s/convenient/logical
10:45:05 <jfischoff> I definitely have a question that about the core of my code where having something like that would be nice
10:45:08 * jfischoff nods
10:45:31 <alpounet> if you or anyone else is willing to help me out on this
10:45:37 <alpounet> i'd gladly brush this up
10:46:02 <pqmodn> Eduard_Munteanu: okay, thanks.
10:46:04 <jfischoff> maybe ...
10:46:19 <aegis__> ok got it, thanks!
10:46:28 <jfischoff> I'm trying to take on any new projects till I wrap up my current ones though :p
10:47:32 <Eduard_Munteanu> pqmodn: by theoretical motivation I mean the  (s, -) |- (->) s  adjunction
10:47:40 <alpounet> aegis__, try this in ghci: error "boom" >>= \_ -> putStrLn "hi"
10:48:21 <alpounet> jfischoff, hah yeah I can understand
10:48:59 <pqmodn> Eduard_Munteanu: that's a bit beyond my understanding, but i'll note it :)
10:49:16 <joejev> Can anyone tell me why this is getting this error
10:49:17 <aegis__> alpounet: hum yes, it throws an error. The thing I don't really understand is why it does whereas (\_ -> putStrLn "hi") (error "boom") does not. Somehow it forces the argument, "error "boom"", to evaluate.
10:49:19 <krakrjak> alpounet: for sandboxing ghc you can have it run as the www user and set strong ulimits before execution...  is that not a good path forward for you?
10:49:21 <joejev> http://lpaste.net/93768
10:49:25 <alpounet> aegis__, and try this too: return (error "boom") >>= \_ -> putStrLn "hi"
10:49:51 <fizruk> are there any laws callCC should satisfy (I want to check my implementation)?
10:50:43 <Eduard_Munteanu> fizruk: callCC is a law itself (depending on the context), namely Peirce's law :)
10:51:18 <alpounet> krakrjak, it may be, but i've been a bit discouraged by the various problems i have encountered while testing out various methods
10:51:36 <aegis__> alpounet: no error. I think it makes sense as it only evaluates one thunk, so we go from <thunk> to IO <thunk>; the error isn't evaluated
10:51:49 <danilo2> Could somebody please look at this simple TH example and tell me why I;'m getting the error? I'm trying to simple generate type synonim with TH: http://lpaste.net/93769
10:52:08 <FreeFull> aegis__: return doesn't have any side effects
10:52:29 <FreeFull> _ there is the error "boom" but it doesn't get used
10:52:35 <fizruk> Eduard_Munteanu: sure, so there aren't any?
10:53:29 <aegis__> FreeFull: I don't get how having side-effects or not is relevant here. Isn't it just a matter of what gets evaluated and what doesn't?
10:53:31 <Eduard_Munteanu> fizruk: I'm not sure, though it does look rather parametric
10:53:37 <krakrjak> alpounet: what are your biggest concerns?  DoS through resource exhaustion can be caught with good ulimits.
10:54:07 <fizruk> Eduard_Munteanu: what do you mean by "parametric"?
10:54:14 <Chousuke> error is kind of weird anyway because it has a side-effect despite not being IO a
10:54:47 <alpounet> krakrjak, it's really that i have investigated 3 or 4 methods back in the time, went quite ahead for realizing them, but something was wrong (stuffs couldn't build for some reason, etc)
10:54:49 <Eduard_Munteanu> fizruk: I mean the types seem to enforce the implementation (like id :: a -> a can only be id a = a)
10:55:45 <fizruk> Eduard_Munteanu: unfortunately, that seems not to be true in my case
10:55:46 <krakrjak> alpounet: that sounds like memory exhaustion issues.  Were your issues with compilation or execution of the resulting binaries?
10:55:49 <FreeFull> aegis__: Printing something out to the screen or concatenating something to a Writer is a side effect
10:55:59 <fizruk> Eduard_Munteanu: I have to different implementation that do work
10:56:11 <aegis__> FreeFull: I get that but I don't understand how it affects my question
10:56:15 <fizruk> Eduard_Munteanu: they are _almost_ the same
10:56:17 <alpounet> krakrjak, i mostly want to restrict file system access, limit resources when running ghc on the given haskell code, and hmm I think that's pretty much it
10:56:19 <Eduard_Munteanu> :t callCC
10:56:20 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
10:56:24 <Chousuke> FreeFull: I think the former is a side-effect while the latter is just an effect.
10:56:29 <alpounet> krakrjak, i never run those binaries so i don't mind
10:56:29 <FreeFull> aegis__: Just evaluating "print "foo"" doesn't do anything
10:56:43 <alpounet> but with TH it's like running any binary
10:56:44 <Eduard_Munteanu> fizruk: well what is your 'm'?
10:56:57 <FreeFull> > print "foo" `seq` 3
10:56:57 <lambdabot>   3
10:57:20 <Eduard_Munteanu> fizruk: because yeah, I think for m = [] for example, you can make  callCC = const []
10:57:35 <aegis__> FreeFull: so what is going on behind the scene to make those operations run sequentially? afaik lazy evaluation doesn't guarantee a specific order
10:57:39 <fizruk> Eduard_Munteanu: hm... that would take some time to introduce, are you interested?
10:57:52 <krakrjak> alpounet: :) ok.  I'd really try the shell out, set ulimits, try compile.  Then slowly open up the memory ulimits until you find a balance that compiles code, but won't exhaust the system so a couple of users can coexist.
10:58:13 <Chousuke> aegis: an opaque State monad and some magic.
10:58:22 <Eduard_Munteanu> fizruk: mm, I'm doing something else right now, so I can't commit to this
10:58:31 <danilo2>  Could somebody please look at this simple TH example and tell me why I;'m getting the error? I'm trying to simple generate type synonim with TH: http://lpaste.net/93769
10:58:50 <alpounet> krakrjak, so that doesn't even imply any modification to the code?
10:59:02 <FreeFull> aegis__: >>= guarantees order
10:59:18 <FreeFull> Because each thing you bind depends on the previous thing
10:59:24 <haasn> > "Hfeflflfo"^.splittingOn "f" folded -- unswedish
10:59:25 <lambdabot>   "Hello"
10:59:31 <aegis__> FreeFull: how? is it some built-in magic or some clever use of the language constructs?
10:59:41 <aegis__> FreeFull: oh
10:59:43 <fizruk> Eduard_Munteanu: actually, we may proceed with [] example for now if you have any ideas :)
10:59:48 <aegis__> FreeFull: ok, that makes more sense
11:00:04 <FreeFull> aegis__: It's just the same how to evaluate  3+(4+(5+6)) you need to first evaluate 5+6, and then 4+11, and then finally 3+15
11:00:42 <haasn> cc edwardk we need a swedish :: Iso String String
11:00:43 <FreeFull> Unless you are using something like lazy Naturals
11:00:53 <krakrjak> alpounet: yeah true.  I just saw your need about file system mitigation....  The best way there is to possibly run the resulting binaries as a special user.  You may need to use something like SELinux, LXC or extended attributes to constrain the execution.
11:00:56 <Taneb> haasn, it's only a prism
11:01:00 <haasn> more like a Prism String String, from to think of it
11:01:02 <haasn> yeah
11:01:04 <haasn> come to*
11:01:05 <edwardk> hah
11:01:13 <edwardk> it should be a prism actually
11:01:21 <haasn> But “from swedish” reads better
11:01:22 <haasn> so let's break the laws
11:01:26 <aegis__> FreeFull: yep, got it now. thanks a lot!
11:01:41 <edwardk> swedish # "hello"
11:01:51 <Eduard_Munteanu> fizruk: yeah, it does depend on your 'm' I guess. There might be some theoretical description of callCC on edwardk's blog, I've seen a more polymorphic one arising from Kan extensions. Perhaps that can give you some laws to prove.
11:02:28 <donri> so unswedish becomes "re swedish"?
11:02:36 <donri> the prism vocabulary continues to confuse me
11:02:36 <alpounet> krakrjak, and that's exactly the kind of things i have tried and had issues with :]
11:02:42 <donri> maybe re should be un
11:02:47 <edwardk> Eduard_Munteanu: Cont is just the right kan extension of a constant functor that ignores its argument along itself.
11:02:57 <alpounet> if you feel like giving it a go, the project sits here: http://github.com/alpmestan/core-online
11:02:58 <elliott> donri: in an ideal world, re and from would be the same
11:03:03 <elliott> we can get that, with pure profunctor lenses
11:03:08 <krakrjak> alpounet: hrm.... So where is the hard barrier?  Compilation or execution?
11:03:10 <danilo2> Sorry for asking the same question again, but maybe somebody knows why I'm getting "Cycle in type synonym declarations" in this example: http://lpaste.net/93769 ? :)
11:03:13 <elliott> donri: "un" would be a bad name
11:03:15 <donri> elliott: what's stopping it?
11:03:17 <elliott> because un _Just would construct a Just
11:03:20 <edwardk> donri: unswedish becomes "Hfeflflfo"^.swedish
11:03:21 <elliott> donri: we don't use pure profunctor lenses
11:03:28 <donri> edwardk: oh right
11:03:29 <edwardk> er ^?swedish
11:03:36 <donri> still weird :P
11:03:37 <krakrjak> alpounet: I'm pretty sure during compilation you don't need much in the way of mitigation other than resource constraints.
11:03:40 <elliott> anyway, I sort of think Prisms should be Unprisms by default so that "from _Just" reads right and it constructs as a getter or something...
11:03:42 <edwardk> :t Control.Lens.un
11:03:42 <Eduard_Munteanu> edwardk: fizruk was wondering if there are any laws callCC must satisfy
11:03:43 <lambdabot>     Not in scope: `Control.Lens.un'
11:03:43 <lambdabot>     Perhaps you meant one of these:
11:03:43 <lambdabot>       `Control.Lens.at' (imported from Control.Lens),
11:03:51 <edwardk> un is used to turn around a review
11:03:51 <donri> elliott: yeah
11:03:53 <haasn> @let translate = preview
11:03:53 <lambdabot>  .L.hs:166:13:
11:03:53 <lambdabot>      No instance for (MonadReader s0 m0) arising from a use of...
11:03:55 <edwardk> unto = un . to
11:04:00 <haasn> .... lambdabot has the DMR?
11:04:08 <tertl3-laptop> hu
11:04:25 <edwardk> maybe that is just in head
11:04:31 <alpounet> krakrjak, i had issues setting up selinux and lxc, for sure, big enough that I looked for others. Found nothing interesting, and well, it has stalled since then
11:04:41 <krakrjak> alpounet: have you looked at halvm?
11:04:51 <edwardk> elliott: sadly this requires breaking the 'lenses just work with base types' mantra
11:05:09 <elliott> edwardk: hmm, what do you mean by that?
11:05:17 <krakrjak> alpounet: it's a way of running haskell directly on the "bare metal" of a VM, thus giving a nice place to constrain access to the host system.
11:05:29 <edwardk> elliott: unprisms aren't compatible with the hack that we use to make traverse a valid traversal
11:05:46 <krakrjak> alpounet: https://github.com/GaloisInc/HaLVM
11:05:48 <alpounet> krakrjak, i don't have a vm there, just a usual dedicated server
11:06:12 <krakrjak> alpounet: sure not now, but if you have a dedicated server running linux, it's already a hypervisor.
11:06:30 <donri> edwardk: traverse a valid traversal??
11:06:43 <edwardk> donri: sure
11:06:50 <donri> isn't that a given
11:06:54 <edwardk> > [1,2,3,4] & traverse +~ 1
11:06:54 <lambdabot>   [2,3,4,5]
11:07:07 <edwardk> donri: not if you switch to pure profunctor lenses
11:07:12 <krakrjak> alpounet: so you could execute resultant binaries on a VM using HaLVM instead of trying to sandbox it on the host system.
11:07:35 <edwardk> donri: then a 'traversal' becomes (forall p. Representable p, Applicative (Rep p) => p a b -> p s t)
11:07:49 <donri> oh lenses, i had misunderstood elliott to only mean prisms (thus my confusion - they're already profunctorial?)
11:07:49 <edwardk> donri: and traverse doesn't have the right signature
11:07:56 <alpounet> krakrjak, that means spending quite a lot of time on this, and I really would like something quick to implement, so that I can release this. I'm not fond of these matters enough to enjoy investigating them on my free time :p
11:07:58 <fizruk> edwardk: what do I need to read to understand "Cont is just the right kan extension of a constant functor that ignores its argument along itself"?
11:08:04 <edwardk> donri: they are currently more complicated than they need be
11:08:08 <elliott> edwardk: right, well I don't care about impure profunctor lenses :)
11:08:12 <elliott> but yes, I was only talking about unprisms instead of prisms
11:08:15 <edwardk> fizruk: the type signatures ;)
11:08:15 <elliott> lenses seem the right way around to me
11:08:40 <Cale> danilo2: That is a weird problem
11:08:44 <elliott> basically I'd like the notion of a prism to be a getter with an affine traversal around the back
11:08:50 <fizruk> edwardk: am I supposed to learn kan extensions from type signatures? O_o
11:08:51 <elliott> just because it applies nicer with the terminology :P
11:09:27 <krakrjak> alpounet: hrm...  you really are in a pickle then.  Sandboxing general purpose binaries is not a solved problem for any language really.  You might say on the JVM you get some help here, but only through setting server side security policies in the runtime environment.  This is very tricky with Haskell programs (and C, C++, Perl, Python, etc.).
11:09:36 <edwardk> fizruk: newtype Ran f g a = Ran { runRan :: forall r. (a -> f r) -> g r } is the 'right kan extension of g along f'    newtype Cont r a = Cont { runCont :: (a -> r) -> r }
11:09:36 <danilo2> Cale: I've just found out it is a bug: http://ghc.haskell.org/trac/ghc/ticket/4364
11:09:47 <edwardk> that is Ran (Const r) (Const r) a
11:09:52 <edwardk> which is the same as Codensity (Const r)
11:10:04 <Cale> danilo2: That's reassuring at least
11:10:05 <edwardk> hence Codensity subsumes Cont
11:10:27 <edwardk> Codensity can also be seen as taking ContT and quantifying to hide the choice of 'r' from you.
11:10:48 <krakrjak> alpounet: you might get better guarantees out of BSD Jails instead of LXC if you don't have the opportunity to build a little infrastructure to integrate with HaLVM.
11:10:52 <danilo2> Cale: Exactly, but its not reassuring, that this bug is not fixed for over 3 years :(
11:11:56 <Cale> danilo2: http://ghc.haskell.org/trac/ghc/blog/Template%20Haskell%20Proposal explains the error better
11:12:32 <alpounet> krakrjak, yeah I guess. but i'm also annoyed that it's almost runnable for public consumption
11:13:05 <danilo2> Cale: I've been just reading it, thank you :)
11:13:17 <krakrjak> alpounet: yeah, but now you have to think about security and it's really hard.
11:13:35 <alpounet> yeah
11:13:59 <alpounet> i also hope some simpler solution will come and save that code
11:14:14 <krakrjak> alpounet: like really hard when you want to isolate core parts of the language from being able to run.  You need good sandboxing support from the OS and those features are sorely lacking outside of using a virtual machine of sorts.  Since LXC won't work, you don't have many options.
11:14:59 <krakrjak> alpounet: you could start removing language features in your ghc so that there are compilation errors when someone tries to compile code that does verboten things.
11:15:23 <krakrjak> alpounet: pretty sure that's a rabbit hole too.
11:15:57 <alpounet> krakrjak, that'd be too restrictive. i'd like us to be able to use that app for checking the core for code using the 'vector' library for example. that means i have to support what vector uses
11:16:04 <alpounet> i'd even like to have TH support
11:16:35 <alpounet> so the only safe path is to limit file system / network access + put resource limits
11:17:07 <krakrjak> as best I can tell that's the way forward...  getting all three is tough.
11:18:39 <dav> pqmodn: visi seems to be very close to what I've been looking for
11:18:54 <dav> pqmodn: thanks!
11:19:52 <krakrjak> I really do recommend giving BSD Jails a try and take a peek at HaLVM.
11:20:17 <krakrjak> for isolation/sandboxing, not much beats a VM.
11:21:30 <fizruk> edwardk: thanks, now it makes some sense to me. though I don't yet see any connection with callCC laws
11:22:55 <edwardk> fizruk: callCC is the thing you get when you can know 'r'. if you don't know 'r' you can't write it. e.g. Codensity Identity a = (forall r. (a -> r) -> r)   is almost Cont, you can write the same code for the monad, etc. but you can't write callCC.
11:23:02 <chrisdone> alpounet: you're making an online core viewer?
11:23:08 <alpounet> krakrjak, yeah that's just a bit heavier than i would have liked. Anyway the day i really want this released i'll just make sure these problems are solved
11:23:19 <alpounet> chrisdone, that part is done, I miss the security part
11:23:46 <chrisdone> alpounet: for tryhaskell's file loading i just whitelist the input with hse =o
11:24:20 <alpounet> chrisdone, can you say import Data.Vector?
11:24:22 <chrisdone> but i guess if you want to support any and every haskell file with arbitrary inputs… go go gadget VM
11:24:35 <krakrjak> alpounet: with HaLVM it's really not very "heavyweight" as the VM doesn't run a full OS+haskell program, it runs a miniature OS embedded from HaLVM and your code.  Boot times of miliseconds into the running program.
11:24:37 <chrisdone> umm. i don't remember whether that's on the whitelist
11:25:28 <chrisdone> (no, it's not on the white list. didn't put it there)
11:26:04 <fizruk> edwardk: ok, so it is impossible to make it the wrong way?
11:26:22 <alpounet> chrisdone, that was just an example anyway. I want to be able to run TH, let pasters import standard packages like vector and what not that would be installed in that environment, meaning it must support quite a few extensions
11:26:26 <edwardk> fizruk: pretty much =)
11:26:39 <alpounet> chrisdone, I think FP Complete does this with VMs, for SoH
11:26:48 <edwardk> fizruk: you get one legal choice
11:27:24 <chrisdone> alpounet: nod. i wanted to do the same thing for lpaste. i want to be able to paste code and see the core output, and rule firings, stuff like that. if you complete it, can i use your service via an API on lpaste? =p
11:27:26 <alpounet> krakrjak, how hard would it be to set up a hlvm instance for running ghc and with the limits and all?
11:27:58 <fizruk> edwardk: the thing is I have 2 implementations for my case (which are compiled but not tested yet)
11:27:58 <chrisdone> alpounet: yeah, fp complete launches isolated amazon VMs for SoH
11:28:01 <krakrjak> alpounet: it's two things.  compilation would happen on the host and execution would happen in the VM.
11:28:03 <alpounet> chrisdone, i'm far from an expert in VMs and sandboxing stuffs, I was hoping you'd do that part :P
11:28:14 <alpounet> err, halcm*
11:28:14 <chrisdone> haha
11:28:17 <alpounet> halvm*
11:28:38 <alpounet> krakrjak, no no no, i don't run the progams
11:28:48 <chrisdone> he just wants the core
11:28:51 <krakrjak> aahhhhhhhh
11:28:56 <alpounet> i run ghc on haskell code, and dump some intermediate representation of the code
11:28:59 <alpounet> (GHC Core)
11:29:05 <krakrjak> well in that case just having resource limits should be enough right?
11:29:22 <alpounet> chrisdone, i would actually prefer to somehow merge this in lpaste
11:29:26 <krakrjak> or are you worried about TH programs ejecting the CD-ROM during compilation?
11:29:29 <chrisdone> alpounet: \o/
11:29:36 <fizruk> edwardk: I wanted to ensure that both are valid
11:30:13 <chrisdone> alpounet: i'm also not familiar with sandboxing techniques, either
11:30:19 * monochrom advocates using TH to show popup ads during compilation :)
11:30:30 <krakrjak> if you really aren't going to run the programs then just sandboxing ghc should come down to resources (memory + cpu mostly).
11:30:59 <chrisdone> monochrom: HE INCREASED HIS MONOID INSTANCES IN TWO WEEKS. ORDER NOW
11:31:00 <krakrjak> there isn't really a way to do FS operations during compilation is there????!!!!
11:31:38 <pqmodn> Krakarn: http://ghc.haskell.org/trac/ghc/ticket/146
11:31:47 <pqmodn> er, krakrjak ^
11:31:56 <chrisdone> krakrjak: yeah there are various ways. TH the main one, but rules and CPP and other ways i don't remember
11:32:01 <alpounet> chrisdone, you have all the UI crap done already, better than I would do it (i gather from your posts and general activity (say, Fay) that you're a fluent web developer). so it'd really be about setting up the right restrictions and adapting my code to lpaste, that's the best choice AFAICT
11:32:21 <carter> question
11:32:23 <carter> why would
11:32:25 <alpounet> krakrjak, you can run any IO action
11:32:30 <carter> import  Data.CLIConfig(CLIOpts(..)) as DC  --- trigger a parse error
11:32:38 <krakrjak> pqmodn: yeah, but you can mitigate that by not using --make or by compiling from the source dir.
11:32:42 <carter> import  Data.CLIConfig(CLIOpts(..))  -- doesn't
11:32:52 <carter> offending error being " parse error on input `as'"
11:33:00 <krakrjak> alpounet: I see your pain much more clearly now....  UGH!!!!!
11:33:30 <chrisdone> alpounet: sure -- abstracting the code into a library and importing it in lpaste would be fine with me. i don't feel i'm up to learning about/setting up the right restrictions, though
11:33:31 <alpounet> krakrjak, http://hackage.haskell.org/package/template-haskell-2.8.0.0/docs/Language-Haskell-TH-Syntax.html#v:runIO
11:33:56 <krakrjak> yikes!
11:34:18 <bxc> way too many csv libraries
11:34:23 <chrisdone> i made a haskell binding to codepad a couple years back. i wonder if codepad can somehow be used
11:34:31 <krakrjak> so yeah, no ejecting the CD-ROM during compilation....  I'm surprised LXC didn't have your back here....
11:34:37 <stevely_> carter: you need to do "import qualified Data.CLIConfig(CLIOpts(..)) as DC"
11:34:52 * hackagebot sgf 0.1.3 - SGF (Smart Game Format) parser  http://beta.hackage.haskell.org/package/sgf-0.1.3 (tonicebrian)
11:34:59 <carter> stevely_: nope
11:35:00 <alpounet> chrisdone, if that security thing gets solved, i'll let you know and extract a library out of my code
11:35:05 <carter> you're allowed to do as without qualified
11:35:10 <chrisdone> alpounet: cool!
11:35:34 <krakrjak> alpounet: the biggest issue using Jails/LXC is the need for ALL the libraries and binaries you need have to live inside the container/jail.
11:35:57 <krakrjak> alpounet: this has caused me sleepless nights in the past trying to track down that one library that wasn't in the right part of the FS.
11:36:13 <alpounet> chrisdone, fwiw, my app already supports choosing the GHC version to use to build the Core. it's not really "reusable" as-is, but I can make all this easily integrable. that'll however most likely require installing something and setting it up on the server running lpaste
11:36:28 <krakrjak> alpounet: the biggest issue is getting the user running the container a SANE environment for thinks like LD_LIBRARYPATH, PATH, etc.
11:36:52 <alpounet> krakrjak, right, that's exactly the kind of headaches I'd like to avoid
11:37:01 <carter> http://lpaste.net/93771
11:37:08 <alpounet> i even had issues installing lxc and getting it to work, so I couldn't even get there
11:37:12 <chrisdone> if i knew sandboxing stuff i would've done core output on lpaste months ago D:
11:37:36 <krakrjak> alpounet: well you get to choose your headache...  Get it right once and it shouldn't bit-rot much as you will likely need a seperate container for each ghc version you support.
11:38:50 <krakrjak> alpounet: seriously give BSD Jails a shot.  You might find your headache gets a little smaller.  Start from FreeBSD and see if in a couple of hours you have something.
11:39:25 <chrisdone> donri said in fedora sandboxing is like one line
11:39:28 <carter> yeah
11:39:39 <alpounet> chrisdone, yeah I have a couple of ideas too. that'd get us the safety of running ghc online "for free", that means a lot of potential for lpaste improvements :)
11:40:01 <ski> Eduard_Munteanu : not sure i see the connection to `Hom'-functors
11:40:03 <alpounet> krakrjak, but that's FreeBSD specific right?
11:40:11 <carter> alpounet: chrisdone  for lxc made nice, check out docker, also notdan  did some great work for his paste.haskell.org tool using selinux
11:40:18 <carter> urm
11:40:20 <carter> wrong url
11:40:28 <carter> byorgey: whats the url for notdan's site?
11:40:29 <krakrjak> alpounet: it's BSD specific.  Also available on Open, Net and other variants of BSD.  LXC is Linux specific so.....
11:41:00 <krakrjak> If you want it in a POSIX manner, you just won't find a tenable approach.
11:41:03 <byorgey> carter: paste.hskll.org
11:41:04 <alpounet> well I can't just change the OS of the server, and i think chrisdone won't install freebsd just for this :P
11:41:25 <byorgey> it's not actually hosted on haskell.org
11:41:43 <Eduard_Munteanu> ski: if you refer to an indexed store comonad, you have: mapI :: (f'i -> i) -> Store i o a -> Store f'i o a   mapO :: (o -> f'o) -> Store i o a -> Store i f'o a
11:41:55 <krakrjak> well in that case....  ACLs + CAP approach (using a small C layer to set CAPs) in Linux might be a little nicer.
11:41:58 <alpounet> carter, i had big issues when trying to install docker IIRC
11:42:09 <Eduard_Munteanu> ski: mapI f'op (Store g a) = Store (g . f'op) a    mapO f (Store g a) = Store g (f a)
11:42:16 <alpounet> I know I tried it, I know I couldn't use it so dumped it, don't remember the exact reason
11:42:45 <chrisdone> codepad doesn't let me import System.Process =(
11:43:01 <Eduard_Munteanu> ski: where mapO is the "normal" mapFocus and mapI is the "deviant" one
11:43:29 <alpounet> krakrjak, wow that still looks quite involved
11:43:40 <alpounet> gah I wish I was fascinated by these things
11:44:06 <chrisdone> ah, codepad uses hugs
11:44:30 <ski> @where MonadFix_Cont
11:44:30 <lambdabot> "Value recursion in the continuation monad" by Magnus Carlsson in 2003-01-07 at <http://www.carlssonia.org/ogi/mdo-callcc.pdf> (there's also slides at <http://www.carlssonia.org/ogi/mdo-callcc-
11:44:30 <lambdabot> slides.pdf>)
11:44:32 <ski> fizruk ^
11:44:48 <ski> see e.g. properties starting at page 13 in the slides
11:44:54 <krakrjak> alpounet: there are no easy paths I'm afraid.  I'll look around some more.  I have a similar need and just haven't really explored the space yet.
11:45:35 <fizruk> edwardk: I've just tested those implementations, both are 'correct', yet 'non-classical' one also meets my needs
11:45:35 <alpounet> krakrjak, if you implement a simple solution that can easily be shipped in a library or directly on hpaste, you'd be my hero
11:45:48 <ski> Eduard_Munteanu : aye (though i'm not sure about the "normal" vs. "deviant" labels)
11:45:49 <alpounet> err, lpaste*, old habits
11:45:54 <Eduard_Munteanu> ski: now it seems like those two make a bifunctor  I^op x O x C -> I x O x C
11:45:58 <fizruk> ski: thanks, I'll look though them now! :)
11:46:03 <krakrjak> alpounet: and after reading through the capabilities(7) man page it appears it's not a restrictive set, mostly it's for adding aditional capabilities to a process.
11:46:27 <krakrjak> alpounet: no promises, but I'll look a little closer and see if there is an "easy" path.
11:46:34 <ski> Eduard_Munteanu : looks like a tri-functor ?
11:46:56 <Eduard_Munteanu> ski: yeah but the third one is identity
11:47:25 <ski> fizruk : the mention of Amr Sabry also suggests that he might have some paper or two mentioning laws for `callcc' ..
11:47:42 <alpounet> krakrjak, i don't mind installing some stuffs, tweaking a few config files. But when you have to spend hours on this, days after days, iit gets really annoying :p
11:48:40 <krakrjak> alpounet: no doubt.
11:48:45 <Eduard_Munteanu> ski: and if you take I^op x O alone, I think the two maps are just Hom(-, I) x Hom(O, -)
11:49:02 <ski> Eduard_Munteanu : also, something is amiss, the codomain shouldn't be a product category, afaiu
11:49:40 <ski> if `C' is the category of `a', then shouldn't the codomain be just `C' ?
11:50:01 <chrisdone> alpounet: i wonder if it would be fine to just have a virtual machine running that can only connect to the host on a single port. worst case scenario someone writes some code to hose the VM or make it output "spam" core, so you restart it with the base image or something
11:50:30 <krakrjak> alpounet: http://bit.ly/WDBfvp is worth a look.
11:50:42 <carter> do we have any merge Lists function in the prelude / base libs?
11:50:44 <carter> Ord a=> [a]->[a]->[a] ?
11:51:09 <alpounet> krakrjak, yeah I remember that article, I read it back when I was actively searching for solutions
11:51:12 <chrisdone> krakrjak: all that seems like a PITA
11:51:34 <krakrjak> alpounet: the traditional infrastructure is to set the compile user's homedir to a FS with a small quota, set ulimits then run in a container.
11:51:37 <alpounet> chrisdone, and have a "ghc-core server" running in it, speaking through that port to the web app?
11:51:58 <chrisdone> alpounet: thinking about this more, setting up a VM on a cheap OS (like freebsd) and then saving the image/resetting it if it gets messed up might be cheap
11:51:59 <chrisdone> alpounet: yeah
11:52:13 <chrisdone> "please compile this and give me some core back"
11:52:14 <krakrjak> yeah all this sandboxing stuff is HARD and only by gluing serveral technologies together do we get something usable.  Turns out the solutions are very maintainable even if they are a PITA to get off the ground.
11:52:55 <krakrjak> chrisdone: that's what I've done in the past for "ephemeral" systems.
11:53:04 <chrisdone> hmm
11:53:16 <FreeFull> I wonder how hard it would be to run a standalone Haskell program outside of a sandbox
11:53:21 <Eduard_Munteanu> ski: hm, I think you're right. Not sure how indexed comonads are represented in CT, but they probably are functors from a diagram category.
11:53:21 <FreeFull> So just on bare hardware
11:53:34 <FreeFull> I know there is a kernel written in Haskell but that's old code
11:53:37 <krakrjak> that's what HaLVM is up to.
11:54:04 <krakrjak> it's "bare metal" code leveraging Xen infrastructure so the "OS" code is downright tiny.
11:54:09 <alpounet> krakrjak, I think that if you put up a working solution for lpaste, we could pick it up, but none of us both will likely investigate this deeply enough apparently
11:54:26 <krakrjak> So for haskell program execution that's a good place to start.  For compilation.....  That is the question.
11:54:46 <krakrjak> alpounet: are you on a tight deadline?
11:55:06 <FreeFull> Xen isn't bare metal
11:55:27 <krakrjak> no, but it's a nice place to start.
11:55:33 <cschneid> what does cabal sandbox hc-pkg do?
11:55:47 <FreeFull> I guess there is Haskell on microcontrollers that some people have been doing recently
11:55:52 <krakrjak> the ghc iOS work can run on bare metal I believe.
11:56:21 <krakrjak> FreeFull: yeah on resource contrained devices having an OS between haskell and the hardware is a HUGE penalty.
11:56:27 <Eduard_Munteanu> ski: mapBoth :: (f'i -> i) -> (o -> g'o) -> Store i o a -> Store f'i f'o a,  so I'd guess Hom(-, I) x Hom(O, -) x Id :: (I^op x O -> C) -> (I x O -> C)   (where Hom is I-, respectively O-valued, so internal hom functors is the term I think)
11:56:40 <alpounet> krakrjak, well not really, and we can even use the VM approach first, if that works out well, until you have a better one :-)
11:57:00 <alpounet> thanks for the advices and for investigating this by the way!
11:57:44 <krakrjak> alpounet: I'll keep poking.  I have a tight deadline at work this week so I wouldn't lose any sleep waiting on me.  Knowing that others have this problem too though gives me some motivation to blow off work :)
11:58:02 <Eduard_Munteanu> ski: the kinds seem reasonable for normal Hask stuff: (* -> * -> *) -> * -> * -> *
11:58:59 <Eduard_Munteanu> ski: you can add mapValue as another covariant component.
12:00:10 <ktosiek> can I see how many arguments a type takes?
12:00:27 <Eduard_Munteanu> ktosiek: use :k here or in ghci
12:00:27 <ktosiek> in ghci
12:00:28 <haasn> :k
12:00:33 <alpounet> krakrjak, great! I wasn't expecting a cabal library in 2 hours in a github repo and passing tests through travis-ci. Thanks for investigating us, just let me know when you're up to something :-)
12:00:35 <haasn> Eduard_Munteanu: not here
12:00:37 <ktosiek> thanks!
12:00:46 <Eduard_Munteanu> Hm, I thought it worked, that and @kind.
12:00:51 <haasn> @kind
12:00:52 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
12:00:53 <alpounet> s/us/this/ damn autocorrect
12:01:00 <Eduard_Munteanu> Ah.
12:01:00 <ktosiek> @kind Parser
12:01:01 <haasn> @kind Either
12:01:01 <lambdabot> Not in scope: type constructor or class `Parser'
12:01:04 <lambdabot> * -> * -> *
12:01:07 <krakrjak> alpounet: will do!
12:01:08 <haasn> so it does
12:01:25 <ktosiek> well, not for all libraries tough :-)
12:01:34 <haasn> I thought that'd get fuzzy-parsed as @undo or something
12:02:38 <alpounet> chrisdone, if the VM approach is fine for a beginning, I'll just start to flesh out the library this week and ping you back with the repo when done
12:02:56 <fizruk> ski: "the axioms for callcc and A are well-known" (from Amr Sabry's paper "Note on Axiomatizing the Semantics of Control Operators"), following the rabbit...
12:03:14 <elliott> :k Int
12:03:15 <lambdabot> *
12:04:31 <Eduard_Munteanu> ski: actually if I unwrap Store as (i -> a, o) it seems to be identity on 'o', contravariant in 'i' and covariant in 'a'. I'm not sure which is the right interpretation.
12:04:51 <alpounet> carter, luite's talk is tonight right?
12:04:55 <carter> yup
12:04:59 <carter> its going to be fun
12:05:01 <carter> i'll be tired
12:05:03 <carter> but it'll be fun
12:05:06 <alpounet> ghcjs i guess?
12:05:10 <chrisdone> alpounet: sure!
12:05:37 <Eduard_Munteanu> ski: that'd make it Hom(-, I) x Hom(A, -) x Id_O
12:06:04 <Eduard_Munteanu> Actually, yes, I'm pretty sure this is the right interpretation.
12:06:05 <mimosa> hello, I am the packager for ghc for my distro Salix, but I'm just starting out with Haskell and there are some things I find confusing about the 'ecosystem'
12:06:17 <mimosa> is this a good place to ask?
12:06:26 <alpounet> sure mimosa
12:06:42 <Eduard_Munteanu> mimosa: yes, or if it's too GHC-guts-specific, there's #ghc as well
12:06:51 <carter> mimosa: ask!
12:07:06 <carter> to quote some irc channels "dont ask to ask, ask!"
12:07:07 <carter> :)
12:07:26 <geekosaur> @where justask
12:07:26 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
12:07:27 * monochrom uses "don't answer to answer, just don't answer"
12:07:43 <mimosa> I get the impression that it isn't good practice to install ghc and cabal and then everything else using cabal, is that right?
12:07:54 <mimosa> because it's a lot more work for the packager that way;)
12:08:11 <S11001001> mimosa: sounds like good practice to me
12:08:32 <carter> erm?
12:08:39 <mimosa> www.haskell.org recommends using 'distro packages'
12:08:43 <carter> really?
12:08:49 <carter> i think thats for installing GHC and Cabal
12:08:57 <carter> but letting cabal install your libs and haskell binaries
12:09:00 <alpounet> mimosa, depends on the system you're running, but these days the situation is okay, we have sandboxes in cabal itself (we used to have cabal-dev for solving these issues) so we don't pollute the user or global package dbs
12:09:02 <Clint> anyone know how long luite's thing is supposed to be this evening?
12:09:11 <carter> Clint: 1.5 hours of awesome
12:09:17 <Clint> ok
12:09:56 <monochrom> mimosa, how is it more work for the packager?
12:10:01 <mimosa> so I just need to make two packages (ghc and cabal) and I'm done?
12:10:04 <carter> yup
12:10:05 <carter> pretty much
12:10:15 <alpounet> that means less stupid constraints to solve for cabal, 'cause distro maintainers were having (they probably still are a bit?) hard headaches when choosing a compatible set of versions for the packages
12:10:21 <carter> yeah
12:10:23 <Ajdr> I have a list of tuples [(int,int,int),(int,int,int),(int,int,int)] and i want to add the last value of all the tuples, how would i do this; I know that i have to use map but how to i reference the item before in the list?
12:10:27 <mimosa> monochrom: more packaging (like, everything)
12:10:46 <mimosa> alpounet: headaches is what I want to avoid
12:10:47 <carter> mimosa: indeed, as alpounet  says, thats really all you should provide if you want to have a simple default starting point
12:11:00 <carter> cabal 1.18 + ghc 7.6
12:11:05 <S11001001> @ty traverseOf._3
12:11:06 <carter> well
12:11:06 <lambdabot> (Field3 (p a (f b)) (f t) a1 b1, Indexable Int p1) => p1 a1 (s -> b1) -> p a (f b) -> s -> f t
12:11:11 <carter> hrmm
12:11:12 <mimosa> arch is an example of a distro with many, many haskell-related packages
12:11:13 <carter> brb in a bit
12:11:32 <carter> mimosa: some people use arch, some people use os x
12:11:38 <alpounet> mimosa, one nice advantage of installing through distros is when there's a dependency on a C library though
12:11:44 <carter> true
12:11:50 <carter> but, thats a by hand relationsihp
12:11:54 <carter> for libs
12:11:55 <alpounet> yeah
12:11:56 <carter> not a systematic thingy
12:11:59 <S11001001> @ty folded._3
12:12:00 <lambdabot> (Applicative f1, Foldable f, Field3 t t a b, Indexable Int p, Contravariant f1) => p a (f1 b) -> f t -> f1 (f t)
12:12:05 <fizruk> ski: would that be a good idea to have these laws with MonadCont documenation?
12:12:10 <carter> mimosa: the simplest correct thing is providing ghc + cabal
12:12:25 <mimosa> so to sum up, in the past ghc + cabal might not have worled well, but these days it does?
12:12:31 <carter> it works great
12:12:32 <mimosa> *worked
12:12:48 <carter> any reasons that might be historically there, are now merely history
12:13:08 <carter> brb in a bit
12:13:09 <S11001001> Ajdr: what is the return type you want?
12:13:12 <monochrom> yeah, it seems that the only least confusing solutions are the two extreme solutions: almost nothing or absolutely everything
12:13:17 <Ajdr> int
12:13:20 <carter> yeah
12:13:23 <Ajdr> I think I've worked it out
12:13:24 <S11001001> Ajdr: you want a fold, not map
12:13:24 <mimosa> ok thanks! Second question: why would I not just use the generic ghc bindist? Stability? Performance?
12:13:26 <Ajdr> Yes
12:13:34 <carter> mimosa: no, thats fine
12:13:39 <carter> well
12:13:42 <carter> yeah
12:13:44 <Ajdr> I found it on haskell.org
12:13:44 <carter> if it works correclty
12:13:47 <carter> go for it
12:13:52 <Ajdr> Thanks though
12:14:06 <monochrom> normally, I just use the generic ghc bindist.
12:14:18 <mimosa> monochrom: but for a package?
12:14:30 <Nimatek> Hmm, so GHC seems to ignore llvm compiler options like -march or -mtriple, thus not cross-compiling anything.
12:14:30 <carter> mimosa: i'd maybe argue for pairing cabal/cabal-install 1.18 with ghc
12:14:31 <S11001001> Ajdr: so mismatch, build according to distro standards...
12:14:34 <monochrom> currently, I don't use it because it wants libgmp3, which is getting old
12:14:37 <carter> but thats something that they can do user side
12:14:45 <mimosa> (At the moment, all there is is a buildscript for Slack, that just unpacks the bindist)
12:14:49 <Ajdr> I'm still not sure on the syntex to get one item from the tuple and fold them together
12:14:55 <carter> cabal by default installs new binaries to ~/.cabal/bin
12:14:56 * hackagebot postcodes 0.1.1 - A library that gets postcode information from the uk-postcodes.com  http://beta.hackage.haskell.org/package/postcodes-0.1.1 (MatthewHall)
12:15:00 <carter> so that needs to be added to path
12:15:07 <carter> brb in a bit
12:15:16 <haasn> k0001: why isn't pipes-text out yet? :(
12:15:42 <mimosa> yes the libgmp thing came up for me previous packaging cycle
12:15:50 <S11001001> erm
12:15:52 <carter> oh yeah
12:15:53 <S11001001> mimosa: so mismatch, build according to distro standards...
12:15:56 <carter> you should have libgmp installed
12:16:20 <mimosa> yes but an *older* gmp is needed for the ghc bindist
12:16:26 <carter> urk
12:16:27 <carter> really
12:16:28 <carter> ok
12:16:30 <carter> well
12:16:33 <mimosa> I know ...
12:16:43 <carter> hop on #ghc and ask to be baby sat through bulding your own ghc
12:16:45 <monochrom> currently, I build from source, so it links againt libgmp10 instead. it is not really different from generic bindist
12:16:46 <carter> its not so hard with some guidance
12:16:57 <carter> i got my first ghc patch merged in yesterday!
12:17:01 <carter> well, today
12:17:18 <mimosa> well, www.haskell.org makes it look like just configure - make - make install !
12:17:27 <monochrom> http://www.vex.net/~trebla/haskell/I-built-GHC.xhtml
12:18:04 <mimosa> indeed, I've built it quite a few times - the trouble comes trying to make a package that follows distro guidelines and still works
12:18:29 <ski> fizruk : probably
12:18:47 <mimosa> thanks for the tip about #ghc though - could be useful for fine tuning
12:19:07 <monochrom> I don't know Salix conventions, so I can't decide whether the generic bindist already satisfies those conventions
12:19:45 <mimosa> monochrom: the conventions already find the whole 'bootstrapping' thing pretty icky
12:19:53 <mimosa> but there's no way round it
12:19:56 <monochrom> though the generic bindist is certainly quite relocatable. "./configure --prefix=/anywhere-you-like"
12:20:09 <mimosa> yes, that's not a problem at all
12:20:47 <mimosa> normally, a package is supposed to build on a vanilla system
12:21:17 <monochrom> oh, if the convention includes "must just need a C compiler", then it's time to quit altogether. what a draconian ancient requirement.
12:21:39 <mimosa> slackware ...
12:22:10 <mimosa> but still, it's ok if it can be justified, which is partly why I'm here ;)
12:22:15 <monochrom> well, an alternative is to start a political revolution to overthrow that tyranny
12:22:35 <mimosa> (I can quote you at the package quality control)
12:23:35 <ski> Eduard_Munteanu : fwiw, i'd say `mapBoth :: (i1 -> i0) -> (o0 -> o1) -> (Store i0 o0 a -> Store i1 o1 a)' ..
12:24:20 <Eduard_Munteanu> ski: yes. (Did I use a different thing?)
12:24:26 <monochrom> GHC has evolved to practically require a Haskell compiler to build, and that compiler has to look very much like an older GHC
12:24:41 <mimosa> anyway, thanks to everyone for your input. I will go with cabal 1.18 and ghc 7.6, and see how that works out
12:24:48 <chrisdone> alpounet: i'm thinking Damn Small Linux or Knoppix are looking like attractive candidates. if i can make a kind of "live CD" that contains the base OS + GHC then i can reset it with low cost
12:25:10 <monochrom> building by C is possible but a lot of manual work and is intended for porting to new hardware only
12:25:15 <ski> Eduard_Munteanu : i'm still not following `Hom(-, I) x Hom(O, -) x Id :: (I^op x O -> C) -> (I x O -> C)', though (nor "(where Hom is I-, respectively O-valued, so internal hom functors is the term I think)")
12:25:20 <ski> (nor "it seems to be identity on 'o', contravariant in 'i' and covariant in 'a'.","that'd make it Hom(-, I) x Hom(A, -) x Id_O")
12:25:33 <mimosa> alpounet: that's just what I'm hoping to do with Salix, which already has a Ratpoison ediion; I'd like to make an xmonad one
12:25:52 <mimosa> *chrisdone
12:26:05 <notdan> carter: argh, I ment to write a letter to the Haskell.org comittee about the domain, but I've been a little bit oveerwhelmed with the school work recently
12:26:25 <alpounet> chrisdone, and I think we can even put some basic resource limits (RAM, CPU) so that it'd practically nalmost never have to be reset, just in exceptional circumstances
12:26:43 <chrisdone> alpounet: right
12:27:22 <ski> Eduard_Munteanu : by this functor stuff, are you trying to capture the functor whose mapping on arrows is `mapBoth' ?
12:27:30 <Eduard_Munteanu> ski: according to the implementation of map* functions, it seems you can only pre/post-compose an arrow to the i -> a part in the store.
12:27:40 <Shin-LaC> I implemented dijkstra's algorithm in haskell, but the result is kind of ugly, and much more verbose than what I had in python: http://lpaste.net/3162330518205235200
12:27:44 <Shin-LaC> am I doing something wrong?
12:28:01 <ski> (according to *which* "implementation of map* functions" ? some implementation in source for `Store' ? something else ?)
12:28:34 <Eduard_Munteanu> ski: the only ones possible really, for indexed store comonads
12:29:04 <Eduard_Munteanu> The mapI and mapO I defined above.
12:29:23 <ski> Eduard_Munteanu : why can't you do "mapO f (Store g a) = Store g (f a)" ?
12:30:21 <Eduard_Munteanu> ski: that is alright... but that's the only possible implementation, no?
12:30:47 <ski> Eduard_Munteanu : but that doesn't agree with "you can only pre/post-compose an arrow to the i -> a part in the store", does it ?
12:31:05 <Eduard_Munteanu> ski: mapI f'op (Store g a) = Store (g . f'op) a
12:31:43 <Eduard_Munteanu> ski: also  fmap f (Store g a) = Store (f . g) a    is part of the picture I think
12:31:44 <Eduard_Munteanu> Err.
12:31:57 <Eduard_Munteanu> Yeah, that's fine, but I should use 'o' not 'a' there.
12:32:26 <ski> are you using `data Store i o a = Store (i -> a) o' or `data Store i o a = Store (o -> a) i' ?
12:32:39 <Eduard_Munteanu> ski: the former
12:32:59 <ski> mhm
12:33:45 <carter> notdan: do it
12:33:51 <ski> in any case, then your "mapO f (Store g a) = Store g (f a)" does indeed not "only pre/post-compose an arrow to the i -> a part in the store"
12:34:39 <Eduard_Munteanu> ski: yes, it's actually an identity functor for O, I was wrong at the beginning
12:34:58 * ski isn't sure what "an identity functor for O" is
12:35:23 <Eduard_Munteanu> ski: newtype Identity a = Identity a
12:35:45 <ski> but what has that got to do with `Store' ?
12:35:53 <Eduard_Munteanu> ski: data Store i o a = (..., o)
12:35:54 <acowley> carter: While building HEAD, I encountered an impossible happening with haddock, then an apparent bug in make (!?), and learned to resent the that "For Dummies" version doesn't do a quick build.
12:36:15 <carter> acowley: for dummies?
12:36:21 <ski> Eduard_Munteanu : also, does "it" in "it's actually an identity functor for O" refer to `mapBoth' or what ?
12:36:30 <acowley> Oh, and I was annoyed by the existence of sync-all, but it wasn't so bad afterall
12:36:38 <carter> acowley: ooo
12:36:38 <Eduard_Munteanu> ski: to mapO.
12:36:40 <acowley> carter: The instructions in the README.md
12:36:48 <acowley> carter: They don't talk about making a build.mk at all
12:36:55 <carter> acowley: do you mean chrisdone ?
12:37:15 <acowley> no, you've been telling me for a while that I should be testing HEAD
12:37:25 <ski> Eduard_Munteanu : well, it looks like a covariant functor to me. not sure why one would say it's an "identity functor"
12:37:36 <acowley> so this is my way of saying I'm finally doing so
12:37:44 <acowley> I'm not very efficient
12:37:52 <ski> (not anymore than not knowing why one might want to call `length *** id' and "identity function")
12:37:54 <acowley> But the build process really isn't too confidence inspiring
12:37:58 <carter> ok
12:38:08 <ski> (s/and/an/)
12:38:14 <acowley> I also have to decide if I want to break everything
12:38:20 <acowley> on my system
12:38:32 <carter> ahh
12:38:48 <carter> acowley: i think someone, mebe joelteon  was working on a way to have multiple ghcs install
12:39:03 <acowley> carter: If I had previously built my own GHC, brew would handle it
12:39:22 <acowley> carter: But the way I have it setup, I'll have to clobber my 7.6 install
12:39:26 <carter> urk
12:39:32 <carter> you could use the right flags
12:39:38 <carter> to select it for sandboxes
12:39:43 <acowley> Yeah, I'll try that
12:39:43 <carter> right?
12:40:07 <carter> cool
12:40:13 <carter> acowley: i'm amidst consulting stuff right now
12:40:14 <carter> ttyl?
12:40:21 <acowley> yeah, congrats are in order?
12:40:26 <Eduard_Munteanu> ski: you can newtype Foo i a o = Foo (Store i o a). Then fmap is just peeling layers, applying the function and wrapping them back.
12:40:29 <carter> acowley: INCOME
12:40:30 <carter> yes
12:40:36 <carter> means my other stuf will happen faster too
12:40:37 <acowley> awesome
12:40:38 <carter> less tress
12:40:49 <carter> i'll tell you this evening while live ircing the luite talk
12:40:50 <ski> Eduard_Munteanu : anyway, starting from `data Store i o a = Store (i -> a) o', iow basically `Store i o a = (a^i) * o', then `a',`i',`o' is probably objects from the same category. an alternative interpretation could be `Store i o a = Hom_C(i,a) * o' where `Hom_C(i,a)' and `o' are objects in `Set' (or something similar), and `i',`a' are objects in `C'
12:42:12 <ski> Eduard_Munteanu : in the former case (uncurrying for the arguments) we get `Store : C^Op * C * C -> C', in the latter case `Store : C^op * Set * C -> Set'
12:42:57 <ski> Eduard_Munteanu : if we fix a specific `a', partially applying, then we get `Store_a : C^Op * C -> C' or `Store_a : C^op * Set -> Set'
12:43:59 <Eduard_Munteanu> ski: I think the former is more realistic given Store is a comonad
12:44:13 <ski> Eduard_Munteanu : now, i'm not sure where your `Hom(-, I)' and `Hom(O, -)' are coming from; care to elaborate ?
12:44:53 <ski> (note that a difunctor probably doesn't need to have anything to do with `Hom'-functors)
12:45:49 <ski> Eduard_Munteanu : former as in not fixing an `a', or as in not using `Hom'-functors and `Set' ?
12:46:35 <Eduard_Munteanu> ski: for any category C, Hom(A, -) : A -> B |-> A -> C, f |-> g . f.
12:48:00 <carter> ttyl all
12:48:08 <Eduard_Munteanu> ski: for Hom(-, A), it maps A -> C to B -> C by postcomposing: f :: A -> C  |->  f . g :: B -> C
12:48:34 <Eduard_Munteanu> Err, Hom(-, C)
12:49:08 <Eduard_Munteanu> ski: now it seems like mapI and fmap are exactly that, there's no other implementation.
12:49:22 <kryft> Hmm, haddock documentation says that documentation for a top level declaration started with a --| continues until the first non-comment line; do blank lines count too?
12:50:06 <cschneid> how do I fix hoogle not finding its data: hoogle: Failed to download: http://hackage.haskell.org/packages/archive/00-hoogle.tar.gz
12:50:13 <Eduard_Munteanu> ski: the former === the one not involving Set, since comonads should be endofunctors (on some indexed category here)
12:50:24 <kryft> I want to write a general comment about the internals of a function that I don't want to include in the haddock documentation since it's not really relevant just for using the function
12:50:35 <ski> Eduard_Munteanu : afaiu, `Hom_C(A, -) : C -> Set' (given `A' an object of `C'), no ?
12:50:48 <ski> (iow, i don't understand "for any category C, Hom(A, -) : A -> B |-> A -> C, f |-> g . f.")
12:51:12 <alpounet> do you already use ErrorT in lpaste?
12:51:39 <ski> (and similarly `Hom_C(-, B) : C^op -> Set', when `B' is an element of `C')
12:53:09 <Eduard_Munteanu> ski: Hom(A, -) is an overloaded notation for both Hom(A, x \in Ob(C)) and Hom(A, f : Hom(x, y), x, y \in C)
12:53:18 <Eduard_Munteanu> (it's common notation AFAIK)
12:53:42 <fizruk> does test1 == test2 for any MonadWriter? http://lpaste.net/93775
12:54:17 <Eduard_Munteanu> ski: so Hom(A, B) is the set of arrows from A to B, and Hom(A, f) where f : B -> C is a map from Hom(A, B) to Hom(A, C) such that along with f you get a commutative triangle.
12:54:53 <ski> Eduard_Munteanu : for the morphism mapping, we could say `Hom(A, g) = (h |-> g . h)' with `g : B0 -> B1',`h : A -> B0' and `g . h : A -> B1', so `Hom(A, g) : Hom(A,B0) -> Hom(A,B1)'
12:54:56 <monochrom> "for any category C, Hom(A, -) : A -> B |-> A -> C, f |-> g . f." is botched. the "C" in "A->C" is not meant to be a category.
12:55:36 <Eduard_Munteanu> Err, yeah, thanks for catching that, monochrom.
12:56:04 <ski> Eduard_Munteanu : similarly in the other case, we could say `Hom(f, B) = (h |-> h . f)' with `f : A1 -> A0',`h : A0 -> B' and `h . f : A1 -> B', so `Hom(f, B) : Hom(A0,B) -> Hom(A1,B)'
12:56:24 <Eduard_Munteanu> ski: yeah
12:57:56 <ski> Eduard_Munteanu : *nod*
12:58:03 <ski> (Eduard_Munteanu : i still don't get "for any category C, Hom(A, -) : A -> B |-> A -> C, f |-> g . f." and "for Hom(-, C), it maps A -> C to B -> C by postcomposing: f :: A -> C  |->  f . g :: B -> C", though, even correcting for "the \"C\" in \"A->C\" is not meant to be a category.")
12:58:11 <ion> What is Hom an abbreviation for?
12:58:25 <Eduard_Munteanu> ion: homomorphism, I think
12:58:31 <monochrom> yeah
12:58:36 <ion> thanks
12:58:40 <Eduard_Munteanu> (nice escaping :D)
12:59:20 <ski> specifically, i don't get the "A -> B |-> A -> C" part
12:59:20 <monochrom> perhaps Mor is too Mordorish, and Arr is too Matey.
12:59:30 * ski likes `Mor'
12:59:51 <Eduard_Munteanu> ski: ah... I meant "it takes an arrow A -> B to another arrow A -> C"
12:59:52 <monochrom> "one does simply Yoneda into Mordor"
13:00:51 <Eduard_Munteanu> ski: given f : B -> C, it maps g : A -> B to (f . g) : A -> C
13:01:01 <ion> join me and we shall map the galaxy as father and son
13:01:05 <ski> Eduard_Munteanu : ok, so `(A -> B) -> (A -> C)' (or perhaps `Hom(A,B) -> Hom(A,C)'), then ?
13:01:18 <ski> (the `|->' in `A -> B |-> A -> C' threw me off)
13:01:33 <Eduard_Munteanu> ski: ah. Yeah.
13:01:41 <monochrom> or functor the galaxy as left adjoint and right adjoint
13:02:13 * ski . o O ( who frees the free functors ? )
13:02:32 <monochrom> I forgot who frees the free functors
13:02:44 <tac> I free the forgotten.
13:02:49 <shachaf> "free functor" means "left adjoint to forgetful functor". But "forgetful functor" means "right adjoint".
13:02:52 <Eduard_Munteanu> ski: now, for closed monoidal categories I think you can talk about the internal hom functor Hom(-, -) : C^op x C -> C. I probably want that to avoid going to Set.
13:02:56 <monochrom> tac wins
13:03:03 <ski> for `Graph', the left adjoint of the free functor (from `Set') is the connected components functor
13:03:06 <ion> We should have a demonstration somewhere and have signs that say “Free monad!”
13:03:24 <monochrom> @remember tac I free the forgotten.
13:03:24 <lambdabot> I will never forget.
13:04:21 <ski> shachaf : well, "forgetful functor" usually means some kind of projection (usually, but not always, being faithful)
13:04:45 <ski> Eduard_Munteanu : ok, so some variant of exponentials
13:06:47 <ion> I like how http://youtu.be/T3xXebIr8AM uses unsafeCoerce where realToFrac would be just fine.
13:07:22 <monochrom> yikes, haha
13:07:40 <acowley> I have a badly thought through question, if I have a functor, F, with a nullary constructor, and another functor, G, with a nullary constructor and a unary constructor. Is there a name for the relationship between them that lets me go from F -> G, but only G -> Maybe F ?
13:07:46 <ion> (:: Double → CDouble)
13:07:58 <Eduard_Munteanu> ski: anyway, I was aiming to get mapI doing Hom_I(-, I) : I^op -> I on the 'i' and fmap doing Hom_C(A, -) : C -> C on the 'a' in Store i o a
13:08:07 <shachaf> ion: Also just fine: CDouble
13:08:10 <acowley> ion: I seem to recall there was a time when the realToFrac rewrite wasn't reliable
13:08:17 <ski> shachaf : for universal algebra, an object consists of a couple of objects from the base category, and some operation morphisms involving these objects (and possibly some "constant/parameter objects"), and some (equational) laws relating the operations. then a forgetful functor might forget any combination of : (a) some objects; (b) some operations; (c) some laws
13:08:29 <haasn> acowley: a prism? :)
13:08:44 <monochrom> perhaps the author thinks the dual: "why use realToFrac when I know that unsafeCoerce is fine" :)
13:08:44 <acowley> haasn: Is that it really?
13:08:57 <napping> acowley: injection?
13:08:58 <haasn> Prism s a ~ (s -> Maybe a, a -> s) -- acowley
13:09:12 <ski> Eduard_Munteanu : how is `I' a category here ? did you mean `Hom_I(-, I) : C^op -> C' ?
13:09:24 <acowley> It's because you look like an idiot when converting Double -> CDouble and you end up doing something other than an unsafeCoerce
13:09:29 <acowley> maybe I should look at the video, though
13:09:42 <Eduard_Munteanu> ski: well 'I' could be the same category as 'C', but not necessarily
13:09:44 <acowley> but I know I've done the same thing myself in the past when dealing with a newtype around CDouble
13:09:55 <acowley> haasn: well, huh
13:10:20 <ski> Eduard_Munteanu : well, iiuc, you pass `I' as the first argument of `Hom(-, -) : C^op x C -> C', no ?
13:10:42 <ski> (or `i' .. anyway, the object)
13:11:40 <Eduard_Munteanu> ski: I in Hom(-, I) is an arbitrary fixed object 'I' in the 'I' category.
13:11:43 <ion> shachaf: Well, actually GLdouble, which is an alias to CDouble at the moment. I’d use realToFrac to be slightly safer against bitrot.
13:12:14 <Eduard_Munteanu> ski: or I \in Ob(C) if I = O = C as categories.
13:12:25 <edwardk> acowley: we have a _Just prism and a _Nothing prism that do just that
13:12:33 <ski> Eduard_Munteanu : .. also, i'm not sure why you pass `I' as second argument and `A' as first argument to the `Hom' in `Hom_I(-, I) : I^op -> I' and `Hom_C(A, -) : C -> C' -- since you had `data Store i o a = Store (i -> a) o', iow more or less `Store (i,a,o) = Hom(i,a) * o'
13:12:44 <acowley> edwardk: I'm trying to think about composing the selector functors in machines
13:12:51 <ski> (i.e. why not the other way around ?)
13:12:59 <acowley> edwardk: It's rather clumsy combining features
13:13:00 <acomar> acowley: So I've been digging into the clang compilation problem all day -- found out that it has nothing to do with bindings-dsl. hsc2hs inserts an fputs wrapper function, presumably for use from your haskell program, and that wrapper takes a void* argument which is passed directly without casting.
13:13:15 <ski> clearly, in `Hom(i,a)', `i' and `a' ought to be in the same category ?
13:13:24 <ski> or is `i' coming from a subcategory of `C' ?
13:13:25 <Eduard_Munteanu> ski: mapI g (Store f o) = Store (f . g) o
13:13:46 <acomar> acowley: The real problem here is that we're using a c++ compiler, pretending it's a c compiler, and passing it both c and c++ sources. We really need a set of tools for working with C++ sources...
13:14:14 <acowley> acomar: If that's the only problem, should we just patch the generated wrapper in a post processing step? Or is that one step too far towards madness.
13:14:17 <ski> Eduard_Munteanu : what about `mapI' ?
13:14:51 <acomar> acowley: you mean the temporary .c/.h files that are created by hsc2hs?
13:14:59 <acowley> acomar: yeah
13:15:19 <Eduard_Munteanu> ski: mapI :: (i2 -> i1) -> Store i1 o a -> Store i2 o a. If you rearrange Store's arguments, it's a contravariant functor in I.
13:15:40 <ski> Eduard_Munteanu : `mapI' is the morphism-mapping part of a functor from `C^op' to `C', afaics
13:15:55 <acomar> acowley: that's crazy, but it's either that or patch hsc2hs -- and upstream by all rights should reject our patch since it's only correct when you pass the tool a C++ compiler and tell hsc2hs it's a C compiler...
13:16:20 <acowley> I think we need to fork GHC to have soft-float and hard-float versions. This is the only way to prevent some of the threads that keep popping up.
13:16:28 <ski> Eduard_Munteanu : i'm not sure how this would be related to your `Hom_I(-, I) : I^op -> I' or `Hom_C(A, -) : C -> C' (whatever it means)
13:16:30 <Eduard_Munteanu> ski: yes. And I'm saying that's not just a functor from C^op to C, but Hom(C, -), assuming all three categories are C.
13:16:35 <acowley> acomar: So it's crazy or crazy?
13:16:40 <Eduard_Munteanu> Err, Hom(-, C), sorry.
13:16:45 <acomar> acowley: both :P
13:17:02 <acowley> acomar: If you say clang++ will take -fpermissive, then I guess we can just put that in the .cabal file and be done with it?
13:17:13 <acomar> acowley: it won't, it's not a supported option
13:17:19 <acowley> Oh geese
13:17:20 <ski> Eduard_Munteanu : what do you mean by the part "but Hom(-, C)" ?
13:17:21 <acomar> acowley: g++ takes it, clang++ doesn't
13:17:24 <acowley> well then I vote for crazy
13:17:48 <acomar> yea
13:17:54 <acowley> I guess dcoutts could save us with separate handling for .c and .cpp files?
13:18:02 <acomar> not in this case
13:18:08 <ski> Eduard_Munteanu : `Hom(-, C)' would be a specific functor. are you claiming `mapI', which is a functor from `C^op' to `C', is equal to that functor ?
13:18:10 <acomar> what we really want is a hscpp2hs
13:18:12 * ski is confused
13:18:19 <Eduard_Munteanu> ski: yes
13:18:23 <acomar> *and* separate handling for .cpp files
13:18:26 <acowley> When not even dcoutts can save us, then these are truly in desperate times
13:18:30 <dcoutts> heh
13:18:39 <ski> Eduard_Munteanu : and `C' here is what ? a category ? yet another object of the category `C' ?
13:18:41 <acowley> hscpp2hs2cpp2perl
13:19:14 <Eduard_Munteanu> ski: in 'Hom_C(A, B)', C is a category, A and B are in Ob(C).
13:19:20 <ski> yes
13:19:23 <dcoutts> acowley: I've always felt that mixing in C++/Obj-C files with the c-files was a recipe for problems
13:19:24 <acomar> speaking of which, even once I figure out how to edit the generated header and source, it's going to be really fun to figure out the right sed command to make this work...
13:19:34 <ski> but i don't understand `Hom(-,C)', unless `C' is also an object
13:19:39 <dcoutts> acowley: but I was persuaded to allow it, people claimed it worked :-)
13:19:40 <Eduard_Munteanu> ski: sure it is
13:19:44 <acowley> dcoutts: Yeah, it's pretty amazing how much that mechanism has been stretched
13:19:57 <ski> (also is `Hom' here `Hom_C', or `Hom_X' for some other category `X' ?)
13:20:01 <acomar> dcoutts: it works...sort of, with a lot of caveats
13:20:12 <dcoutts> it's ok if we can distinguish by file extension
13:20:19 <dcoutts> but that's not the case for .h files
13:20:37 <acomar> yea, part of the problem is how include works in C
13:20:49 <Eduard_Munteanu> ski: above I was talking about a separate index category I, but we can assume it's the same as O and C if you want
13:20:54 * dcoutts disappears
13:21:16 <ski> Eduard_Munteanu : what is the relation of the object `C' to the objects `I',`O',`A' ?
13:21:46 <acomar> ok... so when cabal runs hsc2hs, it produces a .hs file, a .h file, and a .c file, and I need to edit the latter two, right?
13:21:55 <Krook> Hey there guys! I'm getting some stupid errors i can't get the hang of!
13:22:13 <Eduard_Munteanu> ski: in the usual Haskell indexed store comonad, you have (i, o, a :: *) and we can call that '*' C.
13:22:33 <Krook> http://pastebin.com/Q7DJ5e4s It gives me parse error on the getCubes at the far bottom.. :/
13:22:36 <mauke> The paste Q7DJ5e4s has been copied to http://lpaste.net/93777
13:23:27 <ski> Eduard_Munteanu : but that talks about the category `C', no ? what about the object `C' you introduced in `Hom(-, C)' ?
13:23:34 <osa1> what is Unf part in this Core code http://lpaste.net/93776 ? Arity is first specified as 1 but then in Unf it's 0 ..
13:23:35 <acowley> acomar: What needs to change in the .h?
13:23:49 <napping> you need parentheses around the list pattern, like (r : s : k : [])
13:23:55 <Krook> aah, thanks!
13:24:04 <napping> because you're including the end, you could alwo write [r,s,k]
13:24:26 <ski> Krook : `getCubes r : s : k : []' is parsed as `(getCubes r) : s : k : []' which in this case is not what you wanted
13:26:16 <chrisdone> hmm, i wonder if you could translate javascript to haskell for type checking
13:26:27 <ski> Krook : `getCubes firstSplit ++ getCubes secondSplit ++ getCubes thirdSplit' could also be written as `[cube | split <- [firstSplit,secondSplit,thirdSplit] , cube <- getCubes split]' or as `concatMap getCubes [firstSplit,secondSplit,thirdSplit]'
13:26:31 <haasn> chrisdone: build a JS EDSL
13:26:35 <acomar> acowley: actually, it's just *_utils_hsc.c
13:26:42 <chrisdone> haasn: no
13:26:50 <haasn> chrisdone: :(
13:26:57 <acomar> acowley: it includes a function -- hsc_fputs(const char *s, void *stream)
13:27:00 <haasn> I want to see how close you can get to actual javascript
13:27:07 <acomar> that stream parameter is passed without a cast
13:27:10 <haasn> using just syntax magic and notation hacks
13:27:14 <acomar> to stdio fputs
13:27:16 <chrisdone> haasn: there's hjscript and sunroof for that
13:27:22 <acowley> acomar: So you just need to (FILE*) it?
13:27:30 <acomar> acowley: right, except here's the thing
13:27:30 <Krook> THis gives me non exhaustive patterns :/ http://pastebin.com/r8gSVXh6
13:27:33 <mauke> The paste r8gSVXh6 has been copied to http://lpaste.net/93778
13:27:36 <ski> Krook : or like `do split <- [firstSplit,secondSplit,thirdSplit]; getCubes split' or `[firstSplit,secondSplit,thirdSplit] >>= getCubes' or `getCubes =<< [firstSplit,secondSplit,thirdSplit]' is you like the list monad
13:27:46 <acomar> acowley: hsc2hs automatically attempts to compile the files immediately
13:27:50 <ski> (otherwise, ignore the last thing i said)
13:27:58 <acowley> hahah, oh man
13:28:12 <acomar> acowley: it doesn't want to compile the files with the rest of the program
13:28:14 <acomar> *wait
13:28:20 <Krook> ski would you mind chatting a little bit? I got some questions
13:28:22 <Eduard_Munteanu> ski: mapI (g :: J -> I) (Store (f :: I -> A) o) = Store (f . g :: J -> A) o  ::  (J -> I) -> Store I O A -> Store J O A
13:28:35 <haasn> chrisdone: err, http://hackage.haskell.org/package/HJScript needs to be updated to hub.darcs.net:/stepcut/hjscript
13:28:36 <Eduard_Munteanu> ski: in this case we have Hom(-, A)
13:28:38 <ski> Krook : am i not currently chatting ?
13:28:39 <haasn> sans the :
13:28:43 <acowley> So you need to put a wrapper around the C++ compiler that will run on sed on the source before passing the files to the real C++ compiler
13:28:44 <acowley> !
13:28:59 <acomar> acowley: that's even crazier
13:29:07 <acowley> In for a penny, in for a pound
13:29:09 <acomar> holy crap that's crazy
13:29:19 <Krook> Yeah ,but in a tab with just us.
13:29:50 <Eduard_Munteanu> ski: Hom(-, A) :: C^op -> C, Hom(g, A) maps the 'f' in Store f a to 'f . g'.
13:30:26 <ski> Eduard_Munteanu : looks more like `Hom(-,A) * O', to me ..
13:30:43 <Krook> THis gives me non exhaustive patterns :/ http://pastebin.com/r8gSVXh6
13:30:44 <mauke> The paste r8gSVXh6 has been copied to http://lpaste.net/93778
13:30:44 * hackagebot git-annex 4.20131002 - manage files with git, without checking their contents into git  http://beta.hackage.haskell.org/package/git-annex-4.20131002 (JoeyHess)
13:31:07 <Eduard_Munteanu> ski: yes, I omitted it because it doesn't touch it.
13:31:24 <acomar> acowley: ok hsc2hs has a --no-compile option... so we intercept cabal's preprocessing step, tell it to run hsc2hs with the --no-compile and -k options, edit the files, then run the appropriate compile command, then continue on as normal
13:31:36 <ski> Krook : why not in here ? more people can look at your code and possibly come with suggestions, and more people can lurk at the discussion and perhaps learn some
13:32:12 <ski> Krook : your `takeCubes' doesn't handle the empty list case
13:32:41 <ski> Krook : perhaps you meant to write `rs' in place of all the four places you wrote `(r:rs)' ?
13:32:51 <Eduard_Munteanu> ski: so we have 3 functorial maps:  mapI ~ Hom(-, A) * O,  fmap ~ Hom(I, -) * O,   mapO ~ Hom(I, A) * -
13:33:27 <ski> Eduard_Munteanu : well, `Hom(-,A)' is a functor from `C^op' to `C', while `Hom(-,A) * O' is *another* functor from `C^op' to `C'
13:33:30 <Krook> no, i did mean the entire thing, i added an empty case for the takeCubes and i still got non exhaustive pattern >: ( stupid haskell!
13:33:45 <acowley> acomar: In hsc2hs, the generated C does the cast to FILE when calling fputs, right?
13:34:02 <acomar> acowley: no, that's the problem, it doesn't
13:34:08 <acowley> acomar: https://github.com/ghc/hsc2hs/search?q=fputs&ref=cmdform
13:34:26 <Eduard_Munteanu> ski: err, you have two 'Hom(-, A)' there
13:34:31 <ski> Eduard_Munteanu : in short, `Hom(-,A) * O' corresponds to your `i |-> Store i o a' functor, while `Hom(-,A)' does not
13:34:38 <Eduard_Munteanu> Oh.
13:34:40 <acomar> acowley: What on earth... that's not what it's generating
13:35:03 <fizruk> Krook: its getCubes giving error
13:35:19 <fizruk> Krook: you handle only [] and [r, s, k] cases
13:35:26 <acomar> acowley: ahh, yea, check out the 7.6 branch
13:35:32 <acomar> acowley: it's missing that cast
13:35:36 <acowley> Okay
13:35:40 <Krook> fizruk what should i add/change to make it work?
13:35:41 <acowley> fixed oct 19 2012
13:35:58 <acowley> https://github.com/ghc/hsc2hs/commit/9671202c11f7fe98e5b96d379532b6f691dc46dd
13:36:01 <acomar> so once again
13:36:02 <Eduard_Munteanu> ski: yes, I left it out initially because it's an identity on O.
13:36:05 <ski> Krook : i see no handling of the empty list for `takeCubes' at <http://lpaste.net/93778> -- also `getCubes' doesn't handle the cases with an input list having (a) just a single element; (b) just two elements
13:36:07 <acowley> acomar: 7.8 to the rescue!
13:36:10 <acowley> :P
13:36:11 <acomar> for I think the 20th time on this project
13:36:22 <acomar> I've run into a "just upgrade to HEAD" issue
13:36:23 <ski> Eduard_Munteanu : i still have no idea what "it's an identity on O" is supposed to mean :)
13:36:27 <fizruk> Krook: and in the takeCubes definition you call getCubes [firstSplit (r:rs)] (i.e. getCubes [x], where x =...)
13:36:28 <acowley> We need a moratorium on all Haskell bug fixing until 7.8 is released
13:36:30 <Krook> ski i added it here, i just didn't send that pastebin. I've tested with that basecase
13:36:44 <acomar> who do we bug to get it released faster?
13:37:49 <acowley> Well, I bug carter because I don't like bugging thoughtpolice too much, but I think I've exhausted that avenue. So I built HEAD today.
13:37:57 <Krook> still nonexhaustive (updated) http://pastebin.com/DyJffRCW
13:38:03 <mauke> The paste DyJffRCW has been copied to http://lpaste.net/93780
13:38:04 <carter> acowley: well, i don't have commit powers
13:38:08 <carter> i think thoughtpolice  is sleeping now
13:38:10 <carter> or at least i hope so
13:38:14 <acowley> I know, it's just satisfying to bug somebody
13:38:19 <fizruk> Krook: did you mean getCubes [firstSplit (r:rs), secondSplit (r:rs), thirdSplit (r:rs)] ?
13:38:21 <acowley> makes me feel like I did my part
13:38:29 <carter> acowley: testing things is like the most valuable thing everrrr
13:38:34 <ski> Krook : still missing cases (a) and (b) above for `getCubes'
13:38:36 <acowley> carter: Yeah
13:38:48 <Krook> firstSplit , thirdSPlit and Secondsplit returns a list with 3 lists in it that contains 9 elements each
13:38:48 <carter> acowley: have you met leroux ? he's doing epic amounts of help testing GHC lately
13:38:55 <carter> like, i don't want to imagine him not helping out
13:38:57 <acowley> carter: Well, haddock crashes everything hard. So we're not ready for release
13:39:09 <carter> acowley: yeah, isn't that due to goeff's simd?
13:39:10 <Krook> I want to take 3 out of each and turn inte a 9 element list, and then the middle three from the same list, and lastly the last three
13:39:13 <gseitz> I'm in need of a monotonic clock. does anybody have experience with either the system-time-monotonic or clock package?
13:39:24 <Eduard_Munteanu> ski: it's common notation to lump functors together like mapI x id_O, which maps f :: J -> I to (mapI f) :: I -> J and g :: O -> O' to g :: O -> O'
13:39:29 <gseitz> or is there something in base that does a similar job?
13:39:52 <acowley> carter: I think it's http://ghc.haskell.org/trac/ghc/ticket/8276
13:40:13 <carter> could be
13:40:39 <ski> Krook : i suggest simplifying `firstSplit (r:rs) = take 3 (r:rs); firstSplit [] = []' to simply `firstSplit rs = take 3 rs', since the latter clearly does the same thing as the former -- and similarly for `secondSplit' and `thirdSplit'
13:40:51 <Eduard_Munteanu> ski: er, ignore that bit, it's more confusing.
13:40:54 <ski> (Krook : try yourself with `take' and `drop', passing an empty list)
13:41:29 <fizruk> Krook: could you supply an example for takeCubes?
13:41:52 <Eduard_Munteanu> ski: anyway, did I make myself clear on how mapI acts like Hom(-, I) on the i -> a component of the store?
13:43:01 <ski> Krook : also, i suspect that where you write `getCubes ([firstSplit (r:rs)])' you really intended `getCubes (firstSplit (r:rs))' (and similarly in the other two cases)
13:43:02 <Krook> fizruk http://pastebin.com/S1uqdEwm That's what i want to run through the function. I want it to give me all the "Cubes" in a sudoku
13:43:07 <mauke> The paste S1uqdEwm has been copied to http://lpaste.net/93781
13:43:18 <Krook> ski i am so deep now i've lost myself.
13:43:20 <Krook> haha
13:43:26 <ski> Krook : `[firstSplit (r:rs)]' is a list that has exactly one element, namely the list of lists returned by `firstSplit (r:rs)'
13:43:56 <Krook> if i am not mistaked firstSplit returns a list with 3 lists in it
13:44:03 <ski> Krook : if you just wanted to pass the list of the first three lists of `r:rs' to `getCubes', then you probably wanted `getCubes (firstSplit (r:rs))'
13:44:27 <ReinH> Krook: you might be interested in Richard Bird's sudoku solution. It's brilliant.
13:44:31 <ski> Krook : yes, `firstSplit (r:rs)' is a list with the first three lists in it
13:44:40 <Krook> i could translate my comments and upload the whole thing?
13:44:44 <Krook> ski
13:44:56 <ski> Krook : `[firstSplit (r:rs)', however, is a list with a *single* element, namely that list with teh first three lists (from `r:rs')
13:45:01 <Krook>  might simplify understanding for someone better then m,e.
13:45:05 <ReinH> and also excellent for learning
13:45:41 <ski> Eduard_Munteanu : no, what is the `I' doing in the right argument in `Hom(-,I)' ?
13:46:27 <Eduard_Munteanu> ski: I cleared that up above, it should be 'A', not 'I'.
13:47:50 <fizruk> Krook: it is not clear whether [[Maybe Int]] represents list of rows or columns or cubes, which one is it?
13:47:58 <Eduard_Munteanu> ski: there's fmap that acts like Hom(I, -) though, because fmap (f :: A -> B) (Store (g :: I -> A) o) = Store (f . g :: I -> B) o
13:48:29 <Krook> [[Maybe Int]] is the rows
13:48:58 <Krook> I'm working on translating my comments now and i'll upload it shortly. SHould not be to hard to understand for someone experienced. This is the only function that's so much of a trouble.
13:51:49 <Krook> ski http://pastebin.com/DZ6dfAvS
13:51:50 <Eduard_Munteanu> ski: and it seems mapO (f :: O -> P) (Store g (o :: O)) = Store g (f o :: P) is rather different from mapI (which was the "deviant" variant of mapFocus)
13:51:53 <mauke> The paste DZ6dfAvS has been copied to http://lpaste.net/93782
13:51:53 <Krook> fizruk http://pastebin.com/DZ6dfAvS
13:51:53 <mauke> The paste DZ6dfAvS has been copied to http://lpaste.net/93782
13:51:57 <Krook> there you have the whole thing
13:52:23 <Krook> Should clear things up. Maybe you can even help me. I am TOTALLY lost on getting the darn cubes out of the sudokuy.
13:54:29 <ski> Eduard_Munteanu : ok, so i still think it should be `Hom(-,A) * O', not `Hom(-,A)'
13:54:54 <ski> Eduard_Munteanu : while "there's fmap that acts like ..." should be `Hom(I,-) * O'
13:54:55 <Eduard_Munteanu> ski: yes, that's alright
13:55:06 <Cale> Krook: When I wrote a solver (whose representation of a board was an array from pairs of integers to integers), I used the fact that dividing the position's coordinates by 3 will tell you which box it lies in.
13:55:14 <Cale> (i.e. using div)
13:55:47 <Eduard_Munteanu> ski: and mapO is like Hom(I, A) * -
13:56:05 <ski> yes
13:56:20 <ski> (in fact, that *is* the morphism mapping part of that functor)
13:56:30 <Eduard_Munteanu> Yeah.
13:56:51 <ski> Eduard_Munteanu : so, backtracking. what were we talking about before we got bogged down in notation ? :)
13:57:44 <Cale> Krook: You could do something like: [((i `div` 3, j `div` 3), x) | (i,xs) <- zip [0..] board, (j,x) <- zip [0..] xs]
13:58:06 <Cale> Krook: this pairs the entries with the coordinates of the box they lie in
13:58:08 <ski> (btw, i still don't see how "according to the implementation of map* functions, it seems you can only pre/post-compose an arrow to the i -> a part in the store." could be right. maybe you amended this one, though)
13:58:11 <Eduard_Munteanu> ski: I was saying the normal mapFocus is Hom(-, A) * S, and the other one is Hom(S, A) * -
13:58:21 <Eduard_Munteanu> ski: err, the other way around :)
13:58:33 <aranea> Hi. I wrote a small prisoners dilemma simulator, https://github.com/atlaua/prisoners-dilemma . The code for playN (Pd.Master) looks a bit messy to me. Could that be done better?
14:00:31 <Eduard_Munteanu> ski: and I think for indexed monads you want mapBoth to be bifunctorial, that is Hom(-, A) * -, and from that I think you can get some constraints on the non-indexed store comonad.
14:00:43 <ski> (hm, you had something with "and if you take I^op x O alone, I think the two maps are just Hom(-, I) x Hom(O, -)","actually if I unwrap Store as (i -> a, o) it seems to be identity on 'o', contravariant in 'i' and covariant in 'a'. I'm not sure which is the right interpretation.","that'd make it Hom(-, I) x Hom(A, -) x Id_O" which i'm not sure whether you'd amended either)
14:00:59 <monoidal> aranea: hlint will give you simple transformations
14:01:00 <Eduard_Munteanu> ski: yes
14:01:22 <ski> well, indexed monads should be difunctorial
14:01:44 <Eduard_Munteanu> ski: is that different from bifunctorial?
14:01:53 <ReinH> kryft: for "cubes" do you mean the 3x3 subgrids?
14:02:00 <ski> a bifunctor from `A' and `B' to `C' is a functor from `A * B' to `C'
14:02:06 <ski> a difunctor from `A' and `B' to `C' is a functor from `A^op * B' to `C'
14:02:13 <ReinH> oh he's gone
14:02:20 <Eduard_Munteanu> ski: oh, right, that's what I was aiming for.
14:02:27 <ReinH> Cale: the Bird solution is elegant. It uses chunksOf
14:02:32 * Eduard_Munteanu didn't know the word for it
14:02:33 <aranea> monoidal: I'm not talking about simple style errors like the one hlint finds, but that whole algorithm
14:02:59 <aranea> everything from playN to genPairs
14:03:10 <ReinH> Cale: map concat . concat . transpose . chunksOf 3 . map chunksOf 3 -- iirc
14:03:38 <ski> Eduard_Munteanu : for some reason i don't know, it appears "profunctor" is the new hip term for "difunctor"
14:04:24 <Eduard_Munteanu> ski: so anyway, I think both variants of mapFocus are fine, and you can probably come up with a third implementation by mapping both things "halfway".
14:04:31 <acowley> pffff, difunctors are for amateurs
14:04:57 <fizruk> Krook: see what ReinH wrote ^
14:05:11 <ski> -!- Krook [51ea9fe8@gateway/web/freenode/ip.81.234.159.232] has quit [Quit: Page closed]
14:05:14 <ReinH> fizruk: he's gone :)
14:05:46 <ski> acowley : why ?
14:06:13 <fizruk> ReinH: okay then :)
14:06:24 <ReinH> the whole thing is a great object lesson though http://www.cs.nott.ac.uk/~gmh/sudoku.lhs
14:06:26 <acowley> ski: because profunctors are obviously not for amateurs
14:06:30 <rck> I'm trying to understand context of "do" outside the IO monad. I understand it desugars into >>, and >>=, and this makes sense to me in IO. what monad do I get for a pure function? ex: Person = { name :: String, age :: Int}; parseTypes :: ByteString -> Person; parseTypes line = do let [n, a] = ByteString.split ',' line; Person { name = n, age = a };
14:06:37 <ReinH> looks like I was about right
14:06:40 <acowley> ReinH: I love that example, too. It's fantastic.
14:06:46 <Eduard_Munteanu> ski: e.g. for specific types 's' you can go from s to s' and back, or if you define data Store s a = forall s'. Store (s' -> a) s
14:06:55 <Eduard_Munteanu> *to some s'
14:07:03 <rck> that function works, which I don't really understand. what monad am I using? (how can I determine this on my own? ghci somehow?)
14:07:05 <ReinH> acowley: reading that years ago is what really sold me on Haskell tbh
14:07:06 <fizruk> ReinH: sure you were
14:07:10 <shachaf> rck: If you understand how it desugars, then desugar it by hand.
14:07:10 <monoidal> aranea: sumScores would be better with Data.Map
14:07:11 <mhitza> do you guys know if there is a way for me to "lift" packages installed in a cabal sandbox to ~/.cabal or just a straight cp would work?
14:07:33 <shachaf> rck: do { let { ... = ... }; ... } becomes let { ... = ... } in do { ... }
14:07:39 <shachaf> rck: do { x } becomes x
14:08:12 <rck> shachaf: so in this context it isn't actually monadic?
14:08:25 <jfischoff> mhitza: its not that simple. You would have to merge the package databases
14:08:41 <shachaf> rck: "monadic" is kind of a vague word. But no (>>=) etc. are actually being inserted here.
14:08:51 <rck> ah! okay thanks!
14:08:52 <mhitza> jfischoff, how hard AND safe would that be?
14:09:21 <jfischoff> mhitza: sounds hard and unsafe, but that is maybe because I don't know how
14:10:05 <napping> If I have a GADT at kind (Sort -> *) -> Sort -> *, is there any hope of deriving Show?
14:10:38 <haasn> > 100 * do 2 + 3
14:10:39 <ski> rck : note that the kind of `Person' is `*', but the kind of a monad should be `* -> *'
14:10:39 <lambdabot>   500
14:10:40 <chris1> Why does this not compile and complain about the ByteString import? http://lpaste.net/93783
14:10:56 <jfischoff> I didn't realize kinds effected standalone deriving?
14:10:57 <ski> rck : so, it's more or less an "accident" that your code managed to get past the type checker
14:11:05 <jfischoff> s/effected/affected
14:11:15 <mhitza> jfischoff, then let me put another question, related. If cabal builds a package (as in, it compiles it). Is it enough for me to just copy that, or all it's dependencies should be copied along?
14:11:53 <ski> napping : hm, which instance (implication) would you like to derive ?
14:12:18 <napping> something ending Show (Node leaf s)
14:12:20 <rck> ski: yeah makes sense. if I know the input of ByteString.split will be a list of 2 values (only 1 separator in the data), how do I 1 liner map that into my Person contstructor without do/let?
14:12:23 <ski> @undo do let {[n, a] = ByteString.split ',' line}; Person { name = n, age = a }  -- rck
14:12:23 <lambdabot> let { [n, a] = ByteString.split ',' line} in Person{name = n, age = a}
14:12:46 <napping> probably have to invent something like a class ShowSort f containing a method showSort :: f (s :: Sort) -> String
14:12:50 <napping> (or a kind-generic Show1)
14:12:55 <ski> napping : with `Show (leaf s)' as premise ? or `forall s. Show (leaf s)' or what ?
14:13:02 <napping> the second
14:13:04 <monoidal> napping: paste the GADT?
14:13:13 <mhitza> jfischoff, nevermind last question. Going to try something else instead. :)
14:13:14 <chrisdone> ReinH: https://i.imgur.com/tFZInbG.png
14:13:44 <napping> http://lpaste.net/93785
14:14:02 <jfischoff> mhitza: okay that's probably for the best. I would read monochrome's blog on cabal before you try to muck with innards of its folders
14:14:23 <ion> chrisdone: Who’s that?
14:14:57 <mhitza> jfischoff, I've brave enough as to not fear a haskell platform reinstall in the worst case. Already practiced it a couple of times the last two months.
14:15:12 <napping> It's reasonably straightforward to write by hand
14:15:22 <chrisdone> ion: jerry seinfeld
14:15:52 <jfischoff> don stewart
14:16:38 <lispy> jfischoff: We chatted at ICFP about cabal for the enterprise, right?
14:16:54 <jfischoff> lispy: yep.
14:16:55 <chrisdone> lispy: you think dons looks like jerry?
14:17:01 <lispy> jfischoff: You wanted to write down how your use case is different. Did you have a chance to write things up?
14:17:01 * jfischoff waves at lispy
14:17:22 <jfischoff> nope
14:17:23 <ion> lispy: More XML and Java?
14:18:12 <jfischoff> lispy: I am going to do some work on the build today actually
14:18:22 <jfischoff> so I should
14:18:33 <rck> ski: thanks; I appreciate your time
14:18:33 * jfischoff makes a mental note
14:18:37 <lispy> chrisdone: I can honestly say, it's never occured to me :)
14:18:47 <ion> <cabal:package><cabal:name>foo</cabal:name><cabal:version>0.0.1</cabal:version><cabal:category>Java</cabal:category>…
14:18:49 <chrisdone> lispy: ok =p
14:18:52 <lispy> jfischoff: cool. I'm looking forward to reading it :)
14:18:57 <lispy> jfischoff: even if it's a short document
14:19:04 <jfischoff> lets hope so
14:19:13 <ski> rck : itym s/know the input of/know the output of/
14:19:25 <rck> yeah
14:19:47 <ski> rck : well, you can say `let [n, a] = ByteString.split ',' line in Person { name = n, age = a }' without any `do'
14:20:32 <ski> rck : or, if this is the whole of the body in a definig equation, you can say `... = Person { name = n, age = a }  where  [n, a] = ByteString.split ',' line', with the latter parts possibly on succeding lines
14:22:02 <aranea> monoidal: And what do you think about the "playN' n . genPairs" part?
14:25:31 <monoidal> aranea: here's a possible alternate design. First, given agents :: [Agent], create a Map Int (Agent, Score) which assigns n-th agent and initial score 0 to number n. Compute [(i,j) | i <- [0..n], j <- [i+1..n]].
14:26:27 <monoidal> aranea: then, fold over that list foldr (\(agent1, agent2) scores -> playMatch agent1 agent scores) initialScores [(i,j) | i <- ..., j <- ...]
14:26:51 <monoidal> aranea: this means you only need a function playMatch that takes two agents and updates the result map
14:29:19 <aranea> monoidal: The problem is that the agents use closures to preserve state, so I need an individual copy of the initially-supplied agent for each competition
14:29:44 <aranea> ahh sorry, no problem with your approach...
14:30:54 <monoidal> aranea: right, playMatch can modify the score in the map, but leave the original agent alone
14:32:40 <napping> ghci doesn't seem to show all instances of things like SingE, is there some way around that? (I'm trying to make a kind of indexed Map)
14:32:57 <monoidal> aranea: btw play2' can be written using iterate instead of manual tail recursion
14:33:12 <geekosaur> napping, it can only show instances in modules it has loaded
14:33:16 <c_wraith> napping: good luck listing all instances of that...  There's an instance for every Symbol and Nat
14:33:40 <c_wraith> Oh, wait.  SingE.  Ok, that's just two types, not a billion.
14:33:41 <napping> so SingE does have a separate instance for each value? thought that was just SingI
14:33:55 <c_wraith> yeah, it's just SingI
14:34:10 <c_wraith> still, instances for both of those are semi-magical
14:34:16 <c_wraith> don't be surprised that they don't show up in normal ways
14:34:26 <napping> I defined some for an enum type of my own
14:35:04 <aranea> hmm, that's a point. Thanks, monoidal
14:35:53 * hackagebot Nomyx 0.3.2 - A Nomic game in haskell  http://beta.hackage.haskell.org/package/Nomyx-0.3.2 (CorentinDupont)
14:35:55 * hackagebot Nomyx-Language 0.3.2 - Language to express rules for Nomic  http://beta.hackage.haskell.org/package/Nomyx-Language-0.3.2 (CorentinDupont)
14:38:56 <user123abc> need some help cabal --installing hp2any-manager
14:38:58 <user123abc> http://lpaste.net/5025817150338629632
14:39:06 <user123abc> what should my next step be?
14:40:53 * hackagebot ec2-signature 3.0 - The Amazon EC2 style signature calculator.  http://beta.hackage.haskell.org/package/ec2-signature-3.0 (YusukeNomura)
14:41:47 <user123abc> I installed gtkglext through my distro's package manager, and that got me going
14:41:49 <geekosaur> user123abc, you need the gtkglext C library (including development headers and libraries)
14:41:56 <geekosaur> ...slow'
14:42:05 <user123abc> thanks anyway
14:42:57 <monochrom> you need libgtkglext1-dev. emphasis -dev
14:43:20 <monochrom> -dev is when you get *.h, *.a, and *.so files
14:43:33 <user123abc> yeah, I'm set, thanks
14:46:03 <ReinH> chrisdone: o_O
14:46:26 <osa1> what is Unf part in this Core code http://lpaste.net/93776 ? Arity is first specified as 1 but then in Unf it's 0 ..
14:50:12 <xico> in template haskell, is there a way to get the unqualified names of constructors?
14:50:21 <xico> (apart from string processing)
14:50:46 <jfischoff> isn't that what nameBase does?
14:50:51 * jfischoff looks at the doc...
14:50:59 <pqmodn> chrisdone: haha
14:51:07 <mgsloan> xico: Yeah, mkName . nameBase
14:51:34 <xico> jfischoff, mgsloan: thanks! and sorry :/
14:51:46 <mgsloan> xico: No worries! Ask away
14:52:29 <mgsloan> xico: TH isn't the clearest thing to figure out.  One trick is to view the source.  Turns out there's a bunch of documentation that doesn't turn into haddocks
14:52:31 <xico> also, i am building AppE's. for now the first argument is a VarE with a litteral. how can i ensure that this literal is right in the calling modue?
14:53:27 <mgsloan> xico: You can do something like (VarE 'myIdentifier), and it'll always point to the right thing
14:53:46 <xico> mgsloan: perfect! thanks
14:53:50 <mgsloan> xico: welcome
14:54:03 * ski annotated "gadt to show" with "intended `Show' instance, and a `deriving instance'" at <http://lpaste.net/93785>
14:54:27 <ski> chrisdone : hm, do you know how to link to annotations on <lpaste.net> ?
14:54:33 <ski> napping ^
14:54:52 <ihm1> is it possible to obtain a socket given only a SockAddr?
14:55:15 <napping> you are allowed to write quantified constraints now ?!
14:55:20 <monochrom> adding #a93786 sometimes works and sometimes doesn't, depending on which time of the year
14:55:29 <chrisdone> ski: hmm you used to be able to use an anchor. seems that was lost at some point
14:55:51 <chrisdone> monochrom: yeah it stopped working even before the redesign. i guess i must've dropped it by accident
14:55:54 * chrisdone adds it back
14:55:58 <Eduard_Munteanu> Hm, I seem to have come up with a pretty reasonable general category definition...
14:56:24 <Eduard_Munteanu> data ArrowK ob = ArrowT ob [ob]    data CategoryK ob arr = CategoryT (ob -> ob -> arr)
14:56:26 <monochrom> it has, in fact, gone through one cycle of work -> not work -> work -> not work
14:56:28 <geekosaur> ihm1... I am not sure what you are asking
14:56:35 <chrisdone> and why isn't lpaste announcing?
14:56:47 <napping> ski:  your explicit instance is basially what I wrote by hand, but the deriving clause might be nicer.
14:56:49 <Eduard_Munteanu> I think that enforces category laws automatically.
14:56:50 <chrisdone> ah
14:56:51 <lpaste> test
14:57:40 <Eduard_Munteanu> ArrowT A [B, C]  means  (g :: B -> C) o (f :: A -> B) o id_A
14:58:07 <ski> napping : apparently you can quantify constraints with `ConstraintKinds' and `RankNTypes' (maybe `Rank2Types' or `ExplicitForAll' would be enough ? haven't tried)
14:58:08 <lpaste> chrisdone pasted “Yay!” at http://lpaste.net/93788
14:58:35 <napping> I guess that makes sense, if you have ConstraintKinds then a forall might end up at kind Constraint
14:58:38 <ski> napping : still, it doesn't appear to be well-supported, since it couldn't derive `Show (leaf s)' from `forall (s1 :: Sort). Show (leaf s1)'
14:58:38 <chrisdone> okay, my bad. i reconfigured my irc bouncer last week and lpaste couldn't login to it
14:58:49 <monochrom> oh heh
14:58:53 <napping> (forall a . a -> a) :: *
14:58:57 <chrisdone> one issue one. one to go
14:59:13 <napping> Yeah, I see why it's legal to form without necessarily having any useful support
14:59:18 <napping> need to hook up a lambda-prolog or something
14:59:27 <ski> hehe
14:59:54 <napping> wonder if that's due for 7.8
14:59:54 <Eduard_Munteanu> I can always go from ArrowT (a :: ob) (xss :: '[ob]) to ArrowT (a :: ob) (b ': '[]).
15:00:31 <shachaf> SPJ wants to hear about how people use lens!
15:00:42 <shachaf> We should trick him into joining #-lens.
15:00:52 <Fuuzetsu> in scary, scary ways
15:01:03 <ski> shachaf : sounds like a plan
15:01:18 <monochrom> first you have to trick him into using IRC to begin with
15:01:25 <shachaf> preflex: seen simonpj
15:01:26 <preflex>  simonpj was last seen on #ghc 5 years, 23 days, 6 hours, 53 minutes and 5 seconds ago, saying: Sorry went away for a moment.  I am clueless about branch tagging, but feel free to discuss it anyway!
15:01:45 <ski> monochrom : well, that would be a consequence of tricking him into #-lens
15:01:53 <monochrom> in fact, "tricking into joining #-lens" is poly-time-reducible to "tricking into using IRC"
15:02:19 <chrisdone>  lol
15:02:20 <monochrom> perhaps it is an NP-complete problem!
15:03:15 <chrisdone> ski: monochrom: http://lpaste.net/93785#a93786
15:03:35 <monochrom> w00t thanks. what happened?
15:03:55 <chrisdone> i just fixed it. seems the anchor code wasn't there anymore
15:04:02 <monochrom> yikes
15:04:03 <chrisdone> wrote some moar
15:04:22 <monochrom> flesh-eating bacteria ate your anchor code :)
15:04:36 <ski> looks like the anchor is at the end of the annotation title
15:04:56 <monochrom> (did you inject botox into your computer? :) )
15:04:59 <ski> monochrom : anchors made out of flesh, yikes !
15:05:05 <chrisdone> =o
15:05:42 <adimit> Hello, chrisdone! Sorry to bug you, just a question: does haskell-mode support the current cabal sandbox features? It doesn't seem to…
15:05:46 <chrisdone> ski: should i make the anchor an actual link that you can use?
15:05:56 <chrisdone> ski: i mean in the page next to the headers
15:05:56 <adimit> (yet)
15:06:26 <chrisdone> adimit: ermm not that i'm aware. it's trivial to add it afaik
15:07:26 <adimit> chrisdone: there was some code by hvr a month ago, but I'm having trouble running the current version.
15:07:42 <chrisdone> adimit: are you using inf-haskell or haskell-interactive-mode?
15:07:53 <adimit> chrisdone: yeah, I was going to, but couldn't.
15:08:34 <ski> chrisdone : well, Lisppaste does it like <http://paste.lisp.org/display/136160>. perhaps something like that would be nice
15:09:04 <chrisdone> ski: what is that link supposed to demonstrate?
15:09:09 <adimit> (though now that I've deleted the cabal-dev dir in my repo, compilation doesn't work in general, i.e. flymake can't satisfy the packages.)
15:09:20 <adimit> ok, I'll see how far I get with the current state.
15:09:24 <adimit> thanks for your input.
15:09:47 <chrisdone> adimit: are you using inf-haskell or haskell-interactive-mode?
15:09:51 <monochrom> chrisdone: near the top, there is a small box "index of paste annotations: 1 | 2 | 3". the "1", "2", "3" are hyperlinks
15:10:06 <chrisdone> ahh. i didn't even see that O_O
15:10:08 <chrisdone> hmm
15:10:35 <chrisdone> ski: is that the bit you meant?
15:11:32 <ski> yes
15:13:30 <ski> (though i was mostly thinking about lpaste not announcing the annotation link in the channel)
15:13:42 <chrisdone> ok. i made the headings links
15:13:46 <chrisdone> ski:  it does do that
15:14:03 <lpaste> chrisdone annotated “Yay!” with “I'm an annotation” at http://lpaste.net/93788#a93791
15:14:21 <ski> ok, didn't see it for the previous annotation
15:14:23 <chrisdone> ski: it's just that the general announcing feature wasn't working
15:14:32 <chrisdone> (which i just fixed)
15:14:49 <lpaste> xico pasted “No title” at http://lpaste.net/93792
15:15:00 <chrisdone> hurrah!
15:15:04 <ski> (well, i saw the announce for <http://lpaste.net/93788>, but not any announce for the <http://lpaste.net/93788#a93789> annotation)
15:15:08 <xico> so i am trying to make a data derive show in the lpaste
15:15:11 <monochrom> chrisdone: thanks, now you can enjoy my http://lpaste.net/77374#a93533 :)
15:15:35 <xico> but it fails with a stack overflow when actually using show on a datatype
15:16:54 * chrisdone runs monochrom's devil script
15:16:59 <monochrom> chrisdone++
15:17:33 <chrisdone> @  _@ c’est vrai
15:17:52 * monochrom loves unsafeInterleaveIO chaos :)
15:17:57 <chrisdone> just by the evaluate line
15:18:03 <chrisdone> interesting
15:18:25 <ski> noo, devils like order, not chaos !
15:18:26 <xico> are "deriving Show" after a data and "instance Show D" identical?
15:18:51 <ski> xico : no, not in general
15:19:08 <ski> (the former may do more than the latteR)
15:19:25 <Heffalump> you mean "deriving instance Show D"?
15:19:48 <ski> if so, the answer is still : no, not in general
15:21:18 <ski> xico : anyway, it's not clear what you're trying to do. elaborate ?
15:22:36 <xico> i mean, while defining ‘data D = D deriving Show’, i can use ‘print D’, similarly i can ‘print D’ with ‘data D; instance Show D’. so in my template haskell code, i am trying ‘instance Show T1’ and replacing the T1 by my actual type to achieve the same effect. unfortunately it stack overflows.
15:23:57 <monoidal> xico: the default implementation of show has mutually recursive methods
15:24:13 <xico> monoidal: that might explain it
15:24:28 <ski> with ‘data D; instance Show D’, you get no implementation of the methods
15:24:37 <monoidal> xico: if you do not write show/showPrec or derive one of them, it will loop
15:24:45 <monoidal> xico: (head has a warning against this.)
15:25:33 <ski> xico : `deriving instance Show D' will try to materialize the implementation for you (requires `{-# LANGUAGE StandaloneDeriving #-}')
15:26:24 <ski> xico : note that in case this instance depends on any context, you'll have to write that context explicitly here, unlike with a `deriving' attached to a `data' or `newtype'
15:26:33 <xico> ski: thanks. indeed i was wrong with my example, probably forgot to recompile.
15:26:57 <monoidal> afaik TH does not support standalone deriving
15:27:08 <monoidal> I might be wrong
15:27:40 <xico> i will try
15:27:50 <xico> can i have a space in a data constructor?
15:27:54 <ski> no
15:27:58 <xico> i mean escaping or something
15:28:04 <ski> i don't think so
15:28:12 <ski> perhaps with TH you can
15:28:26 <monoidal> ticket for TH support for standalone deriving http://ghc.haskell.org/trac/ghc/ticket/8100
15:30:52 <xico> indeed, it just returns []
15:31:04 <xico> (i mean standalone deriving in th)
15:31:46 <mgsloan> Yeah, that does kinda suck.  Ran into it the other day.  In the meantime the "derive" package is a good replacement
15:33:50 <xico> mgsloan: nice package. thanks.
15:34:11 <mgsloan> xico: welcome!
15:34:34 <jfischoff> mgsloan: that looks like a useful ghc hacking adventure
15:34:52 <mgsloan> jfischoff: It does!
15:35:51 <mgsloan> Might be a good way for someone to get their feet wet.
15:36:05 * jfischoff nods
15:36:28 <mgsloan> In the stack overflow, benmachine speculates that it's because standalone deriving probably happens in the renamer
15:36:45 <jfischoff> oh
15:37:02 <mgsloan> This is actually something that bugs me in general.  While it's great that GHC checks its own work, and maybe there are cases where this is needed, deriving ends up being quite slow
15:37:34 <mgsloan> For example, compiling Language.Haskell.Exts.Annotated takes my machine about 40seconds to build, but only 3 seconds without deriving instances
15:37:46 <jfischoff> I think there has been some recent improvements to some instances
15:37:51 <mgsloan> Not sure if that's due to typechecking or not, could just be all the extra code generation
15:38:06 <joelteon> oh yeah, that annotated module takes FOREVER
15:38:24 <monoidal> Functor/Foldable/Traversable was O(n^2) runtime, but I don't think compilation improved
15:38:39 <aranea> monoidal: switched playN to a Map. Not sure how to do play2' without explicit recursion though
15:38:41 <monoidal> I guess Read is still very bad
15:38:44 <mgsloan> monoidal: Ahh
15:39:13 <mgsloan> Yeah, it might be worthwhile to move these into a haskell-src-exts-orphans package
15:39:22 <mgsloan> Since most people don't need the instances
15:39:33 <srhb> Any yeganesh users here? I'm pondering what the correct way to make it actually execute things is, piping to sh seems a bit like a very large hammer.
15:39:36 <mgsloan> But eh, a minute or two of compile isn't that big of a deal
15:39:50 <jfischoff> I've heard there were some classes that took exponential time, but that sounds crazy
15:40:25 <mgsloan> jfischoff: Wouldn't be surprising, there's definitely something fishy going on with the HSE ones
15:42:45 <monoidal> aranea: hm, I hoped it would be clearer, but it's not so. anyway you can write a single round play3 :: (Score, Score, Agent, Agent) -> (Score, Score, Agent, Agent) and then use iterate play3 (0,0,Init,Init) !! steps
15:43:46 <aranea> aww, sure, thanks
15:53:54 <stinkfinger> !s mirc
15:58:01 <monoidal> aranea: depending on style, (\(a, s) -> (a, s+s')) can be second (+s') instead
15:58:52 <monoidal> aranea: on the second thought, I think it's good to separate the logic of a single round from iterating, so I recommend considering the above play3 design
16:01:00 <monoidal> aranea: instead of M.update, use M.adjust, you don't need Maybe
16:01:32 <evincar> Is there a convenient way to express a type in terms of the type of an identifier?
16:02:02 <evincar> Suppose you want to make an alias for the type of a data constructor.
16:02:11 <aranea> monoidal: thanks. Did you say anything else to me? I had a disconnect...
16:02:40 <roconnor> evincar: nope
16:02:58 <ski> evincar : sounds like you want refinement types
16:03:07 <monoidal> aranea: I said three messages to you during last 15 minutes, http://tunes.org/~nef/logs/haskell/13.10.02
16:03:29 <monoidal> aranea: four
16:03:33 <ski> something like `data NonEmptyList a :< [a] = a : [a]'
16:03:38 <evincar> ski: Not really, I just want "data A = A Int Char; type TA = Int -> Char -> A" without repeating myself.
16:03:58 <ski> mhm
16:04:17 <ski> evincar : try `data A where MkA :: TA' ?
16:04:34 * ski can't recall whether that works
16:04:39 <ski> (works in Agda, though)
16:04:39 <monoidal> it should
16:05:11 <aranea> didn't know there's a log...
16:05:28 <ski> aranea : in the topic :)
16:06:26 <aranea> :)
16:07:32 <aranea> monoidal: I searched for a function like second with Hoogle, just didn't think of Arrows
16:08:11 <monoidal> aranea: btw you can build the list using M.fromAscList (note that in general this can be unsafe)
16:08:33 <shachaf> M.update is strange. But M.alter and M.adjust are sensible.
16:08:42 <acowley> Wasn't there a proposal to move some of the tuple functions to a Tuples module?
16:08:51 <acowley> or at least re-export
16:08:54 <shachaf> And if the argument order was flipped, then M.adjust k would be = M.alter k . fmap
16:10:03 <ski> @type M.update
16:10:04 <lambdabot> Ord k => (a -> Maybe a) -> k -> M.Map k a -> M.Map k a
16:10:07 <ski> @type M.adjust
16:10:08 <lambdabot> Ord k => (a -> a) -> k -> M.Map k a -> M.Map k a
16:10:09 <ski> @type M.alter
16:10:10 <lambdabot> Ord k => (Maybe a -> Maybe a) -> k -> M.Map k a -> M.Map k a
16:11:12 <shachaf> :t Control.Lens.at
16:11:12 <lambdabot> (Functor f, Indexable (Index m) p, At m) => Index m -> p (Maybe (IxValue m)) (f (Maybe (IxValue m))) -> m -> f m
16:11:21 <shachaf> :t \k -> Control.Lens.at k . traverse
16:11:22 <lambdabot> (Applicative f, At m) => Index m -> (IxValue m -> f (IxValue m)) -> m -> f m
16:11:33 <shachaf> :t Control.Lens.ix
16:11:34 <lambdabot> (Indexable (Index m) p, Ixed f m) => Index m -> p (IxValue m) (f (IxValue m)) -> m -> f m
16:13:33 <aranea> monoidal: Your proposals are now implemented
16:18:31 <monoidal> aranea: great! um, sorry to notice this now, but that map is in fact an array, the code might get better if you use another structure. it's late here, I'm going to bed.
16:19:36 <rgrinberg1> can I use Data.ByteString.Char8 for binary data?
16:19:43 <rgrinberg1> non ascii that is
16:19:49 <shachaf> Just use Data.ByteString.
16:20:17 <shachaf> Data.ByteString.Char8 is the same type but it exports broken functions that pretend Word8=Char (it isn't).
16:20:50 <evincar> ski: Okay, now make it work for a record. ;)
16:21:03 <evincar> I already thought of your proposed solution. :P
16:21:21 <evincar> What I want is (don't hate me) "decltype" from C++.
16:22:56 <aranea> What do you others think about that thing monoidal just said? Sure, I could use Data.Array.ST, but the current approach seems nicer to the eye – and I'm okay with logarithmic instead of constant runtime...
16:23:08 <rgrinberg1> schell: i'm using attoparsec and the char8 module has some useful functions for me. I forgot to say that I have ascii and fixed size binary blobs in my data
16:23:10 * ski doesn't know `decltype'
16:28:33 <evincar> ski: "decltype(x)" is the compile-time type of "x", e.g.: "int x; vector<decltype(i)> xs;"
16:29:22 <ski> hm, i thought there was some kind of `typeof' ?
16:29:30 <evincar> For runtime type information, yes.
16:29:35 <ski> oh, i see
16:30:11 <ski> (itym s/\(i\)/\(x\)/)
16:30:24 <schell> rgrinberg1: was that last comment for shachaf, possibly?
16:30:48 <evincar> Yeah, typo, sorry.
16:30:55 <evincar> Well, brainfart.
16:31:47 <rgrinberg1> schell: whoops :/
16:31:47 <evincar> I can hack around it, but it seems like something that should already be in GHC.
16:31:49 <rgrinberg1> you're right
16:31:53 <evincar> Perhaps I'll add it...
16:32:14 <schell> rgrinberg1: :) all good, i was just trying to remember when i was talking about anything like that, haha
16:32:59 <shachaf> rgrinberg1: Data.ByteString.Char8.ByteString and Data.ByteString.ByteString are the same type.
16:33:43 <rgrinberg1> schell: I see, so Data.BS.BS just doesn't export the "unsafe" functions?
16:34:37 <Rarrikins> How do I hide a module?
16:34:55 <schell> rgrinberg1: haha - you're just messing with me meow, aren't you?
16:35:40 <rgrinberg1> schell: damn tab completion :/
16:35:44 <schell> haha
16:37:14 <monochrom> "hide a module" in what sense? what context?
16:37:56 <Rarrikins> Where importing it won't work.
16:38:24 <monochrom> ok, you can only do it at package registration time permanently
16:38:34 <monochrom> and you can only do it to modules in packages
16:38:44 <Rarrikins> Ahh, OK
16:38:59 <Rarrikins> That's a bit off in the future, then.
16:39:06 <monochrom> put it not in Exposed-modules, but in Other-modules
16:39:20 <BigJ> I am trying to write a function which merges two lists together.  When I feed in two lists one with an odd number of elements and one with an even number of elements it works fine but when I provide two lists of equal length it complains about non-exhaustive pattern matching.  I can't see which patter I am missing....   http://codepad.org/7ir35oNy
16:41:03 <ski> BigJ : missing `(x:xs,[])' and `([],y:ys)' where `xs' resp. `ys' can be non-empty lists
16:41:12 <pqmodn> BigJ: [x] only matches a list with one element. x:xs matches at least with /at least/ one element
16:41:40 <ski> BigJ : also s/merget/merge/
16:42:37 <ski> BigJ : btw, i think a more common name for this would be `interleave' or `(/\/)'
16:43:42 <BigJ> ski, I tried writing the function like that originally but couldn't figure out the right side of the equation
16:43:47 <monochrom> the type "mergetList" is the real cause
16:43:50 <monochrom> err
16:43:53 <monochrom> the typo "mergetList" is the real cause
16:44:03 <Ghoul_> /\/ looks cool
16:44:36 <BigJ> monochrom, spelling error eh
16:44:47 <monochrom> because for two lists of same length, the two patterns ([],[]) and (x:xs, y:ys) clearly suffice
16:45:41 <ski> > "iio" /\/ "aa"
16:45:44 <lambdabot>   "iioaa"
16:45:51 <ski> er :)
16:45:55 <BigJ> monochrom, thanks works now
16:46:03 <ski> > "iio" /\/ "aa"
16:46:06 <lambdabot>   "iaiao"
16:51:06 * hackagebot penny 0.30.0.2 - Extensible double-entry accounting system  http://beta.hackage.haskell.org/package/penny-0.30.0.2 (OmariNorman)
16:51:19 <ArisFr> Hi! Data.Vector.Storable.Vector a is not an instance of Functor due to the extra Data.Vector.Storable.Storable a constraint. Is there a way to "adapt" storable vectors so that it can be made an instance of Functor and used in the places where Functor is required?
16:53:16 <Cale> ArisFr: Not without modifying Functor
16:53:30 <jfischoff> There is Coyoneda
16:53:31 <Cale> (and using lots of fancy new extensions)
16:54:23 <lpaste> brainsturgeon pasted “my Permutations” at http://lpaste.net/93798
16:55:15 <brainsturgeon> hey
16:55:28 <ArisFr> Cale: thanks a lot. Just confirming my suspictions.
16:55:28 <brainsturgeon> I was having trouble understanding the permutation function in Data.List
16:55:54 <ArisFr> jfischoff: Thanks as well. I'm looking it up
16:56:01 <brainsturgeon> so I tried writing one myself. It works fine, but appears to be slower by about 30%.
16:56:08 <brainsturgeon> Does anyone have an idea why?
16:56:41 <jfischoff> ArisFr: Coyoneda is a way to make a something that isn't a functor work as one
16:56:50 <jfischoff> I think ...
16:57:08 <Cale> Yeah, that's true
16:57:13 <jfischoff> cool
16:57:20 <Cale> Basically "just hold on to the function to apply until the end"
16:57:25 * jfischoff nods
16:57:34 <monochrom> brainsturgeon: let m = permute' xs or permutations is. you walk m 3 times whereas Data.List's walks m just 1 time
16:57:57 <ArisFr> Seems interesting. Looking at it now.
16:58:01 <Cale> data CoYoneda f x = forall z. CoYoneda (z -> x) (f z)
16:58:04 <monochrom> first time: length. second time: take. third time: drop.
16:58:48 <ArisFr> As an aside, why do some useful things have such unusual names in Haskell ? :) Lens: I'm looking at you
16:59:13 <jfischoff> ArisFr: because they were named before Haskell
16:59:17 <edwardk> ArisFr: so give me the name for a lens in another language? =)
16:59:24 <Cale> Well, that doesn't really apply to lens so much...
16:59:35 <Cale> Unless you're referring to profunctors
16:59:47 <brainsturgeon> monochrom: so you think using takeAt instead of take/drop would gain some speed?
16:59:54 <ArisFr> edwardk: field access :)
16:59:58 <thetallguy> ArisFr: the length of symbol name is inversely proportional to its generality
17:00:00 <monochrom> who is takeAt?
17:00:09 <ArisFr> edwardk: I'm just joking
17:00:28 <Cale> ArisFr: The idea is that lenses are used to focus in on some part of a larger structure, so the name is somewhat appropriate.
17:00:36 <brainsturgeon> takeAt n xs = (take n xs, drop n xs)
17:01:10 <monochrom> where can I find takeAt?
17:01:30 <edwardk> brainsturgeon: splitAt
17:01:32 <ArisFr> Cale: Oh, I understand the name's origin, its just that when coming from an imperative language you would think about looking for "lens"
17:01:33 <edwardk> :t splitAt
17:01:33 <lambdabot> Int -> [a] -> ([a], [a])
17:01:36 <Cale> ArisFr: Prism is mostly just to go along with the optical theme, but it too makes a certain amount of sense if you think about it as separating out some "colours" from many possibilities. :)
17:01:38 <brainsturgeon> right, splitAt.
17:01:41 <brainsturgeon> my mistake.
17:01:58 <brainsturgeon> thank you edwardk.
17:02:21 <Cale> ArisFr: Well, these ideas tend not to be implemented in imperative languages very much
17:02:23 <monochrom> that reduces 3 to 2.
17:02:27 <Cale> ArisFr: because functions are hard to work with
17:02:40 <ArisFr> Cale: well, you would be of course right about that
17:02:40 <Cale> (not always, but often)
17:05:08 <ArisFr> Cale: Having started learning Haskel a few months ago, I just found about lens and I learnd about Functor just recently (I was aware and comfortable with map/foldl from Python). I'm not saying that they are not useful or well defined. Much more so than in other languages. However, they seem somewhat hard to find about.
17:05:52 <ArisFr> s/find about/find out about/
17:05:55 <edwardk> ArisFr: lens is a pretty new thing. it has only taken off in the last year or so, and it is really rather deliberately poised as a 'power user tool' at this point
17:06:12 <orzo> how do i fix this cabal issue? cabal: <file descriptor: 4>: resource exhausted
17:06:44 <monochrom> that is likely very inadequate information
17:06:47 <ArisFr> edwardk: Oh, I wasn't aware. The type signatures sure indicate the power user domain, though
17:06:56 <edwardk> mostly because the kinds of type errors you get with it are the kind of thing that have been known to send newer users of haskell fleeing for other languages. ;)
17:06:57 <orzo> well it dos that with almost any command
17:07:17 <orzo> i tried it with "cabal update" and it started downloading for a while and then bam, resource exhausted
17:07:36 <monochrom> is there any other output?
17:07:47 <orzo> $ cabal update
17:07:48 <orzo> Downloading the latest package list from hackage.haskell.org
17:07:48 <orzo> cabal: <file descriptor: 4>: resource exhausted
17:07:51 <orzo> That is all
17:08:00 <brainsturgeon> monochrom: I think I can get it down to 1 usage
17:08:07 <ArisFr> edwardk: I can definately understand why. I'm persistent though and the community is very impressive. Are all you guys mining karma or something?
17:08:16 <brainsturgeon> I just need to make it stop splitting when the second string comes up empty.
17:08:19 <monochrom> is there more output if you do "cabal update -v3"
17:09:04 <ArisFr> I should stop with the off-topic chatter though, I hope I haven't distracted you too much.
17:09:40 <edwardk> ArisFr: pretty much. but keep it on the down-low. once word gets out we'll have to deal with karma scalpers, claim jumpers, all sorts of stuff
17:09:45 <lpaste> orzo pasted “cabal fail” at http://lpaste.net/93799
17:10:31 <monochrom> do you have a disk-full?
17:10:34 <orzo> oh, looks like my /home partition has only 4k free.  Error message should be improved tho
17:10:37 <ArisFr> edwardk: :) Hope I'll be able to contribute sometime soon. Thanks
17:11:21 <orzo> running update after freeing 16M
17:11:28 <monochrom> error message can be no better than kernel error codes
17:11:31 <orzo> maybe 16M is not enough, it still failed
17:11:49 <orzo> well usually running out of disk space says something else in other apps
17:12:14 <monochrom> it needs about 110-120 MB
17:12:51 <monochrom> essentially because it has to ungzip 00-index.tar and keep it uncompressed
17:13:03 <ski> ArisFr : just stick around in the channel, listen, ask questions sometimes, and sometimes try to help when you feel you can :)
17:14:11 <monochrom> anyway I am appalled that I guessed disk-full correctly
17:14:21 <orzo> well, thanks, it looks like i got it working by freeing up a 100M
17:14:30 <monochrom> \∩/
17:15:04 <shachaf> https://groups.google.com/forum/#!topic/bahaskell/W0g4J-c5Dhs
17:15:14 <shachaf> ☝ edwardk's talk in SF in two weeks
17:15:21 <monochrom> you can look at .cabal/packages/hackage.haskell.org and see how your 100M is used :)
17:16:15 <orzo> i'm having a different problem tryiing to build a package i made
17:16:26 <monochrom> I had to use a large font to see that ☝ is a finger :)
17:16:41 <orzo> GHCi runtime linker is complaining about duplicate symbol _hs_text_decode_utf8
17:16:57 <orzo> while processing object file /usr/lib/haskell-packages/ghc/lib/text-0.11.2.0/ghc-7.4.1/HStext-0.11.2.0.o
17:17:13 <orzo> hm, i notice that is in /usr
17:17:42 <orzo> anyway, it only tells me one object file, i figure it ought to tell me two if the symbol is duplicated
17:18:08 <orzo> i installed text package from cabal in my home, so maybe that object shouldnt even be comming in
17:19:23 <monochrom> are you using something like "cabal build" to build?
17:19:58 <orzo> yes
17:20:04 <orzo> exactly like that
17:21:29 <monochrom> what does GHCi runtime linker have to do with building?
17:21:39 <orzo> i removed the /usr versino of text and am going around installing packages with cabal that it tells me are broken
17:21:45 <orzo> im not sure
17:21:54 <orzo> but it identifies itself in the error message
17:22:11 <monochrom> I guess TH invokes GHCi
17:22:20 <orzo> oh, i use some TH yes
17:23:21 <monochrom> what commands did you use in "removed the /usr version of text"?
17:23:58 <orzo> apt-get remove libghc-text-dev
17:24:00 <orzo> something like that
17:24:12 <monochrom> ok, that is maybe safe
17:24:47 <monochrom> but you should read my http://www.vex.net/~trebla/haskell/sicp.xhtml#unsafeInterleave at your leisure
17:29:11 <orzo> well hot damn, i got it to build
17:29:29 <monochrom> good good
17:34:39 <justinleitgeb> Hey folks. Is there anything in cabal sandbox or a related package to automatically use the binaries installed under .cabal-sandbox/bin ?
17:35:05 <monochrom> isn't it enough to play with PATH?
17:35:48 <justinleitgeb> monochrom: sure, I think something like that could be done. But would be nice if it were automatic like in Ruby's rbenv or rvm. Looking for something similar in Haskell.
17:37:18 <byorgey> justinleitgeb: you want hsenv
17:38:01 <byorgey> it is not (yet?) integrated with the new cabal sandbox stuff, but it gives you a sandbox and automatically sets your $PATH and related stuff
17:38:40 <justinleitgeb> byorgey: got it, thanks!
17:50:49 <blochchain> are Haskell web frameworks more secure by definition than others to things like SQL injections?
17:52:21 <davean> no
17:52:28 <davean> you can code anything badly
17:52:40 <Bram> I don't see why, you can still be stupid and do string concatenation on user input and send that to a rdms
17:52:44 <davean> they make it so you have to go further out of your way to write vunerabilities of said type
17:53:02 <brainsturgeon> hey monochrom: I tried using an infinite list to avoid counting the length in interpose'
17:53:09 <davean> They're more secure by standard procedure then some
17:53:13 <brainsturgeon> but it is now much slower
17:53:30 <brainsturgeon> is there overhead associated with that?
17:53:54 <davean> Bram: That depends on what SQL library you use - some don't allow string-based queries
17:55:01 <Bram> davean: of course, but then your security is unrelated to haskell feature nor the web framework (but then we get back to your first point on coding badly)
17:56:07 <davean> Bram: of course - Haskell does encurage libraries of said form though
17:56:28 <edwardk> Bram: so we shouldn't put handrails on the stairs because an idiot could just jump over them anyways? now i will say that they encourage safer patterns of behavior and more stuff can only really be used in a safe by construction manner than in something lik PHP where 'dumb string munging' is the only option in many cases.
17:56:47 <edwardk> so yes, they are _safer_ by construction, but not safe by construction
18:00:53 <Bram> edwardk: I agree with you
18:02:40 <Dodek> Bram: and yet there are more sql injection vulnerabilities in php code using mysql_query() than there are in code using ORMs or safety mechanisms based on type.
18:05:17 <Bram> Dodek: it is more related to historical reasons and on the people that are using php, most people using other languages uses frameworks that, by default, prevent you from shoting yourself in the foot
18:05:50 <hpc> Dodek: or even perl's "munge strings passed by parameter instead of direct interpolation at the site"
18:07:08 * k0001 is amazed at how much people type in #haskell.
18:07:46 <hpc> k0001: some irc channels are untyped!
18:08:25 <k0001> hpc: yeah, just what I was thinking.
18:10:01 <Hodapp> ohhhh, I've seen some major type mismatches in IRC channels
18:11:32 <hpc> Hodapp: i have actually seen someone insist on using latin-1 on irc because "utf-8 wasn't widely supported"
18:11:44 <hpc> about as close to a type mismatch as you can get
18:11:56 <Hodapp> hpc: I have a coworker who insists that everything be in UTF-16.
18:12:14 <hpc> that's the kind of thinking that gets you the jvm
18:12:17 <hpc> or Data.Text
18:12:22 <hpc> so he's half-right! ;)
18:13:02 <k0001> You mean only 8 bits right?
18:13:15 <Hodapp> it means that our code - which sometimes needs to interact with C libraries - is littered with a lot of Converter::toNarrowString(string).c_str() and the like
18:14:26 <hpc> ouch
18:15:22 <hpc> oh, i have a coworker who set a website's encoding header to ascii and then proceeded to copy content from microsoft word everywhere
18:15:37 <hpc> munged smartquotes /everywhere/
18:16:12 <hpc> i can't even imagine trying to do anything with unicode in C
18:16:53 * hackagebot ForkableT 0.1.0.0 - Forkable monad transformers  http://beta.hackage.haskell.org/package/ForkableT-0.1.0.0 (AndrasSlemmer)
18:16:55 * hackagebot SimpleLog 0.1.0.0 - Simple, configurable logging  http://beta.hackage.haskell.org/package/SimpleLog-0.1.0.0 (AndrasSlemmer)
18:16:57 * hackagebot BlogLiterately-diagrams 0.1.2.3 - Include images in blog posts with inline diagrams code  http://beta.hackage.haskell.org/package/BlogLiterately-diagrams-0.1.2.3 (BrentYorgey)
18:17:43 <hpc> then again, i can't imagine lots of stuff in C
18:17:55 <hpc> it's just not the kind of language that you can manage complexity well with
18:21:54 * hackagebot diagrams-builder 0.4.0.6 - hint-based build service for the diagrams graphics EDSL.  http://beta.hackage.haskell.org/package/diagrams-builder-0.4.0.6 (BrentYorgey)
18:25:52 <brainsturgeon> I wonder if any of you can offer suggestions as to why this code is slow.
18:26:04 <lpaste> brainsturgeon pasted “More Permutations” at http://lpaste.net/93802
18:26:23 <lpaste> brainsturgeon revised “More Permutations”: “No title” at http://lpaste.net/93802
18:26:54 * hackagebot SimpleLog 0.1.0.1 - Simple, configurable logging  http://beta.hackage.haskell.org/package/SimpleLog-0.1.0.1 (AndrasSlemmer)
18:28:17 <brainsturgeon> I'm learning parallel haskell techniques but I figure I should get a handle on basic optimization first.
18:31:07 <byorgey> brainsturgeon: doing lots of taking lists apart and sticking things in the middle of them like that is bound to be suboptimal.
18:31:43 <byorgey> lists are singly linked, so operations are generally O(n)
18:32:37 <byorgey> brainsturgeon: for generating permutations, I think it works much better to select all possible elements to go at the start, instead of sticking the first element in all possible positions.
18:32:51 <byorgey> selecting all possible elements only requires traversing the input list once.
18:33:16 <brainsturgeon> byorgey: Thanks. I didn't know lists were implemented that way.
18:33:41 <brainsturgeon> and that makes sense about the algorithm.
18:34:30 <brainsturgeon> although if I put the elements at the start I still have to keep track of the lists without each element, right?
18:34:36 <byorgey> I am handwaving here, it's quite possible I am wrong on some of the details.  But yes, if you didn't know that about lists then that is an important thing to learn re: basic optimization =)
18:35:06 <byorgey> brainsturgeon: right.  you want to write a function like  select :: [a] -> [(a, [a])]
18:35:15 <byorgey> which gives you pairs of a selected element and all the remaining elements
18:35:41 <brainsturgeon> then run permute on the remaining elements?
18:40:06 <Rarrikins> @type fmap
18:40:07 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:42:08 <byorgey> brainsturgeon: right
18:54:16 <copumpkin> not exactly brain sturgery?
18:56:21 <acowley> edwardk: ping
18:56:29 <edwardk> pong
18:56:36 <acowley> edwardk: https://github.com/acowley/machines/commit/2ca20c33754d8150ea4c95ce8b85bcf8fa8219f3
18:56:58 <brainsturgeon> byorgey: thanks for your help.
18:57:01 <brainsturgeon> night all.
18:57:06 <acowley> I'm not sure what state it's in, but I'm desperately behind schedule on other work
18:58:28 <acowley> I may have given the ASCII artist in me a bit too much freedom: f ~@ (p >~> q ~<> r)
18:58:33 <edwardk> acowley: well, i'll say this it looks coherent, and you seem to like it. ;) The MonadBaseControl IO stuff makes me leery though.
18:58:35 <acowley> but that kind of thing shouldn't be too common
18:58:42 <acowley> edwardk: Yeah, it's dicey
18:58:58 <acowley> I don't see a lot of options though
18:59:01 <edwardk> wondering if that part can be swapped out
18:59:35 <acowley> Probably. In fact, I'd never used that stuff before, and I was quite pleased with how it all worked out.
18:59:41 <edwardk> how much have you beat on this?
18:59:48 <acowley> So I decided to leave that already-invented wheel as is
19:00:05 <acowley> edwardk: I have half a dozen test programs to exercise the modules, but I'm going to start using it violently now
19:00:18 <edwardk> i'm actively pursuing replacement designs with johnw and snoyman, so perhaps when that comes to fruition we'll have a better story
19:00:58 <acowley> edwardk: Yeah, I'm too close to it right now to have any useful perspective, but I think it now does everything I want it to for the time being.
19:01:50 <acowley> I need to have multiple OpenCL and OpenGL streams with little telemetry monitors hanging off here and there
19:02:13 <acowley> And since those streams will be running at different rates, I need control over inter-process buffering
19:02:14 <edwardk> fair enough
19:02:35 <edwardk> yeah up until now we've been all pull driven
19:02:56 <acowley> Right, so I want to have various dials to give fine control over that
19:03:06 <edwardk> paul's code gave us a way to do some mixed rate consumer producer code
19:03:12 <edwardk> but its different than this by far
19:03:26 <edwardk> he was sort of 'wye'ing the producer and consumers
19:03:52 <edwardk> and getting producer messages or consumer callbacks in a bounded window
19:03:58 <acowley> A wye has two inputs… so one is a buffer and one is a source?
19:04:09 <acowley> No, that doesn't make sense
19:04:22 <edwardk> one was the input and one was the hooks for where to send the messages.
19:04:44 <edwardk> so if you got both you fired off the message by calling it with the message
19:05:05 <edwardk> therwise you could wye off and block on both
19:05:23 <edwardk> that way you can have a fixed sized buffer of queued requests or response handlers
19:05:30 <acowley> How does he manage the asynchronous events?
19:05:35 <acowley> I found async to be quite nice
19:05:44 <edwardk> don't remember
19:05:54 <acowley> Yeah, I added fixed size buffers that block and fixed-size rolling buffers
19:06:06 <acowley> But the construction I'm using isn't as clever
19:06:46 <acowley> wye is kind of a mess, and could use some rethinking actually
19:06:49 <acowley> It works
19:06:55 <acowley> but the code is super explicit
19:08:02 <acowley> Well, poke around the code some when you get a chance
19:08:16 <acowley> You can do some neat things with it like sequentially compose parsers and such
19:08:38 <acowley> and I think there's also a solution to the recently popular perfect-streaming problem in there
19:10:00 <acowley> namely, this: https://github.com/acowley/machines/blob/dev/src/Data/Machine/Chunk.hs#L28
19:10:22 <acowley> But it's not as nice as pipes or conduit in some ways
19:12:04 <elliott> has acowley fixed Machine/Plan ugliness yet? :p
19:12:19 <acowley> :(
19:13:16 <acowley> elliott: The short answer is no. But I have to say that you actually really motivated me to clean up the tornado I sent through the code quite a lot.
19:14:06 <elliott> woo! my complaints motivated someone!
19:14:10 <elliott> this is a new and dangerous feeling.
19:14:18 <acowley> hahaha
19:14:33 <elliott> yuck, MonadBaseControl.
19:14:43 <acowley> I know, I know :(
19:15:20 <sshine> is anyone here using Happy? http://stackoverflow.com/questions/18060029/suppress-certain-haskell-alex-happy-compilation-messages
19:15:28 <acowley> But the amazing thing is that it actually works when you just use IO after all that effort!
19:16:23 <elliott> acowley: the marvel is not that the bear dances well, but that it dances at all?
19:16:40 <so9844> anyone used Yesod and Angular in combination here? I read a blog post about it but didn't give a ton of details
19:16:52 <acowley> elliott: You understand me.
19:18:16 <acowley> Well, hopefully someone can figure out how to not need all that nonsense
19:18:43 <elliott> hopefully some acowley will.
19:18:48 <elliott> we're all counting on you.
19:19:11 <acowley> That motivation thing went to your head pretty fast
19:19:54 <elliott> machines is the worst thing ever! if only SOMEONE fixed it to be the best instead. then I could finally stop complaining. hypothetically.
19:20:15 <elliott> or perhaps just pathetically
19:22:11 <acowley> I think some of the multi-input routing stuff in machines has a bit of intrinsic complexity.
19:22:55 <acowley> The Plan / Machine divide is something edwardk can argue for much better than I
19:23:17 <acowley> It was frustrating at times, but the divide forced certain decisions that were probably for the best.
19:23:28 <acowley> Anyway, I'm going to eat dinner. bbiab
19:23:30 <edwardk> i rather like the fact that my code doesn't just randomly slow down asymptotically with machines
19:24:01 <elliott> I don't mind Plan and Machine both existing... I just kinda hate the part where they're almost identical but totally separate. :(
19:24:39 <acowley> edwardk: Yes, and I think/hope my Loop abstraction buys back some of what is apparently lost by your reluctance to have slow code
19:25:07 <acowley> elliott: This seems like something you would be ideally suited to improve
19:26:21 <elliott> weird, I was thinking it sounded like an acowley kinda job.
19:32:02 <Rarrikins> @type let zomg x@(Left _) = x
19:32:03 <lambdabot> <no location info>: not an expression: `let zomg x@(Left _) = x'
19:32:11 <Rarrikins> What's wrong with that expression?
19:32:24 <Rarrikins> @type let zomg x@(Left _) = x in 5
19:32:25 <lambdabot> Num a => a
19:32:28 <Rarrikins> Ahh
19:33:05 <geekosaur> @type \(x@(Left _)) -> x
19:33:06 <so9844> @type >>=
19:33:06 <lambdabot> Either t t1 -> Either t t1
19:33:06 <lambdabot> parse error on input `>>='
19:33:22 <geekosaur> @type (>>=)
19:33:23 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:33:29 <so9844> ah, thanks
19:36:47 <Rarrikins> I had the error where I was changing the type of the Right while trying to use f x@(Left _) = x, which doesn't quite work out typewise.
19:55:25 <enthdegree> sup yo
19:59:47 <Rarrikins> Is there a way, with record syntax data declarations, to either leave one constructor argument unnamed or to name it the same as a typeclass function in order to define the instance?
20:00:17 <Rarrikins> Or do I have to have a second name?
20:04:19 <Rarrikins> Or, a better question: how do I define two data types with record syntax with some identically-named members?
20:04:49 <Polarina> Rarrikins, two data types cannot share record names within the same module.
20:06:57 <Rarrikins> Polarina: Bleh.
20:07:15 <pqmodn> Rarrikins: you can do that in recent versions of GHC if they share the same type
20:07:28 <pqmodn> er, sorry, that's wrong.
20:07:45 <Rarrikins> Darn
20:07:48 <Rarrikins> They do in my case.
20:07:49 <pqmodn> you can only share field names within the same type (but among different variants)
20:07:54 <applicative> > (1,2) ^. _1
20:07:56 <lambdabot>   1
20:08:00 <applicative> > (1,2,3) ^. _1
20:08:02 <lambdabot>   1
20:08:10 <pqmodn> so data X = X1 { name :: String } | X2 { name :: String } is OK
20:08:12 <applicative> check it out, two records with the same field accessor
20:08:20 <Rarrikins> pqmodn: Hmm
20:08:41 <Rarrikins> pqmodn: I might be willing to lose some type safety for it, but I need to think about it.
20:09:27 <Rarrikins> Hmm.
20:09:57 <applicative> > (1,2) & _1 .~ "California"
20:09:57 <Rarrikins> I need to think about whether users of my types will construct new ones using record syntax or not. I might be able to just throw out record syntax and use typeclasses.
20:09:59 <lambdabot>   ("California",2)
20:10:08 <applicative> > (1,2,3) & _1 .~ "California"
20:10:10 <lambdabot>   ("California",2,3)
20:11:19 <pqmodn> :t (\o k v -> o & k .~ v)
20:11:19 <lambdabot> a -> ASetter a b a1 b1 -> b1 -> b
20:11:51 <pqmodn> :t (\o k v -> o & k)
20:11:52 <lambdabot> a -> (a -> b) -> t -> b
20:11:54 <applicative> the lens package can give you some of what you want, Rarrikins; the _1 i was using is exactly like a field name for a record, associated in this case with a class so i can use it with several types
20:11:58 <augur> are the ICFP videos up?
20:12:07 <applicative> augur: good question
20:12:38 <pqmodn> :t _3
20:12:39 <lambdabot> (Functor f, Field3 s t a b, Indexable Int p) => p a (f b) -> s -> f t
20:12:42 <pqmodn> :t _Just
20:13:03 <applicative> Rarrikins: of course, the type errors will completely baffle your users...
20:13:23 <Rarrikins> I was thinking about using lenses.
20:13:57 <Rarrikins> I've never used it before. Does it need me to define things or can users just go ahead and use a nonlensy library with lenses?
20:14:11 <pqmodn> i must be doing this wrong:
20:14:18 <pqmodn> > Just 3 ^ _Just
20:14:19 <lambdabot>   Could not deduce (Data.Profunctor.Choice p0)
20:14:19 <lambdabot>    arising from a use of `Cont...
20:14:24 <pqmodn> ah, finally an error message
20:14:51 <Rarrikins> :t (^ _Just)
20:14:55 <lambdabot>     Could not deduce (Integral
20:14:58 <lambdabot>                         (p0 a0 (f0 b0) -> p0 (Maybe a0) (f0 (Maybe b0))))
20:15:00 <lambdabot>       arising from a use of `^'
20:15:25 <Rarrikins> :t (& _1)
20:15:30 <lambdabot> (Functor f, Field1 s t a b, Indexable Int p) => p a (f b) -> s -> f t
20:15:43 <Rarrikins> Field1 stab!
20:15:48 <applicative> you're using ^ which is some kind of exponentiation
20:15:59 <Rarrikins> Ahh, right.
20:38:34 <nwf> Pardon what might be a silly question, but with the new type-level Nats, can I construct a type with exactly N constructors (all of the same shape, say nullary for the use at hand) in a parametric-in-N way?
20:39:37 <shachaf> Constructors in particular, not just inhabitants?
20:40:06 <nwf> Well, I suppose either, but in a pattern-matchable way.
20:40:53 <shachaf> Anyway, the type-level Nats probably don't do a whole lot of good until GHC 7.8.
20:41:17 <Saizan> can type families match on type-level nats peano style?
20:41:36 <Saizan> oh, i guess gadts would be fine too
20:44:08 <xunie-laptop> :t getLine >>= show
20:44:09 <lambdabot>     Couldn't match type `[]' with `IO'
20:44:09 <lambdabot>     Expected type: String -> IO Char
20:44:09 <lambdabot>       Actual type: String -> String
20:45:34 <xunie-laptop> Why is the expected type "String -> IO Char"?
20:46:26 <xunie-laptop> I'm quite fresh it Haskell, but shouldn't the bind just... work?
20:49:12 <shachaf> What does taht mean?
20:50:15 <xunie-laptop> shachaf, are you talking to me?
20:50:34 <shachaf> xunie: I am now!
20:50:40 <pqmodn> xunie-laptop: perhaps you meant show <$> getLine? it's not clear what you wanted to do
20:50:56 <joeyh_> or getLine >>= print
20:51:15 <shachaf> It's not clear, so I recommend making it clear rather than hoping that someone guesses what you intended. :-)
20:51:42 <xunie-laptop> Yeah, sorry. My intention is to start understanding monads.
20:51:53 <shachaf> Did you read the FAQ?
20:51:55 <shachaf> @where faq
20:51:55 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
20:52:01 <dmj`> xunie-laptop: show is not an IO action. It simply returns the string representation of an object
20:52:02 <shachaf> It has a good section that you should read.
20:52:03 <pqmodn> xunie-laptop: LYAH is also a good place to start
20:52:17 <shachaf> (Also: "understanding monads" and "understanding IO" are too completely different things.)
20:52:25 <td123> so alsa-pcm doesn't let you specify # of channels for outputting..
20:52:26 * hackagebot monoid-subclasses 0.3.3 - Subclasses of Monoid  http://beta.hackage.haskell.org/package/monoid-subclasses-0.3.3 (MarioBlazevic)
20:52:43 <dmj`> xunie-laptop: what you probably wanted was "getLine >>= putStrLn"
20:54:17 <shachaf> If someone asks a vague question, and you guess, there are two possibilities: You guess wrong (where does putStrLn/show/whatever come from?), and just confuse them further. Or you guess right, and then they don't learn to ask questions that don't require wild guessing.
20:54:35 <td123> which is why I've been having a hard time with alsa-pcm playing correctly, because it's not possible with the current library
21:00:46 <xunie-laptop> shachaf, yeah, I asked a vague question. I'm really confused right now. I need to think.
21:00:49 <xunie-laptop> dmj` you were wrong, I'll get back to you.
21:01:40 <shachaf> xunie-laptop: Three ingredients of a good question are: What did you do? What did you expect? What actually happened?
21:01:55 <shachaf> You're missing the second one so it's hard to answer the question.
21:02:23 <dmj`> xunie-laptop: by all means, show me where I was wrong and correct me
21:02:28 <shachaf> I mean, it's obviously a type error: (>>=) :: IO a -> (a -> IO b) -> IO b; getLine :: IO String; show :: Show a => a -> String
21:02:30 <Saizan> shachaf: is he? "I expect getLine >>= show to typecheck" is what i read
21:03:19 <xunie-laptop> dmj`, you weren't wrong about your answer. Just about what I wanted to do. I asked an extremely vague question. No insult intended.
21:03:48 <xunie-laptop> shachaf, and these are questions I'm asking myself right now, and it's hard.
21:04:11 <shachaf> "shouldn't that just work" doesn't make sense to me because I don't know what "work" means.
21:04:24 <shachaf> That's why I asked what it meant.
21:05:12 <shachaf> Anyway I'm not objecting to xunie-laptop's question in particular but to random guesses at what they might possibly have been going for.
21:06:15 <Saizan> xunie-laptop: basically the problem with that code typechecking is that show's result type is String, while (>>=)'s second argument must have a result type of the form "IO b" for some b
21:07:15 <dmj`> xunie-laptop: Can you state in clearer terms what you are trying to do, maybe post some code on lpaste.net, the intention is to help.
21:07:24 <xunie-laptop> Saizan, so it's impossible to have a monad with the type a -> b where a and b are both not IO?
21:07:46 <Saizan> xunie-laptop: the monad here is IO, the type constructor
21:07:54 * haasn pops into #haskell
21:08:15 <xunie-laptop> dmj`, there is nothing I am 'trying' to do. I'm simply trying to become familiar with the language.
21:08:47 <xunie-laptop> I'm so confused as to Haskell. I really need to go back to a tutorial.
21:08:54 <xunie-laptop> BRB, rereading Learn You a Haskell.
21:09:14 <Saizan> xunie-laptop: if you have a function (a -> b) and want to compose it with an action of type IO a, you can use "m >>= \x -> return (f x)"
21:09:25 <Saizan> xunie-laptop: where m :: IO a, and f :: a -> b
21:09:33 <jle`> dmj`: i am not sure if you replied last time, i went afk, but i managed to get favicons working on a scotty app on heroku? there was no special process i needed to go through
21:10:33 <Saizan> xunie-laptop: because "return :: Monad m => a -> m a" can be used to create an action with no effects but with the given argument as result
21:11:19 <Saizan> xunie-laptop: by "action" here i just mean a value of type "m a" for some monad m (e.g. IO) and type a
21:12:24 <Saizan> xunie-laptop: it's good practice to think of them as _descriptions_ of some effects to be perfomed to obtain the result
21:13:43 <Saizan> and what "effects" mean is entirely monad specific
21:16:19 <jle`> i think Maybe is probably the easiest monad to understand, in terms of what bind and return mean ... and understanding maybe might be a good start to being on the right track
21:16:54 <shachaf> What the FAQ says about this is very relevant.
21:17:50 <shachaf> It doesn't quite make sense to "understand a monad", unless you mean understanding the type which happens to be a monad, and understanding some specific questions.
21:17:56 <shachaf> s/question/function/
21:18:33 <shachaf> "monad" is an abstraction. You won't understand it just by understanding any one concrete thing which it happens to abstract.
21:18:40 <shachaf> (Unless it's Codensity or something.)
21:18:45 <mrotondo> How do you partially apply an applicative functor? i.e. I can do ``` (:) <$> (Just 1) <*> (Just [2,3]) ```, but I want to do ``` let f = (:) <$> (Just 1) <*> ``` (which doesn't work, and neither does leaving off the <*>)
21:19:14 <Saizan> mrotondo: (:) <$> (Just 1) works
21:19:41 <user123abc> xunie-laptop, having just learned monads, I'd recommend just trying to write some code that uses them, and referring to the material to answer actual pressing questions
21:19:52 <Saizan> mrotondo: or liftA2 (:) (Just 1) if you prefer to not need another <*> when you complete the application
21:20:00 <mrotondo> Saizan:
21:20:08 <mrotondo> Saizan: Ah, that's the ticket. Thanks!
21:20:42 <shachaf> mrotondo: Probably what you're after is: let f x = (:) <$> (Just 1) <*> x
21:21:04 <Saizan> right, i was going to mention lambdas :)
21:21:15 <jle`> shachaf: by what i said, i meant that concepts like bind and return can be understood well in their implementations in the Maybe type.  and understanding why bind and return are useful and helpful for taming Maybe will help you in your journey of understanding their usefulness as a general abstraction
21:21:19 <shachaf> There are many other ways to write that but that's the most direct answer to your question. To abstract something in a function, just make it an argument to that function.
21:21:25 <mrotondo> shachaf: This is definitely one more instance of me not knowing when & when not to pursue point-free
21:21:39 <shachaf> Answer: Never pursue point-free.
21:21:51 <shachaf> Point-free is a shortcut, or an optimization.
21:22:09 <shachaf> You can always try it if you feel like it. But it's never necessary or anything.
21:23:18 <shachaf> You can use a simpler example: (*) (1 + 1) (2 + 2)
21:23:29 <shachaf> To abstract the (2 + 2), write: let f x = (*) (1 + 1) x
21:23:54 <shachaf> Now you can eta-reduce -- i.e. get rid of that x argument -- after the fact.
21:24:09 <Saizan> don't look for combinators because of pointfree, look for them to help with abstraction
21:24:39 <mrotondo> Okay, cool. That's helpful.
21:25:41 <dmj`> jle`: you should submit a pull request to the scotty-starter project for the favicon on heroku thing you did
21:26:51 <jle`> dmj`: sure, i'll see what i can do
21:27:08 <jle`> also i hope you don't mind that i stole the idea to end a nick with `
21:27:19 <Saizan> (i'm realizing my last line is very punnery)
21:28:51 <dmj`> jle`: I'm flattered ;)
21:29:49 <dmj`> jle`: the '`' came from dmj always being taken (since I leave too many irc buffers open) and erc auto-adding it.
21:36:15 <jle`> it's a lot nicer than _
21:43:30 <chrisdotcode> how can I change a number into a list of that number, containing all one? so like 4 => [1,1,1,1] ?
21:43:44 <chrisdotcode> unfold or something maybe?
21:43:53 <shachaf> replicate
21:46:31 <copumpkin> @hoogle Int -> a -> [a]
21:46:31 <lambdabot> Prelude replicate :: Int -> a -> [a]
21:46:31 <lambdabot> Data.List replicate :: Int -> a -> [a]
21:46:31 <lambdabot> Prelude drop :: Int -> [a] -> [a]
21:46:50 <copumpkin> chrisdotcode: in general, if you think about what the type of the thing you want might look like, you can ask @hoogle to find it for you
21:47:05 <copumpkin> @hoogle a -> Int -> [a]
21:47:05 <lambdabot> Prelude replicate :: Int -> a -> [a]
21:47:05 <lambdabot> Data.List replicate :: Int -> a -> [a]
21:47:05 <lambdabot> Prelude drop :: Int -> [a] -> [a]
21:47:34 <chrisdotcode> copumpkin: checked that already, but a bit less abstract, I was looking for a "repeat function n times" as :: Int -> (a -> b) -> a -> b , but I either didn't find much, or didn't know what I was looking for
21:47:51 <Ralith> chrisdotcode: surely you mean (a -> a) -> a -> a
21:48:03 <chrisdotcode> Ralith: why all "a"s?
21:48:23 <Ralith> how would you implement it otherwise?
21:48:48 <chrisdotcode> Ralith: why not (a -> b) -> a -> b?
21:49:01 <Ralith> how would you implement it?
21:49:09 <chrisdotcode> > replicate 4 []
21:49:10 <lambdabot>   [[],[],[],[]]
21:49:15 <chrisdotcode> > replicate 4 [1]
21:49:16 <lambdabot>   [[1],[1],[1],[1]]
21:49:18 <chrisdotcode> > replicate 4 1
21:49:19 <lambdabot>   [1,1,1,1]
21:49:28 <chrisdotcode> @src replicate
21:49:28 <lambdabot> replicate n x = take n (repeat x)
21:49:41 <haasn> :t foldr (.) id . replicate
21:49:41 <lambdabot>     Couldn't match type `a0 -> [a0]' with `[b0 -> b0]'
21:49:42 <lambdabot>     Expected type: Int -> [b0 -> b0]
21:49:42 <lambdabot>       Actual type: Int -> a0 -> [a0]
21:49:44 <haasn> :t foldr (.) id .: replicate
21:49:45 <lambdabot>     Not in scope: `.:'
21:49:45 <lambdabot>     Perhaps you meant one of these:
21:49:45 <lambdabot>       `.' (imported from Data.Function),
21:49:51 <haasn> :t \x -> foldr (.) id . replicate x
21:49:52 <lambdabot> Int -> (b -> b) -> b -> b
21:50:16 <chrisdotcode> haasn: yeah, to repeat a function x times, with the acc argument like foldr
21:50:51 <haasn> :t \x -> foldrOf (replicated x) (.) id -- lenses wooh
21:50:52 <lambdabot> Int -> (c -> c) -> c -> c
21:54:54 <pqmodn> :t ((!!) .) . iterate
21:54:55 <lambdabot> (a -> a) -> a -> Int -> a
21:55:26 <haasn> yuck!
21:55:37 <Fuuzetsu> lens users need not apply
21:55:41 <haasn> ;_;
21:56:14 <pqmodn> :t (:.)
21:56:14 <lambdabot>     Not in scope: data constructor `:.'
21:56:15 <lambdabot>     Perhaps you meant one of these:
21:56:15 <lambdabot>       `:+' (imported from Data.Complex),
21:56:25 <Fuuzetsu> :t ((.) . (.))
21:56:25 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
21:56:47 <pqmodn> @let (.:) = (.) . (.)
21:56:47 <lambdabot>  Defined.
21:57:16 <Fuuzetsu> so should :. be flip (.:)?
21:57:21 <haasn> Fuuzetsu: :. is a constructor
21:57:22 <Fuuzetsu> :t flip (.:)
21:57:22 <lambdabot> (a -> a1 -> b) -> (b -> c) -> a -> a1 -> c
22:21:37 <jmcarthur> :t (fmap.fmap) (!!) iterate
22:21:37 <lambdabot> (a -> a) -> a -> Int -> a
22:22:26 <haasn> :t fmap fmap fmap (!!) iterate
22:22:26 <lambdabot> (a -> a) -> a -> Int -> a
22:22:46 <haasn> -- optimized for fewer parens
22:22:47 * hackagebot statgrab 0.1.0 - Collect system level metrics and statistics  http://beta.hackage.haskell.org/package/statgrab-0.1.0 (BrendanHay)
22:28:24 <haasn> edwardk: Just what kind of relationship are you and SPJ in??
22:30:26 <MedDev> bromantic i hope :D
22:57:51 * hackagebot yi 0.7.0 - The Haskell-Scriptable Editor  http://beta.hackage.haskell.org/package/yi-0.7.0 (DmitryIvanov)
22:57:52 * hackagebot yi-contrib 0.7.0 - Add-ons to Yi, the Haskell-Scriptable Editor  http://beta.hackage.haskell.org/package/yi-contrib-0.7.0 (DmitryIvanov)
23:08:59 <shachaf> kosmikus: And unlike SPJ, you're in IRC!
23:10:04 <shachaf> kosmikus: "operational" is nice to mention, as you mention. And in particular the way Operational f = Free (CoYoneda f)
23:11:40 <shachaf> I also like the whole "free monad monad monad algebra" thing (though that particular phrasing is obscure on purpose).
23:12:50 <haasn> free monad monad monad algebra?
23:13:15 <shachaf> That's the law for class Functor m => Monad m where monad :: Free m a -> m a
23:13:49 <haasn> makes sense!
23:14:18 <shachaf> It does?
23:15:13 <haasn> I think so?
23:15:29 <haasn> well, monad :: Free m a -> m a -- certainly does
23:15:37 <shachaf> Right.
23:15:43 <shachaf> Also the same for Comonad.
23:15:50 <haasn> as for “free monad monad monad algebra”, I guess “free (monad) monad” <- the free monad from a monad; “monad algebra”
23:16:00 <haasn> as in that operation?
23:17:07 <shachaf> https://twitter.com/kmett/status/384766778062016512 -- maybe the hyphens improve it.
23:17:51 <haasn> yes
23:18:41 <haasn> though now I'm not sure what a free-monad is
23:24:17 <arkeet> haasn: the "free monad" operation gives you a monad
23:24:23 <arkeet> the free monad monad
23:24:26 <arkeet> it's a monad algebra for that monad.
23:24:31 <bigos> Hello, I'm trying to achieve something that I have written in sml with haskell.  I am trying to define a mutually recursive datatype.  In sml we can use the 'and' keyword.  [http://en.wikipedia.org/wiki/Mutual_recursion#Data_types].  Ty
23:25:00 <haasn> arkeet: that's what I thought but the hyphens don't seem to agree with it
23:25:02 * haasn tries not overthinking
23:25:11 <arkeet> I don't know why there are hyphens.
23:25:14 <arkeet> they shouldn't be there.
23:25:18 <Saizan> haasn: basically, if you have data Free f a = Return a | Branch (f (Free f a)), that takes functors (f :: * -> *) and produces Monad (Free f), but Free itself is also a functor from (* -> *) to (* -> *) which is a monad too!
23:25:26 <Saizan> but on (* ->
23:25:37 <Saizan> on (* -> *) rather than *
23:25:57 <haasn> oh, I see
23:25:59 <haasn> so a monad not a Monad
23:26:22 <haasn> .. can we have monads like that in Haskell?
23:26:33 <arkeet> a monad in the sense of category theory
23:26:34 <haasn> as a type class
23:27:09 <Saizan> algebras of Free will be a functor f with an operation alg :: forall a. Free f a -> f a
23:27:19 <Saizan> which respect the laws
23:27:39 <Saizan> haasn: we sort of can
23:28:41 <Saizan> haasn: http://code.haskell.org/~Saizan/FreeMonad.hs
23:29:17 <shachaf> I wish people didn't call it Free.
23:29:59 * arkeet nods
23:30:22 <Saizan> too late for that!
23:30:33 <arkeet> it happens that algebras for the "free X
23:30:33 <haasn> shachaf: do you have something better in mind?
23:30:39 <arkeet> monad algebras, that is.
23:30:52 <haasn> Saizan: so monad :: Free f :-> f
23:31:32 <Saizan> haasn: right
23:31:46 <shachaf> Saizan: It's never too late!
23:31:58 <Saizan> haasn: if that satisfies the T-algebra laws you get a monad instance for f
23:32:06 <Saizan> Monad, even
23:32:59 <Saizan> shachaf: tbf, i call all my forgetful functors U, so i'm fine with calling each free one Free
23:34:16 <shachaf> Saizan: You should call this U.Free, then.
23:34:49 <shachaf> In Haskell we call our forgetul functors "". :-(
23:34:52 <shachaf> f
23:35:53 <Saizan> heh, i wish i had more implicit projections when doing this stuff in Agda tbf
23:42:26 <osfameron> Free as in Beer, or Free as in Monads? ;-)
23:42:56 <c_wraith> free as in category theory
23:59:19 <lpaste> haasn pasted “HComonad” at http://lpaste.net/93806
23:59:25 <haasn> can somebody confirm this looks correct?
23:59:37 <haasn> I just sort of went with the types but I have no idea if the operations are right..
