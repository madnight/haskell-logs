00:00:13 * hackagebot test-framework-sandbox 0.0.2.2 - test-sandbox support for the test-framework package  http://hackage.haskell.org/package/test-framework-sandbox-0.0.2.2 (BenjaminSurma)
00:00:15 * hackagebot test-sandbox 0.0.1.6 - Sandbox for system tests  http://hackage.haskell.org/package/test-sandbox-0.0.1.6 (BenjaminSurma)
00:28:35 <individual> can I override a class instance with my own?
00:31:32 <startling> nope.
00:31:45 <startling> you can write a newtype with that class instance, though.
00:33:59 <Axman6> Hello!
00:37:17 <lpaste> Axman6 pasted “Go-like defer” at http://lpaste.net/94328
00:37:23 <tdammers> well, if the instance is defined outside the modules that define the type and the class, you can simply not import the original instance and import your own instead
00:37:35 <tdammers> except that you shouldn't
00:40:06 <Axman6> so that code I just pasted was something I came up with a few weeks ago. wondering if anyone has improvements for it. it's supposed to add a Go style defer statement. wondering about what sort of semantics it should have for things like exceptions thrown in the deferred statements, whether a Maybe a return type makes more sense, anything else
00:40:23 * hackagebot transformers 0.2.2.1 - Concrete functor and monad transformers  http://hackage.haskell.org/package/transformers-0.2.2.1 (RossPaterson)
00:41:03 <startling> :o
00:43:57 <johnw> Axman6: isn't that the same thing as ResourceT?
00:44:16 <Axman6> no idea, possibly
00:44:24 <johnw> or the SafeT from pipes
00:44:31 <Axman6> @hoogle resourcet
00:44:32 <lambdabot> package resourcet
00:44:32 <lambdabot> System.Posix.Resource ResourceTotalMemory :: Resource
00:44:40 <johnw> both providing finalization bounded by a monad
00:44:42 <Axman6> @hackage resourceT
00:44:43 <lambdabot> http://hackage.haskell.org/package/resourceT
00:45:15 <Axman6> ooo, hackage has changed since I last looked at it
00:47:00 <arkeet> yep, hackage 2 now.
00:47:13 <johnw> running a local hackage is much nicer now too
00:47:49 <bergmark> haven't seen you about in a while Axman6 :o
00:48:02 <Axman6> very nice. last I saw hackage 2 was still a long way from release
00:48:23 <Axman6> bergmark: yeah, found a free night to drop back into the world of IRC
00:48:44 <bergmark> :)
00:50:55 <Axman6> johnw: I think my defer thing is a bit more lightweight. allocations are scoped more clearly too I think
00:51:47 <johnw> I fix the scoping of a "runResourceT" pretty clear
00:51:51 <johnw> s/fix/find
00:57:17 <Axman6> ResourceT seems complex...
01:05:50 <sopvop> heh, I made ghc type checker go mad with type families
01:07:08 <mauke> @def data ShowOff = forall a. (Show a) => ShowOff a
01:07:08 <lambdabot>  Parse failed: Illegal data/newtype declaration
01:08:49 <sopvop> you forgot `a` on lhs
01:09:25 <Axman6> not needed with the forall a
01:09:36 <danr> @def data ShowOff = ShowOff (forall a . Show a => a)
01:09:37 <lambdabot>  Parse failed: Parse error: =>
01:09:39 <danr> :(
01:10:34 <danr> regardless, I do appreciate the name ``ShowOff'' :)
01:10:42 <sopvop> @def newtype ShoOff = ShowOff (forall a . Show a => a)
01:10:42 <lambdabot>  Parse failed: Parse error: =>
01:10:52 <arkeet> it's @let
01:10:58 <sopvop> oh!
01:11:02 <danr> ho!
01:11:03 <arkeet> unless @def works too
01:11:08 <arkeet> @def f x = x + 5
01:11:09 <lambdabot>  Defined.
01:11:11 <arkeet> well then.
01:11:12 <mauke> @quite
01:11:13 <lambdabot> Maybe you meant: quote quit
01:11:13 <arkeet> > f 1
01:11:14 <lambdabot>   Ambiguous occurrence `f'
01:11:14 <lambdabot>  It could refer to either `L.f', defined at L.hs:1...
01:11:17 <arkeet> oops. duh
01:11:20 <mauke> @define
01:11:20 <lambdabot>  Define what?
01:11:24 <arkeet> @let
01:11:24 <lambdabot>  Define what?
01:11:26 <arkeet> heh.
01:11:39 <mauke> @redefine
01:11:40 <lambdabot> Maybe you meant: undefine define
01:11:40 <arkeet> I don't think lambdabot has Rank2Types.
01:11:45 <arkeet> or anything that lets you do that.
01:11:48 <mauke> @undefine
01:11:48 <lambdabot> Undefined.
01:12:01 <mauke> I only need existentials
01:12:01 <arkeet> blame elliott.
01:12:07 <arkeet> <arkeet> or anything that lets you do that.
01:12:08 <arkeet> =(
01:12:10 <danr> @set -XExistentialTypes
01:12:15 <arkeet> nice try
01:12:15 <arkeet> :p
01:12:19 <danr> :)
01:12:28 <arkeet> ok, I really better sleep.
01:12:35 <danr> good night
01:14:49 <sopvop> oh god, I've created a monster! (which typechecks though) compileSelect :: (FromExpr a ~ b,  AsExpr (FromExpr (AsExpr b)) ~ AsExpr b, IsExpr (FromExpr (AsExpr b))) => Select b -> ExprBuilder
01:14:58 <sopvop> Just to hide internal details from user!
01:16:07 <Axman6> yeah, they'll never find that confusing =)
01:19:50 <sopvop> Hm, turns out - IsExpr b was enough! :)
01:20:51 <Axman6> heh
01:25:32 * hackagebot test-framework-sandbox 0.0.2.3 - test-sandbox support for the test-framework package  http://hackage.haskell.org/package/test-framework-sandbox-0.0.2.3 (BenjaminSurma)
01:25:34 * hackagebot test-sandbox 0.0.1.7 - Sandbox for system tests  http://hackage.haskell.org/package/test-sandbox-0.0.1.7 (BenjaminSurma)
01:25:36 * hackagebot test-sandbox-hunit 0.0.1.5 - HUnit convenience functions for use with test-sandbox  http://hackage.haskell.org/package/test-sandbox-hunit-0.0.1.5 (BenjaminSurma)
01:25:38 * hackagebot test-sandbox-quickcheck 0.0.1.5 - QuickCheck convenience functions for use with test-sandbox  http://hackage.haskell.org/package/test-sandbox-quickcheck-0.0.1.5 (BenjaminSurma)
01:35:33 * hackagebot fields-json 0.2.2.2 - Abusing monadic syntax JSON objects generation.  http://hackage.haskell.org/package/fields-json-0.2.2.2 (MariuszRak)
01:48:03 <sopvop> in `cabal repl` :load loads file, but discards it away. Is there a workaround?
01:48:18 <sopvop> file is not in .cabal
02:12:05 <alexander__b> I have four functions. all of them retuns Maybe Point. these functions are to be called in a specific order. how do I call them in this order, and "bail out" when I get a Just Point, or follow through all of them and get Nothing?
02:12:57 <alexander__b> I want to let collisionPoint = [call the functions until I get a point], if Nothing then emptypoint (0, 0).
02:13:09 <fizruk> > Nothing <|> Just 1 <|> Just 2 <|> Nothing
02:13:10 <lambdabot>   Just 1
02:13:22 <fizruk> alexander__b
02:13:23 <alexander__b> oh. so that's what that does, heh.
02:13:35 <mauke> > Nothing `mplus` Just 1 `mplus` Just 2 `mplus` Nothing
02:13:36 <lambdabot>   Just 1
02:13:49 <mauke> :t fromMaybe (0, 0) . msum
02:13:50 <lambdabot> (Num t, Num t1) => [Maybe (t, t1)] -> (t, t1)
02:14:12 <fizruk> msum does different thing here, iirc
02:14:22 <alexander__b> so let collisionPoint = f1 <|> f2 <|> f3 <|> f4
02:14:23 <fizruk> > msum [Just 1, Just 2]
02:14:24 <lambdabot>   Just 1
02:14:38 <fizruk> :t msum
02:14:39 <lambdabot> MonadPlus m => [m a] -> m a
02:14:48 <alexander__b> then I need to do reflect collisionPoint or (0, 0)
02:14:51 <fizruk> oh, I thought it was monoidal sum
02:15:01 <alexander__b> what's the most concise way of doing collisionPoint or (0, 0) (if collisionpoint is Nothing)?
02:15:15 <alexander__b> I could do it with a case or an if or whatever, but maybe there's some neat way of doing it that I'm not familiar with.
02:15:19 <mauke> dude
02:15:46 <fizruk> :t mconcat
02:15:46 <lambdabot> Monoid a => [a] -> a
02:15:57 <fizruk> oh, that's monoidal sum!
02:16:45 <fizruk> alexander__b: mauke's already gave you the answer
02:17:01 <alexander__b> oh. they didn't highlight me, so I didn't notice. sorry, mauke.
02:18:16 <alexander__b> mauke: so let collisionPoint = f1 `mplus` f2 `mplus` f3 `mplus` f4 in reflect (fromMaybe (0 ,0) collisionPoint)?
02:19:00 <mauke> why not msum?
02:19:20 <alexander__b> instead of?
02:20:13 <fizruk> fromMaybe (0, 0) . msum [f1, f2, f3, f4]
02:20:29 <mauke> precedence error
02:20:47 <fizruk> fromMaybe (0, 0) . msum $ [f1, f2, f3, f4]
02:20:49 <alexander__b> fizruk: oh, right
02:21:19 <alexander__b> well, I think I'm going to make a function collisionPoint, and do reflect fromMaybe (0, 0) collisionPoint. and then in collisionPoint I guess I could use msum instead of mplus.
02:23:13 <alexander__b> thanks mauke and fizruk!
02:27:36 <m1dnight_> hi guys
02:28:13 <m1dnight_> http://pastebin.com/AqNdrKxa # I was wondering about that x and y in that function (in the where)
02:28:16 <m1dnight_> are they unbound?
02:28:18 <mauke> The paste AqNdrKxa has been copied to http://lpaste.net/94329
02:28:45 <m1dnight_> I understand that f and g are functions that take two parameters, but flip only takes one argument
02:29:16 <m1dnight_> so, how exactly does it work?
02:29:38 <m1dnight_> if I do 'flip max 1 2', it will put 'max 1 2' into flip?
02:29:55 <MasseR> No it will put max into the flip
02:29:56 <m1dnight_> or first put max into flip, and then apply that to 1 and 2?
02:30:07 <MasseR> flip f a b = f b a
02:30:20 <jophish> Yo yo yo
02:30:24 <m1dnight_> so those x and y are actually unbound variables?
02:32:26 <Axman6> m1dnight_: flip f a b === (((flip f) a) b), if that helps
02:33:10 <m1dnight_> ah okay, that explains the order of evaluation yes :)
02:33:11 <m1dnight_> thanks
02:33:12 <alexander__b> is there a way of writing this: http://lpaste.net/6486480745400369152 that is more concise but doesn't sacrifice too much readability?
02:33:23 <alexander__b> I'm thinking for the future when there will be more things to test against
02:33:45 <Axman6> m1dnight_: well, it explains the order of application, evaluation is another matter =)
02:34:05 <m1dnight_> ah yes, application :D thanks again!
02:38:45 <fizruk> alexander__b: [f b p | f <- [collideCorners, collideEdges], p <- [p1, p2]]
02:40:24 <Connorcpu> bah. anyone else find themselves often just clearing out their packages and reinstalling? .-.
02:40:25 <alexander__b> fizruk: wow. I hadn't even considered using list comprehensions. that looks really neat! thanks.
02:42:07 <fizruk> > [(x, y) | x <- [1, 2], y <- [3, 4]]
02:42:08 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
02:42:18 <fizruk> > [(x, y) | y <- [3, 4], x <- [1, 2]]
02:42:19 <lambdabot>   [(1,3),(2,3),(1,4),(2,4)]
02:42:21 <kuribas> alexander__b: I would keep it as you wrote it.
02:48:19 <kuribas> Alternatively: collisionPoint b p1 p2 = msum $ do p <- [p1, p2]; [collideCorners b p, collideEdges b]
02:48:57 <kuribas> It's the same as the list comprehension, but in monad form.
02:53:31 <remdezx> Hi! I want to ship ghc with my application, but I have a problem with libgmp.so.3 which is required to run and build ghci. I'm afraid to add libgmp library to a package (it could not work on some platforms) and symlinkig is also not a solution here. What is the best way to solve this problem?
02:53:56 <bxc> install in a cabal sandbox appears to still see the packages installed in my top level user cabal, and then upgrade conflicts make it upset and not want to build... is there a way around that without destroying my top level cabal dir?
02:54:47 <donri> bxc: it shouldn't see ~/.ghc, do you mean /usr ?
02:54:53 <donri> or /var or whatever
02:55:32 <bxc> donri: let me show you error.
02:56:05 <bxc> oh wait
02:56:12 <bxc> behaviour is different if i'm in a subdir of a sandbox!
02:56:25 * bxc was expecting git-like behaviour of "walk up the tree"
02:56:51 <donri> nope, there's a flag for specifying the sandbox path though
02:56:57 <kuribas> Is there a simple safe functional extension language that I can use in haskell projects?
02:57:09 <bxc> donri: i'll make a new sandbox one level down - thats fine for now
02:57:49 <donri> kuribas: not sure what you mean there
02:58:44 <bxc> remdezx: are you targetting linux or windows?
02:59:29 <kuribas> I want to experiment with making a music notation program, where the music description language and programming system (macros) are separate.
02:59:30 <remdezx> bxc: both, but linux version will be released first
02:59:57 <kuribas> donri: But the programming system should be safe.  So using haskell for macros is not possible.
03:00:35 <donri> kuribas: SafeHaskell?
03:01:27 <kuribas> donri: maybe...
03:01:52 <kuribas> Does it allow unsafePerformIO?
03:02:01 <bxc> remdezx: the linuxy way would be to use whatever that platforms package manager is, and put a dependency on ghc in the native package?
03:02:02 <donri> kuribas: nope
03:02:31 <donri> kuribas: basically it makes the type not lie. so it still allows IO, but only if the type is IO
03:03:16 <remdezx> bxc: yes, but most linuxes have libgmp.so.10 or newer, but ghc requires ancient libgmp.so.3
03:03:29 <kuribas> donri: Can it be used as an interpreted language?
03:03:46 <donri> kuribas: sure. i think lambdabot does that
03:04:02 <kuribas> Ok, cool!
03:04:23 <donri> @hackage hint
03:04:23 <lambdabot> http://hackage.haskell.org/package/hint
03:04:27 <remdezx> bxc: I read something about ghc having this library included in case there will be no libgmp in the system, but I don't know how can I make ghc use it. Maybe I misunderstood something.
03:04:49 <bxc> remdezx: if you ask the native package manager to install ghc for you, do you have further problems beyond that?
03:05:03 <bxc> remdezx: eg apt-get install ghc or haskell-platform on a debian-like?
03:05:19 <bxc> remdezx: at least for platforms where such a system exists...
03:06:01 <remdezx> no, I have patched ghc with my libraries preinstalled. I could not install it from repo
03:06:27 <bxc> oh a patched ghc
03:06:34 <bxc> ok
03:06:54 <bxc> more complicated
03:07:00 <remdezx> true
03:12:01 <remdezx> bxc: have you any idea how to solve this problem?
03:13:01 <bxc> remdezx: not in general. my first approach would probably be, for each platform, to diddle the native packaging to make your own ghc installer package.
03:13:34 <bxc> but i have a strong preference for stuff that integrates with native packaging.
03:14:38 <remdezx> bxc: If I could just force ghc to use system libgmp in newer versions it would be a solution
03:15:49 * hackagebot halberd 0.1.2.3 - A tool to generate missing import statements for Haskell modules.  http://hackage.haskell.org/package/halberd-0.1.2.3 (ErikHesselink)
03:16:50 <bxc> remdezx: ahh the almighty "just"
03:17:21 <remdezx> :D
03:26:48 <remdezx> bxc: what do you mean by "diddle the native packaging"?
03:27:24 <bxc> remdezx: you can get the source definitions for the ghc package
03:27:44 <bxc> remdezx: for each platform (ubuntu, debian, redheat)
03:28:03 <bxc> remdezx: and make your own package that is the same except using a different ghc source tarball
03:28:21 <bxc> remdezx: that way it will install the same as ghc normally does on that particular platform but using your version of ghc
03:28:47 <bxc> remdezx: then however that platform chose to deal with installing ghc, you will do it the same way
03:28:59 <bxc> remdezx: its going to be specific to each variety of linux, though
03:29:00 <brainacid> hey everyone
03:29:07 <brainacid> is this also true for haskell
03:29:31 <brainacid> http://pastie.org/8406077
03:29:49 <brainacid> i copied it from a math function book
03:30:26 <donri> brainacid: only for pure and total functions
03:30:28 <remdezx> bxc: seems interesting. Where can I find these source definitions?
03:30:31 <Lethalman> brainacid, haskell can have errors unfortunately or bottom
03:30:40 <brainacid> thanks yall
03:30:40 <brainacid> have a good day
03:31:07 <bxc> remdezx: its different per distribution.
03:32:19 <bxc> remdezx: eg on debian chekc out perhaps the https://wiki.debian.org/apt-src command
03:32:47 <bxc> remdezx: packaging is much more effort than you expect it to be though.
03:33:17 <Flonk> Dealing with numbers in Haskell is weird at times..
03:33:20 <remdezx> bxc: I know. I'm asking where can I fing ghc's spec files
03:33:25 <Flonk> I need to check whether an int is a power of 2
03:33:42 <bxc> remdezx: that apt-src command should download them
03:33:47 <Flonk> @let ispw2 :: Int -> Bool; ispw2 x = let lg = logBase 2 (fromIntegral x) in lg - (floor lg) == 0.0
03:33:47 <lambdabot>  .L.hs:145:14:
03:33:47 <lambdabot>      No instance for (Floating a0) arising from a use of `logB...
03:33:47 <bxc> remdezx: i think
03:33:56 <tdammers> Flonk: there are bit-fiddling tricks for that
03:34:39 <Flonk> tdammers: There is?
03:34:44 <remdezx> bxc: ok, I will check that, thanks! ;)
03:35:21 <tdammers> http://graphics.stanford.edu/~seander/bithacks.html
03:36:22 <Flonk> tdammers: v & (v-1), thats pretty smart
03:36:22 <tdammers> that's the one, I think
03:36:27 <Flonk> tdammers: Thanks!
03:36:42 <Flonk> Although I'd still like to know why ghc is complaining about my code
03:36:48 <tdammers> idk
03:36:53 <tdammers> I'm having lunch now
03:38:24 <mm_freak_> Flonk: check out the arithmoi package
03:38:33 <g3orge> can somebody clear this up for me? I know function1 (function2 arg) is the same as function1 $ function2 arg but is this also the same as (function1.function2) arg ??
03:38:50 <Hafydd> It is.
03:39:05 <mm_freak_> Flonk: http://hackage.haskell.org/package/arithmoi-0.4.0.3/docs/Math-NumberTheory-Powers.html
03:39:10 <mm_freak_> see isKthPower
03:39:11 <g3orge> thanks Hafydd
03:39:48 <mm_freak_> Flonk: in Math.NumberTheory.Logarithms you also get integerLog2 and integerLogBase for arbitrarily large integers
03:40:21 <Flonk> mm_freak_: Cool, thats pretty handy
03:40:41 <mm_freak_> i can't imagine getting anything done without arithmoi =)
03:41:16 <fizruk> g3orge: it is also function1 . function2 $ arg
03:41:28 <simpson> mm_freak_: Morning. I'm investigating using netwire for networking. Have you ever built anything like that?
03:41:37 <ocharles> do it!
03:41:38 <mm_freak_> simpson: yes
03:41:51 <mm_freak_> simpson: that was its original motivation =)
03:41:54 <chrisdone> has anyone applied lisp-like macros to an ML-like syntax?
03:42:49 <simpson> mm_freak_: Awesome. My two main problems are that I can't see how to bring data from sockets into Wires, and that I'm not sure how to run a Wire network slowly, so that it only reacts to timers or incoming network data instead of constantly.
03:45:51 <mm_freak_> simpson: how to bring data into a wire:  through events
03:46:18 <mm_freak_> simpson: just use stepWire/stepSession and step the wire when new data/events arrive
03:47:50 <simpson> So should I forkIO my socket reads and writes?
03:49:08 <simpson> Or is there a better way to avoid socket reads blocking everything?
03:49:37 <kuribas> chrisdone: There was a project to use s-expressions for haskell syntax: http://clemens.endorphin.org/ILC07-Liskell-draft.pdf
03:50:40 <chrisdone> kuribas: sure, that's doing lisp-like macros with lisp syntax
03:51:24 <simpson> mm_freak_: The approach I've used in other languages is to have a priority queue with all of the pending timers, and sleep for the duration of the shortest one. Is that still reasonable here?
03:51:49 <_mkrull> hi there. could you recommend a general purpose template library in haskell like Perl's Template Toolkit or Ruby's erb?
03:51:52 <mm_freak_> simpson: forking will be the easiest way right now
03:52:07 <mm_freak_> simpson: use an MVar for communicating events to the wire's controlling thread
03:52:18 <mm_freak_> simpson: later there will be a functor from wires to pipes
03:52:26 <mm_freak_> (it already exists, but it's not public)
03:52:39 <Sonderblade> chrisdone: julia is kind of ml-like?
03:52:53 <kuribas> chrisdone: well, lisp macros work so well, because lisp syntax is so simple.  It would be very difficult to do that with ML.
03:53:34 <mm_freak_> _mkrull: there are many, hstringtemplate, heist (XML), etc.
03:53:51 <aristid> there's Liskell
03:53:55 <simpson> mm_freak_: Alrighty. I had anticipated something like that. And then I guess that for timers, it's mostly a matter of how much responsiveness I want?
03:54:00 <kuribas> I'd be very intersted in haskell in Lisp syntax.
03:54:05 <chrisdone> aristid: yeah already mentioned
03:54:16 <mm_freak_> simpson: exactly
03:54:18 <simpson> I *really* wish that I had select(); I want to wake up either when there's data to read, or when my next timer has gone off.
03:54:22 <aristid> chrisdone: nevermind:)
03:54:40 <mm_freak_> simpson: you have something better than select():  concurrency =)
03:54:41 <kuribas> But liskell doesn't seem to be useable.
03:54:48 <mm_freak_> simpson: just create a thread for everything
03:55:34 <simpson> mm_freak_: But how do I put my application to sleep for extended periods of time?
03:56:00 <mm_freak_> simpson: with STM it's easy
03:56:05 <kuribas> The only good thing about ML syntax is the convenience of infix functions.
03:56:16 <mm_freak_> data Blocked = Blocked | Ready
03:56:19 <kuribas> But that is overrated.
03:56:19 <mm_freak_> TVar Blocked
03:56:20 <chrisdone> kuribas: nope, i looked at liskell before i started on lisk, it was a patch of ghc, vaporware
03:56:45 <mm_freak_> simpson: as always i recommend The Book =)
03:56:48 <mm_freak_> http://chimera.labs.oreilly.com/books/1230000000929
03:56:50 <chrisdone> i think macros in the presence of infix operators could be done
03:57:13 <aristid> isn't a big reason just that macros aren't as necessary in haskell?:P
03:57:21 <chrisdone> no
03:57:36 <mm_freak_> simpson: i have to go now…  power will be out for a few hours…  if you're here in ~4-5 hours, i can answer further questions
03:57:48 <mm_freak_> simpson: you can also ask ocharles, if he has time and is willing to help =)
03:57:49 <kuribas> aristid: With lisp macros you can do things not possible in haskell, logic programming for example.
03:57:53 <aristid> they're still needed for some things, but you don't need them to get loop syntax fir example.
03:57:54 <simpson> mm_freak_: No worries. Thanks for your time. I hope to understand all this and put it to use. Take it easy. :3
03:58:20 <mm_freak_> alright, see you later
03:58:31 <aristid> kuribas: i wouldn't dispute that.
03:58:49 <kuribas> aristid: At the syntax level I mean.  You can do logic programming in haskell, but a good macro library can make that a lot more convenient.
03:59:23 <chrisdone> x + y * z could be tokenized as [x,+,y,*,z] and then the parser would say "i see that + has lower precedence than *", so you get [+,x,[y,*,z]] and then, if + is a macro, the macro is called with those tokens
03:59:23 <kuribas> aristid: for example http://kanren.sourceforge.net/
03:59:55 <aristid> chrisdone: so the macro would work on the AST?
04:00:02 <chrisdone> aristid: that's what lisp macros do
04:00:03 <_mkrull> mm_freak_: thank you, hstringtemplate seems to do exactly what i was searching for
04:00:15 <kuribas> chrisdone: indeed
04:00:39 <aristid> chrisdone: and your proposal does not?
04:01:30 <chrisdone> aristid: my proposal does?
04:01:49 <aristid> chrisdone: agh you're confusing me :P
04:01:59 <donri> i'm still struggling to understand how lisp macros are different from TH other than not sucking
04:02:12 <aristid> chrisdone: [+,x,[y,*,z]] does look like a syntax tree
04:02:26 <aristid> i mean AST
04:02:31 <chrisdone> aristid: ok?
04:03:05 <chrisdone> i think it's a lot easier to have macros in an infix language if infix operators themselves cannot be macros
04:03:20 <chrisdone> if they can, then it seems more detailed
04:04:08 <mgsloan> Hmm, what's the difference between that and TH?  Is it that function application is macro application?
04:04:32 <chrisdone> (foo bar mu) in lisp is either function application or macro application. macros take precedent
04:04:51 <chrisdone> if `foo' is macro, then bar and mu are passed as tokens to foo. if it's a function, it's applied
04:04:57 <mgsloan> I'm not too familiar with using lisp macros, but it seems like TH is pretty darn close.  The big difference is that it's a statically typed AST instead of a homogenous AST
04:05:59 <ij> mgsloan, May I ask what is TH?
04:06:13 <kuribas> chrisdone: Does your program compile to haskell syntax, and then compile it, or does it use the internal representation of ghc?
04:06:22 <mgsloan> ij: Template Haskell, GHC's answer to compiletime code generation
04:06:23 <ocharles> simpson: I'm willing to help :)
04:06:38 <ocharles> what you're doing is a new area for me, but it'll be a fun learning experience
04:06:41 <ocharles> that's what they say, right?
04:06:42 <chrisdone> kuribas: lisk? yeah, that was just a translator from lisp to haskell and back
04:07:50 <chrisdone> really, the fundamental difference between lisp's macros and TH is lisp macros don't require special syntax to invoke
04:07:51 <mgsloan> chrisdone: I think you've heard my opinion on this before, buut for the benefit of others:  I think that macros deserve to look very different from normal code.  Infact, TH's syntax is way too close to normal Haskell syntax for my taste
04:07:53 <simpson> ocharles: Yeah, I'm looking at several idioms that are popular in other languages for building robust networking stacks, and noticing that there appear to be serious deficiencies in current New Hotness libraries like pipes and conduits for addressing them.
04:08:15 <simpson> My goal is to be able to build the complex things, and maybe contribute to some of these libraries along the way.
04:09:00 <kuribas> chrisdone: haskell syntax is already very structured.  It's going to be difficult to make structure on top of that, unless you require it to follow haskell structure.
04:09:01 <mgsloan> chrisdone: Thing is, as aristid was saying, Haskell needs macros much less than lisp needs them.  Already, lazy evaluation and referential transparency is enough to do a lot of stuff previously relegated to macros
04:09:51 <chrisdone> i wasn't really criticizing haskell. my original question was whether anyone's tried lisp macros on an ML-like syntax (i.e. one with infix operators)
04:09:54 <mgsloan> chrisdone: So, it doesn't seem so good to break the nice property that function application is referentially transparent
04:09:54 <kuribas> mgsloan: I'd like to see a logic programming extension done in haskell!
04:10:05 <kuribas> mgsloan: Like kanren for scheme.
04:10:18 <chrisdone> (but #haskell took its natural course and applied an "it's about haskell" take on it, of course =)
04:10:55 <mgsloan> kuribas: That'd be pretty cool indeed!
04:11:22 <aristid> chrisdone: well haskell does fit all the criteria (i.e. it has infix operators ) :P
04:11:48 <chrisdone> mgsloan: i'm not sure whether it's possible to do that anyway in haskell due to partial application. lisp has (operand <param1> <param2>) to indicate "here comes a macro or function", haskell doesn't. but an ML lacking partial application could, maybe
04:12:47 <mgsloan> chrisdone: Not too much of a problem, you just wouldn't be able to use partial application with macros :)
04:13:12 <mgsloan> Actually, hmm
04:13:37 <mgsloan> Yeah, not very feasible :)
04:14:22 <kuribas> chrisdone: You have given up on lisp syntax for haskell?
04:15:05 <chrisdone> hm?
04:15:23 <chrisdone> that lisk project is on hiatus
04:15:39 <quchen> > ((++) ("lisp") (" in Haskell?"))
04:15:42 <lambdabot>   "lisp in Haskell?"
04:16:02 <chrisdone> it'll never be something i can use for public projects
04:16:05 <donri> > (mappend "lisp" " in Haskell!")
04:16:06 <lambdabot>   "lisp in Haskell!"
04:16:33 <donri> chrisdone: z? :)
04:16:43 <chrisdone> z ftw
04:17:08 <chrisdone> http://chrisdone.com/z
04:17:58 <mgsloan> Would be fun to have a GHC frontend that provided Z syntax
04:18:06 <chrisdone> haha
04:18:15 <chrisdone> ZHC
04:18:26 <mgsloan> Yeah, GHC taken to its natural conclusion ;)
04:19:23 <chrisdone> hmm you know it could be generalized
04:19:33 <chrisdone> just pass GHC an HSE AST!
04:19:45 <chrisdone> then you can do a multitide of experimental haskell syntaxes
04:20:48 <chrisdone> or perhaps the desuraged ast
04:21:04 <mgsloan> I do quite like the idea of having some a minimal structural syntax of some kind, such that there's one obvious way of encoding a given AST.  Then, have an editor that's smart enough to re-sugar
04:21:37 <chrisdone> we should get edwin to add this to the idris compiler so we're not stuck with ml syntax forever once idris takes over the world
04:21:51 <mgsloan> One problem is that then you start wanting to include re-sugaring hints, and the stored code starts looking really ugly
04:21:52 <quchen> chrisdone: Is that official?
04:21:58 <chrisdone> true
04:22:05 <chrisdone> quchen: is what official?
04:22:16 <quchen> chrisdone: Idris taking over the world ;-)
04:22:26 <chrisdone> are you a betting man?
04:22:35 <mgsloan> There might be a Coq fight or two
04:22:48 <quchen> Not sure, I'm still hoping for Haskell to take over the world, which taught me a thing or two about betting.
04:22:56 <chrisdone> I don't know if I agda strength to live through that
04:23:34 <ij> Does anyone here make some money with haskell?
04:23:35 <Fuuzetsu> mandatory Agda shout
04:23:47 <chrisdone> ij: at least three of us
04:23:48 <benj_> these puns aren't ALF bad
04:24:01 <quchen> On the other hand Haskell's niche position is nice to make bigger changes. It's still a mess to change Prelude, but not as impossible.
04:24:12 <chrisdone> Isabelle neccessary on a proof assistant?
04:24:24 <Fuuzetsu> it hurts to live
04:25:10 <quchen> Well that killed the discussion.
04:25:10 <derdon> ij: my prof does but that doesn't count I guess :P
04:25:20 <ij> derdon, :)
04:25:37 * quchen codes Haskell for a living, but doesn't earn any money doing so.
04:26:42 <chrisdone> unsafePerformHaskellCodingWithotFood
04:26:52 <ij> But doesn't "for a living" mean to earn money to live with it?
04:27:00 <derdon> quchen: can you explain that to me?
04:27:22 <quchen> Well I'd go nuts if I had to write C++ all day.
04:27:26 <osfameron> "will code haskell for food"
04:27:54 <quchen> I can tell you my above statement is true because I used to write C++ all day. ;-)
04:28:05 <derdon> ij: that's why I'm confused
04:28:10 <ghorn> i convinced my phd advisor to let me use haskell, so at least i'm not losing money coding haskell
04:28:13 <quchen> It was a joke. :-/
04:28:24 * derdon didn't get it :(
04:28:33 <Fuuzetsu> ghorn: what were the alternatives?
04:28:39 <chrisdone> quchen: your jokes are bad and you should ϕ bad
04:28:47 <ghorn> I dunno, drop out, get a real job
04:28:55 <Fuuzetsu> ghorn: language alternatives
04:28:56 <derdon> chrisdone: at least I got that one :)
04:29:15 * osfameron sobs at bad unicode terminal setup
04:29:27 <ghorn> python, matlab, mainly
04:29:28 <ghorn> C++
04:29:47 <Fuuzetsu> MATLAB makes me ill
04:29:52 <ghorn> :D
04:30:06 * chrisdone comforts osfameron with basic ASCII /o/
04:30:43 <quchen> H∀.
04:31:06 <ghorn> i recently got to talk trash about matlab with one of the early octave devs, it was very therapeutic
04:31:28 <Fuuzetsu> I lump Octave under the MATLAB umbrella
04:31:35 <osfameron> chrisdone: awww thanks
04:31:36 <Fuuzetsu> except I use Octave if I really have to use MATLAB
04:31:50 <hpc> i was going to say, that's like complaining about javascript to a coffeescript dev
04:31:51 <ghorn> yeah
04:32:05 <ghorn> this guy uses python now though
04:32:34 <chrisdone> hpc: sure is good up here on our high horses =p
04:33:22 <dibblego> is there a Data.Text.Text1 representing non-empty?
04:36:08 <hpc> chrisdone: i can see quite far from mine, on a pedestal on the top floor of the ivory tower
04:36:42 <hpc> and on that note, i am off to write perl for money ;)
04:36:45 <chrisdone> hpc: whenever i think of ivory towers i think of Terry Practhett's description of wizards during the warring years in Sorcery
04:37:10 <chrisdone> wizard n. (pl. war)
04:38:26 <kuribas> python has numpy and sympy.
04:40:22 <kuribas> Haskell just has a loose number of packages for doing numerical computing.  Nothing for symbolic math.
04:40:54 <mauke> > x ^ 2
04:40:55 <lambdabot>   x * x
04:40:57 <quchen> > a + b :: Expr -- Symbolix math!
04:41:00 <lambdabot>   a + b
04:41:06 <quchen> Eh, Mauke was faster.
04:42:12 <kuribas> > integrate (x ^ 2) :: Expr
04:42:13 <lambdabot>   Not in scope: `integrate'
04:42:13 <lambdabot>  Perhaps you meant one of these:
04:42:13 <lambdabot>    `iterate' (im...
04:42:19 <kuribas> :-(
04:42:21 <mauke> > deriv
04:42:23 <lambdabot>   Not in scope: `deriv'
04:42:24 <mauke> :-(
04:42:59 <mauke> 「deriv (2 * sin) x」 used to work
04:43:23 <quchen> > integrate (x^2)
04:43:27 <lambdabot>   1 / 3 * (x * x * x) + c
04:43:36 <kuribas> Let's port sympy to haskell :)
04:43:46 <individual> is there a way to run a function in Setup.hs if a specific file has been modified?
04:43:49 <mauke> :t integrate
04:43:50 <lambdabot>     Not in scope: `integrate'
04:43:50 <lambdabot>     Perhaps you meant one of these:
04:43:50 <lambdabot>       `iterate' (imported from Data.List),
04:44:03 <quchen> ;-)
04:44:12 <kuribas> > integrate (2*x^2)
04:44:13 <lambdabot>   Not in scope: `integrate'
04:44:13 <lambdabot>  Perhaps you meant one of these:
04:44:14 <lambdabot>    `iterate' (im...
04:44:15 <ghorn> taking a jacobian is relatively easy to implement, it's taking those symbolics and making an efficient function that's harder
04:44:53 <quchen> I guess writing an integration function is a nice beginner exercise. (For polynomials.)
04:45:09 <ghorn> yeah!
04:45:52 <kuribas> Symbolic integration is basicly pattern matching and a tree search.
04:46:24 <ghorn> i'm porting this guy to haskell right now: https://github.com/casadi/casadi/wiki
04:46:39 <ghorn> it's an efficient AD and optimization package
04:46:48 <alpounet> have you seen 'ad' ?
04:46:53 <ghorn> yeah
04:47:24 <ghorn> ad has a couple problems for me
04:47:35 <ghorn> mostly because it's too general
04:47:54 <kuribas> ghorn: nice!
04:49:05 <ghorn> because of the types 'ad' can handle (for instance vector length can change), it can't precompute the function graph and prepare an efficient callable function
04:49:16 <ghorn> it has all the initialization overhead each call you make
04:49:33 <ghorn> also, it doesn't do graph coloring which can make a huge difference in calculating jacobians
04:49:48 <ghorn> it's a really nice package though
05:07:09 <Delaware> is haskell good for dynamic programmign
05:07:22 <bergmark> it actually is :)
05:09:52 <bergmark> Thomas van Noort. Dynamic Typing in Type-Driven Programming. PhD Thesis, ICIS, may 2012, ISBN 978-94-6108-279-4.
05:10:19 <Taneb> What is dynamic programming?
05:10:44 <bergmark> oh i totally misread it as dynamic typing :(
05:10:59 <mauke> avoiding repeated work
05:11:05 * hackagebot fay 0.18.0.2 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.18.0.2 (AdamBergmark)
05:11:07 <bergmark> Taneb: http://en.wikipedia.org/wiki/Dynamic_programming
05:11:28 <Taneb> Okay, I think Haskell is pretty much the best for that
05:11:30 <mauke> basically, caching intermediate results that are needed often or rearranging the logic so that they are only needed once
05:12:04 <bergmark> memoization in some form, i suppose
05:12:20 <thebnq> kind of a misleading name
05:12:35 <bergmark> yes most terrible name :)
05:12:51 <mauke> "programming" here refers to planning (like making a conference program)
05:13:09 <mauke> also, the name was chosen purely because it combines two buzzwords
05:15:11 <Fuuzetsu> Wikipedia lists PHP as a buzzword
05:15:18 <Fuuzetsu> I wonder if ‘monad’ made it yet.
05:16:02 <Fuuzetsu> oh, PHP is no longer listed…
05:16:15 <Taneb> Monads! Monads! Applicative functors! Arrows! Kleisli arrows! Monad transformers! Monads!
05:16:23 <Delaware> in 10 years haskell will be listed too
05:16:44 <mauke> l e n s
05:16:51 <Fuuzetsu> We'll all be using Edwardell by that point anyway
05:17:23 <alexander__b> what's the most concise way of making a random float between n and m?
05:17:42 <alexander__b> or maybe just a random int, and then I can make it a float
05:17:54 <alexander__b> whatever's the simplest. the number should be .0 anyway, so.
05:18:17 <mauke> :t randomIO
05:18:18 <lambdabot> Random a => IO a
05:19:17 <alexander__b> mauke: I guess that'll do. thanks!
05:20:08 <quicksilver> there is one for ranges too
05:20:22 <quicksilver> @type randomRIO
05:20:23 <lambdabot> Random a => (a, a) -> IO a
05:20:32 <quicksilver> x <- randomRIO (n,m)
05:20:32 <ghorn> see http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random
05:20:37 <Delaware> so how is OOP better than functional?
05:20:45 <quicksilver> although I don't recall if n,m are inclusive at both ends. I expect so.
05:20:49 <alexander__b> quicksilver: yes, I found it when I looked up randomIO via hoogle. I'll be using that one. :-)
05:21:26 <Delaware> isn't OOP more intuitive
05:21:35 <mauke> Delaware: when I need to add a new subclass, I don't have to modify all my methods
05:22:09 <Fuuzetsu> Delaware: No, nothing is ‘more intuitive’ to every single person out there, especially when they were taught something else to begin with.
05:22:36 <Fuuzetsu> For me functional style is now more intuitive but it was not always the case.
05:22:49 <quicksilver> when I taught OOP to new programmers, I can attest that they found OOP entirely NON-intuitive.
05:22:58 <quicksilver> I'm not saying they would have found FP any better, mind.
05:23:06 <quicksilver> just that most people find programming non-intuitive full stop.
05:23:09 <Fuuzetsu> quicksilver: gasp! But everything is just like in real world!
05:23:35 <quicksilver> Fuuzetsu: take a look around you at all the dumb things people do every day. Do you think the real world is intuitive to them?
05:23:38 <AshyIsMe> how do you import the random package then?
05:23:49 <ciaranm> if only there were an extensive body of research into how easy beginner programmers find different programming styles to learn, and the depth of understanding achieved during that learning
05:23:50 <quicksilver> import System.Random
05:23:58 <AshyIsMe> oh System.Random
05:23:59 <Fuuzetsu> I stay inside if at all possible and don't read any news.
05:24:25 <AshyIsMe> cheers
05:24:42 <quicksilver> Fuuzetsu: very wise.
05:26:03 <Delaware> well in the case of OOP you would call a chair a chair class. I think when you are programming something really complicated being able to model the real world into your program by the use of OOP will help simplify things.
05:26:44 <mauke> why would I make a class for every single chair?
05:28:15 <Delaware> having different chair classes would make your furniture shop class look better.
05:28:29 <quchen> Delaware: I'd argue that a chair cannot do anything so it's more a (C-) struct than a class, and C structs are Haskell tuples.
05:28:40 <ciaranm> Delaware: i have a question for you. a person can sit on a chair, and a dog can sit on a chair. also, a person can sit on a bench, and a dog can sit on a bench. how do you model that in OOP?
05:28:42 <quchen> Then there are things that operate on that enum/tuple
05:29:47 <thebnq> whenever i read about the origins of OOP from kay, i feel like it was taken the wrong way by everyone hehe
05:29:49 <mauke> well, first you define a pure virtual abstract base class called Sittable
05:30:15 <mauke> then you inherit Sittable from Person, Bench, Dog and Chair
05:30:29 <mauke> this makes sense because a dog can also sit on a person
05:30:29 <quchen> A person is sittable?
05:30:29 <ciaranm> so a Chair can sit on a Dog?
05:30:40 <mauke> well, why not?
05:30:43 <mauke> if the dog is asleep
05:30:46 <kuribas> Should sitting be a method of Person, or of Chair?
05:31:03 <mauke> no, that belongs in the SittingManager
05:31:05 <sqdfsq> I'd like to define a function that takes everything in my custom defined data type and sums it element by element
05:31:18 <sqdfsq> like: Player Int Int Int
05:31:18 <ciaranm> now hang on a minute. the dynamic property of whether or not a dog is asleep affects whether it's Sittable? you can't express that in OOP!
05:31:19 <quchen> sqdfsq: Data.Foldable?
05:31:32 <ciaranm> that's getting into session types territory
05:31:39 <quchen> sqdfsq: Oh, you mean summing up all the Ints in a single Player? You'll have to do that manually.
05:31:40 <mauke> ok, maybe we need two different Dog classes
05:31:45 <alexander__b> OK my first impure function in my game, heh. how do I make (randomRIO (1.0, 200.0), randomRIO (1.0, 200.0)) return a (Float, Float) instead of IOs?
05:31:59 <mauke> alexander__b: you don't
05:31:59 <sqdfsq> ok, so that probably means that my definition is probably not very haskelly
05:32:06 <alexander__b> mauke: so what do I do instead
05:32:09 <quchen> alexander__b: You don't. What happens in IO stays in IO.
05:32:22 <mauke> learn about >>= probably
05:32:27 <alexander__b> quchen: sorry, how do I lift it out of IO/whatever terminology you want to use
05:32:39 <mauke> you don't lift things out, you lift functions in
05:32:42 <adimit> alexander__b: you can't lift it out of IO. You can lift stuf *into* Io
05:32:50 <quchen> alexander__b: I wasn't citicizing your wording, I really meant that :-)
05:33:13 <ciaranm> IO is like AIDS. once you've got it you can't get rid of it. but you can get AIDS whenever you want, and if you already have AIDS, you can get it again and still only have one AIDS.
05:33:29 <quchen> alexander__b: Consider  `randomR >>= \myRandomNumber -> (...)`. Inside the (...) part, "myRandomNumber" can be seen as a pure value.
05:33:35 <mauke> ciaranm: ...
05:33:36 <Delaware> ciaranm, humans and dogs are animals, so i would make a base class with the sitting() fuction. then make a human and a dog object from this same animal class, both with sitting capabilities. Then a bench is almost like a chair, they have four legs, they have weight, they can be sit upon, so i can make a base class and call it chair, and make one object called couch and one bench with the same functions.
05:33:38 <alexander__b> how do I [correct terminology for using my random numbers here]
05:33:53 <ciaranm> Delaware: but dogs also have four legs. is a dog a chair?
05:33:54 <novochar> "In Haskell, conditional expressions have the familiar form: if e1 then e2 else e3 which is really short-hand for case e1 of True -> e2, False -> e3; In other words, if-then-else when viewed as a function has type Bool -> a -> a -> a"
05:34:02 <quchen> ciaranm: The Borg or group ideals would've done as well.
05:34:14 <mauke> Delaware: Animal dog = new Animal()?
05:34:14 <novochar> How is this is Bool -> a -> a -> a?
05:34:15 <quchen> novochar: Indeed.
05:34:17 <adimit> alexander__b: common haskell style is to do eerything that's possible in pure code, then string it together in IO. So you devise a pure function that *uses* a random number, then you call that function from IO and give it the generated random number.
05:34:21 <dibblego> alexander__b: the correct terminology is to have a value of the type IO (Float, Float)
05:34:38 <mauke> novochar: how is it not?
05:34:39 <ciaranm> Delaware: also, more seriously, the way sitting is done depends both upon the dog or human, and what is being sat upon
05:34:46 <Delaware> ciaranm no, it's more like an animal while a chair is more like an inanimate object.
05:34:52 <dibblego> @type \p t f -> if p then t else f
05:34:54 <lambdabot> Bool -> t -> t -> t
05:35:00 <quchen> > let if' p t f = if p then t else f in  if' (2 > 3) "yep" "nope" -- novochar
05:35:02 <lambdabot>   "nope"
05:35:10 <quchen> :t let if' p t f = if p then t else f in  if'
05:35:11 <lambdabot> Bool -> t -> t -> t
05:35:14 <Delaware> ciaranm, well it depends what degree of detail you want to have.
05:35:34 <mauke> Delaware: I want four different actions, basically
05:35:38 <kuribas> Delaware: The biggest problem I had with OOP is that it is often very unclear which method a functino should belong too.  In haskell you can easily make functions which use multiple typeclasses.
05:35:39 <ciaranm> Delaware: the point i'm getting at is that "free functions are useful" and "multiple dispatch is useful", and that "proper" OOP sucks at these
05:35:45 <novochar> the if part represents a Bool, I understand this, but then 3 a's?
05:35:53 <alexander__b> adimit: right so when I have my sole impure function (as of now), makeVelocity which returns (IO Float, IO Float) -- what can I do to use this effectively in e.g. the ball reset code?
05:35:59 <dibblego> novochar: a true branch, a false branch and the return type
05:36:12 <dibblego> can we take the OOP think to -blah?
05:36:12 <novochar> if <- Bool, then <- a, else <- a, -- other a? --
05:36:18 <ciaranm> Delaware: in other words, that OOP is only "intuitive" for a carefully selected set of crap examples
05:36:42 <dibblego> novochar: of what type were you expecting that expression to have?
05:37:03 <quchen> novochar read it as "\proposition valueIfTrue valueIfFalse"
05:37:31 <novochar> Something like: (i::Bool) => i -> a -> a
05:37:32 <Delaware> so the more complicated the analysis becomes the better OOP is at keeping things simplified, Imagine you have to program a simulation that measures investor behavior in a real stock market, with multiple inputs, news, fundamental analysis, economic forecasts, technical analysis. It would soon be very complicated to do without the aid of OOP.
05:37:37 <quchen> novochar: The result of an if statement has to be well-typed, so the result type if true has to match the result type if false.
05:37:41 <adimit> alexander__b: that depends on what you want to do. You'd like to have that read IO (Float,Float) first, probably. You can get a hold of that tuple *inside* the IO monad by assignment, as in: do tuple <- generateRandomFloatTuple. Tuple would then have the type (Float,Float) just incase generateRandomFloatTuple has type IO (Float,Float)
05:37:58 <ciaranm> Delaware: no no. the more complicated the analysis is, the worse OOP does at dealing with it.
05:37:58 <mauke> Delaware: Is the sound a drum makes when it's hit with a drumstick a function of what kind of drum it is or what kind of stick you use to hit it?
05:38:04 <thebnq> Delaware: theres an increase of stockmarket traders using functinoal languages
05:38:25 <ciaranm> Delaware: OOP doesn't so much "keep things simplified" as it does "treat everything as a nail"
05:38:26 <adimit> You can then pass tuple to some function f :: (Float,Float) -> Ball -> Ball or so. That'd generate a new ball out of an old one. You call that function *inside* the IO code.
05:38:29 <alexander__b> adimit: basically I want to use makeVelocity like this: http://lpaste.net/1132840084366688256
05:39:06 <ciaranm> Delaware: here's another one. you can multiply a matrix by a scalar. does that method belong to the matrix class or the scalar class?
05:39:06 <hodapp> Delaware: "the more complicated the analysis becomes"? OOP rapidly becomes completely intractible to any formal analysis because of all the statefulness.
05:39:25 <adimit> alexander__b: makeVelocity is the IO action?
05:39:44 <novochar> Where is the third type variable coming from?
05:39:49 <adimit> (i.e. then this wouldn't type check)
05:40:07 <kuribas> hodapp: OOP doesn't need to be stateful.
05:40:14 <hodapp> The set of things people try to credit to OOP can get to be pretty ridiculous. It's like "structured programming".
05:40:15 <alexander__b> adimit: makeVelocity right now is just (randomRIO >>= (1.0, 200.0), randomRIO >>= (1.0, 200.0))
05:40:23 <quchen> novochar: Bool (proposition) -> a (value if true) -> a (value if false) -> a (result value)
05:40:28 <alexander__b> adimit: so I would ideally like it to just return (Float, Float), of course
05:40:30 <zomg> hodapp: OOP invented monads
05:40:34 <dibblego> novochar: that is the return type
05:40:55 <quchen> novochar: Just like (+) has three "a" in its type signature: type of first summand, type of second summand, type of result.
05:40:59 <quchen> :t (+)
05:41:01 <lambdabot> Num a => a -> a -> a
05:41:02 <adimit> alexander__b: ok, so it's the io action. You need to parameterize bounceX with (Float,Float). So now bounceX has type signature (Float,Float) -> Ball -> Ball
05:41:14 <alexander__b> adimit: wat?
05:41:23 <hodapp> zomg: I'm not sure what you're talking about here.
05:41:30 <adimit> You call makeVelocity in your IO code, then pass *its* result to bounceX.
05:41:31 <alexander__b> adimit: bounceX takes an old ball and returns a new ball
05:41:33 <zomg> hodapp: it wasn't supposed to make sense =)
05:42:01 <ciaranm> everyone knows OOP is comonadic, not monadic
05:42:09 <alexander__b> adimit: the Ball has a Velocity which is a type synonym for (Float, Float)
05:42:13 <mauke> I only knew it was recursive
05:42:14 <hodapp> kuribas: But immutable OOP is quite rare.
05:42:19 <kuribas> hodapp: yes
05:42:27 <adimit> alexander__b: exactly, and the new ball's data depends on the results of makeVelocity. But since makeVelocity happens in the IO world, you need to pass its results to the pure function.
05:42:43 <novochar> I can understand the (+) type, but I don't know where the (return | result) type is coming from in an if/then/else statement, because I'm thinking then or else are (return | result) types
05:42:58 <hodapp> even Alan Kay for instance tailored his definition of OOP to involve hidden state.
05:43:17 <hodapp> because he basically was using a paradigm where each object was its own little RPC server.
05:43:29 <alexander__b> adimit: can't I have makeVelocity return a (Float, Float) anyhow?
05:43:46 <ciaranm> in the Alan Kay sense, java isn't OOP
05:43:58 <adimit> alexander__b: http://lpaste.net/1132840084366688256
05:44:01 <Delaware> maunke the drumset class makes the sound when played() upon. Modelling classes is a skill obviously.
05:44:13 <hodapp> ciaranm: In the Alan Kay sense, a lot of stuff is not OOP.
05:44:13 <adimit> alexander__b: no, taht is impossible. You can only make it return an IO (Float,Float)
05:44:24 <hodapp> ciaranm: but Java comes much closer than C++ in that regard.
05:44:26 <adimit> except you take out the randomness, but that would defeat the purpose.
05:44:30 <kuribas> Delaware: Sometimes it is obvious to wich class a method belongs, but often that is not the case.  In haskell you can have data directed programming, without having to make such arbitrary decisions.
05:44:38 <mauke> I'm hereby moving the OO discussion to #haskell-blah
05:44:55 <alexander__b> adimit: OK, you see the only IO I have is main
05:45:08 <dsdskfv> Hey I was wondeirng if I could get help with applying zipWith in list comprehension
05:45:08 <adimit> alexander__b: you can have as many IO actions in your code as you like. :-)
05:45:12 <alexander__b> adimit: so I guess I'll introduce an IO in a Random.h where I also have makeVelocity
05:45:13 <Delaware> thebnq C++ is the only language they will hire you if you are a financial quant.
05:45:20 <alexander__b> adimit: yes, I know, but I want them separated
05:45:26 <hodapp> Delaware: Bullshit.
05:45:31 <quchen> novochar: if/then/else takes three *parameters*. A proposition, a value to return if the proposition is true, and one for the false case. If you insert all these three values, the whole if/then/else block will have a value. For example "if True then 1 else 0" as a whole has a value of type "Int".
05:45:34 <mauke> Delaware, hodapp: #haskell-blah
05:45:36 <alexander__b> adimit: so I'll put what you suggest in Random.hs or such,
05:45:56 <adimit> alexander__b: you don't need to have different source files for that, but you can.
05:46:06 <hodapp> mauke: I've been there for like a week.
05:46:14 <alexander__b> adimit: I *want*, because I want an incredibly obvious separation between impure and pure.
05:46:16 <Delaware> hodapp well im studying as a quant so i know, haskell isn't the industry language in the financial world.
05:46:31 <alexander__b> adimit: the reason I'm doing this game is actually research on this exact thing -- when to do impurity and how to clearly separate it, and so on.
05:46:33 <hodapp> Delaware: as mauke said, take it to #haskell-blah
05:47:02 <adimit> alexander__b: as your program gets bigger, and more complex, you might need to fan out several impure actions from your main function, though that depends very much on the nature of your program. I'm usually ok with just one main function, except in rare circumstances. A game might be such.
05:47:04 <kuribas> Delaware: Haskell and ocaml are actually being used in the financial world.
05:47:15 <adimit> alexander__b: that is laudable goal. Two files might help you there.
05:47:42 <alexander__b> adimit: I do feel very dirty implementing my first impure function, so I guess I have the correct mindset at least. ;-)
05:47:47 <jmcarthur_mobile> Delaware: there people in here using Haskell and ocaml in finance
05:47:48 <Delaware> well I'm interested in knowing where actually functional programming excells, because as evidence shows very big complicated softwares aren't programmed mainly with haskell, because it's not scalable.
05:48:01 <jmcarthur_mobile> Okay this is trolling
05:48:03 --- mode: ChanServ set +o mauke
05:48:04 <Delaware> nope.
05:48:04 --- mode: mauke set +q *!*@173-9-233-186-Illinois.hfc.comcastbusiness.net
05:48:05 <novochar> quchen: so it's equated to something like (Bool -> a -> a) -> a where this final a is a representation of the result, probably an exact copy of one of the other a's?
05:48:17 <kuribas> Delaware: Please go to #haskell-blah
05:48:21 <hodapp> Delaware: If you have any references for this so-called "evidence", please drop it into #haskell-blah.
05:48:33 <quchen> Guys, #blah is not #haskell-offtopic.
05:48:45 <quchen> It's not the channel to send people to for random ramblings.
05:48:53 <quchen> In particular Haskell is generally offtopic there.
05:48:59 <adimit> alexander__b: impure code is not bad per se.
05:49:05 <ciaranm> quchen: take it to #haskell-whichotherchannelshouldiuse
05:49:16 <quchen> ciaranm: Good suggestion.
05:49:20 <heath> #haskell-in-depth maybe?
05:49:24 <quchen> I heard MD5 sums make nice channel names.
05:49:26 <adimit> alexander__b: what is bad is putting computations into impure code that could have been pure, because it makes them un-composable.
05:49:33 <adimit> (and for several other reasons.)
05:49:40 <heath> #haskell-in-depth-offtopic? :)
05:49:53 <aristid> quchen: not as good as UUIDs
05:50:04 --- mode: mauke set -o mauke
05:50:04 <alpounet> Delaware, you should gather more evidence, there are haskell codebases with millions LoC that work just fine
05:50:33 <novochar> quchen: is that correct?
05:50:34 <ciaranm> and a million lines of haskell is equivalent to more lines of java than there are atoms in the universe
05:50:46 <adimit> so in your example, you could make bounceX impure by making it return an IO Ball. But that'd be a weird way to go, since what it does is actually very much pure, but it *depends* on an impure value, namely the velocity. Threading impure data through pure functions is basically what Haskell code often feels like :-)
05:50:55 <quchen> novochar: Well, your parenthesis are wrong in the type signature, but I think conceptually you're right.
05:51:13 <novochar> quchen: thank you!
05:51:18 <quchen> novochar: A better way of saying what you meant would be that if/then/else can also be read as a function "(Bool,a,a) -> a".
05:51:38 <Twey> Someone linked a post recently that outlined a language much like Haskell, but where ‘everything is a monad’; does anybody remember what it was called?  It was something like ‘monads-comp’
05:51:40 <quchen> novochar: What you wrote, "(Bool -> a -> a) -> a", means it takes a function (Bool -> a -> a) and maps it to an "a".
05:52:34 <alexander__b> adimit: do you have any suggestions on how to structure this with "makeVelocity": http://lpaste.net/4195539902609227776 ?
05:52:36 <quchen> > let if' (p, ifTrue, ifFalse) = if p then ifTrue else ifFalse in if'  -- novochar: this is if/then/else written with a tuple.
05:52:38 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable t0)
05:52:38 <lambdabot>    arising from a use ...
05:52:45 <jmcarthur_mobile> "everything is a monad" sounds like a joke
05:52:52 <quchen> :t let if' (p, ifTrue, ifFalse) = if p then ifTrue else ifFalse in if'  -- novochar: this is if/then/else written with a tuple.
05:52:53 <quchen> Pardon.
05:52:54 <lambdabot> (Bool, t, t) -> t
05:53:07 <ciaranm> Twey: moggi's original paper did it that way
05:53:19 <alexander__b> adimit: some info: bounceX tests if the ball hits behind the player, and so it has to make a new one. main makes a new game world and starts a loop. bang is the new world, and step is the game loop.
05:53:20 <Twey> jmcarthur_mobile: IIRC it did stuff like implicitly wrap pure values in Identity
05:53:36 <jmcarthur_mobile> How many identities?
05:53:45 <novochar> quchen: That is kind of what is happening, right? You have a piece of code, whether it's an if-then-else or case expression, which ultimately returns an a
05:54:09 <alexander__b> adimit: so in step, I do b' = move (bounce b p1 p2) t. then bounce is bounceY . bounceX $ bouncePaddles b p1 p2.  so uh... bounceX is not very well placed for doing IO, :-P
05:54:11 <Twey> jmcarthur_mobile: Good question; I can't remember exactly how it worked, which is why I'm trying to find it :þ
05:54:51 <alexander__b> adimit: BTW the '}' is a typo IDK how it ended up in the paste
05:55:01 <devilnorm> !list
05:55:01 <monochrom> devilnorm: http://lpaste.net
05:55:54 <quchen> novochar: Yes, the rightmost value can be seen as sort of a "return value" for functions. Keep in mind that you can curry functions in Haskell though, so if you have `ifThenElse :: Bool -> a -> a -> a`, you can also read it as a function that produces a function a la `ifThenElse :: Bool -> a -> (a -> a)`.
05:55:54 <thebnq>  /join #haskell-blah
05:55:58 <thebnq> failshh
05:56:13 <lpaste> iLike pasted “State Monad” at http://lpaste.net/101570491877163008
05:56:21 <adimit> alexander__b: oh boy, I think that's a bit beyond the time I have available right now, sorry. Try putting your main loop into IO, since it'll need to be generating random numbers. Alternatively, you could use a ReaderMonad (but I think that's a bit fancy for now.)
05:56:41 <adimit> your main loop would then dish out random numbers to the bounce-functions or so.
05:56:44 <alexander__b> adimit: as you can see I have been avoiding IO completely, heh.
05:56:45 <iLike> I can't seem to figure out how to define 'put' in terms of modify..
05:56:49 <alexander__b> adimit: I see
05:57:05 <quchen> iLike: hint, have a look at "const"
05:57:07 <adimit> alexander__b: not really, you have IO all over the place :-) every call to makeVelocity is IO :-P
05:57:25 <alexander__b> adimit: no, I didn't have makeVelocity until now :-P
05:57:38 <jmcarthur_mobile> What does makeVelocity do exactly?
05:57:43 <jmcarthur_mobile> Random gen?
05:57:49 <adimit> yeah, afaict.
05:58:01 <jmcarthur_mobile> You don't need IO for that
05:58:04 <alexander__b> jmcarthur_mobile: it doesn't do owt ATM. it doesn't really exist even. it *should* make a random Velocity, which is (Float, Float)
05:58:25 <jmcarthur_mobile> You can just make a rng in io and then pass it in as an argument
05:58:45 <jmcarthur_mobile> It's a pure rng though
05:58:50 <jmcarthur_mobile> Just produces a new rng state each time you use it
05:59:19 <mr-> (or a list of random numbers that you can pass on)
05:59:24 <jmcarthur_mobile> You will find that if you use it a lot there will be a lot of boilerplate, so eventually you might find yourself wanting a state monad for it.
05:59:37 <jmcarthur_mobile> Two are provided on Hackage already that I know of
05:59:55 <jmcarthur_mobile> MonadRandom and a lazy variant I forget the name of
06:00:22 <jmcarthur_mobile> The strict one is probably fine if you find yourself wanting it though
06:00:34 <jmcarthur_mobile> The lazy one is mainly good for overly clever things
06:00:50 <alexander__b> jmcarthur_mobile: so what's your suggestion to get a makeVelocity in there as... painlessly as possibly?
06:01:07 <alexander__b> jmcarthur_mobile: makeVelocity being something that makes a "random" (Float, Float)
06:01:31 <iLike> quchen, I don't get what you mean..
06:01:41 <jmcarthur_mobile> But I recommend at first just using System.Random.mkStdGen in your main and passing the rng it produces as an argument to your pure functions
06:01:52 <iLike> const x y == x, but how does that help me?
06:02:00 <jmcarthur_mobile> And then turning it into some state monad only if you decided it's too awkward otherwise
06:02:42 <quchen> iLike: You already implemented "get" as "modify id". What does that do? It takes the current state, "modifies" it with id (yielding that same state again), and the "new" state is returned.
06:03:39 <jmcarthur_mobile> alexander__b: you will find that Haskell doesn't care about how painful something is as long as it's "done right", but you can almost always use some abstraction to make it painless
06:03:41 <alexander__b> jmcarthur_mobile: interesting. I'll try that. thanks.
06:04:01 <quchen> iLike: For "put" you'd like to specify a new state, but modify takes only a function as argument. Can you make a function that throws away a value, and modify the state with this? Think of  "put s = modify (<throw away old state and always set the state to s>)"
06:05:03 <alexander__b> jmcarthur_mobile: do you have some tips on how to uhm do this and not make main look like puke?
06:05:11 <jmcarthur_mobile> alexander__b: in this case the painful thing is that every pure function that needs a prng will have to take a prng as an argument and return a prng with its result
06:05:39 <jmcarthur_mobile> It's hard to provide style tips on my phone
06:05:47 <alexander__b> jmcarthur_mobile: doing that should be OK
06:06:02 <iLike> quchen, my intuition says modify (const s), but GHCI complains when I try to do that..
06:06:26 <mauke> iLike: what's the error message?
06:07:01 <iLike> mauke, quchen, http://lpaste.net/7866485666392047616
06:07:12 <quchen> iLike: That's probably because your "modify" function has an odd result type.
06:07:14 <alexander__b> jmcarthur_mobile: my only "problem" is that I'm not sure how to rearrange main
06:07:16 <jmcarthur_mobile> As far as how to make io look good, io is basically an imperative edsl, so we'll understand software engineering techniques for imperative programming often apply
06:07:18 <adimit> alexander__b: a way to reduce the amount rng passing could be to generate random numbers in the main loop only, and parameterize all pure function just with the random numbers they need. They wouldn't need to return rng state.
06:07:28 <mauke> iLike: what are lines 115, 116?
06:07:30 <quchen> iLike: The final "get" in "modify" is uncommon.
06:07:33 <jmcarthur_mobile> *well understood
06:07:49 <alexander__b> adimit: wouldn't the parameters be IO then?
06:07:49 <iLike> mauke, the 'put' method
06:07:58 <jmcarthur_mobile> I don't think you really need to rearrange main for this
06:08:11 <quchen> iLike: In your implementation, "modify" returns a "m s", but your definition of "put" has "m ()" in its type signature.
06:08:12 * mauke rolls eyes off into the horizon
06:08:13 <adimit> alexander__b: no. You can call pure functions from IO.
06:08:14 <iLike> quchen, but if I wouldn't use get at the end, modify would return m (), right?
06:08:19 <adimit> (or any other monad.)
06:08:29 <jmcarthur_mobile> Just generate the prng somewhere and pass it around like any purely functional state
06:08:36 <alexander__b> adimit: uhm what pure function is it that you want me to generate from IO?
06:08:44 <alexander__b> IO just starts the World.Step function
06:08:48 <quchen> iLike: Right, because then the last function called in the do block yould be "put".
06:08:51 <Krook> Hey guys, anyone have experience with haste?
06:08:52 <alexander__b> s/IO/main
06:09:05 <jmcarthur_mobile> I guess if all the passing around will be in main and this is unacceptable then the state monad I suggested might be reasonable
06:09:16 <quchen> iLike: So either you delete that last "get", or you change your definition of "put" to "put s = modify (const s) >> return ()".
06:09:35 <alexander__b> jmcarthur_mobile: so I can have a Random.hs and make std gen there, and call that in bounceX?
06:09:43 <jmcarthur_mobile> Buy it's made more complicated by the fact that main needs io but the other stuff doesn't
06:09:44 <quchen> (Note that "(>> return ()) = Data.Functor.void)
06:10:10 <jmcarthur_mobile> There are ways to make this work nicely but I would need a nice keyboard
06:10:15 <alexander__b> jmcarthur_mobile: hehe
06:10:39 <jmcarthur_mobile> I think you are over thinking it
06:10:55 <jmcarthur_mobile> Try it bottom up.
06:11:06 <iLike> quchen, could you explain where 's' is then? Since I return a 'void'
06:11:11 <alexander__b> jmcarthur_mobile: well I just want the simplest way of doing "makeVelocity" somewhere and then using those numbers in my pure bounceX function.
06:11:20 <jmcarthur_mobile> Write makeVelocity, then do what you need to do to use it in your other functions
06:11:29 <jmcarthur_mobile> Then fix the type errors
06:11:47 <jmcarthur_mobile> Then refactoring if it's ugly
06:11:50 <alexander__b> jmcarthur_mobile: yes, but i want to keep them pure
06:12:03 <jmcarthur_mobile> Then do what I suggested
06:12:06 <quchen> iLike: () is pronounced "unit" by the way. As for your question, the "s" is put in your State monad, whose purpose is to hide the "s" as much as possible.
06:12:27 <jmcarthur_mobile> makeVelocity takes a prng as an argument and produces a new one with its result
06:12:38 <iLike> Oh right, that makes sense. Thanks a bunch quchen!
06:12:43 <quchen> iLike: It's like "putStrLn" has type "IO ()", because it doesn't matter which value is produced, the whole purpose is having some sort of effect.
06:12:57 <quchen> iLike: In your State case that effect is replacing the state with anothe.r
06:13:15 <jmcarthur_mobile> When you use it in a pure function, you will have to change its type appropriately to get a prng in scope to pass to makeVelocity
06:13:31 <jmcarthur_mobile> And this will bubble up until you hit IO in main
06:13:51 <jmcarthur_mobile> Where you can just generate the prng instead of taking it as an argument
06:13:54 <alexander__b> jmcarthur_mobile: hm. that really sounds even uglier than having bounceX take an IO (Float, Float)
06:14:23 <alexander__b> I have heard the advice to keep all IO-related code in Main, but at the same time passing prng down 20 functions isn't exactly nice
06:14:36 <jmcarthur_mobile> I told you this is painful until you make it nicer with an abstraction
06:14:53 <jmcarthur_mobile> That abstraction being something like MonadRandom
06:15:04 <alexander__b> I'll check it out, thanks
06:15:14 <jmcarthur_mobile> But it still this it's worth going through the exercise of doing it manually first
06:15:34 <jmcarthur_mobile> To understand what's going on and decide if it's really as painful as you expected
06:15:54 <jmcarthur_mobile> *but I still think
06:16:00 <alexander__b> jmcarthur_mobile: it doesn't sound painful to actually *do* it, the result just sounds ugly and inelegant.
06:16:05 <jmcarthur_mobile> Sure
06:16:51 <jmcarthur_mobile> Like I said, Haskell doesn't care if it's a bit painful as long as it type checks. Good abstractions can be used to make it nice though
06:17:18 <jmcarthur_mobile> g2g
06:17:54 <alexander__b> jmcarthur_mobile: thanks
06:18:24 <jmcarthur_mobile> I think a bug problem with learning Haskell writing projects from scratch is all the tough parts comes first ;)
06:18:29 <jmcarthur_mobile> *big
06:18:52 <zomg> jmcarthur_mobile: pretty much
06:19:42 <cinimod> Anyone used cassava to decode fields that are in UTC format?
06:19:59 <cinimod> Googling didn't turn up anything interesting
06:29:00 <cinimod> Never mind. I think I do something like:
06:29:05 <cinimod> > instance FromField (Maybe UTCTime) where
06:29:06 <cinimod> >   parseField s = (parseTime defaultTimeLocale "%F %X") <$> parseField s
06:29:06 <cinimod>  
06:29:07 <lambdabot>   <hint>:1:1: parse error on input `instance'
06:29:08 <lambdabot>   can't find file: L.hs
06:29:30 <cinimod> Ooh what caused lamdabot to answer?
06:29:37 <adimit> the bird mark >
06:30:53 <derdon> does ghci remove all bindings when the :load or :reload command is called? if yes, how can I disable this behaviour?
06:31:09 <adimit> derdon: yes it does, and no, I don't think you can.
06:31:52 <derdon> adimit: hm, ok. well thanks for letting me know then
06:33:58 <adimit> (I know, it can be annoying.)
06:35:46 <alpounet> derdon, i get annoyed by that quite often too, but you can just but your "test bindings" in some .hs file and load it from ghci
06:36:18 <alpounet> you'll get the error messages if something is wrong, and if it works, your modules will be loaded AND you will have some values to play with, all in one command
06:36:25 <alpounet> s/but/put/
06:36:44 <derdon> alpounet: ah, that's a good idea if there are a couple of bindings I need often
06:37:20 <derdon> but currently, it's easy enough to use the up-arrow or Ctrl-R to go to the let-statement I want to use again and enter it
06:37:50 <DarkLinkXXXX> I have two executable files in a cabal project. Is it possible to generate documentation that has an index containing documentation for both those files?
06:38:39 <dcoutts> DarkLinkXXXX: see cabal haddock --help, it lists --executables, have you tried that?
06:39:06 <DarkLinkXXXX> Yes, I have that, but they're not indexed. They both have their own folder with their own index.
06:39:39 <halvorgb> Hey, which mode is better alongside haskell-mode in emacs? Scion or ghc-mode?
06:40:15 <halvorgb> ref: http://www.haskell.org/haskellwiki/Emacs
06:42:31 <adimit> halvorgb: I love ghc-mod. Last time I looked at scion it wasn't being developed (last hackage upload in 2009…)
06:42:45 <halvorgb> Oh ok
06:43:19 <adimit> yeah, seems to be dead over at github, too.
06:44:00 <adimit> ghc-mod is actively developed, and works very well with flymake.
06:44:00 <halvorgb> haskell-mode seems a bit weak when you stop using only Prelude functions
06:44:12 <halvorgb> although the type info is cool (when it shows up)
06:44:17 <halvorgb> what's flymake?
06:44:36 <adimit> flymake mode. gives you immediate feedback about your code (warnings, errors) think eclipse.
06:44:51 <adimit> basically it runs ghc-mod continuously in the background.
06:45:15 <adimit> makes your cpu-usage graph bounce like a yoyo, but it's for a good cause.
06:45:21 <halvorgb> hehe
06:45:22 <halvorgb> cool
06:45:27 <halvorgb> I'll check it out, thanks
06:48:05 --- mode: ChanServ set +o mauke
06:48:05 --- mode: mauke set -q *!*@173-9-233-186-Illinois.hfc.comcastbusiness.net
06:50:05 --- mode: mauke set -o mauke
06:51:09 <int-e> elliott: btw I meant to ask you, how much effort did you put into building a SafeHaskell version of lens for lambdabot? It seems to be nontrivial ...
07:06:44 <derdon> is there somewhere an official guide which describes how to indent code?
07:07:41 <Connorcpu> As in any language, you generally have to decide what style you're going to follow in your own code
07:08:13 <Connorcpu> If someone pointed you to an 'official' style guide, I can assure you someone else would step up to disagree with it ;)
07:09:10 <derdon> Connorcpu: Python has PEP 8. Go has the tool "go fmt" which formats the existing code so that it follows all rules from its style guide. this avoids any kind of disagreements
07:09:28 <derdon> so you can't say "as in any language, …"
07:09:29 <Connorcpu> fine, 'most' languages :P
07:09:50 <Connorcpu> Any language that has any leeway in how free-form it can be
07:10:10 <quchen> derdon: There is no official style guide. You can have a look at GHC's style [1] and see whether you like that.
07:10:12 <quchen> [1]: http://ghc.haskell.org/trac/ghc/wiki/Commentary/CodingStyle
07:10:15 <derdon> I found this unofficial guide: http://code.google.com/p/ganeti/wiki/HaskellStyleGuide, I think I will orient on that one
07:10:23 <adimit> Don't use tabs is the only hard rule, really. Other than that, Haskell folks tend to have an alignment fetish, so you just line stuff up.
07:10:25 <derdon> quchen: ah, thanks
07:11:09 <quchen> derdon: There's also a Snap style guide. Those are the only ones I know of.
07:11:25 <quchen> I can also tell you how to write in Quchen style. ;-)
07:11:43 <klugez> https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md - I have seen this linked sometimes.
07:11:51 <klugez> But as you can see, there's no official one.
07:12:07 <derdon> I like the design of http://snapframework.com/docs/style-guide
07:12:39 <Connorcpu> I tend to mostly follow snap, except I indent by 2
07:12:58 * derdon also indents by two spaces in haskell
07:13:42 <Twey> I use four-spaces but sometimes I half-indent (e.g. for ‘where’ clauses)
07:13:56 <Connorcpu> I indent by 2 in most languages :P except where I'm forced to do otherwise, either by the language or the style guide for the project I'm working on
07:14:04 <kuribas> emacs haskell-indentation mode has the best indentation defaults
07:15:58 <kuribas> I like when code stays below 90 characters/line.
07:16:09 <Twey> 80 is standard
07:16:36 <FreeFull> 80 is how wide terminals used to eb
07:16:37 <FreeFull> be*
07:16:42 <Twey> Though I usually do that as a post-processing step before I commit, rather than adhering to it throughout :þ
07:17:06 <Nimatek> Emphasis on "used to". I don't accept the 80 character limitation.
07:17:08 <derdon> Twey: sounds like double the work
07:17:20 <Twey> FreeFull: It's still a pretty nice number.  You can display 80 columns comfortably on small screens, and on larger/wider screens you can display two 80-column files side-by-side
07:17:34 <derdon> Twey: why don't you configure your editor to automatically wrap long lines?
07:17:47 <Twey> derdon: Because editors aren't smart enough to wrap them in semantically pleasing places
07:18:10 <Connorcpu> word wrap while writing code sounds like torture .-.
07:18:16 <Twey> Aye
07:18:16 <FreeFull> Wrapping can be misleading
07:18:27 <derdon> Twey: at least they are smart enough to mark everything as red after column X (where X is 80 for example)
07:18:34 <Twey> derdon: Sure, mine does that
07:18:39 <derdon> :)
07:18:47 <FreeFull> Having line numbers when wrapping is on helps
07:18:51 <Twey> But where I want to break a particular line changes frequently as I edit the code
07:18:55 <FreeFull> But really, lines shouldn't get that long in the first place
07:19:09 <Twey> Hence the practice of writing the code first, then formatting it
07:19:15 * fizruk can't remember having more than 40-50 symbols per line
07:19:15 <derdon> FreeFull: who codes without displaying line numbers‽
07:19:24 * Twey
07:19:29 * ocharles
07:19:29 * ij
07:19:32 * fizruk
07:19:33 <derdon> you monsters!
07:19:34 <ij> On the command line. ;)
07:19:46 <FreeFull> derdon: I do in vim
07:19:47 <donri> I display relative line numbers ;)
07:19:51 <aristid> ij: surely using ed?
07:19:59 <Twey> ed is the standard editor
07:20:07 <derdon> donri: show me a screenshot pls
07:20:12 <FreeFull> One thing I saw is relative line numbers in normal mode, and absolute in insert mode
07:20:14 <ocharles> can someone on linux ldd libHSrts_debug-whatever for me, and tell me if libffi has a path, or is not found?
07:20:16 <FreeFull> Or you can have both side by side
07:20:18 <ij> aristid, I'm talking about sh with some emacs shortcuts.
07:20:20 <ij> I cannot do ed.
07:20:25 <ocharles> I'm trying to link haskell into a C library, and dlopen complains that libffi is not found
07:20:41 * Connorcpu never uses something less advanced than sublime .-.
07:20:51 <Twey> ocharles: Where would I find that?
07:21:14 <derdon> Connorcpu: using sublime looks advanced and that's what counts
07:21:24 <Twey> Connorcpu: So you've never edited bits by hand?  ;)
07:21:28 <donri> derdon: :set number relativenumber  in vim
07:21:29 <ocharles> Twey: not sure, i run nix
07:21:34 <Connorcpu> In a long while*
07:21:41 <derdon> donri: ah, thanks. will try that out
07:21:44 * Twey wonders what's less advanced than Sublime
07:21:52 <derdon> Twey: Windows Notepad
07:21:52 <enthropy> when redirect -ddump-tc-trace to a file, do you also get words like checheckckEExpxpeeccteteddKiKinndd?
07:21:55 <Twey> notepad.exe, I guess
07:22:00 <Twey> Or EDIT.COM
07:22:02 <supki_> ocharles: libffi.so.6 => /usr/lib/x86_64-linux-gnu/libffi.so.6 (0x00007fce8b55c000)
07:22:12 <ocharles> supki_: hrm, on what os?
07:22:13 <Connorcpu> ohgod. I haven't edited code in notepad.exe since I was 11
07:22:16 <ocharles> or distribution
07:22:19 <supki_> ocharles: debian
07:22:23 <supki_> sid
07:22:28 <ocharles> ok
07:22:57 <derdon> Twey: heh, it works. but was are the benefits of having relative line numbers?
07:23:00 <Entroacceptor> Twey: edit.com used to start qbasic.exe, that was pretty advanced ;)
07:24:11 <Twey> Entroacceptor: I coded Java in EDIT.COM for two years when I was first learning programming :þ
07:24:33 <Twey> derdon: You can guess the line number based on where it is on the screen
07:24:36 <aristid> Twey: but that is not the standard editor
07:24:52 <Twey> So you can say ‘kill the line two lines back’
07:25:00 <derdon> ah, I see
07:25:10 <derdon> I always count myself :P
07:25:12 <Twey> Which is nicer than counting the lines from the top of the file
07:25:17 <Twey> I don't use them, though
07:25:24 <aristid> Twey: something more efficient than 2kdd for that?
07:25:31 <enthropy> ah I was doing something odd with the shell redirection
07:25:39 <Twey> Ask donri, guys.  I'm not the vim user here.  :þ
07:26:09 <derdon> arianvp: yep. but imagine counting whether you want to remove the next 15 or 16 lines
07:26:27 <adimit> that's what you have the more sweeping movements for, like }
07:26:33 <derdon> I delete until the line X then if counting is too exhausting for me
07:26:35 <adimit> or ap.
07:26:37 <fizruk> I use visual mode for that
07:26:38 <Twey> aristid: C-<ppk> :þ
07:26:55 <derdon> fizbin: pah, rela vim users never use the visual mode!
07:26:58 <derdon> *real
07:27:08 <aristid> Twey: not M-2 C-p C-k? :D
07:27:24 <adimit> derdon: last time I slapped myself I was real…
07:27:31 <fizruk> derdon: why is that?
07:27:58 <aristid> fizruk: just too easy to use. that's why real real programmers use ed.
07:28:21 <fizruk> oh, I see :)
07:29:55 <donri> honestly i don't use the relative numbers that much, i tend to favor text objects
07:30:44 <Twey> aristid: I only use numeric arguments for larger numbers… C-<pp> is easier to type than M-2 C-p (especially since I'm on Programmer's Dvorak, where numbers also require shift)
07:31:03 <adimit> same here. they may look fancy, but relative numbers solve a problem that's solved much better by text objects.
07:31:36 <Twey> What's a text object?
07:31:56 <ocharles> Ok, jamming libffi into LD_LIBRARYPATH has done the job...
07:32:04 <adimit> Twey: basic building block of vim commands, formed by movements, such as w, e, ap, {}, etc.
07:32:20 <Twey> Ah
07:32:32 <adimit> there are extensions to make text objects out of stuff in quotation marks, tags, etc.
07:32:32 <aristid> ocharles: rpath might or might not help"_
07:33:19 <Sculptor_> hi
07:33:41 <donri> Twey: no, text objects are not motions, they have a start and an end
07:33:55 <donri> it's a "span" or "region" or what ever
07:33:58 <Connorcpu> .-. all them command-line based text editors confuse me. I'm too used to the comfort of a graphical editor D:
07:34:05 * Twey nods.
07:34:23 <adimit> yeah, donri is correct, though in practice they work similarly.
07:34:26 <donri> Twey: basically a selection without the selection step :)
07:34:28 <Twey> Connorcpu: For all those graphics you display in your text editor :þ
07:34:57 <Twey> donri: Well, you still have to type out the selection command :þ
07:35:15 <Connorcpu> I know the irony x3
07:35:19 <donri> Twey: yeah, but it "composes" with operators
07:35:52 <Twey> donri: So you can select something, and then perform an operation on it?  :þ
07:36:15 <donri> Twey: no, the motion or text object is like an argument to the operator
07:36:20 <Twey> Connorcpu: There's not really a difference between GUI and TUI text editors.  It's all text anyway.
07:36:45 <aristid> donri: so a text object is something like the i(?
07:36:49 <donri> aristid: yes
07:36:50 <adimit> Twey: there is: TUI will allow less, if any, mouse interaction.
07:36:59 <aristid> donri: i love the i* commands
07:37:04 <Connorcpu> Falling back to a mouse is just a habit I can't break :/
07:37:21 <donri> aristid: also a* stuff
07:37:29 <donri> also p = ( which i find easier to type
07:37:33 <donri> uh
07:37:37 <donri> no
07:37:47 <Twey> donri: I don't see the distinction between typing an operator and then typing a text object on which it can operate, versus typing a command to select a region and then typing a command to operate on the region
07:37:53 <adimit> wasn't that b?
07:38:07 <donri> adimit: yeah probably. i have that rebound though
07:38:15 <Twey> adimit: That's not really true.  There's xterm-mouse-mode &c.
07:38:42 <Twey> Connorcpu: Although of course that's missing the point that all the popular editors are available with GUIs too.  :þ
07:38:48 <donri> Twey: well in vim the distinction is that it's less to type and that it's "atomic" so you can repeat/undo it as one unit of change
07:38:58 <adimit> Twey: and there's gvim, which I would still consider pretty "terminal"-y. Compare to Eclipse where use of the mouse is basically mandatory, but it isn't in gvim.
07:40:08 <Twey> donri: *nod* I'm not disagreeing that it's the established way to do things in vim, but I don't see why the ‘selection’ couldn't be just another command and remove the cognitive distinction.
07:41:12 <Twey> adimit: I don't really know how gvim works; can you not mouse-select in it?  I'd assume it just enters visual mode automatically, or something
07:41:24 <aristid> Twey: selection is a command: v
07:41:25 <Lethalman> reading here: http://en.wikipedia.org/wiki/Total_functional_programming why the first qsort is not trivially total?
07:41:41 <aristid> Twey: vi" selects the text between two "
07:41:47 <Lethalman> I expect the compiler to infer that partition makes it substructural
07:42:09 <donri> Twey: yeah there isn't really any distinction since selection is an operator that similarly takes a motion or text object
07:42:56 <Twey> Ah, is the purpose to allow existing ‘command’ character to be repurposed for ‘text object’ syntax?
07:42:58 <fizruk> Lethalman: compiler doesn't know if partition doesn't return (xs, [])
07:43:02 <Twey> characters**
07:43:08 <Lethalman> fizruk, oh right
07:43:14 <Lethalman> fizruk, thanks
07:43:22 <satc> If f :: [a] -> [a] -> [a] is a function such that ([],f) forms a monoid and complexity of f xs ys is O(|xs| + |ys|). A solution like foldr f [] xss (xss is a list of lists with same number of element each) takes O(n ^ 2) (where n is the length of xss) time to build while there is tree based solution which works in O(n log n). Is there a fold (already implemented somewhere) which has the latter complexity?
07:43:39 <donri> Twey: or are you confused about motions vs text objects?
07:44:02 <Twey> donri: I don't *think* I'm confused.  I was just wondering about the purpose of it.
07:44:25 <Twey> But allowing two interpretations of characters would seem to fit the bill, since otherwise you'd be quite limited.
07:45:05 <donri> that's just modality, that's not the issue
07:45:20 <donri> honestly the real reason is historic: visual mode was a late addition in vim, not in vi AFAIK
07:45:55 <Twey> donri: What is the issue?  I didn't think there was an issue
07:46:31 <donri> Twey: i meant with key reuse
07:46:45 <Twey> donri: There's an issue with key reuse?
07:46:48 <donri> operators don't change anything there since they're all bound in visual mode anyway
07:48:13 <jack-from-china> I'm reading <<learn you a haskell>>. The following statement confuses me:
07:48:14 <jack-from-china> >    findKey :: (Eq k) => k -> [(k,v)] -> Maybe v
07:48:15 <lambdabot>   Not in scope: `findKey'
07:48:15 <jack-from-china> >    findKey key [] = Nothing
07:48:16 <lambdabot>   <hint>:1:16: parse error on input `='
07:48:17 <jack-from-china> >    findKey key ((k,v):xs) = if key == k
07:48:18 <lambdabot>   <hint>:1:24: parse error on input `='
07:48:18 <jack-from-china> >                                then Just v
07:48:20 <lambdabot>   <hint>:1:1: parse error on input `then'
07:48:20 <jack-from-china> >                                else findKey key xs
07:48:21 <lambdabot>   <hint>:1:1: parse error on input `else'
07:48:21 <jack-from-china> >
07:48:23 <jack-from-china> >   findKey :: (Eq k) => k -> [(k,v)] -> Maybe v
07:48:24 <lambdabot>   Not in scope: `findKey'
07:48:24 <jack-from-china> >   findKey key = foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing
07:48:26 <lambdabot>   <hint>:1:13: parse error on input `='
07:48:26 <jack-from-china> >
07:48:27 <jack-from-china> >   Note: It's usually better to use folds for this standard list recursion pattern instead of explicitly writing the
07:48:28 <adimit> jack-from-china: stop it.
07:48:29 <lambdabot>   <hint>:1:89: parse error on input `of'
07:48:29 <jack-from-china> >   recursion because they're easier to read and identify. Everyone knows it's a fold when they see the foldr call,
07:48:30 <lambdabot>   <hint>:1:111: parse error on input `,'
07:48:31 <donri> Twey: i guess i'm not really sure what you're asking/saying :)
07:48:31 <jack-from-china> >   but it takes some more thinking to read explicit recursion.
07:48:32 <lambdabot>   <hint>:1:60:
07:48:32 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
07:48:32 <jack-from-china> From what I see, the resursive one is more readable/understandable.  And the fold function must always iterate
07:48:34 <jack-from-china> over the hole list, won't that cause low efficiency?
07:48:52 <adimit> jack-from-china: please use the paste site…
07:48:54 <fizruk> jack-from-china: use lpaste
07:48:58 <fizruk> @where paste
07:48:58 <lambdabot> http://lpaste.net/new/haskell
07:50:02 <Twey> I don't understand what visual mode has to do with it.  I was wondering what purpose the ‘text object or motion’ distinction serves (as opposed to commands).  aristid gave an example in which the ‘i’ character was used in the ‘text object’ part of the command as opposed to the ‘operator’ part of the command, wherein I know that ‘i’ switches to insert mode.  I asked whether allowing these two interpretations of a character was the…
07:50:07 <Twey> … motivation for having a syntactic difference between the ‘text object or motion’ and the ‘operator’, which would seem to have no conceptual reason to be distinct.
07:51:01 <chrisdone> Twey: i saw your messages and knew donri was to blame
07:51:06 <donri> Twey: ah. then yes, usually text objects are more than one key starting with "a" or "i"
07:51:24 <chrisdone> <3 vimri
07:51:31 <Twey> satc: What is this tree-based solution?  It sounds like it involves more knowledge about the data or function than that it forms a monoid
07:51:41 <Twey> chrisdone: Hehe
07:51:49 <donri> Twey: the distinction though is mostly because they couldn't really be actual motions. how do you move to "inside quote"? should that go to the start or end quote?
07:51:58 <jack-from-china> sorry guys, that was an accident
07:52:06 <donri> Twey: so text objects are only bound in "operator-pending mode"
07:52:17 <Twey> Ahuh
07:52:21 <vijaykiran> Hello everyone, I'm trying to get started with Haskell + Emacs - when I do C-c C-l  - I get "no such program hugs"
07:52:39 <chrisdone> vijaykiran: do you want to use hugs or ghci?
07:52:39 <Twey> vijaykiran: M-x customize-group haskell
07:52:40 <donri> which is the mode you're in after you used an operator (aka command)
07:53:04 <Twey> Set the command for your interpreter (you probably want to use GHCi; Hugs is old and unmaintained)
07:53:09 <fizruk> satc: I think you should transform your xss into a tree and then fold it, I don't know a standard implementation for that
07:53:19 <vijaykiran> chrisdone: which one should I use - I installed Haskell Platform - on mac
07:53:32 <vijaykiran> sorry, this is my "first day" with Haskell
07:53:42 <chrisdone> vijaykiran: then ghci's fine. are you an emacs newbie?
07:53:46 <Twey> vijaykiran: You'll have a program called ‘ghci’ somewhere.  You need to tell emacs where it is.
07:53:50 <fizruk> what are trees with values in leaves? tries?
07:54:08 <vijaykiran> chrisdone: nope, I got good exp. with emacs
07:54:35 <chrisdone> vijaykiran: then as Twey said, customize-group haskell and there's a haskell-program-name to configure, change it to ghci
07:54:51 <lpaste> jack-from-china pasted “recursion vs fold” at http://lpaste.net/94336
07:55:32 <vijaykiran> thanks chrisdone, Twey -- it worked. not sure why it was set to hugs "+." though
07:56:16 <Twey> fizruk: Tries are trees with values on all nodes such that the value of a node is a prefix of the value of its children
07:56:52 <fizruk> Twey: oh, thanks!
07:57:12 <chrisdone> vijaykiran: hugs is the default value
07:57:41 <chrisdone> i dunno what +. is for
07:58:07 <Twey> fizruk: FSVO ‘value’ the ‘values’ of a trie are at the leaves, but usually you want to consider the intermediate keys as values too
07:58:25 <hvr> chrisdone: I thought we changed that in recent versions
07:58:42 <hvr> chrisdone: i.e. that hugs isn't preferred over ghci
07:58:56 <Twey> fizruk: But you can attach values to the leaves of e.g. a binary search tree (distinct from the keys in the nodes)
07:59:54 <chrisdone> hvr: me too. although vijaykiran might be using a distro package version
08:00:00 <hvr> ah, right
08:00:05 <fizruk> Twey: I see, I actually wanted data Tree a = Node (Tree a) (Tree a) | Leaf a
08:00:38 <hvr> chrisdone: btw, I've been sucked into ghc development, in case you wondered why I've gone a bit quiet on haskell-mode
08:00:52 <vijaykiran> hvr: I used haskell-mode from emacs packages
08:01:13 <hvr> vijaykiran: can you tell use what 'M-x haskell-version' tells?
08:01:37 <vijaykiran> haskell-mode version @VERSION@ (@GIT_VERSION@ @ /Users/vijaykiran/.emacs.d/elpa/haskell-mode-20131013.1146/)
08:01:51 <hvr> that's actually not that old
08:01:52 <chrisdone> hvr: i suspected so. i've not touched it for a while, though this week i'll be working on emacs integration with the fp complete ide, and i've been working on a [to-be] public version of structured-haskell-mode =)
08:02:20 * hvr is very curious about SHM
08:02:29 <jack-from-china> Hi, another newbie question, does fold function always iterate over the whole list to get the final accumulation?
08:03:04 <Twey> fizruk: I'd just call it a binary tree.  It has no special properties.
08:03:13 <vijaykiran> chrisdone: is is something similar to paredit for haskell ?
08:03:17 <hvr> vijaykiran: yes
08:03:29 <vijaykiran>  awesome :)
08:03:38 <fizruk> Twey: yeah, but is it somewhere on hackage or in base?
08:03:47 <hvr> vijaykiran: you should be able to find some youtube-demonstration of s-h-mode
08:03:48 <Twey> I don't know of a distinction between T(v) = T(v)² + v and T(v) = vT(v)² + v
08:04:53 <Twey> fizruk: I think there are only rose trees in Data.Tree :-\
08:05:20 <fizruk> Twey: I see that :) thanks anyway)
08:05:55 <Twey> Ah
08:06:00 <Twey> fizruk: http://hackage.haskell.org/package/combinat-0.2.4/docs/Math-Combinat-Trees-Binary.html
08:06:34 * hackagebot hath 0.1.2 - Hath manipulates network blocks in CIDR notation.  http://hackage.haskell.org/package/hath-0.1.2 (MichaelOrlitzky)
08:06:48 <hardliner_> is it true that haskell is low payed language?
08:06:54 <fizruk> Twey: how did you find it? :)
08:07:05 <Twey> fizruk: Google :þ
08:07:09 <hardliner_> fizruk: zdorovo
08:07:11 <Twey> "hackage" binary tree
08:07:25 <fizruk> hardliner_: hi
08:07:32 <chrisdone> hvr: i recently started experimenting with what i'm calling “quarantines” -- regions in the buffer which become invalid syntax are automatically quarantined;; put in a red box, isolating the invalidness, until you correct your syntax and then it's accepted back into the tree. hopefully it should be a nice way to always have a tree that you can navigate/manipulate with isolated sections of invalidity
08:07:41 <Twey> hardliner_: I'd imagine it's probably quite highly-paid where you can find work
08:08:03 <mangaba_leitosa> hardliner_: it's a free language :-)
08:08:09 <chrisdone> hvr: i whipped up a dumb prototype of that the other evening http://chrisdone.com/out.ogv you can see when i type "`" that the node i'm at is immediately quarantined
08:08:11 <Twey> chrisdone: That's nice
08:08:23 <edwardk> chrisdone: using something lik a CYK/valiant parser you can find the bounaries of the invalid region pretty easily. its wherever you can't cross the chasm with a parse
08:08:44 <chrisdone> hvr: (the rest of the demo is showing how hitting backspace and things like that simply "glide over" the character if removing it would create a parse error)
08:08:56 <edwardk> i need to get around to releasing a version of my locally-context sensitive variant of valiant
08:09:36 <chrisdone> edwardk: i already know the boundaries of the invalid region because i know the regions of all nodes
08:09:38 <fizruk> Twey: can't see why I didn't try that :)
08:10:01 <satc> Twey: Tree based solution as in forming a complete binary tree and then folding bottom up. Each node represents an action of f on its children.
08:10:17 <Twey> chrisdone: Your keyboard is also pleasingly clicky
08:10:24 <chrisdone> edwardk: e.g. "case foo blah of _ -> …" if i type ` after foo, i know that {foo` blah} is the invalid region
08:10:36 <chrisdone> Twey: cherry mx blues =p
08:11:06 <Twey> chrisdone: Ooh
08:12:18 <Twey> satc: ‘traverse’ should be able to do that
08:12:19 <edwardk> chrisdone: i recover that in a very similar way using the dyck language that says case and of much pair up as a global invariant in the grammar.
08:12:58 <Twey> Erm, but you're doing something that's fundamentally different to just a fold
08:13:45 <Twey> You're building the tree first and then folding on the tree, and it matters where you do the fold; it would be valid to just fold at every node, which is the naïve foldr (which doesn't know that f is associative)
08:16:13 <_mkrull> i have i problem understanding an error when using Aeson. I have this code and 'no instance of' error https://gist.github.com/mkrull/7009210
08:16:18 <hardliner_> liku cobol?
08:16:20 <hardliner_> like
08:16:49 <_mkrull> but according to the docs here http://hackage.haskell.org/package/aeson-0.6.2.1/docs/Data-Aeson.html an instance of FromJSON v => FromJSON (Map String v) exists
08:17:00 <fizruk> hardliner_: like rocket science
08:17:24 <hardliner_> fizruk: rocket science is not well payed in russia
08:17:28 <hardliner_> he-he
08:18:59 <chrisdone> edwardk: i see. i'm just using haskell-src-exts and emacs markers to automatically keep track of the start/end of regions =)
08:19:36 <fizruk> hardliner_: I think you got the point nonetheless
08:22:05 <chrisdone> edwardk: the nice thing is the mode doesn't really have any idea what haskell is, it just asks a parser (hse) to "parse this text and give me some spans or an error". so hypothetically i could apply it to any language for which there's a parser that can spit out some spans
08:23:08 <yesthisisuser> now i am confused.. let 1 = 5 in 3
08:23:34 <fizruk> > let 1 = 5 in 1
08:23:35 <lambdabot>   1
08:23:44 <yesthisisuser> is this because of laziness?
08:23:47 <chrisdone> yes
08:24:12 <chrisdone> > case 5 of 1 -> 1
08:24:13 <lambdabot>   *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
08:24:50 <yesthisisuser> there is no way to force strictness on a let-binding or?
08:25:05 <chrisdone> > let !1 = 5 in 3
08:25:07 <lambdabot>   *Exception: <interactive>:3:5-10: Non-exhaustive patterns in pattern binding
08:25:15 <yesthisisuser> ah ok...
08:25:23 <mauke> > let ~(!a, !b) = undefined in ()
08:25:25 <lambdabot>   ()
08:25:28 <chrisdone> you need to enable bang patterns for it
08:25:37 <bennofs> > let x@1 = 5 in x `seq` 1
08:25:39 <lambdabot>   *Exception: <interactive>:3:5-11: Irrefutable pattern failed for pattern x@1
08:25:47 <chrisdone> mauke: ! and ~, the yin and yang =)
08:26:02 * chrisdone . o O (  or yan and ying?  )
08:26:29 <yesthisisuser> > let !1 = 1 in 1
08:26:30 <lambdabot>   1
08:26:46 <yesthisisuser> ok hmm
08:26:58 <hardliner_> fizruk: are you from russia?
08:27:07 <fizruk> chrisdone: ☯
08:27:22 <fizruk> hardliner_: yes
08:27:54 <chrisdone> fizruk: i guess you could say… ~ and ! are the yin and yang
08:28:09 <chrisdone> ☯_☯
08:28:14 <fizruk> =)
08:28:17 <chrisdone> YEAAHHHH
08:29:07 <hardliner_> fizruk: are you teacher of physical culture?
08:29:12 <hardliner_> he-he
08:29:14 <m1dnight> "This work is licensed under a Creative Commons Attribution-Noncommercial-Share Alike 3.0 Unported License because I couldn't find a license with an even longer name. " That Miran Lipovcaca cracks me up :D
08:29:31 <m1dnight> learning from that book was a blast :D
08:30:01 <yesthisisuser> i like where he says that monoids are like socks
08:30:09 <m1dnight> haha, not there yet :D
08:30:09 <fizruk> chrisdone: interesting thing is that this yin-yang symbol was called a "monad" (in my childhood at least)
08:30:15 <m1dnight> i just finished the modules part
08:30:41 <m1dnight> (I see, "is" a blast instead of "was")
08:32:09 <fizruk> hardliner_: that was my secret day job... you've ruined that just now.
08:32:52 <yesthisisuser> its funny also that a lot of Haskell tutorials on the web are trying to mimic the style of LYAH..  probably unintentionally a lot of times
08:34:36 <hardliner_> i started to read LYAHFAGG
08:34:45 <hardliner_> but not finished
08:34:50 <mm_freak> welcome back, people
08:35:10 <fizruk> chrisdone: actually... http://en.wikipedia.org/wiki/Monad_(Chinese_symbol)
08:36:37 * hackagebot yesod-fay 0.4.0.6 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.4.0.6 (MichaelSnoyman)
08:36:57 <iLike> I'm really having a hard time understanding monads (in particular State monads)
08:37:29 <briennetheblue> so that's what a monad looks like
08:37:30 <danr> yesthisisuser: haha. It seems like he never elaborates on the sock analogy, either
08:38:00 <chrisdone> Twey: http://fortawesome.github.io/Font-Awesome/icon/meh/
08:38:24 <fizruk> iLike: are you good with Reader/Writer monads?
08:39:06 <iLike> fizruk, how would you define good? :-O
08:39:11 <iLike> :-P*
08:39:20 <fizruk> can you implement it?
08:39:35 <chrisdone> iLike: http://en.wikipedia.org/wiki/I_know_it_when_I_see_it
08:40:39 <iLike> fizruk, haven't really tried to implement them myself, but I read the LYAH chapter on them
08:41:00 <fizruk> iLike: implement them :)
08:41:01 <bennofs> _mkrull: what version of aeson do you have installed?
08:41:11 <_mkrull> 0.6.2.1
08:41:22 <bennofs> Because that code works for me
08:41:38 <_mkrull> bennofs: ok. that is strange
08:42:45 <bennofs> I have 0.6.2.0, GHC 7.6.3. Are you sure that this code doesn't work?
08:42:53 <fizruk> iLike: probably, Writer is simpler. also consider data Log a = Log a String, which equivallent to (Writer String a)
08:43:24 <iLike> fizruk, will try, thanks.
08:43:26 <fizruk> iLike: then implement Monad instance for Reader (or ((->) e))
08:43:37 <_mkrull> bennofs: yes. i just copy-pasted. my ghc is 7.4.2 but that should not be the issue
08:44:04 <fizruk> iLike: then it will be simple to get to State
08:44:26 <_mkrull> bennofs: i will try 0.6.2.0 just in case
08:47:17 <FreeFull> Reader is probably easiest to define in terms of fmap and join
08:48:12 <chrisdone> Identity is easiest =p
08:49:13 <fizruk> FreeFull: arguably, Writer is easier to understand
08:50:04 <fizruk> I personally don't know of a simple example usage of Reader monad
08:51:00 <FreeFull> > join (+) 3
08:51:00 <lambdabot>   6
08:51:13 <fizruk> great! why not 3 + 3?
08:51:33 <FreeFull> Because then you write 3 twice
08:51:37 <FreeFull> How about this
08:51:44 <FreeFull> > join (,) "Some long thing"
08:51:45 <lambdabot>   ("Some long thing","Some long thing")
08:52:17 <fizruk> > (\x -> x ++ x) "Something really long... "
08:52:18 <lambdabot>   "Something really long... Something really long... "
08:53:21 <fizruk> so yes, it *is* useful, but you can't explain that with a simple example
08:53:31 <fizruk> at least, I can't
08:54:02 <fizruk> > let x = "Something long" in x ++ x
08:54:03 <lambdabot>   "Something longSomething long"
08:54:04 <alpounet> fizruk, join for the Reader monad lets you feed a function of 2 argumentswith the same argument twice. join :: Monad m => m (m a) -> m a. with m = (->) e, you have: join :: (e -> e -> a) -> e -> a
08:54:27 <FreeFull> You can use join somefunction when composing with other functions
08:54:42 <fizruk> alpounet: why not have a separate function twice f x = f x x ?
08:54:56 <FreeFull> :t join (,) . (++"World!") . drop 3
08:54:57 <lambdabot> [Char] -> ([Char], [Char])
08:55:11 <FreeFull> fizruk: Because join already does the job
08:55:12 <alpounet> fizruk, you can, but join applies to all monads, so it just happens to have a handy behavior here
08:55:19 <alpounet> for this particular monad
08:55:56 <alpounet> fizruk, I was just expanding on this "reader monad example" comment
08:57:35 <fizruk> I see, but in all these small examples, explicit lambda, let/where or twice function is not that cryptic as join is for a newbie
08:58:04 <alpounet> fizruk, also, the Reader monades usefulness résides in its monda transformer version, ReaderT. You'll see a lot of configuration-parametrized code that uses ReaderT SomeConfigType
08:58:13 <fizruk> so why bother to write Monad instance for ((->) e) they might ask
08:59:06 <fizruk> alpounet: yes, I use it in my code for exactly those purposes
09:00:01 <fizruk> I just argue, that there's probably is no simple demonstration of why we need a Reader monad
09:00:04 <gdeest> Hi, I'm trying to give a nicer interface to some FFI bindings, and I have some problem with type families. For some reason, this does not work: http://pastebin.com/hQyEBSeq
09:00:06 <mauke> The paste hQyEBSeq has been copied to http://lpaste.net/94340
09:00:23 <gdeest> Do you have any idea why GHC can't figure out that ISLRaw BasicSet = RawBasicSet ?
09:00:36 <gdeest> May be I'm just doing something stupid, I don't have much experience playing with type families
09:02:03 <alpounet> gdeest, you're using an associated data type, but I think you want an "associated type" (using the 'type' keyword, I mean)
09:02:26 <gdeest> alpounet: hum, OK :)
09:02:27 <gdeest> Makes sense
09:02:33 <gdeest> thanks
09:03:14 <gdeest> Works perfectly ! :)
09:03:29 <alpounet> gdeest, because if you use data, you're making up a brand new type, you're not just creating a synonym
09:03:40 <mangaba_leitosa> what's the place of this new Sublime editor in the 'vim vs emacs' scale?
09:03:55 <bennofs> _mkrull: Hmm. I installed aeson 0.6.2.1 (on ghc 7.4.2), and it worked for me.
09:05:09 <fizruk> > all . zipWith (>)  tail <*> id $ [1..10]
09:05:11 <lambdabot>   Couldn't match expected type `[b0]' with actual type `[a0] -> [a0]'Couldn't...
09:05:21 <gdeest> alpounet: Yes, it's obvious in retrospect ; I was more thinking like "type families are functions between types" and forgetting about this type namespace thing
09:06:04 <_mkrull> bennofs: i did a clean install of aeson and now it works for me too. Will have to check why it does not work with the old set of modules
09:06:35 <FreeFull> > all . zipWith (>) tail <*> [id] $ [1..10]
09:06:36 <lambdabot>   Couldn't match expected type `[(a2 -> a2) -> b0]'
09:06:37 <lambdabot>              with actual ...
09:07:09 <FreeFull> > all . zipWith (>) tail <*> [1..10]
09:07:11 <lambdabot>   Couldn't match expected type `[a0 -> b0]'
09:07:11 <lambdabot>              with actual type `[b...
09:07:18 <FreeFull> Ok
09:07:33 <fizruk> it's and, not all
09:07:43 <fizruk> > and . zipWith (>)  tail <*> id $ [1..10]
09:07:44 <lambdabot>   Couldn't match expected type `[b1]' with actual type `[a0] -> [a0]'Couldn't...
09:08:05 <fizruk> hey, it eats my < $ >
09:09:23 <fizruk> > and $ zipWith (>) `fmap` tail <*> id $ [1..10]
09:09:24 <lambdabot>   True
09:09:46 <FreeFull> fizruk: What eats it? Your client?
09:10:01 <fizruk> perhaps, I dunno :)
09:11:01 <fizruk> yeah, it's nettalk
09:11:17 <fizruk> no idea, how to fix it though...
09:14:55 <bisam> one stupid question (I am a real haskell newbie): Is there an easy way to divide to Ints and get an int as result (truncated if possible)??
09:15:04 <chrisdone> :t div
09:15:05 <lambdabot> Integral a => a -> a -> a
09:15:15 <scriptor> > div 5 2
09:15:15 <fizruk> > 10 `div` 3
09:15:17 <lambdabot>   2
09:15:17 <lambdabot>   can't find file: L.hs
09:15:26 <ReinH> wat
09:15:30 <fizruk> great!
09:15:34 <scriptor> > 10 `dev` 3
09:15:38 <lambdabot>   Not in scope: `dev'
09:15:39 <lambdabot>  Perhaps you meant one of these:
09:15:39 <lambdabot>    `div' (imported fro...
09:15:40 <scriptor> blah
09:15:47 <chrisdone> lambdanot
09:16:07 <bisam> noice!
09:16:08 <FreeFull> When you get the can't find file error, just try again
09:16:42 <chrisdone> (haskell is still good for concurrency, guys)
09:16:57 <hardliner_> python is better than haskell?
09:17:07 <chrisdone> do bears do math in the woods?
09:17:22 <stevely> they occasionally multiply
09:17:47 <hardliner_> they can count up to 7
09:18:28 <donri> horay unsafeCoerce is fun. any silly little mistake you do will type check and either segfault or produce random weirdness :P
09:19:03 <ReinH> donri: it's almost as if it's unsafe
09:19:07 <donri> \o/
09:19:51 <chrisdone> i unsafeYouWereOnlySupposedToBlowTheBloodyDoorsOff
09:19:59 <donri> in my particular use case it's safe... provided i get it right ;)
09:20:03 <Twey> Heheh
09:20:29 <Twey> We could rename it unsafeTrollWithCrossbow
09:20:45 <Twey> I think that would get the idea across
09:21:03 <Twey> donri: It's always safe provided you get it right ;)
09:21:32 <donri> Twey: sure, but, "more so" in my case. i'm basically doing generalized newtype deriving without type classes
09:21:51 <donri> can't wait for ghc 7.8
09:21:52 <Twey> Ah
09:22:02 <Twey> You're unsafeCoercing the newtype away?
09:22:18 <donri> sort of, i'm "lifting" functions on the inner type to my newtype
09:22:22 <Twey> I think that's even standardly safe
09:22:47 <lingxiao> hey all, so Im reading the source for Control.Par
09:22:59 <lingxiao> and I see `Eval` is defined this way;
09:23:06 <lingxiao> #if __GLASGOW_HASKELL__ >= 702
09:23:14 <lingxiao> newtype Eval a = Eval (State# RealWorld -> (# State# RealWorld, a #))
09:23:25 <lingxiao> so what is this `#` thing doing?
09:23:41 <Twey> lingxiao: The first line is a call to CPP
09:23:51 <lingxiao> and what does the statement `State# Realworld` mean?
09:24:00 <Twey> In the second it denotes something that's primitive (usually unboxed)
09:24:17 <Twey> State# is the magic internal GHC state type
09:24:29 <Twey> (# foo, bar #) is a magic internal GHC pair
09:25:09 <lingxiao> oh where can I go to read about such magic?
09:25:11 <Sagi> Can I newtype a list of a class? E.g. something like newtype NumList = (Num a) => [a]
09:25:21 <donri> http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html
09:25:22 <lingxiao> or is it passed down via oral tradition
09:25:28 <lingxiao> ah awesome
09:25:41 <Twey> Sagi: You can certainly newtype NumList = Num a ⇒ NumList [a]
09:25:51 <Twey> Though people generally frown on constraints there
09:25:59 <quicksilver> State# is poorly named.
09:25:59 <lingxiao> thansk Twey and Donri
09:26:05 <Twey> No problem
09:26:06 <quicksilver> it's not a state monad.
09:26:12 <Twey> quicksilver: What is it?
09:26:15 <lingxiao> oh it's not ? what is it?
09:26:19 <quicksilver> the name is chosen for a certain syntactic relevance
09:26:33 <quicksilver> formally it looks like a state monad but it really isn't
09:26:41 <donri> Twey: hm can you do that newtype without DatatypeContexts or ExistentialQuantification?
09:26:44 <quicksilver> the RealWorld is not an actual piece of state which changes
09:26:44 <Sagi> Twey: I know it's frowned upon, but I think it's the only way to get the compiler to help me with keeping my data model consistent with the thing I'm trying to model.
09:26:48 * donri never do that sort of thing :P
09:26:51 <Twey> quicksilver: And why is that?
09:26:56 <Twey> donri: Err, maybe not
09:26:58 <quicksilver> it's a token used to maintain some invariants
09:27:07 <quicksilver> it's a trick.
09:27:09 <Twey> Ah
09:27:13 <quicksilver> and at that level the language isn't haskell anyway
09:27:24 <quicksilver> (non-trivial State# code is impure)
09:27:30 <Twey> Aye
09:27:47 <lingxiao> is there a place to read about State# and Realworld# specifically?
09:27:55 <Twey> Sagi: It probably isn't; you can always put the constraint on your functions instead
09:28:07 <Twey> lingxiao: You could read the GHC source
09:28:21 <lingxiao> ahh good point
09:28:31 <donri> it might be covered in the Lazy Functional State Threads paper
09:28:37 <Sagi> Twey: yeah, well. I use the class for polymorphism, not really to enforce some kind of constraint
09:29:27 <Sagi> I'll hit a wall sooner or later I guess, I'll come back crying then :-P
09:29:42 <Twey> Sagi: That's what constraints are for
09:31:10 <Twey> I.E. instead of writing newtype NumList = Num a ⇒ NumList [a]; f ∷ NumList a → b, you write newtype NumList a = NumList [a]; f ∷ Num a ⇒ NumList a → b
09:31:22 <fizbin> @src join
09:31:22 <lambdabot> join x =  x >>= id
09:31:27 <Twey> (although in that case your newtype is redundant)
09:31:36 <Twey> You get the same guarantees inside the function
09:32:08 <Twey> s/f ∷ NumList a/f ∷ NumList/
09:32:54 <chrisdone> EDITOR CHALLENGE:
09:32:54 <chrisdone> foo = do
09:32:55 <chrisdone>   let bibble = do wibble "wibble"| ← cursor is here, how many generic editor commands ran
09:32:55 <chrisdone>   |   |           |      |           to get to
09:32:57 <chrisdone>   here here       here   here
09:33:01 <chrisdone> without knowing how much `let' is indented, how long bibble is, how long wibble is, or how long wibble is, ahead of time
09:33:58 <FireFly> 1, 2, 2, 1
09:34:19 <chrisdone> FireFly: what are the commands?
09:34:29 <FireFly> ^  ^w  bb  b
09:34:52 <FireFly> er, make that B
09:35:01 <chrisdone> do you mean running those in sequence?
09:35:11 <FireFly> well, to get to the first spot, you'd do ^
09:35:12 <cschneid> chrisdone: no, that's vim, all starting from the end of the line
09:35:17 <hardliner_> i think python developers salary is higher than haskell devs
09:35:23 <Peaker> I want to write a Criterion benchmark that sets up/inserts many keys and then bench only the time it takes to delete them
09:35:27 <bennofs> What is an editor command? Do prefix arguments count as one command?
09:35:29 <FireFly> to get to the second (from the starting point) you'd do ^w
09:35:30 <donri> meh no RULES for fmap f . fmap g = fmap (f . g)
09:35:33 <Peaker> I can't find any way for Criterion to perform some "set up IO" ?
09:36:06 <alpounet> Peaker: main = do { blah <- foo bar; defaultMainWith … }
09:36:16 <Peaker> alpounet: But that is before *all* benchmarks
09:36:24 <fragamus> Can I get lambdabot to cough up source code for, say, id?
09:36:41 <alpounet> Peaker, but you don't want it to be taken into account right?
09:36:44 <chrisdone> FireFly: my question wasn't how do i go from this, to this, to this, to this, but rather "how do i go from the wibble string to any of those points from scratch"
09:36:45 <fragamus> It must use a for all
09:36:59 <chrisdone> FireFly: i don't know vim well, but i know that b doesn't go to a newline, for a start
09:37:19 <cschneid> chrisdone: right, and he does that.  1 command "^" goes to start of the line, modulo whitespace.  ^w is two commands, go to beginning, then one word right
09:37:20 <donri> depends on settings
09:37:31 <FireFly> chrisdone: wait, bibble/wibble/"wibble" may contain newlines?
09:37:38 <cschneid> chrisdone: b is "go back word". So bb is go back two words
09:37:51 <chrisdone> no, i mean you want to start writing on the next line
09:37:52 <FireFly> Each of those four "snippets" of keystrokes go from the cursor start position to each of the four here's
09:37:59 <FireFly> oooh
09:38:11 <FireFly> I thought the vertical bars were arrowy things :p
09:38:13 <cschneid> chrisdone: ohh, I see. `o` does the first one fine.
09:38:17 <cschneid> FireFly: me too :)
09:38:34 <chrisdone> yeah, sorry, it's hard to describe this asciily
09:38:45 <fragamus>  :t id
09:38:52 <alpounet> @src id
09:38:52 <lambdabot> id x = x
09:38:53 <Iceland_jack> :t id id
09:38:53 <lambdabot> a -> a
09:39:11 <FireFly> If you  :set ve=all  then mine would still work if you append o to each of them :p
09:39:19 <chrisdone> bennofs: prefix don't count as additional commands, but the commands themselves will be observed =p
09:39:23 <kuribas> I have set library-profiling to True in .cabal/config, but I still need to use cabal install -p to compile a package.  Is there a way to automate it?
09:39:27 <FireFly> I think, at least..
09:39:31 * FireFly tries
09:39:53 <bisam> >5/2
09:40:00 <chrisdone> FireFly: so "o" is essentially "go down one line on the same column, leaving this line alone"?
09:40:24 <cschneid> chrisdone: o is "open new line", so it makes a newline below you and puts you in insert mode at the "beginning" (as defined by syntax)
09:40:27 <Peaker> alpounet: I want it performed iff the benchmark is run, and the same number of times that the benchmark is run
09:40:29 <donri> chrisdone: vim doesn't have any great way to do that no. my silly solution is "duplicate the line, position cursor, replace every character on line with space, enter insert
09:40:32 <cschneid> chrisdone: there's probably a variaent that keeps the column
09:40:34 <FireFly> o is "open below", which enters insert mode one line down and applies autoindentation
09:41:15 <fragamus> :t fmap
09:41:17 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:41:20 <chrisdone> gotcha
09:41:21 <FireFly> 've' is virtualedit, which basically allows you to pretend there's spaces everywhere. You could put the cursor where there isn't any character, and if you try to insert something there it'll automatically add spaces to the left of it
09:41:40 <chrisdone> yeah, ve is probably good for drawing ascii art
09:42:03 <cschneid> #vim suggested a mapping. which doesn't sound too hard, but I should go do errands instead of messing w/ it :)
09:42:15 <cschneid> chrisdone: FireFly: when you do get it, ping me, I'd be curious to see it
09:42:30 <chrisdone> =)
09:43:37 <bennofs> (1) 4 (<CR> <backspace> <backspace> <backspace>) (2) 3 (<CR> <backspace> <backspace>) (3) 1 (<CR>) (4) idk
09:44:07 <`^_^v> is there any clever way i can reduce the number of characters it takes to write this function? parseType = lexIdentifier >>= (\n -> if (isUpper . head) n then return n else fail "expected type identifier")
09:44:18 <`^_^v> while preserving its exact semantics of course
09:44:50 <donri> FireFly: hm "o" doesn't do that for me with ve=all
09:46:51 <FireFly> donri: hm, looks like you're right
09:47:39 <chrisdone> bennofs: your indentation mode doesn't handle the fourth case?
09:48:35 <chrisdone> `^_^v: i think there's some kind of ?? operator in parsec's combinator module
09:48:46 <bennofs> chrisdone: right. It would indent it like this:
09:49:05 <bennofs>   let bibble = do wibble "wibble"|
09:49:35 <bennofs> And then indent 2 spaces after position 3
09:50:11 <chrisdone> ic
09:50:51 <donri> FireFly: crappy way: :set ve=all nosol  and then use ]<Space> from unimpaired and then ji  :P
09:51:50 <ocharles> oh good, I've finally hit the pipes-safe non-promptness problem :(
09:52:05 <donri> ocharles: nest moar?
09:53:05 <ocharles> https://github.com/ocharles/pipes-postgresql-simple/blob/master/src/Pipes/PostgreSQL/Simple/SafeT.hs
09:53:24 <ocharles> You'd hope that 'putCopyEnd' would happen after each 'toTable' call, but it actually happens when all 'toTable' calls have run
09:53:45 <`^_^v> chrisdone, i mean the more general pattern of (action) >>= (\a -> if (cond a) then return a else fail "…")
09:53:57 <ocharles> so if I iterate over a tar archive with 'iterTarArchive' (from pipes-tar), sending each tar entry to a database table, I want to Pg.putCopyEnd after each file
09:54:01 <ocharles> this seems to leave them all to the end
09:54:10 <chrisdone> `^_^v: satisfy?
09:54:15 <FireFly> donri: well, at least it works :p  I don't have any better suggestions
09:54:16 <ocharles> i guess I should be bracketting, but I'm not
09:54:18 * ocharles hacks at this
09:55:20 <chrisdone> in pure structured-haskell-mode i have:
09:55:21 <chrisdone> foo = do
09:55:21 <chrisdone>   let bibble = do wibble "wibble"|
09:55:21 <chrisdone>   |   |           |      |
09:55:24 <chrisdone>       ))) C-j     ) C-j  C-j
09:55:27 <chrisdone>   )))) C-j
09:55:47 <donri> FireFly: i liked your idea though, i'll probably make go and gO operators that do this independent of settings
09:55:57 <wto> If i had a [Double] in my hand that I wanted to run through an IMDCT, how would I easiest go about it?
09:56:47 <donri> ocharles: if bracketing doesn't do it, try nesting with runSafeP (is what i heard, anyway)
09:56:57 <ocharles> donri: yea, I think that's actually what I want
09:57:34 <ocharles> donri: though I'm not sure I can do that, because I don't have an effect
09:57:37 <donri> wto: what's an IMDCT?
09:57:39 <chrisdone> (which is how you'd write it in paredit-mode)
09:58:05 <wto> donri: a kind of transform
09:58:51 <chrisdone> bennofs: is that editor sublime text?
09:59:12 <bennofs> emacs with haskell-mode
10:00:18 <chrisdone> if you have
10:00:18 <chrisdone>   let bibble = do wibble "wibble" (foo bar
10:00:18 <chrisdone>                                        zot)
10:00:18 <chrisdone> how do you make this?
10:00:21 <chrisdone>   let bibble = do wibble "wibble"
10:00:24 <chrisdone>                          (foo bar
10:00:28 <chrisdone>                               zot)
10:04:23 <lispy> chrisdone: I insert a newline and adjust the horizontal spaces :)
10:04:43 * lispy thinks he didn't understand the question
10:05:02 <chrisdone> lispy: figured
10:05:04 <FireFly> donri:   :nnoremap go i<Esc>yyP`^hv^r<Space>wC
10:05:16 <FireFly> (without any dependency on 've' or plugins :P)
10:05:19 <chrisdone> lispy: in structured-haskell-mode i go to the opening paren and hit C-j
10:05:24 <lispy> ah
10:05:39 <chrisdone> lispy: i'm partly showing off, partly curious how much suck people put up with/are happy with
10:05:47 <lispy> chrisdone: I use vim and do a lot of vertical alignment so that I can work with rectangular regions
10:06:28 <mangaba_leitosa> so, is does it makes sense for me to look at sublime-text if I'm satisfied with vim?
10:06:29 <donri> FireFly: nice :)
10:06:41 <chrisdone> lispy: right
10:06:49 * chrisdone runs to a meeting
10:07:46 <donri> FireFly: "w" might not always work there though
10:07:57 <FireFly> Hmm
10:08:21 <FireFly> That's true, I wonder if there's a nicer way to do the v^r<Space> part anyway..
10:12:21 <donri> FireFly: Ypi<Esc>Vr<Space>`^C
10:12:35 <donri> chrisdone: no that's not a regexp
10:13:41 <fizbin> Is there any class-level thing equivalent to "type"? I want to make an alias for a class with some parameters filled in - that is, I have MyMultiPClass foo bar and I want to say "MyAlias foo" is equivalent to "MyMultiPClass foo String".
10:14:04 <foobar3> \quit
10:14:10 <bennofs> fizbin: Constraint kinds?
10:14:26 <FireFly> donri: after pasting, the cursor seems to reset to beginning-of-line
10:14:27 <fizbin> bennofs: What's that? Got a link?
10:14:34 <bennofs> You can write type MyConstraint a = (MyMultiPClass a String)
10:14:55 <FireFly> (that was why I did i<Esc> and `^, hacky as it is)
10:15:47 <donri> FireFly: ah
10:16:26 <fizbin> Ah, ok. Just need XConstraintKinds
10:17:21 <absence> is there something similar to Data.Vector that includes the length of the vector in the type?
10:19:00 <bartavelle> Can someone explain to me this ? http://www.haskell.org/pipermail/haskell-cafe/2013-October/110981.html
10:19:15 <bartavelle> I don't see how changing elem to Set.member is going to be that bad for strictness and/or performance
10:21:02 <donri> FireFly: so, nnoremap <Leader>o i<Esc>YPjVr<Space>`^C
10:21:44 <fizbin> Hrm. Seems like I should learn about type families before getting into constraint kinds.
10:21:58 * hackagebot bindings-sophia 0.2.0 - Low-level bindings to sophia library  http://hackage.haskell.org/package/bindings-sophia-0.2.0 (EyalLotem)
10:22:00 * hackagebot sophia 0.1.2 - Bindings to Sophia library  http://hackage.haskell.org/package/sophia-0.1.2 (EyalLotem)
10:22:37 <FireFly> donri: p instead of Pj ?
10:23:02 <FireFly> oh, but then you need a j after the `^ instead
10:23:10 <FireFly> so never mind.
10:27:52 <enthropy> preflex seen luqui
10:27:53 <preflex>  luqui was last seen on #haskell 124 days, 17 hours, 10 minutes and 17 seconds ago, saying: I say haskelly
10:29:43 <ocharles> welp, can't solve that pipes problem
10:29:48 <ocharles> lets see what the gurus have to say
10:30:33 <bennofs> FireFly: Note that constraint kind only allows you to use that type synonym in a constraint. You cannot say instance MPTTypeSynonym a
10:31:48 <kuribas> How can I make cabal install profiling libraries by default?
10:32:18 <bennofs> kuribas: edit ~/.cabal/config, and change the library-profiling: field to true
10:34:56 <turiya> hi
10:35:12 <kuribas> bennofs: I did
10:35:31 <kuribas> bennofs: But if I don't use cabal install -p I don't get the profiling libraries.
10:35:41 <turiya> how to get the content between two given chars in Parsec?
10:35:47 <turiya> does the between function help
10:35:59 <bennofs> kuribas: did you uncomment the library-profiling field (removing the -- in front of it) ?
10:37:28 <kuribas> Oh... I am stupid.
10:37:33 <kuribas> bennofs: No
10:38:14 <mm_freak> ocharles: what problem?
10:38:27 <donri> mm_freak: see list
10:38:37 <kuribas> turiya: You answered your own question?
10:38:48 <mm_freak> ah
10:39:19 <turiya> kuribas: maybe, but i am not sure how to use it
10:40:29 <enthropy> turiya: probably you need to make sure what's between doesn't eat the same thing you're expecting at the end: (char 'a') (many (noneOf "x")) (char 'x')
10:41:28 <turiya> enthropy: i want to get the string between to braces, e.g. "{asbcd}", I want to get asbcd
10:41:47 <turiya> two braces
10:42:57 <enthropy> @hoogle braces
10:42:57 <lambdabot> Text.PrettyPrint.HughesPJ braces :: Doc -> Doc
10:42:57 <lambdabot> Text.PrettyPrint braces :: Doc -> Doc
10:42:57 <lambdabot> Language.Haskell.TH.PprLib braces :: Doc -> Doc
10:43:22 <enthropy> there's probably something that comes with parsec that does the between thing with { }
10:43:37 <kuribas> turiya: between (string "\"{") (string "}\"")
10:44:23 <kuribas> Or just the braces?
10:45:37 <turiya> kuribas:just the braces, however the type for that function is GenParser Char st String ->  GenParser Char st String
10:45:51 <turiya> so how to do i use it to parse?
10:47:07 <kuribas> Yes, because it parses a string.
10:47:23 <kuribas> :t between (char '{') (char '}')
10:47:24 <lambdabot> Not in scope: `between'
10:48:30 <kuribas> between (char '{') (char '}') :: Stream s m Char => ParsecT s u m a -> ParsecT s u m a
10:48:33 <NihilistDandy> @pl oct2dec x = traverse %~ fst $ readOct x
10:48:33 <lambdabot> (line 1, column 12):
10:48:33 <lambdabot> unexpected " "
10:48:33 <lambdabot> expecting operator
10:48:43 <kuribas> turiya: It works fine.
10:49:27 <turiya> between (char '{') (char '}' "{ab}"
10:49:39 <kuribas> What enthropy said: between (char '{') (char '}') (many (noneOf "x"))
10:50:04 <mauke> did you mean: noneOf "}"
10:50:13 <kuribas> yes
10:50:27 <kuribas> turiya: You only have a parser, you still need to run it.
10:51:00 <turiya> kuribas: i think i am getting it now
10:52:36 <kuribas> :t parse $ between (char '{') (char '}') (many (noneOf "x"))
10:52:37 <lambdabot> Not in scope: `parse'
10:52:37 <lambdabot> Not in scope: `between'
10:52:37 <lambdabot>     Not in scope: `noneOf'
10:52:45 <kuribas> parse $ between (char '{') (char '}') (many (noneOf "x")) :: Stream s Data.Functor.Identity.Identity Char => SourceName -> s -> Either ParseError [Char]
10:53:28 <Eduard_Munteanu> What happens if you run a program and hGetContents its stdout and stderr? It may write and block on stdout and you're trying to lazily read from stderr, resulting in a deadlock, no?
10:53:42 <turiya> kuribas: thanks, it is working now
10:53:45 <mauke> Eduard_Munteanu: sure
10:53:57 <kuribas> turiya: good!
10:54:17 <Eduard_Munteanu> mauke: right, I guess I should try conduits / iteratees then.
10:54:20 <turiya> between open close p parses open, followed by p and close
10:54:30 <mauke> just spawn a thread or five
10:54:37 <Eduard_Munteanu> Is there any standard recommendation for one of those or something else?
10:54:48 <turiya> what does char '{' do?
10:55:03 <mauke> creates a parser that accepts {
10:55:09 <turiya> does it parse until it hits {
10:55:12 <Clint> no
10:55:19 <zebr> hey all. does using (State a b) rather than (a -> (b,a)) incur any runtime cost?
10:55:34 <Ralith> zebr: try it and see!
10:56:12 <Eduard_Munteanu> mauke: hm, I was hoping to be able to log stderr to a Writer.
10:56:13 <kuribas> cabal sucks!  Why cannot it detect if a package has no profiling libraries installed?
10:56:20 <turiya> mauke: ok, so after char '{' is done, only the remaining list remains? e.g. char '{' on {ab} should give ab}?
10:56:28 <mauke> turiya: yes
10:56:29 <zebr> Ralith: i'd rather not write all my code, in one case using it and in the other not :p
10:56:35 <zebr> +twice
10:56:44 <turiya> mauke: ok, nice. thanks
10:57:31 <Eduard_Munteanu> I guess I can't do that in a forkIO.
10:57:38 <Ralith> zebr: M-x regexp-replace is your friend
10:57:41 <Ralith> (alternatively, sed)
10:57:54 <Ralith> (er, M-x replace-regexp)
10:58:24 <zebr> Ralith: :%s///, actually :p but there's a little more to it than that, what with wrapping and unwrapping newtypes, using or not using monadic do-notation...
10:58:28 <zebr> it would be a faff.
10:59:01 <Eduard_Munteanu> I could use 'async', wait for the stderr thread and 'tell' its result.
10:59:36 <Ralith> zebr: then you should do the convenient thing and change it iff it's too slow
10:59:43 <Eduard_Munteanu> Though that's equivalent to strict IO, really.
11:00:02 <fizbin> Suppose I have an array (that is, a Data.Array.Array made with Data.Array.array) and I want to ensure that the associations it was instantiated with included every index. (that is, check that no value is "bottom") How would I do that?
11:00:14 <Eduard_Munteanu> I'll just forkIO and write to an MVar.
11:00:24 <Eduard_Munteanu> (no more Writer)
11:00:33 <mm_freak> fizbin: by not using 'array'
11:00:57 <mm_freak> fizbin: you can't observe bottoms
11:01:25 <briennetheblue> it's rude
11:01:41 <fizbin> Okay, so now I have an Array built by nothing because "don't use foo" without "use bar instead" leaves me with no code...
11:01:50 * Eduard_Munteanu wonders what's the connection between spoons and bottoms
11:02:23 <NihilistDandy> @pl oct2dec x = fromJust $ readOct x ^? traverse._1
11:02:23 <lambdabot> (line 1, column 46):
11:02:23 <lambdabot> unexpected "_"
11:02:23 <lambdabot> expecting white space
11:02:23 <lambdabot> ambiguous use of a right associative operator
11:03:07 <turiya> mauke: if a line does not contain { or }, how can i ignore and proceed to the next line?
11:03:15 <zebr> mm_freak: presumably you can observe *some* bottoms in IO?
11:03:35 <mm_freak> zebr: fair enough
11:03:52 <zebr> (not that you should...)
11:03:56 <bennofs> NihilistDandy that is just readOct x ^?! traverse . _1
11:04:02 <mm_freak> fizbin: are you using Int indices?
11:04:03 <arkeet> you can get a loewr bound on the definedness of a thing in IO.
11:04:06 <arkeet> lower.
11:04:31 <zebr> yeah, that figures.
11:04:36 <mm_freak> zebr: actually you probably should in most applications, but only for proper error handling =)
11:05:00 <arkeet> error: program doesn't halt
11:05:52 <fizbin> mm_freak: I am. Given that performance here is very non-critical, I may just use accumArray to build an Array of (Maybe WhatIWant), initialize everything to Nothing, and then walk it again to assert that everything's kosher before doing an fmap fromJust on it.
11:05:53 <mm_freak> error: division by zero, so gracefully close the database and quit
11:06:07 <mm_freak> fizbin: then i recommend using Data.Vector instead
11:06:15 <NihilistDandy> > (readOct "12") ^?! traverse._1
11:06:17 <lambdabot>   10
11:06:36 <mm_freak> arkeet: usually the non-termination bottom is translated to a terminating bottom, e.g. a SIGINT =)
11:06:55 <mm_freak> and in that case you may want to createCheckpointAndClose your acid-state ;)
11:06:55 <arkeet> hehe
11:07:11 <bennofs> @let import Numeric.Lens
11:07:12 <lambdabot>  Defined.
11:07:31 <bennofs> > "12" ^?! base 8
11:07:33 <lambdabot>   10
11:07:37 <bennofs> NihilistDandy: ^^
11:07:44 <mm_freak> :t base
11:07:49 <arkeet> :t (base)
11:07:50 <lambdabot> (Integral a, Applicative f, Choice p) => Int -> p a (f a) -> p String (f String)
11:08:02 <mm_freak> seriously?
11:08:05 <bennofs> It's Integral a => Prism' String a
11:08:10 <arkeet> Integral a => Prism' String a
11:08:13 <mm_freak> :t base
11:08:20 <mm_freak> why doesn't that work?
11:08:21 <arkeet> yeah, blame elliott
11:08:33 <mm_freak> :t map
11:08:34 <lambdabot> (a -> b) -> [a] -> [b]
11:08:43 <arkeet> it randomly works for some things and not others
11:08:51 <mm_freak> :t base map
11:08:51 <lambdabot>     Couldn't match expected type `Int'
11:08:52 <lambdabot>                 with actual type `(a1 -> b0) -> [a1] -> [b0]'
11:08:52 <lambdabot>     In the first argument of `base', namely `map'
11:08:56 <arkeet> :t id base
11:08:57 <lambdabot> (Integral a, Applicative f, Choice p) => Int -> p a (f a) -> p String (f String)
11:09:01 <mm_freak> indeed random…
11:09:10 <arkeet> :t Control.Lens.base
11:09:11 <lambdabot>     Not in scope: `Control.Lens.base'
11:09:11 <lambdabot>     Perhaps you meant one of these:
11:09:11 <lambdabot>       `Control.Lens.has' (imported from Control.Lens),
11:09:15 <arkeet> :t Numeric.Lens.base
11:09:16 <bennofs> :t Numeric.Lens.base
11:09:16 <lambdabot> (Integral a, Applicative f, Choice p) => Int -> p a (f a) -> p String (f String)
11:09:17 <lambdabot> (Integral a, Applicative f, Choice p) => Int -> p a (f a) -> p String (f String)
11:09:20 <arkeet> yeah that
11:11:07 <fizbin> mm_freak: Oh, actually I'm using index values of type (Int, Int).
11:11:16 <fizbin> So I think I'll stick with Array.
11:11:25 <mm_freak> fizbin: what's the application?
11:11:50 <fizbin> In this case it's the state transition table of a state machine.
11:13:02 <fizbin> Except that it's a more complicated type at each (Int, Int) spot than simply (Int), because $proprietary_details.
11:14:00 <mm_freak> fizbin: so what's the (Int, Int)?  the starting state?
11:14:36 <fizbin> starting state and .... call it the incoming event number.
11:15:06 <mm_freak> and the array element is the result state?
11:17:31 <mm_freak> fizbin: all of this sounds like you may benefit from using a completely different abstraction…  look into applicative automata as defined by the 'machines' package
11:18:39 <mm_freak> fizbin: this abstracts the state away and makes the automata composable and likely also faster
11:19:08 <fizbin> Not actually helpful to my application.
11:19:41 <mm_freak> if you could reveal slightly more, i could tell you which abstractions would fit
11:19:56 <kuribas> cabal: " Perhaps you haven't installed the profiling libraries for package `srcloc-0.4.0'?"  Why cannot it install the profiling libraries by itself?
11:20:38 <dcoutts> kuribas: the reason it cannot detect if a package has no profiling libraries is because that info is not recorded anywhere
11:20:39 <fizbin> Since I'm creating stuff that compiles to a finite state machine, and this is the structure that holds the machine's state prior to spitting it into a format that then something else is going to run with.
11:21:07 <dcoutts> kuribas: ghc-pkg manages the db of registered packages and that does not tell us if there is profiled libs or not
11:21:35 <mm_freak> fizbin: i see, so you really need a state map…  how about actually using a Map?
11:22:00 <Twey> GHC documentation says: Traditional record syntax, such as C {f = x}, is enabled by default. To disable it, you can use the -XNoTraditionalRecordSyntax flag.
11:22:04 <mm_freak> fizbin: or a "delayed array" aka function =)
11:22:05 <kuribas> dcoutts: Wouldn't that be a good addition to ghc-pkg?
11:22:05 <Twey> What's the non-traditional record syntax?
11:22:46 <dcoutts> kuribas: well yes and no, the better method would be to register the profiling ones separately so you can add profiling ones later
11:22:46 <mm_freak> fizbin: Map Event (Map State State), Map (Event, State) State, Event -> State -> State
11:22:52 <fizbin> mm_freak:  Maybe... a map might actually make more sense, and then I'd just see that everything was there.
11:23:14 <dcoutts> kuribas: since ideally what you want is to just install the profiling versions when you find you need them, not have to do it up front all the time
11:23:18 <mm_freak> fizbin: indeed…  and for completeness here is another interesting alternative:  a store/traced comonad
11:23:30 <mm_freak> fizbin: that's what i would use
11:24:30 <kuribas> dcoutts: yes, that would be better.
11:24:33 <fizbin> Likely Map (State, Event) StateWithOtherCrap. But then my function that builds it will of course be something like (Error e, MonadError e m) => ... -> m (Map (State, Event) StateWithOtherCrap)
11:27:06 <mm_freak> fizbin: or rather just:  (Alternative f) => f (Map …)
11:28:02 <fizbin> mm_freak: The documentation on the comonad library is minimal to non-existent. Where might I read more about what Store and Trace do/mean?
11:28:09 <Twey>  
11:28:24 <flebron> Friend of mine is getting "Could not find module `Test.QuickCheck.Property'", after cabal install quickcheck, "import Test.QuickCheck" also doesn't work. What could be the issue?
11:28:26 <edwardk> i'm happy to accept documentation patches there. comonad is one of my older packages
11:28:52 <flebron> (Fedora 19, GHC 7.4.2)
11:29:03 <mm_freak> fizbin: you can think of Store as an array with a pointer
11:29:06 <fizbin> edwardk: I note a bit of a bootstrapping problem before I could submit such patches.
11:29:19 <dcoutts> flebron: likely it's not actually installed, you can check with ghc-pkg list QuickCheck
11:29:20 <fizbin> mm_freak: Can
11:29:24 <edwardk> fizbin: well, once you're bootstrapped, patch! =)
11:29:28 <mm_freak> fizbin: data Store ix a = Store (Array ix a) ix
11:29:34 <arkeet> flebron: what does ghc-pkg say?
11:29:53 <mm_freak> fizbin: the most general store looks like this:  data Store ix a = Store (ix -> a) a
11:30:10 <fizbin> mm_freak: Can't really use just Alternative because there are many ways to screw up input such that I can't build the output, and I want to strMsg all of them.
11:30:18 <mm_freak> it's almost the same thing, except that it's representation-agnostic
11:30:42 <arkeet> flebron: capitalization is correct, right?
11:30:57 <mm_freak> fizbin: sure, although then i'd probably just use Either MyErrorType
11:31:03 <mm_freak> fizbin: MonadError is retarded
11:31:10 <arkeet> module names are case-sensitive =(
11:31:11 <arkeet> (and package names)
11:31:26 <flebron> (I'm getting the ghc-pkg info from him :))
11:31:35 <mm_freak> arkeet: package names are semi-case-sensitive =)
11:31:43 <arkeet> well yes
11:31:56 <fizbin> mm_freak: MonadError may be over-generic. Since there is a MonadError instance for (Either MyErrorType) though...
11:32:13 <mm_freak> fizbin: no, it's not over-generic…  it's in fact not generic enough
11:32:37 <arkeet> fizbin: look more closely, it's Error e => MonadError (Either e) or something.
11:32:47 <arkeet> the Error e constraint is stupid.
11:32:53 <mm_freak> totally
11:32:54 <fizbin> Sure, but Error instances are easy to add.
11:33:24 <flebron> arkeet, dcoutts: http://lpaste.net/5284342063792390144
11:33:56 <arkeet> flebron: ghc-pkg describe QuickCheck
11:34:44 <arkeet> in case he's doing this in ghci, he *did* restart ghci after installing, right?
11:34:46 <arkeet> ;)
11:36:32 <flebron> (he apparently was doing the cabal install using root.... :s)
11:36:42 <arkeet> and ghci in non-root? yeah that won't work...
11:36:45 <arkeet> or ghc
11:37:20 <dcoutts> flebron: to do a global install one needs to use the --global flag
11:37:29 <arkeet> ahh I just noticed the path in the package list =(
11:37:35 <arkeet> anyway http://www.vex.net/~trebla/haskell/sicp.xhtml
11:38:01 <arkeet> should be read by all
11:38:18 <monochrom> who is doing cabal install using root? he/she needs to read my http://www.vex.net/~trebla/haskell/sicp.xhtml#root
11:38:37 <arkeet> ;)
11:44:03 <xico> hi. i would like to convert a Dynamic to Maybe Double. should i try every possibility with (fromDynamic myVal :: Maybe a), where a is first Double, then Int (and use realToFrac), etc?
11:44:33 <xico> or is there a way to write something like (realToFrac (fromDynamic myVal :: Real a))
11:44:41 <arkeet> is there a reason you have to use Dynamic?
11:44:48 <xico> arkeet: ghc code
11:44:55 <arkeet> =(
11:45:06 <arkeet> then yeah, you'd have to do it one type at a type
11:45:08 <arkeet> at a time
11:45:31 <xico> well, i guess i could put all that in a Maybe do to keep it simple
11:45:49 <arkeet> no, not do
11:46:07 <arkeet> you don't wan't one Nothing to kill everything.
11:46:11 <arkeet> try <|>
11:46:17 <xico> arkeet: ah, you are right!
11:46:21 <xico> thanks :)
11:47:34 <mm_freak> monochrom: nice article, thanks
11:48:02 <Pranz> what other languages exist with linear and dependent types except ATS?
11:48:58 <napping> hardly any, maybe lollimon
11:49:42 <briennetheblue> :t transform
11:49:43 <lambdabot> Plated a => (a -> a) -> a -> a
11:52:47 <flebron> So even if I import Control.Exception (catch), if I use "catch", I can get an ambiguity error between Prelude.catch and Control.Exception.catch?
11:54:13 <arkeet> flebron: which ghc?
11:54:18 <flebron> 7.4.2
11:54:42 <flebron> (This is my friend running the code, I'm using 7.6.3 and it runs fine.)
11:55:24 <arkeet> then yes
11:55:33 <flebron> Was this something changed between versions?
11:55:35 <arkeet> in 7.6, Prelude re-exports the one from Control.Exception.Base
11:55:44 <arkeet> in 7.4, it gets it from System.IO.Error
11:56:21 <flebron> Will changing it to Control.Exception.catch fix it for 7.4?
11:56:33 <simpson> a/bu15
11:56:36 <simpson> Haha, wat.
11:56:47 <arkeet> flebron: probably.
11:56:59 <arkeet> you might get some ambiguous type errors.
11:57:01 <napping> or import Prelude hiding (catch)
11:57:18 <arkeet> that would be the thing to do
11:58:35 <arkeet> I don't know what even older versions of GHC do.
11:58:48 <arkeet> Control.Exception used to be quite different iirc.
11:59:08 <turiya> how can i  parse a string for occurances of continuous chars using Parsec
11:59:21 <zebr> given a [State a b], is there an easy way to get a (State a [b]), where the state has been passed down through the list and each 'intermediate' result returned?
11:59:36 <arkeet> turiya: occurences of the same (unknown) character?
12:00:05 <Twey> turiya: many chunk where chunk = anyToken >>= many . char
12:00:08 <arkeet> zebr: sequence
12:00:14 <Eduard_Munteanu> Can I ask 'lens' to make classy lenses where each *field* corresponds to a Has<field> class?
12:00:20 <zebr> arkeet: ah, thanks.
12:00:22 <Twey> Or something
12:00:35 <edwardk> makeFields
12:00:42 <Eduard_Munteanu> Thanks.
12:01:03 <mm_freak> lambdabot's ircPlugin doesn't have any commands…  how do i make it connect to an IRC server?
12:01:22 <mm_freak> lambdabot could really use some up to date documentation…
12:01:57 <turiya> Twey: thanks, i will try that
12:01:57 <arkeet> I never managed to compile it.
12:02:32 <ratm> a little OT but does anybody know if it's correct to assume the beginning of the unix epoch to be the smallest valid value of the Last-Modified HTTP-Header?
12:02:45 <Nimatek> mm_freak: create a lambdabot config file and start it with: lambdabot -e "rc yourconfigfile"
12:03:01 <mm_freak> ratm: no
12:03:34 <mm_freak> Nimatek: unfortunately "create a lambdabot config file" is infeasible without documentation
12:03:53 <donri> edwardk: i always thought makeFields just made instances for Field*
12:04:13 <fizbin> Is there somewhere a good haskell number-stuff cheat sheet? I find myself constantly needing to go look up stupid stuff like how to convert between Word8 and Int.
12:04:27 <Nimatek> mm_freak: some can be found here http://users.ece.cmu.edu/~allbery/lambdabot/COMMANDS
12:04:43 <Twey> fizbin: The answer is always fromIntegral :þ
12:05:06 <donri> no, unsafeCoerce! ;)
12:05:29 * Twey can't think of a single time he's converted between numeric types and didn't use fromIntegral
12:06:03 <monochrom> well, sometimes it's realToFrac :)
12:06:21 <Twey> I don't think I've ever had to use realToFrac
12:06:29 <Twey> :t realToFrac
12:06:30 <lambdabot> (Fractional b, Real a) => a -> b
12:06:46 <fizbin> Isn't it sometimes toInteger?
12:07:03 <fizbin> Or I guess fromIntegral has you covered there too...
12:07:44 <ratm> mm_freak: does any standard define a range or is this completly implementation dependent?
12:08:25 <briennetheblue> is there a nice way to traverse over the Int leaves of a [...[Int]...]?  can uniplate help with that sort of thing?
12:08:32 <Nimatek> mm_freak: for example http://lpaste.net/94347
12:08:36 <briennetheblue> something that doesn't involve writing traverse a million times
12:09:17 <monochrom> but you did write "[" a million times
12:09:45 <mm_freak> fizbin: here is a catch-all in order of preference:  fromInteger, fromIntegral, realToFrac, round
12:09:56 <mm_freak> Nimatek: thanks
12:10:09 <mm_freak> ratm: what do you mean?
12:10:10 <arkeet> briennetheblue: lens can do it ;)
12:10:49 <briennetheblue> i was hoping so... how?
12:11:08 <monochrom> I don't know
12:11:15 <mm_freak> i don't think lens can do it without traverse . traverse . traverse . traverse . traverse . traverse . traverse . traverse . traverse …
12:11:36 <edwardk> :t without
12:11:39 <arkeet> well sure, if you don't know how many levels you have then that's harder
12:11:40 <briennetheblue> i was looking at control.lens.plated but i don't really understand that stuff
12:11:41 <edwardk> :t (without traverse)
12:11:42 <lambdabot>     Couldn't match type `a1 -> f1 b1'
12:11:42 <lambdabot>                   with `Control.Lens.Internal.Prism.Market a0 b0 a0 (Mutator b0)'
12:11:42 <lambdabot>     Expected type: APrism s0 t0 a0 b0
12:11:43 <mm_freak> briennetheblue: you'd have to use a type class for that
12:11:51 <arkeet> you could that
12:11:53 <arkeet> or plated stuff
12:11:59 <arkeet> > toListOf (traverse.traverse.traverse) [[[1,2]],[[3],[4,5]]]
12:12:00 <lambdabot>   [1,2,3,4,5]
12:12:16 <mm_freak> briennetheblue: but yeah, *plate should also be able to do it
12:12:20 <edwardk> briennetheblue: import Data.Data.Lens then you can just use over biplate
12:12:24 <briennetheblue> :t (without)
12:12:25 <lambdabot> (Applicative f, Choice p) => APrism s t a b -> APrism u v c d -> p (Either a c) (f (Either b d)) -> p (Either s u) (f (Either t v))
12:12:34 <arkeet> > toListOf biplate [[[1,2]],[[3],[4,5]]] :: [Int]
12:12:35 <lambdabot>   []
12:12:37 <arkeet> > toListOf biplate [[[1,2]],[[3],[4,5]]] :: [Integer]
12:12:39 <lambdabot>   [1,2,3,4,5]
12:12:42 <edwardk> > over biplate (+1 :: Int -> Int) [[[[2,3,4],[5,6]]]]
12:12:43 <lambdabot>   <hint>:1:18: parse error on input `::'
12:12:45 <ratm> mm_freak: iam asking this because one can use these timestamps to track users. the http standard says you must not use values in the future. so the number of users you can track is the difference between the current time an the smallest valid value
12:12:52 <arkeet> edwardk: probably needs Integer =(
12:12:52 <edwardk> > over biplate ((+1) :: Int -> Int) [[[[2,3,4],[5,6]]]]]
12:12:53 <lambdabot>   <hint>:1:54: parse error on input `]'
12:12:58 <edwardk> > over biplate ((+1) :: Int -> Int) [[[[2,3,4],[5,6]]]]
12:12:59 <lambdabot>   [[[[2,3,4],[5,6]]]]
12:13:05 <edwardk> > over biplate ((+1) :: Integer -> Integer) [[[[2,3,4],[5,6]]]]
12:13:07 <lambdabot>   [[[[3,4,5],[6,7]]]]
12:13:24 <edwardk> i meant to put the Int constraint on the final answer too but forgot, that works though
12:13:39 <arkeet> that wouldn't have worked
12:13:39 <donri> why don't the Num methods have defaults in terms of fromInteger?
12:13:39 <briennetheblue> > over biplate (show :: Integer -> String) [[[1]]]
12:13:40 <lambdabot>   Couldn't match type `GHC.Integer.Type.Integer'
12:13:40 <lambdabot>                with `GHC.Bas...
12:13:44 <arkeet> you need to fix the list type =(
12:13:48 <donri> oh wait you'd need toInteger too
12:13:50 <arkeet> donri: how would that work?
12:13:50 <arkeet> yeah
12:13:54 <edwardk> > over biplate toUpper [[[[[["hello","world"]]]]]
12:13:55 <lambdabot>   <hint>:1:48:
12:13:55 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
12:14:09 <edwardk> > over biplate toUpper [[[[[["hello","world"]]]]]]
12:14:10 <lambdabot>   [[[[[["HELLO","WORLD"]]]]]]
12:14:16 <arkeet> then again
12:14:21 <arkeet> if you have an unknown number of levels
12:14:23 <arkeet> I'd just use a type for that
12:14:24 <mm_freak> ratm: well, there is the HTTP 1.0 and 1.1 standard
12:14:24 <mm_freak> ratm: but it only gives you a format, so any time you can express with that format is valid
12:14:31 <briennetheblue> > over biplate length [[["test"]]]
12:14:32 <lambdabot>   Couldn't match type `[a0]' with `GHC.Types.Int'
12:14:32 <lambdabot>  Expected type: [a0] -> [a0...
12:14:36 <arkeet> like a rose tree
12:14:41 <briennetheblue> is it possible to do something like that?
12:14:48 <edwardk> brienne: biplate can't do type changing assignment
12:14:59 <briennetheblue> oh ok
12:15:09 <briennetheblue> that's what i was trying to do
12:15:13 <edwardk> briennetheblue: there is no viable type i could give the expression
12:15:55 <briennetheblue> it's impossible then?
12:16:23 <arkeet> > over (traverse.traverse.traverse) length [[["test"]]]
12:16:24 <lambdabot>   [[[4]]]
12:16:26 <arkeet> uh
12:17:04 <briennetheblue> yup
12:17:15 <briennetheblue> i just didn't want to write traverse.traverse.traverse :)
12:17:45 <briennetheblue> i should probably just make a newtype then
12:18:14 <arkeet> or give another name to traverse.traverse.traverse if you're using it a bunch
12:18:53 <briennetheblue> that's probably nicer actually, so i don't have to wrap and unwrap
12:19:08 <arkeet> assuming you know how many levels you have in advance.
12:23:34 <briennetheblue> :t zoom
12:23:41 <briennetheblue> :t (zoom)
12:23:41 <lambdabot> Zoom m n s t => LensLike' (Control.Lens.Internal.Zoom.Zoomed m c) t s -> m c -> n c
12:24:11 <donri> :t traverse.traverse.traverse
12:24:12 <lambdabot> (Applicative f, Traversable t, Traversable t1, Traversable t2) => (a -> f b) -> t (t1 (t2 a)) -> f (t (t1 (t2 b)))
12:32:07 <cubert_> Hi #haskell, what are some good graduate schools for functional programming in haskell, {type,category} theory, dependently typed programming in the US ?
12:33:28 <donri> cubert_: upenn maybe?
12:34:38 <cubert_> ah, because of benjamin pierce ?
12:36:15 <donri> cubert_: i don't know who that is :) i'm thinking all or most of the recent haskell papers relevant to dependent types have had authors from upenn
12:36:42 <Twey> Benjamin Pierce wrote TAPL
12:36:45 <donri> notably byorgey, sweirich, goldfire
12:37:14 <derdon> uhm. do I see it correctly that there is no online documentation of QuickCheck? I have to download the source and compile the API docs myself and don't get some official user guide?
12:37:16 <jfischoff> Oregon I think ...
12:37:20 <byorgey> cubert_: yes, come to upenn! =)
12:37:31 <donri> i totally sneaked in a highlight there
12:37:48 <Iceland_jack> derdon: The Chalmer's introduction to functional programming includes a *lot* of QuickCheck
12:37:49 <jfischoff> derdon: where are you looking?
12:37:52 <Twey> derdon: Umm, http://hackage.haskell.org/package/QuickCheck
12:38:05 <Iceland_jack> derdon: http://www.cse.chalmers.se/edu/year/2012/course/TDA452/FPLectures/Vid/
12:38:17 <donri> @where rwh has a chapter on quickcheck
12:38:18 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:38:40 <derdon> donri: thanks, I already have that page opened
12:38:44 <arkeet> derdon: API docs are on hackage
12:38:46 <Iceland_jack> I've personally found it to be the best introduction for (non-monadic) QuickCheck
12:38:47 <arkeet> yeah
12:39:07 <derdon> Twey: and which link should I follow then? I'm not interested in the API docs btw
12:39:27 <derdon> Iceland_jack: thanks, will take a look at it
12:39:29 <byorgey> cubert_: the sad fact is that there are not many grad schools in the US where you can find that particular combination of topics.  UPenn, Portland State, Iowa
12:40:09 <cubert_> byorgey: do you mind if I pm you?
12:40:14 <byorgey> cubert_: not at all
12:52:16 <boldmort> Hi
12:52:53 <brainacid> hello room
12:52:59 <johnw> 'ello
12:53:12 <brainacid> im having trouble figuring out chap2 of Real World Haskell
12:53:25 <brainacid> the exercise they ask me to do
12:54:09 <brainacid> i tried  similar recursion from the same chapter but no luck
12:54:10 <brainacid> i have no previous programming experience
12:54:29 <Iceland_jack> brainacid: Well what are you having problems with?
12:54:57 <brainacid> Iceland_jack, it ask me to create a function that prints the one before last
12:55:06 <Iceland_jack> yes
12:55:12 <monochrom> point at the exact location of the exercise. and show your actual code.
12:55:21 <mr-> brainacid: you may want to paste what you have already to lpaste.net/new/haskell
12:55:21 <brainacid> ok
12:55:28 <Iceland_jack> Can you make a function that returns the *last* element of a list?
12:57:07 <donri> @src last
12:57:08 <lambdabot> last [x]    = x
12:57:08 <lambdabot> last (_:xs) = last xs
12:57:08 <lambdabot> last []     = undefined
12:57:58 <donri> oh wait this is for an exercise? ignore me :P
12:58:13 <Iceland_jack> :)
12:58:36 <Iceland_jack> brainacid: Having seen the definition of ‘last’, are you closer to being able to defining a function that returns the penultimate element?
12:58:45 <brainacid> http://pastie.org/8407349
12:59:43 <brainacid> Iceland_jack, honestly im totally frozen
12:59:53 <Iceland_jack> ok, don't worry
12:59:59 <monochrom> where is the recursion?
13:00:04 <Iceland_jack> does this definition make sense:
13:00:05 <Iceland_jack> @src head
13:00:05 <lambdabot> head (x:_) = x
13:00:05 <lambdabot> head []    = undefined
13:00:15 <whitedawg> Book doesn't cover pattern matching just yet though
13:00:32 <Iceland_jack> It doesn't?
13:00:40 <brainacid> yeah thats what throws me off...it only has covered very basic stuff
13:00:49 <arkeet> pattern matching is pretty basic =(
13:00:51 <brainacid> and it dont have a cheat sheet with answers
13:00:56 <monochrom> drop 2 [a, b, c, d, e, f, g] = [c, d, e, f, g], do you know this? your job will not involve drop, trust me.
13:01:00 <Iceland_jack> brainacid: Well OK, let's think a little outside of the box :)
13:01:02 <whitedawg> Its introduced a few chapters later
13:01:14 <brainacid> is my code remotely close?
13:01:15 <Iceland_jack> brainacid: Do you know how to get the *second* element of a list?
13:01:29 <Iceland_jack> It's not really the right approach, no
13:01:31 <brainacid> drop 1 [1,2,3]
13:01:37 <Iceland_jack> > drop 1 [1,2,3]
13:01:38 <lambdabot>   [2,3]
13:01:39 <arkeet> that's a list, not an element
13:01:45 <Iceland_jack> [2,3] is not the second element of [1,2,3]
13:01:52 <Iceland_jack> We want 2
13:02:04 <brainacid> snd [1,2,3]
13:02:10 <Iceland_jack> [1,2,3] is not a tuple
13:02:20 <brainacid> ok
13:02:22 <brainacid> :C
13:02:27 <Iceland_jack> Let me give you a hint
13:02:31 <arkeet> :c
13:02:37 <Iceland_jack> the first element of a list is called the ‘head’
13:02:51 <brainacid> head
13:02:53 <brainacid> tail
13:02:55 <briennetheblue> ha that question on rwh has 114 comments
13:03:16 <brainacid> briennetheblue, i downloaded the book .. cant see comments
13:03:33 <Iceland_jack> Well brainacid, how do you get the first element of the list?
13:03:45 <Iceland_jack> ??? [1,2,3] ⇒ 1
13:03:56 <brainacid> Iceland_jack, take 1 [1,2,3]
13:03:59 <Iceland_jack> no
13:04:05 <Iceland_jack> > take 1 [1,2,3]
13:04:06 <lambdabot>   [1]
13:04:07 <arkeet> :t take 1
13:04:07 <monochrom> ok, brainacid, I see the point of the exercise, you just have to combine existing functions from Prelude, you don't have to recurse yourself, or even use pattern matching
13:04:07 <lambdabot> [a] -> [a]
13:04:27 <arkeet> use the types
13:04:30 <Iceland_jack> brainacid: take and drop give you sublists, we want elements
13:04:36 <brainacid> monochrom, i kind of thought that at first but then i over complicated
13:04:56 <Iceland_jack> [1] is not an element of [1,2,3]; 1, 2 and 3 are
13:04:56 <brainacid> Iceland_jack, I dont then
13:05:02 <brainacid> wow this simple stuff is hard
13:05:03 <Iceland_jack> OK, you use ‘head’
13:05:05 <Iceland_jack> > head [1,2,3]
13:05:06 <lambdabot>   1
13:05:18 <brainacid> im on ghci as well
13:05:24 <monochrom> consider init
13:05:39 <brainacid> :type head
13:05:45 <briennetheblue> init hasn't been mentioned i don't think
13:05:51 <arkeet> don't consider init =(
13:05:57 <brainacid> last does the same
13:06:03 <Iceland_jack> brainacid: Now you know how to get the first element of a list (head), now combine that with ‘drop’ to get the second element of a list
13:06:05 <brainacid> last :: [a] -> a
13:06:23 <Iceland_jack> ??? [1,2,3,4] ⇒ 2
13:06:25 <monochrom> ok, then consider take
13:06:41 <brainacid> latsbutone xs = head (drop 1 xs)
13:06:51 <arkeet> oh, I guess you could
13:07:02 <arkeet> that's the second element, not the second last
13:07:09 <Iceland_jack> brainacid: That's not ‘lastbutone’ but rather second element
13:07:09 <monochrom> head (drop 1 xs) gives the second, not the second last
13:07:21 <arkeet> there seems to be an echo in here.
13:07:27 <Iceland_jack> But brainacid, now you just need one thing to solve the puzzle
13:07:58 <arkeet> the chapter talks about recursion.
13:08:50 <brainacid> mmm
13:08:55 * brainacid ponders
13:09:18 <arkeet> so maybe here's one way to approach it:
13:09:21 <Iceland_jack> brainacid: In an odd way, getting the second element of a list is the ‘reverse’ of getting the second-to-last element of a list
13:09:23 <arkeet> first, what do you do when the length is exactly 2?
13:09:36 <arkeet> how can you use that to help you when the list is longer than 2?
13:09:36 <kenkku> brainacid: don't worry, the exercise looks pretty hard to solve with the information you've given so far
13:09:46 <Iceland_jack> Yes the exercise is a bad one imo
13:09:54 <arkeet> I agree I guess sort of
13:09:54 <Iceland_jack> if they haven't covered pattern matching
13:10:06 * brainacid worries about haskell stress
13:10:22 * arkeet thinks LYAH is a better intro to haskell than RWH
13:10:28 * Iceland_jack agrees with arkeet 
13:10:28 <johnw> arkeet++
13:10:35 <johnw> MUCH better
13:10:35 <brainacid> latsbutone xs = tail (drop 1 xs)
13:10:57 <kenkku> I would recommend looking at learn you a haskell as well
13:10:59 <arkeet> wrong type again
13:11:02 <arkeet> @where lyah
13:11:02 <lambdabot> http://www.learnyouahaskell.com/
13:11:11 <kenkku> what's needed is a MOOC with lots of tiny exercises :P
13:11:17 <kenkku> but that doesn't exist, as far as I know
13:11:35 <brainacid> butone xs = tail (drop 0 xs)
13:11:38 <whitedawg> brainacid: try to just tail down the list? Start by writing your own 'last' function
13:11:44 <Nimatek> Reimplementing Prelude is the usual set of tiny exercises.
13:11:54 <monochrom> read the comments on that exercise. a lot of readers have trouble guessing what the authors intend, too
13:12:08 <kenkku> brainacid: drop 0 xs is the same as xs ;)
13:12:13 <Iceland_jack> brainacid: I feel like you're just typing something hoping it will fit
13:12:19 <kenkku> brainacid: if you drop 0 elements from a list, you get the same list back
13:12:33 <Iceland_jack> I actually recommend looking at LYAH
13:12:33 <Iceland_jack> @where lyah
13:12:33 <lambdabot> http://www.learnyouahaskell.com/
13:12:42 <brainacid> Iceland_jack, Prelude> let butone xs = tail (drop 0 xs)
13:12:43 <brainacid> Prelude> butone [1,2,3]
13:12:43 <brainacid> [2,3]
13:12:51 <brainacid> lol
13:12:55 <brainacid> sorry guys
13:13:07 <Iceland_jack> brainacid: don't apologize, is [2,3] what you wanted?
13:13:15 <brainacid> its just frustrating not figuring out the second exercise...i worry about the rest of the book
13:13:24 <arkeet> the commenters don't like that exercise either!
13:13:27 <arkeet> see http://book.realworldhaskell.org/read/types-and-functions.html
13:13:34 <brainacid> well...i think its last but one
13:13:35 <arkeet> and look at the comments on the exercise
13:13:44 <monochrom> essentially one approach is to use the null-head-tail triumvirate (because pattern matching not taught yet) and do your own recursion
13:13:49 <Iceland_jack> Please don't worry about this exercise brainacid, I think it's a pretty bad one given the information
13:13:53 <arkeet> ^
13:14:02 <brainacid> alright guys
13:14:08 <brainacid> thanks a lot for the support
13:14:15 * brainacid feels better but leg still hurts
13:14:17 <xico> i am trying to define a scripting mechanism, in which the scripts can define a number of custom parameters. i need to be able to access those parameters. for now i have implemented that as a Map String Double. unfortunately, it is quite tedious to write in the scripts
13:14:21 <lpaste> xico pasted “Loosing the types” at http://lpaste.net/94349
13:14:21 <kenkku> brainacid: I would recommend Learn You A Haskell
13:14:27 <monochrom> another approach is "but I already learned haskell elsewhere" and use pattern matching anyway :)
13:14:45 <Iceland_jack> > reverse [1,2,3,4,5] -- brainacid: does this help?
13:14:46 <lambdabot>   [5,4,3,2,1]
13:14:46 <brainacid> kenkku, i have it as well on my disk
13:14:57 <donri> brainacid: well you're close. drop 1 makes the last element the "last but one", and tails get the whole list minus the head. remember "last"? :)
13:14:58 <xico> also, i am for now loosing the types (everything is double). are there good ways to define that?
13:15:18 <donri> oh wait that's not what drop does :P
13:15:49 <arkeet> donri: no, drop 1 doesn't do that. :P
13:15:50 <brainacid> Iceland_jack, huh?
13:15:52 <Nimatek> > last (init [1..10])
13:15:53 <lambdabot>   9
13:16:12 <c_wraith> xico: unless those are only sketches, they don't belong in IO.  Just because some part of your code does use IO doesn't mean that you should write everything possible as using IO.
13:16:17 <Iceland_jack> brainacid: If you reverse a list, the task of finding the penultimate element becomes finding the *second* element
13:16:44 <brainacid> right
13:16:51 <c_wraith> xico: as for how to make it polymorphic, you need to modify your Environment type to be something more like type Environment a = Map String a
13:16:52 * arkeet really wouldn't worry about that exercise
13:17:06 <arkeet> c_wraith: but then you can't have an environment with different types of values
13:17:09 <donri> yeah init does what i thought drop 1 would do
13:17:13 <xico> c_wraith: well, i am using an io random number generator. those are sketchy examples of user-defined scripts, which i load through the ghc api, so i am assuming they may need io
13:17:23 <Iceland_jack> brainacid: so it will become
13:17:23 <Iceland_jack>     lastButOne xs = ??? (reverse xs)
13:17:23 <Iceland_jack> where ??? gets the second element, no?
13:17:31 <c_wraith> xico: but those functions *don't* need IO, so they shouldn't say they do.
13:17:36 <c_wraith> xico: that's the important difference
13:17:55 <c_wraith> xico: the whole point of having an IO type is so that you can leave it out everywhere possible.
13:17:58 <xico> c_wraith: similarly, i can define Environment a, but since i am loading through the ghc api, that would make it difficult to compile no?
13:18:01 <brainacid> take 1
13:18:29 <Iceland_jack> brainacid: ‘take 1’ does not give you the second element
13:18:40 <Iceland_jack> > take 1 [1,2,3,4,5]
13:18:41 <lambdabot>   [1]
13:18:46 <brainacid> dmn
13:18:47 <c_wraith> xico: anything you load through the ghc api needs to be unsafeCoerced to something known at compile time anyway.  It turns out to not be an issue.
13:18:49 <brainacid> !!!
13:19:01 <arkeet> mauke: what did you do =((
13:19:01 <Iceland_jack> brainacid: The answer was posted above :)
13:19:08 <Iceland_jack> it uses drop and head
13:19:15 <c_wraith> xico: (though I strongly recommend a library like hint to wrap that up in a slightly safer way for you)
13:20:06 <xico> c_wraith: i guess you are absolutely right, i should check the type of the functions in the caller, and call them with io only if necessary. it would make the code nicer too.
13:22:32 <donri> Nimatek's solution is nicer though
13:22:34 <brainacid> head (drop 1(reverse [1,2,3,4]))
13:22:45 <monochrom> good
13:23:07 <Iceland_jack> > head (drop 1 (reverse [1,2,3,4])) -- You can test it here
13:23:08 <lambdabot>   3
13:23:11 <Iceland_jack> yes :) good job
13:23:26 <brainacid> head gives me 4
13:23:30 <donri> > last . init $ [1..4]
13:23:31 <lambdabot>   3
13:23:31 <arkeet> @where dropFromEnd
13:23:32 <lambdabot> see `sneaky'
13:23:35 <arkeet> @where sneaky
13:23:35 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
13:23:36 <brainacid> but when i drop 1 it gives me the 3
13:23:39 <Iceland_jack> as Nimatek spoiled earlier you can also use last and init
13:24:00 <Iceland_jack> donri: (do avoid (.) and ($) since they haven't been introduced yet I believe)
13:24:03 <kenkku> nice job guys, keep feeding the new guy solutions he won't understand :D
13:24:34 <Iceland_jack> brainacid: ‘head’ of what gives you 4?
13:24:37 <brainacid> :c
13:24:40 <brainacid> i wouldof never guesses reverse
13:24:46 <donri> brainacid: https://s3.amazonaws.com/lyah/listmonster.png :)
13:24:57 <brainacid> head (reverse [1,2,3,4])
13:25:08 <Iceland_jack> brainacid: there is no ‘drop 1’ there
13:25:10 <kenkku> brainacid: that's because it wasn't introduced yet and this is not the way it's supposed to be solved at this point
13:25:17 <brainacid> u asked for the 4
13:25:21 <brainacid> head (drop 1(reverse [1,2,3,4]))
13:25:25 <donri> brainacid: may want to read LYAH before RWH http://learnyouahaskell.com/starting-out#an-intro-to-lists
13:25:26 <brainacid> that gives me 3
13:25:38 <kenkku> it's a hard task, switch to learn you a haskell, please
13:25:49 <brainacid> ok
13:25:55 <brainacid> i will start today lyah
13:25:58 <brainacid> thanks guys
13:25:59 <arkeet> =)
13:26:04 <brainacid> this group is awesome
13:26:06 <kenkku> even though real world haskell sounds better due to the "real world", I would say it's not :P
13:26:12 <Iceland_jack> Where do I ask you for 4?
13:26:26 <arkeet> <Iceland_jack> brainacid: ‘head’ of what gives you 4?
13:26:30 <kenkku> and besides, who wants the real world when you work towards a greater good?
13:26:30 <Eduard_Munteanu> @hoogle m a -> Bool -> m a
13:26:31 <lambdabot> Data.Sequence (|>) :: Seq a -> a -> Seq a
13:26:31 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
13:26:31 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
13:26:39 <Iceland_jack> arkeet: That's not where I ask him for 4, I'm asking him
13:26:40 <Iceland_jack> *them
13:26:42 <heatsink> > quickCheck $ \x -> x == transpose (transpose x)
13:26:43 <lambdabot>   <IO ()>
13:26:45 <Eduard_Munteanu> Hrmpf... there should be a 'flip when'.
13:26:48 <arkeet> I think that's what he was answering.
13:26:56 <Iceland_jack> arkeet: it folloes:
13:26:57 <donri> heatsink: use @check
13:26:57 <Iceland_jack>     <brainacid> head gives me 4
13:27:01 <arkeet> Eduard_Munteanu: there is -- it's called "flip when"
13:27:04 <heatsink> oh ok
13:27:04 <Iceland_jack> *follows
13:27:04 <Eduard_Munteanu> doSomething `when` conditionIsMet    seems nice.
13:27:06 <briennetheblue> @help
13:27:06 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:27:12 <heatsink> @check \x -> x == transpose (transpose x)
13:27:13 <briennetheblue> @list
13:27:15 <monochrom> it is faithful to its name. the real world is tough. you are never given necessary information.
13:27:16 <lambdabot>   *** Failed! Falsifiable (after 2 tests):
13:27:17 <lambdabot>  [[]]
13:27:17 <lambdabot> What module?  Try @listmodules for some ideas.
13:27:25 <arkeet> when condition $ doSomething
13:27:28 <briennetheblue> @help list
13:27:28 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
13:28:09 <brainacid> see u guys later hopefully
13:28:09 <monochrom> every task is ill-posed and every boss expects that you have already learned X before you have learned X.
13:28:12 <Iceland_jack> brainacid: http://learnyouahaskell.com/introduction
13:28:15 <Iceland_jack> You too brainacid
13:28:15 <brainacid> thanks a loy
13:28:16 <Eduard_Munteanu> arkeet: using it infix shaves off some parens and doesn't need a ($). For some reason I find '$' ugly. :/
13:28:18 <brainacid> lot
13:28:24 <stephenmac7> I'm having an issue with with 'Writer'
13:28:27 <brainacid> i truly appreciate it
13:28:34 <stephenmac7>     Not in scope: data constructor `Writer'
13:28:34 <stephenmac7>     Perhaps you meant `WriterT' (imported from Control.Monad.Writer)
13:28:36 <Hafydd> > transpose . transpose $ [[]]
13:28:37 <lambdabot>   []
13:28:41 <Iceland_jack> no problem brainacid, stick to it :)
13:28:49 <brainacid> i truly appreciate it a lot...i will!!! yes indeed
13:28:53 <stephenmac7> Despite the fact that I'm using the LYAH example
13:28:58 <stephenmac7> Word-for-word
13:29:02 <Iceland_jack> stephenmac7: LYAH uses an older version of that library
13:29:12 <stephenmac7> Iceland_jack: So now what do I do?
13:29:21 <sipa> can you paste the code somewhere?
13:29:22 <Iceland_jack> What is the function?
13:29:30 <stephenmac7> logNumber x = Writer (x, ["Got number: " ++ show x])
13:29:33 <Iceland_jack> You probably want ‘writer’ instead of the value constructor Writer
13:29:34 <Iceland_jack> yes
13:29:37 <arkeet> stephenmac7: use writer instead
13:29:49 <stephenmac7> That worked
13:30:06 <arkeet> mtl-2 changed some stuff around
13:30:12 <monochrom> look at the FFI chapter for example. it does not teach FFI at all. it sketches just the most trivial factoids of FFI and then jump right into a highly advanced use.
13:30:13 <stephenmac7> Is there some new fancy function called writer that just does what the contructor, Writer did before?
13:30:13 <arkeet> so that Writer is a type synonym for another thing
13:30:26 <arkeet> stephenmac7: yes exactly
13:30:36 <arkeet> (except it's more general, since it works with any MonadWriter)
13:30:44 <bennofs> stephenmac7: the same also applies to reader and state iirc
13:30:50 <stephenmac7> Why would you break backwards compatibility?
13:30:57 <arkeet> because it's allowed to.
13:31:03 <arkeet> major version number change!
13:31:07 <stephenmac7> Ah
13:31:20 <monochrom> I would break backwards compatibility to move forward.
13:31:25 <Iceland_jack> stephenmac7: As a side-note you can achieve the same with:
13:31:25 <Iceland_jack>     do tell ["Got number: " ++ show x]
13:31:26 <Iceland_jack>        return x
13:31:42 <arkeet> :t (<$)
13:31:42 <lambdabot> Functor f => a -> f b -> f a
13:31:46 <stephenmac7> :t tell
13:31:47 <lambdabot> MonadWriter w m => w -> m ()
13:31:47 <arkeet> x <$ tell ...
13:31:55 <Iceland_jack> arkeet: One step at a time :)
13:31:58 <arkeet> fine fine
13:32:19 <arkeet> tell x = writer (x, ())
13:32:24 <arkeet> er
13:32:27 <arkeet> writer (x, mempty)
13:32:32 <Iceland_jack> stephenmac7: I also find it funnier when you write “do tell” in your code :)
13:32:35 <arkeet> no
13:32:37 <arkeet> writer ((), x)
13:32:37 <arkeet> there
13:32:37 <stephenmac7> :D
13:32:38 <arkeet> haha
13:33:29 <Hafydd> > do not otherwise
13:33:31 <lambdabot>   False
13:33:32 <monochrom> to a large extent, RWH is also a faithful representation of this channel. look at how people flock to flood you with advanced information
13:33:44 <Iceland_jack> haha
13:33:48 <Iceland_jack> sad and true
13:33:58 <Iceland_jack> And then it always ends with lenses
13:34:13 <xico> is there an option for modules without a "module ModName" line not to have a "main" function?
13:34:40 <edwardk> > do otherwise
13:34:41 <lambdabot>   True
13:34:43 <mauke> xico: o_O
13:34:48 <kenkku> monochrom: indeed
13:35:07 <kenkku> monochrom: I hope people could restrain themselves and not go ahead of things
13:35:30 <kenkku> but it's understandable, I'm sure everyone here is excited about haskell and want to both help newcomers and show their knowledge
13:35:48 * Iceland_jack sometimes thinks Haskell should be split up into normal Haskell and Haskell: Academic Version
13:35:50 <mauke> I just want to scare them off
13:35:54 <monochrom> I KISS. I am a refreshing desert in the oasis of abundant advanced information
13:36:17 <kenkku> mauke: right, to keep haskell UG enough ;)
13:36:21 <Cale> xico: You don't need to define main, but the module will implicitly be named Main if you don't explicitly declare its name with a module declaration.
13:36:27 <kenkku> nobody likes mainstream languages. yuch
13:36:44 <Cale> xico: So, pretty much the only use for such a module will be to load it into ghci
13:36:53 <stephenmac7> I don't get the Writer instance
13:36:54 <stephenmac7> (Writer (x,v)) >>= f = let (Writer (y, v')) = f x in Writer (y, v `mappend` v')
13:37:01 <stephenmac7> Especially the
13:37:07 <stephenmac7> let (Writer (y,v')) = fx part
13:37:10 <Iceland_jack> stephenmac7: Do you get the /purpose/ of it?
13:37:16 <stephenmac7> Yes
13:37:21 <stephenmac7> Just not how it works
13:37:25 <mauke> stephenmac7: do you know about destructuring binds?
13:37:36 <donri> i sometimes want a non-module, non-Main like xico, just to type check some code
13:37:40 <stephenmac7> mauke: If I do, it's not by that name?
13:37:42 <Cale> stephenmac7: Well, what type does f x have?
13:37:42 <donri> it's not completely crazy
13:37:48 <monochrom> stephenmac7: general patterns are allowed in let. for example "let (x,y) = joy in ..."
13:37:51 <mauke> stephenmac7: let PATTERN = EXPR
13:37:57 <sipa> it applies f to x, and the result is a Writer, so the (Writer (y, v')) = ... destructs it by pattern matches
13:38:04 <Iceland_jack> stephenmac7 definitely does know about them
13:38:21 <stephenmac7> Cale: It has the type of the function's output
13:38:26 <sipa> giving you access to the two elements of the Writer value, calling them y and v'
13:38:35 <Cale> stephenmac7: Which is what? :)
13:38:41 <stephenmac7> Cale: That's my problem
13:38:57 <sipa> :t (>>=)
13:38:58 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:38:59 <Cale> okay, let's specialise the general type of (>>=) for Writer
13:38:59 <stephenmac7> It looks like it would be a normal value, not a Writer
13:39:15 <Iceland_jack> if ‘f x’ is Writer (5, "testing") then
13:39:16 <Iceland_jack>      Writer (y, v') = f x
13:39:16 <Iceland_jack> binds y to 5 and v' to "testing"
13:39:16 <Cale> (>>=) :: (Monad m) => m a -> (a -> m b) -> m b
13:39:40 <Cale> and in this case, we're making Writer w an instance of Monad, based on some Monoid w
13:39:45 <stephenmac7> Iceland_jack: The problem is, I don't get why 'f x' is Writer(5, "testing") and not 5
13:39:58 <Cale> So: (>>=) :: Writer w a -> (a -> Writer w b) -> Writer w b
13:40:00 <Cale> yes?
13:40:04 <stephenmac7> yes
13:40:05 <Iceland_jack> stephenmac7: Because ‘f’ has type (a → m b) for your Writer monad
13:40:25 <stephenmac7> Iceland_jack: Ah
13:40:28 <Cale> So, if we write x >>= f, then x :: Writer w a, and f :: a -> Writer w b here
13:40:40 <stephenmac7> I think I missed that detail
13:40:42 <arkeet> please don't use x for two different things.
13:41:04 <Cale> I'm going to rewrite the whole definition in a way which hopefully makes slightly more sense
13:41:10 <stephenmac7> Cale: Okay
13:41:34 <Cale> So, recall that runWriter :: Writer w a -> (a,w)
13:41:51 <stephenmac7> Yes
13:42:01 <Cale> So that in this case, we'll have runWriter x :: (a,w)
13:42:18 <Cale> The definition you gave uses pattern matching instead of applying runWriter
13:42:29 <Cale> But let's use runWriter, because I think it'll read better
13:42:32 <Cale> so...
13:42:54 <Cale> x >>= f = let (r,u) = runWriter x ...
13:42:59 <arkeet> you'll still want to match on the pair though
13:43:02 <Cale> Now r :: a, and u :: w
13:43:05 <Cale> yes
13:43:05 <stephenmac7> Right, I see
13:43:28 <Tuplanolla> How can I find the first floating point number that's smaller than the given one?
13:43:30 <Cale> and so now we can apply f to this initial result of running x, namely r
13:43:40 <Tuplanolla> Using pred doesn't work.
13:43:42 <stephenmac7> Oh, I get it
13:43:43 <stephenmac7> Thank you, I've got it now
13:43:51 <Cale> x >>= f = let (r,u) = runWriter x; (r',v) = runWriter (f r) ...
13:44:07 <Cale> and we'll get a second result r' and some other monoid value v
13:44:08 <Iceland_jack> stephenmac7: And the usage makes sense?
13:44:08 <Iceland_jack> > runWriter (do tell "hello"; tell " "; writer (5, "world"))
13:44:09 <lambdabot>   (5,"hello world")
13:44:24 <stephenmac7> Not in the context of do, it doesn't (yet)
13:44:31 <Iceland_jack> OK
13:44:40 <stephenmac7> For some reason, >>= is much easier to read for me than do notation
13:44:41 <arkeet> well, you just need to see how do desugars
13:44:46 <arkeet> @undo runWriter (do tell "hello"; tell " "; writer (5, "world"))
13:44:46 <lambdabot> runWriter (tell "hello" >> tell " " >> writer (5, "world"))
13:45:00 <Cale> So, then we have to think a bit about what to produce as a result, but we want to combine the two monoid values using mappend, and produce the result of the last action performed
13:45:13 <Cale> and we do that by pairing them together and applying Writer
13:45:23 <Iceland_jack> But do you intuitively get what it's doing stephenmac7?
13:45:30 <Cale> x >>= f = let (r,u) = runWriter x; (r',v) = runWriter (f r) in Writer (r', mappend u v)
13:45:54 <Tuplanolla> > pred (1.0 :: Float)
13:45:57 <lambdabot>   0.0
13:45:59 <relrod> When doing `cabal init`, cabal will automatically put dependencies in the 'build-depends' field. If dependencies are added or changed, is there any way to regenerate this list without regenerating the entire .cabal file?
13:46:13 <stephenmac7> Cale: Got that, so if v is [1] and u is [5] then snd (x >>= f) becomes [1,5]
13:46:13 <Cale> So, this code in do notation is the equivalent of:  do r <- x; f r
13:46:26 <stephenmac7> Iceland_jack: Writer itself, yes
13:46:38 <stephenmac7> Your code with the 'tell' function in it, no
13:46:44 <stephenmac7> :t tell
13:46:45 <lambdabot> MonadWriter w m => w -> m ()
13:46:51 <stephenmac7> Still don't get what tell is
13:46:57 <Cale> um, other way around perhaps
13:46:59 <Iceland_jack> @src tell
13:46:59 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:47:05 <stephenmac7> Cale: But the same idea
13:47:09 <arkeet> tell is a class method
13:47:37 <arkeet> @where src
13:47:37 <lambdabot> The fixed database for the `src' lambdabot command is at <http://code.haskell.org/lambdabot/State/source>
13:47:58 <Cale> Well, the point of this monad is to provide something like logging, or otherwise give our computation a way to emit results which are then collected up using the monoid operation
13:48:05 <Tuplanolla> Is it even possible to find the first floating point number that's smaller than the given one?
13:48:14 <arkeet> yes
13:48:20 <stephenmac7> Okay, I think I've got it
13:48:24 <Cale> So, we'll want a Writer w computation which corresponds to writing some value of type w
13:48:31 <stephenmac7> Seems like it will be much easier to understand than reader
13:48:43 <Iceland_jack> stephenmac7: Didn't we already cover reader kind of :)
13:48:43 <Cale> tell u = Writer ((), u)
13:48:53 <stephenmac7> Iceland_jack: Kind of :D
13:48:53 <Iceland_jack> Remembder the monad instance for ((→) r)?
13:49:01 <Iceland_jack> *Remember
13:49:08 <stephenmac7> Iceland_jack: Not, just the Applicative one
13:49:11 <stephenmac7> *No
13:49:12 <Iceland_jack> Hm right
13:49:18 <Cale> Tuplanolla: It is possible, but that's not what pred does (clearly)
13:49:23 <stephenmac7> We really spoke more about applicatives than monads
13:49:33 <Iceland_jack> Well the idea is very simple
13:49:38 <stephenmac7> Because that's where I had the issues. It was just mentioned that readers are similar
13:49:47 <Cale> Tuplanolla: honestly, I'm not entirely sure why pred and succ exist as methods of Enum (for that matter, toEnum and fromEnum are a little out of place there too)
13:49:53 <Iceland_jack> There is some environment that doesn't change that everything has access to
13:49:58 <arkeet> Tuplanolla: for a positive one, you could unsafeCoerce to an integer of the same size and subtract one =(
13:49:58 <Iceland_jack> kind of like a mutable global variable
13:50:14 <stephenmac7> The environment varible, yes?
13:50:18 <Tuplanolla> That should be built in.
13:50:18 <stephenmac7> *variable
13:50:19 <Cale> > runWriter (do tell [1], tell [2,3]; return 4)
13:50:20 <lambdabot>   <hint>:1:35: parse error on input `;'
13:50:21 <arkeet> :t decodeFloat
13:50:21 <lambdabot> RealFloat a => a -> (Integer, Int)
13:50:26 <arkeet> you could probably do it with this too maybe
13:50:30 <Cale> > runWriter (do tell [1]; tell [2,3]; return 4)
13:50:31 <Tuplanolla> Floating point numbers are always enumerable.
13:50:32 <lambdabot>   (4,[1,2,3])
13:50:45 <Cale> stephenmac7: ^^ does that code I just wrote make sense?
13:50:48 <arkeet> hm, do we have a lens for that?
13:51:05 <xico> i would like to replace two import lines "import Prelude hiding(lookup); import MyModule" by a single "import MyModule". is there a way to do that? i tried re-exporting Prelude from MyModule, hiding lookup, but it does not work.
13:51:29 <Iceland_jack> > runReader (do x ← ask; return ("The (global number)^2 is " ++ show (x^2))) 5 -- stephenmac7
13:51:30 <stephenmac7> Cale: Yes
13:51:30 <lambdabot>   "The (global number)^2 is 25"
13:51:35 <Eduard_Munteanu> If I forkIO and hGetContents a handle, when said thread finishes, is the handle fully closed? Say the thread simply writes the contents to an MVar which isn't forced.
13:52:00 <stephenmac7> @undo do x ← ask; return ("The (global number)^2 is " ++ show (x^2))
13:52:00 <lambdabot> <unknown>.hs: 1: 7:Illegal character ''\134''
13:52:19 <Iceland_jack> @undo runReader (do x <- ask; return ("The (global number)^2 is " ++ show (x^2))) 5
13:52:20 <lambdabot> runReader (ask >>= \ x -> return ("The (global number)^2 is " ++ show (x ^ 2))) 5
13:52:28 <arkeet> @let float :: RealFloat a => Iso' a (Integer,Int); float = iso decodeFloat (uncurry encodeFloat)
13:52:29 <lambdabot>  Defined.
13:52:41 <arkeet> > 2.0 & float._1 +~ 1
13:52:42 <lambdabot>   Ambiguous occurrence `float'
13:52:42 <lambdabot>  It could refer to either `L.float', defined a...
13:52:43 <Tuplanolla> I'm testing how Haskell works for massive parallel computing and so far it's really disappointing. There's language extensions and unsafe io everywhere.
13:52:46 <arkeet> :t float
13:52:46 <lambdabot>     Ambiguous occurrence `float'
13:52:47 <lambdabot>     It could refer to either `L.float',
13:52:47 <lambdabot>                              defined at /home/lambdabot/.lambdabot/State/L.hs:142:1
13:52:49 <arkeet> =(
13:52:51 <arkeet> @undefine
13:52:51 <lambdabot> Undefined.
13:53:00 <arkeet> @let float' :: RealFloat a => Iso' a (Integer,Int); float' = iso decodeFloat (uncurry encodeFloat)
13:53:01 <lambdabot>  Defined.
13:53:04 <arkeet> > 2.0 & float'._1 +~ 1
13:53:04 <Cale> Tuplanolla: unsafe IO everywhere?
13:53:05 <Eduard_Munteanu> Tuplanolla: what language extensions?
13:53:07 <lambdabot>   2.0000000000000004
13:53:09 <Cale> Tuplanolla: What do you mean?
13:53:10 <arkeet> > 2.0 & float'._1 -~ 1
13:53:13 <lambdabot>   1.9999999999999996
13:53:18 <stephenmac7> Iceland_jack: I have got it :D
13:53:19 <Cale> Tuplanolla: Most user code shouldn't need unsafe IO.
13:53:21 <arkeet> hm, is that actually proper
13:53:33 <Iceland_jack> stephenmac7: See, the Reader monad is quite simple
13:53:36 <stephenmac7> Thanks, now the reader section of LYAH will be easy reading
13:53:37 <Tuplanolla> BangPatterns and ForeignPtrs for example.
13:53:41 <stephenmac7> Much simpler than <*>
13:53:42 <arkeet> yeah that's wrong.
13:53:53 <stephenmac7> :t (<*>)
13:53:54 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:54:04 <xico> (okay, i can re-export Prelude by removing the implicit prelude)
13:54:14 <stephenmac7> Anyway, thanks
13:54:17 <Eduard_Munteanu> Tuplanolla: BangPatterns isn't controversial or anything. Besides *most* Haskell code uses *some* extensions.
13:54:17 <Cale> BangPatterns are a trivial extension to implement, and ForeignPtrs are neither unsafe nor an extension.
13:54:18 <stephenmac7> Iceland_jack: Thanks for all your help
13:54:26 <Iceland_jack> No problem stephenmac7
13:54:26 <Iceland_jack>  
13:54:37 <Cale> (BangPatterns are also quite safe)
13:54:51 <arkeet> BangPatterns is syntactic sugar.
13:54:58 <arkeet> basically.
13:55:13 <stephenmac7> @undo do a <- logNumber 3; b <- logNumber 5; return (a*b)
13:55:13 <lambdabot> logNumber 3 >>= \ a -> logNumber 5 >>= \ b -> return (a * b)
13:55:21 <Iceland_jack> stephenmac7: So for a compiler, you need to generate code (Writer), you may need type information that doesn't change (Reader) and your current context that does change (State)
13:55:27 <Cale> Yeah, all that BangPatterns do is add some applications of seq to the right side of the equation or case they're involved in.
13:55:29 <arkeet> f !x = ...   =   f x = x `seq` ...
13:55:54 <stephenmac7> Iceland_jack: Ah, is that what it is intended for?
13:56:01 <Iceland_jack> No, it's just a possible use case
13:56:07 <stephenmac7> I see.
13:56:08 <Cale> Well, that's a bit of an oversimplification, they can turn let into case occasionally.
13:56:16 <arkeet> sure.
13:56:16 <Iceland_jack> The Reader monad is nice for global configurations
13:56:18 <arkeet> but that's the idea.
13:56:20 <arkeet> using Writer with lists kinda sucks.
13:56:31 <stephenmac7> Well, I think state is in LYAH
13:56:39 <hpc> before bang patterns, the typical trick to do was f x | x `seq` False = undefined; | otherwise = whatever
13:57:00 <Cale> I still do that trick in fact.
13:57:00 <arkeet> cute
13:57:04 <Iceland_jack> rather than having to pass them manually:
13:57:04 <Iceland_jack>     someAction ∷ Configuration → Other → Parameters → IO ()
13:57:04 <Iceland_jack>     someAction conf = …
13:57:13 <Cale> That trick is also quite useful with trace
13:57:13 <arkeet> anyway, Writer [] kidna sucks because you end up with stuff like (([a] ++ [b]) ++ [c]) ++ [d] etc.
13:57:43 <Iceland_jack> Yes but [] is nice to use for pedagogical uses
13:57:47 <arkeet> > runWriter (tell a >> tell b >> tell c)
13:57:48 <lambdabot>   ((),(a <> b) <> c)
13:57:48 <gauthier_> I'm trying to figure out issue with zmq3-hs under windows (thread blocked indefinitely in an MVar operation) I've stuffed some Debug.Trace.trace statements and something really odd is happening
13:58:01 <arkeet> Iceland_jack: sure.
13:58:12 <arkeet> it would be nice to have a version that reassociated stuff for you though.
13:58:19 <Iceland_jack> Yes that's true
13:58:20 <Cale> f x | trace (unwords ["f", show x]) False = undefined; f ...
13:58:20 <arkeet> > runWriter (tell a >> tell b >> tell c >> return 10)
13:58:22 <lambdabot>   (10,((a <> b) <> c) <> mempty)
13:58:30 <gauthier_> the code seems to be run thrice
13:58:42 <Iceland_jack> would it be so crazy to make lists abstract in Haskell with something like Seq underneath
13:58:54 <arkeet> @let improve a = Endo (a <>); unimprove a = appEndo a mempty
13:58:54 <lambdabot>  Defined.
13:58:58 <quchen> hpc: Why not "| x `seq` True = ...?"
13:59:08 <stephenmac7> :t Endo
13:59:09 <arkeet> > runWriter $ tell (improve a) >> tell (improve b) >> tell (improve c) >> return 10
13:59:09 <lambdabot> (a -> a) -> Endo a
13:59:10 <lambdabot>   No instance for (GHC.Show.Show
13:59:10 <lambdabot>                     (Data.Monoid.Endo Debug....
13:59:13 <arkeet> oops./
13:59:18 <Cale> gauthier_: perhaps you could put the code on lpaste.net?
13:59:23 <arkeet> > second unimprove . runWriter $ tell (improve a) >> tell (improve b) >> tell (improve c) >> return 10
13:59:27 <lambdabot>   (10,a <> b <> c <> mempty)
13:59:43 <stephenmac7> @undo do tell "Something"
13:59:43 <lambdabot> tell "Something"
14:00:06 <hpc> quchen: not really clear in my example, but suppose you pattern-match on x after
14:00:10 <Iceland_jack> Also stephenmac7, I'd get used to the do-notation if I were you
14:00:16 <Cale> stephenmac7: The do notation is defined recursively like this:
14:00:19 <arkeet> > runWriter $ tell a >> return 1 >> return 2 >> return 3
14:00:20 <lambdabot>   (3,((a <> mempty) <> mempty) <> mempty)
14:00:26 <arkeet> > second unimprove . runWriter $ tell (improve a) >> return 1 >> return 2 >> return 3
14:00:30 <lambdabot>   (3,a <> mempty)
14:00:30 <hpc> better would perhaps be f x | x `seq` False = undefined; f Nothing = whatever; f (Just x) = whatever
14:00:30 <Cale> do { x } = x -- base case when only one statement
14:00:33 <arkeet> also gets rid of excess memptys.
14:00:36 <quchen> hpc: Ah okay
14:00:46 <stephenmac7> Iceland_jack: Probably a good idea
14:01:04 <Cale> do { v <- x; <stmts> } = x >>= \v -> do { <stmts> } -- when v is an unfailable pattern (e.g. a single variable)
14:01:26 <Cale> do { let { <decls> }; <stmts> } = let { <decls> } in do { <stmts> }
14:01:43 <stephenmac7> At the moment, I just want to know what happens when something isn't bound
14:01:47 <stephenmac7> Like tell "something"
14:01:59 <arkeet> that's the same as  _ <- tell "something"
14:02:00 <Cale> do { x; <stmts> } = x >> do { <stmts> }
14:02:04 <stephenmac7> Ah
14:02:18 <Iceland_jack> stephenmac7: (do x; y) is the same as  (x >> y)
14:02:22 <Cale> and then the obscure case:
14:02:24 <arkeet> Cale: does it actually desugar with >>, or is it >>= \_ -> ...
14:02:30 <Iceland_jack> just discards the return value of x
14:02:31 <Cale> arkeet: pretty sure it uses >>
14:02:42 <stephenmac7> Iceland_jack: Ah, I see.
14:02:51 <arkeet> > (0$0>>)
14:02:52 <lambdabot>   The operator `GHC.Base.>>' [infixl 1] of a section
14:02:52 <lambdabot>      must have lower pre...
14:02:54 <arkeet> wrong fixity =(
14:02:58 <gauthier_> Cale: right, I'm preparing a diff of the git repository
14:03:05 <hpc> arkeet: if that matters you have weird problems
14:03:25 <arkeet> it matters for performance!
14:03:35 <arkeet> it doesn't make a difference with do notation, of course.
14:03:37 <Iceland_jack> stephenmac7: This should make some sense to you:
14:03:38 <Iceland_jack> > putChar 'h' >> putChar 'i' >> putChar '\n'
14:03:38 <lambdabot>   <IO ()>
14:03:53 <arkeet> but it does mean that do {a;b;c}  and  a >> b >> c  aren't exactly the same thing.
14:03:59 <Cale> do { p <- x; <stmts> } = let ok p = do { <stmts> }; ok _ = fail "some error message" in x >>= ok -- when p is a pattern match which could fail (i.e. involving a match against a constructor of a type with more than one)
14:04:01 <Iceland_jack> Which is the same as
14:04:01 <Iceland_jack> > do putChar 'h'; putChar 'i'; putChar '\n'
14:04:02 <lambdabot>   <IO ()>
14:04:17 <arkeet> Cale: fail is fail =(
14:04:40 <Cale> arkeet: Yeah, it's still good to know that it's there though.
14:04:51 <arkeet> @undo do { x:xs <- foo; bar }
14:04:52 <stephenmac7> lambdabot: Ah
14:04:54 <lambdabot> foo >>= \ a -> case a of { x : xs -> bar; _ -> fail ""}
14:04:59 <stephenmac7> isenmann1: I see
14:05:06 <stephenmac7> wrong ping
14:05:09 <stephenmac7> Iceland_jack: I see
14:05:13 <stephenmac7> There we go
14:05:18 <Iceland_jack> :)
14:05:20 <arkeet> except it's not ""
14:05:24 <Cale> Oh, that's interesting.
14:05:26 <Iceland_jack> or
14:05:26 <Iceland_jack> > mapM_ putChar "hi\n"
14:05:27 <Cale> It used case
14:05:27 <lambdabot>   <IO ()>
14:05:34 <Cale> I'm not sure that's correct, is it?
14:05:39 <arkeet> is there a difference?
14:06:11 <gauthier_> so, the diff and the repository: http://lpaste.net/94350 https://github.com/twittner/zeromq-haskell
14:06:15 <Cale> Probably not in practice, but there is a difference in strictness.
14:06:30 <arkeet> there is?
14:07:11 <Cale> oh, hmm
14:07:13 <gauthier_> to get the haskell package to compile, I downloaded http://download.zeromq.org/zeromq-3.2.4.zip, compiled with mingw, for runtime, I use release dll compiled with visual studio (http://miru.hk/archive/ZeroMQ-3.2.4~miru1.0-x86.exe)
14:07:13 <Cale> maybe not
14:07:27 <arkeet> I'm pretty sure there isn't
14:07:34 <Cale> arkeet: You're right, there's no difference
14:07:42 <Cale> The case is just the result of inlining ok
14:07:49 <arkeet> mhm
14:09:54 <Cale> gauthier_: oh, wait, why are you using trace there? I think it would be a lot more meaningful to push your message inside the liftIO and not expose the evaluation
14:09:54 <gauthier_> the output while running the test is as follow http://lpaste.net/94351 it's odd that I see twice the messages of the main block ("opened", "binding receiver")
14:10:46 <Cale> gauthier_: Oh, this is in a QuickCheck property
14:11:02 <gauthier_> Cale: I wanted to make sure that the async part was called
14:11:18 <Cale> gauthier_: I just mean, you could have used print there
14:11:24 <Cale> rather than trace
14:11:34 <Cale> But that's not the issue
14:11:48 <Cale> So, what's wrong with this?
14:11:55 <Cale> QuickCheck did two tests
14:11:59 <Cale> One of them failed.
14:12:09 <gauthier_> Cale: I attempted at it, but still have difficulty to make such a thing to compile, while with trace I got it work
14:12:16 <Cale> oh, okay
14:13:06 <gauthier_> Cale: so there is only one test, I commented all the others, I didn't notice the output from quickcheck mentionning 2 tests, it's odd
14:13:07 <Cale> You'd put it in the liftIO, like:  liftIO $ do print "async receive, about to putMVar"; putMVar sync m
14:13:46 <Cale> gauthier_: QuickCheck runs tests multiple times, with random inputs, until either a limiting number (usually 100) is reached, or a test fails
14:13:54 <stephenmac7> Iceland_jack: How does that work if >> just discards the first value?
14:14:22 <Cale> Also, when a test fails, it runs it again and again on simplified versions of the input it failed on, until it can't find anything simpler.
14:14:43 <gauthier_> Cale: so that does work once, got it
14:15:35 <gauthier_> my main issue is that the same code is definitely working compiled on linux, so I suspect something not right happens in https://github.com/twittner/zeromq-haskell/blob/master/src/System/ZMQ3/Monadic.hs#L234 or with the async library itself
14:17:37 <Cale> gauthier_: Okay, so obviously because all the other messages got printed, up to "sent", the MVar operation it got blocked in was this takeMVar sync
14:18:24 <Cale> Is there any way perhaps that the async gets cancelled?
14:19:12 <Cale> Because if the async gets cancelled, the only way that the MVar will be set is gone, and the runtime system will detect this and throw the exception you're seeing.
14:19:55 <Cale> takeMVar will block if the MVar is empty, and will error out if there are no other threads with a reference to the MVar.
14:20:09 <Iceland_jack> stephenmac7: It doesn't discard the first value
14:20:16 <Cale> hmm
14:20:18 <Iceland_jack> it discards the *return value* of the first value
14:20:26 <Iceland_jack> in the case of (putChar 'a') it's ()
14:20:36 <Cale> oh, async is some ZMQ thing
14:21:01 <Cale> I suppose that makes sense, given that we're not binding its result...
14:21:02 <stephenmac7> So why does tell end up adding to the log?
14:21:18 <Cale> stephenmac7: Remember that there's an mappend in the definition of >>=
14:21:43 <Cale> stephenmac7: So, the monoidal results of every action that runs are appended automatically.
14:22:10 <stephenmac7> Cale: Ah
14:22:12 <stephenmac7> I didn't see that
14:22:16 <stephenmac7> Thanks
14:22:29 <Iceland_jack> stephenmac7: That's why monads are sometimes called ‘overloaded semicolons’
14:22:30 <Cale> gauthier_: Oh, but it uses Control.Concurrent.Async
14:22:43 <Iceland_jack> since you can define what happens behind the scenes of ;
14:22:48 <Cale> gauthier_: and we're not binding the resulting Async, which means that it's free to be garbage collected
14:23:17 <Iceland_jack> In Writer's case, we ‘mappend’ the value of the previous log with the new log
14:23:34 <d3lxa> if I had to look at one parser-combinator library with some fancy DSL (like scala parsers) what should I look?
14:23:43 <gauthier_> Cale: from what I understand from the test, there is no way it would fall out of scope, I was suspicious about the async call not being honored
14:24:11 <heatsink> Do you mean a DSL for writing parsers, or a parser for parsing DSLs?
14:24:31 <d3lxa> heatsink: writing beautfiul haskell code to parse things, so it's DSL in haskell
14:24:43 <d3lxa> so a DSL for writing parsers
14:24:51 <Cale> gauthier_: I think what's happening is that since we're not hanging on to the Async value which is the result of the call to async, the GC is free to collect that, and it's somehow resulting in the asynchronous action being cancelled (after all, we're no longer interested in the result, so might as well kill it)
14:24:55 <gauthier_> Cale: it seems that it isn't honored in the second occurrence of the test, since I don't know about MVar and Control.Concurrent.Async I'm unclear how I should move forward
14:25:11 <Cale> gauthier_: so it's a bit of a race condition involving the garbage collector, I suspect
14:25:14 <elliott> ThreadIds getting GC'd kills the thread iirc
14:25:15 <elliott> in GHC
14:25:25 <gauthier_> Cale: does it mean the test code is incorrect in some way?
14:25:29 <Cale> gauthier_: yes
14:25:57 <heatsink> I think Parsec is a good first choice.  It's pretty easy to write a parser from scratch with it.
14:26:10 <Cale> not to mention that this is a really really weird way to use async
14:26:25 <Cale> If you're using async, why use an MVar like this? That's what async is for.
14:27:09 <heatsink> You can usually arrange things so that your Parsec code is structured like the grammar of the language you're parsing.
14:27:16 <monochrom> combine async and mvar and tvar for maximum redundancy :)
14:27:46 <Cale> gauthier_: Okay, so... let's try this...
14:27:49 <gauthier_> Cale: I'm trying to make the test pass under windows, my assumption is that the test is correct (the person who implement this package seems to know what to do), is there such a thing as await?
14:28:15 <Cale> I think the test is wrong in its original form
14:28:31 <Cale> (and you haven't affected its wrongness in any way with your changes)
14:28:56 <Cale> It's wrong for a somewhat subtle reason which might not always show up though.
14:29:23 <gauthier_> Cale: an attempt to rewrite it without MVar, maybe using "wait", but the issue is that test package doesn't import async package, I think it's on purpose since the package exports it's own async
14:30:30 <Cale> Well, no, that's okay, just import Control.Concurrent.Async (wait)
14:30:30 <monochrom> gauthier_: learn mvar from article http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/ . learn async from video http://skillsmatter.com/podcast/home/high-performance-concurrency
14:30:50 <quchen> Don't laugh, but is the Monad instance for Reader for (r ->) the same as its Applicative?  `f <*> g = \x -> f x (g x)`, so `f <*> id = \x -> f x x`, therefore `join f = (<*> id)`
14:31:06 <hpc> :t (<*> id)
14:31:07 <lambdabot> (a -> a -> b) -> a -> b
14:31:14 <quchen> A) is that right or am I doing something awfully dumb here?
14:31:30 <quchen> B) If it's right, is it because SKI is enough to express everything on its own already?
14:31:30 <Cale> Try this... get rid of the sync MVar altogether, i.e. delete the line sync <- liftIO newEmptyMVar, and then replace the  (liftIO $ putMVar sync m) with return m, and bind the result of that async, i.e.  sync <- async receive ...
14:31:46 <Cale> and then replace the liftIO $ takeMVar sync with liftIO $ wait sync
14:31:49 <gauthier_> Cale: isn't it odd that the package exports it's own async, but don't have/export a wait as well?
14:31:51 <arkeet> quchen: that's probablya  sufficient explanation.
14:31:52 <hpc> quchen: SK is turing-complete, to answer B
14:32:08 <hpc> quchen: for A, you are right with the caveat that you can't do (<*> id) for anything but (->)
14:32:10 <Cale> gauthier_: Not *that* weird, it just means you'll have to import Control.Concurrent.Async stuff to use it
14:32:17 <Cale> gauthier_: but yeah, a little weird
14:32:18 <quchen> hpc: Sure, I'm just talking about Reader.
14:32:39 <gauthier_> Cale: sounds like an idea :) going to check it out
14:32:42 <quchen> So the Monad instance for Reader is pretty much just convenience then I guess?
14:32:44 <hpc> that also doesn't make the Monad instance the same as Applicative
14:32:52 <arkeet> :t (=<<) . flip
14:32:52 <lambdabot> (a1 -> a -> c) -> (a1 -> a) -> a1 -> c
14:32:59 <quchen> Well, up to isomorphism
14:33:02 <arkeet> :t (<*>) . flip
14:33:03 <lambdabot> (a -> b -> c) -> (b -> a) -> b -> c
14:33:06 <Cale> gauthier_: You absolutely can't use the Async library correctly with only the async primitive.
14:33:13 <hpc> their methods have different types, there isn't an isomorphism or whatever
14:33:47 <quchen> Using the Applicative you can implement the Monad, the kinds match. What more would an isomorphism of the classes mean
14:33:58 <hpc> quchen: you aren't using Applicative to implement Monad
14:34:14 <hpc> you are using Applicative plus "oh hey, id is an 'action'"
14:34:19 <hpc> :t (<*>)
14:34:20 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:34:25 <hpc> :t id
14:34:25 <lambdabot> a -> a
14:34:36 <hpc> quchen: doing (<*> id) matches id's type against (f a)
14:34:58 <hpc> so unify ((->) a a) and (f a) to get f = ((->) a)
14:34:58 <arkeet> "isomorphism" is not the word to use here.
14:35:17 <hpc> f is now constrained and you don't have a generic implementation
14:35:28 <Cale> I've run into more and more cases where it's a good idea for the Applicative instance not to match the Monad one.
14:35:37 <arkeet> never!
14:35:38 <monochrom> huh? Control.Concurrent.Async definitely exports both async and wait.
14:35:50 <quchen> hpc: f = Reader. That's why I said "for Reader" multiple times, yes.
14:36:10 <hpc> quchen: Reader = (->)
14:36:16 <Cale> monochrom: But this ZMQ library exports async, but not wait
14:36:26 <hpc> unless you take the newtype to be significant, in which case you can't even use id there!
14:36:29 <monochrom> ok then too bad
14:36:44 <Cale> monochrom: (its async is just a wrapper around the Control.Concurrent.Async one which does additional setup for some reason)
14:36:48 <hpc> :t (<*> id) -- you can't get more general than this type
14:36:49 <lambdabot> (a -> a -> b) -> a -> b
14:36:51 <quchen> Reader = the thing that has (->) in there, modulo being pedantic.
14:36:51 <hpc> for that term
14:37:37 <hpc> quchen: you have only implemented Monad in terms of Applicative if you imagine this to be a universe where Reader is the only Monad ever
14:37:53 <quchen> "is the Monad instance for Reader for (r ->) the same as its Applicative"
14:38:03 <quchen> <quchen> hpc: Sure, I'm just talking about Reader.
14:38:04 <arkeet> the answer is "no, that doesn't even make sense".
14:38:13 <hpc> "for Reader for (r ->)" wat
14:38:13 <Cale> I think the author of this ZMQ library didn't understand async properly.
14:38:26 <quchen> Am I being trolled here?
14:38:36 <Cale> It appears that they're trying to do something to prolong the lifetime of the asynchronous computation
14:38:37 <arkeet> let's remove "for Reader"
14:38:39 <monochrom> no, you are not being trolled
14:38:40 <arkeet> the answer is still "no, that doesn't even make sense".
14:38:58 <quchen> "Given the Applicative for ((->) r) you can implement the Monad ((->) r)"
14:39:02 <arkeet> yes
14:39:11 <gauthier_> Cale: I'm going to try this code on linux, on windows it fails with an exception from ZMQ instead of the MVar thing
14:39:16 <Cale> Given nothing, you can implement the Monad ((->) r)
14:39:26 <arkeet> yes
14:39:29 <hpc> woohoo! we have proved const!
14:39:40 <quchen> Cale: Good point. (The first of its kind I might add.)
14:39:56 <Kaidelong> isn't ((->) r) a contravariant functor? Don't haskell's monad and applicative require it to be covariant?
14:40:04 <Cale> gauthier_: The extra stuff that the ZMQ library is doing in its async looks really fishy to me.
14:40:06 <arkeet> Kaidelong: ((->) r) is not (-> r)
14:40:20 <Kaidelong> quchen mentioned ((-
14:40:25 <Cale> gauthier_: I think the authors intended it to do something which it doesn't actually accomplish.
14:40:27 <Kaidelong> ((->) r)
14:40:31 <arkeet> ((->) r) x = r -> x
14:40:44 <Cale> (given the nearby comments)
14:40:53 <monochrom> ((->) r) is covariant. trust me.
14:41:19 <quchen> (-> r) is contravariant, would that syntax be allowed.
14:41:26 <quchen> The parentheses matter.
14:41:27 <monochrom> yeah
14:41:38 <monochrom> write (r ->) :)
14:41:41 <arkeet> ((->) r) is (r ->)
14:41:50 <Kaidelong> how'd you write a covariant fmap for ((->) r)?
14:41:56 <quchen> Newtype it :-/
14:41:57 <Cale> fmap f x = f . x
14:41:58 <arkeet> ((/) 5) is (5 /)
14:42:01 <arkeet> Kaidelong: fmap = (.)
14:42:02 <monochrom> if you are a mathematicians, write "r -> -" :)
14:42:05 <quchen> Eh, misread, pardon.
14:42:15 <quchen> For the contravariant one you need a newtype.
14:42:26 <Cale> (->) r is Hom(r,-)
14:42:28 <hpc> this is hard to read
14:42:36 <Kaidelong> but (.) is (b -> c) -> (a -> b) -> (a -> c)
14:42:38 <monochrom> fmap for (r ->) has type: (a -> b) -> (r -> a) -> (r -> b)
14:42:41 <arkeet> (.) :: (a -> b) -> (r -> a) -> (r -> b)
14:43:03 <Iceland_jack> monochrom: some mathematicians use sections to good effect!
14:43:17 <Iceland_jack> (some = very few who also dabble in Haskell and HoTT)
14:43:29 <gauthier_> Cale: my assumption is that it mostly want to avoid exposing IO Async a but ZMQ Async a, but the comment explains something about Context that needs to stick around, I feel there are probably other ways to do this
14:43:35 <hpc> some = Oleg
14:44:12 <Cale> gauthier_: The only reason they have their own async is this funny refcounting business
14:44:19 <Kaidelong> I must be misunderstanding something then, for me, to change the type of ((->) a) you need a function in the form (t -> a) not (a -> t)
14:44:22 <Cale> gauthier_: I don't think this refcounting business is actually working
14:44:39 <arkeet> fmap :: (a -> b) -> ((->) r) a -> ((->) r) b
14:44:44 <arkeet> which is (a -> b) -> (r -> a) -> (r -> b)
14:44:53 <monochrom> Kaidelong, you are misunderstanding. does (a -> b) -> (r -> a) -> (r -> b) mean anything to you?
14:44:58 <ij> How may I import "Array" data constructor?
14:45:06 <arkeet> you don't.
14:45:25 <glguy> Kaidelong: You seem to be misunderstanding how () works on operators in Haskell
14:45:36 <glguy> a + b and (+) a b  are the same in Haskell
14:45:37 <Cale> gauthier_: in particular, if you write the code that they wrote in the comment there between the @ signs, you should fully expect that the async is killed before the threadDelay runs out.
14:45:51 <glguy> (+) a b and ((+) a ) b  are the same
14:46:06 <ij> arkeet, why's that?
14:46:10 <Kaidelong> yeah I knew that
14:46:15 <Cale> gauthier_: Well, maybe not, provided that the result of the runZMQ were getting captured and used
14:46:18 <Kaidelong> mm
14:46:22 <Cale> (which is the result of the async)
14:46:23 <arkeet> ij: because it involves GHC magic. what would you do with it?
14:46:36 <Kaidelong> what monochrom said makes perfect sense to me, I'm just taking some time to rectify it with what I knew
14:46:51 <monochrom> or refute what you knew
14:47:11 <gauthier_> Cale: I'm searching what is this e <- ask about
14:47:12 <Kaidelong> oh wait I still see a problem
14:47:22 <ij> arkeet, Well, I'm looking at wiki about arrays and there all sorts of array types that can be imported, but wouldn't I normally want just Array?
14:47:27 <arkeet> Kaidelong: the problem is on your end ;)
14:47:32 <Cale> gauthier_: That's what the ReaderT is about
14:47:35 <arkeet> ij: you can certainly import Data.Array
14:47:39 <arkeet> and make useful use of arrays with that
14:47:46 <Cale> gauthier_: newtype ZMQ z a = ZMQ { _unzmq :: ReaderT ZMQEnv IO a }
14:47:50 <arkeet> but you can't use and won't have any use for the Array constructor.
14:48:09 <arkeet> well, you can if you import GHC.Arr
14:48:19 <ij> Is there a difference between lists and arrays?
14:48:25 <arkeet> yes!
14:48:27 <Cale> gauthier_: To specialise its type a bit here,  ask :: ReaderT ZMQEnv IO ZMQEnv
14:48:41 <arkeet> data [a] = [] | a : [a]
14:48:50 <Kaidelong> oh I see what it was
14:48:52 <arkeet> data Array i a = magic
14:48:56 <Cale> gauthier_: So, running it will get the ZMQEnv which is passed in at the top level.
14:49:02 <Kaidelong> I was talking about (->) and not ((->) r)
14:49:20 <monochrom> list has cheap prepend and infinite length. array is the opposite.
14:49:20 <Kaidelong> or (-> r)
14:49:20 <arkeet> ij: lists are linked lists, with linear access time and such. arrays are random access fixed-size arrays.
14:49:27 <Kaidelong> I meant (-> r)
14:49:49 <monochrom> (-> r) is contravariant, yes
14:49:50 <Kaidelong> it was because I forgot how instance and class declarations worked, not because of parens
14:49:54 <arkeet> Kaidelong: instance Functor ((->) r) where fmap = (.)
14:49:54 <Cale> ij: Lists can be infinitely long, arrays can't be
14:50:03 <Kaidelong> and that you had to omit the type variable that was actually important
14:50:04 <arkeet> the f is ((->) r)
14:50:20 <Cale> Oh, monochrom mentioned that :)
14:50:23 <arkeet> f a = ((->) r) a = r-> a
14:50:24 <arkeet> and so on
14:50:31 <monochrom> yes, you see how mathematicians poisoned your brain with "the function f(x)" and "the function sin(x)+x"
14:50:41 <ij> arkeet, Can I make an array somehow then?
14:50:44 <arkeet> real mathematicians wouldn't do that!
14:50:48 <arkeet> ij: yes, using the functions in Data.Array
14:50:53 <Cale> monochrom: Hey, for the most part, mathematicians are pretty good about that.
14:50:59 <ij> arkeet, aha
14:51:03 <ij> !
14:51:12 <Cale> It's mostly physicists and highschool math teachers at this point who have that problem
14:51:15 <monochrom> they're pretty good with "the bifunctor Hom(F -, -)"
14:51:26 <arkeet> ij: sorry, I probably should have said that eariler. :P
14:51:44 <startling> monochrom, yeah, they really should say sin + id.
14:51:46 <hpc> Cale: because nobody else learns functions!
14:51:51 <ij> arkeet, You were probably enjoying that.
14:51:54 <monochrom> it is conveniently ambiguous about "\x -> Hom(F x, x)" and "\x y -> Hom(F x, y)"
14:51:56 <Cale> hpc: heh
14:51:59 <arkeet> Cale: "the function f(x)" is ok if we take x = id and application = comopsition
14:51:59 <gauthier_> Cale: well the change using await rather than MVar works on linux, I have to track the underlying failure on windows, it's an exception raised in the package
14:52:23 <Kaidelong> or if f is higher order
14:52:25 <Cale> gauthier_: Does that change help the case on windows?
14:52:28 <startling> arkeet, or if f : a -> b -> c I guess.
14:52:40 <monochrom> well, I guess "bifunctor" disambiguate it. but sometimes they don't add "bifunctor" there
14:52:46 <arkeet> ok, "the function x^2"
14:52:49 <gauthier_> Cale: it does avoid the exception with MVar mentionned
14:52:51 <arkeet> explain that. =(
14:53:00 <Cale> gauthier_: Ah, okay, but you have some new problem?
14:53:09 <gauthier_> Cale: "thread blocked indefinitely in an MVar operation"
14:53:21 <Cale> yeah, that was the one
14:53:31 <gauthier_> Cale: right, now I get *** Failed! Exception: 'ZMQError { errno = 0, source = "receive", message = "No error" }'
14:53:41 <Cale> heh, sounds fun
14:53:52 <gauthier_> Cale: I'm going to investigate where this come from, yes "no error" exception :)
14:54:45 <Cale> gauthier_: Make sure that the main action is wrapped in a withSocketsDo
14:55:19 <Cale> (or that withSocketsDo shows up somewhere, at least -- this is required on Windows but not on Linux to initialise sockets)
14:55:55 <Cale> withSocketsDo :: IO a -> IO a
14:57:00 <`^_^v> is there a chan specifically for parsec questions
14:57:09 <Cale> I don't think so
14:57:14 <monochrom> no, use this channel
14:57:34 <briennetheblue> > over _2 (view _2) (0, (1, 2))
14:57:36 <lambdabot>   Could not deduce (Control.Lens.Internal.Indexed.Indexable
14:57:36 <lambdabot>                  ...
14:57:49 <briennetheblue> why doesn't that work
14:57:59 <gauthier_> Cale: I encounter that dealing with another library or something, ok I added it at the top level of the property but still get the same, I'm looking at places raising the error in the package code
14:58:09 <startling> briennetheblue, _2 is not a lens on "view _2"
14:58:09 <acowley> I wrote almost that exact code yesterday briennetheblue!
14:58:20 <startling> oh, wait, misread.
14:58:27 <Cale> gauthier_: Ah, usually it's *right* at the top level that you want to do that, I'm not sure what happens if they get nested.
14:58:33 <glguy> briennetheblue: It does work in lens-HEAD
14:58:41 <briennetheblue> ah ok
14:58:43 <acowley> briennetheblue: I will admit, I got around the problem by just writing snd instead of view _2
14:58:48 <Cale> (does anyone know if there's any harm in withSocketsDo being nested?)
14:58:49 <glguy> > over _2 (^. _2) (0, (1, 2))
14:58:52 <lambdabot>   (0,2)
14:58:53 <acowley> glguy: That's great! It was a frustrating thing to hit
14:58:59 <acowley> :t view
14:59:00 <lambdabot> MonadReader s m => Getting a s a -> m a
14:59:03 <briennetheblue> thanks :)
14:59:04 <acowley> :t (^.)
14:59:05 <lambdabot> s -> Getting a s a -> a
14:59:09 <glguy> briennetheblue: The issue is that "view" is a little more flexible
14:59:13 <briennetheblue> I see
14:59:25 <ij> Does haskell have some function to return an infinite list consisting of a value given?
14:59:31 <Cale> repeat
14:59:31 <heatsink> repeat
14:59:34 <acowley> :t repeat
14:59:35 <Cale> > repeat 0
14:59:35 <lambdabot> a -> [a]
14:59:36 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
14:59:50 <Cale> > replicate 10 0
14:59:51 <glguy> :t _1
14:59:52 <lambdabot>   [0,0,0,0,0,0,0,0,0,0]
14:59:53 <lambdabot> (Functor f, Field1 s t a b, Indexable Int p) => p a (f b) -> s -> f t
15:00:00 <glguy> but in HEAD: _1 :: (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
15:00:10 <glguy> no more indexable
15:00:27 <arkeet> \o/
15:00:31 <arkeet> death to indexable!
15:00:41 <briennetheblue> cool
15:00:42 <glguy> No in general, just on things like each and _N
15:00:50 <arkeet> :):
15:00:54 <arkeet> :)
15:01:24 <`^_^v> i'm trying to parse a grammar where dispatch ::= expr[: TYPE].ID( expr_list ), and dispatch has precedence over arithmetic operations (which i used text.parsec.expr to create a parser for). no matter how i seem to do it it gets stuck in an infinite loop, any suggestions?
15:01:25 <Cale> Does that actually reduce generality?
15:01:42 <donri> > [0..9] ^. _1
15:01:43 <lambdabot>   Could not deduce (Control.Lens.Tuple.Field1
15:01:44 <lambdabot>                      [GHC.Integ...
15:01:45 <startling> `^_^v, you might have a left recursion problem.
15:01:53 <donri> > [0..9] ^? _1
15:01:54 <lambdabot>   Could not deduce (Control.Lens.Tuple.Field1
15:01:55 <lambdabot>                      [GHC.Integ...
15:01:56 <gauthier_> Cale: it's not called anywhere, so I assume it's safe, in the implementation it would throw ioError if called more than once
15:02:03 <arkeet> > [0..9] ^? ix 1
15:02:03 <startling> > [0..9] ^? ix 1
15:02:05 <lambdabot>   can't find file: L.hs
15:02:05 <lambdabot>   Just 1
15:02:10 <Cale> gauthier_: ah, okay
15:02:13 <startling> arkeet, mine won. :)
15:02:19 <arkeet> startling: =(
15:02:39 <glguy> You don't have to use operators:
15:02:39 <glguy> > preview (ix 0) [0..9]
15:02:41 <lambdabot>   Just 0
15:02:47 <donri> lens should have a Num instance for 'ix' ;)
15:02:48 <Cale> glguy: hooray
15:02:54 <arkeet> using self-indexing objects for test code =(
15:02:57 <startling> :t ix
15:02:57 <arkeet> > preview (ix 1) "abcde"
15:02:59 <lambdabot>   Just 'b'
15:03:04 <arkeet> :t (ix)
15:03:05 <lambdabot> (Indexable (Index m) p, Ixed f m) => Index m -> p (IxValue m) (f (IxValue m)) -> m -> f m
15:03:07 <startling> arkeet gets his vengeance
15:03:14 <arkeet> :>
15:03:19 <glguy> ix is no longer an indexed traversal in HEAD
15:03:26 <startling> What is it?
15:03:32 <glguy> normal traversal
15:03:32 <arkeet> just a traversal
15:03:37 <heatsink> I don't know what the problem is, but sometimes left-factoring the parsing rules helps, v^_^'
15:03:57 <startling> `^_^v: but really we need to see yourcodetotell you.
15:04:09 <arkeet> when you use ix, you already know the index. no need to get it back.
15:04:09 <arkeet> =(
15:04:12 <heatsink> expr_or_dispatch = expr [[:TYPE].ID(expr_list)]
15:04:18 <startling> arkeet: oh, I see.
15:04:33 <arkeet> > "abcde" ^@.. ix 5
15:04:35 <lambdabot>   []
15:04:37 <arkeet> > "abcde" ^@.. ix 2
15:04:38 <lambdabot>   [(2,'c')]
15:04:43 <startling> heatsink, oh, and expr = expr_or_dispatch | ... probably.
15:04:45 <arkeet> > "abcde" ^@.. itraversed
15:04:46 <lambdabot>   [(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e')]
15:05:05 <bos> what's that snail?
15:05:17 <donri> :t itoListOf
15:05:18 <glguy> Now: ix :: Ixed m => Index m -> Traversal' m (IxValue m)
15:05:18 <lambdabot> IndexedGetting i (Endo [(i, a)]) s a -> s -> [(i, a)]
15:05:27 <acowley> Why do lens things need to be parenthesized for lambdabot?
15:05:27 <startling> I think its itoListOf
15:05:28 <donri> :t flip (^@..)
15:05:30 <lambdabot> IndexedGetting i (Endo [(i, a1)]) a a1 -> a -> [(i, a1)]
15:05:30 <arkeet> gets a list of the elements, paired with their index.
15:05:37 <glguy> bos: the @ means indexed the .. means "to list" ...
15:05:39 <briennetheblue> it's a happy looking snail
15:05:41 <startling> acowley: it's a lambdabot bug, no one knows why the parens work.
15:05:44 <arkeet> and ^ means "get"
15:05:45 <jfischoff> `^_^v: left factor
15:05:47 <acowley> hahaa
15:05:52 <startling> :(
15:06:14 <glguy> bos: but you can just use itoListOf and not learn the operator
15:06:32 <monochrom> `^_^v: sometimes chainl and chainr are useful
15:06:38 <arkeet> it all makes sense once you get used to it.
15:06:40 <acowley> How will this play with Haskell's reputation for fussy correctness?
15:06:55 <jfischoff> oh yes and chainl/r
15:07:07 <jfischoff> what monochrom said
15:07:29 <arkeet> aww, I thought we had some 5-character operators.
15:07:55 <arkeet> oh we do.
15:08:25 <heatsink> Are there tricks for debugging run-time type errors resulting from unsafeCoerce?
15:08:25 <glguy> arkeet: did you find <<||~ ?
15:08:38 <arkeet> things derived from 2-character operators don't count =(
15:08:53 <donri> > itoListOf traversed ['a'..'e']
15:08:55 <lambdabot>   [(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e')]
15:09:10 <`^_^v> the operator in chainl is (a -> a -> a) which is not the same as my Dispatch constructor (Expr -> Identifier -> Expr)
15:09:11 <briennetheblue> is there another way to write "over x $ view y"?
15:09:24 <`^_^v> ill try left factoring
15:09:28 <briennetheblue> seems a commonish thing to do
15:09:33 <startling> briennetheblue: I think _2 is the problem.
15:09:44 <briennetheblue> yes
15:10:07 <startling> > over _2 (view _2 :: (a, b) -> b) (1, (2, 3))
15:10:09 <lambdabot>   (1,3)
15:10:24 <briennetheblue> just wondered if there was a slightly shorter way to write it
15:10:25 <startling> You might write a more specific version of _2.
15:10:30 <gauthier_> I'm wondering how to compile with debug options so I can get a stack trace, when I issue --enable-*-profiling, it won't compile because apparently I need to have dependencies with profiling enabled too
15:10:56 <startling> > over _2 (view $ to snd) (1, (2, 3))
15:11:00 <lambdabot>   Could not deduce (Control.Lens.Internal.Indexed.Indexable
15:11:00 <lambdabot>                  ...
15:11:04 <monochrom> true story: once upon a time, someone was using parsec to write a parser for lambda, with juxtaposition parsed to application like haskell. he asked how to do it, I answered chainl, I even showed my own code doing the same. but he rejected it and kept asking and showing frustration. turning a blind eye to chainl and complaining "why is haskell and parsec making my life difficult" when chainl solved his problem in one go.
15:11:24 <monochrom> his name was palomer. he eventually got banned.
15:11:32 <glguy> briennetheblue: I think the best way in these small cases is probably to just pattern match the tuple <_<
15:11:39 <monochrom> moral of the story: if you reject monochrom's answer, you'll get banned :)
15:11:47 <briennetheblue> oh I just meant in general
15:12:05 <startling> in general you don't have that problem.
15:12:06 <briennetheblue> when you modify a part of a structure by looking at the thing there through a lens
15:12:09 <monochrom> no, just kidding! he got banned years later for being annoying for years.
15:12:12 <donri> > (1,(2,3)) & _2 %~ snd
15:12:14 <lambdabot>   (1,3)
15:12:29 <arkeet> I dunno how ot use <<%@~ in a serious application.
15:12:33 <arkeet> > M.fromList [('a',1), ('b',3)] & at 'a' <<%@~ (\i x -> fmap (+ ord i) x)
15:12:34 <lambdabot>   (Just 1,fromList [('a',98),('b',3)])
15:12:35 <glguy> briennetheblue: I don't think there's a shortcut
15:12:37 <acowley> donri: That's how I fixed that problem in my code just yesterday
15:12:55 <jfischoff> monochrom: I learned how to use parsec from the same tutorial
15:13:09 <glguy> arkeet: I think most of these exist because there is a pattern and an implementation of the operator that fits that pattern
15:13:09 <monochrom> err, which tutorial?
15:13:15 <donri> > fmap snd (1,(2,3))
15:13:16 <arkeet> :)
15:13:17 <lambdabot>   (1,3)
15:13:33 <jfischoff> monochrom: the one on the haskell wiki
15:14:07 <frxx> donri how does that work?
15:14:38 <donri> @src (,) fmap
15:14:38 <lambdabot> fmap f (x,y) = (x, f y)
15:14:53 <donri> @src snd
15:14:53 <lambdabot> snd (_,y) =  y
15:15:08 <monochrom> `^_^v: there are "many", "many1", "sepBy", "sepBy1", "endBy", "endBy1", "sepEndBy", "sepEndBy1". I'm sure you could use one of them.
15:15:28 <frxx> got it
15:20:16 <briennetheblue> overView does make a nice function name though :)
15:20:44 <carrutstick> @src join
15:20:45 <lambdabot> join x =  x >>= id
15:21:38 <arkeet> @src src
15:21:38 <lambdabot> Source not found. Abort, Retry, Panic?
15:21:55 <Iceland_jack> > (let us = (++) in join us) "cult! "
15:21:56 <lambdabot>   "cult! cult! "
15:22:01 <mak`> hello, can anyone help me? I have problem running ghc compiled binary in linux chroot
15:22:11 <startling> mak`, what's the problem?
15:22:26 <mak`> it runs but no output is generated
15:22:48 <mak`> i've copied all libs from ldd to chroot
15:23:48 <mak`> form strace output is seem to hang on some kind of alarm
15:24:38 <mak`> http://pastebin.com/k1tuQiK5
15:24:40 <mauke> The paste k1tuQiK5 has been copied to http://lpaste.net/94353
15:25:00 <mak`> this is part of strace
15:27:26 <ocharles> If I am building Foo.hs with -shared -dynamic, and depend on, say, 'hint' - is it possible to do so without compiling hint with --enable-shared?
15:27:34 <ocharles> that is, statically linking hint into Foo.so?
15:29:28 <monochrom> it is impossible or very hard. to me, it's impossible.
15:29:47 <ocharles> mmm
15:29:47 <ocharles> ok
15:29:59 <ocharles> annoyingly there doesn't seem to be a way to make nixos build shared libraries :(
15:45:10 <Peaker> Can optparse-applicative handle escapes for switches?
15:45:24 <Peaker> and can it give me the ordering between switches and positional args?
15:46:06 <donri> escapes, how?
15:46:41 <donri> i think it handles the convention of a bare "--" signaling start of positional arguments
15:47:01 <Peaker> as in:  foo ls \-R   so "-R" goes to "ls", though now that I am typing it out, it sounds ilke I ought to have each cmd in its own single arg (albeit slightly uncomfortable)
15:47:12 <elliott> fo -- ls -R
15:47:14 <elliott> *foo
15:47:26 <Peaker> well, I am writing something that takes a bunch of command lines and executes them in parallel
15:47:35 <Eduard_Munteanu> Hm, why don't HasFoo classes in 'lens' define the second parameter as an associated type synonym?
15:47:37 <Peaker> (spooling and timestamping their stdout/stderr lines)
15:47:45 <johnw> Peaker: like GNU parallel?
15:47:58 <Peaker> johnw: maybe :) Haven't heard of GNU parallel
15:48:04 <Eduard_Munteanu> It's a bit annoying when I'm doing a lot of (HasFoo r, HasBar r ...)
15:48:21 <donri> Peaker: i'd read stdin for that
15:48:44 <Peaker> donri: yeah, maybe that would be better
15:48:50 <donri> hm i guess you want shell tokenization though
15:48:57 <Eduard_Munteanu> I should try making a type family to work around that.
15:49:21 <Peaker> maybe I just want gnu parallel that I didn't know about :)
15:49:50 <johnw> parallel doesn't seem to do multiple commands
15:49:51 <Eduard_Munteanu> It isn't really great.
15:49:57 <johnw> rather, one command iterated over multiple arguments
15:50:07 <johnw> i use it pretty often in place of xargs
15:50:11 <Eduard_Munteanu> Then again, bash isn't really great.
15:50:25 <Peaker> johnw: oh, bummer
15:50:52 <Peaker> does it do line spooling?
15:51:11 <johnw> you mean, showing the lines in a better way that just interleaving all the output?
15:51:15 <Peaker> yeah
15:51:20 <johnw> yeah, it does a good job of that
15:52:00 <donri> Peaker: how about http://beta.hackage.haskell.org/package/hydra-print
15:52:33 <chrisdone> spool. i love that word
15:52:35 <donri> not sure it's what you want but maybe
15:54:15 <lpaste> DanBurton pasted “Merging layers of transformers” at http://lpaste.net/94354
15:54:44 <acowley> What's the current state of the debate on using Void or being polymorphic when potentially dropping outputs?
15:54:47 <DanBurton> Challenge: implement mergeR, mergeW, and mergeS ^
15:54:50 <johnw> DanBurton: does that mean transformers are themselves monads?
15:54:54 <acowley> e.g. m r -> m ()  vs. m Void -> m ()
15:55:07 <DanBurton> johnw: transformers are often monads in the category of monads
15:55:25 <DanBurton> That's the thing I'm working on.
15:55:40 <hpc> acowley: the case of dropped outputs is i think something people tend to know what they want
15:55:40 <acowley> I find their functoriality in the category of monads more commonly useful
15:55:46 <DanBurton> But it seems that mergeS is not possible with the typical implementation of StateT
15:55:49 <acowley> hpc: Yeah, so polymorphic?
15:55:51 <Peaker> DanBurton: hmm.. flattening the StateT to interleave the effects on the same state seems like a bad idea?
15:55:53 <hpc> yeah
15:56:10 <hpc> i mean, if you have a bug about dropped output, oh well and you fix it
15:56:18 <hpc> Void makes you just put so much garbage in your code
15:56:18 <DanBurton> Peaker: but flattening the writer to interleave writes isn't? ;)
15:56:25 <acowley> cool, I hate importing Data.Void just for this
15:56:30 <Peaker> DanBurton: also bad :)
15:56:34 <acowley> Yeah, but I can see the Void argument, too
15:57:06 <DanBurton> Peaker: well I guess interleaving reads is harmless :P and also possible to implement
15:57:12 <Peaker> DanBurton: I think it should be impossible because the semantics of (>>=) on StateT s m  guarantee that the "m" can't meddle in the "s" without any lifting in there
15:57:50 <Peaker> or with..
15:58:17 <acowley> random question: I thought I saw a really clever version of picking every other element from a list somewhere like cafe a long time ago… anyone have a similar memory?
15:58:25 <DanBurton> Peaker: good point
15:58:54 <benmachine> acowley: something like zipWith if' (cycle [False, True])?
15:59:02 <acowley> yeah
15:59:03 <benmachine> wait no
15:59:07 <acowley> something like that
15:59:12 <benmachine> something not unlike that, but not that exactly
15:59:15 <acowley> right
15:59:22 <Peaker> DanBurton: I think it would not be possible for any alternative StateT either, if it is a valid monad transformer
15:59:23 <benmachine> maybe involving filterM
15:59:37 <johnw> :t filterM
15:59:38 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
15:59:53 <benmachine> no, that doesn't look quite right iether
15:59:57 * benmachine shrugs and goes to bed
15:59:58 <johnw> :t mfilter
15:59:58 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
16:00:09 <acowley> where is that from?
16:00:14 <chrisdone> Control.Monad?
16:00:27 <benmachine> I've never seen it before
16:00:30 <ReinH> acowley: you can do it with a zip and a filter
16:00:33 <acowley> whaaattt
16:00:39 <Peaker> didn't know about mfilter either
16:00:42 <acowley> I had no idea that was there
16:00:43 <enthropy> @type guard
16:00:43 <lambdabot> MonadPlus m => Bool -> m ()
16:00:51 <chrisdone> http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#v:mfilter
16:01:01 <johnw> > mfilter (==2) (Just 3)
16:01:02 <lambdabot>   Nothing
16:01:03 <johnw> > mfilter (==2) (Just 2)
16:01:04 <lambdabot>   Just 2
16:01:08 <benmachine> yeah I wonder when that snuck in
16:01:29 <Peaker> Control.Monad is mostly comprised of Monad-constrained functions that should have been Applicative-constrained
16:01:35 <chrisdone> benmachine: maybe the functions are breeding
16:01:42 <Peaker> almost none of Control.Monad actually requires the power of Monad
16:01:53 <ReinH> > let skip = map snd . filter fst . zip (cycle [True, False]) in skip [1,2,3,4]
16:01:54 <lambdabot>   [1,3]
16:01:59 <benmachine> okay I am duly chastised, it's been there since at least GHC 7
16:02:06 <ReinH> acowley: also easy to generalize to taking every nth
16:02:06 <benmachine> that's when I got bored of looking :P
16:02:21 <chrisdone> you think that's bad
16:02:22 <acowley> anyway, I did this lame map filter zip schwartzian transform for picking every other element
16:02:32 <chrisdone> i didn't know that Traversable was derivable until this year
16:02:32 <ReinH> acowley: like what I just did? :p
16:02:52 <benmachine> heh
16:02:56 <acowley> ReinH: Probably! But this is me doing a code review on my code from last week
16:03:03 <acowley> and this part sticks out
16:03:09 <acowley> oh yes
16:03:13 <acowley> that's it exactly
16:03:13 <donri> chrisdone: it won't be efficient until 7.8 though :(
16:03:17 <acowley> I should get my blindness checked
16:03:17 <ReinH> acowley: lmao
16:03:19 <benmachine> chrisdone: what do you mean you don't excitedly read ghc --supported-languages with every new release
16:03:27 <ReinH> acowley: would you prefer an unfoldr?
16:03:30 <chrisdone> donri: so much awesome stuff coming in ghc 7.8
16:03:38 <donri> quite
16:03:56 <johnw> chrisdone: like what?
16:04:05 <ReinH> acowley: or a chunksOf version?
16:04:14 <donri> every new ghc release i'm like "*this* release is killer, i can't live without this stuff!" and then next release that's all old and boring
16:04:20 <acowley> ReinH: I only want an alternative that's better
16:05:11 <acowley> donri: Part of that is because things slip to the next version before release
16:05:12 <ReinH> > let every = fmap head . chunksOf in every 2 [1,2,3,4]
16:05:13 <lambdabot>   [1,2]
16:05:22 <chrisdone> johnw: kind polymorphic typeable for one
16:05:34 <ReinH> acowley: uses head though :/
16:05:46 <johnw> i wish I could have recursive type definitions across two modules
16:05:53 <ReinH> otherwise it's rather elegant
16:05:54 <acowley> ReinH: I don't have a definition of "better" that adds a use of head
16:05:59 <chrisdone> johnw: and then a bunch of other stuff i can't recall but like donri says everything that's awesome is always in the next release
16:06:00 <ReinH> acowley: confirm
16:06:11 <ReinH> acowley: what kind of better do you want?
16:06:18 <acowley> :P
16:06:20 <acowley> it is pretty good in terms of character count
16:06:39 <ReinH> acowley: concatMap safeHead then? :p
16:06:50 <chrisdone> http://ghc.haskell.org/trac/ghc/wiki/GhcKinds/PolyTypeable
16:06:51 <acowley> ReinH: I don't know. I was just wondering if somebody would immediately produce some 10 character magic using only Prelude.
16:06:57 <ReinH> acowley: nope :D
16:07:57 <ReinH> acowley: I mean...
16:08:00 <ReinH> > let f (x:y:xs) = x:f xs; f [] = [] in f [1,2,3,4]
16:08:02 <lambdabot>   [1,3]
16:08:19 <ReinH> but I'm guessing you don't want a naive recursive solution either
16:08:26 <acowley> I want *magic*
16:08:30 <ReinH> fine :p
16:09:02 <ReinH> fmap head . chunksOf is magical. Unsafe, but magical.
16:09:59 <donri> johnw: hmm closed type families, safe coercions, polykinded category, typed TH, probably forgot a bunch of things
16:10:59 <johnw> ok, that's a good list :)
16:11:11 <pqmodn> acowley: you want every other item in a list? swear i've seen incantation in #haskell once before
16:11:16 <donri> https://github.com/ghc/ghc/blob/master/docs/users_guide/7.8.1-notes.xml
16:11:24 <donri> oh yeah type holes
16:11:25 <johnw> the only sad thing is then the number of library writers who refuse to use those extensions because they're extensions
16:11:30 <Eduard_Munteanu> Hrm, how do I write a constraint that should contain a forall?
16:11:31 <chrisdone> type hoelss!!!11
16:11:47 <johnw> holy types, batman!
16:11:49 <acowley> closed type families is exciting
16:11:57 <donri> overloaded lists, right
16:11:59 <donri> new io manager
16:12:02 <acowley> pqmodn: Yeah, me too. I just can't remember how it went.
16:12:08 <johnw> the new io manager is very excited
16:12:09 <johnw> ing
16:12:09 <Eduard_Munteanu> data WrapConstraint :: Constraint -> * where IsConstraint :: c => WrapConstraint c    still doesn't cut it
16:12:17 <donri> i think parallel ghc --make made it too
16:12:21 <acowley> <io_manager> oh boy oh boy oh boy!
16:12:23 <donri> not sure about cabaj
16:12:23 <chrisdone> oh yeah overloaded lists will be conweenient
16:12:45 <donri> MINIMAL pragma is nice
16:12:48 <Eduard_Munteanu> In a type family instance, that is.
16:12:56 <chrisdone> donri: what's that?
16:12:59 <briennetheblue> > [1..10]^..traversed.indices even
16:13:00 <lambdabot>   Couldn't match expected type `(a0
16:13:01 <lambdabot>                                 -> Contro...
16:13:07 <DarkLinkXXXX> Can haddock be configured to generate an index on multiple modules?
16:13:08 <briennetheblue> well whatever
16:13:23 <donri> chrisdone: {-# MINIMAL (==) | (/=) #-}
16:13:25 <chrisdone> ohh, yeah, that is nice
16:13:46 <johnw> hah, I just wrote "typedef" in my Haskell file to make a type synonym; freudian slip
16:14:00 <chrisdone> johnw: wash your hands!
16:14:23 <briennetheblue> hm... shouldn't that work?
16:15:02 <briennetheblue> > ["hello","the","world","!!!"]^..traversed.indices even
16:15:03 <lambdabot>   Couldn't match expected type `(a0
16:15:04 <lambdabot>                                 -> Contro...
16:15:08 <briennetheblue> what the
16:15:23 <donri> nice new warnings like 256 :: Word8 should be compile-time warning IIUC
16:15:34 <ij> array takes list of index+value tuples, because Ix type class doesn't imply ordering?
16:16:12 <johnw> I need an O'Reilly book that just covers lens combinator by combinator, and type by type
16:16:31 <Eduard_Munteanu> ij: it does imply an ordering, I think, since Ix maps to regular Ints.
16:16:34 <startling> heh
16:16:42 <startling> I think we should have a canonical reading order for the lens docs.
16:16:59 <briennetheblue> > over (traversed.indices (>0)) Prelude.reverse $ ["He","was","stressed","o_O"]
16:17:00 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i0 e0'
16:17:00 <lambdabot>              with actual...
16:17:05 <ij> Eduard_Munteanu, Hmm, then why array function takes list of index+value tuples, not just value list?
16:17:20 <Eduard_Munteanu> :t array
16:17:21 <lambdabot> Ix i => (i, i) -> [(i, e)] -> Array i e
16:17:43 <Eduard_Munteanu> @hoogle (i, i) -> [e] -> Array i e
16:17:43 <lambdabot> Data.Array listArray :: Ix i => (i, i) -> [e] -> Array i e
16:17:44 <lambdabot> Data.Array.IArray listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
16:17:44 <lambdabot> Data.Array accumArray :: Ix i => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
16:17:50 <Eduard_Munteanu> ij: listArray ^^
16:19:00 <ij> yay
16:19:13 <ij> > listArray (1,3) $ repeat 9
16:19:13 <lambdabot>   array (1,3) [(1,9),(2,9),(3,9)]
16:19:18 <ij> Thank you.
16:20:33 <briennetheblue> :t (^..traversed.indices even)
16:20:34 <lambdabot>     Couldn't match expected type `(a0 -> Accessor (Endo [a0]) a0)
16:20:34 <lambdabot>                                   -> p0 a1 (Accessor (Endo [a0]) a1)'
16:20:34 <lambdabot>                 with actual type `[i0]'
16:21:12 <Peaker> :t (^..itraversed.indices even)
16:21:13 <lambdabot>     Couldn't match expected type `(a0 -> Accessor (Endo [a0]) a0)
16:21:14 <lambdabot>                                   -> p0 a1 (Accessor (Endo [a0]) a1)'
16:21:14 <lambdabot>                 with actual type `[i1]'
16:21:14 <Eduard_Munteanu> Phew, with a type synonym and ImpredicativeTypes, I can write forall in that constraint.
16:21:14 <lpaste> DanBurton pasted “Interleavable StateT implemented via FreeT” at http://lpaste.net/94355
16:21:28 <Peaker> oh whoops, both work at my ghci, not just the latter
16:21:29 <DanBurton> Peaker: ^ valid Monad instance per FreeT
16:22:27 <Peaker> DanBurton: oh, nice :)
16:22:43 <Peaker> postpone the actual state stuff till later
16:22:46 <briennetheblue> oh well.  that's a cool way to get every other element anyway
16:23:54 <Peaker> briennetheblue: I wonder how efficient it is, compared to the straight-forward list processors
16:24:30 <briennetheblue> that would be nice to know
16:24:45 <Eduard_Munteanu> Weird how  type instance ... = WrapConstraint (forall a. (Foo a))  fails, but it works if I defer that to an external type synonym.
16:27:33 <acowley> briennetheblue: that is pretty slick!
16:27:38 <DanBurton> oh it can be generalized
16:27:45 <DanBurton> the state/freet thing
16:28:45 <acowley> I've completely run out of identifier names. I exhausted foo,bar,etc. earlier, and just defined dude in terms of sweet.
16:28:54 <johnw> DanBurton: but we already know that FreeT turns anything into a monad
16:29:05 <johnw> your mergeS in that case == join
16:29:23 <lpaste> DanBurton annotated “Interleavable StateT implemented via FreeT” with “Interleavable StateT implemented via FreeT (annotation)” at http://lpaste.net/94355#a94356
16:29:45 <briennetheblue> acowley I thought so :) it's an example straight from the docs http://hackage.haskell.org/package/lens-3.10/docs/src/Control-Lens-Indexed.html#indices
16:29:50 <enthropy> is it somehow impossible to get syntax highlighting in https://gist.github.com/aavogt/7016708 ?
16:30:00 <DanBurton> johnw: exactly... MHask.join, that is
16:30:13 <johnw> right
16:30:43 <johnw> DanBurton: I tihnk you can even abstract further using MonadFree in this case
16:31:10 <johnw> or maybe not...
16:31:43 <DanBurton> I think iterT might work or something
16:31:52 <DanBurton> no that's specialized to FreeT
16:32:18 <ij> Is CArray unsafe? How do I create one without IO?
16:32:54 <Vamp> Could someone give me an example of how to make an instance for Random? I think I understand random and randomR, but I don't know how to implement an instance with it, can't really find an example on the net either
16:34:40 <brainacid> hey room
16:34:45 <ij> channel
16:34:50 <brainacid> hello channel
16:35:18 <ij> hello
16:35:39 <DanBurton> ij: you can't do it without IO, at least not directly
16:36:01 <briennetheblue> @let import Data.Thyme
16:36:02 <lambdabot>  .L.hs:102:1:
16:36:02 <lambdabot>      Failed to load interface for `Data.Thyme'
16:36:02 <lambdabot>      Perhaps you...
16:36:40 <ij> Why would dftRC out of Math.FFT want specifically CArray?
16:36:46 <DanBurton> ij: if you want to do harmless mutation to build up an array, then usually you would use the ST monad, but CArray doesn't seem to provide ST operations
16:37:14 <DanBurton> ij: you can use Control.Monad.ST.Unsafe.unsafeIOToST
16:37:57 <pqmodn> acowley: this doesn't seem as cute as what i thought i remembered: concat . zipWith replicate (cycle [1,0])
16:40:20 <arkeet> :t concat . zipWith replicate (cycle [1,0])
16:40:20 <lambdabot> [a] -> [a]
16:40:27 <arkeet> oh.
16:41:10 <brainacid> so haskell really just takes one function returning a function to take the second parameter
16:41:31 <brainacid> takes a function with 2 parameters
16:41:37 <ij> yes
16:42:39 * hackagebot mcpi 0.0.1.0 - Connect to MineCraft running on a Raspberry PI.  http://hackage.haskell.org/package/mcpi-0.0.1.0 (DouglasBurke)
16:42:44 <brainacid> interesting and i cant wait to understand more haskell
16:43:16 <ij> brainacid, Are you reading something?
16:44:35 <brainacid> yes
16:44:42 <ij> May I ask what?
16:44:45 <brainacid> lyah and learn haskell fast and hard
16:44:51 <arkeet> > "abcdefgh" ^.. traversed . Lens.indices even
16:44:52 <lambdabot>   "aceg"
16:45:38 <brainacid> my dilema with lyah is its a lot of stuff about list but i dont know how to use them....but i will keep reading so one day it all clicks
16:45:39 <briennetheblue> :t indicies
16:45:40 <lambdabot>     Not in scope: `indicies'
16:45:40 <lambdabot>     Perhaps you meant one of these:
16:45:40 <lambdabot>       `Lens.indices' (imported from Control.Lens),
16:45:54 <briennetheblue> :t indices
16:45:55 <lambdabot> Ix i => Array i e -> [i]
16:45:56 <arkeet> Lens.indices :: (Indexable i p, Applicative f) => (i -> Bool) -> Optical' p (Indexed i) f a a
16:45:58 <briennetheblue> oooh
16:46:05 <briennetheblue> that's why it didn't work :)
16:46:17 <arkeet> oh, that's HEAD's version.
16:46:17 <arkeet> yeah.
16:46:26 <arkeet> Array =((
16:47:56 <pqmodn> acowley: there's also lefts . zipWith ($) (cycle [Left,Right])
16:48:15 <acowley> pqmodn: That's a pretty smart use of Prelude
16:48:20 <acowley> err
16:48:21 <acowley> base
16:48:24 <pqmodn> still not as magic as my childhood memory :(
16:48:42 <pqmodn> lefts is in Data.Either :\
16:48:57 <acowley> Yeah, stupid childhood memories of magically concise code
16:49:19 <arkeet> > toListOf (folded . _Left) . zipWith ($) (cycle [Left,Right]) $ "abcdefg"
16:49:21 <lambdabot>   "aceg"
16:49:30 <ij> :t CArray
16:49:31 <lambdabot> Not in scope: data constructor `CArray'
16:53:48 <user123abc> I've found that my program's heap blowup is due to memory in the drag state "which lasts from the final use until the last reference to the object is dropped."
16:53:59 <user123abc> could somebody help me to understand what this means and how I can combat it?
16:54:18 <ion> Request for comments: “Transforming mostly-monadic code to mostly-applicative code” https://gist.github.com/ion1/7016798
16:55:27 * jfischoff wishes for applicative do
16:55:41 <user123abc> the only bit of info I can find is a google search result for a paper on these terms
16:56:01 <user123abc> "Lag, Drag, Void and Use-Heap Profiling and Space-Efficient Compilation Revisited", but all links to it are dead
16:57:23 <ion> jfischoff: With this (unless i’m missing something important) the result of “do” unsugaring could be transormed to applicative form.
16:57:24 <gauthier_> can I restrict quickcheck to generate non empty bytestring?
16:57:41 * hackagebot clock 0.4.0.1 - High-resolution clock functions: monotonic, realtime, cputime.  http://hackage.haskell.org/package/clock-0.4.0.1 (CetinSert)
16:57:58 <hpc> gauthier_: you can make your test something like "bytestring is empty or this holds"
16:57:59 <user123abc> I just found this, which is pretty nice: http://www.google.com/url?q=http://www.cs.uu.nl/wiki/pub/USCS/InterestingPapers/HeapProfiling.pdf&sa=U&ei=VCZfUrHfEanYyQGQ3ICQCA&ved=0CBsQFjABOAo&sig2=gW0WbsDqqfOcdQ9D0n405Q&usg=AFQjCNHJEpZQAQKUKsjL09ylIlE6vsVLvQ
16:58:20 <user123abc> http://www.cs.uu.nl/wiki/pub/USCS/InterestingPapers/HeapProfiling.pdf
16:58:23 <startling> Google redirect URLS are so bad.
16:58:36 <ion> gauthier: prop_foo bs = (not . BS.null) bs ==> …
16:58:56 <gauthier_> hpc: I'm looking at this test: https://github.com/twittner/zeromq-haskell/blob/master/tests/System/ZMQ3/Test/Properties.hs#L51 how could I change it so quickcheck never generates empty bytestring?
16:59:05 <user123abc> I'm glad for your feedback, startling
16:59:12 <ion> gauthier: (That will still generate empty bytestrings but skip them for the property.)
17:01:11 <ion> gauthier: You could also do something like prop_foo (BS.pack . getNonEmpty -> bs) = …
17:02:39 <ion> gauthier: That will be :: NonEmptyList Word8 -> …
17:03:34 <gauthier_> ion / hpc: I guess I have to understand what is property in the above line, should I change the test registration (line I point) or should I change the actual function implementation?
17:03:51 <ion> gauthier: You probably should change the property.
17:04:18 <ion> “tests” is just a “list” of the tests specified elsewhere.
17:09:23 <ion> A third alternative (but i’d probably prefer the second one): prop_foo a b = forAllShrink genNEBS shrinkNEBS $ \msg -> … where { genNEBS = arbitrary `suchThat` not . BS.null; shrinkNEBS = filter (not . BS.null) . shrink }
17:10:39 <Clint> does the ghc trac have password resets disabled?
17:10:45 <ion> Hmm. This might be useful: forAllSuchThat f = forAllShrink (arbitrary `suchThat` f) (filter f . shrink)
17:11:29 <gauthier_> ion: I'm a bit lost (and probably dumb), would you mind pasting what you think the file should look like? (https://github.com/twittner/zeromq-haskell/blob/master/tests/System/ZMQ3/Test/Properties.hs#L51)
17:14:10 <gauthier_> ion: so that would be before the monadicIO, I think I'm on the track
17:14:34 <ion> gauthier: If you don’t mind enabling {-# LANGUAGE ViewPatterns #-}: prop_send_receive :: (SocketType a, SocketType b, Receiver b, Sender a) => a -> b -> NonEmptyList Word8 -> Property; prop_send_receive a b (SB.pack . getNonEmpty -> msg) = monadicIO $ do …
17:15:41 <ion> gauthier: If you don’t want ViewPatterns: prop_send_receive :: (SocketType a, SocketType b, Receiver b, Sender a) => a -> b -> NonEmptyList Word8 -> Property; prop_send_receive a b (NonEmpty msgList) = let msg = SB.pack msgList in monadicIO $ do …
17:16:27 <gauthier_> ion: that does compile :) thanks
17:17:20 <gauthier_> I'm suspecting that zmq does something weird on windows when the message contains some bizarre things
17:19:32 <jfischoff> is there a TH way to make hashable instances?
17:19:35 <gauthier_> ion/hpc: anything I can do about \nul too?
17:21:36 <enthropy> jfischoff: probably you can use Data too
17:21:41 <enthropy> @hoogle hash
17:21:41 <lambdabot> Data.HashTable module Data.HashTable
17:21:41 <lambdabot> Data.HashTable hashInt :: Int -> Int32
17:21:41 <lambdabot> System.Mem.StableName hashStableName :: StableName a -> Int
17:22:10 <jfischoff> its okay I'll just you the default instance
17:22:18 <jfischoff> s/you/use
17:23:23 <ion> gauthier: I suppose forAllSuchThat would be appropriate here. forAllSuchThat f = forAllShrink (arbitrary `suchThat` f) (filter f . shrink); prop_send_receive :: (SocketType a, SocketType b, Receiver b, Sender a) => a -> b -> Property; prop_send_receive a b = forAllSuchThat (\msg -> (not . SB.null) msg && 0 `SB.notElem` msg) $ \msg -> monadicIO $ do …
17:26:39 <gauthier_> ion: quickcheck does look amazing, and I guess this way I have full command on the predicate, thanks!
17:29:30 <ion> Note that for instance “forAllSuchThat (== 10000000) $ \n -> …” would be a horribly slow property because the random number generator will rarely generate 10000000. But “not null” is completely fine and “doesn’t contain 0 bytes” is not too bad.
17:30:43 <gauthier_> ion: I guess I'm slowly getting the concept, I just added "where length > 10" and it does what I meant, still not finding the bug I'm chasing though, not related to null or zero length strings
17:32:46 <ion> Another thing worth pointing out: the difference between “forAllSuchThat f (\x -> …)” and “\x -> f x ==> …” is that the former will keep generating values forever until f applies, the latter will give up if f is too restrictive.
17:37:08 <AlexS90> I need some help with Data.Vector.Fixed if anybody's feeling charitable
17:38:34 <acowley> AlexS90: You should just ask your question as available charity will depend upon its nature
17:39:00 <AlexS90> http://lpaste.net/94359
17:39:16 <AlexS90> seems like it should work but I'm a novice
17:42:14 <lpaste> enthropy pasted “should this indentation be accepted by ghc (it is?)” at http://lpaste.net/94360
17:42:17 <arkeet> AlexS90: Mtup isn't an instance of F.Vector. and it can't be, since it's a type synonym.
17:42:37 <acowley> If we get rid of type synonyms, g :: (Float,Float) -> (Vec3, Vec3)
17:42:53 <arkeet> good to do.
17:42:54 <acowley> so you're trying to F.map f over a tuple
17:42:57 * enthropy means it is accepted by ghc, not by haskell-src-exts
17:43:15 <Eduard_Munteanu> enthropy: seems reasonable
17:44:03 <ion> enthropy: Does haskell-src-exts parse it if you indend the (a,b) <- …, print … by one more space?
17:44:12 <ion> indent
17:44:12 <enthropy> of course it does
17:44:28 <enthropy> normal people do that kind of indentation
17:45:14 <AlexS90> acowley: F.map (+1) (1,2,3)   behaves as expected
17:45:18 <acowley> I thought the (a,b) *had* to be indented at least one more space
17:46:08 <lpaste> enthropy annotated “should this indentation be accepted by ghc (it is?)” with “should this indentation be accepted by ghc (it is?) (annotation)” at http://lpaste.net/94360#a94361
17:46:40 <acowley> enthropy: no
17:47:22 <enthropy> acowley: you mean it should be rejected?
17:47:36 <acowley> enthropy: I think so. But I am not the Haskell 2010 standard afaik
17:47:40 <enthropy> there is actual code in ghc which has such indentation
17:47:51 <acowley> ghc's code isn't idiomatic haskell :|
17:48:51 <chrisdone> enthropy: that looks fine to me
17:49:00 <chrisdone> oh, the second one, no
17:49:05 <acowley> They have the same problem
17:49:23 <chrisdone> yeah. i read the first one as being one column in
17:49:28 <chrisdone> parentheses confuse my eyes
17:49:38 <acowley> yeah, I tripped over that too
17:49:51 <enthropy> https://github.com/ghc/ghc/blob/master/compiler/llvmGen/LlvmCodeGen/CodeGen.hs#L1005
17:51:27 <chrisdone> hmmm
17:51:42 <dobblego> tommd: yo
17:51:49 <acowley> AlexS90: I'm afraid I don't know what's happening there. I'm not familiar with either of the libraries you're using.
17:52:12 <enthropy> " If the indentation of the non-brace lexeme immediately following a where, let, do or of is less than or equal to the current indentation level, then instead of starting a layout, an empty list "{}" is inserted, and layout processing occurs for the current level (i.e. insert a semicolon or close brace)"
17:52:15 <chrisdone> it could possibly be exploiting an old layout rule
17:52:30 <enthropy>  -- H98 report
17:52:53 <AlexS90> acowley: no problem, thanks for the look
17:53:05 <enthropy> and the same sentence seems to be in the H10 report
17:54:08 <enthropy> chrisdone: what's an old layout rule? Should I be looking in older standards?
17:55:19 <chrisdone> enthropy: istr there being a language extension about layout, could be wrong
17:55:26 <enthropy> yes there are some
17:56:20 <chrisdone> unless that ghc code just has some cheeky tabs in it
17:57:38 <enthropy> http://www.haskell.org/ghc/docs/latest/html/users_guide/bugs-and-infelicities.html#infelicities-syntax
17:57:46 <enthropy> there's a -XNondecreasingIndentation
17:57:49 <chrisdone> oh, huh
17:57:55 <chrisdone> ghc actually accepts that code
17:58:00 <chrisdone> with no extension
17:58:38 <chrisdone> foo = let bar = do
17:58:39 <chrisdone>           x <- undefined
17:58:39 <chrisdone>           undefined
17:58:39 <chrisdone>       in undefined
17:58:41 <chrisdone> ^ totally accepted
17:59:02 <chrisdone> it seems to be an effect of do-notation
17:59:19 <enthropy> right, they wouldn't say it's an infelicity if you had to enable it
17:59:33 * chrisdone reads the link
18:00:18 <chrisdone> right, that's the extension i meant
18:00:23 <chrisdone> chris@retina:~$ man ghc | grep Indent
18:00:24 <chrisdone> chris@retina:~$
18:00:24 <chrisdone> =(
18:00:40 <chrisdone> i guess my ghc is too old
18:00:49 <acowley> ugh
18:01:13 <johnw> ghcs don't get old, they just get wiser
18:01:14 <acowley> Why is that working by default?
18:01:28 <enthropy> chrisdone: you can  ghc --supported-languages | grep Non
18:01:47 <enthropy> it's not in my man ghc either
18:02:07 <hpc> @hackage ghc-man-completion
18:02:07 <lambdabot> http://hackage.haskell.org/package/ghc-man-completion
18:03:29 <chrisdone> enthropy: ヽ (＾▽＾) ﾉ
18:05:36 <enthropy> hpc: is it a feature that the more obscure flags are missing from the manpage?
18:08:46 <cgpehle> hmp3 fails to compile under fedora19 because apparently there is a conflicting declarations of getline in stdio.h, is this package still maintained?
18:09:04 <enthropy> ah so haskell-src-exts does support that extension, it's just disabled by default
18:10:26 <Hrumph> hi
18:11:20 <Hrumph> can i post two lines?
18:12:08 <elliott> you just did
18:12:12 <lpaste> Hrumph pasted “need function like this” at http://lpaste.net/94362
18:12:34 <Hrumph> i was wondering if there is a function like that so i don't have to use my own
18:13:32 <ion> fmapApp ff x = ff <*> pure x
18:13:46 <ion> Darn, an applicative constraint. :-P
18:14:02 <ion> @type (??)
18:14:03 <lambdabot> Functor f => f (a -> b) -> a -> f b
18:14:22 <ion> That comes with lens.
18:14:34 <ion> @type [(??), flip]
18:14:35 <lambdabot> [(a1 -> a -> c) -> a -> a1 -> c]
18:14:36 <chrisdone> worst operator name ever?
18:15:17 <chrisdone> “what's something that sounds… applicationy?” “how about two question marks” “sold, to the man in the clown suit”
18:17:42 <Hrumph> what lens package specificall do io find this in?
18:19:00 <acowley> I wish I had a clown suit
18:19:26 <Hrumph> you what package do i find (??) in?
18:20:18 <ion> hrumph: lens
18:20:35 <Hrumph> so its just import Lens then?
18:20:47 <ion> @hackage lens
18:20:48 <lambdabot> http://hackage.haskell.org/package/lens
18:20:49 <ion> Control.Lens
18:20:54 <Hrumph> ok
18:21:15 <Hrumph> are lenses worth learning about?
18:21:29 <ion> Yes, but i’m biased because i like them.
18:22:05 <monochrom> I haven't learned lens. to give you an outlier data point. :)
18:22:33 <Hrumph> are lenses more complicated that monads?
18:22:55 <monochrom> no
18:23:01 <chrisdone> i'm quite attracted to the traversals more than the actual typical lenses use
18:23:50 <chrisdone> i saw fclabels like 4 years ago and never bothered to use it, recordd field access is awkward but not painful enough for me to bother
18:24:00 <ion> hrumph: A couple of nice talks: http://skillsmatter.com/podcast/scala/lenses-compositional-data-access-and-manipulation | http://youtu.be/cefnmjtAolY?hd=1
18:24:11 <chrisdone> but i like the jquery-esque stuff in lens
18:25:56 <arkeet> chrisdone: it's kind of a clever name for flip though
18:26:00 <arkeet> it looks like a "hole"
18:26:09 <chrisdone> what does?
18:26:13 <arkeet> (f ?? x) y = f y x
18:26:23 <arkeet> ??
18:26:50 <ion> (f ¤ x)
18:27:01 <chrisdone> that's pretty obscure, heh
18:27:51 <chrisdone> hm, can ? be an operator?
18:27:53 <chrisdone> :t (?)
18:27:54 <lambdabot> Not in scope: `?'
18:27:58 <Hrumph> @type (??)
18:27:59 <lambdabot> Functor f => f (a -> b) -> a -> f b
18:28:07 <chrisdone> seems so. oddly i've never see anyone use ? for anything, that i recall
18:28:15 <Hrumph> i have a use
18:28:23 <chrisdone> it seems like ? wouuld make a good companion to !, but returning Maybe
18:28:28 <Hrumph> use for ?? i mean
18:28:54 <Hrumph> i made a type class some of the members are Maybe (x ->y)
18:29:05 <Hrumph> there's either nothing or a function
18:29:16 <Hrumph> so i want to apply the function when its not nothing
18:29:22 <Hrumph> otherwise presever nothing
18:29:39 <chrisdone> :t fmap . ($)
18:29:39 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:30:12 <Hrumph> chrisone that's not the type i want
18:30:20 <Hrumph> look at the type of ??
18:30:21 <chrisdone> i know
18:39:44 <Hrumph> great i'm now employing ??
18:41:29 <enthropy> what is the selling point for literate syntax for people who don't write paragraphs of comments?
18:42:18 <com> @ ^0
18:42:32 <com> @0^0
18:42:33 <lambdabot> Unknown command, try @list
18:42:41 <enthropy> > 0^0
18:42:42 <lambdabot>   1
18:42:49 <monochrom> no selling point indeed
18:42:57 <com> enthropy: why it is 1 ?
18:43:02 <monochrom> but I do write long comments sometimes
18:43:12 <monochrom> just sometimes, so don't you worry
18:43:16 <joelteon> @djinn f (a -> b) -> f a -> f b
18:43:16 <com> undefined was fine
18:43:16 <lambdabot> -- f cannot be realized.
18:43:21 <joelteon> @djinn Functor f => f (a -> b) -> f a -> f b
18:43:21 <lambdabot> Error: Class not found: Functor
18:43:36 <enthropy> com: I dunno. That's what you get in any case.
18:43:52 <pqmodn> @djinn Maybe (a -> b) -> Maybe a -> Maybe b
18:43:53 <lambdabot> f a b =
18:43:53 <lambdabot>     case a of
18:43:53 <lambdabot>     Nothing -> Nothing
18:43:53 <lambdabot>     Just c -> case b of
18:43:53 <lambdabot>               Nothing -> Nothing
18:43:53 <enthropy> is there a reversible unlit?
18:43:54 <lambdabot>               Just d -> Just (c d)
18:43:58 <monochrom> for example http://www.vex.net/~trebla/haskell/calculator/colour/Calculator.html :)
18:44:16 <com> Any refernce so  i can understand
18:44:34 <enthropy> as in, can I pretend that I am looking at a .hs when in fact I'm supposed to be changing a .lhs
18:44:37 <ion> com: a^(b+c) = a^b · a^c. Let b = 0. What should a^0 be?
18:44:40 <monochrom> actually, let me pinpoint it at http://www.vex.net/~trebla/haskell/calculator/colour/Calculator.html#euclid
18:45:00 <monochrom> I don't know. what "pretend"? I'm serious.
18:45:24 <monochrom> I think I don't understand the question. do you have a concrete example?
18:45:42 <enthropy> I can somehow get ghc to unlit a fle
18:45:58 <monochrom> ok yes, but must you unlit a file?
18:46:00 <enthropy> but I do not know if there's a way to un-unlit that file
18:46:29 <monochrom> oh haha, that's easy. put "\begin{code}" at the beginning, "\end{code}" at the end.
18:47:01 <monochrom> well, you could add "> " to every line instead, but that's more work :)
18:47:03 <enthropy> monochrom: I am looking at haskell-src-exts which uses a literate haskell (happy actually) file. It is based on ghc's parser which is not literate
18:47:34 <khyperia> Is there no standard function "(a -> a -> b) -> a -> b" that duplicates a and passes it in twice to the provided function?
18:47:41 <ion> khyperia: join
18:47:55 <khyperia> Ah, thanks. Wonder why that didn't show up in hoogle...
18:48:02 <enthropy> so the haskell-src-exts file is missing lots of new extensions invented in the last couple years (-XDataKinds, closed type families etc.)
18:48:06 <monochrom> I don't understand. I'm assuming there is a self-contradiction in "literate haskell (happy actually)". they look mutually exclusive.
18:49:45 <khyperia> wait... ion, where is it?
18:50:03 <ion> khyperia: Control.Monad
18:50:37 <enthropy> monochrom: the parser to be updated is: https://github.com/haskell-suite/haskell-src-exts/blob/master/src/Language/Haskell/Exts/InternalParser.ly. The newer parser is https://github.com/ghc/ghc/blob/master/compiler/parser/Parser.y.pp
18:51:26 <khyperia> ion, that doesn't seem to work for me... "join (*) 2" throws wonky errors.
18:51:37 <ion> > join (*) 2
18:51:39 <lambdabot>   4
18:51:41 <com> ion :0
18:52:21 <enthropy> or maybe the second file is supposed to be some other .y file in the ghc repository
18:52:25 <khyperia> um
18:52:29 <enthropy> monochrom: does is make sense now?
18:53:11 <khyperia> I get "No instance for (Monad ((->) a0))"
18:53:12 <ion> khyperia: Try importing Control.Monad.Instances
18:53:35 <khyperia> yep, that worked
18:53:42 <khyperia> thanks!
18:54:32 <ion> khyperia: That’s not required with newer versions of GHC. That instance is defined in GHC.Base nowadays.
18:55:08 <khyperia> Huh. Must be the ubuntu package being old, I usually go with windows
18:55:22 <heathjs> import Haskore.Basic.Duration((%+))
18:55:33 <heathjs> how did this guy create this operator?
18:55:36 <heathjs> jmcarthur: get over here
18:55:40 <heathjs> :)
18:56:10 <jmcarthur_mobile> Hey
18:56:23 <jmcarthur_mobile> I can't look right get now
18:56:27 <ion> khyperia: I install GHC on Ubuntu as follows: https://gist.github.com/ion1/2815423
18:56:30 <jmcarthur_mobile> After my late dinner maybe
18:56:36 <heathjs> thank you sir
18:57:28 <monochrom> enthropy: ok, I think from ghc's file to haskell-src-ext's file is a lot of human decision in what to copy, how to copy, what modification is needed, and adding "> " maybe with the help of an editor.
18:58:15 <khyperia> Ah, installing from source.
18:59:18 <enthropy> indeed. It's just that I don't know a tool that will ignore the > when it tries to mechanically match things up (say like diff)
19:06:38 <ion> heathjs: The source of the operator is linked from the package documentation.
19:06:59 <ion> khyperia: Nope, i install GHC from the binary tarball.
19:07:23 <khyperia> Oh, I'm silly
19:22:51 <jmcarthur> heathjs: so what is this you are asking about exactly?
19:22:52 <pqmodn> i understand ⊥ is an inhabitant of all lifted types. but isn't it also the notation for the absurd type (with no inhabitants)?
19:23:45 <pqmodn> well, maybe the value of ⊥ is an inhabitant of the type ⊥? like the empty tuple () is the one inhabitant of the type ()
19:24:03 <ion> I have usually seen the type being called 0.
19:24:03 <pqmodn> s/value of ⊥/value ⊥/
19:24:06 <elliott> pqmodn: it is an overloading of the name
19:24:26 <elliott> they are both bottoms of certain domains/(semi)lattices (or things like those)
19:25:06 <pqmodn> okay, thanks elliott
19:27:30 <ReinH> hai
19:31:26 <shelf> silly question - i'm looking at Control.Monad source, where exactly is Monad defined? I only see mplus http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Control-Monad.html
19:32:01 <pqmodn> shelf: in GHC.Base. you can query this in ghci using :info Monad
19:36:18 <pqmodn> shelf: unfortunately GitHub doesn't render lhs very well, but https://github.com/ghc/packages-base/blob/master/GHC/Base.lhs
19:37:01 <pqmodn> if you look at the raw source, search for "class  Monad" with two spaces
19:39:05 <jle`> is the source code for base really in lhs
19:39:09 <jle`> never knew that
19:39:24 <elliott> it varies
19:39:39 <shelf> pqmodn: thanks! didn't know about :info
19:40:43 <shelf> is there any syntax in Control.Monad that allows it to export another module's members? or do i need to get to grips with GHC first
19:42:34 <pqmodn> shelf: from the source, no Control.Monad doesn't re-export any values, but yes that's possible in Haskell
19:43:10 <pqmodn> oh, actually it exports Functor(fmap) and Monad((>>=), etc, ...)
19:43:47 <shelf> yeah, that's what i was referring to
19:44:23 <shelf> interesting. thanks for the help~
19:44:29 <pqmodn> you can see in the source for Control.Monad it imports GHC.Base, then in the module declaration it exports Functor and Monad with their members
19:44:32 <pqmodn> sure!
19:44:44 <pqmodn> s/members/methods
19:45:19 <jle`> `otherwise` is just an alias to True
19:45:23 <jle`> my mind is blown
19:45:29 <pqmodn> :)
19:45:45 <pqmodn> try {-# LANGUAGE NoImplicitPrelude #-} and see what you've taken for granted!
19:45:46 <johnw> wow, cool!
19:46:35 <carter> johnw:?
19:47:43 <johnw> otherwise
19:47:47 <johnw> i didn't know that
19:47:58 <jle`> yeah this whole time i thought it was just a language keyword
19:48:21 <carter> johnw: WAT
19:48:22 <carter> really?
19:48:24 <carter> :)
19:48:35 <carter> i only learned about how newtypes are ok for data families this week
19:48:45 <johnw> yeah, I've been using those for a while
19:49:00 <johnw> it's what monad-control uses, which is where I learned it
19:49:17 <johnw> otherwise, none of the docs about type families ever mentions that fact, I don't think
19:49:24 <carter> yeah
19:49:33 <carter> also never quite realized that data families give injectivity
19:49:42 <carter> though thats  obvious in retrospect
19:50:29 <johnw> yeah, kind of by definition, since the instance is making the type
19:50:50 <carter> yeah, unlike type families, data families can't forget the index
19:51:12 <johnw> i just tend to use type families until I hit the injectivity error :)
19:51:47 <carter> i need to make sure i get really really nice type inference for a bunch of upcoming project
19:51:48 <carter> s
19:52:54 <carter> I may also cook up a numberless prelude to force myself to start working alternatives
19:52:57 <carter> *working on
19:53:00 <enthropy> carter: is it going to be ghc-7.8 only?
19:53:04 <carter> enthropy: what is?
19:53:10 <enthropy> this is your linear algebra stuff right?
19:53:29 <carter> for now i'll be making it 7.6 based
19:54:43 <carter> enthropy: theres not really anytying in 7.8 that'll make it worth breaking 7.6 support http://ghc.haskell.org/trac/ghc/wiki/Status/Oct13
19:54:50 <carter> theres a lot of great stuff in 7.8
19:55:45 <carter> heh, neat, it now describes what i've been up to :)
19:56:02 <carter> plus leroux  and hvr and rwbarton, who've been AMAZING
19:57:44 <carter> enthropy: by the time 7.10 rolls around, there might be compelling reasons to drop 7.6
19:57:51 <carter> but CPP is easy
19:58:05 <carter> as long as i can give the same surface API on each ghc
19:59:02 <enthropy> but stuff like:   type family TypeEq a b where TypeEq a a = True; TypeEq a b = False -- makes for better syntax than the current implementation
19:59:11 <enthropy> you can't really support both
19:59:26 <carter> enthropy: i'm not really doing anything proofy right now
19:59:35 <carter> but if i wind up doing htat
19:59:40 <carter> then yess, i'll break all the things
19:59:52 <carter> enthropy: I am using DataKinds
19:59:55 <pqmodn> ion: thanks for those installation instructions, i found them useful.
20:00:00 <structuralist> PR question: How would you respond to "It's unclear to me what you can do in haskell data processing that you can't do pretty easily in Python. I regularly code in a functional style in Python, sometimes with monadic-like structures too."?
20:00:17 <carter> who's asking the question?
20:00:32 <structuralist> someone on a private mailing list
20:00:40 <structuralist> (private but large)
20:00:52 <dobblego> structuralist: they do not code in a functional style in Python.
20:01:03 <carter> 'cause guido makes it hard to do
20:01:06 <carter> and kinda awkward
20:01:09 <carter> *made it
20:01:18 <carter> also 100x slower than haskell :)
20:01:18 <dobblego> I guarantee you that nobody has ever done this.
20:01:24 <carter> oh
20:01:29 <carter> the monadic bit? yeah
20:01:31 <DarkLinkXXXX> Is there a standard way to programmatically execute the contents of a haskell source file?
20:01:32 <carter> not possible sanely
20:01:38 <dobblego> the "functional in python" bit
20:01:44 <carter> DarkLinkXXXX: call ghc ;)
20:01:46 <dobblego> it's simply intractable
20:01:58 <carter> well, python don't have lexical scoping
20:01:59 <carter> sooooo
20:02:00 <carter> theres that
20:02:24 <carter> any language which can't distinguish between declaring and setting variables is kinda hosed that way
20:02:31 <carter> *doesn
20:02:33 <carter> t
20:03:02 <carter> dobblego: hello :)
20:03:45 <structuralist> hmm, I've never used python
20:04:00 <dobblego> structuralist: I have and you are luckier than I am.
20:04:06 <structuralist> haha
20:04:24 <carter> dobblego: i was very sad that day i had to use the global and local keywords to make some code sane
20:05:32 <dobblego> I have a funny story re: python. I had a colleague who argued that python was great because no static types and to him, this meant no type ascriptions. So he showed me this 5 or 6 lines of python and said, "see no static types, unlike that messy haskell nonsense." Turns out it was a valid haskell program, so I compiled it with GHC.
20:06:54 <carter> it was syntactically valid haskell and python?
20:07:00 <dobblego> yes
20:07:13 <carter> hrmmmmm
20:07:25 <carter> i'm trying to figure out a cute example that size that works
20:07:30 <carter> so only using prelude ops
20:07:34 <carter> and no function defns
20:07:35 <carter> right?
20:07:46 <dobblego> it was something like: x = 3 and there was a print(x)
20:07:50 <dobblego> I forget the details
20:08:15 <carter> yeah
20:08:17 <carter> that'd work
20:09:15 <carter> dobblego: so i'm starting to plan out whats needed to get a fixed numerical prelude in 7.12 or 7.14
20:09:19 <carter> mwahahahahahah
20:09:23 <johnw> 7.28 FTW!
20:09:33 <dobblego> are you not just removing Enum t => Integral t?
20:09:51 <carter> dobblego: its a bit more deeply broken than that
20:10:00 <carter> abs really really really shouldn't be in Num
20:10:14 <carter> and currently you can't really use complex numbers that aren't Floating point
20:10:14 <dobblego> crikey, good luck with that
20:10:38 <carter> dobblego: notice how i said 7.12 or 7.4
20:10:44 <carter> so 2-3 years
20:10:50 <carter> *7.14
20:10:53 <carter> out
20:11:37 <carter> dobblego johnw  well, if i get my numerical stuff widely used, i can do a slow boil via that
20:11:55 <Hrumph> is there a more succinct way to do maybe False (\x -> True) maybeVal
20:12:31 <dobblego> hrefchef: Data.Foldable#null
20:13:13 <dobblego> oh wait, there isn't such a thing
20:13:18 <pqmodn> @type isJust
20:13:19 <lambdabot> Maybe a -> Bool
20:13:25 <dobblego> yeah that
20:13:27 <Hrumph> ok thanks, that sounds good
20:13:30 <Hrumph> isJust
20:13:33 <startling> :t has _Just -- if you're already using lens
20:13:34 <lambdabot> Maybe b -> Bool
20:13:36 <dobblego> Hrumph: yes use isJust
20:13:47 <carter> johnw: dobblego  i'll probably make sure the initial numerical release won't require noimplicprelude
20:13:51 <carter> and then slow boil from there
20:15:03 <carter> night all
20:15:29 <dobblego> scratchya
20:44:53 <dobblego> does there exist a HXT example with a pickler that includes the whitespace from the document?
20:54:04 <carter> i'm glad for optparse-applicative, but tis a bit voodoeey to get use to
20:54:14 <carter> but all appicatives kinda are
21:00:38 <heath> > (%+) :: Integer -> Integer -> T
21:00:38 <heath> > (%+) x y = fromRatio (x%y)
21:00:39 <lambdabot>   Not in scope: type constructor or class `T'Not in scope: `%+'
21:00:40 <lambdabot>  Perhaps you ...
21:00:40 <lambdabot>   can't find file: L.hs
21:01:13 <carter> heath: ghci dosne't work that way
21:01:25 <heath> jmcarthur: that's what i was wondering about
21:01:50 <heath> carter: I was just pasting in something from from a literate haskell file, not really caring if lambdabot evaluated it correctly :)
21:01:57 <carter> ahh
21:02:11 <carter> i find it worrisome that my rank on http://ircbrowse.net/ is going up
21:02:16 <carter> despite me having more consulting work
21:03:21 * hackagebot errors 1.4.3 - Simplified error-handling  http://hackage.haskell.org/package/errors-1.4.3 (GabrielGonzalez)
21:04:47 <jmcarthur> carter: yeah i was very concerned when i found out i was the second most talkative person here at one point. i have since shut up (but not just because of that).
21:05:01 <carter> jmcarthur: also busy right?
21:05:07 <jmcarthur> heath: so what is the question exactly?
21:05:37 <jmcarthur> carter: well, and realizing i should get a life
21:05:42 <carter> i'm wokring on it
21:05:56 <carter> jmcarthur: i'm just glad they don't count all the other irc channels i'm on
21:05:58 <carter> or i'd be hosed
21:06:53 <heath> jmcarthur: PM
21:10:41 <dmj`> any idea when mio will be added to ghc
21:11:18 <carter> dmj`: isn't it in head?
21:11:37 <carter> yup
21:11:40 <carter> dmj`: its in head http://ghc.haskell.org/trac/ghc/wiki/Status/Oct13
21:11:43 <dmj`> well well
21:12:06 <dmj`> more reason to learn ghc
21:12:07 <carter> dmj`: if you want more nice things
21:12:11 <carter> contribute ! :)
21:12:16 <carter> if you read the bottom of the page
21:12:28 <carter> apparently my main skill has been talking more people into dabbling with ghc :)
21:12:41 <carter> if i can do it, you can do it better
21:12:44 <carter> mwahaha
21:12:57 <dobblego> has anyone come up with a decent solution for literal strings yet?
21:13:18 <carter> dobblego: in which sense?
21:13:29 <dobblego> consider scala, val x = """hi " there"""
21:13:39 <carter> dobblego: we have overloaded strings...
21:13:43 <carter> ohhh
21:13:46 <dobblego> yeah but literal?
21:14:02 <enthropy> dobblego: quasiquoter?
21:14:04 <dmj`> carter: I know, i like nice things, I can't put it off. I see that 'ghc commentary'
21:14:04 <carter> you mean where you want to do """"  multi line epic """""
21:14:11 <dobblego> carter: yes
21:14:19 <enthropy>  [x| multiline epic |]
21:14:22 <carter> yeah
21:14:23 <carter> that'd work
21:14:32 <dobblego> oh right yeah thanks
21:14:33 <carter> dmj`: start with one area of ghc you want to underatnd
21:14:36 <enthropy> or whatever letter(s) you like to call the quasiquoter
21:14:47 <carter> enthropy: lets call it epic
21:15:09 <enthropy> there are about 8 of those already on hackage http://www.haskell.org/haskellwiki/Quasiquotation
21:15:09 <carter> dmj`: theres SOOOO much low hanging fruit
21:15:22 <enthropy> please don't make another one called epic
21:15:29 <enthropy> unless it actually is ;)
21:15:54 <dobblego> I want to write a document for which I have a parser and then run a [doc]test on it
21:16:22 <enthropy> do you know doctest supports multiline stuff?
21:16:32 <dobblego> yes, but string literal?
21:16:44 <enthropy> well you can use a quasiquoter in them
21:16:48 <carter> you'll probably find a neat bug or two :)
21:16:53 <carter> or it'll work
21:17:04 <dobblego> yeah I will use a quasiquoter in the doctest
21:17:05 <enthropy> only issue is that you aren't allowed blank lines
21:17:15 <dobblego> yeah I have discovered that
21:17:37 <colluphid> since (=~) does not necessarily return the same value, given the same parameters, is it considered impure?
21:17:52 <dobblego> colluphid: what is (=~)?
21:17:55 <enthropy> so something like >>> :{\nlet herestr = [heredoc|\n\n|]\nin herestr\n:}
21:17:58 <enthropy> that's going to fail
21:18:23 <acomar>  colluphid: that only works in state, right?
21:18:42 <acomar> colluphid: so if you runState with the same initial state, you get the same result
21:19:23 <dmj`> carter: alright back on the mailing list
21:19:24 <colluphid> acomar: i dont understand
21:19:33 <carter> dmj`: eh?
21:19:41 <augur> bentnib: shouldnt you be in #ml? :P
21:19:50 <dmj`> carter: ghc-devs
21:19:51 <colluphid> dobblego: regex pattern matching
21:19:52 <augur> (i dont think #ml is for ml)
21:19:55 <carter> dmj`: cool
21:20:04 <acomar> ahh sorry colluphid, thought that was a lens operator
21:20:04 <dobblego> colluphid: please link this function
21:20:06 <carter> also subscribe to ghc trac
21:20:07 <acomar> it has the look of one
21:20:12 <carter> but have it auto filtered into a folder
21:20:16 <carter> because its pretty high volume
21:20:22 <carter> so you can see what other people are woring on
21:20:35 <carter> or not :)
21:20:53 <edwardk> colluphid: you mean the operator from the regex libs?
21:21:03 <colluphid> yes
21:21:08 <edwardk> i love how everyone sees an operator and just assumes its something from lens they haven't seen before ;)
21:21:09 <colluphid> dobblego: http://hackage.haskell.org/package/regex-posix-0.95.2/docs/Text-Regex-Posix-Wrap.html#v:-61--126-
21:21:23 <edwardk> colluphid: its a pure function, its just overloaded on the return type.
21:21:34 <edwardk> and has a horrible ad hoc api copied fom perl
21:22:52 <heath> augur: ping
21:23:02 <augur> heath: pong
21:24:24 <edwardk> (=~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
21:24:34 <edwardk> that function is almost as obvious as a lens combinator
21:29:29 <carter> is that a complicment or a curse?
21:35:17 <carter> ok
21:35:24 * carter off the interwebs for reals
21:35:32 <dmj`> carter: excited to see snaps perf w/ mio
21:35:37 <dmj`> zoom zoom zoom
21:35:59 <dmj`> sry its late
21:54:36 <joelteon> how do qq interpolations work?
21:54:44 <joelteon> like [st|foo #{some arbitrary expression} bar|]
21:54:51 <joelteon> how do you splice arbitrary expressions in th?
21:55:29 <kvda> anyone used scotty with persistent-simple?
21:55:43 <kvda> urm.. postgresql-simple
21:56:49 <enthropy> joelteon: when you define st, it has to handle whatever's in between differently
21:57:39 <enthropy> here is one example http://code.haskell.org/~aavogt/Rlang-QQ/src/RlangQQ/Antiquote.hs
21:57:40 <joelteon> does that mean i'd have to parse it myself
21:58:12 <enthropy> @hackage frquotes -- another approach
21:58:12 <lambdabot> http://hackage.haskell.org/package/frquotes -- another approach
21:58:37 <joelteon> i don't understand what either of these are for
21:58:50 <sol1> i'm working on a small parser and get following error: *** Term           : BinaryOp (fromJust (readOp ts)) t e
21:58:51 <sol1> *** Type           : IntExpr
21:58:52 <sol1> *** Does not match : (IntExpr,[String])
21:58:52 <sol1> , on this code:
21:58:54 <sol1> readExpr :: [String] -> (IntExpr, [String])
21:58:54 <sol1> readExpr xs
21:58:55 <sol1> 	| readOp ts == Nothing = (t,ts)
21:58:57 <sol1> 	| length xs > 2 = (BinaryOp (fromJust(readOp ts)) t e)
21:59:01 <sol1> 	| otherwise = error "Syntax error: Expected an expression."
21:59:03 <sol1> 	  where (t,ts) = readTerm xs
21:59:05 <sol1> 		(e,es) = readTerm ts
21:59:17 <enthropy> sol1: why are you using hugs?
21:59:19 <joelteon> oh, parseExp
22:00:14 <sol1> is ghci better?
22:00:46 <enthropy> joelteon: that extractAntiquotes turns  "blah blah $(valid haskell expression) blah" into   [Right "blah blah ", Left validhaskellexpression, Right " blah"]
22:00:53 <joelteon> I see
22:00:57 <joelteon> oh, that's cool
22:01:08 <enthropy> where validhaskellexpression is what you might get from [|valid haskell expression|]
22:02:46 <enthropy> that frquotes preprocessor turns  «abc {x y z} def» into something like    [x|abc |] <> (x y z) <> [x| def|]
22:02:50 <pavonia> sol1: That "length xs > 2" branch has to return a pair, but it isn't
22:04:37 <joelteon> is there a string version of attoparsec/parsec
22:04:48 <joelteon> for quoters
22:09:00 <enthropy> @hoogle Parser a -> String -> m a
22:09:00 <lambdabot> No results found
22:09:28 <enthropy> well hoogle may be useless, but yes there are functions to do such things
22:21:25 <zRecursive> @djinn Parser a -> String -> m a
22:21:25 <lambdabot> Error: Undefined type Parser
22:41:45 <xico> in ghc's api, is there a way to convert a Name to a String representation?
22:43:32 <xico> (got it)
22:45:39 <xico> (now wondering about String -> Name)
22:49:11 <pavonia> xico: mkName, IIRC
22:51:10 <xico> in th yes
22:55:35 <enthropy> being hygenic is important
22:56:46 <enthropy> if it works, it's better to use 'X or ''X instead of (mkName "X")
22:58:09 <xico> sure. but i am not using th
22:58:28 <xico> it's GHC.Name
23:01:10 <pavonia> What package/module is that?
23:01:11 <dobblego> Using HXT, is it possible to parse a document (e.g. String) without the result being in IO?
23:01:31 <dobblego> oh just found the answer, oops
23:01:32 <xico> pavonia: ghc
23:17:53 <beefcube> is there an industry where the language used isn't that important? I ask because I want to continue to work in Haskell, but I don't see anything out there that's entry level (graduating with BS CS soon)
23:18:35 * hackagebot krpc 0.4.1.0 - KRPC remote procedure call protocol implementation.  http://hackage.haskell.org/package/krpc-0.4.1.0 (SamTruzjan)
23:18:39 <dobblego> beefcube: you can create your own
23:18:45 <Heffalump> beefcube: that would imply finding a job where you are the first coder on an independent project
23:22:04 <Tene> beefcube: Most industries, the only relevance of the language is working with an existing codebase.
23:22:57 <Tene> beefcube: So, it's more to do with individual companies than to do with industries.  If you can find a company that runs many small components all interoperating over RPC, HTTP, etc. then you'll have a much easier time adding a new component written in a different language.
23:25:02 <Tene> My current company has some haskell, as does my previous company.
23:25:55 <Tene> My previous company is in the 'virtual pants' industry, and my current company is in the 'almost everything' industry, but primarily ads and search.
23:25:58 <dobblego> I have never not used haskell at a company in the last 10 years, because it was the most appropriate tool for whatever job I had to do. Don't be told otherwise without a good reason.
23:26:36 <beefcube> oh, I was thinking of analytic work of some kind, where the software was a byproduct
23:59:46 <earthy> the main reason I'm currently *not* doing haskell is because I'm the teamlead for a team of which I'm the only one knowing Haskell
