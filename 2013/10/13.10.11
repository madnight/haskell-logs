00:02:11 <aXqd> hi, all, I wonder how you guys distribute haskell programs to production environment without haskell-platform. So far, i'm using '-static -optc-static -optl-static' to make it totally static, even for glibc (otherwise it always complaints about the GLIBC_VERSION). is this the standard way to go?
00:04:13 <Polarina> aXqd, all the haskell modules should be statically linked by default. You can use the { ldd } tool to see what dynamic libraries your executable depends on.
00:09:50 <aXqd> Polarina: Yes, that's what i'm doing right now. I just don't know, in real world production environment, static-link all modules and even glibc is the common pattern & practice. we have never used haskell in production before. this is our first time.
00:11:11 <startling> aXqd, I think that's about it.
00:13:09 <Polarina> aXqd, I don't know how others would do it, but I would not statically link glibc nor libgmp. That'd just cause issues for your users.
00:13:09 * hackagebot sized-vector 0.0.2.5 - Size-parameterized vector types and functions.  http://hackage.haskell.org/package/sized-vector-0.0.2.5 (HiromiIshii)
00:13:09 * hackagebot pandoc-citeproc 0.1.2 - Supports using pandoc with citeproc  http://hackage.haskell.org/package/pandoc-citeproc-0.1.2 (JohnMacFarlane)
00:18:02 <aXqd> libgmp is ok to be dynamic linking, because we can handle it with apt-get/yum. to staically link glibc is because the GLIBC_VERSION, maybe we can try to change to an older build enviroment. Frankly speaking, i'm not quite comfortable with cabal, to me, which is not quite usable in production.
00:22:52 <elliott> statically linking glibc is a bit scary.
00:23:00 <elliott> there are some parts it wants to dynamically load anyway.
00:23:36 <elliott> anyway, statically linking glibc but not libgmp?! that sounds very weird :)
00:24:04 <startling> doesn't optl-static include libgmp?
00:25:15 <startling> (It does.)
00:33:31 <aXqd> we get 3 major linux distributions, many different os/kernel versions and 5k physical machines. the operation, so far, is a mess. installing haskell-platform is especially a nightmare to me. I guess statically-linking is the best option now.
00:35:25 <startling> aXqd: it makes sense to me.
00:37:32 <safinaskar> is call/cc possible in haskell? if yes, then let's consider the following example: callCC (\f -> f 3 + f 5).  what is the value of this expression? 3 or 5? as you can see, the value depends on order of executing operands
00:37:54 <safinaskar> so, haskell with call/cc is not pure functional lang, right?
00:38:14 <johnw> f 3 + f 5 doesn't type check
00:38:47 <safinaskar> johnw: okey, so let's rewrite it somehow. for example, length [f3, f5]
00:38:59 <safinaskar> johnw: or const 2 (f 3) + const 2 (f 5)
00:39:01 <johnw> that won't evaluate f 3 or f 5
00:39:05 <johnw> neither will that
00:39:22 <johnw> the beauty of monads in that they enforce sequentiality
00:39:34 <johnw> so any scenario in which you can call f 3 or f 5, will enforce sequencing
00:39:46 <johnw> which means you will know which is going to be called
00:40:10 <safinaskar> johnw: so, callCC is possible in monads only?
00:40:14 <johnw> right
00:40:32 <johnw> it requires ContT
00:40:32 <fizruk> :t callCC
00:40:34 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
00:40:38 <johnw> or MonadCont
00:40:40 <shachaf> safinaskar: There is no first-class callCC in Haskell.
00:40:52 <shachaf> You can use Cont or similar to get a similar effect.
00:42:14 <safinaskar> johnw: fizruk: shachaf: thanks
00:43:07 <shachaf> "possible in monads only" makes it sound like monads are magic or something.
00:43:30 <shachaf> There's nothing magical about it. You have to rewrite your program in CPS by hand. It's just that with the right abstraction you can make that very straightforward.
00:43:34 <johnw> I read him as meaning "not available everywhere"
00:44:21 <startling> it is available everywhere, though.
00:44:56 <johnw> but you can't use it outside of a MonadCont
00:45:44 <startling> I mean, like every other haskell expression you can only use it where the types work out.
00:54:13 <peder> is there a way to replace a function in a module loaded?
00:54:15 <kqr> johnw, f 3 + f 5 type checks given a reasonable Num instance for f
00:54:34 <peder> and have access to local functions in that module
00:55:01 <kqr> peder, you can not load the function in the module and write your own version. "import Data.List hiding nub" will import all of Data.List except nub, and then you can write your own nub version
00:55:28 <kqr> peder, you could also use this to create a module that re-exports most of Data.List but with your own versions for some of the functions
00:57:50 <startling> it won't really "replace" it though.
00:58:07 <startling> If some other function in the module uses e.g. "nub", it'll still use the old one.
00:59:17 <johnw> kqr: I was referring specifically to the f which is passed by callCC
00:59:18 <kqr> well yeah, if it imports Data.List. not if it imports the special module you create which exports most of Data.List and then some of your own replacements
00:59:27 <kqr> johnw, oh, i must have missed out on some context. sorry
01:00:01 <peder> startling: yes, and thats what i want to do... make the other functions in the module use my new one...
01:00:30 <startling> peder, the only way to do that is to change the source of the module.
01:07:02 <peder> startling: had hoped i wouldn't need to do that :)
01:28:24 <Taneb> Can anyone tell me a use case for Data.Dynamic?
01:34:43 <frihd_1> Taneb:  i use it in a DSL to let users write setVar "name" <someObj> and later "getVar "name", i could ask users to specify the type of all their variables so that we can typecheck but eventually it would boil down to ask users to re-write a "mini-version of dynamic" with a union type
01:35:54 <frihd_1> Taneb: here https://github.com/lucasdicioccio/laborantin-hs/blob/master/examples/main.hs L31 & L34
01:42:26 <alexander__b> I'm doing a multithreaded programming course in which we'll look at pthreads, boost, SDL, SFML, C++11 and MPI. I thought that while doing this course (it's C and C++-based) I'd look at how to do this stuff in haskell as well. any pointers? (no, not those kind of pointers!)
01:43:00 <alexander__b> TBH I'm such a newbie I don't even know if you *do* explicit threading in haskell
01:43:58 <alexander__b> p.s. we'll look at implicit threads a bit too, so resources on that would be nice too
01:46:50 <Taneb> frihd_1, thanks
01:46:59 <Iceland_jack> alexander__b: Check out Control.Concurrent and Simon Marlow's book http://chimera.labs.oreilly.com/books/1230000000929/index.html
01:47:16 <alexander__b> Iceland_jack: thanks!
01:47:24 <Iceland_jack> Launching a thread is as easy as:
01:47:24 <Iceland_jack>     forkIO (forever (putStrLn "Help!"))
01:47:40 <elliott> we also have more lightweight parallelism support for pure computations.
01:48:06 <Iceland_jack> yes
01:51:46 <alexander__b> Iceland_jack: nice
01:53:37 <arkeet> I should read simon marlow's book
01:54:18 <kqr> i should too
01:57:17 <Jookia> Out of pure interest, would it be possible to implement Haskell as a scripting language in an application, and also be able to get code coverage and profiling of it?
02:00:05 <haasn> Jookia: there's a C-to-Haskell FFI
02:00:12 <haasn> so you can call Haskell functions from foreign (C) code
02:00:42 <haasn> (I sort of assumed that's what you meant. I just realized you could have also meant using Haskell to script Haskell applications, which is doable in lots of different and interesting ways)
02:01:31 <haasn> (Of course you could always run compiled Haskell programs as separate processes altogether and interact with them that way, that goes without saying. You could get profiling and stuff that way too. I don't know about profiling via the FFI)
02:02:00 <Jookia> Hmm. I'll have to look in to it.
02:23:18 * hackagebot libcspm 1.0.0 - A library providing a parser, type checker and evaluator for CSPM.  http://hackage.haskell.org/package/libcspm-1.0.0 (ThomasGibsonRobinson)
02:23:20 * hackagebot cspmchecker 1.0.0 - A command line type checker for CSPM files.  http://hackage.haskell.org/package/cspmchecker-1.0.0 (ThomasGibsonRobinson)
03:12:55 <srhb> Hoi
03:12:57 <srhb> MT
03:24:31 <kuznero> Hi All!
03:27:08 <SwineFlu> Hey, Can anyone tell me the package name for haskell platform on Linux mint
03:27:10 <SwineFlu> I can't find it
03:27:16 <SwineFlu> I've tried Haskell-Platform
03:29:09 <srhb> SwineFlu: http://community.linuxmint.com/software/view/haskell-platform
03:29:26 <srhb> SwineFlu: So presumably "haskell-platform"
03:29:56 <srhb> SwineFlu: That said you're probably better off installing ghc and cabal-install
03:32:29 <SwineFlu> Hmm, I tried that one
03:35:53 <lpaste> kuznero pasted “http-conduit, urlEncodedBody problem” at http://lpaste.net/94149
03:36:21 <kuznero> Hi All! Can someone please help me make sense out of it? http-conduit, urlEncodedBody...
03:40:50 <fizruk> kuznero: no expert, but I think that should be `let body = urlEncodeBody ...`
03:41:16 <kuznero> same thing
03:41:19 <kuznero> :(
03:42:48 <fizruk> hmm... should not be the same (at least second error should dismiss)
03:43:38 <kuznero> yes, you're right, one is still left
03:45:42 <fizruk> kuznero: oh, actually both disappeared and a new one came up: "Ambiguous type variable `m0' ..."
03:45:49 <kuznero> Possible fix: add a type signature that fixes these type variable(s)
03:45:51 <kuznero> yep
03:46:48 <fizruk> kuznero: that is because you are not using body and haven't given it explicit type signature
03:47:13 <kuznero> fizruk: what then should be the type?
03:47:14 <fizruk> kuznero: so there is no clue for the compiler to infer what's `m` in `Request m` should be
03:47:27 <fizruk> kuznero
03:47:47 <fizruk> kuznero: not sure, but probably Request IO
03:48:03 <kuznero> fizruk: thanks, let me try that...
03:48:39 <kuznero> wow! that worked :)
03:48:44 <kuznero> fizruk: thanks a lot!
03:49:12 <fizruk> kuznero: just as they say: follow the types... ;)
03:49:36 <kuznero> :) yeh, not so simple for the beginner :)
04:00:17 <kentroid> Howdy, So I made a lot of progress on my Haskell SDL game :) I was wondering if anyone wanted to help me refactor it/peer review it. As a FP newbie I can't tell if the code is good or not haha The main file is Boxxle.hs You can post here or on my GitHub, thanks! https://github.com/kennycason/haskell_boxxle
04:02:50 <Lethalman> kentroid, what about a data Tile
04:03:12 <zomg> Yeah was thinking the same, instead of having tEmpty tBrick and all that as 0 1 2 3... you would have an actual data type for that
04:03:28 <brainacid> good morning
04:04:15 <brainacid> When using function composition. Does it mean I can simply type func x = map . x . unLines
04:04:34 <brainacid> or doe I have to build it up simplifying as I go
04:04:44 <ciaranm> :t map . x . unLines
04:04:47 <kentroid> I did think about that but then realized this is as complex as my map was going to get so Ints were probably ok
04:04:48 <lambdabot>     Not in scope: `unLines'
04:04:48 <lambdabot>     Perhaps you meant one of these:
04:04:48 <lambdabot>       `unlines' (imported from Data.List),
04:05:00 <fizruk> :t map . ?? . unlines
04:05:01 <lambdabot> parse error on input `??'
04:05:09 <Lethalman> kentroid, roomBuilder can still take [[Int]]
04:05:14 <brainacid> just an example
04:05:28 <brainacid> just seeking clarification on composition
04:05:32 <Lethalman> kentroid, you map from Int to Tile within roomBuilder
04:05:45 <kentroid> ah I see
04:05:52 <Lethalman> tiles = map mapTile tiles
04:05:55 <fizruk> brainacid: composition is as simple as (f . g) x = f (g x)
04:06:00 <Lethalman> that is when creating a Room
04:06:36 <brainacid> fizruk, So i can just go compose basicly ... getLine = map . myLine . byLine
04:06:40 <fizruk> brainacid: you can combine as many functions as you want: (f . g . h) x = f (g (h x))
04:06:57 <brainacid> I see... its basic factorization
04:07:02 <kentroid> wow, github makes my indentation look very strange ...
04:07:26 <fizruk> brainacid: map . myLine . byLine = \x -> map (myLine (byLine x))
04:07:30 <zomg> kentroid: looks like it's tabs? You probably should use spaces with haskell
04:07:38 <fizruk> brainacid: I'm not sure that's what you want
04:08:00 <kentroid> fizruk: yes, I actually thought I replaced my tabs with space ><
04:09:24 <brainacid> fizruk, I believe that im clear. thank u
04:09:40 <brainacid> fizruk, I dont have to evolve the function is what Im trying to say
04:10:28 <kentroid> heh, the moment i replaced tabs with spaces i had a compile issue due to spacing (going to fix)
04:12:31 <tdammers> $ echo ':set expandtab' >> ~/.vim/ftplugin/haskell.vim
04:12:44 <kentroid> basically every single spot I have a where (code) where (code) the second where has a parse error
04:12:51 <kentroid> I don't understand why
04:12:55 <tdammers> ah
04:13:15 <tdammers> look into how Haskell's layout rules work
04:13:21 <tdammers> the where keyword introduces layout
04:13:41 <tdammers> which means that the first token after it establishes a horizontal alignment reference
04:13:54 <xpika> what is the key combination for autocompletion in Leksah?
04:14:08 <tdammers> anything indented less than that reference point ends the layout block
04:14:31 <kentroid> tdammers: thanks :)
04:17:16 <kentroid> fixed it :D
04:18:17 <kentroid> looks much better in github now
04:27:39 <quchen> Is there some other extension than RankNTypes that allows me to write foralls in `type` declaraions? I'd like the program to complain when I accidentially use a rank-2-type, but I need foralls nevertheless
04:27:44 <quchen> s/program/compiler
04:29:07 <brainacid> GOt my Walmart HP laptop with Ubuntu now! Tried twice last night to keep Win8 and it failed to boot. SO I said screw it
04:29:25 <brainacid> Installin haskell on it now...its awesome!
04:29:33 <brainacid> I wish Linux was written in Haskell
04:30:09 <donri> i wish linux was a microkernel written in rust ;)
04:30:22 <ocharles> well, if you use nixos, at least you get parts of Haskell ;)
04:30:37 <donri> nix isn't even written in haskell :(
04:30:51 <donri> mm_freak_: how's your dependently typed kernel coming along? :D
04:31:07 <fizruk> quchen: ExplicitForAll ?
04:31:42 <chrisdone> fizruk: +1
04:31:50 <danr> quchen: and ScopedTypeVariables
04:32:22 <quchen> Oh, right.
04:32:27 <ocharles> donri: i don't think stuff needs to be written in haskell, just follow the same philosophy
04:32:31 <quchen> ExplicitForAll is probably precisely what I want.
04:32:49 <ocharles> until we nail type erasure for dependently typed languages, I'm not sure you're going to get much useful stuff out of a dependently typed kernel
04:33:49 <quchen> Hmm no, none of those extensions help :-/
04:34:29 <quchen> I guess I'll have to make sure that what I'm doing is correct manually
04:45:58 <mlen> Hello :) Beginner question: how can I convert this implementation to be able to do let x = (x + 1 :: Natural) in x > 10 ? http://lpaste.net/4188941321014083584
04:48:44 <albertid> mlen, doesn't "in" expect an assignment?
04:48:55 <albertid> oh sorry, misread
04:48:57 <albertid> nvm
04:49:16 <mrmonday> what's the best way to perform an operation on a sublist? eg something like foldl someFunc 0 arr but with a start and end index?
04:50:11 <int-e> mlen: you can define   a + (Suc b) = Suc (b + a)
04:51:35 <lieven_> mrmonday: work on (take n (drop k arr))
04:52:31 <mlen> int-e: I think that my main problem is that when I say let x = 10 :: Natural, and then :print x it shows it is fully evaluated (even when I derive show instead of definging it)
04:53:10 <fizruk> > (\n m xs -> take n xs ++ [sum (take (m - n) . drop n) xs] ++ drop m xs) 2 5 [1..10]
04:53:11 <lambdabot>   Couldn't match expected type `[[a0] -> a0]'
04:53:11 <lambdabot>              with actual type `...
04:53:24 <mrmonday> lieven_: ooh, thanks :)
04:53:34 <fizruk> > (\n m xs -> take n xs ++ [sum (take (m - n) . drop n $ xs)] ++ drop m xs) 2 5 [1..10]
04:53:34 <lambdabot>   [1,2,12,6,7,8,9,10]
04:55:36 <pavonia> off by one
04:56:30 <int-e> mlen: ok, I actually tried this time:  Zero + n = n; Succ n + m = Succ (m + n)  works for  let x = 1 + x in ...  but it's very sensitive to the order of arguments.
04:59:48 <merijn> edwardk: Did you design the look of http://lens.github.io/ yourself? Or did you get someone else to do the web design for it?
05:00:11 <mlen> int-e: do you know if there is the way to make it work both ways? (1 + x and x + 1)
05:01:45 <merijn> mlen: There isn't you have to do structural recursion in one of the arguments and each choice will break one of the two
05:01:52 <int-e> mlen: no. I'm certain that it can't be done without resorting to hacks like unambigous choice.
05:02:31 <donri> merijn: 1) import bootstrap, 2) add giant stock images, 3) done
05:02:34 <merijn> mlen: Do you just want to encode infinity, though? Because that can be done without the +
05:02:50 <merijn> mlen: Just do "fix Suc" and done :)
05:03:06 <chrisdone> mrmonday: a lense might be a nice way to encode operations on a sublist
05:03:22 <merijn> And the comparison "fix Suc > 10" will even work
05:03:22 <fizruk> merijn: couldn't what mlen be done with zip-like (+) ?
05:03:29 <mlen> int-e, merijn: thanks for help :)
05:03:39 <fizruk> s/what mlen/what mlen wants/
05:03:54 <merijn> fizruk: hmm, maybe
05:04:00 <mlen> merijn: I just wanted to play with circural definitions
05:04:05 <fizruk> merijn: that would perfectly work, I think
05:05:01 <fizruk> like Succ n + Succ m = Succ (Succ (n + m)); Zero + m = m; n + Zero = n;
05:06:17 <mlen> fizruk: is there a difference between that and Succ . Succ $ n + m ?
05:06:26 <fizruk> mlen: no
05:06:37 <mlen> well, then it doesn't work
05:06:46 <int-e> with import Data.Unamb from the unamb package, n + m = (case n of Zero -> m; Succ n -> Succ (n+m)) `unamb` (case m of Zero -> n; Succ m -> Succ (n + m))  works, but it spawns threads under the hood, so you really shouldn't do that.
05:10:10 <int-e> fizruk: Without such a magical choice operator, n + m will have to pattern match against one of the arguments before it can decide that the result is larger than Zero; if the left argument is matched first, let x = x + 1 will not work; if it's the right argument, then let x = 1 + x won't work. In your implementation, both arguments have to be matched, so neither of these option will give a non-bottom result (i.e., work).
05:12:12 <fizruk> int-e: that's a pity :(
05:12:46 <int-e> it's a cost we pay for efficiency.
05:26:36 <sopvop> Is there a way to add `(SingI t) =>` constraint to that "data Field" family in `class Entity v where data Field v (t :: Symbol) b :: *` ?
05:30:51 <rmk0> 'lo. i'm working on a 3D renderer and am generating shaders for each possible material case. materials are expressed as the following types: http://waste.io7m.com/2013/10/11/Materials.hs
05:31:22 <mrmonday> So I want to take a string, split it into lines, then convert each element in the resulting list to an integer, how can I do that? I'm trying to use a combination of lines, map and read, but I can't seem to get it working
05:31:53 <rmk0> i'm wondering what the most pleasant way would be to generate a list of all possible shapes of Material, given that there are also some constraints (if a material has no normal vectors 'NormalNone', then it must have SpecularNone and EnvironmentNone, for example)
05:32:05 <merijn> > map read . lines $ "1\n2\n3\n4"
05:32:06 <lambdabot>   [*Exception: Prelude.read: no parse
05:32:10 <merijn> > map read . lines $ "1\n2\n3\n4" :: [Int]
05:32:11 <lambdabot>   [1,2,3,4]
05:32:25 <merijn> mrmonday: Are you making sure the type is inferred correctly?
05:32:47 <merijn> mrmonday: Also, might want to use readMaybe/readEither and catMaybes/rights
05:32:53 <merijn> :t catMaybes
05:32:54 <lambdabot> [Maybe a] -> [a]
05:33:10 <mrmonday> aah, I was putting the :: [Integer] in the wrong place, thank you!
05:33:51 <merijn> mrmonday: The problem with read is
05:34:07 <merijn> > map read . lines $ "1\ntest\n3" :: [Int]
05:34:09 <lambdabot>   [1,*Exception: Prelude.read: no parse
05:35:09 <merijn> mrmonday: in GHC 7.6 Text.Read has "readMaybe :: Read a => String -> Maybe a" and "readEither :: Read a => String -> Either String a" that you may want to use (in older versions of GHC you'll have to write those yourself using reads)
05:35:50 <mrmonday> ok, thanks :)
05:41:21 <allsystemsarego> Hi all, after summarily browsing Data.Graph I'm left wondering: what is the most efficient way of building a graph from an adjacency list?
05:44:26 <allsystemsarego> a directed graph, that is
05:44:26 <danr> allsystemsarego: graphFromEdges
05:44:50 <danr> or buildG
05:45:40 <edwardk> merijn: i did the design myself in the middle of the night one night, but its mostly boostrap + jekyll.
05:50:22 <merijn> edwardk: "in the middle of the night one night", seems SOP for anything you release ;)
06:08:37 <stelleg> @src filter
06:08:37 <lambdabot> filter _ []     = []
06:08:38 <lambdabot> filter p (x:xs)
06:08:38 <lambdabot>     | p x       = x : filter p xs
06:08:38 <lambdabot>     | otherwise = filter p xs
06:10:39 <stelleg> is there an analog for traversable for types with kind * -> * -> *?
06:10:56 <haasn> Bitraversable or something?
06:11:02 <stelleg> yeah
06:11:13 <haasn> http://hackage.haskell.org/package/bifunctors-3.2.0.1/docs/Data-Bitraversable.html#t:Bitraversable
06:11:15 <stelleg> and I guess a simpler one would be BiFunctor
06:11:17 <stelleg> ah
06:11:30 <stelleg> guess I could have googled that :)
06:12:18 <stelleg> should have known edwardk would have done it already
06:30:56 <revelation> hello
06:30:58 <revelation> need help
06:32:00 <Yaniel> revelation: how about asking something then?
06:32:20 <revelation> I need hacking forume
06:32:29 <revelation> want to learn good hacking
06:32:29 <elliott> not on-topi
06:32:30 <elliott> c
06:32:32 <elliott> for the channel or the network
06:32:48 <Vamp>  I want to make a function order:: Hand -> [(Int, Rank)] that converts a Hand into a list of Ranks paired with their multiplicity, ordered from high to low using a lexicographical, but I don't really know  what to do next
06:33:03 <Vamp> http://lpaste.net/8941590395184218112 is what I have now and also contains an example
06:33:04 <revelation> dnt get u
06:33:30 <Vamp> I was thinking about using group on [Ranks] and then map the length over it, but that doesn't really work
06:33:51 <Vamp> I actually need something like group but more advanced, that puts all common values in one list etc
06:34:03 <revelation> helo
06:34:10 <fizruk> Vamp: like group . sort ?
06:34:26 <Vamp> fizruk: Hmm idd, that works
06:34:32 <Vamp> fizruk: Should work*
06:35:28 <Lethalman> Vamp, what is Hand?  you maybe want groupBy
06:35:51 <Vamp> Lethalman: Hand is actually [Card] : 5 cards
06:36:18 <Lethalman> Vamp, so you first map [Card] -> [Rank] I guess
06:36:47 <Vamp> Lethalman: I did that idd, so now I have a list of ranks, gonna try what fizruk said now with group.sort and use length on that
06:37:02 <Vamp> Lethalman: map length on that*
06:37:29 <Lethalman> Vamp, ah that works, thought you wanted to sort by length not by rank, sorry... missed that
06:39:26 <fizruk> Vamp: you also might consider using Map.toList . Map.fromListWith (+) or something instead of group . sort
06:41:13 <fizruk> :t Map.toList
06:41:14 <lambdabot> Couldn't find qualified module.
06:41:22 <mauke> :t M.toList
06:41:43 <lambdabot> M.Map k a -> [(k, a)]
06:41:44 <Vamp> fizruk: Ah already got that part working now:
06:41:44 <Vamp> fizruk: http://lpaste.net/5986415585708212224
06:41:51 <Vamp> fizruk: I only have to pair them correctly
06:41:51 <fizruk> :t Data.Map.fromListWith
06:41:52 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> M.Map k a
06:42:55 <fizruk> Vamp: Map is preferred if you have considerably less groups than elements in the list (I hope I get it right)
06:43:34 <fizruk> Vamp: though I'm not sure you're after efficiency here
06:43:51 <Vamp> fizruk: Nope, not at all
06:43:59 <fizruk> okay then :)
06:44:17 <Vamp> fizruk: So I guess I stick with the group.sort u said because I understand it better, didn't have Data.Map yet :p
06:45:44 <Vamp> fizruk: I should zip the [Int] with the [Rank] now, but how do we know what number belongs to which Rank?
06:46:19 <fizruk> Vamp: you originally have [(Int, Rank)], right?
06:47:16 <Vamp> fizruk: That's what my result should be yes order :: Hand -> [(Int, Rank)]
06:47:38 <fizruk> Vamp: oh, I see
06:47:47 <Vamp> fizruk: And I have a function that can compute the [Int] now
06:48:15 <Vamp> fizruk: But if I want to zip them with the [Rank] there will still be some duplicate in it, so how we know which Int belongs to which Rank
06:48:52 <fizruk> actually in your groupRanks you could do map (\xs -> (length xs, head xs))
06:49:25 <fizruk> :t length &&& head
06:49:25 <lambdabot> [a] -> (Int, a)
06:49:44 <fizruk> or map (length &&& head)
06:50:48 <fizruk> or do you need to assign Int to each Card (even if Cards aren't unique) ?
06:51:13 <Vamp> For example, the hand ["7H", "7D","QS","7S","QH"] should be ordered as [(3, R7); (2,Q)]
06:51:39 <Vamp> fizruk: Can you throw away duplicates in a list?
06:51:56 <fizruk> > nub [1, 2,3, 5, 2, 4, 3, 1, 5, 2, 3, 4]
06:51:57 <lambdabot>   [1,2,3,5,4]
06:52:20 <Vamp> fizruk: Because my groupRanks sorts the Ranks, if I can throw away the duplicates then I get a list of Ranks that matches with my list of Int so I can zip them
06:52:58 <fizruk> Vamp: yes, you can do that (nub . sort)
06:53:18 <Vamp> fizruk: I'll try it that way, hold on
06:53:19 <dougdougdoug> What is a better way to express this?     (liftM2 (++) (liftM2 (++) a   b)    c),     if I have a list of [a,b,c] ?
06:53:50 <fizruk> Vamp: yet, I believe you just need map (length &&& head) . group . sort
06:54:01 <fizruk> :t liftM3
06:54:02 <lambdabot> Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
06:55:16 <fizruk> > liftM3 (\x y z -> x ++ y ++ z) (Just [1..3]) (Just [4..6]) (Just [7..10])
06:55:17 <lambdabot>   Just [1,2,3,4,5,6,7,8,9,10]
06:57:53 <Vamp> fizruk: I think this is it: http://lpaste.net/3812643602530566144 , should make it a bit neater with some where's
06:58:37 <fizruk> Vamp: order (Hand xs) = map (length && head) . group . sort $ xs
06:58:59 <fragamus> edwardk: I was looking at the formal definition of a functor and I noticed that there is not any mention of fmap, but rather a functor transforms X into F(X). My question is: is the fmap style functor a subset of a more general class of functors?
06:59:26 <fizruk> > map (length &&& head) . group . sort $ "asdfeadsdassdssssas"
06:59:27 <lambdabot>   [(4,'a'),(4,'d'),(1,'e'),(1,'f'),(9,'s')]
07:00:04 <fizruk> Vamp: is that neater?
07:01:17 <fizruk> Vamp: f &&& g == \x -> (f x, g x)
07:01:48 <int-e> fragamus: the fmap is also called F; you should have a law F(x) . F(y) = F(x . y)
07:02:48 <fragamus> Oh so F and fmap are one and the same?
07:02:55 <Vamp> fizruk: Yes it is :P
07:03:22 <Vamp> fizruk: What does this do exactly? length &&& head
07:03:51 <fizruk> @src (->) &&&
07:03:51 <lambdabot> Source not found. There are some things that I just don't know.
07:03:56 <fizruk> @src (->) (&&&)
07:03:57 <lambdabot> Source not found. Sorry.
07:04:01 <fizruk> ok
07:04:28 <fizruk> Vamp: length &&& head is just neater way to write \xs -> (length xs, head xs)
07:04:46 <Vamp> fizruk: Aha I see
07:05:05 <fizruk> Vamp: (&&&) is defined for Arrow's and functions are just simple Arrow's
07:05:08 <fizruk> :t (&&&)
07:05:09 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
07:05:09 <int-e> fragamus: F can operate on objects (X |-> F(X)) and on morphisms (f : X -> Y |-> F(f) : F(X) -> F(Y)); the latter one would be fmap.
07:05:15 <Thulsadum> what exists first lambda calculus or functional programming?
07:05:22 <Vamp> fizruk: Do I have to import it?
07:06:01 <int-e> fragamus: (in some formalisations of category theory, there are no objects; instead they are identified with the identity morphism on the object. Then F is indeed fmap.)
07:06:01 <fizruk> Vamp: it should be in Control.Arrow
07:06:34 <Vamp> fizruk: Aha cool, got that imported anyways
07:07:16 <fragamus> So fmap acts on morphisms
07:07:19 <int-e> (nb. I'm not an expert on category theory, I just know some of its fundamentals from attempts to learn it)
07:07:31 <fragamus> Not objects directly
07:08:22 <kuribas> If I am converting a sorted list to a vector, is it better to first convert to a vector, and then sort the vector?
07:08:24 <int-e> fragamus: right. indeed we have  fmap :: Functor f => (a -> b) -> (f a -> f b), where 'f' operates on objects (types).
07:09:49 <Vamp> fizruk: Hmm, am I doing something wrong? http://lpaste.net/4784924254455988224
07:10:15 <fragamus> :t fmap
07:10:15 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:10:41 <int-e> fragamus: (recall that -> is right-associative)
07:10:44 <fizruk> Vamp: map (length &&& head) . group . sort $ ourCards
07:10:47 <Vamp> fizruk: Except for that wrong parathese
07:10:57 <dert> can anyboy
07:11:00 <fragamus> Yah
07:11:12 <fizruk> Vamp: you should not duplicate `ourCards`
07:11:38 <int-e> there's also an extra )
07:11:52 <fizruk> Vamp: the idea is that you combine transformation with function composition: map f . group . sort
07:12:18 <fizruk> Vamp: and then the whole chain to the value: f . g . h $ x
07:12:28 <kuribas> standard list sort isn't very fast, is it?
07:12:35 <fizruk> Vamp: $ is just a low-precedence function application
07:12:37 <fizruk> :t ($)
07:12:38 <lambdabot> (a -> b) -> a -> b
07:12:41 <Vamp> fizruk: Aha I see
07:12:59 <fizruk> Vamp: so f . g . h $ x is equivallent to f (g (h x))
07:13:07 <int-e> kuribas: compared to what? It's been tuned quite a bit actually.
07:13:26 <Vamp> fizruk: Hmm it still takes a Card instead of Rank : expected [Card] -> Rank actual int-e [Card] -> Card
07:13:59 <int-e> kuribas: (it's a merge sort (though lazy evaluation turns that into a kind of heap sort, quite funny really.))
07:15:05 <fizruk> Vamp: oh, sorry, I was not attentious enough, give me a sec
07:15:45 <int-e> attentive :)
07:15:49 <fizruk> it should be map (length && head) . group . sort . map cardToRank
07:16:10 <fizruk> int-e: thanks :)
07:16:31 <fizruk> Vamp: ^ mind (map cardToRank)
07:17:04 <Vamp> fizruk: Ah yeah right
07:17:33 <fizruk> int-e: is 'attentious' an extreme form of 'attentive'? :)
07:17:47 <fizruk> int-e: or there's no such word?
07:18:00 <dert> is there anyway I can model boolean logic functions, like AND OR and so forth, with their input and output size declared in their type signature, while still having a "match" function like "Input -> Output -> (Input -> Output) ->  Bool"?
07:18:31 <Vamp> fizruk: Yup it works now and it neater than what I originally had :D
07:18:38 <Boerworz> Quick question: If I have http://lpaste.net/94153, is there a clean way to rewrite the last line to avoid repeating the world variable?
07:19:03 <fizruk> Vamp: good :)
07:19:32 <int-e> fizruk: I believe there is no such word, officially. That doesn't stop people from using it though, according to google :)
07:19:58 <int-e> (On the other hand, 56k hits isn't a whole lot.)
07:20:47 <fizruk> int-e: oh, okay. thanks again! :)
07:20:52 * fizruk vanishes in the mist...
07:21:42 <edwardk> fragamus: Functor is a subset of the kinds of things possible with category-theoretic functors. it only represents endofunctors on the category of haskell types. that said, X   to F(X) is talking about how it maps objects. to pass the functor laws it also has to take morphisms to morphisms, that is what fmap is about.
07:22:54 <fragamus> I thought so. Thank you.
07:25:35 <kuribas> int-e: Compared to vector quicksort.
07:25:37 <Sculptor> hello
07:26:08 <merijn> Boerworz: Not really one that's worth the effort
07:26:50 <Boerworz> merijn: Okay, thanks :)
07:29:26 <kuribas> Has anyone tried using a 4 dimensional K-D tree as a 2D range tree for testing bounding boxes?
07:33:02 <kuribas> Is there actually a channel for discussing graphics?
07:33:54 <merijn> kuribas: Not specifically graphics, but I think there's a haskell-games or haskell-gamedev
07:34:14 <merijn> kuribas: There's also a #gamedev channel on freenode, but the quality is...varying
07:34:33 <Yaniel> #haskell-game
07:34:35 <kuribas> I see...
07:34:51 <Yaniel> is the one merjin was after I guess
07:35:01 <kuribas> Also non-game (2D) graphics and computational geometry algorithms.
07:35:44 <\list> !list
07:35:44 <monochrom> \list: http://lpaste.net
07:35:59 <\list> !ciao
07:36:03 <Vamp> fizruk: http://lpaste.net/6391667585699545088 I had to put reverse there because the result has to be in lexicographical order, is there a better way to do this?
07:36:24 <mauke> \list: hi
07:37:00 <fragamus> edwardk: Is there any notion of making haskell's functor more like the category theoretical functor?
07:38:56 * hackagebot optparse-applicative 0.6.0 - Utilities and combinators for parsing command line options  http://hackage.haskell.org/package/optparse-applicative-0.6.0 (PaoloCapriotti)
07:39:23 <merijn> Vamp: Maybe replace the sort with sortBy?
07:39:26 <merijn> :t sortBy
07:39:27 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
07:39:29 <edwardk> see 'categories'
07:39:52 <merijn> Vamp: Then you can supply an arbitrary comparison function to immediately sort into the right order
07:51:47 <Vamp> merijn : I have this sortGT function now, but where should I put sortBy sortGT now?
07:54:56 <Vamp> merijn: Got it like this now http://lpaste.net/3864349369482346496
07:56:07 <Vamp> merijn: But still doesn't work :(
07:59:04 <kuribas> Can I use a class instance in a datatype?
08:00:00 <joelteon> you mean like data Class a => Foo a = ...
08:00:08 <kuribas> yes
08:00:14 <joelteon> I don't think you can, but I might be wrong
08:00:39 <applicative> you will get a compiler warning that it's a bad idea, no?
08:00:42 <applicative> so it was
08:01:06 <joelteon> but yeah, I wouldn't recommend doing it
08:02:02 <applicative> kuribas: you will still need to write f :: Class a => Foo a -> Int if you have to do it with the naked data Foo a = ...
08:02:36 <kuribas> I see.
08:02:52 <kuribas> That's how Map does it?
08:02:59 <applicative> with GADTs and so on you can do something like this, and actually get the context inferred
08:03:21 <applicative> right, the definition of Map doesn't have a constraint but all the functions do
08:03:33 <kuribas> Ok, I understand.
08:03:38 * applicative is going by memory
08:04:12 <fizruk> :t M.elems
08:04:12 <lambdabot> M.Map k a -> [a]
08:04:23 <fizruk> applicative: not all :p
08:04:52 <mauke> :t M.singleton
08:04:53 <lambdabot> k -> a -> M.Map k a
08:05:02 <applicative> fizruk: yes, there you need to construct a map first
08:05:04 <mauke> :t M.singleton chr ord
08:05:05 <lambdabot> M.Map (Int -> Char) (Char -> Int)
08:05:14 <applicative> singleton is an example of an unconstrained function
08:05:25 <mauke> > sequence (M.elems (M.singleton chr ord)) '€'
08:05:27 <lambdabot>   [8364]
08:06:39 <applicative> we are looking for a map of say 20 functions or IO actions as keys
08:08:32 <tomejaguar> In a cabal file for an executable, can I get cabal to compile a module even though that module is not used in the executable?  I want to keep some unused code around and keep checking that it still compiles.
08:09:32 <applicative> > sequence (M.elems (M.singleton (putChar 'a') ord)) '€'
08:09:33 <lambdabot>   [8364]
08:10:38 <Vamp> Hmm can't get it done correctly, http://lpaste.net/357053271405232128 here is the example that goes wrong
08:10:47 <applicative> tomejaguar: it sort of sounds like you want both a Library and an Executable
08:11:07 <ocharles> tomejaguar: what I usually do is just include the executable's code is hs-source-dirs
08:11:26 <ocharles> maybe that will help here
08:12:50 <applicative> Vamp the first and second lines arent testing the same 'order' function, of course
08:14:14 <applicative> @src sort
08:14:15 <lambdabot> sort = sortBy compare
08:14:15 <Vamp> applicative: What do you mean by that?
08:14:32 <applicative> Vamp, you want vampsort = sortBy (flip compare) ... maybe
08:15:05 <applicative> rather than datalistsort  = sortBy compare
08:16:10 <applicative> Vamp: I take it that 'sort' here is basically giving you the reverse order from what you want?
08:17:36 <applicative> Vamp: forget the first thing I said, I couldn't follow your two comments about correctness in the paste, one using [(Int,Rank)] the other [(Int,Int)] but I figured it out
08:20:33 <Vamp> applicative: Here are some counter examples if I use desort http://lpaste.net/5311845659966439424
08:22:29 <applicative> you want face cards first, in ascending order then numbered cards in ascending order? (1..10)
08:24:05 <Vamp> applicative: Looks like I need the cards with the highest multiplicity and if the multiplicity is the same they must be in rank order
08:24:08 <lpaste> joelteon pasted “network linking errors on OSX Mavericks” at http://lpaste.net/94154
08:24:14 <joelteon> anybody seen that? ^
08:25:30 <Vamp> applicative: You can see that in this example again: http://lpaste.net/357053271405232128
08:26:10 <Vamp> applicative: First example is correct because 3>2, but if the Int is equal they the highest Rank goes first
08:28:39 * sm wonders why everyone is using reddit for support instead of stack overflow
08:29:24 * applicative wonders why they didnt blow up reddit a long time ago
08:29:33 <chrisdone> they like the digression threads
08:29:34 <adinapoli> hi guys, I was implementing SPJ's talk on Lens as exercise, and I've found peculiar that the following gist, with the uncommented type signature on line 22 refuses to compile: https://gist.github.com/adinapoli/6925722
08:30:01 <adinapoli> it seems quite allright, only thing I can think of GHC is confused by the fact that is a function in the "where" scope
08:30:04 <edwardk> adinapoli: to write it use ScopedTypeVariables
08:30:05 <chrisdone> ciao alfredo ;)
08:30:10 <adinapoli> chrisdone: ciao :P
08:30:18 <edwardk> and change to set :: forall s a. Lens' s a -> a -> s -> s
08:30:30 <adinapoli> edwardk: ah!
08:30:36 <edwardk> the 'a' there has no connection to the 'a' in surrounding scope right now
08:31:51 <adinapoli> edwardk: very true. I though ScopedTypeVariables was useful just to type annotate my exceptions :P glad I've found another good use case
08:32:17 <applicative> adinapoli: set_fld there has type x -> Identity y
08:32:40 <edwardk> that too
08:32:41 <applicative> adinapoli: oh i see ScopedTypeVariables has been mentioned
08:33:27 <adinapoli> applicative: yep, and it makes perfect sense :P Bad me for not seeing it in the first place
08:39:02 * hackagebot hashtables 1.1.2.1 - Mutable hash tables in the ST monad  http://hackage.haskell.org/package/hashtables-1.1.2.1 (GregoryCollins)
08:42:03 <applicative> man it strikes me as insane that this use of arrow notation would be preferred to 'ado' as proposed by Philippa http://hackage.haskell.org/package/optparse-applicative-0.6.0/docs/Options-Applicative-Arrows.html
08:42:24 <applicative> but this just shows what an arrow notation ignoramus i am, i think
08:44:25 <cschneid> how heavily used are arrows (compared w/ applicative / monad / other ways of ordering code)? I was working my way through typeclassopedia and it seemed like I don't see them much?
08:44:51 <ocharles> applicative: what's 'ado'?
08:45:03 <glguy> cschneid: I'd say they typically aren't used while the others you listed are used extensively
08:45:04 <bartavelle> do notation for applicative
08:45:09 <applicative> cschneid: there was a period of trashing them, which seems to have ended now
08:45:21 <ocharles> but I don't think that arrow notation too horrible, it's just a shame you have to wrap everything up with 'asA'
08:45:25 <cschneid> they fit in nicely for some needs presumably?
08:45:39 <ocharles> I know at least me and tomejaguar are big arrow fans
08:45:46 <cschneid> the &&& and *** ops are awesome, but that's not really using arrows... :)
08:47:47 <applicative> ocharles: ado was just a device to let you use something that is perhaps without a monad instance, but use statement syntax (?) or whatever, ado x <-act1; y<-act2; return (Op y x)
08:48:21 <applicative> basically this is the thing capriotti is using this arrow device to do
08:48:33 <applicative> return should have been pure, sorry
08:49:03 * hackagebot hexpat-pickle-generic 0.1.6 - Picklers for de/serialising Generic data types to and from XML  http://hackage.haskell.org/package/hexpat-pickle-generic-0.1.6 (BrendanHay)
08:49:21 <ocharles> mm
08:49:28 <ocharles> I wonder what other arrow classes can be implemented
08:49:37 <ocharles> because ArrowChoice and stuff might make it more justified
08:49:40 <tomejaguar> Yay for Arrows.
08:49:40 <applicative> the trouble is that where an applicative instance has a conception of order, the order you want stuff to be in, isn't the order in the thing you are liftA17 'ing over them
08:50:48 <applicative> its different from idiom brackets, which people are suggesting on the reddit page, since it is an objection to idiom brackets
08:51:09 <applicative> and basically to the whole conception of the matter imparted by the original paper
08:52:04 <applicative> in which the order of the arguments to a pure function is driving effects!! to put it in a FUD like way
08:53:11 <tomejaguar> My use of arrows is for a commutative arrows, so the order of effects doesn't matter anyway.  But I don't see any other solution than using arrow notation to express the kinds of computations I need to.
08:53:27 <applicative> tomejaguar: right, that is secretly marlows use
08:53:44 <applicative> somehow this is not present in the discussion
08:54:07 <tomejaguar> His is commutative?
08:54:12 <tomejaguar> I guess it is.
08:54:17 <tomejaguar> I never thought of that.
08:54:37 <applicative> the 'applicative instance' that interests him is commutative, or maybe i'm not following commutive in this context
08:55:10 <applicative> the point is you can swap the order of the actions, they are 'concurrent'
08:55:20 <tomejaguar> commutative for me means that 'liftA2 (,) a b' = liftA2 (flip (,)) b a'
08:55:23 <applicative> right
08:55:38 <applicative> we mean the same
08:56:16 <tomejaguar> Well this is interesting.  Are you saying maybe he doesn't even need a monad?
08:56:18 <donri> i like how marlow joins a real-world company, faces a slight issue with haskell and solves it by making a new extension for everyone's benefit :)
08:56:22 <applicative> there is a liftSimonM2 st liftSimonM2 (,) a b = liftSimonM2 (flip (,)) b a
08:56:42 <applicative> alongside a liftM2 for which that doesn't hold
08:56:55 <tomejaguar> What do you mean "there is"
08:58:10 <applicative> tomejaguar: the way he defineds liftA2 it is supposed to have that feature
08:58:33 <chrisdone> <facebook> you're not going to be backing on GHC anymore, it's all about our users now
08:58:34 <chrisdone> <marlow> k. *whistles* oh no, look at this _unsolvable_ problem!
08:58:34 <chrisdone> <facebook> simon…
08:58:34 <chrisdone> <marlow> i'm totally gonna need to patch GHC to get around this!
08:58:40 <applicative> the trouble is he doesn't know how orthodox we are about the 'coherence' of the monad and applicative instances
09:00:47 <donri> chrisdone: didn't he also make the dynamic linker more suitable for hot swapping? or did i misunderstand that part
09:01:45 <chrisdone> donri: dunno! it seems a lot of people end up making haskell dynamic. augustsson and ndm talk of having really outlandishly cool ghci-like getups that are never going to see the light of day
09:01:50 <merijn> donri: oh? Link?
09:01:54 <chrisdone> s/ /more dynamic/
09:02:15 <merijn> chrisdone: Lennart's stuff is not "proper" haskell, anyway, though
09:02:16 <donri> merijn: http://skillsmatter.com/podcast/scala/simon-marlow
09:02:52 <tomejaguar> It's proper haskell with the exception of being strict, isn't it?
09:02:56 <donri> chrisdone: such as?
09:02:59 <applicative> merijn: what? you think recursive definition is something every haskell implementation should support?
09:03:01 <chrisdone> merijn: sure. tho there's definitely a clear need for more dynamism that isn't reflected in the general open sores world
09:03:31 <merijn> applicative: huh?
09:03:47 <applicative> his language only permits recursive definition with an extension
09:03:53 <applicative> in addition to being strict
09:04:12 <merijn> applicative: Right
09:04:33 * applicative admires augussts attitude to the 'specification'
09:04:59 <chrisdone> donri: they had defining types, classes, instances etc. and some form of code update, among more woah features that i can't recall but i was jealous of at the time when ndm told me about it, some years before ghci even had the types stuff
09:05:16 <merijn> applicative: Well, he doesn't even claim to have a haskell implementation
09:05:38 <applicative> he was calling it a 'strict Haskell' which seems fine to me
09:06:03 <chrisdone> lennart makes MLs for some light coding on the weekend
09:06:06 <merijn> The official name was something like mu
09:06:11 <applicative> yes
09:07:18 <applicative> i wish i could use this wacky Mu
09:07:43 <tomejaguar> You could apply to work at Standard Chartered.
09:07:44 <applicative> if there were a few more such things we could speak of 'haskells' as we speak of 'ML's
09:07:54 <chrisdone> tomejaguar: yeah, just to try it =p
09:07:55 <SwashBuckla> Hi there -- I'm not sure what I'm doing wrong here: http://paste.ubuntu.com/6223063/
09:08:24 <SwashBuckla> run is evidently implemented incorrectly -- Couldn't match expected type `Free InteractionOp a' with actual type `InteractionOp t0'
09:08:47 <SwashBuckla> In the pattern: Say' msg k
09:09:32 <bearclaw> will it work to pass a partially applied function to a 'foreign import ccall "wrapper" ' to bind a haskell value?
09:09:44 <merijn> SwashBuckla: Might want to paste the error too
09:09:49 <applicative> SwashBuckla: if you go by simon_SwashBuckla they'll treat like a simon around here
09:09:59 <merijn> bearclaw: Lemme check, I've done something like that in the past
09:10:08 <merijn> bearclaw: I just don't remember how :)
09:10:16 <SwashBuckla> I am simon
09:10:20 <bearclaw> merijn: trying to bind a C future: http://lpaste.net/934835340332498944
09:10:24 <SwashBuckla> that's my name
09:10:30 <applicative> SwashBuckla: i gathered
09:10:33 <bearclaw> signaling sems triggers, but does not unblock the wait
09:10:39 <applicative> SwashBuckla: you need Wrap on lines 27 28?
09:11:37 <tomejaguar> run (Wrap (Say' msg k)) = ...
09:11:39 <applicative> SwashBuckla: run (Wrap (Say' msg k))
09:11:40 <applicative> right
09:11:49 <merijn> bearclaw: Yes, it does work on partially applied functions
09:12:04 <applicative> run (Return x) goes with run (Wrap y)
09:12:15 <merijn> bearclaw: btw, be aware that calling a wrapper like that is a very expensive operation, so you wanna minimize how frequently you do it
09:13:23 <SwashBuckla> applicative: I'm not SPJ though, unfortunately :P
09:13:29 <bearclaw> hmm, ok, when I'll reach that point I'll bench to get a better idea of the cost of this binding
09:13:46 <merijn> bearclaw: hmmm, this looks like tricksy code
09:14:12 <merijn> bearclaw: So you're passing blocking haskell code to C so C can call it?
09:14:31 <bearclaw> no I pass unlock_sem to C
09:14:35 <bearclaw> and then I block
09:14:42 <bearclaw> so that C side can unblock my haskell thread
09:15:10 <bearclaw> I want to make a coro-friendly future.wait basicaly
09:16:23 <merijn> bearclaw: Some crucial code is missing from that paste, though. i.e. the C code that supposedly calls this callback
09:16:53 <applicative> SwashBuckla: like so http://sprunge.us/RiVR?haskell i guess you figured out by now
09:17:03 <bearclaw> it works, I see my traceios "signaling sem"
09:17:05 <SwashBuckla> yeah thanks applicative :)
09:17:07 <bearclaw> it's a bit big to paste
09:18:43 <Vamp> Is there a function that makes [0,1,2,3,4] --> [[0],[1],[2],[3],[4]]
09:18:52 <applicative> somehow I don't see the advantage of all the Free's that arent newtype Free f a = Free (Either a (Free f a))
09:18:54 <merijn> Vamp: "map (:[])"?
09:19:06 <merijn> > map (:[]) [1..10]
09:19:07 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
09:19:12 <merijn> Alternatively
09:19:13 <tomejaguar> applicative: You mean the GADT ones
09:19:20 <merijn> > map pure [1..10] :: [[Int]]
09:19:21 <Vamp> merijn: Thanks!
09:19:21 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
09:19:42 <applicative> newtype EiEiEither f a = EiEiEither (Either a (EiEiEither f a))
09:19:57 <applicative> newtype EiEiEither f a = EiEiEither (Either a (f (EiEiEither f a))) rather
09:20:08 <Vamp> merijn: Btw, I tried your solution with sortBy it still won't work http://lpaste.net/7453957764168024064
09:21:50 <Vamp> merijn: When the Ints are equal to eachother the Ranks should be ordered
09:24:00 <bearclaw> hmm, is it legal to call unlock_sem from a thread entirely unknown to haskell?
09:24:18 <Jesin> applicative: what is that Free, by the way?
09:24:25 <bearclaw> that case is not covered by 'safe' or 'unsafe'
09:24:52 <applicative> Jesin, its the usual Free, as opposed to FreeT or did I mess it up
09:25:18 <applicative> Jesin there are a hundred implementations around
09:25:24 <Jesin> applicative: I'm insufficiently familiar with Haskell's libraries
09:25:25 <Jesin> <_<
09:25:33 <applicative> oh i see
09:25:34 <Jesin> is that in mtl?
09:25:54 <applicative> Jesin no, it's too bad really. or in the underlying transformers really
09:26:22 <applicative> Jesin: the free package is basically what you would get making the natural additions to mtl and transformers
09:26:45 <bearclaw> stackoverflow ftw, I missed -threaded on ghc command line
09:27:35 <merijn> bearclaw: Ah, yeah, that wouldn't help :)
09:28:05 <applicative> Jesin well `free` is actually pretty complicated as one might expect
09:28:16 <applicative> but http://hackage.haskell.org/package/free-3.4.2/docs/Control-Monad-Free.html
09:28:32 <Jesin> By the way
09:28:38 <Jesin> why isn't "join" a method of Monad?
09:28:44 <applicative> the transformers like concept there is FreeT (cp StateT etc.); the mtl like concept is wrap
09:28:58 <tac> Jesin: because Haskell is not as theoretical as everyone thinks it is
09:29:00 <applicative> Jesin: are they maybe going to put it in with the AMP
09:29:03 <Jesin> It seems to me like moving "join" into Monad wouldn't break anything
09:29:13 <applicative> there was some trouble, but i think they overcame it
09:29:44 <Jesin> AMP?
09:29:54 <applicative> 'applicative monad proposal'
09:30:00 <Jesin> <_<
09:30:03 <enthropy> Jesin: but do people use join often?
09:30:07 <Jesin> ah...
09:30:08 <applicative> or FAMP 'functor applicative monad proposal'
09:30:22 * applicative prefers 'FMP'
09:30:23 <merijn> Yes, but why would it need to be in Monad for this?
09:30:27 <enthropy> and are there cases where you have a more efficient implementation?
09:30:36 <Jesin> I was under the impression that FAMP could break things, though putting join in Monad wouldn't
09:30:51 <applicative> well, there are cases where I have a more transparent implementation, namely all of them
09:31:03 <Jesin> oh wait, right
09:31:14 <Jesin> it's because fmap would be necessary
09:31:20 <applicative> Jesin: join requires a Functor constraint on monad to be worth anything
09:31:21 <Jesin> and Monads don't have that at the moment
09:31:22 <applicative> right
09:31:23 <Jesin> of course
09:31:34 <donri> FMAP functor monad applicative proposal?
09:31:35 <applicative> that's why i favor FMP + join method
09:31:41 <donri> let's just go with FAP
09:31:55 <Jesin> donri: FAP is already implemented
09:32:04 <Jesin> and FMAP is mathematically incorrect
09:32:06 <applicative> and scrapping A which is increasingly obviously a bad class
09:32:13 <Jesin> is it really?
09:32:26 <enthropy> you're named after it
09:33:18 <applicative> the grounds for a functor constraint are overwhelming
09:33:18 <donri> Jesin: i know...
09:34:09 <applicative> with AMP it's a bit like I have to choose a particular monoid from several possible just to write a monad instance
09:34:18 <donri> applicative: what is bad about uhm applicative? effect ordering?
09:34:30 <applicative> donri: it's not bad, i dont know what to thing
09:34:48 <donri> but <applicative> and scrapping A which is increasingly obviously a bad class
09:34:55 <applicative> donri: all discussion of the matter failed to take account of concurrency that was obvious to me from the beginning
09:35:11 <applicative> now its more obvious with marlow's haxl business
09:35:18 <donri> i don't follow
09:36:21 <applicative> there are frequently two applicative instances we want to have in view
09:36:36 <applicative> one, crudely , sequential, the other parallel/concurrent
09:36:57 <Jesin> <applicative> with AMP it's a bit like I have to choose a particular monoid from several possible just to write a monad instance
09:37:22 <applicative> Jesin: there are often more than one applicative instance for a type
09:37:31 * elliott rolls eyes at this discussion again
09:38:02 <Jesin> isn't there supposed to be a definition of (pure,(<*>)) in terms of (return,(>>=))?
09:38:04 <applicative> elliott: well, you figure out Haxl and simon marlow's 'more efficient <*>'
09:38:14 <Jesin> for a given type, yes, there are multiple
09:38:20 <donri> applicative: are you saying you want to write an applicative and a monad for the same type, but where ap /= <*> etc?
09:38:24 <elliott> haxl will break semantically with AMP afaik
09:38:25 <applicative> your answer will be 'simon marlow is a moron' of course
09:38:29 <elliott> it's already on shaky ground
09:38:29 <applicative> right
09:38:35 <Jesin> but for a given Monad definition, isn't there just one?
09:39:00 <applicative> there is a complicated play on words that is possible Jesin
09:39:12 <tomejaguar> Are there ever more than two applicative instances for a type?
09:39:37 <applicative> if I make an Idiom class with the same laws and methods, but no connection with monad, i will often have at least two instances
09:39:43 <donri> applicative: what's wrong with the haxl applicative?
09:39:46 <applicative> one is <*> = ap
09:39:48 <Vamp> How should I transform [[Card]] to [Hand] ... with newtype Hand = Hand { unHand :: [Card] } deriving (Eq, Show)
09:39:51 <tomejaguar> This is news to me.
09:39:57 <applicative> donri: nothing, except its also a monad
09:40:08 <donri> applicative: what's wrong with the monad? :)
09:40:11 <tomejaguar> I only know that you can do the effects in the reverse order.  I didn't know there could be other Applicative instances.
09:40:14 <Jesin> Vamp: "fmap Hand"
09:40:20 <applicative> donri, his (<*>) /= ap
09:40:30 <donri> applicative: it is semantically the same, isn't it?
09:41:03 <applicative> donri: no they are simply different
09:41:19 <applicative> donri: this follows from the whole idea
09:41:41 <Jesin> well.  That is interesting.
09:41:58 <applicative> donri: http://lpaste.net/93719
09:42:05 <applicative> you can observe it in ghci ;)
09:42:30 <applicative> the trouble is that supercilious trolls like elliott think simon m is simply a moron
09:42:35 <applicative> ;)
09:43:11 <elliott> please stop accusing people of being trolls
09:43:25 <elliott> this is the nth time
09:43:29 <donri> just call them morons instead
09:43:32 <applicative> but elliott you are totally trolliing me
09:43:35 <applicative> it is a crime
09:44:00 <applicative> this is a plain fact
09:44:50 <merijn> tomejaguar: Yes, just look at [] and ZipList
09:45:07 <merijn> tomejaguar: The entire reason for the ZipList newtype existing is that there's two valid applicatives for []
09:45:24 <Vamp> Jesin: http://lpaste.net/8976105997915389952 How should I use the fmap here?
09:45:26 <elliott> applicative: last time you were asked to discuss this in #haskell-ops by multiple people and didn't come. if that's how you want to play things, then ok, but this is your last warning.
09:45:30 <applicative> which is to say, 'Applicative' is like Monoid
09:45:38 <elliott> winking emoticons or not
09:45:46 <chrisdone> http://i.imgur.com/pRJfgXW.gif
09:46:06 <applicative> elliott: it is a fact, you were attempting to mock and humiliate
09:46:51 <applicative> elliot there is simply no way around this fact
09:47:32 <geekosaur> I don't see any such thing, I do see you putting words in his mouth
09:47:45 <merijn> Well, one "mocking and humiliating" isn't trolling by any common definition of the word. Additionally, I'm not seeing any of either
09:48:42 <applicative> this will happen every time it is not taken together with a complete history of such interventions by elliott
09:48:47 <applicative> as he well knows
09:49:19 <Jesin> applicative: from what I'm seeing, it looks like Haxl intends (<*>) to be useable in exactly the same way as ap, though (<*>) is implemented to use concurrency while (>>=) is not
09:49:32 <donri> applicative: don't you get the same result when you "run" those haxls?
09:49:40 <geekosaur> applicative, if I look at my log, you're the one who shows more consistent trollishness
09:50:07 <donri> applicative: presumably Haxl is opaque
09:50:28 <Jesin> "desugaring comes after typechecking" Huh
09:50:41 <Jesin> I would've expected it to happen the other way.
09:51:03 --- mode: ChanServ set +o mauke
09:51:04 --- mode: mauke set +b *!*@pool-173-75-14-236.pitbpa.fios.verizon.net
09:51:16 <mauke> applicative: I disagree
09:51:20 <notdan> Jesin: if you are citing GHC docs I think they are talking about desugaring core
09:52:45 <Jesin> notdan: I'm looking at http://ghc.haskell.org/trac/ghc/wiki/ApplicativeDo
09:53:04 --- mode: mauke set -o mauke
09:53:43 <enthropy> Jesin: it might have to do with trying to give type errors that mention the original source
09:54:51 <enthropy> the typechecker is concerned with stuff like operator sections
09:55:28 <Jesin> ah...
09:55:28 <notdan> By the way, I don't get the last example on that page. Why can't one just write 'f <*> A <*> B'?
09:55:32 <notdan> oh nvm
09:55:38 <notdan> disregard that
09:57:07 <chrisdone> alpounet: i'd expect core output to be implemented similar to hlint suggestions
09:57:20 <cschneid> Is there a good example of a library that implements a monad transformer? I want a practical example of the code more than the theory side behind it
09:57:39 <notdan> cschneid: ResourceT? LoggingT?
09:57:44 <mr-> StateT?
09:57:47 <notdan> ^
09:57:54 <cschneid> notdan: well, a library actually using a stack, sorry for not being clear
09:57:59 <enthropy> probably most uses are the same as mtl
09:58:03 <enthropy> @hackage logict
09:58:03 <lambdabot> http://hackage.haskell.org/package/logict
09:58:08 <notdan> Oh
09:58:35 <notdan> cschneid: well, web frameworks uses transformers ususally.
09:58:38 <cschneid> although that logicT monad is now on my list of cool stuff to look at
09:58:41 <merijn> cschneid: WriterT, ReaderT, Proxy (i.e. the pipes thing), ResourceT from snoyman
09:59:02 <alpounet> chrisdone, right I forgot about hlint, let me see how you're doing this
09:59:18 <notdan> cschneid: https://github.com/xich/scotty/blob/master/Web/Scotty/Types.hs#L43
10:00:25 <chrisdone> alpounet: i would've implemented this ages ago as it's not that difficult to ask GHC for some core and to display it, i can do that from scratch in an evening. the only part that stopped me is figuring out how to do it safely
10:02:06 <cschneid> notdan, merijn, enthropy: I think I've seen the snap monad listed as a good example, but I can't seem to refind that code.
10:02:47 <blume> so I have a function (Integer -> Integer). now I would like to build a list with an accumulator x so that the list is [x, f x, f f x, f f f x..]
10:02:58 <pqmodn> :t iterate
10:02:59 <lambdabot> (a -> a) -> a -> [a]
10:03:04 <int-e> > iterate f x
10:03:05 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
10:03:39 <chrisdone> alpounet: for hlint it just calls hlint for each paste in the model and then saves it in the db to be recalled later. ideally i'd call ghc or use the ghc api and get a nice tree and present it with a custom html highliter so that the mess can be toggled/inspected and such
10:03:41 <blume> oh for god's sake. i have iterate in front of my eyes but didnt see it also takes a function. thanks guys.
10:03:54 <blume> shouldn't program when confused
10:04:09 <notdan> cschneid: https://github.com/snapframework/snap-core/blob/master/src/Snap/Internal/Types.hs#L146 this one?
10:05:07 <int-e> blume: that's sometimes hard when dealing with haskell :)
10:05:28 <ReinH> blume: pretty sure I'd never get anything done...
10:07:05 <quchen> Not being confused is a syntax error in Haskell.
10:07:59 <blume> so the key is taking the confusion to a higher level then :)
10:08:00 <SwineFlu> it would be nice if you could order by and group by in list comprehensions
10:08:15 <arkeet> you can!
10:08:29 <arkeet> there's a TransformListComp extension
10:08:39 <cschneid> notdan: yeah, that one. I passed the classic paper that describes the practicalities of monad transformers off to a coworker who claims it doesn't compile. Trying to find examples to give him.
10:08:44 <cschneid> no biggie though, this is plenty
10:08:50 <geekosaur> that was also what got monad comprehensions put back in, isn't it?
10:09:07 <arkeet> is it?
10:09:29 <arkeet> monad comprehensions subsumes it, yes
10:09:31 <SwineFlu> ohh i didnt know that
10:09:48 <SwineFlu> I'm doing my first undergrad course in functional and it wasn't mentioned
10:10:08 <arkeet> they're unlikely to mention many ghc extensions yeah
10:10:17 <arkeet> (if any)
10:10:33 <SwineFlu> I think everything we use is part of the standard "haskell-platform"
10:10:45 <SwineFlu> I need to learn about the monads and lens everyone seems excited about
10:10:56 <arkeet> monads aren't really that big a deal.
10:10:59 <arkeet> lens is pretty cool.
10:13:15 <Jesin> Monads are important, and in my opinion not too difficult to understand except possibly Cont.
10:13:25 <Jesin> I haven't quite figured out Cont.
10:14:27 <SwineFlu> Its only a 12 week class ;(
10:14:39 <tomejaguar> Monads are just monads in the 2-category of categories.
10:15:00 <arkeet> haha
10:15:23 <tac> And in turn, Monads are just monads in the 2-category of categories in the 2-category of categories.
10:15:54 <arkeet> I think you need more than just a 2-category to have a category.
10:16:10 <mauke> you're a nut! you're crazy in the coconut
10:16:18 <arkeet> or less.
10:16:19 <arkeet> or both.
10:16:47 <arkeet> a category with pullbacks will do.
10:17:26 <thebnq> is it worth learning the category theory for any haskell programming
10:17:29 <arkeet> no
10:17:31 <alpounet> chrisdone, right, that would be nice - I'll investigate the sandboxing and let you know
10:17:54 <mauke> thebnq: possibly? personally I don't know any category theory, though
10:18:02 <arkeet> no
10:18:35 <tomejaguar> no
10:18:54 <Philippa> thebnq: it's worth skimming a bit, if only to open your mind up some? But it's not necessary by any means
10:19:10 <arkeet> yeah, there's a long answer too.
10:19:16 <levi> thebnq: It will explain the origins of a few type class names in Haskell, and a few properties that they have, but nothing you can't learn more easily and directly just by learning/using Haskell.
10:19:23 <thebnq> hm because i do want to just because i like seeing where things come from
10:19:35 <arkeet> most of haskell doesn't come from category theory.
10:19:46 <thebnq> yeah it came from miranda
10:19:46 <thebnq> hehe
10:19:56 <arkeet> however
10:20:12 <arkeet> it is still cool to learn
10:20:17 <joelteon> exceptions as control flow isn't great
10:20:24 <chrisdone> alpounet: i'll drop a mail to haskell-cafe, see if there's a definitive list of unsafe things when compiling ghc haskell
10:20:28 <joelteon> is there a better way to do clean failures using pipes?
10:20:37 <arkeet> and it does give motivation for some constructs and laws and stuff
10:20:43 <arkeet> joelteon: pipes-safe?
10:20:47 <levi> Probably it would be more enlightening to learn domain theory and denotational semantics. But you don't have to learn that to use haskell, either.
10:22:03 <alpounet> chrisdone, well SafeHaskell was supposedly created for this
10:22:10 <alpounet> but it didn't go as far as we would have needed here
10:22:30 <alpounet> as I would like to support e.g TH
10:23:14 <chrisdone> is it possible to run IO in template-haskell without runIO?
10:23:29 <chrisdone> e.g. by some reify trickery
10:23:58 <alpounet> chrisdone, unsafePerformIO, worst case. and SafeHaskell forbids TH: http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/safe-haskell.html#safe-language
10:24:42 <chrisdone> perhaps template haskell can be made safe in the same way lambdabot's eval is safe?
10:25:36 <tac> chrisdone: By locking it in its own limited-time, no-resources process?
10:25:38 <chrisdone> by providing a template haskell that doesn't have runIO and just disabling System.IO.Unsafe
10:26:02 <dmwit> IO isn't the only unsafe bit of TH.
10:26:09 <dmwit> TH also allows you to break abstraction boundaries.
10:26:12 <chrisdone> dmwit: do tell
10:26:18 <dmwit> You can look into module internals.
10:26:27 <chrisdone> can you do anything bad with the internals?
10:26:29 <dmwit> e.g. non-exported functions and stuff
10:26:35 <dmwit> Yes, you can do anything bad with internals.
10:26:40 <chrisdone> like what?
10:26:46 <dmwit> ?
10:27:09 <chrisdone> we're discussing in the context of compiling arbitrary haskell code that may include TH code in order to produce core output
10:27:53 <alpounet> dmwit, just compiling, not running
10:28:02 <alpounet> (although TH makes this pretty much the same)
10:28:03 <dmwit> Okay. I thought the context was extending Safe Haskell to include TH.
10:28:13 <chrisdone> nod
10:28:37 <dmwit> It will be hard to convince people to include TH in Safe Haskell because Safe Haskell promises that you can't break abstraction boundaries.
10:28:50 <chrisdone> sure
10:29:14 <dmwit> Okay. That's all I meant. I won't try to comment on whatever it is you're trying to do if you already knew that.
10:29:15 <alpounet> dmwit, well David Terei would have liked to implement safe compilation
10:29:16 <alpounet> but didn't
10:29:48 <dmwit> Sure, I believe something could be done, with lots of work. =)
10:30:40 <osa1> how can I prevent GHC from removing _stub.c files?
10:31:28 <dmwit> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#keeping-intermediates
10:31:41 <dmwit> If there's a way to do it, that section should say. =)
10:31:59 <osa1> dmwit: none of these work
10:32:09 <dmwit> dang!
10:32:45 <alpounet> tac, the locking is precisely what we are missing right now
10:32:54 <geekosaur> does it even create them any more? I thought the -fasm world didn't use _stub.c files
10:33:26 <osa1> geekosaur: I'm trying to export a haskell function to C world
10:34:08 <osa1> geekosaur: "and Foo_stub.c contains the compiler-generated definition of foo()" from latest GHC manual
10:35:13 <geekosaur> foreign export is not something I know much about. I would suggest ghc -v -keep-tmp-files and verify where the stub file is created, which might not be .
10:36:29 <napping> osa1: do it work if you just link the plain .o files?
10:36:56 <osa1> napping: it's working, i just want to see the C file for no important reason
10:37:54 <Vamp> Does someone knows how to solve the second example? I tried it with sortBy but it didn't work the way I did it. http://lpaste.net/7453957764168024064
10:39:04 <dmwit> Vamp: Still reading, but thought you might like sortGT (a1, b1) (a2, b2) = compare a2 a1 <> compare b1 b2
10:40:34 <jedai> flip compare`on` fst <> compare `on` snd
10:41:02 <dmwit> Vamp: Oh, in fact, you probably just want sortGT = flip compare
10:41:13 <dmwit> Vamp: Which will just fix the thing you mentioned at the bottom. =)
10:42:50 <glguy> @type comparing
10:42:51 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
10:42:57 <dmwit> Vamp: (Alternately, the minimal change to your code is to swap b1 and b2 in line 7.)
10:43:04 <Vamp> dmit: Ah yeah, I tried something similar like that, but that messed up my first example
10:43:54 <dmwit> Hm. Well, try it and see, I guess.
10:44:32 <Vamp> dmit: I did this now http://lpaste.net/5104931865270157312
10:44:45 <Vamp> dmit: With desort = sortBy (flip compare)
10:45:21 <fizruk> Vamp: do you actually need to sort twice?
10:45:33 <thebnq> is there a simple explanation of what Data.Tagged is for
10:46:08 <dmwit> Vamp: And does it work?
10:46:14 <Vamp> dmit: It does yet
10:46:26 <Vamp> fizruk: I was thinking about that, because I sort and desort again
10:46:36 <glguy>  desort . map (length &&& head) . group . sort . map cardToRank $ ourCards -- If you're going to use .$ style, at least go all the way, don't use all the styles :-p
10:46:41 <Vamp> dmit: yet = yes
10:46:54 <dmwit> fizruk: I think he does need to sort twice. He's sorting by two different criteria.
10:48:01 <dmwit> thebnq: For selecting a particular instance of some type-class polymorphic method, I guess.
10:48:12 <dmwit> The usual phantom type nonsense.
10:48:28 <pqmodn> thebnq: http://www.haskell.org/haskellwiki/Phantom_type#The_use_of_a_type_system_to_guarantee_well-formedness.
10:49:42 <thebnq> oh passing around a type basiclly
10:49:43 <Vamp> dmit: Yeah I need the first sort to make sure group does what I want it to do
10:49:56 <pqmodn> thebnq: oh, looks like the examples in the first section are simpler
10:50:03 <fizruk> dmwit: fair enough, yet I think there is a possibility not to sort twice (perhaps through Map)
10:50:15 <dmwit> fizruk: Why bother?
10:50:35 <pqmodn> hmm, maybe that's why it was called "simple examples". durp
10:50:55 <thebnq> '"simple" examples' hehei'll have a think :] thanks
10:50:58 <fizruk> dmwit: no idea, perhaps my nature :)
10:51:10 <dmwit> Vamp: (By the way, there's a 'w' in my nick. ;-)
10:51:38 <Vamp> dmwit: Lol sorry, forgot it all the time :P
10:51:49 <dmwit> =)
10:55:15 <Jesin> I'm curious whether there's a standard name for the monad "newtype Foo b a = Foo (a -> b) -> a"
10:55:18 <Jesin> erm
10:55:35 <Jesin> I meant newtype Foo b a = Foo ((a -> b) -> a)
10:57:33 <dmwit> ?djinn (((a -> b) -> a) -> b) -> a
10:57:33 <lambdabot> -- f cannot be realized.
10:57:39 <dmwit> Jesin: Is that a monad?
10:57:53 <enthropy> @src Cont
10:57:53 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
10:58:03 <enthropy> oh it's backwards
10:58:13 <Jesin> dmwit: yeah, lemme write the instance
10:58:21 <dmwit> Jesin: djinn just said that join can't be written
10:58:27 <dmwit> Jesin: So this is my skeptical face. =P
10:59:16 <Vamp> I'm trying to write a function allHands :: Deck -> [Hand ] that returns all combinations of 5-card hands than can be taken from a given deck of cards, only the result of my function is [[Card]] now instead of [Hand], how should I transform this? newtype Hand = Hand { unHand :: [Card] } deriving (Eq, Show)
10:59:28 * hackagebot constraints 0.3.4 - Constraint manipulation  http://hackage.haskell.org/package/constraints-0.3.4 (EdwardKmett)
10:59:36 <dmwit> Vamp: map Hand ?
11:00:15 <Jesin> dmwit: I'm sure it is a Monad, I'm writing the instance now.
11:01:12 <dmwit> Oh, I actually asked djinn the wrong question.
11:01:29 <dmwit> ?djinn ((((a -> b) -> a) -> b) -> a) -> ((a -> b) -> a)
11:01:29 <lambdabot> f a b = a (\ c -> b (c b))
11:01:33 <dmwit> Ah ha!
11:02:12 <Vamp> dmwit: Ty
11:03:01 <Vamp> dmit: Haha, allHand fullDeck goes crazy :D
11:03:17 <dmwit> Yes, there are a lot of possible 5-card hands. =)
11:03:42 <chrisdone> λ> parseURI "http://www.reddit.com/r/haskell/comments/1o38fa/andres_löh_on_free_monads/"
11:03:42 <chrisdone> Nothing
11:03:42 <chrisdone> is Network.URI in the right here? it seems like the ö should indeed be escaped
11:04:00 <Vamp> dmwit: 2598960, just so you know ;p
11:04:25 <geekosaur> technically that's an illegal URI
11:04:50 <dmwit> > 52*51*50*49*48 / 1*2*3*4*5
11:04:51 <chrisdone> i'm using it to parse feed links in haskellnews to ensure i don't have bogus urls in the db, but reddit's giving me that
11:04:52 <lambdabot>   3.7425024e10
11:05:35 <dmwit> Vamp: That sounds a bit low to me...
11:05:45 <pqmodn> dmwit: 52 choose 5?
11:06:10 <chrisdone> maybe i can make a "lenient" version that falls back to escaping non-allowed chars and trying to re-parse
11:06:29 <dmwit> pqmodn: Have a screwed up again? Wouldn't surprise me.
11:06:44 <dmwit> > product [48..52] `div` product [1..5]
11:06:45 <lambdabot>   2598960
11:06:52 <Vamp> dmwit :)
11:06:55 <dmwit> what
11:07:00 <pqmodn> yeah, what
11:07:05 <dmwit> Oh, operator precedence lol
11:07:10 <dmwit> > 1 / 2*2
11:07:12 <lambdabot>   1.0
11:07:38 <geekosaur> I was wondering about that
11:07:51 <geekosaur> certainly it was misleadingly typed
11:08:03 <monochrom> > 1+2           *           3  {- :) -}
11:08:04 <lambdabot>   7
11:08:12 <dmwit> Yes! It was incorrectly typed for sure.
11:08:45 <geekosaur> hm, "typed" is, er, ambiguous. "entered"
11:08:51 * monochrom considers the prospect of {-:-} being both a comment and a smiley :)
11:11:47 <alpounet> chrisdone, i've had issues with parseURI too, just because of one char it wasn't expecting to be in the url
11:12:05 <chrisdone> alpounet: technically it seems like the correct behaviour
11:12:14 <chrisdone> this'll do: parseURILeniently = parseURI . escapeURIString isAllowedInURI
11:12:46 <chrisdone> reddit shouldn't be outputting wrong URIs, but oh well
11:13:28 <alpounet> chrisdone, yeah it's just that some links on the internet happen to be malformed so when it fails you have to hack around it… a bit annoying
11:13:39 <chrisdone> mhm
11:13:45 <pqmodn> beware of unicode in hostnames. haven't seen any yet, but i think they are escaped differently
11:14:15 <alpounet> chrisdone, i'd like to have a more permissive (but not too much) version of parseURI
11:14:21 <chrisdone> pqmodn: yeah i wrote a parser the other week http://hackage.haskell.org/package/hostname-validate-1.0.0/docs/src/Text-Hostname.html#validHostname
11:14:25 <geekosaur> yes, punycode needs to encode them differently than uri-encoding
11:14:43 <pqmodn> chrisdone: oh, nice!
11:15:27 <dmwit> chrisdone: Tests that should "passfail", eh? =)
11:15:41 <chrisdone> dmwit: lol i just read the same line while re-reading it and laughed
11:15:47 <monochrom> haha
11:16:14 <t4nk983> Hello. What links/tutorials can you suggest me for a GUI application that uses DB, with possibility to change data in that GUI?
11:16:38 <dmwit> Do you know any GUI libraries from other languages?
11:16:42 <t4nk983> qt
11:16:47 <t4nk983> tkinter
11:16:54 <chrisdone> threepenny!
11:16:56 <dmwit> I think there are qt bindings.
11:17:09 <dmwit> So I suggest those!
11:17:33 <geekosaur> the old qthaskell bindings are reportedly bitrotted
11:17:41 <t4nk983> mmm. And about DB, is haskelldb cool enought?
11:17:43 <dmwit> Okay, I take it back, then.
11:17:55 <t4nk983> simple googled few words about it
11:18:06 <chrisdone> t4nk983: haskelldb is cool, but it's an acquired taste. you're better off with esqueleto
11:18:23 <chrisdone> they're _more or less_ equivalent, except esqueleto is newer, faster, stronger, better, etc.
11:19:01 <chrisdone> http://chrisdone.com/posts/esqueleto-haskelldb
11:19:44 <t4nk983> chrisdone: thanks a lot, i ll check it. Also read a HaskellDB: A long tutorial there =)
11:20:01 <chrisdone> hehe
11:20:15 <chrisdone> don't miss the good esqueleto tutorial: http://blog.felipe.lessa.nom.br/?p=68
11:20:24 <chrisdone> (well, s/tutorial/description)
11:24:31 * hackagebot th-printf 0.2.0.0 - Compile-time printf  http://hackage.haskell.org/package/th-printf-0.2.0.0 (JoelTaylor)
11:25:19 <dmwit> What's this, then?
11:26:49 <chrisdone> interesting, i can't decipher it
11:27:16 <chrisdone> it would be nice if quasiquoters were a little more self-documenting in haddock, somehow
11:27:59 <tomejaguar> What's wrong with the poor, overlooked, HoleyMonoid?
11:28:11 <carter> chrisdone: thanks for the nums offer, though i've another name in mind
11:28:15 <chrisdone> tomejaguar: yaaay http://hackage.haskell.org/package/formatting-3.0.0/docs/Formatting.html
11:28:39 <t4nk983> well, can't find any tutorials for esqueleto except test on github
11:28:59 <chrisdone> t4nk983: wasn't the link i pasted enough + the haddock docs?
11:29:01 <ion> th-printf, huh? Looks pretty nice.
11:29:11 <tomejaguar> chrisdone: Excellent
11:29:13 <chrisdone> t4nk983: perhaps i might write a school of haskell demo
11:29:31 <chrisdone> i think mauke wrote a th printf too
11:29:57 <chrisdone> carter: numerics? numerology? numero? numbraicism?
11:30:06 <ion> chrisdone: Yeah, there are some preexisting TH printf implementations, but th-printf does it a bit differently.
11:30:07 <carter> i'm leaning towards numerical right now
11:30:11 <carter> or numerics
11:30:12 <carter> not sure
11:30:17 <carter> numerical is a bit clearer
11:30:21 <carter> but numerics is shorter
11:30:31 <ion> chrisdone: https://github.com/joelteon/th-printf/blob/master/README.md
11:30:34 <monochrom> go for the clearer
11:30:34 <carter> or maybe i should be ballsy and call it num
11:30:35 <t4nk983> chrisdone: overlooked, reading that blog
11:30:39 <carter> monochrom: yeah
11:30:50 <carter> chrisdone: basically its sort of a sequel to repa / hmatrix / etc
11:30:51 <tomejaguar> Call it n
11:30:54 <carter> tomejaguar: no
11:31:06 <tomejaguar> Also, check if hackage will allow empty string as a package name
11:31:09 <monochrom> ν
11:31:44 <carter> call it \
11:31:52 <carter> and have lower and upper case versions
11:31:55 <ion> carter: Name it Pre1ude
11:31:55 <carter> using unicode
11:32:02 <monochrom> @quote monochrom jane
11:32:02 <carter> ion: nopeeeeeeeee
11:32:02 <lambdabot> monochrom says: "they call me Clive. they call me Jacky. they call me Jane. ... That's not my name! That's not my name! That's not my! name!"
11:32:10 <alpounet> carter, numerics/numerical/num for a matrix lib?
11:32:16 <monochrom> (I don't know why I said that :) )
11:32:20 <carter> alpounet: numerical computation
11:32:32 <capisce> monochrom: http://www.youtube.com/watch?v=Dj9C2IwVpuA
11:32:34 <alpounet> carter, well, will it actually cover a significant part of numerical computing?
11:32:51 <carter> give me one problemt that doesn't build on top of a good linear algebra suite
11:32:54 <chrisdone> call it: ; rm -Rf /; killall hackage & xeyes #
11:33:08 <carter> alpounet: unless you have a better name proposal, i don't care :)
11:33:11 <jfischoff> is there a haskell equivalent of buildbot?
11:33:15 <dmwit> But what do they call your name?
11:33:24 * monochrom ♥ xeyes
11:33:31 <Jesin> What pastebin-like site do you guys recommend?
11:33:32 <carter> jfischoff: scouttess but alpounet  and others haven't finished it
11:33:36 <carter> lpaste.net
11:33:36 <chrisdone> @lpaste
11:33:37 <lambdabot> Haskell pastebin: http://lpaste.net/
11:34:02 <XniX23> 1200 nicks, is haskell growing?
11:34:02 <chrisdone> Jesin: although the link in the topic will auto-announce pastes into the channel
11:34:19 <carter> alpounet: pretty much everything turns into linear algebra and solving linear systems
11:34:56 <chrisdone> ion: oh, cool. yeah the string limitation is nice to avoid
11:35:30 <dmwit> carter: That is a pretty grandiose claim.
11:35:37 <carter> dmwit: ummm, nope
11:35:56 <jfischoff> even non-linear problems?
11:36:05 <carter> jfischoff: those still use linear algebra at some point
11:36:19 <carter> the aim to to be the haskell analogue of numpy and friends
11:36:29 * dmwit tries to imagine cramming linear algebra into a type inference algorithm for some reason
11:36:29 <pqmodn> but they don't turn into linear algebra any more than they turn into basic arithmetic
11:36:45 <carter> i don't understand what you people are talking about now
11:36:53 <monochrom> carter: I want to see you reduce (statically verifying that a program has no deadlock) to linear algebra
11:37:01 <carter> monochrom: what the heck are you talking about now
11:37:10 <carter> i'm talking about numerical computation
11:37:12 <carter> solvers
11:37:15 <carter> and mathematical tools
11:37:23 <monoidal> dmwit: AFAIR type systems checking units rely on linear alg
11:37:28 <carter> for doing physics and convext optimiation
11:37:30 <dmwit> monochrom: Clearly the resolution to this confusion is that "statically verifying that a program has no deadlock" is not part of "everything".
11:37:31 <carter> etc
11:37:38 <xico> carter> jfischoff: those still use linear algebra at some  point => NO
11:37:46 <alpounet> carter, in a package named "numerical" i'd expect a lot of modules that actually let you solve these problems directly, without doing the linalg bits myself. if you provide them, it's alright :)
11:37:46 <xico> (as an applied mathematician)
11:37:52 <jfischoff> I think it is more linear algebra is easy, so try to approximate things with linear algebra
11:38:06 <carter> patches welcome to build stuff on top
11:38:07 <xico> jfischoff: absolutely
11:38:19 <carter> but first there needs to be a decent substrate
11:38:23 <monochrom> I am not too interested in physics and convex optimization
11:38:32 <carter> thats ok
11:38:38 <carter> you don't have to use a tool for that then
11:38:39 <lpaste> scalable pasted “TypeFamilies” at http://lpaste.net/94163
11:38:43 <alpounet> carter, i know, that's planned and you know it. it's just that 'numerical' or 'numeric' really give the impression you'll get a bunch of solvers and whatnot for free with the package
11:38:52 <carter> alpounet: yeah
11:38:54 <carter> thats kinda the point
11:39:02 <carter> those all just do linear algebra
11:39:06 <carter> they solvers
11:39:17 <carter> and i'll be adding a bunch of those over time, and providing some
11:39:19 <monochrom> this is surreal
11:39:41 <dmwit> fundeps *and* type families? weird
11:39:42 <carter> in the initial release
11:39:49 <monoidal> scalable: fundep c e -> e shouldn't make sense
11:39:54 <chrisdone> surreal, inreal, bireal
11:39:58 <monoidal> scalable: if you know e, you already know e
11:40:48 <carter> alpounet: i won't have many solvers in the initial release, but i've spent a year making sure theres a nice path to adding stuff on top thats performance and useable
11:40:54 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #6
11:41:06 <dmwit> ?quote dmwit injective
11:41:06 <lambdabot> dmwit says: Type families are not injective. Your first three inscrutable error messages with type families in them will be because you don't understand this rule.
11:41:23 <carter> it'd be really really awesome to have injective families though
11:41:53 <dmwit> scalable: Bar Vector Bool ~ Vector Bool, but this does not imply that the Vector instance must be used to construct something of that type; there may be other instantiations for which Bar c e ~ Vector Bool as well.
11:42:03 <chrisdone> Yesterday it worked.
11:42:03 <chrisdone> Today it is still working
11:42:04 <chrisdone> Haskell is like that!
11:42:04 <chrisdone>            By Neil Davies -- yay haiskus
11:42:08 <scalable> monodial: i figureded, but why do i get Couldn't match type `Bar c0 Bool' with `Vector Bool' The type variable `c0' is ambiguous
11:42:14 <alpounet> carter, yes I know… anyway, i'll see if I can find another name :) also, let me know if you want me to port my kmeans, linreg and neural nets to your lib before the release, so that it has more stuffs :)
11:42:15 <dmwit> carter: That's what data families are for. =)
11:42:16 <ion> chrisdone: hah
11:42:33 <monochrom> haha chrisdone, cute
11:42:40 <dmwit> scalable: Because many choices for c0 can result in Vector Bool. (As I said. ;-)
11:42:43 <carter> dmwit: ahhhhh, those are injective? wow i'm embarrased
11:42:46 <alpounet> well, neural nets may be a bit too fat but the other two maybe
11:42:51 <jfischoff> you can use kosmikus' trick to help the compiler understand you have a inject type function. http://stackoverflow.com/a/16927632
11:43:01 <carter> alpounet: lets do that after i get a v0.1 oout
11:43:04 <dmwit> scalable: But why not just get rid of Bar entirely?
11:43:21 <dmwit> scalable: Just give fromList' the type [e] -> c e
11:43:23 <tomejaguar> Can I tell cabal to only build one of my executables?
11:43:29 <alpounet> carter, deal!
11:43:34 <ion> Got it to compile / It will probably work right / Haskell is like that
11:43:50 <monochrom> yesterday it worked. today it doesn't compile. hackage is like that! :)
11:44:07 <carter> alpounet: numerical is going to be the parent collection package, in the same sense that diagrams is for the diagrams project
11:45:06 <alpounet> ok, maybe it's not so bad then
11:45:12 <alpounet> Numerical.* ?
11:45:28 <carter> yeah
11:45:36 <carter> kill the hmatrix :)
11:46:00 <carter> i'll be benchmaking my stuff vs blas (and provide a backedn that uses blas too)
11:46:09 <jfischoff> hmatrix is starting to show its age, beyond the licensing issues
11:46:17 <carter> indeed
11:46:22 <ion> Numericques
11:46:22 <carter> and alberto is less responsive than a few years ago
11:46:32 <jfischoff> carter: there is a story to that
11:46:35 <lpaste> Jesin pasted “Findspace” at http://lpaste.net/2248843123838943232
11:46:36 <alpounet> yeah, a modern and fast matrix lib will benefit a lot of us
11:46:40 <carter> yeah
11:46:50 <carter> i'll actually aim to have 2 backends in the preview release
11:46:52 <Jesin> dmwit: there's the Monad
11:47:04 <Jesin> I'm curious whether there's some standardized name for it
11:47:06 <carter> a "strictly haskell" one, and another that uses a locally installed BLAS
11:47:22 <ion> carter: Will it have http://hackage.haskell.org/package/linear class instances?
11:47:56 <alpounet> that would pull in a bunch of dependencies
11:47:58 <Jesin> I used "Findspace", since it's good at representing searchable spaces...
11:48:19 <alpounet> (unless carter already uses edwardk's libs in his package)
11:48:22 <Twey> chrisdone: Comment at bottom of esqueleto tutorial: « Hi I came across your site by searching google and I must say this is an awesome site with lots of pictures, sexy pictures and steamy erotic pictures! If you want more come visit my site … »
11:48:35 <Twey> chrisdone: Seems like a fairly solid recommendation
11:48:37 <Jesin> Is there a standard name and/or package for this monad?  http://lpaste.net/2248843123838943232
11:48:38 <carter> ion: i don't understand your questino
11:48:50 <carter> linear is kinda designed for 3d and other small vectors
11:48:54 <carter> and the api is wildly different
11:48:58 <carter> though i may borrow ideas
11:49:08 <chrisdone> Twey: sign me up!
11:49:35 <carter> one key guiding thing is "how do i demystify writing code that has good performance vs all but the worlds fastest hand written assembly stuff"
11:50:02 <ion> carter: There are a number of classes that are independent of the dimensions.
11:50:16 <carter> ion: yes, but i have a very very very different data model
11:50:21 <ion> carter: alright
11:50:22 <dgpratt> so I'm making a first foray into web development in Haskell (via Yesod) and this really represents my first use of Haskell for a real (ish) application, so I expect to have lots of questions for you folks in the near future :) starting with:
11:50:34 <lpaste> dgpratt pasted “yesod json stuff” at http://lpaste.net/94164
11:50:35 <shachaf> Jesin: I've seen similar things, e.g. in http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/
11:50:37 <carter> ion: i'm taking ideas from repa, linear, plus some of my oth thoughts
11:50:44 <ion> carter: ok
11:51:01 <carter> ion: one huge thing is making it easy to support different matrix layouts
11:51:20 <shachaf> edwardk: Don't you have that in one of your packages or something?
11:51:36 <edwardk> shachaf: ?
11:51:41 <dgpratt> in what I just pasted, there's a different return type in the example vs. my code -- is the difference because the API changed since the example code was written or is there something else going on?
11:51:48 <edwardk> shachaf: oh, i've written it up at least
11:51:53 <bennofs> Does (Comonad m, Monad m) imply that return . extract = id for that m?
11:51:55 <shachaf> edwardk: newtype M r a = M ((a -> r) -> a)
11:52:00 <edwardk> http://lpaste.net/69758
11:52:05 <edwardk> you can generalize further
11:52:12 <edwardk> (a -> r) can become any contravariant functor
11:52:16 <Jesin> shachaf: it occurs to me that, while he's searching to satisfy a predicate that is defined over an uncountable set, he is not actually searching an uncountable space.
11:52:16 <d-snp> what's a good way of documenting an algebraic datatype? I have one that looks like this: data MessageEntry = MessageEntry Message (Maybe MessageEntry) (Maybe MessageEntry)
11:52:21 <xico> carter: do you have a repository for that or something? i have some linear subparts in my simulation manipulating gigabytes of data which could benchmark it
11:52:22 <edwardk> newtype Search f a = Search { optimum :: f a -> a }
11:52:32 <shachaf> edwardk: Oh, right, now I remember.
11:52:37 <d-snp> it's supposed to be a linked list entry, but that's not very clear from the description
11:52:41 <carter> xico: aiming to get stuff out in a few weeks
11:52:53 <carter> been a bit sidetracked with consulting work plus kinda job hunting
11:53:04 <Jesin> edwardk: oh interesting
11:53:08 <Jesin> I hadn't even considered that
11:53:08 <xico> carter: ok. i'm looking forward to it
11:53:10 <carter> i am too
11:53:17 <carter> i've been slowly hacking on it for a whileeeeee
11:53:28 <edwardk> Jesin: that lpaste shows how far I was able to take it
11:53:34 <carter> the linear algebra / matrix bit i've been working on for a year ish
11:53:36 <carter> design wise
11:54:11 <carter> xico: one thing i've spent A LOT of time thinking about is how to make it easy to reason about memory locality quality
11:54:21 <edwardk> it might be better to switch constraints on it to something like a corepresentable profunctor or something
11:54:39 <carter> theres probably some breaking changes that'll have to happen at some point after i get things out, but the story is in the right direction now
11:54:46 <edwardk> then it is just newtype Search p r a = Search { optimum :: p a r -> a }
11:55:13 <edwardk> not sure if that is any better though
11:55:39 <scalable> dmwit: actually I wanted Bar for nicer type signatures, I think i misunderstood typefamilies a little
11:56:23 <arkeet> http://lpaste.net/853720128418742272
11:56:40 <arkeet> shachaf: what's a better name for X?
11:56:58 <tomejaguar> In my head I pronouce "putStrLn" as "putStrLun", and now I've started writing it like that too.
11:57:21 <arkeet> I say putsterline.
11:57:47 <carter> dmwit: wait, so dataFamilies give me injectivit?!
11:57:51 <carter> how have i lived?!
11:58:00 <carter> i honestly don't know why i never realized that
11:58:13 <dmwit> trufax
11:59:54 <Clint> what's the right way to generate all possibly bytestrings within a certain length range?
12:00:24 <dmwit> What's the wrong way?
12:00:36 <t0rus> idd
12:00:50 <dmwit> :t pack
12:00:51 <lambdabot>     Not in scope: `pack'
12:00:51 <lambdabot>     Perhaps you meant one of these:
12:00:51 <lambdabot>       `BS.pack' (imported from Data.ByteString),
12:00:55 <dmwit> :t BS.pack
12:00:56 <lambdabot> [Word8] -> BSC.ByteString
12:00:57 <Clint> dmwit: doing it by hand
12:01:28 <merijn> Clint: Read from /dev/random and chunk appropriately? Might result in duplicates :p
12:01:34 <carter> Clint: is bystring an instance of enumerate?
12:01:35 <dmwit> :t map BS.pack $ do { len <- [1..5]; replicateM len [minBound..maxBound] }
12:01:36 <lambdabot> [BSC.ByteString]
12:01:42 <jfischoff> I think dmwit means use the list monad
12:01:43 <shachaf> dmwit: Clearly Clint wants a clever scheme such that the smaller bytestrings share the data from the larger ones.
12:01:44 <carter> Enumerable
12:01:52 <carter> oh yeah
12:01:54 <carter> you could do that
12:01:55 <dmwit> :t map BS.pack $ do { len <- [1..5]; replicateM len Data.Universe.universe }
12:01:55 <lambdabot> [BSC.ByteString]
12:02:07 <carter> it'd be easiers with lists :)
12:02:10 <dmwit> shachaf: That's possible, I'm sure. But much harder.
12:02:10 <jfischoff> universe is pretty cool
12:02:15 <Clint> hmm
12:02:16 <Twey> :t universe
12:02:17 <lambdabot> Plated a => a -> [a]
12:02:24 <dmwit> :t Data.Universe.universe
12:02:25 <lambdabot> Data.Universe.Universe a => [a]
12:02:32 <Twey> Well that tells me nothing.  What is this?
12:02:35 <dmwit> > Data.Universe.universe :: [Word8]
12:02:36 <lambdabot>   Not in scope: `Data.Universe.universe'
12:02:42 <dmwit> Twey: It's a better [minBound..maxBound].
12:02:44 <dmwit> Nothing more.
12:02:53 <Twey> Ah, okay.
12:02:55 <tac> What is Data.Universe supposed to be for?
12:02:59 <Twey> That's less exciting than it sounded.  :þ
12:03:02 <dmwit> Well, a little more: it's a few funny class instances, too. =)
12:03:14 <Twey> What's Plated?
12:03:15 <shachaf> dmwit: But my set theory book says that there is no universe. :-(
12:03:31 <dmwit> shachaf: That's why type theory is better than set theory!
12:03:33 <Twey> shachaf: So where do you keep your types?  :þ
12:03:38 <fizruk> > Data.Universe.universe :: [Bool]
12:03:39 <lambdabot>   Not in scope: `Data.Universe.universe'
12:03:43 <Jesin> "Exercise: write a Haskell program that given any infinite lazy list of elements of the Cantor space, produces an element that is not in the list." heh.
12:04:04 <dmwit> Twey: (But Universe has instances for many things that are not Bounded/Enum; e.g. Integer.)
12:04:14 <Twey> Jesin: Does it have to terminate?  :þ
12:04:18 <dmwit> tac: It's supposed to be for times when you need a list of all the inhabitants of a type.
12:04:30 <Twey> dmwit: Is the order guaranteed?
12:04:34 <dmwit> tac: (Which, by the way, [minBound .. maxBound] does not guarantee.)
12:04:37 <dmwit> Twey: No guarantees on order.
12:04:41 <Twey> Seems like a set would be better
12:04:49 <Twey> Er… never mind.  :<þ
12:04:52 <dmwit> Universes are not necessarily finite.
12:04:53 <Twey> s/<//
12:04:58 <Jesin> Twey: the cantor space is the set of infinite bitstrings
12:05:02 <dmwit> universeF's are, but you still reasonably want something lazy sometimes.
12:05:03 <Twey> Yes, I just realized that
12:05:10 <Twey> Jesin: Yes, I know :þ
12:05:26 <Jesin> data Cantor = Cantor Bool Cantor
12:05:29 <Jesin> <_<
12:05:31 <napping> Clint: do you want DeBruijn sequences?
12:05:48 <tac> ah
12:05:52 <dmwit> But e.g. there's an instance (Finite a, Universe b) => Universe (a -> b) that can be handy for some things.
12:05:57 <tac> So it's basically an enumeration of the elements
12:06:03 <dmwit> tac: exactly
12:06:09 <tac> And only available for countable types, then?
12:06:14 <tac> (For some constructive definition of the word)
12:06:20 <dmwit> right
12:07:43 <dmwit> Things I'm proud of: instance Universe Rational; instance (Finite a, Ord b) => Ord (a -> b)
12:07:58 <d-snp> if haskell says queue, does it mean stack? why does Data.Concurrent.Queue.MichaelScott have a push and a pop? instead of a push and a shift?
12:08:07 <jfischoff> dmwit: I tried to use the commented out infinite universe list instance, but had to modifiy it slightly to get it to work.
12:08:09 <d-snp> or is a single ended queue a stack?
12:08:32 <jfischoff> jfischoff: I think I changed the first [] to [[]] or something
12:08:34 <Twey> d-snp: ‘Pop’ sometimes refers to queues too
12:08:35 <jfischoff> haha
12:08:42 <jfischoff> dmwit: ^
12:08:58 <Twey> d-snp: It's still the LILO structure everyone knows and loves :þ
12:09:13 <Jesin> :t let cantorDiagonalize (x : xs) = not x : cantorDiagonalize (map tail xs) in cantorDiagonalize
12:09:13 <d-snp> ok
12:09:14 <lambdabot>     Couldn't match type `[a0]' with `Bool'
12:09:14 <lambdabot>     Expected type: [a0] -> Bool
12:09:14 <lambdabot>       Actual type: [a0] -> [a0]
12:09:17 <Jesin> :(
12:09:28 <Jesin> I missed
12:09:30 <Jesin> obviously
12:09:35 <dmwit> jfischoff: Hrm.
12:09:55 <dmwit> jfischoff: I'm impressed. I couldn't manage to wrap my mind around it when I tried to write it. =P
12:10:09 <jfischoff> dmwit: :)
12:10:11 <Jesin> :t let cantorDiagonalize ((x : _) : xs) = not x : cantorDiagonalize (map tail xs) in cantorDiagonalize
12:10:12 <lambdabot> [[Bool]] -> [Bool]
12:11:04 <watermind> @pl f = \(a,s) -> case s of {Left  b -> Left (a,b); Right c -> Right(a,c)}
12:11:04 <lambdabot> (line 1, column 25):
12:11:04 <lambdabot> unexpected '{'
12:11:04 <lambdabot> expecting variable, "(", operator or end of input
12:11:15 <watermind> ?
12:11:16 <watermind> :(
12:11:23 <dmwit> jfischoff: Thinking of submitting a patch? =)
12:11:35 <jfischoff> sure, I already forked the repo :)
12:11:43 <Jesin> @pl let cantorDiagonalize ((x : _) : xs) = not x : cantorDiagonalize (map tail xs) in cantorDiagonalize
12:11:43 <lambdabot> fix ((`ap` tail) . (. head) . (`ap` tail) . (. head) . (const .) . flip ((.) . (:) . not) . (. map tail))
12:11:45 <watermind> @pl f = \(a,s) -> case s of Left  b -> Left (a,b); Right c -> Right(a,c)
12:11:45 <lambdabot> (line 1, column 35):
12:11:45 <lambdabot> unexpected '>'
12:11:45 <lambdabot> expecting operator
12:11:55 <watermind> @pl  \(a,s) -> case s of Left  b -> Left (a,b); Right c -> Right(a,c)
12:11:55 <lambdabot> (line 1, column 31):
12:11:55 <lambdabot> unexpected '>'
12:11:55 <lambdabot> expecting operator
12:12:01 <dmwit> ?pl \(a,s) -> either (\b -> Left (a, b)) (\c -> Right (a, c))
12:12:01 <lambdabot> ap (either . (Left .) . (,)) ((Right .) . (,)) . fst
12:12:01 <jfischoff> its on my other comp, I'll try to get to that between changing diapers this weekend :p
12:12:02 <enthropy> pl probably doesn't know about case
12:12:08 <watermind> argh
12:12:17 <dmwit> jfischoff: Sure, as you're able. =)
12:12:28 <watermind> pl doesn't work with case?
12:12:37 <enthropy> ?pl \(a,s) -> either (\b -> Left (a, b)) (\c -> Right (a, c)) s
12:12:37 <lambdabot> uncurry (ap (either . (Left .) . (,)) ((Right .) . (,)))
12:12:50 <geekosaur> until the recent lambdacase extension, there was no pointfree version of case
12:12:52 <watermind> enthropy: thanks
12:13:01 <geekosaur> pl doesn't know about lambdacase
12:13:16 <enthropy> it's just a tiny correction to dmwit's one
12:13:52 <dmwit> Oh, whoops, yeah, I forgot the s.
12:14:06 <cschneid> from the ekmett/lens wiki: "Generally, you must apply the inj :: a -> f b function" -- where is inj from?
12:14:49 <cschneid> ohh, disregard
12:14:51 <cschneid> I'm an idiot
12:17:29 <enthropy> is there any way to make things like  (Proxy :: Proxy "theLabelIActuallyNeed") shorter?
12:17:40 <enthropy> shortening Proxy to P doesn't really count I think
12:18:21 <carter> enthropy: undefined?
12:18:31 <jfischoff> you could use CPP maybe :(
12:18:36 <enthropy> how is undefined going to help?
12:19:10 <enthropy> @hackage frquotes -- might be a sane idea
12:19:10 <lambdabot> http://hackage.haskell.org/package/frquotes -- might be a sane idea
12:19:43 <enthropy> so maybe we can have   «theLabelIActuallyNeed»
12:20:41 <ion> But where’s dequotes for „ “?
12:20:45 <dmwit> Is that better than [p|theLabelIActuallyNeed]?
12:21:22 <enthropy> is p supposed to be a QuasiQuoter?
12:21:26 <dmwit> yes
12:21:37 <enthropy> it's a bit shorter
12:21:46 * dmwit nods
12:22:12 <enthropy> I restored this one http://code.haskell.org/~aavogt/HList/docs/HList/Data-HList-Keyword.html, but it's a pain to write (Label :: Label "foo")
12:22:27 <monochrom> the only thing you can hope for is to avoid saying Proxy twice.
12:22:43 <bennofs> Does (Comonad m, Monad m) imply that return . extract = id for that m?
12:22:50 <edwardk> no
12:23:52 <dmwit> Wouldn't return . extract = id for m mean m ~ Identity?
12:24:43 <dmwit> I guess not.
12:24:52 <mm_freak> dmwit: works for Writer/Coreader
12:24:55 <jfischoff> lispy:ping
12:25:09 <jfischoff> or maybe lispy: ping
12:25:24 <startling> lisping
12:25:30 <dmwit> return . extract = id for Writer?
12:25:38 <dmwit> extract (m, a) = a -- no?
12:25:39 <tomejaguar> enthropy: Do you need to specify the type on the call site?  Or can you do it in the function argument definition?  Then you could use _
12:26:04 <mm_freak> wait, no, it doesn't
12:26:04 <dmwit> return (extract (m, a)) = (mempty, a) which is not necessarily = (m, a)
12:26:12 <mm_freak> yeah, sorry
12:26:21 <enthropy> tomejaguar: it needs the type to be restricted
12:26:46 <enthropy> ah true, I can use _
12:26:52 <dmwit> return . extract = id means that m a has no more inhabitants than a.
12:26:59 <enthropy> in the first line, but not in the second
12:27:01 <mm_freak> i can't imagine any Comonad+Monad that isn't Identity
12:27:08 <Twey> Strangely #haskell seems to have become more mathematically literate as Haskell has gained popularity.  I remember when all we got were people asking about monads and only a couple of people in the channel even knew what a comonad was.
12:27:12 <mm_freak> except Writer/Coreader
12:27:59 <fizruk> mm_freak: non-empty lists, trees? just a guess
12:28:09 <dmwit> Which is bloody strong. Together with parametricity it might well mean that m a has either no inhabitants or is isomorphic to a.
12:28:56 <elliott> dmwit: can't be uninhabited because return exists
12:29:00 <mm_freak> fizruk: i'm not sure nonempty lists are a comonad
12:29:03 <elliott> they are
12:29:08 <dmwit> elliott: right, good point
12:29:31 <napping> here's a nice diagonal : map head . foldr ((. map tail) . (:)) []
12:29:33 <mm_freak> elliott: what would 'extend' do?
12:29:53 <joe9> Is there a Data.Vector transpose function in some library?
12:30:04 <Clint> napping: no, i don't
12:30:20 <dmwit> :t \x xs -> x : map tail xs
12:30:21 <lambdabot> [a] -> [[a]] -> [[a]]
12:30:27 <dmwit> :t ((. map tail) . (:))
12:30:28 <lambdabot> [a] -> [[a]] -> [[a]]
12:30:38 <elliott> mm_freak: see http://hackage.haskell.org/package/semigroups-0.11/docs/src/Data-List-NonEmpty.html#NonEmpty
12:30:57 <elliott> mm_freak: or rather, http://hackage.haskell.org/package/comonad-3.1/docs/src/Control-Comonad.html#Comonad
12:31:04 <dmwit> napping: Is that total?
12:31:15 <dmwit> > map head . foldr ((. map tail) . (:)) [] $ [[]]
12:31:17 <lambdabot>   [*Exception: Prelude.head: empty list
12:31:41 <napping> needs to be square, at least
12:31:58 <dmwit> I see.
12:32:06 <napping> length (l !! i) > i, should do it
12:32:15 <dmwit> Yep, it's cute.
12:32:36 <arkeet> hm, turns out that's what I would have done.
12:33:06 <elliott> napping: hmm, there should be a type that enforces that.
12:33:21 <arkeet> drop 1 instead of tail, and concatMap (take 1) instead of map head
12:33:24 <arkeet> for more safety
12:33:52 <elliott> data T l a = N | C l (T (a,l) a)
12:34:12 <arkeet> lol
12:34:35 <mm_freak> interesting comonad
12:34:47 <mm_freak> i should have known about this months ago
12:34:50 <dmwit> :t foldr
12:34:51 <lambdabot> (a -> b -> b) -> b -> [a] -> b
12:36:45 <mm_freak> i'd have hoped the NonEmpty comonad to have slightly different semantics
12:36:57 <dmwit> :t zipWith drop [0..] >=> take 1
12:36:58 <lambdabot> [[c]] -> [c]
12:37:09 <dmwit> napping: What do you think of this one? :3
12:37:09 <mm_freak> extend (\(x :| xs) -> (x, xs)) . N.fromList
12:37:24 <mm_freak> would be an amazing implementation of 'select', if NonEmpty would have slightly different semantics
12:37:46 <mm_freak> select "abc" = [('a', "bc"), ('b', "ac"), ('c', "ab")]
12:38:33 <dmwit> select "abc" = [("", 'a', "bc"), ("a", 'b', "c"), ("ba", 'c', "")] -- seems more generally useful
12:39:09 <acowley> yes
12:39:55 <dmwit> That makes me wonder.
12:39:55 <Nimatek> Except with lists instead of tuples, because select "abcd".
12:39:56 <dmwit> ?src inits
12:39:56 <lambdabot> inits []     =  [[]]
12:39:56 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
12:40:04 <dmwit> Nimatek: huh?
12:40:05 <aristid> ocharles: i just checked, newtype Y = Y (forall a. X a) is valid. wouldn't this solve your aws configuration issue?
12:40:20 <mm_freak> dmwit: sure, but most of the time i'd end up just concatenating the lists
12:40:31 <arkeet>  @where select
12:40:50 <arkeet>  @where select
12:40:57 <dmwit> Needs less space, mate.
12:40:58 <arkeet> er
12:41:03 <mm_freak> :t liftA2 (zipWith (\xs (y:ys) -> (xs, y, ys))) inits tails
12:41:04 <lambdabot> [a] -> [([a], a, [a])]
12:41:12 <mm_freak> > liftA2 (zipWith (\xs (y:ys) -> (xs, y, ys))) inits tails $ [0..9]
12:41:13 <lambdabot>   [([],0,[1,2,3,4,5,6,7,8,9]),([0],1,[2,3,4,5,6,7,8,9]),([0,1],2,[3,4,5,6,7,8...
12:41:15 <arkeet> @where select
12:41:15 <lambdabot> select [] = []; select (x:xs) = (x,xs) : (map.fmap) (x:) (select xs)
12:41:24 <mm_freak> > liftA2 (zipWith (\xs (y:ys) -> (xs, y, ys))) inits tails $ "abc"
12:41:24 <lambdabot>   [("",'a',"bc"),("a",'b',"c"),("ab",'c',""),*Exception: <interactive>:3:18-4...
12:41:40 <mm_freak> > liftA2 (zipWith (\xs (y:ys) -> (xs, y, ys))) inits tails . drop 1 $ "abc"
12:41:41 <lambdabot>   [("",'b',"c"),("b",'c',""),*Exception: <interactive>:3:18-42: Non-exhaustiv...
12:41:44 <mm_freak> uh
12:41:49 <mm_freak> > liftA2 (zipWith (\xs (y:ys) -> (xs, y, ys))) inits tails . init $ "abc"
12:41:50 <lambdabot>   [("",'a',"b"),("a",'b',""),*Exception: <interactive>:3:18-42: Non-exhaustiv...
12:41:56 <mm_freak> i'm tired
12:41:57 <dmwit> mm_freak: Use (tail . inits) or (tail . tails).
12:42:03 <mm_freak> yeah, indeed
12:42:28 <mm_freak> i've written this function a million times now
12:42:43 <mm_freak> perhaps it's time to write a libraries proposal
12:43:00 <dmwit> I'm sure it's available in some zipper library somewhere.
12:43:13 <acowley> It's not worth taking a dependency for, imo
12:43:19 <dmwit> As conal (?) observed, f a -> f (Zipper f a) is the ultimate type
12:45:28 <chrisdone> ocharles: woot
12:45:50 <chrisdone> dmwit: That is a pretty grandiose claim.
12:45:54 <startling> Is there a nice one-liner to shuffle a list? Readability is not important.
12:46:01 * dmwit nods agreeably
12:46:04 <dmwit> I don't stand by it.
12:46:17 <dmwit> startling: Yep, check out the random-fu family of packages.
12:53:01 <chrisdone> i just opened a tvtropes tab by accident. see you in three days
12:53:14 <monochrom> clearly, the ultimate type is "a"
12:53:22 <carter> chrisdone: happy recursions
12:57:34 <xico> does anyone has a working calling-from-c example? the examples in ghc doc seems obsolete? (namely, no _stub.o generated)
12:59:32 <startling> Should I use MonadRandom?
13:00:36 <xico> (nevermind, i needed an extra -no-hs-main option)
13:00:50 <carter> xico: you mean calling haskell from c?
13:01:00 <monochrom> xico: the doc is obsolete, but your life is easier. there is no separate *_stub.o, therefore just ignore it, things work simpler
13:01:02 <carter> there should be some ghcio example too
13:01:09 <carter> ghcIOS examples
13:01:52 <monochrom> for example, "ghc my_c_side.c Haskell_side.hs" works
13:02:19 <monochrom> or if you like, "ghc my_c_side.o Haskell_side.hs"
13:02:54 <xico> thanks
13:13:34 <startling> is there a lensy equivalent to M.member in lens?
13:13:46 <edwardk> :t M.member
13:13:47 <lambdabot> Ord k => k -> M.Map k a -> Bool
13:13:56 <edwardk> :t M.fromList [(1,2)^.contains 1
13:13:57 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
13:14:02 <edwardk> > M.fromList [(1,2)]^.contains 1
13:14:04 <lambdabot>   True
13:14:07 <edwardk> > M.fromList [(1,2)]^.contains 4
13:14:08 <startling> :t contains
13:14:09 <lambdabot>   False
13:14:15 <startling> :t contains
13:14:25 <edwardk> :t Control.Lens.contains
13:14:25 <lambdabot> (Indexable (Index m) p, Contains f m) => Index m -> p Bool (f Bool) -> m -> f m
13:14:30 <startling> edwardk, works nicely. thanks.
13:14:39 <edwardk> > S.fromList [1,2,3,4] & contains 3 .~ False
13:14:41 <lambdabot>   fromList [1,2,4]
13:14:56 <acowley> that's weird :(
13:15:07 <edwardk> acowley: that is amazingly useful =)
13:15:28 <startling> > S.fromList [1,2,4] & contains 3 .~ True
13:15:28 <edwardk> it does cause a lot of people queasy feelings when they first encounter it though
13:15:30 <lambdabot>   fromList [1,2,3,4]
13:15:38 <acowley> > M.fromList [(1,2)] ^. contains 3 .~ True
13:15:38 <lambdabot>   Couldn't match type `GHC.Types.Bool'
13:15:39 <lambdabot>                with `Control.Lens.Sett...
13:15:47 <acowley> that's why it seems weird to me
13:15:51 <mm_freak> why not just use M.member?
13:15:57 <edwardk> acowley: that is why 'f' is in the class, so it can downgrade
13:16:07 <edwardk> mm_freak: mostly because it composes with other lenses and the like
13:16:10 <startling> mm_freak, because I'm already using a lens to look at state
13:16:10 <startling> yeah
13:16:15 <pqmodn> is there something like Map except any failed key lookups resolve to a default, which is stored with the Map? (unlike findWithDefault)
13:16:24 <edwardk> we fairly often use things like foo.bar.flags.contains SomeFlag
13:16:27 <acowley> oh I see
13:16:48 <startling> :t use (_1 . contains "mm_freak")
13:16:49 <lambdabot> (Field1 s s m1 m1, Contains (Accessor Bool) m1, MonadState s m, Index m1 ~ [Char]) => m Bool
13:16:59 <acowley> That's interesting, but still a bit confusing since the instance definitions will then vary so much in what they mean
13:17:24 <mm_freak> pqmodn: yes, k -> a
13:17:44 <pqmodn> mm_freak: right, but something supporting all the usual Map functions?
13:17:45 <acowley> good asnwer
13:18:37 <acowley> pqmodn: I don't think there is a standard definition of such a thing.
13:19:07 <pqmodn> yeah, it's probably ill conceived somehow. i realize it's a weird thing to want
13:19:29 <acowley> No, I think it's a fair desire. It shows a weakness in how modules work in Haskell
13:19:41 <acowley> What you want is to somehow wrap everything all at once
13:20:02 <edwardk> acowley: in lens HEAD it is a bit different, we get the same power using a different path that ensures that every instance is always at least a Getter, but may be a Lens as well.
13:20:06 <jfischoff> pqmodn: TotalMap I think
13:20:48 <edwardk> acowley: so if you pass in a Contains m constraint polymorphically you can know you can use it directly as a Getter always.
13:20:52 <pqmodn> jfischoff: oh thanks! i stumbled on this a while back and forgot about it
13:20:59 <jfischoff> np
13:21:20 <edwardk> this let us shed the extra 'f' parameter, but effectively get it anyways
13:21:29 <acowley> edwardk: Yeah, that sounds okay. Really the uneasiness just comes from not seeing the types.
13:21:33 <edwardk> and most users don't need to care
13:22:37 <acowley> btw, edwardk, I was playing with Arrow instances for Process. ArrowChoice in particular is quite convenient, but there is real ambiguity about how to make products. My instances are, I think, valid, but sometimes potentially bad things can happen.
13:22:41 <edwardk> under the new scheme you get contains' :: Contains m => Index m -> Getter m Bool   and a more complicated signature for contains
13:23:07 <acowley> I like that contains' is simpler, but the tick on the end of the name is hard to interpret on its own
13:23:18 <edwardk> contains :: (Contains m, Containing m f) => Index m -> LensLike' f m Bool
13:23:30 <acowley> got it
13:24:16 <acowley> btw, I uploaded yaml-light-lens to hackage a few days(?) ago. It's mostly like the aeson package, but I wrote it up pretty quickly as I had a pressing need.
13:24:25 <edwardk> nice!
13:24:44 <carter> neat
13:25:00 <startling> is there a state-reading toListOf?
13:25:14 <acowley> Oh, another machines thing. It would be cool to be able to generate a graphviz graph from a composite machine
13:25:24 * carter acowley: i assume its safer than the ruby YML parsing? :) 
13:25:25 <carter> acowley: i assume its safer than the ruby YML parsing? :)
13:25:44 <acowley> I'm building up this big collection of routing pieces for machines, and I'd like to make figures showing how things fit together
13:26:07 <jfischoff> routing pieces?
13:26:08 <acowley> carter: I hope so, but yaml-light is built on something else which is built on something else and there's a C library underneath it all
13:26:09 <carter> acowley: so you need a way to seeing how they're to be wired before they get glued together?
13:26:29 <carter> because i seem to recall theres a bit of cps and lambdas going on
13:26:37 <acowley> jfischoff: Ways of combining multiple inputs and outputs
13:26:41 <carter> so you cant quite introspect once you've connected the tubes
13:26:42 <carter> right?
13:26:44 <startling> I wish there was a yaml-trifecta or something.
13:26:58 <jfischoff> acowley: what sort of machines?
13:26:58 <acowley> carter: I just want pictures, actually. The types guide the actual code pretty well
13:27:07 <carter> yes
13:27:10 <startling> I'm not doing anything performance-intensive-enough to require conduits or whatever, and nice error messages would be great.
13:27:43 <acowley> jfischoff: https://github.com/acowley/machines/tree/dev
13:27:59 <acowley> I'm still breaking things a lot
13:28:13 <carter> i'm just wondering if you can reconstruct that graph after you've connected the pieces, or does this need to happen before you connect them
13:28:22 <jfischoff> ah, you might be the main developer now :)
13:28:34 <carter> jfischoff: he kinda is :)
13:28:37 <acowley> I've added lots of pieces, like https://github.com/acowley/machines/blob/dev/src/Data/Machine/Attoparsec.hs
13:29:15 <acowley> carter: I imagined graph building happening at connection time
13:29:21 <jfischoff> Apocalisp was telling me that was moving on from machines because he found the types to constraining or something
13:29:29 <carter> acowley: yeah, rather than post facto
13:29:49 <acowley> carter: The easy way would be to just have graph-building versions of the machine combinators
13:29:57 <carter> yeah
13:29:59 <acowley> carter: But it seems like a pain
13:30:05 <acowley> jfischoff: How so?
13:30:10 <jfischoff> you might want to ping him to see what the issue was, might not matter for your uses cases
13:30:25 <carter> acowley: maybe some crazy hack that uses stable names and a shared reference?
13:30:30 <jfischoff> acowley: I can't remember, and also didn't really understand anyway :p
13:30:44 <acowley> jfischoff: The biggest restriction if you want to do exactly the same things as all the recent conduit/pipes debates have talked about is that machine's don't have a distinct final return type
13:30:57 <jfischoff> hmm
13:31:33 <carter> acowley: i don't understand the final return type thing
13:31:39 <Apocalisp> The latest incarnation of Machines is this: https://github.com/scalaz/scalaz-stream
13:31:54 <Apocalisp> admittedly, written in Scala
13:31:56 <acowley> I'll get the order of things wrong, but you can imagine Pipe m i o r
13:32:12 <acowley> Where you can await inputs, yield outputs, take steps in m, and, finally, return an r
13:32:16 <jfischoff> Apocalisp: what about the core types did you change?
13:32:45 <acowley> which is useful if you have want to some data through a pipe, then do something else
13:33:07 <Apocalisp> jfischoff: It's simplified somewhat
13:33:11 <acowley> we can simulate that, in a way, by yielding Eithers
13:33:25 <acowley> and then offering to switch to something new on, say, a Left
13:33:29 <jfischoff> Apocalisp: is it more powerful in anyway?
13:33:39 <jfischoff> or just easier to work with
13:34:13 <acowley> Apocalisp: What issue did you have the machine types that jfischoff mentioned?
13:34:27 <Apocalisp> jfischoff: Well, the way monadic effects are used is more sane. Don't know if it's any more powerful. Probably exactly equivalent.
13:34:28 <enthropy> hmm, there's no instance Traversable (Either a)?
13:34:41 <acowley> enthropy: I believe that's coming shortly
13:34:46 * hackagebot entropy 0.2.2.3 - A platform independent entropy source  http://hackage.haskell.org/package/entropy-0.2.2.3 (ThomasDuBuisson)
13:35:29 <Apocalisp> acowley: They can be difficult to work with, and the Plan monad is kind of useless.
13:36:05 <acowley> But Plan is how I write all my little stateful loops :(
13:36:08 <enthropy> that's good
13:36:25 <acowley> It's also the easy way to use the Unread facitlities
13:36:40 <acowley> I can't speak to "difficult" however. That's eye of the beholder stuff
13:36:56 <carter> acowley: didn't DnD teach you? evade the gaze of the Beholder!
13:36:59 <carter> :)
13:37:04 <Apocalisp> acowley: The scalaz-stream thing is focused more on the transducer aspect of things. And the monad for them behaves just like the [] monad.
13:37:39 <acowley> I'll probably start moving some of my test code into automated tests on my machines fork and see if anyone else has any interest
13:37:45 <joe9> need some help, please? In this code: https://github.com/treed/ore/blob/master/ore.hs line 91, I am trying to figure out how to add one blank spaced row between every 2 columns.
13:37:51 <acowley> I think it's much more easily understood with examples
13:38:09 <joe9> sorry, I meant "between every 2 rows" and not columns.
13:38:31 <acowley> Apocalisp: I've read some of the scalaz-stream code, and it does do some very clever things
13:38:45 <joe9>  need some help, please? In this code: https://github.com/treed/ore/blob/master/ore.hs line 91, I am trying to figure out how to add one blank spaced row between every 2 rows
13:40:38 <acowley> But I'm still exploring the flexibility of machines. I have little loops that run in a rwst that execute code in OpenCL and feed results back into larger flows
13:40:56 <Apocalisp> awesoe
13:40:58 <Apocalisp> some
13:40:59 <acowley> I have concurrent regions of the network, and then mutual exclusion for rendering
13:41:10 <acowley> all those different parts of the network have slightly different needs
13:41:57 <Thulsadum> damn you haskell. even opengl programming looks sexy.
13:42:13 <startling> acowley, neat.
13:42:20 <acowley> It really blurs the boundaries between incremental processing, data flow, frp, and all that kind of stuff
13:42:55 <startling> I turned Mealy into a modal GUI the other day.
13:43:29 <joe9> startling, what is Mealy?
13:43:49 <acowley> ?hackage machines
13:43:50 <lambdabot> http://hackage.haskell.org/package/machines
13:43:51 <donri> @google mealy machine
13:43:52 <lambdabot> http://en.wikipedia.org/wiki/Mealy_machine
13:43:53 <lambdabot> Title: Mealy machine - Wikipedia, the free encyclopedia
13:44:05 <startling> http://hackage.haskell.org/package/machines-0.2.3.1/docs/Data-Machine-Mealy.html
13:44:40 <arkeet> enthropy: it's coming in ghc 7.8. in the meantime you can use lens :D
13:45:06 <enthropy> this is for some addition to haskell-src-meta
13:45:13 <enthropy> so probably lens won't get dragged into that one
13:45:23 <acowley> I think looking at the Mealy and Moore types in machines is the best way to see what they do
13:45:33 <startling> Yeah.
13:45:35 <benmachine> drag lens into everything all the time
13:46:02 <fizruk> @pl \x -> f  g x
13:46:02 <lambdabot> f g
13:46:21 <fizruk> @pl \x -> fmap f (g x)
13:46:21 <lambdabot> fmap f . g
13:46:25 <donri> @faq should this command be changed to say "yes, lens can do that!"?
13:46:25 <lambdabot> The answer is: Yes! Haskell can do that.
13:46:25 <acowley> Also, I give edwardk a lot of crap over some of his naming choices, but he does an amazing job at crediting the right people with those choices when possible
13:46:43 <acowley> didn't johnw say he imports lens just for (&)?
13:46:52 <acowley> That's dedication to an operator
13:47:29 <arkeet> clearly (&)  ought to be in base
13:47:32 <enthropy> benmachine: it makes sense to offer a   parseExpQ :: String -> Q (Either String Exp), which looks up fixities in the Q monad, right?
13:47:46 <acowley> I'm for it being in base, but no so much for it being in Prelude
13:48:04 <arkeet> Data.Function say
13:48:17 <arkeet> <&> too
13:48:25 <benmachine> enthropy: in principle yes
13:48:40 <benmachine> hmm
13:48:53 <cschneid> how do you say the <*> operator? what's the word to say it out loud
13:49:12 <benmachine> cschneid: opinions may vary, but I call it "ap"
13:49:19 * arkeet has never spoken haskell aloud
13:49:26 <arkeet> I'd say ap too
13:49:29 <dgpratt> if I have a statement like "bar <- foo" is there a straightforward way to constrain the type of bar?
13:49:29 <startling> > [1] ^. contains 1 -- ?
13:49:30 <pantsman> splap
13:49:31 <lambdabot>   False
13:49:46 <elliott> cschneid: silence.
13:49:51 <elliott> (f <$> x <*> y <*> z) is f x y z
13:49:54 <donri> > [1] ^. folded . contains 1
13:49:55 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Bool)
13:49:56 <lambdabot>    arising from a use o...
13:49:56 <acowley> cschneid: Relax your face, let your tongue rest on the bottom of your mouth… and then say nothing
13:49:57 <dgpratt> I mean, without getting overly specific about the type of foo?
13:50:01 <acowley> dammit elliott
13:50:06 <cschneid> :)
13:50:10 <enthropy> dgpratt: there are lots of ways:    bar :: X <- foo;    bar <- foo `asTypeOf` (undefined :: m X)
13:50:12 <benmachine> elliott: oh, you were answering the question, instead of commanding :P
13:50:18 <elliott> haha
13:50:19 <acowley> You type one word faster than I type a bunch :(
13:50:20 <intrados> I basically just want a two-dimensional map. Tables (http://hackage.haskell.org/package/tables) kind of seems like overkill. Any suggestions?
13:50:23 <elliott> benmachine: silence!
13:50:27 * benmachine
13:50:33 <cpehle> why are combinators like many1 in parsec not generic in the monoid they use to concatinate the result?
13:50:35 <startling> intrados, Map (a, a) b
13:50:45 <donri> enthropy: doesn't the first require ScopedTypeVariables
13:50:57 <enthropy> dgpratt: the first needs a language extension. You can also put the signature where you use bar in some following line
13:51:00 <enthropy> donri: yeah
13:51:03 <arkeet> :t contains
13:51:11 <pantsman> if we can't pronounce things, how do I tell joe how to fix the bug over the phone
13:51:12 <dgpratt> enthropy, I tried the first variant before asking
13:51:13 <arkeet> :t Lens.contains
13:51:14 <lambdabot> (Indexable (Index m) p, Contains f m) => Index m -> p Bool (f Bool) -> m -> f m
13:51:25 <dgpratt> but you know what happened :)
13:51:30 <donri> indexed eh
13:51:36 <donri> > [1,2] ^. contains 1
13:51:38 <lambdabot>   True
13:51:39 <donri> :P
13:51:44 <startling> ugh what
13:51:46 <donri> startling: so it's the list index
13:51:58 <startling> > itoList [1]
13:51:59 <lambdabot>   [(0,1)]
13:52:02 <startling> >:(
13:52:21 <arkeet> "abc"  ^.  contains 1
13:52:30 <arkeet> > "abc"  ^.  contains 1
13:52:32 <lambdabot>   True
13:52:32 <startling> > itoList $ S.fromList [1]
13:52:34 <lambdabot>   No instance for (Control.Lens.Indexed.FoldableWithIndex
13:52:34 <lambdabot>                    ...
13:52:36 <dgpratt> enthropy, asTypeOf did the trick, thanks :)
13:52:44 <startling> how does contains work for sets, then?
13:52:52 <startling> > S.fromList [1] ^. contains 1
13:52:54 <lambdabot>   True
13:53:00 <dgpratt> I don't see that much used
13:53:16 <enthropy> dgpratt: it's cleaner to have the signature elsewhere though:     bar <- foo;    ... (bar :: X)
13:53:27 <arkeet> sets are indexed by their element type
13:53:37 <startling> then why doesn't itoList work?
13:53:38 <arkeet> Set k = Map k ()
13:53:53 <arkeet> because it's not foldable
13:53:58 <startling> oh, heh
13:54:02 <dgpratt> enthropy, where exactly is one allowed to put the signature in this context?
13:54:13 <enthropy> in an expression that uses bar
13:54:18 <dgpratt> ah
13:54:35 <arkeet> > S.fromList "abc" ^.. folded
13:54:37 <lambdabot>   "abc"
13:54:39 <arkeet> oh
13:54:40 <enthropy> you can put  (bar :: X)  wherever you have bar (that is an expression)
13:54:41 <arkeet> hmm
13:54:44 <acowley> does lambdabot  know about Text?
13:54:48 * hackagebot Dust-tools 1.0 - Network filtering exploration tools  http://hackage.haskell.org/package/Dust-tools-1.0 (BrandonWiley)
13:54:55 <arkeet> > S.fromList "abc" ^@.. folded
13:54:56 <lambdabot>   [(0,'a'),(1,'b'),(2,'c')]
13:55:00 <arkeet> hmmm
13:55:01 <dgpratt> I see, thanks again enthropy
13:55:06 <arkeet> uhh
13:55:10 <enthropy> I guess you have to look at the language definition to see exactly what is an expression then
13:55:11 <arkeet> oh
13:55:13 <acowley> that "abc" contains example seems like a good argument for making String literals Text
13:55:19 <joe9> is there a splitAt but, instead of returning a tuple, that returns a list?
13:55:21 <arkeet> > S.fromList "abc" ^@.. ifolded
13:55:22 <lambdabot>   No instance for (Control.Lens.Indexed.FoldableWithIndex
13:55:23 <lambdabot>                    ...
13:55:33 <acowley> when lens goes into Prelude, we should think about that
13:55:34 <acowley> :P
13:56:01 <joe9> such that : splitAt 3 [1..10] = [[1,2,3],[4,5,6],[7,8,9],[10]]
13:56:16 <cschneid> joe9: there's something in Data.List.Split package that does that
13:56:22 <joe9> cschneid: thanks.
13:56:28 <mauke> chunksOf?
13:56:46 <joe9> mauke: thanks.
13:56:51 <cschneid> > Data.List.Split.splitEvery 3 ['a'..'z']
13:56:52 <lambdabot>   mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMs...
13:56:56 <Vamp> Why does handCategory gives an error? http://lpaste.net/1636130352181280768
13:57:01 <cschneid> > splitEvery 3 ['a'..'z']
13:57:03 <lambdabot>   mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMs...
13:57:06 <mauke> > ()
13:57:07 <lambdabot>   ()
13:57:18 <cschneid> ohh, google gave me something ancient
13:57:23 <cschneid> > chunksOf 3 ['a'..'z']
13:57:25 <lambdabot>   ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz"]
13:57:33 <fizruk> Vamp: ranks hand is not Bool
13:57:46 <mauke> Vamp: HighCard is not HandCategory
13:57:51 <pqmodn> :t (\n -> takeWhile (not . null) . map (take n) . iterate (drop n))
13:57:52 <lambdabot> Int -> [a] -> [[a]]
13:58:10 <pqmodn> (\n -> takeWhile (not . null) . map (take n) . iterate (drop n)) 3 [1..10]
13:58:15 <pqmodn> > (\n -> takeWhile (not . null) . map (take n) . iterate (drop n)) 3 [1..10]
13:58:16 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
13:58:47 <Vamp> fizruk: Hmm but for a HighCard the field of type [Rank ] contains all five cards in the hand, sorted from high to low.
13:58:48 <pqmodn> oh wait, where is chunksOf from?
13:58:54 <intrados> startling: I'd like to get a collection back if I lookup with just one of the two indices. Would Data.Map still make sense then?
13:59:18 <startling> intrados, no.
13:59:18 <fizruk> Vamp: did you mean "HighCars (ranks hand)"?
13:59:54 <intrados> For that use case, is tables the best (or a good) option then?
13:59:55 <startling> intrados: well, you could get a partially-applied lookup function.
14:00:07 <fizruk> Vamp: "| ranks hand = HighCard" is read as "if (ranks hand) then HighCard"
14:00:11 <startling> it seems like tables is still a research project.
14:00:19 <startling> intrados, maybe use one of the array things?
14:00:36 <elliott> I don't think tables is researching anything.
14:00:41 <elliott> it's meant to be quick-n-dirty.
14:00:42 <Vamp> fizruk: Aha I see
14:00:44 <startling> OK, maybe I'm wrong.
14:02:02 <startling> Does lens have a shorter way to say "(==) `on` view someLens"?
14:02:25 <tenletters> i tore my ACL trying to cabal install cuda
14:02:27 <shachaf> startling: I doubt it.
14:02:33 <startling> shachaf: OK, thanks anyway.
14:02:34 <tenletters> please help me for the love of god
14:02:45 <donri> intrados: give data-store a try
14:02:51 <Vamp> fizruk: I'm just finding out what the syntax should be for what I want to do
14:02:59 <acowley> the tables docs really threw me, I misread esoterica as erotica :/
14:03:12 <fizruk> Vamp: what do you want to do? :)
14:03:36 <Vamp> fizruk: I need  a function handCategory ::Hand -> HandCategory that converts a Hand into a HandCategory
14:04:02 <fizruk> Vamp: I guess you need some cases, right?
14:04:20 <Vamp> fizruk: Indeed, that's what I tried to build up, but went wrong at the first case already :P
14:04:58 <acowley> tables actually looks quite interesting
14:05:04 <acowley> I hadn't given it much time before
14:05:09 <fizruk> for default case you want HighCard, right? so you want handCategory hand = HighCard (ranks hand)
14:05:21 <acowley> Does anyone have any code using tables out there?
14:05:43 <donri> tables has critical bugs that have been unresolved for half a year or so though :)
14:05:57 <acowley> Oh, well that's a chink in the armor
14:06:18 <donri> i use tables in http://hub.darcs.net/dag/kibr
14:06:25 <donri> and then kind of stopped working on that because of the tables bug :P
14:06:37 <Vamp> fizruk: I actually need to make a bool of the ranks function made and use that one?
14:06:44 <acowley> donri: Where do I look for the tables code?
14:06:48 <acowley> donri: And what bugs?
14:07:09 <fizruk> Vamp: name any case except default
14:07:33 <acowley> donri: Oh, looking at the github issues now
14:07:50 <acowley> donri: You should really get on fixing those issues
14:08:20 <donri> acowley: i tried but the tables code is too crazy for my brain ;)
14:08:34 <chrisdone> donri: you can steal the name kibro if you want
14:08:35 <acowley> donri: Then you should make the code look more like your brain
14:08:38 <donri> acowley: my tables stuff is in Kibr.{Data,State}
14:08:59 <donri> chrisdone: :) but i like "kibr" because it's so web 2.0
14:09:04 <chrisdone> tru
14:09:16 <acowley> You came so close to 100 lines of LANGUAGE and imports, why stop short?
14:09:35 <donri> where?
14:09:53 <acowley> http://hub.darcs.net/dag/kibr/browse/src/Kibr/Data.hs
14:10:21 <acowley> a good chunk of it is the export list, but I enjoy a good preamble to a module
14:10:33 <donri> that looks rather innocent to me? most of them are for deriving stuff
14:10:51 <acowley> I'm just teasing
14:10:54 <donri> :)
14:11:10 <donri> acowley: https://github.com/ekmett/tables/blob/master/src/Data/Table.hs
14:11:19 <donri> even sorted by line length
14:11:21 <acowley> Omg
14:11:23 <acowley> that is amazing
14:11:29 <donri> inorite
14:11:51 <chrisdone> {-# LANGUAGE OCD #-}
14:13:24 <donri> acowley: also oh, i missed that you said "and imports"
14:13:35 <donri> i thought you were saying i had close to 100 lines of LANGUAGE pragmas :P
14:13:49 <donri> i don't think ghc even has that many :D
14:14:04 <Vamp> fizruk: What I tried actually was doing something like this http://lpaste.net/9165239113337536512
14:14:35 <donri> ghc --supported-extensions | grep -v No | wc -l  says 88
14:14:50 <donri> i wonder if you can enable all of them in the same module
14:14:50 <pqmodn> but the pragmas don't use alphabetical order as a tie-breaker. pull request time
14:14:59 <acowley> New goal: Arrange LANGUAGE pragmas as a shibe
14:15:17 <donri> clearly pragmas should be sorted by version they got added to ghc
14:15:53 <acowley> {-# LANGUAGE Wow #-}
14:16:00 <fizruk> vamp: ok, I see
14:16:06 <donri> AlternativeLayoutRuleTransitional  one wonders what all these extensions do
14:16:21 <Vamp> fizruk: But I don't know if that is possible with my data etc
14:17:07 <fizruk> it is possible, yet maybe in another fasion
14:19:05 <lightquake> acowley: wow, such undecidable, many types
14:19:21 <xico> is there a command to extract info from /var/lib/ghc/package.conf.d/builtin_rts.conf ?
14:19:29 <xico> like ld-options
14:19:30 <fizruk> Vamp: consider functions handOnePair, handTwoPair, etc. :: Hand -> Maybe HandCategory
14:19:31 <acowley> This idea has legs. chrisdone could add it to haskell-mode.
14:20:09 <pqmodn> the game is afoot
14:20:22 <osa1> I never used template haskell myself -- what's unsafe about it?
14:20:39 <chrisdone> pqmodn: i get the reference. i like you
14:20:42 <xico> (ghc-pkg maybe)
14:20:58 <pqmodn> :)
14:21:24 <chrisdone> acowley: at least stylish-haskell sorts out pragmas
14:21:50 <jfischoff> osa1: it can run IO actions
14:21:59 <startling> Hmm, it just took me a few minutes to realize I was accidentally using dog-notation.
14:22:16 <startling> I think I need another cup of coffee.
14:22:30 <osa1> jfischoff: what? in compile time?
14:22:36 <jfischoff> yes
14:22:44 <Vamp> fizruk: In the case of a TwoPair the first Rank is that of the high pair, the second Rank that of the low pair, and the third Rank that of the kicker (the card that isn’t part of any of the two pairs) for instance. And for a HighCard the field of type [Rank ] contains all five cards in the hand,  sorted from high to low. That's [Rank] stands after HighCard
14:22:54 <chrisdone> pqmodn: see the gazzora edits?
14:23:58 <osa1> jfischoff: but generated code would still be well-typed safe haskell?
14:24:03 <jfischoff> sure
14:24:06 <osa1> okay
14:25:02 <osa1> when I heard that unsafety I though it can generate ill typed haskell or something like that
14:25:21 <chrisdone> someone should make a translation party for haskell that translates to core and then back to haskell
14:25:39 <fizruk> Vamp: are you sure you want your HandCategory structure as is? if so, I can think of creating a bunch of functions like handTwoPair :: Hand -> HandCategory and then combine them as monoid/alternative
14:25:46 <monochrom> that will be a cool game
14:25:49 <osa1> chrisdone: what's the point for that?
14:26:32 <Vamp> fizruk: Yup
14:26:40 <chrisdone> osa1: http://translationparty.com/ -- it tries to get a fixpoint of applying translation to and from a language
14:26:54 <chrisdone> osa1: but with amusing results =)
14:27:42 <osa1> hahah lol
14:27:43 <monochrom> consider http://article.gmane.org/gmane.comp.lang.haskell.cafe/104783/ :)
14:28:04 <Vamp> fizruk: Is this valid? handCategory hand = HighCard (ranks hand)
14:28:22 <Vamp> ranks just sorts the hand from high to low, just what I want for HighCard
14:28:44 <fizruk> Vamp: try it :)
14:28:58 <Vamp> fizruk: It doesn't give a error
14:29:33 <startling> lens question -- will "ix t . contains r .~ True" add an item to a Map a (Set b) ?
14:29:42 <startling> I'm thinking no, but ...
14:30:01 <edwardk> startling: it will add it if the Set is already there
14:30:08 <startling> but not otherwise. got it.
14:30:19 <startling> Is there a nice way to do it in both cases?
14:30:20 <Vamp> fizruk: For the next one I just have to do a second case like: handCategory hand = OnePair (undefined) then, if I'm right?
14:30:31 <edwardk> startling: at t . non Set.empty . contains r .~ True will make up a set from whole cloth if needed and delete the set if you delete it
14:30:33 <acowley> non
14:30:44 <startling> :t non
14:30:50 <startling> :t Control.Lens.non
14:30:51 <lambdabot> (Eq a, Functor f, Profunctor p) => a -> p a (f a) -> p (Maybe a) (f (Maybe a))
14:31:04 <edwardk> non is an isomorphism between Maybe (a sans some value) and 'a'
14:31:04 <startling> Perfect. thanks.
14:31:18 <acowley> isn't there a non for Monoids that uses mempty?
14:31:26 <edwardk> > M.fromList [(1,2)] & at 3 . non 0 +~ 1
14:31:27 <lambdabot>   fromList [(1,2),(3,1)]
14:31:35 <skypers> hey
14:31:44 <startling> acowley: that would be even better.
14:31:57 <edwardk> acowley: in head we have 'anon _Empty' but it is awkward enough to use we're probaby killing it
14:32:04 <skypers> I’d like to write a class which each instances has to define a specific type
14:32:06 <edwardk> nothing there is picking the instance.
14:32:08 <skypers> how should I do that?
14:32:09 <skypers> just
14:32:12 <skypers> class Foo where
14:32:17 <fizruk> Vamp: no, you should either do a case analysis (which will result in a bunch of if-then-else branches) or combine different transformation function which return Maybe's
14:32:19 <skypers>   type x :: ?
14:32:24 <fizruk> Vamp: give me a sec
14:32:41 <edwardk> :t only
14:32:48 <edwardk> :t anon
14:32:52 <edwardk> :t Control.Lens.anon
14:32:53 <lambdabot> (Functor f, Profunctor p) => APrism' a () -> p a (f a) -> p (Maybe a) (f (Maybe a))
14:33:03 <edwardk> :t anon (only Set.mempty)
14:33:04 <lambdabot> Couldn't find qualified module.
14:33:13 <edwardk> :t anon (only S.mempty)
14:33:14 <lambdabot> Couldn't find qualified module.
14:33:16 <edwardk> :t anon (only S.empty)
14:33:16 <lambdabot> (Eq a, Functor f, Profunctor p) => p (S.Set a) (f (S.Set a)) -> p (Maybe (S.Set a)) (f (Maybe (S.Set a)))
14:33:18 <edwardk> :t anon (only mempty)
14:33:19 <lambdabot> (Eq a, Functor f, Monoid a, Profunctor p) => p a (f a) -> p (Maybe a) (f (Maybe a))
14:33:22 <edwardk> sorry for the spam
14:33:50 <startling> I'll just use non mempty.
14:33:59 <shachaf> :t (anon)
14:34:00 <lambdabot> (Functor f, Profunctor p) => APrism' a () -> p a (f a) -> p (Maybe a) (f (Maybe a))
14:34:00 <edwardk> :t anon (only mempty) . contains 12
14:34:01 <lambdabot> (Eq m, Num (Index m), Monoid m, Indexable (Index m) p, Contains f m) => p Bool (f Bool) -> Maybe m -> f (Maybe m)
14:34:07 <shachaf> Yay, you don't need to use the qualified name.
14:34:12 <chrisdone> monochrom: haha, awesome. this further incentivizes me to add core output to lpaste
14:34:23 <edwardk> shachaf: hah good catch
14:34:26 <monochrom> onoes
14:35:05 <Vamp> fizruk: Aha, I already have some sort of helper functions that I could use http://lpaste.net/3381750402968977408
14:36:34 <fizruk> @pl foldr (<|>) empty
14:36:34 <lambdabot> foldr (<|>) empty
14:37:44 <skypers> no one ?
14:38:03 <skypers> I’d like to make a class that defines a function that would give a type
14:38:05 <skypers> like
14:38:08 <chrisdone> skypers: sorry, you were lost in the spam
14:38:27 <skypers> class Foo f where { fooType :: AType }
14:38:31 <skypers> but that just fails
14:38:36 <skypers> because I don’t use f
14:38:42 <tdammers> foldr (<|>) empty... I think I wrote that too many times already
14:38:42 <skypers> so I can do something like
14:38:50 <acowley> skypers: associated type families?
14:38:51 <skypers> fooType :: f -> AType
14:38:53 <skypers> and use
14:39:03 <skypers> fooType (undefined :: hihi)
14:39:26 <skypers> hm it wouldn’t work actually
14:39:27 <chrisdone> you could have a phantom type to pass the dictionary in
14:39:28 <skypers> dammit
14:39:39 <chrisdone> fooType :: Proxy f AType
14:39:46 <fizruk> @where ala
14:39:46 <lambdabot> I know nothing about ala.
14:39:57 <skypers> I’d like to pattern match such a type
14:40:13 <jfischoff> can you explain the context?
14:40:23 <skypers> I have a class
14:40:29 <skypers> and a lot of instances of that class
14:40:38 <xrdb> has someone defined a typeclass for a Monoid m together with a map rho :: a -> m, which is compatible with mappend?
14:40:54 <skypers> I want to write a constrainted instance of the class for another class Bar
14:41:00 <fizruk> where's `ala' defined?
14:41:05 <jfischoff> xrdb: maybe reducers
14:41:09 <skypers> in order not to write as many instances of Bar class as Foo instances
14:41:16 <skypers> I might not be clear…
14:41:23 <chrisdone> maybe paste some code
14:41:30 <chrisdone> @where lpaste
14:41:30 <lambdabot> http://lpaste.net/new/haskell
14:42:41 <fizruk> Vamp: write a function handTwoPair :: Hand -> Maybe HandCategory which returns Just (TwoPair _ _ _) is hand is a TwoPair and Nothing otherwise
14:43:51 <briennetheblue> fizruk this ala? http://hackage.haskell.org/package/lens-3.9.2/docs/Control-Lens-Wrapped.html#v:ala
14:44:09 <briennetheblue> that or the one in Control.Newtype or whatever it is
14:44:54 * hackagebot udev 0.0.0.0 - libudev bindings  http://hackage.haskell.org/package/udev-0.0.0.0 (SamTruzjan)
14:44:56 <fizruk> briennetheblue: thanks!
14:45:03 <briennetheblue> np :)
14:46:22 <ion> Next version: 0.0.0.0.0
14:46:34 <ion> That would actually be a cool versioning scheme. Someone should use it.
14:46:36 <chrisdone> wish cabal didn't default to 4 points
14:47:22 <skypers> chrisdone: http://lpaste.net/7899961552030138368
14:47:23 <skypers> here its
14:48:13 <skypers> I could write data Foo2Stage
14:48:15 <skypers> Foo3Stage
14:48:18 <skypers> Foo4Stage
14:48:20 <skypers> and so on
14:48:42 <skypers> but I don’t exactly know how should I write the FooClass class to make it work
14:49:15 <jfischoff> I don't really get the problem
14:49:30 <skypers> the problem is
14:49:33 <chrisdone> jfischoff: he wants to write classes without all the methods taking an argument for the instance dictionary
14:49:43 <skypers> yeah sort of
14:49:45 <jfischoff> chrisdone: ah
14:49:47 <skypers> or well
14:49:51 <skypers> I heard about type
14:49:53 <skypers> in class
14:49:54 <skypers> lik
14:49:54 <skypers> e
14:49:58 <jfischoff> yeah like chrisdone said, proxy
14:49:59 <skypers> class Foo f where
14:50:02 <skypers>   type s
14:50:08 <skypers> but it would break my ctor use
14:50:12 <skypers> proxy?
14:50:28 <skypers> isn’t my FooClass already a proxy?
14:50:44 <skypers> it’s just here to write instances of Object
14:51:10 <jfischoff> http://hackage.haskell.org/package/tagged-0.2.3.1/docs/Data-Proxy.html
14:51:22 <alpounet> a proxy is a type that draps another, with an additional type parameter used just "as a flag", as in there is no field of that type, it's just "an indicator"
14:51:29 <alpounet> s/draps/wraps
14:51:30 <chrisdone> i'm not sure proxy is applicable anymore. it seems just passing an arg is easiest
14:51:48 <jfischoff> its basically the same thing
14:52:02 <jfischoff> instead of using undefined
14:52:05 <xrdb> jfischoff, reducer is a strange name, but this is indeed what i was looking for
14:52:45 * shachaf . o O ( "Introduction to Functional Programming using Haskell (2nd Edition)" by Richard Bird in 1998 at <http://www.cs.ox.ac.uk/publications/books/functional/> )
14:52:49 <shachaf> Er, wrong channel.
14:53:08 <jfischoff> yeah get that crap out of here!
14:53:09 <shachaf> :-(
14:53:24 <chrisdone> oh, something similar to proxy would work
14:54:44 <skypers> ok so
14:54:46 <monochrom> how dare you call my favourite author's book crap :)
14:54:52 <skypers> you advise me to use proxy here?
14:55:29 <chrisdone> newtype Type f t = Type { getType :: t }
14:55:30 <monochrom> in fact, that book explains both foldl' and monad transformers. 1998. can you fancy that?
14:55:34 <skypers> I think passing undefined sounds simplier
14:55:34 <chrisdone> fooType :: Type s Foo
14:55:38 <chrisdone>  fooType = Type Foo1
14:55:44 <monochrom> 1998 is, like, way before you even heard of haskell
14:55:46 <jfischoff> based on the author … yes
14:55:46 <chrisdone> that's one way to avoid the arg passing
14:55:53 <chrisdone> but… is it worth it?
14:55:56 <skypers> why would we avoid it?
14:56:03 <chrisdone> you seem to want to
14:56:04 <jfischoff> you still pass it in
14:56:08 <skypers> I use it with const
14:56:32 <jfischoff> is there a good way to update an installed package with cabal? Something that will uninstall and reinstall all the dependent packages?
14:56:57 <jfischoff> I am under the impression this is not something cabal likes to do...
14:57:25 <chrisdone> dunno. i tend to cabal install --force-reinstall --force-reinstalls and then install the ones that are broke
14:57:32 <FreeFull> I was thinking,  Functor f => (a -> f b) -> s -> f t  is a Lens, Applicative is a Traversable, is Monad anything?
14:57:40 <FreeFull> Anything meaningful or useful that is
14:58:00 <acowley> jfischoff: cabal install --dependencies-only in a sandbox seems to do the right thing for me
14:58:11 <monochrom> jfischoff: http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#config
14:58:14 <acowley> jfischoff: In the past, I'd write a bash for loop to unregister everything cabal tells me will break
14:59:14 <lpaste> chrisdone annotated “No title” with “skypers” at http://lpaste.net/7899961552030138368#a94167
14:59:20 <jfischoff> monochrom: I think you have the only description of the local repo format :p
14:59:30 <monochrom> \∩/
14:59:43 <Lambi> Hey, anyone sitting on Xcode? If so, what's the best option for syntax colouring?
14:59:50 <Lambi> syntax highlighting
15:00:03 <lispy> chrisdone: I hope my relpy to you on Haskell cafe is helpful. It's an interesting problem.
15:00:21 <lpaste> chrisdone annotated “No title” with “problem solved” at http://lpaste.net/7899961552030138368#a94168
15:00:27 <lispy> chrisdone: Something I forgot to mention in email, someone was proposing to base future lambdabot on SafeHaskell
15:00:31 <jfischoff> hey lispy
15:00:36 <chrisdone> lispy: cool, i'll check it out!
15:00:37 <lispy> jfischoff: yo
15:00:47 <chrisdone> skypers: check that out, i think you'll be pleased
15:00:52 <jfischoff> I have finally had time to think about how I would like to manage packages at work
15:00:58 <jfischoff> in more detail
15:01:00 <lispy> great
15:01:27 <skypers> ok, thank you
15:01:48 <chrisdone> skypers: hm, although without the newtype i think you won't be able to invoke fooType properly
15:02:07 <jfischoff> I have a few requirements
15:02:16 <jfischoff> I need to ensure that all the packages on all developers are the same.
15:02:29 <jfischoff> A internal hackage solves this to a point
15:02:58 <lispy> right
15:02:58 <jfischoff> but as soon as we update the hackage mirror, this doesn't cause developers machines to update their installed packages
15:03:10 <intrados> Surely there's a better way of doing this: http://sprunge.us/WIXQ
15:03:17 <jfischoff> I basically have no idea what packages are installed on people's machines
15:03:18 <lispy> jfischoff: oh right.
15:03:41 <jfischoff> All I know is each time some one spins up, some new issue shows up :p
15:03:58 <lispy> jfischoff: and I think cabal makes this harder because it won't download a new version if the currently installed one meets the constraints
15:03:59 <chrisdone> skypers: yeah, you need the newtype version. so you use it like this:
15:03:59 <chrisdone> λ> getType (fooType :: Type Foo2Stage Foo)
15:03:59 <chrisdone> Foo2
15:04:13 <jfischoff> /me nods
15:04:36 <chrisdone> skypers: hope that helps with the problem or gives you some ideas, anyway. gonna go read what lispy wrote for me on haskell-cafe now =)
15:04:45 <PhineasRex> jfischoff: what is preventing you from just pushing a script to all developer machines?
15:04:46 <jfischoff> also have every developer build the binaries is wasteful
15:04:55 <lispy> jfischoff: and polling the internal hackage on each build is expensive. Does that mean you need a push model?
15:05:09 <jfischoff> because every developer has the same VM so we could just build them once
15:05:25 <Lambi> (Never mind, I'll use TextMate or Sublime)
15:06:05 <jfischoff> I think what I would like is to have the libraries and the associated package db on a server that is rsynced when the sources are pulled
15:07:02 <lispy> jfischoff: just a minute, spontaneous meeting
15:07:05 <jfischoff> np
15:08:45 <chrisdone> lispy: fwiw i'm using mueval for tryhaskell, the same thing lambdabot uses. for evaluation that's been pretty solid, very easy to secure and manage. compiling top-level decls and whole files otoh… seems a whole different kettle of fish
15:09:05 <jfischoff> PhineasRex: what do you mean?
15:09:23 <sie> How does the IO monad magic work? How does it know it is being called from main?
15:09:30 <mauke> what do you mean by "called"?
15:09:57 <hpc> sie: your entire program is a single IO () value
15:10:29 <hpc> this value is composed of other values
15:10:44 <chrisdone> lispy: it's worrying that GND can be used to cause a segfault. by template-haskell i meant that i want to enable it, but disable IO. afaik, TH can only use what is imported normally
15:10:45 <hpc> (>>=) defines how those sub-values get sequenced
15:10:48 <PhineasRex> jfischoff: if I understand correctly, you've set up an internal cabal mirror that all dev machines use.
15:10:54 <jfischoff> yes
15:11:31 <hpc> sie: main itself is magically searched for by the compiler, but that's the same for C and Java and whatever
15:11:39 <PhineasRex> jfischoff: since you should have root on the dev machines, you can just have a script that updates your cabal mirror, then runs cabal update on all dev machines.
15:11:44 <hpc> and then executing main is also magic
15:11:52 <lispy> chrisdone: I'm not sure if that would work for TH or not.
15:11:57 <lispy> jfischoff: hmm
15:12:09 <jfischoff> PhineasRex: which not in anyway update the installed packages
15:12:21 <jfischoff> s/which/which would
15:12:27 <hpc> sie: for a good migrane, main() is not the first thing called in a C program; there's some minimal extra stuff and you might try learning what it is ;)
15:12:42 <PhineasRex> jfischoff: You can poll the machine for installed packages then update them.
15:12:54 <hpc> er, GCC C program
15:13:08 <jfischoff> part of the issue is updating is not something that is providing out of the box
15:13:17 <lispy> chrisdone: the work on Roles for ghc 7.8 is to prevent the GND segfaults
15:13:20 <chrisdone> lispy: me neither… i might just start with a whitelisted set of declarations with HSE. simple functions, whitelisted extensions and imports
15:13:27 <chrisdone> oh, that's what that's about? i see
15:13:52 <jfischoff> I basically need to be able to manage for users there package db and installed libs
15:14:02 <jfischoff> brb
15:14:02 <acowley> I thought roles were also used to better eliminate newtype coercions
15:14:21 <lispy> chrisdone: the problem with GND is that your can reuse the representation (and thus the dictionaries), but you can also define your own dictionaries for newtypes. Those two things can be at odds with each other.
15:15:12 <PhineasRex> jfischoff: you can use cabal-install to install the latest version of a package. Is that not an upgrade?
15:15:13 <lispy> chrisdone: so maybe someone could newtype IO and use GND but maybe define a harmless Monad instance and then confuse GHC into actually doing IO?
15:15:25 <lispy> acowley: that's how you get the segfault :)
15:15:25 <startling> Is there a thing to turn a lens into something working on Monad? I'd like to avoid the extra ugly Functor constraint.
15:15:36 <startling> I'm using the silly _2 id trick
15:15:36 <lispy> acowley: so yes, what you're saying generalizes what I'm saying
15:16:17 <enthropy> benmachine: there's a better solution to the infix problem (there's a pull request to change defaults so that it gets used all the time)
15:17:02 <lispy> jfischoff: I wonder if the janrain folks have a tool for this.
15:17:54 <lispy> i don't see it on their github
15:18:00 <lispy> I must be thinking of something else
15:18:37 <monoidal> chrisdone: fyi, ghc 7.6 has a bug allowing to write unsafeCoerce given multiple modules support + type families
15:18:49 <chrisdone> @_@
15:19:07 <startling> I guess D.T.mapM
15:19:09 <fizruk> Vamp: how's your progress?
15:19:10 <greg`>  Unknown entity "intercalate" imported from module "Data.List
15:19:12 <greg`> what gives?
15:19:22 <chrisdone> what compiler is that?
15:19:35 <chrisdone> UHC?
15:19:43 <greg`> ghc
15:19:45 <geekosaur> greg`, which compiler and version?
15:20:05 <chrisdone> strange… i don't recognise the format of that error message
15:20:15 <greg`> actually not sure , hang on im doing it from emacs
15:20:22 <greg`> works ok on command line
15:20:31 <chrisdone> maybe emacs is launching hugs
15:20:34 <chrisdone> or something
15:20:47 <greg`> Hugs
15:20:55 <greg`> yes its hugs
15:20:55 <geekosaur> that'd be it, then
15:21:00 <geekosaur> hugs is ancient and unmaintained
15:21:04 <greg`> ah
15:21:15 <geekosaur> it's missing a lot of stuff from the past, oh, ten years or so
15:21:24 <greg`> ah i dont think i can get ghci into emacs
15:21:38 <chrisdone> hugs is cool though. it's got that small-codebase factor about it
15:21:47 <geekosaur> think you can, with the right settings
15:22:02 <chrisdone> greg`: yeah M-x customize-group emacs find err
15:22:03 <monochrom> set the variable haskell-program-name to "ghci"
15:22:08 <greg`> yeah ive got emacs running on an arm chromebook , with hugs and ghc pretty sweet
15:22:09 <chrisdone> that
15:22:18 <chrisdone> nice
15:22:34 <Vamp> fizruk: I tried this but the types don't match at all http://lpaste.net/6083287422018256896
15:23:02 <chrisdone> lispy: on the subject of running code, i've always thought hugs would be neat, because it's really easy to just go and cripple the IO/FFI facilities
15:23:09 <fizruk> Vamp: TwoPair need 3 arguments
15:23:16 <chrisdone> it's only haskell 98, but still
15:23:17 <fizruk> s/need/needs/
15:23:30 <geekosaur> see, if someone would take it over and update it, it would be nice
15:23:34 <geekosaur> but nobody has
15:23:35 <greg`> ah i dont have ghci on arm
15:23:39 <fizruk> Vamp: you should specify those pairs
15:23:39 <greg`> its not allowed :P
15:23:43 <geekosaur> um
15:23:54 <chrisdone> geekosaur: i compiled it to js with emscripten and it ran fine =D
15:24:12 <chrisdone> and the js was as small as the binary (1M~). that's how small hugs is
15:24:17 <Vamp> fizruk: I tried to use my helper function order, since that one gives the Ranks with their multiplicity
15:24:18 <geekosaur> older ghc (like 7.4 and earlier) didn't support ghci on arm. I think 7.6.3 should work?
15:24:26 <geekosaur> might need to hunt around for the right repo
15:24:44 <monochrom> oh! arm.
15:24:50 <geekosaur> ghci breaks some rules which made it rather nonportable to some platforms
15:24:58 * hackagebot postgresql-simple 0.3.8.0 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.3.8.0 (LeonSmith)
15:25:06 <chrisdone> lpsmith: =)
15:25:11 <geekosaur> arm was specifically fixed recently, and ghc 7.8 has made changes which should remove that particular source of incompatibility for good
15:26:13 <fizruk> Vamp: you need something like this: case order hand of [(2, x), (2, y), (1, z)] -> Just (TwoPair x y z); _ -> Nothing
15:26:57 <fizruk> if order is sorting the result by multiplicity
15:27:13 <fizruk> otherwise you should do it manually
15:27:52 <fizruk> case sortBy (comparing fst) (order hand) of ...
15:27:55 <Vamp> fizruk: Yeah it sorts, [10D,3C,JD,QC,JC] gives [(2,J),(1,Q),(1,10),(1,3)] for instance
15:28:18 <greg`> oh frabcious day!
15:28:35 <fizruk> Vamp: okay, then the first variation should work just fine
15:29:07 <fizruk> Vamp: in you try there's also a problem with fst (order hand) == 2
15:29:31 <Vamp> fizruk: Because it doesn't check all tupels?
15:29:32 <fizruk> Vamp: since (order hand) :: [(Int, Rank)], you cannot fst on it
15:29:39 <fizruk> :t fst
15:29:39 <lambdabot> (a, b) -> a
15:29:43 <greg`> need to find 7.6.3 its not in my repository
15:29:45 <Vamp> fizruk: Yeah idd
15:30:19 <fizruk> Vamp: you could write map fst (order hand) == [2, 2, 1]
15:30:54 <fizruk> Vamp: but anyway you would lose the ranks (and you need them to build HandCategory value)
15:30:59 <Vamp> fizruk: And now I have to put handTwoPair in handCategory :: Hand -> HandCategory?
15:31:00 <lispy> chrisdone: I think getting the GHC into google's native client would also be interesting. Starting from HaLVM might make that a lot easier, too
15:31:07 <lispy> GHC RTS*
15:31:47 <lispy> chrisdone: in fact, depending on how you wanted to do that, the native client could be server side or client side.
15:32:08 <fizruk> Vamp: you will have a number of Hand -> HandCategory functions for each category type (except HighCard, which is default)
15:33:20 <fizruk> Vamp: using (<|>) from Control.Applicative, you can compose cases: handTwoPair hand <|> handFlush hand
15:33:27 <greg`> http://ghc.haskell.org/trac/ghc/wiki/ArmLinuxGhc
15:33:43 <greg`> dont see ghci for arm supported anywhere
15:33:49 <greg`> are you sure this is fixed?
15:34:24 <pqmodn> i really hate how defaulting hides issues caused by the monomorphism restriction
15:34:38 <geekosaur> there was a specific repo with patches; the official one probably not getting them because of the real fix in 7.8
15:34:51 <pqmodn> at least it's becoming easier for me to recognize it
15:34:57 <geekosaur> which should be released soonish (original plan was in conjunction with icfp, I think?)
15:35:00 <fizruk> Vamp: then you can pattern match on the result: case ... <|> ... of Just cat -> cat; Nothing -> HighCard (ranks hand)
15:35:40 <Vamp> fizruk: Hmm I never saw (<|>), could you give an example of it?
15:35:59 <fizruk> > Nothing <|> Just 1 <|> Just 2
15:36:00 <lambdabot>   Just 1
15:36:22 <Vamp> And why it gives Just 1?
15:36:25 <fizruk> Vamp: for Maybe it return first non-Nothing
15:36:46 <Vamp> fizruk: Aha I see
15:36:51 <fizruk> Vamp: if everything is Nothing then the result is Nothing
15:36:56 <fizruk> > Nothing <|> Nothing
15:36:57 <lambdabot>   Nothing
15:36:57 <chrisdone> lispy: oh yeah, indeed! i saw the talk about NC a while back, clever stuff. compiling ghc to that would be veeeery cool
15:37:29 <Vamp> fizruk: So I should make all functions for Handcategory now like I did with handTwoPair?
15:37:37 <Vamp> fizruk: Except for HighCard then
15:37:53 <greg`> is 7.8 out yet?
15:38:24 <fizruk> Vamp: actually, you can do handTwoPair and handOnePair with a single function
15:38:30 <chrisdone> lispy: it's not a bad idea at all… have you tried using NC for anything? simple C program or whatever?
15:38:54 <chrisdone> lispy: that's suddenly the most fascinating idea ever
15:39:30 <geekosaur> greg`, not yet. per the mailing list they're still finalizing and testing stuff; some of the changes in ghc 7.8 necessitate library updates in various plces and they'd like most of hackage to already work with 7.8 before it is released
15:40:00 <geekosaur> I just saw a "here's what needs to be updated still" go by on the list
15:40:11 <Vamp> fizruk: [(2,x) (1,w), (1,y),(1,z)] -> Just (OnePair x)
15:40:16 <Vamp> fizruk: Like that?
15:40:19 <SwashBuckla> > Nothing <|> Nothing $ <|> $ Nothing <|> Nothing
15:40:21 <lambdabot>   <hint>:1:23: parse error on input `<|>'
15:40:22 <Vamp> fizruk: As other case
15:40:46 <SwashBuckla> > (Nothing <|> Nothing) <|> (Nothing <|> Nothing)
15:40:47 <lambdabot>   Nothing
15:40:47 <fizruk> Vamp: OnePair x [w, y, z]
15:41:21 <SwashBuckla> > (Nothing <|> Nothing) <|> (Nothing <|> Just 1)
15:41:27 <lambdabot>   Just 1
15:41:47 <fizruk> :t getFirst
15:41:47 <lambdabot> First a -> Maybe a
15:42:06 <Vamp> fizruk: Ah yeah you're right forgot it was Rank [Rank]
15:42:15 <Vamp> fizruk: :)
15:42:17 <pqmodn> is there a combinator for abbreviating action >>= ($ arg) ?
15:42:51 <fizruk> Vamp: do you have a vision of handCategory implementation now?
15:42:58 <pqmodn> @hoogle m (a -> m b) -> a -> m b
15:43:00 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
15:43:00 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
15:43:00 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
15:43:22 <Vamp> fizruk: I think so, I'll first try to make the functions for isStraight etc too now
15:43:40 <Vamp> fizruk: I'll probably come back at you when I'm done with that
15:43:44 <fizruk> Vamp: okay, I'm going to get some sleep then :)
15:43:59 <Vamp> fizruk: Thanks :) Night!
15:47:59 <neutrino137_> @help
15:48:00 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:02:58 <quchen> Is the ApplicativeDo proposal thread on Reddit the official discussion? I was surprised when there was nothing on the mailing lists
16:03:32 <monoidal> quchen: there was a discussion on glasgow-haskell-users
16:03:51 <quchen> Ugh how many lists are there to keep track of
16:04:19 <Codex_> @djinn (a->b)->(b->Bool)->(a->Bool)
16:04:19 <lambdabot> f a b c = b (a c)
16:04:39 <hpc> quchen: if it's not on -cafe, it didn't happen
16:04:44 <hpc> you're pretty safe with just the one list
16:04:53 <quchen> I'm also not on -cafe.
16:05:16 <quchen> (Isn't that for beginner talk and general chat?)
16:05:50 <geekosaur> there's a separate beginners list
16:06:03 <geekosaur> -cafe is for general chat
16:06:05 <hpc> -cafe gets a lot of language proposal talk too
16:06:12 <geekosaur> but also lots of serious stuff
16:06:35 <hpc> the only unserious thing i can think of is HWN
16:06:41 <hpc> which is once a week
16:06:49 <geekosaur> I have to admit my mail setup does not lead me to pay much attention to which specific list something is on
16:07:20 <geekosaur> I glom haskell@, cafe, beginners, language, ghc-users, etc. into a single "haskell" category
16:08:24 <pqmodn> are there free web-based mailing list clients? gmail seems like a poor choice because of the way it threads conversations
16:08:37 <leroux> pqmodn: gmane?
16:09:14 <geekosaur> you can turn off threading
16:09:30 <geekosaur> (it's called "conversations" in the general settings)
16:11:16 <pqmodn> hmm, i'll have to look into both more closely then (gmane and gmail). thanks!
16:14:11 <pqmodn> oh, gmane is probably exactly what i wanted. i guess i thought it was just for reading with a web browser, and somehow missed the main point of it -- NNTP gateway
16:19:41 <danilo2> hi! I know it is a strange question, but I'm generating Haskell libraries (their code) and I want them to deliver instances of some common typeclasses (also generated). Right now each such typeclass I'm generating as a separate cabal library (to allow these libraries to use it and be compatible), but registering lets say 20 such libraries is time expensive (each usch library consist of simple typeclass declaration)
16:20:12 <danilo2> Do you have any idea how can I make it faster? Maynbe some ghc or cabal API "hacks" would allow me to get the same effect, but faster?
16:21:15 <slack1256> danilo2: generating with CPP?
16:22:03 <dgpratt> what if I want to parse some JSON into a data type (record) but one field is missing and needs to come from somewhere else? is my best option to define a data type representing the non-missing fields (and then do the obvious)?
16:22:10 <danilo2> slack1256: I'm genrating haskell code with a tool written in haskell (if you're asking about it)
16:22:19 <dgpratt> this is Yesod-flavored JSON, if it matters
16:23:28 <enthropy> danilo2: if you're generating code, why does each class/instance have to have it's own library?
16:24:59 <pqmodn> dgpratt: perhaps the parser should return a function (missingFieldType -> ParsedType)
16:25:37 <pqmodn> or you could make the field a 'Maybe missingFieldType' and initialized it with Nothing, replacing it later
16:26:04 <danilo2> enthropy: Because I'm generating libraries, which should be compatible - I mean - I'm generating library A, which uses typeclasses "TA, TB, ... TF" and library B, whcih uses "TA, TB, ... TZ". each TX declares a function "fx" I want to be able to generate library C, which imports A and B and use "ta, tb, ... tf" - of course we do not know if there is other libraries with different selections of TX, so each TX should be in separate lib
16:26:34 <danilo2> enthropy: I've tried to tell it very short - if it is not understable, I'll describe it longer :)
16:27:16 <pqmodn> danilo2: i'm not sure i understand, but what does separate libraries accomplish that separate modules can't?
16:27:21 <dgpratt> thanks for the suggestions, pqmodn
16:27:32 <enthropy> dgpratt: it's also possible to just put (error "Module.something: to be filled in later") for the field
16:27:38 <enthropy> so long as it's not a strict one
16:28:16 <dgpratt> I have limited control over the original data type since this is being scaffolded by the Yesod persistent stuff
16:29:36 <danilo2> pqmodn: We can simply compile such library and give it to another user (for example - of course if he get the same GHC with the same ABI, but this deos not mather now). Lets say - I want to generate several libraries with different selections of tx (where x is a identifier) and use them in these libraries
16:30:42 <enthropy> danilo2: you could also have:    class Method (name :: Symbol) where type MethodTy name :: *; dispatch :: proxy name -> MethodTy name
16:31:13 <joelteon> :t fix id
16:31:14 <lambdabot> a
16:31:22 <enthropy> actually:    class Method (name :: Symbol) methodTy where dispatch :: proxy name -> methodTy
16:31:38 <enthropy> then instead of ta, you have    dispatch (Proxy :: Proxy "a")
16:31:49 <enthropy> (or some preprocessor stuff to get rid of that mess)
16:32:04 <enthropy> then there is no need to generate so many classes
16:32:32 <danilo2> enthropy: ok, that is interesting, but I thin (but I'm not sure now) It has some performance overhead compared to the solution with typeclasses?
16:32:44 <enthropy> this is also a tyep class
16:33:04 <enthropy> and in any case, it seems you already have a performance problem
16:33:32 <danilo2> enthropy: Yes, but you provide the name as a string. Maybe this strung is handled magically and is optimized, then it is ok. Is it?
16:35:06 <enthropy> it's a string at compile time
16:37:46 <danilo2> enthropy: I've got a performance problem only while generating libraries, but after compilation the code is fast (registering the libraries is slow). I know the string is a "compile time string", but can we say, that this solution is as performant as solution with many typeclasses?
16:41:05 <danilo2> entrhropy: And thank you for this solution - I'll make some benchmarks :)
16:41:22 <enthropy> yeah, you probably need some benchmarks to say it's as good
16:41:41 * enthropy isn't seeing any reason one approach should be slower than another
16:44:02 <danilo2> enthropy: thank you once again! :) If it is as fast as mine its perfect! :)
16:44:44 <enthropy> type inference isn't going to be very good in your case I think
16:45:17 <enthropy>    dispatch (Proxy :: Proxy "+") a b -- isn't going to force the type of `a' to be the same as the type of `b'
16:47:17 <danilo2> enthropy: Oh, thats bad :( So it does not solve this issue. Type inference is very important to me while generating this code :(
16:50:09 <enthropy> danilo2: how is it supposed to work then?
16:52:14 <enthropy> one package might supply a + that's  Int-> Int -> Int
16:52:22 <enthropy> another the same... which one do you pick?
16:53:20 <danilo2> enthropy: each such TX typeclass is defined as class TX a b | a -> b where fx a -> b. I'm using osme templatehaskell to generate some code snippets and the funcitonal depedencies are very important and work great in my case (I'm generating mostly untyped code. Maybe I misunderstood the part with typoe inference, but the inference based on functional dependencies is very improtant to me.
16:55:02 <enthropy> ok so you will never see two functions with the same name that have the same first argument?
16:55:49 <danilo2> enthropy: Yes - that is sure
16:55:58 <enthropy> then you have something like    class Method (name :: Symbol) a b | name a -> b where dispatch :: proxy name -> a -> b
16:56:29 <Vamp> Someone knows how I should define straight here? http://lpaste.net/1636130352181280768. I probably have to use my helper functions isStraight and ranks, but don't know how  I end up with a Maybe HandCategory
16:56:42 <Vamp> Here are the helper functions btw: http://lpaste.net/3381750402968977408
16:56:51 <danilo2> enthropy: ok, I was thinking to do that, but I misunderstood your ocmment on type inference :) I'm going to check it right now :) thank you! :)
16:56:57 <enthropy> danilo2: or you can do the same thing with (~) http://okmij.org/ftp/Haskell/typecast.html#local-fd
16:57:32 <enthropy> probably it's easier to generate a fundep than such a constraint
16:59:03 <danilo2> enthropy: great :) I'll read this article right now :)
17:02:05 <enthropy> my conclusion for you is that it's not necessary
17:05:50 <danilo2> enthropy: Ok, but I would love to know this new think. I love Hasell and learning the new solutions is a pleasure. Could you please give me a small hint how can this "TypeCast" help with my problem? I do not see yet this solution.
17:05:58 <danilo2> *thing
17:06:21 <enthropy> TypeCast a b  is replaced by (a ~ b)
17:06:55 <enthropy> since then you don't need to use that   typeCast at the value level
17:06:57 <flebron> Say I have a function which may throw an exception (say with error). Is there a pure way to handle this?
17:08:17 <enthropy> flebron: not really, using catch brings you into IO
17:08:41 <enthropy> @hackage spoon
17:08:41 <lambdabot> http://hackage.haskell.org/package/spoon
17:08:55 <enthropy> that unsafePerformIO's the catch, which is a bit controversial
17:10:39 <flebron> The background is we're checking students' code, and some of the answers to questions may throw exceptions (usually undefined being evaluated) sometimes, so it'd be great to do something in that case, but keep evaluating the rest of the questions.
17:10:52 <danilo2> enthropy: hmm, ok. Sorry for such maybe simple question, but how (~) can help me get the same effect as " class Method (name :: Symbol) a b | name a -> b where dispatch :: proxy name -> a -> b" ?
17:11:12 <enthropy> you can get rid of the  | name a -> b
17:11:41 <enthropy> by instead having all your instances like      instance  (Y~ y) => Method "foo" X y
17:12:53 <enthropy> which is probably the same as a two-parameter  class Method (n :: Symbol) a where dispatch :: proxy n -> a;  instance (Y ~ y) => Method "foo" (X -> y)
17:12:55 <danilo2> enthropy: Ah I see - it simply matces the "more general" instance and after match specifies more narrow types?
17:13:07 <enthropy> yes that's the idea
17:13:12 <monochrom> flebron: use IO, it enjoys everything in Control.Exception. an extra benefit: now you can also use Control.Concurrent.Async so you can kill a student job that doesn't finish in 3 seconds
17:13:49 <flebron> Yeah that was another question I had :)
17:16:11 <danilo2> enthropy: thank you very much! :)
17:16:48 <monochrom> use Control.Exception's evaluate to turn a pure job into an IO job
17:17:08 <enthropy> actually I think it is useful to replace fundeps with (~), since ghc-7.8 is getting a bit stricter around them
17:17:57 <danilo2> enthropy: In all cases?
17:18:16 <danilo2> enthropy: I mean - it owuld be better to just stop using fundeps and use (~) instead?
17:18:54 * enthropy isn't sure
17:19:34 <danilo2> :)
17:20:07 <enthropy>  if you have    class F a b where f :: a -> b;  you need some type signatures to write     \x -> f (f x)
17:20:25 <enthropy> but that code is perfectly fine if you have an  | a -> b
17:24:52 <danilo2> enthropy: That's clear :) btw what is "proxy" in the code you've provided? I cannot find any information about it - it indeed compiles fine, but ":i proxy" in ghci gives me error: not in scope "proxy" :/
17:25:06 * hackagebot data-interval 0.4.0 - Interval arithmetic for both open and closed intervals  http://hackage.haskell.org/package/data-interval-0.4.0 (MasahiroSakai)
17:28:10 <enthropy> @hackage tagged
17:28:10 <lambdabot> http://hackage.haskell.org/package/tagged
17:28:59 <danilo2> enthropy: ah, nvm! heh I'm tired now :)
17:31:16 <danilo2> enthropy: heh sorry for the ocnfusion - If you would be so nice and tell me what is the "proxy" in your example, I would be very thanful :)
17:31:40 <enthropy> it is a type variable that could become Proxy from that tagged package
17:31:59 <enthropy> you can define data Proxy a = Proxy -- that could work just as well
17:34:30 <Connorcpu> Hey, I've got a little problem with types. I've defined that one of my types has to implement FromJSON, but the compiler is still complaining when I try to decode it :/ http://lpaste.net/94176
17:36:02 <danilo2> enthropy: so proxy is not something magicall? It is normal type vriable ?
17:36:27 <enthropy> maybe it's a bit magical in that it has kind  Symbol -> *
17:36:29 <monoidal> Connorcpu: does it compile if you add {-# LANGUAGE ScopedTypeVariables #-} to the top of the file?
17:36:57 <carter> ScopedTypeVariables is one of my favorit extensions
17:37:36 <Connorcpu> I'll try that thanks
17:37:37 <geekosaur> I think there'd need to be a forall in there too?
17:37:49 <geekosaur> in any case, your :: Maybe b there does not do what you hope
17:37:54 <monoidal> Connorcpu: also geekosaur is right. you need a forall
17:37:59 <monoidal> Connorcpu: try removing :: Maybe b first
17:38:49 <monoidal> Connorcpu: the problem is that GHC thinks "b" in Maybe b is a type variable that does not have anything to do with the variable in (FromJSON b, ToJSON a) => a -> ...
17:39:19 <danilo2> enthropy: Ok, now I get it function. Can I find any informatin aobut it? I thought it would be described somwhere here: http://hackage.haskell.org/package/base-4.6.0.1/docs/GHC-TypeLits.html, but it isnt - while searching for "proxy" in hoogle or google gives no results connected with THE proxy
17:39:23 <Connorcpu> Ah, cool. Removing Maybe b fixed the error :)
17:39:29 <edwardk> enthropy: no magic
17:40:38 <enthropy> danilo2: yeah any other type variable works
17:41:04 <Connorcpu> And everything works now, thank you very much monoidal ^.^
17:41:58 <Connorcpu> and geekosaur too
17:43:30 <flebron> monochrom: How do I wait for the function evaluation to finish for 3 seconds with Control.Concurrent.Async?
17:43:41 <sie> How does IO monad work?
17:44:07 <lpaste> jcande pasted “strange error” at http://lpaste.net/94178
17:44:17 <jcande> hey guys, I'm getting this weird error. I don't understand it
17:44:31 <jcande> I have a file with ONLY: what = length "string"
17:44:32 <monoidal> jcande: you have -XOverloadedStrings on.
17:44:38 <jcande> oh
17:44:40 <monoidal> jcande: probably in ghci.conf
17:44:44 <jcande> let me check
17:44:53 <monoidal> jcande: length ("string" :: String) should work
17:45:04 <jcande> monoidal: this is my ghci.conf
17:45:05 <jcande>   1 :set prompt "λ> "
17:45:05 <jcande>   2 :set +t
17:45:05 <jcande>   3 :set +s
17:45:22 <jcande> could it be switched on somewhere else?
17:45:35 <danilo2> enthropy, edwardk: Ok, but why we cannot simply use " dispatch :: name -> a -> b" and we HAVE TO pack the name in a proxy? Additional, I have to do something wrong, because I'm getting an compilation error here : http://lpaste.net/94177 , dont I ?
17:45:57 <monoidal> jcande: do you get the same behavior with ghci -ignore-dot-ghci?
17:46:20 <jcande> monoidal: I don't. Weird
17:46:24 <monoidal> jcande: (you shouldn't, and if so, check the items at http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/ghci-dot-files.html)
17:46:37 <jcande> monoidal: looking into it now. Thanks
17:46:43 <edwardk> turn on PolyKinds
17:47:08 <danilo2> edwardk: Ok it works, than you!
17:47:11 <edwardk> the name has kind Symbol, it is a type, not a term. it isn't a value-level string, it is a type.
17:47:39 <jcande> monoidal: there's a .ghci in the local directory. It has it. No idea how that got created but thanks for the help in finding it
17:47:44 <monochrom> flebron: waitAnyCatchCancel or waitEitherCatchCancel, one job is student's job, another job threadDelays for 3 seconds
17:47:46 <monoidal> sie: this is a very generic question... in short, IO is a type that stores descriptions (recipes) of IO actions to do
17:48:21 <monoidal> sie: it's a monad, which means that you can glue actions e.g. first read a line from console and then write that back
17:51:33 <monoidal> jcande: I have faint memories that yesod might create such files
17:52:00 <jcande> monoidal: you are a magician. I was playing with yesod and snap yesterday
17:57:47 <flebron> monochrom: I think I may be doing something wrong? Why doesn't this wait for 1 sec? let delayer = async $ threadDelay 1000 in delayer >>= wait
18:00:23 <flebron> ... microseconds, not milliseconds. Disregard the above -_-
18:00:56 <geekosaur> everyone gets caught by that
18:01:12 <geekosaur> (somewhat infamously, it was the cause of a longstanding annoyance in lambdabot)
18:05:01 <sclv> that threadDelay is the worst
18:05:08 <sclv> you can't even set a big delay because of maxbound int
18:06:00 <copumpkin> :O
18:07:19 <carter> whats the longest delay you could do, in minutes, on a 64 bit machine?
18:07:30 <carter> or are we talking 32bit?
18:07:56 <copumpkin> just run it in a loop
18:07:58 <Saizan> > (maxBound :: Int) / (10^6)
18:07:59 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
18:07:59 <lambdabot>    arising from a use o...
18:08:08 <monoidal> > maxBound :: Int
18:08:09 <lambdabot>   2147483647
18:08:13 <Saizan> ow
18:08:24 <monoidal> > 2**32 / 10**6
18:08:24 <lambdabot>   4294.967296
18:08:42 <johnw> not even two hours
18:08:50 <Saizan> > 2**64 / 10**6
18:08:51 <lambdabot>   1.844674407370955e13
18:08:55 <johnw> Haskell programs: impatient by design
18:09:00 <carter> hehe
18:09:10 <carter> except when 64 bit
18:09:17 <carter> how many years would that be
18:09:36 <johnw> > 2**64 / (10**6 * 3600 * 24 * 365)
18:09:38 <lambdabot>   584942.417355072
18:09:52 <carter> the 584,000 year language
18:10:00 <johnw> Y584K
18:10:03 <hpc> 584,000 years is enough for anybody
18:10:19 <carter> i look forward to our impatient singularity overloards who
18:10:26 <sclv> yeah running it in a loop is fine
18:10:27 <carter> needs to wait more than half a million years for a thread
18:10:33 <sclv> but the useful function should do that already
18:10:39 <sclv> its nuts to have to write it each time
18:11:10 <carter> to write which?
18:11:21 <sclv> a loop with setTimeout
18:11:29 <carter> whats a good use case?
18:11:33 <sclv> or threadDelay rather
18:11:55 <hpc> carter: it's more representative of how people think of seconds
18:12:03 <hpc> really, it should be a Double
18:12:05 <sclv>  good use case is a longrunning server process
18:12:21 <sclv> and you want to have a poor man's scheduler
18:12:28 <sclv> to run some job every four hours or whatever
18:12:35 <sclv> and instead of doing a whole task queue with polling
18:12:39 <Cylta> does the haskell has it own garbage collector/memory freeing system?
18:12:45 <carter> Cylta: yes
18:12:47 <sclv> you just have a thread that does its thing and delays for four hours and then does its thing again
18:12:49 <carter> its got a great one
18:12:49 <hpc> Cylta: haskell doesn't specify
18:12:54 <hpc> Cylta: but ghc has a very good one
18:13:27 <Cylta> carter: and it's fully automate, and I will not have memory leaks because of creating and removing complicated arrays? =)
18:13:59 <redgreenbluberry> Memory leaks do happen.
18:14:00 <geekosaur> yes, modulo that laziness can lead to surprises if you are incautious
18:14:07 <Cylta> hpc: okay, sorry for terminology. then my question was about ghc
18:14:18 <Cylta> redgreenbluberry: in what cases usually?
18:14:36 <redgreenbluberry> As geekosaur says: when laziness causes a thunk to hold on to an expression longer than you were expecting.
18:14:37 <hpc> Cylta: in the case of programmer mistakes, same as any other language
18:14:57 <carter> Cylta: that said, you can (with care) write really really really fast array computations in haskell
18:15:10 <redgreenbluberry> Memory leaks are both fairly rare and devilishly difficult to debug.
18:15:17 <lpaste> flebron pasted “Why does this run for more than one second?” at http://lpaste.net/94179
18:15:24 <redgreenbluberry> So my advice is not to think about them until you absolutely must.
18:15:33 <Cylta> redgreenbluberry: is there a way to finish all lazy calculations at some point of a program?
18:15:43 <Cylta> redgreenbluberry: to avoid such memory leaks
18:15:47 <redgreenbluberry> hrm
18:15:51 <lpaste> Polarina pasted “threadDelayInteger” at http://lpaste.net/94180
18:15:52 <redgreenbluberry> Tricky question.
18:16:03 <redgreenbluberry> There are some operations that give you some control of laziness.
18:16:10 <Cylta> redgreenbluberry: okay. then sorry =) if it's rare, i hope I will not meet this problem.
18:16:35 <redgreenbluberry> If you're into that kind of thing, there are probably enough GHC internals exposed in various places to write what you're asking for.
18:16:40 <redgreenbluberry> But it seems like a bad idea to me.
18:16:55 <hpc> Cylta: perhaps a bit of context will help
18:17:06 <johnw> chrisdone has threadDelayInteger in one of his recent util librs
18:17:19 <redgreenbluberry> ?hackage unbounded-delays
18:17:19 <lambdabot> http://hackage.haskell.org/package/unbounded-delays
18:17:21 <carter> johnw: in delays or something?
18:17:23 <carter> hah
18:17:26 <Polarina> johnw, that doesn't surprise me at all. :)
18:17:29 <hpc> Cylta: so, ghc has a concept called a "thunk", which is simplistically thought of as a function pointer that can modify itself
18:17:30 <johnw> yeah
18:17:33 <redgreenbluberry> copyright 2011 -- not exactly new
18:17:33 <Cylta> hpc: I'm from C language, and just tired because of memory leaks because of complicated objects creation\destruction.
18:17:42 <redgreenbluberry> chrisdone should depend on that instead of making his own =)
18:17:55 <hpc> Cylta: evaluating a thunk consists of running the function
18:18:09 <redgreenbluberry> Cylta: Congratulations, then, you get to have memory leaks for brand new reasons in Haskell. =)
18:18:09 <hpc> it computes a final value, and then replaces itself with a function that just returns that value
18:18:19 <redgreenbluberry> Complicated memory accesses are rarely the cause of leaks here.
18:18:34 <redgreenbluberry> Complicated creation/deletion of objects, I mean.
18:18:58 <Cylta> redgreenbluberry: I just want language without memory leaks =)
18:19:11 <redgreenbluberry> TANSTAAFL
18:19:22 <redgreenbluberry> Unless you're willing to give up Turing completeness, in which case you might like guru.
18:20:06 <hpc> Cylta: i hate to break it to you, but programming is hard ;)
18:20:09 <redgreenbluberry> or, like... regex
18:20:22 <redgreenbluberry> can't think of the last time I had to debug a space leak in a regex =P
18:20:40 <Cylta> programming in regex? seriously? =)
18:20:46 <hpc> redgreenbluberry: it happens with extended regex stuff
18:21:06 <redgreenbluberry> pfft, "extended" screams "not regular" to me ;-)
18:21:08 <hpc> (?:) and friends can give you a full CFG parsing language
18:21:14 <hpc> yeah :P
18:21:16 <Polarina> redgreenbluberry, recursive regexes are their own headache.
18:21:35 <redgreenbluberry> Polarina: Can't say I've ever heard of them.
18:21:54 <redgreenbluberry> Cylta: Hey, you're the one making ridiculous demands around here. ASCII stupid question, get a stupid ANSI. =D
18:22:13 <hpc> haha
18:23:01 <carter> unicode!
18:23:14 <carter> soo many books with code points
18:23:16 <redgreenbluberry> huzzah! unicode!
18:23:17 <Cylta> redgreenbluberry: why it's so complicated? I just want to ensure that all that structure, that I'm using is freed as soon, as I deleted it, does not matter how big and complicated this structure is =)
18:23:35 <redgreenbluberry> Cylta: Have you heard of Rice's Theorem and/or the halting problem?
18:23:50 <redgreenbluberry> Cylta: In a nutshell: "every stupid question (about programs) is undecidable".
18:23:51 <Cylta> redgreenbluberry: already opening the wiki...
18:24:08 <hpc> Cylta: even with something as simple as say, closing a network connection handle
18:24:14 <redgreenbluberry> ...and "will I ever use this memory again" counts as a stupid question for these purposes. =)
18:24:16 <hpc> Cylta: what if you close a handle and then return it?
18:24:47 <hpc> or you can coerce a handle to something else like Int and then back again
18:25:21 <Cylta> redgreenbluberry: when I'm saying "delete this stuff" it mean that I will not need it :P at least in C it's a problem. (because object can't be freed all at once)
18:25:31 <hpc> or perhaps you wrote your program so it opens a connection for the entire program execution
18:25:45 <hpc> now there's a network problem and you establish another connection and re-run your main loop
18:25:50 <hpc> and now you have two connections!
18:25:59 <hpc> leaks are for the programmer, not the GC
18:27:01 <redgreenbluberry> Cylta: There is a design choice when making a language. Either you ask the programmer to announce when memory is done being accessed -- and then the programmer often gets it wrong, and this is a source of bugs -- or you try to guess -- and then sometimes the compiler gets it wrong, and you get a space leak.
18:27:04 <Cylta> hpc: but if I wrote something like "disconnect eth0; free eth0;" it should help. even if I did not wrote "free eth0:wire" "free eth0:port" and stuff =)
18:27:15 <lpaste> flebron revised “Why does this run for more than one second?”: “Why does this run for more than one second?” at http://lpaste.net/94179
18:27:25 <hpc> Cylta: sure, but if you never disconnect it?
18:27:31 <hpc> or you never let it go out of scope?
18:27:35 <Cylta> hpc: then it's my problem
18:27:36 <redgreenbluberry> s/compiler/runtime/
18:27:48 <Cylta> hpc: again, my problem. I can handle it.
18:27:54 <redgreenbluberry> Cylta: The name of your problem is "space leak".
18:27:59 <Polarina> Is it just me or do many of the haddoc documentations on Hackage generate links beginning with file:// ? For example in http://hackage.haskell.org/package/OpenGLRaw-1.4.0.0/docs/Graphics-Rendering-OpenGL-Raw-Types.html I can't click on any of the type links.
18:28:00 <redgreenbluberry> So what are you on about?
18:28:08 <redgreenbluberry> If you're fine with space leaks, then what are you afraid of?
18:28:11 <hpc> Cylta: so if we're distinguishing between programmer error and GC error, the GC doesn't incorrectly leave things allocated
18:28:28 <redgreenbluberry> hpc: uh?
18:28:31 <Cylta> hpc: sounds good
18:28:33 <redgreenbluberry> hpc: The GC doesn't incorrectly deallocate things.
18:28:40 <hpc> also that
18:28:53 <redgreenbluberry> hpc: The GC *does* sometimes incorrectly leave things allocated (or what are you imagining "space leak" means?).
18:29:24 <hpc> redgreenbluberry: i am following Cylta's logic of "if the code is wrong, it's not the GC's fault"
18:30:01 <redgreenbluberry> To be honest, I don't really know what Cylta's logic is any more.
18:30:18 <f-a> hello, I am trying to change 1 field in a datatype with many fields. I know the trick is possible with accessors, but i wondered, can you do it without them too?
18:30:19 <redgreenbluberry> Polarina: odd
18:30:38 <hpc> f-a: by accessors, you mean record update syntax?
18:31:02 <hpc> as in (thing {field = newValue})
18:31:12 <f-a> hpc: indeed, hpc.
18:31:17 <redgreenbluberry> Polarina: Demand your money back!
18:31:25 <hpc> f-a: you might like lenses
18:31:39 <Polarina> redgreenbluberry, yeah! All the zero dollars I paid into this.
18:31:48 <hpc> which "functionalize" records as well as some other magic
18:32:04 <redgreenbluberry> f-a: And also, of course you can do it without any special machinery. It's just drudgery.
18:32:10 * f-a feels like hpc just said "it's dangerous to go alone, take this" to him
18:32:18 <hpc> heh
18:32:32 <hpc> f-a: well, what i am offering is dangerous too
18:32:40 <Polarina> f-a, take a look at lenses: http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html
18:32:51 <Cylta> Polarina: i think it's editors mistake... there is "Maintainer" info and email.
18:32:59 <redgreenbluberry> "It's dangerous to go alone, travel together with danger instead."
18:33:05 <f-a> very well, very well, lenses will be
18:33:11 <flebron> Why pick the lesser danger?
18:33:14 <redgreenbluberry> Cylta, Polarina: Probably better to write to the Hackage2 folks than to the package maintainer.
18:33:24 <Polarina> Cylta, I've seen many packages with this error.
18:33:24 <hpc> it's dangerous to go alone, you need a stranger danger!
18:33:40 <hpc> https://www.youtube.com/watch?v=Psp9cj9LsQs -- lol
18:33:49 <redgreenbluberry> hpc++
18:45:14 * hackagebot udev 0.1.0.0 - libudev bindings  http://hackage.haskell.org/package/udev-0.1.0.0 (SamTruzjan)
18:46:38 <dgpratt> using Persistent, it seems like there should be some canonical way to retrieve just an entity id based on a unique constraint, but I don't see such a thing -- have I overlooked something?
18:47:41 <johnw> you mean, you have the unique data and you want to lookup the record?
18:48:15 <dgpratt> johnw, I have the unique data, but I want only to retrieve the id, not the whole record
18:48:27 <johnw> i'm not aware of such a function, actually
18:48:36 <johnw> with esqueleto that would be easy, though
19:00:21 <mgsloan> dgpratt: I don't think you've overlooked something.  However, you can use selectKeysList with the appropriate filters
19:01:06 <johnw> mgsloan: hello!
19:01:08 <mgsloan> Which would be equivalent to using esqueleto, because afaik it doesn't specifically support lookups based on uniqueness constraints
19:01:13 <mgsloan> johnw: Hi!
19:02:43 <dgpratt> mgsloan, very well, thanks
19:03:11 <mgsloan> dgpratt: welcome!
19:03:14 <dgpratt> I wonder how hard it would be to try to extract fields/values from a Unique
19:03:53 <dgpratt> or even if that's possible
19:04:08 <mgsloan> I think there's probably something like that happening internally
19:04:17 * mgsloan looks
19:05:46 <dgpratt> looks like there's some promising methods -- I could probably wrap this up nicely
19:06:24 <carter> hehe
19:06:33 <carter> i only learned yesterday that ghc still supports -fvia-c
19:06:38 <carter> so i'm testing it on my mac :)
19:06:59 <carter> Gracenotes: you should revisit your nacl experiment with -fvia-c
19:08:14 <geekosaur> hm, it was actually removed for a while (well, option present but using it gave an error), did they put it back? (possibly because unregisterised is broken?)
19:08:39 <carter> geekosaur: its apparently how we support archs like ppc64 and alpha
19:08:41 <f-a> mhh, I wonder why show (string here) adds a pair of ""
19:08:58 <carter> f-a: because show is supposed to give you somethign you can paste back in a .hs file
19:09:18 <carter> f-a: just like why  many collection libs print "from list blha"
19:10:02 <f-a> can't you paste "myString" in a .hs file?
19:10:18 <f-a> I mean, do you need "\"myString\""?
19:10:19 <geekosaur> huh, I didnt know anyone cared about alpha any more
19:10:54 <geekosaur> f-a, more precisely, show puts values in "source form". `myString` in a source file is an identifier. `"myString"` is a string literal
19:11:23 <geekosaur> you then get an additional set because you're probably using ghci which is *also* applying show
19:11:32 <f-a> I see
19:11:40 <geekosaur> so use putStrLn in ghci
19:12:27 <geekosaur> (alternately you used print instead of putStrLn; print = putStrLn . show)
19:12:43 <thebnq> is there a way to get the fixity in ghci
19:12:52 <f-a> it was unrelated to ghci really, I was thinking about a putValInMap (Show s) => k -> s -> SomeMapHere
19:12:54 <geekosaur> :info shows that along with other information
19:13:34 <thebnq> oh nice thanks :O
19:13:37 <redgreenbluberry> f-a: "\"myString\"" is what you would have to write in your source if you wanted a String that contained valid Haskell code of type String
19:13:49 <redgreenbluberry> (phew, that's a mouthful)
19:14:01 <f-a> mouthful but clear ^^d
19:16:01 <mgsloan> dgpratt: unfortunately, I'm not seeing a good way to get EntityField values from a Unique.  I think Template Haskell would be needed to automate writing such a function (or have persistent's TH generate it)
19:20:18 <mgsloan> The TH magic would use 'persistUniqueToFIeldNames' to get the haskell names for the fields, and generate a function that uses 'persistUniqueToValues' to get the values that go with the names in the filter
19:37:38 <atg_> Hey guys
19:38:25 <atg_> I'm trying to get started in Haskell
19:38:26 <acowley> Hello!
19:38:30 <acowley> Good move.
19:38:33 <atg_> having trouble getting my head around Monads
19:38:37 <johnw> atg_: welcome!
19:38:39 <copumpkin> don't try to :)
19:38:42 <johnw> atg_: I would let Monads rest for a while
19:39:23 <acowley> Once you get your head around monads, you'll just notice a monad around your head, so you'll have to get your head around that!
19:39:47 <acowley> As everyone is saying, you don't need to worry about monads in their generality for a while
19:40:23 <atg_> If I do :type getLine, I see getLine :: IO String
19:40:34 <atg_> does that mean that getLine returns a tuple of IO and String?
19:40:41 <mauke> no
19:40:44 <heatsink> At the beginning, you just need to be able to write simple commands in main
19:40:53 <sie> Am I doing monads right: http://sprunge.us/VhEH
19:40:57 <heatsink> getLine is an IO action that produces a String
19:40:58 <mauke> atg_: do you know Maybe?
19:41:09 <atg_> yes
19:41:19 <mauke> IO is like Maybe
19:41:48 <acowley> WIth the distinction that you can't pattern match on the IO constructor
19:42:25 * heatsink can never tell if these analogies are useful for new haskellers
19:43:10 <atg_> Maybe just looks like a C# ?? operator to me
19:43:13 <monoidal> sie: if it compiles, it is usually OK. however, withFile means open/handle/close file, so you're opening it twice
19:43:16 <acowley> "like Maybe" isn't so much an analogy as a reference for the syntax "IO String" if I'm playing mauke
19:43:34 <sie> monoidal, That was the point yes — store retrieve, just to test it out.
19:43:39 <ion> atg: You can think of it as a black box that can be executed (by running it in ghci or having main = getLine) and that will result in a String upon execution.
19:43:50 <monoidal> sie: it's ok. try to give a type signature for useFile and main.
19:44:23 <ion> atg: Or, say, main = do { l <- getLine; putStrLn l }
19:44:28 <acowley> atg_: So you've got an IO String, and you want to get at the String. do syntax helps you with this
19:48:37 <atg_> Where can I find some good code to read and play around with?
19:49:14 <acowley> ?google lyah
19:49:15 <lambdabot> http://learnyouahaskell.com/
19:49:15 <lambdabot> Title: Learn You a Haskell for Great Good!
19:50:39 <dgpratt> mgsloan, yes, I think I see your point -- well, thanks for saving me the trouble :)
19:50:41 <atg_> The problem with those books is that they always start at the absolute beginning and bore you with 100 pages of the most simple function calls
19:50:49 <atg_> then they have a short chapter on monads
19:52:06 <geekosaur> gentle introduction, anyone? :p
19:52:26 <atg_> I don't want a gentle introduction
19:52:34 <atg_> I'm a software engineer
19:52:44 <atg_> with years of experience in C#
19:52:45 <heatsink> Maybe a better approach would be to try writing someting simple and practical
19:52:45 <acowley> atg_: Yeah, that's a fair complaint, but it's hard for others to find your level for you
19:52:47 <geekosaur> it's not actually gentle
19:52:56 <heatsink> and refer to the reference when you need something
19:53:30 <geekosaur> it's not quite being tossed into the shark tank, but it's also not the kiddie pool
19:53:41 <acowley> If LYAH is too basic for you, then you should be good to go with your own self-started code
19:53:48 <geekosaur> that said, you might be interested in
19:53:52 <geekosaur> @where rwh
19:53:52 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
19:53:55 <acowley> Can github list projects by language?
19:54:19 <geekosaur> which does have an intro chapter, but then takes you on a tour of actual haskell programs
19:54:20 <mangaba_leitosa> atg_: I found the Monads article of the Gentle introduction very useful. But to read it, you first need to understand well the articles on IO and type classes
19:54:43 <mangaba_leitosa> atg_: "chapter", not "article"
19:55:07 <atg_> mangaba_leitosa: kk
19:55:14 <fylwind> i found it most helpful to google a dozen different articles that try to explain Monads and find the one that you can grok best
19:55:15 <ion> atg: You’ll need to forget everything you learned about C#. :-P
19:55:18 <mangaba_leitosa> atg_: also, I think that the more you had experiencce in interactive programming, the harder will it be for yoou to master Haskell
19:55:38 <mangaba_leitosa> atg_: absolute novice programmers with no experience are at a great advantage
19:55:55 <mangaba_leitosa> atg_: "imperative" not interactive, sorry
19:56:17 <ion> mangaba_leitosa: Haskell is a great imperative programming language.
19:56:24 <fylwind> for a sec i thought you were telling me to uninstall ghci!
19:56:33 <mangaba_leitosa> ion: I know. But that's on a higher level of abtraction :-)
19:56:49 <heatsink> To see Github projects in Haskell: https://github.com/trending?l=haskell
19:56:54 <atg_> I started out with C and assembler, so I tend to want to know how everything maps to CPU instructions
19:57:10 <mangaba_leitosa> atg_: as for the Monads chapter of the Gentle Introduction, it is useful because it shows how to use monads for working with Lissts
19:57:28 <ion> atg: I’d suggest leaving that for later.
19:57:32 <mangaba_leitosa> atg_: many beginners think that monads are only about IO, so fail to see a larger picture
19:57:32 <geekosaur> atg_: haskell will drive you nuts at that level
19:57:33 <heatsink> atg_, operational semantics are usually more confusing than helpful in Haskell
19:57:37 <mangaba_leitosa> atg_: that was my problem, for example
19:57:50 <atg_> mangaba_leitosa: monads are about side-effect, correct?
19:57:55 <atg_> and state
19:57:58 <fylwind> no
19:58:00 <acowley> no
19:58:04 <heatsink> atg_, Haskell is based on domain theory and is easier to understand if you figure out what value each expression stands for.
19:58:12 <heatsink> instead of what each expression _does_
19:58:14 <mangaba_leitosa> atg_: some monada are. Such as IO. The list monad has not any side effects
19:58:22 <fylwind> monads are a mathematical abstraction that encompasses many completely different ideas
19:58:25 <atg_> interesting...
19:58:34 <ion> The list monad has an *effect*, though.
19:58:43 <ion> so to say
19:58:45 <acowley> blech
19:58:50 <geekosaur> but they're so abstract that you can't point at anything and say that it is the essence of monads
19:59:03 <heatsink> Well, you can point at the monad laws
19:59:05 <mangaba_leitosa> atg_: so, try out this chapter and learn how the List monad (without side effects) have some common features with the IO monad (with side effects)
19:59:08 <Makoryu> atg_: The first thing to understand about monads is that only *types* can be monads, not data structures
19:59:24 <mangaba_leitosa> ion: but not side :_)
19:59:43 <atg_> but the point of monads, if I understand, is to isolate code with side-effects from code with non?
19:59:47 <heatsink> For me, learning how to write parsers with Parsec was useful for understanding monads
19:59:53 <ion> mangaba_leitosa: One might say IO doesn’t have side effects either. The impure effects are the *effect* of IO.
19:59:55 <geekosaur> atg_: no, that's one use of them
20:00:01 <geekosaur> it's not what monads are about
20:00:06 <mangaba_leitosa> ion: :-)
20:00:10 <fylwind> heatsink: it's also good for understanding Applicatives :)
20:00:14 <monoidal> atg_: no. monads allow to compose things
20:00:19 <geekosaur> and in fact haskell had monads before anyone considered using them to implement IO
20:00:49 <ion> geekosaur: Huh. I didn’t know that.
20:00:51 <acowley> Yes, I think parsers are a great way to learn applicatives and monads
20:00:57 <geekosaur> my recollection at least
20:00:58 <mangaba_leitosa> atg_: its not their only points. It just happens that monads are useful for dealing with side effects, too (among other things)
20:01:22 <geekosaur> I may recall incorrectly
20:01:34 <monoidal> haskell surely could do IO before it had monads
20:01:36 <ion> atg: Anyway, you don’t really need to get the essence of monads to be able to use specific monads (such as IO) just fine.
20:01:56 <geekosaur> but Im under the impression state/reader/writer existed before the IO monad, back when main :: [Response] -> [Request] or whatever it was
20:02:46 <Makoryu> monoidal: It used to work like interact
20:02:55 <mangaba_leitosa> atg_: for lists, the list monad helps you build a cartesian product of too lists as a short one-liner. No side-effects, though
20:03:03 <Makoryu> Except with more possible actions than just "return part of a string"
20:03:09 <ion> monoidal: Yes. But i didn’t realize there was a notable period of time between monads arriving and them being used for IO.
20:03:49 <geekosaur> what I'm not sure of is whether that prehistory was in Haskell or in something else (Gofer, Miranda, whatever)
20:03:51 <fylwind> I heard that there were a bunch of category-theory related stuff but most of them got pulled out into a separate package
20:03:59 <Makoryu> :t interact
20:04:00 <lambdabot> (String -> String) -> IO ()
20:04:30 <ion> geekosaur: Note that i’m not saying “i thought that wasn’t the case”, i’m saying “i didn’t know that was the case”.
20:05:39 <geekosaur> yes, and I'm trying to clarify that I don't know it was the case, at least in Haskell. it was the case *somewhere* --- recognition that Monads could be used for IO actually came a bit later than Monads as a useful programming abstraction did --- but there are several possibilities as to when
20:06:02 <geekosaur> and I'm a bit weak on what stuff was discovered when/where
20:06:21 <geekosaur> LML, Gofer, Miranda, early Haskell variants, etc.
20:07:02 <geekosaur> (well, unlikely to be Gofer as no typeclasses IIRC)
20:07:10 <Athan> GUYS. I NEED YOU. I've got a question coming straight from the outer reaches of SPACE
20:07:16 <codygman> What indentation in haskell-mode do I need to use to achieve code like this: http://lpaste.net/94184
20:07:19 <Athan> just kidding.
20:07:36 <Athan> But still, I've got a question regarding typeclasses and infinite usability, like a list
20:07:45 <Athan> Here's my parallel:
20:07:52 <heatsink> codygman: select region and C-x align-regexp =
20:07:58 <acowley> codygman: I use a little elisp to do that kind of thing
20:08:01 <atg_> Would it be correct to see the IO monad as a C# stream?
20:08:05 <geekosaur> codygman, that can't be done automatically but there's a keybinding that will fix up lines, or you can do it the way heatsink saod
20:08:17 <acowley> my little elisp calls align-regexp btw
20:08:21 <Athan> Say you have a type being used as the instance of a typeclass
20:08:37 <Athan> and that type has a type parameter
20:08:47 <heatsink> Oh, actually it's M-x align-regexp =
20:09:00 * johnw wrote align-regexp, long ago :)
20:09:15 <Athan> if you place a constraint on the instance definition to have one of the parameters be an instance of that same typeclass
20:09:17 <heatsink> Did you write it for haskell?
20:09:19 <johnw> 20 years next year, actually
20:09:22 <acowley> (global-set-key (kbd "C-x a r") 'align-regexp)
20:09:28 <johnw> I've written definitions for Haskell
20:09:30 <Taslem> atg_: Not quite. You could view IO as a combination of a state and functions which pull off a stream, I think. I'm not terribly familiar with C#.
20:09:32 <Athan> can't you make an infinite nest of types, much like a list is for data?
20:09:34 <acowley> johnw is the hero we need
20:09:37 <ion> atg: I don’t know what C# streams are, but on a hunch, i would guess no.
20:09:40 <johnw> https://gist.github.com/6945280
20:09:49 <johnw> that helps with auto-aligned Haskell, using align-code
20:10:06 <leroux> I really wish I used emacs...
20:10:16 <acowley> leroux: There's a fix for that.....
20:10:16 <codygman> thanks johnw acowley and heatsink
20:10:21 <leroux> I've tried to switch twice.
20:10:24 <leroux> It's such a pain.
20:10:28 <codygman> leroux: What do you use?
20:10:29 <leroux> I even tried using evil.
20:10:31 <leroux> vim.
20:10:41 <johnw> leroux: keep trying till it sticks
20:10:41 <heatsink> I wish haskell-mode undesrtood template haskell.
20:10:52 <codygman> ah... yeah I used vim for 6 years.. have been using emacs for 2 months. It was only painful for a week
20:11:10 <leroux> Hmm. But I have all my nice plugins in vim. =(
20:11:13 <ClaudiusMaximus> Athan: sure, see the old way of doing type level arithmetic, something like data Z, data S a ; instance Nat Z ; instance Nat n => Nat (S n)
20:11:19 <leroux> I'll need to learn elisp too.
20:11:35 <codygman> leroux: do you know vimscript?
20:11:53 * geekosaur trying to fiind it but thought haskell-indent came with a C-c= binding or similar
20:11:53 <acowley> You don't need to learn elisp as a first step or anything
20:11:54 <leroux> No.
20:11:55 <ion> atg: The IO monad provides a function for putting together black boxes that represent (effectful) procedures into bigger black boxes.
20:11:55 <leroux> xD
20:11:59 <leroux> You have a point there.
20:12:04 <codygman> leroux: well you don't need to learn elisp ;)
20:12:08 <acowley> it's exciting not knowing elisp
20:12:24 <leroux> Why don't we have a haskell editor yet?
20:12:28 <heatsink> yi
20:12:29 <fylwind> knowing elisp does help if you're the type that likes customizing just about everything
20:12:29 <leroux> Wasn't there something called Yi?
20:12:31 <joelteon> like yi?
20:12:41 <Athan> ^^ why don't we have a _visual_ haskell editor, yet?
20:12:51 <geekosaur> yi, leksah, manatee but it's bitrotted
20:12:53 <ion> Why wasn’t Yi named Hi?
20:13:06 <Athan> ^^ typeclass functionality can be easily visualized with a key - keyhole system
20:13:17 <codygman> I heard about some project recently trying to do visual IDE.. from hackernews I think.
20:13:28 <acowley> FP Center?
20:13:38 <acowley> or whatever Microsofty name it officially goes by
20:13:48 <Athan> lol
20:13:53 <Athan> I've been trying to help them too much
20:13:58 <johnw> you mean, the FP Complete Haskell Center? ;)
20:14:00 <leroux> Athan: How so?
20:14:05 <Athan> I'm really well educated on front-end development
20:14:09 <leroux> lol johnw.... Do you work on it?
20:14:10 <acowley> johnw: Yes, and can't you do something about that name :(
20:14:13 <johnw> yes, I do
20:14:16 <geekosaur> ah, C-c . is what I was remembering
20:14:16 <leroux> Nice. =)
20:14:21 <geekosaur> I should have just fired up emacs, but.
20:14:23 <Athan> and I've been working on a whole new design for the www in general
20:14:27 <leroux> I can't use it anymore apparently. (have to pay)
20:14:47 <Athan> i think that there is so much potential for harmony
20:14:49 <leroux> I think I got into the beta a few days after it opened up.
20:14:58 <leroux> Never got the time to test it out.
20:15:25 <Athan> Yet yesod is only focused on the back-end
20:15:46 <enthropy> johnw: can you pass multiple --cppopts to c2hsc?
20:15:59 <codygman> acowley: Don't you need to highlight everything first? Would (global-set-key (kbd "C-x a r") ('highlight-all 'align-regexp)) be correct elisp? Not sure what hilight all function is, but hope you see what I'm asking.
20:16:16 * enthropy is finding that c2hsc --cppopts="-Denum_SEXPTYPE=1" --cppopts="-B/usr/share/R" # doesn't make the define work
20:16:27 <johnw> enthropy: I'm not sure, that should be an easy fix though
20:16:35 <geekosaur> codygman, did you look at "C-c ." ?
20:16:37 <enthropy> and that switching the order for the flags means the -B option isn't respected
20:16:58 <acowley> codygman: Yes, probably, but I highlight things so fast in emacs I'm not usually aware of doing it
20:17:11 <acowley> What is C-c .?
20:17:33 <geekosaur> (local-set-key [?\C-c ?\C-.] 'haskell-indent-align-guards-and-rhs)
20:17:43 <geekosaur> oh, C-c C-., whooops
20:17:44 <acowley> codygman: The benefit of this is that you can line up equal signs, double colons (e.g. for records) or anything else
20:17:59 <geekosaur> realigns guards and =s in a definition
20:18:03 <acowley> oh neat
20:18:20 <acowley> that's great!
20:19:10 <acowley> And on that triumphal note, I bid you all adieu
20:20:11 <johnw> night!
20:20:17 <carter> enjoy
20:20:23 <enthropy> johnw: you're right it's a very easy fix
20:20:30 <johnw> pull requests eagerly awaited
20:21:28 * JuanDaugherty wonders how many people would use Haskell Center
20:21:55 <enthropy> johnw: done
20:22:16 <johnw> JuanDaugherty: the number grows daily
20:22:21 <JoeyA> Haskell Center?
20:22:31 <johnw> JoeyA: http://fpcomplete.com
20:22:41 <JoeyA> Ah
20:22:58 <JuanDaugherty> johnw I meant more specifically what fraction of the haskell base, or this channel for instance
20:23:13 <stelleg> @hoogle Bool -> a -> a -> a
20:23:13 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
20:23:14 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vertex3 :: a -> a -> a -> Vertex3 a
20:23:14 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vector3 :: a -> a -> a -> Vector3 a
20:23:16 <JuanDaugherty> once they understood what it was
20:23:31 <johnw> @hoogle a -> a -> Bool -> a
20:23:32 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
20:23:32 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vertex3 :: a -> a -> a -> Vertex3 a
20:23:32 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vector3 :: a -> a -> a -> Vector3 a
20:23:42 <johnw> anyway, that function is in 'cond', plus a few other places
20:23:45 <stelleg> no if function :(
20:23:50 <Athan> Hey folks, why doesn't cabal provide upgrading services like apt-get and emerge?
20:24:08 <Athan> Is there a philosophical reason why the decision was made to leave it out?
20:24:32 <JuanDaugherty> it's not pkg mgr
20:24:35 <JuanDaugherty> *a
20:25:01 <stelleg> which is to say there isn't a group of people managing dependencies etc.
20:25:09 <JuanDaugherty> or at least it defers/shirks that job title and/or has a diff approach
20:25:10 <Athan> is it just a library/code installer then?
20:25:35 <JuanDaugherty> you're supposed to just install or maybe buy Haskell Center
20:26:04 <JuanDaugherty> anyway install is install and upgrade
20:26:16 <JuanDaugherty> to the extent it works
20:26:41 <Hafydd> JuanDaugherty, how is work at FP Complete?
20:26:51 <Athan> I just think that people generally would like to have the most recent editions of people's code that they "subscribe to" via cobal
20:27:13 <johnw> Hafydd: did you mean to ask me that?
20:27:15 <JuanDaugherty> Hafydd, I have no idea, I know nothing about it except it's a for profit concern
20:27:37 <Hafydd> johnw: no; but do you work there?
20:27:41 <johnw> yes
20:27:55 <Athan> so the real question is - are you subscribing to code via cabal install, or are you merely copying a picture of their progress + contributing to it?
20:28:08 <Hafydd> johnw: and how is work there?
20:28:16 <johnw> Hafydd: hehe, it's delightful
20:28:22 <JuanDaugherty> Athan, unclear what you're asking
20:28:35 <Hafydd> I bet. Lots of money from people installing and maybe buying Haskell Center.
20:28:39 <johnw> best job I've ever had, in fact, and I've had quite a few
20:29:01 <JuanDaugherty> are you a partner, have equity?
20:29:16 <atg_> wow, this page is so much more easy to understand regarding monads: http://www.haskell.org/haskellwiki/IO_inside
20:29:19 <Hafydd> Still, I suppose being a Haskell job can forgive many things.
20:29:50 <johnw> JuanDaugherty: I'm just an employee, as it were
20:30:09 <Tekmo> atg_: Have you read this one yet? http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
20:30:33 <atg_> Tekmo: I'll check that out after
20:30:34 <atg_> thanks
20:30:35 <JuanDaugherty> ah, sorry if that was an offensive question I know some people are more sensitive about stuff like that than they are about sex or whatever
20:30:42 <Tekmo> You're welcome
20:30:47 <gienah> atg_: I second that one
20:30:47 <johnw> Tekmo: hello!
20:30:51 <Tekmo> johnw: Hi!
20:30:58 <johnw> Tekmo: got a moment to chat?
20:31:00 <Tekmo> johnw: I want you to know that I haven't forgotten about the exceptions debate
20:31:02 <JuanDaugherty> the social relation that dare not speak it's name and what not
20:31:03 <Tekmo> Yeah, of course
20:31:07 <Athan> Burrrrrrrrn
20:31:19 <JuanDaugherty> *its'
20:31:28 <Athan> >>
20:31:36 <Athan> *plurp*
20:31:59 <Tekmo> johnw: Let me switch to my laptop
20:32:06 <johnw> I heard you just fine, fwiw
20:40:25 <atg_> What sort of software maps well to Haskell?
20:40:40 <atg_> I mean obviously, implementing stuff like mathematica etc
20:41:22 <atg_> But I've been meaning to try to do a web app with Haskell
20:41:47 <atg_> what framework would I use for that?
20:42:02 <shelf> yesod?
20:42:06 <carter> snap or happstack or yesod
20:42:22 <atg_> which one is the most popular?
20:42:34 <atg_> i.e., bigger community
20:45:42 <carter> they all have nice communities
20:45:49 <carter> and they all have different tradeoffs
21:30:09 <goldenwest> I need to convert [IO Char] -> IO [Char] and I'm dumb... please teach me things
21:30:38 <joelteon> :t sequence
21:30:38 <lambdabot> Monad m => [m a] -> m [a]
21:30:43 <goldenwest> shanks
21:30:53 <Ralith> @src sequence
21:30:54 <lambdabot> sequence []     = return []
21:30:54 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
21:30:54 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
21:31:30 <goldenwest> very nice... I appreciate it
21:32:44 <goldenwest> so that's what liftM2 does
21:33:27 <Ralith> :t liftM2
21:33:28 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
21:34:31 <goldenwest> yeah it was just hard for me to internalize until I saw it in that context
21:34:51 <goldenwest> thanks!
21:49:19 <Ghoul_> is there some kind of ordered map with fast insertion?
21:49:34 <Ghoul_> and fast intersection with another map.
21:49:55 <c_wraith> Uh.  Data.Map?
21:50:25 <Ghoul_> well, I need to know whether I put something in after or before another element
21:51:08 <Ghoul_> mhm, maybe Data.Map is OK and I should just use a tuple or something
21:52:26 <bh> When I'm doing pattern matching, is it possible to treat data members literally rather than as bindings? like so -- https://gist.github.com/anonymous/6945919
21:53:38 <Ghoul_> bh:
21:53:53 <Ghoul_> > let f x@(Maybe n) = x in f (Just 3)
21:53:54 <lambdabot>   Not in scope: data constructor `Maybe'
21:54:02 <Ghoul_> > let f x@(Just n) = x in f (Just 3)
21:54:04 <lambdabot>   Just 3
21:54:19 <Ghoul_> the relevant part is what's before @
21:56:48 <bh> Ghoul_: I'm afraid I don't see it. I want to use literal values in a function declaration
21:57:08 <shachaf> bh: I'm not entirely sure what you're asking. That file is valid code. What's wrong with it?
21:57:37 <Ghoul_> unless I understood, that should compile just fine
21:57:45 <Ghoul_> I thought you were asking about scoping patterns
21:57:51 <Ghoul_> *misunderstood
21:57:55 <dainanaki> I have a function "f :: (Monad m) => (Conf -> Conf) -> m Result" where I'm wanting to use some infix operators to modify the Conf value. I'm encountering what seems like a funny fixity issue:
21:58:18 <dainanaki> This is valid: f $ \q -> q & refresh ?~ True & id' ?~ "something"
21:58:36 <dainanaki> This is not: f (& refresh ?~ True & id' ?~ "something")
21:58:41 <bh> shachaf: operator error it looks like. In the 'real' example I managed to roll some overlapping cases
21:59:02 <dainanaki> Does anyone have any ideas how I can avoid having to use a lambda in this case?
21:59:03 <shachaf> dainanaki: Sure. Why should it be?
21:59:21 <shachaf> > (+ 1 + 2) 5 -- also not valid
21:59:22 <lambdabot>   The operator `GHC.Num.+' [infixl 6] of a section
21:59:23 <lambdabot>      must have lower prece...
21:59:43 --- mode: ChanServ set +o mauke
21:59:44 --- mode: mauke set -b *!*@pool-173-75-14-236.pitbpa.fios.verizon.net
21:59:51 <shachaf> Anyway, you can use (id' ?~ "something") . (refresh ?~ True)
21:59:58 <dainanaki> I guess what I am confused about is why it has to have lower precedence if it's supposed to be left-associative.
22:00:03 <shachaf> Or some other form of function composition. That's much better than &
22:00:14 <shachaf> This isn't an issue of precedence. Look at my + example. Only one precedence.
22:00:50 <Ghoul_> the error is kind of misleading I think. It says "blahblah of a section must have lower precedence"
22:00:58 <dainanaki> I just thought that was the point of specifying that an operator would be left or right associative.
22:01:21 <shachaf> The question is how this is interpreted: (x + 1) + 2 or x + (1 + 2) ?
22:01:31 <shachaf> You can see that in the former case, it's not a simple section.
22:01:43 --- mode: mauke set -o mauke
22:01:55 <shachaf> (+ 1 + 2 + 3 + 4) x should magically become (((x + 1) + 2) + 3) + 4
22:02:09 <shachaf> Sections are very simple, they don't work like that.
22:02:29 <dainanaki> Alright then. That was pretty much my question
22:02:40 <shachaf> In addition: I think (&)/($) is overused, and function composition should be encouraged instead.
22:02:56 <Hrumph> i really like function composition
22:03:28 <dainanaki> Me too, I am just a little sleep deprived and didn't think of it... :/
22:04:59 <dainanaki> Thanks for the help, I think this ought to do the trick nicely.
22:07:59 <Hrumph> http://lpaste.net/94186
22:08:19 <Hrumph> there an example of function compositino making something that looks messy (to *me* anyway) look clean
22:10:09 <Hrumph> shachaf: what about use of let in how often should that be used?
22:16:18 <heatsink> I prefer case.  It makes it clearer that the result is being deconstructed.
22:16:55 <Ghoul_> I'm guilty of doing things like this all the time
22:17:10 <Ghoul_> let (a, b, c) = (x + 1, a + 1, b + 1) in ..
22:19:33 <Hrumph> sorry messed up some brackets in the code i posted
22:19:51 <Hrumph> it was part of a code rewriting excercise i was doing i did't test it
22:20:13 <heatsink> case f x of Writer (y, v') -> Writer (y, v <> v')
22:20:37 <Hrumph> yes
22:23:06 <johnw> done
22:23:14 <johnw> (wrong window)
22:23:17 <shachaf> case f x of (v', y) -> (v <> v', y)
22:23:49 <johnw> (v <>) `first` f x
22:24:41 <shachaf> `first` ?
22:24:57 <johnw> just to mix things up :)
22:25:02 <shachaf> Do you really think that's more readable?
22:25:16 <johnw> first (v <>) (f x)
22:25:20 <johnw> maybe, maybe not
22:31:55 <startling> using case for irrefutable patterns seems odd. Why not "let"?
22:33:09 <shachaf> For one, you'll get a warning if it's not irrefutable.
22:33:36 <startling> That's fair.
22:51:41 <smith_> Right now I'm using a type signature of (State Int (Either MyError String)) on a group of functions, but this makes things complicated when I to do eg. maps on these functions. Is there a better alternative to represent this?
22:51:48 <smith_> (State is Control.Monad.State.State.)
22:52:27 <lispy> smith_: can you tell us a bit more about what you're trying to do?
22:52:42 <smith_> lispy: Yeah, I'll put together a paste. Sec.
22:52:42 <lispy> smith_: I don't think I understand yet why you have the type you have or what problem you want to solve
23:02:30 <smith_> lispy: Here's a condensed example of what I'm talking about -- http://lpaste.net/94187
23:03:32 <smith_> Using a combination of State and Either to represent current state and error conditions. It works fine until you try to do any iteration, and then the double-layering of monads makes things messier.
23:04:24 <smith_> So I'm wondering if there's a better type to represent the situation, or a better way to map over functions with this type.
23:04:38 <apples> have you checked out monad transformers?
23:05:09 <smith_> apples: I have not. Relatively new to the Haskell world.
23:08:01 <smith_> http://en.wikibooks.org/wiki/Haskell/Monad_transformers <- that looks perfect. Thanks, apples!
23:08:36 <apples> np, have fun :)
23:58:46 <eflister> i have a parsec ParserT like p = A <$> x <*> y.  two questions:  i want the x, but not y, parser to also be a Reader.  is there any way to do that (preferably keeping applicative style), or am i stuck in a single transformer stack?  second, x and y involve (whiteSpace $ makeTokenParser haskellDef) from Text.Parsec.Token, which seems to lock me in to a String stream and Identity base monad.
23:59:28 <eflister> why isn't haskellDef polymorphic, and how can i use it in my ParsecT s u (ReaderT r Identity) a?
