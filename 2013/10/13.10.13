00:02:01 <erisco> thanks for the help
00:12:37 * hackagebot yesod-fay 0.4.0.4 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.4.0.4 (MichaelSnoyman)
00:12:37 * hackagebot yesod-platform 1.1.9.2 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.1.9.2 (MichaelSnoyman)
00:41:01 <predator217> an
00:52:34 * hackagebot aws-sdk-text-converter 0.1.0.0 - The text converter for aws-sdk.  http://hackage.haskell.org/package/aws-sdk-text-converter-0.1.0.0 (YusukeNomura)
00:58:57 <RommelVR> what is the name of the symbol '->' and '<-' in Haskell?
00:59:03 <RommelVR> Notoriously hard to google for lol
00:59:22 <RommelVR> of the symbols*
00:59:35 <RommelVR> And '=>' even
01:02:16 <AshyIsMe> http://www.imada.sdu.dk/~rolf/Edu/DM22/F06/haskell-operatorer.pdf
01:02:20 <AshyIsMe> hmm, doenst seem to have the name there
01:02:28 <AshyIsMe> "function type-mapping operator"
01:02:29 <AshyIsMe> haha
01:02:34 <AshyIsMe> rolls right off the tongue
01:02:40 <RommelVR> haha
01:03:14 <AshyIsMe> http://stackoverflow.com/questions/7746894/are-there-pronounceable-names-for-common-haskell-operators
01:03:19 <AshyIsMe> not really names but pronunciations at least
01:05:01 <RommelVR> thansk AshyIsMe :)
01:05:31 <RommelVR> interesting "." as pipe to
01:05:34 <mm_freak_> RommelVR: most search engines allow you to write "->" in quotes
01:05:36 <RommelVR> I read that as curry
01:05:59 <mm_freak_> including google
01:06:12 <RommelVR> mm_freak_: eh? https://encrypted.google.com/search?hl=en&q=%22-%3E%22%20haskell
01:06:29 <RommelVR> I tried that, and the results were as useful as that ^
01:07:05 <sipa> afaik you cannot search for symbols in google
01:07:13 <mm_freak_> so much for that =)
01:07:38 <mm_freak_> https://duckduckgo.com/?q=haskell%20%22-%3E%22
01:07:46 <mm_freak_> "Neil Haskell Dating : Connect With Singles"
01:07:48 <mm_freak_> =)
01:10:15 <mm_freak_> RommelVR: the "<-" operator is easier to search for:  monad bind, monadic bind, do notation, etc.
01:10:33 <mm_freak_> and for "=>" you search for "constraint" or "context"
01:19:39 <RommelVR> mm_freak_: even for https://duckduckgo.com/?q=!g+%22%3C-%22+bind%22 I get nothing useful :S
01:19:48 <RommelVR> and afaik, isn't ">>=" bind? :P
01:20:39 <RommelVR> <- is for like... list comps
01:21:39 <mm_freak_> RommelVR: <- desugars to >>=
01:22:17 <Polarina> Desugaring sounds like a diet.
01:23:23 <BMeph> A Diet of Worms? ;þ
01:27:19 <hp67> Hey, can anybody explain to me why my heap profiles always seem to get truncated? I only ever seem to get a 1-2s in the output from hp2ps, which is rather useless for a program that has a stack error after 30s
01:35:14 <volko> hrmm, trying to install accelerate-cuda on windows, I am getting this error
01:35:15 <volko> http://pastebin.com/LKjZcCnZ
01:35:16 <mauke> The paste LKjZcCnZ has been copied to http://lpaste.net/94222
01:35:44 <volko> Data/Array/Accelerate/Cuda/Context.hs looks like it has an instance though
01:35:54 <volko> instance Eq Context where (==) = (==) `on` deviceContext
01:37:27 <volko> not sure what I'm missing here
01:37:36 * hackagebot yesod-bin 1.2.3.4 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.3.4 (MichaelSnoyman)
01:44:33 * zammy is away: I'm busy
01:44:41 * zammy is back (gone 00:00:05)
01:45:07 <xpika_> is there a haskell library for inspecting a functions type for use in a vim plugin?
02:01:28 <jle`> xpika_: vim haskell-mode is supposed to do it, but i haven't really been able to get it to work properly
02:02:09 <jle`> if you do find a way let me know, it'd really come in handy sometimes
02:02:11 <jle`> :)
02:02:16 <skypers> @hoogle String -> Ptr [Char]
02:02:17 <lambdabot> Data.Data tyconModule :: String -> String
02:02:17 <lambdabot> Data.Data tyconUQname :: String -> String
02:02:17 <lambdabot> Test.QuickCheck.Text bold :: String -> String
02:02:25 <skypers> @hoogle String -> Ptr Char
02:02:25 <lambdabot> Foreign.Marshal.Array newArray :: Storable a => [a] -> IO (Ptr a)
02:02:25 <lambdabot> Prelude head :: [a] -> a
02:02:25 <lambdabot> Data.List head :: [a] -> a
02:02:33 <skypers> newArray then
02:07:27 <skypers> hey folks, do you know a way to peekArrayLen ?
02:07:33 <skypers> does it even exist?
02:07:38 <skypers> @hoogle peekArrayLen
02:07:39 <lambdabot> No results found
02:07:42 <skypers> onoes :(
02:08:53 <skypers> oh peekArray0 '\0' maybe?
02:08:58 <skypers> gonna try it
02:13:44 <xpika_> jle`: i was actuall looking a library written in haskell
02:17:47 * hackagebot hamlet 1.1.7.3 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.7.3 (MichaelSnoyman)
02:27:48 * hackagebot yesod-fay 0.4.0.5 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.4.0.5 (MichaelSnoyman)
02:28:50 <skypers> does a function exist to alloca something and read the value back?
02:28:54 <skypers> I use somethink like
02:29:12 <skypers> alloca $ \mem -> … >> peek mem
02:30:00 <Lethalman> skypers, STRef?
02:30:28 <skypers> I don’t know STRef
02:30:32 <Lethalman> skypers, StateT?
02:30:46 <skypers> hm
02:30:50 <skypers> it’s just a function call
02:30:55 <skypers> StateT is too overkill here
02:30:56 <Lethalman> skypers, look for them, those are things for maintaining state
02:31:04 <skypers> I don’t need state here
02:31:06 <skypers> just read back
02:31:12 <Lethalman> ReaderT then
02:32:56 <skypers> huh :D
02:33:09 <skypers> ok I’ll keep stuck to the peek mem solution
02:37:48 * hackagebot acme-omitted 1.2.0.0 - Purely functional omitted content for Haskell  http://hackage.haskell.org/package/acme-omitted-1.2.0.0 (JoachimFasting)
02:38:50 <Polarina> skypers, you may pretty your code a little with { alloca $ liftM2 (>>) getStatus peek } instead of { alloca $ \ptr -> getStatus ptr >> peek ptr } for example. :-)
02:39:23 <skypers> huh
02:39:29 <skypers> liftM2
02:39:45 <skypers> it’s kinda hard to understand now :D
02:39:52 <Polarina> @src liftM2
02:39:52 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
02:39:56 <Polarina> It's in Control.Monad
02:40:04 <skypers> yeah yeah
02:40:07 <skypers> but I mean
02:40:10 <skypers> here
02:40:15 <skypers> it’s hard to understand what it does
02:40:32 <skypers> liftM2 (>>) m1 m2
02:40:41 <skypers> it takes m1
02:40:45 <skypers> x <- m1
02:40:47 <skypers> y <- m2
02:40:52 <skypers> x >> y
02:40:53 <skypers> ?
02:41:16 <Polarina> Correct.
02:41:48 <supki_> > liftM2 (f :: Expr -> Expr -> Expr) g h x :: Expr
02:41:50 <lambdabot>   f (g x) (h x)
02:42:17 <skypers> and where the value from alloca goes?
02:43:56 <Polarina> { liftM2 (>>) getStatus peek } is a function that takes the Ptr and passes them to both getStatus and peek.
02:47:57 <Polarina> skypers, a function is a Monad too.
02:48:12 <Lethalman> :t (>>) <$> m1 `ap` m2
02:48:13 <lambdabot>     Not in scope: `m1'
02:48:14 <lambdabot>     Perhaps you meant one of these:
02:48:14 <lambdabot>       `m' (imported from Debug.SimpleReflect),
02:48:21 <yitz> skypers: "alloca $ \ptr -> do ..." is a very common idiom. so you don't have to feel bad if you use it.
02:48:24 <Lethalman> :t (>>) <$> x `ap` y
02:48:25 <lambdabot>     Couldn't match expected type `f0 (a1 -> m0 a0)'
02:48:25 <lambdabot>                 with actual type `Expr'
02:48:25 <lambdabot>     In the first argument of `ap', namely `x'
02:48:55 <skypers> ok
02:48:56 <skypers> thank you
02:48:57 <yitz> skypers: but the it's fun to explore the alternatives too :)
02:50:12 * Polarina just realized that { alloca $ getStatus >> peek } would work too.
02:52:38 <skypers> Polarina: huh?
02:52:46 <skypers> how?
02:52:56 <skypers> getStatus is IO ()
02:53:16 <Polarina> getStatus :: Ptr a -> IO ()
03:12:49 * hackagebot yesod-core 1.2.4.5 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.4.5 (MichaelSnoyman)
03:16:51 <Polarina> I have this using lens { ((fromList [("a", 1), ("b", 2)]) ^.at "a") } which gives { Just 1 }. How would I modify that to change the value for "a"?
03:17:33 <Taneb> structure & at a .~ Just newValue
03:19:11 <donri> or, i think, ix a .~ newValue
03:20:18 <Polarina> I'm getting neither to work.
03:21:23 <bennofs> Taneb: x .~ Just y is the same as x ?~ y
03:21:49 <Taneb> Yeah
03:22:24 <bennofs> > Data.Map.fromList [("a", 1), ("b", 2)] & at "a" ?~ 3
03:22:26 <lambdabot>   Not in scope: `Data.Map.fromList'
03:22:31 <bennofs> > M.fromList [("a", 1), ("b", 2)] & at "a" ?~ 3
03:22:35 <lambdabot>   fromList [("a",3),("b",2)]
03:22:40 <bennofs> > M.fromList [("a", 1), ("b", 2)] & at "c" ?~ 3
03:22:42 <lambdabot>   fromList [("a",1),("b",2),("c",3)]
03:22:58 <Polarina> Yay! I was so close. :-)
03:24:09 <Polarina> Thank you, Taneb, donri and bennofs.
03:25:44 <bennofs> Can I use hoogle with cabal sandboxes?
03:33:38 <bennofs> Is there a GHC language pragma to make constructor fields strict-by-default?
03:34:26 <Cale> no
03:34:27 <mm_freak_> bennofs: no
03:34:34 <bennofs> :(
03:34:44 <mm_freak_> the proper response should be ":)"
03:35:54 <Cale> It's better that when you look at a data declaration you can tell whether the fields are strict or not without having to go through the rest of the module looking for pragmas.
03:36:36 <bennofs> Cale: That pragma would probably be only used in language-pragma's in the cabal file, I guess. But you'd still have to look there, of course.
03:36:55 <Cale> That seems even worse to me
03:37:10 <mm_freak_> bennofs: also strict fields are usually not what you want…  strict functions work better
03:42:42 <zebr> hi all. is there an easy way to run a function (a -> b -> (a,b)) through a list [a] to yield ([a],b)? it looks like State + foldl, but i can't see how i'd do it.
03:43:26 <bennofs> zebr: Given (,) as the function, and [1,2,3] as the list, what would be the result?
03:43:57 <bennofs> You need at least an initial b.
03:45:08 <enthropy> @type mapAccumL
03:45:09 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
03:45:12 <zebr> yeah. thinking more, i'm looking for some :: (a -> b -> (c,a)) -> a -> [b] -> ([c],a).
03:45:36 <RommelVR> ghc compiles Haskell down to machine code right?
03:45:37 <bennofs> @hoogle  (a -> b -> (c,a)) -> a -> [b] -> ([c],a)
03:45:38 <zebr> mapAccumL looks very close
03:45:38 <lambdabot> No results found
03:45:44 <RommelVR> Its not interpeted? Aka statically compiled
03:45:52 <zebr> RommelVR: yes
03:46:58 <enthropy> zebr: looks the same if you flip the tuple
03:47:03 <RommelVR> zebr: is there any way to product the resultant C or assembly code from a (very small) Haskell program?
03:47:11 <RommelVR> produce*
03:47:21 <zebr> enthropy: yeah, i think that'll work, i'll just do some flipping
03:47:23 <zebr> thanks :)
03:47:59 <bennofs> RommelVR: you can pass -ddump-asm to GHC to view assembly code
03:49:14 <Polarina> There's also a program called ghc-core that makes things easier to read.
03:49:25 <bennofs> Polarina: that doesn't print assembly, does it?
03:49:34 <Polarina> bennofs, it prints assembly too.
04:04:13 <RommelVR> so, I've just been asked by a friend about why I'm not using Haskell for everything yet, and my first response was simply that sometimes mutation is more convenient, with my example being: say I had a 1024*1024 buffer, already set up from some previous situation and in an array (aka, not lazy), if I had mutation to change some data in the center of the buffer I would just do buffer[512][512] and it would be (more or less) a poin
04:04:22 <yasar> Can someone explain what this code state: xs `minus` [p, p+p..m]
04:04:31 <RommelVR> I'm sure my inability to answer this was simply my own inexperience
04:04:58 <Breadmonster> Guys? How does the Haskell-cafe mailing list work?
04:06:15 <Breadmonster> I just decided to subscribe to the list, but I don't seem to get an automated subscription confirmation.
04:06:29 <Breadmonster> Does this mean that someone will manually confirm my subscription?
04:09:01 <benmachine> RommelVR: your message got cut off, (more or less) a poin
04:10:06 <RommelVR> o really?         -- and it would be (more or less) a pointer+offset, pointer  load and value push set of operations. Constant time... how would I be able to do this in Haskell?
04:10:25 <RommelVR> After writing that, I've found MVector/MArray... might be closer to what I'm looking for
04:13:37 <benmachine> yeah, STArray is a way to do it while staying pure
04:13:45 <yasar> Where should I find and import he `minus` function that is used between two lists?
04:14:04 <benmachine> but sometimes it's possible to do it without mutation, e.g. by batching up all your array updates, or using a different algorithm
04:14:12 <benmachine> but for when you *really* need mutable arrays, we have them
04:14:40 <benmachine> yasar: with exactly that name? or just a difference-of-lists function?
04:15:23 <yasar> I am trying to replicate first function here: http://www.haskell.org/haskellwiki/Prime_numbers#Sieve_of_Eratosthenes
04:15:46 <yasar> They used a minus function
04:23:21 <mm_freak_> yasar: scroll down a bit
04:25:32 <bennofs> Using the "network" package to connect to an unix socket, what should I use as the host name for connectTo?
04:25:37 <bennofs> @hoogle connectTo
04:25:38 <lambdabot> Network connectTo :: HostName -> PortID -> IO Handle
04:25:38 <lambdabot> Network.CGI.Compat connectToCGIScript :: String -> PortID -> IO ()
04:26:22 <bennofs> seems it doesn't matter. It's ignored in connectTo (source code)
04:28:39 <benmachine> bennofs: yeah, there's already an issue about it https://github.com/haskell/network/issues/10
04:28:52 <benmachine> bennofs: the Network module is pretty unloved, Network.Socket is recommended instead
04:30:33 <bennofs> benmachine: The haddock says that "Network [..] is recommended, unless you need the lower level functionality." maybe that should be fixed?
04:30:52 <benmachine> bennofs: good point
04:34:19 <Breadmonster> How do I tell when Haskell's smart optimizations kick in?
04:34:57 <Breadmonster> For example, you can define the average of a list of Doubles as avg xs = (sum xs)/(length xs)
04:35:30 <Cale> Breadmonster: apart from strictness analysis, there aren't many optimisations which apply to that
04:35:43 <Breadmonster> But since this is a linked list, and finding the length isn't a constant time operation, can I say that Haskell will walk down the list only once?
04:35:49 <Cale> no you can't
04:36:04 <Cale> In fact, if you write the program like that, it will be walked down twice.
04:36:19 <Breadmonster> So should I implement it using a fold?
04:36:28 <Cale> However, xs itself will be evaluated at most once
04:36:58 <benmachine> Breadmonster: that is kind of the canonical example of things that we'd like to find a nice way of expressing that is both high-level and efficient
04:37:10 <mauke> Breadmonster: why bother?
04:37:12 <Breadmonster> benmachine: I didn't get that.
04:37:36 <Breadmonster> mauke: It's an underlying code construct that I don't need people to see, and it's intuitively obvious.
04:37:38 <Cale> Breadmonster: If you want to get a little more performance out of it, you can opt to rewrite it as a strict left fold
04:37:45 <benmachine> Breadmonster: I just mean, how to write "avg" so that it's pretty and efficient is a problem lots of people have thought about
04:37:46 <mauke> Breadmonster: what
04:37:47 <benmachine> cf. http://squing.blogspot.co.uk/2008/11/beautiful-folding.html
04:37:50 <Breadmonster> Cale: Why not right?
04:37:59 <Kaidelong> benmachine: that's an example where APL and J have a solution that satisfies them
04:38:12 <Cale> Breadmonster: because you want to force the evaluation of the pair on each step
04:38:23 <mauke> why is N * 2 faster than 2 * N?
04:38:24 <Kaidelong> but to be fair they are vector based so length is generally constant time
04:39:11 <Breadmonster> Cale: Also, what's the difference between foldl' and foldl?
04:39:22 <Cale> @src foldl
04:39:23 <lambdabot> foldl f z []     = z
04:39:23 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:39:25 <Cale> @src foldl'
04:39:25 <lambdabot> foldl' f a []     = a
04:39:25 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
04:39:32 <Breadmonster> I've noticed that a lot of the time, GHC internal source code uses foldl and not foldl'.
04:40:02 <Kaidelong> essentially it prevents a big stack of foldl f (foldl f (foldl f (foldl f... from building
04:40:03 <Cale> foldl' sequences the evaluation of the accumulating parameter, so as to keep the expressions from growing
04:40:08 <Cale> uh, no
04:40:12 <Cale> It doesn't look like that
04:40:15 <Kaidelong> err
04:40:23 <Cale> Let's look at foldl (+) 0 [1,2,3]
04:40:23 <Swineflu> I have a list comprehension, and the expression part is 3 values, this gives me an error on the "|"
04:40:36 <Kaidelong> foldl (f (f (f (f ...
04:40:36 <Breadmonster> For example, reverse = foldl (:)
04:40:38 <Kaidelong> something like that
04:40:40 <Breadmonster> And not foldl' (:)
04:40:43 <benmachine> Breadmonster: it's a bit subtle
04:40:52 <benmachine> Breadmonster: with optimisations on it's usually not that big a deal
04:41:03 <Cale> foldl (+) 0 [1,2,3] --> foldl (+) (0 + 1) [2,3] --> foldl (+) ((0 + 1) + 2) [3] --> foldl (+) (((0 + 1) + 2) + 3) [] --> (((0 + 1) + 2) + 3)
04:41:08 <benmachine> Breadmonster: the difference is strictness, and optimisations usually let GHC work out what should be strict anyway
04:41:11 <lpaste> chenwl pasted “ghc bug” at http://lpaste.net/94231
04:41:26 <Kaidelong> distributes the operation throughout the list with left associativity
04:41:28 <Breadmonster> benmachine: Yeah, I thought the differences were obvious after reading LYAH, but now that I've jumped into GHC code, it's a lot of more complex than it appears.
04:41:41 <chenwl> at the line 42, without "=>" cause ghc to panic
04:42:11 <Swineflu> http://lpaste.net/891433639244464128 This is my error and code, I can make it work by returning a tuple but i want a list of ints
04:42:11 <Polarina> chenwl, this would be a good time to file a bug report.
04:42:29 <Cale> Breadmonster: reverse is one case where foldl is definitely better than foldl'
04:42:44 <Cale> Breadmonster: forcing the evaluation of (:) doesn't do much, because it's a constructor
04:42:58 <chenwl> Polarina: how do I know if this is fixed, because I may not using the newest ghc.
04:43:01 <Cale> actually, it's foldl (flip (:)) as well
04:43:09 <chenwl> Polarina: I am using ubuntu 12.04
04:43:21 <mauke> chenwl: what ghc are you using?
04:43:23 <Cale> (but even forcing the evaluation of the flips ahead of time is potentially kind of a waste)
04:43:27 <chenwl> The Glorious Glasgow Haskell Compilation System, version 7.4.1
04:43:30 <chenwl> mauke:
04:43:39 <Polarina> chenwl, on my GHC (7.6.3) I get a "Malformed instance: (IntRep m, IntRep s, IntRep kg) Show (Unit m s kg)"
04:43:46 <Breadmonster> So when can I use foldl' and when can I use foldl?
04:44:27 <Cale> Breadmonster: generally you should use foldl' when the function you're using to combine the elements is strict
04:44:39 <Breadmonster> What do you mean?
04:44:43 <Breadmonster> I thought all functions are lazy?
04:44:45 <chenwl> Polarina: I am not lucky
04:45:01 <Cale> A function f is strict when f _|_ = _|_
04:45:24 <Cale> But to put it another way: when the function pattern matches on both its arguments
04:45:35 <Breadmonster> Okay.
04:45:42 <Cale> (+) can't produce any part of its result before examining both its arguments
04:45:43 <Breadmonster> I've never seen this definition before.
04:45:55 <Breadmonster> So it's strict.
04:45:58 <Cale> yeah
04:45:59 <Breadmonster> Hmm, and how do I tell?
04:46:03 <Breadmonster> Is it just experience?
04:46:13 <Breadmonster> Wait, that way, const is lazy, right?
04:46:18 <Cale> Well, if you have the definition in front of you, you can look and see if it pattern matches
04:46:30 <Cale> const 0 isn't strict
04:46:47 <Cale> I suppose technically const itself isn't either
04:46:48 <Polarina> Breadmonster, you could try in ghci { f undefined `seq` () } and see if you get a empty tuple or Prelude.undefined
04:46:56 <Cale> (but that's much more subtle)
04:47:18 <Breadmonster> Polarina: That's a useful tool, thank you :)
04:47:37 <Cale> > (1 :) undefined `seq` ()
04:47:38 <lambdabot>   ()
04:47:39 <Breadmonster> Polarina: If the function is strict, I should get Prelude.undefined, right?
04:47:46 <Cale> right
04:47:46 <Polarina> Breadmonster, correct.
04:48:12 <Kaidelong> Swineflu, did you try putting the first tuple in parenthesis? The haskell report doesn't seem to specify pat , ... , pat as a valid way of making a tuple but it allows ( pat , ... , pat )
04:48:52 <Kaidelong> oh I see what you want
04:48:55 <Swineflu> I don't want a tuple tho :(
04:49:09 <Cale> Swineflu: perhaps you meant  [ v | (n1,v1,v2,v3) <- xs, n == n1, v <- [v1,v2,v3]] ?
04:49:24 <Swineflu> I can make it return a tuple, I guess passing 3 values isnt a "Expression"
04:49:34 <Breadmonster> Also, when I see function definitions, what do !a and #a mean?
04:49:40 <Swineflu> Ohhh, so i have to make my list a variable first
04:49:46 <Cale> I don't know what #a means
04:49:51 <Cale> (where did you see it?)
04:49:52 <Kaidelong> ! is a strict parameter and # an unboxed one, IIRC
04:50:06 <Polarina> Breadmonster, !a means to evaluate 'a' to weak-head normal form. Same as applying `seq` to it at the very beginning.
04:50:07 <Cale> ! might be a bang pattern, if it occurs before a pattern
04:50:11 <Kaidelong> so # means pass by value
04:50:14 <Cale> no
04:50:17 <Cale> # has no meaning
04:50:24 <Cale> No special meaning
04:50:26 <Kaidelong> MagicHash?
04:50:38 <Cale> However, it's *conventionally* used at the end of names of things which are unboxed
04:50:43 <Kaidelong> oh okay
04:50:48 <Cale> and for otherwise internal things
04:50:53 <Breadmonster> Unboxed?
04:51:03 <Cale> MagicHash is the extension that lets it be used as part of identifier names
04:51:12 <Cale> Otherwise, it's an infix operator symbol
04:51:26 <Breadmonster> @src length
04:51:26 <lambdabot> Source not found. You speak an infinite deal of nothing.
04:51:39 <Kaidelong> unboxed types guarantee a particular size in bytes for all members of that type
04:51:40 <Kaidelong> IE Int
04:51:50 <Cale> Breadmonster: All Haskell values in GHC are normally represented in memory as a pointer to code
04:51:51 <Breadmonster> @stc Data.List (length)
04:51:52 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
04:52:11 <Cale> Breadmonster: This is because we need to be able to represent unevaluated expressions at runtime
04:52:40 <Breadmonster> GHC is incredibly complicated.
04:52:43 <Breadmonster> Wow.
04:52:58 <Cale> Breadmonster: The first time that code is entered, the value is computed, and the pointer is updated to point at a shorter piece of code which returns it immediately
04:53:03 <benmachine> Breadmonster: we prefer the term "sophisticated" :D
04:53:06 <Cale> (before returning the result)
04:53:12 <Breadmonster> That is also true.
04:53:21 <donri> weird, length isn't in @src?
04:53:25 <donri> @src genericLength
04:53:25 <lambdabot> genericLength []    = 0
04:53:26 <lambdabot> genericLength (_:l) = 1 + genericLength l
04:53:43 <Cale> Breadmonster: Actually, that's simpler than most of the other ways of implementing lazy evaluation.
04:53:45 <Breadmonster> Umm, do you know how long it takes for someone to approve of your request for subscription to Haskell-cafe?
04:54:08 <Polarina> Breadmonster, there should be no wait, it's automatic.
04:54:24 <Cale> Breadmonster: Another way would be to represent values as a boolean flag (evaluated) together with either a pointer to code, or a pointer to the computed values
04:54:26 <Cale> value*
04:54:55 <Cale> Breadmonster: However, that would require testing a conditional every time, rather than simply jumping into some code
04:55:19 <Breadmonster> Polarina: Nope, I have no idea what's going on.
04:55:34 <Polarina> Breadmonster, have you checked your spam folder?
04:56:10 <Cale> Breadmonster: Another very important reason for this representation is to support polymorphism
04:56:24 <Breadmonster> Polarina: Yup, absolutely nothing.
04:56:52 <Cale> Breadmonster: You might've noticed that map :: (a -> b) -> [a] -> [b] doesn't care at all about the types a and b -- it's compiled just once and used at every pair of types
04:57:09 <Polarina> Breadmonster, try registering again and see what happens.
04:57:11 <Cale> Breadmonster: the reason that can be the case is that all ordinary values have the same size in memory
04:57:34 <Breadmonster> Yeah, I was wondering how that's implemented...
04:57:38 <Cale> So the same code can operate on them polymorphically so long as it doesn't need to actually pattern match on them.
04:57:40 <Breadmonster> Polarina: Okay.
04:57:50 <Kaidelong> Cale is there any advantage to taking the approach of compiling separate map functions for each instantiation of map discovered in the program?
04:58:02 <Cale> Kaidelong: You might need infinitely many
04:58:50 <Cale> (or in other words, if you do it like that, you might need to do runtime compilation)
04:58:53 <Kaidelong> seems like you'd run into that situation only if you had higher order types or if you didn't do whole program compilation
04:59:12 <Kaidelong> and static linking
04:59:12 <Cale> Consider something like this:
04:59:13 <Breadmonster> Is there a Haskell equivalent of MLton, btw?
04:59:18 <mauke> > let foo :: (Show a) => a -> Int -> String; foo x 0 = show x; foo x n = foo (x, x) (n - 1) in foo 'x' 2
04:59:19 <lambdabot>   "(('x','x'),('x','x'))"
04:59:30 <Cale> ^^ yeah, that was the example I was going to give :)
04:59:45 <mauke> Kaidelong: how many versions of foo do you need?
04:59:50 <Cale> > let foo :: (Show a) => a -> Int -> String; foo x 0 = show x; foo x n = foo (x, x) (n - 1) in map (foo ()) [0..]
04:59:51 <lambdabot>   ["()","((),())","(((),()),((),()))","((((),()),((),())),(((),()),((),())))"...
05:00:24 <RommelVR> what does it mean by "one origin vector"
05:00:36 <sshine> Breadmonster, GHC?
05:01:27 <Breadmonster> I meant one involving whole program optimization.
05:01:54 <Kaidelong> I see, you'd have to disallow instances like (Show a) => Show B a
05:01:57 <Cale> Note that there's nothing special about the use of typeclasses there
05:02:10 <Cale> foo could just as easily have taken a parameter of type (a -> String)
05:02:30 <Kaidelong> mmm
05:02:43 <benmachine> Breadmonster: JHC used to specialise in whole-program optimisation, I vaguely recall
05:02:54 <Cale> (but typeclasses make it easier to write the example, because the instance (Show a, Show b) => Show (a,b) gets supplied automatically)
05:02:59 <benmachine> but I'm not sure if it was really a "production-ready" compiler
05:03:28 <Cale> The real thing which is going on there is called polymorphic recursion
05:03:59 <Cale> It's that you're allowed to define a polymorphic function by applying it at a different type.
05:04:53 <Kaidelong> I see
05:04:58 <mauke> and it's H98 \o/
05:07:20 <RommelVR> this language is going to ruin my *working* life
05:10:30 <Polarina> RommelVR, why so?
05:13:51 <AshyIsMe> RommelVR: ive just started learning haskell
05:14:04 <AshyIsMe> c# at work isnt gonna be the same
05:18:31 <briennetheblue> sadly you can't just forget the existence of haskell at will :)
05:19:31 <Kaidelong> C# is a nice language
05:19:49 <Kaidelong> and .NET is great for deployability
05:19:57 <Kaidelong> so you still have it good
05:20:53 <WJWH> I just tried to upload a package to hackage
05:20:59 <mauke> .NET is shit for deployability on non-windows
05:20:59 <WJWH> but it gave a 403 forbidden error
05:21:00 <Kaidelong> also learning haskell is probably good if you're programming C# because it gives a good background for understanding functional features like LINQ
05:21:28 <mauke> WJWH: did you do it in your browser?
05:21:28 <WJWH> what did i miss?
05:21:36 <WJWH> mauke: yes
05:21:44 <Kaidelong> and async, and Rx
05:22:13 <WJWH> using the "upload" link
05:23:06 <Breadmonster> How do I represent Haskell in GSoC?
05:23:48 <hpc> loook for a project you can do in haskell, or create a project that you want in haskell
05:24:00 <Kaidelong> (C# is practically a functional language now anyway)
05:25:01 <Kaidelong> mainly missing pattern matching and ADTs
05:26:21 <stelleg> @src foldl
05:26:22 <lambdabot> foldl f z []     = z
05:26:22 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
05:30:46 <halvorgb> http://lpaste.net/94232, is there any reason I hit an upper limit of 309 digits?
05:31:13 <halvorgb> isn't fromIntegral Integer -> some sort of abritrary precision Double?
05:31:21 <WJWH> cabal upload gives a 403 error too, btw
05:31:45 <hpc> > length (show (floor (0/0) :: Integer))
05:31:46 <lambdabot>   310
05:32:06 <Maxdamantus> 9*10^308 ~= 2^1024
05:32:09 <hpc> halvorgb: you're going through Double
05:32:23 <hpc> ans = round (floating point value)
05:32:35 <hpc> :t (**)
05:32:36 <lambdabot> Floating a => a -> a -> a
05:32:41 <hpc> :t (^)
05:32:42 <lambdabot> (Integral b, Num a) => a -> b -> a
05:32:44 <halvorgb> Ah I see, is there a power for integers?
05:32:45 <hpc> :t (^^)
05:32:46 <lambdabot> (Fractional a, Integral b) => a -> b -> a
05:32:49 <halvorgb> cool
05:32:50 <briennetheblue> > 10 ^ 1000
05:32:51 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
05:32:51 <hpc> use (^)
05:32:55 <halvorgb> thanks
05:33:13 <hpc> halvorgb: welcome to defaulting!
05:35:21 <Maxdamantus> er, meant 2^1023
05:36:08 <aforemny> All Hydra services are reported running by systemctl. Still the output looks like this: http://hydra.nomath.org/build/1. How long do I have to wait for the build to be picked up? Can I force it? Plus the log seems to be generated already.
05:43:27 <bennofs> Where does hoogle put it's databases?
05:45:25 <Polarina> Lenses are very confusing.
05:47:57 <Lethalman> bennofs, strace hoogle :P
05:48:22 <bennofs> Lethalman: Yeah, I solved it similar to that (ls -l /proc/{pid_of_hoogle}/fd)
05:48:38 <Polarina> Let's say I have { data A = A { _a :: [Int]; _b :: Map Int String } }. Now I'm in a state monad. How do I perform a monadic action for each element in _a that does not have a corresponding key in _b?
05:50:46 <Polarina> I've been going through the haddoc documentation and trying out various things in ghci. I got it to print each element with { [1,2,3] ^! folded . act print } and { [1,2,3] & each `mapMOf_` print }, but that's pretty much it.
05:51:31 <Lethalman> :t Map a b -> [a]
05:51:32 <lambdabot> parse error on input `->'
05:51:39 <Lethalman> @hoogle Map a b -> [a]
05:51:39 <lambdabot> Data.Map.Lazy keys :: Map k a -> [k]
05:51:39 <lambdabot> Data.Map.Strict keys :: Map k a -> [k]
05:51:39 <lambdabot> Data.Graph.Inductive.Query.DFS topsort' :: Graph gr => gr a b -> [a]
05:51:53 <Lethalman> @hoogle retain
05:51:53 <lambdabot> Graphics.UI.GLUT.Callbacks.Window FullyRetained :: WindowState
05:51:53 <lambdabot> Graphics.UI.GLUT.Raw.Tokens glut_FULLY_RETAINED :: CInt
05:51:53 <lambdabot> Graphics.UI.GLUT.Raw.Tokens glut_PARTIALLY_RETAINED :: CInt
05:51:57 <Lethalman> @hoogle difference
05:51:58 <lambdabot> Data.IntMap.Strict difference :: IntMap a -> IntMap b -> IntMap a
05:51:58 <lambdabot> Data.IntMap.Lazy difference :: IntMap a -> IntMap b -> IntMap a
05:51:58 <lambdabot> Data.IntSet difference :: IntSet -> IntSet -> IntSet
05:52:33 <Lethalman> Polarina, you could use keys and (\\)
05:53:20 <Lethalman> a \\ (keys b) without lens
05:53:31 <Polarina> Lethalman, I can do it in many ugly ways, not a problem. I was hoping there was something simple that can be done with lenses. :-)
05:53:49 <Lethalman> Polarina, yes, the fact is that a \\ (keys b) is neither ugly nor complex :)
05:54:11 <Polarina> Just not terribly efficient. :)
05:55:24 <bennofs> Polarina: Is A the type of your state?
05:55:38 <Polarina> bennofs, yes.
05:56:07 <Lethalman> filter (flip member b) a should be the most efficient I guess
05:56:11 <identity> is there a way to make parsec only parse at most some number of bytes/characters, etc?
05:56:24 <Lethalman> I'd like to see a lens way for that as well if it's more simple
05:58:02 * hackagebot packunused 0.1.0.1 - Tool for detecting redundant Cabal package dependencies  http://hackage.haskell.org/package/packunused-0.1.0.1 (HerbertValerioRiedel)
05:58:36 <Polarina> Lethalman, that looks like a good enough solution. Thanks. :D
06:05:14 <RommelVR> is there a painless example of how to use MVectors somewhere?
06:07:41 <kryft> identity: I think there's a parser combinator called 'count' or something like that
06:08:02 <kryft> identity: So you can define a parser like 'count 5 char'
06:18:14 <arianvp_> I need to show all the 'equivalence classes' of the equivalence relation  `cos(a) = cos(-b)`  howabouts would I do that?
06:19:07 <mauke> is this math homework?
06:20:06 <arianvp_> Yes and no. it was sufficient to prove that it , indeed, is an equivalence relation.  I'm just trying to understand equivalence classes
06:20:26 <arianvp_> I've got the proof that it is an equivalence relation already.
06:21:02 <arianvp_> say ~ is our relation.  all its classes are  [a] = {x `elem` RealNumbers : x ~ a} right? but how would i "write down" all the classes..
06:21:11 <arianvp_> aren't there an infinite amount of equivalence classes in this case?
06:22:51 <identity> kryft: This is indeed true, but parsec doesn't fail if there's more than 5 characters in that scenario
06:22:59 <identity> so it parses 5, but there is still more input
06:24:17 <edwardk_> Polarina: in practice, we tend to use & only when the function on the right hand side is transforming something into something related to minimize confusion.
06:24:42 <briennetheblue> arianvp_ you can write it down as an interval I think?
06:25:00 <briennetheblue> if you know what i mean
06:26:20 <arianvp_> hmm wait
06:26:39 <arianvp_> the answer must be a partition. that for sure
06:26:55 <arianvp_> so it's a collection of subsets that are disjoint  or equal
06:27:16 <Cale> arianvp_: Just to simplify things slightly, it might be worth noting that cos (-b) = cos b
06:27:59 <briennetheblue> yup, so it's just an interval, right?
06:27:59 <Cale> Yes, equivalence classes always form a set partition.
06:28:06 <briennetheblue> or maybe my maths is failing
06:28:17 <briennetheblue> in this case i mean
06:29:24 <Cale> The interval [0,pi] contains a single representative for each of the equivalence classes.
06:29:36 <briennetheblue> yeah that's what i meant
06:29:53 <briennetheblue> so that's how you "write them all down"
06:30:30 <arianvp_> Cale. Yes and that also automatically gives me the  reflexivity right?
06:30:46 <Cale> Wait, are you still checking that it's an equivalence relation?
06:30:51 <arianvp_> no i finished that
06:31:17 <arianvp_> but why isnt it the interval [0,2pi] ?
06:31:21 <Cale> Reflexivity is one of the conditions for it to be an equivalence relation
06:31:29 <Cale> huh?
06:31:52 <Cale> {cos x | x in [0,2pi]} = [-1,1]
06:32:21 <Cale> and for each y in [-1,1], there is exactly one x in [0,2pi] such that cos x = y
06:32:54 <Cale> To prove that requires digging into whatever precise definition of the cosine you're using.
06:33:25 <Cale> Well, I suppose you might be able to use various properties without having a proper definition
06:33:44 <Cale> er, sorry, not 2pi, pi
06:33:55 <Cale> (I wrote pi originally, didn't I?)
06:34:06 <briennetheblue> you did
06:34:08 <Cale> cos 0 = 1, and cos pi = -1
06:34:32 <Cale> and cos is strictly decreasing and continuous on that interval
06:35:44 <Cale> and such functions are injective
06:36:09 <arianvp_> it's only injective on that interval right
06:36:27 <cariveri> Hi. how do I pass string from the result of a system cmd to a string argument? ghc gives me could nto match ExitCode with [Char] (using s <- system $ <cmd> ) or couldn't n match IO String with actual type [String] -> ExitCode (using rawSystem $ <cmd>)
06:36:44 <Cale> Well, there are some other intervals, but yeah, if you extend that interval with any additional points, you'll make it not injective anymore.
06:37:41 <mauke> cariveri: system doesn't result in a string
06:37:42 <Cale> cariveri: You'll want the stuff here: http://www.haskell.org/ghc/docs/latest/html/libraries/process-1.1.0.2/System-Process.html
06:37:58 <mauke> cariveri: are you a php programmer?
06:38:03 <Cale> Specifically, readProcess might be just what you're looking for
06:38:57 <Cale> readProcess :: FilePath -> [String] -> String -> IO String
06:39:52 <Cale> You give it the executable's filename, and the list of arguments, and a String to give to the process' stdin, and it gives you an action which will run that process, and produce the contents of the process' stdout.
06:39:58 <cariveri> mauke: why php?
06:41:28 <geekosaur> expecting system to return a string. most languages use something along the lines of C's system() which just produces an exit code
06:41:31 <mauke> because php is the only language I know where system returns a string
06:41:44 <mauke> i.e. you seem to be coding with a php accent
06:42:06 <cariveri> I know that it resturns an ExitCode. thats why I tried "rawSystem" but it didnt work either.
06:42:23 <geekosaur> ...
06:42:24 <mauke> rawSystem also returns an ExitCode
06:42:32 <geekosaur> raw does not mean does *more* work
06:42:37 <mauke> I don't follow your logic
06:42:39 <arianvp_> oh so wait....   [a] = [b]  if   a=b(mod pi) ?
06:42:45 <Cale> rawSystem :: String -> [String] -> IO ExitCode
06:42:49 <arianvp_> that might help me find all equivalence classes
06:43:00 <Cale> arianvp_: not quite
06:43:05 <geekosaur> anything that captures output needs to set up a pipe, at minimum
06:43:12 <Cale> [a] = [b] is a = b (mod 2pi) though
06:43:14 <Cale> if*
06:43:25 <Cale> But not only if.
06:43:41 <Cale> There are two values per 2pi period
06:43:58 <mauke> πeriod
06:44:07 <Cale> (unless we're looking at the preimage of 1 or -1)
06:44:30 <cariveri> mauke: ok. those write to stdout. can't I redirect it to a string?
06:44:46 * geekosaur points to what he said above about pipes
06:44:57 <mauke> cariveri: what is "it"?
06:44:58 <Cale> Draw the graph of the cosine function for 2 or 3 periods, and then draw some horizontal lines, and see where they hit the graph
06:44:59 * geekosaur also points to Cale's comment about readProcess
06:45:01 <mauke> cariveri: and "I"?
06:45:17 <Cale> cariveri: I answered your question right away :)
06:45:34 <Cale> You almost certainly want readProcess
06:45:44 <arianvp_> Oh and because cos a  = cos - a
06:45:53 <arianvp_> then if cos a  = cos b then a and b are in the same class?
06:46:06 <Cale> yeah
06:46:17 <xpika> after loading a file "file.hs" in ghci, how can I show all functions in scope. :browse only shows those local to the file
06:47:00 <Cale> xpika: You can :browse ModuleName to see what's in a given module
06:47:06 <Cale> I don't know whether you can list everything in scope...
06:47:17 <mauke> hit tab twice
06:47:30 <Cale> oh, I suppose that works :)
06:47:55 <mauke> DERIVING SOLUTIONS FROM FIST PRINCIPLES
06:48:06 * hackagebot charset 0.3.5.1 - Fast unicode character sets based on complemented PATRICIA tries  http://hackage.haskell.org/package/charset-0.3.5.1 (EdwardKmett)
06:49:35 <mm_freak_> fist principles?
06:49:53 <Adeon> punch the keyboard until the correct program falls out
06:53:04 * hackagebot comonad-extras 3.0.2 - Comonad transformers requiring extensions to Haskell 98  http://hackage.haskell.org/package/comonad-extras-3.0.2 (EdwardKmett)
06:58:04 * hackagebot reducers 3.0.2.1 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-3.0.2.1 (EdwardKmett)
06:58:07 * hackagebot monadic-arrays 0.2.1.3 - Boxed and unboxed arrays for monad transformers  http://hackage.haskell.org/package/monadic-arrays-0.2.1.3 (EdwardKmett)
07:02:03 <Polarina> edwardk_, what do you mean with that & is used when "transforming" something into something?
07:02:27 <edwardk_> Polarina: in general we use things like & to apply something that tweaks a value slightly rather than turns it into something completely different.
07:03:15 <Polarina> edwardk_, I see. I'll try to avoid it then.
07:03:27 <edwardk_> Polarina: both of your uses there were using it to apply arbitrary functions. the types don't stop you from doing this but in terms of lens style, we tend to avoid that as it is confusing to follow what is being applied. i mentioned it only because right around then you said 'lens is confusing'. i agree, i found those examples confusing too ;)
07:04:49 <Polarina> :-)
07:06:19 <Polarina> edwardk_, I like the library though. Once you get something with it to work correctly, all other Haskell code looks like C++ in comparison.
07:06:33 <edwardk_> =)
07:07:21 <edwardk_> @remember Polarina Once you get something with [lens] to work correctly, all other Haskell code looks like C++ in comparison.
07:07:22 <lambdabot> Good to know.
07:07:56 <haasn> since using lens, my haskell code looks like C++
07:08:02 <edwardk_> hah
07:08:19 <stelleg> I'm guessing that the lyah writer, Miran, knows his section on the State Monad is outdated
07:09:44 <DavideP> what is lens?
07:09:54 <mauke> :3
07:12:38 <Cale> edwardk_: haha, did you see http://ro-che.info/ccc/23
07:26:07 <cariveri> Cale: I wrote a shell script to avoid piping. readProcess to call it worked, but the string seems to contain \n oder other symbols at the end being displayed as trashy bytes.
07:26:51 * pantsman- really enjoyed SPJ's talk about lens
07:27:06 <edwardk_> Cale: yeah =)
07:27:36 <edwardk_> cale: i replied with my favorite way of viewing lens in comic form: http://www.girlgeniusonline.com/comic.php?date=20081205
07:29:11 <edwardk_> pantsman-: he did a pretty good job of selling the basic getter/setter machinery and he was very enthusiastic in his presentation =)
07:30:35 <joelmo> cna i simplify this https://gist.github.com/3a629d4165b916e30245
07:31:15 <Polarina> joelmo, what happens when c is either 'a', 'u' or 'e'?
07:31:27 <bennofs> What is a "dual" in Haskell?
07:31:38 <joelmo> Polarina: same as print = "asd"
07:32:06 <Polarina> And what happens when c is neither of those characters?
07:32:33 <joelmo> Polarina: call rovarsprak cs
07:32:51 <edwardk_> joelmo: rovarsprak (c:cs) | c `elem` "ioaue" = print "asd"
07:32:53 <pantsman-> edwardk_, I liked how he compared it to the getter/setter stuff from the "older" lens representations, and gave just enough of a glimpse of the power and generality of lens to make it seem worth exploring deeper
07:33:17 <joelmo> edwardk_: thanks
07:34:08 <edwardk_> i thought he did a very good job of motivating the (a -> f a) -> s -> f s  representation in terms of the modify functions you'd want to write for efficiency anyways. that angle hadn't occurred to me. i'll adapt my usual lens talk to go that route
07:34:59 <mekeor> question: let M = the set of monads; A = the set of applicatives; F = the set of functors. then, M⊂A⊂F. but is there also a set X such that F⊂X?
07:35:12 <Polarina> edwardk_, less talks, more documentation, please. :)
07:35:17 <hpc> mekeor: all types?
07:35:30 <mekeor> hpc: :D
07:35:41 <edwardk_> Polarina: well, i'm all talks for the next couple of months. then maybe i can stop talking long enough to write things down ;)
07:36:03 <hpc> i think the narrowest you can get for X is "all types :: * -> *"
07:36:05 <edwardk_> i think i have 4-5 talks coming up in relatively short order.
07:36:41 <mekeor> hpc: what about arrow?
07:37:15 <edwardk_> one at mozilla friday, gsoc mentor summit, one at prezi in budapest, johns hopkins, and it sounds like there might be one up at u. waterloo
07:37:45 <mekeor> mekeor: i think that doesn't make sense
07:37:55 <Polarina> edwardk_, best of luck with those.
07:38:32 <edwardk_> post ICFP my schedule sort of exploded
07:44:50 <Polarina> How can a program run for a half a minute with "687,208 bytes allocated in the heap" and an "Alloc rate    2,260,411 bytes per MUT second" from +RTS -s ?
07:45:04 <bennofs> Is there a class like Applicative, that is a superclass of Comonad?
07:45:18 <edwardk_> no for fundamental reasons
07:45:31 <hpc> Polarina: lots of stack allocations?
07:45:49 <Polarina> hpc, stack allocations?
07:46:04 <hpc> just pulling ideas out of my ass ;)
07:47:49 <edwardk_> bennofs: 'coapplicative' would want a comonoid and for full symmetry coexponentials. comonoids in Hask, like comonoids in Set are all trivial. and we can't have a category with both exponentials and coexponentials without the laws for that category constraining it to be a poset. this would mean that there would be at most one arrow between any two objects. e.g. only one function between any two types.
07:48:10 <edwardk_> bennofs: so in the end, it can't exist
07:50:58 <sm> morning. At https://www.fpcomplete.com/user/tel/a-little-lens-starter-tutorial , I see ">>> forall $ \tuple -> view _1 tuple == fst tuple\nTrue". Where is forall from ?
07:52:01 <bennofs> sm: QuickCheck
07:52:18 <edwardk_> bennofs: if you move to linear logic where the world underneath is a symmetric monoidal category instead of a cartesian one, then you can have comonoids and coexponentials
07:54:03 <joelmo> rovarsprak (c:cs) x
07:54:04 <joelmo> 	|	c `elem` "euioa" = rovarsprak cs x
07:54:04 <joelmo> 	| otherwise = rovarsprak cs c:'o':c:x
07:54:11 <joelmo> im doing something thats not ok here
07:54:55 <sm> bennofs: thanks. I see forAll in QuickCheck, maybe it's this
07:55:20 <donri> joelmo: you probably want ++ in the otherwise case
07:55:42 <donri> although i'm not sure that's the whole story
07:56:50 <sm> or not
07:58:09 * hackagebot trifecta 1.2.1.1 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-1.2.1.1 (EdwardKmett)
07:58:11 * hackagebot graphs 0.5.0.1 - A simple monadic graph library  http://hackage.haskell.org/package/graphs-0.5.0.1 (EdwardKmett)
07:58:42 <donri> > (\c -> if c `notElem` "aeiou" then [c,'o',c] else [c]) =<< "rövarspråket"
07:58:44 <lambdabot>   "ror\246o\246vovarorsospopror\229o\229koketot"
07:59:29 <mekeor> what is =<< called in maths?
07:59:46 <donri> "that weird join"
08:00:05 <mekeor> :D
08:01:02 <geekosaur> I thought neoither of those was really used in math, just a Haskellism for a combination of (f)map and join
08:02:32 <joelmo> donri: thank you
08:02:49 <haasn> ‘bind’ is the common name, at least in Haskell
08:03:09 * hackagebot intervals 0.2.2.1 - Interval Arithmetic  http://hackage.haskell.org/package/intervals-0.2.2.1 (EdwardKmett)
08:03:28 <mekeor> haasn: isn't bind >>= ?
08:03:50 <haasn> I think (=<<) is more deserving of the name ‘bind’
08:03:58 <haasn> but you're right, it probably is
08:04:10 <haasn> not that there's much of a distinction between the two
08:04:22 <haasn> ‘flip’ is an absolutely trivial isomorphism, I wouldn't even call it a different function
08:04:23 <mekeor> yeah :)
08:04:25 <donri> =<< is bind, >>= is bind, diagrammatic order ;)
08:08:09 * hackagebot representable-functors 3.2.0.2 - Representable functors  http://hackage.haskell.org/package/representable-functors-3.2.0.2 (EdwardKmett)
08:13:10 * hackagebot keys 3.0.4 - Keyed functors and containers  http://hackage.haskell.org/package/keys-3.0.4 (EdwardKmett)
08:13:11 * hackagebot adjunctions 3.2.1.1 - Adjunctions  http://hackage.haskell.org/package/adjunctions-3.2.1.1 (EdwardKmett)
08:22:08 <startling> What's Set's Ord instance?
08:22:30 <startling> Is it subset/superset?
08:23:53 <aristid> startling: presumably lexical ordering on the ordered list?
08:23:57 <startling> Bleh.
08:24:04 <quchen> startling: instance Ord a => Ord (Set a) where
08:24:04 <quchen>     compare s1 s2 = compare (toAscList s1) (toAscList s2)
08:24:49 * aristid gets cookie points for guessing right \o/
08:25:07 <quchen> :-)
08:27:00 <startling> How verboten are partial orders for Ord?
08:27:54 <quchen> a < b is not necessarily defined for all a, b?
08:28:02 <quchen> That sounds evil.
08:28:15 * hackagebot HPi 0.1.0.0 - GPIO and I2C functions for the Raspberry Pi.  http://hackage.haskell.org/package/HPi-0.1.0.0 (WJWH)
08:28:51 <startling> no, "compare" is not necessarily defined for all a, b.
08:28:55 <ethercrow> Can someone fix unicode in yi's lexers?
08:28:56 <ethercrow> Please?
08:29:49 <quchen> startling: What's the difference to what I said there?
08:30:07 <ethercrow> looks like PhD in alex is required
08:30:35 <startling> quchen, (<) is defined for all a, b, it just might be False while also a > b == False and (a == b) == False.
08:31:43 <hmmh> Hey, I was just reading this: www.fpcomplete.com/user/tel/a-little-lens-starter-tutorial and had a few questions
08:31:58 <startling> Specifically I'm looking at (<) = isProperSubsetOf
08:32:08 <quchen> That would violate ∀ a. a <= a wouldn't it
08:32:22 <startling> No?
08:33:22 <startling> a <= b = a == b || a `isProperSubsetOf` b
08:33:45 <hmmh> Since I'm relatlvely new to haskell, I guess I fail to understand the need for something like lenses but to me it seems like an incredibly elaborate hack to allow for haskell to use OO type behavior. Is that accurate?
08:34:06 <startling> hmmh, it isn't really. Lenses are much more than getters and setters.
08:34:16 <quchen> hmmh: Not at all, no.
08:34:19 <startling> hmmh, it's not even an elaborate hack.
08:34:31 <startling> It's a really simple thing expanded on effusively.
08:35:34 <alpounet> hmmh, i would recommend to forget about lenses for now, if you're new to haskell. Get back to it in a couple of months
08:35:37 <k00mi> hmmh: if you're new to haskell you probably shouldn't bother with lenses yet
08:35:38 <quchen> hmmh: Immutability sometimes makes it awkward to change things deeply nested in some data structure. I think lenses originally addressed this issue, but then they turned out to be much more useful.
08:36:04 <startling> I don't know. I learned a lot learning about lenses.
08:36:25 <sm> quchen: +1. This original use case should be emphasized at the start
08:36:26 <startling> You should probably get a grip on Functor, Applicative, and Monad before you look at lenses though.
08:37:01 <startling> hmmh, I think lenses and traversals can be seen more usefully as "arbitrary left-hand-sides" in the imperative sense.
08:37:25 <startling> hmmh, for example, I can do world.monsters.hp +~ 1
08:37:42 <quchen> I don't know what a left-hand-side is.
08:37:46 <hmmh> quchen: That's helpful and sort of along the lines that my intuition was going.
08:38:08 <startling> or world . monsters . filtered isGood . hp +~ 1
08:38:47 <startling> You can do this with e.g. descriptors in python, but /that's/ a giant hack.
08:39:27 <hmmh> As a general question, do you guys think that libraries like lens are typical of the direction that haskell is going? Because the complexity to me seems absurd (over 100 operators?!) -- I fail to see how anyone could write maintainable code with a library like that
08:39:30 <startling> quchen, in e.g. python you can do "somedict[a] = 2". The left-hand side of this assignment is a special language construct.
08:39:46 <startling> it's different from e.g. "value = 2".
08:39:52 <quchen> hmmh: No, I don't think that occurs anywhere else.
08:39:56 <notdan> hmmh: I hope that's not the case
08:40:03 <quchen> hmmh: And a lot of people don't like lens because of that complexity.
08:40:06 <hmmh> Is haskell still a research language? I guess I was interested in learning it because it seemed to be powerful and heading towards the real practical world of things
08:40:22 <haasn> Haskell is definitely practical for many applications
08:40:24 <quchen> hmmh: It's really a tradeoff between power and understandability.
08:40:27 <startling> hmmh, fwiw the operators have a consistent naming scheme, and there are non-operator versions of most (all?) of them.
08:40:31 <notdan> hmmh: I have nothing against the lenses, but I think that 'lens' library is particularly overengineered. I don't know if there is a better solution though
08:40:35 <notdan> and I still use it :(
08:40:42 <haasn> I feel it mainly lacks in the areas of graphical development (GUIs, Games, etc.) but that's mostly a question of time I think
08:40:47 <haasn> Netwire, gloss etc. can be pretty cool
08:40:58 <startling> Yeah, it seems like we're finally getting there.
08:41:19 <hmmh> quchen: But why the redundancy then.... you're essentially asking everyone to learn things twice
08:41:30 <haasn> There also isn't a really practical Haskell OS yet. There's house, but nobody uses it and it doesn't get updated anymore (?). That's something that could be really cool to see in the future
08:41:44 <startling> But I think this is more of a trend in software development -- it seems to me like backend and web stuff have been in vogue for a while while GUI and game stuff has been ghettoized a bit.
08:41:57 <quchen> hmmh: Redundancy? You mean having multiple libraries having the same use case? Diversity is not a bad thing
08:42:22 <hmmh> Oh... oops sorry quchen, that was directed towards startling! My mistake
08:42:23 <haasn> “Reinventing the wheel” can be good, lenses are a great example. We had lots of different lens libraries before, but this new approach to the wheel gave us a lot of other neat stuff
08:42:24 <quchen> hmmh: Also note that you don't need to know that many operators to use lens
08:42:27 <quchen> Ah okay
08:42:45 <startling> hmmh, are you asking whether having two names for every function makes everyone learn everything twice?
08:43:00 <ibab> hey, does lens have something like "useListOf l = get >>= \s -> return (toListOf l s)"?
08:43:17 * hackagebot mega-sdist 0.2.10 - Handles uploading to Hackage from mega repos  http://hackage.haskell.org/package/mega-sdist-0.2.10 (MichaelSnoyman)
08:43:19 <startling> ibab, I was wondering that the other day. Let me check.
08:43:24 <haasn> gets (toListOf l) -- not lens
08:43:26 <ibab> It does have use and preuse, but I couldn't find the equivalent of toListOf
08:43:34 <haasn> well, sort of lens
08:43:49 <haasn> gets (^..l)
08:43:59 <hmmh> startling: I'm saying that having operator and non-operator versions of everything just makes the code more terse and less understandable... especially when the operators are bizarre, and somewhat regex like: eg ^?
08:44:22 <haasn> maybe: use (partsOf l) -- ?
08:45:02 <startling> hmmh, the thing about lenses and traversals is that you get a handle on what can be done with them pretty quickly, so it becomes "is this implemented in lens yet?".
08:45:19 <startling> That's just been my experience. I don't know if that helps you.
08:45:58 <startling> hmmh: the other thing is that they have consistent names -- the ^ tells me it's a view-ish function and the ? tells me it might returns a Maybe?
08:46:04 <hmmh> One example from the article I found particularly weird: ^. is infix for view. Why? Who needs that over `view`? You've saved tying 3 characters! It's not as if we're in Java here... haskell is terse enough as it is
08:46:06 <startling> I don't know that operator offhand, but let me check.
08:46:28 <haasn> hmmh: consider:  foo = view $ bar bat baz ... frob
08:46:37 <startling> Yep, that's what (^?) does. :)
08:46:41 <haasn> I certainly wouldn't want to type (^.(bar bat baz .... frob))
08:46:59 <haasn> or flip (^.) for that matter
08:47:12 <Polarina> Speaking of (^?), how can I use it on the state within a state monad?
08:47:30 <haasn> Polarina: ‘preuse’ ?
08:48:06 <hmmh> I'll have to come back to this. Thanks for your thoughts! :)
08:48:17 * hackagebot mega-sdist 0.2.10.1 - Handles uploading to Hackage from mega repos  http://hackage.haskell.org/package/mega-sdist-0.2.10.1 (MichaelSnoyman)
08:48:19 * hackagebot wai-app-static 1.3.3 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-1.3.3 (MichaelSnoyman)
08:48:21 * hackagebot warp 1.3.10 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.10 (MichaelSnoyman)
08:48:23 * hackagebot shakespeare-js 1.2.0.1 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-1.2.0.1 (MichaelSnoyman)
08:48:27 * hackagebot yesod-form 1.3.3 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.3 (MichaelSnoyman)
08:49:39 <ibab> haasn: thanks for the tricks with gets and partsOf
08:50:00 <Polarina> haasn, I got something like { let s :: StateT (Map String (Either String String)) IO (Maybe String); s = do { at "b" ^? _Just . _Right } } and that just gives me strange error messages.
08:50:05 <ibab> It does make sense that there's no special operator if you can construct them that easily
08:50:28 <haasn> ibab: oh, also, the  xs >>= \x -> return (f x) -- is equal to fmap f xs
08:50:36 <haasn> so you could have used fmap (^..l) get
08:50:42 <haasn> but fmap f get = gets f
08:50:50 <ibab> wow xD
08:51:08 <startling> :t gets
08:51:09 <lambdabot> MonadState s m => (s -> a) -> m a
08:51:14 <startling> oh, nice.
08:51:25 <haasn> :t fmap ?? get
08:51:26 <startling> I've used `liftM` get lots.
08:51:26 <lambdabot> (Functor f, MonadState a f) => (a -> b) -> f b
08:51:47 <startling> :t used `liftM` get -- I wonder how much of this conversation typechecks
08:51:47 <lambdabot>     Not in scope: `used'
08:51:47 <lambdabot>     Perhaps you meant one of these:
08:51:47 <lambdabot>       `use' (imported from Control.Lens),
08:52:06 <donri> :t use
08:52:07 <lambdabot> MonadState s m => Getting a s a -> m a
08:53:03 <haasn> Polarina: it sounds like you're trying to achieve:  preuse (at "b" . _Just . _Right)
08:53:11 <haasn> :t preuse $ at "b"._Just._Right
08:53:12 <lambdabot> (At s, MonadState s m, IxValue s ~ Either c b, Index s ~ [Char]) => m (Maybe b)
08:53:47 <haasn> somewhat confusing type signature but I hope you get the idea :)
08:53:52 <Polarina> haasn, yay! Thank you.
08:54:19 <haasn> in general, if you have a lens on the left hand side of an operator like ^? or ^. you're probably doing something wrong
08:54:22 <Polarina> haasn, the errors ghci spits out for me would take several pages if printed.
08:54:23 <haasn> the left hand side is where the values go
08:55:59 <Polarina> haasn, thanks. I'll keep that in mind.
08:56:08 <joe9>  can anyone please help me with this: output: http://codepad.org/OLeiviGL , program: http://codepad.org/0PFtua9C. for some reason the output that I am writing out with putStrLn is being overwritten by the runTestTT output.
08:56:25 <joe9> Is there any way I can get the runTestTT output to show up after the output I write out.
08:56:34 <person> what's the GHC language pragma for existential types?
08:57:02 <startling> ExistentialQuantification
08:57:03 <donri> ExistentialQuantification?
08:57:55 <person> thank you
08:59:36 <joe9> adding linebuffering is not helping either:    hSetBuffering stdout LineBuffering, modified program: http://codepad.org/ppKxPizd , output: http://codepad.org/Du2neJHY
09:00:26 <WJWH> w00t
09:00:37 <WJWH> just uploaded my first library to hackage
09:01:19 <katesmith> hi i am new and i was wondering what the channel is about ?
09:02:08 <zomg> katesmith: math porn
09:03:13 <WJWH> :/
09:03:18 <zomg> lol
09:04:02 <sipa> zomg: not such which of the two words of your answer scared katesmith...
09:04:41 <WJWH> sipa: it didnt matter apparently
09:05:42 <katesmith> #haskell-game
09:06:01 <joe9>  i guess my problem is that stderr output is overwriting the stdout output.
09:06:25 <WJWH> @pl \xs n -> take n xs
09:06:25 <lambdabot> flip take
09:06:53 <stephenmac7> How do I catch an error during an IO operation?
09:07:14 <stephenmac7> Like: (x:xs) <- myListReturningIOAction
09:07:27 <Cale> joe9: uh, what?
09:07:46 <stephenmac7> I tried this: catch ((x:xs) <- myListReturningIOAction) handler
09:07:52 <stephenmac7> Didn't work
09:07:59 <joe9>  adding linebuffering is not helping either:    hSetBuffering stdout LineBuffering, modified program: http://codepad.org/ppKxPizd , output: http://codepad.org/Du2neJHY , Cale.
09:08:02 <Cale> stephenmac7: Perhaps you'd rather write  xs <- myListReturningIOAction; case xs of [] -> ...; (y:ys) -> ...
09:08:19 <joe9> I am trying to figure out how to stop the runTestTT output overwriting my normal output.
09:08:31 <Cale> What do you mean by "overwriting"?
09:08:39 <stephenmac7> Cale: Ah
09:08:40 <stephenmac7> Thanks
09:08:59 <Cale> joe9: Output never overwrites other output
09:09:28 <notdan> Silly question: why is a store comonad called costate? In what sense is it dual to state?
09:09:33 <Cale> Output happens sequentially, and it all happens. If you're not seeing output that you expect to see, then it's not happening at all.
09:10:02 <notdan> Is it the reverse arrow in the category of monads or something?
09:13:13 <startling> Cale, it could, with terminal control codes.
09:14:00 <startling> what is runTT other than (apparently) a furry musician?
09:14:49 <Cale> notdan: The functor (,) s is left adjoint to the functor (->) s. (i.e. functions (s,a) -> b correspond to functions a -> (s -> b)). The monad obtained from this adjunction is the state monad.
09:16:24 <startling> Is there any reason to use Rank2Types rather than RankNTypes?
09:17:02 <Cale> notdan: By composing the functors the other way around, you get a comonad.
09:17:08 <jmcarthur> startling: i think in theory there is but in practice there isn't
09:17:35 <Cale> Hugs compatibility
09:17:52 <Cale> (Is the reason to use Rank2Types rather than RankNTypes)
09:18:07 <startling> Oh. Rank2Types is older, I guess?
09:18:11 <jmcarthur> i thought that in theory you don't have to lose type inference with Rank2Types or something
09:18:13 <notdan> Cale: ((->) s) and (s,) functors?
09:18:18 <notdan> Yeah I guess so
09:18:20 <Cale> notdan: yeah
09:18:23 <jmcarthur> but in practice ghc doesn't do anything different anyway
09:18:28 <Polarina> When I do a Data.ByteString.readFile within a forkIO, that seems to lock up my whole runtime (other threads don't get run while it's reading the file). I've compiled with -threaded and set +RTS -N2, yet it's blocking. Is this intentional or am I doing something wrong?
09:18:40 <Cale> jmcarthur: Oh, that might be the case
09:19:08 <joe9> Cale startling I want to see the line "test line 1test line 2" followed by the line: "Cases: 257  Tried: 257  Errors: 0  Failures: 0"
09:19:16 <joe9> but, I cannot seem to get that.
09:19:28 <joe9> The Cases line overwrites the "test line.."
09:19:33 <joe9> does that make sense?
09:20:37 <Cale> joe9: How does it overwrite it?
09:21:18 <augur> the process calculus looks really interesting but also very arcane
09:21:34 <augur> i bet there's a nicer way of representing these processes syntactically
09:21:54 <Cale> joe9: You appear to be printing the Check Page Output line first, which is why it appears first.
09:22:11 <jmcarthur> i don't fully understand the semantics of Test.QuickCheck.Property, but i wish quickcheck had an operator   (===) :: (Eq a, Show a) => a -> a -> Property   or something like that which could show me both sides when reporting a failure so i don't have to copy-paste every time
09:22:13 <Cale> joe9: Output happens sequentially.
09:22:24 <notdan> Polarina: hm, that is weird, can you come up with a small example that has the problem?
09:22:26 <jmcarthur> s/copy-paste/copy-paste the inputs and reconstruct the output/
09:22:47 <startling> joe9: what makes you think things are being overwritten?
09:22:50 <Polarina> notdan, I'll code one right now.
09:23:48 <Cale> jmcarthur: Maybe you can use whenFail?
09:24:03 <Cale> hmm
09:24:26 <donri> or just printTestCase
09:24:39 <Cale> ah, yeah
09:24:51 <jmcarthur> ah
09:25:04 <jmcarthur> okay that looks useful
09:25:07 <jmcarthur> thanks!
09:25:12 <Cale> x === y = printTestCase (show x ++ " /= " ++ show y) (x == y)
09:25:47 <jmcarthur> yup
09:26:15 <donri> doesn't it include any Arbitrary argument itself? or is that the test frameworks...
09:26:37 <jmcarthur> donri: but i'm wanting to see the *results*, not just the inputs
09:27:04 <donri> jmcarthur: yes, but, at least for me the input is usually one of the sides of == :)
09:27:06 <jmcarthur> donri: e.g. if i'm testing associativity and see a failure, i want to see both sides of the equality test. i would end up recomputing them upon seeing that it failed anyway
09:27:07 <startling> I've had this annoyance with QuickCheck, too.
09:27:10 <donri> so it's redundant to show both in ===
09:27:11 <donri> for me.
09:27:25 <startling> donri, it's usually the case for me but not always.
09:27:28 <jmcarthur> donri: then it is fortunate that i chose associativity, since neither side is a single input
09:27:51 <donri> good points
09:28:20 <vraid> what's the syntax to access an index position of Data.Vector?
09:28:52 <quchen> vraid: (!) I think?
09:28:52 <donri> vraid: vec ! ix?
09:29:00 <vraid> oh, infix
09:29:07 <donri> or use !? to get a Maybe
09:29:16 <Cale> http://hackage.haskell.org/package/vector-0.10.9.1/docs/Data-Vector.html
09:29:37 <vraid> thanks, that did the trick
09:29:53 <vraid> i was doing ! vec ix
09:30:32 <lpaste> Polarina pasted “blocking in forkIO” at http://lpaste.net/94234
09:30:34 <joe9> Cale, startling : sorry for the delay in responding: http://codepad.org/5mok5C8t is the output. I want to the "Cases.." line to be printed after the output of the test, which is "test line 1."
09:30:38 <Polarina> notdan, there you go.
09:31:48 <startling> vraid: a nice thing about Data.Vector is that it makes your code look really exciting.
09:31:49 <Cale> joe9: Then why not print it after instead of before?
09:32:03 <Cale> joe9: Your code explicitly prints the things in that order
09:33:01 <joe9> Cale, it does not. The Cases output is being printed by the runTestTT.
09:33:13 <joe9> I have no control over when it is being printed.
09:33:14 <Cale> what?
09:33:31 <Cale>    liftIO $ putStrLn $ "\n\n" ++ sep ++ " Check Page Output " ++ sep
09:33:32 <Cale>    _      <- lift $ runTestTT . TestList $ [ checkLength output
09:33:32 <Cale>                                           , checkBytes  output ]
09:33:37 <Cale> that's from your code paste
09:33:50 <Cale> The Check Page Output line is before the runTestTT line
09:34:19 <Cale> and running the checkLength test is doing the "test line 1" etc. output
09:34:27 <startling> Even in Haskell sometimes code runs in the order you write it. :)
09:34:42 <joe9> cale: output: http://codepad.org/WN89qWig program: http://codepad.org/qbOJ21YX . Cale, I am not talking about the " Check Page Output". I am talking about the "Cases.." printed by runTestTT and the "test line 1" printed by checkLength function.
09:34:47 <joe9> I want the "test line 1  printed by checkLength function."
09:34:47 <joe9> I want the "test line 1  printed by checkLength function."
09:35:00 <joe9> sorry for the above 2 lines.
09:35:10 <Cale> oh
09:35:31 <joelmo> im doing something strange here, i want to count the maximum word in this list: https://gist.github.com/anonymous/f7c3e45c7f97c1846073
09:35:39 <Polarina> notdan, any ideas?
09:35:52 <startling> joe9: ah.
09:35:55 <notdan> Polarina: so I suspect it has something to do with STM, I am looking at it atm
09:36:52 <Polarina> notdan, I cannot imagine how STM would have anything to do with everything blocking while reading a file...
09:37:19 <joe9> the runTestTT is being printed to stderr and the "test line 1 " is being printed to stdout.
09:37:21 <startling> Polarina, what operating system are you on?
09:37:36 <Polarina> startling, Debian GNU/Linux 7.2, runnig GHC 7.6.3.
09:38:00 <startling> Could you repaste your code
09:38:03 <startling> ? I missed it.
09:38:17 <joe9> startling: code: http://codepad.org/uhw1WFRI
09:38:45 <startling> joe9, not you.
09:38:54 <Polarina> startling, http://lpaste.net/94234
09:39:03 <Cale> joelmo: Probably the fact that maxord cs max cur+1 means (maxord cs max cur) + 1
09:39:25 <Cale> joelmo: Function application binds tighter than any infix operator, regardless of spacing.
09:39:32 <Gracenotes> is STM good to use only for its orElse primitive?
09:39:45 <Cale> Gracenotes: no, it's also good for atomicity
09:39:49 <Gracenotes> I mean, well, i.e., to never read or write explicitly from TVars
09:40:01 <Gracenotes> and to have massive transactions, nested, behind orElse, for searching a tree in parallel
09:40:15 <Cale> wat
09:40:25 <Gracenotes> oh dear, a wat
09:40:38 <startling> Polarina: and what's your output and expected output?
09:41:00 <Cale> Gracenotes: I have no idea how that would perform, but I wouldn't expect it to run in parallel.
09:41:03 <joe9> Cale, any thoughts on my issue, please?
09:41:05 <startling> I think "atomically $ writeTVar var True " might be a weird thing, but I'm not 100% sure.
09:41:07 <Gracenotes> I mean, like parallel DFS, where every time you hit a node on a lazily created tree, you go orElse
09:41:28 <Cale> Gracenotes: orElse is a sort of sequential composition, which occurs when the first argument to it retries.
09:41:41 <Gracenotes> oh, right, yes.
09:41:45 <Polarina> startling, it starts by printing several lines of "main: file not yet read", then comes ">>! going to read file" and nothing happens for several seconds, then comes ">>! finished reading file" and spams of "main: file was read"
09:42:01 <Cale> joe9: Well, writing to stderr is what runTestTT is apparently supposed to do
09:42:01 <Gracenotes> I guess there isn't anything like that for STM.
09:42:13 <Cale> joe9: Is the problem that you want to write to stdout instead?
09:42:17 <Polarina> startling, what I expected is outputs such as "main: file not yet read" while it's reading the file.
09:42:18 <kuribas> I recently replaced ubuntu with linux mint, but there is no haskell-platform package...
09:42:20 <startling> Polarina, Data.ByteString.readFile is strict. Doesthat answer your question?
09:42:29 <joe9> Cale, yes.
09:42:37 <Gracenotes> For async, there's waitEither, but the involves mucking around with IO for what's otherwise a pure algorithm.
09:42:37 <Polarina> startling, of course it is strict. I want it that way. Just not to block other threads...
09:42:44 <Cale> runTestTT :: Test -> IO Counts
09:42:44 <Cale> runTestTT t = do (counts', 0) <- runTestText (putTextToHandle stderr True) t
09:42:44 <Cale>                  return counts'
09:42:56 <joe9> Cale, thanks.
09:43:26 <joe9> that helped.
09:43:26 <startling> Polarina, oh, you want, "main: file was read" between the "<<<<>>>>" guys.
09:43:57 <Polarina> startling, "main: file not yet read" because the thread doesn't set the TVar until after having read the file.
09:44:05 <Gracenotes> so, then, there's no way to have short-circuiting branching parallel code? (I suppose this is a do-X-to-do-Y-type question..)
09:44:20 <Gracenotes> *pure
09:44:30 <startling> Polarina: Right. Hm. And you're sure you're compiling with -threaded and running with the RTS thing?
09:44:41 <Cale> Gracenotes: Well, the trouble is that the result would in general be nondeterministic
09:45:31 <Cale> Well...
09:45:41 <Polarina> startling, positive. When I do +RTS -N2 -s and then Ctrl+C the program, it mentions parallel GC and things like that.
09:46:13 <Gracenotes> hm. I guess it's true that what I'm really looking for is a tag that tells me which thunk to look into, perhaps an implicit one.
09:46:21 <Cale> Yeah, if you want the *first* success to be computed, rather than the leftmost one in the tree or something, the result of such an operation isn't really pure
09:46:30 <Gracenotes> so isInWHNF is not exactly a pure thing...
09:46:39 <Gracenotes> or indeed remotely a safe thing
09:46:47 <Cale> hm
09:46:55 <Cale> I'm not sure if I can see why that helps
09:48:06 <epta> What monospace font spj uses in the presentation slides?
09:48:10 <Gracenotes> I guess Control.Concurrent.Async will do the trick. okay. It's a bit early, perhaps the ideas at the tip of my mind aren't so super.
09:49:05 <elliott> epta: comic sans mono? :)
09:49:16 <Gracenotes> (isInWHNF would be a way to tell "doneness", btw, which Async also has)
09:50:51 <startling> Polarina, it works for me as written.
09:51:04 <startling> with -threaded and +RTS -N2
09:51:14 <Polarina> startling, does it spam a lot between the >>! lines?
09:51:31 <lpaste> startling annotated “blocking in forkIO” with “blocking in forkIO (output)” at http://lpaste.net/94234#a94235
09:51:48 <startling> Polarina: just once, but I just used a 5MB file.
09:52:34 <notdan> Hm yeah it works for me on 700mb file with -N4
09:52:49 <Polarina> startling, try something larger. You should be getting 100 lines a second. I sometimes get one line in between there, that's probably a race condition between readFile finishing and the putStrLn's.
09:52:50 <notdan> But it only prints one line
09:53:06 <notdan> yeah that's what I thought
09:53:13 <notdan> it's weird, it should yield back
09:53:21 * hackagebot haskell-packages 0.2.3.1 - Haskell suite library for package management and integration with Cabal  http://hackage.haskell.org/package/haskell-packages-0.2.3.1 (RomanCheplyaka)
09:55:38 <startling> Polarina: you're right. No idea, sorry, and I'm about to leave for work.
09:55:54 <Polarina> startling, all right. Thanks for taking a look at it.
09:57:29 <startling> reproduced with -N4, too. Sorry i couldn't help more. It /does/ look like it should work.
09:57:37 <zugz> @pl \(a,b) -> (f a, f b)
09:57:40 <lambdabot> ap (flip ((.) . (,) . f) f . fst) snd
09:57:40 <lambdabot> optimization suspended, use @pl-resume to continue.
09:57:45 <zugz> anyone have a better solution to that?
09:57:45 <startling> :t over both
09:57:47 <lambdabot> (a -> b) -> (a, a) -> (b, b)
09:57:58 <startling> (warning: lens)
09:58:22 * hackagebot happstack-foundation 0.5.1 - Glue code for using Happstack with acid-state, web-routes, reform, and HSP  http://hackage.haskell.org/package/happstack-foundation-0.5.1 (JeremyShaw)
09:58:23 <edwardk_> :t join (***)
09:58:25 * hackagebot heist 0.13.0.2 - An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.13.0.2 (DougBeardsley)
09:58:25 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
09:59:11 <edwardk_> :t join bimap
09:59:12 <lambdabot> Bifunctor p => (a -> b) -> p a a -> p b b
10:00:08 <notdan> Polarina: I recommend you report this somewhere, maybe on reddit or on stackoverflow, because this looks like unwanted behaviour/bug to me
10:01:43 <zugz> edwardk_: thanks
10:01:44 <Polarina> notdan, oh, I've used neither of those two sites..
10:02:02 <startling> Polarina: one thought: looks like you used tabs? Maybe your indentation is misleading somewhere?
10:02:30 <Polarina> startling, tabs have never caused issues in my code before. But I can try.
10:02:38 <notdan> startling: I've rearranged the code to use spaces and it still doesn't work correctly :(
10:02:58 <notdan> You can see that by replacing readFile with threadDelay
10:02:58 * Polarina is a tab maniac.
10:03:48 <notdan> Polarina: I'll ask on stackoverflow
10:03:57 <startling> If I use threadDelay instead of readFile, I don't get the blocking behavior.
10:04:08 <notdan> now I am also very interrested why that code doesn't work :P
10:04:21 <startling> Me too. It's a shame I don't have more time. :(
10:04:23 <haasn> ‘Bifunctor p’ reads so weirdly
10:05:54 <Polarina> notdan, thanks.
10:12:30 <notdan> http://stackoverflow.com/questions/19347907/does-data-bytestring-readfile-block-all-threads
10:12:39 <notdan> not sure if the title is informative enough
10:13:43 <Polarina> :-)
10:16:32 <edwardk_> startling: re rank-2 types, hugs used to support Rank-2, but not Rank-N.
10:16:59 <edwardk_> startling: also there is in theory an inference algorithm for rank-2, but in theory not on for rank-n, so the former has a better theoretical grounding in some ways
10:19:19 <purplehz> hey what do i do when modifyIORef' is in scope?
10:19:24 <purplehz> isn't in scope*
10:19:59 <notdan> purplehz: import it?
10:20:07 <purplehz> but modifyIORef is in scope
10:20:09 <jmcarthur> purplehz: if you are using a recent enough ghc it will be in Data.IORef, i think. if it's an older ghc then it won't be there
10:20:17 <purplehz> i'm using ghc 7.4.1
10:20:21 <jmcarthur> purplehz: modifyIORef' is a fairly recent addition
10:20:29 <purplehz> more recent than 7.4.1?
10:20:29 <jmcarthur> purplehz: yeah i think you would been 7.6 for it
10:20:33 <jmcarthur> *need
10:20:33 <purplehz> hmm
10:20:46 <notdan> oh yeah, ghc 7.4 uses base 4.5 I think
10:20:48 <purplehz> how can i solve this then?
10:20:57 <notdan> which means no modifyIORef'
10:21:38 <deggis> copy implementation in your code? http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-IORef.html#modifyIORef%27
10:22:11 <deggis> or preferably update to ghc 7.6
10:23:26 <arianvp_> Cale. thank for the help
10:24:12 <arianvp_> Now I realize because cos x on [0,pi] is injective on the entire range [-1,1]  of cosine. thus it it is all the Equivalence classes of  cos a = cos b
10:24:18 <arianvp_> :)
10:25:59 <purplehz> how would i update to ghc 7.6?
10:26:02 <purplehz> i'm on ubuntu
10:28:24 * hackagebot happstack-authenticate 0.10.7 - Happstack Authentication Library  http://hackage.haskell.org/package/happstack-authenticate-0.10.7 (JeremyShaw)
10:28:25 * hackagebot happstack-jmacro 7.0.6 - Support for using JMacro with Happstack  http://hackage.haskell.org/package/happstack-jmacro-7.0.6 (JeremyShaw)
10:33:24 * hackagebot happstack-clientsession 7.2.6 - client-side session data  http://hackage.haskell.org/package/happstack-clientsession-7.2.6 (JeremyShaw)
10:44:07 <RommelVR> I have an [Int], I need [Int] -> [(Int, Int)] such that it represents all pairs in that [Int], then I need to check ((Int, Int) -> Bool), returning true if they are all true
10:45:21 <RommelVR> so uh... [Int] -> [(Int, Int)]       and a way to say all are true in a list (with short circuiting obviously)
10:45:38 <RommelVR> any ideas :S
10:46:29 <FireFly> @pl \f x -> f x x
10:46:29 <lambdabot> join
10:47:35 <scshunt> RommelVR: check l = all pred $ map (\[x, y] -> (x, y)) $ sequence [l, l]
10:47:58 <scshunt> or (all (pred . \[x, y] -> (x, y))) instead of also using a map
10:48:28 <RommelVR> right, I figured that part is not to bad
10:48:42 <RommelVR> honestly the harder question is getting [(Int, Int)] I thought
10:49:10 <Cale> all p [(x,y) | x <- xs, y <- xs]
10:49:11 <scshunt> which is what sequence is for
10:49:18 <scshunt> Cale: that's far too legible
10:49:22 <Cale> You could also just use a list comprehension :)
10:50:22 <stephenmac7> Is there any difference between this:
10:50:27 <RommelVR> so [a, b, c] -> [(a, b), (a, c), (b, c)]
10:50:32 <Cale> You can also do things like all p [(x,y) | (x:ys) <- tails xs, y <- ys]
10:50:36 <stephenmac7> pure (*5) <*> Just 6
10:50:40 <RommelVR> unique pairs*?
10:50:41 <stephenmac7> and (*5) <$> Just 6
10:50:58 <Cale> > [(x,y) | (x:ys) <- tails [1..4], y <- ys]
10:50:59 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
10:51:11 <stephenmac7> > pure (*5) <*> Just 6
10:51:12 <lambdabot>   Just 30
10:51:27 <stephenmac7> > (*5) <$> Just 6
10:51:28 <lambdabot>   Just 30
10:51:41 <RommelVR> Cale: tails?
10:51:48 <Cale> stephenmac7: not in a law-abiding instance of Applicative
10:52:05 <Cale> RommelVR: yeah
10:52:06 <stephenmac7> Cale: Then which is considered better style?
10:52:09 <Cale> > tails [1..10]
10:52:10 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,...
10:52:30 <Cale> stephenmac7: Probably using <$> is better.
10:52:37 <stephenmac7> Thanks
10:52:56 * stephenmac7 always wondered why he's never seen a channel with such good people
10:53:13 <Cale> stephenmac7: There is one difference, in that <$> only requires an instance of Functor, while <*> obviously requires Applicative
10:53:13 <RommelVR> stephenmac7: there all here lol
10:53:26 * hackagebot happstack-heist 7.2.0 - Support for using Heist templates in Happstack  http://hackage.haskell.org/package/happstack-heist-7.2.0 (JeremyShaw)
10:53:35 <Cale> RommelVR: tails is in Data.List
10:53:45 <RommelVR> cheers Cale, found it on Hoogle
10:54:02 <Cale> > [(x,y) | ys@(x:_) <- tails [1..4], y <- ys]
10:54:03 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(2,2),(2,3),(2,4),(3,3),(3,4),(4,4)]
10:54:22 <Cale> There's also that one you might want
10:54:37 <RommelVR> yeah no, but cheers :)
10:55:01 <scshunt> RommelVR: why not?
10:55:15 <scshunt> it does exactly what you want
10:55:15 <doriantje> ls
10:56:34 <RommelVR> scshunt: no, the first one he mentioned was what I was after, sec
10:56:46 <RommelVR> > [(x,y) | (x:ys) <- tails [1..4], y <- ys]
10:56:47 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
10:57:11 <scshunt> ah
10:57:16 <RommelVR> > [(x,y) | (x:ys) <- tails [(1, 1), (2, 2), (3, 3), (4, 4)], y <- ys]
10:57:17 <lambdabot>   [((1,1),(2,2)),((1,1),(3,3)),((1,1),(4,4)),((2,2),(3,3)),((2,2),(4,4)),((3,...
10:58:03 <RommelVR> thanks Cale, I'll have to decipher what is going on with the cons and tails, but shouldn't be to hard
10:58:13 <RommelVR> how would have sequence worked differently?
10:58:37 <Cale> sequence takes a list of lists and produces their Cartesian product
10:58:45 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
10:58:46 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
10:59:39 <Cale> More generally, given a list of actions in some monad, it runs each of them, producing a list of the results. In the list monad, "running" a list means picking an element from it in all possible ways.
10:59:56 <Cale> So it picks one element from each of the lists, in all possible ways.
11:01:40 <Cale> Another nice thing to be aware of is replicateM, which satisfies  replicateM n = sequence . replicate n
11:01:51 <Cale> > replicateM 3 [0,1]
11:01:52 <lambdabot>   [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
11:02:07 <Cale> > replicate 3 [0,1]
11:02:08 <lambdabot>   [[0,1],[0,1],[0,1]]
11:02:17 <Cale> > sequence [[0,1],[0,1],[0,1]]
11:02:18 <lambdabot>   [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
11:08:36 <Guest76066> Hey all, I am starting to learn haskell and I am looking at the learn you a haskell website. I saw this in the tutorial. boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]  I was curious why the part | x <- xs, odd x] makes it so you give it lists of numbers but if you remove that but keep the brackets, it will just take an integer as a parameter
11:10:00 <Guest76066> boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x] needs boomBangs [3] or [3..5] but boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!"] can only take boomBangs 3 (no lists)
11:10:13 <zielwasserjunki> You already reached list comprehensions?
11:10:27 <Guest76066> It's in the first chapter
11:10:45 <Guest76066> Oops, second chapter
11:10:48 <zomg> Guest76066: the first one is a list comprehension, the second without the | part is just running the if-then and making a list of the result
11:11:03 <Guest76066> ohhhh
11:11:04 <Guest76066> I see
11:11:41 <RommelVR> Cale: interesting
11:11:43 <Guest76066> That makes more sense. I was getting caught up with the outside brackets making the list comprehension, but they aren't. Thanks for that
11:11:59 <RommelVR> I think I need to properly define what algorithm I want to take first... haha :) cheers for the help
11:15:06 <Cale> Guest14513: Well, they're both part of the syntax of list comprehensions and part of the syntax of lists
11:16:05 <iamnone> Yeah. I am glad I came in here and asked. It makes more sense when you guys explain it
11:16:33 <Cale> iamnone: Feel free to stick around and ask any questions you might have
11:16:38 <iamnone> Thanks :)
11:16:51 <katesmith> hey mortberg
11:16:54 <katesmith> no
11:16:58 <katesmith> hey mortberg
11:17:05 <katesmith> no noth mortberg
11:17:08 <katesmith> i ment
11:17:28 <katesmith> hey Guest19450
11:18:25 <katesmith> Mortomes, you are in here too?
11:19:08 * katesmith shrugs
11:19:54 <RommelVR> hmmm, Cale: so I have [(x, y) | x <- [1 .. n], y <- [1 .. n]], I am trying to get all possible unique combinations of this :/, I was using replicateM n $ thatlist
11:20:15 <Cale> What do you mean by unique combinations?
11:20:23 <aristid> carter: shame that my haswell comes with TSX disabled:(
11:21:33 <Cale> RommelVR: Can you give an example of the list you want for n = 3?
11:21:49 <RommelVR> will do
11:23:28 * hackagebot clckwrks 0.19.1 - A secure, reliable content management system (CMS) and blogging platform  http://hackage.haskell.org/package/clckwrks-0.19.1 (JeremyShaw)
11:23:31 * hackagebot clckwrks-plugin-page 0.2.3 - support for CMS/Blogging in clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-page-0.2.3 (JeremyShaw)
11:23:32 * hackagebot clckwrks-plugin-ircbot 0.6.2 - ircbot plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-ircbot-0.6.2 (JeremyShaw)
11:23:34 * hackagebot clckwrks-plugin-bugs 0.6.2 - bug tracking plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-bugs-0.6.2 (JeremyShaw)
11:25:42 <RommelVR> [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)] -> [[(1,1), (1,2), (1,3)], [(1,1), (1,2), (2, 1)], [(1, 1), (1, 2), (2, 2)], ...]
11:26:25 <Cale> ah, all combinations of three distinct elements of that list?
11:26:40 <RommelVR> of n distinct elements
11:26:46 <Cale> okay
11:28:09 <Cale> pick 0 xs = [[]]; pick n xs = [(x:xs) | (x:ys) <- tails xs, xs <- pick (n-1) ys]
11:28:28 * hackagebot clckwrks-plugin-media 0.6.0 - media plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-media-0.6.0 (JeremyShaw)
11:28:31 * hackagebot clckwrks-cli 0.2.8 - a command-line interface for adminstrating some aspects of clckwrks  http://hackage.haskell.org/package/clckwrks-cli-0.2.8 (JeremyShaw)
11:28:33 * hackagebot clckwrks-dot-com 0.3.2 - clckwrks.com  http://hackage.haskell.org/package/clckwrks-dot-com-0.3.2 (JeremyShaw)
11:29:29 <Cale> > let pick 0 xs = [[]]; pick n xs = [(x:xs) | (x:ys) <- tails xs, xs <- pick (n-1) ys] in pick 3 [1..10]
11:29:31 <lambdabot>   [[1,2,3],[1,2,4],[1,2,5],[1,2,6],[1,2,7],[1,2,8],[1,2,9],[1,2,10],[1,3,4],[...
11:29:53 <hashcat> has anyone used eden compiler?
11:31:27 <RommelVR> Cale: your awesome
11:31:29 <RommelVR> lol
11:31:51 <RommelVR> I'm 99% sure that is what I was thinking of
11:31:51 <zebr> hi all. does anyone knows if GHC knows about De Morgan's laws? i.e. does it optimise (not (x || y)) to (x && y)?
11:32:10 <zebr> i'm assuming not, but you never know :p
11:32:12 <Cale> zebr: It shouldn't.
11:32:20 <zebr> how come?
11:32:41 <Cale> Different semantics
11:33:00 <zebr> oh, because of _|_?
11:33:03 <Cale> At least, I think
11:33:03 <Cale> yeah
11:33:09 <jmcarthur> zebr: in haskell, x and y might be computations that haven't been evaluated yet, so "optimizing" that might make the semantics different
11:33:16 <zebr> yeah, that makes sense.
11:33:21 <zebr> i'll have to do it by hand, then.
11:33:46 <jmcarthur> zebr: however, if x and y and known to be evaluated already there could be some optimization. i doubt there would be a core->core optimization that does it, but maybe the code generator would do it. the llvm backend most likely would do it if it's actually helpful.
11:33:50 <Cale> You can expect the difference in performance to be trivial
11:34:28 <zebr> mm, i suppose. i'm probably just micro-optimising.
11:34:54 <Cale> I would write the logical expression whichever way made the most sense to understand
11:35:48 <jmcarthur> > not (True || undefined)
11:35:49 <lambdabot>   False
11:35:54 <jmcarthur> > True && undefined
11:35:55 <lambdabot>   *Exception: Prelude.undefined
11:36:10 <Cale> not to mention that those expressions are not logically equivalent
11:36:24 <zebr> yeah, i made a mistake; i meant (not x && not y) i think :p
11:36:29 <Cale> right
11:36:35 <jmcarthur> @check \x y -> not (x || y) == (x && y)
11:36:43 <lambdabot>   mueval-core: Time limit exceeded
11:36:46 <jmcarthur> ugh
11:36:50 <Cale> hah
11:37:01 <Cale> @check \x y -> not (x || y) == (x && y)
11:37:01 <Cale> let's try again
11:37:02 <lambdabot>   *** Failed! Falsifiable (after 2 tests):
11:37:02 <lambdabot>  False
11:37:02 <lambdabot>  False
11:37:12 <Cale> @check \x y -> not (x || y) == (not x && not y)
11:37:15 <lambdabot>   +++ OK, passed 100 tests.
11:37:19 <zebr> there we go ;p
11:37:25 <Cale> 100 tests!
11:37:29 <Cale> lol
11:37:37 * jmcarthur suspects the semantics might not actually be different between those
11:37:56 <Cale> I didn't actually think too hard about it
11:39:33 <RommelVR> Cale: is there a 'dropUntil'?
11:39:48 <Cale> there used to be
11:41:03 <Cale> At least, I think. Maybe there was only takeUntil
11:41:52 <jmcarthur> @check \x y -> let not' = fmap not; x ||| y = x >>= \x' -> if x' then return True else y; x &&& y = x >>= \x' -> if x' then y else return False in not' (x ||| y) == (not' x &&& not' y)
11:41:53 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary.Arbitrary
11:41:53 <lambdabot>                     (f...
11:41:58 <jmcarthur> bah
11:42:06 <joelteon> RommelVR: dropWhile (not . f)
11:42:28 <jmcarthur> @check \x y -> let not' = fmap not; x ||| y = x >>= \x' -> if x' then return True else y; x &&& y = x >>= \x' -> if x' then y else return False in not' (x ||| y) == (not' x &&& not' (y :: Maybe Bool))
11:42:30 <lambdabot>   +++ OK, passed 100 tests.
11:42:34 <Cale> Oh, is that what's desired?
11:42:48 <RommelVR> cheers joelteon
11:42:52 <jmcarthur> from that it looks like a safe enough optimization
11:43:06 <Cale> There are a bunch of off-by-one variations which sometimes you want
11:43:26 <RommelVR> Cale: yeah, afaik I have this huge set of lists I know just want to ?iterate? until I find a solution that is correct
11:43:53 <enthropy> @pl \f -> dropWhile (not . f)
11:43:54 <lambdabot> dropWhile . (not .)
11:45:30 <Cale> takeUntil f would take one more element than takeWhile (not . f) if I recall correctly. It was probably removed because this is potentially confusing. But it's also sometimes exactly what you want.
11:45:55 <joelteon> That doesn't make sense
11:46:07 <Cale> (i.e. it would include the element which matched the predicate)
11:46:12 <Cale> (if there was one)
11:46:54 <RommelVR> Cale: could I not just do filter and only grab the first?
11:46:56 <RommelVR> now that I think about it
11:47:37 <Cale> Well, it depends on what you're trying to do, but yeah, if you're only looking for the first element satisfying a condition, you might try find.
11:47:39 <Cale> :t find
11:47:40 <lambdabot> (a -> Bool) -> [a] -> Maybe a
11:47:58 <Cale> Or of course, you can use filter
11:48:23 <Cale> You still ought to handle the case where there aren't any elements satisfying your condition in general
11:49:20 <RommelVR> Cale: was just about to ask that
11:49:27 <RommelVR> I guess that is where find is useful
11:50:00 <yogert> Hey all, I'm having difficulty finding or devising an EBNF  definition of algebraic expressions. I'm very inexperienced, and rather unfamiliar with parsing, so any help would be greatly appreciated. Here are my attempts so far:  http://lpaste.net/94244
11:56:17 <lpjhjdh> yogert: maybe take a look at operator precedence parsers, they're fairly simple so probably a good starting place.
11:56:45 <lpjhjdh> http://en.wikipedia.org/wiki/Operator-precedence_parser
11:58:39 <yogert> lpjhjdh: okay, ill check it out, thanks!
12:05:28 <Pranz> @pl \str -> (filter $ \word -> (isAnagram `on` mapHead toLower) str word && word /= str)
12:05:28 <lambdabot> filter . ap (ap . ((&&) .) . (isAnagram `on` mapHead toLower)) (/=)
12:05:42 <Pranz> :t ap
12:05:42 <lambdabot> Monad m => m (a -> b) -> m a -> m b
12:08:05 <FireFly> @ty isAnagram
12:08:06 <lambdabot> Not in scope: `isAnagram'
12:08:18 <FireFly> oh.
12:10:17 <ion> @remember edwardk at this point i get enough shit from people no matter what i do that i've kind of lost my sense of smell ;)
12:10:17 <lambdabot> I will never forget.
12:10:57 <RommelVR> Cale: so it works, I think, and basically instantly... much compared to my reference imperative solution (a few seconds at least)
12:11:05 <RommelVR> now just to get the result out to make sure :S
12:12:07 <RommelVR> on a side now, if you have a result, aka Just [Int], how can I get the [Int] alone?
12:12:49 <spaceships> RommelVR: fromMaybe, fromJust, maybe, and related functions (Data.Maybe)
12:13:10 <ion> Just [Int] is meaningless. Do you mean Maybe [Int]? You’ll have to choose what you want out of the two possible cases: Just xs and Nothing.
12:13:34 <spaceships> RommelVR: Or you can pattern match yourself
12:14:01 <RommelVR> yeah true, might just pattern match it myself, cheers spaceships  :)
12:15:20 <ion> Well, i’d suggest using one of the functions (not fromJust, though, it’s evil).
12:16:24 <Iceland_jack> RommelVR: What do you want if it's a Nothing rather than a (Just …)?
12:16:32 <Cale> RommelVR: yeah, you might use a case expression:  case ... of Nothing -> ...; Just x -> ...
12:16:36 <Iceland_jack> You rarely want to use fromJust
12:17:48 <enthropy> @type concat . maybeToList
12:17:49 <lambdabot> Maybe [a] -> [a]
12:18:35 <lpaste> bss03 pasted “Non-Exhaustive Pattern Match” at http://lpaste.net/94246
12:18:52 <lpaste> bss03 revised “Non-Exhaustive Pattern Match”: “No title” at http://lpaste.net/94246
12:19:52 <bss03> So, I'm trying to encode some type judgement rules in Haskell... looking through appendix A of the HoTT book.
12:20:09 <bss03> And I either get that ^^ non-exhaustive patterns warning or...
12:20:37 <lpaste> bss03 pasted “Impossible to reach code” at http://lpaste.net/94248
12:20:49 <Cale> The exhaustiveness checker sometimes reports spurious warnings
12:20:51 <bss03> An impossible to reach code warning ^^.
12:21:33 <RommelVR> hmmm, so I'm still new to this
12:21:37 <Cale> I wouldn't trust it to get things right once the types involved are sufficiently fancy
12:21:41 <bss03> So... should I just ignore them, or is there a way to write this so that I get neither warning.
12:22:30 <RommelVR> but basically I'm after         case solution of Nothing -> "No Solution"; Just solution -> ?
12:22:51 <Cale> ignore them
12:23:07 <RommelVR> where ? is me somehow then doing an IO on the [Int]
12:23:16 <bss03> RommelVR: case mSolution of { Nothing -> "No solution"; Just solution -> show solution; } ?
12:23:43 <Cale> RommelVR: All the branches of a case must have the same type. So if one of them is an IO action, all of them must be.
12:23:49 <RommelVR> what even is the type of that? :}|
12:23:52 <bss03> Your types have to match on each branch of the case.
12:24:01 <Cale> bss03's example has type String
12:24:01 <RommelVR> bss03: that can't be right/
12:24:07 <RommelVR> Oh right
12:24:28 <bss03> So, maybe do 'putStrLn "No Solution."' on the Nothing branch and some other IO () on the Just solution branch.
12:24:29 <RommelVR> I was thinking show was IO()
12:24:32 <Cale> also, you don't need a ; after the last branch
12:24:40 <Cale> ; is a separator, not a terminator in Haskell
12:25:36 <Cale> (but it'll be accepted anyway, you're allowed to have empty branches)
12:37:31 <Eduard_Munteanu> Let 'data Bin :: Nat -> Nat -> * -> * where Ball :: a -> Bin 1 1; Contains :: BoundedVec n (Bin k, a) -> Bin n k a;'. What do you call programs/algos that are concerned with filling such bins, given a number of balls? Generally, not a specific criteria.
12:37:55 <Eduard_Munteanu> s/Bin 1 1/Bin 1 1 a/
12:38:43 <RommelVR> Cale: one hopefully last question (for today anyway haha), I have a [t], and a smaller subset [t], for every value (from the first set) not in the sub set give me 0, else 1
12:39:01 <RommelVR> I'm having trouble formulating this :|
12:39:09 <RommelVR> (probably doesn't help its now 6:30am...)
12:39:20 <Eduard_Munteanu> For example, load-balancing connections, or on the contrary, fitting things in as few bins as possible.
12:39:41 <sie> I want to use FFT, but I don't understand the "dft" function's syntax. I'm puzzled about "=>" in func decl. and I would like to know where could I read about how that syntax works.
12:40:05 <Eduard_Munteanu> sie: link?
12:40:24 <sie> http://hackage.haskell.org/package/fft-0.1.7.2/docs/Math-FFT.html
12:41:27 <Eduard_Munteanu> sie: '=>' has typeclass constraints to the left and a type to the right (likely using the constrained type variables)
12:41:27 <Cale> RommelVR: Well, the inefficient way to do it (but with minimal assumptions about what type t is) is to use elem a bunch
12:42:04 <Cale> RommelVR: [if elem x ys then 1 else 0 | x <- xs] -- this is obviously O(n^2)
12:42:14 <Eduard_Munteanu> sie: but is there something in particular you don't understand about it, or do you find '=>' confusing generally?
12:42:38 <Eduard_Munteanu> it == that type of 'dft'.
12:42:41 <sie> No, I just didn't know that. But why are typeclass constraints needed?
12:42:57 <sie> Could one do without them?
12:43:29 <Eduard_Munteanu> sie: you probably want to take a look at LYAH's chapter on typeclasses or the Gentle Introduction if you prefer something more concise.
12:43:39 <RommelVR> :t elem
12:43:40 <lambdabot> Eq a => a -> [a] -> Bool
12:43:47 <sie> Eduard_Munteanu, Hmm, okay I will.
12:44:08 <Cale> RommelVR: let s = Set.fromList ys in [if Set.member x s then 1 else 0 | x <- xs]  -- this is O(n log n)
12:44:13 <Eduard_Munteanu> sie: you can do without them, but it makes life a lot more difficult :)
12:44:38 <Cale> You could also replace (if ... then 1 else 0) with fromEnum (...)
12:44:45 <RommelVR> Cale: technically your first solution was N*M, N*N
12:44:47 <RommelVR> right?
12:44:56 <RommelVR> (just making sure I understand)
12:45:12 <RommelVR> and the second, O(n log n)
12:45:15 <RommelVR> and the second, O(n log m)
12:45:37 <RommelVR> since length xs not guaranteed to be equal to length ys
12:45:39 <Cale> Yeah, it's O(N*M) which if N is the length of the larger list, is O(N^2)
12:45:54 <Cale> (is a subset of O(N^2))
12:46:15 <Cale> the second is O(m log m + n)
12:46:33 <Cale> which is again bounded above by n log n
12:47:01 <Cale> (I guess it's also bounded above by n log m)
12:47:08 <Eduard_Munteanu> sie: because for example, it's a lot more convenient when you can lump together types which support comparing their elements, and share functions like (<).
12:48:24 <Eduard_Munteanu> sie: instead of having to define and refer to a bunch of charLessThan, intLessThan etc.
12:48:33 * hackagebot snap-elm 0.1.0.1 - Serve Elm files through the Snap web framework.  http://hackage.haskell.org/package/snap-elm-0.1.0.1 (KyleCarter)
12:48:52 <RommelVR> in this case, I'll just do the N*M, its simple, and N*M is small enough in this case its not matter
12:50:44 <Eduard_Munteanu> sie: you still have to define a (<) but then any function refer to it and types which support an ordering. Such a function has a type like  Ord a => ... something that refers to a ...
12:50:53 <Cale> RommelVR: It'd also be a viable approach to sort both lists and walk down them simultaneously with a recursive function.
12:50:57 <Eduard_Munteanu> And the implementation just uses (<).
12:50:57 <heatsink> sie, or in other words, you can use function names based on the meaning of an operation rather than the implementation.  You just write (<) instead of passing around functions for intLessThan, floatLessThan or whatever.
12:51:12 <Cale> RommelVR: but writing explicit recursion is admitting defeat
12:51:16 <RommelVR> Cale: ordering matters :S
12:51:22 <Cale> ah, okay
12:52:02 <Cale> oh, right, also, I got the asymptotics a bit off there, it's O(m log m + n log m) indeed, which amounts to O(n log m) anyway
12:52:10 <Cale> (set lookup is log time)
12:54:35 <S_J> is there some property that must be true to be able to rewrite a function in points free style?
12:54:40 <S_J> http://stackoverflow.com/questions/19349423/rewrite-this-in-point-free-style
12:54:58 <S_J> stackoverflow question  about palindrome, if it can be rewritten points free
12:54:59 <S_J> ^^
12:55:02 <S_J> can it?
12:55:19 <quchen> You can rewrite anything to point-free style.
12:55:30 <Eduard_Munteanu> S_J: pointfree isn't something very formal
12:55:31 <S_J> if the argument is compared ot something that also contains itself, then hopw can it?
12:55:33 <quchen> @pl \x -> x == reverse x
12:55:34 <lambdabot> ap (==) reverse
12:55:40 <S_J> @src ap
12:55:41 <lambdabot> ap = liftM2 id
12:55:44 <S_J> hmm
12:55:51 <S_J> not wiser
12:55:54 <Cale> The monad instance for functions
12:55:55 <S_J> @src liftM2
12:55:55 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
12:55:57 <quchen> ap f g x = f x (g x)
12:56:10 <quchen> It's the (->) r Applicative/Monad instance.
12:56:20 <quchen> ap = S combinator from SKI calculus if that helps
12:56:23 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
12:56:24 <lambdabot>   ("hello","olleh","HELLO")
12:56:37 <Cale> You might be able to see from that how the monad operations help
12:57:42 <briennetheblue> > (==) <*> reverse $ "abcba"
12:57:44 <lambdabot>   True
12:58:18 <heatsink> @pl let {flatten node xs = node (: xs) (\l r -> flatten l (flatten r xs))} in flatten
12:58:18 <lambdabot> (line 1, column 5):
12:58:18 <lambdabot> unexpected "{"
12:58:19 <lambdabot> expecting "()", natural, identifier or "in"
12:58:30 <RommelVR> Cale: oh god I should sleep, but anyway (invested too much time in this now, I want to see ! :D https://gist.github.com/RommelVR/ea8499617840578e5be4)
12:58:33 <S_J> > let isPalindrome = ap (==) reverse in isPalindrome "dallassallad"
12:58:34 <lambdabot>   True
12:58:37 <S_J> > let isPalindrome = ap (==) reverse in isPalindrome "dallassallads"
12:58:38 <lambdabot>   False
12:58:45 <S_J> > let isPalindrome = ap (==) reverse in isPalindrome "smartarab"
12:58:46 <lambdabot>   False
12:58:49 <heatsink> @pl let flatten node xs = node (: xs) (\l r -> flatten l (flatten r xs)) in flatten
12:58:49 <lambdabot> fix (flip (ap . (. flip (:))) . ap ((.) . flip . ((.) .)) flip)
12:58:58 <Eduard_Munteanu> I guess I can rephrase my question more concretely... namely distributing work among a hierarchy of limited resources. For example distributing work among server farms, then among individual computers, then among CPUs within etc.. Any name for such problems? (again, not particularly load-balancing, other outcomes as well)
12:59:17 <heatsink> scheduling
12:59:22 <heatsink> resource allocation
12:59:40 <Eduard_Munteanu> Hm, "resource allocation" seems good.
12:59:49 <briennetheblue> @unpl (==) <*> reverse
12:59:49 <lambdabot> ((==) <*> reverse)
12:59:55 <Eduard_Munteanu> "scheduling" sounds a bit too timey.
12:59:57 <briennetheblue> er
13:01:16 <briennetheblue> @unpl ap (==) reverse
13:01:16 <lambdabot> ((==) >>= \ b -> reverse >>= \ a -> return (b a))
13:02:01 <Eduard_Munteanu> It doesn't quite capture the hierarchy aspect, though. :/
13:05:30 <heatsink> Are you contrasting something against alternative software?
13:07:27 <bss03> Eduard_Munteanu: Sounds like the "co-" version of tree-structured (non-uniform) parallelism.
13:08:10 <bss03> Eduard_Munteanu:  Instead of the tree being divisions of the problem, it's divisions of the solver.
13:19:44 <RommelVR> Cale: pretty sure I've got it done, just need to know, how would you split a list into n
13:20:17 <RommelVR> aka, split 3 [Int, Int, Int] == [[Int]]
13:20:28 <RommelVR> aka, split 3 [Int, Int, Int] == [[Int], [Int], [Int]]
13:20:51 <Cale> er
13:21:02 <ion> That syntax mixes value-level things with type-level things.
13:21:12 <heatsink> There isn't a conveniently dependenced library for chunking lists, though you can get it as part of Eden or HdpH
13:21:20 <heatsink> probably some other things
13:21:32 <Cale> Sure there is, split
13:21:36 <Cale> http://hackage.haskell.org/package/split
13:22:12 <Cale> Well, that may or may not include the function you're looking for
13:22:13 <heatsink> There's "split list into N pieces of arbitrary size" and "split list into arbitrary number of pieces of size N"
13:22:23 <Cale> right
13:22:28 <heatsink> I can't recall which one is in split
13:23:00 <Cale> The latter (as chunksOf)
13:23:50 <RommelVR> what might be easier, is if I could split a string up in n
13:27:13 <RommelVR> worst case I do something horrible like [y | _ <- [0 .. n], y <- [0 .. n]], then just add a "\n" every time y % n == 0?
13:28:06 <RommelVR> tldr, I (now) have a string N*N length, where I want to put a new line every N characters :|
13:30:19 <heatsink> you can split that with chunksOf n
13:32:48 <Cale> Or if you don't want to pull in the split library, chunksOf n = map (take n) . takeWhile (not . null) . iterate (drop n)
13:33:22 <Cale> and then apply unlines to that to add the newlines in between
13:41:33 <intrados> Is there a good way to encode associated data with an enumeration? For example: http://sprunge.us/UOMb
13:42:03 <carter> aristid: good thing you won't be able to use TSX in software for another year or so
13:44:04 <RommelVR> sigh, any help diagnosing this, I've misinterpreted something obvious :S https://gist.github.com/RommelVR/ea8499617840578e5be4
13:45:19 <apples> intrados, if you just need integer values like that, you could always derive Enum and use toEnum / fromEnum
13:46:30 <enthropy> RommelVR: i mod n == 0
13:46:48 <enthropy> that probably doesn't mean what you want it to
13:47:29 <briennetheblue> also you can use zipWith there, I think
13:47:38 <monochrom> make it i `mod` n == 0  or  mod i n == 0
13:47:44 <briennetheblue> :t zipWith
13:47:44 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
13:48:32 <intrados> apples: Thanks. Is the general strategy for that sort of thing then to use typeclasses?
13:50:55 <briennetheblue> zipWith fmtNewLine board [1..n*n]
13:51:00 <briennetheblue> once you've fixed fmtNewLine
13:51:01 <apples> intrados, for enumeration types? yeah
13:51:02 <S_J> > let f a b c = (f a, f b, f c) in f 1 2 3
13:51:03 <lambdabot>   Occurs check: cannot construct the infinite type:
13:51:03 <lambdabot>    t1 = t0 -> t0 -> (t1, ...
13:51:14 <S_J> > let triplify f a b c = (f a, f b, f c) in f 1 2 3
13:51:15 <lambdabot>   Could not deduce (Debug.SimpleReflect.Expr.FromExpr t)
13:51:16 <lambdabot>    arising from the ...
13:51:25 <S_J> > let triplify f a b c = (f a, f b, f c) in triplify (+1) 1 2 3
13:51:27 <lambdabot>   (2,3,4)
13:52:30 <aristid> carter: you mean in haskell software? surely i could use it from c++ just fine?
13:53:29 <Eduard_Munteanu> heatsink: no, I was writing some code to spawn a bunch of ssh tunnels and work around a crappy old sshd that doesn't like multiplexing more than 10 tunnels per connection.
13:53:35 * hackagebot comonad 4.0 - Comonads  http://hackage.haskell.org/package/comonad-4.0 (EdwardKmett)
13:53:50 <carter> aristid: you could, but you'd also have to write the concurrent fall back that uses locsk in C++ too
13:53:54 <Eduard_Munteanu> bss03: hmm... interesting.
13:53:57 <carter> now you have two problems!
13:54:17 <carter> the right way to expose HTM in haskell is to require you to provide an STM fall back too
13:54:29 <Eduard_Munteanu> heatsink: and I was wondering how to name some of that stuff
13:57:13 <aristid> carter: and that will ever get better? i suppose you refer to the problem that the tsx will just fail when it's too large and so on?
13:57:23 <carter> yeah
13:57:34 <carter> you always have to provide a fallback
13:57:50 <carter> aristid: oh you mean will haskell get that?
13:58:11 <aristid> carter: no i mean, will intel fix that in broadwell or whatever:D
13:58:19 <carter> aristid: ahh
13:58:25 <carter> the lack of tsx?
13:58:36 * hackagebot semigroupoids 4.0 - Semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-4.0 (EdwardKmett)
13:58:36 <aristid> carter: the limitations of tsx.
13:58:53 <carter> aristid: its call you have to provide a fall back
13:59:14 <carter> my understanding of tsx is that it merely gives you a safe way of saying "assume theres no contention, do this"
13:59:24 <carter> and you need to provide a fall back that is safe under contention
13:59:44 <aristid> carter: yeah i guess
14:00:32 <aristid> carter: other cool topic of the day: are you planning on putting some of your math load onto the gpu? :D
14:00:42 <carter> aristid: eventually yes
14:01:02 <carter> i've a road map towards that eventually
14:01:50 <pxqr> i'm trying to install lens-family-th-0.2.0.0 against template-haskell-2.7.0.0 and have "Bad interface file".
14:02:05 <pxqr> reinstalling template-haskell-2.7.0.0 doesn't help
14:02:13 <aristid> carter: using something like accelerate, or more low-level?
14:02:15 <edwardk_> never, ever reinstall template-haskell or you screw yourself ;)
14:02:38 <pxqr> edwardk_: why? :(
14:02:39 <carter> aristid: accelerate or repa would be good "toy" backends
14:02:47 <edwardk_> if you reinstall template-haskell it may even build, but anything that tries to use the wrong version of template-haskell for your compiler just won't work
14:03:02 <pxqr> ah
14:03:04 <aristid> carter: and for the real stuff you'd have to generate your own cuda/opencl?:D
14:03:27 <carter> aristid: for the real stuff i'd be like "does your hardware have a maintained LLVM backend"
14:03:31 <pxqr> seems like I need to reinstall platform then
14:03:35 <edwardk_> pxqr: and all sorts of bizarre looking errors show up in seemingly unrelated packages as a result. so make sure whatever you build you try to do it against the current version of template-haskell your compile shipped with
14:03:44 <aristid> carter: llvm has gpu support? oO
14:03:48 <carter> yup!
14:03:48 <edwardk_> pxqr: or nuke your .ghc folder and start over
14:03:55 <aristid> carter: woah
14:04:03 <pxqr> edwardk_: ok, I'll try
14:04:04 <edwardk_> aristid: yeah
14:04:10 <aristid> carter: oh nvcc actually uses llvm
14:04:16 <carter> yup
14:04:23 <edwardk_> pxqr: i have no idea about the state of lens-family template haskell support though.
14:04:41 <edwardk_> pxqr: you'll have to hit up roconnor for support
14:05:18 <pxqr> edwardk_: that's Dan Burton lib
14:05:19 <aristid> carter: so you'd just use llvm to generate e.g. ptx for the nvidia stuff?
14:05:29 <carter> yeah
14:05:36 <pxqr> roconnor have lens-family and lens-family-core
14:05:40 <carter> there'd be some per target pains
14:05:42 <aristid> carter: sounds rather cool.
14:05:52 <edwardk_> pxqr: well, dan wrote it originally, but afaik roconnor has the lens-family ecosystem. not sure if dan has thought about that thing since writing it initially.
14:05:53 <carter> but i think thats the only way to sanely support a wide range of targets
14:06:12 <aristid> carter: do you NEED to support a wide range of targets?
14:06:22 <carter> not until theres money behind it
14:06:22 <lpaste> pxqr pasted “Bad interface file” at http://lpaste.net/94251
14:06:32 <aristid> carter: i mean, just support something that is widely used and provides the required horsepower.
14:06:32 <carter> but having a story for supporting ati and nvida gpgpu would be cool
14:06:43 <edwardk_> carter: too bad the ati gpu story is so crippled
14:06:52 <aristid> edwardk_: how so?
14:06:53 <carter> i don't know enough to know
14:06:54 <carter> yet
14:07:01 <carter> oh yeah, the lack of recursion?
14:07:07 <carter> i thought newer stuff hasd some?
14:07:10 <carter> or is that OpenCL period?
14:08:29 <aristid> even for ATI you don't _have_ to use opencl, do you?
14:08:30 <edwardk_> aristid: the reason the bitcoin miners like the ati stuff is that the VLIW architecture they use works well for letting it calculate a bunch of hashes in parallel, but it is otherwise pretty weak compared to the nvidia arch. notably the stack is cripplingly small, which is why nvidia's CUDA has things like real recursion, function pointers, etc. and ATI has to stick to OpenCL, C99 sans recursion. it makes it very hard to structure
14:08:30 <edwardk_>  code that suits the ATI chipset
14:08:56 <edwardk_> aristid: they had their own thing. i don't remember what happened to it
14:08:57 <aristid> edwardk_: oh, but nvidia does suck for shas?
14:09:22 <edwardk_> aristid: yeah. for that application specific, no GPU task, nvidia is awful =)
14:09:47 <aristid> "no GPU task"?
14:09:49 <edwardk_> aristid: but then even ATI isn't the current story now that everyone has moved to custom hardware
14:09:55 <carter> https://github.com/llvm-mirror/llvm/tree/master/lib/Target/NVPTX
14:09:56 <aristid> right
14:10:06 <edwardk_> er "non GPU"  -- it has no graphics, and only uses integer operations
14:10:27 <aristid> edwardk_: but one thing my naive mind likes about AMD is how there are these new consoles and everything with the same fast memory for cpu and gpu
14:10:58 <carter> aristid: it does help AMD have some cashflow
14:11:01 <edwardk_> I wanted to like the AMD chips. I'm kinda saddened by them
14:11:19 <carter> how so?
14:11:21 <carter> no avx?
14:11:22 <aristid> carter: that's not what i mean. i mean i think that copying memory blobs around is stupid.
14:11:39 <carter> aristid: i think they also are slightly slower memory because of that'
14:12:03 <aristid> carter: because it's no longer 3 cm from the gpu?
14:12:44 <carter> relatedly lispy pointed out to me that the openCL 2.0 standard really pushes for stuff that would make shared ram btween cpu and gpu a bit more doable
14:13:05 <carter> like gpu's being able to address general memory
14:13:24 <aristid> apparently CUDA also supports using one pointer namespace between gpu and cpu but it's probably still a lot slower to use the host memory in the gpu
14:13:49 <carter> will be for a while
14:14:15 <aristid> carter: except in the ps4/xboxone/steambox kinda machine
14:14:19 <carter> yeah
14:14:35 <carter> but you already have a dev advantage there: you know exactly what the hardware is
14:14:48 <pxqr> hm, now I have "Bad interface file" even for aeson
14:15:14 <aristid> carter: if you can use the same memory, i imagine you'd be more willing to use gpu for database-scan kinda workloads for example
14:15:22 <carter> well
14:15:28 <carter> peple have doen that anyways
14:15:37 <carter> and on sufficiently pipelined stuff its a clear win
14:15:59 <aristid> carter: right but if it worked very well i'd surely have heard more about it?:D
14:16:15 <carter> aristid: how much do you like programming for gpus?
14:16:19 <carter> that won't change
14:16:39 <aristid> carter: well i've started doing the udacity cuda course yesterday so it's a bit early to say :D
14:18:37 * hackagebot profunctors 4.0 - Profunctors  http://hackage.haskell.org/package/profunctors-4.0 (EdwardKmett)
14:18:53 <carter> professional functors
14:20:18 <luite> ah tnx for uploading some new pkgs :)
14:20:26 <luite> hdiff updating again confirmed
14:23:36 <johnw> a working man's functor
14:24:38 <Gracenotes> luite: index.tar.gz ended up workin okay?
14:26:33 <luite> Gracenotes: yeah i had to rewrite the whole thing though, i first updated the bash scripts to work with hackage 2, but then i had a typo so they deleted themselves when run from the cron job (before i had backups), did a rewrite in haskell today
14:27:22 <luite> fortunately it's not that big :)
14:27:24 <Gracenotes> oh dear
14:27:43 <Gracenotes> well, bash scripts to haskell script is certainly a change
14:28:00 <luite> yeah the haskell thing is probably better and easier to maintain :)
14:28:06 <NemesisD> i could really use type holes right now
14:28:18 <Gracenotes> well, and the tar library is quite nice in Haskell (it is how the tarball is written out in the first place)
14:28:21 <luite> anyway i should probably get workin on a ghcjs release now
14:28:33 <luite> Gracenotes: ah i have to admit i just use some shell commands to run tar and git
14:28:54 <Gracenotes> sure :)
14:28:55 <luite> might update that later :)
14:28:59 <Gracenotes> strings, the starkest data structure
14:29:15 <luite> but this was easiest to get up and running quickly with the hackage1 hdiff scripts as reference
14:29:20 <luite> and it was broken for far too long already
14:29:50 <luite> but ghcjs is too now, still haven't updated it to the latest primops change... i should try to get a release ready in the coming weeks
14:30:00 <luite> found some bugs at icfp that i haven't committed a fix for yet
14:31:22 <Gracenotes> will the change improve ghcjs performance? it will, at least, make the compiler a bit more complex...
14:31:31 <NemesisD> have any of you guys used the operational package?
14:32:11 <luite> Gracenotes: what change? i think the only thing not yet updated is some prefetch ops
14:32:12 <carter> @hackage operational
14:32:12 <lambdabot> http://hackage.haskell.org/package/operational
14:32:21 <carter> luite: my fault :)
14:32:27 <carter> luite: but they're easy, they're noops!
14:32:46 <luite> Gracenotes: the older changes, like the Bool to Int# change required some work in the optimizer, to weed out the redundant conversions in JS
14:32:52 <luite> but that seems to work reliably now
14:32:59 <lpaste> NemesisD pasted “operational + http-streams” at http://lpaste.net/94252
14:33:02 <Gracenotes> ah, that is "old" now. heh, okay.
14:33:26 <NemesisD> i'm trying to write a little interpreter to mirror http-stream's request building DSL so i can later swap it out for a testing version
14:33:27 * Gracenotes has not yet updated...
14:33:53 <NemesisD> i can get the above code to compile but only with an undefined. i can't for the life of me figure out what to replace that undefined value with
14:33:55 <mantovani> NemesisD: Apache does it.
14:34:03 <luite> Gracenotes: still, the optimizer is a bit too slow, needs soem work
14:34:07 <mantovani> why rewrite ?
14:34:10 <NemesisD> mantovani: apache does what?
14:34:30 <mantovani> "mirror http-stream's request"
14:34:40 <luite> Gracenotes: probably the biplate traversals have to be replaced with handwritten ones, and some more caching of expression/statement dependencies is needed
14:35:22 <NemesisD> i don't understand what you're saying. i'm trying to make it so i can have an IO version of some monadic HTTP interactions, and then a pure version for testing that could record requests, fake out responses, etc
14:35:32 <NemesisD> i don't understand where apache comes in
14:35:51 <edwardk_> luite: i think i just need to turn on -fno-full-laziness in the Data.Data.Lens module to fix your occasional misses
14:35:53 <luite> Gracenotes: but i've you've used ghcjs a few months ago, before i committd the optimizer rewrite, it's already 5 times faster or so
14:35:56 <mantovani> NemesisD: I just read the line above.
14:36:09 <mantovani> 18:29 < mantovani> "mirror http-stream's request"
14:36:19 <NemesisD> oh ok
14:36:25 <NemesisD> yeah that was a bit misleading
14:36:27 <Gracenotes> awesome
14:36:31 <mantovani> :'(
14:36:40 <luite> edwardk_: oh, is that just something that changed in 7.7? i had to send stephen blackheath some fixes for sodium because full laziness was more agressive in 7.7, breaking some things
14:36:59 <NemesisD> johnw: i know you were recommending free monads for my problem, any idea what's going on with my operational code?
14:37:02 <edwardk_> yeah it rather horribly broke concurrent-supply
14:37:11 <NemesisD> it seemed like the easiest library to grok for me
14:37:25 <NemesisD> of the ones mentioned in that monads for free talk
14:38:37 * hackagebot profunctors 4.0.1 - Profunctors  http://hackage.haskell.org/package/profunctors-4.0.1 (EdwardKmett)
14:39:06 <luite> hm bleh i still haven't figured out whats wrong with my svm implementation
14:40:30 <Gracenotes> oh man, the first profunctors 4.0 just wasn't good enough
14:41:21 <johnw> NemesisD: I think I recommended the MonadHttp approach in your case
14:41:23 <lpaste> NemesisD annotated “operational + http-streams” with “operational + http-streams (annotation)” at http://lpaste.net/94252#a94253
14:41:39 <Gracenotes> luite: svm? are you using a constraint solver of sorts?
14:41:53 <NemesisD> johnw: i though that involved free monads and an interpreter. did it not?
14:41:56 <johnw> NemesisD: btw, yesod-test has a facility for doing tihs
14:42:11 <johnw> NemesisD: no, the MonadHttp approach is to just abstract the http-related calls
14:42:15 <carter> edwardk_: so the linear example gives  real world point for "gnd roles as they currently stands is hosed" ?
14:42:20 <luite> Gracenotes: no just an implementation of the smo algorithm, which updates two lagrange multipliers each step until it reaches the optimum
14:42:43 <edwardk_> well, it shows that they are REALLY conservative, which is what i've been saying all along
14:43:10 <NemesisD> johnw: im not sure yesod-test hits the correct side of the equation. i'm trying to test an http client library
14:43:11 <luite> Gracenotes: and some heuristics to select the multipliers reasonably efficiently in the inner loop
14:43:19 <johnw> NemesisD: ah, right
14:43:29 <edwardk_> simon is somehow under the impression that no code breaks with it except for a few modules
14:43:52 <edwardk_> right now 1/3rd of hackage doesn't build with 7.8, so we just aren't getting to the packages that _do_ have the problems ;)
14:44:03 <NemesisD> johnw: not sure i fuly grasp the method you're suggesting. i know someone sent me off to watch the free monads talk
14:44:16 <johnw> one sec
14:44:20 <luite> Gracenotes: i showed it at my ghcjs talk in nyc, but it was not bugfree. i hope to fix it so i can make some better web demo with ghcjs with that
14:44:46 <luite> since svm has a nice geometric intuition and you can make a fun applet to play with the algorithm
14:45:36 <carter> edwardk_: yeah, its a good thing bos is trying  out "lets build all of hackage"
14:47:00 <elliott> edwardk_: it seems like they're trying to avoid making roles more flexible because they'd be too instrusive
14:47:03 <elliott> *intrusive
14:47:07 <elliott> but afaict they have to be intrusive and already are anyway :P
14:47:17 <edwardk_> elliott: yeah
14:47:36 <edwardk_> it struck me that the problem might be simple at first too. now i think its hard
14:47:56 <johnw> NemesisD: I was thinking along these lines: https://gist.github.com/6967738
14:48:14 <elliott> edwardk_: it seems like this is the kind of thing you should add after you collapse the type/kind hierarchy
14:48:20 <johnw> now the behavior of "http" is decided by whether you call runHttp or runMockHttp
14:48:24 <elliott> rather than while it's kind of a mess
14:49:30 <carter> we should also figure out a way to add more solvers :)
14:50:41 <NemesisD> johnw: hmm ill chew on that a bit. the problem is thaat the http client library i'm targeting first doesn't like to expose the internals of request. it is built in a monad and no fields are exposed
14:50:44 <johnw> this is a "shallow" embedding, where you are parameterizing normal code on whether http is mocked or not; the operational approach is a "deep" embedding, where you turn the description of the problem into a runtime representation that you can afterward manipulate as you please.  I think that in this case, a deep embedding creates more problems than it solves for you
14:51:06 <johnw> NemesisD: make that monad a constraint on the MonadHttp type class then
14:51:16 <johnw> class MonadYourHttpClient m => MonadHttp m where
14:51:33 <NemesisD> johnw: the approach i was going to start taking was mirroring the DSL to create a request with operational. one evaluation of it would delegate to the library's request builder and make real http reqs
14:51:42 <johnw> sure, that will work
14:51:44 <NemesisD> the other would build up my own request object that i can freely peer into, fake out, etc
14:51:55 <johnw> actually, I've already started writing such a library
14:52:09 <johnw> a monadic/applicative request-object builder
14:52:36 <johnw> like I said, there's also one inside of yesod-test; and I think others have recreated it in other places too
14:52:51 <NemesisD> ah wait now im starting to understand. i could do class MyRequestBuilder m; instance MyRequestBuilder RequestBuilder; where setHeader = C.setHeader... etc
14:53:01 <johnw> and I know mgsloan is working on this concept also
14:53:12 <johnw> yes
14:53:17 <NemesisD> id love to take a look at either project you guys are working on if its upp
14:53:34 <johnw> sadly, the code I've written is presently a private project not ready for release
14:53:39 <NemesisD> i don't want to reinvent the wheel here
14:54:26 <johnw> my basic approach was to just make a State monad and uses lenses to let you manipulate the request object being built
14:54:49 <johnw> there's a few ways to shave this yak :)
14:55:25 <johnw> gotta run!
14:55:28 <NemesisD> i'm pretty sure the first time i shaved this yak i really butchered it, so i'm a bit gunshy
14:55:33 <NemesisD> johnw: thanks for your help!
14:57:06 <carter> NemesisD: use a machine gun
14:57:10 <carter> or a cannon instead
14:57:10 <kqr> is there some sort of quick explanation for how `join' can be the monoidal binary operator of a monad when it takes only one argument? it seems as though `m (m a)' is enough of a product to satisfy the requirement of being the argument to a binary operation, but i'm still not convinced
14:57:53 <NemesisD> if i aim carefully enough with that cannon this yak might yet get shaved
14:58:15 <bss03> kqr: I think join is not mappend so much as it is mconcat.
14:58:51 <carter> yes that
14:59:06 <kqr> is there a way to derive mappend from mconcat?
14:59:19 <kqr> or i guess mconcat on two elements
14:59:25 <bss03> mappend x y = mconcat [x, y]
14:59:39 <Eduard_Munteanu> kqr: do you know what monoid objects are (in a category)?
14:59:40 <elliott> mempty = mconcat []
15:00:17 <kqr> Eduard_Munteanu, i'm not very well versed with the theory. i'm just dabbling around
15:00:59 <bss03> mconcat's type doesn't quite match join's type because Monoids in haskell all have kind *, so mconcat uses a list (free monoid of kind * -> *) to be the "outer" monoid.
15:01:37 <Eduard_Munteanu> kqr: you can see maps  a |-> m (m a)  as building an M x M in the category of endofunctors. Then 'join' is the arrow M x M -> M that applies the monoid operation.
15:03:32 <kqr> interesting
15:03:36 <Eduard_Munteanu> kqr: and monads 'm' are monoid objects in the category of endofunctors.
15:03:51 <kqr> i'll have to think a little more about it
15:06:18 <johnw> join is concat in the category of endofunctors
15:06:50 <johnw> sorry, to be more precise: join is concat for the free monad, which is the free monoid in the category of endofunctors
15:07:01 <johnw> concat :: Functor f => Free f (Free f a) -> Free f a
15:07:02 <johnw> concat = join
15:07:15 <johnw> wait, that may be wrong, never mind
15:07:40 <Pranz> I always hear "category of endofunctors", as opposed to the category of functors?
15:07:46 <Pranz> or any broader category?
15:08:16 <Eduard_Munteanu> Pranz: there is a category of functors too
15:08:22 <Eduard_Munteanu> Pranz: but monads are endofunctors
15:08:25 <edwardk_> Pranz: every monad is an endofunctor, so including othr stuff in the category isn't relevant
15:08:38 <bss03> Pranz functors are more general than endofunctors.  a functor goes from a category C to a category D mapping objects and morphisms and preserving composition of morphisms.
15:09:20 <bss03> Pranz endofunctors map from category C to _the same category C_ mapping object and morpshims and preserving composition of morphisms.
15:09:30 <Jesin> hmm
15:09:40 <Pranz> yeah but when you say that "monads are monoids in the category of endofunctors", do you mean that they are equivalent to monoids in the category of functors?
15:09:43 <Cale> Yeah, an endofunctor is just a functor from a category to itself.
15:10:18 <Cale> Pranz: In order to understand that statement properly, you'll have to know what a monoidal category is, and what it means for an object to be a monoid object in a monoidal category.
15:10:52 <Pranz> a monoidal category is a category whose objects are monoids?
15:10:52 <bss03> Cale: So... is the category of functors not monoidal?
15:11:02 <Cale> Pranz: no
15:11:11 <Jesin> Any "instance Real a" is required to define "toRational :: a -> Rational  -- | the rational equivalent of its real argument with full precision"
15:11:14 <Cale> bss03: It is a monoidal category
15:11:47 <bss03> Jesin: Yeah, except some punt and "define" it to be a call to error.  Example: CReal.
15:11:59 <Cale> A monoidal category C is a category with a specified bifunctor on objects which is associative and has an identity (which is an object) up to isomorphism.
15:12:02 <Jesin> and then "Real" becomes a constraint for other
15:12:12 <Jesin> .. yeah, bss03, that's what I was going to ask about
15:12:40 <Cale> The category of endofunctors has such an operation on objects, namely composition of functors
15:12:42 <Jesin> it really shouldn't be placed where it is in the type hierarchy
15:12:54 <Cale> See http://en.wikipedia.org/wiki/Monoidal_category for the full proper definition
15:13:13 <Eduard_Munteanu> kqr: or consider the monad '(,) e'. Arrows are of the form a -> (e, b). Now if f :: a -> (e, b), g :: b -> (e, c), \x -> g (f x) :: a -> (e, (e, b)).
15:13:21 <bss03> Jesin: It's useful there, and a lot of the numeric classes are their for utility or history, not because they make good methematical sense.
15:13:39 * hackagebot comonad-transformers 4.0 - This package has been merged into comonad 4.0  http://hackage.haskell.org/package/comonad-transformers-4.0 (EdwardKmett)
15:13:41 * hackagebot comonads-fd 4.0 - This package has been merged into comonad 4.0  http://hackage.haskell.org/package/comonads-fd-4.0 (EdwardKmett)
15:13:43 * hackagebot groupoids 4.0 - This package has been absorbed into semigroupoids 4.0  http://hackage.haskell.org/package/groupoids-4.0 (EdwardKmett)
15:13:57 <Eduard_Munteanu> kqr: now join simply takes that (e, (e, b)) and does the e * e "multiplication" and gives you back an (e, b).
15:14:01 <Cale> (there are some coherence conditions to ensure that every diagram composed of associators and identity isomorphisms will commute)
15:14:20 <bss03> Jesin: I think there's even a haskell-for-maths project that replaces and extends the numeric typeclasses in ways that are morenatural when you think about numbers from maths.
15:14:44 <edwardk_> bss03: and the algebra package if you want to be even more anal retentive ;)
15:14:47 <Cale> The category of endofunctors is a strict monoidal category though -- composition of functors isn't just assocative up to isomorphism, but is properly associative
15:14:54 <Cale> and the identity functor is an honest identity
15:15:02 <Eduard_Munteanu> kqr: if you look at (e, (e, b)) as a string in a monoid, that is.
15:15:21 <Cale> (though the Identity newtype in Haskell only gives an identity up to isomorphism)
15:15:27 <johnw> Pranz: a monoid on values gives you i->a and a*a->a; monads give  you a->f a (f.f) a->f a.  It's the same monoidal algebraic structure (with the same laws), it's just happening to the functor instead of the value
15:15:50 <johnw> (where by i->a I mean () -> a, or just "a")
15:15:59 <Cale> Yeah, so once you have this monoidal structure on objects, you can use it to translate the laws for a monoid from the category of sets to an arbitrary monoidal category
15:16:39 <Jesin> bss03: I suppose there's no attempt to consider it as the new standard because backwards compatability, yes?
15:16:41 <johnw> Cale: what does a monoid in the category of natural transformations look like?
15:17:03 <bss03> Jesin: Float and Double have NaN and other non-mathy parts, so they often don't fit quite right in ... but are quite useful in practice, even if they are filled with traps for the unwary.
15:17:07 <adimit> question: when GHC complains that `State a` and `StateT a Identity` aren't unifiable, that means I'm using State that's not from the right libraries, no? (This is somewhere deep down a Parsec stack.)
15:17:09 <Cale> An ordinary monoid is a monoid object in the category of sets, which is made into a monoidal category using the Cartesian product of sets as the operation on objects, and the one element set as its identity up to isomorphism.
15:17:15 <Cale> johnw: Which category is that?
15:17:25 <johnw> Cale: funny, shachaf always asks me that question to
15:17:26 <Pranz> hmm yeah this still is confusing, but still I feel like I got a better grip on things now
15:17:47 <Cale> johnw: Do you mean the category of functors C -> C, with natural transformations between them?
15:17:47 <bss03> Jesin: Honestly, I don't follow the proposals for GHC / Haskell Prime very closely so it could be in the works and it just hasn't hit my news sources.
15:17:50 <johnw> Cale: where the objects are natural transformations, and the morphisms are natural transformation homorphisms?
15:17:53 <Eduard_Munteanu> johnw: well, I think functors and natural transformations aren't equivalent notions at different levels... natural transformations map specific functors, or more exactly their arrows.
15:17:59 <stephenmac7> What's the difference between mconcat and concat when operating on lists?
15:18:02 <Cale> johnw: What are natural transformation homomorphisms?
15:18:11 <stephenmac7> > mconcat [[1,2],[3,4]]
15:18:12 <lambdabot>   [1,2,3,4]
15:18:15 <stephenmac7> > concat [[1,2],[3,4]]
15:18:17 <lambdabot>   [1,2,3,4]
15:18:27 <johnw> hmm.. I guess that's why I didn't have an answer to my own question :)
15:18:39 * hackagebot semigroupoid-extras 4.0 - This package has been absorbed into semigroupoids 4.0  http://hackage.haskell.org/package/semigroupoid-extras-4.0 (EdwardKmett)
15:18:52 <bss03> stephenmac7: There isn't one.  mconcat has a more general type, but on lists it is the same as concat.
15:19:03 <stephenmac7> bss03: Then why have concat?
15:19:04 <kqr> stephenmac7, the difference between fmap and map
15:19:05 <Pranz> stephenmac7, there is no difference, list is a monoid with identity [] and operation (++)
15:19:14 <kqr> stephenmac7, or fmap and (.)
15:19:17 <bss03> stephenmac7: For operating on not-lists.
15:19:25 <Cale> http://en.wikipedia.org/wiki/Monoid_object
15:19:33 <Pranz> or (<<<) and (.)
15:19:35 <Cale> ^^ for the laws of a monoid object in an arbitrary monoidal category
15:19:38 <nbouscal> stephenmac7: I think we have concat as well to make the error messages easier to understand for people who don't know what Monoids are yet.
15:19:38 <stephenmac7> Meaning, why not drop map and concat?
15:19:40 <bss03> mconcat [const 5, const 7] undefiend
15:19:45 <Cale> You'll note that the laws look exactly like the laws for a monad
15:19:46 <bss03> > mconcat [const 5, const 7] undefiend
15:19:47 <lambdabot>   Not in scope: `undefiend'
15:19:47 <lambdabot>  Perhaps you meant `undefined' (imported from Pre...
15:19:53 <bss03> > mconcat [const 5, const 7] undefined
15:19:54 <lambdabot>   No instance for (Data.Monoid.Monoid a0)
15:19:54 <lambdabot>    arising from a use of `e_157'
15:19:55 <lambdabot>  T...
15:20:07 <bss03> > mconcat [const "foo", const "bat"] undefined
15:20:08 <lambdabot>   "foobat"
15:20:09 <kqr> nbouscal, bingo. also makes the code easier to read at times, since you get additional clues which instance you're working with
15:20:41 <johnw> maybe where the objects are nat. trans. like f :-> g, and the arrows are composition (g :-> h) -> (f :-> g) -> (f :-> h)?  I think that's just the Hom category for the category of functors?
15:20:42 <Jesin> :t mconcat
15:20:43 <lambdabot> Monoid a => [a] -> a
15:20:45 <stephenmac7> I see.
15:20:49 <stephenmac7> :t concat
15:20:50 <lambdabot> [[a]] -> [a]
15:20:55 <johnw> in which case the monoid would be FEndo
15:21:11 <johnw> (for natural transformation endomorphisms)
15:21:15 <bss03> stephenmac7: map and concat ear easier for.... introductory material.
15:21:32 <nbouscal> If learn you a haskell started off with fmap and mconcat I think a lot fewer people would read it :P
15:21:54 <bss03> stephenmac7: Also, type class constraints have non-zero overhead, so sometimes it's best to be explicit about what datatypes you are using.
15:21:58 <johnw> nbouscal: we can talk about fmap and mconcat, but fixed at lists for the first few chapters
15:22:17 <stephenmac7> nbouscal: It could be introduced just for lists
15:22:18 <Pranz> Cale, so, the category of sets is a monoidal category with the product of sets as operator and a set with one element as the ID-object?
15:22:25 <Cale> Pranz: yep
15:22:28 <stephenmac7> bss03: Makes sense
15:22:30 <stephenmac7> Thanks
15:22:45 <johnw> isn't the empty set the ID-object?
15:22:46 <Cale> Pranz: and if you interpret the laws of a monoid object in that monoidal category, you get the traditional idea of a monoid
15:22:50 <Cale> nope
15:22:55 <Eduard_Munteanu> johnw: if functors are "functions" between categories, natural transformations are more like pairs of (domain, codomain), I think
15:23:04 <Cale> It's the identity object for Cartesian product
15:23:07 <Cale> we're talking about
15:23:11 <johnw> ah
15:23:26 <Cale> i.e. in Haskell notation, ((),a) is isomorphic to a
15:23:28 <Eduard_Munteanu> So more like an |-> arrow.
15:23:30 <Cale> (vaguely)
15:23:39 * hackagebot profunctor-extras 4.0 - This package has been absorbed into profunctors 4.0  http://hackage.haskell.org/package/profunctor-extras-4.0 (EdwardKmett)
15:23:47 <johnw> that sounds monadic then, where return embeds an element in the singleton, and join performs a union on the product of two sets
15:23:50 <Cale> Of course, in Haskell, (,) is lifted, so that's not quite true
15:24:30 <Cale> Eduard_Munteanu: I'm not sure I understand that remark either :)
15:24:38 <Eduard_Munteanu> (By pair I meant something equivalent to (x, f(x)) vs f as a function)
15:24:50 <bss03> Haskell is not a theorem prover; all types all inhabited, all propositions are true.  If you ignore that though, equational reasoning works. :P
15:26:04 <bss03> Eduard_Munteanu: I think a set of such pairs is isomorphic to a function.
15:26:33 <bss03> Eduard_Munteanu: Same way that arrays are isomorphic to functions with a codomain of contiguous ranges of natural numbers.
15:26:34 <Eduard_Munteanu> Cale: I think I can rephrase it... a natural transformation is just an arrow in Fun(C, D), not an endofunctor on Fun(C, D).
15:26:49 <Eduard_Munteanu> bss03: yep, that's what I meant.
15:26:50 <Jesin> bss03: I seem to recall some sort of isomorphism between proofs in intuitionistic logic and programs...
15:27:04 <Cale> Eduard_Munteanu: yes
15:27:30 <Eduard_Munteanu> Cale: and it's not at all "just" a functor one level higher
15:27:40 <Cale> There is a category of arrows and commutative squares in Fun(C,D) (as there is in any category), which I guess we can think of as a category of natural transformations.
15:27:43 <bss03> Jesin: Yeah, but it only works when you don't have a value like "bottom" from the Haskell Report.
15:27:47 <Jesin> also, bss03, when you said "Haskell is not a theorem prover", what were you responding to or cautioning against?
15:27:49 <johnw> yay!
15:28:00 <johnw> Cale: is that category monoidal?
15:28:15 <Cale> no idea if it has anything nice about it
15:28:30 <bss03> Jesin: Cale's statement about ((), a) being isomorphic to a / and his statement about (,) being lifted in Haskell.
15:28:40 * hackagebot eq 4.0 - Leibnizian equality  http://hackage.haskell.org/package/eq-4.0 (EdwardKmett)
15:29:33 <bss03> Really edwardk_?  Stealing the really short, hopelessly ambigous package names?
15:29:35 <bss03> :P
15:29:49 <bss03> "eq"
15:29:49 <johnw> i wonder if "equality" was taken
15:30:13 <Maxdamantus> Is Haskell said to have a bottom value?
15:30:22 <Maxdamantus> or just things with bottom type?
15:30:31 <wagle> whats a less space consumptive way of doing "forM_ [1,3..((2^n)-1)] f" for n == 25 or so?
15:30:37 <Maxdamantus> Scala has an actual bottom value, called "None" or something.
15:30:45 <bss03> http://www.haskell.org/onlinereport/haskell2010/haskellch1.html#x6-120001.3
15:30:49 <bss03> Section 1.3
15:30:56 <bss03> Introduces the "bottom" value.
15:30:59 <Maxdamantus> actually, a lot of languages have "null", which works.
15:31:14 <edwardk_> bss03: i've had that one for a long time
15:31:24 <johnw> edwardk_: what do you use that package for?
15:31:24 <Eduard_Munteanu> wagle: I think that's not bad if you evaluate it the right way.
15:31:33 <quchen> Maxdamantus: ⊥ is more like the absence of a value.
15:31:43 <wagle> Eduard_Munteanu: I'm already running out of real memory
15:31:45 <edwardk_> johnw: it contains polykinded leibnizian equality
15:31:54 <Jesin> Maxdamantus: in Haskell it's usually called "undefined"
15:31:58 <Jesin> :t undefined
15:31:59 <lambdabot> a
15:32:05 <johnw> do you use that to allow type substitutions?
15:32:07 * heatsink does a double take
15:32:08 <Maxdamantus> yeah, and that report doesn't mention bottom being a value.
15:32:17 <heatsink>  leibnizian looks a lot like another word.
15:32:29 <briennetheblue> i'm going to nab all the one letter ones
15:32:48 <Jesin> "Errors in Haskell are semantically equivalent to ⊥ (“bottom”). Technically, they are indistinguishable from nontermination, so the language includes no mechanism for detecting or acting upon errors."
15:32:49 <Maxdamantus> > fix id
15:32:50 <Eduard_Munteanu> wagle: consider making a [(2, 1), (4, 3)  .. (2^n, 2^n - 1)] list and foldl'-ing it.
15:32:56 <lambdabot>   mueval-core: Time limit exceeded
15:33:01 <quchen> Maxdamantus: There isn't a bottom value you can do anything with. In general you can't decide whether something is bottom because that's equivalent to solving the halting problem. ⊥ is easy to create, but not so easy to check.
15:33:01 <Pranz> Okay, if i understand this correctly
15:33:06 <Maxdamantus> Another bottom, without a special case.
15:33:18 <Maxdamantus> (assuming `undefined` and `error` are special)
15:33:32 <edwardk_> johnw: mostly
15:33:35 <elliott> Jesin: that second sentence is a lie
15:33:36 <Pranz> in the category of endofunctors, composition of endofunctors is the monoidal multiplication
15:33:40 * hackagebot free 4.0 - Monads for free  http://hackage.haskell.org/package/free-4.0 (EdwardKmett)
15:33:45 <elliott> well depends on how you define "the language" I guess :)
15:33:46 <edwardk_> johnw: we've merged something similar into 7.8 as Data.Type.Equality
15:33:47 <Eduard_Munteanu> wagle: if you rewrite that as an 'iterate' you avoid recomputing 2^k every time.
15:33:48 <bss03> Maxdamantus: "throw" also needs to be special.
15:33:53 <Jesin> heatsink: I don't think this has much to do with Greek islands.
15:33:58 <edwardk_> johnw: but that one uses actual (~) rather than Leibniz.
15:34:07 <bss03> Although, I suppose that's GHC-specific.
15:34:15 <edwardk_> i keep the package around as a reference for leibnizian equality, as it is much nicer than the equivalent i have in scala =)
15:34:35 <Pranz> so m (m a) is like (m, m) a
15:34:48 <Jesin> elliott: when an error occurs in a haskell program, it is not distinguishable from nonterminiation *inside the program*
15:35:36 <bss03> Jesin: except, it is in GHC... catch
15:35:38 <quchen> Not sure what you mean by "error". If you throw an error you can catch it inside the program.
15:35:56 <Jesin> ...
15:35:59 <elliott> Jesin: main = do { x <- try (error "foo") :: Either SomeException (); print x }
15:35:59 <Jesin> Huh.
15:36:05 <Jesin> I'm not familiar with "catch"
15:36:10 <johnw> Pranz: exactly
15:36:17 <Jesin> :t try
15:36:18 <lambdabot> Exception e => IO a -> IO (Either e a)
15:36:19 <elliott> Jesin: main = do { x <- try (let f !n = f (n+1) in f 0) :: Either SomeException (); print x }
15:36:27 <Pranz> still feels like something is missing though
15:36:37 <elliott> it is true that those two are denotationally equal, which is a bit iffy
15:36:43 <johnw> Pranz: but not just compsition, because you want (f . f) -> f, not just (f . f) a -> (f (f a))
15:36:46 <elliott> in a sense IO breaks semantics
15:36:47 <wagle> Eduard_Munteanu: I ran all night in swap, and didnt succeed, so trying to prune down space usage
15:37:02 <Jesin> > do { x <- try (error "foo") :: Either SomeException (); print x }
15:37:03 <lambdabot>   Couldn't match expected type `Data.Either.Either
15:37:04 <lambdabot>                           ...
15:37:52 <bss03> Jesin: catch and ioError are from the 2010 report.  GHC also has throw, which is like ioError except it doesn't "live in the IO monad" so you can use it in "pure" code.
15:38:00 <wagle> Eduard_Munteanu: its an assignment with a dataset tuned to prune out naive solutions like mine..  8) 8/
15:38:27 <Jesin> bss03: that's really strange.  Is there a LANGUAGE pragma for that?
15:38:40 * hackagebot parsers 0.10 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.10 (EdwardKmett)
15:38:59 <bss03> Jesin: No, but you have to use a non-standard module.
15:39:05 <Jesin> okay...
15:39:13 <Jesin> is the module implemented in Haskell?
15:39:30 <briennetheblue> :t throw
15:39:33 <lambdabot> Exception e => e -> a
15:39:52 <elliott> I think the H2010 catch might not catch "error" exceptions.
15:39:59 <bss03> Jesin: It's implemented in GHC Haskell.  Like it uses modules from the GHC.* namespace which only work on GHC, not on any Haskell.
15:40:04 <Jesin> elliott: I hope not
15:40:12 <bss03> Jesin: (like, e.g., Ajhc)
15:40:16 <Jesin> if it did, they'd have a self-contradiction
15:40:17 <elliott> I don't see the point in that hope :)
15:40:28 <elliott> well, nobody expects computers to make any sense.
15:40:34 <quchen> elliott: I think it does, it's the ErrorCall type.
15:40:36 <Jesin> bss03: right, that makes sense.
15:40:40 <elliott> identifying all _|_s works for reasoning about pure code.
15:41:00 <Jesin> ^ yes that
15:41:02 <elliott> and you can give an almost-semantics by just saying that what catch does is nondeterministic.
15:41:05 <bss03> elliott: Yeah, I think if you watch to catch them you have to use userError instead of error and "live in the IO monad".
15:41:14 <elliott> AFAIK, nobody has a semantics for IO other than "everything is nondeterministic"
15:41:21 <edwardk_> elliott: *cough*
15:41:30 <quchen> Sequential maybe?
15:41:35 <Jesin> hi edwardk_
15:41:36 <elliott> which is almost useless, and we rely on a lot more than that all the time, but :P
15:41:50 <elliott> edwardk_: uh oh, what happened now?
15:41:51 <bss03> elliott: I think there's a few better models, but none that I felt were fully complete.
15:42:14 <edwardk_> @google Free Monads for Less Yielding IO
15:42:16 <lambdabot> http://comonad.com/reader/2011/free-monads-for-less-3/
15:42:17 <lambdabot> Title: The Comonad.Reader » Free Monads for Less (Part 3 of 3): Yielding IO
15:42:28 <bss03> elliott: Also, in GHC IO have stuff like forkIO and forkProcess which are *meant* to be non-deterministic.
15:43:02 <edwardk_> that keeps the semantics of the host language perfectly deterministic and pure
15:43:14 <elliott> edwardk_: oh, I agree
15:43:27 <edwardk_> its the evil nasty RTS that is asking the pretty host language for things that might go off and do things non-deterministically
15:43:33 <elliott> edwardk_: but if you add something like catch to your "FFI", you just have to say it works nondeterministically.
15:43:44 <elliott> despite the fact that we know more about it in reality than that implies.
15:43:44 <Jesin> hmm, what is {-# LANGUAGE Trustworthy #-} by the way?
15:43:51 <elliott> (I do like your IO formulation)
15:44:17 <edwardk_> i have catch in the FFI, but you basically have to agree to only catch exceptions that will always happen the same way if its reinvoked. like arg format exceptions for parseInt in java or whatnot
15:44:21 <edwardk_> =)
15:44:23 <bss03> edwardk_: Isn't similar to the way Idris handle the IO monad.  Basically a free monad over FFI calls, yeah?
15:44:48 <wagle> @src foldl'
15:44:49 <lambdabot> foldl' f a []     = a
15:44:49 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:44:59 <bss03> Jesin: I think LANGUAGE Trustworthy is some interaction with safe haskell.
15:45:12 <Cale> bss03: In any case, that's the right way to think of it. The implementation in GHC cheats and uses impure functions.
15:45:17 <Jesin> I just found some documentation http://www.haskell.org/ghc/docs/latest/html/users_guide/safe-haskell.html
15:45:41 <elliott> edwardk_: so you don't have async exceptions that you can catch in your language?
15:45:54 <Cale> But you can imagine that IO is implemented as a free monad internally instead
15:45:56 <edwardk_> bss03: probably. not sure when idris started doing that
15:46:35 <edwardk_> elliott: we have an explicit bottom thunk type that percolates up through pattern matches and what not
15:46:50 <edwardk_> elliott: i don't think we ever implemented a 'catch' for it in general though
15:47:50 <bss03> https://github.com/idris-lang/Idris-dev/blob/master/lib/IO.idr -- my bad, seems like it's still a State #RealWorld type construction... I think.
15:48:21 <elliott> edwardk_: mainly I'm just saying that we'd like to say (error "x") and (let x = x in x) are the same. if we do this then try (evaluate (error "x")) and try (evaluate (let x = x in x)) have to be the same, but in practice when we execute them they are always different
15:48:31 <edwardk_> sure
15:48:36 <elliott> so we just have to say the semantics is that it either doesn't halt or gives any possible execption value in the world
15:48:43 <elliott> which works but is a lot less precise than reality :P
15:48:57 <edwardk_> we also have problems where we freely allow ghc to pick the order to force things when thy are strict, so you need them to be 'the same' in some sense
15:49:01 <edwardk_> or you cripple the optimizer
15:50:05 <Cale> elliott: I'm sure that it's possible to concoct a proper semantics for error calls at least.
15:50:31 <Cale> (it'd necessarily be a nondeterministic one, you'd end up with a set of possible errors attached to each bottom)
15:51:15 <Eduard_Munteanu> wagle: what are you doing with the list?
15:51:40 <Eduard_Munteanu> > let f = (2 *) . fst in foldl1' (seq . fst) . take 5 . iterate (f &&& (subtract 1) . f) $ (1, 0)  -- wagle: this is one way to make going through it better
15:51:42 <lambdabot>   (16,15)
15:52:00 <Cale> (but only because we don't want to say what the evaluation order is, if we picked lazy evaluation, then it could be deterministic)
15:52:14 <Eduard_Munteanu> > let f = (2 *) . fst in foldl1' (seq . fst) . take 25 . iterate (f &&& (subtract 1) . f) $ (1, 0)
15:52:16 <lambdabot>   (16777216,16777215)
15:52:27 <elliott> Cale: sure, but then we don't get to consider every _|_ the same for reasoning about pure code :)
15:52:30 <wagle> using it to solve TSP
15:52:36 <elliott> which is so convenient that it's annoying to give it up just for IO practicalities.
15:52:56 <Cale> Well, we *almost* do
15:53:25 <Cale> You'd just be annotating the _|_'s with sets of exceptions, and unioning those sets in certain cases.
15:55:28 <heatsink> I found out that you can get good loop fusion of concatMap using a stream data type NStream a = Flat (Stream a) | Concat (Stream (NStream a))
15:56:01 <heatsink> it requires inlining recursive functions, which GHC doesn't want to do
15:56:32 <Cale> Well, perhaps you'd need to explicitly have an element for nonterminating _|_ as well as the possible exceptions. I was initially thinking that could be represented using the empty set, but that's not true.
15:56:42 <Eduard_Munteanu> BTW, what are some reasons to talk about monoidal categories instead of monoid objects? AFAICT they are equivalent or can be translated either way.
15:56:56 <Cale> Eduard_Munteanu: they are not equivalent
15:57:06 <Eduard_Munteanu> Hm, let me think.
15:57:10 <Cale> Eduard_Munteanu: Monoid objects live in monoidal categories.
15:57:25 <Cale> You need the concept of a monoidal category in order to define monoid objects in the first place.
15:57:42 <Eduard_Munteanu> Oh monoid objects need associativity on the nose I think.
15:57:50 <Eduard_Munteanu> Cale: er, you do?
15:57:54 <Cale> yes
15:58:06 <Cale> http://en.wikipedia.org/wiki/Monoid_(category_theory)
15:58:12 <Cale> See the (x) and I?
15:58:19 <Cale> Those are the monoidal category structure
15:58:23 <Eduard_Munteanu> Cale: or do you mean *all* monoid objects imply a monoidal category?
15:58:42 * hackagebot bound 0.9.1 - Making de Bruijn Succ Less  http://hackage.haskell.org/package/bound-0.9.1 (EdwardKmett)
15:58:53 <Cale> hm?
15:59:06 <Cale> I mean it doesn't make sense to talk about monoid objects in a category which is not a monoidal category.
15:59:33 <Eduard_Munteanu> Cale: well, just like a category can have some (but not all) products, it can have some monoids, no?
15:59:58 <Cale> uh, not without a monoidal category structure on it, it can't.
16:00:00 <Eduard_Munteanu> Cale: actually Awodey introduces monoid objects before monoidal categories, I think.
16:00:09 <Cale> No way...
16:00:13 <Cale> http://en.wikipedia.org/wiki/Monoid_(category_theory)
16:00:15 <Cale> look there
16:00:38 <Cale> Note that it's defining a monoid object (M, mu, eta) in a monoidal category (C, (x), I)
16:00:39 <elliott> I don't understand what "all monoids" would be
16:00:57 <Cale> It doesn't define a monoid object in an arbitrary category, because that doesn't make sense.
16:01:11 <Eduard_Munteanu> Cale: a monoid object in C is an object 'm' of C along with arrows id :: m -> m and (*) :: m x m -> m such that ...
16:01:11 <Cale> You need to use the (x) and I in the definition of a monoid object.
16:01:20 <Eduard_Munteanu> Hm.
16:01:23 <Cale> Ah, that's in a category with products?
16:01:32 <Eduard_Munteanu> Cale: yes, or some products at least.
16:02:23 <Eduard_Munteanu> Though Awodey's monoids are strictly associative, IIRC.
16:02:35 <Cale> Well, if you have products, then you can define a monoidal category structure. I suppose there's a finer point about maybe not needing all products.
16:04:55 <Eduard_Munteanu> Cale: hm... I think there's another thing too: the tensor product might not be the product itself, right?
16:05:12 <Pranz> Eduard_Munteanu, yeah
16:05:37 <Cale> But for instance, in the category of vector spaces over some field F, you have a monoidal structure taking the tensor product of vector spaces, which has F (viewed as a vector space over itself) as an identity. A monoid object in that category is an algebra (a vector space which is also a ring in a way that's compatible with the vector space addition and scalar multiplication).
16:05:42 <Pranz> Eduard_Munteanu, monoidal objects can only reside in a monoidal category because the tensor product need to be defined
16:05:43 <Eduard_Munteanu> Even a CCC can have a bunch of different monoidal structures I think.
16:05:54 <Cale> yes
16:06:10 <luite> hmm, anyone seen this error? i've fixed a similar one before, but forgot how:
16:06:14 <luite>     Can't find interface-file declaration for variable Language.Javascript.JMacro.QQ.expr2ident
16:06:17 <luite>       Probable cause: bug in .hi-boot file, or inconsistent .hi file
16:06:29 <Cale> luite: Does it persist if you delete the .hi?
16:06:32 <luite> yeah
16:06:35 <Eduard_Munteanu> Well, I was trying to argue monoidal structure is more general than monoid objects.
16:06:54 <Cale> Oh, well, it is
16:07:12 <Cale> You ought to be able to have a monoidal category with no monoid objects in it, even.
16:08:10 <Eduard_Munteanu> But why aren't monoidal structures isomorphic to products, though?
16:08:27 <Cale> Well, the tensor product of vector spaces isn't the categorical product
16:08:48 <Eduard_Munteanu> The product UMP and associativity up to isomorphism pretty much give you a tensor for each choice of a product, no?
16:08:56 <Cale> (it multiplies dimension rather than adding)
16:09:19 <Cale> Yeah, if you have products, you can always use those to get a monoidal category structure.
16:09:25 <Cale> (and a terminal object)
16:09:33 <purplehz> hey i can't seem to get pointerPosition from the glut package to work
16:09:41 <purplehz> does anybody have any idea what i'm doing wrong?
16:09:55 <xpika> is it possible to use ghc -e with imports. I want to do something like ghc -e "splitOn \"x\" \"axbxc\""
16:10:00 <Eduard_Munteanu> Cale: I think there's no "*the* product" either, it's just we pick the most natural product.
16:10:17 <Cale> Eduard_Munteanu: Products are unique up to isomorphism
16:10:29 <Cale> (up to unique isomorphism, even)
16:10:47 <Cale> Er, I should say canonical rather
16:11:02 <Eduard_Munteanu> Cale: yes, but you may pick different ones, they should just map uniquely to the natural one.
16:11:13 <Cale> There's a unique isomorphism which is given to you in each direction by the universal mapping property
16:11:39 <Cale> There might not be a natural one, but we still tend to say "the product", because of this uniqueness up to canonical isomorphism.
16:11:50 <Cale> All the products are "the same"
16:12:15 <Eduard_Munteanu> Cale: oh, I think I see... tensor products aren't required to map uniquely up to isomorphism.
16:12:29 <Cale> Tensor products are not products :)
16:12:45 <Cale> (tensor products of vector spaces, anyway)
16:13:00 <Eduard_Munteanu> Cale: well, yeah, I was trying to see what was different, because arguably in all other aspects they seem very similar.
16:13:19 <Cale> If we take, for instance, R^2 and R^3. Their product is isomorphic to R^5, while their tensor product is isomorphic to R^6
16:13:35 <Eduard_Munteanu> Hm, yeah.
16:14:53 <Pranz> hmm
16:15:23 <Eduard_Munteanu> Cale: the coherence conditions seem to reach for the same thing as the conditions for product projections. Just avoiding the UMP.
16:16:04 <Cale> The coherence conditions are just trying to ensure that every diagram composed entirely of rho, lambda, and alpha will commute.
16:16:18 <Pranz> so a monoidal category of sets with addition of sets as the tensory product is valid
16:16:23 <Eduard_Munteanu> Mm, I thought that was discovered after the fact. :)
16:16:36 <Cale> Well, in general, that's what coherence conditions are for
16:16:39 <Pranz> but I'm having trouble thinking about monoidal objects in this category
16:17:13 <Pranz> can't any object be a monoid in this category with id as monoidal multiplication?
16:17:33 <Cale> Pranz: which one? The category of vector spaces?
16:17:46 <Pranz> the category of sets with addition of sets
16:17:50 <Pranz> as tensory product
16:18:05 <lpaste> wagle pasted “why the type error when used?” at http://lpaste.net/94254
16:18:12 <Eduard_Munteanu> Actually hm... is there such a thing as comonoidal category?
16:18:26 <Pranz> and the empty set as the identity object
16:18:47 * hackagebot pointed 4.0 - Pointed and copointed data  http://hackage.haskell.org/package/pointed-4.0 (EdwardKmett)
16:18:58 <Pranz> or
16:19:05 <Cale> Eduard_Munteanu: There should be, but they're much less popular.
16:19:05 <Pranz> can there even be any monoidal object?
16:19:08 <Eduard_Munteanu> Nevermind, I think there is, you'd have a C -> C x C tensor coproduct. I was curious if they coincide.
16:19:18 <Eduard_Munteanu> (which they don't)
16:19:21 <Pranz> Cale, since eta : I -> M
16:19:35 <Pranz> and I ~= {}
16:19:59 <Cale> Pranz: So, that tells you M = {}
16:20:17 <heatsink> wagle, I think you want (i + incr)
16:20:20 <Pranz> that is weird
16:20:33 <Pranz> a monoidcal category without any monoid objects
16:20:35 <Cale> Pranz: So, there is one monoid object, it's just trivial.
16:20:55 <wagle> heatsink: yup..  thanks..  too many languages at once
16:21:33 <heatsink> You use lisp?
16:22:14 <Eduard_Munteanu> Still, I wonder if it's possible to express the idea of monoidal category at object-level. Perhaps not using products but some other objects (other limits?).
16:22:33 <Eduard_Munteanu> Probably not limits though, they carry an UMP with them.
16:23:02 <Cale> If you want a monoidal category with no monoid objects, perhaps take the category whose objects are, say, binary strings, and where there's a single arrow w -> w' precisely when w is a substring of w', and no others. Take the monoidal operation on objects to be concatenation of strings (it's a bifunctor, since if u -> u' and v -> v', then (u ++ v) -> (u' ++ v')), the identity object is then the empty string.
16:23:16 <Cale> oh, nope!
16:23:47 * hackagebot simple-form 0.4 - Forms that configure themselves based on type  http://hackage.haskell.org/package/simple-form-0.4 (StephenWeber)
16:24:05 <Cale> Right, the unit object for the monoidal operation on objects will tend to be a monoid object.
16:24:13 <Cale> (it's just a boring one)
16:24:39 <Eduard_Munteanu> Cale: I guess just like there's no empty monoid
16:24:48 <Pranz> but since I is empty there can't even be a function eta : I -> M
16:24:52 <Cale> Well, like there's always a one-element monoid.
16:24:56 <Pranz> so there are no monoid objects
16:25:01 <wagle> heatsink: yeah, but I think it was prolog that confused me here
16:25:01 <Eduard_Munteanu> Yeah.
16:25:08 <Cale> The empty string is always a substring of any other
16:25:14 <Cale> So there will be an eta
16:25:19 <Cale> The problem here is mu
16:25:25 <luite> Cale: exporting that missing symbol worked around it
16:25:28 <purplehz> is glut in haskell still experimental?
16:25:46 <Cale> Pranz: There is exactly one function from the empty set to any other set.
16:25:54 <Pranz> oh yeah const
16:26:10 <Pranz> but there isn't any function to an empty set right?
16:26:10 <Eduard_Munteanu> You could look at the empty category.
16:26:26 <Cale> Pranz: There's only a function from the empty set to itself
16:26:34 <Eduard_Munteanu> Though that precludes it from being monoidal since there's no identity object.
16:27:13 <Cale> This is analogous to the facts that x^0 = 1 always, but 0^x = 0 when x is not 0.
16:27:19 <Cale> (and in particular 0^0 = 1)
16:27:24 <Pranz> that is hard for me to understand
16:27:45 <Pranz> how can a set X ={} have a map f : X -> X ?
16:28:27 <Eduard_Munteanu> Though I don't understand if/why monoids really must have the unit. I mean for practical reasons.
16:28:34 <Cale> Pranz: Given sets A and B, a function f: A -> B consists of a triple (A,B,G), where G is a set of pairs (a,b) with a in A, and b in B, such that for each a in A, there is exactly one b in B such that (a,b) is in G. When (a,b) is in G, we write f(a) = b.
16:28:35 <Pranz> and isn't 0^0 undefined?
16:28:44 <elliott> Eduard_Munteanu: why must categories have the unit?
16:28:45 <Cale> Pranz: not usually ;)
16:28:47 * hackagebot bifunctors 4.0 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-4.0 (EdwardKmett)
16:29:06 <Pranz> elliott, only monoidal categories
16:29:12 <Cale> (some people like to leave it undefined, but they haven't thought about it enough -- it's much better to define 0^0 to be 1)
16:29:16 <elliott> no, I mean identity arrows.
16:29:23 <flebron> (for continuity of f(x, y) = x^y)
16:29:24 <Eduard_Munteanu> elliott: I mean {} vs {1}, not all categories
16:29:35 <Eduard_Munteanu> Or monoids.
16:29:35 <Cale> Pranz: Do you understand that definition of function I gave?
16:29:42 <Pranz> cale, reading
16:29:43 <elliott> I just mean that monoids have 1 because categories have 1, and monoids are categories with one object.
16:29:51 <elliott> and categories having 1 is nice because, e.g. the Yoneda lemma is nice.
16:30:01 <Cale> If A and B are both the empty set, then there is exactly one function f: A -> B, and it has G = {}.
16:30:13 <Eduard_Munteanu> elliott: ah, no, I wasn't talking about identity arrows.
16:30:20 <Cale> Or even if A is simply the empty set, and B is any set at all.
16:30:29 <Cale> We can choose G to be {}.
16:30:43 <Eduard_Munteanu> elliott: rather wondering if {} should or should not be considered a monoid
16:31:38 <Cale> But if A is nonempty and B is empty, then we're hosed. That means there is some a in A, and so we need to have some b in B so that there can be a pair (a,b) in G, but there's no b to choose from then.
16:32:17 <Pranz> hmm
16:32:27 <elliott> Eduard_Munteanu: it has no identity, so no? :)
16:32:28 <elliott> it's a semigroup though.
16:32:47 <Cale> Eduard_Munteanu: {} is not a classical monoid, because it has no identity element. But it is a monoid object of this weird monoidal category on Set which Pranz was talking about.
16:32:50 <Eduard_Munteanu> There is an empty category, right?
16:32:59 <Pranz> have to think more about it, but I think i understand the point
16:33:00 <Eduard_Munteanu> An empty monoidoid. :)
16:33:02 <Cale> (it is the only monoid object with this monoidal category structure)
16:33:28 <Cale> We took the (x) to be + (disjoint union), and I to be the empty set
16:33:48 * hackagebot bifunctors 4.1 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-4.1 (EdwardKmett)
16:33:50 * hackagebot bound 0.9.1.1 - Making de Bruijn Succ Less  http://hackage.haskell.org/package/bound-0.9.1.1 (EdwardKmett)
16:34:01 <Cale> Timely update of bifunctors ;)
16:34:09 <Eduard_Munteanu> Actually if you derive monoids from categories, arguably the empty set would be a monoid, no?
16:34:19 <Cale> nope
16:34:43 <Cale> Remember the I with the usual monoidal category structure on Set is the terminal object, which is a one element set
16:34:54 <Cale> the map eta: I -> M ensures that M has at least one element
16:35:22 <Cale> There's no function from a one element set to the empty set.
16:35:47 <Eduard_Munteanu> Doesn't any category pretty much give you an (Arr(C), o) monoid?
16:35:57 <Cale> no
16:36:02 <Cale> Because it's not total
16:36:15 <Eduard_Munteanu> It isn't?
16:36:18 <Cale> The monoid operation has to be defined for all pairs. It has to be a function M x M -> M
16:36:37 <Cale> Composition of arrows isn't defined for every pair of arrows, only ones which line up end to end.
16:36:44 <Eduard_Munteanu> Oh, hm.\
16:36:58 <Cale> This is exactly the sense in which categories generalise monoids.
16:37:01 <erisco> I am new to mutability in Haskell. I have some code here and a compile error. I need some hints: http://lpaste.net/94256
16:37:10 <Cale> A monoid is a category with one object (which means all the arrows compose)
16:37:28 <erisco> I know the error is about mismatched "thread" types but not sure how that is happening
16:38:17 <Eduard_Munteanu> Cale: sounds like typeful monoids / composition, to say so
16:38:26 <Cale> Eduard_Munteanu: exactly
16:38:42 <lpaste> f-a pasted “Eq with Dynamic” at http://lpaste.net/94258
16:38:58 <Cale> erisco: You should only have one application of runST for any given STRef
16:39:15 <Eduard_Munteanu> It's still weird a "typed" monoid can be empty, but the "untyped" one can't. Usually, untyped things are wilder. :P
16:39:15 <edwardk_> Cale: =) they keep coming
16:39:25 <erisco> Cale, where do I have two?
16:39:33 <Cale> edwardk_: I mentioned it because our discussion involved a lot of bifunctors :)
16:39:38 <edwardk_> =)
16:39:50 <f-a> I can provide more code if neede, but I guess it's a Possible/NotPossible question
16:40:21 <edwardk_> Cale: going through and consolidating a bunch of packages. its proving to be fairly disruptive
16:40:22 <Cale> erisco: All usage of any given STRef has to happen inside the same application of runST. You're getting these STRefs refA and refB from somewhere else, and then accessing them inside this new call to runST
16:40:53 <DanBurton> hey all, what's the pvp policy for doing nothing but updating dependencies on a package? +0.+0.+1.+0, or +0.+0.+0.+1 ?
16:40:57 <Cale> erisco: Presumably your 'app' will eventually be used inside another call to runST
16:41:49 <Cale> erisco: I think the solution might (at least partly) be to get rid of the runST in observeA and make that into a single ST action, which writes refC at the end.
16:42:37 <erisco> Cale, ah, yes, that does compile
16:42:42 <edwardk_> DanBurton: the PVP doesn't say. in practice i bump the last option
16:43:20 <elliott> Eduard_Munteanu: it's different things that are empty
16:43:23 <elliott> objects vs. arrows
16:43:24 <edwardk_> DanBurton: that is compliant to the terms of the PVP. if the package you depend on has a semantics change that affects your semantics you should probably bump at least your minor
16:43:31 <erisco> :re
16:43:33 <Cale> The whole PVP/upper bounds thing gives me a headache
16:43:37 <edwardk_> DanBurton: depending on how big a change it is
16:43:48 * hackagebot bifunctors 4.1.0.1 - Bifunctors  http://hackage.haskell.org/package/bifunctors-4.1.0.1 (EdwardKmett)
16:43:51 <Eduard_Munteanu> elliott: objects are arrows :P
16:43:51 <edwardk_> Cale: i can empathize ;)
16:44:17 <Cale> I think it's silly, and in practice requires everyone to be prescient.
16:44:19 <DanBurton> edwardk_: cool, thanks
16:44:59 <Cale> We should only have upper bounds on versions once those versions are released and we know the package doesn't work with that version.
16:45:54 <Cale> Every bound on versions should have a reason.
16:46:52 <Cale> (which should be a better reason than "I incremented the major version number of the only version I tested this thing with by 1")
16:48:48 * hackagebot lens-family-th 0.2.0.1 - Generate lens-family style lenses  http://hackage.haskell.org/package/lens-family-th-0.2.0.1 (DanBurton)
16:48:50 <Eduard_Munteanu> Is (ls, m, rs) :: (Set a, a, Set a), for an ordering like ls <= m <= rs, a notable / interesting / known zipper?
16:49:58 <Eduard_Munteanu> It's isomorphic to (Map k a, k) though.
16:50:30 <Cale> No less efficient
16:50:39 <Eduard_Munteanu> (Store comonad on partial Hask?)
16:50:41 <Cale> (and not *quite* isomorphic)
16:50:51 <Eduard_Munteanu> Yeah, you need a choice of k.
16:51:09 <Cale> Yeah, the ordering in the Map case is by keys
16:51:42 <Eduard_Munteanu> I keep stumbling into things that look like partial stores lately.
16:52:21 <heatsink> What is Store?
16:52:42 <Eduard_Munteanu> heatsink: Store s a ~ (s -> a, s)
16:53:02 <Eduard_Munteanu> aka Costate.
16:53:12 <heatsink> ok
16:53:49 * hackagebot log-domain 0.7.2 - Log-domain arithmetic  http://hackage.haskell.org/package/log-domain-0.7.2 (EdwardKmett)
16:54:06 <heatsink> and partiality turns a into Maybe a?
16:54:46 <Eduard_Munteanu> heatsink: yes, you'd have (s -> Maybe a, s)
16:55:08 <edwardk_> a Comonad on Kleisli-Maybe
16:55:50 <adimit> I love these error messages: Couldn't match expected type `Test' with actualy type `Test' … at least tell me where they're from…
16:56:22 <heatsink> adimit, try using the gnuplot package.  Every data type is 'T' and every class is 'C'.
16:56:38 <heatsink> the haddock documentation is almost useless
16:56:46 <adimit> heatsink: gotta save those bytes. Precious!
16:57:11 <Eduard_Munteanu> edwardk_: is it interesting at all? A few days ago I was staring at it and thought that Store on Kleisli Maybe looked a lot like pairing a parser with its input (a run function, really).
16:57:34 <edwardk_> there are lots of uses for kleisli-m stores of different types.
16:57:57 <edwardk_> memoizing results with a kleisli-IO store, etc.
16:58:21 <Eduard_Munteanu> Hm.
16:58:29 <edwardk_> this is why i tend to say that comonads over a kleisli category are more useful than the distributive law ways you can make monads/comonads interact.
16:58:49 * hackagebot numbers 3000.2.0.0 - Various number types  http://hackage.haskell.org/package/numbers-3000.2.0.0 (DanBurton)
17:01:51 <Eduard_Munteanu> edwardk_: can you make anything like comonad transformers over monads, or the other way around? Effectively making distributivity happen automatically. (Like monad transformers are nicer than wrapping one monad in another.)
17:02:19 <edwardk_> nothing keeps you from making kleisli-m comonad transformers, etc.
17:03:27 <Eduard_Munteanu> I guess applying a comonad transformer to a monad can be thought of as applying a comonad transformer to the identity comonad over the Kleisli-m category, no?
17:03:38 <edwardk_> yeah
17:03:59 <edwardk_> and i do have a comonad-to-monad-transformer the right kan lift along a comonad is a comonad-to-monad-transformer.
17:04:08 <edwardk_> you can tweak it to make a comonad-to-monad-transformer-transformer
17:04:34 <edwardk_> forall r. w (a -> r) -> r    is a monad given w a comonad.
17:04:46 <edwardk_> forall r. w (a -> m r) -> m r    is a monad given w a comonad, m a monad.
17:05:05 <Eduard_Munteanu> Hm, it would be nice if you could just combine constraints like (MonadState s f, ComonadSomething f) ...
17:05:57 <Eduard_Munteanu> s/.../=> ... -> f a   to clarify what I was going on about.
17:05:59 <edwardk_> you can do that with (MonadState s m, ComonadEnv e w) => CoT w m a
17:06:24 <Eduard_Munteanu> Hm.
17:06:28 <edwardk_> that lets you turn the comonadenv stuff into a reader environment, etc.
17:06:43 <edwardk_> and shows how you can get state from store, writer from traced
17:06:51 <edwardk_> i blogged it a few years back
17:07:12 <Eduard_Munteanu> I definitely have to visit that more often. :)
17:07:13 <edwardk_> i proved it was more fundamental a while back when danharaj asked me about right kan lifts in haskell and i realized it was a right kan lift along a comonad =)
17:07:39 <danharaj> edwardk_: I'm going to be in boston again on the weekend of the 1st.
17:07:47 <danharaj> we never got drunk together at icfp :<
17:07:51 <edwardk_> doh
17:07:55 <edwardk_> i think i'll be in michigan
17:08:06 <danharaj> it's ok, I have reasons to be in Boston all the time now :P
17:08:25 <edwardk_> going back for a wedding, giving a talk at my alma mater, etc.
17:08:26 <danharaj> Cambridge in particular.
17:08:33 <danharaj> is it on lens
17:08:35 <edwardk_> very convenient
17:08:39 <edwardk_> haven't decided yet
17:08:46 <edwardk_> i need to send them an overview soon
17:09:08 <edwardk_> it'll probably be something much lighter. like the role of mathematics in library design
17:09:18 <edwardk_> or something that you can pitch to a non-haskell undergrad audience
17:09:35 <danharaj> you'd be surprised how much haskell is infecting undergrad communities
17:09:59 <danharaj> I stayed at MIT over ICFP and I overheard people talking about haskell all the time :P
17:10:10 <danharaj> and I was viewed with mystique and intrigue when I told them I got paid to write Haskell.
17:10:19 <edwardk_> =)
17:10:19 <Eduard_Munteanu> I wonder if that ComonadT-over-Kleisli-m idea works / is identical for plain monad transformers... namely if a monad transformer can always be represented as an Identity transformer over Kleisli-m.
17:13:51 <Eduard_Munteanu> As in, instead of  liftArr :: (a -> m b) -> (a -> t m b)  you have a   liftArr :: Kleisli m a b -> Kleisli m a (t Identity b)
17:14:33 <Eduard_Munteanu> Maybe not the same 't', just morally equivalent.
17:16:55 <Eduard_Munteanu> Or lift :: m a -> t m a  vs  lift :: Kleisli m () a -> Kleisli m () (t Identity a)  pretty much
17:17:27 <Jessin> "template-haskell-2.8.0.0 (reinstall) changes: containers-0.5.0.0 -> 0.5.3.1
17:17:28 <Jessin> cabal: The following packages are likely to be broken by the reinstalls:
17:17:30 <Jessin> ghc-7.6.3"
17:17:32 <Jessin> :(
17:17:41 <Eduard_Munteanu> (assuming 'Kleisli m' preserves the terminal object)
17:18:50 * hackagebot optimization 0.1 - Numerical optimization  http://hackage.haskell.org/package/optimization-0.1 (BenGamari)
17:23:02 <luite> where should Coercible be defined in HEAD? or is it something magic?
17:23:19 <luite> (getting some errors compiling base)
17:24:10 <halvorgb> http://lpaste.net/94260, is there some built in (combination of) function(s) that already does this?
17:26:47 <heatsink> I can't see it, halvorgb
17:27:02 <heatsink> I mean, I can't see your code
17:27:12 <halvorgb> hm, the comma is in the url perhaps?
17:27:32 <halvorgb> http://lpaste.net/94260
17:27:32 <heatsink> that was the problem
17:28:16 <halvorgb> I want to search through a list, but give up if some other condition is met
17:28:57 <halvorgb> I think I can set the upper list bound to get the same effect though, on second thought.
17:30:50 <Eduard_Munteanu> halvorgb: find p . takeWhile (not quit)
17:31:12 <Eduard_Munteanu> Hopefully that fuses.
17:31:16 <lpaste> heatsink revised “findOrQuit”: “No title” at http://lpaste.net/94260
17:31:51 <heatsink> I rephrased the list traversal as msum with map
17:32:52 <edwardk_> glguy: around?
17:33:05 <halvorgb> Eduard_Munteanu: does that traverse the list twice?
17:33:23 <halvorgb> heatsink: need a second to understant that : )
17:33:52 <Eduard_Munteanu> halvorgb: theoretically stuff like that should fuse
17:33:56 * hackagebot distributive 0.3.2 - Haskell 98 Distributive functors -- Dual to Traversable  http://hackage.haskell.org/package/distributive-0.3.2 (EdwardKmett)
17:34:28 <halvorgb> ah thats what you mean by fuse, neat.
17:36:32 <heatsink> Is the code supposed to fail with an exception if find and quit always return False?
17:38:22 <halvorgb> Hm, no
17:38:53 <katesmith> you have people on here that really really cared about wrongplanet ,
17:39:06 <katesmith> there is nothing that can be done about it
17:39:37 <katesmith> i dont post on wrongplanet no more
17:39:43 <katesmith> not much anyways
17:40:28 <katesmith> there was one time when i thought i made the difference , but i have given up
17:40:40 <Mortomes> katesmith: Please leave.
17:40:46 <Jessin> when building haskell-platform, does GHC get built along with it?
17:41:08 <heatsink> No.  GHC must be installed first.
17:41:10 <adimit> Jessin: nope, you need GHC to build haskell-platform.
17:41:50 <katesmith> oh no wrong channel sorry
17:41:58 <Jessin> hm brb
17:43:43 <Jesin> heatsink, adimit: I know ghc needs to be installed in order to build it; I'm wondering if ghc is nevertheless included in haskell-platform
17:44:01 <heatsink> it's not
17:44:22 <heatsink> Wait, you're not Jessin
17:44:55 <adimit> Jesin: you can download it from the GHC site, or have your OS's preferred version in advance. No GHC is part of platform, but Cabal is
17:48:18 <Jesin> adimit: I've installed the archlinux ghc package, but it doesn't seem to be working together with cabal quite as nicely as I'd like.
17:48:46 <Jesin> I'll use that to build another GHC, and then uninstall the archlinux package.
17:48:56 <Jesin> I hope this helps.
17:49:14 <Jesin> Upgrading anything in GHC can be something of a nightmare.
17:49:46 <Jesin> In my experience, anyway.  If anyone has recommendations on how to make it less difficult, please say so.
17:50:20 <adimit> Jesin: building your own GHC is unnecessary on Linux. Use the binaries provided by GHC HQ
17:50:52 <adimit> Jesin: also, platform packages cabal, and certain cabal versions don't like certain ghc versions. Platform will specify which cabal it likes, use that exact version.
17:51:35 <adimit> also, arch should have a haskell-platform package. You could just use that to avoid trouble (but I don't use arch, nor do I use platform, so take it with a grain of salt.)
17:52:02 <beefcube> is this a feasible type in haskell? "type Predicate r = ReaderT r (Writer String) Bool" I know ghc won't complain about it, but when perform and ask on it to retrieve r, i'm getting "cannot deduce" ReaderMonad type errors, in this case: (MonadReader (QuantityConsumers [a0]) (ReaderT (QuantityConsumers l) (Writer String)))
17:52:03 <Jesin> it doesn't
17:52:18 <adimit> weird.
17:52:29 <Jesin> and I would like to work with the newer versions of packages if possible
17:53:18 <Eduard_Munteanu> beefcube: that just means you have a type error in your function definition
17:53:36 <heatsink> beefcube, it looks like the environment type doesn't match
17:53:42 <heatsink> [a0] versus l
17:53:51 <beefcube> oh
17:53:56 <heatsink> well, QuantityConsumers [a0] versus QuantityConsumers l
17:55:47 <Eduard_Munteanu> class MonadReader m where ask :: m r a    would have been nicer IMO.
17:56:30 * elliott doesn't get that class
17:56:30 <katesmith> you are right Mortomes
17:56:39 <Eduard_Munteanu> You just need FlexibleInstances.
17:56:49 <elliott> you can't give an instance for Reader
17:57:16 <Eduard_Munteanu> elliott: instance MonadReader (Reader r) where ...   ?
17:57:22 <elliott> kind error
17:57:45 <Eduard_Munteanu> Er, that's the way it works now.
17:57:56 <elliott> it's a kind error.
17:58:00 <Eduard_Munteanu> instance MonadReader Reader where ...
17:58:04 <elliott> @let class Eduard_Munteanu m whre asketh :: m r a
17:58:04 <lambdabot>  Parse failed: Parse error: ::
17:58:08 <elliott> @let class Eduard_Munteanu m whre { asketh :: m r a }
17:58:08 <lambdabot>  Parse failed: Parse error: {
17:58:10 <elliott> @let class Eduard_Munteanu m where { asketh :: m r a }
17:58:11 <lambdabot>  Defined.
17:58:15 <elliott> @let instance Eduard_Munteanu (Reader r) where { }
17:58:16 <lambdabot>  .L.hs:146:27:
17:58:16 <lambdabot>      Kind mis-match
17:58:16 <lambdabot>      The first argument of `Eduard_Muntean...
17:58:49 <Eduard_Munteanu> elliott: yeah, just 'Reader', I was thinking of the current one.
17:59:22 <elliott> ok, so you need to implement forall r a. Reader r a
17:59:26 <elliott> aka forall r a. r -> a
17:59:48 <Eduard_Munteanu> elliott: erm, why?
18:00:01 <elliott> because that is what your class says
18:00:13 <Jesin> I just attempted to build GHC, and got this output from "./configure": http://ix.io/8sP
18:00:16 <elliott> your one method is ask :: m x y (alpha-renamed by me)
18:00:20 <elliott> aka ask :: forall x y. m x y
18:00:29 <elliott> so in this case (m = Reader), ask :: forall x y. Reader x y
18:00:38 <elliott> expanding the newtype, ask :: forall x y. x -> y
18:00:39 <Eduard_Munteanu> elliott: ask :: Reader r a
18:00:46 <elliott> :t ask
18:00:47 <lambdabot> MonadReader r m => m r
18:00:50 <elliott> :t ask :: Reader r a
18:00:51 <lambdabot>     No instance for (MonadReader a1 (ReaderT r1 Identity))
18:00:51 <lambdabot>       arising from a use of `ask'
18:00:51 <lambdabot>     Possible fix:
18:00:54 <elliott> :t ask :: Reader r r
18:00:55 <lambdabot> Reader r r
18:01:12 <heatsink> Jesin: it is trying to compile a program that prints the size of long long
18:01:19 <Eduard_Munteanu> elliott: grr, I'm tired and making mistakes, I meant  ask :: m r r   of course.
18:01:34 <heatsink> Jesin: You can find the program in config.log and then try compiling it to see what the error is
18:02:03 <heatsink> Those sizes shouldn't be zero
18:02:16 <heatsink> maybe your C compiler isn't set up correctly
18:02:30 <Eduard_Munteanu> elliott: I was arguing for  class MonadReader m   instead of   class MonadReader r m | m -> r
18:02:35 <elliott> Eduard_Munteanu: ok, but now you can't give an instance for StateT s (Reader r)
18:02:41 <elliott> so what's the point of the class?
18:04:20 <Eduard_Munteanu> elliott: why not? With FlexibleInstances, you can do   instance (MonadReader m) => MonadReader (StateT s (m r))
18:05:02 <Eduard_Munteanu> I guess that's why I mentioned FlexibleInstances above.
18:05:21 <elliott> Eduard_Munteanu: kind error
18:05:42 <Eduard_Munteanu> Hm, I see your point.
18:05:47 <elliott> :)
18:06:47 <Eduard_Munteanu> You'd need to make State parametrised in 'r' which would suck.
18:08:30 <elliott> Eduard_Munteanu: if you do that, you'll find you have problems writing MonadState
18:08:41 <elliott> or, um, just stacking transformers more than one deep
18:08:54 <Eduard_Munteanu> Yeah, would really suck. :)
18:09:34 <hodapp> Haskeller opinion on the Go language. GO!
18:09:59 <elliott> language war. STOP!
18:10:06 <startling> Polarina, did you figure it out?
18:10:18 <startling> elliott, I've never heard of that one.
18:10:42 <Peaker> hodapp: repackaging 1970's mistakes in a shiny new package
18:10:49 <hodapp> Peaker: which 1970's mistakes?
18:11:03 <hodapp> Peaker: I'm gonna guess not the mistakes of "not shiny or packaged enough" type?
18:11:13 <elliott> my brakes never did work well.
18:11:32 <Peaker> elliott: what's wrong with a (minor) language war every now and then? :) can stop it before it gets major or if the channel is needed for real help
18:11:43 <hodapp> I don't think this will turn into a language war.
18:11:57 <startling> We've had this language war a few times already.
18:11:58 <Peaker> hodapp: nullability everywhere, no sum types/pattern matching, no parameter polymorphism, no verified immutability
18:12:09 <hodapp> This is #haskell; it will probably turn into a polite discussion with a lot of objective reasons cited.
18:12:11 <startling> This channel is logged. :)
18:12:15 <elliott> hodapp: hahahaha
18:12:18 <Peaker> (not all of these are 1970's mistakes, that was mostly a catch-phrase :)
18:12:31 <hodapp> elliott: Do consider that I've done my time in ##c and #java.
18:12:31 <Peaker> hodapp: s/parameter/paramateric
18:12:40 <startling> Peaker, see, that's a pretty negative way too look at things.
18:12:54 <startling> Peaker, instead: Haskell, in 98, solving the future's mistakes!
18:13:08 <elliott> but, pretty much what startling said, any imaginable language war has been unproductively done to death here already. it gets in the way of haskell conversation implicitly, because people don't want to ask their question when there's a language war going on.
18:13:27 <elliott> and the answer always inevitably comes down to "it lacks haskell features X, Y and Z" (and I don't even like Go)
18:13:33 <Peaker> hodapp: come to #haskell-blah ?
18:16:43 * hodapp hits startling with a chair, because if this is a language war, he's damn well gonna get his money's worth.
18:17:14 <startling> OK.
18:17:52 <hodapp> bunch of pacifists.
18:18:27 <Fuuzetsu> we don't mention those *other* languages
18:18:36 <dobblego> hodapp: it would be most helpful if we moved this over to #haskell-blah
18:18:45 <hodapp> it has been moved over to #haskell-blah.
18:19:38 <startling> http://ircbrowse.net/browse/haskell?q=golang
18:19:58 <dobblego> thanks
18:21:19 <DuDraig> Is there any way to view the procedural source that GHC implements? The ddump flags for C or C-- do not seem to work and the support for emitting C was removed and never fully supported. I want to know exactly how GHC is implementing a given Haskell source.
18:21:27 <Jesin> FOUND IT http://ghc.haskell.org/trac/ghc/ticket/6063
18:21:57 <Jesin> DuDraig: objdump -d
18:22:21 <carter> what source?
18:22:26 <Jesin> DuDraig: alternately, use "ghc -S"
18:22:30 <carter> oh the asm
18:22:33 <carter> yes -S
18:23:33 <DuDraig> Theoretically, at least according to what I've read so far, GHC internally implements the Haskell model source into C-- procedural source and then compiles it. Or is this wrong?
18:24:00 <carter> yes
18:24:03 <DuDraig> I don't mean text C--, but a C-- model.
18:24:08 <startling> Is C-- still the primary backend?
18:24:09 * hackagebot cryptohash 0.11.1 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.11.1 (VincentHanquez)
18:24:16 <startling> I was under the impression that changed.
18:24:25 <carter> Source -> CORE ->STG -> C-- -> (native or c or llvm)
18:24:38 <carter> yes
18:24:45 <carter> at some point we have C-- ASTS
18:24:47 <Jesin> I see
18:24:52 <Jesin> does -ddump-cmm not work?
18:25:09 <Jesin> or -ddump-opt-cmm?
18:25:13 <carter> depends on what the goal is
18:25:26 <carter> Jesin: recently rwbarton found some issues with how cmm is dumped
18:25:40 <Jesin> ahh
18:25:46 <DuDraig> -ddump-cmm emitted nothing for me.
18:26:07 <carter> DuDraig: read the manual for your ghc version
18:26:47 <DuDraig> ghc 7.6.3
18:27:00 <DuDraig> on windows x64
18:27:06 <carter> DuDraig: the ghc manual has a lot fo stuff
18:29:59 <Jesin> DuDraig: are x86-64 and/or LLVM assembly insufficiently high-level?
18:31:17 <DuDraig> The only references I've found in the manual to emitting the C or C-- implementations are the now deleted -fvia-C, and the -ddump-flatC and -ddump-cmm that do not emit anything.
18:32:35 <DuDraig> I haven't been able yet to get an installation of LLVM on Windows to work with GHC. Apparently there are missing elements in the settings file for LLVM commands, and/or those commands are not available for Windows.
18:32:48 <hodapp> I am interested in C-- but it looks rather young.
18:33:37 <DuDraig> I'd prefer to see the C-- source directly to observe things like: when recursions do and do not use a stack.
18:33:55 <startling> hodapp, it's 16 years old.
18:33:57 <heatsink> GHC's cmm, or C--?
18:34:14 <DuDraig> If there's a difference, then either.
18:34:36 <hodapp> startling: whaaaaat?
18:34:37 <heatsink> GHC's cmm is a port of C-- that has subsequently changed a lot
18:34:46 <heatsink> C-- doesn't have active developers
18:34:55 <heatsink> because it is not research-y enough
18:35:02 * geekosaur has a feeling this clarifying look will only cause more confusion
18:35:31 <rmarantz> Does anyone know if hlint works with the current Haskell Platform?  I get an error saying "Failed to install uniplate-1.6.11" when I do a cabal install hint.  The error is Data/Generics/Uniplate/Direct.hs:78:4:      error: invalid preprocessing directive       #-}        ^
18:35:40 <DuDraig> As long as it is a readable source that correctly represents what is actually compiled.
18:37:14 <heatsink> I think you can identify tail recursion at the -ddump-simpl level
18:37:18 <geekosaur> oh, it will reflect it. but your question indicates you're assuming a flow of execution that probably doesn't exist the way you expect it to
18:37:37 <geekosaur> ...yes, haskell's execution model IS that ifferent.
18:37:37 <heatsink> STG and CMM are both pretty hard to follow because they chop the Haskell code into tiny pieces
18:38:47 <heatsink> There's a reasonably accurate cost model for GHC Core, which is what -ddump-simpl prints
18:39:10 * hackagebot optimization 0.1.1 - Numerical optimization  http://hackage.haskell.org/package/optimization-0.1.1 (BenGamari)
18:39:21 <carter> DuDraig: -fvia-c still works
18:39:33 <DuDraig> You're looking at this from the wrong angle. I want to know exactly how GHC is implementing a given Haskell source. I'm not trying to compare it with any expectations. The texts I've read so far indicated that GHC should be able to emit the C-- (cmm) it implements but none of the flags indicated in the manual seem to work.
18:39:35 <carter> i built GHC head using it on fridaty
18:40:22 <heatsink> DuDraig, the -ddump-cmm flag works for me
18:41:27 <DuDraig> ghc 7.6.3 with -fvia-c: "on the commandline: Warning: The -fvia-c flag does nothing; it will be removed in a future GHC release"
18:41:42 <carter> DuDraig: lies
18:41:45 <carter> it works
18:41:49 <carter> and is maintained
18:41:57 <carter> so we can target ppc64 and other archs
18:42:14 <carter> i accidentally broke with for a few weeks because i ddin't know we used it :)
18:42:30 <DuDraig> "ghc -ddump-cmm sumTest.hs" returns without sending anything to the stdout for me.
18:42:51 <heatsink> Oh, hmm
18:43:01 <heatsink> You need to put the -ddump-cmm flag after the input file
18:43:31 <heatsink> I never tried your flag order before, so I didn't know about that.
18:43:39 <DuDraig> I just did. Same thing
18:44:10 <heatsink> GHC won't compile if it detects that the file was already compiled
18:44:11 <DuDraig> Without the flag, the file compiles just fine.
18:44:32 <heatsink> If it's running suspiciously fast, then use -fforce-recomp
18:44:51 <heatsink> which will force recompilation
18:45:01 <DuDraig> Bingo! That was it. Deleting the previously compiled files worked.
18:45:11 <DuDraig> Thank you so much!
18:45:13 <heatsink> ok good
18:45:57 <heatsink> And I guess the flag order doesn't matter
18:46:23 <rmarantz> Anyone have time to answer a new user question?
18:46:37 <Jesin> hm, how does fllvm compare to fasm?
18:46:50 <DuDraig> Comfirmed: the flag order does not matter.
18:47:24 <carter> Jesin: depends on the code and arch and optimization levels
18:47:27 <heatsink> go ahead rmarantz
18:48:13 <Jesin> carter: how about with -O2 for everything
18:48:22 <heatsink> -fllvm benchmarks slightly faster on average (2% or so) and significantly faster on numerical inner loops
18:48:27 <Jesin> on a Sandy Bridge processor
18:48:38 <rmarantz> I just installed Haskell Platform and am trying to install hlint,, but doing a cabal install hlint give me an error saying  Data/Generics/Uniplate/Direct.hs:78:4:      error: invalid preprocessing directive
18:49:00 <carter> rmarantz: youre on a mac right?
18:49:28 <rmarantz> any idea how to proceed? or where I can find the Uniplate/Direct.hs file to fix it?
18:49:48 <rmarantz> carter yes
18:51:14 <carter> rmarantz: with xcode 5 installled / updated right?
18:51:26 <carter> what does going
18:51:28 <carter> gcc --version
18:51:31 <carter> on the cli say?
18:51:36 <carter> do you have brew installed?
18:51:49 <rmarantz> carter yes I just installed them today too
18:51:52 <carter> ok
18:51:55 <Jesin> huh
18:52:03 <carter> rmarantz: brew install apple-gcc42
18:52:04 <Jesin> -fasm "has the best support for compiling shared libraries"?
18:52:10 <Jesin> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/code-generators.html
18:52:16 <carter> Jesin: yes, dynamic linking and llvm apparently ahve issues on some platforms
18:52:19 <Jesin> no other information is given...
18:52:19 <carter> i'm fuzzy on the details
18:52:42 <rmarantz> so this version of gcc is no good?  gcc --version Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/usr/include/c++/4.2.1 Apple LLVM version 5.0 (clang-500.2.76) (based on LLVM 3.3svn) Target: x86_64-apple-darwin12.5.0 Thread model: posix
18:52:53 <carter> rmarantz: its actually clang :)
18:53:00 <bergey> carter: If I'm installing XCode for the first time, what XCode version would you recommend?
18:53:00 <carter> its lying to you
18:53:15 <carter> bergey: dl xcode 4.6.2 CLI TOOLs
18:53:21 <bergey> Thanks!
18:53:22 <carter> from developer.apple.com
18:53:38 <rmarantz> so I should do the brew install apple-gcc42???
18:53:45 <carter> yes
18:53:51 <carter> rmarantz: then theres 1 step after that
18:54:01 <carter> or rmarantz  do you need xcode for anything?
18:54:02 <rmarantz> ok I'll try it now
18:54:22 <rmarantz> no I don't need xcode, should I remove it first?
18:54:22 <carter> actually bergey  too
18:54:26 <carter> rmarantz: nope
18:54:29 <Jesin> hmm.  I'll stick with -fasm for now, and use -fllvm -static for distribution, I guess.
18:54:48 <carter> rmarantz: just do the directions i gave bergey  then
18:54:56 <carter> i was going to walk you through the power user version
18:55:10 <carter> install xcode 4.6.blah cli tools
18:55:16 <carter> from the apple develoepr site
18:55:28 <bergey> carter: I was trying to get macports working too, and I think it needs XCode, not just the CLI tools
18:55:41 <carter> bergey: macports?
18:55:48 <carter> why would it need anything but the cli toosl?
18:55:52 <carter> what error message wer eyou getting?
18:56:25 <rmarantz> carter: I'm confused as to what I should do.  please repeat
18:56:38 <carter> rmarantz: ignore my prior directions
18:56:41 <startling> rmarantz, what error are you seeing?
18:56:51 <carter> startling: the xcode 5 CPP stuff
18:56:59 <startling> oh, ugh.
18:57:05 <carter> rmarantz: go to developer.apple.com
18:57:07 <danharaj> edwardk_: do you have a link to your finger tree slides?
18:57:09 <carter> go to the downloads thing
18:57:10 <danharaj> I can't google it.
18:57:19 <carter> go back 2-3 pages
18:57:27 <edwardk_> http://comonad.com/reader/2010/finger-trees/
18:57:38 <carter> dl xcode 4.6.(any version here) CLI tools
18:57:55 * startling is permanently stuck on xcode 4, as Apple slowly removes any semblance of support.
18:58:58 <hodapp> :-/
18:59:00 <carter> startling: we will have a 7.6.4 bugfix release for ghc
18:59:05 <carter> for OS X reasons
18:59:06 <carter> :)
18:59:28 <danharaj> ty2tu
18:59:59 <carter> ?
19:01:57 <startling> thank you 2 to you?
19:03:12 <carter> i guess i was one of the trumpeters of "ghc 7.6 on xcode 5 / OS X 10.9 is HOSED, we need to fix it"
19:03:22 <carter> but the hard work is wholely attributable to folks who arent me
19:04:38 <rmarantz> carter: I'm downloading xcode 4.6.3 which shold take another 10 minutes
19:04:42 <carter> ok
19:04:45 <carter> rmarantz: ummmm
19:04:46 <carter> no
19:04:48 <carter> the CLI tools
19:04:52 <carter> different things
19:04:59 <carter> you don't need to install XCODE
19:05:01 <carter> just the cli tools
19:05:31 <rmarantz> any idea how to find them in develop.apple.com?
19:05:41 <carter> developer.apple.com
19:05:45 <carter> go to the downloads section
19:05:51 <carter> and click 2-3 pages in
19:06:36 <carter> you may need an apple account
19:06:47 <carter> rmarantz: or brew install apple-gcc42
19:06:55 <carter> and then follow an additional step
19:07:00 <carter> thats power users ish
19:07:55 <rmarantz> I don't have brew and only see the XCode download on the developer.apple.com
19:08:03 <carter> go to resources
19:08:45 <carter> https://developer.apple.com/downloads/index.action
19:08:49 <rmarantz> carter: OSX addition downloads?
19:08:58 <carter> additional yes
19:09:45 <mjo> Is there a way to get Cabal to depend on applications that don't have an accompanying library? I'd like to say that my test suite requires shelltestrunner, but unlike doctest, it ships only an executable
19:10:38 <carter> mjo: have you setup.hs file print "must have shelltestrunner installed"
19:10:53 <rmarantz> carter: September or April (4.6.2) download
19:10:59 <mjo> that kind of defeats the point of cabal, doesn't it?
19:11:17 <carter> mjo: nah, its just we don't have teh right meta data right now
19:11:20 <carter> theres plans to fix it
19:11:29 <carter> rmarantz: which september?
19:11:41 <carter> april 2013 should be the newest….
19:11:54 <mjo> Well, I don't expect 3rd party tools to dig through my setup.hs looking for the string "must have shelltestrunner installed"
19:11:56 <carter> ohhh
19:12:01 <rmarantz> carter: Sept 18, 2013
19:12:01 <carter> rmarantz: september might work
19:12:04 <carter> try it out
19:12:06 <carter> it might not work
19:12:07 <carter> but it may
19:12:14 <rmarantz> ok
19:12:34 <carter> if it doesn't work
19:12:43 <carter> thats info we can share for the next person who asks
19:13:26 <chenwl> I'm writing a physics unit DSL, what is the simplest way to let user just write "1 m/s" to have a value of velocity, "1000 W h" to have a value of energy, etc. What I can do now is " 1 * m / s ", " 1000 * W * h".
19:13:43 <carter> chenwl: have you looked at the units DSLs on hackage?
19:14:01 <chenwl> carter: nope
19:14:08 <carter> worth checking out!
19:14:14 <carter> nb: type nats won't work out well
19:14:18 <carter> well
19:14:21 <carter> well
19:14:23 <carter> i'm saying that worng
19:14:29 <chenwl> carter: bindings-DSL this one?
19:14:34 <carter> umm
19:14:55 <carter> http://hackage.haskell.org/package/units
19:15:26 <meretrix> For a local project with many executables, is there a way to bypass cabal's dependency check so that I don't need to create dependency lists for each executable?
19:15:40 <rmarantz> carter: after installing the Sept cli tools I did a cabal install hlint and got the same error
19:15:47 <carter> rmarantz: ok
19:15:52 <carter> as i thought
19:15:58 <carter> april WILL work
19:16:09 <rmarantz> I'll try the april one now
19:16:12 <carter> rmarantz: you may also want to delete ~/.ghc
19:17:01 <rmarantz> ok I rm -rf ~/.ghc
19:17:17 <carter> yup
19:17:22 <carter> rmarantz: whats gcc --version say right now
19:17:28 <carter> (open a new terminal tab too maybe)
19:17:32 <carter> before you do that
19:18:23 <rmarantz> it said this before I did that April install
19:18:24 <rmarantz> gcc --version Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/usr/include/c++/4.2.1 Apple LLVM version 5.0 (clang-500.2.76) (based on LLVM 3.3svn) Target: x86_64-apple-darwin12.5.0 Thread model: posix
19:18:51 <rmarantz> now it says i686-apple-darwin11-llvm-gcc-4.2 (GCC) 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00)
19:19:37 <carter> rmarantz:
19:19:45 <carter> before you install the new cli tools
19:19:49 <carter> try your build again
19:20:32 <rmarantz> to late.  do you want me to undo some stuff and retry Sept cli tools again?
19:20:36 <carter> nah
19:20:39 <carter> doesn't amtter
19:21:33 <rmarantz> now hlint seems to be building.  do I need to do something to rebuild anything else?  e.g. cabal-install
19:21:43 <carter> rmarantz: ooo
19:21:47 <carter> you should update cabal install
19:22:13 <rmarantz> again?
19:22:20 <chenwl> can I define a function (m) :: Int -> Int -> Int, to make m an infix function. and use it like 10 m 2
19:22:25 <scshunt> I have never been able to figure out how to maintain a sane haskell installation
19:22:38 <carter> rmarantz: what does cabal --version say?
19:22:58 <carter> scshunt: when theres are borken and you're stuck, burn it with fire so theres room for new growth :)
19:22:59 <chenwl> I can see functions like ($) (.|.), but not (test) (a) (b) ...
19:23:05 <rmarantz> I'll say so once hlint finished
19:23:10 <enthropy> chenwl: no. But you can define it as usual (not infix) and use it like 10 `m` 2
19:23:17 <Ghoul_> I have some function, like (+1)
19:23:18 <scshunt> carter: that's pretty much my usual approach
19:23:23 <fread2281> is there any way to turn evaluated expressions back into thunks?
19:23:37 <carter> fread2281: whats the motivation?
19:23:41 <scshunt> fread2281: err, what
19:23:41 <Ghoul_> and I want to feed the result of the application of the function with each element of some list into the next
19:23:53 <carter> Ghoul_: a fold?
19:24:06 <chenwl> enthropy: What kind of functions can be defined in form of (function-name), and be used  param1 function-name param2
19:24:07 <Ghoul_> Yeah, I tried that, but I can't make it typecheck in ghci
19:24:15 <fread2281> to save memory
19:24:30 <carter> fread2281: prevent sharing to begin with
19:24:30 <carter> eg
19:24:37 <enthropy> chenwl: ones that use characters like +-*&^%$#
19:25:06 <carter> ahhhhh
19:25:21 <Ghoul_> oh derp, ofc, because I'm imagining some magic implicit parameter
19:25:27 <enthropy> > filter isSymbol [ minBound .. ]
19:25:28 <lambdabot>   "$+<=>^`|~\162\163\164\165\166\167\168\169\172\174\175\176\177\180\182\184\...
19:25:51 <Ghoul_> :t bind
19:25:52 <lambdabot>     Not in scope: `bind'
19:25:52 <lambdabot>     Perhaps you meant one of these:
19:25:52 <lambdabot>       `BS.find' (imported from Data.ByteString),
19:25:57 <enthropy> > text (filter isSymbol [ minBound .. ])
19:25:58 <lambdabot>   $+<=>^`|~¢£¤¥¦§¨©¬®¯°±´¶¸×÷˂˃˄˅˒˓˔˕˖˗˘˙˚˛˜...
19:26:09 <carter> Ghoul_: :t (>>=)
19:26:23 <Ghoul_> I actualy was just checking if that name was already taken
19:26:27 <Ghoul_> I wanna use it :P
19:26:31 <rmarantz> carter: cabal-install version 1.16.0.2 using version 1.16.0 of the Cabal library
19:26:41 <carter> rmarantz: cabal  install 1.18 is  pretty nice
19:26:49 <carter> sandboxed builds are a feature
19:26:52 <carter> cabal install cabal-install
19:26:54 <carter> and know joy
19:26:55 <Ghoul_> 1.18 has a bugfix on windows for firefox
19:27:03 <carter> Ghoul_: firefox...../
19:27:04 <carter> ?
19:27:18 <Ghoul_> yeah, on firefox all the docs used to 404 with anything earlier than 1.18
19:27:21 <rmarantz> ok is that better than cabal-dev?  I don't know either (yet)
19:27:25 <Ghoul_> I pushed quite hard to get it fixed..
19:27:27 <Gracenotes> the popular web browser
19:27:42 <Ghoul_> because it would emit paths like C:/...
19:27:46 <Ghoul_> and firefox thought it was a protocol
19:27:48 <Ghoul_> so it would just 404.
19:27:58 <carter> rmarantz: cabal-install is the canonical tool
19:28:06 <carter> and with 1.18 it replaced the need for cabal-de
19:28:07 <carter> v
19:28:21 <rmarantz> cool, I'm installing it now
19:31:02 <fread2281> carter: so I have this insane idea that's probably impossible/insanely hard that is so you could say implement apps with large disk-backed data/&structures (eg: databases) by doing that
19:31:17 <carter> ?
19:31:35 <carter> its easy to write a DB, hard to write a good one someone else will also use
19:31:49 <fread2281> (ture evaluated expressions into thunks)
19:31:51 <Ghoul_> this is what I was trying to do, as a continuation. Can't believe it took so long to figure out exactly what I needed :S brain too tired.
19:31:53 <fread2281> *turn
19:31:53 <Ghoul_> > let f = flip (foldl (+)) [1..5] in f 4
19:31:53 <lambdabot>   19
19:32:01 <carter> oh
19:32:13 <carter> fread2281: if you want to forget thunks
19:32:19 <carter> do something like
19:32:30 <carter> fval = \ _-> val
19:33:12 <carter> fread2281: you almost want to be in a monad
19:33:14 <carter> :)
19:33:27 <carter> or figure out a way to "roll back" a computation
19:35:09 <rmarantz> carter: is there some magic to get 1.18 cabal-install?  doing cable install cabal-install left me with version 1.16.0.2
19:35:22 <Tekmo> rmarantz: Check in your ~/.cabal/bin directory
19:35:26 <carter> rmarantz: ahhhh
19:35:31 <carter> you lack ~/.cabal/bin in your path
19:35:34 <carter> or
19:35:44 <xil> hi. I need some help with regexes. I'm trying to figure out what RegexContext a b [[b]] does with =~. I was trying to find the instance declaration for it but can't seem to. I'm basically trying to make sense of the return type [[b]]. Why the nested list?
19:36:06 <Tekmo> What package is this?
19:36:08 <carter> Tekmo: nope, rmarantz  ~/Library/Haskell/bin  is needed to be in path
19:36:16 <carter> Tekmo: he's just freshly installed haskell platform
19:36:43 <carter> rmarantz: you need to add $homedir/Library/Haskell/bin  to your path
19:36:46 <carter> or whatever
19:37:09 <rmarantz> that is in my path ad which cabal shows /Users/rmarantz/Library/Haskell/bin/cabal
19:37:37 <carter> yes
19:37:47 <Saizan> rmarantz: is it in the path with a '~'? because that's not going to work
19:37:58 <rmarantz> ok I'll fix my path
19:38:06 <carter> Saizan: thianks
19:38:10 <carter> i can't do all the hlping
19:38:12 <Tekmo> xil: Could it be a list of matches?
19:38:37 <xil> Tekmo: that would make sense for [b], but what are the inner lists?
19:38:42 <Tekmo> xil: Oh, I think I know
19:38:52 <Tekmo> xil: It's if you are matching against a list
19:39:01 <Tekmo> xil: And you have multiple matches, each of which is a list
19:39:25 <rmarantz> SAizan: no as /Users/rmarantz instead
19:39:45 <Saizan> xil: a single regex has a way to match multiple substrings at once, iirc
19:39:53 <carter> rmarantz: open a new terminal tab and ask cabal --version again
19:40:20 <fread2281> carter: yeah, there's sane ways to do mostly the same thing
19:40:32 <carter> i recommend sane ways
19:40:32 <Tekmo> xil: However, I'd like to point out that working with parsing libraries is much easier if you have a choice
19:40:50 <Tekmo> xil: For example: parsec or attoparsec
19:40:53 <xil> Saizan: that's one thing I was thinking. That maybe the outer list is a list of all matches, and the inner lists are for groups within a match maybe?
19:41:09 <rmarantz> carter, yes I had to source .bash_path again
19:41:13 <xil> Tekmo: oh that's a thought. This doesn't necessarily need regexes
19:41:39 <Saizan> xil: yeah
19:41:52 <Tekmo> xil: General rule of thumb: parsec gives better error messages, but attoparsec gives better performance
19:42:02 <Tekmo> xil: So if you're learning you should train on parsec
19:42:14 <Saizan> xil: anyhow i'd use regex-compat or some other lib, and avoid the RegexContext API, it's needlessly oveloaded
19:42:32 <Tekmo> xil: Yeah.  regex-tdfa makes Haskell look harder than it usually is
19:42:36 <rmarantz> one more question.  is ghc-mod worth it or does normal haskell emacs mode work well enough?
19:42:42 <xil> Saizan: I was using regex-pcre, because perl regexes are better for what I'm doing
19:42:58 <Tekmo> xil: For example, here's what you can do using monadic parsers
19:43:07 <Tekmo> xil: Let's say you have sometihng that parses a double, like:
19:43:13 <Tekmo> xil: double :: Parser Double
19:43:16 * jfischoff . o O ( https://github.com/kmcallister/haskell-re2 )
19:43:17 <carter> rmarantz: honestly, just keep it simple while you're learning
19:43:22 <Tekmo> xil: If you want to parse multiple doubles in a row, you can just write:
19:43:28 <Tekmo> xil: many double :: Parser [Double]
19:43:57 <rmarantz> ok.  I'll go and play now.  thanks so much for your help
19:43:58 <Tekmo> xil: Or if you want to parse double separated by commas, you would write
19:44:04 <Tekmo> xil: double `sepBy` char ','
19:44:17 <Tekmo> xil: That would also have type `Parser [Double]`
19:45:48 <carter> np
19:46:35 <xil> Tekmo: yeah, I remember parsec a bit -- I used it once for a small project. I should check it out again. It might be far easier for this project because I have a balanced input, which is ugly enough in Perl proper, let alone trying to figure it out in regex-perl
19:46:50 <Tekmo> xil: The nice thing about parser combinators is that you can store useful intermediate combinators
19:47:07 <Tekmo> xil: With regex you are limited to whatever is built into the regex language
19:47:22 <Tekmo> xil: But with parser combinators you can create new reusable primitives
19:49:09 <xil> Tekmo: I mostly went with regexes because I am decently familiar with them in other languages. But it probably won't be that hard to learn parsec
19:49:18 * hackagebot optimization 0.1.2 - Numerical optimization  http://hackage.haskell.org/package/optimization-0.1.2 (BenGamari)
19:49:32 <startling> the parsec family is great.
19:49:41 <Tekmo> xil: The main reason I recommend parsers is, besides the advantages I mentioned, those libraries are much better maintained and developed
19:49:51 <Tekmo> xil: Trying to use regex in Haskell is swimming against the stream
19:50:00 <xil> oh, I see
19:51:38 <startling> I wonder why that is. Objection to encoding information as strings?
19:53:23 <Tekmo> Also, it plays poorly with type inference
19:53:26 <Tekmo> As `xil` just learned
19:54:02 <Tekmo> Multiparameter type classes + undocumented instances are a nightmare to use
19:54:21 <xil> I have to admit, I actually really like that you can change the behavior of =~ by just specifying a different return type. That being said, it's not sufficiently well documented
19:54:57 <startling> Tekmo, what type inference do you need for string-matching regular expressions?
19:54:57 <Tekmo> xil: For example, consider the (<|>) combinator that parser combinator libraries use
19:55:15 <Tekmo> xil: It's general type is:
19:55:23 <Tekmo> xil: (<|>) :: (Alternative f) => f a -> f a -> f a
19:55:36 <Tekmo> xil: It's not at all parser-specific
19:55:49 <Tekmo> xil: It also comes paired with an `empty` operator
19:55:56 <Tekmo> xil: empty :: (Alternative f) => f a
19:56:02 <Tekmo> xil: These two obey the following "laws"
19:56:06 <Tekmo> xil: empty <|> f = f
19:56:09 <Tekmo> xil: f <|> empty = f
19:56:16 <startling> > empty <|> Just 2
19:56:17 <lambdabot>   Just 2
19:56:21 <startling> > Just 2 <|> empty
19:56:23 <lambdabot>   Just 2
19:56:26 <Tekmo> xil: (f <|> g) <|> h = f <|> (g <|> h)
19:56:36 <startling> ^ There's an instance for a type you may have already seen.
19:56:41 <Tekmo> xil: That's important because it means that all instances of `Alternative` that obey those laws are well-behaved
19:56:56 <Tekmo> xil: Which means that we can reason about what `(<|>)` does without looking at instances
19:57:10 <copumpkin> :t many
19:57:11 <lambdabot> Alternative f => f a -> f [a]
19:57:17 <copumpkin> > many [1]
19:57:20 <Tekmo> xil: Whereas a class like `RegexContext` is more difficult to reason about
19:57:24 <copumpkin> :P
19:57:24 <lambdabot>   mueval-core: Time limit exceeded
19:57:25 <xil> good point. Also awesome TIL
19:57:40 <Tekmo> xil: We can't really understand what instances should do without inspecting their source code
19:58:05 <Tekmo> xil: This is why I prefer type classes that have laws vs. those that don't have laws
19:58:26 <Tekmo> xil: The type classes with laws don't require you to inspect the source code or guess at the behavior
19:59:00 <Tekmo> xil: Parser combinators work well because they build on type classes that do have laws
19:59:28 <Tekmo> xil: In this case it is usually the `Monad` and `Alternative` type classes
19:59:57 <xil> I do love the sound of that. The fact that Haskell can have these properties at all is largely why I love it
20:00:04 <xil> but I have a LOT more to learn
20:00:10 <Tekmo> xil: One thing that blew my mind whe nI learned Haskell was the `many` function
20:00:18 <Tekmo> xil: many :: (Alternative f) => f a -> f [a]
20:00:26 <Tekmo> It's not at all Parser-specific
20:00:32 <Tekmo> It's totally generic over the `Alternative` API
20:00:40 <Tekmo> Yet it magically does the right thing when you apply it to a parser
20:01:01 <Tekmo> It generates a new parser which parsers multiple occurrences of a sub-parser until it fails
20:02:01 <Tekmo> When you see all sorts of elegant things come together like that you know you are on the right track in Haskell
20:02:19 <Tekmo> That's why people usually flock to parser combinators because they have all of those touchy-feely elegant things
20:02:50 <copumpkin> > many [1]
20:02:53 <copumpkin> >_>
20:02:58 <lambdabot>   mueval-core: Time limit exceeded
20:03:12 <Tekmo> > many []
20:03:13 <lambdabot>   [[]]
20:04:03 <startling> copumpkin, why isn't that lazy?
20:23:13 <RommelVR> how could I flatten a list of [[(Int, Int)]]
20:23:18 <jmcarthur> concat
20:23:28 <RommelVR> currently trying   foldl concat [] dta
20:23:49 <jmcarthur> concat is not a binary operator
20:23:59 <jmcarthur> it already does exactly what you are asking for
20:24:10 <jmcarthur> concat = foldr (++) []
20:24:20 <jmcarthur> :t concat
20:24:21 <lambdabot> [[a]] -> [a]
20:24:24 <jmcarthur> :t (++)
20:24:24 <lambdabot> [a] -> [a] -> [a]
20:25:46 <dobblego> > concat [[(7, 8), (9, 10)]]
20:25:47 <lambdabot>   [(7,8),(9,10)]
20:25:52 <dobblego> > concat [[(7, 8), (9, 10)], [(11, 12)]]
20:25:53 <lambdabot>   [(7,8),(9,10),(11,12)]
20:26:00 <dobblego> > foldr (++) [] [[(7, 8), (9, 10)], [(11, 12)]]
20:26:01 <lambdabot>   [(7,8),(9,10),(11,12)]
20:27:33 <jmcarthur> i am not 100% sure that my answer here is correct, but i do believe that the scenario i describe about garbage collection is plausible in any case. this possibility makes me really wish we had a concurrent GC. http://stackoverflow.com/questions/19347907/does-data-bytestring-readfile-block-all-threads
20:28:32 <jmcarthur> because this means that even safe FFI calls with -threaded might block the whole program :(
20:28:42 <jmcarthur> if i'm right
20:28:57 <carter> ummm
20:29:01 <carter> that'd be a bug
20:29:05 <jmcarthur> i don't think so
20:29:18 <jmcarthur> what behavior could we expect here?
20:29:32 <jmcarthur> did you read my answer on that page?
20:29:43 <carter> my understanding is that safe ffi calls shouldn't block the gc
20:29:51 <jmcarthur> please read the answer first
20:29:56 <jmcarthur> oh wait, what?
20:29:58 <jmcarthur> how could they not?
20:30:17 <jmcarthur> even if they are bound?
20:30:34 <carter> bound?
20:31:02 <carter> the safe ffi calls don't run on normal capability, right?
20:31:13 <jmcarthur> looks like if i allow the call to run in an unbound thread and make the GC only use one core, it *tends* to not block
20:31:30 <carter> i'm tired
20:31:34 <jmcarthur> bound threads promise to always use the same OS thread for safe calls
20:31:35 <carter> so i can't reply in a helpful way
20:31:39 <carter> ok
20:32:05 <jmcarthur> but maybe what you say is true. maybe it's actually a bug
20:32:13 <carter> i think it could be considere done
20:32:21 <carter> if you could show that a safe call can block ghc
20:32:24 <carter> GC
20:32:27 <carter> please please report it
20:34:09 <carter> pleaseeee :)
20:34:43 <leimy> sooooo, what the heck is someone supposed to do to pick the right IO library/approach these days.
20:34:51 <carter> leimy: depends
20:34:53 <leimy> Enumerator/Iteratee still looks pretty complicated.
20:34:58 <leimy> Pipes looks great
20:35:03 <carter> leimy: pipes is pretty simple these days
20:35:08 <leimy> but for the stuff the Conduit guy has been pointing out.
20:35:09 <carter> if it suites your needs
20:35:10 <jmcarthur> i have updated my answer with a proposed workaround
20:35:21 <carter> leimy: they both agree more than they disagree
20:35:29 <carter> tradeoffs exist
20:35:32 <leimy> yeah, it does look that way.
20:35:46 <carter> i'd say if you won't any surpris corner cases, err on using Tekmo 's stuff :)
20:35:49 <leimy> A unified theory of side-effects via handles might come out.
20:35:58 <carter> *dont want
20:36:08 <leimy> fair enough
20:36:09 <jmcarthur> i still believe it's a safe FFI call blocking the GC. i still believe there may not be much to do about it. it depends on the interaction between bound threads and the GC.
20:36:15 <carter> yeah
20:36:17 <carter> still
20:36:30 <carter> worth reporting if you can isolate it to that
20:36:31 <leimy> My solution has usually been "write concurrent Haskell and be explicit"
20:36:47 <carter> thats sort of orthogonal to the other issue
20:36:50 <carter> but fairenough
20:36:51 <leimy> yes
20:37:17 <leimy> Hopping in and out of IO contexts is weird.  And if a Haskell thread can just do one thing, it's easier to think about.
20:37:45 <carter> cool
20:37:50 <carter> leimy: have you seen pipes-concurrency?
20:37:56 <leimy> hmmm no.  I should look
20:38:26 <carter> @hackage pipes-concurrency
20:38:27 <lambdabot> http://hackage.haskell.org/package/pipes-concurrency
20:38:35 <leimy> yes I'm there already :-)
20:38:37 <carter> ok
20:38:39 <leimy> thank you
20:38:39 <carter> just helping
20:38:42 <carter> np
20:39:10 <carter> well, i should actually leave the internet
20:39:11 <carter> night all
20:39:16 <leimy> night!
20:43:50 <Polarina> startling, notdan made a stackoverflow post. There are some answers already, but none of them actually explain the problem: http://stackoverflow.com/questions/19347907/does-data-bytestring-readfile-block-all-threads
20:45:12 <startling> looks like unsafe FFI is the culprit. :/
20:45:52 <startling> Disappointing from a library like 'bytestring', if true.
20:45:52 <Polarina> jmcarthur, here's another variant showing the same symptoms. I discovered the bug originally when the readFile was actually in a bound thread: http://lpaste.net/94234
20:46:04 <carter> startling: good
20:46:04 <carter> that means its solveable
20:46:04 <carter> :)
20:46:04 <carter> if it was safe ffi, that'd be BAD
20:46:14 <startling> carter, heh.
20:46:15 <carter> startling: report an issue to bos :)
20:46:25 <carter> hes pretyt responsive
20:46:26 <startling> carter, not me, Polarina.
20:46:52 <carter> Polarina: report an issue to the bytestring github repo :)
20:47:10 <Polarina> carter, I'll do that.
20:47:10 <jmcarthur> i am still not convinced this can't happen with a safe call. if it couldn't, why would my using forkIO seem to fix the problem?
20:47:31 <startling> jmcarthur: hm?
20:47:35 <jmcarthur> since forkIO is not generally a way to work around issues with unsafe bindings
20:47:46 <jmcarthur> but a way to avoid *safe* calls blocking a bound thread
20:48:03 <jmcarthur> err
20:48:04 <Polarina> jmcarthur, it could be the operating system's cache caching the whole file in memory. That makes subsequent reads very fast.
20:48:08 <jmcarthur> the capability for a bound thread
20:48:26 <jmcarthur> Polarina: that doesn't seem to jive with my having a workaround though, does it?
20:48:38 <Polarina> jmcarthur, I'll try your code snippet, one moment.
20:48:46 <startling> It should probably be reported anyhow.
20:48:54 <jmcarthur> Polarina: make sure to also use the RTS flags i suggested
20:49:01 <Polarina> jmcarthur, of course.
20:49:05 <jmcarthur> it requires both :\
20:50:47 <Polarina> jmcarthur, I get the same blocking behaviour with your code.
20:51:34 <jmcarthur> oh?
20:51:35 <jmcarthur> hmm
20:51:50 <Polarina> jmcarthur, nothing prints for several seconds while it's reading the file.
20:52:12 <jmcarthur> yeah that's the behavior i have observed for anything but that code with those RTS flags
20:52:12 <Jesin> I'm using ghc-7.6.3 and cabal 1.16.0.2
20:52:34 <Jesin> I try to "cabal install -O2 numeric-prelude" and get this error: http://ix.io/8sZ
20:52:36 <jmcarthur> so far it has been very consistent for me unless i enable parallel gc
20:54:09 <Polarina> For example, a gigabyte file blocks the program for 10-20 seconds for me.
20:55:30 <startling> jmcarthur: oh, that's interesting.
20:55:40 <startling> It /is/ immediately garbage-collected.
20:55:56 <startling> Polarina, have you tried storing the ByteString in the TVar?
20:56:05 <Polarina> jmcarthur, although I notice that if the whole file is in the operating system's cache, it doesn't seem to be blocking everything or slowing things down noticeably.
20:56:13 <Polarina> startling, one moment, I'll try that.
20:56:33 <startling> or Maybe ByteString or whatever.
20:59:00 <Polarina> startling, doesn't seem to help.
20:59:20 <startling> Dang.
20:59:50 <jmcarthur> i'm still intrigued that my version doesn't help for you. how many capabilities are you running it with?
21:00:13 <Polarina> jmcarthur, four.
21:00:26 <jmcarthur> when i run with one capability it still blocks, but otherwise it seems to always work
21:00:35 <jmcarthur> including with four
21:03:36 <jmcarthur> if i disable gc load balancing but not parallel gc entirely, it works about half the time
21:04:21 * hackagebot aeson 0.6.2.1 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.6.2.1 (BryanOSullivan)
21:04:46 <startling> jmcarthur, what's your platform?
21:05:37 <jmcarthur> linux, 64 bit
21:06:11 <jmcarthur> i'm talking about my workaround, not the original, to be clear
21:09:04 <Polarina> jmcarthur, I still wonder how having readFile being on a bound thread or not would help. If it blocks, the other capabilities should still run.
21:10:32 <jmcarthur> it'
21:10:33 <jmcarthur> oops
21:10:38 <carter> i think major collections are blocked if any capabilities haven't yielded
21:10:39 <jmcarthur> my theory is still a crank theory at this point
21:10:55 <jmcarthur> but what carter says is true
21:12:30 <Polarina> I get the same behaviour if I store the resulting string in a TVar, so it shouldn't get collected. That is, unless GHC is smart enough to figure out I never use the TVar again later.
21:12:34 <CindyLinz> hi~
21:13:05 <startling> Polarina, I don't think it is, but I think you could look at the core to see.
21:13:20 <jmcarthur> i just tried to replicate this behavior with my own import of sleep and adding performGC to the status loop. i can't get quite the same behavior with either safe or unsafe imports
21:13:28 <Polarina> I'll just throw a writeFile at the bottom somewhere instead. :)
21:13:32 <startling> heh
21:13:38 <startling> good call!
21:13:55 <CindyLinz> If I have some .y files in my cabal package. And I need to run Happy to generate some .hs files from them. Should I run the Happy in the preBuild hook of the Distribution.Simple?
21:16:43 <jmcarthur> wut
21:17:11 <jmcarthur> if i remove my forkIO the way the original code is and use my imported sleep function, it doesn't even block the haskell thread it's running in...
21:17:32 <jmcarthur> sleep only behaves as expected with forkIO? wtf
21:17:38 <lpaste> Polarina annotated “blocking in forkIO” with “blocking in forkIO (prevent GC of the string)” at http://lpaste.net/94234#a94263
21:17:40 <jmcarthur> this seems totally unrelated, even
21:17:47 <Polarina> startling, same behaviour.
21:19:22 * hackagebot http-media 0.1.0 - Processing HTTP Content-Type and Accept headers  http://hackage.haskell.org/package/http-media-0.1.0 (TimothyJones)
21:21:11 <jmcarthur> well, okay, i think i've blown my mind enough for tonight
21:22:30 <Polarina> :(
21:23:35 <carter> yay bug reports pending?!
21:23:36 <carter> :)
21:24:22 <jmcarthur> i'd rather at least determine whether it's bytestring or ghc, first
21:24:28 <jmcarthur> or base, i guess
21:24:48 <jmcarthur> it's not even clear where the fault lies, yet
21:25:02 <jmcarthur> hence me trying to experiment with sleep
21:25:14 <jmcarthur> but now it is time for me to sleep irl
21:25:36 <Refried__> is there an ORM that supports Either?
21:25:37 <elliott> try not to experiment too much if you want to be well-rested.
21:30:27 <carter> welll
21:30:32 <carter> once its isolated
21:37:18 <Jesin> I'm using ghc-7.6.3 and cabal 1.16.0.2
21:37:19 <Jesin> I try to "cabal install -O2 numeric-prelude" and get this error: http://ix.io/8sZ
21:39:23 * hackagebot hashable-extras 0.2 - Higher-rank Hashable  http://hackage.haskell.org/package/hashable-extras-0.2 (EdwardKmett)
21:41:34 <carter> Jesin: don't
21:41:36 <carter> certain libs break with -O2 on 7.6
21:41:59 <carter> Jesin: don't break out the O2 till you're actually needing crazy performance :)
21:42:09 <carter> and comfortable reporting GHC bugs
21:43:05 <Jesin> carter: I get the same output with -O1
21:43:12 <carter> Jesin: don't pass any such flags
21:43:14 <NemesisD> is it considered a Bad Idea to do type aliases on stuff like the state monad
21:43:19 <Refried__> refried
21:43:20 <carter> dont pass O1 or O2 to cabal
21:43:22 <Refried__> oops
21:43:23 <Refried__> haha
21:43:30 <carter> Jesin: it does O1 by default
21:43:42 <carter> Jesin: also numeric-prelude isn't very usable
21:43:43 <Refried__> i was trying to search to see if anyone had replied to me
21:43:48 <Jesin> carter: I get the same output without anything
21:44:12 <Polarina> NemesisD, I don't see why it would be.
21:44:23 * hackagebot log-domain 0.8 - Log-domain arithmetic  http://hackage.haskell.org/package/log-domain-0.8 (EdwardKmett)
21:44:25 <carter> Jesin:  trust me when i say: numeric-prelude doesn't do what you want
21:45:24 <startling> NemesisD, it doesn't usually clarify things ime
21:45:53 <carter> Jesin: have you done a cabal update?
21:46:03 <Jesin> carter: yep
21:46:09 <carter> Jesin: whats your actuall goal
21:46:22 <carter> aside from "install all the cool sounding things and larn how to debug"
21:46:46 <carter> :)
21:46:47 <carter> *learn
21:49:23 * hackagebot http-media 0.1.1 - Processing HTTP Content-Type and Accept headers  http://hackage.haskell.org/package/http-media-0.1.1 (TimothyJones)
21:49:25 * hackagebot snap-accept 0.1.0 - Accept header branching for the Snap web framework  http://hackage.haskell.org/package/snap-accept-0.1.0 (TimothyJones)
21:49:27 * hackagebot compensated 0.5 - Compensated floating-point arithmetic  http://hackage.haskell.org/package/compensated-0.5 (EdwardKmett)
21:53:32 <Ghoul_> a nice ghci tile for win8 https://i.cloudup.com/XDo3P0XqHM-3000x3000.png *shrugs*
22:04:54 <wagle-prime> hi -- is there a more super-duper optimization mode than -O2 for ghc?
22:06:17 <Polarina> wagle-prime, -O1337 :P
22:06:31 <Polarina> wagle-prime, but no, -O2 is the highest. Try messing with the other parameters.
22:06:37 <Ghoul_> wagle-prime: UHC has -O11
22:06:39 <Ghoul_> ;)
22:07:18 <Ghoul_> damnit, Data.Map should have a partitionIntersection function
22:07:40 <Ghoul_> it has partition and intersection, but not both at the same time! complexity fail :(
22:09:46 <wagle-prime> I tried -O1337 but i have to pass some test to see the results
22:10:20 <Ghoul_> -O1337 doesn't exist
22:10:52 <wagle-prime> j/k
22:10:56 <beefcube> silly question: is using the Writer monad to avoid list construction operators considered abuse? and is there an alternative? (naively, do notation isn't an option because all examples I've seen involve cross products etc)
22:10:58 <Ghoul_> -O2 is "crank all the nobs up" and very rarely is there a benefit from doing much more
22:11:44 <wagle-prime> I was hoping for better strictness analysis, I have a space leak, and 2 hours to deadline
22:11:45 <Ghoul_> heh I wonder if a list is even a monoid
22:11:54 <prophile> I'm pretty sure lists are monoids
22:12:09 <prophile> yeah they are
22:12:10 <Ghoul_> 1:2 isn't the same as 2:1 though
22:12:16 <prophile> (:) isn't the monoid operation
22:12:19 <Ghoul_> I always thought monoids had to be squashable
22:12:23 * carter wagle-prime: bang pattern the things
22:12:26 <carter> wagle-prime: bang pattern the things
22:12:28 <prophile> besides which, monoids don't need to be commutative
22:12:33 <Ghoul_> wagle-prime: {-# LANGUAGE BangPatterns #-}
22:12:35 <Ghoul_> spam ! everywhere
22:12:35 <prophile> only associative
22:12:43 <Ghoul_> although tbh that will make your space leak worse most the time!
22:12:47 <Polarina> The exclamation mark to the rescue!
22:12:52 <prophile> ie (a + b) isn't necessarily (b + a), but a + (b + c) = (a + b) + c
22:12:53 <wagle-prime> carter trying that, not working yet
22:12:58 <prophile> (++) satisfies that
22:13:19 <Ghoul_> hmm
22:13:25 <Ghoul_> fair enough
22:14:39 * wagle-prime flogs that disk
22:16:33 <Ghoul_> wagle-prime: look for sharing in recursion and there's your space leak
22:17:09 <wagle-prime> sharing?
22:17:17 <wagle-prime> oh
22:17:24 <Ghoul_> for each of your lets in something recursive think about "is this going to be referenced or kept by something else"
22:17:51 <wagle-prime> yeah, I'm staring at the code, trying to imagine the operational semantics
22:18:30 <wagle-prime> oh..  i'm using foldM_
22:18:37 <wagle-prime> still
22:19:27 <lispy> wagle-prime: this paper might be helpful: http://haskell.cs.yale.edu/wp-content/uploads/2011/01/leak.pdf
22:19:50 <Ghoul_> he has 2 hours \o/
22:19:54 <lispy> not because you want to use arrows, but because it explains the problem
22:20:22 <Ghoul_> foldM_ always blows up my stack for me
22:20:33 <Ghoul_> same with foldl
22:21:07 <wagle-prime> using foldl'
22:22:08 <wagle-prime> thanks for the cite, I wonder if I should read it now or try to find even better optimizations
22:23:35 <lispy> wagle-prime: find other optimizations. Read the paper when you have time to slow down and think carefully
22:24:09 <lispy> optimizing Haskell is a skill that takes a while to develop
22:24:22 <lispy> I think Ghoul_ gave you some good advice though about thinking about lets
22:24:23 <lispy> and sharing
22:24:25 * hackagebot warp 1.3.10.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.10.1 (MichaelSnoyman)
22:24:44 <wagle-prime> yeah, that was my decision, I'm currently on a 6 hour run, and I'm not going to improve it that much by fixing space leaks
22:25:13 <wagle-prime> all my lets are banged already
22:25:37 <wagle-prime> thanks all
22:25:37 <Ghoul_> oh I remember this
22:25:42 <Ghoul_> you mentioned this in the chan a week or so ago
22:25:58 <wagle-prime> this is different problem..  TSP this time
22:26:11 <lispy> wagle-prime: forcing thunks won't really fix a sharing problem
22:26:24 <lispy> it might make the shared thing smaller
22:26:26 <wagle-prime> did improve the speed though
22:26:30 <lispy> but it won't change the structure of what is shared
22:26:45 <Ghoul_> increasing purity can sometimes make things run faster
22:27:22 <wagle-prime> the data is big enough to run me out of RAM
22:28:07 <wagle-prime> but its using 1G more swap now than an hour ago
22:28:26 <wagle-prime> well, I'm going to try a better optimization now
22:28:31 <chipdude> I'm not a math major, but I just HAD TO KNOW the theoretical underpinnings of category theory as it relates to Haskell.  I ended up slogging through an Intro to CT book and Mac Lane's book, missing a lot but getting a lot.
22:29:01 <chipdude> And I conclude that knowing all of CT just to know Haskell is roughly like knowing all of Boolean Algebra (including abstract approaches) just to understand and/or/not
22:29:18 <chipdude> It isn't necessary, but it adds flavor and appreciation
22:29:24 <chipdude> Am I off base or ?
22:30:09 <lispy> chipdude: did you look at Moogi's seminal stuff?
22:30:20 <chipdude> I don't think so; don't recognize the name.
22:30:25 <lispy> sorry, moggi
22:30:32 <chipdude> heh, no better
22:30:37 <chipdude> link link?
22:30:41 <lispy> This might be a place to start: http://www.disi.unige.it/person/MoggiE/ftp/ic91.pdf
22:30:49 <lispy> That's just a random link off google
22:31:09 <lispy> chipdude: he's the one that came up with the idea to use CT (monads specifically) to model semantics in programming languages
22:31:21 <lispy> chipdude: Wadler then took his ideas further
22:31:28 <lispy> and then others joined in
22:31:49 <chipdude> Well paint me green and call me a grassy knoll, that looks very much like what I was searching for
22:31:59 <chipdude> thanks!
22:32:03 <lispy> you're welcome!
22:32:37 <chipdude> is there a seminal Wadler reference I should queue up?
22:33:04 <lispy> chipdude: you may also be interested in closed cartesian categories
22:33:11 <lispy> I don't know where to start with Wadler's stuff
22:33:26 <chipdude> 'sokay, I'll work it out
22:33:48 <lispy> I do think this is one of his earlier papers on the subject: http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
22:34:26 * hackagebot hackage-proxy 0.2.0.1 - Provide a proxy for Hackage which modifies responses in some way.  http://hackage.haskell.org/package/hackage-proxy-0.2.0.1 (MichaelSnoyman)
22:34:47 <wagle-prime> woot!  about 15 minus to go!  i hope its correct
22:35:00 <startling> hey, that looks perfect for a MITM attack.
22:35:19 <joey_> Question: I'm trying to install the new Cabal in Windows. It successfully installs 1.18.02, but when I run "cabal --version" it shows 1.16. The folder C:\Users\me\AppData\Roaming\cabal\bin is at the front of my PATH.
22:35:59 <joey_> When I directly run the 1.18 executable, I get a bunch of "cabal.exe does not exist" errors
22:36:27 <wagle-prime> *minutes
22:39:25 * hackagebot lens 3.10 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.10 (EdwardKmett)
22:40:10 <edwardk_> this is just 3.9.3 + the new dependencies. the previous 3.10 HEAD branch is moved to 4.0
22:40:33 <Polarina> Aww. :(
22:40:37 <edwardk_> there are still about 10k lines worth of code changes coming
22:41:14 <Polarina> What's new for 4.0?
22:41:16 <edwardk_> this mostly addresses the complaints about lens having too many dependencies… by consolidating them. =)
22:42:28 <wagle-prime> woo!  it terminated, and with the correct answer!
22:42:40 <startling> lens-core should be lens, but with all its dependencies in the Control.Lens namespace.
22:42:53 <edwardk_> 4.0 makes a lot of changes, Wrapped cleans up and gets better inference, typechanging ala/alaf, lots of combinators generalize further, relevant traversals, so you can have things that only demand semigroups/apply of you situationally, simpler Each, Ixed, At, Field1...
22:43:47 <edwardk_> in 4.0 we also kill Accessor and Mutator, start talking about laws for optics in general in a way that we can give the same laws for all lens-likes.
22:44:30 <elliott> "cleans up" :/
22:45:00 <Polarina> edwardk_, cool. Seems like it has all the new features, except documentation. :)
22:45:06 <edwardk_> Polarina: patches welcome
22:45:10 <Polarina> Haha.
22:45:17 <edwardk_> in all seriousness
22:45:40 <edwardk_> i'm happy to help folks work on documentation, answer questions, etc.
22:45:44 <Polarina> I am aware, but it would probably be better that I understood lenses before I write documentation for them. :)
22:46:33 <startling> pff
22:46:37 <edwardk_> Polarina: one thing we do that works well is we have doctests everywhere in the lens docs. if you see a function that doesn't have doctests or where the doctests don't suggest how its used. ask for help or figure it out, then write a short doctest that characterizes it as you understand it
22:47:03 <edwardk_> Polarina: lots of people have learned lens by going through and doing that sort of thing
22:47:30 <edwardk_> its a good supply of tricky mental puzzles as well ;)
22:47:43 <Polarina> edwardk_, no doubt about that.
22:48:44 <gabemc> Hello, I have an http-conduit question somebody may be able to answer. I don't see a way to get what I want from the docs. Namely: In the case of a non-2XX status code response from a request, how do you still get the response body?
22:49:12 <johnw> you have to change the error response
22:49:18 <johnw> one sec, let me look up how to do that again
22:49:31 <jfischoff> edwardk: 'constraints' is mind blowing
22:50:15 <johnw> gabemc: set the checkStatus field of the request
22:50:31 <johnw> to a function which always returns Nothing in the cases where you don't want an exception
22:50:39 <chipdude> lispy: back, got that Wadler link, ty again
22:51:27 <gabemc> johnw: Oh…. Ok, thanks.
22:51:31 <chipdude> it'd be nice if scientific paper styles included a date...
22:52:57 <johnw> stepcut: ping
22:59:31 * hackagebot keys 3.10 - Keyed functors and containers  http://hackage.haskell.org/package/keys-3.10 (EdwardKmett)
22:59:33 * hackagebot compressed 3.10 - Compressed containers and reducers  http://hackage.haskell.org/package/compressed-3.10 (EdwardKmett)
22:59:37 <satc> Is there an implementation of this in haskell https://www.lri.fr/~filliatr/puf/
23:00:35 <Polarina> satc, it shouldn't be difficult to implement.
23:01:15 <jfischoff> @hackage union-find
23:01:15 <lambdabot> http://hackage.haskell.org/package/union-find
23:01:46 <satc> Polarina: It think it is difficult to implement efficiently.
23:01:58 <liftM> Either (\/), Validation etc.
23:02:09 <satc> jfischoff: Thats imperative union-find.
23:02:24 <jfischoff> my bad
23:02:42 <liftM> sorry, wrong window
23:03:08 <Tekmo> Yeah, I was like "Why is union find a monad transformer?"
23:04:30 <satc> Tekmo: Cause that is just a verbatim translation of imperative version to haskell.
23:04:31 * hackagebot reducers 3.10 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-3.10 (EdwardKmett)
23:05:12 <satc> If I remember correctly there was some chat going on here a few years back about implementing the same.
23:14:50 * hackagebot either 4.0 - An either monad transformer  http://hackage.haskell.org/package/either-4.0 (EdwardKmett)
23:15:50 <JoeBukkit> I'm new to Haskell, I just wanted a quick pointer to some video tuts if anybody knows any. I have a bit of a background with C++, C#, and Java. So I don't mind it being a bit fast paced.
23:16:31 <Polarina> JoeBukkit, there's a good book online: http://learnyouahaskell.com/
23:17:03 <startling> I don't know of any good video tutorials.
23:17:03 <Polarina> JoeBukkit, it is directed to people that have some previous programming experience.
23:17:26 <JoeBukkit> I really prefer video if possible, although I have read some of that already.
23:17:44 <Polarina> startling, I was wondering if I should try to modify GHC's tokenizer and replace all unsafe with safe on foreign imports. :)
23:17:57 <startling> :/
23:18:27 <Polarina> startling, I'll at least know if it's the FFI or not.
23:18:33 <RommelVR> is there a way to get all distinct elements in a list based on some predicate?
23:18:42 <shiona> JoeBukkit: I'm not sure if this is something one would call 'tutorial', but it's a video series http://www.youtube.com/watch?v=zZ_nI9E9g0I
23:18:57 <shiona> and I thought it was somewhat accessible for a beginner
23:19:37 * hackagebot reducers 3.10.1 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-3.10.1 (EdwardKmett)
23:20:02 <JoeBukkit> I searched for some haskell videos a couple days ago and ended up on lisp videos... And I'm looking at that video right now.
23:24:39 * hackagebot hackage-proxy 0.2.0.2 - Provide a proxy for Hackage which modifies responses in some way.  http://hackage.haskell.org/package/hackage-proxy-0.2.0.2 (MichaelSnoyman)
23:36:29 <JoeBukkit> Just gone done watcing, thanks shiona.
23:36:42 <shiona> np
23:36:44 <JoeBukkit> The first video, that is
23:36:57 <dareTake> another channel -- http://www.youtube.com/user/LazyCasts
23:37:22 <shiona> it does get boring at some point, up to you if you want to keep watching or switch channels
23:37:38 <shiona> I guess i went through some 7 or so videos
23:39:00 <JoeBukkit> Well, I'll keep going through these vidoes, thanks again.
23:42:14 <arkeet> the hackage twitter bot hasn't been working lately =(
23:44:16 <arkeet> hm, irc bot either.
23:44:19 <dareTake> @joe, try out this link, http://stackoverflow.com/questions/1012573/getting-started-with-haskell , nice info
23:44:19 <lambdabot> Not enough privileges
23:44:21 <arkeet> oh wait it's there
23:44:31 <arkeet> pdm
23:44:35 <arkeet> don't prefix nicks with @ ;)
23:44:38 * hackagebot tasty 0.3.1 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.3.1 (RomanCheplyaka)
23:44:40 * hackagebot tasty-quickcheck 0.3.1 - QuickCheck support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-quickcheck-0.3.1 (RomanCheplyaka)
23:44:55 <dareTake> still learning IRC :(
23:45:19 <arkeet> well it's just to avoid triggering lambdabot.
23:45:27 <arkeet> also this isn't twitter =(
23:45:29 <donri> can sharing matter for newtypes? eg. omap f (X a) = X (f a)  vs  omap f x = x { unX = f (unX x) }  -- surely not?
23:46:04 <arkeet> I'm sure core would tell you.
23:46:18 <elliott> donri: omap f a = f a   vs. omap f x = f x
23:46:43 <donri> elliott: ?
23:46:47 <startling> I wonder what @joe does, and why you need admin privileges to use it. :x
23:46:48 * arkeet has never heard of using record updates for newtypes.
23:46:50 <elliott> newtypes don't exist
23:47:05 <donri> elliott: that's my thinking, but they also do sometimes exist a bit
23:47:32 <arkeet> newtype constructors and accessors are id.
23:47:57 <elliott> donri: fmap NewType exists because fmap id exists
23:48:23 <JoeBukkit> dareTake, good info indeed. Thanks.
23:53:28 <Jesin-phone> Why so outdated http://hackage.haskell.org/package/regions
