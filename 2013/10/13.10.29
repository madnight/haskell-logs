00:02:58 <startling> neat.
00:14:15 <DrAlexMV> Hey guys, I have been trying to install Yesod using Cabal for a few hours already today
00:14:28 <DrAlexMV> and after a lot of struggle have not had any success
00:14:31 * hackagebot uuid 1.3.3 - For creating, comparing, parsing and printing Universally Unique Identifiers  http://hackage.haskell.org/package/uuid-1.3.3 (AntoineLatter)
00:14:31 * hackagebot hruby 0.1.1 - Embed Ruby in your Haskell program.  http://hackage.haskell.org/package/hruby-0.1.1 (SimonMarechal)
00:14:42 <ketil_> *Main> alter (Just . (\x -> 1 + fromMaybe 0 x)) 101 j
00:14:42 <ketil_> Process haskell segmentation fault
00:14:52 <ketil_> Don't meddle in the affairs of Haskell wizards...
00:14:53 <DrAlexMV> I have created an SO for it if anybody can help me
00:14:54 <DrAlexMV> http://stackoverflow.com/questions/19650477/installing-yesod
00:17:44 <tikhon> Hey, is there some nice library for drawing directed graphs?
00:17:51 <tikhon> preferably outputting SVG
00:18:20 <tikhon> the diagrams package is neat but it seems a bit too "low-level" for what I want to do
00:18:20 <johnw> tikhon: diagrams?
00:18:24 <tikhon> heh
00:18:45 <tikhon> I'd love something like a much simpler version of GraphViz
00:19:22 <tikhon> I wonder---do you think that would be hard to implement in terms of diagrams?
00:19:43 <tikhon> I haven't put much thought into it, but it seems getting a pretty layout of the nodes and edges would be tricky.
00:23:59 <ketil_> tikhon, heh, I was about to suggest graphviz
00:24:27 <ketil_> the Big Deal is the graph layout, of course - you get something sensible without too much effort.
00:27:34 <moto9> huch, installing kmett's log-domain ends in cabal ExitFailure 139 and manually running the last ghc invocation makes it core dump
00:28:04 <edwardk> moto9: can you send in an issue on it? i'll take a look when i'm more awake
00:28:10 <moto9> cool
00:28:54 <moto9> edwardk, oh, i'm on ghc 7.4.2, still interesting?
00:29:08 <edwardk> moto9: sure, that shouldn't be happening
00:29:26 * hackagebot patch-combinators 0.2.1 - A library for patching functions and data structures  http://hackage.haskell.org/package/patch-combinators-0.2.1 (EmilAxelsson)
00:32:10 <moto9> edwardk, i never sent in an issue, how do i do that?
00:32:44 <edwardk> https://github.com/ekmett/log-domain/issues
00:32:52 <edwardk> click new issue and go from there
00:33:42 <kqr> can anyone elaborate on why it is a bad idea to put typeclass constraints on members of data types? shachaf suggests instead putting the constraints on relevant functions, and i do respect his opinion because i'm sure it's based on something, but i just don't know what that something is
00:34:26 * hackagebot patch-combinators 0.2.2 - A library for patching functions and data structures  http://hackage.haskell.org/package/patch-combinators-0.2.2 (EmilAxelsson)
00:34:56 <edwardk> kqr: in general moving them to methods lets you use more classes and generally reuse vastly more code than randomly crippling your data type by baking instances into it in a couple of places
00:35:49 <edwardk> even if you don't use the dictionaries you baked in via GADTs, then you still pay for them everywhere, you get worse inference, more overhead and less code reuse
00:36:06 <edwardk> hence we don't do that ;)
00:37:10 <edwardk> Functor, Foldable, Traversable, etc. are big things to give up, they carry with them tons of useful combinators
00:37:55 <edwardk> and they are usually the first thing sacrificed on the altar of 'hey i only every expect to store instances of 'x' inside here'
00:49:55 <dv-_> > flip execState ([(3::Int, False)],2::Int) $ _1 %= map (_2 .~ True)
00:49:57 <lambdabot>   ([(3,True)],2)
00:57:39 <SlickRIck> bit.ly/1abgczC
00:57:47 <GGuy> Hi, is there any middleware for handling cookies in WAI... specificially warp? If not is there any helper modules out there?
01:00:02 <kqr> edwardk, fair points. i guess my main stumbling block is that people seem fine with restricting to concrete types (e.g. Integer) but not the slightly-more-general typeclass constraint (e.g. Integral a => a) why are those cases different?
01:00:55 <edwardk> kqr: actually a lot of us try to avoid specializing down to concrete types when we can. ;)
01:01:26 <edwardk> given a function from a -> b -> a   i can tell you what it does if it doesn't do anything stupid, given one from Integer -> Double -> Integer  i have no idea.
01:03:02 <edwardk> by reserving the type variables for the 'interesting bits' that vary in full generality we tend to find that the code that results is more canonical, and less often needs to be hacked to fit a new scenario. you get code that you can use in more situations without trying
01:04:07 <Swenn> http://lpaste.net/94949 Anyone can help me with this?
01:06:16 <kqr> edwardk, but given something concrete like a triangle, it makes sense in my head to do (in pseudo-haskell) `data Coordinate a => Triangle a = Triangle a a a'
01:06:36 <kqr> edwardk, where there might be Coordinate instances for Complex and Num a => (a, a) for example
01:06:56 <edwardk> but what is a 'coordinate'?
01:07:04 <edwardk> why limit yourself to 2d?
01:07:17 <kqr> well you could have a Coordinate instance for Num a => (a, a, a) as well
01:07:28 <edwardk> but what does the class give you here?
01:07:56 <edwardk> the restriction you just put on yourself prevents you from making Triangle Traversable, Foldable. Functor, Monad, Applicative, Distributive, Representable...
01:08:08 <edwardk> all of those instances give you literally dozens of combinators
01:08:28 <edwardk> all of them were possible until you put that constraint on there… which doesn't even help because you don't get that back when you want it
01:08:56 <startling> kqr, why not just have data Triangle a = Triangle a a a ?
01:09:11 <kqr> edwardk, how do they stop you from making e.g. Functor Triangle?
01:09:15 <edwardk> nothing prevents you from writing a combinator that takes advantage of some weird coordinate class.
01:09:35 <edwardk> kqr: because you don't have Coordinate a to atisfy the data type constraint you shoved in there needlessly. write it
01:09:36 <kqr> startling, because a Triangle String is not something I ever imagine wanting to create
01:10:13 <edwardk> kqr: consider while you're parsing it. you might well wind up with one. then you can fmap read over it to get a Triangle a  for anything you can read.
01:10:19 <startling> kqr, fmap must work for any "a -> b". You can't apply any function of that type, since you don't know if that b is a Coordinate.
01:10:29 <kqr> ohhh
01:10:33 <kqr> that makes a lot of sense
01:10:37 <edwardk> bad example since, you'd probably want to traverse readMaybe to get back a triangle if they all parsed
01:10:56 <edwardk> both of those examples are of course ruled out by the data type constraint
01:11:17 <edwardk> which all you did was rule out scenarios you didn't think of in advance.
01:11:52 <edwardk> it didn't _help_ it just ensured that you were screwed later when you went to do something you didn't anticipate
01:12:24 <kqr> yeah
01:12:33 <startling> Applicative instances are nice for this kind of thing btw.
01:13:51 <edwardk> given two triangles you can zip them together using representable, add them elementwise, etc.
01:14:08 <edwardk> if you put the constraint in there, you have to make up all those combinators yourself
01:14:14 <Kneiva> Swenn: can you paste the full log?
01:14:31 <Swenn> Kneiva: The full log? with -v?
01:14:42 <edwardk> if you don't they can all be special cases of general purpose combinators that have a canonical reason for existing, giving you insight into how those things work on all sorts of data types
01:14:46 <Kneiva> Swenn: yeah
01:14:57 <edwardk> rather than forcing you to look up what you called it this time
01:15:58 <Swenn> Kneiva: http://lpaste.net/94950
01:18:32 <edwardk> in a triangle in practice you may temporarily store all sorts of things. e.g. store colored points, etc.
01:19:04 <startling> or functions.
01:20:32 <Kneiva> Swenn: see if these give any ideas: http://www.haskell.org/pipermail/haskell-cafe/2013-September/110320.html http://stackoverflow.com/questions/11700472/building-the-text-library-fails-on-os-x-mountain-lion
01:22:25 <kqr> edwardk, startling thank you both!
01:22:29 <Swenn> Kneiva: Already tried the both! Nothing seems to work
01:23:22 <Kneiva> Swenn: ok, unfortunately I can't help you more
01:23:28 <edwardk> kqr: np. when i first started with haskell i spent months trying what you suggested here before i finally gave it up as a bad idea. anything i can do to sparse others the pain i went through is good =)
01:23:32 <Swenn> Kneiva: To bad! Thanks anyway
01:24:19 <ben_> Hi guys, is there some way to tell cabal to try different hackages in order? I've found the remote-repo setting, but I think that assumes that you're operating against a full hackage mirror?
01:26:14 <startling> ben_, it's kind of a pain but you can cabal sandbox add-source things
01:35:31 <edwardk> kqr: another issue is that if you ever don't pick the instance and it could otherwise be subject to defaulting.. with those constraints there it simply can't be.
01:35:50 <edwardk> well, you can use ExtendedDefaultingRules, but you generally don't want it to be
01:36:04 <edwardk> or if you do you're playing a more complicated game
01:36:46 <augur_> how does this Nat -> |Nat| truncation thing manage to preserve information?
01:40:06 <individual> what's a ribbon in Text.PrettyPrint?
01:40:53 <daGrevis> ski: hello! remember me from yesterday? the guy with splitByDigits
01:41:28 <ij> Can I make tuples programatically? Can I make a function of type Int -> (Int, Int), the lambda calculus way(like (*10))?
01:42:06 <kqr> edwardk, where defaulting means?...
01:42:40 <sbidin> :t (,)
01:42:41 <lambdabot> a -> b -> (a, b)
01:42:53 <kqr> ij, if you're asking for a point-free solution, sure. createTuple = join (,)
01:43:01 <kqr> ij, then createTuple 3 = (3,3)
01:43:54 <kqr> ij, so, by extension, join (,) n == (n, n)
01:44:16 <ij> Which package is join in?
01:44:26 <kqr> Control.Monad
01:44:35 <Draconis> hello I am inspiring to learn haskell on a windows development environment and I am trying to integrate with sublime text 2. The package says I must install hdevtools which fails since it expects a unix environment. I found a fork at https://github.com/mvoidex/hdevtools.git  but I am unsure how I install it after I clone it?
01:45:01 <maybefbi> *aspiring
01:45:15 <Draconis> thank you maybefbi
01:45:34 <Saizan> Draconis: run "cabal install" with no arguments from that directory
01:45:54 <kqr> Draconis, have you tried http://stackoverflow.com/a/19611239/1463507 ?
01:45:56 <Draconis> thank you Saizan.
01:46:18 <kqr> it says that you can't use cabal install for hdevtools on windows
01:46:59 <Draconis> thank you kqr that works great
01:47:28 <Saizan> running "cabal install" from the directory is the same as those runhaskell Setup.hs calls
01:47:45 <kqr> oh
01:47:54 <Saizan> well, a bit better since it'll install the deps if you don't have them
01:49:29 * hackagebot data-stringmap 0.9 - An efficient implementation of maps from strings to arbitrary values  http://hackage.haskell.org/package/data-stringmap-0.9 (SebastianPhilipp)
01:49:55 <ben_> startling, I'm running my own hackage, and I want it to fall back to the main one in the case that a package hasn't been mirrored yet
01:54:25 <daGrevis> > abs -1
01:54:27 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
01:54:27 <lambdabot>    arising from a use ...
01:54:33 <arkeet> > abs (-1)
01:54:34 <lambdabot>   1
01:54:37 <daGrevis> thanks
01:54:48 <arkeet> otherwise it tries to subtract 1 from abs
01:57:14 <daGrevis> can one function have guards and where together? i keep getting oarse error
01:57:16 <daGrevis> *parse
01:57:23 <arkeet> yes, but the where applies to the entire declaration
01:57:25 <arkeet> not an individual guard
01:57:45 <daGrevis> arkeet: http://vpaste.net/PYbKo it's an parse error sadly
01:57:52 <MattY> hello
01:57:57 <MattY> is | not bitwise or in haskell?
01:58:03 <arkeet> no
01:58:03 <MattY> (what is?)
01:58:09 <arkeet> try .|. from Data.Bits
01:58:12 <MattY> thanks
01:58:24 <arkeet> daGrevis: works for me
01:58:35 <arkeet> wait
01:58:46 <MattY> it's a golfing challenge. anything more elegant and concise than this?  [chr(x .|. y) | (x,y) <- zip (map ord "Nerd") (map ord "Geek")]
01:58:47 <arkeet> yep, works for me
01:58:52 <MattY> > [chr(x .|. y) | (x,y) <- zip (map ord "Nerd") (map ord "Geek")]
01:58:54 <lambdabot>   "Oewo"
01:59:48 <daGrevis> arkeet: http://vpaste.net/NdmCb can you please try full example with runhaskell?
02:00:17 <arkeet> > zipWith ((chr.).(.|.)`on`ord) "Nerd" "Geek"
02:00:19 <lambdabot>   "Oewo"
02:00:28 <MattY> neat :)
02:00:47 <arkeet> daGrevis: you should have a close look at where the parse error is.
02:00:50 <arkeet> in particular, ` is not '
02:01:11 <arkeet> :r
02:01:12 <arkeet> er
02:01:36 <daGrevis> arkeet: woah, I'm sorry. fixed it. thought now it runs forever :D
02:01:45 <arkeet> well, that's a start ;)
02:02:04 <arkeet> well
02:02:06 <arkeet> you wrote n = abs (-n)
02:02:10 <arkeet> that's a recursive definition ;)
02:02:41 <daGrevis> arkeet: yes, my bad. fixed it. thanks for all )
02:02:44 <dobblego> @type foldr (<|>) empty
02:02:45 <lambdabot> Alternative f => [f a] -> f a
02:02:49 <arkeet> :t asum
02:02:50 <lambdabot>     Not in scope: `asum'
02:02:50 <lambdabot>     Perhaps you meant one of these:
02:02:50 <lambdabot>       `F.asum' (imported from Data.Foldable),
02:02:52 <arkeet> :t F.asum
02:02:53 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
02:02:57 <dobblego> thanks
02:03:09 <MattY> I don't quite get how that works arkeet. (chr.).(.|.) <- what does that do
02:03:20 <MattY> the (chr.) part is tripping me
02:03:28 <arkeet> (chr .) f = chr . f
02:03:36 <arkeet> well,
02:03:41 <arkeet> it's a sort of idiom if you will.
02:03:47 <arkeet> ((f .) . g) x y = f (g x y)
02:04:10 <MattY> ah
02:04:14 <arkeet> (work it out!)
02:04:20 <MattY> like (f . g) but for two arguments?
02:04:23 <FreeFull> It's clearer if you just use something like .:
02:04:29 <arkeet> FreeFull: too bad that's not defined anywhere.
02:04:34 <arkeet> so, yeah.
02:04:49 <arkeet> MattY: and if you had five arguments, you could do ((((f .) .) .) .) . g
02:04:51 <FreeFull> It is defined in multiple places, in various libraries
02:04:52 <arkeet> ;)
02:04:55 <ij> arkeet, Does that even work?
02:04:58 <MattY> :)
02:05:00 <arkeet> ij: yep
02:05:15 <arkeet> > (((((f .) .) .) .) . g) a b c d e :: Expr
02:05:16 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
02:05:17 <lambdabot>    arising from a us...
02:05:19 <arkeet> doh.
02:05:34 <arkeet> :t \f g -> ((((f .) .) .) .) . g
02:05:36 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> a3 -> a4 -> b) -> a -> a1 -> a2 -> a3 -> a4 -> c
02:05:49 <arkeet> not much that something of that type could do.
02:06:01 <FreeFull> What if f takes 2 arguments and g 3?
02:06:07 <maybefbi> :t (fmap . fmap . fmap . fmap)
02:06:08 <lambdabot> (Functor f, Functor f1, Functor f2, Functor f3) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
02:06:13 <maybefbi> lol
02:06:20 <arkeet> FreeFull: what do you put in the second argument of f?
02:06:41 <arkeet> maybefbi: something for you to ponder:
02:06:49 <arkeet> :t fmap fmap fmap fmap fmap fmap
02:06:49 <lambdabot> (Functor f, Functor f1) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
02:06:50 <FreeFull> Something from the person calling the combination. The result from g goes into the first
02:06:51 <arkeet> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
02:06:52 <lambdabot> (Functor f, Functor f1) => (a1 -> a -> b) -> f a1 -> f (f1 a -> f1 b)
02:06:59 <arkeet> maybefbi: these are the same ;)
02:07:10 <FreeFull> :t fix fmap
02:07:14 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = f0 a0
02:07:14 <lambdabot>     Expected type: (a0 -> b0) -> a0 -> b0
02:07:14 <lambdabot>       Actual type: (a0 -> b0) -> f0 a0 -> f0 b0
02:07:20 <maybefbi> arkeet: wow
02:07:21 <FreeFull> thought so
02:07:43 <arkeet> note: it's not fmap (fmap (fmap ...))
02:08:01 <arkeet> :t \f -> f fmap fmap fmap fmap
02:08:02 <lambdabot> (Functor f, Functor f1, Functor f2, Functor f3) => (((a -> b) -> f a -> f b) -> ((a1 -> b1) -> f1 a1 -> f1 b1) -> ((a2 -> b2) -> f2 a2 -> f2 b2) -> ((a3 -> b3) -> f3 a3 -> f3 b3) -> t) -> t
02:08:08 <arkeet> huh uh.
02:08:42 <arkeet> let's pretend I didn't do that
02:08:57 <maybefbi> arkeet: :)
02:10:59 <MattY> what is | in haskell? hoogle doesn't help
02:11:06 <MattY> nothing?
02:11:10 <kartoffelbrei> MattY: syntax
02:11:19 <kartoffelbrei> it's use for pattern guards
02:11:20 <MattY> oh right.. :)
02:11:23 <arkeet> well, guards
02:11:26 <arkeet> pattern or not
02:11:30 <kartoffelbrei> s/use//used
02:11:32 <MattY> I know, brain fart
02:12:32 <Iceland_jack> MattY: http://www.haskell.org/haskellwiki/Keywords
02:12:59 <Iceland_jack> Used in data type definitions, list comprehensions, guards and fundeps
02:13:01 <MattY> thanks that should come handy
02:19:31 * hackagebot data-stringmap 0.9.1 - An efficient implementation of maps from strings to arbitrary values  http://hackage.haskell.org/package/data-stringmap-0.9.1 (SebastianPhilipp)
02:22:45 <ij> So utf8 works out of the box, correct?
02:23:26 <sbidin> ij: yes.
02:23:28 <Aleksejs> is there any shortened form for "Haskell"? Like "JS" for "JavaScript"
02:23:43 <Iceland_jack> Aleksejs: "HS" if anything
02:23:56 <KingOfKarlsruhe> lambda symbol?
02:24:33 <Iceland_jack> Lambdas are not unique to Haskell..., if you're going to use a symbol in the first place it would be (>>=)
02:24:38 <Iceland_jack> *operator
02:25:23 <Taneb> Aleksejs, hs
02:27:01 <MattY> > let [xs,ys] = ["foo","bar"] in zipWith (\x y -> x : [y]) xs ys
02:27:02 <lambdabot>   ["fb","oa","or"]
02:27:17 <MattY> any nicer way of doing that?
02:27:23 <MattY> (or at least shorter)
02:27:58 <frxx> @pl (\x y -> x : [y])
02:27:58 <lambdabot> (. return) . (:)
02:28:30 <Iceland_jack> ij: Haskell Data.Char.Char's are unicode code points (scalar values) and Data.Text.Text stoles code points as well
02:35:59 <MattY> > sequence [[1,2,3], [5,6,7]]
02:36:00 <lambdabot>   [[1,5],[1,6],[1,7],[2,5],[2,6],[2,7],[3,5],[3,6],[3,7]]
02:36:34 <MattY> what is the correct word for doing that? combining each element in a set with every other in another set
02:36:46 <johnw> cartesian product
02:37:05 <MattY> hanks
02:37:08 <MattY> thanks*
02:41:07 <arnsholt> Cross product is another name
02:41:56 <MattY> thanks too
02:46:25 <MattY> I don't quite get how sequence turns [m a] into m [a] for list monad?  we still end up with [[a]]
02:48:05 <Cale> MattY: Well, it does the same thing that it does with any monad
02:48:12 <Cale> sequence [] = return []
02:48:14 <yesthisisuser> m is the list constructor in this case
02:48:27 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
02:48:53 <Cale> In the list monad, "v <- x" means "select v from x in all possible ways"
02:49:14 <Cale> So, what this does is essentially a Cartesian product of the lists
02:49:25 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
02:49:26 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
02:50:54 <yesthisisuser> > sequence [Just 1, Just 2, Just 3]
02:50:56 <lambdabot>   Just [1,2,3]
02:51:10 <MattY> with sequence [IO a] it removes IO from all the elements and puts them in front. so I would have expected sequence to return [1,4,6,1,4,7...]
02:51:29 <Cale> It doesn't "remove IO"
02:51:44 <MattY> as far as types go
02:51:54 <Cale> It gives an action which executes each of the IO actions in the list of IO actions, and produces a list of the results.
02:52:28 <Cale> "Executing" a list in the list monad means picking one element from it in all possible ways.
02:52:57 <Cale> So, here, we're picking an element from each of the list of lists, and getting a list of the results, in all possible ways.
02:53:32 <MattY> ah right, we always get a list of results
02:54:36 <MattY> would it be possible to write list monad so that sequence [[1,2,3],[4,5,6]] returns [1,4,1,5..] ?
02:55:03 <Cale> Well, no, because the types say that it *must* be a list of lists
02:55:34 <Cale> (but also, there aren't so many options for what return and (>>=) do that still satisfy the monad laws)
02:56:45 <augur_> edwardk: when you studied ling, what aspects did you focus on?
02:57:41 <FreeFull> > sequence [[1,2,3],[4,5,6]]
02:57:43 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
02:57:55 <FreeFull> I don't see the problem with adding a concat/join
02:58:07 <arkeet> you could, but then you wouldn't have sequence.
02:58:07 <FreeFull> > join . sequence $ [[1,2,3],[4,5,6]]
02:58:09 <lambdabot>   [1,4,1,5,1,6,2,4,2,5,2,6,3,4,3,5,3,6]
02:58:17 <Cale> Well, you certainly can concat the result, but that's not sequence on its own then.
02:58:24 <FreeFull> Yeah
02:59:12 <yesthisisuser> On a completely different note, the record syntax in Elm is pretty cool
02:59:32 <quchen> MattY: Maybe this helps to understand sequence: https://github.com/quchen/articles/blob/master/functions_comprehensible.md#sequencemapm
02:59:48 <quchen> It's written out in glorious do notation. Helped me when I learned about it.
03:03:50 <arkeet> > filterM (const [False,True]) "abc"
03:03:52 <lambdabot>   ["","c","b","bc","a","ac","ab","abc"]
03:04:37 <quchen> :-)
03:04:58 <quchen> Do you want to keep or remove this element? - "yes"
03:05:44 <arkeet> haha
03:06:05 <arkeet> @remember quchen <arkeet> > filterM (const [False,True]) "abc" <quchen> Do you want to keep or remove this element? - "yes"
03:06:05 <lambdabot> I will never forget.
03:06:46 <quchen> Technically "and" would've been better.
03:07:05 <quchen> But then the joke would not have been.
03:07:07 <quchen> Dilemma!
03:09:33 * hackagebot crf-chain2-tiers 0.2.0 - Second-order, tiered, constrained, linear conditional random fields  http://hackage.haskell.org/package/crf-chain2-tiers-0.2.0 (JakubWaszczuk)
03:12:26 <Cale> quchen: I think "or" is fine for selecting between options.
03:12:52 <quchen> Cale: Sure, but the powerset keeps each element /and/ discards it.
03:13:04 <quchen> Speaking: or. Technical: and. That's what I meant.
03:14:34 * hackagebot concraft 0.8.1 - Morphological disambiguation based on constrained CRFs  http://hackage.haskell.org/package/concraft-0.8.1 (JakubWaszczuk)
03:19:34 * hackagebot concraft-pl 0.3.1 - Morphological tagger for Polish  http://hackage.haskell.org/package/concraft-pl-0.3.1 (JakubWaszczuk)
03:36:40 <tomejaguar> With a package number A.B.C when does one increment the A?  According to the PVP it seems OK to make arbitrary changes and only increment the B.
03:43:02 <johnw> i usually increment the A after a substantial refactoring/rewrite/redesign, or complete change in UI
03:43:30 <johnw> a change in A is like saying "This may not even work the same way as the old A"
03:46:31 <augur_> haskell cast's theme song has this very psychonaut feeling to me
03:46:43 <tomejaguar> johnw: OK, so it's an indicator to your users of a big change rather than something that has a technical meaning?
03:47:39 <johnw> yes
03:47:45 <johnw> a change in A means you may have to rewrite your code too
03:47:54 <johnw> a change in B means big features or changes, but nothing earth-shattering
03:48:00 <johnw> a change in C is usually a bug fix
03:48:39 <johnw> that said, I think a LOT of packages on Hackage could shift their version numbers up one, and lose nothing.  Too many have a leading zero that really means almost nothing
03:48:53 <johnw> edwardk did that recently, and I think it was a good decision
03:50:32 <linduxed> if you have a csv file and you take the contents of that file and use them to find corresponding objects in your database, would you call that "importing" the csv?
03:50:50 <linduxed> or "converting"?
03:51:01 <linduxed> i'm a bit at a loss for what to call it
03:51:19 <johnw> i would say you're finding an "image" of your csv in the database, where the csv is an index
03:51:50 <fizruk> linduxed, lookupByCSV :)
03:52:03 <linduxed> hmmm, lookup makes sense
03:53:03 <linduxed> is there some word like lookup which would encompass the notion of finding with the help of one column, then mutating with the help of the next column on the same row?
03:53:16 <linduxed> lookup makes sense only for the finding-part
03:53:26 <johnw> lookupThenMutate? :)
03:53:33 <linduxed> haha, yeah i guess
03:53:45 <fizruk> linduxed, or mutateAt
03:53:48 <linduxed> but you see why i started with the word "import" right?
03:54:17 <fizruk> linduxed, I think I don't
03:54:22 <linduxed> oh well
03:54:32 <linduxed> hmm, i'll give it some more thought
03:55:07 <johnw> selectAndApplyFromCSV?
03:55:50 <fizruk> linduxed, or maybe updateWithCSV ?
04:02:24 <dEPy> hi guys
04:02:54 <dEPy> I'd like to add line numbers to this fizz buzz solution:  let fizzbuzz =zipWith (++) (cycle ["","","Fizz"]) (cycle ["","","","","Buzz"])
04:03:52 <quchen> > zip [1..] "hello"
04:03:53 <lambdabot>   [(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]
04:04:02 <quchen> dEPy: ^
04:05:53 <dEPy> can't I somehow add humbers to existing result (list of strings) ?
04:06:15 <dEPy> I tried to do another zipWith on result with (map show [1..])
04:07:25 <dEPy> oh wait, that does work... seems like i didn't have a problem at all O_o
04:07:36 <quchen> > zipWith (\n str -> show n ++ " " ++ str) [1..] ["hello", "dEPy", "world"]
04:07:37 <lambdabot>   ["1 hello","2 dEPy","3 world"]
04:09:17 <tomejaguar> > take 20 $ zipWith (\i s -> if null s then show i else s) [1..] $ zipWith (++) (cycle ["", "", "Fizz"]) (cycle ["", "", "", "", "Buzz"])
04:09:18 <lambdabot>   ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","1...
04:09:32 <dEPy> oh yes, I wanted to know this :)
04:09:37 * hackagebot hruby 0.1.2 - Embed Ruby in your Haskell program.  http://hackage.haskell.org/package/hruby-0.1.2 (SimonMarechal)
04:09:49 <tomejaguar> dEPy: I like your solution :)
04:09:57 <dEPy> I was just so sure I can do it with one zip :)
04:10:23 <tomejaguar> dEPy: I guess you could use zipWith3
04:10:49 <dEPy> I tried but, should then function for combining take 3 args and (++) only take 2 ?
04:10:59 <dEPy> Guess then id have to create my own (+++) :)
04:11:15 <tomejaguar> The argument should be (\i s t -> let u = s ++ t in if null u then show i else u)
04:12:33 <tomejaguar> > take 20 $ zipWith3 (\i s t -> let u = s ++ t in if null u then show i else u) [1..] (cycle ["", "", "Fizz"]) (cycle ["", "", "", "", "Buzz"])
04:12:35 <lambdabot>   ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","1...
04:13:07 <dEPy> ah, cool :)
04:19:19 <epta> Looking for some haskell wrapper around git. With functions like get_branches :: [Branch], blame :: File -> (Revision, Author, String), etc. Something like git shell with types and possibility to use haskell routines
04:19:32 <epta> Are there any candidates?
04:19:37 * hackagebot filecache 0.2.2 - A Linux-only cache system associating values to files. The values are discarded when the files are modified.  http://hackage.haskell.org/package/filecache-0.2.2 (SimonMarechal)
04:19:49 <sachintyagi> I'm looking for the GUI version of the game of life. Anyone knows an implementation?
04:23:28 <alexander__b> is it possible to use runhaskell or hugs with larger projects that are structured like project/src/Main.hs project/src/project/other_stuff.hs?
04:24:04 <lpaste> jeeger pasted “Parsec parser test” at http://lpaste.net/94953
04:24:07 <alexander__b> (i.e. *easily*)
04:25:10 <alexander__b> the best thing would be if you could just uhm hugs project.cabal, and then it figured out the source stuff itself, but
04:26:18 <mr-> alexander__b: "cabal repl" might be what you want
04:26:26 <jeeger> Hey! I'm trying to create a parser for a little toy language using Parsec. I'm getting ahead, but I have a problem parsing boolean expressions containing relations. So I have to parse something like <expr> <relop> <expr>, but I can't use buildExpressionParser because the type of a relational expression is itself a boolean, but the operands are expressions. I know that I could refactor my grammar, or use try() to parse each operator, but
04:26:26 <jeeger> is there a better way thot doesn't involve refactoring the grammar? The code is here: http://lpaste.net/94953.
04:27:13 <alexander__b> mr-: no, I just wonder if users can run my game just using hugs or runhaskell, so without cabal build.
04:27:32 <alexander__b> also I'd like to run my game interpreted just to look at the resource use difference
04:29:15 <henk> morning
04:29:45 <lpaste> henk pasted “diddohs” at http://lpaste.net/94954
04:30:20 <Flonk> Just out of curiosity, is it possible to declare your own instances that you can use inside a deriving clause?
04:30:36 <mauke> Flonk: no
04:30:54 <Flonk> mauke: haha, okay
04:30:59 <mauke> you can write TH code to autocreate instances, but the deriving clause itself is hardwired into the compiler
04:31:47 <Flonk> mauke: I guess that's what for instance Lens does for makeLenses?
04:31:53 <mauke> yes
04:32:10 <mauke> (for instance indeed)
04:32:22 <Flonk> :D
04:32:36 <henk> I have a few questions regarding http://lpaste.net/94954: 1. I’d like hours and minutes be padded to 2 digits. Any hints how to do that? 2. I was told yesterday that I could replace the function in line 13 with a foldr, but I don’t accumulate a value, so I’m not sure that is correct. Can a fold or something else that is more elegant be used here? 3. Any general suggestion what to improve, make shorter,
04:32:37 <henk> make better readable or anything? (I’m more or less a noob, but willing to learn, so I’m grateful for pointers to documentation, functions I could use or anything, but I want to understand what I’m doing and keep the code readable, simple and sane!)
04:33:59 <henk> (I also do not understand how to fix what hlint suggests ):)
04:34:42 <dv-_> remove the do, like it says
04:35:52 <henk> dv-_: That was too easy ): It looks broken with that -> there at the end, which is probably why I didn’t just try it … Thanks
04:38:44 <hpc> mauke: deriving is even hardwired into the language, i think?
04:38:50 <mauke> yes
04:39:04 <mauke> but ghc supports more than haskell :-)
04:42:58 <Flonk> > do Nothing
04:43:00 <lambdabot>   Nothing
04:44:01 <jeeger> So I presume my question is stupid? Should I just refactor my boolean expression into relational and boolean operators and parse those separately?
04:50:39 <Saizan> jeeger: i don't see what the type has to do with this
04:51:45 <Saizan> oh, i guess i do
04:52:31 <rajeshsr> hi all
04:53:37 <rajeshsr> I remember an academic paper which proved that lazy evaluation + (Functional programming?) is strictly better than eager evaluation, for some problem within O(lgN)..
04:53:46 <rajeshsr> Does that ring a bell with anyone?
04:54:23 <rajeshsr> was that O(lgN) with respect to space?
04:54:29 <Saizan> jeeger: anyhow, if you don't get an answer it usually just means noone with a good grasp of what you're asking for is around
04:54:54 <rajeshsr> all i remember abou that paper is that there is a lazy evaluation involved and it is better than eager, strict evaluation..
04:55:23 <jeeger> Saizan: Ah, sorry for pestering then. I've just begun with Haskell and I thought I had a simple question, so I wondered why no one had answered.
04:55:49 <definity> Can someone tell me why i keep getting the "parse error on input `='" error?
04:56:10 <mr-> definity: not without seeing your code.
04:56:16 <Saizan> jeeger: i think one design problem you might be facing is that you're trying to do some typechecking in your parsing, so the tools are not quite up for it
04:56:17 <definity> the code is: doubleMe x = x + x
04:56:34 <joelmo> definity: x can't be bound twice
04:56:39 <joelmo> i believe
04:56:44 <Saizan> definity: that's fine in a file
04:56:57 <Saizan> definity: are you trying to feed it to the repl?
04:57:00 <definity> not in ghci?
04:57:07 <Saizan> no, in ghci you have to use let
04:57:07 <definity> Im in gchi
04:57:13 <definity> oh okay
04:57:15 <mr-> definity: no, there you'd have to write let doubleMe x = x + x
04:57:25 <definity> cool thanks
04:58:07 <Saizan> rajeshsr: http://dl.acm.org/citation.cfm?id=969871
05:02:38 <rajeshsr> Saizan, thanks! That was what i was looking for.
05:03:37 <ben_> are acid state databases relocatable?
05:04:11 <donri> ben_: sure
05:04:39 * hackagebot language-puppet 0.10.2 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.10.2 (SimonMarechal)
05:06:54 <mike3> y
05:18:10 <ben_> donri, so I can just copy the whole directory somewhere else and carry on?
05:18:24 <jophish> Yo yo yo
05:19:41 <jophish> Do people here play golf?
05:19:44 <jophish> "Write a function that takes a string consisting of numeral characters and returns all possible alpha character strings of same length as input that correspond to the keypad of a typical telephone."
05:21:11 <jophish> I got this: http://lpaste.net/94955
05:21:27 <jophish> I could shave off a few characters, but I don't know if it would be so nice
05:31:08 <donri> ben_: should work yes. probably want to make sure to close any open handles first and wait for them to return, though.
05:31:34 <donri> mostly because locking. i don't think "close" is necessary for any durability purposes
05:32:35 <FireFly> jophish: would we have  1 => space, or does 1 never appear in the input?
05:34:39 <FireFly> oh, from your code I guess the latter
05:35:09 <ben_> donri, I'm already having to run find . -name "open.lock" | xargs rm anyway :-)
05:35:39 <donri> ben_: find -delete :)
05:36:02 <donri> . is implied
05:38:35 <jophish> FireFly: I'm assuming that 1 will never appear
05:44:41 * hackagebot xml-picklers 0.3.4 - XML picklers based on xml-types, ported from hexpat-pickle  http://hackage.haskell.org/package/xml-picklers-0.3.4 (PhilippBalzarek)
05:49:03 <malvarez> Does anybody know of any good libraries for linear algebra over finite fields?
05:50:41 <FireFly> > let repeatedly f x | x == mempty = mempty | otherwise = let (y,y') = f x in y:repeatedly f y' in repeatedly (splitAt 3) ['a'..'o']
05:50:42 <lambdabot>   ["abc","def","ghi","jkl","mno"]
05:50:55 <FireFly> ↑ does anything like `repeatedly` exist? I can't think of anything good..
05:51:01 <FireFly> and hoogle gives me nothing
05:51:42 * FireFly trying to compress jophish's lookup list
05:52:13 <FireFly> jophish: anyway, for starters I think you could drop the first two elements of the list and replace digitToInt with something manual with ord and sub, no?
05:52:37 <FireFly> (such that you map '2' to 0 instead, by subtracting two more from each character's ASCII value)
05:53:11 <malvarez> FireFly perhaps you can use Data.List.unfoldr?
05:53:23 <FireFly> Hm
05:53:41 <FireFly> Yes, probably
05:54:35 <sie> Can has hashmaps/dicts?
05:55:03 <sie> Oh, hashtables they're called.
05:55:14 <FireFly> sie: Data.Map?
05:55:32 <FireFly> Altohugh it's backed by a tree instead I think
05:55:46 <Philonous_> sie: http://hackage.haskell.org/package/unordered-containers
05:56:56 <malvarez> Aren't ghc's hashmaps relatively slow anyways?
05:57:54 <malvarez> I remember Jon Harrop ranting about that
05:58:14 <jophish> FireFly: I could't really think of a way to do that which ended up being smaller
05:58:29 <Sagi> I could use some advise on proper API design. I have a couple of functions doing similar things. Three of them can be implemented purely, without monads. One of them requires a Reader monad. I want to use them interchangeably. Should I change the other type signatures and just not use the Reader? Or should I do something else?
05:59:48 <Sagi> the general idea is to make a higher order function and pass one of the functions to do the computation. But that's kind of difficult with different signatures?
06:00:33 <sie> Hmm, why does Data.Map's ghc docs don't have fromList in it?
06:01:27 <malvarez> Sagi: hardly an expert here but couldn't you rewrite the function that lives in the reader monad as a pure function?
06:02:01 <Sagi> I technically can, but then I need to pass it an argument which I can only define itself in the reader Monad.
06:02:20 <bergmark> the reader monad is pure
06:02:21 <Sagi> I don't mind having the higher order function in the reader monad
06:02:35 <Sagi> I should've said monadic
06:02:38 <Sagi> sorry about that
06:02:45 <mr-> sie: http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map-Lazy.html
06:03:33 <malvarez> bergmark: sure, my bad, I meant pure as in regular, plain function
06:04:28 <malvarez> Sagi, could you post your current api?
06:04:58 <Swenn_> Anyone experience with Yesod?
06:05:15 <ski> bergmark : all Haskell operations are pure
06:05:15 <Sagi> malvarez: well, it's quite a mess. You might be better served with some context
06:05:33 <bartavelle> Swenn_, you should just ask the question (and there is also a #yesod chan)
06:05:46 <Swenn_> Alright!
06:06:34 <bergmark> ski: :)
06:06:46 <malvarez> True enough, all Haskell expressions are pure
06:09:32 <ski> @where purely-functional
06:09:32 <lambdabot> "What is a Purely Functional Language?" by Amr Sabry in 1993-01 at <https://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps>
06:11:22 <bergmark> Sagi: usually i prefer to have functions that don't need the monad stack explicitly stating they don't use it
06:12:22 <malvarez> ski: that looks interesting
06:12:32 <Swenn_> How would one select al entries from a entity with persistent(yesod)
06:15:08 <bergmark> Swenn_: selectList [] [] i think
06:15:43 <Swenn_> bergmark: How does selectList know which type to retrieve?
06:16:23 <bergmark> it will usually infer it, you can supply a tyge signature if needed
06:16:36 <bergmark> Swenn_: http://www.yesodweb.com/book/persistent
06:28:26 <lpaste> henk pasted “diddohs” at http://lpaste.net/94956
06:28:30 <henk> I have a few questions regarding http://lpaste.net/94956: 1. I’d like hours and minutes be padded to 2 digits. Any hints how to do that? 2. I was told yesterday that I could replace the function in line 13 with a foldr, but I don’t accumulate a value, so I’m not sure that is correct. Can a fold or something else that is more elegant be used here? 3. Any general suggestion what to improve, make shorter,
06:28:32 <henk> make better readable or anything?
06:29:39 <bennofs> henk: In line 13, that line with "forM_ ..."
06:29:41 <bennofs> ?
06:33:13 <Rylee> -Hey everyone, question - in Haskell, which is more CPU efficient? takeWhile (< 4000000) [0..], or [0..4000000]
06:33:37 <henk> bennofs: argh, sorry, line 23, not 13
06:34:15 <chrisdone> Rylee: probably the latter, but not by much. but always test it if you really need to know
06:34:29 <bennofs> Rylee: They aren't equal iirc
06:34:47 <bennofs> > takeWhile (< 3) [0..] == [0..3]
06:34:48 <lambdabot>   False
06:34:54 <bennofs> > [0..3]
06:34:55 <lambdabot>   [0,1,2,3]
06:34:59 <bennofs> > takeWhile (< 3) [0..]
06:35:00 <lambdabot>   [0,1,2]
06:35:04 <Rylee> I see, okay
06:35:13 <chrisdone> bennofs: i don't think that was his point
06:35:20 <tdammers> off-by-one, so what
06:35:23 <Rylee> I guess I meant takeWhile (< 4000001)
06:35:36 <tdammers> I'd use <=
06:35:48 <Rylee> An important distinction in real code. Thanks.
06:35:50 <tdammers> 4000001 isn't really what you're trying to express here
06:35:57 <bennofs> If the difference matters to you, I'd profile it
06:36:12 <tdammers> "up to and including 4000000" is what you're saying, so that's what you should write
06:38:05 <maik_> I am trying to create my own Functor but I am struggling a bit. I wrote this `instance Control.Monad.Instances.Functor CMaybe where  `
06:38:21 <maik_> I am a little bit confused what I have to import
06:39:28 <bergmark> maik_: you don't have to import anything for Functor, it's exported by Prelude
06:39:28 <chrisdone> maik_: you can just write instance Functor CMaybe where …
06:40:05 <maik_> hm okay, I am pretty sure that I have tried that.
06:40:06 <donri> or use DeriveFunctor ;)
06:40:08 <maik_> *testing*
06:40:26 <bergmark> bad donri
06:40:35 <ski> malvarez : you might also be interested in "Referential Transparency, Definiteness and Unfoldability" by Harald  Languages
06:41:17 <malvarez> ski: I'll check it out, thanks
06:42:14 <maik_> I get "No explicit method or default declaration for `Prelude.fmap" then :( I upload the code
06:42:22 <ski> er, "Referential Transparency, Definiteness and Unfoldability" by Harald Søndergaard,Peter Sestoft in 1987-11-30,1990-01-04 at <http://www.cs.tufts.edu/~nr/cs257/archive/peter-sestoft/ref-trans.pdf> and "Non-determinism in Functional Languages" by the same authors in 1988-08,1992-05 at <http://comjnl.oxfordjournals.org/content/35/5/514.abstract>
06:42:31 <ski> malvarez ^
06:42:32 <donri> maik_: you need to define fmap
06:42:34 <chrisdone> maik_: sure, fmap is the method that you have to implement for Functor
06:43:10 <malvarez> ski: right on my paper stack they go
06:44:12 <chrisdone> monochrom: re your report -- yeah, that's what the ast info helps with
06:45:33 <maik_> my code looks like this https://gist.github.com/MaikKlein/7214769
06:45:44 <maik_> haven't I implemented fmap?
06:46:02 <chrisdone> maik_: it needs to be indented two spaces
06:46:07 <maik_> oh
06:46:22 <chrisdone> =)
06:46:30 <maik_> :)
06:46:36 <maik_> thanks
06:46:40 <chrisdone> welcome
06:47:04 <donri> no, four spaces!
06:47:12 <Flonk> ^
06:47:55 <chrisdone> donri: ho, ho, ho!
06:54:33 <Apocalisp> What do people use for graph manipulation? Data.Graph?
06:55:10 <ski> malvarez : <http://www.informatik.uni-kiel.de/~curry/listarchive/0856.html>,<http://www.haskell.org/pipermail/haskell-cafe/2012-July/102544.html>,<http://stackoverflow.com/questions/210835/what-is-referential-transparency/9859966#9859966>,<http://www.cas.mcmaster.ca/~kahl/reftrans.html> might also be fun
06:56:03 <blueonyx> Apocalisp: there is also fgl the functional graph library
06:56:12 <Apocalisp> blueonyx: Awesome, thanks
06:57:01 <Apocalisp> My specific application is that I have a lot of rather small directed graphs that don't change very much but I need to find nodes quickly and traverse edges from those nodes in both directions.
06:58:40 <malvarez> ski: well, that should definitely help me in my quarrels with purity
06:59:25 <vlatkoB> Is it possible to sort elements in Pipes flow?
07:02:33 <donri> vlatkoB: that would seem rather contrary to the point of using pipes in the first place?
07:04:12 <vlatkoB> so, the solution would be to exit pipe, sort and renter other part of a pipe?
07:05:09 <donri> vlatkoB: i mean you can't sort without bringing the whole thing into memory
07:05:49 <maik_> I started learning haskell a few days ago and I have nearly finished the book learnyouhaskell and I really want to have a look at FRP. What resource would you recommend me for FRP?
07:06:08 <maik_> and there are tons of different FRP libs out there and I have no idea how they differ
07:06:25 <maik_> but I believe most of them are doing the same thing
07:07:11 <vlatkoB> donri: yes, indeed. Haven't thought of that. Thanks.
07:07:21 <donri> vlatkoB: also i'm not sure pipes provide a way to detect termination within a pipeline
07:07:45 <donri> vlatkoB: unless you use pipes-parse, maybe
07:09:45 <donri> maik_: not haskell but elm is quite approachable to grok frp. there's also helm which is supposed to be similar, but in haskell
07:11:31 <donri> maik_: http://elm-lang.org/  and  http://helm-engine.org/  btw
07:12:19 <chrisdone> helm has the coolest logo
07:12:21 <vlatkoB> donri: I see there is a groupBy function, but it seems it is grouping adjacent elements. I'll take a look at it.
07:12:26 <chrisdone> elm's logo is lacking in awesome
07:14:00 <shergill> edwardk: in the cache oblivious maps talk, what is the wave <?> datastructure you mentioned?
07:15:03 <maik_> donri, okay thanks, I'll have a look at helm
07:16:25 <zRecursive> :t groupBy
07:16:26 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
07:18:00 <shergill> http://www.youtube.com/watch?v=P3pLDpbzqCw&feature=youtu.be anyone care to decipher what the datastructure being mentioned is at ~51:30?
07:19:20 <shergill> hmm wavelet trees i think
07:20:11 <Sagi> bergmark: so how would you abstract over functions that either do or don't use some monad stack?
07:20:26 <donri> Sagi: Identity?
07:20:49 <Sagi> hmm
07:21:14 <chrisdone> Sagi: like what?
07:21:16 <Sagi> that'd mean that my monad-free functions suddenly get a Foo -> Identity Bar signature, right?
07:21:30 <chrisdone> yeah
07:21:31 <donri> Sagi: liftM?
07:21:48 <Sagi> donri: I know how to do the code, I'm just wondering about the types.
07:22:11 <Sagi> I want to make a higher order function accepting functions with or without monad stack
07:22:15 <Sagi> oh wait
07:22:19 <donri> Sagi: that's what liftM does
07:22:22 <Sagi> I think I know what you mean
07:23:00 <Sagi> :t liftM
07:23:01 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
07:23:49 <Sagi> cool
07:23:52 <Sagi> thanks :-)
07:25:12 <bergmark> yeah thats what i meant, it's trivial to lift the nonmonadic functions
07:28:15 <quchen> Can someone explain what pipes-parse has to do with parsing?
07:32:38 <augustss> Ahoy!
07:32:46 <dcoutts_> @arr!
07:32:46 <lambdabot> Yeh scurvy dog...
07:32:47 <donri> quchen: it provides look-ahead via push-back
07:32:55 <dcoutts_> lambdabot is so rude
07:33:16 <ski> hiya augustss
07:33:25 <quchen> donri: So it's really just the most low-level parts of a lookahead parser
07:33:31 <ski> how's the ship ?
07:33:37 <augustss> My Ahoy! was legitimate, since I'm on a ship. :)
07:34:06 <donri> quchen: yes
07:34:33 * ski . o O ( look-behind via pull-out )
07:35:32 <donri> quchen: it provides an idiom and some utilities, not a complete parser combinator library. see pipes-attoparsec
07:35:48 <donri> quchen: oh and pipes-binary
07:35:58 <quchen> donri: Ah, I missed the attoparsec package.
07:36:16 <quchen> Pipes-binary I've used, but I didn't realize it used pipes-parse.
07:36:42 <quchen> But makes sense of course, as it has to read, then deserialize, then push stuff back in the source
07:36:45 <Sagi> I still have a hard time understanding why I shouldn't put class constraints in type definitions.
07:36:53 <Sagi> I seem to ``need'' them all the time
07:36:57 <Sagi> and I know I shouldn't
07:38:19 <Twey> What's the least horrible Haskell OpenGL/GLSL library around?
07:39:23 <Twey> E.G. not referreng to everything with GLuints would be nice :þ
07:39:24 <alexander__b> is there a function that does a /= 0? just to uhm not have to write /= 0 heh
07:39:36 <alexander__b> Twey: gloss? depends on what you want to do and how low-level you need it to be
07:39:41 <ski> Sagi : the main reason is that as they currently work, they're pretty useless (doesn't do what you presumably want them to do)
07:39:52 <donri> alexander__b: http://hackage.haskell.org/package/monoid-subclasses-0.3.3/docs/Data-Monoid-Null.html  :P
07:40:02 <augustss> alexander__b: you can make one
07:40:05 <alexander__b> donri: yeah, not importing stuff just to do that hehe
07:40:27 <donri> alexander__b: why are you looking for zero, though?
07:40:28 <alexander__b> augustss: yes, I'm just wondering if there *is* one. I'm just doing /= 0 one place in the code, so making a function for it might be overkill at this stage. :-P
07:40:36 <donri> alexander__b: in what way is zero special?
07:40:53 <alexander__b> donri: if it is zero, it means the ball is at rest.
07:41:03 <donri> alexander__b: you can pattern match on number literals
07:41:14 <quchen> … which desugars to (==), no?
07:41:21 <augustss> Yes
07:41:22 <donri> i think so, yes
07:41:23 <Twey> alexander__b: It's for an assignment, so I think I need it to be close to the actual GL API… but I'd like to sidestep some of the type nastiness if at all possible, and preferably avoid GLUT's callbacks and IORefs for some kind of FRP
07:41:30 <ski> Sagi : in some cases, you can put constraints on constructors in GADT syntax, and it'll work sensibly (for some applications) -- namely the type "hides" the constraint; when you wrap, you have to provide the constraint; when you unwrap, you get the constraint *back* (unlike with constraints on usual (non-GADT) `data' types)
07:41:50 <alexander__b> the whole function would just be "notLaunched Ball _ _ _ v = v =/ 0"
07:42:07 <chrisdone> Twey: what are you up to these days?
07:42:28 <ski> Sagi : still, this won't help any with the intended application of having the type also "abbreviate" the constraint, so that you wouldn't have to type them explicitly in signatures (and instances)
07:42:36 <Twey> chrisdone: Uni, type theory, UI design
07:42:44 <Twey> chrisdone: You?
07:42:54 <alexander__b> Twey: the only way to really learn the horror that is opengl is going full low level. :-) I have only done it with C++ though, so IDK about Haskell.
07:42:55 <Sagi> ski: yeah that's exactly why I wanted to use them.
07:43:05 <Sagi> as some kind of seldocumenting type
07:43:10 <Sagi> self*
07:43:23 <alexander__b> glut was terribad in my opinion though. it made SDL 1.2 look like the best thing ever...
07:43:23 <donri> Sagi: i think the point is mostly that type classes are open, so it doesn't really "do what you mean" in a datatype, you don't get more type safety, not really, and you don't get more convenience either
07:43:24 <chrisdone> Twey: fun! working at fp complete
07:43:39 <Twey> alexander__b: I know it (approximately) already, but now I have to program a bunch of things in it and I'd like to not be passing integer identifiers around :þ
07:43:53 <Twey> chrisdone: Ah, neat!  What are you doing there?
07:43:58 <Sagi> donri: well, I would argue the convenience point
07:44:05 <donri> i kinda think DatatypeContexts do have a use with the coming closed type families though
07:44:12 <ski> Sagi : if your constraints get large, you could try declaring a class having the constraints as superclasses (if possible), or use constraint synonyms (requires extension)
07:44:24 <chrisdone> Twey: working on the school of haskell and the IDE
07:44:34 <dolio> edwardk, jmcarthur: I realized the problem.
07:44:38 <Twey> Oh yeah, you guys were talking about an IDE
07:44:42 <edwardk> ?
07:44:44 <ski> donri : i'm not sure what "get more type safety" would mean in this context
07:44:49 <Sagi> they're not that large. It's just that I'm using Haskell as part of my thesis, and I want non-Haskellers to be able to make sense of it all.
07:44:59 <Sagi> which is kind of hard without sensible naming :-)
07:45:09 <donri> Sagi: what convenience? you have to put the context on every usage site too, even ones that wouldn't otherwise need it
07:45:13 <dolio> edwardk, jmcarthur: wat st = runFree st (unsafeInterleaveST . return . Done) (fmap Step . unsafeInterleaveST . join)
07:45:15 <augustss> Non-Haskellers?  Ignore them. ;)
07:45:41 <ski> Sagi : perhaps you can use constraint synonyms to rename classes to the names you prefer then ?
07:46:02 <donri> ski: if you're using contexts as predicates more than "interfaces". something like that.
07:46:09 <dolio> edwardk, jmcarthur: You need to interleave the base case as well, or else  you demand the second-last stuff too eagerly.
07:46:20 <Sagi> I'll google that
07:46:23 <FreeFull> alexander__b: SDL does a lot more than GLUT too
07:46:27 <ski> re that, i sometimes miss being able to rename-on-import (and preferably also rename-on-export)
07:46:31 <FreeFull> And with 2.0 things are even better
07:46:41 <alexander__b> FreeFull: yes. sfml is probably better if you just want a window.
07:46:41 <dolio> That's what the two-interleaves-in-the-non-base-case is giving you that the other isn't.
07:46:49 <edwardk> dolio: is that still an issue with the IO based version?
07:46:58 <dolio> Probably.
07:47:24 <dolio> Unless you mean the one that uses unsafePerformIO.
07:47:26 <FreeFull> Are C functions that want callbacks as one of the parameters a weakness of Haskell FFI?
07:47:45 <chrisdone> FreeFull: weakness as in you have to define a wrapper and it's annoying, yeah
07:48:00 <edwardk> not sure how it could be. trying to figure that out
07:48:04 <edwardk> walkST l = runSlow l Stop Step (Unsafe.unsafePerformIO . Unsafe.unsafeSTToIO)
07:48:14 <dolio> No, no, that one's different.
07:48:20 <dolio> That's fine.
07:48:36 <edwardk> ok, my world view hasn't shattered then =)
07:48:49 <edwardk> i'm going to stick to this version as it doesn't have the missng noDuplicate problem
07:49:07 <Sagi> hmm, I think http://stackoverflow.com/questions/12717301/haskell-type-synonym-declaration-with-constraint-possible explained to me why this won't help. I think that was the point donri was making. I think I'm starting to get it..
07:49:12 <dolio> edwardk: The problem is: 'interleave $ do n <- m ; r <- n ; return $ Step r'
07:49:35 <edwardk> ohh
07:49:35 <edwardk> now i see it
07:49:39 <dolio> Not doing 'm' right away is based on not needing 'n' right away, which requires 'n' to be interleaved, but the base case isn't.
07:50:04 <edwardk> dolio++ # unsafeInterleaveRocketScience
07:50:25 <FreeFull> And this is why I keep away from unsafe stuff
07:50:44 <edwardk> FreeFull: this'll all wind up behind a safe wrapper
07:50:49 <chrisdone> unsafe stuff comes to you. no one ever asks for it =p
07:51:01 <edwardk> FreeFull: it just lets me achieve a bit of a holy grail in terms of data structure design
07:51:03 <dolio> I'm also not super sold on the noDuplicate thing, but it's your decision.
07:51:09 <FreeFull> I'd rather be writing ASM. Then I know what to expect =P
07:51:19 <dolio> You could get duplicated work all the time in normal lazy code, but you don't worry about it.
07:51:19 <chrisdone> “YOU NEED ME” “I don't, I'll find another way, I swear!” “Har, har, haaar! I'll be waiting.”
07:51:25 <edwardk> i think i could show all the operations i want to perform in ST are actually idempotent
07:51:50 <edwardk> except for a few, like making the new target vector where if one proceeded with the wrong vector you'd get bad results.
07:52:37 <edwardk> but thats a much less safe set of invariants than i use now
07:53:25 <FreeFull> Is what you do tied to only work in GHC?
07:53:31 <dolio> I guess duplication is a bit more dangerous in this case.
07:55:38 <NewGuy> trying to create a offset/ shift for my caesar/enigma cipher for the AZ alphabet
07:55:40 <NewGuy> offset  :: Char -> Cipher -> Int -> Char
07:55:46 <NewGuy> offset cipher rota = drop (26 - rota) ++ take (26 - rota)
07:57:09 <NewGuy> error: exp: take (26 - rota) term: 26 - rota type [Char]   does not match Int
07:57:29 <NewGuy> Tried switching around and before I had does not match Char.
07:57:45 <Twey> chrisdone: This IDE looks pretty cool, but quite mouse-heavy
07:57:53 <NewGuy> Any ideas on other ways instead of take and drop _
07:57:57 <NewGuy> ?
07:58:05 <triliyn> NewGuy: take (26 - rota) is a function that takes a list
07:58:10 <FreeFull> NewGuy: Your cipher there is actually of the type Char, and rota is of the type Cipher
07:58:14 <bartavelle> NewGuy, I can only see ideas without take and drop, those work on lists
07:58:27 <NewGuy> type Cipher = String
07:58:31 <NewGuy> alph :: [Char]
07:58:35 <NewGuy> alph = ['A'..'Z']
07:58:43 <FreeFull> NewGuy: I mean, the function parameter cipher
07:58:49 <bartavelle> also you wrote "offset cipher rota" where is should have been "offset char cipher rota"
07:59:01 <edwardk> yeah if it was just duplicating the start of the calculation i'd have no problem
07:59:49 <bartavelle> NewGuy, you can't nativelly do operation between different "int" types, such as Char - Int, you have to convert them first to a common representation, using fromIntegral for example
07:59:59 <chrisdone> Twey: yeah, mgsloan and I want it to be completely keyboard navigable, but that will come after we've finished churning features
08:00:10 <Twey> Aye
08:00:19 <Twey> Is it scriptable?
08:00:21 <chrisdone> Twey: we'll also be releasing support for third-party editors, like emacs, vim, sublime
08:00:33 <chrisdone> Twey: that's planned
08:00:54 <Twey> Oooh.
08:00:59 <Twey> That will be nice
08:01:13 <chrisdone> Twey: the client-side's configuration is moving into an XMonad-style configuration, and extension client-side would be in Fay, and server-side, not clear yet
08:01:31 * Twey nods.
08:01:32 <NewGuy> hmm, just confused myself. Turned it around anmd swtch it around a couple of times just confused
08:01:42 <triliyn> Is Char an int type? I would have thought you have to use ord and chr (or whatever those functions are)
08:01:51 <NewGuy> Thanks all of you
08:01:54 <FreeFull> Char isn't an int type
08:01:56 <Twey> Nice features, especially for Yesod
08:02:05 <bartavelle> Triliyn: my bad, this is true
08:02:13 <FreeFull> You have to use ord and chr, or fromEnum and toEnum
08:02:13 <NewGuy> no it
08:02:38 <NewGuy> its not, maybe ord and chr is bette rfor me then.
08:03:00 <NewGuy> Should I paste full code for making it easier _
08:03:01 <chrisdone> Twey: indeed, it's possible for people to deploy a web app in a few steps. i like that. half of the benefit is the stable 'everything builds with everything else' package set (stackage)
08:03:01 <Twey> chrisdone: Is Snoyman on-board?
08:03:11 <NewGuy> ?
08:03:11 <chrisdone> Twey: yup
08:03:27 <Twey> That's awesome
08:03:53 <chrisdone> :D
08:05:11 <Twey> Ease of setup is still pretty much the only thing PHP has over everything else; if we could have services like this, we might actually succeed at replacing it :þ
08:05:35 <chrisdone> right ^_^
08:05:40 <NewGuy> Thx for the response so far btw
08:14:01 <robstewartuk> given data Foo = Bar | Baz deriving (Show) , is there a quick way to print all constructors of Foo ?
08:14:40 <geekosaur> in what context?
08:15:09 <robstewartuk> e.g. printConstructors : Foo -> [String]
08:15:20 <chrisdone> you'll want Data.Data for that
08:15:20 <geekosaur> :info will show you stuff in ghci. otherwise, you probably want to derive Enum and Bounded as well and then you can use [minBound .. maxBound] :: [Foo]
08:16:47 <chrisdone> λ> data Foo = Foo | Bar | Mu deriving (Typeable,Data)
08:16:47 <chrisdone> λ> map showConstr (dataTypeConstrs (dataTypeOf Bar))
08:16:47 <chrisdone> ["Foo","Bar","Mu"]
08:18:13 <Sagi> triples = liftM4 query ask (return $ f s) (return $ fmap toRDF p) (return $ f o)
08:18:34 <Sagi> that's awkward, right?
08:19:03 <chrisdone> yeah, use applicative
08:19:08 <Sagi> alternatively, I came up with triples = liftM queryWith ask     queryWith = \r -> query r (f s) (fmap toRDF p) (f o)
08:19:34 <Sagi> applicative means use (<$>) and (<*>), right?
08:19:47 <chrisdone> actually, yeah, there's no point if most of the args are pure
08:19:58 <robstewartuk> Sagi: `toRDF` ? What are you doing out of interest?
08:20:07 <Sagi> using your library :-)
08:20:20 <robstewartuk> heh, hurray !
08:20:20 <chrisdone> robstewartuk's RDF sense tingled
08:20:38 <robstewartuk> Sagi: Pull requests always welcome
08:20:41 <robstewartuk> ;-)
08:20:44 <Sagi> might send you one
08:21:01 <Sagi> I ran into the problem that rdf4h chokes on the (mandatory?) xml hearder in xml/rdf
08:21:17 <Sagi> I just deleted it from the input file, which seemed like the wrong solution :-P
08:21:17 <robstewartuk> Are you serious?? I'm trying to track that one down myself..
08:21:18 <Eduard_Munteanu> Hm, 'cutBy = fst .: unzip .: zip' seems useful, I wonder if it's part of any popular lib.
08:21:19 <robstewartuk> check this out:
08:21:28 <edwardk> robstewartuk: add deriving (Enum,Bounded)  then use  show [minBound .. maxBound :: Foo]
08:21:42 <robstewartuk> Sagi: https://github.com/UweSchmidt/hxt/issues/4#issuecomment-27145818
08:21:58 <Eduard_Munteanu> Or 'zipWith const' I suppose.
08:22:02 <Eduard_Munteanu> :t zipWith const
08:22:03 <lambdabot> [c] -> [b] -> [c]
08:22:11 <robstewartuk> Uwe suggests using a hxt arrow to do this in a more principled way.
08:22:37 <chrisdone> Eduard_Munteanu: what would by the point of cutBy?
08:22:53 <chrisdone> :t const :: [c] -> [b] -> [c]
08:22:54 <lambdabot> [c] -> [b] -> [c]
08:23:15 <Sagi> robstewartuk: I'm afraid my knowledge of Haskell falls way short to help you with that :-\
08:23:28 <Sagi> which is actually why I went with my cheap solution in the first place..
08:23:28 <Eduard_Munteanu> chrisdone: given two lists of different lengths, it cuts the first list to the length of the second.
08:23:38 <chrisdone> Eduard_Munteanu: ahh
08:23:52 <Sagi> chrisdone: so I should just stick with one of my two solutions?
08:23:54 <FreeFull> :t const `const` id
08:23:55 <lambdabot> a -> b -> a
08:24:02 <Sagi> It felt clumsy, but I don't know a better way :-)
08:24:41 <robstewartuk> Sagi: I've got all the W3C tests sat on a private branch locally. I need to fix this in order most of them. So, I'm waiting on Uwe's reply w.r.t. a hxt arrow that will remove the xml specification headers.
08:25:00 <Sagi> hmm, that's nice!
08:25:07 <chrisdone> Sagi: yeah, your latter one seems alright
08:25:15 <Sagi> chrisdone: okay, thanks!
08:25:36 <frx> can someone explain why don't types match in here?
08:25:39 <chrisdone> @let om f m = (m >>=) . flip f
08:25:40 <frx> > fmap unwords [getLine, getLine]
08:25:40 <lambdabot>  Defined.
08:25:41 <lambdabot>   Couldn't match expected type `[GHC.Base.String]'
08:25:42 <lambdabot>              with actual t...
08:26:14 <FreeFull> frx: You need to double fmap
08:26:18 <chrisdone> :t when `om` pure False $ return ()
08:26:19 <lambdabot> (Monad m, Applicative m) => m ()
08:26:25 <FreeFull> > fmap (fmap unwords) [getLine, getLine]
08:26:26 <lambdabot>   Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
08:26:27 <lambdabot>  Expected type...
08:26:30 <chrisdone> Sagi: as an alternative ^ =p
08:26:32 <FreeFull> Hmm, wait
08:26:36 <FreeFull> > fmap (fmap words) [getLine, getLine]
08:26:40 <lambdabot>   [<IO [[Char]]>,<IO [[Char]]>]
08:26:42 <FreeFull> There you go
08:26:53 <frx> I wanted to use unwords
08:27:01 <FreeFull> Unwords takes a list of strings
08:27:06 <frx> wait hmm
08:27:07 <FreeFull> And makes it into a single string
08:27:13 <Lethalman_> :t unwords . sequence
08:27:14 <frx> yeah that is what I wanted
08:27:14 <lambdabot> [[Char]] -> String
08:27:18 <chrisdone> triples = om query ask (f s) (fmap toRDF p) (f o)
08:27:32 <frx> Lethalman_ that seems to be it
08:27:33 <FreeFull> getLine is IO String
08:27:37 <Lethalman_> frx, not yet
08:27:40 <FreeFull> Do you want to make the two getLines into a single one?
08:27:41 <Lethalman_> :t unwords . concat . sequence
08:27:42 <lambdabot> [[String]] -> String
08:27:47 <frx> FreeFull yes
08:27:51 <geekosaur> :t unwords . sequence $ [getLine, getLine]
08:27:53 <lambdabot>     Couldn't match type `IO' with `[]'
08:27:53 <lambdabot>     Expected type: [Char]
08:27:53 <lambdabot>       Actual type: IO String
08:27:58 <geekosaur> not quite :)
08:28:04 <Lethalman_> it's unwords . concat . sequence
08:28:20 <FreeFull> :t unwords . concat . sequence
08:28:21 <lambdabot> [[String]] -> String
08:28:24 <FreeFull> Nope
08:28:35 <Lethalman_> ?
08:28:43 <FreeFull> fmap unwords . sequence
08:28:48 <Lethalman_> :t unwords . concat . sequence $ [getLine, getLine]
08:28:49 <lambdabot>     Couldn't match type `IO' with `[]'
08:28:49 <lambdabot>     Expected type: [String]
08:28:49 <lambdabot>       Actual type: IO String
08:29:01 * chrisdone watches the faill with delight
08:29:04 <Lethalman_> :t sequence $ [getLine, getLine]
08:29:05 <lambdabot> IO [String]
08:29:13 <Lethalman_> :t fmap concat . sequence $ [getLine, getLine]
08:29:14 <lambdabot> IO [Char]
08:29:29 <FreeFull> Yeah, you want unwords instead of concat there and it'll work
08:29:37 <Lethalman_> :t fmap unwords . sequence $ [getLine, getLine]
08:29:38 <lambdabot> IO String
08:29:53 <frx> yay :)
08:29:57 <Lethalman_> lol
08:30:45 <FreeFull> Lethalman_: I don't think you thought about the types hard enough =P
08:31:05 <Lethalman_> FreeFull, I didn't think enough in general :P
08:31:30 <zmanian> \help
08:34:31 <Sagi> chrisdone: tmx
08:34:32 <Sagi> tnx*
09:02:12 <cschneid> :t sequence
09:02:13 <lambdabot> Monad m => [m a] -> m [a]
09:04:09 <briennetheblue> is there a nice :: Monad m => m a -> (a -> m b) -> m a?  sort of like the monad bind version of <*
09:06:27 <geekosaur> at this point every Monad should also be an Applicative (and soon this will be enforced), so <* should work?
09:06:44 <ski> not what was sought
09:07:08 <FreeFull> briennetheblue: You can do   (<<) = liftM2 const
09:07:21 <mauke> not what was sought
09:07:24 <FreeFull> Or wait until all Monads are alternatives
09:07:43 <mauke> looks like I'll have to start kicking people
09:08:13 <FreeFull> It doesn't have the same type
09:08:16 <briennetheblue> it's doing something monadic so <* can't work
09:08:19 <FreeFull> But it is the Monad equivalent of <*
09:08:24 <mauke> no, it's not
09:08:27 --- mode: ChanServ set +o mauke
09:08:31 <mauke> ಠ_ಠ
09:08:36 <FreeFull> :t (<*)
09:08:37 <lambdabot> Applicative f => f a -> f b -> f a
09:08:41 <FreeFull> :t (liftM2 const)
09:08:42 <lambdabot> Monad m => m r -> m a2 -> m r
09:09:30 <briennetheblue> that's not what i meant
09:09:45 <FreeFull> Hmm, something matching your type signature..
09:10:01 --- mode: mauke set -o mauke
09:10:06 <briennetheblue> i meant sort of rather loosely :)
09:10:17 <briennetheblue> but i think you can see what i mean
09:10:32 <FreeFull> :t  \m f -> fmap f m >> m
09:10:33 <lambdabot> (Monad m, Functor m) => m b -> (b -> a) -> m b
09:10:38 <mauke> @. pl undo \mx f -> do { x <- mx; f x; return x }
09:10:38 <lambdabot> (. flip (liftM2 (>>)) return) . (>>=)
09:10:38 <FreeFull> Nope, that's not it
09:11:03 <mauke> :t (. flip (liftM2 (>>)) return) . (>>=)
09:11:04 <lambdabot> Monad m => m b -> (b -> m a) -> m b
09:11:10 <briennetheblue> like echoed = getLine ??? putStrLn :: IO String
09:11:15 <FreeFull> That's it, but it needs to be prettyfied
09:11:32 <ski> @type flip ((=<<) . liftM2 liftM const)
09:11:33 <lambdabot> Monad m => m a -> (a -> m b) -> m a
09:11:33 <ski> @type (. liftM2 liftM const) . (>>=)
09:11:34 <lambdabot> Monad m => m b1 -> (b1 -> m b) -> m b1
09:12:02 <ski> briennetheblue : how about those ^ ?
09:12:05 <FreeFull> That's the first time I've seen someone liftM2 liftM
09:12:48 <FreeFull> briennetheblue: That would just be bind
09:13:01 <ski> FreeFull : no
09:13:02 <FreeFull> Except that it returns the same thing as getLine
09:13:03 <FreeFull> Hmm
09:13:14 <briennetheblue> :t getLine >>= putStrLn
09:13:15 <lambdabot> IO ()
09:13:22 <FreeFull> Yeah
09:13:36 <FreeFull> \mx f -> do { x <- mx; f x; return x }    does match
09:13:48 <FreeFull> I've got it
09:13:52 * ski suggests calling this operation `after', and then `after_ :: Applicative i => i a -> i b -> i a' is `(<*)'
09:13:52 <briennetheblue> i just wondered if someone had already come up with a nice operator name for it
09:14:03 <briennetheblue> after is nice :)
09:14:06 <ski> so
09:14:17 <ski> er, no, s/after/before/, rather
09:14:19 <FreeFull> @pl \a b -> a >>= \x -> b >> return x
09:14:20 <lambdabot> (. ((. return) . (>>))) . (>>=)
09:14:27 <FreeFull> :t \a b -> a >>= \x -> b >> return x
09:14:28 <lambdabot> Monad m => m b -> m a -> m b
09:14:30 <ski>   echoed = getLine `before` putStrLn
09:14:31 <FreeFull> Nope
09:14:32 <FreeFull> Wrong
09:14:47 <FreeFull> :t \a b -> a >>= \x -> b x >> return x
09:14:49 <lambdabot> Monad m => m b -> (b -> m a) -> m b
09:15:02 <FreeFull> @pl \a b -> a >>= \x -> b x >> return x
09:15:02 <lambdabot> (. flip (liftM2 (>>)) return) . (>>=)
09:15:07 <briennetheblue> "after getLine putStrLn" reads nicely to though
09:15:09 <FreeFull> That's not any prettier
09:15:27 <ski> briennetheblue : `before' is better, both with infix and ordinary function application syntax
09:15:38 <briennetheblue> i suppose so
09:15:45 <mauke> FreeFull: ...
09:15:56 <mauke> do you read what other people are typing?
09:16:07 <ski> briennetheblue : `after getLine putStrLn' and  getLine `after` putStrLn  to me suggests `getLine' will be done after `putStrLn'
09:16:08 <FreeFull> mauke: I wanted to make an alternative formulation of what you wrote, but prettier
09:16:15 <ski> btw, iirc, there's an
09:16:24 <mauke> FreeFull: then why did you repeat it exactly?
09:16:26 <ski>   val before : 'a -> () -> 'a
09:16:33 <ski> in SML (or maybe it was OCaml ?)
09:16:40 <FreeFull> mauke: I was pointing out that what you wrote was right
09:17:31 <FreeFull> ski: How about   getLine `then` putStrLn
09:18:45 <ski> FreeFull : `(>>)' is commonly pronounced "then" (and before the infix operators were invented, it was often spelled `thenM', for some particular `M')
09:18:46 <geekosaur> was afraid of that... h2010 report says then is reserved
09:19:03 <FreeFull> Ok, probably not then
09:19:03 <ski> yea, that as well
09:19:08 <identity> I don't get it -- aren't we just talking about bind? getLine >>= putStrLn ?
09:19:16 <FreeFull> identity: Nope
09:19:23 <ski> > [x | x <- [0..], then takeWhile (x < 5)]
09:19:24 <lambdabot>   Unexpected transform statement in a list comprehension
09:19:25 <lambdabot>  Use -XTransformList...
09:19:25 <briennetheblue> "before" is good, I suppose it doesn't need some funny operator name.  thanks ski :)
09:19:28 <FreeFull> bind is   m a -> (a -> m b) -> m b
09:19:40 <FreeFull> What briennetheblue wants is   m a -> (a -> m b) -> m a
09:19:49 <identity> oh
09:20:15 <ski> briennetheblue : `after' could perhaps have worked, if you were prepared to change the order of the two arguments
09:20:21 <FreeFull> I wonder what a good fixity would be
09:20:23 <ski>   putStrLn `after` getLine
09:20:51 <ski> (in fact, perhaps that one would sometimes be a nice companion/alternative to `before'. cf. `(>>=)' vs. `(=<<)')
09:20:53 <FreeFull> ski: So natural bind order rather than the sequential order?
09:22:36 <identity> I don't see what uses a function with that type signature could have.. Not in the getLine `whatever` putStrLn example, anyhow.
09:23:10 <zq> :t (,)
09:23:11 <FreeFull> identity: Well, you want to output the string to the screen but still have it afterwards
09:23:11 <lambdabot> a -> b -> (a, b)
09:23:17 <zq> :t (,,)
09:23:18 <lambdabot> a -> b -> c -> (a, b, c)
09:23:28 <FreeFull> And you don't want to use do notation because it's too bulky
09:23:39 <zq> :t (--)
09:23:41 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
09:23:47 <FreeFull> zq: -- is comments
09:23:47 <identity> FreeFull: ah, so you could (foo `something` bar) >>= baz ?
09:23:58 <zq> FreeFull: not sure how (,,) makes sense
09:24:14 <Narvius> It's the 3-tuple constructor
09:24:15 <zq> FreeFull: i get how (,) could be a binary operator
09:24:15 <FreeFull> identity: Yeah, pretty much
09:24:25 <Narvius> It's not an infix operator
09:24:29 <FreeFull> zq: (a,b,c), get rid of the letters
09:24:39 <Narvius> Kinda how you can write "[] a" instead of "[a]" in type declarations
09:24:40 <fizbin> @type let foo ma bf = ma >>= (runKleisli $ (arr id &&& Kleisli bf) >>> arr fst) in foo
09:24:41 <lambdabot> Monad m => m b -> (b -> m c') -> m b
09:24:57 <Narvius> fizbin, that looks scary
09:25:12 <FreeFull> fizbin: That's overkill
09:25:21 <zq> :t (//)
09:25:22 <lambdabot> Ix i => Array i e -> [(i, e)] -> Array i e
09:25:27 <zq> why doesn't this work, then?
09:25:30 <FreeFull> It's like shooting a mosquito with an elephant gun
09:25:41 <zq> > (1 / 2 / 3)
09:25:43 <lambdabot>   0.16666666666666666
09:25:51 <zq> :t (//)
09:25:52 <lambdabot> Ix i => Array i e -> [(i, e)] -> Array i e
09:25:54 <FreeFull> zq: Because it's not special syntax. (,,) is just a thing, like Foo
09:26:25 <zq> FreeFull: just a "thing"?
09:26:31 <FreeFull> > let pair a b = (a,b) in pair 3 4
09:26:33 <lambdabot>   (3,4)
09:26:40 <FreeFull> (,) is basically the same as pair
09:26:48 <FreeFull> (,,) is the same but with 3 arguments, and so on
09:26:55 <Narvius> Isn't it more like (a, b) is syntactic sugar for (,) a b?
09:27:03 <FreeFull> Yep
09:27:27 <briennetheblue> fizbin, nice ;)
09:27:52 <zq> > let pair a b = (a / b) in pair 3 4
09:27:54 <lambdabot>   0.75
09:28:03 <zq> (/) is basically the same as pair
09:28:10 <zq> (//) is the same but with 3 arguments, and so on
09:28:13 <zq> except it isn't
09:28:38 <zq> not trying to troll, but very much not understanding why , -> ,, but / -/-> //
09:28:38 <Narvius> zq: You're claiming all birds can't fly because you saw a penguin.
09:28:48 <Narvius> Because (,) is not the infix operator ,
09:28:51 <Narvius> But (/) is /
09:28:59 <zq> ah
09:29:18 <Narvius> (,) is a type constructor, like "Just"
09:29:27 <Narvius> Value constructor?
09:29:37 <fizbin> briennetheblue: Still, it's really overkill for do {a <- ma; bf a; return a}
09:29:37 <Narvius> Which one is it, folks? :S
09:29:42 <geekosaur> data constructor
09:29:49 <Narvius> Okay.
09:29:55 <zq> can't hoogle it
09:29:58 <geekosaur> Just is a data constructor, Maybe is a type constructor
09:30:10 <Narvius> okay.
09:30:12 <Narvius> Thanks.
09:30:24 <fizbin> Narvius: Actually, (,) is both a type and a data constructor.
09:30:41 <Narvius> I realized that just before you said that, fizbin :P
09:30:54 <geekosaur> and tuple syntax is just weird, because it's actually hardwired syntax and not a normal operator
09:30:54 <Narvius> Incidentally
09:30:57 <fizbin> @type let t :: (,) Int String in fst t
09:30:59 <lambdabot>     The type signature for `t' lacks an accompanying binding
09:31:18 <fizbin> @type let t :: (,) Int String;t=undefined in fst t
09:31:19 <lambdabot> Int
09:31:23 <geekosaur> so trying to draw generalizations from tuple syntax is pretty much guaranteed to lead you wrong
09:31:24 <Narvius> I recently wrote a function with type "(a, b) -> (b -> Maybe c) -> Maybe (a, c)"
09:31:34 <Narvius> And I thought whether that could be generalized
09:31:43 <Narvius> Since the functor instance for (,) does pretty much what I want there
09:32:20 <Narvius> But "(Functor f1, Functor f2) => f1 b -> (b -> f2 c) -> f2 (f1 c)" is probably not possible?
09:32:47 <Lethalman_> Narvius, fmap is for (a -> b) -> (c, a) -> (c, b)
09:33:04 <Lethalman_> so may get (a, b) -> (b -> Maybe c) -> (a, Maybe c)
09:33:05 <Narvius> Yes, which is what I wanted here
09:33:12 <Narvius> I know
09:33:22 <Lethalman_> well you said Maybe (a, c)
09:33:24 <Narvius> the function roughly was
09:33:27 <Narvius> I know
09:33:28 <Narvius> lemme finish
09:33:53 <Narvius> fun f (a, b) = f b >>= Just . (,) a
09:34:20 <Lethalman_> good enough
09:34:25 <Narvius> The goal was to return nothing if the mapping fails, and I ended up using the Maybe monad instead of just fmap.
09:34:57 <Narvius> So I was thinking if, since both Maybe and "(,) a" are functors, whether that function could be generalized
09:35:06 <Narvius> What it would do was basically swap the inner and outer functors.
09:35:28 <Narvius> But I would probably need at least Applicative?
09:35:47 <Narvius> I'm not sure, I don't have that solid a grasp on the hierarchy, and I wanted to work that out as practice
09:36:16 <briennetheblue> i was thinking about something similar recently but with [] and (,) a
09:36:23 <Lethalman_> :t \(a, b) -> (a,) <$> f b
09:36:24 <lambdabot> Illegal tuple section: use -XTupleSections
09:36:37 <Lethalman_> :t \(a, b) -> (,) <$> a <*> f b
09:36:38 <lambdabot> (Show t, Applicative f, FromExpr (f a)) => (f a1, t) -> f (a1, a)
09:36:42 <Lethalman_> :t \f (a, b) -> (,) <$> a <*> f b
09:36:44 <lambdabot> Applicative f => (t -> f a) -> (f a1, t) -> f (a1, a)
09:36:56 <briennetheblue> you can only swap them in one direction though, of course
09:37:08 <Lethalman_> :t \f (a, b) -> (,) <*> a <*> f b :: Maybe (a,b)
09:37:10 <lambdabot>     Couldn't match expected type `Maybe (a1 -> a0 -> (a, b))'
09:37:10 <lambdabot>                 with actual type `a2 -> b0 -> (a2, b0)'
09:37:10 <lambdabot>     In the first argument of `(<*>)', namely `(,)'
09:37:17 <Lethalman_> :t \f (a, b) -> (,) <$> a <*> f b :: Maybe (a,b)
09:37:18 <lambdabot>     Couldn't match expected type `t1' with actual type `Maybe a1'
09:37:18 <lambdabot>       `t1' is a rigid type variable bound by
09:37:19 <lambdabot>            the inferred type of it :: t -> (t1, t2) -> Maybe (a, b)
09:37:23 <Lethalman_> eeeeek sorry
09:37:26 <Lethalman_> however use TupleSections :P
09:37:40 <Narvius> :t \f (a, b) -> pure (,) <*> a <*> f b :: Maybe (a, b)
09:37:41 <lambdabot>     Couldn't match expected type `t1' with actual type `Maybe a1'
09:37:41 <lambdabot>       `t1' is a rigid type variable bound by
09:37:41 <lambdabot>            the inferred type of it :: t -> (t1, t2) -> Maybe (a, b)
09:37:41 <briennetheblue> pm lambdabot :p
09:37:46 <Lethalman_> :t \f (a, b) -> ((,) a) <*> f b :: Maybe (a,b)
09:37:47 <lambdabot>     Couldn't match expected type `Maybe (a0 -> (a, b))'
09:37:48 <lambdabot>                 with actual type `b0 -> (t0, b0)'
09:37:48 <lambdabot>     In the return type of a call of `(,)'
09:37:52 <Lethalman_> :t \f (a, b) -> ((,) a) <*> f b
09:37:53 <lambdabot>     Couldn't match type `(a1, b1)' with `a0 -> b0'
09:37:53 <lambdabot>     Expected type: b1 -> a0 -> b0
09:37:53 <lambdabot>       Actual type: b1 -> (a1, b1)
09:38:18 <Lethalman_> :t \f (a, b) -> (a,undefined) <$> f b
09:38:19 <lambdabot>     Couldn't match expected type `a0 -> b0' with actual type `(t0, t1)'
09:38:19 <lambdabot>     In the first argument of `(<$>)', namely `(a, undefined)'
09:38:19 <lambdabot>     In the expression: (a, undefined) <$> f b
09:38:33 <Lethalman_> however
09:38:40 <Lethalman_> in your ghci :t \f (a, b) -> (a,) <$> f b
09:38:44 <Lethalman_> with -XTupleSections :P
09:38:54 <Narvius> ;P
09:43:46 <ski> FreeFull : you could possibly state it like that, yes
09:51:08 <Lethalman_> :t let foo f (a,b) = let p x y = (x,y) in p a <$> f b in foo
09:51:09 <lambdabot> Functor f => (t -> f a) -> (t1, t) -> f (t1, a)
09:51:14 <Lethalman_> Narvius, ^^
09:51:28 <Lethalman_> the trick here is using the (->) r functor
09:51:52 <Lethalman_> (a,) <$> f b is better with TupleSections
09:52:40 <Narvius> :D
09:52:43 <triliyn> :t let foo f (a,b) = (,) a <$> f b in foo
09:52:44 <lambdabot> Functor f => (t -> f a) -> (a1, t) -> f (a1, a)
09:52:49 <Sagi> can someone explain to me why newtype NMLReader = NMLReader { runNMLReader :: Reader MGraph } does not make sense?
09:52:54 <Sagi> the compiler is being mean to me :-)
09:53:28 <Sagi> the error is Expecting one more argument to `Reader MGraph'
09:53:37 <Lethalman_> triliyn, mh weird it didn't work on my ghci
09:53:40 <donri> Sagi: that means it'x expecting one m ore argument ;)
09:53:41 <Lethalman_> ah perhaps I used a lambda
09:53:49 <donri> :k Reader
09:53:50 <lambdabot>     Type synonym `Reader' should have 1 argument, but has been given none
09:53:50 <lambdabot>     In a type in a GHCi command: Reader
09:54:11 <geekosaur> Sagi, Reader MGraph is not a type, it's a type function that needs to be applied to another type to produce a type
09:54:15 <Sagi> but type Reader r = ReaderT r Identity
09:54:24 <geekosaur> yes
09:54:24 <Sagi> oh
09:54:24 <donri> :k ReaderT
09:54:25 <lambdabot> * -> (* -> *) -> * -> *
09:54:34 <donri> Sagi: partial application on types :)
09:54:35 <Sagi> So I need to put ReaderT in there?
09:54:35 <lpaste> vvein pasted “No title” at http://lpaste.net/94958
09:54:40 <geekosaur> no]
09:54:47 <Narvius> Look at it this way, Sagi
09:54:53 <geekosaur> you cannot have a value of type Reader Thing
09:54:56 <Narvius> Monads, per definition, have a kind of "return type"
09:54:56 <ski> @kind Reader Bool
09:54:58 <lambdabot> * -> *
09:55:02 <geekosaur> it must be Reader Thing SomeOtherThing
09:55:02 <Narvius> It needs to be in the signature
09:55:17 <vvein> hi there! I have super simple question, pasted the code above
09:55:36 <FreeFull> Reader is implemented in terms of ReaderT, but the simple implementation is  type Reader = forall r. (->) r
09:55:39 <ski> Sagi : if you say `blah :: ...', then `...' should be a type with kind `*', a "concrete type"
09:55:41 <donri> Sagi: a Reader monad has both a type you can "read" (presumably Graph) and a normal monad return type (your missing "a")
09:56:06 <donri> Sagi: newtype NMLReader a = NMLReader { runNMLReader :: Reader MGraph a }
09:56:08 <Sagi> so it needs to be newtype NMLReader a = NMLReader { runNMLReader :: Reader MGraph a }  ?
09:56:17 <donri> yep
09:56:20 <Sagi> yeah, that compiled earlier, which hugeley confused me :-)
09:56:48 <Sagi> because I don't pass an a to NMLReader throughout my code. At least not when it was still a simple type NMLReader = Reader MGraph
09:56:55 <Sagi> -e
09:57:04 <donri> Sagi: consider: do mgraph <- ask; return (show mgraph)  -- :: Reader MGraph String
09:57:05 <Sagi> oh wait
09:57:06 <Sagi> I do
09:57:12 <geekosaur> type can get away wiuth that as long as it's used in a way which results in an actual type later
09:57:23 <geekosaur> newtype has to be complete in and of itself, not a "type lambda"
09:57:29 <Sagi> doh, this stuff really makes me think
09:57:47 <Sagi> thanks everyone. Now I'll try to write a bunch of 'ask' functions
09:58:02 <donri> Sagi: Reader is really just a function (r -> a) and you have (MGraph ->)
10:01:10 <geekosaur> vvein, you are trying to compile that? the last line is a bare expression, that works in ghci which is an expressione valuator, it is not valid in a compiled program
10:01:52 <geekosaur> programs consist of bindings, one of which (main) is the one that the program will evaluate when it is run
10:05:38 <vvein> geekosaur: I just try to run it in a ghci
10:06:10 <vvein> geekosaur: I want to better understand applicatives and monads
10:06:11 <geekosaur> let me rephrase what I said. is that the contents of a source file?
10:06:41 <geekosaur> you can use bare expressions at the ghci prompt. you can NOT use them in source files
10:06:47 <geekosaur> not even with ghci
10:07:06 <dwcook> vvein, it doesn't work because it's ill-typed.
10:07:06 <vvein> geekosaur: no, just three lines that I typed in on the ghci prompt after importing Control.Applicative
10:07:23 <dwcook> The operation you're attempting doesn't make sense.
10:08:24 <geekosaur> okat
10:08:24 <briennetheblue> it works if you turn those Justs into single length lists i think...
10:08:36 <vvein> ummm, so how would I do that?
10:08:36 <geekosaur> do you understand how Maybe works?
10:08:58 <vvein> that's the thing, I have an example with a list of functions applies over a list of ints
10:09:28 <dwcook> vvein, that would be good if you had a list of functions there, but you have a list of only possibly existent functions
10:10:13 <vvein> geekosaur: probably not well enough ;)
10:10:18 <dwcook> What is the result you want here?
10:10:49 <vvein> dwcook: [Maybe Int]
10:11:05 <dwcook> What's an example output given a and b there?
10:12:16 <vvein> dwcook: [Just 6, Just 7, Just 8, Just 5, Just 10, Just 15]
10:12:50 <briennetheblue> a >>= (\x -> maybeToList x <*> b) works, if that's what you want
10:13:03 <briennetheblue> it gives [6,7,8,5,10,15]
10:13:21 <briennetheblue> maybeToList is in Data.Maybe
10:13:30 <fizbin> Narvius: Don't know if anyone mentioned it, but that general type you were looking for before looks like the type of flip Data.Traversable.Traverse, if there were a Traversable instance for (a,)
10:14:48 <FreeFull> :t concat . maybeToList
10:14:49 <lambdabot> Maybe [a] -> [a]
10:15:02 <FreeFull> :t concat . liftM maybeToList
10:15:04 <lambdabot> [Maybe a] -> [a]
10:15:14 <fizbin> :t Data.Traversable.for
10:15:15 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
10:15:56 <donri> :t (F.fold . F.fold) `asAppliedTo` Just []
10:15:58 <lambdabot> Monoid b => Maybe [b] -> b
10:17:14 <chrisdone> > maximum ["Metallica","Pantera"]
10:17:16 <lambdabot>   "Pantera"
10:17:16 <Lethalman_> :t maybeToList
10:17:17 <lambdabot> Maybe a -> [a]
10:17:54 <vvein> briennetheblue: thank you
10:19:25 <donri> > maximumBy length ["Metallica","Pantera"]
10:19:26 <lambdabot>   Couldn't match type `GHC.Types.Int'
10:19:26 <lambdabot>                with `[GHC.Types.Char] -...
10:19:32 <donri> :(
10:19:44 <donri> > maximumBy (comparing length) ["Metallica","Pantera"] -- ?
10:19:45 <lambdabot>   "Metallica"
10:20:35 <glguy_> vvein: If the goal was just to compute the expression you could always just write: [ f x | Just f <- a, x <- b ]
10:20:44 * haasn .oO( let volume = length )
10:21:48 <vvein> glguy_: I am playing with >>= and <*>
10:22:07 <ski> > foldr (zipWith max) (repeat minBound) ["Metallica","Pantera"]
10:22:07 <ski> > (getZipList . foldr (liftA2 max) (pure minBound) . map ZipList) ["Metallica","Pantera"]
10:22:08 <lambdabot>   "Pettlri"
10:22:09 <lambdabot>   "Pettlri"
10:23:12 <chrisdone> Pettlri is probably a swedish death metal band
10:23:28 <donri> or an ikea product
10:23:34 <chrisdone> we just don't know.
10:28:42 <haasn> > swedish "Metallica"
10:28:47 <lambdabot>   "Mfeftfaflflfifcfa"
10:29:10 <Clint> wat
10:29:40 <triliyn> http://www.youtube.com/watch?v=RqvCNb7fKsg
10:31:36 <nooodl> wow i got top comment on that huh
10:37:18 <sellout-> Is there any more general version of unzip? Specificially, I want Set (a, b) -> (Set a, Set b)
10:41:19 <Sculptor> o/
10:45:01 * hackagebot blaze-builder 0.3.2.0 - Efficient buffered output.  http://hackage.haskell.org/package/blaze-builder-0.3.2.0 (SimonMeier)
10:50:07 <donri> :t F.foldr (\(a,b) ~(as,bs) -> (Data.Set.singleton a <> as,Data.Set.singleton b <> bs)) (mempty,mempty)
10:50:08 <lambdabot> (Ord a, Ord a1, Foldable t) => t (a, a1) -> (S.Set a, S.Set a1)
10:51:09 <donri> sellout-: can't make it general without something like Pointed, which seems to be considered a bad idea
10:51:56 <sellout-> donri: Thanks for the … pointer.
10:52:51 <donri> sellout-: but anyway Set is Foldable, so you can use Data.Foldable.foldr like i did
10:53:30 <sellout-> donri: Yeah, that’s my plan. Just wanted to make sure I wasn’t overlooking a good abstraction.
10:53:42 <donri> sellout-: Foldable is a good abstraction :)
10:54:27 <elliott> foldMap is better than foldr for Set :(
10:54:41 <mlen> where can I find the definition of that swedish function? :)
10:54:52 <lightquake> why is Pointed considered harmful?
10:54:54 <elliott> :t F.foldMap (\(a,b) -> (S.singleton a, S.singleton b))
10:54:55 <lambdabot> (Ord a, Ord a1, Foldable t) => t (a, a1) -> (S.Set a, S.Set a1)
10:55:07 <elliott> :t F.foldmap (S.singleton *** S.singleton)
10:55:08 <lambdabot> Couldn't find qualified module.
10:55:10 <elliott> :t F.foldMap (S.singleton *** S.singleton)
10:55:11 <lambdabot> (Ord a, Ord a1, Foldable t) => t (a, a1) -> (S.Set a, S.Set a1)
10:55:13 <donri> lightquake: no useful laws, IIUC
10:55:15 <elliott> that should be more efficient, maybe
10:55:35 <lightquake> well, you can define laws on Pointed Functors
10:55:45 <lightquake> but yeah Pointed itself doesn't have any
10:56:03 <pfurla> hello
10:56:24 <mzero> I suppose    (Data.Set.fromList *** Data.Set.fromList) . unzip . Data.Set.toList     is just to common?
10:56:47 <sellout-> lightquake: Here’s what I found: http://www.haskell.org/haskellwiki/Why_not_Pointed%3F (haven’t read it yet)
10:56:52 <donri> elliott: and nicer. good point
10:57:31 <pfurla> I am looking for an IO lib that already gives me Either some IO
10:57:45 <elliott> mzero: about as efficient as the foldr
10:57:48 <pfurla> s/some/someError
10:57:50 <elliott> less efficient than the foldMap I think. maybe.
10:59:04 <mzero> I'm not sure - it depends on how unzip and *** are implemented - can they construct and deconstruct the outer pair so that the contents can be consumed lazily - if so - then it is pretty efficient
10:59:21 <donri> pfurla: something like syncIO from the errors package?
10:59:22 <mzero> where's johan when you need him?
10:59:34 <pfurla> donri: let me check
10:59:41 <donri> pfurla: http://hackage.haskell.org/package/errors-1.4.3/docs/Control-Error-Util.html#g:6
10:59:55 <donri> @hoogle syncIO +errors
10:59:55 <lambdabot> Could not find some databases: errors
10:59:55 <lambdabot> Searching in:
10:59:55 <lambdabot>   .
10:59:57 <donri> :(
11:00:09 <donri> elliott: Y U NO hoogle all of hackage
11:01:08 <pfurla> donri: I think it will do it, at least as quick solution, thanks
11:01:16 <pfurla> Control.Error.Util
11:01:45 <donri> pfurla: or were you looking for tryIOError?
11:01:49 <donri> @hoogle tryIOError
11:01:49 <lambdabot> No results found
11:01:52 <donri> :(
11:02:16 <donri> pfurla: http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO-Error.html#v:tryIOError
11:02:41 <donri> pfurla: or more generally, http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Exception.html#g:7
11:02:41 <pfurla> I quickly look at try, but felt it's not already plumed
11:02:50 <donri> plumed?
11:02:51 <pfurla> look at Exception too
11:03:04 <Eduard_Munteanu> Is there a name for ordered bags?
11:03:20 <donri> Eduard_Munteanu: lists? :P
11:03:41 <Eduard_Munteanu> donri: mm, yeah, but backed by something like Data.Map
11:03:44 <pfurla> Eduard_Munteanu: an amazon order? :)
11:03:54 <Eduard_Munteanu> Heh.
11:03:56 <donri> Eduard_Munteanu: how then is it ordered?
11:04:26 <donri> or did you mean "Ord-ered"
11:04:40 <Eduard_Munteanu> donri: you can zip it with [1..] to make it stable relative to implicit sorting of Map.
11:04:56 <Eduard_Munteanu> Not exactly ordered, just stably-sorted.
11:05:06 <donri> @hackage multiset this?
11:05:06 <lambdabot> http://hackage.haskell.org/package/multiset this?
11:05:57 <pfurla> donri: thanks, I look at these options
11:06:00 <Eduard_Munteanu> donri: hm, that seems useful... I wonder if it's stable already.
11:07:36 <Eduard_Munteanu> It probably isn't, because Map isn't.
11:10:11 <aloiscochard> pfurla: try should be fine, it's bascially very similar to scala control ;-)
11:17:17 <eacameron> is there a better way of doing this: modifyMVar_ mCnt (\x -> return x + 1)
11:17:51 <Eduard_Munteanu> eacameron: are you sure that 'return' is wanted there?
11:17:59 <mauke> eacameron: that's a type error
11:18:02 <haasn> Eduard_Munteanu: ‘tables’ with an autokey or something as primary index
11:18:07 <mauke> are you asking for a better way to generate a type error?
11:18:23 <haasn> actually I have no idea what you're trying to do. But that gives you O(log n) lookup and stuff while retaining your-order traversals
11:18:24 <eacameron> oops: modifyMVar_ mCnt (\x -> return $ x + 1)
11:18:47 <eacameron> mauke: Haha...no I'm good at that
11:18:55 <mauke> @hoogle modifyMVar_
11:18:55 <lambdabot> Control.Concurrent.MVar modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
11:18:55 <lambdabot> GHC.Conc.Sync modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
11:19:22 <eacameron> mauke: I need (+1) to be a -> IO a
11:19:31 <mauke> return . (+1)
11:19:34 <mauke> return . succ
11:19:50 <eacameron> ahh cool!
11:19:53 <Eduard_Munteanu> haasn: I have something that takes [(a, Integer)] as input and spreads them over a list. But I want to update the former list more nicely than using list lookups.
11:20:34 <Eduard_Munteanu> haasn: and I wanted to keep the relative order in the result (spread) list.
11:20:37 <haasn> Eduard_Munteanu: and your ‘a’ is Ord?
11:20:41 <Eduard_Munteanu> haasn: yeah
11:21:39 <haasn> ‘tables’ can definitely do that; define an auto-incremented primary key and use your ‘a’ as a secondary key; then do lookups and modifications based on that secondary key
11:21:41 <Eduard_Munteanu> Maybe I should keep a list [a] and retrieve them?
11:21:48 <haasn> it's probably not ideal
11:21:55 <haasn> ‘tables’ has a lot of overhead as far as I'm aware
11:22:42 <Eduard_Munteanu> It's not a lot of data, quite little in fact.
11:23:18 <Eduard_Munteanu> I think I'll go with a (Map a Integer, [a]).
11:24:16 <haasn> might as well
11:24:49 <Eduard_Munteanu> Luckily I can do map lookups and only cons the list if needed.
11:29:53 <haasn> Eduard_Munteanu: but do you get a lensy interface for ‘free’? :)
11:30:12 <Eduard_Munteanu> Hm, not really.
11:35:04 * hackagebot symbol 0.2.0 - A 'Symbol' type for fast symbol comparison.  http://hackage.haskell.org/package/symbol-0.2.0 (GeoffreyMainland)
11:37:32 * haasn read Symbol comparison and got excited :(
11:37:56 <scriptor> isn't that what it is?
11:38:25 <haasn> It's comparison on a data type Symbol (as isomorphic to String), not the kind Symbol (as exists on the type level with DataKinds) :)
11:38:50 <haasn> but I think that stuff is coming with 7.8 either way
11:38:52 <haasn> If not, 7.10
11:39:18 <ski> what would a `Symbol' kind be of use for ?
11:40:08 <Eduard_Munteanu> ski: annotating regions of code with names
11:40:19 <ski> hm
11:40:30 <ski> and how are fresh `Symbol's generated ?
11:40:39 <ski> (or maybe they aren't fresh ?)
11:40:52 <Eduard_Munteanu> ski: oh, I'm just saying type-level Strings.
11:43:37 <Eduard_Munteanu> ski: for instance you can give each IO-ish monad a name such that the "stack trace" is known at compile-time, AFAICT.
11:44:31 <jg> hi all. i have some type problems with a simple removeDups function: http://pastebin.com/FLXHZvUm
11:44:32 <zq> is [] a monad?
11:44:33 <ziman> they use unsafePerformIO
11:44:36 <mauke> The paste FLXHZvUm has been copied to http://lpaste.net/94962
11:44:39 <Eduard_Munteanu> e.g. require lifts to combine names
11:44:43 <zq> nvm
11:44:44 <Eduard_Munteanu> zq: yes
11:44:45 <ziman> so I guess (intern "foo" /= intern "foo")
11:44:50 <danharaj> [1,2,3] >>= \x -> [1..x]
11:44:55 <zq> now i get why fmap works on String
11:44:56 <danharaj> > [1,2,3] >>= \x -> [1..x]
11:44:57 <lambdabot>   [1,1,2,1,2,3]
11:45:25 <mzero> ziman: no those should be ==
11:45:59 <mzero> intern uses unsafePerformIO to query/update a global map of intern'd Strings
11:46:11 <ziman> oh, I see
11:49:38 <zq> :t concat
11:49:39 <lambdabot> [[a]] -> [a]
11:50:30 <amalloy> jg: you have a way to handle empty lists, and lists of size 2+, but no way to handle lists of size 1
11:50:49 <jg> ah
11:51:15 <mzero> > concat [ "pro", "cat", " ", "can", " ", "haz", " ", "type" ]
11:51:17 <lambdabot>   "procat can haz type"
11:51:48 <lilred> Hey guys, I'm looking into trying Haskell for a coding competition
11:51:57 <lilred> is there a good tutorial on the Haskell actor model?
11:52:09 <lilred> basically Concurrent.Control.Actor
11:52:12 <haasn> ski: I used it for abstract identifiers for type level correctness stuff
11:52:24 <haasn> (not fresh, mind)
11:53:03 <jg> amalloy: so, can i just add removeDups [a] = [a]?
11:53:12 <zol> Anyone know where I can lookup the source implementation of the max fanction if it doesn't exist on Hoogle?
11:53:22 <mzero> @src ma
11:53:23 <lambdabot> Source not found. It can only be attributed to human error.
11:53:26 <mzero> @src max
11:53:26 <lambdabot> max x y = if x <= y then y else x
11:53:36 <amalloy> jg: that looks sufficient to me, but i haven't tried it
11:53:46 <mzero> @src maximum
11:53:46 <lambdabot> maximum [] = undefined
11:53:46 <lambdabot> maximum xs = foldl1 max xs
11:54:17 <zol> mzero: Thanks!
11:54:43 <jg> amalloy: compiler still complaining
11:55:40 <mzero> jg:   x : removeDups y:xs  should be    x : removeDups (y:xs)
11:55:43 <amalloy> you probably need parens around (y:xs) or something; i always forget
11:56:04 <amalloy> but seriously, never say "compiler is complaining" without a paste of its actual error messages: they are there to help
11:56:04 <mzero> otherise it would be parsed as    x :  (removeDups y) : xs
11:56:17 <mzero> which complains because removeDups expects a list, not an element
11:56:34 <mzero> same on the line above, too
11:57:16 <jg> mzero, amalloy: parens solved the issue, thanks!
12:00:04 <sm> lilred: I don't think so. There are a number of actors-ish packages. async should be a good one
12:00:30 <Eduard_Munteanu> lilred: CloudHaskell might also be related
12:01:11 <sm> and http://chimera.labs.oreilly.com/books/1230000000929/index.html discusses parallelism/concurrency in haskell generally
12:08:10 <zq> :t (<-)
12:08:11 <lambdabot> parse error on input `<-'
12:08:13 <zq> :t <-
12:08:14 <lambdabot> parse error on input `<-'
12:08:16 <seydar> in type theory, what does an arrow with a vertical bar at its base mean?
12:08:33 <seydar> example: http://danielmattosroberts.com/earley/context-sensitive-earley.pdf page 7 under "Return Propagation"
12:09:15 <geekosaur> zq, <- is syntax, not an operator
12:09:47 <nbouscal> zq: <- is syntactic sugar, x <- y; z is equivalent to y >>= \x -> z
12:13:00 <zq> geekosaur, nbouscal: thanks
12:13:17 <MattY> hello
12:13:19 <MattY> how can I make a show' function that will print all the objects with show, except string which should be printed without quotes?
12:14:01 <geekosaur> do we not have a faq about that yet?
12:15:29 <ski> MattY : define your own function(s), possibly using a new class
12:16:49 <MattY> I want a single function, which should work with all Show instances. not sure how to express that
12:17:18 <nbouscal> give the function the type signature Show a => a -> String
12:17:43 <MattY> and how would I specialize it on a Sttring?
12:17:48 <nbouscal> pattern match
12:18:38 <arkeet> nbouscal: no
12:18:48 <c_wraith> wow, I just saw http://hackage.haskell.org/package/acme-realworld .  That's a brilliant joke that you have to understand *way* too much for. :)
12:19:20 <arkeet> there's a SPECIALIZE pragma but that won't necessarily work
12:20:05 <geekosaur> this is what typeclasses are for, but you'd need OverlappingInstances. in general this is just a bad idea that all beginners think is the greatest idea ever
12:20:13 <johnw> c_wraith: I wonder if it can fork computation into parallel universes?
12:20:29 <arkeet> yep
12:20:34 <arkeet> you shouldn't want to do that.
12:20:37 <MattY> and how to do it properly?
12:20:41 <nbouscal> agreed on that
12:20:45 <arkeet> well, that depends on what you're actually trying to do!
12:21:19 <MattY> I am pretty printing a Tree, and it would look nicer if strings were printed without quotes
12:21:21 <edwardk> bergey: intervals should be fixed now
12:21:30 <edwardk> bergey: i spammed out about 20 patches to it =)
12:22:06 <arkeet> MattY: the tree contains things of one (variable) type?
12:22:29 <MattY> yes
12:22:31 <arkeet> e.g. pretty :: Tree a -> String
12:22:39 <arkeet> you could let the pretty printer take an extra function argument (a -> String)
12:22:41 <MattY> that's right
12:22:51 <arkeet> and you could use id for strings, show for non-strings
12:23:39 <MattY> that would work. still curious how I could write a function like this. can't it be done in standard haskell?
12:23:50 <arkeet> not really.
12:23:58 <arkeet> types disappear at runtime.
12:24:10 <arkeet> maybe you could do something with Typeable.
12:24:38 * arkeet or here's an evil idea: use show for everything, but then try to read it as a String (to remove the quotes)
12:24:45 <MattY> what do you mean at runtime?  it should know at compile time whether object is String or some other Show instance
12:25:07 * hackagebot intervals 0.3 - Interval Arithmetic  http://hackage.haskell.org/package/intervals-0.3 (EdwardKmett)
12:25:30 <amalloy> MattY: suppose that you could tell String and Show apart - that still wouldn't really solve your original problem
12:25:52 * arkeet the evil idea would also work with things like Text
12:26:14 <amalloy> because (show' (Tree "foo")) would see that its argument is not a String but a Tree String, and would then call show on that. note that it's not calling show', so the inner foo will still get quotes around it
12:27:22 <MattY> in this case I don't care what show' (Tree "foo") does, I will use show' in prettyPrint function
12:28:05 <MattY> prettyPrint (Tree obj left right) = ... show' obj
12:28:21 <`^_^v> why don't you just declare a new typeclass that has as a default implementation show
12:28:27 <`^_^v> and override it for strings
12:28:33 <MattY> I will try
12:31:12 <mzero> no no - you don't need to do evil things at run time - just a new typeclass
12:32:10 <mzero> ah what `^_^v said
12:32:25 <classius> Don't even need a type class.
12:32:29 <classius> Just take the drawTree approach.
12:32:31 <classius> :t drawTree
12:32:33 <lambdabot> Tree String -> String
12:32:45 <classius> It is the user's job to pretty-print the leaves, not your pretty-printing function's.
12:32:48 <mzero> that too -
12:33:19 <MattY> it is complaining about doing instance on String, telling me to use -XTypeSynonymInstances. when I did it is complaining about -XFlexibleInstances. am I on the right track?
12:33:22 <mzero> sure, if you have a Tree of some other type, then    drawTree . fmap show
12:33:42 <MattY> classius sure that would be more flexible, this is a practice project, I want to know how to do something like this
12:33:46 <MattY> +but
12:34:15 <MattY> it complained about TypeSynonymInstances because string is alias for [Char]? why is it complaining about flexible instances?
12:34:24 <classius> Read the error carefully.
12:34:26 <classius> It says why.
12:34:33 <mzero> MattY: yeah- I think we misled you, the typeclass idea is going to be painful in this case, both because String is a type, not a data, and because you'd want a default instance for all other types
12:34:50 <startling> MattY, it's complaining because that's what the Haskell spec specifies.
12:34:59 <MattY> mzero so what would be a better approach?
12:35:12 <startling> MattY, but yes, you probably want to do something else.
12:35:16 <nbouscal> the drawTree approach wins
12:35:22 <mzero> if you really need to pretty print Tree a and Tree String --- and for Tree a you want show, and for Tree String  you want just to use the string
12:35:25 <mzero> then use two functions:
12:36:04 <classius> http://stackoverflow.com/questions/8633470/illegal-instance-declaration-when-declaring-instance-of-isstring/8633584 <- on what the FlexibleInstances error says
12:36:15 <mzero> prettyTree :: Tree String -> String     and     showTree :: (Show a) => Tree a -> String      showTree = prettyTree . fmap show
12:36:55 <edwardk> classius: this is precisely the kind of instance you want flexible instances for
12:36:57 <mzero> unless you have some very specific situation where you don't know a, but want prettyTree, then this is probably best
12:37:08 <mzero> (well, simplest and clearest for future readers of your code)
12:37:10 * classius nods agreeably at edwardk
12:37:34 <MattY> I wouldn't have thought specializing show' for string would be so painful. is there any way to get it working?
12:37:36 <edwardk> classius: in my experience though, this is a pretty crappy instance, because (length "hello") doesn't determine the element type of the list
12:38:04 <classius> I believe we are in violent agreement.
12:38:43 <classius> MattY: Use a different class.
12:38:47 <classius> Show ain't it.
12:38:59 <classius> You want a pretty-printer, make a pretty-printing class.
12:39:13 <MattY> I thought I nailed it, but no
12:39:19 <MattY> I'll paste
12:39:30 <mzero> well, MattY, think of it this way:   You'd need    instance PrettyShow String where prettyShow = id   and     instance PrettyShow a where prettyShow = show
12:39:43 <MattY> mzero yes that's what I did
12:39:58 <mzero> that second one covers the first one, so now we need some disambiguation rule - which plain Haskell doesn't have
12:40:56 <lpaste> MattY pasted “Show'” at http://lpaste.net/94966
12:41:07 <mzero> and you can use various extensions to get you that rule - but (I think) we are now entering the realm where there a reasonable sounding rule could easily end up in ambiguity (though not in this case)
12:41:49 <MattY> it seems it doesn't know whether to use Show or String instance for Show', even though String instance is a closer match
12:42:02 <mzero> see the error messages: It is telling you that there are two applicable instance declarations - where there are!
12:42:02 <classius> MattY: Two things you should know when staring at this code: 1. the order of declarations in Haskell never matters; 2. the context of an instance declaration doesn't matter until too late
12:43:02 <MattY> I didn't think order would matter
12:43:08 <classius> Okay, your misconception is a different one than I thought. So ignore my previous two-point comment.
12:44:16 <MattY> so how does one resolve this?  is it even possible to write this this class
12:44:19 <classius> Instances are not allowed to overlap in Haskell. It is possible to ask GHC to ignore this restriction; however, it is not recommended because it can make things fragile in surprising ways.
12:44:23 <mzero> "closer match" is a disambiguation rule... which doesn't always disambiguate!   hence it isn't a standard part of Haskell....
12:44:35 <mzero> what you need is -XOverlappingInstances
12:44:36 <mzero> http://lambda.haskell.org/platform/doc/current/ghc-doc/users_guide/type-class-extensions.html#instance-overlap
12:44:46 <classius> He will need IncoherentInstances, too.
12:45:28 <mzero> by the way - there is a good, if concise, discussion of the situation on that man page
12:46:59 <MattY> lol Dear God
12:47:32 <MattY> I got it to compile and work with this :-O.  {-# Language TypeSynonymInstances, FlexibleInstances, OverlappingInstances, IncoherentInstances , UndecidableInstances #-}
12:48:00 <mzero> I don't think you need all those at all
12:48:19 <MattY> you are right it works without IncoherentInstances
12:48:41 <geekosaur> MattY, tjhat should be telling you something, specifically that you are not doing a good thing at all
12:48:45 <classius> You can make the instances without IncoherentInstances, but I suspect you will find it hard to use them.
12:49:03 <mzero> BUT - in any event, personally, I don't ever like using IncoherentInstnaces because it instructs the compiler to make a choice that isn't obvious to the programmer, and contradicts a simple feel for "most specific"
12:49:25 <MattY> classius in what way?
12:50:09 * hackagebot hexpat 0.20.4 - XML parser/formatter based on expat  http://hackage.haskell.org/package/hexpat-0.20.4 (StephenBlackheath)
12:50:32 <lpaste> monochrom pasted “special show” at http://lpaste.net/94967
12:50:40 <mzero> I disagree - if you turn off IncoherentInstances, you are forced to explicitly write your constraints into the type signatures - but other than that, I don't think it restricts you
12:50:43 <monochrom> MattY: http://lpaste.net/94967
12:50:46 <MattY> geekosaur honestly I don't understand why it was so painful to get this to work
12:51:10 <Eduard_Munteanu> Say I'm using Data.Map.Lazy and incrementing an Integer value at a key, is it enough to do 'M.adjust (\i -> i `seq` i + 1)' to strictify it without using Data.Map.Strict explicitly?
12:51:11 <geekosaur> because you are insisting that you must abuse Show
12:51:22 <geekosaur> note that second last word
12:51:26 <MattY> I don't see how I am abusing it
12:51:27 <classius> MattY: In polymorphic calls to your new show function, GHC has no way of knowing which instance to use, even with OverlappingInstances. That is where IncoherentInstances comes in.
12:51:35 <geekosaur> then you do not know what you are doing
12:51:35 <mzero> MattY: because you are inducing a somewhat scary global dependence on your program
12:52:06 <MattY> what is scary about it?
12:52:08 <classius> Eduard_Munteanu: I don't think so.
12:52:18 <mzero> Imagine that I have   instance PrettyShow String     and    instance PrettyShow a         and    prettyTree :: PrettyShow a => Tree a -> String
12:52:22 <Saizan> Eduard_Munteanu: doesn't adjust take a (v -> Maybe v) ?
12:52:34 <Eduard_Munteanu> :t Data.Map.adjust
12:52:35 <lambdabot> Ord k => (a -> a) -> k -> M.Map k a -> M.Map k a
12:52:36 <MattY> geekosaur yes I do. I am writing a class that uses show for all classes, except for String. doing this shouldn't be so painful!
12:52:44 <geekosaur> yes, it should
12:52:52 <mzero> now I import that and use     prettyShow on Tree Int   - that uses? which PrettyShow instance?
12:52:56 <Eduard_Munteanu> Saizan: it just leaves it as it was if the key isn't in the map
12:53:02 <geekosaur> the reason you don't think it should is that you don't know what that actually means
12:53:08 <geekosaur> you may have a model for it, but that model is wrong
12:53:12 <mzero> what if elsewhere in the code base I add in     instance PrettyShow Int  ?
12:53:21 <mzero> non-local code change here, yes?
12:53:24 <Cale> Eduard_Munteanu: Not really. Supposing the value at the given index were 0, it would record the expression (\i -> i `seq` i + 1) 0
12:53:26 <Eduard_Munteanu> Also, to be more precise, I don't care the value is lazy as long as it doesn't cause problems with that Integer.
12:53:42 <Cale> Eduard_Munteanu: You need a strict version of adjust.
12:53:46 <Eduard_Munteanu> Hm.
12:53:52 <Saizan> Eduard_Munteanu: ah, i was thinking of update
12:54:09 <Saizan> Eduard_Munteanu: which and the Maybe offers a way to make it stricter
12:54:10 <MattY> geekosaur by how vague you are being, it seems you don't know either what is wrong with it
12:54:14 <mzero> MattY: with the normal Haskell instance rules, this sort of thing can't happen
12:54:18 * monochrom agrees with geekosaur but doesn't bother to argue with people who have this tunnel vision of "I must make ad hoc special cases cavalierly" and not see how flexibility for the author equals difficulty for readers/reasoners.
12:54:24 <geekosaur> MattY, did you pay any attentjon to what mzero was showing?
12:54:30 <Saizan> Eduard_Munteanu: (\i -> Just $! i + 1)
12:54:48 <geekosaur> I am being vague because mzero was showing you a specific
12:54:54 <Eduard_Munteanu> Saizan: hm... does that avoid the problem raised by Cale above?
12:54:59 <geekosaur> and because it's actually pretty complex
12:55:00 <classius> MattY: For what it's worth, you're right: it's surprising that this is so hard! But don't mistake "it's surprising" for "it's a failure of the language".
12:55:19 <Cale> Yes
12:55:51 <Eduard_Munteanu> Cale: actually I'm unsure it's a problem, I don't care if it's lazy, I just don't want to blow the stack
12:55:51 <geekosaur> and I don't expect you to necessarily understand the complexity... but "ignorance of the law is no excuse". this kind of thing can easily bite you in the *ss, that's why it's so hard to do
12:56:23 <monochrom> actually, guess what, don't use [Char], use Text
12:56:25 <MattY> <mzero> Imagine that I have   instance PrettyShow String     and    instance PrettyShow a         and    prettyTree :: PrettyShow a => Tree a -> String
12:56:26 <Eduard_Munteanu> Cale: as in foldl vs foldl'
12:56:27 <Saizan> Eduard_Munteanu: if you get a lot of (+1) there lazily it'll blow the stack when you'll look at the result
12:56:32 <geekosaur> the "canonical" example isn't even this pretty printing one. it's that, if we made it easy to do this, it would also be easy to break sorting (because we could abuse Ord the same way you're abusing Show)
12:56:43 <MattY> <mzero> now I import that and use     prettyShow on Tree Int   - that uses? which PrettyShow instance?
12:56:48 <yrlnry> Is there some rule where if the final expression in a do-block does not have a monadic value, "return" is inferred?
12:56:53 <mzero> meant prettTre on Tree Int there
12:56:56 <classius> yrlnry: no
12:57:03 <Cale> update is inherently stricter because it has to pattern match on the result of the function to be able to tell whether it's deleting the key or not, and that gives you an opportunity to force evaluation of the value
12:57:04 <geekosaur> this, among other things, means that I can make a Data.Map with values that you can't get at
12:57:07 <classius> yrlnry: If the last thing is not monadic, it's just a type error.
12:57:10 <Eduard_Munteanu> Maybe I should use [()] or some natural instead of Integer, it really sucks. :)
12:57:11 <MattY> mzero I would expect it would use PrettyShow a
12:57:13 <yrlnry> Thanks.
12:57:21 <mzero> Yes, MattY, you would...... but
12:57:31 <Eduard_Munteanu> Cale: oh, I see.
12:57:39 <mzero> now... what if some other file in the program, perhaps added later....    defines    instance PrettyShow Int    ?
12:57:50 <Eduard_Munteanu> And you can't really match irrefutably, morally.
12:57:52 <MattY> mzero then it should use that instance
12:58:03 <yrlnry> I am looking at the definition of "local" on the lower-left corner of page 4 of this paper by Keselyov et al. http://okmij.org/ftp/Haskell/extensible/exteff.pdf  Just before the beginning of section 3,2.
12:58:07 <yrlnry> It is ill-typed.
12:58:20 <mzero> so - adding code in some place should affect code in another that doesn't reference it at all?
12:58:21 <geekosaur> so the code should suddenly change its behavior everywhere because some apparently unrelated thing changed?
12:58:28 <Cale> Eduard_Munteanu: *or* you could just use the strict version of adjust
12:58:36 <yrlnry> Should I just email him, or is there something I am missing here?
12:58:45 <mzero> that would really bad - because now the meaning of your call to     prettyTree on Tree Int   *depends on the the entire program*
12:58:46 <Cale> Eduard_Munteanu: The Map datatype itself is shared between the .Lazy and .Strict modules
12:58:59 <MattY> redefining PrintShow, that you are using in your code, isn't changing "unrelated thing"
12:59:02 <classius> yrlnry: is it?
12:59:02 <Cale> Eduard_Munteanu: The only thing which differs is how all the functions act on it.
12:59:09 <classius> yrlnry: The base case of loop is "return x"...
12:59:18 <yrlnry> classius:  ghc says it is; the return is missing.
12:59:34 <yrlnry> You're right, I omitted return.
12:59:37 <yrlnry> Thanks.
12:59:47 <Eduard_Munteanu> Cale: yeah, I know... I'm wrapping Map to make a stably-sorted Map, so it was a bit more inconvenient. I could use Map.Strict all the way though, I'm not using it for anything else.
13:00:10 <mzero> imagine you put that call to prettyTree on Tree Int  in a library... we can't know what it means until it is linked into some executable!
13:00:18 <mzero> (gotta run for now)
13:00:33 <MattY> mzero I am not sure why you find this flexibility scary
13:01:02 <MattY> it means it will use the most specific PrintShow instance, whatever that one is
13:01:05 <geekosaur> MattY, there is flexible and there is not debuggable
13:01:16 <classius> MattY: I like to know what code I'm calling. If somebody else controls what code I'm calling, and I don't know it, I will write a bug. (Not "may write a bug". Will.)
13:01:27 <monochrom> geekosaur, mzero: the fundamental dialectic class struggle between the writer and the reader is that the writer wants more flexibility, but the reader wants more predictability. and the fundamental problem with arguing with the writer is that the writer is putting on his/her writer hat, not the reader hat.
13:01:31 <geekosaur> there is action at a distance which good freaking luck trying to figure out why your program just broke in a weord way
13:02:21 <Cale> MattY: What was your question?
13:02:33 <Eduard_Munteanu> And RWS is when the State forces Writer to work together with Reader? :P
13:02:45 <classius> hehehe
13:02:52 <monochrom> Cale: a question that can be answered by http://lpaste.net/94967
13:03:31 <monochrom> and now the debate is the dialectic struggle between writer freedom and reader prediction
13:03:36 <classius> Pfft, MattY rejected my "use a different class and declare all the same instances" suggestion ages ago.
13:03:41 <classius> But damned if I know why.
13:03:56 <MattY> if you wrote a library that uses PrettyPrinter, and the user of your library adjusts it to his needs, why would that be a problem for the writer of the library?
13:04:45 <Eduard_Munteanu> Soon we will be arguing whether the MonadReader class is the ruling class.
13:04:46 <classius> MattY: If I wrote a library that uses PrettyPrinter, and I called a pretty-printing function at a type which I provided the instance for, and later the user substituted that instance with another one without my knowledge, I will have different results than I expected in my code.
13:04:49 <MattY> classius I am not sure how that suggestion is different than  what I was doing
13:05:05 <classius> MattY: Some hard-earned invariants that I set up will probably be broken, and the result is that my answer will be broken.
13:05:30 <natux_> Can anyone tell me why this code won't compile? http://pastebin.com/k4p8KaaC
13:05:31 <classius> MattY: You are trying to use "instance Show a => Show' a" to declare all the instances in your new class. This is not recommended.
13:05:36 <Cale> Oh: <MattY> how can I make a show' function that will print all the objects with show, except string which should be printed without quotes?
13:05:38 <classius> MattY: Instead, declare all the instances.
13:05:39 <mauke> The paste k4p8KaaC has been copied to http://lpaste.net/94968
13:05:51 <joelteon> I did that a few days ago, let me find the code.
13:05:51 <monochrom> I have always sided with the reader, and recent talks by Liskov and by that "scala does it all wrong" guy confirm me
13:05:52 <Cale> My first reaction to this question is: Why do you want that?
13:05:57 * Eduard_Munteanu should put together a Marxist Prelude.
13:06:11 <mauke> natux_: why don't you ask the compiler?
13:06:16 <classius> natux_: What is the error?
13:06:28 <Cale> Is this just an intellectual exercise, or do you actually think you need this thing?
13:06:39 <classius> Cale: That was our first question, too. The answer was, "because".
13:07:12 <Cale> natux_: Because you have an expression at the top level of your module
13:07:14 <MattY> no, the answer was I am writing a pretty printer for my Tree. and then I got interested why it doesn't work, and how to get it working
13:07:23 <natux_> Just an exercise and the error is Parse error: naked expression at top level
13:07:27 <classius> Cale: (Which on its own is a perfectly good answer, as far as I'm concerned, of course. =)
13:07:35 <monochrom> I can't speak for him/her, but I would be glad to guess "because I'm a cavalier solo hero"
13:07:38 <loadedanvils> looking for a function that does IO() -> [Char]
13:07:39 <classius> natux_: Maybe you would like binding that thing to a name.
13:07:48 <classius> natux_: e.g. answer = sum $ filter ....
13:07:52 <MattY> classius so you think these extensions shouldn't exist? because the user can still do exactly that, with them
13:07:53 <Cale> natux_: You may want to write something like  main = print . sum $ filter isMultipleOfThreeOrFive [999,998..0]
13:07:56 <Eduard_Munteanu> loadedanvils: what would it do?
13:08:14 <Cale> loadedanvils: wat
13:08:17 <natux_> Okay, thanks! Sorry, very new to haskell.
13:08:17 <FreeFull> loadedanvils: What would it do?
13:08:19 <loadedanvils> Eduard_Munteanu: if IO() outputs to out a string
13:08:21 <classius> MattY: Correct: I squint long and hard at any code that uses IncoherentInstances, and merely long at any code than uses OverlappingInstances.
13:08:24 <Cale> loadedanvils: Every such function is a constant function.
13:08:32 <mauke> loadedanvils: foo _ = "hello"
13:08:42 <FreeFull> loadedanvils: You could do IO () -> IO String
13:09:00 <loadedanvils> FreeFull: what function is that
13:09:02 <classius> FreeFull: ...what would that do?
13:09:12 <Cale> IO () -> IO String capturing stdout would be interesting.
13:09:26 <Cale> That's pretty tricky.
13:09:28 <loadedanvils> well, is there a way to IO ByteString to String?
13:09:35 <mauke> loadedanvils: foo _ = "hello"
13:09:37 <classius> ?where faq
13:09:38 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
13:09:42 <Cale> loadedanvils: What are you trying to do?
13:09:53 <Cale> fmap unpack?
13:09:59 <Cale> :t unpack
13:10:01 <classius> loadedanvils: No. But there is a way to turn your String-consuming function into an IO String-consuming function.
13:10:05 <Cale> :t BS.unpack
13:10:06 <lambdabot>     Not in scope: `unpack'
13:10:06 <lambdabot>     Perhaps you meant one of these:
13:10:06 <lambdabot>       `BS.unpack' (imported from Data.ByteString),
13:10:07 <mauke> Cale: [Word8]
13:10:11 <classius> loadedanvils: And a way to turn a ByteString into a String, I suppose.
13:10:12 <lambdabot> BSC.ByteString -> [Word8]
13:10:17 <Cale> :t fmap BS.unpack
13:10:19 <lambdabot> Functor f => f BSC.ByteString -> f [Word8]
13:10:20 <loadedanvils> I'm getting simpleHttp via Network.HTTP.Conduit
13:10:32 <classius> loadedanvils: http://www.haskell.org/haskellwiki/FAQ#How_do_I_convert_IO_Int_to_Int.3F
13:10:33 <Cale> :t fmap BSC.unpack
13:10:34 <lambdabot> Functor f => f BSC.ByteString -> f [Char]
13:10:42 <user123abc> http://lpaste.net/73819471227125760
13:11:18 <classius> print . show is pretty unusual.
13:11:19 <classius> ?src print
13:11:20 <lambdabot> print x = putStrLn (show x)
13:11:20 <Cale> loadedanvils: okay
13:11:34 <ski> it would be nice if `putChar' and `getChar' used two dynamically changing variables, which per default contains `stdin' and `stdout', but which could be temporarily changed with a `local'-like construct (perhaps called `withStdin' and `withStdout')
13:11:43 <user123abc> is there any sort of construct which would let me use some shorter infix operator for applying an f(a -> b) to an a value? I'd like foo = (+) <$> pure 1 ? 2
13:11:49 <loadedanvils> code I want to get string output of is: withSocketsDo       $ simpleHttp "http://www.dir.bg/" >>= L.putStr
13:11:57 <user123abc> where you tell me what ? is
13:12:05 <RustemS> monochrom: What talk by Liskov are you referring to?
13:12:08 <Cale> loadedanvils: uh, why did you putStr then?
13:12:22 <loadedanvils> Data.ByteString.Lazy.putStr
13:12:22 <ski> (hm, it'd have to be thread-local, though)
13:12:26 <classius> user123abc: pure $ (+) 1 2 -- ?
13:12:27 <Eduard_Munteanu> ski: there should be a way to redirect std{in,out,err}, after all bash does that just fine
13:12:31 <loadedanvils> I googled it first and copied it into my code Cale
13:12:37 <monochrom> http://www.infoq.com/presentations/liskov-power-of-abstraction
13:12:52 <user123abc> classius, (pure 1) is intended to stand in for something which must remain a monad
13:12:59 <RustemS> monochrom: Sure. This is a good one. thanks
13:13:00 <classius> user123abc: Okay. =)
13:13:05 <ski> Eduard_Munteanu : perhaps as well. but temporary replacement (as in Scheme) can be nice, too
13:13:07 <MattY> anyway, last question for this, since I am defining my own class, not extending some elses, what exactly is the problem with what I was doing?
13:13:13 <classius> :t let f ? x = ($x) <$> f in (?)
13:13:14 <MattY> someone*
13:13:15 <lambdabot> Functor f => f (a -> b) -> a -> f b
13:13:17 <startling> > (+) <*> pure 1 ?? 2
13:13:18 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable b0)
13:13:18 <lambdabot>    arising from a use ...
13:13:26 <classius> user123abc: How about that? =)
13:13:33 <startling> :t (??)
13:13:34 <lambdabot> Functor f => f (a -> b) -> a -> f b
13:13:34 <user123abc> that has the right type, trying to grok it
13:13:38 <Cale> loadedanvils: Well, if you just don't use putStr there, the result of executing the simpleHttp will be a ByteString which has the contents of the page.
13:13:41 <Eduard_Munteanu> ski: if you can do it temporarily you can probably wrap it up in a bracket-like API
13:13:49 <Eduard_Munteanu> Er, permanently.
13:13:53 <classius> startling: Cool, which package/module provides that?
13:13:59 <MattY> how do these general complaints about OverlappingInstances apply to MyShow class?
13:14:00 <startling> classius: it's a lens thing.
13:14:07 <classius> Of course it is.
13:14:10 <startling> :)
13:14:18 <loadedanvils> Cale: it's an IO ByteString
13:14:23 <startling> It's good to know what other people are calling it, though.
13:14:32 <startling> it's actually so you can do e.g.
13:14:33 <Cale> loadedanvils: If you *also* want to print it, you could write something like  do page <- simpleHttp "http://www.dir.bg/"; L.putStr page; return page
13:14:39 <startling> :t map ?? [1, 2, 3]
13:14:40 <lambdabot> Num a => (a -> b) -> [b]
13:14:45 <startling> it's a "hole"
13:14:52 <ski> Eduard_Munteanu : yeah, but another thread should be able to use the original `stdin' and `stdout', simultenously as some thread has had them replaced (for the duration of execution of some action)
13:15:01 <Cale> loadedanvils: How to convert the ByteString to a String is something which depends on the text encoding if you want to do it right.
13:15:03 <startling> but the type is general enough so that it works for Applicative style too.
13:15:03 <Eduard_Munteanu> Hm, yeah.
13:15:11 <ski> @type map ?f [1,2,3]
13:15:13 <lambdabot> (Num a, ?f::a -> b) => [b]
13:15:19 <loadedanvils> Cale: thanks!
13:15:22 <Cale> loadedanvils: If you're sure it's just ASCII text, you can use Data.ByteString.Char8
13:15:25 <classius> :t let f ?? x = \y -> f y x in (??)
13:15:26 <lambdabot> (t1 -> t2 -> t) -> t2 -> t1 -> t
13:15:27 <loadedanvils> I have no idea I wasn't getting anywhere with this
13:15:33 <ski> @type \ ?f -> map ?f [1,2,3]
13:15:34 <classius> I see.
13:15:34 <lambdabot> Parse error in pattern: ?f
13:15:45 <Eduard_Munteanu> ski: arguably Haskell's threads are more like processes wrt their behavior
13:15:48 <Cale> (the unpack function from there will produce a String, but will be incorrect for anything outside of ASCII range)
13:16:27 <ski> Eduard_Munteanu : elaborate on what you meant ?
13:16:28 <Eduard_Munteanu> ski: in fact not even like processes, but separate mains
13:16:36 <Cale> oh, I guess it's actually Data.ByteString.Lazy.Char8 rather
13:17:04 <classius> If you use D.BS.*.Char8, you fail the 21st-century test.
13:17:43 <Cale> Well, if you have control over the strings you're using it on, it might be just fine
13:17:58 <Eduard_Munteanu> ski: they don't really share any implicit context. Also forkIO is quite unlike fork() because you don't get a forked thread start at the same point as the original caller.
13:18:08 <Eduard_Munteanu> They also don't join back.
13:18:21 <Cale> However, in this case, dir.bg contains lots of Russian text which is going to be horribly mangled if you don't decode it properly.
13:18:23 <donri> Char8 is fine for ASCII and latin-1. problem is neither Char nor string literals are either of those.
13:19:14 <classius> Eduard_Munteanu: It's very unusual for the two threads you get from fork() to start at the same point conceptually anyway.
13:19:19 <Eduard_Munteanu> ski: I mean semantically, they're just separate programs, except you can pass actual Haskell value through MVars etc
13:19:26 <classius> Eduard_Munteanu: Everybody does if(fork()) { thread1; } else { thread2; }
13:19:30 <Cale> Well, anything which happens to be an ASCII-encoded ByteString will be correctly decoded by .Char8
13:19:40 <user123abc> spotty connection - thanks for the help before
13:20:14 <natux_> My code's still not working, can anyone help? http://pastebin.com/k4p8KaaC it's just an exercise so it's not really important. The compile error is, Parse error: naked expression at top level
13:20:19 <mauke> The paste k4p8KaaC has been copied to http://lpaste.net/94968
13:20:27 <user123abc> I'm not seeing this magical (??) operator in hackage
13:20:36 <classius> natux_: You didn't like our previous answer to this question?
13:20:45 <user123abc> what provides it?
13:20:50 <classius> ?hackage lens
13:20:50 <lambdabot> http://hackage.haskell.org/package/lens
13:20:54 <startling> user123abc, it's in Control.Lens, and it's probably silly to require that if you're not using the other stuff
13:20:54 <user123abc> thanks
13:20:59 <classius> ?hoogle (??) +lens
13:20:59 <lambdabot> Could not find some databases: lens
13:20:59 <lambdabot> Searching in:
13:20:59 <lambdabot>   .
13:21:00 <Eduard_Munteanu> classius: I thought it was more like  parent = getpid(); fork(); if (parent == getpid()) { ... } ...
13:21:02 <startling> in "lens", yeah.
13:21:05 <user123abc> that's a very good point
13:21:06 <donri> natux_: what are you expecting that "sum" line to do?
13:21:24 <natux_> It didn't work for me, maybe I'm just an idiot, but I update the paste with code I'm currently using.
13:21:25 <ski> Eduard_Munteanu : yeah, but iiuyc, redirecting `stdin' would be visible from other threads, no ?
13:21:36 <startling> user123abc, http://hackage.haskell.org/package/lens-3.10/docs/src/Control-Lens-Combinators.html#%3F%3F if you want to copy-paste
13:21:44 <user123abc> thanks
13:21:49 <MattY> nobody?  I can see why changing how some instances behind someones back can cause problems. but I defined a new class, so, what exactly is the problem?
13:22:01 <classius> Eduard_Munteanu: Whatever. My point is that nobody runs two identical threads anyway, so the "you don't get a forked thread starting at the same point as the original caller" is not a very fundamental difference.
13:22:04 <MattY> none that I can see
13:22:16 <donri> natux_: to make an executable program, you need to define a "main :: IO ()". that's probably where you want that sum line, possibly prefixed by "print $ "
13:22:37 <MattY> you can abuse everything, including OverlappingInstances
13:22:42 <Eduard_Munteanu> ski: the simplest implementation possibly involves that, because copying handles would be rather expensive.
13:22:42 <classius> MattY: The class you defined explicitly allows people to swap instances out from under you by turning on OverlappingInstances.
13:22:50 <Cale> loadedanvils: In this case, the way I'd handle the conversion is to use decodeUtf8 from the Data.Text.Encoding module to convert it to Text, and then perhaps convert to String using Data.Text.unpack (which seems roundabout, but has the advantage that nearly everyone will already have the text package installed, so it's an almost-free dependency)
13:23:18 <donri> MattY: type classes are open
13:23:21 <MattY> classius every class allows that. how is my class special in this regard?
13:23:28 <classius> MattY: Incorrect.
13:23:32 <loadedanvils> Cale: ok, I will try this
13:23:33 <classius> MattY: Not every class allows that.
13:23:34 <Cale> (also, the text package is really cool, and for many serious jobs, you'll often want to use Text in place of String)
13:23:54 <donri> maybe closed type classes with ordered overlap could work, but that's not what you get with OverlappingInstances
13:23:55 <MattY> classius because my class was defined in a file using OverlappingInstances?
13:24:00 <natux_> Thank you! It works perfectly!
13:24:11 <Eduard_Munteanu> classius: sure, not identical, but you don't have to bother about e.g. what happens if one thread returns. It's much like an exec except you get to pass values in.
13:24:19 <classius> MattY: Yes.
13:24:32 <ski> MattY : i think you probably need a method similar to `showsList'
13:25:02 <classius> ski: MattY is building a rickshaw instead of a car and you're telling him he painted the rickshaw the wrong color.
13:26:02 <ski> classius : i've already accepted the nonsensical problem statement. what's left is how to do it
13:26:09 <classius> =)
13:26:20 <donri> MattY: i would probably use generics to do what you originally asked, though (reading backscroll)
13:26:32 <mauke> I want a heptagonal bikeshed
13:27:20 <ski> MattY : what are the members of `PrettyShow' ?
13:27:23 <donri> MattY: actually Typeable should be enough
13:28:19 <MattY> ski I called my class Show'. it has just one member, show', which prints strings without quotes and uses show function for every other Show.
13:28:29 <ski> @src Show
13:28:30 <lambdabot> class  Show a  where
13:28:30 <lambdabot>     showsPrec :: Int -> a -> ShowS
13:28:31 <lambdabot>     show      :: a   -> String
13:28:33 <lambdabot>     showList  :: [a] -> ShowS
13:28:36 <donri> show' :: (Show a, Typeable a) => a -> String; show' a | typeOf a == typeOf "" = a | otherwise = show a
13:28:43 <donri> MattY: ^ something like that
13:28:46 <MattY> I used this to pretty print a Tree, because printing strings with quotes wasn't so pretty
13:28:49 <ski> you need something like `showList', to avoid the `OverlappingInstances'
13:29:05 <MattY> donri I see, I will try it
13:29:11 <ski> (a little like encoding binary methods in OO, perhaps)
13:29:21 <donri> MattY: note this is without any new type class, just import Data.Typeable
13:29:22 <mauke> no quotes around strings? did you mean: code injection
13:30:25 <classius> Who needs code injection when you have first-class functions?
13:30:26 <classius> =(
13:30:51 <henk> I have a few questions regarding http://lpaste.net/94956: 1. I’d like hours and minutes be padded to 2 digits. Any hints how to do that? 2. I was told yesterday that I could replace the function in line 23 with a foldr, but I don’t accumulate a value, so I’m not sure that is correct. Can a fold or something else that is more elegant be used here? 3. Any general suggestion what to improve, make shorter,
13:30:52 <henk> make better readable or anything?
13:30:55 <ski> > Just worry
13:30:57 <simpson> MattY: Wait, wait, this is all just because you felt that something wasn't pretty in a Show instance?
13:30:59 <lambdabot>   Just what, me worry ?
13:31:17 <donri> :t worry
13:31:18 <lambdabot> Expr
13:31:21 <donri> heh
13:31:27 <simpson> MattY: Did you consider not using Show at all?
13:31:30 <classius> henk: Your link doesn't seem to be working here.
13:31:47 <classius> simpson: Those who don't study history, etc. etc.
13:32:29 <simpson> classius: I had a girlfriend once who told me that that was a famous quote by Santana. I was quite confused.
13:32:33 <donri> MattY: but you might be looking for something like text-format, rather than Show
13:32:34 <MattY> donri your code doesn't work unfortunately
13:32:40 <ski>   show' a = fromMaybe (show a) (cast a)
13:32:41 <Cale> henk: Use a proper time representation, and you'll spare yourself the arithmetic and have access to lots of formatting stuff.
13:32:49 <ski> donri ^
13:33:06 <donri> oh right you need cast
13:33:37 <donri> MattY: see ski's version
13:33:38 <classius> henk: Oh, my mistake. I was copying the colon.
13:34:03 <MattY> simpson if I didn't use show I couldn't use prettyPrint with all the trees
13:34:08 <henk> classius: Good to know, will try to avoid that in the future.
13:34:32 <henk> Cale: Can you suggest a good one? All I found so far do not seem to meet my requirements …
13:34:35 <classius> henk: I suspect that your function on line 23 *could* be rewritten with a fold. But a scan would probably be more direct.
13:34:50 <simpson> MattY: Show isn't pretty, it isn't supposed to be or required to be pretty, and I'm not sure why you'd ever expect it to be.
13:34:59 <zol> How do I take the nth item from a list?
13:35:00 <ski> MattY : couldn't you define instances of `PrettyShow' for all the data types that you care about ?
13:35:11 * hackagebot csv-nptools 0.4.0 - A collection of CSV tools  http://hackage.haskell.org/package/csv-nptools-0.4.0 (NicolasPouillard)
13:35:13 <classius> zol: Generally speaking, you don't.
13:35:16 <donri> zol: xs !! n, and pray the list is long enough
13:35:17 <classius> zol: However, (!!)
13:35:17 <Cale> henk: Data.Time.* has almost everything I think someone could reasonably want :)
13:35:23 <henk> classius: Is it just 'scan'? I don’t know that function.
13:35:29 <classius> :t scanl
13:35:29 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
13:35:36 <henk> Cale: hm, ok, I’ll take another look, thank you.
13:35:40 <zol> classius: donri: thanks!
13:35:40 <Cale> Let me just look at what your code is doing here
13:35:47 <henk> classius: thank you
13:36:14 <ski> MattY : anyway, `Show' is typically meant to show a text representation of a value such that the text representation is generally a valid haskell expression evaluating to the given value
13:36:20 <MattY> simpson I don't expect it to be, that is why I wrote another class, which uses show by default, or prettified version of show if it exists
13:36:30 <classius> :t scanl1
13:36:31 <lambdabot> (a -> a -> a) -> [a] -> [a]
13:36:34 <Cale> > scanl (+) 0 [1,2,3,4,5]
13:36:35 <lambdabot>   [0,1,3,6,10,15]
13:36:37 <loadedanvils> Cale: if I want to directly parse the output as JSON can I use >>= to put it in there?
13:36:40 <classius> (unlike fold?1, scanl1 is perfectly safe)
13:37:05 <henk> Cale: Calculating the time needed for each task (by subtracting the timestamp (unix epoch) of the previous entry) and converting the time needed in seconds to H:M:S notation, but I’d like H:MM:SS notation …
13:37:28 <ski> MattY : if you want pretty-printing, you're better off (a) with a few separate functions, for the datatypes you care about; or maybe (b) a new class, whose instances doesn't use `Show' constraints (since it's unrelated to `Show')
13:37:30 <Cale> ah, okay
13:38:39 <ski> (you're still allowed to use `show' or `shows' or `showPrec' for a few "primitive" cases in this class, but you shouldn't rely extensively on `Show' (like arbitrary instances of it), imho)
13:40:05 <Cale> henk: Oh, I guess NominalDiffTimes don't quite display like that.
13:40:57 <Cale> So that's unfortunate
13:41:09 <Cale> I suppose the quickest thing would just be to use printf
13:42:01 <`^_^v> is there a better way to write this type of pattern? http://lpaste.net/8689873215348015104
13:42:02 <Cale> > printf "%02d:%02d:%02d" 2 3 50 :: String
13:42:03 <lambdabot>   "02:03:50"
13:42:36 <classius> formatTime "%T" :: TimeOfDay -> String -- ?
13:43:23 <ElectroStatik> hello
13:43:50 <yrlnry> classius:  Thanks again.
13:43:57 <classius> yrlnry: welcome!
13:45:04 <ElectroStatik> i'm trying to construct a type 'List' with a value constructor associated with a component [a], how would I do this?
13:45:19 <Cale> `^_^v: findSymbol xs y = msum [find (== y) x | x <- xs]
13:45:32 <classius> :t msum
13:45:39 <lambdabot> MonadPlus m => [m a] -> m a
13:45:59 <classius> How about find (== y) (concat xs) ?
13:46:08 <Cale> Or of course, you can concat, yes
13:46:18 <Cale> (in this case, anyway!)
13:46:28 <Eduard_Munteanu> ElectroStatik: newtype List a = List [a]  ?
13:46:31 <classius> Better yet: what about filter (==y) (concat xs)? =)
13:46:45 <Cale> That has a different type
13:46:53 <classius> Yes, I know.
13:47:24 <henk> Cale: ok, thank you
13:47:31 <classius> "find" is "filter" for people that haven't grokked laziness yet. ;-)
13:48:22 <chrisdone> Cale: Prelude> :m + Formatting Formatting.ShortFormatters
13:48:23 <chrisdone> Cale: Prelude Formatting Formatting.ShortFormatters> format (l  2'0' %":" %l 2 '0' %":" %l 2 '0') 2 3 50
13:48:23 <chrisdone> Cale: "02:03:50"
13:48:26 <chrisdone> \o/
13:48:43 <Cale> henk: Oh, you could use TimeOfDay like classius mentioned, but that treats times greater than 24 hours by converting the additional time to leap seconds.
13:49:08 <`^_^v> (find (== y) x) <|> (findSymbol (STImpl xs) y) seems more readable to me
13:49:13 <classius> Yeah, it's a hack. Don't use TimeOfDay.
13:49:39 <henk> Yeah, that’s not good …
13:49:43 <Cale> It would be nice to have the time formatting stuff available for DiffTimes
13:49:47 <henk> thanks for the suggestion though
13:50:07 <classius> Cale: Agreed. It would need some new formatters, though, I think.
13:50:15 <classius> Or more relaxed descriptions of what the current formatters do.
13:50:28 <Cale> (or even just a second, similar function for that)
13:50:34 <chrisdone> i shall add them to Formatting!
13:50:35 <classius> right
13:50:41 <chrisdone> http://lpaste.net/6970058869967945728
13:50:46 <chrisdone> looks nice with syntax highlighting
13:50:57 <classius> chrisdone: Why not add them to Data.Time.Format??
13:51:36 <chrisdone> classius: well, why do you think i want don't to use Text.Printf?
13:51:50 <classius> wat
13:52:06 <chrisdone> Text.Printf and Data.Time.Format are stringly typed
13:52:31 <classius> Okay, if I switch "don't" and "want" then that question makes sense.
13:52:35 <classius> And is a good answer to my question. =)
13:52:54 <classius> just took me a second to get it =)
13:53:26 <chrisdone> sorry, i grammarfailed
13:53:44 <chrisdone> word transposition is a new one…
13:55:16 <classius> chrisdone: ?where Formatting
13:55:46 <chrisdone> classius: http://hackage.haskell.org/package/formatting
13:56:00 <classius> thanks
13:59:15 <stolaruk> I am in the "StateT WorldState IO ()" monad. I would like to map a function of type "Int -> StateT WorldState IO ()" over a list of Ints. How can I do this? (I was able to write a method of type "[Int] -> StateT WorldState IO ()" that uses explicit recursion, but I'm wondering if I can find a better solution using some variant of "map").
13:59:45 <classius> ?hoogle (Int -> StateT WorldState IO ()) -> [Int] -> StateT WorldState IO ()
13:59:45 <lambdabot> Did you mean: (Int -> StateT WorldState (IO a) ()) -> [Int] -> StateT WorldState (IO a) ()
13:59:45 <lambdabot> No results found
13:59:55 <classius> bah
13:59:57 <classius> :t mapM
13:59:58 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
14:00:00 <classius> :t mapM_
14:00:01 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
14:00:53 <stolaruk> The function I want to map is not just "m b", it's in a transformer stack. So would I lift it first?
14:00:58 <classius> ?hoogle (Int -> m ()) -> [Int] -> m ()
14:00:58 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
14:00:59 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
14:00:59 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
14:01:12 <startling> stolaruk, what's its type?
14:01:16 <classius> stolaruk: Really? What you just said does not match your initial question.
14:01:34 <stolaruk> I want to map, over a list of Ints, a function of type "Int -> StateT WorldState IO ()"
14:01:44 <classius> stolaruk: m = StateT WorldState IO
14:01:49 <ayegill> (StateT WorldState IO ()) ~ m () with - yeah that
14:02:01 <stolaruk> oh really?
14:02:02 <stolaruk> ok
14:02:37 <classius> stolaruk: Sure, why not? Your only obligation is to show that Monad m, that is, that Monad (StateT WorldState IO). Which is true.
14:02:41 <Cale> monochrom: you might find this amusing http://blogs.msdn.com/b/oldnewthing/archive/2013/10/29/10461148.aspx
14:02:48 <stolaruk> I didn't realize that a simple "m" could represent all that.
14:03:04 <stolaruk> classius: Oh I see.
14:03:07 <stolaruk> Thanks!
14:03:11 <stolaruk> I'll try that.
14:03:40 <ocharles> Does anyone have any experience with pChainl in uu-parsinglib? I get an infinite loop trying to parse something with left recursion, but can't see how to fix it :(
14:04:45 <ocharles> http://lpaste.net/3939102089858252800 being what I have so far
14:05:30 <ocharles> I can remove the 'identifier' part and it still loops
14:07:17 <classius> Does it loop if you get rid of lines 2 and 4, too?
14:07:50 <ocharles> classius: and just have the chainl?
14:08:10 <classius> ocharles: Well. It's a pchainr_ng in your code. But yes.
14:08:14 <ocharles> right
14:08:19 <ocharles> yes, it still loops on parsing "1"
14:08:30 <ocharles> (with pChainl and pChainr_ng)
14:08:47 <FreeFull> ocharles: What if you get rid of the asum too?
14:08:58 <classius> that doesn't matter
14:09:15 <ocharles> classius: doesn't matter, but to confirm: it loops
14:09:26 <FreeFull> It's nice to just minimise things as much as possible
14:09:32 <classius> asum [x] = x
14:09:32 <ocharles> indeed
14:09:39 <classius> ?src asum
14:09:40 <lambdabot> Source not found. Are you typing with your feet?
14:10:49 <classius> uu-parsinglib's docs are a bit light, huh?
14:11:17 <ocharles> yea...
14:11:27 <FreeFull> When in doubt, look at the library's code
14:11:42 <hpc> use the source, luke
14:11:46 <classius> Even looking at the code is easier when the docs are good.
14:11:46 <ocharles> but the shorter case is: expression = pChainl ((\o a b -> Operator a o b) <$> pSym '+') expression
14:11:53 <ocharles> the code is pretty nasty
14:12:12 <FreeFull> Have you considered using a different parsing lib?
14:12:21 <classius> bah and posh
14:12:28 <classius> Fight this lib until you understand it!
14:12:33 <ocharles> yes, i am fine with parsec, but i like the theory behind uu-parsinglib
14:12:54 <ocharles> uu-parsinglib seems to fits nicely for case insensitive parsing due to the way it's formulated, too
14:12:58 <FreeFull> Write your own uu-parsinglib?
14:13:00 <ocharles> (and i also have this working with alex/happy)
14:13:23 <ocharles> FreeFull: you think it would be more productive i wrote my own parsing library than just worked out what's going wrong in one place?
14:13:25 <Eduard_Munteanu> Should I use 'Real a' if I just mean '(Num a, Ord a)'? I don't care about toRational.
14:13:29 <classius> The source for pChainr_ng uses (<**>) which isn't exported. =/
14:13:48 <classius> Or... no, it's exported, but not in the documentation.
14:13:49 <classius> urgh
14:14:30 <startling> yeah, I tried helping someone with uu-parsinglib here a few week ago and the docs were disappointing
14:14:42 <classius> How am I supposed to read http://hackage.haskell.org/package/uu-parsinglib-2.8.1/docs/doc-index-60.html which mentions <**>?
14:14:59 <classius> It points at two modules, but the source for those modules don't mention <**> at all...
14:15:19 <Eduard_Munteanu> classius: isn't it 'flip (<*>)', IIRC?
14:15:35 <classius> Oh, is it not a uu-parsinglib-specific thing?
14:15:37 <classius> That would explain it.
14:15:41 <classius> :t (<**>)
14:15:42 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
14:16:01 <Eduard_Munteanu> classius: it should be defined in the base Applicative module
14:16:04 <ocharles> yea, it's from base
14:16:53 <Eduard_Munteanu> classius: in fact only (<?>) and (<??>) there are parser-specific, I guess
14:17:18 <classius> :t (<??>)
14:17:19 <lambdabot> Not in scope: `<??>'
14:17:54 <classius> Why would pChainr need something parser-specific where pChainr_ng does not? very strange
14:17:56 <Eduard_Munteanu> classius: flip (<?>), I presume, where (<?>) attaches an error message to a parser to use when it fails
14:18:20 <classius> There's no way the error message is a parser.
14:18:35 <Eduard_Munteanu> classius: it isn't
14:18:39 <classius> (Which both arguments to <??> there seem to be.)
14:18:58 <Eduard_Munteanu> classius: (<?>) :: p a -> String -> p a
14:19:00 <ocharles> (<??>) is a non-greedy (<**>)
14:19:03 <Eduard_Munteanu> http://hackage.haskell.org/package/uu-parsinglib-2.8.1/docs/Text-ParserCombinators-UU-Core.html#v:-60--63--62-
14:19:16 <Eduard_Munteanu> Hm.
14:19:45 <classius> ocharles: I'm kind of surprised by this "greedy" and "non-greedy" stuff. Doesn't uu-parsinglib return all parses?
14:19:53 <ocharles> I found that a bit odd too
14:19:57 <classius> Or is the point that this changes the order of the parses?
14:20:36 <ocharles> so in short, pChainl takes two parsers, 'op' and 'x' and parses an x, then a list of 'ops' followed by 'x's
14:20:39 <Eduard_Munteanu> classius: probably makes sense if you have overlapping parsers, the greedy one would take precedence I guess
14:21:41 <classius> Eduard_Munteanu: If you are returning all parses, what does "precedence" mean?
14:21:54 <ocharles> I wonder if it might be because of the error correction uu-parsinglib does...
14:22:11 <ocharles> "1" is not of the form "1 + 1", so maybe it constantly tries to correct itself into "1 + 1 + 1 + 1..."
14:22:16 <ocharles> because I don't get <<loop>> in ghci
14:22:25 <ocharles> so it at least seems to be productive
14:23:09 <classius> Well, <<loop>> takes longer in ghci than in compiled code.
14:23:11 <classius> (Did you know that?)
14:23:12 <Eduard_Munteanu> classius: perhaps you're supposed to use it if the parse you're interested in would otherwise be hard to access from an all-parses list.
14:23:47 <Eduard_Munteanu> classius: e.g. matching a '.*x' regex
14:24:04 <classius> Eduard_Munteanu: Yeah, that's my working hypothesis, too: "precedence" means "earlier in the list".
14:24:48 <classius> ocharles: good luck with that -_-
14:25:37 <darthdeus> guys, i'm screwed ... ever since i understood monads (at least to some level) about a week ago I see them EVERYWHERE now
14:26:27 <dv-_> i don't know what you're >>= talking about
14:26:31 <Eduard_Munteanu> Haskell Persisting Perception Disorder? :P
14:26:37 <FreeFull> Functors and monoids are everywhere, monads not as much
14:26:55 <startling> some parsers may match if greedy and not match if not greedy.
14:27:18 <darthdeus> FreeFull: in the world of c# surprisingly a lot of things are designed as monads, which is kinda funny
14:27:26 <ocharles> startling: and some may just loop :
14:27:27 <ocharles> :P
14:27:34 <startling> ocharles: yep!
14:27:46 <Eduard_Munteanu> startling: would that be the case for lazy / infinite stream parsing?
14:27:50 <startling> people are kind of silly about parsers.
14:27:58 <startling> Eduard_Munteanu: I don't know.
14:28:02 <ElectroStatik> I wish the Scala community was this good
14:28:16 <dobblego> darthdeus: C# has monad comprehension syntax
14:28:54 <darthdeus> dobblego: err monad comprehension?
14:29:06 <dobblego> darthdeus: do-notation
14:29:06 <darthdeus> is that like list comprehension?
14:29:13 <ocharles> I'm pretty certain the problem is because there is no 'base case' to this pChainl
14:29:20 <ocharles> so it constantly tries to correct itself into oblivion
14:29:26 <Eduard_Munteanu> darthdeus: yes, list comprehensions easily generalize to arbitrary monads
14:29:30 <ocharles> for example, unwrapping it a bit:
14:29:31 <ocharles> parse (lexeme (some pDigit) *> operator *> lexeme (some pDigit) *> operator *> pEnd) . createStr (0::Int) $ "1 > 1"
14:29:36 <ocharles> [--    Inserted  '>' at position 5 expecting one of ['0'..'9', Whitespace]]
14:29:44 <darthdeus> hmm interesting
14:30:29 <dobblego> C# uses select/from/in keywords and is slightly better and worse than haskell in different ways
14:30:50 <prophile> :t (*>)
14:30:51 <lambdabot> Applicative f => f a -> f b -> f b
14:31:16 <FreeFull> C# has LINQ
14:31:27 <darthdeus> dobblego: yeah after watching some of the channel9 functional programming videos where they compare c# and haskell it's surprisingly similar in some ways, especially with LINQ
14:31:50 <dobblego> darthdeus: that's because Erik Meijer is sneaking language features in without the C# guys noticing
14:32:03 <darthdeus> haha
14:32:08 <Heffalump> dobblego: except he's left :-)
14:32:17 <FreeFull> People do like LINQ's power though
14:32:18 <dobblego> yeah except that
14:32:18 <darthdeus> Heffalump: really? :O
14:32:21 <Eduard_Munteanu> darthdeus: basically [ f x y ... | x <- xs, y <- ys, ... ] is just  do { x <- xs; y <- ys; ... ; return (f x y ...) }
14:32:32 <darthdeus> he left? he's kinda why i got into c# :\
14:32:51 <FreeFull> I think F# is a bit of a testing ground for C#
14:33:03 <dobblego> from x in xs; from y in ys; select f(x, y)
14:33:18 <Eduard_Munteanu> @undo [ f x y | x <- xs, y <- ys ]
14:33:18 <lambdabot> concatMap (\ x -> concatMap (\ y -> [f x y]) ys) xs
14:33:36 <Eduard_Munteanu> darthdeus: guess what concatMap is. :)
14:33:47 <dobblego> SelectMany
14:34:23 <Eduard_Munteanu> @compose @pl @undo [ f x y | x <- xs, y <- ys ]
14:34:23 <lambdabot> Plugin `compose' failed with: Unknown command: "@pl"
14:34:31 <darthdeus> Eduard_Munteanu: SelectMany? :P
14:34:31 <Eduard_Munteanu> Hrm.
14:35:11 <Eduard_Munteanu> darthdeus: well, I was going for concatMap f = concat . map f = join . fmap f = (>>=)  :)
14:35:36 <Eduard_Munteanu> @@ @pl (@undo [ f x y | x <- xs, y <- ys ])
14:35:36 <lambdabot>  (ys >>=) . flip flip [] . ((:) .) . f =<< xs
14:35:40 <Eduard_Munteanu> Grr.
14:37:24 <Eduard_Munteanu> Well, I should have said '(>>= f)'.
14:38:25 <ocharles> screw it, i'm emailing Doaitse
14:39:04 <Eduard_Munteanu> ocharles: is that when () gets pulled apart? :P
14:39:55 <Eduard_Munteanu> Wait, that's a real name, I thought it was a pun on Goatse.
14:40:07 <jkoppel> cabal install libssh2-0.2.0.1 ... cabal: The pkg-config package libssh2 version >|=1.2.8 is required but it could not be found
14:40:09 <jkoppel> WTF?
14:40:18 <frx> why isn't minimal complete definition for Ord (<), instead of (<=)?
14:40:36 <Eduard_Munteanu> frx: because Eq is a superclass of Ord
14:40:49 <frx> Eduard_Munteanu right, so it already has == from Eq
14:40:53 <hpc> Eduard_Munteanu: but (<) still produces a complete definition
14:41:00 <hpc> frx: does it work if you do just (<)?
14:41:05 <hpc> like, if you actually try
14:41:15 <frx> hpc I did not try, but docs say "Minimal complete definition: either compare or <=."
14:41:22 <Eduard_Munteanu> Well, I mean  a == b  ~  (a <= b) and (b <= a)
14:41:34 <dcoutts_> jkoppel: as it says, the pkg-config libssh2 isn't installed, ie the C libs (dev headers etc)
14:41:44 <hpc> i expect that's a logistical issue to defining all those mutually recursive definitions, then
14:41:45 <dcoutts_> jkoppel: pkg-config is the key word there
14:41:56 <hpc> and it's easier to just say "(<=) is your entry point to instance writing"
14:42:35 <jkoppel> dcoutts_: Thanks! Thought it was saying the Haskell package I was trying to install wasn't installed...
14:42:35 <dcoutts_> jkoppel: probably just a matter of installing the -dev variant of the libssh package using your system package manager
14:42:40 <Eduard_Munteanu> So morally your Eq and Ord notions of equality should be identical.
14:43:16 <jkoppel> dcoutts_: I just managed to install libssh2-0.2 without a hitch, so something's up
14:43:37 <Eduard_Munteanu> Also I presume (<=) is less efficient to derive from separate (<) and (==).
14:44:58 <jkoppel> Can't you just define x > y = y < x, and then definite x <= y = not (y > x)?
14:47:23 <dcoutts_> jkoppel: did you install the -dev flavour of the system package?
14:47:39 <dcoutts_> jkoppel: many distros split the development headers of C libs into a separate package
14:48:14 <jkoppel> dcoutts_: Still figuring out whether libssh2-dev exists
14:48:21 <apo> Well, I've never written quicksort quite this quickly
14:48:25 <apo> I'm beginning to like haskell
14:48:38 <Eduard_Munteanu> apo: just wait until someone nitpicks that it's not quicksort :P
14:49:20 <jkoppel> dcoutts_: Thanks a lot. Just reinstalled libssh2 from MacPorts instead of from source; cabal magically started complying
14:49:37 <danr> did I hear someone say treesort?
14:50:10 <Eduard_Munteanu> quicksort and treesort... maybe we can compromise and call it tricksort? :P
14:51:18 <Hodapp> hey, don't forget Shell sort. Some guy from my university came up with that one.
14:51:33 * startling . o O ( If I use Mechanical Turk, can I call it Clicksort? )
14:52:02 <Eduard_Munteanu> Hodapp: is that when you map sleep over your list in a shell? :D
14:52:03 <ocharles> startling: that's cloudsort
14:52:26 <hpc> what if i change the ordering so my list is now sorted as-is?
14:52:33 <ocharles> or maybe cloudsort is POST http://so.rt.myda.ta/
14:52:42 <hpc> 6 > 4, 8 == 7, acme-microwave, etc
14:52:54 <hpc> 6 < 4, rather
14:53:32 <danr> Eduard_Munteanu: nice trick ;)
14:55:26 <apo> Eduard_Munteanu: nope. Not gonna show it to anybody! :P
14:57:35 <chrisdone> Eduard_Munteanu: sleep sort!
14:57:44 <joelteon> anybody know if there's a package with a Money type for persistent?
14:58:41 <chrisdone> Eduard_Munteanu: http://dis.4chan.org/read/prog/1295544154
14:58:53 <intrados> I'm using ghc-mod with emacs. When I import a local module, C-c C-i (to get info on a function) reliably chokes with "Dummy:0:0:Error:Cannot add module Contrib to context: not interpreted"
14:59:10 <chrisdone> the exciting world of ghc-mod
14:59:11 <lpaste> Prinsen pasted “HXT” at http://lpaste.net/94972
14:59:32 <prinsen> Having some problems with arrows and Maybe
14:59:42 <intrados> Where "Contrib" is a local module
15:01:28 <prinsen> I am unable to "get the value" back from inside the Maybe
15:01:44 <prinsen> as I am new to arrows, I am sure there is something easy im missing
15:05:35 <prinsen> anyone out there?
15:06:07 <myname_> pl \x y -> x y
15:06:08 <startling> prinsen: can you annotate with type signatures + the error?
15:07:52 <glguy_> myname_: id
15:07:58 <lpaste> Prinsen annotated “HXT” with “HXT (annotation)” at http://lpaste.net/94972#a94973
15:08:14 <prinsen> I cant do the type signatures as Im very new to this
15:09:28 <myname_> @pl \x y -> x y
15:09:28 <lambdabot> id
15:09:43 <Eduard_Munteanu> myname_: maybe you want ($)
15:10:45 <myname_> @pl \x y -> nub (sort ((++) x y))
15:10:45 <lambdabot> ((nub . sort) .) . (++)
15:12:01 <prinsen> startling: I annotated the paste
15:12:55 <startling> prinsen, the issue is "arr (fmap (getList "url") )"
15:12:58 <startling> :t arr
15:12:59 <lambdabot> Arrow a => (b -> c) -> a b c
15:17:26 <prinsen> startling: I am really stuck here
15:17:49 <startling> prinsen, well, look at the type of getList
15:20:17 * hackagebot concraft-pl 0.4.0 - Morphological tagger for Polish  http://hackage.haskell.org/package/concraft-pl-0.4.0 (JakubWaszczuk)
15:23:23 <prinsen> startling: String -> a (Data.Tree.NTree.TypeDefs.NTree XNode) [String]
15:23:41 <chrisdone> Peaker: hey!
15:23:49 <startling> prinsen, I suspect that's not true.
15:23:50 <Peaker> chrisdone: hey!
15:24:00 <startling> prinsen, I think you're missing a constraint.
15:24:01 <chrisdone> Peaker: did you have any small success with shm?
15:24:04 <Peaker> chrisdone: I did manage to get it to work on your Main.hs, but it couldn't parse any of my files that I tried
15:24:20 <prinsen> Yes Arrow a =>
15:24:21 <Peaker> though I had only very superficial toying around as of yet, it is cute :)  I'm really missing undo!
15:24:30 <Peaker> (need to remove read-onlyness to get undo again)
15:24:43 <prinsen> ArrowXml a
15:24:54 <startling> prinsen: OK. So what the type of getList "url" is Arrow a => a (NTree XNode) [String], yeah?
15:25:00 <chrisdone> Peaker: right -- i'd bet that it's an extension. it seems to be that this patched version of HSE doesn't handle extensions as specified ('all'). e.g. anything with RecordWildCards fails. but yeah, that it fails is expected (for now!)
15:25:03 <prinsen> startling: yes
15:25:30 <startling> prinsen: oh, no, it's ArrowXml. that's an important distinction.
15:25:35 <startling> prinsen, so, look at this
15:25:36 <Peaker> chrisdone: I could really use a diagnostic about where the failure is.. maybe I'll work on adding that... currently a bit over-committed for the next week or so
15:25:36 <startling> :t fmap
15:25:37 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:25:39 <chrisdone> Peaker: yeah, that's an easy thing to add, come to think of it. undo can simply be (let ((inhibit-read-only t)) (undo) (shm/reparse)) ;; more or less
15:26:05 <startling> prinsen: ^ the first argument to fmap must have type "a -> b" a.k.a "(->) a b"
15:26:25 <startling> prinsen, but there's no ArrowXML instance for (->).
15:26:25 <prinsen> startling: right
15:26:47 <chrisdone> Peaker: at this stage you can leave it to me as i'm unable to use it myself yet, i'll let you know when i think it's usable. but i'm happy you tried it out even in this stage =)
15:27:15 <chrisdone> Peaker: but good point, it should print the parse error rather than failing opaquely
15:27:16 * chrisdone puts it down as TODO
15:27:24 <Peaker> chrisdone: I really liked the indent/alignment moving properly, and the structural selections
15:27:29 <prinsen> startling: I assume Im tackling the Maybe from the wrong direction. arrows in HXT has been easy so far, but I'm unable to tackle this
15:27:50 <startling> prinsen, I don't think Maybe has anything to do with it.
15:28:32 <Peaker> chrisdone: me and yairchu avoid all alignments in Haskell code (and newline like crazy) just because we don't have this feature in our editors
15:28:35 <chrisdone> Peaker: yay! i'm glad =)
15:28:41 <Peaker> chrisdone: we don't want every rename to break alignments
15:29:06 <chrisdone> Peaker: yeah. it's funny -- having this feature changes you
15:29:23 <Peaker> Yeah, the trade-offs all change with the tools and "best practices" change accordingly
15:29:30 <Lindrian> Are there any good introduction videos for haskell?
15:29:41 <Peaker> just like currying makes less sense to use everywhere once you have a good structural IDE :)
15:29:52 <chrisdone> Peaker: mgsloan (coworker) would grumble slightly about my reliance on alignments (because it's effortless for me with shm), but now that he's added it to the fp complete IDE, i suspect i will be seeing it more in his code too =p
15:30:01 <ReinH> chrisdone: yaaaaaaay!
15:30:12 <chrisdone> ReinH: great podcast!
15:30:16 <ReinH> chrisdone: <3 thanks!
15:30:29 <ReinH> chrisdone: it's amazing what you can do if you just shut up and let SPJ talk :D
15:30:46 <donri> chrisdone: alignment makes for shitty patches :(
15:31:02 <chrisdone> Peaker: that's an interesting point -- in lamdu you can "indent" (present) however you like, i presume there's no user-control over that? are there different "themes" for presenting things?
15:31:25 <Peaker> chrisdone: there aren't different themes, but of course there could easily be, as the GUI is rather decoupled form the code's presentation
15:31:42 <chrisdone> ReinH: haha, yeah. oddly, my "wait, woah" moment was that he actually changed the ciricculum in the UK to include CS in primary school. WHAAAT
15:31:50 <prinsen> startling: Well I have an Maybe XmlThingy and I want to apply the arrow (bear with me Im new to this), so I tought of using fmap. Is there any other solution?
15:31:53 <ReinH> chrisdone: :D yeah really excited about that
15:32:07 <Peaker> There's the low-level System-F repr (which fits in a <100lines module), and it is sugared to a much more complex representation (that also has OO-ish editing operations alongside the data), and the GUI is a thin wrapper over that
15:32:14 <chrisdone> Peaker: right. one thing i worried about in my browser-based prototype was "when do i go to a newline"?
15:32:15 <ReinH> chrisdone: I need to learn Agda or some other dependently typed system now. Suggestions?
15:32:25 <ReinH> chrisdone: I want to work on proving the lattice properties for LVar data structures.
15:32:35 <chrisdone> hah
15:32:41 <donri> chrisdone: i think this whole computing in school thing is both awesome and terrifying. schools tend to make cool subjects seem boring and painful.
15:32:43 <ReinH> I just talked to Lindsey Kuper about it here at RiconWEST and it's fascinating
15:32:53 <chrisdone> ReinH: johnw would recommend agda, with some enthusiasm, i might add =p i'm still baby steps with it
15:33:12 <ReinH> johnw: suggestions for learning agda?
15:33:16 <ReinH> do I need to learn emacs? ;)
15:33:19 <chrisdone> donri: that's true. what was the quote? want to ruin something, teach it in school?
15:33:22 <startling> prinsen: aha.
15:33:23 <ReinH> (relearn emacs)
15:33:30 <donri> chrisdone: haha hadn't heard it
15:33:38 <user1358> @pl (\l -> key!!(ord l - 97))
15:33:39 <ReinH> donri: oh god yes, just look at what happened to math
15:33:41 <lambdabot> (key !!) . flip ((-) . ord) 97
15:33:41 <lambdabot> optimization suspended, use @pl-resume to continue.
15:33:43 <ReinH> infinite :(
15:33:47 <chrisdone> ReinH: possibly at least a few bindings, though the agda-mode is pretty sweet
15:33:52 <donri> ReinH: exactly. i'm just *now* discovering how math is awesome.
15:34:11 <user1358> @pl-resume (\l -> key!!(ord l - 97))
15:34:17 <lambdabot> (key !!) . flip ((-) . ord) 97
15:34:17 <lambdabot> optimization suspended, use @pl-resume to continue.
15:34:17 <ReinH> donri: indeed
15:34:55 <chrisdone> Peaker: the system-f representation sounds nice =)
15:35:05 <chrisdone> Peaker: i bet that's useful for structural diffs =p
15:35:27 <nbouscal> ReinH: pretty sure agda has vim bindings if that's your preference. Also idris is nice, but I haven't got to agda yet so I can't compare them directly
15:35:32 <donri> then again maybe the existing curriculum is worse if they make kids think computing = microsoft office
15:35:54 <donri> that's a bit like teaching math by teaching how to use a calculator
15:35:55 <glguy_> Can GHCi's ":set stop" take multiple commands?
15:35:58 <donri> (only!)
15:36:49 <ReinH> user1358: how about
15:36:50 <chrisdone> donri: lockhart's lament really applies to any topic in school, really, i think. it's just particularly apt for maths. people don't leave school with a genuine shellshock fear of science and english, unlike maths
15:36:51 <ReinH> @pl \k -> list !! ((-97) + ord k)
15:36:51 <lambdabot> (list !!) . (-97 +) . ord
15:37:07 <donri> chrisdone: oh right i need to read that. got any non-pdf link?
15:37:26 <Peaker> chrisdone: I hope so :) Maybe the diffs ought to happen at the sugared level, we're not sure yet.. we have a long way to go before we do the revision control stuff
15:37:34 <ReinH> chrisdone: yes lockhart's is amzing
15:38:14 <ReinH> ocharles: <3
15:38:30 <chrisdone> donri: i can't find a non-pdf version
15:38:37 <augustss> Arr!
15:38:46 <donri> chrisdone: alright. i'd like to read it on the ereader :)
15:38:46 <startling> your library might have a dead-tree one.
15:38:49 <donri> which sucks for pdf
15:38:50 <chrisdone> augustss: ahoy!
15:38:57 <prinsen> startling: so (>>^) is what i need?
15:39:00 <chrisdone> donri: yeah D:
15:39:15 <chrisdone> Peaker: i look forward to future developments about that topic
15:39:20 <donri> chrisdone: although i hear it sucks less on the kobo aura hd. you should get one and review for me.
15:39:30 <chrisdone> Peaker: it seems a bit of an unexplored space in the popular/real world
15:39:42 <startling> prinsen: it doesn't look like it.
15:39:53 <chrisdone> donri: i was trying to get a kindle but apparently living in italy isn't good enough for amazon D:
15:39:56 <startling> oh, well, you could use it to supply a default for Nothing.
15:40:04 <allsystemsarego_> How do I turn [[Just 1,Just 2,Just 3],[Just 4,Just 5]] into [[1,2,3],[4,5]] ?
15:40:19 <donri> chrisdone: don't get kindle. no epub and silly apple-style sense of lock-in
15:40:23 <chrisdone> :t map catMaybes
15:40:24 <lambdabot> [[Maybe a]] -> [[a]]
15:40:38 <allsystemsarego_> chrisdone, thanks
15:40:38 <startling> :t mapM sequence
15:40:38 <chrisdone> donri: b-but the paperwhite!
15:40:39 <lambdabot> Monad m => [[m a]] -> m [[a]]
15:40:42 * chrisdone drools a bit
15:40:48 <donri> chrisdone: kobo aura hd is better :)
15:40:50 <Peaker> chrisdone: funnily, the only pioneer in that area that I know of is Microsoft Word, heh :) Integrating change tracking with revision control (rather than the usual git/darcs change-guessing)
15:41:23 <donri> chrisdone: .8 inch larger screen and higher pixel density with the same frontlight tech
15:41:48 <Peaker> chrisdone: This reminds me of "Brief, wrong history of PLs" where he said "Java made lambdas popular by not having them".  Word made change tracking unpopular by having it :)
15:41:49 <chrisdone> donri: hm, cool. sounds nice. maybe they ship to my apparently-unworthy country
15:42:02 <donri> chrisdone: but you could probably order a paperwhite from amazon.co.uk.  .com doesn't ship internationally
15:42:07 <Peaker> chrisdone: the UK?
15:42:18 <chrisdone> Peaker: haha… in a sense, Java and C++ made static type systems unpopular by having a bad one, too =p
15:42:24 <chrisdone> Peaker: no, Italy =(
15:42:32 <chrisdone> donri: oh, really?
15:42:36 <donri> chrisdone: http://www.kobo.com/koboaurahd/wheretobuy/
15:43:08 * chrisdone . o O ( amazon can't figure that out and take me to the right “domain”? )
15:43:42 <hpc> it's probably a tax thing
15:43:45 <chrisdone> donri: do you have one?
15:43:58 <donri> chrisdone: i have the paperwhite (first version)
15:44:04 <chrisdone> oic
15:44:18 <donri> (they just released an upgraded version)
15:44:20 <chrisdone> is it as sexy as it looks in the photoshopped pictures?
15:44:36 <donri> i think it's sexy but i haven't seen anything else IRL ;P
15:45:18 <startling> I saw this the other day: http://waterfi.com/waterproof-kindle
15:45:32 <chrisdone> but yeah i want a good paper-reading thing to read moar haskell and category theory papers
15:45:52 <augustss> 800ms ping time is a real joy killer for the internet. :(
15:46:13 <chrisdone> startling: that's cool. if i had a bath tub or a pool i'd consider investing in one
15:46:33 <ayegill> All I want for christmas is a e-reader(e-ink) with a proper *nix system
15:46:58 <chrisdone> the sony reader uses a linux system afaik. is that not proper?
15:47:16 <ayegill> I was not aware of this thing
15:47:25 <startling> the barns and noble one is android
15:47:36 <chrisdone> http://en.wikipedia.org/wiki/Sony_Reader#Internal_OS
15:47:42 <chrisdone> ^ also android (modified)
15:47:42 <startling> you can root it and everything
15:47:53 <donri> chrisdone: so kobo aura hd. ;) highest pixel density on the e-ink market (265 dpi) and bigger screen than most ereaders (6.8")
15:48:02 <donri> chrisdone: i wish i had one :(
15:48:07 <hpc> is it color?
15:48:11 <fread2281> also kindle is linux
15:48:17 <donri> chrisdone: plus reviews says it has much better pdf app than the kindle
15:48:21 <hpc> also wow, 7"
15:48:35 <glguy_> You guys running Haskell on these things?
15:49:00 * FireFly thought this was -blah for a second
15:49:04 <jle`> i wonder why people introduce functional programming with recursion and stuff before more intuitive things like map and fold
15:49:23 <jle`> maybe it's to make a point that loops aren't possible
15:49:38 <Peaker> jle`: because that isn't bottom up and when asked "how do they work" you have to answer "magic".  Though maybe that is a better way to teach, I haven't empirically tested it myself
15:49:40 <augustss> Recursion is the goto of FP.
15:49:42 <apo> I always found recursion pretty intuitive
15:49:50 <apo> augustss: considered harmful?
15:50:01 <joelteon> first class functions considered harmful
15:50:13 <augustss> apo: Harmful, but useful.
15:50:19 * hackagebot text-icu 0.6.3.6 - Bindings to the ICU library  http://hackage.haskell.org/package/text-icu-0.6.3.6 (BryanOSullivan)
15:50:21 <fread2281> apo: low-level, you should be using more abstractions
15:50:21 <donri> if you need to use explicit recursion you're either learning, doing it wrong, or doing something interesting. :p
15:50:22 <crocket> Does haskell have an editor?
15:50:35 <crocket> lisp languages have emacs.
15:50:41 <Peaker> crocket: there's Yi
15:50:47 <donri> crocket: yi, leksah
15:50:48 <Peaker> but I don't think anything on the scale of emacs exists
15:50:49 <sm> haskell also has emacs
15:50:51 <chrisdone> crocket: not an official one. haskell has vim, emacs, yi, leksah, fp complete
15:50:53 <jle`> Peaker: why would you need to know how map and fold are implemented in order to reason with functional thought process
15:50:55 <crocket> Is Yi a good choice?
15:51:02 <chrisdone> not really, imo
15:51:04 <augustss> crocket: Haskell also has emacs.  Like every other language.
15:51:06 <donri> i want to say yes. but no.
15:51:12 <Peaker> jle`: didn't say you would, but the student might ask how they are implemented
15:51:23 <fread2281> also leksah
15:51:25 <crocket> fp complete?
15:51:30 <crocket> Is it good?
15:51:31 <Peaker> jle`: and there is probably value to bottom up teaching with as little magic as possible
15:51:35 <jle`> Peaker: that's like asking how "while" is implemented in C.
15:51:50 <jle`> I don't think people start C courses with teaching how a compiler compiles while into bytecode
15:51:50 <Peaker> jle`: except you *can* implement map/fold
15:52:05 <Peaker> whereas recursion/"while" in C are magic
15:52:17 <prinsen> startling: urls <- fromMaybe [] <<^ tmp <<< atOptionalTag "urls" -< x is what I got
15:52:22 <prinsen> startling: any hint?
15:52:36 <jle`> you can implement them, but ... i don't really see the conceptual benefit in teaching people the implementation first before what you actually use it for
15:52:41 <Peaker> maybe "can" is the wrong word.  "while" is a primitive, "fold" is a library
15:52:41 <zq__> @src (^)
15:52:41 <lambdabot> x ^ 0            =  1
15:52:41 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
15:52:41 <lambdabot>   where f _ 0 y = y
15:52:41 <lambdabot>         f x n y = g x n
15:52:41 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
15:52:41 <chrisdone> crocket: http://www.youtube.com/watch?v=ZHSBwlm5C8U
15:52:43 <lambdabot>                       | otherwise = f x (n-1) (x*y)
15:52:45 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
15:52:50 <augustss> Peaker: "while" is builtin in C, but can be explained with goto.
15:52:58 <startling> prinsen: sorry, I don't know much about using arrowsand I'm not sure how you'd do it.
15:53:24 <jle`> Peaker: primitive/library, the distinction doesn't really help with actually thinking "in functional style"
15:53:27 <Peaker> augustss: yeah, and you most probably don't want to teach goto first to build up while
15:53:29 <jle`> right?
15:53:42 <FireFly> crocket: most people in here seem to prefer text editors over IDEs (i.e. vim, emacs, etc)
15:54:07 <augustss> zq__: The definition of (^) is a bit involved to minimize multiplications.
15:54:22 <krakrjak> crocket: I like using vim and bind :make command to ghci on the file I'm editing
15:54:23 <chrisdone> augustss: when my connection is awful, i also spend most of my time on IRC too =p
15:54:28 <zq__> augustss: i think the implementation is a bit less than optimal
15:54:48 <Peaker> jle`: yeah, I agree, it might be a better idea to teach whatever set of tools helps learning the FP style - and not the primitives.  Primitives-upwards has some nice properties too IMO, but possibly not worth the downsides
15:54:49 <krakrjak> crocket: this makes it painless to work with my implementation as I go.  Then again I love vim so it's easy for me YMMV.
15:54:54 <augustss> zq__: It's pretty good.
15:55:05 <zq__> augustss: it's lg n complexity, but it's still bigger by a constant factor
15:55:11 <augustss> chrisdone: Guilty as charged.
15:55:22 <jle`> :t (^)
15:55:23 <augustss> zq__: Bigger than what?
15:55:23 <lambdabot> (Integral b, Num a) => a -> b -> a
15:55:35 <zq__> lemme write a better one
15:55:48 <Rylee> 3/query lambdabot
15:55:50 <Rylee> whoops
15:56:16 <chrisdone> =p
15:56:18 <prinsen> Anyone used to arrows?
15:56:34 <prinsen> I will love you for it
15:56:37 <chrisdone> prinsen: i'm used to the concept, but not to the syntax
15:56:44 <augustss> zq__: First check that the one lambdabot shows is the one ghc uses.
15:57:01 <crocket> Krakarn: i chose emacs.
15:57:07 <zq> augustss: how?
15:57:12 <crocket> However, I use vim from time to time.
15:57:15 <zq> augustss: it's not the sme as http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Real.html#^
15:57:21 <prinsen> chrisdone: http://lpaste.net/94972#a94973
15:57:40 <prinsen> chrisdone: starling helped me a bit
15:58:11 <prinsen> chrisdone: now I have urls <- fromMaybe [] <<^ atOptionalTag "urls" -< x
15:58:17 <zq> .msg lambdabot @src (^)
15:58:33 <prinsen> chrisdone: But I need to apply toList "url" to the XmlTree inside the Maybe
15:58:45 <augustss> zq: The ghc one is the one that counts.
15:59:03 <augustss> zq: Because that's the one I wrote. :)
15:59:05 <zq> augustss: not sure which one is the 'ghc one'
15:59:30 <augustss> zq: The one you linked to.
15:59:31 <zq> hm
15:59:51 <augustss> zq: I can't easily look at it.  My connection is terrible.
15:59:52 <zq> augustss: you're not lennart augustsson, are you?
16:00:02 <augustss> zq: I am.
16:00:09 <chrisdone> THE lennart augustsson
16:00:10 <jle`> zq: make sure it works on arbitrary Num and possibly user-defined Num types (that have +,*,-, sign)
16:00:13 <zq> whoa, respect
16:00:27 <chrisdone> prinsen: hmm
16:00:45 <Iceland_jack> augustss: I'm a lowly student who saw your talk at Chalmers this year for the Parallel Functional Programming course, just wanted to thank you for it :)
16:00:54 <chrisdone> prinsen: i can't really tell what's going on here. can  you make a paste that i can copy paste in ghc that will compile?
16:01:12 <prinsen> chrisdone: sure
16:01:25 <chrisdone> prinsen: and e.g. with some commented out line saying "this doesn't work" or w/e
16:01:30 <augustss> Iceland_jack: Thanks.  I wish I'd had something more interesting to say.
16:02:05 <Iceland_jack> It was very interesting
16:02:24 <augustss> Iceland_jack: I'm glad.
16:02:43 <chrisdotcode> hey guys, what is "<-<" called?
16:02:51 <chrisdotcode> :t <-<
16:02:52 <lambdabot> parse error on input `<-<'
16:02:55 <chrisdotcode> :t (<-<)
16:02:56 <lambdabot>     Not in scope: `<-<'
16:02:56 <lambdabot>     Perhaps you meant one of these:
16:02:56 <lambdabot>       `<<<' (imported from Control.Arrow),
16:03:08 <chrisdotcode> :t (<<<)
16:03:09 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
16:03:21 <glguy_> chrisdone: It's pronounced "ascii art"
16:03:32 <augustss> :t (<=<)
16:03:33 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
16:03:39 <augustss> Maybe that one?
16:04:21 <glguy_> chrisdone: Are you reading Pipes code?
16:04:58 <glguy_> In Pipes, (>->) is "pipe composition" and (<-<) is "flipped pipe composition"
16:05:13 <zq> so why is lambdabot's (^) different from the one in base-4.6.0.1?
16:05:19 * hackagebot yaml-light-lens 0.2.0.1 - Lens interface to yaml-light.  http://hackage.haskell.org/package/yaml-light-lens-0.2.0.1 (AnthonyCowley)
16:05:27 <zq> slightly different source, i mean
16:05:34 <prinsen> chrisdone: http://sprend.com/download.htm?C=d3106056de694597962fb3f9df9c4e9a
16:05:35 <chrisdone> glguy_: chrisdotcode is not me
16:05:44 <augustss> zq: The lambdabot sources are a bit old, and tweaked for didactic purposes.
16:05:56 <chrisdone> chrisdotcode: change your nickname, i demand it!
16:06:10 <glguy_> You two are going to have to work that one out, I'm good for about 4 nick characters and a tab
16:06:17 <chrisdotcode> chrisdone: haha, it makes me feel special to occasionally get things meant for you :D
16:06:26 <chrisdone> D:
16:06:33 <zq> glguy_: what about 3 chars and 2 tabs?
16:06:57 <chrisdotcode> but yeah, thanks guys; I was looking for <=<, actually.
16:07:11 <chrisdotcode> and what's it called?
16:07:17 <augustss> chrisdone: (<=<) is Kleisli composition
16:07:20 <chrisdone> reverse fish
16:07:32 <startling> :t (<>~)
16:07:33 <lambdabot> Monoid a => ASetter s t a a -> a -> s -> t
16:07:45 <chrisdone> or forward fish, depending on your culture
16:07:53 <chrisdotcode> thanks :)
16:08:01 <augustss> Hmmm, one of you will have to change name.
16:08:19 <startling> chrisdonecode
16:08:26 <cdc> heh, shame somebody already owns this nick
16:08:45 <chrisdone> well chrisdone is my real name and i've had it for 5 years
16:08:52 <chrisdone> chrisdotcode isn't his real name and he's had it for one year
16:08:53 <chrisdone> i win!
16:08:56 <startling> cdc, c.c?
16:09:16 <augustss> dotcode
16:09:24 <chrisblake> ah, okay. that one's not taken :)
16:09:33 <jle`> ch.co
16:09:35 <chrisblake> oh ,wait. I think it is...
16:09:49 <chrisdone> chrisblake, that looks good on you
16:10:20 <chrisblake> chrisdone: why thank you :) I think I"ll get it registered (shame the twitter handle is taken)
16:10:43 <chrisdone> chrisblake: yeah, i had to use christopherdone for my twitter =(
16:10:49 <jle`> chrisblake: i am sure it will yield with some suggestive power
16:11:07 <chrisdone> the real chrisdone account is taken by someone called Donna Monjuil. /me shakes fist
16:11:28 <chrisblake> chrisdone: yeah, but at least you have your github profile at least...
16:11:59 * chrisdone celebrates
16:12:26 <johnw`> haha
16:13:07 <donri> i have my first name as my github. three letters :)
16:13:34 <johnw`> oOo, I just got to use <$ in a cool way
16:13:43 <chrisblake> donri: lucky man; but it seems you don't have the twitter, either...
16:13:56 <johnw`> modifyMVar_ mutex $ \x -> x <$ action, in order to block on mutex without changing its value in order to have action's effect
16:14:10 <donri> chrisblake: no, had to go @donri there. but don't really use it
16:14:20 <chrisdone> johnw`: nice =)
16:14:32 <prinsen> chrisdone: does it make sense?
16:14:40 <Peaker> johnw`: use a section!
16:14:54 <Peaker> modifyMVar_ mutex (<$ action)
16:15:07 <chrisdone> prinsen: did you make a paste?
16:15:13 <prinsen> http://sprend.com/download.htm?C=d3106056de694597962fb3f9df9c4e9a
16:15:20 <prinsen> I zipped it for you
16:15:24 <chrisdone> that ain't a paste. that's spyware
16:15:30 * chrisdone turns his nose up at the spyware
16:15:46 <prinsen> chrisdone: :) I thougt it easier
16:15:50 <johnw`> Peaker: awesome!
16:15:55 <prinsen> chrisdone: and I want to know your surfing habits
16:16:13 <johnw`> Peaker: in my particular case flip (<$) is nicer
16:16:29 <johnw`> liftIO . modifyMVar_ logCounter . flip (<$) $ do
16:16:50 <prinsen> chrisdone: do you want a paste, I think that getting the full source is easier
16:16:52 <chrisdone> huh… it looks like there is damage to my retina screen D: either that or an ant sneezed on it
16:17:08 <Peaker> johnw`: I sometimes wonder if instead of pure/return, it could be nicer to use   <$  and  "unit :: Applicative f => f ()"   so  x <$ unit   because then it fits into the Applicative pattern as a special case:   (Zero <$ parseZero) <|> (One <$> parseOne) <|> (Two <$> parseTwo <*> parseTwo) ...
16:17:12 <johnw`> chrisdone: what does the damage look like?
16:17:12 <johnw`> ant snot?
16:17:58 <chrisdone> johnw`: a cloud of tiny blueish specs. i'm trying to clean it to see if it's just stubborn surface partcles
16:18:08 <johnw`> actually, i'm going to add this to monad-extras:
16:18:13 <johnw`> holding mutex = modifyMVar_ mutex . flip (<$)
16:18:31 <startling> maybe it's ectoplasm from a ghostly ant
16:19:51 <chrisdone> well, i be damned. it won't be cleaned away. i think it's actual screen artifacts
16:20:03 <glguy_> or just: holding mutex action = withMVar mutex (const action)
16:20:12 <johnw`> oho
16:20:18 <johnw`> even better
16:20:40 <johnw`> i just forgot about withMVar
16:20:50 <glguy_> (No, (withMVar mutex . const) isn't better)
16:21:12 <johnw`> why not?
16:22:38 <johnw`> here is the most complete version for my codebase:
16:22:40 <johnw`> holding mutex action = control $ \run -> withMVar mutex $ \_ -> run action
16:30:21 * hackagebot csv-nptools 0.4.1 - A collection of CSV tools  http://hackage.haskell.org/package/csv-nptools-0.4.1 (NicolasPouillard)
16:33:06 <loadedanvils> can anyone clarify some issues I'm having?
16:34:59 <amalloy> not without some more specific questions
16:37:12 <geekosaur> @where justask
16:37:12 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
16:38:47 <hpc> i can help; i am the master of all things
16:38:52 <hpc> need to solve the halting problem?
16:39:31 <loadedanvils> sorry, I was just testing my haskell code
16:39:43 <path[l]> lol
16:40:20 <loadedanvils> my question is: is there a way to parse an IO string?
16:40:40 <loadedanvils> I'm stating the question badly
16:40:42 <loadedanvils> let me rephrase
16:41:23 <Cale> loadedanvils: Run the IO String, parse the String result.
16:41:38 <Cale> (and then do some other I/O with the result of that)
16:42:02 <loadedanvils> Cale: I've been trying different ways of your solution, I was still confused
16:42:20 <Cale> loadedanvils: an IO String isn't anything like a string, any more than /bin/ls is a list of files.
16:42:30 <loadedanvils> I think I understand you
16:42:52 <Cale> loadedanvils: It's a program which if you were to run it, would give you a String as its result.
16:42:52 <newsham> String.EXE
16:43:00 <Cale> lol
16:43:04 <Cale> but yeah
16:43:25 <loadedanvils> Cale: I got that. I'm just trying to find a function that would put that string somewhere
16:43:27 <newsham> if we called it EXE I wonder if people would be less confused
16:43:45 <newsham> do { s <- getsAString; print s }
16:43:54 <Cale> loadedanvils: You can only run IO actions from inside other IO actions, which is generally not a problem because eventually main is an IO action.
16:44:05 <loadedanvils> right
16:44:11 <Peaker> ".EXE" as a suffix type operator, specifically
16:44:16 <Peaker> main :: ().EXE
16:44:29 <newsham> main :: EXE ()
16:44:31 <loadedanvils> I'm just confused why printing the string is much faster than parsing it
16:44:41 <Cale> hm
16:44:43 <hpc> newsham: Stri~1.EXE
16:44:58 <Cale> loadedanvils: Well, that's something else :)
16:45:15 <loadedanvils> Cale: I feel like I have the wrong function or something but I don't know what's going on here
16:45:23 <Cale> loadedanvils: But on my original point, consider this program:   main = do xs <- getLine; putStrLn (reverse xs)
16:45:35 <newsham> who will be the first to write a ().EXE monad tutorial?
16:45:52 <Cale> reverse :: String -> String (or really [a] -> [a]) doesn't need to know that its argument came from doing I/O stuff
16:46:18 <loadedanvils> is there a way to parse a bytestring as a string?
16:46:40 <Cale> loadedanvils: There are lots of ways
16:46:42 <loadedanvils> for some reason, it's very slow to parse but fast to print
16:47:07 <Cale> What are you currently doing?
16:47:19 <Cale> also, how are you measuring this?
16:47:21 <loadedanvils> (the actual type is Data.ByteString.Lazy.Char8
16:47:41 <Cale> Are you just using unpack?
16:47:43 <loadedanvils> I'm running this: withSocketsDo $ simpleHttp "http://www.dir.bg/" >>= L.putStr
16:47:52 <loadedanvils> and when I unpack, it's much slower
16:47:58 <Cale> Well, for sure
16:48:16 <Cale> What program are you using with unpack in it?
16:48:18 <loadedanvils> I feel there's a function I'm missing (you can probably tell I'm new)
16:48:33 <loadedanvils> Data.ByteString.Lazy.Char8.unpack
16:48:39 <Cale> Yeah, but the whole program
16:48:57 <loadedanvils> Cale: what do you mean
16:49:19 <Peaker> loadedanvils: Data.ByteString.Lazy.Char8 goes back in time before unicode was invented, and brings back the horrors to haunt you in your nightmares
16:49:29 <Cale> Are you doing something like  withSocketsDo $ do page <- simpleHttp "http://www.dir.bg/"; putStr (BS.unpack page)  ?
16:49:32 <Cale> or what?
16:49:43 <loadedanvils> ok hold on
16:49:51 <Cale> Yeah, this is like the worst choice of website to be using with Char8
16:50:27 <loadedanvils> really?
16:50:30 <loadedanvils> I just found this on google
16:50:33 <Cale> It *will* result in gibberish if you put in much of anything going beyond 7-bit ASCII.
16:50:36 <loadedanvils> I copy pasted it into my code
16:51:05 <loadedanvils> in reality I want to just parse JSON data
16:51:14 <Cale> That page has a bunch of UTF-8 encoded Cyrillic on it.
16:51:20 <Peaker> loadedanvils: do you know what unicode code points are? And what UTF8/UTF16 and ASCII are?
16:51:46 <loadedanvils> Peaker: I think so. The thing is, I actually didn't look at the site in my browser
16:52:10 <loadedanvils> perhaps that is the problem
16:52:25 <Cale> (It's Bulgarian)
16:52:34 <loadedanvils> I'm an idiot
16:53:15 <loadedanvils> I need to clear my mind for a bit
16:53:34 <Cale> loadedanvils: But that's okay, Data.ByteString is appropriate for getting the raw data coming off the line
16:53:41 <Peaker> loadedanvils: A Haskell "String" is [Char]. Char ~ code point.   ByteString ~ sequence of bytes (not unicode).  A website is likely UTF8 bytes encoding code points.   To convert ByteString->String, you have to choose an encoding
16:54:10 <newsham> "you can only access String from String.EXE from inside of another .EXE"
16:54:18 <Peaker> loadedanvils: Data.ByteString.Char8 (and the lazy counterpart) is using a silly "encoding" of just assuming 256 values of a byte map to the first 256 code points of unicode.
16:54:42 <Cale> loadedanvils: What I recommended to you before is that you convert from ByteString to Text first, because there are convenient library functions for that, and then Text -> String if you really need to.
16:55:07 <loadedanvils> Cale: is that fast? I'm probably only going to work with JSON things
16:55:08 <Cale> You can get libraries off of Hackage which will go directly to String as well.
16:55:23 <Peaker> loadedanvils: There's Data.ByteString.UTF8.toString :: ByteString -> String   which is a sensible default, I think
16:55:41 <Cale> Well, if you're just parsing JSON, I think Aeson will parse directly from ByteString.
16:55:55 <Cale> As will many others, probably.
16:55:56 <loadedanvils> Cale: really? I should have checked first
16:55:59 <loadedanvils> hmm
16:56:22 <Cale> Yeah, aeson's decode :: FromJSON a => ByteString -> Maybe a
16:59:34 <Cale> (see that library here: http://hackage.haskell.org/package/aeson-0.6.2.1/docs/Data-Aeson.html )
17:00:08 <johnw> i didn't realize JSON was a binary format, or does the standard require UTF8 or something?
17:00:28 <geekosaur> I believe it requires utf8, yes
17:09:13 <briennetheblue> :t Data.Map.Lazy.empty :: Data.Map.Strict.Map a b
17:09:14 <lambdabot> M.Map a b
17:09:18 <briennetheblue> why does this work??
17:10:11 <geekosaur> briennetheblue, as long as you're just asking for a type, it has no problem with uninstantiated type variables
17:10:20 <geekosaur> you can't ask for a *value* with that type though
17:10:41 <user1234> @pl \l ->chr $ sum (97 : elemIndices l key)
17:10:44 <lambdabot> id chr . sum . (97 :) . flip elemIndices key
17:10:45 <lambdabot> optimization suspended, use @pl-resume to continue.
17:10:49 <prophile> geekosaur: I think he's referring to the lazy/strict thing
17:11:07 <geekosaur> oh
17:11:09 <briennetheblue> geekosaur, sorry i'm confused, aren't those different types?
17:11:16 <geekosaur> hm
17:11:22 <geekosaur> I have no idea actually
17:11:37 <geekosaur> however I suspect that empty is polymorphic
17:12:12 <elifrey> what needs to happen for hackage to support tls?
17:12:21 <geekosaur> just because it's exported from Data.Map.Lazy doesn't mean it's not polymorphic
17:13:47 * geekosaur now curious, pokes at Data.Map
17:13:55 <briennetheblue> :t Data.Map.Lazy.fromListWith :: Ord a => (b -> b -> b) -> [(a, b)] -> Data.Map.Strict.Map a b
17:13:56 <lambdabot> Ord a => (b -> b -> b) -> [(a, b)] -> M.Map a b
17:14:17 <geekosaur> ah, yes. "The Map type itself is shared between the lazy and strict modules, meaning that the same Map value can be passed to functions in both modules (although that is rarely needed)."
17:14:51 <briennetheblue> oh ok
17:16:15 <briennetheblue> my mind was just boggled from reading code where someone "import Data.Map.Strict (Map)" "import qualified Data.Map as Map"
17:16:40 <geekosaur> I would call that bad (confusing) style
17:16:43 <briennetheblue> i thought that couldn't possibly compile
17:17:48 <briennetheblue> so in that case, using the Data.Map functions, it isn't value-strict?
17:18:34 <briennetheblue> it gave me a real :psyduck: moment :P
17:19:28 <geekosaur> Data.Map is mostly lazy values, yes, although it does export a few things from Data.Map.Strict as well
17:19:47 <latermuse> data.map is a boss
17:23:00 <briennetheblue> i'm really confused how Data.Map.Lazy and Data.Map.Strict can share the same type of Map but i suppose this is a case of read the source and try to understand it...
17:23:27 <startling> briennetheblue, I think D.M.Strict just seqs things
17:23:30 <geekosaur> easy: the strict vs. lazy distinction is in the functions, not in the map data itself
17:23:38 <startling> yeah.
17:24:17 <Cale> briennetheblue: They both export the same Map datatype, it's just that all the higher order functions are written to be more strict in the Strict module.
17:24:36 <briennetheblue> oh hm
17:24:45 <Cale> (which means they use seq or bang patterns or $! or whatever)
17:25:01 <briennetheblue> that makes sense, thanks
17:25:35 <geekosaur> there are lots of ways to force evaluation to WHNF; while it's often convenient to encode that into the data type, it's not necessary to do so
17:46:04 <loadedanvils> any good tutorials / tips for making a data type for JSON parsing?
17:46:20 <loadedanvils> I know what the json object looks like, how do I define the data type?
17:47:19 <dwcook> loadedanvils, is this for an exercise or do you just need to read JSON? Because there's already a package for that.
17:47:22 <dwcook> @hoogle json
17:47:22 <lambdabot> package json
17:47:23 <lambdabot> package json-b
17:47:23 <lambdabot> package json-builder
17:47:54 <WraithM> @hoogle aeson
17:47:54 <lambdabot> package aeson
17:47:54 <lambdabot> package aeson-bson
17:47:54 <lambdabot> package aeson-lens
17:47:55 <loadedanvils> dwcook: it's not an exercise, I'm trying to learn haskell by porting one of my older scripts
17:48:27 <dwcook> loadedanvils, sorry, I'm not sure how that's not a contradiction.
17:48:29 <loadedanvils> JSON data types is what I'm interested in
17:48:44 <startling> loadedanvils, aeson is probably what you want.
17:48:48 <loadedanvils> dwcook: I'm not following any book or tutorial
17:48:57 <dwcook> loadedanvils, I wasn't suggesting that you were.
17:49:19 <loadedanvils> startling: I have the aeson package, I just want to know how to create the data type (I seem confused by the examples)
17:50:15 <startling> loadedanvils: which data type?
17:50:29 <startling> usually you write a type for your thing and a FromJSON instance for it.
17:50:58 <loadedanvils> startling: I want to do that (write a type), I'm just not sure how to do it
17:51:02 <WraithM> You need to make your data an instance of FromJSON and ToJSON for decoding and encoding (respecitively)
17:51:54 <loadedanvils> the problem is, I don't know how the data type definition corresponds to the json object
17:52:06 <startling> loadedanvils: Don't worry about that yet.
17:52:07 <loadedanvils> I'm trying to figure it out but it's not going too well
17:52:18 <startling> loadedanvils: do you understand "data" declarations?
17:52:35 <loadedanvils> startling: sort of
17:53:08 <loadedanvils> startling: I know how they look and work
17:53:08 <startling> loadedanvils: could you perhaps paste some of your data to lpaste.org?
17:53:09 <zq> okay, done
17:54:18 <startling> sorry, lpaste.net
17:57:04 <augur> this whole role business seems like it shouldnt be necessary at al
17:59:20 <Yonkie_> hi
18:01:26 <zq> is it possible to view an execution trace in ghc?
18:17:42 <mm_freak> zq: GHCi has something like that, but i've never used it
18:17:58 <mm_freak> type :?
18:18:15 <mm_freak> see "commands for debugging"
18:19:15 <WraithM> Has anybody tried using jmacro and blaze-html together? Does that even make sense?
18:19:44 <levi> jmacro uses blaze-html, so yeah, it makes plenty of sense.
18:19:49 <WraithM> Oh
18:19:52 <WraithM> Cool
18:20:41 <WraithM> I guess I'm a little confused about the types then.
18:20:57 <Luke> chrisdone: you around?
18:21:34 <mm_freak> levi: i can't confirm that jmacro uses blaze-html
18:22:00 <mm_freak> if anything, it would use blaze-builder, but it doesn't even use that one…  i guess it just uses bytestring's builtin Builder functionality
18:22:29 <levi> Hmm... maybe it's JMacroRPC that uses blaze-html
18:22:42 <levi> In any case, I have used them together.
18:23:02 <mm_freak> yeah, should be fairly straightforward
18:23:05 <WraithM> Do you have any good examples?
18:23:06 <VonDraco> How would I go about doing something like this "eval (Mult (Number 3) (Plus (Number 8) (Number 9) ))" with the code here http://lpaste.net/4425407505773887488 ?
18:23:17 <VonDraco> I know that it involves some sort of recurssion, but I have no clue where to begin.
18:23:28 <mm_freak> WraithM: ByteString is a ToHtml, so in the worst case (and after making sure your encodings match!) you can simply use toHtml
18:23:37 <WraithM> :D
18:23:44 <WraithM> mm_freak: That was my thought
18:23:57 <WraithM> I just wanted to see if that was totally nuts before I went off on an adventure
18:24:17 <levi> It looks like I have a toHtml . show . renderJs function.
18:24:26 <mm_freak> VonDraco: first step, rename Nothing to something else =)
18:24:42 <Iceland_jack> VonDraco: You're passing (Plus … …) to Mult
18:24:59 <Iceland_jack> (Plus … …) has type ArithExpr, Mult only accepts Number
18:25:01 <mm_freak> VonDraco: now you have a 'Plus x y', where x and y are expressions themselves
18:25:22 <mm_freak> VonDraco: you can write an 'eval' clause for that:  eval (Plus x y) = …?
18:25:34 <mm_freak> VonDraco: hint:  you want the sum of the result of evaluating x and y
18:25:50 <VonDraco> jfldksaf I completely forgot that was there, mm_freak. I was going to try doing something like this successor of natural numbers beginning with Zero that I saw.
18:25:57 <mm_freak> oh, wait
18:26:12 <mm_freak> x and y aren't actually expressions…  why not?
18:26:29 <mm_freak> so yeah, what Iceland_jack said =)
18:26:38 <VonDraco> hmm
18:27:24 <Iceland_jack> VonDraco: A quick fix would be to write something like:
18:27:24 <Iceland_jack>     data Expr = Num Integer | Mult Expr Expr | Plus Expr Expr
18:27:39 <Iceland_jack> and then ‘eval’ follows quite naturally
18:28:11 <VonDraco> holy shit that actually makes A LOT of sense
18:28:28 <VonDraco> thanks!
18:28:34 <Iceland_jack> You're welcome VonDraco
18:28:47 <Iceland_jack> I'm not used to people saying that I make sense :)
18:35:27 * hackagebot lens-family-core 1.0.0 - Haskell 98 Lens Families  http://hackage.haskell.org/package/lens-family-core-1.0.0 (RussellOConnor)
18:35:29 * hackagebot lens-family 1.0.0 - Lens Families  http://hackage.haskell.org/package/lens-family-1.0.0 (RussellOConnor)
18:35:46 <edwardk> roconnor hasn't given up yet i see ;)
18:35:54 <roconnor> :)
18:36:53 <bennofs> How can I communicate between two processes in haskell? (I want to wait until a process spawned by forkProcess has reached a certain state)
18:37:35 <edwardk> if you replaced Phantom with the use of Contravariant we'd be almost perfectly compatible
18:37:59 <roconnor> edwardk: if Contravarient ends up in the Prelude or Platform, I will change.
18:38:09 * edwardk shrugs.
18:40:23 <roconnor> Hmm I didn't realize contravarient was in its own package.
18:40:34 <roconnor> I guess it is something I will have to reconsider.
18:40:41 * monochrom violently refuses to say "strict vs lazy"
18:40:52 <zq> augustss: ping
18:41:08 <dwcook> This reminds me of those scifi scenarios where rogue AIs build out of control and take over the world. Although in this case, the rogue AI is edwardk, and his utility function instructs him to create Haskell packages.
18:42:08 <monochrom> edwardk is Three-Law-Safe :)
18:42:56 <edwardk> =)
18:43:54 <edwardk> if you ever decide to add isomorphisms/prisms, the profunctors package is also independent of lens
18:44:20 <mm_freak> bennofs: the hard way (through unix sockets) or the easy way (through distributed-process)
18:44:40 <roconnor> what are the two functional reference laws expressed using profunctors?
18:44:46 <pdxleif> Is there a version of this Network.listenOn function that lets you specify the local interface you want to bind to? http://hackage.haskell.org/package/network-2.2.1.7/docs/Network.html#v:listenOn
18:44:53 <mm_freak> bennofs: http://chimera.labs.oreilly.com/books/1230000000929/ch14.html
18:44:59 <pdxleif> I could just copy 'n paste that impl and replace the address, I guess
18:45:49 <bennofs> roconnor: http://ekmett.github.io/lens/Control-Lens-Type.html#t:Optic
18:46:00 <bennofs>  l pure ≡ pure
18:46:02 <bennofs>  l (Procompose f g) = Procompose (l f) (l g)
18:46:12 <edwardk> l (Procompose f g) = Procompose (l f) (l g)    -- is pretty much spot on
18:46:20 <edwardk> the other one is a bit of a lie i think
18:46:30 <roconnor> edwardk: okay; that's sort of what I figured.
18:46:38 <edwardk> also i don't remember if those laws were from pure profunctor lenses
18:46:40 <roconnor> I guess I need to learn to be comfortable with Procompose.
18:46:40 <mm_freak> pdxleif: the high level interface can't do that, but you can use Network.Socket
18:46:52 <mm_freak> pdxleif: however, you will still need to retrieve the interface's address to bind to
18:47:09 <edwardk> roconnor: anyways that has the potential to eventually unify all of the laws for all of the lens-likes
18:47:21 <roconnor> edwardk: what do you mean potential?
18:47:24 <edwardk> as they all appear to be specializations of the kind of optic laws
18:47:36 <pdxleif> inet_addr "127.0.0.1" seems to work
18:47:42 <edwardk> well, the 'pure' one doesn't read quite right
18:48:12 <pdxleif> Just wanna bind to localhost-only instead of iNADDR_ANY
18:48:25 <edwardk> i want to spend more time firming those up
18:49:18 <mm_freak> pdxleif: localhost may be a different address, but it should work as an approximation
18:50:13 <edwardk> i can probably phrase them a bit nicer in terms of arrows for id and arrow composition, but thats less satisfying
18:50:32 <edwardk> at least in the pure profunctor setting
18:50:36 <monochrom> I would nail it to 127.0.0.1
18:50:57 <mm_freak> pdxleif: note that binding to localhost does not guarantee that you will only receive local connections…  you have to actually check the address of incoming connections anyway, if you want to do it properly
18:51:11 <monochrom> unless you say, "what about IPv6?", then I don't know.
18:51:21 <mm_freak> it's easy enough to mess up your iptables to route connections to lo from other interfaces
18:52:13 <pdxleif> mm_freak: What, like so? https://github.com/idris-lang/Idris-dev/commit/229975d61c7e5728ba5ce41e62c471596bcb92b4
18:52:33 <pdxleif> checks for host = "127.0.0.1" or "localhost"
18:52:41 <mm_freak> pdxleif: pretty much
18:52:47 <pdxleif> problem was, on my box it came up as "localhost.localdomain"
18:53:01 <mm_freak> pdxleif: under the assumption that 127.0.0.1 is localhost
18:53:05 <Clint> fix /etc/hosts
18:53:14 <mm_freak> pdxleif: the proper solution for local-only connections is not to use a network socket =)
18:53:16 <pdxleif> That's common on default installs
18:53:22 <mm_freak> pdxleif: you should probably use unix sockets
18:53:24 <monochrom> after a while, I just find that you shouldn't be too paranoid about this
18:53:30 <pdxleif> Do those work on mac / windows?
18:53:47 <mm_freak> they work nearly everywhere
18:53:59 <mm_freak> my main point is:  don't hardcode the bind address
18:54:08 <mm_freak> also provide a whitelist feature
18:54:22 <mm_freak> finally:  for local-only connections unix sockets are easy to deal with and faster
18:54:52 <pdxleif> I'll give it a shot - thanks
18:56:17 <carter> mm_freak: unix sockets wont work for wondows
18:56:46 <mm_freak> for wondows there are named pipes, but i don't know how to use them in haskell
18:57:05 <mm_freak> (named popes?)
18:57:53 <Iceland_jack> as opposed to anonymous popes?
18:58:02 <Clint> popesix ipc
18:58:04 <monochrom> named burettes and labelled flasks
18:58:12 <pdxleif> > takeWhile (/= '.') "localhost.localdomain"
18:58:13 <lambdabot>   "localhost"
18:59:10 <Iceland_jack> > splitOn "." "localhost.localdomain"
18:59:11 <lambdabot>   ["localhost","localdomain"]
19:01:08 <mm_freak> they're like named burritos, if you have trouble understanding them
19:01:42 <mm_freak> or warm fuzzy thongs
19:03:17 <fl00r> exit
19:03:21 <fl00r> oops
19:05:31 <zq> ugh
19:08:34 <jcullen> hey guys.  I've got a question relating to parsec that I'm having trouble figuring out.  does anyone have a sec?
19:09:29 <khyperia> What's the question, jcullen?
19:09:58 <jcullen> so I'm trying to parse a list of chord names out of a string
19:10:05 <jcullen> and I've got that parser working fine
19:10:23 <jcullen> but I realize now that I also want to output the consumed string that successfully parsed as well
19:10:32 <jcullen> so I can label the chords
19:10:40 <jcullen> I've been looking through the docs
19:10:55 <khyperia> what do you mean by "output the consumed string"?
19:11:08 <jcullen> so I've got some chord data type
19:11:18 <jcullen> and right now the chord parser has type Parser Chord
19:11:23 <jcullen> but I want it to be Parser (String, Chord)
19:11:35 <jcullen> where string is the sequence of tokens that resulted in a successfull "Chord" parse
19:11:39 <jcullen> does that make sense?
19:11:52 <khyperia> Ah, so you're only parsing a subsection of it?
19:12:20 <jcullen> yeah potentially
19:12:44 <jcullen> If the string to be parsed is something like Amaj Bmin C
19:13:05 <jcullen> I'd like to get out ("Amaj", <Amaj Chord>), ("Bmin", <Bmin chord>), .. etc
19:13:06 <jcullen> eventually
19:13:30 <khyperia> Ahhh, so returning the token, not the entire string.
19:13:36 <jcullen> yeah, right
19:15:58 <jcullen> I tried this http://lpaste.net/94980
19:16:06 <jcullen> but that obviously doenst work in retrospect
19:16:12 <jcullen> because it will just parse the whole string
19:16:34 <jcullen> I'm wondering if there is some kind of general way to do it.. without having to stick a bunch of bookkeeping in the chord parser itself
19:16:37 <jcullen> to count characters
19:16:40 <jcullen> or something
19:17:29 <khyperia> Well... could I see your actual chord parsing functions? I have an idea
19:17:43 <jcullen> sure
19:18:15 <khyperia> since when you parse it, I assume you have do someString <- parseThing; let chord = convertToChord someString; return chord;
19:18:18 <khyperia> or similar
19:18:29 <khyperia> and you might be able to just say (someString, chord) instead of chord
19:19:04 <jcullen> https://github.com/phenguin/hasmt/blob/master/ChordParser.hs
19:19:05 <jcullen> its this file
19:19:26 <jcullen> line 57
19:20:00 <khyperia> hmmm
19:20:59 <jcullen> yeah there isn't really a spot where I get direct access to the string in there either
19:21:19 <jcullen> since there are alot of sub-parsers to construct the actual Chord instance
19:21:50 <khyperia> yeah...
19:22:15 <khyperia> and I assume there's a bunch of information you throw away when you parse it
19:22:28 <khyperia> so you can't just make a Show instance
19:22:37 <jcullen> yeah right
19:23:03 <jcullen> a "Chord" is just a set of intervals.. and its not 1-1
19:23:07 <jcullen> so it'd be ambiguous
19:23:20 <jcullen> which is the reason I'm trying to preserve the original string psased in
19:26:24 <jcullen> I guess I can think of some pretty seemingly inefficient ways to do it
19:26:29 <jcullen> like stepping one character at a time
19:26:36 <jcullen> and trying to parse a chord at each step
19:26:52 <jcullen> but then you might not get the longest match..
19:34:22 <TheCrownedFox> I seem to be having trouble with cabal. ghc-pkg lists it as being on my computer, however I cannot run any cabal commands. Is there another way to verify I have it installed?
19:35:05 <geekosaur> TheCrownedFox, ghc-pkg does not show the cabal executable
19:35:20 <geekosaur> it shows the cabal *library*, which is more fundamental
19:35:43 <geekosaur> but the cabal *command* (package: cabal-install) does not have its own library, so ghc-pkg doesn't know about it
19:38:26 <TheCrownedFox> geekosaur: that makes sense. so I really don't have cabal.
19:39:13 <jcullen> khyperia: Think I've got a solution if you're curious.  thanks for looking into it
19:39:17 <geekosaur> anyway if you cannot find a command named "cabal" then you probably need to install the cabal-install bootstrap http://www.haskell.org/cabal/download.html
19:39:25 <natux_> Anyone know why I can't install language-javascript? I'm getting a configuration compile error ExitFailure 1
19:39:28 <khyperia> alright, awesome
19:39:32 <khyperia> what is it?
19:39:40 <jcullen> one sec
19:39:43 <geekosaur> unless you installed ghc from your distribution's packages in which case look for a cabal-install package from the same place
19:40:06 <geekosaur> natux_, ExitFailure 1 is pretty much the least informative part of the error
19:40:25 <geekosaur> so no, nobody can know why it failed
19:40:50 <geekosaur> use cabal -v install language-javascript and pastebin the full output somewhere
19:40:52 <geekosaur> @lpaste
19:40:52 <lambdabot> Haskell pastebin: http://lpaste.net/
19:41:00 <TheCrownedFox> geekosaur, I shall try just that, thanks!
19:41:10 <natux_> Sorry... I figured it out.
19:43:28 <Xeno> I just want to convert a couple of numbers to a string.  Seems like my two tutorials are imperious for information on this.  Is it just not done in Haskell?
19:44:10 <Rarrikins> > show 1
19:44:11 <lambdabot>   "1"
19:44:47 <Xeno> So, in C if I have i, j I would do "%d, %f", i, j...
19:45:04 <Rarrikins> > show (1, pi)
19:45:05 <lambdabot>   "(1,3.141592653589793)"
19:45:15 <Xeno> Ok.  Thank you.
19:45:23 <Rarrikins> > show 1 ++ ", " ++ show pi
19:45:25 <lambdabot>   "1, 3.141592653589793"
19:45:34 <Rarrikins> You're welcome.
19:45:54 <geekosaur> there is a Text.Printf.printf, but in general we don't like to use it because varargs type stuff is remarkably icky in Haskell
19:47:04 <geekosaur> also it is necessarily a partial function (fails if you have a value type that doesn't work with the corresponding format sequence, and partial functions are kinda bad in general
19:48:07 <Xeno> Okay, well, I'm trying to actually learn Haskell, rather than just learn hacks, so it sounds like the show example is the way to go.
19:48:39 <startling> printf is nice to use when you need it.
19:49:17 <Xeno> This is helpful guys.  Shakes me loose form my doldrums.  Thank you again.
19:50:23 <startling> @hackage printf-mauke -- this is nice, too
19:50:23 <lambdabot> http://hackage.haskell.org/package/printf-mauke -- this is nice, too
19:52:41 <TheCrownedFox> Does anyone happen to know if cabal is supported on ARM? I don't seem to be able to compile it.
19:52:54 <jcullen> khyperia: https://github.com/phenguin/hasmt/blob/master/ChordParser.hs
19:52:57 <carter> TheCrownedFox: do you get an error message?
19:53:08 <jcullen> khyperia: check out withParsedString method on line 58
19:53:30 <startling> TheCrownedFox: it should be, but GHC on ARM is in a sort of sorry state
19:53:31 <khyperia> Ah, neat!
19:53:57 <jcullen> thanks for your chatting about it. helped me think about the problem more clearly :)
19:54:16 <startling> TheCrownedFox: you definitely should paste your error message, though
19:54:20 <TheCrownedFox> carter, yes I did. "wrong initializer for intrinsic global variable" and on the next line "[0 x i8*] undef
19:54:31 <carter> WHICH arm platform?
19:54:32 <carter> and which ghc?
19:55:10 <carter> GHC head is much nicer for ARM
19:55:28 <TheCrownedFox> carter, it's armv7hf, ghc version 7.6.3. what is GHC head?
19:55:40 <carter> the stuff in the git repo master
19:55:51 <carter> master branch
19:55:57 <carter> that will be ghc 7.8 in a few weeks
19:56:19 <TheCrownedFox> oh, duh. so I should install from source?
19:56:36 <carter> sure
19:56:45 <carter> theres docs on the ghc wiki
19:56:55 <carter> ghc.haskell.org/trac/ghc/wiki/Building
19:57:03 <carter> TheCrownedFox: ask leroux  for help if you get stuck :)
19:57:16 <TheCrownedFox> I certainly will, thank you!
19:57:47 <carter> TheCrownedFox: do you have ghc working
19:57:48 <carter> or not?
19:59:58 <TheCrownedFox> carter, I do have a working version of ghc from the package repositories from my distro.
20:00:03 <carter> ok
20:00:12 <carter> so you dont' have to deal with cross compilation!
20:00:20 <carter> woot
20:00:23 <carter> you'll like life more
20:00:31 <carter> the build directions should be pretty easy to follow
20:00:40 <TheCrownedFox> I hope so, there's a few bugs with ghc on ARM from what I understand.
20:01:09 <carter> git clone <GHC repo> ; ./sync-all pull ; perl boot ; make
20:01:15 <carter> ooops
20:01:20 <carter> git clone <GHC repo> ; ./sync-all pull ; perl boot ; configure  ; make
20:01:23 <startling> Does interpretation work on ARM yet?
20:01:35 <carter> startling: does arm have a system linker?
20:01:42 <carter> i'm not following that stuff
20:01:50 <carter> fox can tell us :)
20:01:52 <carter> ghci may not work
20:02:02 <carter> but ghc / projects with no TH should be fine
20:02:11 <carter> umm
20:02:22 <carter> Rwbarton wouldkno
20:02:26 <startling> Yeah, that's what I understood was the state of things a few months ago.
20:02:34 <startling> no TH/ghci is kind of disappointing.
20:03:09 <startling> It seems like something that shouldn't be platform-dependent anyhow.
20:03:14 <TheCrownedFox> the biggest issue I'be run into is ghci freaking out whenever I use the data keyword
20:03:23 <carter> startling: nope
20:03:24 <carter> linking
20:03:25 <carter> is a think
20:03:28 <carter> dylinking
20:03:31 <carter> you're welcome to patch it
20:03:32 <carter> :)
20:03:37 <carter> *thing
20:04:11 <TheCrownedFox> I'd love to help, but I'm fairly new to haskell. I only started really getting into it about 10 days ago.
20:04:12 <startling> carter: I guess so.
20:06:43 <carter> well, you can report bugs
20:06:48 <carter> and find out if they're new ones or not
20:06:50 <carter> and they try stuff
20:06:51 <carter> :)
20:06:53 <carter> *then
20:06:58 <adnap> Do you think it's a bad habit to make one-character type synonyms for use with function type signatures that are not exported when type signatures are just getting too long?
20:07:12 <carter> adnap: yes, terribad
20:07:21 <carter> make type synonym combinators
20:07:29 <adnap> wat
20:07:29 <TheCrownedFox> I have looked into it actually, it has been a reported bug for several months now
20:07:35 <carter> ok
20:07:36 <carter> well
20:07:45 <startling> :t _1 :: Simple Lens (a, b) a
20:07:45 <lambdabot> Functor f => (a -> f a) -> (a, b) -> f (a, b)
20:07:47 <carter> you could dig into it and try stuff and see what happens
20:07:59 <carter> type OP a b =  a -> b
20:08:03 <carter> would be a "combinator"
20:08:05 <startling> :i Simple
20:08:06 <startling> type Simple f s a = f s s a a 	-- Defined in `Control.Lens.Type'
20:08:07 <carter> you cant partially apply it
20:08:23 <carter> adnap: see, lens does it!
20:08:39 <carter> dont do the magic name that no one else knows
20:08:44 <carter> i'v ehad to deal with libs that do that
20:08:45 <carter> i hate them
20:08:47 <carter> :)
20:09:01 <startling> Don't be afraid to make your type signatures cover several lines !
20:09:10 <carter> yes
20:09:11 <carter> that too
20:09:13 <edwardk> we do it in lens for 'chunking' purposes, but lens is downright massive. -- and people give us crap about it regularly
20:09:19 <adnap> Alright, but I don't like copy-pasting them
20:09:20 <startling> Sometimes you need it, especially for multiple constraints.
20:09:25 <adnap> They're too long to type quickly sometimes
20:09:36 <startling> adnap: do you use emacs' thing?
20:09:50 <edwardk> i recommend just learning to type faster =)
20:09:52 <adnap> I guess I will just use a find/replace on my one-character type synonyms when I'm done editing
20:09:59 <edwardk> or that
20:10:00 <startling> there's a shortcut that does :t thisDefinition and puts it above it.
20:10:19 <startling> C-c C-a, maybe?
20:10:26 <startling> Your editor may have an equivalent.
20:10:26 <adnap> I use Vim
20:10:43 <adnap> I don't know how to use Emacs. I tried to learn it once and it made my hands hurt
20:11:04 <startling> emacs pinkie etc
20:11:14 <carter> edwardk: whats the allusion to ryan ingram insight re lens and cps?
20:11:29 <amalloy> yeah, if you actually use the control key (rather than swapping it with caps lock), emacs is bad for your pinky
20:11:34 <startling> But yeah, I use vim atm; it's nice but the ghci integration is lacking.
20:11:47 <edwardk> ?
20:12:17 <startling> Maybe I haven't explored it enough?
20:12:20 <edwardk> startling: i just use vim. i've yet to adopt anything fancier than hasktags
20:12:27 <edwardk> the ? was re carter's question
20:12:31 <startling> Oh.
20:12:51 <carter> edwardk: http://www.haskell.org/pipermail/haskell-cafe/2013-October/111154.html
20:12:55 <adnap> Well, I asked about the one-character thing because my brain likes it, but I imagine that if anyone ever took a look at the code, they would be confused and have to constantly look at the definitions of the type synonyms.
20:13:02 <carter> yes
20:13:19 <edwardk> i avoid emacs lik the plague as everyone i know who uses it (and doesn't remap ctrl to capslock, etc, yes, yes, sure some of you may save yourselves) has developed carpal tunnel, RSI, etc.
20:14:13 <adnap> I don't use qwerty touch-type for that reason either. Well, sometimes I use it for 30 minutes and go back to my habit style, but I am also practicing Dvorak so I can touch-type without hurting so much
20:14:25 <startling> I switch every couple of months when I get too frustrated with the current one.
20:14:45 <adnap> I move my hands a bit with my "habit stype", and I feel no finger strain
20:14:50 <adnap> *style
20:15:46 <edwardk> ah, yeah we can adapt his version of alongside
20:16:03 <carter> edwardk: oh, i dont know what that means (yet)
20:16:09 <edwardk> :t (alongside)
20:16:10 <lambdabot> Functor f => ALens s t a b -> ALens s' t' a' b' -> ((a, a') -> f (b, b')) -> (s, s') -> f (t, t')
20:16:28 <edwardk> 'run two lenses at the same time into their respective sides of a pair'
20:16:38 <carter> ahh
20:16:45 <carter> his is different?
20:17:18 <adnap> Is the result a lens?
20:17:28 <adnap> It looks like it
20:23:38 <startling> Yes.
20:24:00 <startling> edwardk, my "tee" would be so useful with alongside.
20:24:33 <startling> well, a variation of it.
20:25:45 <edwardk> his allows it to work with a Getter as well
20:26:28 <edwardk> which is pretty nice
20:26:34 <edwardk> so i'm appropriating it
20:27:44 <carter> oh?
20:27:50 <carter> which snippet is his?
20:28:04 <carter> i'm still learning to read lens' / trying to
20:28:12 <edwardk> http://hackage.haskell.org/package/lens-family-core-1.0.0/docs/src/Lens-Family-Stock.html see the alongside definition
20:29:23 <TheCrownedFox> So, I'm trying to compile ghc, I tried to run ./configure and I got an error saying Happy version 1.19 or greater is required. What is this? Unfortunately google wasn't too helpful.
20:29:44 <johnw> happy is the Haskell version of "yacc" basically
20:29:47 <johnw> what OS are you on?
20:29:59 <TheCrownedFox> I'm running the ARM version of arch linux
20:30:13 <johnw> you'll need to "cabal install happy" to get a recent enough version
20:30:25 <johnw> and then make sure ~/.cabal/bin is earlier on your PATH than the system happy
20:30:31 <carter> TheCrownedFox: cabal install happy
20:30:38 <carter> johnw: he's also on ARM
20:30:39 <buzzfazz> does anyone here have experience with imagemagick's bindings for haskell?
20:30:47 <TheCrownedFox> hmm. So I'm trying to compile ghc from source so that I can use cabal, because I don't have it by default.
20:30:53 <johnw> yeah, I know nothing about Linux/Haskell on ARM
20:30:57 <carter> TheCrownedFox: noooo
20:31:02 <carter> TheCrownedFox: thats not why
20:31:13 <carter> TheCrownedFox: you can dl the cabal tarball and boostrap it
20:31:36 <TheCrownedFox> the bootstrap failed because I didn't have an up to date version of ghc I thought.
20:31:44 <carter> nope
20:31:46 <carter> that sounds wrong
20:31:49 <carter> TheCrownedFox: you didn't share error emssages
20:31:53 <carter> try again
20:32:10 <buzzfazz> i'm trying to use the haskell imagemagick bindings to output an animated gif; does anybody have experience with this?
20:32:24 <heath> 'foo -- what does the leading paren me?
20:32:28 <heath> s/me/mean
20:32:50 <TheCrownedFox> carter, I did post error messages, however it certainly doesn't hurt to try bootstrapping again :)
20:32:56 <carter> ummm
20:33:00 <carter> ok
20:33:04 <lpaste> buzzfazz pasted “haskell imagemagick animated giff” at http://lpaste.net/8654361665535475712
20:33:17 * heath rephrases
20:33:20 <carter> probably note :)
20:33:27 <carter> not
20:33:28 <heath> what does a leading paren for a variable name represent?
20:33:57 <procrasturbate> hey
20:34:04 <procrasturbate> i'm trying to learn prolog got any good material
20:34:14 <arkeet> heath: ??
20:34:14 <startling> heath, example?
20:34:35 <heath> 'foo :: a -> a -> a
20:34:45 <TheCrownedFox> carter: wrong initializer for intrinsic global variable \n [0 x i8*] undef. Ultimately, it can't find a file in in /tmp
20:34:46 <lpaste> buzzfazz revised “haskell imagemagick animated giff”: “haskell imagemagick animated gif” at http://lpaste.net/8654361665535475712
20:34:54 <buzzfazz> sorry! the first one had a typeo
20:34:58 <startling> heath: that's a "leading paren"?
20:34:58 <carter> TheCrownedFox: what were you doing that made it say that
20:35:01 <carter> ohhhhhhh
20:35:08 <carter> TheCrownedFox: you have too new an LLVM
20:35:18 <carter> TheCrownedFox: you need llvm 3.2 for ghc 7.6 to be happy
20:35:27 <TheCrownedFox> I downloaded the cabal source, then ./bootstrap .
20:35:36 <heath> hah, i mean, apostrophe, apologies :)
20:35:45 <buzzfazz> anybody?
20:35:45 <carter> TheCrownedFox: right now your ghc 7.6 is trying to use llvm 3.3
20:35:48 <carter> buzzfazz: no clue
20:35:54 <carter> buzzfazz: try stuff and see what happens
20:36:17 <buzzfazz> carter: that's what i've been doing for several hours now; nothing i've changed has made the output image contain two layers, much less animate
20:36:31 <carter> buzzfazz: well, take a break and look again tomorrow?
20:36:43 <carter> buzzfazz: or play with the diagrams lib :)
20:36:47 <buzzfazz> carter: yep. but i like to ask on irc before heading in for the night
20:36:51 <buzzfazz> i'll look into diagrams..
20:36:56 <carter> its neat stuff
20:36:59 <carter> really really neat stuff
20:37:15 <TheCrownedFox> So then, ultimately I won't be able to utilize cabal until my llvm version is supported? or I downgrade somehow?
20:37:25 <carter> TheCrownedFox: dl and build llvm 3.2
20:37:37 <carter> and repoint your opt and llc fields in your Settings file
20:37:38 <carter> to that
20:37:55 <heath> 'foo isn't allowed
20:38:00 <buzzfazz> carter: thx.. diagrams is nice looking
20:38:03 <arkeet> heath: indeed
20:38:03 <heath> not sure where that was coming from
20:38:13 <TheCrownedFox> how do I do the repointing? sorry.
20:38:22 <heath> someone asked, i guess they had seen a typo somewhere
20:38:50 <startling> it's sometimes used for TH things iirc
20:39:05 <arkeet> but not with variables
20:39:17 <startling> that's fair.
20:39:18 <carter> TheCrownedFox: you'll see a path on the first line when you type "ghc-pkg list"
20:39:30 <carter> go one directory up and there should be a file called "settings"
20:39:45 <carter> with fields that  have "opt" and "llc" there
20:39:59 <carter> when you build llvm 3.2, adjust the settings files to point to those
20:40:10 <carter> uuuu
20:40:12 <carter> noooo
20:40:15 <carter> use llvm 3.1
20:40:18 <carter> or 3.0
20:40:29 <carter> theres issues with using llvm 3.2 to build a ghc boostrap
20:40:33 <carter> if you wanna do that later
20:40:57 <TheCrownedFox> gotcha, no worries
20:42:07 --- mode: ChanServ set +o monochrom
20:42:19 --- mode: monochrom set -b *!*@84.22.61.190
20:42:29 --- mode: monochrom set -o monochrom
20:42:33 <carter> what happened?
20:42:52 <monochrom> expiring a ban
20:43:16 <carter> ah
20:43:19 <carter> thats nice of you
20:45:06 <Fuuzetsu> monochrom realised his mistakes
20:47:52 <carter> or forgetting them
20:57:45 <Xeno> Hoogle cannot tell me what "instance declaration" is.
20:57:55 <Xeno> ghci wants one.
20:59:09 <zomg> Xeno: huh?
21:00:13 <heatsink> Instance declarations are made with the instance keyword.  However, that kind of error may be the result of a type error.
21:00:46 <mm_freak> Xeno: hoogle is not a haskell search engine, but rather a haskell API search engine
21:00:51 <mm_freak> it can't help you with errors
21:00:52 <heatsink> Hoogle only indexes names of variables, classes, and the like.  It doesn't describe Haskell syntax
21:00:56 <Xeno> http://pastie.org/8441764
21:01:41 <mm_freak> Xeno: ask for the type of x
21:02:02 <mm_freak> Xeno: type ":t x"
21:02:32 <Xeno> :t x x :: Integer
21:02:33 <lambdabot>     Couldn't match expected type `Expr -> Integer'
21:02:33 <lambdabot>                 with actual type `Expr'
21:02:33 <lambdabot>     The function `x' is applied to one argument,
21:02:55 <mm_freak> Xeno: now read "No instance for (Fractional Integer)" as "Integer is not a Fractional type"
21:03:06 <mm_freak> this is because (/) requires a Fractional type
21:03:34 <mm_freak> does the error make more sense now?
21:04:12 <Xeno> Yes, well that made sense, I'm just trying to figure out how far out of the paradigm I am.
21:04:27 <Xeno> I guess I want to do coersion, but it doesn't seem like you do that here.
21:04:41 <mm_freak> Xeno: you're right there, and it's a little haskell peculiarity that makes this fail
21:05:15 <mm_freak> when you write "let x = 10", haskell actually decides that it has to be Integer…  however, there is nothing wrong with saying 10 / 10
21:05:49 <mm_freak> > 10 / 10
21:05:51 <lambdabot>   1.0
21:06:04 <mm_freak> it's even fine to say:
21:06:09 <mm_freak> > let x = 10 in x / 10
21:06:10 <lambdabot>   1.0
21:06:43 <mm_freak> because now at the definition site of 'x' there is more context, and the type-checker knows that it has to be a fractional type, so it infers x :: Double
21:07:59 <mm_freak> you can solve this peculiarity by providing type signatures for all of your top-level definitions…  this includes let-without-in bindings in GHCi
21:08:15 <mm_freak> let x = 10 :: Double
21:15:52 <Xeno> Is it "regular" to provide such bindings in a formula like let x = ( y :: Double * z :: Double ) / g :: Double ??
21:17:02 <mm_freak> Xeno: not really, only occasionally
21:17:52 <mm_freak> Xeno: the trouble is:  in GHCi you usually define small things with little context…  type inference has this default strategy:  use the closest type that works
21:18:04 <mm_freak> with no context Integer is the closest type for 10
21:18:19 <mm_freak> in actual haskell programs this is much less an issue
21:19:00 <heatsink> Certainly for monomorphic variables, putting a type annotation on the variable binding is sufficient
21:19:14 <heatsink> let x = y * z / g :: Double
21:20:25 <lpaste> buzzfazz revised “haskell imagemagick animated giff”: “No title” at http://lpaste.net/8654361665535475712
21:20:54 <buzzfazz> figured it out ... dumb mistake: should've used the output function "writeImages" not "writeImage"
21:21:23 <buzzfazz> g'night #haskell!
21:50:46 <relrod> [6~/4
21:50:48 <relrod> gah
22:10:38 * hackagebot cassy 0.6 - A high level driver for the Cassandra datastore  http://hackage.haskell.org/package/cassy-0.6 (OzgunAtaman)
22:48:39 <divyansr> I am wondering what Dijkstra would have said about haskell.
22:48:57 <startling> "considered harmful"
22:52:16 <prophile> Dijkstra would probably like it
22:52:36 <prophile> he accepted loops only as a necessary evil
22:54:01 <startling> @google pointfree considered harmful
22:54:01 <lambdabot> Plugin `search' failed with: user error (https not supported)
22:55:57 <divyansr> Here he shared his thoughts about functional programming https://www.cs.utexas.edu/users/EWD/misc/vanVlissingenInterview.html
23:24:32 <DrDev> Functor? Hardly know her!
23:27:00 <AshyIsMe> haha
23:27:25 <xeno> I am not understanding why there is no sprintf, or equivalent.  That makes a lot more sense than printf, since it can be implemented as a pure function.
23:28:03 <johnw> printf returns either IO a, or String
23:28:09 <johnw> depends on the context of use
23:29:27 <lispy> xeno: we have Text.printf which really is more like snprintf
23:29:33 <lispy> @hoogle printf
23:29:33 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
23:29:34 <lambdabot> Text.Printf class PrintfArg a
23:29:34 <lambdabot> Text.Printf class PrintfType t
23:29:44 <lispy> > printf "%d" 5
23:29:45 <lambdabot>   Could not deduce (Text.Printf.PrintfType t)
23:29:45 <lambdabot>    arising from the ambiguity c...
23:29:48 <johnw> > printf "%s" "Hello" :: String
23:29:49 <lambdabot>   "Hello"
23:29:50 <lispy> > printf "%d" 5 :: String
23:29:51 <lambdabot>   "5"
23:29:53 <johnw> > printf "%s" "Hello" :: IO ()
23:29:55 <lambdabot>   <IO ()>
23:33:11 <xeno> Thankyou lispy, I got that to work.
23:38:19 <perebor> hi, so I've written a recursive function that builds a map and consumes a list. So the base case is buildMap [] _ m = m
23:38:48 <perebor> now, what if I'd like to quit if then length of the list is some n
23:42:01 <arkeet> perebor: use a helper function that keeps an integer argument of how much you've consumed, or something?
23:45:41 <sopvop> haskelldb looks quite cool. why so unpopular?
23:52:10 <mm_freak> sopvop: probably because it seems unmaintained
