00:07:20 * hackagebot bencoding 0.4.0.2 - A library for encoding and decoding of BEncode data.  http://beta.hackage.haskell.org/package/bencoding-0.4.0.2 (SamTruzjan)
00:07:20 * hackagebot lens 3.9.2 - Lenses, Folds and Traversals  http://beta.hackage.haskell.org/package/lens-3.9.2 (EdwardKmett)
00:24:16 <adnap> If I have "data T = A Integer | B", can I check that a value of T is an A without pattern matching? If not, what is the most concise way to pattern match?
00:25:55 <startling> adnap, prisms are nice
00:26:12 <startling> you could have preview _A :: T -> Maybe Integer
00:27:07 <startling> or has _A :: T -> Bool
00:27:32 <Taneb> adnap, why not use Maybe Integer?
00:27:57 <startling> I assumed there was more to it, but that's a good point too.
00:28:19 <adnap> Yeah, this is way abstracted from my problem.
00:28:30 <Taneb> Oh
00:28:34 <adnap> Maybe I can come up with a better abstraction
00:28:36 <Taneb> Well, startling's way uses lens
00:28:50 <Taneb> But you could make a function checkA :: T -> Maybe Integer
00:30:28 <adnap> I have "data T = A Integer | B Char | C String" and "data S = S { as :: [Integer], bs :: [Char], cs :: [String] }" and I want to make an S from [T]
00:30:56 <Taneb> Then folding with pattern matching is your best bet
00:31:11 <Taneb> Either you can use a case in a lambda or a new function in a where clause
00:31:55 <adnap> Actually, T's are sent over a socket. :P
00:32:26 <startling> adnap: the thing prisms don't let you do is ensure totality
00:32:35 <Taneb> adnap, I still think a fold would be best
00:32:50 <Taneb> Probably a left fold in this situation?
00:32:59 <adnap> startling: I don't understand "totality"
00:33:10 <adnap> Are you talking about an order?
00:33:27 <startling> oh, I think I misread the problem.
00:33:40 <startling> prisms don't let you say "one of these three prisms always matches"
00:35:21 <adnap> Is this the most concise? isA :: T -> Bool; isA x = case x of; A _ -> True; _ -> False
00:35:49 <startling> is there a thing in lens that goes Alternative f => Traversal s t a b -> f t, where the result is "empty" if the traversal doesn't apply to anything?
00:35:58 <adnap> Or isA (A _) = True; isA _ = False
00:37:35 <startling> :t (maybe empty pure .) . preview -- I guess that's just this
00:37:36 <lambdabot> Alternative f => Getting (First a1) a a1 -> a -> f a1
00:38:09 <adnap> I wish I knew Template Haskell. It would save writting a bunch of isA, isB, isC, ...
00:38:13 <adnap> *writing
00:38:37 <startling> adnap, makePrism ''T
00:38:41 <startling> *makePrisms
00:39:17 <adnap> startling: Then, from what you wrote, I still need to write isA = isJust . preview _A
00:39:36 <startling> adnap, "has"
00:39:42 <startling> > has _Just $ Just 13
00:39:46 <lambdabot>   True
00:39:54 <adnap> wat
00:40:14 <startling> instead of "isA" you could have "has _A"
00:40:24 <adnap> Also, what if I have "data T = A Integer | B Integer"? Does preview _A still return Nothing for a B?
00:40:52 <Taneb> Yeah, it's just a traversable rather than a prism
00:41:07 <adnap> What is?
00:41:12 <startling> adnap, yep.
00:41:18 <adnap> What is a prism?
00:41:37 <adnap> Is a prism a lens?
00:41:49 <Taneb> A Prism is a fancy thing that's a bit like a lens
00:41:58 <startling> adnap: it's sort of like a lens. it's more like a traversal.
00:42:07 <adnap> So, it can't be used with functions that take lenses.
00:42:15 <startling> it sometimes can be.
00:42:21 <adnap> Then it is sometimes a lens.
00:42:37 <startling> adnap: no. lenses are always traversals. prisms are always traversals.
00:42:39 <Taneb> No, just the functions that take lens are sometimes very general
00:42:52 <startling> if your function takes a lens, it might really only require that the thing be a traversal.
00:43:00 <startling> e.g. "has" works on lenses
00:43:07 <startling> > has _1 ('a', 'b')
00:43:08 <lambdabot>   True
00:43:12 <Taneb> _Just is a prism, right?
00:43:12 <Taneb> > Just 'a' ^. _Just
00:43:12 <Taneb> Doesn't work
00:43:13 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
00:43:13 <lambdabot>    arising from a use o...
00:43:31 <kamatsu> so, data types a la carte (from Swierstra) is wonderful and all, but is it possible to generalise this approach to mutually recursive data types?
00:43:33 <Taneb> > Just "a" ^. _Just
00:43:33 <Taneb> does
00:43:35 <lambdabot>   "a"
00:43:48 <adnap> I thought a lense was like (a -> f b) -> f a -> f b or somethign
00:44:13 <Taneb> A lens is forall f. Functor f => (a -> f b) -> f a -> f b
00:44:14 <adnap> So if a function takes those arguments, and a function sometimes takes a prism, then how can a prism not be a lens?
00:44:21 <startling> yeah. type Prism s t a b = (Choice p, Applicative f) => p a (f b) -> p s (f t)
00:45:06 <startling> adnap, lenses are Functor f => (a -> f b) -> f a -> f b
00:45:17 <adnap> Yeah, I already wrote that
00:45:18 <Taneb> Because both of them are type synonyms rather than datatypes in their own right, they have an overlap
00:45:18 <startling> adnap, traversals are Applicative f => (a -> f b) -> f a -> f b
00:45:27 <adnap> I'm aware that f has to be a Functor
00:45:29 <startling> adnap: no, you left out the Functor f => part.
00:45:30 <startling> OK.
00:45:34 <startling> so every lens is a traversal.
00:46:03 <startling> (because every Applicative is also a Functor.)
00:46:23 <startling> (i.e., code written for every Functor works for every Applicative, too)
00:46:27 <adnap> Taneb: Which is why I don't understand how if a function acceps a lens and a prism, a prism is not a lens
00:47:01 <startling> adnap: (+) accepts Ints and Doubles. is an Int a Double?
00:47:05 <adnap> startling: That doesn't make sense. A traveral is more restrictive than a lens
00:47:13 <startling> adnap, nope.
00:47:21 <startling> adnap, there's a forall here.
00:47:28 <adnap> A traversal requires an applicative, while a lens requires a functor
00:47:35 <startling> adnap, yes.
00:47:48 <adnap> So traversals work on less types than lenses
00:47:51 <adnap> ER
00:48:23 <adnap> That makes no sense. Sorry
00:48:32 <startling> adnap, we're on the same page now?
00:49:03 <tikhon> adnap: take a look at the arguments of Lens
00:49:06 <adnap> Yes, I agree that "every lens is a traversal"
00:49:07 <tikhon> s t a b
00:49:13 <adnap> I hate stab
00:49:14 <adnap> Stab me
00:49:27 <tikhon> well, my only point was that there was no 'f'
00:49:28 <Taneb> source target alpha beta
00:49:33 <tikhon> but I think you understand that already
00:49:54 <startling> adnap, OK. so also, every prism is a traversal, since type Prism s t a b = (Choice p, Applicative f) => p a (f b) -> p s (f t)
00:50:04 <Taneb> All lenses are traversals. All prisms are traversals.
00:50:10 <adnap> I don't know what a Chocie is
00:50:16 <startling> adnap, sine (->) is a Choice, this specifies down to Traversal.
00:50:19 <startling> *since
00:50:27 <adnap> Would it be easier for me to learn from a tutorial?
00:50:53 <startling> adnap: it's just a complicated typeclass. don't worry about it. You just need to know that (->) is a Choice, and so all prisms work as traversals.
00:51:16 <shachaf> I guess when you have linear types, not all functors are strong?
00:51:47 <adnap> O dpm
00:51:59 <adnap> I don't remember the more generalized lense that has 4 types instead of two
00:52:12 <adnap> *lens
00:52:46 <startling> so, lots of the lensy combinators work for any traversal. the set-ish ones all do. the view-ish ones mostly don't, since a traversal might not actually apply your function to anything.
00:53:02 <startling> do you see why?
00:53:10 <adnap> No
00:53:53 <startling> :t \f a -> pure a
00:53:54 <lambdabot> Applicative f => t -> a -> f a
00:54:00 <startling> ^ this is a traversal
00:54:22 <adnap> :t traverse
00:54:24 <arkeet> :t (\f a -> pure a) :: Applicative f => (a -> f b) -> (s -> f s)
00:54:25 <lambdabot> Applicative f => (a -> f b) -> s -> f s
00:54:44 <startling> 'pure' gives you the ability to create some of your f without involving the function.
00:55:02 <arkeet> :t ignored
00:55:03 <lambdabot> Applicative f => pafb -> s -> f s
00:55:12 <startling> but if you just have Functor, and if your code is written for forall f. Functor f, it can't.
00:55:43 <arkeet> > "abc" ^.. ignored
00:55:45 <lambdabot>   []
00:55:45 <adnap> The type of traverse makes no sense. I must have forgotten about how it works
00:55:52 <arkeet> > "abc" & ignored .~ 5
00:55:54 <lambdabot>   "abc"
00:56:14 <adnap> How can you make an f s with (a -> f b) and s?
00:56:16 <arkeet> adnap: traverse is mapM
00:56:17 <startling> adnap, lambdabot swallowed your :t. that was arkeet's thing.
00:56:22 <adnap> Well, with pure you can
00:56:27 <fizruk> :t (^..)
00:56:27 <lambdabot> s -> Getting (Endo [a]) s a -> [a]
00:56:28 <adnap> @src traverse
00:56:29 <lambdabot> Source not found. stty: unknown mode: doofus
00:56:36 <startling> adnap: you apply it to part of your s.
00:56:39 <arkeet> traverse is a class method
00:56:55 <startling> (You have a specific s. not a forall s.)
00:57:23 <arkeet> :t traverse
00:57:25 <adnap> Is there any good tutorial I can read?
00:57:28 <arkeet> :t Data.Traversable.traverse
00:57:29 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
00:57:34 <startling> adnap, take a look at \f (a, b) -> fmap ((,) a) $ f b
00:57:40 <adnap> Okay, no wondedr
00:57:48 <adnap> lambdabot said the wrong thing to me
00:57:55 <startling> that was arkeet's :t
00:58:01 <adnap> I know
00:58:12 <arkeet> elliott should fix this behaviour
00:58:20 <startling> I think it's a bug.
00:58:23 <shachaf> It's a bug.
00:58:29 <adnap> I got
00:58:29 <shachaf> It's been figured out and fixed in the past.
00:58:31 <adnap> :t traverse
00:58:37 <adnap> I don't even know what the hell it is
00:58:38 <shachaf> And then, you know.
00:58:42 <startling> shachaf: heh
00:59:04 <adnap> > "hi"
00:59:05 <lambdabot>   "hi"
00:59:13 <adnap> Okay...
00:59:25 <startling> adnap, there's https://github.com/ekmett/lens/wiki/Overview
00:59:43 <startling> adnap: we're almost there, though. :)
00:59:54 <adnap> I want something as simple as LYAH
01:00:49 <adnap> startling: I looked at your function
01:01:16 <arkeet> adnap: read the typeclassopedia about traverse.
01:01:17 <startling> adnap: do you see how that applies f to part of the tuple and then uses fmap to get an f (a, b) ?
01:01:26 <arkeet> as an exercise, implement Traversable instances for your favourite things.
01:01:26 <adnap> Yes
01:01:42 <adnap> I already did implement Traversable once when someone in here tried to teach me lens
01:01:49 <arkeet> [],  (,) e,  Either e,
01:01:50 <arkeet> heh
01:01:51 <adnap> Then I never used lens and probably forgot a bunch of stuff
01:01:57 <startling> adnap: cool. so have you seen Const?
01:02:01 <adnap> Yes
01:02:04 <adnap> And Identity
01:02:20 <adnap> And over, view, etc.
01:02:57 <adnap> And then I looked at the lens API and got really annoyed that there were all these types
01:03:05 <adnap> Like setters, getters, etc.
01:03:13 <adnap> And nothing matched up with the examples people showed me
01:03:47 <startling> oh. those are mostly just type synonyms, because most code requires even less than Traversal.
01:04:00 <adnap> https://gist.github.com/ion1/5924946/
01:05:05 <adnap> I am basically at the point of understand all of the above and nothing else
01:05:09 <adnap> *understanding
01:05:20 <fizruk> mm_freak: sorry, but you've just inspired me: "someone's freakish 'round the corner, could that someone be mm_freak?"
01:05:53 <startling> adnap: OK! So, for the traversal-ish functions we have "preview" and "has"
01:05:55 <startling> :t preview
01:05:56 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
01:06:06 <startling> :t has
01:06:06 <lambdabot> Getting Any s a -> s -> Bool
01:06:07 <haasn> fold-ish
01:06:10 <startling> shhhh
01:06:25 <arkeet> toListOf is a good one.
01:06:37 <startling> oh, that's probably a better place to start.
01:06:57 <arkeet> or foldMapOf
01:07:10 <haasn> :t traverseOf
01:07:11 <lambdabot> Over p f s t a b -> p a (f b) -> s -> f t
01:07:17 <arkeet> traverseOf = id ;)
01:08:18 <startling> you guys do it.I need to get to bed. >.>
01:08:43 <arkeet> me too
01:08:50 <startling> sorry adnap
01:09:06 <shachaf> I predict: It'll never be done.
01:10:47 <adnap> Well, is there any tutorial?
01:10:52 <adnap> How did you learn?
01:11:01 <adnap> This is the best thing I have read: https://gist.github.com/ion1/5924946/
01:11:20 <adnap> Should I just read the doc?
01:11:26 <mm_freak> fizruk: "of course!"
01:11:37 <startling> adnap: I learned when shachaf explained to me, at length, how lenses and traversals work
01:11:40 <startling> in this very channel
01:11:49 <startling> well, maybe #haskell-overflow
01:11:51 <adnap> How long did that take?
01:12:01 <startling> an hour at most.
01:12:07 <adnap> Wow, you're smart
01:12:28 <startling> >.>
01:13:40 * startling points adnap at http://nymag.com/news/features/27840/
01:13:57 <adnap> startling: I don't have kids
01:14:02 <adnap> startling: I'm sorry I praised you
01:14:16 <adnap> startling: I probably fried your internal reward circuits
01:14:34 <adnap> Now you will be less motivated
01:14:57 <startling> heh. my point was something more like "inherent intelligence is a red herring!"
01:15:29 <adnap> startling: You learn faster than me. That's accurate
01:16:09 <haasn> He may have had a better teacher! (no offense to startling :P)
01:16:15 <startling> ^ also true
01:16:41 <haasn> adnap: I'm somewhat confused (I didn't follow the start of the conversation), what exactly are you trying to learn?
01:16:48 <adnap> haasn: What a prism is
01:17:28 <haasn> adnap: what a prism ‘is’ or how it's represented internally?
01:17:53 <startling> What a prism is capable of. A Traversal would work fine for adnap's purposes.
01:18:01 <startling> I guess I should have been more clear about that.
01:18:14 <adnap> I want to use what startling suggested
01:18:18 <adnap> And understand how it works
01:18:43 <startling> I was going to walk you through deriving preview and has, but toListOf is a better suggestion.
01:18:53 * startling disappears
01:19:11 * haasn is not sure what adnap's purposes are
01:19:30 <adnap> haasn: I want to learn lens
01:19:40 <startling> adnap wants to avoid writing isX for every one of their constructors
01:19:57 <adnap> startling: Go to bed
01:20:08 <haasn> ok. I'd use a Prism for that even if a Fold works fine :)
01:20:22 <haasn> But regardless, I'm not sure where to start, since I don't know what adnap knows and what adnap doesn't know.
01:20:36 <adnap> I understand https://gist.github.com/ion1/5924946/ and nothing else
01:21:41 <shachaf> It doesn't really matter where you start.
01:21:58 <adnap> shachaf: Please teach me!
01:24:15 <haasn> adnap: so it looks like you understand what a lens and a traversal are, but don't know what a fold or prism is?
01:24:39 <adnap> haasn: Yeah, but I probably forgot some stuff
01:25:57 <mmirman> Anybody know what to do about "2121: utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: No such file or directory" other than install libgmp (which has been done)?
01:26:23 <shachaf> strace?
01:26:53 <haasn> I like folds. Folds are easy! Basically, a fold is a read-only traversal. ‘folded’ is a motivating example, for all Foldable things. An example of a fold could be ‘replicate :: Int -> Fold a a’ and it obviously can't be a traversal because there's no way to recombine the arbitrary number of ‘a’s you get out of it
01:29:48 <haasn> adnap: internally a fold is just like a traversal but the applicative ‘f’ it has also has a Contravariant constraint, the combination of which basically gives you coerce :: f a -> f b; the only relevant instance of both is ‘Const a b’ so you can see why it can only be used to read out
01:30:43 <adnap> :/
01:31:27 <haasn> is something I said weird or confusing?
01:31:41 <adnap> Yeah, pretty much everything
01:31:50 <haasn> :(
01:32:32 <fizruk> haasn: Contravariant is dual to Functor?
01:32:43 <haasn> (oh, I made at least one mistake; replicate should be replicated. The standard function ‘replicate’ isn't a legal fold in its own right)
01:33:12 <Taneb> fizruk, Functor is its own dual. Contravariant is the class with contramap :: (b -> a) -> f a -> f b
01:33:13 <shachaf> fizruk: Not "dual" in the usual sense.
01:33:16 <haasn> fizruk: I'm not sure if ‘dual’ is the right word (I don't know much CT) but it's the same a functor that flips arrows around when mapping, yes
01:36:31 <fizruk> shachaf: what's the usual sense?
01:38:13 <fizruk> haasn: am I correct that being both Functor and Contravariant enables f a -> f b and f b -> f a coerces provided any of (a -> b) or (b -> a)?
01:38:23 <shachaf> "in the opposite category"
01:38:44 <adnap> shachaf: Will you teach me lens sometime, or do you not want to?
01:39:03 <shachaf> But arguments over the meaning of the word "dual" are a waste of time.
01:39:59 <haasn> fizruk: I'm not sure I understand that but consider contramap (const ()); const () :: a -> () so contramap (const ()) :: Contravariant f => f () -> f a
01:40:24 <haasn> fizruk: and fmap (const ()) obviously gives you Functor f => f b -> f ()
01:41:34 <haasn> also contramap absurd :: Contravariant f => f b -> f Void -- fmap absurd :: Functor f => f Void -> f a
01:41:42 <adnap> I'm going to try reading the Hackage documentation
01:41:47 <shachaf> In Haskell: If F is a Functor, then "F A" "produces" A, in a vague, general sense.
01:42:08 <haasn> adnap: I assume you know of http://lens.github.io/ ?
01:42:09 <shachaf> That could mean it produces zero or multiple As, or only when you give it something, or only gives you instructions on how to do it, or whatever.
01:42:23 <adnap> haasn: No
01:42:29 <shachaf> But if F is Contravariant, then "F A" "consumes" A, in a similar sense.
01:42:33 <adnap> I wonder if shachaf has me on ignore
01:42:37 <haasn> Well then you might as well check it out :)
01:43:16 <shachaf> If you have a machine that eats apples, and a machine that turns bananas into apples, then you can build a machine that eats bananas.
01:43:22 <fizruk> adnap: sorry, I might have distracted him with "dual"
01:43:35 <shachaf> adnap: Yep.
01:43:46 * adnap is confused
01:44:02 * adnap hurt himself in his confusion
01:44:38 * haasn wants one of these machines that turn bananas into apples
01:45:08 <adnap> haasn: Thanks for the link
01:45:09 * fizruk would prefer bananas.
01:46:01 <shachaf> If you have a machine that produces apples, and you know how to turn apples into bananas, you can build a machine that produces bananas.
01:46:24 <haasn> in shachaf's analogy, the f that has (Functor f, Contravariant f) we're concerned about is ‘Const a’ and will essentially ‘consume zero’ and ‘produce zero’ a’s
01:46:27 <adnap> What is a monomorphic container?
01:46:29 <haasn> b’s *
01:46:33 <adnap> [String]?
01:46:46 <haasn> adnap: Text ‘contains’ Char, for example
01:46:48 <shachaf> This whole thing is just to explain Gettable? Who cares.
01:46:59 <haasn> but this obviously cannot be made an instance of Functor, Foldable or Traversable
01:47:04 <adnap> haasn: Not understood
01:47:35 <haasn> adnap: over text :: (Char -> Char) -> Text -> Text
01:47:43 <adnap> What is a monomorphic container?
01:48:58 <quchen> Monomorphic is the opposite of polymorphic. Like Haasn said, Text is a monomorphic container for, well, text. It can't contain Int or (a -> b).
01:49:09 <quchen> Lists on the other hand are polymorphic in what they can contain.
01:50:10 <adnap> So "data F = F Integer" is monomorphic
01:50:18 <quchen> Yes.
01:50:24 <adnap> "data F = F" is monomorphic?
01:50:48 <quchen> Ummm … that's un-morphic ;-)
01:51:01 <haasn> ‘F’ is monomorphic
01:51:04 <quchen> Take away bottom and that's the same as "data F = F ()"
01:51:31 <haasn> ‘Monomorphic’ is a property of values (or types? I think you may get into trouble calling a type “polymorphic”)
01:52:19 <adnap> I'm just reading the lens Haddock. I think it's going well
01:53:28 <lieven_> given data Test = Test { a::Integer, b::Integer}, is there a way to map the Test constructor to a list of lists of Integers? map ?Test? [[1,2],[3,4]] giving [Test 1 2, Test 3 4]?
01:54:06 <monoidal> lieven_: map (\[a,b] -> Test a b) - though, what happens if your list has a list of different length?
01:54:20 <monoidal> lieven_: if you use tuples, map (uncurry Test)
01:55:05 <lieven_> monoidal: thanks. Should have thought of that. The lisper in me was looking for APPLY.
01:58:31 <haasn> adnap: lens haddocks are fantastic!
01:58:34 <haasn> I learn about lens that way
02:10:04 <petapetapeta> I am attempting to enable glr in happy using the --glr flag. It compiles fine, but when I attempt to use the produced .hs file I get the following error: http://lpaste.net/2612546013935697920
02:11:15 <petapetapeta> That is - when I attempt to compile using ghc.
02:12:31 * hackagebot groundhog 0.4.0.1 - Type-safe datatype-database mapping library.  http://beta.hackage.haskell.org/package/groundhog-0.4.0.1 (BorisLykah)
02:12:34 * hackagebot groundhog-th 0.4.0.1 - Type-safe datatype-database mapping library.  http://beta.hackage.haskell.org/package/groundhog-th-0.4.0.1 (BorisLykah)
02:14:27 <fizruk> petapetapeta: are you running cabal build/install?
02:14:47 <petapetapeta> fizruk: No.
02:16:45 <adnap> Does anyone find the Cont monad useful? I just found out about it by reading https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
02:17:01 <petapetapeta> fizruk: should I be? :P
02:17:23 <solrize> adnap it's used inside lots of useful libraries, though using it directly can be confusing
02:17:34 <adnap> I don't quite understand how it is better than function composition yet
02:17:51 <solrize> you know how coroutines work?
02:17:57 <solrize> or "yield" in python?
02:18:01 <adnap> No
02:18:01 <solrize> you can do that stuff with cont
02:18:14 <solrize> hmm
02:19:52 <solrize> http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html
02:19:53 <fizruk> petapetapeta: is `import System` generated by happy?
02:20:06 <solrize> i gotta go to bed, i can talk about this more some other time
02:20:45 <petapetapeta> fizruk: Yeah
02:21:27 <fizruk> petapetapeta: hmm... what versions do you use?
02:21:39 <petapetapeta> fizruk: Ghc 7.4.1
02:21:49 <petapetapeta> Happy 1.18.9
02:24:14 <fizruk> petapetapeta: I believe this is related to your problem: http://stackoverflow.com/questions/9555671/ghc-7-4-update-breaks-haskell98
02:25:19 <petapetapeta> fizruk: Ahh yes - that looks right :) Thank you
02:31:00 <petapetapeta> fizruk: Removing the import System statement seems to have resolved the issue
02:31:17 <petapetapeta> However now I get another error in the generated code. GLR_Lib.hs:26:14: parse error on input `doParse'
02:33:34 <fizruk> petapetapeta: emm... could you hpaste the context?
02:35:35 <petapetapeta> fizruk: I am unsure about where the error occurs. It seems like it is in a file called GLR_Lib.hs, but I can't locate it on my computer
02:36:54 <petapetapeta> fizruk: I think it's in this one http://lpaste.net/9164911007900893184
02:41:45 <radioxid> Hey I see that http://www.haskell.org/haskellwiki/Learn_Haskell_in_10_minutes isn't translated to French yet.
02:41:50 <radioxid> Can I do that?
02:42:58 <adnap> I think I found an error in the lens Haddock
02:43:32 <adnap> "A Getter s a is just any function (s -> a)..." and "it is isomorphic to an arbitrary function from (a -> s)."
02:45:26 <fizruk> petapetapeta: can you hpaste exact build process? like `$ happy ...; ghc ...`
02:45:27 <Lethalman> anybody can add https://github.com/garetxe/haskell-gi to http://www.haskell.org/haskellwiki/GObjectIntrospection ?
02:45:30 <Lethalman> don't have an account
02:45:42 <Lethalman> registration to the wiki is ugly :S
02:46:12 <fizruk> petapetapeta: I tried a small piece of GLR_Lib.hs (with undefined) which works in ghc-7.4.2
02:46:49 <fizruk> petapetapeta: I understand your error as "syntax error in the export list"
02:47:26 <monoidal> radioxid: yes, you only need a wiki account (request it at nominolo at google mail)
02:48:05 * fizruk goes afk for 15 minutes.
02:55:07 <adnap> What the heck is the point of an Endo type that just turns function composition into mappend?
02:55:29 <haasn> adnap: using it with other abstractions that require a monoid
02:55:32 <haasn> (like lens!)
02:55:51 <adnap> I am still reading the lens Haddock and it's like reading a Wikipedia article where every other word is an unknown topic
02:56:35 <adnap> haasn: No surprise there since lens defines Endo
02:56:51 <haasn> adnap: Endo is defined in Data.Monoid
02:56:52 <haasn> it re-xports it
02:57:01 <adnap> Oh, okay
02:57:19 <ion> > let (Sum n, Endo f) = foldMap (\a -> (Sum a, Endo (a+))) [1..5] in (n, f 0)
02:57:20 <lambdabot>   (15,15)
02:57:28 <adnap> ion: Hey
02:58:49 <adnap> (Sum a, Endo f) is a monodi?
02:58:56 <adnap> *monoid
02:58:57 <ion> yes
02:59:27 <monoidal> Monoid m, Monoid n => Monoid (m,n)
02:59:38 <adnap> Ohh
02:59:50 <ion> > let (s, Endo f) = foldMap (\a -> (a, Endo (a ++))) ["Jelly", " ", "world", "!"] in (s, f "")  -- f ends up being like a difference list.
02:59:51 <lambdabot>   ("Jelly world!","Jelly world!")
03:00:01 <ion> Well, s/like //
03:00:21 <adnap> ion: Were you just trying to explain that Endo behaves like Sum in that example?
03:00:59 <Flonk> Geez, the guys at #java are dicks
03:01:36 <adnap> > Endo (+2) <> Endo (*5) $ 3
03:01:37 <lambdabot>   Couldn't match expected type `a1 -> t0'
03:01:38 <lambdabot>              with actual type `Data...
03:06:18 <adnap> Ohh
03:06:39 <adnap> > appEndo (Endo (+2) <> Endo (*5)) 3
03:06:41 <lambdabot>   17
03:13:06 <ion> adnap: yeah
03:14:00 <ion> Much of the power of the Monoid class comes from the “… Monoid a … => Monoid (… a …)” instances.
03:14:15 <adnap> This Contravariant class is weird. I can't use things in Control.Lens.Fold if I don't know whether my functor is Contravariant
03:14:21 <ion> So it’s not enough to think about the usefulness of Endo alone.
03:14:40 <petapetapeta> fizruk: Sorry for the delay. Was just in a meeting. I will hpaste it in a sec.
03:17:58 <petapetapeta> fizruk: http://lpaste.net/3944216064467927040
03:21:10 <mcjohnalds> hello?
03:21:22 <chrisdone> donri: do n sa ri ko mo
03:21:24 <chrisdone> mcjohnalds: hey
03:22:11 <mcjohnalds> anyone know good resources for learning Yampa?
03:22:33 <ocharles> mcjohnalds: the Yampa papers are quite accessible
03:22:41 <ocharles> mcjohnalds: also, jekor has a video on youtube about using Yampa
03:22:56 <ocharles> mcjohnalds: and if you change your mind to use netwire, I use that daily at the moment ;)
03:23:31 <mcjohnalds> is that paper your talking about called "Arrows, Robots, and Functional Reactive Programming"?
03:23:58 <ocharles> mcjohnalds: that, and 'The Yampa Arcade'
03:24:07 <mcjohnalds> Ok, awesome, thanks!
03:24:34 <ocharles> mcjohnalds: http://haskell.cs.yale.edu/publications/#FunctionalReactiveProgramming
03:24:43 <ocharles> lots of Yampa there
03:24:58 <mcjohnalds> ooh, thanks for the list :)
03:25:22 <ocharles> i'm working my way through it myself :)
03:25:29 <petapetapeta> fizruk: No wait. That is not the right one. Give me a second
03:27:51 <petapetapeta> http://lpaste.net/97851410976079872
03:29:47 <fizruk> petapetapeta: emm... wait a sec
03:32:01 <fizruk> petapetapeta: haven't you moved on with the <Could not find module `System'> error?
03:32:02 <mjboa> hey guys, what's the best way to update cabal if it's out of date in my package manager?
03:32:37 <petapetapeta> fizruk: Yeah I fixed that by removing the 'import System'-line
03:34:29 <MasseR> mjboa: cabal install cabal-install
03:34:43 <shiona> is there a way to do a stable single-pass split (for merge sort)
03:34:55 <mjboa> MasseR: that won't destroy my whole installation somehow?
03:35:04 <Flonk> Is there an inbuilt function to turn an (a,b,c) into a (b,c) (like head, but on tuples)?
03:36:37 <MasseR> mjboa: You install it locally for your user
03:36:50 <mcjohnalds> Flonk: I put (a,b,c) -> (b,c) into hoogle and nothing said no, so I'd asume there isn't
03:37:41 <Flonk> mcjohnalds: Too bad. Thanks, though!
03:38:37 <petapetapeta> fizruk: Okay. I've gotten a step further. I think. It looks very weird to me. So I compile using 'happy Parser.y --glr'. This gives me a file with the 'import System'-line which I remove. Then I compile using the long ghc command I pasted in the last lpaste. It turns out that it attempts to compile a file named ParserData.hs(No idea where this comes from) and fails due to there being two 'module .... where'-lines. If I remove one of them I
03:38:37 <petapetapeta>  get some type errors
03:38:58 <quicksilver> there is little or nothing in the standard library which operates on triples, Flonk . But \(_,b,c)->(b,c) is not too hard to type and is quite clear in my opinoin.
03:39:08 <Peaker> adnap: if you know traversals, lens will be easy to learn
03:39:29 <fizruk> petapetapeta: ParserData is generated via `happy Parser.y`
03:39:30 <Peaker> (and knowing semantic editor combinators could help too, since lens are sort of a generalization of that)
03:39:42 <radioxid> thanks monoidal. Will do.
03:39:59 <gspr> Am I correct in understanding that the new Hackage supports uploading documentation for a package in case those fail to build on the server (for example because of missing FFI dependencies)?
03:40:09 <petapetapeta> fizruk: oh yeah. That clears that part up :) Thanks
03:40:51 <Flonk> quicksilver: Yep! I just wanted to know if I'm writing unnecessary code there.
03:45:16 <petapetapeta> fizruk: Is it correct that ParserData.hs will only be generated if I use the --glr flag?
03:45:57 <fizruk> petapetapeta: I believe so
03:47:21 <petapetapeta> fizruk: When using the --glr flag both Parser.hs and ParserData.hs is generated
03:47:25 <petapetapeta> Which one should I use?
03:48:23 <fizruk> petapetapeta: Parser.hs has this small line: import ParserData
03:50:31 <petapetapeta> fizruk: Okay. Do you have any idea why it would create two module lines?
03:57:00 <fizruk> petapetapeta: I think GLR-related code is outdated (for ghc at least)
03:58:10 <petapetapeta> fizruk: That would certainly explain some of the things I'm seeing.
03:58:54 <fizruk> petapetapeta: the only confusing thing is that ProduceGLRCode.lhs has been modified 2 months ago (https://github.com/simonmar/happy/blob/master/src/ProduceGLRCode.lhs)
03:59:16 <RommelVR> argiopeweb: so I figured it out :D
03:59:45 <RommelVR> argiopeweb: basically just went with the toRational/fromRational pair as we discussed b4
04:00:14 <RommelVR> but it was only a problem because of the fact that sqrt was giving a Floating type
04:00:28 <fizruk> hm...
04:01:24 <petapetapeta> fizruk: Could it be that my Happy version is not completely up to data and that this results in the errors?
04:02:05 <fizruk> petapetapeta: no, I've tried that with the latest happy (1.19.0) and got the same
04:03:04 <petapetapeta> fizruk: That's a shame :/
04:03:23 <petapetapeta> Where did you find 1.19.0?
04:03:40 <fizruk> petapetapeta: cabal install happy-1.19.0
04:03:54 <fizruk> petapetapeta: on hackage :)
04:04:01 <petapetapeta> fizruk: Cool thanks :) I just found it on hackage as well ;)
04:05:17 <fizruk> petapetapeta: there's also a year-old SO question related (I think) to your problem (http://stackoverflow.com/questions/13279087/parser-library-that-can-handle-ambiguity)
04:06:21 <fizruk> petapetapeta: there is another possibility: GLR functionality has been tested with another Haskell compiler
04:06:39 <petapetapeta> fizruk: Yeah it is peripherically mentioned in one of the comments
04:07:00 <petapetapeta> fizruk: Oh yeah that might be an option.
04:07:24 <petapetapeta> fizruk:  So it is just incompatible with GHC
04:08:22 <fizruk> petapetapeta: [on SO question] i meant, you could probably use different tools (maybe, polyparse)
04:09:03 <petapetapeta> fizruk: Yeah I might have to do that. Luckily it should be possible to just substitute the parser for another
04:10:21 <gspr> Is there, with the new Hackage, a mechanism for saying "build the docs even though the dependencies of the package are not satisfied"?
04:11:26 <fizruk> petapetapeta: I doubt that. Happy is a preprocessor like yacc or bison, while polyparse is a combinator parser library like Parsec
04:12:17 <petapetapeta> fizruk: Damn! I was rather hoping to avoid that
04:16:58 <petapetapeta> fizruk: I was kinda hoping for a parser generator
04:18:59 <fizruk> petapetapeta: for any particular reason?
04:24:46 <petapetapeta> fizruk: Working with a deadline so the less I have to rewrite the better
04:25:17 <fizruk> petapetapeta: do you actually need GLR?
04:25:29 <petapetapeta> I need to be able to set associativity
04:26:25 <fizruk> petapetapeta: have you seen this? http://www.haskell.org/happy/doc/html/sec-Precedences.html
04:26:57 <petapetapeta> fizruk: But that requires GLR doesn't it?
04:27:46 <fizruk> petapetapeta: nope, I can remember myself using precedences in happy about 3 years ago without GLR
04:28:12 <petapetapeta> fizruk: that's strange. Couldn't get it to work. I just have to log off for 15 minutes. I will be back :)
04:30:49 <quchen> Is there some trick to make exceptions not require explicit type annotations? Take `try` for example, it creates an "e" out of nothing, hence there's an ambiguity when you use it
04:31:35 <quchen> One obvious fix is of course locally defining a monomorphic synonym a ly `try' :: IO a -> IO (Either MyException a)`, but that looks like a code smell
04:31:40 <nominolo> quchen: if you pattern match on the exception the type is clear
04:31:42 <donri> quchen: you can use the predicates to restrict the type
04:32:10 <merijn> quchen: Eh, if you actually *use* the exception it will be inferred
04:32:14 <donri> quchen: also, tryIOError if it's an IOError
04:32:36 <fizruk> petapetapeta: see also this page http://www.haskell.org/happy/doc/html/sec-glr-using.html
04:32:43 <merijn> quchen: I usually use "case try foo of Left (SomeException _) -> failureCode; Right x -> doSomething x"
04:33:43 <quchen> Yeah when I pattern match on it immediately it's not a problem
04:33:58 <donri> http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Exception.html#g:4
04:38:41 <donri> while on the subject of exceptions, my main problem with them is that it's so hard to tell what exception actually got thrown: you only get the Show string, which typically is a message without the type or constructor!
04:38:46 <donri> is there something i'm missing/
04:38:47 <donri> ?
04:39:48 <merijn> donri: For IO Exceptions you can use functions to check
04:39:54 <merijn> @hoogle isEOFError
04:39:55 <lambdabot> System.IO.Error isEOFError :: IOError -> Bool
04:39:55 <lambdabot> System.IO.Error isEOFErrorType :: IOErrorType -> Bool
04:40:01 <donri> merijn: that doesn't help when it was already thrown
04:40:10 <donri> merijn: i mean when you're debugging something that throws
04:40:39 <donri> so it's hard to know which of those is* functions to use in the code
04:41:23 <merijn> donri: Eh, it does help, unless you're just catching everything ಠ_ಠ
04:41:42 <donri> merijn: i'm talking about when you're not catching anything, or at least not the one that is thrown
04:41:50 <quchen> I'm in a weird place between catchall and sane error handling right now.
04:42:13 <merijn> donri: I don't understand what you mean? Do you have an example of what that code looks like?
04:44:02 <donri> merijn: you have a program that sometimes fails with an exception. you need to know which exception it is so you can handle it better, but it's not always clear from the message which exception it actually is
04:45:12 <merijn> donri: "show . typeOf"?
04:45:53 <donri> merijn: yeah. i just wish it was included in the live error i guess :)
04:46:52 <merijn> donri: Blame the author of the exception instance
04:47:06 <donri> merijn: this is the case with every instance in base, i think
04:48:40 <RommelVR> merijn: https://gist.github.com/RommelVR/e2b9248a83b3d7184e60 - not bad progress from last night aye? :P
04:49:09 <merijn> donri: Patch proposal to libraries@ ;)
04:49:21 <merijn> I'm sure that wouldn't actually get much resistance
04:50:00 <quicksilver> most of the standard ones make it pretty clear what they are, don't they?
04:50:03 <quicksilver> *** Exception: doesntexist: openFile: does not exist (No such file or directory)
04:50:17 <merijn> RommelVR: Fun fact, you can make Vector3 a Functor instance with vmap as the implementation of fmap
04:50:21 <quicksilver> do you have examples of exception messages which seem ambiguous or uninformative?
04:51:01 <merijn> I think it can be an Applicative too
04:51:11 <donri> quicksilver: i think in the past i've been confused by "resource busy", which you need isAlreadyInUseError for i *think*, which makes sense in retrospect but is non-obvious to search for etc
04:51:12 <petapetapeta> fizbin: I am quite sure that I need GLR to handle the precedence in Happy. I've tried writing a grammar reminiscent of the one on http://www.haskell.org/happy/doc/html/sec-Precedences.html, but without glr it results in shift reduce errors
04:51:15 <RommelVR> merijn: will that lower complexity of the code in some way? Or is it better design, or simple an alternative approach? Remember, I'm learning, lets stay with pragmatism here haha
04:51:18 <merijn> I don't think a Monad instance would be sensible, though
04:51:48 <merijn> RommelVR: Well, making a Functor/Applicative instance means that all existing code that works for any functor/applicative immediately works for you
04:52:03 <quicksilver> donri: ah I understand what you mean.
04:52:21 <quicksilver> donri: not clear how to get back from the plain text error output to the "type" of exception to use in 'catch'ing them
04:52:22 <donri> quicksilver: or for that matter how you need predicate functions for io errors. would be easier if we had an ADT that we could pattern match on exhaustively
04:52:57 <quicksilver> I think that's historical - the messages were chosen long before the extensible-exceptions version of catch
04:53:01 <donri> e.g. if the error included ResourceBusy, and I could import that and pattern match on it, that'd be obvious
04:53:33 <merijn> RommelVR: Typeclasses like Functor/Applicative/Monad and to a lesser extent things like Foldable/Traversable have huge amounts of generic code written for it, the idea behind making instances for your own datatypes is getting the existing code "for free"
04:54:18 <merijn> RommelVR: Additionally, people *know* what fmap does, so it's less mental overhead to figure out what "fmap f vector" does than "vmap f vector" (although, not much in your case, I just mean in general :))
04:54:21 <RommelVR> merijn: ah, now I see what you mean
04:54:29 <quicksilver> donri: yes, extensible excpetions vs ADT exceptions is another tradeoff
04:54:32 <merijn> Last bonus, you don't have to worry about thinking up a name for your function! :p
04:54:40 <quicksilver> donri: the extensible exceptions paper has some details on why they chose this way I think
04:55:09 <RommelVR> merijn: I think in this case, its not so terrible :P, but of course it would be a plus to make it more compatible with prexisting code
04:55:48 <RommelVR> tho, I'm not entirely sure how I would go about making it a functor instance (will have to re-read up on it :P)
04:55:58 <merijn> RommelVR: oh, I agree, in this case it's a just a neat simple exercise (i.e. you have Functor already in the form of vmap, but can you see how to implement Applicative)
04:56:32 <merijn> RommelVR: Functor is just "fmap :: Functor f => (a -> b) -> f a -> f b", so for you it's "(a -> b) -> Vector3 a -> Vector3 b"
04:59:14 <chrisdone> yeah, i don't know why IOException is opaque, makes discoverability more annoying
05:00:47 <chrisdone> most opaque types are annoying =)
05:01:08 <donri> yeah
05:02:33 <haasn> merijn: of course, these days one can just provide a lens :)
05:02:37 <haasn> (and get all of the instances for free, too!)
05:05:28 <RommelVR> merijn: whats the difference between map and fmap?
05:05:41 <RommelVR> merijn: the functor context?
05:05:50 <Iceland_jack> RommelVR: fmap is a more general version of map
05:05:50 <haasn> ‘map’ is just a monomorphic version used to prevent scaring off newcomers :P
05:06:09 <haasn> (though in some cases ‘map’ could resolve type ambiguities that might arise from using ‘fmap’)
05:06:09 <Iceland_jack> > fmap succ ['a'..'h']
05:06:10 <lambdabot>   "bcdefghi"
05:06:11 <Iceland_jack> > map succ ['a'..'h']
05:06:13 <lambdabot>   "bcdefghi"
05:06:39 <Iceland_jack> > fmap succ (Just 'a')
05:06:40 <haasn> @src [] fmap
05:06:41 <lambdabot> fmap = map
05:06:41 <lambdabot>   Just 'b'
05:06:44 <Iceland_jack> > map succ (Just 'a')
05:06:45 <lambdabot>   Couldn't match expected type `[b0]'
05:06:45 <lambdabot>              with actual type `Data.May...
05:06:49 <RommelVR> @type map
05:06:50 <lambdabot> (a -> b) -> [a] -> [b]
05:06:53 <RommelVR> @type fmap
05:06:53 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:07:09 <RommelVR> ah
05:07:26 <RommelVR> that actually makes more sense haha
05:07:57 <mcjohnalds> Anyone know that paper "The Yampa Arcade"? I can't find the source files for it, all I get by searching google is haskell.org/yampa/afrp-0.4-src.tgz (link gives a 404)
05:08:16 <RommelVR> cheers haasn: your explanation plus those type signatures just cemented it (I think)
05:09:05 <mangaba_leitosa> mcjohnalds: web.archive.org/web/20070903144408/http://www.haskell.org/yampa/afrp-0.4-src.tgz
05:10:25 <mcjohnalds> mangaba_leitosa: That's really helpfull, thanks
05:11:46 <mangaba_leitosa> 206.cable.telstraclear.net] has quit [Ping timeout: 260 seconds]
05:11:48 <mangaba_leitosa> oops
05:11:57 <mangaba_leitosa> mcjohnalds: np :-)
05:26:19 <edwardk> adnap: 'Const r' is contravariant and the combinators in Control.Lens.Fold all use types that are Contravariant.
05:26:45 <edwardk> adnap: for the most part you don't wind up passing a Fold a functor yourself
05:27:04 <merijn> RommelVR: map == fmap for the list functor, yeah :)
05:27:32 <RommelVR> merijn: haha, :), yeah seeing the types of fmap vs map helped a lot
05:28:33 <edwardk> adnap: just fixed the Getter s a docs in HEAD
05:28:57 <merijn> RommelVR: Next challenge, figure out how "fmap == (.) for functions" ;)
05:29:18 <merijn> > fmap (+1) (+2) $ 0
05:29:20 <lambdabot>   3
05:32:17 <merijn> Actually, I guess the $ is superfluous
05:32:23 <merijn> > fmap (+1) (+2) 0
05:32:25 <lambdabot>   3
05:34:16 <edwardk> fizruk: re why Contravariant isn't dual to Functor. class Functor f where fmap :: (a -> b) -> f a -> f b   should probably be denoted so that we can see which of those are arrows in the category. (a ~> b) -> (f a ~> f b). to dualize it, flip all of the ~>'s You get (b ~> a) -> (f b ~> f a) . if you alpha rename that you get back where you started so the dual of a Functor is a Functor. Contravariant isn't that. ;)
05:34:30 <edwardk> fizruk: this is why when people say 'Cofunctor' they get booed.
05:34:57 <remdezx> Hi! I was just looking at ThreadId returned by forkIO, and I found something strange. What is that ThreadID# here http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Conc-Sync.html#ThreadId ? It is not defined anywhere...
05:35:52 <quicksilver> remdezx: it's an implementation ID.
05:35:55 <RommelVR> merijn: https://gist.github.com/RommelVR/64f89dd6cadc03f0cf91 what am I missing here :S
05:36:09 <quicksilver> remdezx: anything with # is some detail about how GHC implements that you don't normally need to care about
05:36:14 <fizruk> edwardk: I see, contravariant functor reverses arrows only for domain (or codomain) category, right?
05:37:02 <remdezx> quicksilver: so there is no source code for that?
05:37:40 <RommelVR> merijn:     The first argument of `Functor' should have kind `* -> *',
05:37:52 <quicksilver> remdezx: well, all the source code of GHC is available.
05:38:36 <quicksilver> remdezx: ThreadId# might be a primitive type defined in Cmm rather than a .hs file, though
05:38:40 <quicksilver> (I don't know if it is, or not)
05:38:42 <merijn> RommelVR: You should use "instance Functor Vector3 where"
05:39:04 <merijn> RommelVR: Why do you want to restrict it to Numeric types?
05:39:20 <remdezx> quicksilver: ok, thank you. That's all I needed to know ;)
05:39:46 <haasn> Fractional also implies Num
05:40:09 <yesthisisuser> i am looking at Text.Regex.Posix, and this tutorial http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
05:40:51 <yesthisisuser> matching over tuples or lists doesn't work
05:40:53 <RommelVR> merijn: interesting, my code b4 needed the extra argument for vector3
05:40:56 <RommelVR> yet this didn't?
05:41:10 <yesthisisuser> of course, the tutorial is a bit old
05:41:14 <merijn> RommelVR: ok, are you familiar with the term "kind"?
05:41:16 <haasn> RommelVR: class Functor f where fmap :: (a -> b) -> f a -> f b
05:41:36 <yesthisisuser> for example, "before foodiebar after" =~ pat :: (String,String,String) doesn't work for me
05:41:44 <haasn> RommelVR: if f = (Vector3 n) then this would be fmap :: (a -> b) -> Vector3 n a -> Vector3 n b -- but Vector3 only takes one parameter
05:42:06 <merijn> haasn: Pfft, stealing my explanation
05:42:11 <haasn> RommelVR: The class Functor is an abstraction over the *type constructor* Vector3, not the concrete type Vector3 n
05:42:27 <RommelVR> ahh
05:42:43 <haasn> It's different than, say, class Num  in that respect
05:42:45 <RommelVR> haasn: to the rescue again with terms that I seem familiar with :D
05:42:57 <RommelVR> merijn: and no, not familiar with "kind"
05:43:11 <haasn> ‘kind’ is like the type of a type
05:43:22 <merijn> RommelVR: To put it more abstractly, a "kind" is the "type of a type". The kind of a "normal" type like Char is *, so 'a' :: Char and Char :: *
05:43:24 <Fuuzetsu> ``kind''
05:43:24 <haasn> when we say “Vector3 only takes one parameter”, that's like a ‘type signature’ (actually kind signature)
05:44:08 <haasn> we formalize it by writing Vector3 :: * -> * -- it takes one type (of kind *, ie. something that has values), and gives you another type (of the same kind), eg. Int :: *, Vector3 :: * -> *; Vector3 Int :: *
05:44:22 <merijn> RommelVR: Now, if you look at the type "Maybe a", it's a type that takes another type as argument, right? So while "Just :: a -> Maybe a", "Maybe :: * -> *" (i.e. Maybe takes a "normal" type and returns a "normal" type)
05:45:02 <merijn> RommelVR: Some other examples, "Either :: * -> * -> *", that is, either takes 2 types and returns a new type
05:45:47 <haasn> Fix :: (* -> *) -> *; newtype Fix f = Fix (f (Fix f))
05:46:05 <haasn> Fix Vector3 ~ Vector3 (Vector3 (Vector3 (...))) -- :)
05:46:12 <haasn> but that's going off the deep end
05:46:55 <RommelVR> haha, eating an elephant here, but I think I get it, will continue on (and maybe look up 'kind' :)
05:47:21 <haasn> (->) :: * -> * -> * -- not to be confused with the -> on the right hand side
05:47:25 <merijn> RommelVR: Dont worry about it, it was just some extra info, at some point you'll go "oh, of course"
05:48:05 <merijn> RommelVR: The thing in this case is that, because of fmap's type ("(a -> b) -> f a -> f b") GHC infers that f must have kind "* -> *" (it takes an argument, right?)
05:48:11 * hackagebot yesod-core 1.2.4.4 - Creation of type-safe, RESTful web applications.  http://beta.hackage.haskell.org/package/yesod-core-1.2.4.4 (MichaelSnoyman)
05:48:27 <merijn> RommelVR: Whereas "(+) :: a -> a -> a", so the argument of Num has kind *
05:48:54 <merijn> RommelVR: This is the reason why you needed "instance Num (Vector3 a) where", but "instance Functor Vector3 where"
05:49:32 <haasn> to clarify: any type that has inhabitants must be of kind *; eg. Int has inhabitants (3, 4) so it must be of kind *
05:49:49 <haasn> (3, 4, etc.)*
05:50:31 <haasn> So if something is a parameter to a function or return value or binding or something, it must have a type of kind *
05:50:51 <edwardk> fizruk2: effectively, yes
05:50:57 <RommelVR> merijn: yeah cool, that is what I interpreted from what you were saying before, but thanks for re-iterating it :)
05:51:31 <haasn> fmap :: (a -> b) -> f a -> f b -- GHC infers f a, f b :: * because ‘f a’/‘f b’ is used as a value, and a, b :: * because ‘a’ and ‘b’ are used as values
05:51:35 <fizruk2> edwardk: btw, I think I came up with what properties I want for wrap and wrapT
05:51:38 <haasn> so it infers f :: * -> *
05:53:06 <tomejaguar> Does anyone understand this error when failing to install comonad: http://lpaste.net/93695
05:53:16 <franz__> Why is following not working with the Control.Lens package? traverseOf each print (1,'a')
05:53:34 <RommelVR> haasn: ok, I might go ahead and play with some examples, sec
05:53:54 <edwardk> franz__: the types of the two arguments have to match. otherwise we'd have to write an impossible rank-2 signature
05:54:24 <edwardk> tomejaguar: what version of cabal are you running?
05:54:50 <tomejaguar> apparently: cabal-install version 0.8.2 using version 1.8.0.6 of the Cabal library
05:54:53 <franz__> edwardk Thank!
05:54:58 <franz__> You
05:55:02 <tomejaguar> edwardk: Too old?
05:55:02 <edwardk> tomejaguar: cabal install cabal-install and then try
05:55:04 <edwardk> yeah
05:55:09 <dcoutts> wow, that is old
05:55:12 <edwardk> test-suites didn't exist back then
05:55:34 <tomejaguar> Haha.  How old is it?
05:55:43 <chrisdone> about as old as the Velvet Underground
05:55:50 <edwardk> tomejaguar: you're doing better than banging two rocks together to make fire, but not by much ;)
05:56:01 <fizruk2> edwardk: these two http://lpaste.net/93696
05:56:54 <dcoutts> tomejaguar: about 3.5 years
05:56:56 <edwardk> fizruk2: i'd be rather surprised if those held
05:57:24 <edwardk> fizruk2: i'll se if i can't figure out a counter-example with dolio at work today
05:58:44 <fizruk2> edwardk: I failed to get unexpected behaviour with FreeT Bin IO, though I believe you know better where to look for a counterexample
05:58:56 <christiaanb> how does one upload to the new hackage? I keep getting "No authorization provided" without ever getting to option to enter it anywhere (OS X 10.8.5, Safari 6.0.5)
05:59:17 <christiaanb> use a different browser?
06:03:33 <christiaanb> I guess I answered my own question there… I does give me an authentication pop-up in chrome
06:05:05 <RommelVR> ok, I think I get it :D
06:05:13 <RommelVR> merijn: haasn: https://gist.github.com/RommelVR/aec3f556f833e0669dba
06:06:38 <RommelVR> tldr    *   vs  * -> *
06:06:40 <RommelVR> makes sense
06:15:03 <donri> christiaanb: there's also cabal upload
06:15:22 <christiaanb> I got 404 errors last time I used it
06:15:37 <Dakk> Hey there! I need help with a sudokuSolver for school.
06:15:42 <Dakk> Got a slight error.
06:15:45 <christiaanb> I'll check again
06:17:15 <Dakk> Actually i just solved it on my own, thx anyway :)
06:17:22 <fizruk2> edwardk: property for wrap holds for both Free and FreeT
06:18:20 * hackagebot crypto-conduit 0.5.2.1 - Conduit interface for cryptographic operations (from crypto-api).  http://beta.hackage.haskell.org/package/crypto-conduit-0.5.2.1 (MichaelSnoyman)
06:19:50 <fizruk2> edwardk: my proofs in annotation http://lpaste.net/93696
06:19:53 <srhb> I've been having problems cabal install'ing glib for a few days, due to some problem with an ambigious moreRecentFile. Has anyone worked around this?
06:20:48 <{AS}> edwardk: Hi, are you the author for the Trifecta parsing library?
06:20:59 <edwardk> i am
06:21:52 <{AS}> I am sorry to disturb, but I have recently rewritten the parser for the #idris programming language in Trifecta, and am wondering if you have some time to discuss a small thing
06:22:00 <edwardk> sure
06:22:25 <edwardk> i'm rather open to improving/changing the api in response to user feedback
06:22:32 <{AS}> First of all, it is a very cool library (thanks!)
06:23:29 <{AS}> Secondly, I am wondering if it is possible to somehow change the API such that the parse functions would be more generic than taking Parser as an argument
06:23:55 <edwardk> AS: that part is tricky. i'm guessing you want to use a transformer stack down there?
06:24:10 <{AS}> As I really want to redefine some of the methods of TokenParsing (more concretely, the whitespace and token methods)
06:24:11 <edwardk> if you can come up with a version of them that can work with the stack i'd be happy to take the patch
06:24:42 <edwardk> the usual way i think is to run the parse method and take off the newtype right before running it
06:24:58 <{AS}> Oh, that uses the newtype instance?
06:25:00 <edwardk> parse (removeYourNewType yourparser) ...
06:25:23 <{AS}> actually I am using the state transformer, and it seems to work fine
06:25:26 <edwardk> then the newtype was used during all the calls to someSpace, etc.
06:25:34 <{AS}> Ah cool, thanks!
06:25:43 <edwardk> AS: that works too here, just runState inside the parse call
06:26:06 <{AS}> Yeah, thanks
06:26:28 <{AS}> I didn't now that Haskells type system was so sophisticated
06:28:05 <{AS}> Anyways thanks again!
06:28:08 <{AS}> bye
06:30:58 <Eduard_Munteanu> Hm... I think I found a way to represent identity / non-identity arrows in a promotable datatype... data Category ob hom = Category (Arrow ob ob hom) (Hask hom)     data Arrow s t hom = Id (s -> (t -> hom) -> hom) | NotId (s -> t -> hom)
06:31:09 <srhb> Is there a full gtk2hs floating around somewhere that builds with Cabal 1.18?
06:31:48 <Eduard_Munteanu> I hope that gets me a little more kind-safety.
06:34:30 <applicative> srhb: is this one complete? https://github.com/bgamari/gtk2hs/tree/cabal-1.18
06:36:19 <srhb> applicative: Yes, but it does not build with cabal 1.18, sadly.
06:37:34 <tomejaguar> When I make a cabal package how can I check I have listed all the relevant modules under other-modules?
06:37:39 <tomejaguar> I keep leaving some off by accident
06:37:53 <applicative> srhb: what goes wrong?
06:38:28 * hackagebot clash-lib 0.2.0.1 - CAES Language for Synchronous Hardware - As a Library  http://beta.hackage.haskell.org/package/clash-lib-0.2.0.1 (ChristiaanBaaij)
06:38:37 <bennofs> tomejaguar: I think "cabal check" checks that
06:39:23 <srhb> applicative: http://lpaste.net/93699
06:39:26 <tomejaguar> bennofs: Doesn't seem to.  If I comment out one of the modules it doesn't notice.
06:41:23 <applicative> srhb: are you using --branch cabal-1.18 ? I can install glib both in ~/.cabal and in a sandbox
06:42:52 <srhb> applicative: Oh, no I'm not. Where am I supposed to use that again?
06:43:28 * hackagebot fclabels 2.0 - First class accessor labels implemented as lenses.  http://beta.hackage.haskell.org/package/fclabels-2.0 (SebastiaanVisser)
06:43:33 <notdan> srhb: 'git checkout cabal-1.18' in the gtk2hs cloned directory
06:43:58 <srhb> Ah, I'm a noob then. I thought that github url would fetch me the branch on its own
06:44:03 <applicative> srhb: well, i did git clone https://github.com/bgamari/gtk2hs.git --branch cabal-1.18
06:45:20 <applicative> then i cd'd into gtk2hs ; first i started to install it with bootstrap.sh, then gave up when the glib things built; then i did cabal sandbox init
06:45:29 <applicative> cabal install ./glib ./gio etc etc
06:45:35 <srhb> Thanks, giving that a go now :)
06:46:44 <applicative> the first thing bootstrap.sh makes is a couple of executables, which were'nt rebuilt when I tried the sandbox way. I have a suspicion you want them in ~/.cabal/bin but I'm not sure
06:53:35 <fizruk2> edwardk: checked wrap property for StateT s m (where the property holds for m) http://lpaste.net/93696
06:54:18 <edwardk> fizruk2: the mountain of evidence is becomig quite compelling ;)
06:55:18 <fizruk2> edwardk: was that sarcasm? O_o
06:55:27 <edwardk> quite the opposite
06:55:54 <applicative> oh what's the problem with 'MonadFree'?
06:56:04 <edwardk> i want to run it past dolio to make sure i'm not missing anything, but i'm more or less convinced
06:56:15 <fizruk2> edwardk: ok, I believe that wrap property formalises the intuition of "wrap adds a layer"
06:57:17 <fizruk2> edwardk: I have yet to prove that wrapT follows the property given that wrap does
06:57:20 * applicative was trying to implement wrap for the 'cochurch' encoding of FreeT f the other day
06:57:41 <fizruk2> edwardk: and check its performance
06:57:49 <fizruk2> edwardk: right?
06:58:13 <tomejaguar> What's this wrap thing?
06:58:32 <edwardk> sounds right
06:58:44 <edwardk> wrap is in Control.Monad.Free.Class
06:58:55 <applicative> tomejaguar: MonadFree f m where wrap :: f (m a) -> m a
06:59:06 <applicative> if i remember
06:59:47 <fizruk2> applicative: I think I'm trying to convince edwardk to add wrapT: https://github.com/ekmett/free/pull/18
07:00:01 <applicative> oh let me see
07:00:29 <edwardk> well, if it is correct, then i can take it as a default definition for wrap
07:00:39 <edwardk> using default signatures
07:00:53 <fizruk2> there's poor text I wrote there, though
07:01:41 <mm_freak> is there a library for rational matrices that is capable of computing the (reduced) row echelon form (somewhat efficiently)?
07:01:53 <mm_freak> Double is not an option, i need exact arithmetics
07:02:32 <fizruk2> applicative: here I present properties for wrap and wrapT and prove for several instances the first one: http://lpaste.net/93696
07:02:41 <ocharles> mm_freak: can you use linear with constructive reals or something?
07:02:59 <ocharles> linear is polymorphic over element type
07:03:14 <ocharles> i think you my have to write the row echelon form yourself though
07:03:42 <mm_freak> ocharles: Rational is sufficient, and linear doesn't support echelon/determinant algorithms
07:03:52 <mm_freak> well it does support the latter, but only for small matrices
07:04:07 <ocharles> i see
07:04:42 <mm_freak> i guess i'll have to write this myself
07:06:56 <luite> mm_freak: it will have exponential time/space worst case complexity
07:07:01 <applicative> fizruk2: I see, the trouble is, how does wrap/MonadFree interact with a transformer
07:07:09 <mm_freak> luite: "it"?
07:07:16 <luite> mm_freak: your algorithm
07:07:35 <mm_freak> why?  the gauss algorithm seems to be O(n^2)
07:08:11 <luite> only if you count the number of elementary operations, but exact rational representations can grow exponentially
07:08:58 <fizruk2> applicative: wrapT could be the default implementation for MonadFree f (t m) given MonadFree f m
07:09:02 <mm_freak> luite: i'll apply some additional knowledge along the way to keep the numbers small
07:09:13 <fizruk2> applicative: if that what you've meant
07:09:15 <mm_freak> in fact it will probably only work on Integer
07:15:32 <applicative> fizruk2: so all the separate instances like instance (Functor f, MonadFree f m) => MonadFree f (ReaderT e m) where
07:15:40 <applicative> would be unnecessary?
07:15:54 <fizruk2> applicative: not exactly
07:16:39 <fizruk2> applicative: those instances should be faster than wrapT (I don't yet know in what sense)
07:17:11 <Dakk> Hey, i need some help with lists!
07:17:30 <applicative> Dakk: what help do you need with lists?
07:17:43 <chrisdone> Dakk: please list your problems =p
07:18:00 <chrisdone> so… irccloud has died =)
07:18:06 <chrisdone> so much for being a cloud
07:18:19 <Dakk> chrisdone
07:18:19 <Dakk> so
07:18:21 <applicative> i was thinking something was wrong with the weather
07:18:28 <Dakk> let's say i got a list wich contains 9 lists
07:18:33 <ski> probably it hit the ground, and is now evaporating mist
07:18:39 <Dakk> what is the easiest way to split them into three lists that each contain three lists?
07:18:44 * hackagebot haste-compiler 0.2.6 - Haskell To ECMAScript compiler  http://beta.hackage.haskell.org/package/haste-compiler-0.2.6 (AntonEkblad)
07:19:42 <ocharles> Dakk: http://hackage.haskell.org/package/split-0.2.2/docs/Data-List-Split.html#v:chunksOf
07:19:54 <applicative> well, if you can find a general way to group a list into sublists of length three, then you can use that and then map concatenate
07:19:59 <Dakk> Thanks! Will look into
07:20:15 <applicative> chunksOf does the first of these
07:20:23 <applicative> oh wait, no it just does, it
07:20:28 <applicative> does it, rather
07:21:01 * ocharles pats applicative 
07:22:01 <Dakk> Cannot find chunksof
07:22:08 <Dakk> not in scope, and yes, i imported Data.List
07:22:15 <applicative> Data.List.Split
07:22:20 <applicative> chunksOf
07:22:29 <alpounet> it's in the "split" library
07:22:32 <applicative> or did it get renamed or something
07:22:39 <applicative> split comes with the haskell platform
07:23:07 <ocharles> Dakk: read what I linked you to
07:23:11 <applicative> Dakk: in ghci see if 'import Data.List.Split' does anything
07:23:15 <ocharles> slow down a bit
07:23:30 <applicative> no speed up Dakk!
07:24:16 <Dakk> applicative it does not
07:24:55 <fizruk2> edwardk: added proof of wrapT property through wrap: http://lpaste.net/93696
07:26:19 <applicative> Dakk: 'cabal install split' should give it to you
07:26:52 <fizruk2> edwardk: do I need to replicate those in the pull request?
07:27:46 <edwardk> fizruk2: so long as i have them i'm pretty happy to run with them
07:28:40 <fizruk2> edwardk: sorry, failed to parse that one
07:28:58 <fizruk2> edwardk: you mean "yes, replicate them, please"?
07:29:18 <edwardk> i mean even if you just linked to the lpaste in the pull request issue that'd be fine
07:29:32 <fizruk2> oh, ok, I'll do that
07:30:23 <applicative> Dakk, i'm assuming you have the 'cabal' executable. Of course, you could try to implement chunksOf ;)
07:32:18 <quicksilver> chunksOf n = takeWhile(not.null).map(take n).iterate(drop n)
07:33:31 <ocharles> nice
07:34:15 <applicative> yes
07:34:17 <ocharles> i wonder what the complexity of that is
07:34:54 <quchen> n*m where m = length(list)?
07:36:05 <applicative> i guess the implementation in split is more or less that, but gussied up to use 'build'
07:36:21 <peteretep> I make it 700L on the Lexile Scale
07:38:02 <Maior> wooo my copy of RWH arrived
07:38:42 <Sculptor> yo
07:38:44 <ocharles> Maior: high five!
07:38:46 <ocharles> enjoy :)
07:38:57 <fizruk2> edwardk: to fully justify the property, I should prove it for ContT m, right?
07:39:42 <applicative> fizruk2: no, use it to show that ContT is not a valid transformer, please
07:40:46 <applicative> ocharles: did you see this amusing compiler panic with 'hoist' http://ghc.haskell.org/trac/ghc/ticket/7887
07:40:51 <fizruk2> applicative: sorry, I can't tell if that's a joke, so I must ask directly :( is that a joke?
07:41:11 <applicative> fizruk2: just kidding
07:41:44 <applicative> i was thinking 'then i wont have to worry about ContT any more'...
07:42:22 <ocharles> applicative: impressive
07:42:41 <fizruk2> applicative: ok)
07:42:53 <monoidal> the problem is more with "lift" in 7.6 than "hoist".
07:42:58 <applicative> oh is it
07:43:11 <monoidal> e.g. lift anything anything panicks
07:44:06 <fizruk2> edwardk: if the property turns out to be true, I propose to include it in MonadFree description
07:44:10 <applicative> oh, I lept to the conclusion that the rank2ness of hoist was in there somewhere
07:44:33 <monoidal> the problem is with kinds, not rank-2 types
07:44:50 <applicative> yeah, the error makes that clear
07:46:13 <fizruk2> why can't I take a look at ContT implementation from haddock? http://hackage.haskell.org/package/mtl-2.1.2/docs/Control-Monad-Cont.html#t:ContT
07:46:29 <fizruk2> the same issue with other transformers, actually
07:46:34 <applicative> or i guess this isn't error, more a cry of desperation: kindFunResult
07:46:44 <applicative> <<details unavailable>><<details unavailable>>
07:47:01 <chrisdone> i think because it comes from another library
07:47:29 <chrisdone> http://hackage.haskell.org/package/transformers-0.1.4.0/docs/Control-Monad-Trans-Cont.html
07:48:13 * chrisdone seems to spend his days noticing things that suck about haddock
07:48:18 <fizruk2> chrisdone: I thought it was possible for haddock to redirect to another package
07:48:52 * hackagebot haste-compiler 0.2.7 - Haskell To ECMAScript compiler  http://beta.hackage.haskell.org/package/haste-compiler-0.2.7 (AntonEkblad)
07:49:06 <monoidal> applicative: <details unavailable> is also fixed in head, panicks now give more information
07:49:25 <applicative> monoidal: oh, how can I produce one ;) ?
07:49:26 <monoidal> applicative: (if I remember correctly, compiling via ghc, not ghci, might give the details.)
07:51:05 <applicative> yes if i compile i get 	kindFunResult ghc-prim:GHC.Prim.*{(w) tc 34d}
07:52:15 <sdx23> hi, is there an elegant way to strip lists of alternating types from another list? I got a function like "function a1:b1:a2:b2:xs = anotherfunc a1 b1 a2 b2 xs"
07:53:10 <ski> i'm not sure what you mean by "strip lists of alternating types from another list"
07:53:42 <peteretep> sdx23: What would be the typedef of your function?
07:53:47 <ski> also note that `function a1:b1:a2:b2:xs = anotherfunc a1 b1 a2 b2 xs' will be parsed as `(function a1):b1:a2:b2:xs = anotherfunc a1 b1 a2 b2 xs'
07:53:57 <ski> perhaps you intended `function (a1:b1:a2:b2:xs) = anotherfunc a1 b1 a2 b2 xs' ?
07:54:11 <sdx23> ski: ah, yes. sorry for that.
07:55:07 <sdx23> peteretep: function :: [m] -> [m], where a and b are subtypes(?) of m
07:55:26 <ski> Haskell has no subtyping
07:55:43 <sdx23> I'm not sure how it's called, therefore the (?)
07:55:43 <ski> (also, you didn't mention `a' and `b' in that type signature)
07:56:07 <monoidal> sdx: do you mean a,b are *values* of type m?
07:56:08 <ski> in Haskell, in any given list, every element has to have the same type
07:56:09 <peteretep> M = A x | Bx?
07:56:15 <applicative> @type partitionEithers
07:56:16 <lambdabot> [Either a b] -> ([a], [b])
07:56:36 <ski> lists are sometimes called "homogenous" to stress on this property
07:56:44 <applicative> > partitionEithers [Left "hi", Right 12, Right 1, Left "ho"]
07:56:44 <lambdabot>   (["hi","ho"],[12,1])
07:56:55 <sdx23> monoidal: nay. More concrete: m is data Inline as defined in Text.Pandoc.Definition
07:57:32 <applicative> sdx23: yes a [Inline] is list of things of a single type
07:57:51 <applicative> if you want to get rid of some, you can e.g. pattern match
07:57:57 <sdx23> applicative: so what's the name for Str, Emph, Strong and so one?
07:58:26 <quicksilver> constructors, sdx23
07:58:45 <applicative> sdx23: they are constructors of an Inline, different forms of Inline thing
07:58:46 <ski> specifically, *data* constructors
07:58:56 <sdx23> applicative: yeah, I'm doing pattern matching right now, but it's ugly if I'm searching repeated combinations like: (Str:Space:Str:Space:xs)
07:58:57 <applicative> data constructors, indeed, as we say
07:59:09 <ski> data cosntructors belong on the value level of the language. the type level is separate from this
07:59:21 <applicative> sdx23: are you trying to convert one kind of Inline to another? or elimate some?
07:59:22 <stelleg> @src concat
07:59:23 <lambdabot> concat = foldr (++) []
07:59:55 <ski> sdx23 : perhaps you could paste the current code you have which you think is ugly, and perhaps we could try to suggest alternatives ?
07:59:58 <ski> @paste
07:59:58 <lambdabot> Haskell pastebin: http://lpaste.net/
08:00:03 <sdx23> applicative: eleminatate certion combinations.
08:00:11 <sdx23> ski: yeah, just a moment.
08:00:55 <sdx23> http://pastebin.com/SwuT4jcV there you go
08:01:02 <mauke> The paste SwuT4jcV has been copied to http://lpaste.net/93702
08:02:06 <chrisdone> i'm loving all the threepenny success stories
08:02:18 * quicksilver doesn't find that ugly (sdx23's paste)
08:03:04 <sdx23> the embed_n_img should ideally be more like "embedimg n i t xs" embedimg:: Int -> Image -> [Inline] -> [Inline]
08:03:06 <ski> sdx23 : i would replace `(Image i1 t1)' with plain `Image i1 t1' (and similarly in the other places)
08:03:39 <quicksilver> sure, perhaps you want
08:03:48 <sdx23> quicksilver: so it's just ok the way it is?
08:04:00 <ski> sdx23 : btw, you forgot to paste `embed1img',embed2img',`embed3img'. try *annotating* the paste with those ?
08:04:02 <quicksilver> embedimg [(i1,t1)] xs and embedimg [(i1,t1),(i2,t2),(i3,t3)] xs
08:04:05 <sdx23> ski: ok. And for the concept? Is there some other way to do it?
08:04:22 <quicksilver> but without the source of embedNimg we don't know if they're uniform or entirely different ;)
08:04:24 <ski> sdx23 : iow, the <http://lpaste.net/93702> paste
08:05:06 <sdx23> quicksilver: they will be uniform, more or less. Same handling of every Image + some header / footer.
08:05:30 <fizruk2> edwardk: interesting thing is that proof for ContT does not use property of the inner monad... https://github.com/ekmett/free/pull/18#issuecomment-25457264
08:05:30 * ski awaits sdx23's annotation of <http://lpaste.net/93702>
08:05:58 <ski> fizruk2 : i haven't been following, but i'm not really surprised to hear
08:06:19 <fizruk2> ski: can you tell why?
08:06:57 <fizruk2> ski: the same proof for StateT needed that property holds for the inner monad
08:06:58 <sdx23> ski: I haven't implemented embedimg up to now. It's type is  embed1img :: [Inline] -> Target -> [Inline] -> [Inline]
08:08:07 <ski> sdx23 : if we see your implementations of `embed1img',embed2img',`embed3img', we could perhaps suggest ways of removing code duplication, leading to (hopefully) nicer code
08:08:35 <fizruk2> ski: if my intuition that StateT is "just one example of" ContT, I'd expect them to act similarly (both need or both needn't)
08:08:50 <applicative> sdx23: but you don't anticipate being able to write embedAll :: [([Inline],Target)] -> [Inline] or something
08:09:34 <ski> fizruk2 : well, just noting that `instance Monad (ContT o m)' doesn't need `Monad m' (and iirc, similar behaviour also in some other cases with `ContT') -- i haven't grasped exactly what your `wrap' and `wrapT' are after
08:09:35 <sdx23> ski: ok, i may come back with that later on.
08:10:20 <ski> sdx23 : as far as `beimage' goes for the moment, we can't tell whether one can condense more, since it depends on those `embed1img',`embed2img',`embed3img'
08:10:20 <applicative> sdx23: are you expecting these sequences of images to be anywhere or just at top level paragraphs or something?
08:10:52 <sdx23> applicative: yeah, this is a good proposal, but can I pattern match in this way as well? Like: beimage ([([Inline],Target)]:xs) = embedall... =
08:11:30 <ski> sdx23 : btw, one question. would you like to also handle interspersals of more images with space than three images ?
08:11:32 <fizruk2> ski: that's an interesting property! wrap is the only method of MonadFree class
08:11:40 <sdx23> applicative: anywhere. Even better were to get that Space optional.
08:11:40 <applicative> sdx23: no, I was thinking of extracting images from the list, preserving the remains, and then putting them together but we don't know what you;re doing with the images
08:12:20 <sdx23> ski: I'm not sure about that. It may be nice, even though 3 would be enough for the beginning.
08:12:34 <fizruk2> ski: so the Monad m contraint for the Monad (ContT m) is there to ensure that monad laws do hold?
08:13:03 <ski> fizruk2 : however, note that `evalContT :: Monad m => ContT o m o -> m o' needs `Monad m' -- so in a sense the application of `Monad m' is delayed (compare with `CoDensity' monad, and similar behaviour for `Yoneda' and `CoYoneda' re `Functor')
08:13:07 <applicative> sdx23: what kind of thing to you mean to do with the image data you extract?
08:13:08 <FreeFull> fizruk2: Monad transformers can only be applied to monads, anything else just doesn't make sense
08:13:39 <sdx23> applicative: adding frames before and after, as well as captions.
08:13:53 <sdx23> applicative: in html that is.
08:13:54 * hackagebot wai-routes 0.3.4 - Typesafe URLs for Wai applications.  http://beta.hackage.haskell.org/package/wai-routes-0.3.4 (AnupamJain)
08:14:01 <fizruk2> FreeFull: "sense" being monad laws, right?
08:14:14 <applicative> sdx23: so you will be inserting RawHtml or whatever into the list?
08:14:42 <sdx23> applicative: yes, even though I guess this not the best way to do it.
08:14:46 <applicative> RawInline
08:16:13 <ski> fizruk2 : hm ? i see only see `instance Monad (ContT r m)'
08:17:08 <ski> FreeFull : "Monad transformers can only be applied to monads, anything else just doesn't make sense" -- hmm
08:17:44 <fizruk2> ski: I was staring at the old code, nevermind
08:18:06 <ski> @unmtl ContT o IORef a
08:18:07 <lambdabot> (a -> IORef o) -> IORef o
08:18:12 <ski> probably not useful
08:18:27 <ski> @unmtl ContT o (CoYoneda IORef) a
08:18:28 <lambdabot> (a -> (CoYoneda IORef) o) -> (CoYoneda IORef) o
08:18:30 <ski> perhaps
08:20:03 <quicksilver> well certainly if you believe they are 'monad transformers' that is a tautology.
08:20:06 <quicksilver> ContT is a monad creator though.
08:20:23 <applicative> sdx23: the last line should probably be: beimage (x:xs) = x : beimage xs; then also beimage [] = []
08:21:15 <applicative> then embed3image a b c d e f should just make an Inline (eg with RawInline) or else a [Inline]
08:21:37 <applicative> sdx23: then the first line should be .... = embed3img a b c d e f : xs or
08:21:58 <dmj`> @unmtl ErrorT String (ReaderT Int (StateT Int IO)) ()
08:21:58 <lambdabot> (ReaderT Int (StateT Int IO)) (Either String ())
08:22:05 <applicative> sdx23: embed3img ++ xs if you make a list of inlines out of the material
08:23:02 <sdx23> applicative: ah, thanks very much, i'd have just appended xs within embedimg, but yours does make more sense.
08:23:48 <sdx23> ok, so i'll be using all your suggestions and implement embedimg as well, then paste again. Thanks to all of you so far.
08:24:18 <applicative> so it would look like this http://lpaste.net/6512662445129990144
08:25:03 <applicative> it moves through the [Inline] (e.g. the paragraph) and when it comes on clump of images of one length or another, gathers it and does what it does, then it continues with the rest of the paragraph
08:25:34 <applicative> this will e.g. allow a long paragraph to have a couple of image-clumps
08:26:44 <sdx23> applicative: nice, this is exactly what I wanted.
08:28:56 * hackagebot simple-sessions 0.1.2 - A simple implementation of session types  http://beta.hackage.haskell.org/package/simple-sessions-0.1.2 (JesseTov)
08:31:17 <ski> sdx23 : it would be possible to check for any interspersal of images and spaces, stuff the images into a list, pas it to an `embedImgs' function, appending the `beimage' translation of the rest of the input
08:36:28 <applicative> ski sdx23 it might be conceptually simplest to normalize the [Inline] first, if you anticipate other patterns, making sure each Image a b comes just before one space, or eliminating spaces between and immediately after an image
08:39:01 <sdx23> http://lpaste.net/92381684225277952 well, this might fail for Image:Image:Space:Image - and I need to think of "inl" again, this needs to be converted to an html string first.
08:39:32 <sdx23> applicative: aye, this would then eleminate the problem I just mentioned, yes?
08:40:02 <sdx23> ski: I did not quite understand that.
08:41:46 <ski> sdx23 : `embedImgs :: [([Inline],Target)] -> Inline' or maybe `embedImgs :: [([Inline],Target)] -> [Inline]'
08:43:09 <ski> your current `embed1img i1 t1',`embed2img i1 t1 i2 t2',`embed3img i1 t1 i2 t2 i3 t3' would then correspond to `embedImgs [(i1,t1)]',`embedImgs [(i1,t1),(i2,t2)]',`embedImgs [(i1,t1),(i2,t2),(i3,t3)]', respectively
08:43:38 <ski> (but then you wouldn't write such code thrice, you'd only write it once)
08:44:00 <sdx23> that's what i did in the new paste, isn't it?
08:44:22 <ski> oh, didn't notice your new paste
08:44:27 <sdx23> not quite in that form, but i tried to build on that idead.
08:46:12 <ski> `embedimg is = header : map htmlimage is : footer' should probably be `embedimg is = header : map htmlimage is ++ [footer]' or `embedimg is = [header] ++ map htmlimage is ++ [footer]'
08:46:25 <applicative> ah the pasted one doesn't type check. it's trying something too clever
08:46:31 <ski> although ..
08:47:05 <ski> i don't see any type `Image' at <http://hackage.haskell.org/package/pandoc-types-1.12.2.1/docs/Text-Pandoc-Definition.html>
08:47:14 <sdx23> ski: ah, no appending to lists with : ?
08:47:32 <Jookia> Hello. With QuickCheck, say I have a list of file paths, and I'd like a bunch of them to be selected randomly. listOf . elements doesn't work because listOf has duplicates, and it's kind of illogical to test with duplicate file paths (this doesn't really happen in real life)
08:47:39 <geekosaur> do you understand what (:) does?
08:47:39 <ski> `:' is for prepending a *single* element to a list
08:47:44 <ski> `++' is list concatenation
08:47:52 <sdx23> ski: it's typeconstructor for Inline.
08:48:02 <sdx23> geekosaur, ski: ah, i see.
08:48:10 <ski> (and `a : b : c' means `a : (b : c)', so if `a' and `b' are elements of some type, then `c' is a *list* of elements of that type)
08:48:39 <ski> so, `embedimg :: [([Inline],Target)] -> [Inline]', i think
08:48:58 <ski> and your patterns `Image i' should be `Image i t'
08:48:59 * hackagebot trifecta 1.2.1 - A modern parser combinator library with convenient diagnostics  http://beta.hackage.haskell.org/package/trifecta-1.2.1 (EdwardKmett)
08:49:12 <ski> and `embedimg [i]' should then be `embedimg [(i,t)]'
08:49:22 <ski> (just fixing the type errors, so far)
08:50:04 <mee> ah
08:50:07 <ski>   htmlimage :: ([Inline],Target) -> Inline
08:50:14 <ski> .. though if you really want to, you could say
08:50:22 <ski>   type Image = ([Inline],Target)
08:50:33 <ski> and then use `Image' in type signatures as you did already
08:51:01 <sdx23> ski: and I can't simple let the list be as is in embedimg?
08:51:23 <quicksilver> ski: did you mention the i1@(Image _ _) approach?
08:51:39 <ski> sdx23 : also, you forgot to call `beimage' recursively in two cases
08:51:46 <ski> quicksilver : i considered it, but didn't mention it
08:51:57 * ski would like refinement types :/
08:51:59 <quicksilver> the fact that individual constructors aren't actually types is often frustrating to newbies
08:52:03 <quicksilver> and oldbies.
08:52:13 <sdx23> ski: single-element and no element case, ok.
08:52:39 <ski> sdx23 : no, i was talking about the first two definition equations
08:54:41 <sdx23> ski: hu? so withing beimage and not the definition of embedimage?
08:55:27 <ski> well, why would you want `embedimg' to be mutually recursive with `beimage' ?
08:55:47 <Shin-LaC> In the first versions of Haskell, the comprehension syntax was available for all monads. (See History of Haskell) Later the comprehension syntax was restricted to lists.
08:55:50 <Shin-LaC> why was this done?
08:56:10 <ski> if we're assuming you don't want that. i don't see how to interpret "you forgot to call `beimage' recursively in two cases" apart from two recursive calls *in* `beimage' missing
08:57:06 <ski> Shin-LaC : iirc, it was thought to be simpler for newbies, and they wanted to restrict the language (in the standard) to a "safe starting point" from which then further explorations of extensions could be made
08:57:23 <ski> preflex: xseen augustss
08:57:23 <preflex>  augustss was last seen on freenode/#haskell 9 days, 12 hours, 29 minutes and 23 seconds ago, saying: FreeFull: Well, that's because you made an error. :)
08:57:30 <Shin-LaC> hm, I see
08:58:02 <ski> (similarly for `map :: Functor f => (a -> b) -> (f a -> f b)' and some other cases)
08:59:00 * hackagebot integration 0.2.0.1 - Fast robust numeric integration via tanh-sinh quadrature  http://beta.hackage.haskell.org/package/integration-0.2.0.1 (EdwardKmett)
09:03:24 <donri> Shin-LaC: note that there's MonadComprehensions in ghc these days
09:04:58 <Shin-LaC> ah
09:05:34 <tom39341> Is there a ghc flag that will cause warnings when 'undefined' and 'error' is used?
09:06:55 <donri> tom39341: nope. you can replace them in your own usage with ones that do warn though
09:07:29 <monoidal> tom39341: you can use holes (for head) instead of undefined/error for "todo"
09:09:16 <Shin-LaC> is there an editor that compiles haskell code and highlights errors in real time like java IDEs do?
09:09:49 <alpounet> emacs with haskell-mode / ghc-mod I think
09:09:52 <donri> Shin-LaC: vim with syntastic; emacs with flycheck; probably sublime and eclipsefp too
09:10:15 <chrisdone> Shin-LaC: the fp complete ide does it out of the box
09:10:37 <bartavelle> the ghc-mod option is not really real-time though, and doesn't work at all with programs that do not compile
09:10:47 <Shin-LaC> ah
09:11:03 <Shin-LaC> thanks, I'll check those out
09:11:33 * ion sees the FPComplete IDE pricing – whoa!
09:11:42 <chrisdone> Shin-LaC: https://www.youtube.com/watch?v=ZHSBwlm5C8U
09:11:49 <bartavelle> I suppose one of the goals of the fpcomplete IDE is to get there
09:11:59 <chrisdone> ion: the personal edition is something like 10 bucks a month
09:12:33 <bearclaw> jedit doesn't have realtime, but it has facilities to run the compiler, parse errors and highlight lines, including marks  in the scrollbar
09:12:44 <chrisdone> ion: that'll be available in october. but the free trials are available now, so you can start using now and then in october grab the personal edition
09:13:33 <Shin-LaC> what platforms does it run on?
09:14:04 <Shin-LaC> oh wait, it's browser-based?
09:14:12 <chrisdone> Shin-LaC: it runs in the browser, so technically any. we're also providing an API for using it from external editors, like emacs, vim, sublime
09:14:45 <Shin-LaC> I'm looking for a local option
09:15:18 <ion> chrisdone: Ok, that’s not a “whoa!”, but alas, too much for me to switch from vim/emacs, no matter how much better it may be for Haskell development.
09:15:19 <Shin-LaC> let's see what sublime can do
09:15:35 <chrisdone> ion: you don't have to switch from vim/emacs =)
09:16:31 <Shin-LaC> oh, I should have just checked the wiki
09:16:34 <chrisdone> ion: in our development version we have drivers for flycheck.el for live checking, and auto-complete.el for complete-as-you-type and goto-definition, hoogle
09:16:43 <ion> chrisdone: s/from .*//
09:16:56 <chrisdone> ion: hm?
09:20:46 <ion> chrisdone: I mean, that’s unfortunately too much for me. The unfounded assumption about switching wasn’t the point. But i’m of course not representative of the majority of Haskellers. :-)
09:23:30 <chrisdone> ion: yeah, general feedback is that people like the price
09:23:54 <ion> alright
09:24:39 <chrisdone> i should probably write this up on the wiki page about ides otherwise it'll start to sound markety
09:26:05 <chrisdone> what heappened to the wiki layout, heh?
09:26:08 <stelleg> @src filter
09:26:08 <lambdabot> filter _ []     = []
09:26:09 <lambdabot> filter p (x:xs)
09:26:09 <lambdabot>     | p x       = x : filter p xs
09:26:09 <lambdabot>     | otherwise = filter p xs
09:27:39 <FreeFull> What's my best bet for making TUIs with Haskell? vty-ui ?
09:28:05 <lispy> FreeFull: I have no personal experience here, but I have heard good things about vty-ui
09:28:22 <FreeFull> I just want something simple that would let me make a program that looks like irssi
09:28:44 <FreeFull> Well, not too strictly like irssi, just somewhat
09:28:51 <FreeFull> I am working on a chat client
09:31:04 <lispy> FreeFull: there is also an ncurses binding and vty
09:31:29 <lispy> FreeFull: I think vty-ui has a pretty extensive manual and lets you specify the gui using xml?
09:33:00 <shachaf> copumpkin: Yay, Simon Marlow is proposing the Applicative translation that I mentioned a while ago.
09:33:06 <lispy> FreeFull: http://codevine.org/vty-ui/vty-ui-users-manual-1.4.pdf
09:33:37 <elliott> which Applicative translation?
09:34:35 <shachaf> E.g. do { x <- A; y <- B; f x y } into join (f <$> A <*> B)
09:35:58 <elliott> ugh.
09:38:06 <FreeFull> lispy: You are saying that as if xml was a good thing
09:38:41 <lispy> FreeFull: it allows your ui to be skinnable, IIRC
09:39:24 <ion> shachaf: And do { x <- A; y <- B; pure (f x y) } into just f <$> A <*> B?
09:39:30 <Eduard_Munteanu> Is this a known thing?   type Compose a b b' c = (b' -> c) -> (a -> b) -> (a -> c)    data IfEquals a b r = IfEquals { unIE :: (forall i. Compose i a b r) -> r }    mkIfEquals r = IfEquals (const r)
09:39:48 <lispy> FreeFull: and I may be mistaken, I just searched the manual for XML and I couldn't find it
09:40:05 <Eduard_Munteanu> To get the 'r' out, you write something like   unIE foo (.)
09:40:15 <ion> shachaf: Also, link please.
09:40:25 <chrisdone> shachaf: what's the use-case for that? it seems like having to name the results of A and B is more verbose than regular applicative, so i presume it's not for concision
09:40:45 <FreeFull> I am wondering if vty-ui would be overkill
09:42:31 <chrisdone> reminds me of the old
09:42:31 <chrisdone> yo = do A
09:42:31 <chrisdone>         B
09:42:31 <chrisdone>         pure (,)
09:42:35 <chrisdone>   where (>>) = flip (<*>)
09:42:36 <Eduard_Munteanu> Basically it's a kind-promotable Eq, since you can't promote the GADT one.
09:43:14 <chrisdone> well, the A and B would have to be in reverse order, but ja
09:43:25 <haasn> What's ‘the’ way to invoke a shell command? I want to run ("sendmail -oi " ++ unwords ps) and feed a String to its STDIN
09:43:29 <haasn> And return its exit code
09:43:48 <chrisdone> you'll  find what you need in System.Process
09:44:02 <Eduard_Munteanu> haasn: are you sure you want a shell command, or does calling sendmail with some args work for you?
09:44:05 * hackagebot threefish 0.2.1 - The Threefish block cipher and the Skein hash function for Haskell.  http://beta.hackage.haskell.org/package/threefish-0.2.1 (AntonEkblad)
09:44:11 <haasn> Eduard_Munteanu: the latter
09:44:30 <applicative> ion chrisdone marlowe seems to have begun with simpler promises http://www.reddit.com/r/haskell/comments/1le4y5/the_haxl_project_at_facebook_slides_from_my_talk/cbykooc?context=3
09:44:31 <ion> chrisdone: If it refrains from adding a join when it’s not necessary, that could reduce the constraint of the expression to Applicative or Functor. Also, giving names to the values drawn from A and B may or may not be a good thing.
09:44:36 <haasn> chrisdone: thanks, I can work with that
09:44:41 <Eduard_Munteanu> haasn: ah, look in System.Process... and use the non-shell functions, they're safer.
09:44:52 <ion> applicative: thanks
09:47:37 <n-dolio> chrisdone: do x <- m ; y <- n ; z <- o ; return $ x * y + z^x
09:47:57 <chrisdone> applicative: ahh, it's for optimization
09:49:06 * hackagebot threefish 0.2.2 - The Threefish block cipher and the Skein hash function for Haskell.  http://beta.hackage.haskell.org/package/threefish-0.2.2 (AntonEkblad)
09:49:13 * ion can’t help imagining one of the “Other back-end services” nodes in the graph having “NSA” written on it.
09:50:11 <ion> says he on IRC transmitted in cleartext through wiretapped Internet backbone.
09:53:02 <applicative> chrisdone: i guess if join and <*> are written correctly, it might come to the same in the essentially monadic cases, but admit optimization in the <*> only cases?
09:53:47 <haasn> What's ‘the’ way to get :: String -> (IO) Handle -- ?
09:54:06 * hackagebot threefish 0.2.3 - The Threefish block cipher and the Skein hash function for Haskell.  http://beta.hackage.haskell.org/package/threefish-0.2.3 (AntonEkblad)
09:54:18 <applicative> openHandle str ReadMode? ;)
09:54:26 <elliott> shachaf: that desugarting is going to be awful for pure = return; (<*>) = ap instances
09:54:54 <ion> “so don’t do that” hth
09:54:55 <haasn> applicative: no, no, that would be :: FilePath -> IO Handle  :P
09:55:17 * applicative wasn't making the String FilePath distinction
09:55:29 <applicative> writeFile :: FilePath -> FilePath -> IO ()
09:55:44 <ion> hah
09:56:03 <applicative> elliott: do you see a definite proposal?
09:56:16 <ion> type FilePath' = IO ()
09:59:07 * hackagebot threefish 0.2.4 - The Threefish block cipher and the Skein hash function for Haskell.  http://beta.hackage.haskell.org/package/threefish-0.2.4 (AntonEkblad)
10:00:04 <elliott> applicative: I saw <shachaf> E.g. do { x <- A; y <- B; f x y } into join (f <$> A <*> B)
10:00:12 <elliott> maybe it would get inlined away though.
10:01:04 <applicative> elliott: oh, yes, I was assuming there was a definite strategy in mind
10:01:17 <Shin-LaC> I'm trying sublimehaskell, but it doesn't seem to do much of anything
10:01:27 <Shin-LaC> I know there are errors in this code, yet it's not showing them
10:02:10 <shachaf> elliott: Post to the list!
10:06:20 <applicative> i see simonmar's new page http://ghc.haskell.org/trac/ghc/wiki/ApplicativeDo
10:08:12 <applicative> i see, as he is writing it, it would secretly be aware of the literal use of the word 'return' or 'pure'
10:08:31 <elliott> "Sometimes this is really important, such as when the Applicative bind is concurrent whereas the Monad bind is sequential" I hope this doesn't involve changing semantics :/
10:12:29 <applicative> elliott: he discusses the Haxl type in his slides; i'm not seeing how the Applicative instance is the same as ap but maybe ...
10:12:38 <stelleg> @src foldr
10:12:38 <lambdabot> foldr f z []     = z
10:12:38 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:13:24 <applicative> newtype Haxl a = Haxl (IO (Either a (Haxl a))) sort of
10:13:55 <stelleg> @src (++)
10:13:55 <lambdabot> []     ++ ys = ys
10:13:55 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
10:13:55 <lambdabot> -- OR
10:13:55 <lambdabot> xs ++ ys = foldr (:) ys xs
10:14:21 <applicative> yes, this is not <*> = ap
10:14:40 <applicative> though what that means when we are buried in IO I dont know
10:14:55 <elliott> it would just be an "optimisation" if Haxl computations always terminate
10:15:01 <elliott> and never interact
10:15:09 <elliott> so concurrency is a mere optimisation
10:15:13 <elliott> but I somehow doubt that's the case...
10:17:07 <FreeFull> > take 1 ([3] ++ undefined)
10:17:08 <lambdabot>   [3]
10:17:15 <saml> is scotty good?
10:17:55 <Sculptor> yes but not as good as micheal
10:18:20 <saml> micheal cray
10:18:32 <Sculptor> michael jordan/scotty pipen
10:18:55 <saml> whoa
10:18:59 <saml> let me try if i can use haskell
10:26:46 <applicative> i guess in the going version of the Functor/Applicative/Monad proposal 'ap' is a method of Monad with the usual definition as a default?
10:28:41 <applicative> as it stands his reason for doing this seems to be to get around the constraint "If f is also a Monad, it should satisfy pure = return and (<*>) = ap " if ap is taken as defined in Control.Monad
10:29:10 * hackagebot skein 1.0.8 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://beta.hackage.haskell.org/package/skein-1.0.8 (FelipeLessa)
10:31:53 <Frederick1830> I have several expressions of the form:  _1 .~ ((1,2) ^. _1) $ (4,5)   and  _2 .~ ((1,2) ^. _2) $ (4,5).
10:32:29 <Frederick1830> And now I want to abstract over the Lens:  \lens -> lens .~ ((1,2) ^. lens) $ (4,5) ,which gives me an error. How can I do this?
10:32:59 <Frederick1830> (I am using Control.Lens btw)
10:33:02 <elliott> e.g. you can use (cloneLens lens) instead
10:33:20 <elliott> \lens -> let l = cloneLens lens in l .~ ((1,2) ^. l) $ (4,5)
10:33:26 <elliott> maybe you need a type signature on that l though...
10:34:42 <Frederick1830> elliot: WOW
10:36:08 <applicative> it is clear that Marlow is proposing something that would permit the applicative instance for IO to be runConcurrently (($) <$> Concurrently ff <*> Concurrently fx) , using this also I guess to implement 'ap'
10:36:20 <Frederick1830> elliot: Ups. No! still gives an error: Couldn't match type `Mutator t1' with `Accessor t1 t1'
10:37:29 <applicative> no that was slightly mixed up it should be fmap ($) (concurrently iof iox)
10:38:03 <chrisdone> ohh
10:38:08 <elliott> Frederick1830: hmph, then yeah, you need a type signature on l. or else just say cloneLens lens instead of lens as arguments to both of the operators.
10:38:19 <elliott> that's slightly slower or something if it doesn't get inlined but who cares.
10:38:20 <applicative> or equivalently,  runConcurrently ( Concurrently ff <*> Concurrently fx)
10:38:55 <Frederick1830> elliott: This gives me the same error:  (\y  -> y .~ ((1,2) ^. y) $ (4,5) ) $ cloneLens _2
10:39:51 <elliott> Frederick1830: as in (l -> cloneLens l .~ ((1,2) ^. l) $ (4,5))
10:39:54 <elliott> *\l ->
10:40:01 <elliott> er.
10:40:09 <elliott> Frederick1830: as in (\l -> cloneLens l .~ ((1,2) ^. cloneLens l) $ (4,5))
10:40:15 * applicative anticipates that Marlow will burst into tears when he figures this all out....
10:40:30 <Frederick1830> elliott: yes this works!
10:44:09 <S_J> > Left 6 >>= return . (+1)
10:44:11 <lambdabot>   Left 6
10:44:16 <S_J> > Right 6 >>= return . (+1)
10:44:17 <lambdabot>   Right 7
10:45:43 <Frederick1830> elliott: alternative  (\y  -> y #~ ((1,2) ^# y) $ (4,5) )  _2
10:45:46 <FreeFull> Left is like Nothing but with a parameter
10:45:54 <FreeFull> > Left 'a' >>= return . (+1)
10:45:55 <lambdabot>   Left 'a'
10:46:44 <FreeFull> The type system ensures that any Left value can't be changed monadically
10:48:40 <applicative> It occurs to me that if 'ap' is a method of Monad, then the sacred text "If f is also a Monad, it should satisfy pure = return and (<*>) = ap" can be interpreted to mean only that pure = return; so the zip instance of lists would be excluded, since return = repeat; whereas the concurrent instance for IO could in principle be permitted ;)
10:49:35 <monoidal> ZipList is not a monad
10:49:56 <applicative> list is a monad
10:50:20 <FreeFull> A nonzippy one
10:50:22 <applicative> which might have been given the applicative instance pure = repeat etc
10:50:35 <monoidal> yes, but ZipList is a different type from [], which is not a monad. so I disagree with premise "If f is also a Monad..."
10:51:04 <applicative> no, monoidal consider the text before any instances are declared
10:51:18 <quchen> Is this the "Applicative instance shouldn't match Monad instance" talk again?
10:51:24 <quchen> Didn't we have that a million times now?
10:51:33 <applicative> if i didn't propose to make a monad instance for lists, i could make the zippy applicative instance, obviously
10:51:58 <monoidal> applicative: if the Monad [] instance is not defined, then the premise is still false. I still don't see how you could interpret the text otherwise.
10:52:12 <applicative> quchen: yes, but now  marlow is proposing a case where x <*> y is 'concurrent'
10:52:45 <quchen> I didn't get that memo.
10:52:51 <applicative> monoidal:  it won't work for lists since the zippy pure is repeat
10:52:56 <applicative> it would work for IO
10:53:25 <applicative> and he has already done it with Haxl, it seems
10:53:27 <quchen> And I highly doubt Simon Marlow would propose something like that.
10:54:24 <applicative> the whole purpose is to evade x <*> y = do {f <- x; a <- y; return (f x)} to put it crudely
10:55:50 <carter> optparse-applicative is niceee
10:55:58 <carter> no relation to applciative
10:55:58 <haasn> I think if the Applicative instance did not match the Monad instance I would be extremely confused trying to ue it
10:56:01 <haasn> use*
10:56:17 <FreeFull> Same
10:56:17 <applicative> quchen: see http://ghc.haskell.org/trac/ghc/wiki/ApplicativeDo and compare the slides linked here http://www.reddit.com/r/haskell/comments/1le4y5/the_haxl_project_at_facebook_slides_from_my_talk/
10:56:18 <haasn> I like going back and forth between applicative and monad syntax
10:56:23 <FreeFull> Especially since AMP is coming up
10:57:17 <quchen> That's a link to a bunch of slides.
10:57:24 <haasn> also “‘pure = return and (<*>) = ap’ can be interpreted to mean only that ‘pure = return’” <- I don't see how ignoring half the sentence is ‘interpreting’ it
10:57:27 <quchen> Doesn't look like he's proposing something to me.
10:57:44 <applicative> if ap is a method of monad, it can be implemented independently
10:57:45 <quchen> haasn: "For left-biased definitions of 'and'" maybe
10:58:23 <haasn> applicative: oh, so you're instead suggesting that ap ≠ liftM2 id
10:58:35 <applicative> quchen: that was the hypothesis of the bit you quoted from me
10:59:01 <quchen> I didn't quote you, did you mean haasn?
10:59:07 <applicative> haasn: i'm not suggesting anything, just trying to figure out marlowe
10:59:35 <applicative> sorry, muddled there about haasn v quchen
11:02:53 <quchen> ap ≠ liftM2 id also sounds a little strange.
11:03:26 <applicative> isn't that the actual definition? something wacky like that
11:03:51 <quchen> You can also write it as `liftM2 ($)` if you find that less "wacky".
11:04:29 <quchen> I've heard some people wanted to add `ap` to `Monad`, but now that's redundant anyway.
11:04:41 <applicative> yea thats the actual definition.
11:05:23 <applicative> quchen: i think you haven't been meditation on the io related cases
11:05:27 <applicative> meditating
11:05:49 <quchen> Not sure what you mean by meditating here.
11:06:29 <applicative> well look at the applicative instance in marlow's slides ;)
11:07:00 <applicative> i don't totally understand it yet
11:07:16 <quchen> "instance Applicative Haxl where", that one?
11:07:36 <applicative> yes
11:07:49 <applicative> is it (<*>) = liftM2 id?
11:08:13 <applicative> liftM2 f a b is the obvious a <- x; b <- y etc
11:10:04 <applicative> I think to get wants he will need two types, one for the monad one for the 'nonsequential' applicative
11:11:47 <edwardk> Shin-LaC: there was a great wave of monomorphization in haskell 98. mostly to compensate for crappy error messages out of compilers scaring newbies.
11:11:56 <applicative> and then if he likes do notation, a specifically applicative or 'concurrent' do
11:12:02 <edwardk> now we have awesome error messages, but the painful monomorphism remains
11:12:11 <edwardk> applicative: ?
11:12:38 <applicative> edwardk: just trying to figure out what marlow is up to with do notation and his haxl type
11:12:44 <edwardk> applicative: not liking the upgrade to do notation to let it automatically upgrade to applicative we've been toying with?
11:13:09 <edwardk> applicative: right now mapM, etc. needlessly introduce a ton of sequencing
11:13:39 <FreeFull> @pl \a -> f a >>= b
11:13:42 <lambdabot> (>>= b) . f
11:13:42 <lambdabot> optimization suspended, use @pl-resume to continue.
11:13:44 <edwardk> philippa actually was the first to propose an applicative do that i know of. iavor and i talked to spj about it, and marlow got really excited about it
11:13:51 <applicative> i have no view, it's really a question whether his (<*>) = ap for haxl
11:14:22 <edwardk> applicative: in general (<*>) affords more opportunities for optimization
11:14:34 <edwardk> e.g. swierstra/duponcheel's parser
11:14:41 * jfischoff makes a small prayer for applicative do
11:14:44 <applicative> yes the idea has been around forever. it just seems like his actual purpose doesn't fit with this
11:15:06 <edwardk> applicative: to be fair, he popped up after a bunch of the rest of us had been calling for it. ;)
11:15:22 <applicative> it fits with applicative do, but he seems to want the same 'applicative desugarig' to apply to all do notionation
11:15:31 <edwardk> sure
11:16:05 <edwardk> lots of code is idiomatically written in do notation, but could be translated into semantically correct applicative code that was just better and exposed more opportunities for introspection
11:16:56 <edwardk> some people just can't be bothered to learn how to sprinkle <$> all <*> the <*> applicative <*> noise through <*> their code
11:17:38 <Shapeshifter> Hi. In lyah there's an example "map (Circle 10 20) [4,5,6,6]" which creates 4 circles with equal x/y but varying r. But what do I need to do if I want for example same y,r but different x, i.e. different currying? I can't figure it out.
11:17:38 <applicative> its not that its the writing of an explicit lambda to get the ordering of 'effect's that you want
11:17:43 <shachaf> I suggested the tuple-less do translation in here a while ago... I have a file at home with some examples/edge cases. I should find it.
11:18:12 <edwardk> shachaf: thats probably where i got it from. i showed it to him at icfp
11:18:18 <applicative> r is the third parameter Shapeshifter ?
11:18:52 <Rarrikins> Shapeshifter: map (\x -> Circle 10 x 20)
11:18:56 <Rarrikins> Shapeshifter: Or whatever.
11:18:56 <applicative> Shapeshifter: I think you won't do much better than map ...
11:19:03 <applicative> like Rarrikins says
11:19:31 <Rarrikins> Shapeshifter: You can try @pl here, but use the results only if they're not ugly.
11:19:40 <Rarrikins> @pl \x -> Circle 10 x 20
11:19:44 <lambdabot> flip (Circle 10) 20
11:19:44 <lambdabot> optimization suspended, use @pl-resume to continue.
11:20:03 <applicative> is that a case where ?? works, map (Circle 10 ?? 20)
11:20:07 <applicative> hah
11:20:20 <Rarrikins> applicative: There's a ???
11:20:25 <FreeFull> :t (???)
11:20:27 <lambdabot>     Not in scope: `???'
11:20:27 <lambdabot>     Perhaps you meant `??' (imported from Control.Lens)
11:20:30 <Rarrikins> @type (??)
11:20:31 <lambdabot> Functor f => f (a -> b) -> a -> f b
11:20:34 <applicative> @type (??)
11:20:35 <lambdabot> Functor f => f (a -> b) -> a -> f b
11:20:38 <FreeFull> applicative: I'm pretty sure ?? would work there
11:20:50 <Rarrikins> I wish hoogle.com was Hoogle.
11:21:01 <Shapeshifter> Ah, I see. Got it. So the original, "map (Circle 10 20) [4,5,6,6]" could be rewritten "map (\x -> Circle 10 20 x) [4,5,6,6]".
11:21:03 <edwardk> Rarrikins: (??) comes from lens
11:21:05 <applicative> yes, it was map (Circle ?? 10 20) where it would break
11:21:13 <Rarrikins> Oh, I see.
11:21:19 <Shapeshifter> Yeah, bloody beginner, here.
11:21:20 <Rarrikins> Hoogle can't handle the (??)!
11:21:21 <edwardk> applicative: Circle ?? 10 ?? 20
11:21:29 <FreeFull> > map ((,,) 3 ?? 5) [1,2,3,4,5]
11:21:30 <applicative> omigod
11:21:31 <lambdabot>   [(3,1,5),(3,2,5),(3,3,5),(3,4,5),(3,5,5)]
11:21:54 <FreeFull> > map ((,,) ?? 3 5) [1,2,3,4,5]
11:21:55 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> b))
11:21:55 <lambdabot>    arising f...
11:21:56 <applicative> it has the right precedence?
11:22:04 <FreeFull> > map ((,,) ?? 3 ?? 5) [1,2,3,4,5]
11:22:05 <edwardk> applicative: explicitly so
11:22:05 <lambdabot>   [(1,3,5),(2,3,5),(3,3,5),(4,3,5),(5,3,5)]
11:22:12 <applicative> you are a really a twisted one edwardk
11:22:14 <Rarrikins> @let data Circle a = Circle { x :: a, y :: a, r :: a }
11:22:15 <lambdabot>  Defined.
11:22:16 <edwardk> =)
11:22:32 <Rarrikins> @let data Circle a = Circle { x :: a, y :: a, r :: a } deriving Show
11:22:33 <lambdabot>  .L.hs:145:6:
11:22:33 <lambdabot>      Multiple declarations of `Circle'
11:22:33 <lambdabot>      Declared at: .L.hs:...
11:22:37 <Rarrikins> Blah
11:22:43 <Rarrikins> @let data Circle2 a = Circle2 { x :: a, y :: a, r :: a } deriving Show
11:22:44 <lambdabot>  .L.hs:145:26:
11:22:44 <lambdabot>      Multiple declarations of `x'
11:22:44 <lambdabot>      Declared at: .L.hs:143:...
11:22:59 <applicative> its obvious, but it gives ?? a slightly different feel
11:23:04 <quchen> @undef
11:23:04 <lambdabot> Undefined.
11:23:09 <quchen> There you go.
11:23:23 <Rarrikins> I was about to write a Show instance :)
11:23:31 <Rarrikins> @let data Circle a = Circle { x :: a, y :: a, r :: a } deriving Show
11:23:32 <lambdabot>  Defined.
11:23:38 <applicative> @type Circle 10 ?? 20
11:23:39 <lambdabot> Num a => a -> Circle a
11:23:55 <Rarrikins> > map (Circle 10 ?? 20) [1..10]
11:23:55 <applicative> @type Circle ?? 10 ?? 20
11:23:56 <lambdabot> Num a => a -> Circle a
11:23:59 <lambdabot>   [Circle {x = 10, y = 1, r = 20},Circle {x = 10, y = 2, r = 20},Circle {x = ...
11:24:06 <Rarrikins> Neat.
11:24:10 <krakrjak> nice thanks for the ?? hint, that's pretty nifty.
11:24:19 <krakrjak> me goes off to read more lens code.
11:24:40 <Rarrikins> > map (Circle ?? 10 20) [1..10]
11:24:41 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> a))
11:24:42 <lambdabot>    arising f...
11:24:54 <applicative> you need the second ??
11:25:00 <Rarrikins> > map (Circle ?? 10 ?? 20) [1..10]
11:25:04 <lambdabot>   [Circle {x = 1, y = 10, r = 20},Circle {x = 2, y = 10, r = 20},Circle {x = ...
11:25:51 <Rarrikins> So, it sort of leapfrogs over arguments?
11:26:04 <Rarrikins> It's probably left associative.
11:28:58 <tom39341> ssssddffffjj
11:29:26 <carter> anyone know how i can use optparse-applicative to get an optional flag? i'm a bit stumped on doing that
11:29:26 <tom39341> Lag, sorry.
11:29:51 <donri> carter: "optional"? :)
11:29:53 <donri> :t optional
11:29:54 <lambdabot> Alternative f => f a -> f (Maybe a)
11:30:13 <carter> ok
11:30:15 <carter> i'll try that
11:30:43 <briennetheblue> > [pred, succ] ?? 0
11:30:44 <carter> yuusss
11:30:45 <lambdabot>   [-1,1]
11:30:46 <carter> thanks donri
11:32:33 <Enigmagic> carter: look at the source for optional
11:33:54 <xeno_> So, on the Higher Order Functions chapter of the _Learn_... book, I am frustrated with lack of information on the !! operator:
11:33:57 <xeno_> ghci> (listOfFuns !! 4) 5
11:34:30 <xeno_> Find it looks like !! takes 5 as an argument, but why is it not in the Oreilly book?
11:34:40 <xeno_> I almost wonder if it's a typo.
11:34:48 <joelteon> !! takes listOfFuns and 4 as its arguments
11:35:15 <klugez> > [1,2,3] !! 0
11:35:16 <lambdabot>   1
11:35:19 <xeno_> Okay, so 4 is the K then.
11:35:33 <xeno_> Got it.  Now that makes sense.  That IS in the Oreilly book.  Sorry I'm so dense.
11:35:42 <ReinH> @hoogle (!!)
11:35:42 <lambdabot> Prelude (!!) :: [a] -> Int -> a
11:35:42 <lambdabot> Data.List (!!) :: [a] -> Int -> a
11:35:42 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
11:36:23 <ReinH> xeno_: you can always look a function up in hoogle
11:36:29 <ReinH> or a type signature, which is super useful
11:36:39 <ReinH> @hoogle [a] -> Int -> a
11:36:40 <lambdabot> Prelude (!!) :: [a] -> Int -> a
11:36:40 <lambdabot> Data.List (!!) :: [a] -> Int -> a
11:36:40 <lambdabot> Prelude drop :: Int -> [a] -> [a]
11:41:53 <xeno_> Thank you also ReinH.
11:46:38 <acomar> anyone know a good tutorial on existential types?
11:49:31 <Cale> acomar: http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#existential-quantification
11:50:08 <cschneid> Wait, so who implements this ?? function ya'll are playing with
11:50:24 <cschneid> @src ??
11:50:24 <lambdabot> Source not found. I feel much better now.
11:50:35 <jfischoff> @t (??)
11:50:35 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
11:50:42 <jfischoff> @type (??)
11:50:43 <lambdabot> Functor f => f (a -> b) -> a -> f b
11:50:50 <acomar> Cale: thanks
11:50:53 <cschneid> @src (??)
11:50:54 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
11:50:54 <jfischoff> its in lens somewhere I think
11:51:23 <joelteon> :t pure ($)
11:51:23 <lambdabot> Applicative f => f ((a -> b) -> a -> b)
11:51:31 <joelteon> :t pure id
11:51:31 <Rarrikins> @hoogle (??)
11:51:31 <lambdabot> No results found
11:51:32 <lambdabot> Applicative f => f (a -> a)
11:51:48 <cschneid> there it is. It's in Control.Lens.Combinator
11:51:54 <cschneid> Combinators.
11:51:58 <Rarrikins> How did you find it?
11:55:01 <carter> Enigmagic: thanks
11:55:01 <briennetheblue> click index in the docs on the top right
11:55:06 <briennetheblue> that's how I found it anyway
11:55:20 <donri> hayoo is good for this
11:56:12 <WingbeatPony> Is unregisterized ghc still the preferred method for porting to new flavors of linux?
12:00:29 <WingbeatPony> I'm still hunting for a way to bring haskell to a system that only has gcc, no ghc exists for it
12:01:09 <haasn> are there any haskell compilers out there that will build GHC?
12:01:15 <haasn> (other than GHC)
12:01:28 <shachaf> I really doubt it.
12:01:31 <monoidal> current GHC - no
12:01:39 <FreeFull> Doesn't GHC have a bootstrap thing included?
12:01:40 <haasn> Ok. Well, you could go through the versions
12:01:45 <WingbeatPony> That's kinda what I feared
12:02:16 <WingbeatPony> GHC as of 7.0 doesn't really have an easy way to build an unregisterized (c-based) version of itself, and thus vice versa
12:02:36 <FreeFull> AFAIK GHC is written in a constricted subset of Haskell specifically so it can be bootstrapped on a system without GHC
12:03:44 <WingbeatPony> Do you have any more details on that? I'm not that great at compiling from source, and I'm constantly tripping over "How to build GHC: Step 1. install GHC"
12:04:01 <FreeFull> Maybe I'm wrong though
12:04:09 <FreeFull> You could try cross-compiling
12:04:12 <monoidal> FreeFull: don't think so. e.g. basicTypes/Literal.hs needs -XDeriveDataTypeable
12:04:30 <WingbeatPony> I have never once attempted to cross-compile. I don't even know what's involved
12:05:00 <Tazman> Hey, just wondering what library function I could use to determine if a character is a digit
12:05:15 <opqdonut> :t isDigit
12:05:15 <lambdabot> Char -> Bool
12:05:16 <Tazman> "You'll need a library function to de- termine if a character is a digit, one to convert a digit to an integer, and one to do the multiplication. 2"
12:05:18 <FreeFull> Tazman: isDigit from Data.Char
12:05:23 <Tazman> ah okay
12:05:34 <shachaf> Tazman: It sounds like the idea is that you figure it out yourself.
12:05:34 <Tazman> second one is digitToInt right>
12:05:58 <Tazman> Actually we've been directed to a page on a textbook
12:06:02 <Tazman> but mines hasn't been delivered yet
12:06:16 <FreeFull> What is the textbook called?
12:06:18 <WingbeatPony> If that book is "Learn you a haskell for great good," it's available in full online
12:06:28 <Tazman> haskell - the craft of functional programming
12:06:51 <shachaf> http://hackage.haskell.org/package/base is most of the standard library.
12:07:04 <shachaf> @where hoogle lets you search for things by name or type.
12:07:04 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
12:07:30 <Tazman> ah that'll help, great :)
12:07:49 <FreeFull> Tazman: digitToInt is in Data.Char
12:07:55 <FreeFull> > digitToInt '3'
12:07:55 <lambdabot>   3
12:08:24 <haasn> now all we need is a function for multiplication... *scratches head*
12:08:42 <haasn> @faq can haskell multiply?
12:08:43 <lambdabot> The answer is: Yes! Haskell can do that.
12:08:51 <FreeFull> > 3 * 3
12:08:52 <lambdabot>   9
12:09:07 <FreeFull> Perfect?
12:09:14 <WingbeatPony> Don't beat yourself silly over that one. Just look up how to write functions, I think
12:10:05 <WingbeatPony> I highly doubt figuring out how to multiply was the purpose of that exercise
12:10:51 <shachaf> Figuring out how to multiply isn't very useful. But figuring out how to figure out is very important.
12:11:35 <WingbeatPony> True, I did rather drive my classmates nuts because that sort of thing came to me easily
12:11:43 <FreeFull> "Hey, I need a function to do stuff to characters. I should check if a Data.Char exists. Yep, it exists, and it looks like that function does exactly what I wanted"
12:14:01 <acomar> anyone know off the top of their heads if Ints are 32 bit or 64 bit in Haskell?
12:14:10 <acomar> (off to search google in a moment)
12:14:15 <stevely> neither
12:14:37 <acomar> yea, I see that :/
12:15:23 <ion> acomar: If you need a specific size, use types from Data.Int.
12:15:50 <acomar> ion: yea, that's what I'm looking at now
12:16:03 <acomar> ion: It's less that I need a specific size and more that I just need to know what it is
12:16:17 <ion> > maxBound :: Int
12:16:19 <lambdabot>   2147483647
12:16:46 <haasn> Int is ‘at least 2^29’ (or something close to that)
12:16:55 <haasn> but there's no upper bound
12:17:00 <haasn> I mean
12:17:07 <haasn> There's no upper bound on the upper bound. If that makes sense
12:17:09 <ion> Perhaps cabal can provide a CPP macro to detect the exact value in compile time. I haven’t looked.
12:17:38 <quchen> "Data.Int - A fixed-precision integer type with at least the range [-2^29 .. 2^29-1]"
12:17:48 <quchen> Page 181 of the PDF Report
12:18:14 <quchen> s/Data.Int/data Int
12:19:52 <acomar> ion: yea, I'm solving it by requiring a fromIntegral to the guaranteed width types
12:20:23 <acomar> ion: passing Int will fail at compile time with no instance for this typeclass
12:21:18 <slehuito> I have a program that I compile like so: >ghc -O2 --make Test.lhs
12:21:33 <slehuito> And run like so: >Test.exe
12:21:44 <slehuito> I get this in return:
12:21:52 <slehuito> *Stack space overflow: current size 8388608 bytes.
12:22:02 <ion> Pastebin the code.
12:22:04 <slehuito> *Use `+RTS -Ksize -RTS' to increase it.
12:22:22 <slehuito> So I figured I’d try to change stack size, like so: >Test.exe +RTS -K50m
12:22:36 <slehuito> The result was not nice:
12:22:47 <slehuito> *Test.exe: Most RTS options are disabled. Link with -rtsopts to enable them.
12:22:53 <aranea> slehuito: could you perhaps show us the code?
12:22:59 <slehuito> However, querying for rts options like so: >Test.exe +RTS -?
12:23:04 <S11001001> slehuito: such an error usually indicates that you need to fix something in your code
12:23:21 <S11001001> slehuito: see ion's comment right after your error message.
12:23:49 <WingbeatPony> Incidentally, I *finally* found the answer I was looking for. Maybe this'll be useful information for the rest of you, too http://www.haskell.org/ghc/docs/6.4.1/html/building/sec-porting-ghc.html
12:24:10 <WingbeatPony> I can't confirm that this works, though, as I have yet to test it
12:24:48 <slehuito> aranea, s11001001: Thanks! But I want to know how to activate some rts trace/debug options, I'm not asking for you guys to fix my stack overflow!
12:25:22 <ion> slehuito: Increasing the stack size isn’t a solution to this problem.
12:25:41 <Rarrikins> Compile it with -rtsopts
12:25:46 <monoidal> WingbeatPony: that's documentation for ancient GHC, might be outdated
12:26:00 <Rarrikins> But yes, fix the leak.
12:26:04 <slehuito> Compiling with "ghc -rtsopts Test.lhs" (or with –make -rtsopts) gives the exact same result.
12:26:26 <Flonk> > fmap (+1) [1..10]
12:26:27 <aranea> slehuito: well, as the message says: link with -rtsopts
12:26:41 <edwardk> lens is considering picking up affine (0 or 1 target) traversals, and relevant (1 or more target) traversals. throwing open the discussion of these names. if anyone has better ones, i'm happy to take it
12:26:46 <Rarrikins> slehuito: That allows you to use +RTS with stack space options.
12:27:03 <slehuito> so "ghc -rtsopts Test.lhs" doesn't link?
12:27:12 <shachaf> I like the phrases "at least one" and "at most one", not that that helps you.
12:27:12 <slehuito> (rtsopts I mean)
12:27:13 <edwardk> keep in mind we'd also have Affine/Relevant Folds too
12:27:44 <Shapeshifter> Is it possible to define a new data type which is just a Map with specific type parameters? I.e. a Map Int Int?
12:27:46 <WingbeatPony> Woohoo, netsplit party!
12:27:56 <edwardk> Shapeshifter: type MyMap = Map Int Int
12:28:09 <Shapeshifter> Oh, it works. Thanks
12:28:37 <edwardk> Shapeshifter: that works fine so long as you want everythin you can do on a map to work with it. if you need to 'protect it' hide it behind a newtype or something
12:28:51 <WingbeatPony> I'll see what works and get back to you guys
12:29:09 <slehuito> I guess my question becomes: how do I "link with -rtsopts"?
12:29:19 <Rarrikins> slehuito: ghc -rtsopts -O2 Whatever
12:29:28 * hackagebot HaRe 0.7.0.6 - the Haskell Refactorer.  http://beta.hackage.haskell.org/package/HaRe-0.7.0.6 (AlanZimmerman)
12:29:53 <prophile> finally
12:30:02 <slehuito> I don't see how different it is to my "ghc -rtsopts Test.lhs" (with or without O2)
12:30:21 <Rarrikins> slehuito: It's not with regard to RTS.
12:30:44 <slehuito> rarrikins: I don't understand your answer...
12:31:27 <Polarina> Shapeshifter, you may want to take a look at IntMap as well. It is specialized for Ints as the key and thus has better performance for those.
12:31:47 <Rarrikins> slehuito: It's not different.
12:33:27 <slehuito> rariikins: then, why does "Test.exe +RTS -K50m -RTS" complain about most rts options being disabled?
12:33:52 <Shapeshifter> edwardk: mh, actually, I'm not sure this is what I need. import qualified Data.Map as Map; type T = Map Int Int gives me "Not in scope: type constructor of class `Map'" and type T = M.Map Int Int really isn't what I need I think (wondering what Data.Map.Map is even).
12:34:00 <dmwit> slehuito: I missed some context, but did you compile with -rtsopts? That's how you enable those options.
12:34:01 <slehuito> Could this have to do with my using ghc 7.4.1?
12:34:17 <Shapeshifter> Polarina: thanks for the hint, I was wondering about the general case.
12:34:33 <slehuito> dmwit: I agree the context is long to establish, so you might have missed;-)
12:34:38 <slehuito> something
12:34:47 <Rarrikins> slehuito: Delete Test.exe. Compile with -rtsopts.
12:35:36 <edwardk> type T = Map.Map Int Int
12:35:58 <edwardk> Data.Map is the module, Data.Map.foo is the names from Data.Map   when you import Data.Map as Quux  then Quux.foo = Data.Map.foo
12:36:07 <aranea> Hi. I've just started a program which tries out different strategies for the prisoner's dilemma. A master manages the agents and lets them play against each other, recording the results. Each agent should be allowed to have a state, which the master preserves between subsequent invocations. I thought the data of the master might look like [(Agent, State)], but I can't do that because the different agents need different kinds of states.
12:36:08 <edwardk> Data.Map contains a type named Map
12:36:21 <edwardk> so import Data.Map as Map means that Map.Map is the data type Map from the Data.Map module
12:36:37 <edwardk> import Data.Map as M means that M.Map is the data type Map from the Data.Map module
12:36:39 <dmwit> aranea: Have your Agent be a function which returns a move and another Agent.
12:37:09 <dmwit> aranea: (The other Agent that's returned will be a closure over the modified state.)
12:37:11 <slehuito> rarrikins: Thanks! The rebuild wasn't done
12:37:33 <Rarrikins> slehuito: No problem.
12:38:14 <aranea> thanks, dmwit!
12:39:29 * hackagebot pipes-vector 0.5.2 - Various proxies for streaming data into vectors  http://beta.hackage.haskell.org/package/pipes-vector-0.5.2 (BenGamari)
12:41:26 <ReinH> aranea: relevant to your interests http://www.haskell.org/haskellwiki/Import http://www.haskell.org/haskellwiki/Import_modules_properly
12:41:42 <ReinH> er
12:41:46 <ReinH> that's the wrong person isn' tit
12:41:46 <ReinH> sorry
12:42:00 <ReinH> Shapeshifter: relevant to your interests http://www.haskell.org/haskellwiki/Import http://www.haskell.org/haskellwiki/Import_modules_properly
12:42:08 <fizruk> edwardk: does there exist the "right way" to define default wrap implementation? http://lpaste.net/93706
12:42:20 <fizruk> edwardk: and should I actually define such?
12:43:33 <Moggle> I'd like extensible data types, but I'd like them to sort of extend sum types so that I can still pattern match/serialize my types/whatever. Existential data types don't quite do this.
12:43:39 <Moggle> Is there a GHC extension or something?
12:43:51 <Moggle> ... is anyone willing to write a GHC extension?
12:44:13 <dmwit> um
12:44:19 <dmwit> Sounds like you just volunteered. =)
12:44:20 <fizruk> edwardk: I think it _is_ good to have polymorphic wrap (so you can do wrap having arbitrary transformer nesting)
12:44:29 <dmwit> But I'm not sure what it is you're asking for yet, can you give a few more details?
12:44:33 <dmwit> Maybe a motivating example?
12:44:49 <Shapeshifter> I must have something backwards. My Idea is that I would like to have a Map type, which only works with some specific data types, e.g. Int Int. So I think that I should for example be able to do MyMap.fromList $ map (\x -> (x, 1)) ['a'..'z'] and have this fail if MyMap is a Map Int Int.
12:45:01 <Moggle> dmwit: The motivating example is the same example as for something using existential typeclasses.
12:45:08 <fizruk> edwardk: though I'm not sure that it should be in typeclass
12:45:37 <dmwit> Moggle: Okay, I'll bite. What is the motivating example for existential typeclasses? (And what are existential typeclasses?)
12:45:39 <edwardk> fizruk: i started going through the code with dolio but we got distracted
12:45:43 <Rarrikins> Shapeshifter: Map Int Int is just such a type.
12:46:02 <Rarrikins> Shapeshifter: If you try to put that list into that map, it will give a type error.
12:46:04 <Moggle> dmwit: I just want to be able to say, collect a bunch of data declarations and shove them into one thing. Preferably there'd also be a way to define functions and pattern match them all over as well.
12:46:06 <Cale> Shapeshifter: Yeah, what's wrong with just using the Map type from Data.Map?
12:46:15 <ReinH> er. Where is lambdabot?
12:46:24 <Rarrikins> ReinH: Probably netsplitted.
12:46:33 <Moggle> dmwit: as for extenstial typeclasses, I am pretty confident i typo'd hard and meant existential types.
12:46:33 <ReinH> Rarrikins: argh partition failures are the worst
12:46:37 <dmwit> Shapeshifter: You can define a more-monomorphic fromList if you like, but there isn't (yet) syntax for specializing the type the way you want.
12:46:56 <dmwit> Shapeshifter: Future GHC's will have explicit type application, and then you will be able to write something like fromList @MyMap for what you want.
12:47:14 <Cale> dmwit: Oh really?
12:47:29 <Shapeshifter> Rarrikins: But I get Failed to load interface for `MyMap' when trying to do MyMap.fromList or anything like that.
12:47:31 <dmwit> Moggle: That doesn't sound like a motivating example to me, just a restatement of your previous wish. =)
12:47:36 <Moggle> dmwit: :P
12:47:37 <dmwit> Cale: Well. Maybe. =)
12:47:50 <Cale> Shapeshifter: Well, does that module exist?
12:47:59 <dmwit> Cale: There's some code written for it. Whether it goes into GHC proper or not is another question, I guess.
12:48:06 <Rarrikins> Shapeshifter: No, just use Map Int Int. Whatever.f is the Whatever module rather than the Whatever type.
12:48:08 <Shapeshifter> Cale: no, that's what I'm trying to understand.
12:48:19 <Cale> Shapeshifter: uhhhh
12:48:23 <Rarrikins> Shapeshifter: If the type you have is a Map Int Int, fromList can't take anything but Ints.
12:48:33 <Cale> Shapeshifter: I think you just want to use Data.Map
12:48:39 <dmwit> Shapeshifter: These other people aren't reading your question carefully enough. Read my answer and ignore them. =)
12:48:48 <Cale> Shapeshifter: unless your goal is to implement your own finite map datastructure
12:48:50 <Rarrikins> Shapeshifter: Just make your functions take only Map Int Ints.
12:48:55 <Moggle> dmwit: Alright, basic example: I'd like to make a basic Widget data type, and ideally there'd be different kinds of widgets and each one can be rendered.
12:49:06 <Cale> dmwit: I think he's confused about the difference between modules and data types
12:49:11 <dmwit> Yes, he is.
12:49:13 <dmwit> And that's fine.
12:49:16 <Shapeshifter> Ah I got it now.
12:49:33 <Moggle> dmwit: I could make a sum type, Data Widget = Window Data1 Data2 Data3 | Button etc etc
12:49:35 <Shapeshifter> M.fromList $ map (\ x -> (x, 1)) ['a' .. 'z'] :: MyMap fails indeed in that case
12:49:36 <dmwit> He used module syntax, and wanted type application. That's okay.
12:49:45 <Shapeshifter> Thanks.
12:49:55 <fizruk> edwardk: I understand, work is always distracting from things ;)
12:50:16 <Moggle> dmwit: Now, I'd like to be able to add to that definition from multiple files. I don't want a single data declaration with hundreds of widgets, and then I don't want to pattern match on a render function for hundreds of widgets too.
12:50:32 <dmwit> Moggle: Right. You might like the Data Types a la Carte paper.
12:50:37 <Moggle> dmwit: Ideally I'd have each widget in its own file, say, and pattern match on the render function for that specific data constructor.
12:50:40 <dmwit> There's some code up on Hackage, too.
12:50:48 <Moggle> dmwit: Curses, I was hoping you wouldn't suggest that. It was... ugly.
12:51:39 <Moggle> dmwit: There's an option to declare a Widget as something containing a render function on its own, which is close to what I want... but I also want to seralize it. Can't serialize functions.
12:51:57 <elliott> Moggle: you want data Widget = Widget { ... behaviour ... }
12:52:02 <elliott> Moggle: and then data Window = Window Data1 Data2 Data3
12:52:13 <elliott> and then a function Window -> Widget. you can serialise Window, just not Widget.
12:52:23 <Moggle> elliott: What if I want a tree of Widgets?
12:52:39 <elliott> well... it depends. :p
12:52:42 <dmwit> I'm curious how you plan on deserializing.
12:52:48 <elliott> yes, what dmwit said.
12:52:55 <elliott> if you are throwing away type information like this, then...
12:52:59 <dmwit> Under the assumption that you don't know what type you're getting, that seems hard.
12:53:04 <Moggle> I don't WANT to throw away type information.
12:53:10 <Moggle> Hence, a big sum type with a bunch of data constructors
12:53:14 <Moggle> and my wish for a way to be like
12:53:20 <dmwit> Serializing is programming-code for "throw away type information".
12:53:26 <Moggle> data Widget = Window Data1 Data 2 | Button Data3
12:53:28 <Moggle> and then in some other file
12:53:36 <Moggle> data Widget = Label String
12:53:44 <Moggle> and somehow combine these definitions into one thing.
12:53:51 <Moggle> Seems like the compiler should be able to do it and keep type safety.
12:54:02 <dmwit> I challenge that assertion.
12:54:10 <Moggle> Well, that's why I'm here!
12:54:18 <Moggle> Explain to me why I am wrong in my wish.
12:54:43 <dmwit> You have your head on backwards. It's your job to prove that your wish is right, not mine to prove it's wrong. =)
12:54:55 <Moggle> dmwit: Sorry for bothering you then D:
12:55:18 <Moggle> I see no reason why a compiler couldn't scan through all my files, look for perhaps some new syntax like "extendeddata <Name>"
12:55:28 <elliott> Moggle: for a start, you can define functions foo :: Widget -> ...
12:55:31 <Moggle> and then just cut that out and gather it into one big sum type.
12:55:34 <elliott> those functions need to cover every constructor of Widget.
12:55:39 <elliott> this essentially comes down to the expression problem.
12:55:43 <dmwit> In any case, I think you have your answer: there's nothing like that currently, but there are similar things (existentials, a la carte, and records of functions) that you can play with.
12:55:46 <Moggle> elliott: yes, I'd like to be able to do this for function declarations too!
12:55:51 <elliott> Moggle: but that's not enough.
12:56:04 <Moggle> ... yes, I'd like a solution to the expression problem please. :D
12:56:17 <elliott> every time you add a new piece of data, it must know about every function that did not cover it, ever -- including things like local where-clause declarations! this is not tenable, it breaks modularity horribly when you can define arbitrary functions
12:56:37 <elliott> a solution is to fix the functions that operate on it -- this is the OOP solution, you can add subclasses freely, but the methods of the actual superclass remain the same.
12:56:41 <Moggle> I'd like to be able to break modularity under carefully controlled circumstances!
12:56:53 <elliott> another solution is to fix the data constructors and allow as many new functions as you want -- this is the algebraic data type solution.
12:57:08 <elliott> they correspond to a data record of behaviour, and an algebraic sum type of data, in Haskell, respectively.
12:57:24 <elliott> if you want both, well, tough, you have to break the rules and compromise somewhere :)
12:57:35 <Moggle> It seems like I shouldn't, though.
12:57:46 <Moggle> I could in practice just _write_ one big algebraic data type.
12:57:51 <dmwit> We need a #haskell-whine.
12:57:57 <Moggle> And then write functions and pattern match.
12:58:02 <Moggle> I just want a way to organize it more cleanly.
12:58:07 <Moggle> Sorry for whining then!
12:58:12 <Moggle> It wasn't my intention to annoy anyone
12:58:20 <Moggle> I was just hopeful there was an easy solution when google failed me.
12:58:30 * dmwit is not annoyed
12:58:50 <elliott> Moggle: I throw you this bone: https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/higpig.html
12:59:01 <elliott> it lets you make that huge algebraic type like this if you want.
13:00:13 <Shapeshifter> Mh. So is it possible to pattern match on a type? E.g. type Seat = Int and then pattern match like doSomething (Seat n) = Something. This doesn't work, it gives me a "Not in scope: data constructor Seat", because it's just a simple type.
13:00:13 <Moggle> that seems like something I could use! thanks
13:00:28 <Moggle> i'll just write a simple parser and make a pass over my code if i must anyways
13:00:40 <Moggle> then again i doubt it would be so simple
13:00:41 <dwcook> Shapeshifter, maybe what you want is a type with constructors that accept values of other types
13:00:49 <dwcook> data StringOrInt = String String | Int Int
13:01:07 <dmwit> Shapeshifter: That is what type classes are for.
13:01:11 <dwcook> Shapeshifter, though it would be good if you explained further what you want this for.
13:01:35 <Moggle> the expression problem: The goal is to define a datatype by cases, where one can add new cases to the datatype and new functions over the datatype, without recompiling existing code
13:01:43 <elliott> Moggle: anyway, the downside to this is that it's kind of spaghetti code.
13:01:48 <Moggle> silly question, but I don't want to be able to add new functions over the datatype
13:01:52 <Moggle> just a few core ones
13:01:57 <Moggle> i don't suppose _that's_ possible?
13:02:01 <elliott> then you want a record of behaviour.
13:02:22 <Moggle> but i want to be able to serialize and deserialize.
13:02:36 <elliott> yes, the latter part is the problem there :P
13:02:40 <Moggle> okay
13:02:46 <Moggle> so saying i want to serailize/deserialize
13:02:53 <Moggle> is the same as saying i want to add new functions over the datatype?
13:02:59 <Moggle> sorry to be dense here :P
13:03:31 <elliott> well.
13:03:38 <elliott> it's a little complicated.
13:03:47 <Moggle> i'm getting that!
13:03:49 <elliott> you might be able to do a record of behaviour that is serialisable.
13:03:53 <Moggle> i had in mind a _horrific_ template haskell solution
13:03:56 <elliott> if you expose your rendering logic as something higher-level than IO () or something.
13:04:06 <Moggle> that assumed any functions in a data type were 'static'
13:04:32 <Moggle> and that i would have a few instances of records of behavior
13:04:34 <Moggle> just assign each a number
13:04:44 <Moggle> and bam easy serialization/deserialization
13:04:54 <Moggle> still not perfect though, you have to assign a unique number to each 'instance' of the type.
13:05:03 <Moggle> and it's not perfectly type safe either
13:05:05 <Moggle> which is sad.
13:06:36 <dmwit> I think you can do serialization and deserialization with a record of behaviors.
13:07:06 <dmwit> However, you need to have some place that knows all the possible records.
13:07:07 <Moggle> you can, but ideally i'd want it to be automatic
13:07:12 <Moggle> and as easy as "deriving Binary"
13:07:18 <dmwit> ...
13:07:19 <Moggle> ... wow I feel whiny and entitled.
13:07:26 <Moggle> i am a horrible person, aren't I?
13:07:30 <Moggle> i need to deal with this.
13:08:06 <Moggle> also you wouldn't even need a place that knows all the possible records
13:08:17 <Moggle> if you were willing to abuse some good old unsafePerformIO
13:08:30 <Moggle> ... probably?
13:09:20 <ReinH> The expression problem is more commonly seen as the tension between connascence of type and connascence of behavior (sometimes you want to put like types together but sometimes you would prefer to put like behaviors together)
13:10:09 <ReinH> One Haskell feature that helps manage these cross-cutting concerns is typeclasses
13:10:26 <Moggle> Existential types are indeed a godsend
13:10:37 <elliott> I've always found the idea of solving the expression problem a bit amusing.
13:10:46 <shachaf> ==elliott
13:10:52 <ReinH> elliott: you don't solve it, you just mitigate it
13:10:52 <elliott> to me it expresses a fundamental tension that can't be worked around.
13:11:00 <elliott> you can "cheat" only by changing the goalposts.
13:11:03 <shachaf> It would be better called the "expression decision" or "expression consideration".
13:11:03 <ReinH> yep
13:11:29 <geekosaur> "expression headache"
13:11:31 <shachaf> The expression dilemma.
13:11:34 <ReinH> my point above is that it's not a problem to be solved, it's a tension to be weighted
13:12:12 <ReinH> And as long as your langauge offers both ways to group things you can make a decision based on your own context.
13:12:17 <elliott> also, I don't like the description in terms of recompiling code and stuff.
13:12:26 <ReinH> elliott: right, that's why mine specifically avoids that
13:12:38 <elliott> I guess you can solve the "expression problem" in those terms, it's just a compiler architecture question mostly or something.
13:12:39 <haasn> the expression expression
13:12:44 <Moggle> hmm, if there was some sort of way with template haskell to get all implementations of a typeclass, I could probably solve my own problem in a lovely typesafe way
13:12:48 <ReinH> right now we have an expression expression problem problem
13:12:54 <elliott> but I think it's more useful to use the name to refer to the fundamental trade-off involved.
13:13:03 <ReinH> the expressing expression problem problem?
13:13:12 <ReinH> elliott: did you read what I said :p
13:13:18 <elliott> yes. I'm monologuing.
13:13:25 <ReinH> elliott: oh, sorry, proceed :)
13:13:33 <haasn> > fix $ \xs -> "expression " ++ xs ++ " problem"
13:13:35 <elliott> also, it's just a special case of the covariant/contravariant power tension.
13:13:39 <Moggle> Oh, cool, there is
13:13:44 <elliott> like everything else in software architecture.
13:13:51 <Moggle> alright, time to abuse template haskell to the fullest when I get a chance
13:13:55 <haasn> lambdabot? :(
13:13:58 <pqmodn> > helo?
13:14:18 <Rarrikins> haasn: I can't see any problem with that.
13:14:43 <haasn> the problem is lambdabot isn't in this channel (or running, probably)
13:15:17 <geekosaur> lambdabot likes to get "stuck" when there are connectivity issues like freenode has been having today
13:15:57 <elliott> oh.
13:16:27 <elliott> I like the part where 90% of running lambdabot is noticing when it quits and starting it again. maybe I should run it under a supervisor.
13:16:32 <ReinH> haha
13:16:40 <ReinH> elliott: definitely :)
13:16:51 <ReinH> you can just use whatever init-like your OS provides :)
13:17:00 <ion> So it doesn’t have an internal supervisor? :-P
13:17:08 <elliott> it would be kinda silly if @quit made it restart.
13:17:13 <haasn> while true; do lambdabot; done
13:17:27 <ReinH> elliott: why would you want it to @quit :p
13:17:30 <ion> until lambdabot; do :; done
13:17:38 <ion> And return 0 on quit
13:17:40 <ReinH> elliott: you can have @quit shell out to control your init-like :)
13:17:56 <elliott> but if I modified the code, then I'd do better to fix whatever actual bug makes it die.
13:18:11 <ReinH> elliott: sure, but supervision is its own reward
13:19:34 * hackagebot git-date 0.2.1 - Bindings to the date parsing from Git.  http://beta.hackage.haskell.org/package/git-date-0.2.1 (StephenWeber)
13:20:49 <elliott> ReinH: "rewarding" isn't a word I associate with lambdabot.
13:21:40 <dwcook> "Restart on non-0 exit" and "non-0 exit on error" sounds the sanest to me.
13:21:56 <dwcook> Imagine you encountered a separate bug that also made it quit – You would still be able to do that.
13:22:07 <ion> elliott: It was a typo for “retarding”.
13:22:38 * ion notices 1200 users in the channel.
13:22:48 <ReinH> elliott: hah
13:23:05 <ReinH> dwcook: totally reasonable.
13:23:13 <ReinH> most init-likes support that model
13:23:55 <dwcook> It's not like lambdabot is segfaulting, is it? It's doing something that would raise an exception?
13:24:43 <elliott> I have no idea.
13:25:18 <geekosaur> I never tried to diagnose it when I was running one
13:27:17 <geekosaur> one thing I can say is that it wasn't just lambdabot losing its connection; seemed like a flood of users getting "disconnected" by netsplit sometimes caused it to lock up
13:28:22 <ion> lambdabot is truly a prime example of Haskell engineering.
13:29:37 <Cale> heh
13:30:49 <sm> elliott: don't forget to limit the connection rate & number of attempts in your supervisor, to avoid tripping freenode alarms
13:32:18 <sm> haasn's while loop looks a tad risky
13:32:43 <haasn> while true; do lambdabot; sleep 10; done
13:33:59 <sm> haasn: bah now there's a mandatory 10s of downtime
13:34:34 <sm> but I like the simplicity
13:35:15 <ion> until lambdabot; do sleep 10; done
13:35:19 <aranea> Why isn't that possible? {f :: Int -> Int; f 0 = 1; f = id} Sure, you can do "f x = x", but...
13:36:20 <Moggle> because there's a difference between f x = id x and f = id
13:36:33 <Moggle> though i admit i am not wise enough to know what it is exactly
13:36:45 <ion> I agree with enforcing all cases to have the same number of parameters for clarity and consistency.
13:36:46 <Moggle> the dreaded monomorphism restriction has bit me enough to know there is, though.
13:36:48 <haasn> consider f = undefined
13:36:57 <haasn> let f = undefined in f `seq` ()
13:37:08 <haasn> vs f x = undefined x in f `seq` ()
13:37:45 <haasn> so if anything, it would *have* to be an automatic eta-expansion
13:48:08 <queequeg> I am having a hard time reading this:  (.) :: (b -> c) -> (a -> b) -> a -> c
13:48:59 <haasn> “(.) is a function that, given a function of type (b -> c), a function of type (a -> b) and an ‘a’, will give you a ‘c’”
13:49:16 <haasn> or in other words, “given a function of type (b -> c) and a function of type (a -> b), will give you a function of type a -> b”
13:49:52 <apples> haasn: typo there :)
13:49:59 <haasn> a -> c
13:51:03 <Bram> queequeg: you have 2 functions, one of type a -> b and one of type b -> c and you want to merge them to have a -> c, this is the usage of "." (but you just write the b -> c before the a -> b)
13:52:23 <queequeg> I guess there is something sideways in my mind about the (b->c) coming first.  It matches usage order, but it seems like logically the illustration of the process would put it after (a->b).
13:52:53 <Rarrikins> queequeg: The types aren't about what happens first. They're just about what functions are produced with only some of the arguments.
13:53:22 <queequeg> Ok.  That helps.  Thank you.
13:53:34 <Dodek> queequeg: the point basically is so that (f . g)(x) is the same as f(g(x))
13:53:38 <Rarrikins> queequeg: No problem.
13:53:40 <Bram> queequeg: it is the same order than function call, like a(b(c)) ~= (a.b)(c)
13:58:07 <acomar> dcoutts: Is there any chance of getting a separate C++ sources/headers field for cabal packages? Having the user pass --with-gcc=g++ works, but it's brittle (like you can't user cabal haddock for example).
13:58:42 <acomar> dcoutts: I'd try and add it myself, but my hands are full at the moment
14:13:05 <user123abc> could somebody help me to understand why type inference is failing on the following monadic vector code:
14:13:11 <user123abc> http://lpaste.net/4572548554144350208
14:13:55 <user123abc> I suppose I can randomly add type annotations that I half understand from Hoogle, but why isn't it clear that I want a vector of Pos?
14:14:39 * hackagebot laborantin-hs 0.1.0.0 - an experiment management framework  http://beta.hackage.haskell.org/package/laborantin-hs-0.1.0.0 (LucasDiCioccio)
14:15:05 <user123abc> this code is copied from the example use of create function given here: http://hackage.haskell.org/package/vector-0.10.9.1/docs/Data-Vector-Generic.html
14:16:45 <acowley> user123abc: How would it every know which vector type to use?
14:17:07 <acowley> e.g. Storable, Unboxed, Boxed
14:17:49 <FreeFull> user123abc: Haskell is made so that adding a new typeclass instance doesn't change the way existing code works
14:18:16 <user123abc> acowley, ah, that makes sense
14:18:38 <user123abc> FreeFull, how does that relate to my issue?
14:19:07 <user123abc> not saying it doesn't, just that I don't fully grok stuff like that
14:19:09 <user123abc> what did you mean?
14:19:33 <FreeFull> :t V.create
14:19:34 <lambdabot> Couldn't find qualified module.
14:19:41 <FreeFull> :t Data.Vector.create
14:19:42 <lambdabot> (forall s. ST s (Data.Vector.Mutable.MVector s a)) -> Data.Vector.Vector a
14:20:03 <FreeFull> :t Data.Vector.Generic.create
14:20:04 <lambdabot> Data.Vector.Generic.Base.Vector v a => (forall s. ST s (Data.Vector.Generic.Base.Mutable v s a)) -> v a
14:20:24 <acowley> user123abc: It would matter if there was only one instance of the class, so *of course* you're referring to that instance… but the type checker would disagree with you for the reason FreeFull mentioned.
14:20:24 <FreeFull> user123abc: Your code doesn't specify anywhere what kind of Vector it wants
14:24:51 <user123abc> it does make sense abstractly that I'd have to specify the type of vector, so I guess the issue is that I don't understand how Vector's using the type/class system to achieve that
14:25:10 <user123abc> I'll probably save such an attempt for later, though
14:31:47 <acomar> acowley: do you know off the top of your head what exactly MatExprs are for? It looks like they're just a lazy evaluation trick, but if you know of some other use for them...
14:34:31 <acowley> acomar: No, I think that's it. But I've never done anything with them.
14:34:55 <FreeFull> user123abc: You could use a non-generic create
14:35:05 <acomar> Ok, then I'm going to force the conversion back to Mat when I wrap them, and rely on lazy evaluation on the haskell side.
14:35:19 <acowley> How would it be lazy?
14:35:49 <user123abc> FreeFull, that's what I'm doing now
14:35:57 <acomar> m3 = m1 .+. m2 won't evaluate till m3 is forced (in the pure api)
14:36:05 <acowley> Ah, pure API
14:36:20 <aranea> I want to map a function over a list, but at the same time that mapping function has to read and write a global state.
14:37:11 <user123abc> though I think I will try to understand what's going on, since it's not the first time I've run into issues with MVector
14:37:16 <acowley> acomar: But won't it still force things too early if you don't use MatExprs?
14:37:17 <acomar> yea, the monadic API is necessarily strict. I don't think it's worth keeping MatExprs around in Haskell just for lazy evaluation
14:37:17 <user123abc> and I'd like to use it more
14:38:05 <acowley> I mean, it's lazy in that the whole chain of operations isn't run until the result is forced, but the intermediate operations will be individually strict, whereas OpenCV can do clever things with composite operations.
14:38:10 <acomar> acowley: how? m4 = m3 + m5, reading m4 forces m3, m5, m2, and m1, but reading m5 doesn't force any of the others
14:38:15 <FreeFull> user123abc: The thing is, you didn't use MVector there, just "any vector"
14:38:37 <acomar> acowley: yea, that's what I'm wondering -- how much do they do with intermediate representation
14:38:41 <user123abc> ok, it's not the first time I've had issues with any vector
14:38:46 <user123abc> and I'd like to use any vector more :)
14:38:47 <user123abc> :P
14:39:03 <aranea> it's for my Prisoner's dilemma project: I've got a list of pairs of competing agents, I want to let each of them make one game step (= a map over the pair list), but each game step also need to update the "scores" list
14:39:13 <acowley> acomar: Suppose we have "let m3 = transpose m1 .+. m2" your API will do the transpose, then do the addition. MatExpr's can make the transpose implicit by just controlling how it indexes into m1 when doing the addition.
14:39:25 <user123abc> http://lpaste.net/3462423065747521536
14:39:30 <acomar> acowley: ahh, good point
14:39:41 <acowley> user123abc: You should just pick a vector type
14:39:57 <user123abc> why does the parameter of vector there need a kind : * -> *
14:40:28 <acowley> user123abc: Stop using the Generic module
14:40:30 <user123abc> :t Vector.!
14:40:33 <lambdabot> parse error on input `Vector.!'
14:41:06 <acowley> user123abc: Using a concrete vector type will give you the Vector type constructor you're expecting
14:41:07 <user123abc> acowley,  whether or not I use it, I'd like to understand what's going on
14:41:33 <quup> hi, trying to get color in ghci, is `ghci --colour` supposed to work in v7.4.2? I get the error "ghc: unrecognised flags: --colour" (yes it says ghc, I call ghci though)
14:41:45 <acowley> user123abc: With Generic, you might say, "(Monoid a, Vector v a) => v a -> a"
14:42:00 <acowley> user123abc: WIth a concrete vector type, you'd say, "Monoid a => Vector a -> a"
14:42:45 <user123abc> but isn't Vector Int a valid instance of Vector?
14:42:59 <user123abc> !: Vector v a => v a -> Int -> a
14:43:13 <acowley> You're going to need to qualify these names if you want to mix and match
14:43:32 <acowley> Data.Vector.Storable.Vector is an instance of Data.Vector.Generic.Vector
14:43:55 <user123abc> what do you mean by mix and match?
14:44:17 <acowley> "but isn't Vector Int a valid instance of Vector?"
14:44:27 <acowley> Those two uses of the word "Vector" are different
14:44:52 <user123abc> oh, I see
14:45:38 <user123abc> I was reading off the list of instances here: http://hackage.haskell.org/package/vector-0.10.9.1/docs/Data-Vector-Generic.html#t:Mutable
14:45:45 <user123abc> and yeah, those are all different vectors
14:45:59 <acowley> So using idiomatic qualified imports, you could VS.Vector Int is an instance of G.Vector
14:46:15 <user123abc> yeah, I see that
14:47:45 <user123abc> ok, and I see why my use of vector expected a kind : * -> *
14:47:47 <user123abc> Vector
14:48:25 <bearclaw> hmm, I think I understood something, 'fun <$> io_stuff' can be read as "do io_stuff, and pass the result to fun", it's kind of a callback.
14:50:18 <quchen> Not really, "do stuff and put result into" is more like (>>=).
14:50:52 <quchen> "fun <$> io_stuff" is "do io_stuff, and then modify the result with 'fun'".
14:50:59 <ReinH> acowley: so I'm checking out the vinyl-gl examples. They render on OS X and ESC quits but arrows don't work. Have you seen this?
14:51:15 <acowley> ReinH: No
14:51:20 <ReinH> ok
14:51:23 <ReinH> thanks
14:51:23 <acowley> ReinH: I use OS X, too
14:51:27 <ReinH> hmm
14:51:32 <quchen> Wait, I just wrote the same sentence twice, sort of. Nevermind. It makes sense in my head but is rubbish when I spell it out haha
14:51:51 <ReinH> acowley: which glfw are you using?
14:52:19 <ReinH> and which GLFW-b?
14:52:21 <ReinH> if you don't mind
14:52:35 <acowley> ReinH: The GLFW-b version is constrained in the examples .cabal file
14:53:02 <acowley> ReinH: I'm using glfw 2.7.9
14:53:16 <ReinH> acowley: I thought GLFW-b used glfw 3?
14:53:31 <acowley> The new version is problematic. I can either work to fix up its cabal so I can still use it in GHCi, or I can wait for 7.8.
14:53:40 <acowley> ReinH: That's why it's constrained in the .cabal file to be < 1
14:53:46 <ReinH> acowley: oh GLFW-b < 1 used glfw 2?
14:53:47 <ReinH> makes sense
14:54:08 <ReinH> acowley: what does "its" refer to in "fix up its cabal"?
14:54:20 <acowley> I currently run with glfw from brew
14:54:37 <acowley> But GLFW-b wants to build its own copy of glfw
14:54:42 <ReinH> acowley: ah, the packages have been split out into glfw2 and glfw3
14:54:56 <ReinH> but it doesn't matter because GLFW-b is building its own
14:55:05 <acowley> The problem is that something goes wrong with statically linking the ObjC stuff
14:55:10 <ReinH> :/
14:55:18 <acowley> But if you want dynamic linking, the library needs to be in a known location
14:55:22 <acowley> for me, that is /usr/local/lib
14:55:38 * elliott wants finished SDL 2 bindings!
14:55:41 <ReinH> right same
14:55:41 <acowley> At least, the story goes something like that.
14:55:48 <ReinH> acowley: GUI is such a ghetto :/
14:55:59 <ReinH> elliott: +1
14:56:06 <acowley> ReinH: I've been really happy with GLFW-b before these recent changes
14:56:12 <acowley> I can update code and relaunch from ghci
14:56:16 <acowley> it's great
14:56:17 <ReinH> acowley: so do you have a recommended "do this shit and you can start using GLFW-b and/or vinyl-gl" path?
14:56:56 <acowley> ReinH: No. Any such instructions would be mac only, and I feel like it's better to just wait out the 7.8 release to see how things shake out.
14:57:26 <ReinH> acowley: I am on mac and I was asking specifically for me :)
14:58:33 <acowley> ReinH: I would have thought using a GLFW-b < 1 and having brew install the dylib would be sufficient
14:58:54 <ReinH> acowley: It's weird that ESC works but arrow keys don't.
14:58:55 <ReinH> it renders fine
14:58:59 <acowley> It's very weird
14:59:17 <acowley> Can you stick some printfs in the Window code to see if it's getting key press events?
14:59:20 <ReinH> I know arrow keys are sometimes weird
14:59:23 <acowley> Maybe it's a KeyCode thing
14:59:31 <ReinH> yeah, I might switch to wasd
14:59:31 <acowley> I don't know why I just wrote that as "KeyCode"
14:59:33 <ReinH> just to see
14:59:52 <acowley> My keyboard is US English, too, in case that's a variable
14:59:53 <ReinH> wait, I can run these with ghci?
14:59:58 <ReinH> acowley: same
15:00:00 <acowley> ReinH: Yes!
15:00:02 <ReinH> yay!!!
15:00:14 <ReinH> that's great
15:00:17 <ReinH> ok let's see
15:01:36 <ReinH> acowley: is there any way to get ghci to load the glfw-b version I need for Game2D? Something something cabal-sandbox?
15:01:54 <acowley> cabal repl?
15:03:26 <ReinH> acowley: man Cabal 1.18 couldn't come at a better time
15:03:35 <ReinH> unless that time was before the time it came
15:03:46 <acowley> I love it except that I'm not thrilled with haskell-interactive in emacs
15:03:58 <ReinH> don't care, use vim! :D
15:04:03 <acowley> impossible
15:04:18 <ReinH> It's beyond impossible. It's unpossible!
15:05:24 <acowley> I'm glad you see my point
15:05:33 <NiceOneBrah> has anyone here read Concrete Mathematics? I'm looking for a math book or course to help me improve my problem solving skills and am curious if anyone has any recommendations.
15:05:48 <startling> NiceOneBrah, what's your background?
15:06:22 <NiceOneBrah> startling: I have an undergrad degree in CS and have been working as a backend web developer in the industry for 4 years
15:06:29 <roconnor> NiceOneBrah: --> #haskell-blah
15:06:55 <user123abc> NiceOneBrah >>= #haskell-blah
15:07:10 <bearclaw> if I do data D = D (Int, Int) deriving (CLASS), haskell will automatically write Instance Foo D and copy the code from Instance Foo (Int, Int)  with wrapping/unwrapping?
15:07:19 <acomar> acowley: Ok, I added MatExprs back in. I left MatExpr operations pure because they **should** be referentially transparent
15:07:37 <startling> bearclaw: with GeneralizedNewtypeDeriving switched on, yes.
15:08:00 <acomar> acowley: you have to manually promote Mats to MatExprs and force MatExprs back to Mats in order to actually use operations, which is inconvenient, but I haven't thought of a good way around that yet
15:08:03 <acowley> acomar: How do you handle the conversion back to a Mat?
15:08:15 <acowley> hah
15:08:18 <acowley> okay
15:08:29 <startling> bearclaw: oh, that would need to be a newtype rather than a data in that case
15:08:36 <acowley> acomar: I don't think it's worth worrying about too much
15:08:52 <bearclaw> startling: how can data derive from Show then?
15:09:17 <startling> bearclaw, that's a baked-in mechanism provided by GHC.
15:09:35 <bearclaw> ah, so it does not generalize to arbitrary classes
15:09:39 <startling> Correct.
15:10:19 <startling> it's only for a handful of prelude things, and there are extensions for Functor, Foldable, and Traversable.
15:10:53 <startling> there's also the extension GeneralizedNewtypeDeriving, which allows you to derive any instance that a type wrapped in a newtype has.
15:11:11 <startling> Remember that newtypes may only have one member.
15:11:19 <bearclaw> but the record syntax is not a newtype
15:11:28 <startling> hm?
15:11:39 <bearclaw> or I can use record syntax (the one that autocreate accessors) with newtype?
15:12:00 <startling> yes, but only with one member of the record.
15:12:08 <roconnor> bearclaw: you can use record syntax (for one field) in a newtype.
15:12:12 <startling> newtype Mything = Mything { toInt :: Int } is valid.
15:12:39 <acomar> acowley: yea, don't plan to. I'm mostly worried about every function I let out of CV before I implement your dupping trick
15:13:01 <acomar> but I think these operations are safe
15:13:03 <bearclaw> aha, no, well, I want the unique field to be a tuple
15:13:10 <bearclaw> and accessor from its individual content elements
15:13:11 <acomar> they're mathematical functions after all
15:13:13 <acowley> acomar: Yeah, it's good to be conservative for the low-level wrappings
15:13:21 <acowley> acomar: Though you do have to be careful with OpenCV
15:13:35 <acowley> it does all kinds of nasty things like re-use scratch space attached to various objects
15:13:44 <bearclaw> so I have to chose the one I'll write manually, the accessor, or the instance
15:13:54 <startling> bearclaw, function composition
15:14:08 <startling> but yeah, usually people go with writing the instance manually.
15:14:20 <startling> newtype on a tuple often isn't as convenient as a real record.
15:14:26 <startling> what instance are we talking about?
15:15:02 <bearclaw> I'm having fun binding the middleware I'm working on at work
15:15:03 <acomar> acowley: yuck! I think what I'll do is leave force in CV for now, since that's the operation that actually gives you back a Mat -- there are no provided operations to look inside a MatExpr
15:15:15 <bearclaw> So I made a class Serializable, with instances for all tuple size
15:15:31 <acomar> acowley: that should guarantee referential transparency even if OpenCV tries something really weird
15:15:34 <startling> bearclaw: ah. this is for binary serialization?
15:15:38 <bearclaw> And then I have basic struct for which I would like to use record syntax, but they are tuple basically
15:15:42 <bearclaw> startling: yes
15:15:51 <startling> bearclaw, take a look at http://hackage.haskell.org/package/cereal if you haven't.
15:16:13 <ReinH> bearclaw: newtype MyThing = MyThing { toInt :: Int } is not fundamentlly different from newtype MyThing = MyThing Int; toInt (MyThing i) = i
15:16:21 <startling> bearclaw, you could write instance Serializable MyThing where serialize (MyThing a b c) = serialize (a, b, c)
15:16:50 <startling> but I really would recommend using an existing library instead.
15:17:08 <startling> there's even automatic derivation somewhere iirc
15:17:20 <bearclaw> startling: I have to implement our existing binary protocol, but I'll definitely look at this thanks
15:17:46 <startling> bearclaw, cereal gives you primitives to implement just about any protocol
15:18:05 <bearclaw> ReinH, startling: My problem is that I have to write code with 0 semantic value here
15:18:16 <startling> but yeah, I guess using the predefined instances wouldn't be so great for you.
15:18:43 <ReinH> @hackage binary
15:18:44 <lambdabot> http://hackage.haskell.org/package/binary
15:18:46 <ReinH> ^ will help
15:19:25 <startling> ReinH: more so than cereal?
15:20:03 <bearclaw> huhu, http://lpaste.net/93715  VS http://hackage.haskell.org/package/cereal-0.4.0.0/src/src/Data/Serialize.hs
15:20:12 <bearclaw> I guess there aren't 1000 ways to do this
15:20:33 <startling> :)
15:20:38 <bearclaw> I was hoping for more dark magic somehow
15:21:03 <acowley> what dark magic is wanted?
15:21:08 <startling> what's your "signature" thing for?
15:21:14 <ReinH> startling: maybe not.
15:21:28 <bearclaw> the metadata layer represents methods with (name, signature)
15:21:36 <startling> ah.
15:21:45 <bearclaw> and uses that to find if a call is possible, and resolve overloads
15:22:07 <bearclaw> acowley: well, for instance, avoiding the duplication on tuples
15:22:56 <acowley> Okay
15:22:58 <acowley> don't use tuples
15:23:00 <acowley> use HList
15:23:02 <bearclaw> you can't generalize code like   "applytoalltuplemembers functorthatworksonallelementtypes arbitrarytuple"
15:23:05 <acowley> or something like vinyl
15:23:32 <acowley> You do the induction with type class instances, so you only need two
15:24:30 <bearclaw> ah, so that "applytoalltuplemembers" can be implemented using some advanced voodoo?
15:25:20 <acowley> Yes
15:25:49 <startling> it turns out to be kind of gross in practice though.
15:26:13 <acowley> syntactically?
15:26:42 <acowley> I do this with OpenCL code to have a heterogenous list of asynchronous computations that I can then wait on en masse
15:26:49 <k0001> Haddock is a fish! Who would have thought of that? https://en.wikipedia.org/wiki/Haddock
15:27:04 <startling> well, it turns out to be not very much better than deriving things yourself.
15:27:05 <startling> ime
15:27:11 <acowley> What?
15:27:11 <startling> k0001, :)
15:27:27 <acowley> How is it not better than those instances poor bearclaw has?
15:27:50 <acowley> You're replacing 8 instances with 2
15:28:11 <acowley> And when you realize you want a 9-tuple? You're already covered.
15:28:13 <haasn> k0001: apparently, Java is an island
15:28:28 <donri> python is a snake!
15:28:36 <ReinH> acowley: omg cabal repl Just Works
15:28:36 <haasn> and c is the speed of lgiht
15:28:39 <haasn> light, too
15:28:50 <acowley> ReinH: awesome, right?
15:29:03 <acowley> ReinH: I find it frustrating when people keep saying it's not possible
15:29:06 <haasn> Whoa, cabal repl
15:29:10 <dcoutts_> ReinH: glad you like it :-)
15:29:14 <haasn> Is that like launching a GHCi instance with the locally built package?
15:29:18 <ReinH> dcoutts_: <3 <3 <3
15:29:35 * jfischoff thinks induction with type classes is nifty
15:29:35 * bearclaw can generalize more with his C++ and thus is sad
15:29:47 <ReinH> acowley: this OpenGL stuff still isn't playing nice though :/
15:30:00 <acowley> bearclaw: Scroll to the bottom of http://hackage.haskell.org/package/vinyl-0.1.3/docs/src/Data-Vinyl-Rec.html#Rec
15:30:17 <donri> haasn: yes, plus lots of details work, like preprocessors and :reload
15:30:27 <acowley> That's defining Storable instances for vinyl records
15:30:29 <haasn> donri: that is quite awesome
15:30:30 <k0001> haasn: haha
15:30:34 <acowley> which is a little more complicated than you want
15:30:51 <acowley> ReinH: Noooo, why not?
15:31:05 <donri> haasn: and ffi for bundled c-sources, etc etc, just works
15:31:13 <[swift]> saw vinyl mentioned and it reminded me of a question i've been wondering about: AFAICT (and I could easily be missing something) neither Lens nor Vinyl lets you use the same accessor for different records with the same field name. is there a standard solution for that?
15:31:31 <donri> [swift]: vinyl does do t hat
15:31:32 <donri> that
15:31:51 <donri> lens kinda-sorta with makeClassy
15:31:54 <acowley> Can inferior haskell mode be made to work with cabal repl?
15:32:03 <[swift]> donri: nice! i missed that in my reading; will look into it more
15:32:08 <bearclaw> acowley: the whole page causes maybe 20 failures of my brain's haskell parser, too many features I don't know about yet :)
15:32:13 <donri> although not really re: makeClassy
15:32:28 <acowley> bearclaw: It's not the simplest example, I just wanted to demonstrate that it's used in practice
15:32:39 <acowley> bearclaw: So it's not just me sitting here saying that in theory this can kind of work
15:33:06 <jfischoff> Printf also does it
15:33:16 <haasn> bearclaw: starting with the half-page of language pragmas?
15:33:24 <jfischoff> @hoogle jmacro-rpc
15:33:24 <lambdabot> package jmacro-rpc
15:33:25 <lambdabot> package jmacro-rpc-happstack
15:33:25 <lambdabot> package jmacro-rpc-snap
15:33:34 <jfischoff> yeah there is an example in there
15:33:39 <acowley> haasn: I said scroll to the bottom! If you were following instructions, you wouldn't have seen that :P
15:33:44 <jfischoff> pretty much all of olegs code :p
15:34:09 <acowley> {-# LANGUAGE TheRealHaskell #-}
15:35:53 <bearclaw> acowley: hehe, that's exactly what is woriing me at this point. Is there one haskell that will suit my needs, or am I well in the realm of experimental stuff that is still moving
15:36:30 <acowley> bearclaw: Haskell is always moving, you need to let go and ride the wave.
15:36:33 <acowley> :)
15:37:05 <applicative> quchen: elliott here is marlow's <*> for haxl and a short proof it isn't `ap` http://lpaste.net/93716
15:37:11 <bearclaw> looking at how easily I found answers to my noob questions like "how to split a list" on stackoverflow haskell is big enough, but does it still hold for stuff like Vinyl?
15:37:57 <haasn> you just have to reduce the size of the context instead, and Haskell seems big in comparison
15:38:15 * haasn suggest lenses
15:38:54 <bearclaw> a lens to make it look bigger? :)
15:39:11 <haasn> I heard lens HEAD is getting telescopes now
15:39:20 <haasn> (but don't let anybody know you got that from me)
15:40:23 <applicative> quchen elliott the 'proof' proceed by replacing IO by the identity functor
15:40:27 <acowley> bearclaw: You mean the haskell community isn't big enough to answer questions about fringe techniques?
15:40:40 <ReinH> dcoutts_: is there a ghci : cabal repl :: runghc :: ?
15:40:59 <lispy_> ReinH: I don't think so
15:41:03 <dcoutts_> ReinH: sorry, I don't understand the question
15:41:04 <applicative> cabal test
15:41:16 <acowley> ReinH: I just add executables to the .cabal and use cabal run
15:41:18 <ReinH> dcoutts_: can I run a haskell file with cabal like I would with runghc?
15:41:20 <ReinH> ah
15:41:38 <dcoutts_> ReinH: no, there's a run command for exes though
15:41:48 <ReinH> does that require building first or does it automatically build?
15:42:31 <ReinH> looks like the latter
15:44:34 <ReinH> dcoutts_: that's perfect :)
15:44:50 <bearclaw> acowley: I'm trying to get a g,rasp of what haskel is, and am discovering that some stuff I'd realy want (generalizing over tuple, inheriting the tuple instance from a record type) are indeed fringe stuff
15:45:15 <dcoutts_> bearclaw: right, we don't treat tuples as vectors
15:45:17 <dcoutts_> they're records
15:45:49 <dcoutts_> for vectors we use lists, vectors, arrays etc
15:46:41 <acowley> bearclaw: I guess it's fair if you want to say that tuple instances is something that is "hard" in classic Haskell, but why look backwards? A great benefit of Haskell is it's velocity.
15:47:03 <haasn> I've never really seen much of a use-case for high tuples
15:47:21 <haasn> I've used 3 here and there but I can't really actively remember wanting 4 or higher
15:47:57 <haasn> But if you do want to abstract over them, you can get a lot for free by naively stacking them eg. (a,(b,(c,d))) -- not pretty, of course, but better than nothing
15:47:58 <ReinH> acowley: pun intended?
15:48:43 <ReinH> If you want something that works like a vector you almost certainly want Data.Vector or Linear.V*
15:48:58 <ReinH> which are nice, modern libraries with lots of useful typeclass instances
15:49:19 <acowley> Yeah, right-nested tuples make the point pretty well
15:49:44 <ReinH> haasn: and if you want to map over the d you just need fmap.fmap.fmap.fmap :D
15:49:56 <haasn> over $ _2._2._2._2
15:50:01 <haasn> do you even lens
15:50:12 <ReinH> haasn: just saying :p
15:50:48 <ReinH> is that one too many fmaps/_2s? Who knows! That's why they suck!
15:51:15 <haasn> (yes)
15:51:19 <haasn> (to both)
15:51:21 <ReinH> yep
15:51:24 <acowley> big tuples come from an aversion to naming things :/
15:51:26 <ReinH> but you have to count
15:51:32 <ReinH> and I use computers precisely so I don't have to count things
15:51:38 <ReinH> that's their job
15:51:40 <acowley> How many computers do you have?
15:51:47 <ReinH> acowley: let me ask my computer-counting computer
15:51:49 <Kevin-_-_> I'm trying to construct a list of non-duplicating elements from another list.  Is this the right direction of doing that?  foldr (\x xs -> if not (x == xs) then x:xs else xs) [] [1,2,2,3,4,5,5,6]
15:51:56 <Kevin-_-_> original list is sorted
15:52:08 <acowley> Kevin: What is the type of your lambda expression?
15:52:12 <bearclaw> http://lpaste.net/93717 <--ok, this is redundant and I hate it, but I have to admit type inference is impressive coming from the C++ world
15:52:23 <haasn> acowley: namp -sP 192.168.0.0/24 | grep 'Host is up' | wc -l
15:52:31 <haasn> nmap, too
15:52:32 <acowley> haha
15:52:34 <ReinH> Kevin-_-_: more specifically, what is the type of x == xs?
15:52:42 <haasn> counting is for losers!
15:52:56 <Kevin-_-_> well isn't it a [a] -> [a]?
15:53:04 <ReinH> Kevin-_-_: what is x?
15:53:11 <Kevin-_-_> (Eq a) => a?
15:53:16 <ReinH> what is xs?
15:53:20 <acowley> Okay, so if the type of the lambda is a -> [a] -> [a]
15:53:32 <acowley> then what is the type of == in the expression "x == xs"?
15:53:36 <ReinH> :t foldr
15:53:37 <lambdabot> (a -> b -> b) -> b -> [a] -> b
15:53:40 <Kevin-_-_> ah ok
15:53:52 <Kevin-_-_> so it's comparing 1 element to the rest of the list then?
15:53:54 <haasn> :t elem -- Kevin-_-_
15:53:55 <lambdabot> Eq a => a -> [a] -> Bool
15:54:06 <ReinH> Kevin-_-_: currently, yes
15:54:23 <haasn> :t nub -- Kevin-_-_ the function you're writing, in case you aren't doing this as exercise but as part of actual code :P
15:54:24 <lambdabot> Eq a => [a] -> [a]
15:54:45 <haasn> also if your type is Ord a and not Eq a you can write a much more efficient version
15:54:48 <Kevin-_-_> no it's an exercise, I can't use nub
15:54:58 <Kevin-_-_> I tried at first and they said no :)
15:55:13 <haasn> and if you don't want to preserve order, you can just go via Set. And if your input list is strictly ascending, you can make it even more efficient!
15:55:14 <Kevin-_-_> haasn: how would that work?
15:55:16 <ReinH> :t mapMaybe
15:55:17 <lambdabot> (a -> Maybe b) -> [a] -> [b]
15:55:46 <Kevin-_-_> it not strictly increasing originally, the output will be
15:55:50 <haasn> Kevin-_-_: use a ‘Set a’ to store which elements you've already seen, which has O(log n) lookup rather than O(n) lookup like the [a] does
15:56:18 <ReinH> haasn: the list is sorted
15:56:45 <ReinH> Kevin-_-_: do you know how nub is implemented?
15:56:45 * haasn will shut up now
15:56:52 <ParahSailin> @src nubBy
15:56:52 <lambdabot> nubBy eq []             =  []
15:56:52 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
15:57:05 <Kevin-_-_> if it's part of Data.List I can't use it
15:57:06 <ReinH> ParahSailin: the explicit definition of nub is more useful here
15:57:11 <Kevin-_-_> no ReinH
15:57:12 <ParahSailin> @src nub
15:57:12 <lambdabot> nub = nubBy (==)
15:57:13 <[swift]> bearclaw: look up record puns and record wildcards; you can make the redundant code in your paste there a bit prettier if you want
15:57:40 <[swift]> bearclaw: though actually possibly more verbose =)
15:57:47 <[swift]> but take a look anyway
15:58:47 <ReinH> Kevin-_-_: look it up here http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-List.html#nub
15:59:09 <bearclaw> hmm, the c preprocessor does not support ## (concatenation)?
15:59:40 <ReinH> Kevin-_-_: there are three cases for nub'. How would you describe what they do?
15:59:54 <acowley> bearclaw: Check out cpphs
16:00:04 <bearclaw> I tried -XCpp
16:00:54 <acowley> bearclaw: https://github.com/acowley/GLUtil/blob/master/src/Graphics/GLUtil/Linear.hs
16:01:04 <geekosaur> bearclaw, ## is ANSI and ANSI cpp can't be used with Haskell because it's too syntax-aware (so doesn't work with languages that are very different from C)
16:01:14 <Kevin-_-_> if it's empty then nothing, if it's part of the array already then move on, otherwise append it to the results
16:01:15 <acowley> that example shows using ## in haskell
16:01:16 <geekosaur> cpphs has some ANSI extensions without the requirement of C syntax
16:01:21 <Kevin-_-_> so it's a double for loop then
16:01:25 <Kevin-_-_> in C
16:01:45 <ReinH> Kevin-_-_: so tht works for nubbing any list. What is special about a sorted list?
16:02:05 <Kevin-_-_> I figured if I sorted it then I could cut out some of the iterations
16:02:16 <ReinH> Kevin-_-_: (yes, it's equivalent to a double for loop and has O(n^2))
16:02:31 <ReinH> Kevin-_-_: yes, but why? What is special about the location of duplicates?
16:02:56 <Kevin-_-_> they're right next to each other
16:02:58 <ReinH> right
16:03:11 <ReinH> Kevin-_-_: show me a pattern match for an element, another element, and the rest of the list
16:03:29 <ReinH> if (x:xs) is an element and the rest of the list
16:03:58 <bearclaw> ah now it's using cpphs which can parse my macro, thanks
16:04:17 <Kevin-_-_> so if xs = {1,1,1,1,1,1,1} ?
16:04:34 <acowley> bearclaw: It took me a whole day to sort that out when I hit the need for it :(
16:05:08 <bearclaw> (even though the apocalypse might be a little closer than it was ten minutes ago now that I use cpp macros in hs code :p )
16:05:18 <ReinH> > let f (x:xs) = (x,xs) in f [1,2,3,4]
16:05:19 <lambdabot>   (1,[2,3,4])
16:05:30 <ReinH> Kevin-_-_: modify that to return (1,2,[3,4])
16:06:03 <acowley> Using cpp for instances is pretty darned convenient
16:06:15 <ReinH> Kevin-_-_: remember that:
16:06:21 <ReinH> > 1:2:[3,4]
16:06:22 <lambdabot>   [1,2,3,4]
16:06:44 <Kevin-_-_> ok thanks
16:06:54 <Kevin-_-_> hey I have to head out, thanks for the help
16:06:58 <ReinH> Kevin-_-_: np
16:07:49 <ReinH> Can I use lambdabot to test quickcheck properties?
16:07:54 <ReinH> Cause that would be cool
16:08:31 <donri> @check 1 == 1
16:08:36 <lambdabot>   +++ OK, passed 1 tests.
16:09:46 <donri> @check (==) <$> (reverse.reverse) <*> id
16:09:50 <lambdabot>   +++ OK, passed 100 tests.
16:10:21 <bearclaw> hmm, dammit, \n and ; are not strictly the same thing, my macro fails
16:12:16 <letrec> What does 'rigid' mean in GHC error messages? Like `a' is a rigid type variable bound by... Why can't type inference happen there? Thx
16:13:36 <mauke> > let foo :: a; foo = () in 42
16:13:38 <lambdabot>   Could not deduce (a1 ~ ())
16:13:38 <lambdabot>  from the context (GHC.Num.Num a)
16:13:38 <lambdabot>    bound by th...
16:14:32 <bearclaw> letrec: If you are in an instance, the way I read it you can't have unrelated signatures for the various implementations: class Foo where bar :: x->y,  x and y can't be specific types for a given Foo impl
16:15:16 <bearclaw> But I'm not entirely sure as to what exactly is allowed
16:16:03 <Saizan> letrec: rigid roughly means that it's a type variable bound in an outer scope, so much like a lambda bound variable you can't assume it's of a particular form
16:16:07 <acowley> letrec: http://stackoverflow.com/questions/4629883/rigid-type-variable-error
16:18:05 <bearclaw> acowley: on that matter, things like "class Foo x where bar :: x -> y -> z" compiles, but can't be implemented right?
16:18:18 <letrec> Ok, thanks. I'm actually defining a function of type :: StateT (ChannelS a) IO ()  However when I put the type signature, GHC complains that I make assumption on what a is (but would like to keep it generic if I understand). How can I have a type signature and compile?
16:18:53 <letrec> (without replacing a by what it really is as it's a complex type)
16:19:02 <Saizan> letrec: well, the problem is in your function body, there's something that's making the polymorphism impossible
16:19:16 <acowley> bearclaw: right
16:20:03 <Saizan> letrec: what are you trying to accomplish exactly? do you want the caller of your function to not know what type you're relly using in place of 'a'?
16:20:16 <Saizan> *really
16:21:19 <letrec> Saizan: Ok, makes sense. So I need to declare the type with the actual type for a.. When I remove the signature it works fine. I wanted to add the signature for documentation reason without computing the actual type for a (which is complex and might change as my code evolves).
16:21:20 <Saizan> if you just worry that the type signature would be too long you can use a type synonym
16:21:41 <letrec> Saizan: Thx
16:21:48 <acowley> letrec: And if you just don't want to type it yourself, M-t in ghc-mod to the rescue!
16:22:02 <jfischoff> or :t in ghci
16:22:08 <Saizan> C-u C-c C-t in haskell-mode
16:22:18 <acowley> magic, 3 ways
16:22:27 <Saizan> it be nice to have _ for signature though
16:22:34 <acowley> omg yes
16:22:49 <letrec> Saizan: Yeah, exactly :)
16:23:45 <Saizan> in theory it's doable, in practice it might not be easy to implement in GHC
16:25:02 <bearclaw> won't that break the type deduction system?
16:25:42 <Saizan> type inference is actually the thing that makes it possible :)
16:25:50 <acowley> bearclaw: The idea is that it works when you don't write a type at all
16:26:05 <acowley> bearclaw: So the aim is to write the general shape of the type, but let type inference fill in some holes
16:26:29 <Saizan> in fact non giving a type signature to foo would be the moral equivalent of foo :: _
16:26:41 <acowley> right, but what if you want to say foo :: Bar _
16:26:50 <acowley> so a reader knows they've got a Bar
16:26:52 <joelteon> foo :: Bar a
16:27:10 <Saizan> joelteon: Bar a is different, it forces foo to be polymorphic
16:27:23 <acowley> joelteon: That's right back the rigid type variable question
16:27:29 <joelteon> oh I didn't read, sorry
16:27:36 <Saizan> joelteon: here "Bar _" could end up being resolved to Bar Int
16:27:48 <joelteon> So could Bar a
16:28:35 <Saizan> no
16:28:54 <Saizan> try writing "foo :: Maybe a; foo = Just (1 :: Int)"
16:28:58 <Saizan> you'll get a type error
16:29:19 <joelteon> ok, but wouldn't a type wildcard in place of a be uhh
16:29:28 <bearclaw> I think it's a big change, you will have to look at the function per-instance implementation to deduce the _. At this point just the class-given signature is all you need
16:29:30 <joelteon> is that possible to implement?
16:30:07 <Saizan> _ is such a wildcard, and yeah it's possible to implement for much the same reason that type inference works, it's a matter of unification
16:30:21 <acowley> It's just saying, infer the type of this definition and match everything in the type signature that isn't a wildcard.
16:30:29 <Saizan> bearclaw: i'm not talking about methods of a class
16:30:57 <acowley> so if Bar Int is the inferred type, and the type annotation is Bar _, then that's fine. If the type annotation was Quux _, then we've got a type error.
16:32:50 <bearclaw> ah, sorry, since for 'bare' functions annotation is optional my statement doesn't make sense
16:32:53 <Saizan> if you tried to define "class C a where m :: a -> _" you'd simply get a type error because it's ambiguous
16:40:59 <ReinH> So what do people use to set up new cabal projects with correct directory structure and stuff? Just cabal init?
16:47:54 * haasn wonders if there's some ‘skeleton’ that will give him all the nice stuff like doctests and whatnot out of the box
16:50:21 <[swift]> haasn: what are doctests? documentation coverage tests?
16:50:59 <haasn> [swift]: basically, when you see a usage example in the documentation like http://ekmett.github.io/lens/Data-Bits-Lens.html
16:51:02 <haasn> those are actually unit tests.
16:51:17 <jfischoff> haasn: https://github.com/lens/project-template
16:51:27 <haasn> jfischoff: cheers
16:51:30 <[swift]> haasn: wow, very cool!
16:51:47 <augur> oes anyone happen to know of any natural deduction proof editor/checker programs?
16:52:01 <augur> ones that can handle lambda calc proof terms?
16:55:21 <roconnor> augur: Coq, Agda?
16:55:55 <augur> roconnor: i mean something that lets you do actual tree proofs with explicit contexts, etc.
16:56:33 <roconnor> augur: there was a Flag-deduction mode for Coq at one point in time...
16:56:52 <augur> that wont work for my purposes unfortunately :\
16:57:09 <augur> im going to have to write something myself i guess. blegh.
16:57:20 <roconnor> blegh
16:57:57 <MitchellSalad> hi all, simple lens question here, is there a more clever way to do this? http://lpaste.net/93723
16:58:13 <MitchellSalad> that maybe doesn't involve fmap, but rather something in lens itself
16:58:34 <acowley> ott catches some errors
16:59:49 <augur> i wonder if i can get a grant to develop some logic software... hm
16:59:58 <acowley> MitchellSalad: I'd do something like map (_2 %~ length) <$> foo
17:00:18 <acowley> I've actually never used ott, though
17:00:25 <acowley> so I don't know how useful it's error catching is
17:02:50 <roconnor> MitchellSalad: what you wrote seems appropriate to me.
17:03:10 <MitchellSalad> hmm, alright. thanks!
17:03:30 <haasn> mapped.mapped._2 %~ length
17:03:42 <roconnor> oh duh
17:03:55 <Watcher7> sdfg
17:04:13 <acowley> ya'll are lens addicts
17:04:15 * roconnor needs more experiance with SECs
17:04:29 <roconnor> MitchellSalad: see haasn
17:04:42 <haasn> you make me sound like a doctor
17:04:45 <schell> anyone have any idea why (i'm guessing) ghc-mod would be giving me this error? "/usr/local/Cellar/ghc/7.6.3/lib/ghc-7.6.3/settings: openFile: does not exist (No such file or directory)"
17:04:47 <MitchellSalad> right, mapped.mapped. Lol
17:04:51 <MitchellSalad> thanks haasn
17:04:54 <acowley> mapped.mapped.lol
17:04:55 <acowley> great
17:05:02 <roconnor> haasn: you are not a doctor?
17:05:03 <MitchellSalad> :)
17:05:04 <schell> i'm thinking there's a path stored somewhere pointing to an old ghc install
17:05:26 <glguy> In this case isn't it "mapped . mapped . mapped" ?
17:05:34 <haasn> glguy++
17:05:44 <glguy> aka "quiteMapped"
17:05:50 <haasn> very mapped
17:06:06 <roconnor> haasn: LOL!
17:07:02 <MitchellSalad> lol
17:07:15 <MitchellSalad> Hfefefeleo
17:07:33 <acowley> This is the problem, we've forgotten the majesty of fmap . fmap . fmap
17:07:48 <acowley> Always a pleasure to encounter that when reading code
17:07:51 <glguy> MitchellSalad: don't forget you could just write: (fmap . fmap . fmap) length foo
17:07:58 <glguy> You don't always have to use lens ;)
17:08:02 <MitchellSalad> yeah, im realizing that now
17:08:16 <MitchellSalad> but _2 seems clearer than fmap for (,)
17:08:36 <MitchellSalad> ill stick with fmap.fmap.fmap :)
17:08:40 <acowley> nothing is clearer than fmap
17:09:05 <MitchellSalad> i meant that (,) fmap instance is arbitrary
17:09:18 <acowley> It's not arbitrary
17:09:21 <glguy> Functor instances are rarely arbitrary
17:09:24 <haasn> it's the only legal instance
17:09:27 <acowley> but I was joking about fmap being clear
17:09:51 <roconnor> Every type constructor has at most one functor instance.
17:09:56 <MitchellSalad> right, it's not arbitrary
17:09:56 <glguy> They're so regular we have "DerivingFunctor" language extension since there's just one implementation
17:12:10 <haasn> DeriveFunctor
17:12:16 <haasn> not everything is a lens!
17:12:21 <MitchellSalad> after a cabal-dev install, what's the difference between cabal-dev/bin/foo and dist/build/foo/foo?
17:17:50 <BigJ> I am trying to write a function that takes a single list that was split into a tuple containing two lists and return a single list of them merged together.  I can't seem to get the last line to do what I want ... http://codepad.org/RVy4mvFo
17:19:50 <xico> :t (:)
17:19:52 <lambdabot> a -> [a] -> [a]
17:19:52 <xico> > :t (:)
17:19:54 <lambdabot>   <hint>:1:1: parse error on input `:'
17:20:03 <ReinH> acowley: why does the Game2D demo use older SDL/GLFW?
17:20:28 <BigJ> xico, ok I see that helps
17:21:56 <BigJ> the first part of the definition is ok though?  concatList ([x:xs],[y:ys])
17:22:29 <xico> no
17:22:33 <acowley> ReinH: Because of all the linking stuff we talked about earlier
17:23:04 <ReinH> acowley: oh right sorry
17:23:13 <xico> BigJ: (x:xs,y:ys)
17:24:38 <BigJ> concatList (x:xs,y:ys) = x : y : concatList (xs,ys)
17:26:03 <tel> Does anyone have recommendations for Aeson-like XML serialization?
17:27:57 <ParaSa1lin> tel theres nothing good
17:28:19 <xico> BigJ: yep, by the way you could also use Data.List for that, to have a oneliner
17:37:04 <DanBurton> Just a quick fun fact before I log off: TIL http://www.haskell.org/haskellwiki/Donate_to_Haskell.org
17:47:01 <lispy> acowley: so once 7.8 is released, you'll upgrade?
18:00:03 * hackagebot here 1.2.3 - Here docs & interpolated strings via quasiquotation  http://beta.hackage.haskell.org/package/here-1.2.3 (TaylorHedberg)
18:10:38 <jocolloman> Anyone here familiar with Elm compilation?
18:17:30 <RichyB> jocolloman, only in that I've run toy examples in it once or twice, but /join #elm since that is on this network.
18:17:52 <RichyB> or do you mean with getting the Elm compiler to itself compile? I did that very easily, by building it in a fresh hsenv.
18:18:44 <jocolloman> I am having trouble compiling a multi file project. I asked in #elm but there doesn't seem to be anyone around right now
18:18:54 <jocolloman> I thought I might poke over here to see if anyone was familiar with Elm
18:19:18 <jocolloman> It is having trouble finding a module that is defined in a sub directory
18:19:55 <jocolloman> It works fine if they are in the same directory but I would like to have a little structure in my file hierarchy.
18:23:06 <Ghoul__> @djinn (a -> b) -> (c -> b) -> Either a c -> b
18:23:07 <lambdabot> f a b c =
18:23:07 <lambdabot>     case c of
18:23:07 <lambdabot>     Left d -> a d
18:23:07 <lambdabot>     Right e -> b e
18:25:01 <Polarina> What is this @dijinn ?
18:25:18 <shachaf> See: /msg lambdabot @help djinn
18:26:29 <Polarina> Nice, thanks.
18:28:49 <prophile> @djinn (a -> b) -> (b -> a) -> a -> (b, b -> a)
18:28:49 <lambdabot> f a b c = (a c, \ _ -> b (a c))
18:29:12 <applicative> @type (curry,uncurry)
18:29:12 <lambdabot> (((a, b) -> c) -> a -> b -> c, (a1 -> b1 -> c1) -> (a1, b1) -> c1)
18:29:21 <applicative> @djinn (((a, b) -> c) -> a -> b -> c, (a1 -> b1 -> c1) -> (a1, b1) -> c1)
18:29:21 <lambdabot> f = (\ a b c -> a (b, c), \ d (e, f) -> d e f)
19:03:11 <chexxor> I have two  data types, they share some type constructor names. I get error: "Ambiguous occurrence <Constructor Name>".
19:03:24 <chexxor> How can I reuse constructor names in a module?
19:04:02 <tac> In a single module?
19:04:05 <tac> I don't believe that's possible
19:04:22 <chexxor> one type is declared in a different module, and I import that one
19:04:46 <tac> oh, then you can just disambiguate with a qualified import
19:04:47 <chexxor> now I want to extend it with one more constructor. That is, I want to copy-paste and add a constructor
19:05:23 <chexxor> so I copy-pasted into my current module, then renamed, then added the extra constructor
19:06:27 <chexxor> am I wrongly solving the problem?
19:07:52 <tac> at the end of the day, the compiler needs to know which version you mean
19:08:42 <chexxor> ok. So, the set of type constructors in a module must be unique, right?
19:08:48 <tac> yes
19:09:00 <tac> Haskell has crappy namespacing rules
19:19:08 <lispy> I don't mind them but maybe I'm just used to them
19:20:04 <lispy> for things that have a lot of common names, I just do something like import qualified Data.Map as M; import Data.Map (Map)
19:20:17 <lispy> then I can use the type (Map) and just have to qualify the functions
19:23:40 <applicative> chexxor: but the common constructors, your purpose is that they really mean the same thing somehow?
19:24:25 <applicative> if that's so then there are various expedients for arranging the types
19:24:36 <chexxor> applicative: good question....
19:25:09 <chexxor> It's a calculator. ExprT is just numbers, VarExprT also allows variables of String type
19:25:35 <chexxor> so I have Add constructor
19:25:50 <chexxor> should I name one VAdd and keep the other Add ?
19:31:38 <applicative> chexxor: of course you can keep making types and complicating the names of the constructors, or keeping them in separate modules and importing qualified, which comes to the same.
19:32:18 <chexxor> applicative: that's good insight. Thanks.
19:32:21 <applicative> your example is really a pretty classical illustration of the so-called expression problem
19:32:34 <chexxor> Is it normal to put new types in separate modules/files?
19:32:54 <applicative> its perfectly normal
19:34:10 <chexxor> well, I mean convention, standard practice
19:35:05 <applicative> import qualified ExprT as Ex; import qualified VExprT as Vex; f :: Vex.ExprT -> Ex.ExprT ; etc
19:35:11 * chexxor reading about this expression problem.
19:37:31 <applicative> chexxor: with the Prelude, the text, bytestring and vector packages, we have about 10 versions of e.g. 'map' available, map, Text.Lazy.map Text.Strict.map, etc
19:38:18 <applicative> those three packages in particular can only be used if imported qualified
19:38:37 <applicative> unless you hide half the Prelude
19:41:22 <applicative> chexxor: it's slightly insane to mention it, but because it uses your very example, you might find http://okmij.org/ftp/tagless-final/course/ amusing. The theoretical discussion is a bit much but the first several modules in the list Intro1.hs Intro2.hs have witty devices
19:42:16 <jmcarthur> there is a decent approach for the expression problem using type classes and final encodings instead of ADTs and initial encodings. it's the same as the usual way of adding constructors using coproducts, except without the coproducts, and using extra type classes instead of more constructors.
19:42:28 <jmcarthur> ah, and applicative linked to basically the same stuff :)
19:42:55 <jmcarthur> i agree that it is slightly crazy to bring it up for beginner questions
19:43:10 <jmcarthur> i've been thinking about putting together a more approachable intro for it
19:43:25 <applicative> jmcarthur: ;) with the recommendation that chexxor avoid the theory and think about the types/classes.  Strangely, I don't find them that hard, the description of whats happening is hard
19:43:55 <jmcarthur> no, i don't think it's hard either
19:43:59 <applicative> jmcarthur: that would be cool. oleg is a bit of a strain on the best day
19:44:16 <jmcarthur> but it took a while for me to recognize what the trick actually is
19:44:27 <jmcarthur> like, the style was easy, but it was hard to see the benefits
19:45:06 <jmcarthur> but i really like final encodings now, not even necessarily using type classes
19:47:39 <chexxor> applicative: haha, yeah, that looks a bit deep. I currently feel a full load with the current exercises I'm working.
19:49:29 <applicative> chexxor: sorry I mentioned it. This idea of a succession of increasingly complex expression types is the perfect illustration of the trouble; you want the new one to refer back to the old one, but each recursively refers to itself
19:49:38 <jmcarthur> chexxor: the gist is that your representation is not an AST but the actual meaning of the expression instead. this means that it's trivial to add more "constructors" (just normal functions that use the representation you chose), unless you actually change the meaning, in which case you can expect big changes anyway
19:49:40 <applicative> so the old that just has Plus, not Times, say...
19:49:45 <applicative> is never good enough ...
19:50:34 <jmcarthur> chexxor: you can often determine the meaning from the "run" function's type
19:51:16 <jmcarthur> chexxor: for example, if i have some type T and its run function has a type like   run :: T -> A -> B -> C,  maybe T could just *literally* be a (A -> B -> C)
19:51:45 <jmcarthur> chexxor: the only issue is that sometimes you want more than one run function, which is when you would use type classes to support multiple "meanings" with the same interfaces
19:52:54 <ReinH> acowley: so I think I'm an idiot because I can't figure out how to run a game loop using GLFW-b
19:53:21 <jmcarthur> ReinH: set up callbacks, poll, render, swap, poll, render, swap, etc.
19:53:31 <jmcarthur> ReinH: or you can set it to poll each time you swap
19:53:47 <ReinH> jmcarthur: right, I mean, that's the normal way to do it, but how do I pass the game state to my render function?
19:54:04 <jmcarthur> ReinH: unfortunately, shared mutable state with the callbacks
19:54:12 <ReinH> oh.
19:54:17 <ReinH> Is that it? Ok then.
19:54:25 <ReinH> IORef?
19:54:27 <elliott> can't you do sigfpe's reinversion of control trick?
19:54:28 <jmcarthur> ReinH: but it doesn't need to be too crazy. it can all be stored in one reference or something
19:54:34 <carter> ReinH: you can have a global one
19:54:54 <ReinH> right, I can have a global GameState value, sure. Do I just update an IORef between renders?
19:54:56 <carter> topLevelRef = unsafePerformIO --- mkIORef
19:54:58 <jmcarthur> yeah, you can reinvert control, but then you are setting callbacks repeatedly, which is weird
19:55:23 <jmcarthur> i also don't entirely trust reinversion anymore since it means there are periods of time without callbacks set, and i haven't read anything that guarantees no events will be lost
19:55:39 <jmcarthur> also reinversion means blocking, which may be inappropriate
19:56:19 <adnap> What does STAB stand for again? I remember "source" and "target"
19:56:30 <jmcarthur> well, that last bit may not necessarily be true
19:56:33 <adnap> ..."action"...
19:56:35 <jmcarthur> many but not all uses of reinversion work that way i guess
19:57:08 <jmcarthur> i would avoid the global IORef trick
19:57:22 <carter> yeah, its only good when you really truly need a global schedule
19:57:23 <carter> r
19:57:25 <jmcarthur> i reserve that for libraries which truly honestly have to have global state due to ugly FFI stuff
19:57:49 <carter> jmcarthur: what about global shared work queueu?
19:58:19 <jmcarthur> carter: if it's in pure haskell otherwise then i wouldn't use the trick just for that. i'd make it more explicit
19:58:31 <carter> jmcarthur: REPA
19:58:33 <carter> has to do it
19:58:35 <ReinH> if my render is Window -> IO (), can I write a function GameState -> (Window -> IO ()) ?
19:58:37 <jmcarthur> carter: with the usual benefits, like being able to have more than one of them
19:58:46 <jmcarthur> carter: with isolation
19:58:52 <jmcarthur> carter: great for testing, for example
19:58:54 <osa1> I'm trying to parse some huge JSON as AST using aeson but it doesn't report error location -- do we have a library that does that?
19:59:00 <carter> good piont
19:59:01 <elliott> ReinH: you can write IORef GameState -> Window -> IO ()
19:59:08 <elliott> and make the IORef in main
19:59:12 <ReinH> right
19:59:16 <jmcarthur> carter: i disagree that repa has to do it
19:59:20 <carter> hrmm
19:59:21 <jmcarthur> carter: it's just convenient this way
19:59:25 <carter> whats a better way?
19:59:28 <carter> 'm all ears
19:59:58 <jmcarthur> carter: i don't see any reason not to just provide whatever necessary tokens when doing a parallel force or something
20:00:00 <ReinH> elliott: so I can't write a pure, higher order function that takes a gamestate and produces my render function from Window to IO action?
20:00:05 <ReinH> (without IORef)
20:00:13 <carter> jmcarthur: good point
20:00:23 <elliott> ReinH: uh, maybe I don't understand the question.
20:00:34 <carter> jmcarthur: happily, because i'm sort of having anotion of worlds
20:00:36 <carter> in my api
20:00:55 <jmcarthur> carter: there could even be some type tricks to keep you from nesting them accidentally
20:00:55 <carter> that is sorta like an way of doing the multi backend trick for accelerate, i can probably do that
20:00:59 <jmcarthur> carter: which are harder to do without the token
20:01:05 <carter> jmcarthur: i will want to hear more about these dieas
20:01:18 <jmcarthur> s/are/may be/
20:01:40 <jmcarthur> i only just thought of these now. there is nothing polished enough about this to bother sharing :)
20:01:56 <ReinH> elliott: I probably don't understand it either :/
20:02:17 <jmcarthur> ReinH: you can definitely do that
20:02:30 <jmcarthur> ReinH: it's only the sharing of that gamestate between rendering and callbacks that may need IO
20:02:45 <ReinH> jmcarthur: right, the callbacks are what are getting me :/
20:04:11 <ReinH> afaik I need global state for e.g. the window refresh callback
20:04:15 <jmcarthur> ReinH: something like do { ref <- newIORef initialGameState; setUpCallbacks ref; forever (do { state <- readIORef ref; render state; swapBuffers; pollEvents }) }
20:04:56 <applicative> osa1: http://hackage.haskell.org/package/json has a parsec module so you might be able to get it to work your way
20:05:01 <ReinH> jmcarthur: the callbacks expect functions that take a window. I don't see how I can thread the ref around.
20:05:17 <jmcarthur> ReinH: it's in the closure when you create it
20:05:38 <osa1> applicative: thanks
20:05:41 <ReinH> er.
20:05:46 <jmcarthur> ReinH: setBlahBlahCallback $ Just $ \x y -> do { readIORef refFromContextWhereIDefinedThisFunction; etc. }
20:06:15 <jmcarthur> ReinH: e.g. that could be part of that setUpCallBacks placeholder
20:06:33 <jmcarthur> ReinH: (obviously where refFromContextWhereIDefinedThisFunction is what i had formerly called ref)
20:07:33 <jmcarthur> s/obviously //
20:07:35 <nwf> Hey #haskell; is there a name for a Functor which supports a join-like operation (:: f (f a) -> f a) but is not necessarily Applicative (i.e. lacks pure :: a -> f a) or an Algebra (:: f a -> a)?
20:08:34 <ReinH> jmcarthur: I'm sorry, I don't understand how ref (or whatever it's called) is in scope of the function provided as the callback
20:08:36 <jmcarthur> nwf: http://hackage.haskell.org/package/semigroupoids-3.1/docs/Data-Functor-Bind.html#t:Bind
20:08:38 <acomar> nwf: that's the monoid operation
20:08:43 <ReinH> oh
20:08:47 <ReinH> ok.
20:08:48 <acomar> nwf: fxf -> f
20:08:51 <ReinH> hax.
20:08:56 <shachaf> nwf: semigroupoids has Bind
20:09:11 * shachaf sighs, blames slow connection.
20:09:12 <jmcarthur> ReinH: e.g.   do { ref <- newIORef blah; setCallbackBlah (Just (\x y -> <use the ref here>)) }
20:09:44 <ReinH> jmcarthur: yeah I'm dumb sorry
20:09:50 <jmcarthur> nah it's fine
20:10:04 <jmcarthur> took me a while to realize this, too, although it's been a while since then
20:10:57 * shachaf is vaguely interested in things that have join and return but no fmap.
20:11:44 <nwf> acomar: I'm not asking about mappend :: a -> a -> a, I'm asking about join :: f (f a) -> f a.  Besides, Monoids have mzero :: a, which I don't think my structure does.... though if I'm missing something, please elaborate.
20:11:59 <ReinH> jmcarthur: partial application, how does it work
20:12:52 <acomar> nwf: right, another way of expressing a -> a -> a is to curry the function and produce (a, a) -> a, or fxf -> a which is equivalent to forall a. f (f a)
20:13:06 <jmcarthur> shachaf: hmm... seems tough come up with something that supports *both* but not fmap
20:13:13 <acomar> nwf: you do lack the mzero, hence shachaf's suggestion of semigroupoids
20:13:15 <jmcarthur> shachaf: at least simple things, i mean
20:13:30 <shachaf> jmcarthur: Well, it would probably be a GADT or something.
20:13:44 <shachaf> You have things in e.g. some modal logics that have that, I think?
20:13:46 <jmcarthur> shachaf: that seems somewhat uninteresting to me
20:14:19 <nwf> shachaf: Isn't fmap f x === pure f `ap` x?
20:14:49 <shachaf> jmcarthur: A monad lets you embed logic more powerful than Haskell, e.g. classical logic with LEM. I'd like to see something that *doesn't* give you (a -> b) -> F a -> F b, in order to embed a weaker logic or something.
20:15:12 <jmcarthur> nwf: you can't define ap from return and join without fmap
20:15:14 <nwf> acomar: Could you expand on the isomorphism between (a,a) -> a and forall a . f (f a) ?
20:15:17 <shachaf> nwf: Yes, so you probably couldn't have pure and/or <*>
20:15:36 <shachaf> nwf: When you say a monad is a "monoid object in the category of endofunctors", you get join :: (m . m) ~> m
20:15:46 <shachaf> It's not Monoid in the sense of the Haskell class.
20:15:52 <adnap> Hey
20:16:03 <shachaf> (Where type f ~> g = forall a. f a -> g a)
20:16:05 <nwf> jmcarthur: Er, base defines ap as 'liftM2 id', and liftM2 as "do { x1 <- m1; x2 <- m2; return (f x1 x2)}"....
20:16:06 <acomar> nwf: shachaf covered it
20:16:13 <adnap> I don't understand the type of _1. Is it a lens?
20:16:17 <jmcarthur> nwf: <- desugars to bind
20:16:19 <adnap> I am in #haskell-lens by the way.
20:16:23 <shachaf> nwf: You can define fmap from (>>=) and return, but not join and return.
20:17:21 <jmcarthur> nwf: m >>= f = join (fmap f m)
20:17:36 <nwf> Oh, right, I forgot about that fmap.  Sorry for noise. :)
20:17:52 <jmcarthur> bedtime!
20:18:25 <adnap> ...
20:19:04 <shachaf> jmcarthur: Anyway, I'm not exactly sure what it would be like, I'm just interested in finding out.
20:19:54 <shachaf> People say that "M a" represents a program for various monads M, but that's only a specific kind of program, and you can't e.g. statically analyze anything about it without running it.
20:23:11 <pdxleif> halp: was trying to define: "instance Alternative a => Alternative (IO a) where", but it tells me: "Expecting one more argument to `a' In the instance declaration for `Alternative (IO a)'"
20:23:14 <pdxleif> howtofix?
20:23:44 <acomar> pdxleif: what are you really trying to do?
20:23:45 <applicative> several things are wrong, the kind of 'a'
20:24:13 <pdxleif> I want to write IO Maybe a <|> IO Maybe b, basically
20:24:20 <pdxleif> a <|> b = a >>= (maybe b return)
20:24:28 <adnap> Nevermind. I get it now. Indexable i (->) is an instance of Indexable, so _1 :: Functor f => (->) a (f b) -> s -> f t
20:24:29 <pdxleif> or something
20:25:30 <joelteon> :t liftM2 (<|>)
20:25:31 <lambdabot> (Monad m, Alternative f) => m (f a) -> m (f a) -> m (f a)
20:26:01 <acomar> pdxleif: You can do it if you bring they Maybe outside as MaybeT
20:26:11 <acomar> or yea what joelteon suggested
20:28:51 <applicative> MaybeT has MaybeT on the outside, Maybe on the inside and e.g. IO in the middle...
20:29:43 <acomar> sounds like a tasty sandwich
20:29:59 <pdxleif> So... how do I get from IO (Maybe String) to MaybeT IO String?
20:30:11 <applicative> runMaybeT
20:30:17 <applicative> @type runMaybeT
20:30:18 <lambdabot> Not in scope: `runMaybeT'
20:30:21 <applicative> bah
20:30:28 <nwf> Arg, why does semigroupoid's Bind require Apply?
20:30:33 <pdxleif> runMaybeT :: MaybeT m a -> m (Maybe a)
20:30:37 <applicative> yes
20:31:08 <acomar> pdxleif: The suggestion is that you generate the alternatives as MaybeT IO a instead of IO (Maybe a)
20:31:13 <applicative> it just wraps your type and does what you want, to judge from the Alternative/MonadPlus instances http://hackage.haskell.org/package/transformers-0.3.0.0/docs/src/Control-Monad-Trans-Maybe.html
20:31:20 <acomar> then use runMaybeT to turn it into IO (Maybe a)
20:32:06 <acomar> we can be more specific you actually put up some code on lpaste, we can give you more concrete suggestions
20:32:11 <applicative> but maybe joelteon s plan is more sensible.
20:32:12 <pdxleif> I'm just trying to say 'lookupEnv "FOO" <|> someOtherIOAction'
20:32:17 <acomar> ack, that was repetetive
20:32:27 <acomar> oh wow, I just give up
20:32:28 <pdxleif> that is, if the shell env doesn't exist, do something else to get the value.
20:33:42 <acomar> ahh, the problem with that is IO doesn't have a well defined Alternative instance
20:34:13 <acomar> straightforward solution is to just write out the branching statement
20:34:48 <pdxleif> yeah...
20:36:43 <ReinH> jmcarthur: why the hell wasn't I reading this? http://www.haskell.org/haskellwiki/GLFW
20:36:47 * ReinH facepalms
20:36:56 <ReinH> I should put the computer down and step away.
20:37:31 <monochrom> it was not required reading. don't blame yourself :)
20:37:57 <ReinH> monochrom: but it explains things I was too dumb to figure out :)
20:39:14 <pdxleif> liftM2 (<|>) (lookupEnv "FOO") (lookupEnv "PATH") works
20:43:10 <pdxleif> Or I can annoy people and write that w/ idiom brackets as: (| lookupEnv "FOO" <|> lookupEnv "PATH" |)
20:44:04 <joelteon> are there idiom brackets anywhere
20:44:08 <joelteon> actually implemented
20:44:16 <applicative> there are preprocessors, template haskell etc
20:44:22 <applicative> print =<< runMaybeT  (MaybeT (lookupEnv "MOO") <|> MaybeT (lookupEnv "SHELL") <|> lift(return "I'm lost"))
20:44:36 <pdxleif> Just a lil preprocessor - https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/idiom.html
20:44:40 <applicative> kinda hideous
20:44:40 <pdxleif> Idris has them natively
20:47:18 <applicative> joelteon: here's a little preprocessor torn out of mcbrides package http://lpaste.net/91686 ;)
20:48:15 <applicative> joelteon: with this wacky demo of its use http://lpaste.net/91688
20:49:32 <joelteon> huh, neat
20:53:46 <pdxleif> could write that as 'maybe getLine return =<< (lookupEnv "PATH")', but I kinda like the "or / alternative" look of 'runMaybeT (MaybeT (lookupEnv "PATH") <|> lift getLine)'
20:57:55 <chexxor> which Data.Map tutorial do you recommend?
20:59:38 <monochrom> none
21:00:23 * hackagebot cabal-install 1.18.0.2 - The command-line interface for Cabal and Hackage.  http://beta.hackage.haskell.org/package/cabal-install-1.18.0.2 (JohanTibell)
21:01:25 <pdxleif> > None
21:01:29 <lambdabot>   Not in scope: data constructor `None'
21:01:29 <lambdabot>  Perhaps you meant one of these:
21:01:29 <lambdabot>    `...
21:05:04 <skeet70> Hello! I'm trying to get a handle on concurrency. I'm using this code http://lpaste.net/93730 to read a file character by character and write to an output file.
21:05:45 <skeet70> When the forkIO function is removed, the program runs fine, but with it, it stops printing to the output file ~390,000 lines in. Any idea why/what I'm doing wrong?
21:06:00 <Maxdamantus> :t let a = Nothing; b = show a in a
21:06:00 <lambdabot> Maybe a
21:06:08 <Maxdamantus> That feels strange.
21:06:31 <Maxdamantus> Both that it still has a free type variable, and that there's no `Show a` constraint.
21:06:53 <acomar> MAxdamantus: you didn't make use of b, so it's value was never forced -- the constraint isn't necessary
21:06:55 <Maxdamantus> I guess the type variable makes sens.
21:07:20 <Maxdamantus> O_o .. didn't know it took that shortcut.
21:08:02 <acomar> look into lazy evaluation
21:08:13 <Maxdamantus> :t let a = Nothing; b = show a; c = read b in c
21:08:14 <lambdabot> Read a => a
21:08:17 <Maxdamantus> Explain that.
21:08:45 <acomar> you only asked for the type
21:09:09 <acomar> so you forced c but not b
21:09:47 <acomar> it didn't need to continue evaluating past checking the constraint on c
21:12:03 <Maxdamantus> Oh, right. nvm
21:12:08 * Maxdamantus is being silly.
21:12:39 <Maxdamantus> Nothing requires that `read b` be the same type as `a`
21:13:22 <acomar> "There is nothing that requires that..." or "Nothing requires that"
21:13:22 <acomar> ?
21:14:20 <Maxdamantus> Either works.
21:14:49 <Maxdamantus> (I didn't mean "Nothing" as in `Maybe a`)
21:17:36 <acomar> yea, that's what I was asking
21:24:21 <ethercrow> fannkuchredux benchmark works in parallel now
21:25:04 <Maxdamantus> Hmm .. so what happens here? I have a `data Foo = Bar | Baz deriving Read`: let a = Nothing; b = show a; c = read b in (a, b, c) :: (Maybe Foo, String, Maybe Foo)
21:25:10 <Maxdamantus> that actually typechecks.
21:25:19 <Maxdamantus> it doesn't when replacing the `Nothing` with `Just Bar` though.
21:25:30 <shachaf> Nothing is more polymorphic.
21:25:40 <shachaf> What type do you think read has there?
21:25:50 <monochrom> Nothing requires a terminal object. :)
21:26:09 <Maxdamantus> String -> Maybe Foo
21:26:22 <Maxdamantus> what seems odd is the `show a`
21:26:27 <shachaf> Er, right.
21:26:41 <Maxdamantus> that should require that `a` be of some `Show a => a` type.
21:26:53 <Maxdamantus> particularly, `Show a => Maybe a`
21:26:55 <shachaf> No, of some Show a *> a, if you want to be precise.
21:26:59 <Maxdamantus> more particularly, `Show a => Maybe Foo`
21:27:06 <Maxdamantus> er, s/Show a =>//
21:27:13 <shachaf> Who says it's Foo?
21:27:21 <Maxdamantus> The ::
21:27:39 <shachaf> > let x = Nothing in (x, x) :: (Maybe Int, Maybe Char)
21:27:40 <lambdabot>   (Nothing,Nothing)
21:27:53 <dmj`> Anyone used acid-state with snap before? If so, how'd you deal with authentication?
21:28:31 <Maxdamantus> Hm. Shouldn't that require the no monomorphism restriction.
21:28:42 <Maxdamantus> Wait, that's enabled by default in ghci, isn't it?
21:29:12 <Maxdamantus> I actually :set -XMonomorphismRestriction.
21:29:45 <Maxdamantus> :t let x = Nothing in (x, x)
21:29:46 <lambdabot> (Maybe a, Maybe a1)
21:30:06 <Maxdamantus> Hm. Doesn't seem to care.
21:30:46 <shachaf> You misunderstand the monomorphism restriction.
21:31:10 <Maxdamantus> Apparently.
21:31:40 <Maxdamantus> Oh, it only applies to classes.
21:31:50 * Maxdamantus thinks he's noticed that before.
21:32:32 <mm_freak_> instance (SingI n) => Reifies (n :: Nat) Integer where reflect _ = fromSing (sing :: Sing n)
21:32:37 <mm_freak_> i'm not sure about that instance
21:32:42 <shachaf> http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-930004.5.5
21:32:55 <mm_freak_> firstly it's orphan, secondly it /feels/ like it should be undecidable, but the type checker does not complain
21:33:11 <mm_freak_> edwardk recommended me to do it that way, but it just feels wrong
21:33:12 <shachaf> Yes. Some class.
21:33:23 <Maxdamantus> which seems odd.
21:33:47 <mm_freak_> does anyone have advice?
21:33:48 <Maxdamantus> Because you can make long polymorphic computations without classes.
21:34:03 <mm_freak_> i'd normally just use type lits, but then i wouldn't get reflection
21:34:16 <shachaf> Maxdamantus: But they can be shared, right?
21:34:23 <shachaf> Sigh, the wiki page on the MR isn't very good.
21:34:48 <Maxdamantus> No.
21:34:58 <Maxdamantus> Hang on .. I think I have an example somewhere.
21:35:12 <Maxdamantus> Meh, could just make one again.
21:35:26 <monochrom> you are looking at ghci's extra default in "b = show a" => "b = show (a :: Maybe ())"
21:36:26 <jfischoff> has anyone here ever used hermit?
21:36:33 <mm_freak_> dmj`: the last time i tried it was not possible to integrate the authentication snaplet's state into your acid-state state, but that might have changed
21:36:35 <Maxdamantus> > let slowid = foldl (.) id $ take 500000 $ repeat id in slowid (5, 4) :: (Int, Double)
21:36:36 <lambdabot>   (5,4.0)
21:36:44 <Maxdamantus> > let slowid = foldl (.) id $ take 500000 $ repeat id in (slowid 5, slowid 4) :: (Int, Double)
21:36:46 <lambdabot>   (5,4.0)
21:36:54 <ReinH> jmcarthur: thoughts on this? http://dmytrish.wordpress.com/2013/01/12/haskell-opengl-animation-done-right/
21:36:55 <monochrom> instead, you should perform this more realistic experiment: put your data declaration and "v = let ... in (a,b,c) :: (Maybe Foo, String, Maybe Foo)" in a file. load that file. that will give you an error on "b = read a".
21:37:36 <Maxdamantus> actually, bad example, nvm.
21:38:19 <Maxdamantus> monochrom: or just `let r = ..` and don't show it in ghci.
21:38:43 <MedDev> is getCPUTime the preffered way to get a precise measurement of how long it's been since my program has started?
21:39:06 <monochrom> no, that is still subject to ghci's difference
21:40:14 <monochrom> do not use ghci to predict real code behaviour
21:41:02 <Maxdamantus> and actually, yeah, they are shared.
21:41:26 <Maxdamantus> based on ghci-based predictions of code behaviour: let slowid = iterate id id !! 5000000 in (slowid 5, slowid 4) :: (Int, Double)
21:55:13 <td123> does anyone know a working audio library that can play raw data?
21:55:24 <td123> alsa-pcm segfaults on their example
21:55:27 * hackagebot lvish 1.0 - Parallel scheduler, LVar data structures, and infrastructure to build more.  http://beta.hackage.haskell.org/package/lvish-1.0 (RyanNewton)
21:55:48 <td123> gstreamer doesn't look like it supports appsrc
21:56:40 <xico> td123: alsa?
21:57:01 <xico> does not work?
21:57:11 <td123> xico: I couldn't get their example to work
21:57:17 <td123> it segfaulted
21:57:50 <leroux> If it segfault'd, it should probably be reported.
21:58:21 <td123> I have a feeling it isn't actively maintained though
21:58:47 <td123> last code update was over a year ago
21:59:28 <xico> well, alsa does not change much
21:59:58 <td123> right
22:00:25 <td123> openal is unmaintained
22:00:45 <td123> and pulseaudio-simple's write method is blocking which I can't have :/
22:03:39 <xico> (as a side note, i am using alsa-pcm without problems)
22:07:34 <acomar> acowley: no clue if this will be useful yet, but I just noticed that MatExprs form an F-algebra over Mats. And they're functors in a restricted context (you need constraints on the element type so you don't construct an invalid matrix)
22:07:45 <acomar> acowley: I have no idea if that buys us anything, but it's interesting to note
22:32:08 <chexxor> Not in scope: data constructor `M.Map' -- How to fix this?
22:32:16 <chexxor> I imported with this -- import qualified Data.Map as M
22:32:44 <shachaf> By showing your code.
22:33:05 <shachaf> (In this case I figured out what the issue is after reading your error carefully. But you should show your full code and full error anyway.)
22:34:15 <td123> xico: do you have any example code?
22:34:32 <chexxor> shachaf: just a sec, I'll paste
22:34:36 <td123> xico: I might be able to compare code to see if you're setting up anything differently
22:35:39 <jfischoff> is it possible to convert a argument to an unpacked type in hermit?
22:35:50 <xico> td123: no simple ones. but i just tried sine.hs from the examples of alsa-pcm and it works fine.
22:36:19 <td123> sine.hs works also
22:36:29 <td123> but play.hs doesn't
22:36:45 <jfischoff> has anyone attempted a ghc-core edsl with Haskell?
22:40:14 <xico> td123: works fine here too.
22:40:32 <pqmodn> jfischoff: i don't know much about it, but you might look at KURE
22:40:47 <jfischoff> right that is the basis of hermit
22:40:50 <xico> td123: guess you can always try to debug it to know where it segfault.
22:41:26 <td123> segfaults on the writei
22:44:05 <td123> I need to investigate this further before I would know why
22:44:21 <td123> non of the registers look like a null
22:45:28 <chexxor> http://lpaste.net/93733
22:50:14 <pavonia> chexxor: Map is an internal constructor, you can't use it in patterns. You have to use just x and functions exported from Data.Map
22:50:43 <shachaf> Map isn't a data constructor at all.
22:50:49 <chexxor> pavonia: thanks! ok... so, now I have to think about this.
22:51:01 <pavonia> Ah, even that
22:55:10 <pavonia> chexxor: As a first step, what is the type of the funtcion you are trying to implement?
22:55:34 * hackagebot pandoc-types 1.12.2.2 - Types for representing a structured document  http://beta.hackage.haskell.org/package/pandoc-types-1.12.2.2 (JohnMacFarlane)
22:55:36 * hackagebot karakuri 0.1 - Good stateful automata  http://beta.hackage.haskell.org/package/karakuri-0.1 (FumiakiKinoshita)
22:55:47 <chexxor> *cries a little* I have no idea. :-(
22:56:16 <chexxor> my mind spins when I see all these types, instances, and classes
22:56:52 <pavonia> there's a class "HasVars a" which has a function of type "String -> a"
22:57:15 <pavonia> now you're defining an instance for a = M.Map String Integer -> Maybe Integer
22:59:26 <pavonia> you should be able to tell the type of var from that
23:00:34 * hackagebot socket-activation 0.1.0.0 - systemd socket activation library  http://beta.hackage.haskell.org/package/socket-activation-0.1.0.0 (DavidFisher)
23:05:50 <chexxor> What does "instance HasVars (M.Map String Integer -> Maybe Integer)" mean?
23:05:51 <chexxor> It means the "var" function can be used with a "Map" type?
23:06:58 <chexxor> This looks like Map is a constructor, which takes two arguments.
23:07:09 <chexxor> But Map doesn't *have* a constructor, so what does this mean?
23:08:04 <pavonia> Map is a *type* constructor
23:08:23 <chexxor> what other constructors exist?
23:08:32 <chexxor> type constructor is the only thing I know
23:08:52 <pavonia> there are type and data constructors
23:10:09 <chexxor> type and data are fundamentally different? They look the same, in code, to me.
23:10:10 <pavonia> e.g "Just" is a data constructor, while "Maybe" is a type constructor
23:10:11 <pavonia> :t Just
23:10:11 <lambdabot> a -> Maybe a
23:10:11 <pqmodn> Maybe takes a type, like Int, and creates a type, like Maybe Int
23:10:12 <pavonia> data constructors can be used in expressions, type constructors in types
23:10:43 <pavonia> but yeah, they both start with a capital letter
23:11:09 <pqmodn> Just takes a value (of type a) and constructs a value (of type Just a)
23:11:18 <pqmodn> er, sorry, of type Maybe a
23:12:14 <chexxor> so if I do this: "Person = Person name".... Person is a data constructor?
23:12:28 <chexxor> so if I do this: "Person = MkPerson name".... MkPerson is a data constructor?
23:12:58 <pqmodn> data Person = MkPerson String, sure
23:13:03 <pqmodn> then Person is a type
23:13:21 <chexxor> so what does a type constructor look like?
23:13:39 <sipa> Maybe is a type constructor
23:13:59 <sipa> data Maybe a = Nothing | Just a
23:14:03 <pqmodn> also, types and data constructors live in different namespaces, so they can share names, like data Person = Person String.
23:14:11 <sipa> Nothing and Just are the corresponding value constructors
23:14:24 <sipa> :k Maybe
23:14:25 <lambdabot> * -> *
23:14:44 <chexxor> why is Maybe a type constructor? It doesn't make anything, it's just a label
23:14:50 <pqmodn> it makes a type
23:14:59 <pqmodn> it takes a type, like Int, and makes a type, like Maybe Int
23:15:10 <pqmodn> Maybe by itself is not a type
23:15:34 <sipa> Maybe Int is a type, Maybe is something that takes a type, and returns a modified type
23:16:24 <pqmodn> another example is Either
23:16:26 <pqmodn> :k Either
23:16:27 <lambdabot> * -> * -> *
23:16:28 <sipa> note that type-level stuff is typically resolved by the compiler rather than at runtime
23:16:32 <pqmodn> :k Either Int String
23:16:32 <lambdabot> *
23:16:45 <sipa> so perhaps you're confused by the fact that it doesn't make something at runtime
23:17:21 <mcjohnalds> Does anyone know any simple examples of yampa for game dev? I've tried The Yampa Arcade's game but it doesn't compile and "cuboid" made my brain hurt :(
23:17:26 <chexxor> wow, I thought I understood this, but I obviously have no idea
23:18:24 <pavonia> finally, Map is a type constructor in your example too, ist defined like "data Map k v = ..." where k is the type of keys and v the type of values
23:18:36 <pavonia> *it's
23:18:39 <chexxor> True or False, if I do "data x = blah blah", the stuff to the right of "=" is always type constructors.
23:19:00 <pavonia> nope, the other way around
23:19:00 <Iceland_jack> No "x" is the type construtor
23:19:20 <chexxor> I thought "x" is a type...
23:19:20 <Iceland_jack> When you write:
23:19:20 <Iceland_jack>     data Bool = True | False
23:19:21 <Iceland_jack> ‘Bool’ is the type, not a value
23:19:30 <pqmodn> is it still called a type constructor if it takes no args?
23:19:42 <Iceland_jack> Sure
23:19:56 <sipa> chexxor: x is something at the type level
23:20:40 <pavonia> and blah blah are the values of the type x
23:20:43 <Iceland_jack> It's really not that involved: type constructors make a new type, data constructors make a new value
23:21:14 <sipa> True or Nothing are also value constructors
23:21:37 <pavonia> What are type constructors without parameters called, "nullary"?
23:21:49 <sipa> or type constants, perhaps
23:21:50 <chexxor> so, Maybe is not a value, but True is a value... I can understand that
23:22:07 <shachaf> Names aren't that important.
23:22:18 <shachaf> People argue about these things a lot and they're not worth arguing about.
23:22:28 <chexxor> lol
23:22:35 <shachaf> Just define what you mean at the top of the paper and use it consistently.
23:22:37 <pavonia> true, but it helps in teaching things
23:22:49 <chexxor> well, I think understanding this will help me understand how to use Map, so....
23:22:52 <sipa> to forget about the word constructor for a while
23:23:06 <sipa> Nothing, True and False are constant values
23:23:15 <sipa> Just is a function
23:23:25 <Iceland_jack> chexxor: Map is a bit different since the data constructors are hidden
23:23:42 <sipa> Just True is a non-function value
23:23:53 <chexxor> Map is a namespace which has functions, right?
23:24:11 <chexxor> and these functions can only be used on certain types, right?
23:24:31 <sipa> M is a module name, in your code
23:24:57 <sipa> M.Map is a type constructor in the module M
23:25:04 <Iceland_jack> chexxor: There is nothing inherently special about how the functions can be used
23:25:07 <Iceland_jack> they're just regular functions
23:25:35 <sipa> M.size is for example a function in that module
23:26:17 <Iceland_jack> The Data.Map module also includes values (as opposed to functions) such as Data.Map.empty
23:26:30 <chexxor> you said the Map data constructor is hidden, so what is this -> "instance HasVars (M.Map String Integer -> Maybe Integer) where"
23:26:52 <Iceland_jack> Are you asking me what "->" is?
23:27:10 <sipa> chexxor: an instance makes a type member of a type class
23:27:14 <chexxor> no, the "M.Map" in the instance declaration
23:27:17 <sipa> the type here is M.Map String Integer
23:27:18 <Iceland_jack> M.Map is just the type constructor
23:27:29 <Iceland_jack> (because it, well, constructs a type)
23:27:36 <sipa> which is the M.Map type constructor applied to String and Integer
23:27:43 <sipa> eh, sorry
23:27:50 <chexxor> but you said it's hidden, so how can it be used here?
23:27:56 <sipa> the type isn't hidden
23:28:02 <Iceland_jack> chexxor: I never said the type constructor was hidden
23:28:02 <sipa> ooh, i see the confusion
23:28:08 <sipa> the type constructor is hidden
23:28:16 <Iceland_jack> oops
23:28:18 <sipa> the corresponding value constructor(s) are
23:28:26 <sipa> is NOT
23:28:33 <sipa> sorry, i need sleep :)
23:28:59 <chexxor> so, we use type constructors only in type signatures, true?
23:29:03 <sipa> yes
23:29:04 <Iceland_jack> Yes
23:29:14 <sipa> value expressions and type expressions are completely separate
23:29:27 <Eelis> sadly ;)
23:29:36 <sipa> (the only exception is that within a value expression, after :: a type expression follows, afaik)
23:29:39 <Iceland_jack> Eelis: (hush!) :)
23:30:11 <sipa> chexxor: anyway, M.Map (aka Data.Map.Map) is a type constructor
23:30:17 <sipa> chexxor: which is public
23:30:21 <mm_freak_> sipa: sadly
23:31:02 <chexxor> and this is like a type signature? "instance HasVars (M.Map String Integer -> Maybe Integer) where"
23:31:04 <sipa> that's an instance declaration
23:31:05 <mm_freak_> chexxor: a type signature always involves a "::"
23:31:05 <Iceland_jack> chexxor: You may want to read up on LYAH a little bit
23:31:09 <sipa> it makes the type (M.Map String Integer -> Maybe Integer) member of the typeclass HasVars
23:31:17 <Iceland_jack> It seems like much of your confusion about simple concepts could be answered by going through that
23:31:28 <mm_freak_> chexxor:
23:31:31 <mm_freak_> @where lyah
23:31:31 <lambdabot> http://www.learnyouahaskell.com/
23:31:38 <mm_freak_> read it, it will answer these basic questions
23:31:44 <sipa> chexxor: "M.Map String Integer -> Maybe Integer" is the type of all functions that take a M.Map String Integer, and return a Maybe Integer
23:32:17 <sipa> and yes, read LYAH
23:33:18 <mm_freak_> haskell is definitely not for the impatient =)
23:33:31 <Iceland_jack> That's true
23:33:50 <chexxor> This "(M.Map String Integer -> Maybe Integer)" looks like a type. Can I say it's a "type expression" which evaluates to a type?
23:33:57 <sipa> yes
23:34:13 <sipa> if you want to decompose it
23:34:25 <Iceland_jack> If "a" is a type, and "b" is a type: then "a -> b" is a type
23:34:32 <sipa> it's the (->) type constructor applied to (M.Map String Integer) and (Maybe Integer)
23:34:32 <chexxor> and the result will be "M.Map" type
23:34:45 <Iceland_jack> chexxor: What?
23:34:47 <Iceland_jack> No
23:35:04 <Iceland_jack> Do read up on LYAH
23:35:10 <mm_freak_> chexxor: something of type A -> B is a function of A resulting in a B
23:35:11 <sipa> chexxor: the result will be "the type of functions that take an M.Map (...) and return a Maybe (...)
23:35:21 <mm_freak_> "A -> B" itself is a type
23:35:56 <chexxor> effing a, this is complicated.
23:35:58 <Iceland_jack> I feel like you're dealing with slightly advanced type signatures when you don't grasp some of the basics yet
23:36:07 <chexxor> I'm pretty sure I've read a lot of LYAH, but I still don't understand this
23:36:23 <Iceland_jack> Do you understand: Bool -> Int?
23:36:35 <mm_freak_> chexxor: your confusion may come from the fact that you don't add "::" into the mix
23:36:35 <mm_freak_> A -> B is a type
23:36:40 <chexxor> Sorry for bothering you about these basic things. I guess I'll go sit in the corner with LYAH again.
23:36:44 <mm_freak_> and you say "f :: A -> B" to say that f is a value of type A -> B
23:36:56 <mm_freak_> and a value of type A -> B is a function from values of type A to values of type B
23:37:39 <pqmodn> only in this instance, A = M.Map String Integer and B = Maybe Integer
23:37:39 <chexxor> I understand functions and writing them
23:37:59 <chexxor> but I can't draw the line between values, data, and types. This makes it difficult to read and write code
23:38:00 <Iceland_jack> chexxor: Do you understand type classes?
23:38:12 <mm_freak_> chexxor: the line is "::"
23:38:13 <Iceland_jack> Values have a type
23:38:18 <chexxor> Iceland_jack: yeah, I understand the concept. I spent a whole week reviewing them.
23:38:45 <Iceland_jack> so in:
23:38:46 <Iceland_jack>     not True :: Bool
23:38:47 <Iceland_jack> 'not True' is a value, with the type of 'Bool'
23:38:59 <mm_freak_> s/of //
23:39:15 <mm_freak_> "the type of Bool" = "*" ;)
23:39:37 <Iceland_jack> mm_freak_: Right, I should've written "of type Bool"
23:39:43 <mm_freak_> yes
23:40:24 <mm_freak_> the type of 'not True' is Bool
23:40:31 <mm_freak_> so you write: not True :: Bool
23:40:42 <mm_freak_> the type of 'sin' (simplified) is:  Double -> Double
23:40:49 <mm_freak_> so you write:  sin :: Double -> Double
23:41:06 <mm_freak_> from that type signature you can see that 'sin' is a function that takes a Double and returns a Double
23:41:24 <chexxor> mm_freak_: right, I get that
23:41:42 <chexxor> but "instance <class> <type constructor> where" This is right?
23:42:01 <mm_freak_> this is right, but it's too early for you to dig into type classes yet
23:42:13 <mm_freak_> chexxor: given x :: Double, what's the type of 'sin x'?
23:42:18 <chexxor> and when I write functions, it's "myFun <type constructor> = ...."
23:42:24 <mm_freak_> no
23:42:33 <mm_freak_> myFun argument = …
23:42:39 <chexxor> mm_freak_: It should return a Double
23:42:41 <sipa> myFun x = y
23:42:46 <sipa> that's entirely at the value level
23:42:47 <mm_freak_> chexxor: give me a type signature for sin x
23:42:56 <sipa> type expressions are only involved in:
23:43:01 <sipa> myFun :: type -> type
23:43:10 <sipa> and in:
23:43:15 <sipa> data type = ...
23:43:17 <Iceland_jack> chexxor: You can write a function without any data or type constructor:
23:43:18 <Iceland_jack>     foo x = x
23:43:25 <chexxor> so, it's "myFun <data constructor> = ..."?
23:43:35 <Iceland_jack> It *can* be
23:43:36 <mm_freak_> chexxor: that's one way to write it
23:43:45 <mm_freak_> chexxor: again, give me the type signature for 'sin x'
23:43:47 <mm_freak_> given x :: Double
23:44:07 <Iceland_jack> When you write:
23:44:07 <Iceland_jack>     foo []     = ...
23:44:07 <Iceland_jack>     foo (x:xs) = ...
23:44:07 <Iceland_jack> [] and (:) are data constructors
23:44:10 <chexxor> :t sin x == Double
23:44:10 <lambdabot>     Ambiguous occurrence `x'
23:44:11 <lambdabot>     It could refer to either `L.x',
23:44:11 <lambdabot>                              defined at /home/lambdabot/.lambdabot/State/L.hs:140:24
23:44:25 <Iceland_jack> chexxor: "sin x" is not a type
23:44:35 <Iceland_jack> If you want to specify the type of a value, you use ::
23:44:38 <mm_freak_> chexxor: a type signature always looks like this: "x :: T"
23:44:52 <mm_freak_> in this case you would write:  sin x :: T
23:44:53 <mm_freak_> what is T?
23:44:57 <Iceland_jack> @ty let x = pi :: Double in sin x
23:44:58 <lambdabot> Double
23:45:08 <mm_freak_> Iceland_jack: thanks for spoiling…
23:45:15 <chexxor> but sin x returns a value, and that value has a type, no?
23:45:21 <Iceland_jack> Well they already knew the answer
23:45:22 <mm_freak_> chexxor: yes, absolutely
23:45:29 <Iceland_jack> They just didn't know how to formulate it
23:45:30 <TallerGhostWalt> trying to hire a few ppl to train in haskell, any advice for traits to look for?
23:45:34 <chexxor> so why can't I use :t sin x?
23:45:43 <Iceland_jack> chexxor: You can
23:45:47 <mm_freak_> chexxor: because x is not defined
23:45:53 <chexxor> :t sin 1
23:45:54 <lambdabot> Floating a => a
23:45:58 <Iceland_jack> if x is bound to a value of type Double, you can use :t sin x
23:46:01 <mm_freak_> :t sin (1 :: Double)
23:46:03 <lambdabot> Double
23:46:08 <chexxor> :t sin (1::Double)
23:46:09 <lambdabot> Double
23:46:16 <chexxor> :t sin 1 :: Double
23:46:16 <lambdabot> Double
23:46:18 <Iceland_jack> :t sin (1 :: Double) :: Double
23:46:19 <lambdabot> Double
23:46:34 <mm_freak_> chexxor: note the difference between 'sin x :: Double' and 'sin (x :: Double)'
23:46:37 <sipa> chexxor: also, "Maybe Int" is a not a type constructor; it's a type that results from applying the type constructor Maybe to the type Int
23:47:01 <sipa> chexxor: you seem to be using "type constructor" to refer to just types
23:47:15 <chexxor> mm_freak_: I feel like the former makes Haskell convert x to Double, because sin expects a Double
23:47:26 <mm_freak_> chexxor: it doesn't "convert" x to Double
23:47:37 <sipa> it requires x to Double
23:47:40 <sipa> *be
23:47:44 <mm_freak_> chexxor: an explicitly written type signature is always an assertion…  the compiler simply checks it
23:47:47 <chexxor> ah
23:48:09 <mm_freak_> :t length ("abc" :: Int)
23:48:11 <lambdabot>     Couldn't match expected type `Int' with actual type `[Char]'
23:48:12 <lambdabot>     In the first argument of `length', namely `("abc" :: Int)'
23:48:12 <lambdabot>     In the expression: length ("abc" :: Int)
23:48:16 <sipa> but using type inference, the compiler usually already knows what type what is
23:48:25 <mm_freak_> this is a type error, because i asserted that "abc" is of type Int
23:48:32 <mm_freak_> the compiler checked and found that that's wrong
23:48:35 <Iceland_jack> :t length ("abc" :: String) :: Int
23:48:36 <sipa> but type declarations make the errors you get because of it much more readable
23:48:36 <lambdabot> Int
23:48:37 <ReinH> :t 1 -- this is causing some confusion
23:48:43 <lambdabot> Num a => a
23:48:57 <lesur> lamdabot: .
23:49:34 <mm_freak_> chexxor: the next step is to understand algebraic data types…  do you understand the definition of Bool?
23:49:39 <mm_freak_> data Bool = True | False
23:49:39 <ReinH> Would probably be easier to talk about types without having to talk about typeclasses
23:50:05 <chexxor> mm_freak_: yeah Bool = True | False
23:50:11 <chexxor> True and False are values
23:50:18 <mm_freak_> chexxor: ok, what is the type of True?
23:50:24 <mm_freak_> write a type signature for True
23:50:32 <chexxor> True is type Bool
23:50:39 <chexxor> True :: Bool
23:50:42 <mm_freak_> yeah
23:50:59 <chexxor> ok...
23:51:03 <chexxor> Bool :: * ?
23:51:06 <Iceland_jack> yes
23:51:08 <chexxor> * can be used only with types?
23:51:08 <Iceland_jack> :k Bool
23:51:09 <mm_freak_> chexxor: True is a data (or "value") constructor…  you can use it to pattern-match
23:51:10 <lambdabot> *
23:51:18 <mm_freak_> chexxor: not True = False;  not False = True
23:51:24 <leroux> :t <type> is a kind, right?
23:51:24 <lambdabot> parse error on input `<'
23:51:25 <mm_freak_> you would never write:  not Bool = …
23:51:29 <lesur> @hoogle .
23:51:29 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
23:51:29 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
23:51:29 <lambdabot> Control.Category (.) :: Category cat => cat b c -> cat a b -> cat a c
23:51:34 <mm_freak_> because Bool is a type, not a value
23:51:44 <chexxor> :t Bool
23:51:45 <lambdabot> Not in scope: data constructor `Bool'
23:51:46 <lesur> @hoogle fmap
23:51:46 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
23:51:46 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
23:51:46 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
23:51:46 <shachaf> People write all sorts of crazy things.
23:51:51 <leroux> :k Bool
23:51:52 <lambdabot> *
23:51:56 <chexxor> :t True
23:51:57 <lambdabot> Bool
23:51:58 <leroux> Nevermind, the kind of a type.
23:52:01 <mm_freak_> chexxor: since Bool is a type, it is of some "kind"
23:52:10 <mm_freak_> :k Bool
23:52:12 <lambdabot> *
23:52:12 <leroux> :k Maybe
23:52:13 <lambdabot> * -> *
23:52:40 <mm_freak_> chexxor: now digest this type:  data Nat = Zero | Succ Nat
23:52:45 <chexxor> ah, ok. I can use :t and :k to see if a Name is a value/data or a type
23:52:49 <mm_freak_> what's the type of Succ?
23:53:12 <Iceland_jack> chexxor: You can also use :info
23:53:17 <leroux> Succ is a type constructor (hint).
23:53:25 <mm_freak_> leroux: no
23:53:30 <leroux> Data constr.
23:53:34 <leroux> =\
23:53:36 <chexxor> mm_freak_: good question
23:53:46 <mm_freak_> chexxor: what is Succ?
23:53:48 <chexxor> mm_freak_: Succ :: Nat
23:53:51 <mm_freak_> no
23:54:01 <mm_freak_> chexxor: give me an example of a value of type Nat
23:54:30 <chexxor> Zero :: Nat
23:54:34 <mm_freak_> correct
23:54:36 <mm_freak_> give me another one
23:54:47 <chexxor> Succ Nat :: Nat
23:54:58 <mm_freak_> ok, so apparently Succ is applied to something to yield a Nat
23:55:01 <leroux> Nat is a datatype.
23:55:05 <mm_freak_> oh, almost
23:55:07 <mm_freak_> Succ Zero :: Nat
23:55:10 <leroux> Yep.
23:55:36 <mm_freak_> given that expression you can read two things
23:55:44 <mm_freak_> 1. Succ Zero is a value of type Nat
23:55:55 <mm_freak_> 2. Succ is applied to something, so certainly it is a function
23:55:57 <Iceland_jack> chexxor: Note that another way of defining Nat (that makes the type signature explicit is):
23:55:58 <Iceland_jack>     data Nat where
23:55:58 <Iceland_jack>         Zero :: Nat
23:55:58 <Iceland_jack> 	Succ :: Nat -> Nat
23:56:09 <mm_freak_> Iceland_jack: please stop spoiling already!
23:56:17 <mm_freak_> i'm done now
23:56:28 <chexxor> haha
23:56:31 <Iceland_jack> ah sorry! I could've sworn that had already been posted
23:56:44 <chexxor> woah, a type function?
23:57:00 <ellipsis_> Iceland_jack: That notation works?
23:57:08 <mm_freak_> ellipsis_: no
23:57:19 <mm_freak_> oh, yes
23:57:26 <ellipsis_> mm_freak_: awesome. TIL
23:57:43 <mm_freak_> but you need one of two extensions to write it that way
23:57:48 <ellipsis_> which ones?
23:57:56 <ellipsis_> or will GHC tell me if I try
23:58:06 <mm_freak_> either GADTs or that other extension, which permits using GADT syntax without actually allowing GADTs
23:58:09 <Iceland_jack> ellipsis_: it will tell you
23:58:20 <ellipsis_> neat
23:58:42 <ellipsis_> I'll have to refactor some code now
23:58:43 <ellipsis_> :D
23:58:52 <chexxor>  data Nat = Zero | Succ Nat
23:59:07 <chexxor> Zero is data, of type Nat
23:59:43 <chexxor> Succ is a function, of type Nat
23:59:51 <mm_freak_> chexxor: Nat is not a function type
