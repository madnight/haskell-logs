00:06:03 <johnw> eflister: you'll need to "lift x" and have the whole computation in the Reader
00:31:24 <eflister> johnw: thanks, but i can't get it to work.  are you thinking ReaderT r (ParsecT s u Identity) a?  cuz i'd prefer ParsecT s u (readerT r Identity) a -- i know they're isomorphic, but i don't want to imply that the parsec backtracking can see different environments...
00:32:37 <eflister> lifting x would wrap a transformer around it, right?  but x already has the parsec/reader stack.  it's combining it with y, which is parsec/identity, which i'm struggling with...
00:51:58 <johnw> hello all, the haskell mailing list archives should now be fully restored, thanks to leroux
00:52:09 <johnw> please let #haskell-infrastructure know if there are any further issues
00:53:27 <__jim__> are there any good tutorials for haskell arrays?
00:58:06 <m3ga> +1 leroux!
01:02:01 <Cale> __jim__: I'm not sure about tutorials, but have you seen the Haddock documentation?
01:02:03 <user123abc> I have some poorly performing code that uses two kinds of mutable vectors, each built by a monadic map over some list, in which that vector is the target of writes
01:02:33 <__jim__> hm
01:02:40 <user123abc> a vector of the second kind is built for each element of the list which is used to build the first vector
01:02:54 <user123abc> and in order to build that vector, I need a complete picture of the entire state of the first vector
01:03:00 <user123abc> http://lpaste.net/3171872569737347072
01:03:13 <user123abc> here's a poorly performing version of what I describe
01:03:19 <user123abc> I can add some more context if you need it
01:03:35 <startling> user123abc, have you profiled?
01:03:38 <user123abc> yeah
01:03:46 <alas> hmm
01:04:05 <startling> user123abc, what's your biggest cost center?
01:04:08 <user123abc> the issue is that, in the code above, where I use V.freeze to get an immutable picture of the first vector
01:04:39 <user123abc> the O(n) copy is causing heap blowup
01:05:02 <user123abc> the biggest cost center is "assColor"
01:05:26 <alas> > 1+1
01:05:29 <lambdabot>   2
01:05:29 <__jim__> Cale: I haven't actually seen that yet. I'm still pretty new to Haskell, so I was not aware of that yet
01:05:32 <Cale> __jim__: The two most important modules here are IArray and MArray, which should give you an idea of the operations available on immutable and mutable arrays respectively http://hackage.haskell.org/package/array
01:05:44 <user123abc> type profiling shows MUT_ARR_PTRS_FROZEN as the most expensive thing (corresponding to the allocation from assColor)
01:05:57 <__jim__> Cale: thank you!
01:06:22 <Cale> and then there's the Ix class, which just has a few operations which are required in order to be able to index an array with a given type http://hackage.haskell.org/package/base-4.5.0.0/docs/Data-Ix.html#t:Ix
01:06:24 <user123abc> I think I understand the issue, and what I'd like to do - namely, like I said, I think the O(n) copy in freeze is the issue
01:06:50 <user123abc> and I'd like to just reference the mutable vector inside of the map which builds the inner vector
01:06:56 <alas> > import Text.Regex
01:06:59 <lambdabot>   <hint>:1:1: parse error on input `import'
01:07:08 <user123abc> but I could use some advice on how to do this
01:07:35 <alas> maybe lambdabot cannot import anything
01:08:15 <shachaf> Maybe lambdabot isn't ghci.
01:08:16 <user123abc> namely, am I allowed to read from vector A (the "outer" vector, cols in assColor) in the same monad in which I write to vector B (mask in mark_col_used by)?
01:08:47 <johnw> is there a function that flips an Ordering?
01:09:17 <johnw> ah, Down
01:09:31 <shachaf> Er, what?
01:09:38 <alas> i find that splitRegex in Text.Regex can't distinguish 'a.*a'(greedy) from 'a.*?a'(non-greedy).
01:10:49 <user123abc> should I try to explain the issue some more?
01:10:57 <alas> for the sake of example, splitRegex (mkRegex "{{{.*?}}}") "asdf{{{fdsa}}}zxcv{{{vcxz}}}qwer" shows ["asdf", "qwer"]
01:12:30 <__jim__> so, I see how to make one dimensional arays, but I get stuck on mult-dimensional
01:13:01 <Kaini> alas, you could try something like {{{[^}]*}}}, assuming that works well enought in your case
01:13:15 <__jim__> so you can bound it such that ((lower,lower), (upper, upper)), but what would the list comprehension be for something like that
01:15:16 <alas> thank you Kaini. but i want to make it work even when there is one or two '}' between {{{ and }}} if possible
01:19:01 <Kaini> alas, "The syntax of regular expressions is otherwise that of egrep (i.e. POSIX "extended" regular expressions)." I think .*? is a Perl extension.
01:22:25 <Cale> __jim__: range :: (Ix a) => (a, a) -> [a]
01:22:46 <__jim__> Ok, so I can get a list comprehension to work with Data.Array, but Data.Array.Iarray gets an error
01:22:53 <Cale> IArray
01:23:40 <__jim__> sorry, typo. GHCI seems to think that the valid code for Data.Array is ambiguous when I use it for Data.Array.IArray
01:24:23 <Cale> __jim__: Ah, what error are you getting? Sometimes you might have to write a type signature or two because there are many different instances of IArray for which the same code would work.
01:25:54 <__jim__> ah, ok.
01:26:14 <__jim__> This is the error: Ambiguous type variables `a0', `e0' in the constraint:
01:26:14 <__jim__>       (IArray a0 e0) arising from a use of `array'
01:26:14 <__jim__>     Probable fix: add a type signature that fixes these type variable(s)
01:26:14 <__jim__>     In the expression:
01:26:17 <__jim__>       array
01:26:20 <__jim__>         ((0, 0), (3, 3))
01:26:23 <__jim__>         [((i, j), - 1) | i <- range (0, 3), j <- range (0, 3)]
01:26:26 <__jim__>     In an equation for `xs':
01:26:30 <__jim__>         xs
01:26:33 <__jim__>           = array
01:26:36 <__jim__>               ((0, 0), (3, 3))
01:26:40 <__jim__>               [((i, j), - 1) | i <- range (0, 3), j <- range (0, 3)]
01:27:04 <__jim__> I might be overthinking this too, coding in the middle of night isn't always a great idea
01:30:40 <hari_> hi
01:34:03 <sisig> hi
01:34:16 <hari_> hello
01:34:47 <t0rus> hey
01:35:30 <notdan> Why is threadscope saying that I am improving my running time when using multiple cores, while UNIX time disagrees?
01:35:47 <sisig> whats up
01:35:51 <notdan> Is that due to multithreaded rts startup time?
01:36:44 <donri> notdan: needs moar criterion :)
01:37:19 <notdan> True! Gonna do that
01:37:48 <donri> notdan: you can make two cabal benchmark suites for the same code with different ghc-options
01:40:33 * hackagebot querystring-pickle 0.1.7 - Picklers for de/serialising Generic data types to and from query strings  http://hackage.haskell.org/package/querystring-pickle-0.1.7 (BrendanHay)
01:56:53 <eflister> can anyone help me on my parsec questions above?  (23:52-00:25)
02:01:01 <quchen> eflister: We have users from pretty much all timezones here, so that range doesn't really work for most of us. For me it means you asked 10 hours ago.
02:03:19 <lpaste> flebron pasted “Why does this run for more than one second?” at http://lpaste.net/94189
02:09:15 <donri> flebron: duno if it matters but are you compiling with or without -threaded? try both
02:09:58 <flebron> Same if I add or remove -threaded. Do you get a different result?
02:11:48 <eflister> quchen: ok, wasn't sure if the timestamps were standardized at wherever the server is for easier reference.  it's just a couple screenfuls above from a couple hours ago, but i'll resend:
02:11:54 <eflister> i have a parsec ParserT like p = A <$> x <*> y.  two questions:  i want the x, but not y, parser to also be a Reader.  is there any way to do that (preferably keeping applicative style), or am i stuck in a single transformer stack?  second, x and y involve (whiteSpace $ makeTokenParser haskellDef) from Text.Parsec.Token, which seems to lock me in to a String stream and Identity base monad.
02:11:59 <eflister> why isn't haskellDef polymorphic, and how can i use it in my ParsecT s u (ReaderT r Identity) a?
02:16:58 <Xunie`> I find that Haskell has a certain elegance to it's solutions and code.
02:17:03 <Xunie`> I pride myself in writing pretty code.
02:17:14 <Xunie`> I can't seem to make this more prettier: getArgs >>= (\x -> return (x !! 0))
02:18:16 <Xunie`> I seem to replicate the (\x -> return (f x)) a lot.
02:18:20 <Xunie`> Is there something I'm missing?
02:18:36 <Cale> fmap
02:18:46 <Cale> fmap (!! 0) getArgs
02:19:08 <flebron> \x -> return (f x) is return . f.
02:19:24 <Cale> x >>= return . f is the same as fmap f x
02:19:54 <kylcarte> Xunie`: or, in your earlier case: '(!! 0) <$> getArgs'
02:19:57 <flebron> Sure.
02:20:23 <kylcarte> which is the same as 'fmap (!! 0) getArgs'
02:20:36 <donri> flebron: yeah i get the same result, weird. even with threadDelay 1. not without any threadDelay though
02:22:18 <Xunie`> :t <$>
02:22:20 <lambdabot> parse error on input `<$>'
02:22:22 <Xunie`> :/
02:22:29 <kylcarte> :t (<$>)
02:22:30 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:22:38 <Xunie`> Oh yeah. Damn.
02:22:51 <eflister> hey Cale, would you mind taking a look at my question?  :)
02:23:34 <Cale> eflister: hmm
02:23:45 <Cale> eflister: I don't think I understand the question
02:23:59 <eflister> Cale: how can i clarify?
02:24:14 <quchen> eflister: In "x <*> y", the parsers have to have the same type, since the type of <*> is `fff (a->b) -> fff a -> fff b`.
02:24:24 <Cale> "i want the x, but not y, parser to also be a Reader"
02:24:29 <Cale> What does that mean?
02:24:33 <donri> flebron: maybe it has something to do with this caveat "There is no guarantee that the thread will be rescheduled promptly when the delay has expired"
02:25:01 <quchen> Cale: I think he wants (x :: ParsecT Identity) and (y :: ParsecT Reader) in x <*> y.
02:25:20 <Cale> uhh, yeah, that doesn't work
02:25:29 <Cale> (if that's what he means)
02:25:37 <eflister> Cale/quchen: well i already wrote a bunch of parsers (x's, y's, etc), and now just one of them needs to read an environment.  they're all combined in applicative styles in other parsers, and so i want to minimize the impact of making it a reader.
02:26:04 <Cale> How about instead of making it involve a Reader monad, just adding an extra function parameter?
02:26:59 <eflister> quchen: correct interpretation, but switch x/y :)  cale: yeah, but it's several levels down and i wanted to thread the environment down with a reader.  can i do it in non applicative style?
02:27:19 <Cale> Reader is great some of the time, particularly when you get a lot of benefit from 'local', but a lot of the time, it doesn't really save any trouble (you pay for in lifts what you made up in parameter passing)
02:27:54 <Cale> It's not magic, you have to lift all your other actions into the same monad
02:28:41 <eflister> Cale: isn't that kind of a disaster from just needing one out of a million parsers to be a Reader?
02:28:50 <Cale> If you're going to use reader at all here, probably what you want is ReaderT over your parsing monad, and then you can lift the other actions
02:29:19 <Cale> But that can be more cumbersome than just passing an additional parameter
02:30:01 <eflister> i was preferring ParsecT s u (Reader b) a, so as not to imply the parsec backtracking could change environements.  but you mean ReaderT b (ParsecT s u) a, right?
02:30:10 <Cale> yes
02:30:17 <Cale> er
02:30:25 <Cale> Not ParsecT
02:30:28 <Cale> just Parser
02:30:43 <eflister> Cale: oh yeah missing an Identity there
02:31:09 <eflister> Cale: then i can lift the other parsers in my <*> chain without having to modify their definitions/types?
02:31:19 <Cale> right
02:31:43 <eflister> Cale: great, i'll try it thanks!  thought i was being clever with my reason to prefer the other order, oh well...
02:31:46 <Cale> Just to be clear, that's not likely how I'd do it
02:32:01 <Cale> (I'd just introduce a new explicit parameter)
02:32:06 <eflister> Cale: you mean pass it in, right?  it's just that it goes through a bunch of levels.
02:32:18 <Cale> yeah, but you'll end up changing things on all those levels anyway
02:32:32 <eflister> Cale: just types tho, right?
02:32:40 <Cale> uhhh, maybe
02:32:57 <Cale> But if there are any parsing primitives, those will have to be lifted
02:33:40 <eflister> Cale: oh hrm...  well i'll see how it goes.  how about the haskellDef question?
02:33:41 <Cale> also, is there a reason you're using (whiteSpace $ makeTokenParser haskellDef)?
02:33:52 <Cale> over something like spaces?
02:34:07 <eflister> Cale: yeah, i am parsing a text format that i want to include haskell-like comments
02:34:15 <Cale> ah, okay
02:35:20 <eflister> Cale: why didn't they make it polymorphic?
02:36:11 <Cale> Well, the non-polymorphic bit is haskellDef
02:36:37 <Cale> I don't know exactly why it's not
02:37:10 <eflister> Cale: right, but why does it care if it's String vs. Text/ByteString etc?  or transforming a non-identity base monad?
02:37:10 <Cale> http://hackage.haskell.org/package/parsec-3.1.3/docs/src/Text-Parsec-Language.html#haskellDef -- you might try copying the definitions from here, and seeing whether they generalise
02:38:54 <eflister> Cale: ha, good idea, why didn't i think of that :)
02:39:38 <eflister> Cale: thanks, you're always a huge help!
02:39:43 <Cale> no problem
02:49:27 * simukis_ would like to write myself `money :: Producer a Money IO ()`. Any brilliant ideas?
03:04:52 <Polarina> simukis_, Not in scope: type constructor or class `Money'
03:10:35 <stephe> d\\
03:15:08 <volko> trying to install entropy via cabal on windows. It claims to be cross platform, but I just get an error about failing to find System.Posix
03:15:54 <volko> am I missing something?
03:16:22 <Cale> volko: What GHC version?
03:17:48 <volko> $ ghc --version
03:17:49 <volko> The Glorious Glasgow Haskell Compilation System, version 7.6.3
03:17:49 <volko> \Users\\josh\\AppData\\Local\\Temp\\5276.c","-o",
03:17:52 <volko> er, whoops
03:17:56 <Cale> hmm, okay
03:18:29 <Cale> oh, hmm
03:20:53 <Cale> That is actually pretty interesting. The entropy package doesn't list the unix package as a dependency, but that's where System.Posix lives.
03:21:35 <Cale> and it definitely imports stuff from System.Posix
03:21:36 <eflister> Cale: thanks, you're always a huge help!
03:21:45 <eflister> whoops wrong window
03:22:28 <donri> Cale: i think there might be an issue with displaying conditional dependencies in hackage 2 http://hackage.haskell.org/package/entropy-0.2.2.3/entropy.cabal
03:23:14 <donri> hm although i don't see it on old hackage either http://old.hackage.haskell.org/package/entropy
03:23:47 <donri> oh actually that's an old version which doesn't have that conditional dependency
03:24:39 <Cale> http://hackage.haskell.org/package/entropy-0.2.2.3/docs/src/System-Entropy.html -- looking at the source, the import of System.Posix is unconditional. Is it part of another package on Windows?
03:25:59 <donri> you're right, looks bugged
03:26:12 <donri> volko: try the previous version and report the bug upstream
03:26:48 <donri> volko: cabal install entropy --constraint 'entropy < 0.2.2.3'
03:27:03 <Cale> Yeah, the previous version looks like it ought not to have that problem.
03:27:14 <donri> and report here https://github.com/TomMD/entropy/issues
03:31:48 <volko> w00t
03:31:49 <volko> that worked
03:31:52 <volko> thank you donri and Cale
04:05:40 * hackagebot haskell-updater 1.2.0.11 - Rebuild Haskell dependencies in Gentoo  http://hackage.haskell.org/package/haskell-updater-1.2.0.11 (SergeiTrofimovich)
04:55:43 * hackagebot pipes-postgresql-simple 0.1.0.0 - Convert various postgresql-simple calls to work with pipes  http://hackage.haskell.org/package/pipes-postgresql-simple-0.1.0.0 (OliverCharles)
05:01:58 <sx> i know this question is a bit off topic, but are there packages for debian wheezy with newer versions of ghc? because it never works when i'm trying to build the package by myself (either from source or from the binary distribution)
05:04:22 <Cale> sx: Er, what if you just install the binary distribution? I tend not to rely on my distribution's packages, because they're frequently out of date.
05:04:52 <chrisdone> hm, is there anywhere a really small version of GHC that doesn't come with shared, interpreted, profiling libs?
05:04:55 <Cale> In order to compile GHC yourself, you will need to have a working already installed GHC.
05:05:03 <Cale> chrisdone: hmm
05:05:06 <chrisdone> i mean, a distribution, other than compiling myself
05:05:18 <Cale> (yeah, my comment was aimed more at sx)
05:05:26 <chrisdone> yeah =)
05:05:36 <chrisdone> our questions are just coincidentally related
05:05:39 <sx> Cale: i just don't like the thought of putting files in my file system without binding them to a package. I have ghc 7.4.3 from my repositories already installed
05:09:47 <chrisdone> i'mma try compiling a recent release, see if there's anything about excluding libs in the ./configure
05:16:16 <xrdb> if one were to write a more convenient wrapper for http://hackage.haskell.org/package/freetype2-0.1.1/docs/Graphics-Rendering-FreeType-Internal.html, would it be wise to make functions like ft_Get_Char_Index pure by using unsafePerfomIO?
05:18:58 <benmachine> xrdb: iff they really are pure
05:19:04 <benmachine> are fonts mutable?
05:19:57 <benmachine> I'd guess no, from the various FT_Set_blah
05:20:00 <benmachine> er
05:20:01 <benmachine> yes
05:23:17 <xrdb> benmachine, i think for a fixed FT_Face and FT_UInt, Get_Char_Index will always give the same result
05:23:53 <chrisdone> lol, extracted ghc onto this system. watching df -h: Size: 1014MB, Used: 111MB → extract GHC → Used: 947MB  *wipes sweart from brow*
05:25:49 <benmachine> xrdb: so what do the Set things do?
05:26:04 <benmachine> chrisdone: eep
05:26:33 <AshyIsMe> so is there a good haskell vim plugin for proper indenting?
05:26:47 <chrisdone> not sure i'm actually going to be able to install it if ghc is just going to copy itself to another location
05:26:47 <AshyIsMe> by default i seem to have to press tab a lot
05:27:03 <pancakeface> Ok, been playing with haskell for the first time this week (first week FP actually) and started looking at the 48hr Write a Scheme tutorial. When I have args <- getArgs and then it asks me to do that and add two args together, but first converting them from Strings to ints using "read" I have no idea how to do that.
05:27:35 <chrisdone> AshyIsMe: remember when we started writing a web server for viewing darcs repos in scheme?
05:27:37 <pancakeface> nevermind
05:27:39 <xrdb> benmachine: well some things are mutable, a face is something like "Arial"
05:27:52 <chrisdone> AshyIsMe: back in '08
05:28:54 <AshyIsMe> woah, very vaguely
05:29:17 <AshyIsMe> that's a blast from the past
05:30:14 <xrdb> benmachine, but without a fixed fontsize and so on specified
05:30:34 <chrisdone> :D
05:30:50 <AshyIsMe> i dont remember getting very far with it haha
05:30:55 <chrisdone> haha, me neither
05:31:13 <AshyIsMe> that must have been around the time i was working on my trading system backtester in c++ and lua
05:31:24 <chrisdone> @_@
05:31:46 <AshyIsMe> haha
05:31:57 <AshyIsMe> is this you? https://github.com/chrisdone
05:32:13 <chrisdone> yeah =p
05:32:41 <AshyIsMe> followed you
05:32:52 <chrisdone> what's yours?
05:33:02 <AshyIsMe> https://github.com/ashyisme
05:33:09 <chrisdone> lol
05:33:10 <chrisdone> woot
05:33:25 <AshyIsMe> havent got much public on there yet
05:33:37 <chrisdone> you like The Prodigy, right?
05:33:56 <AshyIsMe> i finished uni and promptly got a job working in access97 vba for about 5 years
05:34:05 <chrisdone>  oh noes D:
05:34:09 <AshyIsMe> haha
05:34:20 <chrisdone> actually i did see some experimental tab cycle in vim for haskell, hang on
05:34:39 <AshyIsMe> yeah i was big on the prodigy for a while there
05:35:23 <chrisdone> https://www.youtube.com/watch?v=EIs2YEcM9LY
05:35:25 <benmachine> AshyIsMe: maybe three or four more years before people can get the job who are younger than the software
05:35:33 <chrisdone> vim indenter ^
05:36:08 <AshyIsMe> benmachine: haha yeah
05:36:21 <AshyIsMe> they've since upgraded that project to access2003 i think
05:36:36 <AshyIsMe> and we were already working on the .net successor at the time
05:37:01 <chrisdone> working on making the platform itself?
05:37:38 <AshyIsMe> i dont work for that company anymore, it's an accounting package
05:38:06 <AshyIsMe> just happened to be written in access because it started out as a specific thing for a single client
05:38:43 <AshyIsMe> working for a consulting company now, supporting a few different .net web apps
05:39:37 <AshyIsMe> figured i would finally get around to learning haskell
05:41:52 <chrisdone> sweet =)
05:42:26 <AshyIsMe> bout you, what've you been up to?
05:45:09 <AshyIsMe> oh wow you made tryhaskell.org
05:45:10 <chrisdone> spent the past five years haskelling =p mostly web dev
05:45:11 <AshyIsMe> nice
05:46:12 <chrisdone> presently trying to get ghc installed on a puppy linux live cd
05:47:51 <dalaing1> I'm writing a quick check property and getting a weird type error
05:48:25 <dalaing1> Expected type: [Token]
05:48:25 <dalaing1>       Actual type: [attempt1-0.1.0.0:Token.Token]
05:48:54 <dalaing1> attempt1 being the name of this particular project
05:49:52 <dalaing1> I'm using Alex in amongst this, and am wondering if that's having some kind of effect
05:50:28 <dalaing1> does anyone have any ideas?
05:52:33 <chrisdone> two different package versions are in use
05:52:57 <chrisdone> the first will be the one for your program/lib, the second will be the one used by a library you're using, i guess
05:53:34 <chrisdone> or you have a local module being imported directly, which will be considered different to a library module
05:54:03 <dalaing1> ahhh, thanks heaps
05:54:08 <dalaing1> I love this channel
05:58:37 <pancakeface> Parsec's oneOf should return true if any char in the string is one in the list provided, correct?
05:58:38 <skypers> hey
05:58:47 <briennetheblue> @pl \(a, (b, c)) -> ((a, b), c)
05:58:50 <lambdabot> ap (flip (ap . flip ((.) . ((,) .) . (,)) fst) snd . fst) snd
05:58:50 <lambdabot> optimization suspended, use @pl-resume to continue.
05:58:57 <briennetheblue> hm no
05:58:57 <skypers> why isn’t the extension ScopedTypeVariables automatically supported by GHC?
05:59:01 <chrisdone> :t Text.Parsec.oneOf
05:59:02 <lambdabot> Text.Parsec.Prim.Stream s m Char => [Char] -> Text.Parsec.Prim.ParsecT s u m Char
05:59:02 <skypers> it’s kinda useful
05:59:08 <chrisdone> pancakeface: it returns a character
05:59:34 <chrisdone> skypers: because it changes the meaning of a program
06:00:02 <pancakeface> it returns the first of the characters found then?
06:00:45 <chrisdone> pancakeface: it only parses one character. it parses a character is one of the given ones you provide
06:00:55 <skypers> chrisdone: ?
06:00:58 <skypers> well
06:01:27 <skypers> it lets us type variables in function scopes
06:01:38 <skypers> how would it change the meaning of a program?
06:01:39 <chrisdone> > Text.Parsec.parse (Text.Parsec.oneOf "ab") "" "a"
06:01:40 <lambdabot>   Not in scope: `Text.Parsec.parse'Not in scope: `Text.Parsec.oneOf'
06:01:59 <pancakeface> Ahh I see
06:02:07 <chrisdone> λ> parse (oneOf "ab") "" "ab"
06:02:08 <chrisdone> Right 'a'
06:02:14 <chrisdone> λ> parse (many (oneOf "ab")) "" "ab"
06:02:15 <chrisdone> Right "ab"
06:02:58 <skypers> what the heck is λ> here?
06:03:01 <skypers> λ> Just 4
06:03:03 <chrisdone> my prompt =)
06:03:09 <skypers> oh
06:03:15 <chrisdone> skypers: f :: x -> (); f = … where g :: x -> …; g = …
06:03:25 <pancakeface> confusing, but I think I follow
06:03:26 <chrisdone> skypers: in that you're saying that the two x's are the same
06:03:40 <skypers> yes
06:03:40 <chrisdone> skypers: without ScopedTypeVariables you're saying they're completely unrelated
06:03:51 <skypers> huh
06:04:00 <skypers> it could be done with RankNTypes
06:04:03 <chrisdone> they might be coincidentally unified, but the only thing they have in common necssarily is a name
06:04:04 <skypers> with forall x .
06:04:37 <skypers> so with ScopedTypeVariables
06:04:43 <skypers> both the x are exactly the same type?
06:04:55 <skypers> I thought it would always require forall
06:05:00 <skypers> I’m confused
06:05:54 <chrisdone> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#scoped-type-variables
06:07:15 <skypers> so ScopedTypeVariables discards the use of forall?
06:07:29 <skypers> oh
06:07:29 <skypers> no
06:07:37 <skypers> it has te be on to use forall
06:07:38 <skypers> ok
06:07:40 <skypers> but hm
06:07:47 <skypers> I’m writing an instance of something
06:07:48 <skypers> like
06:08:01 <skypers> instance (Foo f) => Object f where
06:08:11 <skypers> in a methode implementation
06:08:18 <skypers> I can reuse f without forall
06:08:20 <skypers> why?
06:12:53 <chrisdone> okay, here's an example:
06:13:10 <chrisdone> {-# LANGUAGE ExplicitForAll #-}
06:13:11 <chrisdone> f :: forall a. a -> ()
06:13:12 <chrisdone> f a = fst (g 'a', g 1) where
06:13:12 <chrisdone>   g :: a -> ()
06:13:14 <chrisdone>   g _ = ()
06:13:25 <chrisdone> ^ this is fine. the forall isn't required, it's implicit in haskell 98/2010, i'm just showing it to be explicit
06:13:32 <chrisdone> that compiles, however:
06:13:36 <chrisdone> {-# LANGUAGE ScopedTypeVariables #-}
06:13:36 <chrisdone> f :: forall a. a -> ()
06:13:37 <chrisdone> f a = fst (g 'a', g 1) where
06:13:37 <chrisdone>   g :: a -> ()
06:13:39 <chrisdone>   g _ = ()
06:14:26 <chrisdone> does not compile, because the a of f is re-used in g
06:14:59 <chrisdone> if i change it to
06:14:59 <chrisdone> {-# LANGUAGE ScopedTypeVariables #-}
06:15:00 <chrisdone> f :: forall a. a -> ()
06:15:00 <chrisdone> f a = fst (g 'a', g 1) where
06:15:02 <chrisdone>   g :: forall a. a -> ()
06:15:05 <chrisdone>   g _ = ()
06:15:09 <chrisdone> then we're in business again
06:15:26 <chrisdone> classes variables are automatically scoped over all its methods
06:16:01 <chrisdone> so you don't need forall there. that's just to activate the scoped extension
06:16:10 <skypers> slow down :D
06:16:54 <skypers> in your first example
06:17:00 <skypers> if you don’t have forall a.
06:17:04 <skypers> 15:07 < chrisdone>   g :: a -> ()
06:17:05 <chrisdone> see the difference? in the first and third example, g is polymorphic over *any* a. whereas in the second example, g is restricted specifically to the a from f
06:17:06 <skypers> this fails
06:17:12 <skypers> because it would be like g :: x -> ()
06:17:14 <skypers> right?
06:17:23 <chrisdone> um
06:17:28 <skypers> the a wouldn’t be the same as the a in the function type signature
06:17:33 <skypers> it would be another a variable
06:18:32 <chrisdone> the first example doesn't need the forall, i'm just showing that without ScopedTypeVariables, f :: forall a. a -> … and f :: a -> … are the same. it's turning *on* ScopedTypeVariables that makes this suddenly mean "okay scope a over everything inside this function"
06:18:57 <skypers> huh?
06:18:58 <skypers> so
06:19:04 <chrisdone> you know that in vanilla haskell 98, forall a is implicit, right?
06:19:12 <skypers> yes
06:19:18 <chrisdone> ok
06:19:24 <skypers> so we can reuse a in function scope then
06:19:34 <chrisdone> yeah
06:19:38 <skypers> ok
06:20:01 <skypers> so what’s the point of forall then?
06:20:52 <chrisdone> it just lets ScopedTypeVariables know to activate
06:21:35 <skypers> I don’t get it
06:21:45 <skypers> if I do something like
06:22:04 <skypers> foo :: String -> a
06:22:11 <chrisdone> mhm
06:22:20 <skypers> foo s = (read s :: a)
06:22:30 <skypers> I don’t need forall nor ScopedTypeVariables here
06:22:32 <skypers> right?
06:22:37 <skypers> because it’s implicit
06:22:42 <skypers> I could even right
06:22:42 <skypers> read s
06:22:53 <skypers> so it’s not a good example :D
06:23:02 <monoidal> no, you can't write read s :: a
06:23:11 <chrisdone> that a would be a different a
06:23:20 <skypers> so
06:23:23 <skypers> I need forall a
06:23:37 <monoidal> foo :: forall a. String -> a; foo s = (read s :: a) will work
06:23:39 <skypers> then it’s _not_ implicit
06:23:53 <chrisdone> monoidal: where does the Read constraint come from? =)
06:24:03 <monoidal> oh, right, forgot about it
06:24:04 <chrisdone> skypers: hold up
06:24:12 <skypers> yeah
06:24:15 <chrisdone> f :: Read a => String -> a
06:24:16 <chrisdone> f s = read s :: Read a => a
06:24:19 <skypers> foo :: (Read a) =>
06:24:20 <skypers> yeah
06:24:31 <skypers> that would work?
06:24:43 <chrisdone> yeah, that works, but i'm not sure for the reason you expect
06:24:49 <skypers> well
06:24:51 <chrisdone> f :: Read a => String -> a
06:24:51 <chrisdone> f s = read s :: Read b => b
06:24:53 <chrisdone> this is also fine ^
06:25:11 <skypers> yeah
06:25:15 <skypers> so the a are not the same
06:25:18 <chrisdone> the letters used in the first line and second line don't matter. they're just free variables that will unify
06:25:20 <chrisdone> yeah
06:25:22 <skypers> so
06:25:28 <skypers> need a better example
06:25:31 <skypers> with sizeOf
06:25:38 <skypers> foo :: Int
06:25:52 <skypers> well need a type tho :D
06:26:08 <skypers> well ok, that means per default
06:26:27 <skypers> typing in a function scope use other names
06:26:32 <chrisdone> well, the one i gave is good:
06:26:32 <skypers> not the function type signature
06:26:33 <chrisdone> f :: a -> ()
06:26:33 <chrisdone> f a = fst (g 'a', g 1) where
06:26:33 <chrisdone>   g :: b -> (); g _ = ()
06:26:52 <skypers> if I want to use the same a
06:26:55 <skypers> I need what
06:26:57 <skypers> forall?
06:27:01 <chrisdone> if you change `b' to `a' here, does it make a difference?
06:27:04 <skypers> ScopedTypeVariables?
06:27:07 <skypers> no
06:27:10 <skypers> it doesn’t
06:27:16 <chrisdone> right
06:27:21 <noam> how do i get strict & unboxed STRefs? ghc doesn't like "field :: STRef s !Int" in a record, it says 'Unexpected strictness annotation !Int'
06:27:34 <skypers> in order to use forall, I need to activate ScopedTypeVariables?
06:27:36 <chrisdone> skypers: if you write forall in both the f and g, in normal haskell 2010 -- does it make a difference?
06:28:05 <skypers> chrisdone: for me
06:28:11 <skypers> foo :: forall a . a -> ()
06:28:30 <skypers> that means any use of :: a in the function scope would result in the same type as the a in function type signature
06:28:34 <skypers> right?
06:29:33 <monoidal> skypers: in order to use forall, you need -XExplicitForAll (which is implied by ScopedTypeVariables, as well as RankNTypes)
06:29:34 <chrisdone> skypers: with ScopedTypeVariables, it means they're the same, yes
06:29:50 <skypers> monoidal: oh fuck :D
06:29:53 <chrisdone> monoidal: i've explained that, but i'm trying find a way to say it that isn't confusing
06:30:25 <chrisdone> skypers: remember, forall is /implicit/ in haskell. id :: a -> a is the same as id :: forall a. a -> a. you can't write forall in haskell 98/haskell 2010 because it would be redundant
06:30:31 <skypers> I think I need to read what are 1. ExplicitForAll 2. ScopedTypeVariables and 3. RankNTypes
06:30:47 <chrisdone> skypers: there's -XExplicitForAll so that you can write them. it doesn't mean anything additional, but it lets you write it
06:30:48 <skypers> chrisdone: whaaaaaaaaaaaat
06:30:55 <chrisdone> forget about ScopedTypeVariables and RankNTypes for now
06:30:59 <skypers> 15:21 < chrisdone> if you change `b' to `a' here, does it make a difference?
06:31:03 <skypers> you just said it’s not implicit!
06:31:51 <chrisdone> skypers: forget any extensions apart from ExplicitForAll. are f :: forall a. a -> () and g :: a -> () different types?
06:32:09 <skypers> well
06:32:24 <skypers> I think it depends
06:32:25 <skypers> for me
06:32:34 <skypers> if g is declared in f’s scope
06:32:39 <skypers> it would have an influence
06:32:44 <chrisdone> it doesn't have any influence
06:32:46 <skypers> f :: a -> ()
06:32:49 <skypers> g :: x -> ()
06:32:50 <skypers> for me
06:32:54 <skypers> they’re the same.
06:33:03 <chrisdone> mhm
06:33:09 <skypers> they both take somethink
06:33:13 <skypers> and returns unit
06:33:35 <skypers> f :: a -> ()
06:33:40 <skypers> f = …
06:33:45 <skypers>   where g :: a -> ()
06:33:46 <monoidal> with no extra extension, f :: forall a. a -> () and g :: a -> () are completely interchangable. completely - "a" is quantified implicitly in the second one
06:33:46 <skypers> here
06:33:52 <chrisdone> skypers: when would f :: forall a. a -> () and f :: a -> () ever make a difference for a top-level function declaration in haskell 2010?
06:33:53 <skypers> both the a are disconnected
06:33:55 <skypers> if I do
06:34:01 <skypers> f :: forall a . a -> ()
06:34:02 <skypers> f = …
06:34:05 <skypers>   where g :: a -> ()
06:34:06 <skypers> here
06:34:11 <skypers> if I pass
06:34:17 <skypers> f (3 :: Int)
06:34:24 <skypers> the g will be passed Int arg
06:34:35 <skypers> whereas in the first f definition
06:34:40 <chrisdone> monoidal: i want skypers to recognise that in standard haskell forall is implicit and doesn't mean anything
06:34:44 <skypers> it could be other types
06:34:54 <chrisdone> hmm, i've got to get back to work, this isn't getting anywhere. laters
06:35:02 <skypers> bye
06:35:05 <monoidal> chrisdone: i want that too
06:35:10 <monoidal> bye
06:36:04 <monoidal> skypers: in normal haskell (without -XScopedTypeVariables), type variables are implicitly quantified everywhere, including "where" blocks
06:36:15 <skypers> monoidal: so
06:36:20 <skypers> foo :: a -> ()
06:36:22 <skypers> foo = …
06:36:24 <monoidal> skypers: f :: a -> (); f = ... where g :: a -> (); g = ...
06:36:26 <skypers>   where g :: a -> ()
06:36:27 <skypers> here
06:36:31 <skypers> both the a are the same?
06:36:43 <skypers> if I write
06:36:45 <monoidal> skypers: they're independent and could as well be called a and b
06:36:53 <skypers> damn
06:36:57 <skypers> I don’t get it then.
06:37:04 <monoidal> slowly
06:37:21 <skypers> for me, “implicitly quantified everywhere” means that any a would refer the same thing
06:37:22 <monoidal> so it doesn't matter if you write "forall" or not.
06:37:40 <monoidal> skypers: the quantification is done every time when you write ::
06:37:41 <skypers> here you’re saying that g is a brand new function with its very own variables
06:38:07 <monoidal> skypers: yes - the type variables of f have no relation to type variables of g
06:38:18 <skypers> yes
06:38:19 <skypers> so
06:38:31 <skypers> forall a is disabled per default
06:38:31 <AshyIsMe> oh ghci has tab completion
06:38:32 <AshyIsMe> very nice
06:38:59 <skypers> if it was on, the g function would have a relation with the f’s a
06:39:03 <skypers> isn’t is?
06:39:06 <skypers> *it
06:39:49 <monoidal> skypers: normally, you cannot write "forall a". if you enable -XExplicitForall, then you can, and you can explicitly quantify f :: forall a. a -> () instead of f :: a -> ()
06:40:01 <monoidal> skypers: STILL, it does not mean that type variables in g have any relation to type variables in f
06:40:11 <skypers> monoidal: I don’t get it at all :D
06:40:15 <skypers> I need to experiment
06:40:24 <monoidal> skypers: remember, we still do not use scoped type variables
06:40:25 <skypers> I might not understand the meaning of forall in Haskell
06:40:41 <monoidal> skypers: "forall" by now simply enumerates variables used in a type signature
06:40:57 <skypers> monoidal: well
06:41:01 <skypers> as a default
06:41:07 <skypers> a variable a is polymorphic
06:41:12 <skypers> so it can be anything
06:41:17 <skypers> so forall is implicit
06:41:20 <skypers> is that all?
06:41:31 <monoidal> that's right, by default
06:41:34 <skypers> DAMN
06:41:35 <skypers> :D
06:41:36 <skypers> so
06:41:38 <monoidal> bare haskell 2010 with no extensions
06:42:02 <skypers> we haven’t been talking about the same thing for 15 minutes :D
06:42:29 <skypers> I thought forall was used to express the fact that a variable can be scoped
06:42:43 <monoidal> only if you enable an extra flag
06:42:52 <monoidal> but you have to learn the behavior without the flag first.
06:43:09 <skypers> let f :: a -> (); f = let g :: b -> (); g _ = () in g
06:43:11 <skypers> here
06:43:28 <skypers> a and b are not bound
06:43:49 <skypers> so g is polymorphic, and doesn’t depend on f at all
06:44:01 <skypers> now if I want it to be bound to f’s a
06:44:05 <monoidal> skypers: yes. you could have written it without "where" and it would be equally good
06:44:07 <monoidal> skypers: wait
06:44:08 <skypers> how should I do that?
06:44:12 <monoidal> not so fast.
06:44:38 <monoidal> skypers: we now enable explicit forall
06:44:43 <monoidal> skypers: you can write now
06:44:49 <monoidal> let f :: a -> (); f = let g :: b -> (); g _ = () in g
06:44:56 <monoidal> let f :: forall a. a -> (); f = let g :: b -> (); g _ = () in g
06:45:02 <monoidal> let f :: a -> (); f = let g :: forall b. b -> (); g _ = () in g
06:45:05 <monoidal> let f :: forall a. a -> (); f = let g :: forall b. b -> (); g _ = () in g
06:45:10 <monoidal> all four are equivalent
06:45:34 <skypers> huh
06:45:40 <skypers> with ExplicitForAll
06:45:42 <monoidal> yes
06:45:46 <skypers> what’s the meaning of a in
06:45:47 <skypers> 15:38 < monoidal> let f :: a -> (); f = let g :: b -> (); g _ = () in g
06:46:01 <skypers> a isn’t polymorphic anymore?
06:46:04 <monoidal> it is
06:46:07 <skypers> :D
06:46:25 <skypers> this is totally insane crap
06:46:27 <monoidal> explicit forall only allows to you to explicitly enumerate type variables used in a signature
06:46:37 <monoidal> for now, it has no extra effect
06:46:56 <skypers> then it’s useless?
06:47:05 <monoidal> skypers: by itself, yes
06:47:19 <monoidal> skypers: but if you combine it with other extensions, it gets very useful
06:47:45 <donri> does it do anything for any extension that doesn't imply it?
06:47:45 <skypers> ok
06:47:48 <skypers> so
06:47:55 <skypers> if I combine it with ScopedTypeVariables
06:48:02 <monoidal> donri: I don't think it does
06:48:09 <skypers> it makes a link between type signature variables and scoped ones?
06:48:15 <monoidal> skypers: now we turn on ScopedTypeVariables
06:48:32 <monoidal> skypers: previously, *before* the flag f :: a -> () and f :: forall a. a -> ()
06:48:40 <monoidal> were completely interchangeable. they meant the same thing
06:49:14 <monoidal> skypers: but now, with scoped type variables, the second definition has a side effect of introducting "a" into scope in local type signatures
06:50:16 <skypers> ok
06:50:17 <skypers> got it.
06:50:25 <monoidal> skypers: so, f :: forall a. a -> (); f = ... where g :: a -> (); g = ... - now, the "a" in "g" is bound to be the same variable on which you call f
06:50:28 <skypers> this is actually what I always knew
06:50:35 <skypers> ok
06:50:36 <monoidal> skypers: but consider
06:50:39 <skypers> but if you write
06:50:41 <skypers> g :: b -> ()
06:50:44 <skypers> it doesn’t compile
06:50:51 <skypers> because of types mismatch
06:50:52 <skypers> right?
06:51:00 <monoidal> skypers: what is the complete code?
06:51:26 <skypers> f :: forall a. a -> (); f = g where g :: b -> (); g = …
06:51:36 <monoidal> skypers: this is equivalent to
06:51:55 <monoidal> f :: forall a. a -> (); f = g where g :: forall b. b -> (); g = …
06:52:09 <monoidal> since you named "b" differently from "a", it is implicitly quantified
06:52:19 <skypers> so it does compile?
06:53:00 <monoidal> yes - the same way id1 :: a -> a; id1 = id2; id2 :: b -> b; id2 x = x compiles (note no "where")
06:53:18 <skypers> ok
06:53:27 <skypers> so ScopedTypeVariables doesn’t restrict anything by default
06:53:29 <skypers> got it
06:53:36 <skypers> it’s just a way to make links
06:53:41 <skypers> not break
06:53:42 <skypers> :)
06:53:57 <monoidal> if you don't use "forall", a program with ScopedTypeVariables is equivalent to one without the flag
06:54:01 <monoidal> it's backwards compatible
06:54:05 <skypers> yeah
06:54:09 <skypers> thank you :)
06:54:12 <skypers> but now
06:54:12 <donri> it "breaks" things if you have a scoped type signature with an "a" in it that you expect to be something else
06:54:17 <skypers> my real issue.
06:54:21 <skypers> http://lpaste.net/5100729518943895552
06:54:26 <skypers> I don’t use forall
06:54:28 <donri> but yeah that's only if you forall on the outer type sig
06:54:28 <skypers> hence it works.
06:54:40 <monoidal> it can break programs where you use explicitforall
06:55:29 <skypers> in my paste
06:55:38 <skypers> I thought I would need to write the instance that way
06:55:49 <skypers> instance forall s . (Shader s) => Object s where
06:55:59 <skypers> in order to reuse it in (undefined :: s)
06:56:09 <skypers> but it sounds to be already connected
06:56:14 <skypers> because it’s a class instance
06:56:15 <skypers> like
06:56:19 <skypers> class Foo f where
06:56:22 <skypers>   foo1 :: f -> ()
06:56:27 <monoidal> let me check this. I don't know what happens here.
06:56:27 <skypers> both the f are the same
06:56:40 <skypers> I think it’s because of what I said :)
06:58:20 <donri> skypers: also you might want to use proxies for this
06:58:33 <skypers> well donri
06:58:38 <donri> but might still need scoped type vars
06:58:45 <skypers> we already talked about that yesterday
06:58:51 <donri> also instance sigs if you're gonna forall a method sig
06:58:53 <skypers> and I think it’s not worth it
06:59:43 <donri> but vars from the instance context might already be scoped, not sure
07:00:26 <skypers> btw
07:00:34 <skypers> RankNTypes
07:00:36 <monoidal> skypers: donri seems to be right
07:00:41 <skypers> what is it for?
07:00:48 <skypers> monoidal: what about? proxying?
07:01:03 <monoidal> skypers: if you write instance Object s where ... then the variable "s" is bound inside the instance
07:01:21 <skypers> yeah
07:01:25 <skypers> that sounds logic
07:01:34 <skypers> because it’s the same behavior in class definition
07:01:36 <monoidal> skypers: btw doesn't your code need undecidable instances?
07:01:42 <skypers> it does :)
07:01:47 <skypers> I have a few extensions
07:01:50 <skypers> undecidable
07:01:52 <skypers> flexiable
07:01:55 <monoidal> skypers: look at this http://stackoverflow.com/a/3216937
07:01:56 <skypers> and scoped type variables
07:02:12 <monoidal> you shouldn't write instance (Shader s) => Object s
07:03:33 <skypers> I don’t get why
07:03:37 <skypers> if I don’t
07:03:44 <monoidal> the link explains the reason
07:03:46 <skypers> I have to write an instance for each instance of Shader
07:03:49 <skypers> it’s annoying
07:04:11 <donri> type Object s = Shader s -- done, yay constraint kinds!
07:05:13 <skypers> huh, what? :D
07:05:45 <skypers> Object is a general-purpose class
07:05:51 <donri> your object class is a synonym for shader
07:07:05 <Vamp> Could someone give me an example of how to write an Ord instance for your own datatype?
07:07:25 <skypers> ok so the instance resolution works at the right of instance =>
07:07:26 <skypers> so
07:07:35 <skypers> instance (Foo f) => Show f where
07:07:36 <skypers> here
07:07:42 <skypers> it doesn’t know the constraint yet
07:07:43 <donri> Vamp: instance Ord () where compare _ _ = EQ
07:07:53 <skypers> so it would make any type an instance of Show
07:07:55 <skypers> right?
07:08:00 <skypers> then it will fail
07:08:04 <skypers> and read the constraint
07:08:27 <monoidal> once it takes to find Foo f, it will not backtrack
07:08:31 <monoidal> *it fails
07:08:46 <skypers> once the compiler has committed to the choice of using your instance, (just by virtue of the fact that 'a' unifies with everything) it has no chance to fall back and use any other instances!
07:08:50 <skypers> so that means
07:08:52 <donri> skypers: it blocks any other instance, ie. you can only have that one instance, ie. it's an alias for Shader
07:08:54 <skypers> it could break other Show instances?
07:09:23 <monoidal> yes. if you have Show TypeX, the compiler might overlook that instance, use yours, and fail to use Foo TypeX
07:09:29 <skypers> it’s good to know
07:09:35 <skypers> then I need to write all the instances
07:09:38 <skypers> because no donri
07:09:48 <skypers> Object is not an alias of Shader
07:09:55 <skypers> Object has a LOT of instances in my engine
07:10:00 <donri> skypers: it is in your paste
07:10:06 <skypers> (Buffer, Framebuffer, Texture and so on)
07:10:08 <adas> I am in the IO monad. Inside the IO monad I have an Either value which is also a monad. is it possible to lift the Either value from the Either monad to the IO monad?
07:10:15 <skypers> yeah I’m not about to dump my 3D engine code
07:10:23 <skypers> it’s a lot of lines :D
07:10:27 <adas> there is a function called 'lift' in monad.trans but not sure if that is appropriate
07:10:33 <monoidal> adas: you can't change IO (Either ...) to Either (IO ...) (IO ...)
07:11:04 <skypers> adas: lift actually lifts a monad into another
07:11:05 <donri> adas: "return". bam.
07:11:40 <adas> donri: but return, gives me an IO (Either  ...)
07:11:42 <donri> adas: if you want to run IO from Either you need EitherT IO, then lift works
07:11:54 <skypers> :t lift $ Right 3
07:11:55 <lambdabot> (Num a, MonadTrans t) => t (Either a1) a
07:11:56 <monoidal> adas: what type do you need?
07:12:34 <adas> im in main whose type is IO (). INside main i have an Either.
07:13:05 <adas> I would like to take "Right a" and make it to an "IO a"
07:13:10 <adas> something tells me thats not possible
07:13:23 <monoidal> what if you have Left?
07:13:50 <monoidal> case x of Right a -> return a; Left a -> ...
07:14:19 <adas> monoidal: dang.. so simple.. thanks
07:14:49 <donri> :t either
07:14:50 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
07:15:14 <monoidal> adas: however, do you really need the IO a? it sounds a little strange (though it has uses)
07:15:16 <donri> :t either fail return
07:15:17 <lambdabot> Monad m => Either String a -> m a
07:17:58 <adas> monoidal: perhaps i don't.. i can simply do 'return (Either a b)' and Ill get 'IO (Either)'. but when i do the printing, it print with the 'Right ....' or 'Left ...'
07:18:28 <donri> :t either print print
07:18:29 <lambdabot> (Show a, Show b) => Either a b -> IO ()
07:19:20 <monoidal> adas: I think it's better to return the Either a b type, and remove Right/Left during printing (using donri's function)
07:20:57 <donri> :t either (hPutStrLn stderr) putStrLn
07:20:58 <lambdabot>     Not in scope: `hPutStrLn'
07:20:59 <lambdabot>     Perhaps you meant one of these:
07:20:59 <lambdabot>       `BS.hPutStrLn' (imported from Data.ByteString),
07:21:03 <donri> :(
07:21:54 <Athan> :t either (BS.hPutStrLn) BS.putStrLn
07:21:55 <lambdabot>     Couldn't match type `IO ()' with `BSC.ByteString -> IO ()'
07:21:55 <lambdabot>     Expected type: BSC.ByteString -> BSC.ByteString -> IO ()
07:21:55 <lambdabot>       Actual type: BSC.ByteString -> IO ()
07:22:24 <donri> :t stderr
07:22:25 <lambdabot> Not in scope: `stderr'
07:22:34 <Athan> dude
07:22:46 <Athan> ghci, yo
07:22:53 <Athan> probably be better for learning
07:23:02 <donri> :t either (System.IO.hPutStrLn System.IO.stderr) putStrLn
07:23:03 <lambdabot> Either String String -> IO ()
07:23:23 <Athan> Good man!
07:23:27 <donri> i'm not learning, i'm teaching adas
07:23:35 <Athan> sorry!
07:24:39 <Athan> is that Either (String) (String -> IO ())
07:24:40 <Athan> ?
07:24:47 <Athan> is my nesting correct?
07:24:59 <quchen> No, it's (Either String String) -> IO ()
07:25:01 <donri> there is no nesting
07:25:05 <Athan> derp
07:25:34 <donri> :)
07:25:41 <Athan> please go on! This is amazing!
07:26:12 <donri> oh i was sort of done
07:27:27 <Athan> :/
07:27:45 <Athan> Can you teach me denotational semantics?
07:27:56 <Athan> I'm having trouble assessing where it's used in Haskell
07:28:12 <Athan> At the computation level, at the type matching level, etc.?
07:28:32 <Athan> I feel like it could be graphed or something
07:28:57 <Athan> how the lambdas at the type, class, data, etc.'s capabilities / expectations
07:29:23 <mm_freak> Athan: denotation semantics is at the value level
07:29:34 <mm_freak> +al
07:30:52 <donri> even with type-level programming?
07:30:58 <mm_freak> Athan: imagine DS as a function from source code to mathematical formulae
07:31:18 <mm_freak> donri: well, at least in standard haskell
07:31:33 <donri> aye
07:31:39 <mm_freak> to DS everything looks like values
07:51:25 <Athan> sorry man my puter went out
07:51:31 <Athan> but anyway DS
07:52:50 <Athan> Does DS get evaluated _after_ the reduction and matching of the syntax tree?
07:53:04 <Athan> I know the syntax of haskell can be described in haskell
07:53:11 <Athan> via types
07:53:41 <Athan> would the evaluation of the math happen when reducing the syntax into code?
07:56:00 <divyansr> join #hasgeek
07:57:19 <Kron> hmmm
07:57:34 <Kron> is there any way to make :sprint the default print in the read-eval-print loop of ghci?
07:57:42 <augur> ICFP videos? :D
07:58:04 <mrmonday> is there something like foldl which allows you to work on muliple elements at once? given [1, 2, 3, 4] I want to operate on [1, 2] then [2,3], then [3, 4] etc
07:58:56 <Kron> mrmonday: you can apply a function that sections out the list in pairs first
07:59:52 <bennofs> > zipWith (+) [1,2,3,4] (drop 1 [1,2,3,4])
07:59:52 <Kron> hmmm
07:59:53 <lambdabot>   [3,5,7]
08:00:30 <mrmonday> Kron: ooh, seems obvious now... thanks :)
08:00:40 <Kron> i'm trying to think of the most obvious way to do it
08:00:45 <Kron> but I'd do something like this:
08:01:16 <Kron> sectionByTwo (a:b:rest) = (a,b) : sectionByTwo rest
08:01:32 <Kron> where sectionByTwo :: [a] -> [(a,a)]
08:01:37 <Kron> I think tupling it is the neatest way to do it
08:01:46 <k00mi> > let xs = [1,2,3,4] in zip xs (tail xs)
08:01:47 <lambdabot>   [(1,2),(2,3),(3,4)]
08:01:58 <Kron> obviously track the base case where sectionByTwo [] = []
08:02:01 <chrisdone> how do you generate a package.cache file?
08:02:27 <Kron> oh wait [1,2] then [2,3]. That's a bit different
08:02:29 <chrisdone> package.conf.d/package.cache: openBinaryFile: does not exist
08:02:36 <benmachine> Kron: you want sectionByTwo (b : rest)
08:02:40 <Kron> right
08:02:40 <geekosaur> ghc-pkg recache
08:02:40 <benmachine> in the recursive case
08:02:52 <benmachine> you also need a base case for one element
08:02:56 <mrmonday> Kron: hmm, that's nicer than how I was thinking of doing it - I was gonna use something with take and tail
08:03:01 <Kron> I didn't read his problem properly
08:03:04 <chrisdone> geekosaur: thanks!
08:03:10 <Kron> I thought he wanted [1,2,3,4] -> [(1,2),(3,4)]
08:03:25 <Kron> mrmonday, I just personally prefer pattern matched sub functions
08:03:27 <Kron> for readability
08:03:43 <k00mi> mrmonday: just use zip(With) like bennofs and me showed
08:03:44 <Kron> using head and tail is standard lisp style but with pattern matching it's just sort of more obvious when you look at your code a month later
08:05:59 <mrmonday> k00mi: that's really elegant, thank you :)
08:06:09 <benmachine> I think what is best for readability depends very much on the reader
08:06:18 <Kron> yeah it's very subjective
08:07:04 <Kron> the zip solution is really elegant too
08:07:09 <Kron> I wish I thought of that
08:07:14 <benmachine> but that said, many things are bad for everyone, so it's still worth worrying about
08:08:03 <Kron> I wonder about the readability of monad based code
08:08:30 <Kron> the incredible terseness you can generate for very complex data wrangling is really neat, but hiding all the magic in a "do" feels odd
08:08:38 <Kron> is there any way to make it more clear what monad a given do is using?
08:09:13 <shapr> Wow, that's a lot of members.
08:09:28 <k00mi> Kron: add a type signature
08:09:33 <shapr> So, I've heard that Haskell is a great language to learn, does anyone have good reasons I should pick it up?
08:09:39 <Kron> how does one type a do block, I'm curious
08:09:48 <ParahSail1n> how is cereal's performance
08:09:54 <Kron> shapr, to begin with it's mostly about mind expanding
08:10:00 <shapr> Kron: how so?
08:10:12 <Kron> Everyone knows imperative programming styles, but learning some haskell and prolog really helps you think about programming in new ways
08:10:19 <quchen> Kron: "do" isn't hiding anything, it translates pretty directly to Haskell. "x <- something" translates to "something >>= \x ->" for example.
08:10:41 <shapr> I learned some Prolog in a class I had two terms ago, it really was mind expanding.
08:10:47 <Kron> shapr: Haskell is a purely functional (and lazily evaluated) language. Do you know what that implies?
08:10:54 <shapr> Kron: I think so
08:11:08 <shapr> Kron: How would you describe it?
08:11:25 <Kron> there's no state, no loops; everything is immutable and recursion is used to solve all your problems
08:11:30 <int80_h> I've done something horrible, and need to uninstall the ghc 7.6.3 binaries and compile from source. Do I need to remove things by hand?
08:12:11 <Kron> you basically have to work with a very different style of programming since you're sacrificing the expressability of using state in order for the compiler to know that any function call on the same arguments will always generate the exact same result
08:12:14 <quchen> int80_h: I've never heard that that's required to do as a consequence of anything.
08:12:27 <quchen> Can't you just download the binaries of GHC?
08:12:29 <haasn> FSVO ‘sacrificing’, ‘state’
08:12:53 <donri> shapr: wat
08:13:00 <Kron> hmmm
08:13:06 <shapr> donri: I hear Haskell is awesome
08:13:08 <quchen> int80_h: Deleting ghc, runghc, haddock, alex, cabal, happy in /usr/bin or something should get you a system-wise clean slate, then delete .ghc and .cabal and your user dir is clean
08:13:10 <Kron> like in haskell you can do this:
08:13:15 <Kron> x = [1..]
08:13:20 <Kron> and then x is an infinite list
08:13:24 <quchen> > let x = [1..] in x
08:13:25 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
08:13:26 <int80_h> quchen: instead of compilng against libgmp.so.10 like I should have, I tried to just make a soft link to that library named libgmp.so.3
08:13:27 <Kron> of [1,2,3,4..] up to infinity
08:13:30 <donri> shapr: are you reverse trolling or something :D
08:13:37 <shapr> donri: sort of, yeah
08:13:41 <donri> :)
08:13:46 <Kron> and this works in haskell because it's lazily evaluated
08:13:47 <shapr> Kron: that's really awesome. How did you get into Haskell?
08:13:51 <Kron> it doesn't actually try to process x
08:13:57 <Kron> it just treats x like a concept
08:14:05 <int80_h> quchen: instead of compilng against libgmp.so.10 like I should have, I tried to just make a soft link to that library named libgmp.so.3
08:14:05 <Iceland_jack> shapr: Read Learn You a Haskell
08:14:09 <Kron> so you can do this a lot, give haskell impossible to compute concepts and then work wih it
08:14:16 <geekosaur> :)
08:14:19 <Iceland_jack> @where lyah
08:14:19 <lambdabot> http://www.learnyouahaskell.com/
08:14:25 <Kron> Learn You A Haskell is an incredible site
08:14:28 <Kron> i'm on it right now
08:14:29 <shapr> Iceland_jack: I'll check it out
08:14:43 <Iceland_jack> shapr: Happy Haskelling
08:14:51 <geekosaur> reverse trolling indeed :p
08:14:56 <jmcarthur> :D
08:15:00 <shapr> Kron: did that book get you started with Haskell?
08:15:02 <chrisdone> woot
08:15:03 <Kron> well
08:15:06 <Kron> my girlfriend did
08:15:11 <shapr> ok, that's awesome
08:15:12 <chrisdone> got ghc working on puppy linux
08:15:12 <Kron> she's been haskelling for years
08:15:13 <donri> guys shapr is the #4th most active user in #haskell all-time http://ircbrowse.net/nicks?recent=false
08:15:18 <Kron> but yeah, I'm learning from LYAH
08:15:28 <Kron> ah o.o
08:15:37 <shapr> psh, donri exposed my reverse trolling :-P
08:15:42 <geekosaur> even got his own bot command
08:15:44 <donri> :D
08:15:45 <geekosaur> @get-shapr
08:15:46 <lambdabot> shapr!!
08:15:49 <Kron> oh well. It's an interesting educational exercise trying to summarize why you like haskell to someone new
08:15:50 <int80_h> shapr: heh. I knew you were up to something
08:15:58 <shapr> Kron: btw, you're very helpful to newbies, even pretend newbies, thanks for that :-)
08:16:07 * shapr hugs Kron
08:16:07 <Kron> I'm still a newbie myself :x
08:16:11 <jmcarthur> i've been laughing my head off
08:16:18 <Kron> applicative functors and monads still make my brain bleed
08:16:25 <Kron> I'm working on a toy memoization library right now
08:16:29 <shapr> Cool!
08:16:29 <Kron> just to prove I can
08:16:38 <Kron> also some crappy prolog substitute 8 queens constraint satisfaction solver
08:16:41 <donri> shapr: didn't you found this channel even, or something like that :P
08:16:49 <jmcarthur> also, welcome back shapr
08:16:52 <Kron> I still can't make it work on heterogenous lists of rules so I'm not sure how general I can make this
08:16:56 <shapr> donri: Yes, I started #haskell ... twelve years ago or so.
08:17:03 <donri> \o/
08:17:06 <Kron> lol
08:17:08 <Kron> wonderful
08:17:13 * benmachine hugs shapr
08:17:17 <donri> reverse trolling in deed :)
08:17:35 <shapr> Kron: You have proven to me that the positive spirit of this channel is alive and well :-)
08:17:42 <benmachine> reverse trolling: deliberately trying to provoke a... nice response from people?
08:17:51 <donri> something like that :D
08:17:55 <Kron> I literally just started talking in this channel like 5 minutes before you showed up
08:18:03 <Kron> and this is like the first time I've even tried
08:18:05 <Kron> ;P
08:18:13 <int80_h> shapr: The spirit of this channel reflects the spirit of the haskell community.
08:18:16 <shapr> howdy benmachine !
08:18:20 * benmachine waves
08:18:23 <shapr> int80_h: Yes, I agree!
08:18:46 <jmcarthur> with the exception of some recent blog and reddit wars...
08:18:59 <ReinH> shapr: <3 <3 <3
08:19:02 <benmachine> even the wars I don't think are acrimonious
08:19:05 <shapr> howdy ReinH !
08:19:09 <ReinH> morning or other appropriate greeting everyone
08:19:09 <benmachine> at least by comparison to other internet wars
08:19:26 <shapr> ReinH: You're the guy who's doing the Haskell interviews and podcasts, right?
08:19:27 <benmachine> we tend to stop at "you're wrong" instead of spilling over to "you're a terrible person"
08:19:28 <ReinH> shapr: Howdy!
08:19:38 <ReinH> shapr: with Chris Forno, yes :)
08:19:40 <benmachine> or maybe I just don't pay attention
08:19:42 <int80_h> ReinH: You did the one with dons?
08:19:44 <quchen> Speaking of which, can we expect a new Podcast soon?
08:19:49 <int80_h> oh sweet!
08:19:57 <jmcarthur> oh i didn't realize ReinH was one of those guys
08:20:01 <int80_h> that interview helped me right away.
08:20:01 <shapr> ReinH: Awesome! I haven't watched or listened to any of them yet, but I'll have more time soon.
08:20:07 <ReinH> quchen: we're recording on the 20th and hopefully releasing that week
08:20:14 <ReinH> shapr: :)
08:20:23 * haasn needs to be reminded which one is which. Is ReinH the one with curly hair?
08:20:24 <quchen> ReinH: Who's going to be your guest this time?
08:20:35 <shapr> Let's see, you interviewed edwardk, dons, and simonpj and then JaffaCake?
08:20:37 <ReinH> haasn: I have a beard
08:20:51 <ReinH> shapr: just the first two
08:20:59 <ReinH> but our next guest is SPJ :)
08:21:02 * jmcarthur nominates shapr!
08:21:03 <int80_h> wow!
08:21:05 <haasn> shapr might be onto something
08:21:06 <ReinH> I guess I might as well let the cat out of the bag :)
08:21:07 <quchen> ReinH: OOOO
08:21:18 <int80_h> I'm going to tweet about it
08:21:23 <shapr> ReinH: whoops, didn't know that was non-public information, sorry!
08:21:23 <ReinH> heh
08:21:35 <int80_h> not really. I don't tweet
08:21:49 <ReinH> shapr: hah, no worries
08:22:03 <shapr> jmcarthur: psh, I haven't written much actual code, I've only done community organizing.
08:22:16 <shapr> But I hope to change that soon.
08:22:18 <ReinH> it's not particularly private, we just like a little bit of surprise
08:22:20 <jmcarthur> shapr: i would say that the community is at least as important
08:22:24 <quchen> To remember which one of the hosts is ReinH, the picture titled "Rein Henrichs" next to a picture of a person is a pretty good helper.
08:22:26 <Kron> hmmm
08:22:33 <ReinH> wow, this train's wifi harkens back to modems of yore
08:22:39 <int80_h> without the comminuty, I would have given uo already. How many others are like that?
08:22:49 <Kron> > let fibonacci = 1 : 1 : zipWith (+) fibonacci (tail fibonacci) in fibonacci
08:22:50 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
08:22:52 <shapr> Kron: How's the memoizing lib going?
08:22:55 <ReinH> quchen: lol
08:23:02 <shapr> Kron: Are you still in college?
08:23:06 <Kron> I am
08:23:08 <Kron> and sorta well
08:23:19 <shapr> I'm still in college too, this is my last term before I graduate!
08:23:21 <ReinH> Kron: let fibs = 0 : 1 : (zipWith (+) <*> tail) in take 10 fibs
08:23:22 * shapr does the happy dance
08:23:30 <ReinH> > let fibs = 0 : 1 : (zipWith (+) <*> tail) in take 10 fibs
08:23:31 <lambdabot>   Couldn't match expected type `[a1 -> a0]'
08:23:31 <lambdabot>              with actual type `[c...
08:23:34 <ReinH> woops
08:23:38 <Kron> I think I have it mostly done? it's like a crappy remake of the state monad
08:23:41 <Kron> I'll show you
08:23:44 <ReinH> > let fibs = 0 : 1 : (zipWith (+) <*> tail) fibs in take 10 fibs
08:23:46 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
08:23:47 <ReinH> oh yeah have to recurse duh
08:23:49 <shapr> Yeah! put it on hpaste?
08:24:10 <ReinH> (zipWith f <*> tail) is my new favorite idiom :)
08:24:10 <Flonk> That fibonacci code just blew my mind
08:24:12 <lpaste> Kron pasted “Memory” at http://lpaste.net/94195
08:24:19 <quchen> @quote aztec
08:24:19 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
08:24:34 <ReinH> > let pairwise f = zipWith f tail in pairwise (=>) [1,2,5,8]
08:24:36 <lambdabot>   <hint>:1:46: parse error on input `=>'
08:24:36 <Kron> I'm mostly playing around with data types / type constructors / modules and stuff
08:25:09 <Kron> I have two separate kinds of memoized unary function; one with infinite memory that uses a Data.Map and one with limited memory that uses a sorting list that forgets the final element if it gets too big
08:25:19 <Kron> and then you keep memCalling it to append things to the internal memory
08:25:28 <shapr> that makes sense
08:25:40 <ReinH> > let pairwise f = zipWith f <*> tail in all . pairwise (<=) [1,2,5,8]
08:25:41 <lambdabot>   Couldn't match expected type `a0 -> a1 -> GHC.Types.Bool'
08:25:42 <lambdabot>              with...
08:25:45 <Kron> ghci on -Wall warns me that changeLimit needs to be defined for the Inf constructor
08:25:54 <Kron> so I'm wondering if I should put in an exception there
08:25:56 <Kron> or an error
08:26:01 <Kron> I think in general, error is a bad thing?
08:26:04 <Kron> that's what my gf told me
08:26:12 <Kron> you want to modify the type system so the error can't happen at all
08:26:18 * zammy is away: I'm busy
08:26:25 <quchen> > let pairwise f = zipWith f <*> tail in and $ pairwise (<=) [1,2,5,8] -- ReinH
08:26:26 <lambdabot>   True
08:26:35 <ReinH> quchen: yeah my bad
08:26:45 <ReinH> that's a lazy detector of partially ordered lists :)
08:27:27 <quchen> I wonder whether there's a nice way of generalizing this so n list elements can be considered at a time.
08:27:31 <ReinH> let touching = ((==) . succ) in pairwise touching -- contiguous list of enums detector
08:27:39 <quchen> Would be useful for convolutions for example.
08:27:39 <ReinH> quchen: I've been thinking about that, haven't come up with one
08:27:43 <donri> > fix ((0:) . scanl (+) 1)
08:27:45 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:27:47 <ReinH> quchen: but something something ZipList and tails
08:28:15 <ReinH> (if it weren't for succ being unsafe)
08:28:21 <shapr> Kron: If your code should act like just the average function, then I think you're doing it right, and an exception for exceptional cases is okay. But that's just my opinion.
08:29:59 <Kron> okay
08:30:15 <Kron> this is basically a programmer error, I dont' want anyone to be calling changeLimit on a Finite thing
08:30:25 <Kron> kinda like calling head on an empty list
08:30:28 <Kron> that should be an error right?
08:30:36 <shapr> I would think so.
08:30:48 <jmcarthur> it depends
08:30:56 <jmcarthur> it's kind of up for debate
08:30:57 <shapr> But ndm wrote safeHead, which is nicer.
08:31:08 <Kron> ooh
08:31:11 <Kron> how does that work
08:31:14 <Vamp> Do numbers form a monoid under division?
08:31:19 <jmcarthur> i tend not to like partial functions
08:31:23 <Kron> I don't... think so
08:31:30 <Kron> n / 1 = n, but 1 / n is not n
08:31:34 <bennofs> Vamp: is division assoziative
08:31:35 <jmcarthur> Vamp: no kind of number that i know of
08:31:45 <quchen> Kron: Monoids need not be commutative.
08:31:48 <Kron> oh, sorry
08:31:57 <bennofs> > 3 / (2 / 4)
08:31:58 <lambdabot>   6.0
08:32:02 <bennofs> > (3 / 2) / 4
08:32:03 <lambdabot>   0.375
08:32:06 <Kron> ahhh right
08:32:06 <Vamp> Aha I see
08:32:07 <shapr> Kron: look at the safeHead exercise here: http://book.realworldhaskell.org/read/functional-programming.html
08:32:17 <bennofs> @ty listToMaybe
08:32:17 <lambdabot> [a] -> Maybe a
08:32:19 <jmcarthur> @check \x y z -> x / (y / z)  ==  (x / y) / (z :: Rational)
08:32:25 <lambdabot>   *** Failed! Exception: 'Ratio has zero denominator' (after 1 test):
08:32:25 <lambdabot>  0 % 1...
08:32:29 <ReinH> Vamp: they form a magma :)
08:32:43 <jmcarthur> @check \x y z -> y /= 0 && z /= 0 ==> x / (y / z)  ==  (x / y) / (z :: Rational)
08:32:43 <lambdabot> Plugin `check' failed with: Ambiguous infix expression
08:32:46 <jmcarthur> aw
08:33:03 <jmcarthur> @check \x y z -> if y /= 0 && z /= 0 then x / (y / z)  ==  (x / y) / (z :: Rational) else True
08:33:09 <lambdabot>   *** Failed! Falsifiable (after 2 tests and 3 shrinks):
08:33:09 <lambdabot>  5505827934532 % 60...
08:33:09 <int80_h> I need to sort out my space leaks. ugh
08:33:14 <quchen> ReinH: Not even that, magmas need to be closed, right? So `a / 0 / b` doesn't work
08:33:16 <Kron> how do you make multi line strings in haskell?
08:33:28 <FireFly> ==> ?
08:33:29 <Kron> \ and then > after?
08:33:40 <jmcarthur> FireFly: in quickcheck that is an operator to put conditions on the inputs
08:33:41 <FireFly> @help check
08:33:41 <lambdabot> check <expr>
08:33:41 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
08:33:46 <ReinH> quchen: well, fsvo numbers, i.e. N (w/o 0)
08:33:47 <geekosaur> Kron: string gaps
08:33:47 <latro`a> just \n, Kron
08:33:48 <quchen> Kron: When you escape one whitespace, all further whitespaces are ignored until the next backslash.
08:33:53 <jmcarthur> FireFly: if the condition on the left doesn't pass, it abandons that input and tries another
08:33:57 <Kron> ahhh ok
08:33:58 <latro`a> oh wait nvm
08:33:58 <quchen> > "hello\     \ world" -- Kron
08:33:59 <lambdabot>   "hello world"
08:33:59 <Kron> so \ and \
08:34:00 <FireFly> Oh, okay
08:34:01 <Kron> thanks
08:34:02 <latro`a> now I know what you meant
08:34:03 <geekosaur> or, if you just mean embedding newlines, just use \n in the string
08:34:21 <jmcarthur> hmm
08:34:31 <quchen> ReinH: "fsvo"?
08:34:34 <int80_h> > (+ 3) <$> Just 3
08:34:34 <jmcarthur> @check \x y z -> (y /= 0 && z /= 0) ==> (x / (y / z)  ==  (x / y) / (z :: Rational))
08:34:35 <lambdabot>   Just 6
08:34:35 <lambdabot>   can't find file: L.hs
08:34:37 <ReinH> for some value of
08:34:40 <jmcarthur> darn
08:35:19 <Kron> do you guys prefer using "otherwise =" as the last guard or "True =" as the last one?
08:35:27 <ReinH> Kron: otherwise =
08:35:42 <Kron> my first real language was common lisp, and thinking in terms of True as the final condition is normal to me
08:35:47 <Kron> but if the standard is otherwise I'll use it
08:36:01 <quchen> Kron: otherwise = True. Defined in Data.Bool or GHC.Bool I think.
08:36:10 <quchen> It's just a more expressive name.
08:36:13 <Kron> ok!
08:36:18 <quchen> > otherwise == True
08:36:19 <donri> is it scheme that defines else = True
08:36:19 <lambdabot>   True
08:36:37 <quchen> donri: Scheme has "anything that's not nil is true" I think.
08:36:54 <Kron> hmmm
08:36:55 <chrisdone> nope
08:36:59 <ReinH> Kron: it literally exists for that use case (and the analogous case... case) ;)
08:37:06 <Kron> it's interest, lpaste warns me of several style errors that ghci doesn't warn me about even with -Wall
08:37:17 <donri> Kron: that's hlint
08:37:17 <ReinH> Kron: hlint
08:37:19 <Kron> how do I make ghci track unnecessary pattern match def-
08:37:22 <Kron> ... what is hlint/
08:37:22 <ReinH> damn you slow internet
08:37:24 <Kron> *?
08:37:32 <ReinH> Kron: haskell lint, it's on hackage
08:37:33 <Kron> *interesting
08:37:39 <chrisdone> scheme is "anything not #f" =)
08:37:41 <quchen> ReinH: You can't use `otherwise` in `case` statements. (Well, except in case guards, but that's the same scenario again.)
08:38:01 <quchen> But "_otherwise" is easier to spot than "_" so I often use that.
08:38:07 <chrisdone> > (if '() "yay" "boo")
08:38:08 <chrisdone> "yay"
08:38:08 <lambdabot>   <hint>:1:20: parse error on input `)'
08:38:21 <erisco> where can I get a decent explanation of the ST monad? I understand the basic idea but the information listed here http://hackage.haskell.org/package/base-4.3.1.0/docs/Control-Monad-ST.html seems incomplete (there are more functions no?)
08:38:29 <ReinH> quchen: right
08:38:39 <quchen> chrisdone: Oh, so it's CL with the nil-false?
08:38:48 <ReinH> quchen: that's the one I meant :)
08:38:49 <donri> chrisdone: i meant for use with "cond"
08:38:50 <hpc> CL is CL with nill-false
08:39:00 <chrisdone> quchen: yeah
08:39:09 <FireFly> Lua has "all but nil and false is kinda true-y"
08:39:14 <ReinH> so does Ruby
08:39:24 <chrisdone> lisp is a nightmare for json
08:39:30 <chrisdone> it thinks null, [] and false are all the same
08:39:42 <donri> javascript has false, null, undefined, not actually defined, emptyish, uuuh
08:39:42 <ReinH> ha
08:39:48 <ReinH> let's not even talk about vimscript...
08:39:56 <FireFly> donri: :D
08:39:58 <ReinH> and its equivalency classes of maximal annoyance
08:39:58 <zielwasserjunki> erisco, you are asking for some kind of libary reference?
08:40:00 <quchen> Let's stop this here before this ends in a PHP rant
08:40:23 * int80_h thinks PHP is the bees knees.
08:40:34 <ReinH> erisco: well, being a monad you can do monad things with it
08:40:41 * int80_h says that with a totally staight face.
08:41:18 <quchen> erisco: The "ST s" Monad is like a more restrictive IO. It allows impure operations, but if you pack it in runST, the entire thing looks pure from the outside.
08:41:24 <chrisdone> int80_h: i once had to work with php… on windows
08:41:34 <chrisdone> needless to say i got another job
08:41:34 * ReinH is thinking about writing a talk on parallelism models using legos
08:41:44 <ReinH> chrisdone: my condolences
08:41:49 <erisco> for example this seems related http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-STRef.html#v:newSTRef
08:41:59 <quchen> erisco: It's useful when you're updating Vectors for example. Changing a single value requires you to copy the entire Vector with one element changed. With ST, you can do an arbitrary amount of writes in one go.
08:42:03 <ReinH> erisco: and, importantly, you can't do generic IO things
08:42:07 <donri> chrisdone: at least you got to work in emacs, right? right??
08:42:46 <ReinH> consider the free lego trace monoid as a model of nondeterministic lego building
08:43:00 <erisco> the best examples I've found are here http://www.haskell.org/haskellwiki/Monad/ST
08:43:02 <ReinH> where the equivalency relationship is color
08:43:19 <ReinH> you could literally explain nondeterministic parallelism to a child :D
08:43:25 <erisco> but I do not know how you get from "stref" to having data structures
08:43:54 <chrisdone> donri: yeah, emacs on windows
08:44:17 <donri> chrisdone: is it anything like gvim on windows
08:44:30 <donri> chrisdone: i like how fixedsys is the default font there ;)
08:44:41 <quchen> ReinH: Care to elaborate on that Lego analogy? Or write that talk? :-)
08:45:47 <chrisdone> donri: ntemacs was surprisingly acceptable
08:46:34 <chrisdone> even had antialiased fonts!
08:46:43 <ReinH> quchen: are you familiar with trace monoids?
08:46:56 <ReinH> basically monoids where certain elements commute based on an equivalency relationship
08:47:01 <stephenmac7> Hello, I'm having an issue with the lazy IO
08:47:02 <quchen> ReinH: No, haven't heard of them
08:47:11 <quchen> ReinH: Okay
08:47:20 <stephenmac7> I wrote a random number guessing game based on the one in "Learn you a haskell"
08:47:26 <ReinH> quchen: they model nondeterministic parallelism where commuting elements are parallelisable and non-commuting are checkpoints that require ordering
08:47:30 <stephenmac7> However, it needs hFlush to function properly: http://pastebin.com/C24KU73c
08:47:32 <stephenmac7> Why is that?
08:47:33 <Kron> o.o
08:47:36 <mauke> The paste C24KU73c has been copied to http://lpaste.net/94196
08:47:52 <ReinH> quchen: so if you have a bag of multicolored legos and a bag of red legos, you have to be careful which lego you select when you need a non-red lego
08:47:59 <ReinH> but any time you need a red lego you can just pick one at random
08:48:00 <chrisdone> stephenmac7: because it's line buffering by default
08:48:00 <chrisdone> stephenmac7: use hSetBuffering stdout NoBuffering
08:48:32 <chrisdone> stephenmac7: if you don't want to flush yourself
08:48:34 <Kron> the IO monad is really confusing to me
08:48:40 <ReinH> the free lego trace monoid consists of all "strings" of legos where all same-colored legos are equivalent
08:48:46 <stephenmac7> chrisdone: Then why is it not mentioned in LYAH?
08:48:54 <chrisdone> stephenmac7: dunno?
08:49:01 <ReinH> quchen: does that make sense?
08:49:19 <ReinH> (we're assuming all these legos are the same size and connect with each other)
08:49:22 <chrisdone> stephenmac7: probably the author assumed some familiarity with I/O and buffering
08:49:40 <stephenmac7> Yes, but the example code has the same issue
08:49:50 <Kron> stephenmac7 is saying the LYAH code doesn't work
08:50:08 <chrisdone> oh, maybe it's a mistake
08:50:13 <quchen> ReinH: Sort of, yes.
08:50:19 <Kron> that is most unfortunate
08:50:20 <stephenmac7> Kron: Yes, that's what I meant
08:50:55 <Kron> the IO Monad is really confusing to me. I can never tell when something actually 'happens', and isn't just placed in a thunk
08:50:56 <ReinH> quchen: legos of the same color in sequence can be reordered at will
08:51:29 <ReinH> quchen: consider the set {a,b,c,d} where a == b, the strings "aacd" and "bacd" and "abcd" and "bbcd" are all equivalent
08:51:33 <quchen> Kron: When you have an IO thing on the right side of "<-" things "happen", usually.
08:51:47 <quchen> ReinH: Alright.
08:51:54 <ReinH> quchen: now instead of strings or legos, consider parallel operations
08:52:00 <Kron> yeah but only ... usually... I think someone showed me an example when even after binding an IO thingy it didn't actually run until much later
08:52:15 <ReinH> quchen: the operations that commute can be reordered at will
08:52:29 <ReinH> the operations that do not commute must have their ordering preserved somehow
08:52:39 <mrmonday> where is zip4 defined? is it not in prelude? I'm getting an error when trying to use it (not in scope)
08:52:57 <mrmonday> using ghc 7.6.3 this is
08:53:05 <ReinH> quchen: the more elements are a part of the equivalency class, the more freely parallelizable the set of operations
08:53:20 <stephenmac7> chrisdone: Okay, thanks. New code: http://lpaste.net/94198
08:53:31 <geekosaur> mrmonday, Data.List
08:53:33 <quchen> ReinH: I think I get it.
08:53:33 <ReinH> quchen: this makes sens of the intuition a lot of distributed systems builders have of favoring commutative operations
08:53:39 <ReinH> *sense
08:53:51 <shapr> chrisdone: howdy!
08:54:00 <quchen> ReinH: The problem was understanding the Lego part. Monoids with a subset satisfying commutativity when they're equivalent is much clearer. :-P
08:54:08 <ReinH> Lindsey Kuper's LVar stuff, on the other hand, makes sense of the intuition of preferring monotonic operations for deterministic parallelism
08:54:25 <chrisdone> shapr: how do?
08:54:28 <ReinH> quchen: well if you're looking at a bunch of legos I think it's pretty clear :)
08:54:35 <mrmonday> geekosaur: lovely, thanks :)
08:54:45 <ReinH> quchen: especially for people who don't know what a "monoid" is ;)
08:54:46 <shapr> chrisdone: eh, better than I expected.
08:54:50 <ReinH> this is intended for a very general audience
08:54:52 <shapr> chrisdone: how are you?
08:54:56 <chrisdone> shapr: that's good =)
08:55:06 <chrisdone> shapr: cold =p
08:55:26 <shapr> build ghc with make -j 12 ?
08:55:33 <quchen> ReinH: Oh that's easy to explain, just take away the inverse and unit from a group.
08:55:38 <chrisdone> shapr: it's not a bad idea ;)
08:55:41 <quchen> (Just kidding. I know what you mean.)
08:55:46 <stephenmac7> Whoever decided to make lists so important in haskell was a genius
08:55:53 <ReinH> hate you
08:56:02 <Kron> stephenmac7: is that rhetorical? lol
08:56:12 <stephenmac7> Kron: Just a statement
08:56:15 <Kron> I do like that list functions can be used on almost everything
08:56:21 <stephenmac7> Not sarcastic
08:56:30 <stephenmac7> I love pattern matching
08:56:33 <Kron> but I certainly hope that the compiler abstracts away some of my silly list constructions into things better than lists I guess
08:56:33 <shapr> chrisdone: Anyway, I'll just be dropping in here until my degree is finished in early December, then I'll have time to write Haskell again!
08:56:38 <Kron> yeah pattern matching is awesome
08:56:45 <Kron> you can do it on tuples and other structures too!
08:57:02 <stephenmac7> So far, my favorite things about haskell are: Lists, Pattern matching, Function comprehensions, and Laziness
08:57:06 <Kron> sumPair (a,b) = a + b
08:57:08 <shapr> I'll be back later guys!
08:57:10 <Kron> stuff like that
08:57:11 * shapr waves
08:57:24 <ReinH> quchen: my goal is to do some cool webgl lego building visualizations a la acko.net :)
08:57:38 <Kron> oh stephenmac7: something I didn't realize in LYAH is that you can use :sprint to see the laziness
08:57:45 <quchen> > uncurry (+) (a,b) :: Expr
08:57:46 <Kron> like if you define... x = [1..]
08:57:46 <lambdabot>   a + b
08:57:47 <quchen> :-)
08:57:50 <Kron> the usual infinite list
08:57:50 <Kron> then do
08:57:53 <Kron> :sprint x
08:57:59 <Kron> it'll just show you how much is already calculated
08:58:07 <Kron> then you can take 10 x and :sprint x and see more is calculated
08:58:16 <ReinH> Kron: uncurry (+)
08:58:17 <stephenmac7> That's cool
08:58:35 <Kron> ReinH: yeah I know
08:58:39 <ReinH> :)
08:58:39 <Kron> but don't get too complicated :P
08:58:48 <Kron> point free programming is pretty hardcore for a newbie
08:59:09 <stephenmac7> Not trying to do point free
08:59:18 <stephenmac7> It's just nice when I do
08:59:32 <stephenmac7> Anyway, thanks for the help!
08:59:38 <Kron> right
08:59:44 * stephenmac7 moves on to the bytestrings section
08:59:51 <Kron> speaking of sprint, is there any way to make it the default printing system in ghci?
08:59:55 <chrisdone> yahl has a bytestrings section?
08:59:56 <Kron> like a read-eval-sprint mode?
08:59:58 <Kron> yeah it does
09:00:00 <chrisdone> does it also have a text section?
09:00:12 <Kron> it has a string and bytestring bit?
09:00:17 <chrisdone> okies
09:00:39 <chrisdone> nobody really uses (or should use) String for real text work. they use the text library and the Text type
09:00:54 <ReinH> I try to get people doing pointfree as early as possible
09:01:01 <chrisdone> it would be cool if that were covered to avoid newbies trying to do text stuff with Strings and lazy io
09:01:04 * hackagebot yesod-s3 0.1.0.0 - Simple Helper Library for using Amazon's Simple Storage Service (S3) with Yesod  http://hackage.haskell.org/package/yesod-s3-0.1.0.0 (TvH)
09:01:06 <ReinH> not by running everything through `pointfree`
09:01:12 <ReinH> but because it's a very natural way to compose functions
09:01:27 <rinaku> hello, I'm a noob and I have a one-liner that gives me an error that I don't understand in ghci
09:01:30 <rinaku> the error is:
09:01:32 <rinaku> "*** Exception: user error (Text.Regex.Posix.String died: (ReturnCode 5,"Trailing backslash"))
09:01:39 <rinaku> the one-liner is:
09:01:45 <rinaku> (subRegex (mkRegex "≜") "abc" "x")
09:02:03 <rinaku> in ghci with :mod +Text.Regex
09:02:09 <dveim> hello
09:02:15 <rinaku> can someone tell me what I'm doing wrong?
09:02:23 <dveim> i was installing yesod and got this error: http://lpaste.net/94199
09:02:38 <dveim> can anyone give some tips?
09:02:57 <Clint> apt-get install yesod
09:03:44 <zielwasserjunki> I would be very grateful if somebody would explain me the following issue: http://codepad.org/JctgYVza relating to this code i have 2 question why doesnt run ghci this code and secondly why does the (+) pattern catches all?
09:03:51 <burp_> yesod in debian stable is old
09:03:51 <Vamp> Bool forms a monoid under conunction and biconditional right?
09:03:59 <burp_> and it is supposed to work with cabal
09:04:12 <dveim> Clint: it will re-download all packages in own way, isn't it?
09:04:18 <geekosaur> zielwasserjunki, patterns can't match values, only constructors
09:04:28 <geekosaur> (+) is a *variable*
09:04:40 <geekosaur> as far as pattern matching is concerned
09:05:42 <zielwasserjunki> thank you for quick response, but then why i can match over the ints 1 2 3...
09:05:43 <fizruk> Vamp: http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Monoid.html
09:05:53 <geekosaur> because they're special cased in the compiler :/
09:05:58 <fizruk> Vamp: All is a boolean monoid under conjunction
09:06:09 <geekosaur> (specifically Num and Eq constraints are inferred and the compiler rewrites them to guards
09:06:11 <geekosaur> 0
09:06:12 <geekosaur> )
09:06:40 <geekosaur> has to do with the magic where any numeric literal is turned into a function call
09:06:47 <ReinH> > foldMap All [True, False]
09:06:49 <lambdabot>   All {getAll = False}
09:06:49 <geekosaur> so that they can be polymorphic
09:07:06 <zielwasserjunki> ?? does this relate to lambda calculus?
09:07:07 <lambdabot> Plugin `compose' failed with: Unknown command: ""
09:07:08 <ReinH> > ala All foldMap [True, False]
09:07:11 <lambdabot>   False
09:07:36 <fizruk> Vamp: similarly Any is a boolean monoid under disjunction
09:07:44 <geekosaur> also note that, if numeric literals were handled "normally", they would be constructors. (+) and the like are not built-in magic, they're ordinary functions
09:08:07 <fizruk> Vamp: I'm not sure what you mean by "biconditional". Is it xor?
09:08:39 <Kron> hmmm
09:08:50 <Kron> what is the difference between :print and :sprint?
09:09:01 <Iceland_jack> :sprint is simplified
09:09:24 <zielwasserjunki> when (+) then acts like a variable is it then independent from the original (+)
09:09:32 <zielwasserjunki> like in expample
09:09:36 <Iceland_jack> Kron: You can type in ":?" and you should get an enumeration of options
09:09:39 <geekosaur> yes, it is a local binding that shadows the global definition
09:09:39 <zielwasserjunki> when i type show (/)
09:09:43 <Iceland_jack> Where you'll see:
09:09:43 <Iceland_jack>    :print [<name> ...]         prints a value without forcing its computation
09:09:44 <Iceland_jack>    :sprint [<name> ...]        simplifed version of :print
09:09:51 <Kron> ahhh ok
09:09:54 <zielwasserjunki> the (+) gets the (/)
09:09:55 <Vamp> fizruk: The 3 stripes above eachother, so the = symbol with another stripe on top of it
09:10:00 <Kron> and :pr is short
09:10:01 <Kron> okay
09:10:40 <fizruk> Vamp: oh, equivalence, I think it is
09:11:04 <fizruk> Vamp: it's the negation of xor
09:11:05 <Vamp> fizruk: That word yes :p
09:11:15 <zielwasserjunki> this made my sight a litte more clear, ty geekosaur
09:11:18 <geekosaur> rinaku, you're having some kind of encoding issue, I'm not quite sure what as the utf8 sequence doesn't appear to include a backslash. I suspect whichever regex engine is in use doesn't expect utf8 though
09:11:54 <Kron> what are BangPatterns...
09:11:57 <rinaku> geekosaur: is there a standard utf8 regex engine in haskell?
09:12:15 <Kron> hmm
09:12:52 <geekosaur> rinaku, regex is kinda not loved very much in the Haskell community and probably hasn't been well tested with utf8. I would not be surprised to find odd bugs in it
09:13:33 <fizruk> Vamp: I think Bool forms a monoid under both xor and equiv, since both operations are associative and have identity (False for xor and True for equiv)
09:13:45 <zielwasserjunki> geekosaur, is there any possibility to call a whole expression in infix manner, not just 1 identifier? without assigning the expr to the identifier?
09:14:02 <geekosaur> there has certainly not been the amount of effort into getting utf8 + regex to be sane as there has been in perl and python
09:14:13 * fizruk hopes he hasn't spoken something stupid..
09:14:17 <rinaku> geekosaur: is there another lib I should use to do basic substitution on unicode strings?
09:15:19 <fizruk> > foldr (/=) False [True, False, False, True]
09:15:19 <Vamp> fizruk: Aha I see
09:15:20 <lambdabot>   False
09:15:23 <geekosaur> zielwasserjunki, I don't think you can do what you're trying to do at all; since (+) is not a language intrinsic and functions aren't (and can't usefully be) members of Eq you can't detect specific functions like that at all
09:15:29 <fizruk> > foldr (==) True [True, False, False, True]
09:15:30 <lambdabot>   True
09:15:44 <tdammers> doesn't Bool form a monoid under *every* binary boolean operation?
09:15:53 <Kron> can anyone tell me what lpaste is all about? It seems like a unique version of pastebin that checks your code for you but also doesn't let you set pastes to expire and stuff... I can't find any about pages on it
09:16:14 <fizruk> tdammers: apparently it does
09:16:58 <geekosaur> Kron, it doesn't push ads on its users. also, we generally don't *want* expiration; I certainly have stuff in there from years ago that I still point people at
09:17:11 <geekosaur> (mostly snippets of code for xmonad)
09:17:13 <funfunctor> right, because I changed "draw (O.south) ++(0.5,-0.5) node[rectangle,draw,] {\large 0x0A0B0C0D};"
09:17:29 <Kron> I'd personally prefer expiration and I feel nervous pastebinning code here if it's apparent a bot will just lpaste it for me :$
09:17:40 <briennetheblue> > ala Any foldMap [False, True]
09:17:42 <lambdabot>   True
09:17:48 <funfunctor> and was trying to work out how to get the arrorws to align correctly again myself to learn.
09:18:29 <funfunctor> oops sorry, changed channel :/
09:18:44 <jmcarthur_mobile> Kron: the channel is also logged
09:18:51 <zielwasserjunki> geekosaur, i expressed my request a bit vague: i meant things like   1 `(\x->\y->"example")` 2, which gives me a parse error
09:19:04 <donri> > anyOf folded [False, True]
09:19:05 <lambdabot>   Couldn't match type `[]' with `p0 a0'
09:19:05 <lambdabot>  Expected type: p0 a0 GHC.Types.Bool
09:19:06 <lambdabot> ...
09:19:08 <Kron> yeah I know, I just don't like leaving my crappy code on the internet to be seen foreeever ;_;
09:19:29 <geekosaur> zielwasserjunki, `` doesn't allow arbitrary expressions like that, no.
09:19:33 <jmcarthur_mobile> Everybody has to learn
09:19:34 <zielwasserjunki> :(
09:19:43 <geekosaur> mostly we wouldn't bother trying to infix that
09:19:56 <geekosaur> > (\x->\y->"example") 1 2
09:19:58 <lambdabot>   <hint>:1:4: parse error on input `->\'
09:20:02 <geekosaur> mrrr
09:20:42 <Kron> > (x->(\y->"example)) 1 2
09:20:44 <lambdabot>   <hint>:1:24:
09:20:44 <lambdabot>      lexical error in string/character literal at end of input
09:20:51 <ReinH> Also remember that they're non-strict :)
09:20:53 <Kron> > (x->(\y->"example")) 1 2
09:20:54 <lambdabot>   Pattern syntax in expression context: x -> (\ y -> "example")
09:20:55 <ReinH> > ala Any foldMap (repeat True)
09:20:57 <lambdabot>   True
09:20:59 <zielwasserjunki> yeah i know its ugly i just spent a litte thought bout this
09:21:11 <Kron> > (\x->(\y->"example")) 1 2
09:21:12 <lambdabot>   "example"
09:21:14 <zielwasserjunki> > print "test"
09:21:14 <Kron> derp
09:21:15 <lambdabot>   <IO ()>
09:21:15 <Kron> so many typos
09:21:19 <geekosaur> works in ghci, this may be a bug in hint
09:21:49 <zielwasserjunki> whats prefix for lambdabot?
09:22:39 <geekosaur> several. @ or ? for commands, : works for some ghci-alike stuff like :t and :k (but not :i !), "> " is short for @run
09:23:13 <zielwasserjunki> :k (Maybe)
09:23:14 <lambdabot> * -> *
09:23:24 <briennetheblue> > anyOf folded id [False, True]
09:23:25 <lambdabot>   True
09:23:26 <zielwasserjunki> ? :t True
09:23:41 <fizruk> :t anyOf
09:23:43 <geekosaur> :t True
09:23:44 <lambdabot> Bool
09:23:47 <zielwasserjunki> :t True
09:23:48 <lambdabot> Bool
09:23:50 <geekosaur> ?type True
09:23:51 <lambdabot> Bool
09:24:03 <geekosaur> (same thing in non-shorthand form)
09:24:04 <ReinH> but in that case one could use or :)
09:24:31 <zielwasserjunki> @run (print "Thank you very much")
09:24:32 <briennetheblue> Now that would just be silly
09:24:33 <lambdabot>   <IO ()>
09:25:23 <fizruk> :t anyOf
09:25:47 <ozgura> Hi. This may not be the best place to ask, but just trying my luck. Does anyone happen to know what tool they used when writing RWH? I mean the web version which allows comments and such.
09:26:14 <briennetheblue> :t or
09:26:14 <lambdabot> [Bool] -> Bool
09:26:22 <briennetheblue> i wonder why it doesn't work for anyOf...
09:26:29 <fizruk> lambdabot ignores me...
09:26:31 <briennetheblue> :(
09:27:07 <joelteon> what datastructure would you use to represent a board game?
09:27:37 <ReinH> joelteon: depends on the board game and why you're representing it
09:27:47 <joelteon> ok, not a board game
09:27:51 <joelteon> let's say minesweeper
09:28:15 <ReinH> joelteon: a grid of squares :)
09:28:24 <ReinH> would be the most obvious
09:28:39 <joelteon> yeah, what do you use for the grid
09:28:41 <joelteon> Array?
09:28:53 <ReinH> [[Square]] until I need something else
09:29:00 <osfameron> or a map of (Int,Int) coordinates
09:29:33 <osfameron> (Int,Int) -> (Bool,Bool) or something
09:29:39 <ReinH> if [[Square]] is fast enough to solve sudoku it should be fast enough to represent a minesweeper board
09:30:09 <ReinH> and I would prefer to inhabit the space with types, not back on Bool
09:30:52 <osfameron> sure
09:31:19 <Kron> hmmmm
09:31:23 <Kron> does haskell have arrays?
09:31:24 <ReinH> maybe data Square = Square { _seen :: Bool, _type :: SquareType }; data SquareType = Empty | Mine
09:31:46 <ReinH> Kron: yes, although what you're asking for depends on what you mean by array
09:31:56 <Kron> I mean like a literal contiguous block of memory array
09:32:00 <Kron> like common lisp arrays
09:32:01 <ReinH> oh you need flagged state too
09:32:01 <geekosaur> Kron, Data.Array and friends, also Data.Vector
09:32:05 <Kron> ahhhh awesome
09:32:05 <Kron> thanks!
09:32:18 <joelteon> what's the extension that allows you to provide your own fromString?
09:32:20 <FreeFull> Kron: You can also look at REPA
09:32:24 <joelteon> and so on
09:32:25 <Kron> what's REPA?
09:32:35 <geekosaur> joelteon, OverloadedStrings
09:32:40 <FreeFull> A library for arrays
09:32:46 <Kron> okay
09:32:46 <Kron> hmmm
09:32:50 <joelteon> OverloadedStrings doesn't let you provide fromString
09:32:51 <FreeFull> "Repa provides high performance, regular, multi-dimensional, shape polymorphic parallel arrays. All numeric data is stored unboxed. Functions written with the Repa combinators are automatically parallel provided you supply +RTS -Nwhatever on the command line when running the program. "
09:32:54 <joelteon> it just adds fromString to everything
09:33:09 <Kron> Data.Map is a tree right? How does Haskell do hash tables...
09:33:12 <Kron> ooh
09:33:16 <geekosaur> afaik there is no extension for that part, just a bog standard typeclass IsString
09:33:18 <Kron> I don't know what half those words mean
09:33:23 <Kron> but it sounds awesome
09:33:31 <Kron> shape polymorphic parallel arrays D:
09:33:33 <Kron> I must have them.
09:33:35 <joelteon> what's the extension that lets you overload (>>=) for do notation?
09:33:43 <geekosaur> RebindableSyntax?
09:33:46 <joelteon> that's the one
09:33:48 <chrisdone> Kron: for a small price they can be yours today!
09:34:17 <FreeFull> Very small price
09:34:42 <nicoo> FreeFull: I'll import a dozen.
09:35:10 <geekosaur> Kron, there are several hashed container implementations around, see the unordered-containers package and Data.HashTable
09:35:26 <Kron> ok o.o
09:35:37 <Kron> reminds me, my gf keeps telling me about hoogle
09:35:44 <Kron> need to get a hoogle search engine plugin for my fox
09:35:59 <Iceland_jack> Please don't plug anything into foxes
09:36:10 <FreeFull> Hoogle only searches the haskell platform though
09:36:17 <Kron> http://www.youtube.com/watch?v=jofNR_WkoCE
09:36:19 <FreeFull> AFAIK anyway
09:36:28 * geekosaur just keeps a tab open on hayoo :p
09:36:36 <Kron> what's hayoo?
09:36:55 <FreeFull> Another search engine
09:37:06 <FreeFull> More general
09:37:13 <hpc> Kron: just go to hoogle, then click the drop-down on your search bar
09:37:22 <FreeFull> http://giavasan.diludovico.it/archivi/public_html/giavasan/archivi/images5/Firefox%20addons.jpg
09:37:24 <hpc> there will be an option to add it, and you can also set a keyword for it
09:37:26 <geekosaur> alternative haskell search engine, searches all of hackage. hoogle works better for some things, hayoo for others; most of the searches I do work better with hayoo
09:37:35 <Kron> I shall use both
09:37:38 <Iceland_jack> Kron: Are you familiar with keyword substitution in Firefox?
09:37:39 <hpc> then in the URL bar, "hoogle sdfadsf"
09:37:41 <erisco> all this time being pure and now I am entirely lost and confused....
09:37:48 <geekosaur> but if you want to do matching by types, hoogle is smarter
09:37:54 <Kron> I use vimperator with seventeen billion search engine plugins with terse keywords for all of them
09:38:02 <Kron> ranging from the wikipedia to the minecraft wiki
09:38:04 <Kron> ALL THE PLUGINS
09:38:04 <erisco> http://lpaste.net/94201 I don't have any idea what I'm doing. does this make any sense?
09:38:07 <Iceland_jack> Just use that then
09:38:21 <Kron> Iceland_jack: I am indeed!
09:38:28 <FreeFull> Kron: You don't need an addon to have a keyword for a search engine
09:38:41 <BitPuffin> Man I can't get Haskell working on netbsd :(
09:38:42 <Kron> I know, but you need plugins for the search engine itself
09:38:49 <Kron> vimperator just means I can do it with o instead of Ctrl l
09:39:22 <FreeFull> Kron: I mean, you can bookmark the search engine page, and then edit the bookmark to add a keyword
09:39:26 <Iceland_jack> Kron: What do you mean?
09:39:33 <Iceland_jack> Just use http://www.haskell.org/hoogle/?hoogle=%s
09:39:58 <Kron> if I'm correct, the bookmark generated search engines aren't fantastically good at taking complex queries. But I really haven't tried them so i don't know
09:39:58 <donri> it also links an opensearch description
09:41:03 <donri> Iceland_jack: opensearch is better
09:41:35 <Iceland_jack> Or that
09:41:37 <Kron> I don't know about opensearch! o.o
09:41:43 <donri> which i think is what Kron means by search engine plugin
09:41:55 <Kron> is that the mycroft project thing?
09:41:58 <Kron> in which case yeah that's what I use
09:42:03 <donri> that's an archive of opensearch descriptions
09:42:11 <Kron> ahh yes then I use opensearch
09:42:14 <donri> hoogle has its own
09:43:43 <lpaste> ff pasted “ss” at http://lpaste.net/94202
09:47:29 <zielwasserjunki> A short question to all people here: whos using haskell in job?
09:48:58 <erisco> @pl \x -> return (f x)
09:48:59 <lambdabot> return . f
09:56:27 <felix__> haven't see anyone using haskell in job
09:56:51 <mcstar> possibly he meant `for work`
09:57:29 <felix__> a more popular choice is ocaml, or scala maybe
09:58:16 <nicoo> felix__: At least Drup (on #ocaml) does.
09:59:39 <mangaba_leitosa> nicoo: but #ocaml has only 157 members vs. 1100 members here. Marginal language!
10:00:15 <nicoo> mangaba_leitosa: I sincerely doubt the number of users on freenode is an accurate measure of use.
10:00:17 <mcstar> it could also mean, that it is easier to grok ocaml...
10:00:20 <felix__> financial corps like Jane Street uses ocaml a lot
10:00:33 <nicoo> mangaba_leitosa: And regarding my answer, Drup uses Haskell :D
10:01:12 <mcstar> does anyone remember what's the nick of the guy behind wellposed.com?
10:01:33 <mangaba_leitosa> nicoo: ah, understood about Drup :-)
10:01:48 <mangaba_leitosa> nicoo: yes, ocaml is trivial as compared to haskell
10:02:16 <nicoo> mangaba_leitosa: Please leave condescension outside. I use both, and OCaml is definitely not trivial.
10:02:32 <nicoo> Though you hear less often about catamorphisms.
10:02:46 * nicoo hilights gdeest 
10:03:43 <mangaba_leitosa> nicoo: that's not condescension, it's an acknowledgement of my idiotism. I started learning Haskell and Ocaml at the same time and can now use ocaml in real-life projects, but I'm still a beginner in Haskell
10:04:24 <nicoo> mangaba_leitosa: Ah, yes, Haskell has a much steeper learning curve.
10:05:00 <mangaba_leitosa> nicoo: so => 'not trivial' :-)
10:05:35 <nicoo> mangaba_leitosa: It's not because it is simpler to learn at the beginning that it is trivial.
10:06:18 <mangaba_leitosa> nicoo: less expressive, has less features => less time for learning....
10:07:56 <mcstar> i'd say it was always a consideration to be able to write a simple compiler for ocaml, and that shaped the language
10:08:58 <nicoo> mangaba_leitosa: I would *love* to see an exemple where OCaml is indeed less expressive. (Note, though, that OCaml and Haskell has a rather different “feature sets”)
10:09:36 <nicoo> (And I don't mean “less expressive” as “I cannot encode X” but as “I cannot naturally write X”)
10:09:48 <mangaba_leitosa> nicoo: x + y operation, for example
10:10:07 <nicoo> mangaba_leitosa: You mean typeclasses ?
10:10:13 <mangaba_leitosa> nicoo: right :-)
10:10:23 <nicoo> The only such feature I miss in OCaml is rank-2 polymorphism, but that's not something I'ld use so often.
10:11:05 <nicoo> mangaba_leitosa: You can take a first-class module containing your arithmetic operations. Haskell just make it implicit.
10:11:20 <mangaba_leitosa> nicoo: for example, I find it annoying to write 'List.length x', 'String.length x', 'Array.length x' instead of 'length x'. That's definitely lack of expressiveness
10:11:33 <mcstar> i heard that would really hurt performance...
10:11:55 <elliott> mangaba_leitosa: just like Haskell?
10:11:56 <mangaba_leitosa> nicoo: yes, I use a type 'Scalar' in my ocaml-based DSL where you can do '1 + 1.0'
10:12:40 <nicoo> mcstar: Not that much more than with Haskell's typeclasses, AFAIK : you pay the runtime-cost iff the compiler doesn't manage to defunctorize.
10:12:53 <mangaba_leitosa> elliott: mmmm. in Haskell, you can have different 'length' for different types
10:13:24 <mangaba_leitosa> elliott:  no requirement to name them differenlty like List.length x, String.length x, Array.length x
10:13:25 <companion_cube> mangaba_leitosa: ocaml has some not-so-easy features: subtyping, GADT, functors...
10:13:26 <elliott> I mean, we could have a length class but we don't :)
10:13:29 <mcstar> not in the same namespace, only if length is a typeclass method
10:13:46 <mangaba_leitosa> elliott: and in ocaml, you  can't :-)
10:13:56 <bennofs> Can one write 'lens' in ocaml?
10:14:23 <lpaste> mike1127 pasted “Parsec question” at http://lpaste.net/94204
10:14:50 <mike1127>  question about Parsec and 'parserZero' posted
10:15:02 <elliott> you need typeclasses + HKP to do lens like lens does it
10:15:28 <mcstar> HKP == higher kinded poly.. ?
10:16:05 <elliott> yes
10:16:26 <companion_cube> otoh, you could argue that functors are also a big expressiveness improvement
10:16:50 <companion_cube> in the large, not in the small, that is
10:17:00 <mangaba_leitosa> companion_cube: right, functors are not trivial. And their use is really complicated, because of ocaml's lack of expressiveness :-)
10:17:29 <companion_cube> by "functor" I mean "modules parametrized by other modules", in this context
10:17:39 <mcstar> functors in ocaml are parameterized modules, so, they are not the same as functors in haskell
10:17:39 <mangaba_leitosa> companion_cube: you cannot easily do Map.fromList [("x", 10), ("y", 20)] without defining your own module for Map
10:18:25 <mcstar> though, probably a trivial module is a functor, am i right?
10:18:34 <mcstar> (in the haskell sense)
10:18:35 <mangaba_leitosa> companion_cube: so, yes, functors for e. g. Map are not trivial to use at all, unlike haskell, where it's really simple thanks to haskell's expressiveness
10:19:06 <companion_cube> mangaba_leitosa: look at ocamlgraph to have an idea of what functors can do
10:19:40 <benmachine> I've been using OCaml for a couple of months at work now and I do like it
10:19:52 <mangaba_leitosa> companion_cube: I'm know talking about what they can't. They can't allow me just write Map.fromList [("x", 10), ("y", 20)] and be done with creating a map :-)
10:19:58 <benmachine> but there are questions like "how do you write a datatype that contains a set of itself" that seem easy in Haskell and hard in OCaml
10:20:02 <mangaba_leitosa> companion_cube: s/know/now/
10:20:17 <mcstar> mangaba_leitosa: but you need to define ordering between the elements of the keys!
10:20:35 <mcstar> afaik, in ocaml, you parameterize the Map module with exactly that
10:20:51 <mcstar> but in haskell, Eq is given forever for String
10:20:52 <mangaba_leitosa> mcstar: right. But my example is real Haskell code that does not require any additional definitions
10:20:57 <mcstar> only a newtype can help to change it
10:21:01 <benmachine> mcstar: right, but that means that you already have to have the type before you can defined maps from that type
10:21:12 <companion_cube> it's clear that haskell's typeclasses are great
10:21:17 <mangaba_leitosa> mcstar: ok, makes sense. so, it's only easier in the basic case
10:21:37 <companion_cube> but I'm not sure that Ocaml is much less expressive on larger chunks of code
10:21:58 <benmachine> the thing I miss most about OCaml when writing haskell is non-strictness
10:22:04 <mcstar> my 2 cents is, haskell is evolving more rapidly, and i'd go with that
10:22:16 <benmachine> laziness
10:22:20 <benmachine> either/both
10:22:32 <companion_cube> benmachine: you can have some lazyness in ocaml
10:22:37 <mcstar> also, haskell is much more hip
10:22:46 <mangaba_leitosa> mcstar: ocaml, in constract is becoming marginal after appearence of F#
10:22:56 <benmachine> companion_cube: you can, but it's syntactically a bit heavyweight and not the default
10:23:05 <companion_cube> I like it not being the default actually
10:23:08 <benmachine> I don't
10:23:26 <mike1127> bump http://lpaste.net/94204
10:23:30 <mcstar> mangaba_leitosa: well, i just skimmed f#, does it really bring together OO and functional progamming better than ocaml inteded?
10:23:38 <companion_cube> (when I discovered that you could force evaluation in pattern matching, it became easier to use)
10:24:00 <nicoo> mangaba_leitosa: Your exemple about Map.fromList exhibits only one thing : for safety reasons, the OCaml stdlib forces you to specify the ordering.
10:24:12 <benmachine> companion_cube: but culturally it's not really encouraged, e.g. there's no standard lazy list type as such
10:24:26 <mangaba_leitosa> mcstar: yes, it seems that F#'s objects look much more like objects familiar to programmers of other OOP languages. Also, you can use any .NET classes from F#
10:24:43 <companion_cube> that's true. the stdlib is small, but the community provides alternatives
10:24:44 <Jesin> if Set were declared with the constraint "Ord a => data Set a", would "instance Monad Set" be valid?
10:24:53 <benmachine> Jesin: no
10:25:09 <doomlord_> f# looks nice on that front
10:25:16 <mangaba_leitosa> mcstar: and basic types in F# are objects
10:25:30 <companion_cube> but F# has no functors afaik
10:25:49 <mangaba_leitosa> mcstar: so, unlike ocaml, in F# you CAN write array.length, string.length, list.length without having to use different function names for length
10:25:49 <benmachine> Jesin: so, literally what you just said is a syntax error, there's a couple of ways of fixing it but none of them lead to exactly what you want
10:25:49 <nicoo> mangaba_leitosa: I don't feel my langage of choice is becoming marginal. (Except that Jon Harrop now ennoys the F# people)
10:25:51 <mcstar> F# can attach static methods to objects, thats how it eliminates the need for typeclasses, for basic things, afaik
10:25:56 <erisco> what is an example that just uses the ST monad?
10:26:34 <mangaba_leitosa> nicoo: yes, I read Harrop's article explaining reasons for his switch to F# from ocaml
10:26:54 <companion_cube> wasn't it because he found hashtables too slow? -_-
10:27:07 <benmachine> Harrop says some damn silly things
10:27:16 <Jesin> benmachine: which part is a syntax error? The part where I left out " = {- Constructors go here -}" for the "data" declaration, and/or "where" for the "instance" declaration?
10:27:23 <nicoo> companion_cube: He gave a boatload of silly reasons, mostly.
10:27:32 <benmachine> Jesin: no, your context appearing before the data keyword
10:27:43 <mangaba_leitosa> nicoo: he mentions that google query stats show that during a 3 year period, ocaml's popularity fell to the same degree as F#'s grew
10:27:53 <Jesin> Huh.
10:27:55 <benmachine> Jesin: you can do data (Ord a) => Set a or data Set a = Ord a =>
10:28:02 <Jesin> oh
10:28:05 <elliott> :(
10:28:06 <benmachine> Jesin: the former is obsolete because it was useless
10:28:17 <benmachine> the latter is possibly more helpful, but you can't define return for that type
10:28:19 <Jesin> it was?  =/
10:28:22 <benmachine> it also needs some extension or other
10:28:26 <benmachine> yeah, it didn't do what you'd hope
10:28:37 <Jesin> that's unfortunate.
10:28:49 <elliott> mangaba_leitosa: note that Harrop should be assumed to be trying to promote his company's services and make languages they don't favour look bad by default
10:29:02 <mangaba_leitosa> elliott: makes sense
10:29:05 <benmachine> Jesin: it's arguable to what extent this is a deficiency of Haskell and to what extent it's actually a design decision
10:29:08 <elliott> (he basically admits as much :) )
10:29:12 <nicoo> mangaba_leitosa: So ? I'm not using a given language to feel hip.
10:29:42 <nicoo> elliott: And some times, he is rather obvious about it.
10:29:46 <mangaba_leitosa> nicoo: this means that ocaml's libraries, that are not very rich as compared to haskell, will be developping even slower
10:29:49 <benmachine> Jesin: some would say that it's sort of an intrinsic property of monads that they can hold whatever they like
10:30:04 <companion_cube> I feel like Ocaml is winning over SML, on the other hand
10:30:09 <mangaba_leitosa> nicoo: less developpers -> less available librearies
10:30:12 <benmachine> Jesin: whereas sets in general just can't do that
10:30:28 <nicoo> mangaba_leitosa: Yet, the developpement of OCaml's ecosystem has been quickening over the past few years.
10:30:38 <nicoo> My bad, Jon might have been wrong.
10:30:39 <benmachine> mangaba_leitosa: I work for Jane Street and they put a lot of money/effort into OCaml standard library
10:30:54 <benmachine> well
10:30:59 <benmachine> into their own replacement for it, rather
10:31:02 <Jesin> benmachine: in category theory, couldn't you restrict yourself to the category of ordered sets and still have monads in that category?
10:31:28 <mangaba_leitosa> benmachine: good to know
10:31:45 <benmachine> Jesin: yes, and possibly you could do something like that in Haskell too
10:31:47 <mangaba_leitosa> nicoo: ok, that's a good sign then
10:32:05 <benmachine> Jesin: however it would probably be worth keeping your monads separate from ordinary monads
10:32:15 <mangaba_leitosa> nicoo: it's a pity that F# appeared the way it did, though
10:32:33 <benmachine> Jesin: it's not obvious to what extent you'd want to consider them the same thing and to what extent you want to think of them as different
10:32:45 <nicoo> mangaba_leitosa: Why ?
10:32:48 <mangaba_leitosa> nicoo: that is, Microsoft's incompatible dialect of ocaml. That's the usual Microsoft's way of doing things
10:32:49 <benmachine> Jesin: but that's just a standard problem with abstraction, I suppose
10:32:50 <Jesin> hm, okay
10:33:17 <nicoo> mangaba_leitosa: Yes, but I don't care overly much over there being F#
10:33:19 <mangaba_leitosa> nicoo: a united developper community got splitted into two
10:33:22 <companion_cube> mangaba_leitosa: F# isn't really a dialect of Ocaml, plus it's on a proprietar-ish platform
10:33:34 <companion_cube> most ocaml users, I believe, are not on windows
10:33:38 <benmachine> Jesin: there are some ways of getting pretty close to instance Monad Set, btw, but they have drawbacks
10:33:41 <Jesin> hmm
10:33:42 <nicoo> mangaba_leitosa: I don't know so many people who switched to F#
10:33:44 <mangaba_leitosa> companion_cube: right, so 'incompatible dialect' :-)
10:33:45 <Jesin> http://hackage.haskell.org/package/free-3.4.2/docs/Control-Monad-Free.html
10:33:56 <Jesin> "m >>= f = join . fmap f m" <-- isn't this incorrect?
10:34:08 <nicoo> AFAIK, it is more targeting people who already work on .Net
10:34:10 <benmachine> Jesin: join (fmap f m) I think
10:34:10 <mangaba_leitosa> companion_cube: I remember Microsoft doing the same with Java some years ago
10:34:26 <companion_cube> yeah...
10:34:27 <mangaba_leitosa> companion_cube: (their initially Java-incompatible Visual J++)
10:34:30 <Jesin> benmachine: yeah, or (join . fmap f) m
10:34:35 <mcstar> now, C# is a dialect of Java?
10:34:42 <Jesin> that means this documentation is wrong
10:34:43 <Jesin> =/
10:34:43 <companion_cube> the solution is to ignore anything that microsoft does
10:34:58 <mangaba_leitosa> companion_cube: but it does good things for haskell
10:35:03 <monoidal> Jesin: where?
10:35:04 <mangaba_leitosa> companion_cube: its research department
10:35:08 <companion_cube> microsoft research, yes
10:35:10 <nicoo> companion_cube: Nah, sometimes they contribute nice OCaml software. (Z3 anyone ?)
10:35:17 <mcstar> but you cant ignore ballmer! developers! developers! develoeprs!.....
10:35:23 <benmachine> Jesin: probably a typo rather than a serious problem
10:35:29 <companion_cube> which is only remotely concerned with microsoft-the-company stuff :)
10:35:31 <benmachine> monoidal: under "Monads provide substitution (fmap) and renormalization (join):"
10:35:31 <Jesin> monoidal: the first few lines of http://hackage.haskell.org/package/free-3.4.2/docs/Control-Monad-Free.html
10:35:50 <companion_cube> nicoo: you mean the Z3 interface to OCaml, right?
10:35:56 <mangaba_leitosa> mcstar: I didn''t mention C#
10:36:09 <benmachine> companion_cube: you know SPJ works for microsoft research, right?
10:36:11 <mcstar> i thought that's what you meant..
10:36:18 <mangaba_leitosa> mcstar: I mentioned J++, Microsoft's incompatible Java dialect, now moribund
10:36:26 <companion_cube> benmachine: yes, that's wht I was saying
10:36:27 <monoidal> Jesin: i think you can file a pull req at https://github.com/ekmett/free
10:36:29 <mcstar> i see the parallel between ocaml and f# as between java an c#
10:36:33 <try_haskell_less> Sorry bother the people in haskell land Im at "try haskell lesson 2", what is what in this expression let x = 4 in x * x
10:36:39 <benmachine> companion_cube: oh, sorry, I didn't quite keep up
10:36:42 <companion_cube> microsoft isn't pushing for haskell, but people at MSR work on ghc
10:37:12 <Jesin> oh it's maintained by ekmett too...
10:37:12 <mangaba_leitosa> try_haskell_less: it's defining a local variable x, it's scope being a single expression x * x
10:37:27 <monochrom> try_haskell_less: the general form is "let <definitions> in <expression, can use names defined in those definitions>"
10:37:47 <mcstar> it bind the value 4 to x, in the expression x * x, with (*) a free label
10:37:52 <mcstar> binds*
10:37:53 <try_haskell_less> Thankyyou very much I can move on now.:)
10:38:17 <mangaba_leitosa> mcstar: why 'java vs. c#", not 'java vs. J++' ? :-0
10:38:39 <mcstar> because i dont see how f# is a dialect of ocaml
10:38:42 <mangaba_leitosa> mcstar: isn't C# more C++ than Java?
10:38:42 <erisco> does the ST monad do anything other than provide the special 's' type parameter?
10:39:06 <erisco> mangaba_leitosa, no
10:39:13 <mcstar> mangaba_leitosa: there is managed c++
10:39:33 <doomlord_> managed c++ is an ABOMINATION
10:39:37 <monochrom> why are we talking about java, c++, and c#?
10:39:37 <mangaba_leitosa> mcstar: I tried rewriting a simple 100 line ocaml program in F#, it took about 10 global replace commands in vi to translate it
10:39:42 <Connorcpu> C# is more java than c++ for sure
10:39:45 <mangaba_leitosa> mcstar: if it's not a dialect, then what?
10:40:29 <mcstar> mangaba_leitosa: thats like saying c++ is a dialect of c, just because there is some compatibility
10:40:38 <benmachine> erisco: the ST monad allows you to use efficient implementations of mutable variables and arrays in a provably-pure way
10:40:49 <mangaba_leitosa> mcstar: I'd say that C++ is a superset of C
10:40:53 <erisco> okay but what does the ST monad do itself?
10:41:20 <doomlord_> someones' going to point out that C++ and C diverge any minute now
10:41:25 <donri> it enforces sequencing and encapsulation
10:41:26 <benmachine> erisco: you mean, how is it implemented?
10:41:26 <monochrom> why are we comparing java, c++, and c#? please move it elsewhere, maybe #haskell-blah, but preferably pm
10:41:26 <mangaba_leitosa> mcstar: or the other way round, C being subset of C++
10:41:46 <monoidal> erisco: ST is similar to IO - a value of type ST s a is a recipe to create a value of type a, possibly reading/writing references
10:42:00 <doomlord_> thanks to a small amount of divergance we have to say "There is a significant subset of C that is a subset of C++"
10:42:10 <mangaba_leitosa> doomlord_: :-)
10:42:14 <erisco> benmachine, I guess? I was presuming there was meaningful work happening behind the scenes
10:42:33 <nicoo> companion_cube: Yes, the Z3 interface. AFAIK, it is the only sane way to une Z3 ;)
10:42:36 <erisco> benmachine, but it just looks like a simple container, such as Maybe
10:42:49 <ttq> How can i get rid of these parentheses. 'func1 (func2 par1) par2 par3'
10:42:53 <benmachine> erisco: monoidal is right, listen to them
10:43:03 <benmachine> ttq: why would you want to?
10:43:11 <nicoo> ttq: f1 $ f2 p1 $ p2 p3 if you really want to
10:43:12 <erisco> monoidal, I do not understand
10:43:13 <ttq> want to learn how to use $ and .
10:43:19 <benmachine> nicoo: no, that doesn't work
10:43:33 <erisco> monoidal, for example, why is STRef needed?
10:43:34 <benmachine> ttq: you can't achieve much with $ and . here
10:43:51 <erisco> monoidal, does STRef actually provide the mutable memory area?
10:43:58 <erisco> whereas ST does not?
10:44:10 <companion_cube> nicoo: there's a python interface that is supposed to be good, too :)
10:44:10 <benmachine> erisco: do you understand IO and IORef?
10:44:21 <erisco> no
10:44:24 <benmachine> oh
10:44:26 <benmachine> well
10:44:37 <benmachine> STRef is kind of
10:44:38 <nicoo> benmachine: Indeed, wrong associativity. My bad
10:44:46 <benmachine> the name of a mutable memory cell
10:44:51 <nicoo> companion_cube: Is Python sane ?
10:44:59 <companion_cube> depends on your task!
10:45:02 <benmachine> but you need to use ST to actually do anything with it
10:45:13 <benmachine> e.g. readSTRef :: STRef s a -> ST s a
10:45:14 * nicoo has colorless tasks
10:45:32 <edwardk> Jesin: thanks for the patch. merged
10:45:33 <benmachine> writeSTRef :: STRef s a -> a -> ST s () -- or a flipped version, I don't remember exactly
10:45:37 <erisco> so if I have  ST s (STRef s a)   then I have a state with one mutable memory "cell" for a type 'a'?
10:45:47 <benmachine> yes
10:45:50 <Jesin> edwardk: that was quick, thank you ^_^
10:45:51 <benmachine> well
10:45:58 <erisco> okay, so ST s a on its own doesn't do anything
10:46:05 <erisco> ie ST s Int... is that any use?
10:46:12 <erisco> does that mean a mutable Int?
10:46:15 <benmachine> no
10:46:22 <benmachine> it means a computation that might use mutability to come up with an Int
10:46:32 <edwardk> erisco: no it is a calculation you can run that internally uses mutation to generate an Int.
10:46:44 <erisco> mkay
10:46:52 <erisco> so ST is around just for this special 's' parameter
10:46:53 <monoidal> erisco: do x <- newSTRef 0; y <- newSTRef 1; z <- readSTRef x; ...; return (x+y+z-t) is a value of type STRef s Int
10:46:56 <edwardk> erisco: but if you used runST foo      twice in different portions of your code you'd get the same Int each time.
10:47:34 <geekosaur> (ST s) is just an existential phantom type, i.e. a tag that prevents mixing. in and of itself it does nothing; but by virtue of that untouchable phantom type, it enables you to safely do things that would otherwise be unsafe. in short, it's a type system trick
10:48:05 <monochrom> it may be easier to learn IORef first.
10:48:11 <edwardk> erisco: the idea behind ST is that if you could build a value with mutation, but nobody can see you do it or distinguish how it was made, and the calculation will mean the same thing no matter when you do it, then its okay to use mutation behind the scenes.
10:48:40 <Vamp> Can anyone tell me why distinctHands gives me type errors? http://lpaste.net/2072947222177120256
10:49:33 <lpaste> novochar pasted “length_of_lists” at http://lpaste.net/94205
10:50:02 <novochar> how would you write this or something similar within ghci?
10:50:28 <geekosaur> use :{ :} or a let with braces
10:50:31 <monoidal> novochar: let length :: ...; length [] = 0; length (x:xs) = ...
10:50:38 <geekosaur> ^
10:50:40 <monoidal> novochar: or, as geekosaur said
10:50:44 <monochrom> at ghci, you have to say: let { length :: [a] -> Integer; length [] = 0; length (x:xs) = 1 + length xs }
10:51:07 <monoidal> you don't need the { } in this case
10:51:08 <monochrom> but I recommend putting it in a file and just :load
10:51:51 <novochar> oh, you can even do type classes within ghci?
10:52:01 <monoidal> Vamp: does it work with foldl (flip insert) empty ...?
10:52:03 <monochrom> recently, yes
10:52:05 <monochrom> but I recommend putting it in a file and just :load
10:52:28 <mekeor> is it hard to implement an hashing algorithm (for strings)? which one is good but simple?
10:52:34 <mcstar> mutation, in memory, ie. without actual IO
10:52:37 <Vamp> monoidal: Yes :o
10:53:01 <monoidal> Vamp: foldl takes a function a -> b -> a where a is the accumulator, b is the type of elements in the list
10:53:17 <monoidal> Vamp: foldr bit confusingly has reverse order
10:53:52 <Vamp> monoidal: I see
10:54:00 <Jesin> Is there any reason to define "f $ x = f x" insead of "($) = id" ?
10:54:01 <novochar> wow, you can
10:54:15 <monochrom> mekeor: package hashable (comes with Haskell Platform) has a hash function for String (for [a] generally)
10:54:20 <geekosaur> Jesin, monomorphism restriction
10:54:24 <novochar> thanks monoidal and geekosaur
10:54:36 <novochar> and monochrom
10:54:39 <monoidal> geekosaur: is that affected by the restriction?
10:54:46 <novochar> geekosaur: i didn't understand your response
10:54:51 <novochar> but i'm assuming it's helpful
10:54:57 <Jesin> geekosaur: can't you get around that by saying "($) :: (a -> b) -> a -> b" right before taht
10:55:08 <monoidal> novochar: if you write :{ in GHCi it starts multiline input
10:55:10 <geekosaur> novochar, I was going to expand on it but the others did before I could type it
10:55:21 <chrisdone> guys, i heard that there are channels on freenode that aren't directly or tangentally related to haskell!
10:55:26 <donri> :t id :: (a -> b) -> a -> b
10:55:26 <lambdabot> (a -> b) -> a -> b
10:55:27 <chrisdone> but then i woke up, it was just a nightmare
10:55:42 <stephenmac7> Another issue with LYAH
10:55:48 <monochrom> "($) = id" gives you id's type, not application's type :)
10:56:02 <geekosaur> and :{ :} syntax is generally used in .ghci files, not at the prompt
10:56:03 <stephenmac7> test.hs:5:14: Not in scope: `catch'
10:56:17 <geekosaur> yes, you need to import Control.Exception for it these days
10:56:28 <Jesin> monochrom: what about "($) :: (a -> b) -> a -> b; ($) = id"
10:56:29 <monoidal> f $ x = f x might inline differently
10:56:30 <stephenmac7> geekosaur: Thanks
10:56:36 <monochrom> then it's good
10:56:40 <Jesin> monoidal: yes, but I think it inlines worse.
10:56:46 <geekosaur> Prelude used to have a limited form of catch, Control.Exception had the full form. we made the limited one go away
10:56:52 <donri> :t id `asAppliedTo` id
10:56:52 <lambdabot> (a -> a) -> a -> a
10:57:14 <Jesin> :t id `asAppliedTo` unsafeCoerce
10:57:15 <lambdabot> Not in scope: `unsafeCoerce'
10:57:23 <geekosaur> monoidal, re your question to my response, it matters with ghci's extended defaulting, you're liable to get () inferred
10:57:25 <Jesin> :t id `asAppliedTo` Unsafe.Coerce.unsafeCoerce
10:57:27 <lambdabot> (a -> b) -> a -> b
10:57:44 <monoidal> Jesin: fwiw (undefined$) is _|_ with your definition, non-_|_ with f$x=f x
10:57:46 <geekosaur> since it's no longer limited to just Num
10:57:49 <monoidal> geekosaur: thanks
10:58:07 <monoidal> um I should have said ($) defined
10:58:10 <monoidal> ($) undefined
10:58:18 <lpaste> novochar pasted “length_of_lists” at http://lpaste.net/94207
10:58:22 <Jesin> Huh, interesting
10:58:32 <novochar> that's my attempt at doing multiline input
10:58:39 <Jesin> monoidal: is there any circumstance in which a function might be evaluated without being called?
10:58:50 <monochrom> novochar, use one single let
10:58:58 <novochar> okay
10:59:13 <monoidal> Jesin: only via seq/strict field
10:59:15 <monochrom> I mean this: you can use many lines fine, but don't use 3 "let"s
10:59:22 <Jesin> or anyone, really
10:59:26 <chrisdone> it depends what it means to be evaluated
10:59:39 <Jesin> ah right, seq
10:59:42 <chrisdone> a function of 3 args possibly has 3 evaluations to be forced
11:00:10 <Jesin> > ($) undefined `seq` 3
11:00:12 <lambdabot>   3
11:00:18 <chrisdone> and whether it's saturated or not makes a difference
11:00:22 <monoidal> > id undefined `seq` 3
11:00:22 <lambdabot>   *Exception: Prelude.undefined
11:00:37 <Jesin> okay then
11:00:43 <lpaste> novochar pasted “length_of_lists” at http://lpaste.net/94208
11:00:49 <startling> > id $ undefined `seq` 3
11:00:50 <lambdabot>   *Exception: Prelude.undefined
11:01:05 <geekosaur> novochar, indentation/layout
11:01:10 <lpaste> geekosaur annotated “length_of_lists” with “length_of_lists (annotation)” at http://lpaste.net/94207#a94209
11:01:11 <startling> > id $ 2 `seq 3
11:01:12 <lambdabot>   <hint>:1:13: parse error on input `3'
11:01:17 <startling> > id $ 2 `seq` 3
11:01:18 <lambdabot>   3
11:01:21 <monochrom> novochar: I forgot to say: after deleting 2 "let"s, use spaces to fill in their void, you need to keep the alignments
11:01:33 <joelteon> > 1 `(+)` 2
11:01:34 <lambdabot>   <hint>:1:4: parse error on input `('
11:01:37 <joelteon> aw
11:01:44 <Jesin> startling: "$" has lower precedence than "`seq`"
11:01:50 <monoidal> joelteon: only identifiers can be given in `...`
11:01:50 <monochrom> vertical alignment is how you can save {}s
11:02:01 <joelteon> i figured, monochrom
11:02:02 <joelteon> monoidal
11:02:05 <novochar> thanks geekosaur, that worked
11:02:09 <Jesin> :t (`seq`)
11:02:11 <lambdabot> parse error on input `)'
11:02:11 <novochar> thanks monochrom
11:02:11 <joelteon> you guys should look into diversifying your nicks
11:02:17 <startling> Jesin: oh, it does? oops.
11:02:34 <geekosaur> novochar, informally indentation indicates continuation: something more indented continues the thing on the previous line, less or equally indented starts a new thing
11:02:56 <geekosaur> (and in ghci's multiline mode the latter will usually be a syntax error, because ghci's not very smart)
11:03:07 <benzrf> ok
11:03:14 <joelteon> ghci is smart philosophically, just not with multiline stuff
11:03:16 <benzrf> I think I finally have a good intuition of monads...
11:03:28 <mcstar> socks
11:03:36 <joelteon> a monad is like a sock
11:03:41 <monochrom> joelteon: with 1000 nicks in the same channel, you are looking at the birthday paradox :)
11:03:43 <chrisdone> mcstar: you can never find them?
11:03:43 <benzrf> they are for chaining functions that each emit more than they receive
11:03:50 <benmachine> Jesin: `seq` has minimum infix precedence, same as $
11:03:51 <benzrf> the binding operator is for taking care of the extra output
11:03:54 <joelteon> fair enough monochrom
11:03:57 <mcstar> chrisdone: especially in the morning...
11:04:05 <Adeon> comonad is like a sock turned inside out
11:04:07 <joelteon> benzrf: that's the list monad
11:04:10 <joelteon> there are a lot of monads
11:04:11 <benzrf> :I
11:04:14 <mgaare_> novice functional programmers use them to masturbate?
11:04:15 <joelteon> only one of which is the list monad
11:04:19 <benzrf> by 'extra output' I mean in a super general way
11:04:23 <benzrf> i.e. things like side effects
11:04:35 <benzrf> logging, for the writer monad
11:04:42 <joelteon> mgaare_: i was going to say "difficult to digest"
11:04:44 <benzrf> or success/failure for the maybe monad
11:04:45 <mcstar> 'threading the state'
11:04:48 <Jesin> what about the State monad?
11:04:54 <benzrf> err
11:05:01 <Jesin> even worse, what about the Cont monad?  :D
11:05:02 <benzrf> :I\
11:05:09 <joelteon> your mother is a Cont
11:05:10 <benzrf> ok look i don't really know those ones ok
11:05:17 <Jesin> when I first developed intuition for Monads
11:05:18 <benmachine> I'm fond of the Cont monad
11:05:28 <Jesin> I was able to get my head around all of them except Cont
11:05:30 <benmachine> it took me way longer to understand it than anything else
11:05:32 <benmachine> but it's pretty cool
11:05:37 <chrisdone> the whole 'monads are about' attempts fall down in the same way 'monoids are about' or 'functors are about' or 'numbers are about' do
11:05:50 <benzrf> from the little ive seen of Cont it looks god damn impossibl
11:05:51 <benzrf> e
11:05:52 <geekosaur> monads are kinda like zen; the monad that has an intuition is not the true monad :p
11:05:54 <chrisdone> benmachine: http://this-plt-life.tumblr.com/post/36425238138/when-i-finally-grokked-delimited-continuations
11:06:04 <benzrf> chrisdone: do you mean benzrf
11:06:09 <chrisdone> benzrf: no
11:06:21 <joelteon> i don't understand cont yet
11:06:23 <benzrf> oh wait derp
11:06:26 <joelteon> but i don't understand continuations in general
11:06:28 <monochrom> I too have been saying forever "'what is monad' is the same question as 'what is number'" but nobody listens
11:06:29 <benmachine> chrisdone: apt
11:06:34 <benzrf> people here are constantly miscompleting to benmachine when I come here
11:06:42 <benmachine> benzrf: it happens to all the bens
11:06:43 <sipa> how is monad formed
11:06:50 * chrisdone gives monochrom a hug
11:06:54 <mcstar> how are monads useful? == how are numbers useful?
11:06:56 <joelteon> how bind get evaleted
11:07:00 <benmachine> what are birds? we just don't know
11:07:21 <benmachine> benzrf: this is useful for understanding what Cont is for http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html
11:07:28 <geekosaur> and yes, Cont will fry your brain
11:07:39 <chrisdone> sipa: how bind get value?
11:07:43 <joelteon> if I used Cont in the real world I'd understand it pretty quick
11:07:53 <benmachine> benzrf: also this http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
11:07:55 <sipa> they need to do way instain monoid
11:08:00 <benmachine> joelteon: then go read that article I just posted
11:08:05 <joelteon> but I don't know when to use it, that's when I ask smarter people
11:08:07 <mcstar> is somehow Cont more complicated, is there more to it, than just continuations in a dynamically typed language?
11:08:23 <joelteon> i don't understand continuations mcstar
11:08:23 <benmachine> mcstar: "just"? :)
11:08:40 <mcstar> well, yeah, just
11:08:57 <mcstar> i am yet to have a revelation about many things...
11:09:07 <benmachine> joelteon: the reinversion of control one is a pretty cool trick
11:09:26 <chrisdone> mcstar: Cont is just continuation passing style encoded in a monad
11:09:26 <mcstar> so, what does the word 'delimited' indicate with Cont?
11:10:13 <mcstar> chrisdone: thanks, i thought so, but needed reassurance
11:10:37 <chrisdone> mcstar: you 'delimit' where the scope of the continuation starts
11:12:01 <erisco> having hell of a time implementing this...  how do I unwrap the ST and STRef?   (a -> b -> c) -> ST s (STRef s a) -> ST s (STRef s b) -> ST s (STRef s c)
11:12:03 <chrisdone> mcstar: e.g. in scheme it's like (reset …) inside here is where the continuation is 'recorded', and then (reset (+ 2 (shift k …))) is translatable to (let ((k (lambda (x) (+ 2 x)))) (k …))
11:12:20 <chenwl> Is there a haskell way to manipulate physics unit type safely, like the c++ code do here https://gist.github.com/qzchenwl/6952888
11:12:23 <chrisdone> mcstar: so (reset (+ 2 (shift k (k 2)))) => 4
11:12:31 <johnw> also, you can re-enter the delimited block from outside it (but still within Cont).  reset starts the delimited block, shift within that block receives a continuation that resumes after the shift, but the trick is that if shift returns without calling that continuation, it can return a value (such as the continuation) from the reset block
11:12:46 <benmachine> erisco: that doesn't look implementable
11:12:48 <monoidal> chenwl: there's dimensional package on hackage
11:13:02 <benmachine> erisco: notice that you can *write* values of type c to an STRef s c
11:13:10 <benmachine> erisco: what would your function do with them?
11:13:10 <johnw> (let ((j (reset (+ 2 (shift k k))))) (j 4)
11:13:17 <monochrom> erisco: the type doesn't tell me what you want it to do. what do you want it to do?
11:13:28 <mcstar> chrisdone: thanks
11:13:37 <chrisdone> mcstar: see johnw's example too!
11:13:56 <enthropy> chenwl: check out http://hackage.haskell.org/package/dimensional
11:13:56 <benmachine> actually hmm, maybe I'm being silly
11:14:00 <joelteon> have any of you guys tried `operational'?
11:14:10 <benmachine> you can just read the first two refs and then generate a new ref
11:14:24 <benmachine> but it's probably not what you want
11:14:37 <erisco> monochrom, read 'a', read 'b', and create new ref of 'f a b'
11:14:47 <benmachine> the equivalent (a -> b) -> ST (STRef a) -> ST (STRef b) is emphatically not an fmap
11:14:51 <enthropy> oh monoidal beat me to it
11:15:06 <monoidal> erisco: just write a do-block using readSTRef and newSTRef
11:15:28 <sipa> :t readSTRef
11:15:29 <lambdabot> STRef s a -> ST s a
11:15:40 <monochrom> \f va vb -> do { a <- readSTRef va; b <- readSTRef vb; newSTRef (f a b) }
11:15:46 <mcstar> chrisdone: so, where does call/cc come into the picture?
11:15:59 <benmachine> :t \f va vb -> do { a <- readSTRef va; b <- readSTRef vb; newSTRef (f a b) } -- not the same type
11:16:00 <lambdabot> (t -> t1 -> a) -> STRef s t -> STRef s t1 -> ST s (STRef s a)
11:16:01 <monoidal> monochrom: erisco takes ST (STRef ...) not bare STRef ...
11:16:10 <mcstar> is it somehting like, you can save the state of a random function, and continue that from another with call/cc?
11:16:11 <monochrom> yikes
11:16:12 <monoidal> but it's rather weird,
11:16:21 <sipa> erisco: strefApply f sa sb = do { strefA <- sa; strefB <- sb; a <- readSTRef sa; b <- readSTRef sb; return (newSTRef (f sa sb)) }
11:16:22 <benmachine> monoidal: I suspect monochrom's function is what they want regardless
11:16:25 <monochrom> \f va vb -> do { a <- join (readSTRef va); b <- join (readSTRef vb); newSTRef (f a b) }
11:16:27 <hodapp> benmachine: very interesting link.
11:16:30 <chenwl> enthropy: it seems much complicate than c++'s way
11:16:37 <monoidal> erisco: maybe you really want (a -> b -> c) -> STRef s a -> STRef s b -> ST (STRef s c)?
11:16:45 <monochrom> heh
11:16:47 <chrisdone> mcstar: you mean how does call/cc relate to delimited continuations?
11:16:52 <mcstar> yes
11:16:56 <erisco> monoidal, I don't know. why would I want that?
11:17:20 <benmachine> monoidal: that doesn't look quite right
11:17:21 <monoidal> erisco: the same reason we have e.g. putStr :: String -> IO () not putStr :: IO String -> IO ()
11:17:32 <monoidal> benmachine: why?
11:17:37 <mcstar> maybe it has to do with non-delimited continuations? :)
11:17:41 <benmachine> monoidal: I meant monochrom
11:17:42 <chrisdone> mcstar: oh, you can implement them in terms of call/cc, or not. but i haven't tried
11:17:48 <johnw> mcstar: some simple examples of shift/reset in Haskell here: http://pllab.is.ocha.ac.jp/~asai/cw2011tutorial/main-e.pdf
11:17:52 <benmachine> :t \f va vb -> do { a <- join (readSTRef va); b <- join (readSTRef vb); newSTRef (f a b)
11:17:53 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
11:17:57 <benmachine> :t \f va vb -> do { a <- join (readSTRef va); b <- join (readSTRef vb); newSTRef (f a b) }
11:17:58 <lambdabot> (t -> t1 -> a) -> STRef s (ST s t) -> STRef s (ST s t1) -> ST s (STRef s a)
11:18:10 <johnw> err, actually that is mostly not Haskell, but it's still good
11:18:13 <monochrom> oh oops, yeah, but nevermind, it's better to drop it :)
11:18:19 <erisco> monoidal, why is that?
11:18:32 <mcstar> johnw: it is always a pleasure to real from oleg, thanks
11:18:35 <mcstar> read*
11:18:37 <benmachine> erisco: well, you can turn a function a -> m b into one m a -> m b using (=<<)
11:19:15 <monoidal> erisco: ^ it's more convenient, and the type ensures you that only the string is important, not how you get it via IO
11:19:25 <benmachine> erisco: but there are lots of functions m a -> m b that can't be made with (=<<)
11:19:26 <johnw> Chung-chieh Shan does a lot of writing about this too, he told me that he got interested in continuations as a way to analyze linguistics
11:19:38 <benmachine> so you know more about the function if you can give it the former type
11:19:52 <benmachine> with an IO String -> IO () operation, you might worry how many times it will do the IO, if at all
11:20:04 <benmachine> with (putStrLn =<<) that's not a concern
11:20:06 <enthropy> chenwl: your implementation doesn't do as much
11:20:23 * mcstar goes back to writing nested loops for threaded array transpositions...
11:20:41 <enthropy> you only have 3 fundamental units, everything is just in kg,m,s
11:20:42 <erisco> sipa, thanks that got me something anyways
11:21:28 <enthropy> chenwl: does (2 * m ** 2) work?
11:21:43 <chenwl> enthropy: I am looking for a simple example of haskell, that do the same kind of thing.
11:21:51 <monoidal> erisco: in sipa's version, I believe last return has to be removed
11:21:58 <chenwl> enthropy:   ** is undefined
11:22:16 <erisco> monoidal, yes I caught that
11:22:20 <erisco> well, the compiler did
11:22:24 <chenwl> enthropy: but 2*m*m works
11:24:39 <erisco> okay that might get me somewhere for a while. thanks for the help
11:25:22 <enthropy> chenwl: well stuff like  unit<m1+m2, s1+s2, kg1+kg2>operator*(unit<m1, s1, kg1> a, unit<m2, s2, kg2> b)  takes a bit more set-up in haskell
11:26:08 <lpaste> halvorg pasted “can't match” at http://lpaste.net/94211
11:26:19 <enthropy> or maybe it is doable with the released ghc
11:26:21 <halvorg> could anyone tell me what that error means?
11:26:32 <mcstar> you can use -std=c++11 now, with the latest versions
11:26:33 <halvorg> I handle the empty list case so I'm stumped
11:26:52 <monoidal> enthropy: It is doable, but we currently have only type-level *naturals*, while units usually require type-level integers
11:26:52 <monochrom> halvorg: you have an extra '
11:27:03 <halvorg> oy
11:27:05 <halvorg> ofc
11:27:07 <halvorg> thanks : )
11:27:11 <monochrom> hehe
11:27:29 <monoidal> enthropy: if you are willing to use manually defined integers, it's possible
11:27:41 <chenwl> how to hide Prelude or import qualified Prelude in ghci
11:28:08 <enthropy> the same syntax as for files should work
11:28:08 <monoidal> halvorg: compiling with -Wall should give you a warning for this code
11:29:20 <Fawad> I want to start learning programming and someone pointed me towards Herskell, so I need a text editor...
11:29:41 <enthropy> chenwl: the translation is probably a `data D kg m s d = D d', with things like    (*) :: D kg m s d -> D kg' m' s' d -> D (kg + kg') (m + m') (s + s') d
11:29:50 <monochrom> yes. do you already have a favourite text editor?
11:30:21 <monochrom> if not, consider notepad++ if windows, gedit if linux
11:30:22 <enthropy> but as monoidal mentioned, there is no built-in type-level integer (so you need to define that, and the instances of the type family + )
11:30:48 <monoidal> that's essentially what the dimensional package does.
11:32:05 <monoidal> Fawad: I second monochrom's suggestion
11:32:17 <Fawad> im on windows btw
11:32:26 <Francisco> gedit is not really a good choice
11:32:39 <mcstar> still, not a reason to say Herskell in place of Haskell
11:32:56 <Fawad> i spelled it wrong?
11:33:03 <monochrom> gedit is just a gateway drug editor
11:34:00 <chenwl> enthropy: quite close to c++'s version, but looks need some extension of ghc. Would you recommend me some reading? I don't quite understand the example.
11:34:03 <mcstar> modern operating systems come with vi installed
11:34:37 <mcstar> </flame>
11:37:15 <Earnestly> Which vi?
11:37:26 <Earnestly> elvis? ex? nvi?
11:37:36 <monochrom> vi vi. (as in, henry vi :) )
11:38:42 <monochrom> class VI where esc :: IO (); ...
11:39:40 <mcstar>                backspace  = cursor_left -- how annoying
11:39:58 <geekosaur> VI is of course a monad transformer over IO, since it's stateful... :p
11:40:00 <monochrom> j :: Int -> IO (); k :: Int -> iO (); ...
11:41:01 <monoidal> chenwl: for type functions, http://research.microsoft.com/en-us/um/people/simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf
11:41:20 <chenwl> monoidal: thanks
11:41:33 <chrisdone> mcstar: maybe emacs should come with vim installed
11:41:49 <mcstar> wait, it doesnt?
11:41:55 <geekosaur> vim +huge is bigger than emacs these days :p
11:42:10 <mcstar> chrisdone: evil mode?
11:42:15 <monochrom> windows vista, windows vi, windows vii, and windows viii :)
11:42:20 <chrisdone> mcstar: that's just a mode
11:42:40 <sclv> modern vis come with operating systems installed
11:42:43 <sclv> :-P
11:42:48 <monochrom> hehe
11:43:00 <mcstar> chrisdone: i appoint you to write an i386 emulator in emacs lisp, all problem solved :)
11:43:06 <Earnestly> geekosaur: Not even close to emacs.  emacs 98M installed, vim 2.8M.  emacs with lucid toolkit
11:43:19 <Earnestly> After removing all the games from emacs that is
11:43:35 <Iceland_jack> Earnestly: What's the point of Emacs after you've removed the games⁇
11:43:39 <Earnestly> Iceland_jack: D:
11:43:50 <chrisdone> Iceland_jack: nice double question mark
11:43:52 <geekosaur> mm, I am recalling a /usr/bin/vim on an RHalike that was all by itself well over 2.8<
11:43:55 <geekosaur> er, 2.8M
11:43:55 <Earnestly> Anyway, vi is not vim.
11:43:56 <Iceland_jack> Thanks.
11:44:05 <Iceland_jack> To be fair, configuring Emacs is like a very arcane RPG
11:44:08 <Earnestly> And vi is awful, even ed is better
11:44:26 <Earnestly> ex -v specifically
11:44:29 <mcstar> wine notepad ftw
11:44:31 <chrisdone> Iceland_jack: emacs is like an rpg that never ends
11:44:34 <Earnestly> howaboutno
11:44:43 <monochrom> mcstar wins :)
11:44:45 <chrisdone> people using emacs for 20 years still discover new things about it
11:44:50 <Iceland_jack> exactly
11:45:11 <mcstar> kind of shows how short life is...
11:45:19 <Iceland_jack> and you take your ‘game file’ (.emacs) and get bits and pieces from other players
11:45:34 <Earnestly> emacs is not comparable anyway
11:45:57 <monochrom> hell, I have played Civ V for 4000 years and still discovering new things :)
11:46:09 <chrisdone> haha, civ, awesome
11:46:13 <Earnestly> to vim.  It does it no justice to think of emacs as competent text editor when it is so much more.  That said, vim and emacs sure as hell beat the crap people are using these days
11:46:19 <chrisdone> got a copy of that in the 90s
11:46:28 <Earnestly> tant/
11:47:21 <chrisdone> the only thing emacs sucks at is multiple modes
11:47:41 <mcstar> im having freezes with tramp, that sucks too
11:48:22 <redscare> suppose I have a type Foo with a string description and some other property (data Foo = Foo { desc :: String, other :: Integer } for example), but I want a constructor with a default value of a description (i.e. data Foo = Foo { desc :: String, other :: Integer } | Bar { other :: Integer }; a = Bar 3; desc a = "Default description"). What is the haskell way of doing this?
11:48:45 <mcstar> the first thing that steered me in way of emacs, is that i could just create multiple frames, to the same instance, which is awesome, vim couldnt do it
11:50:01 <Saizan> if it's just for constructing you could make a bar function, if it's for pattern matching you need to rename one of your "desc"
11:50:07 <shachaf> One option: data Foo = Foo { desc :: Maybe String, other :: INteger }
11:51:18 * hackagebot constraints 0.3.4.1 - Constraint manipulation  http://hackage.haskell.org/package/constraints-0.3.4.1 (EdwardKmett)
11:51:21 <monochrom> redscare: I recommend sticking to "data Foo = Foo {desc :: String, other :: Integer}" and defining special n = Foo{desc="Default description", other=n}
11:52:59 <redscare> the reason I want to do this is it seems a conceptually cleaner way to model my problem. For example, suppose I have a type Task. I can think of a general Task as having a description and a time estimated associated with it. But I can also think of some common tasks like RunExperiment that does not need a description but still needs a time estimate. It would be great to be able to write something like RunExperiment 4.5, for example. do
11:53:00 <redscare> you recommendations remain the same?
11:53:35 <monochrom> "does not need description" != "has default description"
11:53:49 <shachaf> If it doesn't need a description then why do you want "desc" to handle it?
11:53:54 <monochrom> I use shachaf's for "does not need description"
11:54:08 <redscare> sorry, I was not precise. I meant that I do not need to modify the descriptoin
11:54:19 <redscare> so RunExperiment always has the description "Run experiment."
11:54:31 <shachaf> I use monochrom's for "always has the same description"
11:55:12 <redscare> OK. This might be asking a bit much, but it would ALSO be great to pattern match on RunExperiment
11:55:13 <monochrom> "has description, won't change" is subsumed by "has description". you don't want to change it? then don't change it. but you still have it.
11:56:45 <monochrom> data Nature = Experiment | NotExperiment; data Task = Task { nature :: Nature; desc :: String; other :: Integer }
11:56:48 <shachaf> redscare: data TaskType = RunExperiment | Papaya; data Task = Task { taskType :: TaskType, description :: String }; now you can pattern-match on
11:56:58 <shachaf> What monochrom said.
11:58:33 <monochrom> data AllInOne = Experiment { desc :: String, other :: Integer } | NotExperiment { desc :: String, other :: Integer }  is also possible
11:59:38 <monochrom> you know what, if you want to omit desc in the Experiment case, you're welcome to, it's a free country.
12:00:16 <redscare> monochrom: and then define a description that pattern matches, but by default uses desc?
12:00:26 <redscare> that is what I am doing right now, but I was wondering if there was a better way
12:01:11 <redscare> shachaf's solution above looks awesome, the only issue I can take with it is that I can create a Task that has a taskType of RunExperiment but has a description different from other RunExperiment Tasks
12:01:17 <monochrom> it just implies that at 1000 places of trying to read a description, you have to branch off for Experiment and hardcode a description for it. at 1000 places.
12:02:13 <monochrom> as opposed to, one single smart constructor for the experiment case that fills the description once and for all, henceforth you read descriptions uniformly, not caring whether it's an experiment or not
12:12:04 <sshine> I'm looking for a word to describe a property for an operator, * :: a -> b -> b, where (a * (b * e)) = (b * (a * e)). I can't call it commutative or distributive.
12:13:09 <mcstar> my descriptions http://sprunge.us/fEPD?haskell
12:14:46 <monoidal> sshine: for any a,b, the operators (a*) and (b*) commute. don't know any better description
12:15:39 <sshine> monoidal, I can be more specific: looking at a map-reduce framework, whether the reduce operator has this property seems to play a role in the structure of the framework.
12:16:16 <sshine> monoidal, i.e. whether I need the elements in the same order or not plays a role in gathering the mapped results and sorting them out first.
12:16:28 <tac> sshine: what monoidal said. You sprinkle on a handful of abstraction, thinking about the (a*)'s instead of (*) itself, and you have just described commutativity.
12:16:31 <Eduard_Munteanu> sshine: you might want to look at strength / sequence
12:16:43 <Eduard_Munteanu> :t Data.Traversable.sequence
12:16:44 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
12:16:54 <sshine> tac, monoidal: thanks :) that is certainly helpful.
12:17:12 <monoidal> sshine: list fold over this operator is invariant under permutations. or something like that.
12:17:23 <sshine> and Eduard_Munteanu, thank you :) this is actually an Erlang thing, but I found it easier to describe it in terms of types.
12:17:24 <monoidal> but that's probably too roundabout
12:17:35 <sshine> monoidal, that's actually pretty good.
12:17:57 <sshine> monoidal, although I like the one where (a*) and (b*) commute a lot. ;-)
12:18:18 <briennetheblue> @pl \((a, b), c) -> a $ b $ c
12:18:18 <lambdabot> uncurry (uncurry (.))
12:18:21 * sshine doesn't usually think in terms of partially evaluated functions commuting
12:18:35 <mcstar> (a*)((b*) e) == (b*)((a*) e) == (a*) (b*) e == (b*) (a*) e
12:18:56 <sshine> mcstar, right.
12:20:03 <eflister> i've got p :: (ParsecT s u (Reader b) a).  it is used in parsing a file, together with an earlier Parser b, the result of which i want to supply as the Reader environment to p.  i can't figure out how to get at the inner monad.
12:21:08 <hiptobecubic> i vaguely remember some idiom for injecting "fromIntegral" into things like f x y = fromIntegral x / fromIntegral y, using applicative perhaps? @pl is only giving me crazy results so i might just be wrong here
12:21:20 <hiptobecubic> not just fromIntegral, of course
12:21:21 * hackagebot simple-form 0.2 - Forms that configure themselves based on type  http://hackage.haskell.org/package/simple-form-0.2 (StephenWeber)
12:21:32 <Eduard_Munteanu> sshine: https://en.wikipedia.org/wiki/Braided_monoidal_category and related stuff might also give you a notion of swapping/twisting.
12:21:34 <hiptobecubic> but applying 'f' to both sides of some binary operator 'g'
12:21:37 <mcstar> :t on
12:21:38 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
12:21:42 <shachaf> (/) `on` fromIntegral
12:21:48 <hiptobecubic> on, that was it
12:21:50 <hiptobecubic> thanks
12:22:01 <mcstar> from data.function, iirc
12:22:14 <wollw> Is there a way to simplify an expression like this, "fmap (+1) <$> Just (Just 1))"?
12:22:28 <monoidal> (fmap.fmap) (+1) (Just (Just 1))
12:22:32 <wollw> ah
12:22:35 <monoidal> not simplified, but that's how I would write it
12:22:40 <wollw> yeah, that looks better
12:22:41 <mcstar> :t join
12:22:42 <lambdabot> Monad m => m (m a) -> m a
12:22:42 <hiptobecubic> wollw, <$> is fmap, afterall
12:22:46 <hpc> wollw: let (.:) = fmap fmap fmap in (+ 1) .: Just (Just 1)
12:22:53 <mcstar> > join (Just (Just 3))
12:22:55 <lambdabot>   Just 3
12:23:03 <wollw> hpc: I like that too.
12:23:14 <wollw> mcstar: Well, my actual problem involves different functors
12:23:23 <wollw> That was just a simple example
12:23:37 <mcstar> k, im just learning
12:24:02 <wollw> same
12:24:09 <hiptobecubic> fmap fmap fmap always felt unnecessarily opaque to me
12:24:23 <monoidal> eflister: probably you use runPT + runReader where you supply the result of the earlier parser
12:24:23 <shachaf> Of course it is.
12:24:41 <johnw> hiptobecubic++
12:25:47 <hiptobecubic> i guess using fmap for (.) always felt a little ugly
12:27:01 <briennetheblue> it's just for fun i think
12:27:11 <briennetheblue> i don't think there's a good reason to write fmap.fmap like that
12:28:01 <eflister> monoidal: how does runPT differ from runParsecT?  both parsers run in a call to parseFromFile, so i don't know what input to give something like runParsecT...
12:28:47 <monoidal> eflister: I don't know exactly what runParsecT does, but runPT is afaik easier to use
12:29:27 <eflister> monoidal: they are the same type, are they synonyms?  anyway, if i'm in the midst of parsing the file using parseFromFile, what input would i give an inside call to runPT?
12:30:21 <monoidal> hm I don't know. perhaps I would not use parseFromFile.
12:30:22 <eflister> monoidal: yeah, src says runParserT = runPT
12:31:18 <eflister> monoidal: the context is the file has column headings and then a list of entries.  the first parser finds the column positions of the headings, and the second parser verifies that the entries do fall in those column positions.
12:31:21 <briennetheblue> > over (wrapping Compose) (fmap (+1)) (Just (Just 1))
12:31:22 <lambdabot>   Not in scope: data constructor `Compose'
12:41:22 * hackagebot haskell-modbus 0.3 - A cereal-based parser for the Modbus protocol  http://hackage.haskell.org/package/haskell-modbus-0.3 (JasonHickner)
12:42:25 <eflister> monoidal: sorry, battery died.  can you resend anything from after my last message at xx:24?
12:43:05 <monoidal> eflister: I don't have any good idea. maybe you can not use parseFromFile
12:44:04 <eflister> monoidal: ok, thx.  in general, the only way to get at the inner monad is to run the outer one?  there's nothing (like lift or sequence or something) that can get in there?
12:44:29 <monoidal> what do you mean "get at the inner monad"?
12:45:40 <halvorg> :t foldl1'
12:45:41 <lambdabot> (a -> a -> a) -> [a] -> a
12:46:12 <eflister> monoidal: well, run it.  :)
12:46:22 <monoidal> eflister: ah, I think I understand. in general, it's the only way.
12:46:58 <monoidal> you can use functions such as lift, return, withReaderT etc. for other purposes
12:47:53 <mekeor> monochrom: but i wanna code it myself! ;)
12:48:23 <eflister> monoidal: hrmph, ok.  you'd just do it in two passes?  it sure feels like it should be doable in one!
12:54:35 <halvorg> If I have a function that takes zero parameters that always yields the same result, like f.x. globalPrimes = take 10000 Data.Numbers.Primes.primes, does this "function" get reevaluated if it is used in different scopes?
12:54:46 <halvorg> I can make an example if that was unclear
12:55:02 <hpc> halvorg: it's not a function if it takes no parameters
12:55:09 <Eduard_Munteanu> halvorg: it's usually shared, unless it's too polymorphic
12:55:09 <glguy> halvorg: functions take one parameter
12:55:27 <Eduard_Munteanu> Which was the reason for DMR.
12:55:32 <halvorg> so it is a value/data any I do not have to pass it around to everything i call?
12:55:36 <halvorg> and*
12:55:45 <chrisdone> yes
12:55:48 <hpc> halvorg: and in ghc it should stay evaluated over the whole life of your program (modulo polymorphism)
12:56:03 <halvorg> man, I've done lots of stupid shit then :D
12:56:04 <hpc> halvorg: it won't ever get "unevaluated", so it can be a source of memory leaks
12:56:04 <halvorg> thanks guys
12:56:29 <chrisdone> hpc: is ghc not smart enough to garbage collect it if it can never be reached by any codepaths anymore?
12:56:35 <Eduard_Munteanu> halvorg: if anything, referencing the global definition would be better than passing it around.
12:56:56 <monochrom> mekeor: you can draw inspiration from hashable. or just know that it can be done so you do it your own way.
12:57:04 <geekosaur> chrisdone, it is, but laziness can mean what you think is unreachable is still reachable
12:57:16 <monoidal> eflister: either in two passes, or I would somehow combine the two parsers to a single one
12:57:27 <chrisdone> geekosaur: well when i say reachable that includes "reachable by laziness"
12:57:45 <geekosaur> sure, just remember the compiler is less likely to overlook something :)
12:57:50 <geekosaur> so is the gc
12:58:00 <hpc> chrisdone: it can always be reached; it's global
12:58:10 <chrisdone> hpc: nuh-uh!
12:58:13 <Moogle_> does hGetLine properly handle \r\n on linux?
12:58:15 <chrisdone> x = 1
12:58:16 <chrisdone> main = print "Go!"
12:58:18 <chrisdone> x can't be reached
12:58:26 <hpc> oh, like that
12:58:31 <hpc> no clue, actually
12:58:57 <monochrom> ghc -O omits "x=1" altogether actually. that's dead code removal.
12:58:57 <geekosaur> Moogle_, define "properly"
12:59:08 <Moogle_> geekosaur: properly chopping off the \r bit
12:59:18 <hpc> chrisdone: here's a good test:
12:59:20 <chrisdone> monochrom: of course. but that wasn't the point of the example
12:59:38 <geekosaur> Moogle_, as far as unix/linux is concerned \r is just a character and is not part of a newline
12:59:48 <chrisdone> main = do print x
12:59:49 <chrisdone>            forever $ print "woot"
12:59:54 <chrisdone> is another example
12:59:55 <hpc> x = [1..]; main = do rnf (take 10000000 x); threadDelay (whatever a minute is)
12:59:55 <glguy> Moogle_: if you want Windows behavior check out System.IO.hSetNewlineMode :: Handle -> NewlineMode -> IO ()
12:59:56 <Moogle_> geekosaur: ah, alright. I'll just have to make my own function for parsing HTTP lines then. thanks!
12:59:59 <geekosaur> i.e. you are asking for what the OS and libraries consider NOT "porperly"
13:00:01 <chrisdone> after the print x, it's unreachable
13:00:06 <hpc> yeah
13:00:07 <monochrom> yeah, that one will really test it. I think x will get GCed
13:00:25 <geekosaur> there are http libs, I imagine they support network format which specifies \r\n
13:00:34 <Moogle_> geekosaur: makes sense! i myself think the fact that HTTP/IRC and a billion other protocols use \r\n is silly
13:00:41 <geekosaur> writing your own would be silly, even the old HTTP library is better than that
13:00:49 <Moogle_> it's just to teach me parsec in more detail
13:00:53 <geekosaur> Moogle_, it's a historical leftover
13:01:03 <mekeor> monochrom: but which algorithm should i implement? md5 is insecure, sha as well. whirlpool?
13:01:11 <geekosaur> before unix took over, the earliest ARPAnet stuff was TOPS-10
13:01:18 <geekosaur> (well, Tenex)
13:01:19 <chrisdone> md5 and sha are insecure? for what?
13:01:28 <Moogle_> geekosaur: would it be a performance issue to use hGetChar and keep grabbing characters until I get an \r\n?
13:01:33 <monochrom> cryptographic hash? I don't know, consider sha256
13:01:33 <Moogle_> is there a better way to do that?
13:01:42 <Eduard_Munteanu> mekeor: SHA256 is reasonable... but what for?
13:01:45 <hpc> mekeor: what are you doing? md5 is perfectly fine for a few things
13:01:52 <chrisdone> glass windows and door keys are insecure. it depends who you're trying to stop
13:02:17 <Eduard_Munteanu> MD5 is poor for many things, actually.
13:02:25 <geekosaur> Moogle_, I'd probably use a hGetLine wrapper that trimmed a trailing \r
13:02:42 <Eduard_Munteanu> Slower than a CRC, a lot less secure than SHA256.
13:02:50 <donri> chrisdone: md5 is broken, you can find duplicates without brute force (IIRC?)
13:02:50 <Moogle_> geekosaur: makes sense, though wouldn't I have to do an O(n) search to get to the end of the list?
13:03:01 <Moogle_> geeoksaur: traversal, whatever.
13:03:15 <Moogle_> ooooh wait is there a Text version
13:03:19 <Moogle_> rather than a String version
13:03:23 <mekeor> uh, i just want to write a password-trainer. i have many passwords and i wrote them down. i want to write a password trainer which says "Enter password for mekeor@gmail.com: " and then i have to type in the password and the program checks whether it matches the saved hash... – could i explain it?
13:03:45 <Moogle_> ah wonderful, there is
13:04:01 <mekeor> but i wanna implement the hash function myself :D
13:04:27 * geekosaur can't help but consider that a red flag
13:04:27 <mekeor> and i dislike sha for being standardized by NIST.
13:04:31 <monochrom> is that all "password-trainer" means? nothing else? I've never heard of that term.
13:04:37 <geekosaur> first rule of crypto: don't implement it yoursef
13:04:38 <hpc> wat
13:04:49 <mekeor> monochrom: i created that word myself
13:04:50 <Eduard_Munteanu> mekeor: if you want to check the password without storing it cleartext, you probably want to encrypt or do *multiple* rounds of a good hash.
13:05:02 <Eduard_Munteanu> And salt it too.
13:05:10 <donri> mekeor: you shouldn't memorize your passwords though ;)
13:05:11 <elliott> "for being standardized by NIST", lol
13:05:12 <hpc> you should solve the underlying problem of "your passwords are so bad you have to write them down"
13:05:13 <abg> Or use HMAC SHA256
13:05:13 <mekeor> Eduard_Munteanu: the point is, that i wanna implement the hash function myself
13:05:20 <monochrom> ok, why do you even need hashing? it's just a program for finger exercise
13:05:38 <mekeor> donri: why not? huh? Ô.ô?
13:05:42 <Eduard_Munteanu> Ah, I'm probably missing the point.
13:05:43 <glguy> elliott: I dislike it for having too few numbers in its name
13:06:10 <mekeor> hpc: nope.
13:06:14 <donri> mekeor: you should use a password manager and only memorize that master passphrase
13:06:20 <monochrom> "monochrom's hash 2938493" :)
13:06:34 <donri> mekeor: and then generate random passwords for each use
13:06:52 <glguy> ooh, with that many numbers it's probably quite secure, and you just made it up so the NSA probably hasn't influenced it
13:06:53 <mekeor> but sometimes i have to login to an e-mail account on another computer where i can't use a master password, e.g.
13:07:06 <monochrom> no, you should tell me your master password :)
13:07:16 <abg> hunter2
13:07:20 <donri> mekeor: you can store the password db encrypted online
13:07:28 <elliott> donri: (do you have any recommendations for an (open-source, preferably Windows+Linux) password manager? I'm in the market. I should maybe join -blah for this...)
13:07:31 <mekeor> monochrom: yeah, that'd be cool because i could always ask you on irc :D
13:07:31 <chrisdone> just keep the hard part of your password written down and keep it in your wallet
13:07:35 <Jesin> so
13:07:50 <abg> elliott: keepass is FOSS
13:07:52 <ibotty> mekeor: be sure to mention very visibly that the program you are writing was written to learn and is not meant to be used! people might use your supposedly broken crypto (that's the second rule of crypto: that it will be wrong)...
13:07:58 <monochrom> this is beyond XY problem. it's now YZ solutions.
13:08:23 <mekeor> ...
13:08:37 <elliott> abg: yes, but it seems like KeePassX is nicer on Linux, and only an alpha version is compatible with the latest Windows version...
13:08:49 <Jesin> does GHC or anything else offer good support for parallelism?
13:08:56 <donri> elliott: no, i'm also in the market. i used lastpass for a while but not free software. currently just use firefox sync
13:09:01 <chrisdone> do thunks eval in the woods?
13:09:05 <elliott> clearly, someone should write an excellent cross-platform one in Haskell. *master of on-topicity*
13:09:17 <chrisdone> elliott: hurrah!
13:09:19 <donri> chrisdone: i thunk, therefore i might become
13:09:27 <Jesin> The way Haskell doesn't allow side effects seems like it would allow a lot of automatic parallelism...
13:09:40 <Moogle_> Jesin: you'd be right. there's a free textbook on the matter
13:09:41 <elliott> chrisdone: thank you for volunteering! get to work!
13:09:47 <elliott> Jesin: not quite automatic, but yes
13:10:12 <Moogle_> Jesin: http://chimera.labs.oreilly.com/books/1230000000929/index.html
13:10:20 <chrisdone> unsafePerformWriteSecuritySoftware
13:10:34 <Moogle_> theoretically, a haskell compiler could do a lot of automatic parallelism...
13:10:46 <Jesin> I'l look at Moogle_'s link.  elliott, is there anything you'd recommend for this?
13:11:04 <Eduard_Munteanu> unsafeBlowWhistle
13:11:15 <elliott> Jesin: the parallel and monad-par packages are relevant
13:11:25 <abg> safeRot13ForPasswordStorage
13:11:33 <alpounet> chrisdone, hey, i'm investigating notdan's restricted-workers package: http://hackage.haskell.org/package/restricted-workers - that may help us out significantly
13:11:33 <donri> mekeor: also, understand that length adds exponential complexity to passwords, whereas alphabet is only linear. there are programs for generating "pronounceable passwords" which tend to be easy to memorize, and you can combine two or four shortish passwords into one passphrase and it's quite secure
13:12:07 <chrisdone> Eduard_Munteanu: https://www.youtube.com/watch?v=8X_Ot0k4XJc
13:12:21 <monochrom> 1st law of crypto: the cipher must prevent humans from getting the plaintext. 2nd law of crypto: the cipher must prevent itself from getting the plaintext, when allowed by the 1st law. 3rd law of crypto: the cipher must accept plaintexts, when allowed by the 1st and 2nd laws. :)
13:12:30 <Eduard_Munteanu> :P
13:12:56 <abg> 4th law of crypto: when in doubt, XOR
13:13:41 <chrisdone> alpounet: isn't the diagrams package basically a pure dsl?
13:13:48 <chrisdone> (and therefore trivial to run safely)
13:13:58 <hpc> 0th law of cryptography: the attacker will just hit your operational security anyway
13:13:59 <monochrom> 1st law of compression: ... :)
13:14:04 <Fawad> I've got a question about this definition:
13:14:05 <Fawad> doubleSmallNumber x = if x > 100
13:14:06 <Fawad>                         then x
13:14:06 <Fawad>                         else x*2
13:14:31 <Fawad> what if I want x to not be a negative number
13:14:35 <chrisdone> ah, he's using SELinux
13:14:36 <alpounet> chrisdone, well yeah but they run arbitrary haskell programs on http://paste.hskll.org/
13:14:40 <luite> chrisdone: if you need to render or load external data (fonts, bitmaps) you often need IO
13:14:40 <heath> http://www.meetup.com/Fantasy-Land/
13:14:50 <Taslem> Fawad: If it IS a negative number, what should happen?
13:14:56 <heath> if you happen to be in the nashville area, let's meetup
13:15:12 <Fawad> then it would get timed by 2
13:15:19 * heath is looking for other haskellers around nashville, tn
13:15:26 <Fawad> since x<100
13:15:46 <Moogle_> Fawad: you might make the condition "if abs x > 100" then.
13:15:49 <chrisdone> luite: ah, i've never looked at the package
13:16:07 <chrisdone> alpounet: thanks, couldn't remember the url
13:16:09 <Moogle_> > abs (-100)
13:16:10 <lambdabot>   100
13:16:25 <luite> chrisdone: yeah it's easiest to set it up with a vm
13:16:32 <Fawad> I'll try
13:17:12 <chrisdone> luite: what is?
13:17:32 <luite> chrisdone: anything based on restricted-workers
13:17:36 <luite> if you need the selinux security
13:17:55 <luite> ubuntu has a broken selinux policy, but recent debian works
13:18:33 <chrisdone> yeah, so i heard
13:19:03 <alpounet> i could try to set something up on my server and then make it chat with lpaste
13:19:04 <Fawad> Moogle: what did you mean by > abs (-100) ?
13:19:07 <donri> fedora FUCK YEAH
13:19:11 <alpounet> but I suppose you'll want this on your server at some point
13:19:47 <Iceland_jack> Fawad: It's a way of evaluating expressions here
13:19:49 <Iceland_jack> > 5 + 5
13:19:50 <lambdabot>   10
13:20:11 <chrisdone> alpounet: i don't really care where it runs
13:20:14 <luite> yeah fedora/centos should work fine with selinux obviously :)
13:21:30 <Moogle_> Fawad: it was to show how it turns negative numbers into positive numbers. lambdabot here in the channel has GHCI going on (sort of) and evaluates stuff for us.
13:21:34 <chrisdone> alpounet: as long as i can ask it for stuff, it doesn't matter
13:21:59 <Moogle_> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 10 fibs
13:22:01 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
13:22:53 <chrisdone> donri: how easy is it with fedora?
13:23:17 <donri> chrisdone: is what? selinux? it's set up out of the box
13:23:45 <chrisdone> hmm, i'll try it in virtualbox
13:23:50 <ypaq> hey, i'm playing around with haskell a bit. i bumped into this: http://dev.stephendiehl.com/hask/ . i was just trying out the ghci.conf part which does an 'import Control.Monad.IO.Class'. this import lets my ghci seg fault.
13:24:00 <chrisdone> jesus, it's massive
13:24:11 <chrisdone> donri: is there a server version that just has bare essentials?
13:24:12 <ypaq> anyone an idea why
13:24:21 <donri> chrisdone: there's a netinstall
13:24:39 <ypaq> i'm running ghc 7.6.3
13:24:51 <ypaq> on a mac
13:24:53 <hpc> ypaq: that's... special
13:24:56 <chrisdone> donri: where?
13:25:19 <donri> chrisdone: https://fedoraproject.org/en/get-fedora-all Network Install CD
13:25:23 <ypaq> hpc: thought so
13:25:50 <hpc> http://hackage.haskell.org/package/transformers-0.3.0.0/docs/src/Control-Monad-IO-Class.html#MonadIO
13:25:55 <hpc> ypaq: try importing System.IO
13:26:10 <chrisdone> donri: lol, 300mb =)
13:26:31 <chrisdone> donri: i remember when i could get a 40mb freebsd netinstall disc. what happened to the world?
13:26:38 <donri> :)
13:27:06 <donri> chrisdone: there's a 129M cloud image for EC2 :)
13:27:13 <hpc> i remember when the average household internet speed was measured in kb/s
13:27:13 <chrisdone> (it doesn't help that i've been playing with damn small linux all day)
13:27:16 <ypaq> hpc: seg faults with System.IO too
13:27:16 <hpc> oh wait, that's still true :(
13:27:18 <donri> hah
13:27:23 <chrisdone> hpc: ;_;
13:27:43 <chrisdone> donri: hm where's that?
13:27:51 <hpc> ypaq: you have a bad problem and will not go to space today :(
13:27:54 <donri> chrisdone: https://fedoraproject.org/en/get-fedora-options#clouds
13:27:56 <hpc> i have no idea what's wrong
13:28:15 <hpc> but it's fairly fundamental and it's a miracle you have anything at all
13:28:36 <hpc> someone else will have to help you further
13:28:36 <donri> chrisdone: you can also install fedora with just yum
13:28:40 <ypaq> hpc: when i disable the ghci.conf and import System.IO it's fine
13:29:04 <hpc> that's odd
13:29:16 <chrisdone> donri: i'm on ubuntu, i don't have yum
13:29:40 <donri> chrisdone: sudo apt-get install yum :)
13:29:59 <donri> this isn't the best method if you want a vm though. it works for setting up a chroot
13:30:24 <Rarrikins> From runghc: Zomg.hs:1:33: Not in scope: `main' Perhaps you meant `min' (imported from Prelude)
13:30:33 <chrisdone> chris@retina:~$ sudo apt-get install yum
13:30:33 <chrisdone> Error: attempted to install competitor. Erasing hard disk ...
13:30:41 <donri> lol really?
13:30:52 <chrisdone> lol, nah
13:30:56 <monochrom> Rarrikins: I want to see at least the first 5 lines of the file
13:30:56 <donri> :D
13:31:21 <hpc> ypaq: i suppose play around with ghci.conf and see if a specific line causes the problem
13:31:41 <hpc> ypaq: or take a hint from the "doctor it hurts when i do this" joke and just not have a ghci.conf
13:31:43 <notdan> chrisdone: maybe there is a vagrant image for fedora which might be small enough
13:31:44 <hpc> ;)
13:31:47 <notdan> not sure though
13:31:55 <ypaq> hpc: it seg faults when i add 'import Control.Monad' and 'import System.IO' to ghci.conf. not an issue when i manually import in ghci. weird
13:32:15 <Rarrikins> monochrom: It was http://lpaste.net/3943758096400121856
13:32:39 <ypaq> hpc: :D
13:32:46 <quchen> Is the maintainer of fclabels on IRC?
13:32:50 <monochrom> ok, do you have anything called "main"?
13:32:59 <donri> quchen: i think that's sfvisser ?
13:33:04 <monochrom> if you don't, then it is ineligible for runghc.
13:33:14 <quchen> donri: That's his email at least
13:33:17 <hpc> ypaq: you might try asking #ghc
13:33:28 <ypaq> hpc: will do, thanks!
13:33:29 <hpc> or posting to the trac, since it seems like a bug
13:33:40 <hpc> at the very least, it should give a message instead of segfaulting
13:36:25 * hackagebot mysql 0.1.1.5 - A low-level MySQL client library.  http://hackage.haskell.org/package/mysql-0.1.1.5 (BryanOSullivan)
13:37:13 <chrisdone> feel sorry for people still using mysql
13:37:13 <Rarrikins> monochrom: Ahh, I see. Thanks :)
13:37:27 <monochrom> you're welcome
13:37:44 <shachaf> I think #haskell is probably a better channel for that question.
13:38:00 <shachaf> #ghc is for GHC development.
13:38:07 * zammy is away: I'm busy
13:38:07 <chrisdone> notdan: there is a 400mb one on vagrant =)
13:38:17 * zammy is back (gone 00:00:04)
13:38:22 <monoidal> ypaq: do you need both Control.Monad and System.IO to crash?
13:38:41 <hpc> shachaf: a ghci segfault is most certainly a question for ghc developers
13:38:53 <elliott> zammy: you might want to disable that script :)
13:38:57 <zammy> alright
13:38:59 <zammy> done
13:39:20 <shachaf> GHC developers are in here.
13:40:53 <hpc> shachaf: and lots of people in -blah are here too; if you can't talk about ghc in #ghc what can you talk about?
13:42:12 <elliott> fixing bugs would seem to be under the purview of GHC development
13:42:28 <hpc> it's a segfault ffs
13:42:49 <flebron> monochrom: I tried using threadDelay as a timeout for a computation, but I can't seem to get it to work. Am I doing something wrong here? http://lpaste.net/94189
13:43:13 <hpc> flebron: that's supposed to be a delay of one second?
13:43:21 <geekosaur> I think a segfault in a ghc-related program is perfectly sensible for #ghc, provided it's not obvious foot shooting like reinventing unsafeCoerce
13:43:24 <flebron> yeah, that many microseconds
13:43:25 <monoidal> i think panics and segfaults can be reported here first, if no one recognizes it it should be taken to #ghc
13:44:17 <flebron> (Even setting the argument to threadDelay to 1 doesn't work, it always returns the "student" function, taking several seconds.)
13:44:39 <chrisdone> quoth vagrant:  Progress: 19% (83557998 / 418870169)
13:44:39 <chrisdone> who ever cares to see bytes when it's more than 1024?
13:44:42 <hpc> flebron: could you be in the non-threaded runtime?
13:44:52 <hpc> chrisdone: that smells like zmodem
13:44:53 <hpc> ;)
13:44:56 <flebron> I tried compiling with -threaded, is that enough?
13:46:22 <hpc> flebron: what if you have no threadDelay at all?
13:47:03 <flebron> Then it returns 1 consistently.
13:47:27 <donri> i tried flebron's program earlier and it returns 1 without threadDelay and 300.. even with just threadDelay 1
13:47:41 <hpc> http://www.mspaintadventures.com/advimgs/ps/ps1035_1.gif very strange...
13:48:18 <ypaq> actually i don't have to have anything in my ghci.conf. ghci seg faults randomly
13:48:33 <hpc> theory:
13:48:48 <hpc> threadDelay yields the x thread
13:48:57 <benmachine> possibly the student computation doesn't allocate, so doesn't have any points to yield at
13:49:02 <hpc> then y starts doing number crunching in such a way that doesn't.. that
13:49:05 <monochrom> flebron: use "evaluate" not "return". "return" clearly takes 0 seconds to "finish".
13:49:16 <benmachine> ah
13:49:20 <benmachine> monochrom has a much better idea
13:49:22 <johnw> chrisdone: the best article I ever read on delimited continuations was this one: http://blog.moertel.com/posts/2005-09-13-scope-herding-with-delimited-continuations.html
13:49:31 <flebron> Oh it only evaluates to whnf?
13:49:34 <monoidal> ypaq: it might be http://ghc.haskell.org/trac/ghc/ticket/8094
13:49:38 <monochrom> yes
13:49:38 <benmachine> y always wins the race, but isn't actually evaluated
13:49:54 <hpc> johnw: fun fact: all continuations in haskell are delimited
13:50:00 <benmachine> so you do the waiting after the race is over
13:50:05 <hpc> Cont continuations are delimited by runCont
13:50:10 <geekosaur> yes, that looks sensible
13:50:22 <johnw> hpc: yes, and as a result the implementation of shift and reset are extremely trivial
13:50:29 <hpc> :D
13:50:31 <geekosaur> you get back an instantly computed thunk, which is actually evaluated in the print
13:51:28 <monochrom> no no, "return" evaluates nothing. "evaluate" evaluates to whnf, which is what you need for Int
13:51:48 <flebron> monochrom: Awesome :))
13:51:53 <hpc> for something less trivial you might want rnf
13:51:59 <flebron> Yeah I meant the waiting function :)
13:52:11 <flebron> Just to be sure, you mean evaluate from Control.Exception right?
13:52:14 <monochrom> yeah, "evaluate (rnf xxx)"
13:52:23 <monochrom> yes
13:53:10 <ypaq> monoidal: definitely possible, i'm running show leopard
13:53:14 <monochrom> it's in Control.Excpetion because it also exposes divide-by-zero and things like that so you can catch
13:53:58 <flebron> Incidentally this is perfect for my case - I'm already calling evaluate to catch those things (I'm grading student code and wanted to guard against both exceptions and nontermination).
13:59:36 <danilo2> Hello! Is there any newer TH documentation than this one? It does NOT contain some things like "LitT" or "StrTyLit" (these types appear when you runQ in GHCI something like (A::A "test") using PolyKinds and Datainds http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/template-haskell-2.5.0.0/Language-Haskell-TH.html
14:00:37 <hpc> http://hackage.haskell.org/package/template-haskell-2.8.0.0/docs/Language-Haskell-TH.html -- the latest version, perhaps?
14:02:14 <danilo2> hpc: super, thank you. Hmm maybe the links from other documentation sites should update automatically? I mean: http://www.haskell.org/haskellwiki/Template_Haskell ? Because I know no other way to get the TH documentation than by going through this site
14:02:37 <Cale> danilo2: Usually to get to documentation I go to hackage
14:02:46 <Cale> http://hackage.haskell.org/packages/
14:03:06 <monoidal> danilo2: I will update that link
14:03:30 <monochrom> danilo2, you should: 1. look up which version your GHC is using (and yes it's tied to your GHC, avoid installing a different version); 2. look up the doc for that version, no more no less; 3. the doc comes with your GHC already, somewhere on your hard disk; 4. people spend lifetimes browsing the web and not one minute browsing their own disks.
14:03:52 <Cale> I updated the link already
14:04:22 <monochrom> I would much prefer that link to point to the copy on your disk
14:04:33 <Cale> That's kind of hard.
14:04:45 <monochrom> because if you're at GHC 7.0, the doc for 2.8.0.0 is of no use to you
14:04:57 <benmachine> I used to use on-disk docs but they weren't built with --hyperlink-source and that made me sad
14:04:59 <Cale> Well, it now links to the template-haskell page on hackage.
14:05:04 <Cale> You can select the version from there
14:05:04 <monochrom> and if you're at GHC 7.8, the doc for 2.1.0.0 is of no use to you
14:05:17 <danilo2> monochrom: You're right - I'll start using the local one :)
14:05:33 <monochrom> people spend lifetimes browsing the web and not one minute browsing their own disks. this is sick.
14:05:40 <Cale> I'm not sure how one would reliably make it a file: link
14:05:59 <Cale> Because the documentation is installed in different places on different architectures
14:06:04 <monochrom> I know it's impossible. some dreams and ideals are impossible. I know that.
14:07:12 <Cale> I actually do have my local haddock index bookmarked, but since there's so much stuff in it, it's often more convenient just to go to hackage anyway
14:07:24 <Cale> (It's not split up by package)
14:08:10 <monochrom> yes, but often I just click through to the index and look for individual entity names
14:08:41 <Cale> Yeah, it's definitely better when you don't know which package something comes from
14:10:18 <johnw> chrisdone: ping
14:16:34 <danilo2> Does anybody hav an idea why such error can occure: "/tmp/test.config: openFile: does not exist (No such file or directory)" (While using configurator haskell package's load function). What is interesting the file exists and can be read (by for example "cat"). Additionaly this is part of a code, which works on my computer but does not work on computer of my friend (throwing such error)
14:17:11 <halvorg> [A
14:17:11 <halvorg> [A
14:20:49 <mekeor> danilo2: does the file CERTAINLY exist on the computer of your friend for SURE?
14:22:46 <colluphid> hey im not really sure why this wont work: map (\x -> read x :: Int) y
14:22:55 <colluphid> where y = "1234567890"
14:23:16 <hpc> colluphid: y :: [Char], so when you map over it x :: Char
14:23:18 <mekeor> colluphid: because "read" gets a string, not a char
14:23:40 <joelteon> colluphid: map (\x -> read [x])
14:23:51 <mekeor> > map (\x -> read [x] :: Int) "1234567890"
14:23:52 <lambdabot>   [1,2,3,4,5,6,7,8,9,0]
14:23:59 <joelteon> > ord '1'
14:23:59 <lambdabot>   49
14:24:18 <colluphid> joelteon: sweet, thanks for that
14:24:19 <joelteon> > map (\x -> chr (ord x - 48)) "123456789"
14:24:20 <lambdabot>   "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t"
14:24:23 <joelteon> whoops
14:24:29 <joelteon> > map (\x -> fromIntegral (ord x - 48)) "123456789"
14:24:30 <lambdabot>   [1,2,3,4,5,6,7,8,9]
14:24:33 <colluphid> mekeor: and thanks for the rational
14:25:14 <ion> > 5%6
14:25:15 <lambdabot>   5 % 6
14:25:22 <mekeor> :D
14:26:42 <danilo2> mekeor: I've asked aboiut it thousand times and indeed if he cats it, he gets its output
14:27:04 <ion> > map (\x -> ord x - ord '0') "1234567890"  -- I’d just use ord instead of a magic number here.
14:27:06 <lambdabot>   [1,2,3,4,5,6,7,8,9,0]
14:27:47 <benmachine> > map digitToInt "1234567890" -- I would use neither :)
14:27:48 <lambdabot>   [1,2,3,4,5,6,7,8,9,0]
14:27:53 <ion> :-)
14:28:12 <arkeet> > map digitToInt "123456oops"
14:28:12 <lambdabot>   [1,2,3,4,5,6,*Exception: Char.digitToInt: not a digit 'o'
14:28:14 <ion> digitToInt is evil.
14:28:26 <ion> > (digitToInt 'f', digitToInt 'g')
14:28:27 <lambdabot>   (15,*Exception: Char.digitToInt: not a digit 'g'
14:28:31 <arkeet> haha
14:28:35 <benmachine> ion: and \x -> ord x - ord '0' is less evil?
14:28:37 <mekeor> let digitToInt 'o' = 0
14:28:41 <ion> benmachine: I didn’t say that.
14:28:42 <arkeet> yes! (it's total)
14:28:54 <benmachine> arkeet: there are many forms of evil in the world.
14:29:07 <benmachine> ion: fair enough
14:29:21 <ion> https://github.com/ekmett/lens/blob/master/src/Numeric/Lens.hs#L79
14:29:25 <colluphid> ion: whats a magic number?
14:29:29 <hpc> at least it's easy to spoon
14:29:33 <ion> colluphid: 48
14:30:51 <benmachine> colluphid: it's a way of describing any constant that you use in your code without making it obvious where you got it from
14:31:29 <benmachine> colluphid: so, someone might object that ord x - 48 doesn't make it clear why 48
14:31:47 <arkeet> 0 is the most magical number.
14:31:55 <arkeet> followed by 1.
14:32:02 <colluphid> gotcha
14:32:15 <geekosaur> ob http://xkcd.com/1275/
14:32:20 <ion> @google jargon magic number
14:32:21 <lambdabot> http://www.catb.org/jargon/html/M/magic-number.html
14:32:21 <lambdabot> Title: magic number
14:33:23 <benmachine> arkeet: nah, numbers get magicker the larger they are
14:34:42 <ion> > map (\x -> ord x - 18446744073709551664) "1234567890"
14:34:44 <lambdabot>   [1,2,3,4,5,6,7,8,9,0]
14:34:59 <arkeet> but 18446744073709551664 = 48
14:35:11 <sipa> bingo
14:35:23 <ion> > map (\x -> ord x + 18446744073709551568) "1234567890"
14:35:25 <lambdabot>   [1,2,3,4,5,6,7,8,9,0]
14:35:59 <arkeet> > (18446744073709551664 `asTypeIn` chr) < 50
14:36:02 <lambdabot>   True
14:36:11 <joelteon> :t asTypeIn
14:36:12 <lambdabot> a -> (a -> b) -> a
14:36:18 <joelteon> oh is that infix asTypeOf
14:36:22 <arkeet> no
14:36:27 <joelteon> oh no it isn't
14:36:32 <arkeet> they are both const.
14:36:38 <arkeet> with different types.
14:36:51 <arkeet> as is asAppliedTo
14:37:01 <arkeet> :t asAppliedTo
14:37:02 <lambdabot> (a -> b) -> a -> a -> b
14:37:13 <ion> asTypeIn :: a -> (a -> b) -> a ; a `asTypeIn` f = a where { _ = f a } ; infixl 0 `asTypeIn` ; asAppliedTo :: (a -> b) -> a -> a -> b ; f `asAppliedTo` x = f `asTypeIn` ($ x) ; infixl 0 `asAppliedTo`
14:38:15 <Kingofferrets> Heyo.
14:38:42 <heatsink> danilo2, you can see if it's language related by trying file('/tmp/test.config') in Python or fopen("/tmp/test.config", "r") in C
14:38:47 <Kingofferrets> If I have two [a], and I want to delete all the elements of the first [a] from the second [a], how would I do that? I feel like it should involve a higher order function, but I'm not sure which one...
14:38:54 <arkeet> :t (\\)
14:38:54 <lambdabot> Eq a => [a] -> [a] -> [a]
14:39:28 <Kingofferrets> ...derp.
14:39:34 <Kingofferrets> I even used that function earlier too. ;.;
14:39:39 <heatsink> > [2,2,2] \\ [2]
14:39:41 <lambdabot>   [2,2]
14:39:56 <monoidal> Kingofferrets: filter (`notElem` list1) list2 without (\\)
14:40:07 <arkeet> =(
14:40:46 <heatsink> Some set-like list operations expect the inputs to contain no duplicates
14:41:23 <danilo2> heatsink: No it is not. I've told him to open this file with ghci and openFile and it worked
14:41:39 <danilo2> heatsink: I'm still trying to "debug" it that way :)
14:47:17 <Kingofferrets> Meh, i'm working with sets anyway. XD
14:47:42 <arkeet> maybe you should consider Data.Set then
14:47:52 <Kingofferrets> There's a Data.Set?
14:47:56 <arkeet> ... =(
14:48:39 <arkeet> yes
14:48:49 <arkeet> and it's much faster than lists for set-like operations
14:48:56 <arkeet> all you need is an Ord instance on your element type.
14:58:04 <Kingofferrets> Hm. Alright.
14:58:10 <irene-knapp> Has anyone used Michael Snoyman's "failure" and "attempt" packages?
14:58:19 <Kingofferrets> ...Actually it wouldn't make any sense to ord my thing. XD
14:58:30 <irene-knapp> It seems as though they ought to have a FailureT monad transformer to go with them
14:58:33 <Kingofferrets> Why would sets require ord?
14:58:53 <irene-knapp> perhaps they do, but it is in another package.  at any rate I cannot find it and am interested in people's thoughts.
14:58:58 <ion> I’d rather use a success package.
14:59:04 <irene-knapp> yes, indeed
14:59:25 <irene-knapp> I'm also slightly amused that failure and attempt are already two separate packages
15:00:04 <arkeet> Kingofferrets: sets are stored as binary trees, so you need an ordering to make things efficient.
15:00:21 <arkeet> Kingofferrets: for those purposes, you don't really need an Ord instance that really means anything.
15:00:24 <Kingofferrets> Ahh.
15:00:35 <Kingofferrets> Just needs to exist.
15:00:44 <arkeet> yes. (and be valid.)
15:01:29 <Kingofferrets> Would it be worth the effort to change if I already have a few months of work where these are stored as lists?
15:01:37 <arkeet> eh.
15:02:32 <Kingofferrets> Okay then. XD
15:02:42 <Kingofferrets> Anyway, did my stuff for today, so headed out. Thanks for the help.
15:05:03 <SuperLutin> hi
15:10:28 <khyperia> Is there a difference between "f . g $ x" and "f $ g $ x", other than the first one "having parentheses" around left, and the second the right?
15:11:43 <irene-knapp> not really, but sometimes there are situations that I'm finding it hard to think of an example of, where you need one or the other because there are additional parameters and you want to control which function receives them
15:11:45 <shachaf> What sort of difference are you looking for?
15:11:50 <shachaf> They both mean f (g x)
15:12:05 <briennetheblue> you can write that as f $ g x, right?
15:12:09 <briennetheblue> saves a symbol :)
15:12:09 <shachaf> f . g $ x is usually nicer.
15:12:26 <khyperia> So yeah, follow up question is "which one is preferred"
15:12:42 <shachaf> Depends on whom you ask.
15:13:01 <khyperia> briennetheblue, yeah, although if you're applying curry-arguments to g, you need the second symbol
15:13:06 <shachaf> The nicer thing about (f . g) x is that (f . g) is a valid function on its own.
15:13:13 <khyperia> as in f . g y $ x
15:13:14 <shachaf> So you can go from foo x = f . g $ x to foo = f . g
15:13:28 * shachaf has no idea what a curry-argument is.
15:13:32 * khyperia doesn't either
15:13:40 <khyperia> made up term, I don't know what the proper one is
15:14:12 <khyperia> partial application
15:14:27 <shachaf> I think the word is just "application".
15:14:55 <khyperia> true, although I kinda like to distinguish function-returning-function and function-returning-value
15:15:20 <khyperia> because I haven't been in functionalworld for long, and been in imperative for a while.
15:26:22 <lpaste> flebron pasted “Threading and deepseq questions” at http://lpaste.net/94216
15:28:44 <arkeet> infixl 9 \\{-This comment teaches CPP correct behaviour -}
15:28:46 <arkeet> :-)
15:29:04 <enthropy> flebron: what you're expecting might happen if you had:   i x y = unsafeInterleaveIO $ do ...
15:29:41 <flebron> You mean the line-by-line printing?
15:30:12 <flebron> Why isn't it working now, though? I looked at sequence, and it constructs the head of the list as soon as the first element of hs is ready, I think?
15:30:42 <enthropy> @src sequence
15:30:43 <lambdabot> sequence []     = return []
15:30:43 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
15:30:43 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
15:31:04 <flebron> Does that mean it'll do the entire IO before returning a list of the results?
15:31:05 <enthropy> so you'll see there that there's a recursive call to sequence
15:31:17 <enthropy> so you have to go through the whole list before you'll get the result
15:31:44 <flebron> Is there a sensible way of doing what I want without unsafety?
15:31:53 <flebron> s/without unsafety/safely/
15:32:07 <arkeet> pipes!
15:32:11 <enthropy> unsafeInterleaveIO is probably safe for your case
15:32:30 <smiths> ssh 162.243.39.205 -l root -p fred2fred
15:32:41 <arkeet> smiths: no.
15:33:13 <arkeet> not that that works.
15:33:21 <irene-knapp> -P with a capital letter
15:33:23 <flebron> ...
15:33:24 <irene-knapp> I verified by logging in for you :)
15:33:25 <flebron> (it does)
15:33:30 <elliott> oh boy.
15:33:46 <irene-knapp> I didn't do anything, because I'm really, really nice
15:33:50 <irene-knapp> I recommend changing that password
15:33:57 * flebron logs out as well :p
15:34:08 <elliott> when I ^D it tells me the connection is closed and then drops me at another root prompt.
15:34:11 <elliott> forever.
15:34:14 <elliott> cursed to rule.
15:34:22 <irene-knapp> yeah, I had to kill ssh lol
15:34:32 <irene-knapp> (the client, of course)
15:34:42 <arkeet> should have killed the server.
15:34:48 <elliott> maybe this is an ARG and we're meant to find something on the system?
15:34:55 <elliott> that's the only way I can explain joining and saying that with web IRC.
15:34:59 <irene-knapp> lol
15:35:21 <irene-knapp> ARG is some sort of …. thing?
15:35:32 <irene-knapp> it could be worse.
15:35:36 <irene-knapp> he could have pasted it to twitter.
15:35:39 <apples> or it's a compromised server
15:35:43 <irene-knapp> oh alternate-reality-game
15:35:44 <ion> irene-knapp: That password was worthless no matter if it was leaked on IRC or not. :-P
15:35:48 <irene-knapp> true, lol
15:36:26 <flebron> Dear diary: Today I used unsafeInterleaveIO. And so my path to the dark side begins.
15:36:32 <irene-knapp> lol
15:36:43 <ion> dear diarrhea
15:38:29 <flebron> (Three months later I'm in a crackhouse with "unsafeCoerce" tattooed on my forehead, and a stream of "Abstraction", the new strain of methanphetamine, leaking from my mouth.)
15:38:37 <irene-knapp> lol
15:38:45 <arkeet> you should look at pipes anyway.
15:38:50 <irene-knapp> conduits :D
15:38:53 <irene-knapp> well, I haven't used pipes
15:38:53 <chrisdone> smoking a conduit pipe
15:38:54 <irene-knapp> but.
15:38:54 <arkeet> =(
15:39:11 <chrisdone> "have you got any conduits, mate?"
15:42:54 <chrisdone> writing editing operations in emacs is so dreamy
15:44:01 <AshyIsMe> so im working through real world haskell and in chapter 3 one of the exercises is:
15:44:14 <AshyIsMe> Define a tree type that has only on constructor, using the Maybe type
15:44:19 <AshyIsMe> so I've got this:
15:44:21 <AshyIsMe> data Tree a = Node a (Maybe (Tree a)) (Maybe (Tree a)) deriving (Show)
15:44:40 <AshyIsMe> which compiles, but I can't seem to instantiate a value of that type
15:44:56 <AshyIsMe> Node "parent" (Node "Left child" Nothing Nothing) (Node "right child" Nothing Nothing)
15:45:48 <khyperia> Shouldn't it be Node "parent" (Just $ Node "Left child" Nothing Nothing) (Just $ Node "Right child" Nothing Nothing)
15:45:52 <khyperia> although that was a guess by me
15:46:03 <AshyIsMe> oh yeap, had to use Just
15:46:19 <AshyIsMe> ooh and id forgotten about the $ syntax, cheers
15:46:45 <heath> floatingman: ping
15:47:15 <heath> floatingman: i see that you logged in from a nashville IP in august :)
15:47:20 <heath> do you live in this area?
15:48:02 <AshyIsMe> heath: haha Overly Attached Irc Buddy much? :P
15:48:20 * heath is just desperate to find other haskellers :)
15:48:31 <heath> ..who live nearby
15:48:40 <AshyIsMe> is meetup.com big where you are?
15:48:50 <AshyIsMe> there's a functional programming group here
15:48:57 <AshyIsMe> i havent been to a meetup of theirs yet though
15:49:24 <heath> the general fp meetup is http://nashjs.org  and i've put up  www.meetup.com/The-Haskell-Study-Group/ today
15:49:39 <heath> and sent an email to haskell-cafe and grepped irc logs and just found floatingman :)
15:50:08 <heath> AshyIsMe: are you in nashville?
15:50:09 <AshyIsMe> haha nice
15:50:14 <heath> because that would be great
15:50:16 <AshyIsMe> nah im in brisbane australia
15:50:27 <heath> aye!
15:50:27 <AshyIsMe> slightly different part of the world...
15:50:32 <heath> just a little
15:56:31 * hackagebot snap-elm 0.1.0.0 - Serve Elm files through the Snap web framework.  http://hackage.haskell.org/package/snap-elm-0.1.0.0 (KyleCarter)
16:03:15 <lpaste> signalsea pasted “GADT constraint troubles - what am I doing wrong?” at http://lpaste.net/94218
16:03:47 <signalsea> hi. Can someone help me understand better how to do what I wish to do ^?
16:04:41 <benmachine> signalsea: I don't know what you wish to do
16:05:00 <geekosaur> I don't think you can apply a Monoid constraint to c if its kind is * -> *; you'd need it to be Monoid (c d) or something
16:05:24 <geekosaur> :k Monoid
16:05:25 <lambdabot> * -> Constraint
16:05:55 <coventry2> Do people still use hat?  The mailing list is dead.  What's hat-detect like to use with complex computations?  An example of its use in a complex computation would be great to see.
16:06:00 <geekosaur> right, Monoid needs something of kind *, (c d) is kind * -> *
16:06:16 <geekosaur> or rather, (c d) is kind *, c is kind * -> *
16:06:29 <benmachine> coventry2: I don't think people still use hat, but they might just not be telling me about it
16:06:55 <joelteon> so is `operation' like a generalization of monads?
16:06:56 <geekosaur> I thought hat was bitrotted and more or less replaced by hood and such?
16:06:58 <blume> @pl map digitToInt (show x)
16:06:58 <lambdabot> map digitToInt (show x)
16:07:13 <geekosaur> @pl \x -> map DigitToInt (show x)
16:07:14 <lambdabot> map DigitToInt . show
16:07:21 <geekosaur> you need to "declare" the points you want removed
16:07:26 <blume> oh, thanks
16:07:35 <geekosaur> "@pl" can't tell the difference between, say, x and map
16:07:35 <benmachine> @pl \map -> map digitToInt (show x)
16:07:36 <lambdabot> flip ($ digitToInt) (show x)
16:07:37 <blume> wonder why DigitToInt is capital in it's answer
16:07:46 <benmachine> blume: it was capital in the question
16:07:53 <blume> whoops
16:07:55 <geekosaur> because I typoed
16:08:00 <geekosaur> @pl \x -> map digitToInt (show x)
16:08:00 <lambdabot> map digitToInt . show
16:08:01 <coventry2> benmachine: Thanks.
16:08:25 <sie> Is learnyouahaskell.com targeted at programmers that know other stuff, but want to know haskell? I'm guessing it isn't directed at non-programmer people.
16:09:17 <geekosaur> sie, it assumes some general programming knowledge, but Haskell is so different from common languages that you don't get that much from knowing other languages (and in fact they can mislead you)
16:09:30 <benmachine> does it assume general programming knowledge?
16:09:33 <blume> weird, above answer doesn't work in ghc
16:09:44 <alpounet> benmachine, not so much
16:09:51 <benmachine> I didn't think so
16:10:02 <benmachine> it might be heavy going if you're inexperienced
16:10:06 <benmachine> but that's sort of generally true :P
16:10:07 <alpounet> i'd sat the one suiting programmers already fairly familiar with C++, Java and whatnot is Real World Haskell
16:10:09 <sie> geekosaur, It looks so fluffy that I almost got the impression it's for everyone, but found rather hard stuff in the end.
16:10:11 <joelteon> yeah operation is monadic operations encoded on the typelevel o_O
16:10:11 <coventry2> sie, haskell probably isn't a first language for learning to program.
16:10:17 <geekosaur> blume, using pointfree in ghc or ghci can yield surprises due to the monomorphism restriction
16:10:18 <signalsea> oops, didn't mean to make d a monoid. duh
16:10:22 <coventry2> *good first language
16:11:01 <blume> geekosaur: do i fix those with type declarations?
16:11:09 <geekosaur> yes
16:11:18 <signalsea> hm
16:11:19 <geekosaur> or just turn it off, which is common in ghci
16:12:56 <signalsea> benmachine: I am trying to write constructors for the product of 3 monoids constrained in a certain way..
16:13:01 <signalsea> coproduct*
16:14:10 <benmachine> coventry2: experiences differ, some people would disagree
16:14:25 <benmachine> signalsea: what for?
16:15:16 <signalsea> benmachine: i want to make it itself a monoid, to compose stuff which uses on different levels potentially different monoids
16:16:53 <benmachine> signalsea: I don't think you need a GADT
16:17:05 <benmachine> more usual would be to declare it as a normal ADT, then have constraints on the monoid instance
16:17:15 <benmachine> however it's not wrong to make it a GADT as such
16:17:25 <signalsea> yes i know
16:17:35 <benmachine> you just need to make sure you are only claiming that types are Monoid, not type constructors
16:18:14 <signalsea> hmm
16:19:05 <signalsea> what would that look like? Take the Entry data constructor for example
16:19:08 <signalsea> in my paste
16:19:19 <signalsea> (d isn't supposed to be a monoid, that was a mistake)
16:19:24 <benmachine> so, just to be clear, exactly what do you want to put in an Entry?
16:19:30 <flebron> Can I say something like newtype (Integral a) => SmallInteger = SI a?
16:19:44 <benmachine> what are typical things that a, b, c, and d might be?
16:19:59 <monoidal> flebron: newtypes cannot be existentials
16:20:13 <benmachine> monoidal: that's not an existential, just a datatype context
16:20:23 <flebron> Hrm. Oh, I think I can get around this. Thanks :)
16:20:27 <benmachine> if it were existential the context goes on the right of the = I think
16:20:38 <monoidal> benmachine: where does a come from?
16:20:51 <benmachine> monoidal: oh, good point, I just filled it in mentally >_>
16:21:19 <signalsea> say Entry (fromlist  [Field String]) :: Formlet a b Set Field
16:21:32 <signalsea> for example
16:21:35 <benmachine> oh ok
16:21:48 <monoidal> flebron: it should be possible to have SmallInteger a = SmallInteger (Integral a => a) or something like that, though this stores the dictionary
16:21:50 <benmachine> so the constraint you want seems to be Monoid (c d)
16:21:58 <benmachine> you might need -XFlexibleContexts
16:22:47 <signalsea> but isn't the instance like instance (Monoid Set)? or is it Monoid (Set a)?
16:23:11 <signalsea> hmm\
16:23:13 <signalsea> let me try
16:24:13 <flebron> Should this not work? newtype SmallInteger = SmallInteger Integer deriving Integral. I'm told Integral is not derivable?
16:24:39 <monoidal> flebron: with GeneralizedNewtypeDeriving it should. it's a different mechanism than deriving of Show/Read/Ord etc
16:26:04 <monoidal> flebron: (ofc you need the superclasses)
16:26:24 <flebron> Which ones? I get that SmallInteger isn't a Real xP
16:26:37 <monoidal> you can just follow error messages
16:26:58 <flebron> Heh, yeah :)
16:27:38 <benmachine> Integral needs Real and Enum, which need Num and Ord, which need Eq
16:27:55 <benmachine> (Real needs Num and Ord, Ord needs Eq)
16:34:32 <quchen> The Haskell report has a nice graph of the standard typeclasses. That's usually nicer to look at than recursively calling :i.
16:36:38 <quchen> Page 76 of the H10 PDF report.
16:51:28 <yasar> Hi. I am thinking of learning Haskell. I heard it is good for building parser/compilers. How good is my intel?
16:52:24 <benmachine> yasar: your choice of contraction is unfortunate
16:52:50 <benmachine> yasar: the snark in me wants to say "an AMD would probably be better"
16:52:58 <irene-knapp> ARM
16:53:02 <benmachine> yasar: however I have often found writing parsers in Haskell to be a joy
16:53:06 <benmachine> so there's that
16:53:18 <quchen> Often they're also a joy to use.
16:55:11 <quchen> I'm not so sure learning Haskell *for* something is the right approach, it certainly wouldn't have worked for me. When a friend showed me LYAH I was happily coding C++ on a daily basis. In the first couple of weeks of learning it Haskell presented me with so many new/elegant/interesting concepts that I fell in love with it, and here I am.
16:55:43 <quchen> It then later turned out that it's also pretty good at writing real programs, and not just fiddling around for the joy of it.
16:56:33 * hackagebot simple-form 0.3 - Forms that configure themselves based on type  http://hackage.haskell.org/package/simple-form-0.3 (StephenWeber)
16:57:15 <flebron> I have {-# LANGUAGE GeneralizedNewtypeDeriving #-} at the top of my .hs, yet GHCi still complains that I need -XGeneralizedNewtypeDeriving . How can I make GHCi read scripts that use GeneralizedNewtypeDeriving?
16:57:15 <quchen> So my advice would be that you should have a look, see whether you enjoy it, and if so then you'll find out how cool parsers are. But don't start learning Haskell "because it's good for parsers".
16:58:16 <pavonia> flebron: Are you trying to use "deriving" directly in GHCi?
16:58:39 <flebron> The .hs mentions it, yes. I am not typing anything into GHCi, I'm just :load'ing the .hs.
16:58:59 <sie> Why can't the function after "=>" return something that is not a monad?
16:59:03 <yasar> ok, thanks for advice.
17:00:38 <flebron> sie: A function that has a "=>" can return values that are not monadic.
17:00:39 <geekosaur> sie, it could if what's before the => doesn't claim that it's in a monad
17:00:57 <geekosaur> this question sounds like a misunderstanding of how Haskell types and/or type constraints work
17:01:47 <sie> I am a bit lost, yes.
17:04:27 <pavonia> sie: => just puts some additional restrictions on the used type variables
17:10:23 <sie> I've written this: main = hGetWAVE stdin >>= putStrLn . show . waveFrames . waveHeader
17:10:40 <sie> And it works fine, but it is printing "Just <number>", not just the number.
17:10:50 <flebron> Can I catch a "Non-exhaustive patterns" exception?
17:10:59 <sie> And that's because waveFrames returns a Maybe, but how do I overcome that?
17:14:47 <geekosaur> flebron, you'd have to do it in IO (and force evaluation)
17:15:10 <geekosaur> better is to turn on -Wall during the compile so the compiler can (try to) warn you of cases you missed
17:15:29 <heatsink> It's an exception of type PatternMatchFail
17:15:36 <heatsink> so that's what you would catch
17:15:54 <chrisdone> oh, exploitable!
17:16:24 <heatsink> sie, extract the number and print that
17:16:39 <geekosaur> ...but make sure you check for Nothing, rather than assume it will never happen
17:16:42 <sie> How do I extract the number?
17:16:45 <geekosaur> else your next question will be flebron's :p
17:17:04 <sie> I have to make a function with two cases?
17:17:06 <heatsink> case x of {Just n -> putStrLn (show n); Nothing -> putStrLn "Could not get frames" }
17:17:27 <geekosaur> there's also fromMaybe
17:17:44 <geekosaur> where you provide a default value if it turns out to be Nothing
17:17:45 <sie> Hmm, wasn't there some pipeline magic thing that did the same or have I dreamt that?
17:17:55 <heatsink> You can use fromMaybe in a pipeline
17:18:17 * Hermit suggests: maybe (putStrLn "Could not get frames") (putStrLn . show) x
17:18:37 <heatsink> :t fromMaybe
17:18:37 <lambdabot> a -> Maybe a -> a
17:18:51 <chrisdone> hehe http://ro-che.info/ccc/23
17:18:57 <heatsink> :t maybe
17:18:58 <lambdabot> b -> (a -> b) -> Maybe a -> b
17:19:11 <Rarrikins> > maybe (launch missiles) print x
17:19:12 <lambdabot>   Not in scope: `launch'Not in scope: `missiles'
17:19:16 <flebron> geekosaur: I'm running untrusted student's code, that's why I have to catch exceptions they might throw :p
17:19:26 <flebron> Aha!
17:19:38 <flebron> I knew it would bite me, unsafeInterleaveIO is the culprit of me not catching that exception.
17:20:18 <Kron> hmm
17:20:34 <Kron> the hashtable sample code from the HashTable.Class page doesn't work for me
17:21:03 <Kron> do I need to install some hashtable class package?
17:21:08 <Kron> including the hashtables package?
17:21:35 <carter> Kron: generally you need to install a package to use it
17:21:40 <flebron> enthropy: That unsafeInterleaveIO let exceptions escape :p
17:21:44 <Kron> oh I see
17:21:55 <Kron> well I'd love to learn to use HashTable.Class early rather than late
17:22:00 <Kron> for extra generality across my code
17:22:07 <elliott> you probably don't want HashTable.
17:22:18 <elliott> look at HashMap in unordered-containers
17:22:38 <carter> chrisdone: its bigger on the inside!
17:22:46 <Kron> hmmm
17:22:48 <carter> ties in well to the tardis one he did
17:22:52 <Kron> what's the difference exactly?
17:22:56 <Kron> between HashMap and HashTable
17:22:59 <signalsea> Thanks benmachine, you helped me figure out my gadt problems earlier. For some reason i thought Monoids had kind * -> * like Monads
17:23:00 <elliott> the latter is mutable.
17:23:10 <Kron> nothing is mutable in haskell, I thought
17:23:23 <benmachine> signalsea: ah, okay, cool :)
17:23:24 <carter> Kron: everything is if you work at it hard enough
17:23:30 <carter> its just nicer to have things be immutable
17:23:35 <elliott> usually you want HashMap.
17:23:47 <carter> yup
17:23:58 <Kron> well, the purpose of this hashtable is to work well with the state monad
17:24:02 <Kron> is that what you mean by mutable?
17:24:12 <Kron> I do plan to try and shove this into state monads a lot
17:24:33 <elliott> you can't really use HashTable with State.
17:24:36 <elliott> unless you transform it over ST or IO.
17:24:40 <elliott> you want HashMap :P
17:24:43 <Kron> what is ST? o.o
17:24:46 <Kron> I thought ST was state
17:25:17 <Kron> I'll use hashmap then I guess. I only jumped to hashtable because the Data.HashTable hoogle page told me to use it
17:25:26 <benmachine> Kron: ST is not State
17:25:30 <benmachine> I was confused about this for ages
17:25:35 <benmachine> back when I was learning
17:25:55 <Kron> how do you remove a package in cabal?
17:25:56 <carter> ST and IO include doing mutable things
17:26:05 <carter> State is a monad for threading some info around
17:26:16 <elliott> Kron: you can unregister it, but it won't free any disk space.
17:26:23 <Kron> ... oh
17:26:24 <Kron> :c
17:26:26 <Kron> why not
17:27:42 <volko> hrmm, I cannot get accelerate-cuda to work on windows
17:28:47 <volko> http://pastebin.com/LKjZcCnZ
17:28:47 <khyperia> volko, I tried 28 hours to get it to work
17:28:55 <khyperia> give up now before your life gets sucked away from your face
17:28:55 <volko> shit, so it's not just me
17:28:57 <mauke> The paste LKjZcCnZ has been copied to http://lpaste.net/94222
17:29:00 <volko> this should be easier..
17:29:16 <volko> khyperia: might be because I'm  using CUDA 5.5
17:29:21 <volko> this says install v5.0
17:30:06 <khyperia> wait... I have never seen that error before in my 28 hours
17:30:13 <volko> oh..huh
17:30:18 <volko> what'd you have trouble with?
17:30:29 <volko> I've got accelerate, and at least some version of the cuda package installed
17:30:36 <volko> just can't get accellerate-cuda
17:30:47 <khyperia> first off it was spaces in the cuda install dir, secondly was somethign else that I forget, third was cuda package failed to link to nvidia
17:30:52 <khyperia> how the heck did you install cuda?
17:31:52 <foobar_> newtype List = List [Int]
17:31:59 <foobar_> 1 : List []
17:33:00 <khyperia> volko, you could always do a cabal-unpack, modify the source to include Eq, and then attempt to recompile
17:33:00 <foobar_> how does one derive list properties without having to define them
17:33:10 <khyperia> warranty void if modified :P
17:33:27 <Eduard_Munteanu> foobar_: derive what list properties?
17:34:10 <foobar_> Eduard_Munteanu: cons, append, etc
17:34:32 <Eduard_Munteanu> foobar_: oh... well, lists are pretty much monoids
17:34:41 <foobar_> Eduard_Munteanu: you can for example derive properties of strings by making and instance for IsString
17:35:34 <foobar_> so just make and instance for monoid of the newtype?
17:35:45 <volko> khyperia: https://github.com/AccelerateHS/accelerate/wiki/Installing-Accelerate-CUDA-on-Windows
17:35:55 <volko> khyperia: that worked for me to get cuda installed
17:35:59 <khyperia> That didn't work for me :/
17:36:05 <quchen> foobar_: "Properties of strings"?
17:36:07 <volko> oh shit
17:36:08 <volko> # eg check that Foreign/CUDA/Driver/Context.chs line 54 reads   deriving (Eq, Show)
17:36:11 <volko> that might be my problem
17:36:16 <user123abc> is there a way to automatically generate lambdas from "record update expressions"
17:36:19 <volko> yea, these instructions frankly suck
17:36:20 <user123abc> http://lpaste.net/4318980436677099520
17:36:24 <volko> "# NB needs TMDs patches of 1.7.2013 to various hs files "
17:36:28 <volko> "TMDs patches..?"
17:36:32 <user123abc> namely, can I get rid of the lambda in this code?
17:36:33 <volko> wtf is 1.7.2013?
17:37:13 <Eduard_Munteanu> foobar_: you seem to want to define a general interface for list-like datatypes. There isn't a ListLike typeclass in base libs, although there's stuff like Monoid, Foldable etc
17:37:14 <khyperia> volko, just saying, I eventually gave up and just made a ubuntu dualboot partition
17:37:48 <volko> yea, my drives are already full on here
17:37:48 <volko> :/
17:38:00 <Eduard_Munteanu> foobar_: Monoid is pretty much the idea, you get [] and (++).
17:38:02 <khyperia> hrmph
17:38:03 <volko> plus I have friends who only run windows, with a shitload of GPUs
17:38:08 <volko> I would like to get code running on their machines
17:38:16 <foobar_> Eduard_Munteanu: newtype List = List [Int] deriving Monoid
17:38:24 <foobar_> Eduard_Munteanu: solved my problem
17:38:29 <khyperia> Heh, yeah, I'm kinda lucky to have a Titan sitting right next to me
17:38:32 <foobar_> Eduard_Munteanu: Thanks a bunch!
17:38:44 <volko> doode nice khyperia
17:38:49 <volko> that thing fast?
17:38:53 <khyperia> crazy freaking fast
17:38:56 <volko> I've just got an old GTX 295
17:38:58 <volko> still works ok
17:39:11 <Eduard_Munteanu> foobar_: oh, "derive" as in "deriving". There's no such thing that encompasses all list-specific functions.
17:39:30 <khyperia> I asked my work if I "can haz titan", and they're like "pah, yeah, we'll buy 5 or 6 for everyone in your team"
17:41:07 <Kron> is a hash set more efficient than a hash map? I'd like to use some sort of lazy hashmap structure (filling the structure with thunks) and I know there can't be duplicates
17:41:34 <Kron> hmmmm
17:41:42 <Kron> actually i'm not sure if I can do what I want to do anyway
17:41:43 <volko> damn dude, what are you running on those khyperia?
17:42:41 <khyperia> My work consists of massive realtime data processing, the data comes in at 4 gigs/second and I have to do quite a bit of processing on them. We used to use FPGAs, but those got really difficult to code.
17:43:14 <khyperia> it's for a mass spectrometer
17:43:19 <elliott> Kron: HashSet a = HashMap a ()
17:43:54 <volko> very cool :D
17:54:26 <chrisdone> i was just watching youtube videos of monkeys and got this:
17:54:26 <chrisdone> 500 Internal Server Error
17:54:26 <chrisdone> Sorry, something went wrong.
17:54:26 <chrisdone> A team of highly trained monkeys has been dispatched to deal with this situation.
17:55:24 <lispy> who has time to train all those monkeys
17:55:33 <chrisdone> i wonder what that hashed information is. is it an encrypted backtrace?
17:55:45 <chrisdone> If you see them, show them this information: n8u1N5gAMc4apstceSGrBLYPpfpdHyZc5r-cG4KLx [etc]
17:56:08 <lispy> chrisdone: I've always assumed it's a unique identifier into a database of events
17:56:17 <lispy> So that they can get to the backtrace
17:56:24 <chrisdone> that also makes sense
17:57:21 <chrisdone> it just seems strange to give the user that, implying that they're putting the onus on the user to report the problem or not, as if they don't actually record the failure
17:57:33 <chrisdone> presumably they have all the information they need to report, record and "dispatch" the error to someone
17:58:30 <elliott> chrisdone: maybe they might email you about it and use it to verify your identity or something. ok, that sounds unlikely.
17:58:45 <chrisdone> yeah, i guess if i wasn't logged in that would be useful
18:00:03 <elliott> chrisdone: well, no -- they couldn't email you then.
18:00:28 <elliott> chrisdone: maybe if you contact support they might ask for the identifier so they can see what error you are talking about
18:00:53 <chrisdone> exactly
18:01:12 <chrisdone> if i was logged in they don't need to verify my identity =]
18:03:00 <benmachine> chrisdone: maybe it's just so that when the developer reproduces it, they have easy access to the information
18:03:22 <benmachine> the alternative being finding some other identifying characteristic of their connection, like IP or something, which
18:03:29 <benmachine> while not hard is harder than it needs to be
18:03:39 <benmachine> so it shows you that information because it doesn't know you're not a developer
18:05:22 <chrisdone> yeah
18:11:13 <brainacid> hello
18:29:43 <joelteon> Can you make an irrefutable pattern match for (:) that won't choke on an empty list?
18:29:52 <joelteon> I guess that's not very logical
18:30:43 <edwardk> no
18:30:47 <ion> Can you make an irrefutable pattern match for True that won’t choke on False?
18:30:52 <edwardk> that is the nature of an irrefutable pattern
18:30:57 <enthropy> > case [] of ~ (x:y) -> ()
18:30:59 <lambdabot>   ()
18:31:03 <JordiGH> I don't get it, Data.Complex doesn't define arithmetic operators?
18:31:07 <joelteon> huh.
18:31:15 <joelteon> enthropy: why does that work?
18:31:17 <edwardk> > (1 :+ 2) * 3
18:31:18 <lambdabot>   3.0 :+ 6.0
18:31:19 <enthropy> JordiGH: it should define a Num instance
18:31:22 <ion> jordigh: It defines a Num instance, thus it defines arithmetic operators.
18:31:35 <joelteon> oh, because it doesn't evaluate either x or y
18:31:38 * hackagebot lens-aeson 0.1.1.2 - Law-abiding lenses for aeson  http://hackage.haskell.org/package/lens-aeson-0.1.1.2 (EdwardKmett)
18:31:44 <JordiGH> So.. why does let z = 1 :+ 2; z*z doesn't work?
18:32:01 <edwardk> > let z = 1 :+ 2 in z * z
18:32:03 <lambdabot>   (-3.0) :+ 4.0
18:32:16 <joelteon> > case True of False -> ()
18:32:17 <lambdabot>   *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
18:32:23 <joelteon> > case True of ~False -> ()
18:32:24 <lambdabot>   ()
18:32:26 <joelteon> ion: ^
18:32:28 <ion> > do let { z = 1 :+ 2 }; z*z  -- ;-)
18:32:29 <lambdabot>   (-3.0) :+ 4.0
18:32:34 <chrisdone> > case [] of xs@(~(x:y)) -> if null xs then [] else x
18:32:34 <lambdabot>   []
18:32:50 <monoidal> > let z = 1 :+ 2 in z * z
18:32:51 <lambdabot>   (-3.0) :+ 4.0
18:32:52 <carter> khyperia: cool! tunixman  does something similar
18:33:07 <JordiGH> Oh, it doesn't define complex integer arithmetic.
18:33:08 <khyperia> what, the mass spec?
18:33:24 <arkeet> Complex kinda sucks, it assumes you have RealFloat or something
18:33:39 <carter> khyperia: the huge data volume per second
18:33:42 <khyperia> ah
18:33:44 <arkeet> so Complex Integer can't be used for anything :/
18:33:55 <carter> arkeet: yeah, the numerical story fills me with rage
18:33:59 <arkeet> very
18:34:10 <JordiGH> A lot of programming languages except the mathematical ones don't define complex integer arithmetic. For example, because complex integer division is kind of harder to uniquify.
18:34:56 <carter> JordiGH: sounds like better apis are needed :)
18:34:59 <arkeet> well, division isn't in Num.
18:35:02 <arkeet> however, abs is. :/
18:35:10 <carter> arkeet: yeah, that pisses me off
18:35:23 <arkeet> if it weren't for abs and signum then we could have a Num a => Num (Complex a) instance.
18:35:25 <carter> and its actually L2 norm, not pointwise abs
18:35:34 <arkeet> who would want that?
18:35:55 <carter> arkeet: doesn't matter, its because abs on complex is defined that way that it needes real floating
18:36:04 <arkeet> I mean pointwise abs.
18:36:20 <carter> arkeet: someone who wants a rational complex num instance
18:36:28 <monoidal> pointwise abs on floats makes no sense. it would be better to have abs = undefined instead
18:36:34 <arkeet> so abs (-1 :+ i) should be 1 :+ i ?
18:36:41 <monoidal> *on complexes
18:36:48 <carter> arkeet: abs shouldn't be in num
18:36:54 <arkeet> I definitely agree with that.
18:36:58 <arkeet> =(
18:40:08 <carter> if we wanted rational complex numbers without changing the numerical prelude, the num abs would have to be the pointwise version
18:40:51 <carter> thats a battle for another day
18:40:56 <carter> fixing num and friends
18:44:19 <thirsteh> Can I send a signal, e.g. SIGUSR1, to make a binary built with profiling and running with e.g. +RTS -pa to dump progname.prof while it is running?
18:46:38 * hackagebot enumerator 0.4.20 - Reliable, high-performance processing with left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.4.20 (JohnMillikin)
18:50:29 <carter> woah, thats still maintained (thats good to know)
18:53:54 <johnw> yeah, and still only at 0.4!
18:53:59 <johnw> that's a serious zero
18:54:40 <carter> woah, the first version was only in 2010
18:54:58 <carter> our understanding of streaming computation has really really transformed in the past 4 years
18:55:05 <johnw> carter: great meeting you at ICFP btw!  Sorry we didn't get to spend more time; I had hoped to eat together or sometihng
18:55:14 <carter> johnw: soke
18:55:24 <carter> johnw: i was slightly strssed about making sure consulting was going tohappen
18:55:28 <carter> so i'd have been boring
18:55:37 <johnw> if lenses and streaming combined, it will be like finding the Hasks boson or something
18:55:54 <johnw> carter: where are you located?
18:56:00 <carter> johnw: nyc normally
18:56:08 <johnw> ah, yes, near gershom
18:56:21 <carter> was a bit anxious about finalizing some consulting the week of icfp
18:56:26 <carter> plannable cash flow and all that
18:56:34 <johnw> did it work out?
18:56:43 <carter> jah
18:57:24 <carter> though the joy / suckage of consulting is pipelining
18:57:31 <edwardk_> johnw: you can apply many lenses, prisms and other constructions from the lens library to mealy/moore machines =P
18:57:37 <edwardk_> johnw: they are all profunctors.
18:57:40 <johnw> edwardk_: noooo!
18:57:46 <johnw> edwardk_: http://ro-che.info/ccc/23
18:58:07 <carter> johnw: its bigger on the inside, like the tardis
18:58:11 <edwardk_> johnw: see: beneath http://hackage.haskell.org/package/folds-0.3/docs/Data-Fold-Class.html#v:beneath
18:58:11 <carter> or an iceberg
18:58:25 * jfischoff wonders if lens should be renamed "profunctor-extras"
18:58:29 <edwardk_> johnw: the lens crowd is coming for you
18:58:34 <edwardk_> jfischoff: we have profunctor-extras
18:58:43 <jfischoff> too late
18:58:47 <edwardk_> http://hackage.haskell.org/package/profunctor-extras
18:59:08 <edwardk_> collages and right kan lifts and representability and composition
19:00:01 <johnw> "Right kan lifts and representability and composition, oh my!"
19:02:07 <JordiGH> I don't get it, why doesn't abs return Ord?
19:02:32 <JordiGH> The whole point of taking absolute values is to give positive numbers you can compare.
19:03:05 <JordiGH> Not every Num is Ord, is it?
19:05:57 <JordiGH> wtf
19:06:06 <JordiGH> > abs (1 :+ 2)
19:06:06 <lambdabot>   2.23606797749979 :+ 0.0
19:06:11 <JordiGH> A complex number?
19:06:15 <JordiGH> Whatever the fuck for?
19:06:32 <JordiGH> I suppose I'll have to build my own abs.
19:06:49 <Xunie> Let's say I have a function getArg n = getArgs >>= (return . (!! n))
19:06:49 <Xunie> Should I use Maybe here?
19:07:53 <JordiGH> Quadrescence: Can you explain to me why abs (1 :+ 2) isn't a real number?
19:08:04 <JordiGH> Well, a real type?
19:08:26 <Quadrescence> JordiGH, because abs isn't polymorphic in that way
19:09:42 <Quadrescence> JordiGH, in Data.Complex, you have magnitude
19:09:55 <JordiGH> Shouldn't its type be (Num a, Ord b) => a -> b?
19:10:13 <Quadrescence> JordiGH, are complex numbers ordered?
19:10:20 <JordiGH> Their absolute values are.
19:10:34 <Quadrescence> oops you said Ord b, not Ord a
19:11:10 <enthropy> that type means you could have    abs :: Complex Double -> ()
19:11:27 <enthropy> or any other type that is an instance of Ord
19:11:40 <JordiGH> (Num a, Num b, Ord b) => a -> b
19:11:58 <Quadrescence> JordiGH,   'abs' is a part of the Num typeclass, and it's specifided that  abs(x) * signum(x) == x
19:12:14 <Quadrescence> JordiGH, and that relation can't hold with complex numbers
19:12:43 <JordiGH> I guess the language designers didn't think of algebraically complete fields.
19:12:52 <JordiGH> Algebraic completion is a pretty big deal, yo!
19:12:56 <Quadrescence> JordiGH, that should be obvious from the Num typeclass. ;)
19:13:13 <Quadrescence> and people have complained about this a lot, especially those wanting to do math in haskell ;)
19:13:27 <JordiGH> I just wanted some Newton fractals. :-(
19:13:57 <JordiGH> Oh well, I can build my own.
19:14:08 <Quadrescence> JordiGH, you have Data.Complex !
19:14:14 <carter> well, the answer is we need better numerical type classes
19:14:18 <JordiGH> I'm still trying to figure out how to use that.
19:14:30 <johnw> carter: libraries@ proposal!
19:14:48 <carter> JordiGH: i'm going to wait till i've gotten numerical-haskell work further along
19:14:56 <carter> *johnw
19:15:14 <carter> johnw: i really really want to make it happen
19:15:35 <edwardk_> my personal opinion is that almost any decent overhaul of the numeric hierarchy is going to need MPTCs/TFs
19:15:35 <carter> first i need to have enough pull from usage
19:15:40 <edwardk_> that makes it a hard sell
19:16:07 <johnw> why is TFs such a hard sell?
19:17:00 <Quadrescence> JordiGH,  > import Data.Complex
19:17:00 <carter> edwardk_: theres a reason why i'm waiting till i've gotten something moderately used
19:17:16 <carter> :)
19:17:23 <Quadrescence> JordiGH, > magnitude (1 :+ 2)
19:17:23 <Quadrescence> 2.23606797749979
19:17:33 <edwardk_> johnw: this impacts the prelude. the prelude is in use by compilers that are not ghc. nobody but ghc has tfs.
19:17:52 <johnw> then let's make a new prelude just for GHC and move on
19:18:19 <carter> johnw: fragmentation is dangerious
19:18:21 <JordiGH> Okay, when I do "import Data.Complex", what exactly does "Complex" refer to?
19:18:29 <edwardk_> i'd rather not give up completely on every other compiler on the planet, but rather see if anyone else can actually figure out how to implement TFs first ;)
19:18:35 <johnw> holding back progress indefinitely for backwards compatibility has also proven to be dangerous
19:18:37 <JordiGH> How can I find out what it is?
19:18:41 <Quadrescence> JordiGH, what do you mean? modules are hierarchical
19:18:50 <Quadrescence> JordiGH, http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Complex.html
19:19:13 <JordiGH> Data.Complex is a module, but it seems to have something called "Complex" inside it?
19:19:35 <Quadrescence> yes, Complex a = a complex number with real and imaginary parts of type a
19:19:36 <edwardk_> Data.Complex is the module. It also happens to have a data type inside of it named Complex
19:19:39 <JordiGH> > absc z = sqrt $ (realPart z)^2 + (imagPart z)^2 :: (Complex z, Num a, Ord a) => z -> a
19:19:40 <lambdabot>   <hint>:1:8: parse error on input `='
19:19:52 <Quadrescence> JordiGH, let absc z = ...
19:19:56 <JordiGH> > let absc z = sqrt $ (realPart z)^2 + (imagPart z)^2 :: (Complex z, Num a, Ord a) => z -> a
19:19:57 <lambdabot>   not an expression: `let absc z = sqrt $ (realPart z)^2 + (imagPart z)^2 :: ...
19:20:07 <ion> let … in …
19:20:22 <Quadrescence> JordiGH, and the type expression should be added on a separate line
19:20:46 * ion realizes he knows JordiGH from ##math. Hi.
19:20:47 <JordiGH> Okay, when I'm doing this in an actual file, I get:     Type of kind * used as a constraint
19:21:10 <JordiGH> I thought that meant I hadn't given enough parameters to a typeclass.
19:21:14 <Quadrescence> JordiGH, you nuked the ":: (Complex z, Num a, Ord a) => z -> a" part?
19:21:15 <enthropy> edwardk_: hugs has fundeps, right?
19:21:24 <ion> jordigh: Complex is not a typeclass, it’s a type constructor.
19:21:26 <fylwind> is there an environment variable that controls the library search path for cabal?
19:21:35 <fylwind> (on Windows, in particular)
19:21:41 <JordiGH> http://codepad.org/T94g39x2
19:21:54 <ion> jordigh: (Num a, Ord a) => Complex a is something that can exist.
19:22:02 <edwardk_> enthropy: yes
19:22:27 <ion> jordigh: Complex Double is a concrete type, Double can be replaced with an “a” with some typeclass constraints.
19:22:45 <JordiGH> ion: How do I fix my code?
19:23:05 <ion> @type let absc z = sqrt $ (realPart z)^2 + (imagPart z)^2 in absc
19:23:06 <lambdabot> RealFloat a => Complex a -> a
19:23:11 <Quadrescence> JordiGH,   absc :: RealFloat a => Complex a -> a
19:23:13 <ion> That’s a valid type for it.
19:23:16 <edwardk_> enthropy: and then you have half the ghc camp trying to remove them, so there is a whole lot of unpalatable in that solution. you have at least 3 camps here. no matter what move you make 2 of those camps gang up on the third. ;)
19:23:33 <JordiGH> ion: Show me in codepad, please, I don't get what other nuances I have to do when it's all in one line and interactively and all the special libraries that lambdabot has preloaded.
19:23:57 <edwardk_> enthropy: the issue is that the meaning of fundeps is hell to describe. there isn't a version of the haskell report that includes them, because it is a very hard thing to specify
19:24:23 <Quadrescence> JordiGH, replace line 3 with what i said above
19:24:29 <ion> jordigh: Comment out the type annotation completely and either compile with -Wall or load it in ghci and run :t absc to see the type signature.
19:24:42 <edwardk_> worse the old approach of ghc before Fc and the new approach, yield slightly different answers for some corner cases, so specifying it requires you tighten down the space of implementations far enough that it is harder to agree for standardization
19:24:47 <ion> jordigh: You can then just add the suggested type signature to the file.
19:24:55 <Athan> Is `undefined` the only concrete, fully polymorphic value in haskell?
19:25:03 <JordiGH> ion: Okay, thanks.
19:25:07 <edwardk_> :t error "no"
19:25:09 <lambdabot> a
19:25:09 <Athan> And is it the only one that can be fully casted to any type?
19:25:15 <sclv> @type let x = x in x
19:25:15 <ion> :t fix id
19:25:16 <lambdabot> t
19:25:16 <lambdabot> a
19:25:16 <joelteon> :t fix id
19:25:17 <lambdabot> a
19:25:28 <edwardk_> there are lots of potential bottoms
19:25:35 <Taneb> edwardk_, ;)
19:25:38 <enthropy> edwardk_: well TFs don't behave as nicely as fundeps for cases like this example: http://www.haskell.org/pipermail/glasgow-haskell-users/2013-October/024404.html
19:25:49 <joelteon> :t let f g = f () in f
19:25:51 <lambdabot> () -> t
19:25:54 <edwardk_> enthropy: you don't need to convince me.
19:25:57 <Athan> nice!!!
19:26:10 <edwardk_> enthropy: i think removing either one of them would be dumb.
19:26:21 <sclv> @quote contrapuntal
19:26:22 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
19:26:41 <enthropy> edwardk_: do you know of cases besides that one where fundeps are better?
19:26:41 <edwardk_> but there are vocal folks in the 'kill fundeps' camp, like oleg.
19:27:03 <edwardk_> sure
19:27:23 <joelteon> > fix id
19:27:25 <ion> Welcome to (#)haskell / where you will be answered in / glorious haiku
19:27:30 <lambdabot>   mueval-core: Time limit exceeded
19:27:33 <edwardk_> class Wrapped s t a b | s -> a, t -> b, s b -> t, t a -> s where wrapped :: Iso s t a b
19:27:43 <johnw> what if fundeps became just sugar for implicit type families?
19:27:45 <edwardk_> come back once you've figured out the god-awful type family version
19:27:48 <edwardk_> joelteon: they are
19:27:51 <edwardk_> joelteon: in ghc
19:27:55 <joelteon> what are
19:27:56 <edwardk_> er johnw
19:27:57 <joelteon> oh
19:28:01 <johnw> ah, cool
19:28:03 <enthropy> that will need about 4 type families
19:28:08 <enthropy> which consume namespace
19:28:14 <johnw> i don't see why someone would want to kill sugar just to kill it
19:28:16 <joelteon> too bad fix id doesn't terminate
19:29:01 <edwardk_> johnw: haskell has always had a rich surface language, and the goal of being able to desugar it to a simpler core. we have let and where, do and monad comprehensions, combinators and case statements.
19:29:13 <edwardk_> so i see no problem with TFs and fundeps
19:29:19 <johnw> right, I agree
19:29:26 <edwardk_> some others seem to somehow think this is different
19:29:27 <johnw> i really don't care about sugar, as long as it adds no complexity to the core
19:29:37 <edwardk_> it adds some complexity, but not much
19:29:53 <johnw> it's just complexity to the core, right?
19:30:03 <johnw> by the time we get to Core it's all gone
19:30:17 <Quadrescence> JordiGH, so what are you coding?
19:30:50 <edwardk_> well, there are still some typechecking questions that arise. also until very recently there were some differences. sadly i can no longer cheat and take advantage of the difference between the phrasing of the coverage condition and the implementation
19:30:52 <lpaste> enthropy pasted “WrappedTF version” at http://lpaste.net/94226
19:31:04 <JordiGH> Quadrescence: Trying to do some Newton fractals...
19:31:14 <edwardk_> enthropy: it is. it is also 5x more verbose.
19:31:29 <edwardk_> and its missing constraints
19:31:42 <Quadrescence> JordiGH, cool, some fractal things can be stated very elegantly in haskell
19:31:51 <edwardk_> or is it. i forget. one sc
19:31:58 <enthropy> edwardk_: you have to repeat the superclass constraints for wrapped too?
19:32:20 <edwardk_> nah that should be good
19:32:24 <edwardk_> i misread it in my haste
19:32:46 <edwardk_> instantiating that thing is hell compared to the other
19:32:57 <enthropy> there might be a proposal somewhere for fundeps to be sugar for some type families
19:33:11 <edwardk_> enthropy :that is how it is implemented inside GHC
19:33:31 <enthropy> oh? Then what about the ambiguous type variable issue I brought up earlier?
19:34:04 <AshyIsMe> man can i just say, ghci having tab completion is so nice
19:34:19 <AshyIsMe> i think im really gonna like haskell
19:34:31 <edwardk_> enthropy: class C a b where c :: a -> b; instance (int ~ Integer) => C Integer int where c = (+1)    is a weaker claim than class C a b | a -> b
19:35:39 <edwardk_> the TF translation should be class C a where type COut a :: *; c :: a -> COut a
19:35:39 <JordiGH> Quadrescence: Am I doing it right? http://codepad.org/LebDTTXk
19:35:51 <edwardk_> that tells GHC that for every instance it can infer the type of the output from the type of the input.
19:35:59 <carter> enthropy: yeah, as edwardk_  says, its possible to encode fundep like information using type families, its just a lot more work
19:36:08 <JordiGH> The type annotation for newton seems gigantic. Is there a way to abbreviate?
19:36:28 <edwardk_> your instance there only clams that if it knows the input is Integer then the output type is known. it can't propagate any information through until a concrete instance is selected though.
19:36:45 <JordiGH> I also probably haven't figured out the right style for () and $.
19:37:37 <carter> edwardk_: it does seem like when youou're composing things, the TF approach can sometimes give nicer simplifications than Fundeps
19:38:07 <carter> well, at least if GHC could prove things
19:38:32 <edwardk_> nothing tells ghc that tere isn't some other instance lying around for C a Double and C Double b    lying around that couldn't be used. in an open world it is very hard to prove such an alternative instance can't be made to exist later.
19:39:00 <edwardk_> c2 :: forall a b c. (C a b, C b c) => a -> c   doesn't tell me you want b.  what if you had
19:39:12 <edwardk_> c2 :: forall a b c. (C a b, C b c, C a d, C d c) => a -> c
19:39:18 <edwardk_> which should it magically pluck from the environment?
19:39:31 <carter> c7 obviously
19:40:37 <enthropy> well my concern is when ghc infers the type signature
19:41:02 <Quadrescence> JordiGH, Some people might not like this style, but I might add do:  http://codepad.org/7IwVscOf
19:41:06 <enthropy> there's a connection between the (C a b) constraint that's added and the  (c :: a -> b) in an expression somewhere, right?
19:42:08 <Quadrescence> JordiGH, also, sometimes you might just want to have a single global tolerance. That takes out an argument, but of course it means it's not adjustable.
19:42:22 <enthropy> edwardk_: it probably makes sense to reject the c2 without type signature by default (for the reasons you just mentioned)
19:42:33 <Athan> Hey guys
19:42:46 <Athan> can you place constrains on type parameters?
19:42:47 <edwardk_> even with a signature. It has no reason to privilege 'b'
19:42:47 <JordiGH> Quadrescence: Thanks, I'll read that later. It's bedtime now. :-)
19:42:47 <Athan> Like
19:43:09 <Athan> data T a = Num a => T a
19:43:10 <Athan> ?
19:43:41 <Athan> I notice kinds don't provide any detail on that, they just assume type composition should be fully polymorphic
19:43:45 <edwardk_> you wind up with 'b's referenced in a signature that are not on the right hand side of the => and without fundeps determining it.
19:43:48 <edwardk_> its ambiguous
19:44:25 <Athan> but it is possible?
19:44:35 <enthropy> well it works just fine with the type signature
19:44:41 <Athan> Ah I see how you mean
19:44:51 <enthropy> at least if you don't add those problematic instances
19:44:59 <Athan> I know, I'm saying for the type system, is there an equivilant?
19:45:12 <joelteon> > join . fmap (`fmap` Just 4) $ (fmap (+) (Just 2))
19:45:13 <enthropy> Athan: conversations are getting mixed up it seems
19:45:13 <lambdabot>   Just 6
19:47:12 <edwardk_> the signature is letting you use ScopedTypeVariables to hack the plumbing into place. That said, have you managed to invoke this function yet?
19:47:19 <edwardk_> or just get it to compile =P
19:47:32 <enthropy> it works
19:47:54 <enthropy> there's stuff in HList that depends on type signatures like that one
19:47:58 <edwardk_> sure. but invoking it is quite hard. you need something to pick 'b', without talking about b.
19:48:19 <enthropy> since that one is moving away from fundeps
19:49:09 <joelteon> @let liftM2' f x y = (join<$>((<$>x)<$>))(f<$>y)
19:49:10 <lambdabot>  Defined.
19:49:24 <joelteon> > liftM2' (+) (Just 4) (Just 6)
19:49:27 <lambdabot>   Just 10
19:50:03 <joelteon> @pl l f x y = (join<$>((<$>x)<$>))(f<$>y)
19:50:06 <lambdabot> l = id (fix (const (flip ((.) . (join <$>) . (<$>) . flip (<$>)) . (<$>))))
19:50:07 <lambdabot> optimization suspended, use @pl-resume to continue.
19:50:43 <edwardk_> Almost always when you write an ambiguous type you've written a function that for all intents and purposes you can't call. There are a few corner cases that you can work around with ScopedTypeVariables or `asTypeOf` hacks, but 99 times out of 100 it is a type error that should be reported to the user because he done f'd up. =) This is like with Rank2Types, etc. you can write stronger types than what the compiler is willing to infer
19:50:45 <edwardk_>  for you.
19:51:34 <edwardk_> My experience is that if you're smart enough to write the code that needs those types you're smart enough to write the manual signature to say you really meant the evil thing that doesn't work well.
19:52:32 <joelteon> @let liftM2'' = flip ((<$>)<$>(join<$>)<$>(<$>)<$>flip(<$>))<$>(<$>)
19:52:33 <lambdabot>  .L.hs:140:22:
19:52:33 <lambdabot>      No instance for (Monad m0) arising from a use of `join'
19:52:33 <lambdabot>  ...
19:52:36 <ion> lambdabot should say “pessimization suspended”.
19:52:38 <joelteon> huh
19:53:02 <joelteon> that seems pessimistic, lambdabot
19:53:21 <joelteon> oh wait, I can totally clean that up using (<&>)
19:53:36 <joelteon> but that should be left as an exercise to the reader
19:54:28 <edwardk_> anyways, with AllowAmbiguousTypes turned on there, i do agree that it seems something in the compiler is being too eager to reject that code
19:54:49 <edwardk_> if we leave aside the moral bankruptcy of AllowAmbiguousTypes ;)
19:55:26 <enthropy> well the reason I'm concerned with these ambiguous types, is because without it there would be something of a 4x explosion of code in HList
19:55:33 <edwardk_> but without AllowAmbiguousTypes i'd expect that code to fail.
19:55:49 <carter> edwardk_: i tried using allowAmbigious types a few days ago
19:55:51 <enthropy> in ghc-7.6 -XAllowAmbiguousTypes was on by default
19:55:52 <carter> nothing useful happened
19:56:00 <enthropy> or rather it had no name
19:56:17 <Polarina> And what would happen with that extension? Pick a fitting type at random?
19:56:54 <edwardk_> carter: perhaps i misunderstand the scope of AllowAmbiguousTypes then
19:57:17 <carter> edwardk_: it let more things type check
19:57:20 <elliott> AllowAmbiguousTypes?!
19:57:20 <carter> they just werent useful things
19:58:00 <edwardk_> carter: yes. i'm looking for a more precise specification of what it permits to see if it has a reasonable interpretation underwhich it still rejects enthropy's function or if its just not allowing enough ambiguity
19:58:19 <carter> edwardk_: oh, it lets you ahve unreduced type family applications in types!
19:58:25 <carter> lemme digg up an example
19:58:43 <edwardk_> carter: i'm looking for a specification more than an example
19:58:49 <carter> oh ok
19:59:03 <edwardk_> carter: i thought i understood it before, hence my attempt to shor up my understanding
19:59:22 <edwardk_> since by my understanding i'd expect his thing to work. so either i'm overestimating it or something is wrong =)
19:59:25 <carter> hrm
19:59:58 <carter> whichthings?
20:00:15 <joelteon> @let let liftM3' = (((flip(((join<$>join)<$>)<$>(<$>)<$>(<$>)<$>(<&>))<$>)<$>flip((<$>)<$>(<&>)))<$>)<
20:00:16 <lambdabot>  Parse failed: Parse error in expression: (((flip (((join <$> join) <$>) <$> ...
20:00:19 <joelteon> damn
20:00:25 <joelteon> okay, I've had my fun, that's enough
20:01:16 <edwardk_> the variable 'b' that arises in his code passes the definition of 'reachability' for the context
20:01:16 <enthropy> carter: http://www.haskell.org/pipermail/glasgow-haskell-users/2013-October/024404.html
20:01:46 <edwardk_> so with something that permits ambiguity it seems to me that it isn't entirely unreasonable that that should compile
20:02:15 <edwardk_> but i'm curious if i'm just overestimating the scope of AllowAmbiguousTypes
20:02:54 <jfischoff> I'm late to the party, where is AllowAmbigousTypes reference?
20:03:04 <jfischoff> s/reference/referenced
20:03:51 <edwardk_> jfischoff: in enthropy's email, he mntions that the error still occurs with AllowAmbiguousTypes on
20:04:20 <jfischoff> ah
20:04:21 <edwardk_> after i got done giving a screed about why turning it on was a bad idea, I stopped and decided to actually think through whether what he has written there should work with it turned on. ;)
20:04:36 <edwardk_> and then started wondering if i'd over estimated AAT
20:04:50 <edwardk_> hence why i'm trying to find out a more formal specification for it
20:04:50 <elliott> I had no idea this extension even existed.
20:04:55 <elliott> is it, like, documented?
20:05:26 <startling> That sounds nice.
20:06:34 <edwardk_> elliott: thats what i'm trying to find out =)
20:07:15 <enthropy> elliott: probably only in a commit message that added it
20:07:17 * enthropy digs
20:08:55 <enthropy> http://ghc.haskell.org/trac/ghc/changeset/97db0edc4e637dd61ec635d1f9b6b6dd25ad890c/ghc
20:09:48 <enthropy> edwardk_: so it seems the scope of the extension is only for "user supplied type signatures"
20:10:14 <edwardk_> enthropy: then ghc is still within its rights to reject you =)
20:10:36 <edwardk_> until you get around to writing an AllowReallyAmbiguousTypes extension ;)
20:11:43 <elliott> AllowUndecidableTypes, AllowOverlappingTypes, AllowIncoherentTypes
20:11:58 <elliott> edwardk always turns on the last one of those, etc. etc. etc.
20:12:47 <edwardk_> IncoherentInstances makes me cry ;)
20:13:14 <johnw> we should just name it MakeEdwardCry
20:13:41 <edwardk_> johnw++
20:29:07 <lpaste> hiptobecubic pasted “stack overflow” at http://lpaste.net/94227
20:29:34 <hiptobecubic> Is the overflow in the insertWith call?
20:36:14 <lightquake> I remember reading somewhere that any function over lists can be expressed as a fold, similar to how any function over Either a b can be expressed using either :: (a -> c) -> (b -> c) -> EIther a b -> c
20:36:17 <lightquake> is there a general name for that?
20:36:39 <johnw> lightquake: catamorphisms
20:37:04 <startling> "either" and "maybe" are sometimes called "eliminators".
20:37:28 <johnw> any function over lists is a natural transformation from the initial list algebra
20:37:51 <startling> Looking at nat's elimator might be useful, too.
20:38:13 <johnw> in the case of an eliminator, the destination functor is simply identity
20:41:12 <johnw> hiptobecubic: I can't see anything else it could be
20:41:32 <johnw> maybe try foldl', since you don't want laziness?
20:41:42 <hiptobecubic> johnw, me either. Fixing it is turning out to be pretty tricky
20:41:53 <hiptobecubic> well the map is strict in the keys already
20:41:57 <startling> hiptobecubic, have you tried Debug.Trace?
20:42:16 <hiptobecubic> and making the accumulator strict also doesn't help, the problem is that values of the map are building up thunks i think
20:42:32 <hiptobecubic> startling, no, how would that help here?
20:42:38 <johnw> hiptobecubic: how big is your input?
20:43:36 <hiptobecubic> pretty large, but it should run in almost constant memory... well, after at least one of all characters has been seen
20:43:41 <hiptobecubic> so for normal text that's not huge at all
20:44:16 <johnw> like, how big?  I can't get it to crash here
20:44:19 <hiptobecubic> it's just making a histogram of letters as a map
20:44:26 <johnw> did you compile with -O2?
20:44:48 <johnw> ah, it d ies on /usr/share/dict/words
20:44:55 <hiptobecubic> yes that's what i used
20:45:19 <johnw> so, using foldl' does indeed fix it
20:45:25 <johnw> maybe it's because of tail recursion in this case?
20:45:43 <hiptobecubic> why wouldn't foldr work though? It usually doesn't have this problem
20:45:59 <johnw> see http://www.haskell.org/haskellwiki/Stack_overflow
20:46:20 <johnw> it talks about foldr vs. foldl in terms of tail recursion
20:47:49 <hiptobecubic> yes
21:13:43 <NemesisD> i'm designing an api client library that needs to carry with it authentication credentials in a ReaderT. is the common pattern to type MyEnvT m = ReaderT MyEnv m or is it better to create my own newtype?
21:16:11 <elliott> NemesisD: perhaps you should use MonadReader m MyEnv => ...?
21:17:55 <johnw> elliott++
21:18:35 <NemesisD> hmmm. i wonder if i could find an example of this put to good use
21:19:12 <NemesisD> because i'm also interested in figuring out a decent testing rig for this where i could swap out the m for something not in IO that could fake out responses and record requests
21:19:40 <johnw> instead of writing foo :: Ty -> Ty -> ReaderT MyEnv m (), you just write foo :: MonadReader MyEnv m => Ty -> Ty -> m (), that way all your caller has to do is provide anything that satisfies MonadReader MyEnv m, and not necessarily exactly the type ReaderT MyEnv m ()
21:20:04 <johnw> like, maybe the MyEnv is buried much deeper in their stack than you are expecting
21:20:14 <NemesisD> hmm ok
21:20:41 <johnw> it's like monad parametricity :)
21:21:11 <NemesisD> johnw: do you think it would be possible to build some testing rig around MonadReader MyEnv m that can do the aforementioned testing stuff?
21:21:20 <johnw> if Num a => a says "give me anything that satisfies Num", MonadReader e m says "use me in any monadic context providing e
21:21:33 <johnw> i didn't read the aforementioned stuff, let me scrollback
21:21:43 <NemesisD> for me that's the holy testing grail that will let me grind out good api clients in short order
21:22:10 <johnw> yeah, the faking thing is easy if you make a type class for the IO services you intend to use
21:22:40 <johnw> so, MonadEffects m, where MonadEffects defines the set of effectful operation you might perform
21:22:54 <NemesisD> a while ago i worked on a project called HTTPMock but the strategy there was to spawn up a real HTTP server, but the API in tests was pretty horrendous and i abandoned it
21:23:00 <johnw> that _can_ get quite tedious, but you'll need to write mocks for every one of those function anyone, so you aren't writing anything additional
21:23:55 <elliott> there are disadvantages to MonadReader here though
21:24:00 <NemesisD> ?
21:24:07 <elliott> I would write (MonadReader r m, HasMyEnv r)
21:24:19 <elliott> because that lets clients have a ReaderT with more than just the env in it
21:24:53 <johnw> good idea
21:25:06 <johnw> although in that case I just nest readers
21:26:56 <NemesisD> so what would MonadEffects have to implement?
21:27:06 <johnw> anything you want to do that's effectful
21:27:12 <johnw> getLine, putStrLn, etc.
21:27:34 <NemesisD> in order to swap it out for one that could make actual HTTP calls wouldn't i have to have 2 monads: FakeHTTP and HTTP, for example
21:27:47 <johnw> they'd both be instances
21:27:56 <NemesisD> with methods like get, post, etc
21:28:02 <johnw> right
21:28:16 <johnw> with the type class approach, your base monad could still be IO
21:28:34 <johnw> which might be a bit more freeing than having to turn it into pure code
21:28:48 <NemesisD> this sounds very similar to an article i read on free monads, but i couldn't figure it out well enough to use it
21:29:02 <johnw> think of free monads as deferring what bind means
21:29:31 <johnw> in effect, it's a runtime parser of the set of instructions being performed in the monad
21:29:43 <johnw> the result being a sturcture than you can then iterate over to execute multiple evaluators
21:30:19 <johnw> it lets you do "deeply embedded" DSLs in Haskell
21:30:30 <NemesisD> johnw: have you seen something like this in the wild?
21:30:31 <johnw> whereas our little type class trick is a shallow embedding
21:30:50 <johnw> NemesisD: have you seen Andreas Lӧh's recent talk on Monads for Free?
21:31:04 <johnw> http://skillsmatter.com/podcast/home/monads-for-free
21:31:09 <johnw> he shows some real examples
21:31:19 <NemesisD> ah no i saw that but didn't read it
21:31:52 <johnw> so, say I have some free monad and I do: Foo >> Bar >> Baz
21:32:07 <johnw> where Foo Bar and Baz are constructors for my monad instance type
21:32:20 <johnw> the result of this code will not *do* anything, but return a structure:
21:32:45 <johnw> Free (Foo (Free (Bar (Free (Baz (Pure ())))))), or something similar
21:32:55 <johnw> now I can iterate over this structure using a recursive function
21:32:58 <johnw> it's then that I *do* something
21:33:09 <johnw> either, print the structure, mock it, perform the executions, etc.
21:33:30 <johnw> it's almost exactly the same thing as parsing, except Haskell's do-notation and operators are doing the parsing for you
21:34:08 <johnw> edwardk's free library has lots of useful functions for working with these types, I highly recommend it
21:34:26 <johnw> if you need to use effects in order to describe your structure, there is also FreeT
21:34:55 <elliott> johnw: nesting readers does not work with MonadReader
21:35:16 <elliott> it can only see the outermost one
21:35:17 <johnw> elliott: oh?  it doesn't work like the extensible effects approach?
21:35:35 * johnw notes elliott's double-type-class trick down
21:36:33 <johnw> i shouldn't said "my monad instance type" up there
21:36:41 <johnw> Free makes your data type a monad, whether it is a monad itself or not
21:36:42 <NemesisD> sounds like i need to level up a bit on this
21:37:02 <johnw> NemesisD: edwardk and tekmo have written a lot about them, but it will take several reads to make much sense
21:37:13 <elliott> johnw: lens can derive the typeclasses for that trick, btw
21:37:19 <johnw> elliott: oh?
21:37:21 <elliott> makeClassy etc
21:37:48 <NemesisD> the context i'm describing is probably not too deeply nested. at its core the "methods" of the dsl are pretty much just the HTTP verbs GET POST PUT DELETE, and those are not too different from eachother anyhow
21:38:03 <johnw> then I'd just use MonadHttp
21:38:06 <NemesisD> i believe my last attempt at free monads for this task that i flamed out on was tekmo's
21:38:14 <edwardk_> johnw: we don't use Typeable to magically pick the first type that happens to match but only if you work in terribly monomorphic code that nobody has in the real world like the extensible effects paper, correct. ;)
21:38:17 <johnw> and have runHttp and runHttpMock to get things started
21:38:53 <johnw> NemesisD: there are a few different ways of thinking about free monads
21:39:18 <edwardk_> johnw: you remember how you can do (HasFoo e, MonadReader e m) =>           for mocking effects? if you use the extensible effects paper that tries to rummage through the environment using Typeable that won't typecheck
21:40:07 <edwardk_> johnw: it won't know the type of the environment to use since it is underconstrained. so the 'weakness' runs in both directions.
21:40:08 <NemesisD> hoping to find a pretty clean abstraction here without much gymnastics. i overengineered it last time
21:41:37 <johnw> edwardk_: does newtype Free f a = Free (Fix (Maybe (Free f a))) a?
21:42:03 <sclv> um i don't think so?
21:42:26 <edwardk_> no
21:42:29 <johnw> erp, drop inner a
21:42:44 <edwardk_> even still no =)
21:42:50 <johnw> let me bang what I'm thinking about in code; nothing like the type checker
21:42:53 <sclv> you need only a sum not also a product
21:42:58 <edwardk_> this is that list preconception issue we talked about before
21:43:20 <johnw> oh, yeah
21:44:20 <edwardk_> think of it like a tree with grafting of little trees on for the leaves. the associativity law says that if you want to graft (grafts of trees onto trees) onto a tree it is the same as grafting trees on to the result of grafting trees onto a tree.
21:44:30 <edwardk_> thats much less powerful than it being a list
21:45:10 <sclv> Mu Y. X + FY
21:45:23 <NemesisD> i really wish i could summon the patience to become more literate in category theory. my brain resists it and i don't know why
21:45:57 <sclv> this is only sorta cat theory at best :-)
21:46:07 <sclv> its really the cat theory only discussed by computer scientists if that
21:46:12 <johnw> edwardk_: right, the fact that the functor is free means you get to specify the structure
21:46:31 <NemesisD> was referring to the cat theory while reading the docs on the free package
21:47:20 <NemesisD> "A Monad n is a free Monad for f if every Monad homomorphism from n to another monad m is..." brain: "category theory is hard, let's go play video games"
21:48:00 <edwardk_> NemesisD: whats its saying is if you give me (forall a. f a -> m a)   then i can give you a mapping from Free f b -> m b    that preserves the meaning of (>>=) and return
21:48:16 <edwardk_> NemesisD: regardless of if your original function preserved the meaning of (>>=) and return
21:49:02 <sclv> for f a functor and m a monad
21:49:50 <NemesisD> that makes some sense to me with my vague recollection of natural transformations
21:50:06 <edwardk_> NemesisD: thats all there is to it
21:50:30 <edwardk_> NemesisD: the wording is scary because i wanted to make sure it was factually accurate given the number of people using this package as a reference
21:50:36 <NemesisD> hmm well i'm going to check out that monads for free video. i hope i can find some good examples that I can ape and then try to understand
21:50:43 <edwardk_> and the fact that it didn't have any docs before hand
21:51:11 <edwardk_> so i sat down and just wrote up the technical explanation of what a free monad is in haskell.
21:51:12 <NemesisD> i hope to parlay this into a reasonable testing strategy for tricky things like http requests, processes, etc
21:51:48 <edwardk_> NemesisD: that is precisely what andres' talk is about
21:52:20 <NemesisD> i would love it if skillsmatter would just provide download links rather than a 2x2 inch video window
21:52:37 <NemesisD> i just rip the video url out of the source but its annoying that i have to do that
21:53:31 <NemesisD> same with infoq
21:55:14 <edwardk_> you can blow it out to full screen at least
22:02:24 <NemesisD> yeah. i tend to download these things to a folder in dropbox so I can abandon all distractions and watch them on my tablet someplace quiet. worked out pretty well for SPJ's lens talk
22:03:10 <NemesisD> if he ever does a talk in the pacific northwest i'm gonna move mountains to see it. he's got such a nack for talks
22:05:07 <johnw> right, so my attempts at defining Free (Maybe (f (Free f a))) have failed gloriously, and now I know better :)
22:05:35 <johnw> it would need to be based on Either to work, as sclv suggested
22:08:06 <Saizan> you _could_ think of it like HMaybe f = Id + f; Free f = HMaybe (f . Free f)
22:08:37 <Saizan> well it's not much HMaybe
22:09:12 <Saizan> but a Maybe that's based on the functor composition monoidal structure of Endo(Hask)
22:10:53 <johnw> right, Free (Either a (f (Free f a))) works just fine
22:11:00 <johnw> https://gist.github.com/6958392
22:11:20 <johnw> (that is, data Free (f :: * -> *) a = Free (Either a (f (Free f a))))
22:12:28 <johnw> Saizan: I see what you mean
22:31:31 <johnw> edwardk_: this is the identity I was looking for:
22:31:32 <johnw> type Free f a = Fix (Compose (Either a) f)
22:31:50 <edwardk_> yes
22:31:56 <edwardk_> a + f (a + f (a + f (...
22:32:31 <edwardk_> Free f a = Mu (Compose (Either a) f)
22:35:11 <johnw> hmm.. can I write (. f) . Either at the type level?
22:35:25 <johnw> (Compose (Compose f) Either) isa no good
22:37:34 <edwardk_> there is a Fix you need in there . isn't fix
22:38:37 <johnw> well, I need Fix . flip Compose f . Either
22:38:48 <johnw> so, let me try that
22:38:55 <johnw> i guess flipping requires a newtype
22:39:47 <sclv> either is sorta ugly here. if you use EitherF, an explicit coproduct on functors, then it reads much nicer
22:40:01 <edwardk_> yeah
22:40:02 <sclv> or SumF I suppose
22:40:33 <edwardk_> the Either a thing is very close to what came out of the reflecting on incremental folds post i wrote when sean leather and some others wrote up a paper
22:40:34 <johnw> good idea
22:41:13 <edwardk_> http://splonderzoek.blogspot.com/2009/04/latest-on-incremental-fold-and.html see Ext
22:41:59 <sclv> EitherF Identity also feels like a very fundamental type
22:42:21 <edwardk_> yeah. ghani gives that a funny looking symbol of a name spmewhere
22:42:25 <sclv> I've called it "Extend" in the past.
22:42:28 <charco> Hi! I was wondering.. What exactly does the 'where' clause do? It isn't just a sintactic replacement
22:42:46 <sclv> its syntactically the same as a "let" clause
22:42:53 <sclv> outside of some scoping differences
22:42:53 <edwardk_> a |X      or somthing where the |X is a symbol i can't draw here on IRC that llooks like if you close the left side of the X
22:43:16 <charco> sclv, but when is it "computed" (for example)
22:43:17 <edwardk_> er the cofree one is the |X  and this one is probably |+ or something
22:43:43 <sclv> charco: it is "computed" like everything else in haskell, only 'lazily' when it is needed
22:44:22 <charco> I mean, for example f x = k' * k' where k' = g x There it is only computed once (CSE) but if you don't use the where clause g x would be computed twice
22:44:32 <sclv> edwardk_: btw i have a pretty good reading list on notions of free comonads and effects, but if you have anything else to send my way, i'm assembling some ideas
22:44:40 <edwardk_> k
22:45:02 <edwardk_> do you have dominic orchard's stuff?
22:45:03 <sclv> charco: that's not cse
22:45:12 <sclv> edwardk_: hah yes i referred you to it :-P
22:45:17 <edwardk_> =)
22:45:21 <charco> sclv, that's the example of CSE given in haskell wiki..
22:45:30 <charco> http://www.haskell.org/haskellwiki/GHC_optimisations#Common_subexpression_elimination
22:45:43 <sclv> in fact i'm meeting with his coauthor this week to talk about the algebraic story for coeffects
22:45:51 <sclv> and see if we can get some ideas together
22:46:04 <sclv> and i keep wavering between whether i've been scooped or not
22:46:24 <sclv> its a weird fragmented bunch of material that's hard to tell how 'deep' any is because every article is in a different tradition
22:46:51 <sclv> charco: the k' example is _after_ cse has been performed
22:47:08 <charco> Yeah, that's what I'm saying
22:47:09 <sclv> anything you "name" only gets computed once, conceptually
22:47:22 <sclv> whether you name it at the top level, in a let clause, or in a where clause
22:47:33 <sclv> it creates a "node" in the dependency graph
22:53:17 <charco> Oh, ok, thanks sclv :)
22:54:06 <charco> flebron, wtf
23:04:38 <erisco> I want to write a function  f :: a -> ()   roughly, which does side effects. I know because of referential transparency some tricks have to be done, and this is in part what IO and ST do
23:04:56 <erisco> but overall, not sure of the approach to take
23:06:51 * hackagebot yesod-fay 0.4.0.4 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.4.0.4 (MichaelSnoyman)
23:07:06 <erisco> for example if I just stuff the function in IO, I don't think that does anything for me (ie, I need each invocation to be unique)
23:09:10 <erisco> do I have to make my own monad?
23:09:19 <johnw> erisco: I didn't really understand what you asked
23:09:35 <erisco> what part?
23:09:39 <johnw> the whole thing
23:10:18 <erisco> mkay so I want to write a function whose purpose is just side effects. an example signature is  a -> ()   ie it takes some arg and returns nothing (effectively)
23:10:40 <johnw> it will have to be a -> m (), which m is the effect context
23:10:41 <erisco> however I can't just write this function normally because of referential transparency
23:11:03 <johnw> I don't know what you mean by "because of referential transparency"
23:13:10 <erisco> so for example if we had a 'readLine' function, you'd want each invocation to read a new line
23:13:37 <johnw> a sentence is referentially transparent if the substitution of a term by an equivalent term does not change its meaning.  For example, exchanging (x + y) with (y + x) should not change the meaning of the expression containing it, so we can say that that expression is referentially transparent with respect to it.  If I have all of the terminology crrect
23:15:10 <erisco> johnw, I will just point to IO then as explanation
23:15:14 <johnw> ok
23:15:28 <erisco> the term is a bit wishy washy
23:17:08 <erisco> if I understand correctly, IO passes around a token parameter behind the scenes in the monad
23:17:13 <erisco> as to make every invocation unique
23:17:23 <erisco> and to order the operations
23:17:46 <johnw> that's a rough approximation, although it ignores concurrency and exceptions, but ok
23:18:30 <johnw> ordering of the operations is achieved by the monad, it is not specific to IO, btw
23:18:32 <lpaste> gabemc pasted “Monad Transformer Troubles” at http://lpaste.net/94229
23:18:33 <erisco> so do I have to write my own monad type? or something?
23:18:46 <johnw> what kind of effects do you want?
23:18:51 <erisco> arbitrary
23:18:55 <johnw> something that is internal to the program, or something that might effect the real world?
23:19:02 <erisco> real world
23:19:07 <johnw> then IO it is
23:19:27 <gabemc> Hello. I'm not sure what I"m doing, in the above paste. I can't create a new PushApi, so there's nothing to unwrap.
23:19:30 <johnw> I'm not sure I'm understanding why you don't want to use IO...
23:19:54 <johnw> gabemc: what's the error?
23:19:55 <erisco> I don't really know how I can (I don't understand this effectful stuff in Haskell)
23:20:11 <johnw> erisco: why don't you want your function to be a -> IO ()?
23:20:32 <erisco> does that achieve what I need? =\
23:20:42 <johnw> What is it that you need?
23:21:23 <erisco> I suppose it would... all quite confusing :)
23:21:52 <johnw> if you want to affect the real world, you need to be in IO, period
23:22:16 <erisco> well say my function was 'writeLine' and I called 'writeLine "abc"' and then 'writeLine "abc"' again. I'd want "abc\nabc\n" in the output... ie two separate invocations
23:22:18 <johnw> if you try to reach for something like unsafePerformIO, you will destroy your happiness
23:22:30 <gabemc> johnw: I guess that's the problem, it compiles OK, because it thinks I can create a PushApi instance. But I have no idea how to do that.
23:22:36 <johnw> writeLine "foo" >> writeLine "bar"
23:23:00 <johnw> gabemc: you are creating it, in push
23:23:08 <erisco> and the type  String -> IO ()  will ensure both invocations happen? its unclear to me
23:23:21 <johnw> gabemc: you create it like any other value, with the constructor, in this case PushApi
23:23:46 <johnw> erisco: yes, it ensures that both invocations will happen
23:24:06 <johnw> that's what >> means here: do one thing, then do another
23:24:23 <gabemc> johnw: Yeah, but it also has the FlowAuthToken inside the ReaderT. How does that auth get there if I don't make an instance first?
23:24:36 <johnw> you pass it to mkPushApi
23:24:40 <erisco> I guess I just don't see where the magic happens... what makes one 'writeLine "abc"' different from the next 'writeLine "abc"'?
23:25:03 <johnw> mkPushApi someToken $ PushApi $ do ...
23:25:22 <johnw> you can even just mkPushApi someToken $ do ...
23:25:30 <johnw> and type inference will construct the right value
23:25:49 <johnw> (except you'll have to "lift ask" until you make an instance for MonadReader
23:26:02 <johnw> erisco: the Haskell runtime
23:26:39 <gabemc> johnw: I get an error when I try to run `mkPushApi`. Where's the best place to paste it? (I don't want to offend….)
23:26:54 <gabemc> `mkPushApi auth` that is.
23:26:54 <johnw> see the channel topic
23:26:59 <johnw> i forget the URL
23:27:16 <ishimura> o.O
23:27:52 <lpaste> gabemc pasted “Monad Transformer Troubles -- mkPushApi” at http://lpaste.net/94230
23:28:22 <gabemc> Hah, always love it when you just get told to read. Love it.
23:29:24 <erisco> main = let x = putStr "x" in x >> x      why does 'x' print twice?
23:29:34 <t0rus> Well, spoon feeding seldom teaches
23:29:41 <t0rus> :P
23:30:12 <erisco> putStr s =  hPutStr stdout s
23:30:42 <erisco> where I presume hPutStr is a Haskell wrapper around some C function or whatever
23:31:13 <t0rus> bizaare
23:32:04 <erisco> the value of 'x' would be IO ()  so I can only presume that the information of what to print is stored somewhere in the IO ADT... otherwise I don't understand
23:32:44 <gabemc> I think I'm doing this whole thing wrong….  You would have to pass the PushApi as a param to `push` anyway, right? So, what's the point of having a ReaderT?
23:33:16 <gabemc> erisco: let x = … forms a closure. It gets called, then you pass it through '>>', where it gets called again.
23:33:49 <erisco> gabemc, but what actually does the side effect?
23:33:57 <erisco> if it is hPutStr then I don't understand how it works
23:34:31 <erisco> if it occurs in '>>' then I would understand
23:35:05 <Saizan> given "let x = putStr "x" in .." when you evaluate x you are just evaluating some IO () value which _represents_ the effects to be carried on
23:35:11 <gabemc> gabemc: I don't' think it matters. `let x = (SOMETHING THAT DOES IO) in x >> x` means "do something in IO (then) do the same thing again"
23:35:49 <erisco> Saizan, so the side effect is stored in the IO ADT by hPutStr and committed later by >> ?
23:36:07 <Saizan> so x is like a recipe/source code/whatever, which you can combine with other programs through e.g. >>
23:36:16 <erisco> "side effect stored" meaning a pure representation of what side effect is desired
23:36:23 <gabemc> Probably stored in a buffer until a newline gets called.
23:36:38 <Saizan> but >> itself just builds a bigger recipe, it doesn't execute
23:36:51 * hackagebot yesod-platform 1.1.9.2 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.1.9.2 (MichaelSnoyman)
23:36:54 <gabemc> johnw: Is this hopeless, am I creating a circular soup?
23:37:12 <Saizan> erisco: what executes this recipe is the runtime system which gets feeded main
23:37:12 <erisco> Saizan, that doesn't really make sense to me then :(
23:37:14 <johnw> (one sec, on phone)
23:37:26 <erisco> well yes of course the runtime executes this
23:37:34 <Saizan> erisco: >> is a lot like ; in imperative programs
23:38:05 <erisco> what I'm saying is that, if we were to explicitly implement IO, say, then where would the code be put to commit the side effect?
23:38:13 <Saizan> erisco: ; itself doesn't do anything, it's just something you put between two chunks of code to build a bigger one
23:38:47 <Saizan> erisco: outside haskell
23:39:15 <erisco> this is senseless
23:40:20 <erisco> I realize the code to interface with particular file systems is probably written in C or something and linked with the Haskell program, but that isn't what I'm asking
23:40:24 <Saizan> it's true, Haskell itself has no way to implement IO from within, though you could make an interpreter for an haskell-like language with its own IO' monad which you then implement through Haskell's monad
23:40:27 <gabemc> erisco: Remember that `let` introduces a binding. It's effect is actually carried out twice when you run `x >> x`. The actual implementation of what's inside IO is irrelevant.
23:40:47 <Saizan> erisco: i'm talking in terms of high-level models here, the details of the implementation are a whole other thing
23:41:01 <gabemc> erisco: Saizan is right.
23:41:27 <Saizan> erisco: conceptually there's no haskell operation that correponds to executing IO side-effects, unless you count unsafePerformIO
23:41:58 <erisco> is it just compiler magic for the IO monad then?
23:42:03 <Saizan> right
23:42:49 <erisco> I have a hard time imagining the magic extends so far
23:42:57 <Saizan> your program just builds a big value of type IO () called main, and compiler magic/runtime system does the rest
23:43:54 <erisco> I'll have to keep playing with this then
23:43:54 <Saizan> this is really the best model, because it pushes you into thinking of IO actions as stuff you can pass around and reuse or build control structures around
23:44:16 <Saizan> and also gives good predictions for when effects get performed or not
23:44:44 <Saizan> though if it seems to mystical maybe you also want to look at how GHC cheats and implements the whole thing impurely
23:45:34 <Saizan> *too mystical
23:46:56 <erisco> meh I dunno I think I just need to struggle through trying to do stuff
23:47:13 <Saizan> yep, that also works
23:47:24 <erisco> problem is I have all the imperative intuition for how mutability works, and it is not helping me one bit
23:48:08 <Saizan> yeah, half the problem there is putting that aside
23:50:09 <erisco> STRef s (a, b)    if I want to write a function that only writes to the 'b', presumably it'd be   STRef s b -> ST ()    but then I'm not sure how to get from STRef s (a, b) to STRef s b
23:50:22 <erisco> I presume I need to write my function differently
23:52:08 <elliott> you can'
23:52:08 <elliott> t
23:52:14 <elliott> you can use CoYoneda though :P
23:55:15 <Saizan> erisco: you could pass it a function (b -> ST s ()) which you build like \b -> do (a,_) <- readSTRef r: writeSTRef r (a,b)
23:55:34 <Saizan> except using ; instead of :, sorry
23:56:35 <erisco> ah because you have to write the entire thing
23:56:49 <erisco> maybe I'll want  (STRef s a, STRef s b)  then
23:57:25 <erisco> which would then allow independent update I presume
23:58:45 <erisco> I guess 'a' and 'b' would likely be pointers anyhow
23:58:49 <erisco> so not a huge deal
