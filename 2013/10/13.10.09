00:11:43 * hackagebot authoring 0.1.0.0 - A library for writing papers  http://hackage.haskell.org/package/authoring-0.1.0.0 (TakayukiMuranushi)
00:11:43 * hackagebot citation-resolve 0.4.2 - convert document IDs such as DOI, ISBN, arXiv ID to bibliographic reference.  http://hackage.haskell.org/package/citation-resolve-0.4.2 (TakayukiMuranushi)
00:32:13 <Fly_Boy> I have a silly question I want to pass a list to a function that evaluates that list for an empty list If it finds it empty I want it to return [0] and not [] any thoughts
00:33:17 <Fly_Boy> should I hold my breath lol
00:33:48 <mr-> I'm having trouble understanding the question.. are you looking for f [] = [0] ? ;-)
00:34:40 <Fly_Boy> I would normaly think so but I need it to out put the full list if it is not empty
00:35:19 <mr-> then add f xs = xs as the second case
00:35:27 <Fly_Boy> its late and I guess my head is not in this this evening sorry
00:35:41 <mr-> But that will be a function f :: Num a => [a] -> [a]
00:35:59 <Fly_Boy> thank you I thought I tried this but i waill give it another go
00:36:31 <Fly_Boy> not :: [a] -> [a]
00:36:47 <Fly_Boy> hmm
00:36:54 <Cale> No, it'll be f :: Num a => [b] -> [a]
00:37:25 <yesthisisuser> why?
00:37:32 <mr-> Cale: no
00:37:33 <Fly_Boy> I will try again thank you very much
00:37:44 <mr-> Cale: Not with f xs = xs
00:37:45 <yesthisisuser> i think it's [a] -> [a]
00:37:51 <Cale> oh, right, of course
00:38:00 <mr-> yesthisisuser: not with f [] = [0] ;-)
00:38:03 <Cale> Wasn't reading correctly :)
00:38:57 <FreeFull> Num a => [a] -> [a]
00:39:15 <mr-> Yeah :-)
00:41:34 <wagle> ok, who ran fix mailman-day?
00:42:03 <Fly_Boy> I get a parse error on input `=>' in both cases
00:42:12 <c_wraith> wagle: hah. I was just complaining about that in -blah
00:42:14 <Fly_Boy> zeroMe  a => [a] -> [a]
00:42:14 <Fly_Boy> zeroMe [] = [0]
00:42:14 <Fly_Boy> zeroMe xs = xs
00:42:46 <Fly_Boy> I must be brain dead
00:43:07 <Cale> Fly_Boy: What are you doing with this function?
00:43:09 <Fly_Boy> -> ?
00:43:13 <c_wraith> You need a :: between the identifier and its signature
00:43:21 <c_wraith> zeroMe :: a => ...
00:43:26 <Cale> also, not a =>
00:43:29 <Cale> Num a =>
00:43:34 <c_wraith> err, yes.  that too
00:43:40 <Fly_Boy> trying to stop another function from producing a empty list
00:43:59 <zorzar> is there a way to define constants with a type in haskell?
00:44:10 <haasn> :t toListOf $ folded `failing` to (const 0)
00:44:13 <Fly_Boy> i tryed Num a =>
00:44:21 <Cale> zorzar: The same way that you define anything else? Or... what do you mean?
00:44:23 <c_wraith> Fly_Boy: did you try putting :: before the type?
00:44:30 <haasn> :t Control.Lens.toListOf $ Control.Lens.folded `Control.Lens.failing` Control.Lens.to (const 0) -- ._.
00:44:31 <c_wraith> Fly_Boy: you know, as the grammar requires
00:44:37 <haasn> oh, no lambdabot
00:44:53 <haasn> well it's (Num a, Foldable f) => f a -> [a]
00:45:01 <Fly_Boy> lmao
00:45:05 <Fly_Boy> nope
00:45:07 <zorzar> Cale: ok, so there's no difference between a variable and a constant?
00:45:10 <Fly_Boy> duh
00:45:16 <Cale> zorzar: myPi :: Double; myPi = 3.141592653589793
00:45:20 <haasn> zorzar: all variables are constant
00:45:33 <zorzar> Cale: haasn: thanks
00:45:36 <Cale> Well, a constant has a wider scope, presumably?
00:45:40 <zammy> wow PI inside haskell code
00:45:46 <zammy> you are fantastic
00:45:52 <Cale> ?
00:46:16 <Cale> Could also write  myPi = 4 * atan 1
00:46:32 <zammy> well I love you anyway
00:46:34 <zomg> myPi = 3
00:46:36 <zomg> err
00:46:38 <Fly_Boy> thank tou thank you thank you
00:46:52 <Fly_Boy> it was Num a =>
00:46:57 <Cale> zorzar: Variables like the parameters of functions do vary between applications of the function
00:47:13 <Cale> For example, if you write f x = x^2, and then map f [1,2,3,4,5]
00:47:20 <Cale> Then x takes on different values
00:47:38 <Cale> But it doesn't change as long as it remains in scope during any one of those function applications.
00:47:47 <haasn> (My argument goes that they're different ‘x’s, but they're more or less of equal semantic value)
00:47:53 <haasn> the two viewpoints, I mean
00:48:11 <Cale> x is the name for whatever the argument of f is
00:48:31 <Cale> It's in that sense that it varies
00:48:35 <Fly_Boy> you guys are great  I cant thank you enough I know it was a no brainer but I just pulled my head out of an accounting midterm that took 3 hours and I have to do haskell  so ya brain is fried
00:49:33 <zorzar> Cale: thanks
00:49:35 <zammy> I would make the same... you know what... fried brain... that's freaky but I think great at same time
00:50:46 <Fly_Boy> N E way  you all have a great night
00:53:30 <yesthisisuser> I have created this module that translates a url string to a Url data type : http://codepad.org/JG4igvh7
00:54:11 <yesthisisuser> with the different parts of the url, like scheme, port, query parameters etc
00:54:55 <yesthisisuser> but i am not sure what is the best way to parse the url.. right now i use an ugly regex to tokenize the url
00:55:50 <yesthisisuser> also.. is it better to use ByteString or Data.Text?
01:01:47 <shiona_> yesthisisuser: why do you limit the schemas?
01:02:33 <shiona_> oh, of course
01:03:45 <yesthisisuser> well i just want to make sure it's valid.. i think i would only need http and https in this case but
01:05:52 <shiona_> What I was considering was to allow uris for gopher, file, mailto etc. but of course things like port, path, anchor or query would make no sense in these cases
01:06:05 <shiona_> sorry, fragment, not anchor
01:07:22 <yesthisisuser> hmm.. yes i didn't think about that.. the regex would need to be a lot smarter then
01:07:47 <yesthisisuser> in any case, i don't really like the regex approach
01:12:34 <yesthisisuser> i guess ftp shouldn't allow a "fragment" either. i don't think ftp://abc:def@hello#x is valid
01:27:27 <john__> hello?
01:27:35 <alpounet> meh, lambdabot's gone
01:28:05 <shachaf> elliott: ☝
01:34:08 <faio> !list
01:34:08 <monochrom> faio: http://lpaste.net
01:42:44 <donri> monochrom: !list means they're looking for file sharing bots
01:42:52 <donri> no clue what they're doing on freenode :P
01:45:05 <seanparsons> edwardk: SPJ is blowing minds with lens.
01:46:41 <zomg> donri: there are clients specifically written for leeching files, it's probably users on those not knowing what network to pick so they pick the big ones =)
01:55:11 <edwardk> seanparsons: oh?
02:10:52 <mbrock> what, you guys don't share your cool codez over DCC? lame!
02:31:48 <chrisdone> edwardk: what happens in #haskell-lens, stays in #haskell-lens, eh?
02:37:24 <shachaf> Yes, #haskell-lens is unlogged.
02:49:36 <tac> More than that. Edwardk actually goes an reverses entropy when he discovers a third party has logged the channel, erasing unauthorized recordings of the past.
03:16:02 <chrisdone> i can't hear myself think in here!
03:20:23 <fizruk> quiet night of quiet stars...
03:27:28 <hpc> i just received three months worth of -cafe list reminders
03:27:39 <hpc> is someone doing something with mailman?
03:32:07 * hackagebot bibtex 0.1.0.3 - Parse, format and processing BibTeX files  http://hackage.haskell.org/package/bibtex-0.1.0.3 (HenningThielemann)
03:33:24 <no-n> hi
03:33:26 <chrisdone> hpc:  me too
03:36:46 <examon> Hi, I'm new to haskell and kinda stuck. I have this piece of code:
03:36:46 <examon> const (.) map
03:36:46 <examon> I know what does: const . map, and also: (.) const map but I cannot grasp (.) used in infix... can someone explain me what does function like
03:36:46 <examon> f x y z = (const (.) map) x z y, do in inside?
03:37:14 <Twey> examon: That's not infix.  The function (.) is passed as an argument to const.
03:37:29 <examon> Twey: thanks
03:37:35 <notdan> so 'const (.) g = (.)'
03:37:36 <examon> Twey: ok I got that
03:38:15 <Twey> (const (.) map) x y z = const (.) map x y z = (.) x y z = (x . y) z = x (y z)
03:38:42 <examon> notdan: yeah Thank you! It totally makes sense!
03:39:50 <examon> Isn't (const (.)) right operator section?
03:39:56 <Twey> examon: No
03:40:03 <examon> why
03:40:09 <Twey> Because there's no infix operator
03:40:24 <Twey> The bracketing converts (.) to a prefix function
03:41:04 <examon> Twey: aha, Ok, Now I understand what's going on
03:41:14 <Twey> An alternative name for (.) (with a more general type) is fmap; (const (.)) is the same as (const fmap) (where the former would typecheck)
03:41:33 <examon> Twey: I don't even know what is fmap right now
03:41:50 <examon> Twey: but (const .) is operator section right?
03:41:51 <notdan> That's not an alternative name for function composition?
03:41:59 <Twey> For the purpose of the example, it's a function without an operator name that behaves the same as (.) :þ
03:42:07 <notdan> It's only synonymous to (.) in case of a specific functor
03:43:05 <Twey> :t (.)
03:43:14 <Twey> Oh, λb died.
03:43:34 <mauke> preflex: seen lambdabot
03:43:34 <preflex>  lambdabot was last seen on #haskell 7 hours, 36 minutes and 11 seconds ago, saying:   *Exception: Maybe.fromJust: Nothing
03:43:35 <t7> again...
03:43:37 <Twey> notdan: That's not the point of the explanation, though :þ
03:43:47 <t7> should have written it in something other than haskell
03:43:58 <mauke> preflex: seen elliott
03:43:58 <preflex>  elliott was last seen on #haskell-lens 8 hours, 51 minutes and 6 seconds ago, saying: hm, have people modelled typestate in haskell?
03:51:13 <examon>  I have one more question
03:51:14 <examon> I got this function in point free:  f = (.) (.) const map
03:51:14 <examon> I want to get it into point wise, I got this: f x y = ((.) . const) map x y
03:51:14 <examon> but I got stuck there, can anyone give me some hints how to progress?
03:51:49 <mauke> the first thing I'd do is inline the first (.)
03:52:09 <examon> mauke: what does it mean "inline" something?
03:52:11 <mauke> f = (\f g x -> f (g x)) (.) const map
03:52:12 <Twey> examon: (.) is easier to expand if you write it infix, usually
03:52:20 <mauke> substitute the definition
03:52:52 <mauke> f = (.) (const map)  -- apply
03:53:11 <mauke> f = (\f g x -> f (g x)) (const map)  -- inline
03:53:30 <mauke> f = \g x -> const map (g x)  -- apply
03:53:58 <mauke> f = \g x -> (\x _ -> x) map (g x)  -- inline
03:54:20 <mauke> f = \g x -> map  -- apply
03:54:24 <mauke> ... did I do that right?
03:54:34 <int-e> yes, I think so.
03:54:39 * int-e got the same thing.
03:54:52 <int-e> @type (.) (.) const map
03:55:01 <int-e> oh. that's (a -> b) -> a -> (a1 -> b1) -> [a1] -> [b1]
03:55:25 <int-e> so indeed the first two arguments are ignored.
03:55:37 <examon> int-e: yes
03:59:22 <examon> mauke: that inline stuff (definition substitution) is kinda cool
03:59:59 <int-e> I wonder, can we call it partial evaluation?
04:00:24 <Twey> Heh
04:00:41 <Twey> There used to be a service that would do that for you; don't remember what it was called
04:01:12 <int-e> lambdabot: @unpl
04:01:18 <int-e> but that would require ...
04:02:24 <Twey> No, I meant step-wise evaluation of an expression
04:02:50 <alpounet> Twey, it used to live at http://bm380.user.srcf.net/cgi-bin/stepeval.cgi I think, but the repo is there: https://github.com/benmachine/stepeval -- benmachine is the author
04:02:59 <Twey> Aha, thanks
04:03:46 <int-e> @unpl (.) (.) const map
04:03:46 <lambdacat> (\ e f -> map)
04:03:52 <examon> mauke: anyway, is there a method how can I get point wise without substituting the definition? It looks kinda advanced and I'm searching for something more simpler so I can understand it
04:03:54 <mauke> steppenvalf
04:04:22 <int-e> (lambdacat is mine; the usual suspects should be able to tell it to @leave or even @quit)
04:04:33 <mauke> examon: ... if that is "kinda advanced", what else is left?
04:05:02 <mauke> I mean, it doesn't get much simpler than to take "x = y" and substitute y for x
04:06:03 <examon> mauke: well I didn't need substitution for other functions to get into point wise so I'm wondering if I can get this one into point wise without it as well
04:12:49 <yesthisisuser> is (f . g) in WHNF? it is not, is it?
04:14:09 <yesthisisuser> its outermost part is a function application (.) f g
04:14:13 <yesthisisuser> or?
04:16:03 <int-e> it depends on the semantics; if you regard (.) as a combinator with arity three then (.) f g is a whnf. If you regard is as a lambda abstraction (.) = \f g x -> f (g x) then you can evaluate (.) f g to \x -> f (g x).
04:16:52 <yesthisisuser> hmm
04:17:40 <yesthisisuser> int-e: thanks
04:18:48 <yesthisisuser> i had not considered the latter form
04:21:31 <yesthisisuser> also, something like (+1) . (+1).. conceptually "evaluates" to (+2).. so would it make sense to say that it is in whnf?
04:22:11 <chrisdone> http://ircbrowse.net/pdfs/haskell
04:22:12 <lambdacat> Title: PDFs linked in #haskell
04:23:01 <alpounet> chrisdone, that's super awesome!
04:23:56 <supki_> chrisdone: last page does not look OK
04:24:07 <donri> chrisdone: make it extract the urls and present them with a frequency count / sorting :)
04:24:31 <chrisdone> supki_: i think the pagination is just being dense, there are no results on the last page
04:24:39 <chrisdone> donri: hehe =)
04:25:05 * chrisdone makes latest ones appear first
04:25:52 <mauke> it doesn't mirror the pdfs though, does it?
04:26:03 <safinaskar-i> let's consider typed lambda caluclus, which includes lambda construction (or, alternatively, ski combinators), and, maybe, 0, 1 and +. and nothing else. without build-in recursion. then, we cannot express fixed-point combinator, recursion and loops in such terms, so this language is not Turing-complete, right? but untyped lambda calculus (and untyped ski calculus) can express fixed-pont combinator and it is turing-complete, right?
04:26:11 <chrisdone> mauke: no o_o
04:26:22 <mauke> also, why does it stop in 2013-03?
04:26:59 <safinaskar-i> MoHaX: привет, монах
04:27:03 <hpc> safinaskar-i: correct; you need some other built-in construct to make typed lambda calculus turing complete
04:27:24 <hpc> such as putting your fingers in your ears and saying "lalala the fixed point combinator exists"
04:27:30 <tac> The point of typing originally was to eliminate turing completeness, in a certain sense
04:27:31 <int-e> yesthisisuser: Same answer. Fortunately, implementations have a lot of freedom when drawing the line between (head-)reducible terms and whnfs, because we do not expect to be able to look inside functions; (.) f g and \x -> f (g x) are indistinguishable if all you can do with such a value is apply it to another value.
04:27:31 <MoHaX> safinaskar-i здравствуй
04:27:41 <tac> Turing completeness implies that your language is inconsistent as a logic
04:27:42 <hpc> or in the case of haskell, recursive let-in
04:29:28 <safinaskar-i> tac: why?
04:30:33 <int-e> > 2.0^53+1+1 == 2.0^53+2
04:30:35 <lambdacat>   False
04:30:47 <tac> Because it does. It's a deep fact about logic and programming languages.
04:31:28 <tac> If you can write an evaluator for the untyped lambda calculus, you have to solve the halting problem
04:31:41 <tac> Since that's impossible, any language that can do it must be inconsistent
04:33:14 <safinaskar-i> > 2.0^53 + (1 + 1) == 2.0^53 + 2
04:33:16 <lambdacat>   True
04:33:23 <safinaskar-i> > 2.0^53 + 1 + 1 == 2.0^53 + 2
04:33:24 <lambdacat>   False
04:33:32 <tac> To put it slightly more accurately, if you claim to have a function which takes programs written in the untyped lambda calculus and returns their normal form, then you are a liar.
04:33:46 <tac> (because not every such program has a normal form)
04:34:05 <tac> Yet, in Haskell, you can write a function LambdaCalcProgram -> NormalForm just fine
04:40:52 <adnap> Awwwww yeah: http://skillsmatter.com/podcast/scala/lenses-compositional-data-access-and-manipulation/te-8510
04:40:54 <lambdacat> Title: Skills Matter : Haskell eXchange 2013: Simon Peyton Jones on, http://tinyurl.com/q7s4y8e
04:41:08 <chrisdone> woot!
04:42:12 <alpounet> won, already online?
04:42:16 <alpounet> wow*
04:42:16 <frihd_> already online? great =)
04:43:16 <tac> oh nice
04:43:16 <chrisdone> fast turnaround!
04:43:18 <safinaskar-i> tac: i can write evaluator for the untyped lambda calculus. yes, in some cases it will never stop. but evaluator exists, and it is consistent. and it cannot solve its own halting problem. what you mean by inconsistency?
04:44:06 <tac> safinaskar-i: A program running but never stopping is not a good thing in logic. It is basically how you spell "liar's paradox" under the Curry-Howard isomorphism
04:44:07 <yesthisisuser> lenses seems like a "hot topic" right now
04:44:31 <tac> yesthisisuser: I think that's because only 2 people in the whole damn community know how to use them >__>
04:44:34 <quicksilver> safinaskar-i: an evaluator that doesn't always stop isn't what tac meant by 'an evaluator'
04:44:39 <tac> Hopefully that number is greater after today
04:44:49 <yesthisisuser> so where do we start?
04:45:07 <chrisdone> tac: they don't seem that hard to use to me
04:45:14 <quicksilver> safinaskar-i: it's kind of a technical point about terminology that, but that's why tac tried to explain in different words afterwards.
04:45:20 <tac> chrisdone: Sorry, I guess the number was closer to 3 :P
04:46:28 <tac> safinaskar-i: Having a program that loops basically breaks your language viewed as a logic
04:46:53 <tac> that can be seen if you interpret the program `fix id` in Haskell
04:46:55 <tac> @type fix id
04:46:56 <lambdacat> a
04:47:11 <tac> `fix id` has type "forall a. a"
04:47:45 <tac> meaning it is can be cast to an element of any type you want
04:47:52 <tac> meaning there are no uninhabited (empty) types
04:48:01 <tac> Empty types correspond to false propositions under Curry-Howard
04:48:11 <tac> If there are no empty types, there are no false statements.... every statement is true
04:48:46 <tac> (How can that possibly be? Because if all else fails, `fix id` can be used to prove your proposition/inhabit your type)
04:52:32 <bearclaw> why do I need to liftM fromIntegral twice to apply to  a  IO Int ?
04:52:50 <bearclaw> @let test = return :: (Int -> IO Int)
04:52:50 <lambdacat>  Defined.
04:53:00 <bearclaw> :t  (liftM (liftM fromIntegral)) test
04:53:00 <lambdacat> Num r => Int -> IO r
04:53:14 <bearclaw> :t fromIntegral <$> test
04:53:15 <lambdacat>     Could not deduce (Integral (IO Int))
04:53:15 <lambdacat>       arising from a use of `fromIntegral'
04:53:15 <lambdacat>     from the context (Num b)
04:53:32 <kuribas> tac: fix id is _|_
04:53:40 <sojka> > fix id
04:53:40 <lambdacat>   No instance for (GHC.Show.Show a0)
04:53:40 <lambdacat>    arising from a use of `M8064858193460...
04:53:54 <sojka> but ghci loops
04:54:27 <adnap> I wonder what "skills matter"'s policy is on copying videos
04:54:34 <safinaskar-i> thanks, i understand
04:55:31 <quchen> kuribas: And `forall a. a` is ⊥
04:55:36 <fizruk> :t fmap liftM fromIntegral . test
04:55:36 <lambdacat>     Could not deduce (Integral (IO Int))
04:55:36 <lambdacat>       arising from a use of `fromIntegral'
04:55:36 <lambdacat>     from the context (Monad m, Num (a1 -> r))
04:55:43 <gspr> tac: I gotta say: What you just explained really helped clear up something for me (although I was just idly staring at IRC for other reasons…)
04:55:45 <tac> Yes, kuribas. It is.
04:55:57 <gspr> tac: So thanks :)
04:55:58 <kuribas> tac: So it is like a False proposition.
04:55:58 <tac> np gspr :)
04:56:01 <safinaskar-i> > let myfix f = f (myfix f) in myfix id
04:56:02 <lambdacat>   No instance for (GHC.Show.Show a0)
04:56:02 <lambdacat>    arising from a use of `M6673776736301...
04:56:08 <tac> kuribas: no, it's not
04:56:08 <fizruk> :t liftM fromIntegral . test
04:56:08 <lambdacat> Num r => Int -> IO r
04:56:09 <kuribas> quchen: yes, right.
04:56:19 <bearclaw> http://www.haskell.org/hoogle/?hoogle=ForeignPtr : broken links
04:56:20 <lambdacat> Title: ForeignPtr - Hoogle
04:56:21 <tac> kuribas: false propositions are uninhabited (under Curry-Howard)
04:56:27 <fizruk> bearclaw: test is function, that's because?
04:56:30 <tac> kuribas: but in haskell, every type is inhabited. If by nothing else, by fix id
04:56:49 <bearclaw> ah, first lift to mean map-over-function, second lift to map over io
04:57:17 <fizruk> bearclaw: yes, first is for ((->) Int)
04:58:02 <bearclaw> :t (liftM fromIntegral).test
04:58:04 <lambdacat> Num r => Int -> IO r
04:58:08 <bearclaw> ok I get it
04:58:17 <kuribas> tac: What about a -> a -> b
04:58:49 <kuribas> @djinn a -> a -> b
04:58:50 <lambdacat> -- f cannot be realized.
04:59:05 <quchen> :t fix id `asTypeOf` (undefined :: a -> a -> b)
04:59:06 <lambdacat> a -> a -> b
04:59:14 <quchen> Cannot be realized, yet there it is. :-)
04:59:28 <prophile> that's a frankly terrifying expression
04:59:31 <quchen> (It has no non-bottom implementation)
04:59:46 <tac> kuribas: @djinn operates on a very small decidable and consistent subset of haskell.
05:00:26 <tac> Djinn is another story. It is consistent. But you might notice, it's not Turing compelte :)
05:01:16 <kuribas> Then _|_ includes False, but it is then only value in haskell that does so?
05:01:46 <tac> _|_ doesn't really "include" anything
05:01:50 <kuribas> I mean the false proposition, not the false constructor.
05:02:11 <tac> _|_ isn't actually a real thing in haskell, to be strict about it. It's something that we talk about in the metatheory of haskell.
05:02:45 <tac> fix id is a term. It's a proof of its type. And it has every type
05:02:57 <tac> You can declare the empty type in Haskell (with some very mild extension)
05:03:06 <tac> But the empty type isn't truly empty
05:03:27 <kuribas> What's the empty type?
05:04:13 <quchen> "data Void"
05:04:16 <quchen> without a right hand side
05:04:21 <quchen> It's like () if you take () away :-)
05:04:23 <tac> kuribas: it's the type with exactly 0 constructors
05:04:43 <kuribas> ah
05:04:53 <tac> kuribas: to declare a function on Empty, you simply need an empty case statement. There is one function defined on it, and it is vacuous.
05:05:06 <tac> That function corresponds to the principle of explosion
05:05:17 <tac> (that anything follows from an absurdity)
05:05:31 <quchen> :t absurd
05:05:31 <lambdacat> Not in scope: `absurd'
05:05:36 <quchen> Hm. No Void in Lambdabot?
05:06:09 <safinaskar-i> tac: kuribas is right. (fix id) is undefined. and it is like false proposition in that curry-somebody :) isomorphism. (fix id) has any type. "any type" is "false" in that isomorfism. (fix id) give us possibility to get an object of any type. so, under the isomorfism, we can prove any proposition. this is equivalent to prove "false". read this: http://en.wikibooks.org/wiki/Haskell/Denotational_semantics , especially "bottom" section
05:06:10 <lambdacat> Title: Haskell/Denotational semantics - Wikibooks, open books for an open world
05:07:03 <tac> safinaskar-i: kuribas is a bit too confused on terminology to be right.
05:07:30 <kuribas> I am not a computer scientist...
05:07:57 <tac> It's ok. I'm not calling you dumb or anything. I'm just trying to explain how this works, because I think it's cool.
05:09:46 <quchen> kuribas: I found Thompson a nice read as an introduction into the matter, "Type theory and functional programming"
05:12:02 <kuribas> tac: But safinaskar-i says (fix id) is like the false proposition, and you say it is not.  That's confusing.
05:12:47 <chrisdone> haha, damn that's surprisingly fast: http://ircbrowse.net/pdfs/haskell/unique
05:12:47 <lambdacat> Title: Unique PDFs linked in #haskell
05:13:06 <lpaste> chrisdone pasted “PDFs” at http://lpaste.net/94070
05:13:12 <chrisdone> considering i used that naive algo ^
05:14:01 <safinaskar-i> tac: yes, "false propositions are uninhabited", as you said. but "fix id" is false proposition, so false proposition is inhibited. so, this proves haskell inconsistency
05:14:16 <quchen> chrisdone: Now weight each occurrence with some power law of the time it was posted and bam, we have HaskellIrcRedditNews
05:14:49 <chrisdone> quchen: hehe
05:14:58 <chrisdone> oh, i should make them clickable. duh
05:15:55 <chrisdone> there we go
05:16:48 <merijn> safinaskar-i: It does, yes
05:16:59 <merijn> safinaskar-i: If haskell wasn't inconsistent, it wouldn't be Turing complete
05:17:53 <merijn> safinaskar-i: If you're interested in the logic side of type systems, you might want to check out Coq/Agda which are not inconsistent (and as a result not Turing complete, but Turing completeness is overrated)
05:18:29 <tac> Turing completeness was cool back in the 40s.
05:18:39 <quchen> merijn: Is there even a word for a programming language that is useful yet not Turing complete?
05:18:56 <tac> It's 70 years later. We have better ideas of what is cool now :)
05:19:01 <t7> quchen: not-useful
05:19:13 <quchen> t7: Agda/Coq would like to have a word with you
05:19:40 <t7> write some non trivial program for me in agda or coq
05:19:44 <t7> you have 2 weeks
05:20:04 <quchen> Not sure how many logical fallacies lead to this statement
05:20:37 <k00mi> I suspect you have differing definitions of "useful"
05:21:17 <t7> agda and coq are useful as theorem provers, i would argue that they are not useful programming languages
05:22:42 <kuribas> I wonder how many algorithms wouldn't be possible in a non turing complete language.
05:22:51 <tac> I fucking love SPJ
05:22:53 <kuribas> Commonly used algorithms.
05:23:00 <t7> infinity
05:23:01 <tac> kuribas: algorithms are always total
05:23:11 <tac> in the conventional sense of the word, at least
05:23:19 <tac> (in other words, all of them)
05:28:26 <thoughtpolice> kuribas: i think the more interesting question is - what classes of programs can we not express in a language that is not turing complete? perhaps the class of programs we *can* express is good enough anyway.
05:29:08 <tac> One big misconception people have is that if you don't have turing completeness, you can't write something like a webserver, which can (in theory) run forever
05:29:11 <chrisdone> donri: http://ircbrowse.net/pdfs/haskell/unique
05:29:13 <lambdacat> Title: Unique PDFs linked in #haskell
05:29:27 <merijn> t7: That's not related to their non-Turing-completeness, though
05:29:29 <tac> However, there are ways around that problem, and you can write a web server or an OS just fine, in theory.
05:29:32 <merijn> quchen: total language
05:30:16 <donri> chrisdone: awesome!
05:30:19 <t7> "perhaps the class of programs we *can* express is good enough anyway" lol it is not
05:30:20 <danilo2> Hello! could somebody help me with a small issue? I can use onException (Control.Exception) to make some actions after using "error" or "fail" function. The rpoblem is it does not catch errors thrown by "raise" (like from function fromJust). Why this is so incosistent?
05:30:28 <merijn> kuribas: Well, the thing is, you can have (like in Agda) a special monad for non-termination :)
05:30:31 <t7> well not for the layperson
05:30:38 * thoughtpolice ignores t7 for his nonsense
05:30:38 <safinaskar-i> :t undefined :: a -> a -> b
05:30:39 <lambdacat> a -> a -> b
05:30:48 <merijn> kuribas: Which means you can still write Turing complete programs in non-Turing complete languages
05:31:15 <safinaskar-i> :t fix id :: a -> a -> b
05:31:16 <lambdacat> a -> a -> b
05:31:22 <t7> i mean at present
05:31:46 <merijn> danilo2: Where di you get "raise" from? I'm not aware of any function called that
05:31:47 <safinaskar-i> quchen: i derived a -> a -> b even simpler way
05:32:01 <kuribas> tac: btw, the wikipedia page of bottom states that _|_ corresponds to falsity, like I said: http://en.wikipedia.org/wiki/Bottom_type
05:32:01 <lambdacat> Title: Bottom type - Wikipedia, the free encyclopedia
05:32:28 <thoughtpolice> tac: to be fair, issues like productivity are not really explored up-front when discussing a lot of those issues at a glance. but it's a good point to make, yes
05:32:28 <merijn> danilo2: fromJust just uses "error" and I'm not sure sure that's a proper exception
05:32:35 <tac> kuribas: The bottom type is not the same as the bottom value.
05:33:03 <tac> kuribas: The bottom type is another name for the empty type.
05:33:16 <tac> (It does get confusing to have no fixed set of names for these things)
05:33:25 <quchen> safinaskar-i: "undefined" is a special form and not really a "definition" of ⊥
05:33:26 <merijn> danilo2: btw, fail is dirty and shouldn't be used
05:33:27 <donri> aka. the type that is *only* inhabited by the bottom value
05:33:29 <tac> _|_ is also how you write the empty type in Idris
05:33:47 <donri> in haskell anyway
05:34:32 <matthias_goergen> Can you make a type that doesn't include the bottom value?
05:34:42 <tac> matthias_goergen: not in Haskell
05:34:43 <thoughtpolice> not in Haskell, no.
05:34:48 <quchen> safinaskar-i: Probably the simplest way of getting ⊥ is by inlining fix and id, giving you "let x = x in x"
05:35:19 <int-e> danilo2: are you sure that the error is raised within the code guarded by `onException`?
05:35:56 <matthias_goergen> Not even in Safe-Haskell?
05:36:02 <merijn> matthias_goergen: Not even there
05:36:03 <thoughtpolice> matthias_goergen: nope.
05:36:10 <merijn> matthias_goergen: You'll want a total language like Coq or Agda
05:36:13 <matthias_goergen> Boomers.
05:36:19 <matthias_goergen> Bummers.
05:36:40 <thoughtpolice> matthias_goergen: you can always write 'let x = x in x' as quchen said. this term has the type 'forall a. a' so it can be used anywhere for anything!
05:36:41 <chrisdone> ermm
05:36:47 <int-e> danilo2: lazy evalutation can let unevaluated errors escape quite easily, say: (return (error "foo") `catch` (\(SomeException e) -> print e)) >>= print
05:36:47 <chrisdone> i think unboxed types can't include bottom
05:37:03 <chrisdone> because they're unboxed
05:37:12 <danilo2> merijn, int-e: Ok, youre right. I dont know why I missnamed it it is not raise - anyway the problem is the same - if I use fromJust and onException it is not handled properly - If I implement my own "fromJust" using fail it works
05:37:42 <merijn> danilo2: Take this as the big clue to not use fromJust, there's a reason why it's considered evil
05:37:55 <merijn> danilo2: Why not just pattern match on the Maybe?
05:38:12 <danilo2> merijn: I want exactly the functionality of fromJust - "throw" erro when the value is Nothing
05:38:27 <Maior> booo error
05:38:30 <danilo2> merijn: why do you concider fail an evil ?
05:38:33 <merijn> danilo2: "case blah of Just x -> something; Nothing -> throw myError"
05:38:49 <merijn> danilo2: Because it claims to be implemented for any monad, but in most does something hideously stupid
05:38:52 <danilo2> merijn: Ok, so why should I use "throw" and not "error" ?
05:39:08 <merijn> > const 1 (error "whoops")
05:39:08 <lambdacat>   1
05:39:10 <chrisdone> because strings are rubbish exceptions
05:39:43 <merijn> danilo2: Because when the exception is thrown with error depends on where the (lazy) value is forced
05:39:46 <mr-> danilo2: You could also use fromJust instead of direct pattern matching
05:39:56 <chrisdone> can't rely on them for pattern matching, can't catch them specifically based on their type, english-specific, can't extract data from them
05:40:00 <merijn> mr-: I was just telling him he shouldn't
05:40:12 <mr-> merijn: oops, I meant to write fromMaybe
05:40:17 <mr-> fromMaybe!
05:40:49 <quchen> donri: "fail" is part of the Monad typeclass, but cannot be implemented for all of them. For State you're *forced* to have fail crash your program in some way.
05:40:51 <danilo2> chrisdone, merijn: Ok thank you. Can I handle exceptions thrown with "throw" with onException function?
05:40:57 <merijn> danilo2: For reliable exception raising you want to have throwIO anyway
05:41:11 <quchen> danilo: The above was for you instead of donri, woops
05:41:12 <merijn> danilo2: Yes, but you can't be sure when their thrown because of laziness
05:41:34 <danilo2> merijn: Ok, but using throwIO I know when?
05:42:40 <chrisdone> danilo2: sure. or catch or anything parametrized on the class Exception
05:42:42 <merijn> danilo2: Yes, at the cost of being in IO
05:43:57 <danilo2> merijn, chrisdone: Ok coolm, thank you:) By the way - "being in IO" is a cost? I'm talking right now about final code performance. I love pure functional code and all the logic behind it, but leaving it behind - does using IO monad guive us some "overhead" or something?
05:45:01 <safinaskar-i> kuribas: "typed ski calculus", "typed lambda calculus (without recursion)" and "djinn" are all same thing. they all have no recursion, Turing-incomplete.  they always halt, and we can prove for any djinn-generated program (or for any typed lambda-expression) that this program halts
05:45:18 <quchen> donri: Being in IO is undesirable for functions that don't need to be.
05:45:22 <safinaskar-i> kuribas: so, every such program is  mathematical function, as tac said. but in turing-complete language, this is not true
05:45:25 <safinaskar-i> kuribas: so, every such program is  mathematical function, as tac said. but in turing-complete language, this is not true
05:45:29 <safinaskar-i> nbnnnnso, every such program is  mathematical function, as tac said. but in turing-complete language, this is not true
05:45:37 <chrisdone> foo = case 24# of 24# -> "Woot"; _ -> "Boot" -- ok
05:45:38 <chrisdone> foo = case undefined of 24# -> "Woot"; _ -> "Boot" -- Couldn't match kind `*' against `#'
05:45:38 <chrisdone> so although _|_ inhabits Haskell 2010 values, ghc's unboxed types don't
05:45:51 <merijn> danilo2: No, I meant a semantic cost, i.e. you can't use throwIO in pure code
05:45:55 <merijn> Obviously
05:46:38 <danilo2> merijn: I completely understood what you've told before - I'm jsut asking if there is in ANY case any performance overhead :)
05:46:44 <merijn> quchen: You're failing at tab completion, today :)
05:46:54 <safinaskar-i> kuribas: (sorry for garbage) we have recursion, some programs never halts, and we cannot determine  whenever given program halts. so, for example, the haskell function is not really mathematical function.
05:46:55 <merijn> danilo2: between throw and throwIO? I wouldn't think so
05:46:57 <tac> chrisdone: Unboxed types are always inhabited though without the help of _|_ :)
05:46:57 <chrisdone> ghc also forbids recursive lets for unboxed types
05:47:09 <chrisdone> tac: give me an example?
05:47:10 <quchen> merijn: One mistake is a rather small sample size, mechairoi!
05:47:25 <danilo2> merijn: no, between using IO and not using IO in for exampel pure function
05:47:36 <donri> quchen: second mistab? :P
05:47:40 <merijn> quchen: You made the same one twice in the past couple of minutes ;)
05:47:57 <tac> chrisdone: What example is there to give? An Int# is inhabited by 0#, etc etc
05:47:59 <chrisdone> tac: oh, i misread. you're saying unboxed types have values. uh huh
05:48:02 <merijn> danilo2: No, shouldn't be a difference
05:48:04 <tac> ah
05:48:34 <tac> I feel like I almost understand wtf lenses are doing now sorta kinda.
05:48:56 <tac> I still feel like I need to get to the chapter on the Yoneda lemma before I start using them.
05:48:56 <merijn> tac:  Didn't you watch edwardk's nice lens talk?
05:48:59 <chrisdone> donri: i misread that as mis-stab. am i cereal killer?
05:49:02 <tac> merijn: half way through now
05:49:03 <danilo2> merijn: ok, thank you :))
05:49:05 <tac> oh
05:49:09 <chrisdone> donri: am i cereal thriller?
05:49:09 <tac> merijn: I'm watching SPJ's talk
05:49:09 <merijn> btw
05:49:20 <t7> tac which one?
05:49:21 <kuribas> safinaskar-i: Why should a mathematical function always terminate?  What about a diverging function?
05:49:22 <tac> I've never made it all the way through Edwardk's talk :<
05:49:23 <merijn> tac: edwardk has a two hour lens talk on youtube too
05:49:33 <merijn> t7: Probably http://skillsmatter.com/podcast/scala/lenses-compositional-data-access-and-manipulation/te-8510
05:49:35 <lambdacat> Title: Skills Matter : Haskell eXchange 2013: Simon Peyton Jones on, http://tinyurl.com/q7s4y8e
05:49:35 <tac> merijn: Being two hours is probably why I never made it through
05:49:39 <merijn> I was about to watch that
05:49:46 <merijn> And was about to remark
05:49:54 <quchen> donri: That one was a joke
05:49:57 <merijn> Jesus Christ, someone needs to hire SPJ a designer for his slides
05:50:01 <quchen> merijn: I didn't even realize the other one
05:50:10 <FreeFull> merijn: No, they are perfect
05:50:15 <mangaba_leitosa> tac: can you give a link to Edwardk's talk?
05:50:20 <bearclaw> merijn: thanks for yesterday's hints on purity btw, although in practice it's hard to see when binding C stuff, cf the pcre example in ffi cookbook (I think)
05:50:24 <merijn> @where lens
05:50:24 <lambdacat> I know nothing about lens.
05:50:29 <merijn> :O
05:50:31 <quchen> merijn: They're so ugly he could work for the NSA :-D
05:50:34 <merijn> Where is lambdabot :(
05:50:52 <tac> magicman: http://lens.github.io/ <- it's on this site
05:51:01 <tac> mangaba_leitosa: http://lens.github.io/ <- sorry wrong person
05:51:02 <lambdacat> Title: Lenses, Folds and Traversals
05:51:03 <merijn> mangaba_leitosa: The link used to be in "@where lens" for edwardk's talk, but it seems lambdabot is dead for the moment
05:51:31 <mangaba_leitosa> tac: thank you
05:51:36 <merijn> bearclaw: Yeah, in general it's best to assume C stuff is IO unless it's simple stdlib stuff that you know is safe, or it is code you wrote yourself
05:52:14 <danilo2> Ok one additional small question - Is there a list of some "standfard" haskell exceptions I can throw? Like predefined not to define custom ones?
05:52:23 <mangaba_leitosa> tac: Big Watch the video button on the home page, right?
05:52:34 <merijn> danilo2: Yes, lemme check where they were
05:52:36 <safinaskar-i> kuribas: because the haskell function sometimes freezes and so doesn't return anything. so, if we will consider such functions as proofs (under the isomorphism), then such proofs can prove anything and resulting logic will be inconsistent. you can read this: http://en.wikibooks.org/wiki/Haskell/Denotational_semantics for "undefined", "bottom", etc
05:52:36 <lambdacat> Title: Haskell/Denotational semantics - Wikibooks, open books for an open world
05:53:15 <tac> mangaba_leitosa: Careful. It might knock you in the forehead ;)
05:53:24 <merijn> danilo2: Oh, right, just the Control.Exception documentation
05:53:31 <mangaba_leitosa> tac: why?!
05:53:33 <merijn> danilo2: If you scroll down there's a whole list of existing ones
05:53:41 <mangaba_leitosa> tac: ok, almost 2 hours :-)
05:53:55 <merijn> mangaba_leitosa: 2 hours and be prepared to make notes and practice the stuff he's explaining :p
05:54:05 <mangaba_leitosa> merijn: :-)
05:54:33 <quchen> danilo2, merijn: Those mostly aren't for users to throw I think. If you have your own kind of exception, give it your own type.
05:55:12 <tac> ooo, at half an hour, SPJ has a really cool example of equational reasoning.
05:56:31 <danilo2> quchen, merijn: Ok, thanks :)
05:57:02 <tac> How is SPJ such a good presenter. I wish I could attend one of his talks
05:57:06 <kuribas> safinaskar-i: Thanks, I'll look at it.
05:57:15 <quchen> danilo2: It's pretty easy to make your own type for this, the docs give an example where the Exception class is defined
05:59:11 <safinaskar-i> quchen: "Is there even a word for a programming language that is useful yet not Turing complete?" - TeX. TeX is turing complete because Knuth added some functions to it espesially for this purpose (because someone asked Knuth about them). but if you throw this functions, the language will not be Turing-complete anymore, but still will be very useful for typesetting documents. in fact that function are used very rarely
06:00:23 <safinaskar-i> quchen: *that functions
06:01:08 <quchen> But if you remove that from TeX you're left with a markup language like HTML. It's useful for something, but you can't compute stuff with it.
06:02:07 <mangaba_leitosa> safinaskar-i: sed is a useful programming language, and probably not turing-complete :-)
06:02:20 <Iceland_jack> sed isn't Turing complete?
06:02:30 <mangaba_leitosa> I'm not sure
06:02:37 <Iceland_jack> It has labels and branches
06:02:44 <safinaskar-i> quchen: kuribas: turing machine has unlimited memory. any computer has limited memory. so, every language is not turing-complete in reality
06:02:45 <mr-> http://www.catonmat.net/blog/proof-that-sed-is-turing-complete/
06:02:46 <Iceland_jack> I'm pretty sure it is
06:02:46 <mr-> ;-)
06:02:47 <lambdacat> Title: A proof that Unix utility "sed" is Turing complete - good coders code, great ..., http://tinyurl.com/6llmavb
06:02:55 <mangaba_leitosa> ah, ok, then I'm wrong :-)
06:03:02 <mangaba_leitosa> thanks for the link
06:03:08 <tac> Turing completeness is not hard to acheive
06:03:14 <kuribas> safinaskar-i: With garbage collection it can be.
06:03:17 <mangaba_leitosa> OK, what about grep? :-)
06:03:18 <quchen> safinaskar-i: Languages don't have memory.
06:03:21 <tdammers> unlimited != infinite
06:03:23 <Tinned_Tuna> safinaskar-i: that's only the runtime; the language could be turing complete (just code up an algorithm that takes infinite memory)
06:03:28 <tac> You're likely to get turing completeness by accident if you're not careful
06:03:32 <mangaba_leitosa> grep is a useful programming language for searching text :-))
06:03:43 <quchen> safinaskar-i: The things we use to run our languages are finite state machines, but that doesn't make the languages incomplete.
06:03:47 <mangaba_leitosa> and certainly not turing-complete
06:03:54 <Tinned_Tuna> sure, it'll hit an issue with the runtime, but the language itself could have the same expressive power as a turning machine
06:04:03 <quchen> tac: Greetings from C++ templates
06:04:10 <tdammers> tac: I'd say there are three categories of languages: trivially simple ones, turing complete ones, and academic ones crafted specifically to not be in either category
06:04:46 <mangaba_leitosa> what about yacc/bison?
06:04:51 <safinaskar-i> quchen: kuribas: also, web servers successfully run on machines with limited memory
06:05:04 <mangaba_leitosa> They are for context-dependent (not context-free) grammars, that is, not turing-complete?
06:05:19 <quchen> safinaskar-i: Okay, and?
06:06:28 <thoughtpolice> on the note of sed being turing complete, here's one of my favorite examples: http://uuner.doslash.org/forfun/sedtris.sed
06:07:14 <quchen> thoughtpolice: GOL is probably an abstract example that is nicer to look at
06:07:44 <mangaba_leitosa> quchen: lol. trying it...
06:07:54 <thoughtpolice> quchen: tetris is more fun to play
06:07:55 <thoughtpolice> :P
06:08:16 <quchen> bash: ./sedris: /usr/bin/sed: bad interpreter: No such file or directory
06:08:18 <quchen> Not fun :-(
06:09:11 <mangaba_leitosa> quchen: WOW, it has colors
06:09:13 <mangaba_leitosa> quchen: works for me
06:09:19 <quchen> And that dear children is why we use /usr/bin/env
06:09:53 <mangaba_leitosa> quchen: ah, I did not try to run it directly, did sed -f sedtris.sed right away
06:10:07 <safinaskar-i> kuribas: tac: "The bottom type is not the same as the bottom value" - hmm, tac, you are right. so, bottom type is false proposition. but bottom value is not. and "fix id" has bottom value. but if you can write program which returns bottom value (such as "fix id"), then this program has bottom type, and then you proved false proposition
06:10:37 <funfunctor> g'day
06:10:58 <tac> safinaskar-i: exactly
06:11:17 <funfunctor> I want to go about writing a config _writter_.. any good tips on that? I know BNF notation and i'm aware of the LBNF project.
06:11:50 <funfunctor> So I should be able to write a _reader_ fairly quickly for a given configuration file.
06:11:59 <mangaba_leitosa> quchen: the best ever proof of turing-completeness :-)  I think there was httpd.sed as well
06:13:51 <mangaba_leitosa> (but you don't need turing-completeness for serving static content via HTTPD) :-)
06:14:21 <quchen> mangaba_leitosa: But you need it for having an unbounded loop waiting for new clients
06:16:11 <mangaba_leitosa> quchen: right, so best to be run via inetd :-)
06:17:04 <merijn> quchen: Fun fact, C (unlike Haskell) is not Turing complete :)
06:17:24 <merijn> quchen: At least not without dirty hacks using the filesystem
06:17:42 <funfunctor> What do you mean its not Turning complete?
06:18:03 <mauke> merijn: does tmpfile() count as the file system?
06:18:09 <merijn> mauke: Yes
06:18:15 <mauke> aww
06:18:32 <merijn> funfunctor: Turing completeness requires unbounded memory, C's memory is bounded by the size of char*
06:18:59 <quchen> merijn: Wow :-D
06:19:00 <merijn> Therefore, any program that requires more than sizeof(char*) memory cannot be expressed directly in C, making it non-Turing complete
06:19:22 <funfunctor> oh well that is true I guess.
06:19:32 <merijn> Haskell, not having any explicit definition of memory, can trivially define programs using arbitrary amounts of memory :)
06:20:02 <quchen> merijn: But where does that bound come from in C?
06:20:06 <tromp__> C doesnt define sizeof(char *)
06:20:08 <funfunctor> werid, being Turing complete is not really hard.
06:20:22 <merijn> quchen: The language standard specifies that a pointer can point to any object in memory
06:20:29 <tromp__> so it's not bounded
06:20:34 <merijn> quchen: Therefore a finite pointer size means finite memory size
06:20:43 <merijn> tromp__: It is, because pointers have a finite size
06:20:54 <tromp__> there might be some implementatoion where sizeof (char *) is 10^6
06:20:58 <merijn> tromp__: Sure
06:21:02 <quchen> 10^6 is finite
06:21:04 <mauke> tromp__: still finite
06:21:06 <merijn> tromp__: That's still finite
06:21:06 <funfunctor> acutally I thought its more to do with the range of integers being bounded.
06:21:16 <mr-> what?! 10^6 is _not_ finite!
06:21:24 <tromp__> finite is sufficient for any problem instance you want to solve
06:21:33 <mauke> tromp__: irrelevant
06:21:40 <mauke> we're not talking about solving problems
06:21:42 <merijn> tromp__: Sure, but we're arguing theoretical things here!
06:21:55 <mauke> funfunctor: no, you can just build your own integers
06:21:59 <merijn> tromp__: "works for me" is not an argument that makes C turing complete :)
06:22:29 <quchen> merijn: And why are C pointers of finite size?
06:22:33 <tromp__> i grant you that a single fixed C implementation is not universal
06:22:37 <quchen> merijn: Because the implementation has to choose a size a priori?
06:22:40 <merijn> quchen: Because they're defined that way :)
06:22:53 <quchen> merijn: "A pointer is some bounded integer"?
06:23:04 <mangaba_leitosa> merijn: then we can generalize this statement about C to the machine language as well
06:23:09 <tromp__> but you cannot say the language poses memory bound N
06:23:19 <Philippa> mangaba_leitosa: Sure. All hardware computers are FSMs
06:23:23 <mangaba_leitosa> merijn: machine language is not turing complete, at least in modern implementations :-)
06:23:24 <funfunctor> mauke: yes but at the end of the day its all integers.. so its really a matter of, as per the C spec any sizeof() a object in C that is well defined is finite and so is not Turing complete.
06:23:24 <kuribas> tac: Ok, you say the type of "fix id" is like the false proposition, not it's value.  Btw, that's what I meant above.
06:23:29 <Philippa> it's just not useful to analyse most of them that way
06:23:37 <merijn> quchen: I can't quote verse of the standard and I'm too scared of mauke's corrections to make any *definite* claims, but as far as I remember pointers are a finite, but unspecified size
06:23:41 <Philippa> (so we talk about them as turing machines modulo the memory bound)
06:23:47 <merijn> mangaba_leitosa: Oh, but no one claimed it was :)
06:24:11 <mangaba_leitosa> merijn: and since both C and Haskell are implemented using the machine language...
06:24:14 <Philippa> (well, we don't, because the only thing turing machines are good for us convincing us they're a good model of what it means to 'compute' based on what human computers did...)
06:24:16 <mauke> funfunctor: huh?
06:24:20 <Philippa> *is convincing us
06:24:25 <quchen> mangaba_leitosa: Haskell isn't implemented. Haskell implementations are.
06:24:26 <quicksilver> "Turing completeness requires unbounded memory, C's  memory is bounded by the size of char*
06:24:31 <funfunctor> but since I can use pointers I get "effective" turning completeness. Although its not strictly a ramifcation of the C specification *directly*.
06:24:34 <merijn> mangaba_leitosa: Haskell *implementations* aren't Turing complete, Haskell the *language* *is* Turing complete
06:24:34 <quicksilver> really? is that inference correct?
06:24:44 <mangaba_leitosa> merijn: ok, makes sense :-)
06:24:49 <merijn> mangaba_leitosa: However, C *the language* is *not* Turing complete :)
06:24:50 <quicksilver> where is it written in the C spec that c's memory is bounded by the size of char*?
06:25:00 <mauke> quicksilver: it's implicit
06:25:07 <giogadi> howdy!
06:25:08 <quicksilver> turing completeness requires that you can model an infinite tape
06:25:11 <mangaba_leitosa> merijn: and Haskell is a partially implemented language :-)
06:25:11 <merijn> quicksilver: It's not bounded by char* explicitly. But all memory is addressable in C
06:25:18 <mauke> quicksilver: all object pointers can be roundtripped through void*/char*
06:25:21 <merijn> quicksilver: using pointers, I mean
06:25:26 <mauke> and sizeof (char *) is finite
06:25:26 <Philippa> quicksilver: you need to add Magic Library Functions to get access beyond that
06:25:35 <monoidal> Is there a way to unsafely create Dict (a ~ b) via unsafeCoerce, where Dict :: c => Dict c?
06:25:39 <Philippa> (this has happened for eg 16-bit segmented systems)
06:26:01 <funfunctor> The trivial langauge is turning complete.. Any way.. Can I have help with my question _in_ Haskell please :D ?
06:26:09 <quicksilver> mauke: the standard doesn't require all pointers to coexist in a single memory model does it?
06:26:11 <merijn> quicksilver: So finite pointers implicitly mean finite memory in C :)
06:26:13 <Philippa> funfunctor: sure, what is it?
06:26:22 <funfunctor> lol ^,
06:26:26 <funfunctor> I want to go about writing a config _writter_.. any good tips on that? I know BNF notation and i'm aware of the LBNF project.
06:26:28 <merijn> quicksilver: Function pointers can be in a separate memory segment, but they can't contain data
06:26:49 <mauke> quicksilver: object pointers have to, because all objects can be accessed as an array of bytes
06:26:50 <t7> merijn: the stack might be infinite, just not addressable
06:26:51 <merijn> quicksilver: So you can't use that as an escape hatch
06:26:52 <safinaskar-i> chrisdone: kuribas: "ghc also forbids recursive lets for unboxed types" - so, unboxed types like constexpr in c++11? i. e. functions on unboxed types are like mathematical functions and always return? and can be evaluated in compile time and compiler will not freeze with garantee?
06:27:03 <Philippa> funfunctor: how big a config are we talking about? I've used "deriving Show" in anger...
06:27:17 <merijn> t7: But then you couldn't use pointers to variables on the stack, so then you're not implementing C
06:27:24 <Philippa> there are also some reasonably good pretty-printing libraries on HackageDB
06:27:27 <giogadi> Hi everybody. I'm trying to to traverse a Data.Tree using Data.Tree.Zipper. I'd like to search the tree for a node with a given label, and return the position of that node so I can alter that node later
06:27:29 <monoidal> safinaskar-i: no, unboxed values can depend on runtime
06:27:33 <Philippa> (they'll do things like handle indentation for you automatically)
06:27:40 <funfunctor> Philippa: Well, I want to make a web interface in Haskell Snap to write pf firewall rules..
06:27:48 <merijn> Eh, maybe we wanna move the C turing completeness discussion to -blah :)
06:28:02 <giogadi> Is there an easy way to do this? I can't seem to make sense of all the different movement functions in Data.List.Tree
06:28:11 <giogadi> er, Data.Tree.Zipper
06:28:13 <Philippa> funfunctor: ah. So you need to both render them to HTML and spit them out as text, right?
06:28:30 <Philippa> (though the former is arguably just a different version of the latter)
06:28:54 <Philippa> do you know how you're going to represent the rules internally yet?
06:30:06 <kuribas> safinaskar-i: It's actually obvious that a computer cannot be turing complete, because that would imply it would be able to solve any (terminating) problem with finite resources.
06:30:19 <funfunctor> Philippa: yep
06:30:53 <funfunctor> Philippa: So rendering it should not be too much a problem, if I use LBNF to define the syntax.. and generate a parser..
06:31:13 <kuribas> Is there a rule for module structure in a package?  I have this structure in my package, but hackage recommends against it: http://hackage.haskell.org/package/cubicbezier
06:31:14 <lambdacat> Title: Hackage: cubicbezier: Efficient manipulating of 2D cubic bezier curves.
06:31:21 <Philippa> I have to admit, I don't know LBNF myself. I was just the idiot who pushed Parsec 3 as a Summer of Code project :-)
06:31:42 <Philippa> But pretty-printers certainly look a lot like an 'inverted' grammar, yes
06:31:48 <funfunctor> Philippa: haha.. ok, do go on..!
06:31:54 <kuribas> Should I use Data.Point, Data.Transform and Data.CubicBezier?
06:32:09 <tdammers> Parsec 3 was a SoC project?
06:32:14 <tdammers> when was that?
06:32:22 <Philippa> tdammers: '07
06:32:25 <kuribas> Or Data.Geom2D.Point, Data.Geom2D.Transform and Data.Geom2D.CubicBezier?
06:32:30 <Philippa> still got the t-shirt somewhere, I mentored and xerox did the coding
06:32:40 <int-e> hmpf, now I wonder whether one could satisfy the C standard with a byte that holds infinitely many bits (indexed by omega+1, so ther'd still be a most significant bit)
06:32:56 <Philippa> the initial result was... on the slow side, so we got a serious community version transition problem (one of the first big ones, IIRC)
06:33:17 <safinaskar-i> kuribas: mathematical function should always "terminate" because for every concrete argument it should have some concrete result. also, in mathematics we have no time
06:33:39 <Peaker> is there a name for foldr (<|>) empty ?
06:33:44 <Philippa> funfunctor: anyway, you end up writing a traversal of the data structure that maps it back to the corresponding grammar, preferably in terms of a pretty-printing library that'll take care of white space for you
06:34:00 <chrisdone> donri: now with context links: http://ircbrowse.net/pdfs/haskell/unique
06:34:01 <lambdacat> Title: Unique PDFs linked in #haskell
06:34:02 <kuribas> safinaskar-i: Right, it must be defined on the domain.
06:34:13 <Philippa> Peaker: I know parsec had one, I'd guess Control.Applicative does but you'll have to RTFM or hoogle it yourself :p
06:34:29 <Peaker> Philippa: I guessed that too, can't find anything in Control.Applicative
06:34:41 <monoidal> Peaker: Data.Foldable.asum
06:34:54 <Philippa> monoidal: ah. Figures, but annoying.
06:35:00 <monoidal> found via hoogle
06:35:04 <Peaker> ah, thanks
06:35:22 <Peaker> monoidal: I saw that but read the t/f backwards :)
06:36:01 <funfunctor> Philippa: I see, ok..
06:36:19 <funfunctor> Philippa: Any idea about pandoc?
06:36:29 <Philippa> I've used pandoc, 'tis nice
06:36:45 <safinaskar-i> kuribas: diverging function is not a true function. if we say f: X -> Y, we mean that for every x in X there is exatly one y in Y (but in other way this is not always true; for one y we can have zero of x or two, three of x)
06:36:45 <funfunctor> yea, I was wondering about that for ideas perhaps?
06:36:51 <Philippa> not sure it's what you want here, admittedly?
06:37:13 <Philippa> I used it to write a toolchain to render out bits of LaTeX in blog posts as .pngs
06:38:02 <Philippa> it's going to be gross overkill if you're trying to go text <-> data structure, it's really meant for mapping across different text representations
06:38:39 <safinaskar-i> kuribas: so, 1 / x is not a function R -> R (where R mean real numbers).     this is a function R \ {0} -> R and also a function R \ {0} -> R \ {0}. Here "\" is set theory substraction
06:40:49 <safinaskar-i> kuribas: this gives us possibility to write f(x) in mathematics and to be sure that this is always concrete object (for example, concrete number). and so, we can write theorems like "if x > 2, then f(x) > 4" and be sure such theorems has always some meaning
06:40:52 <applicative> there is plenty of use of partial and divergent functions in mathematics, they're just usually not thematized when they are used, e.g. taking a limit, to use an obvious example
06:40:54 <sopvop> is that slower if core unpacks record too much instead of once. like  foo a = case a  of ... in case a of ... in ... and so on?
06:41:14 <kuribas> safinaskar-i: Yes, I see.
06:41:52 <kuribas> safinaskar-i: I didn't have a formal background in CS, but I do have some books I should read when I have time :)
06:42:28 <tac> applicative: Just as division isn't defined on zero, the limit (as a function) isn't defined on divergent sequences
06:42:59 <applicative> that is, the ones where limit is undefined
06:43:07 <tac> You're almost always better off working with total functions in mathematics (and in programming, but we're still working on changing the status quo on that front)
06:43:48 <safinaskar-i> kuribas: for example, there is theorem "tg x ctg x = 1". but the full formulation of this theorem is "if x is not pi * k / 2, then tg x ctg x = 1"
06:43:58 <gspr> tac: A total function being what, in mathematics?
06:44:07 <applicative> a function
06:44:09 <tac> gspr: They usually just call it "a function".
06:44:12 <gspr> tac: Exactly
06:44:14 <gspr> that was my point :p
06:45:03 <gspr> I mean… you wouldn't define functions (between sets) in anyway where "not total" makes sense.
06:45:06 <gspr> *any way
06:46:04 <tac> In programming, it is more understandable, since most language have at best an incredibly weak notion of subset.
06:46:54 <tac> anywho, time to get ready for work
06:46:58 <yesthisisuser> but for example 1/x is partial since it is not defined for x = 0 .. ?
06:47:06 <yesthisisuser> or i am not sure i followed the discussion
06:47:11 <applicative> as most mathematics has an incredibly weak notion of a type
06:47:23 <tac> yesthisisuser: (you would define 1/x as a function R\{0} -> R, as stated above)
06:47:53 <yesthisisuser> so "partial" is not a mathematically correct term in this context
06:49:03 <Peaker> which is the recommended parser combinator library at the moment, if I need good diagnostics, and not speed?
06:49:16 <yesthisisuser> didn't that concept first come up in recursion theory
06:49:21 <haasn> have you tried trifecta?
06:49:25 <Peaker> haasn: nope
06:49:30 <Peaker> I'll try
06:50:46 <Peaker> installing an edwardk package takes cabal some time :)
06:50:58 <edwardk> only the first one ;)
06:52:09 <safinaskar-i> quchen: "But if you remove that from TeX you're left with a markup language like HTML" - you can substract 2cm from paper width. :) and you will have recursion anyway. of course, this language will not be true programming lang, i just showed it will be useful. useful for typesetting
06:52:22 <mauke> s/substract/subtract/g
06:53:51 <safinaskar-i> quchen: bash will be useful even if you remove recursion, conditions and loops
06:54:18 <quchen> safinaskar-i: Good points
06:54:21 <yesthisisuser> i'm reading some stuff on type theory here and have a question
06:54:42 <bxc> it took until 2pm before the first mention of the word "category" at Haskell eXchange...
06:54:58 <yesthisisuser> if you have something like Γ |- u : A  (sorry for the ugly notation)
06:55:09 <yesthisisuser> the |- is called turnstile i guess?
06:55:11 <shergill> bxc: are there screencasts?
06:55:22 <Peaker> edwardk: trifecta has a ByteString and a String parser function, but no Text parsing function?
06:55:32 <yesthisisuser> then i have something like Γ, x : |- A t : B
06:55:40 <safinaskar-i> mangaba_leitosa: Iceland_jack: mr-: there is tetris in sed. google for it
06:56:02 <yesthisisuser> sorry Γ, x : A |- t : B
06:56:17 <yesthisisuser> the question is: why is the "turnstile" inbetween x:A and t:B here
06:56:48 <yesthisisuser> A and B are types
06:57:17 <yesthisisuser> Γ is a context.. so basically, how do i read this
06:57:23 <yesthisisuser> Γ, x : A |- t : B
06:57:25 <Philippa> yesthisisuser: "Given a context that consists of arbitrary bindings plus "x is bound to A", on the LHS of the turnstile
06:57:28 <safinaskar-i> quchen: yes, languages don't have memory. but machines does. and turing machine is machine. so, for example, "haskell + machine, on which it runs" is not turing-complete
06:58:00 <quchen> Turing machines have infinite memory.
06:58:09 <yesthisisuser> Philippa: thanks..
06:58:40 <yesthisisuser> so the part that x is bound to A is essential
06:58:46 <quchen> If you run something that works with infinite memory on something that has only finite memory you're of course introducing a limitation.
06:58:57 <merijn> quchen: Not necessarily
06:58:59 <mangaba_leitosa> safinaskar-i: already playing it :_)
06:59:18 <merijn> quchen: Turing machines require arbitrary finite memory
06:59:33 <Philippa> yesthisisuser: yep! I'm guessing that's the top half of the rule for typing a lambda expression?
06:59:47 <merijn> quchen: i.e. you can have a finite memory Turing machine as long as there is no bound on what that finite amount is
06:59:59 <Philippa> so you want to make sure the variable bound by the lambda is in scope inside the lambda's body when you typecheck that
07:00:22 <safinaskar-i> tdammers: "I'd say there are three categories of languages". in which category grep is?
07:00:25 <Peaker> how do you render a Leijen pretty doc as returned by trifecta's errors?
07:00:25 <yesthisisuser> Philippa: yes but it also appears under substitivity rules
07:00:25 <Maxdamantus> Note that `Γ, x : A` and `t : B` are the bits the `|-` is between.
07:00:34 <Philippa> quchen: turing machines have unbounded memory. You don't ever get the opportunity to coinduct on omega
07:00:49 <yesthisisuser> but how does x : A prove t : B..? isn't that what it says .. ?
07:00:53 <Maxdamantus> ((Γ, x) : A) |- (t : B)
07:01:00 <monoidal> the Turing completeness discussion does not seem to be ontopic here
07:01:06 <Philippa> yesthisisuser: if it's /above/ the line, it's required to prove the thing below the line
07:01:14 <Maxdamantus> er, sorry
07:01:20 <merijn> quchen: In essence the requirement for Turing machines is "there is sufficient (but not infinite) memory, whatever sufficient means for a specific program"
07:01:21 <Maxdamantus> (Γ, (x : A)) |- (t : B)
07:01:48 <Philippa> monoidal: it's... borderline, as is the typechecking one
07:01:50 <yesthisisuser> Philippa: ah. ok i think i misread the line
07:02:15 <ikarus> there are even space complexities for Turing machines known
07:02:18 <Philippa> "borderline" implies that less-borderline things should get priority and -blah and -overflow exist for a reason
07:02:29 <bxc> shergill: tjeres some kind of video going on - I odn't know if live or if its only for later viewing.
07:02:32 <Maxdamantus> yesthisisuser: it doesn't prove it. It's just a statement.
07:02:33 <Philippa> (-overflow seems more appropriate than -blah in both cases to this particular op)
07:02:49 <Maxdamantus> yesthisisuser: `x = 4` doesn't prove anything. It's just a possible statement in a possible universe.
07:03:00 <safinaskar-i> quchen: "bash: ./sedris: /usr/bin/sed: bad interpreter: No such file or directory" - type "type sed", then copy-paste path you get to first line of the script instead of /usr/bin/sed
07:03:05 <Peaker> edwardk: I think trifecta direly needs a simpler API for simple cases: parse :: Parser a -> String -> Either String a (not just from file). getting a simple string parsed requires 10 lines of annoying boilerplate, it seems :(
07:03:18 <yesthisisuser> but doesn't is say kind-of that the environment Γ determines whatever comes after
07:03:18 <Philippa> yesthisisuser: on its own, it just means "given that context, I can type the term t with type B"
07:03:42 <dmilith> anybody did try installing ghc-mod on OSX 10.8.5?
07:03:42 <yesthisisuser> ok
07:03:53 <dmilith> I tried every version down to 1.2.10
07:03:57 <dmilith> and I'm unable to install it
07:04:02 <yesthisisuser> and why is the context required again?
07:04:04 <Philippa> yesthisisuser: if it's the same Γ that appears elsewhere (eg it's part of an inference rule) then it's talking about extending that existing environment, yes
07:04:07 <Maxdamantus> It's the environment, `Γ`, additionally with `x: A`
07:04:10 <applicative> the sedris worked when I got rid of the opening lines and called sed directly
07:04:15 <tdammers> safinaskar-i: first or second, depending on whether or not it is turing-complete
07:04:30 <Philippa> yesthisisuser: because otherwise you can't talk about what type anything has. Everything has a context.
07:04:33 <tdammers> ANSI SQL is actually an interesting exception
07:04:41 <Maxdamantus> `Γ` is one environment, `Γ, x: A` is the same, but with `x` bound to `A`
07:04:44 <tdammers> but then, it's not really
07:05:02 <tdammers> because it *is* simpler than typical TC languages, by design
07:05:07 <applicative> is the peyton jones talk on lenses good?
07:05:16 <yesthisisuser> ok thanks everyone.. the rules themselves are simple enough at least ..
07:05:28 <Philippa> if you represented Γ as an association list in Haskell, Γ, x:A would be represented by (x,A):Γ
07:05:39 <Philippa> (where that : is list cons)
07:05:43 <shergill> bxc: yes they seem to be up on the skills matter site
07:06:00 <bxc> applicative: i quite like dit
07:06:10 <bxc> next talk starting
07:06:12 * bxc offline
07:06:53 <applicative> haha, 'having edwardk's undivided attention, which is a fairly dangerous state of affairs'
07:07:03 <Peaker> why do I need to jump through the delta hoops in trifecta?   Either I'm using it wrong, or it seems to be very unusable :(
07:07:24 <Peaker> to parse a simple string, I need to go import a separate Delta module, and construct a Delta with a duplicate of the same string I'm parsing?
07:07:42 <Philippa> applicative: hah! I think I could survive that myself, he's harmless
07:08:03 <Philippa> (go on, shoot me for the bad joke already)
07:08:26 <Peaker> I think I'll revert to parsec..  which of the packages is the up-to-date one? "parsec" or "parsec3"?
07:08:44 * chrisdone shoots Philippa with a polaroid
07:08:44 <Philippa> I think parsec has been parsec3 for a while now?
07:08:57 <Philippa> (BICBW)
07:08:58 <Flonk> > 4+4
07:08:58 <lambdacat>   8
07:09:17 <chrisdone> Peaker: parsec version >= 3
07:09:26 <chrisdone> import Text.Parsec, not the old module format and you're good to go
07:09:32 <Peaker> what's the "parsec3" package about?
07:09:39 <chrisdone> no idea
07:10:28 <chrisdone> attoparsec can parse Text, fwiw, if the thing you're parsing is simple enough to be parsec by attoparsec
07:10:55 <chrisdone> i used it just t'other day to parse the output of gnu grep
07:11:43 <Peaker> 1) tried attoparsec, the error messages were terrible.  2) tried trifecta, couldn't figure out how to run a parser   3) falling back to parsec :(   in this instance I'd get a C parser going faster.  I wish the community had a "this is the recommended way to parse, here are examples"
07:12:08 <safinaskar-i> mangaba_leitosa: and all: i writed httpd in shell: http://paste.org.ru/?6clhzk . just run this script, and (not stopping the script) type "127.0.0.1" to your browser
07:12:29 <RichyB> Philippa, hello! Good to see you around again. :)
07:12:42 <Philippa> Peaker: parsec3 is a relic from when it was necessary to keep the previous major version around as well
07:12:46 <chrisdone> Peaker: afaik the accepted way is: attoparsec for performance, parsec for better error messages and generality. trifecta is new to me
07:13:01 <Peaker> Philippa: probably ought to be hidden then, so as to not pollute "cabal list"/etc
07:13:02 <chrisdone> i don't think anybody uses trifecta yet
07:13:10 <Philippa> Parsec still has error message problems if your parser uses negation, btw
07:13:45 <Philippa> trifecta has some serious potential, but there's enough of a learning curve I've not bothered myself despite having talked to edwardk about it plenty
07:13:50 <applicative> idris uses trifecta no?
07:13:51 <Philippa> RichyB: hey!
07:14:21 <mangaba_leitosa> safinaskar-i: nice. Somewhere I saw a collection of HTTPD in sed, awk, shell, PostScript, Forth etc :-)
07:14:21 <applicative> yeah, it seems so; thats a pretty glorious user, chrisdone
07:15:02 <Philippa> yep. Trifecta is on my "if I were spending more time learning stuff" list, and pretty high up it
07:15:15 <Philippa> it has a lot of interesting capabilities
07:16:02 <chrisdone> applicative: sure, but Peaker was asking "accepted/standard way"
07:16:18 <chrisdone> i see parsec used _everywhere_
07:16:26 <Philippa> yeah. Parsec is still the swiss army tacnuke of haskell parsing
07:17:12 <Philippa> it won't always be pain-free, but if you're willing to be a little creative with how you use effects you can make it do most things tolerably so long as you don't mind being limited to offline, single-threaded parsing with no explicit framework for error /recovery/
07:17:12 <chrisdone> which i'm happy about -- in lisp, for example, there's no real go-to library. there's a bunch, or you'll find custom parsers, which is really bothersome
07:17:18 <applicative> chrisdone: of course, it was "<chrisdone> i don't think anybody uses trifecta yet"
07:17:35 <giogadi> Has anyone used Data.Tree.Zipper? If the order of a node's children does not matter, is it more efficient to add a child node at the front or back of the Forest, or does it not matter?
07:17:55 <chrisdone> applicative: well, edward uses it, so obviously "nobody" was used in the general sense. but i appreciate your pedantry
07:18:03 <applicative> Forest is a list, so the answer is probably its better to put it furst, giogadi
07:18:09 <applicative> first even
07:18:58 <giogadi> applicative: that makes enough sense, thanks!
07:20:37 <applicative> chrisdone: i was thinking the stature of idris means the point wasnt pedantic
07:22:00 <applicative> haha, peyton jones's bad history is being corrected.
07:23:07 <safinaskar-i> mangaba_leitosa: quchen: "you don't need turing-completeness for serving static content via HTTPD" - "you need it for having an unbounded loop waiting for new clients" - you don't need turing-completeness for any particular task. for any task (web server, factorial program, etc) i can create turing-incomplete language, which solves this task
07:23:55 <Philippa> and you most certainly don't need turing completeness just for an indefinite loop on input
07:24:05 <yesthisisuser> today is turing completeness day on #haskell :)
07:24:11 <Philippa> (whereas in a sense you need a capability turing machines don't have: they don't /have/ input, just the tape)
07:24:14 <mangaba_leitosa> safinaskar-i: indeed :-)
07:24:28 <Philippa> (this matters: it's part of why the "launchMissile" joke)
07:24:50 <quchen> We're celebrating that Haskell was finally declared Turing complete today.
07:25:02 <mangaba_leitosa> safinaskar-i: the only expression of the language solve_task(input_parameters) will do :-)
07:25:04 <safinaskar-i> mangaba_leitosa: quchen: turing incomplete language may have loops. for example, i can create lang, which has unconditional infinite loop as only one syntax construction
07:25:43 <Philippa> hah! STLC + nats, bools and basic intro/elim on both + fix is turing complete
07:25:55 <safinaskar-i> mangaba_leitosa: quchen: i can take turing-complete brainf*ck (with symbols +-<>[]) and throw +- or <>. resulting language will have loops but will not be turing complete
07:26:01 <Philippa> safinaskar-i: or you can learn about codata and coinduction. Stream processing has a long history.
07:26:16 <quchen> I don't know Brainf*ck, is that similar to Brainfuck?
07:26:41 <quchen> End of political statement.
07:26:48 <mangaba_leitosa> safinaskar-i: I agree
07:26:49 <Philippa> quchen: that's a little unfair, it's not obvious to everyone that it's acceptable in here to use the u
07:27:29 <mangaba_leitosa> @add_global_filter %s/u//g
07:27:29 <lambdacat> Unknown command, try @list
07:27:31 <merijn> Philippa: otoh, I've always found the use of "f*ck" instead of "fuck" weird. Either don't say it, or just write it out. Is anyone less offended due to the fact of a * being there? >.>
07:27:37 <safinaskar-i> mangaba_leitosa: quchen: turing incomplete language may have conditions, recursion (as in TeX), just not all constructions same time. turing incomplete language may freeze forever
07:27:51 <Philippa> merijn: oh, I know. But sometimes it'll save your job
07:28:03 <merijn> Philippa: Doesn't sound like a job worth saving >.>
07:28:04 <Philippa> (because it indicates "I am referring to a known entity but I'm not using it as an excuse to swear")
07:28:32 <Philippa> it's 2013. Many people are in situations where any job they have is worth saving unless they have another in hand.
07:29:51 <quchen> (It indicates your desire to say "fuck" with the cop-out option a 13-year-old would use)
07:30:22 <chrisdone> swear in a foreign language, nobody cares =p
07:30:37 <quchen> chrisdone: Too many Germans here :-(
07:30:43 <Philippa> I'm sure I'm not the only one who just said fuck at 13. But when you're crossing cultural boundaries, the *ed option is safer when you're referring to something like Brainfuck, alas
07:30:54 <shelf> employers would fire you for cursing?
07:31:22 <Philippa> shelf: many would. More would for doing so in a logged public forum on company time, too.
07:32:06 <shelf> jeez. that's petty
07:32:33 <merijn> Philippa: heh, might just be a cultural difference here. I've noticed the UK is silly uptight about somethings (and the US is obviously worse, still)
07:32:46 <shelf> i hope i detect such employers before signing up
07:32:52 <chrisdone> i can say vaffanculo, testa di cazzo stronzo! when i'm back in the uk and nobody bats an eyelid
07:33:18 <chrisdone> likewise in italy i can swear like a sailor in english at the supermarket and nobody bats an eyelid
07:33:27 <Flonk> :t ap
07:33:27 <lambdacat> Monad m => m (a -> b) -> m a -> m b
07:33:28 <tdammers> chrisdone: I've had an italian colleague for long enough to judge you by these words
07:33:52 <chrisdone> tdammers: and then shun me? shhhhhuuuuuuuuuuunnnnnn
07:33:52 <Philippa> so can anyone who played the right Assassin's Creed games :p
07:34:17 * sm_ thought it was a 13 year old who named brainfuck
07:34:55 <Philippa> merijn: *nod*. It's a power thing, one is supposed to be rude in a genteel fashion. Passive-aggressive is the conventional form of aggressive around here
07:35:03 <shelf> much less 'brainfuck' than 'brainannoy'
07:35:05 <Philippa> always cements power imbalances
07:35:39 <Philippa> (it's one of the reasons I cheerfully swear away and have done so in eg meetings about national-scope issues)
07:35:59 <Philippa> (I'm in a position to get away with it and it lets people know I /will/ re-tilt the playing field)
07:36:03 <chrisdone> i wonder if there are people who pronounce Coq like "coke" to avoid being shamed for it
07:36:27 <Philippa> chrisdone: probably not a lot
07:36:38 <lpaul7> Hi. I want to override instance that library implements. What are my options?
07:36:47 <Philippa> OTOH, there aren't a lot of funny Coq jokes to be made
07:36:49 <merijn> Philippa: It was so weird first having to fill in a 3 page form on nationality, cultural affilition, sexuality, religion, etc. for HR about discrimination (and again when my contract expired...)
07:36:54 <quchen> lpaul7: Use a newtype wrapper
07:37:09 <Philippa> merijn: yeah. You're not actually obliged to disclose most of that stuff, but most people don't know that
07:37:11 <lpaul7> quchen: Any others?
07:37:14 <quchen> Nope
07:37:20 <Philippa> (which can be a complicated thing when it comes to disability in particular)
07:37:29 <chrisdone> Philippa: discussion reminds me of this: =p https://www.youtube.com/watch?v=dF1NUposXVQ
07:37:44 <lpaul7> I don't like wrapping values in newtype. Looks ugly.
07:38:05 <quchen> OK.
07:38:05 <Philippa> you're SOL, then
07:38:24 <Philippa> types are in a 1:0-1 relationship with instances
07:38:43 <Philippa> changing that breaks things badly
07:39:06 <lpaul7> Is there any way to hide library instance implementation?
07:39:13 <Philippa> nope
07:39:44 <Philippa> people are talking loosely about ways to do it, but they'd be somewhat limited in where they can be applied: you'd have to be able to show there's a watertight boundary that said instance never, ever escapes
07:41:13 <safinaskar-i> funfunctor: "yes but at the end of the day its all integers" - this gives you really unbounded integers on the base of bounded integers and unbounded memory: you can create bignum (i. e. long arithmetic) with unbounded length
07:41:28 <lpaul7> Perhaps it is library issue, it is not enough modular.
07:41:33 <Philippa> (you should see the pain this causes in ML, where they don't have the 1:1 rule but have to keep track of where everything came from explicitly instead)
07:41:47 <Philippa> not if a newtype will solve the problem, it isn't
07:42:07 <Philippa> not unless you're going to be forced to map that newtype along a structure with a big spine or something
07:42:32 <lpaul7> I believe solution should be transparent to my code :)
07:42:42 <safinaskar-i> funfunctor: moreover, you can make this bignums as linked lists, so you don't even have to store bignum length as integer. all you need is infinite memory
07:42:45 <chrisdone> shelf: employers are capricious about it, too. swearing is fine sometimes, and other times the swearer will be labelled “unprofessional”
07:44:42 <lpaul7> Then I'll make a newtype and try to abstract wrapping. Thank you.
07:44:55 <Philippa> chrisdone: yep. Which is exactly why I don't think it's fair to pick on someone for using the accepted convention for when you have to do it to refer to a legitimate object of study but might need to nod in the direction of people who might make an issue of it
07:45:01 <shelf> i guess it's always going to be a grey area. being dismissed for it would be horrid, though
07:45:17 <shelf> given it's a superficial or political issue
07:45:22 <Philippa> especially as it's a good excuse for employers who want rid of you because they're discriminatory arseholes
07:45:30 <yesthisisuser> another question: in something like System-F, how is something like a "type constraint" or Haskell type classes expressed.. if it is?
07:45:31 <chrisdone> true
07:46:02 <Philippa> yesthisisuser: it isn't. The closest thing is passing around a dictionary that's equivalent to the instances involved.
07:46:16 <chrisdone> yesthisisuser: iirc system f doesn't have type-classes
07:46:28 <Philippa> You can picture a language which had 'constraint' and 'instance' syntactic classes and lambdas and applications for them
07:46:34 <Philippa> (which I have done)
07:46:46 <Philippa> in which case => ends up looking a lot like -> or forall
07:47:55 <Sculptor> hi
07:48:21 <yesthisisuser> interesting.. because it seems like something that would be useful to .. study more rigorously
07:48:26 <shelf> does anyone have a decent list of firms that embrace Haskell? (i'm internship hunting)
07:48:34 <shelf> the wiki page is... rather brief
07:51:09 <Philippa> yesthisisuser: it's been studied at that level of rigour. Benedict Gaster's PhD thesis, for example
07:51:32 <Philippa> For non-typeclass constraints, System Fc is a relevant part of the picture as well
07:53:03 <yesthisisuser> ah. ok.. thanks
07:53:27 <yesthisisuser> couldn't one say for example ∀α ∈ Num . α → α . instead of just ∀α . α → α
07:53:46 <yesthisisuser> well. not Num.. but some family of types
07:56:40 <applicative> 'edwardk is deeply in thrall to abstractionitis'
07:57:26 <Philippa> yesthisisuser: it ends up making more sense to have Num a as something with its own abstractions and applications
07:57:41 <n-dolio> That doesn't extend very well to non-unary relations.
07:57:44 <Philippa> that allows multi-parameter classes, and it makes the type theory less 'magical'
07:57:59 <Philippa> (you're effectively asking for subtyping there)
07:59:03 <Philippa> (subtyping turns out to have really /lousy/ theoretical properties)
07:59:08 <edwardk> applicative: =)
07:59:26 <applicative> edwardk: nice talk in the end. he needed a couple more hours.
07:59:39 <safinaskar-i> funfunctor: please say your question (about config writers) in detail. i don't see any difficulties in writing config writers (unlike config readers). if you have some object and you want to serialize it, just create recursive function which does this
07:59:46 <safinaskar-i> funfunctor: for example: let configwritter (a, b) = "<pair>" ++ (configwritter a) ++ (configwritter b) ++ "</pair>"
07:59:48 <edwardk> Peaker: send a patch. there is also a branch i think where i tried to swap all the bytestring noise out for Text, but i never finished it
08:00:04 <edwardk> applicative: yeah. its hard to even get through intro to lenses in less than 2 hours.
08:00:07 <sclv_> There are two types of people. Those who understand lazy IO and those who Exception: EOF
08:00:13 <Philippa> safinaskar-i: is funfunctor PMing you?
08:00:14 <yesthisisuser> i see. subtyping is not the way to go
08:00:18 <Philippa> only we're not seeing what you're responding to
08:00:47 <Philippa> yesthisisuser: it's been studied - "bounded polymorphism" is the phrase, you get "forall a <= Foo. T"
08:00:49 <chrisdone> sclv_: hahah*** Exception: handle closed or end of file reached
08:00:51 <n-dolio> sclv_: Apparently getting rid of lazy I/O doesn't save you from running out of file descriptors. :)
08:01:09 <Philippa> but it turns out that the obvious subtyping rule is actually undecidable for that system, and the next-best bet makes type inference hellish
08:01:28 <applicative> edwardk: its not abstractionitis, its abstractophilia or maybe abstractomania
08:01:29 <edwardk> i've gotten to where i can crash course one person at a repl trough the basics in about a half hour, but they get little feel for the "why"
08:01:45 <Philippa> edwardk: *nod*. "Why" is always harder.
08:02:00 * Philippa will be AFK for an hour shortly, btw
08:02:04 <safinaskar-i> Philippa: and all: no, i answer to hour-old question. i am reading this chat in one-hour past time
08:02:06 <Philippa> (and probably for longer after that)
08:02:19 <Philippa> safinaskar-i: that's generally confusing to everyone else around you
08:02:24 <Philippa> at best
08:02:31 <safinaskar-i> Philippa: yes..
08:02:44 <applicative> edwardk: yes he wasn't going for the 'just use the repl and see how it works' approach, which has a lot to be said for it though
08:03:08 <edwardk> yeah
08:03:17 <safinaskar-i> funfunctor: but this example errors. but you get it. but i cannot help you anyway. i just said say this question in detail for others
08:03:19 <Philippa> intermingling that with explanations is generally good
08:04:59 <applicative> i think there was a sort of mistake first laboring over the implemenation of set, then later coming to the implementation of get/view -- rather than posing the question, how can we square this circle and define them both, so to say
08:06:23 <applicative> uhoh more Tekmo v snoyberg, break out the giant foam mallets for them.
08:06:34 <nanothief> Is it possible to pass a value through template haskell? Eg macro = let val = MyType "hello" True in <don't know>; Then in another module, x = $(macro), so that x will equal MyType "hello" True
08:07:26 <nanothief> Actually now thinking about it that isn't possible in the general case, nevermind (unless I'm wrong)
08:08:46 <mekeor> is there already a type class (defined somewhere in a package in hackage) like `class C a b where (===) :: a -> b -> Bool`?
08:09:11 <safinaskar-i> monoidal: "unboxed values can depend on runtime". but other runtime values may not be unboxed, so they may be undefined. so unboxed values may be undefined too, right?
08:09:14 <Peaker> edwardk: I couldn't figure out what kind of "Delta" param to give..
08:09:38 <Peaker> edwardk: is there any good example of simple trifecta parsers in use that I could look at?
08:11:18 <monoidal> safinaskar-i: they can't. It's like in C, a variable of type "int" cannot be undefined (in haskell's sense).
08:11:27 <edwardk> Peaker: see the branch. there i simplified Delta
08:11:47 <edwardk> if you wanted to go through and do the change to eliminate ByteString and replace it everywhere with Text, i'd take it
08:11:55 <edwardk> it rather greatly simplifies a lot of the internals
08:12:22 <edwardk> moving to parsers already cost us most of the low level performance gains we had from working in utf8 bytestring anyways
08:12:55 <nanothief> mekeor: I don't think so. In hayoo, the only matches for === were for types with the same type. Test.Simple has the Likeable class, which has the right type signature, but doesn't have many instances: http://hackage.haskell.org/package/test-simple-0.1.5/docs/Test-Simple.html#v:isLike
08:12:57 <lambdacat> Title: Test.Simple, http://tinyurl.com/pnauesm
08:14:15 <mekeor> nanothief: hm. thanks :)
08:17:07 <safinaskar-i> int-e: "indexed by omega+1" - o_O. in fact, i have an idea to create ordinal notation. based on ski-calculus or lambda calculus. and i add 0 (this is the number 0 and the ordinal 0) and ' (successor function)
08:18:40 <safinaskar-i> int-e: and i add Kleene function, i. e. function which gets Natural -> Ordinal function and returns limit ordinal for sequence defined by that function. so, this notation can define every ordinal below Kleene ordinal
08:19:14 <safinaskar-i> int-e: what do you think about this idea? this is why i interested in ski and go to this channel to ask some questions about ski
08:19:48 <safinaskar-i> (i'm reading 17:28 chat and now is 19:14. damn)
08:20:38 <n-dolio> safinaskar-i: Doesn't go far enough. :)
08:20:40 <int-e> safinaskar-i: it's hard to compare two such limit ordinals.
08:21:06 <n-dolio> safinaskar-i: http://code.haskell.org/~dolio/agda-share/html/Ordinal.html
08:21:06 <lambdacat> Title: Ordinal
08:21:49 <osa1> do we have a tool like ghc-core that prints STG output?
08:22:19 <thoughtpolice> osa1: you can just pass -ddump-stg to ghc-core
08:22:25 <int-e> n-dolio: clearly that W type constructor is missing an argument called H, so it would read W H A T :)
08:22:45 <n-dolio> I think it works as is.
08:22:49 <n-dolio> It's more meme-y.
08:22:59 <osa1> thoughtpolice: awesome, just what I need
08:23:31 <thoughtpolice> i agree, W A T is pretty good
08:31:38 <lpaul7> What is OverlappingInstances for? Is it possible to use it to override library instance with my own?
08:32:59 <sclv_> @remember spj [on pointfree style] It has a certain eccentric charm all of its own.
08:32:59 <lambdacat> I will remember.
08:33:10 <startling> lpaul7, not sanely. Are you just looking for a way to do that?
08:33:31 <lpaul7> Yes, without newtype if it possible.
08:33:42 <startling> I was going to recommend a newtype. >.>
08:33:55 <startling> lpaul7, what specifically are you trying to do?
08:35:14 <lpaul7> startling, Yesod provides it's own `ToJSON` instance for `Entity`. I don't like its implementation and looking for a transparent way to change implementation.
08:35:23 <tdammers> W A T is appropriate for a JavaScript interpreter
08:36:13 <startling> lpaul7: a newtype would be the way to go. I think aeson exposes a way to provide an arbitrary serialization function, though?
08:36:30 <startling> I don't know if this is exposed in the yesod thing.
08:37:08 <startling> I guess aeson doesn't expose one. Hrm.
08:38:04 <lpaul7> It is very simple to get `Entity`s from db and then serialize it with `toJSON`. Newtype will add complexity to this pattern
08:38:24 <sm> I propose that the future love child of conduit and pipes be named "ducts"
08:38:29 <safinaskar-i> merijn: "Turing machines require arbitrary finite memory" - we should not bound memory before running the turing machine. because we don't know (before running) what amount of memory it will require. and (without running) we cannot guess
08:38:39 <startling> lpaul7, "json <- getFromDB; putJSON (Mynewtype json);"
08:38:56 <applicative> toJSON . wrap
08:38:57 <lpaul7> And if it is a list of entities :)
08:38:57 <startling> or even getFromDB >>= putJSON . Mynewtype
08:39:12 <startling> lpaul7, then map Mynewtype
08:39:51 <safinaskar-i> merijn: we cannot guess anyhow that amount, because this is equivalent to halting problem. because non-halting machine can actually use infinite amount of memory (consider loop "go left, write 1")
08:40:40 <lpaul7> Yep. I'm thinking of wrapping `selectList` to return MyEntity, but maybe OverlappingInstances provides easier way
08:40:44 <safinaskar-i> merijn: so, to run turing machine we need infinite memory. but turing machine (if it halts) will use finite amount of it
08:41:12 <safinaskar-i> merijn: or we can add memory while turing machine runs when it need it :)
08:41:16 <lpaul7> selectList is an yesod function to fetch from db
08:41:18 <merijn> safinaskar-i: No, you only need finite memory for a Turing machine
08:41:29 <merijn> safinaskar-i: It's just that the amount of finite memory may differ per Turing machine
08:41:50 <merijn> safinaskar-i: The fact that you cannot know in advance how much is needed is irrelevant
08:42:04 <tac> You have to be mindful of the order of quantifiers
08:42:27 <startling> merijn: intuitively it feels like a turing machine could use an infinite amount of memory very easily. Am I missing something?
08:42:30 <tac> If I'm not mistaken, turing machines do require infinite memory, but will only use a bounded amount of memory at any given point.
08:42:40 <tac> But you still have to have an inexhaustible (infinite) supply of the stuff
08:42:48 <tac> Or else there are computations you can't do
08:42:49 <merijn> tac: Unbounded
08:43:20 <tac> Yes. But that totally qualifies as a kind of infinity :)
08:43:39 <merijn> startling: The requirement is that you have an unbounded amount of memory, infinitess is a trivial but overkill way to guarantee unboundedness
08:43:44 <merijn> tac: I disagree
08:43:53 <startling> merijn, oh, I see what you mean.
08:44:15 <startling> I didn't realize there was a distinction. Thanks!
08:44:44 <tac> Like I said, it's a matter of quantifier order. Infinite is not necessarily wrong
08:44:50 <tac> and there is no harm in assuming infinite memory
08:45:14 <merijn> startling: The thing is, if you have a magic predictor that predicts in advance how much memory your Turing machine will take and a mechanism to then execute the Turing machine with that much memory, you are Turing complete while not having infinite memory
08:45:35 <startling> merijn: right. Makes sense.
08:46:10 <merijn> I agree the distinction is fairly theoretical, but we wanna be careful not to prematurely exclude other formalism from being Turing complete :)
08:46:29 <monoidal> what does the predictor say if the machine continuously writes 'a' and moves to the right?
08:47:04 <tac> monoidal: That would be a problem. Let's solve it by removing the letter 'a' from our tape's alphabet ;P
08:47:13 <startling> So in this sense e.g. haskell programs are usually turing machines, and the people making the "infinite memory" distinction are pedants.
08:48:19 <merijn> Anyhoo, I need to do grocery shopping, so the rest of pedant hour needs to wait :)
08:48:40 * tac waits patiently for pedant hour to return.
08:49:17 <ParahSai1in> does renzo hang out here?
08:49:37 <heath> anyone aware of an example which demonstrates how to handle http requests status, sending back 200 and the data, 404, 400, etc.
08:50:01 <startling> heath, it's kind of hard to tell what you're asking.
08:50:08 <startling> ParahSai1in: the name doesn't look familiar.
08:50:21 <heath> i want something like this: http://www.senchalabs.org/connect/errorHandler.html
08:50:21 <lambdacat> Title: Connect - High quality middleware for node.js
08:50:23 <ParahSai1in> heath: http-conduits
08:51:51 <heath> checking it out, thanks ParahSai1in
08:53:22 <safinaskar-i> tdammers: i think grep is not turing-complete. but it is not trivial too. i don't think any non-turing-complete useful language is trivial. there is html, tex (without that functions which make it complete)
08:55:12 <ijp> safinaskar-i: but _not_ html + css3
09:00:16 <intrados> I'm parsing a CSV file into a GADT. Is there a way to automatically select the right constructor based on type and save myself some boilerplate? Example here: http://sprunge.us/GUVg . It seems like I ought to be able to just provide one instance of FromField. Would template haskell be the best way to do this?
09:00:57 <quicksilver> safinaskar-i: tex?
09:07:25 <latro`a> isn't tex complete with just counters?
09:07:31 <Vamp> I'm trying to make foldMap with fold and fmap, foldMap f = fmap fold f  is what I have now but what am I missing?
09:07:52 <latro`a> Vamp, check the types
09:08:07 <latro`a> @type foldMap
09:08:10 <lambdacat>     Not in scope: `foldMap'
09:08:10 <lambdacat>     Perhaps you meant one of these:
09:08:10 <lambdacat>       `Data.Foldable.foldMap' (imported from Data.Foldable),
09:08:17 <latro`a> @type Data.Foldable.foldMap
09:08:18 <lambdacat> (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
09:08:24 <latro`a> @type Data.Foldable.fold
09:08:25 <lambdacat> (Data.Foldable.Foldable t, Monoid m) => t m -> m
09:08:56 <latro`a> if you look at the types, you have to fold after you map
09:09:00 <enthropy> intrados: maybe you can re-arrange your data to be:   data A f g where A :: Proxy f -> Proxy g -> Double -> A f g
09:09:33 <Vamp> latro `a: Ah yeah I forgot that, it's what I had actually
09:09:42 <Vamp> latro `a : But the compiler still doesn't like that
09:09:47 <merijn> intrados: Sadly, no
09:09:54 <Vamp> latro ` a: foldMap f = fold( fmap fold f)
09:09:59 <latro`a> er, no
09:10:11 <merijn> intrados: There's no such thing as types at runtime, so you can't dispatch them (unless you use Typeable)
09:10:13 <latro`a> foldMap g f = fold $ fmap g f
09:10:16 <latro`a> (to make it check)
09:11:25 <Vamp> latro` a: Aha I see and g is (a-> m) then ?
09:11:31 <latro`a> correct
09:11:51 <latro`a> note that this adds a redundant Functor constraint
09:12:33 <augur> soooo
09:12:34 <augur> ICFP videos?
09:12:37 <Vamp> latro ` a: What does that mean?
09:12:52 <latro`a> notice that the type of foldMap does not assume that t is a Functor
09:12:58 <latro`a> the type of your foldMap does
09:13:24 <alpounet> augur, just haskell exchange ones for now afaik
09:13:24 <mizu_no_oto> On a similar idea, does anyone know when CUFP videos are coming out?
09:13:42 <augur> alpounet: those'll do!
09:14:01 <latro`a> Vamp, it may be helpful to look at the default definition of foldMap:
09:14:10 <latro`a> foldMap f = foldr (mappend . f) mempty
09:14:28 <alpounet> augur, yeah right? i recommend SPJ's on 'lens' for a starter, with a cup of coffee/tea: http://skillsmatter.com/podcast/scala/lenses-compositional-data-access-and-manipulation/te-8510
09:14:29 <lambdacat> Title: Skills Matter : Haskell eXchange 2013: Simon Peyton Jones on, http://tinyurl.com/q7s4y8e
09:14:34 <augur> alpounet: ofcourse
09:14:46 <augur> alpounet: also, im drinking turkish coffee as we speak!
09:14:49 * chrisdone has a fresh croissant, that'll do
09:15:02 <augur> but i have to figure some logic stuff for my students, before i do anything like watch videos
09:15:28 <Vamp> latro` a: Aha ok
09:17:19 <intrados> Enthropy and merijn: Thanks. That info helped
09:18:22 <enthropy> intrados: so you're not using a GADT anymore then?
09:20:20 <intrados> I'm trying the proxy idea.
09:21:11 <enthropy> ok that's just a normal ADT
09:21:18 * mangaba_leitosa got feedback about his Lens bug report https://github.com/ekmett/lens/issues/341 : "The makeLenses family of functions is currently implemented to only support records. For now you'll need to add field labels to all of your constructors. I've improved the situation in 8299681"
09:21:19 <latro`a> suppose at runtime you have a value x and a runtime constructor N; what exactly happens when you evaluate (N x)?
09:21:27 <enthropy> the same as   data A f g = A Double
09:21:52 * mangaba_leitosa will try installing the new fixed version then :-)
09:22:40 <intrados> Yeah.
09:23:26 <safinaskar-i> n-dolio: http://www.cs.nott.ac.uk/~pgh/chat.html - not found
09:26:26 <enthropy> merijn: where does     data S where S :: Show a => a -> S -- doesn't it make sense to consider the type 'a' existing at runtime inside the S?
09:26:55 <n-dolio> safinaskar-i: Yeah, I know. I don't know where it moved to, or if it's just dead.
09:29:03 <safinaskar-i> n-dolio: thanks a lot for link
09:29:07 <quicksilver> enthropy: nope.
09:29:31 <triyo_> I wish to create a Read instance for my ADT that behaves just like the `Read a => Read [a]`. How exactly do I do this?
09:29:43 <quicksilver> enthropy: it makes more sense to imagine the type as containing an impossible-to-interpret pointer "A" along with a function which takes "A" and produces a string.
09:30:23 <triyo_> Seems that readsPrec is what I need to define and perhaps call [a]'s version
09:32:16 <merijn> enthropy: The value exists inside S, the type does not
09:32:30 <merijn> enthropy: You can never get 'a' back out
09:32:49 <merijn> enthropy: You have a value of unknown type inside S and the only function you can apply to it is "show"
09:32:59 <triyo_> I could have sworn that I used to define `read` implementation a few year back as oppose to `readsPrec`.
09:33:30 <merijn> enthropy: At least, not without unsafeCoerce
09:35:59 <enthropy> ok well my take is that    f (S a) = show a -- this show is selected based on a type `a' that exists at runtime
09:37:53 <merijn> enthropy: The show instance is selected when you create "S a", not when you call show
09:38:02 <enthropy> well that's an implementation detail, no?
09:38:03 <merijn> enthropy: It's stored inside S, together with a
09:38:36 <merijn> enthropy: The existence of types at runtime (or not) is an implementation detail, so that argument doesn't really hold when discussing whether types exist at runtime
09:39:13 <triyo_> anyone?
09:39:27 <startling> triyo_: it's not really clear what you're asking.
09:39:27 <monoidal> triyo_: what is your ADT?
09:39:58 <monoidal> triyo_: maybe you can examine the source of Read instance for [a]
09:40:04 <triyo_> monoidal: Datra.Matrix -> http://hackage.haskell.org/package/matrix-0.2.1/docs/Data-Matrix.html
09:40:04 <lambdacat> Title: Data.Matrix, http://tinyurl.com/oyu5vaj
09:40:09 <triyo_> data Matrix a
09:40:11 <applicative> ParahSai1in: i think renzo = k0001
09:42:12 <triyo_> I'm using the GA (Genetic Algorithm) library that needs to be able to deserialise my type.
09:43:29 <safinaskar-i> n-dolio: sorry, but tetration defined such way not working as probably expected. i already thought about that before you give me this link. i tried to define tetration, pentation and other hyper-operators
09:43:32 <enthropy> merijn: sure. Sometimes maybe it's useful to have a mental picture that isn't the same as the implementation
09:43:41 <lpaul7> When overriding instance with a newtype, if I forget to wrap value, program will pass compiler but behave differently. Is there anything I could do with it?
09:43:53 <applicative> wow the new Tekmo v snoyberg is really pretty awesome
09:43:54 <applicative> "Your library is also the epitome of accidental complexity. Your entire strategy is "correctness by obscurity".
09:44:10 <triyo_> monoidal: so simplest thing for me is to represent my matrix as a [[a]], since there exists a Rea [a].
09:44:13 <applicative> "It should not be my responsibility to prove your library wrong. It should be your responsibility to prove it correct."
09:44:45 <safinaskar-i> n-dolio: also i tried to define ω-tation (you see unicode, right?), (ω + 1)-tation etc. but this failed, and i understand hyperoperators simply doesn't work for ordinals :(
09:45:01 <mwc> 12
09:45:20 <applicative> 17
09:45:34 <donri> are we listing our ages
09:45:59 <triyo_> monoidal: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Read.html
09:45:59 <triyo_> Seems to be where `Read [a]` is defined.
09:45:59 <lambdacat> Title: GHC/Read.lhs, http://tinyurl.com/nf2z58h
09:46:51 <safinaskar-i> n-dolio: (does you read me?) cause is following: ω ^ (ε0) = ε0
09:47:16 <applicative> somehow I think I could do without this lambdbot url minifying service
09:47:38 <safinaskar-i> n-dolio: i. e. if i apply (ω^) to ω ω times, then, if i apply (ω^) one more time, nothing will change
09:49:38 <alpounet> applicative, re. tekmo/snoyberg, i suppose it's on one of the recent reddit threads?
09:49:46 <safinaskar-i> n-dolio: this is because of http://en.wikipedia.org/wiki/Fixed-point_lemma_for_normal_functions . if f is normal function ((ω^) is example of normal function), then limit of x, f x, f (f x), etc (lets name this limit l) has the following property: f l = l
09:49:49 <lambdacat> Title: Fixed-point lemma for normal functions - Wikipedia, the free encyclopedia, http://tinyurl.com/pdcallz
09:49:58 <safinaskar-i> n-dolio: so there is useless to apply f more times
09:51:38 <Taneb> :O
09:51:44 <Taneb> I'm watching SPJ's lens talk
09:51:49 <Taneb> And he uses Times!
09:51:53 <tac> Taneb: isn't it good?
09:51:54 <Taneb> (for one word)
09:51:54 <applicative> alpounet: yes, it keeps going on. there was one the other day too http://www.reddit.com/r/haskell/comments/1o1ink/the_core_flaw_of_pipes_and_conduit/
09:51:56 <lambdacat> Title: The core flaw of pipes and conduit : haskell, http://tinyurl.com/o5g82wy
09:52:41 <applicative> oh, lambda*cat* is minimizing for me
09:52:45 <Taneb> tac, it's annoyingly similar to a tutorial I was halfway through writing
09:53:02 <tac> Taneb: Well, as they say
09:53:20 <tac> "You could have written a talk on Lenses (And maybe you already have!)"
09:53:40 <monoidal> triyo_: a cop-out solution is to use Read instance of [[a]] and then convert [[a]] -> Vector (Vector a)
09:54:09 <triyo_> monoidal: thanks I'll have a look.
09:54:34 <monoidal> triyo_: that's probably what I would do since it's the simplest. Read is slow anyway
09:55:01 <triyo_> good point on the perf
09:55:05 <DMcGill> Is there anybody who knows gloss here? I want my window to scroll when I move my mouse near the edge of the screen but I can't see a way to get either 1) the relative mouse position or 2) the window size so I can work out the previous myself
09:55:37 <startling> DMcGill, I do. One sec
09:56:03 <DMcGill> gloss is absolutely incredible though, I transformed a mess of opengl into nice clean gloss in like 30 mins
09:56:16 <startling> DMcGill: EventMotion gives you the absolute position of the end of the mouse movement. Does that help you?
09:56:24 <DMcGill> my current code is here for the interested: https://github.com/Swooshed/Fight-puck
09:56:38 <startling> The name is kind of confusing, and it took me a little experimentation to clean that up.
09:56:47 <startling> s/clean/clear
09:57:01 <DMcGill> startling: I don't think you can use that to work out if the mouse is near the edge of the screen
09:57:27 <startling> DMcGill, keep the screen size somewhere?
09:57:41 <DMcGill> is there a resize event?
09:57:46 <DMcGill> I don't think so atm
09:57:56 <startling> I don't think there's any resizing for gloss windows.
09:58:03 <DMcGill> There definitely is, I just tried it
09:58:08 <startling> hrm. on OS X there isn't.
09:58:20 <DMcGill> I don't mind losing that functionality for now if it means I get to use gloss :)
09:58:48 <n-dolio> safinaskar-i: The stuff below the ordinal definition is just me messing around. So I don't know if it makes any sense.
09:59:04 <DMcGill> thanks for trying anyway startling
09:59:22 <startling> DMcGill: no problem!
10:15:50 <napping> Is gtk2hs broken with Cabal 18?
10:17:11 <geekosaur> I think I saw some patches go by about that, you may want to build gtk2hs from its repo instead of the current hackage version
10:17:27 <alpounet> applicative, wow, yeah, there are quite a few new comments, since the last time I checked. let's hope it'll result in improvements to the respective libraries this time too :)
10:17:32 <napping> Ah, that would probably work better than trying to patch things up error by error myself
10:18:13 <ReinH> sclv_: ping
10:18:16 <mr-> DMcGill: which would you prefer, a relative mouse position, or a resize event? ;-)
10:23:23 <DMcGill_> mr-: I don't know and I feel it's worth asking for others' positions (heh) on this too. For my specific use case now a relative mouse position would be most useful but the former can be calculated from the latter anyway. I'm sure there are many situations where knowing the size of the window is important - for GUI elements including displays and buttons and so on for example.
10:24:42 <DMcGill_> mr-: how would such a relative position be given? 'EventMotion (Float,Float) (Float,Float)'?
10:24:43 <mr-> DMcGill_: Yeah.. but gloss is supposed to be really easy
10:25:22 <mr-> DMcGill_: I would probably give it as (x,y) with 0 <= x, y <= 1
10:25:32 <DMcGill_> mr-: exactly which is why I'm not certain either. I feel that ResizeEvents are 1) the easiest to understand and 2) the most useful in general
10:26:21 <DMcGill_> mr-: the other alternative would be to start adding IO functions in to ask for data like this but that seems like a dark road to go down...
10:27:04 <mr-> DMcGill_: Hmm.. playIO _does_ exist
10:28:02 <DMcGill_> mr-: are there currently any IO specific functions in gloss (I mean other than playIO, animateIO etc)? I couldn't see any in my quick look.
10:28:07 <mr-> It would fit there.. For a "pure" interface, the user would have to carry it around in 'world', I guess
10:28:23 <mr-> I don't think there are
10:29:14 <startling> there are.
10:29:31 <startling> e.g. http://hackage.haskell.org/package/gloss-1.8.0.1/docs/Graphics-Gloss-Interface-IO-Game.html
10:29:32 <lambdacat> Title: Graphics.Gloss.Interface.IO.Game, http://tinyurl.com/lbwxd65
10:29:47 <startling> oh, heh.
10:29:54 <mr-> startling: _other_ than playIO ;-)
10:29:54 <startling> DMcGill_: what are you looking for?
10:29:55 <DMcGill> mr-: ah, I think there was some confusion earlier. When I said 'EventMotion (Float, Float) (Float, Float)' for mouse movement, I meant that the first pair would be absolute x,y and the latter pair to be relative
10:30:06 <napping> geekosaur: building from darcs is working so far
10:30:20 <DMcGill> sorry I missed any messages in the last minute. startling: I'm still thinking about relative mouse pos and window size
10:30:23 <mr-> DMcGill: that would give a nifty way to calculate the absolute size ;-)
10:30:41 <DMcGill> mr_: what is your comment referring to sorry?
10:30:56 <mr-> DMcGill: your (Float, Float) (Float,Float)
10:31:03 <startling> DMcGill_: what do you want IO for?
10:31:34 <reinoud> 0 ppl hefe? I dont think so!
10:31:40 <reinoud> here
10:31:50 <reinoud> oh 1224 ...
10:32:15 <DMcGill> mr-: calculating the size of the window from the absolute and relative positions of the mouse seems like the worst thing :p
10:32:59 <mr-> hehe
10:33:19 <DMcGill> startling: I was discussing the possibility of adding in some IO functions to poll for the current state - mousePos, windowSize, maybe even keysDown. It would mean that the user wouldn't have to carry these things down but I'm not too convinced. It would be a marked departure from the pure interface.
10:33:45 <DMcGill> it seems like doing that might take us back (or at least close) to where we started in the first place
10:36:03 <DMcGill> mr_ startling: the alternative answer would be to simply say "gloss is too simple for this stuff, this is where you need to go behind the scenes yourself" which would be totally okay given gloss's aims.
10:37:15 <startling> DMcGill, can't you do that with playIO?
10:37:41 <mr-> You would need to get the "backendRef"
10:37:46 <mr-> somehow
10:37:49 <startling> That's true.
10:37:55 <DMcGill> startling: it might be possible, I don't know a way to interact with the opengl context from inside gloss. Would just calling opengl's functions work?
10:38:02 <startling> I don't know. A resize event would be pretty simple.
10:38:05 <mr-> then you'd be able to call getWindowDimensions
10:38:15 <startling> to add to gloss, I mean.
10:38:19 <mr-> True
10:38:54 <mr-> (doing that atm)
10:39:21 <DMcGill> mr-: thanks! :) On another note, does one of the examples use the mouse wheel? I couldn't get it working earlier in my code so I'd like to test.
10:39:50 <mr-> No promises.. if it turns out to be too much work.. ;-)
10:52:45 <xico> is it possible to defined 'instance AClass MyClass a' for every 'AClass a'?
10:52:51 <xico> without doing template haskell
10:53:00 <xico> (ie not manually)
10:53:29 <startling> xico: I think that's a syntax error. Could you rewrite it?
10:53:32 <DMcGill> instance declarations accept constraints
10:53:48 <xico> startling: 'instance AClass (MyClass a)'
10:53:51 <DMcGill> you could try something like "instance (MyClass a) => AClass a"
10:54:08 <xico> DMcGill: indeed, but i would like to do it for every AClass
10:54:25 <DMcGill> ah, sorry I read that as "every MyClass"
10:54:33 <startling> xico: oh. Is MyClass actually a class?
10:54:37 <xico> yes
10:54:56 <xico> maybe it does not make sense :)
10:54:56 <startling> xico, OK, then your second try is a syntax error, too. :3
10:55:21 <xico> startling: yes, is for every a such that 'instance AClass a' is defined
10:55:29 <xico> no
10:55:38 <xico> for every AClass such that...
10:55:40 <startling> xico, make AClass a superclass of MyClass, I think.
10:55:59 <startling> (Is this you? http://www.reddit.com/r/haskell/comments/1o0jyl/what_are_best_practices_for_making_a_subclass/ )
10:56:01 <lambdacat> Title: What are best practices for making a subclass that specifies the default impl..., http://tinyurl.com/qzdkged
10:56:04 <xico> startling: i could but i want to do it for every AClass
10:56:09 <DMcGill> xico: perhaps you could put together a concrete example?
10:56:24 <DMcGill> on lpaste. Concrete classes Foo Bar and such
10:56:36 <xico> i should :)
10:57:04 <Bio4> Hello, why there is no BSP tree implementations in haskell?
10:59:39 <startling> Bio4, there are a handful of them around.
10:59:47 <startling> I think everyone rolls their own tbh.
11:00:01 <Bio4> startling: Can you point me at couple of them?
11:00:43 <startling> Oh, maybe I'm wrong.
11:00:54 <cpa> hi there, I have a question about snap and the acid-state snaplet: I'd like to do something like if bool then (update state) else (writeText "error") but the types do not match
11:00:56 <DMcGill> there's a quad tree in gloss
11:00:58 <startling> I thought there was one in gloss, but that's a quadtree.
11:00:59 <startling> Yeah
11:01:19 <DMcGill> Bio4: perhaps when you have to write one, you could put it on hackage!
11:01:59 <mightybyte> cpa: Why don't you come to #snapframework?
11:01:59 <lpaste> xico pasted “Automatic instances” at http://lpaste.net/94081
11:02:15 <xico> startling, DMcGill: there is what i have in mind
11:02:22 <cpa> mightybyte: because I didn't realise there was such a chan
11:02:39 <DMcGill> xico: use GeneralizedNewtypeDeriving
11:02:51 <DMcGill> then you have newtype Factor a = Factor a deriving (Eq, Ord, Show, ...)
11:02:55 <DMcGill> that's the best you're going to get
11:02:59 <Bio4> DMcGill: Ha-ha, thats quite odd frankly not having bsp tree implenmtation in such mature language.
11:03:03 <teneen> does 32-bit ghc cross build for 64-bit?
11:03:16 <DMcGill> automatically derinv ALL instances for a newtype is a bad idea for various reasons
11:03:48 <xico> DMcGill: you may be right. th would not make it really easier also, not to mention that generalized deriving does not work in th.
11:04:17 <DMcGill> I'm not even sure that 'list all instance decls in scope' is possible in TH
11:04:35 <jfischoff> DMcGill: its not
11:04:36 <xico> DMcGill: oh you are right, its the other way
11:04:57 <jfischoff> but having patched the compiler to provide that information through TH before
11:05:08 <jfischoff> I can say its not a difficult thing to add
11:05:43 <jfischoff> but there is simple TH way to do it right now
11:05:47 <teneen> I have a 32-bit ghc installed and I want to build for 64-bit machine, is this possible?
11:05:50 <jfischoff> something you could do
11:05:57 <teneen> on Windows
11:05:58 <jfischoff> that would be overkill no doubt
11:06:17 <jfischoff> is to use the GHC api in the runIO portion of TH
11:06:20 <xico> DMcGill: yet GeneralizedNewtypeDeriving wont work here
11:06:37 <jfischoff> and then copy the code from ghci that can find all the instances in scope
11:06:40 <jfischoff> and call that
11:06:41 <xico> DMcGill: since i can only instantiate, let's say, Num (Factor a) if Num a
11:07:09 <xico> jfischoff: where is the code from ghci in the ghc stuff?
11:07:19 <xico> jfischoff: there is no usefull ghci/ directory
11:07:31 <jfischoff> one sec...
11:09:28 <jfischoff> xico: if you follow the children of this function you will get to the code that gets the instances: https://github.com/ghc/ghc/blob/master/ghc/InteractiveUI.hs#L1063
11:09:36 <jfischoff> I can't remember what the function is called
11:09:42 <DMcGill> xico: that's when you use StandaloneDeriving and have "deriving instance Num a => Num (Factor a)"
11:09:53 <DMcGill> TH is not needed in this case
11:10:04 <xico> DMcGill: thanks!
11:10:15 <xico> jfischoff: perfect, thanks :)
11:10:18 <augur> is there a structural notion of computable function?
11:10:47 <xico> jfischoff: now i know the location of the ghci code
11:11:41 <jfischoff> xico: the GHC API is more difficult than TH, don't say I didn't warn you ;)
11:16:03 <lpaste> DMcGill annotated “Automatic instances” with “xico: Automatic instances (annotation)” at http://lpaste.net/94081#a94083
11:16:10 <xico> as a completely unrelated question, does anyone know how to fetch the correct location of the headers (HsFFI.h) and libraries (containing hs_init) of ghc?
11:16:30 <Bio4> BSP TREE
11:16:38 <xico> DMcGill: thanks, and beautiful
11:17:29 <DMcGill> I fully maintain that any other solution, be it hackery with ghc or th, will involve much more work than that
11:18:07 <jfischoff> to be clear I was not proposing a solution to deriving the instances
11:18:28 <mr-> DMcGill: adding a resize eventHandler is surprisingly easy.. Now how to push the changes? ;-)
11:18:44 <jfischoff> I was just explaining how to find which instances for a type are in scope
11:19:02 <jfischoff> or what might work, but still probably not worth the work
11:20:19 <xico> jfischoff: well, i really want to have a look at ghci, for unrelated reasons, so that was helpful
11:20:19 <triyo>  /quit
11:20:36 * jfischoff nods
11:28:01 <sm> how do I fix the problem of ghc-pkg check giving a load of .../FILE.haddock warnings ?
11:28:28 <sm> does ghc-pkg check expect that haddocks were built ? and cabal-install does not do that by default ?
11:28:47 <geekosaur> pretty much, yes
11:29:55 <sm> since ghc 7.4 by the looks of it
11:30:41 <sm> that's unfortunate, but good to know - thanks
11:31:27 <joe9> I am tring to parse contents of a string before --. For example, "testing string -- commented out", extract "testing string" out. http://codepad.org/83BznHDq is my attempt at it.
11:31:27 <lambdacat> Title: Plain Text code - 12 lines - codepad
11:31:48 <joe9> I am not sure how to go about it.
11:31:52 <joe9> any thoughts, please?
11:32:19 <joe9> the -- portion is a comment line, hence it is not guaranteed to be there on all lines.
11:32:40 <sm> `ghc-pkg check --simple-output` seems to avoid the problem
11:35:33 <DMcGill> joe9: one solution: add a parse 'end' which succeeds if it finds a line ending or "--". Then use manyTil.
11:35:58 <joe9> DMcGill: thanks.
11:38:32 * hackagebot math-functions 0.1.4.0 - Special functions and Chebyshev polynomials  http://hackage.haskell.org/package/math-functions-0.1.4.0 (AlexeyKhudyakov)
11:38:32 <lambdacat> Title: Hackage: math-functions: Special functions and Chebyshev polynomials
11:38:34 * hackagebot statistics 0.10.5.0 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.10.5.0 (AlexeyKhudyakov)
11:38:34 <lambdacat> Title: Hackage: statistics: A library of statistical types, data, and functions
11:39:00 <tac> What linux is a good linux for haskell-platform? I know that Ubuntu falls behind really badly.
11:40:27 <yaxu> tac: it does? latest ubuntu seems to have the latest haskell platform packaged as standard
11:40:31 <Eduard_Munteanu> tac: Gentoo sort of catched up lately although 6.12.3 still seems to be the latest stable :)
11:40:35 <yaxu> http://packages.ubuntu.com/search?keywords=haskell-platform
11:40:35 <lambdacat> Title: Ubuntu – Package Search Results -- haskell-platform
11:40:53 <Eduard_Munteanu> I'm running 7.6.3-r1 which is just keyword-masked.
11:41:11 <Eduard_Munteanu> Erm, GHC, not HP version.
11:42:20 <yaxu> ah, although the latest ubuntu isn't officially released for another week..
11:42:29 <Morley93> Any tips as to why this isn't working? http://pastebin.com/GE862xSg
11:42:31 <mauke> The paste GE862xSg has been copied to http://lpaste.net/94084
11:43:06 <Flonk> @src on
11:43:06 <lambdacat> Plugin `sourcePlugin' failed with: state not initialized
11:43:07 <yaxu> although the current ubuntu is haskell platform 2012.2.0 too
11:43:16 <Flonk> What happened to lambdabot?
11:43:20 <fizruk> Morley93: parens around (x:xs)
11:45:51 <Morley93> fizruk: Thanks, just got completely different errors to deal with now!
11:47:34 <DMcGill> Morley93: that code snippet (with the extra parens) works fine for me. Note that "x : toNormal xs" works
11:54:21 <Morley93> DMcGill: Yeah, just some other functions which aren't working as intended.
11:54:55 <joe9> DMcGill:  parseTest (manyTill anyChar (try (string "--"))) "test --"
11:55:15 <joe9> DMcGill: I cannot figure out how to tell the parser to NOT consume the string "--"
11:56:59 <newsham_> lens question -- peyton-jones' talk gives a fahrenheit to centigrade example.  does lense library have a way to plug in an arbitrary isomorphism in the same way?
11:57:21 <edwardk> yes
11:57:23 <edwardk> :t iso
11:57:24 <lambdacat> Not in scope: `iso'
11:57:26 <edwardk> :t Control.Lens.iso
11:57:27 <DMcGill> joe9: I think 'lookAhead' does what you want
11:57:27 <lambdacat> Couldn't find qualified module.
11:57:34 <edwardk> lambdacat?
11:57:41 <edwardk> anyways, yes
11:57:45 <newsham_> danke
11:57:58 <edwardk> if you use iso to build something up you can also turn the isomorphism around and use it as a lens in the other direction with 'from'
11:58:03 <newsham_> i should code this up for kicks in python
12:00:07 <joe9> DMcGill: thanks. that helped.
12:00:51 <newsham_> i guess one pain would be lack of templating to autogenerate
12:01:23 <newsham_> though i guess could also use reflection features
12:01:33 <Bio4> Hello again. Trying to implement BSP tree.
12:01:38 <newsham_> all the machinery would be costly too (unlike hask)
12:01:57 <Bio4> http://roguebasin.roguelikedevelopment.org/index.php?title=Basic_BSP_Dungeon_generation Following this brief guide.
12:01:59 <lambdacat> Title: Basic BSP Dungeon generation - RogueBasin, http://tinyurl.com/yajbb2v
12:03:18 <Bio4> How do you guys would represent ADT for BSP tree?
12:04:09 <Bio4> BSP Tree for dungeon*
12:04:18 <Bio4> Like on that wiki page.
12:05:08 <solarstorm> yes, nice indeed :9
12:05:15 <safinaskar-i> n-dolio: so, ω↑↑ω makes sense and it is ε0. but ω
12:06:06 <safinaskar-i> n-dolio: but ω↑↑(ω + 1) is ε0 again. do you read me?
12:07:09 <Bio4> safinaskar-i: copy that
12:09:12 <n-dolio> safinaskar-i: Okay.
12:09:24 <DMcGill> Bio4: it looks pretty simple. Each split needs: a random float between 0 and 1, a random Bool for horizontal/vert and then the two sub-rooms
12:09:52 <DMcGill> data Dungeon = Room | Split Float Bool Dungeon Dungeon
12:10:27 <c_wraith> I'd replace Bool with a custom data type for orientation
12:10:36 <c_wraith> Just to make things more readable
12:11:08 <Bio4> DMcGill: Thanks a lot!
12:11:13 <ReinH> I think it would be better to calculate each partition's coordinates and store those
12:11:14 <startling> data Dungeon = Room | Horizontal Float Dungeon Dungeon | Vertical Float Dungeon Dungeon
12:11:24 <ReinH> rather than storing the means of caculation (the float and bool)
12:11:58 <startling> What's up with 'lambdacat'?
12:12:31 <ReinH> data Dungeon = Room Coord Coord | Partition Coord Coord Dungeon Dungeon
12:12:44 <ReinH> where coords are top left and bottom right, respectively
12:12:45 <newsham_> wow, the applicative/traversal example that p-j gives is pretty awesome
12:13:11 <DMcGill> newsham_: is this in his talk? I haven't watched it yet
12:13:24 <ReinH> otherwise you're going to be calculating these values every time you use the tree anyway
12:13:31 <osa1> this has to be a joke http://hackage.haskell.org/package/uulib-0.9.15/docs/UU-Pretty-Basic.html#v:-62--62--47--47--60--60-
12:13:32 <lambdacat> Title: UU.Pretty.Basic, http://tinyurl.com/keyghwk
12:13:33 <newsham_> yah in http://skillsmatter.com/podcast/scala/lenses-compositional-data-access-and-manipulation starting around minute 53 or so
12:13:35 <lambdacat> Title: Skills Matter : Haskell eXchange 2013: Simon Peyton Jones on, http://tinyurl.com/olqdthm
12:13:36 <Bio4> ReinH: Yeah, you're right.
12:14:03 <DMcGill> (>>-<<)
12:14:11 <ReinH> and since the values are context-sensitive, you won't have a useful functor instance, etc
12:14:13 <DMcGill> Kirby is very upset
12:14:14 <startling> osa1: someone here was using that terrible library and wouldn't use anything else.
12:14:18 <startling> I felt really bad.
12:14:44 <osa1> is the library bad? I haven't tried it yet
12:15:07 <startling> Well, I don't know if it's bad. It's really unidiomatic and underdocumented.
12:15:13 <osa1> I mean it's already 5 characters, why not give it a useful name instead of a stupid smiley like operator ??
12:15:33 <osa1> s/5/6
12:16:53 <ion> Skill smatter (also, yay! the videos have been posted)
12:17:07 <startling> :t (??) -- osa1
12:17:07 <lambdacat> Not in scope: `??'
12:17:11 <startling> ugh
12:17:15 <startling> what is lambdacat
12:17:33 <startling> why doesn't it import lens? :(
12:18:16 <ion> startling: http://ro-che.info/ccc/images/logo.png
12:18:18 <ReinH> Bio4: it would be really hard to, e.g., search the tree to find which room a coord is in if you use the Float Bool representation and trivial with the coord representation
12:18:22 <luite_> exit
12:18:23 <luite_> oops
12:18:38 <geekosaur> lambdabot got taken out by the big netsplit last night, lambdacat is presumably filling in
12:19:46 <Bio4> ReinH: Why do you mean by "trivial with coord"?
12:19:51 <Bio4> Room Coord Coord?
12:20:06 <ReinH> right, with a top-left bottom-right representation of the partition
12:20:34 <ReinH> since inside point topLeft bottomRight is easy to write
12:20:34 <Bio4> ReinH: What do you think is better?
12:20:36 <carter> there ws a net slpit?
12:20:40 <carter> *was a net split
12:20:42 <ReinH> Bio4: my representation :)
12:20:44 <Bio4> Ahh. got it.
12:21:05 <ReinH> Bio4: take advantage of the fact that two points uniquely define a 2d (or 3d) region
12:21:11 <ReinH> (as long as they are pairwise unequal)
12:21:31 <ReinH> and of the fact that your dungeons are finite
12:21:37 <ReinH> for a more efficient representation :)
12:21:48 <Bio4> Indeed, thank you.
12:22:02 <ReinH> np
12:22:55 <ReinH> Bio4: you might do something like: branch on area of partition to determine whether next partitions should be rooms or further partitions
12:23:28 <ReinH> or, more accurately, divide the partition with a line and branch on size of those new spaces
12:24:02 <ReinH> you can also determine whether to branch horizontally or vertically by comparing width/height ratio
12:25:14 <ReinH> branchType ratio >= 1 = Vertical | otherwise = Horizontal
12:25:43 <DMcGill> ReinH: the random generation is an important part of it, that'd leave all the rooms quite square.
12:25:58 <ReinH> DMcGill: no, that determines what type of line to draw, not *where* to draw it
12:26:18 <ReinH> you don't want to repeatedly vertically branch on a tall partition
12:26:21 <ReinH> or vice versa
12:26:38 <DMcGill> hmm, I'd be interested to see how it affects things - how square things end up looking
12:26:43 <ReinH> you then get a random interval, maybe 0.2..0.8, to draw the line
12:26:48 <DMcGill> perhaps only if the ratio was over a certain limit?
12:27:01 <ReinH> DMcGill: the above is: if the partition is wider than tall, split vertically
12:27:28 <ReinH> then you draw a random vertical line. The bounds of this random interval I think would have more effect on "squareness"
12:27:43 <ReinH> 0.1..0.9 would be less square, 0.4..0.6 would be more square
12:27:55 <startling> Yeah. I don't think you need to remember the direction at all.
12:28:07 <ReinH> startling: you only need to remember it long enough to draw the line :)
12:28:12 <yitz> startling: is that the original uuparsinglib? that's actually an interesting parser. or is this a spinoff of some kind?
12:28:25 <startling> You get a graph-theoretically-isomorphic room either way, don't you?
12:28:31 <startling> yitz: no idea.
12:28:33 <ReinH> startling: I still think Vertical and Horizontal are more useful than Bool even if they are used ephemerally :)
12:28:49 <ReinH> startling: up to graph isomorphism, sure, but we do care about actual shape of the rooms
12:29:13 <startling> Don't you get the same shapes?
12:29:20 <startling> (Just perhaps rotated.)
12:29:21 <Vamp> I need to write a show instance for my data type, the ranks of a card 2, 3 till Ace etc., Is there a shorter way to do that than this? http://lpaste.net/6377058963111804928
12:29:22 <yitz> startling: uuparsinglib is the result of a lot of good research. its distinguishing feature is that it is very smart about correcting parse errors rather than just reporting them.
12:29:27 <ReinH> startling: by shape I mean the dimensions of the rooms
12:29:28 <ReinH> sorry
12:30:00 <ReinH> the attributes of the dungeon forgotten by the graph morphism are still important to the player :){
12:30:00 <startling> yitz: maybe. It's kind of a bad thing to point people new to haskell and parsing to, though.
12:30:22 <yitz> startling: if so, i don't think the fact that someone went a little wild with an operator name is that much of an issue.
12:30:31 <safinaskar-i> n-dolio: just read ordinal theory in wikipedia, it is very interesting. also, add some way to "see" resulting ordinal. for example, there is an f function described in "A terminating process" in http://en.wikipedia.org/wiki/Ordinal_collapsing_function . this function (given integer) can convert an ordinal to integer. so, ordinal can be viewed as an Int -> Int function
12:30:32 <lambdacat> Title: Ordinal collapsing function - Wikipedia, the free encyclopedia
12:30:51 <startling> yitz: right, the complete dearth of doc comments is the issue.
12:31:12 <yitz> startling: not sure. they have some really cool demos where you type in stuff with all kinds of typos and the thing eerily fixes them.
12:31:42 <yitz> startling: though you're right that it's not the most popular in actual code. probably not the fastest parser.
12:31:53 <dert> anyone here that can help me with a vim haskell-mode problem?
12:31:57 <safinaskar-i> n-dolio: so you can remove your type "ordinal" and just manipulate Int -> Int functions. every small ordinal (even epsilon 0) will be first-class function Int -> Int
12:32:02 <ReinH> dert: not without knowing the question ;)
12:32:10 <joe9> http://codepad.org/TUVy2NVY any suggestions, please? I seem to be missing something simple. I want to be able to parse "testcontent\n" or "testcontent -- comment\n"
12:32:10 <lambdacat> Title: Plain Text code - 24 lines - codepad
12:32:22 <DMcGill> yitz: interesting, got a paper link?
12:32:22 <yitz> dert: oh no. we all use emacs. <ducks>
12:32:23 <joe9> error message : http://codepad.org/4H8kB41k
12:32:24 <lambdacat> Title: Plain Text code - 7 lines - codepad
12:32:36 * ReinH uses haskellmode-vim
12:32:51 <dert> alright, when I try to :make it says "Could not find module Analysis.hs" (one of my modules, of course)
12:32:51 <DMcGill> joe9: going to need to see your code
12:32:57 <elliott> int-e: ok to @quit lambdacat?
12:33:04 <jfischoff> preflex seen kmc
12:33:05 <preflex>  kmc was last seen on #haskell 102 days, 7 minutes and 13 seconds ago, saying: right, and they differ between Haskell implementations
12:33:07 <ReinH> startling: now you have me thinking about dungeon -> room graph functors p
12:33:10 <dert> I tried the -v option, and it seems to search the correct file (Analysis.hs)
12:33:10 <int-e> elliott: sure
12:33:21 <ReinH> startling: and their free left adjionts
12:33:26 <joe9> DMcGill: this is the code:  http://codepad.org/VSxcDvXr
12:33:39 <ReinH> startling: and whether you a free functor so constructed could usefully generate dungeons
12:33:56 <dert> and when I run the same build command in the terminal (ghc -e :q Main.hs) it compiles, no problem
12:34:21 <ReinH> or any functor graph -> dungeon that adds the necessary structure, free or otherwise
12:34:48 <int-e> elliott: ah, you were not on my admin list, added (in case there is  next time :) )
12:35:14 <ReinH> (where that structure is dimension of rooms, location of doors and hallways, etc)
12:36:38 <yitz> DMcGill: look on this site: http://www.cs.uu.nl/wiki/bin/view/HUT/ParserCombinators
12:37:39 <yitz> DMcGill: paywalled: http://dl.acm.org/citation.cfm?doid=944705.944727
12:37:47 <yitz> but there is a technical report
12:39:20 <yitz> startling: ok i see. uulib is an older but still supported branch of the code with less error correction but much faster. the latest research is in uu-parsinglib.
12:40:01 <startling> ReinH: well, for one it would need to be a planar graph
12:40:15 <startling> (with standard roguelike semantics)
12:40:25 <safinaskar-i> merijn: "No, you only need finite memory for a Turing machine" - no, one machine can need different amounts depended on input. so, your idea is to create new computer or programming lang for every algorithm and even its input, eh? even if we have some concrete input, we cannot guess amount required by machine
12:40:36 <startling> Though I guess you could do crossing tunnels without much difficulty.
12:41:01 <safinaskar-i> merijn: turing machine has infinite memory, it just uses finite amount of it. trust me, i am mathematic student :)
12:41:05 <startling> safinaskar-i: I think you're missing the point.
12:41:24 <safinaskar-i> merijn: look at any book, in wikipedia, somewhere else
12:41:53 <startling> safinaskar-i, you're putting a forall where there isn't one.
12:42:28 <startling> to run a turing machine, you just need more memory than it ever needs to use.
12:42:40 <startling> You don't need infinite memory for every turing machine.
12:43:14 <startling> For some turing machines, you would need infinite memory.
12:43:39 <safinaskar-i> merijn: turing machine has infinite tape. for example: http://en.wikipedia.org/wiki/Turing_machine , "The tape is assumed to be arbitrarily extendable to the left and to the right, i.e., the Turing machine is always supplied with as much tape as it needs for its computation."
12:44:07 <startling> safinaskar-i, what you just quoted supports merijn's point, not yours.
12:44:21 <startling> safinaskar-i: notice that that quote does not say "infinite" anywhere.
12:44:27 <int-e> startling: lambdacat is basically just the repo version of lambdabot, which misses a couple of goodies (and still includes some annoyances like the URL title thing)
12:44:33 <safinaskar-i> (now 23:39 MSK, and i reading and answering to 19:36, damn, damn)
12:45:03 <startling> safinaskar-i, that quote says "i.e., the Turing machine is always supplied with as much tape as it needs for its computation."
12:45:07 <lpaste> DMcGill pasted “joe9: this works although I'm not that satisfied with the (fmap return newline)” at http://lpaste.net/94089
12:45:09 <startling> Not "infinite".
12:45:35 <startling> int-e, can we make it import lens?
12:45:38 <scopedTV> essential: at any given point in time, the turing machine has used only a finite amount of tape
12:45:40 <DMcGill> joe9: when the non-comment finds a newline, it leaves it on the end so that the comment parser sees it
12:45:49 <DMcGill> perhaps not the best solution
12:46:17 <joe9> DMcGill: thanks.
12:47:06 <int-e> elliott: could you put your actual Pristine.hs (aka L.hs) somewhere, please?
12:48:31 <elliott> int-e: sure
12:48:35 <elliott> int-e: Pristine.hs and L.hs aren't the same though :)
12:48:40 * hackagebot hmidi 0.2.1.0 - Binding to the OS level MIDI services  http://hackage.haskell.org/package/hmidi-0.2.1.0 (BalazsKomuves)
12:48:42 * hackagebot launchpad-control 0.0.1.0 - High and low-level interface to the Novation Launchpad midi controller.  http://hackage.haskell.org/package/launchpad-control-0.0.1.0 (BalazsKomuves)
12:49:02 <int-e> elliott: but L.hs is restored from Pristine.hs on @let, isn't it?
12:49:12 <elliott> int-e: http://sprunge.us/ILLX
12:49:16 <elliott> on @undefine, not on @let
12:49:21 <joe9> DMcGill: thanks, it works.
12:49:26 <elliott> btw, I use the git version of lambdabot (lightly patched)
12:51:40 <safinaskar-i> startling: if turing machine runs forever, it can use infinite amount of memory. but if it halts, then, of course, no. because it can make finite count of head moves only in finite amount of time
12:52:49 <mm_freak> does anyone know why vincent hanquez abandoned the (safe) crypto-api in favor of his own (unsafe) crypto-random library?
12:53:16 <mm_freak> the latter is impure
12:53:35 <Clint> i don't know why vincent does any of the things that he does
12:53:36 <c_wraith> mm_freak: almost certainly performance
12:53:52 <yitz> a turing machine runs much cooler than a modern data center, but its carbon footprint is still large due to all the pencil leads it goes through.
12:54:04 <c_wraith> yitz: don't forget all the paper in the tape!
12:54:20 <joe9> DMcGill: something is not correct with that code. I think the getContent string "--" is consuming that "--"
12:54:25 <yitz> c_wraith: and the rubber erasers that you need to keep replacing
12:54:54 <mm_freak> c_wraith: it's almost the same API, except that crypto-random doesn't require you to reseed manually…  instead it does that for you in an impure way
12:55:03 <YawningAngel> What's the procedure for debugging a type error in a fairly trivial program?
12:55:08 <haasn> c_wraith: unless you make it out of a clothesline
12:55:13 <YawningAngel> I've misunderstood something somewhere and I can't see it
12:55:21 <joe9> getComment = string "--" >> many (noneOf "\n") -- changing getComment to this line, errors out.
12:55:23 <scopedTV> YawningAngel: I tend to add type signatures to subexpressions and definitions.
12:55:40 <YawningAngel> It has type signatures. I've muffed them :/
12:55:40 <joe9> http://codepad.org/QyDNVsEa DMcGill
12:55:53 <Lethalman> sorry, isn't there an error in the slides when he talks about Const and the getter of Lens'? http://skillsmatter.com/podcast/scala/lenses-compositional-data-access-and-manipulation
12:55:54 <scopedTV> YawningAngel: the error message you'll get will be more descriptive that way.
12:55:58 <c_wraith> mm_freak: ah. reseeding is *hard* to get right. Neither impure nor manual are really correct. :(
12:56:18 <lpaste> DMcGill annotated “joe9: this works although I'm not that satisfied with the (fmap return newline)” with “joe9: string "--" moved to getComment” at http://lpaste.net/94089#a94090
12:56:19 <Lethalman> there he says a -> Const a a for view :: Lens' s a -> s -> a
12:56:33 <edwardk> :t Const
12:56:34 <scopedTV> YawningAngel: for example:   let z = f x y;    I'll add   let z = f (x :: Integer) (y :: Integer -> Integer)
12:56:35 <lambdabot> a -> Const a b
12:56:40 <Lethalman> but lens Const s shouldn't Const in this case be a -> Const a s ?
12:56:49 <c_wraith> YawningAngel: add more signatures - especially on subexpressions.  See if you can get a very narrow type mismatch
12:56:49 <edwardk> lets work through it
12:56:51 <Lethalman> rather than a -> Const a a?
12:56:54 <mm_freak> c_wraith: correct would be to put a monadic layer around crypto-api's CryptoRandomGen
12:57:02 <edwardk> :t getConst . both Const
12:57:02 <lambdabot> Monoid c => (c, c) -> c
12:57:04 <DMcGill> joe9: it's easy enough to move the lookAhead to include the "--" and move a string "--" into getcomment. Why would you want to though?
12:57:08 <johnw> is there a simpler withTimer wrapper that will show how long a monadic computation took to execute?
12:57:10 <YawningAngel> I'm passing something an Int List that's expecting an Int
12:57:36 <c_wraith> mm_freak: the problem is that reseeding requires IO, but you *really* want to be able to use the gen in pure contexts.
12:57:46 <edwardk> (a -> f a) -> s -> f s      when you pass a -> f a      Const :: a -> Const a b      this forces a ~ b. so you get (a -> Const a a) -> s -> Const a s
12:57:53 <Lethalman> ah right
12:57:55 <joe9> DMcGill: yes, got it. adding a lookahead helped.
12:57:57 <YawningAngel> I was just wondering whether there was a procedure to track things down or if I'm going to have to try and reason things out
12:57:59 <Lethalman> it's the return type that is Const a s
12:58:01 <ParahSai1in> @hoogle TypeValuable
12:58:02 <Lethalman> edwardk, right, thanks
12:58:02 <lambdabot> No results found
12:58:02 <edwardk> yeah
12:58:08 <YawningAngel> Thanks for tryin'
12:58:20 <c_wraith> YawningAngel: adding signatures on subexpressions *is* how you track it down
12:58:23 <joe9> DMcGill: good question too.
12:58:39 <Vamp>  I'm trying to make a constant for a full deck of cards, I can hard code it all but I think it is also possible with list comprehensions, how should I do this? http://lpaste.net/129633730879815680
12:58:41 <Lethalman> the video explains things very well
12:58:47 <Lethalman> for newbies
12:58:58 <mm_freak> c_wraith: in pure contexts you can use lazy I/O or a deterministic PRNG
12:59:00 <YawningAngel> I'll do it, I'm sure this is going to be embarrassingly derp :/
12:59:10 <mm_freak> c_wraith: just seeding impurely is the wrong approach
12:59:12 <scopedTV> YawningAngel: we've all been there :)
12:59:15 <edwardk> Lethalman: i think he did a wonderful job getting the core ideas across
12:59:20 <c_wraith> mm_freak: Oh, I definitely agree with that.
12:59:45 <Lethalman> edwardk, until the view I found everything clear
12:59:49 <edwardk> roconnor: i did let spj know the two 'Edward's big idea' ideas he got around to in the talk were actually yours ;)
12:59:50 <Lethalman> now let's continue :)
12:59:57 <edwardk> Lethalman: heh, thats usually where people stall out =)
13:00:02 <yitz> mm_freak: you mean vincent's api change from crypto-random-api to crypto-random, right? crypto-api is unrelated.
13:00:05 <mm_freak> my main problem is, cprng-aes doesn't provide a crypto-api interface anymore =/
13:00:27 <mm_freak> yitz: cprng-aes used to provide a crypto-api interface
13:00:39 <c_wraith> does it at least give you something lower-level?  or is crypto-random the only interface to it?
13:00:51 <mm_freak> it's the only safe interface to it
13:00:59 <mm_freak> the other one is the usual RandomGen
13:01:02 <c_wraith> "safe"
13:01:07 <Clint> at least he's providing sizes again
13:01:11 <mm_freak> well, "secure" =)
13:01:32 <mm_freak> it's weird that you actually have to choose between safe and secure =)
13:02:26 <c_wraith> Last I heard, though, unless you're trying to be cross-platform, you really shouldn't use your own csprng internally anyway.  You should just read from /dev/urandom
13:03:00 <mm_freak> /dev/urandom is slow and supposed to be used as a seeding source
13:03:26 <c_wraith> take that up with your kernel author.
13:03:36 <joe9> DMcGill: if you do not mind me asking, how did you figure out that you needed "fmap return" before newline
13:03:43 <mm_freak> (and i'd like to add that it isn't slow because it's ubersecure…  it's slow, because it's retarded)
13:03:46 <geekosaur> mm_freak, are you thinking of /dev/random?
13:03:56 <mm_freak> geekosaur: no, /dev/urandom on linux
13:03:57 <DMcGill> the error message was 'expected [Char], actual Char'
13:04:04 <DMcGill> inside some monad transformer
13:04:05 <ion> I can read from /dev/urandom on my desktop box at 17.4 MB/s.
13:04:18 <DMcGill> to operate on a value inside said monad transformer, use fmap
13:04:19 <c_wraith> that sounds fast enough
13:04:25 <DMcGill> to turn a char into [char], use return
13:04:32 <DMcGill> you put the code back and try it :)
13:04:53 <jfischoff> johnw: never used it, but would this work: http://hackage.haskell.org/package/timeit-1.0.0.0/docs/System-TimeIt.html
13:05:04 <mm_freak> oh, seems like it improved…  i get 15 MiB/s
13:05:28 <johnw> jfischoff: thanks
13:05:39 <Lethalman> edwardk, lol
13:06:56 <mm_freak> i guess i'll just use System.Entropy for now
13:07:18 <mm_freak> and for deterministic PRNGs i'll use cprng-aes' RandomGen interface
13:07:38 <joe9> DMcGill: thanks. that is what I doing. breaking it down to understand.
13:08:29 <yitz> mm_freak: so there is no longer a good algo that uses the crypto-api interface?
13:08:38 <DMcGill> joe9: as I said at the time, I'm not convinced that's the best solution to turn a single char parser into one that works on a string. Perhaps "count 1" instead?
13:09:01 <mm_freak> yitz: apparently
13:09:17 <DMcGill> joe9: actually, many1 would probably be best
13:09:17 <yitz> mm_freak: i'll tell you, this constant reshuffling of all the crypto libraries and apis is one of the main factors that make web apps so difficult to build
13:09:26 <joe9> DMcGill: I am not finding fault. I am grateful. just trying to understand so I can learn.
13:09:34 <mm_freak> yitz: indeed, this is about a web app
13:09:40 <mm_freak> to be fair, i'm not overly fond of crypto-api
13:09:41 <DMcGill> I didn't think you were, doesn't mean that I can't find fault with my solutions :)
13:09:58 <mm_freak> it's not powerful enough for some things and for other things it's incredibly inconvenient
13:10:06 <mm_freak> CryptoRandomGen is a particularly bad example
13:10:08 <skypers> hey
13:10:23 <skypers> I think have found an issue within OpenGL.Raw
13:10:24 <kuznero> Hi All!
13:10:29 <mm_freak> that API is so inconvenient that i had to write pages of code to deal with it
13:10:34 <yitz> mm_freak: i don't care. i don't use any of them directly. i just want my web apps to build. they all depend on a gigant pile of shifting sand in the crypto libs.
13:10:43 <acomar> @tell acowley I think I figured out how to get the package on hackage neatly without needing to force reinstalls or something -- I'll have to use a 4 number versioning scheme, first 3 for the opencv version number, last number for the package revision number.
13:10:44 <lambdabot> Consider it noted.
13:10:54 <skypers> https://gist.github.com/skypers/6907446
13:10:57 <kuznero> Am I right assuming that Text.Regex does not support non-capturing groups?
13:11:02 <skypers> I checked the source of all gl_*
13:11:07 <skypers> they’re no overlaps
13:11:12 <skypers> so maybe the type of GLenum?
13:11:17 <skypers> which is CInt
13:11:19 <yitz> mm_freak: any code older than a month or two won't build without hours of cabal constraint research.
13:11:25 <skypers> CUInt*
13:11:37 <skypers> any idea?
13:12:01 <mm_freak> yitz: the problem is, all web frameworks use clientsession, and you have to write the glue code yourself to get server-side sessions
13:12:25 <mm_freak> yitz: for that you need to generate a session identifier, which should be a strong random number
13:12:55 <yitz> mm_freak: i don't want server-side session (at least for now). but i do need clientsession to build because it is a dep of everything.
13:13:30 <mm_freak> yitz: you need server-side sessions for stuff as simple as providing a "logout" button
13:13:36 <yitz> mm_freak: i may need session sometime in the near future though. your warnings sound ominous.
13:14:53 <yitz> mm_freak: hmm maybe. we do have that. could be it's built in to yesod or something. i didn't write that part of the code. i haven't noticed any manual crypto glue code lying around though.
13:17:17 <yitz> mm_freak: what are you building your web app on top of?
13:17:53 <zomg> mm_freak: you can logout with client side sessions by just nuking the cookie
13:18:12 <zomg> obv if you stick anything else in there that's gone too :P
13:18:17 <yitz> zomg: that's not a very secure logout
13:18:53 <safinaskar-i> n-dolio: try to get that article from http://web.archive.org/web/20131009161931/http://www.cs.nott.ac.uk/~pgh/chat.html , when web archive makes that machine up
13:18:55 <zomg> most of the time logout is implemented as just getting rid of whatever identifies your login session
13:18:59 <zomg> so that should be fine
13:19:20 <zomg> well, I guess you can't invalidate certain things with that
13:19:22 <zomg> so yeah
13:19:49 <yitz> zomg: if there's nothing persistent on server side you can just capture the cookie and resurrect the session without the server's permission.
13:19:51 <carter> yitz: did my emails to users makes sense?
13:20:12 <yitz> carter: ?
13:20:21 <carter> yitz: the one about the static deloys
13:20:23 <joe9> DMcGill: I get it now. because of list monad.
13:20:25 <mm_freak> yitz: happstack
13:20:26 <carter> *ghc-users
13:20:30 <mm_freak> zomg: no, you can't
13:20:33 <mm_freak> the session is still valid
13:21:04 <joe9> DMcGill: fmap return turns the Char to List Char, where List = m.
13:21:21 <zomg> Yeah it's not so secure, true
13:21:34 <mm_freak> also clientsession cookies get very large very quickly
13:21:48 <YawningAngel> And now I'm going to ask a better question
13:21:50 <mm_freak> finally the missing isolation forces you to have server-side sessions
13:22:21 <haasn> http://aosabook.org/en/posa/warp.html this is really cool!
13:22:23 <YawningAngel> In the code: http://pastebin.mozilla.org/3225728 , why am I getting an error saying that cross' is being passed x as [[Int]]?
13:22:26 <mauke> The paste 3225728 has been copied to http://lpaste.net/94092
13:22:40 <yitz> carter: thanks for responding! just looked at them now.
13:22:49 <YawningAngel> Surely x is the head of [[Int]], which is [Int]?
13:23:31 <yitz> carter: i am quite surprised with how murky this is. i really need a simple deployment story that doesn't depend on manually supporting each customer.
13:23:39 <carter> yeah
13:23:47 <mm_freak> YawningAngel: my first guess is that you have a problem with operator precedence
13:23:51 <carter> yitz: how about you see if you can get integer simple built?
13:23:55 <mm_freak> YawningAngel: a ++ b : c = ?
13:24:00 <carter> as a ghc variant
13:24:22 <c_wraith> I think mm_freak nailed it
13:24:25 <carter> i forget if theres support for going a build with gmp statically linked, but that has implications with LGPL strictly speaking
13:24:27 <YawningAngel> Is that wrong? Append b to a, prepend that to c
13:24:30 <yitz> carter: sigh. i suppose i could try that. most of our team works on windows, i do the linux and mac versions.
13:24:34 <carter> ok
13:24:41 <mm_freak> YawningAngel: a ++ b : c = a ++ (b : c)
13:24:46 <c_wraith> YawningAngel: I think (:) binds more tightly than (++).  Ask ghci
13:24:55 <YawningAngel> So it does. Welp
13:24:55 <carter> yitz: if you find problems with using integer-simpl ghc, please report them, and we can try to fast track solving issues for 7.8 at least
13:25:06 <yitz> carter: right. integer-simple makes more sense from a licensing pov.
13:25:10 <YawningAngel> Is (a ++ b) : c a useful subsitute?
13:25:26 <mm_freak> YawningAngel: that's /the/ useful "substitute" =)
13:25:37 <mm_freak> if (a ++ b) : c is what you actually mean
13:25:48 <yitz> carter: as long as you don't need really performant big ints, which we don't afaik.
13:25:55 <carter> yitz: yeah
13:26:13 <carter> at some point i  want to hack out a performant "integer-fancy"  but thats a bit ways down on my todo list
13:26:14 <YawningAngel> It is, yes. Though this is a language in which brevity is achieved through y-calculus, so I suppose that shouldn't surprise me :P
13:26:24 <mm_freak> YawningAngel: just like when you mean (a + b) * c you can't write a + b * c ;)
13:26:31 <ski> why calculus ?
13:26:44 <n-dolio> safinaskar-i: I don't remember the content of the article, but I can describe the idea behind the types in that file.
13:27:13 <YawningAngel> Well yes, but I didn't fine any indication that : took precedence over ++; I assumed they had similar precedence, as they're both list operators
13:27:28 <n-dolio> safinaskar-i: Basically, the standard ordinal notation is: 'data Ord = Zero | Suc | Lim (Nat -> Ord)'.
13:27:30 <mm_freak> YawningAngel: "similar precedence"?
13:27:36 <n-dolio> Where we've stepped beyond Nat.
13:27:50 <YawningAngel> They execute in the order they're read
13:27:54 <YawningAngel> I am not a functional programmer :/
13:28:00 <mm_freak> YawningAngel: since the two associations have different meanings, the compiler has to choose one of them
13:28:18 <YawningAngel> Yeah, I feel a fool
13:28:19 <mm_freak> YawningAngel: so it takes the precedence as defined by the corresponding infix declarations
13:28:19 <ski> YawningAngel : they both have the same precedence level -- and also the same associativity (namely right-associative)
13:28:25 <n-dolio> safinaskar-i: But, now you have a bigger type, so what if you can take limits with it? 'data Ord2 = Zero | Suc | Lim (Nat -> Ord2) | Lim2 (Ord -> Ord2)'
13:28:41 <yitz> carter: integer-simple uses karatsuba?
13:28:49 <carter> yitz: doubt it
13:28:50 <n-dolio> That's probably redundant, but maybe we have more limits, because we can have Ord-indexed limits.
13:28:59 <yitz> ugh
13:28:59 * carter yitz: integer simple is REALLY simple
13:29:12 <carter> yitz: integer simple is REALLY simple
13:29:19 <YawningAngel> Welp, thanks guys. I'm going to go feel dumb now
13:29:21 <n-dolio> safinaskar-i: And you can keep iterating that.
13:29:22 <carter> i think it uses grade-school
13:29:46 <yitz> karatsuba isn't really that hard. python used it in its simple form for many years, though now they've gotten more complicated to eek out a little more speed.
13:31:10 <kuznero> non-capturing groups in Text.Regex.Posix? Is it possible?
13:31:21 <yitz> gmp uses many different algorithms with different tuning parameters to scale up efficiently to widely varying integer sizes. we certainly don't need that sophistication for our stuff.
13:31:28 <Lethalman> :t view
13:31:28 <lambdabot> MonadReader s m => Getting a s a -> m a
13:31:53 <n-dolio> safinaskar-i: So, the type in that file uses a fancy type of definition called induction-recursion, where it ties some mutual definitions together to have something that looks like an ordinal-indexed version of that.
13:32:03 <Lethalman> huh so it requires a monadreader, not an applicative?
13:32:38 <supki_> applicative what?
13:32:41 <n-dolio> But, I don't have an example of a definition you can write with the fancy type that you can't write with regular Ord.
13:32:48 <n-dolio> It seems like there might be some, though.
13:33:04 <supki_> Lethalman: MonadReader is to overload view over (->) and Reader
13:33:17 <supki_> Lethalman: saves from having use-like combinator for Reader
13:33:21 <supki_> @ty use
13:33:22 <lambdabot> MonadState s m => Getting a s a -> m a
13:33:37 <yitz> carter: iirc there are instructions on the well-typed somewhere how to compile with integer-simple?
13:33:53 <zebr> hi all. i'm rewriting an ML programme in Haskell, and i have a problem - i have some shared data, which i'm using references for. in haskell if i don't want to be bottled up in an IO monad i'd presumably need to maintain a list of data, and have indices into that instead of references. but if data becomes unnecessary, it shouldn't be in the list - so i'd basically have to implement my own garbage collection. which seems ugly. is there an idiomatic way to do
13:33:59 <zebr> sorry for the wall of text.
13:34:12 <carter> yitz: should also be on the ghc dev wiki
13:34:15 <carter> yitz: if you hit any troubles
13:34:21 <Lethalman> supki_, I thought it was Profunctor p => Settings p s t a b -> ...
13:34:25 <Lethalman> now it changed?
13:34:28 <carter> please don't hesistate to add issues to trac / email ghc-users
13:34:29 <Lethalman> ah no that's over
13:34:29 <Lethalman> :t over
13:34:30 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
13:34:34 <carter> https://github.com/ghc/packages-integer-simple/blob/master/GHC/Integer/Type.hs#L654-L732 is the multiplication code currently
13:34:40 <yitz> carter: ok great thanks!
13:34:53 <carter> yitz: also see my priv message to you on irc
13:34:58 <napping> zebr: if you're changing, IO sounds right.
13:35:11 <carter> yitz: if you hit some perf issues with integer simple
13:35:17 <carter> please report them too
13:35:33 <carter> i *could* be convinced into trying to spend a weekend making simple use karasuba mebe
13:35:40 <carter> though you'll owe me :)
13:35:41 <carter> :p
13:36:12 <zebr> napping: well, the problem is the data shouldn't be changed outside the data structure, though the references may be updated within the structure
13:36:27 <zebr> so operations on the full structure should be pure
13:36:45 <napping> Do you mean while constructing it and before publishing it, or internally to operations?
13:36:57 <carter> yitz: point being, at some point i'd like to make integer-simple a bit fancier
13:37:01 <napping> It's actually confluently persistent?
13:37:52 <yitz> carter: you're right, it's just long mult. - yet quite convoluted for just that.
13:38:14 <yitz> carter: the old python karatsuba code in C was shorter than that.
13:38:45 * hackagebot Dust 2.0 - Polymorphic protocol engine  http://hackage.haskell.org/package/Dust-2.0 (BrandonWiley)
13:38:47 * carter yitz: if you throw up a ticket with a link to the old python C codes etc, i'd be game to figure out if ffying to that is sane
13:38:49 <carter> yitz: if you throw up a ticket with a link to the old python C codes etc, i'd be game to figure out if ffying to that is sane
13:39:30 <zebr> napping: i mean that you *could* implement it purely, because it's just a piece of data. the problem is that *within* the data structure, certain bits of data are understood to be shared in multiple places, as though a reference. the difference is that the reference is only mutable to the extent of the data structure - updating a reference shouldn't modify another structure, only the instances of that reference in *this* structure
13:39:36 <napping> zebr: if it really is internal, and careful enough that you can hold on to a reference to the old and new object and keep using both, and it's threadsave
13:39:37 <zebr> am i making any sense? >.>
13:39:51 <napping> then you might expose a pure interface and use unsafePerformIO inside
13:39:53 <yitz> carter: it's simple enough that it shouldn't be too hard to just port it to native haskell. at least that was my impression.
13:40:00 <carter> yitz: even better!
13:40:02 <carter> still
13:40:04 <carter> links and stuff
13:40:08 <carter> so its written down somewhere
13:40:09 <carter> :)
13:40:12 <carter> on a trac ticket
13:40:15 <carter> as a feature request :)
13:40:17 <napping> otherwise, you probably might as well expose it in IO (or maybe ST)
13:40:31 <yitz> carter: i'll try to get to it. traveling soon, so it might have to wait a bit.
13:40:34 <carter> ok
13:40:38 <carter> fair enough
13:40:41 <lpaste> kuznero pasted “Non-Capturing Groups Regex” at http://lpaste.net/94094
13:41:01 <kuznero> Gents, could you please have a look at this regex example?
13:41:19 <carter> i'm sure theres some women on channel too
13:41:38 <kuznero> :) Sorry, ladies included
13:41:41 <hpc> they have to look at other examples
13:41:46 <hpc> it's the '50s they should really know better
13:42:01 <jfischoff> ReturnCode 13 :(
13:42:36 <hpc> oh god, ?: groups
13:42:46 <kuznero> yep
13:43:08 <napping> zebr: if you're using indicies you'll have to GC yourself if you want
13:43:20 <kuznero> I could have disregarded capturing groups, np. But exp does not work anyway
13:43:43 <hpc> kuznero: to completely side-step your problem, you can split by '?' and then by '&' and then by '='
13:44:08 <hpc> kuznero: those characters shouldn't ever appear as literals unescaped in the URL
13:44:10 <kuznero> hpc: I though about it, but wanted to try regex
13:44:23 <kuznero> that is part of url
13:44:39 <kuznero> I'm trying to parse out parameters values
13:44:40 <zebr> napping: yeah. i don't know, resorting to unsafePerformIO just seems a little heavy handed.
13:44:47 <zebr> napping: i'll think some more. thanks, anyway. :)
13:44:57 <kuznero> hpc: does it make sense to look into parsec then?
13:45:10 <napping> zebr: Is your ML multithreaded?
13:45:19 <zebr> napping: no, single threaded
13:45:43 <napping> that makes the bar a bit higher to wrap things in a pure interface
13:46:12 <hpc> kuznero: if you haven't used parsec before, that would be a great place to start with
13:46:17 <hpc> it's a really easy grammar
13:46:33 <kuznero> hpc: I've been there before, but really long ago...
13:47:14 <kuznero> hpc: but maybe I should ask different question :) is there any relyable libraries (sure there are) that can parse URL parameters?
13:47:24 <kuznero> preferably without too many dependencies
13:47:27 <jfischoff> yes
13:47:56 <kuznero> can you name a few please?
13:48:17 <hpc> is the happstack routing combinator set standalone?
13:48:43 <jfischoff> kunznero: I anwsered before I saw the second part
13:48:43 <hpc> that would be a nice haskelly solution
13:48:59 <jfischoff> all of the webframeworks do a good job of that
13:49:03 <jfischoff> but deps are many
13:49:32 <kuznero> in network package there is something, will try to dig into something smaller than happstack or snap :)
13:49:43 <hpc> kuznero: you can also write one and upload it
13:49:51 <hpc> it really is just a few simple splits
13:50:05 <kuznero> true
13:50:11 <kuznero> Thanks for help!
13:51:54 <hpc> trying to find my code for it and forget which module it is ;)
13:53:46 * hackagebot printf-mauke 0.6.0 - A Perl printf like formatter.  http://hackage.haskell.org/package/printf-mauke-0.6.0 (LukasMai)
13:54:53 <hpc> mauke: you should work on a perl-like list/hash conflation library ;)
13:55:07 <mauke> hpc: what would that do?
13:55:12 <hpc> /magic/
13:55:41 <mauke> ?
13:55:48 <mauke> perl doesn't conflate hashes and lists
13:57:00 <hpc> mauke: i mean the way you can do stuff like @concat = (@first, @last) or %options = (%defaults, %overrides)
13:57:21 <mauke> , is list concatenation
13:57:42 <hpc> get your technical details out of my crazy idea
13:58:33 <geekosaur> :p
13:58:55 <geekosaur> anyway this kinda sounds like it's in lens's bailiwick, although I imagine the operator is fancier than (,) :p
13:59:02 <hpc> anyhoo, it would be horrifyingly untypesafe because of how keys/values get mixed in @x = %y
14:00:41 <safinaskar-i> "data Ord = Zero | Suc Ord | Lim (Nat -> Ord)" - yes, i thought about the same
14:02:40 <haasn> geekosaur: (<>)?
14:04:37 <Flonk> > 4+4
14:04:38 <lambdabot>   8
14:06:09 <interspersion> what introductory textbook would you recommend for learning predicate logic?
14:06:15 <Rickasaurus> integrate x^2 sin^3 x dx
14:06:56 <yaxu> Hi all, I'm using crunchbang linux, which is based on debian wheezy, which only has haskell platform 2012.2.0.0 and ghc 7.4.1. To get the latest versions am I best off recompiling from source or is there a way to upgrade via prebuilt packages?
14:07:25 <zebr> i take it Control.Concurrent.STM.TVar.TVar is an instance of Eq by pointer comparison (or so)?
14:08:49 <Bio4> Hi, me again, sorry for bothering you with my silly questions.
14:09:08 <lpaste> kuznero pasted “Split with Foldr (Efficiency?)” at http://lpaste.net/94097
14:09:19 <kuznero> hpc: what do you think?
14:10:07 <safinaskar-i> n-dolio: "But, now you have a bigger type, so what if you can take limits with it?" - this will not work. any ordinal you can create using Zero, Suc and Lim is countable.  so, every ordinal which is limit of sequence numbered using that countable ordinals, is also a limit of normal sequence with ω members. this is because of http://en.wikipedia.org/wiki/Cofinality theory
14:10:16 <safinaskar-i> n-dolio: so Ord2 will be same as Ord
14:10:26 <hpc> kuznero: i would have done:
14:10:27 <hpc> @src split
14:10:28 <lambdabot> Source not found. The more you drive -- the dumber you get.
14:10:32 <hpc> not that
14:10:44 <hpc> but i would have pattern matched on xs at the start and avoided the fold entirely
14:10:44 <Bio4> http://vpaste.net/gYpwJ Trying to came up with nice recursive solution but stuck.
14:11:05 <kuznero> is it generally too slow?
14:11:06 <Bio4> wd -- width, ht -- height
14:11:14 <kuznero> O(n) I guess, right?
14:11:19 <kuznero> but ++
14:12:12 <Bio4> Trying to write function which given rectange width and height will produce BSP tree.
14:13:06 <hpc> split's going to be O(n) anyway (assuming normal form evaluation)
14:15:17 <kuznero> hpc: yes, but what's concerning then is concatenation of arrays, right? (:) work faster as far as I know... But, for my needs that should be more than enough... Only if pushing it into some kinda generic library which is not for me yet :) I just started doing something practically in Haskell :)
14:15:36 <scriptor> hi guys
14:15:42 <kuznero> hi
14:15:50 <safinaskar-i> n-dolio: so, as i said, ↑↑ is not useful for constructing large ordinals.  same for ↑.  (g ↑ a) b is "apply g to b a times", right? so, if "g" is normal function (as (w^)), then this function will give same results for all a >= w
14:15:58 <scriptor> is there any sort of variation on folds where it consumes a list of functions as it consumes the main list?
14:15:58 <hpc> kuznero: just write it to read nicely first
14:16:28 <hpc> kuznero: if it's too slow for practical use, i will be impressed ;)
14:17:10 <scriptor> such as (foldl-fns (cycle [(+), (*)] 1 [1 .. 10])
14:17:16 <kuznero> hpc: foldr should not be slow :) but I will try making it nicer. Thanks for advice
14:17:22 <scriptor> (where I just made foldl-fns up)
14:18:49 * hackagebot PrimitiveArray 0.5.2.0 - Efficient multidimensional arrays  http://hackage.haskell.org/package/PrimitiveArray-0.5.2.0 (ChristianHoener)
14:19:18 <mauke> > foldl (\z (f, x) -> f z x) 1 (zip (cycle [(+), (*)]) [1 .. 10])
14:19:19 <lambdabot>   16490
14:19:23 <mauke> > foldl (\z (f, x) -> f z x) 1 (zip (cycle [(+), (*)]) [1 .. 10]) :: Expr
14:19:24 <lambdabot>   (((((1 + 1) * 2 + 3) * 4 + 5) * 6 + 7) * 8 + 9) * 10
14:19:46 <mauke> @pl (\z (f, x) -> f z x)
14:19:46 <lambdabot> (`ap` snd) . flip fst
14:20:23 <kuznero> ah, it is not working perfectly :) like a mirror
14:20:45 <lpaste> henk pasted “print first argument” at http://lpaste.net/94098
14:20:55 <safinaskar-i> n-dolio: your ε definition seems to be wrong. right definition is: ε z = ω ↑↑ ω; ε (a + 1) = fix (ε a + 1) (ω^); ε (lim β i f) = lim β i (λ j → ε (f j))
14:21:20 <mauke> henk: let logfile = head args
14:21:34 <mauke> or even: (logfile : _) <- getArgs
14:21:58 <henk> ok, nevermind the prose I wanted to write (: hi everyone
14:22:29 <henk> mauke: Thank you very much for answering without me even saying hi (:
14:23:39 <mauke> @src print
14:23:40 <lambdabot> print x = putStrLn (show x)
14:24:43 <henk> oh ouch, I just copied that somewhere … Thanks
14:25:32 <safinaskar-i> n-dolio: veblen functions definition is wrong, too. if you want, i can write real definition
14:27:03 <safinaskar-i> n-dolio: (also, Suc Ord, not Suc)
14:31:34 <letrec> Say I have 2 or more threads (started by forkIO) modifying the same Hashmap.. Wondering what could happen  - are data structures lightthread-safe?
14:32:05 <donri> letrec: hashmaps yes, hashtables not sure
14:32:36 <Eduard_Munteanu> letrec: if you're writing to a single IORef, you don't need any locking. However if it's a more complex thing, you do.
14:33:23 <ReinH> If you're worried about contention you might consider STM
14:33:42 <quchen> Eduard_Munteanu: There are cases in which IORefs are thread safe?
14:33:47 <ReinH> or parallelism instead of concurrency
14:34:05 <quchen> Eduard_Munteanu: I thought they are as safe as bare pointers
14:34:06 <Eduard_Munteanu> quchen: AFAIK IORef writes are always atomic
14:34:23 <quchen> Ah, for single writes
14:35:45 <letrec> Currently I use STM on keys (I have something like: type STMap k v = M.HashMap (TVar Bool, k) v). But was wondering if it is an overkill
14:35:47 <quchen> I guess for multiple ones there's atomicModifyIORef, but that seems a bit unsafe
14:36:22 <donri> tvars are hashable?
14:36:41 <safinaskar-i> n-dolio: "So, the type in that file" - so, idea of Ord2 etc is from http://www.cs.nott.ac.uk/~pgh/chat.html , right? and _this_ file is not written by you, right? in this case don't read this file, it is written not by mathematician. using Ord2 etc you will not get even more ordinals. it is just interesting programming task and no more
14:36:43 <merijn> donri: Based on address, probably
14:36:51 <donri> why not put the whole hashmap in a single tvar
14:37:43 <donri> none of hashable and stm depend on each other, so i'll assume it's letrec's own orphan instance
14:37:44 <zett_zelett> Is there a way to insert unicode characters directly into yi so that the syntax will be understood?
14:37:45 <merijn> quchen: IORef's are safer than pointers. IORef updates are always atomic
14:37:59 <zett_zelett> Like typing "fun :: Rational → Rational"?
14:38:26 <merijn> quchen: The problem is thate modifyIORef is not atomic and so there's no atomic way to "read, compute, update" (which will be added, or might already be added in HEAD)
14:38:59 <donri> merijn: hm wasn't that about mvars
14:39:03 <donri> i probably misremember
14:39:06 <merijn> donri: Oh, maybe
14:39:15 <merijn> donri: Not sure, maybe both
14:39:26 <merijn> I remember a bunch of discussion about this, but only vaguely :p
14:41:57 <donri> merijn: this? http://www.haskell.org/pipermail/libraries/2013-July/020069.html
14:45:51 <xico> zett_zelett: UnicodeSyntax
14:46:25 <xico> (oups)
14:46:32 <yaxu> Another problem, failing to build binary under mac os x, with haskell platform 2013.2.0.0 and ghci 7.6.3: http://hastebin.com/viwuraxefa.vbs
14:48:33 <geekosaur> yaxu, you have xcode 5, right
14:48:33 <geekosaur> ?
14:49:33 <yaxu> geekosaur: this isn't me, but someone who is trying to use my software.. I'll ask them
14:49:52 <yaxu> geekosaur: I don't use mac os myself
14:49:56 <safinaskar-i> n-dolio: hmm, author of that article Peter G. Hancock is phd in computer science o_O
14:50:49 <geekosaur> known issue, xcode5 broke LANGUAGE CPP, the easiest workaround is to remove the official package and install haskell platform from homebrew or macports (both of which will use a known working gcc instead of apple's clang stuff)
14:50:58 <geekosaur> alternately you can arrange to use cpphs as your preprocessor
14:51:55 <yaxu> geekosaur: Ok they're using macports, so I'll get them to try that, thanks a lot
14:52:16 <acowley> yaxu: http://www.haskell.org/pipermail/haskell-cafe/2013-September/108902.html
14:53:26 <yaxu> acowley: thanks
14:53:53 <f-a> hello folks, does anyone have some experience with haste? I have cabal instelled it, tried ./hastec someExample.hs just to receive a "Could not find module `Haste'". I am a bit lost.
14:58:13 <quchen> merijn: atomicModifyIORef is in the docs at least
14:59:26 <merijn> quchen: Yeah, maybe my remark was even for 7.6 instead of HEAD, I don't remember
15:00:40 <acowley> I think you were thinking about MVar
15:01:00 <acowley> Lots of functions there note that they're only safe for single-producer setups
15:01:09 <merijn> quchen: read/writes for IORef are still atomic, though
15:01:31 <merijn> Although it appears that IORef only have sequential consistency in multithreaded programs
15:01:43 <merijn> So no strong consistency
15:02:29 <merijn> Then again, in a multithreaded program you should be able to deal with that anyway
15:03:47 <mel-> hi
15:05:24 <mel-> I have a problem with Haskells PRNG. Here's a test program: http://lpaste.net/94100 --- the program returns the same random number everytime i run it.
15:06:07 <acowley> When we pick a random number, we stick to it
15:06:22 <mauke> :t getStdRandom
15:06:22 <lambdabot> (StdGen -> (a, StdGen)) -> IO a
15:07:33 <mel-> mauke: are you saying there's a bug in my program? I had the impression that i'm following the documentation.
15:07:53 <geekosaur> you are assuming the initial seed is random
15:07:55 <xico> acowley: :D
15:08:31 <mel-> the seed differs from run to run.
15:11:31 <mel-> so, yes, 'rand' in my program varies. so where's the bug?
15:11:57 <ocharles> phew
15:12:02 <ocharles> haskell exchange is tiring stuff!
15:12:12 <sclv_> @remember acowley When we pick a random number, we stick to it.
15:12:12 <lambdabot> Okay.
15:14:29 <Vamp> I'm trying to make a function that checks if a hand full of cards are of the same suit, I have a function that compares the suit of 2 cards now, but how should I use this for the hand? http://lpaste.net/8693718813100736512
15:14:34 <mel-> I don't get it.
15:15:45 <Eduard_Munteanu> Vamp: well, start by opening Hand
15:16:53 <nooodl> Vamp: if you have a [Card], say (x:xs), you can compare each of xs to x
15:17:33 <mel-> even funnier: http://lpaste.net/94102 -- this program returns either 1 or 3. but never 2.
15:17:36 <Vamp> nooodl: With the function I already made right?
15:17:42 <mel-> this seems broken to me.
15:17:47 <nooodl> like, all (sameCards x) xs
15:17:52 <nooodl> yup
15:19:01 <colluphid> \pl
15:19:09 <seanparsons> ocharles: It was a good day.
15:19:29 <Eduard_Munteanu> mel-: there are no guarantees that it gives you random numbers if you reinit it every time.
15:19:39 <Vamp> nooodle: That's what I tried sameSuits (x:xs) = all (sameCards x) xs, but Hand isn't the same as [Card] the compiler syas
15:20:02 <ocharles> seanparsons: +1
15:20:11 <Eduard_Munteanu> mel-: it's only random for reasonably long runs
15:20:22 <acowley> mel-: Try using random instead of randomR when calling getStdRandom
15:20:42 <mel-> Eduard_Munteanu: ah okay. But I need to make sure that the first random player in my computer game is not always the same player.
15:21:03 <ParahSai1in> how does GeneralizedNewtypeDeriving derive Monad instances
15:21:33 <Eduard_Munteanu> ParahSai1in: GND only packs and unpacks datatypes, really
15:21:44 <mel-> acowley: from the description of these functions it seems that random and ranomR are supposed to be basically the same -- only that randomR allows me to specify the range directly.
15:21:54 <mel-> and that's exatly what I want.. chosing a random element from a fixed, finite set.
15:22:03 <acowley> mel-: Yes, but random doesn't exhibit the problem you're having
15:22:17 <acowley> mel-: So mkStdGen wants more bits apparently
15:22:28 <Eduard_Munteanu> ParahSai1in: e.g.  return = C . return
15:22:43 <ParahSai1in> Eduard_Munteanu: ok thats what i was thinking
15:22:55 <mel-> acowley: So... am I using it wrong it should i report a bug?
15:23:30 <acowley> mel-: I don't think it's a bug, just an undesirable quality from your point of view
15:24:01 <mel-> mhh, okay, thanks
15:24:27 <Eduard_Munteanu> You could argue that behavior should be documented.
15:24:45 <acowley> Yeah, that seems like the right thing
15:25:12 <nooodl> Vamp: sameSuits (Hand (x:xs)) = ... should work
15:25:14 <Eduard_Munteanu> Normally you expect base libs to ask the OS-specific stuff for random number.
15:25:19 <ParahSai1in> Eduard_Munteanu: it probably is, i just was looking at the business in acid-state and wondered how they derived monad, functor etc, and then looked at the extensions pragma
15:25:40 <Eduard_Munteanu> And those libs better save and restore the seeds.
15:26:12 <Eduard_Munteanu> ParahSai1in: note it's not the same thing as data deriving
15:27:06 <colluphid> if i want to search a list for a value could i write search s = filter (==s)
15:27:50 <Eduard_Munteanu> colluphid: for all values
15:27:54 <Vamp> nooodl: Yup that does the trick, thanks
15:27:59 <Eduard_Munteanu> :t elem
15:28:01 <lambdabot> Eq a => a -> [a] -> Bool
15:28:05 <Eduard_Munteanu> :t find
15:28:07 <lambdabot> (a -> Bool) -> [a] -> Maybe a
15:28:18 <Eduard_Munteanu> colluphid: look at these as well ^
15:30:07 <colluphid> Eduard_Munteanu: thanks very much
15:32:45 <safinaskar-i>  - real time -
15:33:18 <safinaskar-i> yeah! i just read this chat and fallen to real time. now is 02:28 MSK and i'm reading chat at 02:28 MSK
15:33:32 <FreeFull> > find (==3) [1,5,23,6,3,2]
15:33:34 <lambdabot>   Just 3
15:33:46 <dert> anybody has any experience with the vim plugin "vim2hs"?
15:33:51 <ocharles> i use vim2hs
15:34:31 <dert> how do I disable the hiding of function definitions?
15:34:42 <ocharles> do you mean folding?
15:34:56 <dert> excactly
15:35:24 <ocharles> i'm not sure, i just hit 'zo' which disables folding
15:35:29 <ocharles> not sure how to always do that
15:36:09 <dert> hm, alright
15:36:31 <dert> any way to do this for all folds in the buffer, maybe?
15:36:51 <safinaskar-i> let's consider typed lambda calculus with lambda construction only without recursion (or, alternatively, typed ski-calculus). as you already said, this calculus will not we turing complete. now let's add to it fixed point combinator. will resulting language be turing complete?
15:37:09 <safinaskar-i> (yeah turing completeness day at #haskell continues)
15:37:21 <dert> figured it out
15:37:31 <dert> set nofoldenable
15:37:40 <dert> just had to figure out it was called folding :P
15:37:42 <dert> thanks man
15:37:45 <acowley> That sounds like something from lens
15:38:36 <acowley> But you may prefer the section (.~ cofoldenated)
15:38:59 <ski> safinaskar-i : yep
15:39:03 <FreeFull> safinaskar-i: All recursion is possible using the fixed point combinator
15:39:03 <ReinH> dert: you can set nofoldenable in a after/ file or autocommand
15:39:30 * ski is not a calculus !
15:39:41 <ReinH> dert: if you want to enable folds but start with them all open you can set foldlevel=99
15:39:49 <dert> i put it un my .vimrc, which works. is an after file / auto command preferable?
15:39:55 <dert> oh, cool
15:40:16 <ReinH> dert: au FileType haskell set fdl=99 " should be sufficient
15:40:29 <ReinH> in .vimrc
15:40:41 <ReinH> Some people prefer to group stuff in .vim/after/haskell.vim and similar
15:41:06 <ReinH> And if a plugin is affecting your .vimrc settings you can use an after file to force them back
15:41:07 <dert> i see
15:42:42 <quchen> Boy this Lens talk by SPJ is good
15:44:49 <colluphid> Couldn't match type `Maybe' with `IO'
15:44:49 <colluphid>     Expected type: IO String
15:44:49 <colluphid>       Actual type: Maybe String
15:44:51 <colluphid>     In the return type of a call of `find'
15:45:21 <colluphid> do i have to take my call to find out of main ?
15:47:53 <quchen> Some code would help
15:48:02 <quchen> @where paste
15:48:03 <lambdabot> http://lpaste.net/new/haskell
15:48:09 <quchen> ^ Haskell pastebin
15:48:23 <Eduard_Munteanu> colluphid: no, it's just not a IO action, so <- won't work if you used that.
15:49:24 <Eduard_Munteanu> colluphid: I mean x <- find ... isn't meaningful, you just want to use it in an expression.
15:49:34 <Eduard_Munteanu> (or a let-binding)
15:50:05 <quchen> It's meaningful if you're in a Maybe block.
15:50:31 <xico> @where my keys
15:50:31 <lambdabot> I know nothing about my.
15:50:55 <safinaskar-i> ski: FreeFull: thanks
15:51:00 <safinaskar-i> ski: nice nick
15:51:59 <safinaskar-i> ski: why ski is not calculus?
15:53:55 <ski> safinaskar-i : <http://lambda-the-ultimate.org/node/533#comment-7712>
15:54:05 <ski> still, this terminology isn't used by everyone
15:55:30 <colluphid> http://lpaste.net/94104
15:56:12 <colluphid> what its supposed to do is open unistd.h and search for the syscall string then return that line it is found on
15:56:48 <colluphid> but i get 'Nothing' regardless of what i search for
15:57:37 <colluphid> i would be most grateful if anyone had pointers
15:59:04 <Eduard_Munteanu> colluphid: what searchStr are you giving it?
15:59:29 <safinaskar-i> typed lambda calculus without fixed point operator. let's add call/cc to it. will resulting lang remain pure functional lang? will be in this lang program which never terminates? will resulting lang be turing complete?
15:59:30 <Eduard_Munteanu> colluphid: find there looks for entire lines
16:00:20 <colluphid> Eduard_Munteanu: just key words like 'read', 'write' etc...
16:00:33 <Eduard_Munteanu> :t find
16:00:35 <lambdabot> (a -> Bool) -> [a] -> Maybe a
16:01:23 <Eduard_Munteanu> colluphid: it can't do that, you have to search substrings some other way
16:01:32 <ski> > find (== "read") (lines "stuff(&a,&b);\na = read();\nwrite(b);")
16:01:33 <lambdabot>   Nothing
16:01:41 <ski> > find (== "a = read();") (lines "stuff(&a,&b);\na = read();\nwrite(b);")
16:01:42 <lambdabot>   Just "a = read();"
16:02:27 <ski> try providing something else than `(== searchStr)', that looks for `searchStr' *inside* the other string argument
16:13:37 <safinaskar-i> hey, what about my call/cc question?
16:14:00 <colluphid> Eduard_Munteanu: Thank you! got it working using `isInfixOf`
16:16:09 <lonecub2131> Is there a better tutorial on Type Classes in Haskell? I am finding it hard to follow this chapter in LYAH. Thanks
16:17:29 <Cale> lonecub2131: Well, hmm
16:17:31 <Eduard_Munteanu> lonecub2131: you might find this more compact, perhaps: http://www.haskell.org/tutorial/classes.html
16:17:44 <Cale> lonecub2131: If you have any questions, I'd be happy to answer them too
16:18:05 <Eduard_Munteanu> A different style as well.
16:18:09 <Cale> lonecub2131: Are you comfortable with how ordinary type variables work?
16:18:44 <Cale> For example, how  length :: [a] -> Int  makes use of the type variable a to indicate that the function doesn't care what type of elements the list has
16:19:19 <lonecub2131> Cale: Yes, and thanks for replying. I understand types. I guess, the examples in LYAH are not making sense to me. Like, I would like to see a more real world implementation of them.
16:19:20 <Cale> Or how  map :: (a -> b) -> [a] -> [b]  works?
16:19:34 <Cale> Well, consider something like sorting a list
16:19:52 <Cale> We'd want our sort function to be able to handle sorting lists of elements of many different types
16:19:58 <Cale> but  sort :: [a] -> [a]  doesn't work
16:20:10 <Cale> because how, for instance, are we supposed to sort a list of functions?
16:20:45 <Cale> The types a for which sorting a list of elements of type a makes sense are those which have comparison operations defined
16:21:00 <Cale> i.e. ordered types
16:21:44 <Cale> So, there's a type class called Ord which specifies what those operations are, and the type of sort can make use of that type class to restrict the types which the type variable ranges over
16:21:51 <Cale> sort :: (Ord a) => [a] -> [a]
16:22:03 <Cale> This says that 'a' ranges only over instances of the type class Ord
16:22:14 <Cale> Ord itself is defined something like this:
16:22:20 <Cale> class Eq a => Ord a where
16:22:28 <Cale>   (<=) :: a -> a -> Bool
16:22:40 <lonecub2131> Oh ...
16:22:40 <Cale>   ... type signatures for some other comparison operations ...
16:23:01 <Cale> Eq here is another type class which specifies the (==) and (/=) functions
16:23:10 <lonecub2131> Yep
16:24:03 <lonecub2131> Ok, this makes more sense now
16:24:09 <Cale> and the => constraint in the head of Ord's definition just means that whenever something is an instance of Ord, the compiler will complain if there isn't also an instance of Eq, and when you specify that some type is in Ord in a signature, Eq will come along for free then
16:24:43 <Cale> It's also possible to define default implementations of functions, for example, in the definition of the Eq class, we have:
16:24:46 <Cale> class Eq a where
16:24:54 <Cale>   (==), (/=) :: a -> a -> Bool
16:25:04 <Cale>   x == y = not (x /= y)
16:25:09 <Cale>   x /= y = not (x == y)
16:25:36 <Cale> Then when you define an instance of Eq, you can provide an implementation of just one of (==) or (/=), and the other one will take the default definition
16:25:47 <Cale> instance Eq MyType where
16:25:54 <Cale>   x == y = ... something ...
16:26:01 <lonecub2131> (==), (/=) :: a -> a -> Bool mean, a is of type == and /=
16:26:06 <lonecub2131> (==), (/=) :: a -> a -> Bool means, a is of type == and /=
16:26:17 <Cale> That means (==) and (/=) are both functions of type a -> a -> Bool
16:26:23 <lonecub2131> Oh ic
16:26:39 <Cale> Well, for the specific type a which the class is discussing
16:27:04 <Cale> Outside of the type class declaration, their type signatures will appear as  (==) :: Eq a => a -> a -> Bool
16:28:02 <Cale> You can think of Eq and Ord and other type classes as being like predicates on types, that is, things which might be true or false of any given type.
16:28:18 <lonecub2131> Ok
16:28:38 <Dodek> siema co ta mxD
16:28:45 <Dodek> oops wrong channel
16:28:55 <Cale> and (Eq a) => ... at the start of a type signature is a way to insist that this predicate is true of the type a. In order to make it true, you need to provide an instance declaration which implements (==) (and/or (/=))
16:29:21 <lonecub2131> Cale: Thanks for the comprehensive explanation. I guess, I will go back to reading this chapter again. It makes more sense to me now
16:29:26 <Cale> cool :)
16:29:32 <lonecub2131> awesome
16:32:12 <Eduard_Munteanu> Hrmpf, can't find a data Coset a =
16:32:13 <Eduard_Munteanu> data Setoid k a whereV Setoid :: (Ord k, Monoid (f a)) => (a -> k) -> Map k (f a) -> Setoid k a
16:32:18 <Eduard_Munteanu> Blargh
16:33:00 <Eduard_Munteanu> Wrong paste... I was saying I can't find a  (k -> a -> (k', b)) -> Map k a -> Map k' b
16:33:56 <Cale> Eduard_Munteanu: any such operation will not be any more efficient than just converting back and forth from a list
16:34:07 * hackagebot hdocs 0.2.0.0 - Haskell docs tool  http://hackage.haskell.org/package/hdocs-0.2.0.0 (AlexandrRuchkin)
16:34:50 <Eduard_Munteanu> Cale: well, in my case I want something like  (a -> k') -> Setoid k a -> Setoid (k, k') a
16:34:53 <Xupet> can someone help me?
16:35:00 <Xupet> whats wrong with this code?
16:35:01 <Xupet> http://lpaste.net/3870500707543023616
16:35:02 <Eduard_Munteanu> Cale: I figure that would be possible
16:35:24 <Eduard_Munteanu> Blargh, not the Setoid thing again. /me is tired
16:35:47 <Cale> Xupet: What error are you getting?
16:35:48 <Xupet> i get erros like not in scope data constructors "var"
16:36:02 <Cale> Xupet: What's the data declaration for Expr?
16:36:13 <Eduard_Munteanu> refine :: (a -> k') -> Map k [a] -> Map (k, k') [a]
16:36:31 <Eduard_Munteanu> I wanted to implement that with some sort of key-value-combining function.
16:36:35 <Xupet> Data.maybe?
16:36:45 <Cale> also, "var" can't be a data constructor because it starts with a lowercase letter, but in order to get a message like that, I suspect the error actually prints it as Var
16:36:55 <Xupet> ye Var
16:37:05 <Cale> Xupet: No, look for a line which starts with 'data Expr ='
16:37:39 <Cale> (or just paste your whole module, so that I can try to compile it)
16:38:13 <Xupet> http://lpaste.net/2798813209350373376
16:38:16 <Cale> If this *is* your whole file, then the reason you're seeing an error like that is because the Expr data type hasn't been defined.
16:39:11 <Xupet> how do i define that?
16:39:14 <Xupet> really new to this
16:39:28 <Cale> Well, guessing at what this code intends, you might have:
16:40:00 <Cale> data Expr = Num Double | Add Expr Expr | Mul Expr Expr | Sin Expr | Cos Expr | Var
16:40:30 <Cale> This will simultaneously define the type Expr, and the values Num, Add, Mul, Sin, Cos and Var
16:40:56 <Cale> All but the last of those will be functions having the given types as the types of their parameters, e.g.  Add :: Expr -> Expr -> Expr
16:41:03 <Cale> and Num :: Double -> Expr
16:41:38 <Xupet> Ok it works in the terminal now
16:41:41 <Xupet> but if i want to try it now?
16:41:45 <Cale> try
16:41:53 <Xupet> should i just write eval (Add 5 5)
16:41:58 <Cale> eval (Add Var Var) 3
16:42:04 <Cale> Or
16:42:14 <Cale> eval (Add (Num 5) (Num 5)) 0
16:42:51 <Xupet> why is it a 0 at the end+
16:43:04 <Xupet> why not just eval (add (num5) (num5)=
16:43:13 <Cale> Well, that parameter gives the value of any occurrences of Var in the expression
16:43:40 <Cale> Even if the expression doesn't make use of the Var constructor, you still have to give that parameter
16:43:56 <Xupet> ok so i could just write any number there?
16:44:00 <Cale> yeah
16:44:02 <Xupet> nice
16:44:03 <Cale> try
16:44:05 <Xupet> thanks! :)
16:44:15 <Cale> eval (Mul (Num 10) Var) 6
16:45:04 <Cale> One way to look at this is that eval (Mul (Num 10) Var) is a function Double -> Double which multiplies by 10
16:45:11 <Cale> i.e. it's the same as (\x -> 10 * x)
16:45:51 <Xupet> Ok got it!
16:46:57 <Xupet> But if i want to try Cos x?
16:47:00 <Xupet> how do i do that
16:47:15 <Xupet> eval (Cos 5)?
16:48:14 <Xupet> eval (Cos (Num 5)) 0
16:48:19 <Xupet> solved it :(
16:48:20 <Xupet> :)
16:52:41 <sajapa> how do you zip two lists that are in the IO monad?
16:54:09 <dobblego> @type liftA2 zip -- sajapa
16:54:10 <lambdabot> Applicative f => f [a] -> f [b] -> f [(a, b)]
16:54:19 <Cale> sajapa: You mean how do you zip the results of executing two IO actions which produce lists?
16:54:52 <Cale> sajapa: You could use liftA2 or liftM2, but you should be aware of the straightforward way, which is just to run them both and return the zip of the results, like this:
16:55:09 <Cale> do xs <- action1; ys <- action2; return (zip xs ys)
16:56:03 <sajapa> dobblego: thank, that worked!
17:02:49 <Xupet> mplement a function   showExpr :: Expr -> String that converts any expression to string. Use as little parentheses as possible. Anyone?
17:03:28 <merijn> Xupet: That sounds like homework, maybe you want to try a little before asking for a solution...
17:04:21 <Xupet> no just random questions, studying for exam
17:05:59 <merijn> Xupet: So what don't you understand about the exercise?
17:06:28 <Xupet> Dont understand the question
17:07:04 <Xupet> i should do a function that?..
17:07:50 <jfischoff> it wants you to take advantage of precedence to avoid parens I think
17:09:02 <Rarrikins> Xupet: Do you understand the conversion part?
17:37:03 <brainacid> to me functional coding is like chunking from neurolinguistic programming
17:37:22 <brainacid> It so elegant and powerful
17:37:58 <brainacid> I recommend The Craft of Functional Programming 2ndEd to all Haskell newbie
17:39:14 * hackagebot socks 0.5.3 - Socks proxy (version 5) implementation.  http://hackage.haskell.org/package/socks-0.5.3 (VincentHanquez)
17:41:31 <skyflash> Does anyone know how to use an IO action (like getCurrentTime) in a QuickCheck generator?
17:41:50 <skyflash> Pulling my hair out on that one
17:42:11 <kfish> skyflash, what is the type of a QuickCheck generator?
17:46:03 <skyflash> kfish Gen a  (Quickcheck has its monad for generators, within which there are a bunch of combinators for producing test values from things like a random number stream)
17:46:36 <Cale> You can't do IO inside a Gen
17:46:53 <Cale> Internally, Gen a is the same as StdGen -> Int -> a
17:46:57 <skyflash> Cale: that's what it looks like
17:47:09 <Cale> However, why did you want to do IO inside a Gen?
17:47:36 <Cale> You can do IO inside a Prop
17:47:45 <Cale> (which is an instance of Testable)
17:47:56 <skyflash> Cale: well I might be subverting QuickTime a little, but I'm using the generators (arbitrary) to produce test values to send off onto a message queue
17:48:29 <zRecursive> :t (<*)
17:48:29 <lambdabot> Applicative f => f a -> f b -> f a
17:48:37 <Cale> morallyDubiousIOProperty :: Testable prop => IO prop -> Property
17:48:38 <Cale> heh
17:48:59 <kfish> skyflash, so why do the generators need to do IO? can't you just get a value from one, then send that using IO?
17:49:05 <skyflash> Cale: I just wanted one field to have the current time, rather than generating an offset from some epoch time (which I suppose I could do 'purely')
17:50:31 <Cale> Maybe write a coarbitrary instance for the time datatype you're using
17:50:39 <Cale> and use arbitrary to get a function of that type
17:50:40 <Cale> time*
17:50:55 <merijn> edwardk: "I've referred this question to the core libraries committee" <- aren't you on the core libraries committee nowadays? :p
17:51:13 <edwardk> merijn: "and recused myself from the discussiom"
17:51:27 <skyflash> Cale: OK, that means reading a bit more of the Quickcheck docs to figure out coarbitrary
17:51:30 <tac-tics> Where the heck do you need to put the makeLenses macro to make Template Haskell happy?
17:51:34 <merijn> edwardk: Aww, not it's less amusing :<
17:51:37 <merijn> s/not/now
17:51:51 <edwardk> i chair the committee, but i was also the most vocal proponent of it the first time around.
17:52:01 <Cale> skyflash: coarbitrary :: a -> Gen c -> Gen c
17:52:24 <brainacid> its recommended to declare the types yes??
17:52:36 <brainacid> or be lazy
17:52:36 <Cale> skyflash: The basic idea is to do something kind of random to an arbitrary generator based on the value of type a
17:52:53 <edwardk> i was the one who unilaterally said we shouldn't do it, despite the fact that it was yitz's proposal, not my own. in my personal capacity i'm for it. in my chair capacity i'm more neutral.
17:52:57 <brainacid> Will it be higher performance declaring or lazy>
17:53:06 <merijn> brainacid: It's recommended to declare the types
17:53:18 <Cale> skyflash: This is how random functions are constructed -- they use coarbitrary on their arguments to modify the generator which will generate their results in a predictable and repeatable fashion
17:53:26 <skyflash> Cale: OK, thanks... time to get reading.  I suppose if it lets me do something IO-ish in the "a", then maybe I can do what I want
17:53:31 <brainacid> rosebud :: String -> String
17:53:33 <Cale> No, it doesn't
17:53:35 <merijn> brainacid: Without types it's frequently hard to see what's going on, plus it helps check that you didn't write wrong (but still typechecking) code
17:53:43 <Cale> But it means you don't have to
17:53:47 <brainacid> Function rosebud is of type string returning string??
17:53:51 <merijn> brainacid: Yes
17:53:54 <Cale> Because you can generate a random function of time
17:54:10 <brainacid> actually
17:54:10 <Cale> which means you can execute getCurrentTime elsewhere, and pass the result to that function.
17:54:15 <brainacid> rosebud :: String -> String -> String
17:54:20 <tac-tics> ack, why is template haskell so damn picky about the order your lines go in?
17:54:26 <brainacid> Function rosebud is of type string  taking an argument string and returning string??
17:54:42 <Cale> coarbitrary will usually be built up from variant and >< along with other coarbitrary instances
17:54:52 <Cale> variant :: Integral n => n -> Gen a -> Gen a
17:54:59 <Cale> (><) :: (Gen a -> Gen a) -> (Gen a -> Gen a) -> Gen a -> Gen a
17:55:18 <merijn> brainacid: No, it's "String -> String -> String" == "String -> (String -> String)", that is, it's a function that takes a String and returns a function that takes a String and returns a String
17:55:19 <Cale> variant will take a number of any integer-like type, and produce one of these generator-modifying functions
17:55:34 <skyflash> Cale: hmm, OK, well you've given me a direction to investigate.   Off to play... thanks.
17:55:40 <Cale> >< will take two generator modifying functions and twist them together somehow
17:55:59 <brainacid> merijn, Thanks !
17:56:23 <Cale> :t getCurrentTime
17:56:24 <lambdabot> Not in scope: `getCurrentTime'
17:56:59 <ski> @index getCurrentTime
17:56:59 <lambdabot> bzzt
17:57:03 <ski> @hoogle getCurrentTime
17:57:04 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
17:57:04 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
17:57:14 <Cale> Hey, what happened to the time library on hackage?
17:57:36 <Rarrikins> http://hackage.haskell.org/package/old-time-1.0.0.3/docs/System-Time.html
17:57:43 <Zer000> how come >> for the IO monad is defined like this:  (>>) a1 a2 = a1 >>= (\x -> a2)    and not simply (>>) a1 a2 = a2 or something?
17:57:59 <Rarrikins> http://www.haskell.org/ghc/docs/7.0.2/html/libraries/time-1.2.0.3/Data-Time.html
17:58:00 <shachaf> Zer000: Because those are different?
17:58:10 <shachaf> Zer000: This definition is good for any monad, by the way, not just IO.
17:58:17 <hpc> Zer000: same reason (+) x y /= y
17:58:27 <Cale> instance CoArbitrary Day where coarbitrary (ModifiedJulianDay n) = variant n
17:58:31 <shachaf> So I recommend taking a simpler one. IO is magic and a very unusual monad.
17:58:46 <ski> @check \x y -> (+) x y == y
17:58:46 <Zer000> oh shoot, i forgot a1 and a2 are types, not arguments
17:58:49 <lambdabot>   *** Failed! Falsifiable (after 4 tests and 5 shrinks):
17:58:49 <lambdabot>  1
17:58:50 <lambdabot>  0
17:58:50 <Rarrikins> Zer000: It still needs to perform a1.
17:58:58 <shachaf> Zer000: a1 and a2 are arguments.
18:00:01 <Cale> instance CoArbitrary DiffTime where coarbitrary dt = coarbitrary (show dt) -- kind of dumb, but it'll work
18:00:41 <Cale> instance CoArbitrary UTCTime where coarbitrary (UTCTime day dt) = coarbitrary day >< coarbitrary dt
18:01:00 <Cale> skyflash: ^^
18:01:04 <Cale> Something like that
18:01:05 <ski> is `><' composition ?
18:01:14 <Cale> ski: almost but not quite
18:01:22 <skyflash> Cale: yes, thanks.  You're way ahead of me here, but I'm watching !
18:01:31 <Cale> ski: There's an extra random variant in between
18:03:00 <Cale> You could also go with something like  coarbitrary dt = coarbitrary (toRational dt)
18:03:14 <Cale> for the DiffTime instance
18:03:29 <Cale> might be a little better than show
18:07:09 <Cale> skyflash: It's worth noting that this coarbitrary business for generating random functions is one big reason why Gen can't have IO in it
18:07:31 <skyflash> OK
18:07:32 <brainacid> whats this mean map :: (a -> b) -> [a] -> [b]?
18:08:09 <Cale> skyflash: In order that the produced random functions actually be functions (i.e. give you the same results for the same inputs each time), the generators will have to reliably produce the same results for the same random seed.
18:08:30 <brainacid> function map is of type tuple taking a tuple as parameter and returning individual characters????
18:08:38 <Cale> brainacid: It means that map takes a function from a's to b's, and a list of a's, and produces a list of b's.
18:08:53 <brainacid> Oh
18:08:57 <brainacid> Thanks Cale
18:08:57 <Cale> There are no tuples involved.
18:09:08 <geekosaur> try reading it as: (a -> b) -> ([a] -> [b])
18:09:08 <skyflash> Cale: Yes, I haven't used quickcheck much, but I'm aware that you split a stream of randoms and destribute the values across value generators
18:09:25 <Cale> You can also think of it as taking a function from a's to b's and giving a function from lists of a's to lists of b's.
18:09:58 <brainacid> a and b meaning two different types: like Int and Char
18:10:06 <brainacid> ???
18:10:11 <Cale> brainacid: Right, any two types whatsoever.
18:10:46 <brainacid> map 3 t
18:10:47 <brainacid> ?
18:10:53 <Cale> (map doesn't know or care what the types a and b are, since values of all types in Haskell have a uniform representation)
18:10:55 <Cale> hm?
18:10:58 <ski> > (map sum . reverse . map digitToInt . words) "12 345 6"
18:11:00 <lambdabot>   Couldn't match type `GHC.Types.Int' with `[b0]'
18:11:01 <lambdabot>  Expected type: GHC.Types.C...
18:11:01 <Zer000> shachaf, thanks but I still don't get it. Both are functions that take two args only give back the second one. You say they are different but I don't see how. Obviously the bind operator is doing something, but if we aren't getting the result of that back, only a2 :/
18:11:01 <Cale> > map (*10) [1,2,3,4,5]
18:11:02 <lambdabot>   [10,20,30,40,50]
18:11:25 <Cale> > map reverse ["here", "are", "some", "words"]
18:11:26 <lambdabot>   ["ereh","era","emos","sdrow"]
18:11:48 <Cale> > map length ["here", "are", "some", "words"]
18:11:49 <lambdabot>   [4,3,4,5]
18:11:49 <ski> > (map (sum . reverse . map digitToInt) . words) "12 345 6"
18:11:50 <lambdabot>   [3,12,6]
18:11:53 <brainacid> > map zipWith ["hello" "crazy" "world"]
18:11:54 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]
18:11:54 <lambdabot>                             ...
18:11:57 <brainacid> lol
18:12:00 <shachaf> Zer000: Do you see the difference between: f x y = foo x (\z -> y) and g x y = y ?
18:12:19 <Cale> brainacid: note that you left the commas out of your list
18:12:23 <brainacid> > let x = map (zipWith ["hi" "crazy" "world"])
18:12:24 <lambdabot>   not an expression: `let x = map (zipWith ["hi" "crazy" "world"])'
18:12:38 <brainacid> I see
18:12:44 <brainacid> this language is fun
18:12:47 <Cale> (but also zipWith is probably not going to be happy to get a String as its argument)
18:12:48 <brainacid> its the only one I know
18:13:06 <brainacid> zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
18:13:13 <Cale> zipWith wants a function
18:13:16 <brainacid> seems the same as map
18:13:18 <brainacid> I see
18:13:23 <Cale> It's related, certainly
18:13:32 <Cale> > zipWith (+) [1,2,3] [40,50,60]
18:13:33 <lambdabot>   [41,52,63]
18:13:42 <brainacid> Cale ur a genius
18:13:51 <Zer000> shachaf: i see the difference, but I don't see the point of calling foo if you aren't doing anything with the result.
18:13:59 <brainacid> I just started to code 4 days ago and Im in love with Haskell
18:14:03 <shachaf> What result?
18:14:09 <shachaf> Let's be more concrete.
18:14:12 <shachaf> foo = map
18:14:21 <Cale> brainacid: cool! I'm happy that you're enjoying it.
18:14:32 <shachaf> Or flip map or something.
18:14:35 <shachaf> f xs y = map (\_ -> y) xs
18:14:42 <shachaf> g xs y = y
18:14:58 <shachaf> (OK, that's a type error because I didn't do the concat. But whatever.)
18:15:09 <shachaf> Do you see the difference there?
18:15:21 <brainacid> Cale, and this book I found is divine.
18:15:25 <Zer000> just a sec i'm pretty new to haskell so it takes me a bit to decipher the meaning
18:15:48 <shachaf> Also, maybe you just shouldn't be worrying about this function at this point.
18:16:00 <brainacid> [[a]] -> [a]
18:16:08 <brainacid> meaning a list of a list
18:16:14 <brainacid> returning a list
18:16:25 <brainacid> concat :: [[a]] -> [a]
18:17:41 <DanC> I'm trying to read Desugar.hs, and I get lost at line 32. Whence comes Prop?
18:17:42 <DanC> https://github.com/brownplt/LambdaJS/blob/master/haskell/src/Language/LambdaJS/Desugar.hs
18:18:26 <shachaf> DanC: It's imported from somewhere.
18:18:44 <shachaf> You're in a better position than we are to find out!
18:18:50 <Zer000> shachaf: so correct me if i'm wrong: f is a function that takes a list and a value and gives you back a list of length xs where each element is y, and the second example is just y?
18:19:16 <shachaf> Zer000: Right.
18:19:20 <shachaf> Completely different, right?
18:19:23 <tac-tics> Is there an extension that gives you syntactic sugar for Bool-valued predicates on the choice of constructor?
18:19:53 <DanC> shachaf, so there's no way to tell from looking at Desugar.hs which module it's imported from?
18:20:19 <shachaf> DanC: You could type :i Prop in ghci.
18:20:32 <shachaf> In this case it comes from http://hackage.haskell.org/package/language-ecmascript-0.9/docs/Language-ECMAScript3-Syntax.html#t:Prop
18:20:54 <shachaf> But if the import doesn't mention it explicitly then there's no easy way from just looking at the code.
18:21:04 * DanC holds up a cross at such magic
18:21:05 <shachaf> Fortunately computers and programs like ghci exist to figure it out for us.
18:21:11 <DanC> how'd you find that?
18:21:29 <Zer000> oh ok! thank you. so the result of >> is not actualy a2 as it was given - its of the same type but it could be a different value.
18:21:32 <DanC> so I have to load the whole program to figure out where stuff comes from? I can't seem to get used to this idea
18:21:39 <[swift]_> i'm running into some trouble trying to create a [Foo a] and store both Foo Bar's and Foo Baz's in it. I thought that RankNTypes (i.e., an explicit forall) would let me do this as long as I don't need to do anything that wouldn't work for any value of a. am I wrong that this should work?
18:21:55 <DanC> I don't have the program loaded. I'm not even sure I have ghci installed
18:22:01 <DanC> downloaded, rather
18:22:01 <shachaf> DanC: As opposed to, say, C or something?
18:22:41 <DanC> I guess it's a lot like C.
18:22:54 <Hodapp> everyone loves C.
18:22:55 <shachaf> [swift]_: You're wrong, yes.
18:23:14 <DanC> I've spent a lot of time with python, where it's typical to chase xyz.abc back to xyz
18:23:15 <shachaf> [swift]_: What you want is an existential, not a universal. GHC doesn't have first-class existentials.
18:23:20 <shachaf> s/you want/you're asking for/
18:23:41 <geekosaur> ...and while there are ways to force it to work, it doesn't generally do what you hope
18:23:42 <shachaf> DanC: You can do that in Haskell too if you want. import qualified ... as ...
18:24:06 <intrados> DanC: Ideally, you wouldn't have load the program to figure it out. http://www.haskell.org/haskellwiki/Import_modules_properly
18:24:06 <intrados> If the author had used a different import style, the source would have been more obvious
18:24:09 <DanC> yeah, well, having that option doesn't help me read other people's code
18:24:13 <shachaf> DanC: Some people do it, some people don't. Probably it's more common that people don't. The default import in Haskell is like "from ... import *" in Python.
18:24:22 <[swift]_> shachaf: sadness! i know there's an extension for that as well, but i've never had to use it before. i guess now's the time
18:24:23 <shachaf> Yes. Well. So it goes.
18:24:25 <sirspazzolot> have any of you worked with the ncurses package in hackage? looking to do nested menus with it, but I'll stick with urwid/python if that's too messy
18:24:47 <shachaf> [swift]_: Like geekosaur says, it's quite possible that it doesn't do what you want. And at any rate you'd need to make a new data type for it.
18:25:07 <[swift]_> shachaf: yup, i'm noticing that now. requires more plumbing than i'd hoped =\
18:25:35 <shachaf> DanC: In this case I found it by looking at the code and guessing.
18:25:41 <brainacid> best editor for non-programmer
18:25:42 <DanC> interesting, intrados... so explicitly saying where stuff comes is a documented best practice in haskell too. It just doesn't seem to be as common as in python.
18:26:02 <brainacid> bluefish dont have syntax highlights
18:26:06 <shachaf> What a surprise, that wiki page is mostly written by Henning.
18:26:07 <sirspazzolot> brainacid: notepad++ is nice. syntax highlighting, line numbers, lightweight, not complex
18:26:12 <spaceships> [swift]_: do you think that style should be used with common modules such as Control.Monad or Control.Monad.State etc
18:26:24 <brainacid> sirspazzolot, I use that in Windows 8
18:26:26 <brainacid> cool
18:26:28 * DanC tends to michevious dogs...
18:27:09 <shachaf> DanC: "documented best practice" by some people.
18:27:48 <DanC> yes, well documented at http://www.haskell.org/haskellwiki/Import_modules_properly
18:28:01 <brainacid> Best editor in Linux
18:28:06 <brainacid> notepad is for windows
18:28:08 <brainacid> lol
18:28:32 * DanC scrolls up...
18:28:43 * DanC doesn't get the Henning reference...
18:28:47 * shachaf should write a wiki page that gives the opposite advice at http://www.haskell.org/haskellwiki/Import_modules_correctly
18:29:56 <DanC> why a separate page? surely the point of a wiki is to edit in-place
18:30:18 <xxen> Better troll results
18:30:58 <Zer000> brainacid: just bite the bullet and learn vim
18:31:18 <sirspazzolot> brainacid: iunno, gedit? I hear great things about Sublime Text, but I don't know how user-friendly the defaults are
18:31:22 <brainacid> Zer000, Its nice but I like color...Ive used vim before
18:31:36 <spaceships> brainacid: vim has color these days
18:31:36 <xxen> I think kate is better than gedit
18:31:41 <DanC> wikis tend to work well in documenting community consensus. But if a community hasn't come to consensus, the don't work so well.
18:31:48 <sirspazzolot> Zer000: I think tackling vim and haskell at the same time will dilute how both are learned
18:32:04 <shachaf> OK, editor arguments?
18:32:09 <sirspazzolot> xxen: never liked KDE myself. and nowadays I don't like gnome anymore
18:32:15 <sirspazzolot> yeah okay this is offtopic sorry I'm done
18:33:25 <Zer000> brainacid: there are LOTS of colorscheme options for vim. http://vimcolorschemetest.googlecode.com/svn/html/index-c.html  and http://www.vimninjas.com/2012/08/26/10-vim-color-schemes-you-need-to-own/ for examples
18:34:21 <Zer000> btw does everyone in here religiously use xmonad? :)
18:34:50 <xxen> On linux I use xmonad with gnome :x
18:36:17 <brainacid> Zer000, apt-get install vim-gnome :)
18:36:44 <brainacid> what scheme you use for Haskell Zer000
18:37:25 <Zer000> I uhm... I don't program in haskell (nobody kick me) but I use solarized for Python and web stuff
18:37:26 <sirspazzolot> Zer000: haha I hadn't heard of haskell when I chose my tiling wm. I've been meaning to try xmonad for a while though
18:37:33 <elliott> do we have to transition from editor argument to window manager argument?
18:37:40 <Zer000> http://ethanschoonover.com/solarized
18:37:48 <sirspazzolot> lol at least xmonad is written in haskell
18:38:26 <xxen> yi is also written in haskell
18:49:22 * hackagebot eithers 0.0.0 - Collection of functions for dealing with Either values.  http://hackage.haskell.org/package/eithers-0.0.0 (ChrisDone)
18:49:24 * hackagebot nums 0.0.0 - Handy common number functions  http://hackage.haskell.org/package/nums-0.0.0 (ChrisDone)
18:49:26 * hackagebot lists 0.0.0 - Functions for dealing with lists  http://hackage.haskell.org/package/lists-0.0.0 (ChrisDone)
18:49:28 * hackagebot bools 0.0.0 - Functions for dealing with bools  http://hackage.haskell.org/package/bools-0.0.0 (ChrisDone)
18:49:30 * hackagebot texts 0.0.0 - Common things for text  http://hackage.haskell.org/package/texts-0.0.0 (ChrisDone)
18:49:40 <dolio> wat
18:50:35 <dolio> Is chrisdone squatting on edwardk package names to sell later?
18:50:43 <edwardk> hahahahaha
18:50:59 <enthropy> category CATEGORY too
18:51:05 <xxen> They got a nice category
18:51:19 <edwardk> i think h may be splitting up that hug package of helpers of his finally
18:51:40 <edwardk> its taking the first step to becoming a butterfly
18:52:36 <chrisdone> edwardk: yeah =( i finally sat down to go through all my codebases and start extracting the .Extra modules out. with hackage2's more flexible facilities it's less costly to make a package that can be deprecated later =)
18:53:02 <edwardk> chrisdone: makes sense
18:54:32 * hackagebot blaze 0.0.0 - Common blaze operations  http://hackage.haskell.org/package/blaze-0.0.0 (ChrisDone)
18:54:34 * hackagebot string 0.0.0 - Common things for strings  http://hackage.haskell.org/package/string-0.0.0 (ChrisDone)
18:54:40 <acowley> wow
18:54:53 <chrisdone> i've got way more stuff to add to these, so don't complain how small they are >_>
18:55:09 <chrisdone> man, hackage2 is super fast at building documentation now!
18:55:09 <acowley> This must be the biggest name grab we've had
18:55:16 <acowley> yeah, the speed is great!
18:56:08 <Clint> things for strings
18:56:37 <chrisdone> acowley: yeah i've been going through similar packages to collect authors to email to maybe merge into these names (the -extras and -util and such) later
18:57:03 <xxen> Why is trim [Char] instead of String?
18:57:25 <dolio> String is [Char]
18:57:38 <xxen> I know
18:58:02 <xxen> I mean why he uses [Char] instead of String
18:58:22 <chrisdone> xxen: no reason, that'll be one i auto-inserted from ghci instead of typed up
18:58:35 <xxen> okay
18:58:39 * spaceships grins at Data.Texts.bigUp
18:58:43 <chrisdone> xxen: i'll change it for consistency, after i implement a fast version of that function
18:59:14 <dolio> Make sure lists has an efficient powerslice.
18:59:22 <dolio> It's the sign of a legit language.
19:00:26 <chrisdone> dolio: what's a powerslice?
19:00:43 <chrisdone> spaceships: marketing folks like that stuff =p
19:01:21 <spaceships> chrisdone: aha.. its cute nonetheless ;)
19:01:58 <xxen> is it based on xkcd?
19:02:25 <dolio> chrisdone: https://github.com/ermine-language/ermine-legacy/blob/master/src/main/resources/modules/List.e#L146
19:03:35 <dolio> It's this function we found in some library of crazy functions on Hackage.
19:04:43 <dolio> The original is implemented by generating all pairs of indices and cutting the original list for each pair.
19:04:49 <dolio> But mine is more efficient.
19:06:06 <chrisdone> ahh, nice implementation =)
19:06:36 <chrisdone> does your lang not have a (.) operator?
19:06:52 <chrisdone> although the lambda syntax is nice
19:07:11 <dolio> It does, if you look below.
19:08:08 <chrisdone> ah, i see a use in spanM
19:08:16 <dolio> I don't know why I didn't use it at the time.
19:08:32 <chrisdone> no type-classes either. interesting
19:08:34 <dolio> It is possible that (.) didn't exist when I wrote that.
19:08:42 <dolio> Type classes are a work in progress.
19:08:46 <chrisdone> what's the experience like passing dictionaries around?
19:08:49 <chrisdone> gotcha
19:08:52 <dolio> It's terrible. :)
19:08:55 <chrisdone> haha
19:24:49 <chrisdone> does this exist anywhere already? http://lpaste.net/63372
19:26:14 <Polarina> chrisdone, http://hackage.haskell.org/package/stm-2.4.2/docs/Control-Concurrent-STM-TQueue.html
19:27:31 <chrisdone> Polarina: can you write lookQueue in terms of that?
19:30:24 <Polarina> chrisdone, not that I am aware of. But you could wrap TQueue in a data structure that keeps a track of a list alongside of it.
19:31:40 <Polarina> chrisdone, TQueue is implemented with lists, it just doesn't expose them. It'd probably be easier to patch the package.
19:34:19 <chrisdone> nod
19:35:52 <brainacid> whats with using : x (x+1)
19:36:08 <brainacid> I see it a lot in code
19:36:15 <ReinH> brainacid: can you give an example
19:36:16 <brainacid> like
19:36:30 <brainacid> invertColor = map (map Invert)
19:36:42 <ski> if
19:36:48 <ski>   invert :: Foo -> Bar
19:36:48 <ski> then
19:36:50 <brainacid> inver x = if x =='.' then '#' else '.'
19:36:56 <ski>   map invert :: [Foo] -> [Bar]
19:36:58 <ski> and so
19:37:09 <ski>   map (map invert) :: [[Foo]] -> [[Bar]]
19:37:13 <ReinH> :t map . map
19:37:14 <lambdabot> (a -> b) -> [[a]] -> [[b]]
19:37:32 <ski>   (map . map) invert :: [[Foo]] -> [[Bar]]  -- another spelling of it, as ReinH noted
19:37:32 <ReinH> @pl \xs -> map (map xs)
19:37:33 <lambdabot> map . map
19:38:02 <ski> brainacid : ok, so in that case `Foo' and `Bar' are both `Char'
19:38:02 <brainacid> Im still confused
19:38:08 <brainacid> right
19:38:14 <brainacid> I will follow
19:38:15 <ski> so `inver' translates a single `Char'
19:38:22 <ReinH> > map toUpper "foo"
19:38:23 <lambdabot>   "FOO"
19:38:23 <ski> `map inver' translates a list of `Char's
19:38:27 <brainacid> so map does the whole list
19:38:32 <brainacid> bingo
19:38:37 <ski> `map (map inver)' translates a list of lists of `Char's
19:38:53 <brainacid> because strings are a list of char
19:38:53 <ReinH> > (map . map) toUpper ["foo", "bar"]
19:38:55 <lambdabot>   ["FOO","BAR"]
19:39:22 <ski> > map (map toLower) ["This","is","a","Dream"]
19:39:23 <lambdabot>   ["this","is","a","dream"]
19:39:32 <Rarrikins> > map (map upper) ["O-o"]
19:39:33 <lambdabot>   Not in scope: `upper'
19:39:37 <Rarrikins> > map (map toUpper) ["O-o"]
19:39:38 <lambdabot>   ["O-O"]
19:39:44 <brainacid> toUpper
19:39:45 <ReinH> let shout = map toUpper = map shout ["foo", "bar"]
19:39:48 <ReinH> > let shout = map toUpper = map shout ["foo", "bar"]
19:39:49 <lambdabot>   <hint>:1:25: parse error on input `='
19:39:54 <ReinH> > let shout = map toUpper in map shout ["foo", "bar"]
19:39:55 <ReinH> woops
19:39:56 <lambdabot>   ["FOO","BAR"]
19:39:58 <ReinH> and so on
19:40:06 <brainacid> you guys are so fluent in this
19:40:09 <brainacid> I cant wait
19:40:12 <brainacid> to get there
19:40:15 <ski> practice
19:40:15 <ReinH> brainacid: just keep doing it :)
19:40:36 <brainacid> Now that I have all my ducks in order I can
19:40:50 <ReinH> brainacid: there will always be more ducks
19:41:01 <brainacid> I was having issues with some of the tutorials being to technical and not presenting it logically for me
19:41:17 <brainacid> now I got a great book thats got me practicing
19:41:27 <brainacid> I love this language
19:41:33 <brainacid> its my first one
19:44:31 <ski> brainacid : ooc, which book ? :)
19:44:51 <brainacid> ski, The Craft of Functional Programming 2ed
19:44:58 <ski> that's a nice one
19:45:02 * ski learned from that one
19:45:14 <brainacid> dude im glad I quit
19:45:21 <ski> quit ?
19:45:25 <brainacid> I was so frustrated that I started doing something else
19:45:36 <brainacid> coding is a hobby for me.
19:45:59 <brainacid> I started to play with networking but lost interest quick and came back to coding
19:46:20 <brainacid> so i researched more and found the book
19:46:26 <brainacid> and I am very happy
19:46:27 <brainacid> lol
19:47:53 * ski grins and bounces up and down
19:49:16 <ReinH> :D :D
19:49:33 <ReinH> brainacid: I would also recommend http://www.amazon.com/Haskell-Programming-Second-Edition-Computing/dp/0954300696/ref=pd_bxgy_b_img_y
19:50:07 <sirspazzolot> and of course Learn You A Haskell and Real World Haskell, both available free online
19:50:16 <brainacid> now im playing with it and making chessboards lol with '.' and '#'
19:50:25 <ReinH> brainacid: oh you should watch my screencasts
19:50:26 <brainacid> ReinH, I have it too :)
19:50:40 <ReinH> I need to keep doing those :( :( :(
19:50:57 <brainacid> ReinH, Im just got my first block
19:51:17 <edwardk> ReinH: no no that should be :) :) :)
19:51:44 <edwardk> people avoid doing things they feel :( :( :( about
19:52:58 <chrisdone> :)
19:53:01 <ReinH> edwardk: :) :) :) :)
19:53:04 <Gracenotes> hurrah! I have all of the Haskell Cast to watch now
19:53:11 <ReinH> Gracenotes: yay!
19:53:18 <Gracenotes> anyone here attend it?
19:53:22 <Gracenotes> (presumably)
19:53:41 <ReinH> Gracenotes: the podcast?
19:53:42 * ReinH points at edwardk
19:53:44 <Gracenotes> well, by which I mean the Haskell eXchange or whatsit
19:53:47 <ReinH> oh then no
19:53:51 <edwardk> oh
19:54:01 <ReinH> Gracenotes: they're uploaded now? Where?
19:54:04 <Gracenotes> there's also the podcast, which I've been listening to. I like that very much as well.
19:54:09 <Gracenotes> http://skillsmatter.com/event/scala/haskell-exchange
19:54:10 <ReinH> Gracenotes: ok that's better :p
19:54:10 <Gracenotes> "scala"
19:54:16 <edwardk> ReinH :they managed to start uploading within an hour or two of the talks ending
19:54:21 <edwardk> it was quite impressive turnaround
19:54:22 <ReinH> that site's formatting o_O
19:54:25 <ReinH> edwardk: awesome
19:54:29 * hackagebot texts 0.1.0 - Common things for text  http://hackage.haskell.org/package/texts-0.1.0 (ChrisDone)
19:54:30 * hackagebot string 0.1.0 - Common things for strings  http://hackage.haskell.org/package/string-0.1.0 (ChrisDone)
19:54:49 * Gracenotes meanwhile waits for ICFP/Haskell Symposium talks to be uploaded...
19:55:22 <edwardk> Gracenotes: I mostly want my CUFP talk so I can link it to people
19:55:28 <ReinH> heh
19:55:34 <brainacid> ReinH, whats your review on that book u told me about? is it a lot of math inclined Haskell or programming in general
19:55:46 <Gracenotes> yep, all of em.
19:56:16 <ReinH> brainacid: it introduces a lot of useful math using Haskell
19:56:26 <ReinH> brainacid: and is also a very gentle introduction to equational reasoning and writing proofs
19:56:37 <brainacid> cool
19:56:39 <ski> which book ?
19:56:41 <brainacid> thanks ReinH
19:56:48 <ReinH> ski: haskell road to math
19:56:50 <brainacid> ski, Road to Math, Logic
19:56:51 <ski> ok
19:57:13 <ReinH> well, proofs of the Bird pearls sort at least
19:57:20 <brainacid> I got LYHFGG, YAHT, Oreilly RWOH
19:57:26 <brainacid> that should be plenty for now
19:57:33 <ski> @where HRtML
19:57:34 <lambdabot> I know nothing about hrtml.
19:57:36 <ReinH> brainacid: check out http://haskelllive.com too
19:57:41 <ReinH> brainacid: since you're interested in chess
19:57:44 <brainacid> someone here suggested I learned python and smalltalk
19:58:03 <ReinH> ski: http://www.amazon.com/gp/product/0954300696
19:58:12 <brainacid> ReinH, the xercises in the book ask to make a board. Im not into chess. But thanks anyways
19:58:20 <ReinH> well fine then :p
19:58:21 <brainacid> Everyone here is so polite and helpful
19:58:29 <brainacid> I take that back
19:58:30 <ski> brainacid : at some point, you'll probably want to take a look at Prolog, to get to see what logic programming is about
19:58:31 <brainacid> LOL
19:58:33 <ReinH> brainacid: :p
19:58:40 <brainacid> :P
19:58:44 <brainacid> Prolog
19:58:53 <brainacid> Pro Logic trap
19:58:59 <brainacid> cool
19:59:01 * ski grins
19:59:44 <ski> (there's a ##prolog channel on this network, e.g.)
20:00:07 <startling> sirspazzolot, the reason is that "functor" is sort of a complicated thing outside of haskell.
20:00:25 <ski> however, as you've started learning Haskell, it's probably best if you stick with it for a while, at least until you've learned the basics, before attempting another language
20:00:34 <sirspazzolot> startling: gotcha
20:00:37 <brainacid> ski, I agree
20:00:40 <ski> @where on-functors
20:00:40 <lambdabot> "On Functors" (in C++,Standard ML,Haskell,Prolog) by James Coplien in 2010-05-17 at <http://www.catonmat.net/blog/on-functors/>
20:01:00 <brainacid> ski, when I get this little project in my brain coded then ill move on
20:01:35 <ski> sounds reasonable
20:01:43 <brainacid> ski, I want to read an avi file info and add the length of all avi files in a dir. Just to know how many hours or days of video a person has in a certain dir
20:02:01 <ski> @quote slipped
20:02:01 <lambdabot> SPJ says: Haha this is good news, I have slipped functional programming into your brain without you realising it is something very weird.
20:02:24 <ski> (don't look at the above quote)
20:03:07 <brainacid> @quote weird
20:03:07 <lambdabot> kowey says: all the things with guards are just there to siphon off the weirdos
20:03:14 <brainacid> @quote weird
20:03:17 <lambdabot> bringert says: yay! ghc compiles! now let's see what weird and wonderful panics we get
20:03:36 <ski> @ghc
20:03:37 <lambdabot> Too many parameters for class
20:03:39 <brainacid> The world and my brain is a weird market of exchange
20:04:02 <ski> @quote urk
20:04:02 <lambdabot> ghc says: Urk! Inventing strangely-kinded void TyCon: ZCt{tc a2AN} (* -> *) -> * -> *
20:08:05 <chrisdone> it would be good to explicitly relinquish names on hackage
20:08:08 <Hermit> ski: what quote were you looking for?
20:08:55 <chrisdone> me and mmorrow wrote this when we were haskell newbs http://hackage.haskell.org/package/validate but it's not a package anyone would use these days, but the name is free for anyone to use
20:10:01 <ddfisher> Hi all!  I uploaded a package to hackage last week (a day or two after the transition) and docs still haven't been generated for it. How can I go about diagnosing this?
20:10:16 <chrisdone> (it's been superceded by things like digestive functors/formlets)
20:10:33 <ReinH> chrisdone: there should be an inverse relationship between how newby you are and how common a package name you use
20:10:54 <ReinH> @hackage string
20:10:54 <lambdabot> http://hackage.haskell.org/package/string
20:10:59 * ReinH stares pointedly at chrisdone
20:11:14 <chrisdone> ReinH: you got a better name for general functions that work on String?
20:11:24 <elliott> base
20:11:58 <ReinH> chrisdone: you called your text package texts
20:12:07 <ReinH> but presumably only because text was already taken by... Text.
20:12:12 <chrisdone> ReinH: yup
20:12:13 <ReinH> :p
20:12:24 <Polarina> Should've named it Text
20:12:33 <chrisdone> heh
20:13:19 <startling> chrisdone, I think you should spend less time with edwardk
20:14:22 <startling> ddfisher: try running haddock on your local machine.
20:14:31 <startling> I think if there's an issue, hackage will just fail silently.
20:15:51 <adnap> I just finished watching and understanding Simon's talk on lens. He seems to not know any more than me about the real type signatures in lens (Profunctor, etc.), but it clarified what I already understood and I learned about Traversal.
20:15:54 <chrisdone> startling: i quite like edwardk's naming convention of just calling things what they are =)
20:16:07 <adnap> *he clarified
20:16:13 <enthropy> ddfisher: you can find a log of what hackage tried to do
20:16:27 <ddfisher> enthropy: where?
20:16:29 <ReinH> I realize that the package namespace is larger than the IPv4 namespace
20:16:43 <ReinH> nevertheless I am convinced that edwardk is going to singlehandedly exhaust it first
20:16:57 <chrisdone> does it matter? =)
20:17:04 <enthropy> well there used to be links for such that the old hackage made
20:17:17 <ddfisher> startling: it works for me locally!
20:17:29 <ReinH> adnap: perhaps he knows *slightly* more? ;)
20:17:53 <adnap> ReinH: He said he didn't. He said you might need a Phd to understand the type signatures :P
20:18:17 <ReinH> adnap: hah I haven't seen it. Now I need to.
20:18:19 <startling> ddfisher: dang. no idea.
20:18:29 <adnap> ReinH: I'm sure he knows more about lens though
20:18:31 <elliott> I guess I have a Ph.D., then.
20:18:36 <startling> can I take a lens quiz somewhere and get a Ph.D.?
20:18:47 <adnap> *might*
20:18:49 <ReinH> That's... not how implication works.
20:18:55 <adnap> Notice I used a weasel word
20:19:06 <startling> adnap, might makes right dude.
20:19:06 <ddfisher> startling: okay, thanks for the idea!
20:19:39 <chrisdone> Let's use weasel words to solve the PVP debate!
20:19:55 <elliott> ReinH: if you nee a phd to understand the types then (understands_types -> has_phd). I understand the types, therefore...
20:20:03 <adnap> Maybe there could be a baby lens package that has less complicated type signatures and less generality and easier to understand documentation
20:20:25 <ReinH> startling: You can get a Ph.D. in affirming the consequent.
20:20:35 <adnap> elliott: No. Phd -> understand types. understand types -> ?
20:20:46 <startling> adnap: that's not what "needs" means.
20:20:46 <ReinH> elliott: you too.
20:20:58 <elliott> adnap: ?
20:21:01 <ReinH> startling: "might need"
20:21:09 <elliott> adnap: phd -> understands types means "If you have a Ph.D. then you understand the types."
20:21:28 <elliott> "You need a Ph.D. to understand the types" means that you do not understand the types unless you have a Ph.D., i.e. ~phd -> ~understand_types, i.e., clasically, understand_types -> phd.
20:21:29 <adnap> elliott: Oh, I see
20:21:31 <enthropy> ddfisher: the logs on old hackage used to be in places like http://old.hackage.haskell.org/packages/archive/ipopt-hs/0.0.0.0/logs/failure/ghc-7.6
20:21:36 <joelteon> would it be helpful to anyone for me to provide a module that uses unicode characters from multiple ranges in module/identifier/operator names?
20:22:06 <startling> ReinH, maybe you should get a Ph.D. in denotational semantics.
20:22:16 <ReinH> startling: touche
20:22:25 <adnap> I was thinking "might need" means Ph.D is one route to understanding the types.
20:22:30 <adnap> But there are others.
20:22:33 <ReinH> +1
20:22:52 <ReinH> 22:51:38           ReinH : startling: "might need"
20:23:06 <startling> I read that as "it might be the case that ..."
20:23:08 <ReinH> I also love that we are arguing about this right now
20:23:19 <startling> I'm not sure the other sense makes sense.
20:23:43 <ReinH> so then the strongest implication is "it might be the case that you have a Ph.D."
20:23:58 <startling> Yep.
20:24:07 <adnap> If self-teaching fails, you get a Ph.D instead to undestand the types and Ph.D => understanding types and successfully self-taught => understanding types
20:24:14 <startling> anyway.
20:24:46 <ReinH> startling: Enjoy Schrodinger's Ph.D.
20:25:46 <adnap> I wish edwardk could give easy-to-understand communications
20:25:55 <edwardk> ?
20:26:00 <edwardk> sorry
20:26:04 <adnap> Like Simon did
20:26:08 <dobblego> adnap: you are confusing "having a PhD" with "having to do hard work"
20:26:18 <adnap> dobblego: I was just quoting Simon!
20:26:23 <adnap> *paraphrasing
20:26:59 <adnap> edwardk: I'm not saying your incapable, but that I haven't seen any
20:27:01 <dobblego> ok, excuse my exhaustion
20:27:05 <edwardk> simon is remarkably good at making topics accessible
20:27:29 <adnap> I guess when you make something, it's hard to understand it from the outside in
20:27:35 <edwardk> i'm more focused on doing interesting research and dragging along a few dozen people in my wake that can figure out how to explain everything to everyone else =)
20:27:40 <adnap> And then give that process to someone else
20:27:45 <startling> in the old days edwardk used to give lens tutorials to every clown who walked into this room. Now he's got better things to do I guess.
20:28:12 <startling> hey edwardk can you explain machines to me
20:28:36 <edwardk> startling: its more that shachaf and everyone else have gotten pretty good at it, and there are now videos and posts galore on it on the internets
20:28:45 <adnap> edwardk: Not really
20:28:46 <edwardk> startling: to do that i'd have to know what it wants to be when it grows up
20:28:47 <startling> edwardk: (I know, I'm joking.)
20:28:56 <startling> edwardk, how about a GUI library
20:29:12 <adnap> Most of the information I have found is at the introductory level too
20:29:23 <startling> I feel like you could make a "modal" GUI out of Mealy pretty nicely.
20:29:28 <adnap> It doesn't explain the real type signatures in lens
20:29:34 <chrisdone> edwardk: how come your unification package isn't on hackage?
20:29:38 <adnap> Like Setting, Profunctor, etc.
20:30:01 <startling> adnap, Profunctor isn't reall important for lenses
20:30:05 <edwardk> chrisdone: i think i put it on github because someone asked if it was possible to do 2-level unification in haskell 98 and i said i had code lying around
20:30:13 <edwardk> chrisdone: i'm not sure i'd advocate doing it that way
20:30:13 <dobblego> adnap: try using :i at ghci, it is very good at helping you do work of understanding
20:30:27 <chrisdone> edwardk: ah, ok
20:30:35 <dobblego> e.g. :i Setting
20:30:52 <edwardk> adnap: the workshop i gave at lambdajam used all the real names and types for everything, but sadly it wasn't recorded.
20:30:53 <adnap> startling: It's in the type signature, so, how am I supposed to understand a type signature unless I can somehow know how these classes boil down into a more specific easy-to-understand type signature?
20:30:59 <edwardk> it was also something like 3 and a half hours long
20:31:08 <startling> adnap, (->) is a Profunctor.
20:31:13 <adnap> startling: I know
20:31:23 <Hafydd> s/b e
20:31:31 <ski> Hermit : the one i quoted
20:31:58 * ski . o O ( s/Profunctor/Difunctor/ )
20:32:09 <adnap> startling: I figured that out from trying to decode over
20:32:14 <edwardk> adnap: a profunctor is lik a piece of taffy. you can stretch it with functions on either end. but to make a crappy metaphor worse you can't stick two of these pieces of taffy together without something more. =)
20:32:24 <dobblego> :i Profunctor will tell you all the instances
20:32:28 <adnap> startling: But then I kept forgetting everything when I got back to the real type signature
20:32:54 <dobblego> put "the things you forget" in a comment nearby the thing to be understood, until such time as you have internalised that thing, then delete it
20:32:58 <startling> adnap, well, the Profunctor thing is for "extra" information. As a lens you normally just use the (->) instance. You can do "extra" things, though -- e.g. for Prisms, you use a superclass of Profunctor called Choice to be able to turn the prism around.
20:33:04 <edwardk> adnap: see, finding good metaphors is not my strong suit ;)
20:33:18 <edwardk> > _Left # 4
20:33:20 <lambdabot>   Left 4
20:33:31 <adnap> Yeah, so I wish there was like a "baby lens" package that was less general and had simpler type signatures
20:33:31 <edwardk> > Left 4 ^? _Left
20:33:32 <lambdabot>   Just 4
20:33:38 <edwardk> adnap: there is
20:33:42 <edwardk> adnap: lens-family
20:33:50 <edwardk> its lens, family style
20:33:51 <brainacid> anyone with Java experiencie
20:33:57 <Demos> I have some
20:34:09 <dobblego> brainacid: yes, we can take it to #haskell-blah if you like
20:34:19 <edwardk> adnap: be warned its a twisty maze of type synonyms all the same
20:34:32 <adnap> edwardk: It doesn't look general enough. There's no Traversals
20:34:35 <edwardk> amusingly i wrote lens in protest over the complexity of lens-family
20:34:51 <startling> adnap: do you know that :i in ghci shows you the definition of a type synonym?
20:35:31 <adnap> startling: Yeah
20:35:49 <edwardk> adnap: it is set up in such a way that traversals fit its form, it just doesn't offer any
20:37:49 <adnap> I think I would just like more commented out type signatures in the documentation, like substituting any Profunctor for (->)
20:38:32 <edwardk> feel free to add more signatures to the haddocks in lens. glguy even typechecks the ones we have
20:38:42 <dobblego> adnap: do it in your head and if that is too difficult, write it in a comment and if that is hard, write it in your own dependent library
20:39:03 <edwardk> er do try to show the aliases for them to the point where we have several thousand extra type signatures in there, but they are a real pain in the ass to write
20:39:50 * applicative considers that this fancy free monad concept is too theoretical; he proposes the free monad with prompt finalization support 
20:39:54 <applicative> newtype FreeT f m a = FreeT {runFreeT :: Either a (f (m (), FreeT f m a))}
20:40:03 * applicative is working on leftover support
20:40:55 <edwardk> of course a guy named applicative would find a monad too theoretical ;)
20:41:10 <applicative> whats up with this bind stuff
20:42:21 <applicative> newtype FreeTwithLeftovers f m a = FreeT {runFreeT :: Either (a, Maybe a) (f (m (), FreeT f m a))}
20:42:30 <applicative> no, not quite
20:44:18 <applicative> newtype FreeTwithLeftoversWeb f m a = FreeT {runFreeT :: Either (a, Maybe (a, Maybe URL)) (f (m (), FreeT f m a))}
20:45:40 * applicative seems to have read a few too many conduit v pipes posts lately
20:46:07 <ReinH> edwardk: yes, I suspect he might be biased in this regard
20:46:53 <ReinH> I kind of want to get Gabriel and Michael on the podcast to fight^H^H^H^H^H discuss them
20:48:46 <applicative> I wonder if I could implement Either a b in terms of Proxy x y z w m r
20:49:33 <Polarina> applicative, don't even try.
20:49:39 * hackagebot lists 0.1.0 - Functions for dealing with lists  http://hackage.haskell.org/package/lists-0.1.0 (ChrisDone)
20:49:45 <ReinH> applicative: put the ghc down and step away slowly
20:49:51 <applicative> hah
20:50:12 <ReinH> chrisdone: of COURSE you also have a package called lists
20:51:02 <applicative> ReinH: and at this revision rate he'll be at lists-10.9.9 in couple weeks
20:51:57 <enthropy> at least nobody has claimed http://hackage.haskell.org/package/package
20:52:00 <chrisdone> ReinH: ideally it should be a one-stop shop: http://hackage.haskell.org/package/lists-0.2.0/docs/Data-Lists.html
20:52:31 <applicative> does it re-export Data.List? and Data.List.Split?
20:52:36 <ReinH> yep
20:52:41 <chrisdone> applicative: yup
20:52:45 <ReinH> also that
20:52:56 <applicative> oh there you go i see it
20:53:26 <chrisdone> i globbed functions from MissingH, too. not all, some are dupes of the split package's functionality or just aliases of base
20:53:34 <applicative> and we get Data.List.Extras.LazyLength for good measure
20:53:58 <ReinH> chrisdone: isn't joins just intercalate?
20:54:17 <chrisdone> hmm. you may be right, actually. let me check
20:54:22 <ReinH> @src intercalate
20:54:22 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
20:54:23 <ReinH> yep
20:54:24 <chrisdone> yeah
20:54:29 * chrisdone removes
20:54:31 <ReinH> heh
20:54:33 <ReinH> I like the name
20:54:35 <chrisdone> it's called "join" in MissingH
20:54:35 <Polarina> No, you must deprecate first!
20:54:39 <chrisdone> haha
20:54:40 * hackagebot lists 0.2.0 - Functions for dealing with lists  http://hackage.haskell.org/package/lists-0.2.0 (ChrisDone)
20:54:50 <ReinH> now you have to release 1.0 because of the breaking API change
20:54:54 <ReinH> thems are the rules
20:55:35 <chrisdone> actually the '2' was a breaking change, by adding a dependency, so it should be 0.3.0 now
20:55:37 <applicative> type Either a b = Proxy Void Void Void a (Const Void) b
20:55:44 <chrisdone> applicative: lol
20:55:49 <ReinH> applicative: please stop
20:56:27 <Polarina> ReinH, the Package Versioning Policy states "If any entity was removed, or the types of any entities or the definitions of datatypes or classes were changed, or instances were added or removed, then the new A.B must be greater than the previous A.B. "
20:56:55 <applicative> hey, I'm just following simonpj's advice, I want one 'abstraction' to rule them all
20:57:01 <ReinH> Polarina: oh yeah PVP
20:57:14 <chrisdone> yup. mine is: dunno.breaking-change.minor-change
20:57:15 <ReinH> which is a nicely combative acronym
20:57:34 <chrisdone> i tend to change 'dunno' on a major redesign
20:57:52 <ReinH> you could just approach phi or something
20:57:53 <chrisdone> the x.x.x.x format that cabal init defaults to seems way overkill
20:58:02 <applicative> dunno.breaking-change.minor-change.dunno
20:58:13 <chrisdone> yeah =p
20:58:23 <ReinH> wtf.hax.stuff.whitespace
20:58:37 <chrisdone> changedstuff.???.profit
20:58:57 <chrisdone> git commit -a -m "stuff"; git push -f
20:59:13 <chrisdone> Enterprise Quality Programming Practices™
20:59:40 * hackagebot lists 0.3.0 - Functions for dealing with lists  http://hackage.haskell.org/package/lists-0.3.0 (ChrisDone)
20:59:42 <Polarina> What comes after enterprise then?
20:59:53 <chrisdone> Polarina: Exitprise?
21:00:14 <startling> chrisdone, you forgot --amend
21:01:01 <applicative> wait how did i miss lists-0.2.x?
21:01:16 <chrisdone> rm -rf *; git commit -a -m "oh noes it's all over"; git gc; xeyes & disown
21:02:10 <chrisdone> don't actually run that command, by the way
21:02:12 <chrisdone> <_<
21:02:42 <c_wraith> what is disown?
21:02:46 <startling> cowsay u.u
21:02:51 <ReinH> chrisdone: where's maps?
21:02:54 <ReinH> @hackage maps
21:02:54 <lambdabot> http://hackage.haskell.org/package/maps
21:03:00 <ReinH> disappointing
21:03:20 <chrisdone> i've never really collected any functions for maps, personally
21:03:22 <ReinH> chrisdone: you need to run git add -u to add the deletions :p
21:03:31 <chrisdone> ReinH: good point =p
21:03:32 <applicative> haha
21:03:33 <ReinH> or git rm -rf .
21:03:42 <ReinH> or * actually
21:03:47 <chrisdone> c_wraith: disown the child process from the parent shell process
21:03:59 <ReinH> applicative: I mean, just because it's a joke doesn't mean it shouldn't be correct
21:04:38 <Polarina> I could make 'attoparsecs'. I got enough mess for that already. :P
21:04:40 <chrisdone> c_wraith: it stops SIGHUP being sent when you close the terminal, iow
21:04:49 <startling> sl -l
21:07:25 * chrisdone goes back to bed
21:09:42 * hackagebot lists 0.3.1 - Functions for dealing with lists  http://hackage.haskell.org/package/lists-0.3.1 (ChrisDone)
21:16:15 <elliott> chrisdone: how long until ints?
21:18:39 <carter> elliott: don't egg him on please
21:22:18 <Hafydd> booleans?
21:22:30 <Hafydd> units?
21:23:00 <carter> Hafydd:  or ninjas
21:23:27 <applicative> bools chars conduitses
21:23:40 <carter> arrays
21:23:42 <carter> oh noes
21:23:44 <carter> that would be bad
21:23:49 <carter> maths
21:23:53 <Hafydd> Hahah.
21:23:54 <carter> compilers
21:24:01 <carter> oses
21:24:15 <carter> networking-stacks
21:24:21 <carter> silicons
21:24:24 <carter> i'll stop
21:24:54 <Hafydd> xsss -- functions for dealing with lists of lists
21:25:44 <carter> not to be confused with xxxs, for lists of tuples
21:25:50 <giogadi> howdy, has anyone been able to solve the "Tricky" exercise for applicatives in section 4.2 of the typeclassopedia? http://www.haskell.org/haskellwiki/Typeclassopedia
21:26:15 <applicative> it's an open problem
21:26:59 <giogadi> applicative: I hope you're not talking to me
21:27:12 <applicative> pure f <*> x = pure (flip ($)) <*> x <*> pure f
21:27:30 <carter> seems pretty straightforward to me
21:27:42 <giogadi> I can't seem to get the steps down from the laws
21:27:57 <carter> hint: write flip $ as a lambda expression
21:28:01 <giogadi> I tried applying interchange to the latter two terms of the right hand side
21:28:20 <applicative> oh we get fmap f x = pure f <*> x of course
21:28:50 <carter> and use that pure f has no effects
21:29:12 <carter> well
21:29:22 <carter> ignore me
21:29:26 <shachaf> For what it's worth, I think the Applicative formulation that's used in the libraries is the most awkward one you could reasonably come up with.
21:30:00 <applicative> you mean this formulation of the laws? hm
21:30:06 <giogadi> I'm still not seeing it; could one of you walk through the steps using each of the laws?
21:30:18 <shachaf> I mean pure/<*>
21:30:21 <giogadi> also, did you derive the left from the right, or vice versa
21:30:23 <carter> shachaf: how so?
21:30:56 <shachaf> Compared to e.g. mult :: f a -> f b -> f (a,b), or liftA2 :: (a -> b -> c) -> f a -> f b -> f c
21:31:18 <Rarrikins> It would be nice if there was something that converted (a, b, c) to a <$> b <*> c for lots of tuple sizes.
21:31:28 <applicative> mult would be a chamber of horrors like the tuples in arrow
21:31:29 <shachaf> giogadi: Well, you know that the left side is fmap f x, right?
21:31:43 <giogadi> shachaf: OH
21:31:48 <giogadi> one sec don't say anything
21:31:49 <giogadi> haha
21:32:49 <shachaf> Also keep associativity in mind -- <*> is infixl.
21:32:54 <shachaf> I guess that's obvious from one of the laws.
21:34:18 <shachaf> giogadi: Another exercise: Derive the Functor laws from the Applicative laws, without using the "law" fmap g x = pure g <*> x
21:34:37 <shachaf> (It's possible!)
21:34:48 <giogadi> shachaf: maybe I'll try that first, I'm still not making progress on the first problem
21:34:55 <shachaf> I think the first one is easier.
21:35:05 <giogadi> hmph
21:35:22 <giogadi> was the general strategy to simplify the RHS to become the left, or the other way around?
21:35:56 <shachaf> Whichever you want.
21:36:10 <shachaf> "=" is magic like that.
21:36:21 <giogadi> right but sometimes reductions are easier than expansions
21:36:22 <applicative> hah
21:37:27 <giogadi> so on one hand, I can get (fmap (flip ($)) x) <*> pure f
21:37:28 <shachaf> OK, maybe the exercise I gave is easier. I don't know what's easier.
21:37:29 <giogadi> then I'm stuck
21:37:57 <giogadi> in the above, I'm trying to reduce the RHS
21:40:10 <giogadi> so question: is it definitely invalid to try to directly replace the (x <*> pure f) in the RHS using the interchange law
21:41:46 <shachaf> Is what invalid?
21:41:52 <shachaf> Write the before, after, and reasoning. :-)
21:42:07 <giogadi> RHS: pure (flip ($)) <*> x <*> pure f
21:43:26 <giogadi> by the interchange law, can I reduce RHS to pure (flip ($)) <*> pure ($ f) <*> x
21:43:37 <giogadi> or does this somehow violate associativity
21:43:50 <shachaf> Add parentheses.
21:44:05 <shachaf> (pure (flip ($)) <*> x) <*> pure f
21:44:07 <giogadi> I guess I'm not certain where I'm allowed to add them, since the problem doesn't specify any
21:44:09 <giogadi> oh
21:44:14 <giogadi> right, left infix
21:46:38 <giogadi> shachaf: so with the parentheses, it *looks* like I can still apply the interchange law
21:46:49 <giogadi> lemme give this a try
21:46:56 <shachaf> What is u and what is y?
21:47:43 <giogadi> in this case, y would be f and u would be (pure (flip ($)) <*> x)
21:47:58 <giogadi> er, y would be pure f
21:48:02 <giogadi> no, f
21:48:18 <shachaf> Hooray for unification!
21:48:35 <shachaf> Yes, that sounds right.
21:48:49 <shachaf> So now you can apply the law: u <*> pure y = pure ($ y) <*> u
21:49:01 <giogadi> ok, it looks even worse, but let's see where I can go
21:49:22 <shachaf> One step at a time.
21:49:46 * hackagebot citation-resolve 0.4.2.1 - convert document IDs such as DOI, ISBN, arXiv ID to bibliographic reference.  http://hackage.haskell.org/package/citation-resolve-0.4.2.1 (TakayukiMuranushi)
21:49:48 * hackagebot authoring 0.2.3 - A library for writing papers  http://hackage.haskell.org/package/authoring-0.2.3 (TakayukiMuranushi)
21:50:01 <giogadi> so the new equation is pure ($f) <*> (pure (flip ($)) <*> x)
21:50:23 <giogadi> I'd like to use homomorphism on the two pures but the parentheses seem to forbid that
21:50:36 <shachaf> Correct.
21:50:43 <giogadi> but I guess I can use the Composition rule to change that
21:50:48 <shachaf> Correct.
21:53:26 <giogadi> so we get, after applying homomorphism, pure (.) <*> pure (flip($) $ f) <*> x
21:53:45 <shachaf> What are u,v,w?
21:53:51 <giogadi> ok, rewinding
21:54:33 <giogadi> u = pure ($f),    v = pure (flip ($)),     w = x
21:54:52 <ski> Rarrikins : er, why ?
21:55:20 <giogadi> composition gives us pure (.) <*> pure ($f) <*> pure (flip ($)) <*> x
21:55:39 <giogadi> oh shoot, I homomorphosed the wrong terms
21:55:44 <giogadi> earlier
21:55:50 <shachaf> Sounds right. One step at a time. :-)
21:55:58 <shachaf> Add some parentheses if you like.
21:56:36 <stacky> question, do people usually use Const from Control.Applicative or Constant from Data.Functor.Constant
21:56:45 <giogadi> If I compose u and v, I get pure ((.) ($f)) <*> pure (flip ($)) <*> x
21:56:50 <stacky> is one preferred if I just need the constant functor?
21:57:24 <shachaf> stacky: I use Const. Most people use Const.
21:57:32 <stacky> alrighty thanks
21:57:34 <shachaf> Ross Paterson uses Constant.
21:57:45 <giogadi> this is still a mess, but I'll just keep composing and see if anything happens.
21:57:57 <giogadi> er, homomorphosing
21:58:19 <shachaf> OK. What's the next step?
21:58:29 <giogadi> then it's pure ((.) ($f) (flip ($)) <*> x
21:58:53 <giogadi> or pure (($f) . (flip ($))) <*> x
21:59:21 <shachaf> Looks right.
21:59:38 <Rarrikins> ski: For a bit more concision.
22:00:00 <shachaf> Now what?
22:00:08 <giogadi> haha I'm just staring at that
22:00:16 <ski> Rarrikins : how about idiom brackets ?
22:00:44 <giogadi> I need some more time to work through the awful argument to pure
22:00:57 <ski> Rarrikins : <http://hackage.haskell.org/package/applicative-quoters-0.1.0.8/docs/Control-Applicative-QQ-Idiom.html>
22:01:13 <Rarrikins> ski: Ahh, those look nice :)
22:03:33 <giogadi> shachaf: any hints for making sense of (($f) . (flip ($)))
22:03:45 <shachaf> giogadi: Add a lambda.
22:03:54 <shachaf> (\q -> (($f) . (flip ($))) q)
22:07:33 <giogadi> I'm not really sure how that lambda helps
22:07:53 <giogadi> I did try to make use of pure f <*> x = fmap f x though
22:08:27 <giogadi> and since fmap has a law about function composition, I have fmap ($f) . fmap (flip ($))
22:08:42 <Rarrikins> giogadi: Begin applying the function to q.
22:09:16 <arkeet> e.g. observe how the right side of the -> is of the form (f . g) q
22:09:34 <arkeet> now apply the definition of (.)
22:09:35 <arkeet> and so on
22:10:04 <giogadi> ok, let's see
22:10:19 <giogadi> g q = flip ($) q
22:11:01 <arkeet> hm.
22:11:05 <arkeet> I shouldn't have reused f
22:11:36 <arkeet> oh well, it's all alpha-equivalent anyway.
22:11:56 <giogadi> well I'm just trying to "evaluate" shachaf's lambda function one step at a time
22:12:27 <arkeet> if someone gave you (\q -> (k . g) q)
22:12:30 <arkeet> how would you simplify that?
22:12:45 <giogadi> \q -> k (g q)
22:12:46 <arkeet> I mean
22:12:48 <arkeet> yeah.
22:12:57 <giogadi> that's where I'm at now
22:13:07 <arkeet> yeah, but you have some specific k and g.
22:13:20 <giogadi> so I *think* flip ($) q = ($q)
22:13:34 <giogadi> still having trouble wrapping my head around that
22:13:55 <joelteon> :t ($ q)
22:13:56 <lambdabot> (Expr -> b) -> b
22:14:34 <shachaf> One step at a time.
22:14:44 <joelteon> whoops, I forgot q was defined
22:14:47 <shachaf> You know the definition of flip. You know the definition of ($q)
22:14:50 <ski>   ($) `flip` q  -- is `($ q)', yes
22:15:50 <arkeet> flip ($) q  =  (\x -> flip ($) q x)  =  ($) x q
22:15:51 <giogadi> ok, then we should have ($f) ($q)
22:15:54 <arkeet> when in doubt, add more lambdas.
22:16:00 <giogadi> ok lemme go back for a sec
22:16:21 <arkeet> er
22:16:25 <arkeet> \x -> ($) x q, on the right.
22:16:31 <shachaf> You can't just take people's word for it!
22:16:43 <giogadi> I know, I'm trying to make sense of it here
22:22:57 <giogadi> so after more looking I'm still getting that \q -> (($f) . (flip ($))) q = ($f) ($q)
22:23:02 <giogadi> which doesn't seem to make sense
22:23:23 <arkeet> so far so good, but
22:23:28 <arkeet> what is ($f) ?
22:23:55 <giogadi> thats the rub
22:24:11 <shachaf> If you don't know what ($f) is, you can look it up in the Haskell Report.
22:24:18 <arkeet> I mean you just figured out how something is ($q).
22:24:21 <shachaf> What is (* 5)?
22:24:21 <arkeet> so surely you know what ($q) is
22:24:32 <giogadi> oooooh
22:25:03 <giogadi> so ($f) = flip f
22:25:08 <zRecursive> :t ($f)
22:25:08 <lambdabot> FromExpr a => (a -> b) -> b
22:25:13 <arkeet> giogadi: no
22:25:16 <elyon> using GHCi, I can't seem to use `:/` (or any symbol for that matter) as a data constructor. Is there something I need to do with GHC to make it interpret this constructor?
22:25:34 <shachaf> What does ghci say?
22:25:37 <arkeet> elyon: works for me.
22:25:48 <arkeet> what are you typing?
22:25:55 <elyon> shachaf: "parse error on input `:'"
22:26:01 <ski> > map ($ x) [f,g,h] :: [Expr]
22:26:02 <lambdabot>   [f x,g x,h x]
22:26:18 <elyon> arkeet: `data N = :/ | S !N`
22:26:21 <shachaf> Maybe it's a literal "can't" -- you try to type it in but you can't bring yourself to do it?
22:26:26 <arkeet> elyon: well, yes, :/ is an operator.
22:26:34 <ski> elyon : try `data N = (:/) | S !N' ?
22:26:36 <elyon> shachaf: could have been, but no
22:26:38 <arkeet> so it must be used infix.
22:26:40 <arkeet> unless you write (:/)
22:27:20 <shachaf> In general, when you ask a question, you should say what you did, what you expected would happen, and what actually happen. That way people would have been able to answer you right away. :-)
22:27:21 <arkeet> you *can* use it infix, in e.g.  data F = Int :/ Int
22:28:06 <elyon> arkeet: hmm ...
22:28:07 <shachaf> happens
22:28:17 <elyon> shachaf: that makes sense, thank you
22:29:32 <giogadi> so looking at the type for $, I see (a -> b) -> a -> b
22:30:27 <nstdloop> :t `$`
22:30:27 <lambdabot> parse error on input ``'
22:30:28 <giogadi> to me, it seems that putting a function on the RHS of $ gives us something weird like ((x -> y) -> b) -> (x -> y) -> b
22:30:30 <shachaf> Not that the type hurts, but you have the definition here. You can use it even without the type.
22:30:32 <nstdloop> :t $
22:30:32 <lambdabot> parse error on input `$'
22:30:40 <nstdloop> ....
22:30:45 <shachaf> Sometimes looking at the types makes things harder.
22:30:48 <giogadi> ok
22:30:53 <ski> @type ($)
22:30:54 <lambdabot> (a -> b) -> a -> b
22:31:00 <nstdloop> there we go
22:31:02 <shachaf> ski: :t works in /msg now, by the way.
22:31:15 <ski> i see
22:31:32 * ski is used to typing `@type'
22:31:33 <giogadi> so if x $ y = x y
22:32:02 <shachaf> What are you even trying to do? I've lost track.
22:32:24 <giogadi> haha
22:33:04 <Rarrikins> Convert sections to lambdas.
22:33:29 <giogadi> I think the point was to try to say ($f) . (flip ($)) = f
22:33:40 <shachaf> OK.
22:34:15 <shachaf> Did you add a lambda?
22:34:16 <giogadi> using lambdas, I could say \q -> (($f) . (flip ($))) q = ($f) ($q)
22:34:20 <shachaf> OK.
22:34:30 <giogadi> ($q) makes sense to me
22:34:31 <shachaf> If you're stuck now, add more lambdas.
22:35:03 <arkeet> does ($f) make sense to you?
22:35:09 <giogadi> no it doesn't
22:35:12 <giogadi> I'm working on it
22:35:16 <giogadi> WITH LAMBDAS
22:35:16 <arkeet> why does ($q) make sense and ($f) not?
22:35:33 <arkeet> they're the same, just with a different letter.
22:35:46 <shachaf> arkeet: Are you suggesting that a function can be an argument to another function?
22:35:51 <arkeet> whoa!
22:35:53 <shachaf> That's crazy talk.
22:36:01 <giogadi> haha I know I know
22:36:32 <elliott> what's a function?
22:36:44 <giogadi> so I'm looking at \x -> ($f) x
22:36:51 <Rarrikins> elliott: It's when you have to dress up and go somewhere.
22:37:01 <shachaf> A function is just a total functional relation.
22:37:18 <giogadi> so \x -> ($f) x = x $ f obviously
22:37:33 <Ralith> a function is just a functoid in the category of okay I don't know what I'm doing here someone help me out
22:37:48 <mgsloan> elliott: It's a value that likes being smashed into other values
22:38:00 <giogadi> OH I GOT IT
22:38:14 <arkeet> giogadi: well, ($f) x = x $ f
22:38:29 <giogadi> if \x -> ($f) x = x $ f, then ($f) ($q) = ($q) f
22:38:32 <giogadi> which is f q
22:38:35 <arkeet> yes
22:38:36 <giogadi> WOOOOOO
22:38:47 <arkeet> what happened to the lambda? \q ->
22:39:03 <giogadi> well yeah I was abusing notation
22:39:09 <arkeet> =(
22:39:22 <elyon> okay, let's try this again; When interpreting this code (http://pastie.org/8391434) through GHCi, I get an error message telling me `·' is not in scope. I was expecting it to be a valid constructor per the definition of ℕ. (Here's hoping the unicode is transferred properly)
22:39:23 <ski> obviously it's meant o be read as `\x -> (($f) x = x $ f)'
22:39:34 <shachaf> Don't abuse notation.
22:39:35 <giogadi> so \q -> ($f) ($q) = ($q) f = f q
22:39:45 <shachaf> It makes arkeet sad.
22:39:56 <shachaf> You're making arkeet sad again. :-(
22:40:15 <giogadi> which brings us all the way back to pure f <*> x, where we needed to be
22:40:18 <arkeet> but
22:40:24 <arkeet> =(
22:41:20 <giogadi> wow I finally have it. Maybe I'm just new, but that exercise was more than "tricky"
22:41:28 <giogadi> I really can't thank all of you enough for your time and patience
22:42:24 <shachaf> That kind of symbol manipulation gets easier as you get grumpier.
22:42:43 <giogadi> :)
22:43:50 <giogadi> ok, well it's way past my bedtime now.
22:43:55 <giogadi> thanks again everyone, and good night!
22:51:43 <elyon> is it possible to undefine a standard library function/operator (like `+`)? If so, how would one go about doing so?
22:53:19 <shachaf> Not possible. But you can not import it if you don't like it.
22:53:43 <arkeet> import Prelude hiding ((+))
22:53:59 <elyon> arkeet: ah, wonderful; shachaf: that makes perfect sense
23:14:11 <Ghoul_> well, you can use NoImplicitPrelude
23:14:32 <Ghoul_> arkeet: does that work since Prelude is automatic?
23:14:46 <joelteon> yeah, it works
23:14:56 <joelteon> Prelude is implicit unless you make it explicit
23:16:22 <elyon> Ghoul_: that is exactly what I want for now :) Thank you
23:55:04 * hackagebot persistent-template 1.2.0.3 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.2.0.3 (MichaelSnoyman)
