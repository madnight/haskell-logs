00:00:36 <chrisdotcode> cool; thanks!
00:02:27 <davean> edwardk: Did I hear you need more stickers? ;)
00:02:36 <edwardk> ack!
00:03:28 <edwardk> er, that was ack as in a cry of distress, rather than an enthusiastic acknowledgement ;)
00:03:39 * edwardk figures he'd better be clear
00:03:44 <edwardk> lest another shipment arrive
00:05:10 <edwardk> I left ~1000 of them with T_S_ at the Hacker Dojo in Mountain View, and dumped as many as I could plausibly get away with at Mozilla last week
00:08:15 <davean> So you're running low then?
00:10:50 <edwardk> i've got quite a few left. even some of the bigger form factor
00:17:22 * hackagebot crypto-cipher-types 0.0.9 - Generic cryptography cipher types  http://hackage.haskell.org/package/crypto-cipher-types-0.0.9 (VincentHanquez)
00:17:22 * hackagebot hoopl 3.9.0.0 - A library to support dataflow analysis and optimization  http://hackage.haskell.org/package/hoopl-3.9.0.0 (HerbertValerioRiedel)
00:38:51 <haasn> edwardk: stickers?
00:39:00 <haasn> lens stickers?!
00:39:32 <edwardk> haasn: haskell stickers so far, no lens stickers yet, but thats an idea
00:39:45 <haasn> edwardk: where do I get these haskell stickers? Whatever the cost!
00:40:29 <tazjin> Did somebody say stickers?
00:40:31 <tazjin> What have I missed?
00:41:24 <edwardk> haasn: email me an address
00:41:34 <haasn> edwardk: it's that simple?
00:41:57 <edwardk> tazjin: are you in hungary?
00:42:21 <tazjin> edwardk: I'm in Sweden, it's not that far! :-)
00:42:28 <edwardk> tazjin: i ask merely because of your connection
00:42:44 <edwardk> if you were i was going to say i'd be there with stickers in hand in a couple of weeks ;)
00:42:59 <edwardk> but sweden is a bit of a detour for me =)
00:43:00 <frxx> is using unsafePerformIO to read a config file so that I can have globally accessible options a horrible idea?
00:43:26 <tazjin> edwardk: It would be a beautiful detour though!
00:44:03 <edwardk> if nothing else i shall bring haskell stickers to sweden next year for icfp
00:45:13 <tazjin> I'll be there so that works!
00:48:09 <erisco> what approach can be used for whitespace sensitive languages (such as Haskell) when using the Happy parser generator?
00:48:44 <erisco> input is a sequence of tokens so I presume something clever is done in the lexing stage
00:48:46 <edwardk> erisco: teach the lexer about indentation and add tokens for it
00:50:03 <erisco> edwardk, as far as the grammar is concerned perhaps I treat it as a braced language then?
00:50:40 <edwardk> you probably want to do a bit more with the onside/offside noise, but typically its very close
00:51:11 <erisco> edwardk, what particularly are those rules?
00:51:55 <edwardk> erisco; you can steal a working set of onside/offside rules from github.com/ermine-language/ermine-legacy/ or ghc's guts
00:54:42 <erisco> edwardk, okay thanks
01:12:19 * hackagebot socks 0.5.4 - Socks proxy (version 5) implementation.  http://hackage.haskell.org/package/socks-0.5.4 (VincentHanquez)
01:20:16 <iamtakingiteasy> hello, is it possible to implement a factorial in foldr-way (using something like foldr (*) 1 [1..n]) on datatype which implements only Num and Ord (no Enum implementation)?
01:20:44 <iamtakingiteasy> is there anything like succ and pred, which relies not pre-defined behaviour, but rather on arithemitc operations (like (+1) or (-1)) ?
01:21:15 <iamtakingiteasy> to build-up a list out of that
01:21:24 <iamtakingiteasy> a guarded incrimenting list*
01:21:58 <iamtakingiteasy> i know it is trivial to implement, i am mostly wonder what there is in standard library for same task
01:23:02 <iamtakingiteasy> and i know that implementing Enum would be best option to go, but i just can't due to nature of my task (sort of homework with crazy signatures)
01:26:49 <erisco> iamtakingiteasy, not sure what you mean... if you have a succ function for your type can't you use that?
01:27:21 <iamtakingiteasy> erisco: i don't have succ and pred, actually
01:27:24 <iamtakingiteasy> i have no instance of Enum
01:27:34 <iamtakingiteasy> nor derrived nor user-defined
01:28:03 <iamtakingiteasy> i just can't add (Enum a) to signature of factorial :: (Num a, Ord a) => a -> a
01:28:16 <iamtakingiteasy> and i need to implement it with foldr somehow
01:28:37 <peddie> iamtakingiteasy: can you use an unfold to create the list?
01:28:38 <iamtakingiteasy> crazy task, with no practical meaning
01:29:30 <erisco> iamtakingiteasy, how would you define succ?
01:30:03 <peddie> :t unfoldr
01:30:04 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
01:30:14 <iamtakingiteasy> peddie: probably, thank you
01:30:23 <iamtakingiteasy> erisco: succ = (+1)
01:30:52 <erisco> I thought you were not working with instances of Enum?
01:31:00 <peddie> iamtakingiteasy: see the example at http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#g:9
01:31:34 <iamtakingiteasy> erisco: yes, but if you ask me how wold i implement succ in my case, if i have permission to, i answered
01:32:30 <erisco> iamtakingiteasy, I do not understand how you can reasonably both need something like succ and have no way to define succ
01:32:54 <iamtakingiteasy> erisco: i have a way to define succ in terms of helper functions and a bit recursion
01:33:11 <iamtakingiteasy> i just can't use (Enum a) in my function signature
01:33:22 <iamtakingiteasy> doesn't mean i can't write own succ
01:33:34 <peddie> iamtakingiteasy: do you need Ord?  I wrote one and GHC told me it was    fact :: (Eq a, Num a) => a -> a
01:33:41 <iamtakingiteasy> yes
01:34:06 <iamtakingiteasy> well
01:34:14 <erisco> I'm lost. sorry.
01:34:34 <iamtakingiteasy> it is not a practical or a meaningful task
01:34:37 <iamtakingiteasy> it is homework
01:35:09 <iamtakingiteasy> i have to 1. use foldr, 2. use factorial :: (Num a, Ord a) => a -> a signature
01:35:20 <iamtakingiteasy> sorry
01:35:30 <peddie> iamtakingiteasy: happily, I think Ord implies Eq, so no problem -- I was just curious
01:35:34 <erisco> if you do not want to constrain 'a' to the Enum class, which seems odd given that you demand a successor function, just define mySucc which is the same thing
01:35:50 <iamtakingiteasy> yes, it is odd indeed
01:36:17 <erisco> myFac n = blah blah where mySucc = (+1)
01:36:17 <iamtakingiteasy> i just thought there could be something in standard library for doing even such an odd task in neat way
01:36:22 <iamtakingiteasy> yeah
01:36:34 <iamtakingiteasy> and i think unfoldr could be the instance
01:39:40 <iamtakingiteasy> aha, found another approach: take 5 $ iterate (+1) 1
01:41:02 <Flonk> Is there an instance of Num that isn't Enum?
01:42:39 <iamtakingiteasy> yep
01:42:49 <iamtakingiteasy> my own data type AbstractInteger
01:43:36 <iamtakingiteasy> defined as data AbstractInteger = Zero | Succ AbstractInteger | Pred AbstractInteger deriving (Eq)
01:43:54 <iamtakingiteasy> and manual instances for Num, Ord and Show
01:44:22 <iamtakingiteasy> it naturarl to have an Enum instance
01:44:22 <Flonk> iamtakingiteasy: Well, because you just didn't define it or because there is no meaningful way to make your Num an instance of Enum?
01:44:26 <iamtakingiteasy> but crazy rules, i can't
01:44:39 <erisco> iamtakingiteasy, you sure you are a computer scientist? Pred? really? <3
01:45:15 <notdan> ?
01:45:39 <iamtakingiteasy>  i am not a computer scientist
01:45:44 <iamtakingiteasy> i am not even learning
01:45:49 <erisco> :(
01:45:50 <iamtakingiteasy> i am just doing a lab work for my friend
01:46:17 <iamtakingiteasy> probably (to bad for my friend, he will learn less than could)
01:46:26 <iamtakingiteasy> too bad*
01:46:37 <iamtakingiteasy> but i will instead >:3
01:47:40 <iamtakingiteasy> Flonk: just because i am restrictd to not defining it
01:47:57 <iamtakingiteasy> if it were any reasonable task - i did an Enum instance
01:48:12 <iamtakingiteasy> (or just used regular Int, lol)
01:48:22 <iamtakingiteasy> and product [1..n]
01:48:28 <Flonk> Yeah, I see
01:49:22 <iamtakingiteasy> but well, defining a Num instance for such data type was soldifying
01:56:18 <fizruk> edwardk, ping
01:58:17 <Enzier> Question, does there exist a fast variant of concatMap?
02:03:11 <fizruk> Enzier, no expert, but why do you expect there to be a faster version?
02:03:43 <fizruk> Enzier, perhaps there is a faster version for your particular use case?
02:04:03 <fizruk> Enzier, I mean with specialized type
02:04:27 <Enzier> fizruk: As far as I can find it uses ++, while it's faster to use : in another fashion
02:04:44 <peddie> :t (:)
02:04:45 <lambdabot> a -> [a] -> [a]
02:04:47 <peddie> :t (++)
02:04:48 <lambdabot> [a] -> [a] -> [a]
02:04:56 <Enzier> peddie: I'm not stupid.
02:05:25 <peddie> Enzier: I don't think you're stupid, I'm just checking for myself
02:05:28 <Taneb> Hi, emacs is saying some of my installed things can't be found, but (for example) tiny core in emacs works fine
02:05:43 <Enzier> fizruk: I'm not sure how it's called what I mean, but it should look like 1:2:3:4:5:6:[7,8,9] instead of [1,2,3] ++ [4,5,6] ++ [7,8,9]
02:05:58 <fizruk> Enzier, I think concatMap is linear in total number of elements in (map f xs)
02:06:04 <peddie> @src (++)
02:06:04 <lambdabot> []     ++ ys = ys
02:06:04 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
02:06:04 <lambdabot> -- OR
02:06:04 <lambdabot> xs ++ ys = foldr (:) ys xs
02:06:23 <Enzier> fizruk: it uses foldr so that uses loads of memory
02:06:33 <donri> Enzier: you could use foldMap on the Endo monoid
02:07:22 <peddie> Enzier: I'm not convinced that what you wrote is going to be different than doing it with ++
02:07:31 <fizruk> Enzier, did you check if it does actually?
02:08:29 <Enzier> peddie: I wasn't convinced either when I heard of this in my lectures long time ago, but when I tested it back then, it really was much faster. I don't know if I wrote it correct precisely, but I know that you can use : instead of ++ in some way in cases like this
02:09:21 <peddie> Enzier: you can avoid ++ traversing the whole list by using : to add elements and then reverse the list at the end?
02:10:21 <fizruk> I vaguely recall Wadler's paper "The Concatenate Vanishes", I believe GHC does something like that to concatMap
02:10:26 <fizruk> I may be wrong though
02:11:14 <fizruk> @src concat
02:11:14 <lambdabot> concat = foldr (++) []
02:12:18 <peddie> as concatMap is implemented using a fold, it might fuse as well?  I don't really know
02:13:50 <fizruk> sure, foldr (++) [] . map f = foldr ((++) . f) []
02:14:54 <peddie> Enzier: what kind of cases are you worried about being slow with concatMap?
02:14:57 <Enzier> peddie: yes I guess it was that, but that is not in the definition and as all of you don't know another option, I guess I need to write it myself
02:15:54 <Enzier> peddie: I'm turning a directed acyclic graph around and I need to store the links which are in the nodes, but there are a lot of links (150m eventually) so these changes make a huge difference
02:16:23 <Enzier> peddie: the links are coming from the nodes with concatMap getLinks graph
02:16:39 <MercurialAlchemi> np
02:16:41 <Enzier> peddie: where getLinks :: Node -> [Link]
02:17:24 <donri> Enzier: i did suggest an option. and others also suggested trying a different type.
02:17:48 <peddie> Enzier: maybe a list isn't the best data structure for this problem, especially if you're going to have a lot of links per node
02:18:20 <Enzier> peddie: no that's not the case, almost all nodes have 3 or less links, only a few have a dozen or so
02:18:26 <peddie> Enzier: you could use one of the existing graph libraries also
02:18:26 <fizruk> Enzier, my hand-written version of concat (using :) runs a bit slower than Prelude.concat
02:18:56 <Enzier> donri: I know, that's what I meant by writing it myself
02:19:37 <Enzier> peddie: as far as I learned, writing a data structure yourself is always faster than using a generic one, if you code well enough (and I believe I do)
02:19:56 <Enzier> fizruk: could you give me the code?
02:20:21 <fizruk> Enzier, concat' [] = []; concat' ([]:xss) = concat' xss; concat' ((x:xs):xss) = x : concat' (xs:xss)
02:21:16 <peddie> Enzier: best of luck
02:22:22 * hackagebot parsec3-numbers 0.0.4 - Utilities for parsing numbers from Char sequences  http://hackage.haskell.org/package/parsec3-numbers-0.0.4 (ChristianMaeder)
02:22:54 <Enzier> fizruk: you're right. Strange
02:23:27 <fizruk> Enzier, I believe GHC can't optimize concat' enough.
02:25:19 <fizruk> Enzier, so perhaps you should check out existing graph libraries, etc. before making it yourself
02:26:10 <fizruk> Enzier, you can at least see how they do, what you're going to do
02:29:45 <donri> :t flip appEndo [] . F.foldMap (Endo . (++)) `asTypeOf` concat
02:29:47 <lambdabot>     Precedence parsing error
02:29:47 <lambdabot>         cannot mix `.' [infixr 9] and `asTypeOf' [infixl 9] in the same infix expression
02:29:58 <donri> :t (flip appEndo [] . F.foldMap (Endo . (++))) `asTypeOf` concat
02:29:59 <lambdabot> [[a]] -> [a]
02:32:29 <Enzier> fizruk: I will, thank you
02:32:37 <Enzier> donri: thanks :)
02:32:42 <donri> :t (\f -> flip appEndo [] . F.foldMap (Endo . (++) . f)) `asTypeOf` concatMap
02:32:43 <lambdabot> (a1 -> [a]) -> [a1] -> [a]
02:32:59 <fizruk> donri, that is also slower than Prelude's
02:33:10 <donri> okies :)
02:33:32 <donri> fizruk: how are you measuring that
02:33:53 <fizruk> donri, length . concat $ replicate 1000 [1..10000]
02:34:02 <donri> fizruk: how are you compiling?
02:34:38 <fizruk> oh, I'm using ghci, should try compiling
02:34:56 <donri> i imagine concat is compiled -O or -O2
02:35:00 <donri> ghci is not
02:35:10 <donri> it's not even -O0
02:39:53 <skypers> hi
02:40:03 <skypers> 05:14 #haskell: < dested> skypers, did you mean to ping me?
02:40:05 <skypers> nope?
02:42:05 <haasn> With the advent of closed type families, would it be possible to automatically lift a function to the type system?
02:42:14 <haasn> Possibly not involving recursion
02:42:27 <haasn> On second thought, nonstrict semantics in general would be quite hard
02:42:45 <skypers> http://hackage.haskell.org/package/FModExRaw-0.1.0.0 < if anyone wants to contribute, they can continue what I started in Sound.FModEx.Raw.Core.Functions
02:42:53 <skypers> the list is _long_
02:44:08 <mgsloan> skypers: Cool, good work!  I remember using fmod waay back in the day
02:44:41 <mgsloan> Looks like it's come far since then (though it was awesome back then too)
02:44:55 <skypers> yeah, it’s a great API, I used it in both my first 64k intro (demoscene), in C++
02:45:02 <skypers> and now my engine is Haskell
02:45:09 <skypers> I need fmodex in haskell as well!
02:45:10 <skypers> :)
02:45:21 <skypers> I might want to get into c2hs tho
02:45:25 <skypers> it was a pain to write :D
02:45:31 <mgsloan> Awesome!!
02:46:06 <skypers> thank you
02:46:16 <skypers> it’s just a raw binding (like OpenGL.Raw actually)
02:46:25 <mgsloan> Yeah, I've had good results from c2hsc before.  It doesn't handle everything for you, but it certainly writes a lot of the boilerplate
02:46:32 <skypers> but it works (there’s a lpaste link in the few last commits’ logs)
02:46:51 <skypers> mgsloan: yeah, I’ll try to use it next times
02:47:41 <skypers> lpaste here: http://lpaste.net/94754
02:47:50 <absence> is touchForeignPtr unneccessary when the foreign ptr itself is used last, after the value returned by unsafeForeignPtrToPtr?
02:47:51 <sie> Can I make this function work without a lambda? (\x -> (*3) $ read x) "3"
02:47:59 <AshyIsMe> ok, just bought learn you a haskell in hard copy
02:48:09 <mbuf> is it possible to pass a parameter to map that needs to be used in the function passed to it?
02:48:33 <AshyIsMe> because, down with trees i guess
02:48:58 <Cale> Using paper encourages tree farmers to plant moar trees.
02:48:59 <skypers> mbuf: what do you mean?
02:49:22 <absence> > (*3) . read $ "3"
02:49:23 <lambdabot>   9
02:49:29 <absence> sie: ^^
02:49:40 <sie> ah, cool — thanks
02:49:46 * sie claps.
02:49:56 <mbuf> skypers: from a function that calls map (fn [1, 2, 3]), I want to pass an argument to map that is used in fn
02:50:32 <mbuf> skypers: and that parameter is used in fn that operates on the list
02:50:44 <skypers> here you have two lists
02:51:07 <absence> mbuf: a constant?
02:51:13 <mbuf> absence: sure
02:51:18 <skypers> then const yeah
02:51:54 <absence> mbuf: partially apply it to the function, like "map (fn myconstant) list"
02:52:08 <skypers> yeah
02:52:13 <mbuf> absence: skypers okay
02:52:24 <skypers> if you have c -> a -> b
02:52:28 <skypers> if you partially apply it
02:52:31 <skypers> you get a -> b
02:52:46 <skypers> that’s closure magics here :)
02:53:18 <skypers> :t map ((+1))
02:53:19 <lambdabot> Num b => [b] -> [b]
02:54:38 <fizruk> donri, Enzier: this is what I got with -O2 http://lpaste.net/94781
02:55:38 <fizruk> donri, never going to test performance in ghci anymore :)
02:56:14 <donri> fizruk: again, though, your base package might be -O1 :P
02:56:36 <donri> can't imagine it makes such a drastic difference though
02:57:01 <fizruk> donri, with -01 results are almost the same
02:57:20 <donri> -01 or -O1? :P
02:57:41 <donri> fizruk: also, for serious measurements use criterion
02:57:47 <fizruk> donri, -O1 :p
02:57:50 <donri> :)
02:57:54 <absence> http://lpaste.net/928784341297790976 <- is it safe to drop the commented touchForeignPtr here, since the foreign ptr is yielded in "done" (which executes last)?
02:58:23 <fizruk> donri, ah... I heard about that, never had to do serious measurements though
02:58:58 <donri> fizruk, Enzier: if either of you feel like it you should measure this with criterion and if it still says concat' is faster, maybe propose it to libraries@
02:59:08 <iLike> Anyone here has experience with yesod Persistent? I have to do a one-to-many join, but I can't for the life of me figure out how.
02:59:16 <skypers> have a good day
02:59:18 <skypers> see you around
03:02:14 <donri> fizruk: (there's also a sharing issue here, that the first concat is forcing the evaluation of xs, and the rest just share it. at least that could be happening)
03:02:31 <fizruk> donri, oh, right!
03:04:14 <sie> If one wants to manipulate with IO data, one must obligatory do so within the IO pipeline and cannot use the data outside of it, am I correct?
03:05:48 <absence> sie: you can use the data outside io, you just can't perform io actions
03:06:16 <sie> Can you show me a scenario of that happening? With getLine, for example.
03:07:25 <absence> sie: when you run the IO action returned by getLine, you get a String. you can convert that string to upper-case using a pure function
03:07:57 <iLike> Suppose I have a payment table (with fields: from UserId, to UserId and amount Double) and a user table with (id, email), how Do I use persistent to make a query like: "SELECT r.amount, u.email FROM payment r INNER JOIN user u ON u.id = r.`to`"
03:09:01 <sie> absence, But I'd still have to do that WITHIN the pipeline, no?
03:09:08 <iLike> what I do now is get all payments (from a certain UserId) and then map over that list and get the User with the 'to' ID. This is terribly inefficient, haha
03:10:08 <fizruk> donri, um... if I (print . sum $ concat xs) first, it does not affect time measurements, I'm going to check it with criterion
03:11:03 <absence> sie: yes, but the pure function that converts to upper-case isn't part of the "IO pipeline", so you're using the data outside it
03:12:25 <merijn_> absence: I think his question is "you can't escape IO, right?" and the answer is "no, you can't"
03:12:29 <Enzier> @src concat
03:12:29 <lambdabot> concat = foldr (++) []
03:13:50 <merijn_> sie: The usual approach to program design is a hard outer IO shell, with a soft gooey purely functional center :)
03:14:12 <sie> lol
03:14:29 <sie> I see, then I will just accept my IOful fate.
03:14:36 <absence> merijn_, sie: ah yes. trying to emphasise that the signature of toUpper doesn't have to be Char -> IO Char :)
03:14:40 <sie> pun unintended
03:15:11 <merijn_> sie: Well, it has some neat side effects too!
03:15:59 <merijn_> sie: First class IO means you can implement things like shortcircuiting operations, bracketing (i.e. python's "with"-blocks) and similar inside the language, rather than needing builtin support
03:18:05 <with-block> merijn_: how can you implement with block?
03:18:26 <Aleksejs> Hi, is it possible to search for Int in IO [Int] using elem?
03:18:36 <with-block> Aleksejs: Yes.
03:18:47 <merijn_> with-block: Like this: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Control-Exception-Base.html#bracket
03:19:25 <merijn_> Aleksejs: You'll want fmap :)
03:19:42 <merijn_> :t elem 1
03:19:43 <lambdabot> (Eq a, Num a) => [a] -> Bool
03:19:49 <merijn_> :t fmap (elem 1)
03:19:50 <lambdabot> (Eq a, Functor f, Num a) => f [a] -> f Bool
03:20:04 <merijn_> IO being a Functor, means you can use that as
03:20:17 <merijn_> :t fmap (elem 1) :: IO [Int] -> IO Bool
03:20:19 <lambdabot> IO [Int] -> IO Bool
03:20:41 <with-block> :t (>>= (elem 1))
03:20:42 <lambdabot>     Couldn't match type `Bool' with `m0 b0'
03:20:42 <lambdabot>     Expected type: [a0] -> m0 b0
03:20:42 <lambdabot>       Actual type: [a0] -> Bool
03:20:44 <Hermit> :t fmap . elem 1 :: IO [Int] -> IO Bool
03:20:46 <lambdabot>     Couldn't match type `f0 a0 -> f0 b0' with `IO Bool'
03:20:46 <lambdabot>     Expected type: (a0 -> b0) -> IO Bool
03:20:46 <lambdabot>       Actual type: (a0 -> b0) -> f0 a0 -> f0 b0
03:20:57 <sie> merijn_, Same could be done with >>= correct?
03:20:59 <merijn_> with-block: elem doesn't return an IO value
03:21:17 <merijn_> sie: You'd have to do "foo >>= return . elem 1"
03:21:26 <sie> Oh, yes.
03:21:33 <with-block> :t (>>= (return . elem 1))
03:21:34 <lambdabot> (Eq a, Monad m, Num a) => m [a] -> m Bool
03:21:34 <sie> This is pretty interesting.
03:21:40 <merijn_> sie: But "? >>= return . ?" is just fmap/liftM :)
03:21:44 <Hermit> err
03:22:56 <merijn_> sie: This btw, proves that every Monad is indeed (at least theoretically) is a functor, since you can implement "fmap f x = x >>= return . f"
03:23:29 <sie> I'll have to advance a bit for that to make sense in my head.
03:24:29 <Hermit> sie: just to give you something else to chew: this can be done with applicative functors too
03:24:49 <Enzier> fizruk, donri: http://lpaste.net/94782 more interesting results. It doesn't really matter with short lists, which is where I need it, but in other cases it does
03:24:56 <Hermit> :t pure (elem 1)
03:24:57 <lambdabot> (Eq a, Num a, Applicative f) => f ([a] -> Bool)
03:25:52 <Hermit> err
03:26:03 <Hermit> :t (elem 1 <$>)
03:26:04 <lambdabot> (Eq a, Functor f, Num a) => f [a] -> f Bool
03:26:06 <merijn_> Hermit: That requires "pure f <*> x"
03:26:11 <Hermit> yep
03:26:13 <merijn_> Hermit: Which is also fmap :p
03:26:21 <merijn_> In other words, you want fmap ;)
03:26:25 <Hermit> yep
03:26:46 <Hermit> the simplest, the better
03:27:06 <merijn_> sie:  Good practice is to just, everytime you implement a datatype, try if you can implement Functor/Applicative/Monad for it
03:27:29 <Hermit> or liftM...
03:27:35 <Hermit> which is also fmap
03:27:37 <merijn_> sie: And then google "functor/applicative/monad laws" and check whether your implementation 1) type checks and 2) follows the laws
03:27:54 <merijn_> sie: One example, try if you can implement those three for "data Pair a = Pair a a"
03:28:40 <Enzier> fizruk, donri: i'm sorry I forgot to change concat to concat''' in the last example
03:30:23 <fizruk> donri, Enzier: this is how I'm benchmarking it with criterion http://lpaste.net/94783
03:30:34 <fizruk> donri, Enzier: this is gonna take some time...
03:34:17 <bennofs> Is there a way to prevent cabal from reinstalling system packages? Even when using sandboxes, cabal rebuilds ghc-mod ...
03:34:20 <donri> fizruk: you shouldn't use whnf with something returning a list
03:34:32 <donri> (yeah, haskell is really hard to benchmark correctly :P)
03:34:46 <donri> oh i see you have test returning Int, nvm
03:34:47 <fizruk> donri, it returns length
03:34:49 <bennofs> Or, alternatively, prevent cabal from using system packages at all?
03:36:44 <donri> bennofs: you can put "constraint: ghc-mod installed" in the cabal config
03:37:03 <donri> bennofs: but i don't think it'll work in the case of ghc-mod which is only an executable
03:37:25 <bennofs> donri: I don't understand why it rebuild ghc-mod at all. My project doesn't depend on it
03:37:26 <donri> bennofs: you shouldn't depend on executable-only packages
03:37:26 * hackagebot tidal 0.2.6 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.2.6 (AlexMcLean)
03:37:38 <donri> oh wait ghc-mod has a library too, nevermind
03:37:48 <bennofs> But I don't depend on ghc-mod
03:37:57 <donri> bennofs: even transitively?
03:38:07 <bennofs> pretty sure, yes
03:38:40 <bennofs> donri: http://packdeps.haskellers.com/reverse/ghc-mod
03:39:05 <bennofs> there are only 2 packages that depend on ghc-mod. I depend on neither
03:39:35 <bennofs> The funny thing is, the rebuild happens even after my project has been successfully installed into the sandbox
03:39:48 <donri> bennofs: and you're not doing "cabal install world"?
03:40:03 <bennofs> no. cabal sandbox init && cabal install
03:40:21 <donri> that does sound odd. try installing with -v2 or so
03:46:05 <fizruk> donri, hmm... perhaps I shouldn't test on such a large input? criterion seems to test each call like 100 times
03:46:26 <donri> yeah. it has a flag to control that though
03:49:06 <bennofs> donri: Hmm, now I get the same problem with gloss
03:49:36 <bennofs> donri: running with -v2 --dry-run doesn't really show anything interresting
03:49:44 <bennofs> donri: should I try to run without --dry-run?
03:50:13 <donri> bennofs: maybe cabal is trying to be smart when it needs to recompile something that ghc-mod/gloss depend on, which means it needs to recompile those too
03:50:21 <donri> i didn't think cabal was that smart, but maybe sandboxes are. duno
03:50:25 <donri> dcoutts?
03:50:39 <donri> bennofs: also try #hackage for cabal issues
03:50:46 <dcoutts_> the solver isn't doing anything particularly different in the sandbox case
03:50:59 <bennofs> gloss is a system package, fyi
03:51:29 <bennofs> Maybe it's a NixOS issue
03:52:04 <donri> dcoutts_: cabal is rebuilding system packages bennofs doesn't depend on, when they're installing in a sandbox
03:52:07 <donri> IIUC
03:52:35 <dcoutts_> there must be an indirect dependency somewhere
03:52:58 <dcoutts_> did adding an installed constraint not help?
03:54:01 <bennofs> dcoutts_: Oh, adding --constraint="gloss installed" gives a conflict
03:54:20 <bennofs> lpaste should have cabal conflict highlighting :P
03:54:40 <dcoutts_> ok, so that's consistent with it wanting to reinstall it
03:54:48 <lpaste> bennofs pasted “Cabal sandbox conflict” at http://lpaste.net/94785
03:56:41 <dcoutts_> bennofs: looks like ghc-mod uses a different version of binary from the one you depend on, and your thing depends on ghc-mod somehow
03:56:58 * dcoutts_ notes that this is a case where private deps would really help
03:57:18 <bennofs> dcoutts_: I don't depend on ghc mod. If I do not install ghc-mod, cabal doesn't try to install it either
03:57:54 <dcoutts_> bennofs: well it says there it's a user goal
03:58:40 <dcoutts_> bennofs: is that because it's a src package in your sandbox?
03:59:31 <bennofs> Oh, I wasn't right. Removing ghc-mod doesn't help. Also, cabal sandbox delete && cabal sandbox init && cabal install --dry-run -v2 produces the problem
04:01:36 <bennofs> dcoutts_: Might be a NixOS issue. I noticed that ALL packages I installed via nix are listed as an user goal
04:01:39 <dcoutts_> bennofs: we're not addressing the problem here, clearly something is using ghc-mod, though you think it shoudn't be. And it's ghc-mod's indirect dep on binary (0.5) that conflicts with the version of binary your thing or sandbox wants (0.7)
04:02:36 <dcoutts_> bennofs: well, what is in this sandbox?
04:02:49 <dcoutts_> cabal sandbox list-sources
04:02:53 <sie> Does haskell have anything to do with nix?
04:02:53 <donri> dcoutts_: are --system installs considered "user goals"?
04:03:22 <donri> sie: not really, but they have tools wrapping cabal i think
04:03:24 <dcoutts_> donri: I don't think so, just the contents of the sandbox
04:03:27 <bennofs> Index file '/home/benno/apps/hdevtools/.cabal-sandbox/packages/00-index.tar'
04:03:30 <bennofs> has no references to local build trees.
04:03:53 <bennofs> sie: I installed some haskell packages via the nix package manager
04:04:30 <bennofs> Turns out I didn't really remove ghc-mod when I tried it before. Trying again ...
04:05:12 <bennofs> After removing the ghc-mod package, I get a different error
04:05:22 <dcoutts_> doesn't explain why it's turning up as a user goal
04:05:26 <fizruk> donri, Enzier: http://lpaste.net/94786
04:05:51 <bennofs> The issue is clearly that all system packages are listed as user goals. But I don't know whether it's cabal or nixos who does that
04:06:13 <dcoutts_> bennofs: you get this with our without using a sandbox?
04:06:18 <dcoutts_> our/or
04:06:30 <bennofs> dcoutts_: with using a sandboxes
04:06:37 <donri> fizruk: so Endo wins? ;)
04:06:49 <dcoutts_> bennofs: and not without?
04:06:57 <fizruk> donri, unexpectedly...
04:06:58 <bennofs> dcoutts_: didn't try without
04:07:06 <bennofs> let me try ...
04:07:17 <donri> fizruk: not really. Endo gives you the difference list which has O(1) append
04:07:24 <fizruk> donri, not *that* unexpectedly, but still
04:07:55 <bennofs> dcoutts_: When not using a sandbox, it indeed works
04:08:24 <Eduard_Munteanu> Hrmpf, Data.List doesn't seem to have a 'span' that takes a two-argument predicate. That's useful for stuff like  splitLocalMin = span' (>=). Is there something like that around though?
04:08:25 <fizruk> donri, I wonder what's wrong with that dummy performance test
04:08:39 <Eduard_Munteanu> The predicate inspects adjacent elements.
04:09:24 <fizruk> donri, specifically, why such a big difference for concat'
04:09:36 <Eduard_Munteanu> I guess you can use  groupBy (>=)  but it's a bit awkward.
04:10:08 <donri> fizruk: oh although you have a lot of variance there
04:10:38 <fizruk> donri: does that mean the results are unreliable?
04:10:41 <bennofs> dcoutts_: well, nixos seems to install a wrapper script for ghc that passes flags in the form -package-db .../gloss.installedconf ... to ghc
04:10:59 <bennofs> dcoutts_: could that cause the packages to become "user goals"?
04:11:39 <donri> fizruk: not sure you can get rid of that though. that's usually the gc and excessive laziness, but we can't make concat any less lazy without changing its semantics
04:12:50 <donri> fizruk: maybe if you force the replicate first and share it...
04:13:13 <fizruk> donri, e.g. with deepseq?
04:13:15 <bennofs> dcoutts_: it also passes a -B flag
04:13:53 <donri> fizruk: maybe with evaluate and force
04:14:37 <donri> xs <- evaluate . return . force $ replicate ...
04:16:28 <dcoutts_> bennofs: no, is there a cabal wrapper script too?
04:16:34 <bennofs> dcoutts_: no
04:17:18 <dcoutts_> bennofs: is the ghc-pkg one consistent with that?
04:19:00 <dcoutts_> bennofs: I can't see how any of these things could end up as user targets
04:20:39 <bennofs> dcoutts_: I also noticed that I have duplicate entries in ghc-pkg list, where the same package appears twice (with same version).
04:21:17 <donri> fizruk: variance means there's a significant difference between the best and worst run, which is suspicious for pure code that is run with the same argument
04:22:22 <absence> can functions that are part of composition chains (i.e. "f . g . h") be inlined, or must their parameters be explicit, \x -> f (g (h x)))?
04:22:40 <dcoutts_> bennofs: that's usually not good, but that doesn't seem to be the cause of our spurious dependency here
04:22:58 <bennofs> dcoutts_: yes, ghc-pkg flags seem to be consistent
04:23:08 <dcoutts_> bennofs: did you find you had the same problem without using a sandbox?
04:23:24 <fizruk> donri: where are evaluate/force?
04:23:46 <dcoutts_> @hoogle evaluate
04:23:47 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
04:23:47 <lambdabot> Control.Exception evaluate :: a -> IO a
04:23:47 <lambdabot> Control.OldException evaluate :: a -> IO a
04:23:47 <donri> absence: i think the "fully applied" rule is only used when there's an INLINE pragma
04:25:37 <fizruk> donri, evaluate from Control.Exception? can't find force still
04:25:43 <donri> @hoogle force
04:25:43 <lambdabot> Control.DeepSeq force :: NFData a => a -> a
04:25:43 <lambdabot> package force-layout
04:25:43 <lambdabot> Graphics.UI.GLUT.Initialization ForceDirectContext :: DirectRendering
04:25:47 <bennofs> dcoutts_: when not using a sandbox, everything works as expected (gloss isn't reinstalled, and when using gloss installed as constraint, there is no conflict)
04:26:06 <absence> donri: so functions with INLINE pragma shouldn't be used pointful rather than pointfree?
04:26:22 <donri> fizruk: you want force to fully evaluate the list, and evaluate . return to ensure it's evaluated *before* the benchmarks
04:26:43 <dcoutts_> bennofs: ok, we should talk to refold when he's around
04:27:24 <donri> absence: depends on how they're defined. it's purely syntactical so f = \x -> ... INLINEd will inline on just "f"
04:27:44 <absence> donri: oh right
04:27:51 <donri> absence: you probably don't want to put INLINE on your own functions unless you're edwardk though
04:30:11 <absence> donri: nah, i'm using library functions that are INLINE, so i'm just trying to avoid deliberately messing up performance :)
04:30:41 <donri> absence: hopefully the library authors considered composition and acted accordingly :)
04:31:22 <maik_> what is the best book to learn haskell for someone who has never programmed before. still "learnyouahaskell"?
04:31:43 <donri> absence: when in doubt, inspect core
04:32:06 <donri> maik_: yep
04:32:17 <absence> donri: does INLINABLE work the same way?
04:32:33 <donri> maik_: although LYAH targets programmers new to FP, primarily
04:32:45 <donri> absence: no
04:33:27 <donri> absence: btw http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html
04:35:38 <fizruk> donri, now concat' wins :) http://lpaste.net/94788
04:35:55 <fizruk> edwardk, ping
04:37:05 <donri> fizruk: you're not actually measuring Prelude.concat there though
04:37:38 <fizruk> donri, oh that's right, give me a sec
04:37:44 <mm_freak_> why doesn't GHC see that ((0 + 1) + 1) + 1 is the same as 3 on the type level?  (GHC.TypeLits)
04:38:32 <donri> fizruk: and we didn't get rid of the variance anyway :(
04:38:37 <mm_freak_> is that intentional or is my GHC just too old?
04:38:48 <fizruk> donri, yeah
04:39:40 <donri> mm_freak_: http://ghc.haskell.org/trac/ghc/wiki/Status/Oct13 mentions "type natural solver", relevant?
04:40:41 <fizruk> edwardk, just reminding you about wrapT
04:42:26 <quicksilver> my understanding is that the solver is very weak at the moment
04:42:34 <quicksilver> but I don't know exactly what it can/can't do
04:42:44 <donri> quicksilver: but non-existent in <7.8 right?
04:43:10 * quicksilver doesn't remember if any made it into 7.8
04:43:13 <mm_freak_> donri: indeed
04:44:12 <trapdoor> Is there an extension or something what can do partial application of any argument, not just leftmost? i.e. given «takes3 a b c = print (a, b, c)» doing something like «takes3 "foo" _ "baz"» to produce a lambda with a middle argument to be applied and.
04:44:35 <fizruk> donri, Enzier: anyway here's final thing (with huge variance) http://lpaste.net/94791
04:44:55 <danr> trapdoor: nothing primitive, except for tuple sections
04:45:06 <danr> @type \ a c -> print . (a,,c)
04:45:08 <lambdabot> Illegal tuple section: use -XTupleSections
04:45:30 <donri> you could combine tuple sections with type-classed curry ;)
04:45:33 <donri> @hackage curry
04:45:34 <lambdabot> http://hackage.haskell.org/package/curry
04:45:38 <donri> @hackage tuple rather
04:45:38 <lambdabot> http://hackage.haskell.org/package/tuple rather
04:46:25 <danr> donri: good ponit
04:46:32 <danr> point
04:49:45 <trapdoor> donri: nice.. is there a reason why this isn't implemented yet? looks like it's already detected in syntax: «<interactive>:1:14: Pattern syntax in expression context: _»
04:50:12 <quicksilver> trapdoor: yes.
04:50:29 <quicksilver> the reason is, you need something else to tell it where the "outside" of the expression is.
04:50:43 <quicksilver> where do you put the implicit lambda
04:51:03 <danr> trapdoor: I think it is not as straightforward as it first looks, do you want f (g _ (h _)) to be f (\ x y -> g x (h y)) or f (\ x -> g x (\ y -> h y))
04:51:07 <quicksilver> of course you can devise an answer to that question but it's not quite as obvious as it appears
04:51:24 <danr> right, what quicksilver is pointing at
04:51:33 <quicksilver> and, in the end, lambda notation is actually a good notation for this idea
04:51:51 <quicksilver> still some languages do allow it
04:52:08 <quicksilver> but with other syntax choices things might be a bit clearer.
04:52:19 <quicksilver> it's quite straightforward in a langauge with Java/C-style function calls
04:52:24 <quicksilver> (not curried)
04:53:00 <trapdoor> hm.. yeah, perhaps lambda is really that fits here anyway
04:54:31 <donri> _ would conflict with TypeHoles
04:54:54 <quicksilver> there was a conversation about it a few years ago which covered some of the points
04:54:58 <quicksilver> http://www.haskell.org/pipermail/haskell-cafe/2007-July/027848.html
04:55:12 <quicksilver> it does come up from time to time because it's a very natural idea, but has some trade-offs which aren't visible at first glance :)
04:55:34 <donri> didn't someone make a preprocessor implementing it
04:55:44 <quicksilver> pigworker's response in particular - http://www.haskell.org/pipermail/haskell-cafe/2007-July/027896.html - with terible line breaks.
04:57:31 * hackagebot tidal 0.2.7 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.2.7 (AlexMcLean)
04:57:34 <fizruk> donri, someone did
04:57:55 <danr> quicksilver: interesting link, thanks
05:01:21 <Flonk> Wouldn't it be super practical if (.)==fmap?
05:02:04 <donri> oh god no, Category please!
05:02:10 <Cale> Flonk: I think so
05:02:38 <mm_freak> put Category into Prelude
05:02:42 <Cale> There still aren't enough instances of Category I feel to make that particular generalisation.
05:03:00 <donri> Cale: maybe because it's so hard to import :P
05:03:02 <Cale> (and Category is kind of weird)
05:03:28 <mm_freak> a much more useful generalization
05:03:28 <mm_freak> Cale: we already have (<$>)
05:04:37 <Cale> mm_freak: Well, for instance, you probably wouldn't want to use <$> everywhere that you presently use composition.
05:04:46 <Cale> (because it's comparatively noisy)
05:05:09 <mm_freak> Cale: f . g <$> x
05:05:10 <Cale> But generally if you are chaining fmap, then all but the last one in the chain will be using the function instance anyway
05:05:12 <mm_freak> would you really prefer (f . g) . x?
05:05:26 <donri> i would like to use (.) anywhere i have (<<<) though ;)
05:05:26 <Cale> I think it's rather nice that the functor law looks like associativity ;)
05:05:48 <donri> also <$> reads better together with the applicative/alternative operators
05:05:52 <Cale> donri: But where are you using (<<<)? Do you write a lot of Arrow code?
05:06:05 <donri> Cale: no, but Category comes up a lot
05:06:11 <Cale> Oh?
05:06:12 <mm_freak> Cale: you may be using different abstractions…  i import Control.Category and Prelude hiding ((.), id) into almost every module i write
05:06:32 <Cale> What Category instances are you using?
05:06:47 <mm_freak> and honestly it pisses me off to have to do that…  there isn't even a shortcut, because there is no way around importing Prelude
05:07:02 <mm_freak> Cale: boomerang parsers, wires, automata
05:07:17 <donri> lenses, wires, free categories, boomerang
05:07:31 * hackagebot hslogstash 0.3.2 - A library to work with, or as, a logstash server  http://hackage.haskell.org/package/hslogstash-0.3.2 (SimonMarechal)
05:07:31 <Cale> i.e. non-lens lenses?
05:07:40 <donri> yeah
05:07:42 <mm_freak> donri: lenses don't actually require the generalization
05:07:48 <donri> i know
05:07:48 <mm_freak> ah
05:07:59 <donri> but previously with data-lens, and people do use fclabels
05:08:01 <bennofs> Does anyone know what the -B flag to for GHC?
05:08:19 <bennofs> s/to/does/
05:08:38 <mm_freak> i do like fclabels
05:08:47 <mm_freak> lens is too much of a monster
05:09:09 <donri> it's too bad pipes' Proxy can't actually be a Category
05:09:29 <donri> but it is a "category" :P
05:09:34 <mm_freak> donri: it could be one, but then it's not directly a monad anymore
05:09:34 <donri> well, five. :P
05:09:39 <donri> exactly
05:10:16 <mm_freak> data Proxy r a' b' m a b
05:10:38 <mm_freak> however, it's more sensible as it is right now =)
05:10:44 <donri> yeah
05:11:06 <mm_freak> if you insist, you can still newtype it into a Category =)
05:11:38 <donri> in deed. i just would like it if it could be both at the same time
05:12:32 * hackagebot hslogstash 0.3.3 - A library to work with, or as, a logstash server  http://hackage.haskell.org/package/hslogstash-0.3.3 (SimonMarechal)
05:13:01 <donri> mm_freak: wait why can't it be (Monad m) => Monad (Proxy r a' b' m a) ?
05:13:58 <donri> oh because the (codomain?) of the category is different from the monad return type
05:14:18 <donri> ie. r /~ b
05:14:32 <mm_freak> donri: that would be a monad for stream composition
05:15:11 <mm_freak> it would be a different monad that would repeat all past side effects for every value you've passed downstream so far
05:16:51 <donri> mm_freak: btw could Wire be a Monad? is it just not provided because it would have bad performance, or because the types don't work out?
05:17:49 <donri> http://hackage.haskell.org/package/machines-0.2.3.1/docs/Data-Machine-Mealy.html  "slow diagonalization" :P
05:18:20 <fizruk> what's diagonalization?
05:18:43 <donri> mm_freak: hey wait is Wire basically a mealy machine?
05:19:35 <donri> fizruk: in this case i imagine it's vertical composition?
05:19:40 <mm_freak> donri: Wire would have exactly the same problem as Proxy =)
05:19:51 <mm_freak> donri: Wire is almost Mealy
05:20:06 <mm_freak> newtype Mealy a b = Mealy (a -> (b, Mealy a b))
05:20:18 <mm_freak> newtype Wire a b = Wire (a -> (Maybe b, Wire a b))
05:21:10 <fizruk> mm_freak, doesn't that mean Wire a b ~ Mealy a (Maybe b) ?
05:21:38 <mm_freak> fizruk: no
05:21:50 <fizruk> donri, i'm not familiar with wire/machines
05:22:49 <mm_freak> fizruk: w1 . w2 has different semantics
05:27:12 <fizruk> mm_freak, w1 . w2 stops when w1 stops (kind of)?
05:28:00 * fizruk perhaps shouldn't ask stupid questions...
05:51:34 <Narvius> Is there a more concise way to get a list of all unwrapped non-Nothing values in a list of Maybe a's than filtering out the Nothings and then mapping with fromJust?
05:52:06 <Taneb> @type catMaybes
05:52:07 <lambdabot> [Maybe a] -> [a]
05:52:18 <Taneb> Narvius, try that
05:52:31 <Narvius> Thanks
05:52:41 <FreeFull> It's in Data.Maybe
05:53:03 <bag-man> I have started learning Haskell today, I am enjoying it so far but I am a bit confused as to how I call a function. Here is what I have so far: http://sprunge.us/dDaQ
05:53:10 <bag-man> How would I square 5 for example?
05:53:31 <Narvius> "square 5"
05:53:34 <Kinnison> simply 'square 5'
05:53:40 <fizruk> bag-man, main = print (square 5)
05:53:51 <relrod> /1/4
05:53:51 <Narvius> Also, catMaybes is just what I want; thanks.
05:53:53 <relrod> gah
05:54:00 <FreeFull> bag-man: You probably should be using ghci to make things easier for yourself
05:54:04 <Kinnison> > let square x = x * x in square 5
05:54:05 <lambdabot>   25
05:54:15 <Taneb> :)
05:55:29 <bag-man> If I add square 5 or print (square 5) at the EOF I get "Naked expression at top level" I assume this is because the code isn't part of the main function?
05:55:44 <Kinnison> correct
05:55:55 <Kinnison> you need the 'main ='
05:56:20 <bag-man> Kinnison: How can I add more than one line to the main though?
05:56:24 <FreeFull> main is what gets executed when your program gets run
05:56:33 <FreeFull> For more than one line, you'll have to use do notation
05:56:47 <Ghoul_> bag-man: for now, just use main = print (square 5)
05:57:00 <Ghoul_> I dont recommend do-notation yet.. its really confusing at first
05:57:06 <Ghoul_> especialy the types.
05:57:23 <FreeFull> bag-man: What book are you following along to learn?
05:57:37 <Ghoul_> @where lyah
05:57:37 <lambdabot> http://www.learnyouahaskell.com/
05:57:39 <Ghoul_> ^ is a good one
05:57:41 <bag-man> Ghoul_: Hmm but if I want to do more than two things in main (On separate lines)
05:57:52 <Ghoul_> bag-man: yeah its more complex unfourtunately
05:57:55 <bag-man> Yeah I have been recommended that :) I am doing it as part of my coursse
05:57:59 <Ghoul_> you have to do a chapter on types to understand it
05:58:12 * Kinnison nods
05:58:17 <FreeFull> There is also https://www.fpcomplete.com/school/haskell-fast-hard/haskell-fast-hard-part-1
05:58:25 <bag-man> Also anyone use xmonad? Would it help me to learn Haskell?
05:58:27 <Ghoul_> haskell: fast and hard is a little fast and hard
05:58:34 <bennofs> bag-man: If you just want to try out your function, you could still run it from GHCi
05:58:40 <FreeFull> Although I used LYAH myself at first.
05:58:49 <Kinnison> bag-man: I use XMonad, and no it won't help that much
05:58:59 <Ghoul_> first half LYAH -> first half RWH -> second half LYAH -> second half RWH -- is a good way to do it
05:59:14 * Kinnison nods. LYAH and RWH together were good for me
05:59:19 <bag-man> Kinnison: Is it configured when it is compiled or is there a file you configure in haskell?
05:59:27 <FreeFull> bag-man: I use xmonad, and it's more that I started using it because I already knew haskell
05:59:40 <FreeFull> RWH is starting to show its age
05:59:42 <Ghoul_> isn't xmonad a DSL?
06:00:13 <FreeFull> Ghoul_: It's a window manager
06:00:32 <Kinnison> bag-man: You have an xmonad.hs which you can use to configure it
06:00:33 <Ghoul_> I know what it is, but I don't think I would recommend trying to learn haskell by modding xmonad
06:00:37 <Kinnison> bag-man: But that then recompiles xmonad
06:00:44 <bag-man> Ah coo
06:00:45 <bag-man> l
06:00:49 <Kinnison> bag-man: mostly I recommend not using xmonad until you are comfortable with haskell
06:00:57 <Kinnison> bag-man: at least the syntax and meaning of what you read
06:01:08 * Kinnison didn't dare switch to xmonad until he was a few months into learning
06:01:12 <FreeFull> Ghoul_: I wouldn't say it is a DSL though
06:01:13 <merijn> Kinnison: Heh
06:01:16 <bag-man> Fair enough
06:01:22 <Ghoul_> I tried to learn haskell by writing a parser and had the worst time until I learnt about monads, functors and applicatives for real
06:01:31 <merijn> bag-man, Kinnison: I've heard like tons of people using xmonad without knowing any haskell
06:01:31 <bag-man> Any good example programs I can study?
06:01:34 <Ghoul_> the type system is so brutal on beginners ;(
06:01:47 <FreeFull> It wasn't brutal on me
06:01:48 <Kinnison> merijn: Anyone who does, either doesn't configure it, or doesn't understand their configuration file
06:01:52 <Kinnison> merijn: that process is not for me
06:01:53 <sie> It has no mercy.
06:01:55 <FreeFull> I just went. "Oh, that is awesome"
06:02:08 <Kinnison> FreeFull: No, Awesome is a Lua-based WM
06:02:11 * Kinnison hides
06:02:18 <FreeFull> It's not like the wimpy type systems of other languages
06:02:19 <bag-man> lol
06:02:25 <FreeFull> Kinnison: Well, it is written in C
06:02:35 <FreeFull> Well, most other languages I mean
06:02:36 <Ghoul_> yeah, its friendly, until you get a return wrong somewhere
06:02:38 <merijn> bag-man: Depends, how experienced are you in other languages? How far are you with haskell?
06:02:46 <Ghoul_> and it gives you a huge 3-line type error because of the huge meta types of some parsers
06:02:54 <Ghoul_> and then as a beginner you sit there like
06:03:03 <FreeFull> Ah, I've never done any parsing stuff
06:03:06 <bag-man> merijn: Literally just had my first lecture today. Though I am comfortable with Java C and a fair few other languages
06:03:37 <merijn> bag-man: Ah, then I would mostly recommend plowing through Learn You a Haskell and not try to study existing code until then
06:03:38 <FreeFull> I know how to implement lenses from scratch though
06:04:30 <bag-man> merijn: Okidokes, I think I will just have to hope LYAH and lectures suffice
06:04:34 <Kinnison> Parsing is pretty fun with Parsec
06:04:57 <merijn> bag-man: In my personal experience the abstract nature of haskell makes code reuse a lot more common, which means that trying to study "idiomatic" haskell, has quite a steep learning curve until the "basic" abstractions everyone takes for granted are more familiar
06:05:04 * Ghoul_ looks around for the trifecta guy
06:05:13 <bennofs> I did C++ before Haskell, and really liked the clear error messages
06:05:15 <Ghoul_> seriously, trifecta kicks ass.
06:05:18 <bennofs> (of Haskell)
06:05:33 <bag-man> bennofs: Really? My first impressions of haskell are incredibly unclear errors
06:05:45 <bennofs> Try C++ with boost
06:05:58 <merijn> bag-man: They're not great, they're not terrible either
06:06:24 <Ghoul_> reminds me of that "2 megabyte error" people were joking around in that layers thread on reddit
06:06:39 * Kinnison thinks there's a trick to reading a haskell compiler error and once you have it, they make sense.  Until then, they're often impenetrable
06:06:41 <Ghoul_> monad errors are evil and hard to understand
06:06:43 <merijn> bag-man: It requires a certain mind frame, though. The problem is that if you rely solely on type inference the wrong types of your code may not be visible to the compiler until a completely different point in the program
06:06:53 <fizruk> I didn't have clearer error messages in any other language
06:07:03 <davean> bag-man: You consider the things you get out of STL "clear"?
06:07:05 * bennofs agrees with fizruk
06:07:09 <merijn> bag-man: The more types you annotate, the quicker and more accurately GHC pinpoints the errors
06:07:12 <yesthisisuser> it helps sometimes to think of it as programming in two separate domains.. the type level and the expression level
06:07:39 <FreeFull> I mostly have found the errors helpful
06:07:43 <fizruk> I mean I can always follow the types and *understand* what the error actually means even if it looks cryptic
06:07:46 * bennofs thinks what happens when you use a monad library in C++
06:07:47 * Kinnison mostly writes type signatures to make my life easier
06:07:54 <Kinnison> Every now and again they make things compile too :-)
06:08:19 <merijn> bag-man: Most of the complexity of type errors comes from GHC getting stuck on type inference far away from where you screwed up the code. Being able to trace back from the error to code requires a feeling for how type inference works
06:08:49 <merijn> bag-man: On the other hand, I encourage newbies to write explicit types everywhere (at least for top level functions) anyway, as it's good practice and helps debugging problems when asking questions here
06:09:00 <fizruk> and every time I got a cryptic error, it basically said that I'm making a bad design
06:09:05 <bag-man> Cool :) Thanks for all the advice guys!
06:09:06 <merijn> Anyhoo, I need to run
06:09:14 <bag-man> merijn: Thanks :)
06:09:17 <Narvius> I have been digesting Kmett's talk on Lenses the past three days, and right now I'm trying to start to use them
06:09:23 <Narvius> So amazing :O
06:09:29 * bennofs agrees
06:09:43 <quicksilver> three days to digest, edwardk is haskell's red meat.
06:09:57 <Ghoul_> if you know what you're doing enough, but dont know a type, you can chuck :: Int infront of stuff and the compiler will tell you a type
06:10:01 <yesthisisuser> i hope someone can write a LYAH for lenses
06:10:41 <yesthisisuser> LYAL
06:10:46 <bag-man> Also you guys probably hate this question but I have to ask it... "What is Haskell ACTUALLY used for?", like I know it is great to learn because it teaches you a whole new way of thinking and programming. However the only Haskell project I am aware of is XMonad, the rest I can find are very niche bits of software written  by/for large comapnies
06:10:48 * bennofs waits for the day he can tell people to use GHC TypeHoles instead of ()
06:11:24 <yesthisisuser> Haskell has some pretty solid web frameworks.. Snap. Happstack and Yesod to mention the most well-known
06:11:41 <bag-man> yesthisisuser: Yet I haven't heard of any of them...
06:11:45 <davean> bag-man: pandoc is pretty commonly used
06:11:55 <yesthisisuser> http://snapframework.com/
06:12:05 <davean> Though most people I know don't realize pandoc is haskell
06:12:06 <yesthisisuser> http://www.yesodweb.com/
06:12:06 <fizruk> bag-man, Haskell is also used at Facebook and Microsoft afaik
06:12:18 <yesthisisuser> http://www.happstack.com
06:12:35 <bag-man> http://www.nodejs.org
06:12:48 <merijn> bag-man: I know at least Standard Chartered is using Haskell and their own custom Haskell dialect, there's the financial thingy edwardk works, Facebook is doing a bunch of haskell, nowadays
06:12:51 <yesthisisuser> Haskell is also used in the  financial industry
06:12:52 <davean> bag-man: also, it is nitch, but not for/by large companies, but git-annex
06:12:58 <Ghoul_> @where industry
06:12:58 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_industry
06:13:04 <Ghoul_> Oh! magic, I got it first time.
06:13:05 <bag-man> fizruk: It seems they use Haskell to help write other bits of code in other languages, rather than make products in Haskell
06:13:11 <bennofs> bag-man: darcs, XMonad, (GHC, cabal -- well they are haskell dev tools), Pandoc, BazQux(bazqux.com, a RSS reader written in Haskell and Ur/Web)
06:13:32 <Ghoul_> darcs
06:13:32 <fizruk> bag-man, yes Haskell is used a lot for internal purposes
06:13:36 <bag-man> I shall re-phrase, WHY would I use Haskell over other languages? (Not attacking Haskell I am keen to learn)
06:13:36 <bennofs> bag-man: That's because haskell is awesome for compiles / code generators
06:14:16 <merijn> bag-man: Because it requires I do the least amount of coding and the least amount of bugfixing to get to working code :)
06:14:34 <Narvius> My reason is that it will improve the way I code in general.
06:14:45 <Narvius> Common Lisp and Clojure already vastly improved my C# code.
06:14:59 <Entroacceptor> bag-man: or if you're into open source team shooters http://ojeling.net/apelsin/!
06:15:08 <bennofs> Because it forces you to actually handle those edge cases that you miss in most other languages
06:15:11 <Narvius> And Haskell has a whole slew of new stuff that I can steal for my personal enlightenment. :]
06:15:12 <davean> I use it because I can come back to projects that have been running, untouched for years and actually make changes in them immediately
06:15:31 <davean> I've never managed that with other languages, they've always taken refamiliarization
06:15:47 <davean> (with the project)
06:16:58 * fizruk is just fond of beautiful abstractions and mind-bending...
06:17:00 <bag-man> Rightio, well thanks for the insight it has been most informative!
06:17:18 <bag-man> I must depart I have other things to work on sadly, no doubt I will be back someday soon!
06:17:34 <Ghoul_> beware, you can catch FP.
06:17:57 <Ghoul_> today I had to normalize an angle, and instead of using a modulus or anything I did something like this in C:
06:17:58 <Narvius> Okay. Lenses. I have a [(a, Maybe b)], and want to have a [(a, b)] with b=Nothing filtered out.
06:18:07 <Narvius> There is bound to be a neat solution to this. :D
06:18:56 <Ghoul_> int normalize(int angle) { if (angle > 360) { normalize(angle - 360); } return angle; } // hehe creeped into the wrong idiom
06:19:15 <Narvius> heh.
06:20:14 <davean> Ghoul_: ... that seems inefficient
06:20:27 <simukis_> Ghoul_: yeah, you can angle `mod` 360 😃
06:20:38 <simukis_> oh
06:20:43 <Ghoul_> I'm aware of that.
06:20:49 <simukis_> didn't read enough backlog
06:20:54 <davean> Ghoul_: My point is that isn't good FP :-p
06:21:14 <Ghoul_> although, actually, in my defense
06:22:00 <Ghoul_> it was Interactive C, not real C, and the modulus function was giving me really weird errors for floats when I later had to use floating angles.
06:22:27 <Ghoul_> /s/function/operator/
06:23:16 <davean> Ghoul_: Hum, then it becomes an itneresting question what the best way to do it is.
06:23:36 <davean> esp. taking into account numerical error
06:23:45 <Ghoul_> O(n) complexity or expensive O(1), that *is* the question.
06:30:44 <Narvius> Is there a concise list of Lens combinators somewhere? :x
06:30:53 <Narvius> Because the Hackage page is kinda sucky.
06:31:19 <Taneb> Narvius, try https://github.com/ekmett/lens/wiki/Operators
06:31:29 <Narvius> THANK you.
06:32:04 <Taneb> :)
06:39:30 <Cale> Narvius: For the most part, I find the Hackage to be quite good. I don't really like using the infix operators in lens though.
06:39:33 <donri> Narvius: also http://hackage.haskell.org/package/lens-3.10/docs/Control-Lens-Operators.html
06:39:37 <donri> if you wanted operators
06:39:45 <donri> basically everything in lens is a combinator ;)
06:40:27 <Cale> (why does the lens package show up on the second page of results when I search for 'lens' on Hackage?)
06:40:47 <Cale> Also, who decided that 10 items at a time would be a good idea?
06:40:54 <donri> Cale: maybe because it has Lenses, not Lens, in the synopsis
06:41:04 <donri> agreed on the pagination
06:41:22 <donri> worse still that it doesn't tell you how many results or pages there are
06:41:43 <donri> oh look you can give it &limit=100
06:41:49 <Cale> yeah, you can
06:41:56 <Cale> (but you have to do it every time)
06:41:59 <donri> yep
06:42:56 <ion> Comments, anyone? “What is inside Haskell IO?” https://gist.github.com/ion1/7154691
06:43:53 <donri> @quote shachaf files
06:43:53 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
06:45:40 <Narvius> Because I'm still wondering whether I can turn a [(a, Maybe b)] into [(a, b)] where all Maybe b == Nothing are filtered out, via lens stuff.
06:45:51 <donri> ion: have you seen the IOSpec package
06:45:52 <Cale> ion: I only skimmed it, but it looks good :)
06:46:05 <ion> donri: Nope. Thanks, i’ll take a look.
06:47:00 <fizruk> Narvius, i only made it to `xs ^.. folded.filtered (has $ _2._Just)` -- and one should apply fromJust then...
06:48:00 <donri> ion: also free/operational. i think your MiniIO might not quite be a legal monad
06:48:18 <Narvius> Thanks.
06:52:42 <fizruk> Narvius: perhaps it could be folded.filtered (has $ _2._Just).mapped (_2.to fromJust) with something appropriate instead of mapped
06:53:50 <bennofs> @ty toListOf (traverse . _2 . traverse) :: [(a, Maybe b)] -> [b]
06:53:53 <lambdabot> [(a, Maybe b)] -> [b]
06:54:37 <ion> donri: I wanted this to be usable as a self-contained tutorial to how IO works for newbies. I’m not sure i should use Free for that. And for this purpose duplicating a tiny subset of IOSpec should be okay. I’ll figure out if i’m violating monad laws a bit later and fix whatever’s needed.
06:57:36 <ocharles> any uu-parsinglib users around? I want have parser for identifier, and I just want the underlying string that is matched
06:58:25 <ocharles> e.g., foo (pLetter *> many (pLetter <|> pDigit)) will give me a parser that parsers a letter and then many letters or digits, but will just return this as a string
06:59:13 <ion> Do you mean “(:) <$> pLetter <*> many (pLetter <|> pDigit)”?
06:59:29 <ocharles> that would work, but it means I have to reallocate
06:59:50 <ocharles> but more annoyingly, means I have to manually glue things back together
07:00:33 <sie> If I pass Nothing to fmap, it knows to do nothing with it, because Maybe has implemented something of Functor? Can someone expand on this so it makes more sense to me?
07:01:11 <danr> sie: for Maybe, the case for Nothing is defined as fmap f Nothing = Nothing
07:01:16 <donri> ion: that's cool, it's probably not important for a simplified example. but i think, you can't really have Bind in the same type (without type indexes) and preserve associativity
07:01:27 <danr> sie: and the other case is fmap f (Just x) = Just (f x)
07:01:28 <eikke> sie: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-Maybe.html#Maybe, see "instance Functor Maybe where ..."
07:01:29 <FreeFull> sie: Maybe has a functor instance, where   fmap f Nothing = Nothing; fmap f (Just x) = Just (f x)
07:02:41 <ion> donri: Ok, thanks. I’ll have to give the issue some thought.
07:03:21 <sie> I see an instance of Functor Maybe in Data.Maybe docs, but I don't see where to click for it to lead me to the implementation.
07:03:33 <donri> ion: it's explained in this talk http://skillsmatter.com/podcast/scala/monads-for-free
07:03:33 <eikke> sie: see the link I gave above
07:03:58 <sie> eikke, Oh, yes indeed. Was it from docs or hoogle?
07:04:01 <ion> donri: Thank you. Will watch.
07:04:13 <eikke> from hoogle to docs to 'source'
07:04:36 <ion> sie: Many of us wish Haddocks had links to instance sources. Nobody has got around to making a patch yet. :-)
07:04:55 <ocharles> oh well, I guess I'l live with concat <$> sequenceA [ parts ]
07:05:22 <donri> haddock needs a number of improvements. type families, gadts, fixities...
07:05:23 <ion> sie: But instance implementations are almost always close to either the definition of the class (like Functor) or the definition of the type (like Maybe).
07:05:59 <eikke> preferably the latter :)
07:06:05 <sie> Thanks guys — this is pretty cool.
07:06:49 <donri> sie: you can think of Maybe a as [a] that can only have zero or one elements
07:07:02 <donri> sie: fmap then is a lot like map for list
07:07:15 <sie> Interesting perspective.
07:08:10 <ion> The Applicative and Monad instances also behave just like with lists with the same size constraint.
07:09:03 <donri> also Foldable and Traversable. not Monoid though
07:09:16 <ion> nor Alternative
07:09:25 <eikke> > Data.Foldable.toList Nothing
07:09:27 <lambdabot>   Not in scope: `Data.Foldable.toList'
07:09:27 <lambdabot>  Perhaps you meant `Data.Foldable.fold...
07:09:31 <donri> the Maybe monoid is just silly. but even First and Last are different from the list monoid
07:09:37 <ion> @type Fol.toList
07:09:38 <lambdabot> Couldn't find qualified module.
07:09:41 <ion> @type F.toList
07:09:42 <lambdabot> Foldable t => t a -> [a]
07:10:21 <donri> @check \x -> F.toList x == maybeToList x
07:10:28 <lambdabot>   mueval-core: Time limit exceeded
07:11:19 <ion> @check \x -> F.toList x == maybeToList (x :: Maybe Integer)
07:11:25 <lambdabot>   +++ OK, passed 100 tests.
07:14:48 <t4nk353> hi there, say I had a list of 26 tuples and wanted to check every letter of alphabet was present as snd element how would I go about this?
07:15:24 <bennofs> t4nk353: Extract snd element of each tuple, sort the resulting list and compare to ['a'..'z'] ?
07:16:05 <t4nk353> does Hugs have a compareto function? can't remember
07:16:10 <t4nk353> because I have to use hugs
07:16:18 <bennofs> t4nk353: just use == ?
07:16:25 <t4nk353> oh of
07:16:26 <t4nk353> ofc
07:16:26 <t4nk353> hahah
07:16:29 <t4nk353> easy peasy
07:16:44 <t4nk353> cheers
07:17:43 <ocharles> meh, I'm not having much luck with uu-parsinglib
07:17:54 <ocharles> 'parse (pListSep_ng pSpaces (some pLetter) <* pEnd) (createStr (0::Int) "Add")'
07:17:57 <donri> t4nk353: might also want nub there if a character can occur more than once
07:17:59 <ocharles> that says "Ambiguous parser?"
07:18:07 <ocharles> but I can't see any other way to phrase it :|
07:19:09 <Cale> t4nk353: Did you have that nick chosen for you, or did you pick it? It strikes me that I've seen more than one person recently with a nick in the form t4nk###
07:19:16 <t4nk353> chosen for me
07:19:29 <t4nk353> I'm not a regular. I'll change it now
07:20:09 <t4nk353> how do I change my nick
07:20:10 <t4nk353> ?
07:20:16 <Demac> there we go
07:21:54 <iguano> http://www.theweeklypay.com/index.php?share=19844/
07:22:19 <iguano> http://www.theweeklypay.com/index.php?share=19844/
07:22:31 <flux> iguano, I think you were doing well before pasting twice
07:22:38 <iguano> ok
07:22:39 <flux> who is going to click an obviously spammed url?
07:23:05 <flux> not to mention the url is pretty fishy to begin with. and not a good way to start conversation on a channel.
07:23:08 <ion> Wat, a spambot answered a comment? :-D
07:26:00 <Demac> not sure how I would get a list of 2nd elements of a list of 2-tuples
07:26:08 <Demac> do I need the map function?
07:28:25 <Ankhers> Using list comprehension, you could do something like [ y | (x, y) <- a ]
07:28:31 <Ankhers> assuming a is your list of tuples.
07:28:55 <simpson> > map snd [(1,2),(3,4),(5,6)]
07:28:57 <lambdabot>   [2,4,6]
07:29:37 <Demac> ah perfect
07:36:46 <fizbin> :t let uci p f = uncurry (\x -> p (f x)) in uci . uci . uci . uci id
07:36:47 <lambdabot> (a3 -> b1 -> b -> c) -> (a -> a1 -> a2 -> (a3, b1)) -> (a, (a1, (a2, b))) -> c
07:37:49 <fizbin> :t let uci p f = uncurry (\x -> p (f x)) in uci . uci . uci . uci
07:37:50 <lambdabot> (t -> b -> c) -> (a -> a1 -> a2 -> a3 -> t) -> (a, (a1, (a2, (a3, b)))) -> c
07:37:51 <cognominal> https://github.com/evancz/Elm/blob/master/compiler/Docs.hs uses the .= operator. I can't figure out where it is defined. Help!
07:38:06 <fizbin> That's a Lens thing.
07:39:14 <fizbin> http://hackage.haskell.org/package/lens-3.10/docs/Control-Lens-Setter.html#v:.-61-
07:40:20 <cognominal> thx, fizbin. I don't see where it is imported though
07:42:09 <fizbin> Oh, I hadn't looked at the original. That's not using Lens's .= it's using the one in Aeson: http://hackage.haskell.org/package/aeson-0.6.2.1/docs/Data-Aeson.html#v:.-61-
07:42:57 <cognominal> I am using emacs, is this the kind of thing I could figure out by myself using scion?
07:43:17 <fizbin> @pl let uci p f = uncurry (\x -> p (f x)) in uci
07:43:17 <lambdabot> (uncurry .) . (.)
07:43:45 <jml> just got prompted for which of the three different indentation modes emacs should use
07:44:09 <jml> any recommendations, or any means of distinguishing between the options without trying each of them?
07:44:14 <fryguybob> cognominal: I think the one you are looking at comes from Data.Aeson: http://hackage.haskell.org/package/aeson-0.6.2.1/docs/Data-Aeson-Types.html#v:.-61-
07:44:47 <cognominal> thx, fizbin, fryguybob  that makes a lot of sense now.
07:44:51 <fizbin> cognominal: I don't know; I knew what it was because I saw it being used in the middle of toJson stuff and so figured "oh, it's probably something in Aeson since that's one of those libraries that likes to play with syntax"
07:45:15 <fryguybob> Oh, I missed fizbin's clearification.  Oops.
07:46:04 <bennofs> cognominal: you could use hayoo
07:46:07 <bennofs> @where hayoo
07:46:07 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html – See also Hoogle: http://haskell.org/hoogle
07:46:08 * jml finds http://stackoverflow.com/questions/11365815/what-are-the-similarities-and-differences-among-haskell-indentation-modes-for-em
07:46:54 <siwica> I am about to install haskell on Ubuntu 13.04. What's the difference between the "precise", "quantel" and "saucy" platform?
07:48:05 <quchen> siwica: Those are Ubuntu versions, not Haskell Platform versions.
07:48:14 <monoidal> siwica: they are names of ubuntu versions, there should be raring for 13.04
07:48:53 <siwica> ok, didn't know that. however there is no raring
07:49:15 <siwica> on http://packages.ubuntu.com/search?keywords=haskell-platform
07:50:02 <sm> odd
07:50:02 <cognominal> bennofs, indeed this seems better than hoogle. Thanks
07:50:31 <bennofs> Unfortunaly, hayoo has quite many downtimes :(
07:50:38 <monoidal> siwica: I would try saucy, since it has the newest platform version
07:50:54 <monoidal> siwica: if it won't work, then quantal
07:51:15 <sm> monoidal: you're saying try show packages on 13.04 ?
07:51:28 <sm> try those packages on 13.04 ?
07:52:00 <monoidal> sm: aptitude install haskell-platform
07:52:13 <monoidal> or apt-get
07:53:23 <DanielDiaz> hi there! if the only operation I am going to do after creating a moderately big structure is /lookup/, what structure should I use? Array?
07:53:39 <DanielDiaz> hashmap?
07:55:45 <shepheb> DanielDiaz: what type are the keys?
07:55:46 <monoidal> siwica: sorry, I meant you, can you try installing haskell-platform using apt?
07:56:28 <DanielDiaz> shepheb: ideally strings
07:57:16 <shepheb> long shot, but: I'm struggling to find a talk I read slides for perhaps two years ago, describing the weaknesses of the relational model and a categorical approach instead. anyone have any idea what I'm talking about?
07:57:57 <siwica> monoidal: aptitude gives me: Couldn't find any package whose name or description matched "haskell-platform"
07:57:57 <siwica> (is the name different)
07:57:59 <siwica> ?
07:58:22 <shepheb> DanielDiaz: a trie, perhaps?
07:58:53 <shepheb> O(length-of-query), regardless of the size of the collection.
07:58:58 <iguano> http://www.theweeklypay.com/index.php?share=19844/
07:59:03 --- mode: ChanServ set +o geekosaur
07:59:10 --- mode: geekosaur set +b *!*iguano@166.48.42.*
07:59:10 --- kick: iguano was kicked by geekosaur (iguano)
07:59:26 <geekosaur> third time for that URL + they've been hititng other channels I'm in
07:59:27 <DanielDiaz> shepheb: a trie sounds good, but I thought maybe there is a O(1) access structure around?
07:59:38 --- mode: geekosaur set -o geekosaur
07:59:39 <DanielDiaz> shepheb: like vector does
07:59:43 <shepheb> depends on what you mean by O(1)
07:59:54 <DanielDiaz> shepheb: constant time
07:59:55 <gspr> siwica: haskell-platform was introduced in Debian in Squeeze and in Ubuntu in Saucy (13.10)
07:59:58 <shepheb> a hashing algorithm would still need to process every character in the string to hash it...
08:00:02 <shepheb> is that constant?
08:00:12 <Cale> DanielDiaz: Any structure which can hold arbitrarily many elements will have at least O(log n) time for lookup
08:00:22 <monoidal> siwica: I would install binaries then
08:00:23 <gspr> (it's just a meta-package, the individual packages at the appropriate versions may or may not have been available before then)
08:00:33 <Cale> (because any function with a range that has n elements takes at least O(log n) time to compute)
08:00:34 <monoidal> gspr: there are packages for 12.10 though
08:00:45 <DanielDiaz> ok
08:00:46 <gspr> monoidal: Ah, ok, but not in the official repos, I guess?
08:01:03 <DanielDiaz> Cale, shepheb: thank you
08:01:09 <monoidal> gspr: I think in official repos, but I'm not speaking with certainity
08:02:01 <Cale> A lot of references lie about the performance of hashtables by ignoring the cost of computing the hash function (the cost of computing the hash function has to grow as you increase the size of the hashtable)
08:02:18 <monoidal> siwica: can you check the ghc6 package?
08:02:54 <Cale> (and if you don't resize the hashtable, lookups become worse than constant time, because things end up in the same bucket)
08:02:59 <DanielDiaz> Cale: but my table will be of a fixed size. It will not change in all the execution of the program, and each execution may be of one whole day or more
08:03:16 <monoidal> siwica: or, ghc, don't know what is the name in raring
08:03:32 <Cale> If you can bound the number of elements in your data structure, then lookups will obviously be constant time :)
08:04:07 <DanielDiaz> Cale: that's true. good point
08:04:17 <monoidal> siwica: once you have ghc, it's easy to install packages contained in the haskell platform
08:05:35 <DanielDiaz> Cale: in fact, since the table is going to be immutable, I can say that every query is bounded by a constant. I just want to reduce that constant. Probably log N is the best I can get.
08:05:56 <DanielDiaz> Cale: I was just wondering what's the best library in this case.
08:06:07 <Cale> Right, I'm just being nitpicky :)
08:06:12 <DanielDiaz> Cale: i.e. data structure to use that is already implemented.
08:06:40 <Cale> Array is generally going to be pretty good, if it's a viable option for you.
08:07:12 <Cale> If you can use an unboxed array for what you're doing especially, that's going to have pretty decent constant factors.
08:08:07 <Cale> Vector is similar in that regard, but it can in some cases do some optimisations on compositions of Vector operations to avoid constructing intermediate structures.
08:08:08 <DanielDiaz> my first thought was arrays, yeah. But I like to listen to a second opinion.
08:08:33 <Cale> (but if you're mostly doing lookups, it's going to be pretty much equivalent to arrays)
08:08:44 <siwica> monoidal: I think I will update to 13.10 and try again
08:09:15 <DanielDiaz> Cale: ok, thank you. I am going to try with unboxed arrays!
08:09:56 <monoidal> siwica: did you try apt-get install ghc? of course, upgrading is also an option
08:11:56 <Cale> DanielDiaz: The downsides of unboxed arrays is that they only work for specific types, and you can't define/compute the elements lazily. You can do fancy things with boxed arrays like computing the elements on demand and in terms of other elements of the array, which is useful for dynamic programming / memoisation.
08:12:59 <Cale> DanielDiaz: But if you don't need recursive definitions and your elements are of a primitive type so that you can use an unboxed array, you obviously can benefit a lot from the memory locality and avoidance of the extra indirection.
08:13:25 <DanielDiaz> Cale: aha, similar to the downside I have seen in unboxed vectors
08:14:47 <donri> do people generally prefer exceptions in IO over Maybe or Either?
08:14:50 <Cale> Right. Boxes serve two purposes: 1) making sure that every value is the same size in memory to support polymorphism, and 2) supporting laziness.
08:14:58 <Cale> donri: It depends
08:15:13 <donri> i feared as much ;)
08:15:22 <donri> what might it depend upon?
08:15:37 <siwica> monoidal: not yet, I'll let you now when I tried.
08:16:16 <Cale> Well, one thing would be whether you expect your user to try to deal with the exception at the point where they're using your function/action most of the time.
08:17:01 <donri> that's a good metric
08:17:27 <shergill> Cale: hmm could you give an example?
08:18:57 <Cale> Using IO (Maybe a) or IO (Either e a) will force the user to case on the the result in order to make use of the 'a' (in one way or another). If you use IO a (but sometimes throw an exception), then the user can use the result without handling the exception, and it will propagate outward (possibly into some catch, or possibly ending the program altogether)
08:19:54 <donri> in deed
08:20:27 <Cale> The extensible exception mechanism in IO is really quite nice. You can, through clever instances of Exception, construct new exception types which represent arbitrary sets of existing exception types, or arbitrary refinements (i.e. if you want to only catch certain values of a particular type of exception).
08:20:54 <donri> it "feels" like exceptions are less "strongly" typed here because you get runtime errors implicitly; with Maybe/Either you have to explicitly ask for it. hm.
08:21:36 <Cale> But people don't really use it so much, because the culture is very much in the direction of leaning on the type system to express things that can go wrong, yeah.
08:22:24 <Cale> So, despite IO having better exceptions than most imperative languages, we use them less :P
08:22:26 <donri> on the other hand, for some use cases, it can be really annoying to have to deal with weird error situations up front, when all you want in that case is to "crash" anyway
08:23:57 <danr> donri: fromJust? :)
08:24:38 <donri> if i use Either on an Exception, users can do "either fail ...". if i use exceptions, users can do "try"...
08:24:50 <donri> danr: exceptions in pure code are different/evil
08:25:30 <donri> i'm specifically considering API design for IO operations here
08:26:08 <donri> oh you're saying users can do fromJust <$> myIOThing
08:26:32 <donri> I prefer Just x <- myIOThing for that, you get source location in error :)
08:26:41 <siwica> monoidal: I will try doing it according to the first answer here: http://askubuntu.com/questions/286764/how-to-install-haskell-platform-for-ubuntu-13-04
08:26:41 <siwica> I wasnt recommended to update without reading the errata and doing a full backup which I dont have time for.
08:26:54 <donri> but it's still bad because you don't really get any hint at what the error was
08:28:24 <danr> donri: I agree
08:28:40 <monoidal> siwica: that answer seems good
08:29:37 <siwica> monoidal: althoug I have the following trouble now: http://pastebin.com/PK7s5ed3
08:29:38 <mauke> The paste PK7s5ed3 has been copied to http://lpaste.net/spam
08:29:44 <siwica> monoidal: any ideas?
08:31:06 <monoidal> siwica: this error is not related to ghc - it's something with kernel versions
08:32:18 <siwica> monoidal: ok, thanks! I will try to get some help at the #ubuntu channel
08:32:49 <fizruk> what would you recomend as an introductory algebra/category theory book (not too deep, but with some examples and exercises) ?
08:35:43 <Sculptor> friday! hi
08:35:57 <fizruk> B. Pierce "Basic Category Theory for Computer Scientists" ?
08:36:15 <danharaj> I have heard negative things about Pierce.
08:36:39 <danharaj> I don't remember what though. Perhaps it is difficult?
08:36:50 <`^_^v> the book "conceptual mathematics" is a pretty good introductory material (probably undergrad level)
08:36:53 <monoidal> danharaj: as far as I remember, it did not cover some important topics
08:37:02 <monoidal> danharaj: it's not difficult
08:37:05 <quicksilver> opinions differ widely on what a good approach to basic category theory is
08:37:22 <quicksilver> or, indeed, what parts of category theory should be considered "basic".
08:37:22 <`^_^v> it has a weird format though
08:37:39 <fizruk> monoidal, I've read it long ago and don't remember much, but perhaps it was too introductory
08:38:17 <monoidal> amazon reviews also say it's too basic
08:38:49 <fizruk> monoidal, it has a great literature review chapter though
08:39:01 <fizruk> I heard
08:39:10 <monoidal> fizruk: lecture notes by Eugenia Cheng http://cheng.staff.shef.ac.uk/catnotes/categorynotes-cheng.pdf are prety nice
08:39:40 <quicksilver> in a similar vein as monoidal's suggestion, there is this write-up of basically Peter Johnstone's course : http://www.cs.tufts.edu/~nr/cs257/archive/inna-zakharevich/categorytheory.pdf
08:39:55 <quicksilver> and thre is this course by Tom Leinster (sp?) http://www.maths.ed.ac.uk/~tl/msci/all.pdf
08:40:27 <quicksilver> Eugenia Cheng and Tom Leinster both taught (and possibly attended) Johnstone's course so I expect all three of those have similarities.
08:41:15 <danharaj> Eugenia Cheng is the catster right?
08:41:18 <quicksilver> right.
08:41:19 <monoidal> yes
08:41:31 <quicksilver> some people say Awodey's book is good but I never read it - http://www.amazon.co.uk/Category-Theory-Oxford-Logic-Guides/dp/0199237182
08:41:41 <quicksilver> many people say Mac Lane is not a good book but I found it useful.
08:41:44 * quicksilver shrug
08:41:46 <quicksilver> people = different.
08:42:12 <monoidal> I read Awodey, and it's good.
08:42:49 <fizruk> quicksilver, i don't have enough background for Mac Lane
08:43:41 <quicksilver> try the three free sets of lecture notes :)
08:43:49 <quicksilver> hopefully between them they get you to a better starting point.
08:44:50 <fizruk> monoidal, what's Awodey's book compared to those lecture notes?
08:45:21 <ocharles> there is also a bunch of category theory in the Oregon Summer School lectures, which are online videos
08:45:21 <ocharles> (by Awodey)
08:45:21 <monoidal> fizruk: it's similar in spirit
08:46:08 <fizruk> ok, I guess I'll start with those lecture notes
08:46:19 <fizruk> quicksilver, monoidal: thanks!
09:23:51 <mm_freak> fizruk: yeah
09:37:46 <Narvius> I just learned via stackoverflow that list comprehensions call "fail" for the monad when failing a pattern match.
09:38:09 <Narvius> ...I am not sure what the implications of that are, other than not returning [] for the List monad.
09:39:00 <simpson> > fail "What would you expect?" :: [a]
09:39:01 <lambdabot>   []
09:39:49 <Narvius> Technically, it feels like it implies that other things than lists can be used in there, though I'm not exactly sure how that would look and why.
09:40:28 <simpson> Oh!
09:40:36 <simpson> There's a thing called monad comprehensions.
09:40:45 <t0rus> whut
09:41:13 <t0rus> :t fail
09:41:14 <lambdabot> Monad m => String -> m a
09:41:32 <simpson> List comprehension operations can be generalized to options on Monad, MonadPlus, etc.
09:41:39 <simpson> And there's a language extension to do so.
09:42:07 <Narvius> So yeah, that's what I expected. :P
09:42:36 <DanielDiaz> Narvius: read more here http://db.inf.uni-tuebingen.de/files/giorgidze/haskell2011.pdf
09:42:43 <Narvius> Thanks.
09:47:02 <ski> @undo [a | Left a <- abs]  -- no `fail' here
09:47:03 <lambdabot> concatMap (\ b -> case b of { Left a -> [a]; _ -> []}) abs
09:49:04 <simpson> But there would be if it were a monad comprehension, I think.
09:49:19 <ski> yes
09:49:32 <ski> (or maybe `mzero')
09:50:05 <glguy> ski: The "fail" there is []
09:53:30 <ski> it's equivalent to a `fail' call yes, but the expansion described at <http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11> doesn't mention `fail'
09:55:41 <fizbin> Is there a rule somewhere that specifies that mzero is to >> as 0 is to multiplication? That is, something like foo >> mzero = mzero >> foo = mzero for all foo?
09:56:00 <elliott> foo >> mzero = mzero is false
09:56:03 <elliott> consider foo = print ()
09:57:18 <fizruk> quicksilver, will it be too bad if I skip topology examples? I'm not familiar with that :\
09:57:26 <fizbin> Ok, it's really the other direction I care about.
09:57:52 <monoidal> fizruk: I think you can skip, though topology it worth learning on a basic level.
09:58:23 <Taneb> elliott, I don't think IO is a MonadPlus
09:58:30 <fizruk> monoidal, can you advise something lightweight enough?
09:58:50 <fizbin> If nothing else, exploring topology may introduce you to the wonderful text "Counterexamples in topology", which illustrates a great way to ellucidate a mathematical theory.
10:00:00 <fizbin> So what about mzero >> foo? Is there a rule that specifies that must be mzero?
10:00:08 <fizruk> elliott, fizbin: http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:MonadPlus
10:00:22 <haasn> but foo >> mzero = mzero >>= foo = mzero
10:00:32 <haasn> IO is not a MonadPlus
10:00:54 <monoidal> fizruk: unfornately, I don't know any lightweight tutorial, I would look at lecture notes
10:01:38 <fizruk> monoidal, okay, thank you!
10:02:01 <monoidal> fizruk: topology lets you feel continuity in a much refined way
10:02:53 * hackagebot snaplet-postgresql-simple 0.4.1 - postgresql-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-postgresql-simple-0.4.1 (DougBeardsley)
10:10:11 <fizbin> fizruk: The "unapologetic mathematician" blog is pretty intense and something you need to step through slowly, but you can get a crash course in topology by starting at http://unapologetic.wordpress.com/category/topology/page/18/ and working your way through posts back to about page 14. At that point, you'll have covered the material in a good undergraduate topology course. You can keep working back and get all the connections betw
10:11:39 <fizbin> But as I said, it's intense and at least as dense as the math books I bought as a grad. student.
10:12:06 <fizruk> fizbin, thanks for the link!
10:22:49 <moto9> aww, i'm forgetting it all... what's the easiest way to extract a value from a Just or replace it with some other value if Nothing
10:23:24 <sipa> :t fromMaybe
10:23:25 <lambdabot> a -> Maybe a -> a
10:23:39 <moto9> hui
10:23:41 <moto9> thanks
10:24:04 <derdon> :info fromMaybe
10:25:31 <jle`> this guy is pretty unapologetic
10:26:56 <krakrjak> > fromMaybe 1 (Just 0)
10:26:58 <lambdabot>   0
10:27:05 <krakrjak> > fromMaybe 1 Nothing
10:27:06 <lambdabot>   1
10:27:39 <mangaba_leitosa> fizruk: the notes look awful... Nothing but definitions containing formulae :-)
10:28:32 <danharaj> edwardk: I just used lens to turn a really ugly monadic loop into a very pleasing two liner. Thank you ;)
10:29:26 <ParahSailin> i havent yet seen a use case for lens
10:30:04 <fizruk> mangaba_leitosa, they have examples on each definition so far. do you suggest an alternative reading?
10:31:14 <mangaba_leitosa> fizruk: no, I'm in search of something more lightweight and more exciting :-)
10:32:24 <fizruk> mangaba_leitosa, Pierce's book is more lightweight and arguably more exciting, but you've seen what others think
10:34:25 <mangaba_leitosa> fizruk: I heard that Pierce is very dense
10:34:37 <mangaba_leitosa> fizruk: but maybe I'll try it :-)
10:34:53 <fizruk> mangaba_leitosa, perhaps there's also something more exciting on http://youtube.com/TheCatsters, haven't checked out that yet
10:36:12 <mangaba_leitosa> fizruk: thanks for the link
10:36:18 <danharaj> ParahSailin: The biggest app is that it makes the state monad a hella lot easier to use with a complicated state.
10:41:10 <funfunctor> hi, I am trying to define a new lexical type using a regexpression.. token IPIdent (digit{1,3}\.){3,3} digit{1,3} ;
10:41:39 <funfunctor> http://bnfc.digitalgrammars.com/LBNF-report.pdf I don't fully get the syntax outlined here... Can anyone help?
10:47:03 <FreeFull> It'd be interesting to have a Haskell DSL that compiles to 6502
10:48:37 * Hodapp looks at FreeFull
10:49:22 <scriptor> thanks for volunteering, FreeFull
10:49:52 <Hodapp> FreeFull: http://hackage.haskell.org/package/atom/ ?
10:50:02 <Hodapp> FreeFull: that has MSP430 backends. MSP430 isn't that far off from 6502...
10:53:41 <simpson> At some point, I should learn Atom.
10:55:03 <Hodapp> simpson: I was going to work with it a bit on a project, but I had to stick with C in the meantime.
10:56:18 <ski> @wiki MonadPlus reform proposal
10:56:18 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
10:56:23 <ski> @wiki MonadPlus
10:56:23 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus
10:56:30 <ski> FreeFull : seen those two ^ ?
10:56:32 <ski> er
10:56:35 <ski> fizruk ^
10:58:50 <fizruk> ski, fizbin?
10:59:44 * fizbin gets a "not fizbin" badge for fizruk and makes a "not fizruk" badge for himself...
11:00:59 <arkeet> I don't like MonadOr. =(
11:05:33 <fizruk> edwardk, what time of day is most suitable for haunting you?
11:05:38 <funfunctor> atom wont do it by itself..
11:06:13 <funfunctor> FreeFull: you want to look at http://smaccmpilot.org/languages/ivory-introduction.html
11:07:19 <FreeFull> That compiles to C though
11:07:30 <FreeFull> The 6502 is more suited for assembly
11:09:22 <funfunctor> so..
11:09:35 <funfunctor> you would still need to do backend work any way..
11:13:33 <funfunctor> FreeFull: You would want to write Ivory.HW.6502 first, compile to C and get that working. Then you can swap the C backend for another one that writes 6502 asm.
11:13:54 <funfunctor> You could go the LLVM IR route to be more general.
11:16:12 <mm_freak> what's the package to use for length-indexed lists nowadays?
11:16:49 <mm_freak> HList seems unmaintained
11:18:06 <elliott> mm_freak: linear has V
11:18:11 <elliott> uses Vector under the hood
11:19:22 <lpaste> jml pasted “todo.txt format parser” at http://lpaste.net/94806
11:19:37 <jml> ooh, it shows warnings
11:19:54 <jml> was just wondering if anyone would like to offer feedback on how that could be done better
11:22:48 <mm_freak> elliott: not quite the interface i was looking for
11:23:07 <mm_freak> fixed-vector seems more promising
11:24:04 <fizruk> jml: `GenParser Char st a` means "value of type `a` parsed by a parser with tokens of type `Char` and state of type `st`" (something like that)
11:24:49 <fizruk> jml, there's also a type synonym type CharParser st = GenParser Char st
11:25:36 <jml> fizruk: thanks.
11:26:45 <ski> fizbin,fizruk : sorry, i haven't noticed you were different people
11:27:04 <fizruk> ski, that's ok :p
11:27:47 * ski . o O ( "Fizbin of Misfortune" )
11:27:56 <fizasterisk> I am become fiz* !
11:29:54 <mm_freak> when searching through http://hackage.haskell.org/packages/ it's very annoying that some packages appear 5-10 times
11:30:05 <mm_freak> there should be a limit on how many categories a package can be in
11:31:12 <mm_freak> interestingly the more categories a package is listed in, the less useful it seems to be
11:31:17 <fizruk> mm_freak, 1?
11:31:43 <mm_freak> fizruk: perhaps 2
11:33:14 <chee1> mm_freak: or the more generic the package is: http://hackage.haskell.org/package/semigroups
11:36:39 <mm_freak> chee1: IMO that one belongs into Algebra and Data
11:37:12 <mm_freak> i don't even get what we need a separate "Data Structures" category for
11:37:28 <mm_freak> and "Math" is such a broad category that you could put almost all packages into it
11:37:37 <fizruk> jml, have you considered using regexes instead of parsec? seems those would fease better for your task
11:37:41 <mm_freak> perhaps the trouble is that we simply have too many categories
11:40:13 <jml> fizruk: well, I was more interested in mucking around with parsec & haskell than maximizing effectiveness
11:41:03 <jml> fizruk: but yes, regular expressions would be a better fit. The format is at todotxt.com, and the canonical implementation is a bash script
11:41:46 <fizruk> jml, perhaps you should take another example to work with?
11:42:33 <fizruk> jml, todotxt can be done with parsec, but that looks like a great overkill
11:45:02 <jml> fizruk: fair enough.
11:51:05 <notdan> jml: you can replace GenParser Char st with just 'Parser'
11:52:17 <jml> notdan: ta
11:52:46 <notdan> I think in 'word' you can use 'choice combinator
11:53:03 * hackagebot fay 0.18.0.4 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.18.0.4 (AdamBergmark)
11:53:51 <notdan> I am not sure why do you need Maybe in 'word' but I haven't looked close enough tho
11:54:10 <fizruk> notdan, Nothing for plain word
11:54:45 <notdan> hm but.. you don't actually make use of the word?
11:54:51 <jml> notdan: that's right.
11:55:46 <fizruk> notdan, jml: I'd have a parser projsAndCtxs :: Parser ([Projects], [Contexts]) or something which parsed the rest on the line
11:56:24 <jml> fizruk: oh yeah, that'd make sense
11:56:53 <fizruk> jml, perhaps it would be easier to write Parser [Either Project Context]
11:57:28 <notdan> I guess you can do that with word too
11:57:37 <notdan> :t (lefts &&& rights) . catMaybes
11:57:38 <lambdabot> [Maybe (Either a b)] -> ([a], [b])
11:57:57 <notdan> oh yeah, Parser [Either Project Context] would make more sense too
11:58:58 <jml> :t (&&&)
11:58:59 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
11:59:27 <notdan> jml: as for associating metadata, can't you just make your 'line' function return (String, TodoItem)?
11:59:29 <fizruk> it's also probably better to make project/context/date/etc lexems rather that parse them with Char lexems
11:59:49 <notdan> (&&&) is basically (\x -> (f x, g x)) in this case
12:00:45 <notdan> fizruk: well, isn't the parsing is actually lexing in this case?
12:01:49 <notdan> jml: as for mapM_, it's a function very much like map, but it applies a monadic function over a list instead of a regular one
12:01:52 <notdan> :t mapM
12:01:53 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
12:01:54 <notdan> :t mapM_
12:01:55 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
12:02:14 <fizruk> notdan, well, yeah... that's why I told about regexes :)
12:02:15 <notdan> mapM_ is just a version of mapM that ignores the result
12:03:03 * hackagebot ViennaRNA-bindings 0.0.3.0 - ViennaRNA v2 bindings  http://hackage.haskell.org/package/ViennaRNA-bindings-0.0.3.0 (ChristianHoener)
12:03:26 <notdan> fizruk: idk, you certainly can do this with regex, but I actually would prefer to read code that uses Parsec to reading code that uses regular expressions ;)
12:04:05 <notdan> (I am not against regular expressions, I just don't feel comfortable when there are too much of them around)
12:04:13 <jml> dinner just arrived.
12:04:25 <notdan> \o/
12:04:26 <jml> thanks for the feedback fizruk & notdan!
12:04:51 <notdan> Gonna go play video games instead of working bbl
12:05:37 * fizruk is going to have some tea then...
12:06:29 <Eduard_Munteanu> Let m = lcm a b, what do you call m / a and m / b? Is there a function that computes those things instead?
12:08:03 <lpaste> gniourf pasted “Problem: ghc vs ghci” at http://lpaste.net/94808
12:08:31 <Eduard_Munteanu> gniourf: monomorphism restriction, likely
12:08:49 <geekosaur> gniourf, ghci uses extended defaulting. [] can't be defaulted normally but ghci will infer () as the list's type
12:09:30 <gniourf> Eduard_Munteanu, geekosaur thanks for your quick answers! Is there a quick fix for this?
12:09:42 <gniourf> (I'm new to haskell)
12:09:42 <Eduard_Munteanu> gniourf: add a type signature for l3
12:09:43 <geekosaur> (if there were a number involved somewhere with the list's type, bogh ghc and ghci would infer Integer or Double as appropriate
12:09:47 <monochrom> lcm a b / a = b / gcd a b
12:10:10 <geekosaur> add a type signature, or use {-# LANGUAGE ExtendedDefaultRules #-}
12:10:28 <Eduard_Munteanu> You need {-# LANGUAGE NoMonomorphismRestriction #-} too.
12:10:38 <gniourf> geekosaur, yeah, that works!
12:10:40 <Eduard_Munteanu> Oh wait, no.
12:10:56 <Eduard_Munteanu> Yeah, if it defaults, it compiles since it's not monomorphic anymore.
12:11:08 <gniourf> now I'll probably spend 1 week trying to figure it all out :) thanks so much guys !
12:11:40 <Eduard_Munteanu> @where dmr
12:11:40 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
12:12:09 * monochrom is alone in disliking "let's tell ghc to emulate ghci"
12:12:25 <Eduard_Munteanu> gniourf: this is why it won't infer l3 :: NestedList a ^^
12:12:35 <gniourf> thanks for the link ;)
12:13:24 <Eduard_Munteanu> Arguably that would be ambiguous wrt Show, though.
12:13:44 <udevd> > Just 2 >>= (\x -> (Just 2*x))
12:13:46 <lambdabot>   No instance for (GHC.Show.Show b0)
12:13:46 <lambdabot>    arising from a use of `M1087165230.sh...
12:14:04 <udevd> @type (>>=)
12:14:05 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:14:12 <geekosaur> afaik the monomorphism restriction is not involved here; just the ability to assign some type to an empty list with no other type information (except Show a => a)
12:14:16 <udevd> hmm, should work...
12:14:21 <geekosaur> extended defaulting lets () be inferred
12:14:55 <udevd> aaah, the ()s are wrong
12:14:59 <geekosaur> normal defaulting doesn't allow any type to be inferred. turning off the DMR also doesn't help with the fact that it needs *some* type for the list, and has insufficient information to assign one
12:15:04 <udevd> > Just 2 >>= (\x -> Just (2*x))
12:15:06 <lambdabot>   Just 4
12:15:18 <Eduard_Munteanu> geekosaur: yeah, because you call show on it via print
12:15:20 <geekosaur> extended defaulting is not the ideal fix there indeed but it'll do
12:16:14 <S11001001> > show . read $ "()"
12:16:15 <lambdabot>   "()"
12:16:20 <udevd> > map (>>= (\x -> Just(x-100))) $ (map Just [1..10])
12:16:21 <lambdabot>   [Just (-99),Just (-98),Just (-97),Just (-96),Just (-95),Just (-94),Just (-9...
12:16:26 <geekosaur> correct fix is to give [] a type e.g. `l3 = List ([] :: [Int])` or just giving l3 a type signature
12:16:30 <udevd> > map (>>= (\x -> Just(x-100))) $ (map Just [1..10]) ++ replicate 10 Nothing
12:16:31 <lambdabot>   [Just (-99),Just (-98),Just (-97),Just (-96),Just (-95),Just (-94),Just (-9...
12:16:36 <udevd> > map (>>= (\x -> Just(x-100))) $ (map Just [1..3]) ++ replicate 10 Nothing
12:16:37 <lambdabot>   [Just (-99),Just (-98),Just (-97),Nothing,Nothing,Nothing,Nothing,Nothing,N...
12:16:47 <absence> when i have a module loaded in ghci, then edit the source file and type :r, is it possible to make ghci not eject everything if there's a type error or something? it's very annoying to loose the ability to experiment with :t etc when i need it most
12:17:19 <nomeata> > fix show
12:17:20 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
12:17:22 <fizruk> absence, have 2 interpreters?
12:18:03 <Eduard_Munteanu> monochrom: hm, that's not much of a name. Actually I want those 'lcm' factors for fractionals: lcmFrac tol a b = (cm / a * tol, cm / b * tol) where cm = lcm (a / tol) (b / tol) -- with the type conversions omitted for clarity
12:18:31 <udevd> nomeata: what is fix?
12:18:39 <absence> fizruk: i've been doing that, and it's better than nothing of course, but it's unneccesary mental strain to remember which interpreter has which version of the code loaded
12:18:44 <nomeata> @type fix
12:18:48 <lambdabot> (a -> a) -> a
12:18:53 <fizruk> @src fix
12:18:53 <lambdabot> fix f = let x = f x in x
12:19:02 <Eduard_Munteanu> Where 'tol' is a tolerance, 0 < tol <= 1
12:19:06 <udevd> what.
12:19:22 <monochrom> udevd, read my http://www.vex.net/~trebla/haskell/fix.xhtml
12:19:24 <udevd> what does it even mean
12:19:27 <absence> udevd: it recursively applies a function to itself. like f . f . f . f . f .....
12:19:35 <monoidal> absence: :set -fdefer-type-errors?
12:19:48 <udevd> absence: will it even stop?
12:19:57 <absence> udevd: no
12:20:04 <Eduard_Munteanu> udevd: fix $ \f x -> ... f ...   ~~~   f x = ... call f again ...
12:20:26 <nomeata> udevd: it allows you, for example, to write recursion without giving the thing a name
12:20:27 <fizruk> > take 10 $ fix (1:)
12:20:28 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
12:20:28 <udevd> so it is useful just for infinite IO loops?
12:20:33 <udevd> ah.
12:20:34 <udevd> ok
12:20:39 <monoidal> udevd: no, the same way replicate 1 = 1 : 1 : ... endlessly
12:20:44 <udevd> okay, i see
12:20:49 <monoidal> udevd: you can write any recursive definition using fix
12:20:50 <absence> udevd: laziness makes it not hang forever :)
12:20:50 <Eduard_Munteanu> udevd: fix lets you write *any* recursive function without explicit recursion.
12:20:54 <nomeata> udevd: no, if you pass it a function you can easily terminate
12:21:05 <udevd> but how does even > fix show works?
12:21:12 <absence> > fix error
12:21:13 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
12:21:18 <nomeata> absence: nice one
12:21:29 <monoidal> udevd: this is due to Show instance of Strings
12:21:44 <nomeata> I hear a ever fainting call of the run time that something went wrong... nightmarish
12:21:49 <monoidal> > fix ("hello " ++) -- udevd
12:21:50 <Eduard_Munteanu> udevd: it's productive... even if it doesn't terminate, it still gives part of the result as it goes
12:21:50 <lambdabot>   "hello hello hello hello hello hello hello hello hello hello hello hello he...
12:22:23 <fizruk> :t fix fix
12:22:24 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = a0 -> a0
12:22:25 <lambdabot>     Expected type: (a0 -> a0) -> a0 -> a0
12:22:25 <Eduard_Munteanu> > let hi = "hi " ++ hi in hi
12:22:26 <lambdabot>       Actual type: (a0 -> a0) -> a0
12:22:28 <lambdabot>   "hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi...
12:22:40 <Eduard_Munteanu> @src fix
12:22:41 <lambdabot> fix f = let x = f x in x
12:22:49 <Eduard_Munteanu> Ring a bell? :)
12:23:04 <absence> monoidal: thanks, that flag did the trick!
12:23:08 <jmcarthur_mobile> udevd: it's useful for any recursion, not just infinite recursion
12:23:10 <monochrom> it is why I wrote http://www.vex.net/~trebla/haskell/fix.xhtml
12:23:21 <monoidal> absence: GHC loads then your module, but type errors become warnings + runtime errors
12:23:29 <nomeata> > let nth = fix (\r l n -> if n == 0 then head n else r (tail n) (n - 1)) in nth "hallo" 3
12:23:30 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
12:23:30 <lambdabot>    arising from a use of `nt...
12:23:30 <monochrom> most recursions are "infinite"
12:23:41 <absence> monoidal: just what i want :)
12:23:46 <monoidal> > fix (\f n -> if n == 0 then 1 else n * f (n-1)) 5 -- udevd
12:23:48 <lambdabot>   120
12:23:48 <nomeata> > let nth = fix (\r l n -> if n == 0 then head n else r (tail l) (n - 1)) in nth "hallo" 3
12:23:50 <lambdabot>   No instance for (GHC.Show.Show a0)
12:23:50 <lambdabot>    arising from a use of `M755843907.sho...
12:23:52 <Eduard_Munteanu> Most recursions aren't typeable. :P
12:24:10 <nomeata> monoidal has the better example
12:24:16 <monochrom> ok, most typeable recursions are "infinite"
12:25:08 <jmcarthur_mobile> monochrom: yeah I only meant that it doesn't necessarily imply nontermination
12:25:28 <jmcarthur_mobile> Or even infinitely large output
12:26:03 <udevd> monoidal: thanks, i'll read :3
12:26:04 <monoidal> udevd: note that example (with 5!=120) uses no explicit recusion - it is encapsulated in fix.
12:26:09 <fizruk> > fix (const 23)
12:26:10 <lambdabot>   23
12:26:28 <identity> anyone here using ghcmod-vim? It seems it's telling me there's a parse error at "|" for multiwayif, while it compiles fine
12:26:35 <nomeata> > let (!) = fix (\r l n -> if n == 0 then head l else r (tail l) (n - 1)) in "hallo" ! 3 -- not it works; (!) implemented using fix
12:26:36 <lambdabot>   'l'
12:26:56 <udevd> >fix (const. flip 23)
12:26:59 <udevd> >fix (const. flip $ 23)
12:27:04 <udevd> welp.
12:27:08 <udevd> > fix (const. flip $ 23)
12:27:09 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable c0)
12:27:10 <lambdabot>    arising from a use ...
12:27:23 <udevd> > fix (flip.const$ 23)
12:27:24 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable c0)
12:27:24 <lambdabot>    arising from a use ...
12:27:25 <monoidal> you can't flip 23, unless numbers are functions
12:27:38 <fizruk> udevd, you can't flip (const 23) either
12:27:52 <DanielDiaz> sure I can! 32!
12:27:54 <udevd> > fix (flip.(const 1)$ 23)
12:27:55 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable c0)
12:27:55 <lambdabot>    arising from a use ...
12:28:04 <udevd> ;_;
12:28:04 <fizruk> DanielDiaz, :P
12:28:26 <monochrom> the list "0:0:0:..." is infinite. but so is the function (\n -> 0), which has an infinite domain.
12:28:36 <monoidal> udevd: try this. pick a function defined recursively, and rewrite it using fix.
12:29:06 * Eduard_Munteanu pretty much gave that away above
12:30:09 <monochrom> here is a finite list: 0:⊥. here is a corresponding finite-domain function: \x -> case x of 0 -> 0
12:31:55 <udevd> > let  fact n = case n of {(0)->1 ; (1)-> 1; (_) -> n*fact(n-1)} in fact 4
12:31:56 <lambdabot>   24
12:32:42 <udevd> oh, this is bad example.
12:32:48 <Matthias|PC> Can someone explain me the difference to me between data, type and newtype?
12:33:13 <Matthias|PC> since, this doesn't work: data Parser a = String -> [(a, String)], but this does: type Parser a = String -> [(a, String)]
12:34:00 <Eduard_Munteanu> Matthias|PC: 'type' just defines a synonym, i.e. what's before the '=' is exactly what follows after '='.
12:34:22 <Matthias|PC> and newtype is type with a constructor?
12:34:24 <udevd> fix \(x -> sin x)
12:34:31 <udevd> > fix (\x -> sin x)
12:34:38 <lambdabot>   mueval-core: Time limit exceeded
12:35:14 <Eduard_Munteanu> Matthias|PC: in some ways but not exactly. 'data' and 'newtype' actually define new types.
12:35:33 <Matthias|PC> ah ok :)
12:35:36 <Matthias|PC> I think I'm starting to get it
12:35:38 <Matthias|PC> thank you very much!
12:35:49 <Matthias|PC> now I know type vs data I can look at the rest :p
12:35:53 <Eduard_Munteanu> Matthias|PC: it might help to ask a specific question
12:36:08 <Matthias|PC> I'll fiddle around with it a bit first, ty :)
12:36:31 <monochrom> udevd, fix sin = ⊥ because ⊥ satisfies the equation ⊥ = sin ⊥, and fix prefers that solution
12:37:48 <johnw> monochrom: isn't fix the *least defined* fixed point, and so ⊥ is the most appropriate answer?
12:38:04 <monochrom> whereas fix (0:) = 0:0:0:... because 0:0:0:... = 0:(0:0:0:...), and also note that ⊥ ≠ 0:⊥, so fix can't give you ⊥ as a solution
12:38:15 <monochrom> yes, that is why fix prefers it
12:38:21 <Eduard_Munteanu> Matthias|PC: anyway, if you understand 'data', newtypes are similar with two exceptions: you only have one constructor which can wrap exactly one value, and they're equivalent to 'type' definitions at *runtime* (namely the constructor isn't present in the compiled code and no unwrapping occurs)
12:38:39 <Matthias|PC> ahh, I see
12:38:43 <Matthias|PC> Eduard_Munteanu: thank you!
12:38:44 <monochrom> we humans, of course, prefer 0 = sin 0, but we have advanced knowledge
12:38:49 <johnw> ok, the use of "prefers" made it seem like it was just choosing one option among many, when in fact that is _the_ answer for fix sin, as I understand
12:38:55 <razieliyo> hi
12:39:34 <razieliyo> is there any way to nest guards? I have this code http://lpaste.net/94809 and I'd like to avoid the repeating of the el < val and el >= val
12:39:55 <Eduard_Munteanu> Matthias|PC: (there's a third one, but it's mostly a corollary: 'undefined' and 'Foo undefined' are the same thing for newtypes with a Foo constructor)
12:39:56 <johnw> you can use a ,
12:40:08 <Matthias|PC> ah yes, seen that one
12:40:08 <johnw> oh, I see what you mean
12:40:17 <udevd> > fix (\v n -> if n==0 then 1 else n * v(n-1)) 4
12:40:18 <lambdabot>   24
12:40:25 <udevd> hm
12:40:41 <monoidal> udevd: this is equivalent to: let fact = (\v n -> if n==0 then 1 else n * v(n-1)) fact in fact 4
12:41:00 <udevd> i see.
12:41:01 <monoidal> udevd: which is: let fact = \n -> if n==0 then 1 else n *  fact(n-1) in fact 4
12:41:53 <monochrom> well, you should, instead, critique on anthropomorphizing fix
12:43:14 <udevd> but how does the computation stop in this case?
12:43:38 <udevd> i mean, i can see it in > fix f = let f x in x
12:43:52 <udevd> but not in "fix f = f .f .f.f...."
12:44:22 <monochrom> fix doesn't have a choice, it's a dead piece of code. the author of fix has a choice. although, then, you will argue that parametric polymorphism leaves him/her no choice.
12:45:51 <Eduard_Munteanu> udevd: (f . f . f ...) x  wouldn't terminate if you add fs to the right.
12:46:21 <Eduard_Munteanu> udevd: because you'd need to construct that infinite function even before you can apply x to it.
12:46:45 <monochrom> udevd: allow me to use a simpler function to save typing. fmono = \f n -> if n==0 then 0 else f (n-1)
12:46:51 <Eduard_Munteanu> udevd: however if you add fs to the left, you can apply x as soon as you have an f.
12:47:07 <djahandarie> Huh, I didn't know hackage packages could have dependencies on themselves.
12:47:24 <mauke> this is known as "tying the knot"
12:47:37 <djahandarie> Not sure what knot you need to tie in that context :p
12:47:52 <udevd> > let fmono = \f n -> if n==0 then 0 else f (n-1) in fix fmono 100
12:47:53 <lambdabot>   0
12:47:57 <Eduard_Munteanu> A knot in the ethernet cord. :P
12:47:58 <udevd> mhm
12:48:12 <monochrom> now work this out: fmono (fmono unknown) 1 = if 1==0 then 0 else fmono unknown (1-1)
12:48:21 <monochrom> = fmono unknown (1-1)
12:48:34 <djahandarie> ( http://hackage.haskell.org/package/fay-0.18.0.4 is the package I'm looking at which depends on itself.)
12:48:39 <monochrom> = if (1-1)==0 then 0 else unknown (1-1-1)
12:48:40 <djahandarie> I assume this causes no problems, just kind of odd.
12:48:49 <djahandarie> I wonder what happens if you depend on an older version of yourself.
12:48:52 <monochrom> = 0  and we don't even have to know unknown
12:49:05 <udevd> welp.
12:49:26 <djahandarie> Oops, sorry for interrupting your proof monochrom.
12:49:29 <udevd> > let fmono = \f n -> if n==0 then 0 else f (n-1) in fix fmono (fmono fmono 100))
12:49:30 <lambdabot>   <hint>:1:79: parse error on input `)'
12:49:32 <udevd> > let fmono = \f n -> if n==0 then 0 else f (n-1) in fix fmono (fmono fmono 100)
12:49:33 <lambdabot>   Could not deduce (GHC.Num.Num a0) arising from a use of `fmono'
12:49:34 <lambdabot>  from the c...
12:49:42 <udevd> > let fmono = \f n -> if n==0 then 0 else f (n-1) in fix fmono (fmono fmono 100) 100
12:49:43 <lambdabot>   Could not deduce (GHC.Num.Num a0) arising from a use of `fmono'
12:49:43 <lambdabot>  from the c...
12:49:45 <notdan> djahandarie: it's an executable that depends on a library
12:49:46 <Eduard_Munteanu> djahandarie: you wouldn't be able to do it by the hackage protection conjecture :P
12:49:57 <udevd> > let fmono = \f n -> if n==0 then 0 else f (n-1) in fix fmono unknown
12:50:00 <lambdabot>   Not in scope: `unknown'
12:50:08 <monochrom> udevd, use "undefined"
12:50:11 <udevd> > let fmono = \f n -> if n==0 then 0 else f (n-1) in fix fmono undefined
12:50:11 <notdan> djahandarie: so if you were to include an older version then that executable would be build against the old version of the library
12:50:12 <lambdabot>   *Exception: Prelude.undefined
12:50:21 <notdan> djahandarie: note that the library does not depend on itself
12:50:24 <udevd> it tried to compare 0 and undefined.
12:50:26 <djahandarie> notdan, ah. That makes more sense.
12:50:33 <djahandarie> I clearly should have opened the cabal file.
12:50:37 <monochrom> you're doing it wrong. do you agree?
12:50:40 <udevd> yup
12:50:50 <udevd> and i don't really know how to do it properly
12:51:02 <monochrom> either try "fix fmono 1", or "fmono (fmono undefined) 1"
12:51:25 <monochrom> here, actually:
12:51:27 <notdan> How is 'fix' related to Kleene's fixed point btw?
12:51:41 <monochrom> @let fmono f n = if n==0 then 0 else f (n-1)
12:51:42 <lambdabot>  Defined.
12:51:50 <udevd> > let fmono = \f n -> if n==0 then 0 else f (n-1) in fix fmono (fmono undefined) 1
12:51:51 <lambdabot>   Could not deduce (GHC.Num.Num a0) arising from a use of `fmono'
12:51:51 <lambdabot>  from the c...
12:51:54 <monochrom> now you can directly use it
12:52:05 <monochrom> > fmono (fmono (fmono undefined)) 2
12:52:06 <udevd> > let fmono = \f n -> if n==0 then 0 else f (n-1) in fmono (fmono undefined) 1
12:52:07 <lambdabot>   0
12:52:09 <lambdabot>   0
12:53:34 <monochrom> fmono undefined has domain {0}. fmono (fmono undefined) has domain {0,1}. fmono (fmono (fmono undefined)) has domain {0,1,2}. it keeps growing.
12:53:58 <monochrom> so fmono (fmono (fmono (...))) has domain {0,1,2,...}
12:54:30 <monochrom> notdan, which one is Kleene's fixed point?
12:55:29 <notdan> monochrom: the one in his fixed point theorem
12:55:36 <notdan> for complete lattices
12:56:19 <monochrom> is it the one that says "consider the sequence ⊥, fmono ⊥, fmono (fmono ⊥), ..."?
12:57:12 <notdan> yep :P
12:57:22 <chrisdotcode> how can I uninstall a package with cabal-dev?
12:57:23 <monochrom> then fix equals Kleene's fixed point
12:57:24 <notdan> I type my Q before reading the scrollog
12:58:07 * hackagebot pipes-csv 1.2.0 - Fast, streaming csv parser  http://hackage.haskell.org/package/pipes-csv-1.2.0 (WilliamCasarin)
12:59:10 <monochrom> because fix uses the language's recursion construct, and we require functional languages' recursion construct to use Kleene's fixed point for denotational semantics
13:00:19 <monochrom> hell, then we translate imperative languages to functional languages when giving denotational semantics to imperative languages, and so imperative languages are also infected
13:03:16 <madariaga> I'm following a series of blog posts. It's about the implementation of a very much OO task, and I thought it would be perfect to learn about Haskell's type system.
13:03:51 <madariaga> The problem is, I'm already quite confused right after starting; I guess I'm thinking too much in terms of OOP
13:04:47 <Javran> hello, is there someone familiar with dbus lib?
13:06:28 <Javran> I'm playing with dbus, now I can get a response like `Variant (Variant 2)` from methodReturnBody but I don't know how to extract that `2` from the value.
13:07:35 <notdan> Javran: fromVariant?
13:11:07 <augur> udevd: i wouldnt say its f.f.f.f.... on to infinite
13:11:14 <augur> because that would imply its type is still a -> a
13:11:33 <augur> f.f.f.f.. to infinity would indeed be fix (f.)
13:11:36 <augur> not fix f
13:11:49 <Javran> notdan: but that's a Variant embeded in another Variant, I think I have to write something like `let (Just x) = fromVariant response; let (Just y) = fromVariant x`, but it doesn't work
13:13:42 <monochrom> @type fix (fmono .)
13:13:43 <lambdabot> (Eq a2, Num a2, Num a1) => a -> a2 -> a1
13:14:18 <monochrom> that may be unreliable, lambdabot has advanced instances
13:15:15 <monochrom> ok, that is the type in a vanilla environment too
13:15:15 <Javran> notdan: I can't do `let (Just (x :: Variant Int)) = fromVariant k` because Variant is hidden from that module...
13:16:07 <fizruk> Javran, (fromVariant response >>= fromVariant) :: Maybe Int ?
13:16:19 <monochrom> ha, fix (fmono .) x n = fix fmono n
13:23:58 <lpaste> Javran pasted “No title” at http://lpaste.net/94810
13:24:55 <Javran> fizruk: please take a look at the errors, I don't know what's going wrong here
13:26:04 <fizruk> Javran, I guess you need Int32/Int64 instead of just Int
13:26:51 <skypers> @src Path
13:26:51 <lambdabot> Source not found. You untyped fool!
13:26:58 <skypers> hm
13:27:02 <skypers> :t Path
13:27:03 <lambdabot> Not in scope: data constructor `Path'
13:27:32 <fizruk> Javran, also pasting some actual code might help diagnosis
13:27:38 <skypers> :t FilePath
13:27:39 <lambdabot> Not in scope: data constructor `FilePath'
13:27:47 <skypers> @src FilePath
13:27:47 <lambdabot> type FilePath = String
13:27:58 <udevd> > Just Nothing
13:28:00 <lambdabot>   Just Nothing
13:30:14 <Javran> fizruk: thanks a lot, I've figured it out.
13:31:04 <Javran> the return type is "u", I imported Data.Word, and use `:: Maybe Word32`, and the outcome is what I expected.
13:39:01 <augur> icfp videos? :D
13:39:36 <johnw> augur: good question!
13:41:32 <johnw> "ICFP 2013 has a Video Chair, and one event per day can be filmed."
13:41:59 <augur> o.o;
13:42:06 <augur> previous ICFPs seemed to have filmed everything
13:53:26 <skypers> hey
13:53:36 <skypers> I’d like to test a cabal-dev sandbox with ghci
13:53:42 <skypers> but it fails to starts with
13:53:53 <skypers> cabal-dev ghci
13:53:53 <skypers> cabal-dev: user error (cabal: Can't parse --info output of GHC
13:53:53 <skypers> )
13:53:58 <skypers> any idea?
13:54:56 <dcoutts_> skypers: oh, that's not so good, what does ghc --info report?  (hpaste)
13:55:12 <jhormuz> Why wouldn't ghci complain if I declare something and instance of a class without defining the "minimal complete definition"?  In fact I didn't declare any class function at all (I just wrote "instance X Y where"....  in my case X=Foldable, and Y=a tree class I wrote).
13:55:31 <skypers> dcoutts_: a lot of things, wait
13:55:35 <elliott> jhormuz: because machine-readable machine complete definition specifications are only in GHC HEAD
13:55:58 <skypers> http://lpaste.net/94811
13:56:00 <skypers> that, dcoutts_
13:56:03 <dcoutts_> jhormuz: minimal complete definition is not checked
13:56:09 <jhormuz> really?
13:56:18 <jhormuz> Isn't that something easy to check?
13:56:52 <dcoutts_> jhormuz: no, it's theoretically impossible.
13:56:54 <jhormuz> It acted really strange also, the program froze when I ran it.
13:57:22 <dcoutts_> jhormuz: yes, it's gone into an infinite loop because the defaults are mutually recursive.
13:57:40 <jhormuz> dcoutts- Oh, that makes sense!
13:58:19 <jhormuz> I think I get it.
13:58:34 <jhormuz> thanks gang!
13:58:47 <dcoutts_> skypers: can you reproduce it without cabal-dev?
13:58:52 <dcoutts_> skypers: or get a log with -v3
14:00:12 <skypers> dcoutts_: http://lpaste.net/94812
14:00:46 <dcoutts_> ahh --with-ghc=fake-ghc-cabal-dev
14:01:02 <dcoutts_> skypers: and presumably fake-ghc-cabal-dev --info doesn't do anything sensible.
14:01:26 <skypers> == GHC Arguments: Start ==
14:01:26 <skypers> --info
14:01:27 <skypers> == GHC Arguments: End ==
14:01:29 <skypers> only that
14:01:37 <dcoutts_> right, so that's not valid
14:01:52 <skypers> why?
14:02:04 <dcoutts_> skypers: it's not the right format, see ghc --info
14:02:06 <dcoutts_> skypers: basically cabal-dev doesn't work with the latest cabal
14:02:17 <skypers> oh
14:02:18 <skypers> I see
14:02:25 <skypers> so how should I test my application? :(
14:02:41 <dcoutts_> it's clearly not been updated (or if it has, you're not using the latest)
14:02:48 <skypers> using only cabal?
14:02:56 <skypers> I like sandboxes
14:02:58 <dcoutts_> skypers: cabal-dev is obsoleted by cabal sandboxes
14:03:12 <skypers> cabal now supports sandboxes?!
14:03:20 <dcoutts_> didn't you get the memo?
14:03:27 <skypers> no!
14:03:29 <skypers> that’s great!
14:03:40 <skypers> how long has it supported it?
14:03:55 <dcoutts_> http://ro-che.info/ccc/22
14:04:31 <skypers> great!
14:04:32 <skypers> :)
14:06:45 <qwxc> hi, I'm quite new to haskell and i'm having som issues with implementing a simple webapp using snap, would this be the right place to ask som questions?
14:07:06 <identity> qwxc: yep
14:07:22 <qwxc> excellent!
14:08:11 <qwxc> so, I'm using snap auth, and i want most of my handlers to only run if a user is logged in, how is a good way of doing that?
14:08:29 <qwxc> I don't want to check isLoggedIn in every handler...
14:09:02 <ozataman_> qwxc: see requireUser in http://hackage.haskell.org/package/snap-0.13.0.4/docs/Snap-Snaplet-Auth.html
14:09:17 <ozataman_> put that at the root of your site
14:11:08 <t0rus> äpfel
14:12:07 <briennetheblue> mus
14:13:00 <skypers> http://ro-che.info/ccc/15
14:13:01 <skypers> ahah
14:13:06 <skypers> the confusing part is so true
14:13:10 <qwxc> ozataman_: do you have an example of how to do that, not entirely sure where it goes ..
14:13:11 <skypers> ><>
14:13:17 <skypers> the fish operator :D
14:13:52 <briennetheblue> i still love the lens happy snail operator ^@..
14:13:53 <skypers> :t (><>)
14:13:54 <lambdabot>     Not in scope: `><>'
14:13:54 <lambdabot>     Perhaps you meant one of these:
14:13:54 <lambdabot>       `>>' (imported from Control.Monad.Writer),
14:13:59 <t0rus> muß
14:14:05 <edwardk> hah
14:14:10 <skypers> briennetheblue: what is it for?
14:14:26 <edwardk> briennetheblue: we also have a rat: <<>~
14:14:38 <briennetheblue> :D
14:15:03 <ozataman_> qwxc: simple example: requireUser auth needLoginH (route $ [("foo", fooHandler), ("bar", barHandler)])
14:15:19 <FireFly> maybe 'lens' should've been 'zoo'
14:15:41 <skypers> night
14:25:00 <qwxc> ozataman_: what would needLoginH be?
14:27:47 <haasn> http://hackage.haskell.org/package/these-0.3/docs/Data-These.html <- what's the point of providing prisms if you're just going to roll out all of the ‘is’, ‘preview’, ‘toListOf’ etc. combinators either way? :P
14:27:53 <monochrom> \∩/ ghci can autocomplete ":set -XLamb" too
14:32:15 <edwardk> haasn: its more that the prisms were added to an already existing api
14:35:36 <haasn> The existing API should be deprecated ;)
14:37:24 <codygman> Can haskell not do multiple assignment with tuples? "let x,y = 1,2" gives "parse error on input =".
14:37:52 <acowley> parens
14:37:55 <refold> codygman: use let (x,y) = (1,2)
14:38:52 <edwardk> > let (x,y) = (1,2) in x
14:38:53 <lambdabot>   1
14:39:27 <haasn> note: that's not assignment. It's declaration. It's also not special to tuples, you can pattern match on any constructor
14:40:22 <haasn> > let Just x = Just 3 in x
14:40:23 <lambdabot>   3
14:40:29 <haasn> > let [a,b,c] = take 3 "Hello, world!" in (a,b,c)
14:40:30 <lambdabot>   ('H','e','l')
14:42:34 <ReinH> codygman: for clarification, `x,y' and `1,2' are not tuples.
14:43:19 <nisstyre> Is there a way to block a thread until a specified amount of time has passed OR a TVar is available to read from?
14:43:38 <codygman> thanks ReinH and refold
14:43:44 <codygman> acowley also
14:45:17 <simpson> nisstyre: Hey, the problem that I had and continue to have.
14:45:33 <simpson> nisstyre: You can use the async package's ability to race two actions.
14:45:33 <ReinH> nisstyre: do you perhaps mean TMVar?
14:45:38 <nisstyre> simpson: found a solution?
14:45:45 <simpson> @hackage async
14:45:45 <lambdabot> http://hackage.haskell.org/package/async
14:45:49 <nisstyre> ReinH: maybe, I'll look at that
14:46:04 <nisstyre> simpson: I have used parts of the Async module before, I'll look at that too
14:46:07 <ReinH> An async exception should cause the blocked thread to abort
14:46:22 <ReinH> depending on how it's handled within that thread ofc
14:47:05 <identity> when cabal install fails for some reason, it exits with an exit code that is non-zero, right?
14:47:46 <merijn> identity: It should, yes
14:47:49 <nisstyre> ReinH: yes, looks like TMVar is the right thing
14:47:51 <identity> thanks :)
14:47:58 <merijn> identity: Also, try -v3 for more useful feedback
14:48:10 <identity> merijn: oh, thanks.
14:48:16 * hackagebot randsolid 0.3 - Set the background of your root window to a random colour.  http://hackage.haskell.org/package/randsolid-0.3 (JohannesMartinsson)
14:48:33 <merijn> identity: That prints diagnostics, like which commands where executed and error messages
14:48:52 <identity> I'm merely wondering if I can't get my terminal to set the urgent flag when something returns non-zero
14:48:59 <identity> for stuff like long builds and such
14:50:21 <nisstyre> simpson: waitEither is what you meant right?
14:50:51 <nisstyre> oh race
14:50:52 <nisstyre> nevermind
14:50:57 <codygman> Can someone explain to me why this is happening? I'm guessing it's something to do with lazy evaluation here that I don't understand.
14:51:01 <codygman> http://lpaste.net/94815
14:51:04 <nisstyre> that's awesome
14:51:05 <udevd> @type unfold
14:51:06 <lambdabot>     Not in scope: `unfold'
14:51:06 <lambdabot>     Perhaps you meant one of these:
14:51:06 <lambdabot>       `BS.unfoldr' (imported from Data.ByteString),
14:51:19 <udevd> @type unfoldr
14:51:20 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
14:54:01 <codygman> oh I feel silly
14:54:06 <monochrom> nisstyre: you may like waitEitherCancel. there are others. go through the doc to find something you like
14:54:49 <nisstyre> monochrom: yeah, it's a very useful module
14:55:24 <monochrom> codygman: heh, the Infinity refers to IEEE 754's infinity
14:55:57 <frx> @src concat
14:55:57 <lambdabot> concat = foldr (++) []
14:59:16 <letrec> I cabal installed http-conduit using bytestring 0.10.2.0 However because of a bug in this version, I would like to rebuild http-conduit (and all other packages) with a different bytestring, like 0.10.4.0. How do I do this?
15:00:01 <nisstyre> letrec: I don't think that's possible without deleting all of your packages, although I could be very wrong
15:00:22 <codygman> what would the type signature of an (x,y) coordinate pair be? I thought it would be (Num a, Num a).
15:00:56 <nisstyre> letrec: you should probably be using sandboxes
15:01:23 <letrec> nisstyre: Ok, so I should delete all the packages and add a constraint. How do I do this? What is a sandbox?
15:01:24 <quchen> What would be the easiest way of having a server send its own address over the network, so that the recipient can connect to it (at a later point in time, for example)? Network.Socket gives me "SockAddr" data as result types, but takes the usual stringy mess as input when establishing a connection
15:01:38 <nisstyre> letrec: hold on, there is a good intro to sandboxes I'll link you to
15:01:55 <nisstyre> http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
15:02:06 <jml> is there a way to get the documentation for a function in ghci?
15:02:11 <quchen> My specific use case is sending server data over multiple nodes in a network, with the goal of having a distant node establish a reverse connection
15:02:38 <nisstyre> letrec: also are you using a cabal build file anyway?
15:03:39 <letrec> nisstyre: Thanks for the pointer. No, I'm just using commands like: cabal install <pkg>
15:04:20 <nisstyre> letrec: ok, I would setup a build file and use a sandbox, it'll be easier in the long run
15:05:23 <merijn> codygman: "(Num a) = (a, a)"?
15:05:28 <identity> holy shit, hakyll takes long to build.
15:05:36 <codygman> Can anyone give me recommendations on this short snippet of code: http://lpaste.net/94819
15:05:39 <merijn> codygman: errr... "(Num a) => (a, a)"
15:05:57 <merijn> codygman: i.e. "a is a Num" and "both tuple arguments have type a"
15:06:40 <merijn> codygman: Is it supposed to take a 4 item tuple as argument?
15:07:17 <merijn> quchen: I'm not sure there's a generic way to do that
15:07:33 <udevd> you can make > getSlopeAndIntercept coords@(x1,x2,y1,y2)
15:07:36 <merijn> quchen: There's no way to know which address is routable for a specific node
15:07:49 <merijn> udevd: He doesn't even need the alias
15:07:59 <codygman> merijn: Yes, well for now it is. How would I write that?
15:08:11 <lpaste> merijn annotated “No title” with “No title (annotation)” at http://lpaste.net/94819#a94820
15:08:17 <quchen> merijn: Is there a "best case" version though? getNameInfo sounds like it could be right: http://hackage.haskell.org/package/network-2.4.2.0/docs/Network-Socket.html#v:getNameInfo
15:08:21 <merijn> codygman: Like that
15:08:24 <quchen> But I'm not competent to judge that
15:09:02 <merijn> quchen: Seems the most sensible, yeah
15:09:19 <quchen> merijn: Okay, thanks for the peace of mind then :-)
15:09:20 <udevd> codygman: why are you using monad here?
15:09:32 <merijn> udevd: Where is he using monad?
15:09:39 <udevd> >return
15:09:47 <codygman> udevd: I'm not on purpose? I noticed that the type signature had monad and was confused actually.
15:09:53 <codygman> oh... return returns a monad?
15:10:00 <merijn> It doesn't return a monad
15:10:02 <merijn> It's a function
15:10:05 <merijn> :t return
15:10:06 <lambdabot> Monad m => a -> m a
15:10:14 <merijn> > return 3 :: Maybe Int
15:10:15 <lambdabot>   Just 3
15:10:19 <udevd> it just builds up context around value.
15:10:20 <merijn> > return 3 :: [Int]
15:10:21 <lambdabot>   [3]
15:10:23 <monochrom> you should say, "return brings in a monad"
15:10:46 <merijn> codygman: There is no notion of "returning from a function" in Haskell
15:11:09 <merijn> codygman: Function bodies are always exactly 1 expression and the return value is the result of that expression
15:11:15 <codygman> merijn, monochrom, udevd: Alright, thanks. That helps me reason about this easier.
15:11:28 <monochrom> merijn is right. "f x = 5" does not mean "f x returns 5". it means "f x is 5. is. equals."
15:11:41 <lpaste> udevd annotated “No title” with “No title (annotation) (annotation)” at http://lpaste.net/94819#a94821
15:11:59 <merijn> codygman: Yeah, that should work fine
15:24:01 <codygman> I am trying to rewrite a friends code in haskell, and was wondering if I can accomplish (don't want the answer to it) this for loop in haskell or if I should be making a seperate function using recursion/pattern matching: https://github.com/johnwessolomon88/document-image-reader/blob/master/GeometryFunctions.py#L168
15:26:29 <Kinnison> looks like a list comprehension
15:27:28 <Rylee> #haskell, I am excited. http://i.imgur.com/sZekXba.jpg
15:28:17 <hpc> Rylee: it's a pretty great book
15:28:18 * Kinnison likes those socks/leggings
15:28:27 <Rylee> hpc, i know right
15:28:50 <Rylee> I was working on it on the online version but it was half off on Amazon, so I just bit the bullet and went for it
15:29:08 * Kinnison needs to find another project to do in Haskell to learn more
15:30:14 <t0rus> gz
15:31:09 <simpson> Rylee: It's a pretty entertaining read.
15:31:35 <kenkku> a paper copy, nice
15:31:36 <Rylee> I strongly agree, heh - the illustrations are great and he words things well.
15:31:38 <kenkku> very retro
15:31:49 <t0rus> Kinnison, have you done any of 99 problems or PE?
15:32:02 <Kinnison> t0rus: I work better with a project I see use in
15:32:09 <t0rus> ic
15:32:12 <Kinnison> t0rus: I used to do PE (and indeed did some PE livecoding on youtube)
15:32:32 <Kinnison> t0rus: I had a project of my own, but it got squished by work and I've yet to work up the enthusiasm for another :-(
15:33:02 <llano> is there a way to pattern match a range of numbers in an instance declaration?
15:33:38 <t0rus> im making a game of life
15:33:55 <geekosaur> llano, not without using type level naturals or something
15:34:05 <t0rus> im not very good with project ideas either, lol.
15:34:14 <Kinnison> t0rus: I did a Conway implementation a while ago.  It was fun.  I think you'll enjoy achieving something :-)
15:34:22 <t0rus> idd
15:34:43 <lpaste> monochrom pasted “from an appending loop to a list comprehension” at http://lpaste.net/94823
15:34:59 <monochrom> codygman: my http://lpaste.net/94823 may help
15:35:04 <t0rus> irc bots are always fun
15:35:57 <monochrom> in fact, I don't understand why your friend didn't use python's very own list comprehension
15:36:23 <simpson> It is a sad result that most Python code in the wild is bad.
15:37:00 <lightquake> s/Python //
15:38:28 <monochrom> well, I guess I "understand". it's because "[int(round(float(y - inter) / float(slope))), y] for y in xrange(y0, y1+1)" is too long
15:38:56 <llano> geekosaur, sounds complicted...i'll go back to the drawing board
15:39:04 <monochrom> people must break down a compound expression into a million small bindings. they must.
15:43:30 <monochrom> in the 1960s, John Backus gave us the gift of Fortran. its whole point was to allow you to write compound expressions like (x+4)*(y+z), because before Fortran they were forced to write a million small bindings like "tmp1 = x+4; tmp2 = y+z; now you can talk about tmp1*tmp2"
15:44:00 <monochrom> today, people trash that gift. they seek to undo it and go back to a million small bindings
15:46:07 <monochrom> to say that "mainstream programmers are reinventing the past 40 years of inventions" give them way too much credit. mainstream programmers are uninventing the past 40 years of inventions.
15:46:37 <hpc> monochrom: to be fair, you can't uninvent something you have never used
15:47:07 <monochrom> but they have used (x+4)*(y+z)
15:48:08 <lightquake> let xPlusOne = x + 1
16:03:13 <letrec> How do I specify more than one source file for an executable in a cabal file?
16:03:22 * hackagebot direct-sqlite 2.3.7 - Low-level binding to SQLite3. Includes UTF8 and BLOB support.  http://hackage.haskell.org/package/direct-sqlite-2.3.7 (IreneKnapp)
16:03:38 <letrec> Looks like hs-source-dirs isn't built
16:03:43 <monochrom> use "other-modules"
16:03:58 <monochrom> did you know: http://www.haskell.org/cabal/users-guide/ exists
16:14:15 <udevd> @type foldl
16:14:16 <lambdabot> (a -> b -> a) -> a -> [b] -> a
16:18:18 <zugz> nice way to express (\x y -> f x == f y)?
16:18:38 <udevd> hey! how to efficiently write multiple lines to a file? apparently, let toWrite = foldl' fun data in writeFile filename data is approx. 3.5x times worse than just redirecting output using shell > (./program > filename)
16:18:38 <copumpkin> (==) `on` f
16:19:00 <udevd> erm
16:19:09 <udevd> let toWrite = foldl' fun data in writeFile filename toWrite
16:19:11 <udevd> .
16:19:29 <zugz> copumpkin: nice, thanks
16:19:49 <copumpkin> I'm pretty awesome
16:20:07 <copumpkin> :P you're welcome
16:20:33 <udevd> ;_; noone knows
16:21:33 <acowley> cabal sandbox doesn't play nicely with bash completion
16:22:25 <acowley> But I don't know enough about how that stuff works to even write up an issue beyond that sentence :/
16:24:00 <edwardk> I just posted https://www.fpcomplete.com/user/edwardk/editorial/procrustean-mathematics feedback welcome
16:24:43 <acowley> Is bool defined anywhere standard yet?
16:25:30 <Ghoul_> would it be good practise to hardcode the first, say, 50 primes, into a library which advertises calculating primes using a fast sieve
16:26:38 <edwardk> acowley: Data.Bool in 7.8
16:26:42 <Eduard_Munteanu> Ghoul_: aren't the first primes the easiest to compute?
16:26:53 <acowley> edwardk: thanks
16:27:16 <acowley> The 7.8 release can't some soon enough
16:27:17 <Eduard_Munteanu> Ghoul_: I'm just saying that's a O(1) space-time tradeoff, morally
16:27:51 <Ghoul_> well, surely its still faster though
16:27:56 <edwardk> carter: numerous typos in your latest couple of tweets
16:28:37 <acowley> carter is a typo artist
16:29:05 <ReinH> carter: your tweets do not type check
16:29:07 <Eduard_Munteanu> Tycon artist? :P
16:29:07 <ReinH> please fix
16:29:16 <ReinH> edwardk: hai!
16:29:21 <edwardk> heya ReinH
16:29:31 <copumpkin> twutter
16:30:23 <ReinH> edwardk: so I have my dual geforce 760 pc now
16:30:38 <ReinH> but the one of the mobo's pci slots is busted
16:30:38 <edwardk> the better to run roguelikes?
16:30:40 <ReinH> :/
16:30:40 <acowley> !
16:30:48 <ReinH> so I have to rma the mobo
16:30:54 <acowley> that's a lot of compute
16:31:09 <ReinH> which involves the exact thing I tried to avoid by not building my own PC: seating the CPU and RAM and shit
16:31:15 <edwardk> i think it'll be a damn sexy rogue-like with that kind of horsepower as the expected default ;)
16:31:21 <ReinH> also buying was cheaper than building(!)
16:31:29 <ReinH> edwardk: heh
16:31:32 <acowley> ReinH: Where did you buy from?
16:31:41 <ReinH> acowley: ibuypower.com
16:31:46 <ReinH> stupid name, totally reasonable prices
16:31:48 <edwardk> ReinH: could be worse. try doing that with a watercooled rig
16:31:53 <ReinH> that should be their tag line
16:31:56 <acowley> I like shopping for good value then buying macs
16:31:56 <ReinH> edwardk: it is water cooled :D
16:32:03 <edwardk> oh, then you're screwed
16:32:12 <ReinH> edwardk: nah, water cooling systems are self contained now
16:32:23 <edwardk> ah. i'm a dinosaur =)
16:32:25 <ReinH> :D
16:32:38 <ReinH> it's not just pouring water over the CPU like some sort of savage
16:32:40 <ReinH> :p
16:32:50 <ReinH> but I fucking hate seating CPUs
16:32:55 <ReinH> so many tiny pins, so easy to break
16:33:12 <edwardk> now now, we didn't pour water.. it was mineral oil. then you just had to look out for wicking
16:33:18 <ReinH> edwardk: :p
16:33:23 <acowley> There are so many pins, they can't possibly all matter
16:33:23 * hackagebot bindings-GLFW 3.0.3 - Low-level bindings to GLFW OpenGL library  http://hackage.haskell.org/package/bindings-GLFW-3.0.3 (BrianLewis)
16:33:25 * hackagebot GLFW-b 1.4 - Bindings to GLFW OpenGL library  http://hackage.haskell.org/package/GLFW-b-1.4 (BrianLewis)
16:33:25 <ReinH> edwardk: you said water cooled so I went with it :p
16:33:30 <edwardk> =)
16:33:41 <Eduard_Munteanu> There are oil-cooled computers AFAIK.
16:33:48 <ReinH> edwardk: so Planetside 2 (massively multiplayer FPS) has traditionally been CPU limited
16:33:56 <Eduard_Munteanu> Like immersed in oil.
16:34:16 <ReinH> which means that my i7 4770 gets between 30 to 60 fps at 2560x1440
16:34:21 <edwardk> @google mineral oil computer
16:34:22 <lambdabot> http://www.pugetsystems.com/submerged.php
16:34:22 <lambdabot> Title: Custom PC; Mineral Oil Submerged Computer
16:34:32 <ReinH> which is actually really good because that CPU is excellent at single threaded performance
16:34:50 <ReinH> edwardk: but the PS2 devs are currently doing a "make shit faster" phase where they just focus on performance
16:34:51 <Eduard_Munteanu> ReinH: Direct3D 9? That is usually a CPU hog, yeah.
16:35:04 <Ghoul_> #haskell-blah
16:35:20 <ReinH> and on the test server I'm now GPU limited at 2560x, which means that once SLI fucking works I should have stellar performance :D
16:35:23 <ReinH> Ghoul_: ok
16:35:37 <Ghoul_> yeah I know, I'm no fun :(
16:35:43 <edwardk> my old dell 30" is about to give up the ghost, so i'm thinking about biting the bullet and buying a 4k monitor, but i don't really want to revisit my pc rig
16:35:52 <ReinH> Ghoul_: apologies for interrupting the fascinating Haskell chat that was going on :D
16:35:58 <Ghoul_> lol
16:36:32 <ReinH> Ghoul_: yes, you should totally hard code the first 50 primes. But why stop there? TH generate the first 1000
16:36:36 <ReinH> FOR SPEED
16:37:01 <acowley> Should write a PS2 helper application in threepenny-gui
16:37:22 <ReinH> edwardk: I was serious btw when I tweeted about wanting to get you and Carmack talking about Haskell and graphics and games :)
16:37:25 <ReinH> I think it would be fascinating
16:37:31 <acowley> The way to talk about what you want to talk about is to write somewhat related Haskell code. This drives my research.
16:37:32 <ReinH> but I don't know how to reach out to him
16:37:55 <edwardk> typically you don't =)
16:38:11 <ReinH> acowley: hah I'm going to dual boot into *nix soon and start running shit on my GPU
16:38:16 <ReinH> and eventually GPUs once I fix the fucking mobo
16:38:24 * hackagebot GLFW-b-demo 1.0.4 - GLFW-b demo  http://hackage.haskell.org/package/GLFW-b-demo-1.0.4 (BrianLewis)
16:38:29 <ReinH> ^ yes like that
16:38:30 <ReinH> ;)
16:38:31 <acowley> My OpenCL stuff is pretty good
16:38:36 <Eduard_Munteanu> Hrmpf, I find myself naming a lot of record fields 'fooBar' when the type is called 'foo'. Any suggestions on how to avoid that?
16:38:37 <acowley> So I recommend it!
16:38:44 <acowley> I'll cut a release next week hopefully
16:38:50 <ReinH> acowley: sweet
16:38:53 <acowley> It's under heavy use now
16:39:10 <ParaSa1lin> Eduard_Munteanu, change it up with "derp" and "hodor" occasionally
16:39:29 <ReinH> edwardk: new nvidia proprietary shit like HBAO+ is quite nice. Also fuck ATI.
16:39:50 <Eduard_Munteanu> I wish there was a page listing a variety of coding styles, so you can compare them like you compare fonts.
16:40:01 <Ghoul_> No, don't fuck ATI :(
16:40:42 <simpson> ReinH: I don't want to start a flamewar, but please have a modicum of respect for open drivers.
16:41:43 <ReinH> simpson: that's totally fair
16:41:54 <ReinH> It's just too bad their tech isn't on par
16:42:11 <ReinH> And although nvidia has been historically pretty evil, they're starting to come around
16:42:16 <ReinH> probably largely due to pressure from Valve
16:42:31 <Ghoul_> "Tech isn't on par" isn't fair given the new R290X
16:42:58 <Ghoul_> and historically radeon drivers have always been better on linux except for APU's (fixed in 3.11)
16:43:25 <simpson> AMD/ATI provided me with 2yrs of open source experience, documentation, and equal footing at a time when there weren't any other alternatives for sticking to both open-source software and 3D acceleration.
16:43:46 <simpson> So I'm loathe to say that not having the best benchmark numbers immediately puts a vendor into the trashbin.
16:44:23 <simpson> Especially given that the third-place vendor in benchmarks, Intel, has roughly the market share of AMD/ATI and nVidia combined.
16:44:39 <simpson> But you're totally entitled to your opinion. >:3
16:44:50 <ReinH> Ghoul_: the 290x is a significant upgrade from their earlier offerings, by way of actually incorporating a new GPU ;)
16:45:49 <ReinH> It seems like it was specifically designed as a Titan slayer.
16:46:05 <ReinH> Which is awesome. I'm glad they finally have a competitive offering again
16:47:12 <ReinH> So I guess the more nuanced sentiment is: as an OSS dev, fuck nvidia prior to SteamOS. As a gamer, fuck ATI prior to the 290X ;)
16:47:42 <averell> at least pulseaudio is not the default there...
16:47:45 <averell> mis
16:47:48 <Ghoul_> The submerged oil computer is cool
16:48:18 <monochrom> I like this discussion, but it should go to #haskell-blah
16:48:23 <ReinH> monochrom: that's true
16:48:25 * ReinH heads that way
16:52:03 <zzo38> I think I figured out now, how to make up the type that I have asked about before.
16:52:59 <zzo38> Something like this perhaps:   class (Eq s, SetType__ s) => SetType s where { type SetOf s :: *; ... }; constructSetType :: forall a c. (forall b. SetType b => SetOf b -> (b -> c) -> a) -> [c] -> a; ...
16:53:05 <zzo38> Do you expect things like this working?
16:53:33 <Eduard_Munteanu> zzo38: what is it supposed to do?
16:53:44 <Eduard_Munteanu> If there's a short way to describe it.
16:54:20 <zzo38> Eduard_Munteanu: To make up a set of unique values and a unique type of values belonging to that set, at runtime.
16:55:12 <Eduard_Munteanu> zzo38: do you mean you want the type system to enforce uniqueness?
16:56:34 <zzo38> Eduard_Munteanu: No, not really; rather, I mean that it might be used something like this:  DirectedGraph :: forall n v. SetType n => SetOf n -> (n -> v) -> (n -> n -> Bool) -> DirectedGraph v;  This isn't quite the correct definition of a directed graph, but it is hopefully good enough to explain what I mean by this.
16:59:17 <zzo38> (Note: SetType__ is a private class, and its only instance is a private newtype wrapper.)
16:59:33 <zzo38> Do you understand what I mean now?
17:00:37 <Eduard_Munteanu> zzo38: sorry, not really. I was doing something else as well, can't pay enough attention right now.
17:01:17 <zzo38> OK. Does someone else understand me?
17:03:09 <zzo38> singleton :: forall a. (forall b. SetType b => SetOf b -> b -> a) -> a;   may be another function which can create a SetType.
17:04:21 <udevd> @type intersperse
17:04:22 <lambdabot> a -> [a] -> [a]
17:05:14 <udevd> > intersperse ' ' ['a'..'z']
17:05:15 <lambdabot>   "a b c d e f g h i j k l m n o p q r s t u v w x y z"
17:05:37 <zzo38> (It doesn't actually create a new type with every call (it is actually always the same time), but it pretends to.)
17:06:31 <zzo38> This can be done without using unsafeCoerce or any other unsafe.
17:07:03 <udevd> > intersperse " " ['a'..'z']
17:07:04 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:07:04 <lambdabot>              with actual ty...
17:07:10 <udevd>  ['a'..'z']
17:07:12 <udevd> > ['a'..'z']
17:07:13 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
17:08:26 * hackagebot bindings-GLFW 3.0.3.1 - Low-level bindings to GLFW OpenGL library  http://hackage.haskell.org/package/bindings-GLFW-3.0.3.1 (BrianLewis)
17:08:28 * hackagebot GLFW-b 1.4.1 - Bindings to GLFW OpenGL library  http://hackage.haskell.org/package/GLFW-b-1.4.1 (BrianLewis)
17:08:30 * hackagebot GLFW-b-demo 1.0.5 - GLFW-b demo  http://hackage.haskell.org/package/GLFW-b-demo-1.0.5 (BrianLewis)
17:13:32 <airlok9> I'm using some (I assume) legacy code, and it's throwing "Pattern syntax in expression context" on ->, anyone encountered this before?
17:14:13 <monochrom> I haven't. I write pretty clean code.
17:14:18 <geekosaur> airlok9, show actual code?
17:14:21 <geekosaur> @lpaste
17:14:21 <lambdabot> Haskell pastebin: http://lpaste.net/
17:15:05 <monochrom> perhaps it's a poll.
17:15:08 <airlok9> http://lpaste.net/94828
17:15:36 <geekosaur> you may be seeing code written for an extension your ghc doesn't understand, especially if this is the ghc from e.g. ubuntu (still 7.0.4 last I heard)
17:15:42 <monochrom> replace "(x,y) ->" by "\(x,y) ->"
17:15:43 <Eduard_Munteanu> airlok9: that's not a valid lambda, you need a '\'
17:15:51 <geekosaur> oh
17:15:57 <geekosaur> yeh, you lost a \ there
17:16:26 <Eduard_Munteanu> I suspect that referred to ViewPatterns?
17:16:59 <Eduard_Munteanu> f (isJust -> True) = ...   but here it's used in an illegal context.
17:18:05 <Eduard_Munteanu> I guess it fits case-of too though.
17:18:22 <airlok9> Even adding the "\" to "\(x, y) ->", it fails with the same error
17:18:51 <airlok9> Never mind, works now
17:18:52 <airlok9> odd
17:19:04 <airlok9> Thanks all
17:19:08 <simpson> :t charMatch (p,q) far = filter (\(x,y) -> x >= p - far && x <= p + far && y == q)
17:19:09 <lambdabot> parse error on input `='
17:19:20 <simpson> :t \(p,q) far -> filter (\(x,y) -> x >= p - far && x <= p + far && y == q)
17:19:22 <lambdabot> (Eq a1, Num a, Ord a) => (a, a1) -> a -> [(a, a1)] -> [(a, a1)]
17:19:43 <gaze__> hey guyz. What sort of performance penalty is there in directly sequencing IO actions vs. folding over something that generates data that picks the IO actions
17:20:10 <gaze__> I'm trying to write a "pure" graphics library
17:20:22 <gaze__> and I could either do it the cairo way where I just call the FFI
17:20:44 <gaze__> or I could have the "cairo" of my design fold over "draw line" "draw rect" commands generated by my program
17:20:59 <gaze__> and I understand that haskell is quite good at this sort of thing?
17:21:48 <Eduard_Munteanu> gaze__: I guess it depends on whether you write code that fuses the intermediate layers.
17:22:13 <gaze__> "fuses the intermediate layers." what does this mean?
17:22:28 <gaze__> I understand that what I described is sort of the iteratee strategy, yeah?
17:22:33 <gaze__> and it's quite fast.
17:22:46 <Eduard_Munteanu> gaze__: e.g. list fusion, namely that lists that are produced and consumed are actually absent from final code, if you do it right.
17:23:36 <Eduard_Munteanu> gaze__: I wouldn't expect things to fuse magically, but packing/unpacking isn't horribly slow either.
17:23:57 <gaze__> ah ha!
17:24:14 <gaze__> that's exactly what I was hoping would happen
17:24:47 <Eduard_Munteanu> gaze__: there are fusion combinator libs around, like 'stream-fusion'
17:24:56 <gaze__> how can I figure out if list fusion "happened", what are the sort of constraints on the code that the compiler will be looking for
17:25:14 <Eduard_Munteanu> gaze__: you can look at the generated Core code.
17:25:23 <zq> is parsec supposed to be a rerplacement for regexes?
17:25:44 <zq> s/be a replacement/stand in place/
17:26:23 <Eduard_Munteanu> zq: not really, unless parsers generally are replacements for regexes too. :)
17:26:51 <zq> haskell has teh regexs?
17:27:02 <Eduard_Munteanu> zq: yes, quite a few libs
17:27:12 <geekosaur> altogether to many people try to use regexes for parsing
17:27:15 <geekosaur> *too
17:27:24 <gaze__> okay now I'm really excited
17:27:25 <zq> recommended parsec tuts?
17:27:40 <Earnestly> pandoc’s source :P
17:27:43 <geekosaur> ob http://stackoverflow.com/questions/1732348
17:27:53 <Eduard_Munteanu> zq: http://www.haskell.org/haskellwiki/Regular_expressions  -- pick your poison :P
17:28:55 <zq> geekosaur: right link, wrong time :pp
17:29:25 <zq> i'm finding rwh's section on parsec mind-numbingly slow
17:29:59 <Eduard_Munteanu> zq: oh, you can just read the haddock stuff from the package
17:30:19 <thirsteh> MessagePack vs. Binary vs. Cereal -- thoughts?
17:30:38 <Eduard_Munteanu> zq: you just need to be familiar with Applicative and Alternative, and you can google for some examples on Parsec to get a taste first.
17:31:08 <Earnestly> Scheme in 48 hours?
17:31:47 <Earnestly> Specifically: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
17:31:53 <zq> yeah god no
17:32:00 <zq> so much hand wavy magic
17:32:14 <zq> "do this, you'll get a purple snake. do that, you'll get a blue snake."
17:33:12 <Earnestly> *shrug*
17:33:46 <zq> Earnestly: thanks, anyhow
17:43:11 <airlok9> Another odd error: "Prelude.head: empty list" despite pattern checking for empty strings. http://lpaste.net/94829
17:44:15 <geekosaur> not odd at all
17:44:21 <geekosaur> you check the strings you pass in
17:44:25 <Eduard_Munteanu> airlok9: what check? You only check the length isn't 4
17:44:35 <geekosaur> you don't handle in cp the fact that you lop the head off and reinvoke cp
17:45:14 <airlok9> Just above that, right? Lines 2-4 check for "" inputs
17:45:29 <geekosaur> you are not reinvoking commonPrefix
17:45:42 <geekosaur> you do not have those checks in cp, which you *do* recursively call
17:46:26 <monochrom> yeah, cp has the problem
17:46:55 <airlok9> ok, I'll add patern matching to cp
17:48:10 <thirsteh> What is the internal representation of Data.Text again.. UTF16LE? I'm wondering which encodeFoo function will be fastest if I just need to interchange serialized Texts
17:48:47 <thirsteh> It's definitely not UTF8, judging from the encodeUtf8 function
17:50:10 <monochrom> it's a kind of UTF16. but no BE or LE because it uses a real 16-bit data type, not a combination of two 8-bit data types.
17:50:37 <monochrom> and I say the weak "a kind of" because I want to avoid being sued by the police
17:51:29 <thirsteh> monochrom: I see. I'll just use encode/decodeUtf16LE
17:51:32 <monochrom> although, they being the police, they could still sue me on the ground of "but there is only one UTF16, therefore you're still a criminal for saying 'a kind of'"
18:11:26 <codygman> How would I make a list comprehension equivalent to this python construct:  xrange(x0, x1 + 1)
18:11:57 <codygman> I guess I mean to ask, how can I refer to the length of a list in a lazy language... I can't right? So I need a different approach?
18:12:59 <hpc> codygman: that's xrange(start, step) or xrange(start, end)?
18:13:23 <codygman> I suppose I could do [ x | x <-  [0..y+1] | y <- [0..]]. hpc: that is start, end.
18:13:39 <hpc> codygman: [x0 .. x1 + 1]
18:13:53 <hpc> (that desugars to enumFromTo x0 (x1 + 1))
18:14:15 <codygman> hpc: Interesting.  Thanks for the desugar ;)
18:14:31 <Eduard_Munteanu> > [1..length xs] where xs = [5, 14, 4]
18:14:33 <lambdabot>   <hint>:1:16: parse error on input `where'
18:14:41 <hpc> see the rest of Enum for other neat stuff
18:15:06 <codygman> hpc will do, that's pretty cool
18:15:07 <Eduard_Munteanu> > let xs = [5, 14, 4] in [1..length xs]
18:15:09 <lambdabot>   [1,2,3]
18:15:24 <Eduard_Munteanu> Not sure why 'where' doesn't work anymore, hm.
18:15:36 <hpc> oh, i think i missed the part where x1 is a list
18:15:41 <Eduard_Munteanu> Maybe I misremember it working.
18:15:56 <geekosaur> Eduard_Munteanu, where is part of declaration syntax, you used it on an expression
18:16:17 <hpc> codygman: so if x1 is a list and you're xranging like that, i assume you'll be using that to index into the list?
18:16:33 <Eduard_Munteanu> Yeah, I thought it worked as if the whole thing was an  it = ...
18:16:37 <hpc> in which case you probably want a fold or map instead
18:16:48 <codygman> I'm using the index values more specifically. They are the x or y value in a list of coordinates.
18:17:15 <sclv> ryantrinkle: looks like the event was a success?
18:17:15 <geekosaur> ghci might conceivably work that way; hint/lambdabot doesn't
18:17:26 <monochrom> old lambdabot allowed "x where x=3" because began by rewriting to "it = x where x=3" or something like that
18:17:50 <hpc> that's pretty neat
18:17:52 <geekosaur> oh, yeh, pre-hint lambdabot
18:18:17 <monochrom> it was very old
18:18:42 <monochrom> it was also uphill both ways :)
18:18:49 <geekosaur> it got pretty old :p
18:32:37 <codygman> For whatever reason I haven't been able to figure out how to turn this python code into haskell code yet, could anyone help me or at least let me know if I'm going in the right direction? http://lpaste.net/4539132729328926720
18:35:35 <Cale> codygman: I'll have a look
18:35:40 <heatsink> codygman, it helps to add type signatures
18:36:35 <udevd> > fmap (*2) 2
18:36:37 <lambdabot>   No instance for (GHC.Show.Show (f0 b0))
18:36:37 <lambdabot>    arising from a use of `M16997084...
18:36:41 <Cale> You have y <- (slope * x) + intercept
18:37:01 <Cale> which makes it think that (slope * x) + intercept must be a list
18:37:12 <Cale> because it occurs to the right of <- in a list comprehension
18:37:22 <monochrom> "slope" does not exist
18:37:39 <Cale> slope is bound in the where clause
18:37:53 <Cale> But it's not intended to be a list
18:38:02 <monochrom> I see
18:38:09 <Cale> You probably wanted  let y = (slope * x) + intercept
18:38:25 <codygman> Cale, monochrom: oh.... I didn't notice I was doing that. I didn't know you could use let within list comprehensions.
18:38:36 <Cale> (and similarly in the other list comprehension,  let x = (y - intercept) / slope  )
18:38:41 <heatsink> If you add a type signature to getSlopeAndIntercept, then you get a type error at the expression (y - intercept) / slope, which is closer to the real problem.
18:39:36 <udevd> > [(i,j) | i <- [1..3], j<-'!']
18:39:38 <lambdabot>   Couldn't match expected type `[t1]'
18:39:38 <lambdabot>              with actual type `GHC.Type...
18:39:39 <Cale> Yeah, adding type signatures to indicate your intentions tends to help GHC report errors much more clearly
18:39:42 <udevd> > [(i,j) | i <- [1..3], j<-"!"]
18:39:44 <lambdabot>   [(1,'!'),(2,'!'),(3,'!')]
18:44:08 <udevd> > repeat 1
18:44:10 <zzo38> I think I have done it:   http://sprunge.us/jiGA
18:44:10 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:44:44 <zzo38> Do you have a comment of this please?
18:48:39 <udevd> @kind Either
18:48:42 <lambdabot> * -> * -> *
18:50:42 <osa1> so I'm trying to compile "poppler" library with latest cabal and I think I have to rewrite it's setup program and it's a gtk program .. is there an easy way to generate setup.hs for gtk programs?
18:53:48 <udevd> > sequence . map print $ [1..5]
18:53:50 <lambdabot>   <IO [()]>
18:53:54 <udevd> > sequence_ . map print $ [1..5]
18:53:55 <lambdabot>   <IO ()>
18:58:03 <hamishmack> osa1: You should be able to copy Setup.hs, SetupMain.hs SetupWrapper.hs and Gtk2hsSetup.hs from one of the other libraries
18:58:52 <hamishmack> You might want to add gtk3 support too.  We have been doing that by having two .cabal files.
18:59:34 <hamishmack> osa1: Here is one I have been working on... https://github.com/gtk2hs/gtksourceview
19:01:37 <osa1> hamishmack: thanks, I'm trying
19:02:19 <monochrom> eh? Neil Mitchell has an article in ACM Queue on memory leaks
19:02:42 <monochrom> err, space leaks, he makes a big distinction
19:04:50 <monochrom> I dislike how he brings up only how lazy evaluation can use more memory, not how eager evaluation can use more memory
19:05:08 <zzo38> Do you know much about program I have linked here?
19:05:33 <monochrom> I don't
19:06:00 <zzo38> I would want to request comment of it though.
19:06:52 <monochrom> especially given his article's preamble: Xena wants one page from a 26-volume encyclopedia. she begins by buying the whole set.
19:07:25 <monochrom> that is exactly a space leak caused by eager evaluation, and exactly avoided by lazy evaluation.
19:08:08 <zzo38> OK, but I want to ask a different question please.
19:09:38 <monochrom> but no, the main sections must portray lazy evaluation as the main cause of space leaks. and now he has to write 10 lines defending writing lazy programs.
19:11:11 <monochrom> as opposed to simply pointing out that eager evaluation also causes space leaks. you must choose an evaluation wisely, and it is not always the same choice.
19:16:31 <codygman> thanks cale, heatsink, and monochrom for your help earlier.
19:16:42 <monochrom> you're welcome
19:16:46 <heatsink> np
19:28:07 <darkf> In Parsec, what would be the best way to implement some postfix record access operator? Like, a rule might be "expr ::= expr '.' identifier | ...", but I couldn't do that due to left recursion
19:28:56 <monochrom> consider sepBy, chainr, chainl
19:32:01 <darkf> monochrom: chainl looks like what I'm after, thanks.
20:01:10 <mm_freak> edwardk: (reflection) what's the run-time penalty for reflecting a type-level integer generated by 'int' or 'nat'?
20:01:27 <mm_freak> especially when doing it multiple times
20:03:42 <Ghoul_> woah that guy up there uses braces in haskell
20:04:04 <Ghoul_> and semicolons..
20:11:07 <pharaun> braces? semicolons? madness!
20:13:50 <udevd> > intersperce 2 [1..10]
20:13:52 <lambdabot>   Not in scope: `intersperce'
20:13:52 <lambdabot>  Perhaps you meant one of these:
20:13:52 <lambdabot>    `interspers...
20:14:03 <udevd> > intersperse 2 [1..10]
20:14:04 <lambdabot>   [1,2,2,2,3,2,4,2,5,2,6,2,7,2,8,2,9,2,10]
20:14:25 <udevd> > intersperce "2" [show k|k<-[1..10]]
20:14:26 <lambdabot>   Not in scope: `intersperce'
20:14:26 <lambdabot>  Perhaps you meant one of these:
20:14:26 <lambdabot>    `interspers...
20:14:29 <udevd> > intersperse "2" [show k|k<-[1..10]]
20:14:31 <lambdabot>   ["1","2","2","2","3","2","4","2","5","2","6","2","7","2","8","2","9","2","1...
20:18:09 <mm_freak> > intercalate ", " (words "The Way I Walk")
20:18:10 <lambdabot>   "The, Way, I, Walk"
20:19:04 <mm_freak> i'm desparately looking for a good implementation of type-level naturals using DataKinds…  one that supports arithmetic
20:28:58 <Ghoul_> mm_freak: isnt that in 7.8 now?
20:29:20 <Ghoul_> minus arithmetic, I think that got stripped
20:32:40 <mm_freak> Ghoul_: i'm on GHC 7.6
20:32:53 <mm_freak> the type-natural library seems interesting
20:33:04 <Ghoul_> gah
20:33:08 <Ghoul_> my cabal always gets corrupt
20:33:12 <Ghoul_> its retarded and annoying
20:42:25 <Infandum> What is the correct layout for modules? Like, should I have separate modules for my own types and import those into all the files or...
20:42:55 <Infandum> I'm at a total loss of how to divide a "monolithic" file into several small ones.
20:43:18 <enthropy> do you have a big module now?
20:43:47 <Infandum> I had a single file that was growing (started at like 500 lines, became 1000, getting bigger, so I thought I should split it up).
20:44:36 <Infandum> So now I have four modules, but some of their types and funcitons overlap with each other but it wouldn't make sense to import each into each other
20:44:37 <enthropy> some people put data types separately
20:44:54 <enthropy> doing that isn't going to make you need recursive imports
20:44:57 <enthropy> which are good to avoid
20:45:13 <Infandum> Doing what?
20:45:21 <Infandum> Gathering all types from all modules in a single module?
20:45:32 <Infandum> It sounds like a good idea, but is it?
20:46:05 <Infandum> Also, if two modules need the same function, but it's a two line function, should I really be making another module for it or just leave the duplicated code?
20:46:19 <Infandum> Well, 4 or 5
20:46:20 <Infandum> line
20:46:27 <Infandum> you know
20:47:05 <mm_freak> Infandum: otherwise you may want to ask yourself whether they really need to depend on each other
20:47:30 <mm_freak> for example data structures i usually define in a single module (perhaps with some auxiliary submodules)
20:47:47 <mm_freak> for domain/application/business-specific types i often have a .Types module
20:47:54 <Infandum> mm_freak: What do you mean?
20:48:38 <mm_freak> Infandum: for example just this very minute i'm struggling to define a data structure that is not application-specific, but will be used by my application…  it's just a fancy list type with corresponding operations
20:48:48 <mm_freak> i collect both the type and the operations in a single module
20:49:18 <Infandum> mm_freak: So only the really generic types you gather together?
20:49:34 <mm_freak> Infandum: exactly the opposite
20:49:53 <Infandum> So the really specific into a separate module?
20:49:54 <mm_freak> application-specific types together, generic types separate
20:50:10 <mm_freak> like Data.List vs. MyApp.Model.Types
20:50:19 <Infandum> yeah
20:50:30 <Infandum> I guess I meant application specific
20:50:48 <Infandum> Maybe those should be gathered up
20:51:00 <heatsink> You could make a Utils module
20:51:10 <monochrom> trust your personal taste in dividing up modules
20:51:27 <Infandum> monochrom: You have no idea how hard it is for me to make small decisions
20:52:18 <monochrom> I had. but now I no longer have. after I invented: to break a tie, toss the coin
20:52:19 <mm_freak> Infandum: my approach is the result of trying and failing =)
20:52:24 <mm_freak> Infandum: so just do the same
20:53:24 <Infandum> haha
20:53:27 <Infandum> ohhhh kaaaay
20:53:33 <Infandum> separate modules it is
20:53:37 <Infandum> they will be SO SMALL
20:53:48 <mm_freak> monochrom: indeed, i actually carry around a special coin for that =)
20:54:14 <frx> i am having trouble understanding why implementing concat works with both foldr and foldl? I expected one to give me reverse concatenation.  concat' = foldr (++) []
20:54:34 <monochrom> sometimes, I used my watch. just look at the current second, is it even or odd.
20:54:36 <copumpkin> > foldr f z [a,b,c,d]
20:54:40 <lambdabot>   f a (f b (f c (f d z)))
20:54:47 <copumpkin> > foldl f z [a,b,c,d]
20:54:48 <lambdabot>   f (f (f (f z a) b) c) d
20:54:53 <monochrom> but now, I can't use my watch, its battery is exhausted, and very hard to replace.
20:54:55 <mm_freak> frx: one gives you a ++ (b ++ c), the other gives you (a ++ b) ++ c
20:54:59 <copumpkin> frx: both of them are "left to right", but they associate differently
20:55:02 <copumpkin> that's the only difference
20:55:09 <mm_freak> frx: since (++) is associative the only difference is in performance/strictness
20:55:34 <frx> I see. let me try to process that
20:55:39 <mm_freak> > foldl (++) [] (repeat [1])
20:55:45 <frx> btw which one would be prefered for concat?
20:55:48 <lambdabot>  Terminated
20:55:51 <monochrom> note: it's perfectly alright to toss the coin, then decide to disobey it
20:55:51 <copumpkin> foldr
20:56:12 <heatsink> That reminds me of a grook
20:56:21 <copumpkin> > foldr (++) [] [[1,2,3], undefined]
20:56:25 <lambdabot>   [1,2,3*Exception: Prelude.undefined
20:56:26 <copumpkin> > foldl (++) [] [[1,2,3], undefined]
20:56:27 <lambdabot>   [1,2,3*Exception: Prelude.undefined
20:56:31 <copumpkin> err
20:56:37 <copumpkin> > foldl (++) [] [1,2,3]:undefined
20:56:38 <lambdabot>   No instance for (GHC.Show.Show a0)
20:56:39 <lambdabot>    arising from a use of `M2068041183.sh...
20:56:41 <copumpkin> > foldl (++) [] ([1,2,3]:undefined)
20:56:42 <lambdabot>   *Exception: Prelude.undefined
20:56:44 <copumpkin> > foldr (++) [] ([1,2,3]:undefined)
20:56:46 <lambdabot>   [1,2,3*Exception: Prelude.undefined
20:56:49 <copumpkin> :)
20:56:58 <mm_freak> frx: to understand why foldr is the preferred choice ask yourself what you get when you pattern-match on foldr (++) [] [x:xs,ys,zs]
20:57:03 <monochrom> the coin is just an accelerator of human psychology. sometimes, you don't see which issue is the most important for you, until you have decided and regretted. the coin makes you decide and regret.
20:57:07 <mm_freak> frx: do the same with foldl
20:57:35 <mm_freak> frx: one of the two will allow you to get the answer instantly, the other will force you to compute quite a bit before you get the answer =)
20:58:14 <heatsink> Whenever you're called on to make up your mind, and you're hampered by not having any, the best way to solve the dilemma, you'll find, is simply by spinning a penny.
20:58:45 <heatsink> No — not so that chance shall decide the affair while you're passively standing there moping;
20:58:52 <lpaste> int80_h pasted “What should the type signature be?” at http://lpaste.net/94836
20:59:28 <frx> mm_freak foldr would return immediately, right? it would also work on infinite lists
21:00:08 <heatsink> is addToAL a library function?
21:00:18 <frx> but, then again, i think foldl' would work on very long lists, while foldr may stack overflow?
21:00:27 <lpaste> int80_h revised “What should the type signature be?”: “No title” at http://lpaste.net/94836
21:00:30 <mm_freak> frx: work it out:  (a:as) = foldr (++) [] [x:xs, ys, zs]
21:00:34 <mm_freak> frx: a = ?
21:00:36 <int80_h> fixed
21:00:46 <monochrom> int80_h: you are supposed to write: let test :: (ArrowApply a) => Category Table Table; test = addToAL tbl "y" ^<< interpExp binop
21:01:08 <mm_freak> frx: don't guess, but evaluate =)
21:01:43 <mm_freak> by definition:  foldr (++) [] [x:xs, ys, zs] = (x:xs) ++ foldr (++) [] [ys, zs]
21:01:48 <monochrom> "let x = e :: t" is different from "let x :: t; x = e". different. repeat: different. emphasis again: different. trust me. different. you absolutely want the latter. the latter. repeat: the latter.
21:01:49 <frx> a = x:xs, and foldr stops
21:02:04 <frx> err no
21:02:11 <mm_freak> by definition:  (x:xs) ++ more = x : (xs ++ more)
21:02:26 <mm_freak> so (a:as) = x : (xs ++ more)
21:02:41 <mm_freak> instant answer by evaluating the foldr, then the (++)
21:03:34 <int80_h> monochrom : That was me making a wild guess, I think Category Table Table is wrong
21:03:43 <int80_h> I modified the lpaste
21:03:49 <int80_h> so the code and the wrror agree
21:04:02 <monochrom> the type looks wrong too. I don't know the right type. but I'm just saying how to write a type.
21:04:03 <int80_h> oooh
21:04:05 <frx> @src foldl
21:04:06 <lambdabot> foldl f z []     = z
21:04:06 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:04:06 <mm_freak> frx: exercise: would you define 'map' in terms of foldl or foldr?  do exactly the same thing to figure it out
21:04:46 <int80_h> monochrom: thanks, that was enough to put me on the right track
21:05:00 <int80_h> let test :: (ArrowApply a) => a Table Table; test = addToAL tbl "y" ^<< interpExp binop
21:05:02 <monochrom> why is it not something close to (ArrowApply a) => a Table Table ?
21:05:14 <int80_h> that's it, I was writing it wrong
21:05:16 <frx> mm_freak, should foldr always be prefered when result is a list?
21:05:22 <monochrom> ok good
21:05:27 <mm_freak> frx: no
21:06:25 <mm_freak> frx: foldr is preferable when its function argument is nonstrict in its second argument
21:07:14 <mm_freak> because that's precisely the condition for immediate results on pattern-matching
21:08:30 <monochrom> compare "foldl (&&) False (repeat False)" with "foldr (&&) False (repeat False)"
21:08:38 <frx> isn't that always the case (function is nonstrict in the second argument) when are generating a list with fold*?
21:08:54 <mm_freak> frx: not at all
21:09:01 <mm_freak> (++) is not always nonstrict in its second argument =)
21:09:15 <dao> what's the best way to learn haskell? i'm fairly new
21:09:32 <mm_freak> (x:xs) ++ ys = x : (xs ++ ys)
21:09:38 <mm_freak> but:  [] ++ ys = ys
21:10:02 <mm_freak> dao: there are a number of great books and tutorials you can start with
21:10:06 <copumpkin> which is why concat (repeat []) is a bad idea
21:10:19 <mm_freak> dao: LYAH is very popular
21:10:20 <mm_freak> @where lyah
21:10:20 <lambdabot> http://www.learnyouahaskell.com/
21:10:23 <copumpkin> and why Agda won't even let you write concat
21:10:44 <mm_freak> copumpkin: huh?
21:10:45 <copumpkin> (on possibly infinite lists)
21:10:52 <mm_freak> ah ;)
21:10:53 <monochrom> I put it this way: (++) is conditionally non-strict in the 2nd argument. it depends on the 1st argument.
21:11:17 <copumpkin> concat : Colist (Colist A) -> Colist A isn't safe to write
21:11:19 <dao> mm_freak: Thanks, I'll check it out.
21:11:31 <copumpkin> concat : Colist (Colist+ A) -> Colist A is
21:11:39 <monochrom> but then, the consideration is: when (x ++) is strict, you don't care. when (x ++) is non-strict, you care, and you want foldr.
21:12:07 <mm_freak> copumpkin: i assumed List
21:12:08 <mm_freak> it's obviously wrong for Colist
21:12:09 <monochrom> clearly, logically, you use solely what you care to decide what you want. you don't use what you don't care to decide. isn't that right?
21:12:31 <mm_freak> you can't even write foldr for Colist IIRC
21:12:37 <elliott> copumpkin: hmm, so Colist is a relative monad.
21:12:42 <mm_freak> well, s/even//
21:12:54 <elliott> copumpkin: maybe.,
21:12:54 <mm_freak> if you could write foldr, you could also write concat
21:13:19 <copumpkin> elliott: perhaps!
21:13:28 <copumpkin> elliott: actually, don't think so
21:14:43 <lpaste> int80_h pasted “What's the right arrow command” at http://lpaste.net/94838
21:15:28 <mm_freak> int80_h: why are you using the arrow interface?
21:15:47 <bss03> I have a type with four arguments: Foo a b c d.
21:15:59 <bss03> Values of those 4 types only appear in positive positions.
21:16:59 <bss03> Is there a QuadFunctior or some other existing typeclass that I can implement to provide fmap4 :: (a1 -> a2) -> (b1 -> b2) -> (c1 -> c2) -> (d1 -> d2) -> Foo a1 b1 c1 d1 -> Foo a2 b2 c2 d2 ?
21:17:00 <int80_h> mm_freak: I was implementing the evaluator from the Tiger book, and thinking I might want to use Arrows. Then when I read the Hughes paper, it gave an evaluator similar to what I want. So I figured using the Arrows interface was correct, plus I suppose it's time to learn them.
21:17:05 <monochrom> therefore, you can add 23 newtypes. these 23 newtypes, plus the original type, can all be given Functor instances :)
21:17:14 <int80_h> mm_freak: Chapter 1 of the Tiger book.
21:17:36 <mm_freak> int80_h: if you have an ArrowApply constraint, you could just as well use a monad
21:18:35 <bss03> It's like JSON data, and I'd like to delay / prevent parsing of the Text values until later...
21:19:12 <Ghoul_> its really stupid that hackage is case sensitive
21:19:13 <bss03> Like, i'd present a Foo Text Text Text Text and do a "simple" fmap / traverse / blah to get a Foo Rational (Fixed E9) Double Integer
21:19:13 <Ghoul_> honestly.
21:19:34 <monochrom> I like case sensitive. call me stupid.
21:19:51 <bss03> I also tend to favor case sensitiveity.
21:20:08 <mm_freak> Ghoul_: haskell is also case-sensitive =)
21:20:12 <bss03> Being case insensitive in a Unicode world is not... trivial.
21:20:16 <mm_freak> even more than other languages
21:20:21 <int80_h> mm_freak, hmm so the example in the Highes paper may have been an artifical one.
21:20:26 <int80_h> Hughes
21:20:37 <mm_freak> int80_h: if it uses ArrowApply, then very likely
21:20:47 <Ghoul_> yeah, except it makes sense in haskell
21:20:52 <bss03> I guess I really want to have like QuadTraversable, but QuadFunctor would be a start... :/
21:20:52 <Ghoul_> for package names its just annoying
21:21:51 <mm_freak> int80_h: as an exercise to implement an actual non-monad arrow, implement this type:  data State' s a = State { runState :: s -> (s, a); usesPut :: Bool }
21:22:04 <bss03> monochrom: Where you suggesting that 23 newtypes is the best solution to my QuadFunctor problem. :( ?
21:22:10 <mm_freak> int80_h: the boolean should be True, if the computation potentially changes the state
21:22:15 <monochrom> no, it was a joke :)
21:22:25 <int80_h> mm_freak: challenge accepted
21:22:43 <mm_freak> int80_h: first try to write Functor and Applicative instances (possible)
21:22:53 <bss03> monochrom: Any non-j/k solutions? :/
21:22:59 <mm_freak> int80_h: then try and fail to write a Monad instance…  really do it, to understand /why/ it's not a monad
21:23:01 <int80_h> mm_freak: good I understand those better
21:23:11 <monochrom> write your own QuadFunctor class
21:23:23 <bss03> monochrom: I'd like a typeclass here, mainly because I have another similar (4-argument) type and 2 other slightly smaller (3-argument) types.
21:23:43 <int80_h> mm_freak : my guess will be that it fails to hold to one of the monadic laws
21:23:52 <monochrom> add a TriumvariateFunctor class
21:23:59 <int80_h> mm_freak: and my task will be to find out which one
21:24:00 <mm_freak> int80_h: nope, you won't even be able to implement (>>=)
21:24:08 <bss03> monochrom: Kk.  So, nothing above "BiFunctor" is any hackage libraries?  Not even something crazy from edwardk?
21:24:17 <mm_freak> int80_h: you will run into an interesting chicken-and-egg problem =)
21:24:20 <int80_h> mm_freak: hah! okay I'll do this
21:24:21 <monochrom> I don't know. that's the problem.
21:24:55 <edwardk> bss03: we stop at bifunctors/bifoldables etc, because you can typically bundle things up in pairs
21:25:11 <edwardk> bss03: and beyond a certain scale it starts to become absurd
21:25:28 <edwardk> i've written code that had "Triversable" in it before though, just for the pun.
21:25:49 <monochrom> edwardk: do you like my "a four-parameter type spawns 24 Functor instances" idea? :)
21:25:57 <bss03> edwardk: I'm probably just being absurd.  The types are not exactly pair-able though.
21:26:10 <monochrom> haha Triversable wins
21:26:18 <edwardk> bss03: sure, just pointing out why we don't have them all =)
21:26:32 <int80_h> mm_freak did you mean data State' s a = State {  runState :: s -> (s, a); usesPut :: Bool }
21:26:44 <int80_h> mm_freak did you mean data State' s a = State {  runState :: s -> (s, a), usesPut :: Bool }
21:26:51 <int80_h> I meant to change the ; to a ,
21:26:57 <int80_h> which makes more sense
21:26:57 <mm_freak> int80_h: oh, indeed
21:27:00 <mm_freak> sorry =)
21:27:09 <bss03> edwardk: 1 type is a measurement, 1 type is a different (quantity) measurement, 1 type is the product of those two types, and the final type is a date type (generally unparsed as Text or parsed as LocalTime)
21:27:32 <mm_freak> int80_h: you may want to put the Bool as the first field
21:27:35 <int80_h> no worries. I'm encouraged by being able to notice these things.
21:27:39 <int80_h> okay
21:27:41 <mm_freak> int80_h: makes your code look less awkward =)
21:28:10 <edwardk> why do you have the product of them as an extra component?
21:29:15 <bss03> edwardk: unparsed, the product is just Text, like the others.  I could do that type as a type family instread, I guess.
21:29:44 <edwardk> admittedly this sounds fairly messy
21:30:27 <bss03> edwardk: Internally, there's no meaning to the types, yet.  Like there's no operations that actually do the product; just semantically it is a product.
21:30:38 <bss03> edwardk: Probably is needlessly messy.
21:30:49 <bss03> edwardk: Might just simplify for a while.
21:31:58 <bss03> edwardk: All 3 values are really (Fixed E8) in the JSON.  Probably will just parse them as either Double or Rational for a bit.
21:45:47 <t0rus> apples: are you therd
22:04:01 <zol> In LYAH, they're writing a take' function, why give the type take' :: (Num i, Ord i) => i -> [a] -> [a] and not just take' :: int -> [a] -> [a] ?
22:10:47 <darkf> zol: so that it can take any kind of number instead of just the Int type. presumably they use Ord because they have something like "n > 0"?
22:14:57 <Ghoul_> take' 3.1415 [1..5] -- would be possible there
22:34:53 <bss03> ...
22:34:57 <bss03> > read "
22:34:58 <lambdabot>   <hint>:1:7:
22:34:58 <lambdabot>      lexical error in string/character literal at end of input
22:35:04 <bss03> > read "1.2345" :: Rational
22:35:05 <lambdabot>   *Exception: Prelude.read: no parse
22:35:17 <bss03> How do I read "1.2345" (e.g.) as a Rational?
22:35:23 <bss03> s/read/parse/
22:36:05 <bss03> I know ghc can do it internally. :(
22:36:11 <bss03> >1.2345 :: Rational
22:36:12 <zol> darkf: Ghoul_: Thanks
22:36:16 <bss03> > 1.2345 :: Rational
22:36:17 <lambdabot>   2469 % 2000
22:37:06 <pavonia> > toRational (read "1.2345" :: Double)
22:37:07 <lambdabot>   5559693739988877 % 4503599627370496
22:37:21 <pavonia> > toRational (read "1.2345" :: CReal)
22:37:23 <lambdabot>   *Exception: CReal.toRational
22:37:28 <bss03> :( See why I don't want to go through Double. :(
22:37:59 <pavonia> > read "1.2345" :: CReal
22:38:00 <lambdabot>   1.2345
22:38:14 <pavonia> I think CReal has a better conversion function
22:39:12 <bss03> > readSigned readFloat "1.2345" :: [(Rational, a)]
22:39:13 <lambdabot>   Couldn't match type `a1' with `[GHC.Types.Char]'
22:39:13 <lambdabot>    `a1' is a rigid type va...
22:39:19 <bss03> > readSigned readFloat "1.2345" :: [(Rational, String)]
22:39:20 <lambdabot>   [(2469 % 2000,"")]
22:40:46 <pavonia> > approxRational (read "1.2345" :: Double) (1/1e9)   -- <-- that's what I actually meant
22:40:47 <lambdabot>   2469 % 2000
22:52:28 <jle`> just noticed that there was a bind operator hidden in the haskell logo
22:57:29 <mdxbhmt> hey, is it tricky to get a newer version of cabal-install via cabal-install on manjaro/archlinux? I know little to nothing on linux and I'm not sure where to start.
22:58:56 <zol> Ehr.. Isn't currying very inefficient?
22:59:18 <simpson> zol: No; why?
23:00:43 <zol> simpson: multThree :: Int -> Int -> Int -> Int; multThree x y z = x * y * z; Returning three? functions when calculating (multThree 3 5 9) seems redundant, why not just eval x*y*z directly? I think I am missing something..
23:01:02 <simpson> zol: "seems"
23:01:32 <zol> simpson: I guess you are right. :)
23:02:05 <simpson> zol: Maybe your compiler noticed how you applied the function.
23:02:16 <jle`> in any case, the elegant theoretic/mathematic structures/abstractions aren't always correlated with the actual bytecode that is compiled
23:02:19 <simpson> And it's possible to have runtimes that are optimized for this sort of system.
23:02:31 <jle`> haskell is a language, not an implementation.
23:03:50 <jle`> it's powerful to be able to deal with abstractions like this that lead to expressive code, and be able to think about them abstractly without tying it down to commpilers and implementations and real-world worries
23:04:09 <jle`> of course you can't completely ignore it, but ... try to think of the language as just a way of structuring ideas
23:04:19 <jle`> not a way of structuring instructions to a computer
23:06:18 <jle`> in fact depending on your compiler your actual compiled computer-instructions can vary wildly.
23:10:08 <zol> jle`: thank you :)
23:11:03 <zol> http://hastebin.com/qigisiyeya.haskell -- is this roughly what's going on behind the scenes, "pseudo code"? tmp1 and tmp2 are the curry functions and result the final value.
23:14:48 <bss03> zol: You can think of it that way, I guess.  But, if you call multThree with 3 arguments in your program GHC (at least) will only generate 1 ( or 0) thunk(s), not 3 or more.
23:14:58 <carter> ReinH: edwardk  what typoes did I do this time?
23:15:13 <jle`> zol: it's a bit of a messy way to put it ... i would write it using anonymous functions as multThree = (\x -> (\y -> (\z -> x * y * z) ) ), so multThree 3 would return (\y -> (\z -> 3 * y * z) ), multThree 3 5 would return (\z -> 3 * 5 * z).  you just gave them names.  but to elaborate on my point earlier, you can think of the "idea" of the language as doing that.  As multThree 3 returning a function.
23:15:14 <carter> i'm great at typoes :)
23:15:16 <jle`> Theoretically you can think of things that way, and that's how you will be understanding/writing/manipulating the code.  but it doesn't necessarily mean that that's what is actually happening "under the hood", the compiler doesn't care about your understanding etc.
23:15:16 <edwardk> carter: you're, your, etc.
23:15:27 <edwardk> it hurt to read =)
23:15:32 <carter> edwardk: ahhh. I was a bit super tired this afternoon evening
23:15:53 <edwardk> hence why i was mentioning it, since your tweets will be immortalized and your grammar held against you forever =)
23:15:58 <bss03> "multThree :: Int -> Int -> Int -> Int" is the same as "multThree :: Int -> (Int -> (Int -> Int))"
23:16:14 <zol> jle`: Yeah, I just continued reading on in LYAH and they just explained the same thing you did. I feel much more confident on the concept now. Thanks!
23:16:22 <edwardk> carter: I posted video from the Cache-Oblivious Map talk http://youtu.be/P3pLDpbzqCw
23:16:34 * zol nodnods at bss03.
23:16:36 <carter> sweeet!
23:16:40 <jle`> zol: np :)  hope i didn't come off as too patronizing actually, now that i re-read
23:16:41 <bss03> "multThree x y z = x * y * z" is the same as "multThree = \x -> \y -> \z -> x * y * z"
23:16:48 <carter> edwardk: ohhh, i see the tweet in question
23:17:00 <carter> bss03: yes, in terms of the meaning of the program those are the same
23:17:11 <carter> i don't talk about implementation details though
23:17:16 <bss03> But, then the GHC optimizer gets to take a swing at the code!
23:17:23 <zol> jle`: No, you did not. :)
23:17:32 <carter> bss03: yup, the latter gets inlined much more easily :)
23:18:06 <carter> edwardk: are the slides enough
23:18:09 <carter> eh
23:18:12 <carter> i should do both i guess
23:18:16 <jle`> here are some neat currying tricks that everyone gets shown at first.  inc x = x + 1.  but you can also write inc = (+) 1
23:18:22 <jle`> also double = (*) 2
23:18:29 <edwardk> carter: 40 slides, 1:30 minute of talk. you judge =)
23:18:37 <carter> yeah
23:18:54 <jle`> > let double = (*) 2 in double 8
23:18:55 <lambdabot>   16
23:19:12 <bss03> (+) 1 == \x -> 1 + x; (+) 1 =/= \x -> x + 1
23:19:21 <bss03> (For non-commutative (+))
23:19:38 <jle`> bss03: thanks :P
23:20:13 <carter> edwardk: keynote or pandoc made these slides?
23:20:17 <edwardk> keynote
23:20:29 <jle`> > let incr = (+) 1 in incr (incr 2)
23:20:30 <lambdabot>   4
23:21:02 <edwardk> not sure how much got eaten by the loss of transitions translating to pdf
23:21:17 <jle`> > map ((<) 3) [1,8,3,7,2]
23:21:18 <lambdabot>   [False,True,False,True,False]
23:21:54 <bss03> If I have a record type were all the fields are Monoids, isn't there a "slick" / applicative way to write the Monoid instance for the record?
23:22:20 <zol> jle`: Cool, thanks :)
23:22:32 <bss03> I tried "mappend = Baz <$> mappend <*> mappend <*> mappend <*> mappend <*> mappend", but that's clearly wrong. :(
23:23:32 <carter> edwardk: the relative speedup / slow down plots are a bit confusing!
23:23:52 <zol> Is it better style to write.. compareWithHundred = compare 100 than the superfluous compareWithHundred x = compare 100 x ?
23:24:19 <edwardk> carter: yeah. couldn't plot very well in keynote, it was the best i could do. i tried log scale first, but it didn't work consistently for all plots, etc.
23:24:43 <bss03> zol: I like prefer pointfree style as long as it isn't abused.
23:24:53 <carter> so 2x here mean "2x faster"
23:25:05 <carter> so we're still at the faster inserts
23:25:07 <carter> slower lookups?
23:25:13 <bss03> zol: I'm pretty sure the optimizer treats them differently, too.  But, I can't remember which one is better.
23:25:33 <bss03> zol: I think pointfree (the version without mentioning "x") gets more aggressively inlined.
23:25:44 <carter> bss03: lambdas on the right hand side are easier to inline
23:26:00 <zol> bss03: sweet, will try to keep that in mind, thanks!
23:26:02 <carter> you can't inline a right hand side unless the args on the left hand are saturated
23:26:16 <zol> carter: saturated?
23:26:26 <carter> "f a b = Blah"
23:26:26 <bss03> carter: So, yeah, pointfree is better than pointful. At least for inlining.
23:26:32 <carter> bss03: not quite
23:26:39 <carter> defining something point free is good
23:26:47 <carter> for inlining
23:26:55 <bss03> zol: IT means you aren't partially appliying the function.  You've provided an argument of everything that it gives a local name to.
23:27:04 <carter> i can't inline f x = blah
23:27:11 <carter> unless its  f thingy
23:27:32 <carter> bss03: so only if everyting is defined point free is pointfree good for inlining
23:27:42 <carter> point free is also hard to understand if you're not careful style wise
23:28:07 * zol nodnods.
23:28:25 <bss03> carter: If you have to use "dup" or "id" or one of the arroes operators to do you pointfree stuff, it's way harder to read. :(
23:28:56 <carter> bss03: you mean ifyou're writing circuits using pointfree style it looks like textual circuits :)
23:29:10 <bss03> carter: I only point-free stuff that's pretty easy to understand, just a chain of (.)
23:29:33 <carter> cool
23:29:53 <bss03> carter: Yeah, ugh, pointfree circuits is... a big bag of NOPE.
23:30:01 <carter> good :)
23:39:56 <jle`> pointfree style can be a pretty nice expressive tool if used properly.  and an awful one if abused.  but compareWithHundred = compare 100 is nice, because it says "compareWithHundred just means compare 100"
23:40:13 <carter> yeah
23:40:17 <carter> but thats not really point free
23:40:23 <carter> well
23:40:23 <carter> it is
23:40:27 <carter> but it isnt
23:40:38 <jle`> hm
23:40:46 <jle`> i guess i am really talking about eta reduction
23:40:52 <carter> yup :)
23:41:02 <carter> lens is the pointless style :)
23:41:12 <carter> its not quite point free :)
23:49:37 <joelteon> is there a good way to package a bunch of cabal packages for installation from apt?
23:50:07 <carter> joelteon: cabal install :)
23:50:15 <joelteon> ok
23:50:19 <carter> i'm not helping
23:50:20 <joelteon> but cabal install takes about 85 minutes
23:50:20 <carter> ignore me
23:50:22 <joelteon> is apt faster
23:50:24 <bss03> joelteon: cabal-debian will take a cabalized package and generate some kind of deb
23:50:35 <joelteon> ok
23:50:36 <carter> joelteon: what version of cabal do you have
23:50:39 <carter> "cabal --version"
23:50:42 <carter> if its < 1.18
23:50:47 <carter> you're missing out on parallel builds
23:50:57 <bss03> joelteon: The deb isn't really Debian quality, but it is something you can throw in a local APT repo or PPA.
23:50:58 <joelteon> travis is, i'm sure
23:51:05 <joelteon> yeah i just need a ppa
23:51:16 <joelteon> because travis is killing my site build when it's 60% done
23:51:24 <carter> joelteon: urk
23:54:45 <bss03> What's the ghci option for defered type errors?
23:55:02 <carter> :set -XDeferedTypedErrors?
