00:01:31 <sopvop> It seems it generates queries not suitable for mysql
00:01:42 <sopvop> postgres optimizer is much better
00:13:54 <mm_freak> sopvop: "not suitable" as in "wrong" or "inefficient"?
00:24:07 <xeno> I cannot see why this doesn't work:  http://pastie.org/8442027
00:24:39 <xeno> It seems to be related to the fact that it is a function returning a float next to a value that is an int.
00:25:07 <xeno> But I try feeding them in a simple statement in ghci, and it works fine with identifier values alone.
00:25:22 <sopvop> mm_freak: inefficient, mysql can't lift sub queries from "FROM" clause like postgres can
00:25:34 <xeno> So, I seem to be constructing one of my functions badly but I don't see how.
00:27:45 <mm_freak> xeno: "doesn't work" is not exactly useful
00:28:14 <mm_freak> also you should use lpaste.net for haskell pastes
00:28:21 <mm_freak> gives you syntax highlighting and some other options
00:29:29 <johnw> is there a way to get "cabal test" to simply run tests without relinking all executables in the project?
00:29:45 <xeno> Sorry, here is a better pastie:  http://pastie.org/8442037
00:30:01 <xeno> ...
00:30:44 * hackagebot ua-parser 0.3 - Port of ua-parser in Haskell  http://hackage.haskell.org/package/ua-parser-0.3 (OzgunAtaman)
00:30:45 <mm_freak> johnw: that's what it does for me
00:31:19 <xeno> Here's the lpaste.net:  http://lpaste.net/94986
00:31:28 <mm_freak> xeno: both of those are Floats
00:31:46 <mm_freak> xeno: you should really write type signatures for your functions
00:32:12 <mm_freak> fx :: X -> Float
00:32:15 <mm_freak> fx x = 9*x
00:32:31 <mm_freak> replace the X by what you think the argument's type should be
00:32:45 <Draconis> just started learning haskell here... question if I do a simple recursion like   sumOf xs = if null xs then 0 else head xs + sumOf (tail xs)  why do I need the parenthesis at the (tail xs) ?
00:33:10 <mm_freak> Draconis: sumOf tail xs = (sumOf tail) xs
00:34:04 <mm_freak> Draconis: also you should use pattern-matching instead of if-then-else with partial (aka unsafe) functions
00:34:11 <Draconis> ah so it has no way to know that tail is another function that requires an input
00:34:26 <srh_> yeah parsing has nothing to do with type signatures
00:34:29 <Draconis> mm_freak, ok just literally installed the repl and messing around with basic structures
00:34:38 <xeno> Ok.
00:34:47 <mm_freak> Draconis: it does know that tail is a function and that sumOf does not want a function as its argument
00:35:04 <Draconis> mm_freak, got it that makes sense
00:35:13 <Draconis> so essentially its a type error
00:35:17 <mm_freak> yeah
00:35:35 <Draconis> which now looking at the error tells me explicitly heh
00:36:00 <mm_freak> i'd expect the error message to be an instance error =)
00:36:08 <mm_freak> missing Num instance probably
00:36:19 <mm_freak> unless you've written an explicit type signature for sumOf
00:36:30 <Draconis> Couldn't match expected type `[t0 -> t1]'
00:36:32 <Draconis> no
00:36:52 <mm_freak> are you using GHCi?
00:38:15 <Draconis> sublime text 2 repl but yeah
00:39:35 <mm_freak> Draconis: you should still use pattern-matching
00:39:44 <mm_freak> sumOf [] = 0; sumOf (x:xs) = x + sumOf xs
00:40:25 <Draconis> yes moving forward I'll use pattern matching
00:40:32 <Draconis> like I said just learning syntax at the moment
00:40:41 <Draconis> havent even gotten that far to pattern match yet
00:41:28 <mm_freak> Draconis: well, the first challenge when learning haskell is not to use if-then-else =)
00:55:31 <zol> Hm.. How come "and' :: [Bool] -> Bool; and' xs = foldr (&&) True xs" works with "and' (repeat False)" ? It folds from the right, so the infinite list will never reach its end. Is GHC smart enough to figure out that the whole list will contain False elements or how does this work?
00:57:09 <Ralith> > foldr f [x,y,z]
00:57:10 <lambdabot>   Could not deduce (Debug.SimpleReflect.Expr.FromExpr
00:57:10 <lambdabot>                      [D...
00:57:21 <Ralith> oh right
00:57:59 <enthropy> @src (&&)
00:57:59 <lambdabot> True  && x = x
00:57:59 <lambdabot> False && _ = False
00:58:22 <enthropy> once you get a False, it doesn't have to evaluate any more of the list
00:58:57 <enthropy> > foldr f True [x,y,z]
00:58:58 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr GHC.Types.Bool)
00:58:59 <lambdabot>    arisi...
00:59:04 <enthropy> > foldr f z [x,y,z]
00:59:05 <lambdabot>   f x (f y (f z z))
01:01:10 <mm_freak> zol: foldr does not "fold from the right"
01:01:19 <mm_freak> zol: folds are always left-to-right
01:02:09 <mm_freak> foldr (&&) True (False:xs) = False && foldr (&&) True xs
01:02:15 <mm_freak> False && _ = False
01:04:41 <Draconis> holy mother of god list comprehensions
01:04:44 <Draconis> I recognize those
01:05:14 <Draconis> do I take it this means people don't use map and filter as much?
01:05:39 <mm_freak> Draconis: actually it's the other way around
01:05:55 <mm_freak> list comprehensions are "closed" in that they don't compose
01:06:33 <amalloy> also haskell's excellent support for lambdas makes it comparatively easy to use map, filter, and so on
01:08:04 <Draconis> ah, I remember in python they basically said use list comprehensions and stick away from map etc
01:08:12 <Draconis> I know python and fp are far apart but heh
01:08:34 <mm_freak> Draconis: i think that's less of a practical thing
01:08:47 <mm_freak> even in python i'd use HOFs rather than list comprehensions
01:09:24 <mm_freak> but of course "map(lambda x: x**2, xs)" is not as nice as "map (^2) xs"
01:09:25 <zol> mm_freak: http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:foldr ?
01:09:25 <mm_freak> =)
01:09:30 <Draconis> yeah. Seems to be frowned upon or not pythonic though :)
01:09:59 <Draconis> true
01:10:19 <mm_freak> zol: i didn't actually notice that the API documentation of foldr is that bad =)
01:13:35 <Draconis> so basically its map (^2) xs or   [x^2 | x <- xs] correct?
01:13:43 <mm_freak> yeah
01:13:52 <mm_freak> what was that python guru's name who makes propaganda against functional programming?
01:14:04 <Draconis> the language creator?
01:14:12 <Draconis> heh he doesn't seem to like that many fp concepts
01:14:17 <Draconis> besides first class functions
01:14:33 <Draconis> recursion being a big pet peeve of his
01:14:49 <Draconis> Guido van Rossum
01:14:56 <mm_freak> yeah, him…  he even wanted to remove map/filter/reduce
01:14:59 <VonDraco> What does "=>" mean?
01:15:06 <zol> mm_freak: Ah, now I understand why it's called "from right to left", it's just a matter of how the recursive call is made, right?
01:15:11 <jle`> VonDraco: it specifies a typeclass constraint
01:15:27 <VonDraco> oh, okay. got it
01:15:31 <jle`> VonDraco: (Eq a) => a means "any type a that is an instance of Eq"
01:15:34 <zomg> I kinda get why someone would dislike recursion
01:15:37 <mm_freak> zol: it's about associativity…  foldr applies the function right-associatively
01:15:41 <zomg> It is one of the concepts that can be difficult to understand at first
01:15:51 <jle`> to be fair i don't know many functional programmers who are a fan of explicit recursion
01:16:00 <amalloy> Draconis: i don't think many would write it this way, but another option would be: do {x <- xs; return (x^2)}
01:16:01 <mm_freak> zomg: for imperative programmers
01:16:07 <mm_freak> zomg: unlike loops recursion is something natural
01:16:17 <zomg> mm_freak: it's not natural if you've never seen it before
01:16:22 <zomg> same as loops :P
01:16:27 <mm_freak> zomg: not true
01:16:52 <Draconis> amalloy, yeah I guess that would depend on readability. That way does have some advantages since its more human friendly than mathematics syntax
01:17:02 <zomg> It doesn't really matter if you're a functional programmer or an imperative programmer
01:17:06 <zomg> if you've never seen recursion before
01:17:11 <mm_freak> zomg: i've taught haskell to non-programmers…  the usual response to recursion is:  "ah, of course!"
01:17:11 <zomg> it doesn't make it any easier =)
01:17:40 <zomg> most imperative background people I've talked to about recursion don't find it that hard either
01:18:00 <Draconis> its their for loop ;)
01:18:17 <mm_freak> zomg: what is not natural is recursion-abused-as-a-loop-substitute
01:18:25 <mm_freak> fib x = fib (x - 1) + fib (x - 2)
01:18:27 <mm_freak> that's not natural
01:18:31 <zomg> ya
01:18:46 <mm_freak> fibs x y = x : fibs y (x + y)
01:19:00 <mm_freak> this one (coupled with the corresponding consumer) is much more natural
01:19:21 <amalloy> Draconis: really the way i wrote it there is quite bad - it's just a very long-winded way of replacing (map) with a monadic thingy. the only real benefit is that it would "work" on Just 5 as well as on [1,2,3]
01:19:36 <mm_freak> usually when introducing haskell to non-programmers i don't say a word about laziness or any other buzzwords
01:19:42 <mm_freak> laziness is just as natural
01:20:02 <Draconis> amalloy, ok. Not sure yet as I'm just learning
01:20:26 <amalloy> sometimes i just can't help but introduce confusing irrelevancies
01:23:11 <mm_freak> Draconis: what amalloy tried to get across is:  "i think the type of 'map' is too constrained"
01:23:14 <mm_freak> =)
01:24:07 <Draconis> :)
01:27:00 <apo> http://p.0au.de/6932cea9/ <- well, I guess that's why they're called partially ordered... :P
01:28:11 <zol> mm_freak: I don't exactly follow what you meant with right-associativity, would you mind elaborating, please?
01:28:59 <mm_freak> zol: left-associative application:  ((a + b) + c) + d
01:29:07 <mm_freak> zol: right-associative application:  a + (b + (c + d))
01:30:06 <mm_freak> for an associative function like (&&) the result will be the same except when infinity enters the stage
01:30:30 <zol> mm_freak: Ah! And you specify which type you want depending on whether you perform the recursive all on the left side or on the right side of the current (broken down) problem you are trying to solve?
01:30:41 <zol> recursive call*
01:31:15 <identity> I can see that Haskell is being used for a programming course(programming languages) in my school. The teacher seems to be using Hugs -- why would he use hugs, as opposed to ghc? I mean, is there any .. real reason to use hugs? Less complex, or something?
01:31:18 <mm_freak> zol: you never fold from the right, and the recursive call always uses the head and recurses on the tail
01:31:38 <mm_freak> foldr f z (x:xs) = f x (foldr f z xs)
01:31:50 <mm_freak> foldl f z (x:xs) = foldl f (f z x) xs
01:31:54 <mm_freak> that's the difference
01:32:11 <zol> mm_freak: Yes, that is what I meant, ill phrased..! Thank you :)
01:32:34 <chrisdone> identity: familiarity and easy setup, i expect. hugs is lightweight, like 1.1mb in size, few dependencies
01:32:36 <mm_freak> identity: hugs is probably a lot more lightweight, but unless you're working on very old hardware there is really no reason to use hugs
01:33:19 <identity> I see.
01:33:36 <identity> I hope he switches before I have to take that course
01:33:40 <mm_freak> zol: it's always helpful to think in terms of pattern-matching, or in other words:  what answer do you get when you ask for something
01:34:03 <mm_freak> zol: example:  what's the result of head (repeat 5)?
01:34:12 <Draconis> 5?
01:34:17 <mm_freak> yeah
01:34:21 <mm_freak> head (repeat 5) = head (5 : repeat 5)
01:34:24 <Draconis> heh
01:34:27 <mm_freak> and head (x:_) = x
01:34:36 <DarkUnicorn> mm_freak: but doesn't the recursion of foldr mean that it "folds from the right" because it starts when it reaches the end of the list?
01:34:40 <mm_freak> so head (5 : repeat 5) = head (5 : _) = 5
01:34:56 <mm_freak> DarkUnicorn: not at all
01:35:27 <mm_freak> DarkUnicorn: foldr in particular allows you to examine the left-most part of whatever you generate without performing the entire fold
01:36:04 <zol> DarkUnicorn: It will iterate the list from the left, but it will evaluate from the right, or am I wrong here, mm_freak ?
01:36:13 <ion> > foldr const undefined [42..]
01:36:14 <mm_freak> zol: yes
01:36:14 <lambdabot>   42
01:36:29 <mm_freak> zol: i mean, yes, you're wrong =)
01:36:58 <mm_freak> both iteration and evaluation have to be left-biased
01:37:04 <ion> foldr const undefined (x:xs) = const x (foldr const undefined xs) = x
01:37:50 <zol> mm_freak: Figured. :) I thought for example, that foldr (+) 0 [1,2,3] would be expanded to (1 + (2 + (3 + 0))) ?
01:37:55 <mm_freak> zol: you seem to interpret some kind of "direction" in the term "right-associative"
01:38:04 <mm_freak> zol: everything is left-to-right…  really, everything!
01:38:28 <mm_freak> zol: indeed
01:38:41 <ion> zol: Are you sure that’s what foldr (+) 0 [1,2,3] expands to?
01:38:50 <zol> mm_freak: Doesn't parentheses have higher precedence than + ?
01:39:02 <mm_freak> zol: parentheses have no precedence =)
01:39:04 <sopvop> is this haddock message? We do not support associated types in instances yet. These instances are affected: ...
01:39:04 <ion> Uh, sorry. Don’t mind me.
01:39:17 <mm_freak> zol: here is an interesting example:
01:39:23 <mm_freak> :t foldr (<|>) empty
01:39:24 <lambdabot> Alternative f => [f a] -> f a
01:39:34 <mm_freak> set f = Maybe for example
01:39:38 <mm_freak> it finds the first Just
01:39:54 <mm_freak> > foldr (<|>) empty [Nothing, Nothing, Nothing, Just 3, Just 4]
01:39:56 <lambdabot>   Just 3
01:40:07 <zol> mm_freak: Sorry, you are above me now, I have no idea what that lambda would do..
01:40:08 <ion> > foldr (<|>) empty [Nothing, Nothing, Nothing, Just 3, error "oh no"]
01:40:09 <lambdabot>   Just 3
01:40:20 <mm_freak> you would not want to use foldl here
01:40:38 <mm_freak> read "x <|> y" as:  the program that tries the subprogram x and on failure tries the subprogram y
01:40:40 <sopvop> yes it was a haddock
01:41:08 <mm_freak> the reason why you wouldn't want to use foldl:  there is no reason to know the rest of the program, if the first subprogram already succeeds
01:41:53 <mm_freak_> i died
01:42:00 <mm_freak_> the reason why you wouldn't want to use foldl:  there is no reason to know the rest of the program, if the first subprogram already succeeds
01:42:06 <mm_freak_> foldr (<|>) empty (x:xs) = x <|> foldr (<|>) empty xs
01:42:20 <mm_freak_> if x succeeds, then the right-hand-side is irrelevant, so it becomes:  x <|> UNIMPORTANT_STUFF
01:42:22 <DarkUnicorn> mm_freak_: isn't the documentation on foldr a bit misleading then? "foldr, applied to a binary operator, a starting value (typically the right-identity of the operator), and a list, reduces the list using the binary operator, from right to left"
01:42:26 <mm_freak_> and UNIMPORTANT_STUFF is not even evaluated
01:42:39 <mm_freak_> DarkUnicorn: indeed
01:45:08 <zol> mm_freak_: Thank you! I will chew on this while I continue my studies. :)
01:45:19 <DarkUnicorn> mm_freak_: thanks for explaining that :)
02:00:50 <jeeger> Hey! I have a parsec question: I am trying to parse a little toy language, and I'm trying to parse boolean expressions. A boolean expression consists of either logical operators  (and, or, not) with more boolean expressions, or relational operators with expressions (something like "e1 < e2 and a3 >= e4"). My current try is here (abridged): http://lpaste.net/94987, but of course chainl1 needs a function a -> a -> a, while I need
02:00:50 <jeeger> something like Expr -> Expr -> BooleanExpr. How can I do that?
02:04:08 <srh_> jeeger: i'm not sure that would quite work anyway, how does it handle difference precedence levels of And/Or versus comparison operators?
02:04:53 <srh_> oh okay I guess I assumed the wrong thing in the "..."
02:05:11 <yitz> jeeger: i think you want the type of relExpr to be Parser Expr
02:05:26 <srh_> but it shouldn't make sense to use chainl1 anyway, because what is x < y > z supposed to mean?
02:05:36 <srh_> Maybe that can parse, I guess :/
02:05:40 <yitz> jeeger: and you haven't told us what can go on either side of a comparison operator
02:06:18 <jeeger> yitz: Hm? Isn't the data type specifying that an expression needs to go to each side of any relational operator?
02:06:42 <yitz> jeeger: ah i see ok
02:07:16 <srh_> you'd need to tell it something about how to create an Expr value out of a BoolExpr
02:07:22 <jeeger> srh_: Nah, I wouldn't want that to parse. Right, I need to parse only one "level", but I need to parse the infix operator first to decide on the type of node I return. But I don't know how to do that.
02:07:27 <srh_> you need that if you want to put a BoolExpr inside of an Expr
02:07:42 <jeeger> srh_: Expressions can't contain boolean expressions
02:07:43 <srh_> so using chainl1 is completely the wrong thing
02:09:02 <jeeger> Ah okay, thanks!
02:09:51 <srh_> you'll probably end up with something that looks like    do { left <- expression; op <- relExpr'; right <- expression; return (op left right); }
02:09:53 <yitz> jeeger: does your grammar allow parens?
02:09:53 <jeeger> What I wanted to do instinctively is parse the expression on the left side and the right side, and then return a BoolExpr based on what type of operator we parsed. (that would save some backtracking). But I don't know how to do that.
02:10:52 <jeeger> srh_: Thank you, of course. relExpr' would then be something like (reservedOp "<" >> return (Less)), and that would work
02:10:53 <yitz> jeeger: in parsec, you do backtracking by having a list of alternatives each wrapped in try
02:12:09 <jeeger> yitz: Yeah, but if I'd use do { try(e1 <- expression); reservedOp(<)... }, that would lead to obscene amounts of backtracking, right?
02:13:08 <jeeger> I just got it to compile, I think I can soldier on from here! Thanks for your help!
02:16:06 <yitz> jeeger: great! gl
02:16:52 <yitz> jeeger: never mind the amount of backtracking to begin with. just get your grammar well defined so that it compiles and works. then refactor the grammar to reduce backtracking.
02:18:24 <yitz> jeeger: i think it's probably a mistake to have all of the comparison ops as constructors of BooleanExpr
02:18:34 <yitz> oops. jeeger's gone.
02:19:38 <yitz> anyway, i would have those as constructors of Expr
02:42:03 <Reite> Whats a good datastructure to use if I have a large set of Integers and want to find all values within some bounds? I need to do many lookups so it should be fast.
02:43:02 <dobblego> discrete interval encoding tree
02:48:57 <Reite> dobblego: Thanks, there already seems to be a haskell implementation: http://hackage.haskell.org/package/diet-0.0.1/docs/Data-Set-Diet.html , but there doesnt seem to be any function for doing lookups. Am I missing something or is the implementation lacking?
02:57:50 <mm_freak_> Reite: generate-once, query-often?
02:58:11 <mm_freak_> i.e. generate-once, never-change?
02:58:33 <Reite> yes
02:59:34 <mm_freak_> Reite: for a general purpose data structure with updates i have used IntervalMap a few times…  for the never-change special case i recommend using a sorted Vector
02:59:53 <mm_freak_> the quickset library does the latter, but it has no interval querying
03:00:21 <mm_freak_> @hackage quickset
03:00:21 <lambdabot> http://hackage.haskell.org/package/quickset
03:03:48 <Reite> mm_freak_: Thanks I will take a look at them
03:10:52 * hackagebot fclabels 2.0.0.1 - First class accessor labels implemented as lenses.  http://hackage.haskell.org/package/fclabels-2.0.0.1 (ErikHesselink)
03:22:52 <eevar_> which is more idiomatic: a <- foo; b <- bar a vs b <- foo >>= bar
03:23:05 <ocharles> eevar_: I prefer foo >>= bar
03:23:46 <ocharles> \o/ my uu-parsinglib version of my SQL parser passes all the same tests as my happy+alex version
03:24:28 <ocharles> it's about 50% of the size too
03:25:45 <Peaker> I prefer =<< to >>= in one-liners (same direction as (.), ($) and ordinary application)
03:26:12 <Peaker> though I've come to prefer >>= when combining with & and <&> since they all have the same fixity which makes things nice
03:26:17 <zol> Do people often write stuff like map ($ 3) [(4+), (*10), (^2), sqrt] ?
03:26:26 <Peaker> zol: no :)
03:26:55 * zol wipes his eyebrows while going "Phew!".
03:27:01 <ocharles> sure, i've written that
03:27:26 <zol> ocharles: I just realized that it is actually kind of useful, if you want to make physics tables for instance!
03:27:33 <ocharles> Peaker: I'm on the fence with =<<. yes, it's like (.), but it hides the ordering of effects
03:27:45 <ocharles> that can be important
03:28:40 <Peaker> ocharles: it doesn't "hide it", it just synchronizes it with the data flow direction
03:30:41 <arkeet> > [(4+), (*10), (^2), sqrt] ?? 3
03:30:43 <lambdabot>   [7.0,30.0,9.0,1.7320508075688772]
03:32:39 <quchen> Types can't be infinite, can they? In particular, can a free monad be infinitely long?
03:32:49 <arkeet> what?
03:33:10 <arkeet> what does it mean for a free monad to be "long"
03:33:35 <bartavelle> ocharles, is your alex+happy version somewhere public ?
03:33:43 <quchen> If you look at Free as a type-level list, then "Pure a" has length 1, "Roll (f (Pure a))" has length 2, etc.
03:33:56 <arkeet> Free is not a type-level list.
03:34:03 <arkeet> Pure and Roll are values.
03:34:27 <quchen> That's what the quotation marks were supposed to cloud :-)
03:34:41 <arkeet> your quotation marks are not making sense.
03:35:30 <arkeet> there is no more problem in having infinite values in Free f a then there is in having infinite lists.
03:35:31 <quchen> Maybe if I ask another way: Does every value of type `Free f a` involve a `Pure` data constructor
03:35:36 <arkeet> no
03:36:23 <arkeet> if you had some foo :: f (Free f a) -> Free f a
03:36:30 <arkeet> then fix (foo . Free) is a perfectly good value.
03:37:09 <arkeet> also, consider what  forever (...)  looks like in that monad
03:37:12 <FireFly> @ty (??)
03:37:13 <lambdabot> Functor f => f (a -> b) -> a -> f b
03:37:31 <quchen> Hm. But then how does `m >>= return = m` work out? It translates to `Roll x >>= Pure = Roll ((>>= Pure) <$> x)`.
03:37:44 <FireFly> Er, what?
03:37:45 <quchen> There are two cases. For x = Pure y, the thing terminates.
03:37:56 <FireFly> @ty (<*>)
03:37:56 <quchen> for x = Roll y, the definition recurses.
03:37:57 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:38:18 <FireFly> @ty (>>=)
03:38:21 <lambdabot> Monad m => m a -> (a -> m b) -> m b
03:38:22 <quchen> And in case of an infinite chain of Rolls, I don't see how you could show that that monad law holds.
03:38:25 <FireFly> Oh, right
03:38:46 <quchen> It's an induction step without a base case.
03:39:32 <arkeet> it works for the same reason  map id  works on an infinite list.
03:40:36 <arkeet> obviously you can never test two infinite lists for equality.
03:40:56 <arkeet> but I can show you that  somelist  and  map id somelist  deconstruct the same way as deep as I want.
03:40:59 <arkeet> even if somelist is infinite.
03:41:07 <arkeet> well, which means they're the same.
03:41:09 <arkeet> same thing for Free.
03:41:21 <Saizan> iow you can prove it by coinduction
03:41:38 <quchen> Never heard of that.
03:44:09 * FireFly doesn't see how (??) could be implemented to satisfy that type..
03:44:28 <FireFly> Isn't Functor too weak to do something like that?
03:44:29 <arkeet> FireFly: think harder.
03:44:31 <arkeet> nope
03:44:35 <FireFly> Okay
03:44:38 * FireFly thinks some more
03:44:41 <arkeet> :t (??)
03:44:42 <lambdabot> Functor f => f (a -> b) -> a -> f b
03:44:59 <arkeet> given a and f (a -> b), what do I need to get f b?
03:45:26 <arkeet> the only way to make f b is to fmap something.
03:45:31 <adnap> If you want to update an element in a list by some criteria, say the least Integer, and leave the original order intact, what do you do? The first thing I thought of was to associate a ID number with each element, sort the associated elements based on the criteria, obtain the ID of the desired element, search for it in the orignal list, and update the element: http://ideone.com/brAnJB
03:45:35 <arkeet> and the only f _ we have is f (a -> b).
03:45:43 <FireFly> Hm
03:45:55 <arkeet> so you need to fmap some function of type (a -> b) -> b
03:46:01 <FireFly> so f (a -> b) what we want to fmap over
03:46:09 <FireFly> Hm
03:47:49 <arkeet> adnap: instead of associating an id number, associate a function Integer -> [Integer] that modifies the element.
03:48:08 <augustss> adnap: Seems like a reasonable idea.
03:48:30 <arkeet> this way you will avoid scanning twice
03:49:38 <adnap> arkeet: Oh, I see
03:49:44 <adnap> arkeet: I will try to write that
03:49:45 <arkeet> ;)
03:50:42 <augustss> adnap: You should also try your first idea.  Sometime the clever ways are slower than the straight forward.
03:51:20 <arkeet> try them both!
03:51:58 <adnap> augustss: I already did. I posted an ideone link with my explanation
03:52:21 <FireFly> arkeet: got it :3  thanks
03:54:13 <adnap> arkeet: By the way, I originally reasoned that scanning the list twice will not affect big-O
03:54:21 <arkeet> :r
03:54:25 <arkeet> er
03:54:41 <arkeet> adnap: it may affect big-O memory usage.
03:55:07 <arkeet> consider  average xs = sum xs / length xs
03:55:41 <arkeet> it has to traverse the list twice, so it can't gc the part of xs that's been consumed the first time.
03:55:43 <arkeet> or so
03:55:47 <arkeet> I dunno.
03:56:40 <lpaste> arkeet pasted “stuff for adnap” at http://lpaste.net/94988
03:56:50 <arkeet> heh, minimumBy
03:56:57 <adnap> arkeet: So you are arguing that memory is used for a longer time, but not that more memory is used
03:57:06 <arkeet> no
03:57:24 <arkeet> if xs is some lazy list of length 10000000
03:57:33 <arkeet> say xs = [1..10000000]
03:57:42 <arkeet> then average, as written above, will have to hold the entire list in mempry
03:57:44 <arkeet> or memory
03:58:09 <adnap> Oh, if you compute-as-you-go, you never have to do that
03:58:48 <arkeet> so the usual thing is to write it as foldl' (\~(s,l) a -> (s+a,l+1)) 0 xs
03:58:50 <arkeet> or something
03:58:54 <arkeet> er, (0,0) not 0
03:59:15 <arkeet> that's also a parse error. \ ~
03:59:52 <arkeet> in your particular example where you're looking at the minimum, this doesn't make a difference I think.
03:59:57 <arkeet> since you have to scan the whole list to find the minimum anyway.
04:00:04 <adnap> Actually, I'm not sure why the entire list has to be held in memory. Is it that the first scan fully evaluates the xs expression, and then that exists in memory until the second scan completes?
04:00:07 <arkeet> but say instead you were doing the first element smaller than 100.
04:00:10 <arkeet> yes.
04:00:39 <adnap> Why not just throw away the evaluated expression when the first scan completes and start with the unevaluated one again?
04:00:48 <arkeet> because xs is shared.
04:01:38 <arkeet> so it makes the choice to hold the list in memory rather than have to compute it again.
04:02:14 <arkeet> anyway.
04:02:18 <arkeet> I need sleep
04:03:04 <adnap> I don't know what an Arrow is
04:03:15 <arkeet> you don't need to.
04:03:19 <arkeet> I wrote the definition of first for you.
04:03:34 <adnap> Oh, I see. Thank you
04:03:50 <arkeet> (that's Control.Arrow.first specialized to (->))
04:04:20 <arkeet> (specializing to (->) is really what Control.Arrow gets used for most frequently, I think)
04:04:40 <arkeet> exercise: write updater as a fold
04:05:02 <arkeet> it doesn't seem trivial. so I'm going to bed.
04:05:43 <b1nery> Ok, so I just came to ask about building GHC on Mavericks and saw the answer linked above: "do not install xcode 5 if you are using ghc 7.6". Er - too late!
04:06:23 <b1nery> I'm trying to install the Macports version though, which uses its own installation of gcc-4.8, so Xcode5 shouldn't be causing the problem.
04:06:43 <arkeet> @let updater :: [a] -> [(a -> [a], a)]; updater [] = []; updater (x:xs) = (\x' -> x':xs, x) : fmap (first ((x:) .)) (updater xs)
04:06:44 <b1nery> I do however have this problem with package-data.mk: http://trac.macports.org/ticket/40950
04:06:45 <lambdabot>  Defined.
04:07:02 <arkeet> > map (\(f,a) -> f (a+10)) $ updater [1..4]
04:07:08 <lambdabot>   [[11,2,3,4],[1,12,3,4],[1,2,13,4],[1,2,3,14]]
04:07:14 <arkeet> cute.
04:07:23 <b1nery> So has anyone successfully built GHC 7.6 with Macports on Mavericks?
04:08:10 <arkeet> hmm.
04:08:13 <arkeet> this reminds me a lot of select.
04:08:16 <arkeet> @where select
04:08:16 <lambdabot> select [] = []; select (x:xs) = (x,xs) : (map.fmap) (x:) (select xs)
04:08:38 <arkeet> bye
04:08:53 * frerich wonders WTH to make of that mail by Roman Czyborra to Haskell-beginners
04:10:58 <augustss> Link?
04:10:59 * hackagebot fclabels 2.0.0.2 - First class accessor labels implemented as lenses.  http://hackage.haskell.org/package/fclabels-2.0.0.2 (ErikHesselink)
04:11:44 <frerich> augustss: http://www.haskell.org/pipermail/beginners/2013-October/012903.html
04:13:53 <augustss> frerich: Looks like something to ignore.
04:15:41 <frerich> I guess what I'm wondering is whether he's smoking everything by himself or whether he'd be willing to share a bit. :-}
04:16:07 <augustss> :)
04:16:49 <frerich>  I'm a bit disappointed though because I carefully read the Haskell program at http://czyborra.com/diplom/plank.hs.unifont.pdf and only noticed very late there there's not much purpose to it.
04:17:17 <frerich> It's strangely poetic somehow.
04:27:24 <dobblego> is there any way to get out of the fact that parsec uses strings for error messages?
04:31:07 <donri> dobblego: maybe with parsers, if you make your own instance for a newtype and override unexpected
04:31:25 <dobblego> donri: trying to figure it out with parsers now, but I cannot see a way to get the types to align
04:31:26 <donri> well, not sure what kind of error type you want
04:31:42 <dobblego> data Error = …
04:31:51 <donri> <?> takes a string, as does unexpected. i was thinking you could have a constructor for those
04:32:04 <donri> but maybe you want those to not be stringly typed either
04:32:23 <dobblego> right, I don't
04:34:23 <dobblego> I think I cannot use parsers if I want proper error messages
04:34:49 <donri> can errors be anything other than unexpected?
04:35:01 <dobblego> yes
04:35:06 <donri> such as?
04:35:34 <dobblego> data Error = TheCharacterAIsInvalid | TheCharacterBIsInvalid
04:37:00 <donri> those are both "unexpected"
04:37:12 <dobblego> sorry, I thought you meant the function unexpected, which takes String
04:37:38 <dobblego> essentially, I think I want instance CharParsing m => CharParsing (EitherT Error m a), which cannot exist
04:37:45 <donri> char 'a' <?> "a"
04:38:03 <dobblego> that's just back to string messages
04:40:01 <donri> well, not necessarily. you can use errorMessages to get [Messages] and you can then map those to your error type
04:41:05 <donri> it's still using strings as symbols but you can abstract that away with code generation
04:41:19 <dobblego> so I would have to parse error messages?
04:41:19 <donri> e.g. char 'a' <?> show TheCharacterAIsInvalid
04:41:34 <dobblego> yeah I could do that — looking for a way out first :)
04:41:34 <donri> map read . errorMessages
04:41:51 <dobblego> I think I would write a parse library before that
04:42:15 <dobblego> I must protest String for error messages 4 eva
04:47:23 <zq> > 5 `quot` 2
04:47:25 <lambdabot>   2
04:47:51 <dobblego> I am bummed, thanks donri
04:50:23 <elliott> dobblego: I bet edwardk would accept a patch and give you commit access :p
04:50:40 <dobblego> elliott: yeah probably — I will have to think about what is required to fix it though
04:50:56 <dobblego> perhaps change satisfy to satisfyM or something
04:53:08 <arnsholt> Does anyone know of a shuffling algorithm for trees (a generalisation of Fisher-Yates for example)?
04:54:46 <donri> dobblego: how about, add an associated type to CharParsing for the error type, maybe default it to String and make unexpected and <?> use that type
04:55:16 <dobblego> donri: you mean make CharParsing a MPTC?
04:55:23 <donri> dobblego: no, type families
04:55:29 <dobblego> ok
04:55:40 <dobblego> but can parsec implement that?
04:55:44 <donri> class CharParsing a where type Err a = String
04:56:06 <donri> doubtful.
04:56:09 <dobblego> instance CharParsing (ParsecT m) where … ?
04:56:17 <dobblego> yeah so I am still in big trouble
04:56:22 <donri> parsec would be untouched, with this String default
04:56:57 <donri> but it pave the way for error-parametric parsers. you could then patch trifecta, say.
04:57:11 <dobblego> right, I think I would have to write the parser itself first though
04:57:18 <donri> (i doubt you'll get such a breaking change accepted into parsec)
04:57:24 <dobblego> screw parsec
04:57:36 <dobblego> I am bitter, as you can see
04:58:30 <ibotty> hi!
04:58:30 <ibotty> i'd like to raise attention to a problem i have over on reddit. see http://www.reddit.com/r/haskell/comments/1pj75z/ask_reddit_noninjective_type_families/
04:58:31 <ibotty> maybe someone can help me
04:59:01 <dobblego> incidentally, why is parsec (ParsecT) implemented as  church-encoding?
04:59:06 <ibotty> in short: how to constraint a type in non-injective type families
05:00:51 <Peaker> dobblego: sometimes people do that and cite performance concerns
05:01:00 <individual> does anyone have an example of a program written with wxHaskell?
05:01:01 <Peaker> (not sure about ParsecT's case in particular)
05:01:14 <dobblego> Peaker: you mean they church-encode then state performance concerns, or regular data type then ?
05:01:37 <dobblego> they say, "I church-encoded because performance"? that is weird
05:03:03 <dobblego> actually, I guess it has to be for the transformer version like that
05:03:48 <Peaker> dobblego: supposedly they compared the performance of the ADT vs. church encoding, and chose the latter
05:03:59 <dobblego> bizzaro
05:05:04 <Peaker> the claim is that the intermediate heap structures being constructed and then case analysis disappears
05:08:19 <ghorn> ibotty: can you make a small self-contained example of the broken code?
05:08:32 <ibotty> it's in the reddit q at the bottom
05:08:34 <dobblego> donri: by your suggestion, I think I could make parsec implement it, so long as I accept Error = String
05:08:41 <ibotty> http://lpaste.net/94989
05:08:48 <ibotty> thanks for looking into it ghorn
05:08:50 <ibotty> :)
05:10:43 <ibotty> it needs http-types, http-conduits, Text and ByteString. if need be, i can reduce these dependencies, but that makes the problem more clear imo
05:11:01 <ghorn> it's ok, i got them
05:17:09 <donri> dobblego: that would be automatic with my suggestion
05:17:42 <dobblego> donri: however, client code that would then use a non-String message would nor allow parsec to be used, right?
05:17:59 <donri> dobblego: the type would be defined by the CharParsing instance
05:19:45 <dobblego> maybe I am misunderstanding, what would the type of unexpected be?
05:20:58 <donri> dobblego: uh wait actually it's the Parsing instance
05:21:05 <dobblego> donri: yeah that's fine
05:21:10 <dobblego> Parsing m => CharParsing m
05:21:15 <donri> dobblego: so, (Parsing m) => Err m -> m a
05:22:00 <dobblego> donri: ok, and suppose I use: unexpected parser nonString, how could parsec work with this?
05:22:12 <donri> so if you pass a String you get a constraint like, (Parsing m, Err m ~ String)
05:22:15 <donri> i think
05:22:23 <dobblego> unexpected :: Parsing m => m a -> Err m -> m a
05:22:33 <dobblego> yes
05:22:44 <dobblego> but if I don't, I get (Parsing m, Err m ~ NotString)
05:22:52 <donri> that's not unexpected, that's <?>, but same applies yes
05:22:57 <dobblego> and there goes parsec?
05:22:58 <donri> yep
05:23:00 <dobblego> oh yeah sorry
05:23:10 <dobblego> ok, so as long as Err m ~ String, I can use parsec
05:23:21 <lpaste> ghorn pasted “injective type families” at http://lpaste.net/94991
05:23:31 <donri> it would make it a type error to runParsec a Parsing with a different Err equality constraint
05:23:36 <ghorn> ibotty: here is a core example of the issue here
05:23:58 <dobblego> donri: ok, I was just checking I wasn't missing something, thanks
05:24:12 <ghorn> ibotty: basically, the compiler can infer what (Parameters a) is from a, but it can't infer a from (Parameters a)
05:24:26 <donri> dobblego: so yeah it doesn't magically make non-string error types work with parsec :) you'd have to add support for that in parsec, or with newtypes
05:24:40 <dobblego> donri: right, I was just being a bit hopeful :)
05:25:21 <donri> dobblego: but the idea here anyway is that it makes it possible to write a parser type that is parametric on the error type, and you can then have instance Parsing (ErrParser e) where Err (ErrParser e) = e, for example
05:25:28 <ghorn> ibotty: two difference instances could "type (Parameters a) = Int", so the compiler can't take an Int and figure out which instance it came from
05:25:41 <ibotty> ghorn: i _guess_, i understand. but that is exactly what i want. i don't want injective Parameters
05:25:42 <dobblego> donri: yep, I'd have to write a proper parser library n the end, regardless
05:25:49 <donri> dobblego: or patch trifecta
05:25:54 <dobblego> yeah or that
05:26:02 <ibotty> if i make them injective (data instead of type), it works
05:26:41 <ibotty> but i'd like to have the api (e.g.)
05:26:42 <ibotty> myUser = discogs "UserName" :: User
05:27:10 <ibotty> so i am fine with callers of `discogs` to have to specify the type
05:27:45 <elliott> donri: you could make a newtype wrapper that wrapped Parsec and allowed any Show, Read error type
05:27:48 <elliott> jussayin'
05:28:10 <donri> yep. i don't think dobblego likes that though :)
05:28:20 <dobblego> that's just more stringly-typed hackery
05:28:28 <ibotty> the discogs API (as in the web) is rest-like, so many parameters will only consist of one string. it would be nice to make the haskell api as easy to use
05:28:31 <elliott> but encapsulated!
05:29:41 <dobblego> you mean, newtype P e a = Parsec a, then to :: Show e => P e a -> Parsec a; from :: Read e => Parsec a -> P e a ?
05:29:50 <dobblego> you mean, newtype P e a = P (Parsec a), then to :: Show e => P e a -> Parsec a; from :: Read e => Parsec a -> P e a ?
05:30:07 <ghorn> ibotty: it would work if you had handleRequest :: Parameters a -> IO a, the problem is when you break it into those two functions
05:30:46 <ibotty> yes i figured that out as well. unfortunately that makes writing instances way more cumbersome.
05:31:10 <ghorn> ibotty: i had this problem before and someone gave me a workaround, but i can't find it
05:31:30 <ibotty> oh. that would be awesome indeed.
05:31:33 <lpaste> ghorn pasted “simpler question” at http://lpaste.net/94992
05:32:00 <ghorn> ibotty: in the future, asking a question with a very simple example like ^ might get you more responses
05:32:01 <ibotty> thank you for simplifying it
05:32:06 <ibotty> :D
05:32:12 <ghorn> at least in my experience :)
05:32:40 <ibotty> i'm pretty sure you are right.
05:32:42 <ibotty> :)
05:44:05 <augur> impromptu monad tutorial :X
05:44:06 <augur> http://www.reddit.com/r/programming/comments/1pj3bs/monads_and_gonads_a_google_tech_talk_presented_by/
05:50:05 <quchen> That's a very long comment.
05:57:46 <lpaste> ibotty revised “simpler question”: “solved question?” at http://lpaste.net/94992
05:58:20 <ibotty> hi ghorn, when doing the laundry i thought about the following thing
05:58:24 <ibotty> what do you think?
05:59:10 <ibotty> it is a way to get around the limitation. i'm not sure about how to name things still though
05:59:29 <ibotty> (that's the second hard problem in cs)
06:02:05 <otulp> The other hard problem being cache invalidation, and off-by-one errors, right. :)
06:02:35 <ghorn> ibotty: this doesn't work for me
06:04:06 <ibotty> yeah for me not. now i cannot write any instances anymore...
06:04:18 <ghorn> ibotty: if a is uniquely determined by Parameters a, you can use FunctionalDependencies
06:04:34 <ibotty> but it is not
06:04:42 <ibotty> (it should not)
06:04:53 <ghorn> do you need a typeclass?
06:05:45 <ibotty> it would be nice
06:06:40 <ibotty> i have different parameter types and different response types. for every response type i know the parameter type.
06:07:10 <ibotty> how can i associate them together, so that i can't write illegal things
06:07:18 <ibotty> i mean, i'd like to have the api:
06:07:29 <ibotty> user = discogs "userName" :: User
06:08:42 <ibotty> and (maybe): userCollection = discogs (exactly 5) :: [User]
06:12:13 <lpaste> ghorn pasted “cheater version” at http://lpaste.net/94994
06:12:24 <ghorn> if users can't write instances of Request, you can do this
06:12:44 <ghorn> you have to guarantee that the first argument of getRequest is never evaluated
06:13:50 <ibotty> i might do that then. thank you.
06:14:06 <ibotty> i'll have to look for asTypeOf
06:14:10 <ibotty> :t asTypeOf
06:14:11 <lambdabot> a -> a -> a
06:14:24 <ibotty> ic
06:14:26 <ibotty> :)
06:18:17 <ghorn> > 4 `asTypeOf` (undefined :: Double)
06:18:19 <lambdabot>   4.0
06:19:49 <donri> > 4 `asProxyTypeOf` (Proxy :: Proxy Double)
06:19:50 <lambdabot>   Not in scope: type constructor or class `Proxy'Not in scope: data construct...
06:19:53 <donri> :(
06:21:14 <hc> hi all
06:21:18 <ibotty> i was serious. the type (with the name) did tell me something
06:21:33 <hc> quick question about the Maybe monad: Why is the constructor called "Just"? (i'm just curious;)
06:21:52 <ibotty> hc: because it sounds great
06:21:53 <donri> hc: because you have "just" that value
06:22:08 <ibotty> i have Nothing, or Just 5
06:22:13 <donri> Maybe is like a list of zero or one element
06:22:20 <hc> i understand what maybe does
06:22:22 <donri> so it either contains Nothing or Just the one value
06:22:31 <hc> i was just wondering... is it called "Just" to confuse people? ;)
06:22:40 <donri> how is it confusing?
06:22:50 <hc> I mean if I say something like cost = Just 10000000000
06:22:50 <b_> Why not Nothing or Soma a
06:22:52 <b_> Some*
06:22:53 <augustss> I prefer Some and None.
06:22:54 <briennetheblue> what would you call it? :)
06:22:58 <fizbin> hc: I'll admit that the scala constructor name "Some" sounds slightly better.
06:23:04 <donri> some languages and literature call it data Option a = None | Some a
06:23:06 <ibotty> some sounds like plural to me
06:23:12 <donri> but yes some sounds plural to me
06:23:14 <donri> :t some
06:23:15 <lambdabot> Alternative f => f a -> f [a]
06:23:28 <bartavelle> same is ibotty
06:23:28 <bartavelle> as
06:23:30 <ghorn> donri: so THATS what a proxy is, thanks!
06:23:37 <donri> ghorn: \o/
06:23:50 <donri> ghorn: incidentally Proxy is Maybe without Just ;)
06:23:51 <briennetheblue> data Maybe a = Nothing | Merely a
06:24:07 <b_> Merely sounds weird
06:24:12 <briennetheblue> :(
06:24:14 <b_> :D
06:24:22 <augustss> data Maybe a = Nothing | A a
06:24:34 <hc> okay, thanks for the explanations. i like Just; i like a bit of confusion ;)
06:24:41 <b_> data Maybe a = Nothing | A a | An a
06:24:41 <b_> :D
06:24:46 <briennetheblue> hehe
06:24:54 <Entroacceptor> data Maybe a = Nothing | Indeed a
06:24:55 <donri> data CanHas a = Nope | Cheezburger a
06:25:02 <hc> haha
06:25:03 <ibotty> yeah
06:25:04 <augustss> I wish I could remember where Just&Nothing come from.  It might have been Ponder.
06:25:26 <donri> b_: pattern An a = A a
06:25:33 <donri> needs moar PatternSynonyms
06:25:42 <augustss> Coming soon
06:25:44 <augustss> I hope
06:25:46 <donri> in deed!
06:25:49 <b_> None | One a
06:26:06 <frerich> The C++ Boost library has std::optional (same thing as 'Maybe'), you create values of that type with 'make_optional'. Not very pretty, but I guess that's Boost for you. :-/
06:26:15 <augustss> Gergo needs to work harder (since I was too lazy to implement pattern synonyms).
06:26:22 <b_> But I've been running into this lately, there's a lot of Just-like constructors, and I sometimes wish they were all called the same
06:26:27 <b_> Of course it's not feasible
06:26:45 <ibotty> donri: Proxy cannot be used in the example by ghorn though, can it?
06:27:07 <b_> But when referring to ADT's it would be cute if it could be built from things-that-already-have-good-names
06:27:10 <b_> Void/Unit/bla
06:27:14 <fizbin> data Maybe a = Nothing | Indeed a
06:27:15 <donri> ibotty: what example?
06:27:21 <ibotty> http://lpaste.net/94994
06:27:38 <donri> type Maybe a = Either () a
06:27:44 <ibotty> sorry, i thought you were following along (nice that you chimed in anyways)
06:27:45 <b_> donri, exactly
06:27:46 <b_> :D
06:27:58 <b_> That's actually bugging me
06:28:06 <augustss> type Bool = Either () ()
06:28:31 <augustss> You can take things too far... :)
06:28:53 <t7> type Nat = \x -> Either () x
06:28:59 <danr> type Ordering = Either () (Either () ())
06:29:04 <b_> But from a couple of primitives you can build up the entire world
06:29:15 <donri> type (||) = Either; type One = (); type Bool = One || One; type Maybe a = One || a
06:29:26 <b_> yeah
06:29:28 <t7> \ means rec
06:29:55 <dobblego> type Either a b = Free (Const a) b
06:30:07 <donri> ibotty: in that example i think you can just pass in ret directly
06:30:33 <donri> infinite recursion is just another bottom :p
06:30:34 <ibotty> ah. because of lazyness
06:30:43 <ghorn> donri: you could, but a user could give themselves an infinite loop if they tried to evaluate it
06:30:53 <ibotty> that would still not be more typesafe
06:30:54 <donri> yep
06:31:02 <lpaste> ghorn pasted “using a proxy” at http://lpaste.net/94995
06:31:15 <donri> you could use ScopedTypeVariables, probably
06:32:50 <kakos> Does the <*> operator in Applicative have a name?
06:32:57 <donri> kakos: apply
06:33:02 <kakos> donri: Danke
06:33:03 <dobblego> angle bum
06:33:13 <donri> dobblego: can't unsee
06:33:51 <kakos> dobblego: I'm having strong feelings towards you, but I'm not sure whether it is hate or amusement.
06:33:53 <kakos> :-P
06:34:00 <t7> >o< goatse
06:34:38 <miasma> kakos: if you want to learn, worry less about your emotions and focus on rational thinking
06:34:57 <donri> ghorn: this proxy just moves the infinite recursion to asProxyOf though :) which is probably fine, because it's so simple and local
06:35:02 <kakos> miasma: Damn it, Spock, I'm a human being, not a green-blooded Vulcan
06:35:35 <ghorn> donri: but you can ensure it doesnt happen in that one place only, not every time you write an instance
06:35:43 <donri> yep
06:35:50 <ibotty> that's why i like this version
06:35:52 <ibotty> :D
06:35:58 <ibotty> thank you both!
06:36:10 <ibotty> now for some json parsing fun
06:36:54 <b_> is there a limit to what types you can express with just type synonyms and a couple of basic ADT's?
06:36:55 <sopvop> hey ibotty, I've answered you question on reddit
06:37:19 <ibotty> thank you sopvop, i'll have a look
06:37:24 <donri> ghorn: why not just use Parameters as your proxy
06:37:33 <b_> and if so, what are the most basic types you can do this with?
06:37:41 <b_> if so = if there is no limit
06:38:28 <ibotty> donri: it's my problem :).
06:38:34 <donri> oh
06:38:44 <ibotty> hehe. ghorn was only very kind in answering
06:38:51 <ghorn> ^^
06:40:11 <ghorn> donri: it's cause a is not uniquely determined by Parameters a, where as it is uniquely determined by Proxy a
06:40:31 <donri> ghorn: isn't it though?
06:40:39 <ibotty> no it's not
06:40:59 <ibotty> at least it shouldn't
06:41:07 <ghorn> donri: the original problem was about non-injective type families
06:41:26 <donri> ok use a data family?
06:41:54 <ibotty> well, i'd like to have non-injective type families, so that's not what i am after
06:43:43 <donri> ibotty: and ScopedTypeVariables?
06:44:33 <donri> wait no doesn't help
06:44:36 <t7> b_: i think empty, dependent product and rec together are more powerful than haskell type system with all the extensions
06:44:38 <ibotty> sopvop: finally could look at your answer. am i right that the bidirection type family means, that Parameters is injective again?
06:45:06 <ibotty> (well, whenever there is a FromParams instance)
06:45:35 <ibotty> donri: i had to read about ScopedTypeVariables first. simply enabling it did not solve it
06:46:59 <augustss> ibotty: you have to add type signatures
06:47:15 <ibotty> but where?
06:47:17 <donri> ibotty: it would only let you get rid of asTypeOf or asProxyOf, but you'd still need undefined or Proxy, i think
06:47:32 <ibotty> ah. ic
06:47:46 <donri> ibotty: you'd do discogs :: forall a. ... and then you can do (undefined :: a) or (Proxy :: Proxy a)
06:47:56 <donri> but not really a big win
06:48:07 <ibotty> ah. augustss you were also talking about ScopedTypeVariables, right? if so, i get it
06:48:15 <augustss> yes
06:48:31 <ibotty> donri: is scopedTypeVariables morally accepted?
06:48:57 <ibotty> i'll have to look for that stackoverflow answer again about the good and bad extensions
06:49:17 <ibotty> (wasn't that even your's donri? or was it dons, or some other don?)
06:49:45 <donri> not mine
06:49:57 <augustss> ScopedTypeVariables is what Haskell should have had from the start, so it's all good.
06:49:57 <donri> ScopedTypeVariables is considered a good extension
06:50:43 <sopvop> I use ScopedTypeVariables everywhere
06:50:55 <sopvop> it's a type level `let`
06:51:10 <ibotty> that sounds useful :)
06:51:17 <donri> only ever so slight gotcha to keep in mind is how it interacts with other extensions that use the forall keyword (ie. it makes them scoped as well)
06:52:16 <donri> although i'm not sure how that interacts with RankNTypes? can those even be scoped, outside the uh scope of the rank-n type, uh
06:52:27 * donri i have no idea what i'm doing
06:53:48 <augustss> There's no bad interaction with RankNTypes.  It works as expected.
06:54:05 <donri> similarly existentials are wrapped in a data constructor, so maybe there is no issue here
06:54:28 <ghorn> ibotty: it's good to know when ScopedTypeVariables is needed vs when it is just convenient but possible without it
06:54:39 <augustss> I.e., only the top level forall will bind variables in the function body.
06:55:02 <donri> only issue is with ExplicitForall which ScopedTypeVariables change the semantics of. but why would you use ExplicitForall alone anyway?
07:02:44 <derdon> > True == True == True
07:02:45 <lambdabot>   Precedence parsing error
07:02:46 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
07:02:54 <derdon> meh, that sucks
07:03:53 <mauke> no, it doesn't
07:04:07 <ocharles> It does when your operator is associative
07:05:02 <Takumo> Are there any good guides along the lines of "Haskell for /.+/ programmers"
07:05:13 <Takumo> Because I'm struggling to get to grips with the concepts... :(
07:05:52 <quchen> Since Haskell is unlike most languages, I doubt there are good guides like that.
07:06:01 <Takumo> quchen: Except maybe for lisp? :P
07:06:18 <quchen> No, it's not at all like Lisp.
07:06:27 <Takumo> But yeah, I really want to learn Haskell, but struggling to understand stuff like Data constructors and how to use them
07:07:09 <mauke> Takumo: what languages do you know?
07:07:45 <Takumo> mauke: Ruby, Python, PHP, (and most of) C C++ Java Lisp Lua JavaScript
07:07:57 <mauke> good
07:08:01 <alexander__b> OK I'm still unable to properly grok composition. how would I write "h - div (floor (magVec v)) 10" in a point-free style?
07:08:18 <mauke> Haskell 'data' is like C enum/struct/union rolled in one
07:08:37 <Takumo> mauke: I guessed that, but how would I construct an instance of a Data type?
07:08:43 <quchen> alexander__b:   f (g x) = (f . g) x
07:08:48 <Peaker> Takumo: data Foo = A Int | B String
07:08:49 <quchen> Use that, repeatedly.
07:08:53 <mauke> Takumo: by using one of its constructors
07:09:03 <Peaker> Takumo: "A 5" constructs a Foo
07:09:11 <Peaker> Takumo: B "Hello"  also constructs a Foo
07:09:37 <Peaker> Takumo: the "data" declaration there defines 3 new names: "Foo" (the name of the type), "A" and "B" the names of the "data constructors" or possible "cases" of a value of type Foo
07:09:51 <xeno> http://lpaste.net/94996
07:10:02 <alexander__b> quchen: so if floor (magVec v) is f (g x), then why doesn't h - div (floor . magVec) v)) 10 work?
07:10:06 <Peaker> Takumo: there are 2 ways to use a data constructor -- as a function that constructs values of the type (i.e: "A" is a function that given Ints, builds Foo values)
07:10:13 <quchen> alexander__b: Your code isn't a very good example for composition though, it's fine writing it like that. On the other hand, consider the sum of squares smaller than 100,  sum . takeWhile (< 100) . map (^2) $ [1..]
07:10:27 <mauke> struct Foo { enum {A, B} type; union { int A; string B; }; };  // sort of
07:10:33 <Peaker> Takumo: and as a "pattern" that can do "case analysis" on values of type "Foo": for example:  case someFoo of A theInt -> ... ; B theStr -> ...
07:10:39 <Peaker> Takumo: and that's all there is to data constructors
07:10:56 <quchen> alexander__b: Because the parentheses don't match.
07:11:19 <alexander__b> quchen: oh lol.
07:11:21 <alexander__b> thanks
07:11:27 <Peaker> Takumo: mauke's code there is the C approximation of the "data Foo = A Int | B String"
07:11:42 <FireFly> (case analysis would correspond to a `switch` on the 'type' field of mauke's struct)
07:11:45 <Takumo> So to construct a Foo with A = 3 and B = 9 I'd do what? create a makeFoo :: Foo; makeFoo a b = [A a , B b] ?
07:11:56 <mauke> Takumo: you can't have both
07:12:05 <mauke> that's like trying to set both fields of a union
07:12:12 <mauke> you can only have one at a time
07:12:45 <FireFly> Imagine, I dunno, a variable in Lua or Ruby or JS or something. It can be either a number, a string, an object, ...
07:12:51 <FireFly> but it can't be multiple of those at the same time
07:12:58 <FireFly> it has to be only one thing at a time
07:13:04 <Peaker> Takumo: A Int | B String    is *either* A or B, not both.   If you have:  data Pair = Pair Int String         then "Pair" has both an Int and a String in it.  Haskell data structures can have "a and b" in it (like most languages) but it can also have "a or b" in it (which most languages don't have, or have very poorly)
07:13:06 <Takumo> mauke:  so if it's using a Guard in its constructor there, that's a union-type deal where its excusive?
07:13:07 * FireFly </weird analogues>
07:13:17 <mauke> Takumo: you can't use guards in constructors
07:13:39 <Peaker> Takumo: the "|" means "OR" it doesn't mean "guard" in this context
07:13:45 <Takumo> case analyzer then?
07:13:58 <mauke> no
07:14:02 <Takumo> so if I have a Pair type which has both Int A /and/ Int B?
07:14:19 <mauke> data Pair = P Int Int  -- no A or B, though
07:14:28 <FireFly> You're confusing structs and unions (or product types and sum types)
07:14:52 <Peaker> data Foo = A Int | B String   <--- note that it's not A=5 or B="foo",  A and B have fields *inside* them which equal to 5 or "foo"
07:14:55 <enthropy> the "|" also kind of OR in guards
07:14:56 <FireFly> One has both, the other has one of them. It's a bit analogous to && and ||
07:15:44 <briennetheblue> what's the best way to just typecheck a file?  "ghc -C file.hs" and throw away the output?
07:15:46 <mauke> data X = A | B Int | C Double String
07:15:55 <Takumo> so C union ~= Haskell type? and C struct ~= Haskell …?
07:16:04 <Takumo> Just trying to get this clear in my head!
07:16:41 <scooty-puff> a c struct could be comparable to a data type with only one constructor
07:16:51 <Peaker> Takumo: C *tagged* union (i.e: with an enum tag remembering which union element if the right one) is like a type with A|B|C|...   and C struct is like multiple fields in a single case: i.e: like:  data Foo = Foo Int String Char
07:17:12 <mauke> you get even closer to struct with record syntax
07:17:15 <Peaker> Takumo: data Foo = Foo Int String Char    means that the type "Foo" has only one data constructor/case called "Foo", which has 3 fields in it
07:17:25 <mauke> data Foo = Foo{ a :: Int, b :: String, c :: Char }
07:17:26 <briennetheblue> oh, ghc doesn't like -C
07:18:18 <Takumo> ok, so if I have one of the latter type, like mauke 's Foo{ a :: Int , b :: String , c :: Char } how would I create an instance of a Foo?
07:18:32 <Peaker> Takumo: data Animal = Cat { whiskerLength :: Double, name :: String } | Dog { barkDecibels :: Int, tailWagPotential :: Double }     You could say the *content* of each constructor (Cat or Dog) is a struct, whereas the Animal type is like a tagged-union of ructs
07:18:34 <mauke> Foo 1 "hello" 'x'
07:18:49 <Peaker> Takumo: Also: Foo { a=1, b="hi", c='x' }
07:18:49 <mauke> Foo{ a = 1, b = "hello", c = 'x' }
07:18:55 <Takumo> Peaker: mauke Eureka! Thanks so much!
07:18:58 <Peaker> haha :)
07:19:03 <Takumo> Now I understand it all
07:19:39 <FireFly> Peaker++
07:20:04 <FireFly> I was just about to say something like "isn't it more of a (tagged) union of structs" before noticing your line..
07:20:13 <Takumo> nothing like trying to learn Haskell to make you feel like you don't know anything again...
07:20:59 <Peaker> Takumo: After learning Haskell I sometimes found myself wondering how other languages got so much stuff so wrong, when doing it right is relatively easy :)
07:21:17 <FireFly> Isn't that kind of a good thing, in a way, though? You get to learn new stuff and broaden your knowledge
07:21:42 <donri> Peaker: maybe because doing it wrong is also relatively easy ;)
07:21:45 <Takumo> FireFly: That was my intention
07:21:49 <FireFly> Languages that make you feel completely lost are the most fun IMO :P
07:22:33 <Peaker> Takumo: btw, this syntax for declaring data types makes some things really easy: data BinTree a = Branch (Tree a) a (Tree a) | Leaf a
07:22:46 <otulp> Does GHC evaluate constant arithmetic expressions in a function during compilation? I.e. is "somefun x = x * k where k = 2.0**(-24)" reduced to something like "somefun x = x * 5.960464477539063e-8" by the compiler, or is (**) applied over and over again when the function is used? I suspect is it not evaluated at compile-time, but that I can keep it from being re-evaluated by putting k at the top level.
07:23:03 <mauke> Peaker: why a in Leaf?
07:23:18 <Peaker> mauke: depends on what kind of tree you want.. maybe you want a Tip with no data in it
07:23:30 <mauke> I do
07:23:47 <mauke> because a tip with data in it can be represented by Branch Leaf x Leaf
07:23:51 <Peaker> well, sometimes you might want data only in the leaves, or different data in leaves and non-leaves
07:24:30 <Peaker> mauke: maybe there's some extra semantic meaning attached to leaves vs. branches though
07:25:01 <Peaker> also, maybe you want a "non-empty tree"
07:53:29 <Eduard_Munteanu> Let Foo be a data containing a function, and 'f :: ... -> Foo'. I want to write 'f ... = Foo $ \a b ... -> let ...<mention a, b...>... in <expr>' as a 'where'. I'm thinking of using ViewPatterns.
07:54:45 <Eduard_Munteanu> As in   f ... (Foo -> a b ...) = <expr> where ...
07:55:29 <Eduard_Munteanu> Actually that doesn't work, but it's "close".
07:56:14 <Eduard_Munteanu> Any ideas?
07:58:54 <Eduard_Munteanu> Bah, too complicated, I should just do f ... = foo ... where foo a b = ...
08:07:39 <epsilonhalbe> hey why do i get an error when i add the type signatures in instance declarations for Functor, Applicative when I am implementing the State monad myself?
08:08:17 <epsilonhalbe> "illegal type signature in instance declaration"
08:13:54 <merijn> epsilonhalbe: Oh, for stupid historical reasons that's invalid syntax
08:14:01 <merijn> epsilonhalbe: GHC has an extension that allows it, though
08:14:07 <merijn> epsilonhalbe: Should be mentioned in the error?
08:14:24 <epsilonhalbe> is it recommended to use this extension or not
08:15:42 <donri> epsilonhalbe: you shouldn't normally need it
08:16:04 <donri> ie. you shouldn't normally need type signatures in instances
08:16:15 <epsilonhalbe> i just omit the type signature when implementing a monad or applicative etc
08:16:22 <merijn> epsilonhalbe: I wouldn't worry about it. Normally you don't have to specify type signatures for instance (because the typeclass already specifies the signature)
08:16:49 <merijn> epsilonhalbe: Personally I find it helpful to write down the signature when trying to implement complex instances, so I enable it then.
08:16:55 <epsilonhalbe> then I just leave the signature as a comment
08:17:35 <merijn> epsilonhalbe: The only "problem" would be that other compilers (hah!) might complain about the syntax, so you'd have to delete the signature when compiling with something other than GHC
08:17:52 <merijn> epsilonhalbe: In reality, it's not something I'd worry about, especially as a beginner
08:18:13 <ibotty> merijn: or ... *drums*... wrap it in cpp :D
08:18:19 <merijn> ibotty: ugh :(
08:18:24 <epsilonhalbe> thanks - no no cpp
08:18:28 <epsilonhalbe> ;-)
08:18:34 <merijn> Actually
08:18:40 <ibotty> (c pre processor)
08:18:45 <merijn> CPP is an extension too, so tough luck :p
08:18:50 <ibotty> aww
08:18:52 <ibotty> too bad
08:18:54 <ibotty> :)
08:19:04 <merijn> Although probably a universally supported extension
08:19:29 <ParahSailin> is there a way to do a ghci inside a cabal sandbox?
08:19:38 <ibotty> cabal repl
08:19:41 <donri> i bet CPP is the first extension any haskell compiler implements
08:19:55 <ParahSailin> ibotty: that just seems to do it for one package
08:20:00 <ibotty> ?
08:20:09 <ibotty> it will work within your sandbox
08:20:20 <ParahSailin> when i do a ghci in a shared sandbox, it demands a .cabal file
08:20:22 <ibotty> you have access to everything within your sandbox
08:20:27 <ibotty> ah
08:20:37 <ibotty> ok
08:20:53 <ParahSailin> er, cabal repl inside
08:21:31 <ibotty> i never noticed that. sorry ParahSail
08:23:10 <justinleitgeb> Hey folks. Just wondering why something like cereal wouldn't be mentioned on the Haskell wiki page for "Dealing with binary data." http://www.haskell.org/haskellwiki/Dealing_with_binary_data
08:23:17 <donri> ParahSailin: you could probably do it with GHC_PACKAGE_PATH and normal ghci
08:23:35 <ibotty> ParahSailin: you can of course just work with straight ghci and set the environment
08:24:00 <justinleitgeb> Is there a reason to prefer something else if you want to get back an Either instead of using exception handling code?
08:24:59 <ibotty> ParahSailin: ghci -package-conf=.cabal-sandbox/x86_64-linux-ghc-7.4.2-packages.conf.d
08:25:13 <donri> or yeah -package-conf :)
08:25:15 <ibotty> or whereever your sandbox is and whatever ghc you are using
08:25:46 <ParahSailin> ah thanks
08:26:17 <merijn> justinleitgeb: Probably no one bothered to update it to include cereal?
08:26:28 <merijn> justinleitgeb: btw, you can trivially convert an exception into Either :)
08:26:30 <merijn> :t try
08:26:31 <lambdabot> Exception e => IO a -> IO (Either e a)
08:27:11 <justinleitgeb> merijn:  thanks I didn't know that! But I guess the restriction is that it still has to be done within the IO monad right?
08:27:26 <ibotty> yes
08:27:38 <donri> dealing with async exceptions is harder though
08:28:11 <sclv_> holy crap 160 ppl registered for our ny haskell meetup tonight
08:28:23 <sclv_> jaw, meet floor
08:28:37 <donri> plus you can decode purely so you're not necessarily already in IO
08:28:37 <ibotty> sclv_ you are doing too good a job
08:28:42 <justinleitgeb> sclv_: really wish I were in town, just headed from NYC back to Quito. Should have extended my stay.
08:29:02 <t7> how do i realloc in c++ ?
08:29:06 <donri> however, binary has runGetOrFail these days
08:29:07 <t7> can i do that with new?
08:29:11 <sclv_> our venue's capacity is 120. crossing my fingers that we have our usual 66% attendnace rate
08:29:23 <blakesmith> Any Raspberry Pi Haskellers in here? I found the wiki article on the Pi (http://www.haskell.org/haskellwiki/Raspberry_Pi), but it's unclear to me whether the best approach to getting a binary running on the Pi is cross-compile or compiling on the Pi itself.
08:29:45 <justinleitgeb> sclv_: we are however doing the first-ever Haskell meetup in Quito tonight though, so that makes me feel a bit less bad about missing the event in NY tonight. :) http://www.meetup.com/Quito-Lambda-Meetup/events/141163542/
08:29:50 <bearclaw> the pi is extremely slow compared to your average desktop computer
08:30:11 <blakesmith> bearclaw: For sure. ;-)
08:30:13 <bearclaw> but getting a proper cross-toolchain can be troublesome
08:30:37 <bearclaw> (it takes more than a minute per .cpp file using boost::asio for instance)
08:30:38 <blakesmith> Yeah, this wiki article doesn't make it look easy: http://ghc.haskell.org/trac/ghc/wiki/CrossCompilation
08:31:11 <sclv_> justinleitgeb: w00t, meetups++
08:31:17 <merijn> justinleitgeb: Yes, but in case of cereal/whatever the other binary parsing thing was, you're usually in IO already anyway :)
08:32:22 <blakesmith> bearclaw: How troublesome is it? All day compilations on the Pi is going to kill my feedback loop. ;-)
08:33:23 <Takumo> What’s everyone's preferred tools for Haskell development (I know this is purely a matter of /preference/) I'm using emacs with haskell-mode , I like it but want to know if there's anything “better” I've not heard of
08:33:34 <bearclaw> if you're lucky you will find prebuild binaries or a nice script that works out of the box
08:35:09 <MercurialAlchemi> Takumo: vim + syntastic + ghc-mod
08:36:13 <jle`> Takumo: basically use the same stack as MercurialAlchemi ...with NeoComplCache and vim-haskell-mode.
08:37:42 <dv-> emacs + ghc-mod is pretty nice
08:37:58 <jle`> ls
08:38:01 <jle`> sorry
08:38:23 <srhb> dv-: Do you have it working with cabal sandboxes?
08:38:34 <bergmark> i have never managed to get ghc-mod running :
08:39:11 <bergmark> also my haskell-mode freezes emacs sometimes, no idea how to debug it :(
08:39:28 <srhb> bergmark: Oh? I've never experienced that.
08:39:44 <ibotty> srhb: i use hdevtools, but the config should be similar. i have a working vim + cabal sandboxes setup if someone is interested
08:40:06 <donri> bergmark: i wonder if any of it is fish's fault. fish doesn't play well with vim at all. but emacs is probably not as dumb.
08:40:09 <srhb> ibotty: I think there's a general lack of sources on how to get _anything_ to work with the new cabal sandboxes
08:40:16 <ibotty> huh
08:40:17 * hackagebot fclabels 2.0.0.1 - First class accessor labels implemented as lenses.  http://hackage.haskell.org/package/fclabels-2.0.0.1 (ErikHesselink)
08:40:17 * hackagebot fclabels 2.0.0.2 - First class accessor labels implemented as lenses.  http://hackage.haskell.org/package/fclabels-2.0.0.2 (ErikHesselink)
08:40:17 <srhb> ibotty: Worth a reddit post at the very least :-)
08:40:32 <ibotty> hmm. it's so easy though
08:40:33 <bergmark> donri: hmm that is a possibility
08:40:38 <donri> ibotty: hdevtools with cabal sandboxes? how?
08:40:52 <srhb> ibotty: Please consider it at least. :)
08:41:36 <donri> admittedly i didn't try to get it to work myself. but hdevtools hasn't been updated since 2012, and other projects seemed to need updates to support sandboxes
08:41:43 <bergmark> i *think* i get it even if i launch emacs from bash, but apparently i didn't last time it froze
08:41:51 <haasn> > text $ unlines [[if abs x + abs y < 4 then '*' else ' ' | x <- [-3..3]] | y <- [-3..3]]
08:41:52 <lambdabot>      *
08:41:53 <lambdabot>    ***
08:41:53 <lambdabot>   *****
08:41:53 <lambdabot>  *******
08:41:53 <lambdabot>   *****
08:41:54 <lambdabot>    ***
08:41:56 <lambdabot>     *
08:42:03 <haasn> heh, lambdabot inserts a leading space
08:42:31 <ibotty> srhb: feel free to write something about it (or better yet: polish it): http://lpaste.net/94999
08:42:34 <jle`> get your act together lambdabot
08:42:40 <haasn> elliott!!
08:42:52 <donri> is there any flood protection on that there thing?
08:42:54 <srhb> ibotty: I have a similar hack for haskell-mode
08:43:00 <haasn> donri: seems like it, since the messages got delayed
08:43:11 <dwcook> The flood protection is on Freenode itself
08:43:12 <donri> i meant more in the lines of @more
08:43:22 <haasn> Ah, doesn't seem like it
08:43:31 <haasn> dwcook: I think freenode just kills clients that flood
08:43:37 <haasn> (or maybe it doesn't)
08:43:49 <dwcook> I have seen clients quit due to "Excess flood"
08:43:49 <donri> so uh text (repeat '\n')? :P
08:44:07 <dwcook> On the other hand, I've also seen clients send text one line at a time at regular intervals, presumably having pasted it all at once
08:44:21 <dwcook> s/clients/users/
08:44:22 <haasn> donri: or (cycle "a\n") at least
08:44:29 <dwcook> s/users/nicks/
08:44:44 <dwcook> Whatever the terminology here is
08:44:46 <donri> s/nicks/clients/
08:44:49 <bergmark> dwcook: i think that's the irc client's doing
08:45:03 <haasn> test by using nc
08:45:10 <dwcook> bergmark, could be.
08:45:24 <haasn> paste a whole bunch of PRIVMSG #something-that-isnt-haskell :a\r\n into it
08:45:30 <dwcook> donri, my point being I'm uncertain whether the client program itself is causing that
08:45:36 <dwcook> Thus why "clients" wasn't quite the right word
08:45:39 <jle`> lambdabot does truncate output though
08:45:40 <chrisdone> erc debounces messages
08:46:00 <sm> freenode does kill clients that flood, or connect too often
08:46:20 <haasn> and I was hoping people would talk about the haskell code :(
08:46:23 <ibotty> oh hi chrisdone: why does lpaste sometimes post messages to #haskell and sometimes not?
08:46:36 <chrisdone> ibotty: the author has to be the nickname in the channel
08:46:59 <ibotty> ah ic. thanks
08:47:18 <ibotty> and: can you add vimscript to possible languages :D
08:47:27 <chrisdone> uhh
08:47:29 <ibotty> (it's not heresy, is it?)
08:48:22 <chrisdone> the highlighter doesn't support vimscript
08:49:44 <chrisdone> bash, erlang, cs, ruby, diff, javascript, lua, css, xml, lisp, java, php, haskell, python, smalltalk, tex, sql, ini, perl, scala, cmake, objectivec, nginx, erlang_repl, django, delphi, vbscript, apache, cpp, go
08:49:52 <chrisdone> if vimscript is a subset of any of those, i can alias it
08:50:17 <ibotty> i don't think so. vimscript is weird
08:55:18 <FireFly> VimL and subset-of-a-sane-language are mutually exclusive
08:55:36 <FireFly> s/^/being /
08:55:47 <ibotty> not that every language in this list is sane
08:56:06 <FireFly> That's true
08:57:12 <chrisdone> Peaker: i pushed the read-only to be disabled for now. it makes the buffer vaguely useable for real work
08:57:45 <chrisdone> Peaker: btw, the selection is used for indentation. i've a bunch of cases to add from old shm, but basically if you know how paredit works, it's the same principle
08:58:38 <chrisdone> Peaker: close parenthesis jumps to the end of the node, then the parent's end, etc. that's how you decide where to indent. then C-j will use the parent to determine how to indent
09:00:19 <chrisdone> Peaker: foo bar|  C-j here will take you to the same column as bar for the catch-all case
09:00:19 <chrisdone> Peaker: but e.g. [foo bar|] C-j here with the selection as "foo bar" will give you
09:00:19 <chrisdone> [foo bar
09:00:19 <chrisdone> ,|]
09:00:22 <chrisdone> Peaker: assuming that you want to write a new list item. i want that to be a general idiom
09:03:09 <chrisdone> Peaker: i've been using the read-only as a keeps-us-honest trick. if you can't do an operation because the buffer is read-only, then what you're doing is probably not structural, and there should be a structured equivalent of it
09:04:44 <Peaker> chrisdone: cool, will take a look asap :)
09:05:14 * hackagebot text-icu 0.6.3.7 - Bindings to the ICU library  http://hackage.haskell.org/package/text-icu-0.6.3.7 (BryanOSullivan)
09:11:47 <chrisdone> Peaker: added some tentative undo support
09:12:13 <Peaker> chrisdone: does it consist of more than just letting ordinary undo happen?
09:12:24 <chrisdone> Peaker: it's (undo) (shm/reparse-decl)
09:12:30 <chrisdone> Peaker: =)
09:13:36 <Peaker> Do you know the "undo-tree" elisp module?
09:13:45 <Peaker> it's pretty awesome, I hope it works with shm too :)
09:13:46 <chrisdone> Peaker: yeah, see comment in my commit
09:15:19 <chrisdone> Peaker: i don't use the tree version of undo, so let me know if it doesn't behave. i don't see why it shouldn't at present
09:16:58 <Peaker> chrisdone: git log -p |grep -i undo   comes up with nothing, which comment do you mean?
09:17:29 <chrisdone> Peaker: ah, maybe i didn't push. thought i'd pushed. push again
09:17:39 <chrisdone> Peaker: try that?
09:18:49 <chrisdone> Peaker: (i think a proper implementation can look at the actual changes in the buffer and think about what to do better, but this trivial solution has been acceptable for me for some months)
09:30:15 * hackagebot language-pig 0.1.0.0 - Pig parser in haskell.  http://hackage.haskell.org/package/language-pig-0.1.0.0 (elisehuard)
09:30:17 * hackagebot cake3 0.1.0.0 - Third cake - Makefile DSL  http://hackage.haskell.org/package/cake3-0.1.0.0 (SergeyMironov)
09:35:16 * hackagebot urembed 0.5.0.0 - Ur/Web static content generator  http://hackage.haskell.org/package/urembed-0.5.0.0 (SergeyMironov)
09:36:36 <chrisdone> there's a language called pig?
09:40:16 * hackagebot Agda 2.3.2.2 - A dependently typed functional programming language and proof assistant  http://hackage.haskell.org/package/Agda-2.3.2.2 (NilsAndersDanielsson)
09:41:08 <Takumo> So could someone explain to a Haskell noob what the difference between a String and an IO String is?
09:41:26 <haasn> @quote /bin/ls
09:41:26 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
09:41:45 <Takumo> haasn: saywaaaat?
09:41:59 <chrisdone> Takumo: are you the japanese version of Tekmo?
09:42:03 <Takumo> Also why "IO String" can't be cast to "String"
09:42:04 <klugez> That is, when you run an action of type IO String, it will give you a String.
09:42:06 <haasn> IO String is an IO computation that (might) produce a string
09:42:12 <mzero> yes, chrisdone, there is - and my it looks scary: http://pig.apache.org/docs/r0.12.0/start.html
09:42:12 <fizbin> In other words, "IO String" is properly thought of as "IO action that returns a String"
09:42:13 <Takumo> ah ok
09:42:23 <Takumo> hence why main is an IO () ?
09:42:35 <haasn> main is an IO action, yes
09:42:36 <Takumo> because its an IO computation with not return
09:42:46 <haasn> () is a valid Value
09:42:49 <haasn> (of type ())
09:43:02 <Takumo> much like Nothing is both a type and a value?
09:43:07 <chrisdone> mzero: APACHE IS PIG DISGUSTING
09:43:11 <scshunt> Takumo: Nothing is not a type
09:43:15 <fizbin> The "with not return" would be more like "IO Void"
09:43:23 <Takumo> fizbin: IO Unit?
09:43:24 <scshunt> Takumo: () being both a value and a type is a special case
09:43:28 <frerich> Takumo: main actually has the type 'IO a', i.e. 'main = getLine' type checks.
09:43:33 <scshunt> it's just a syntactic thing
09:43:43 * chrisdone wonders whether his reference to old memes is lost on everyone these days
09:43:43 <Takumo> oh ok, I think I'm learning
09:43:55 <mzero> :-)
09:43:58 <scshunt> :t Nothing
09:43:59 <lambdabot> Maybe a
09:44:06 <fizbin> Takumo: () is how Haskell spells the scala type "Unit".
09:44:16 <scshunt> note that it's unconstrained, so Nothing is a "Maybe a" for all types "a"
09:44:31 <ParahSailin> @let data Unit = Unit
09:44:32 <lambdabot>  Defined.
09:44:39 <ParahSailin> @type Unit
09:44:40 <lambdabot> Unit
09:44:46 <dv-> frerich: main is IO ()
09:45:03 <merijn> dv-: Technically, main is "IO a"
09:45:05 <fizbin> Takumo: haskell Void is like the type in scala called Nothing.
09:45:12 <merijn> dv-: According to the Haskell standard
09:45:18 <dv-> not in ghc apparently
09:45:24 <haasn> main does not need to be forall a. IO a -- though
09:45:39 <dv-> Couldn't match type `[Char]' with `()' In an equation for `main': main = getLine
09:45:56 <merijn> dv-: Did you change the signature?
09:46:01 <mzero> Takumo: don't listen to the dithering over main's type --- for all intents and purposes, you should just consider it   IO ()
09:46:01 <fizbin> dv-: Do you have an explicit type line for main?
09:46:36 <dv-> oh :(
09:46:47 <dv-> i was lazy and just edited an existing file
09:47:12 <merijn> dv-: Works just fine with a correct or missing signature here
09:47:27 <dv-> yeah, it does, sorry
09:48:08 <mzero> Takumo: you also asked why IO String can't be "cast" to String
09:48:44 <mzero> Here's a way to think about that, if you are still looking for something to hang on to:
09:49:40 <briennetheblue> i always thought it was strange that it wasn't :: IO Int (for an exit code)
09:50:25 <chrisdone> imagine having to return an exit code all the time. BORING
09:50:42 <Cale> briennetheblue: Of course, that would mean that  main = putStrLn "hello, world!" would be ill-typed.
09:50:57 <mzero> a value of IO String is a computation (in IO) that can produce a String... if you want to do anything to the String produced by it, say reverse it, then what you are really doing is producing a /new/ computation (in IO) that first runs the first computation, then reverses the result ---- the total new thing is still a computation to produce the result (the now reversed String).....
09:51:15 <mzero> .... you can't ever "erase" (or "cast away") the act of the computation ---
09:51:25 <briennetheblue> yeah i guess a lot of the time it would just be an annoyance
09:51:44 <mzero> briennetheblue: I think it is because not all platforms respect the return value of main as the exit code of the process...
09:53:04 <clahey> chrisdone, Well, a program always has an exit code, right?  Why shouldn't you have to specify it?
09:53:11 <clahey> (I like that you don't, but it would feel haskelly to me.)
09:53:30 <bearclaw> (and the do blocks is a magic syntax that makes it look like  "x <- doio ; foo x" is extracting the value from the io, but in truth it is just chaining foo and doio)
09:53:42 <chrisdone> clahey: because i've wanted to specify an exit code manually in haskell maybe once ever
09:53:56 <chrisdone> clahey: throwing an exception sets an exit code for you if things go wrong
09:53:57 <jle`> clahey: the idea of pure idea of a program does not involve an exit code
09:54:08 <jle`> ^the "pure" idea of a program
09:54:16 <clahey> chrisdone, Oh, practicality, right. :-P
09:54:27 <jle`> if you were to explain to someone what a program was/is/represented
09:54:29 <clahey> jle`, Interesting point.
09:54:29 <chrisdone> clahey: there's at least System.Exit when you want to specify your own
09:54:31 <jle`> it would not involve an exit code
09:55:23 <Draconis> weird. so pattern matching in haskell is like defining a set of different functions with different arguments?
09:55:35 <Draconis> I'm so used to keywords like match x in y
09:55:41 <Draconis> or case
09:56:07 <jle`> Draconis: yeah, you can think of it that way.
09:56:37 <Draconis> seems odd
09:56:50 <mzero> bearclaw: exactly
09:56:51 <jle`> odd? compared to other pattern matching?
09:57:01 <Cale> Draconis: It desugars into a case expression of course
09:57:02 <klugez> Draconis: Well, there's case too.
09:57:04 <Draconis> yeah
09:57:37 <chrisdone> fib(0) = 0; fib(1) = 1; fib(n) = fib(n-1)+fib(n-2)
09:57:43 <mzero> Draconis: actually, the pattern match for a function can't take different numbers of arguments, or even different types
09:57:43 <chrisdone> it reads like maths
09:57:54 <mzero> it really is just a case around the outside
09:58:25 <mzero> don't confuse it with overloading like in C++ or Java
09:58:49 <Cale> Well, different numbers of arguments is an artificial restriction just because that's usually an editing mistake rather than something you want.
09:59:04 <Cale> But it would be possible to support that in the cases where it's well-typed
09:59:20 <chrisdone> often that bugs me
09:59:31 <chrisdone> f [1,2] = []
09:59:31 <chrisdone> f = id
09:59:34 <chrisdone> can't write that ^
09:59:44 <Cale> It does look a bit odd though
09:59:45 <FireFly> Yeah, I've been wanting to write things like that too
09:59:49 <chrisdone> it comes naturally to write
09:59:58 <donri> me too!
09:59:59 <chrisdone> especially with more args
10:00:18 <donri> i even had a case where not being able to do that caused silly problems! granted, i was using unsafeCoerce ;)
10:00:26 <benzrf> OK IS THIS AN INDISPUTABLY CORRECT DEFINITION OF MONADS:
10:00:27 <chrisdone> it kinda blocks you from point-freeness, sometimes
10:00:38 <chrisdone> @faq can benzrf describe monads?
10:00:38 <lambdabot> The answer is: Yes! Haskell can do that.
10:00:42 <benzrf> - a means of chaining functions that return structured results
10:00:54 <Cale> benzrf: go on
10:00:57 <benzrf> :I
10:01:04 <benzrf> that's all I have that universally applies
10:01:05 <Cale> benzrf: (that's not a definition at all)
10:01:06 <benzrf> -.-
10:01:09 <benzrf> totally is
10:01:20 <chrisdone> what's a structured result?
10:01:22 <benzrf> oh, and TAKE unstructured results
10:01:29 <benzrf> ok you guys are just mean
10:01:33 <chrisdone> :D
10:01:34 <briennetheblue> it's vague enough to accurate :P
10:01:36 <briennetheblue> maybe
10:01:38 <Cale> I'm not trying to be mean here :)
10:01:43 <FireFly> But that definition doesn't involve either burritos, space suits or nuclear waste
10:01:50 <benzrf> whenever I define a monad data type as like
10:01:52 <benzrf> 'a wrapper'
10:01:58 <benzrf> you say 'well structured is more accurate'
10:02:06 <benzrf> but apparently now that isn't enough
10:02:15 <Cale> A monad is a type constructor M together with definitions of return :: a -> M a and (>>=) :: M a -> (a -> M b) -> M b such that a few laws are satisfied
10:02:16 <benzrf> you god damn goalpost-shifting smug assholes
10:02:18 <Draconis> so fo factorial I understand you can write it like this:
10:02:18 <Draconis> factorial 0 = 1
10:02:19 <Draconis> factorial x = x * factorial (x - 1)
10:02:37 <Cale> Namely:
10:02:43 <Cale> return v >>= f = f v
10:02:47 <Draconis> is that the correct and most common way? what is the case way you spoke of? I tried drafting it and kept getting syntax errors.
10:02:47 <Cale> x >>= return = x
10:03:01 <Cale> and (x >>= f) >>= g = x >>= (\v -> f v >>= g)
10:03:01 <clahey> benzrf, The question I have is why do you need to define it in some way other than what Cale is doing?
10:03:08 <benzrf> Draconis: factorial n = foldl1 (*) [1..n]
10:03:17 <mzero> benzrf: are you just talking about when you need to return two or more distinct values... and then want to consume them both (or all) in the next function?
10:03:35 <benzrf> argh forget Itkovian
10:03:37 <benzrf> *it
10:03:41 <darthdeus> guys i need a little advice ... i'm about 97% done with learn you a haskell and now i'd love to use haskell for something real ... i wanna build a simple web API, which will work on a sort of reversed tree (tournament bracket), store it in some sort of database and provide operations on it ... what would you recommend? yesod seems quite heavy
10:03:46 <benzrf> god damn muscle memory
10:03:53 <dv-> > product [1..10]
10:03:54 <lambdabot>   3628800
10:04:00 * benzrf facepalms
10:04:04 <benzrf> of course that's there
10:04:10 <benzrf> how about mconcat $ map Sum
10:04:11 <benzrf> :D
10:04:12 <bartavelle> Darthdeus : you might want to start with just warp
10:04:13 <darthdeus> i wanna point out that i'm really a noob, so something uber simple would be nice :) for the database and REST API that is
10:04:18 <benzrf> definitely the best solution
10:04:29 <Draconis> ah nm I found it... the site had the wrong syntax strangely. I guess the language evolved
10:04:33 <benzrf> darthdeus: why not write it in python and then invoke it from haskell
10:04:33 <benzrf> :D
10:04:37 <clahey> benzrf, I'm actually curious what you're trying to come up with wrt Monads.
10:04:47 <benzrf> clahey: huh?
10:04:57 <Cale> darthdeus: I find both Happstack and Snap to be easier to understand than Yesod.
10:04:59 <clahey> benzrf, You were trying to define it.  I'm curious why.
10:05:00 <cschneid> darthdeus: scotty is a really light weight web frontend from what I understand. postgresql-simple is super easy, if you're willing to write the SQL code yourself (ie, it's not an ORM to learn).
10:05:09 <benzrf> clahey: to help solidify  the idea in my brain
10:05:09 <darthdeus> benzrf: because i have a written solution in ruby and there's some nasty bug :P so i wanna try rewriting the business logic in haskell to learn it and to make sure i got it right in the first place
10:05:10 <benzrf> >.>
10:05:16 <briennetheblue> i think there's a distinction here between definition and um... intuitive description?
10:05:18 <benzrf> darthdeus: i was joking ;p
10:05:21 <FireFly> As I see it, being a monad (or a functor, or an applicative, or a monoid, or ...) is a property of a type, much like being associative is a property of a binary operation, or being prime is a property of an integer
10:05:24 <bartavelle> darthdeus : you can write very quickly an application with warp around a "case (pathInfo query) of"
10:05:24 <darthdeus> benzrf: oops :P
10:05:26 <jle`> darthdeus: for what it's worth, i'm a big fan of persistent :)  debugging errors can be pretty hairy until you understand the type system though ... after that, it's amazing
10:05:28 <benzrf> briennetheblue: thank you for acknowledging that
10:05:33 <jle`> scotty is also a nice light frameowkr
10:05:39 <darthdeus> oh perfect
10:05:44 <benzrf> briennetheblue: everybody here is a hyper-facetious faux-pedant
10:05:46 <benzrf> or something
10:05:58 <darthdeus> i love this chat room
10:05:59 <darthdeus> :D
10:06:01 <bearclaw> benzrf: you said "definition" :)
10:06:01 <donri> darthdeus: happstack-lite has the nice property that it's easy to migrate to the more full framework at any time, but it starts out very lite and easy
10:06:06 <Draconis> so is it frowned upon to do something like factorial x = case x of 0 -> 1; x -> x * factorial (x - 1);
10:06:13 <darthdeus> it's like every time i ask a question i get 50 good answers
10:06:21 <Draconis> I know thats not the best way, and the foldl way is better, but abstractly
10:06:33 <benzrf> it's like every time I ask a question I get 49 Mathemetician
10:06:34 <Cale> benzrf: Well, the definition aside, the monad class is a certain shape that often enough shows up in a particular style of library that we like to write that we've bothered to give it a name (or rather steal a name for it from category theory)
10:06:35 <benzrf> 's Answer
10:06:36 <benzrf> s
10:06:40 <benzrf> and 1 helpful one
10:06:42 <donri> @where web
10:06:42 <lambdabot> #haskell-web | #happs - http://happstack.com/ | #snapframework - http://snapframework.com/ | #yesod - http://yesodweb.com/
10:06:44 <bearclaw> I like the way learn you a haskell introduce monads. It's a kind of value container with its own definition of >>= and >> which can be used among other things to perform a sequence of operations with a state variable that is completelyhidden from the code
10:06:57 <darthdeus> benzrf: at least the mathematicians think their answers through a little bit
10:07:07 <benzrf> whatever
10:07:12 <clahey> benzrf, I agree that an intuitive description is useful.  I think the most useful ones for Monads include the word, "usually".
10:07:14 <benzrf> im leaving before I get sucked into a discussion about something I barely understand
10:07:19 <benzrf> "thanks"
10:07:20 <Cale> benzrf: It's similar to Applicative and Arrow in that regard
10:07:33 <clahey> How else will  you learn about something without having a discussion?
10:08:03 <chrisdone> to be fair, when i first started and i came in here asking about monads
10:08:09 <chrisdone> i was diverted to functors
10:08:32 <chrisdone> when you're still fresh to haskell, the last thing you want is yet another thing
10:08:44 <Cale> At least functors are a simpler thing than monads :)
10:08:45 <chrisdone> regardless of what order makes more 'logical' sense
10:09:04 <darthdeus> happstack-lite seems really simple :O
10:09:13 <darthdeus> looks like it does all i need
10:09:15 <Cale> I think it doesn't hurt at all to try understanding functors first
10:09:17 <chrisdone> although these days you have LYAH, so…
10:09:19 <donri> the least useful advice i got learning monads was that "no, it's not about sequencing because order doesn't matter in all monads" which is kinda-true but very misleading because no monad can look at more than one "semicolon" at a time
10:09:21 <Cale> Might not be strictly necessary
10:09:25 <darthdeus> but there's nothing about json serialization :X
10:09:32 <chrisdone> Cale: doesn't hurt as in physically? =p
10:09:34 <Draconis> so is it frowned upon to do something like factorial x = case x of 0 -> 1; x -> x * factorial (x - 1);  instead of a two line pattern match.
10:09:43 <Cale> chrisdone: as in, it doesn't waste any of your time
10:09:46 <darthdeus> donri: i thought order always matters?
10:09:51 <clahey> donri, That's what I was trying to get at earlier.
10:09:56 <bartavelle> darthdeus, you can just use aeson, it doesn't matter if it's not built in
10:10:05 <bartavelle> as long as you can set the content type
10:10:08 <donri> darthdeus: well, take Maybe. a Nothing anywhere "short circuits" to a Nothing.
10:10:09 <mzero> darthdeus: JSON is independent of the web framework.
10:10:10 <Cale> chrisdone: What you learn in understanding functors is immediately relevant to what monads are.
10:10:23 <mzero> we all use aeson now for JSON and we are very very happy indeed
10:10:25 <donri> clahey: i didn't read what you said earlier
10:10:30 <clahey> donri, "Monads are often about sequencing."
10:10:41 <donri> ok :)
10:10:42 <cschneid> darthdeus: keep it simple. Add libraries one at a time, so do the web side first, with super simple echo type logic. Then wire in Aeson for json parse/serialize functionality. Then wire in a DB layer....
10:10:49 <clahey> donri, About the "intuitive description" containing the word usually.
10:10:57 <darthdeus> bartavelle: cool, thanks
10:10:59 <cschneid> darthdeus: just do it slowly. I've found as a relative newbie myself that if I try too much at once, things blow up and I can't debug
10:11:07 <darthdeus> hmm
10:11:20 <donri> well i'm suggesting all monads *have* to do sequencing FSVO the word
10:11:22 <darthdeus> yeah i guess it's probably best if i do it without a web/database at all, and then just add persistence and stuff
10:11:37 <clahey> FSVO?
10:11:41 <cschneid> darthdeus: yeah, first step may just be a command line app that takes an arg, and spits out an answer
10:11:41 <donri> it was very confusing and misleading for me to be told it's not about sequencing
10:11:47 <cschneid> darthdeus: then that answer in JSON form.
10:11:52 <donri> made me think monad did more than it does
10:11:54 <cschneid> darthdeus: then that answer in JSON form, fetched from a DB
10:11:55 <cschneid> etc.
10:12:02 <darthdeus> aye, makes sense
10:12:03 <donri> clahey: for some value of
10:12:43 <bartavelle> darthdeus, I'd do the DB part last, many libraries will give you confusing type errors
10:12:49 <donri> i'd argue sequencing is exactly what monad is for, cf. how it's different from the context-free nature of applicative
10:13:04 <Cale> donri: That's pretty true when you look at the examples in Haskell at least.
10:13:45 <donri> Cale: yep. but i'm thinking even more deeply. you can't "join" without first looking at the outermost "layer"?
10:13:46 <n-dolio> Not all of them.
10:13:49 <cschneid> bartavelle: which is why I proposed postgresql-simple or equivalent, that doesn't try to type-system the database :)
10:14:07 <cschneid> persistent is cool, but took me a while to wrap my head around the types going on
10:14:23 <Cale> In that in order to execute x >>= f (no matter what that means) you have to do *something* with x
10:14:24 <donri> (of course, the real issue here is that "sequencing" is vague and probably means something different to everyone :))
10:14:38 <Cale> because there's no way to use f except to apply it to a value of the appropriate type
10:14:45 <donri> yeah
10:14:48 <darthdeus> would you guys still think it's a good idea for a haskell project, or is the "web api with a database" stuff not a good fit?
10:15:04 <Cale> and there's no way to get a value of the appropriate type without doing *something* to x (unless the monad is the trivial one)
10:15:11 <donri> darthdeus: sure it's a good fit. plenty of packages to help you there
10:15:12 <clahey> Except because of lazy ordering, the computation in f might take place in the processor before the computation in x.
10:15:21 <bartavelle> darthdeus, it certainly is a good fit, I'd go with cschneid advice for the choice of DB library though
10:15:47 <Cale> clahey: Lazy evaluation doesn't mean you're free of data dependencies
10:15:57 <donri> darthdeus: personally i'd recommend acid-state
10:15:57 <darthdeus> my mind is still stuck at thinking that mutable state is hard
10:16:05 <clahey> Cale, Fair enough.
10:16:09 <cschneid> darthdeus: it's a cool thing to solve.  It splits up nicely across domains: the task itself, the db, the web side, etc.
10:16:19 <xcastilho> the point of the >>= function is exactly to introduce a data dependency that forces ordering
10:16:30 <clahey> Cale, I suppose you could define  x >>= f as f (error "whatever")
10:16:36 <Cale> I don't like hearing that that's "the point" of >>= though ;)
10:16:36 <cschneid> darthdeus: so you can easily start on a task-itself level, with a super-simple command line interface, and start layering on the other features
10:16:46 <xcastilho> well, true
10:16:56 <n-dolio> The use of monads in bound has nothing to do with sequencing.
10:17:03 <xcastilho> It was a poor choice of words. =P
10:17:07 <n-dolio> Unless you use a trivial definition of sequencing like the one above.
10:17:12 <clahey> But yeah, I agree that Monads are usually about sequencing.
10:17:12 <darthdeus> cool :)
10:17:19 <xcastilho> but bind does that.
10:17:20 <n-dolio> Where it means, "I have to find all the variables in a tree to replace them."
10:17:28 <n-dolio> So I've "sequenced" the tree first.
10:17:31 <cschneid> darthdeus: The only gotcha you'll run into is monad transformers. Web libs in particular seem to use them heavily to handle both the IO, and State, and Request (in the ReaderMonad).  So that can be slightly tricky, but not too terrible.
10:18:08 <cschneid> darthdeus: but they're not that scary, other than the type errors they give when things go wrong :)
10:18:23 <srhb> Does the ghc api provide essentially the same features as the plugins package?
10:18:25 <xcastilho> btw, hi guys. I've been toying around with Haskell for the last six months, but it's actually the first time I get over here.
10:18:33 <srhb> Or does the latter utilize the former?
10:18:40 <srhb> xcastilho: Welcome :)
10:19:01 <xcastilho> srhb: thanks. :)
10:20:25 <Cale> srhb: plugins uses the ghc api
10:20:41 <Cale> srhb: Hint does as well, and usually is a bit easier to use.
10:20:58 <srhb> Cale: ah, so that's the two I'm deciding between when I want to load some code at runtime?
10:21:05 <Cale> Probably :)
10:21:08 <srhb> Cale: Thank you.
10:21:45 <Cale> (or three, you could use the GHC API directly, it's just a little convoluted in the simple use cases)
10:23:01 <donri> srhb: plugins is compiled with dynamic object loading; hint is embedded ghci, ie. interpreted
10:23:09 <srhb> donri: Oh, I see.
10:24:35 <xcastilho> does the GHC API make it possible to implement a typical 'eval' function in the vein of dynamic languages?
10:24:54 <xcastilho> I see ways of doing something like that, but I think making it type-correct would be a pain
10:26:10 <mzero> xcastilho: you can implement such a feature with hint
10:26:25 <donri> xcastilho: that's just "interpret" with hint, which works via Typeable
10:26:33 <fizbin> Does anyone use emacs with flycheck/hdevtools for development?
10:27:01 <fizbin> I can't figure out how to use it properly with this package.
10:27:06 <enthropy> you have to pick what result type you are expecting without looking at the contents of the string you feed into "interpret"
10:27:38 <donri> yeah, it's basically like Data.Dynamic, i imagine
10:30:18 <dEPy> heyo
10:30:59 <dEPy> how do I define Ord instance for data Point = Point { x :: Float, y :: Float}  so that it will compare y components first?
10:31:55 <Cale> dEPy: instance Ord Point where compare (Point x y) (Point x' y') = mappend (compare y y') (compare x x')
10:32:29 <cschneid> Cale: oh, I forgot about the monoid instance on the EQ/LT/GT type (what's that type called?)
10:32:36 <shiona_> Ordering
10:32:38 <Cale> Ordering
10:32:39 <Cale> yeah
10:33:50 <dEPy> oh nice
10:33:58 <donri> :t EQ
10:33:59 <lambdabot> Ordering
10:34:13 <cschneid> :info Ordering
10:35:14 <cschneid> @src mappend :: Ordering -> Ordering -> Ordering
10:35:14 <lambdabot> Source not found. :(
10:35:23 <cschneid> is there a way to get the source of that from lambdabot
10:39:00 <dEPy> instance Ord a    requires   instance Eq a  defined ?
10:39:19 <Cale> dEPy: yeah
10:39:43 <Cale> dEPy: You probably just want to derive the Eq instance
10:40:12 <dEPy> oh yea, dont know why I implemented that
10:41:52 <newsham> is there a program for visualizing haskell types?
10:42:03 <cschneid> vim. :)
10:42:13 <Cale> ghci's :t command?
10:44:26 <donri> @src Ordering mappend
10:44:26 <lambdabot> Source not found. Whoa.
10:45:16 <krakrjak_> newsham: visualizing like how?  GHCi allows you to use :t expr to get the type of the expression
10:45:59 <newsham> asking for a friend,  trying to figure out that answer.  i think he wants something that visualizes various elements in data structures
10:47:57 <enthropy> @hackage vacuum
10:47:57 <lambdabot> http://hackage.haskell.org/package/vacuum
10:49:18 <newsham> yah looking at a youtube video fo that now http://www.youtube.com/watch?v=oujaqo9GAmA
10:50:42 <bz> ugh
10:50:52 <bz> either i'm in imperative mode or declarative mode
10:51:54 <newsham> bzSetDeclarative :: IO ()
10:52:00 <newsham> d'oh, still imperative!
10:56:11 <dwcook> You have to produce a new bz, identical except for the mode
10:57:07 <newsham> i tried that but ran into garbage collection problems
10:57:25 <dwcook> Well obviously you don't *actually* do that in memory, just conceptually
10:57:27 <newsham> now i have a basement full of BZs in water tanks :(
10:57:37 <dwcook> You are bad at compiling :P
10:58:56 <jml> is it possible to get haddock documentation annotations in ghci? would be nice to get better docs for functions than just their types
10:59:05 <newsham> i blame tesla and his damned machine
11:00:08 <kqr> jml, not in ghci, i don't think. but isn't that a responsibility for your IDE anyway, and not the interpreter
11:00:33 <jml> kqr: maybe. works just fine in ipython, for example.
11:00:41 <jml> although being a compiled language changes things.
11:01:27 <Cale> It would be a nice feature for things where you have the source code and/or documentation installed.
11:02:29 <kqr> ipython also aims to be slightly more than just an interpreter. as far as I can tell from looking at the website, it tries to be more of a complete environment for interactive programming
11:02:48 <kqr> far from the bare-bones evaluation engine ghci is
11:03:15 <kqr> i think such an environment would be awesome for haskell as well, don't get me wrong, i just think ghci is the wrong place to put it
11:03:37 <jml> fair enough.
11:03:48 <Cale> jml: If you set documentation: True in your ~/.cabal/config then you'll end up with HTML documentation for all installed packages under ~/.cabal/share/doc/index.html
11:03:57 <jml> by your use of the subjunctive mood, I'm going to conclude that such an environment doesn't exist :)
11:04:00 <tromp_>  fp complete Haksell IDE is awesome, just not free:(
11:04:02 <jml> Cale: yeah, thanks.
11:04:07 <Cale> kqr: I dunno, ghci has quite a lot of stuff in it these days
11:04:12 <Cale> It has a debugger
11:04:50 <Bram> ipython goes to the point of having a web interface and a cluster mode, I don't think that ghci have that (or would want to have that)
11:05:48 <Bram> oh, and a qt interface too
11:06:17 <Cale> I don't see any conceptual reason that this kind of stuff couldn't be in GHCi, if people were willing to write it. The QT interface would be a little more tricky, because of the dependencies.
11:07:09 <kqr> Cale, most interactive interpreters have some measure of debugging abilities (in my experience, anyway)
11:07:53 <jml> there _is_ a thing called ihaskell, which plugs into the ipython interface
11:08:07 <jml> but I couldn't get it to work when I tried it.
11:08:16 <jml> https://github.com/gibiansky/IHaskell
11:09:17 <kqr> i might want to try that out later. it looks cool
11:10:06 <fizbin> Is there any cabal command for "show me the ghc options you would use when compiling file X if you were asked to"?
11:10:36 <dcoutts> fizbin: cabal build --with-ghc=echo
11:10:48 <fizbin> Heh. Maybe...
11:10:59 <dcoutts> might need to be a wrapper that really calls ghc
11:11:34 <fizbin> Yeah. I get:
11:11:35 <fizbin> setup: ghcInvocation: the programVersion must not be Nothing
11:16:39 <monochrom> there is also "cabal build -v"
11:16:56 <fizbin> Yeah, but I want a fast command...
11:17:14 <monochrom> wait, how is "cabal build -v" not "fast"?
11:17:27 <dcoutts> fizbin: we don't yet support individual file targets anyway
11:17:42 <evancz> Hi, I'm coding up a basic REPL in Haskell, and I am curious how to handle arrow keys and ^C in a platform independent way
11:17:43 <dcoutts> just whole components at the moment
11:17:56 <evancz> are there libraries or projects for this?
11:17:57 <dcoutts> evancz: haskeline
11:18:11 <evancz> dcoutts: thanks, I'll check it out :)
11:18:15 <fizbin> I'm trying to figure out how to tie hdevtools to a cabal sandbox properly.
11:18:33 <mzero> are you trying to do full screen stuff in the terminal?
11:18:48 <evancz> mzero: me?
11:18:51 <mzero> yeah
11:19:07 <monochrom> ghci uses haskeline
11:19:21 <dcoutts> fizbin: do you really mean a sandbox, or just any .cabal file (and perhaps if configured within a sandbox)
11:19:22 <evancz> no, just basic REPL stuff, so only things needed by ghci or python's interactive mode, etc.
11:19:48 <mr-> monochrom: cool, too bad it's not in the platform
11:19:48 <evancz> mzero: is there something for full screen stuff?
11:20:03 <evancz> that'd be pretty awesome :)
11:20:18 <fizbin> dcoutts: Well, eventually, I suppose any cabal file. For now I'd accept it if it only worked when inside a cabal sandbox env.
11:20:31 <mzero> there are at least two packages that support standard termcap stuff for doing full terminal screen stuff
11:20:45 <dcoutts> fizbin: if you only care about a sandbox env, but not actually about any .cabal file then that's easy
11:20:50 <mzero> those should work via any terminal emulator - though I don't know how well supported on Windows
11:20:59 <dcoutts> fizbin: because it's just a matter of using the package db
11:21:31 <dcoutts> fizbin: but I suspect that what you're really after is using the same environment as cabal build/repl use for particular components
11:21:31 <fizbin> dcoutts: And guessing the right source directory path.
11:21:57 <evancz> mzero: what are they called?
11:22:16 <fizbin> dcoutts: As I said, eventually. For now I just want my in-emacs hdevtools integration to behave.
11:23:22 <mzero> evancz: hscurses
11:23:24 <mzero> @hoogle hscurses
11:23:25 <lambdabot> package hscurses
11:23:25 <lambdabot> package hscurses-fish-ex
11:23:29 <mzero> @hackage hscurses
11:23:29 <lambdabot> http://hackage.haskell.org/package/hscurses
11:23:36 <mzero> that's the one I've used
11:23:44 <evancz> ah, okay, bindings to curses probably
11:23:56 <evancz> gotcha
11:23:58 <evancz> cool :)
11:25:22 * hackagebot th-desugar 1.2.1 - Functions to desugar Template Haskell  http://hackage.haskell.org/package/th-desugar-1.2.1 (RichardEisenberg)
11:27:33 <lpaste> rekahsoft pasted “Hakyll getMetadataField with teasers” at http://lpaste.net/95002
11:27:48 <evancz> okay, thanks folks :)
11:34:57 <Tuplanolla> Haddock doesn't produce anything. What's up with that?
11:35:01 <Tuplanolla> Here's what happens: https://www.refheap.com/20301
11:36:59 <dcoutts> Tuplanolla: tell it to generate --html
11:39:00 <Tuplanolla> That seems to work, thanks. Why isn't it mentioned anywhere that it doesn't generate files by default?
11:41:07 <Tuplanolla> You know least astonishment and all that.
11:44:16 <Cale> Tuplanolla: Another thing you can do is to write a .cabal file for your project and then run "cabal haddock", which *will* default to generating html.
11:44:25 <Cale> But you're right, that is weird.
11:45:00 <Tuplanolla> It deserves a mention on the man page or the usage summary.
11:45:00 <argiopetech> Is there an equivalent to GHC.IOBase which exports the IO constructor in 7.7/7.8? It seems to have disappeared from base-4.7
11:50:04 <Cale> argiopetech: I think that module is part of ghc-prim rather than base, but I don't know about its status in 7.8
11:50:57 <Narvius> It's there a function Eq a => [a] -> [a] that removes all duplicates, but doesn't leave one remaining, unlike nub? Aka [1,1,2,3] becomes [2,3]
11:51:35 <geekosaur> ghc-prim:GHC.Types ?
11:51:36 <Narvius> Or, equivalently, that only leaves duplicates
11:51:55 <Cale> Narvius: Well, you can do things with group if you sort the list
11:51:56 <geekosaur> hm, no
11:52:05 <argiopetech> geekosaur: Looks like it.
11:52:07 <argiopetech> Good call
11:52:08 <pavonia> > (\l -> l \\ nub l) [1,1,2,3]
11:52:10 <lambdabot>   [1]
11:52:14 <Cale> > concat . filter (null . tail) . group . sort $ [1,1,2,3,4,4,5]
11:52:15 <lambdabot>   [2,3,5]
11:52:17 <geekosaur> well, it re-exports it
11:52:25 <geekosaur> it doesn't define it
11:52:36 <argiopetech> That's fine by me.
11:52:38 <Narvius> Cale: Sensible. Didn't think of that. Thanks.
11:52:40 <Cale> > concat . filter (null . tail) . group . sort $ "mississippi river"
11:52:41 <lambdabot>   " emv"
11:52:48 <quchen> What prevents expressions like "x = x" in dependently typed languages (Agda)? In particular, what does Haskell's type system not have so these are allowed?
11:52:55 <argiopetech> I just need it to get DonS' magic to compile.
11:53:21 <Narvius> :t groupBy
11:53:22 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
11:53:28 <n-dolio> quchen: You mean, definitions like that?
11:53:34 <quchen> n-dolio: Yes
11:53:41 <n-dolio> Agda has a termination checker that will rule that out.
11:53:42 <Narvius> :t comparing
11:53:43 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
11:53:49 <Cale> quchen: Explicit structural rules which require recursion to be descending.
11:54:01 <Narvius> :t compare
11:54:02 <lambdabot> Ord a => a -> a -> Ordering
11:54:20 <quchen> n-dolio: Ah, so it's not an intrinsic property of the type system to disallow this - the type system enables termination checking though.
11:54:22 <quchen> ..?
11:54:24 <Sculptor> hello
11:54:27 <argiopetech> geekosaur: It looks like it's newtype defined in GHC.Types in 7.7.
11:54:29 <n-dolio> In lots of type theory formalisms, there isn't even any native notion of self-reference, so it's just impossible to write that.
11:54:42 <geekosaur> I was poking at the master ghc repo
11:54:54 <quchen> n-dolio: What makes it impossible? No naming?
11:55:17 <n-dolio> There are names. There's just no recursive definition construct.
11:55:31 <quchen> Ah, okay. Thanks
11:55:32 <Cale> quchen: Well, if x just isn't in scope in the definition of x, then you can't refer to it
11:55:41 <quchen> Right.
11:56:25 <n-dolio> For instance, you'd take foldr as primitive, rather than saying that (some) recursive definititons with pattern matching could be desugared to foldr.
11:56:53 <Cale> quchen: you might find the Coq documentation's section on Fixpoint useful http://coq.inria.fr/distrib/current/refman/Reference-Manual003.html#hevea_command14
11:57:00 <n-dolio> And anything recursive would have to be written in terms of the like of foldr.
11:57:35 <argiopetech> geekosaur: Odd. I'm running 7.7-20131027 and it's defined in ghc-prim:GHC.Types.
11:58:25 <geekosaur> hm.
11:58:35 <n-dolio> This is unrelated to being dependently typed, though.
11:58:38 <geekosaur> ...oh, I managed to miss the whole center of it by a bad scroll, it turns out
11:58:40 <geekosaur> whoops
11:58:45 <argiopetech> Heh
11:59:02 <geekosaur> missed IO, (~), and Coercible
11:59:16 <yitz> geekosaur: grep, don't scroll ;)
11:59:19 <quchen> n-dolio: I was wondering how those two related. (foldr as primitive, wow)
11:59:43 <quchen> Cale: Thanks, let's see how much I understand without having touched Coq much :-)
11:59:47 <n-dolio> quchen: There's an old language called Charity that does that.
11:59:59 <n-dolio> Research language.
12:01:11 <n-dolio> It has bracket syntax for folds and unfolds that you use to define functions.
12:01:12 <quchen> Cale: Oh, that was easier than I expected.
12:01:31 <quchen> n-dolio: Lists are primitive as well then?
12:01:40 <n-dolio> You can define arbitrary inductive and coinductive data types.
12:01:52 <n-dolio> And the brackets work for all of them.
12:02:31 <quchen> n-dolio: Wikipedia says it's younger than Haskell.
12:02:35 <Cale> quchen: If you know Haskell and/or some ML, most of Coq's language will be pretty understandable. There's the whole tactic-based approach to things which will be unfamiliar, but it's not too hard to pick up either (for the most part, you can think of tactics as a baroque way of writing lambda calculus terms with some fancy code-generating shenanigans)
12:02:51 <n-dolio> quchen: Well, Haskell is pretty old these days.
12:03:06 <xico> is unix the right package to get SIGINT and co?
12:03:25 <mauke> @hoogle sigint
12:03:25 <lambdabot> System.Posix.Signals sigINT :: CInt
12:03:33 <quchen> Cale: How about Agda? It seems more familiar when you come from a Haskell background. (In case I want to learn something dependently typed)
12:03:34 <n-dolio> quchen: Anyhow, you don't even need to go that route. System F just has typed lambda terms and polymorphism.
12:03:40 <Cale> Agda too :)
12:03:42 <n-dolio> And you can encode data types using just those.
12:03:50 <n-dolio> But there's no self-referential definitions at all.
12:04:10 <quchen> n-dolio: Remind me what is System F again? Hindley-Milner-typed lambda calculus?
12:04:42 <n-dolio> It is lambda calculus with higher-rank polymorphism, but only kind *.
12:05:29 <Cale> The *only* thing I have against Agda is that its standard library is hard on my hands to type.
12:05:30 <n-dolio> You can encode [A] as the type (forall r. (A -> r -> r) -> r -> r)
12:05:51 <n-dolio> Or, finite lists, at least.
12:06:20 <quchen> Cale: What kind of hands do you use?
12:06:24 <Cale> heh
12:06:48 <quchen> n-dolio: Infinite lists are forbidden I assume
12:07:04 <n-dolio> You can have potentially infinite lists, but then you can only unfold them, not fold them.
12:08:05 <yitz> apple is trying to push me the mavericks upgrade now. is there a definitive url about what to do?
12:08:40 <startling> haskell-wise? http://www.haskell.org/pipermail/haskell-cafe/2013-September/110320.html
12:09:07 <yitz> startling: tnx! i'll look.
12:11:48 <yitz> startling: well then the question is: if i don't have xcode installed, only v4.6 CLI tools, will the mavericks upgrade change that? if so, is there any way to revert?
12:12:18 <yitz> that is revert to just v4.6 CLI on mavericks
12:13:00 <johnw> you can't get xcode 5 working?
12:13:26 <mzero> if you stick with Xcode 4 , and upgrade to Mavericks
12:13:29 <startling> yitz: I don't know.
12:13:33 <mzero> then all you need are to set some env. vars.
12:13:38 <startling> carter might.
12:13:51 <mzero> upgrading to Mavericks is independent of upgrading to Xcode 5
12:14:18 <mzero> yitz: stick with 4.6 CLI tools and you'll be fine I think
12:14:27 <carter> brb in a bit
12:14:29 <carter> on phone
12:14:30 <geekosaur> um. I would not want to bet on xcode 4 working fully on 10.9, knowing apple
12:14:35 <carter> yup
12:14:36 <carter> that too
12:14:40 <mzero> I have Mavericks and Xocde 4.6.1 and 4.6 CLI tools
12:14:41 <carter> install your own gcc
12:14:48 <carter> and xcode 5 works fine :)
12:14:59 <yitz> mzero: yay! thanks
12:15:06 <mzero> as far as compiling Haskell goes, this set up works
12:15:23 <mzero> there really is no reason that Xcode 4 won't continue to work under 10.9 - you just don't get the 10.9 SDK
12:15:26 <yitz> mzero: we really really need to say something about this on the HP Mac page.
12:15:36 <mzero> well - frankly - we are still working out what to say
12:15:43 <mzero> I only discovered some of this in the last hour!
12:15:45 <yitz> mzero: urgently, now that apple is pushing out mavericks to everyone by default for free
12:15:51 <yitz> wow
12:16:15 <yitz> mzero: ok. thanks.
12:16:17 <mzero> I will try to get something on the site soon - perhaps tonight
12:16:27 <startling> yitz, ghc 7.8 fixes the issue and will be released soon.
12:17:11 <mzero> yitz: I found that I needed the following to get things to work:
12:17:12 <mzero> export SDKROOT=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.8.sdk
12:17:13 <mzero> export CPATH=$SDKROOT/usr/include
12:17:14 <mzero> export LIBRARY_PATH=$SDKROOT/usr/lib/system:$SDKROOT/usr/lib
12:17:19 <yitz> mzero: being in my current situation, do you want me to try something? (on condition that it's very unlikely that i'll irrevocably haskell-brick my mac)
12:17:56 <mzero> your mileage may vary here -- and if it does - PLEASE e-mail me
12:18:10 <yitz> mzero: will do. thanks!!
12:18:27 <mzero> yitz, after you upgrade to 10.9, but leaving all Xcode stuff untouched - let me know if /usr/include is still present
12:18:35 <mzero> if so, you probably don't need the above
12:18:46 <yitz> mzero: ok. i'll probably try all this tomorrow.
12:19:06 <mzero> if it is gone... then we need to find out where the CLI tools left the include files
12:19:28 <mzero> for me, as I have Xcode 4 installed, they were still in  /Applications/Xcode.app/Contents/Developer
12:19:40 <user123abc> is there any syntax to hide all accessors related to the records of some data type when importing a module?
12:20:03 <yitz> mzero: hmm ok. i don't have xcode 4 and probably won't be able to get it after i'm on mavericks.
12:20:08 <mzero> import  Some.Module (DataType)
12:20:23 <mzero> yitz - sure you will - it is just a download from developer.apple.com (assuming you can download from there)
12:20:32 <yitz> mzero: but doesn't it seem unlikely that CLI tools won't come with the includes?
12:20:35 <mzero> but yes - that is a small worry....
12:21:32 <yitz> mzero: also i have almost no disk space. i have an external drive with plently of space, but in practice a lot of installers don't know how to deal with that.
12:21:55 <mzero> I think they did come with the includes, but it is possible that 10.9 trashes /usr/include.... you might consider saving a tarball of /usr/include and /usr/lib before you upgrade (not that you'd ever want to use that /usr/lib again - but you might need it for some static libs - so you'd have to unpack it somewhere else and delete all the dynlibs....)
12:22:16 <yitz> mzero: right. ok.
12:22:19 * mzero >>= lunch &&& meetings
12:22:38 <yitz> mzero: ok have fun tnx !!
12:28:55 <xico> i am having this funny error message with ffi:
12:28:59 <xico> Unacceptable argument type in foreign declaration: GHC.Int.Int32 -> Ptr () -> GHC.Int.Int32
12:29:11 <xico> (where the 1st arg and ret val are CInt)
12:29:36 <mauke> what's the foreign declaration?
12:29:49 <xico> while trying to define a wrapper whose type is CFunction -> FunPtr CFunction
12:30:01 <xico> and CFunction is the CInt -> Ptr () -> CInt
12:30:08 <mauke> ok, that makes sense
12:30:19 <mauke> functions aren't values in C
12:30:22 <xico> mauke: glad to hear so
12:30:25 <xico> mauke: ouch
12:30:26 <mauke> you can't have an argument with a function type
12:31:56 <xico> mauke: isn't it what they are doing in https://en.wikibooks.org/wiki/Haskell/FFI#Passing_Haskell_Functions_to_the_C_Algorithm
12:32:02 <xico> for the "wrapper" function?
12:32:34 <mauke> I'll wait for the answer to my question
12:33:04 <xico> mauke: the foreign declaration?
12:33:38 <mauke> yes
12:33:56 <lpaste> xico pasted “FFI” at http://lpaste.net/95003
12:34:36 <lpaste> xico revised “FFI”: “No title” at http://lpaste.net/95003
12:34:46 <mauke> yeah, that's not a wrapper, that's a static import
12:35:17 <xico> mauke: ah!!!
12:35:19 <xico> thanks
12:35:23 <xico> i totally forgot about that
12:35:26 <xico> :)
12:35:57 <xico> (i mean the fixed "wrapper" name)
12:36:38 <mauke> "wrapper" is not the name
12:36:45 <mauke> a wrapper has no name
12:37:00 <mauke> http://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1620008.5.1
12:41:36 <dEPy> am
12:42:17 <dEPy> I have a point p0 and list of points and a function angleWithXaxis which takes 2 points and return angle between these two and x axis
12:42:26 <chrisdone> give them back!
12:42:29 <dEPy> how can I sort list of points based on that angle?
12:42:44 <chrisdone> sortBy (comparing angleWithXaxis)
12:43:24 <sdrodge> Hi, I have a question about how best to implement something. I have a Vector x full of values, and a Vector y full of indices of x. I want to decrement each value in x which corresponds to an index in y, and as a side-effect update another value that is a summative measure of x. I'm hoping to accomplish this with exactly one allocation (for the combination new result vector and updated measure) and with one
12:43:27 <sdrodge> loop.
12:43:45 <dEPy> i chrisdone im stuck with sortBy :)
12:44:07 <dEPy> hm
12:44:41 <dEPy> sortBy (angleWithXaxis point) list    doesnt work
12:44:49 <chrisdone> :t sortBy
12:44:50 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
12:44:53 <dEPy> oh wait, sorting function should return ordering
12:44:56 <dEPy> yea that :/
12:44:56 <chrisdone> :t comparing
12:44:57 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
12:45:20 <danr> :t compare
12:45:21 <dEPy> :info comparing
12:45:21 <lambdabot> Ord a => a -> a -> Ordering
12:45:35 <chrisdone> comparing is from Data.Ord
12:46:06 <chrisdone> > sortBy (comparing fst) [(4,2),(7,3),(23,5)]
12:46:09 <lambdabot>   [(4,2),(7,3),(23,5)]
12:51:59 <sdrodge> Anybody willing to help with mutable vectors and State?
13:00:55 <user123abc> livestreaming myself working on a toy compiler in haskell: http://www.justin.tv/gosu___#/w/7330757664
13:01:00 <user123abc> not sure if I'll stick with it
13:03:03 <dEPy> ok I can't get it to work... here's the code: https://gist.github.com/depy/7239146
13:03:34 <dEPy> I need to sort list of points based on angle between (point from a list and one another point) AND axis X
13:03:45 <dEPy> I have function that calculates the angle
13:03:53 <carter> monochrom: https://gist.github.com/cartazio/7131371 is the current tested xcode 5 directions
13:03:55 <carter> taht works for folks
13:04:05 <carter> should we update the status to point to that?
13:04:28 <monochrom> ok yes. do you want to replace "xcode 5 issues?" too?
13:06:12 --- mode: ChanServ set +o monochrom
13:06:15 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://bit.ly/1hcZveF' by monochrom
13:06:22 --- mode: monochrom set -o monochrom
13:07:29 <mzero> okay okay - I'll try to get the script to run tonight... I really don't want to point people at a solution that requires brew installs
13:07:53 <carter> mzero: theres no brew installs required
13:07:57 <carter> i also linked to Manuels directions
13:07:59 <carter> re read it :)
13:08:21 <sdrodge> dEPy: ys = sortBy (comparing angleWithXaxis) xs
13:08:54 * monochrom will not use bit.ly next time. principle: a shortener service must provide me with the option of seeing the real URL before sending me to it
13:08:59 <jle`> sdrodge: shoot
13:09:07 <monochrom> e.g., tinyurl.com has that option
13:09:34 <mzero> carter: "brew install apple-gcc42"
13:09:39 * monochrom does not understand why so many people ignore that issue
13:10:03 <dEPy> carter: angleWithXaxis takes 2 parameters, but I figured it out, just had to curry (partially apply?) it with one fixed point
13:10:19 <jle`> for a url shortener service, tinyurl sure is a long url
13:10:23 <khyperia> I'm trying to install leksah. Installing from cabal gives multiple errors (I can go through them if you want), and the highest leksah ghc download is 7.4.1, and on my machine ghc --version says 7.6.3. Are they compatible?
13:10:25 * monochrom understands. the same people carelessly clicks every url in sight, has no-privacy facebook settings, etc etc
13:10:28 <mzero> monochrom: because it is meaningless: What it shows you might redirect further
13:10:49 <alexander__b> what's a more idiomatic way of doing "if health > 0 then Just blah else Nothing?
13:10:51 <alexander__b> "
13:10:51 <jle`> mzero: it's meaningful if you trust the other party perhaps
13:10:54 <monochrom> it is not meaningless. I don't have to follow it after reading it
13:10:59 <mzero> perhaps -
13:11:07 <dEPy> What's the proper wording? To curry a function or partially apply? Or is it the same?
13:11:10 <jle`> alexander__b: is blah a function of health or just a constant
13:11:12 <carter> mzero: read the ALTERNATIVE line
13:11:50 <mzero> carter - below the fold, and so people will assume the first is the way - it is, afterall, what we're pointing them to
13:11:51 <alexander__b> jle`: I'll just post the entire snippet
13:12:18 <monochrom> look, if the expansion is "haskell.org/etcetc" or even "reddit.com/r/lolcats" I'll follow it. if it is "randomshopmall.com" I will not follow it
13:12:20 <alexander__b> I'm sure most of this is kind of ugly, so suggestions are welcome: http://lpaste.net/8321315362939338752
13:12:46 <mzero> and - those wrapper instructions have to be done ... before you clobber GHC! since you need to compile the wrapper!
13:12:57 <carter> mzero: nope
13:12:58 <carter> brb
13:13:01 <carter> phone
13:13:19 <sdrodge> jle`: I have x :: Vector Int8 and y :: Vector Int, where x holds values and y holds a subset of x's indices. I also have a variable that holds some summative measure of x, I want to decrement the value in x corresponding to each index in y, while updating x's summative measure as a side-effect. I also want to make sure that only one allocation is done.
13:13:33 <monochrom> you are probably saying, what if "tinyurl.com/xyz" expands to "bit.ly/abc". ok, clearly, I won't follow it. double indirection is clearly to be distrusted.
13:14:51 <jedai> monochrom: And the sign of a disturbed mind ... ;)
13:16:19 <alexander__b> jle`: oh, so the answer to your question, blah is "make a new entity with h' as a parameter to the constructor"
13:16:53 <jle`> sdrodge: you mean some sort of MVector, right?
13:18:11 <jle`> and is your measure variable mutable as well?
13:18:24 <sdrodge> jle`: I assume that I will have to use one to accomplish this, but the Vectors are immutable; I'm generating new ones, I just want to make sure it only requires one allocation.
13:20:06 <jle`> sdrodge: yes you can do this with one allocation of x
13:20:11 <sdrodge> jle`: In other words, I want a pure function (Vector Int8, Measure) -> Vector Int -> (Vector Int8, Measure)
13:20:25 <sdrodge> jle`: that doesn't cause excess allocation
13:20:37 <jle`> sdrodge: yes, you can achieve it with the ST monad and runST
13:21:06 <sdrodge> jle`: Fantastic! That is what I figured, but I'm not sure how to go about it.
13:21:55 <jle`> not sure how familiar you are with this, but you can think of ST a as a description of a self-contained computation involving mutable state, and runST will "run" that computation in a referentially transparent/pure way
13:23:14 <user123abc> jle`, are you saying that even an immutable vector can avoid copying if using ST?
13:23:36 <mm_freak_> jle`: i can't help with the problem you have right now, but remember that the vector library performs stream fusion
13:24:12 <mm_freak_> and it's terrible at mutable vectors anyway…  i recommend going with immutable vectors
13:24:56 <jle`> user123abc: no, ST only benefits to mutable vectors
13:25:18 <user123abc> it's also required for mutable vectors, hence my confusion
13:25:22 <jle`> but ST is a self-contained computation, so it does not affect any state outside of itself
13:25:23 <user123abc> but I see what you're saying
13:26:24 <jle`> mm_freak_: not my problem but sdrodge, but i actually haven't looked into vector's stream fusions.  it sounds like something worth looking into
13:26:37 <sdrodge> jle`: I get that much (or at least think I do :p). I assume that the way to pull this off is to make a State computation that starts by making an MVector copy of the Vector and ends by freezing the MVector to a Vector, but I'm not sure how to pull off the updating of the Measure.
13:27:01 <mm_freak_> jle`: that together with fast operations is the main selling point of vector…  i'm surprised it's news to you =)
13:27:17 <jle`> mm_freak_: i'm new to haskell so much is news to me ;)
13:27:22 <mm_freak_> sdrodge: State and ST are completely different things
13:27:35 <mm_freak_> sdrodge: in particular State does not give you mutable variables, much less mutable vectors
13:27:40 <user123abc> sdrodge, you'll want to use unsafeThaw to make that mvector, as regular freeze and thaw will make actual deep copies
13:27:43 <mm_freak_> jle`: ah, ok =)
13:27:50 <jle`> mm_freak_: is the stream fusion automatic? or does it have to be explicit
13:27:56 <mm_freak_> jle`: automatic
13:28:07 <jle`> hm.
13:28:26 <sdrodge> mm_freak_: ST = State Transformer, right?
13:28:43 <jle`> my first ever non-baby haskell project was a metro-hastings monte carlo algorithm, and switching from Vector to MVector was orders of magnitude of an improvement
13:28:56 <startling> sdrodge: no.
13:28:57 <mm_freak_> jle`: when f and g are "subject to fusion" (see haddocks), then things like 'f . g' and 'f (g x)' won't use an intermediary vector
13:29:09 <mm_freak_> sdrodge: ST = strict state thread
13:29:21 <user123abc> fusion isn't so relevant to sdrodge's problem, though
13:29:34 <sdrodge> startling, jle`, __mm_freak: Thank you all for the enlightenment, I shall go and read up on ST.
13:29:53 <mm_freak_> sdrodge: it's a way to use mutable variables within pure computations…  it's essentially a constrained IO
13:30:15 <sdrodge> Sounds awesome, thank you.
13:30:20 <jle`> sdrodge: yeah it's basically an IO that isn't allowed to touch anything else
13:30:29 <user123abc> there's a simple example of mutable vector use and conversion here:
13:30:33 <user123abc> http://hackage.haskell.org/package/vector-0.10.9.1/docs/Data-Vector.html#v:create
13:30:34 <jle`> i actualyl have some resources from when i was learning it ... i learned to use ST by using mvec's too
13:30:53 <user123abc> I found that to be helpful, as the types of mutable vector code are a little scary
13:31:19 <mm_freak_> sdrodge: in any case you're using more than one related value, so it might be worth writing a type
13:31:43 <mm_freak_> data Stuff = Stuff { stuffX :: Vector Int, stuffY :: Vector Int8, … }
13:31:52 * donri learnt ST by retrofitting it for enforcing concurrency-safe access to a struct while writing FFI bindings ;p
13:32:07 <sdrodge> mm_freak_: That's exactly what I have, just was simplifying my question.
13:32:09 <startling> :)
13:32:14 <user123abc> donri, uphill both ways and in the snow?
13:32:20 <donri> :)
13:32:23 <mm_freak_> sdrodge: then you would have simplified it by pasting what you have right now =)
13:32:42 <donri> granted, i mostly understood ST before; this was just the first real use. :)
13:32:42 <mm_freak_> sdrodge: if you already have code, there is really no reason to turn it into informal text ;)
13:33:36 <sdrodge> mm_freak_: You make a good point.
13:33:45 <mm_freak_> i haven't used ST for a long time
13:33:57 <mm_freak_> perhaps i should rethink my problems =P
13:34:07 <mm_freak_> or perhaps you really don't need it that often =)
13:34:41 <mm_freak_> given that ST is still ConstrainedIO it's usually a last resort =)
13:34:46 <donri> in my case i could easily have made my own monad with a higher-ranked run function. but reusing ST is probably more useful as you get all the other ST stuff.
13:36:28 <sdrodge> mm_freak_: Perhaps I'm just going about this the wrong way, then. I am rewriting a bestFirst search that was performing badly when parallelized to try to cut down on heap churn.
13:36:58 <carter> mm_freak_:sdrodge: parallel breadth first search would need some Mvars
13:37:04 <carter> to coord "has anyone been there yet"
13:37:55 <donri> mm_freak_: I guess ST sees less use than one might think because it forces code to be monadic and you have to make copies to return something mutated (e.g. Vector.thaw) so it's not always a win
13:38:34 <user123abc> see comment about unsafeThaw above
13:38:36 <sdrodge> mm_freak_, carter: It was greedyBestFirst, with fairly conservative sparking, but I suspected that doing lots of math on pure Arrays was causing the 60 billion bytes of allocation for a program with only 190KB max residency
13:38:48 <carter> urk
13:39:07 <mm_freak_> carter: what?!
13:39:27 <carter> 60gb of churn on 190kb live dat?
13:39:28 <mm_freak_> a breadth-first search seems to be easy to parallelize without any impure code
13:39:29 <carter> *data
13:39:31 <carter> ah
13:39:45 <carter> mm_freak_: bounded depth would make it behave better
13:39:54 <carter> do the parallelism in "generations"
13:39:58 <donri> user123abc: i imagine it's not called unsafe for no reason :)
13:40:03 <mm_freak_> carter: that's what i was about to suggest
13:40:07 <carter> ok
13:40:10 <carter> cool
13:40:11 <sdrodge> mm_freak_: How do you synchronize the priority queue?
13:40:13 <carter> i'll leave you to dthat
13:40:17 <mm_freak_> sdrodge: spark only to a specific level
13:40:23 <mm_freak_> sdrodge: what priority queue?
13:40:47 <sdrodge> mm_freak_: It's a best-first search.
13:41:00 <mm_freak_> donri: it doesn't force code to be monadic, it forces it to be imperative, and i appreciate the distinction =)
13:41:04 <carter> so you have a monoidal concat
13:41:09 <donri> mm_freak_: heh
13:41:49 <user123abc> donri, the reason is documented
13:41:49 <sdrodge> mm_freak_: I assumed "breadth-first" was just a(n inaccurate) way to say A* in this context.
13:41:57 <donri> user123abc: i'm aware
13:42:53 <mm_freak_> sdrodge: perhaps your main problem is Vector
13:43:04 <mm_freak_> sdrodge: because best-first sounds like you want to just recurse on a data structure
13:43:40 <mm_freak_> sdrodge: if you follow the description on wikipedia literally you will write imperative code…  the algorithm descriptions are usually written by imperative-minded people
13:44:33 <mm_freak_> there is absolutely nothing imperative about best-first
13:46:13 <sdrodge> mm_freak_: The problem to be solved consists of a rectangular matrix with entries from Z/n w/ n>=2 and a collection of smaller rectangular matrices with entries from Z/2. A solution consists of placing each of the series of smaller matrices on the larger matrix exactly once, adding them (mod n) element-wise as you do so. The final result must be the zero matrix.
13:47:23 <mm_freak_> sdrodge: quadratic sieve?  number field sieve?  dixon's factoring method? =)
13:47:44 <sdrodge> I'm starting to become very glad I came in here.
13:48:24 <carter> oooo
13:48:26 <carter> number theory! :)
13:48:38 <mm_freak_> sdrodge: so you're trying to find the left null space?
13:48:47 <carter> ooo
13:48:52 <carter> theres some neat things you could o
13:48:55 <carter> @hackage tagged
13:48:55 <lambdabot> http://hackage.haskell.org/package/tagged
13:48:57 <carter> might be releant
13:49:13 <mm_freak_> carter: indexed types would probably confuse sdrodge right now
13:49:17 <carter> oh
13:49:18 <carter> ok
13:49:23 <carter> so no mention of
13:49:26 <carter> @hackage reflection
13:49:26 <lambdabot> http://hackage.haskell.org/package/reflection
13:49:27 <carter> this week
13:49:29 <carter> gotcha
13:49:36 <carter> dont look (at least not yet)
13:49:43 <sdrodge> mm_freak_: I'd be delighted to be confused.
13:49:56 <sdrodge> I promise I'm a quick study.
13:50:14 <carter> i do need to learn about varieties and sheaves and how they releate to finite fields
13:50:25 <carter>  well, at least if i want to understand some research a friend does
13:50:30 * hackagebot Elm 0.10.0.2 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.10.0.2 (EvanCzaplicki)
13:50:46 <sdrodge> mm_freak_: Are indexed types Sigma-types (from intuitionistic type theory)?
13:50:49 <mm_freak_> sdrodge: what carter is suggesting is to encode the modulus on the type level
13:50:52 <carter> yes
13:50:53 <carter> that
13:51:21 <mm_freak_> sdrodge: sigma types are a special kind of indexed type, and haskell does not give you those at all
13:51:28 <carter> yup
13:51:31 <sdrodge> So, what's being suggested, exactly?
13:51:32 <mm_freak_> sdrodge: however, haskell does allow you to lift values up to the type level
13:51:33 <carter> idris is where you need to go for that
13:51:47 <carter> sdrodge: basically be able to run with a shared modulus
13:51:48 <mm_freak_> sdrodge: newtype Mod n a = Mod a
13:51:50 <carter> yes
13:51:53 <lpaste> Dodek pasted “ghci misbehaving” at http://lpaste.net/95004
13:52:00 <Dodek> hey, i have a problem with ghci misbehaving
13:52:03 <mm_freak_> instance (Integral a, Modulus n) => Num (Mod n a)
13:52:13 <Dodek> it doesn't see a function that should be in scope
13:52:17 <carter> mm_freak_: not necesarrliy
13:52:27 <Dodek> and suggest me the function i meant
13:52:29 <carter> because you maybe want to use the reflection like suff
13:52:31 <carter> *stuff
13:52:35 <Dodek> but it prints it without backtick in front of it
13:52:37 <mm_freak_> carter: sure
13:52:38 <carter> so you don't ahve to write a type at the type leve
13:52:48 <mm_freak_> carter: type Modulus n a = Reifies n a
13:52:49 <mm_freak_> =)
13:52:56 <mm_freak_> instance (Integral a, Modulus n a) => Num (Mod n a)
13:53:32 <carter> something like that
13:53:42 <sdrodge> carter, mm_freak_: Is there a performance and/or code cleanliness benefit to creating this Mod type family?
13:53:43 <carter> there may be some subtleties
13:54:01 <carter> sdrodge: yes, you can make all the operations "share" the modulus values
13:54:05 <carter> ignore it for now
13:55:03 <sdrodge> Ok, I'll add it to my reading list. I'm definitely interested in what was being said about a different approach to computing the solution
13:55:08 <mm_freak_> sdrodge: i know i shouldn't say this, but it will let you write x^y and the type system will figure out that you want square-and-multiply modulo a certain modulus =)
13:55:41 <carter> yes
13:55:42 <carter> that
13:55:49 <carter> but punt on it for now
13:55:52 <sdrodge> mm_freak_: Sounds suspiciously like dependent types....
13:55:55 <carter> nope
13:56:00 <carter> its related
13:56:02 <carter> but not the same thing
13:56:14 <carter> its more like a saner version of C++ templates parameters
13:56:15 <carter> ish
13:56:16 <carter> well
13:56:17 <carter> thats a lie
13:56:22 <carter> its mostly unrelated
13:56:26 <carter> but you can use it for overlapping things
13:57:12 <sdrodge> Perhaps I could get feedback on the code as it is now? I'm sure there are a million things I could be doing better.
13:57:17 <carter> sure
13:57:20 <carter> share early and often
13:57:27 <carter> though I fail at that almost surely and often
13:57:43 <sdrodge> The questions I was asking today were more about the rewrite, but I'll share the current one also
13:58:08 <sdrodge> https://github.com/sjdrodge/neopets_shapeshifter
13:58:15 <sdrodge> Be brutal!
13:58:44 <carter> looks decent
13:59:39 <sdrodge> Part of the rewrite includes using Generics to get rid of all the manual JSON instances.
14:00:51 <sdrodge> My intention with the Vector stuff was to stop wasting the effort of storing/computing on the zeros in the GameShapes
14:01:07 <sdrodge> and also to incrementally update the distance heuristic
14:01:13 <sdrodge> instead of summing the entire board each time
14:01:32 <augur> my impromptu monad tutorial got more upvotes, both net *and* gross, than the original posted comment
14:01:37 <augur> er, posted content**
14:01:43 <augur> im quite happy about this :D
14:01:47 <hpc> augur: linky?
14:01:51 <augur> http://www.reddit.com/r/programming/comments/1pj3bs/monads_and_gonads_a_google_tech_talk_presented_by/
14:02:02 <danr> gonads... :p
14:02:08 <sdrodge> mm_freak_: Can you give me some more information about the sieves you were mentioning earlier and how they apply to this problem?
14:03:14 <hpc> that video is awful just on the title alone
14:03:18 <augur> danr: yeah, thats one of the reasons i responded. to draw people away from the video. i have no idea why crockford felt the need to bring gonads into the talk, nor do i know how he did so since i didnt watch it
14:03:30 <augur> im sure it was some casual sexism
14:03:55 <simpson> It's not even a good talk.
14:04:04 <augur> probably not. thats why i wrote the tutorial :p
14:04:12 <carter> sdrodge: i'll have to stare at your problem more to understand it
14:04:30 <mekeor> is there a nice function in the base-package which does the same as "foo f x = f x x" or so? or, is there a function which applies a function to both elements of a tuple, like "bar f (x,y) = (f x,f y)"? i'm using "f *** f $ (x,y)" for this purpose, at the moment.
14:04:31 <hpc> oh, it's in javascript too
14:04:41 * hpc closes tab with extreme prejudice
14:04:43 <lispy> augur: well, males and females both have gonads, so hopefully it was done without sexism (but I also have not watched it)
14:04:52 <monochrom> encoding monad in javascript is sad
14:05:00 <augur> lispy: it probably wasnt done without sexism.
14:05:08 <danharaj> it isn't a very good talk :3
14:05:24 <donri> i don't recall gonads ever coming up in the actual talk
14:05:30 <donri> which almost makes the title worse
14:05:34 <sdrodge> carter: Take your time. Thanks a lot for the help.
14:05:47 <carter> i'm a bit buried for the next month
14:05:48 <carter> :)
14:05:55 <sdrodge> carter: XD
14:06:02 <augur> i figured that a toy language like hutton's razor would provide some nice simple examples. im not entirely happy with the state version
14:06:35 <augur> i would've liked to have something else
14:06:56 <augur> but adding too much stuff would, i think, confuse the matter.
14:07:08 <monochrom> mekeor: as it happens, join f x = f x x. the monad used is "(->) r". r is the type of x
14:08:15 <mm_freak_> sdrodge: what you described sounded a lot like the final matrix step of dixon/QS/NFS
14:08:59 <moto9> lol, never ever used mapAccumL or mapAccumR, it's really time! :)
14:09:10 <carter> mm_freak_: you may have to explain what those acronyms are
14:09:12 <jle`> anyone know how printf does its magic?
14:09:25 <mm_freak_> carter: quadratic sieve, number field sieve
14:09:32 <mm_freak_> i already mentioned them earlier
14:09:35 <carter> oh ok
14:09:43 <monochrom> scary factoring algorithms :)
14:10:11 * monochrom spent some time on the quadratic sieve when young
14:10:25 <mm_freak_> the NFS is scary, the QS is actually easy
14:10:38 * monochrom , in fact, spent that time instead of studying for exams!
14:11:21 <monochrom> multiple-polynomial quadratic sieve => parallelizable except the final matrix step :)
14:11:58 <monochrom> well, I guess NFS too. the final matrix step has always been the real problem and focus of ongoing research
14:12:39 <mm_freak_> monochrom: the final matrix step can be parallelized very well
14:12:44 <monochrom> there is a Springer collection of papers on NFS. basically every article suggests yet another way to try to do that matrix faster or with less memory :)
14:12:45 <mm_freak_> it just can't be distributed
14:12:50 <mm_freak_> parallelizing it requires shared memory
14:13:17 <mm_freak_> however, if you want to parallelize it, you have to use gauss
14:13:17 <monochrom> aha, well, yeah, I don't can't that as parallelizable, I'm anal about that
14:13:43 <mm_freak_> that sparse matrix algorithm (i always forget its name) can only be parallelized up to individual matrix operations
14:13:59 <carter> parse matrix mult is also darn subtle to tune well
14:14:07 <carter> really really really hard to tuen well
14:14:30 <carter> though i'm looking forward to dealing with tha tsoon
14:14:38 <mm_freak_> my approach was not to build the matrix and then solve it in a separate step
14:14:46 <mm_freak_> with each new relation, solve the matrix as far as you can
14:16:52 <mm_freak_> that has two advantages:  1. linearly dependent relations will be removed as part of that step, 2. the matrix never gets complicated in the first place
14:17:12 <lispy> danharaj: wow, yeah this talk is terrible
14:18:18 <sdrodge> mm_freak_: I'm not seeing the connection between factoring and trying to build the additive inverse of a modular matrix from smaller matrices.
14:18:20 <sdrodge> help?
14:19:07 <mm_freak_> sdrodge: additive inverse?
14:19:11 <carter> sdrodge: http://en.wikipedia.org/wiki/Finite_field_arithmetic#Multiplicative_inverse
14:19:12 <mm_freak_> like -M?
14:19:27 <carter> solving a matrix isn't additive inverse....
14:21:56 <mm_freak_> carter: we haven't actually established that sdrodge is /solving/ the matrix…  it just sounded like they did
14:22:05 <carter> well
14:22:05 <carter> umm
14:22:06 <carter>  yeah :)
14:22:12 <carter> finite fields are neat though
14:22:14 <sdrodge> mm_freak_: The problem entails a rectangular matrix with entries in Z/n (the "board") and a set of smaller rectangular matrices with entries in Z/2 (the "shapes"). Applying a shape to the board is doing element-wise addition. You have to use every shape exactly once and turn the starting board into the zero board.
14:22:43 <carter> sdrodge: nooooo
14:22:47 <carter> thats sounds wrong
14:23:08 <carter> urk
14:23:40 <carter> you have 0,1 entries
14:23:40 <carter> that have "patterns"
14:23:41 <carter> you can use to add to board
14:23:48 <carter> sums on board are in Z/N
14:23:56 <carter> they can't be z/2
14:24:10 <mm_freak_> sdrodge: so you have a smaller binary matrix?
14:24:12 <carter> you can't have sums from z/2 and z/n
14:24:13 <carter> yes
14:24:13 <sdrodge> Example: modularity: 2, board: [[0,0,0],[1,1,1],[0,0,0]], shapes: [[1,1],[1]]
14:24:13 <carter> that
14:24:20 <mm_freak_> carter: of course you can
14:24:25 <carter> well
14:24:29 <carter> but in which sense?
14:24:36 <sdrodge> The sums are in Z/n
14:24:39 <carter> ys
14:24:45 <carter> so binary entries in z/n
14:25:06 <mm_freak_> as long as n is odd, ℤ/nℤ and GF(2) are compatible by the chinese remainder theorem
14:25:06 <mm_freak_> that's at least one sense
14:25:12 <carter> yes
14:25:13 <mm_freak_> sdrodge: but the way i understand it:  both matrices are ℤ/nℤ
14:25:15 <carter> but in which sense
14:25:16 <carter> yes
14:25:17 <carter> that
14:25:17 <mm_freak_> but one just contains 0 or 1
14:25:23 <sdrodge> For the example puzzle I just gave, the solution is to apply the 1st shape at row 2 column 1, and apply the second shape at row 2, column 3
14:25:36 <sdrodge> (or rather, one of two solutions)
14:26:16 <sdrodge> mm_freak_: Sure, I only specified Z/2 because it's a useful restriction.
14:26:24 <monochrom> please don't model a shape by a matrix. in fact, please don't model a board by a matrix either.
14:26:57 <sdrodge> monochrom: You want me to use mappings?
14:27:35 <sdrodge> In the rewrite, I was planning to model shapes as Vectors of indices
14:28:06 <sdrodge> but I'm all ears when it comes to a better way of doing things
14:28:10 <mekeor> monochrom: oh, right... i think i knew that once. uhm. how do can i actually really *understand* the ((->) r) instance of monad?
14:28:34 <monochrom> a board is an array of Z/n. a shape is an operation that adds 1 to selected entries of a board. shapes form an abelian group. this group acts on boards. please use group theory and group actions and orbits etc
14:28:44 <quchen> mekeor: Maybe this helps? https://github.com/quchen/articles/blob/master/reader_instance_derived.md#bind
14:28:57 <mm_freak_> sdrodge: ah, now i understand it…  the "matrix" is really just a bitmap image =)
14:29:12 <sdrodge> mm_freak_: Yup.
14:29:15 <carter> ooo
14:29:15 <mm_freak_> if you say matrix, i think of a matrix ;)
14:29:16 <carter> thats neat
14:29:24 <carter> theres a bit of a combinatorial thing here too
14:29:46 <carter> like dynamic programming could work, but it might take a while
14:29:50 <carter> and it'd slow no matter what
14:29:59 <monochrom> mekeor: join :: M (M a) -> M a. instantiate M to (->) r. join :: (r -> (r -> a)) -> (r -> a). now you can plug in f :: r->r->a and x::r.
14:30:09 <sdrodge> monchrom: Can you be a little bit more specific about how you would model a group, and what benefit it would bring?
14:30:26 <carter> more math makes everything better :)
14:31:02 <johnw> carter++ :)
14:31:09 <carter> johnw: fact
14:31:09 <monochrom> I can't.
14:31:15 <carter> sdrodge: math is powah
14:31:16 <sdrodge> carter: I wasn't able to figure out how to turn this into a dynamic programming problem. If you can: I'll kiss you right on the mouth.
14:31:29 <carter> flattered but i'll pass
14:31:31 <carter> well
14:31:36 <carter> hrmm
14:31:37 <mm_freak_> sdrodge: the benefit of group theory is communication
14:31:40 <carter> yes
14:31:41 <carter> that too
14:31:52 <carter> sdrodge: lets break it into smaller problems
14:32:04 <carter> 1) given a "shape", what are ALLL the valid placements on the board
14:32:43 <mekeor> quchen: yeah
14:32:50 <mekeor> quchen: cool, neat :)
14:33:00 <mekeor> quchen: that helped (a bit) :)
14:33:14 <sdrodge> Sorry, let me clarify. I wasn't sure if monochrom was suggesting thinking about the problem in terms of group theory, or if monochrom was suggesting that there's some helpful type representation based on group theory that will make the coding easier.
14:33:20 <mekeor> monochrom: ah, right, i see
14:33:32 <quchen> mekeor: It at least deobfuscates the f (m r) r business. :-)
14:33:57 <mm_freak_> sdrodge: likely both =)
14:34:01 <monochrom> think about the problem in terms of group theory
14:34:10 <carter> "what are the valid moves"
14:34:23 <carter> "what are the valid moves that bring me closer to the solution"
14:34:41 <sdrodge> carter: Just subtract the dimensions to get the range of legal locations for the top left corner of the shape
14:34:57 <carter> oh, the pieces are all square?
14:35:01 <sdrodge> Yes.
14:35:02 <carter> thats good to know!
14:35:09 <startling> yeah, a stupid tree search may be viable depending on the size of your matrix.
14:35:11 <carter> yes
14:35:20 <sdrodge> I am currently doing a tree search
14:35:20 <carter> just dumb enumeration might work well for small enough boards
14:35:22 <carter> ok
14:35:29 <sdrodge> but I need better performance
14:35:30 <carter> sdrodge: have you used profiling?
14:35:37 <carter> ghc has AMAZING profiling
14:35:41 <carter> though a better algorithm always helps :)
14:35:49 <sdrodge> carter: Yeah, distance is the hotspot
14:35:50 <VonDraco> Should I always eta reduce whenever possible?
14:36:00 <carter> VonDraco: what ghc version?
14:36:01 <carter> and where?
14:36:02 <sdrodge> carter: Hence the rewrite I was working on
14:36:05 <carter> ok
14:36:05 <VonDraco> umm, the latest, i think
14:36:05 <carter> cool
14:36:12 <carter> HEAD or 7.6.*?
14:36:12 <mekeor> quchen: https://github.com/quchen/articles/blob/master/great_things_about_haskell.md#everyone-thinks-youre-weird :D hehe
14:36:14 <VonDraco> 7.6.3
14:36:23 <quchen> mekeor: :-)
14:36:26 <startling> List the possible cells given by all possible addition of submatrices, and only create boards that can be solved by those cells.
14:36:28 <augustss> carter: You're obviously more easily amazed than I. :)
14:36:38 <carter> augustss: oh?
14:36:54 <carter> augustss: egads, is this lennart?
14:37:12 <augustss> carter: ghc space profiling is good, but time profiling is very intrusive
14:37:15 <augustss> carter: yes
14:37:16 <quchen> mekeor: That file is somewhat out of date though, I should rework it
14:37:36 <Eduard_Munteanu> Interesting, it seems streams exhibit some foldl/foldr asymmetry. Namely, foldr is a foldr1, and foldl only exists for functions whose fixed points are non-diverging.
14:38:09 <carter> augustss: btw: Enigmagic  started a newer "llvm" dsl  https://gist.github.com/NathanHowell/6720691
14:38:15 <startling> Eduard_Munteanu: sure. streams have a start point but not an end point.
14:38:23 <sdrodge> carter,mm_freak_,monochrom,startling: Right now, I'm just doing a greedy best first search where the heuristic is: # of 1's in the remaining shapes - distance of current board from zero board. I also sort the shapes before beginning the search such that those with the smallest degree of freedom and those with the largest # of 1's are first.
14:38:37 <augustss> carter: good.  it needs a revision.
14:38:38 <carter>  augustss : was great meeting you at icfp
14:38:48 <carter> did you mange to chat with malcom about the CPP matter?
14:39:04 <carter> 'cause right now we have to give people some pretty unholy / intrusive work arounds
14:39:13 <carter> *manage
14:39:16 <mm_freak_> sdrodge: since i don't understand your application i can't really help much further
14:39:19 <augustss> carter: I mentioned it.  But he remains unconvinced.
14:39:37 <carter> ok
14:39:39 <carter> well
14:39:42 <carter> then we have to write another one
14:39:43 <carter> oh welll
14:39:46 <carter> g2g
14:39:47 <sdrodge> mm_freak_: Do you mean the problem, or the code? I'm happy to throw away all the code.
14:39:51 <carter> happy hacking all
14:39:57 <mm_freak_> sdrodge: the problem
14:39:58 <augustss> There are other parts distributed with ghc that are GPL
14:40:18 <sdrodge> mm_freak_: Ah, ok. So the factoring approach doesn't apply, then?
14:40:32 * hackagebot monad-resumption 0.1.0.1 - Resumption and reactive resumption monads for Haskell.  http://hackage.haskell.org/package/monad-resumption-0.1.0.1 (IanGraves)
14:40:39 <augustss> carter: I'm not sure it's that big of a problem with a GPLed CPP.  It's a standalone program.
14:42:53 <sdrodge> monochrom: I don't think you can actually consider the shapes to be part of a group for puzzles with modularity >2. Individual shapes cannot be inverses in that case.
14:44:09 <Eduard_Munteanu> Actually hm, does foldl work for any function, on streams?
14:44:18 <mm_freak_> sdrodge: apparently not at all
14:44:30 <Eduard_Munteanu> It seems not, so I guess it has to have a more special type.
14:44:46 <Eduard_Munteanu> streamFoldl :: (s -> a -> s) -> s -> Stream a -> s  -- other than that
14:44:55 <mm_freak_> sdrodge: when i think of matrices over ℤ/nℤ the first application that comes to my mind is factoring or index calculus
15:10:34 * hackagebot stomp-conduit 0.0.1 - Stompl Conduit Client  http://hackage.haskell.org/package/stomp-conduit-0.0.1 (TobiasSchoofs)
15:13:19 <prinsen> TH question. How would one construct the type signature func :: HandleT App IO Html? My first try was to nest AppT but that resulted in HandleT App (IO Html)
15:16:15 <donri> prinsen: [t| HandleT App IO Html |]
15:29:23 <prinsen> donri: App is generated by another TH function so i pass it to the generating function as a Q Type, how do i "splite it in"?
15:33:40 <Abe1244> Hi,
15:33:49 <Abe1244> I'm currently working through Graham Hutton's book
15:33:55 <Abe1244> and one early exercise has me stumped
15:34:06 <Abe1244> Here's the function:
15:34:07 <Abe1244> double x        = x * 2
15:34:15 <Abe1244> I'm supposed to define the types
15:34:27 <Abe1244> but the compiler rejects "double :: (Num a) -> (Num a)"
15:34:38 <mm_freak_> Abe1244: that's because 'Num a' is not a type
15:34:45 <Abe1244> what is the exact type then?
15:34:52 <mm_freak_> Abe1244: try to come up with a concrete type first
15:35:08 <mm_freak_> for example for doubling Integer values
15:35:14 <Abe1244> one possible concrete type is: "double :: Int -> Int"
15:35:21 <Abe1244> or... " ... Float -> Float"
15:35:29 <Abe1244> or.. "Integer -> Integer"
15:35:43 <mm_freak_> yeah, now the idea is:  instead of Int you want the function to by polymorphic on the type it works on
15:35:46 <mm_freak_> a -> a
15:35:58 <mm_freak_> but that alone doesn't work, because you have to make one assumption about 'a':  it has multiplication
15:36:09 <mm_freak_> that assumption can be expressed like this:  (Num a) => a -> a
15:36:09 <madariaga> Hello. I have a function [Foo] -> IO (Foo, Foo), it selects random elements from the original list, performs some operations and returns those two selected elements.
15:36:19 <Abe1244> so the compiler automatically inferences that it has to be a type that allows multiplication?
15:36:30 <mm_freak_> Abe1244: yes, because you used (*) in there
15:36:34 <madariaga> I would like to output some text to the screen, in the form of messages of what goes on (while it's going on)
15:36:38 <mm_freak_> :t \x -> 2*x
15:36:39 <lambdabot> Num a => a -> a
15:37:06 <madariaga> Would I need to "wrap" this somehow in order to make IO?
15:37:55 <Abe1244> ok, thanks!
15:38:01 <dwcook> madariaga, fortunately, randomness and printing can both be done in IO. Just throw a print in there.
15:38:12 <Abe1244> Hutton's book is a bit terse, so thanks a lot for the elaboration!
15:38:32 <dwcook> do { a <- randomlySelectValue ; print a ; return a } -- or something like that
15:38:41 <dmj`> How do I compress a folder using zlib?
15:38:47 <dmj`> main = do { [a] <- getArgs; coo <- L.readFile a; let r = compress coo; L.writeFile "out" r }
15:38:48 <dmj`>  
15:38:48 <dmj`>  
15:38:53 <dmj`> error "can't open directories"
15:39:07 <madariaga> dwcook: thank you
15:40:45 <madariaga> it does work :D
15:41:01 <dmj`> I have the wrong pkg
15:41:08 <dmj`> zip-archive is what I want
15:46:22 <mm_freak_> Abe1244: you're welcome, and don't hesitate to ask questions =)
15:46:41 <mm_freak_> Abe1244: also if that book is too terse you can try LYAH
15:46:44 <mm_freak_> @where lyah
15:46:44 <lambdabot> http://www.learnyouahaskell.com/
15:46:57 <mm_freak_> if you don't mind the fancy pictures =)
15:47:24 <Abe1244> Thanks for the hint! I just went through a university course on Erlang and used Learn You Some Erlang as a supplementary text, but found it way too verbose
15:47:40 <Abe1244> which is why I didn't bother with LYAH yet
15:48:02 <Abe1244> Apart from some minor bumps Hutton's book seems to be pretty good, though
15:53:48 <mm_freak_> Abe1244: i generally recommend the verbose texts for haskell newcomers though, because it's not just a new language, it's a new paradigm as well
15:54:16 <mm_freak_> that applies to erlang, too, but not to the same extent
15:54:37 <Abe1244> mm_freak: Erlang is also a functional language ;)
15:54:40 <scriptor> right, you're entering the realm of typeclasses now, which lyah does a pretty good job explaining
15:55:25 <scriptor> Abe1244: there's more to it than just being functional
15:55:31 <mm_freak_> Abe1244: but not a lazy one…  erlang solves recursively what other languages solve iteratively
15:56:02 <Abe1244> okay, I'll have a look at LYAH too, then
15:56:06 <mm_freak_> Abe1244: the haskell solution commonly doesn't look at all like the solution in erlang or other languages
15:56:19 <definity> Whhere are some good Haskell tutorials?
15:56:34 <mm_freak_> Abe1244: don't get me wrong…  you can still follow hutton's book =)
15:56:38 <Abe1244> what I've written in Haskell so far looks a lot like the functions I've written in Erlang, though...
15:56:44 <mm_freak_> but if you hit too many bumps, consider reading LYAH
15:56:54 <mm_freak_> or maybe even both in parallel
15:57:10 <mm_freak_> use hutton's where it's fine, LYAH where hutton's gets too terse
15:57:36 <mm_freak_> Abe1244: i can assure you that you will find much better solutions on your way…  it takes time to understand the paradigm
15:58:26 <Abe1244> I'm intrigued...
15:58:43 <mangaba_leitosa> > let f x = Debug.Trace.traceShow ("f(" ++ (show x) ++ ")") $ x * x in f 2 + f 2
15:58:44 <lambdabot>   Not in scope: `Debug.Trace.traceShow'
15:58:56 <mangaba_leitosa> > import Debug.Trace
15:58:57 <lambdabot>   <hint>:1:1: parse error on input `import'
15:59:03 <mangaba_leitosa> :-(
16:00:34 <mm_freak_> @let import Debug.Trace
16:00:35 <lambdabot>  .L.hs:113:1:
16:00:35 <lambdabot>      Debug.Trace: Can't be safely imported!
16:00:35 <lambdabot>      The module its...
16:00:40 <mangaba_leitosa> mm_freak_: thanks
16:00:46 <mangaba_leitosa> > let f x = traceShow ("f(" ++ (show x) ++ ")") $ x * x in f 2 + f 2
16:00:47 <lambdabot>   Not in scope: `traceShow'
16:00:50 <monochrom> always read 3 books concurrently to learn a subject. P. S. the 3rd book you read is the best book.
16:00:54 <mangaba_leitosa> > let f x = Debug.Trace.traceShow ("f(" ++ (show x) ++ ")") $ x * x in f 2 + f 2
16:00:55 <lambdabot>   Not in scope: `Debug.Trace.traceShow'
16:00:59 <mm_freak_> mangaba_leitosa: you can't import Debug.Trace, because it's not a trusted module
16:01:02 <mangaba_leitosa> ok :_)
16:01:09 <mangaba_leitosa> anyway, my question was:
16:01:12 <mm_freak_> lambdabot isn't that easy to hack, you know =P
16:01:28 <scriptor> monochrom: am I just confused or is that a joke?
16:01:36 <monochrom> it is not a joke.
16:01:52 <scriptor> but how do you define 3rd book if you're reading them concurrently
16:02:01 <quchen> That's the joke.
16:02:09 <scriptor> :(
16:02:15 <mangaba_leitosa> All: when I evaluate the let expression above, I can see that "f(2)" is printed twice. Does it mean that 'f 2' is really evaluated twice or it's just that the I/O action evaluated during the first (and only) evaluation of 'f 2' is reproduced by the runtime system twice?
16:02:15 <monochrom> you will inevitably serialize somewhat.
16:02:23 <scriptor> gotcha
16:02:23 <monochrom> again, I am not joking.
16:02:27 <mm_freak_> scriptor: the one you don't really read, because you think you're too smart =)
16:03:11 <mm_freak_> mangaba_leitosa: likely f is evaluated twice
16:03:38 <mm_freak_> mangaba_leitosa: in f x * f x, if you want to use sharing you have to use a let explicitly:  let x' = f x in x' * x'
16:03:48 <mangaba_leitosa> mm_freak_: and why? shouldn't 'f 2 + f 2' be optimized by the compiler as 'let value = f 2 in value + value ?
16:03:58 <mm_freak_> mangaba_leitosa: that may not be an optimization
16:04:07 <mm_freak_> that's why the compiler doesn't do it
16:04:29 <monochrom> the 3rd book is the best book because you have to read 3 perspectives to get it. at the moment you get it, you subjectively perceive that the most recent explanation does the job, and so you think it's the best, forgetting that the first two explanations laid the groundwork.
16:04:32 <mangaba_leitosa> mm_freak_: if all expressions are referentially transparent (no side effects), what's the reason for evaluating the expression twice?
16:05:55 <mm_freak_> mangaba_leitosa: sharing can turn an O(1) memory operation into an O(n) memory operation
16:06:25 <mm_freak_> which may impact even time complexity to such an extend that it uses not only a lot more memory, but is actually even much slower
16:06:27 <scriptor> monochrom: I see what you mean. I'll often have that experience with just a single resource
16:06:39 <mangaba_leitosa> mm_freak_: ah, ok. and are there extensions/options for enabling sharing explicitly?
16:06:53 <mm_freak_> mangaba_leitosa: just give the thing a name
16:06:55 <monochrom> then good for you, but very few people enjoy the same talent
16:07:01 <mm_freak_> shared:  let y = f x in y + y
16:07:05 <mm_freak_> not shared:  f x + f x
16:07:19 <mangaba_leitosa> mm_freak_: I see. Thanks. It's just sometimes it takes more code to create an additional let
16:07:21 <scriptor> monochrom: as in having to do multiple reads of the same thing
16:07:35 <scriptor> because I'll have no idea what I'm reading the first time
16:07:47 <alexander__b> I have a gaming console/Windows computer. what's the easiest way to install my game on it? my game uses cabal. do I just need to download ghc and cabal? is there an even easier way?
16:08:02 <mm_freak_> mangaba_leitosa: sometimes the compiler performs CSE for you, but only if it's absolutely certain that it won't change the time/memory behavior into a bad direction, which is pretty rare
16:08:10 <haasn> alexander__b: copy over a prebuilt, statically linked binary?
16:08:23 <johnw> alexander__b: yeah, I would likely create a Windows VM to build static binaries, and then copy those over
16:08:50 <alexander__b> haasn: doesn't work
16:08:58 <alexander__b> haasn: at least not the one I built.
16:09:14 <haasn> keep in mind ghc may want to pull in a link to libgmp
16:09:21 <johnw> alexander__b: can you define "doesn't work"?
16:09:22 <haasn> unless you go out of your way to link that in
16:09:23 <alexander__b> johnw: I don't use windows at all and have no desire to do anything more interesting than run my game on it
16:09:36 <mm_freak_> mangaba_leitosa: btw, all you need for sharing is a name…  this includes function arguments, where clauses, etc.
16:09:36 <haasn> johnw: I wonder if you can cross compile via wine
16:09:40 <alexander__b> johnw: "wahh wahh not correct. make sure it is built for the appropriate windows version." or something like that.
16:09:48 <alexander__b> haasn: you can cross-compile on gentoo, I know how to
16:09:55 <mm_freak_> mangaba_leitosa: so there is no need to write:  f x = let y = x in …
16:10:02 <johnw> alexander__b: can you right-click on the executable and select "Run as..." and choose an older version of Windows?
16:10:02 <alexander__b> I just have no interest in having anything for building for windows on my work computer at all
16:10:05 <haasn> alexander__b: cross-compile with GHC?
16:10:38 <alexander__b> haasn: hmmm. point. maybe gentoo only has official documentation for doing it with gcc.
16:11:00 <haasn> I don't think cross-compiling with GHC and cross-compiling with gcc have very much relevance to each other :P
16:11:51 <alexander__b> johnw: I doubt that's the point. I don't think ghc makes a binary that just automagically works everywhere.
16:12:04 <haasn> oh, but to answer your implied question of the minimum requirements you'd need to actually build it,
16:12:15 <alexander__b> haasn: yah, so just get ghc and cabal
16:12:17 <alexander__b> ?
16:12:36 <johnw> alexander__b: it's easy to try, but you're probably right
16:12:40 <alexander__b> I'm not sure I want to invest that much work into my WC which I only use for games. :-P
16:12:57 <mangaba_leitosa> mm_freak_: yes, I understand that. It's just that sometimes it's seems stupid to write something like 'let hd = head list in if hd > 0 then hd else 0' because 'if head list == 0 then head list else 0' looks more readable
16:13:05 <alexander__b> johnw: you can select compatibility modes. just trying a few random ones don't work at least.
16:13:29 <johnw> would be neat if there were actually an option "try random compatibility mode"
16:13:38 <mm_freak_> mangaba_leitosa: there is really nothing we can do about it without solving the halting problem
16:13:53 <mm_freak_> mangaba_leitosa: GHC's behavior is the correct one there with no further context
16:14:06 <mangaba_leitosa> mm_freak_: what does it have to do with the halting problem?
16:14:08 <alexander__b> lolwat there is no ghc for anything newer than x86? interesting
16:14:43 <alexander__b> errr s/x86/windows xp
16:15:42 <simpson> mangaba_leitosa: IIRC the question of whether any given partial-recursive function is primitive-recursive is undecideable.
16:16:02 <alexander__b> MEH. maybe some of the forks of my game will make a windows binary some day. I'll try it then. :-P
16:16:24 <Narvius> (<>) == (++) for lists?
16:16:57 <mangaba_leitosa> simpson: how solving this task helps in evaluating or not evaluating 'head list' in the expression 'if head list > 0 then head list else 0' twice?
16:17:00 <mm_freak_> mangaba_leitosa: will automatic sharing produce better code at this spot?  compiler's answer: good question
16:17:38 <carter> augustss: true, people would just grump about it
16:17:42 <simpson> mangaba_leitosa: Oh, we're talking about sharing, sorry. I thought we were talking about detecting partiality.
16:17:54 <quchen> Narvius: (<>) = mappend, and for lists mappend = (++).
16:18:11 <mangaba_leitosa> mm_freak_: so, answering the question 'will automatic sharing produce better code at this spot' is equivalent to the halting problem?
16:18:17 <chrisdone> Peaker: just heading to bed, but i pushed some more stuffs, including fixing the hse parsing (its docs lie! they lie!!!)
16:25:05 <mm_freak_> mangaba_leitosa: yes
16:25:26 <mm_freak_> mangaba_leitosa: in a few instances it can be answered by the compiler in reasonable time, but it's better not to rely on the compiler's CSE
16:25:57 <mm_freak_> mangaba_leitosa: in haskell the decision when to apply CSE is about as difficult as the decision when to parallelize automatically
16:26:13 <mm_freak_> that's why you still have to tell the compiler where you want parallelism
16:26:30 <chrisdone> mm_freak_: what's CSE?
16:26:31 <mangaba_leitosa> mm_freak_: understood, thanks
16:26:32 <carter> too much parallelism would mean you'd spend most of your time just in the scheduler! :)
16:26:39 <carter> common subsexpression elimniation
16:26:42 <chrisdone> ahh, duh
16:26:48 * chrisdone → bed
16:26:53 <carter> do it
16:26:56 <carter> :)
16:28:12 <mm_freak_> if haskell would have the same totality properties as agda, then the decision could actually be made by the compiler =)
16:28:21 <simpson> mm_freak_: Perhaps showing an example would be instructive.
16:28:48 <prinsen> TH question: I have a funcion generatFunction :: MyType -> Q [Deq], generateFunction m = do ... get <- [| ... let t= m .. |]. This however gives me the error: No instance for Lift MyType. Why is this?
16:28:55 <mm_freak_> simpson: sum (take 100 xs ++ take 100 xs)
16:28:57 <mm_freak_> O(1) memory
16:29:11 <mm_freak_> simpson: let ys = take 100 xs in sum (ys ++ ys)
16:29:14 <mm_freak_> O(n) memory
16:29:35 <mm_freak_> (assuming a foldl' sum)
16:30:17 <prinsen> ie. I want to use the value of m inside [| |], but this seems impossible
16:30:48 <simpson> mm_freak_: And this is because, in the second example, `ys` builds up the list of 100 items, whereas the first example folds and consumes immediately?
16:31:07 <startling> simpson: not quite.
16:31:17 <startling> it's a sharing thing, isn't it?
16:31:44 <startling> hm, maybe not.
16:32:42 <mm_freak_> startling: it is
16:33:08 <startling> well, why doesn't the one with "let" have more sharing?
16:33:11 <mm_freak_> simpson: pretty much…  because there is a second reference, the prefix list will not get garbage-collected in the shared case
16:33:24 <startling> oh.
16:34:58 <structuralist> Does Happstack support websockets?
16:36:12 <hpc> structuralist: i am sure there's a way
16:36:26 <structuralist> me too, but friendly?
16:36:56 <hpc> no idea
16:37:18 <mangaba_leitosa> mm_freak_: so, in case of 'sum (take 100 xs ++ take 100 xs)' we get slowness and in case of 'let ys = take 100 xs in sum (ys ++ ys)' we get increased memory consumption?
16:37:22 <hpc> trying to look through and see if there's a good way of doing back-and-forth communication in happstack that would allow using a separate websockets lib
16:37:32 <mangaba_leitosa> mm_freak_: is there a way to combine both options?   :-)
16:37:38 <Lindrian> hmm. I'm trying to learn haskell. Why is [3,2,1] > [2,10,100] true?
16:38:04 <startling> Lindrian: it's dictionary-style ordering.
16:38:15 <Lindrian> what does that mean?
16:38:27 <ParahSail1n> @src [] (>)
16:38:27 <lambdabot> Source not found. I feel much better now.
16:38:36 <hpc> structuralist: it's looking a lot like there isn't
16:38:38 <startling> Lindrian, consider "dcb" and "bmn"
16:38:44 <ParahSail1n> @src [] compare
16:38:44 <lambdabot> Source not found. Maybe if you used more than just two fingers...
16:38:53 <startling> Lindrian: "dcb" would be after "bmn" in the dictionary, yes?
16:38:54 <structuralist> :/
16:39:05 <Lindrian> startling: sure
16:39:13 <startling> Lindrian, so, lists order that way.
16:39:22 <ParahSail1n> @src [] (<=)
16:39:22 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
16:39:24 <startling> Lindrian, 3 > 2, so [3, ...] > [2, ...]
16:39:28 <hpc> structuralist: a particularly silly thing to do might be to have happstack proxy for a socket server
16:39:34 <Lindrian> so head determines?
16:39:49 <hpc> Lindrian: yes
16:39:52 <startling> Lindrian: yeah. and if they're equal, the next one determines it, ad infinitum.
16:39:55 <hpc> > "aardvark" > "apple"
16:39:56 <lambdabot>   False
16:39:59 <Lindrian> ah
16:40:00 <Lindrian> thank you.
16:40:33 <startling> Lindrian: this is sometimes called "lexicographical order" by people who like latin roots.
16:40:58 <Lindrian> thanks again
16:41:05 <hpc> > "aaa" > "aa"
16:41:06 <lambdabot>   True
16:41:07 <Lindrian> long words make everything better
16:41:28 <startling> it literally means "dictionary order".
16:41:28 <hpc> Lindrian: another way to remember it is that list ordering is what would be generated by "deriving"
16:41:36 <hpc> if you happen to have that memorized
16:42:03 <Lindrian> dictionary thing was better
16:42:04 <startling> Tuples use it, too.
16:42:13 <startling> > (3, 0) > (2, 5)
16:42:14 <lambdabot>   True
16:42:27 <Lindrian> > "abc" > "abd"
16:42:28 <lambdabot>   False
16:42:56 <startling> > 'd' > 'c'
16:42:57 <lambdabot>   True
16:42:59 <theorbtwo> > "aaa" < "BBB"
16:43:00 <lambdabot>   False
16:43:37 <theorbtwo> It's not strictly dictionary order, then, it's asciibetical.  (Well, unicodeabetical, which doesn't roll off the tounge quite so well.)
16:44:02 <krakrjak> > zipWith compare [3, 2, 5] [2, 10, 100]
16:44:03 <lambdabot>   [GT,LT,LT]
16:44:14 <startling> it's still dictionary order, but letters are ordered differently than is usually done in dictionaries.
16:44:27 <ion> > compare "ä" "ä"
16:44:29 <lambdabot>   GT
16:44:32 <hpc> it's a weird dictionary
16:44:52 <mm_freak_> mangaba_leitosa: why would the non-shared one be slower?
16:44:57 <mm_freak_> mangaba_leitosa: it's likely faster
16:45:26 <theorbtwo> ion: One of those was a sequence of a, combining ¨, the other was the precomposed version?
16:45:47 <ion> yeah
16:45:53 <simpson> mangaba_leitosa: Just to point things out, you'd make it faster with something like: 2 * (sum (take 100 xs))
16:46:07 <krakrjak> Lindrian: the real trick is knowing what you really want to compare.  Do you want to know if one list is longer than another?  Do you need to compare each individual value in a list against values in another list?
16:46:59 <theorbtwo> Oftentimes, a sort is better then a compare -- though, of course, a sort is really a bunch of compares.
16:47:05 <theorbtwo> Likewise, min and max...
16:48:09 <Lindrian> krakrjak: how would i compare list length?
16:48:15 <Lindrian> im currently just learning haskell so no real tasks yet
16:49:08 <krakrjak> Lindrian: by using length
16:49:16 <monochrom> length x < length y. or, compare (length x) (length y)
16:49:28 <Lindrian> of course
16:49:34 <krakrjak> > length [1, 2, 3, 4, 5]
16:49:35 <lambdabot>   5
16:49:45 <mangaba_leitosa> simpson: indeed :-))
16:49:47 <Lindrian> i just need to wrap my head around how functions work in haskell
16:49:56 <Lindrian> that'll come with time i assume
16:50:04 <briennetheblue> :t (<) `on` length
16:50:05 <lambdabot> [a] -> [a] -> Bool
16:50:08 <mangaba_leitosa> mm_freak_: because take takes 100 items twice?
16:50:19 <krakrjak> try to just forget about the = being for variables an think that everything is a function.  Starting from there helps.
16:50:24 <monochrom> hmm, that's interesting, because supposedly you already know how functions work from highschool math, just different notation
16:51:00 <monochrom> I still have to write my "the prerequisite of haskell is highschool math skill, and only some of it" article
16:51:22 <krakrjak> monochrom: please write that article.
16:51:52 <tim_> Is there something I'm missing about cabal? I would expect it to install scripts to something like a Haskell/bin in the Library. But instead it seems like it's all going to something like /Library/Haskell/ghc-7.6.3/lib/LIBNAME/bin
16:52:05 <monochrom> and yeah, "=" means definitional equality.
16:52:08 <mm_freak_> mangaba_leitosa: that's an almost negligible cost
16:52:14 <tim_> Do you put all of those in your path?
16:52:23 <mm_freak_> mangaba_leitosa: it doesn't necessarily /compute/ the elements twice
16:53:17 <monochrom> it is the same "=" as in highschool math "f(x) = x+1", "let y = 10". it means everywhere you see "f(5)" you can replace with 5+1, everywhere you see "y+2" you can replace with 10+2
16:53:59 <krakrjak> exactly we get so beaten down by IP into thinking that the = is for storing a value in a cell.
16:54:09 <krakrjak> a mutable value in particular
16:56:09 <prinsen> I have a really wierd problem with TH, anyone with experience?
16:58:17 <krakrjak> How weird is it?
16:58:31 <prinsen> superwierd
16:58:37 <prinsen> unexplanably wierd
16:58:39 <krakrjak> now I have to see it.
16:58:48 <krakrjak> even if I can't help
16:59:01 <prinsen> krakrjak: give me a sec to try to explain it
16:59:38 <prinsen> I have a function generateFunction :: MyType -> Q Dec to create a function
17:00:52 <prinsen> I create the function with [| do ... let a = LOCAL_VARIABLE |]
17:01:32 <prinsen> if LOCAL_VARIABLE is the parameter to the generating function, I get Exception when trying to run compile-time code:       Prelude.head: empty list
17:01:59 <prinsen> if it is a locally defined string it works
17:02:48 <krakrjak> just out of curiosity what is the type of MyType?
17:03:15 <prinsen> Its a large data type representing an Open data table
17:04:00 <krakrjak> so the whole [| ...  |] is the parameter to generateFunction?
17:04:26 <prinsen> No generateFunction is something like this
17:05:20 <prinsen> generatingfunction ot -> do exp <- [d| do .. let a = ot .. |] ...
17:06:25 <prinsen> the problem occurs when a is assigned to the parameter ot
17:06:44 <krakrjak> so if ot is a hardcoded string it's fine?
17:07:10 <krakrjak> or is it only when you don't use ot as the rval to the let?
17:07:16 <prinsen> well if i rename ot and create a local variable ot that is a hardcoded string then it works
17:08:08 <prinsen> generateFunction ot = do let hard = "apa ; exp <- [| .. let m = hard .. |]  .. works
17:08:27 <krakrjak> hrm...  it sounds like the other code is assuming a is a list so you are getting the unsafe head violation.
17:08:52 <krakrjak> what if it's a single character instead of a String?
17:09:54 <prinsen> krakrjak: i will try
17:10:39 <krakrjak> prinsen: it's just an intuition.  I'm not really sure how to proceed either, but the error you typed above sounds like the computation is expecting a list and when you give it a String you have a list and otherwise it's failing.
17:15:07 <xenon`> hello. what is a good haskell image manipulation library? I want to do very basic things, resizing the image and applying sharpening filter. also qualify of the resulting image is more important to me than speed
17:17:38 <Peaker> xenon`: not sure if it fits, but maybe juicy pixels can help (I think it's a pure Haskell lib for img formats)
17:18:42 <xenon`> thanks I will take a look
17:19:32 <pavonia> xenon`: There's also an imagemagick binding for Haskell, not sure how well that works, though
17:20:31 <xenon`> thanks too
17:31:16 <prinsen> krakrjak: Are you there?
17:35:33 <jophish_> Yo yo yo
17:35:40 <jophish_> Haskell with clang doesn't goo too smoothly
17:36:23 <jophish_> go*
17:40:28 <krakrjak> prinsen: yeah I'm back
17:41:35 <srhb> I'm trying to test System.Eval.Haskell.eval from the plugins package, but when I run my program (which basically is just eval "2 :: Int" [] -- I get  cannot satisfy -package plugins
17:41:43 <srhb> Is this because it needs something outside of my sandbox?
17:42:32 <jophish_> cabal doesn't seem to use cpphs instead of gcc for preprocessing
17:48:04 <Moogle_> http://hackage.haskell.org/packages/#cat:ACME
17:48:09 <Moogle_> what an excellent part of hackage.
17:49:13 <monochrom> yes, we love it
17:50:30 <hpc> http://hackage.haskell.org/package/acme-schoenfinkel-0.1.1/docs/Control-Category-Schoenfinkel.html#v:h-228-sslich -- the best acme joke
17:57:08 <srhb> Hum. I'm trying to statically link (I think) my program to see if that error goes away, but with -optl-static it complains it cannot find -lgmp
17:57:14 <srhb> I have gmp installed.
18:00:03 <geekosaur> but do you have libgmp.a or just a shared object for it?
18:01:43 <srhb> geekosaur: Hum, only the so I guess
18:01:57 <srhb> I'm a bit out of my depth here. :P
18:02:35 <geekosaur> if you use -optl-static you are telling the linker to only accept .a files, not .so files
18:02:45 <srhb> Ah.
18:04:39 <srhb> geekosaur: Am I correct that I need to do that in order to have plugins work?
18:05:22 <geekosaur> I am not sure what problems you are having
18:05:34 <geekosaur> I checked scrollback but didn't see a whole lot
18:05:47 <geekosaur> in general though I'd say static linking is not the best of ideas on linux
18:06:13 <geekosaur> certain parts of glibc are unhappy about being linked statically (notably the interfaces to the NSS modules)
18:06:57 <srhb> geekosaur: Right. It's all a bit confusing, I expected plugins to "just work" but clearly it needs a bit extra in order to work in a standalone application
18:07:05 <structuralist> So I'm running jaspervdj's websockets tutorial verbatim from http://jaspervdj.be/posts/2013-10-22-websockets-0.8.html ... and it's not working
18:07:26 <structuralist> using .../console/bash it echos what I type but nothing else happens
18:07:41 <structuralist> but using .../console/ls I get the output of ls and a closed connection thereafter
18:08:10 <structuralist> what could be causing a difference if I literally copied + pasted his code?
18:09:50 <structuralist> code is here: https://github.com/jaspervdj/websockets-snap/tree/master/example
18:14:39 <blakesmith> Has anyone seen an error like this when compiling GHC? https://gist.github.com/blakesmith/7242972
18:15:59 <srhb> Well, that's interesting. Now my executable segfaults instead.
18:16:30 <heatsink> Doesn't look familiar to me.
18:17:13 <blakesmith> Are all those *.mk files supposed to be present?
18:17:18 <blakesmith> I feel like I missed a step somewhere...
18:19:14 <heatsink> Did you boot?
18:19:55 <heatsink> http://ghc.haskell.org/trac/ghc/wiki/Building/QuickStart
18:20:01 <blakesmith> No, I didn't see that step here: http://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling :-(
18:20:43 <heatsink> Cross-compiling is not tested thoroughly so you might have complications
18:20:52 <heatsink> Are you really trying to cross-compile though?
18:22:33 <blakesmith> heatsink: I am. It'll take many days to compile on the Raspberry Pi itself.
18:22:53 <blakesmith> Had trouble with the QEMU approach, so trying this now.
18:23:08 <blakesmith> Cross Compilation is dicey eh?
18:23:14 <geekosaur> very
18:24:04 <blakesmith> Hrm, I need to come up with a decent way to build for ARM.
18:30:59 <blakesmith> I'll give the QEMU approach another try, thanks for the tip on Cross Compilation. :-)
18:34:47 <lpaste> srhb pasted “plugins troubles” at http://lpaste.net/95010
18:35:03 <srhb> The program in all its glory :/
18:40:54 <heatsink> It's a library dependency issue.  Use -v to see which libraries conflict
18:41:16 <heatsink> You can also run ghc-pkg list to see which libraries are installed
18:46:15 <heatsink> srhb, it looks like eval only searches for packages in the current directory.  Maybe you can use eval_ and pass the other information.
18:46:51 <srhb> heatsink: Oh. So if I place the plugins library in the same library I'd be fine?
18:46:59 <srhb> heatsink: I'd like this to be as self-contained as possible
18:47:49 <srhb> But I'd guess I need ghc as a library or something too, then
18:50:02 <heatsink> I don't know how plugins works.  That's just my guess about what's producing the error message.
18:50:30 <heatsink> And it's the package.conf directory that is needed by eval
18:50:31 <srhb> heatsink: Okay. Thank you anyway
20:05:03 <loadedanvils> how do I access data in a type
20:05:34 <Iceland_jack> loadedanvils: You can pattern match or use accessor fields
20:05:43 <loadedanvils> oh, right
20:06:18 <Iceland_jack> For:
20:06:18 <Iceland_jack>     data Person = Person Int String
20:06:18 <Iceland_jack> You can do:
20:06:18 <Iceland_jack>     details (Person age name) = printf "%s is %d years old" name age
20:06:54 <Iceland_jack> or
20:06:55 <Iceland_jack>     data Person = Person { age :: Int, name :: String }
20:06:55 <Iceland_jack> and
20:06:55 <Iceland_jack>     details person = printf "%s is %d years old" (name person) (age person)
20:07:26 <loadedanvils> what is %s and 5d?
20:07:29 <loadedanvils> %d
20:07:48 <Iceland_jack> It's for formatting
20:08:02 <Iceland_jack> > printf "%s is %d years old" "Sally" 55 :: String
20:08:04 <lambdabot>   "Sally is 55 years old"
20:08:12 <loadedanvils> what if I have five elements
20:08:18 <Iceland_jack> What do you mean?
20:08:43 <loadedanvils> data Megaman = Megaman { a1 :: Int, a2 :: Int, a3 :: Int, a4 :: Int, a5 :: Int }
20:08:50 <Iceland_jack> Yes, then you can do that
20:09:04 <loadedanvils> do what?
20:09:21 <Iceland_jack> Use those multiple fields
20:09:38 <loadedanvils> how? I still don't understand what %s and %d indicate?
20:09:59 <Iceland_jack> ok ignore the %s and %d things, that was irrelevant to your question
20:10:04 <Iceland_jack> I assumed you were familiar with printf
20:10:11 <loadedanvils> oh I see now
20:11:08 <loadedanvils> Iceland_jack: thanks, I get it now
20:17:19 <davve123> any tips for someone getting to grips with the compiler error messages? just stick it out?
20:18:08 <mm_freak> loadedanvils: may i offer a small improvement to your type:  data Megaman a = Megaman { a1 :: a, a2 :: a, a3 :: a, a4 :: a, a5 :: a }
20:18:10 <startling> davvel123: Read them really carefully.
20:18:41 <mm_freak> davve123: read "No instance for (X Y)" as "Y is not a X type"
20:18:53 <startling> davve123: I think most errors for other compilers and interpreters are pretty nonspecific, so it's easy to gloss over important stuff.
20:18:56 <startling> GHC
20:19:08 <startling> 's messages will literally tell you exactly what's wrong, you just need to know the jargon.
20:19:42 <mm_freak> > "abc" + "def"
20:19:43 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
20:19:43 <lambdabot>    arising from a use of `GH...
20:19:52 <mm_freak> String is not a Num type
20:20:03 <enthropy>  data Megaman a = Megaman { a1, a2, a3, a4, a5 :: a } -- shorter still
20:20:06 <mm_freak> (the error message will look less weird in GHC/GHCi)
20:20:20 <mm_freak> enthropy: oh, i didn't know that syntax is allowed…  thanks
20:20:31 <startling> it's a nice syntax!
20:20:36 <mm_freak> but it's actually weird
20:20:40 <startling> it is weird.
20:20:46 <mm_freak> @let data Test = Test { x, y :: Integer }
20:20:47 <lambdabot>  Defined.
20:20:55 <enthropy> why? You can do it for top-level declarations too
20:20:56 <Iceland_jack> How is it weird?
20:20:57 <mm_freak> @undefine
20:20:57 <lambdabot> Undefined.
20:21:12 <loadedanvils> mm_freak: thanks for that!
20:21:13 <mm_freak> enthropy: sure, but there you have line feeds or semicolons to delimit
20:21:27 <enthropy> > let { f, g :: Int -> Int; f = succ; g = pred } in f (g 3)
20:21:28 <lambdabot>   3
20:21:47 <mm_freak> consider this:  a, b :: Int, c, d :: Int
20:21:48 <enthropy> so I guess that's also weird
20:21:51 <mm_freak> that does look weird
20:22:07 <mm_freak> with 'let' you would write:  a, b :: Int; c, d :: Int
20:22:11 <Iceland_jack> It's similar to: n, n′ ∈ ℕ
20:22:38 <mm_freak> i understand the syntax, but i'm noticing that it really only works, because the syntax within record definitions is very constrained
20:22:55 <davve123> thanks guys. they got the better of me last time, now i have some more experience with erlang, the syntax/concepts seem less daunting. i know from experience i learn best by writing code and correct according to what the compiler tells me. usually just go to line and fix it, ghc is in a league of its own :)
20:23:33 <mm_freak> to me as a human "a, b :: Int, c, d :: Int" reads like "a, (b :: Int), c, (d :: Int)", and to me the way the compiler reads it is a precedence error
20:23:52 <Iceland_jack> mm_freak: “… as a human” see there's your problem
20:24:24 <davve123> but also more rewarding
20:24:27 <geekosaur> I've come to expect :: to extend as far left as it can, so it makes sense
20:24:39 <enthropy> it's about the same as declaring types in other languages
20:24:48 <mm_freak> geekosaur: then it doesn't make sense
20:24:55 <mm_freak> a, b :: Int, c, d :: String
20:24:57 <Iceland_jack>     int a, b;
20:24:57 <Iceland_jack> versus
20:24:57 <Iceland_jack>     a, b ∷ Int
20:25:06 <mm_freak> now the ":: String" extends only to the c
20:25:15 <geekosaur> yes
20:25:29 <geekosaur> which is as far as it can go due to the preceding type
20:25:42 <enthropy> > do 1 :: Int :: Int
20:25:43 <lambdabot>   1
20:25:54 * davve123 compiling ghc 7.6.3
20:26:15 <mm_freak> i wouldn't have done it that way…  using commas in record syntax is weird enough as it is
20:26:39 <mm_freak> unlike most other symbols "," has a number of meanings depending on where you find it
20:29:02 * enthropy sees the oddness now
20:29:09 <davve123> damn, running low on batteries and left charger at work
20:29:13 <davve123> hope it compiles in time
20:30:09 <davve123> was hoping to muck about with ghci a bit.. :(
20:30:40 <mm_freak> davve123: why are you compiling it?
20:30:44 <davve123> is there a webbased interpreter i could use?
20:30:52 <davve123> mm_freak: oh, my packagemanager just decided to
20:31:16 <mm_freak> davve123: which one?
20:31:26 <davve123> homebrew
20:31:42 <mm_freak> ah
20:32:17 <mm_freak> davve123: just in case you're reinventing: http://nixos.org/
20:32:27 <mm_freak> if you like haskell, you probably also like the nix package manager =)
20:33:40 <davve123> mm_freak: interesting!
20:35:28 <davve123> had to stop compiling, it was draining too fast. luckily found tryhaskell.org which should satisfy my insomnia/itch to learn haskell :)
20:36:19 <mm_freak> hehe
20:36:24 * roconnor was recompiling ghc a few days ago.
20:36:49 <roconnor> I wanted to compile in a new branch of nixpkgs.
20:37:16 <roconnor> It recompiled glibc, gcc, ghc, some haskell package.
20:37:25 <roconnor> ta da
20:37:40 <bennofs> glibc and gcc compile quite fast compared to ghc
20:37:46 <mm_freak> currently haskellPlatform fails for me with a derivation collision i couldn't resolve yet
20:38:02 <mm_freak> so some of my haskell packages are still outdated
20:38:31 * bennofs uses ghcPlain because hdevtools doesn't deal with all this ghc-pkgs symlinking very well
20:39:08 <roconnor> all to get unicode haddock :D
20:40:32 <mm_freak> are you guys using the ~/.nixpkgs/config.nix local installation setup?
20:40:55 <mm_freak> i noticed that installing haskell-platform via nix-env actually works
20:41:25 <mm_freak> but installing haskellPlatform via hsEnv doesn't for some reason =/
20:41:32 <roconnor> What is hsEnv?
20:42:59 <mm_freak> roconnor: http://lpaste.net/95011
20:43:11 <mm_freak> that's my ~/.nixpkgs/config.nix
20:43:17 <roconnor> ah
20:43:25 <roconnor> that seems like a good idea.  But I don't do it
20:43:38 <mm_freak> what do you do?  just -i into your profile?
20:43:45 <roconnor> yes
20:43:58 <mm_freak> hmm…  i'd prefer not to give up that setup
20:45:42 <roconnor> mm_freak: does your haddock work with hsEnv?
20:46:42 <roconnor> haddock doesn't really work with nix-env for reasons that I more or less understand.  Haddock doesn't see my installed pacakges because it isn't calling ghc-wrapped.
20:46:56 <mm_freak> it works
20:47:01 <roconnor> nice
20:47:21 <mm_freak> however, it can't handle unicode
20:47:57 <roconnor> mm_freak: that's just an env bug that is fixed in stdenv-update and will be ported back into master "soon".
20:50:43 <roconnor> mm_freak: also, I don't have the haskell-platform installed.
20:50:52 <roconnor> I'm the anti-haskell-platform guy.
20:51:23 <xico> i want to create a cabal package for a library, whose examples/tests are small .so shared libraries. is there a way to do so easily in a single .cabal file?
20:51:24 <mm_freak> roconnor: so you install everything separately?
20:51:36 <roconnor> mm_freak: yep
20:51:45 <mm_freak> let me try that out
20:51:48 <roconnor> as needed.
20:52:37 <mm_freak> xico: what do you mean?  your tests aren't in haskell?
20:53:19 <xico> mm_freak: no. the main program is an already existing c program. the small tests, and main lib is the haskell package.
20:54:15 <xico> i mean the small tests are .so plugins written in haskell, which are loaded by the c binary.
21:01:08 <VonDraco> okay, why is it that when i take the tail of a list of lists, i get back a list within a list?
21:01:16 <VonDraco> yet when i take the head of a list of lists, i get a simple list
21:01:33 <VonDraco> this is driving me nuts @_@
21:02:11 <cbw> (1:(2:(3:[])))
21:02:48 <cbw> > tail [[]]
21:02:49 <lambdabot>   []
21:03:02 <cbw> > head [[]]
21:03:03 <lambdabot>   []
21:03:36 <VonDraco> > head [[1,2],[3,4]]
21:03:37 <lambdabot>   [1,2]
21:03:46 <glguy_> VonDraco: The head of a list of lists is a list. The tail of a list of lists is a list of lists
21:03:50 <VonDraco> > tail [[1,2],[3,4]]
21:03:51 <lambdabot>   [[3,4]]
21:03:53 <glguy_> What else would you expect??
21:04:08 <glguy_> maybe you meant "last"?
21:04:09 <VonDraco> huh, i never thought about it that way
21:04:12 <glguy_> > last [1,5,10]
21:04:13 <lambdabot>   10
21:04:32 <VonDraco> holy shit
21:04:37 <VonDraco> never knew about last
21:04:45 <cbw> > tail [[1],[2]]
21:04:46 <lambdabot>   [[2]]
21:04:49 <cbw> > head [[1],[2]]
21:04:50 <lambdabot>   [1]
21:04:59 <VonDraco> thanks
21:05:21 <cbw> sorry I was scrolled up...
21:08:25 <xico> @hoogle cdr
21:08:25 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
21:08:25 <lambdabot> Graphics.Rendering.OpenGL.GL.BufferObjects DynamicDraw :: BufferUsage
21:08:25 <lambdabot> Graphics.Rendering.OpenGL.GLU.Quadrics data QuadricDrawStyle
21:08:55 <Iceland_jack> Haskell not having CAR/CDR is the reason it will never become mainstream!
21:10:16 <cbw> Iceland_jack: No, Is that most people arn't as cool as we are
21:11:05 <dmwit> ?hoogle [a] -> [a] -- xico
21:11:05 <lambdabot> Parse error:
21:11:05 <lambdabot>   [a] -> [a] -- xico
21:11:05 <lambdabot>                ^
21:11:07 <dmwit> oops
21:11:09 <dmwit> ?hoogle [a] -> [a]
21:11:10 <lambdabot> Prelude cycle :: [a] -> [a]
21:11:10 <lambdabot> Data.List cycle :: [a] -> [a]
21:11:10 <lambdabot> Prelude init :: [a] -> [a]
21:11:12 <Iceland_jack> Haskell people are cool?
21:11:16 <dmwit> what
21:11:18 <dmwit> hoogle--
21:11:41 <Iceland_jack> dmwit: No comments in Hoogle command I'm afraid :(
21:11:53 <dmwit> I can understand cycle and reverse coming before tail in the results. But *init*??
21:13:24 <geothermalphysix> I just wanna hack
21:14:32 <dmwit> What are you doing on IRC, then?
21:14:55 <geothermalphysix> dwmit, uniting with fellow hackers, feeding off the energy
21:15:12 <mm_freak> edwardk: any plans to update trifecta's dependencies?
21:16:51 <mm_freak> dmwit: if the ordering is alphabetical, it's totally reasonable
21:16:52 <Iceland_jack> geothermalphysix: Have you gone through LYAH? If not, you should go through LYAH :)
21:16:52 <Iceland_jack> @where lyah
21:16:52 <lambdabot> http://www.learnyouahaskell.com/
21:17:27 <edwardk> yes
21:17:56 <edwardk> mm_freak: patches welcome =)
21:18:40 <mm_freak> edwardk: i know, i know =)
21:19:01 <mm_freak> the darcshub vs. github dilemma again =)
21:20:22 <edwardk> dilemma implies that one can viably argue both sides ;)
21:20:54 * dmwit gets all annoyed again at the "let's switch to github because I like it better" crowd
21:21:07 <edwardk> =)
21:21:30 * edwardk trolls dmwit.
21:21:36 <edwardk> "go is a stupid game"
21:21:40 * dmwit grumps and harrumphs
21:21:42 <edwardk> you should play chess
21:21:44 <dmwit> You're a stupid game!
21:21:52 * dmwit sticks his tongue out
21:22:22 <mm_freak> edwardk: that's why it's not a dilemma for me…  git out, darcs in, done =P
21:23:30 <edwardk> i wonder if that iteration monad is the thing i really want for the ST monad.
21:23:36 <edwardk> that seems to be precisely it
21:24:21 <mm_freak> iteration monad?
21:25:34 <edwardk> newtype It r a = It { runIt :: r (Either a (It r a)) }; instance Monad r => Monad (Iter r)
21:25:38 <edwardk> its not the free monad
21:25:58 <mm_freak> yeah, i see the difference
21:26:07 <edwardk> It c >>= k = It (c >>= either (runIt . k) (return . Right . (>>= k)))
21:28:48 <mm_freak> edwardk: i don't it…  what's the point of that monad (transformer)?
21:28:57 <mm_freak> +get
21:29:04 <edwardk> http://www.ioc.ee/~tarmo/tday-veskisilla/uustalu-slides.pdf
21:30:14 <edwardk> i'm looking for something better than Free (Id :+: ST s) for my 'steppable ST'
21:30:31 <edwardk> this lets me i think use Iter (ST s) and (>>=) in such a way that i don
21:30:40 <edwardk> t violate the monad laws, but can explicitly insert step points
21:31:02 <edwardk> that recovers a nicer theoretical foundation from my current hack
21:33:07 <mm_freak> edwardk: and your application can't be expressed in terms of stream processing?
21:33:23 <edwardk> correct
21:33:36 <mm_freak> ok, problem understood
21:34:04 <edwardk> this is basically a map, and i wind up with some partiality monads embedded in it to enable me to force steps in a 'tied off' ST calculation as i do other things.
21:34:16 <edwardk> so that after say a million steps the ST calculation finishes, but never pays more than O(1) per step
21:34:25 <edwardk> it lets me 'time dilate' an ST calculation
21:34:45 <edwardk> newtype Slow s a = Slow { runSlow :: ST s (Either a (Slow s a)) }
21:35:52 <edwardk> then I can embed ST actions into it, but I can also nest time steps that are explicit breaks so that when that gets converted with walk :: (forall a. Slow s a) -> Partial a   only those breaks become 'Step's in the final Partial monad.
21:36:13 <mm_freak> edwardk: you could send a log instead of setting a breakpoint
21:36:31 <mm_freak> advantage:  you can tell the coroutine where you are right now
21:36:32 <edwardk> i need that to be the trivial data type based Free in the end or i lose the ability to know that two computations have forced it so far
21:36:59 <edwardk> the problem with that approach is that i can 'kick off' far too much work that i can't afford to pay for by my amortization schedule
21:37:32 <mm_freak> how does the Iter monad guarantee O(1) without breaking the monad laws?
21:37:36 <dmwit> I'm confused how you could ever use Slow.
21:37:52 <dmwit> You can't just run one iteration; you'll be escaping with that existential s.
21:37:53 <dmwit> Won't you?
21:39:17 <edwardk> i have 2 evaluation techniques, one is evil, one is less so
21:39:23 <mm_freak> edwardk: consider the law: replicateM_ n (return ()) ~ return ()
21:39:33 <edwardk> the evil one is more correct, and uses unsafePerformIO
21:39:50 <dmwit> ...of course =P
21:40:06 <edwardk> mm_freak: O(1) is by convention here. you put explicit debits / yields in between steps of known cost
21:40:21 <mm_freak> ah, so it's not enforced
21:40:23 <edwardk> i need to say, build an unboxed vector over a half million steps.
21:40:25 <edwardk> correct
21:40:33 <edwardk> i can't afford to pay for all half million at once, ever.
21:40:51 <edwardk> because it may be on the 499,999th step and the next one would make the whole array.
21:41:09 <edwardk> and so if i added one element i'd do it, then if i went back to the same immutable structure and did it again i might have to do it again
21:41:21 <edwardk> so instead i need to deamortize to slow the world down
21:41:34 <mm_freak> i'd just use pipes there
21:41:39 <edwardk> so that every time i insert something i pay down one step towards it
21:42:01 <edwardk> this is a Map, not a pipeline. it looks like a normal data structure to the nd user and they can be doing anything they want to it, sharing copies, etc.
21:42:18 <edwardk> i need to 'slowly' build immutable-thereafter vectors
21:42:28 <edwardk> and i can't afford to stop the world to build it all at once
21:42:35 <edwardk> hence the use of Slow
21:42:40 <mm_freak> what does "stop the world" mean?
21:42:58 <edwardk> i mean i can't afford to do a million steps of an algorithm during any one insert.
21:43:20 <edwardk> i want worst-case logarthmic time, not amortized ephemerally logarithmic time
21:43:44 <edwardk> as i will have cases where its not millions, but billions
21:44:02 <edwardk> and i need low pause times
21:44:12 <mm_freak> is there some process that needs to run continuously?
21:44:16 <edwardk> no
21:44:43 <edwardk> this is literally the nternals of a very strange Map replacement that lets me match the asymptotics of a b-tree cache obliviously and persistently
21:45:37 <edwardk> its not a pipeline, its just a data structure, that gives you lookups and inserts, and those inserts need to slowly percolate into the right places in very big vectors, but i can only pay a logarithmic-ish cost for any individual insert or lookup
21:45:47 <edwardk> and it has to look just like any other data structure
21:45:52 <edwardk> that is what i'm using Slow for
21:46:41 <edwardk> because i can 'start' the ST-like operation that merges two vectors together into a bigger vector and pay for it on step at a time as it digests in the belly of the Sarlacc over 1000 years ;)
21:47:10 <edwardk> if i stop adding entries to the map then i don't pay any more for the merge
21:47:34 <edwardk> i can't 'kick off a thread for it' because if i never look at the result i'll have done too much work for my amortization schedule
21:48:03 <edwardk> and if someone goes back and uses the structure one version before i'd kick off the thread, and feeds it another value, it'd also spin off in the background
21:48:20 <edwardk> this is a technical trick that lets me achieve asymptotics i didnt think i could do before
21:50:05 <edwardk> and which opens the door to a number of other algorithms we couldn't do in a functional setting before. it lets me use okasaki style implicit recursive slowdown on inherently imperative algorithms, whch lets me use overmars and van leeuwen's dynamization technique to take many static data structures and make not only dynamic data structures out of them with good amortized bounds, but dynamic data structures that are purely
21:50:07 <edwardk>  functional and hence functionally persistent, with good worst-case bounds
21:51:45 <edwardk> this'll give me nice algorithms for dynamic maintenance of convex hulls, dynamic data structures for nearest neighbor search, my wavelet trees, lets me capstone the work on stratifying b-trees by showing that i have a single data structure that hits literally basically the operations you can think of with provably optimal asymptotics across the board.
21:52:01 <edwardk> er 'basically all'
21:52:14 <mm_freak> edwardk: understood
21:52:27 <mm_freak> like a sorted vector that slowly sorts itself
21:52:33 <edwardk> yeah
21:53:06 <edwardk> here for the map i maintain several such vectors, and merge them as i go, the trick is keeping just enough of them merging at all times that i'm never 'starving' for work
21:53:14 <edwardk> that is the job of the number system i'm using
21:54:42 <edwardk> dmwit: anyways you can sneakily use unsafeInterleaveST twice to get that to work
21:55:25 <edwardk> dmwit: but its ironically safer to use unsafePerformIO due to the fact that I think unsafeInterleaveST is unsound in the presence of `par`.
21:55:44 <edwardk> unsafeInterleaveST, unlike unsafeInterleaveIO doesn't do the noDuplicate check
21:55:50 <edwardk> but that isn't correct
21:56:31 <dmwit> :t unsafeInterleaveST
21:56:32 <lambdabot> Not in scope: `unsafeInterleaveST'
21:56:48 <dmwit> ST s a -> ST s a?
21:57:44 <edwardk> yeah
21:58:09 <edwardk> https://github.com/ekmett/structures/blob/master/src/Data/Vector/Slow.hs#L122
21:58:27 <edwardk> that version is based on a free monad, not Iter, which i'm investigating now
22:08:17 <geothermalphysix> Iceland_Jack, thanks! It looks very friendly and inviting. Lambda awaits
22:08:37 <geothermalphysix> Iceland_jack
22:09:00 <Iceland_jack> Good luck geothermalphysix
22:09:18 <Iceland_jack> feel free to drop by the channel if you have any questions
22:09:35 <geothermalphysix> awesome, will do
22:26:58 <xico> what is the option to pass to ghc to set the location of .hi/.o files so that it uses a locally non-installed library?
22:27:36 <xico> (hidir)
22:40:02 <Dobiasd> Hi, I have a question regarding point free notation. Here is a minimum example of my problem, with the questions formulated in a comment: http://codepad.org/wVY4aS7U
22:40:22 <johnw> @pl bar' = (\x -> maybe False id x) . (foo 1)
22:40:23 <lambdabot> bar' = maybe False id . foo 1
22:40:44 <johnw> @pl bar b c = maybe False id $ foo 1 b c
22:40:47 <lambdabot> bar = ((maybe False id $) .) . foo 1
22:40:47 <lambdabot> optimization suspended, use @pl-resume to continue.
22:41:24 <Dobiasd> Wow, you habe a bot for this? That is awesome. :D Thank you
22:42:09 <startling> Dobiasd: lambdas aren't usually considered "point-free"
22:43:11 <Dobiasd> startling: ok, I just had no other Idea to try. ;)
22:43:53 <dmwit> ?pl bar b c = maybe False id $ foo 1 b c
22:43:55 <startling> :t const (const False) -- this is the same thing, afaict
22:43:56 <lambdabot> bar = ((maybe False id $) .) . foo 1
22:43:56 <lambdabot> optimization suspended, use @pl-resume to continue.
22:43:56 <lambdabot> b -> b1 -> Bool
22:45:12 <xico> is there an alternative name to 'flip maybe id'?
22:45:12 <dmwit> startling: You mean const (const True)?
22:45:18 <dmwit> :t flip maybe id
22:45:19 <lambdabot> a -> Maybe a -> a
22:45:20 <dmwit> :t fromMaybe
22:45:21 <lambdabot> a -> Maybe a -> a
22:45:29 <xico> dmwit: thanks :)
22:45:50 <dmwit> ?@ @hoogle @type flip maybe id
22:45:53 <lambdabot>  Data.Maybe fromMaybe :: a -> Maybe a -> a
22:45:53 <lambdabot>  Prelude asTypeOf :: a -> a -> a
22:45:53 <lambdabot>  Prelude maybe :: b -> (a -> b) -> Maybe a -> b
22:46:06 <xico> dmwit: you can combine?! great
22:49:11 <startling> dmwit: yeah.
22:49:20 <sopvop> I want foldWith in data foldable, which takes both monoid methods as arguments.
22:49:50 <startling> sopvop: isn't that foldr?
22:49:53 <sopvop> hm
22:49:56 <sopvop> well yes...
22:49:59 <startling> :t foldr mempty mappend
22:50:00 <lambdabot> Monoid a1 => [a] -> a1 -> a1 -> a1
22:50:01 * sopvop is a dumbass
22:50:08 <startling> :t fold
22:50:09 <lambdabot> (Foldable t, Monoid m) => t m -> m
22:51:02 <startling> :t foldr mappend mempty -- heh
22:51:02 <lambdabot> Monoid b => [b] -> b
22:51:33 <startling> I love when (->) instances give bizarro signatures
22:52:02 <sopvop> I love how DataKinds give bizzare type errors
22:52:59 <sopvop> One typo, and it finds some constructors which has same name as the typo and starts telling you what you chose wrong universe
22:53:03 <sopvop> or something like that
22:54:14 <startling> Sometimes I accidentally use Just a as a type instead of Maybe a.
22:54:28 <johnw> startling: heh, I do that sometimes too
22:54:47 <startling> I'm sure DataKinds would make the error more fun. :)
22:55:53 <startling> Haskell: Losing is Fun
22:56:25 <sopvop> DataKinds should always use 'Foo and not only to disambiguate Foo type from 'Foo constructor
23:29:06 <airlok9> I'm trying to run a function on every element in a list using map, but that function depends on the value at each index. Any ideas on how to solve? http://lpaste.net/95012
23:32:33 <dmj`> airlok9: You must think lazily
23:32:51 <dmj`> > zip [1..10] ['a'..]
23:32:54 <lambdabot>   [(1,'a'),(2,'b'),(3,'c'),(4,'d'),(5,'e'),(6,'f'),(7,'g'),(8,'h'),(9,'i'),(1...
23:34:02 <slack1256> lambdabot don't be THAT lazy, there are only 10 items
23:35:45 <dmwit> airlok9: I don't understand your question at all.
23:36:33 <startling> me neither.
23:36:36 <dmwit> What is "the value at the map's index"?
23:36:43 <dmwit> What is wrong with the existing code?
23:37:14 <dmwit> And what is up with your sample INPUTS/OUTPUTS?
23:37:39 <airlok9> dmwit: trying to demo the desired output
23:37:53 <airlok9> comparing against what it's actually spitting out
23:37:57 <dmwit> But your INPUTS don't have the right type, and there's two sets of OUTPUTS.
23:38:16 <airlok9> Yes, yes, there are functions in-between
23:38:18 <dmwit> That is, neither your inputs nor your outputs match applyJW's type.
23:38:36 <dmwit> So, you are expecting us to debug code that we cannot see?
23:38:54 <mzero> airlok9: I think we are confused by "depends on the value at each index"
23:39:25 <mzero> the value of what? the item in the list? the index itself? or do you mean some iterative value that is being computed as it trudges along?
23:39:44 <airlok9> mzero: slist is a list of strings. I want to run jaroWinkler on every string in for every String in that List.
23:39:58 <mzero> is this not just map?
23:40:15 <dmwit> 02:30 < dmwit> What is wrong with the existing code?
23:40:22 <airlok9> That's what I thought, but it outputs a length of 1
23:40:26 <mzero> > map reverse [ "rats" "are" "evil" ]
23:40:26 <airlok9> With clearly the wrong value
23:40:27 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]
23:40:27 <lambdabot>                             ...
23:40:37 <mzero> > map reverse [ "rats", "are", "evil" ]
23:40:37 <lambdabot>   ["star","era","live"]
23:40:49 <jfeltz> is there any practical benefit to studying some of the more algebraic topics that kmett (opeace be upon him) has made packages for?
23:41:18 <arkeet> you could ask edwardk yourself
23:41:21 <edwardk> =)
23:41:28 <dmwit> Yes. Next question!
23:41:29 <edwardk> which ones?
23:41:37 <mzero> uhm, wait, map can do anything but return a list of the exact same length that was pass to it
23:42:20 * dmwit suggests that mzero wait patiently for airlok9 to ask a better question, instead of trying to guess what the question is
23:42:29 <jfeltz> edwardk: semigroupoids, groupoids for example?
23:42:40 <_d3f> Hello, when using haskell to get the sum of [1/x | x < [1..]] (where 1/x should be float) I get a memory overflow. But the list 1/x should end in 0 on a PC. Is there a way to resolve this?
23:43:02 <dmwit> _d3f: Why should the list end?
23:43:05 <arkeet> semigroupoids is good for stuff like Apply and Foldable1 and stuff
23:43:11 * mzero suggests that he and dmwit have different pedigogical styles
23:43:42 <edwardk> semigroupoids exists because you can't use product categories in haskell right now, but product semigroupoids are used in anger. groupoids is used by 'constraints' which is currently mostly used to let you do some more advanced manipulations on constraint kinds you have to do because they unify via unification not via bi-entailment
23:43:59 <dmj`> > splitAt (length $ map fst $ takeWhile (\(x,y) -> x == y) $ zip "test" "test2345") "test2345"
23:44:00 <lambdabot>   ("test","2345")
23:44:01 <_d3f> dmwit: w8 I need to check if 1/x > 0 in the list ...
23:44:03 <edwardk> lens 4 is picking up relevant traversals and will use Apply more
23:44:12 <dmwit> _d3f: huh?
23:44:42 <edwardk> groupoids has been folded into semigroupoids 4
23:45:00 <mzero> _d3f: if you are hoping to terminate that list when 1/x > 0 by starting with the integers from 1... you are going to be waiting a long time!
23:45:06 <edwardk> algebra introduced the world to geometric coalgebra ;)
23:45:21 <edwardk> which at some point in time i need to do a formal writeup on
23:45:34 <_d3f> mzero: when 1/x is float it shouldn't be that "long"
23:45:43 <arkeet> _d3f: it would be very long.
23:45:46 <arkeet> what do you think the largest Float is?
23:45:48 <mzero> uhm... yes it would!
23:45:55 <arkeet> (it would use Double, in fact.)
23:46:27 <_d3f> 10^-38 wasn't it?
23:46:41 <mzero> that's, uhm, a long time, no?
23:46:44 <mzero> try it
23:46:49 <dmwit> That would be an awfully small largest number.
23:47:12 <mzero> > sum $ takeWhile (> 0.001) [ 1/x | x <- [1..] ]
23:47:13 <lambdabot>   7.484470860550343
23:47:27 <arkeet> > log 1000
23:47:28 <lambdabot>   6.907755278982137
23:47:28 <jfeltz> edwardk: sorry, most of that is pretty indistinguishable from gibberish for me at the moment, my perspective as a CS undergrad - is that I want to represent programming problems as math problems when possible, and topics such as monoids alone were pretty earth shattering to me, I'm wondering if delving into the rest is worthwhile
23:47:32 <arkeet> right, gamma.
23:47:32 <mzero> now- slowly make that epsion smaller....
23:47:39 <_d3f> mzero: the problem is my memory
23:47:59 <edwardk> jfeltz: monoid was 'you have an operation and it is associative and has a unit'
23:47:59 <arkeet> _d3f: I don't think you'll ever be able to add up 10^38 floats.
23:48:13 <edwardk> jfeltz: semigroup: 'you have an operation and its assocative'
23:49:11 <edwardk> jfeltz: category = 'monoid with multiple objects' , semigroupoid = 'semigroup with multiple objects'
23:49:35 <arkeet> _d3f: moreover:
23:49:44 <arkeet> > [(2^24 :: Float) ..]
23:49:45 <lambdabot>   [1.6777216e7,1.6777216e7,1.6777216e7,1.6777216e7,1.6777216e7,1.6777216e7,1....
23:49:51 <arkeet> > map (== 2^24) [(2^24 :: Float) ..]
23:49:52 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
23:50:23 <_d3f> hmm I see
23:50:35 <mzero> let's see.. at 10^9 additions / second ... it is still 10^29 seconds.... or... 3 x 10^21 years....
23:50:39 <edwardk> jfeltz: when you get around to playing with monads/applicatives, etc. you find there are certain categories involved. if you weaken the category to just be a semigroupoid, hen there are lots of things that aren't quite monad/applicative that can give rise to those things as well.
23:50:42 <arkeet> > 2^24 + 1 == (2^24 :: Float)
23:50:43 <lambdabot>   True
23:50:57 <arkeet> so in fact at some point your numbers won't ever get smaller.
23:51:04 <edwardk> jfeltz: semigroupoids is just about removing the requirement that id/pure/arr/return exists.
23:51:06 <arkeet> you'll hit 1/2^24 and repeat forever.
23:51:13 <dmwit> That's okay. That's the correct behavior for summing the harmonic series. =)
23:51:15 <arkeet> (1/2^53 for double)
23:51:27 <edwardk> jfeltz: by making the abstraction's requirements weaker, you get more instances!
23:51:54 <jfeltz> edwardk: thanks
23:51:59 <edwardk> jfeltz: so in many ways these weaker structures should be more relevant to your interests, since they appear in more places
23:52:35 <_d3f> arkeet: thx. I will tell my prof, as he ment that this should be possible ...
23:52:52 <dmwit> _d3f: Uh. Can we see the exact problem statement?
23:52:57 <arkeet> _d3f: there's a paper, called What Every Computer Scientist Should Know About Floating-Point Arithmetic.
23:53:02 <arkeet> you might consider read it.
23:53:05 <dmwit> I suspect somewhere there's been a misunderstanding.
23:53:09 <arkeet> reading
23:53:15 <_d3f> dmwit: it's in german
23:53:23 <jfeltz> edwardk: i noticed that some of the data-structures could be handled through treating them as monoids, thus allowing for greater modularity, so that is the payoff for me right now
23:53:23 <edwardk> i try to define the classes that theory indicates should exist that have the fewer constraints they put on the types involved, because instances for them are virtually everywhere, and by saying that some type is an instance of one of them is enough to give me a.) insight and b.) a few free combinators i can use in even more situations.
23:53:25 <dmwit> ah, bummer
23:53:36 <arkeet> well, I'm sure one of the 1166 other users here speaks german
23:53:42 <_d3f> arkeet: I will look for it
23:54:01 <edwardk> jfeltz: a semigroup is just a monoid that doesn't necessarily have a unit
23:54:04 <arkeet> _d3f: somehow I doubt that your prof meant that. but if he did, he should read it too.
23:54:47 <edwardk> consider: newtype Min a = Min { getMin :: a }; instance Ord a => Semigroup (Min a) where Min a <> Min b = Min (min a b)
23:54:58 <edwardk> to have a unit for it 'a' has to have an upper bound.
23:55:06 <mzero> okay! I have a shell script that should patch up GHC to work with Xcode 5
23:55:11 <mzero> yay!
23:55:11 <sopvop> after applicative=>monad reform, next one will be apply=>applicative, semigroup=>monoid...
23:55:15 <edwardk> you can make one some times, but not always. consider Integer.
23:55:44 <edwardk> instance (Ord a, Bounded a) => Monoid (Min a) where mempty = Min maxBound
23:56:16 <edwardk> sopvop: i'm kicking that down the road til i'm not chair'ing the committee. =)
23:56:20 <arkeet> I suppose it's on the large side for a paper.
23:56:56 <sopvop> edwardk: What if you become about base library Czar?
23:57:03 <edwardk> sopvop: mostly because i 'have a dog in this fight' in terms of having written them, and also because i'm don't think that haskell the language we have today is terribly good at dealing with fine grained class hierarchies.
23:57:06 <sopvop> delete about
23:57:28 <edwardk> sopvop: http://www.haskell.org/haskellwiki/Core_Libraries_Committee
23:57:45 <sopvop> Oh, so thats how it works
23:58:17 <edwardk> sopvop: but even in that capacity i'm not comfortable pushing for Apply/Bind in the hierarchy
23:58:27 <_d3f> arkeet: http://wikisend.com/download/356622/Aufgabenblatt-03.pdf
23:58:31 <edwardk> haskell is remarkably bad at dealing with very fine-grained class hierarchies =(
23:59:02 <arkeet> what's better?
23:59:04 <edwardk> that was one of the things i pointed out in https://www.fpcomplete.com/user/edwardk/editorial/procrustean-mathematics
