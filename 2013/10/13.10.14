00:09:52 <Athan> anyone know how to use (<-) properly?
00:09:59 <Athan> my mind doesn't work anymore :S
00:12:15 <startling> Athan, learning the explicit (>>=) notation might help.
00:12:23 <startling> <- is not an operator.
00:12:44 <Athan> ah yeah I just got it
00:13:05 <startling> Are you sure? :)
00:13:16 <Athan> each line that's got a <- basically extracts the monad and appies the internal into a new lambda's parameter?
00:13:20 <Athan> ie
00:13:41 <Athan> x <- something == something >>= (/x -> ...)
00:13:49 <Athan> ?
00:13:50 <startling> exactly.
00:13:55 <Athan> :D
00:13:58 <Athan> hmm
00:14:04 <Athan> have you worked with yesod before?
00:14:07 <startling> @undo do { x <- something; }
00:14:07 <lambdabot> <unknown>.hs: 1: 23:Parse error: Last statement in a do-block must be an expression
00:14:14 <startling> @undo do { x <- something; return x; }
00:14:15 <lambdabot> something >>= \ x -> return x
00:14:29 <Athan> oh wow that's cool
00:14:37 <startling> I haven't. I'm sure people here have, if you've got a specific question.
00:14:37 <Jesin-phone> What library with you guys suggest for matrix algebra
00:14:48 <startling> Athan: There might also be a yesod channel.
00:15:04 <Athan> I'll check it out, thanks man
00:15:52 <startling> Jesin-phone, you might try http://www.haskell.org/haskellwiki/Linear_algebra , especially the link at the end.
00:16:06 <startling> That information might be way out of date, though.
00:20:09 <Jesin-phone> Ooh, hmatrix looks great
00:21:20 <carter> Jesin-phone: hmatrix is starting to get long in the tooth
00:21:21 <carter> i'm hopefully getting my modern stuff out soon
00:21:21 <carter> also everyone: http://www.haskell.org/pipermail/haskell-cafe/2013-September/110320.html is the living link for my XCODE 5 PSA
00:21:25 <carter> please share it with folks
00:21:29 <carter> so i don't have to
00:21:59 <Jesin-phone> "Long in the tooth"?
00:22:08 <startling> "old"
00:22:14 <carter> yes
00:22:15 <carter> old
00:22:20 <carter> and not extensible
00:22:47 <carter> i've kinda been hacking on the design for a nicer thing for the past … 1+ year
00:22:51 <carter> the design part is the hardest part
00:22:56 <carter> mostly done with the core now
00:23:02 <carter> just need to hae the time to focus
00:23:47 <carter> ok i'm off
00:39:28 <startling> Does the DeriveFunctor instance include {-# INLINE fmap #-} ?
00:39:49 <startling> Well, my question is: might deriving it by hand give me nicer inlining?
00:40:33 <johnw> startling: shachaf has mentioned situations where DeriveFunctor had horrible performance
00:40:41 <johnw> but that may have been fixed
00:41:06 <johnw> huh, shachaf isn't on any channels today
00:41:14 <startling> He was just an hour or two ago.
00:41:14 <edwardk> its fixed now in head, not sure about 7.6.3 or when it happened
00:41:33 <startling> I wrote scalar multiplication et al in terms of fmap; I was wondering why they were overwhelming cost centers.
00:41:34 <edwardk> maybe 3 months ago
00:42:50 <startling> Is INLINE-ing typeclass instances generally a performance increase?
00:44:31 <edwardk> it highly depends
00:45:10 <edwardk> what ghc are you on?
00:45:20 <startling> 7.6.3.
00:51:21 <donri> functor too? i remember foldable/traversable deriving badly
00:52:00 <arkeet> too much eta expansion, or something.
00:53:10 <arkeet> ah, just foldable and traversable.
00:53:22 <arkeet> oh no, functor too.
00:53:41 <arkeet> http://ghc.haskell.org/trac/ghc/ticket/7436
00:58:02 <startling> Yeah, handwriting half my instances saved off ~ a fifth of a second.
00:59:53 <startling> (The whole run-time is about a second.)
01:07:27 <johnw> edwardk: what do you think of Serge Lang's Algebra book?
01:09:23 <startling> everyone seems to hate Lang.
01:09:46 <johnw> how about Dummit?
01:09:54 <startling> I don't know anything about the Algebra book, but people say he's not great. OTOH he was part of Bourbakai ...
01:09:55 <johnw> i finally bought Mac Lane today
01:55:34 <ziman> :t fix (ap . (:))
01:55:35 <lambdabot>     Couldn't match type `[m0 a0 -> m0 b0]' with `a0 -> b0'
01:55:35 <lambdabot>     Expected type: (m0 a0 -> m0 b0) -> m0 (a0 -> b0)
01:55:35 <lambdabot>       Actual type: (m0 a0 -> m0 b0)
01:56:31 <startling> do inlined things get specialized automatically if the code they are inlined into is specialized?
01:59:23 <prophile> :t newIORef >>= (readIORef &&& writeIORef)
01:59:24 <lambdabot>     Not in scope: `newIORef'
01:59:24 <lambdabot>     Perhaps you meant `newSTRef' (imported from Data.STRef)
01:59:24 <lambdabot>     Not in scope: `readIORef'
01:59:44 <prophile> :t newSTRef >>= (readSTRef &&& writeSTRef)
01:59:45 <lambdabot>     Couldn't match type `ST s0 (STRef s0 a0)' with `STRef s1 a1'
01:59:45 <lambdabot>     Expected type: ST s0 (STRef s0 a0) -> ST s1 a1
01:59:45 <lambdabot>       Actual type: STRef s1 a1 -> ST s1 a1
01:59:59 <prophile> :t \x -> (newSTRef x >>= (readSTRef &&& writeSTRef))
02:00:00 <lambdabot>     Couldn't match type `(ST s0 a0, a0 -> ST s0 ())' with `ST s0 b0'
02:00:00 <lambdabot>     Expected type: STRef s0 a0 -> ST s0 b0
02:00:00 <lambdabot>       Actual type: STRef s0 a0 -> (ST s0 a0, a0 -> ST s0 ())
02:00:05 <startling> prophile: (&&&) doens't lift things out of the resulting tuple
02:00:16 <prophile> ah yes
02:00:26 <startling> :t newSTRef >>= both id (readSTRef &&& writeSTRef)
02:00:27 <lambdabot>     Couldn't match expected type `ST s0 (STRef s0 a0) -> a0 -> b0'
02:00:28 <lambdabot>                 with actual type `(c0, (b1, b1))'
02:00:28 <lambdabot>     In the return type of a call of `both'
02:00:36 <startling> :t newSTRef >>= both id . (readSTRef &&& writeSTRef)
02:00:36 <prophile> :t \x -> (readSTRef &&& writeSTRef) <$> (newIORef x)
02:00:37 <lambdabot>     Not in scope: `newIORef'
02:00:37 <lambdabot>     Perhaps you meant `newSTRef' (imported from Data.STRef)
02:00:37 <lambdabot>     Couldn't match type `ST s0 (STRef s0 a0)' with `STRef s1 a1'
02:00:37 <lambdabot>     Expected type: ST s0 (STRef s0 a0) -> a0 -> ST s2 ()
02:00:37 <lambdabot>       Actual type: STRef s1 a1 -> ST s1 a1
02:00:42 <prophile> :t \x -> (readSTRef &&& writeSTRef) <$> (newSTRef x)
02:00:43 <lambdabot> a -> ST s (ST s a, a -> ST s ())
02:00:46 <prophile> there we go
02:01:10 <quicksilver> or the instance of &&& for the kleisli monad, perhaps?
02:01:22 <quicksilver> arrow
02:02:10 <prophile> how would that work?
02:02:55 <quicksilver> well you need to do something about writeSTRef's second parameter to make it work.
02:03:27 <Lethalman> :t readSTRef &&& writeSTRef
02:03:28 <lambdabot> STRef s a -> (ST s a, a -> ST s ())
02:04:35 <donri> :t runKleisli (Kleisli newSTRef >>> (Kleisli readSTRef &&& Kleisli writeSTRef))
02:04:38 <lambdabot>     Couldn't match type `c0 -> ST s0 ()' with `ST s0 c'0'
02:04:38 <lambdabot>     Expected type: STRef s0 c0 -> ST s0 c'0
02:04:38 <lambdabot>       Actual type: STRef s0 c0 -> c0 -> ST s0 ()
02:06:25 <johnw> :t runKleisli (Kleisli newSTRef >>> Kleisli (readSTRef &&& Kleisli writeSTRef))
02:06:25 <lambdabot>     Couldn't match expected type `Kleisli ((->) a2) (STRef s2 a2) c0'
02:06:26 <lambdabot>                 with actual type `STRef s1 a1 -> ST s1 a1'
02:06:26 <lambdabot>     In the first argument of `(&&&)', namely `readSTRef'
02:06:33 <johnw> :t runKleisli (Kleisli newSTRef >>> Kleisli (readSTRef &&& writeSTRef))
02:06:34 <lambdabot>     Couldn't match type `(ST s0 a0, a0 -> ST s0 ())' with `ST s0 b0'
02:06:34 <lambdabot>     Expected type: STRef s0 a0 -> ST s0 b0
02:06:34 <lambdabot>       Actual type: STRef s0 a0 -> (ST s0 a0, a0 -> ST s0 ())
02:07:31 <donri> :t runKleisli (Kleisli newSTRef >>> (Kleisli readSTRef &&& Kleisli (`writeSTRef` 123)))
02:07:32 <lambdabot> Num c => c -> ST s (c, ())
02:07:43 <donri> i'm not sure what you're trying to do?
02:09:52 <xenocons> :t (>>>)
02:09:53 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
02:09:57 <xenocons> interesting
02:13:26 <arkeet> >>> is just a flipped .
02:14:02 <arkeet> for Kleisli it's just >=>, up to newtypes
02:14:06 <t7> :t show >>> read :: Int
02:14:07 <lambdabot>     Couldn't match expected type `Int' with actual type `a0 -> a1'
02:14:07 <lambdabot>     In the expression: show >>> read :: Int
02:14:15 <t7> :t show >>> read :: Int -> Int
02:14:16 <lambdabot> Int -> Int
02:14:34 <arkeet> more precisely, it's a flipped Control.Category..
02:14:36 <arkeet> not Prelude..
02:14:42 <arkeet> but who cares. =(
02:16:56 <donri> :t (newSTRef >=> (readSTRef &&& (`writeSTRef` 123)))
02:16:57 <lambdabot>     Couldn't match type `(ST s0 a0, ST s0 ())' with `ST s0 c0'
02:16:57 <lambdabot>     Expected type: STRef s0 a0 -> ST s0 c0
02:16:57 <lambdabot>       Actual type: STRef s0 a0 -> (ST s0 a0, ST s0 ())
02:42:08 <hc> hi all, i'm lazily reading a file inside an STM monad, i'm getting the error Control.Concurrent.STM.atomically was nested
02:42:21 <hc> I'm not getting any error when I'm forcind the string to be evaluated before entering the atomically block
02:42:32 <hc> is there some documentation available about this behaviour somewhere?
02:43:18 <fizruk> hc: could you paste some related code?
02:43:40 <fizruk> @where paste
02:43:40 <lambdabot> http://lpaste.net/new/haskell
02:44:11 <lpaste> hc pasted “Experiments4.hs” at http://lpaste.net/7035383351150116864
02:44:45 <hc> fizruk: there it is; if you uncomment the line 'print randomness', the program will work just find
02:44:48 <hc> s/find/fine/
02:47:53 <quicksilver> hc: well the bottom line is 'never use hGetContents'
02:48:43 <quicksilver> but as a workaround pseqing "length randomness" instead of merely randomness might suffice.
02:49:20 <hc> ah, thanks
02:49:50 <hc> yeah, i understand the combination of hGetContents and atomically is bad; i just wonder exactly why that is ;-)
02:50:18 <quicksilver> GHC's STM implementation doesn't like being tricked into doing IO inside an atomically block
02:50:30 <hc> haha, alright
02:50:34 <hc> is that documented somewhere?
02:50:40 <quicksilver> although I must admit I wouldn't have predicted the error you got
02:50:47 <quicksilver> and neither can I entirely explain it
02:50:52 <fizruk> something is here: http://hackage.haskell.org/package/stm-2.1.1.2/docs/Control-Monad-STM.html#v:atomically
02:51:02 <quicksilver> suggests that STM/atomically is used in part of the implementation of hGetContent's interleaved IO.
02:51:51 <fizruk> although it says "cannot use atomically inside of unsafe..." I guess the other way around doesn't work either
02:53:30 <hc> thank you!
02:56:43 <hc> the fix to use (length randomness) `pseq`... works
03:01:24 <fizruk> :t writeTChan
03:01:24 <lambdabot> Not in scope: `writeTChan'
03:02:06 <sqdfsq> :t ParseError
03:02:08 <lambdabot> Not in scope: data constructor `ParseError'
03:02:20 <sqdfsq> :i ParseError
03:08:11 <sqdfsq> I'm trying to read values of a ParseError (parsec)
03:08:23 <sqdfsq> But I can't really access the data structure
03:08:28 <sqdfsq> see http://lpaste.net/94265
03:08:41 <sqdfsq> It's probably something simple, I'm just starting out...
03:12:45 <fizruk> sqdfsq: ParseError is abstract, you can't get access to its internals
03:13:21 <sqdfsq> ah
03:13:28 <fizruk> sqdfsq: there are some special access functions though: see http://hackage.haskell.org/package/parsec-3.1.3/docs/Text-Parsec-Error.html#t:ParseError
03:16:15 <sqdfsq> errorMessages & messageString will do the trick
03:16:30 <sqdfsq> thc fizruk
03:16:34 <sqdfsq> thk*
03:16:46 <sqdfsq> thanks**
03:16:50 <sqdfsq> :)
03:16:58 <fizruk> :)
03:45:51 <danilo2> Hello :) What is the standard way in haskell to write to stderr? Should I use hPutStr stderr "something" or is there any other more preferred method?
03:46:38 <Lethalman> danilo2, if you want something more structured there's System.Log.Logger
03:46:56 <Lethalman> or in general logging to stderr
03:48:27 <danilo2> Lethalman: Ok, of course :) I'm using logging normally but right now I was looking for something very simple and very often we have in haskell some libraries, we should avoid, and becauseof that I was asking this question. thank you :)
03:49:06 <Lethalman> danilo2, if you can rephrase... :)
03:53:46 <danilo2> Lethalman: heh, I'm sorry :) I was trying just to say, you're right :) Thank you :)
04:06:48 <erisco> can you go from IO a to ST RealWorld a?
04:07:40 <Saizan> erisco: no
04:07:45 <erisco> =\
04:08:21 <erisco> can I do everything that I can do in ST from IO?
04:10:49 <quicksilver> erisco: you can, yes, and if that's what you need to then you asked the wrong way around
04:11:05 <quicksilver> you should have asked "can you go from ST RealWorld a to IO a"
04:11:10 <quicksilver> and the answer would have been yes
04:11:15 <erisco> I'm only asking this way around now because the first way wouldn't work according to Saizan
04:11:16 <quicksilver> although 9/10 you don't need to use stToIO.
04:11:46 <quicksilver> you can after all just use IORefs and IOArrays.
04:12:02 <erisco> well I am already using ST stuff in parts...
04:12:55 <erisco> ah but I can go from ST RealWorld a to IO, so that should be fine
04:13:28 <erisco> well I guess not *shrug*
04:13:37 <erisco> I mean, I want to do putStr, for example
04:13:51 <erisco> but I'm in the ST monad...
04:14:19 <Saizan> yeah, the ST monad can't allow you to putStr, otherwise runST couldn't have that type
04:15:21 <erisco> this will be difficult then
04:15:29 <ehamberg> erisco: if you just want debug printing, have a look at Debug.Trace's trace function
04:15:54 <erisco> no I want to be able to write to the world
04:16:19 <Saizan> i'd use IO then
04:16:26 <erisco> but I do not need to read... if my return type is always unit, could I not do this safely from ST?
04:18:17 <erisco> I think unsafePerformIO is fine here
04:18:39 <Saizan> it really isn't, but you can shoot in your foot if you want :)
04:19:27 <erisco> why is it not?
04:20:15 <Saizan> e.g. if you care about writing happening in some predictable order, some exact number of times, then unsafePerformIO doesn't guarantee any of that
04:22:37 <quicksilver> erisco: if you're using unsafePerformIO you're no guaranteeing you aren't reading.
04:22:44 <quicksilver> you might as well just use IO and not read.
04:22:47 <quicksilver> it's the same thing.
04:23:08 <quicksilver> you could newtype IO and only permit the operations you want, though.
04:23:55 <erisco> an appropriate API could be developed on top to prohibit unwanted operations, and to solve the issues Saizan mentioned, yes? that seems to be what ST and IO monads are about
04:24:25 <quicksilver> ST is about being able to do mutable code within a pure calculation safel
04:24:31 <quicksilver> that's entirely different from restricted IO
04:24:45 <quicksilver> restricted IO is a natural notion you can implement in pure haskell with a newtype
04:24:58 <quicksilver> ST requires special compiler support.
04:27:41 <Disgrntld> Can someone explain the type of bracketOnError (and bracket) to me (:: IO a -> (a -> IO b) -> (a -> IO c) -> IO c)? How can the error handling function (a -> IO b) yield a different type than the common case? What if I am relying on bracketOnError to yield a value of type 'c' and I get a 'b'?
04:27:48 <Saizan> it's not like there's a way to add writing to something like ST without giving up most basic properties of haskell
04:28:42 <Saizan> Disgrntld: it's not really an "handling" function, it's a cleanup function before the error gets rethrown
04:30:16 <Disgrntld> Saizan: so, let's say there's an IO error when bracketOnError runs, will it still yield a value of type 'c' no matter what?
04:31:30 <Saizan> Disgrntld: no, it will throw an exception
04:31:53 <Saizan> ?hoogle throwIO
04:31:54 <lambdabot> Control.Exception.Base throwIO :: Exception e => e -> IO a
04:31:54 <lambdabot> Control.Exception throwIO :: Exception e => e -> IO a
04:31:54 <lambdabot> Control.OldException throwIO :: Exception e => e -> IO a
04:32:09 <Lethalman> Disgrntld, the release is not called when there's an exception
04:32:34 <Lethalman> Disgrntld, that is, IO a is not supposed to throw an exception, a -> IO c is always run
04:33:02 <Lethalman> mh I wasn't clear
04:33:03 <Saizan> when you throw an exception you get to be polymorphic in the result type, because the surrounding code won't get called anyway, only exception handlers
04:33:44 <Saizan> ?type Control.Exception.catch
04:33:44 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
04:34:04 <Lethalman> Disgrntld, the final IO c is due to a -> IO c, not due to a -> IO b
04:34:12 <Lethalman> a -> IO b is just there for releasing
04:34:20 <Saizan> "h" in "catch m h" is never given an 'a'
04:34:35 <danilo2> Hi! I'm writing a ghc-pkg wrapper, which patches the package descriptor from cabal and replaces hardcoded paths with variables (to make them movable in filesystem). I see, that cabal calls "ghc-pkg update - --global --no-user-package- db"
04:34:53 <danilo2> While registering new packages and the package descriptor probably goes over stdin. The problem is that
04:35:10 <Disgrntld> ok, still fuzzy for me tbh as I know nothing about Haskell exceptions yet (just read through LYAH's IO section).. I feel like until I learn about exceptions I'll just hav eto set this aside
04:35:38 <Lethalman> Disgrntld, don't think as bracket for exception handling, think of it for releasing an acquired resoruce
04:35:41 <danilo2> when I "readLine" in my wrapper, the program hangs (it does not recive any input from stdin) -does anybody know why this happens or where I make a mistake?
04:35:52 <Disgrntld> I think that is my problem, Lethalman
04:36:14 <Lethalman> Disgrntld, the OnError is there to force release in case of exception, but a -> IO b has nothing to do with the return value
04:36:17 <Disgrntld> I just saw it as an error handler
04:36:45 <Lethalman> Disgrntld, it handles the error in that it release the resource, but then the exception is rethrown
04:36:55 <erisco> Saizan, hm, I get no side effect at all in my case... I wonder if the compiler is figuring out the return value is always () and therefore discards everything else
04:37:14 <Disgrntld> gotcha, well, I tihnk as much as I will at this point
04:37:39 <Disgrntld> thanks for the explanation and pointing me where to learn more, Saizan and Lethalman
04:38:22 <Saizan> erisco: yeah, the "number of times" can be 0, though i suspect if you are strict enough on that resulting () you'll get the side effect
04:46:07 <erisco> Saizan, how might I be strict?
04:49:04 <erisco> Prelude.seq (unsafePerformIO $ Prelude.putStr "hello") ()
04:49:14 <erisco> I haven't used seq before so maybe this is not sensical
04:49:56 <erisco> > Prelude.seq (unsafePerformIO $ Prelude.putStr "hello") ()
04:49:57 <lambdabot>   Not in scope: `unsafePerformIO'
04:50:38 <mikeplus64> erisco: a neat side-effect of this is that seq'ing IO operations will evaluate the pure parts of it, such as branches (if they don't e.g. depend on another IO action)
04:51:30 <Amadiro> I've compiled ghc on rhel6, and it looks like the configure script correctly found /usr/lib64/libgmp.so.3, but when I run ghc, it only looks for /usr/lib64/libgmp.so. Anybody know why that could be, and how to fix it?
04:52:37 <dmwit> mikeplus64: ...he's not seq'ing an IO operation.
04:52:49 <dmwit> erisco: Even after reading the logs, I'm still confused about exactly what it is you're trying to do.
04:53:06 <dmwit> erisco: ...and why you aren't doing whatever that is from within IO.
04:53:51 <erisco> ah I suppose I have to also be strict on the value returned by seq, else it won't evaluate the first argument
04:54:09 <dmwit> Amadiro: Strange. What makes you say configure found the right thing? Also, are you sure you're running the newly-built GHC?
04:54:38 <dmwit> erisco: Yeah, I don't think that seq call is helping you at all there.
04:54:39 <erisco> dmwit, in my limited knowledge this is what I should do for now. I cannot really explain everything as I am still learning and experimenting
04:55:06 <Amadiro> dmwit, well, the configure script surely would complain if it didn't find libgmp, right? Yeah, I am running the right ghc (the system has no ghc from before), and I'm using the generic linux amd64 binary distro, btw
04:55:24 <Amadiro> retrying with --with-gimp-includes=... and --with-gmp-libraries=... now
04:55:55 <Amadiro> s/gimp/gmp/
04:56:02 <dmwit> erisco: That's a very strange attitude. You have at least three people who have significantly less-limited knowledge telling you Don't Do That. If I were in your shoes, I'd be working as hard as I could to find out why.
04:57:39 <erisco> dmwit, that is kind of you but I feel it'd be wasting your time for me to try and describe what I'm after at this time
04:57:40 <Amadiro> No luck -- it still looks for libgmp.so in the wrong place (I made a separate folder with a libgmp.so)
04:58:43 <Amadiro> I guess I'll just have to LD_LIBRARY_PATH="/path/to/my/libgmp.so-folder/:$LD_LIBRARY_PATH"
04:58:46 <dmwit> Amadiro: er
04:59:02 <dmwit> Amadiro: Tell me more about this: "I'm using the generic linux amd64 binary distro, btw".
04:59:12 <dmwit> Amadiro: This means you downloaded the binary of GHC from GHC's website?
04:59:18 <Amadiro> dmwit, correct.
04:59:28 <dmwit> Amadiro: If so, "I've compiled ghc on rhel6" is incorrect.
04:59:37 <Amadiro> dmwit, oops. Yes, entirely incorrect.
04:59:47 <Amadiro> I've been compiling packages all day, sorry :)
04:59:55 <dmwit> Amadiro: Okay, then it's looking for /usr/lib64/libgmp.so because the person who built it linked with that.
05:00:08 <Amadiro> dmwit, so then the configure flags... do nothing?
05:00:14 <dmwit> I shouldn't think so.
05:00:48 <dmwit> To be less ambiguous: I would be very surprised if the configure flags you suggested do anything.
05:01:00 <Amadiro> So then surely its a bug that they are there...?
05:01:32 <danilo2> Hello :) Is there any library in Haskell, which parses cabal package descriptors configuration files ?
05:01:38 <dmwit> I don't know. I guess.
05:01:46 <danilo2> *cabal package descriptors files
05:01:49 <Amadiro> Allright. I'll compile it myself, then
05:02:18 <dmwit> danilo2: Cabal, presumably
05:03:11 <dmwit> Amadiro: I have heard that symlinking libgmp.so.3 to libgmp.so works. But you didn't hear it from me and it's not my fault when your computer explodes, etc.
05:03:26 <Amadiro> dmwit, yeah, I'm not allowed the easy way out, unfortunately
05:03:38 <Amadiro> but yeah, it does work
05:03:45 <dmwit> Okay. I can understand not wanting to do that.
05:06:16 <danilo2> dmwit: Ok, I was thinking that maybe there is some library to parse such configs. It would make sense to keep it as a library, because not only cabal could use it easly then :)
05:06:28 <dmwit> danilo2: Yes, there is a library.
05:06:32 <dmwit> danilo2: The library is named Cabal.
05:12:22 <Amadiro> dmwit, hm, it looks like compiling ghc requires ghc ("unless bootstrapping from .hc files") -- any clue where I'd get those .hc files from?
05:12:39 <dmwit> Amadiro: Correct, compiling GHC requires GHC.
05:13:25 <Amadiro> well, I guess I can use the binary version if I have to...
05:13:30 <dmwit> I don't know anything about other ways to do it. I was under the impression that if you wanted to do it without having a binary of GHC at all you had to go back essentially to the beginning of GHC history, when it was written in C, and bootstrap from there.
05:13:32 <Amadiro> (to do the bootstrapping)
05:14:04 <dmwit> Amadiro: But surely RHEL has GHC in its repositories...?
05:14:26 <Amadiro> dmwit, we're maintaining a separate in-house repository of more up-to-date software than the ancient stuff rhel provides us with
05:14:38 <Amadiro> so I have to package that stuff myself
05:14:53 <dmwit> Right, but if they have an old GHC, you can use that to bootstrap a new one.
05:14:53 <Amadiro> and installing packages is a rather longwound beaurocratic process
05:15:06 <dmwit> I see.
05:15:26 <dmwit> Bootstrap a new one on a virtual machine. =)
05:15:29 <Amadiro> so I'll just go the "use binary version from my home dir"-route
05:16:10 <Amadiro> dmwit, getting permission to set up a VM is at least equally beurocratic, because rhel licenses and all that shit
05:16:23 <dmwit> Don't set it up on this box. ;-)
05:16:24 <Amadiro> although I guess I could probably do it in a fedora vm
05:16:38 <dmwit> Oh, sorry, I didn't read that carefully enough.
05:16:49 <dmwit> Scratch the "use your own box" suggestion.
05:18:11 <bxc> are there names for the "function application on the left" style of writing things vs the "unix pipes" like style:   eg  print =<< (readIORef foo)  (like f a)  vs (readIORef foo) >>= foo   (like echo a | cat)  - not just in monads but in general
05:20:34 <quicksilver> applicative notion or prefix function application, bxc
05:22:34 <bxc> for the first one both?
05:22:58 <bxc> i mean are those both names for the  "function application on the left" style
05:24:17 <erisco> Saizan, you were right, the unit value was not being evaluated. I was able to fix that using seq. thanks
05:26:40 <danilo2> Do you plan to update cabal to use variables instead of hardcoded full paths in package descriptors? I remember one day I was talking with somebody about it and as far as I remember it should not be very hard for a cabal developer, because the variables (like ${pkgroot}) are available for over 2 years or something like that.
05:28:05 <danilo2> This would make ghc installation movable on Linux boxes, like it is on Windows ones
05:32:44 <dmwit> danilo2: Package descriptors use hardcoded full paths?
05:34:45 <danilo2> dmwit: yes! If you run "cabal install" it passes a package descriptor to ghc-pkg and this descriptor uses hardcoded paths. Look at your ghc installation dir/lib/ghc-7.6.3/package.conf.d/<any package>. There you can see fields like "import-dirs", which have hardcoded full paths, but they can use variables instead
05:35:24 <dmwit> I see. Perhaps I gave you bad advice earlier, then; I thought package descriptor meant something else.
05:35:51 <dmwit> Apologies for that, if so.
05:36:54 <danilo2> dmwit: no problem, I handle it right now, but I had to create a ghc-pkg wrapper, which patches all package descriptors got from cabal to use "${pkgroot}" variable instead of hardcoded path. This is ugly and I'm curious if somebody (who nows cabal) could fix this in the future.
05:37:31 <danilo2> This is very easy fixable - just instead of pass full package path, we shoudl use this variable on the beginning
05:38:25 <danilo2> additionaol to make ghc fully movable on Linux the scripts "ghc", "gthc-pkg" etc needs to be patched also (thay are simple bash scripts) - I've got them patched, so If you want I can provide the movable versions of them, but somebody needs to patch cabal also
05:43:59 <mm_freak> instance (Reifies n Integer) => Show (Relation n) where
05:44:08 <mm_freak> this is undecidable according to GHC
05:44:22 <mm_freak> do i really have to make Relation polymorphic to fix that?
05:44:54 <mm_freak> or is there some way to convince GHC that this is decidable?
05:45:09 <mm_freak> (other than enabling UndecidableInstances)
05:46:01 <dmwit> Why shouldn't it be undecidable? What's stopping somebody from writing instance Show (Relation SomethingOrOther) => Reifies SomethingOrOther Integer?
05:47:29 <quicksilver> that's not what undecidable means in this context
05:47:47 <quicksilver> it just means "fails a specific context which exists to be a conservative check for decidability"
05:47:55 <quicksilver> so really undecidable is the wrong work.
05:47:57 <quicksilver> word
05:48:11 <quicksilver> the point is rather than GHC doesn't know that that instance is decidable.
05:48:41 <dmwit> Is it really decidable, though?
05:48:42 <prophile> is there a means of controlling green thread interleavings in GHC?
05:48:52 <dmwit> I mean.
05:49:45 <mm_freak> prophile: not really…  if you don't want threads to be interleaved, they should have some data-dependency
05:49:47 <dmwit> prophile: You mean like MVars, STM, etc.?
05:50:04 <prophile> dmwit: no, I mean the actual order they're scheduled to run
05:50:08 <ciaranm> if only ghc could decide whether or not it's decidable
05:50:20 <prophile> I was hoping to be able to repeatably reproduce some hairy threading bugs :(
05:50:41 <dmwit> Yeah, that's very, very hard.
05:50:53 <mm_freak> prophile: MVar has some guarantees that might help you there, but it's difficult in general
05:51:14 <mm_freak> ok, i'll make Relation polymorphic in the element type
05:51:24 <prophile> mm_freak: that's a pity
05:54:16 <mm_freak> instance (Modulus n a, a ~ Integer) => Show (Relation n a) where
05:54:20 <mm_freak> this one works
05:54:32 <mm_freak> but it's the same thing, except that Relation is now parameterized
05:55:01 <mm_freak> instance (Modulus n Integer) => Show (Relation n Integer) where
05:55:03 <mm_freak> or rather this one
05:56:35 <danilo2> If is here somebody involved in cabal development I would like to help to fix the package descriptors not to use hardcoded full paths and use variable based ("${pkgroot}") relative ones, If somebody give me a hint how can I start working on it to fix it in a not very long time :)
05:57:08 <dmwit> mm_freak: I conclude that I don't yet understand UndecidableInstances. Since to me that looks no more decidable than the last one.
05:57:14 <danilo2> (see above discussion about hardcoded paths in package descriptors)
05:58:14 <dmwit> danilo2: I'm not a cabal expert, but in case one doesn't appear, you might consider looking for a bug on their tracker and creating one if you don't find anything. Saying you want advice in the description of such a bug is likely to get you some.
05:58:15 <mm_freak> dmwit: it is decidable (the type-checker can verify in finite time)
06:00:03 <danilo2> dmwit: I do not belive in that. ability to use such variable was introduced over 2 years ago and nobody fixed that until now. I like the community on haskell irc, because it is very responsible, but I simply do not belive in "cabal" bug tracker any more
06:00:15 <mm_freak> dmwit: you may be confusing decidability with overlapping, but to be honest, i don't quite understand the criteria for instance decidability either
06:00:16 <danilo2> dmwit: but if is the only option, I'll try there
06:00:25 <mm_freak> GHC surprises me every other day about that =)
06:00:48 <dmwit> danilo2: Are you saying a bug has been open for two years?
06:00:59 <dmwit> And with no discussion about how to fix it?
06:02:30 <danilo2> dmwit: no, but this feature to make GHC movable on Linux boxes was introduced over 2 years ago. I'm writing a bug right now :)
06:03:10 <dmwit> If there was no bug, then I don't consider "they haven't implemented it" good evidence that the bug tracker doesn't work.
06:07:50 <danilo2> dmwit: I've filled the bug here: https://github.com/haskell/cabal/issues/1542 :)
06:08:17 <dcoutts> danilo2: there's much more to it than using pkgroot
06:08:22 <dcoutts> to make a package relocatable
06:09:02 <danilo2> dcoutts: right now I've used these variables and after relocating package and running cabal recache everything works
06:09:28 <danilo2> dcoutts: Windows installations are relocatable by default btw
06:10:37 <dcoutts> danilo2: yes I know
06:10:56 <dcoutts> danilo2: and yes I fully expected it to work for ghc itself and its core packages
06:11:05 <dcoutts> that's not the same as making all packages relocatable
06:11:29 <dcoutts> danilo2: perhaps all you want is for ghc binary tarballs to be fully relocatable?
06:12:19 <danilo2> dcoutts: Yes, I want the tarball AND 2 my own libraries installed as global libraries in this tarbal (I'm talking about compiled ghc library for linux boxes)
06:13:09 <dcoutts> danilo2: hacking it will probably just work, so long as you know your libs do not use data files at runtime
06:13:21 <dcoutts> and as long as you're using static libs
06:13:24 <dcoutts> not shared
06:14:04 <danilo2> dcoutts: it works for me right now, but still it would need a LOT less hacks if cabal will use thesde relative variables. Right now I've written my own ghc-pkg wrapper, which while ionstalling globaly l;ibrares patches some paths etc . This is ugly :(
06:14:37 <dcoutts> danilo2: yes yes, but do realise that there's more to making a relocatable package than just using ${pkgroot}, see my comment on your ticket
06:14:40 <danilo2> dcoutts: yes of course apps that use dynlibs are not relocatable, but everything which could be, should be :)
06:14:59 <dcoutts> it's also possible to make shared libs relocatable on linux
06:15:06 <dcoutts> it's all "just" work
06:15:37 <danilo2> dcoutts: Ok, that would be cool, but we can "start" by making a really small step forward and use the pkgroot variable ?
06:16:10 <danilo2>  dcoutts: I really understand what youre talking about, but I think if we can fix "1/3" of this issuae with easy work, why not just fix it?
06:18:39 <dcoutts> danilo2: you can only use the pkgroot when you know it is safe to do so
06:19:06 <danilo2> dcoutts: Hm int it safe always when youre not using shared libs?
06:19:11 <dcoutts> you can't pretend something is relocatable when it is not
06:19:12 <danilo2> *isn't
06:19:28 <dcoutts> danilo2: no, think about finding data files
06:19:46 <dcoutts> you would also need to fix the mechanism for finding data files
06:19:53 <dcoutts> and then note that that will not work for libs
06:20:03 <dcoutts> libs with data files almost certainly cannot be relocated
06:20:14 <danilo2> dcoutts: What doses "finding data files" mean?
06:20:25 * hackagebot hslogstash 0.3.0 - A library to work with, or as, a logstash server  http://hackage.haskell.org/package/hslogstash-0.3.0 (SimonMarechal)
06:20:38 <dcoutts> Cabal provides a mechanism to find *at runtime* data files that were installed along with the package
06:21:03 <dcoutts> the pkgname_paths.hs module
06:21:42 <ocharles> http://hackage.haskell.org/package/postgresql-simple-0.3.8.0/docs/Database-PostgreSQL-Simple-Copy.html ffs, this is really getting annoying now
06:22:32 <geekosaur> anyone else get slightly worried when SPJ, of all people, says "And NOW I finally realise why GHC implements (...) like this"? :)
06:23:46 <Saizan> nah, there's always more in the product than in the mind of the creator :)
06:24:58 <JuanDaugherty> why should we worry geekosaur? SPJ != ghc
06:26:29 * JuanDaugherty .oO(ain't there enough real shit to worry about?)
06:30:25 * hackagebot hslogstash 0.3.1 - A library to work with, or as, a logstash server  http://hackage.haskell.org/package/hslogstash-0.3.1 (SimonMarechal)
06:42:14 <sqdfsq> I have a problem trying to distill a summary out of a series of events
06:42:33 <sqdfsq> such as, for example: a series of events in a basketball game to a box-score
06:42:47 <sqdfsq> I made some example code: http://lpaste.net/94271
06:43:04 <Lethalman> am I wrong or anchors in hackage source don't work?
06:43:09 <sqdfsq> goal is to complete the distilEvents function
06:43:30 <Lethalman> at least for datatype
06:43:46 <mm_freak> sqdfsq: you should use named fields for your Player type
06:44:08 <sqdfsq> output should be something like [Player "PlayerA" 0 1 1 1, Player "PlayerB" 0 0 1 0, ..
06:44:10 <mm_freak> data Player = Player { plName :: Name, plShots :: Int, plMissedShots :: Int, … }
06:44:27 <sqdfsq> is that like a dictionary?
06:44:41 <mm_freak> no, it's the same type, just with named fields
06:44:45 <fizruk> it's like a record
06:44:49 <sqdfsq> ok
06:45:05 <mm_freak> sqdfsq: the differences are:  you get accessor functions, record updates and it influences the derived Show instance
06:45:15 <mm_freak> sqdfsq: next step:  remove the player's name from the type
06:45:28 <mm_freak> type Players = Map Name Player
06:45:29 <Lethalman> for example: http://hackage.haskell.org/package/wai-1.4.0.2/docs/src/Network-Wai.html#Middleware
06:45:37 <Lethalman> doesn't move to the Middleware type
06:45:39 <mm_freak> that's a "dictionary" (a map) of players
06:45:50 <sqdfsq> ok, I'm following
06:46:34 <notdan> Lethalman: it works for me
06:46:39 <Lethalman> notdan, uhm
06:46:43 * Lethalman using chromium
06:46:47 <notdan> Lethalman: it moves to the beginning of the haddock though
06:46:47 <mm_freak> sqdfsq: finally just construct this map recursively using M.empty and M.insert
06:46:54 <mm_freak> sqdfsq: (import qualified Data.Map as M)
06:46:59 <notdan> the '- | Middleware is a component..' line
06:47:17 <notdan> you can also link to specfic lines, I think
06:47:47 <mm_freak> sqdfsq: you will need M.insertWith in your case
06:47:49 <notdan> Lethalman: works for me in Firefox and chrome :(
06:47:49 <fizruk> mm_freak: I'd removed name from events either and then used Map.fromListWith
06:48:00 <notdan> it scrolls to the very botton
06:48:00 <Lethalman> notdan, mh ok thanks
06:48:03 <notdan> bottom*
06:48:12 <fizruk> mm_freak: on [(Name, Event)] instead of [Event] though
06:48:29 <mm_freak> sqdfsq,fizruk: there is a more elegant way to construct this
06:48:34 <mm_freak> instance Monoid Player
06:48:39 <mm_freak> M.singleton, M.unionWith
06:48:43 <mm_freak> M.singleton, M.unionWith (<>)
06:49:08 <mm_freak> basically make Player a monoid and use a monoid morphism into maps of players =)
06:49:29 <sqdfsq> mm_freak, I'm just starting out. Where should I go to read/see an example of this?
06:49:38 <mm_freak> sqdfsq: don't worry about this
06:49:52 <mm_freak> for now just start with either M.insertWith and M.empty or with fizruk's approach
06:50:16 <sqdfsq> ok, I'll try to put what you said together
06:50:24 <fizruk> I meant something like Map.fromListWith (<>)
06:50:30 <hardliner_> hello
06:50:40 <hardliner_> my name is haskell
06:51:21 <mm_freak> fizruk: this will require to extract the player names first…  not that it's bad, but the M.insertWith approach should be difficult enough for now =)
06:52:33 <fizruk> mm_freak: yes, I think. I also meant to replace Event with (Name, EventType)
06:53:56 <mm_freak> sqdfsq: should you get stuck, start by writing the type signature for distillEvents and paste it
07:05:37 * hackagebot pipes-postgresql-simple 0.1.1.0 - Convert various postgresql-simple calls to work with pipes  http://hackage.haskell.org/package/pipes-postgresql-simple-0.1.1.0 (OliverCharles)
07:07:15 <mm_freak> ocharles: just what i need right now!
07:07:18 <mm_freak> thanks a lot =)
07:08:15 <t7> pipes or conduits, which are better
07:09:28 <AfC> t7: yes
07:09:29 <bss03> t7: I'm a big fan of pipes.
07:12:32 <bss03> t7: I think conduit may still have more support from other libraries, though.  It takes a much more "batteries included" stance, whereas pipes makes it easier to correctly add your own layers, and provides some of the functionality that conduit considers "core" as separate layers (pipes-safe and pipes-parse, e.g.).
07:14:11 <donri> conduit is DWIM, pipes is DTRT, and since those two should be the same thing, both have some warts
07:15:32 <ocharles> mm_freak: :D
07:15:37 <ocharles> mm_freak: whatcha working on?
07:15:58 <ocharles> let me know if you would need something that's not in that library. it's just scratching an itch for me right now
07:16:14 <mm_freak> t7: pipes is cleaner from a categorical perspective, but conduit has some practical advantages like guaranteed prompt finalization and builtin leftover support
07:16:32 <mm_freak> t7: my personal favorite is pipes, but only because i haven't needed those additional features yet
07:16:58 <mm_freak> ocharles: i'm working on a bot for a customer that will need a large database
07:17:06 <mm_freak> large enough that acid-state will be insufficient
07:17:27 <ocharles> are you mostly pulling data out, or putting lots of data in?
07:18:18 <mm_freak> ocharles: there will be a configurable number n, which will determine the pull-to-push ratio
07:18:28 <mm_freak> if n = 1000, for each 1000 pullouts there will be one push
07:19:55 <ocharles> mm_freak: right. i ask because there is only a 'query' producer at the moment, but nothing that does an INSERT
07:20:13 <ocharles> though you can't really 'stream' an insert in postgresql
07:20:17 <ocharles> (though there are COPY wrappers)
07:20:27 <mm_freak> ocharles: that's fine for my purpose
07:20:34 <ocharles> kewl
07:20:59 <mm_freak> ocharles: most of the heavy writing logic is done in-database through pl/pgsql
07:21:21 <hardliner_> is there haskell jobs in industry?
07:21:53 <ocharles> mm_freak: ah. good decision :)
07:22:05 <ocharles> hardliner_: well i get paid to write haskell, so there's one data point for your answer
07:22:22 <hardliner_> ocharles: thx
07:22:29 <ocharles> there have been a rise of haskell jobs recently, i feel
07:22:34 <hardliner_> ocharles: what is your country?
07:22:45 <hardliner_> i'm from Russia
07:22:56 <ocharles> hardliner_: UK
07:25:51 <hardliner_> ocharles: do you work in financial industry?
07:26:11 <ocharles> hardliner_: nope
07:26:30 <mbrock> i guess it's not much like the big languages where you have a huge constant demand, on the other hand the companies choosing haskell are perhaps likely to have technical expertise, interesting problems, and other desirable qualities :)
07:27:26 <hardliner_> i learned some ML
07:28:00 <hardliner_> what is better for study functional paradigm, haskell or ocaml?
07:28:17 <ocharles> both are good choices
07:28:28 <ocharles> i'd mostly say make a decision, then stick with it for a while
07:28:31 <ocharles> you can always re-evaluate later
07:28:37 <ocharles> but there's not much to gain by constantly jumping around
07:29:34 <hardliner_> ocharles: thx, i stick to ml for a while
07:29:53 <hardliner_> ocharles: actually i'm c++ developer)
07:36:41 <poucet_> Hi
07:36:46 <Jesin> I just saw someone refer to "Data.Bits.bitSizeMaybe", but I can't find anything about that function in http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/Data-Bits.html
07:36:52 <Jesin> :t bitSizeMaybe
07:36:53 <lambdabot> Not in scope: `bitSizeMaybe'
07:36:59 <Jesin> :t Data.Bits.bitSizeMaybe
07:37:00 <lambdabot>     Not in scope: `Data.Bits.bitSizeMaybe'
07:37:01 <lambdabot>     Perhaps you meant `Data.Bits.bitSize' (imported from Data.Bits)
07:37:08 <poucet_> Any reason why downloading Haskell package is not working? "Waiting for haskell.org"
07:37:14 <poucet_> Any reason why downloading Haskell package is not working? "Waiting for lambda.haskell.org"
07:38:13 <joelmo> can anyone see what im doing wrong here: https://gist.github.com/bca3c105d7c91f440f49 its a function that turns a string like "poppop" to "pp"
07:38:55 <joelmo> ah it was a typo sorry
07:38:58 <joelmo> its fixed
07:42:40 <aXqd> hi all, I want to make sure [requestURL :: String] (which is generated from a complex function) has been strictly generated before the actual HTTP request. By doing this - "requestURLs `seq` do xxx", are there still any thunks left behind inside of requestURLs? If so, what else can I do?
07:44:10 <bss03> aXqd: It depends; deepSeq.
07:45:07 <bss03> aXqd: seq reduces something to WHNF, depending on how the list was constructed that may evaluate other things as well, or it might not.
07:45:07 <Jesin> ah, apparently it's in ghc 4.7+
07:45:18 <Jesin> (@ bitSizeMaybe)
07:45:29 <Jesin> brb
07:47:55 <bss03> aXqd: deepSeq is supposed to fully evaluate (but it's not a built-in, so when you are providing a NF instance, you can do what you like).  It may do "extra work" though, if parts of the structure are already evaluated because it crawls the whole thing.
07:47:59 <aXqd> bss03: I see. I think `String` is an instance of NFData, hence I can just use `deepSeq` to get what I want.
07:50:09 <Sculptor_> hi
07:50:14 <aXqd> bss03: And also, i was thinking if I `putStrLn . show` it, it must be evaluated. Can I do something alike, but without showing it on screen?
07:51:05 <bergmark> show x `deepseq` somethingElse ?
07:51:24 <bss03> aXqd: deepSeq will basically do that, for http://en.wikipedia.org/wiki/Special:Search?go=Go&search=String
07:51:45 <bss03> WTF, that wasn't what I typed.
07:51:58 <bss03> [ [String] ]
07:52:37 <fizruk> [[a]]
07:53:15 <bss03> fizruk: It was a problem on my side; Konversation was a default outgoing replacement setting that recognizes wikipedia-like links.
07:53:19 <bss03> [[String]]
07:53:24 <bss03> It's turned off now. :P
07:53:44 <aXqd> LOL :D ok, thanks.
07:54:20 <fizruk> =)
07:55:29 <alexander__b> with cabal, how do I make it understand that all my stuff is in a directory, 'src/'?
07:56:18 <dcoutts> alexander__b: http://www.haskell.org/cabal/users-guide/developing-packages.html#build-information
07:56:29 <alexander__b> or maybe if I have src/ everything should be in there, including .cabal?
07:56:50 <dcoutts> alexander__b: using subdirs is fine
07:56:55 <dcoutts> or multiple dirs
07:57:14 <alexander__b> dcoutts: thanks. that link was a bit more clear than what I've been looking at over at http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
07:57:48 <alexander__b> oh. I actually found it in that article as well now. never mind me. ^_^ thanks, dcoutts.
07:57:56 <dcoutts> np
07:59:35 <kuribas> Can I make (Double, Double) and instance of a class?
08:00:15 <tibbe> dcoutts: hey, how are things?
08:00:19 <hpc> kuribas: you can do both of those things!
08:00:19 <tibbe> dcoutts: we're moving to zurich on wednesday
08:00:22 <dcoutts> tibbe: ok :-)
08:00:25 <dcoutts> tibbe: oooh :-)
08:00:26 <hpc> kuribas: perhaps you meant "an" ;)
08:00:31 <kuribas> yes
08:00:37 <hpc> and yes you can do that too
08:00:54 <kuribas> Strange, I am having troubles with it...
08:01:01 <dcoutts> tibbe: hope the move isn't too stressful
08:01:10 <hpc> depending on the instance you could be having overlapping instance problems
08:01:14 <hpc> can you hpaste?
08:01:55 <ParahSailin> is there an easy way to have yesod dispatch to wai Application rather than HandlerT stuff?
08:02:31 <lpaste> kuribas pasted “class instance” at http://lpaste.net/94278
08:02:34 <quchen> kuribas: Small example: class Swappable f where swap :: f a b -> f b a; instance (,) Swappable where swap (a,b) = (b,a)
08:02:41 <tibbe> dcoutts: it's alright, mostly done now
08:02:53 <tibbe> dcoutts: it was a bit stressful in that I was switching projects at the same time
08:03:02 <dcoutts> tibbe: ah right
08:03:42 <kuribas> hpc: I get: illegal instance declaration
08:04:04 <alexander__b> what's a good way to do enable this structure in cabal: Main.hs is in src/ and the rest in src/program/. setting hs-source-dirs: src will make it find Main.hs fine, but I don't want to do program.File, program.OtherFile etc.
08:04:44 <dcoutts> alexander__b: just list all the src dirs, ie hs-source-dirs: src src/program
08:04:47 <tibbe> dcoutts: switching projects never results in going from 0 to 100% on the new project and the opposite on the old one. Tyipically it means 75% on both for a few weeks
08:04:58 <hpc> kuribas: oh, at the top add {-# LANGUAGE FlexibleInstances #-}
08:04:58 <alexander__b> dcoutts: oh! nice. thanks.
08:05:00 <dcoutts> tibbe: heh, right
08:05:27 <kuribas> hpc: ok
08:05:28 <quchen> kuribas: kdkeyCoord takes whatever you make the class instance for as first argument, but in the actual instance declaraion you give it 1 and 0.
08:05:43 <hpc> kuribas: haskell defaults to a particularly anal idea of what's a proper instance
08:05:44 <rck> getting "setup.exe: does not exist" when running cabal install cabal cabal-install to upgrade from 1.16 to 1.18.2 on windows 7
08:05:50 <rck> anyone else using windows?
08:05:54 <hpc> FlexibleInstances expands it as far as one can safely go
08:06:05 <kuribas> quchen: oh right, I swapped the arguments.
08:06:41 <quchen> kuribas: Also your implementation is not total (what happens for `kdKeyCoord 2`?)
08:06:57 <lpaste> kuribas annotated “class instance” with “class instance (annotation)” at http://lpaste.net/94278#a94279
08:07:27 <kuribas> quchen: It will throw an exception.
08:07:41 <quchen> kuribas: And that's evil.
08:07:56 <kuribas> quchen: Alright, then I'll make it an error...
08:08:07 <quchen> `Maybe` would be enough.
08:08:42 <kuribas> Well, an implementation of KDKey should handle all the dimensions.
08:08:59 <kuribas> So it's up to the writer of the instance.
08:10:31 <kuribas> quchen: Even if I use maybe, I still have to throw an error if it doesn't define all dimensions.
08:11:09 <quchen> ..?
08:11:13 <fizruk> kuribas: you could return Nothing instead
08:11:16 <quchen> kdKeyCoord _ = Nothing
08:11:20 <quchen> As the base case
08:11:35 <hpc> quchen: he could always just document that it's a partial function
08:12:10 <quchen> hpc: And discourage users from using the function in the docs and if they do they should write lots of unit tests?
08:13:44 <kuribas> quchen: It's an implementation error if kdkeyCoord is not defined for a dimension.  Otherwise I have to wrap all my library functions in a Maybe?
08:13:59 <kuribas> Which is silly.
08:14:50 <fizruk> kuribas: why instances for tuples then?
08:15:20 <kuribas> fizruk: It seemed convenient...
08:15:53 <bss03> silly?  Or awesome?  Having something be "Maybe a" instead of "a {- But, you know, I'll call error or throw whenever I feel like it and hide the documentation, unintentionally sure, but it's still hidden 3 dependencies deep -}" is awesome, not silly.
08:16:46 <kuribas> Alright, then explain to me why List.!! and Vector.! not return a maybe.
08:17:11 <bss03> Why does head not return a maybe?  Same reason.
08:17:26 <luite> is it possible to build the testsuite with cabal-install but not run it?
08:17:32 <bss03> People in the past a stupid and now we are stuck with their mistakes.  :P /s
08:18:13 <mm_freak> luite: you have to run it manually anyway
08:18:16 <mm_freak> cabal test
08:18:28 <mm_freak> luite: and you need to --enable-tests when configuring
08:19:01 <luite> mm_freak: that also runs it when doing cabal install
08:19:23 <mm_freak> luite: it doesn't for me…  check your ~/.cabal/config
08:19:54 <mm_freak> see the 'tests' flag
08:20:02 <mm_freak> it's false by default
08:20:26 <kuribas> bss03: I am not going to wrap every function from my K-D-tree in a Maybe datatype, because a library user doesn't acces all dimensions, which is pretty obvious.  It will not even make the source less buggy.
08:20:38 <kuribas> Probably more buggy.
08:20:52 <luite> mm_freak: hm, doesn't that just say whether to build tests by default?
08:22:06 <quchen> I don't follow the reasoning behind "using appropriate types will make my code more buggy".
08:22:17 <mm_freak> luite: if you don't run them, you don't need to build them =)
08:22:17 <mm_freak> if you build them, you might as well run them, otherwise you're just wasting CPU cycles
08:22:19 <mm_freak> luite: for development you should use --enable-tests explicitly
08:22:27 <bss03> kuribas: Your choice.  Partiallity is the bane of my extentence, so I'd make a different choice.
08:22:55 <mm_freak> kuribas: my libraries always give you a Maybe when there may not be a result
08:23:08 <mm_freak> 'head'/(!!) not using Maybe is a historical accident
08:23:12 <luite> mm_freak: i want the test executable to be built in my installation script, but running the tests takes half an hour or so, so i don't want that
08:23:49 <mm_freak> luite: --enable-tests, but not cabal test, works for me
08:24:00 <mm_freak> i have the default 'tests' setting in my ~/.cabal/config, which is False
08:24:11 <luite> mm_freak: yeah same here but it runs the tests, weird?
08:24:17 <mm_freak> weird.
08:24:19 <luite> it doesn't show output during the run
08:24:29 <mm_freak> let me double-check
08:24:41 <kuribas> mm_freak: Mine too.  But in my case the k-d-tree operation is not defined when the user doesn't give coordinates for every dimension.  It's an error either way, so "error" is better than "Maybe".
08:25:15 <quchen> Except that Maybe doesn't crash everything.
08:25:55 <kuribas> quchen: What's the problem with it crashing?  It would be obvious where the mistake is.
08:26:13 <fizruk> kuribas: perhaps you should elaborate on purpose on KDKey class
08:27:02 <mm_freak> kuribas: i understand your point
08:27:20 <mm_freak> kuribas: use Maybe for the potentially unsafe things
08:27:35 <luite> mm_freak: i can make a workaround though, just let teh testrunner abort immediately here
08:27:43 <kuribas> fizruk: KDKey is a key for a multidimensional K-D-tree.
08:27:51 <mm_freak> kuribas: for example, once created, your data structure as well as all its operations may be safe, but the creation itself is unsafe, so use Maybe when creating
08:28:09 <bss03> kuribas: Maybe just put the instances where you implement the function by using undefined/error/throw into their own module, so it's easy to not import them?
08:28:23 <mm_freak> kuribas: for these cases i use type-level support to encode the safety
08:28:47 <kuribas> I could alternatively use a datastructure to receive the dimensions, instead of a number.
08:29:32 <lpsmith> Hmm, a large number of packages seem to have a documentation problem with the new hackage server
08:31:49 <mm_freak> luite: i found the problem, "cabal install" reconfigures
08:32:17 <kuribas> data Dim = ZeroDim | Dim Dim
08:32:17 * haasn .oO( my libraries always let you traverse over an arbitrary pointed functor when there may not be a result )
08:32:46 <luite> mm_freak: oh right, so it does run it for you if you run cabal install --enable-tests, right?
08:32:58 <mm_freak> luite: yeah
08:33:09 <luite> ok, i'll just patch my testrunner to skip the tests in this case then
08:33:14 <mm_freak> luite: but even if you had --enable-tests in your configure step, if you install without --enable-tests, it reconfigures
08:33:31 <luite> yeah
08:33:33 <mm_freak> which seems like an odd choice
08:35:48 <mm_freak> kuribas: if you're going to lift that to the type level, i suggest just using GHC's type level naturals
08:36:00 <mm_freak> and/or the 'reflection' package
08:36:35 <mm_freak> crossProduct :: Vector 3 -> Vector 3 -> Vector 3
08:38:22 <Phlogistique> je crois pas que j'ai fait des trucs overcompliqu
08:38:24 <Phlogistique> oops
08:39:06 <Jesin> representable-functors and several packages that depend on it are failing to build, due to incompatability with comonad >= 4
08:39:28 <Jesin> this means I can't install the "algebra" package like I wanted
08:39:31 <edwardk> Jesin: i'm still updating. i got about 20 hours into my update binge and ran out of energy
08:39:34 <Jesin> ah
08:39:39 <edwardk> algebra still builds with the < 4 ecosystem
08:39:49 <Jesin> ok
08:39:49 <Jesin> hmm
08:40:05 <Jesin> edwardk: do you by any chance have a job besides this or do you just work on haskell/ghc full-time?
08:40:18 <edwardk> Jesin: i have a job, too =)
08:40:46 <Jesin> ... and yet you find time to eat and sleep
08:41:06 <Jesin> nice
08:41:28 <edwardk> I have a very patient and understanding wife ;)
08:42:21 <kuribas> mm_freak: I'll look into it.  Anyway, if this is a problem, than practically all Array and vector handling in haskell is wrong: repa, vector, array, accelerate, etc..
08:42:38 <kuribas> They all work with unsafe indices.
08:42:51 <mm_freak> kuribas: you get the usual run-time checking you know from other languages
08:42:57 <Lethalman> > T.splitBy
08:42:58 <lambdabot>   Not in scope: `T.splitBy'
08:43:12 <mm_freak> kuribas: it's unfortunate, but for static checking you need some language extensions
08:44:43 <mm_freak> kuribas: functional style and immutability contribute a lot to the correctness though, so at least i still get a lot less bugs
08:44:56 <mm_freak> in fact most bugs i have in my haskell programs are arithmetic errors
08:46:21 <kuribas> Yeah, that's true.
08:58:19 <osa1> how can I see if my code is subject to fusion? for example I have this code `map (snd . fst) $ filter (\((nt', _), _) -> nt == nt') (M.toList tbl)` if it subject to fusion?
09:00:13 <alexander__b> I want to have Direction be either Left, Right or Stop. then I want to pattern match for what Direction to go in. in C++ or whatever I'd obviously use enums, what do I use for this purpose in Haskell?
09:00:35 <mm_freak> alexander__b: data Direction = LeftDir | RightDir | Stop
09:00:44 <alexander__b> that easy, huh
09:01:00 <mm_freak> (Left and Right will clash with the predefined Either type, hence LeftDir/RightDir)
09:01:05 <alexander__b> ah
09:01:07 <alexander__b> thanks
09:01:12 <alexander__b> that's why ghc-mod was whining. :-)
09:02:42 <cschneid> mm_freak: is there a standard way to handle that? I imagine stuff like Left Right Just Nothing are all so common, you just don't try and conflict? Otherwise module namespacing I suppose?
09:05:22 <mm_freak> cschneid: yes, namespacing
09:05:25 <mm_freak> import Prelude as P
09:05:57 <mm_freak> or rather:  import qualified Prelude as P; import Prelude hiding (Maybe(..))
09:06:04 <mm_freak> but it's better not to clash
09:06:30 <capisce> mm_freak: are you a SIMD intrinsic?
09:07:00 <mm_freak> capisce: "intrinsic"?
09:07:14 * mm_freak is not a native english speaker
09:07:42 <capisce> mm_freak: http://msdn.microsoft.com/en-us/library/78x83000(v=vs.90).aspx etc
09:08:40 <mm_freak> capisce: i still don't know how to respond (neither do i quite understand why you address me specifically)
09:09:47 <capisce> mm_freak: your nick just reminds me of SIMD intrinsic functions
09:10:03 <mm_freak> oh, then no =)
09:10:36 <mm_freak> i have this nick since 1999, and i don't even remember what the "mm" stands for =)
09:10:43 * hackagebot tagged-transformer 0.5 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-transformer-0.5 (EdwardKmett)
09:12:56 <mm_freak> edwardk: selfM :: Monad m => a -> TaggedT s m a
09:12:59 <mm_freak> seems like a bug
09:13:28 <edwardk> mm_freak: i haven't lookat at that package in a long time. that is mostly matvey
09:13:50 <edwardk> that does seem silly though
09:13:50 <mm_freak> edwardk: that can't be true…  you just updated it =P
09:14:00 <edwardk> mm_freak: i merged a pull request and pushed =)
09:14:54 <edwardk> going through and reading it, removing unnecessary things
09:15:18 <mm_freak> on your way you could add reifyTagged
09:16:17 <mm_freak> or runTagged :: a -> (forall s. (Reifies s a) => TaggedT s m b) -> m b
09:16:56 <edwardk> patches welcome, but i just shipped 0.6 ;)
09:20:19 <osa1> anyone knows about my loop fusion question?
09:20:25 <osa1> ^ "how can I see if my code is subject to fusion? for example I have this code `map (snd . fst) $ filter (\((nt', _), _) -> nt == nt') (M.toList tbl)` if it subject to fusion?"
09:20:43 * hackagebot tagged-transformer 0.6 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-transformer-0.6 (EdwardKmett)
09:21:55 <mm_freak> osa1: http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html
09:22:07 <mm_freak> osa1: see section 7.19.6
09:22:21 <bss03> osa1: I think the standard answer is to look at the core output and see if the intermediate list was fused away.
09:22:48 <mm_freak> no, GHC can tell you which rules fired
09:22:56 <mm_freak> see if the fusion rule fired
09:23:12 <osa1> mm_freak: well according to -ddump-rules output no transformations applied on my source
09:23:23 <osa1> mm_freak: why it isn't fired?
09:23:57 <mm_freak> osa1: are you compiling with -O?
09:24:08 <osa1> no
09:24:15 <mm_freak> you need to
09:24:23 <osa1> oka
09:24:27 <osa1> okay, it printed stuff
09:26:59 <osa1> yeah this isn't helpful because I don't understand what it's saying
09:27:12 <osa1> but it definitely has `filter`s in it :p
09:28:11 <lpsmith> edwardk, do you have any ideas why hackage 2 is displaying your haddocks but apparently not many other people's?
09:28:34 <osa1> mm_freak: just to understand if what I have in mind is possible to do by GHC,
09:28:35 <edwardk> because i'm apparently doing things right ;)
09:28:50 <bss03> lpsmith: Wasn't there a haddock change in 7.8?
09:29:02 <mm_freak> osa1: depends on what it is =)
09:29:27 <osa1> mm_freak: what I have in mind that that filter _ . map _ _ part in my code can be replaced by a recursive function for efficiency
09:29:27 <lpsmith> hackage 2 isn't building with ghc 7.8 yet
09:29:34 <bss03> lpsmith: ISTR my rommate complaining that GHC (docs) wouldn't build for a while due to changes that were in progress in haddock.
09:29:58 <CindyLinz> There are many manipulation function that take a predicate in Data.ByteString, such as span :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
09:30:04 <osa1> mm_freak: but simple shuffling filter/map calls around can't give me any advantages
09:30:09 <osa1> simply*
09:30:11 <danilo2> Hello :) Can somebody tell me why if I edit my cabal config file (~/.cabal/config, section: install-dirs global) the global packages are registered where I tell them, but the package configure files are still copied to <ghc install>/lib/ghc-7.6/package.conf.d? Can we change it also ?
09:30:13 <lpsmith> ok,  it seems that plenty of other people have working haddocks,  but a number don't,.
09:30:13 <CindyLinz> I think it lack the monadic version.. @@"
09:30:29 <mm_freak> osa1: one thing to note is that Data.List does not perform stream fusion AFAIK
09:30:35 <dcoutts> danilo2: yes, you can specify which package database to register into
09:30:40 <mm_freak> osa1: it performs what is called "deforestation"
09:30:48 <mm_freak> i think it's called build/foldr fusion or something
09:30:54 <osa1> hm
09:31:03 <mm_freak> not quite as powerful as stream fusion, most notably because it can't 'filter'
09:31:13 <mm_freak> but it will successfully rewrite map f . map g to map (f . g)
09:31:16 <dcoutts> um not quite
09:31:42 <dcoutts> foldr/build can do filter just fine
09:32:20 <mm_freak> what was it that couldn't filter?
09:32:27 <danilo2> dcoutts: ok, but I have to do it using some command line arguments? I cannot set it in ~/.cabal/config ?
09:32:34 <osa1> dcoutts: do you mean it can do what I explained?
09:33:20 <dcoutts> mm_freak: the most straightforward unfolrd fusion system cannot do filter, it needs the addition of skip. It's the skip that distinguishes simple unfoldr-based fusion from stream fusion
09:33:29 <dcoutts> erm unfolrd/unfoldr
09:34:17 <dcoutts> osa1: can you point me to your original Q, I'm missing context
09:35:04 <dcoutts> mm_freak: there was a paper that called it unfoldr/destroy fusion, though the better name for it is unfoldr/unbuild, since it is just a dual of foldr/build
09:35:17 <osa1> dcoutts: I have this code "map (snd . fst) $ filter (\((nt', _), _) -> nt == nt') (M.toList tbl)" which can be improved by moving to a recursive function which traverses the list one time. I was trying to understand if GHC does/can do this for me
09:35:58 <dcoutts> osa1: I would expect foldr/build to get that
09:36:04 <latro`a> to my understanding the usual answer about GHC and list fusion is "probably"
09:36:15 <osa1> dcoutts: ok how can I enable that and observe that it's really working?
09:36:24 <mm_freak> osa1: enabling: -O
09:36:24 <latro`a> well, you could just benchmark
09:36:35 <mm_freak> osa1: observing: either -ddump* or what latro`a said
09:37:03 <osa1> is there an option just to enable this optimization?
09:37:06 <dcoutts> osa1: -O -ddump-simpl-stats
09:38:28 <osa1> "429 unfolding done"
09:38:33 <osa1> not sure if related though
09:38:35 <dcoutts> 3 RuleFired
09:38:35 <dcoutts>   1 filter
09:38:36 <dcoutts>   1 fold/build
09:38:36 <dcoutts>   1 map
09:38:38 <satc> Is hGetLine lazy?
09:38:46 <dcoutts> satc: no
09:38:54 <osa1> 316 RuleFired
09:39:30 <osa1> 1475 beta reduction <-- is this argument inlining?
09:39:46 <osa1> um does that make sense
09:39:54 <dcoutts> osa1: so the answer appears to be that yes it does fuse. The core also looks good to me.
09:39:58 <danilo2> dcoutts: It is impossible to override the global pkg db with just ~/.cabal/config file? I have to use cmd line args for that?
09:40:19 <mm_freak> osa1: i think, beta reduction simplifies "1 + 1" to "2"
09:40:30 <osa1> dcoutts: wow ... if this is really true it's one more thing to love about GHC
09:40:51 <dcoutts> danilo2: you can certainly set a package db to register into, not sure you can reset the location of the global one
09:42:06 <dcoutts> osa1: put that fragment into its own module and look at the result of ghc -O -ddump-simpl -fforce-recomp
09:42:25 <dcoutts> e.g.  foo tbl nt = map (snd . fst) $ filter (\((nt', _), _) -> nt == nt') (M.toList tbl)
09:42:39 <kuribas> Is this considered unclean haskell? "if null l then [] else tail l"
09:43:45 <luite> drop 1 l would be shorter?
09:43:46 <pqmodn> kuribas: pattern matching is usually preferred
09:44:03 <dcoutts> kuribas: recommended practice is usually for pattern matching instead, i.e. case ls of [] -> []; _:ls' -> ls'
09:44:23 <kuribas> > drop 1 []
09:44:24 <lambdabot>   []
09:44:25 <dcoutts> in this specific case luite is right of course
09:44:46 <osa1> dcoutts: it really looks like happening ... this is so awesome
09:44:49 <kuribas> luite: I like that better :)
09:44:57 <luite> kuribas: just in this case of course :)
09:45:04 <xico> hi. i got a few questions regarding the ghc api, which i use to load and run some haskell code. 1. i would like my haskell code to be in a module with a fixed name. is there a way to do that from the ghc api, without having to put a "module" line in the loaded code? 2. similarly, i would like by module to always import specific packages, without having to add "import" lines in it. is there a way to do so from ghc api? 3. having solved my first q
09:45:07 <osa1> dcoutts: I'm not very fluent in Core but I compared outputs with -O enabled and not
09:45:29 <kuribas> luite: sure
09:45:39 <dcoutts> osa1: yep, fusion is cool
09:46:41 <dcoutts> osa1: don't think that it's magic though, there's fairly specific rules about where it can fuse and where it cannot
09:47:05 <dcoutts> you need to know which functions are "good consumer" and "good producers"
09:47:11 <dcoutts> only those ones fuse
09:47:33 <dcoutts> when a list is produced by a good producer and consumed by a good consumer
09:47:41 <dcoutts> then it'll fuse
09:48:27 <mm_freak> xico: your question got cut off at 3.
09:48:28 <osa1> dcoutts: well once you understand how it works it no more magic of course
09:49:12 <osa1> dcoutts: do you think it could be done by just simple rewrite rules? I think somewhat deeper analysis is going on here
09:49:13 <dcoutts> osa1: don't need to know how it works, just which library functions are good consumers and producers
09:49:29 <dcoutts> osa1: it is rewrite rules
09:50:01 <dcoutts> osa1: if you're interested in this stuff, you may like to read my thesis
09:50:10 <mm_freak> xico: as a side note, not exactly answering your question, you may want to look at 'hint' or 'plugins'
09:50:14 <osa1> dcoutts: link pls :)
09:50:30 <dcoutts> osa1: http://code.haskell.org/~duncan/thesis.pdf
09:50:56 <osa1> dcoutts: I'm not quite sure about how can some rewrite rules replace map/filter/fold combinations with a recursive function
09:50:58 <osa1> thanks
09:51:01 <dcoutts> osa1: in the intro chapter it covers foldr/build, unfoldr/unbuild & stream fusion
09:51:08 <xico> mm_freak: my question was too long anyways :) as for hint, i should definitively look into it (never heard of plugins, i will check)
09:51:26 <mm_freak> osa1: that's half of the story…  the trick is to express your list functions in a stream processing abstraction that allows fusion
09:51:32 <mm_freak> then you use rewrite rules to fuse
09:52:13 <mm_freak> xico: hint is for run-time interpretation of haskell modules, plugins is for run-time loading/executing of compiled modules
09:52:27 <mm_freak> xico: see also mueval, if the modules are untrusted
09:52:32 <mm_freak> that's what powers lambdabot
09:52:34 <mm_freak> > "hello!"
09:52:35 <lambdabot>   "hello!"
09:52:56 <osa1> okay thanks all for your help
09:53:35 <osa1> another question: can moving to applicative style(instead of monadic style) in Parsec code give me performance advantages? if so, where can I learn more about this?
09:54:07 <mm_freak> osa1: it can be faster or slower depending on implementation, but the difference should be negligible
09:55:19 <osa1> yeah I just realized this question doesn't make much sense because obviously applicative and monad instance implementations are different so different codes are being run ...
09:58:50 <bss03> Well, usually when something is both a Monad and an Applicative, there are certain corespondences like return = pure, and f <*> x = f `ap` x.
09:59:21 <dcoutts> osa1: http://www.staff.science.uu.nl/~swier101/Papers/1996/DetErrCorrComPars.pdf
09:59:40 <dcoutts> osa1: note that this is before applicative existed
09:59:57 <dcoutts> (and indeed is one of the motivations for Applicative)
10:00:18 <dcoutts> see also http://www.cs.uu.nl/research/techreps/repo/CS-2008/2008-044.pdf
10:02:15 <osa1> dcoutts: thanks for the links. this just happened in a time when I just finished implementing my own LL(1) parser generator and was about to move LR ones ... (just to understand this stuff better)
10:04:35 <satc> Can ffi calls be lazy?? I mean If I do something like * acquire resourse * perform ffi call on that resourse * free resource. Can this throw an exception because resource was freed before the actual ffi call was made.
10:04:50 <satc> *resource
10:06:26 <enthropy> satc: if you have:    do r <- acquire; out <- useResource r; free r; return out,  unless you did something funny in defining useResource it should be ok
10:06:35 <enthropy> something funny like unsafeInterleaveIO
10:06:45 <mm_freak> satc: http://chimera.labs.oreilly.com/books/1230000000929/ch15.html
10:07:08 <bss03> satc: Does your ffi call return an IO a?  IF you are in IO you get sequencing, so you know the call occurs before the release.
10:07:12 <mm_freak> satc: generally you should use 'bracket' anyway
10:07:48 <enthropy> mm_freak: which exceptions can ffi calls throw?
10:07:59 <mm_freak> enthropy: i think none
10:08:09 <mm_freak> enthropy: but they may get an exception thrown at them
10:08:34 <mm_freak> satc: apart from that, if you have an unevaluated to-be-evaluated 'f x', then the x will certainly not get garbage-collected before f returns
10:08:49 <bss03> If you've brought the foreign function in as "pure"... seq is your friend.
10:37:52 <kuribas> I installed emacs24 on linux mint, but navigation error messages in inf-haskell doesn't work anymore.
10:38:20 <kuribas> (haskell-mode is the same version)
10:42:38 <lykos> How could I have a data type consisting of a few chars?
10:42:54 <lykos> Like a "DNA" type that is either 'a','t','c', or 'g'?
10:43:05 <mm_freak> data DNA = A | T | C | G
10:43:16 <mm_freak> you may want to use a few more characters though
10:43:17 <monochrom> do you mind not using chars at all?
10:43:48 <monochrom> string is not the last data type on earth, you know
10:44:18 <mm_freak> data DNA = Ad | Th | Cy | Gu
10:44:29 <lykos> thanks
10:44:39 <lykos> although, just to know, how would I use char constants?
10:44:51 <Rarrikins> lykos: 'A'
10:45:21 <Rarrikins> > ['A', 'T', 'C', 'G']
10:45:21 <lambdabot>   "ATCG"
10:45:28 <mm_freak> lykos: perhaps it's better not to know =)
10:45:34 <lykos> I mean a char constant as DNA type is either 'A', 'T', 'C', or 'G'
10:45:43 <lykos> I'm trying to learn about data types more
10:45:59 <Rarrikins> It's much better not to use Char, though, since then you lose compile-time checking for invalid characters.
10:46:06 <lykos> I understand.
10:46:16 <mm_freak> lykos: i'm not sure what you're trying to achieve…  either use a data type or use characters, the former obviously being preferred
10:46:28 <Jesin> Is there a reason to have both lens and data-lens?
10:46:47 <mm_freak> Jesin: unless you are forced to for historical reasons, not really
10:47:00 <djahandarie> lykos, if you trying to get a datatype where you can have   'A' :: YourType   typecheck and  'B' :: YourType  fail to typecheck, it's not possible.
10:47:01 <lykos> can I have it so that I have [DNA] where it's a string of chars guarenteed to be a string of just those chars?
10:47:09 <mm_freak> Jesin: well, data-lens is faster than lens, but the difference is small
10:47:38 <mm_freak> lykos: [A, A, T, C, A, A, G]
10:47:39 <jfischoff> data-lens is simplier and less powerful
10:47:40 <lykos> djahandarie: thanks
10:47:45 <mm_freak> lykos: does that look like what you want?
10:48:15 <Rarrikins> lykos: You can also do some things with Template Haskell to avoid commas.
10:48:39 <mm_freak> not TH, but QQ
10:48:45 <scriptor> huh, just had a thought, dependent types and DNA could lead to some interesting tricks
10:48:51 <mm_freak> and i suggest not throwing TH/QQ at a beginner!
10:49:05 <Rarrikins> Alright.
10:49:08 <mm_freak> scriptor: yes, i'd combine DNA and RSA in a GADT
10:49:17 <mm_freak> RNA
10:55:49 * hackagebot free 4.1 - Monads for free  http://hackage.haskell.org/package/free-4.1 (EdwardKmett)
10:57:54 <lykos> can I have a datatype foo = A | B
10:58:02 <lykos> Foo*
10:58:13 <lykos> and Bar = [Foo]?
10:58:29 <Nimatek> Yes.
10:58:41 <djahandarie> You can certainly have Foo (as long as there are no conflicting types / values with those names)
10:58:52 <glguy_> data Foo = A | B ; type Bar = [Foo]
10:58:58 <djahandarie> Bar cannot be a "datatype", but it can be a type synonym.
10:59:36 <djahandarie> Type synonyms are nothing but conveniences when writing code, so that may not be what you're looking for.
11:00:06 <lykos> thanks!
11:00:16 <djahandarie> (Some people also use type synonyms for documentation purposes but I personally don't like that very much.)
11:00:59 <monochrom> just write [Foo]
11:04:49 <mm_freak> i like type synonyms for String and Text, but not for much else
11:05:08 <mm_freak> like FilePath, HostName, etc.
11:05:34 <tac> I would prefer to have named parameters in the types
11:05:54 <tac> openFile :: (filepath :: String) -> IO Handle
11:06:04 <djahandarie> mm_freak, dunno, even that bugs me. I'd rather have a newtype.
11:06:05 <monochrom> type synonyms are great for people who fancy that the meaning of a program is determined by the English meaning of names.
11:06:56 <mm_freak> tac: that would be great
11:07:10 <mm_freak> djahandarie: i agree
11:07:12 <tac> mm_freak: yeah....
11:07:44 <tac> It would be nice to avoid pathological stuff like Speak :: Text -> Text -> Text -> Cmd ()
11:08:07 <jfischoff> tac: that's cool. That would make documentation easier.
11:08:08 <mm_freak> well, for Speak it's already available (called records)
11:08:20 <mm_freak> but for 'speak' (being an actual function) it's not
11:08:54 <tac> mm_freak: That's a constructor I have in one of my programs
11:09:16 <mm_freak> tac: data Cmd a = Speak { … }
11:09:18 <tac> You can't have a sum of records in Haskell (and it would be bad if you did anyway, since projections become partial then)
11:09:24 <tac> mm_freak: That's just one of many constructors
11:09:36 <mm_freak> tac: i understand
11:09:38 <tac> yeah
11:09:45 <tac> jfischoff: I stole the idea straight from Agda.
11:09:55 <djahandarie> tac, re your openFile example, I'd rather haddock just pull the variable name from the function, and then just avoid writing point-free stuff if you want documented variable names.
11:09:57 <mm_freak> you stole it from the dependent function arrow
11:10:13 <mm_freak> i'd love to have it in haskell…  even without dependent types
11:10:20 <tac> For sure.
11:10:38 <jfischoff> tac: what do you mean you can't have a sum of records? data Foo = Bar { x :: Int } | Bar1 { y :: Int }, no?
11:10:50 <tac> jfischoff: Does that even work in Haskell?
11:11:02 <jfischoff> tac: yes
11:11:05 <tac> And if so,  >____>
11:11:19 <enthropy> y (Bar 2) -- is a runtime error
11:11:19 <Rarrikins> @let data Foo = Bar { x :: Int } | Bar1 { y :: Int }
11:11:20 <lambdabot>  Defined.
11:11:24 <mm_freak> jfischoff: the problem is that x is now a partial function, which sucks
11:11:29 <jfischoff> tac: honestly I wish it didn't
11:11:31 <Rarrikins> > y (Bar 2)
11:11:32 <lambdabot>   Ambiguous occurrence `y'
11:11:33 <lambdabot>  It could refer to either `L.y', defined at L.hs:1...
11:11:34 <tac> yeah
11:11:34 <jfischoff> mm_freak: agreed
11:11:35 <Rarrikins> Blah
11:11:47 <tac> > x (Bar1 3)
11:11:48 <lambdabot>   Ambiguous occurrence `x'
11:11:48 <lambdabot>  It could refer to either `L.x', defined at L.hs:1...
11:11:51 <tac> doh
11:11:53 <Rarrikins> @undef
11:11:54 <lambdabot> Undefined.
11:11:56 <mm_freak> that's basically why agda has a separate 'record' construct
11:12:00 <Rarrikins> @let data Foo = Bar { x' :: Int } | Bar1 { y' :: Int }
11:12:00 <lambdabot>  Defined.
11:12:08 <Rarrikins> > x' (Bar1 3)
11:12:09 <mm_freak> which given the advanced module system is great to work with
11:12:15 <lambdabot>   *Exception: No match in record selector x'
11:12:24 <mm_freak> of all those fancy things agda has, i miss the module system most in haskell
11:12:26 <monochrom> in fact, data Food = Salad { pH :: Int } | Soup { ph :: Int, fragance :: Fragance } | Steak { fragance :: Fragance }
11:12:37 <monochrom> err, s/ph/pH/
11:12:38 <Rarrikins> monochrom: Does that work?
11:12:43 <mm_freak> Rarrikins: yes
11:12:46 <monochrom> yes it totally does. try it.
11:13:03 <Rarrikins> @let data Food = Salad { pH :: Int } | Soup { pH :: Int, fragance :: Fragance } | Steak { fragance :: Fragance }
11:13:05 <lambdabot>  .L.hs:144:41: Not in scope: type constructor or class `Fragance'
11:13:07 <lambdabot>  
11:13:07 <lambdabot>  .L.hs:14...
11:13:07 <mm_freak> fragance is still partial, but it works for both Soup and Steak
11:13:14 <jfischoff> I really consider sums of records a misfeature
11:13:16 <monochrom> read the Haskell 2010 Report some day. you will find many new friends.
11:13:21 <Rarrikins> @let data Fragrance = Fragrance String; data Food = Salad { pH :: Int } | Soup { pH :: Int, fragance :: Fragance } | Steak { fragance :: Fragance }
11:13:23 <lambdabot>  .L.hs:146:41:
11:13:24 <lambdabot>      Not in scope: type constructor or class `Fragance'
11:13:24 <lambdabot>      P...
11:13:41 <Rarrikins> Blah
11:13:47 <mm_freak> try it in a local source file ;)
11:13:48 <mm_freak> @undefine
11:13:49 <lambdabot> Undefined.
11:13:55 <monochrom> have you read the error message? :)
11:14:17 <monochrom> oh nevermind, you have.
11:14:21 <enthropy> case f of c { pH = 7 } -> "neutral"; _ -> "has no ph" -- too bad this won't work
11:14:51 <Rarrikins> It was a minor misspelling.
11:15:10 <mm_freak> i wonder if pattern-matching with partial record accessors works with pattern guards
11:15:21 <mm_freak> case f of c | ph <- pH c -> …
11:15:23 <mm_freak> but i guess not
11:15:40 <enthropy> if it was  pH :: Food-> Maybe Int
11:15:41 <monochrom> that will bomb. pH in that context is just another partial function
11:15:59 <Rarrikins> It would be nice if you could concisely make it a Maybe.
11:16:08 <mm_freak> yeah, but then i think i've never used sums of records anyway
11:16:17 <mm_freak> Rarrikins: you can
11:16:23 <mm_freak> Rarrikins: with lenses
11:16:30 <mm_freak> or prisms rather
11:16:36 <Rarrikins> Ahh. I have yet to learn lenses or prisms.
11:16:44 <mm_freak> prisms are special lenses
11:17:18 <mm_freak> > Left 15 ^? _Left
11:17:20 <lambdabot>   Just 15
11:17:35 <mm_freak> > Left 15 & _Left +~ 2
11:17:37 <lambdabot>   Left 17
11:18:05 <monochrom> oh bother, pH values can step outside Int
11:20:55 <quchen> mm_freak: Wait, prisms are lenses?
11:21:08 <mm_freak> yeah
11:21:10 <jfischoff> colenses
11:21:11 <quchen> I thought they were distinct concepts
11:21:18 <quchen> Yeah something along those lines, jfischoff
11:21:25 <edwardk> we started calling the whole family of these things 'optics', that way both prisms and lenses are different kinds of optics
11:21:34 <edwardk> subject to related laws
11:21:40 <quchen> Quickly, grab the name on Hackage :-)
11:21:45 <edwardk> =P
11:22:23 <quchen> I'm still in the "understanding Iso" stage though, so what do I know about anything :-C
11:24:03 <ocharles> quchen: if you claim 'optics', edwardk will just release 'optic' and vice-versa. and not many people are capable of writing the same library twice in different ways
11:24:04 <sansor_> hi all, what is the best way to use mutable arrays in haskell? i see that there is a GHC.Prim -> GHC.Arr -> Data.Array.MArray path, and there is a GHC.Prim -> Data.Primitive -> Data.Vector path...
11:24:07 * ocharles coughs
11:24:27 <sansor_> what are the main differences between these libraries that look similar to me??
11:24:31 <quchen> ocharles: You're thinking of the recent "lists eithers maybes" flood heh
11:24:34 <foozbazzz> how do i know if the code i'm writing is haskell98 or haskell2010? ... are there great sweeping differences?
11:24:39 <ocharles> quchen: that and folds :)
11:25:12 <quchen> foozbazzz: There's not a big difference. H10 removed n+k patterns and introduced pattern guards, that's about it.
11:25:14 <ocharles> though i'm fine with 'either', cause it is correct :)
11:25:27 <quchen> ocharles: You mean EitherT?
11:25:36 <ocharles> ya
11:26:18 <bss03> quchen: Technically, heirarchical module names is also 2010 and not 98, IIRC.
11:26:20 <enthropy> some imports are different
11:26:40 <foozbazzz> quchen: 2010 it is! thank yoj
11:26:40 <quchen> enthropy: But that's hardly a problem when you're using a non-ancient Base package
11:26:41 <jfischoff> sansor_: Vector has a fusion framework, so is usually preferred.
11:28:00 <enthropy> quchen: at some level it's worse that they standardized modules like Data.List. It's harder to tell whether you're getting the H10 Data.List, or the Data.List from the current base
11:28:21 <enthropy> before you would see `import List' and know right off that it was H98
11:28:59 <carter> hey all: could someone maybe set the topic to add "Have trouble with GHC on your mac, please read http://www.haskell.org/pipermail/haskell-cafe/2013-September/110320.html" or something?
11:29:12 <carter> i'm tired of having to repeat myself :)
11:29:14 <bss03> enthropy: Isn't there a package import syntax so you can say which package you want a module from?
11:29:18 <sansor_> jfischoff: thanks
11:29:38 <bss03> @topic Have trouble with GHC on your mac, please read http://www.haskell.org/pipermail/haskell-cafe/2013-September/110320.html
11:29:38 <lambdabot> Unknown command, try @list
11:30:24 <carter> jfischoff: elliott  edwardk  lispy sclv  who has channel topic powers?
11:30:52 <quchen> @ops
11:30:53 <lambdabot> Maybe you meant: pl oeis docs
11:30:59 <edwardk> try elliott he runs the bot. i think i remember how to hack it but i'd screw it up =)
11:31:02 --- mode: ChanServ set +o monochrom
11:31:07 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | GHC on mac: http://tinyurl.com/n74yuhz |Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com' by monochrom
11:31:09 <bss03> @push-topic Have trouble with GHC on your mac, please read http://www.haskell.org/pipermail/haskell-cafe/2013-September/110320.html
11:31:11 <jfischoff> carter: I suppose any of the channel ops …
11:31:18 <edwardk> or that
11:31:20 --- mode: monochrom set -o monochrom
11:31:22 <edwardk> monochrom++
11:31:37 <carter> monochrom: thankessssss
11:32:06 <carter> edwardk: my email about HP wasn't too grumpy was it?
11:32:16 <carter> well
11:32:18 <carter> i guess it was 3 emails
11:32:23 <carter> last night
11:32:58 <dpld> @p1 \k g -> k . (. g) . (flip ($))
11:32:58 <lambdabot> (. flip) . (.)
11:33:51 <quchen> Did you mean @unpl?
11:33:54 <quchen> @unpl \k g -> k . (. g) . (flip ($))
11:33:55 <lambdabot> \ k g j -> k (\ q -> g q j)
11:34:54 <dpld> No, it actually was p1
11:35:05 <dpld> Sometimes it is better to have some points though :)
11:35:14 <quchen> @unp1 \k g -> k . (. g) . (flip ($))
11:35:15 <lambdabot> Maybe you meant: unpl unpf
11:35:18 <quchen> Hmpf :-)
11:37:12 <dpld> Oh wait :)
11:37:18 <dpld> @pl \k g -> k . (. g) . (flip ($))
11:37:18 <lambdabot> (. flip) . (.)
11:37:48 <dpld> \unpl (.)
11:37:58 <dpld> @unpl (.)
11:37:58 <lambdabot> (\ a b c -> a (b c))
11:39:31 <dpld> @pl \f -> flip (.) (flip (.) f)
11:39:31 <lambdabot> flip (.) . flip (.)
11:39:46 <dpld> @p1 \f -> flip (.) (flip (.) f)
11:39:46 <lambdabot> flip (.) . flip (.)
11:40:30 <dpld> @pl \kk -> kk . flip ($)
11:40:33 <lambdabot> (. flip ($))
11:40:34 <lambdabot> optimization suspended, use @pl-resume to continue.
11:40:48 <dpld> @pl-resume
11:40:51 <quchen>  /q lambdabot
11:40:54 <lambdabot> (. flip ($))
11:40:54 <lambdabot> optimization suspended, use @pl-resume to continue.
11:43:00 <quchen> edwardk: I don't understand your email :-s
11:43:27 <quchen> Are you saying that not all possible instances should be added just because one can? I was only referring to Show/Read/Eq/Ord
11:43:31 <edwardk> quchen: some folks say things like newtype Down a = Down a  shouldn't have any instances other than the ones its changing
11:43:41 <edwardk> i am not suggesting this
11:43:48 <edwardk> i'm saying such a weak prescriptive argument could be made
11:44:01 <quchen> Okay, that in mind, let me try reading it again. :-)
11:44:07 <edwardk> and then i say that it is a bad idea though, because it leads to problems when people need things outside of what narrow minded view
11:44:19 <monoidal> can I see the mail? I was just about to commit Show/Read to Down
11:44:29 <monoidal> basing on the libraries discussion
11:44:31 <edwardk> monoidal: please do commit it
11:44:33 <edwardk> =)
11:44:34 <carter> agreed
11:44:45 <edwardk> monoidal: i was holding up Down as a strawman here, not criticizing this
11:44:48 <acowley> I want a profunctor Strong-like class that lets me put Monoid constraints here and there
11:44:52 <acowley> who's with me?
11:45:00 <carter> wheres that
11:45:02 <edwardk> acowley: ?
11:45:03 <quchen> acowley: Your editor?
11:45:29 <acowley> edwardk: If I can put Monoid constraints on first' and second' I can do more sensible things for machines
11:45:31 <quchen> monoidal: Sneak it in, if it's rejected ask the mailing list ;-)
11:45:53 <acowley> edwardk: There are several sensible options for bundling things up when two machines do not yield at the same rate
11:46:11 <acowley> edwardk: I've done a bunch of these combos before for the robotics stuff, but it really just boils down to monoid selection
11:46:15 <edwardk> the problem is that with those constraints these things aren't canonical in any ways
11:46:58 <acowley> Hmph
11:47:01 <edwardk> there are universal properties that say things like Strong and Choice should exist, but no such defense for one with a monoid
11:47:20 <acowley> I guess I should just keep that stuff out of the profunctor namespace
11:47:40 <acowley> It's frustrating because one can define seemingly okay instances, but they are not the only reasonable choice
11:49:43 <edwardk> thats why i try to stay toward things with universal properties. it avoids me having to make a decision ;)
11:50:02 <acowley> It's a nice strategy when it's available :)
11:50:25 <edwardk> When someone discovers it later it always feels like i just always made the right calls, when really i just stuck to writing things that have the property i couldn't screw them up.
11:51:19 <Lethalman> :t Data.Text.splitBy
11:51:20 <acowley> This whole area is so intriguing to me, though. This issue of merging streams with different rates also seems connected to tropical algebra
11:51:20 <lambdabot> Not in scope: `Data.Text.splitBy'
11:51:30 <Lethalman> sorry I've asked that today but I hadn't time to read
11:51:38 <Lethalman> Data.Text is not importable due to unsafeness :-(
11:52:04 <Lethalman> nothing to do here right? trustworthy or such...
11:52:28 <donri> Lethalman: latest version is Trustworthy
11:52:34 <Lethalman> donri, oh!!! thanks
11:52:35 <donri> not platform though i think
11:52:39 <Lethalman> let's see
11:52:43 * Lethalman doesn't use platform
11:54:19 <foozbazzz> i'm making a cabal package. it has many executables and about three modules. currently i only list the executables in the cabal file, and when doing "cabal build" it rebuilds these three modules over and over... is there a way to get around this?
11:56:41 <foozbazzz> is this where "library \n exposed-modules" and "executable \n other-modules" are necessary?
11:57:14 <enthropy> you shouldn't need a library section
11:57:28 <enthropy> but you do need to list those other-modules
11:58:36 <foozbazzz> enthropy: ok, i'll try that first.. thankls
12:02:02 <foozbazzz> enthropy: it seems to still build those modules over and over.
12:02:48 <carter> foozbazzz: are you giving the same optimization / build flags for each lib / binary?
12:03:45 <foozbazzz> carter: i'm not giving any.. there's only main-is, build-depends, other-modules, and default-languages ... and except for main-is, they're the same for each executable
12:03:55 <carter> huh
12:04:01 <carter> what ghc version/
12:04:04 <carter> and what cabal version?
12:04:35 <foozbazzz> carter: ghc 7.6.3 cabal 1.18.1
12:04:39 <carter> ok
12:04:43 <carter> hrm
12:05:15 <carter> if you can come up with a small minimal repro of the redundant builds, i think the cabal people would love a bug report
12:06:27 <Vulpyne> I'm having a somewhat odd issue with memory usage. I have a program I'm running with "+RTS -M80m -K512k" but it still somehow manages to slowly grow in memory usage >= 300mb.
12:06:50 <foozbazzz> carter: http://pastebin.com/7c7bg701
12:06:56 <mauke> The paste 7c7bg701 has been copied to http://lpaste.net/94283
12:07:09 <foozbazzz> carter: oh, that's not a repro; just an excerpt
12:07:16 <foozbazzz> carter: i'l make a repro.. one sec
12:07:20 <Vulpyne> I'd expect it to run out of heap before then, so what I suspect is some FFI stuff allocating memory that isn't accounted for by the normal Haskell heap. Does that sound reasonable?
12:07:42 <carter> doens't -M say "start the heap with this much space?"
12:07:56 <Vulpyne> Nope, that's -H
12:08:00 <carter> ok
12:08:02 <carter> i have no clue
12:08:19 <carter> what / who is mauke?
12:08:25 <Vulpyne> Thanks anyway. Anyone else?
12:08:33 <carter> Vulpyne: depends on the code!
12:09:08 <Vulpyne> Well... How could a program exceed the allowed heap/stack limits?
12:09:19 <Vulpyne> Aside from doing "out of band" allocations like with the FFI.
12:09:33 <mauke> carter: I'm me
12:09:34 <mm_freak_> foldl (+) 0 (repeat 1)
12:09:41 <carter> oh
12:09:46 <mm_freak_> @ Vulpyne
12:09:49 <Vulpyne> The code also also only calls forkIO once (but uses a lot of sparks) so I don't think it could be thread stacks.
12:10:00 <carter> Vulpyne: you need to share code or we cant help
12:10:11 <Vulpyne> It's a fairly large program, unfortunately.
12:10:19 <Vulpyne> I don't think showing it would help much.
12:10:50 <Vulpyne> I'm not really asking for details about the program specifically, but how the RTS limits work.
12:11:55 <carter> Vulpyne: oh, ezyang is the expert on that
12:12:00 <carter> also whats the ghc manual say?
12:12:38 <Vulpyne> It says that -M sets the max heap size to the specified size.
12:12:55 <Vulpyne> And that -K sets the max stack size to the specified number of bytes (and you can use suffixes like m, g, etc for convenience)
12:13:09 <Vulpyne> The default heap limit is unlimited, and the default stack size is 8mb.
12:13:56 <Vulpyne> If there were a lot of forkIO'd threads and the stack size was large, and those threads were in a way that used stack space then I'd expect the memory usage to be able to grow bigger than the configured heap.
12:14:01 <Vulpyne> But I've set the stack size to only 512k.
12:14:08 <Vulpyne> And the program only forks once.
12:14:10 <carter> how many thread?
12:14:19 <carter> even green threads have a stack
12:14:22 <Vulpyne> I'm not sure if sparks each get a stack though.
12:14:38 <Vulpyne> It uses quite a bit of sparks.
12:15:01 <Vulpyne> The way the program works is it grabs packets off the wire using pcap, up to 10,000 packets, then compresses them and saves them to a file.
12:15:02 * carter idk
12:15:04 <carter> idk
12:15:07 <carter> hrm
12:15:08 <carter> neat
12:15:10 <Vulpyne> The compression/conversion part is what uses the sparks.
12:15:18 <carter> what compression alg?
12:15:29 <Vulpyne> And after each chunk, there's no state preserved.
12:15:48 <carter> try triggering a GC explicitly
12:15:53 <Vulpyne> However the program doesn't spike to a large amount of memory, it very gradually grows. So it's not that processing any single chunk is requiring more memory than permitted.
12:16:03 <carter> it might be too much laziness
12:16:07 <carter> or too much sharing
12:16:13 <Vulpyne> A custom algorithm + gzip.
12:16:17 <carter> ok
12:16:21 <wollw> If I want to compile a package for ARM that requires template haskell, is it possible to evaluate the template haskell on another computer with GHCi?
12:16:28 <Vulpyne> Well, there are no variables in scope between chunks.
12:16:33 <carter> are your data structures strict?
12:16:47 <Vulpyne> So if the problem was laziness within a specific chunk, then I'd expect it to be available to GC after the chunk was finished.
12:16:58 <Vulpyne> Yeah, in general.
12:17:04 <Vulpyne> But it shouldn't really matter for the reasons I mentioned.
12:17:10 <carter> well
12:17:11 <carter> idk
12:17:12 <carter> :)
12:17:21 <carter> have you use the heap profiling tools that ghc has?
12:17:30 <carter> sounds like you havent...
12:17:42 <Vulpyne> Not yet (would be kind of a pain for various reasons, but I may have to.)
12:18:00 <Vulpyne> I'm also thinking it won't be that helpful since the program is able to grow to use more memory than the configured limits.
12:18:10 <enthropy> wollw: if it's just top-level (Q [Dec]) splices, this might do the right thing https://github.com/aavogt/zeroth
12:18:12 <mm_freak_> Vulpyne: sparks don't get stacks, until they are assigned to a thread
12:18:17 <Vulpyne> So it stands to reason that the memory that's leaking isn't considered part of the heap, and then profiling the heapon won't really help.
12:18:33 <mm_freak_> Vulpyne: i recommend reading this:  http://chimera.labs.oreilly.com/books/1230000000929
12:18:45 <carter> Vulpyne: try it anyways...
12:18:48 <wollw> enthropy: Thanks, I'll take a look.
12:19:04 <enthropy> or maybe there are some other better forks of that (mostly dead) project
12:19:07 <Vulpyne> mm_freak_: Thanks, I have read it though.
12:19:19 <Vulpyne> I can't say that I've memorized the whole thing. :)
12:19:32 <mm_freak_> Vulpyne: me neither =)
12:19:53 <Vulpyne> This program sniffs packets, and there are a *lot* of them. Like 10mbit+.
12:20:12 <Vulpyne> So if it was failing to free the actual packet payloads it would run out of memory very quickly.
12:20:16 <Vulpyne> Instead of growing very slowly.
12:20:30 <mm_freak_> how do you get the packets?  are you FFI-binding to libpcap or something?
12:20:46 <Vulpyne> I'm using the pcap binding from hackage.
12:21:01 <Vulpyne> The dispatchBS function from it, specifically.
12:21:08 <mm_freak_> and your program's RAM usage grows far beyond your -M setting?
12:21:26 <carter> yeah
12:21:29 <Vulpyne> Indeed, it's at 400mb now.
12:21:34 <Vulpyne> And I am running it with -M80 -K512k
12:21:35 <carter> that sounds like theres some delayed frees off heap
12:21:44 <carter> Vulpyne: what does the heap residency say?
12:21:46 <Vulpyne> Also, it's been running for an hour or so.
12:21:47 <mm_freak_> -M80?  -M80m?
12:21:57 <Vulpyne> Sorry, -M80m
12:22:00 <carter> because the only off heap stuff would but stuff GHC's rts isn't managing
12:22:12 <Vulpyne> The 400mb figure I'm giving is RES.
12:22:29 <carter> from the GHC process, or from the heap?
12:22:40 <mm_freak_> the RTS would blow up if more than 80 MiB were required at once, so my guess is that there is some FFI data structure running amok
12:22:54 <Vulpyne> mm_freak_: That's what I said. :) I just wanted to confirm it.
12:23:02 <mm_freak_> Vulpyne: yeah, sounds reasonable
12:23:10 <Vulpyne> But if there was a massive memory leak in pcap, I'd think it would have been fixed by now.
12:23:15 <Vulpyne> It's been a year since the last commit in the git repo.
12:23:23 <mm_freak_> unfortunately the pcap binding is rather old
12:23:23 <carter> could still be a bug there
12:23:30 <Vulpyne> GHC process? Do you mean the program compiled with GHC?
12:23:46 <Vulpyne> I think what you're trying to find out is if I'm counting virtual memory, shared libraries, etc - no, I'm talking only about resident memory usage.
12:23:49 <carter> yes
12:23:53 <carter> idk
12:23:59 <mm_freak_> Vulpyne: i suggest emulating the pcap binding (just generate random packets and feed it to your program)
12:24:10 <mm_freak_> if the memory behavior goes away, then you know it's the pcap binding
12:24:34 <carter> good idea
12:24:35 <Vulpyne> Aw man, I wanted easy fixes!
12:24:53 <mm_freak_> make sure you generate random packets (not just one constant packet fed multiple times), otherwise sharing can kick in
12:25:14 <mm_freak_> Vulpyne: i'm pretty sure it's the pcap binding
12:25:31 <mm_freak_> if it's indeed buggy, it's rather easy to make your own binding =)
12:26:07 <Vulpyne> Thanks for the advice.
12:28:59 <foozbazzz> carter: i can't seem to push this example to gist .. is there a good place i can upload it? it's ilke four files and one subfolder.
12:29:26 <mm_freak_> foozbazzz: hub.darcs.net =)
12:30:47 <Vulpyne> From looking at the pcap source, I can't really see how it would leak memory.
12:30:56 <Vulpyne> It doesn't allocate anything really.
12:31:26 <mm_freak_> Vulpyne: more likely libpcap itself does allocate stuff
12:31:45 <mm_freak_> and it certainly uses malloc() instead of GHC's RTS =)
12:31:54 <Vulpyne> dispatch passes in a pointer to the packet header and body, but the docs for pcap itself say that those pointers are only valid in the callback and should not be freed.
12:32:42 <mm_freak_> btw, is libpcap actually necessary?  can't packet sockets do the same thing?
12:33:13 <Vulpyne> Packet sockets?
12:33:38 <Rarrikins> Yes, sockets with packets rather than circuits.
12:33:55 <Vulpyne> Well, I have to promiscuously sniff all traffic hitting a certain interface, according to a filter.
12:34:03 <Vulpyne> Would that be possible with packet sockets?
12:34:20 <mm_freak_> i'm not sure…  as far as i know libpcap is for portability
12:34:33 <geekosaur> libpcap is an interface, packet sockets are one thing that (appropriate releases of) libpcap can wrap, as I understand it
12:34:33 <mm_freak_> otherwise you can just set the interface to promisc. mode and use raw/packet sockets
12:34:56 <geekosaur> packet sockets do not help you with decoding packets though libpcap does
12:35:07 <Vulpyne> libpcap doesn't. :(
12:35:13 <Vulpyne> Had to write my own packet parsing code.
12:35:36 <Vulpyne> Well, at least the pcap interface on hackage has nothing to assist with parsing the packets.
12:35:38 <spaceships> Vulpyne: :(
12:35:41 <geekosaur> (not a whole lot but some. allllso libpcap lets you use existing packet decoding libraries (in C) which are on top of libpcap
12:35:43 <mm_freak_> my question is:  does libpcap do anything related to the actual sniffing a packet socket can't do?
12:35:59 <Vulpyne> I wasn't familiar with packet sockets, so I really couldn't say.
12:36:11 <mm_freak_> Vulpyne: there are quite a few libraries on hackage with packet types
12:36:12 <Vulpyne> I'd rather not have to rewrite large chunks of this or make my own interfaces.
12:37:21 <geekosaur> there's also the part some of us clearly wrongheaded folks care about: portability
12:37:35 <Vulpyne> Yes, portability is pretty decent.
12:37:41 <Vulpyne> But it's not my biggest concern. :)
12:38:02 <Vulpyne> pcap gives a pretty reasonable high level interface for snarfing packets though.
12:38:05 <Vulpyne> It's convenient to use.
12:38:12 <mm_freak_> Vulpyne: http://hackage.haskell.org/package/network-data
12:38:23 <geekosaur> if linux is the only OS you will ever care about, go ahead and code directly to  a Linux specific interface
12:38:41 <Vulpyne> mm_freak_: That's just packet headers.
12:38:51 <Vulpyne> Not actually taking data and turning it into a structure.
12:39:02 <mm_freak_> Vulpyne: look closer
12:39:27 <Vulpyne> Ah, okay, serialize instances.
12:39:32 <sclv_> preflex: seen poucet
12:39:39 <preflex>  poucet was last seen on #haskell-infrastructure 4 hours, 56 minutes and 55 seconds ago, saying: Also, there's no contact information on the page linked to by "Problems?"
12:39:40 <Vulpyne> But I actually already did the work of making my packet parsing code.
12:40:04 <Vulpyne> This thing works, except for the gradually increasing memory usage.
12:40:15 <carter> whats the end goal?
12:40:33 <Vulpyne> To deploy it and live happily ever after, while it doesn't murder the machine it runs on.
12:41:08 * hackagebot hath 0.1.0 - Hath manipulates network blocks in CIDR notation.  http://hackage.haskell.org/package/hath-0.1.0 (MichaelOrlitzky)
12:41:11 * hackagebot JuicyPixels 3.1.1.1 - Picture loading/serialization (in png, jpeg, bitmap, gif, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.1.1.1 (VincentBerthoux)
12:41:27 <mm_freak_> Vulpyne: how many haskell threads does your program use?  because the stack is per-thread
12:41:50 <Vulpyne> Just the main thread and one helper, but it does use sparks.
12:42:10 <carter> Vulpyne: how many sparks?
12:42:13 <Vulpyne> Hang on. I guess I can put the main module in a gist or something.
12:42:57 <foozbazzz> mm_freak_ carter : http://hub.darcs.net/blorbab/cabal-test
12:43:08 <carter> foozbazzz: ooo
12:43:12 <foozbazzz> mm_freak_: if you're interested to help, my question is in the description
12:43:33 <Vulpyne> https://gist.github.com/vulpyne/a99ad6427d9d9fcd71f1
12:43:44 <carter> foozbazzz: i think you should file a bug report at github.com/haskell/cabal/issues
12:44:03 <sqdfsq> mm_freak_, hi again
12:44:04 <Vulpyne> packetHandler is forkIO'd and pulls in the packets.
12:44:13 <foozbazzz> did you see the content of the cabal file? in this repo i'm not using other-modules at all..
12:44:14 <mm_freak_> foozbazzz: move the executables into different directories
12:44:16 <carter> Vulpyne: how many aprksparse
12:44:24 <carter> foozbazzz: so you should file a bug report / feature request
12:44:25 <xico> how do i get a Ptr a from a a? (i would need a GLuint -> Ptr GLuint)
12:44:27 <sqdfsq> I made something that works, but it doesn't feel very haskelly or even functional
12:44:34 <Vulpyne> spork (an extremely descriptive name, I know) does processing and saves them (runs in main thread.)
12:44:35 <sqdfsq> http://lpaste.net/94285
12:44:39 <foozbazzz> mm_freak_: what?
12:44:51 <carter> mm_freak_: he's finding that cabal does redundant builds
12:44:54 <foozbazzz> carter: i feel like i'm just using it wrong.. are you sure my cabal file is write?
12:44:54 <Vulpyne> carter: It depends, but even if it used a lot of sparks the processing is done in chunks with nothing in common.
12:44:55 <carter> foozbazzz: file a bug reprot
12:45:02 <carter> foozbazzz: file a bug report
12:45:08 <foozbazzz> carter: ok ok :)
12:45:10 <mm_freak_> no, that's not a bug
12:45:12 <Vulpyne> So memory usage could spike for a specific chunk, which I'd be okay with.
12:45:13 <carter> well
12:45:16 <carter> a feature request ;)
12:45:21 <mm_freak_> foozbazzz: it's not a bug, it's a feature
12:45:25 <carter> oh?
12:45:26 <Vulpyne> But it just slowly growss forever until the machine runs out of memory.
12:45:39 <carter> Vulpyne: how long do the sparks last before they're fun?
12:45:40 <carter> *run
12:45:41 <mm_freak_> foozbazzz: if you want to get rid of redundant builds, turn the Lib stuff into a library
12:45:49 <Vulpyne> A very short time.
12:45:50 <xico> (it's "with")
12:45:56 <Vulpyne> Each chunk takes about a second to process.
12:46:03 <Vulpyne> And a new chunk is generated roughly every 10sec.
12:46:10 <mm_freak_> foozbazzz: you can have both a library and executables in one package
12:46:15 <foozbazzz> mm_freak_: even though it's not necessary to expose as part of the package?
12:46:31 <foozbazzz> mm_freak_: ok i'll try that
12:46:35 <mm_freak_> foozbazzz: http://hub.darcs.net/ertes/config/browse/skel
12:46:39 <mm_freak_> that's how i do it
12:47:14 <mm_freak_> foozbazzz: notice that the library sits right in the root directory, while executables live in subdirs ("program" and "test")
12:47:34 <mm_freak_> ah, it's not up to date anymore, let me push my latest changes
12:48:12 <foozbazzz> mm_freak_: i'll wait for your push
12:48:16 <Vulpyne> github doesn't understand UnicodeSyntax. :(
12:49:13 <mauke> giþub
12:49:47 <dmj`> can lambdabot do kinds?
12:50:36 <monoidal> @kind []
12:50:37 <lambdabot> * -> *
12:50:47 <dmj`> @kind Monad
12:50:48 <lambdabot> (* -> *) -> Constraint
12:51:01 <dmj`> monoidal: Where is Constraint defined
12:51:08 <monoidal> dmj`: GHC.Prim
12:51:20 <dmj`> monoidal: thank you
12:51:25 <monochrom> GHC.Exts
12:51:39 <mm_freak_> foozbazzz: pushed
12:51:53 <mm_freak_> foozbazzz: see +name+.cabal.bob
12:52:33 <Vulpyne> Guess the code didn't help.
12:53:03 <mm_freak_> foozbazzz: as you can see the executables depend on the library in the same package
12:53:24 <foozbazzz> so you put library files at the top level, and then each executable in it's own subdir?
12:53:31 <mm_freak_> yeah
12:54:05 <foozbazzz> mm_freak_: is there a way to do it the other way around? executable sources all at the top level, and library files all in a single subdir?
12:54:24 <foozbazzz> mm_freak_: if not, that's fine.. just curious :)
12:54:42 <mm_freak_> foozbazzz: haven't tried
12:54:44 <theVart> Does someone know why this https://pastee.org/zz433 runs forever while https://pastee.org/yyh8g finishes quickly. They're pretty much identical other than the where
12:55:06 <foozbazzz> mm_freak_: alright
12:55:13 <mm_freak_> foozbazzz: but it's important to keep them separate…  otherwise when in your executable you import X.Y and it exists as a file, it will take precedence over X.Y exposed by a library
12:55:27 <mm_freak_> so X.Y will be recompiled, even though it's already exposed by a library
12:56:03 <mm_freak_> this is universal…  if you had a module named Data.List in your executable, it would take precedence over base's Data.List and would get compiled as part of your project
12:56:14 <mm_freak_> that's why this redundant compiling is not a bug, but a feature =)
12:56:51 <Vulpyne> theVart: How long is the list you're passing to it?
12:57:20 <sqdfsq> mm_freak_, did you see http://lpaste.net/94285 (regarding the basketball example you helped me with a couple of hours ago)
12:57:35 <foozbazzz> how does a program in ./subdir/foo.hs import a module located in ./Mod.hs ? .. it's one level up..
12:57:43 <foozbazzz> mm_freak_:  ^
12:57:44 <sqdfsq> I managed to get something working, but it does not feel right
12:57:49 <Lethalman> theVart, the first one terminates
12:58:10 <theVart> https://pastee.org/qfb5y <- That's the list I'm using
12:58:22 <Lethalman> theVart, http://ideone.com/6rG3Hk
12:58:40 <Vulpyne> Have you tried it with other lists? For example: "hi"
12:59:12 <theVart> Yes, I have
13:00:49 <monochrom> theVart, I think you're just looking at exponential time vs linear time
13:01:53 <Lethalman> theVart, look my paste, it run :)
13:02:00 <Vulpyne> Yeah, the version with the where will have to do a lot more calculating, since the result isn't shared.
13:02:05 <Vulpyne> Er, without.
13:02:10 <theVart> monochrom, why is one of them linear and the other exponential?
13:02:28 <Lethalman> monochrom, there's no exponential stuff in there
13:02:51 <Vulpyne> He means the amount of calculations it has to do.
13:03:03 <Lethalman> Vulpyne, yet not exponential
13:03:12 <Lethalman> it might be at most 2n instead of n
13:03:29 <Vulpyne> I'm pretty sure it's not 2n.
13:03:43 <Vulpyne> Keep in mind that each recursion into krontroll will also recurse again.
13:03:47 <Vulpyne> And that will recurse, etc.
13:03:50 <Lethalman> Vulpyne, yes and?
13:03:53 <Lethalman> Vulpyne, it consumes the list
13:03:56 <Lethalman> it's at most n
13:03:59 <Megatomte> Lethalman: what do you mean that it terminates?
13:04:03 <monoidal> dmj`: http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/constraint-kind.html
13:04:16 <Lethalman> Megatomte, it terminates because it consumes the list
13:04:17 <lpaste> monochrom pasted “exponential time and linear time” at http://lpaste.net/94286
13:04:39 <monochrom> theVart, Lethalman: see that, http://lpaste.net/94286
13:04:42 <Megatomte> Lethalman: doesnt the other paste consume the list as well?
13:04:53 <Lethalman> Megatomte, yes, terminates
13:05:08 <monochrom> consider fexp 20 and flin 20
13:05:30 <Megatomte> Lethalman: so both terminate?
13:05:33 <monochrom> add some Debug.Trace.trace if you want to see more
13:05:35 <Lethalman> Megatomte, ...
13:06:07 <Megatomte> Lethalman: forgive me, i'm new with haskell!
13:06:08 <Vulpyne> I can guarantee you'll see a lot more prints from Debug.Trace than 2n. :)
13:06:19 <Lethalman> Megatomte, if the list is finite, it terminates
13:06:28 <theVart> monochrom, thank you
13:06:41 <Megatomte> Lethalman: okay, you mean it just takes ~a very long time~ to do it?
13:06:47 <Lethalman> Megatomte, yes
13:06:51 <monochrom> it is the same exponential time reason as "fib n = fib (n-1) + fib (n-2)"
13:06:57 <Lethalman> monochrom, true that
13:07:20 <Lethalman> degenerated but still exponential :(
13:07:42 <Lethalman> oh no it's even worse than fib
13:08:04 <monochrom> an expoential-time algorithm over a text of length 120 is going to look like non-termination :)
13:08:36 <monochrom> fib is 1.617^n, fexp is 2^n.
13:08:40 <Lethalman> eh eh... especially with that n+1 not being strict :P
13:09:34 <foozbazzz> i'm still pretty stuck here .. i have a project with >10 executable-sources and two modules in a subdirectory .. i'd like the cabal file to compile the modules only once for all the executables .. is this possible with my arrangement? http://hub.darcs.net/blorbab/cabal-test
13:09:46 <monochrom> this is why "the algorithm terminates" and "it's a total function" completely miss the point.
13:09:58 <mm_freak_> foozbazzz: it gets the module as part of the library
13:10:17 <mm_freak_> sqdfsq: i'll be back in a few minutes, then i'll check it out
13:10:32 <Lethalman> monochrom, he may have written something that didn't terminate at all
13:10:53 <dmj`> So it's my understanding that classes yield constraints (i.e. class Monad), which restrict polymorphic type variables, to types that implement the class Monad. So the kind of Monad is (* -> * -> Constraint), when made a concrete type with Maybe (* -> *), a Constraint kind is produced. (i.e. :k (Monad Maybe) yields Constraint). So is it safe to that Constraint is the kind for concrete types? Or am I confused
13:11:04 <carter> foozbazzz: try mm_freak_ 's idea
13:11:04 <foozbazzz> mm_freak_: i mean, i tried making a library section and saying what modules are in it, but i got this: http://pastebin.com/XmnwM0Gh
13:11:10 <mauke> The paste XmnwM0Gh has been copied to http://lpaste.net/94287
13:11:12 * hackagebot diagrams-haddock 0.2.1.1 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.2.1.1 (BrentYorgey)
13:11:14 * hackagebot hslinks 0.5 - Resolves links to Haskell identifiers.  http://hackage.haskell.org/package/hslinks-0.5 (HansHoglund)
13:11:14 <dmj`> to say*
13:11:27 <monochrom> instead of idealizing about "a language that makes you prove termination", you should idealize about "a language that makes you state and prove a concrete time bound". I'm looking at all you agda fans and coq fans etc
13:11:43 <monoidal> dmj`: Monad is kind (* -> *) -> Constraint, remember about parens
13:11:57 <dmj`> monoidal: yes, thank you
13:12:01 <monoidal> dmj`: Constraint is a kind for things that appear on the LHS of =>
13:12:02 <Lethalman> monochrom, -.-'
13:12:25 <sqdfsq> mm_freak_, ok thanks!
13:12:30 <monoidal> dmj`: what do you mean by "kind for concrete types"?
13:13:32 <monoidal> dmj`: Constraint is fully applied in this sense, like * is, but not like * -> * or * -> Constraint etc.
13:13:45 <dmj`> A concrete type is a type that has all of its polymorphic type variables specified, So Maybe a, compared with Maybe String. Maybe String is a "concrete type" am I understanding that correctly?
13:14:21 <monoidal> dmj`: a constraint can also have type variables, e.g. Show a is of kind Constraint
13:14:44 <monoidal> dmj`: it's the same situation as with non-constraints, e.g. [a] is of kind *
13:15:20 <Lethalman> :k [a]
13:15:20 <lambdabot> Not in scope: type variable `a'
13:15:36 <donri> :k []
13:15:37 <lambdabot> * -> *
13:15:45 <Lethalman> ah
13:15:47 <donri> :k forall a. [a]
13:15:48 <lambdabot> *
13:16:02 * Lethalman is ignoring kinds
13:16:37 <monochrom> "concrete type" depends on the speaker
13:16:37 <donri> that's kind of typical, real classy! i categorically disagree with doing so!
13:16:39 <dmj`> so concrete types are defined as types with kind * ?
13:16:58 <monochrom> as is "beautiful theorem"
13:17:06 <donri> dmj`: it's not a formally defined term as far as i know
13:17:27 <coreyoconnor> I'm attempting to write a tiny HTTP server using only Haskell Platform packages
13:17:30 <coreyoconnor> https://github.com/coreyoconnor/tiny-http-hp/blob/master/TinyHttp.hs
13:17:37 <donri> dmj`: i think i use your definition myself though
13:17:40 <coreyoconnor> this fails about 3% of the time
13:17:52 <coreyoconnor> I think lazy IO is messing me up
13:18:08 <coreyoconnor> the socket is closed before the response is sent AFAICT
13:18:17 <coreyoconnor> anybody know what I'm missing?
13:18:34 <jfischoff> dmj`: Monad is (* -> *) -> Constraint not * -> * -> Constraint
13:18:51 <dmj`> jfischoff: yes, thank you
13:19:06 <donri> doesn't that depend on whether ConstraintKinds is enabled?
13:19:14 <monoidal> no
13:20:02 <monoidal> technically, in pure 2010, mere "Monad" makes no sense; class must be fully applied and put on the LHS of =>
13:20:07 <donri> (does haskell98/2010 even specify kinds?)
13:20:14 <monoidal> it does. but not constraints
13:20:24 <monoidal> it does not have any kind syntax, though
13:21:11 <dmj`> Fonzie says: Aaay! When I talk about concrete types I mean like fully applied types like Map Int String or if we're dealin' with one of them polymorphic functions, [a] or (Ord a) => Maybe a and stuff. And like, sometimes me and the boys say that Maybe is a type, but we don't mean that, cause every idiot knows Maybe is a type constructor. When I apply an extra type to Maybe, like Maybe String, then I have a concrete type. You know,
13:21:11 <dmj`> values can only have types that are concrete types! So in conclusion, live fast, love hard and don't let anybody else use your comb!
13:21:13 * hackagebot transf 0.10 - Text transformer and interpreter.  http://hackage.haskell.org/package/transf-0.10 (HansHoglund)
13:21:19 <dmj`> from lyah
13:21:49 <monoidal> dmj`: yes, in this sense, concrete types == types of kind *
13:22:12 <dmj`> So as long as you have no type variables w/o constraints, you can have a concrete type
13:22:18 <foozbazzz> carter: mm_freak_ : i inverted the directory structure, and still it compiles the module(s) redundantly.. http://hub.darcs.net/blorbab/cabal-test
13:22:48 <monoidal> dmj`: my understanding of this definition is that it callls [a] and Ord a => Maybe a concrete types
13:22:57 <carter> i know nothing
13:23:02 <carter> literally
13:23:07 <carter> i have redundant builds in my stuff
13:24:00 <bss03> What is 'OpenKind'?
13:24:07 <foozbazzz> carter: ah, ok..
13:24:10 <bss03> ghc is saying: Expected kind `OpenKind', but `ctx' has kind `AnyContext'
13:24:18 <monochrome> hello #haskell
13:24:27 <monoidal> bss03: unless you're dealing with unboxed types, OpenKind is the same as *
13:24:27 <bss03> Hello, monochrome.
13:24:41 <dmj`> monoidal: I see, because [] has a kind that yields a Constraint, so does Ord. If we just have foo :: a, it would not be concrete correct?
13:25:03 <monoidal> dmj`: [] does not yield a Constraint. it is * -> *
13:25:15 <monoidal> dmj`: as LYAH defined it, it would be.
13:25:23 <bss03> monoidal: Hrm, I can see why ghc might expect OpenKind, but I'm trying to restrict the kind to be a particular DaraKind.
13:25:30 <bss03> I'm probably just doing it wrong. :(
13:25:36 <monoidal> bss03: lpaste
13:26:15 <acowley> coreyoconnor: What happens when it fails?
13:26:26 <monochrome> I'm writing some bindings to a C library with a lot of #define constants on which it would be nice to pattern match in Haskell and I have some questions about the best aproach.
13:26:38 <dmj`> monoidal: yes, [] isn't a class, my bad. Also, there must be objective truth when dealing with this. I know LYAH defines it one way, but what is the objectively correct way to understand concrete types.
13:26:55 <monoidal> bss03: forgot, OpenKind might also mean Constraint
13:27:34 <monoidal> dmj`: I don't think there's an everywhere accepted definition, but I think concrete type = type of kind * is the most common
13:28:03 <ParahSailin> is there an array package that exposes O(1) indexing and O(1) amortized append?
13:28:16 <monochrome> As i see it i can create a newtype to just wrap an Int,  make a data type , or a combination of the two by first just doing a newtype and the write a higher lever wrapper using data types where apropiate
13:28:17 <monochrome> ?
13:28:24 <dmj`> :k Maybe String
13:28:25 <lambdabot> *
13:28:26 <lpaste> bss03 pasted “Kind mis-match” at http://lpaste.net/94288
13:28:46 <dmj`> :k forall a . Maybe a
13:28:47 <lambdabot> *
13:29:02 <donri> :k forall a. a
13:29:03 <lambdabot> *
13:29:06 <monochrome> are there any other ways, what would the best aproach be?
13:29:49 <dmj`> Still confused, how can we have a kind of *, when there is no Constraint specified on a in (forall a . Maybe a)
13:29:55 <lpaste> bss03 revised “Kind mis-match”: “No title” at http://lpaste.net/94288
13:30:06 <bss03> monodial: ^^
13:30:46 <dmj`> unless the forall (universal quantification) is doing something I don't understand
13:31:41 <monochrom> why must Constraint be involved? Maybe :: * -> *, no Constraint there. Now just plug in something of kind *, for example a::*
13:31:54 <monoidal> bss03: what value do you expect of type WellFormed <something>?
13:32:07 <monoidal> bss03: there's no value whose type has kind AnyContext
13:32:10 <bss03> ctx_EMP = WellFormed $ AnyC EmptyC
13:32:34 <monoidal> bss03: so maybe you want newtype WellFormed = WellFormed AnyContext
13:33:05 <bss03> ctx_EMP :: WellFormed (AnyC EmptyC)
13:33:54 <bss03> I want to have the context in the type so I can write a type signature that unifies two contexts, e.g.  ctx_EXT :: HasType c a u -> WellFormed (AnyC (ExtC c a))
13:34:00 <monoidal> dmj`: you don't need to specify a constraint for a universally type variable to have kind *
13:34:25 <monoidal> dmj`: (in forall a. Maybe a, you could as well write forall a. () => Maybe a, i.e. empty context)
13:34:45 <monoidal> bss03: I'm afraid you need dependent types for this
13:36:06 <monoidal> bss03: you could store the type of the context in an additional variable to context
13:36:15 <monoidal> bss03: but this is going to be messy IMO
13:36:20 <monochrome_> can anyone help?
13:36:43 <bss03> monoidal: Hrm, I'll just have to weaken things a bit then pass around maybes or something.  I'm fiddling around with trying to do type checking on the HoTT type system presented in it's appendix.
13:37:18 <foozbazzz> mm_freak_: i have to go.. thanks for your help though!
13:38:07 <dmj`> monoidal: isn't forall a, implicit? Why do I need to specify it when doing :k Maybe a
13:38:20 <monoidal> dmj`: in :k, it is not. In type signatures (using ::), it is.
13:38:37 <carter> wait, so i can't do derive Show, Read,Eq on GADTS?
13:39:01 <monoidal> carter: only standalone deriving
13:39:05 <carter> ok
13:39:09 <carter> whats the syntax for that again?
13:39:16 <carter> this'll be the first time i'm doing that
13:39:20 <monoidal> deriving instance Show a => Show (Maybe a), for example
13:39:47 <carter> ok
13:40:21 <monoidal> carter: wait, I'm wrong http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/data-type-extensions.html
13:40:21 <monoidal> carter: search for deriving
13:40:36 <dmj`> :k Monad m => m String
13:40:56 <lambdabot> *
13:41:18 <monoidal> dmj`: bit confusingly, the "forall" is implicitly present every time you use =>
13:41:35 <monoidal> dmj`: (there are plans to change this in future ghc.)
13:42:06 <lpaste> carter pasted “can't derive eq  read show” at http://lpaste.net/94290
13:42:14 <carter> monoidal: nope
13:42:23 <carter> i think its because i'm too fancy
13:42:32 <dmj`> so forall is existential quantification? not universal...
13:42:59 <monoidal> dmj`: it is universal, *except* in a special form of a data declaration
13:43:01 <carter> can't even derive Typeable or Data
13:43:02 <carter> :(
13:43:13 <monoidal> carter: with -XDeriveDataTypeable or whatnot?
13:43:28 <carter> monoidal: nope
13:43:31 <carter> try it yourself
13:43:39 <carter> i think it *should* work with 7.7
13:43:53 <carter> but probably not with 7.6 or older...
13:43:53 <monoidal> carter: ah, I think there's a ticket for that
13:44:06 <carter> is there a typeable1 class or something
13:44:08 <monoidal> carter: is Nat the same as GHC.TypeLits.Nat or a custom one?
13:44:13 <carter> custom one
13:44:16 <carter> ohhh
13:44:20 <carter> hrmmm
13:44:25 <monoidal> carter: it should work in 7.7, but definitely not 7.6
13:44:28 <carter> S Nat | Z
13:44:35 <carter> i'll see if i an add instances to it
13:44:48 <monoidal> for type-level nats, Typeable still does not work as far as I remember
13:45:24 <monoidal> dmj`: the only place where forall denotes existential quantification is a declaration like this: data Datatype = forall a. Construct ...
13:46:28 <carter> i guess i'll write those instances by hand
13:46:33 <monoidal> carter: it's doubtful, you would need TypeableNat or something like that
13:46:43 <monoidal> carter: or, instance Typeable (Shape rank) if that makes sense
13:46:45 <carter> monoidal: i mean eq/read/show
13:46:47 <carter> yeah
13:47:18 <dmj`> monoidal: ok interesting, the forall seems to always mean "universal" in my mind though.
13:48:18 <dmj`> monoidal: so when making something an instance of monad, a concrete type isn't necessary, just a type that can fully apply the Monad class to yield a constraint.
13:48:23 <dmj`>  
13:48:24 <dmj`> s
13:48:25 <monoidal> carter: Show/Eq can be standalone derived
13:48:52 <monoidal> dmj`: that's right. For example, you can write instance (Monad m) => Monad (ReaderT r m)
13:49:03 <dmj`> instance Monad (Either a) where
13:49:12 <monoidal> dmj`: oh, that's a better example
13:49:41 <monoidal> dmj`: notice Either is applied to one parameter, not two
13:50:13 <monoidal> carter: don't know what's the deal with Read
13:50:13 <dmj`> I see, that was confusing me, for some reason I thought we needed a concrete type when doing instances
13:50:21 <carter> monoidal: thanks!
13:50:48 <carter> deriving instance Show (Shape rank) and deriving instance Eq (Shape rank) works
13:50:48 <carter> monoidal: proably because it can't check the size?
13:50:48 <dmj`> monoidal: But, in Monad (Either a), this means, since a is specified, its value cannot change right?
13:51:00 <dmj`> in the monad def of either, Left never changes
13:51:15 <monoidal> dmj`: in that sense, yes
13:51:55 <monoidal> carter: I don't know the reason
13:52:00 <carter> i think i know why
13:52:16 <carter> read doesn't really have the notion of checking the parse
13:52:17 <monoidal> carter: I think that's right - it would writing run-time typechecking whether an expression you are reading is valid
13:52:17 <carter> ish
13:52:31 <Jesin> Maybe is equivalent to (Either Void)
13:52:44 <Jesin> unless you use deepseq
13:52:56 <carter> so i can write readShapeMaybe :: String -> Maybe (Shape rank)
13:53:11 <elliott> ?
13:53:11 <elliott> no, Either ()
13:53:12 <elliott> (modulo _|_)
13:53:13 <dmj`> monoidal: how would I say it in a way that is objectively correct, the correct sense. What is the reason why Left doesn't change its type nor value.
13:53:30 <carter> hrmmm. so I need to do some reflection to reify that rank as a runtime integer and query the parsed shape for length?
13:53:58 <monoidal> dmj`: the type of >>= is m a -> (a -> m b) -> m b. Since we are writing a monad instance for m = Either x (I renamed the var to avoid collision) the type is Either x a -> (a -> Either x b) -> Either x b
13:54:12 <monoidal> dmj`: that's all what takes - we substitute the same type everywhere
13:54:18 <carter> monoidal: thankfully… I really only care about having show, i don't think i care about read
13:54:50 <Jesin> dmj`: I think you got the reason pretty much right...  monoidal, do you agree?
13:55:38 <Jesin> :t asAppliedTo
13:55:42 <lambdabot> (a -> b) -> a -> a -> b
13:55:56 <carter> i think i should do the horrid fromList approach :)
13:56:17 <Jesin> :t (>>=) `asAppliedTo` (Right "")
13:56:18 <lambdabot> Either a [Char] -> ([Char] -> Either a b) -> Either a b
13:56:30 <Jesin> :t (>>=) `asAppliedTo` (Left "")
13:56:31 <lambdabot> Either [Char] a -> (a -> Either [Char] b) -> Either [Char] b
13:56:50 <Jesin> :t (>>=) `asAppliedTo` (Right undefined)
13:56:51 <lambdabot> Either a1 a -> (a -> Either a1 b) -> Either a1 b
13:57:32 <Jesin> carter: what's the fromList approach?
13:58:28 <carter> Jesin: many haskell data structures have a read instance that essentially first parses the stuff in as a list
13:58:31 <dmj`> monoidal: Left x >>= _ = Left x, if we were to try to define it as Left x >>= f = f x, we would hit a type error, yet with Right, the definition is f x. This is due to the type system, since we are specifying Monad (Either a), the a corresponds to the type of the Left parameter. So is the reason why are getting a type error because the 'a' has been specified, or because the type of f is f :: b -> Either b, or both?
13:58:39 <carter> then turns it into whatever data structure it really is
13:59:38 <monoidal> dmj`: what you are saying is somewhat right, but I prefer to explain it the way I did earlier - take type of >>= and substitute Either x in place of m
13:59:52 <monoidal> we get Either x a -> (a -> Either x b) -> Either x b
13:59:52 <quchen> Speaking of the Either issue, is there a way of making a Left-based Either instance using some new extensions, or is that still off limits?
13:59:54 <jfischoff> My hackage mirror is failing when it tries to get http://hackage.haskell.org/packages/archive/log, what's the new location of the log?
14:00:06 <carter> jfischoff: ask on #hackage?
14:00:07 <monoidal> quchen: it's off-limits afaik
14:00:26 <carter> quchen: eh?
14:00:42 <Jesin> quchen: what do you mean "Left-based Either instance"?
14:00:45 <monoidal> dmj`: and that type means we cannot apply f to x if x comes from Left x
14:01:05 <quchen> carter, Jesin: fmap f (Left x) = Left (f x); fmap _ r = r
14:01:16 <quchen> The other way round, basically. Swapping Left with Right
14:01:33 <monoidal> dmj`: trivia question: what's the difference between Left x >>= _ = Left x and a@(Left x) >>= _ = a?
14:02:02 <quchen> One of them is nicer to read? :-s
14:02:13 <bss03> quchen: You could make a Monad instance for Flip Either.  type Flip f a b = f b a
14:02:13 <quchen> Sharing?
14:02:21 <quchen> bss03: Sure, but Flip Either isn't Either.
14:02:22 <monoidal> quchen: no, both answers are wrong
14:02:48 <carter> quchen: whats the motivation for it?
14:02:50 <quchen> Hm. I'll take that third chance.
14:03:12 <Jesin> quchen: um.  You'd have to use {-# LANGUAGE NoImplicitPrelude #-}, because what you're proposing contradicts the standard.
14:03:14 <quchen> carter: Well it basically requires a type-level lambda, which can be practical.
14:03:25 <carter> whats the motivation?
14:03:44 <carter> Jesin: somehow i thought you were new to haskell yesterday, my mistake!
14:04:15 <quchen> Jesin: You wouldn't be able to do it for `data Either' a b = Left' a | Right' b` either.
14:04:17 <Jesin> carter: why do you want a Left-based Either?
14:04:55 <hpc> monoidal: behavior wrt bottom?
14:04:58 <monoidal> hpc: no
14:05:03 <Jesin> quchen: right, that's because type constructors are curried
14:05:11 <dmj`> monoidal: you're using a stale data constructor, its a wholly different type, from a new instance of Left x
14:05:16 <coreyoconnor> acowley: the failure is the message "ErrorClosed" in handle_failed_request
14:05:19 <quchen> Jesin: Yes.
14:05:30 <quchen> Jesin: Hence my question whether one can work around that.
14:05:42 <Jesin> quchen: "work around that" toward what goal?
14:06:00 <monoidal> dmj`: do you see the consequence of this fact?
14:06:04 <coreyoconnor> I'm not sure where the ErrorClosed is being produced.
14:06:20 <quchen> Jesin:  "instance Functor (/\a. Either a b) where"
14:06:25 <monoidal> Left x >>= _ = Left x typechecks.
14:06:30 <monoidal> a@(Left x) >>= _ = a does not.
14:06:38 <quchen> monoidal: Oh?
14:06:39 <coreyoconnor> I presume it means that the socket has been closed before the read could complete
14:07:06 <hpc> oooh wow
14:07:11 <hpc> i should have caught that...
14:07:15 <quchen> monoidal: Aaah I get it. Funny how I stumbled upon that yesterday and didn't recognize it.
14:07:22 <quchen> hpc: Blindness high five? :-)
14:08:03 <Jesin> monoidal: nice example
14:08:05 <hpc> those damn phantom types
14:08:27 <Jesin> quchen: as bss03 said, you can define "type Flip f a b = f b a"
14:08:56 <Jesin> quchen: this is basically equivalent to your type-level lambda approach, except that it takes up another identifier.
14:09:01 <quchen> That doesn't solve the problem, which is that type constructors have to be curried the right amount.
14:09:24 <Jesin> quchen: doesn't it?
14:09:30 <monoidal> dmj`: in Left x >>= _ = Left x, the "Left x" are two values of different types Either e a and Either e b, while in a@(Left x) >>= _ = a we force them to be the same value, but this does not typecheck.
14:10:11 <Jesin> well maybe you'd need to use newtype...
14:11:23 <quchen> If you use a newtype you have FlipEither, which is not Either anymore.
14:11:32 <quchen> Isomorphic of course.
14:11:45 <Jesin> quchen: well of course it's not Either
14:11:58 <Jesin> quchen: Either already has a Monad instance
14:12:02 <quchen> ....
14:12:09 <quchen> Then take Either'
14:12:55 <Jesin> quchen: okay... what's wrong with it being a different type?
14:13:50 <quchen> Although there are two valid Functor instances for the Either type (primes are implicit from now on), you can only express one in Haskell's type system.
14:13:53 <hpc> Jesin: so let's make a flipped Either'
14:13:57 <Jesin> quchen: if it's the boilerplate code for getting other instances, you can use {-# LANGUAGE NewtypeDeriving #-}
14:14:24 <hpc> data FlippedEither a b = FlippedRight a | FlippedLeft b
14:14:39 <hpc> but oh wait, that's just Either with the constructors renamed
14:15:05 <Jesin> hpc: it has a different default Enum though  :p
14:15:12 <hpc> no it doesn't
14:15:18 <Jesin> wait
14:15:21 <hpc> ;)
14:15:32 <Jesin> there's no such thing as instance Enum (Either ...)
14:15:36 <Jesin> derp
14:15:43 <Ghoul_> is it possible to use streaming lazy functions in a multithreaded environment
14:15:44 <Jesin> anyway yeah
14:15:45 <hpc> you can define an enum instance just fine
14:16:01 <Ghoul_> like, have some thing streaming work from a lazy function and some other thread consuming it
14:16:11 <hpc> (well, not "just fine", but you can)
14:16:12 <Ghoul_> (sounds more appropriate for pipes-async I guess...)
14:16:29 <lpaste> carter revised “can't derive eq  read show”: “No title” at http://lpaste.net/94290
14:16:40 <quchen> Ghoul_: Isn't that like a normal pipe? Put things in, get things out?
14:16:59 <quchen> There are parallel pipes that carry that idea over to the pipes universe
14:17:04 <Ghoul_> yes, but I want both sides to be parallel
14:17:09 <Jesin> quchen: what exactly is the difference?  I mean, I suppose the Functor typeclass does not allow for fully general Functors?
14:18:52 <quchen> Both Functor instances are fully general Functors. It's just that sometimes you don't have the argument you want to use for the Functor is in the last place.
14:19:41 <quchen> Basically you're always forced to use your types point-free (at least for the arguments you want to use in the class).
14:19:57 <quchen> That's like if "sort" required you to always use a point-free `comparing` function.
14:20:16 <quchen> Which is sometimes inconvenient. Not so much for types, but still.
14:20:41 <Jesin> quchen: it's... not really
14:21:11 <Jesin> that is, it's not like if sortBy required a point-free comparison function
14:21:55 <Jesin> quchen: also this looks relevant: http://hackage.haskell.org/package/categories/docs/Control-Category-Dual.html
14:22:43 <Jesin> also http://hackage.haskell.org/package/categories/docs/Control-Category-Functor.html
14:22:51 <Jesin> gives a more general definition of Functor
14:26:52 <carter> http://hackage.haskell.org/package/categories-1.0.6/docs/Control-Categorical-Functor.html  ?
14:27:20 <quchen> That defines a Functor between Categories.
14:27:25 <quchen> And it's probably unrelated.
14:28:42 <Jesin> quchen: it kind of is.  Also, I don't think there's any data-level analogue of a typeclass.
14:29:06 <quchen> Well then I don't see it.
14:29:33 --- mode: ChanServ set +o johnw
14:29:37 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | GHC on mac: http://tinyurl.com/n74yuhz |Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://www.haskell.org/pipermail/haskell-cafe/2013-September/110320.html' by johnw
14:29:43 --- mode: johnw set -o johnw
14:30:34 * quchen just looked up what XCode is and is confused how an IDE can break GHC.
14:30:40 <dmj`> monoidal: If the type we need is Either x a -> (a -> Either x b) -> Either x b, and l@(Left x) >>= _ = l, doesn't change the type of x, why wouldn't it typechec
14:30:44 <quchen> Dependency hell?
14:30:45 <johnw> installing it changes the system compiler
14:30:47 <cschneid> quchen: it's the backing C compiler it stomps on.
14:30:50 <quchen> Ah.
14:30:57 <monoidal> dmj`: left is Either x a, right is Either x b
14:30:59 <cschneid> xcode is the whole dev toolchain for osx
14:31:05 <quchen> And you can't not do that because Apple?
14:31:11 <quchen> Like local installs etc?
14:31:33 <dmj`> the type of x in Left x, isn't changing though.
14:31:44 <cschneid> quchen: nah, not built for that afaik. You can build your own gcc and friends if you want, but that's just like on a unixy system.  Manual or you find a package manager.
14:31:48 <monoidal> dmj`: so you can't use "l" to denote both a value of type Either x a and of Either x b
14:32:05 <monoidal> johnw: fwiw imo it's good to use url shortener for the last link
14:32:15 <dmj`> oh, is this sort of a phantom type?
14:32:24 <dmj`> monoidal: ^
14:32:24 <mm_freak_> sqdfsq: looked at your code…  does it work?
14:32:24 <johnw> people in the past have complained when I used URL shorteners in the topic
14:32:24 <johnw> I agree with you
14:32:40 <sqdfsq> yes
14:32:54 <monoidal> johnw: but the link is twice there! one with link shortener, and the other with not
14:32:58 --- mode: ChanServ set +o johnw
14:33:02 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | GHC on mac: http://tinyurl.com/n74yuhz |Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://j.mp/GOh7za' by johnw
14:33:03 <quchen> (Maybe we should have our own haskell.org shortener?)
14:33:05 --- mode: johnw set -o johnw
14:33:25 <johnw> i don't see the link twice there
14:33:30 <sqdfsq> mm_freak_, it should run with "playGame M.empty events"
14:33:31 <johnw> oh, I see
14:33:33 --- mode: ChanServ set +o johnw
14:33:40 <mm_freak_> sqdfsq: i expect it to work, but haven't tried…  in any case, it's fine as a first solution
14:33:48 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://j.mp/GOh7za' by johnw
14:33:53 --- mode: johnw set -o johnw
14:33:56 <sqdfsq> I was looking at insertWith
14:33:57 <johnw> thanks for pointing that out
14:34:06 <mm_freak_> sqdfsq: next step:  define the "zero player" and the "add players"
14:34:12 <mm_freak_> sqdfsq: zeroPlayer :: Player
14:34:18 <dmj`> monoidal: it *is* a phantom type issue
14:34:21 <mm_freak_> sqdfsq: addPlayers :: Player -> Player -> Player
14:35:08 <monoidal> dmj`: yes (I don't completely like it calling phantom type, since it is used, in the other constructor. but the problem is with the unused type variable.)
14:35:40 <sqdfsq> mm_freak_, I was looking at your insertWith suggestion, but I didn't know how to update just one field of a player
14:35:43 <dmj`> monoidal: the 'b' in this case correct?
14:35:56 <mm_freak_> sqdfsq: you don't…  you write an "addition" function for players
14:35:59 <sqdfsq> mm_freak_, what should zeroPlayer & addplayer do?
14:36:04 <monoidal> dmj`: I don't understand the q
14:36:16 <mm_freak_> sqdfsq: let's use a simpler example…  write a program that counts character occurrences in a string
14:36:17 <sqdfsq> oh
14:36:25 <mm_freak_> sqdfsq: countChars :: String -> Map Char Int
14:36:35 <sqdfsq> player 0 0 1 0 + player 0 2 0 0 = player 0 2 1 0?
14:36:40 <mm_freak_> yeah
14:36:46 <bss03> :t Data.Map.adjust
14:36:47 <lambdabot> Ord k => (a -> a) -> k -> M.Map k a -> M.Map k a
14:36:53 <mm_freak_> sqdfsq: write the character counter…  it will help
14:36:59 <sqdfsq> ok
14:37:04 <mm_freak_> sqdfsq: do not use M.lookup
14:37:12 <mm_freak_> write it using only M.empty and M.insertWith
14:37:20 <mm_freak_> (or alternatively using M.singleton and M.unionWith)
14:37:23 <bss03> :t Data.Map.unionsWith
14:37:24 <lambdabot> Ord k => (a -> a -> a) -> [M.Map k a] -> M.Map k a
14:37:32 <monoidal> dmj`: on the left side, we need Left x which has type Either x a, on the right Left x which has type Either x b
14:37:41 <sqdfsq> mm_freak_, allright, I'll do that
14:37:54 <sqdfsq> tomorrow
14:38:08 <sqdfsq> thanks for all the advice
14:38:17 <mm_freak_> sqdfsq: hint:  write a helper function of this type:  addCounts :: String -> Map Char Int -> Map Char Int
14:38:21 <mm_freak_> you're welcome
14:39:19 <mm_freak_> sqdfsq: btw, i'm leading you slowly towards understanding monoids =)
14:39:26 <bss03> sqdfsq: countChars = M.unionsWith (+) . map (flip M.singleton 1)
14:39:35 <mm_freak_> sqdfsq: Player is really a monoid
14:39:57 <mm_freak_> and with M.insertWith you write the corresponding monoid morphism from Player to Map Name Player
14:40:36 <mm_freak_> bss03: you're not helping!
14:40:43 <sqdfsq> mm_freak_, It's great that you're helping me this way. I've started learning haskell a couple of times, but this time I'm really determined
14:41:51 <mm_freak_> sqdfsq: since the solution has been spoiled, i forbid you to use M.unionWith/M.unionsWith ;)
14:42:18 <sqdfsq> hehe :)
14:42:20 <sqdfsq> anyway
14:42:22 <sqdfsq> tomorrow..
14:42:29 <mm_freak_> sure
14:42:33 <sqdfsq> bye
14:44:12 <bss03> Learning monoids?
14:44:51 <bss03> countChars = M.map getSum . mconcat . map (flip M.singleton $ Sum 1)
14:44:52 <blorbab> mm_freak_: hey.. i tried your layout and still have duplicate compilations.
14:45:24 <mm_freak_> guys, i understand that knowing an elegant solution is cool and everything…  but when someone poses an exercise for a haskell beginner, it's not only unhelpful but rude to spoil the answer…  it destroys the first person's efforts
14:46:21 <mm_freak_> blorbab: is it on hub.darcs.net?
14:48:52 <blorbab> mm_freak_: yes, it's at: http://hub.darcs.net/blorbab/cabal-test
14:49:09 <blorbab> mm_freak_: sorry, my nick was random earlier
14:49:26 <mm_freak_> blorbab: use hs-source-dirs
14:49:32 <mm_freak_> not main-is with a subdirectory
14:50:27 <mm_freak_> hs-source-dirs: foo
14:50:30 <mm_freak_> main-is: Foo.hs
14:50:56 <pqmodn> bss03: mconcat on Map won't add the Sum values. you have to use M.unionsWith mappend
14:51:46 <bss03> pqmodn: :(  Disappointing, that.  But I guess that's the cost for being a Monoid even if the value type is not.
14:52:45 <pqmodn> yeah :\
14:56:17 <monoidal> i hope that in future we will change the instance to Monoid v => Monoid (Map k v)
14:56:51 <carter> ugh, is there any way get TH to work on the right hand sides of type synonyms? ?
14:56:54 <monoidal> you will be able to recover the old behavior by fmap First - currently this takes linear time, but with newtype coercions it might be O(1)
14:57:08 <monoidal> carter: use head
14:57:13 <mm_freak_> monoidal: i agree…  that would be very useful
14:57:23 <carter> monoidal: yeah… thats really what it comes down to i guess
14:58:25 <mm_freak_> is the current Monoid instance really first-biased?
14:58:34 <monoidal> i think so
14:58:37 <mm_freak_> > M.singleton 'a' 'x' <> M.singleton 'a' 'y'
14:58:38 <lambdabot>   fromList [('a','x')]
14:58:42 <mm_freak_> indeed
14:59:51 <monoidal> (and btw the new behavior of monoid for maps will match the monoid instance for r -> a)
15:00:04 <mm_freak_> yeah
15:00:54 <mm_freak_> but this discussion won't change anything…  i'm happy to write the patch
15:00:58 <clahey> first biased?
15:01:08 <carter> left vs right biased?
15:01:32 <clahey> Isn't Monoid defined as requiring associative?
15:01:36 <monoidal> it is
15:01:46 <carter> yes
15:01:51 <clahey> So left vs. right doesn't matter except for efficiency, right?
15:01:52 <carter> thats not saying its commutative :)
15:01:58 <bss03> ++carter
15:02:05 <mm_freak_> clahey: that's commutativity
15:02:14 <carter> the left / right biased monoids are non commutative
15:02:18 <mm_freak_> x <> y = y <> x  -- commutative
15:02:25 <clahey> I misunderstood first biased then.
15:02:29 <monoidal> if we pick 1st argument, (x <> y) <> z and x <> (y <> z) both give x
15:02:30 <dmj`> monoidal: So, when using instances, the class being instanced must be fully-applied and in a sense concrete, which would yield a Constraint. All instances must be fully-applied classes, but a concrete (fully-applied) class yields a constraint. A fully applied type-constructor yields *, a value
15:02:31 <mm_freak_> x <> (y <> z) = (x <> y) <> z  -- associative
15:02:44 <monoidal> of course, care must be taken with mempty <> x = x
15:02:45 <Eduard_Munteanu> Hm, why is there no singleton type for type-level lists?
15:02:53 <mm_freak_> clahey: most interesting monoids are not commutative =)
15:03:06 <clahey> I know commutative vs. associative.  I just must have misunderstood first biased.
15:03:38 <Eduard_Munteanu> http://hackage.haskell.org/package/base-4.6.0.1/docs/GHC-TypeLits.html
15:03:39 <bss03> Eduard_Munteanu: I think they are adding that as an extension in 7.8.
15:03:47 <clahey> I assumed it was something to do with the definition of x <> y <> z.
15:03:48 <monoidal> dmj`: yes. In other words, if you write "instance (something) => X", then X must have kind Constraint, and if you write "something :: X", then X must have kind *
15:03:56 <carter> Eduard_Munteanu: becaue it hasn't been written yet
15:03:57 <Eduard_Munteanu> bss03: hm, so I can't define it myself?
15:04:04 <jfischoff> Eduard_Munteanu: more reason to just use 'singletons' fancy syntaxed be damned!
15:04:07 <carter> its easy to write your own reflection class
15:04:16 <mm_freak_> dmj`: Monad :: (* -> *) -> Constraint
15:04:18 <bss03> Eduard_Munteanu: Nah, you can already write it yourself.
15:04:43 <mm_freak_> dmj`: didn't quite understand what you were saying, but the Monad class might be interesting regardless =)
15:04:46 <jfischoff> Eduard_Munteanu: you can probably write the code of singletons almost verbatim
15:04:47 <blorbab> mm_freak_: i'm not sure you're doing the same thing as me here: http://hub.darcs.net/ertes/config/browse/skel
15:04:59 <mm_freak_> dmj`: with PolyKinds you also get polymorphically kinded classes
15:05:00 <dmj`> mm_freak_: Which part didn't make sense
15:05:14 <bss03> Eduard_Munteanu: Hasochism talk at ICFP covered 4 (or 5) things to get type-level ints that are pretty good.
15:05:17 <Eduard_Munteanu> jfischoff: AFAICT you can't write it for string/natural literals
15:05:36 <monoidal> dmj`: I think what mm_freak_ was saying is that parameters to constraints need not be fully applied types - e.g. you can have instance Monad Maybe, where Maybe is not applied to an argument
15:05:42 <carter> jfischoff: yeah, the builtins have black magics
15:05:46 <mm_freak_> blorbab: i am, basically
15:05:58 <Eduard_Munteanu> I mean, those aren't even inductively defined I think.
15:06:31 <jfischoff> you can still make your own Sing instances of other things.
15:06:35 <mm_freak_> dmj`: if you could ask for the kind of (=>) it would give you something like this:  Constraint -> * -> *
15:06:35 <dmj`> yes, Maybe :: * -> *, applied to Monad :: (* -> *) -> Constraint, produce Constraint and produce a valid instance. Even though maybe is not fully applied, but Monad is.
15:06:40 <mm_freak_> :k (=>)
15:06:41 <lambdabot> parse error on input `=>'
15:06:44 <monoidal> dmj`: that's right
15:06:47 <blorbab> mm_freak_: but your main programs don't import modules at the top level...
15:06:55 <mm_freak_> unfortunately (=>) is still special
15:06:58 * Eduard_Munteanu is planning to use singleton types to mark functions / larger blocks of code with a label for logging.
15:06:59 <mm_freak_> blorbab: they could
15:07:07 <mm_freak_> blorbab: what you're looking at is just a project template
15:07:08 <monoidal> in some sense, (=>) has kind Constraint -> * -> *
15:07:29 <hpc> i really don't want to imagine what alternate positionings of (=>) will look like
15:07:48 <mm_freak_> blorbab: http://hub.darcs.net/ertes/netwire/browse/netwire.cabal
15:08:06 <monoidal> hpc: I think there's some place for first-class (=>)
15:08:42 <hpc> definitely, but making it first-class involves thinking about everything
15:08:48 <mm_freak_> dmj`: (=>) isn't really much different from (->), except that its first argument has to be a concrete Constraint
15:08:51 <Eduard_Munteanu> Sure, just make classes first-class (no pun intended) like in Agda. :)
15:09:13 <mm_freak_> dmj`: (=>) is not that special
15:09:42 <Eduard_Munteanu> I.e. just a record type, perhaps at type-level.
15:09:56 <mm_freak_> > (flip shiftL :: Int -> Bits a => a -> a) 1 10
15:09:57 <lambdabot>   20
15:10:00 <dmj`> monoidal: Fully applied types give you kind :: *, which is what we call concrete, can that jargon be used when talking about classes, like Monad. Would we say, Monad Maybe, is fully-applied?
15:10:14 <dmj`> :k Monad Maybe
15:10:16 <lambdabot> Constraint
15:10:22 <dmj`> :k Maybe Int
15:10:23 <lambdabot> *
15:10:31 <monoidal> dmj`: I don't think many people use this terminology, but it makes some kind of sense.
15:10:33 <dmj`> Do we call both "concrete"?
15:10:46 <monoidal> dmj`: I would use "concrete" only to *
15:10:52 <Eduard_Munteanu> "Concrete" constraints perhaps.
15:11:05 <mm_freak_> > (flip shiftL :: (->) Int ((=>) (Bits a) ((->) a a)) 1 10
15:11:06 <lambdabot>   <hint>:1:28: parse error on input `=>'
15:11:13 <mm_freak_> that's where it becomes special
15:11:25 <bss03> monoidial: Hrm, I would think concrete would apply to any named kind as well as *
15:11:33 <monoidal> mm_freak_: (regarding 1st class =>, I think with values there's no problem, but parsing e.g. instance Ord a => Ord [a] might get problematic.)
15:12:16 <bss03> monodial: Since if I have Two :: Nat, and S (S Z) :: Two, then we have a value whose type is of a named kind.
15:12:20 <monoidal> bss03: a "concrete" type usually does not refer to e.g. Maybe. however, this terminology is not widely accepted imo
15:12:39 <monoidal> bss03: you can't have this in GHC
15:12:47 <mm_freak_> monoidal: well, it would look something like this:  forall a. (Ord a) => instance Ord [a]
15:12:48 <Eduard_Munteanu> I wonder... if you use DataKinds you can pretty much define type-level record types. If you could do that for GADTs, and GHC had implicit-from-scope parameters, that would be enough to implement first-class typeclasses, no?
15:12:50 <bss03> bss03: Yeah, "concrete" types have value, Maybe doesn't have values, it is a type contrustor.
15:12:54 <mm_freak_> monoidal: in a way that would make more sense anyway
15:13:01 <bss03> DataKinds
15:13:08 <mm_freak_> bss03: something is concrete, when it's not a function
15:13:18 <mm_freak_> concrete: *, not concrete: * -> *
15:13:25 <mm_freak_> concrete: Constraint, not concrete: * -> Constraint
15:13:36 <bss03> concreate: Nat, not concreate * -> Nat -> *
15:13:59 <carter> Eduard_Munteanu: so you mean passing reifed dictionaries around?
15:14:03 <carter> don't we kinda have that right now?
15:14:08 <Eduard_Munteanu> You might want to say constraints aren't types.
15:14:17 <carter> eh?
15:14:17 <mm_freak_> carter: see the 'reflection' package
15:14:20 <carter> mm_freak_: yup
15:14:22 <carter> i'm using it :)
15:14:30 <carter> well
15:14:30 <carter> about to
15:14:32 <mm_freak_> then i don't understand your question =)
15:14:45 <monoidal> mm_freak_: that syntax seems weird to me. [note that normally we write instance forall a. Ord a => Ord [a] ...
15:14:48 <carter> mm_freak_: maybe i meant to be rhetorical
15:15:14 <monoidal> mm_freak_: in other words, in data/newtype/type/type family etc. the first token determines the kind of the declaration
15:15:14 <Eduard_Munteanu> carter: what sort of reified dictionaries? You can certainly use GADTs to implement typeclasses minus instance resolution.
15:15:28 <carter> i'm pretty sure i've seen it done
15:15:36 <carter> don't recall teh examples
15:15:44 <mm_freak_> monoidal: well, whenever we write an instance with a context we're really writing an instance without a context, which gets type-checked with the context
15:15:47 <alpounet> carter, isn't "constraints" about passing reified dictionnaires around ?
15:15:54 <carter> you might be right
15:15:57 <carter> i'll have to look
15:15:57 <mm_freak_> monoidal: that's why this doesn't work:  instance (Monad m) => Applicative m
15:16:04 <carter> @hackage constraints
15:16:04 <lambdabot> http://hackage.haskell.org/package/constraints
15:16:07 <carter> @hackage singletons
15:16:07 <lambdabot> http://hackage.haskell.org/package/singletons
15:16:11 <alpounet> yet another edwardk package, you know :)
15:16:12 <mm_freak_> monoidal: so we might as well put the forall outside
15:16:32 <monoidal> dmj`: people above have different opinions regarding whether types of kind Constraint and Nat should be called concrete. anyway, I still think it's not a strongly established notion.
15:16:46 <Eduard_Munteanu> carter: Agda has a rather neat idea of "typeclasses": you just mark a parameter with {{ }} in the type, and if there's a single value of that type in scope, it picks it automatically. :)
15:16:50 <jfischoff> yes constraints is about capture constraints
15:17:00 <carter> Eduard_Munteanu: yeah
15:17:07 <carter> dependent types let cool things happen
15:17:08 <monoidal> mm_freak_: but this does not seem to be worth making a special exception in the syntax. plus, it is imaginable that we would extend the solver to support backtracking
15:17:17 <jfischoff> and singletons is difficult to use without it
15:17:27 <monoidal> mm_freak_: such choices should not be tied by giving such syntax imo
15:17:44 <mm_freak_> monoidal: your point was about first-class (=>) and the problems that would follow it
15:17:46 <blorbab> mm_freak_: ok, that example helped a lot.. the missing pieces: library section needs to expose the modules in question, and executable section needs build-depends to reference the current package
15:17:53 <blorbab> mm_freak_: thanks!
15:17:57 <mm_freak_> monoidal: my alternate syntax is an attempt to provide a solution
15:18:13 <monoidal> mm_freak_: I agree on this, but I think this solution is bad.
15:18:33 <lykos> How would I add time-delay between displaying a text string? I'm planning on just using the gloss game/simulation module, but I'm curious how this would best be done?
15:18:57 <monoidal> mm_freak_: if we have a first-class implication Constraint -> Constraint -> Constraint, it would be different, but that raises a lot of inference questions
15:19:03 <mm_freak_> blorbab: you're welcome…  note also that you need to tell cabal about any extra modules your executables use, otherwise you will end up with an incomplete package, if you ever use cabal sdist
15:19:18 <Eduard_Munteanu> lykos: you want to delay printing something, but not slow down the rest?
15:19:22 <monoidal> mm_freak_: I have no issues with (=>) :: Constraint -> * -> * partially applied
15:19:27 <mm_freak_> monoidal: i'm not even sure what a clean solution would look like
15:19:56 <mm_freak_> monoidal: i guess the more we first-classify things, the more we will move away from type classes into something similar to agda's {{ }}-style implicits
15:20:12 <lykos> Eduard_Munteanu: Well, I just meant an over-all pause, but what you said would be better.
15:20:17 <monoidal> that's also possible.
15:20:18 <mm_freak_> the other option would be to have two (=>)
15:20:33 <mm_freak_> one special (for declarations), one first class (for type signatures)
15:20:40 <Eduard_Munteanu> lykos: just spawn a thread and print-delay-print from it then?
15:21:23 <monoidal> mm_freak_: or: infix => is special, and (=>) is first-class. currently this is with (->) with regards to unboxed types
15:21:40 <monoidal> mm_freak_: you can write Int# -> Int but not (->) Int# Int
15:21:42 <lykos> Eduard_Munteanu: Okay, I just wasn't sure how that played with Haskell's implicit threading?
15:21:44 <Eduard_Munteanu> mm_freak_: {{ }} seems to work fine there, but I'm unsure how you'd implement stuff like functional dependencies
15:21:48 <mm_freak_> monoidal: i'd prefer not to give up more uniformity
15:22:11 <vraid> so apparently the name haskell means 'sacrificial cauldron of the gods'
15:22:16 <mm_freak_> Eduard_Munteanu: you wouldn't…  {{ }} implicits would simply require only one instance to be in scope
15:22:17 <Eduard_Munteanu> lykos: if you mean things like 'par' those are only useful for computations, pure expressions.
15:22:20 <monoidal> mm_freak_: the solution with two => is definitely better longterm, but it's doubtful it will ever be done considering backwards compat
15:22:39 <mm_freak_> monoidal: i'm also not sure where that would be useful =)
15:23:17 <Eduard_Munteanu> lykos: if you want to actually *do* something in the IO sense in a parallel fashion, you have to do it explicitly.
15:23:38 <lykos> Eduard_Munteanu: Okay, thanks.
15:24:07 <blorbab> mm_freak_: extra as in, external?
15:24:08 <mm_freak_> lykos: if you want the pause to be precisely timed, you can use a second thread that periodically puts a () into an MVar
15:24:13 <Jesin> > exp . recip . (^2)
15:24:15 <lambdabot>   <Double -> Double>
15:24:24 <mm_freak_> blorbab: extra-modules
15:24:30 <mm_freak_> blorbab: see the cabal documentation
15:24:40 <blorbab> mm_freak_: ok.
15:24:43 <Ghoul_> [z | z = x^2, x <- [1..], z < 300]
15:24:45 <Ghoul_> > [z | z = x^2, x <- [1..], z < 300]
15:24:46 <mm_freak_> blorbab: http://www.haskell.org/cabal/users-guide/developing-packages.html
15:24:46 <lambdabot>   <hint>:1:8: parse error on input `='
15:25:20 <lykos> mm_freak: Okay. I'm just going to use the gloss module for now, but I want to play around with multi-threading eventually.
15:26:13 <lykos> > [ x^2  |x <- [1..], z < 300]
15:26:14 <Jesin> Ghoul_: I'd write that as
15:26:20 <lambdabot>   mueval-core: Time limit exceeded
15:26:21 <mm_freak_> lykos: as always, i recommend The Book =)
15:26:27 <lykos> :t [x^2 | x <- [1..], z < 300]
15:26:28 <lambdabot> (Enum t, Num t) => [t]
15:26:36 <lykos> :t [x^2 | x <- [1..], x < 300]*
15:26:37 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
15:26:55 <Ghoul_> uh, I want the x^2 part to be < 300
15:26:57 <Ghoul_> how do I do that
15:26:59 <Jesin> > filter (300 >) $ fmap (^ 2) [1..]
15:27:01 <mm_freak_> http://chimera.labs.oreilly.com/books/1230000000929
15:27:05 <lykos> :t [x^2 | x <- [1..], x^2 < 300]*
15:27:06 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
15:27:06 <lambdabot>   mueval-core: Time limit exceeded
15:27:23 <Jesin> :t [x^2 | x <- [1..], x^2 < 300]
15:27:24 <lambdabot> (Enum t, Num t, Ord t) => [t]
15:27:28 <Ghoul_> > [let y = x^2 | x <- [1..], y < 300]
15:27:29 <lambdabot>   <hint>:1:14: parse error on input `|'
15:27:31 <lykos> mm_freak: Which book?
15:27:40 <Jesin> :t filter (300 >) $ fmap (^ 2) [1..]
15:27:41 <lambdabot> (Enum a, Num a, Ord a) => [a]
15:27:50 <Ghoul_> > [y | x <- [1..], let y = x^2, y < 300]
15:27:55 <Jesin> Ghoul_: I'd recommend using filter
15:27:57 <mm_freak_> @ lykos
15:27:58 <lambdabot>   mueval-core: Time limit exceeded
15:28:02 <monoidal> Ghoul_: takeWhile?
15:28:03 <Ghoul_> success! I think
15:28:08 <mm_freak_> uh
15:28:10 <Jesin> Ghoul_: nope
15:28:13 <Ghoul_> Uh, a friend asked, 'tis all.
15:28:46 <Jesin> Ghoul_: you can't precompute stuff like that in list-comprehension notation, which is perfectly fine, because "filter" is just as readable
15:28:55 <mm_freak_> Don't Leave 13 Seconds After Asking A Question.
15:29:00 <Jesin> Ghoul_: filter (300 >) $ map (^ 2) [1..]
15:29:24 <Ghoul_> well, I know you can do that
15:29:25 <Jesin> Ghoul_: alternately: filter (300 >) [ x^2 | x <- [1..] ]
15:29:28 <Ghoul_> thanks.
15:30:21 <ReinH> > takeWhile (<300) . fmap (^2) $ [1..]
15:30:22 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289]
15:30:31 <monoidal> Ghoul_: ^
15:30:46 <monoidal> Ghoul_: note the difference between filter and takeWhile
15:30:47 <Jesin> Ghoul_: oh, use takeWhile
15:30:49 <ReinH> you can use takeWhile because (^2) is monotonic
15:31:12 <blorbab> mm_freak_: got it, i think. thanks!
15:31:42 <Ghoul_> > [y | x <- [1..], let y = x^2, y < 300]
15:31:46 <Jesin> Ghoul_: if you use takeWhile, it will terminate in finite time; filter will keep looking for a decrease.
15:31:49 <lambdabot>   mueval-core: Time limit exceeded
15:31:53 <Jesin> Ghoul_: no
15:31:58 <ReinH> Ghoul_: filter cannot terminate
15:32:01 <Ghoul_> I know how to do it with regular functions guys, just wanted to figure out the comprehension :P
15:32:10 <Jesin> Ghoul_: there is no comprehension for it
15:32:10 <ReinH> Ghoul_: you can't.
15:32:17 <ReinH> well, there is no comprehension that terminates
15:32:25 <Jesin> ^ that
15:32:36 <ReinH> so effectively none that you can use to solve the problem
15:32:54 <Jesin> > takeWhile (< 300) $ map (^ 2) [1..]
15:32:56 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289]
15:33:09 <monoidal> > last [y | x <- [1..], let y = x^2, y < 300]
15:33:16 <lambdabot>   mueval-core: Time limit exceeded
15:33:17 <monoidal> > last $ takeWhile (< 300) $ map (^ 2) [1..]
15:33:19 <Polarina> Would anyone like to tackle this problem I'm experiencing? http://stackoverflow.com/questions/19347907/does-data-bytestring-readfile-block-all-threads
15:33:19 <lambdabot>   289
15:34:12 <Jesin> Ghoul_: if "filter" takes an infinite list as an argument, it will always attempt to return an infinite list.  Same goes for comprehensions.
15:36:48 <mm_freak_> Polarina: first guess:  did you compile with -threaded?
15:37:09 <Polarina> mm_freak_, yes, of course. First thing I tried.
15:39:00 <Ghoul_> did you try a different optimization level
15:39:02 <Ghoul_> ie -O2
15:39:03 <mm_freak_> Polarina: how long did the read take?
15:39:28 <Polarina> mm_freak_, depends on the size of the file and the throughput on the hard disk drive. A gigabyte file takes about half a minute on my computer.
15:39:39 <Ghoul_> personally, a lot of the wierd behaviour I get from haskell is because fusion doesn't happen and something somewhere just breaks and infinite loops :/
15:39:52 <mm_freak_> Polarina: and during that half minute the other thread is paused?
15:39:59 <Polarina> mm_freak_, yes.
15:40:11 <mm_freak_> Ghoul_: fusion not happening should not change the semantics of your program
15:40:16 <alpounet> Polarina, i suppose you are not running with -N2 or more?
15:40:38 <jmcarthur_mobile> Heh
15:40:41 <Polarina> alpounet, I've tried up to -N8.
15:40:43 <mm_freak_> Polarina: my second guess is that you shouldn't use readFile, but a streaming abstraction instead, which uses proper chunking internally
15:40:50 <alpounet> Polarina, it pauses the other cores too?
15:40:57 <jmcarthur_mobile> This is actually a tricky problem Polarina has
15:40:57 <Polarina> alpounet, yes.
15:41:10 <jmcarthur_mobile> It does pause other cores. They spin wait in fact.
15:41:20 <alpounet> Polarina, with the parallel runtime? that's odd, it should pause only the capacity that runs the thread, shouldn't it?
15:41:25 <mm_freak_> spin-wait as in busy-wait?
15:41:36 <alpounet> although lazy bytestrings should solve that right?
15:41:40 <Polarina> alpounet, that's the expected behaviour.
15:41:46 <jmcarthur_mobile> As I said in my answer, I believe it is the garbage collector about to run, stalling all threads until none are busy
15:42:02 <alpounet> oh
15:42:05 <alpounet> that's quite nasty
15:42:05 <jmcarthur_mobile> The question is why
15:42:06 <mm_freak_> Polarina: what happens when you use an MVar instead of an IORef?
15:42:11 <jmcarthur_mobile> Possibly an unsafe binding but I think it may be something else
15:42:18 <Polarina> mm_freak_, I tried TVar in my test case, same behaviour.
15:42:24 <mm_freak_> the IORef is wrongly used anyway
15:42:24 <alpounet> with lazy bytestrings, is it different?
15:42:39 <alpounet> the chunking should let the other things run
15:43:10 <Polarina> alpounet, the reason I want it strict is because I want the actual IO to run in *that* thread and not do lazy IO when I use the bytestring.
15:43:11 <mm_freak_> i'm pretty sure that it's just readFile being implemented badly
15:43:19 <jmcarthur_mobile> Note that you would still have to force the whole result deeply if you switch to lazy
15:43:22 <jmcarthur_mobile> Because it uses lazy io
15:43:26 <alpounet> yeah
15:43:59 <mm_freak_> Polarina: btw, try MVar, not TVar
15:44:02 <jmcarthur_mobile> Yeah my leaning is something bad about readFile or some other function it depends on
15:44:05 <Polarina> mm_freak_, http://lpaste.net/raw/94234
15:44:08 <mm_freak_> MVar has some fairness guarantees that TVar doesn't have
15:44:11 <Polarina> mm_freak_, I'll try that, one moment.
15:44:17 <alpounet> but the successive calls should let some time for the other things to happen (gc, other caps running other threads)
15:44:40 <alpounet> it's not reading everything at once
15:45:01 <mm_freak_> Polarina: if that doesn't help, i'd look at the source code of readFile from the bytestring package
15:45:03 <alpounet> there would be moments where the cap won't be running unsafe code
15:45:31 <mm_freak_> chances are it's actually an unsafe blocking call that stalls the whole program
15:46:24 <jmcarthur_mobile> Switching to an mmap binding might be another way around the problem
15:46:33 * hackagebot hzk 0.0.1 - Haskell client library for Apache Zookeeper  http://hackage.haskell.org/package/hzk-0.0.1 (DiegoSouza)
15:46:39 <alpounet> Polarina, you should ask on ghc-dev/haskell-cafe or something, where the rts experts hang out
15:46:59 <alpounet> jmcarthur_mobile, it did help my use of JuicyPixels at some point
15:47:18 <mm_freak_> i'm not convinced that this is an RTS problem
15:48:09 <Polarina> mm_freak_, I get the same behaviour with Mvars.
15:48:38 <mm_freak_> indeed!
15:48:46 <mm_freak_> readFile is one giant hGet call
15:49:07 <Polarina> Which is a haskell function.
15:49:13 <mm_freak_> hGet itself maps to hGetBuf
15:50:12 <Ghoul_> mm_freak_: unfortunately it does, as shown in something I wrote recently which causes a very expensive computation which eventually stack overflows or an instant struct computation under -O2
15:50:19 <Ghoul_> *strict
15:50:35 <Polarina> mm_freak_, http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-IO-Handle-Text.html#hGetBuf
15:50:42 <Ghoul_> and strictness analysis is like that, but sometimes its hard to narrow down the iteractions between all the different bits and pieces you're using and see whats causing it
15:50:43 <Polarina> mm_freak_, I got no idea how that function works...
15:50:56 <Ghoul_> Polarina: is your buffer big enough?
15:51:15 <Polarina> Ghoul_, buffer?
15:51:29 <jmcarthur_mobile> Ghoul_: the buffer is allocated by readFile already
15:51:58 <jmcarthur_mobile> It's not some sort of buffer size bug. This is about the rts and syscalls, most likely
15:52:00 <Ghoul_> oh right, didn't follow the conv. I use that function manually for high performance sockets
15:52:19 <jmcarthur_mobile> Some weird binding or something
15:52:35 <Polarina> hGetBuf seems to be implemented by GHC.
15:53:08 <jmcarthur_mobile> It's not itself a primitive if that's what you mean
15:53:15 <mm_freak_> Polarina: it boils down to RawIO.read
15:53:15 <Polarina> No, it's not.
15:53:32 <mm_freak_> see GHC.IO.Device
15:53:46 <jonbho> Hi everyone, new haskeller here. I got two questions you may be able to help with. (1): What GUI toolkit is good for doing a small, sample graphical text editor? I'm thinking wxHaskell but would like to hear your thoughts. And (2): is there a way to have a variable restricted to pointing to an element in a list? If I use a regular integer I may have inconsistent state, and it seems like Haskell's type system should be able to help here
15:53:51 <mm_freak_> Polarina: so it depends on how that function is implemented for file handles
15:54:28 <Polarina> Just got to search for the instance! <search-mode>
15:54:29 <FreeFull> jonbho: For (2), you might want to look at zippers
15:55:25 <mm_freak_> Polarina: in any case that function is called initially with a huge size (the file size)
15:55:36 <mm_freak_> Polarina: it may actually block everything during its execution
15:55:40 <jmcarthur_mobile> mm_freak_: it most likely depends on the kind of file descriptor. For files in the filesystem I think I would hope for a safe FFI binding. For a socket I would hope for epoll.
15:55:48 <Eduard_Munteanu> jonbho: I think the first choice would be gtk2hs, not wxHaskell.
15:56:04 <jonbho> Freefull: thanks going to look into that
15:56:16 <mm_freak_> jmcarthur_mobile: well, i'd hope for implicit chunking, but that's not what happens in hGetBuf
15:56:28 <mm_freak_> jmcarthur_mobile: so it can only happen in the instance in question
15:56:33 <jonbho> Eduard: thanks, is gtk2hs more complete? and, will it work on Win+OSX+Linux?
15:56:55 <mm_freak_> Polarina: anyway, using a streaming abstraction will solve your problem
15:56:56 <jmcarthur_mobile> I don't think I would expect chucking if it'd a safe binding anyway
15:57:00 <Eduard_Munteanu> jonbho: yes... it should. At least Linux and Windows, but OS X should be fine too.
15:57:03 <jmcarthur_mobile> *it's
15:57:11 <jmcarthur_mobile> *chunking
15:57:26 <Polarina> mm_freak_, that may well be, but I'm very curious as to what exactly is causing this now. :-)
15:57:34 <FreeFull> Eduard_Munteanu: Weren't there problems building gtk2hs stuff in Windows and OSX?
15:57:47 <mm_freak_> i'd expect all kinds of scaling problems when using readFile =)
15:57:55 <mm_freak_> in fact your current problem doesn't even shock me
15:58:12 <Eduard_Munteanu> FreeFull: I admit I haven't been using it recently, much less on Windows.
15:58:51 <mm_freak_> Polarina: not knowing exactly, but making an educated guess:  the underlying libc's read() function is actually called with a giant buffer size
15:59:17 <mm_freak_> this stalls the GC
15:59:20 <jmcarthur_mobile> I agree with that guess
15:59:44 <jmcarthur_mobile> But my impression is that a safe binding *should* not stall the GC
15:59:59 <Polarina> Ok, but why would that stall the GC, even if the read string isn't garbage yet?
16:00:02 <alpounet> Polarina, http://lpaste.net/94294
16:00:27 <jmcarthur_mobile> Polarina: because the GC needs the thread that is blocked, apparently
16:00:31 <mm_freak_> that might have to do with the read string being a ForeignPtr
16:01:01 <mm_freak_> try it:  use hGetBuf with a regular Ptr
16:01:08 <jonbho> Eduard: thanks, will look into it.
16:01:10 <mm_freak_> it might actually work without stalling anything
16:03:12 <jonbho> FreeFull: zippers look cool, they are more like "pointers" than constrained indices… to allow "updating". Not sure I need it… but will try it. But I'm having some trouble picturing a zipper for a simple [Char]
16:03:53 <mm_freak_> jonbho: https://en.wikibooks.org/wiki/Haskell/Zippers
16:05:22 <Peaker> jonbho: a zipper for any [a] is basically (reversed list of elements "behind" ptr, list of elements "in front of" ptr
16:05:50 <jonbho> mm_freak: thanks, that looks quite instructional
16:05:59 <Peaker> the current element can be in either one, or maybe nicer to have a "Maybe a" as the current element:  ([a], Maybe a, [a])
16:06:10 <mm_freak_> data ListZipper a = ListZipper [a] a [a]
16:06:26 <mm_freak_> left-of-here, here, right-of-here
16:06:30 <Peaker> mm_freak_: what if there are no elements at all?
16:06:37 <mm_freak_> Peaker: then there is no zipper
16:06:47 <stoch> trying to install the GLFW-b package with the latest platform (ghc 7.6.3) on Windows - keep getting http://lpaste.net/94239 .  Looks like it is in the ghc trac at http://ghc.haskell.org/trac/ghc/ticket/7056 . Anyone know of a workaround until 7.8.1?
16:06:49 <jonbho> peaker: so the zipper actually contains the rest of the structure?
16:07:17 <Eduard_Munteanu> jonbho: if you want a data structure you can update, you likely want a Map.
16:07:28 <mm_freak_> jonbho: take "zipper" literally…  it's a focus on a certain point within the data structure with pointers to the rest of the structure in all directions
16:07:33 <Eduard_Munteanu> jonbho: http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map-Lazy.html
16:07:52 <Eduard_Munteanu> Reasonably fast lookup and updates, that is.
16:08:48 <mm_freak_> jonbho: for a list, it takes a certain list element and makes it the top node…  just read the article, it explains everything
16:08:53 <Peaker> jonbho: the zipper contains the structure "around" some focus, in a way that makes moving the focus to "close" positions easy, as well as modifying that which is in focus
16:09:56 <jonbho> Eduard, mm_freak_, peaker: picture this case… a text editor, which holds the text buffer (could be an array of Chars), and another variable holding the cursor position. The cursor has to be separate from the buffer (as there may be different cursors, markers, etc…). Would you be using a zipper on the buffer for all variables that point somewhere in the buffer?
16:11:35 <Peaker> jonbho: I'm not sure I'd use zippers for a text editor
16:12:04 <Eduard_Munteanu> If you're doing simultaneous updates from multiple cursors then probably not.
16:12:14 <jonbho> Using an integer is always an option… but I was trying to find a way to express the relationship between a cursor pos and the text buffer via types.
16:14:09 <Eduard_Munteanu> jonbho: you might want to use a length-indexed list (usually called a Vec), but that's rather advanced stuff.
16:14:15 <Peaker> jonbho: You could have a newtype around the integer whose name makes it clear it's a cursor, and have all the operations on the buffer require that newtype, and possibly only allow constructing the newtype with smart constructors that enforce invariants
16:14:19 <mm_freak_> jonbho: i'd totally use a zipper for text editors
16:14:27 <mm_freak_> jonbho: in fact i had a prototype somewhere
16:14:44 <Peaker> mm_freak_: would you use a linked list for the editor's data structure?
16:15:07 <Eduard_Munteanu> mm_freak_: if I understand correctly, he might want multiple foci into the text and updating one of them is problematic for the others.
16:15:09 <Peaker> I'm guessing it should probably use mutable vectors for decent/scalable performance
16:15:45 <mm_freak_> Peaker: i used Text and Control.Lens.Zipper
16:15:52 <Eduard_Munteanu> Unless your zipper is a store comonad, but that's pretty much an index.
16:15:55 <jonbho> Efficiency is not really necessary right now (I'm concerned with and researching expressiveness of code).
16:16:05 <mm_freak_> Peaker: and no, mutability will make your editor just another emacs/vim
16:16:10 <mm_freak_> i wanted something different, more flexible
16:16:32 <jonbho> Eduard: when implementing a text editor, you hold a lot of pointer into the buffer (markers, points of the latest edits for an undo queue, cursor, selection endpoints, etc…)
16:16:40 <jonbho> a lot of *pointers*
16:17:06 <mm_freak_> Eduard_Munteanu: well, you can use a lens instead of a zipper
16:17:14 <Peaker> mm_freak_: more flexible in what way?
16:17:49 <jmcarthur_mobile> I'd be fine with a Sequence
16:17:57 <jmcarthur_mobile> Fast enough, purely functional
16:18:01 <alpounet> Polarina, seen my paste?
16:18:07 <mm_freak_> Peaker: the idea was this:  a snapshot never disappears…  every change makes a new snapshot, including changing the lens
16:18:14 <Polarina> alpounet, I have.
16:18:24 <alpounet> you get the same behavior?
16:18:32 <Eduard_Munteanu> jonbho: hm... there's the option of *not* doing that, and holding the data itself. For example, instead of a pointer related to undo buffers, you could just hold the old data, even focused as it was (with a zipper).
16:18:36 <mm_freak_> Peaker: so you could look at a buffer from the point of view of a function listing, source code, a graphical tree representation, etc.
16:18:59 <jonbho> mm_freak_: the latest Visual Studio versions (since 2010) use that model internally. It definitely makes some things much simpler.
16:19:01 <mm_freak_> once you're happy with your changes, you apply and everything updates accordingly
16:19:34 <jonbho> eduard: yes, thanks, but I'm after not holding any intermediate values at all (only fundamental state).
16:19:40 <mm_freak_> it's a beautiful combination of immutable data structures, lenses, zippers and STM
16:19:48 <Peaker> mm_freak_: I don't see why those kinds of different views relate to a persistent store?
16:20:37 <mm_freak_> Peaker: well, i'd want it for the same reason xmonad uses an immutable data structure for its window set
16:21:01 <Polarina> alpounet, yes, although I worry that it's still blocking everything in the smaller reads so other threads don't get to utilize the CPU to its fullest, but I have not tested that. :)
16:21:04 <mm_freak_> mutability always makes things either much more difficult to work with or less flexible
16:21:21 <alpounet> Polarina, i think that's the case too
16:21:29 <alpounet> but at least it lets you do some other work
16:21:39 <alpounet> it requires more than one core though, which is annoying
16:21:40 <Peaker> mm_freak_: There are performance advantages, though
16:22:09 <Eduard_Munteanu> jonbho: perhaps you can record differences instead of entire states instead?
16:22:12 <Polarina> alpounet, there's going to be a FFI call there somewhere, nothing we can do about that. Just wished it wouldn't block every thread.
16:22:16 <Peaker> mm_freak_: an O(logN) penalty on the data structure size could possibly be expensive for large editing
16:22:18 <mm_freak_> Peaker: yes, from O(log n) to O(1)…  i'm happy to give that up
16:22:32 <mm_freak_> Peaker: not really
16:22:55 <alpounet> at least lazy bytestring gives a partial solution
16:23:06 <Eduard_Munteanu> jonbho: e.g. instead of deleting a line you can record that operation and apply it only to display the text
16:23:42 <mm_freak_> Peaker: when you translate O(log n) to actual machine instructions for a 4 GiB text file, you'd have to follow a small multiple of 32 branches for each edit…  hardly noticable for humans
16:23:50 <jonbho> Eduard: yes, that's it, I'll store actions or diffs or something like that… one interesting thing is that when an edit is done, all markers in the file have to be updated, so the datatype used for those (which should be the same as for the cursor) should better be related to the original buffer in a way that ensures consistency and correctness.
16:23:52 <mm_freak_> Peaker: and you don't edit 4 GiB text files every day =)
16:24:31 <jonbho> Ok folks thanks much for the help and pointers, need to go to sleep now. Will come back coming for more wisdom, thanks!
16:24:43 <Eduard_Munteanu> jonbho: arguably Haskell makes pointers, whole states and differences interchangable
16:24:43 <Peaker> mm_freak_: the tree-structure might be less compact than compact arrays, though
16:25:07 <mm_freak_> Peaker: it doesn't have to be a tree structure from the beginning…  only edits would introduce new nodes
16:25:10 <Peaker> mm_freak_: I agree the cost of making changes is negligible, I'm worried about sizes
16:25:22 <mm_freak_> Peaker: think of a Seq of Texts
16:25:28 <Peaker> mm_freak_: and you squash/compact the tree after a bunch of edits?
16:25:50 <mm_freak_> Peaker: perhaps, although i don't think that's necessary
16:26:01 <Eduard_Munteanu> Peaker: were you working on a structural editor? How's that doing recently?
16:26:17 <mm_freak_> Peaker: the structure would compact itself for related edits (like inserting a word)
16:27:15 <Peaker> Eduard_Munteanu: It's on a couple months hold because of some urgent business needs of both me and yairchu. Planning to go back full throttle at mid-November
16:27:40 <Eduard_Munteanu> I was going to tell jonbho you can just hold the data, since the GC does compaction for you if you just forget about it.
16:27:52 <Eduard_Munteanu> Nice.
16:28:19 <Eduard_Munteanu> Peaker: any link to it?
16:28:43 <Peaker> Eduard_Munteanu: https://github.com/Peaker/lamdu
16:32:17 <halvorgb> is there a floating point type analogous to Integer?
16:34:13 <halvorgb> With arbitrary precision I mean
16:34:46 <koala_man> there's Rational, depending on what you want to do with them
16:35:18 <Peaker> There's also CReal, though I think you have to tell it what precision to use
16:36:02 <halvorgb> :t sqrt
16:36:03 <lambdabot> Floating a => a -> a
16:37:58 <stolaruk> I'm learning Haskell. More than monads or anything else, Haskell's immutability has been most difficult for me. Due to immutability, does one often end up writing helper methods that make a copy of a data structure, changing one element of it as needed?
16:38:41 <Eduard_Munteanu> stolaruk: no, only naively... normally you pick a data structure that's reasonable to update in your case.
16:39:43 <Eduard_Munteanu> stolaruk: unless you mean "creating a new value" by "copying"
16:39:50 <jfischoff> stolaruk: can you show any example of what your are referring to?
16:40:34 <Iceland_jack> stolaruk: Here's an example there we have a string and make it upper case: we never modify the original value
16:40:34 <Iceland_jack> > let original = "hello!" in (original, map toUpper original)
16:40:35 <lambdabot>   ("hello!","HELLO!")
16:40:37 <stolaruk> I don't have a solid example. I'm trying to write a text adventure game. There is lots of state that can change based on the user's actions.
16:41:04 <halvorgb> if you have a type Dude = Dude { dPosition :: (Int, Int)
16:41:06 <Iceland_jack> stolaruk: You can pass the state as an argument to a function (or more advanced, use a state monad)
16:41:30 <Iceland_jack> @let data Dude = Dude { dPosition :: (Int, Int) } deriving Show
16:41:31 <lambdabot>  Defined.
16:41:36 <stolaruk> In my original question I meant to ask if one would typically write helper methods to, yes, make a new object based on an existing object, but only changing one aspect of it as necessary
16:41:39 <halvorgb> you can make a new Dude based on  dude1 like dude {dPosition = (2,2) }
16:41:51 <Eduard_Munteanu> If you're merely updating something like a list, you are creating a new value but it doesn't mean you copy it.
16:41:58 <halvorgb> typos etc. :D
16:42:15 <Iceland_jack> stolaruk: You don't have to but you can? What data structure are you thinking of modifying
16:42:36 <jmcarthur> Peaker: CReal is effectively infinite precision. you only have to tell it how many digits to spit out that the end.
16:42:36 <dmj`> newtype Snap a = Snap { unSnap :: StateT SnapState (Iteratee ByteString IO) (SnapResult a)  }
16:42:41 <dmj`> what is yesods underlying monad?
16:42:46 <dmj`> is it like snaps?
16:42:54 <stolaruk> Say I have a monster with a certain number of hit points. This is like old school D&D RPG. The player fights the monster. He hits the monster and the monster looses HP.
16:43:03 <Iceland_jack> stolaruk: Sude
16:43:04 <Iceland_jack> *sure
16:43:19 <Iceland_jack> @let data Monster = Monster { hp :: Int, name :: String }
16:43:20 <lambdabot>  Defined.
16:43:28 <stolaruk> ok
16:43:39 <Eduard_Munteanu> stolaruk: for records, lens make updating more convenient. Although record syntax is ok too for simple things.
16:43:53 <Iceland_jack> > let attack val (Monster hp name) = Monster (hp - val) name
16:43:55 <lambdabot>   not an expression: `let attack val (Monster hp name) = Monster (hp - val) n...
16:44:01 <stolaruk> Eduard_Munteanu: Ok. Lens is something I've heard about but haven't checked up on yet
16:44:01 <Iceland_jack> @let attack val (Monster hp name) = Monster (hp - val) name
16:44:03 <lambdabot>  Defined.
16:44:09 <Eduard_Munteanu> But no, if you find yourself writing a bunch of code to change one little thing, it's probably wrong.
16:44:17 <Iceland_jack> stolaruk: Don't bother with lens if you're just starting out imo
16:44:39 <Iceland_jack> But here I defined a Monster data structure and a function that take values off your HP
16:44:40 <latro`a> incidentally, how readily can GHC avoid actually copying a data structure in pure code?
16:44:54 <Iceland_jack> > let sally = Monster 50 "Sally" in attack 5 sally
16:44:56 <lambdabot>   No instance for (GHC.Show.Show L.Monster)
16:44:56 <lambdabot>    arising from a use of `M680954...
16:45:00 <jmcarthur> latro`a: why would it accidentally copy anything?
16:45:07 <Eduard_Munteanu> latro`a: it never does for small updates
16:45:08 <Iceland_jack> @let data Monster = Monster { hp :: Int, name :: String } deriving Show
16:45:08 <Iceland_jack> @let attack val (Monster hp name) = Monster (hp - val) name
16:45:09 <lambdabot>  .L.hs:151:6:
16:45:09 <lambdabot>      Multiple declarations of `Monster'
16:45:09 <lambdabot>      Declared at: .L.hs...
16:45:09 <lambdabot>  .L.hs:152:1: Warning:
16:45:10 <lambdabot>      Pattern match(es) are overlapped
16:45:11 <lambdabot>      In an equat...
16:45:12 <jmcarthur> latro`a: ghc never copies, really
16:45:14 <Iceland_jack> @undef
16:45:14 <lambdabot> Undefined.
16:45:15 <Iceland_jack> @let data Monster = Monster { hp :: Int, name :: String } deriving Show
16:45:16 <Iceland_jack> @let attack val (Monster hp name) = Monster (hp - val) name
16:45:16 <latro`a> interesting
16:45:17 <lambdabot>  Defined.
16:45:18 <lambdabot>  Defined.
16:45:20 <Iceland_jack> > let sally = Monster 50 "Sally" in attack 5 sally
16:45:24 <lambdabot>   Monster {hp = 45, name = "Sally"}
16:45:28 <jmcarthur> latro`a: you simply define new (parts of existing) data structures
16:45:33 <Eduard_Munteanu> latro`a: e.g. changing a list's head results in copying the head and the pointer to the rest of the list, not copying all of it
16:45:40 <stolaruk> Right, ok, so that makes a new monster with 5 HP less
16:45:45 <Iceland_jack> stolaruk: Yes
16:45:46 <jmcarthur> latro`a: whatever sharing is in your code, syntactically, is also shared at runtime
16:45:54 <Iceland_jack> but the ‘old’ monster is unchanged
16:46:00 <jmcarthur> latro`a: "sharing" just means "not copying"
16:46:00 <latro`a> but if you do a deep change
16:46:07 <latro`a> does it have to update the pointers all the way up?
16:46:19 <latro`a> or does it just move the deepest one and update the thing that was directly changed?
16:46:33 <jmcarthur> latro`a: it doesn't update anything. if you create a new path deep down into a structure, it will exist in memory. if you don't, it won't.
16:46:35 <Eduard_Munteanu> latro`a: depends what you mean by deep... is 'map' deep?
16:46:36 <latro`a> ah now I recall the case when you need to update everything
16:46:36 <acowley> If I use @..@ to create a block of example code, how can I insert a blank line without screwing up the line following the blank?
16:46:43 <latro`a> if you have a cycle
16:46:45 <acowley> Currently the line after the blank is pulled left one space
16:46:47 <latro`a> every update has to update everything
16:46:53 <acowley> If I put anything on the blank line, the spacing is fine
16:47:03 <Iceland_jack> stolaruk: Does that answer your question?
16:47:08 <latro`a> but otherwise it can simply update the value being modified and the appropriate pointer to (or if need be, from) it
16:47:15 <jmcarthur> latro`a: sure, but that's not ghc's fault. you have to write that out *yourself*. the copying is not hidden from you.
16:47:40 <jmcarthur> latro`a: i don't know what you mean by "update" here
16:47:44 <stolaruk> Iceland_jack: Yes, I think so. My imperative programming background is so strong it's just hard for me. But yeah I get it.
16:48:07 <Iceland_jack> stolaruk: Since ‘attack’ returns a new Monster, you can call attack on the outcome
16:48:09 <Iceland_jack> @ty attack
16:48:10 <lambdabot> Int -> Monster -> Monster
16:48:14 <jfischoff> acowley: I find bird ticks '>' work better with newlines etc
16:48:19 <Iceland_jack> > let sally = Monster 50 "Sally" in attack 35 (attack 5 sally)
16:48:20 <jmcarthur> latro`a: the entire path to the leaf you are replacing also needs to be replaced. when there is a cycle it just happens that the cycle is that path.
16:48:24 <lambdabot>   Monster {hp = 10, name = "Sally"}
16:48:35 <latro`a> gotcha
16:48:37 <jmcarthur> latro`a: but this is really nothing to do with ghc, again
16:48:52 <stolaruk> So lets say in my game I have rooms, monsters, objects, and so on, and all of these have properties that may change in response to the user's activity. Would it make sense to create some sort of "GameState" "data" type and then thread the GameState thru all functions that need it, perhaps using the State monad?
16:48:52 <acowley> jfischoff: That's a good idea. I like using @@ paragraphs due to less noise, but if they don't work right, it's not a very good options :/
16:49:09 <Iceland_jack> stolaruk: You could do that, yes
16:49:10 <latro`a> jmcarthur: GHC presumably does "the best reasonable thing", I wasn't sure what that was
16:49:15 * jfischoff nods
16:49:27 <jmcarthur> latro`a: it's nothing intelligent, if that's what you mean
16:49:32 <acowley> jfischoff: Yeah, that solved my problem. That's a shame about @
16:49:34 <Iceland_jack> depending on what you want, if it's all pure it may make sense to keep it in the state monad
16:49:42 * jfischoff nods
16:49:59 <Iceland_jack> otherwise it may make sense to have a single mutable variable containing the game state, especially if you're using threads
16:50:00 <latro`a> jmcarthur, the point is that if you have n layers of records down to a value, you typically can't simply update the value and leave the pointer to it be
16:50:03 <halvorgb> Can I square an Integer into a CReal? sqrt doesn't let me
16:50:09 <halvorgb> I mean square root
16:50:18 <jmcarthur> latro`a: you never can, in fact, because there is just no mutation
16:51:07 <Eduard_Munteanu> IIRC strictness analysis did do something to improve that.
16:51:13 <jmcarthur> latro`a: your terminology of "updating pointers" make it seem like you don't really have the right model, or perhaps i am drawing more conclusions from the evidence than i really should be
16:51:42 <stolaruk> Being a newbie, it's hard for me to decide whether I should use State monad, IORef, or Mvar (I think it's called).
16:52:11 <jmcarthur> stolaruk: i think you should not use any of those at first
16:52:12 <Iceland_jack> stolaruk: From what I've heard I'd say you keep it simple for now
16:52:15 <latro`a> when I change the 50th element of a list, I have to replace it, then pass up to the head
16:52:32 <latro`a> which takes 50 (+-1) pointer operations
16:52:34 <jmcarthur> latro`a: but you're not really replacing it at all
16:52:43 <Peaker> stolaruk: have you seen http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html ?
16:52:44 <stolaruk> jmcarthur: Not even State monad?
16:52:46 <jmcarthur> latro`a: you're actually just building some prefix of a new list
16:52:49 <latro`a> right
16:52:57 <jmcarthur> stolaruk: no, i don't think i would recommend even that quite yet
16:53:00 <stolaruk> Peaker: I have not, will check it out
16:53:04 <Iceland_jack> stolaruk: Why do you keep mentioning the State monad? Do you know what that is?
16:53:09 <latro`a> I guess I'm trying to avoid thinking entirely in terms of copying, because you're *not* copying the whole list
16:53:14 <jmcarthur> stolaruk: i think it is valuable to just get used to the language first, and then start learning all the fancy libraries
16:53:15 <latro`a> since you can point to the same tail you had before
16:53:19 <hpc> latro`a: the real issue is that you are changing the 50th element of a list
16:53:31 <jmcarthur> latro`a: right
16:53:35 <latro`a> but the first 50 elements have to be re-updated, because they're collectively the prefix of a list
16:53:35 <Peaker> stolaruk: you use MVar when you're implementing low-level concurrency primitives (very rarely)
16:53:36 <hpc> that's going to be slow no matter the language
16:54:01 <stolaruk> Peaker: OK, I can rule that one out then. :)
16:54:07 <Peaker> stolaruk: you use IORef when you want IO code to share a mutable cell to read/write.  You use State when you want to automate the threading around of an argument through many functions
16:54:10 <jmcarthur> latro`a: loosely one can call that copying, but i'm trying to be pedantic to make sure the difference is understood
16:54:37 <latro`a> I'm basically trying to think about what actually does get copied and what just gets a reference to it like was there before
16:54:46 <jmcarthur> stolaruk: what Peaker said... and you use none of them just to learn haskell ;)
16:54:48 <elliott> there's no inherent notion of copying
16:54:57 <elliott> if you use a thing you get, it's shared
16:55:00 <elliott> if you construct a new thing, it's not
16:55:05 <jmcarthur> latro`a: anything that gets "copied" is not really a copy because it is not the same value anyway
16:55:06 <Peaker> stolaruk: generally if you can structure your code without IO, it is generally better
16:55:07 <elliott> if you take apart a thing you get and construct a new thing, you've constructed a new thing
16:55:16 <elliott> you can call this "copying", but it's just a composite of destructing and constructing values
16:55:25 <jmcarthur> latro`a: value in the operational sense, not in the denotational sense
16:55:49 <latro`a> but you don't have to operate on parts of the structure that don't refer to what you "modified"
16:56:04 <latro`a> with my list example, you don't have to *do* anything with the structure past #50
16:56:09 <stolaruk> jmcarthur: I've written a handful of little utility programs and done a bunch of the Haskell-99 problems. Read LYAH and working on RWH. Just to give you an idea of where I stand
16:56:15 <latro`a> but you do have to do things before #50 because those all refer to #50
16:56:17 <jmcarthur> latro`a: e.g. when you "copy" the prefix of the list to make a new one that shares the tail, the prefix is actually made up of *different* nodes with different pointers
16:56:28 <latro`a> right
16:56:32 <jmcarthur> latro`a: not the same stuff
16:56:34 <latro`a> but the tail actually *is* shared
16:56:37 <jmcarthur> right
16:56:45 <latro`a> ok, now I get it
16:56:45 * hackagebot quickcheck-property-comb 0.1.0.0 - Combinators for Quickcheck Property construction and Property diagnostics  http://hackage.haskell.org/package/quickcheck-property-comb-0.1.0.0 (jfeltz)
16:57:09 <beefcube> that's my first package :P
16:57:21 <scshunt> beefcube: congrats
16:57:32 <Peaker> stolaruk: if you manually pass around your data between your functions, feeding the result state of function A to the input state of function B, result state of B to function C, you'll notice a pattern that's annoying to manually thread the state around. the State monad is just about capturing this pattern so the state is threaded for you
16:57:57 <Iceland_jack> stolaruk: Your question seems strange to me knowing that you've gone through LYAH
16:58:19 <jmcarthur> stolaruk: i recommend not using the State monad until you see the need for it. just using it for the sake of using it is premature.
16:58:36 <stolaruk> jmcarthur: ok, that's a good point
16:59:11 <hpc> stolaruk: to sort of side-step your question, i would suggest you write your code to look like what it does, then see what issues pop up
16:59:13 <stolaruk> Iceland_jack: Well I don't know what to say. Like I said for whatever reason what's been tripping me up is how to work with immutability
17:00:07 <Iceland_jack> stolaruk: It may be beneficial to go through LYAH again or work on getting a firmer grasp on functions that take values and return modified versions of them
17:00:12 <Iceland_jack> since it's a big part of Haskell
17:01:22 <Iceland_jack> For example, can you write an ‘attack’ function that doesn't decrease the HP below 0 and a ‘heal’ (∷ Int → Player → Player) function that doesn't heal above 100 (or something like that)
17:01:30 <stolaruk> Iceland_jack: Ok. In any case your "attack" function makes total sense. Maybe if I had actually tried to write it myself instead of just trying to think about it in my head, I would have been able to write the same function
17:02:42 <jmcarthur> stolaruk: i do understand where you're coming from, it think. i remember when i was just starting i had a lot of moments where i thought "I know I can define this function, but where do I *put* the result? I can't just hold on to it forever!"
17:02:47 <jmcarthur> *i think
17:02:55 <Iceland_jack> @let data Player = Player { name :: String, level :: Int } deriving Show
17:02:56 <Iceland_jack> @let levelUp (Player name lvl) = Player name (lvl + 1)
17:02:56 <Iceland_jack> > let sally = Player "S411y" 5 in levelUp (levelUp (levelUp sally))
17:02:56 <lambdabot>  .L.hs:143:22:
17:02:56 <lambdabot>      Multiple declarations of `name'
17:02:56 <lambdabot>      Declared at: .L.hs:1...
17:02:57 <lambdabot>  .L.hs:146:10: Not in scope: data constructor `Player'
17:02:57 <lambdabot>  
17:02:58 <lambdabot>  .L.hs:146:29: Not i...
17:03:00 <lambdabot>   Not in scope: data constructor `Player'Not in scope: `levelUp'
17:03:02 <lambdabot>  Perhaps you...
17:03:10 <Iceland_jack> @let data Player = Player { playerName :: String, playerLevel :: Int } deriving Show
17:03:10 <Iceland_jack> @let levelUp (Player name lvl) = Player name (lvl + 1)
17:03:10 <Iceland_jack> > let sally = Player "S411y" 5 in levelUp (levelUp (levelUp sally))
17:03:11 <lambdabot>  Defined.
17:03:12 <lambdabot>   Not in scope: data constructor `Player'Not in scope: `levelUp'
17:03:12 <lambdabot>  Perhaps you...
17:03:13 <lambdabot>  Defined.
17:03:15 <Iceland_jack> hah..
17:03:30 <Iceland_jack> @undef
17:03:30 <lambdabot> Undefined.
17:03:39 <jmcarthur> stolaruk: but eventually you realize that "putting" results in places doesn't even make much sense in an imperative language, because even when you stick it in some mutable variable, you still hold on the mutable variable somehow.
17:03:42 <Iceland_jack> @let data Player = Player { playerName :: String, playerLevel :: Int } deriving Show
17:03:43 <Iceland_jack>  
17:03:43 <lambdabot>  Defined.
17:03:49 <Iceland_jack> @let levelUp (Player name lvl) = Player name (lvl + 1)
17:03:49 <Iceland_jack>  
17:03:50 <lambdabot>  Defined.
17:03:52 <Iceland_jack> > let sally = Player "S411y" 5 in levelUp (levelUp (levelUp sally))
17:03:53 <jmcarthur> Iceland_jack: ...
17:03:55 <lambdabot>   Player {playerName = "S411y", playerLevel = 8}
17:04:38 <elliott> the flooding isn't ideal...
17:04:47 <ReinH> Iceland_jack: you can give playerLevel an Enum constraint and use succ if you want :p
17:04:50 <Iceland_jack> Apologies
17:05:02 <Iceland_jack> ReinH: also Bounded!
17:05:06 <stolaruk> I did not realize how easy it would be to make a new object based on an existing one simply by using pattern matching to grab the values I want to retain from the old object.
17:05:06 * jmcarthur read "levelUp (levelUp (levelUp sally))" with a rhythm like it's a song
17:05:50 <Iceland_jack> finalBoss = Player "Sephiroth" maxBounded …
17:05:51 <stolaruk> I probably sound dumb because it is clearly obvious how easy that is
17:05:59 <ReinH> > let player = ("sally", 5) in player & _2 %~ succ.succ.succ
17:06:01 <lambdabot>   ("sally",8)
17:06:03 <jmcarthur> stolaruk: no, this is normal growing pains
17:06:11 <stolaruk> Just pointing out the "attack" function helped a lot
17:06:17 <Iceland_jack> stolaruk: Glad to hear it
17:06:21 <ReinH> > let player = ("sally", 5) in player & _2 +~ 1
17:06:23 <lambdabot>   ("sally",6)
17:06:41 <Iceland_jack> It's a different way of thinking and it can be tricky to jump from imperative to functional
17:06:46 * hackagebot hzk 0.0.2 - Haskell client library for Apache Zookeeper  http://hackage.haskell.org/package/hzk-0.0.2 (DiegoSouza)
17:07:05 * jmcarthur thinks jumping from functional to imperative is tricky
17:07:06 <ReinH> > let levelUp = (_2 %~ succ) in levelUp . levelUp $ ("sally", 5)
17:07:08 <lambdabot>   ("sally",7)
17:07:11 <Iceland_jack> That too :)
17:08:30 <stolaruk> I was able to write, in Haskell, a little CLI program that quizzes me on Japanese vocabulary, it does some file IO, too, and yet I couldn't see how easy it would be to write "attack".
17:09:06 <Iceland_jack> Well, now you could write that function right?
17:09:29 <stolaruk> Yep, this is a good step in the right direction. I would be pretty lost without this channel, I appreciate the help!!
17:10:03 <Iceland_jack> No problem! For characters you might use something called ‘smart constructors’ that only allow you to create valid Players for example
17:10:48 <stolaruk> Iceland_jack: Ah that's an interesting idea. Yeah I did already start to write some helper functions to make populating the game world easier
17:10:58 <Iceland_jack>     player ∷ String → Int → Maybe Player
17:10:59 <Iceland_jack>     player name lvl | lvl >= 1 && lvl <= 100 = Just (Player name lvl)
17:10:59 <Iceland_jack>                     | Nothing
17:11:19 <stolaruk> Using Maybe, I see that's interesting
17:11:23 <Iceland_jack> Then you don't export the Player value constructor
17:11:37 <stolaruk> oh ok, yes
17:11:38 <Iceland_jack> and you know for sure that if you have a Player value, that the level is between 1 and 100
17:11:45 <stolaruk> right
17:12:46 <Peaker> Iceland_jack: missing "otherwise = ..." there
17:13:03 <stolaruk> yes :)
17:13:06 <Iceland_jack> yeah what Peaker said :)
17:14:41 <Iceland_jack> stolaruk: A good started might be to create a turn-based game where Player₁ and Player₂ take turns picking attacks?
17:15:51 <Iceland_jack> Each player might have a certain attack power, so the attack function might be something like:
17:15:51 <Iceland_jack>     attack ∷ Player → Player → Player
17:15:51 <Iceland_jack>     attack opponent player = …
17:16:31 <stolaruk> Iceland_jack: Yeah I could do that. I kinda have aspirations of developing a MUD in Haskell but I'm starting to realize that I better start small scale and take it from there. :)
17:17:05 <Iceland_jack> It's good to hear that you still have motivation! Good luck and don't hestitate to ask here
17:17:41 <stolaruk> Iceland_jack: Yeah I don't know where this motivation came from but I really want to give it a go and try to become a skilled Haskell programmer. Thank you fro your kind words.
17:23:39 <benzrf> hello
17:23:44 <benzrf> why is Alternative a thing?
17:23:54 <benzrf> why not just use Monoid?
17:24:21 <edwardk> Alternative is a stronger statement.
17:24:27 <benzrf> how s?
17:24:28 <benzrf> *so
17:24:40 <jmcarthur> alternative promises not to use the type parameter f is applied to
17:24:50 <edwardk> it says that m a has a monoidal structure no matter what the choice of 'a' is. It also carries laws for how that interacts with (<*>) and pure
17:25:03 <edwardk> it is stronger in both of those ways
17:25:12 <Peaker> also: you can't have this in contexts: (forall a. Monoid (f a))  whereas you can have   Alternative f
17:25:23 <Peaker> ah that's what he said
17:25:28 <jmcarthur> does alternative actually have extra laws or are they guaranteed by parametricity and the existing applicative laws anyway?
17:25:43 <jmcarthur> deja vu
17:25:49 <jmcarthur> i think i have had this discussion before
17:26:07 <Peaker> at least:  empty <*> _ = empty, I think?
17:26:07 <edwardk> tis is like saying why use a ring with (+) and (*) when you can just use the monoid for (*)… but there are laws for how (*) relates to (+) in a ring.. e.g. a * (b + c) = a * b + a * c. there is a similar laws for a <*> (b <|> c)
17:26:20 <benzrf> i don't know these words
17:26:25 <benzrf> but ill take this on faith
17:26:26 <benzrf> :I
17:26:34 <ezrios> Anyone here experienced with xmonad? I'm having some trouble and #xmonad is dead
17:26:50 <edwardk> benzrf: consider 3 * (4 + 1) = 3*4 + 3*1
17:27:06 <edwardk> benzrf: thats all i'm sayng, there is a similar property for Alternative that isn't captured by Monoid
17:27:20 <edwardk> where you replace * with (<*>) and + with (<|>)
17:27:57 <stephenmac7> I'm having issues with the examples in LYAH
17:28:28 <benzrf> stephenmac7: I suck at haskell so maybe ill be able to phrase it in a way that sounds vaguely like english
17:28:43 <stephenmac7> :D
17:28:49 <benzrf> what's your issue
17:29:12 <stephenmac7> I fail to see how the lines
17:29:13 <stephenmac7> Just 3 >>= (\x -> Just "!" >>= (\y -> Just (show x ++ y)))
17:29:15 <stephenmac7> and
17:29:29 <stephenmac7> do
17:29:29 <stephenmac7>     x <- Just 3
17:29:29 <stephenmac7>     y <- Just "!"
17:29:29 <stephenmac7>     Just (show x ++ y)
17:29:32 <stephenmac7> are similar
17:29:40 <benzrf> the latter is just sugar for the former
17:29:43 <benzrf> it is translated
17:29:44 <ezrios> stephenmac7: do-notation is syntactic sugar for the bind operator
17:29:58 <stephenmac7> Ah, I see.
17:30:18 <benzrf> basically, a line like 'foo <- bar' wraps the remainder into a lambda
17:30:29 <benzrf> then binds bar to the lambda, where foo is the parameter of the lambda
17:30:35 <Iceland_jack> > liftM2 (\a b -> show a ++ b) (Just 3) (Just "!")
17:30:36 <lambdabot>   Just "3!"
17:30:47 <stephenmac7> So, why couldn't I do this? Just 5 >>= (\x -> putStrLn x)
17:30:56 <Iceland_jack> stephenmac7: Different monads
17:30:57 <benzrf> stephenmac7: that's not how monads work
17:31:03 <benzrf> stephenmac7: it makes sense from your point of view...
17:31:09 <benzrf> but that's because you don't understand the point of monads yet
17:31:12 <Peaker> @type (>>=)
17:31:13 <stephenmac7> I see. So they have to be the same type
17:31:13 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:31:14 <benzrf> I too once thought as you did
17:31:26 <stephenmac7> :D
17:31:27 <Peaker> stephenmac7: note that the same "m" is used in both arguments to (>>=) and in the result
17:31:29 <Iceland_jack> stephenmac7: Yes, consult the type of (>>=)
17:31:47 <monoidal> stephenmac7: the same monad; note "x" and "y" do not have to have the same type, and in fact in your example they're different
17:31:59 <Peaker> stephenmac7: Just 5 :: Num a => Maybe a ; (\x -> putStrLn x) :: String -> IO ()
17:32:04 <Iceland_jack> The first argument "m a" is 'Just 5' and thus has type "Maybe Int" (simplified)
17:32:12 <monoidal> stephenmac7: one is [Int], the other is [Char]. the monad in both cases is [] though
17:32:25 <stephenmac7> Ah, thanks
17:32:29 <stephenmac7> Otherwise it would be
17:32:48 <stephenmac7> (Monad m, Monad n) => m a -> (a -> n b) -> n b
17:33:02 <stephenmac7> Correct?
17:33:14 <benzrf> yeah
17:33:16 <monoidal> that's right - but such a function does not exist
17:33:37 <stephenmac7> So, I can do this: Just 5 >>= (\x -> Just x)
17:33:40 <benzrf> the thing here is, what would be the point of a function like that?
17:33:43 <benzrf> yeah
17:33:43 <monoidal> it is possible to combine several monads into a single one, but that's a topic better left for later
17:33:59 <Iceland_jack> stephenmac7: Yes, which is the same as: Just 5 >>= Just
17:34:02 <benzrf> the ONLY use I can think of off the top of my head for a function like that is your IO example
17:34:26 <stephenmac7> Iceland_jack: I keep forgetting type constructors work like functions
17:34:31 <benzrf> they ARE functions
17:34:37 <benzrf> also, I think you mean value constructors
17:34:46 <benzrf> type constructor is Maybe, not Just
17:34:48 <stephenmac7> That ^
17:35:01 <Iceland_jack> (of course, it is also the same as 'Just 5' but I digress)
17:35:07 <stephenmac7> It's the capital that throws me off
17:35:25 <benzrf> stephenmac7: everybody will probably contradict me immediately, but I find it easiest to think of monads as a way of stringing together computations that produce some kind of extra output or side effect
17:35:47 <Iceland_jack> Maintaining a distinction between types and values seems to be a common tripping point
17:36:07 <Eduard_Munteanu> benzrf: "computations with structured output" isn't bad
17:36:12 <stephenmac7> So, like using monads with Maybe produces Nothing in the case of failure (assuming you're using Nothing to indicate failure)
17:36:16 <benzrf> i.e. the Maybe monad can be used to chain together computations that take in a value and output another value and/or whether it failed [kinda]
17:36:36 <benzrf> if you have a bunch of functions that take in regular input but give out wrapped or structured output and you want to string them together...
17:36:39 <benzrf> that's what monads are for
17:37:15 <stephenmac7> So, monads would work well for Either
17:37:18 <benzrf> yep!
17:37:38 <benzrf> two major ways to think of monads are in terms of containers or in terms of side effects
17:37:53 <stephenmac7> Great. After going through 12 chapters in LYAH I'm finally starting to see the appeal
17:37:55 <Iceland_jack> stephenmac7: So when you say ‘work well for’, well Either *is* a monad
17:37:57 * yogurt_truck thinks do notation should be absolutely avoided when introducing the idea of monads
17:37:57 <benzrf> :)
17:38:10 <benzrf> for example, the Writer monad is a way of returning a monoidal value along with your output
17:38:47 <stephenmac7> yogurt_truck: The problem is that it's harder to introduct IO before monads if you avoid do notation
17:38:49 <benzrf> so you could 'write' a string from the function by returning the result plus the output
17:38:53 <stephenmac7> *introduce
17:39:09 <benzrf> there you go, a function that returns structured or additional output
17:39:13 <benzrf> chain them with binding
17:39:24 <stephenmac7> benzrf: Ah, and that would be much harder without a Monad
17:39:28 <benzrf> right!
17:39:39 <stephenmac7> Lots of pattern matching
17:40:28 <benzrf> I found 'you could have invented monads' incredibly helpful
17:40:34 <Earnestly> stephenmac7: http://stackoverflow.com/questions/17002119/haskell-pre-monadic-i-o
17:40:35 <benzrf> in fact half of what im saying right now is just paraphrasing it
17:40:39 <yogurt_truck> stephenmac7: well but that's kinda what lyah does isn't it? uses do notation just for "magic" IO, because telling you anything about monads, and then it introduces monads properly without the sugar
17:40:41 <hodapp> :)
17:40:53 <yogurt_truck> s/because/before/
17:41:11 <stephenmac7> benzrf: True
17:41:17 <yogurt_truck> (and finally it explains what do notation is doing)
17:41:32 <stephenmac7> yogurt_truck: That's exactly what it does
17:41:38 <stephenmac7> Earnestly: Interesting
17:41:51 * hackagebot snap-elm 0.1.1 - Serve Elm files through the Snap web framework.  http://hackage.haskell.org/package/snap-elm-0.1.1 (KyleCarter)
17:41:52 <thebnq> do notation is definitely magical
17:42:05 <Earnestly> Thought it might be a nice bit of historical perspective
17:42:12 <stephenmac7> Earnestly: I wouldn't suggest doing that though
17:42:17 <monoidal> thebnq: "magical" only in the sense it's sugar
17:42:23 <Earnestly> stephenmac7: You cannot anymore
17:42:29 <stephenmac7> Ah, I see.
17:42:42 <thebnq> hehe but until you learn the tricks, anything is magic :p
17:42:44 <stephenmac7> In this case, wouldn't do notation have lots of overhead?
17:43:24 <stephenmac7> Oh, and why on earth are monads (so far) much easier to understand than applicative functors?
17:43:51 <dobblego> because you said so to yourself!
17:43:53 <Iceland_jack> stephenmac7: …they are?
17:44:20 <stephenmac7> Iceland_jack: As far as I can tell, yes
17:44:21 <digilord> Hi I am new to Haskell.  The . operator (function composition) is like chaining functions together in other languages right?
17:44:35 <stephenmac7> digilord: Basically that's what it is
17:44:43 <benzrf> digilord: more or less
17:44:48 <dobblego> stephenmac7: I think you will take that back once you spend some quality time with both.
17:44:55 <benzrf> digilord: it returns a new function rather than making a call, thoug
17:44:58 <benzrf> *though
17:44:58 <monoidal> digilord: f . g is a function that takes x and returns f (g x)
17:45:04 <digilord> Great!  Thanks.  Just going through the learning haskell book
17:45:12 <benzrf> stephenmac7: I personally sort of feel the same way
17:45:21 <Iceland_jack> stephenmac7: In other languages you might concatenate two input lines using "read() + read()", using applicative you can write: (++) <$> getLine <*> getLine
17:45:21 <stephenmac7> dobblego: Possibly
17:45:26 <benzrf> but the reason is probably because we are both focusing way too hard on monads
17:45:32 <benzrf> and asking/reading about them
17:45:39 <stephenmac7> It's really the (->) instance of Applicative that I completely don't understand
17:45:41 <benzrf> so we gained a better understanding
17:45:43 <benzrf> stephenmac7: oh god
17:45:45 <Iceland_jack> stephenmac7: Ignore it
17:45:46 <benzrf> I just skipped that part
17:45:49 <benzrf> it was like alien speak
17:45:50 <benzrf> :I
17:45:57 <stephenmac7> :D
17:46:00 <monoidal> it's SK combinators in case you encountered them.
17:46:07 <dobblego> @type \f g x -> f x (g x) -- where is the hard bit?
17:46:09 <lambdabot> (t2 -> t1 -> t) -> (t2 -> t1) -> t2 -> t
17:46:10 <Iceland_jack> People hardly ever use the that instance in actual Haskell code
17:46:28 <dobblego> Iceland_jack: I think a lot of people use it, including me
17:46:32 <elliott> I use it!
17:46:39 <monoidal> it's used in @pointfree
17:46:44 <benzrf> ive found that applicatives are MORE OR LESS a way of fmapping functions with multiple args
17:46:48 <Iceland_jack> I didn't say nobody used it
17:46:55 <benzrf> think of it like this:
17:47:11 <benzrf> the functions are curried, so if you fmap a '3-arg' function over, say...
17:47:13 <benzrf> [1, 2, 3]
17:47:22 <benzrf> you'll get a list of partially applied functions
17:47:37 <benzrf> now if you want to add more arguments, you need to be able to apply those from inside the functor
17:47:38 <Eduard_Munteanu> :t fmap (uncurry ($))
17:47:40 <lambdabot> Functor f => f (b1 -> b, b1) -> f b
17:47:40 <benzrf> -> applicatives
17:47:49 <stephenmac7> Just a second
17:47:51 <Eduard_Munteanu> :t uncurry (<*>)
17:47:53 <lambdabot> Applicative f => (f (a -> b), f a) -> f b
17:48:49 <stephenmac7> I'm back
17:48:50 <Eduard_Munteanu> It's lifted application, for a given functor, really.
17:49:24 <benzrf> funnily, this actually results in something like a monad
17:49:30 <stephenmac7> I see, but at the same time, I don't see
17:49:32 <benzrf> at least in terms of usage/workings
17:49:47 <benzrf> ok, let's take an example
17:49:57 <benzrf> sum3 a b c = a + b + c
17:50:00 <Iceland_jack> stephenmac7: Don't worry about getting it, just be aware of it so you can think back to it when you see it used
17:50:14 <benzrf> let's say you want to map this over 3 lists
17:50:18 <benzrf> and get a new list
17:50:24 <benzrf> right?
17:50:33 <stephenmac7> Iceland_jack: I don't think I'll be using it anytime soon. I do want to understand it though.
17:50:36 <stephenmac7> Yes
17:50:39 <benzrf> if I do 'fmap sum3 [1, 2, 3]'...
17:50:50 <benzrf> I'll get '[sum3 1, sum3 2, sum3 3]'
17:51:01 <mm_freak_> i suggest explaining in terms of Maybe or 'f' instead of []
17:51:08 <benzrf> mm_freak_: probably smart
17:51:14 <benzrf> ok, hold on.
17:51:18 <stephenmac7> So, wou were saying
17:51:19 <benzrf> let me start over :P
17:51:22 <stephenmac7> You'll get
17:51:26 <stephenmac7> Just (sum3 2)
17:51:30 <benzrf> right
17:51:43 <benzrf> let's say the 3 Maybes are Just 1, Just 2, Just 3
17:51:44 <Eduard_Munteanu> Or you could say Applicatives generalize fmap, zipWith, zipWith3 ...
17:51:51 <benzrf> so I apply sum3 to Just 1
17:51:53 <mm_freak_> > Just f <*> Just x <*> Just y <*> Just z
17:51:55 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
17:51:55 <lambdabot>    arising from a us...
17:51:57 <benzrf> and I get Just (sum3 1)
17:51:59 <mm_freak_> > Just f <*> Just x <*> Just y <*> Just z :: Maybe Expr
17:52:00 <lambdabot>   Just (f x y z)
17:52:16 <benzrf> now I want to apply this functor'd partially-applied function to my next functor
17:52:20 <benzrf> how do I do that?
17:52:27 <Iceland_jack> stephenmac7: Look at what mm_freak_ posted ↑
17:52:30 <benzrf> easy, if it's Just (fn), fmap fn
17:52:33 <benzrf> otherwise Nothing
17:53:13 <benzrf> so 'ffmap (Just (sum3 1)) (Just 2)' will give me 'Just (sum3 1 2)'
17:53:24 <benzrf> and then on Just 3:
17:53:32 <benzrf> I get Just 6
17:53:57 <stephenmac7> Give just a little bit of time to absorb that
17:54:00 <benzrf> :)
17:54:14 <mm_freak_> let's use actual code:  you have a function f that you want to apply to three arguments…  the arguments are Maybe-wrapped, so the natural thing would be to use fmap
17:54:20 <Iceland_jack> I have to say, I understand applicative functors and I don't find that explanation clear…
17:54:28 <benzrf> Iceland_jack: ;p
17:54:29 <mm_freak_> > fmap f (Just x)  :: Maybe Expr
17:54:32 <lambdabot>   Just (f x)
17:54:45 <mm_freak_> problem:  you can't apply that to 'Just y' using fmap
17:55:08 <mm_freak_> that's where (<*>) comes in:  unlike fmap it takes a wrapped function
17:55:19 <mm_freak_> fmap :: (a -> b) -> …
17:55:22 <mm_freak_> (<*>) :: f (a -> b) -> …
17:55:34 <stephenmac7> Ah.
17:55:40 <mm_freak_> > fmap f (Just x) <*> Just y  :: Maybe Expr
17:55:42 <lambdabot>   Just (f x y)
17:56:02 <mm_freak_> finally a little style improvement:  use <$> instead of fmap in applicative style =)
17:56:07 <stephenmac7> :)
17:56:17 <mm_freak_> > f <$> Just x <*> Just y :: Maybe Expr
17:56:18 <Iceland_jack> stephenmac7: So ‘fmap’ allows you to apply a unary function to a Functor, applicative functions allow you apply binary+ functions to Functors
17:56:18 <lambdabot>   Just (f x y)
17:56:37 <mm_freak_> and that's it…  but not only Maybe is an applicative functor…  all monads are applicative functors
17:56:38 <stephenmac7> Iceland_jack: Now that was a nice, concise explanation
17:57:02 <mm_freak_> so whenever you are compelled to write this:  do x1 <- c1; x2 <- c2; x3 <- c3; return (f x1 x2 x3)
17:57:13 <edwardk> byorgey: did that explanation on the semigroupoids issue make sense?
17:57:15 <mm_freak_> you can use applicative style instead:  f <$> c1 <*> c2 <*> c3
17:57:22 <stephenmac7> Ah
17:57:24 <stephenmac7> Thanks, mm_freak_
17:57:31 <Iceland_jack> > (++) <$> Just "hello" <*> Just " world"
17:57:31 <Iceland_jack> > (++) <$> getLine <*> getLine
17:57:32 <lambdabot>   Just "hello world"
17:57:32 <lambdabot>   can't find file: L.hs
17:57:33 <benzrf> stephenmac7: when you map over multiple functors, you want to join the structures of those functors together. you end up rolling them up with you as you map each functor'd function across the next functor
17:57:37 <mm_freak_> thank benzrf =)
17:57:39 <benzrf> this is kind of like a monad!
17:58:00 <mm_freak_> stephenmac7: as a further note, applicative style is a generalized liftM*
17:58:01 <benzrf> like how with a monad, you roll up the structure of the monad you're binding with the result of the function you're binding it to
17:58:28 <mm_freak> stephenmac7: as a further note, applicative style is a generalized liftM*
17:58:28 <stephenmac7> So, that why this:
17:58:29 <stephenmac7> > (+) <$> (+3) <*> (*100) $ 5
17:58:31 <lambdabot>   508
17:58:46 <Eduard_Munteanu> Any idea how to make a SingRep instance for lists without UndecidableInstances?
17:58:59 <stephenmac7> No
17:59:08 <stephenmac7> Why does 5 get applied to both?
17:59:24 <mm_freak> stephenmac7: '(->) r' is a confusing functor…  it's the reader monad =)
17:59:31 <benzrf> Ok, what happens when you fmap (+) over (+3)?
17:59:39 <stephenmac7> There's a (->) Monad??
17:59:52 <mm_freak> > (do x <- (+3); y <- (*100); return (x + y)) 5
17:59:54 <lambdabot>   508
18:00:04 <benzrf> functions as functors work if you think of them as associations or mappings; you're mapping your function over the result column
18:00:08 <Eduard_Munteanu> GHC complains that  instance (SingE (Kind k) a) => SingE (Kind :: [k]) [a]  fails coverage checking.
18:00:08 <mm_freak> stephenmac7: (+3) in reader monad terms:  asks (+3)
18:00:50 <mm_freak> stephenmac7: the monad is '(->) r'
18:00:53 <mm_freak> not just (->)
18:00:57 <mm_freak> and you just used it =)
18:00:59 <stephenmac7> That's what I meant
18:01:14 <benzrf> i dont know reader, nor do I actually understand the applicative version
18:01:15 <benzrf> <.<
18:01:16 <mm_freak> i translated your applicative example to monadic style
18:01:24 <Iceland_jack> stephenmac7: In mm_freak's example, you can think of "5" being the environment and 'x ← (+3)' applies the function (+3) to the environment, binding the result to 'x'
18:01:32 <mm_freak> :t do x <- (+3); y <- (*100); return (x + y)
18:01:33 <lambdabot> Num a => a -> a
18:01:39 <stephenmac7> Iceland_jack: I was wondering how that worked
18:01:56 <Iceland_jack> then 'y ← (*100)' does the same ((*100) 5 = 500), storing 500 in y
18:01:58 * hackagebot snap-elm 0.1.1.1 - Serve Elm files through the Snap web framework.  http://hackage.haskell.org/package/snap-elm-0.1.1.1 (KyleCarter)
18:02:11 <mm_freak> stephenmac7: it's literally just the reader monad…  each "computation" is just a function of the environment
18:02:20 <stephenmac7> How can 'a' be applied to both?
18:02:21 <mm_freak> stephenmac7: Reader is really just a newtype wrapper around exactly this
18:02:24 <benzrf> @undo do x <- (+3); y <- (*100); return (x + y)
18:02:24 <lambdabot> (+ 3) >>= \ x -> (* 100) >>= \ y -> return (x + y)
18:02:27 <enthropy> Eduard_Munteanu: undecidableinstances isn't so bad
18:02:31 <mm_freak> newtype Reader e a = Reader (e -> a)
18:02:34 <Iceland_jack> stephenmac7: Because it creates an implicit ‘environment’
18:02:53 <mm_freak> you could just as well write an instance for '(->) e' directly, and that's what happens here =)
18:03:03 <mm_freak> then 'runReader' is just ($)
18:03:11 <mm_freak> and 'asks f' becomes just 'f'
18:03:24 <stephenmac7> benzrf: That @undo things was helpful
18:03:29 <benzrf> stephenmac7: ;)
18:03:34 <stephenmac7> *thing
18:03:48 <mm_freak> > (f <$> g <*> h) x :: Expr
18:03:51 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
18:03:51 <lambdabot>    arising from a us...
18:04:52 <Iceland_jack> stephenmac7:
18:04:52 <Iceland_jack> > (do x <- show . pred; y <- show; z <- show . succ; return (x, y, z)) 10
18:04:54 <lambdabot>   ("9","10","11")
18:05:03 <mm_freak> > (do x <- sin; y <- cos; return (x + y)) 5
18:05:05 <lambdabot>   -0.6752620891999122
18:05:20 <mm_freak> > (+) <$> sin <*> cos $ 5
18:05:22 <lambdabot>   -0.6752620891999122
18:05:48 <mm_freak> (f <$> g <*> h) x = f (g x) (h x)
18:05:57 <Iceland_jack> > (liftM2 (+) sin cos) 5   -- etc. etc. etc.
18:05:58 <lambdabot>   -0.6752620891999122
18:06:11 <stephenmac7> I think you lost me
18:06:18 <mm_freak> stephenmac7: do you understand reader monads?
18:06:20 <Iceland_jack> stephenmac7: OK ignore my liftM2 example
18:06:36 <stephenmac7> mm_freak: No, haven't gotten there yet
18:06:46 <stephenmac7> Iceland_jack: I've only seen liftA anyway
18:06:48 <Iceland_jack> But if you get the intuition of having a value in the environment that functions can use, then you've pretty much got it
18:07:05 <mm_freak> stephenmac7: consider do-notation
18:07:10 <stephenmac7> Iceland_jack: Ah, okay
18:07:19 <mm_freak> to the right of "<-" you have functions
18:07:29 <mm_freak> each of those functions receives the same argument, which is fed from outside
18:07:55 <mm_freak> this argument is often called the "environment" value
18:08:27 <stephenmac7> Go that
18:08:33 <Iceland_jack> Using the Reader monad one might have some immutable environment such as the program configuration there
18:08:36 <mm_freak> when you write "x <- f" it means that x is f applied to the environment value
18:08:41 <mm_freak> like in my example:  x <- sin
18:08:47 <mm_freak> x is the sine of the environment value
18:09:02 <stephenmac7> Is actually let x = sin env
18:09:28 <Iceland_jack> stephenmac7: yes that's similar to what it desugars to
18:09:29 <mm_freak> given such a computation "do …" this is how you "run" it with an environment value:  (do …) env
18:09:39 <mm_freak> that's because it's really just a function you can apply
18:10:06 <mm_freak> :t (do x <- sin; y <- cos; return (x + y))
18:10:06 <lambdabot> Floating a => a -> a
18:10:19 <mm_freak> this function returns the sum of the sine and the cosine of the environment value
18:10:22 <mm_freak> let's apply it
18:10:23 <Iceland_jack>     (do x ← fx; y ← fy; z ← fz; …) FOO
18:10:23 <Iceland_jack> is really just
18:10:23 <Iceland_jack>     let x = fx FOO; y = fy FOO; z = fz FOO in …
18:10:27 <mm_freak> > (do x <- sin; y <- cos; return (x + y)) 15
18:10:28 <lambdabot>   -0.10940007270170449
18:10:40 <mm_freak> does that make sense?
18:10:58 <Iceland_jack> It's not very impressive or complicated to be honest… maybe a bit strange
18:10:59 <stephenmac7> mm_freak: I understand that
18:11:00 <mm_freak> "environment" is really just a fancy word for "argument" =)
18:11:05 <mm_freak> great
18:11:14 <mm_freak> now you should recognize that pattern
18:11:19 <stephenmac7> However, I don't understand the desugared edition
18:11:25 <mm_freak> "do x <- sin; y <- cos; return (x + y)"
18:11:29 <benzrf> reader is basically just a way of composing multi-arg functions isnit it
18:11:41 <benzrf> *usage
18:11:42 <mm_freak> it fits this pattern:  do x1 <- c1; x2 <- c2; return (f x1 x2)
18:11:48 <Iceland_jack> benzrf: What do you mean?
18:11:54 <mm_freak> so you can rewrite it:
18:11:56 <stephenmac7> @undo (do x <- sin; y <- cos; return (x + y))
18:11:56 <lambdabot> (sin >>= \ x -> cos >>= \ y -> return (x + y))
18:12:07 <mm_freak> :t (+) <$> sin <*> cos
18:12:08 <Eduard_Munteanu> I think the best thing is to stare at (>>=)'s type for a while.
18:12:08 <lambdabot> Floating a => a -> a
18:12:11 <mm_freak> same function
18:12:12 <benzrf> Eduard_Munteanu: heh
18:12:21 <mm_freak> > ((+) <$> sin <*> cos) 15
18:12:23 <lambdabot>   -0.10940007270170449
18:12:44 <stephenmac7> mm_freak: So why on earth would you write it monadically rather than applicatively
18:13:03 <mm_freak> stephenmac7: you wouldn't, unless you're not familiar with applicative style =)
18:13:08 <mm_freak> (or disagree with it for some reason)
18:13:14 <stephenmac7> I see.
18:13:19 <mm_freak> i'd write it like this:  liftA2 (+) sin cos
18:13:26 <mm_freak> > liftA2 (+) sin cos 15
18:13:27 <lambdabot>   -0.10940007270170449
18:13:30 <mm_freak> again, same thing
18:13:32 <copumpkin> (| sin + cos |)
18:13:32 <benzrf> stephenmac7: congratulations, you now know more about applicatives & monads than I do
18:13:40 <stephenmac7> Rather than (+) <$> sin <*> cos
18:13:45 <stephenmac7> benzrf: I seriously doubt it :)
18:13:58 <benzrf> im not joking
18:14:09 <stephenmac7> So, this: (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5
18:14:20 <mm_freak> stephenmac7: we have quite a few high level interfaces to regular functions in haskell =)
18:14:25 <benzrf> most of what I was saying to you was the extent of my knowledge and I was figuring out  half of it on the spot
18:14:41 <stephenmac7> Basically applies all those middle functions (+3, *2, etc) to the environment (5) and fmaps our lambda to it
18:14:52 <mm_freak> one of my favorites is Monoid
18:14:52 <mm_freak> > (id <> reverse) "abc"
18:14:54 <lambdabot>   "abccba"
18:15:05 <stephenmac7> :t (<>)
18:15:06 <lambdabot> Monoid m => m -> m -> m
18:15:06 <Iceland_jack> stephenmac7: In do-notation that would be:
18:15:06 <Iceland_jack>     (do x ← (+3); y ← (*2); z ← (/2); return [x,y,z]) 5
18:15:06 <benzrf> now monoids I understand
18:15:08 <benzrf> mostly...
18:15:20 <benzrf> @src (<>)
18:15:20 <lambdabot> Source not found. My pet ferret can type better than you!
18:15:26 <benzrf> oh wait
18:15:32 <benzrf> what does <> do?
18:15:35 <mm_freak> instance (Monoid b) => Monoid (a -> b)
18:15:38 <mm_freak> (<>) = mappend
18:15:40 <Iceland_jack> mappend
18:15:41 <benzrf> ah
18:15:42 <stephenmac7> Ah
18:15:52 <mm_freak> (f <> g) x = f x <> g x
18:16:04 <stephenmac7> f <> g = f `mappend` g
18:16:25 <benzrf> > Sum 3 <> Sum 4
18:16:27 <lambdabot>   Sum {getSum = 7}
18:16:27 <Iceland_jack> > "hello" <> " " <> "world"
18:16:28 <lambdabot>   "hello world"
18:16:30 <Iceland_jack> etc. et.
18:16:36 <stephenmac7> Iceland_jack: Great
18:16:39 <dobblego> copumpkin: is there a nice notation for this yet?
18:16:41 <redscare> is there an explanation of why one does not need to use "lift" to call "get" on something like ReaderT a (State b) c?
18:16:45 <stephenmac7> Your do notation translationg was helpful
18:16:48 <mm_freak> so for lists:  (f <> g) x = f x ++ g x
18:16:48 <stephenmac7> *translation
18:17:19 <Iceland_jack> stephenmac7: To be honest you don't need to dwell on this particular instance too much, at least not until it crops up as the Reader monad :)
18:17:22 <Eduard_Munteanu> redscare: because ReaderT has a MonadState instance
18:17:28 <Iceland_jack> there are more important and more intuitive instances of applicative functors
18:17:45 <benzrf> dammit whenever I think I understand a typeclass a weird instance comes along and knocks me for a loop
18:17:51 <benzrf> D:<
18:17:54 <benzrf> usually the instance for functions
18:18:20 <lispy> understanding the function instance of Reader is a really good learning moment
18:18:30 <Iceland_jack> That is true though
18:18:34 <redscare> so do all of the standard transformers have Monad* instances?
18:18:45 <mm_freak> redscare: in mtl
18:19:04 <stephenmac7> Iceland_jack: benzrf: mm_freak: Thanks for all your help!
18:19:04 <copumpkin> dobblego: in idris and SHE :)
18:19:05 <Iceland_jack> if stephenmac7 were to go through the type for return and (>>=) and translate it to ((->) r) it would no doubt be fruitful
18:19:05 <lispy> benzrf: I don't rely on that instance in "real code"
18:19:16 <mm_freak> redscare: mtl is a type-classy interface to 'transformers' with all the instances you need to get along without lifting =)
18:19:22 <stephenmac7> It isn't common that I ask for something in an IRC and get not one, but three people helping
18:19:37 <copumpkin> there used to be a quote about that in here
18:19:39 <Iceland_jack> What, only three??
18:19:40 <mm_freak> redscare: in fact i prefer to write "(MonadReader X m, MonadWriter Y m) => m ()" instead of a specific monad =)
18:19:42 <benzrf> stephenmac7: #haskell is magic
18:19:45 <Iceland_jack> we're losing our touch :)
18:19:45 <Iceland_jack> No problem stephenmac7, happy Haskelling
18:19:54 <lispy> ?quote stereo
18:19:54 <lambdabot> geheimdienst says: data Stereoloid = BanachTyvski | CoBanachTyvski
18:19:55 <benzrf> it is like
18:20:01 <lispy> booh, not the quote I wanted
18:20:03 <benzrf> the inverse of #ubuntu or something
18:20:04 <redscare> so then there's a lot of boilerplate in the MTL?
18:20:33 <mm_freak> redscare: indeed
18:20:42 <stephenmac7> [21:14:29] <Iceland_jack> if stephenmac7 were to go through the type for return and (>>=) and translate it to ((->) r) it would no doubt be fruitful
18:20:48 <redscare> it just seems to detract a bit from the "elegance" of haskell if that's /required/.
18:20:55 <Eduard_Munteanu> redscare: the instances are quite straightforward though
18:21:00 <mm_freak> redscare: it's not required…  mtl is a convenience
18:21:03 <stephenmac7> Iceland_jack: How would I do that?
18:21:18 <redscare> mm_freak: i mean that there's no way to provide the features of the MTL without boilerplate
18:21:44 <mm_freak> redscare: haskell's elegance may be responsible for that
18:21:49 <Iceland_jack> stephenmac7: Well basically replace every occurrence of “m X” in the type signature with “(r → X)”
18:21:54 <Polarina> benzrf, Our selfish desires for attention has turned this channel into a flock of humans competing to be the greatest helper.
18:21:59 <Iceland_jack> so for return:
18:21:59 <Iceland_jack> @type return
18:22:00 <lambdabot> Monad m => a -> m a
18:22:11 <Iceland_jack> @type return :: a -> (r -> a)
18:22:12 <lambdabot> a -> r -> a
18:22:12 <benzrf> Polarina: MAN I know that feelin
18:22:13 <redscare> it just seems somehow natural that "get" should propagate through non-State transformers, and so the implementation should be "elegant". But this is very hand-wavy anyway
18:22:18 <Eduard_Munteanu> redscare: there's some 'deriving' magic to do it automatically for some thing.
18:22:22 <Eduard_Munteanu> *things
18:22:26 <amalloy> so i've been thinking of writing a card-game-playing engine of sorts, mainly as an exercise to practicee haskell, and i'm a little puzzled about the "right" way to get user input in the middle of a turn. suppose i'm playing a game where, anytime your opponent plays an ace, you may, if you like, discard a two. how do i get that user-choice into the the middle of a turn, without making the entire game engine run in IO?
18:22:41 <Iceland_jack> Return just creates a constant function from an initial value
18:22:45 <mm_freak> redscare: you can get the same functionality with far less boilerplate if you allow UndecidableInstances
18:22:57 <stephenmac7> Iceland_jack: I see
18:22:59 <Iceland_jack> > (return 5) "Ignore me"
18:23:00 <lambdabot>   5
18:23:05 <Iceland_jack> And you can inger that from the types
18:23:05 <erisco_> Polarina, if there is any justification for selfishness, that is the best I've found
18:23:07 <mm_freak> redscare: mtl chose not to do that
18:23:14 <benzrf> so lately ive been reading land of lisp
18:23:19 <Iceland_jack> stephenmac7: Now try doing the same with (>>=) :)
18:23:19 <Iceland_jack> @type (>>=)
18:23:20 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:23:22 <benzrf> and it feels sort of like bizarro haskell
18:23:23 <stephenmac7> return 5 >>= Just
18:23:27 <stephenmac7> Ah
18:23:36 <stephenmac7> Just a second
18:23:37 <Iceland_jack> s/inger/infer/
18:23:42 <Iceland_jack> No problem
18:23:47 <mm_freak> amalloy: make it a function of the user's input
18:23:51 <benzrf> Ill be reading some function that looks like haskell but with sexprs, then out of nowhere, BAM mapping list mutation instead of a fold
18:23:55 <benzrf> its kind of jarring
18:24:13 <Iceland_jack> Common Lisp isn't very similar to Haskell
18:24:24 <Iceland_jack> Actually rather unfamiliar
18:24:28 <Iceland_jack> *unsimilar
18:24:31 <benzrf> i guess it's just that haskell is my only majorly FP language
18:24:32 <benzrf> :p
18:24:41 <stephenmac7> Just a little more time..
18:24:42 <redscare> common lisp is decidedly not fp
18:24:49 <benzrf> it's PRETTY fp
18:24:49 <Iceland_jack> exactly
18:24:51 <mm_freak> benzrf: do you want to learn FP or haskell-FP? ;)
18:24:58 <benzrf> mm_freak: both pls
18:25:04 <Iceland_jack> benzrf: Common Lisp is pretty FP?
18:25:13 <mm_freak> benzrf: they are utterly incompatible
18:25:16 <redscare> benzrf: you just CAN do FP in common lisp
18:25:24 <stephenmac7> (a -> r) -> (a -> (b -> r) -> (b -> r)
18:25:32 <stephenmac7> I don't think that's right
18:25:33 <redscare> benzrf: but the common lisp spec doesn't even require tail recursion (although SBCL provides it)
18:25:40 <mm_freak> stephenmac7: well, it's a syntax error =)
18:25:43 <Iceland_jack> stephenmac7: You need a closing parentheses somewhere there :P
18:25:49 <stephenmac7> *(a -> (b -> r))
18:25:50 <mm_freak> stephenmac7: would be worrying if that were right =P
18:26:06 <benzrf> the point is that CL is way way more FP than python
18:26:06 <benzrf> :D
18:26:23 <Iceland_jack> stephenmac7: Why is "r" on the right side?
18:26:25 <mm_freak> benzrf: i'm not going to argue whether CL is FP or not
18:26:37 <stephenmac7> Iceland_jack: that would be a problem
18:26:43 <mm_freak> benzrf: but the styles you use in haskell vs. CL are very different
18:26:44 <benzrf> mauled indentation, but this function: http://bpaste.net/show/140543/
18:26:47 <benzrf> yeah
18:27:02 <stephenmac7> @type (>>=)
18:27:02 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:27:06 <benzrf> but there's enough similarity vs. say python that it feels similar for a moment then I get knocked back
18:27:17 <Iceland_jack> stephenmac7: remember that "m a" should become "r → a", not "a → r"
18:27:18 <stephenmac7> (r -> a) -> (a -> (r -> b)) -> (r -> b)
18:27:31 <Iceland_jack> right!
18:27:35 <mm_freak> in fact most FP languages desparately need tail call optimization
18:27:35 <Iceland_jack> let's test your solution stephenmac7
18:27:37 <spaceships> people seem to think monadic haskell looks like python
18:27:38 <Iceland_jack> @ty (>>=) :: (r -> a) -> (a -> (r -> b)) -> (r -> b)
18:27:38 <Eduard_Munteanu> amalloy: with lazy I/O, you can just pretend you have the entire input available as a stream.
18:27:38 <lambdabot> (r -> a) -> (a -> r -> b) -> r -> b
18:27:44 <mm_freak> in haskell you generally don't use tail-call style at all
18:27:44 <Iceland_jack> Right, it type checks
18:27:46 <benzrf> spaceships: it does a little bit
18:27:58 <stephenmac7> Iceland_jack: Thank you, but I really have to go for a few minutes
18:28:00 <stephenmac7> Be right back
18:28:29 <Iceland_jack> No problem stephenmac7, once you get back you should see if that type signature makes sense compared to what was covered earlier
18:28:45 <Eduard_Munteanu> amalloy: but you should try structuring the input some more, and see if you can take decisions based upon something else than strings.
18:29:32 <redscare> benzrf: your code example is exactly why i suggested to be cautious saying CL is FP. Not only does your example have mutation, but it would be more efficiently written as a loop. just some things to keep in mind
18:29:42 <benzrf> redscare: there's my point
18:29:55 <mm_freak> example:  the good old fibonacci series…  i dislike the recursive examples, because they completely miss haskell style
18:29:59 <benzrf> the example was a point of how it looks at first like FP, but then I get jarred when I realize it's a closure with mutation
18:30:06 <Eduard_Munteanu> amalloy: for example, don't parse input in the middle of your game logic. Instead try to keep parsing out.
18:30:24 <benzrf> let..in, recursion, etc, BAM mutatoin
18:30:24 <mm_freak> here is fibonacci in idiomatic haskell:  fibs x y = x :> fibs y (x + y)
18:30:25 <benzrf> *mutation
18:30:25 <Iceland_jack> I'd say that you hardly get more multi-paradigm than Common Lisp, to call it functional is doing it a disservice imo
18:30:39 <mm_freak> where:  data Stream a = a :> Stream a
18:30:47 <benzrf> again, the point here is that it's much more functional than a lot of mainstream languages
18:30:54 <benzrf> in particular, python
18:30:58 <benzrf> [my language of choice]
18:31:24 <mm_freak> in other words, i don't put "FP languages" and haskell in the same basket
18:31:35 <benzrf> hmm, really?
18:31:47 <benzrf> frankly...
18:31:50 <benzrf> given my background, recursion looks like FP to me
18:31:52 <benzrf> >_>
18:32:07 <mm_freak> strict semantics FP
18:32:13 <mm_freak> where recursion is your only option
18:32:20 <mm_freak> the addition of nonstrict semantics completely changes your coding style
18:32:43 <benzrf> yeah
18:33:13 <mm_freak> just compare idiomatic haskell to idiomatic scheme
18:33:17 <mm_freak> there is almost no similarity
18:33:24 <benzrf> hmm
18:33:26 <mm_freak> and i'm not talking about syntax here
18:33:54 <mm_freak> consider reading a file:  in scheme you would write a recursive loop
18:34:00 <mm_freak> in haskell you would write a coroutine
18:34:53 <benzrf> i do not know coroutines
18:34:55 <benzrf> ...
18:35:33 <mm_freak> well, more precisely you would use one of the streaming abstractions and write a file reader using it
18:36:08 <benzrf> i have a strong feeling that i will never know enough haskell to write anything nontrivial in it
18:36:13 <mm_freak> the file reader would not know where the read data goes and what happens to it
18:36:25 <mm_freak> python approximates this style using generators
18:36:26 <benzrf> but at least it has helped stretch my brain a little
18:36:27 <benzrf> ;-;
18:36:55 <yogurt_truck> benzrf: why though?
18:37:23 <benzrf> because i can barely understand the super basics after about six months
18:37:23 <benzrf> >_>
18:37:33 <geekosaur> benzrf, I felt that way when I was starting. then I started helping out with xmonad (initially in a non-haskell capacity; sjanssen needed help figuring out fine points in the x11 window management stuff)
18:37:44 <mm_freak> benzrf: i've picked an advanced example, but the basic principle is simple enough:  you encode your algorithms in up to three steps:  data generation (unfold), data transformation, data consumption (fold)
18:38:07 <mm_freak> benzrf: you want the 500th fibonacci number?  don't write a recursive fibonacci function!
18:38:22 <geekosaur> there is really no substitute for actually doing useful things in haskell, even simple ones
18:38:22 <mm_freak> write a stream of fibonacci numbers, then just pick the 500th element from it
18:39:47 <mm_freak> benzrf: this one doesn't have a transformation step, but here is another example:  you want to find the first three square integers that are larger than 100
18:39:53 <mm_freak> in most other languages you would write a tight loop
18:40:04 <mm_freak> in haskell you would start with all positive integers
18:40:12 <mm_freak> > [1..]
18:40:14 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
18:40:16 <mm_freak> you want the squares
18:40:19 <yogurt_truck> mm_freak: you mean that once one absorbs it, laziness totally changes the approach for solving every problem one faces, when compared to doing FP in other langs?
18:40:20 <mm_freak> > map (^2) [1..]
18:40:21 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
18:40:46 <mm_freak> drop all squares < 100, pick the first three of the remaining
18:40:59 <mm_freak> > take 3 . dropWhile (<= 100) . map (^2) $ [1..]
18:41:00 <lambdabot>   [121,144,169]
18:41:02 <Cale> yogurt_truck: At least, it gives you a lot more options for how you decompose problems
18:41:15 <mm_freak> benzrf: this coding style is haskell-specific
18:41:22 <mm_freak> it's not FP, it's haskell
18:41:33 <mm_freak> yogurt_truck: yeah
18:41:36 <Iceland_jack> The solution to mm_freak's problem would be far less compositional in a strict language
18:41:44 <yogurt_truck> Cale: right
18:41:57 <mm_freak> or rather what Cale said
18:42:02 * hackagebot hath 0.1.1 - Hath manipulates network blocks in CIDR notation.  http://hackage.haskell.org/package/hath-0.1.1 (MichaelOrlitzky)
18:42:34 <yogurt_truck> Cale: mm_freak: is this related to the idea of non-deterministic programming, and things like the Curry language?
18:43:21 <benzrf> welp
18:43:23 <mm_freak> nonstrict semantics together with lazy evaluation make this not only possible, but actually very efficient
18:43:25 <benzrf> my brain is full of cuk
18:43:28 <benzrf> *fuck
18:43:40 <yogurt_truck> :)
18:43:46 <mm_freak> yogurt_truck: good question =)
18:44:07 <mm_freak> yogurt_truck: to me it's related to corecursion/coinduction and recursion/induction =)
18:44:09 <benzrf> maybe it is not actually true but all too often http://i.imgur.com/t2QTEf9.png seems accurate
18:44:12 <benzrf> >.>
18:44:30 <stephenmac7> Iceland_jack: I'm back
18:44:31 <Polarina> benzrf, the light-bulb will eventually light up (then imploding into a black hole that sucks everything in).
18:44:36 <benzrf> oh noooooo
18:44:39 <stephenmac7> It does make sense
18:44:40 <Polarina> benzrf, don't worry. :)
18:44:44 <Iceland_jack> stephenmac7: Welcome back
18:44:53 <yogurt_truck> mm_freak: I see
18:44:55 <stephenmac7> ...and I think my scrollbar's broken
18:44:59 <mm_freak> benzrf: i think a sand clock would be more appropriate =)
18:45:07 <mm_freak> benzrf: with an infinite supply of sand =)
18:45:09 <stephenmac7> Because this channel is so active
18:45:30 <mm_freak> corecursive sand that is =)
18:46:08 <mm_freak> > unwords (repeat "knowledge")
18:46:10 <lambdabot>   "knowledge knowledge knowledge knowledge knowledge knowledge knowledge know...
18:46:30 <stephenmac7> Iceland_jack: Thank you so very much for your time invested in a Haskell...
18:46:37 <stephenmac7> newcomer
18:46:51 <Iceland_jack> No need to thank me, it's my pleasure
18:46:56 <benzrf> the problem with haskell is that it is labelled as programming along with things like Python, so people who know python expect to understand it, fail, and label it as really really hard
18:47:08 <benzrf> when python for example is just as hard, only completely fucking different
18:47:17 * stephenmac7 comes from the land of python
18:47:19 <benzrf> and it seems easier because you've already internalized its concepts from other languages
18:47:24 <benzrf> pythonfive
18:47:35 <mm_freak> benzrf: that may be related to the similar-looking syntax
18:47:39 <benzrf> argh
18:47:42 <mm_freak> but apart from that haskell is very different
18:47:54 <stephenmac7> Only reason I picked up haskell was...
18:48:02 <stephenmac7> Because the cover if LYAH was nice
18:48:03 <stephenmac7> :D
18:48:05 <benzrf> lel
18:48:10 <mm_freak> in fact i have difficulty using python (or any strict language)
18:48:13 <Iceland_jack> stephenmac7: That's how we get you!
18:48:36 <stephenmac7> The elephant! It's a trap!
18:48:55 <stephenmac7> At first I thought it was a political book...
18:48:57 <benzrf> it's like if you've learned how to drive cars, then you learn how to drive a truck, which seems easy to learn because you know cars, then you try to learn how to fly a plane expecting to know how because it has wheels, and since it's totally new it seems super hard
18:49:21 <benzrf> so even though the truck may be just as hard as the plane it doesnt seem like it
18:49:24 <benzrf> ~fin~
18:49:42 <stephenmac7> benzrf: Trust me, haskell has been harder to learn than my first language was
18:49:43 <yogurt_truck> well the process of learning anything is going to be affected (for better or worse) by the things you already know. haskell is perhaps one of those "forget about everything you know for a moment"-kind languages if you're coming from, like, java or something
18:49:44 <mm_freak> stephenmac7: once you feel the compulsive need to write colons and arrows, you'll know that all your base are belong to haskell
18:50:11 <thebnq> haskell is very mathematical so that background helps a lot more for some :)
18:50:15 <stephenmac7> mm_freak: I've already forgotten parenthesis in my python code multiple times
18:50:27 <Iceland_jack> The abstractions in Haskell seem to be a tripping point for many
18:50:27 <stephenmac7> thebnq: I lack in that field
18:50:46 <Polarina> The moments I catch myself writing $ instead of parenthesis in Python...
18:50:52 <benzrf> if only, if only
18:51:00 <mm_freak> stephenmac7: have you identified monoids in your python program?
18:51:09 <stephenmac7> mm_freak: I'm not quite there yet
18:51:13 <benzrf> is there a 'signs you may be a haskeller'
18:51:24 <thebnq> the sign will have plenty of arrows  >_>
18:51:34 <stephenmac7> Is that even a word? Haskeller
18:51:43 <benzrf> 'if you try to put a where clause after the class keyword in your python program, you may be a haskeller
18:51:44 <Iceland_jack> It beats Haskellista
18:51:46 <benzrf> '
18:51:52 <mm_freak> benzrf: no, but i love this post:  http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html
18:51:54 <stephenmac7> (>_>) :: (Haskeller h) => h -> h
18:51:58 <benzrf> hue
18:52:08 <benzrf> @t (>_>)
18:52:08 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
18:52:09 <pxqr> i'm searching for package like largeword but with unboxed datatypes
18:52:09 <benzrf> hmm
18:52:14 <benzrf> @type (>_>)
18:52:15 <lambdabot> parse error on input `)'
18:52:20 <pxqr> and batteries like hashable instances
18:52:56 <pxqr> seems like crypto defines it's own Word160, etc
18:53:00 <pxqr> :<
18:53:12 <mm_freak> benzrf: "_" is not allowed in operators
18:53:16 <yogurt_truck> (I've found that after doing FP for a while, solving things recursively, writing code that keeps RT, etc. when I go back to reading some of my old stuff with like some big ugly for(i=blah;i<123, j > 12; c++) { += --  } crap, it looks like total noise, honestly)
18:53:27 <thebnq> @t >.>
18:53:28 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
18:53:54 <benzrf> mm_freak: cute post
18:54:04 <mm_freak> > let (>.>) = replicate in (3 >.> 'a') <> "h!!"
18:54:05 <lambdabot>   "aaah!!"
18:54:24 <mm_freak> and the famous…
18:54:29 <mm_freak> > let 2 + 2 = 5 in 2 + 2
18:54:30 <lambdabot>   5
18:54:46 <mm_freak> you know, for large values of 2…
18:55:27 <thebnq> haha
18:55:30 <Iceland_jack> Hm, I can't get that to type check in Agda
18:55:39 <benzrf> mm_freak: wait
18:55:39 <mm_freak> Iceland_jack: what?
18:55:39 <benzrf> that is possible
18:55:40 <benzrf> wtf
18:55:42 <Iceland_jack>     proof ∶ 2 + 2 ≡ 5
18:55:42 <Iceland_jack>     proof = …
18:55:48 <Iceland_jack> I must be doing something wrong
18:55:49 <mm_freak> benzrf: it's a new function (+)
18:55:53 <thebnq> not large enough :D
18:55:56 <mm_freak> benzrf: not related to the regular (+)
18:56:12 <mm_freak> Iceland_jack: depends on your (≡)
18:56:15 <mm_freak> uhm
18:56:16 <mm_freak> _≡_
18:56:18 <benzrf> aahhhh
18:56:21 <benzrf> i see how that works
18:56:24 <benzrf> so it's like
18:56:32 <mm_freak> > let 2 + 2 = 5 in 2 + 3
18:56:33 <stephenmac7> Well, I do have to go
18:56:33 <lambdabot>   *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
18:56:36 <stephenmac7> Thanks for everything
18:56:42 * stephenmac7 is amazed by #haskell
18:56:48 <stephenmac7> ...the channel
18:56:53 <benzrf> let (+) = \x, y -> case (x,y) of (2,2) -> 5 in 2 + 2
18:56:55 <stephenmac7> The language still has some work to do
18:56:56 <Iceland_jack> and the language no doubt :)
18:57:02 <benzrf> bye stephenmac7
18:57:02 <Polarina> benzrf, it can be like: let f 2 2 = 5 in f 2 2 -- where f is (+)
18:57:08 <benzrf> yeah
18:57:12 <stephenmac7> bye
18:57:18 <Iceland_jack> take care stephenmac7
18:57:25 <mm_freak> benzrf: yeah, a very verbose version of it =)
18:57:28 <benzrf> eat plenty of typeclasses
18:57:28 * stephenmac7 forces himself to close the client
18:57:34 <stephenmac7> Iceland_jack: Good bye
18:57:34 <benzrf> they're full of types
18:57:43 <stephenmac7> benzrf: Good one
18:57:48 <benzrf> :B
18:57:49 <stephenmac7> Bye
18:57:49 <Iceland_jack> stephenmac7: You can write a Haskell program to close it
18:57:56 <stephenmac7> I'm not sure about that
18:58:07 <stephenmac7> At 10 PM my chat client gets closed!
18:58:15 <Iceland_jack> :)
18:58:22 <stephenmac7> Anyway... bye
18:58:24 <thebnq> > let (+) = (*) in 3 + 3
18:58:26 <lambdabot>   9
18:59:09 <Iceland_jack> > (do b ← (!!2); y ← (!!0); e ← (!!1); return [b,y,e]) "yeb"
18:59:11 <lambdabot>   "bye"
18:59:21 <mm_freak> stephenmac7: are you having difficulty closing your client? =)
19:00:00 <benzrf> any ops here?
19:00:04 <benzrf> somebody temporarily ban stephenmac7
19:00:40 <benzrf> Iceland_jack: wait wot
19:00:45 <benzrf> you can use unicode arrows?
19:00:46 <stephenmac7> mm_freak: Darn. You made me open it again
19:00:51 <stephenmac7> benzrf: Good idea
19:00:51 <Iceland_jack> benzrf: I believe I just did ;)
19:01:02 <benzrf> well isn't that a cute trick
19:01:03 <benzrf> :V
19:01:20 <stephenmac7> Next time, I'm turning off the server side too
19:01:23 * stephenmac7 leaves again
19:01:34 <mm_freak> stephenmac7: we'll see =)
19:01:41 <Polarina> I fear he'll be back.
19:01:51 <mm_freak> benzrf: my editor displays many symbols as unicode
19:02:17 <benzrf> hmm
19:02:22 <benzrf> in ghci it fails to ←
19:02:32 <benzrf> Prelude> foo ← getLine
19:02:32 <benzrf> <interactive>:4:1: Not in scope: `foo'
19:02:32 <benzrf> <interactive>:4:5: Not in scope: `←'
19:02:38 <Iceland_jack> > sequence (map (flip (!!)) [22,7,24,7,0,21,4,13,19,24,14,20,11,4,5,19,24,4,19]) ['a'..'z'] -- stephenmac7
19:02:39 <lambdabot>   "whyhaventyouleftyet"
19:02:40 <Polarina> benzrf, it's an extension.
19:02:44 <benzrf> ah
19:02:51 <mm_freak> benzrf: do you use emacs?
19:02:59 <benzrf> HELL NO
19:03:04 <stephenmac7> Iceland_jack: You made me reopen
19:03:05 <benzrf> VIM4LYFEWOOOOO
19:03:09 <Polarina> benzrf, ghci -XUnicodeSyntax
19:03:11 <stephenmac7> WHY???
19:03:42 <Iceland_jack> > mapM (flip (!!)) [3,14,13,19,1,11,0,12,4,12,4] ['a'..'z'] -- stephenmac7
19:03:44 <lambdabot>   "dontblameme"
19:03:54 <stephenmac7> Okay, this time, I'm turning off the quassel daemon
19:04:08 <benzrf> JUST CLOSE YOUR CLIENT
19:04:11 <stephenmac7> I did
19:04:15 <benzrf> sever the t c p connection
19:04:19 <stephenmac7> But for some reason my computer beeps
19:04:20 <Iceland_jack> > mapM (flip (!!)) [17,4,18,13,14,13,21,4,17,1,0] ['a'..'z'] -- stephenmac7
19:04:21 <benzrf> allow yourself to quit
19:04:21 <lambdabot>   "resnonverba"
19:04:23 <benzrf> 8D
19:04:24 <Iceland_jack> anyway
19:04:26 <stephenmac7> when I get a  new message
19:04:41 <thebnq> pull the power plug :3
19:04:52 <stephenmac7> All I have to do is run: killall quasselcore
19:04:54 <benzrf> don't forget
19:04:56 <benzrf> you're here forever
19:04:58 <benzrf> :-D
19:04:59 <stephenmac7> D:
19:05:05 <Iceland_jack> #haskell is like crack apparently…
19:05:16 <stephenmac7> [Whois] stephenmac7 is logged in since 2013-10-08 20:40:32 UTC
19:05:34 <Clint> this is amazing
19:05:35 <stephenmac7> This is what's wrong ^
19:05:48 <stephenmac7> Anyway
19:05:49 <Iceland_jack> “My name is Iceland_jack, I've been Monad free for 2 weeks…”
19:05:55 <benzrf> Iceland_jack: lies
19:06:00 <benzrf> you used one just a minute ago
19:06:01 <Iceland_jack> “Haven't touched the applicative stuff.”
19:06:01 <stephenmac7> sleep 5 $ killall quasselcore
19:06:08 <stephenmac7> Wait
19:06:09 <benzrf> ahahhaah
19:06:18 <benzrf> is there a hssh
19:06:27 * stephenmac7 takes a look
19:06:28 <benzrf> I want an hssh
19:06:34 <mm_freak> "My name is Bruce Schneier.  I'm the endofunctor that turns all automorphisms into identities."
19:06:42 <benzrf> what does that even mean
19:06:45 <stephenmac7> HSSH (Hybrid ssh) is developing to transmit the large size data at high speed on the long ...
19:06:56 <mm_freak> benzrf: to bruce schneier AES looks like id
19:06:56 <stephenmac7> I don't think that's what you wan
19:06:57 <benzrf> not what REAL hssh stands for
19:06:58 <stephenmac7> *want
19:07:06 <benzrf> mm_freak: good enough
19:07:09 <Iceland_jack> benzrf: It's a joke, that's what it is
19:07:11 <mm_freak> and to bruce schneier twofish looks like id, too
19:07:13 <stephenmac7> http://www.yesodweb.com/blog/2012/03/shelly-for-shell-scripts
19:07:20 <mm_freak> RSA also looks like id
19:07:39 <benzrf> I think you can get an idea of the character of a language from the names of its major web framework
19:07:43 <benzrf> or
19:07:44 <benzrf> one of them
19:07:55 <benzrf> I was thinking of flask for python, sinatra for ruby, & yesod for hs
19:08:08 <mm_freak> benzrf: there are also happstack and snap
19:08:12 <benzrf> right
19:08:21 <benzrf> but the name yesod basically captures it just right
19:08:22 <stephenmac7> Keyword: major
19:08:23 <benzrf> :_D
19:08:28 <benzrf> stephenmac7: ok not major
19:08:29 <geekosaur> sadly the only thing "yesod" tells you is it was written by an Israeli :p
19:08:30 <benzrf> make thatm
19:08:30 <benzrf> minor
19:08:38 <stephenmac7> Yesod seems to be the number one framework for Python
19:08:42 <benzrf> pfffft
19:08:46 <stephenmac7> *Haskell
19:08:52 <benzrf> geekosaur: you sure about that?
19:09:00 <stephenmac7> I was getting my statements mixed up
19:09:09 <mm_freak> stephenmac7: not quite, but it has commercial success
19:09:09 <benzrf> not all israelis are jewish, nor are all jews into kaballah
19:09:13 <stephenmac7> Flask, however, seems to be number 3
19:09:15 <stephenmac7> for python
19:09:18 <benzrf> flask WOO
19:09:21 <benzrf> wait, what's #2
19:09:25 <stephenmac7> mm_freak: What do you mean?
19:09:30 <stephenmac7> benzrf: I thought pyramid was #2
19:09:32 <geekosaur> yes, but religious Jews are not likely to use Hebrew to name secular things
19:09:33 <benzrf> ah
19:09:46 <mm_freak> stephenmac7: i mean that yesod is /one/ of the major web frameworks
19:09:47 <stephenmac7> That stat includes Pylons and repoze.bfg
19:09:54 <carter> all three of the haskell web frameworks have some commercial usage
19:09:57 <mm_freak> stephenmac7: and it's great for getting stuff done
19:10:01 <stephenmac7> mm_freak: It's not THE major framework?
19:10:06 <mm_freak> no
19:10:17 <stephenmac7> Hm. Equal usage with snap and happstack?
19:10:18 <mm_freak> happstack, snap and yesod are THE major frameworks
19:10:51 <stephenmac7> When I get familiar with haskell, the first thing I'm doing is web frameworks
19:11:07 <carter> theres 3 good ones
19:11:10 <carter> all different
19:11:11 <stephenmac7> Didn't I say I was leaving?
19:11:16 <Iceland_jack> I believe you did
19:11:24 <carter> all making trade offs that make them valuable
19:11:29 <stephenmac7> :|
19:11:37 <stephenmac7> Now I must stay to listen to carter
19:11:42 <carter> i'm done :)
19:11:43 <mm_freak> stephenmac7: web applications form a monoid, and that's what happstack and snap are based on
19:11:46 <stephenmac7> This is the problem with this channel
19:11:51 <carter> mm_freak: monoid?!
19:11:53 <stephenmac7> mm_freak: And yesod?
19:12:01 <mm_freak> stephenmac7: yesod is less algebraic, more pragmatic
19:12:04 <carter> stephenmac7: my focus is math and fast things
19:12:08 <mm_freak> less beauty, more getting stuff done
19:12:13 <carter> mm_freak: i'd not call any of them algebraic
19:12:24 <stephenmac7> mm_freak: So, it's more like conventional frameworks?
19:12:27 <mm_freak> carter: happstack is algebraic
19:12:30 <carter> it is?
19:12:32 <carter> really?
19:12:35 <carter> how so?
19:12:41 <carter> i've not really look at it in recent tim
19:12:43 <carter> e
19:12:45 <mm_freak> stephenmac7: well, not quite
19:13:02 <carter> they're all worth playing with if you have the time
19:13:28 <mm_freak> stephenmac7: one distinguishing feature of yesod is its builtin static checks
19:13:34 <stephenmac7> The appealing thing about snap seems to be snaplets
19:13:42 <mm_freak> you get most of them for the other frameworks as well, though
19:13:43 <benzrf> i rly rly need to get to sleep
19:13:44 <carter> like, even if you like the first one you try, you should try them all
19:13:46 <stephenmac7> mm_freak: So, it's safer
19:13:49 <carter> benzrf: then go sleep
19:13:49 <benzrf> school tomorrow unu
19:13:56 <mm_freak> stephenmac7: safer than, say, django
19:13:58 <stephenmac7> benzrf: How about this. We both leave at the same time
19:13:59 <benzrf> im suffering from stephenmac7 syndrome
19:13:59 <benzrf> :B
19:14:05 <stephenmac7> :D
19:14:12 <carter> they're all safer than django probably
19:14:21 <benzrf> i try not to touch django
19:14:23 <benzrf> flask woo
19:14:24 <stephenmac7> Because haskell itself is safer
19:14:27 <carter> jah
19:14:30 <stephenmac7> I personally use Pyramid
19:14:32 <mm_freak> carter: well, once you identify something as a monoid, you're already using algebra =)
19:14:33 <benzrf> stephenmac7: safe, useless
19:14:34 <benzrf> :D
19:14:36 <stephenmac7> But we're in haskell
19:14:44 <benzrf> Pfft haskell is for lusers
19:14:49 <benzrf> PERL WOO
19:14:49 <carter> mm_freak: well, yeah, thats boring algbra though
19:15:00 <mm_freak> carter: not at all
19:15:01 <carter> i'm working on making numerical (multi)linear algebra easier :)
19:15:02 <stephenmac7> Let's not speak of these contraband frameworks in this hold channel
19:15:03 <mm_freak> i see monoids everywhere
19:15:14 <stephenmac7> *holy
19:15:15 <carter> i'm saying theres lots of richer algebras :)
19:15:15 <benzrf> ok can you think of a language more opposite of haskell than perl
19:15:18 <benzrf> which is in major usage
19:15:24 <mm_freak> carter: there is abstract algebra and numerical algebra…  i find the latter rather boring =)
19:15:24 <carter> english
19:15:31 <stephenmac7> Anyway
19:15:35 <benzrf> mm_freak: isnt the latter a subset of the former?
19:15:36 <stephenmac7> benzrf: I'm leaving in 3
19:15:42 <stephenmac7> 2
19:15:43 <carter> mm_freak: numerical algebra is really abstract algebra + functional analysis in finite dimensions
19:15:47 <stephenmac7> 1
19:15:49 <Iceland_jack> take care stephenmac7
19:15:52 <mm_freak> carter: note that category theory is another branch of abstract algebra ;)
19:15:54 <stephenmac7> Iceland_jack: Thanks
19:15:57 <stephenmac7> 0
19:15:58 <Iceland_jack> -1
19:16:04 <carter> mm_freak: mathematicians would disagree
19:16:21 <carter> they'd argue abstract algebra is usually a pretty concrete form of category theory
19:16:36 <carter> and that category theory is just a notation for studying geometry
19:17:59 <startling> they embed each other pretty trivially.
19:18:12 <startling> Categories are just an algebraic structure, right?
19:18:18 <carter> erm
19:18:20 <mm_freak> carter: "just a notation" doesn't give you axioms and theorems
19:18:23 <carter> :P
19:18:33 <mm_freak> carter: what startling said
19:18:54 <carter> i've friends who are doing exotic math that happens to use categorical language
19:19:02 <carter> but category theory winds up just being the basic vocab
19:19:24 <mm_freak> carter: we do the same, and i don't disagree about CT being a language
19:19:28 <mm_freak> but i disagree about it being "just notation"
19:19:42 <startling> numbers are just notation
19:19:43 <carter> english is just a notation for platonic ideation :)
19:19:55 <startling> math is just manipulating drawings on pieces of paper
19:20:31 <mm_freak> this is one of the cases where philosophy makes things worse ;)
19:20:56 <carter> startling: i need towork on my doodling skills some time
19:21:26 <startling> carter, this is why mathematicians have bad handwriting
19:21:29 <thebnq> definitions are hard =(
19:21:45 <Iceland_jack> let's go shopping?
19:22:12 <carter> of course!
19:22:16 <AlainODea> Any Aeson users here?
19:22:36 <startling> Probably. Best to just ask your question.
19:22:50 <carter> aeson is pretty nice
19:23:15 <mm_freak> anyway, non-intuitionistic mathematicians often disagree with me…  i maintain that CT is a branch of abstract algebra =)
19:23:18 <AlainODea> Thanks. What's a good way to turn a data type into a JSON object? Right now I have a toPair function, but that seems clumsy.
19:23:44 <AlainODea> Aeson is very nice. I'm really impressed so far. Bit of a learning curve initially, but my Haskell is rusty.
19:24:57 <carter> AlainODea: look at the examples in the docs!
19:25:31 <carter> also applicatives work out great on the parsing side
19:25:52 <mm_freak> aeson shouldn't require writing any parsers…
19:26:13 <startling> mm_freak, it doesn't! luckily it uses a type cause Parser anyhow.
19:26:25 <startling> *called
19:26:40 <carter> mm_freak: doing between the JSON AST and your haskell type
19:26:46 <carter> are still parsing
19:26:47 <AlainODea> carter: fair. I have it working. That's the easy part. I want to make it as clean as possible. I imagine some people have tricks of the trade for this
19:27:02 <carter> write the terrible thing that works correctly
19:27:06 <carter> then share the code and ask for feedback :)
19:27:12 <mm_freak> carter: similarly aeson shouldn't require you to deal with the JSON AST
19:27:17 <carter> mm_freak: depends
19:27:49 <carter> and maybe i mean it in a sense that is different than you think
19:27:50 <carter> eg
19:27:53 <carter> what about a map
19:28:01 <carter> keys 2 values
19:28:16 <carter> where teh values in the JSON encoding are either arrays of objects or an object singleton
19:29:04 <mm_freak> carter: there are FromJSON and ToJSON instances for most containers
19:29:10 <carter> mm_freak: yes
19:29:13 <carter> i know
19:29:24 <carter> i can't show you the code because it was for a client
19:29:31 <carter> point being
19:29:44 <carter> Aeson makes handlign funny javascript interopt sane
19:29:45 <mm_freak> you mean when you don't have control over the exact JSON encoding?
19:29:56 <carter> nope, client specd it
19:30:10 <AlainODea> carter: good idea. Doing that now. Yesod's magical Import module makes sharing an SSCCE harder :)
19:30:21 <carter> SSCCE?
19:30:37 <carter> AlainODea: are you one of the people on smartos?
19:30:42 <carter> #smartos?
19:30:43 <zRecursive> It seems `ghc -e "func1" Foo.hs` doesnot use Foo.o created by `ghc -c -O2 Foo.hs` ?
19:30:44 <mm_freak> well, i don't yet see any requirement to deal with the JSON AST
19:30:46 <AlainODea> Short, Self Contained, Correct (Compilable), Example. http://sscce.org/
19:30:54 <AlainODea> carter: I am
19:31:06 <carter> mm_freak: well, im explaining it wrong
19:31:17 <carter> i consider the aeson "fromJSON" to be parsing
19:31:21 <carter> from an AST
19:31:38 <carter> even if you only look at one level then fire off the right instances recursively
19:31:55 <carter> AlainODea: ah yeah, yesod is a funny critter
19:32:19 <AlainODea> carter: it seems Rails-esque, convenient but magical
19:32:53 <carter> hehe, batteries included untill you need custom batteries?
19:32:55 <mm_freak> carter: then your interpretation of fromJSON is different from mine
19:33:04 <carter> mm_freak: indeed
19:33:08 <carter> soke
19:33:16 <mm_freak> my interpretation is:  fromJSON is a broken historical accident that should be removed =)
19:33:24 <carter> what should it be instead?
19:33:55 <mm_freak> the regular generic/TH stuff that you would normally use
19:34:02 <carter> ummm
19:34:11 <carter> that doesn't work if the json format isn't custom
19:34:31 <carter> or 'm not understanding your idea maybe
19:34:48 <carter> oh well
19:34:51 <mm_freak> well, you can always express the customer's JSON format as a haskell type
19:34:59 <carter> yes
19:35:08 <mm_freak> you just have to be careful to use the proper data structures
19:35:17 <AlainODea> carter: I'm slow today. Here's my MachineJSON module that I'm trying to clean up. https://gist.github.com/AlainODea/6985602
19:35:27 <carter> mm_freak: sure, but nope
19:35:33 <carter> its not alays that simple
19:35:41 <mm_freak> yeah, i know
19:35:42 <carter> i agree that aeson could be awesomer
19:36:02 <carter> but i think your approach would just mean i'd have to have 2 haskell side models
19:36:05 <mm_freak> in fact fromJSON will be removed
19:36:06 <carter> one for specing the json parsing
19:36:17 <carter> and then mapping that to my actual haskell data model
19:36:24 <mm_freak> yeah
19:36:27 <mm_freak> exactly
19:36:29 <carter> yes
19:36:33 <carter> aeson lets me do that :)
19:36:44 <luite> hm
19:36:50 <mm_freak> and it doesn't require fromJSON for that ;)
19:37:22 <carter> i'm going to read AlainODea's code and do math for a while :)
19:37:26 <carter> luite: sup
19:37:47 <luite> i need a faster laptop now that i can run ghcjs on os x :p
19:38:10 <carter> luite: how old is your laptop?
19:38:16 <AlainODea> mm_freak: I've got a relatively complex working example of writing JSON. I haven't tried reading it yet. Would GenericNewTypeDeriving derive sensible FromJSON instances?
19:38:20 <luite> over 2y!
19:38:44 <carter> AlainODea: good question
19:38:44 <mm_freak> AlainODea: i think so
19:38:50 <carter> yeah
19:38:54 <carter> should jsut be the underlying type
19:39:01 <mm_freak> AlainODea: you'll get the same JSON representation as the underlying type
19:39:06 <carter> AlainODea: looks like decent code
19:39:18 <carter> not "slick" but definitely clear and solid
19:39:55 <AlainODea> carter: cool. That'll work for me. I'll hold myself to a higher standard as time goes on. Thank you for reviewing it :)
19:39:59 <luite> carter: it's 2.0 ghz sandy bridge quad
19:40:46 <hamishmack> luite: That is cool (ghcjs on OS X)
19:40:58 <luite> hamishmack: yeah finally!
19:41:03 <luite> now windows
19:41:23 <carter> AlainODea: no problem
19:41:47 <carter> AlainODea: i'm nearing release for a library who's API i spent > 18 months thinking about how to have a good api
19:41:59 <carter> and that i want people to actually adopt
19:42:08 <carter> i'm a tad unproductively ocd about good code
19:42:14 <carter> you're starting off fine
19:42:23 <luite> recent ghc appears to stack overflow more than older
19:42:54 <carter> luite: head or?
19:43:12 <mm_freak> carter: i can beat that…  it took more than two years to stabilize netwire's API =)
19:43:58 <carter> mm_freak: i can beat that: i anticipate needing to make breaking changes at least twice in the year following whenever i get this out :P
19:44:05 <TallerGhostWalt> mm_freak net wire is amazing
19:44:16 <luite> carter: yeah got some overflows that i'd never seen before, like for genprimopcode
19:44:30 <luite> and some during the native code run in the ghcjs tetsutite
19:44:32 <djahandarie> mm_freak, ever end up making progress on that new version of fastirc?
19:44:47 <mm_freak> TallerGhostWalt: =)
19:44:50 <carter> i should check out netwire some time
19:44:56 <carter> but finite timeeeee
19:45:08 <mm_freak> djahandarie: i hardly get to work on netwire right now…  version 5 is almost ready for release
19:45:08 <carter> when will someone cook up a good declarative gui dsl?
19:45:14 <carter> gui's scare me
19:45:26 <djahandarie> mm_freak, aw. Oh well.
19:45:36 <djahandarie> Glad you still have time for netwire at least!
19:45:51 <TallerGhostWalt> my biggest code problem is biting off more than I can chew
19:46:06 <carter> TallerGhostWalt: whats the biggest bite you've tried to take?
19:47:03 <startling> Does cabal have a thing for haddocking?
19:47:20 <carter> cabal haddock
19:47:25 <startling> Genius.
19:47:30 <TallerGhostWalt> carter: took over maintenance for a very successful startup with back end in c# front end in pho
19:47:32 <carter> you could have done cabal --help
19:47:34 <TallerGhostWalt> pho
19:47:39 <carter> pho?
19:47:41 <TallerGhostWalt> php
19:47:45 <carter> ah
19:47:47 <TallerGhostWalt> stupid ac
19:47:50 <AlainODea> carter: nice. I like that approach. Too many libraries are just released without deep thought about the API.
19:48:19 <TallerGhostWalt> yeah decided to port it all to haskell
19:48:35 <edwardk> bah. my visions of writing c# in a vietnamese noodle establishment are dashed.
19:48:44 <carter> me too
19:48:58 <TallerGhostWalt> haha
19:49:04 <AlainODea> TallerGhostWalt: autocorrect is right to correct PHP to something else, almost anything else :D
19:49:11 <TallerGhostWalt> hehe
19:49:17 <startling> carter, that's true.
19:49:23 <startling> Where does cabal haddock put the haddocks?
19:49:35 <carter> probably in the dist folder
19:49:44 <edwardk> jfischoff is slowly autocorrecting all of the php at his workplace to haskell
19:49:48 <startling> carter: nope.
19:49:55 <AlainODea> that's not entirely fair, but my experience is that PHP spirals out of control without very strong code review and bounds on where it works and doesn't
19:50:21 <edwardk> AlainODea: i agree, though i suspect that i'd draw the lines on where it works very differently ;)
19:50:26 <startling> carter: oh, no, you're right.
19:50:43 <Bergle_1> Hi, im pretty new to haskell, I am hunting around for test runner that reruns test [hspec or hunit] when files are saved ?
19:51:04 <startling> carter: somehow I ignored the line of output that said 'setup: Run the 'configure' command first.' and just assumed it worked. :/
19:51:17 <mm_freak> Bergle_1: my Makefile runs "cabal test" after each "cabal build"
19:51:30 <Bergle_1> on windows :) not a make friendly place in general.
19:51:46 <Bergle_1> but thats not running stuff after a save as such is it ?
19:51:59 <mm_freak> Bergle_1: after saving you want to compile anyway
19:52:02 <edwardk> Bergle_1: you can configure vim to run things on save
19:52:09 <mm_freak> otherwise you run old tests =)
19:53:12 <Polarina> Is there a more efficient way to figure out how to do something with lens other than trying every combination of operators until it works?
19:53:12 <mm_freak> Bergle_1: you could install mingw/msys to get GNU make
19:53:18 <edwardk> e.g. adding a line like:       au BufWritePost *.hs silent! :exec ":!executesomecommandhere"
19:53:23 <mm_freak> i can't imagine writing code without 'make'
19:53:40 <edwardk> Polarina: well, asking helps, that often gives you insight into why things are the way they are =)
19:54:41 <Polarina> Ok. I have two values of the type { Maybe a }. I want to modify the former to take the value of the latter only if the former is Nothing and the latter is Just a.
19:55:56 <mm_freak> Polarina: former = former' <|> latter
19:56:09 <mm_freak> where former' is the current former
19:56:24 <Polarina> mm_freak, you embarrass me sometimes. :)
19:57:11 <mm_freak> Polarina: something along the lines of (untested!): x & former .~ (x ^. former <|> x ^. latter)
19:57:40 <Polarina> mm_freak, what would x be?
19:57:50 <mm_freak> the value you want to change =)
19:58:04 <Polarina> Then what's former? o.O
19:58:30 <mm_freak> i was assuming that you have the two Maybes as part of some larger structure
19:58:46 <Polarina> Yes.
19:58:49 <mm_freak> otherwise:  former = former' <|> latter
19:58:50 <mm_freak> =)
19:59:23 <startling> Someone should write a hackage mirror that uses HEAD for everything.
20:01:59 <Polarina> Uhm, how would I do this if former is a lens?
20:02:10 <mm_freak> > (\x -> x & _1 .~ (x ^. _1 <|> x ^. _2)) (Just 1, Just 2)
20:02:13 <lambdabot>   (Just 1,Just 2)
20:02:17 <mm_freak> > (\x -> x & _1 .~ (x ^. _1 <|> x ^. _2)) (Nothing, Just 2)
20:02:19 <lambdabot>   (Just 2,Just 2)
20:02:26 <mm_freak> Polarina: like that?
20:02:46 <Polarina> That looks overly complicated...
20:03:04 <edwardk> x & former %~ (<|> x^.latter)
20:03:23 <mm_freak> yeah, that's better
20:03:25 <edwardk> or:    over former (<|> x^.latter) x
20:03:26 <startling> there's no <|>~?
20:03:42 <mm_freak> > (\x -> x & _1 %~ (<|> x ^. _2)) (Nothing, Just 2)
20:03:45 <lambdabot>   (Just 2,Just 2)
20:04:00 <mm_freak> Polarina: it looks awkward, because the names the lens package uses are awkward =)
20:04:03 <edwardk> startling: nah. it has ambiguity issues with the conventions we adopt. since <op=    is the version that returns (a summary of) the value it changed.
20:04:05 <mm_freak> "_1", seriously
20:04:16 <Polarina> Yay! I got a type error I understand!
20:04:18 <startling> edwardk: but <>~ doesn't?
20:04:32 <blackdog> any recent benchmarks on hashtables/Maps? looking for a Set-like structure I can throw ~5gb of data at & check for membership - all insertion happens first, so non-ephemeral-ness is not a requirement.
20:04:33 <mm_freak> i didn't like underscores before lens, now i really hate them
20:04:37 <edwardk> startling: special case, besides <<>~ looks like a rat and is kinda cute
20:04:48 <startling> :)
20:04:52 <Polarina> And it compiled.
20:04:55 <elliott> edwardk: we could have a (>~).
20:04:55 <startling> cabal sandbox is so nice.
20:05:02 <elliott> edwardk: just saying.
20:05:07 <mm_freak> blackdog: so a create-once-then-query data structure?
20:05:10 <blackdog> mm_freak: yep.
20:05:26 <mm_freak> blackdog: i've written a small library called quickset for that purpose
20:05:29 <blackdog> and no payload, just inhabited-or-not
20:05:30 <mm_freak> @hackage quickset
20:05:30 <lambdabot> http://hackage.haskell.org/package/quickset
20:05:35 <edwardk> elliott: well we're largely saved from that from the source and result types being different, otherwise we'd have to decide how to deal with the conflict for (>=) =)
20:05:40 <Polarina> startling, sandboxes? Real men rm -rf ~/.cabal ~/.ghc
20:05:46 <edwardk> elliott: and yes i realize you can define if for Bool
20:05:48 <blackdog> mm_freak: thank you, that looks perfect.
20:05:48 <edwardk> =)
20:05:50 <edwardk> er it for
20:06:09 <blackdog> mm_freak: have you benchmarked it+
20:06:09 <elliott> edwardk: very useful operator that would be
20:06:11 <mm_freak> blackdog: it's not very powerful, but very compact and fast
20:06:17 <startling> Polarina, only if I've got nothing scheduled for the rest of the week.
20:06:32 <mm_freak> blackdog: yes, but i don't remember the exact numbers
20:06:48 <mm_freak> blackdog: should be faster than Set/IntSet by a factor of 10-10000 depending on your application =)
20:07:01 <blackdog> mm_freak: it looks like it has everything i need :)
20:07:18 <mm_freak> blackdog: the downside is that it works for Unbox types only
20:07:23 <startling> mm_freak: what's it do? is it a perfect hash thingy?
20:07:46 <mm_freak> startling: it's really just a sorted vector + binary search lookup
20:07:53 <startling> Heh, neat.
20:08:22 <mm_freak> interestingly it outperforms libc's bsearch() =)
20:08:33 <startling> nice!
20:08:37 <Polarina> mm_freak, bsearch uses a function pointer.
20:08:46 <mm_freak> yeah, that explains it
20:09:07 <Polarina> And it works on pointers, adding another layer of indirection.
20:09:17 <startling> oh, it's probably a cache thingy?
20:09:24 <mm_freak> well, the haskell variant has that indirection as well
20:09:26 <blackdog> ... that reminds me, i think my perfect hash wrapper is still on hackage :) is slow to build though.
20:09:53 <mm_freak> i agree that it's probably a cache thing
20:10:25 <mm_freak> but i don't understand CPU caches very well
20:10:49 <rohan_> I'm trying out lens; putStr $ "Test"^.. taking 10000000 (cycled traverse) is about eight times as slow as the equivalent using list functions. Am I doing something wrong? Is there a fix?
20:11:25 <mm_freak> rohan_: how do you even benchmark that?
20:11:29 <edwardk> taking is unfortunately not the most high performance bit of lns
20:11:31 <edwardk> er lens
20:11:45 <rohan_> mm_freak: umm, unix time?
20:11:46 <edwardk> it is forced to inject a state parameter into the traversal
20:12:06 <mm_freak> and yes, lens has a cost…  if you need efficiency and still want to work with lenses, i suggest using the old data-lens package
20:12:24 <edwardk> well, data-lens can't do this so the point is moot
20:12:31 <mm_freak> right
20:13:01 <edwardk> lens is generally faster than data-lens in my experience, so that strikes me as an odd claim
20:13:30 <mm_freak> edwardk: perhaps because specialization kicks in for you more often
20:13:37 <edwardk> we much more aggressively inline, so anything remotely monomorphic wins for lens
20:14:03 <edwardk> we also do things like unsafeCoerce like crazy, so take that for what its worth
20:14:22 <mm_freak> well, my last benchmark was before lens 3.8
20:14:26 <edwardk> ah
20:14:47 <mm_freak> but it seemed to make sense anyway, since data-lens is really just a thin layer around regular getter/setter functions
20:15:21 <blackdog> mm_freak: ... so, next qusetion: what string-like key types have instances for Unbox? :)
20:15:50 <mm_freak> blackdog: none as far as i know
20:16:05 <blackdog> ah, so if i want bytestrings, i have to convert them to Vector Char or something?
20:16:08 <edwardk> the issue is more that its harder for the compiler to tease apart the s -> (a, a -> s)   into separate functions and discard the latter than it is for it to notice the lack of application of the second function when it is being passed to Const. the former has to notice and do things differently with a data type, the latter is just a few steps of inlining
20:16:11 <mm_freak> blackdog: Unbox instances need to be constant-size
20:16:27 <edwardk> once it inlines Const's fmap, the rest of free
20:16:29 <blackdog> mm_freak: i can pad, that's not an issue.
20:16:30 <mm_freak> blackdog: rather to Word64 =)
20:16:45 <mm_freak> blackdog: you can use the hashable package
20:16:51 <Polarina> blackdog, you could try a Ptr.
20:17:09 <blackdog> mm_freak: oh, good point.
20:17:29 <mm_freak> blackdog: but remember that hashes clash, and quickset does not compensate
20:17:38 <mm_freak> keep the birthday paradox in mind
20:17:51 <blackdog> mm_freak: ah, point. ok, maybe this isn't the data structure for me after all.
20:18:11 <rohan_> edwardk: are there more restrictive types that I could use for which the implementation is faster?
20:18:14 <mm_freak> blackdog: if your keys are short enough, you can still turn them into Word64
20:18:24 <carter> my little lens, iso's are magic
20:18:25 <blackdog> they're not necessarily short. domain names.
20:18:53 <carter> blackdog: would hashtables make sense?
20:19:00 <edwardk> rohan_: not for taking. taking is mostly there because it is occasionally useful. its not on the high performance end of the spectrum. (most of the fold combinators admittedly aren't)
20:19:39 <edwardk> rohan_: they are there because the theory says they should exist, and we worked hard to make them work at all, but they don't inline well enough to eliminate all their performance overhead.
20:19:48 <blackdog> carter: i'll test a few. problem is that it's a lot of data to hold in memory.
20:20:11 <mm_freak> blackdog: for data structures of this size you may want to consider using a DBMS =)
20:20:17 <mm_freak> there are good haskell bindings to postgresql =)
20:20:27 <blackdog> mm_freak: heh. yeah, eventually.
20:20:29 <carter> or sqlite can be zippy i hear
20:20:31 <edwardk> rohan_: there is a tension with 'taking' in particular that it needs to work even when the underlying traversal/fold is infinite. this leads to a design that doesn't have the best performance characteristics, but if we didn't use that design your example would have failed!)
20:21:03 <blackdog> carter: we use sqlite very heavily :)
20:21:34 <mm_freak> i don't recommend sqlite for > 1 GiB
20:22:33 <carter> i know ntohign
20:22:41 <mm_freak> in fact i don't really recommend it at all =)
20:22:59 <mm_freak> if your data is small, use acid-state, if it's large, use postgresql =)
20:23:07 <blackdog> mm_freak: it's useful as a storage mechanism for us - then again, we write 10k entries, tie it off, then start a new db :)
20:23:14 <edwardk> taking is forced to go through BazaarT, peel off a prefix of the traversal and reassemble the result. this actively gets in the way of it optimizing out =(
20:23:47 <blackdog> mm_freak: the distribution story with postgres was still a bit terrible last time i looked.
20:23:53 <rohan_> edwardk: what a pity :(
20:23:55 <edwardk> taking n l pafb s = outs b <$> traverse (corep pafb) (take n $ pins b) where b = l sell s  -- winds up using 'b' twice once in the (<$>) once in the right hand side. -- this makes it hard for the inliner to decide to inline (l sell s) when we're just using it as a Fold, like you are there.
20:24:18 <mm_freak> blackdog: i doubt that sqlite is any better there ;)
20:24:24 <edwardk> in your case, as a fold, the stuff on the left hand side of the <$>  isn't used at all
20:24:35 <mm_freak> blackdog: more seriously it has improved a lot there over recent years
20:24:44 <edwardk> since fmap _ (Const a) = Const a
20:24:56 <blackdog> mm_freak: well, the difference is that you can just dedicate a database to every thread
20:25:10 <blackdog> then treat the db files as elements to be processed
20:25:29 <blackdog> it's a bit janky, but all the distributed db bindings i've tried for haskell have been pitifully slow
20:25:35 <edwardk> so taking winds up slowed down by a somwhat expensive 'corep' call, and having to use 'sell' to build the BazaarT
20:25:46 <blackdog> i have a half-completed blog entry there, i should finish it and get some criticism.
20:25:47 <mm_freak> blackdog: that's possible with postgres as well and usually with much better performance…  just open multiple connections to the server
20:26:13 <blackdog> mm_freak: i don't think we'd actually have enough network bandwidth for that
20:26:31 <blackdog> we have 50 bots chuckin 40mb/s each
20:26:36 <edwardk> in your case you don't use the index either, so 'pins' is making a list of pairs where you only look at the second element of each pair as well
20:26:55 <edwardk> we might be able to improve that portion of taking
20:26:59 <edwardk> by using conjoined
20:27:17 <edwardk> that would let you avoid paying for the indexing, and might net you a factor of 2
20:27:20 <mm_freak> blackdog: why network?  you'd just use it locally like sqlite
20:27:48 <blackdog> mm_freak: oh, an instance of postgres on each bot?
20:28:02 <mm_freak> blackdog: on each host
20:28:09 <startling> Hey, does cabal sandbox have an uninstall thing?
20:28:17 <mm_freak> blackdog: if you have multiple bots on each host, they can share the running instance
20:28:23 <carter> startling: it just has delete the sandbox and start anew :)
20:28:23 <mm_freak> they can and should
20:28:24 <carter> i think
20:28:25 <blackdog> yeah, i guess that's possible. but when i move it to a more serious db i'd really like to have the coalescing done too, so we can collect all the domains that redirect to a particular place.
20:28:37 <startling> carter, in true haskell packaging tradition
20:28:44 <blackdog> mm_freak: sorry, by "bot" i mean host. I have 50 physical boxes, a bot on each.
20:28:46 <zRecursive> @where rts-xc
20:28:46 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
20:28:47 <carter> its functional :P
20:28:53 <rohan_> edwardk: my hope was that you could use these functions to consume bytestrings and the like efficiently.
20:29:08 <mm_freak> blackdog: i have a feeling that your clients are very similar to mine =)
20:29:24 <edwardk> rohan_: for some operations on bytestrings we're quite competitive, for some others not so much
20:29:25 * mm_freak writes bots all the time
20:29:28 <blackdog> mm_freak: maybe? :) who do you hack for?
20:29:40 <mm_freak> blackdog: i'm self-employed
20:29:59 <blackdog> ah, freelancer?
20:30:04 <mm_freak> yeah
20:30:14 <carter> mm_freak: as am I
20:30:24 <zRecursive> mm_freak: self-employed is great. but who paid you ?
20:30:25 <carter> takes a bit of work having good freelance deal flow :/
20:30:28 <edwardk> rohan_: the main thing lens optimizes for is programmer time / flexibility, we do try to keep an eye on the wallclock though. i'm taking a whack at improving taking right now.
20:30:30 <mm_freak> it's almost the only way to get a haskell job in germany =)
20:30:41 <carter> ah
20:30:42 <carter> neat
20:31:35 <NemesisD> i find myself needing a reader/writer monad w/ different types but not quite MonadRWS
20:31:47 <rohan_> edwardk: it's great in any case that one can get expert support so easily. :)
20:32:03 <mm_freak> zRecursive: i prefer not to reveal that =)
20:32:17 <edwardk> rohan_: there is also the #haskell-lens channel, which has a rather disturbingly large number of folks who know whats going on who can help as well.
20:32:36 <carter> plus people who hang out on *lens because tis fun :)
20:32:40 <zRecursive> mm_freak: i envy you
20:32:53 <startling> NemesisD, no reason not to use RWS with () as the State.
20:32:54 <Polarina> edwardk, sounds like the scary door.
20:32:56 <carter> having good freelance deal flow takes some works
20:33:01 <edwardk> rohan_: okay, i have an alternative implmentation of taking i'd like to have you try out in your benchmark
20:33:11 <edwardk> rohan_: let me hpaste it
20:33:19 <edwardk> rohan_: i'm putting it in lens HEAD
20:33:22 <mm_freak> carter: indeed, but haskell hacking has a big advantage:  your stuff works amazingly well, so people always come back to you =)
20:33:29 <carter> ahhh
20:33:38 <NemesisD> startling: as opposed to type aliasing for statet/readert?
20:33:47 <carter> what type of businesses do you have as clients?
20:33:48 <startling> NemesisD: you should probably be using MonadWriter, MonadReader in your type signatures.
20:33:59 <mm_freak> carter: small to medium
20:34:04 <carter> ah
20:34:06 <carter> web or other?
20:34:17 <blackdog> ha. so, how do you call readFile on a fifo? i'm getting comm: /dev/fd/63: hFileSize: inappropriate type (not a regular file)
20:34:25 <NemesisD> i'm guessing that would be something like ReaderWriterT r w m a = ReaderT r (WriterT w m a) a?
20:34:26 <mm_freak> web mostly, but not for web application dev
20:34:35 <startling> :t hGet -- blackdog
20:34:36 <lambdabot>     Not in scope: `hGet'
20:34:36 <lambdabot>     Perhaps you meant one of these:
20:34:36 <lambdabot>       `BSC.hGet' (imported from Data.ByteString.Char8),
20:35:08 <blackdog> ah, righto
20:35:17 <startling> NemesisD, write all your type signatures for MonadWriter and MonadReader; use runRWS when you want to run it
20:35:25 <edwardk> rohan_: if you pull from github.com/ekmett/lens.git  the 3.10-maintenance branch i think i've patched taking in such a way that it should run faster for your usecase.
20:35:49 <edwardk> rohan_: i' going to go through and see if i can't do something similar for the other taking-like traversals in that module.
20:36:07 <edwardk> rohan_: i was going to giv you the code in a paste to try directly, but it uses things internal to control.lens.traversal
20:36:29 <NemesisD> startling: i think in my use case i need to use newtypes because i need to declare class instances for this type
20:36:58 <startling> NemesisD, no you don't. You can add the class to your type signatures, too, and maybe make RWST an instance.
20:37:23 <startling> What classes are you talking about?
20:37:46 <NemesisD> startling: here i'll paste this monstrosity
20:37:51 <startling> NemesisD: k.
20:38:01 <carter> i should pumpkin out
20:38:01 <carter> night all
20:38:11 <carter> mm_freak: web but not web application?
20:38:13 <startling> do you copumpkin in?
20:38:15 <carter> whats a good exmaple?
20:38:23 <carter> startling: nope, i don't like dueling
20:38:25 <startling> backend stuff, I guess?
20:38:36 <carter> isn't that still web application?
20:38:45 <startling> Maybe.
20:39:05 <carter> hehe
20:39:32 <lpaste> NemesisD pasted “http mocking” at http://lpaste.net/94297
20:39:49 <NemesisD> startling: specifically line 31 ish
20:40:02 <rohan_> edwardk: argh, I cannot just compile the benchmark in the src directory, because Data.Constraint is missing.
20:40:27 <edwardk> rohan_: are you using the 3.10-maintenance branch or master?
20:40:39 <rohan_> ah, master
20:40:54 <edwardk> rohan_: try the other =)
20:41:25 <heatsink> NemesisD, the constraint conn req resp -> m seems overly specific.  Should it be more like conn -> m, req -> m, resp -> m ?
20:42:17 <mm_freak> carter: bots, internal network services, etc.
20:42:24 <NemesisD> heatsink: probably. i haven't fully grokked fundeps yet
20:43:06 <heatsink> For a given connection type, is there exactly one request type and exactly one response type that can be used on those connections?
20:44:00 <heatsink> You can probably ask yourself a few similar questions to work out what the actual constraints are
20:44:02 <NemesisD> heatsink: pretty much, this typeclass conceivably can only have 2 targets right now, fake and real. it isn't really general enough to apply to other http libraries or other testing mechanisms because it mirrors the http client's api
20:46:38 <heatsink> It looks like it can be simplified.  But I'm not able to infer from this what are the real constraints on types/values.  That determines how the problem would be written.
20:46:43 <rohan_> Maye I should not have started compiling with -O2 now…
20:46:48 <eccstartup> Anyone who use "http://hdiff.luite.com"?
20:47:40 <NemesisD> heatsink: i also have a strong suspicion that something like typefamilies/gadts would make this a whole lot less nasty, but i haven't yet learned how to apply those
20:47:59 <edwardk> rohan_: well, the -O2 will help make the benchmark fairer at least ;)
20:48:43 <heatsink> What I would do is figure out the "degrees of freedom" in the HTTP session interface you're building.  Which things are constrained by which other things.
20:49:38 <NemesisD> heatsink: there's pretty much no degrees of freedom between those typeclass params. the first instance uses all types from Network.Http.Client, the second instance fake versions of all of those
20:50:21 <NemesisD> and the actual monad at hand for fake will be a reader for a dictionary of fake responses, a writer for recorded requests
20:52:54 <rohan_> edwardk: hmm, it has made things a bit worse.  Now it's ten times as slow as the vanilla version.
20:52:55 <heatsink> Okay.  I would make the request and response types be data families
20:53:23 <heatsink> data family Req a; data instance Req FakeConnection = FakeConnectedRequest {...}
20:53:32 <rohan_> edwardk: I do not know if that could be because of the -O2 – does it sometimes reduce performance?
20:54:18 <heatsink> Which means that, for a given connection type 'a', you have a specific data type 'Req a', defined just like a regular ADT
20:54:28 <edwardk> rohan_: interesting. wasn't expecting that
20:54:57 <edwardk> i may have to explicitly use 'inline' in there a couple of times to make it avoid fearing work duplication
20:56:01 <rohan_> Hmm, curiously it has not changed the timings for the bytestring equivalent — which is now faster than the list one.
20:56:03 <edwardk> i think the use of conjoined caused it to fear to inline the 'l' which now occurs non-linearly in the body
20:56:06 <heatsink> The MonadHTTP class looks a bit like an object-oriented pattern, where sendRequest and receiveResponse are the OO class members
20:56:30 <edwardk> rohan_: not sure i parsed if that was good or bad for the library =)
20:56:42 <NemesisD> heatsink: i think you're right on that one. happy to do it the FP way if i learn what that is
20:57:01 <NemesisD> heatsink: also don't know how to write an instance of Req for the real types, i don't define them
20:57:03 <heatsink> Well, sometimes OO is appropriate.  I can't tell if this is one of those times
20:57:33 <NemesisD> heatsink: i'd love whatever help you can offer on this design. this is a nut i've been wanting to crack for a long time
20:58:27 <heatsink> sure
20:59:16 <rohan_> edwardk: please tell me when I should pull to try again.
20:59:32 <startling> NemesisD: sorry, I decided to recompile everything in the lens stack in a cabal sandbox so I could edit some haddocks, so i had to step away and go get ice cream when my machine started swapping.
20:59:46 <NemesisD> startling: no worries
20:59:48 <startling> NemesisD: did people clear things up for you?
20:59:58 <NemesisD> startling: heatsink is graciously helping me out
21:00:04 <heatsink> NemesisD, so the purpose of this is so that you can swap out a "testing" implementation for a "real" implementation of the network code?
21:00:05 <startling> Great.
21:01:12 <edwardk> rohan_: try now.
21:01:44 <heatsink> If that's the case, you probably want to design things so the testing and real implementations have the same types.
21:01:53 <NemesisD> heatsink: yep! i want to write some monadic code to make http requests (perhaps several), take that same code into a testing environment and run it against something like RWST ResponseMocker RequestLog () m
21:01:54 <edwardk> rohan_: we should probably move this chatter to #haskell-lens
21:03:01 <NemesisD> heatsink: unfortunately the types must differ. the http library i'm targeting does not export fields on its request object, and only exports some query methods on the response, i replicated the request building API already to build a fake request specification of my own
21:03:16 <heatsink> I see
21:03:46 <NemesisD> also the monad instance must necessarily be MonadIO. can't work with io streams without io it seems
21:04:59 <NemesisD> heatsink: the opaqueness of the http types may be fine though, because the structure isn't exported, my code can't rightly care that much about whether its dealing with the real types or fakes
21:05:20 <startling> How do I install some library source into a sandbox not in the library source directory?
21:05:48 <startling> (With cabal sandbox.)
21:05:56 <heatsink> I'm getting a better sense of what the connection types do.  Do you know if this is going to be mixed with other code that wants its own IO-like monad?
21:07:17 * hackagebot system-filepath 0.4.8 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.4.8 (JohnMillikin)
21:07:36 <NemesisD> the way i build most http-oriented libraries I stack a lot of functionality into 1 or 2 core, generic functions making api calls
21:08:08 <NemesisD> i.e. the core function knows nothing specifically about json, pagination, etc. it is more or less request -> response, that part is the part i want to swap out
21:08:35 <NemesisD> so i could test out the higher level stuff to use that at the core and they will behave the same, just wont make outbout http calls
21:10:35 <heatsink> Hmm, so at some level you want to use the same requests and responses with both the real and fake APIs
21:11:21 <NemesisD>  this would be easier to discuss with the real code http://hackage.haskell.org/package/http-streams-0.6.1.1/docs/Network-Http-Client.html#g:4
21:11:51 <heatsink> Seems like both apis should use the same request and response types
21:12:08 <heatsink> oh, I'll look at that
21:12:13 <NemesisD> the real type is opaque but it has stuff like getStatusCode, getHeader, etc, which are easily faked. it also has a body stream which is a separate, simple type of InputStream ByteString, so my response faker could easily provid that
21:12:51 <NemesisD> heatsink: my initial plan was to add getStatusCode, getHeader, etc to the big MonadHTTP typeclass for this very purpose
21:13:33 <elliott> NemesisD: you can make a typeclass for for responses
21:13:56 <elliott> and have a multi-param typeclass or type family for the request/response types in your MonadHTTP, with a method to access them
21:14:05 <elliott> (and require via a superclass that they implement the request/response typeclass)
21:14:15 <NemesisD> elliott: interesting proposition. guess that would break up the monolith a bit
21:14:20 <elliott> better would be to use non-abstract types though :P
21:14:58 <NemesisD> i'm really interested in how i could use type families here
21:15:15 <NemesisD> i have yet to use them in anger
21:16:24 <heatsink> I'm thinking you should define your own NemesisRequest and NemesisResponse type, which is used by both the fake and real interfaces.
21:16:27 <elliott> NemesisD: class (Monad m, HTTPRequest (Request m)) => MonadHTTP m where { type Request m; request :: m (Request m); ... }
21:16:36 <elliott> NemesisD: my real suggestion is to ask the http-streams author to de-abstract the type
21:16:37 <heatsink> The real interface would translate NemesisRequest into Network.HTTP.Request
21:16:39 <elliott> s
21:16:53 <elliott> NemesisD: they look trivial
21:17:04 <NemesisD> i'm sure he would be willing, but this is a good exercise for me in the mean time i think
21:17:14 <heatsink> and the fake interface would translate it into whatever it uses
21:17:25 <NemesisD> heatsink: i cant actually construct Request though, unless i misunderstand
21:18:05 <heatsink> Hmm?  Where do you get the value that you currently pass to Network.HTTP.sendRequest?
21:18:13 <NemesisD> well, thinking of it, i could build it in IO, obvously
21:18:54 <NemesisD> id just have to translate a NemesisRequest into a series of monadic actions in Network.Http.Client.RequestBuilder 9)
21:18:56 <NemesisD> ()*
21:19:05 <heatsink> right
21:20:25 <heatsink> The reason I'm suggesting this is so that both interfaces use exactly the same request and response types.  It's one less thing that needs to be modified when switching between the fake and real interfaces.
21:20:44 <NemesisD> good point i like it
21:21:04 <startling> Does cabal sandbox have a way to add-source a git repository? That would be so nice.
21:21:17 <NemesisD> separates me a liiitle bit from a particular http client libarary too
21:21:26 <NemesisD> which is always a good idea to avoid vendor lock in
21:21:37 <NemesisD> startling: +1
21:22:03 <startling> python has had this for years. >.>
21:22:24 * hackagebot cabal-debian 3.8 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-3.8 (DavidFox)
21:22:26 <NemesisD> haskell packaging lags a bit in some ways
21:22:38 <NemesisD> probably a consequence of a smaller community
21:23:01 <startling> It seems like we're getting there, though.
21:23:15 <NemesisD> oh yes we are. i love what has happened with cabal recently
21:23:27 <NemesisD> and hackage
21:25:44 <heatsink> I can see two ways to swap connection implementations.
21:26:44 <heatsink> You can do it with a type class.  This associates a connection implementation with each piece of source code that uses connections.
21:27:14 <heatsink> Or you can do it with object-oriented methods.  This associates a connection implementation with each piece of source code that creates connections.
21:27:42 <NemesisD> heatsink: if you literally mean Connection from the client libarary, i actually think that might not be a big factor
21:27:47 <heatsink> So it depends on whether the connection-setup code or the connection-using code gets to be "fake" or "real"
21:28:10 <NemesisD> i'm planning on request carrying all the pieces needed to construct a Connection in Network.Http.Client, so the fake version just doesn't need to connect to anything
21:28:46 <NemesisD> data Request = Request { method :: Method, host :: Hostname, port :: Port, path :: ByteString } deriving (Show, Eq)
21:29:34 <heatsink> Looking at the MonadHTTP class you wrote, it looks like there are methods to open a connection and then repeatedly send and receive messages on that connection
21:30:20 <NemesisD> heatsink: yeah im thinking with this idea of making my own Request type that builds the request ion the "real" version that i don't need that much fine grain control
21:31:48 <NemesisD> i may lose the ability to do http connection pipelining but i'm willing to sacrifice that for this yak shave
21:32:00 <heatsink> ok.  What functions will be overloaded in the real/fake interfaces?
21:33:15 <NemesisD> hmm
21:33:43 <NemesisD> probably sendRequest and receiveResponse
21:34:19 <NemesisD> i'm willing to choose reasonable defaults for opening/closing the connection, and the buildRequest part can be elsewhere as i'm going into this will a fully constructed Request
21:35:09 <heatsink> The receiveResponse function will need some piece of data to know what request it's associated with
21:36:02 <NemesisD> good point. maybe they should be one
21:36:16 <NemesisD> and if you don't care about the response have a response handler that discards
21:39:21 <heatsink> I'm still confused about how the plan has changed from what you put on lpaste
21:39:56 <heatsink> It sounds like you have sendRequest and receiveResponse, but the values of type 'conn' type have been taken away
21:41:20 <NemesisD> heatsink: yeah. say we have requestResponse  that is more or less Request -> Response, the real version will be responsible for opening/closing the connection
21:41:39 <heatsink> I see
21:41:50 <heatsink> then it's super simple
21:42:18 <heatsink> you just have two requestResponse functions with the same type.  One does the real network communication, one simulates it.
21:42:21 <birdie> is using haskell to interface with a .h+.dll possible?
21:43:14 <NemesisD> heatsink: woo! not sure what trickery i'll need to do around the monad
21:43:56 <heatsink> birdie: If the dll has a C interface, then you can use the FFI.  Are you familiar iwth the FFI?
21:43:57 <NemesisD> i think the fake one still needs IO so it can read the input stream/output stream
21:44:34 <heatsink> I saw that the network-streams functions used the IO monad.  Does that mean both use IO?
21:44:51 <birdie> heatsink, nope..just reading on it
21:45:33 <birdie> heatsink, i remmeber reading an article that involves marshalling between c++ and haskell but i cant seem to find it anymore
21:45:38 <birdie> which i think is a better way
21:45:52 <NemesisD> heatsink: i'm afraid so :(
21:46:24 <heatsink> The FFI is used to call C functions from Haskell or vice versa
21:46:35 <heatsink> call using the C calling convention, I mean
21:46:49 <heatsink> With C++, you have to write wrapper functions in C.
21:47:08 <heatsink> NemesisD, so I guess the signature will be Request -> IO Response
21:47:16 <dpld> @djinn (a -> a) -> a
21:47:16 <lambdabot> -- f cannot be realized.
21:47:17 <NemesisD> i don't think i could abstract away the req/resp streams to something like lazy bytestrings
21:48:00 <NemesisD> heatsink: yeah pretty much, i'm curious why the library delibiterately divorced streams from the request/response objects. not sure if i should do the same
21:48:01 <birdie> so i cant just "loadlibrary" the dll and get the raw ptr and do stuff with it?
21:48:17 <dpld> @djinn ((a -> r) -> r) -> a
21:48:17 <lambdabot> -- f cannot be realized.
21:48:17 <heatsink> by streams, do you mean the Connection type?
21:48:55 <NemesisD> heatsink: nah, the request body is something like OutputStream Builder, response stream is InputStream ByteString
21:49:25 <johnw> dpld: if djinn could do that, it would be something indeed
21:49:25 <heatsink> Is loadlibrary the Windows equivalent of dlopen?
21:50:17 <birdie> i am not sure about that
21:51:17 <heatsink> idk, maybe it's designed to chop data streams into short network messages
21:53:01 <birdie> is it me or is haskell learning curve is extremely steep?
21:53:18 <NemesisD> birdie: compared to what
21:53:37 <heatsink> There is a lot of learning involved compared to switching from one imperative language to another
21:54:00 <birdie> compare to lets say C#, java
21:54:10 <johnw> birdie: it's like this: http://mmoreporter.com/wp-content/uploads/2011/02/LearningCurve1.jpg
21:54:15 <NemesisD> birdie: coming from what?
21:54:31 <birdie> java
21:54:53 <NemesisD> actually doesn't matter, i think haskell has a steep learning curve but it is steeper if you don't start out with FP
21:55:12 <birdie> FP being? functional programming?
21:55:12 <NemesisD> haskell is a very different beast from most oop langs
21:55:16 <NemesisD> yeah
21:55:33 <birdie> i never learnt any FP of any sort, so i guess that could be a barrier
21:56:04 <NemesisD> i can't say for sure but i think my path to haskell was probably beneficial. started out with traditional OOP langs, did (and still do) Ruby for work, took up haskell
21:56:29 <johnw> one of the big things I had to unlearn from OOP was the focus on objects as the most important entity
21:56:34 <heatsink> To finish the earlier question, the usual way to interface with a non-Haskell library is to import library functions through the FFI and then call them in Haskell.  Program linking works the usual way.
21:56:50 <NemesisD> working with dynamic OOP langs helped me to keep going with haskell because i had experience with the deficiencies in the OOP langs
21:56:51 <acomar> NemesisD: to be fair, that learning curve is more about forgetting what you think you know than it is about actually learning. It took me a while to stop trying to force Haskell into something it wasn't rather than just adopting idioms and the like.
21:57:46 <NemesisD> acomar: agree. my leearning curve is probably exacerbated by my unwillingness to study category theory, but you can go a long way before that becomes an issue
21:58:35 <acomar> you don't really need category theory for anything. it's useful for library design and understanding a lot of the community stuff, but for actually getting stuff done? totally unnecessary
21:59:08 <heatsink> It's necessary for understanding conversations in #haskell
21:59:13 <acomar> true that
22:00:04 <johnw> i think category theory helps you see how some seemingly very different concepts in Haskell are really the same concept, they just occur at different "levels"
22:00:08 <NemesisD> what if you need to use community stuff to get stuff done
22:00:16 <ReinH> like monads and monoids :p
22:00:26 <johnw> exactly like monads and monoids
22:00:35 <johnw> thanks to CT, I see monoids practically everywhere now
22:00:35 <NemesisD> i immediately started having a better time the minute i stopped reading monad tutorials
22:01:06 <johnw> it's hard for any tutorial, however good, to teach intuition -- because it's just that, intuition
22:01:47 <NemesisD> one one hand i have a hard time explaining functors and monads in words. on the other i use them in terms of wrapping, unwrapping, etc and i get things odne
22:01:49 <NemesisD> done*
22:02:12 <NemesisD> ReinH: oh my god what i wouldn't give for a good failure/maybe monad in Ruby
22:02:36 <ReinH> NemesisD: lol
22:03:25 <edwardk> i use category theory to know when what i'm writing is something i'll be able to seal off and forget about because it is canonical and satisfies universal properties or when its a bunch of ad hoc decisions i'm making, that i may have to revisit later. knowing the distinction is very useful to me.
22:03:49 <heatsink> That makes sense
22:04:04 <edwardk> i tend to try to focus on implementing things that category theory tells me should exist, because those things are the kinds of things that i can write once and forget and reuse over and over forever
22:04:17 <johnw> yeah, it's really a powerful lens for evaluating abstractions
22:04:27 <startling> heh.
22:04:36 <johnw> ;)
22:04:44 <johnw> edwardk likes mind lenses
22:04:48 <acomar> edwardk: I hope to get to the point of being able to do that. Right now I settle for understanding what you and others have already done :)
22:05:23 <NemesisD> i sometimes couch my design decisions pretending i had coworkers who also wrote haskell and try not to be too clever
22:05:27 <edwardk> another thing it is useful for is telling me when i can stop looking for something by giving me lots of ways to know that something can't exist.
22:06:18 <edwardk> universal properties also let me know when two things are the same thing in disguise. it can be an easy way to evaluate whether two things really are isomorphic even when showing the isomorphism is hard. if they satisfy the same universal property, they are the same thing
22:07:34 * hackagebot ChasingBottoms 1.3.0.7 - For testing partial and infinite values.  http://hackage.haskell.org/package/ChasingBottoms-1.3.0.7 (NilsAndersDanielsson)
22:07:43 <bos> http://www.serpentine.com/blog/2013/10/14/open-question-help-me-design-a-new-encoding-api-for-aeson/
22:07:45 <johnw> or realizing you've found an initial object, and that no other object can be initial without being uniquely isomorphic to it
22:07:58 <rohan_> edwardk: the universal property really gives you the isomorphism though, not just its existence.
22:08:13 <edwardk> rohan_: sure, its just a really convenient way of finding it
22:08:40 <edwardk> johnw: well, ultimately any universal property is about doing that if you squint hard enough =)
22:09:31 <johnw> edwardk: my copy of Mac Lane is coming tomorrow
22:09:59 <johnw> i wonder if it will make any sense at all
22:10:03 <heatsink> So um... what does it mean when a function's class context grows suspiciously large?
22:10:20 <edwardk> johnw: i bounced off of it a half dozen times before i made it through
22:10:32 <edwardk> johnw: but it was worth it for the journey
22:10:47 <johnw> i figure it will be
22:11:24 <johnw> i'm trying to gear up with Agda so I can have a way of working through it that tells me when I'm wrong
22:12:07 <johnw> it's pretty neat when you beat your head against a proof and suddenly realize, oh, hey, if I had been able to prove that, the world would have ended
22:13:34 <edwardk> johnw: i've probably mentioned it before, but Serge Lang's Algebra is another good book to go through to pick up more of the category theory side of things. he goes through and derives a ton of abstract algebra right alongside all of the categorifications of the ideas, so if you have any intuition for abstract algebra it makes a good rosetta stone. http://www.amazon.com/Algebra-Graduate-Texts-Mathematics-Serge/dp/038795385X
22:13:47 <johnw> ah, I asked you that yesterday but I think you were aFK
22:14:10 <johnw> buying now
22:14:27 <edwardk> it's like if categories for the working mathmatician was 900 pages
22:14:42 <edwardk> =)
22:17:00 <luite> lang's book gives me a headache pretty quickly... it's about as dense as a stone as well :o
22:20:19 <edwardk> luite: its dense, but thats why it is awesome
22:20:25 <heatsink> I've run into situations where it's useful to inline a structurally recursive function, if the constructor that it pattern matches on is known.  Is there a way to convince GHC to do that?
22:20:36 <edwardk> i wasn't kidding when i analogized it to 900 extra pages of CftWM
22:21:50 <luite> hehe perhaps i should revisit it, these things tend to get better after the 2nd (or tenth) read :)
22:22:06 <startling> luite: I've noticed that with math books.
22:23:06 <johnw> yeah, me too
22:23:23 <johnw> the first time Awodey was goobledy gook, but the second time (months later), I thought, "Omg, this is awesome!"
22:23:42 <ReinH> edwardk: aaand now I own Lang
22:23:45 <johnw> his comment about category theory being a study of the algebra functions really hit me
22:24:08 <ReinH> Awodey is on my list too
22:24:33 <johnw> i also like Halmos' set theory book; that one has proved to be invaluable
22:24:45 <edwardk> i really need to go back and go deeper on category theory. the problem is i've hit a very productive little ghetto of it, and haven't finished exploring the space i'm in yet
22:24:47 <zRecursive> @ty first
22:24:47 <johnw> since some much of CT is discussed in terms of sets
22:24:49 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
22:25:05 <satc> Why is there a difference of speed using read and readDec ??
22:25:10 <johnw> edwardk: but could you be even moreso, that's the question ;)
22:25:36 <Saizan> i feel like there's a gap in these books, e.g. even MacLane has kan extensions only in the appendix
22:25:43 <edwardk> in particular i want to go deeper on internal categories and Bénabou cosmoi
22:26:10 <zRecursive> @ty (&&&)
22:26:12 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
22:26:52 <startling> johnw, Naive Set Theory? I hated that one.
22:27:41 <johnw> startling: yeah
22:27:54 <johnw> why did you hate it?
22:27:58 <edwardk> the notion of doing category theory on a more general setting like a cosmos is very appealing to me for the reasons the rosetta stone paper points out. Set is an odd duck in the world of category theory, so swapping it for a complete and cocomplete closed symmtric monoidal category seems to replace the parts of category theory that behave differently with the same thing as you want to work in for the rest of it.
22:28:08 <startling> I just found it really discursive and hard to follow.
22:28:14 <startling> I guess I like dryer math books.
22:28:27 <johnw> ah, I see what you mean
22:28:54 <jfischoff> complete and cocomplete?
22:29:34 <heatsink> mplete?
22:29:42 <edwardk> if we look at category theory ad try to make it turtles all the way down, it seems building it on set theory gets in the way basically.
22:30:03 <edwardk> has all small limits and all small colimits
22:30:36 * jfischoff nods
22:30:52 <edwardk> thats the kind of thing you want whatever is taking the place of your hom-sets to have
22:31:45 <ReinH> edwardk: needs more 2-categories
22:32:21 <edwardk> well, thats why i said turtles all the way down, so you can play with omega-categories and whatever on top of this sort of thing and not have to switch vocabularies
22:32:37 * hackagebot test-framework-sandbox 0.0.2.0 - test-sandbox support for the test-framework package  http://hackage.haskell.org/package/test-framework-sandbox-0.0.2.0 (BenjaminSurma)
22:32:40 * hackagebot test-sandbox 0.0.1.4 - Sandbox for system tests  http://hackage.haskell.org/package/test-sandbox-0.0.1.4 (BenjaminSurma)
22:32:41 * hackagebot test-sandbox-hunit 0.0.1.3 - HUnit convenience functions for use with test-sandbox  http://hackage.haskell.org/package/test-sandbox-hunit-0.0.1.3 (BenjaminSurma)
22:32:43 <edwardk> anyways, i suck at this stuff, but it strikes me as something worth going deeper on from my limited perspectiv
22:32:43 * hackagebot test-sandbox-quickcheck 0.0.1.3 - QuickCheck convenience functions for use with test-sandbox  http://hackage.haskell.org/package/test-sandbox-quickcheck-0.0.1.3 (BenjaminSurma)
22:34:09 <edwardk> the reason i care about it for haskell is trying to figure out if i should instead revisit the definitions i use for things like the 'categories' package to allow describing things in the internal language of some category other than Hask
22:34:11 <johnw> edwardk: isn't a value of Set the relevance to Haskell?
22:34:19 <jfischoff> I can remember that limits have do with cones and hom-sets are like exponentials, but its still interesting
22:35:00 <jfischoff> edwardk: would it be cartesian closed?
22:35:08 <edwardk> johnw: yes, but if we revisit, say, categories and make the instances about describing operations in the internal language of categories that may not be Hask, then we avoid having to have a separate language for internal categories, the usual definitions are just when that is hask
22:35:39 <edwardk> jfischoff: the cosmos thing? no. its closed monoidal
22:35:55 <edwardk> cartesian is the very thing i'm trying to escape
22:35:56 <startling> I want to load a file with the modules I have installed in a cabal sandbox. `cabal repl` and then `:l myfile.hs` seems to, uh, not load it -- I'm left without any of the definitions from it and the prompt just says "Prelude>"
22:35:57 <jfischoff> edwardk: the internal language instead of Hask?
22:36:24 <edwardk> jfischoff: basically i want to be able to defin as much as possibl without needing to lean on the cartesian stuff
22:37:07 <acomar> what are the issues with CCCs?
22:38:26 <edwardk> jfischoff: i have some very loosely thought out goals in the long term for trying to be able to do some nice edsls in the spirit of what conal has been blogging about lately, and have been half-heartedly trying to figure out if we can rephrase something like the code transformation for DPH in that same vein.
22:38:27 <jfischoff> for some reason I find symmetric monoidal categories more beautiful, but I can't point to practical language built off them.
22:40:19 <edwardk> acomar: its more that CCCs are very different than most other things that arise in practice. if you consider the category of rational tangles, cobordisms in topology, etc. they all tend to fit into the monoidal category mold rather than be CCCs.
22:40:43 <edwardk> acomar: have you read trough the old baez and stay rosetta stone paper?
22:40:46 <acomar> interesting, I haven't really looked into monoidal categories yet
22:40:48 <acomar> no, I haven't
22:40:56 <edwardk> http://math.ucr.edu/home/baez/rosetta.pdf
22:41:03 <acomar> thanks
22:41:44 <edwardk> anyways i keep revisiting symmetric monoidal categories as they are very nice place to think
22:42:17 <jfischoff> What did you think of the reversible language Amr had based on those?
22:42:22 <edwardk> but i think a lot of the problem with languages that try to build on them is they get stuck in one 'level' of it
22:42:49 <edwardk> hence why i want something more like turtles all the way down, it'd be nice to have a nice tower of universes in that style, etc.
22:43:08 <jfischoff> http://www.cs.indiana.edu/~sabry/papers/cat-rev.pdf
22:43:09 <edwardk> but for that you need to revisit the vocabulary you're using
22:43:31 <edwardk> i'm underwhelmed by reversible programming in general at this stage, but your mileage may vary
22:43:35 <jfischoff> could it have something like lambdas?
22:43:47 <jfischoff> its not practical
22:43:48 <edwardk> you can write lenses in an affine logic, so there is something to it ;)
22:43:58 <jfischoff> yes lenses!
22:44:25 <edwardk> yes you can have those exponentials you get in linear logic
22:44:28 <jfischoff> pointfree is tiresome :(
22:44:42 <jfischoff> right, its weird
22:45:25 <startling> Is there a way to runhaskell with a cabal sandbox environment?
22:45:28 <jfischoff> they mentioned that is the correspondence a la curry-howard but I don't think they have expontials in the language
22:45:47 <jfischoff> would it still be reversible?
22:45:56 <edwardk> anyways, HoTT is likely a more productive research vein in this area
22:46:03 <acomar> startling: does -package-db /cabal-sandbox-dir/ not work for you?
22:46:04 <edwardk> and i have more than enough haskell stuff to keep me busy =P
22:46:20 <jfischoff> :)
22:47:06 <acomar> startling: sorry, runhaskell -package-db /cabal-sandbox-dir/actual-package-db/
22:49:08 <ion> tag:todo (category theory talk)
22:51:22 <startling> acomar, so .cabal-sandbox/packages?
22:51:36 <acomar> startling: no, it's the dir that starts with your arch and all that
22:51:49 <NemesisD> heatsink: got a question on the implementation of this mocking thing
22:51:58 <acomar> startling: x86_64-linux-ghc-7.6.3-packages.conf.d on my system
22:52:17 <heatsink> kay
22:52:28 <startling> acomar: got it, thanks.
22:52:31 <NemesisD> sec pasting
22:53:31 <lpaste> NemesisD pasted “so far so good” at http://lpaste.net/94299
22:54:47 <NemesisD> heatsink: the question is what the type signature of fakeRequest should be like.
22:55:50 <NemesisD> the monad is likely going to need to change to RWST FakeResponder (Seq Request) () IO a
22:56:44 <NemesisD> heatsink: or actually is the goal to just have 1 function like realRequest, run it in IO for reals, run it in RWST for test
22:57:05 <NemesisD> and replace all instances of IO in the typesig to MonadIO m => m
22:57:19 <startling> That sounds strange.
22:57:58 <NemesisD> all the arguments to realRequest theoretically shouldn't need to change in that case between test and real
22:59:09 <heatsink> Does the FakeResponder read a request and build a response?
22:59:10 <startling> Well, you can't really do anything with an IO other than run it, so what would liftIO x do in your test thing?
22:59:38 <NemesisD> heatsink: yep
23:00:23 <NemesisD> startling: specifying MonadIO instead of IO there means it could work for IO and RWST r w () m wouldn't it?
23:01:19 <startling> NemesisD: so long as m is IO or some other MonadIO.
23:01:49 <NemesisD> startling: exactly, hence why i was thinking MonadIO, just making the type less constrained
23:01:52 <acomar> NemesisD: yea, but then you can't really make use of any of the features of RWST -- it's as if you're stuck in plain old IO
23:02:03 <acomar> or is that ok?
23:02:08 <heatsink> I don't think you can generalize withConnection over MonadIO
23:02:59 <NemesisD> heatsink: ah yeah i was confused, what i meant to say is to make a realRequest and fakeRequest which are type compatible
23:03:10 <heatsink> oh ok
23:03:46 <acomar> ahh, separate functions. nevermind
23:03:48 <NemesisD> in which case both nead monadio i think, acomar i would be using monadio on the m part of RWST, that would prevent me from using its features?
23:03:51 <NemesisD> ah ok
23:05:20 <NemesisD> so then the fake one's constraints would be like: (MonadIO m, MonadRWS ResponseFaker (Seq Request) () m) => ... ?
23:05:48 <startling> Using IO in your test thing seems like a bad idea.
23:06:23 <NemesisD> startling: i agree but it is unavoidable with the machinery of this http client. it uses IO streams and you can't do anything with them not in IO
23:06:43 <startling> aha.
23:08:28 <heatsink> The constraints would be MonadReader ResponseFaker m and MonadWriter (Seq Request) m
23:09:30 <heatsink> Though I think you could just fix it to the RWST IO monad.  It's easy enough to generalize it later.
23:11:21 <simpson> Evening. I encountered Mr. Marlow demonstrating non-trivial STM-based concurrency in networking here: http://community.haskell.org/~simonmar/slides/cadarache2012/5%20-%20server%20apps.pdf
23:11:54 <simpson> I was wondering whether anybody had developed common code based on these ideas, and whether they were compatible with the more modern data flow libraries available in Haskell like pipes and conduits.
23:13:59 <zRecursive> How to understand "keys conf cnf" in `additionalKeys conf keyList = conf { keys = \cnf -> M.union (M.fromList keyList) (keys conf cnf) }` ?  keys just needs one argument ?
23:14:29 <johnw> 'keys conf' accessing the keys member of conf; it is a function that you are passing cnf
23:14:32 <NemesisD> heatsink: man im really surprised at how clean this solution is coming out
23:14:44 <acomar> keys is an accessor into a record
23:14:56 <acomar> it has an implicit parameter which is an instance of the record you want to look into
23:14:57 <BlankVerse> when I try ,  cabal haddock --hyperlink-source, =>
23:14:59 <BlankVerse> cabal: The program hscolour version >=1.8 is required but it could not be
23:15:02 <BlankVerse> found.
23:15:11 <zRecursive> johnw: right, thx
23:15:49 <zRecursive> acomar: ok
23:16:23 <heatsink> I've got to sleep.  I think you can handle the rest NemesisD.
23:18:41 <jack_rabbit> Hello, all. I've been reading the docs, but don't understand how to intuitively create a PortID for the Network package. I found something about byteswap, but that seems non-intuitive.
23:19:01 <jack_rabbit> Create one from an Int, that is.
23:21:05 <NemesisD> jack_rabbit: PortNumber $ fromIntegral 999
23:21:26 <ion> fromIntegral 999 = 999
23:21:28 <NemesisD> jack_rabbit: actually it has a num instance so you could just use the literal
23:21:35 <NemesisD> PortNumber 999
23:22:28 <ion> If PortNumber has a Num instance, you can just say “999”.
23:23:07 <startling> If you want to create one from an Int you have already (that is not a literal), fromIntegral
23:23:10 <ion> If you have an Int, you can convert with fromIntegral (but note that you may lose information).
23:26:13 <jack_rabbit> Hmmm. Why is ghci complaining about no definition for constructor PortID? I have included the Network module, which contains the definition.
23:27:04 <jack_rabbit> Oh, I guess I can just pass the PortNumber to the functions accepting a PortID?
23:27:27 <shachaf> Hmm, that's a good question someone is asking on stackoverflow.
23:27:59 <shachaf> Simplified version: data Foo :: Bool -> * where { A :: Foo False; B :: Foo True }; hmm :: Foo b -> Foo b -> Bool; hmm A A = False; hmm B B = True
23:28:10 <jack_rabbit> I wonder if PortID has been turned into a type rather than a data declaration.
23:28:54 <startling> shachaf, I don't get it.
23:28:59 <shachaf> GHC warns that the pattern match isn't exhaustive. But it is, and GHC even knows that, because if you try to match with e.g. "hmm A B" you get an error (as you should).
23:29:08 <elliott> that's already reported iirc
23:29:11 <startling> oh, there was more.
23:29:18 <shachaf> Oh, OK then.
23:30:23 <shachaf> Any idea what the bug number is?
23:30:24 <jack_rabbit> Oh, duh. I am just a fool (or at least a newbie). PortNumber is a PortID constructor. Still getting used to Haskell ideas.
23:30:35 <shachaf> Oh, is it 6124?
23:32:48 * hackagebot file-embed 0.0.5 - Use Template Haskell to embed file contents directly.  http://hackage.haskell.org/package/file-embed-0.0.5 (MichaelSnoyman)
23:34:48 <Platz> /pa
23:35:48 <guoguo12> hey, anyone here? i have a question
23:42:49 * hackagebot shakespeare 1.2.0.1 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-1.2.0.1 (MichaelSnoyman)
23:42:51 * hackagebot shakespeare-js 1.2.0.2 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-1.2.0.2 (MichaelSnoyman)
23:42:54 * hackagebot shakespeare-text 1.0.0.8 - Interpolation with quasi-quotation: put variables strings  http://hackage.haskell.org/package/shakespeare-text-1.0.0.8 (MichaelSnoyman)
23:46:05 <shachaf> elliott: Thanks!
23:57:18 <shachaf> What's the simplest way to write foo :: Is Char Bool -> Void?
23:57:46 <Ralith> unsafeCoerce
23:57:47 <Ralith> obv
23:58:33 <Saizan> type family F :: * -> *; type instance F Char = (); type instance F Bool = Void
23:59:23 <Saizan> then substF : Is x y -> F x -> F y
23:59:34 <Saizan> foo eq = substF eq ()
23:59:45 <Kaidelong> now I'm curious about what the Is type constructor is used for and google is bound not to help because Is is is
23:59:46 <shachaf> OK, you would go through substF.
23:59:58 <shachaf> Kaidelong: data Is a b where Refl :: Is a a
