00:00:12 <edwardk> arkeet: well, languages like c++. etc force you to cram all the definitions about a given thing in one place, but they do let you define parts of your superclasses in your subclasses. i don't know a better design for haskell style typeclasses, but we do get poor code-reuse / ability to use laws from points below us in the lattice of laws and data types
00:00:34 <edwardk> arkeet: jacques carette has a nice system for defining these very fine grained types via pullbacks
00:02:30 <edwardk> but that is definitely not haskell =)
00:02:52 <sopvop> haskell is becoming too boring. lets move to idris!
00:02:54 <airlok9> Got it to work, thanks everyone. =) mzero was exactly right... the problem was a bad [String] as input
00:05:56 <dmj`> sopvop: but haskell has 3000+ packages for it
00:06:07 <sopvop> java has even more
00:06:11 <sopvop> and ruby
00:06:42 <sopvop> not to mention php
00:06:47 <begriffs> Anyone else have problems building skein-1.0.8 on a mac? It has problems with the clang preprocessor I think.
00:07:13 <mzero> is skein a haskell package?
00:07:19 <mzero> are you on Xcode 5
00:07:41 <arkeet> see the topic if you are
00:07:42 <sopvop> idris has no sockets bindings yet. Once you have that, all the webdevs will jump on it.
00:08:09 <mzero> actually - don't
00:08:20 <mzero> look at this: https://gist.github.com/mzero/7245290  if you are
00:08:26 <begriffs> arkeet: I am on xcode 5.0.1
00:08:33 <mzero> I just develope this easier way of handling xcode 5
00:08:37 <dmj`> sopvop: yes, but we'd like to stay functional ideally. Haskell has the most libraries for a purely functional language
00:08:44 <mzero> begriffs: did you patch anything to get your GHC / HP install to work?
00:09:24 <begriffs> mzero: I didn't patch anything. I installed the haskell platform a few months ago, and recently upgraded xcode.
00:09:26 <sopvop> dmj`: Success avoidance test: Failed
00:09:31 <mzero> excellent!
00:09:41 <begriffs> arkeet: oh I overlooked the channel topic. :) oops
00:09:42 <mzero> then follow that gits
00:09:45 <mzero> that gist
00:09:55 <mzero> it will patch things up so your set up should work again
00:10:11 <arkeet> mzero: then you should get your thing in the topic somehow.
00:10:13 <mzero> (I'm the HP packager for Mac... and JUST finsihed that script about 20 min. ago!)
00:10:26 <dmj`> sopvop: I see :) but define success
00:10:42 <mzero> arkeet: I just finished it and tested it on all machines I have... and just put out a call to have it tested on a few more
00:10:52 <arkeet> mzero: :)
00:11:03 <mzero> once we have a little bit more coverage - it can become the suggested way
00:11:08 <sopvop> dmj`: success of language is when there are enough users that changing anything becomes hard
00:11:26 <mzero> it is essentially a self-contained, self-installing wrapper - as a shell script
00:11:36 <sopvop> like adding (&) :: a -> (a -> b) -> b to base library proposal
00:11:38 <mzero> and doesn't require doing anything drastic like installing gcc from brew
00:12:05 <mzero> begriffs: if you use my script, please tell me if it works for you
00:13:02 * hackagebot monad-resumption 0.1.0.1 - Resumption and reactive resumption monads for Haskell.  http://hackage.haskell.org/package/monad-resumption-0.1.0.1 (IanGraves)
00:13:02 * hackagebot stomp-conduit 0.0.1 - Stompl Conduit Client  http://hackage.haskell.org/package/stomp-conduit-0.0.1 (TobiasSchoofs)
00:13:17 <dmj`> sopvop: Because it would break real world code, but Applicative => Monad will do this :)
00:13:47 <sopvop> dmj`: it would be a trivial fix
00:16:20 <begriffs> mzero: your script worked! Thank you! I love how it walked me through copying it to the right place, setting permissions, and running it.
00:16:28 <mzero> YAY!!!!
00:16:38 <dmj`> sopvop: still
00:16:41 <sopvop> edwardk: How about smaller change to base library, will (&) finally make it?
00:16:44 <mzero> That's just the kind of packager I am!
00:16:57 <edwardk> that one it looks like will
00:17:03 <sopvop> and <&>
00:17:06 <edwardk> yes
00:17:26 <sopvop> yay!
00:17:35 <edwardk> there was a referendum to th core libraries committee that i recused myself from, and folks all said 'do it'
00:17:37 <jfeltz> edwardk: sorry, brain catching up, thanks again
00:17:48 <arkeet> how about (??) ?
00:17:57 <edwardk> arkeet: wasn't in the referendum =)
00:18:03 <arkeet> maybe next time
00:18:16 <edwardk> i think dolio mentioned it in passing but nobody picked it up
01:08:02 * hackagebot base32-bytestring 0.1.1.1 - Fast base32 and base32hex codec for ByteStrings  http://hackage.haskell.org/package/base32-bytestring-0.1.1.1 (SamTruzjan)
01:15:42 <sopvop> edwardk: It would be nice to have in base something like Either, but accumulating lefts in aplicative. It seems I have defined it in almost every program I've written. Like data Result e a = Fail e | Ok a; instance Monoid e => Applicative (Result e) where....
01:16:38 <sopvop> there is package for it http://hackage.haskell.org/package/Validation but it is not maintained
01:25:03 <supki_> next you will want non-empty list in base
01:25:26 <startling> sopvop, I've written something similar
01:25:39 <startling> it's nice for reporting as many errors as possible.
01:28:54 <johnw> sopvop: you could also achieve that by composing applicatives: type Result e a = Monoid e= > Sum (Const e) Identity a
01:29:28 <sopvop> johnw: that is writer
01:29:44 <johnw> writer would be a Product
01:29:45 <sopvop> johnw: Product (Const e) Maybe a
01:29:48 <sopvop> oh
01:34:57 <Twey> supki_: Just Vec will do :þ
01:38:04 * hackagebot urembed 0.5.0.1 - Ur/Web static content generator  http://hackage.haskell.org/package/urembed-0.5.0.1 (SergeyMironov)
01:38:47 <johnw> sopvop: maybe crude, but: https://gist.github.com/7246118
01:40:08 <sopvop> johnw: I've found relevant blogpost http://comonad.com/reader/2012/abstracting-with-applicatives/
01:40:34 <johnw> yep, that's what I copied from
01:40:59 <johnw> that should be required reading along with Typeclassopedia :)
01:41:06 <sopvop> true
01:43:15 <sopvop> I think I've seen Sum defined in several packages also. Is there a canonical one? It's not in transformers
01:44:01 <Twey> sopvop: In Data.Monoid?
01:44:07 <sopvop> no that sum
01:44:52 <Twey> Oh, that Sum
01:49:22 * sopvop thinks it would be easier to find stuff if there was an 'edwardk' category on hackage.
01:50:23 <Iceland_jack> heh
01:52:58 <sopvop> that package is a bit too much http://hackage.haskell.org/package/syntactic-1.0/docs/Language-Syntactic-Syntax.html#g:2
01:53:05 * hackagebot urxml 0.2.0.0 - XML parser-printer supporting Ur/Web syntax extensions  http://hackage.haskell.org/package/urxml-0.2.0.0 (SergeyMironov)
01:57:33 <crabman> Hello. I've just read that list comprehensions is a syntactic sugar for list monad. How do I translate the boolean filter in list comprehension to monad?
02:01:06 <sopvop> crabman: MonadPlus
02:01:44 <startling> crabman, do { x <- myList; if x == whatever then return x else mzero; }
02:01:54 <startling> > mzero :: [Int]
02:01:55 <lambdabot>   []
02:02:16 <danr> @type guard
02:02:17 <lambdabot> MonadPlus m => Bool -> m ()
02:02:26 <startling> > do { x <- [2, 4, 5]; if even x then return x else []; }
02:02:27 <lambdabot>   [2,4]
02:04:03 <startling> > do { x <- [2, 4, 5]; guard (even x) [x]; }
02:04:04 <lambdabot>   Couldn't match type `()' with `[b0]'
02:04:04 <lambdabot>  Expected type: [t0] -> [b0]
02:04:04 <lambdabot>    Actual...
02:04:16 <startling> > do { x <- [2, 4, 5]; guard (even x); [x]; }
02:04:17 <lambdabot>   [2,4]
02:04:37 <crabman> startling: thanks
02:05:01 <startling> note that return x = [x] and mzero = [].
02:13:23 <Aleksejs> Hi, which would be the best way to get all k-permutations of given list?
02:17:54 <Flonk> > nub.permutations $ [1,1,2] --Aleksejs
02:17:56 <lambdabot>   [[1,1,2],[2,1,1],[1,2,1]]
02:18:04 <Flonk> Not sure if its particularly efficient
02:23:54 <Aleksejs> Flonk, thanks, but these are just permutations, but I need k-permutations
02:24:47 <lpaste> structuralist pasted “Interactive commands” at http://lpaste.net/95016
02:24:53 <Aleksejs> that is - perm 3 [1..5] would be [1,2,3],[3,2,1][1,3,4] etc
02:25:16 <structuralist> Can someone tell me why the program above doesn't give any output until I hit Ctrl+C?
02:25:32 <Flonk> Aleksejs: Oh, I thought it was permutations in a multiset. My bad!
02:29:16 <Aleksejs> Flonk, I guess I figured it out
02:29:20 <Aleksejs> > map (take 2) $ permutations [1..3]
02:29:22 <lambdabot>   [[1,2],[2,1],[3,2],[2,3],[3,1],[1,3]]
02:30:03 <Flonk> Aleksejs: I suppose that works, make sure to nub the result though
02:30:18 <Flonk> > take 3 [1,2,3,4,5] == take 3 [1,2,3,5,4]
02:30:19 <lambdabot>   True
02:30:54 <Aleksejs> yes, thanks
02:30:56 <Aleksejs> > nub.map (take 2) $ permutations [1..4]
02:30:58 <lambdabot>   [[1,2],[2,1],[3,2],[2,3],[3,1],[1,3],[4,3],[3,4],[4,2],[2,4],[4,1],[1,4]]
02:31:13 <Aleksejs> > map (take 2) $ permutations [1..4]
02:31:14 <lambdabot>   [[1,2],[2,1],[3,2],[2,3],[3,1],[1,3],[4,3],[3,4],[3,2],[4,2],[2,4],[2,3],[4...
02:32:05 <sopvop> why this (Functor m, Monad m) => Applicative (StateT s m) and `ap` instead of  (Functor m, Applicative m) => Applicative (StateT s m) and (<*>) ?
02:58:22 <sopvop> johnw: I've figured that out! Lift (Const e) a
02:59:04 <johnw> nice!
03:00:54 <johnw> it even comes with a type synonym, Errors, which is exactly what that Result type did
03:13:56 <ibotty> hi short question. what's the preferred way to get Int -> ByteString?
03:14:06 <ibotty> it's not `pack . show`, is it>?
03:14:33 <ibotty> using a builder sounds like too much work when it's only for one small number
03:32:38 <merijn> ibotty: Well, in what way do you want a bytestring?
03:32:54 <merijn> ibotty: You mean you went a binary encoding of the Int for sending over network/storing in file?
03:32:59 <merijn> s/went/want
03:33:06 <ibotty> ehm. as `pack . show` does
03:33:12 <ibotty> no
03:33:25 <merijn> "pack . show" is a really silly thing to do
03:33:32 <ibotty> i think so as well
03:33:33 <ibotty> :)
03:33:38 <ibotty> that's why i am asking
03:33:40 <merijn> ibotty: I meant in terms of what it does
03:33:52 <merijn> ibotty: I can't imagine a single reason for ever wanting that behaviour
03:34:08 <merijn> In fact
03:34:12 <merijn> That's not even correct
03:34:18 <Cale> ?
03:34:19 <ibotty> i'd like a typical ByteString.Char8 behaviour: 12 -> "12"
03:34:26 <merijn> pack is "[Word8] -> ByteString"
03:34:27 <frerich> Well one reason for wanting it would be a reason for wanting it. :-)
03:34:32 <merijn> ibotty: No, you don't want that
03:34:35 <mauke> merijn: wrong pack
03:34:49 <merijn> ibotty: Data.ByteString.Char8 is an abomination which should not be used
03:35:11 <Cale> merijn: the results of show for Integer are guaranteed to be ASCII :P
03:35:19 <merijn> mauke: You mean the "right pack" :p
03:35:27 * mauke uses it all the time
03:35:43 <merijn> Cale: Still, bad habit to encourage
03:35:45 <ibotty> aww. i know. but i generate a HTTP.Types.Request, where i have bytestrings as path's
03:36:02 <ibotty> and i have to generate "/path/to/id/" ++ 12
03:36:05 <chrisdone> then you use text
03:36:07 <merijn> mauke: You maybe one of a handful of people I expect to not screw stuff like that up
03:36:09 <chrisdone> and encodeUtf8
03:36:20 <chrisdone> e.g.
03:36:21 <merijn> chrisdone++
03:36:24 <ibotty> chrisdone: i do that, sometimes, but not here
03:36:29 <chrisdone> why?
03:36:55 <ibotty> because the interface of http.conduit is to use bytestring
03:37:03 <ibotty> and i know everything is ascii
03:37:27 <merijn> mauke: I use the fromString for ByteString for networking too, but experience has shown me that people that ask questions about encoding are usually not capable of deciding when it's the right thing
03:37:56 <ibotty> :hoogle Int -> ByteString
03:38:20 <ibotty> nobody needs that...
03:39:01 <ibotty> so: i'll use B8.pack . show. thanks for answering.
03:42:01 <frx> filter f . map f $ xs  <- will GHC optimize this away to a single iteration over the list?  what if I chained more operations?
03:42:40 <bz> what does it mean if () shows up in the type signature? for instance, f :: () -> Integer; f x = 32
03:43:12 <bz> is () some sort of singleton value such that f as defined above would only accept ()?
03:46:14 <ibotty> bz: you know what () is, right?
03:47:16 <ibotty> so f is a 1-ary function (also in the not-curried sense) that returns and Int
03:48:06 <quchen> data () = ().
03:48:31 <Jaxan> It's like the empty tuple ;D
03:48:37 <quchen> It *is* the empty tuple.
03:49:05 <ibotty> :i ()
03:49:20 <bz> ibotty: unit
03:49:27 <sipa> :t ()
03:49:28 <lambdabot> ()
03:49:52 <bz> nvm then
03:49:55 <bz> makes sense
03:56:14 <zebr> does anyone know what the go-to paper for supercombinators is? mostly i just want to know what the agreed-upon notation etc is. unfortunately hughes' thesis doesn't seem to be available unless i actually trek up to oxford.
03:56:40 <zebr> i'm using spj's book atm, but it's a bit old so it might be out of date
03:57:53 <b_> When I do cabal update; I get Note: there is a new version of cabal-install available
03:58:03 <b_> So I run cabal install cabal-install
03:58:15 * hackagebot fclabels 2.0.0.3 - First class accessor labels implemented as lenses.  http://hackage.haskell.org/package/fclabels-2.0.0.3 (ErikHesselink)
03:58:28 <b_> all fine and dandy, but then when I do cabal update again, it says the same thing again
03:58:55 <b_> And when I re-run cabal install cabal-install, it happily reinstalls it without being aware that it's a reinstall
03:59:27 <merijn> zebr: Have you tried mailing Hughes and asking if he could email you a copy? Presumably he still has a digital version
03:59:51 <merijn> b_: Sounds like the installation directory of cabal is not in your path
04:00:23 <merijn> b_: Use "which cabal" to figure out which it is using and find out whether the installation directory for cabal is in your path
04:01:19 <zebr> merijn: hmm, i could try that
04:01:48 <b_> merijn, it is in my path (of fish), does cabal need extra info?
04:05:03 <merijn> b_: It shouldn't, is it in your path before the current cabal? Does fish need to "rehash" or similar when a new binary appears?
04:06:08 <b_> All installed binaries from the cabal bin directory work fine from CL
04:06:23 <b_> I'll try installing from bash
04:08:16 * hackagebot fclabels 2.0.0.4 - First class accessor labels implemented as lenses.  http://hackage.haskell.org/package/fclabels-2.0.0.4 (ErikHesselink)
04:11:43 <donri> couldn't they fit "functional references" into that synopsis for fclabels?
04:13:16 * hackagebot fclabels 2.0.0.5 - First class accessor labels implemented as lenses.  http://hackage.haskell.org/package/fclabels-2.0.0.5 (ErikHesselink)
04:15:06 <henk> I have a list of tuples (timestamp, string) and need to run something like "scanl1 (-)" over the timestamps without loosing the strings belonging to the timestamps. Any clever way to do that?
04:15:39 <lpaste> henk pasted “diddohs” at http://lpaste.net/95022
04:16:00 <henk> http://lpaste.net/95022 that’s the code, see lines 23-28 for what I’m talking about.
04:16:12 <henk> (non-functional as it is ATM)
04:17:33 <frerich> I.e. [(4,"x"),(9,"y"),(11,"z"] becomes [(4,"x"),(5,"y"),(2,"z")] ?
04:19:58 <FreeFull> > scanl1 (\(x,_) (y,s) -> (x-y,s)) [(1,"Meow"),(2,"Hoof"),(3,"Hats")]
04:19:59 <lambdabot>   [(1,"Meow"),(-1,"Hoof"),(-4,"Hats")]
04:20:04 <FreeFull> Ugly but it works
04:20:25 <FreeFull> I don't know how to make it prettier without using lenses
04:20:45 <bennofs> FreeFull: Why is the second -1?
04:20:53 <frerich> FreeFull: Shouldn't it be "[(1,"Meow"),(-1,"Hoof"),(1,"Hats")]" though?
04:21:12 <FreeFull> bennofs: 1-2 = -1
04:21:39 <FreeFull> > scanl1 (-) [1,2,3]
04:21:40 <lambdabot>   [1,-1,-4]
04:21:49 <FreeFull> -1 - 3 = -4
04:21:55 <bennofs> > xs = zipWith (\a (b, q) -> (b - a, q)) (0 : map fst xs) xs
04:21:57 <lambdabot>   <hint>:1:4: parse error on input `='
04:22:05 <FreeFull> It's a cumulative difference
04:22:11 <FreeFull> Rather than pairwise
04:22:12 <bennofs> > (\xs -> zipWith (\a (b, q) -> (b - a, q)) (0 : map fst xs) xs) [(1,"Meow"),(2,"Hoof"),(3,"Hats")]
04:22:13 <lambdabot>   [(1,"Meow"),(1,"Hoof"),(1,"Hats")]
04:22:25 <frerich> FreeFull: I suspect that's not what henk wants.
04:22:39 <FreeFull> Probably not
04:23:01 <FreeFull> So you'd want to use something other than scanl1
04:23:09 <frerich> bennofs: That's exactly the code which hnk already has commented out :)
04:23:18 <FreeFull> Probably zipWith and drop 1
04:23:21 <frerich> bennofs: (in line 24)
04:24:08 <bennofs> frerich: actually, I copied that code here :P
04:24:35 <bennofs> frerich: I guess he wants to do the same with scanl?
04:27:47 <henk> bennofs: Not necessarily with scanl, but that’s what I want to do.
04:28:51 <FreeFull> zipWith is the way to go
04:28:57 <bennofs> henk: Why don't you use the zipWith code then? Just as an exercise?
04:29:27 <FreeFull> You can replace the 0 with t
04:29:36 <FreeFull> Or, start that is
04:31:27 <supki_> > mapAccumLOf (traverse._1) (\acc t -> (t, t - acc)) 0 [(1, "foo"), (2, "bar"), (9, "baz")]
04:31:29 <lambdabot>   (9,[(1,"foo"),(1,"bar"),(7,"baz")])
04:40:25 <henk> 'shrug' just thought it might be possible simpler … Maybe I’ll just split the tuples in two lists. Seems easier to handle … thanks everyone
04:45:57 <sie> Why does ^Y suspend ghci?
04:49:33 <ion> Not here. It pastes the cut buffer for me.
04:49:34 <quchen> sie: Doesn't do anything here
04:50:06 <ion> ^Z also works as expected here.
04:50:13 <sie> hmmm
04:50:15 <geekosaur> you're on a system that supports "delayed suspend"
04:50:29 <geekosaur> stty dsusp ^-
04:50:31 <quchen> sie: Are you on a QWERTZ keyboard and your system switched to QWERTY?
04:50:33 <geekosaur> at a shell
04:50:46 <sie> quchen, nope, a regular mac with a qwerty
04:51:08 <geekosaur> yep, macs do dsusp (BSD based)
04:51:11 <bennofs> "forever (return ()) `finally` writeFile "log" "Exit"  -- Why is this not executed when I terminate the process with SIGTERM?
04:51:22 <bennofs> (Image that code in main = ...)
04:51:33 <sie> geekosaur, Woo hoo, thanks.
04:52:11 <geekosaur> (in case you're wondering, ^Z is immediate and ^Y only suspends when something is waiting for input)
04:52:33 <sie> But why doesn't ruby console or zsh suspend in the case then?
04:52:38 <sie> +the
04:53:40 <geekosaur> gnu readline uses raw mode and doesn't implement dsusp functionality itself; shells themselves generally don't do either suspend character at their prompts on the assumption there's nothing to suspend *to*
04:54:23 <geekosaur> (if you actually want to suspend a shell, there is a suspend command)
04:55:23 <b_> merijn, I'm sorry, it turned out that I had two versions of cabal in my path :/ Problem fixed
04:55:50 <bennofs> Oh, in `finally` action, the action is not run if the process terminates via SIGTERM in haskell?
04:57:07 * geekosaur doesn't recall offhand if the ghc runtime intercepts SIGTERM by default
04:57:37 <sie> geekosaur, Still a bit unsure. So ghci doesn't use readline, which would shadow this signal?
04:58:01 <geekosaur> ghci uses a partial reimplementation called haskeline
04:58:21 <sie> aha
04:58:31 <geekosaur> which apparently runs in "semi-cooked" mode, so it gets individual characters but doesn'tdisable handling of terminal signal keys
04:58:33 <alexander__b> https://secure.plaimi.net/~alexander/tmp/main.pdf -- here's a paper I wrote for a class. it is sort of aimed at C++ game programmers. it's a mix of "our experience using haskell for games" and "why you should use haskell for games". any feedback would be great! since we are not experienced with haskell, we probably say something wrong.
04:58:50 <bennofs> Does Haskell have something like "atexit" ?
04:59:14 <geekosaur> (it used to use readline but that caused problems on a number of platforms --- including Macs, where Apple ships a "readline" that isn't GNU, it's a renamed BSD editline)
04:59:33 <sie> But you can install the gnu one.
04:59:49 <sie> But yeah's another problem.
04:59:56 <geekosaur> you can, but I'm not sure you can even build ghci with real readline any more
05:01:44 <sie> geekosaur, Last question, if I may — up to this point I was sure how signals worked, now I'm not certain. So when I press something that is meant to be interpreted as a "signal key"(stuff stty sets), how does it travel from my keyboard to the current executable after the point of the kernel receiving it?
05:01:44 <geekosaur> bennofs: may not be relevant if the runtime is not intercepting SIGTERM; in that case atexit() stuff would not be run either
05:02:38 <geekosaur> sie: a terminal has a current process group; the signal is sent to every process in that group. usually the group consists of a single process, but if you are running a shell pipeline then every process in the pipeline receives it
05:03:57 <sie> Hmm, that's very interesting, I didn't know this. Thank you.
05:05:12 <geekosaur> dsusp is a little weird since typically only one of those processes can be reading from the terminal at any given time, but it then suspends the entire process group; this is why nobody outside the BSDs has implemented it, it behaves somewhat oddly with more than one process in the tpgrp and requires some extra process accounting
05:05:44 <sie> Where may I read up on this process group thing?
05:05:45 <geekosaur> likewise SIGSTAT (control-T)
05:06:18 <sie> man pg?
05:07:07 <geekosaur> the manpages are not a lot of help here since the information is scattered through the documentation for the terminal device / line discipline and signal handling
05:07:32 * sie goes to lunch with colleagues.
05:10:48 <geekosaur> `man termios` but the information is kinda all over the place (most of the important stuff is under "Special Characters")
05:19:20 <chrisdone> neat! http://www.reddit.com/r/haskell/comments/1pkzd0/show_reddit_my_weekend_project_purescript/
05:20:29 <bennofs> Hmm, would consider it a bug if decodeStrict and decode give different results (Nothing vs Just something) ? (In aeson)
05:22:02 <chrisdone> depends
05:22:15 <chrisdone> if it's for a number or something
05:22:19 <chrisdone> then decodeStrict should not work
05:22:24 <chrisdone> whereas decode is more lenient and allows it
05:22:50 <bennofs> chrisdone: isn't strict vs lazy just strict bytestrings vs lazy ones?
05:23:31 <chrisdone> ah, n/m. yeah it's that, was thinking of this pitfall: http://hackage.haskell.org/package/aeson-0.6.2.1/docs/Data-Aeson.html#g:6
05:23:46 <chrisdone> that's weird,  what's the difference you get?
05:23:52 <bennofs> chrisdone: I
05:24:11 <bennofs> chrisdone: hmm, I'll factor it out to paste it
05:29:46 <lpaste> bennofs pasted “Aeson weirdness” at http://lpaste.net/95024
05:29:51 <bennofs> chrisdone: There
05:30:06 <bennofs> decode . encode should equal id, but it doesn't
05:30:24 <bennofs> hmm, actually it's decodeStrict . encode that isn't id
05:34:49 <bennofs> I'm using Aeson 0.6.2.1
05:35:02 <chrisdone> aha. strange
05:35:49 <bennofs> chrisdone: https://github.com/bos/aeson/issues/142 might be related, but there they say it's fixed?
05:37:20 <donri> bennofs: looks like decodeStrict uses decodeStrictWith which might not be fixed yet as hinted in the last comment
05:37:37 <chrisdone> bennofs: that fix happened after 0.6.2.1, seems to me
05:38:51 <chrisdone> lame
05:39:10 <chrisdone> aeson no unit tests to check this simple isomorphism?
05:39:10 <bennofs> chrisdone: You're right, I just checked it.
05:40:12 <donri> i should package up that code i used to generate isomorphism tests for every instance of a class...
05:40:44 <chrisdone> how do you generate the list of instances?
05:41:01 <donri> chrisdone: TH
05:41:25 <donri> https://github.com/acid-state/safecopy/blob/master/test/instances.hs
05:41:35 <bennofs> But even then, the problem might not show because the user can define own instances?
05:42:04 <donri> bennofs: in deed. does this problem only show up in user written instances?
05:42:19 <chrisdone> donri: which TH function gives you the instances of a class name?
05:42:21 <bennofs> donri: Not sure, but data Baz = Foo | Bar didn't trigger it for example
05:42:27 <donri> chrisdone: reify?
05:42:35 <chrisdone> donri: is that a question?
05:43:08 <donri> chrisdone: is this question rhetorical? ;)
05:43:24 <donri> chrisdone: http://hackage.haskell.org/package/template-haskell-2.8.0.0/docs/Language-Haskell-TH.html#t:Info
05:43:33 <donri> ClassI Dec [InstanceDec]
05:43:41 <chrisdone> cool
05:45:23 <donri> and then i also reify Arbitrary etc and test the intersection of all classes, warning for untested instances of SafeCopy
05:45:44 <Two9A> Alright, so. I'm trying to compile a package and getting errors relating to "catches" and "Handler". This package compiled fine on my old ghc6, so did something change around exception handling between 6 and 7?
05:45:49 <donri> i think it's a cute trick :)
05:46:57 <donri> Two9A: extensible-exceptions got merged into base in 6.10
05:47:38 <chrisdone> donri: https://www.youtube.com/watch?v=mlYkIJVguCU
05:48:05 <Two9A> Hm. These seem to be part of Control.Exception; should I try an older version of that, perhaps
05:48:12 <donri> is that the one i saw on your g+ i think it ws
05:48:14 <donri> was
05:48:29 <LeoTal> Hi! So, I'd like to use lambdabot to do things like this: let takeAwayMyFreedomOfChoice l n = l !! (fst $ randomR (0, length l - 1) (mkStdGen n)) in takeAwayMyFreedomOfChoice ["Play Pokemon", "Read about monads", "Do housework"] 42. But I'd rather not have to seed the generator myself, so I'd like to use getStdRandom - but then how do I get to see the value? Doing that directly gets me an IO
05:48:30 <LeoTal> String and won't tell me what's inside, printing doesn't print, unsafePerformIO doesn't exist.
05:48:50 <individual> there's no foldM for mutable IO Vectors?
05:48:56 <donri> chrisdone: yeah it's funny :) got another good one?
05:49:05 <individual> or mapM or anything useful
05:49:18 <edwardk> @pl  \f m n -> f <$> m <*> n <|> m <|> n
05:49:21 <Two9A> Or yeah, an older version of base
05:49:21 <lambdabot> flip flip id . (ap .) . (((<|>) .) .) . join . (flip .) . (((<|>) .) .) . (. (<*>)) . (.) . (<$>)
05:49:21 <lambdabot> optimization suspended, use @pl-resume to continue.
05:49:29 <edwardk> @pl  \n -> f <$> m <*> n <|> m <|> n
05:49:32 <lambdabot> ap ((<|>) . flip ((<|>) . (f <$>) . (m <*>)) m) id
05:49:32 <lambdabot> optimization suspended, use @pl-resume to continue.
05:49:36 <edwardk> bah
05:49:38 <chrisdone> donri: :D
05:50:57 <donri> LeoTal: you either need IO or some way to pass around a generator
05:51:04 <donri> :t state random
05:51:04 <lambdabot> (MonadState s m, RandomGen s, Random a) => m a
05:53:25 <ibotty> hi edwardk, when i see you here. a small q on ermine. is it (supposed to be) non-strict? and besides row types, what kind of types does it permit?
05:53:43 <edwardk> its lazy
05:53:57 <edwardk> rank-n types, polykinds
05:53:58 <ibotty> that's nice to hear :D
05:54:06 <donri> what's a good read on row types, i can't even find a wikipedia article
05:54:21 <donri> is it the same as "row polymorphism"?
05:54:43 <ibotty> i google (earlier today): https://www.cs.cmu.edu/~neelk/rows.pdf
05:54:45 <edwardk> donri: yeah. we have an algorithm we use for inferrable row polymorphism in the presence of 'disjunction' constraints
05:55:09 <edwardk> uses virtual constructors to enable you to to talk about the subtyping relationships in java, etc. explicitly
05:55:30 <edwardk> that way you don't have to give up hindley-milner style inference to work with java
05:56:10 <ghorn> is it possible to write latex in haddocks, or have your doctests show up in .lhs pdf output?
05:57:10 <ibotty> thanks edwardk.
05:57:41 <donri> doesn't haddock have a pdf backend
05:57:42 <ibotty> sounds interesting. i might play with it someday... whenever i find the time
05:57:45 <edwardk> ghorn: no latex in haddocks sadly. re doctests/lhs never found a way that makes sense. maybe you could concoct a \begin{doctest} block or something such that lhs thought they were just a comment
05:58:05 <donri> --latex
05:58:13 <edwardk> and then use some latex wizardry to go through the doctest block and reformat it
06:12:14 <alexander__b> I know this is asked a lot (I have seen it frequently), but I don't remember the answer...
06:12:22 <alexander__b> when's ghc approximately 7.8 due?
06:12:33 <donri> by christmas!
06:12:41 <alexander__b> errr that sentence only more sentence-like
06:12:44 <alexander__b> donri: really?
06:13:00 <donri> no idea. joke.
06:14:09 <chrisdone> No instance for (Alternative ParseResult)
06:14:13 <chrisdone> D: hse!!!
06:15:00 <quchen> alexander__b: End of November.
06:15:24 <bennofs> @hoogle (a -> m ()) -> m c -> a -> m c
06:15:24 <lambdabot> No results found
06:15:30 <bennofs> @hoogle Monad m => (a -> m ()) -> m c -> a -> m c
06:15:31 <lambdabot> No results found
06:15:39 <bennofs> Is there any such function?
06:15:39 <quchen> alexander__b: http://permalink.gmane.org/gmane.comp.lang.haskell.ghc.devel/2569
06:15:52 <bennofs> @ty \x -> (x >=>) . const
06:15:53 <lambdabot> Monad m => (a -> m b) -> m c -> a -> m c
06:17:23 <fryguybob> donri: We have some latex wizardry do embedded diagrams in latex documents.  You might need less then we do: https://github.com/diagrams/diagrams-doc/blob/master/doc/latex.rst
06:17:42 <donri> fryguybob: wasn't for me :)
06:17:50 <donri> ghorn: ^
06:18:00 <fryguybob> Oops :D
06:18:16 <ghorn> looking...
06:18:30 <fryguybob> The actual wizardry is here: https://github.com/diagrams/diagrams-builder/blob/master/latex/diagrams-latex.sty
06:19:08 <chrisdone> huh, no way
06:19:26 <chrisdone> module X (foo,) where is valid syntax
06:19:45 <donri> chrisdone: seen https://www.youtube.com/watch?feature=player_detailpage&v=TS1lpKBMkgg#t=2311 ? he starts talking about structural editing there
06:20:00 <donri> bit earlier
06:21:02 <donri> uh wtf youtube that's not the time i linkend from!
06:21:05 <chrisdone> where does he start talking about it?
06:21:07 <donri> about 38:00
06:21:25 <chrisdone> you can write &t=38m
06:21:37 <donri> i used right click copy url at current time
06:31:12 <Narvius2> I have a list of 3-tuples with unique first elements with an Eq instance; how can I concisely look up one of those tuples based on that "key"?
06:31:50 <geekosaur> 3-tuples makes it difficult (there is a function in Data.List that does that with 2-tuples)
06:32:11 <Narvius2> I'm trying to piece together something neat with lenses.
06:32:13 <Narvius2> But I can't. :/
06:32:28 <geekosaur> any reason you didnt use a Data.Map?
06:33:10 <Narvius2> That form is an intermediary step in a larger algorithm, so I thought map'd be overkill.
06:33:38 <Narvius2> Also, the list is usually rather small.
06:34:11 <donri> has (_1 . only k) or something like that?
06:34:11 <edwardk> > ('x',2,3) ^? filtered (views _1 (== 'x'))
06:34:13 <lambdabot>   Just ('x',2,3)
06:34:21 <edwardk> > ('y',2,3) ^? filtered (views _1 (== 'x'))
06:34:23 <lambdabot>   Nothing
06:34:34 <Narvius2> :D
06:34:36 <Narvius2> Thank you!
06:34:48 <edwardk> > ('x',2,3) ^? filtered (elemOf _1 'x')
06:34:49 <lambdabot>   Just ('x',2,3)
06:34:54 <edwardk> > ('y',2,3) ^? filtered (elemOf _1 'x')
06:34:56 <lambdabot>   Nothing
06:35:07 <edwardk> fewer parens
06:35:48 <donri> > ('x',2,3) ^? filtered (has (_1 . only 'x'))
06:35:51 <lambdabot>   Just ('x',2,3)
06:35:55 <Narvius2> I seriously need more exercise with lenses. :x
06:37:52 <chrisdone> donri: he's got the right idea =)
06:38:05 <donri> chrisdone: sounds like he's describing lamdu ;)
06:40:53 <chrisdone> donri: pretty much
06:41:10 <chrisdone> donri: or interlisp from the 80's, but ja, programmer amnesia
06:41:13 <donri> especially given the "change" stuff at the end
06:42:36 <chrisdone> aye
06:42:38 <merijn> chrisdone: Although I don't think interlisp would support type directed name completion :)
06:42:50 <merijn> Unless they had a typed lisp
06:42:54 <chrisdone> nah
06:43:07 <chrisdone> but in interlisp it would update the live image as you typed
06:43:11 <merijn> That bit is the coolest bit, though :)
06:43:17 <chrisdone> no reparsing, no-recompiling of anything other than the node you're at
06:43:27 * hackagebot terminfo 0.3.2.6 - Haskell bindings to the terminfo library.  http://hackage.haskell.org/package/terminfo-0.3.2.6 (JudahJacobson)
06:44:00 <chrisdone> which i think lamdu either does or might hope to do
06:51:42 <quchen> Is it correct to call "forall a. a" a "bottom type"? The only inhabitant of it is bottom, but the type itself is not. The name confuses me.
06:51:57 <quchen> I would expect the "bottom type" to be the "value" of a kind-level function that does not exist.
06:52:51 <quchen> Wait, let me correct that.
06:53:45 <quchen> Nevermind. I don't know the right words to do so, handwavy will have to suffice
06:53:58 <jophish> Yo
06:58:35 <merijn> quchen: Well, it should be isomorphic to Void, no?
06:58:42 <quchen> Sure.
06:59:05 <quchen> But is Void the bottom type?
06:59:10 <merijn> I don't think haskell has a bottom type, as that would have to be  a type that inhabits every kind
06:59:18 <merijn> And there's no such thing in haskell, afaik
06:59:20 <geekosaur> ...yet
06:59:22 <quchen> Right, that's what I would think.
06:59:35 <quchen> But Wikipedia calls "Void" the bottom type, for example.
06:59:47 <merijn> geekosaur: I'm not a psychic so I try to restrict my comments to the present :)
06:59:57 <merijn> quchen: Wikipedia is notoriously terrible for these things
07:00:16 <geekosaur> that was more a comment on all the new type/kind/mumble machinery finding its way into recent ghcs
07:00:19 <merijn> Learning type theory from wikipedia is a fool's quest
07:00:39 <quchen> merijn: Glad to hear that, this article confused me quite a bit.
07:01:00 <geekosaur> at some point you just *know* there will be type level bottom. And probably kind level bottom shortly thereafter :p
07:01:09 <merijn> quchen: I'd just try and get a proper book :)
07:01:14 <merijn> Like
07:01:17 <merijn> @where TaPL
07:01:18 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
07:01:56 <geekosaur> (actually it probably has both already --- masquerading as compiler nontermination bugs :)
07:02:43 <geekosaur> (if you can call that "masquerading"...)
07:04:02 <quchen> merijn: Neat. Now I need to find a website I have a uni subscription to that gives me the ebook version of that.
07:04:21 <quchen> I've seen the cover of that book multiple times though, and it seems to be highly praised :-)
07:16:19 <mar09> ciao
07:16:24 <mar09> !list
07:16:25 <monochrom> mar09: http://lpaste.net
07:20:07 <geekosaur> more evidence there's some Italian "how to be a hacker" or something that starts with dropping "!list" into a busy channel...
07:21:19 <mangaba_leitosa> geekosaur: :-)
07:22:12 <geekosaur> (we got an especialy clueless one in another channel last week)
07:34:01 <donri> fun: if you hide a record's constructor but export its fields, you can still use the fields as setters, thus side-stepping the constructor hiding
07:34:56 <donri> also fun: the solution is to exploit the fact that records aren't first-class, so we can just export a field = internalField
07:35:19 <donri> it has the exact same type, but can't be used as a setter
07:35:23 <chrisdone> TYL
07:36:00 <donri> actually i learnt this before, but discovered old code had the problem ;)
08:06:06 <saml> hello. how can i do things?
08:06:22 <briennetheblue> with haskell you can do things
08:06:46 <simukis_> briennetheblue: that's not an answer to how.
08:07:04 <simukis_> saml: by writting some (haskell) code maybe?
08:09:04 <briennetheblue> oh... as in do notation, maybe?
08:12:05 <chrisdone> @faq can haskell do things?
08:12:05 <lambdabot> The answer is: Yes! Haskell can do that.
08:13:23 <t7> @faq can haskell into webscale?
08:13:23 <lambdabot> The answer is: Yes! Haskell can do that.
08:19:22 <simukis_> @faq can haskell?
08:19:22 <lambdabot> The answer is: Yes! Haskell can do that.
08:21:27 <ibid> @faq can of haskell?
08:21:27 <lambdabot> The answer is: Yes! Haskell can do that.
08:21:41 <ibid> @faq can opener
08:21:42 <lambdabot> The answer is: Yes! Haskell can do that.
08:23:21 <Sculptor> hello
08:23:28 <briennetheblue> hi
08:23:39 <saml> i mean.. I have data Expr = :+ Expr Expr | A Int | Empty | B Int
08:24:45 <saml> so, I want to do do  B 2 :+ Empty :+ A 1 :+ B 1 :+ Empty    =>    B 2 :+ B 1 :+ A 1
08:24:57 <saml> I want to put all A's  to the back. and remove all Empty
08:25:02 <saml> order of B's are kept
08:25:22 <saml> so it's normalizing expression
08:25:34 <saml> where A's are back
08:34:28 <haasn> smells like ([Int], [Int])
08:34:55 <mzero> saml: you want to write  simplify :: Expr -> Expr -> Expr    right?
08:34:58 <mzero> er
08:34:59 <mzero> no
08:35:04 <mzero> simplify :: Expr -> Expr
08:35:11 <haasn> At least if your :+'s are always nested so linearly
08:35:25 <saml> yah
08:36:02 <mzero> so given that your data structure is a tree (it isn't linear), you need to think about how to implement simplify as a recursion over a tree
08:36:23 <mzero> you might start with writing what simplify does for each of the four cases of Expr
08:36:51 <mzero> simplify (A i) = A i      simplify (B i) = B i     simplify Empty = Empty
08:37:19 <mzero> but when it comes to    simplify (:+ e1 e2) =
08:37:28 <mzero> you have to think what simplify means.....
08:38:05 <malvarez> Would this https://gist.github.com/m-alvarez/4efd59755f7ff53ce81d be a good analogue of a doubly-linked list in Haskell? Any way to make it nicer?
08:38:46 <geekosaur> not sure doubly linked lists can ever be "nice" in haskell, short of e.g. zippers
08:39:44 <malvarez> That's actually kind of my goal: to understand zippers by trying to solve the problem myself
08:40:56 <n-dolio> You should never ask for doubly linked lists. You should ask for a data structure with certain properties.
08:41:15 <n-dolio> Like, what properties do you want out of a doubly linked list in an imperative language.
08:41:17 <mzero> malvarez: you should look into the data structure called a zipper
08:41:30 <mzero> ah
08:41:43 <mzero> I think your whole "put" mechanism is overly complicated
08:42:11 <n-dolio> Then you can evaluate whether other data structures fit that need in Haskell or elsewhere, rather than worrying about whether something is a doubly linked list, or how to build one, which isn't an end in itself.
08:42:14 <malvarez> mzero: that's the kind of feedback I'm looking for
08:43:07 <malvarez> n-dolio: I'm not interested in doubly-linked lists by themselves, I'm more interested on data structures you can 'traverse back and forth', possibly making some updates
08:43:11 <malvarez> 'updates'
08:43:24 <mzero> why not just?    DL { prev: [a], currAndRest: [a] }
08:43:50 <n-dolio> malvarez: Right. It's good that you recognize that. :)
08:44:11 <n-dolio> We get lots of questions from people who don't. :)
08:44:12 <malvarez> mzero: yeah, that makes sense, but I was looking for something that I can hope to generalize to, say, trees.
08:44:17 <mzero> I think you are hung up because you are thinking "update" -- really, think "make a new list, substituting x for the current element"
08:45:24 <mzero> malvarez: a good project --- start by writing the simple list version --- and then look at your key operations:  next, prev, get, replace (or update if you prefer the name)  --- and think about the essential thing going on in each
08:45:44 <mzero> that could lead you to the core operations, and perhaps a typeclass you could make: Zippable
08:47:23 <malvarez> mzero: that sounds interesting. I think I'll start with trees though (my original goal was to move around in a tree)
08:52:13 <LeoTal> I'd like lambdabot to @join ##megaharem. Is that okay, and if so whom should I pester for privileges?
08:54:03 <lzm> LeoTal: what's the channel about?
08:57:10 <dmwit> LeoTal: Last I knew, elliott was in charge of \bot. You can also build and run an instance yourself.
08:57:39 <LeoTal> lzm: It's for people involved in a certain polyamorous relationship, so it's mostly about cuddles, declarations of love, category theory, logic, topology, movies, making plans, and occasional relationship drama.
08:58:58 <LeoTal> dmwit: Thanks! Does getting my own have any advantages besides "elliott doesn't get pestered"?
09:01:11 <dmwit> Not really.
09:02:08 <saml> i have a list. I want to move certain elements to the end of the list. how?   [1,2,-1,3,-1] ==> [1,2,3,-1,-1]
09:02:13 <loans> god dammit
09:02:15 <saml> not sorting
09:02:17 <loans> wrong channel
09:02:26 <saml> loans, right channel. asl?
09:03:14 <dmwit> > delete (-1) [1,2,-1,3,-1] ++ [-1]
09:03:15 <lambdabot>   [1,2,3,-1,-1]
09:03:16 <saml> let bubble pred list = map list pred
09:03:34 <saml> no it's not that simple
09:03:40 <saml> i want predicate
09:03:53 <saml> maybe there's partition or something
09:04:25 <dmwit> > let (b, e:es) = splitAt (==(-1)) [1,2,-1,3,-1] in b ++ es ++ [e]
09:04:26 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
09:04:26 <lambdabot>              with actual type ...
09:04:29 <dmwit> whoops
09:04:34 <dmwit> > let (b, e:es) = break (==(-1)) [1,2,-1,3,-1] in b ++ es ++ [e]
09:04:35 <lambdabot>   [1,2,3,-1,-1]
09:04:48 <saml> wait.. my structure is actually a tree, not list. maybe i'll flatten the tree to list and the work on split and concat
09:05:15 <dmwit> I feel like I'm in some bizarro world where every solution causes the problem to mutate.
09:05:50 <saml> yah i'm working on scala. it didn't translate well
09:08:45 <briennetheblue> > foldMap (\ x -> if x >= 0 then ([x], []) else ([], [x])) [1,2,-1,3,-1]
09:08:46 <lambdabot>   ([1,2,3],[-1,-1])
09:08:56 <dmwit> oh god
09:09:09 <dmwit> > partition (>=0) [1,2,-1,3,-1]
09:09:11 <lambdabot>   ([1,2,3],[-1,-1])
09:09:20 <briennetheblue> o well
09:09:24 <S11001001> @src foldMap
09:09:25 <lambdabot> Source not found. You type like i drive.
09:09:41 <dmwit> S11001001: It's a Foldable method, I think.
09:09:52 <briennetheblue> yes
09:10:06 <S11001001> dmwit: for some reason I thought it would print the [] variant
09:10:30 <dmwit> You can ask it to do that. Whether it knows the answer is another question.
09:10:47 <dmwit> ?src [] mappend
09:10:47 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
09:10:51 <dmwit> ?src mappend []
09:10:51 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
09:11:04 <dmwit> ?src [] (>>=)
09:11:04 <lambdabot> xs >>= f     = concatMap f xs
09:11:08 <S11001001> eh
09:11:08 <dmwit> ?src [] foldMap
09:11:08 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
09:11:14 <dmwit> Okay, it doesn't know it. =)
09:21:08 <apo> Hrm. I'm playing with functional dependencies and am trying to make a vector class so I can do vector*vector, scalar*vector, or vector*scalar, but in my sample code ( http://p.0au.de/8d1d320a/blah.hs ) I get errors about ambiguous references when using *, because it could refer to Main.* or Prelude.*
09:21:13 <apo> What am I doing wrong?
09:22:32 <donri> apo: you'd have to import Prelude hiding ((*)) but probably better rename yours (or see if you can make a Num instance for your vector)
09:22:59 <apo> donri: But Num (*) does a->a->a, no?
09:23:39 <donri> apo: yes
09:23:52 <fizbin> Anyone know much about Haddock? I have a comment that it's rejecting but with no indication as to what might be wrong.
09:24:00 <fizbin> It's the comment starting here: https://github.com/fizbin/lens/blob/master/src/Control/Lens/Setter.hs#L1199
09:24:01 <donri> fizbin: try us
09:24:19 <dmwit> apo: "class Mult a b c | a b -> c where (*) :: a -> b -> c" declares two new names, "Mult" (at the type-level), and "(*)" (at the term-level).
09:24:31 <fizbin> The haddock doc on exactly what's allowed is a bit... sparse.
09:24:37 <dmwit> apo: Since there's already a "(*)" at the term-level from the Num typeclass, this makes it ambiguous which one you want to use.
09:24:37 <fizbin> And missing.
09:25:39 <donri> fizbin: how is it "rejecting"?
09:25:43 <fizbin> apo: my very strong suggestion is that you rename your dot product operator. How about (.*.) ?
09:27:20 <lpaste> fizbin pasted “haddock output” at http://lpaste.net/95028
09:27:48 <fizbin> donri: like that. (line 24 and following)
09:28:23 <dmwit> fizbin: I don't know what's wrong. If I were faced with this, I would use the standard "binary search" debugging technique.
09:29:21 <donri> fizbin: random shot in the dark: @@ allows markup, and _ is markup, so _1 is what's confusing it
09:29:30 <apo> fizbin: hrm
09:30:01 <donri> fizbin: in particular you have three underscores, which means the last one is "open"
09:31:24 <donri> fizbin: but you might want to use the > markup for that code block instead, because you have no (intentional) markup in it
09:31:41 <fizbin> donri: The haddock documentation does not claim that _ is markup.
09:31:54 <apo> fizbin: I guess that'll work, thanks.
09:32:12 <TallerGhostWalt> Are floats 64 bit on a x86_64 bit machine in ghc?
09:32:18 <donri> fizbin: oh
09:32:20 <fizbin> However, < might be...
09:32:33 <donri> The following characters have special meanings in documentation comments: /, ', `, ", @, <. To insert a literal occurrence of one of these special characters, precede it with a backslash (\).
09:33:08 <donri> fizbin: it seems you can also work around it by linking, so '<~<' is fine for example
09:43:28 <fizbin> Ah. It was the fact that I had lines where the first non-whitespace character was > inside that code block. I need to backslash the initial > in >>>
09:46:19 <TallerGhostWalt> 11:29 *** fronx QUIT Remote host closed the connection
09:46:36 <TallerGhostWalt> Looks like Float is still 32 bit on x86_64
09:46:50 <dmwit> Correct.
09:47:13 <TallerGhostWalt> k
09:47:13 <TallerGhostWalt> th
09:47:15 <TallerGhostWalt> thx
09:47:38 <dmwit> (Was there a reason to believe that the size of Float would depend on architecture?)
09:47:54 <LeoTal> @tell elliott Hi! I'd like lambdabot to @join ##megaharem. I was told to pester you for the relevant privileges.
09:47:54 <lambdabot> Consider it noted.
09:52:09 <osfameron> megaharem?
09:52:49 <dmwit> 11:52 < LeoTal> lzm: It's for people involved in a certain polyamorous relationship
09:54:30 <simpson> The channel topic is instructive, I feel.
09:54:42 <simpson> Also isn't this Freenode? :3
09:55:33 <LeoTal> osfameron: I don
09:56:44 * osfameron wonders why lambdabot would find that of relevance :-)
09:56:48 * osfameron shudders to think
09:56:56 <LeoTal> osfameron: I don't think it holds much interest for uninvolved people, but if someone wants to come watch us go "I love you so much! *cuddles*" and plan reading-linalg-textbooks dates, we don't mind it.
09:57:54 <simpson> LeoTal: You can run your own lambdabot; she is open-source.
09:57:56 <LeoTal> osfameron: I wanted to ask a Haskell question to my boyfriend's boyfriend's boyfriend today, and it would have been convenient to have lambdabot around. Plus, Haskell is romantic.
09:58:25 <LeoTal> simpson: I know, but I don't see any upsides to it other than not having to annoy elliott
09:58:51 * Kinnison raises an eyebrow.  If Haskell is romantic, I should use it more
09:59:00 <simpson> LeoTal: lambdabot is a shared resource; every channel that she is in is another channel that she has to handle requests for, and it slows her down for everybody else.
09:59:32 <simpson> LeoTal: Additionally, you can customize your own lambdabot if you like, without having to alter the one running in #haskell.
10:00:09 <osfameron> also lambdabot presumably only has one brain for factoids etc., which might be interesting
10:00:57 <briennetheblue> import Data.Graph.Relationship
10:01:21 <simpson> LeoTal: So those are a handful of upsides to running your own!
10:01:57 <TallerGhostWalt> dmwit: Just parsing a binary string from a protocol and having some trouble getting things lined up.
10:02:06 <TallerGhostWalt> dmwit: Making sure I was right
10:02:39 <dmwit> As far as I know, there is no correct way to parse a Float or Double from a binary protocol.
10:03:10 <dmwit> (Except to serialize it to ASCII, and even that encoding is lossy.)
10:04:05 <LeoTal> simpson: Hm, the slowing might be relevant, yes. Are requests the main source of load, or is listening to every message a significant cost?
10:04:27 <simpson> LeoTal: Presumably the former.
10:06:05 <simpson> > fix error
10:06:07 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
10:06:18 <FreeFull> dmwit: Define in the protocol which parts of the float are which
10:06:43 <dmwit> FreeFull: Not helpful. The IEEE754 spec doesn't specify a way to query or set the particular bits of the storage format.
10:06:52 <FireFly> simpson: that's really, really, really ... broken
10:06:59 <LeoTal> simpson: We're a very small channel, so I don't think that's significant, especially if I'd query lambdabot otherwise. But thanks.
10:07:04 <simpson> FireFly: Uh-uh, I fixed it.
10:07:50 <dmwit> s/ the//
10:08:09 <hamh> Hi quick question about how best to structure my haskell programs. If possible is it better for runtime performance to define pure versions of your functions and then apply something like liftM to them in the main do block?
10:08:13 <malvarez> Are there any good resources on how to structure large-scale Haskell applications?
10:08:26 <malvarez> I don't have anything specific in mind, just curiou
10:08:43 <simpson> hamh: It's generally a better way to reason about your functions.
10:08:48 <FireFly> LeoTal: for a private/personal channel where I thought it'd be neat to have "lambdabot" support I simply had my bot ask lambdabot and relay the reply to the channel. That's always a workaround..
10:08:48 <dmwit> hamh: It's not particularly different for performance. It is particularly different for testing and maintenance.
10:09:12 <FireFly> LeoTal: (asking with /msg, that is)
10:09:42 <dmwit> FireFly: That's not going to work for ?ask/?tell.
10:09:58 <dmwit> Where the identity of the person making the /msg matters.
10:10:46 <LeoTal> FireFly: Making a bot and having it ask lambdabot seems inferior to getting my own lambdabot, since it puts load on lambdabot. If I already had a bot and just had to add the feature it'd be different.
10:11:17 <hamh> Ok, so best in general to write pure and monadify as needed. Is there a good resource for info about structuring haskell idiomatically that you guys can recommend? I'm using hlint but that doesn't touch broader issues
10:11:36 <FireFly> dmwit: true
10:20:45 <bergmark> hamh: that's bound to be very opinionated, and hard to make exhaustive. Here's something related: http://fvisser.nl/post/2013/may/28/towards-a-better-haskell-package.html
10:21:54 <bergmark> maybe more high level than what you asked for
10:37:44 <HugoDaniel> hi
10:37:52 <HugoDaniel> im trying to upload a package to hackage but im getting a 403 forbidden error
10:38:11 <donri> HugoDaniel: have you upgraded your account?
10:38:32 <HugoDaniel> no :(
10:38:35 <HugoDaniel> how can i do that ?
10:38:39 <donri> HugoDaniel: try logging in on the site
10:40:04 <HugoDaniel> cool :D
10:40:05 <HugoDaniel> done
10:40:19 <donri> HugoDaniel: upload working now?
10:40:24 <HugoDaniel> yes
10:40:28 <donri> \o/
10:40:28 <HugoDaniel> just uploaded it
10:40:38 <HugoDaniel> i love the anarchist feel of hackage :D
10:40:48 <donri> it's less anarchist now
10:40:52 <HugoDaniel> rly ?
10:41:04 <HugoDaniel> why ?
10:41:40 <HugoDaniel> i realy enjoyed uploading packages just because :D
10:41:54 <donri> HugoDaniel: oh, still anarchist in that regard
10:42:00 <dmwit> Well, you can't upload a new version of somebody else's package without their permission any more.
10:42:03 <dmwit> So that's less anarchist.
10:42:10 <donri> but you can't upload to existing packages that you don't have permissions for
10:42:20 <HugoDaniel> oh
10:42:21 <haasn> I miss being able to accidentally break every program in existence :(
10:42:27 <haasn> RIP anarchy
10:42:36 <donri> i regret never putting a trojan in base
10:42:39 <donri> ...or did i...
10:42:42 <HugoDaniel> ahaha
10:42:43 <HugoDaniel> :D
10:42:54 <dmwit> ha
10:43:03 <dmwit> Luckily, I never get base from Hackage...
10:43:07 <donri> in deed
10:44:04 * hackagebot iso639 0.1.0.0 - ISO-639-1 language codes mapping to Haskell datatypes from the official site (http://www.loc.gov/standards/iso639-2/php/English_list.php)  http://hackage.haskell.org/package/iso639-0.1.0.0 (HugoGomes)
10:44:38 <dmwit> > "Gomes" == "Daniel"
10:44:39 <lambdabot>   False
10:44:41 <dmwit> Impostor!
10:45:42 <HugoDaniel> :D
10:45:47 <HugoDaniel> thats me
10:45:50 <HugoDaniel> iso639
10:46:40 <HugoDaniel> its just a lazy arse parse of the html table, and a dump with haskell-src of the language codes
10:48:26 <HugoDaniel> hugo daniel is my "first name", the guy that runs hackage told me i could only have one first name, so yeah
10:48:54 <yitz> HugoDaniel: do you play for the red sox?
10:48:59 <HugoDaniel> lol
10:49:00 <HugoDaniel> no
10:49:02 <HugoDaniel> what is that ?
10:49:12 <yitz> HugoDaniel: nm
11:04:07 * hackagebot iso639 0.1.0.1 - ISO-639-1 language codes mapping to Haskell datatypes from the official site (http://www.loc.gov/standards/iso639-2/php/English_list.php)  http://hackage.haskell.org/package/iso639-0.1.0.1 (HugoGomes)
11:10:07 <joelteon> :t ½
11:10:07 <lambdabot> Not in scope: data constructor `½'
11:10:17 <joelteon> oh, is that a capital letter?
11:10:22 <joelteon> I guess it is
11:14:15 <kem_> hi
11:15:06 <haasn> > generalCategory '½'
11:15:08 <lambdabot>   OtherNumber
11:15:35 <kem_> before starting out haskell should i need to know any programming language (as basis )?
11:16:11 <geekosaur> not really
11:16:33 <geekosaur> in some ways it's better not to, as there are things you'd have to "unlearn" after starting with a procedural language
11:19:15 <kem_> k so no programming language is required right to learn haskell right ?
11:19:41 <Mortomes> Hasn't that question been answered already?
11:19:54 <tac> It's unusual for people to learn Haskell first. But that's more of a cultural thing, I think most people here would argue.
11:20:31 <Mortomes> Yeah, you're more likely to encounter something like java/python/C# in college first
11:21:32 <kem_> thanks
11:21:40 <LeoTal> tac: It seems to me that Haskell requires more independent insights than learning to program at all does
11:22:03 <tac> LeoTal: I don't know what you mean by independent insights.
11:22:42 <monochrom> insights are overrated
11:23:16 * roconnor learned Coq before Haskell.
11:23:40 <tac> If you learn Haskell first, I imagine you would grow to instantly see that most of the software industry is utterly insane.
11:24:08 <simpson> tac: Not really.
11:25:01 <simpson> I find that it's the really *really* opinionated languages that make one feel that way. Smalltalk, Prolog, and Forth all taught me things like that, but Haskell didn't.
11:25:02 <monochrom> I see them cavalier rather than insane
11:25:03 <LeoTal> tac: 1) computers as purely mechanical and predictable - I don't have a good way of explaining this, but it's what distinguishes programmers from non-programmers in that camel-has-two-humps study - it may have moving parts rather than be one big insight, but if you learn it you'll be able to write Hello World in BASIC; 2) types; 3) functional programming; 4) monads
11:25:57 <tac> LeoTal: I don't think that's an especially coherent picture.
11:27:06 <tac> In something like C++, you're learning a lot of other things, too, like call-by-value versus call-by-reference, classes and the complexity of OOP, memory management, etc.
11:28:20 <monochrom> more accurately: through the haskell looking glass, I see the industry cavalier rather than insane. overly self-confident, solo heroism, always wanting writer's freedom and trashing reader's predictive power.
11:28:32 <geekosaur> ^
11:28:33 <LeoTal> tac: Never said it was! The thing I'm trying to convey is that learning your first language makes you go "augh my brain", and so does learning Haskell when you know another language, so maybe compounding two "augh my brain"s is unwise. I don't get the impression that memory management does that, though learning what a pointer is does. ...and I think I'm arguing myself into liking Basic.
11:28:36 <lpaste> stepcut pasted “ghc panic?” at http://lpaste.net/95032
11:28:51 <tac> monochrom: I could weaken my statement comfortably to that one.
11:28:51 <monoidal> stepcut: it's a well-known panic, fixed in HEAD
11:29:07 <roconnor> monochrom: the industry doesn't seem to appreciate constraint and/or simple semantics.
11:29:18 <tac> ehhh? Memory management and pointers are the bane of a new C++ programmer's existence!
11:29:34 <tac> The two classic "hard to teach" things in programming are recursion and pointers.
11:29:59 <LeoTal> Agree with you on pointers.
11:30:13 <monoidal> stepcut: lift <anything> <anything> is a kind error; you probably want lift (<something> <something>)
11:30:21 <stepkut> can someone using ghc >= 7.8.1 tell me if this still causes a compiler panic, http://lpaste.net/95032
11:30:31 <stepkut> don't want to file a bug if it is already fixed :)
11:30:34 <monoidal> stepkut: did you see my above message?
11:30:36 <roconnor> LeoTal: are you familiar with monad fixpoints, a la mfix or recursive do?
11:31:12 <LeoTal> roconnor: No, sorry
11:31:21 <stepkut> monoidal: right, that code is buggy itself -- but I care if the compiler panic is fixed or not :)
11:31:31 <roconnor> LeoTal: if you learn it, it will remind you how hard recursion is to learn.
11:31:38 <monoidal> stepkut: ah, you were disconnected
11:31:51 <monoidal> stepkut: it's a well-known panic, fixed in HEAD
11:31:57 <monoidal> stepkut: lift <anything> <anything> is a kind error; you probably want lift (<something> <something>)
11:32:07 <stepkut> monoidal: ah thanks!
11:32:25 <stepkut> I shan't report it then
11:33:19 <joelteon> oh, neat
11:34:12 * hackagebot sgd 0.3.3 - Stochastic gradient descent  http://hackage.haskell.org/package/sgd-0.3.3 (JakubWaszczuk)
11:34:59 <donri> :t lift f a
11:35:13 <donri> monoidal: even with the function monad?
11:35:27 <monoidal> donri: it's a kind error, instances do not matter
11:35:53 <donri> oic
11:36:48 <monoidal> it's the most often reported bug in 7.8, about 20 reports
11:36:51 <monoidal> 7.6
11:37:51 <monoidal> does anyone know if "brew install ghc" installs 7.6.1 or 7.6.3?
11:41:57 <frxx> @pl \f (x,y) -> (f x, f y)
11:42:09 <frxx> @pl (\f (x,y) -> (f x, f y))
11:42:20 <monoidal> frxx: first f . second f
11:42:54 <frxx> wasn't there a function in prelude that did this? something like both f (it is not both)
11:42:55 <monoidal> or f &&& f
11:42:57 <monoidal> f *** f
11:42:58 <geekosaur> lambdabot apparently got killed by the netsplit at 18:25 UTC
11:43:26 <joelteon> :t over both
11:43:32 <joelteon> oh, right
11:43:35 <joelteon> whoops
11:43:47 <mlen> monoidal: 7.6.3
11:44:52 <monoidal> mlen: thanks. this can depend on OS X version, right?
11:45:00 <monoidal> frxx: both is in lens
11:46:18 <mlen> monoidal: AFAIK no
11:46:35 <monoidal> mlen: thanks
11:48:10 <mlen> monoidal: they have hardcoded 7.4.2 for some reason, but the dsl changed so much since I contributed formulas to homebrew that I no longer understand what happens there https://github.com/mxcl/homebrew/blob/master/Library/Formula/ghc.rb
11:48:18 <Rylee> oh dear
11:48:22 <Rylee> lambdabot is gone D:
11:48:54 <quchen> She needs a vacation sometimes. It's not easy to lookup types 8 hours a day, every day.
11:49:27 <mlen> monoidal: anyway the "bottled" version is 7.6.3.
11:49:48 <edwardk_> :t join (***)
11:49:54 <edwardk_> oh, no lambdabot
11:50:44 <roconnor> (a -> b) -> (a,a) -> (b,b)
11:51:02 <malvarez> Excuse the (perhaps off-topic) question, but does anybody know of a proof assistant that's good for category theoretical proofs?
11:52:03 <roconnor> malvarez: as an expert in interative theorem provers I will tell you that when I want to formalize category theory proofs ... I just use paper :(
11:53:08 <malvarez> roconnor: isn't that...ironic? Since most proof assistants are based on (dependent) type theory, one would expect category theory to be the foremost domain of application...
11:53:16 <roconnor> I think a good category theory library could be put together in Coq/Adga/whatever but would be tricky to get right.
11:53:23 <edwardk_> clearly if i ever write a proof assistant it should be named 'paper' or 'whiteboard'  =)
11:53:28 <roconnor> category theory is really really abstract.
11:53:33 <malvarez> Yeah, I absolutely don't want to go there.
11:53:40 <malvarez> As in, write my own library
11:53:47 <roconnor> like when monoidal categories are defined in terms of monoidal categories.
11:53:48 <edwardk_> dan peebles has a pretty solid category theory library in agda
11:53:53 <edwardk_> but its a hard slog
11:53:57 <edwardk_> it has to be _very_ explicit
11:54:21 <edwardk_> and it'll bring your computer to its knees
11:54:57 <edwardk_> roconnor: i adopted your version of alongside =)
11:55:01 <malvarez> That's sad.
11:55:23 <roconnor> I mean, we can do the odd order theorem in Coq, so I think we could do category theory, probably with less effort even.
11:55:23 <edwardk_> malvarez: they are looking at doing better hash consing in a future agda version, which should help out a lot
11:56:14 <Guest86186> Haskell Noob here, how do you cast a String to a float or int?
11:56:18 <edwardk_> once you get set up you can work just fine with it in agda, but you need to know how to use the tools, then you can get set up where you load everything in the right order over 10 minutes and get into a state where you can keep tweaking and rebuilding one module
11:56:25 <edwardk_> > read "123" :: Double
11:56:50 <malvarez> harsh
11:56:56 <Saizan> 10 minutes is a lot, i think you can load the whole library in 5 :)
11:57:06 <edwardk_> read :: Read a => String -> a -- assumes you won't fail. there is also readMaybe, and readEither nowadays in Text.Read
11:57:14 <Saizan> 32bit agda helps
11:57:17 <malvarez> I'll probably just start with Coq and see where I get...
11:57:20 <WraithM_> Is lambdabot down?
11:57:23 <edwardk_> Saizan: heh, well, i'm not that good at agda ;)
11:57:39 <Saizan> malvarez: there are some Coq libraries too, e.g. catdb
11:57:42 <roconnor> malvarez: I strongly suggest starting with the notion of an enriched category.
11:57:46 <geekosaur> WraithM_, yes
11:57:47 <edwardk_> malvarez: anyways, peebles efforts are probably the most robust ones  know of
11:57:54 <edwardk_> er i know of
11:57:58 <donri> link?
11:58:03 <geekosaur> there was a netsplit about half an hour ago and lambdabot went with it :(
11:58:03 <WraithM_> geekosaur: Thanks
11:58:09 <malvarez> Saizan: I'll look into that
11:58:18 <edwardk_> https://github.com/copumpkin/categories
11:58:26 <donri> thanks
11:58:30 <malvarez> edwardk_: I'm not sure I actually need that much power
11:58:40 <roconnor> malvarez: actually I take that back;  I don't even know how to start.
11:58:44 <edwardk_> well, i offer it up, if only as reference
11:58:57 <malvarez> I'll look into that anyways
11:59:06 <malvarez> every little bit helps
11:59:12 <monochrom> most proof assistants are all about implicational reasoning and not equational reasoning. but equational reasoning is exactly what you need for category theory
11:59:36 <mzero> anyone here upgraded to OS X 10.9 (Mavericks), but still on Xcode 4?
11:59:40 <edwardk_> hrmm. its gotten a lot cleaner. https://github.com/copumpkin/categories/blob/master/Categories/NaturalTransformation/Core.agda#L56 used to be littered with all sorts of universes, etc.
12:00:02 <Luke> mzero: no but I wish I had
12:00:05 <malvarez> What about twelf? does anyone have any experience with that one?
12:00:13 <Saizan> i think the nicest way to do category theory in type theory is to try to turn the axiomatic proofs into computation as much as you can
12:00:36 <mzero> Luke - did you move to Xcode 5?  I have a simple shell script that fixes up GHC for that situation now
12:00:38 <Luke> mzero: as far as I know if you're upgraded to xcode5 your only option is to use brew to install gcc and just not use the llvm backend
12:00:42 <mzero> NOW
12:00:43 <mzero> NO
12:00:45 <mzero> you don't
12:00:46 <Luke> mzero: what does it do?
12:00:54 <mzero> https://gist.github.com/mzero/7245290
12:01:08 <Saizan> malvarez: only with some formalization of lambda calculus
12:01:22 <Saizan> malvarez: CT seems to not be the kind of thing that'd work well there
12:01:22 <edwardk_> malvarez: https://groups.google.com/d/msg/bostonhaskell/aIhVNRdWOPk/uMQ44-NgYEEJ was from the announcement of his talk on agda last year. we sent it out as an april fools announcement about us changing the name of boston haskell
12:01:29 <mzero> tells gcc to use the script (itself) as the C compiler - and then, if your gcc is really clang (which it is under Xcode 5), then fixes the command line args so things work
12:01:54 <Luke> mzero: that's awesome. so this uses clang and just makes it work?
12:01:59 <edwardk_> oh, actually i guess that was for derek's talk
12:02:02 <malvarez> Saizan: even then, if it's good enough to prove stuff like type erasure being semantics-preserving, I might be able to use that for some other stufff
12:02:04 <mzero> I've tested it on several machines (10.8/Xcode 4 and 10.9/Xcode 5)
12:02:07 <edwardk_> preflex: xseen ddarius
12:02:07 <preflex>  ddarius was last seen on freenode/#haskell 1 year, 60 days, 9 hours, 53 minutes and 22 seconds ago, saying: > let f n = g (n-1) where g k [] = []; g 0 (_:xs) = g (n-1) xs; g k (x:xs) = x:g (k-1) xs in f 5 "hello, world"
12:02:09 <edwardk_> =(
12:02:11 <mzero> Luke -yes
12:02:14 <mzero> okay
12:02:16 <Luke> mzero: did you put this on reddit?
12:02:18 <mzero> heading >>= lunch
12:02:24 <Luke> mzero: nice - thanks
12:02:24 <mzero> not yet - I wanted a few people to test it
12:02:29 <mzero> I will soon is
12:02:32 <mzero> soonish
12:02:32 <Luke> k
12:02:35 * edwardk_ is going to go over to his apartment and make him log into IRC some time soon. ;)
12:02:35 <mzero> back later
12:02:41 <malvarez> I'm basically trying as hard as I can not to use Coq. Don't have much experience with it, but I remember the syntax being obnoxious and arbitrary
12:02:50 <Saizan> malvarez: it's good at dealing with binders, it's just not very good at abstracting over predicates/types and similar
12:02:59 <edwardk_> malvarez: hence my efforts to steer you toward agda ;)
12:03:19 <roconnor> malvarez: Coq has canonical structures though.
12:03:23 <malvarez> edwardk_: I'll definitely have to consider it
12:04:13 <divyansr> You should not start language war when monarch is Haskell
12:04:34 <malvarez> Saizan: that might actually kill it for me, I'd need to prove semantics are preserved for all type systems of a certain kind
12:07:42 <rasfar> What would a person do to show the reduction sequence of a Haskell expression? I've tried Hat and Hood, and they sort of do it ... ghci tracing sort of does ....
12:08:52 <monochrom> I recommend paying me to do it
12:09:14 <rasfar> Just basic lambda calculus stuff, pedagogical as it were -- it seems like it should be easier than I'm finding it... haha monochrome, your price would go up with your boredom
12:09:22 <cariveri> hi. can I assign a class C to a in "type L a = B a" ?
12:10:14 <malvarez> cariveri: like 'type L a = (C a) => B a'?
12:10:21 <monochrom> cariveri: I don't understand the question. but I bet the answer is no.
12:10:38 <bergmark> cariveri: or http://ghc.haskell.org/trac/haskell-prime/wiki/TypeSynonymInstances ?
12:11:08 <donri> i bet the answer is "maybe". maybe RankNTypes or ConstraintKinds, depending on what you actually want.
12:11:24 <donri> or TypeSynonymInstances, yeah :)
12:11:55 <malvarez> cariveri: perhaps some more information would be necessary
12:12:18 <cariveri> I stil trying to understand our suggestions. let me think :)
12:14:19 <cariveri> well, in "type L a = B a" ? I want to make sure when ever L is used the a is of a specific other type or class. more like type L (String a) = B a  ?
12:14:41 <malvarez> Then why not just 'type L = String'?
12:15:29 <malvarez> I don't think you can do it for classes, though. Definitely not without language extensions.
12:16:05 <monochrom> cannot be done. please put those conditions right in functions' type sigs.
12:16:12 <monoidal> cariveri: do you want to define a type L such that for example L (Maybe a) = Either a a? then look for type families
12:16:37 <dmwit> rasfar: Write a Haskell interpreter and step it. =)
12:17:45 <monochrom> why do people love so much to use type synonyms as intentionally leaky abstractions?
12:18:25 <rasfar> dmwit -- I'm prepared to do so, but it feels like a fool's errand -- it seems such a natural thing to ask of a Haskell interpreter
12:18:51 <rasfar> I did so in a course years ago actually, but what old HD is that on? dunno
12:18:52 <malvarez> rasfar: it would be awesome - and very useful - if someone added that functionality to lambdabot
12:18:55 <monochrom> I am also prepared to do so, but I want someone to pay me
12:18:59 <Hodapp> intentionally leaky abstractions?
12:19:58 <rasfar> i'm only really interested in pedagogical cases. I don't even ask for ADTs ... alright I'll do it. But I also need a parser. Gah.
12:20:25 <dmwit> rasfar: Hack ghci to do it... ;-)
12:20:40 <Saizan> @google stepeval
12:20:42 <rasfar> We used Parsec back in 2006 -- now Text.ParserCombinators is preferred?
12:21:10 <donri> Text.Parsec
12:21:19 <geekosaur> mm? Text.ParserCombinators.Parsec was the parsec 2 path
12:21:20 <rasfar> Surely if ghci doesn't already do it, I must be missing something.
12:21:32 <geekosaur> Text.Parsec is parsec 3, which these days should generally be a drop-0in replacement otherwise
12:21:54 <rasfar> Why isn't Parsec in base then?
12:22:03 <geekosaur> um
12:22:19 <geekosaur> it's in the haskell platform, which may be what you are thinking of as base
12:22:32 <geekosaur> base itself is supposed to be minimal, and is gradually getting slimmed down
12:22:47 <monochrom> yes Hodapp. it is an abstraction (or pretends to be) because I will just tell you "the type is L a". it is leaky because the only way you use "L" is by knowing its definition. the leak is intentional because I set up "L" by a type synonym.
12:22:54 <rasfar> yeah, that's what I mean, but it ... I don't see it in ... oh.
12:23:09 <rasfar> I had a corrupt haddock index for a few days and didn't realise... it is there.
12:23:59 <rasfar> alrighty then, it'll be a good exercise :)
12:24:07 <geekosaur> ...ohai!
12:24:09 <geekosaur> @bot
12:24:26 <geekosaur> ...nope, back but stuck
12:24:51 <malvarez> rasfar: if you get it done, I'd love to see it integrated into lambdabot
12:25:14 <schell> is the mac os x ghc situation better than it was a bit ago?
12:25:23 <rasfar> malvarez: I'm just worried about getting in too deep, trying to support the whole language...
12:25:41 <monochrom> I want to support the whole language
12:25:50 <geekosaur> there is now a script that will adapt to xcode 4 or xcode 5 as needed
12:25:51 <rasfar> And then there's the popular and indispensible extensions like BangPatterns and whatnot
12:25:56 <monochrom> I don't mean when you write it. I mean when I write it.
12:25:56 <malvarez> rasfar: I think even if it's really limited it would be a great tool to have in lambdabot
12:26:04 <rasfar> fair enough
12:26:05 <lambdabot> :)
12:26:12 <Saizan> rasfar: there's stepeval
12:26:15 <malvarez> The newcomers would be really grateful for it. I would be really grateful!
12:26:20 <schell> geekosaur: is that the brew tap?
12:26:27 <malvarez> Not the paying money kind of grateful though
12:26:29 <rasfar> I'd not heard of stepeval, thanks Saizan I'll look
12:26:40 <geekosaur> dunno if it's in homebrew yet, I don't use that
12:26:58 <rasfar> (I want to visualise the execution.)
12:26:59 <djahandarie> edwardk_, we should grab food or something ddarius at some point.
12:27:05 <geekosaur> http://www.haskell.org/pipermail/haskell-cafe/2013-October/111174.html
12:27:10 <djahandarie> I've been meaning to get in touch with him ever since I moved here but haven't.
12:27:22 <monochrom> rasfar: have you read my http://www.vex.net/~trebla/haskell/lazy.xhtml ?
12:27:26 <schell> geekosaur: cool, thanks
12:28:17 <cariveri> monoidal: I came up with an example: type CarWreck = Wreck c where c must be of type Car. how to realise something like this?
12:28:29 <monoidal> cariveri: you mean, class Car?
12:28:41 <malvarez> cariveri: 'data CarWreck = Wreck Car'
12:28:43 <rasfar> monochom: nope, not yet. page is now open for when I get home though, tx
12:28:47 <dmwit> Saizan: Where is stepeval?
12:28:55 <malvarez> If I understand you correctly
12:29:20 <dmwit> malvarez: s/data/type/, probably
12:29:22 <cariveri> monoidal: malvarez I think thats wrong. Wreck in your phrase is a constructor not a type from somewhere else.
12:29:31 <cariveri> monoidal: yes liek a class I think.
12:29:45 <monoidal> cariveri: is CarWreck supposed to take a type?
12:29:52 <rasfar> https://github.com/benmachine/stepeval I expect
12:30:07 <cariveri> monoidal: I m not sure, could also be a data, if thats what your asking for.
12:30:07 <malvarez> Oh, okay, if Wreck is a type then that's different. Is Car a datatype or a typeclass?
12:30:21 <monochrom> stepeval is at https://github.com/benmachine/stepeval  I think the running instance is gone
12:30:27 <monoidal> cariveri: do you want "type CarWreck = ..." or "type CarWreck c = ..."?
12:30:41 <monoidal> cariveri: in both cases, I am afraid the answer will be negative.
12:31:48 <dmwit> If it fits in a tweet, you haven't included enough information to debug it yet.
12:32:17 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #4 :)
12:32:19 <carlosgaldino> how could one try to sum two values inside a Maybe monad?
12:32:35 <monoidal> carlosgaldino: liftM2 (++) if Nothing + Just _ should be Nothing
12:32:39 <monoidal> liftM2 (+)
12:33:29 <monochrom> @remember dmwit If it fits in a tweet, you haven't included enough information to debug it yet.
12:33:29 <lambdabot> I will never forget.
12:33:30 <dmwit> monochrom: Oh, yours is even shorter than mine. Forget the "if", it's just "You haven't included enough information to debug it yet.".
12:33:54 <monochrom> but I like the reference to tweet i.e. 140 bytes :)
12:34:00 <dmwit> =)
12:35:01 <dmwit> I like "the solution depends on the problem" a lot.
12:35:22 <rasfar> stepeval won't cabal configure with GHC 7.6.3 (upper constraint on base) but ... it's building with 7.0.4
12:37:22 <cariveri> monoidal:How would I design CarWreck in: data Car = Car String; let racer = Car "racer"; let wreck1 = Wreck racer; data Wreck a = Wreck a; type CarWreck = Wreck Car ? Is tha tpossible?
12:37:24 <mlen> who hosts lambdabot?
12:37:24 <monochrom> yeah hehe. it is a gem because most programmers don't understand it
12:37:25 <carlosgaldino> monoidal: thanks. and how can I use this in ghci? how can I import it?
12:37:42 <rasfar> it's going pretty slow as I'm also building lambdabot and it's a puny netbook with the usual 500 browser tabs open
12:38:14 <dmwit> cariveri: Define "design".
12:38:43 <dmwit> The answer to the question "Is that possible?" is trivially answerable by typing your code into a file and asking GHC.
12:40:38 <rasfar> oops: Test: testsuite: changeWorkingDirectory: does not exist
12:41:04 <rasfar> But at least it (stepeval) builds fine.
12:44:30 <monoidal> cariveri: what you wrote is legal haskell
12:44:38 <monoidal> carlosgaldino: liftM2 is in Control.Monad
12:44:49 <monoidal> > liftM2 (+) (Just 5) (Just 3)
12:44:51 <lambdabot>   Just 8
12:45:22 <carlosgaldino> monoidal:  thanks
12:49:34 <rasfar> kadath:andru> stepeval
12:49:45 <rasfar> Enter a string to parse, terminated by a blank line:
12:49:46 <rasfar> (\x->x+1)1
12:49:46 <rasfar> (\ x -> x + 1) 1
12:49:46 <rasfar> 1 + 1
12:49:46 <rasfar> 2
12:49:54 <cariveri> monoidal: thank you. I think I know what I need to do now.
12:50:07 <rasfar> yay! thanks Saizan!
12:50:36 <monoidal> cariveri: a synonym CarWreck = Wreck Car is imo not very idiomatic; it doesn't save space, and makes the structure less apparent
12:51:17 <monoidal> I would just write Wreck Car each time.
12:52:14 <darthdeus> guys, let's say i have the following types ... type Match = (User, User); type Round = [Match]; type Bracket = [Round] ... how should i persist this as a single data blob that can be atomically saved? i have a feeling that doing this in a relational database wouldn't make much sense, and i just wanna store it as a single blob
12:52:27 <joelteon> acid-state
12:53:17 <darthdeus> joelteon: but that's ORM no?
12:53:18 <vonDraco> any ideas on why this will not work? http://lpaste.net/4425407505773887488
12:53:26 <joelteon> what's ORM
12:53:32 <darthdeus> oh right
12:53:46 <darthdeus> orm doesn't make much sense in haskell i guess :X
12:54:23 <dmwit> vonDraco: You claim to return a [String], but your otherwise clause doesn't.
12:54:24 <geekosaur> vonDraco, you're just returning x (a String) for the otherwise case, when the return type is [String]
12:54:42 <geekosaur> also, you should use pattern matching instead of head
12:54:48 <vonDraco> OH, so even that has to be a [string]?
12:54:51 <vonDraco> i never thought of that
12:54:56 <dmwit> I suspect that if you read the error message closely, it will say essentially the same thing geekosaur and I just did.
12:55:22 <vonDraco>    Expected type: String
12:55:22 <vonDraco>       Actual type: [String]
12:55:25 <vonDraco> yeah, i see now
12:56:02 <rasfar> um, how much disk roughly will I need to build lambdabot?
12:56:28 <geekosaur> there's more wrong with ut actually
12:56:44 <dmwit> rasfar: 80M or so
12:56:45 <geekosaur> since you are invoking tokeniser, declared to return [String], and wrapping another list around it
12:56:56 <rasfar> okay, no prob :)
12:57:00 <geekosaur> like you started with it returning String and changed it midway without adjusting the code to match
12:57:12 <lpaste> geekosaur annotated “No title” with “No title (perhaps this)” at http://lpaste.net/4425407505773887488#a95034
12:58:28 <rasfar> I suppose you can drop the base case too
12:58:49 <geekosaur> likely, yes
12:58:59 <monoidal> in this code you can, but I would expect that after adding new cases [] will need special handling.
12:59:19 <vonDraco> oh, so that's pattern matching. what i was using were guards?
12:59:25 <geekosaur> yes
12:59:27 <rasfar> do folks prefer matching [] explicitly, or picking up the crumbs with _ ?
12:59:29 <monoidal> vonDraco: yes
12:59:48 <geekosaur> rasfar, matching [] expliciy can protect you from bugs if you change things later, I guess
12:59:49 <t4nk992> hello
13:00:07 <rasfar> hi t4nk992
13:00:12 <vonDraco> jesus, that's way easier
13:00:18 <geekosaur> consider that later on more cases will be added and the otherwise eventually report a parse error
13:00:44 <rasfar> yeah
13:00:46 <vonDraco> hmm. i'll get to that when i get to it
13:00:55 <t4nk992> i have an integer. Can you advise best (fastest/shortest) way to check if it contains only unique digits?
13:01:05 <t4nk992> so 102 is, and 112 is not
13:01:29 <t4nk992> decimal numbers
13:01:36 <monochrom> vonDraco: please see my http://www.vex.net/~trebla/haskell/crossroad.xhtml . even "tokeniser (h:t) | h=='+' = ..." is better than using head.
13:02:01 <simpson> t4nk992: def f(i): s = str(i); return len(set(s)) == len(s)
13:02:02 <dmwit> t4nk992: nub (show x) == show x
13:02:08 <simpson> Oh, waaaait, this isn't #python. Sorry.
13:02:14 <geekosaur> heheh
13:02:19 <simpson> dmwit: Nice and elegant.
13:02:29 <t4nk992> :i nub
13:02:34 <dmwit> :t nub
13:02:35 <lambdabot> Eq a => [a] -> [a]
13:03:00 <t4nk992> wait, i need to read what what nub do =)
13:03:06 <t4nk992> *what that
13:03:11 <dmwit> nub deletes duplicate elements.
13:03:15 <t4nk992> heh
13:03:17 <t4nk992> cool
13:03:19 <rasfar> > nub [3,5,2,3,6,5,5]
13:03:19 <monochrom> f i = let s = show i in Set.size (Set.fromList s) = length s
13:03:20 <lambdabot>   [3,5,2,6]
13:03:42 <monochrom> err, typo
13:03:45 <monochrom> f i = let s = show i in Set.size (Set.fromList s) == length s
13:03:54 <dmwit> Believe it or not, I think nub is superior to using Set in this case.
13:04:00 <simpson> t4nk992: How large are these numbers?
13:04:12 <simpson> You'd have to get really big before nub gets spendier than Set, wouldn't you?
13:04:14 <t4nk992> set requires too much memory to generate
13:04:18 <monochrom> yes, I'm just translating the python code :)
13:04:25 <t4nk992> simpson 0:987654321 ;D
13:04:59 <simpson> Yeah, Python's weird in that sets are so much faster than written-out algorithms.
13:05:01 <monoidal> you can write (x <= 99999999999)  &&  <nub> to get O(1) always
13:05:19 <monoidal> assuming positive numbers
13:05:25 <dmwit> You are making the crazy assumption that comparisons are O(1).
13:05:41 <monoidal> they're on the RAM model.
13:05:49 <texasmynsted> Is there a generally accepted way to show a cons in pseudo-code for comments?  I like the diagrams with the boxes split into car and cdr with the car containing a dot pointing down to its payload and the cdr pointing to the next element, but these diagrams would be too awkward to attempt in one line of comments.
13:06:06 <Cale> :
13:06:17 <Dodek> it would be crazy tedious to analyze complexity if you couldn't assume elementary operations aren't O(1)
13:06:36 <monoidal> well, we're not on the ram model, so this is indeed rough
13:06:45 <monoidal> but it's O(log n) vs O(log^2 n)
13:07:08 <dmwit> If you assume elementary operations are O(1), then the nub solution is already O(1) just by swapping out "show" for something that produces the digits in the other order.
13:07:19 <vonDraco> monochrom, thanks for the link. my professor loves using guards, so i never really knew much about pattern matching. :(
13:07:43 <monochrom> it seems your professor should read it too
13:08:12 <monochrom> but I am not against guards. I'm just against head tail isJust fromJust
13:08:25 <vonDraco> haha, i see
13:08:26 <monoidal> dmwit: can you explain?
13:08:29 <monochrom> and I am not even against them 100% of the time
13:09:00 <Cale> If you use isJust, then you shouldn't use fromJust, and vice-versa
13:09:05 <monoidal> dmwit: oh I probably see
13:09:16 <dmwit> monoidal: div and mod are O(1); so we can produce the last ten digits of the number in O(1) time; and we can check they're unique in O(1) time with nub because there's at most ten of them, so at most say 100 equalities.
13:09:29 <Cale> (because if you're using both, you should be pattern matching)
13:09:51 <monoidal> dmwit: does nub definitely makes at most 100 equalities?
13:09:53 <vonDraco> that second example for pattern matching was really enlightening.  never knew you could refer to the parameters differently, (e.g. f [] and f (x:xs) )
13:10:06 <dmwit> monoidal: It definitely makes at most 10 choose 2 equalities. =)
13:10:32 <dmwit> n choose 2 < n^2, so...
13:10:42 <monoidal> hm, it makes a linear number of comparisions?
13:10:47 <dmwit> no, quadratic
13:10:57 <dmwit> quadratic in the number of elements in the list
13:10:57 <monoidal> in case of list with elements from [0..9]?
13:11:05 <dmwit> but there's exactly 10 elements in the list, so constant =)
13:11:34 <monoidal> oh. but you are adjusting the solution to have "take 10" somewhere
13:11:38 <dmwit> no =)
13:11:44 <dmwit> Laziness takes care of that for me.
13:12:14 <monoidal> dmwit: then I don't see it. nub on replicate 10000 1 does more than 100 equalities, no?
13:12:18 <dmwit> Oh, you're worried we'll get something like 9876543210lotsofdigits, eh?
13:12:26 <Eduard_Munteanu> Is there a way to list all installed modules, from any packages?
13:12:30 <dmwit> Okay, then you indeed need to stick a take in.
13:12:50 <t4nk992> btw, getting length of list in Haskell is O(1), isn't it?
13:12:54 <dmwit> Which, I agree, amounts to doing the comparison you suggested.
13:12:58 <dmwit> So you've convinced me.
13:13:02 <dmwit> t4nk992: No, it is not.
13:13:02 <Eduard_Munteanu> t4nk992: no, O(n)
13:13:26 <dmwit> t4nk992: However, it's easy to create a list-like data structure for which it is O(1).
13:13:32 <monochrom> Eduard_Munteanu: try "ghc-pkg field base exposed-modules"
13:13:58 <monochrom> there is also "hidden-modules" if you also want it
13:14:25 <t4nk992> dmwit: well, i will change the algo a bit)
13:14:42 <t4nk992> but, just curious, why it is not?
13:14:45 <Eduard_Munteanu> monochrom: hm, that works... I guess I should iterate something like that over all packages.
13:14:51 <Eduard_Munteanu> Thanks.
13:14:56 <Cale> t4nk992: Because lists are lazy linked lists
13:15:28 <t4nk992> Cale: but if i count length of the list once, will it be cached?
13:15:30 <Cale> t4nk992: Even knowing whether length applied to some list will terminate or not is undecidable
13:15:44 <Cale> Not unless you bind that to a variable and reuse the variable.
13:15:55 <Eduard_Munteanu> t4nk992: it can be shared, yes, but that doesn't mean it costs nothing
13:16:00 <Cale> If you write something like  let n = length xs in n + n
13:16:07 <Cale> then length xs will be computed once
13:16:30 <Cale> If you write  length xs + length xs  then it will be computed twice
13:16:41 <t4nk992> thanks)
13:16:51 <dmwit> To clarify: these comments are about GHC.
13:16:51 <Eduard_Munteanu> Cale: doesn't it do CSE for such simple cases at all?
13:17:01 <Cale> Eduard_Munteanu: CSE isn't always good
13:17:05 <dmwit> Haskell doesn't say much at all about when/how often something gets evaluated.
13:17:19 <Eduard_Munteanu> Cale: yeah, I know the thing about sharing
13:17:21 <LeoTal> Hi Cale! Google seems to suggest you're a good person to ask to make lambdabot @join a channel
13:17:21 <ski> CSE may induce space leaks (in the "retain things too long" sense)
13:17:25 <Cale> The only CSE which GHC does, as far as I know, is when you have nested case expressions which match on the same scrutinee
13:17:42 <Cale> (which isn't likely to be something in code that you write, but it does come up after inlining)
13:17:47 <monochrom> read GHC core to see whether CSE happens. do not think. read.
13:18:00 <Cale> LeoTal: That would be old information. I no longer manage lambdabot.
13:18:08 <monochrom> people think too much and verify too little
13:18:11 <LeoTal> Okay, thanks anyway
13:18:19 * ski feels tempted to @remember "do not think" :)
13:18:42 <rasfar> Do people use Hat much? It's broken by the newer HSE, but I think I have a patch.
13:18:49 <Eduard_Munteanu> I'm unsure CSE is the right term here though, I just mean automatically sharing exactly-repeated subexpressions.
13:18:55 <dmwit> Also good advice for quantum physics.
13:19:01 <Cale> Eduard_Munteanu: That's the correct term for it
13:19:20 <Cale> Eduard_Munteanu: The trouble is that it can result in horrible space leaks
13:19:48 <bergmark> rasfar: haven't used hat, but upgrading to hse 1.14 should be pretty straight forward
13:20:18 <rasfar> it's mostly a matter of sprinkling "Boxed" in a bunch of places
13:20:19 <Cale> Consider something like  subsequences [] = [[]]; subsequences (x:xs) = subsequences xs ++ map (x:) (subsequences xs)
13:20:31 <Cale> If you turn that into:
13:20:49 <Eduard_Munteanu> Cale: if that results in horrible leaks, then I guess explicit sharing does too, except it can be "fixed", no? I mean, adding a "where"-bound expression for stylistic reasons.
13:21:00 <Cale> subsequences [] = [[]]; subsequences (x:xs) = ss ++ map (x:) ss where ss = subsequences xs
13:21:44 <Eduard_Munteanu> Unless where/let does not guarantee sharing.
13:22:09 <Cale> Right (though at the moment, it does)
13:22:17 <Cale> In lazy evaluation, it does, anyway.
13:22:56 <Eduard_Munteanu> Strictness analysis is supposed to add some brains to it, no?
13:22:57 <aleksejs_> i have 2 functions, first = f1 . f2 . zipWith (+) [0..] and the second is basically the same, but instead of + there is a -. Is it possible to write only one function and apply + or - as a parameter?
13:23:16 <Cale> I don't think that's what strictness analysis is looking for.
13:23:22 <dmwit> yep, just write first f = f1 . f2 . zipWith f [0..]
13:24:16 <Eduard_Munteanu> Cale: yeah, strictness is a subset of possible good cases for CSE, I presume.
13:24:18 <aleksejs_> dmwit, thanks
13:24:22 <Cale> Strictness analysis is just trying to determine when you'll *always* match on something, so that there's no point in constructing a thunk to represent the expression in the meantime.
13:24:33 <ski> aleksejs_ : functions are values to, you can parameterize and abstract away functions, as well as other values, making two almost-equal snippets of code equal
13:25:36 <Eduard_Munteanu> Cale: yeah, somehow I thought that lets the compiler do constant folding and other reductions, and eventually see certain things can be shared without leaks, but I might be wrong.
13:26:44 <Eduard_Munteanu> Cale: IIRC there are some connections between strictness analysis and mutation, which would also be related to this. Namely, if you have terms you know you don't need further, you can just do in-place updating.
13:26:45 <aleksejs_> ski, I know, I'm just not so familiar with func compositions in haskell
13:27:50 <Cale> Eduard_Munteanu: I suspect it's hard in some fundamental way for the compiler to always make good decisions on its own of this sort.
13:28:07 <rasfar> For whatever reason lambdabot depends on monad-control-0.3.2.1 but fails to install it (platform 2013.2.0.0)
13:28:34 <rasfar> but installing the monad-control by hand, and the rest of the build is flawless
13:28:57 <rasfar> that took basically one whole battery... hey, I thought Vixen was withdrawn! :)
13:29:36 <Eduard_Munteanu> Cale: yeah, but it's rather commonplace in strict languages. So if the compiler can reduce parts of the program to an equivalent strict-language case, it should be able to do a lot of the stuff they do in other languages.
13:30:11 <dmwit> The code wasn't deleted. The plugin just isn't loaded any more.
13:30:20 <rasfar> w00t! lambdabot> vixen
13:30:21 <rasfar> you know what? if we'd known it was going to be like this we'd have picked our own goddamn cotton!
13:30:22 <Eduard_Munteanu> I'd personally like to see GHC using *some* mutation when possible.
13:30:45 <Cale> Well, lazy evaluation is secretly mutation of course, but apart from that :)
13:30:52 <madariaga> I'm working with lists nested two levels, and I'm repeating myself a lot on these steps: picking elements randomly, applying functions, and replacing those original elements to return "updated lists"
13:31:09 <madariaga> I suspect there might be a common pattern to do this
13:31:11 <Eduard_Munteanu> Because even with fast GC, it still slows down things and pollutes the cache, i.e. the garbage stinks even if you collect it regularly. :P
13:31:29 <johnw> madariaga: lens might be exactly what you want
13:31:58 <Cale> madariaga: lists are a really terrible data structure for that sort of operation (I hope your lists are at least short)
13:32:11 <johnw> > [[1,2],[3,4]] & element 1.element 1 +~ 10
13:32:12 <lambdabot>   [[1,2],[3,14]]
13:32:25 <madariaga> Cale: they are, but they may not be
13:32:37 <Cale> But yeah, lenses make that kind of thing easier to write
13:32:53 <madariaga> ok, I'll dig into the lens library.
13:33:02 <Eduard_Munteanu> madariaga: which elements do you replace? All of them? Those matching a predicate? Or do you apply a stateful transformation to decide?
13:33:08 <madariaga> Cale: could you please point me to a better data structure?
13:33:18 <madariaga> Eduard_Munteanu: the two I randomly picked
13:33:29 <Cale> > over (element 1 . element 1) (+1) [[1,2],[3,4]] -- this is how I'd write it, I think it's more readable like this :P
13:33:31 <lambdabot>   [[1,2],[3,5]]
13:33:39 <Cale> madariaga: Data.Sequence
13:33:55 <Cale> madariaga: Data.Sequence at least has log time splitting and concatenation.
13:34:06 <madariaga> ok
13:34:13 <johnw> Cale: but when you chain multiple overs, doesn't that get unwieldy?  with & + operator, applying several in succession reads quite nicely
13:34:39 <Cale> johnw: I'm not sure I understand
13:34:44 <Eduard_Munteanu> madariaga: how do you want to index into the structure, do you know the element or some property that uniquely identifies it before looking it up?
13:34:48 <Cale> johnw: Isn't it like composing functions normally?
13:34:49 <rasfar> I actually wrote my first code using Data.Vector today / hey, updated hoogle comes with lambdabot, excellent (handy when offline) / ah the Sequence/Vector debate ...
13:34:55 <johnw> > [[1,2],[3,4]] & element 1.element 1 +~ 10 & element 1.element 1 +~ 10 & element 1.element 1 +~ 10
13:34:58 <lambdabot>   [[1,2],[3,34]]
13:35:03 <cariveri> monoidal: please have look at this: http://pastebin.com/6im4Huc2 it shows the problem I have.
13:35:12 <mauke> The paste 6im4Huc2 has been copied to http://lpaste.net/95035
13:35:34 <Eduard_Munteanu> madariaga: for example, if you generate two random numbers and use them to identify your elements, you can use a Map or even an IntMap.
13:35:41 <madariaga> Eduard_Munteanu: No, not necessarily, I just have to pick some of them, feed them to some functions that will eventually return those "updated" values, and replace the originals
13:35:47 <Cale> > over (element 1 . element 1) (+10) . over (element 1 . element 1) (+10) . over (element 1 . element 1) (+10) $ [[1,2],[3,4]]
13:35:50 <lambdabot>   [[1,2],[3,34]]
13:35:55 <johnw> ah, I see what you mean
13:36:03 <monoidal> cariveri: Car is not a type. it's a value. What do you expect that a value of type CarWreck would contain?
13:36:20 <johnw> I use over sometimes, but not often
13:36:29 <cariveri> monoidal: Id like to keep the information that Car is also a Vehicle on a more abstract level. see what I want?
13:36:36 <Cale> I don't like all the wacky operators
13:36:42 <johnw> and I hear edwardk is considering changing %~ to %=
13:36:52 <johnw> the operators actually make a lot of sense after a while
13:36:58 <johnw> they are highly morphological
13:37:06 <Cale> I'd much prefer to just use prefix notation functions
13:37:11 <jrmithdobbs> ya I don't understand that, did you mean type CarWreck = Wreck Vehicle ... ?
13:37:18 <Cale> For almost all of the things
13:37:30 <johnw> Cale: well, the great thing about aesthetics is that it always gives us something to talk about :)
13:37:32 <monoidal> cariveri: maybe you want data Car = Car <fields>; data Vehicle = CarVehicle Car | Truck; type CarWreck = Wreck Car
13:37:33 <Cale> I don't see why we need a special operator for addition :P
13:37:43 <Cale> (apart from the one which already exists)
13:37:48 <cariveri> jrmithdobbs: you then would have constructed a VehicleWreck not a CarWreck
13:37:48 <madariaga> So far I've been using a really cumbersome way, picking an element, returning its index and then rebuilding the list afterwards, but now I have to previously filter the original list by some predicate, and then select from those.
13:37:52 <johnw> Cale: how do you add 1 to a State Int?
13:37:58 <johnw> I do: id += 1
13:38:04 <madariaga> Having to filter it makes it imposible to rebuild it
13:38:17 <dmwit> cariveri: I worry about your phrasing, "Car is also a Vehicle". Car is a Vehicle. What else is it that warrants an "also"?
13:38:57 <Eduard_Munteanu> madariaga: you can just delete stuff from a Map by key...
13:39:01 <Eduard_Munteanu> :t Data.Map.delete
13:39:02 <lambdabot> Ord k => k -> M.Map k a -> M.Map k a
13:40:33 <aleksejs_> I love haskell: here's my Nqueens implementation http://vpaste.net/Z0X3x
13:40:44 <Cale> johnw: Well, I don't use lens with state monads enough to know whether there's a prefix name for %= but I would expect %= to be enough
13:40:56 <Cale> johnw: i.e. why not id %= (+1) ?
13:41:11 <cariveri> dmwit: I added "also" to leave a possibility of being even more that this. but thats not of great importantce right now.
13:41:17 <johnw> += is just simpler
13:41:18 <edwardk_> modify (over l f) -- obviously =)
13:41:29 <johnw> and it is %=
13:41:29 <Cale> Well, yeah
13:41:31 <Dodek> aleksejs_: is it fast enough to obtain any result?
13:41:39 <Cale> modify (over l f) is fine
13:41:48 <johnw> to each his own I guess
13:41:55 <jrmithdobbs> cariveri: but your Car isn't a type constructor so it wont work like you think
13:42:05 <aleksejs_> Dodek, it shows all 92 results immediately on my i3
13:42:06 <Cale> I don't think it's simpler once you have dozens of variations for each arithmetic operator
13:42:17 <Dodek> aleksejs_: for what size, 8?
13:42:28 <johnw> I find it simpler, once you get familiar with the morphology of lens operators
13:42:28 <Cale> When all you need is one thing for each variation that works with an arbitrary function
13:42:31 <madariaga> alright, thanks, I'll take a look and come back again later
13:42:34 <johnw> I see <>~ and it means exactly one thing to me
13:42:36 <aleksejs_> yes, but you can change one number
13:42:41 <Cale> That's what functional languages are for
13:42:41 <Dodek> aleksejs_: cool
13:42:51 <aleksejs_> [0..7] << change 7 to anything
13:43:00 <Dodek> aleksejs_: i was afraid, since you don't seem to do backtracking
13:43:06 <Dodek> but on the other hand 8! is small
13:43:08 <Cale> So that we don't need to define 80 different specialised versions of things, we can just have a parameter
13:43:10 <johnw> and the other thing functional languages are for is for defining functions, so I'm not sure why that's a bad thing
13:43:12 <jrmithdobbs> cariveri: i think what you want (you don't but you think you do) is typeclass Vehicle ... etc etc ... data Car = Car ... instance Vehicle Car = ....
13:43:25 <aleksejs_> and eights also
13:43:32 <monoidal> aleksejs_: you need to change 8 to n too (it's better to have a defined constant than a magic number)
13:43:53 <jrmithdobbs> cariveri: but it probably isn't really what you want to do, i think you're trying to treat the type system like a poor object system, and it's not
13:43:57 <aleksejs_> I guess, i need to make just another function that takes size parameter
13:44:07 <dmwit> aleksejs_: Bah, ignore these people. I think you wrote some neat code and don't need a lot of criticism. =)
13:44:53 <edwardk_> dcoutts: i'm getting a "400 Bad Request" when I attempt to upload a new version 0.4 of intervals, but there isn't one already there, and I'm the maintainer, ideas?
13:44:59 <aleksejs_> dmwit, but I agree about those eights
13:45:11 <dmwit> Yup. There's lots of cool directions to take this code.
13:45:46 <aleksejs_> next step for this code is to leave only those results that are unique
13:46:10 <aleksejs_> I mean, to filter out all mirrored or rotated results
13:46:13 <mzero> looking for anyone who has upgraded to Mac OS X 10.9 (Mavericks), but is still on Xcode 4
13:46:15 <mzero> anyone?
13:46:22 <aleksejs_> there should be 12
13:46:23 <edwardk_> aleksejs_: if you keep going you can go down the road of an overton-style finite domain solver
13:46:24 <johnw> mzero: I'm avoiding that upgrade at the moment
13:46:43 <mzero> johnw - I have it working on my system
13:46:55 <johnw> mzero: it won't get my ZEVO ZFS to work, though :(
13:47:04 <simpson> This is largely out of curiosity rather than burning need; is there a monad that is like List but which uses a Eq or Ord constraint to make its contents unique? Or, rather, what's the best technique for doing so?
13:47:08 <edwardk_> aleksejs_: http://overtond.blogspot.com/2008/07/pre.html
13:47:18 <edwardk_> aleksejs_: its also been explored quite a bit since then
13:47:20 <mzero> but I'm trying to develop the script that works for most cases so we can publish it on the HP site
13:47:29 <jrmithdobbs> simpson: Data.Map
13:47:30 <johnw> simpson: you want the restricted monad for Set
13:47:35 <Cale> simpson: Set is morally a monad
13:47:37 <jrmithdobbs> or set too
13:47:42 <edwardk_> aleksejs_: but if you're getting curious about these kinds of techniques in haskell thats a good starting point for a high performance desgn
13:47:48 <simpson> johnw, Cale : Yeah, but IIUC I can't use do-syntax with it, right?
13:47:53 <mzero> simpson: Data.Set
13:48:06 <johnw> can't modern GHC rebind do syntax?
13:48:29 <Cale> simpson: Right, not without trickery of some sort, because the polymorphic type of (>>=) doesn't involve Ord constraints
13:48:37 <simpson> Also, what's performance like? It's similar to persistent red-black trees, right? Logarithmic time on every bind?
13:48:44 <Cale> (which would be needed to define (>>=) for Set)
13:48:44 <Peaker> fmap (f . g) == fmap f . fmap g    is wrong for Set, right? And if so, it can't be a Functor, and thus, morally isn't a Monad either? I'm missing something here
13:48:47 <monoidal> johnw: even nonmodern can.
13:49:30 <johnw> Peaker: good point
13:49:45 <johnw> just fmap (const ()) shows that Set isn't a Functor
13:50:01 <monoidal> hm. what's wrong with it?
13:50:10 <johnw> I thought fmap had to be homomorphic
13:50:15 <johnw> mutate the contents, not the structure
13:50:18 <sclv_> no
13:50:33 <Peaker> surely some Category Theorist has an answer for me?
13:50:39 <Cale> simpson: Well, x >>= f would take each of the elements of the set x, apply f to them to obtain a bunch of sets, and then union all those sets together, which means that you have O(size x) applications of f, and then a linear time union
13:50:43 <johnw> sclv_: ah
13:50:55 <monoidal> I don't see why fmap (f.g) = fmap f . fmap g is violated, as long as == is normal set equality
13:50:57 <Cale> (linear in the sum of the number of elements in all the sets)
13:50:57 <aleksejs_> here's an improvement http://vpaste.net/tPDvy
13:50:59 <dmwit> Peaker: Let's assume some rules on equality to recover fmap (f . g) == fmap f . fmap g.
13:51:09 <simpson> Cale: Sure. And fmap would be linear as well, not log-linear?
13:51:24 <dmwit> Peaker: Like, we're already saying Set is a functor on a subcategory of Hask that supports Ord, now let's just make it the subcategory that has sane Ord instances.
13:51:24 <sclv_> 'contents' and 'structure' are really not categorical notions in the way they're being used here.
13:51:40 <johnw> sclv_: fair enough, I think I inferred too much from past reading
13:52:26 <Cale> simpson: map on Set is O(n log n)
13:52:42 <aleksejs_> it's interesting: this code works faster than that permutations [0..n-1] part
13:52:51 <Cale> johnw: The reason you had that impression is that it's true when you don't have an Ord instance :)
13:53:05 <simpson> Cale: Ugh. But map on a Map would be O(n) since there's no rekeying, right?
13:53:10 <aleksejs_> probably, permutations are also lazy
13:53:26 <sclv_> hmm
13:53:32 <sclv_> however you have to 'touch' the whole structure
13:53:42 <Cale> simpson: sure, but your monad instance is totally different
13:53:49 <johnw> a Halloween build of GHC: https://www.dropbox.com/sh/l24540a7ndwte01/qG7qRlE8nv/dist/ghc-7.7.20131031-x86_64-unknown-linux.tar.bz2
13:53:51 <monoidal> simpson: note that Set is essentially Map to ()
13:53:55 <dmwit> aleksejs_: I suspect that printing, not permutations, is the bottleneck.
13:54:09 <Heffalump> how far off is a GHC 7.8 RC?
13:54:09 <dcoutts> edwardk_: cabal-install is apparently not reporting the error that the server is sending, have to fix that. In the meantime you can see what the server is really saying by using -v3.
13:54:10 <Cale> monoidal: Not... here?
13:54:13 <sclv_> so the size of your map structure itself includes logn nodes just as branch nodes
13:54:18 <simpson> Yeah.
13:54:20 <monoidal> Cale: why?
13:54:31 <sclv_> which means you probably get closer to n + logn for map
13:54:35 <sclv_> if you're being careful about it
13:54:36 <Cale> monoidal: Because the the order of the parameters to Map and how instances work
13:54:40 <simpson> Maybe it's just easier to use list as a monad and then explicitly nub as needed?
13:54:47 <monoidal> Cale: oh, I agree with this.
13:54:50 <Cale> monoidal: Map k will be a monad, but it's essentially (->) k
13:54:51 <dmwit> Surely n+log n is in O(n).
13:54:55 <aleksejs_> dmwit, maybe you're right
13:54:59 <edwardk_> dcoutts: thats it, thanks!
13:55:07 <edwardk_> dcoutts: this one is my fault =)
13:55:08 <sclv_> dmwit: of course!
13:55:20 <dmwit> And no reason your branches can't contain data...
13:55:39 <monoidal> Cale: ah, I see, thanks. so \x -> Map k x is a monad, and furthermore \x -> Map x () is a monad.
13:55:51 <monoidal> Cale: didn't realize it's so different.
13:55:55 <dcoutts> edwardk_: actually, can you paste the log somewhere, I'd like to look
13:56:17 <dcoutts> edwardk_: cabal-install already has code to print the error if the content-type is text/plain, so I'd like to see what's going wrong in this case
13:56:33 <Cale> Yeah, the instances will be very different in terms of how they work, and what fmap does.
13:56:41 <edwardk_> http://lpaste.net/5079407269767020544
13:56:44 <dcoutts> edwardk_: ta
13:56:59 <dcoutts> ah Content-Type: text/html; charset=utf-8
13:57:09 <Cale> If you're talking about fmap for \x -> Map x (), then it'll be O(n log n) again
13:57:12 <dcoutts> edwardk_: ok, server's fault, it's saying it's html when it's really text/plain
13:57:29 <edwardk_> well, at least that doesn't mean a new cabal version for everyone =)
13:57:34 <dcoutts> indeed
13:58:44 <Peaker> dmwit: ah, thanks.  so we're not allowed to observe things like Set.size ?
13:58:57 <Cale> simpson: anyway, it's best not to take log factors too seriously
13:58:57 <dmwit> eh?
13:59:04 <dmwit> Peaker: Maybe you better tell me your counterexample.
13:59:09 <monoidal> so Map is a covariant functor in both arguments, while (->) is contravariant.
13:59:10 <Cale> simpson: We're already ignoring at least one
13:59:18 <dmwit> Peaker: I'm probably thinking incorrectly and arguing against the wrong thing. =P
13:59:21 <Cale> (if not more...)
13:59:33 * hackagebot intervals 0.4 - Interval Arithmetic  http://hackage.haskell.org/package/intervals-0.4 (EdwardKmett)
13:59:53 <Cale> monoidal: Oh, well, not really.
13:59:59 <simpson> Cale: Yeah, this is true. I'm just curious as to what people use for building amb-style stuff, especially for things like traversal of lazily-generated graphs or in situations with lots of mzero.
14:00:15 <Peaker> dmwit: hmm.. let me see if my counterexamples make sense, just a sec :)
14:00:27 <Cale> monoidal: Map - () is a covariant functor, but we've specialised things :)
14:00:48 <monoidal> Cale: don't we have (k -> k') -> (v -> v') -> Map k v -> Map k' v'?
14:01:13 <monoidal> Cale: or am I missing something?
14:02:04 <Cale> monoidal: hmmmm
14:02:18 <monoidal> ah. it's problematic when k -> k' glues keys.
14:02:34 <Cale> monoidal: (We obviously have such a function, but I'm not sure it satisfies the laws)
14:02:48 <Peaker> dmwit: hmm..  I was confused, accepted that  fmap f . fmap g /= fmap (f . g) for sets but now I can't remember which example convinced me and can't think of one that works (with a sane Ord)
14:03:15 <Cale> monoidal: It might actually be okay
14:05:44 <dmwit> Peaker: I suspect the example you were thinking of allowed your Ord instance to mark as EQ two things which were observably different.
14:05:55 <Peaker> dmwit: so if (==) implies they are observationally the same (can't extract a difference with any pure function) then the law isn't broken and all is well
14:06:02 <dmwit> right, that's the idea
14:08:06 <Peaker> dmwit: that has a weird consequence. The mere existence of some unsafe functions (e.g: Data.Map.unsafeMapDepth) or at least their use in such contexts breaks the laws.   It seems it'd be nice to be able to differentiate functions that can observe behind (==) from those that don't (terminology-wise) so we can describe the laws more accurately?
14:08:42 <dmwit> Well, it's got "unsafe" in its name. What more do you want? =)
14:08:58 <Peaker> When inside the Data.Map module, you want to know what is lawful to use in which context (in that context, "treeDepth" might not be "unsafe")
14:09:35 <dmwit> Well, that's the usual argument behind implementation hiding, right?
14:09:53 <dmwit> You can write functions that rely on some invariants; then you have to be careful when you use them, and hide them from the stupid user for that reason.
14:10:20 <dmwit> I mean, I'm not really sure what you're getting at, other than "please write some comments on your unsafe functions".
14:11:09 <startling> I guess the solution might be a newtype.
14:11:33 <Peaker> heh, I'm not yet sure myself :)  I am trying to classify what is legal/illegal to do in the Data.Map context.. We're not allowed to use "treeDepth" in fmap context. Is there a simple description of where we're allowed to use it vs. where we aren't?
14:11:55 <startling> WIth invariants preserved for the newtype, unsafe functions legal on the unwrapped type, and a special place to import the (unsafe) constructor from.
14:12:38 <monoidal> Peaker: treeDepth should be called unsafeTreeDepth or something like that. it is not a function respecting extensional equality.
14:13:03 <dmwit> Just for fun, can we cook up an example that shows why we can't use treeDepth in fmap context?
14:13:16 * ski thinks the Mercury approach, with explicit promise that operations that look at representation won't break equality on abstract type, is nice
14:14:24 <monoidal> functions are divided into "safe" and "unsafe". if you use an unsafe function, you're on your own, and it's your responsibility to preserve the contract between you and the library.
14:14:25 <ski> "User-defined equality and comparision" <http://www.mercurylang.org/information/doc-latest/mercury_ref/User_002ddefined-equality-and-comparison.html>
14:14:57 <joelteon> @let ☠ = error "BOO!"
14:14:58 <lambdabot>  Parse failed: Illegal character ''\152''
14:15:01 <joelteon> aw, man
14:15:21 <dmwit> > "☠"
14:15:22 <lambdabot>   "\9760"
14:15:29 <joelteon> :t (☠)
14:15:30 <lambdabot> lexical error at character '\152'
14:15:32 <dmwit> It's just not a legal variable name, it seems.
14:15:39 <joelteon> it is
14:15:47 <tdammers> isn't that an extension?
14:15:49 <dmwit> > genericCategory '☠'
14:15:51 <lambdabot>   Not in scope: `genericCategory'
14:15:51 <lambdabot>  Perhaps you meant `generalCategory' (impor...
14:15:56 <dmwit> > generalCategory '☠'
14:15:57 <lambdabot>   OtherSymbol
14:16:04 <joelteon> I executed it in ghci fine
14:16:14 <dmwit> > let 3 ☠ 4 = 5 in (☠)
14:16:16 <lambdabot>   <Integer -> Integer -> Integer>
14:16:18 <joelteon> must be my client
14:16:22 <dmwit> It has to be infix, it seems.
14:16:29 <ski> @let (☠) = error "BOO!"
14:16:29 <lambdabot>  Parse failed: Illegal character ''\152''
14:16:32 <joelteon> > let 3 ☠ 4 = 5 in (☠)
14:16:33 <lambdabot>   <Integer -> Integer -> Integer>
14:16:36 <joelteon> interesting.
14:16:43 <ski> > let (☠) = error "BOO!" in (☠)
14:16:44 <lambdabot>   *Exception: BOO!
14:16:49 <dmwit> Oh ho!
14:16:54 <dmwit> So @let is broken.
14:17:04 <joelteon> I knew it
14:17:52 <monoidal> @let ***** = 6
14:17:52 <lambdabot>  Parse failed: Parse error: *****
14:18:03 <monoidal> @let (*****) = 6
14:18:05 <lambdabot>  Defined.
14:18:16 <monoidal> it doesn't seem broken
14:18:20 <Peaker> dmwit: well, if Data.Map is a Red Black tree, you could have two equivalent trees with differing representation depths
14:18:45 <dmwit> Yup, with you so far.
14:19:19 <dmwit> I'm not saying we can't make a problem. I'm just saying I have such a hard time remembering how to do it that I want some help. =P
14:19:34 <Peaker> So  fmap treeDepth . fmap mkMap  could eliminate all Maps into one, and then have one depth.  vs.   fmap (treeDepth . mkMap)
14:19:52 <dmwit> perfect, thanks
14:21:11 <dmwit> Okay. Now I can read your question comfortably, and answer "I have no idea!" with confidence. =P
14:22:08 <dmwit> Certainly for fmap we can say what's okay and what's not (we've done so already).
14:22:20 <dmwit> But categorizing things in general seems... implausible.
14:26:47 <ski> Peaker : in Mercury, operations which (behaviorally) observe representation has to be marked as `cc_multi' (or perhaps `multi'), meaning the system knows you're getting one of possibly multiple possible representations of the datum
14:28:06 <ski> Peaker : i suppose the nearest in Haskell (without extending the static system) would be to invent a `CCMulti' monad, with `runCCMulti :: CCMulti a -> IO a' and `unsafeRunCCMulti :: CCMulti a -> a'
14:28:28 <ski> (or maybe `NonDet' would be a better name, not sure)
14:29:12 <Peaker> ski: but you do want to write pure operations inside Data.Map that can look at the representation without leaking it out
14:29:54 <ski> yes, so `unsafeRunCCMulti' or something similar could be used
14:31:25 <ski> in the Mercury page i linked to, `promise_equivalent_solutions' is used to promise that even since we observe the current representation out of many possible, the result of ordering comparision used here won't leak information about the actual representation that we observed
14:31:46 <ski> s/even since/even while/
14:32:35 <Eduard_Munteanu> Hm, I'm beginning to think scans are more fundamental / general combinators than folds.
14:33:04 <ski> Eduard_Munteanu : how would a scan look like, for a tree ?
14:33:24 <FreeFull> Each branch would get the value from the parent node
14:34:03 <Eduard_Munteanu> ski: the scan for a tree would be the same as the scan for its preorder traversal, for instance
14:34:14 <FreeFull> Eduard_Munteanu: You can't write head in terms of a scan
14:34:43 <ski> and for `data Tree d a = Leaf a | Branch (d (Tree d a))' ?
14:35:13 <FreeFull> I don't think preorder is feasible for all trees
14:35:14 <Eduard_Munteanu> ski: assuming 'd' is Foldable?
14:35:19 <FreeFull> Branching is though
14:35:41 <jrmithdobbs> so, dumb question, but I'm just looking for basic confirmation that these aren't dead projects ... warp and network-conduits are probably not a, generally speaking, "bad" way to go about http/socket servers in haskell in 2013 right? ;p
14:36:00 <Eduard_Munteanu> FreeFull: you should be able to write head, why not? You just need a way to cut the list, e.g. take
14:36:31 <jrmithdobbs> it's so hard to figure out which of the stuff on hackage is "modern"/"current" =/
14:37:08 <mzero> jrmithdobbs: look for the last time it was updated - if in the last 6 months - it is probably a live project
14:37:12 <ski> Eduard_Munteanu : perhaps
14:37:37 <mzero> but yes, warp and network-conduits are live projects, and a fine way to do a small http server in Haskell
14:37:39 <jrmithdobbs> mzero: ya they "apear" alive-ish on hackage and github but updates slowing ... seems more to do with maturity though
14:37:50 <mzero> the other options would be snap or happstack
14:37:53 <monochrom> you can also ask us for recommendations. "I want to parse command line options, which library do you recommend?"
14:37:54 <Eduard_Munteanu> > scanl (flip (:)) [] ([a,b,c] :: [Expr])
14:37:56 <lambdabot>   [[],[a],[b,a],[c,b,a]]
14:38:08 * monochrom recommends optparse-applicative for that :)
14:38:14 <FreeFull> > foldl1 const [1,2,3]
14:38:15 <lambdabot>   1
14:38:54 <FreeFull> In general, a fold can return anything while a scan can only return a datastructure of anything
14:38:58 <jrmithdobbs> well I guess I could phrase it that way then, *is* network-conduit a good way to do udp servers in haskell that need to go well beyond c10k ;p
14:39:04 <monochrom> there is a business opportunity in writing reviews for hackage libs
14:39:09 <Eduard_Munteanu> ski, FreeFull: the reason I said more general is because certain folds just don't exist for certain infinite structures, for example.
14:39:14 <mzero> jrmithdobbs: if you are looking for an example of a JSON like REST service, my project Plush has such an http server: https://github.com/mzero/plush/tree/master/src/Plush/Server
14:39:20 <Eduard_Munteanu> E.g. a stream.
14:39:32 <mzero> oh - UDP... hmmm... htat I don't know
14:39:45 <jrmithdobbs> mzero: that's useful too
14:39:47 <Eduard_Munteanu> The only reasonable equivalent to 'foldl' seems to be a 'scanl'.
14:40:09 <FreeFull> > foldl1 const [1..]
14:40:11 <Eduard_Munteanu> scanl is conveniently productive
14:40:17 <lambdabot>   mueval-core: Time limit exceeded
14:40:23 <FreeFull> You're right, you only get foldr for streams
14:40:25 <jrmithdobbs> mzero: ya i was trying to dig through warp to find it's actual event loop to figure out how they were doing the tcp handling so i could replicate something similar (network-conduit does have udp handling code) but decided to ask in here before digging further ;p
14:40:29 <FreeFull> > foldr1 (flip const) [1..]
14:40:37 <lambdabot>   mueval-core: Time limit exceeded
14:40:45 <FreeFull> Hmm
14:40:50 <jrmithdobbs> mzero: sounds like I am indeed on a "right enough" path though! thanks!
14:40:58 <ski> Eduard_Munteanu : fold is basically for inductive data
14:40:59 <Eduard_Munteanu> FreeFull: yeah, but you can get an arbitrarily-good approximation to foldl
14:41:08 <Eduard_Munteanu> (scanl)
14:41:12 <FreeFull> > foldr1 (const) [1..]
14:41:13 <lambdabot>   1
14:41:51 <Eduard_Munteanu> ski: yeah, though I used to think 'foldr' would be very suitable for codata
14:42:23 <FreeFull> In a sense, Stream only has one kind of fold, similar to a Tree
14:42:44 <FreeFull> I guess a finite tree can have multiple types
14:43:09 <ReinH> oh hai
14:43:27 <jrmithdobbs> mzero: where's the equivilant to main in that app?
14:43:32 <Eduard_Munteanu> FreeFull: shouldn't folding direction be dictated by your operation, rather than the data structure?
14:45:16 <FreeFull> A fold is replacing the data structure's constructors with functions/values, and direction depends only on associativity
14:45:18 <jophish_> grr, HLint! I don't want a string literal there±
14:45:22 <DouweM> I'm having some trouble installing Haskell libraries on my OS X Mavericks... Getting the error "error: '#' is not followed by a macro parameter" This seems to be http://ghc.haskell.org/trac/ghc/ticket/7678, but it doesn't seem to have a fix :/ Any advice?
14:45:26 <xico> is there a way to specify int64_t/int32_t/... for ffi? i could use cint/clong/... but hackage says they correspond to their c counterparts. which makes sense. and is not portable.
14:45:32 <mzero> jrmithdobbs: oh - that isn't easy!
14:45:43 <mzero> https://github.com/mzero/plush/blob/master/src/Plush/Main.hs
14:45:56 <Eduard_Munteanu> I wonder if annotating types with Agda's codata things yields any insight, e.g. foldr :: (a -> s -> ∞ s) -> Stream a -> ∞ s
14:46:01 <jophish_> DouweM: yeah, this is a problem I've not been able to find a nice solution to
14:46:08 <monochrom> jophish_: I just don't use hlint :)
14:46:10 <FreeFull> Some data structures only have one way associativity can really go
14:46:11 <jrmithdobbs> mzero: oh no wonder i felt retarded, didn't bother going up in the tree
14:46:13 <jrmithdobbs> mzero: lol
14:46:15 <jophish_> DouweM: If you compile the package yourself, you can fix most of these
14:46:26 <jophish_> make sure that # isn't the first character in a line
14:46:34 <monochrom> my only encounter with hlint is lpaste forcing it upon everyone
14:46:35 <mzero> is the logical main, but there is a c main wrapper https://github.com/mzero/plush/tree/master/src-main - so that FDs can be carefully controled
14:46:42 <jophish_> so move block comment terminator #-} to the end of the previous line
14:46:56 <jophish_> I really like HLint most of the time.
14:47:14 <DouweM> jophish_ it's not only that, it's failing on `#define NEGATE(n) (negateInt# (n))` in alex specifically. doesn't seem like I can just remove that
14:47:38 <monochrom> perhaps it needs more options and a config file so you can turn off a few checks you dislike
14:47:40 <jophish_> ah, that sucks
14:47:44 <jrmithdobbs> mzero: am I misunderstanding warp? I thought it was similar to a rack-like stack, why do you need all this system-level socket handling code?
14:48:11 <monochrom> DouweM: see the topic, the part near the end
14:48:27 <DouweM> monochrom: ooh thanks, I'll check that out
14:48:45 <mzero> jrmithdobbs: because plush is a POSIX shell, with some rather complex requirements
14:49:13 <mzero> in particular, since it is going to fork out processes, it needs fine-grained control over the sockets (so they don't get copied into the fork'd processes)
14:49:22 <mzero> assuming that is what you're referring to
14:50:12 <jrmithdobbs> mzero: ok, I'm not misunderstanding warp, you just gave me a much cooler example to look through than I was expecting :P
14:50:57 <mzero> heh! Admittedly it wasn't a starter project
14:51:27 <Eduard_Munteanu> In contrast, I think it's fair to write the hypothetical left fold as   foldl :: (s -> a -> ∞ s) -> ∞ s -> Stream a -> s   because you're accumulating in the '∞ s' argument. But there's no way to extract the "final" 's'.
14:52:35 <Eduard_Munteanu> And you can't pretend you return an '∞ s' because the recursion isn't productive.
14:52:40 <monochrom> onoes, mzero has also posted about xcode 5 on haskell-cafe.
14:52:59 <Eduard_Munteanu> Does this make any sense? :)
14:53:02 <monochrom> I think the topic still has room for more :)
14:54:16 <mzero> I know, monochrom, continuing to lead hoards of unsuspecting programmers down the path of Mac-dom!!! Bwahahahahahahaha
14:55:53 <Eduard_Munteanu> scanl :: (s -> a -> s) -> s -> Stream s -> Stream s   and you have no inftys.
14:57:03 <Eduard_Munteanu> Er, Stream a.
14:57:30 <Eduard_Munteanu> And  scanr :: (a -> s -> ∞ s) -> Stream a -> ∞ (Stream a)   AFAICT.
14:57:56 --- mode: ChanServ set +o monochrom
14:58:22 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? bit.ly/1hcZveF is.gd/nFaH9z' by monochrom
14:58:32 --- mode: monochrom set -o monochrom
15:00:53 <Eduard_Munteanu> Actually the last infty is wrong I think, Stream is already codata.
15:03:09 <startling> infty is nifty
15:05:11 <Eduard_Munteanu> Hm, wait... I think it should be  scanr :: (a -> s -> ∞ s) -> Stream a -> Stream (∞ s), because 'head (scanr f xs) = foldr f xs'
15:06:11 <Eduard_Munteanu> (those are scanr1's / foldr1's in fact, but the normal ones don't make sense for streams, you don't care about the last value)
15:11:41 <Eduard_Munteanu> (For reference, in Agda you have delay :: a -> ∞ a, force :: ∞ a -> a, and '∞' basically means you're dealing with a coinductively-defined (possibly infinite) type)
15:12:46 <Eduard_Munteanu> (with the requirement that from any '∞ a' you can peel off a data constructor)
15:14:24 <Eduard_Munteanu> In finite time, that is.
15:16:18 <rasfar> well, my battery actually did die after that lambdabot build -- right when I was typing how I loved Haskell and #haskell. It's nice to be back.
15:16:52 * Eduard_Munteanu thought he was responsible for killing the chat in here :P
15:18:56 <monochrom> love transcends life, death, battery life, and battery death :)
15:20:15 <mzero> speaking of #haskell -- 1200+ people in here? yikes! Are we now, in fact, the biggest room on freenode?
15:20:23 <cbw> Anyone use the Curry Programming language
15:20:31 <cbw> http://www-ps.informatik.uni-kiel.de/currywiki/
15:20:34 <FireFly> I think the ubuntu channel is bigger, or was last I checked anyway
15:21:05 <Cale> We're 6th
15:21:11 <aleksejs_> mzero, I think, most of people here are "dead"
15:21:17 <cbw> Curry = Haskell + Prolog
15:21:28 <Cale> After #ubuntu, #archlinux, #debian, #python, and ##linux
15:21:45 <aleksejs_> I've decided to add my Nq solution here http://rosettacode.org/wiki/N-queens_problem#Using_permutations
15:21:54 <mzero> none the less - we are still way up there -
15:22:13 <aleksejs_> cuz I think the code is neat
15:24:43 <danr> aleksejs_: neat
15:32:08 <rasfar> I wouldn't be surprised if a good number of the 1200 were bots. I mean, with lambdabot as an incentive and all. Like Haskellers plus pets...
15:32:28 <simpson> rasfar: You'd be surprised!
15:33:04 <rasfar> i'm lookin at you funny simpson 8/ -- botornot....
15:33:47 <simpson> rasfar: I'm a bot.
15:33:52 <rasfar> (hope that didn't come off rude, my humour is suffering from insomnia)
15:34:51 <rasfar> ah good, bots don't mind when you look at 'em funny
15:35:08 <simpson> rasfar: I'm not that kind of bot.
15:35:33 <rasfar> heehee. takes all kinds
15:38:09 <rasfar> Supposing I wanted to annotate a Haskell parse tree with types inferred, is my best bet the GHC API?
15:39:13 <rasfar> Always used Haskell.Source.Extensions in the past, but would be willing to make the leap into that very big and scary GHC API for the types
15:43:07 <rasfar> * haskell-src-exts oops (Language.Haskell.Exts) -- much smaller API
15:43:42 <rasfar> but maybe I only need a module or two from the GHC API (hopefully)
15:46:31 <rasfar> http://www.haskell.org/haskellwiki/GHC/As_a_library looks like a good tutorial for this in fact!
15:49:37 <dmj`> hey, I'm trying to zip files that I've uploaded to Snap. Keeps freezing and I don't know wehre
15:50:19 <rasfar> hey it works!! (sorry dmj`, i'm finished)
15:50:31 <dmj`> http://lpaste.net/95038
15:50:39 <dmj`> Another set of eyes would be greatly appreciated
15:51:18 <benmachine> rasfar: btw I wrote stepeval but I stopped because it didn't work properly
15:51:40 <benmachine> rasfar: I thought it might well be easier to start from scratch than fix it :P
15:52:07 <benmachine> rasfar: re: annotating with types, there's an ongoing project to do that
15:52:20 <benmachine> I believe it's not finished
15:52:25 <benmachine> but you might look into haskell-suite
15:52:29 <benmachine> also: typing haskell in haskell
15:52:39 <benmachine> which was a paper with code
15:52:42 <benmachine> pretty old now
15:52:51 <dmj`> linted: http://lpaste.net/95038
15:53:23 <rasfar> hi benmachine / dmj`, i didn't even know you could use commas to give a type to multiple targets
15:53:49 <dmj`> rasfar: yes haskell is the best language in the entire world
15:54:02 <rasfar> I remember that title certainly; I'm sure I've downloaded it more than once over the years...
15:54:07 <aleksejs_> can I ask a serious question?
15:54:35 <Eduard_Munteanu> aleksejs_: only if you expect a serious answer :P
15:54:46 <eikke> what would be a good name for a function "Int -> (Int -> m ()) -> m ()" which executes the 2nd element N times, providing the index?
15:54:48 <dmj`> aleksejs_: yes
15:55:16 <rasfar> thanks benmachine, for the awesome advice, I'll check out all of the above
15:55:20 <aleksejs_> how many of you guys (girls) are actually haskell developers? I mean your job
15:55:28 <dmj`> a -> (a -> m b) -> m b
15:55:35 <dmj`> @typ replicateM_
15:55:37 <lambdabot> Monad m => Int -> m a -> m ()
15:55:42 <dmj`> BOOYA
15:55:56 <eikke> dmj`: that doesnt help
15:56:10 <eikke> aleksejs_: I do (mostly ocaml, but some haskell as well)
15:56:15 <dmj`> yea, missing the (a -> m ()) in the middle
15:56:16 <Eduard_Munteanu> aleksejs_: not in the job description, but I can use anything I want, so I choose Haskell :)
15:56:18 <rasfar> aleksejs_: i'm not but I'm thinking of making an ultimatum stand on the subject soon!
15:56:44 <dmj`> aleksejs: I am doing a startup in haskell w/ a friend
15:56:49 <dmj`> so errday
15:57:27 <startling> dmj`: I heard that the way to be successful doing startups is to use your kindle during takeoff. Confirm/deny?
15:58:10 <dmj`> startling: kindle? Like the amazon ebook reader?
15:58:11 <apo> a+[b,c,...] evaluates to [a+b,c,...] because it's the same as a+b:c:... and + has higher precedence than :?
15:58:27 <dmj`> I'm sorry I'm not good with startup terminology (i.e. bootstrapping, etc)
15:58:41 <startling> dmj`: yep.
15:58:47 <apo> or is it some other magic? :P
15:59:01 <simpson> > 6 + [7..9] -- apo
15:59:03 <lambdabot>   No instance for (GHC.Show.Show t0)
15:59:03 <lambdabot>    arising from a use of `M1969144757.sh...
15:59:05 <apo> oh, it's part of what the teacher's doing somewhere
15:59:13 <startling> source: https://news.ycombinator.com/item?id=6648162
15:59:23 <apo> Guess I'll need to look again :)
15:59:38 <aleksejs_> I think it's a problem. In my case, I have contracts where I must develope and support projects in Java/PHP/JS/etc, and I hate this, because, as I mentioned before, I love haskell, but can't do it for the living. I think it's time to change the paradigm
16:00:19 <dmj`> startling: I don't own a kindle, so I guess I'm screwed
16:00:53 <dmj`> startling: is that article you sent related somehow
16:02:42 <rasfar> aleksejs_: Does  handleFiles xs = io $ (print xs) >> zipFiles...  guarantee that xs will be printed before the rest begins evaluating? (I presume the print is for debugging.)
16:03:16 <rasfar> you could try replacing that whole RHS with  error "blah" :: SuitableType
16:03:24 <Eduard_Munteanu> @src print
16:03:25 <lambdabot> print x = putStrLn (show x)
16:03:43 <apo> oooh.
16:03:44 <apo>   fromInteger x = (fromIntegral x) : repeat 0
16:03:47 <apo> this part did it.
16:03:55 <Eduard_Munteanu> rasfar: also don't confuse execution and evaluation
16:04:06 <rasfar> fromIntegral, grrr!...
16:04:50 <rasfar> Eduard_Munteanu: It's just, if the second part can raise an exception before the print happens? Or does that make no sense?
16:06:15 <mzero> apo: did you're prof. really write that?   a + [ b, c, d ... ]
16:06:20 <Eduard_Munteanu> rasfar: well, technically yes, I think. But not "normal" IO exceptions.
16:06:44 <rasfar> Would you care to elaborate a wee bit about execution vs. evaluation?
16:07:19 <rasfar> Is execution the compiler/implementation-dependant factor?
16:07:19 <Eduard_Munteanu> rasfar: execution of IO actions is unrelated to the evaluation of IO values.
16:07:22 <apo> mzero: https://github.com/olegl/fp13/blob/master/03/powerseries.lhs
16:07:38 <apo> mzero: Not explicitly, but something similar ;)
16:07:43 <rasfar> wow. (aside to self: "how can i not know this??...")
16:08:09 <apo> also, do yourself a favour and use https://raw.github.com/olegl/fp13/master/03/powerseries.lhs
16:08:12 <Eduard_Munteanu> rasfar: well, with the exception of lazy IO / unsafeInterleaveIO / unsafePerformIO
16:09:39 <mzero> apo: ick! there's a lot not to like in that code!
16:09:45 <startling> rasfar: you can think of IO as an abstract decision tree containing some foreign calls or whatever.
16:09:46 <Eduard_Munteanu> rasfar: now, if you have an IO action that calls print, and you happen to have undefined values like 'error' gives you, then technically you could get an exception.
16:09:49 <apo> mzero: Yeah, no kidding.
16:09:51 <rasfar> "unrelated" seems too strong -- how can that be? if I say getChar the value is certainly related to the action
16:10:03 <startling> rasfar, x -> IO a doesn't do anything, it just creates a decision tree.
16:10:19 <startling> rasfar, let x = getChar in x >> x
16:10:21 <rasfar> interesting
16:10:35 <apo> mzero: I started fixing it, adding type signatures and stuff, but eventually just gave up and wrote the 2 (or 4, I guess) lines I needed.
16:10:41 <startling> @quote /bin/ls
16:10:46 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
16:10:50 <rasfar> (I actually never use >> notation so bear with me)
16:10:51 <startling> rasfar: ^
16:10:51 <Eduard_Munteanu> rasfar: like startling says, a better model to think of IO is that it creates a list/tree of IO commands the RTS reads and performs.
16:12:27 <startling> rasfar: a >> b says "create an action out of two actions a and b where we do a, throw out the result, and then do b and keep the result".
16:12:30 <rasfar> is  let x = getChar in x >> x  any different than  getChar >> getChar  ?
16:12:35 <startling> rasfar: nope.
16:12:39 <rasfar> okay, whew
16:12:40 <schell> monochrom: thanks for the link earlier
16:12:57 <startling> rasfar: just saying "x" isn't the result at all, it's a description of the action you want to perform.
16:12:57 <Eduard_Munteanu> rasfar: plugging that back into Haskell, 'main' is a pure function that creates a program which the RTS executes independently.
16:13:07 <schell> i deleted all of my ghc's, cabal's etc and reinstalled the platform
16:13:14 <schell> then ran that script (twice)
16:13:21 <ski> s/function/value/
16:13:25 <schell> and i'm still getting lib loading errors
16:13:27 <Eduard_Munteanu> Fair.
16:14:06 <lpaste> schell pasted “mac os x glfw-b” at http://lpaste.net/95041
16:14:12 <rasfar> okay, I can accept that ... and even that *gulp* (ski)
16:14:18 <startling> rasfar: and then yeah, the runtime looks for an IO () called "main" and runs the whole tree.
16:14:27 <schell> that seems to be the same problem i'v had for weeks on mac os x
16:15:00 <startling> /creating/ an IO a is pure, but it describes an impure action.
16:15:15 <apo> heh, the prof gave away the solution to one of the other exercises in that template
16:15:29 <apo> (the pow xs stuff, we're supposed to implement that)
16:17:09 <DouweM> was able to get Haskell working after upgrading to Mavericks using the info linked in the topic; thanks to whoever wrote that up :)
16:17:57 <rasfar> thanks startling. between being overtired and needing to read some tutorials to refresh on stuff, I should let it be for now. Never thought of it as a decision tree before.
16:18:29 <schell> DouweM: i'm still working on it, thanks for the note
16:18:59 <rasfar> i'm off for groceries; bye for the present
16:18:59 <ski>   data IO :: * -> *
16:19:04 <ski>     where
16:19:13 <ski>     Return :: a -> IO a
16:19:20 <rasfar> (unless this is related...)
16:19:30 <ski>     Bind :: IO a -> (a -> IO b) -> IO b
16:19:39 <ski>     GetChar :: IO Char
16:19:49 <ski>     PutChar :: Char -> IO ()
16:19:52 <ski>     ...
16:19:57 <ski> rasfar : e.g. like that
16:20:18 <rasfar> yeah, looks very Monad
16:21:05 <ski> another way is
16:21:27 <ski>   data IOResult = ExitWith ExitCode
16:21:31 <haasn> http://comonad.com/reader/2011/free-monads-for-less-3/
16:21:44 <ski>                 | GetCharBind :: (Char -> IOResult) -> IOResult
16:21:57 <ski>                 | PutCharBind :: Char -> IOResult -> IOResult
16:22:00 <ski>                 | ...
16:22:15 <ski>   type IO a = (a -> IOResult) -> IOResult
16:23:43 <ski> rasfar : this has the advantage of being a monad "on the nose"
16:23:45 <rasfar> i manage to use this stuff without really understanding it. enjoying thinking about Bind (that's also >== and <- ?), instead of just using it on reflex.for a change
16:24:04 <ski> (`(>>=)' is bind)
16:24:05 <rasfar> i see
16:24:40 <rasfar> >>= not >== oops
16:24:47 <startling> rasfar: something beneficial might be to look at Maybe, Reader, and State and rewrite them and their Monad instances.
16:24:51 <rasfar> :r (<-)
16:24:54 <ski> (the problem with the former is that `Bind ma Return' is not equal to `ma', failing a monad law -- if we make the type abstract, and don't export a way to notice the difference, then it works)
16:24:57 <rasfar> :t (<-)
16:24:58 <lambdabot> parse error on input `<-'
16:25:04 <startling> rasfar: (<-) is syntactic sugar, not a real operator.
16:25:17 <ski> @hoogle <-
16:25:17 <lambdabot> keyword <-
16:25:25 <geekosaur> x <- y     is    y >>= \x ->
16:25:28 <rasfar> ah, so I can't ... @hoogle works, okay
16:25:30 <mauke> @undo do { x <- y; z }
16:25:30 <lambdabot> y >>= \ x -> z
16:25:40 <rasfar> doesn't tell you the semantics unfortunately
16:25:48 <rasfar> (keyword <- that is)
16:25:53 <ski> @src Maybe (>>=)
16:25:54 <lambdabot> (Just x) >>= k      = k x
16:25:54 <lambdabot> Nothing  >>= _      = Nothing
16:26:34 <rasfar> @src Either (>>=)
16:26:35 <lambdabot> Left  l >>= _ = Left l
16:26:35 <lambdabot> Right r >>= k = k r
16:27:00 <ski>   do a <- Just a ; ma  =  ma
16:27:02 <ski>   do _ <- Nothing; _  =  Nothing
16:27:03 <geekosaur> (plus a handful of special cases when x is a pattern instead of a simple binding)
16:27:15 <rasfar> wonder why there's indentation with Maybe, weird
16:27:31 <startling> people like aligning stuff sometimes.
16:27:39 <rasfar> types stripped from document comments in the source, nm
16:27:48 * ski aligns the stars
16:28:01 <startling> rasfar: the semantics depend on the monad instance whose (>>=) you're using.
16:28:12 <rasfar> i have a pet project to use dynamic programming to vertically align Haskell source...
16:29:41 <rasfar> well, "short range semantics" (meta-semantics?) -- I mean, the semantics that the interconnections in the Monad class tell you, without refracting into more particulars :)
16:30:07 <startling> rasfar: you mean the Monad laws?
16:30:20 <rasfar> yeah
16:30:23 <startling> http://www.haskell.org/haskellwiki/Monad_laws
16:30:30 <rasfar> I mean, "keyword <-" tells you less than it might
16:30:40 <rasfar> @src Monad
16:30:41 <lambdabot> class  Monad m  where
16:30:41 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
16:30:41 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
16:30:41 <lambdabot>     return      :: a -> m a
16:30:41 <lambdabot>     fail        :: String -> m a
16:31:17 <rasfar> specific (semantic) yet general (meta) ... or something
16:31:52 <rasfar> i should really sign off and get some food/sleep. Haskell/#haskell existing will make the morning seem brighter!
16:32:06 <rasfar> (even though it will probably be 4am when I wake up and still dark for 5 hours.) bye for now
16:35:48 <darthdeus> is there a way I can write a function thats   Just Int -> Int?
16:36:15 <simpson> darthdeus: Sure.
16:36:22 <dcoutts_> @hoogle Maybe Int -> Int
16:36:22 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
16:36:22 <lambdabot> Test.HUnit.Base ListItem :: Int -> Node
16:36:23 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
16:36:26 <simpson> :t maybe
16:36:27 <lambdabot> b -> (a -> b) -> Maybe a -> b
16:36:30 <startling> :t fromMaybe 12
16:36:31 <lambdabot> Num a => Maybe a -> a
16:36:39 <simpson> :t maybe 0 (+1)
16:36:41 <lambdabot> Num b => Maybe b -> b
16:36:51 <darthdeus> oh perfect :P thanks
16:36:57 <startling> :t const 0 `asAppliedTo` Just 12
16:36:58 <lambdabot> (Num b, Num a) => Maybe a -> b
16:37:18 <darthdeus> i thoguht once i stick something into maybe i can't get it out
16:37:42 <startling> darthdeus, well.
16:37:42 <simpson> darthdeus: You can pattern-match on Just and Nothing.
16:37:48 <startling> darthdeus, you need to handle the Nothing case.
16:38:04 <darthdeus> startling: I've filtered out Nothing ahead of the place where I'm calling it
16:38:22 <darthdeus> I have a list of [Maybe Int] and i kinda process it to filter some values, including Nothing
16:38:32 <startling> darthdeus: then you shouldn't have Maybe at all.
16:38:46 <startling> :t catMaybes
16:38:47 <lambdabot> [Maybe a] -> [a]
16:39:11 <startling> > catMaybes [Nothing, Just 2, Nothing, Just 1337]
16:39:12 <lambdabot>   [2,1337]
16:39:54 <darthdeus> oh perfect
16:39:56 <darthdeus> i love you guys
16:40:02 <startling> it's in Data.Maybe
16:40:32 <jml> a really good trick for finding things like that is to try hoogle.
16:40:32 <monoidal> darthdeus: if you are combining with map, use mapMaybe
16:41:06 <jml> I was looking at a similar thing the other day and went, is there something that does [Maybe a] -> [a]
16:41:07 <darthdeus> I have this http://lpaste.net/95042
16:41:21 <jml> and lo, there it was
16:41:25 <darthdeus> since I need to filter out the a < b case I don't think mapMaybe would work
16:41:46 <startling> :T mapMaybe
16:41:52 <startling> :t mapMaybe
16:41:53 <lambdabot> (a -> Maybe b) -> [a] -> [b]
16:42:08 <monoidal> darthdeus: what does the pair function do?
16:42:31 <darthdeus> monoidal: pair is an argument, lemme update the whole code
16:42:39 <darthdeus> i'm trying to solve this http://projecteuler.net/problem=32
16:42:43 <monoidal> darthdeus: in map (pair c)
16:43:06 <darthdeus> monoidal: http://lpaste.net/95042
16:43:07 <darthdeus> here it is
16:43:27 <darthdeus> allPairs gets a number like 6 and produces [(1,6), (2,3)]
16:44:26 <monoidal> darthdeus: if you can combine pair and properPair, you can use mapMaybe
16:45:22 <monoidal> darthdeus: other c a >>= (\b -> guard (a < b) >> Just (a,b))
16:46:09 <monoidal> darthdeus: then it's just mapMaybes (pair c) [1..c]
16:46:19 <gipp> > fromJust Nothing
16:46:21 <lambdabot>   *Exception: Maybe.fromJust: Nothing
16:46:44 <startling> I wish people would stop bringing up fromJust when people ask basic questions about Maybe.
16:46:57 <darthdeus> monoidal: i need a second to process that in my OOP brain :D
16:47:41 <monoidal> darthdeus: or, more explicitly,
16:47:54 <monoidal> darthdeus: other c a >>= (\b -> if a < b then Just (a,b) else Nothing)
16:48:08 <rck> is there an easy way to see which libraries are causing my program to be enormous when compiled? ~45MB for 400 lines. 27MB stripped.
16:48:26 <rck> I suspect http-conduit or haskeline but can't be sure
16:49:14 <monoidal> darthdeus: another - maybe simpler way - is this
16:49:37 <monoidal> darthdeus: you first map, then filter, then use catMaybes
16:49:42 <darthdeus> monoidal: hmmm so guard with >> is kinda like "if the condition is true yield the result in a monad, otherwise yield the falsy value of that monad"?
16:49:43 <monoidal> darthdeus: but there's another option
16:49:55 <darthdeus> i mean only guard, the >> is kinda obvious
16:50:07 <darthdeus> I'm not sure if I understand the MonadPlus typeclass
16:50:13 <monoidal> darthdeus: guard x = if x then return () else Nothing
16:50:26 <darthdeus> oh
16:50:27 <monoidal> darthdeus: that implementation is for Maybe, you needn't care about MonadPlus
16:50:34 <monoidal> darthdeus: but, I suggest something different
16:50:39 <startling> :t mzero :: Maybe String
16:50:41 <lambdabot> Maybe String
16:50:41 <darthdeus> monoidal: i thought it's   guard x = if x then return x else Nothing
16:50:41 <monoidal> darthdeus: change the pipeline
16:50:45 <monochrom> rck: use "ghc-pkg field haskeline library-dirs" to get a directory name. find the *.a file in that directory.
16:50:47 <startling> > mzero :: Maybe String
16:50:49 <lambdabot>   Nothing
16:50:54 <monoidal> darthdeus: that would be "then return True"
16:50:58 <rck> monochrom: thanks, will do
16:51:07 <darthdeus> right
16:51:24 <monoidal> darthdeus: first, map (pair c), *then* catMaybes, *then* filter, and during the filter you don't have to deal with Maybes
16:51:29 <jml> I just read through the parser chapter of RWH. The motivation for applicative functors isn't clear. I guess there are some things that are not monads but are applicative functors?
16:51:49 <monoidal> darthdeus: furthermore you will be able to use mapMaybe
16:51:51 <rck> jml: yes
16:52:09 <darthdeus> monoidal: oh right, it makes sense to switch those around
16:52:17 <jml> rck: can you give an example?
16:52:25 <darthdeus> monoidal: but i guess i'll pretend to be smart and use the mapMaybe solution you mentioned earlier
16:52:34 <jml> the chapter uses a parser, which is already a monad, so it seems weird to even bother with applicative functors
16:52:36 <chrisdone> jml: yeah, in monads you need a join operation (or bind, the implementation for which the definition can be derived from join), whereas applicatives don't need to have that. so there are more applicatives
16:52:46 <monochrom> jml: my personal motivation is that <*> <* *> are helpful, even though I stick with monad
16:53:13 <monoidal> darthdeus: IMO the solution with different order is much smarter/better.
16:53:17 <rck> jml: https://www.fpcomplete.com/school/advanced-haskell-1/functors-applicative-functors-and-monads
16:53:54 <jml> monochrom: well, <*> is just `ap`, right? so it's only <* and *> that are the actual wins?
16:54:37 <monoidal> jml: for what's worth, *> is the same as >>
16:54:39 <startling> *> is >>
16:54:42 <startling> yeah
16:54:52 <jml> oh right.
16:54:53 <startling> "Applicative style" is useful though
16:55:05 <jml> I think I knew that but forgot :\ Thanks.
16:55:07 <startling> Applicative literally gives you nothing over MOnad.
16:55:22 <startling> But, since you're more restricted, you can do things more safely.
16:55:27 <darthdeus> monoidal: allPairs c = filter (\(a, b) -> a < b) $ mapMaybe (pair c) [1..c]
16:55:37 <startling> E.g. downloading files with an applicative interface can always be done in parallel
16:55:38 <darthdeus> and i can get rid of the properPair function as well
16:55:44 <monoidal> darthdeus: yes
16:55:54 <monoidal> darthdeus: by the way do you know "uncurry"?
16:55:57 <darthdeus> monoidal: this haskell thing is so fucking brilliant
16:56:05 <darthdeus> monoidal: uhm, nope :X
16:56:05 <startling> And applicative-only parsers always describe context-free grammars.
16:56:13 <chrisdone> another happy customer
16:56:18 <monoidal> > (+) 3 4
16:56:19 <lambdabot>   7
16:56:22 <monoidal> > uncurry (+) (3,4)
16:56:23 <lambdabot>   7
16:56:59 <jml> ah ok. that's definitely a thing.
16:57:14 <monoidal> darthdeus: ^ uncurry changes a function a -> b -> c to a function (a,b) -> c, the function takes "two parameters at once" so to speak
16:57:14 <darthdeus> oh wow
16:57:17 <sie> How uncurrying differs from application?
16:57:47 <monoidal> uncurrying alone does not mean you are applying a function.
16:58:02 <monoidal> darthdeus: with this in mind, how can you write \(a,b) -> a < b?
16:58:07 <jml> rck: that explains what monads can do that applicative functors can't, but doesn't give an example of a thing that can be modelled as an applicative functor but not as a monad.
16:58:09 <startling> :t (+)
16:58:10 <lambdabot> Num a => a -> a -> a
16:58:12 <startling> :t uncurry (+)
16:58:13 <lambdabot> Num c => (c, c) -> c
16:58:28 <darthdeus> monoidal: uncurry (<) (a,b)
16:58:44 <monoidal> darthdeus: \(a,b) -> uncurry (<) (a,b)
16:59:02 <darthdeus> monoidal: so that i can make ... (\(a, b) -> uncurry (<) (a,b))  into just  (uncurry (<))
16:59:08 <monoidal> darthdeus: right!
16:59:11 <darthdeus> HOLY SHIT
16:59:12 <darthdeus> :D
16:59:19 <darthdeus> this is just so much magic
16:59:27 <monochrom> no, it's just algebra
16:59:27 <monoidal> so it's filter (uncurry (<)) $ mapMaybe ...
16:59:38 <monochrom> substitute equal for equal
16:59:43 <asparagui> so, who wants to do my homework
17:00:11 <jml> startling: I am going to postpone verifying those properties (parallel file dls, context free grammars) as an exercise to myself. sounds interesting & fun.
17:00:22 <chrisdone> jml: all monads are applicatives
17:00:32 <jml> chrisdone: yeah, I get that.
17:00:35 <darthdeus> i am so mindblown
17:00:37 <chrisdone> jml: just like all monads are functors
17:00:46 <jml> chrisdone: I'm asking for an example of a thing that is an applicative and not a monad.
17:01:42 <monoidal> jml: ziplist, const
17:01:53 <jml> monoidal: thanks.
17:02:11 <triliyn> Are those things fundamentally non-monadic or do they just not have Monad instances?
17:02:22 <Eduard_Munteanu> Technically there are monads that are not applicatives as well, probably not in Hask though.
17:02:34 <darthdeus> monoidal: so if i have    (\(a, b) -> show a ++ show b) ... i could kinda uncurry that with ++ as well, if i could do `show` on both of the elements, right?
17:02:39 <monoidal> triliyn: they cannot be made monadic and agree with applicative laws.
17:03:02 <jml> anyway, I have to leave before I turn into a pumpkin
17:03:08 <chrisdone> sometimes you just don't want a monad instance
17:03:10 <jml> (to make an oddly seasonal reference)
17:03:13 <chrisdone> to make some assurances
17:03:15 <darthdeus> kinda like (a -> b) -> (a, a) -> (b, b), but hoogle doesn't find it
17:03:16 <triliyn> monoidal: hmm, interesting
17:03:17 <monoidal> darthdeus: this is bit trickier; there's "on" combinator that supports this pattern
17:03:29 <jml> thanks all!
17:04:26 <monoidal> darthdeus: so the pointfree version is (++) `on` show
17:04:45 <monoidal> darthdeus: ultimately, sometimes it pays off to name variables, sometimes not.
17:04:55 <monoidal> ah, uncurry ((++) `on` show)
17:05:00 <monoidal> good night
17:08:24 <Eduard_Munteanu> I wonder if there's a fold, scan or something else that can deal with structures which don't have a start, nor an end.
17:09:01 <Eduard_Munteanu> Not sure what such a structure looks like though.
17:09:44 <monochrom> a function of type Integer->Integer has no start or end. what is fold and scan of it?
17:09:48 <Eduard_Munteanu> (Perhaps strictly negative types?)
17:10:11 <Eduard_Munteanu> monochrom: er, no, let's talk about inductively-defined things.
17:10:34 <monochrom> inductively-defined things have starts and ends
17:10:58 <Eduard_Munteanu> monochrom: by inductive I don't mean strictly inductive, they can be coinductive as well.
17:11:32 <monochrom> coinductive things have starts
17:12:45 <Eduard_Munteanu> Hm, I see. Not sure it makes sense not to have a start.
17:12:53 <FreeFull> :t on
17:12:54 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
17:13:13 <Eduard_Munteanu> Coinductive things don't have fully-defined values, so I suspect you can't really ask for less.
17:17:04 <jmcarthur> i challenge everybody to a game of golf. http://qandwhat.apps.runkite.com/i-failed-a-twitter-interview/
17:17:18 <jmcarthur> i have a head start. i freely admit that :)
17:17:38 <jmcarthur> therefore, i will wait a while before pasting my solution
17:18:25 <jmcarthur> the things i do on halloween...
17:19:16 <Hafydd> Twitter interviews?! http://24.media.tumblr.com/b30da8726527766d1f6b7e3778c70286/tumblr_mj5823ohgL1ru74s4o1_500.jpg
17:19:35 <asparagui> lol
17:19:56 <asparagui> gotcha code questions are silly lol
17:20:29 <Hafydd> Oh, it's an interview for Twitter, not over Twitter. That's what I thought, but the mention of Amazon confused me.
17:20:42 <jmcarthur> haha
17:20:47 <jmcarthur> this isn't a gotcha question
17:20:55 <jmcarthur> it is quite straightforward
17:21:09 <jfeltz> i'm sorry, but you don't have the right thought process for this company
17:21:20 <jmcarthur> for those wishing to take my up on my challenge, my solution is well under the 140 character limit of a tweet ;)
17:21:23 <jmcarthur> *me up
17:22:23 <asparagui> it was on yc yesterday
17:22:27 <jmcarthur> yeah
17:22:36 <jmcarthur> the solution has been thrown all over the internet by now
17:22:42 <jmcarthur> but not many have golfed it yet
17:23:23 <jmcarthur> also many of the solutions people have been putting out have been... wrong
17:23:26 <jmcarthur> which is sad
17:23:41 <jmcarthur> not that they got it wrong, but that they think they got it right
17:23:55 <chrisdone> wait
17:24:05 <jmcarthur> waiting
17:24:07 <chrisdone> are you using logic or something exotic in that sentence?
17:24:25 <jmcarthur> there are not exotic terms here
17:24:34 <jmcarthur> *no
17:24:58 <chrisdone> wittgenstein doesn't use exotic terms but i have no idea what he's talking about either
17:25:24 <Hafydd> Logic is so exotic.
17:26:11 <jmcarthur> has anybody taken the challenge?
17:27:40 <copumpkin> jmcarthur: nope, too lazy, but can you PM me your answer? I'm curious :)
17:28:11 <monochrom> I too only thought up the same wrong solution described in that article. at each local minimum, find local maxima on the left side and on the right side.
17:28:13 <jmcarthur> ok
17:58:26 <Hafydd> jmcarthur: here is my solution: rain hs = sum (zipWith min (scanl1 max hs) (scanr1 max hs)) - sum hs
17:58:43 <jmcarthur> we have a taker!
17:58:52 <jmcarthur> ah you are going for a low token count
17:58:57 <jmcarthur> i am going for a low character count
17:59:32 <Hafydd> Oh, well, I could do that, too. What libraries am I restricted to?
17:59:42 <jmcarthur> "major" ones
17:59:50 <jmcarthur> i'm willing to be a little handwavy here
17:59:55 <jmcarthur> i only used base, though
18:00:36 <Hafydd> Well...
18:00:37 <Hafydd> @pl rain hs = sum (zipWith min (scanl1 max hs) (scanr1 max hs)) - sum hs
18:00:38 <lambdabot> rain = ap ((-) . sum . ap (zipWith min . scanl1 max) (scanr1 max)) sum
18:00:43 <jmcarthur> i will go ahead and share my best so far
18:01:04 <jmcarthur> sum.liftA3(zipWith3$((-).).min)(scanl1 max)(scanr1 max)id
18:01:08 <jmcarthur> we had pretty similar ones
18:01:21 <Hafydd> We had the same essential idea, it seems.
18:01:56 <jmcarthur> an alternative i was working on right before you pasted yours. it's still a bit longer than my other one though
18:01:57 <jmcarthur> sum.((liftA3.zipWith3)(((-).).min)`on`($max))scanl1 scanr1 id
18:03:30 <copumpkin> does the infix on buy you anything there?
18:03:38 <jmcarthur> ah probably not
18:03:41 <jmcarthur> just used to it
18:04:17 <copumpkin> might be fewer chars without
18:04:26 <jmcarthur> oh, if i don't use it infix i just have to add some parens to its first argument
18:04:32 <copumpkin> oh boo
18:04:35 <jmcarthur> so no win, i think
18:05:04 <jmcarthur> sum.(on(liftA3$zipWith3(((-).).min))($max))scanl1 scanr1 id
18:05:15 <jmcarthur> i'm not using enough $
18:05:37 <jmcarthur> sum.(on(liftA3$zipWith3$((-).).min)($max))scanl1 scanr1 id
18:05:56 <copumpkin> more $ always helps
18:08:30 <startling> > fix $ (++) "id $"
18:08:31 <lambdabot>   "id $id $id $id $id $id $id $id $id $id $id $id $id $id $id $id $id $id $id...
18:12:08 <Targen> > fix error
18:12:10 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
18:12:22 <copumpkin> > fix show
18:12:24 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
18:12:29 <schell> jesus
18:12:33 <Targen> hah, didn’t know that one :)
18:12:33 <startling> copumpkin: haha
18:12:35 <schell> > :t fix
18:12:36 <lambdabot>   <hint>:1:1: parse error on input `:'
18:12:45 <schell> well that didn't work
18:12:46 <geekosaur> :t fix
18:12:47 <lambdabot> (a -> a) -> a
18:12:53 <schell> hmm
18:12:56 <startling> > fix f
18:12:58 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
18:12:58 <lambdabot>    arising from a us...
18:13:10 <startling> schell, fix f = f (f (f (f ...
18:13:20 <jmcarthur> @src fix
18:13:20 <lambdabot> fix f = let x = f x in x
18:13:23 <schell> i don't think i can understand fix from...ah thanks
18:13:49 <jmcarthur> > fix f :: Expr
18:13:51 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
18:13:54 <schell> that's trippy
18:14:04 <startling> > fix (const 13)
18:14:05 <lambdabot>   13
18:14:13 <jmcarthur> > fix (1:)
18:14:14 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:14:43 <schell> that sounds like one of Douglas Hofstadter's strange loops, ha
18:14:54 <foooz> anybody know how to tell ghc to use my freeglut instead of glut?
18:15:12 <startling> foooz: I think you need to recompile the glut package.
18:15:19 <startling> schell, it's a laziness thing
18:15:31 <foooz> startling: i'll try that now
18:15:44 <prophile> fix is _|_ if the argument is strict, iirc
18:15:59 <startling> foooz: there might be an option for freeglut / to specify a library to build against
18:16:24 <startling> > fix (`seq` 1)
18:16:26 <schell> what's a practical application of fix?
18:16:31 <lambdabot>   mueval-core: Time limit exceeded
18:16:51 <prophile> schell: you can use it to write most (all?) recursive functions without explicit recursion
18:16:56 <jmcarthur> all
18:16:57 <copumpkin> > let x = show x in x
18:16:57 <copumpkin> all
18:16:58 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
18:17:12 <ion> > fix (flip (foldr (:)) "hello")
18:17:14 <lambdabot>   "hellohellohellohellohellohellohellohellohellohellohellohellohellohellohell...
18:17:28 <startling> schell: but you never do really need it; you can do anything you can do with fix with explicit recursion.
18:17:29 <jmcarthur> if we did not have any sort of direct recursion but did have fix we would still have the same expressivity
18:17:43 <schell> right - the recursion is implicit - so it's a sort of recursion short cut
18:17:59 <ion> > fix (flip (foldr const) "hello")
18:18:00 <lambdabot>   'h'
18:18:05 <startling> it's "primitive recursion".
18:18:18 <copumpkin> general recursion
18:18:28 <jmcarthur> more general than primitive!
18:18:32 <startling> is it?
18:18:42 <startling> (is "primitive recursion" the y-combinator?)
18:18:49 <jmcarthur> no
18:18:52 <jmcarthur> the y combinator is fix
18:19:05 <startling> in lazy languages
18:19:08 <startling> (right?)
18:19:59 <startling> what's primitive recursion, then? Nat eliminators?
18:20:03 <tac> startling: primitive recursion is foldr
18:20:20 <jmcarthur> umm
18:20:30 <jmcarthur> wouldn't foldr in this vocabulary normally be "iteration"
18:20:33 <startling> foldr is the "list eliminator" right?
18:20:38 <tac> It's where all your recursion is allowed to do is pop off a constructor, and call itself again with the insides.
18:20:43 <jmcarthur> i normally think of primitive recursion as being a paramorphism, not a catamorphism
18:20:43 <tac> startling: yes
18:20:44 <startling> tac: right, OK.
18:21:02 <foooz> startling: cabal says "following packages are likely to be broken by the reinstalls: haskell-platform-2013.2.0.0" ...
18:21:08 <startling> heh.
18:21:15 <foooz> startling: that seems like a non-starter
18:21:22 <foooz> i don't want to replace the global-glut
18:21:25 <foooz> just install a local-glut ..
18:21:25 <startling> foooz, how did you install everything else?
18:21:33 <jmcarthur> paramorphisms and catamorphisms are equally expressive, but a paramorphism may be more efficient for some things.
18:21:39 <foooz> startling: platform, i think.. hence the platform..
18:21:39 <startling> foooz, (are you using sudo? you shouldn't be.)
18:21:47 <startling> foooz, what OS?
18:21:48 <foooz> startling:  no.. i think glut is in the platform
18:21:52 <startling> yes, it is.
18:21:53 <foooz> macos; not using sudo
18:22:21 <startling> foooz, you can use a cabal sandbox if you don't mind reinstalling everything.
18:22:44 <startling> cabal sandbox init; cabal install glut --whatever-options; cabal install
18:23:07 <foooz> hmm.. i've never used the sandbox option .. i'll look into it
18:23:16 <foooz> startling: thanks! ..
18:23:38 <startling> it's new in this cabal version. you may need to cabal install cabal-install if you don't have 1.18 yet
18:24:39 <foooz> startling: i have 1.18.1 :)
18:24:42 <Hafydd> I like that the "simple and beautiful" solution is 41 lines of ugly Java.
18:24:59 <copumpkin> damn right
18:26:19 <ion> hafydd: Where?
18:26:38 <Hafydd> ion: https://gist.github.com/mkozakov/59af0fd5bddbed1a0399 , which is linked from http://qandwhat.apps.runkite.com/i-failed-a-twitter-interview/
18:26:45 <Hafydd> (Contains spoilers)
18:28:20 <NickHu> Hey guys, I'm trying to display icons with Gtk, but transparency doesn't seem to work. I think I need to set a mask, but I don't know how this works:
18:28:29 <NickHu> imageMask :: PixmapClass pixmap => ReadWriteAttr Image Pixmap pixmap
18:34:56 <lykos> Hello everyone
18:36:08 <lykos> I've been here before, but I'm really starting to get into Haskell now, and figured I should get to know some of you. The Haskell community's pretty great from what I've seen so far.
18:36:38 <ski> you're welcome
18:38:35 <lykos> I'm making a game using gloss (a library using glut and openGL)
18:38:45 <lykos> and I'm trying to figure out how to best implement something
18:39:28 <lykos> I have seeking-missiles that head towards a given point
18:39:44 <lykos> I want to make it o missiles can follow a certain entity
18:40:13 <lykos> I want to have a list of agents, and have it so that the bullets of one agent can "lock onto" another agent.
18:40:31 <lykos> In an imperative language, I'd use pointers to an object.
18:40:43 <lykos> How could I accomplish this in haskell?
18:41:14 <edwardk> I've posted https://www.fpcomplete.com/user/edwardk/oblivious/deamortized-st in case anyone wants to help proof read it before it gets too much visibility to a wider audience
18:41:46 <davorak_> Requesting code review advise for conduit library that allows the use of monad transformers in isolated sections of conduit.  Much like how the pipes package handles it.  I am more familiar with the pipes package then conduit. https://github.com/Davorak/conduit-lift
18:42:03 <lykos> I could have a unique identifier in each agent, and every tick I could parse the agent list to find the one with the unique identifier, then get the coords from that agent and head towards them. That would have quite a computational overhead though.
18:42:26 <ricree> quick question. what function is equivalent to using >> on each member of a list of [m a]?
18:42:43 <edwardk> :t sequence
18:42:45 <lambdabot> Monad m => [m a] -> m [a]
18:42:46 <edwardk> :t sequence_
18:42:47 <lambdabot> Monad m => [m a] -> m ()
18:42:57 <edwardk> sequence_
18:43:05 <lykos> :t MapM
18:43:06 <lambdabot> Not in scope: data constructor `MapM'
18:43:30 <lykos> :t Control.Monad.MapM
18:43:31 <lambdabot>     Not in scope: data constructor `Control.Monad.MapM'
18:43:32 <triliyn> :t mapM
18:43:33 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
18:43:40 <lykos> ah, of course
18:44:04 <ricree> thank you. knew it was something simple like that. Almost afraid to ask, but for some reason my mind was going blank
18:45:34 <lykos> Does anyone have a suggestion for what I could do?
18:46:28 <HugoDaniel> why are conduits good for ? doesn't haskell already does what they do under the hood ?
18:47:51 <triliyn> lykos: I'm not really an expert on the best haskell-ish way to do things, but to get potentially-better performance with your unique identifier thing, you could use a map from identifiers to agents instead of an agent list
18:49:17 <lykos> triliyn: Okay, any idea's how I could implement that? I have some ideas but I'm trying to think outside the box
18:49:32 <Iceland_jack> lykos: Do you mean how to implement maps?
18:49:36 <Iceland_jack> Data.Map
18:49:36 <simpson> HugoDaniel: What do you mean, exactly?
18:50:13 <lykos> I know how to use maps
18:50:13 <triliyn> lykos: yeah, Data.Map, and you could probably get away with just using integers as IDs
18:50:44 <lykos> I mean how would I efficiently "map from identifiers to agents"?
18:51:33 <Iceland_jack> lykos: Do you know who to use Data.Map? Also like triliyn said you can use Integer's (or Int's and use Data.IntMap)
18:51:34 <HugoDaniel> haskell already does lazy io, i cant understand why conduits are better
18:51:46 <Iceland_jack> conduits are not about doing lazy IO
18:52:12 <HugoDaniel> ok, so what are they about ?
18:52:25 <Iceland_jack> HugoDaniel: Have you looked at the documentation?
18:52:34 <lykos> Ah, okay. I thought you meant just basic mapping a function over the list
18:52:40 <HugoDaniel> reading data in chunks ?
18:52:42 <lykos> I just looked up the documentation
18:52:51 <HugoDaniel> the yesod blog ?
18:53:46 <Iceland_jack> Just searching for ‘Conduits Haskell’ gives me good results, maybe that could work for you
18:55:05 <lykos> How are basic lists implemented in haskell?
18:55:13 <lykos> linked-list based, right?
18:55:15 * hackagebot yamemo 0.4.0.1 - Simple memoisation function  http://hackage.haskell.org/package/yamemo-0.4.0.1 (NobuoYamashita)
18:55:45 <Iceland_jack> @src []
18:55:45 <lambdabot> data [] a = [] | a : [a]
18:55:49 <lykos> triliyn: and Iceland_jack: thanks for the advice, Data.Map looks perfect for what I'm trying to do
18:55:56 <Iceland_jack> Good luck lykos
18:56:01 <HugoDaniel> "conduit allows you to deal with large- and possibly infinite- streams of data in constant memory. Chunks of data are dealt with one piece at a time instead of needing to read in the entire body at once."
18:56:06 <lykos> Maybe later on, would anyone be interested in testing out my game?
18:56:14 <HugoDaniel> conduits: lazy io with an agenda ?
18:56:29 <lykos> It's starting to get rather nice
18:56:30 <Iceland_jack> HugoDaniel: conduit also allows for deterministic resource usage. When using scarce resources like file descriptors, conduit is designed to immediately recycle resources when they are no longer needed. Contrast this with lazy I/O, which provides for constant memory usage, but at the expense of deterministic resource usage.
18:56:33 <HugoDaniel> "conduit also allows for deterministic resource usage."
18:56:51 <HugoDaniel> what happened to the "with..." functions that haskell used to have ?
18:57:14 <HugoDaniel> whats wrong with bracket ?
18:57:29 <Iceland_jack> You can implement ‘with…’ using ‘bracket’
18:57:54 <geekosaur> the problem with those is yoiu kinda have to use strict I/O with them. I believe conduit enableds deterministic lazy I/O without the flaws of standard lazy I/O
18:58:21 <Iceland_jack> @ReadMode
18:58:21 <lambdabot> Unknown command, try @list
18:58:21 <Iceland_jack> | WriteMode
18:58:26 <Iceland_jack> Oops.
18:58:31 <Iceland_jack> @src withFile
18:58:31 <lambdabot> withFile name mode = bracket (openFile name mode) hClose
18:58:46 <Iceland_jack> HugoDaniel: ↑ is that relevant to your question?
18:58:48 <HugoDaniel> exactly
18:59:02 <HugoDaniel> so conduits pt1: lazy io with an agenda
18:59:10 <HugoDaniel> conduits pt2: bracket with an agenda
18:59:13 <HugoDaniel> lets see pt3
18:59:15 <Iceland_jack> What?
18:59:20 <simpson> Uh. What's the agenda?
18:59:27 <Iceland_jack> I don't know what you're talking about HugoDaniel
18:59:50 <HugoDaniel> i dont know, i fail to see the point with conduits :/
18:59:52 <simpson> HugoDaniel: conduits and pipes are dataflow abstraction libraries.
19:00:04 <HugoDaniel> haskell already does everything they do
19:00:14 <simpson> HugoDaniel: With lists? Not really.
19:00:15 <geekosaur> again, only if you do strict I/O
19:00:28 * ski thinks `hClose' on a handle passed to `hGetContents' ought to not terminate the read string
19:01:24 <geekosaur> hClose is only part of it, though. there is no way to do error handling with hGetContents
19:01:33 <geekosaur> no exception, just your string ends
19:02:07 <geekosaur> or if it is soemthing that throws an exception, it's liable to be thrown in pure code where you can't catch it
19:02:17 * Iceland_jack shakes fist at lazy I/O
19:03:34 <HugoDaniel> its easy, grab a handle, work the handle, close the handle
19:03:58 <geekosaur> easy and might as well be written in C
19:04:00 <HugoDaniel> with conduits: use $$= $==D and all those others funky operators :/
19:04:41 <HugoDaniel> and in the end, have your handle closed somewhere in the middle just because you forgot to properly setup buffering
19:04:42 <geekosaur> i fyou want to write all your code in Haskell-flavored imperative C, there is indeed no point in conduits.
19:04:48 <HugoDaniel> or something like that :/
19:04:53 <geekosaur> if you want to write idiomatic Haskell, you want something sensible
19:05:06 <HugoDaniel> whats sensible in $==D ?
19:05:16 <simpson> HugoDaniel: That's not actually a conduits operator.
19:05:20 <simpson> HugoDaniel: But please, go on.
19:05:23 <HugoDaniel> oh sry about that :)
19:05:24 <geekosaur> (mind, I'm not convinced myself that the current state of those libraries is sensible... but this is how we *find* what is sensible)
19:05:53 <geekosaur> you are more or less looking at someone's research projects
19:06:05 <simpson> HugoDaniel: The idea of conduits and pipes is to have an easy way to model dataflow, one value at a time.
19:06:15 <HugoDaniel> ok, this one exists (i skimed to the bottom of the overview page): $$+-
19:06:20 <simpson> If you need multiple values, or you need to provide backpressure, these libraries allow you to do it.
19:06:21 <geekosaur> if you want to wait N years for the research to become polished production code, wait and write Haskell-flavored imperative C in the meantime
19:06:22 <HugoDaniel> whats sensible in $$+- ?
19:06:31 <simpson> HugoDaniel: Not much, but you won't use it often.
19:06:47 * geekosaur sees he's talking to a wall, goes away
19:06:53 <HugoDaniel> "imperative" ?
19:07:25 <HugoDaniel> i dont find the current state of haskell handle functions to be that "imperative", but sure you can be bare metal and almost close to C
19:08:13 <HugoDaniel> which is actually a good thing, considering that proper fd mangling is a discipline long mastered by C programmers
19:08:40 <jcarpenter2> what does fd stand for?
19:08:46 <HugoDaniel> dude: $$+-, all arguments are invalid
19:09:12 <simpson> HugoDaniel: So how about pipes instead?
19:09:13 <geekosaur> jcarpenter2, in what context?
19:09:21 <simpson> jcarpenter2: File Descriptor, probably.
19:09:22 <HugoDaniel> file descriptor
19:09:28 <geekosaur> if you meant HugoDaniel comment, file descriptor
19:09:32 <jcarpenter2> yep
19:09:38 <geekosaur> which is the low-level file object on POSIX systems
19:10:09 <geekosaur> (actualy a small integer representing an index into a process file table in the kernel, typically)
19:10:29 <jcarpenter2> oh cool, just a handle
19:11:11 <jcarpenter2> oh my god, that's where 0, 1, and 2 for stdin, etc. come from
19:11:33 <geekosaur> yep
19:11:34 <jcarpenter2> I thought that was just arbitrary bullshit
19:11:36 <foooz> startling: sandbox is awesome. :)
19:11:42 <jcarpenter2> haha
19:11:45 <startling> foooz: isn't it?
19:11:55 <foooz> startling: i came from the python world, so this is a great addition to cabal, as far as i'm concerned! :)
19:12:01 <startling> only downside is long compile times
19:12:14 <foooz> startling: well, just when you're getting started with a package..
19:12:16 <geekosaur> the first file descriptors opened by a terminal session leader are its terminal input, output, and error streams, thus those are 0, 1, and 2
19:12:20 <startling> foooz: yeah.
19:12:29 <jcarpenter2> It's still just an arbitrtary convention
19:12:32 <HugoDaniel> geekosaur: you are not talking to a wall, i just wonder how conduits can be a "better" option than what haskell already offers in base
19:12:36 <jcarpenter2> but there's some method to it at least
19:12:37 <geekosaur> (traditionally by getty, these days by the terminal emulator)
19:12:54 <startling> HugoDaniel, Haskell's base doesn't really do anything like conduits
19:13:04 <simpson> HugoDaniel: Like I said, when you want to operate on flowing streams of values, it's an interesting option.
19:13:10 <startling> Lazy I/O, sort of, but that's unpredictable.
19:13:21 <simpson> HugoDaniel: Also look at the pipes library, which does the same sorts of things in a slightly different way.
19:13:24 <startling> The thing about conduits/pipes/etc is that you explicitly read
19:13:27 <HugoDaniel> simpson: what about lazy bytestring ? isnt that flowing streams of values ?
19:13:36 <HugoDaniel> it comes in chunks
19:13:40 <startling> HugoDaniel: yes, but it reads whenever it feels like
19:13:49 <startling> HugoDaniel: rather than exactly when you tell it to.
19:14:00 <geekosaur> HugoDaniel, I think I addressed that. they're works in progress and they address some use cases the standard I/O mechanisms don't handle very well so early adopters are willing to use them. I think in some number of years they will evolve into something that is a bit more tractable for common cases
19:14:04 <startling> This means it's hard to predict when e.g. the file will be closed.
19:14:10 <simpson> HugoDaniel: Imagine reading off of a TCP socket. Do you really want a lazy ByteString for that?
19:14:27 <startling> http://stackoverflow.com/questions/5892653/whats-so-bad-about-lazy-i-o
19:14:51 <HugoDaniel> simpson: good example
19:15:03 <HugoDaniel> i might use a lazy bytestring
19:15:23 <geekosaur> network streams being one big case of something that's not handled very well --- simple stuff can be done with the stuff in base, high performance / high throughput stuff not so much
19:15:25 <HugoDaniel> it depends on the use case
19:15:27 <startling> laziness makes it hard to do things asynchronously, too.
19:15:39 <startling> well, asynchronously in a predictable way.
19:15:47 <HugoDaniel> ok, whats wrong with async ?
19:15:59 <startling> Nothing!
19:16:02 <HugoDaniel> async is *way* more idiomatic than the most basic conduit example :/
19:16:23 <geekosaur> right, that's twice the same wall.
19:16:28 <simpson> HugoDaniel: The async package makes it difficult to deal with indefinitely-long TCP streams. Imagine that you have GiB of data being moved through a stream over a course of hours. Do you really want to buffer all of it in memory before you begin to process it?
19:16:29 <startling> HugoDaniel, what if I'm blocking on I/O and I want to do something at the same time?
19:16:42 <HugoDaniel> and you can use hPutBuf and hGetBuf on a socket
19:16:42 <startling> oh, you're talking about a package called "async".
19:16:50 <HugoDaniel> forkIO ?
19:17:20 <dmj`> anyone care to look at my broken snap file upload code? Would appreciate feedback
19:17:21 <dmj`> http://lpaste.net/95038
19:17:27 <dmj`> as to why it's broken
19:17:46 <HugoDaniel> simpson: you can set a handle to be unbuffered
19:18:09 <simpson> HugoDaniel: You said Async, right?
19:18:13 <HugoDaniel> in that case just forward data to attoparsec or whatever else you need to have it parsed
19:18:19 <HugoDaniel> async, the pkg
19:18:27 <HugoDaniel> should work well with unbuffered handles
19:18:29 <simpson> HugoDaniel: So you have to run many many many Asyncs constantly to get all of that data?
19:18:55 <simpson> HugoDaniel: And then you have to constantly run an attoparsec parser to peel out records or packets from the data?
19:19:05 <simpson> HugoDaniel: So let's write a library to wrap up the parser. We'll call it "cereal".
19:19:07 <HugoDaniel> simpson: as you also have to in conduit
19:19:34 <simpson> HugoDaniel: And let's write a piece of code that hooks "cereal" up to ByteString-based chunk delivery. We'll call that "conduit-cereal".
19:19:52 <simpson> HugoDaniel: And let's also write something that hooks that delivery mechanism up to a socket. We'll call it "conduit-network".
19:19:54 <HugoDaniel> i said attoparsec as an example, you can use cereal if you want
19:19:55 <simpson> Surprise!
19:20:00 <HugoDaniel> cereal uses strick bytestrings
19:20:03 <simpson> HugoDaniel: cereal uses attoparsec internally.
19:20:21 <HugoDaniel> ok
19:20:24 <HugoDaniel> cool
19:20:36 <simpson> HugoDaniel: You can, if you like, turn a single Get-table type into a full-blown stack that parses from a socket, in maybe three lines, using conduit.
19:20:42 <dmj`> emacs froze, did I miss something
19:20:45 <HugoDaniel> your point is ? you can use brainf*ck if you want, its not the point
19:20:58 <simpson> HugoDaniel: You asked why somebody might use conduits or pipes. This is why.
19:21:06 <HugoDaniel> simpson: three amazing lines filled with $$+- and $==D
19:21:25 <simpson> HugoDaniel: ...Okay, yeah, you're just being intentionally dense. I have better things to do. Have a nice night.
19:21:47 <HugoDaniel> simpson: you can also do the same with std haskell in 3 lines, if properly abstracted
19:21:57 <simpson> HugoDaniel: conduits is such an abstraction.
19:22:11 <HugoDaniel> its not, because they force you into their pattern
19:22:36 <HugoDaniel> and into their strange datatype
19:22:40 <HugoDaniel> and stranger operators
19:22:49 <HugoDaniel> and functions
19:23:01 <HugoDaniel> its far from trivial and idiomatic :/
19:23:05 <HugoDaniel> its just not easy
19:23:07 <Iceland_jack> HugoDaniel: OK
19:23:12 <startling> HugoDaniel, I think you might like pipes.
19:23:18 <HugoDaniel> most stuff done with conduits can easily be done with simple type classes in haskell
19:23:23 <startling> HugoDaniel: but consider that this is not an easy problem.
19:23:27 <HugoDaniel> yet people are doing it with conduits, just because
19:23:28 <simpson> HugoDaniel: Go home and be a family man.
19:23:42 <HugoDaniel> ill give you an example
19:23:57 <carter> schell: posting on the gist doesn't reach me
19:24:17 <carter> schell: and old gcc doesn't understand objective C i'd assume
19:24:38 <HugoDaniel> look at the diff between these two packages: csv-conduit and cassava
19:25:26 <HugoDaniel> they both do more or less the same thing
19:25:36 <HugoDaniel> with cassava you only need basic haskell skills
19:27:11 <HugoDaniel> not so much with csv-conduit :/
19:29:53 <foooz> startling: after much sandboxing, it appears that simply compiling the haskell GLUT package with freeglut on my system and then forcing my package to use the newly compiled glut doesn't cause GLUT to use the freeglut backend
19:30:25 <HugoDaniel> i have a package that uses only libX to open a opengl 3.x context
19:31:02 <HugoDaniel> if xorg is your target, it should be enough: http://hackage.haskell.org/package/GLHUI
19:31:10 <HugoDaniel> and it doesn't use conduits (yay)
19:31:14 <startling> foooz: aw.
19:31:26 <startling> there's probably an -l thing you can do, but I'm not sure.
19:31:43 <foooz> likewise; and i'm not really planning to persue it tonight
19:31:51 <foooz> another day!
19:31:58 <foooz> startling: thanks for showing me sandboxing, thought!
19:33:46 <lispy> the easy way to get an opengl conext is glfw-b
19:33:59 <lispy> It builds on all platforms without extra libraries and just works.
19:34:08 <simpson> lispy: He's made it clear that he doesn't want life to be easy.
19:34:18 <Iceland_jack> lol
19:34:43 <Iceland_jack>     (deftype ℕ {Z ℕ, S (→ ℕ ℕ)})
19:34:54 <lispy> what language is that?
19:35:09 <lispy> looks like agda in lisp syntax :)
19:35:12 <Iceland_jack> Yes!
19:35:22 <Iceland_jack> Basically, it's a fantasy language of mine :)
19:35:28 <lispy> cool
19:35:48 <ski> Agda meets Liskell meets Clojure ?
19:35:49 <lispy> Sports nerds have fantasy football/soccer teams. PL Nerds have fantasy languages :)
19:35:51 <Iceland_jack> But it's pretty hard to reconcile ML style syntax with Lisp to be honest
19:35:55 <Iceland_jack> ski: Something like that :)
19:35:57 <HugoDaniel> lispy: they have included the glfw c code in it ?
19:36:08 <lispy> HugoDaniel: precisely
19:36:13 <HugoDaniel> amazing :)
19:36:21 <lispy> It's not much code actually
19:36:23 <Iceland_jack> Pattern matching on ML-style constructors always ends up icky
19:36:24 <HugoDaniel> i hope they removed all the thread handling junk glfw used to bring
19:36:39 <ski> Iceland_jack ?
19:36:42 <lispy> HugoDaniel: Yeah, it's using the latest GLFW if that's what you're getting at
19:36:48 <Iceland_jack> ski: Using Lisp syntax
19:36:55 <lispy> HugoDaniel: have you seen the glxgears in Haskell using GLFW?
19:37:01 <HugoDaniel> no
19:37:04 <ski> why does it end up icky ?
19:37:25 <HugoDaniel> im out of the opengl scene for quite a while now :/
19:37:45 <Iceland_jack> ski: For most examples the ML/Haskell versions look far cleaner but I'd love to br proven wrong!
19:37:53 <lispy> HugoDaniel: https://github.com/bsl/GLFW-b-demo/tree/master/src
19:38:14 <NickHu> When you do something like a <- someIOFunction does the IO get dropped?
19:38:37 <ski>   (= (length (nil)) 0)
19:38:38 <ski>   (= (length (cons _ as)) (+ 1 (length as)))
19:38:43 <ski> or something like that ?
19:38:53 <lispy> NickHu: Not exactly. It's more that you create a name for the result and then youe can refer to the result in other computations.
19:38:58 <NickHu> I'm just trying to understand why this doesn't work: http://puu.sh/55hUt.hs
19:39:01 <Iceland_jack> ski: I don't like that approach, that's the Liskenn one right?
19:39:05 <lispy> NickHu: but the `a` still can't escape
19:39:27 <lispy> :t return
19:39:27 <ski> (possibly with the definiens' (definienses ?) on their own lines, indented under the definiendums)
19:39:28 <lambdabot> Monad m => a -> m a
19:39:29 <Iceland_jack> Another icky thing is how to specify type annotations in a Lisp-like language but a personal preference would be to have → be variadic (→ a (→ b₁ b₂) c) equalling (a → (b₁ → b₂) → c)
19:39:37 <ski> Iceland_jack : can't recall
19:39:47 <lispy> NickHu: notice that while `return` takes an the `a`, it wraps it again in IO
19:40:13 <NickHu> lispy: So how should I be doing it?
19:40:26 <Iceland_jack> ski: ?
19:40:26 <Iceland_jack>     (defn length [nil      0
19:40:26 <Iceland_jack>                   (∷ _ xs) (+ 1 (length xs))])
19:40:45 <lispy> NickHu: instead of trying to get the `a` out of IO, you could a) pass in a function that works on the `a`, or b) call a function on the `a` once you have it (inside testIO)
19:40:52 <lispy> NickHu: those are the two main options anyway
19:40:53 <ski> Iceland_jack : what about it ?
19:41:05 <Iceland_jack> ski: That's a possible alternative I just came up with
19:41:20 <ski> Iceland_jack : but then you don't repeat `length' :(
19:41:25 <Iceland_jack> :(
19:41:31 <Iceland_jack> why is that needed though?
19:41:36 <ski> it's not needed
19:41:40 <ski> it's just often nicer
19:41:54 <Iceland_jack> Maybe, for +3 cases it feels redundant
19:41:55 <ski> (to be able to read each clause separately, as a true fact)
19:42:00 <Iceland_jack> yes that's true
19:42:16 <Iceland_jack> you can use case … of in Haskell though for something similar to the above example
19:42:39 <ski> in OCaml, there's `let rec length = function nil => 0 | _ :: xs => 1 + length xs'
19:42:48 <ski> (which is similar to `\case')
19:42:53 <Iceland_jack> I'm not sure repeating the definiens (‼) would be the lispy way to do it anyway
19:43:03 <Iceland_jack> Yes I find that rather nice
19:43:13 <ski> s/definiens/definiendum/
19:43:16 <Iceland_jack> gah
19:43:35 * ski grins smugly
19:44:00 * Iceland_jack feels sting of defeat
19:44:32 <Iceland_jack> But yes, there are several typed Lisps (Typed Racket, Clojure with types, …) and I'm not really a fan of their syntax (or type systems for that matter)
19:44:40 <ski> NickHu : When you do something like `a <- someIOFunction; ...', the `IO' from `someIOFunction' gets *merged* with the `IO' from `...'
19:44:45 <Iceland_jack> So maybe Lisps just aren't meant to be typed :)
19:45:34 <ski> or maybe retrofitting a type system to a language that wasn't designed with types in mind will always be somewhat disappointing ?
19:45:51 <Iceland_jack> Yes of course that as well
19:46:03 <vonDraco> finally got around to getting my tokeniser working. all i had to do was replace the cons with ++ http://lpaste.net/4425407505773887488
19:46:11 * ski should look at Qi some time
19:46:11 <Iceland_jack> but what about something like (+) (+ a) (+ a b) (+ a b c), what's the type of +?
19:46:21 <vonDraco> does this make me a computer scientist now?
19:46:27 <Iceland_jack> The novelty of Qi wore off quite quickly for me
19:46:35 <Iceland_jack> vonDraco: Sure why not
19:46:46 <vonDraco> :D
19:47:05 <ski> Iceland_jack : `Num a => (a^*) -> a' or something like that
19:47:12 <HugoDaniel> lispy: opengl 1.1 in haskell ? i thought it only supported newer versions or something
19:47:20 <Iceland_jack> I feel like that would get real hairy real quickly ski
19:47:22 <HugoDaniel> this gears example is using display lists
19:47:52 <ski> Iceland_jack : perhaps. i don't know
19:47:57 <lispy> HugoDaniel: IIRC, that stuff is only deprecated not removed
19:48:05 <HugoDaniel> oh cool :D
19:48:11 <lispy> HugoDaniel: OpenGL ES removes things like that, but I thought desktop opengl left it in
19:48:36 <HugoDaniel> here is a bit of PHP for everyone here in #haskell: http://3v4l.org/XXbtf
19:48:39 <Iceland_jack> ski: Also with map which would be map, zipWith, zipWith3, … depending on the arity: don't get me wrong I'd love a nice solution!
19:48:49 <Iceland_jack> Maybe if we make it dependently typed…
19:49:44 <lispy> HugoDaniel: haha. Not really relevant here (better in #haskell-blah) but hilarious none the less.
19:50:05 <HugoDaniel> yeah, sry for that :)
19:50:48 <NickHu> ski: I thought it bound the value of the action to a
19:50:56 <NickHu> Getting rid of the IO part
19:51:08 <ski> there is no "Getting rid of the IO part"
19:51:25 <rck> Iceland_jack: I'm mostly ignorant on typed racket's type system but I'm curious what you don't like about it?
19:51:36 <ski> there is "specifying the sequencing of I/O parts, and specifying that latter parts may depend on results of former parts"
19:51:38 <rck> IO is like the clap
19:52:49 <NickHu> Is this more correct then? http://puu.sh/55izO.hs
19:53:33 <ski> NickHu : `do x <- someIOAction; ..x..' represents the `IO'-action that when executed will : (a) execute the `IO'-action `someIOAction', naming the result `x', then (b) execute the `IO'-action `..x..', and finally provide the result of executing that action as the result of executing the whole `do x <- someIOAction; ..x..' action
19:54:40 <ski> NickHu : no, if you want your `testIO' to sensibly use the `IO'-action, then it *must* have `IO' in its return type
19:55:03 <NickHu> How can I just extract the result then?
19:55:14 <ski> (an example of not sensibly using it is ignoring it. another is to evaluate it (but still not *execute* it))
19:55:45 <ski> NickHu : you can't. (and you shouldn't, since then the program wouldn't know in which order to sequence your I/O operations wrt each other)
19:56:13 <ski> NickHu : you can't "get things out of `IO'". instead you should "get other things *into* `IO'"
19:57:17 <ski> NickHu : .. without knowing more about what talk you're *really* attempting to do, it's hard to be more clear than this
19:58:23 <ski> Iceland_jack : `(: map (-> (-> (a ...) b) (-> ((list a) ...) (list b))))', perhaps (the `...'s are literal)
19:58:50 <NickHu> Sorry, I'm trying to get the data from pixbufNewFromFile to pixbufFill from here: http://hackage.haskell.org/package/gtk-0.12.4/docs/Graphics-UI-Gtk-Gdk-Pixbuf.html
19:58:54 <ski> sorry, s/talk/task/
19:59:30 <ski>   pixbufNewFromFile :: FilePath -> IO Pixbuf
19:59:31 <ski>   pixbufFill :: Pixbuf -> Word8 -> Word8 -> Word8 -> Word8 -> IO ()
19:59:35 <ski> mhm
19:59:38 <ski> so, something like
19:59:38 <Iceland_jack> ski: Fair enough, one might have one type signature for each definition as well
19:59:47 <Iceland_jack> but it looks fairly noisy
20:00:21 <Iceland_jack> My idea was to drop the ∶ for types and use dictionaries with Clojure syntax
20:00:35 <Iceland_jack> but I dunno, I don't think it would play well with currying
20:00:54 <ski>   do ...
20:01:03 <ski>      myPixbuf <- pixbufNewFromFile "/tmp/icons/pacman.xpm"
20:01:09 <ski>      ...
20:01:20 <ski>      pixbufFill myPixbuf red green blue alpha
20:01:22 <ski>      ...
20:01:32 <lykos> hey everyone, quick question about show instances
20:01:38 <lykos> I'm using the Data.Unique library
20:01:48 <lykos> and need to have a show instance of it
20:01:54 <ski> NickHu : and this whole thing would have a type `IO Something', where `Something' comes from the last command in the second `...' there
20:02:13 <lykos> currently I have this: instance Show Unique where   show _ = "???"
20:02:23 <Iceland_jack> lykos: instance Show Unique where show (Unique int) = show int ?
20:02:33 <ski> NickHu : it would become `SomeArgument -> IO Something', in case you defined `myFunction someArgument = ..the above `do' expression..'
20:02:48 <Iceland_jack> lykos: http://hackage.haskell.org/package/base-4.3.1.0/docs/src/Data-Unique.html this is the definition of Unique
20:03:01 <Iceland_jack> It's just a newtype
20:03:12 <ski> (iow, `myFunction' would get the type `SomeArgument -> IO Something' in that case. the `do' expression still of course would have tupe `IO Something')
20:03:22 <ski> NickHu : does this help ?
20:03:39 <ski> (er, s/second/last/)
20:04:22 <lykos> Okay, thanks. I just wasn't sure if Unique was refering to the type constructor or the actual variable for the type
20:04:33 <NickHu> ski: Yes, kind of, I'm a bit sleep deprived at the moment though. Am I correct in assuming that myPixbuf is of type Pixbuf and not IO Pixbuf?
20:04:52 <Iceland_jack> NickHu: Yes
20:05:25 * hackagebot monoid-subclasses 0.3.4 - Subclasses of Monoid  http://hackage.haskell.org/package/monoid-subclasses-0.3.4 (MarioBlazevic)
20:05:30 <triliyn> Iceland_jack: the constructor isn't exported, is it? I thought you'd have to say Unique(Unique) in the export list to do that
20:05:52 <ricree> anyone know where +>> is defined? I was reading through the Pipes source, and it shows up, but neither Hoogle nor lambdabot recognize it
20:05:58 <Iceland_jack> triliyn: Ah good point, yes you're right
20:06:15 <ski> NickHu : yes
20:06:25 <triliyn> lykos: you can't pattern match on Uniques since the constructor isn't exported, but you can get an integer with this hashUnique function
20:06:28 <triliyn> Which you can then show
20:07:18 <lykos> Iceland_jack: That's where I was confused on
20:07:30 <lykos> triliyn: How would I do that in this case?
20:07:56 <triliyn> lykos: instance Show Unique where show u = show (hashUnique u)
20:08:00 <Iceland_jack> lykos: I guess you can do: show = show ∘ hashUnique
20:08:05 <ski> NickHu : think of `do myPixbuf <- ...; ..myPixbuf..' as "plumbing" together two `IO'-actions, one which will produce a `Pixbuf' when executed, and one which will consume (as a function input) a `Pixbuf' so as to compute an `IO'-action (possibly depending on that `Pixbuf')
20:08:06 <triliyn> Or show = show . hashUnique if you prefer
20:08:19 <lykos> Ah, I get it know
20:08:21 <lykos> now*
20:08:26 <Bayushi> I'm having trouble understanding why (last .) . take does what it does.  Anyone able to explain?
20:08:36 <lykos> I was unsure of the syntax of creating an instance
20:08:41 <lykos> makes perfect sense now
20:08:43 <NickHu> ski: Ah, thanks, I managed to get it working
20:08:43 <Iceland_jack> Bayushi: You should never really write (f .) . … in code
20:09:00 <NickHu> Unfortunately pixbufFill doesn't do what I thought it did...
20:09:06 <Iceland_jack> but '(f .) . g' means: \a b -> f (g a b)
20:09:15 <ski> NickHu : the actual passing of the computed `Pixbuf' from the first to the second will only happen when execution starts, which only happens because the system starts executing `main :: IO ()' (which conceptually happens *after* it has evaluated it, iow determined *what* to do -- in practice the two parts, evaluation and execution, are interleaved)
20:09:27 <Iceland_jack> Bayushi:
20:09:27 <Iceland_jack> @unpl (f .) . g
20:09:27 <lambdabot> (\ d i -> f (g d i))
20:09:54 * Iceland_jack finds composition sections horribly ugly
20:10:10 <Bayushi> Iceland_jack: Yes, I realized that's what it ended up doing eventually, but I have no understanding at all of why it works
20:10:52 <ski> NickHu : any `IO'-action that won't eventually become part of the big `main' `IO'-action simply won't be executed. so if we had `testIO :: IO Pixbuf -> Pixbuf', then we could already tell that any `IO'-action passed to this function won't get executed (since the function doesn't return an `IO'-action which could be ultimately incorporated into `main')
20:10:56 <Iceland_jack> Bayushi:
20:10:56 <Iceland_jack> :t ((?f .) . ?g) 'a'
20:10:56 <lambdabot> (?f::b -> c, ?g::Char -> a -> b) => a -> c
20:11:06 <Iceland_jack> Is the same as:
20:11:06 <Iceland_jack> :t (?f .) (?g 'a')
20:11:07 <lambdabot> (?f::b -> c, ?g::Char -> a -> b) => a -> c
20:11:39 <triliyn> Baushi: whenever you have f . last, that thing represents a function that passes its argument to last and then passes the result of that to f
20:11:39 <ski> (NickHu : of course, if the passed `IO-action is also in some other way incorporated into `main', it could get executed anyway. i was thinking about the case where it's only used by passing it to `testIO')
20:11:51 <HugoDaniel> leaving, sorry for the conduits bashing, ill read the overview tomorrow with ease and make a better informed opinion
20:11:56 <sshine> has anyone used pandoc with syntax-highlighted Standard ML code snippets?
20:12:15 <Bayushi> Iceland_jack: For some reason I was being stupid and getting my arguments out of order. That helps, thanks.
20:12:23 <triliyn> *take . last
20:12:24 <sshine> and... when I do 'cabal install pandoc', it complains that pandoc-1.11 will be broken by this. well, I'm installing a new version, so yeah!
20:12:41 <triliyn> **f . take
20:12:49 <triliyn> Wow, I'm making lots of mistakes
20:13:06 <NickHu> Can anyone guess what pixbufRenderPixmapAndMaskForColormapSource is supposed to do from this? http://hackage.haskell.org/package/gtk-0.12.4/docs/Graphics-UI-Gtk-Gdk-Pixbuf.html
20:13:12 <ski> @type (?f .: ?g) 'a'
20:13:13 <lambdabot> (?f::b -> c, ?g::Char -> a1 -> b) => a1 -> c
20:13:24 <ricree> In case anyone else ever wondered about my question from a few minutes ago: +>> is defined in Pipes.Core
20:13:27 <triliyn> but anyway, I guess Iceland_jack explained what I was trying to explain?
20:13:29 <ski> @type ?f . ?g 'a'
20:13:30 <lambdabot> (?f::b -> c, ?g::Char -> a -> b) => a -> c
20:13:35 <NickHu> I'm basically trying to draw an image with a colour swapped out for a different one
20:14:04 <ski> Iceland_jack : how about `.:' then ?
20:14:10 <Iceland_jack> ski: What about it?
20:14:13 <ski> Bayushi ^
20:14:18 <ski> Iceland_jack : do you find it less ugly ?
20:14:34 <Iceland_jack> I do but personally I would just write out the expression
20:15:15 <Bayushi> ski: is .: a seperate operator or are we just using cons for some reason?
20:15:16 <Iceland_jack> It's good to be aware of stuff like '(f .) . g' and 'f .: g' should you encounter it but I would not introduce it into my own code
20:15:37 <lykos> clear code > obscured code that saves a few chars
20:15:42 <Iceland_jack> Yes exactly
20:16:18 <ski> Bayushi : separate, defined by `(.:) = (.) . (.)'
20:16:18 <Iceland_jack> I've also said this here before, but a lot of things are ‘clear’ in isolation but put 5 ‘clear’ things into an expression and it can be horribly unclear
20:16:43 <Iceland_jack> So it goes: ((f .) . g) x y ⇒ ((f .) (g x)) y ⇒ (f . g x) y ⇒ f (g x y)
20:16:45 <ski> (or by `(f .: g) a b = f (g a b)', if you prefer)
20:16:49 <lykos> That's fair. That's why I tend to shorten expressions with uility functions
20:16:52 <Bayushi> ski: is it primitive? :t (.:) in ghci gets me nothing
20:16:52 <lykos> utility*
20:17:13 <ski> Bayushi : not primitive. you can define it yourself if you like it
20:17:25 <ski> Bayushi : `(.::) = (.) . (.) . (.)', &c.
20:17:39 <Iceland_jack> lykos: Yes that can be very nice, I believe I'm rather conservative compared to most people on #haskell when it comes to this though
20:17:44 <Bayushi> ski: Ah, fair enough.  Thanks.
20:18:27 <ski> Bayushi : the number of dots are supposed to be equal. also the number of characters (`.' and `:'s) are supposed to say how many arguments are "passed on" to the right argument function
20:19:59 <oio> > let lol = show in lol 1
20:20:00 <lambdabot>   "1"
20:20:07 <ski> hello oio
20:20:22 <oio> hi
20:20:31 <lykos> I enjoy clever syntax, but eventually it becomes unwieldy. I like to learn it and enjoy the theory behind it, but I prefer to make my own code more clear.
20:20:53 <Iceland_jack> Yes that mirrors my thoughts very well
20:21:21 <Iceland_jack> I might use ‘join (+)’ when testing it in ghci but I would never use it in actual code
20:21:27 <oio> > let lol = 2 + 5 where 2 + 5 =0 in lol
20:21:28 <lambdabot>   0
20:21:35 <lykos> :t join
20:21:37 <lambdabot> Monad m => m (m a) -> m a
20:21:55 <Iceland_jack> :t join replicate
20:21:56 <lambdabot> Int -> [Int]
20:22:01 <Iceland_jack> > map (join replicate) [1..]
20:22:02 <lambdabot>   [[1],[2,2],[3,3,3],[4,4,4,4],[5,5,5,5,5],[6,6,6,6,6,6],[7,7,7,7,7,7,7],[8,8...
20:22:41 <Iceland_jack> > map (\a -> replicate a a) [1..]
20:22:41 <ski> NickHu : not sure whether `pixbufRenderPixmapAndMaskForColormap' will do what you want
20:22:44 <lambdabot>   [[1],[2,2],[3,3,3],[4,4,4,4],[5,5,5,5,5],[6,6,6,6,6,6],[7,7,7,7,7,7,7],[8,8...
20:23:38 <oio> redifeine mathmatics
20:23:38 <lykos> map (\a  -> replicate (5-a)) [1..5]
20:23:43 <lykos> > map (\a  -> replicate (5-a)) [1..5]
20:23:44 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
20:23:45 <lambdabot>    arising from a use ...
20:23:46 <ski> lykos : .. and stuff like  sortBy (comparing length `mappend` compare)  ?
20:23:51 <lykos> > map (\a  -> replicate (5-a) a) [1..5]
20:23:53 <lambdabot>   [[1,1,1,1],[2,2,2],[3,3],[4],[]]
20:23:55 <NickHu> ski: I'm not entirely sure what the terminology for what I want to do is
20:23:56 <ski> oio : why ?
20:24:01 <oio> > let lol = 3 + 5 where 3 + 5 = 0 in lol
20:24:03 <lambdabot>   0
20:24:23 <NickHu> Basically I'm trying to replicate dzen's ^i stuff, whereby it can render icons in different colors
20:24:46 * ski doesnät know what that is
20:24:52 <NickHu> Although saying that, I haven't used dzen so I don't know it it actually does change the color
20:24:56 <ski> s/ä/'/
20:25:21 <lykos> ski: I'd tend to wrap that in a function all by itself, with a clear type signature and comment
20:25:24 <NickHu> I have XPM icons, and they're black, I want a way of specifying in code what color black should be replaced with
20:25:30 <ski> (is anything like `activeIcon' in XTerm ?)
20:25:38 <lykos> preferably, I'd have it in a separate module I included for my main program
20:25:40 <NickHu> ski: I'm not sure
20:26:40 <lykos> I'm still trying to find my coding style, but haskell's composition lends so well towards abstraction. Clever syntax is nice, but I prefer to have it only in utility functions, then clearer functions to tie it all together
20:27:21 <lykos> is there some image pastebin like lpaste?
20:27:31 <lykos> I want to show you guys a quick screenshot of what I'm working on :)
20:27:32 <carter> imgur.com
20:30:46 <ellipsis_> hello
20:30:52 <Iceland_jack> hi
20:31:00 <ellipsis_> I'm trying to install Harpy and I'm getting a compile error from cabal
20:31:12 <lykos> http://imgur.com/4EGQ7FE
20:31:34 <ellipsis_> http://lpaste.net/95050
20:31:39 <Iceland_jack> lykos: That looks cool :)
20:32:01 <ellipsis_> lykos: Neat - what are you using for the graphics?
20:32:07 <lykos> I move the red circle with the wasd or arrow keys, and when I click on the screen it fires where I click. The cannon barrel always aims at me (angle is shown on screen in radians) and it follows me
20:32:20 <lykos> and wherever I point on the screen, my players cannon points towards it
20:32:28 <lykos> I'm using gloss for the graphics and event handling
20:33:23 <lykos> oh, and the cannon shoots once a second at me. I also made it so the missles can gracefully seek me(slowly turn towards my location when I move)
20:33:28 <triliyn> lykos: that's awesome. Can I see your code?
20:35:18 <lykos> sure, I'll message you
20:35:40 <triliyn> Thanks :3
20:38:37 <rck> I'm using a library that doesn't export a data constructor. it does provide a function that returns a value of that type. if I use that type in a where clause and try to add a type annotation ghc yells, which makes sense. if I don't add the annotation the where, and my program, work correctly. should I just not annotate here?
20:39:48 <Cale> rck: Which library? It sounds like it didn't export the *type* constructor
20:40:07 <Cale> Also, which error are you getting?
20:40:24 <rck> Cale: correct, thanks, and it's just some custom one I wrote to screw around
20:40:47 <rck> GHC complains that it can't find the type constructor
20:41:54 <rck> "not in scope"
20:42:46 <Cale> rck: Even if you don't want to export the data constructors for a type, if you're exporting functions which operate on it, you should export the type itself.
20:44:26 <rck> that does make sense
20:44:58 <rck> I'm still curious why the function works though? the compiler has access to magic via inference that I can't describe with annotations?
20:45:39 <Cale> Yeah, the compiler will happily infer the types even if you can't write them because the names you need aren't in scope.
20:45:50 <rck> interesting
20:45:56 <rck> thanks for the help
20:47:27 <Cale> There are some more subtle cases too, where in Haskell 98 it's impossible to write type signatures for things in where clauses, because their type would need to refer to type variables bound in the parent's type. (The ScopedTypeVariables extension fixes that though.)
20:47:42 <Cale> (But even in Haskell 98, you can write the definition, you just can't annotate it)
20:50:27 <vonDraco> is it possible to somehow do recursion with lambda expressions?
20:51:06 <johnw> vonDraco: fix $ \loop x -> loop x
20:51:12 <Iceland_jack> You can use ‘fix’, some other languages (namely Lisps) allow crazy stuff like anaphoric macros
20:51:20 <Iceland_jack> but in general no
20:51:22 <johnw> vonDraco: fix $ \loop x -> if x == 0 then 0 else loop (pred x)
20:51:44 <johnw> Iceland_jack: why do you say that?
20:51:49 <Iceland_jack> Say what?
20:51:52 <johnw> the Y-combinator allows recursion using only lambda expressions
20:52:18 <Iceland_jack> So the Y-combinator is not typeable in Haskell
20:52:28 <lispy> > fix $ \fibs -> 0 : 1 : zipWith (+) fibs (tail fibs) -- my favorite fix example
20:52:29 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
20:52:48 <lispy> Iceland_jack: yes, but we have something similar that does type
20:52:49 <johnw> ah, i see
20:53:13 <Iceland_jack> but I believe vonDraco was asking about actually giving the lambda expressions a name like: (alambda self ((x)) …)
20:53:22 <vonDraco> umm
20:53:24 <lispy> Using one of two tricks: recursion in a type or recursion from let
20:53:49 <Iceland_jack> if vonDraco is OK with the fix solution then I misunderstood what they wanted
20:53:50 <lispy> (maybe there is a third trick?)
20:54:05 <vonDraco> i was playing with an ifinite recurssion thing ( iterate f x = x : map f (iterate f x) )
20:54:16 <monochrom> it is going to be recursion in syntax or recursion in semantics :)
20:54:36 <vonDraco> and I tried making that into a lambda expression, (\f x -> x : map f (   )
20:54:42 <vonDraco> and i don't know where to go on from there
20:54:57 <Iceland_jack> vonDraco: You can use fix for that
20:55:01 <Iceland_jack> if you really care
20:55:26 <lispy> hmm.. would iterate f x = let y = iterate f x in x : map f y, have better space behavior?
20:55:27 <vonDraco> ah, i didn't see that
20:55:32 * hackagebot yamemo 0.4.0.3 - Simple memoisation function  http://hackage.haskell.org/package/yamemo-0.4.0.3 (NobuoYamashita)
20:55:35 <Iceland_jack> Just add a new argument to the anonymous function which will refer to the function itself
20:55:48 <lispy> (I'm trying to figure out of sharing the recursion matters)
20:56:33 <Iceland_jack> > fix (\ego f x -> x : map f (ego f x)) (+1) 0
20:56:35 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
20:56:51 <Iceland_jack> vonDraco: ↑ is that solution relevant to what you want?
20:57:06 <Iceland_jack> > let myIterate = fix (\ego f x -> x : map f (ego f x)) in myIterate (+1) 0
20:57:07 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
20:57:38 <vonDraco> yes! that is, thanks
20:58:24 <Iceland_jack> But a more ‘normal’ way of giving a name to anonymous functions is by using let or where or just making them named to begin with
20:58:24 <ricree> When using Pipes, is there a way for a Consumer to know that it's reached the end of a stream (via EOF, for example)?
20:58:34 <moops> is there any way to simplify this? any' :: (a -> Bool) -> [a] -> Bool ; any' f list = or' (map f list)
20:58:55 <Iceland_jack> moops: Do you mean simplify: \f list -> or' (map f list)?
20:59:14 <ricree> Or do I have to write my producers so that they pass the eof down the line somehow?
20:59:30 <Iceland_jack> This was just being discussed earlier :) and I mentioned my distain for it but you can use:
20:59:30 <Iceland_jack>     any' = (or' .) . map
20:59:30 <Iceland_jack> or
20:59:30 <Iceland_jack>     any' = or' .: map
20:59:59 <moops> you think its clearest as is then?
21:00:09 <Iceland_jack> moops: Yes.
21:00:17 <moops> okay, thanks :)
21:00:20 <monochrom> "any' f = or' . map f" looks the best to me
21:00:31 <Iceland_jack> oh right, monochrom is right actually
21:00:39 <Iceland_jack> I was too obsessed with keeping it point-free
21:00:48 <moops> that looks good too
21:00:58 <Iceland_jack> I'd write:
21:00:59 <Iceland_jack>     any' f = or' . map f
21:00:59 <Iceland_jack> or
21:01:02 <Iceland_jack>     any' f xs = or' (map f xs)
21:01:16 <Iceland_jack> Or better yet, not write it at all since it already exists
21:01:16 <Iceland_jack> @src any
21:01:16 <Iceland_jack> :)
21:01:16 <lambdabot> any p =  or . map p
21:01:28 <moops> hehe
21:02:02 <moops> im just going through LYAHFGG and trying to implement stuff right after the author explains it
21:02:18 <monochrom> any' f = foldr (\x y -> f x || y) False.  maybe now simplify (\x y -> f x || y)
21:02:31 <Iceland_jack> moops: That's a very good strategy
21:03:59 <moops> any' f = foldr ((||) . f) False ?
21:04:24 <monochrom> @pl (\x y -> f x || y)
21:04:25 <lambdabot> (||) . f
21:04:32 <monochrom> you're smart :)
21:04:33 <moops> cool :)
21:17:01 <Iceland_jack> @unpl (||) . f
21:17:01 <lambdabot> (\ c -> (||) (f c))
21:25:55 <lispy> @tell HugoDaniel I tweeted your PHP February example and people love it :)
21:25:56 <lambdabot> Consider it noted.
21:26:19 <carter> lispy: what link?
21:26:42 <Iceland_jack> <HugoDaniel> here is a bit of PHP for everyone here in #haskell: http://3v4l.org/XXbtf
21:27:55 <edwardk> its an awesome example
21:28:23 <moops> haha
21:28:28 <ion> :-D
21:35:31 <carter> what does the hiphopvm say
21:39:29 <Twey> Why does that happen?
21:39:54 <Twey> I guess in ‘January’ the day underflows, but I have no explanation for ‘December’
21:41:39 <lispy> Twey: if you follow the link that says, "based on 0qsoJ" you get a hint
21:42:44 <carter> ?
21:45:52 <Twey> Aha
21:46:06 <carter> ?
21:59:29 <ski> Iceland_jack : .. hm, haven't seen that called anaphoric lambda before
22:00:53 <Iceland_jack> ski: Stuff like (alambda (n) (if (= n 0) 1 (* n (self (1- n))))) are examples of it
22:01:10 <Iceland_jack> it's been quite some time since I was into that, back in Common Lisp
22:01:21 <lispy> ski: I think the name comes from here: http://en.wikipedia.org/wiki/Anaphoric_macro
22:01:38 * Iceland_jack wrote that article…
22:01:48 <lispy> Iceland_jack: nice!
22:01:58 <Iceland_jack> Someone had to!
22:02:03 <ski> i know about anaphoric `if'
22:02:30 <Iceland_jack> Truth be told I never found anaphoric macros useful but the idea was cute
22:03:27 <Iceland_jack> Very un-Haskell like in that way, implicitely capturing an identifier
22:04:13 <ski> it's unhygienic
22:04:16 <triliyn> Iceland_jack: I actually found that a lot of the things I liked to use anaphoric macros for worked better with Maybe
22:04:30 <Iceland_jack> triliyn: Example?
22:04:30 <triliyn> (awhen (get-hash key table) (foo it))
22:04:32 <triliyn> ==>
22:04:33 <Iceland_jack> ah right
22:04:40 <triliyn> lookup key table >>= foo
22:04:44 <Iceland_jack> ski: (sometimes it's okay to get a little dirty ;])
22:05:11 <Iceland_jack> triliyn: Yes I see, I hadn't thought of that
22:05:42 <ski> Iceland_jack : seen Eli Barzilay's "Dirty Looking Hygiene" in 2008-02-23 at <http://blog.racket-lang.org/2008/02/dirty-looking-hygiene.html> ?
22:05:57 <Iceland_jack> No
22:06:00 <ski> (about dynamic scope at the macro level)
22:06:39 <Iceland_jack> There is so much messiness when it comes to macros, especially in CL
22:07:20 <ski> also <http://stackoverflow.com/questions/19664993/is-it-possible-to-implement-common-lisps-macro-system-in-scheme/19670813#19670813> might be interesting (though perhaps you already know most of its contents. it has a link to a later Barzilay paper, though)
22:08:40 <Iceland_jack> That's a very interesting comment
22:09:36 <ski> triliyn : also `and-let*', Scheme Request For Implementation 2, "AND-LET*: an AND with local bindings, a guarded LET* special form" by Oleg Kiselyov in 1999-03 at <http://srfi.schemers.org/srfi-2/srfi-2.html>
22:18:34 <structuralist> What's the recommended way to generate fresh/unique identifiers? Someone told me about concurrent-supply, which looks nice. Are there other more standard ones?
22:19:05 <napping> Data.Unique is another
22:20:38 <napping> Drawing IDs is in IO and it's probably less concurrent, but it's in base
22:24:30 <Ralith> structuralist: usually I just use a trivial state monad
22:26:59 <edwardk> concurrent-supply is something i wrote mostly so that i could generate globally unique ids across multiple threads without collision and without paying the price of a full blocking read on an TVar like you do in Data.Unique
22:27:39 <edwardk> (at least it is back to being an IORef again)
22:28:00 <edwardk> for a while it couldn't be used from unsafePerformIO
22:45:54 <Twey> structuralist: [0 ..]
22:46:17 <Twey> Oh, across threads
22:50:24 <Iceland_jack> Twey: ;P
23:05:49 * hackagebot free 4.2 - Monads for free  http://hackage.haskell.org/package/free-4.2 (EdwardKmett)
23:06:22 <zomg> What, I can have monads for free?!
23:06:30 <zomg> And I've been paying licensing fees to Microsoft all this time!
23:06:35 <edwardk> for a limited time only
23:08:44 <Iceland_jack> What's the catch?
23:09:01 <edwardk> no catch, catch is in exceptions
23:09:13 <Iceland_jack> ah I see :)
23:13:41 <dmj`> finally got that file upload working
23:20:51 * hackagebot yesod-platform 1.2.4.4 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.4.4 (MichaelSnoyman)
23:29:19 <Draconis> does anyone use sublime text for their haskell development?
23:31:37 <nisstyre> Draconis: not me, I prefer vim
23:33:20 <jfeltz> http://www.reddit.com/r/haskell/comments/vqhke/is_anybody_using_sublime_text_for_their_haskell/
23:34:06 <nisstyre> Draconis: keep in mind it is closed source
23:35:05 <Draconis> all emacs users here?
23:35:14 <David> nope. vimmer.
23:35:18 <Iceland_jack> Draconis: The ones who count :)
23:35:38 <Draconis> heh I was trying to find good integration with the repl with sublime
23:35:46 <Draconis> auto reload, or just shortcuts to launch it
23:35:50 <Draconis> guess it won't work
23:35:53 <pharaun> anyone here with experience with installing a private copy of lpaste? i got postgres and everything else (i think) working but its crashing with fd buffer closed errors
23:36:02 <pharaun> and i'm not sure how to start to track that down
23:36:03 <Draconis> well it probably will-- too lazy to research. Not finding results ;)
23:37:46 <jfeltz> sigh, too many hipster editors these days attracting kids, vim/emacs is the real deal
23:38:23 <nstdloop> I need your help guys. What's the coolest thing about Haskell?
23:38:34 <arkeet> the community!
23:38:35 <Iceland_jack> nstdloop: How much time have you got? :)
23:38:37 <nstdloop> Could be some code snippet or little project that demonstrates how awesome Haskell is
23:38:53 <pharaun> xmonad imho, but there's many other examples
23:39:24 <nstdloop> arkeet: I kind of like that answer. People are much more helpful here than on many other channels.
23:39:29 <Iceland_jack> So there are a lot of things about Haskell that are very cool but don't show in small examples (and that many others would consider cons), such as immutability or purity
23:39:56 <nstdloop> iceland_jack: Ya, that's true. I just wrote a long answer on Quora about how functional programming is black-magic
23:40:10 <David> nstdloop: what I like about haskell is the concision. Short snippets of code that do a lot appeal to me.
23:40:10 <Iceland_jack> Why is it black magic?
23:40:13 <nstdloop> but I didn't include almost any code because it doesn't show.
23:40:21 <David> parsec stuff, for instance
23:40:55 <nstdloop> iceland_jack: http://www.quora.com/Computer-Programming/What-are-some-programming-styles-other-than-Object-oriented
23:40:57 <Iceland_jack> Another cool thing about Haskell is that it allows for more abstractions than some other languages, standard stuff like Functor, Monoid, Monad, Applicative, … are some of the more useful examples
23:41:29 <edwardk> i have to second the 'the community' response. I was lured in by the language, but the community is what made me stick around.
23:41:30 <jfeltz> nstdloop: a type system (esp sum types, ADT's) that blew me away it's totally different from most other languages out there, and this is after using those for decades :) monads are pretty amazing as well, but take longer to realize
23:41:31 <David> On the more estoeric side of things, I recall there was a project somewhere that did actual computation using haskell's type system.
23:41:33 <Iceland_jack> But again, those would probably not be considered pros by someone unfamiliar with Haskell
23:41:49 <Iceland_jack> David: Sure, it's not very hard to do
23:42:08 <nstdloop> jfletz: I really wanted to talk about monads but they are so hard to explain and never seem that cool until you use them
23:42:14 <edwardk> if it wasn't for the very warm community i likely wouldn't have stuck it out to see what all the hubbub was about regarding the language iself
23:42:21 <edwardk> er itself
23:42:26 <Iceland_jack> Indeed, the community is excellent
23:42:35 <David> Iceland_jack: true, in haskell it's not too hard. You'll never going to find that in the likes of C or Java though, and obviously not in dynamically typed languages
23:43:07 <Iceland_jack> David: I'm not sure if computation at the type-level is something that's going to attract people to Haskell :)
23:43:07 <edwardk> now its the type system for me, in that haskell has a type system that sits at almost exactly the right power to weight ratio for me
23:43:26 <nstdloop> What are some of the coolest projects done in haskell
23:43:34 <nstdloop> like little stuff
23:43:42 <nstdloop> thats explainable and uses some of the cooler parts of haskell
23:44:05 <David> lens is pretty cool, but I don't think it would be of much appeal to a non-hs audience
23:44:20 <David> as I said earlier, look into parsec
23:44:30 <Iceland_jack> Parsec is very neat, QuickCheck definitely as well
23:44:32 <edwardk> pandoc, darcs, snap, yesod, lens doesn't qualify on the 'little stuff' side, parsec is amazing, it changed the way i think of writing languages
23:44:47 <edwardk> bound is very convenient for writing little languages
23:44:52 <David> it's a very practical parser and has a lot of things you don't see in bison or the like
23:44:54 <mm_freak_> Iceland_jack: mindbending things do attract people, if they have a sense for elegance
23:44:59 <edwardk> free monads make it easy to write little EDSLs as well
23:45:10 <Iceland_jack> mm_freak_: Sometimes you need some experience with them to see the point though
23:45:11 <David> and it demonstrates a lot of cool features too (applicative parsing, for instance)
23:45:16 <Iceland_jack> I certainly did
23:45:18 <mm_freak_> when i'm asked why i like haskell, my first answer is:  "because it thinks for me"
23:45:22 <edwardk> llvm-general and the like make it easy to do code gen directly from your libraries for some doman specific little language you want
23:45:36 <jfeltz> nstdloop: clay, fay, blaze html (these are game changers for web-dev :)
23:46:28 <Iceland_jack> oh nstdloop, Feldspar is definitely interesting
23:46:28 <Iceland_jack> http://hackage.haskell.org/package/feldspar-language
23:46:42 <nstdloop> blaze html looks cool
23:46:46 <Iceland_jack> Basically embeds a language inside Haskell (EDSL) which compiles to C
23:46:50 <nstdloop> something that people outside of haskell would find cool
23:46:59 <nstdloop> oh that's cool too
23:47:02 <pharaun> haha all i can really say is i second basically everything edwardk is saying, he's saying it much better than i am :D
23:47:05 <mm_freak_> nstdloop: darcs
23:47:13 <mm_freak_> it's a masterpiece of engineering
23:47:13 <David> speaking of haskell for web dev, which of the haskell js compilers would be most suitable for a javascript newbie to get to use quickly? fay, haste, or ghcjs?
23:47:32 <nisstyre> this is pretty cool, http://hackage.haskell.org/package/generic-deriving-1.5.0
23:47:42 <mm_freak_> David: GHCJS probably produces the best code, but haste also works
23:47:50 <mm_freak_> David: fay is not haskell, it's a subset
23:47:56 <adnap> Stop using JavaScript and do things server-side
23:48:01 <arkeet> adnap: =(
23:48:08 <edwardk> lets see, other things, ersatz and sbv make it easy to prove a property holds once and forall, the latter can be used to generate c code that provably satisfes properties. probably the single most compelling video i can point someone to regarding the practical aspects of haskell makes use of this tool
23:48:10 <mm_freak_> adnap: you can't stop using javascript today
23:48:14 <David> adnap: trying to make a game, server side isn't gonna cut it.
23:48:18 <Iceland_jack> lol @ telling people to stop using JavaScript
23:48:20 <arkeet> adnap: I heard you like latency.
23:48:25 <edwardk> https://vimeo.com/77164337
23:48:30 <adnap> I use NoScript
23:48:34 <David> mm_freak_: thanks, will wait for ghc7.8
23:48:48 <mm_freak_> David: it's already usable…  are you new to haskell?
23:48:49 <arkeet> adnap: that's just an argument against *mandatory* javascript.
23:48:53 <adnap> There's web sockets now
23:48:55 <edwardk> nstdloop: ^- that link is worth watching if you want to get a feel for 'why haskell matters' for writing real software
23:49:12 <nstdloop> thanks
23:49:33 <nstdloop> The fact that I could just drop in and get this many responses is also a testament to the community.
23:49:39 <David> mm_freak_: new-ish, yes. The github page says that you need to use vagrant to use it right now, and I don't want to fiddle with vms.
23:49:40 <adnap> I don't know why people want to make games for browsers. People want to make the browser an OS or something
23:49:41 <nstdloop> Haskell is good stuff.
23:49:53 <mm_freak_> David: ok, then i won't tell you that idris also has a javascript target =P
23:49:59 <edwardk> nstdloop: it has robots, computer vision, stream processing, embedded systems, pretty much everything
23:50:30 <mm_freak_> David: if you like haskell, you may find NixOS interesting, too…  it would allow you to have multiple haskell environments simultaneously
23:50:44 <David> thanks mm_freak_, will look into them
23:51:00 <edwardk> another good example of haskell is brent yorgey's diagrams library, which is damn sexy
23:51:04 <mm_freak_> David: idris is a different language…  more advanced that haskell, but still in its infancy
23:51:29 <mm_freak_> it's probably usable for some basic stuff, though
23:51:30 <David> dependent types... interesting.
23:51:41 <David> probably beyond what I'm looking for right now
23:51:41 <mm_freak_> David: i suggest learning haskell first
23:52:01 <David> mm_freak_: I went through lyah and rwh already, trying to cut my teeth on some real projects
23:52:10 <edwardk> nstdloop: http://www.fpcomplete.com/user/edwardk/cellular-automata/part-1  if you scroll to the bottom tere is a live code snippet that uses diagrams to generate an svg inside a custom web server, generating the entire cellular automaton and simulating it in ~60 lines of code
23:52:31 <mm_freak_> David: another book i highly recommend is this one:  http://chimera.labs.oreilly.com/books/1230000000929
23:52:39 <nisstyre> David: dependent types are basically types of expressions that depend on the value of something
23:52:47 <edwardk> that is a whole bunch of parts of the ecosystem all working together, lens, diagrams, comonads, memoization, yesod, etc.
23:52:50 <nisstyre> that makes it seem simpler than it really is
23:52:52 <nstdloop> edwardk: this language constantly surprises me
23:53:14 <mm_freak_> nisstyre: dependent types is actually a lot more than that
23:53:14 <edwardk> the thing i like about haskell is how well all the random little libraries just fit together and work
23:53:23 <mm_freak_> everything becomes first class, absolutely everything
23:53:25 <nisstyre> mm_freak_: that's the really basic idea
23:53:30 <mm_freak_> so types become function arguments
23:53:50 <David> thanks mm_freak_. nisstyre: is it like beefed-up polymorphism?
23:54:09 <mm_freak_> David: no, it's a simpler type system concept
23:54:19 <mm_freak_> but it's more powerful
23:54:19 <David> also, where would I look to find out about the more theoretical aspects of haskell's type system? Not sure where to start reading on the wiki.
23:54:35 <nisstyre> David: if you want to get a good feel for it I recommend reading some papers by Luca Cardelli (inventor of the ML language which is a predecessor of Haskell)
23:54:48 <nisstyre> he has several good papers on dependent type systems
23:55:15 <nisstyre> but you'll need to understand some jargon and ideas before you can read them
23:55:24 <David> this one? http://lucacardelli.name/Papers/TypeSystems.pdf
23:55:37 <mm_freak_> David: about haskell's type system, i suggest learning it by doing a real project
23:55:44 <mm_freak_> it's a practical type system
23:56:01 <nisstyre> David: this one is good, http://lucacardelli.name/Papers/PhaseDistinctions.A4.pdf
23:56:15 <nisstyre> and http://lucacardelli.name/Papers/Dependent%20Typechecking.US.pdf
23:56:24 <mm_freak_> if you hit bumps, replace "how do i do X" questions by "what would be the type of the function to do X"
23:56:57 <David> thank you very much guys
23:57:04 <David> I've got a reading queue for the next week now
23:57:19 <mm_freak_> David: you have to stop reading at some point
23:57:36 <nisstyre> the paper on phase distinctions actually gives a very lucid explanation in the first page or two
23:57:37 <mm_freak_> stop now and write a simple program, then continue
23:58:02 <David> true. I have too many projects on hand right now though... including writing a type system in C++ for homework. Hopefully that will give me some insight into how they work
23:58:08 <Shin-LaC> if I want to parse a text-based file format, what general method should I use? for example, I might have lines like "2 3 4" and I need to get three integers out of it
23:58:32 <mm_freak_> Shin-LaC: is all the syntax that simple?
23:58:51 <Shin-LaC> it depends
23:58:57 <David> Shin-LaC: if it's that simple you can read from the file and split by spaces/newlines
23:59:08 <David> and then map read over it
23:59:20 <Shin-LaC> so just map read | words . readLn ?
23:59:31 <mm_freak_> Shin-LaC: how large is the file?
23:59:53 <David> Shin-LaC: won't work, readLn returns an io monad
23:59:55 <Shin-LaC> mm_freak_: I'm not sure, but I don't think it's going to be too large
