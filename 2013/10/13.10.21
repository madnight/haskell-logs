00:00:02 <sopvop> wouldn't let look better?
00:04:25 <jle`> pretty sure you can't use where's like that though
00:04:48 <Twey> scshunt: ‘case’ has ‘where’ as well
00:04:59 <jle`> yeah, you should only be able to use them when declaring a function
00:05:07 <arkeet> where contains declarations, so yes you can nest wheres
00:05:19 <Twey> But no, the ‘where’ needs to go after the ‘do‘ block.
00:06:00 <jle`> yeah, the where is associated with the function declaration itself
00:06:05 <jle`> not with a statement in a do block
00:07:27 <jle`> in fact it's a little perverse that there are two separate syntax roles for 'let'
00:08:19 <jle`> that `let` has a special syntax meaning in the context of a do block separate from its normal non-do meaning
00:08:28 <lpaste> Twey annotated “whats wrong with the final return?” with “whats wrong with the final return? (annotation)” at http://lpaste.net/2757209188298915840#a94585
00:11:35 <identity> jle`: how is that exactly?
00:11:54 <wagle> i can relax now, the soft deadline is past
00:12:29 <Twey> identity: do let x = y; z   translates to   let x = y in z
00:12:29 <jle`> identity: well, 'normal' let doesn't really make sense without the accompanying 'in'
00:12:30 <identity> it all desugars to let .. in .. with bind, no?
00:13:02 <identity> Twey: ah, yeah.
00:13:04 <identity> i get it.
00:13:17 <Twey> It's not particularly inconsistent, but it's potentially confusing if you're not aware of it
00:13:29 <Twey> Especially since there's nothing equivalent for ‘where’, apparently
00:13:32 <identity> i think it's intuitive,
00:13:42 <identity> well, from an imperative perspective anyway
00:13:54 <identity> it's what you'd expect coming from an imperative language basically
00:14:16 <individual> I need to provide instance declarations for a set of types. The declarations are all the same. Can I do it without copy pasting a lot of code? I can't use default implementations
00:14:48 <Twey> identity: It's subtly different, though (no mutation, only works for pure values, bindings are recursive)
00:15:16 <identity> individual: foo = ...; instance Blah foo where bar = foo; instance Phartiphukborlz foo where baz = foo;
00:15:19 <identity> no?
00:15:38 <Twey> individual: You can make a type family, or use TH
00:15:44 <identity> or that.
00:16:08 <identity> hackagebot, noooooooooooo
00:16:09 <Twey> But probably you should just write the instances; the alternatives seem like more effort than they're worth
00:16:13 * hackagebot hmatrix-gsl-stats 0.2 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.2 (VivianMcPhail)
00:16:13 * hackagebot karakuri 0.1.1 - Good stateful automata  http://hackage.haskell.org/package/karakuri-0.1.1 (FumiakiKinoshita)
00:16:20 <identity> hackagebot: good boy
00:16:49 <individual> thanks Twey
00:17:01 <individual> identity's suggestion is what I was trying to avoid :)
00:17:25 <Twey> Sadly writing instances is not as convenient as it could be, because instances are second-class citizens
00:18:06 <Twey> If you have a *lot* of types and they're not semantically related in any way that warrants putting them in a type family, you might want to try the TH route
00:19:06 <individual> Twey: 11 is not a lot?
00:20:50 <lpaste> wagle pasted “does this compile for anyone?  why not?” at http://lpaste.net/6324667371487232000
00:22:37 <supki_> wagle:  where  is attached to function declaration
00:22:52 <supki_> i.e. to dump_clauses
00:23:50 <Twey> individual: Probably not
00:24:12 <wagle> oh..  thats lame, I think
00:24:36 <wagle> i was getting away with it before because I was tail-recursive
00:24:52 <Twey> wagle: http://lpaste.net/2757209188298915840
00:24:59 <Twey> &c.
00:28:49 <lpaste> wagle pasted “this even works, bletch” at http://lpaste.net/4637141894453788672
00:37:22 <wagle> Twey: thanks
00:45:04 <Twey> ‘The purpose’ of ‘where’ (as opposed to ‘let’) is that it scopes over a whole definition, including guards.  So it wouldn't be useful to have it attach to the last statement of a ‘do’ block instead.
01:16:14 * hackagebot regex-applicative 0.3.0.1 - Regex-based parsing with applicative interface  http://hackage.haskell.org/package/regex-applicative-0.3.0.1 (RomanCheplyaka)
01:24:49 <Ghoul_> I wish there was something like Data.Graph that didn't want to order keys and stuff
01:25:25 <Ghoul_> Might just be me, but Data.Graph is great -- it just feels like it doesn't have enough love to be containers. There's only a handful of functions there and the documentation is a bit meh
01:25:37 <Ghoul_> *to be in
01:29:36 <jle`> individual: you could try to submit a patch to add a deriving extension to ghc
01:34:02 <mr-> Ghoul_: Yeah.. already the interface looks weird. dfs, dff, scc, bcc ..
01:34:23 <Ghoul_> mr-: I don't really know what any of those mean. There isn't any huge explanation or anything :S
01:34:46 <cinimod> With -O2 my program runs in 6M(!) (according to Activity Monitor - I havent't tried profiling yet) but *without* -O2 I get a spaceleak
01:34:53 <cinimod> Is that a bug in ghc?
01:35:01 <Ghoul_> Also, it's missing functions for merging graphs and stuff like that - the type of stuff Map has. It kind of looks a little bit like a hack where the user is expected to manually merge vertices and stuff
01:35:57 <zw01> does GHC have a way to use '-e' with expressions involving stuff imported from modules?
01:36:45 <zw01> (trying to do some direct-from-shell one-liners a la 'sh -c', 'python -c', etc.)
01:37:03 <cinimod> Ghoul_: dfs = depth first search, dff = depth first forest, scc = strongly connected components
01:37:06 <mr-> Ghoul_: I aggree, it does not compare to Data.Set or Data.Map interface- and documentation-wise
01:41:10 <Ghoul_> cinimod: is there anything there to do a dependency-first search
01:41:34 <Ghoul_> like what stronglyConnCompR does, except without the added complexity of sorting by key
01:41:50 <cinimod> Ghoul_: I don't what that is - sorry
01:42:06 <cinimod> Ghoul_: know
01:42:49 <Ghoul_> Uh, yeah "dependency-first" doesn't mean much, I made it up hoping it conveyed something
01:42:50 <cinimod> Ghoul_: I don't know the package - just enough graph theory to be dangerous :-)
01:42:56 <Ghoul_> oh ok
01:43:36 <cinimod> Ghoul_: What are you trying to do - I missed the beginning of the conversation
01:43:38 <ciaranm> the trouble with graph libraries is that they try to choose the "right" data structure for the operations you want. which is silly, because the wrong data structure is often better.
01:44:02 <mr-> Ghoul_: where is ther eany sorting going on in scc?
01:45:05 <Ghoul_> uh, stronglyConnCompR has an interesting characteristic which I  found makes it useful for some stuff
01:45:23 <Ghoul_> > flattenSCCs $ stronglyConnCompR [(1, 1, [2, 3, 0]), (2, 2, []), (3, 3, [2]), (4, 4, [2, 0]), (5, 5, [3, 4]), (0, 0, [])]
01:45:24 <lambdabot>   [(2,2,[]),(3,3,[2]),(0,0,[]),(1,1,[2,3,0]),(4,4,[2,0]),(5,5,[3,4])]
01:45:33 <Ghoul_> all the dependencies on keys are from left to right
01:46:07 <Ghoul_> but if you make unused bindings have larger keys, the result isn't so *nice* anymore
01:46:36 <Ghoul_> err, some of the bindings. It likes to put things which are large ahead when possible.
01:48:02 * Lethalman so excited: http://ghc.haskell.org/trac/ghc/wiki/Status/Oct13
01:50:27 <Ghoul_> Lethalman: yes 7.8 is exciting
01:50:42 <Ghoul_> I just hope its available in a haskell platform *soon*
01:55:13 <Lethalman> missed this: (x+2) ~ 5 implies x = 3 :O
02:03:26 <startling> I'm using a type family and GHC says it can't deduce something I thought it could deduce: https://gist.github.com/startling/fa734c5f53f9f70998bc
02:07:22 <startling> I guess FunDeps would work as well, but type families are so much nicer.
02:09:37 <fizruk> startling, my guess is using 'type' instead of 'data' in Shift class is the problem
02:10:03 <fizruk> in invert (b, d) = (not b, invert d)
02:10:17 <startling> fizruk, it's a type synonym family.
02:10:44 <fizruk> d :: Direction a
02:11:07 <fizruk> but Direction a does not imply using invert of Shift a
02:11:22 <fizruk> since Direction is not (injective?)
02:11:52 <startling> oh. That's a good point.
02:11:56 <startling> Yeah, injective is the right word.
02:11:56 <fizruk> so GHC does not know which invert to use (type variable r is ambiguous)
02:11:59 <startling> Thanks!
02:12:13 * startling needs to learn to read. :/
02:12:16 <fizruk> startling, so I think you should use data families instead
02:12:50 <startling> I wonder if there are newtype families.
02:13:02 <startling> fizruk: yeah, it seems to work with data families.
02:13:52 <fizruk> startling, there are newtype families
02:14:19 <fizruk> startling, see http://www.haskell.org/ghc/docs/latest/html/users_guide/type-families.html
02:14:40 <startling> I guess it doesn't buy me much, though, since a newtype on a pair is kind of silly.
02:14:48 <startling> I just thought it would be nice to preserve instances etc
02:14:51 <fizruk> oh, actually newtype instances
02:15:02 <fizruk> that makes more sense :)
02:15:08 <startling> fizruk: ah.
02:25:38 <zebr> this is a bit of a stretch, but there doesn't happen to be any way in haskell to say e.g. 't ~= p', where t is an expression and p is a pattern, such that it returns a boolean indicating whether t matches pattern p, is there?
02:25:45 <zebr> it's just, that would be very useful, very often. <.<
02:26:51 <merijn> zebr: Not quite what you ask, but maybe you want pattern guards?
02:27:14 <arkeet> (if we had first-class patterns, we could do this)
02:27:21 <arkeet> (fortunately we do, sort of, in the form of prisms!)
02:27:46 <startling> yeah, I thought prisms too.
02:27:54 <startling> > has _Left (Right 2)
02:27:56 <lambdabot>   False
02:27:56 <merijn> That lets you write stuff like "foo x | Just y <- lookup key x = y" (i.e., pattern matching on an expression from some argument)
02:28:29 <arkeet> pattern guards are pretty good yeah.
02:29:18 <arkeet> hm, I better sleep
02:29:24 <zebr> hold on, monadic failure in a patter guard evaluates to false?
02:29:25 <skypers_> hi
02:29:31 <skypers_> can you see that thread? http://fr.reddit.com/r/haskell/comments/1ow00i/hsfmodex/
02:29:34 <zebr> s/monadic/pattern/
02:29:36 <zebr> (tired)
02:29:51 <skypers_> I don’t understand why it doesn’t appear in the general haskell threads list
02:29:59 <fizruk> zebr: to fail
02:30:27 <fizruk> > do {[x] <- Just [1, 2, 3]; return x}
02:30:29 <lambdabot>   Nothing
02:30:37 <startling> :t fail
02:30:38 <lambdabot> Monad m => String -> m a
02:30:41 <startling> it's a pretty bad hack.
02:30:47 <fizruk> sure
02:30:49 <startling> > fail :: Identity 2
02:30:50 <lambdabot>   <hint>:1:18: Illegal literal in type (use -XDataKinds to enable): 2
02:30:58 <startling> > fail :: Identity Int
02:30:59 <lambdabot>   Couldn't match expected type `Data.Functor.Identity.Identity
02:30:59 <lambdabot>               ...
02:31:07 <startling> > fail "oops" :: Identity Int
02:31:08 <fizruk> > fail "yo" :: Identity Int
02:31:13 <lambdabot>   Identity {runIdentity = *Exception: yo
02:31:13 <lambdabot>   Identity {runIdentity = *Exception: oops
02:31:15 <startling> That too way too many tries. >.>
02:31:20 <zebr> so... i was right with the monadic thing? pattern guards are basically monadic, kinda?
02:31:27 <zebr> i should really read more about pattern guards.
02:31:29 <startling> zebr, no, they're different.
02:31:32 <scshunt> > fail "waaaaa" :: Either String Int
02:31:34 <lambdabot>   *Exception: waaaaa
02:31:53 <zebr> what's the deal with guards and 'fail' then?
02:32:02 <startling> scshunt, nope. There's no way for "fail" to introspect whether you're Either String or Either anythingElse.
02:32:10 <scshunt> startling: of course
02:32:21 <scshunt> zebr: fail is used in do notation, and only there
02:32:22 <merijn> zebr: Pattern match failure simply moves on to the next pattern (like normally on failed pattern match in functions)
02:32:52 <merijn> zebr: Pattern guard syntax is completely unrelated to do-notation
02:32:54 <startling> zebr, I think maybe merijn mixed guards and pattern binds
02:33:08 <ion> Pattern guards don’t have anything to do with monads or fail.
02:33:22 <ion> I like how meta “fail” is.
02:33:37 <merijn> startling: huh? I never mentioned pattern binds?
02:33:37 <startling> Maybe I'm wrong. I don't ever use guards so the syntax always looks a little strange to me.
02:33:40 <scshunt> zebr: they have basically nothing to do with each other
02:33:43 <startling> merijn, yeah, my mistake.
02:33:47 <zebr> i see. but does 'f a | Just x <- g y = x' work? i.e. if the pattern fails, does it just go to the next pattern?
02:33:57 <merijn> zebr: Yes
02:34:06 <zebr> how does it do that? magic?
02:34:21 <ion> > let f a | Just x <- a = x | otherwise = 42 in [f (Just 1), f Nothing]
02:34:21 <merijn> zebr: Same way it normally does that
02:34:22 <lambdabot>   [1,42]
02:34:25 <scshunt> zebr: the same way other patterns work
02:34:46 <merijn> zebr: The only difference is that instead of comparing patterns directly it ends up running some extra code before matching
02:34:52 <ion> > let f a = case a of { Just x -> x; _ -> 42 } in [f (Just 1), f Nothing]
02:34:53 <lambdabot>   [1,42]
02:35:25 <zebr> but see, i get 'f a | g y'. no problem. it just feels like if you have 'Just x <- g y' then, well, how does it know not to just panic and die on pattern failure (i.e. Nothing)? >.>
02:35:51 <merijn> zebr: Because it was hardcoded in the compiler to interpret the syntax like that?
02:35:56 <ion> “f a | False” – how does that know not to panic? Well, that’s how it’s specified to work.
02:36:07 <ion> “f a | Nothing <- Just 42” – ditto
02:36:18 <zebr> right, so it is a magical syntactic thing, rather than something observable underlying both it and fail?
02:36:44 <merijn> zebr: Well, depending on what you mean by magical syntax?
02:36:57 <merijn> zebr: Is "2 + 2" in C/python/ruby magical syntax?
02:37:03 <zebr> absolutely.
02:37:04 <ion> You can imagine non-pattern guards as pattern guards with “True <-” in the beginning. :-P
02:37:07 <fizruk> zebr, you may think of "f a | condition = ..." as "f x | True <- condition = ...", if that helps
02:37:09 <merijn> If not, "how does it know to add 2 + 2?"
02:37:21 <zebr> fizruk: that makes sense.
02:37:52 <fizruk> zebr, so pattern guards extends that for other types you can pattern match on
02:38:03 <ion> > let f (Just x) = x; f _ = 42 in [f (Just 1), f Nothing]
02:38:04 <lambdabot>   [1,42]
02:38:16 <ion> > let f y | Just x <- y = x; f _ = 42 in [f (Just 1), f Nothing]
02:38:17 <lambdabot>   [1,42]
02:39:07 <Lethalman> where can I read about the new ghc constraint solver?
02:39:17 <zebr> it's very clever, anyway. i'll be sure to use this. thanks all.
02:40:47 <startling> I've got a thing of kind * -> * and I want to write an instance with a constraint on the type argument. The only workaround I've seen is the silly GADT thing where you go "data X where X :: a -> X a a". Is there something better?
02:43:16 <fizruk> startling, are talking about typeclass constaint?
02:43:23 <fizruk> s/are/are you/
02:43:56 <merijn> startling: You want to constrain what type can be passed to it?
02:44:52 <startling> With that "silly GADT thing", you could do "Ord a => Functor (X a)". I want to do something analogous.
02:45:18 <startling> fizruk: yes.
02:45:51 <startling> merijn: so no. I just want to put a typeclass constraint on the argument in an instance for the whole.
02:45:56 <startling> if that makes sense.
02:46:48 <fizruk> startling, something like this? http://www.haskell.org/haskellwiki/Data_declaration_with_constraint
02:46:48 <merijn> startling: Oh, same thing
02:47:12 <merijn> fizruk: No, that's awful and doesn't do anything
02:47:21 <merijn> fizruk: There's a reason it was dropped from the 2010 standard
02:47:28 <merijn> startling: Maybe look at this? https://gist.github.com/merijn/6130082
02:47:31 <startling> merijn: oh, you're right. I can just add the constraint to the GADT thing?
02:47:43 <merijn> startling: Although the syntax for that may have changed in latest HEAD
02:47:46 <startling> "data X where X :: Ord a => a -> X a"?
02:47:49 <fizruk> merijn, ok, good to know
02:47:51 <merijn> I didn't test it recently
02:48:18 <merijn> fizruk: Basically, it means you can only pass in types matching a certain typeclass, but it won't remember that the types must be in that class
02:49:07 <merijn> fizruk: So if you have "data Ord x => Foo x = ..." you *still* need to write "foo :: Ord x => Foo x -> x"
02:49:21 <merijn> fizruk: i.e. it doesn't allow you to drop the Ord cosntraint on the foo function
02:49:30 <fizruk> merijn, I see, thanks :)
02:49:38 <merijn> startling: That GADT would work too
02:49:57 <startling> That seems simpler for my use-case. Thanks!
02:50:14 <merijn> startling: My neat type family leads to horrific type errors anyway :p
02:50:53 <startling> Oh, wait, that would mean I can't have a Functor instance, wouldn't it.
02:51:04 <merijn> Possibly
02:51:08 <startling> Because there
02:51:21 <startling> 's no guarantee that the result of the function mapped would have Ord ...
02:51:30 <startling> Hrm.
02:51:55 <staafl> why is the following not a category: https://en.wikibooks.org/wiki/File:Not-a-cat.png
02:52:08 <fizruk> startling, not sure, the result type is X b, which should tell GHC that b is Ord
02:52:17 <fizruk> startling, didn't try that though
02:52:22 <t7> not-a-cat.png
02:52:25 <staafl> it's an exercise from the wikibook
02:52:26 <startling> fizruk, right, but there's no constraint on the function.
02:52:48 <staafl> it says "Hint: think about associativity of the composition operation."
02:52:58 <staafl> but I've written it out and the associativity seems to hold
02:53:32 <fizruk> startling, m... yes, that should break it, perhaps
02:54:49 <sjoerd_visscher> staafl: what should f . g . h be?
02:56:29 <staafl> sjoerd_visscher, well, it maps B to A
02:57:14 <fizruk> staafl, I guess it should be either f or h, which one?
02:57:18 <sjoerd_visscher> staafl: so it must be either f or h, there are no other arrows than shown
02:57:51 <staafl> ah, I see
02:58:28 <staafl> so every composition is a unique morphism of the category?
02:58:53 <fizruk> staafl, f . g . h = f . (g . h) = f . id = f
02:59:07 <fizruk> staafl, f . g . h = (f . g) . h = id . h = h
02:59:09 <staafl> but (f . g) . g = id . h = h
02:59:12 <fizruk> staafl, f = h
02:59:34 <staafl> yes, got it
02:59:36 <fizruk> but the picture says they're not the same, so it's not a cat
03:00:30 <staafl> so does this mean that there is no way to have two morphisms from B to A?
03:00:31 <staafl> surely not
03:01:08 <sjoerd_visscher> staafl: you'd need more arrows from B to B and A to A then
03:01:25 * hackagebot uuid-quasi 0.1.0.1 - Supplemental package for 'uuid' allowing quasiquotation.  http://hackage.haskell.org/package/uuid-quasi-0.1.0.1 (LarsPetersen)
03:03:57 <sjoerd_visscher> staafl: you should try to fix it, f.e. set f . g . h = h and see which new arrows you need
03:06:43 <staafl> sjoerd_visscher, but the new morphisms can't be identities, right?
03:07:03 <fizruk> staafl, they should not be :)
03:07:24 <fizruk> staafl, id2 = id1 . id2 = id1
03:08:56 <staafl> fizruk, id2 = id1 . id2 = id1 is what should NOT be the case?
03:09:02 <staafl> or am I being dense :-D
03:09:40 <fizruk> staafl, there can't be two ids on a cat: id2 = id1 . id2 = id1 is the proof :)
03:10:06 <staafl> fizruk, yes, I get it now
03:10:19 <staafl> arcsin . sin = id
03:10:23 <staafl> arcsin . cos != id
03:10:45 <ion> > (asin . sin) 42
03:10:46 <lambdabot>   -1.159295503332688
03:11:18 <staafl> > (asin . sin) 1
03:11:19 <lambdabot>   1.0
03:11:38 <staafl> assuming one uses the proper domain to begin with
03:11:40 <fizruk> staafl, i'm bad at examples, but perhaps you can try with A = Nat and B = Set
03:12:10 <staafl> fizruk, ok, I'll try
03:12:15 <staafl> thanks for the input :-)
03:17:35 <individual> I can't have multiple constructors of different types with the same name?
03:18:04 <individual> I mean data A and data B can't have constructors with the same name?
03:18:23 <Lethalman> individual, constructors are like functions
03:18:58 <Lethalman> they are in the global namespace, so no they can't have the same name
03:19:20 <Lethalman> individual, you can, however, put those two data types in different modules
03:19:49 <individual> thanks
03:20:10 <Lethalman> in which case you could do ModuleA.YourCtor and ModuleB.YourCtor
03:20:41 <merijn> individual: On the one hand it's annoying sometimes, on the other hand you never have to be confused which type a constructor belongs too
03:24:53 <techtangents> Hi all. New to parsec. How do I to a 'not' parser? e.g. not . char $ ':'
03:26:23 <fizruk> techtangents, http://hackage.haskell.org/package/parsec-3.0.0/docs/Text-Parsec-Combinator.html#v:notFollowedBy
03:27:14 <techtangents> weird. Thanks.
03:27:59 <int-e> hmm, for single characters use 'noneOf' or 'satisfy'. http://hackage.haskell.org/package/parsec-3.0.0/docs/Text-ParserCombinators-Parsec-Char.html#v:satisfy
03:29:34 * w0rm_x wonders why Parsec is used over Happy
03:29:50 <int-e> (Hmm, I should link to Text.Parsec.Char)
03:29:55 <tdammers> :t notFollowedBy
03:29:56 <lambdabot> Not in scope: `notFollowedBy'
03:29:59 <tdammers> hmm
03:30:09 <tdammers> @hayoo notFollowedBy
03:30:09 <lambdabot> Unknown command, try @list
03:30:13 <tdammers> @hoogle notFollowedBy
03:30:14 <lambdabot> Text.Parsec.Combinator notFollowedBy :: (Stream s m t, Show a) => ParsecT s u m a -> ParsecT s u m ()
03:30:14 <donri> it's weird the parser combinator libraries don't have a "not" combinator
03:30:14 <lambdabot> Text.ParserCombinators.Parsec.Combinator notFollowedBy :: (Stream s m t, Show a) => ParsecT s u m a -> ParsecT s u m ()
03:30:19 <donri> notFollowedBy is not quite that
03:30:35 <tdammers> what would "not" mean in the context of a parser combinator?
03:30:39 <tdammers> should it consume?
03:30:44 <tdammers> if so, what and how much?
03:30:45 <mr-> w0rm_x: For one thing, you do no need to know another language
03:30:52 <tdammers> should it backtrack?
03:30:55 <donri> tdammers: parse anything that this parser doesn't
03:31:05 <int-e> donri: and then do what?
03:31:09 <mr-> w0rm_x: it just seems easier ;-)
03:31:31 <tdammers> donri: yeah, but how much should I parse, then?
03:31:33 <int-e> We have alternative, which is left-biased, and we have notFollowedBy for discarding the first alternative.
03:31:42 <donri> i guess it's a question then how much it consumes
03:32:48 <techtangents> I think satisfy . not is what I was looking for.
03:33:12 <tdammers> playing devil's advocate here, "not" could mean "try to parse X, and if it fails, backtrack and consume the rest of the input"
03:33:43 <donri> yeah that doesn't sound too useful, not sure what i was thinking of :)
03:33:57 <w0rm_x> mr-, fair enough
03:34:50 <quchen> Does the free monad for Maybe have a common analogon? It seems like it's a list where Nil "[] | Last x", is that right?
03:34:55 <donri> maybe i'm thinking of manyTill
03:34:56 <int-e> Right, you can take the complement of a language. But parsers do more than accept a language; they also provide an intepretation of the parsed things. And that's where a simple 'not' lacks expressive power.
03:34:56 <donri> hm
03:35:13 <tdammers> so you'll have to be a bit more specific about what kind of thing you *do* want to parse
03:35:24 <tdammers> Alternative, manyTill, etc. do that
03:36:05 <tdammers> or, indeed, if it's a single token, satisfy . not or noneOf should do the trick
03:36:10 <donri> or maybe i'm looking for something like noneOf that takes a parser rather than a string, but that would be weird for a parser that consumes more than one character
03:36:28 <techtangents> Actually, manyTill sounds like what I'm after.
03:36:57 <techtangents> cheers
03:37:43 <int-e> w0rm_x: Parsec is used instead of Happy because with Parsec you don't have to learn another syntax, only an EDSL ;-) Also parser combinators are a very cute application of higher order functions. You can write papers about that. Yet another parser generator ala yacc is comparatively boring.
03:39:06 <mr-> quchen: isn't it more like "F a = a | Maybe (F a)" I don't see the list-part you mention. I.e. nested Maybe or something of a
03:39:26 <int-e> (The question should be, why do people use parsec rather than ... uh ... attoparsec, polyparse, or uu-parsinglib, to name a few)
03:40:00 <mr-> int-e: are papers still being written about parser-combinators?
03:40:04 <alexander__b> hm. I have a tuple (Type, Type), and a function that takes Type Int. so if I have an int, foo=2, I could do e.g. "(function (fst tuple) foo, function (snd tuple) foo)". is there some clever trick to do this more concise?
03:40:16 <quchen> mr-: F Maybe a = Pure a | Roll (Maybe (F Maybe a)) = Pure a | RollNothing | Roll (F Maybe a)
03:40:27 <quchen> mr-: … handwavy
03:40:49 <alexander__b> right now I pattern match (a,b) and do "(move a t, move b t)", but would love to do it more concisely if possible.
03:40:49 <quchen> So it's like a list that has either a "Pure a" or a "Roll Nothing" at the end
03:41:15 <mr-> quchen: how would you encode two elements of a, for example?
03:41:17 <quchen> Oh wait, the cons cells don't have a value attached
03:41:26 <techtangents> alexander__b: sounds like a job for Arrows.
03:41:35 <quchen> It's a list of units with a weird ending :-s
03:41:44 <danilo2> Hello! \o/ Do somebody know how can I accomplish this task: I want function "f" to work with both X and Y instances. Right now it only works with X (if you uncomment the line 35 id does not compile). The code is written with help of some people here and it aims imitating some OO behaviours in Haskell.
03:41:44 <danilo2> http://lpaste.net/94587
03:41:57 <quchen> Hm, I'll have to think about that over lunch. Colleague pressuring me :-)
03:41:59 <mr-> quchen: a typical element is of the form Just $ Just $ Just 4, or Just $ Nothing, or 4 ?
03:42:37 <w0rm_x> int-e, interesting..
03:42:46 <techtangents> danilo2: make both X and Y implement the same typeclass.
03:43:21 <danilo2> techtangents: please look at the code :)
03:43:32 <techtangents> sorry
03:45:35 <danilo2> The problem is with signature of "f" (lines 24-26) - How can we fix it not to have "harsdcoded" return types of "method1"? If I could write a predicate like "F_method1 m (Int -> Int -> b)" instead of "F_method1 m (Int -> Int -> (Int, Int))" it would work
03:47:16 <Lethalman> danilo2, type YourRet = (int, Int)
03:47:45 <danilo2> Lethalman: method1 for Y retunrs Int and for X returns (Int,Int)
03:48:02 <danilo2> Lethalman: lines 11-12
03:49:35 <mr-> quchen: it almost is equivalent to Maybe a, except for the number of "Just"-steps. Which leads me to the question, is Just $ Just $ .. (forever) something of type Free Maybe a ?
03:50:51 <danilo2> More detailed question I've posted on SO here: http://stackoverflow.com/questions/19484232/oop-using-haskell-type-system?noredirect=1#comment28899789_19484232
03:51:03 <danilo2> So If anybody would know the answer I would be very thankful for help :)
03:51:35 <techtangents> danilo2: that's some crazy stuff. Over my head, but good luck :)'
03:51:47 <danilo2> techtangents: thank you :)
03:53:42 <int-e> mr-: Hmm, 2013: "Correct-by-Construction Pretty-Printing" -- the idea being to combine pretty printing and parsing into a single specification ... expressed using parser combinators.
03:54:19 <donri> int-e: where's that from? i've been wanting to do that miself
03:54:41 <fizruk> danilo2, hi, you had some question yesterday?
03:54:59 <mr-> quchen: it is!  fix (Free . Just) :: Free Maybe a (where Free = Roll, as defined in Control.Monad.Free)
03:55:01 <yorick> what's the difference between -> and =>? it's virtually ungooglable :/
03:55:10 <danilo2> fizruk: Hello! Thank you, you remember it :)
03:55:21 <int-e> donri: http://www.cse.chalmers.se/~nad/publications/
03:55:33 <donri> thanks
03:55:37 <mr-> int-e: cool
03:55:49 <danilo2> fizruk: Yes, I wanted to ask you if you know how can we fix your solution a little more (http://lpaste.net/94587) in such way, that line 35 will also work
03:56:02 <mm_freak> int-e: 2013?
03:56:07 <donri> heh i seem to have visited that pdf before
03:56:20 <mm_freak> boomerang is quite older than 2013 =)
03:56:36 <donri> and boomerang itself is based on zwaluw
03:56:36 <mm_freak> and it's not even original…  it was already based on a different library
03:56:43 <danilo2> fizruk: Right now we hardcioded the return type of method1 in type signature of f (in lines 24-26) and we can use only these "method1", which returns tyuple of the same elements
03:57:09 <int-e> mm_freak: the question was whether there are still publications on parser combinators :)
03:57:18 <int-e> mm_freak: 2013 is about as recent as it gets.
03:57:19 <danilo2> fizruk: If I would replace (line 24) F_method1 m (Int -> Int -> (Int, Int)) to something like F_method1 m (Int -> Int -> b) I would be super-happy :)
03:57:27 <mm_freak> ah =)
03:57:31 <donri> mm_freak: i think boomerang itself is just a bunch of isomorphisms, and maybe this paper is about enforcing those isomorphisms in the types
03:58:12 <mm_freak> the same could maybe be applied to isomorphism lenses then
03:58:51 <mm_freak> in fact i find myself wondering if boomerang can be expressed in terms of van laarhoven
03:59:38 <donri> probably more like a prism though
03:59:51 <donri> and prisms are currently kinda crappy for parsing because failure only gets you a Nothing
04:00:13 <fizruk> danilo2, you know it can't be just b. at least (b Int)
04:00:16 <mm_freak> for the usual use cases of boomerang that's all you care about =)
04:00:23 <mm_freak> Nothing → reply 404 =)
04:00:24 <donri> true enough :)
04:00:55 <donri> although, if we had good error messages those could be part of the 404 message
04:01:04 <danilo2> fizruk: But cannot we implement method1 for X in such way it returns Int and for Y in such way that it returns for example String?
04:01:27 <donri> got /admin/secrut expected one of: secret, passwd
04:01:28 <donri> ;)
04:03:15 <mm_freak> true
04:05:35 <fizruk> danilo2, X a is just a wrapper for a, how can you get Int out of a?
04:05:52 <individual> can I turn off non-exhaustive pattern match warning while keeping -Wall in GHC?
04:06:41 <mr-> individual: I don't know, but you could just add a f _ = error "Uhoh.." Pattern
04:06:41 <mm_freak> individual: yes, _ = error "BUG!"
04:07:06 <danilo2> fizruk: X a is a wrapper for a, but a is a lambda expression. If you look at the definition of "cons_X = X { _methodx1 = (\a b -> (a,b)) }", you see, a is here a lambda. Then we make X instance of F_method1. (http://lpaste.net/94587)
04:07:06 <ocharles> or better, use Maybe/Either
04:07:19 <mm_freak> individual: of course the proper solution is not to have non-exhaustive patterns
04:07:23 <individual> I was actually doing that but it gets really annoying since pattern matching is used so often
04:07:29 <danilo2> fizruk: So (method1 x) "returns" (\a b -> (a,b))
04:07:49 <mm_freak> individual: if non-exhaustive patterns are frequent in your code, that's a really bad sign
04:07:50 <sjoerd_visscher> individual: -fno-warn-incomplete-patterns
04:08:07 <danilo2> fizruk: We can also make for example cons_Y = Y { _methody1 = (\a b -> "hello") } and (method1 y) will return String
04:08:12 <mr-> individual: really really bad ;-)
04:08:36 <individual> mm_freak: but if I have a function that I use only inside a module and I have already assured that I will not call it with a wrong argument then what's the point?
04:09:10 <mm_freak> individual: that there is still potential to call it with a wrong argument, i.e. you're using the wrong argument data type
04:09:32 <danilo2> fizruk: Maybe I explained it in not beautifull way, but "method1" is just a "name" for a method of "an object". It is logicaly equivalent to calling x.method1(1,2) (which returns for example (1,2)) and y.method1(1,2), whcih can return a string or anything - based on the implenmetation of _methody1
04:09:40 <mm_freak> for example if lists are required to be infinite, it's wrong to use []…  you should use Stream instead
04:09:41 <adimit> individual: it depends, but you might want to rethink your ADTs, if this happens frequently. The fact that you're using an ADT somewhere were its full power is not required hints at possible refactoring opportunities.
04:10:19 <fizruk> danilo2, ok, wait a bit
04:10:21 <mm_freak> individual: as a nice bonus your code will become faster =)
04:10:26 <danilo2> fizruk: ok :)
04:10:28 <adimit> That would make the code easier to read and extend. Probably. There are a lot of ifs and buts involved here.
04:12:54 <individual> I have to think about this
04:17:43 <danilo2> fizruk: If you want to read more, I've posted today morning a question os SO about this problem trying to explain everything the best I can: http://stackoverflow.com/questions/19484232/oop-using-haskell-type-system?noredirect=1#comment28899789_19484232
04:24:23 <fizruk> danilo2, I think the problem is that you must tell Haskell about the result type somehow
04:24:39 <quchen> mr-: Up next, what's "FreeM (r ->) a"? :-)
04:25:11 <quchen> Looks related to Cont.
04:25:19 <danilo2> fizruk: :( So is there **any** way of simulating the OO behaviour? I mean simulating "x.method1()", which vcan result different types based on the type of x?
04:25:26 <elliott> FreeM = Control.Monad.Free.Free?
04:25:37 <quchen> elliott: Yes
04:25:43 <elliott> it's Supply.
04:25:45 <fizruk> danilo2, existential types
04:25:50 <quchen> Ah, thanks.
04:25:50 <mr-> quchen: I don't know. But a typical element is of the form r^n -> a where r^n = (r,...,r) ;-)
04:25:53 <elliott> oh, it's also a fold thing.
04:25:58 <elliott> maybe.
04:26:12 <elliott> anyway I like Free ((->) s).
04:26:20 <elliott> it's a good type.
04:26:27 <fizruk> danilo2, in your example you only use return value of method1 to print it
04:26:48 <quchen> elliott: Supply as in monad-supply package?
04:27:12 <fizruk> danilo2, so you can wrap a value into data Printable = forall a. Show a => Printable a
04:27:15 <Taneb> elliott: is that "If you through enough s's at me I'll give you somehi
04:27:22 <elliott> no, this Supply is better than any packaged Supply
04:27:30 <danilo2> fizruk: In this example to print it, but of course we can use as a return of the function etc. I've read about them (existential datatypes) - do you have any hint how they can be used here? :) Btw thank you for all the help, If I'll met you I'll buy you a beer :D
04:27:30 <Taneb> *something but I'm not going to say how many s's you need"
04:27:30 <fizruk> danilo2, note that Printable does not have a type parameter
04:27:42 <elliott> Taneb: sure
04:27:48 <quchen> elliott: I'm not familiar with the Supply type, that's why I'm asking where I could find more information about it.
04:27:49 <elliott> quchen: consider something which wants a supply of free variable names or such
04:28:22 <danilo2> fizruk: do you suggest I should wrap every method of a "OO class" into and existentail datatype ?
04:28:25 <elliott> define supply = liftF id or whatever
04:28:30 <elliott> then liftA2 (,) supply supply
04:28:37 <fizruk> danilo2, not method, but the return value
04:28:38 <elliott> you can feed it from a stream or from an RNG or from user input or whatever
04:29:04 <fizruk> danilo2, like cons_X = X $ \a b -> Printable (a, b)
04:29:19 <fizruk> danilo2, and cons_Y = Y $ \a b -> Printable a
04:30:06 <fizruk> then in f's signature use contraints (F_method1 m (Int -> Int -> Printable), F_method1 m (String -> String -> Printable)) => ...
04:30:07 <Taneb> (and Cofree ((->) s) is the almost entirely unrelated "You choose how many s's you give me and I'll give you something)
04:30:17 <danilo2> fizruk: Ahh I see. Ok that makes sense. Hmm this way we tell haskell what is the result of "f" somewhat like "callecting all common methods, that could be used on the return type"?
04:33:34 <danilo2> fizruk: Ok, but if the body of f is a simple calls to a polymorphic method, like for example "f x = (method1 x) (1::Int) (2::Int)", than why we cannot tell Haskell, that its result type depends on the implementation of method1 for a specific x type?
04:34:00 <danilo2> fizruk: If the body contains no prints and only this one line it works without giving any types. And it works both for X and Y
04:34:28 <fizruk> danilo2, what's the implementation of method1? :)
04:34:50 <fizruk> danilo2, the caveat here is that the implementation *depends* on type
04:34:55 <fizruk> danilo2, and not vice versa
04:34:59 <danilo2> fizruk: method1 is a function of typeclass so its implementation idffers for instances of the class
04:35:25 <fizruk> danilo2, so the return type drives the implementation, but not the other way around
04:36:54 <danilo2> fizruk: I think I understand it, but please look here: http://lpaste.net/94588 . In this example both X and Y are working. f cons_X returns (Int,Int) and f consY returns a String
04:38:21 <danilo2> fizruk: and again everything stops working if we try to call other method in the body of f, but again if this exampel works, why canmot we make rankNtypes work this way? I mean - in this excample Haskell infers the signaturwe of method1 to be Int-Int->a
04:40:34 <danilo2> fizruk: I simply want to tell Haskell that method1 has predicate F_method1 m (Int -> Int -> b) - and b depends on the type of x (for X it gives (Int,Int), for Y it is String)
04:41:16 <fizruk> danilo2, brb
04:41:25 <danilo2> fizruk: ok, thnak you
04:43:10 <srhb> What's a good way for an editor to handle file writing? Is it alright to simply write the entire edited file to disk on save, or should I try to be clever about modified regions? Not sure how to abstract that properly.
04:44:41 <mm_freak> srhb: neither
04:44:52 <srhb> mm_freak: Alright?
04:45:05 <mm_freak> srhb: you should write a completely new file with a temporary name, then rename it to the target file
04:45:19 <srhb> mm_freak: How come?
04:45:25 <ocharles> because writing is not atomic
04:45:31 <ocharles> but moving things is
04:45:35 <mm_freak> srhb: picture a system crash in the middle of writing
04:46:30 <srhb> Oh, right! Derp.
04:48:08 <quchen> That can be problematic for large files though. What about a hybrid system in that case? Have two files, one in focus. Update the file out of focus where necessary, then switch focus.
04:51:55 <mm_freak_> in other words, we need a transactional filesystem
04:51:56 <Itkovian> suppose I need to wrap a number of shell commands (due to lack of an API) in my Haskell library, what is the idiomatic method of defining the various options each command takes?
04:57:16 <individual> ghci is funny. It can create tags for Vi but uses emacs's keybindings
04:57:34 <donri> no, it uses readline-style bindings
04:57:40 <donri> and vi-like commands :P
04:58:20 <srhb> quchen: I was thinking of a zipper-like thing to update "dirty" lines
04:58:51 <srhb> quchen: But of course, I'd have to translate "lines" to bytes at some point. Eck.
04:59:33 <donri> @hackage cautious-file
04:59:33 <lambdabot> http://hackage.haskell.org/package/cautious-file
05:00:08 <srhb> donri: Neat.
05:00:13 <individual> donri: and readline is a part of which project :P?
05:00:26 <srhb> individual: GNU
05:00:42 <individual> srhb: that was rhetorical
05:00:52 <srhb> Oh.
05:03:01 <srhb> individual: I didn't understand then. It uses haskeline internally, so if you set that to Vi-mode, you get a consistent result. It's much like how bash is set up by standard, isn't it?
05:04:18 <srhb> (Or readline, if you will)
05:04:57 <individual> but why not set the defaults to vi then? Why do bindings and commands have a different source of inspiration? (I don't actually care, I was just making an observation :)
05:05:12 * srhb shrugs
05:05:21 <srhb> I don't care either. I never thought of them as vi-style commands.
05:05:28 <srhb> Just prefixed by : :P
05:06:22 <donri> http://trac.haskell.org/haskeline/wiki/UserPrefs is how you configure it btw, if anyone was curious
05:09:14 <srhb> I'm curious, how come I often bump into
05:09:16 <srhb> ergh
05:09:30 <srhb> How come I often bump into packages on Hackage that don't have documentation available for the newest versions?
05:09:57 <donri> it doesn't build them on upload
05:10:06 <donri> rather, there's a cronjob or something
05:10:23 <srhb> Oh, I see.
05:17:46 <skypers_> ad time: https://github.com/skypers/hsFModEx
05:17:46 <skypers_> :)
05:17:58 <skypers_> and http://fr.reddit.com/r/haskell/comments/1ow00i/hsfmodex/
05:21:53 <skypers_> btw
05:22:06 <skypers_> is there a Ian Ross here?
05:32:18 <vlatkoB> If b1 and b2 take x and return IO Bool, why "c x = (&&) <$> b1 <*> b2 $ x" isn't good?
05:32:44 <merijn> vlatkoB: is x an IO value?
05:32:52 <ion> Try writing it in a more readable form.
05:32:52 <merijn> vlatkoB: oh, wait
05:33:02 <ion> Without the (-> r) Applicative
05:33:14 <haasn> vlatkoB: (&&) doesn't operate on IO values
05:33:24 <haasn> it would probably work if you used liftM2 (&&) instead
05:33:24 <merijn> You'll want liftM2 (&&)
05:33:46 <haasn> alternatively, slip a Compose applicative in there ;)
05:34:11 <Peaker> @type (liftA2 . liftA2) (&&)
05:34:11 <merijn> :t liftM2 (&&) <$> (undefined :: a -> Bool) <*> (undefined :: a -> Bool) $ (undefined :: a)
05:34:12 <lambdabot> (Applicative f, Applicative f1) => f (f1 Bool) -> f (f1 Bool) -> f (f1 Bool)
05:34:13 <lambdabot>     Couldn't match type `Bool' with `m0 Bool'
05:34:13 <lambdabot>     Expected type: a0 -> m0 Bool
05:34:13 <lambdabot>       Actual type: a0 -> Bool
05:34:26 <merijn> hmmm
05:34:27 <Peaker> merijn: you forgot the IO in IO Bool there
05:34:34 <merijn> oh, right
05:34:44 <merijn> :t liftM2 (&&) <$> (undefined :: a -> IO Bool) <*> (undefined :: a -> IO Bool) $ (undefined :: a)
05:34:45 <lambdabot> IO Bool
05:34:53 <haasn> :t liftA2.liftA2.liftA2 -- I've seen this pattern before..
05:34:53 <lambdabot> (Applicative f, Applicative f1, Applicative f2) => (a -> b -> c) -> f (f1 (f2 a)) -> f (f1 (f2 b)) -> f (f1 (f2 c))
05:35:03 <merijn> I'd define a helper, though
05:35:10 <Peaker> merijn: though I find it very weird to use both liftM2 and <$>_<*> form in the same expression
05:35:16 <merijn> Yes
05:35:22 <vlatkoB> but "c x = (&&) <$> b1 x <*> b2 x" works, so it operates on IO
05:35:29 <Peaker> I like (liftA2.liftA2) directly without helpers
05:35:42 <merijn> vlatkoB: Yes, because here the <$> changes && to work on IO
05:35:47 <Peaker> though in this case I'd avoid the (->) applicative, yeah
05:35:48 <vlatkoB> I was hoping to do it in Applicative
05:35:50 <merijn> :t fmap (&&)
05:35:51 <lambdabot> Functor f => f Bool -> f (Bool -> Bool)
05:35:59 <srhb> :t liftA2
05:36:00 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
05:36:03 <haasn> :t getCompose ((&&) <$> Compose (undefined :: x -> IO Bool) <*> Compose (undefined :: x -> IO Bool)) undefined
05:36:04 <lambdabot> Not in scope: `getCompose'
05:36:04 <lambdabot> Not in scope: data constructor `Compose'
05:36:04 <lambdabot> Not in scope: data constructor `Compose'
05:36:06 <haasn> poo
05:36:14 <merijn> vlatkoB: You need to lift && an extra time for the function application
05:36:22 <merijn> vlatkoB: I'd just write it out, it'll be clearer
05:36:45 <ocharles> or maybe see if monad-loops has something useful here
05:37:21 <Peaker> vlatkoB: b1,b2 are: (a -> IO Bool),   so they are "wrapped" by 2 applicatives, (a->) and IO,   so the <$> <*> form lets the (&&) operate inside the (a->) Applicative, but not inside the IO applicative. For that you need to "penetrate" 2 Applicatives, so (liftA2.liftA2) (&&) does that
05:37:22 <merijn> vlatkoB: I don't think "c x = (&&) <$> b1 x <*> b2 x" looks that bad
05:37:28 <haasn> :t getCompose .: (liftA2 (&&) `on` Compose)
05:37:29 <lambdabot> Not in scope: `getCompose'
05:37:29 <lambdabot>     Not in scope: `.:'
05:37:29 <lambdabot>     Perhaps you meant one of these:
05:37:38 <Peaker> vlatkoB: are you doing this for real code, or for pedagogical purposes?
05:37:38 <haasn> oh right, that thing still isn't imported
05:38:40 <haasn> in all seriousness, I would go with (liftA2.liftA2) (&&) f g x -- for actual code, and look, you can eta-reduce!
05:39:21 <merijn> haasn: wut
05:39:25 <srhb> Clearly we need something like (liftA2)^2
05:39:29 <merijn> haasn: Try maintaining that a year from now :p
05:39:38 <haasn> merijn: I think liftA2.liftA2 is fine
05:39:46 <ocharles> srhb: you can have that, if you have dependent types :)
05:39:52 <haasn> we all know liftA.liftA, fmap.fmap, traverse.traverse etc. from lens
05:40:05 <srhb> ocharles: I can have everything if only, dependent types.. :P
05:40:10 <merijn> haasn: For some value of "we all"
05:40:12 <vlatkoB> Peaker: pedagogical, I have made an app that works, and now I'm trying to make as haskelish as possible.
05:40:15 <Peaker> merijn: with a lot of practice, you can be as efficient working with extremely point-free form as with point-ful, or even moreso (because shorter code is easier to work with, and it is often shorter)
05:40:21 <haasn> “we all” <- all people who will be mantaining my code
05:40:24 <haasn> aka me
05:40:31 <Peaker> merijn: but it does make the code inaccessible for a very minor benefit...
05:41:01 <merijn> Peaker: Sure, I'm not arguing against pointfree in general. I feel the added value here is just very minor for the added incomprehensibility
05:41:03 <Peaker> vlatkoB: well, it isn't considered very "Haskellish" to use the Applicative instance of (a->) that much
05:41:20 <ion> I wouldn’t nest (-> r) with another Applicative. I can *understand* (liftA2.liftA2) (&&) but it requires more brain cycles. In lens, something like “_1 . foo” follows a pattern that makes it easy to grasp. You don’t have to constantly be thinking about their Applicative effects.
05:41:37 <vlatkoB> Peaker: liftA2.liftA2 works, and thanks for explanation
05:42:09 <ion> (->) r
05:42:12 * Lethalman usually just removes any lift* from the code when reading
05:42:21 <vlatkoB> Peaker: I read that Applicative should be used if Monads are an overkill, as in this case. It is basically andM function, no?
05:42:25 <Lethalman> or <$>, <*>, $ etc.
05:42:31 <merijn> vlatkoB: In general code, yes
05:42:41 <merijn> vlatkoB: But IO is not general, it's already forced to be a monad
05:42:49 <haasn> of *course*, we should /actually/ have instance (Boolean x, Applicative f) => Boolean (f x)
05:42:55 <haasn> f && g
05:43:00 <Peaker> vlatkoB: Applicative is more general than Monad (applicable to more types), so prefer that, especially now as GHC is moving to make it a super-class of Monad
05:43:14 <merijn> vlatkoB: They idea is, if you only use applicative your code will work with more types. But since your code only works with IO it's already guaranteed to be a Monad :)
05:43:24 <Peaker> merijn: Ideally we wouldn't even have liftM2 and most of Control.Monad's functions would be in Control.Applicative with an Applicative constraint rather than a Monad one
05:43:26 <ion> (HasOperator x, Applicative f) => HasOperator (f x)? :-P
05:44:05 <merijn> Peaker: I'M SO EXCITED BY AMP!
05:44:25 <srhb> AMP?
05:44:42 <ion> Applicative-Monad Proposal or something like that
05:44:44 <Peaker> merijn: I love it too, though I already use an ugly workaround (a silly MonadA class capturing Applicative+Monad constraints that I use everywhere in place of Monad)
05:44:48 <haasn> will the change add a DEPRECATE to liftM2 etc. now?
05:44:52 <vlatkoB> merijn: Haven't thought of that, indeed. That "andM" is for filterM, so I wanted to make it short and pretty. :-)
05:45:26 <merijn> haasn: Probably not
05:45:35 <merijn> haasn: Not sure, though
05:45:43 <srhb> vlatkoB: andM sounds like a monadic and though.
05:46:04 <merijn> It has to be
05:46:11 <merijn> Applicative andM can't shortcircuit
05:46:15 <haasn> andM :: Monad m => [m Bool] -> m Bool
05:46:40 <fizruk> danilo2, sorry I can't get something working right know, I'll think about it later
05:47:37 <danilo2> fizruk: I'm very thankful for all your help :) It would be cool if you'll have later time and think about it :) thank you once again! :)
05:48:13 <fizruk> danilo2, np, tell me if you get further yourself :)
05:48:35 <danilo2> fizruk: of course! :)
05:48:35 <vlatkoB> Thanks to all, guys. Much appreciated.
05:51:29 <Peaker> vlatkoB: merijn has a good point there,  this (liftA2.liftA2) (&&) stuff might not do what you expect
05:52:08 <Peaker> (in terms of executing both bool-generating actions anyway, even if the first yielded false)
05:58:28 <startling> Can I have a typeclass constraint on a data family thing?
05:59:31 <merijn> startling: I don't think so?
05:59:42 <merijn> Actually
05:59:48 <merijn> Maybe you can? Good question...
05:59:55 <merijn> That'd be neat
06:01:02 <remdezx> Hello! Why "reads "0.1" :: [(Int, String)]" gives [] instead of [(0, ".1")] ?
06:01:59 <startling> > reads
06:02:01 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
06:02:01 <lambdabot>    arising from a use ...
06:02:10 <startling> > reads "0 .1"
06:02:11 <lambdabot>   []
06:02:15 <startling> huh.
06:02:42 <startling> > reads "0"
06:02:43 <lambdabot>   []
06:02:58 <srhb> > reads "0 .1" :: [(Int, String)]
06:02:59 <lambdabot>   [(0," .1")]
06:03:18 <startling> Oh. yeah, I think you need the space.
06:03:21 <monoidal> > reads "0.a" :: [(Int,String)]
06:03:22 <lambdabot>   [(0,".a")]
06:03:43 <remdezx> interesting
06:03:46 <haasn> > reads "0.1" :: [(Int,String)]
06:03:48 <lambdabot>   []
06:03:52 <srhb> Thaaat's a bug.
06:04:02 <srhb> Or seems like one for sure.
06:04:10 <remdezx> I need to parse something like ""1.2.3" as my datatype Version Int Int Int
06:04:14 <haasn> > reads ("0."++[undefined]) :: [(Int,String)]
06:04:16 <lambdabot>   *Exception: Prelude.undefined
06:04:18 <srhb> remdezx: Split at . ?
06:04:50 <ion> > (reads :: ReadS Int) ("0.0." ++ [undefined])
06:04:51 <lambdabot>   []
06:04:53 <haasn> let [a,b,c] = splitOn "." "1.2.3" in Version a b c
06:05:10 <remdezx> srbh: It was my first try, but I though I could do it as it should be done...
06:05:26 <haasn> oh, needs more ‘read’
06:05:27 <haasn> but you get the idea
06:06:13 <ion> You could also use Parsec or something. verList = nat `sepBy` char '.' where { nat :: Parser Integer; nat = read <$> many1 digit }
06:06:30 <haasn> Oh
06:06:40 <haasn> Read Int uses ‘readNumber’ which internally parses and then converts a single lexeme
06:06:45 <haasn> “0.1” is one, but “0.a” is two
06:06:53 <haasn> (or three, whatever)
06:07:01 <remdezx> haasn: sure, thanks. I though I could do it as in tutorials, but if it's a bug or sth I'll make it as you said
06:07:29 <srhb> haasn: Terrible behaviour.
06:08:14 <monoidal> > readDec "0.1"
06:08:15 <lambdabot>   [(0,".1")]
06:09:52 <merijn> remdezx: If you have GHC 7.6 you might want to simply use readMaybe from Text.Read
06:10:02 <remdezx> monoidal: thanks! It solves the problem :)
06:24:51 <peterbb> Is there some way to make ghci print the context (i.e. the local variables and their types) when an expression does not type check? Similar to how it's done in Coq.
06:25:29 <monoidal> peterbb: this is planned in 7.8, called TypeHoles
06:26:02 <peterbb> ok. Cool :)
06:26:10 <Hodapp> TypeHoles... hmmm.
06:26:49 <monoidal> the name is IMO unfortunate
06:31:13 <monoidal> (it should be just "holes", I think)
06:33:36 <yesthisisuser> Is there no generalized zip ... zap :: (Monad m) => m a -> m b -> m (a, b) ?
06:33:40 <yesthisisuser> zap one two = one >>= \a -> two >>= \b -> return (a, b)
06:33:50 <yesthisisuser> I mean is it not already defined somewhere?
06:34:09 <bennofs> yesthisisuser: it's liftA2 (,)
06:34:14 <bennofs> @ty liftA2 (,)
06:34:15 <lambdabot> Applicative f => f a -> f b -> f (a, b)
06:34:17 <yesthisisuser> ah..
06:34:21 <yesthisisuser> right
06:34:23 <yesthisisuser> thanks
06:34:30 <startling> merijn, it looks like it's not possible to require a typeclass for an associated type. Dang.
06:35:14 <monoidal> yesthisisuser: or liftM2 (,) [bit less general but might save from (Monad m, Applicative m) context.]
06:37:18 <b_jonas> @hoogle ziWithM
06:37:19 <lambdabot> No results found
06:37:23 <b_jonas> @hoogle zipWithM
06:37:23 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
06:37:23 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
06:37:23 <lambdabot> Data.Generics.Twins gzipWithM :: Monad m => GenericQ (GenericM m) -> GenericQ (GenericM m)
06:37:30 <b_jonas> yesthisisuser: ^
06:37:49 <b_jonas> hmm, maybe that's not what you wanted
06:37:54 <monoidal> zipWithM is bit different. it's sequence (zipWith f a b)
06:38:27 <b_jonas> monoidal: yeah
06:39:34 <yesthisisuser> liftA2 works in this case.. i just wanted to create an infix operator to pair two Maybes into a Maybe pair
06:44:59 <startling> merijn: oh, no, I figured it out. it's "class Functor (Associated r) => MyClass r where data Associated r; ..."
06:46:40 <srhb> So I'm looking at the UI.NCurses module from ncurses, and I'm pondering how to plumb it so that I can access my state as well as its various functions. I guess I need to make Update an instance of MonadState to do that easily, but how does one go about that?
06:47:31 <malvarez> Can anyone recommend a good text on the relationship between category theory and type theory?
06:49:45 <merijn> srhb: Orthogonal remark: Have you looked at vty/vty-ui?
06:49:54 <srhb> merijn: I have not, but I will do that. :)
06:50:44 <merijn> srhb: vty is a mostly haskell replacement of ncurses, vty-ui is a wrapper around it that has a bunch of existing widgets like text entry, button, containers, etc.
06:51:06 <srhb> merijn: I might as well rewrite what I have to use that, then.
06:52:02 <merijn> srhb: I have some complaints about the design, but those are mostly general complaints I have about any existing (G)UI framework atm, I wrote some simple stuff in it and it seemed better than straight up curses, at least
06:52:39 <srhb> merijn: For what little I have done so far, the ncurses library seemed fine. I did have that problem with accessing my state and making updates to the UI without throwing lift everywhere, though.
06:53:11 <merijn> It depends on how complicated you want things, I guess
06:53:57 <srhb> The UI right now is mostly to teach me the kind of things I'd have to deal with when moving around in a file buffer and such.
06:58:40 <ski> malvarez : perhaps "Categorical Logic and Type Theory" by Bart Jacobs at <http://www.cs.ru.nl/B.Jacobs/CLT/bookinfo.html> ?
06:58:46 <rofer> I'm a little confused with how module naming works. Say I have my project Foo with files Bar.hs and Baz.hs. I can put "module Foo.Bar" at the top of Foo and it compiles fine, but then I'm unsure how to include Baz from Bar.
06:59:18 <startling> is "data U a = [a] a [a]" provided by any well-recommended package?
06:59:32 <malvarez> ski: thanks! That looks exactly like what I'm looking for
06:59:37 <rofer> If I just "import Baz" while Baz.hs has "module Foo.Baz" I get an error, but if I "import Foo.Baz" then it doesn't find Baz.hs
06:59:38 <startling> rofer, make a directory "Foo" and put Bar.hs and Baz.hs in it.
07:00:10 <rofer> startling: And then do I just do "module Bar" and "module Baz"?
07:00:25 <rofer> because I already have them in a folder Foo
07:00:25 <startling> rofer, no, module Foo.Bar and module Foo.Baz.
07:00:55 <ski> malvarez : you might perhaps also want to look at some other text, about Categorical logic, and its relation between cartesian closed categories (and monoidal closed and star-autonomous categories, &c.) and good old Curry-Howard (and linear logic)
07:02:14 <rofer> startling: It's not finding
07:02:25 <rofer> (woops)
07:02:30 <startling> rofer: you're going to have to give us more information, then.
07:03:08 <malvarez> ski: any suggestions on that?
07:03:46 <ski> malvarez : hm, various papers which i forgot who wrote them ..
07:03:55 <rofer> startling: I have Bar.hs and Baz.hs in Foo/ with "module Foo.Bar" and "module Foo.Baz". If I try and "import Foo.Baz" from Bar.hs I get "Could not find module Foo.Baz"
07:04:17 <ski> there's a book (classic, iiuc) by Lambek on Categorical Logic
07:04:26 <ski> (i have only browsed it a little)
07:04:51 <startling> rofer, oh. Make sure you're running these from the top level (i.e., the directory that contains Foo).
07:05:09 <startling> What's this (~) thing all the cool new lenses are using?
07:05:13 <ski> malvarez : but it's good to be aware that cartesian closed categories aren't the end-all-be-all
07:05:32 <merijn> rofer: What directory are you in when you run import?
07:05:39 <malvarez> ski: how so? I assume they can't model substructural logics?
07:05:49 <ski> right
07:05:58 <merijn> rofer: For uninstalled libraries it will look starting from the current directory. If you're inside the Foo directory, it will break
07:07:03 <malvarez> ski: well, for starters I'll take a look at Jacobs' book, thank
07:07:06 <rofer> So, I need to put my Makefile in the directory that contains Foo/?
07:07:25 <ski> malvarez : also not quite what you're asking about, but "Proofs and Types" by Jean-Yves Girard in 1987-1990, with appendices by Paul Taylor and Yves Lafont at <http://www.paultaylor.eu/stable/Proofs+Types.html> might be interesting, if you haven't seen it before
07:07:48 <ski> s/not quite/not really/
07:08:10 <malvarez> ski: yeah, I really enjoyed (what little I read) of that one
07:08:14 <startling> rofer, or a directory above it, yeah. using Makefiles for Haskell is kind of unusual, though.
07:08:30 <startling> is there a data Pair a = Pair a a somewhere?
07:09:43 <rofer> startling: I have to pass stuff to GHC every time I compile, is there a better way to do that?
07:10:04 <startling> rofer, what stuff do you need to pass to GHC?
07:10:18 <ocharles> rofer: if you have a cabal file, you can use the 'ghc-options' key
07:10:21 <malvarez> roefer: Isn't Cabal the haskell-ish way to do that?
07:10:24 <startling> Yeah.
07:10:34 <bergmark> startling: that's (a,a)
07:10:45 <ocharles> bergmark: no, (a,a) :: (a, a)
07:10:55 <malvarez> bergmark: That's slightly different, because you could make Pair an instance of Functor
07:11:10 <rofer> startling: Right now just -hide-package, I feel like there's a way to sandbox my project so I don't need that, but I don't really know how
07:11:12 <startling> Yeah, I need a * -> * one.
07:11:14 <ocharles> yea, and (a, a) is a bifunctor
07:11:21 <merijn>  malvarez Well, you can make tuple a functor instance too, but it's a different one :)
07:11:25 <startling> rofer, cabal is the way.
07:11:25 <rofer> This is my first Haskell project in quite a while
07:11:33 <ocharles> merijn: you can't make (,) a functor, only (a,)
07:11:42 <merijn> ocharles: pfft, details
07:12:01 <startling> rofer, your .cabal file has a list of version bounds and everything to use.
07:12:11 <startling> oh, I guess bifunctors might have a thing.
07:12:19 <rofer> startling: Ah, I guess I'll switch to that then
07:12:21 <startling> (is it called "Me"?)
07:12:33 <rofer> This project largely exists so I can get better at this stuff
07:12:37 * ski . o O ( `Functor (Join (,))' )
07:12:56 <startling> ski: haha
07:13:00 <merijn> rofer: Also, the latest cabal version supports sandboxes :)
07:13:57 <malvarez> Has anyone defined type-level SKI combinators?
07:14:11 <startling> malvarez, almost!
07:14:21 <startling> oh, wait, no, it's here: http://www.haskell.org/haskellwiki/Type_SK
07:14:32 <merijn> rofer: Just running "cabal init" and following the instructions and reading the comments in the generated file is a pretty good way to get started with cabal
07:14:41 <malvarez> startling: that's awesome
07:14:42 <startling> cabal init is so nice.
07:14:59 <startling> I find myself putting off cabalizing a project just so I can make cabal init do most of the work.
07:15:13 <malvarez> startling: but in a more practical way, you might want some kind of type-level combinators so that you can write an instance for Functor (,a), right?
07:15:40 <merijn> malvarez: You can do that using newtypes (unfortunately this adds some noise, you need unwrap it at the end)
07:15:45 <rofer> merijn: startling: Thanks
07:16:04 <startling> malvarez: I don't need the instance. I'm just doing a type family thing so I need a thing of kind * -> * that holds two values of the type argument.
07:16:10 <ski> .. aka the warbler
07:17:06 * startling feeds ski to a Quizzical Bird
07:24:16 <rofer> Still a bit confused about how my directory structure should look. Should I have Foo/Foo.cabal, then Foo/Foo/Bar.hs and Foo/Foo/Baz.hs because that seems pretty silly
07:24:53 <startling> rofer, that's what you normally do, yeah.
07:25:03 <startling> rofer, you might have Foo/src/Foo/Bar.hs etc instead.
07:25:22 <rofer> startling: Hmm, that second one feels a bit nicer, thanks
07:25:44 <startling> makes it clearer that the top Foo is your "project directory"
07:27:22 <quchen> I'm confused about Network.PortNumber's Ord instance. The source says it's just a Word16 newtype with derived Ord, but "sort [2101, 2002] :: [PortNumber]" evaluates to "[2101, 2002]".
07:27:54 <quchen> When I take out a zero each it results in the desired behaviour though.
07:27:54 <merijn> rofer: See also http://www.haskell.org/haskellwiki/Structure_of_a_Haskell_project
07:28:02 <fizruk> > 2101 < (2002 :: Word16)
07:28:03 <lambdabot>   False
07:28:18 <startling> > sort [2101 :: Word16, 2002]
07:28:19 <lambdabot>   [2002,2101]
07:28:31 <startling> quchen: weird.
07:28:48 <quchen> Can you try reproducing it in your GHCi? I'm on 7.6.3, maybe it's a bug somewhere?
07:28:53 <startling> > sort [2101 :: PortNumber, 2002]
07:28:54 <lambdabot>   Not in scope: type constructor or class `PortNumber'
07:29:48 <startling> where is Network.PortNumber from?
07:29:57 <quchen> http://hackage.haskell.org/package/network-2.4.2.0/docs/src/Network-Socket-Types.html#PortNumber
07:29:58 <startling> oh, that's a type, not a module.
07:30:45 <quchen> Proof for the unbelieving: http://i.imgur.com/rrVmJie.png
07:30:58 <startling> quchen, reproduced on 7.6.3
07:31:47 <quchen> I guess I'll ask in #ghc for someone with HEAD to reproduce it. Smells like the derived Ord instance is wrong.
07:32:13 <fizruk> quchen, have you checked if sort works properly on Word16? :)
07:32:22 <merijn> wait!
07:32:41 <merijn> hmm, no
07:32:47 <quchen> sort [2101, 2002] :: [Word16]
07:32:47 <quchen> [2002,2101]
07:32:48 <startling> quchen, oh, is it a network byte order thing?
07:32:50 <ski> startling : i don't know that one
07:33:13 <quchen> startling: The source code literally says "newtype PortNumber = PortNum Word16 deriving (Eq, Ord, Typeable)"
07:33:17 <quchen> No networking involved
07:33:31 <startling> quchen: sure. What about the Num instance?
07:33:37 <quchen> Aaaaah.
07:33:48 <quchen> You're quite a detective :-D
07:33:57 <startling> fromInteger i = intToPortNumber (fromInteger i)
07:34:21 <startling> intToPortNumber v = PortNum (htons (fromIntegral v))
07:34:24 <quchen> foreign import CALLCONV unsafe "ntohs" ntohs :: Word16 -> Word16
07:34:25 <quchen> …
07:34:45 <startling> http://linux.die.net/man/3/htons
07:34:45 <monoidal> i would look at the show instance
07:35:25 <monoidal>  showsPrec p pn = showsPrec p (portNumberToInt pn)
07:35:35 <startling> monoidal: sure. Same thing, but in reverse.
07:35:37 <quchen> And that calls ntohs
07:35:52 <monoidal> fromInteger should not matter, since sort [2101,2002] should be the same as sort [2002, 2101]
07:36:08 <startling> monoidal, it is.
07:36:40 <startling> The deal is that they're sorted in network byte order but output and input in host byte order.
07:36:41 <EarlGray> Hello all
07:36:55 <EarlGray> How to parse C-like comments with Parsec?
07:37:21 <quchen> Okay, at least "sort . reverse" leaves the result invariant :-)
07:37:35 <bartavelle> EarlGray, take a look at http://beta.hackage.haskell.org/package/parsec-3.1.3/docs/Text-Parsec-Token.html
07:37:54 <bartavelle> I suppose one of the language is close enough
07:38:04 <bartavelle> (in Text.parsec.Language)
07:38:46 <EarlGray> bartavelle: thanks, I suspected it's not in Text.ParserCombinators.Parsec
07:39:32 <bartavelle> you should not use stuff that's in ParserCombinators
07:39:34 <bartavelle> it's deprecated
07:40:18 <merijn> EarlGray: Do you want to parse them like C does or supporting nested comments?
07:40:39 <quchen> "The ntohs() function converts the unsigned short integer netshort from network byte order to host byte order." -- Ah, that explains it. Good call startling
07:41:03 <quchen> I thought "hs" was Haskell-related and furiously grepped through the soure ;-)
07:41:10 <startling> heh.
07:41:15 <EarlGray> just like C does, without nested comments
07:42:08 <merijn> I thought there were some defaults like that predefined to use
07:43:25 <bartavelle> merijn, EarlGray : java has C-like comments, you can just reuse this http://beta.hackage.haskell.org/package/parsec-3.1.3/docs/src/Text-Parsec-Language.html#javaStyle
07:43:35 <merijn> Yeah, I was about to link that
07:48:14 <EarlGray> but anyway, how to just do non-greedy parser for /* */ ?
07:48:24 <EarlGray> Is defining a language for Parsec the way to go?
07:49:06 <EarlGray> I am writing gas-like assembly parser now and it's quite simple to be handled manually, I think
07:51:18 <bartavelle> EarlGray, if you do want to use Parsec, this is the way to go
07:51:57 <bartavelle> you'll just have to import the token module qualified and redefine non qualified versions of the tokenizers you need if you do not want to get crazy
07:54:00 <EarlGray> ok, it looks like I need to read Parsec code first
07:55:07 <EarlGray> because I have no idea where to start with custom tokenizers (I just read the chapter about parsec in RWH, and it already uses deprecated interfaces)
07:59:09 <udevd> hi
07:59:29 <udevd> i've heard about bot that can shorten long haskell expressions... how do i use it?
07:59:45 <udevd> i have in particular (a(b!!c))>>=d
08:00:09 <quchen> You can make them pointfree here, but that's rarely making it any shorter or easier to read.
08:00:30 <udevd> are you talking to me :D?
08:00:32 <quchen> I haven't seen a "refactor this" function here yet.
08:00:32 <startling> udevd, a (b !! c) >>= d
08:00:44 <udevd> no, it doesn't work
08:00:52 <udevd> or, let me see
08:00:55 <startling> udevd, it's the same code.
08:01:06 <startling> if it doesn't work, no shortening will make it work.
08:01:09 <udevd> ...because a $ b!!c >>=d does not
08:01:10 <udevd> okay
08:01:19 <startling> udevd: right, that's different.
08:01:25 <quchen> a $ b!!c >>=d   ==   a $ (b!!c >>=d)
08:01:40 <udevd> yep, i just realised that
08:01:56 <startling> udevd: it seems almost silly to try to shorten such a short expression.
08:02:43 <monoidal> udevd: regarding shortening, you can use hlint to find common ugly patterns
08:03:08 <startling> @pl a (b !! c) >>= d
08:03:12 <lambdabot> a (b !! c) >>= d
08:03:12 <lambdabot> optimization suspended, use @pl-resume to continue.
08:03:24 <quchen> startling: That's already pointfre :-P
08:03:33 <quchen> @pl \a b c d -> a (b !! c) >>= d
08:03:33 <lambdabot> (((>>=) .) .) . (. (!!)) . (.)
08:03:42 <startling> quchen: oh, right.
08:04:17 <udevd> what does the dot mean in this expression?
08:04:25 <monoidal> function composition
08:04:26 <startling> udevd: ^^^ there's your "shorter" version. :)
08:04:30 <udevd> xD
08:04:35 <udevd> ah, okay
08:04:41 <monoidal> (x .) is section
08:05:00 <udevd> yeah, i'm just quite tired and in first place didn't seen this
08:05:01 <udevd> :D
08:05:09 <t7> @unpl (((>>=) .) .) . (. (!!)) . (.)
08:05:09 <lambdabot> (\ i o r -> (>>=) (i (o !! r)))
08:05:47 <t7> @unpl (.) . (.)
08:05:47 <lambdabot> (\ i b c f -> i (b c f))
08:05:56 <t7> @unpl (.) . (.) . (.)
08:05:56 <lambdabot> (\ l b c f i -> l (b c f i))
08:06:02 <monoidal> @pl  \a b c -> (a (b !! c) >>=)
08:06:02 <lambdabot> (((>>=) .) .) . (. (!!)) . (.)
08:11:37 <HugoDaniel> hi
08:13:16 <HugoDaniel> how can i choose the number of decimal numbers in a Double ?
08:13:25 <HugoDaniel> without doing some awkward multiplication/divisions
08:13:28 <tdammers> what do you mean, "choose"
08:13:42 <tdammers> a Double is an IEEE float, not a decimal type
08:13:44 <haasn> Double has a fixed, well-defined definition
08:13:47 <HugoDaniel> haskell sometimes freaks out and gives me stuff like 1.00000000000001
08:13:52 <geekosaur> that's nothaskell
08:13:54 <HugoDaniel> i just want 1.00
08:13:55 <haasn> that's correct
08:13:56 <geekosaur> that's floating point
08:14:10 <HugoDaniel> yes
08:14:16 <geekosaur> I can get you people complaining about THAT BUG!!!1! in every programming language that supports IEEE doubles
08:14:17 <elliott> just use Rational.
08:14:27 <geekosaur> if you want precise representation, use Rational or Fixed
08:14:30 <HugoDaniel> but still, how can i do it 1.00 without multiplying/div ?
08:14:52 <tdammers> depends on how you arrive at that value
08:14:52 <HugoDaniel> ok
08:14:53 <HugoDaniel> thanks
08:15:07 <HugoDaniel> tdammers its a simple read on a string
08:15:11 <haasn> Rational is good if you need only operations with exact rational results; otherwise Fixed lets you represent floating point numbers with fixed precisions (that don't suffer from the same wierdness of IEEE floats in certain places, eg. Infinity/NaN/etc.)
08:15:20 <geekosaur> or use Text.Printf to display only a particular precision while still using Float/Double
08:15:43 <tdammers> > read "1" :: Double
08:15:44 <geekosaur> (although I gotta think there should be a better way to do that... printf, in haskell, furrfu)
08:15:44 <lambdabot>   1.0
08:15:55 <haasn> CReal lets you compute exact decimal representations (up to an arbitrary but finite precision), but it's *very* slow
08:16:01 <tdammers> a simple read from a string gives 1.0 exactly
08:16:03 <udevd> > read "1" :: Char
08:16:04 <lambdabot>   *Exception: Prelude.read: no parse
08:16:06 <HugoDaniel> k
08:16:06 <udevd> > read "1" :: String
08:16:07 <lambdabot>   "*Exception: Prelude.read: no parse
08:16:08 <HugoDaniel> thanks :D
08:16:12 <merijn> geekosaur: iknorite, "hey guys, I get weird precission artifacts with floats, this language sucks!"
08:16:15 <udevd> > read "\"1\"" :: String
08:16:17 <lambdabot>   "1"
08:16:34 <merijn> > read "'1'" :: Char
08:16:35 <lambdabot>   '1'
08:16:37 <startling> Doesn't Java or something try to detect and hide them?
08:16:44 <tdammers> however:
08:16:52 <merijn> startling: So does python when displaying
08:16:53 <tdammers> > (1 / 3) * 3 :: Double
08:16:55 <lambdabot>   1.0
08:16:56 <tdammers> hmm
08:17:00 <tdammers> wait
08:17:03 <startling> merijn: I'm pretty sure that's not the case.
08:17:15 <merijn> startling: Unless they changed it, it most certainly is
08:17:33 <tdammers> > pi / pi :: Double
08:17:34 <lambdabot>   1.0
08:17:36 <tdammers> bleh
08:17:41 <startling> merijn, #python has gotten this question at least weekly since 2009, when I started going there.
08:17:44 <allsystemsarego> hi all, after running cabal update and cabal install takusen, I get: http://lpaste.net/94589 any help?
08:17:54 <merijn> startling: Straught from the docs
08:17:57 <merijn> >>> 0.1
08:17:57 <merijn> 0.1000000000000000055511151231257827021181583404541015625
08:17:58 <merijn> That is more digits than most people find useful, so Python keeps the number of digits manageable by displaying a rounded value instead
08:18:21 <startling> oh. that's just "%.10f" or whatever by default.
08:18:26 <merijn> It’s easy to forget that the stored value is an approximation to the original decimal fraction, because of the way that floats are displayed at the interpreter prompt. Python only prints a decimal approximation to the true decimal value of the binary approximation stored by the machine.
08:18:34 <merijn> ^
08:19:07 <haasn> What kind of representation is that? That permits 0.1000000000000000055511151231257827021181583404541015625
08:19:21 <startling> Yeah, I think that might be a lie.
08:19:22 <merijn> haasn: ...IEEE754?
08:19:39 <startling> >>> 0.1000000000000000055511151231257827021181583404541015625
08:19:39 <startling> 0.1
08:19:42 <startling> :/
08:19:56 <merijn> allsystemsarego: System.IO.Error stopped exporting error handling functions
08:20:04 <tdammers> > (0.1 ** 100) * (10 ** 100) :: Double
08:20:05 <haasn> merijn: binary128?
08:20:05 <lambdabot>   1.0000000000000056
08:20:18 <tdammers> there you go
08:20:19 <merijn> allsystemsarego: takusen should be updated to use try from Control.Exception
08:20:46 <merijn> haasn: How so?
08:20:51 <allsystemsarego> ok, thanks, I'll notify the maintainer
08:21:09 <merijn> haasn: I didn't check, but I assume that's just 64bit float or whatever
08:21:17 <simpson> > 0.1 :: CReal
08:21:19 <lambdabot>   0.1
08:21:28 <haasn> It's just that my intuition tells me that's an awful lot of digits for 64 bit precision
08:21:39 <simpson> > (0.1 ** 100) * (10 ** 100) :: CReal
08:21:40 <lambdabot>   1.0
08:21:54 <simpson> Ah, CReal is so magical~
08:22:22 <haasn> > (0.1 ^ 100) * (10 ^ 100) :: Rational
08:22:23 <lambdabot>   1 % 1
08:22:38 <udevd> wut
08:22:43 <merijn> haasn: I don't think you can map digit length to bit representation that easily
08:23:02 <merijn> udevd: % is rational notation for a fraction, so 1%1 would be "1/1" (i.e. 1)
08:23:02 <udevd> > read "1 % 3" :: Rational
08:23:03 <lambdabot>   1 % 3
08:23:07 <udevd> i c
08:23:23 <merijn> For modulo you want "mod" in Haskell
08:23:28 <merijn> > 5 `mod` 3
08:23:29 <lambdabot>   2
08:24:15 <quchen> Or `rem`, depending on what behaviour you want for negative numbers.
08:24:42 <haasn> merijn: Double should be an IEE754 double as well, right? Would that imply that I can get the 0.1000000000000...625 representation out of (0.1 :: Double) as well? If so, how?
08:24:58 <merijn> > 0.1
08:24:59 <lambdabot>   0.1
08:25:03 <merijn> > 0.1 :: Double
08:25:05 <lambdabot>   0.1
08:25:14 <udevd> >0.100000000000000000000000000000000000625 :: Double
08:25:18 <merijn> haasn: Haskell is messing around with show of Double too
08:25:19 <ski> > toRational 0.1
08:25:20 <lambdabot>   3602879701896397 % 36028797018963968
08:25:28 <merijn> haasn: 0.1 is not representable in IEEE754
08:25:39 <haasn> > 3602879701896397 / 36028797018963968 :: CReal
08:25:40 <lambdabot>   0.1000000000000000055511151231257827021182
08:25:46 <haasn> there we go
08:26:43 <haasn> > (fromRational . toRational) 0.1 :: CReal
08:26:44 <lambdabot>   0.1000000000000000055511151231257827021182
08:26:56 <haasn> (is that a function somewhere, incidentally?)
08:27:01 <ciaranm> just to confuse you, though, Double calculations aren't necessarily carried out at Double precision
08:27:33 <merijn> > logBase 2 (maxBound :: Int)
08:27:34 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
08:27:35 <lambdabot>    arising from a use of...
08:27:47 <merijn> > logBase 2 (fromIntegral (maxBound :: Int))
08:27:48 <lambdabot>   30.999999999328193
08:27:49 <ski> > decodeFloat 0.1
08:27:50 <lambdabot>   (7205759403792794,-56)
08:27:52 <ski> > (exponent &&& significand) 0.1
08:27:53 <lambdabot>   (-3,0.8)
08:28:44 <lpaste> ghorn pasted “derive generic vector exception” at http://lpaste.net/94590
08:29:00 <merijn> ciaranm: Much like C, the more I know about floats, the more I realise I know jack all about floats and the odds of me writing bug free float code are pretty much zero...
08:29:04 <ghorn> i couldn't find anything on google about this ghci exception ^
08:29:20 <ski> @@ @hoogle @type fromRational . toRational
08:29:22 <merijn> I rate my ability to write bugless C only slightly higher than bugless float code
08:29:23 <lambdabot>  Prelude realToFrac :: (Real a, Fractional b) => a -> b
08:29:23 <lambdabot>  Unsafe.Coerce unsafeCoerce :: a -> b
08:29:23 <lambdabot>  Prelude ($) :: (a -> b) -> a -> b
08:29:35 <haasn> Ah, realToFrac
08:30:00 <ski> @where floating-point
08:30:00 <lambdabot> "What Every Programmer Should Know About Floating-Point Arithmetic" at <http://floating-point-gui.de/> and "What Every Computer Scientist Should Know About Floating-Point Arithmetic" by David
08:30:01 <lambdabot> Goldberg in 1991 at <http://docs.sun.com/source/806-3568/ncg_goldberg.html> and <http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.102.244>
08:30:19 <merijn> ski: Anyone who actually knows all that is insane :)
08:30:33 <monoidal> ghorn: ghc version? might be http://ghc.haskell.org/trac/ghc/ticket/5884
08:30:44 <ghorn> 7.6.3
08:31:15 <haasn> The best way to avoid floating point bugs is to never inspect floating point values, imo
08:31:36 <monoidal> ghorn: it's a GHC bug, still unfixed in head.
08:31:47 <monoidal> ghorn: i'll look at it a bit more.
08:33:10 <ghorn> monoidal: did you find a ticket, or just try it yourself?
08:33:35 <monoidal> ghorn: I tested it myself. it's definitely a bug, if you compile with ghc (not interactive mode), you'll see a panic.
08:37:19 <sajt__> hi, I have an issue with HDBC.ODBC: my problem is that some drivers don't allow you to call SQLGetData (used for data that doesn't fit into a single buffer) on columns that already have been bound
08:37:22 <monoidal> ghorn: it seems Generic1 runs into trouble with Array#
08:37:59 <sajt__> but HDBC.ODBC calls bind on every column and uses SQLFetch to normally retrieve the data
08:38:29 <ghorn> monoidal: is Data.Vector.Generic is relevant?
08:38:40 <sajt__> only when SQLFetch returns 'This didn't fit into the buffer' it decides to call SQLGetData
08:38:47 <monoidal> ghorn: the defn of Vector uses Array which in turn uses Array#
08:39:02 <sajt__> then I get an SQLERROR because the column is already bound
08:39:18 <sajt__> any ideas what I could do about this?
08:39:26 <monoidal> ghorn: I don't know much about Generic1, there should be a way to manually derive it as a workaround
08:39:50 <ghorn> monoidal: ok, i will look into that, thanks
08:40:09 <ghorn> monoidal: should I file a new bug report?
08:40:11 <sajt__> to know that the content is large I need to bind the column and call SQLFetch, but in order to actually get the large data I need SQLGetData, but it only works on unbound cols
08:40:58 <lpaste> monoidal annotated “derive generic vector exception” with “derive generic vector exception (annotation)” at http://lpaste.net/94590#a94591
08:41:03 <allsystemsarego> hi all, here's my situation - I just e-mailed the maintainers of Takusen about a bug that causes the installation of it via cabal, to fail. While I'm waiting for a response, what would people recommend as the most reliable, well-maintained, well-tested DBMS access library? (I need to connect to both Oracle and MySQL natively from Linux)
08:41:44 <monoidal> ghorn: yes; I annotated your paste with a smaller testcase, not relying on Vector
08:43:45 <monoidal> ghorn: with deriving Generic1 we get "Can't make a derived instance of `Generic1 Array': Array must not have unlifted or polymorphic arguments" - so it seems the check is not done recursively on used types
08:43:56 <monoidal> ghorn: * deriving Generic1 on Array
08:45:19 <bxc> allsystemsarego: i do everything with HDBC
08:45:24 <monoidal> ghorn: answering earlier question, Data.Vector.Generic is not relevant to Generic
08:45:48 <allsystemsarego> bxc, how do you connect to Oracle?
08:46:15 <bxc> allsystemsarego: i don't
08:46:38 <bxc> allsystemsarego: i think you can go hdbc->odbc->oracle? not sure though
08:46:38 <cariveri> hi there.
08:46:44 <cariveri> Could not find module `Text.Parsec.Indent'
08:46:56 <cariveri> what can I do abotu that?
08:47:04 <monoidal> cabal install indents
08:47:48 <monoidal> not sure if that package is not rusty though
08:48:56 <cariveri> I use  ubuntu packages.
08:50:52 <ghorn> monoidal: thanks for the clarification
08:50:53 <cariveri> monoidal: thank you. I fogort that I had cabal installed too. it worked.
08:51:02 <ghorn> monoidal: heres the new bug report http://ghc.haskell.org/trac/ghc/ticket/8468
08:51:29 <monoidal> dreixel: bug regarding Generic1: http://ghc.haskell.org/trac/ghc/ticket/8468
08:52:38 <dreixel> monoidal: thanks, just assigned it to myself :)
08:55:32 <merijn> allsystemsarego: btw, that bug should be fairly trivial to fix, you could try fixing it yourself and then using takusen anyway?
08:55:47 <merijn> allsystemsarego: With some luck it's literally adding 1 import line
08:56:40 <merijn> allsystemsarego: i.e. just add "import Control.Exception (try)" to whatever file is complaining and replace any references to System.IO.Error.try to that, I think that should work
08:58:02 <allsystemsarego> merijn, so unpack first, make the changes, then cabal configure, and then cabal install?
08:58:24 <merijn> allsystemsarego: Well, you can just do "cabal install" directly, it should automatically configure, but yes.
08:58:35 <allsystemsarego> ok, thanks
08:58:46 <merijn> allsystemsarego: That's the approach I usually take to fix simple issues like this/version problems
08:59:07 <merijn> allsystemsarego: Don't forget to mail a diff to the maintainer :)
08:59:25 <allsystemsarego> ok, will do
09:03:19 <startling> This "Learn Haskell Fast and Hard" thing seems to make all the usual Monad/IO mistakes. :/
09:03:37 <bergey`> is there a lens defined somewhere for Data.Semigroup.Max?
09:03:56 <bergey`> I'd like to cleanup: over (inEnvelope . mapped) ((Max .) . t . (getMax .))
09:04:36 <startling> bergey`, take a look at "wrapped".
09:04:47 <bergey`> startling: thanks!
09:05:20 <int-e> startling: living up to the promise of being hard? :)
09:05:50 <startling> bergey`: well, unwrapped.
09:07:05 <startling> Hmm, maybe that instance doesn't exist.
09:07:14 <int-e> ah. main :: IO (). "This means main will cause side effects." ... and I'm starting to disagree.
09:07:35 <startling> :t lens Max getMax
09:07:35 <lambdabot> Not in scope: data constructor `Max'
09:07:36 <lambdabot> Not in scope: `getMax'
09:08:22 <Iceland_jack> int-e: main = return () causes the side-effect of people wondering why nothing happened!
09:08:39 <int-e> Iceland_jack: I stand corrected.
09:09:20 <bennofs> > wrapped # 3 :: Max Int
09:09:25 <lambdabot>   Not in scope: type constructor or class `Max'
09:09:26 <lambdabot>  Perhaps you meant `M.Map' (i...
09:09:27 <int-e> (But I was really thinking about  main `seq` "foo", which will evaluate to "foo" without side effects.)
09:09:54 <int-e> (Barring uses of unsafe*)
09:10:10 <startling> unsafeConfuseBystanders
09:10:24 <Iceland_jack> Well the author didn't specify execution or evaluation
09:10:25 <bennofs> > wrapped # 3 :: Max Int
09:10:27 <lambdabot>   No instance for (Control.Lens.Wrapped.Wrapped
09:10:27 <startling> bergey`, this instance should probably exist.
09:10:27 <lambdabot>                     s0 (Data....
09:10:50 <bergey`> which instance?
09:10:50 <int-e> Iceland_jack: Right. Then, to me, evaluation is the default.
09:10:57 <int-e> This is Haskell after all :)
09:10:59 <Iceland_jack> heh
09:11:13 <int-e> @quote variables
09:11:13 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of
09:11:13 <lambdabot> these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
09:11:19 <bergey`> Defining `lens Max getMax` at the point of use feels dirty.  Wrapped seems nicer to me.
09:11:26 <startling> bergey`: the instance Wrapped (Max a) (Max b) a b or whatever.
09:11:36 <int-e> (right quote in one try, I'm so lucky)
09:11:41 <bennofs> :t iso getMax Max
09:11:42 <lambdabot> (Functor f, Profunctor p) => p a (f b) -> p (Max a) (f (Max b))
09:11:50 <Iceland_jack> I'd say ‘IO = side-effects’ is a decent white lie to tell newcomers
09:12:12 <startling> bergey`, if you wanted to you could probably add it to lens pretty easily, but it'd be for lens 4.0.
09:12:19 <int-e> Iceland_jack: but a hard tutorial should get it right the first time.
09:12:31 <Iceland_jack> Yes I agree with that
09:12:31 <bergey`> startling: Meaning I should write it, test it in my code, and submit a pull request?  Can do.
09:12:31 <alllex220> Iceland_jack: why you think its a lie?
09:12:44 <Iceland_jack> well because IO doesn't imply side-effects
09:12:48 <startling> bergey`: well, Wrapped is slightly different (and a lot nicer) in HEAD>
09:12:54 <Iceland_jack> case in point “return ()”
09:12:59 <alllex220> IO in haskell or in general?
09:13:06 <Iceland_jack> IO type in Haskell
09:13:38 <alllex220> ah k
09:13:47 <startling> bergey`, inspiration: https://github.com/ekmett/lens/blob/master/src/Control/Lens/Wrapped.hs#L140
09:14:11 <pyr> hi, I feel I'm not grasping some of the subtleties of working with IO. When confronted with a list of IO String, I cannot get to do any sort of computation of them, due to not handling them in the right order
09:14:30 <pyr> when working on a single (IO x) value, fmap or do blocks work just fine
09:14:34 <startling> bergey`: and in lens 3.* : http://hackage.haskell.org/package/lens-3.10/docs/src/Control-Lens-Wrapped.html#Wrapped
09:14:36 <zq> :t error
09:14:37 <lambdabot> [Char] -> a
09:14:45 <Iceland_jack> pyr: Is your question ‘how to get an IO value from [IO String]’?
09:14:52 <pyr> yes
09:14:56 <Iceland_jack> @ty sequence
09:14:57 <lambdabot> Monad m => [m a] -> m [a]
09:14:58 <bergey`> startling: Good to know, thanks.  I'll take a look at the HEAD version once I wrap my head around the current syntax.  (With apologies for the mostly unintended pun.)
09:14:59 <zq> [Char] -> a suggests that 'error' is a pure function, but it's not
09:15:05 <Iceland_jack> @ty sequence [getLine, getLine]
09:15:06 <lambdabot> IO [String]
09:15:19 <startling> bergey`: it's a type families thing.
09:15:34 <pyr> Iceland_jack: so sequence [IO String] yields IO [String] ?
09:15:37 <Iceland_jack> Then you can use the normal do-notation or what ever you prefer to operate on the values
09:15:38 <Iceland_jack> Yes
09:15:42 <pyr> nice
09:15:52 <Iceland_jack> > sequence [Just 1, Just 2, Just 3]
09:15:53 <lambdabot>   Just [1,2,3]
09:15:56 <Iceland_jack> > sequence [Just 1, Nothing, Just 3]
09:15:57 <lambdabot>   Nothing
09:16:32 <startling> :t sequence $ replicate 3 getLine
09:16:33 <lambdabot> IO [String]
09:16:45 <Iceland_jack> :t replicateM 3 getLine
09:16:46 <lambdabot> IO [String]
09:16:51 <Iceland_jack> :t length <$> replicateM 3 getLine
09:16:51 <lambdabot> IO Int
09:17:02 <monoidal> zq: it depends on how you look at it. it can be argued that _|_ is not impure, it's simply an undefined value
09:17:06 <startling> Iceland_jack: I knew someone was going to do that.
09:17:28 <monoidal> pyr: many functions ending in M (mapM, replicateM, zipWithM) are equivalents of their non-M versions composed with sequence
09:17:37 <Iceland_jack> startling: Sorry, I didn't intend to obfuscate your example
09:18:19 <monoidal> pyr: (for example, mapM print [1,2,3] is the same as sequence (map print [1,2,3]) which is the same as sequence [print 1, print 2, print3])
09:18:32 <pyr> ack
09:18:38 <pyr> makes sense
09:18:47 <zq> monoidal: how does bottom tie into error?
09:18:59 <Iceland_jack> pyr: But since print has a rather un-interesting return value, you probably want mapM_
09:19:05 <startling> zq, error x is like a bottom that GHC recognizes and tells the user about.
09:19:08 <monoidal> zq: "error <anything>" has denotation _|_.
09:19:09 <Iceland_jack> @ty mapM print "testing"
09:19:09 <lambdabot> IO [()]
09:19:11 <Iceland_jack> @ty mapM_ print "testing"
09:19:12 <lambdabot> IO ()
09:19:40 <startling> zq: rather than the usual bottom: nontermination.
09:22:13 <ddosen> hey all - I'm trying to install ghc-mod on macos - and have an error running cabal install - related to a dependency in monad-control-0.3.2.1 -     warning: control reaches end of non-void function [-Wreturn-type]
09:22:13 <ddosen> int foo() {}
09:22:17 <ddosen> Any ideas?
09:22:23 <flaritycat> Anyone knows of a good tutorial for teaching a 9year old haskell?
09:22:40 <scriptor> flaritycat: learn you a haskell?
09:23:03 <ddosen> Is Learn You a Haskell for Great Good too much for a nine year old?
09:23:27 <flaritycat> scriptor: Well, I scrabbled thru that some week ago.
09:23:33 <joelteon> @. pl undo do { m <- hGetContents h; n <- hGetContents h1; return (m,n) }
09:23:34 <flaritycat> Seems a bit much, but could work.
09:23:36 <lambdabot> hGetContents h >>= (hGetContents h1 >>=) . (return .) . (,)
09:23:36 <lambdabot> optimization suspended, use @pl-resume to continue.
09:23:38 <scriptor> maybe, but I can't think of many Haskell resources for complete beginners to programming
09:23:49 <Iceland_jack> Teaching a 9 year old programming in general requires a completely different approach, this goes for any programming language
09:23:51 <flaritycat> Merely learning the basics I guess.
09:23:55 <scriptor> flaritycat: you'll likely have to hold their hand much of the way
09:24:17 <flaritycat> scriptor: I did some test's on paper, they were 100% without any information given.
09:24:19 <monoidal> joelteon: liftM2 (,) (hGetContents h) (hGetContents h1) ?
09:24:33 <joelteon> right
09:24:33 <flaritycat> Just the problem not any other info.
09:24:34 <ddosen> Any advice on ghc-mod? I'm trying to get syntastic to work with vim
09:24:36 <scriptor> flaritycat: why do you want to teach them Haskell in particular?
09:24:48 <foeniks> as I understand the addition operator is part of the Num class. Now I wanted to use the + operator for a datatype which does not implement the multiplication or "fromInteger" for example?
09:24:50 <foeniks> or is this unwise
09:25:04 <flaritycat> scriptor: It's either that or ASM I guess.
09:25:07 <flaritycat> Maybe python
09:25:09 <foeniks> I do not necessarily want to implement the Num class
09:25:10 <Iceland_jack> foeniks: It's sometimes done, where multiplication = undefined …
09:25:20 <scriptor> ASM is definitely far too much for a 9 year old
09:25:27 <monoidal> foeniks: it's unwise, but you can implement the Num class and leave remaining methods undefined
09:25:45 <Iceland_jack> It's a result of the catch-all design of the Num class
09:25:47 <flaritycat> scriptor: I would like to start with the most logic and pure language.
09:26:08 <Sculptor> scriptor, logo
09:26:23 <Sculptor> let that turtle run around
09:26:26 <scriptor> flaritycat: I think that would work well for someone with some background in math
09:26:41 <scriptor> but a 9 year old is far more interested in seeing the results of their work than a theoretical foundation
09:26:42 <Iceland_jack> Sculptor: For school I once implemented logo in Haskell as an EDSL
09:26:42 <flaritycat> Maybe
09:26:43 <Sculptor> scriptor, http://www.calormen.com/jslogo/
09:26:46 <Iceland_jack> so why not both!
09:26:49 <Sculptor> Iceland_jack, nice
09:27:00 <alllex220> scriptor: which background in math do u mean?
09:27:07 <scriptor> Sculptor: I'm not the one teaching the kid, flaritycat is
09:27:17 <Sculptor> oh, ok
09:27:30 <Iceland_jack> But yes, teaching kids something is very hard and can often make them dislike it if anything
09:27:33 <scriptor> alllex220: maybe high school or something, enough to know what a function is
09:27:59 <Iceland_jack> especially if they don't do things a bit autonomously
09:28:11 <monoidal> joelteon: (btw, for purposes of obfuscation, you can write (liftM2 (,) `on` hGetContents) h1 h2, or something similar)
09:28:22 <alllex220> scriptor: yes thats true, sets and so on
09:28:36 <flaritycat> Iceland_jack: Thats my intention, to have them do it autonomously.
09:28:48 <foeniks> monoidal, could I somehow define my own infix operator for convenient usage? instead of `add_em` something like (myop)?
09:28:54 <flaritycat> well brb, thanks for answers.
09:28:58 <Sculptor> binary arithmetics is simple than base-10
09:29:02 <Sculptor> simpler
09:29:18 <Sculptor> 9yo kids can grasp it
09:29:19 <monoidal> > let x +++ y = x + y - 3 in 2 +++ 10 -- foeniks
09:29:21 <lambdabot>   9
09:29:50 <foeniks> aha
09:30:01 <monoidal> foeniks: any string containing characters +-*/% and similar can be used as a name of an operator.
09:30:41 <Iceland_jack> Sculptor: If you ignore that base-10 is everywhere and also more concise
09:30:48 <scriptor> does it have to exclusively contain those characters?
09:30:57 <foeniks> I reckon that this is better than overloading (+) and (-) for my purposes (although it really is about addition in the end)
09:31:09 <monoidal> scriptor: afair it should be classified as symbol in unicode
09:31:15 <scriptor> ah
09:31:30 <Iceland_jack> > let (⊕) = xor in 5 ⊕ 15
09:31:32 <lambdabot>   10
09:32:13 <Iceland_jack> > let (⊕) = subtract in 5 ⊕ 15 -- unrelated
09:32:14 <lambdabot>   10
09:33:15 <lpaste> bennofs pasted “Weird GHC [using the API] error” at http://lpaste.net/94592
09:33:31 <pyr> Iceland_jack: thx, slowly getting the hangn of it
09:33:38 <monoidal> foeniks: maybe your addition has a neutral element and is associative, then you can implement instance Monoid
09:33:39 <bennofs> What could cause this error ?
09:34:17 <ddosen> any vim users successfully install ghc-mod?
09:34:29 <startling> Iceland_jack, base 10 is /everywhere/.
09:34:40 <startling> In fact, it's really the only base there is.
09:34:52 <Iceland_jack> startling: (funny)
09:34:57 <rdevilla> ddosen: trying to get syntastic to work?
09:35:03 <ddosen> yep
09:35:07 <alllex220> anyone can give me a list of easy haskell problems like 99 hskl problems but easier?
09:35:08 <joelteon> monoidal: right, that's what i was trying to do is obfuscate
09:35:16 <ddosen> redevilla - yes!
09:35:21 <rdevilla> ddosen: this may be of help https://github.com/scrooloose/syntastic/issues/285
09:35:33 <Iceland_jack> I think Sculptor meant base-10_10_10_10_…
09:35:33 <Iceland_jack> <Sculptor> binary arithmetics is simple than base-10
09:35:56 <Sculptor> decimal system
09:35:57 <ddosen> rdevilla - I can't even get ghc-mod to install
09:36:00 <startling> alllex220: what's hard about the haskell 99 problems?
09:36:04 <Sculptor> you only have two digits in binary system
09:36:06 <Sculptor> not 10
09:36:10 <monoidal> bennofs: check output of ghc-pkg check
09:36:23 <Iceland_jack> Sculptor: And that makes it easier?
09:36:25 <startling> Sculptor: binary is base 10.
09:36:42 <Sculptor> yes, easier
09:36:44 <startling> (sorry)
09:36:44 <Iceland_jack> (let's just say ‘base 10’)
09:36:46 <Iceland_jack> :)
09:36:48 <Iceland_jack> *ten
09:36:51 <alllex220>  startling: not hard but some students to learn syntax and so on
09:37:15 <startling> alllex220, I don't think "here's a list of problems" is a good way to learn syntax at all.
09:37:21 <bennofs> monoidal: I only get some haddock warnings. Might also be worth mentioning that I'm using a cabal sandbox and NixOS
09:37:52 <monoidal> bennofs: i don't know then. you might also peek at output with -v
09:38:10 <joelteon> heh, base 10
09:40:44 <rdevilla> ddosen: why not?
09:41:30 <ddosen> rdevilla - a dependency in monad-control err:Monad $ cabal install monad-control
09:41:31 <ddosen> Preprocessing library monad-control-0.3.2.1...
09:41:31 <ddosen> <command line>: cannot satisfy -package-id transformers-0.3.0.0-ff2bb6ac67241ebb987351a3db564af0
09:41:33 <alllex220> startling: yeah i know but some good examples or whatever to show which things are useful and so on
09:41:48 <rdevilla> O.o
09:42:00 <rdevilla> not sure, to be honest
09:42:31 <ddosen> I'm adding an issue on the github repo
09:44:18 <alllex220> startling: but is there more than 99 problems or project euler?
09:44:28 <foeniks> monoidal, thanks for the hint, I will look at Monoids.
09:44:45 <rdevilla> alllex220: Try hackerrank
09:44:49 <rdevilla> they accept Haskell solutions
09:45:01 <alllex220> rdevilla: thanks ill see
09:47:05 <ddosen> rdevilla https://github.com/basvandijk/monad-control/issues/16
09:47:12 <merijn> @where exercises
09:47:12 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
09:47:42 <merijn> oh, wait you said easier
09:49:10 <alllex220> thx
09:55:48 <mr-> Does anybody know exercises that teach the use of GADTs, Typefamilies and stuff like that?
09:57:14 * hackagebot closure 0.1.0.0 - Depth- and breadth-first set closures  http://hackage.haskell.org/package/closure-0.1.0.0 (JosephAbrahamson)
10:00:30 <startling> mr-: GADTs and type families aren't especially hard to understand. There are OK HaskellWiki pages about them, though.
10:01:11 <erisco> how can you check if a value is undefined?
10:01:19 <startling> erisco, you don't.
10:01:34 <glguy> well...
10:01:48 <jfischoff> It would be nice if there were more tutorials. There are some tricks to working efficently with type families.
10:02:02 <jfischoff> there is a dirty way to tell if something is undefined I think
10:02:12 <jfischoff> using GHC magic
10:02:25 <monoidal> erisco: if by 'undefined' you mean Prelude.undefined, you can catch it like a normal error call. it's dirty though
10:02:41 <glguy> erisco: In pure code you can't. What are you trying to do?
10:02:58 <startling> you can catch it in IO, and use unsafePerformIO to catch it elsewhere. `spoon` on Hackage does this. You really shouldn't organize things so you need to, though.
10:03:15 <erisco> I suspected as much
10:03:43 <erisco> okay thanks
10:03:55 <monoidal> mr-: did you read http://research.microsoft.com/en-us/um/people/simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf? this gives a lot of insight into typefams.
10:05:14 <mr-> monoidal: I have not, thanks
10:05:59 <startling> type families are most easily seen as a power-up to functional dependencies, I think.
10:08:06 <mr-> startling: provided one knows about fundeps? ;-)
10:09:13 <mr-> startling: I am really just looking for a way into type hackery beyond the basics
10:10:01 <Twey> mr-: Start with Agda.  :þ
10:10:22 <startling> mr-: OK! So FunDeps are a way you associate types with other types in multi-parameter typeclasses.
10:10:25 <Jeanne-Kamikaze> if it helps, the way I learn about type hackery is I try to do something, ghc omplains, suggests me to use -XzomgABC, and then I google about it
10:10:49 <mr-> Twey: So I should view Haskell's type system as a restriction of Agda's? ;)
10:11:11 <Twey> Haskell's presentation of more powerful type tricks is disjointed (hackery, indeed)
10:11:11 <startling> mr-: e.g. "MonadState s m | m -> s" means that s is uniquely determined by s.
10:11:39 <Twey> Agda's is a lot easier to grasp once you get a feel for the basic idea of dependent programming, and requires less language-specific hackery
10:11:42 <startling> mr-: not quite. The thing about dependent types is that they make it hard to infer types and impossible in general.
10:12:01 <Twey> And then you'll understand the motivations behind most of Haskell's stuff
10:12:20 <mr-> Twey: that sound like a plan, thanks
10:12:38 <startling> mr-, you could just read this paper: andres-loeh.de/LambdaPi/ :)
10:12:45 <Twey> That's a nice paper
10:12:52 <jfischoff> reading Agda tutorials might be the best way to motivate GADTs
10:13:01 <startling> That kind of thing won't teach you anything about GADTs or type families though.
10:13:30 <Twey> Yeah; you're interested in learning how to program dependently, not how to write a dependent language (which is what λΠ is really about)
10:13:39 <jfischoff> you might want to read "dependent types at work"
10:13:56 <mr-> jfischoff: I've started on that one :-)
10:14:05 <jfischoff> I like that one
10:14:07 <startling> mr-, this is pretty well-motivated: http://en.wikibooks.org/wiki/Haskell/GADT
10:14:17 <startling> I think maybe dependent types are a red herring, though.
10:14:25 <Twey> http://oxij.org/note/BrutalDepTypes/ — this comes well-recommended
10:14:28 <jfischoff> yeah that's good
10:14:30 <Twey> startling: Why do you think that?
10:14:46 <startling> Because learning dependent types won't help you do anything in Haskell.
10:15:11 <startling> (If you're interested in them in-and-of themselves, then go for it.)
10:15:21 <tac> Eh.... yeah it will.
10:15:45 <tac> Dependent types gives you a much better conceptual understanding of many haskell constructs
10:16:40 <Twey> Eh.  A lot of things come under the heading of ‘dependent types’.  Dependent programming itself is… actually also useful, with all the new Singleton/Proxy stuff.  But squashing the kind/type/value hierarchy also leads to nicer, more consistent type-level programming in general, which is certainly useful to understand in Haskell.
10:17:41 <startling> OK.
10:18:29 <Twey> After that it's just a matter of learning how to mechanically translate the ideas into hacks involving Proxies and type families and things.
10:19:08 <mr-> Great, I'll start/continue with dependent types, then :-)
10:19:45 <startling> mr-: you might have a look at Idris, then.
10:19:59 <Iceland_jack> startling: Dependent types helped me realized ‘what was possible’ which in turn made me go from not considering an idea to ‘I'm sure I can cram this into Haskell's type system somehow’ ;)
10:20:08 <tac> Iceland_jack: exactly ;P
10:21:38 <Twey> Just so
10:22:41 <Twey> Idris is a lot more to learn than Agda, and doesn't currently have such good tooling/documentation.  It's a cool language, but if you're looking to learn types I'd start with Agda.
10:23:17 <Iceland_jack> Idris has some interesting ideas for EDSL's
10:23:47 <startling> Well, Idris is closer to Haskell. I don't think it's a lot to learn -- you definitely don't need to learn the DSL stuff to learn about types with it. Also, the supported way to use Idris is not a weirdo emacs mode.
10:24:09 <tac> the emacs mode for Agda is a blessing onto this Earth
10:24:11 <Twey> The emacs mode is very (very) useful
10:24:35 <tac> Whether or not you like emacs, the Agda-mode is more-or-less what a typed language's IDE should look like.
10:24:40 <Iceland_jack> tac: Indeed
10:24:48 <Twey> It could be more interactive
10:24:50 <tac> Holes and interactive type-checking
10:24:52 <tac> it could
10:24:57 <Twey> But it's certainly a good start
10:25:01 <tac> But it's better than anything Haskell has :<
10:25:08 <Twey> Indeed
10:25:31 <Iceland_jack> I think agda{,2}-mode provide an interesting view of what programming with types could be
10:25:32 <jfischoff> hmm, I wonder if some things are, if not unique to Haskell, at least different enough that you won't learn them from Agda. I'm think specifically of using `constraints` which I have found convenient when I have recursive function that returns the result of type function. I haven't played around with Agda enough to say is a similar pattern
10:26:01 <Twey> jfischoff: Contraints are not that different to implicits, conceptually
10:26:08 <jfischoff> ah
10:26:20 <Twey> Only the passing mechanism really differs (Haskell's constraint solver is more powerful, though)
10:26:40 <Twey> But the idea is the same — there are just some tricks you can use to make it more convenient in Haskell
10:26:49 <jfischoff> so do you something return the captured implicit from a base case, so the inductive step can pattern match on it?
10:27:37 <Twey> I'm missing your use-case; example?
10:28:23 <jfischoff> So I had a haskell function, that was like foo :: a -> TypeFunction a
10:28:59 <JordiGH> Is it possible to do "automatic" eta reduction? I.e. an easy way to automatically transform my code?
10:29:19 <jfischoff> oh wait
10:29:35 <jfischoff> it was more like foo :: SomeConstraint a => a -> TypeFunction a
10:29:52 <sellout-> JordiGH: Woah, hey – thought I just switched buffers from #emacs to #emacs for a minute ;)
10:30:02 <JordiGH> sellout-: Hm?
10:30:11 <sellout-> JordiGH: Seeing you in here.
10:30:12 <jfischoff> and it was recursive but the type checker couldn't tell that the result would have the SomeConstraint in the inductive step
10:30:16 <JordiGH> sellout-: Hi.
10:30:53 <Twey> jfischoff: That's odd
10:31:07 <jfischoff> so I made an ancillary function that was like SomeConstraint a => a -> (TypeFunction, Dict (SomeConstraint a))
10:31:20 <jfischoff> can then I could pattern match on the Dict in the inductive step
10:31:28 <Twey> I see
10:31:38 <jfischoff> but maybe there was a simplier way
10:31:40 <jfischoff> I don't know
10:31:55 <monoidal> JordiGH: there's hlint which often hints if eta reduction is possible
10:31:56 <Twey> It depends why the type-checker couldn't figure out the constraint, I guess
10:32:03 <JordiGH> monoidal: Ah, neat, thanks.
10:32:04 <Twey> :t repeat 3
10:32:04 <lambdabot> Num a => [a]
10:32:22 <jfischoff> I wonder if it would still be a problem with closed type families
10:32:36 <Twey> :t replicate 3 :: Num a => a -> [a]
10:32:37 <lambdabot> Num a => a -> [a]
10:32:59 <jfischoff> oh wait I meant SomeConstraint a => a -> (TypeFunction a, Dict (SomeConstraint a))
10:33:15 <Twey> I figured
10:33:38 <Twey> The Agda equivalent of constraints involves passing the dictionary around, though
10:33:55 <jfischoff> not that different
10:34:15 <Twey> So you'd have it already (although it can be automatically passed around by the compiler using implicits or instance arguments, you can still access it as a first-class value)
10:39:04 <danilo2> Hello! :) Should this code be working when using -XExtendedDefaultRules? Shouldnt "5.0" be handled as "Double" ? http://lpaste.net/94595
10:40:05 <Vamp> I want to tag a tree with integers increasingly, but I don't really know how to use my modify,put and get in my tag function (behind n of the do-notation) http://lpaste.net/3400012268904120320
10:42:20 <geekosaur> danilo2: ExtendedDefaultRules should not affect that at all
10:42:45 <geekosaur> hm, maybe
10:42:51 <shergill> was cdsmith's arrows from category and applicative <http://cdsmith.wordpress.com/2011/08/13/arrow-category-applicative-part-iia/> ever concluded?
10:43:25 <mr-> Vamp: n <- get and modify (+1) might be helpful (if you are looking for tips like that)
10:44:07 <lpaste> arnsholt pasted “postorder numbered tree” at http://lpaste.net/94596
10:44:47 <arnsholt> Vamp: Not entirely sure if it's what you want, but that paste above is what I use to create a Tree Int whose nodes are numbered post-order
10:45:01 <arnsholt> And with the same structure as the input Tree _
10:45:22 <glguy> danilo2: http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/interactive-evaluation.html section 2.4.7
10:45:36 <glguy> defaulting occurs if ALL the constraints are single-parameter type calsses
10:45:38 <glguy> classes*
10:45:43 <geekosaur> ^^
10:45:50 <geekosaur> was just about to paste that myself
10:46:02 <Iceland_jack> danilo2: You'll have to give an instance for Fractional or annotate
10:46:24 <glguy> danilo2: perhaps an associated type family instead of a fundep would solve the issue
10:46:38 <Iceland_jack>     instance Fractional a ⇒ Get0 a a where get0 = id
10:46:41 <danilo2> geekosaur,glguy: Ok, thank you, but as far as I know ALL the constraints to 5.0 is Fractional a => a and it is single - parameter type class, isnt it?
10:46:52 <glguy> Get0 becomes one of the constraints
10:46:57 <Speer> hello all
10:47:04 <geekosaur> Get0 is a constraint and has 2 parameters
10:47:10 <geekosaur> defaulting can't occur
10:47:19 <Speer> could anyone here give me some javascript help for this program that wont work for me?
10:47:28 <glguy> danilo2: GHC just isn't smart enough to use the fundep knowledge here
10:47:40 <glguy> danilo2: but this would work for you if you translated Get0 to use type families
10:47:44 <Vamp> arnsholt and mr- : Thanks that might help me out
10:47:48 <Iceland_jack> Speer: Javascript help?
10:47:56 <Speer> yes sir
10:48:06 <Iceland_jack> Does it relate to Haskell?
10:48:14 <geekosaur> this seems like the wrong channel for that...
10:48:40 <Iceland_jack> Speer: You should discuss topics in here rather than in PM
10:49:10 <Speer> what is haskell?
10:49:17 <Speer> okay
10:49:22 <danilo2> glguy: Ok, I'll try with type families. I'm not sure now how to use them in this case, but I'll try now :)
10:49:24 <Speer> i have a while loop inside another while loop
10:49:33 <geekosaur> o.O
10:49:37 <osfameron> Speer: do you wonder into random stranger's houses and ask them general questions about things?
10:49:37 <Speer> my program does not run with my outer loop present, only when i remove it
10:49:42 <Speer> yes
10:49:52 <Iceland_jack> Speer: If you're interested in finding more about Haskell you can look at Learn You a Haskell, otherwise you're in the wrong channel :)
10:49:52 <Iceland_jack> @where lyah
10:49:52 <lambdabot> http://www.learnyouahaskell.com/
10:50:15 <Speer> oh
10:50:18 <osfameron> http://xkcd.com/163/
10:50:58 <glguy> danilo2: Oh, it might not be able to resolve, either
10:51:08 <glguy> I'd been testing on a smaller case where the tf did help
10:51:32 <lpaste> glguy annotated “DefaultRules question” with “DefaultRules question (annotation)” at http://lpaste.net/94595#a94597
10:51:32 <danilo2> glguy: Could you explain a little more what solution did you have in mind when you were talking about type families?
10:51:33 <Iceland_jack> osfameron: heh
10:51:46 <frxx> > map (2^) [1..]
10:51:48 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
10:51:56 <danilo2> glguy: Ok, I'm reading the annotation :)
10:52:03 <mr-> osfameron: thanks :-)
10:52:23 <glguy> danilo2: Type families can replace simple uses of functional dependencies
10:52:42 <cschneid> I have some code that slowly builds up a data structure, and I'm not sure how to store it. the record is something like { raw :: ByteString, key :: ByteString, decrypted :: ByteString, score :: Double... }
10:52:52 <cschneid> the idea being that I may want copies of this structure without a score
10:52:56 <Vamp> arnsholt: What is the data of the tree in your example by the way? Because I use a binary tree that stores values on the internal nodes only
10:52:59 <cschneid> should I just wrap stuff in Maybe and deal with the hassle of checking
10:53:47 <Iceland_jack> cschneid: Does it make sense for your case to i) split it into smaller data types, ii) create incremental data types
10:53:48 <danilo2> glguy: I have heard about "closed" type families - do they bring us something "better" than fundeps? (this question is not so related to the 5.0 problem). Do the give us something better than using (~) (from GADT's) in instance level?
10:53:54 <cschneid> I could partially apply the data constructor, and if I want it early, fill in dummy values.  I could split into smaller datas
10:53:59 <arnsholt> Vamp: It's a parse tree, so all the nodes have data, and different nodes can have different arities
10:54:23 <cschneid> Iceland_jack: the data is: "given this encrypted value, and this key, what is its output, and the score is how close it is to english using a heuristic"
10:54:29 <arnsholt> (Parse tree for a natural language sentence, using dependency grammar, if you're into the whole NLP thing)
10:54:39 <cschneid> maybe I should just calc score no matter what, since... if I never reference it, it'll just never get evaled.
10:54:40 <ghorn__> danilo2: closed type families help solve overlapping instance problems, cause the compiler doesn't have to worry about all possible instances some user might write
10:54:51 <glguy> danilo2: I haven't played with them
10:54:53 <Iceland_jack> cschneid: That doesn't sound like a good way
10:55:02 <ghorn__> i mean, closed type classes, i haven't heard of closed type families
10:55:16 <glguy> ghorn__: They're coming in 7.8
10:55:26 <cschneid> Iceland_jack: ok. Basically I have a set of functions to do each bit of the structure. So I could pull it all together, but some uses don't require the score for instance.
10:55:38 <glguy> danilo2: In this case the problem is the "Show (GetR m)" constraint
10:55:44 <danilo2> ghorn__: Ok, but in GHC-7.8 the Overlapping instances handling rules will be extended in such way, thatif you;'ve got more thna 1 overlapping instance, the first one will be choosen - so in that case, will the closed type families bring us something "more"?
10:55:48 <Iceland_jack> You can do:
10:55:48 <Iceland_jack>     data CipherStuff = CS { ... }
10:55:48 <Iceland_jack>     data Score = Score { score :: Double, value :: CipherStuff }
10:56:02 <cschneid> Iceland_jack: sure, nesting things
10:56:36 <Iceland_jack> Is there anything other than the Score that you need to build incrementally?
10:56:55 <ghorn__> danilo2: do you have a link for the extended overlapping instances in 7.8?
10:57:02 <cschneid> not yet I think.
10:57:09 <Iceland_jack> This solution is far better than having 'wrong' scores or (Maybe Double) in the sense that you can distinguish them on the type-level
10:57:12 <cschneid> actually that'd be nice, since I could then `instance Ord` my score solution
10:57:17 <dorei> hello, is there a way to read documentatiion from within ghci?
10:57:20 <danilo2> ghorn__: It is written in current status log of 7.8 brb
10:57:48 <Iceland_jack> And a function:
10:57:49 <Iceland_jack>     calculateScore :: CipherStuff -> CipherStuffAndScore
10:57:49 <Iceland_jack> makes that explicit
10:57:57 <Iceland_jack> where CipherStuffAndScore is what I called 'Score' previously
10:58:01 <cschneid> Iceland_jack: right. I have stuff like that already
10:58:06 <cschneid> and my solution has been tuple based, which is silly
10:58:17 <Iceland_jack> Are you unsatisfied with that solution?
10:58:20 <cschneid> ie, adhoc data. I should use real data.
10:58:25 <cschneid> yeah, my type sigs are ugly as heck
10:58:31 <Iceland_jack> Example?
10:58:43 <danilo2> ghorn__: http://ghc.haskell.org/trac/ghc/browser/ghc/docs/users_guide/7.8.1-notes.xml
10:58:52 <cschneid> sortAttempts :: CorpusStats -> DecryptionAttempt -> [(LBS.ByteString, LBS.ByteString, LBS.ByteString)]
10:59:01 <danilo2> ghorn__: see: IncoherentInstances
10:59:03 <cschneid> that'd be [CipherStuffAndScore]
10:59:30 <cschneid> ohh I'm sorry it was worse: sortAttempts :: CorpusStats -> [(LBS.ByteString, LBS.ByteString)] -> [(LBS.ByteString, LBS.ByteString, LBS.ByteString)]
10:59:42 <Iceland_jack> cschneid: You can always create synonyms for Cipher, Key, Message
10:59:56 <Iceland_jack> That makes it more readable right off the bat
11:00:06 <cschneid> Iceland_jack: of course. How should I choose a `data` vs. a tuple of more basic data types
11:00:10 <cschneid> with aliases
11:00:11 <danilo2> glguy: Ok so is this somehow solvable?
11:00:29 <Iceland_jack> Not sure what you're asking cschneid?
11:00:31 <glguy> Sure, add a type signature to 5.0
11:00:56 <glguy> or make a function: asDouble :: Double -> Double = id
11:00:58 <glguy> :)
11:01:09 <cschneid> Iceland_jack: style-wise, how do I choose when a `data Foo = Foo...` is appropriate vs. when a type alias and a tuple like (Key, Message) is appropriate?
11:01:10 <Iceland_jack> danilo2: (or you can use my solution of using a Fractional constraint)
11:01:14 <danilo2> glguy: hehe, ok :) I was simply searching for something magical
11:01:25 <Iceland_jack> cschneid: In general I avoid tuples
11:01:35 <Iceland_jack> especially when they're 3+-tuples
11:01:57 <danilo2> Iceland_jack: Hmm what solution? Maybe I missing something, but I do not know what youre talkign about :)
11:02:05 <cschneid> so similar to the code-smell in OO code, data that ends up being bundled up and moved around together deserves a name & a data type?
11:02:07 <Iceland_jack> <Iceland_jack>     instance Fractional a ⇒ Get0 a a where get0 = id
11:02:16 <Iceland_jack> Creating a datatype gives you type safety, some form of documentation so on
11:02:49 <danilo2> By the way - using type families gives us something better than fundeps ? (I was asking before about closed type fmailies - what with not closed ones?)
11:03:30 <Iceland_jack> cschneid: Not sure I'd call it similar but if something is concrete (key, cipher, message, score) then I find it good style to make that explicit in your code
11:03:52 <cschneid> Iceland_jack: right. More of "this data belongs together" should be called out.
11:03:55 <Iceland_jack> It could make no sense to do that for (a, b) in zip since you know nothing about it
11:03:55 <Iceland_jack> @ty zip
11:03:55 <Iceland_jack>  
11:03:55 <lambdabot> [a] -> [b] -> [(a, b)]
11:04:03 <Iceland_jack> Yes
11:04:17 <cschneid> Iceland_jack: thanks - let me play with data-izing my code and see how it plays out
11:04:21 <cschneid> I certainly need better names
11:04:26 <Iceland_jack> Sure :)
11:04:31 <Iceland_jack> also a small note cschneid
11:04:42 <Iceland_jack> when you have identical data, you can mix them up
11:05:26 <danilo2> Iceland_jack: Oh yes it works, but then this instance "overlapps" with all other instances I declare - even with "data X = X;  instance Get0 (X) (X) where get0 = id"
11:05:26 <Iceland_jack> so a function:
11:05:26 <Iceland_jack>     encrypt :: Key -> Message -> Cipher
11:05:26 <Iceland_jack> where Key = Message = Cipher = ByteString or something, you can mess up the arguments and the compiler wouldn't care
11:05:40 <cschneid> right. real `data` items can't, since they're more than simple aliases
11:05:47 <Iceland_jack> Yes
11:06:07 <Iceland_jack> so it *can* be good style (if you care a lot about not mucking up your arguments) to use newtype for that
11:06:33 <Iceland_jack>     newtype Key = Key LBS.ByteString
11:06:33 <Iceland_jack>     newtype Msg = Msg LBS.ByteString
11:06:33 <Iceland_jack>     ...
11:06:40 <cschneid> newtype is transparent during runtime, but stronger type knowledge in the compiler
11:06:56 <Iceland_jack> Yes in most cases newtype goes away
11:07:05 <cschneid> but doesn't it make it a bit more awkward to use during coding? Since you have to extract the inner bytestring (or fmap I suppose) to use it?
11:07:13 <Iceland_jack> Well you can't fmap it
11:07:19 <Iceland_jack> but yes, it becomes more awkward
11:07:28 <homo_vitruvius> Does somebody know of a good example of using Parsec with a language that has the equivalent of C #include CPP statements? Thx
11:07:43 <cschneid> f (Key x) = ... function here ... for instance
11:07:45 <Iceland_jack> so then you have to make the call whether you need the added type safety versus the hassle
11:07:47 <cschneid> to use the x value
11:08:05 <cschneid> or is there a simpler way to extract out the newtype value?
11:08:08 <Iceland_jack> For many values you can use generalized newtype deriving and it goes away
11:08:16 <Iceland_jack> yes, you can make it a record
11:08:28 <Iceland_jack>     newtype Key = Key { getKey :: LBS.ByteString }
11:08:39 <Iceland_jack> then getKey :: Key -> LBS.ByteString
11:08:50 <Vamp> arnsholt: Aha ok, because I defined my tree as data Tree a = Branch (Tree a) a (Tree a) | Leaf (values in internal nodes only) and want to tag this tree by using depth-first in-order traversal
11:08:58 <danilo2> glguy: Does using type families (not closed) gives us something "better" than just using fundeps?
11:10:26 <Iceland_jack> cschneid:
11:10:26 <Iceland_jack> Prelude> :set -XGeneralizedNewtypeDeriving
11:10:26 <Iceland_jack> Prelude> newtype IPv4 = IPv4 Int deriving (Show, Eq, Bits, Num)
11:10:29 <Iceland_jack> Prelude> (5 + 25 :: IPv4) `shiftL` 5
11:10:33 <Iceland_jack> IPv4 960
11:10:43 <glguy> More effort has been put into them in GHC, so some things that should work with fundeps don't unless you recode them as type families. The syntax can be nicer in some cases
11:11:23 <mr-> Iceland_jack: aweome!
11:11:31 <mr-> +s ;-)
11:11:34 <Iceland_jack> :)
11:11:46 <Iceland_jack> Using that you retain certain type class instances
11:11:51 <Iceland_jack> and also gain type safety
11:11:55 <arnsholt> Vamp: Ah, right. My code uses Data.Tree. But depth-first in-order is postorder numbering, no? Deepest, left-most node is 1, and so on
11:12:16 <danilo2> glguy: Ok, that is interesting. I have to check them out. Do you have any examples of such things?
11:12:46 <Vamp> arnsholt: Yes indeed, left sub, root, right sub, but I don't really know what to take as the base case
11:13:01 <Iceland_jack> Of course multiplying IPv4 addresses is not the most useful thing in the world, but getting fromInteger can be useful
11:13:14 <arnsholt> Oh, that's infix order. Postorder is left subtree, right subtree, node
11:13:47 <danilo2> Additional, why such code produces Overlapping instances? Why GHC things "get0 X" is matched to "(Fractional a, Show a) => Get0 a a" if it is not instance of Fractional? This is because of open world assumption?
11:14:25 <Iceland_jack> Prelude> newtype IPv4 = IPv4 Word32 deriving (Show, Bounded)
11:14:25 <Iceland_jack> Prelude> IPv4 minBound
11:14:25 <Iceland_jack> IPv4 0
11:14:25 <Iceland_jack> Prelude> IPv4 maxBound
11:14:29 <Iceland_jack> IPv4 4294967295
11:15:14 <joelteon> @pl q f = m f () () ()
11:15:14 <lambdabot> (line 1, column 13):
11:15:14 <lambdabot> unexpected ' '
11:15:15 <lambdabot> expecting variable, "(", operator or end of input
11:15:23 <joelteon> @pl q f = m f 1 2 3
11:15:26 <lambdabot> q = flip (flip (flip m 1) 2) 3
11:15:26 <lambdabot> optimization suspended, use @pl-resume to continue.
11:15:36 <Vamp> arnsholt: So I tried something like this http://lpaste.net/577078420140195840 as the base case
11:15:48 <Iceland_jack> cschneid: Anyway, that doesn't apply to your particular example, except for Eq and Ord etc.
11:16:05 <cschneid> Iceland_jack: awesome - so now I can also then do custom instances my newtype as well, where it makes sense.
11:16:16 <Twey> homo_vitruvius: I don't know of an example, but the way I would do it would be: 1) apply ParserT to the IO monad to get a parser in which you can do IO operations, and then 2) when you encounter an #include directive, read the specified file and prepend it to the stream using Text.Parsec.Prim.getInput/setInput
11:16:28 <cschneid> Iceland_jack: so... newtypes inside of a data? Or does data do the work necessary to make them typeable and safe
11:16:48 <Iceland_jack> well you can think of newtype as a limited data
11:17:03 <cschneid> a 1 item data, with no "or" clause to it. Right?
11:17:16 <Iceland_jack> yes, omitting some details
11:17:29 <cschneid> anyway, I'll go play with code and see what comes out. I'm getting tired of typing "ByteString" for sure.
11:17:35 <Iceland_jack> cschneid: :)
11:17:35 <arnsholt> Vamp: Well, since Leaf doesn't hold any data, tagging a leaf is a noop
11:17:54 <Twey> Sadly my cabal is currently broken so I can't code up an example :-\
11:18:04 <Vamp> arnsholt: Hmm I see
11:18:50 <geekosaur> "Why GHC things "get0 X" is matched to "(Fractional a, Show a) => Get0 a a" if it is not instance of Fractional?" from your earlier example, you used it with a numeric literal whose type is Fractional a => a
11:18:54 <homo_vitruvius> Twey: the.
11:19:26 <homo_vitruvius> Twey: thanks
11:19:39 <geekosaur> this means you used it in a context which demands that instance exisrt
11:19:48 <geekosaur> (because defaulting can't happen with your 2-parameter class)
11:19:51 <Twey> homo_vitruvius: No problem
11:20:05 <Twey> (you can also do it in two passes, of course)
11:20:55 <jozefg> Hi all
11:20:57 <arnsholt> Then your "tag (Tree left data right)" becomes something like "do left' <- tag left; n <- get; put (n+1); right' <- tag right; return $ Tree left' (n, data) right'"
11:22:03 <arnsholt> (And its type is (Tree a) -> State Int (Tree (Int, a)) I think)
11:23:00 <danilo2> geekosaur: Ok, but X is not Fractional. So GHC is matching it to "(Fractional a, Show a) => Get0 a a" because of open world assumption, am I right?
11:23:37 <homo_vitruvius> Twey: I'll experiment a bit. I've never really used Haskell and now I've found a reasonably small problem to see if the hours spent on real world Haskell have left something in me...
11:23:40 <danilo2> geekosaur: http://lpaste.net/94599
11:24:06 <ski> danilo2 : no, GHC doesn't consider the context when selecting an instance
11:24:13 <danilo2> geekosaur: hehe it seems I didnt pasted the updated code before, sorry
11:24:52 <geekosaur> ok, so what I said doesn't apply; I was responding to why the one where you wanted Double to be defaulted would have inferred a Fractional instance
11:24:58 <danilo2> ski: Ok, but if I turn on "IncoherentInstances", GHC considers it? It selects then instances in proper way
11:25:22 <geekosaur> in a way which might be proper if it's all in a single source file
11:25:32 <geekosaur> but is not guaranteed to do anything like what you intend otherwise
11:25:33 <ski> i probably wouldn't rely on getting aby particular instance selected with `IncoherentInstances'
11:25:48 <ski> s/aby/any/
11:26:29 <danilo2> ski, geekosaur: Ok, thank you :)
11:26:31 <ski> i don't think you can make it select one instance in case `a' is in `Fractional', and another instance in some other case
11:26:53 <ski> .. except of course by selecting based on matching on the type constructors in the instance head
11:26:55 <monochrom> I don't think you interpret IncoherentInstances correctly
11:27:23 <danilo2> ski: But it works this way in this code: http://lpaste.net/94599 Maybe this is just by accident, but it works
11:27:36 <geekosaur> incoherent means it'll try to guess what you intended, and just go in order of declaration otherwise. it's not even remotely reliable
11:27:40 <geekosaur> don't use it
11:28:35 <jfischoff> is there a reasonable use case for IncoherentInstances?
11:28:43 <ski> anyway, yes it's related to OWA in so far as to what would happen when someone adds `Fractional X'
11:28:59 <monochrom> suppose you have both "instance Integral a => MyClass a" and "instance Fractional a => MyClass a". the compiler will not use "Integral vs Fractional" to choose. will not. with or without IncoherentInstances. will not.
11:29:00 <danilo2> geekosaur: I know, I have heard a lot about that we shouldnt use IncoherentInstances, but I wanted to know how they work. Thank you :)
11:29:42 <danilo2> ski, geekosaur: but is it somehow possible that GHC will choose instance thaty has Fractional predicate on object, who do not implement Fractional when using IncoherentInstances?
11:29:57 <geekosaur> what I said is a quick summary and probably doesn't describe particulars correctly. the ghc manual explains the details
11:30:47 <geekosaur> I have not studied all the corner cases; I don't consider IncoherentInstances at all safe to use in real programs
11:30:59 <ski> danilo2 : perhaps `OverlappingInstances' would be enough in your case ?
11:31:14 <geekosaur> (as in, if I for some reason need it, I'm Doing It Wrong)
11:31:42 <danilo2> ski: yes it is :)
11:32:02 <danilo2> geekosaur: Ok, thank you, I will not use it! I promise :D
11:33:17 <ski> danilo2 : "When matching, GHC takes no account of the context of the instance declaration" <http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-overlap>
11:33:56 <jozefg> For what it's worth, the idiom in most libraries is to create a simple new type exclusively to be used with a particular context and then define the instance with that.
11:34:41 * monochrom craves for GHC 7.8 :)
11:34:55 <jozefg> Eg newtype MonadFunctor m a = {runMonadFunctor :: m a}; instance Monad m => Functor (MonadFunctor m) where ...
11:35:05 <ski> danilo2 : "Warning: overlapping instances must be used with care. They can give rise to incoherence (i.e. different instance choices are made in different parts of the program) even without `-XIncoherentInstances'."
11:35:21 <danilo2> ski: Thank you for the reference. Now the mechanism is very cler to me! :)
11:35:58 <danilo2> ski: I will not use Overlapping in my code neither. I know it is dangerous and if I can do it other way around, I'll o it :)
11:36:01 <Iceland_jack> monochrom: Don't you just!
11:36:06 <Iceland_jack> 7.8 looks amazing
11:36:22 * Iceland_jack is always amazed at the GHC developers
11:36:33 <ski> monochrom : any feature in particular ?
11:37:03 <monochrom> none in particular
11:37:51 <jozefg> I have a few DSLs that are going to thoroughly benefit from overloaded lists
11:38:00 <jozefg> Plus now seq's won't be second class :D
11:39:18 <monochrom> actually, there is no harm telling you this secret. I just want to enjoy building it from source so I can tell you "my build uses libgmp10 not libgmp3" on http://www.vex.net/~trebla/haskell/I-built-GHC.xhtml :)
11:39:34 <Iceland_jack> jozefg: What's new with seq?
11:39:59 <benmachine> possibly Seq from Data.Sequence
11:40:10 <Iceland_jack> ah
11:42:57 <jozefg> :Iceland_jack Well currently there are no Seq literals, with 7.8 they can be implemented, it's just syntactic sugar but it's quite nice sugar. And with monadcomprehensions i believe we can use them exactly interchangeably
11:43:16 <Iceland_jack> Yes definitely jozefg :) I just thought you meant ‘seq’
11:43:21 <Vamp> arnsholt: I got that implement now, but I'm getting a non exhaustive pattern, I think this has to do with the Leaf, how should I fix that?
11:43:42 <skypers> hey
11:43:51 <skypers> I written a binding for a C function in Haskell like
11:44:03 <jozefg> :Iceland_jack Ah I see
11:44:13 <arnsholt> Vamp: Depends on what the code looks like =)
11:44:13 <skypers> foreign import ccall "foo" cFoo :: CInt -> IO ()
11:44:18 <jozefg> Adjoint functors are proving absurdly useful :O
11:44:22 <amalloy> i have a function f :: (a -> b -> c) and a Monad m, and i want back (a -> b -> M c), where i just (return $ f a b). i can write it like (\a b -> return $ f a b), of course, but it seems like there must be some combination of ($), (.), and return that i can call on f without having to mention a and b; i just can't figure out what that is
11:44:24 <skypers> when I do cFoo 0
11:44:33 <skypers> it acts like it doesn’t do anything in « the real world »
11:44:37 <skypers> do I need unsafe then?
11:44:43 <skypers> foreign import unsafe?
11:45:02 <foeniks> I have too corresponding types, think of them like row and column vectors
11:45:11 <skypers> (what that keyword stands for anyway?)
11:45:32 <Vamp> arnsholt: http://lpaste.net/2913381496330911744 so I guess I need a seperate case for the Leaf
11:45:33 <foeniks> I have written two classes to generalize their behaviour
11:45:34 <jozefg> :amalloy How about (.:) = (.) . (.); return .: f
11:46:04 <foeniks> now I would like to implement something like a multiplication that only works with two instances that pair up
11:46:06 <Iceland_jack> @pl \a b -> return (f a b)
11:46:07 <lambdabot> (return .) . f
11:46:27 <foeniks> I am struggling on how to include this in to the classes
11:46:49 <arnsholt> Vamp: Yeah, you'll need a "tag Leaf" as well. Otherwise it won't know what to do when you pass in a Leaf =)
11:48:12 <jfischoff> foeniks: what class are you trying to write?
11:48:21 <amalloy> Iceland_jack: yeah, that sounds right. i tried (return . f), but i still seem to wind up confused when i need multiple . operators
11:48:24 <jfischoff> and instances there of
11:48:31 <Vamp> arnsholt: label Leaf = return Leaf is too simple?
11:48:45 <Vamp> tag Leaf even
11:48:54 <arnsholt> Yeah, that should do the trick
11:48:55 <Iceland_jack> amalloy: Yeah, take that as a sign of writing it in ‘pointful’ style :)
11:49:02 <Iceland_jack> but I know many Haskellers disagree with me
11:49:35 <Iceland_jack> But for familiarizing yourself with Haskell it's perfectly in my opinion
11:49:40 <Iceland_jack> *perfectly fine
11:49:42 <skypers> heyoh? :)
11:50:10 <jozefg> Is there somewhere that provides the `.:` operator? I personally hate the (fun .) . otherFun, it breaks up the nice concatenate style
11:50:14 <skypers> the C function I’m binding create a thread and plays some music (FMOD_System_PlaySound)
11:50:19 <skypers> when I call it from Haskell
11:50:25 <skypers> I get correct return value
11:50:29 <skypers> but no sound is actually played
11:50:43 <skypers> does it refer to something like laziness issue here?
11:50:51 <johnw> skypers: this sounds awfully familiar
11:51:03 <skypers> oh
11:51:10 <skypers> so you’re experienced with
11:51:13 <johnw> notme
11:51:14 <skypers> tell me you secret then
11:51:15 <skypers> oh
11:51:15 <skypers> :(
11:51:16 <johnw> but maybe search IRC history?
11:51:25 <skypers> huh
11:51:26 <skypers> :D
11:51:29 <monochrom> a C function doesn't usually give you the right return value without playing
11:51:32 <skypers> where could I do such a thing?
11:51:47 <johnw> ircbrowse.net
11:51:47 <skypers> monochrom: well it’s a thread
11:51:53 <monochrom> and if it does, it is the C function itself, nothing to do with Haskell
11:52:01 <skypers> hm
11:52:08 <skypers> that’s weird then
11:52:19 <skypers> I checked all returned values
11:52:21 <skypers> all ptr
11:52:27 <skypers> all is just right
11:53:23 <TallerGhostWalt> I have a question abou the ffi: If I use a piece of c code that inits a global pointer on first run, then calls that pointer on subsequent runs, what are the rules for when that pointer is kept and gc'd?
11:53:23 <Iceland_jack> jozefg: http://hackage.haskell.org/package/composition-1.0.1.0/docs/Data-Composition.html
11:53:38 <foeniks> jfischoff, I would like to write a class Rowvector and a class Columnvector. Both have some kind of a method for adding the vectors, furthermore Rowvector has "fromcolumn" and Columnvector has "fromrow".  I want to implement instances, Row2, Col2, Row3, Col3, etc.
11:53:42 <foeniks> The constraint I am struggling with is, that fromrow :: (Rowvector r, Colvector c) => r -> c should only match up with corresponding sized vectors.
11:54:08 <foeniks> I don't know if there is a way to combine this into a single class
11:54:21 <foeniks> something like multiple dispatch .
11:54:33 <jozefg> Iceland_jack: Oh lord… I wonder if anyone actually uses `.:::::.`
11:54:58 <jfischoff> you could add the size as a type variable
11:54:59 <Iceland_jack> jozefg: :) I certainly hope not
11:55:26 <jfischoff> class RowVector v s | v -> s where ….
11:55:34 <Twey> foeniks: Don't do it; use typelevel nats and write a type Matrix ∷ Nat → Nat → *
11:55:42 <jfischoff> yeah
11:55:47 <Twey> Or Nat → Nat → * → *
11:55:52 <Iceland_jack> I would personally write:
11:55:53 <Iceland_jack>     concatMap f xs = concat (map f xs)
11:55:54 <jfischoff> do what Twey said
11:55:58 <Iceland_jack> rather than
11:55:58 <Iceland_jack>     concatMap = concat .: map
11:56:25 <Twey> I usually write fmap concat . map
11:56:35 <Twey> Is .: in base now?
11:56:46 <jozefg> Twey: That's a type error and no
11:56:52 <skypers> http://pastebin.com/mwF9sisM
11:56:56 <skypers> it just should work
11:56:57 <Twey> :t fmap concat . map
11:56:57 <mauke> The paste mwF9sisM has been copied to http://lpaste.net/94600
11:56:58 <lambdabot> (a1 -> [a]) -> [a1] -> [a]
11:57:03 <skypers> all pointers are ok
11:57:12 <skypers> do I need to enable anything
11:57:14 <Twey> jozefg: Why do you think it's a type error?
11:57:20 <skypers> like multithreading
11:57:22 <skypers> or whatever?
11:57:43 <Iceland_jack> Maybe I'd define it as such: ;)
11:57:43 <Iceland_jack> :t let (f .: g) x y = f (g x y) in concat .: map
11:57:44 <lambdabot> (a1 -> [a]) -> [a1] -> [a]
11:58:10 <dmj`> I want to apply the results of catMaybes to a function
11:58:11 <Twey> Doesn't seem worthwhile, really :þ
11:58:14 <skypers> sounds like foldl1
11:58:15 <jozefg> Twey: map takes two arguments, so your trying to feed concat `[a] -> [b]`
11:58:34 <Twey> jozefg: No, I'm feeding ‘fmap concat’ [a] → [b]
11:58:40 <dmj`> @def results@[f,l,e,m] = catMaybes [Just 1, Just 2, Nothing, Nothing]
11:58:41 <lambdabot>  Defined.
11:58:47 <dmj`> > length results
11:58:51 <lambdabot>   *Exception: L.hs:141:1-67: Irrefutable pattern failed for pattern results@[...
11:58:55 <Twey> :t (concat .)
11:58:56 <lambdabot> (a -> [[a1]]) -> a -> [a1]
11:59:02 <jozefg> Twey:  Oh drat I missed the fmap
11:59:04 <jozefg> My mistake
11:59:09 <dmj`> @def results@[f,l,e,m] = catMaybes [Just 1, Just 2, Just 3, Just 4]
11:59:09 <lambdabot>  .L.hs:142:1:
11:59:09 <lambdabot>      Multiple declarations of `results'
11:59:09 <lambdabot>      Declared at: .L.hs...
11:59:15 <Twey> Aha
11:59:20 <dmj`> @def results'@[f,l,e,m] = catMaybes [Just 1, Just 2, Just 3, Just 4]
11:59:20 <lambdabot>  .L.hs:142:11:
11:59:21 <lambdabot>      Multiple declarations of `f'
11:59:21 <lambdabot>      Declared at: .L.hs:141:...
11:59:29 <dmj`> ugh
12:00:05 <Twey> dmj`: Don't @def that… nobody else is ever going to want to call it :h
12:00:07 <Twey> :þ**
12:00:34 <jfischoff> foeniks: other options is not to worry about the size in the type level
12:00:43 <foeniks> Twey, okay I see the point for small vectors, but if a further constraint is: this should also work with Vec53, then Nat Nat Nat Nat, are there any options?
12:00:54 <jfischoff> and just have functions that return a Maybe
12:00:59 <cschneid> How do I go about avoiding the `fromIntegral` call to go from Integer -> Int? keysOfLength n = map (LBS.cycle . LBS.concat) (replicateM (fromIntegral n) allHexBytes)
12:01:24 <jfischoff> foeniks: what is Vec53?
12:01:38 <jozefg> Hey could someone skim this for me? I'm not sure if it's worth keeping http://jozefg.bitbucket.org/posts/2013-10-21-representable-functors.html
12:01:44 <cschneid> my type sig is: keysOfLength :: KeyLength -> [Key]  (and type KeyLength = Integer). and Key = LBS.ByteString
12:01:46 <Twey> foeniks: Sorry?  That would be a four-dimensional tensor
12:01:47 <Taneb> jfischoff, a big scary product type
12:02:08 <Twey> foeniks: I thought we were doing vectors here :þ
12:02:19 <Iceland_jack> cschneid: Well replicate only takes an Int
12:02:21 <dmj`> Twey: ok
12:02:26 <Iceland_jack> (also replicateM)
12:02:34 * hackagebot FixedPoint-simple 0.5.1 - Fixed point, large word, and large int numerical representations (types and common class instances)  http://hackage.haskell.org/package/FixedPoint-simple-0.5.1 (ThomasDuBuisson)
12:02:37 <dmj`> Twey: Do you see what I'm trying to do though?
12:02:56 <cschneid> Iceland_jack: I suppose: "where is a single tree of the numeric typeclasses" is the right question.
12:03:19 <Twey> dmj`: Your code is valid and binds results' = [1, 2, 3, 4]; f = 1; l = 2; e = 3; m = 4
12:03:22 <foeniks> Twey, jfischoff: vectors with 53 rows or 53 columns, so rather a first order tensor
12:03:47 <foeniks> Maybe I chose the wrong analogy when asking for help
12:03:48 <cschneid> Iceland_jack: can I make this work?  type KeyLength  = Integral  -- I get the error: Illegal constraint synonym of kind: `* -> Constraint'
12:03:54 <jfischoff> in either case wouldn't you just need one Nat?
12:03:55 <Twey> foeniks: A column vector with 53 rows would be Matrix 53 1
12:03:56 <Iceland_jack> cschneid: no
12:04:01 <Iceland_jack> Integral is not a type
12:04:10 <jfischoff> or what Twey said
12:04:11 <Twey> foeniks: It still takes only two Nats — the Nats in the kind are dimensions
12:04:13 <cschneid> it's a typeclass. That a type could be a member of.
12:04:23 <Twey> foeniks: If you add another Nat you're adding another dimension, not another row
12:04:23 <shergill> what's the current method for taking over as maintainer for a package on hackage?
12:04:35 <cschneid> I get the why, just figuring out how to make type aliases not concrete types. Is there a way, or should I just stick with the fromIntegral line
12:04:37 <Iceland_jack> Yes, constraining data types is frowned upon
12:05:01 <jfischoff> so you would have something like Vec 53 1 as your type
12:05:03 <jozefg> Data type constraints are pretty much useless..
12:05:17 <skypers> f**k it
12:05:25 <skypers> I tested with the exact C code
12:05:30 <skypers> +same
12:05:30 <Twey> jfischoff: It would be ‘Matrix’ since it's not necessarily a vector
12:05:31 <skypers> it works in C
12:05:33 <skypers> not in Haskell
12:05:37 <skypers> what the…
12:05:37 <jfischoff> oh right
12:05:38 <dmj`> Twey: I got it!
12:05:55 * Iceland_jack prefers f>=>ck it
12:06:02 <dmj`> let result@(a:b:c:d:_) = catMaybes [Just 1, Just 2, Just 3, Nothing]
12:06:25 <shergill> i've mailed the current maintainer and have his permission
12:06:29 <Iceland_jack> cschneid: Give me a moment to read your previous comments, I was in the middle of something
12:06:54 <dmj`> nvm, it still errors
12:07:07 <skypers> http://lpaste.net/858396042134028288
12:07:09 <skypers> here it is
12:07:18 <skypers> if you have an idea why I don’t have sound playing…
12:07:23 <skypers> maybe it’s because of forever
12:07:26 <skypers> I don’t know
12:07:28 <skypers> it annoys me
12:08:45 <TallerGhostWalt> What is a datatype constraint?
12:09:21 <skypers> TallerGhostWalt: foo :: (Num a) => a -> a; foo = (3*)
12:09:31 <Twey> dmj`: That errors because catMaybes [Just 1, Just 2, Just 3, Nothing] returns [1, 2, 3], which you then try to bind to (a : b : c : d : _)
12:09:31 <skypers> (Num a) is a constraint, right?
12:09:32 <skypers> well
12:09:38 <skypers> you can put that on datatype too
12:09:39 <skypers> like
12:09:56 <Twey> a = 1, b = 2, c = 3, (d : _) = [], and the match fails
12:10:04 <skypers> like I don’t actually know, it’s not advised because it’s a pain to write function taking such a type
12:10:07 <skypers> maybe
12:10:30 <skypers> (Ord a) => data Foo a = Foo a
12:10:33 <skypers> not sure at all
12:10:37 <TallerGhostWalt> skypers: lol
12:10:47 <skypers> I’d like someone to help me with my foreign issue
12:10:50 <skypers> 20:57 < skypers> http://lpaste.net/858396042134028288
12:10:51 <skypers> here
12:11:00 <skypers> if you have some spare time…
12:11:05 <TallerGhostWalt> Just more mind boggling word jumble in haskell
12:11:20 <jozefg> TallerGhostWalt: data (Show a)  => Foo a = Foo a
12:11:34 <TallerGhostWalt> oh I see
12:11:36 <skypers> yeah that way
12:11:41 <skypers> and do not do that.
12:11:44 <TallerGhostWalt> lol
12:11:57 <jozefg> Technically it's a context not a constrain
12:12:19 <TallerGhostWalt> Yeah I have seen not to do that
12:12:27 <foeniks> jfischoff, Twey thanks, I think I have some reading up to do now ;)
12:12:37 <TallerGhostWalt> Just like to hear about stuff not to do, so I can stop!
12:12:59 <TallerGhostWalt> I was thinking... I use types to constrain all kinds of things!
12:13:06 <Iceland_jack> cschneid: Back, ok so there exists a genericReplicate but no monadic version of that
12:13:13 <Iceland_jack> @ty genericReplicate
12:13:14 <lambdabot> Integral i => i -> a -> [a]
12:13:38 <cschneid> Iceland_jack: well, I don't mind it only taking an Int. I've moved on for the moment, I'll go look at it again later
12:13:47 <Iceland_jack> If you believe you key will ever exceed (maxBound ∷ Int) then you need fromIntegral
12:13:55 <cschneid> ahh, sure.
12:14:07 <Iceland_jack> either that or implement genericReplicateM :)
12:14:10 <cschneid> ahh, so Int == unboxed and Integer == boxed/infinite version?
12:14:26 <Iceland_jack> No, Int is boxed
12:14:29 <Iceland_jack> Int# is unboxed
12:14:32 <cschneid> I suppose I wasn't clear on the difference (other than knowing they were different.)
12:14:50 <xico> skypers: have you tried without your null pointers?
12:14:56 <cschneid> ok, box is the wrong word. Int == some known range of values, Integer == infinite length numbers
12:15:06 <xico> skypers: like allocating a sys
12:15:26 <Iceland_jack> Yes
12:15:48 <skypers> 21:05 < xico> skypers: like allocating a sys
12:15:54 <skypers> I don’t know how could I do that
12:16:01 <skypers> since sys isn’t in Storable
12:16:15 <Iceland_jack> cschneid: You can quite easily implement genericReplicateM though
12:16:24 <Iceland_jack> @src replicateM
12:16:24 <lambdabot> replicateM n x = sequence (replicate n x)
12:16:28 <Iceland_jack> :t \n x -> sequence (genericReplicate n x)
12:16:28 <lambdabot> (Integral i, Monad m) => i -> m a -> m [a]
12:16:30 <cschneid> Iceland_jack: of course. But I think I'm doing things wrong if I need it :)
12:16:34 <cschneid> (for this problem)
12:16:39 <Iceland_jack> yes possibly
12:16:55 <xico> skypers: generate an instance for it then
12:17:02 <xico> skypers: you can do that automagically
12:17:36 <xico> (more or less)
12:17:43 <skypers> xico: it’s an opaque C structure
12:17:54 <skypers> even in C you cannot allocate by yourself it
12:17:56 <skypers> (FMOD_SYSTEM)
12:18:05 <skypers> FMOD_SYSTEM sys; would result in a compiler error
12:18:14 <skypers> you can only do FMOD_SYSTEM *psys;
12:18:37 <jozefg> Does anyone here have any recommendations for good intermediate advanced books on category theory
12:19:26 <Iceland_jack> jozefg: http://wiki.portal.chalmers.se/cse/pmwiki.php/CTFP11/CTFP11 there are good references here
12:19:34 <xico> skypers: why doesn't fmodSystemCreate return an opaque pointer then?
12:19:53 <xico> skypers: ok
12:19:56 <Iceland_jack> @def genericReplicateM n x = sequence (genericReplicate n x)
12:19:56 <lambdabot>  Defined.
12:20:31 <xico> skypers: can you paste the ffi code?
12:20:36 <skypers> sure
12:20:43 <skypers> https://github.com/skypers/hsFModEx
12:20:44 <skypers> here
12:20:50 <skypers> https://github.com/skypers/hsFModEx/tree/master/Sound/FModEx
12:20:52 <skypers> all is here
12:20:53 <skypers> :)
12:20:58 <skypers> it’s quite minimalistic for now
12:21:22 <jozefg> Iceland_jack: I've read them all, I think I've become addicted to category theory
12:21:36 <Iceland_jack> jozefg: That sounds unhealthy :)
12:21:53 <Iceland_jack> Didn't you know abstractness makes you brain go mooshy
12:22:21 <carter> huh, theres a positive "learning haskell" post on the front page of hacker new. everyone upvoate it!  https://news.ycombinator.com/news
12:22:51 <jozefg> Iceland_jack: Maybe not, but my category theoretic names are going to get my bludgeoned to death by my fellow contributors
12:22:59 <jozefg> *me
12:23:04 <Iceland_jack> haha
12:23:30 <Iceland_jack> just be careful not to overuse category theory where it's not needed, that seems to happen a bit
12:23:59 <Hodapp> Iceland_jack: probably a lesser vice than overusing OOP.
12:24:03 <Iceland_jack> ;)
12:24:12 <Iceland_jack> at least humans appear to understand OOP
12:24:15 <Iceland_jack> cschneid: If you're unclear about ‘what’ Integral is, you can think of it as a set of types that a like integers: Integral = { Integer, Int, Int8 Int16, Int32, Int64, Word8, Word16, … }
12:24:30 <Hodapp> Iceland_jack: how is appearing to understand it a good thing?
12:24:51 <jozefg> Iceland_jack: Tbh I find OOP completely counter intuitive (class based at least)
12:24:56 <cschneid> Iceland_jack: right. Why is replicate implemented as `Int` then? seems odd to have it so restricted?
12:25:07 <Iceland_jack> cschneid: It's kind of a mistake
12:25:10 <skypers> xico: if you have any clue please let me know :) thanks for your help btw!
12:25:20 <Iceland_jack> which is why the generic* functions exist in Data.List
12:25:43 <cschneid> Iceland_jack: ahh, cool. Makes sense. The really basic stuff in haskell was done super early, and mistakes were easier to make
12:25:45 <Iceland_jack> jozefg: I agree with that :)
12:27:51 <Iceland_jack> Not that you often need to replicate something more often than (maxBound ∷ Int) ;) but it saves you a fromIntegral
12:31:20 <fizruk> danilo2, ping
12:31:31 <xico> skypers: you could write "type FModSystem = Ptr ()", then allocate one in your main with "sys <- alloc", and call "fmodSystemCreate sys", whose type is now "Ptr FModSystem -> IO FModResult"
12:32:17 <xico> skypers: that would solve your "with nullPtr $ \s -> return s" which do not really make sense
12:33:01 <xico> skypers: also, do not forget to free the allocs, and wrap all that in a nice haskellish high level interface
12:33:37 <xico> skypers: maybe with functions like "withSystem :: (FModSystem -> IO a) -> IO a"
12:37:38 * hackagebot Hipmunk 5.2.0.12 - A Haskell binding for Chipmunk.  http://hackage.haskell.org/package/Hipmunk-5.2.0.12 (FelipeLessa)
12:37:40 * hackagebot HipmunkPlayground 5.2.0.8 - A playground for testing Hipmunk.  http://hackage.haskell.org/package/HipmunkPlayground-5.2.0.8 (FelipeLessa)
12:38:43 <tac> oooo hipmunk
12:38:55 * tac has always wanted to play with hipmunk
12:39:44 <petantik> isn't hipmunk also an airline travel company?
12:42:38 * hackagebot hsnock 0.1.3 - Nock 5K interpreter.  http://hackage.haskell.org/package/hsnock-0.1.3 (mrdomino)
12:52:40 * hackagebot verbalexpressions 1.0.0.0 - Regular expressions made easy  http://hackage.haskell.org/package/verbalexpressions-1.0.0.0 (klrr)
12:52:58 <skypers> xico: thanks for your feedback
12:53:03 <skypers> for the frees
12:53:08 <skypers> yes, I plan to free all the alloc
12:53:19 <skypers> but I didn’t Ptr () could be used for opaque structure
12:53:23 <skypers> but hm
12:53:26 <skypers> thinking of it
12:53:31 <skypers> it could be done the same way in C
12:53:47 <skypers> because we’re not supposed to do anything else but use handles
12:53:54 <skypers> so void* is okish for that task
12:53:56 <skypers> thank you!
12:57:21 <stephenmac7> If I have this line:
12:57:22 <stephenmac7> (command:args) <- getArgs
12:57:33 <stephenmac7> How do I check if the pattern match failed?
12:57:49 <Iceland_jack> You don't, really :)
12:57:58 <stephenmac7> So, how would you handle that?
12:57:59 <Iceland_jack> the error in Monad will kick in
12:58:10 <Iceland_jack> do …; args ← getArgs; case args of …;
12:58:10 <Mdx> wrap it around a function?
12:58:17 <stephenmac7> Ah
12:58:19 <sipa> or, alternatvely, you create a different pattern for the case that would fail
12:58:33 <sipa> oglh
12:58:39 <sipa> sorry, this is in a monad
12:58:55 <stephenmac7> sipa: Yes, but if it's wrapped in a function...
12:59:32 <Iceland_jack> stephenmac7: It is possible to catch the result of error
12:59:43 <stephenmac7> case seems like it would work best
12:59:46 <Iceland_jack> but if you have the option, you should rather just case split
13:00:07 <stephenmac7> cases of what? length?
13:00:18 <Iceland_jack> just the case on the arguments
13:00:33 <stephenmac7> Oh, the arguments themselves, I see
13:00:52 <stephenmac7> How would I check just the head of the case?
13:01:30 <Iceland_jack> stephenmac7: Can you give me an example of what you want?
13:01:43 <stephenmac7> The arguments should look something like this
13:02:10 <stephenmac7> ["command", "-sm", "--someoption", "positional"]
13:02:13 <Iceland_jack> of course if you really want to parse user options for a serious application you should use a library
13:02:22 <stephenmac7> I tried using a library
13:02:41 <stephenmac7> After trying two, I decided to go back to doing it manually
13:02:45 <Iceland_jack>     do args ← getArgs
13:02:45 <Iceland_jack>        case args of
13:02:45 <Iceland_jack>          ["command", "-sm", "--someoption", "positional"] → ...
13:02:45 <Iceland_jack>          _ → printUsage
13:03:10 <stephenmac7> Iceland_jack: Any suggestions on a library?
13:03:38 <stephenmac7> Ah, so you're saying that I should patternmatch everything?
13:03:45 <stephenmac7> Including options
13:04:21 <Iceland_jack> CmdArgs is OK
13:04:29 <Iceland_jack> http://hackage.haskell.org/package/cmdargs-0.10.5
13:04:59 <stephenmac7> I tried console-program and optparse-applicative
13:05:38 <Iceland_jack> There is also http://hackage.haskell.org/package/options-0.1.1 ?
13:05:53 <Iceland_jack> it just depends on what you want
13:06:00 <Iceland_jack> for something simple, pattern matching should be fine
13:06:06 <stephenmac7> It's not simple
13:06:16 <Iceland_jack> well then find a library you like
13:06:32 <Iceland_jack> http://www.haskell.org/haskellwiki/Command_line_option_parsers
13:06:45 <stephenmac7> Problem I had with console-program was chaining arguments
13:06:46 <stephenmac7> http://hackage.haskell.org/package/console-program-0.3.1.1/docs/System-Console-Command.html#t:Action
13:07:00 <stephenmac7> options requires template haskell?
13:07:03 <Iceland_jack> Yes
13:08:22 <Iceland_jack> http://www.haskell.org/haskellwiki/GetOpt details on how to use GetOpt
13:08:29 <Iceland_jack> most of this information may be found by googling
13:09:25 <stephenmac7> Okay, I think I'll look for another library
13:09:34 <stephenmac7> Don't really like getopt but...
13:09:36 <Iceland_jack> My personal choice is not to accept command-line arguments and rather have users phone me up and tell me to change the source code
13:09:44 <Vamp> http://lpaste.net/6954972689966563328 how should I make this type correct?
13:09:49 <stephenmac7> Iceland_jack: :D
13:11:16 <Iceland_jack> Vamp: What is the point of run?
13:11:30 <Iceland_jack>     run scomp inistate = runState' scomp inistate
13:11:30 <Iceland_jack> means that
13:11:30 <Iceland_jack>     run = runState'
13:11:35 <Iceland_jack> with more restricted types
13:12:10 <Iceland_jack> Vamp: As to your question, if you find the types don't match try compiling without type signatures and ask GHCi
13:12:20 <Iceland_jack> In your case:
13:12:20 <Iceland_jack>     run :: State' s a -> (s, Counts) -> (a, s, Numbers)
13:12:41 <Iceland_jack> which is exactly the same as runState' since it's the same function
13:12:44 <supki_> stephenmac7: what was the problem with optparse-applicative?
13:13:03 <stephenmac7> supki_: The way it handles commands is confusing and unclean
13:13:09 <stephenmac7> submodule or something
13:13:34 <stephenmac7> Then it requires that they all be the same type and that pattern matching is done to serparate them
13:13:42 <stephenmac7> Plus, it has almost no documentation
13:14:42 * stephenmac7 must have documentation
13:14:48 <Iceland_jack> Vamp: You can do something like this:
13:14:49 <Iceland_jack>     run :: State' s a -> (s, Counts) -> (a, Numbers)
13:14:49 <Iceland_jack>     run scomp inistate = let (a, s, n) = runState' scomp inistate in  (a, n)
13:15:00 <Iceland_jack> But I don't know what you're trying to do
13:15:44 <adnap> Upi dpm
13:15:47 <adnap> Sorry
13:15:49 <stephenmac7> supki_: If you can find documentation that's actually useful and has examples...
13:16:18 <adnap> You don't need to compile without type signatures. The compiler will just say somethign like "could not match [your type] ... expected [inferred type]"
13:16:22 <edvo> Do you know some package for parsing network packages (from ByteString)? I would need some way to strip IP and TCP headers and extract the payload
13:16:49 <Iceland_jack> adnap: Indeed, I find compiling without signatures clearer personally
13:17:10 <supki_> stephenmac7: well, readme actually had enough examples for me
13:17:16 <supki_> stephenmac7: https://github.com/pcapriotti/optparse-applicative/blob/master/README.md
13:17:25 <supki_> stephenmac7: any examples in particular you find missing?
13:17:27 <stephenmac7> I read the whole thing
13:17:47 <stephenmac7> This section: https://github.com/pcapriotti/optparse-applicative/blob/master/README.md#commands
13:18:06 <stephenmac7> Needs a complete, large example
13:18:10 <Vamp> Iceland_jack: The point of run is running a state monadic computation given an initial state (inistate) and return the computed value together with the counted number of operations
13:18:25 <stephenmac7> Actually, I would love it if I could find some software that uses it
13:18:42 <Iceland_jack> Vamp: counted number of operations?
13:18:54 <Iceland_jack> That sounds un-monadic, maybe you're looking for arrows
13:19:07 <Vamp> The Numbers data
13:20:10 <Iceland_jack> Vamp: So what should the count for:
13:20:11 <Iceland_jack>     return a >>= f
13:20:11 <Iceland_jack> be?
13:20:44 <stephenmac7> supki_: Best thing I can find is https://github.com/pcapriotti/optparse-applicative/blob/master/tests/Examples/Commands.hs
13:21:05 <Vamp> Iceland_jack: Numbers 1 1 0 0
13:21:10 <stephenmac7> However, it only has one command with arguments
13:21:16 <Iceland_jack> Vamp: And what about
13:21:16 <Iceland_jack>     f a
13:21:16 <Iceland_jack>  
13:21:40 <supki_> stephenmac7: well, I have a couple of parsers with subcommands
13:21:45 <Iceland_jack> Violating the monad laws :)
13:21:52 <supki_> not sure how useful they will be for you though :)
13:22:02 <stephenmac7> Can I see them?
13:22:14 <supki_> stephenmac7: https://github.com/biegunka/biegunka/blob/develop/bin/biegunka/Options.hs#L35
13:22:21 <Vamp> Iceland_jack: Numbers 0 0 0 0 ?  I'm not sure
13:22:34 <Iceland_jack> Vamp: (return a >>= f) should always equal (f a)
13:22:38 <Iceland_jack> stephenmac7: Is there any particular problem you're stuck on?
13:22:43 * hackagebot hzk 1.0.0 - Haskell client library for Apache Zookeeper  http://hackage.haskell.org/package/hzk-1.0.0 (DiegoSouza)
13:22:56 <Iceland_jack> Or did you decide against it because you feel the documentation isn't good enough
13:23:01 <Vamp> Iceland_jack: So then Numbers should be equal too
13:23:24 <stephenmac7> Iceland_jack: I coulodn't get multiple subcommands to work with arguments
13:23:40 <stephenmac7> But accidentally deleted the code because of faulty tab completion
13:23:45 <Iceland_jack> Vamp: You can't ‘count’ the number of binds and returns without violating the laws
13:24:31 <Iceland_jack> Unless you really dislike the library you could have asked about that particular issue rather than changing libraries
13:25:27 <stephenmac7> Iceland_jack: I asked when I ran into an issue with console-program but no one responded
13:25:48 <stephenmac7> So I switched to optparse-applicative and ran into an issue and asked about it again
13:25:51 <stephenmac7> No one answered
13:25:57 <stephenmac7> ...must have been a slow day
13:26:08 <Iceland_jack> Possibly, normally questions get responses here
13:27:05 <skypers> xico: even after what you advised
13:27:09 <skypers> I get no sound :(
13:27:31 <stephenmac7> Iceland_jack: It seems that when you use a library, the number of repsponses drops significantly
13:28:02 <skypers> xico: https://github.com/skypers/hsFModEx/blob/master/Sound/FModEx/Types.hsc#L226
13:28:09 <Iceland_jack> Well that's to be expected, there are often many to choose from and not everyone has experience with your particular one at that particular time
13:28:09 <stephenmac7> supki_: Thanks
13:28:23 <stephenmac7> Iceland_jack: Exactly
13:28:36 <stephenmac7> Anyway, I have to go now
13:28:42 <stephenmac7> I'll push harder on optparse later
13:29:03 <skypers> is it sane to state that opaque C structure must me represented as Ptr () ?
13:29:05 <Iceland_jack> Good luck stephenmac7, hope you get better responses in the future
13:32:17 <jfischoff> stephenmac7: I would look up the opt-parse reverse deps
13:32:37 <jfischoff> I'm too lazy to do it for you :p
13:32:50 <dgvncsz0f> skypers: I suppose this isn't the case. You are free to use any type, like `data Void; type CVoid = Ptr CVoid;'
13:32:50 <joelteon> ~ is type equality, right? is there a type inequality operator?
13:33:05 <dgvncsz0f> ops, `data Void; type CVoid = Ptr Void'
13:33:06 <jfischoff> joelteon: no
13:33:10 <joelteon> damn.
13:33:38 <skypers> dgvncsz0f: I see…
13:33:39 <jfischoff> all is not lost. You can write your own type level equality functions that might still be useful
13:33:42 <joelteon> I just want to make a version of Show that's special-cased on String so that it returns the String, not a Shown version
13:33:46 <skypers> so the error is not here
13:33:52 <skypers> but where…
13:33:57 <joelteon> is such a thing possible?
13:34:00 <jfischoff> look at the singletons ByHand.hs function on github for examples
13:34:08 <skypers> the exact same code in C actually runs the way I expcet
13:34:10 <skypers> expect
13:34:13 <skypers> why not the Haskell one?
13:34:38 <joelteon> oh, interesting
13:35:05 <jfischoff> joelteon: one more thing http://www.haskell.org/haskellwiki/GHC/AdvancedOverlap
13:35:25 <skypers> hey dgvncsz0f
13:35:30 <skypers> for opaque type
13:35:35 <skypers> could I even use ()
13:35:36 <skypers> like
13:35:48 <skypers> well no
13:35:55 <skypers> it will lead in compiler mistake
13:35:58 <joelteon> jfischoff: awesome
13:36:03 <skypers> I’m gonna stay with newtypes
13:36:05 <joelteon> jfischoff: thanks a lot
13:36:07 <xico> skypers: can you paste back your updated main?
13:36:51 <skypers> I just replace the with nullPtr by alloca
13:37:02 <jfischoff> joelteon: np, but caveat emptor
13:38:13 <skypers> seriously
13:38:15 <skypers> it’s weird
13:38:27 <skypers> might it be a GHC error?
13:38:52 <xico> skypers: you also need to modify the other functions
13:38:55 <dgvncsz0f> skypers: you can, actually. Ptr () is fine, but isn't mandatory (that is what I was referring to). It is just useful to type them, makes it easier to spot mistakes... :-)
13:38:57 <danilo2> fizruk, ping
13:39:08 <fizruk> danilo2, pong
13:39:18 <skypers> xico: already done Ptr (Ptr FModSystem) is now Ptr FModSystem
13:39:26 <danilo2> fizruk: hello :) I've seen, you've pinged me, while I was not available :)
13:39:44 <danilo2> fizruk: I was thinking about it and scratching my head but without any results so far.
13:39:45 <fizruk> danilo2, yeah, I got kind of solution
13:39:45 <skypers> dgvncsz0f: yeah but if a function takes a Foo
13:39:52 <skypers> (Foo = ())
13:39:58 <xico> skypers: i mean your fmodSystemInit would then be "FModSystem -> CInt -> …
13:39:58 <skypers> and I pass a Bar (Bar = ())
13:39:59 <danilo2> fizruk: really? \o/
13:40:05 <skypers> it will pass, won’t it?
13:40:17 <skypers> xico: look at my github
13:40:31 <skypers> oh it’s not updated
13:40:32 <xico> skypers: yep, Functions.hsc need update
13:40:32 <skypers> wait
13:40:35 <fizruk> danilo2, posted on SO
13:40:35 <skypers> yeah
13:40:46 <danilo2> fizruk: Ok, I'm looking there right now :)
13:40:48 <skypers> I haven’t commited the patch yet
13:41:01 <xico> skypers: your main should not include any peek now
13:41:16 <skypers> done
13:41:27 <skypers> huh actually it does
13:41:40 <skypers> gonna rewrite then
13:41:59 <xico> skypers: repaste your full main if it still does not work
13:42:40 <xico> skypers: also, you could use -S to check that the generated assembly (or llvm assembly) looks good (ie comparable to the one generated by the c code)
13:43:56 <skypers>     Couldn't match type `Ptr ()' with `()'
13:44:01 <skypers> got a lot of that
13:44:04 <skypers> ne peek
13:44:05 <skypers> no*
13:44:07 <skypers> just
13:44:16 <skypers> sys <- alloca $ \s -> … >> return s
13:44:26 <danilo2> fizruk: give me a second - I have a skype call riht now and I have to analyze everythong you've written there, brb :)
13:44:28 <xico> skypers: no
13:44:42 <skypers> oh
13:44:43 <skypers> yes
13:44:48 <skypers> I’m an idiot
13:45:21 <skypers> well actually
13:45:32 <skypers> alloca takes a function that take a pointer, and is IO b
13:45:33 <skypers> si
13:45:33 <dgvncsz0f> skypers: err, not sure what you meant, but I guess not (at least not without castPtr)
13:45:38 <skypers> alloca $ \s
13:45:39 <skypers> here
13:45:49 <skypers> s is a pointer on FModSystem
13:45:51 <skypers> return s
13:45:52 <skypers> is
13:45:55 <skypers> IO FModSystem
13:45:56 <xico> skypers: do not return the pointer given by alloca, it is freed after the alloca
13:45:57 <skypers> isn’t it?
13:46:04 <skypers> oh
13:46:05 <skypers> yes
13:46:09 <skypers> damn me…
13:46:11 <xico> skypers: use "sys <- alloc"
13:46:18 <xico> and manually free at the end
13:46:24 <skypers> xico: or
13:46:25 <xico> or put everything inside the alloca
13:46:26 <skypers> alloca
13:46:33 <skypers> and nested calls
13:46:36 <skypers> yeah
13:46:45 <skypers> sounds better for me
13:47:46 * hackagebot stompl 0.0.3 - Stomp Parser and Utilities  http://hackage.haskell.org/package/stompl-0.0.3 (TobiasSchoofs)
13:47:48 * hackagebot stomp-queue 0.0.5 - Stompl Client Library  http://hackage.haskell.org/package/stomp-queue-0.0.5 (TobiasSchoofs)
13:48:16 <xico> skypers: you may have the same problem with your usage of withArray
13:48:55 <dgvncsz0f> question! i have uploaded the documentation for a package on hackage (neat feature, congrats!!!)... however, what is the better way to produce the `safe haskell' flags?
13:49:47 <dgvncsz0f> is there any program that is able to infer them, or should it be written manually?
13:50:25 <Heffalump> as I understand it the compiler normally infers safeness
13:50:35 <Heffalump> but "trustworthy" is manually applied
13:50:51 <skypers> xico: nope
13:51:04 <skypers> because I use withArray to feed a function a String
13:51:09 <skypers> that’s all
13:51:21 <xico> skypers: don't
13:51:37 <xico> skypers: use Foreign.C.String
13:51:47 <skypers> withCString ?
13:52:02 <xico> for instance, if the function you are calling wont reference it afterwards
13:52:04 <skypers> because otherwise it may ommit the final \0?
13:53:25 <dgvncsz0f> Heffalump: do you know the exact command I should be using? I'm currently using: cabal haddock --contents-location=/package/hzk-1.0.0 --hyperlink-source --html-location=/package/hzk-1.0.0/docs
13:53:35 <danilo2> fizruk: Ok, I've checked your answer and it indeed works great :) I really do not want to say that, but I'm not sure it works for all cases though :( (but I hope, I'm wrong): Using existential datatypes and defining Printable we say what is the result of "method1" of **any** "OO class"? So we cannot make different "OO classes" with implementations of "method1" returning different things?
13:53:40 <skypers> xico: if I do
13:53:43 <dgvncsz0f> and it gets generated like this: http://hackage.haskell.org/package/hzk-1.0.0/docs/Database-Zookeeper.html
13:53:45 <skypers> alloca $ \sys
13:53:49 <skypers> and sys :: FModSystem
13:53:53 <skypers> :: Ptr ()
13:53:56 <danilo2> fizruk: Or we have to make egzystential datatype with all possible methods acrosss all possible classes?
13:54:04 <skypers> what’s the best type for sys?
13:54:07 <skypers> Ptr FModSystem?
13:54:17 <danilo2> fizruk: this small egzample demosntrates the problem I think: http://lpaste.net/94603 ?
13:54:25 <skypers> if I want to use only FModSystem
13:54:27 <skypers> I need to peek
13:54:39 <danilo2> fizruk: am I right?
13:56:06 <xico> skypers: dont peek
13:56:07 <skypers> YEAH
13:56:08 <skypers> IT WORKS
13:56:17 <skypers> with peeks tho
13:56:36 <skypers> xico: I obviously need to peek
13:56:45 <skypers> FModSystem :: Ptr ()
13:56:49 <skypers> FModSystem -> IO ()
13:56:53 <skypers> alloca $ \s
13:56:58 <skypers> if s is Ptr FModSystem
13:57:00 <skypers> I need to peek
13:57:34 <xico> yes
13:57:40 <xico> (actually)
13:57:55 <skypers> :)
13:57:59 <fizruk> danilo2, if you want to use method1's return value in any undetermined way (like in your example) you may need Data.Dynamic or similar thing, I guess
13:57:59 <skypers> yeah
13:58:01 <skypers> I have SOUND
13:58:04 <skypers> with MY binder
13:58:06 <skypers> \m/
13:59:27 <Twey> danilo2: Your use of ‘gz’ for ‘x’ is disturbing :þ
14:00:17 <fizruk> danilo2, the solution presented does give you some static garantees (which I believe you wanted actually)
14:00:33 <danilo2> fizruk: give me a second
14:00:50 <danilo2> Twey: oh :D I'll try to figz my spelling :D
14:02:04 <Twey> Haha
14:02:19 <Twey> danilo2: What's your question?  I wasn't looking when you linked it
14:02:48 <danilo2> Twey: http://stackoverflow.com/questions/19484232/oop-using-haskell-type-system/19504086?noredirect=1#19504086
14:03:41 <simpson> danilo2: This entire exercise seems a little contrived, since objects contain both state and behavior, by definition; are you just building this for fun, or as part of something serious?
14:04:48 <Twey> Oh, I see
14:04:52 <Twey> Yes
14:05:40 <danilo2> simpson: Maybe word "object" is wrong in this case. By "object" I mean a structure with methods, which can return new (changed) instances of such objects. I'm building it with a couple of friends and we are trying to make a language, which will be specialized in dataflow processing.
14:05:56 <ParahSailin> do you not need to use a pragma for PatternGuards?
14:06:12 <simpson> danilo2: Yeah, this sounds like C rather than like actual objects.
14:06:31 <danilo2> simpson: We have written compiler, some optimization passes, a GUI but we didnt saw this problem before. We are planning to release this as opensource project if it will really start working as we want
14:06:38 <joelteon> hey, can anybody help me out with this? https://gist.github.com/joelteon/7090869
14:07:49 <Twey> I'm sure there was a proposal that had typeclasses for ‘has such a field’; anyone remember where that was/what it was called?
14:07:53 <joelteon> why does instance flag ~ HFalse => StringPred a flag overlap StringPred String HTrue?
14:08:09 <joelteon> aren't they mutually exclusive?
14:08:20 <geekosaur> ParahSailin, pattern guards are in Haskell 2010
14:08:39 <geekosaur> they were a separate extension in H'98
14:08:51 <joelteon> maybe I should put it on hpaste, that's probably a better idea
14:08:58 <geekosaur> but see the first production for "guard" in http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-460003.13
14:09:09 <lpaste> joelteon pasted “GADT problem” at http://lpaste.net/94606
14:09:10 <jfischoff> joelteon: the context is not looked at for instance selection
14:09:23 <jfischoff> so they do overlap
14:09:24 <danilo2> fizruk: do you think it is undetermined? I mean - normal Haskell functions behave like so, dont they? I'm not sure - I'm just asking. Look, if we cut the previous solution to this code (annotation): http://lpaste.net/94603 - it works and types very strictly, hm?
14:09:26 <joelteon> oh, really?
14:09:59 <jfischoff> you need* overlapping for that trick
14:10:00 <joelteon> huh
14:10:08 <danilo2> Twey: Oh, such proposal will solve this problem?
14:10:26 <Twey> danilo2: I think it's at least relevant to you
14:11:15 <joelteon> hey! it works now
14:11:22 <joelteon> I could have sworn I turned on overlapping instances, but I actually didn't
14:11:25 <ParahSailin> geekosaur: ah, i'd always put that extension pragma in whenever i used them, and i just noticed that i forgot to put it in and ghc still liked it
14:11:25 <joelteon> silly me
14:11:30 * jfischoff nods 
14:11:31 <jfischoff> great
14:11:40 <ParahSailin> geekosaur: was just checking that some other behavior did not happen
14:11:59 <danilo2> Twey: but I'm amazed, that this is not possible with "simple haskell". I know this needs RankNTypes, but I'm still sure, we should be able to type this solution without using existential datatypes. If you look at fizruk solution on SO (which is of course great), I fell it is not so good as it could be, because it forces **all** classes (OO)
14:12:22 <danilo2> Twey: to have methods with the same name to return the same existential datatype
14:13:09 <fizruk> danilo2, the problem is that you abstract away both the object and the methods' arguments/return type
14:13:32 <danilo2> Twey: which is not so cool. If you look at my code example (annotation  to: http://lpaste.net/94603) It works and types fine, providing for us exactly what I need. (it works because it has no other funciton call in lines 23-24)
14:13:59 <fizruk> danilo2, in such a way it is only possible to do things dynamically
14:14:47 <fizruk> danilo2, I don't get what you mean by "forces **all** classes (OO)"
14:14:54 <danilo2> fizruk: hmm, I do not see it really - Why following code (annotation) then works?: http://lpaste.net/94603 (it is **almost**) the same - function f works on X and Y and it provides results, which depends on oinput types
14:15:29 <geekosaur> fizruk, see continuation
14:15:35 <geekosaur> "to have methods..."
14:15:35 <fizruk> danilo2, try to use method1 with strings *and* ints in f
14:15:53 <danilo2> fizruk: I mean, that in your solution, we say "method :: forall a b. (Show a, Show b) => (a, b) -> c -> Printable" , so **any** class, which has method named "method" have to return Printable
14:17:47 <fizruk> danilo2, eh... as I said, if you want to get anything from everything, use Data.Dynamic or similar
14:18:28 <danilo2> fizruk: So if we want allow user define custom classes, it is undoable I think. But I don't get 1 think, namely, why the code: http://lpaste.net/94607 works and we cannot simply make a version of this code with an additional "print" in line 23-24? The types should be exactly the same imo :(
14:18:36 <fizruk> danilo2, if you can see how the method is used, you can make the appropriate existential wrapper (like Printable)
14:19:29 <fizruk> danilo2, nope
14:19:50 <fizruk> danilo2, ask ghci what type does f have in your paste
14:19:52 <danilo2> fizruk: I understand it and I do not want to use dynamic :( I want the final code to be fast. But could you please explain to me the difference between http://lpaste.net/94607 and what I'm trying to get?
14:20:36 <fizruk> danilo2, the difference is that code in your paste is not as polymorphic as you want in general case
14:20:55 <danilo2> fizruk: Ok, it will be not the same type (of course - sorry for that), but cannot we somehow using Rank2Types do it? There is a lot of OO languages, which have types (C++, Java) etc and all of them allow such behavior. Why haskell does not ?
14:21:52 <qz> anyone used conduits library? if i try to use drop on a source it drops all items no matter what..
14:22:02 <fizruk> danilo2, I'm not sure C++ allows such behavior
14:22:09 <danilo2> fizruk: So Haskell s type system is worse then C++ or Javas one? Cannot we simply mimic "objects with methods"?
14:22:23 <danilo2> fizruk: give me a second. I'll make C++ code
14:22:35 <fizruk> danilo2, and I guess Java uses reflection of some kind for that
14:22:48 <danilo2> fizruk: I hope I'll make. Ihavent touched it for a time.
14:22:49 * hackagebot lens-aeson 0.1.2 - Law-abiding lenses for aeson  http://hackage.haskell.org/package/lens-aeson-0.1.2 (EdwardKmett)
14:22:52 <danilo2> fizru: brb
14:23:38 <Iceland_jack> danilo2: “This dog will not swim, does that mean it's worse than this fish”
14:24:35 <danilo2> Iceland_jack: I know, but I'm suprised, this dog cannot breath under the water :)
14:24:37 <fizruk> danilo2, haskell's type system is restrictive and that's why it's better
14:27:29 <dgvncsz0f> for the record, {-# LANGUAGE Safe #-} did the trick... haddock notice that and added proper safe haskell flags :-)
14:27:50 * hackagebot HaRe 0.7.0.7 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.0.7 (AlanZimmerman)
14:27:52 * hackagebot hzk 1.0.1 - Haskell client library for Apache Zookeeper  http://hackage.haskell.org/package/hzk-1.0.1 (DiegoSouza)
14:28:01 <dgvncsz0f> Heffalump: thanks for the help...
14:31:32 <Heffalump> dgvncsz0f: oh, I see. That part of it didn't occur to me :-)
14:32:06 <skypers> night folks
14:32:23 * r``t <3 haskell
14:38:03 <danilo2> fizruk: If you compile this code: http://lpaste.net/94609 it wokrs, and for X returns Int, for Y returns String. I'm sure it can be better templated than this one, but maybe you're right, that Haskells type sustem is better and I'm not seeing it exactly. In that case, where can I read about the theoretical backgorund of Haskell type system? I would love to **deeply** understeand all the desing decisions :)
14:39:30 <Iceland_jack> danilo2: How much of Haskell have you studied?
14:39:32 <jle`> danilo2: it's being thrown around here casually, but "better" and "worse" aren't really meaningful terms.  C++/Java's type system is great for its own purposes and Haskell's is as equally good if not better for its own purposes.
14:39:44 <danilo2> Twey: Did you remember how this extension proposal was called?
14:40:59 <fizruk> danilo2, and now add x.method1("Hello", "there") to the f's body
14:41:30 <danilo2> Iceland_jack: not very long
14:41:39 <danilo2> fizruk: ah, I forgot about it, brb
14:42:05 <Iceland_jack> danilo2: Quite possibly this? http://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/Plan
14:43:37 <Iceland_jack> My comment about the ‘dog’ and the ‘fish’ earlier mirror what jle` said: it's not about being better but about different approaches
14:44:46 <letrec> I'd like to do something like: http://lpaste.net/94610
14:45:27 <letrec> Doesn't compile - any idea or pointer to a relevant example? Thx
14:45:43 <johnw> you don't need generics or type classes to write a T a b c d -> [a] function
14:46:01 <cschneid> Iceland_jack: thank you for your advice earlier. The code is MUCH cleaner after a few types being introduced. And far easier to reason about.
14:46:08 <johnw> conv (List x) = x; conv (Tup1 x) = [x]; conv (Tup2 x _) = [x], etc.
14:46:12 <Iceland_jack> cschneid: Glad to hear it!
14:46:30 <letrec> I'd like to have the code generated
14:46:48 <danilo2> fizruk: here you go: http://lpaste.net/94609
14:47:06 <danilo2> fizru: btw C++ is ugly :)
14:48:20 <danilo2> Iceland_jack: I'm writing now a "big" priject in Haskell. I'm not "studied" it long. Where can I learn the theory behind it?
14:48:28 <fizruk> danilo2, uuic cout << x works for any x
14:48:51 <Iceland_jack> well I'm first interested in knowing why you're attempting to basically make objects in Haskell?
14:49:07 <danilo2> fizruk: what does uuic mean ?
14:49:42 <fizruk> danilo2, i meant "if i understood correctly", iiuc, sorry
14:49:47 <Iceland_jack> Are you doing it to experiment or is that the style of Haskell you plan on using
14:49:47 <danilo2> Iceland_jack: http://stackoverflow.com/questions/19484232/oop-using-haskell-type-system
14:50:45 <danilo2> fizruk: ah ok :) I'll remember that shortcut. No, we can cout only objects of class ostream (http://www.cplusplus.com/reference/iostream/cout/)
14:50:54 <fizruk> danilo2, you're not enforcing any check on what's x.method1("hello", "world") is
14:51:14 <carter> ooo, ihaskell http://gibiansky.github.io/IHaskell/
14:51:21 <danilo2> fizruk: yes, but If I try to use it with wrng type, compiler will not allow me to
14:51:53 <fizruk> danilo2, i guess you could make even x.method1(...).method2(...) without knowing for sure if there can be method2 (or even method1)
14:52:29 <fizruk> s/can be/is/
14:52:32 <danilo2> fizruk: yes, but if I try to use it, the compiler will complain for all the types, which will fail
14:53:28 <Iceland_jack> danilo2: Not sure about the “theory” behind Haskell, it's based on certain formalisms but there is no Grand, Unified Theory of Haskell
14:53:47 <danilo2> fizruk: please look at the annotation here: http://lpaste.net/94609
14:54:15 <Iceland_jack> Perhaps related to what you're attempting to do, Haskell and functional style in general attempts to separate values from the functions that operate on them
14:54:34 <monochrom> I understand wanting to express OOP in Haskell, manually or mechanically. but like Cale says, use records, not classes.
14:54:40 <carter> yeah
14:54:52 <carter> idris/agda records are ven cooler
14:54:56 <carter> but, baby steps :)
14:54:58 <carter> *even cooler
14:56:41 <fizruk> monochrom, I think the problem being discussed is not about OOP per se, but some extreme form of ad hoc polymorphism (I may be wrong)
14:57:08 <danilo2> Twey: The extension proposal you've posted seems very very interesting. Maybe it solves even the problems I'm faicng right now! I see there is a prototype of it. Do you know it will be available in Haskell any time or how can I test it right now ?
14:58:06 <danilo2> monochrom: I'm using records. I Was saing "classes" in OO meaning (as records having methods) - but you're right. records are much better word, see: http://stackoverflow.com/questions/19484232/oop-using-haskell-type-system
15:00:03 <dr_diagoras> insist :: Monad m => m (Maybe a) -> m a
15:00:10 <dr_diagoras> insist action = action >>= maybe (insist action) return
15:00:13 <Iceland_jack> danilo2: So the methods of your classes cannot modify their state?
15:00:41 <dr_diagoras> sorry to intervent, but anyone else finds this idiome pretty?
15:00:58 <Iceland_jack> dr_diagoras: I'm not a fan of ‘maybe’
15:01:02 <sclv_> dr_diagoras: eh it only works in some monads :-)
15:01:08 <sclv_> other than that its v. cute
15:01:12 <danilo2> Iceland_jack: exactly. They can return a new "object/record" with modified fields instead
15:01:20 <danilo2> Iceland_jack: there are no mutable objects there
15:02:04 <Iceland_jack> What is gained from that as opposed to separating the functions and the data?
15:02:07 <sclv_> and sadly the monads it does work in like IO, I'd probably want to often have some sort of thread delay between tries, etc
15:02:12 <dr_diagoras> I just found that roughly half of ugly MaybeT usages in my code can be replaced with this :-)
15:02:14 <sclv_> rather than just hammering on it over and over
15:02:18 <srhb>   c <- use (buffer.contents); unless (endp c) $ do
15:02:20 <srhb> Oops
15:02:30 <srhb> Meant to paste that properly - anyway, am I missing some lensy goodness there?
15:04:01 <dr_diagoras> hm...
15:04:26 <danilo2> Iceland_jack: the "classes/records" have fields and methods. Maybe "classes in OO meaning" is really wrong word to describe it.
15:04:26 <dr_diagoras> insistInterleaving :: Monad m => m (Maybe a) -> m () -> m a
15:05:02 <sclv_> looks good, ship it :-)
15:05:11 <dr_diagoras> insistInterleaving action delay = action >>= maybe (delay >>= insist action) return
15:05:35 <fizruk> Iceland_jack, smth like data Counter = forall self. {_self :: self, _inc :: self -> self, _reset :: self, _value :: forall a. Num a => self -> a } ?
15:06:27 <glguy> srhb: No, there isn't an "unlessOf"
15:06:34 <srhb> glguy: Sadface.
15:06:35 <Iceland_jack> What danilo2 is talking about sounds a lot like dependent products
15:06:36 <dr_diagoras> though name too long to type :-)
15:06:54 <glguy> srhb: it wouldn't really buy you anything
15:07:04 <srhb> glguy: No.. The problem is the m.
15:07:15 <srhb> uses (buffer.contents.???) >>= ???
15:07:18 <srhb> Or something.
15:07:27 <glguy> srhb: you could do: uses (buffer.contents) endp
15:07:33 <srhb> Yeah.
15:07:51 <fizruk> Iceland_jack, hmm... is it possible to model dependent type with type family?
15:07:59 <glguy> thing <- uses (buffer.contents) endp; unless thing $ do...
15:08:04 <Iceland_jack> to a certain extent
15:08:15 <fizruk> Iceland_jack, s/dependent type/dependent product/
15:08:29 <jfischoff> is there a name for the equality operation (Typeable n, Typeable m) => Foo n -> Foo m -> Bool ?
15:08:30 <fizruk> Iceland_jack, I tried to make it, but failed
15:09:07 <fizruk> Iceland_jack, I mean for what danilo2 is trying to achieve
15:09:11 <Iceland_jack> hm
15:09:36 <Iceland_jack> It may be possible, not idiomatic of course
15:11:43 <fizruk> danilo2, are you sure you want that flexibility in your project?
15:12:43 <fizruk> danilo2, perhaps if you supplied a motivation example for this feature we might suggest something better
15:12:51 <danilo2> fizruk: I would love to, if it will be able to generate fast final binaries ... I do not know what are dependent products, but If it could help it I would be very happy
15:13:40 <fizruk> dependent product is simply a product where type of the second value depends on value of the first
15:14:14 <danilo2> fizruk: ok, so dependent products sound like exactly what I'm trying to model here
15:14:17 <tac> "dependent product" is somewhat ambiguous, though.
15:14:34 <danilo2> fizruk: What do you mean by "supplied a motivation example" ?
15:14:50 <tac> There are reasons to call both dependent pairs and dependent functions "dependent products"
15:16:30 <sclv_> tac sure but i think its clear from fizruk's description he means sigma
15:16:54 <Iceland_jack> I mean if you want something like:
15:16:54 <Iceland_jack>     x.length()
15:16:54 <Iceland_jack> that depends on the type of x, that is easily done
15:17:00 <fizruk> danilo2, use case in DSL you're making which makes use of the feature (and shows that other approaches do not fit)
15:18:27 <Flonk> "No instance for (Monad ((->) Int)) arising from a use of 'ap' [...]"
15:18:33 <Flonk> Is that not in Haskell 98 or something?
15:18:47 <danilo2> fizruk: Ok, I'll write you a story, what I'm doing. I'll try to make it not very long :)
15:19:04 <geekosaur> Flonk, probably just missing an import.
15:19:12 <danilo2> fizruk: Maybe it would be good to explain a little more, what I (or we, because I'm working with 5 other people on this project) aiming to do. Starting from the beginning: Most of us were working as "technical directors" in film studios and we were writing tools for creating film special effects. These tools were used mainly by non-technical people
15:19:12 <fizruk> Flonk, Control.Monad.Reader
15:20:15 <Flonk> fizruk: I'm not using reader, and it compiles nicely on my system.. On the uni server it throws a bunch of errors though
15:20:32 <danilo2> fizruk: The main idea behind each such tool was to process data in the most flexible available way. There are different tools and libraries available and we focused on delivering tools, which allowed people to work in a visual way. By visual way - I mean using a visual dataflow language.
15:20:46 <fizruk> Flonk, or Control.Monad rather...
15:21:19 <Flonk> fizruk: Hm, yes, I imported that
15:21:48 <fizruk> Flonk, and the error remains?
15:22:05 <Flonk> Yeah..
15:22:19 <danilo2> fizruk: We've quit the job and we started working on our custom visual language, which aims to solve a lot of problems we have seen in existing solutions. We have designed a double representation language - a language, which you can use in a visual and textual way in parrarel - I maena - you can write code or build the logic by connecting
15:22:45 <fizruk> Flonk, outdated packages?
15:23:05 <fizruk> Flonk, what's the version of base?
15:23:21 <Flonk> fizruk: I guess.. The uni server uses a pretty old version of hugs
15:23:23 <Flonk> fizruk: How do I check?
15:23:45 <fizruk> Flonk: ghc-pkg list base
15:23:51 <danilo2> fizruk: dataflow "building blocks" and see interactively how data changes and is processed across your application. You can switch between these representations in any time. Ok this is shortly, what we are doing. And now, to make the visual language user friendly, clean and concise, we would love to model such feature in Haskell.
15:24:21 <Twey> danilo2: Of course it's possible.  You need type annotations, though.
15:24:29 <Flonk> fizruk: base-3.0.3.2; base-4.2.0.0
15:24:32 <danilo2> fizruk: We are compiling this language to Haskell and the beta compiler (for visual and textual language currently works). We plan to release the language as an open source project in the near future
15:24:49 <fizruk> Flonk, oh you should remove/hide base-3.0.3.2
15:25:00 <Iceland_jack> You haven't shown a motivating example yet
15:25:20 <fizruk> Flonk, also, I belive first one is in the global scope and second — in users'
15:26:16 <Flonk> fizruk: http://lpaste.net/94616
15:26:27 <danilo2> fizruk, Twey: I would love to allow users to not type to much. It would be ideally i users could, but not have to type anything (if they are making basic thinks, like calling an "objects/record" method. For example - we have written some TH snippets, which automaticly generate instances of specific classes, so right now, hte beta textual language works
15:26:31 <ski> Flonk : import `Control.Monad.Reader' or `Control.Monad.Instances', iirc
15:26:32 <Flonk> fizruk: I doubt that I have permissions to.. how would I do that?
15:27:02 <danilo2> fizruk, Twey: and it does not need to type anything in simple programs. The only problem appeared when you're maing functions with such "type complexity" as I was trying to solve now
15:27:23 <Iceland_jack> danilo2: Because you're attempting to implement OO in Haskell…
15:27:33 <fizruk> Flonk, iirc ghc-pkg unregister base-3.0.3.2
15:27:43 <fizruk> Flonk, I might be wrong
15:28:00 <danilo2> Iceland_jack; no OO, there are no mutable objects. There are no states. Only methods "bundled" with records
15:28:01 <fizruk> Flonk, recheck in docs first :)
15:28:42 <Flonk> ski: I'll try that. So older versions of base had these definitions not in Control.Monad but Control.Monad.Instances?
15:28:43 <Iceland_jack> danilo2: But why not just learn Haskell
15:29:35 <fizruk> danilo2, Iceland_jack has the point. Also dataflow programming is poorly connected to OOP afaik.
15:30:34 <Flonk> fizruk: eh well, I suppose I'd rather not mess around with packages on a server that hundreds of people use every day
15:31:30 <fizruk> Flonk, are you building with cabal?
15:31:37 <danilo2> Iceland_jack: It is not easly to answer in one sentence. I love Haskell and I would be happy if it could rule the world. but you know that Haskell is not an easy language for an "average programmer", which used to live in imperative world. We are creating language, which allow even non programmers (or not very "technical guys) to understand, what is going on
15:31:44 <danilo2> fizruk: ^^
15:32:00 <startling> cabal init doesn't play nicely with cabal sandbox? Dang.
15:32:04 <Iceland_jack> Do you think your code makes Haskell simpler danilo2?
15:32:38 <Flonk> fizruk: just loading the file in hugs, not sure what that does. But importing Control.Monad.Instances seems to have fixed it!
15:32:52 <Iceland_jack> Also you still haven't given a motivating example, you've simply given vague context
15:33:01 <fizruk> Flonk, oh ok :)
15:33:25 <Iceland_jack> Is there any concrete example that is hard to understand in Haskell but would be nice to use in your ideal, finalized DSL
15:34:37 <danilo2> Iceland_jack: No, it not makes *Haskell* simplier. I mean it is a DSL language. It is meant to create data processing graphs. I love thje idea of "honest languages" (like one wise guy, whose name I cannot remember right now, was talking on a video about functional languages), but we do not deliver the ability to write for example monads etc, because
15:34:57 <Iceland_jack> Erik Meijer?
15:35:55 <danilo2> Iceland_jack: It is in this particular case - much simplier to model using "objects" with methods in such dataflow graph. Of course all this stuff depends on some desing decisions, but we belive, that this visual language will be very easy to understand and use by even not "good programmers", like you.
15:36:47 <fizruk> danilo2, so do you have motivating examples for your design decisions?
15:36:55 <danilo2> Iceland_jack, fizruk: but you';ve told that there exist a chance to make it? am I right?
15:36:56 <Iceland_jack> So your base assumption is that using objects is simpler than what you'd use in Haskell
15:37:33 <danilo2> fizruk: Ok, but what is "the plan"? What are the possibilities?
15:37:55 <Iceland_jack> I'd simply tell you to do something else, but I think you won't listen
15:38:22 <fizruk> danilo2, the possibilities I know of are to use Data.Dynamic or my solution
15:38:30 <danilo2> Iceland_jack: I love to listen :) And I'm always trying to get most of it, really :)
15:39:16 <fizruk> danilo2, I double Iceland_jack
15:39:20 <danilo2> fizruk: but as far as I know, Data.Dynamic will not be as strongly optimized during compilation as your solution ?
15:39:24 <acowley> startling: What?
15:39:38 <fizruk> danilo2, sure
15:39:51 <danilo2> Iceland_jack: could you please tell a little more, what is on your mind? :)
15:40:01 <startling> acowley, I've got a bunch of sandboxed dependencies that cabal init didn't add to build-depends even though my sources import modules from them.
15:40:16 <acowley> oh, I always init earlier in the process so I didn't notice
15:40:29 <danilo2> fizruk: ok, and I undertand, modeling these mysterious "dependent products" is impossible in haskell?
15:40:38 <acowley> startling: it's worth opening an issue on that
15:40:48 * Iceland_jack regrets fueling this fire
15:41:07 <fizruk> danilo2, not sure, but I failed to make it
15:41:46 <danilo2> fizruk: Ok, and could you just tell me how you wanted to make it? maybe it will give me some hints and maybe somehow it is doable?
15:42:16 * geekosaur cannot help but think that this is going in entirely the wrong direction
15:43:07 <fizruk> danilo2, class Interface c where type Ret c a b; method :: forall a b. ... -> Ret c a b
15:43:54 <danilo2> btw fizruk, Iceland_jack: you've told "I'd simply tell you to do something else", could you tell a little more why? I'll not argue with your opinions, but I would love to hear them
15:46:00 <fizruk> danilo2, 1) dataflow /= OO 2) the feature you're trying to make suggests that you're trying to mimic some OO language(s) without thinking why you need it in your DSL
15:49:17 <danilo2> fizruk: Thank you :) Just to clarify: 1) you're right. My description was wrong - I was talking about records with bundled methods. 2) I need it, because we belive this desing would be simpler and clearer for end user of the visual language :)
15:49:37 <danilo2> fizruk: and thank you for the **huge** help I get from you. I do not know if I can repay somehow it. Thnak you very, very much! :))
15:49:38 <Iceland_jack> You claim to listen danilo2
15:49:44 <Peaker> danilo2: this design is internal, isn't it? i.e: not visible to the end-user?
15:49:49 <danilo2> Iceland_jack: thank you too :)
15:49:55 <Iceland_jack> …
15:50:21 <danilo2> Iceland_jack: I'm listening, really - I'm considering right now, what you've told. I just wanted to "update" and clarify, what I've told you
15:50:42 <Iceland_jack> Well I believe everyone here who commented said it was not a good way to go
15:50:54 <Iceland_jack> and yet you say you “need it”
15:51:11 <fizruk> danilo2, for 2) we still don't have a motivating example... have no clue what is your belief based on
15:52:42 <danilo2> Iceland_jack: I told "I need it", because I didn't changed my mind in a second :) Really, I'm listening to you and thinking about it :)
15:53:47 <Iceland_jack> What you're looking for is not Haskell
15:53:58 <Iceland_jack> try F# or Scala
15:54:01 <danilo2> Peaker: It IS visible to the user. If you imagine a dataflow graph, each "block" outputs a data of a specific type. Then you can place a "function", which behaves different, based on the type connected to it.
15:54:46 <jfischoff> that sounds like type classes, no?
15:54:51 <fizruk> danilo2, think of the actual use cases for your DSL and make design desicions based on motivating examples.
15:55:38 <vervic> Hi! What is the opposite function of filter? I search a function that returns the list of those elements that *not* satisfy the predicate.
15:55:57 <Iceland_jack> vervic: \x -> filter (not x) :)
15:55:58 <Cale> vervic: you can just write filter (not . p)
15:56:12 <Iceland_jack> right, (not . x)
15:56:21 <vervic> ty
15:56:59 <Cale> > filter (not . isAlpha) "here 84378 is 0123 some ! test string"
15:57:00 <lambdabot>   " 84378  0123  !  "
15:58:20 <Peaker> danilo2: how is that OO in any way?
15:58:22 <danilo2> fizruk, Iceland_jack: I really appreciate your help, every note and suggestion. Than you once again :) I'll verify the design decisions once again. If I'll write a motivation example, that would be short enough to be shown here, I'll send it tou you :)
15:59:22 <stephenmac7> jfischoff: How do I do that?
15:59:47 <jfischoff> I can't remember what I said to do ;p
15:59:52 <stephenmac7> reverse deps
15:59:53 <danilo2> Peaker: I've told before, that "OO" was very bad words for describing what I want do do. By this term I meant "non-mutable classes with methods" - another words "records, with bound methods to them", so each type can have for example method "test" and we can call it in a pseudocode like "x.test(), y.test()"
16:00:23 <jfischoff> google for hackage reverse deps
16:00:25 <stephenmac7> danilo2: You mean you want record syntax with functions?
16:01:00 <fizruk> danilo2, I think, you're mixing dataflow programming with immutable record-based programming
16:01:06 <xico> danilo2: as an unrelated but similar kind of things to what you are doing, i let my dsl be haskell, where i compile the functions on the fly through ghc, and then call them differently from the engine using ghc api. this allows the functions to have various types without the user having to enter typing info
16:01:28 <xico> danilo2: it also allows to have the full haskell power for users who need it
16:01:46 <jfischoff> danilo2: are you saying you want a record of functions associated with a class (type)?
16:02:04 <stephenmac7> jfischoff: Interesting... haggis
16:02:08 <stephenmac7> http://hackage.haskell.org/package/haggis
16:02:37 <danilo2> stephenmac7: Instead of wriitng agian what I was trying to do and what was the question, I send you link with it (it tells roughly what Im trying to achive): http://stackoverflow.com/questions/19484232/oop-using-haskell-type-system/19504086?noredirect=1#19504086
16:02:51 <fizruk> danilo2, perhaps, you may be interested Arrows for dataflow programming (rather than objects/records)
16:03:33 <stephenmac7> danilo2: Sorry, I wasn't offering help, just trying to rephrase what you want for people who were :)
16:03:38 <stephenmac7> I'm new to haskell.
16:04:42 <danilo2> jfischoff: I think the actuall problem is best described here: http://stackoverflow.com/questions/19484232/oop-using-haskell-type-system
16:04:56 <jfischoff> too long
16:05:03 <Guest68899> @type (!!?)
16:05:04 <lambdabot>     Not in scope: `!!?'
16:05:04 <lambdabot>     Perhaps you meant one of these:
16:05:04 <lambdabot>       `!!' (imported from Data.List), `^!?' (imported from Control.Lens)
16:05:28 <danilo2> xico: can you say more about it? I was thinking about very simmilar desing and also using GHC API in the near future. Can I learn more about your solution?
16:05:30 <fizruk> @type (^!?)
16:05:31 <lambdabot> Monad m => s -> Acting m (Leftmost a) s a -> m (Maybe a)
16:06:06 <fizruk> Acting is like Getting in Monad?
16:06:23 <glguy> yes
16:07:14 <dorei> hello
16:07:24 <dorei> may i ask something totally noob? :)
16:07:36 <fizruk> ^ is for get, ! — action, ? — prism/maybe ?
16:07:47 <xico> danilo2: well, i am unsure it is entirely related, but my users are allowed to defined global callbacks, or callbacks in structures. i just compile the code, and extract the typing info with the ghc api.
16:07:49 <glguy> yeah get,action,maybe
16:07:50 <jfischoff> dorei: yes and you don't have to ask to ask ;)
16:08:00 <glguy> dorei: You just did :-p
16:08:04 <xico> danilo2: this allow for instance to check if a function need IO or not, and call it with the right monad if necessary.
16:08:10 <dorei> okie, is there a way to read documentatiion from within ghci?
16:08:13 <fizruk> glguy, thanks)
16:08:19 <danilo2> jfischoff: Ok, the actual problem was (is) I'm translating a custom DSL language to Haskell and I want tocreate in Haskell such behaviour, that objects have bundled methods. Writing In pseudocode: I wanted to create equivalent of such code "x.f(), y.f()", where x and y were instances of some "datatype" in my language.
16:08:32 <glguy> dorei: No.
16:08:36 <jfischoff> dorei: that's a good question … I don't think so.
16:08:53 <Iceland_jack> dorei: !curl … :)
16:09:10 <geekosaur> dorei, are you looking for something like python
16:09:14 <geekosaur> s docstrings?
16:09:15 <jfischoff> danilo2: if you want to have functions associated with a type, that is a type class
16:09:36 <jfischoff> so I would use that feature
16:09:49 <dorei> geekosaur: no idea about python, probably something like unix manpages or whatever, no idea about haskell's way of documenting stuff
16:09:52 <geekosaur> Haskell is primarily a compiled language; ghci is not really intended to be like the pythin prompt
16:09:55 <danilo2> jfischoff: I now, but there are some problems with RankNTypes (everything is described on SO and really I tried hard to make it short there :) )
16:10:02 <jfischoff> or you can something manually by making your "dictionary" or record of the typeclass functions
16:10:22 <danilo2> xico: brb
16:10:25 <geekosaur> there used to be a way to hook hoogle (haskell function search) into ghci but I don't know if it currently builds?
16:10:45 <glguy> dorei: For the Haskell packages available on Hackage you can find their documentation online: http://hackage.haskell.org/package/base for example
16:10:53 <geekosaur> (actually I thought I heard recently that someone was maintaining it again)
16:10:58 <glguy> dorei: When you install packages locally you can opt to install the same kind of documentation
16:11:07 <dorei> oh, i see, so hoogle is the main documentation point for haskell?
16:12:08 <glguy> dorei: I have my "cabal" set to build documentation by default, so all the packages I have documentation reachable from "~/Library/Haskell/doc/index.html"
16:12:35 <glguy> but it's very common to just use hackage when possible
16:12:50 <startling> dorei: no, hackage is.
16:16:40 <the_last> Google is the main documentation point for everyone
16:16:57 <the_last> And everything
16:17:18 <stephenmac7> jfischoff: Thanks, found a good one: https://github.com/pjones/playlists/blob/master/playlist.hs
16:17:33 <jfischoff> \o/
16:20:04 <danilo2> xico: I'm cheching for IO in a simmilar way. Additional your workflow sounds very interesting. I undeerstand it is a closed source project, or can I learn / ask more about some desing you've got there?
16:22:18 <jfischoff> danilo2: why would something like class Method1 a b where method1 :: a -> b -> b -> String not work?
16:23:33 <NihilistDandy> I'm trying to write API bindings for a game I play online. Basically I need to query a particular URL with some parameters and then parse the XML that it spits back at me. Any library recommendations for this kind of thing?
16:28:40 <xico> danilo2: it will be opensourced at some point, but it is more of a recent (and unfinished) experiment in converting the engine and user language to haskell now. i can paste parts of the code though.
16:28:53 <JanAson> is there any simple way to express "f (g a) (g b) (g c) (g d) (g e) (g f) (g h) (g j)"?
16:29:31 <startling> jfischoff, do you get an error?
16:29:41 <startling> JanAson, not really.
16:30:07 <jfischoff> startling: ?
16:30:36 <malvarez> I'd argue that having a function that takes eight arguments of the same type is a code smell to begin with
16:30:44 <adimit> JanAson: you might want to think about expressing f as a fold, and then using `map g`. So you would have something like: foldl f . map g $ [a,b,c,d,e,…]
16:31:21 <startling> jfischoff, oh, I didn't realize that was addressed to danilo2; I thought it was an independent question for some reason.Sorry!
16:31:48 <adimit> JanAson: but that depends on what f is doing. It is weird for a function to take so many different arguments of the same type anyway. Never seen something like that.
16:32:05 <xico> JanAson: uncurryN from tuple
16:32:14 <startling> xico, how will that help?
16:32:14 <xico> (might help)
16:32:22 <startling> you can't map across a tuple anyway.
16:32:27 <JanAson> uncurryN. hmmm
16:32:46 <danilo2> xico: Ok, can I talk with you tommorow? I'll not take much of your time, but I would love to ask some more questions :)
16:32:57 <startling> > over each (+ 1) (1, 2, 3, 4, 5, 6) -- well, there's this, but ...
16:32:58 <lambdabot>   (2,3,4,5,6,7)
16:33:14 <startling> JanAson, what is f?
16:33:51 <xico> danilo2: sure, i here almost every day
16:34:05 <xico> startling: well you can use generics for that
16:34:06 <startling> JanAson: I ask because there's some tricks you could do if it's a constructor.
16:34:09 <JanAson> in my case, type constructor, but i'm curious there is a way even when it is not a type constructor.
16:34:26 <startling> JanAson, can you write a Functor instance?
16:34:26 <xico> startling, JanAson: like gmapT
16:34:37 <danilo2> xico: great! so I'll write tommorow :)
16:35:21 <JanAson> i think i can.
16:35:36 <danilo2> jfischoff: It is no porlbem to use typeclasses, but If I want to create a function, which calls a polymorphic function defined in a typeclass passing to it different arguments, then there is a problem. You can see the code on SO :)
16:35:39 <startling> JanAson, then it becomes fmap g . f.
16:36:10 <JanAson> hmmm that looks nice. thank you.
16:37:02 <jfischoff> danilo2: My point is you could avoid the problem you showed by just creating type classes for each function you need ad-hoc polymorphism for
16:37:07 <JanAson> > :t over
16:37:08 <lambdabot>   <hint>:1:1: parse error on input `:'
16:37:16 <startling> JanAson, it's a complicated lens thing.
16:37:44 <JanAson> oh
16:37:55 <startling> > over _1 (+ 1) (0, "_1 is a lens on the first element of this tuple")
16:37:56 <lambdabot>   (1,"_1 is a lens on the first element of this tuple")
16:39:15 <letrec> Can I implement a class convT like this: http://lpaste.net/94618
16:39:27 <startling> JanAson: It's not too complicated to use, but the type of "over" will tell you little-to-nothing about what it does if you don't know lens.
16:39:49 <NihilistDandy> :t over
16:39:50 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
16:39:51 <letrec> This doesn't compile but can't find how to fix this
16:39:58 <danilo2> jfischoff: I feel I should really go to sleep right now, I'm totally exhausted, but wait a second
16:40:13 <startling> letrec, "conv" is always a partial function? That looks bad.
16:40:44 <letrec> startling: Yes I know. I just want to understand the type system here
16:41:16 <startling> letrec, OK. the problem is that you have two different 'a's that don't necessarily correspond, I think.
16:41:53 <startling> letrec: conv's type says "for every type a, b, c, d we can make a t out of it."
16:42:18 <letrec> startling: Yes.. But t could be (,) or [], or ....
16:42:46 <letrec> I understand what the type system is telling me but I think that what I want to do is safe :)
16:42:57 <startling> letrec, the [a] instance would only be valid if the previous "a" and the parameter to "[]" always correspond, but that's not necessarily true.
16:42:59 <letrec> startling: So I should be able to do it
16:43:04 <danilo2> jfischoff: Here is a code I was discussion earlier: http://lpaste.net/94619. It does not ocmpile, because "f" needs to explicit RanNType'd. I'm generating Haskell code, so I want to automatically type it somehow. This would not be a problem. the real problem is, I can not mimic following pseudo code using this technique: http://lpaste.net/94603
16:43:44 <jfischoff> I am not proposing that solution
16:43:45 <startling> letrec, one way to do it would be to have "data T a = List [a] | Tup1 a | Tup2 a a | Tup3 a a a" and then "conv :: T a -> t a".
16:44:09 <danilo2> jfischoff: because the only solution for it right now is fizruk's one, posted on SO: http://stackoverflow.com/questions/19484232/oop-using-haskell-type-system, which uses existential datatypes to type the output of methods in f function. Do you see any other solution?
16:44:30 <letrec> startling: Ok, but I really would need Tup2 a b :)
16:45:01 <jfischoff> maybe. Like I said I don't see why a simple type class would not suffice
16:45:02 <letrec> I'm just surprised I can't do that I want (looks safe) and I wonder why.
16:45:24 <jfischoff> so maybe I don't understand your problem
16:47:11 <danilo2> jfischoff: Ok, so how would you write in haskell a code, which would be equivalent to this pseudocode : http://lpaste.net/94603 ? This pseudocode uses simple syntax: x.method1 is equivalent to calling "method1" based on type of "x".
16:48:02 <startling> letrec: you could do it two ways, I think. There's the new hot type families way and the old dependendable FunDeps way.
16:48:48 <danilo2> jfischoff: If your solution would allow to write such eqivalent code, I'll buy you a truck of beer :D
16:48:50 <lpaste> jfischoff annotated “OO pseudo code” with “OO pseudo code (annotation) (annotation)” at http://lpaste.net/94603#a94620
16:49:34 <letrec> startling: Ok, thanks. Will look into type families stuff.
16:49:45 <jfischoff> I think I wrote code to your example on stackoverflow or my memory of it
16:51:18 <startling> letrec, actually, no, I think I'm wrong.
16:51:33 <rofer> I want to use several functions which take in a random generator and return an updated random generator inside the IO monad. This is the place for monad transformers, right?
16:51:42 <danilo2> jfischoff: brb
16:52:09 <letrec> startling: Ok, so it's not possible you think?
16:52:28 <udevd> has anyone here used gnuplot package?
16:52:50 <startling> letrec, I think what you're trying to do is sort of insane; this makes it hard for me to tell you whether it's sanely possible.
16:52:51 <udevd> i'm searching for a working example (i'm not even dreaming of tutorial...)
16:53:06 <udevd> because the attached to package one doesn't work...
16:53:31 <startling> letrec: one way you could make it saner is with phantom types.
16:53:53 <jfischoff> udevd: paste the code and the error in lpaste
16:53:58 <startling> letrec: instead of [], use newtype AsList a b c d = AsList [a]
16:54:09 <startling> but again, partial functions.
16:54:25 <monochrom> letrec, startling: after I try it hands-on and reading the error message, I know why. "instance ConvT [a]" means "instance ConvT [e]" (because let's use a fresh name to avoid lying to ourselves). and "instance ConvT [e]" means conv :: T a b c d -> [e], not [a].
16:55:02 <startling> monochrom: sure, I said that already.
16:55:28 <udevd> http://lpaste.net/94621 and the error is quite simple: there's not Paths_gnuplot package.
16:55:39 <udevd> no*
16:55:41 <danilo2> jfischoff: Ok, I'm back
16:56:07 <letrec> startling: I'm insane so that makes sense :) Partial functions could be ok and act as a type checker for instance (say if I'm dynamically loading code).
16:56:21 <startling> letrec, uh, what?
16:56:22 <stephenmac7> Finally, it's kind of working
16:56:29 <udevd> commenting out this line doesn't really help
16:56:30 <danilo2> jfischoff: but your solution assumes, method1 returns String. But if "method1" can be implemented "by several datatypes",m thay can have different return types
16:56:36 <kenalex> hello
16:56:42 <startling> If I bump all of the dependencies of a package, do I need to bump the package version?
16:56:58 <kenalex> do any of you guys know of any good books on functional programming
16:57:00 <startling> (A major number, I mean.)
16:57:01 <jfischoff> danilo2: that was just to simplify the example
16:57:02 <monochrom> usually you should
16:57:13 <jfischoff> you can just add other type variable for the return type
16:57:39 <danilo2> jfischoff: Ok, so would you be so nice and tell me how would look the code for this example? It is very simmilar to that one: http://lpaste.net/94603#a94620
16:57:42 <monochrom> err, major number? then probably not.
16:57:43 <jfischoff> inference goes out the window
16:58:05 <startling> well, I bumped almost all of the dependencies by a major number.
16:58:34 <ski> kenalex : "Haskell: The Craft of Functional Programming" by Thompson ?
16:58:50 <monochrom> externally, you have a "maintenance release that just increases compatibility with more build environments"
16:59:04 <jfischoff> danilo2: why? do you not understand the solution I am proposing?
16:59:19 <geekosaur> hm. udevd, as far as I know you cannot get at, nor is it sensible to use, the Paths_ module from the gnuplot package directly. (Its own demos can. but they're built with the package so they have access.) You would be using cabal to build your program and Cabal would generate an appropriate Paths_ module for it
16:59:37 <kenalex> thanks ski. i'll check it out
17:00:21 <geekosaur> Paths_* is cabal-install magic of sorts
17:00:36 <danilo2> jfischoff: Of course I understand it, but I'm almost sure It will fail on that example. give me a second
17:00:51 <jfischoff> what do you mean by  "fail"
17:01:02 <monochrom> then again, let me put on my logician hat, as though human consensus is logical. there is no rule that says, "major version increase implies major API change"
17:01:48 <monochrom> as though both human consensus is logical and human language is free of unsaid subtext :)
17:02:51 <lonecub2131> What open source project a beginner like me can start contributing to? My goal is to learn from people who are experts in this field. I know, I still have a long way to go. In addition to XMonad, this is what I see on Github - https://github.com/search?l=Haskell&q=stars%3A%3E1&s=stars&type=Repositories
17:03:13 <ski> kenalex : there's also "Haskell School of Expression" and some other books
17:05:00 <monochrom> anyway, variable capture is evil
17:05:44 <danilo2> jfischoff: Ok so on the beginning., if you want to abstract the return type, you';ve got to use type families or fundeps, like this:
17:05:58 <jfischoff> you never have to use fundeps
17:06:14 <danilo2> jfischoff: http://lpaste.net/94622
17:06:18 <Twey> danilo2: What's the type of the arguments to method1 supposed to be in your example?
17:07:04 <Twey> monochrom: There is, actually: semver.org :þ
17:07:30 <udevd> okay, so i managed it to work... manuall
17:07:33 <udevd> manually*
17:08:21 <danilo2> Twey: you are talking about this example? http://lpaste.net/94603#a94620 If yes, then method1's signature is a->b->(a,b)
17:08:35 <danilo2> jfischoff: how would you do it without fundeps?
17:08:44 <jfischoff> not use them
17:09:10 <jfischoff> fundeps do not always makes sense
17:10:15 <danilo2> jfischoff: than you get compilation error: http://lpaste.net/94622
17:10:22 <danilo2> jfischoff: (annotation)
17:10:30 <jfischoff> then you add a type annotation
17:10:55 <razieliyo> hi
17:11:16 <razieliyo> how can I write a function multiline in haskell?
17:11:46 <monochrom> put it in a file. :load the file
17:12:05 <Iceland_jack> razieliyo probably means in ghci
17:12:10 <frxx> razieliyo do you have an example of a function that you want to write in multiple lines?
17:12:27 <razieliyo> well, it's a list comprehension, maybe I'm doing it wrong
17:12:29 <monochrom> I probably recommend a method that scales to professional use
17:12:31 <razieliyo> I'll paste it
17:12:40 <razieliyo> it works single-lined
17:13:14 <razieliyo> http://ideone.com/EurHmh this is it
17:13:55 <razieliyo> I'm just starting (the third or fourth time) with haskell
17:13:58 <Iceland_jack> razieliyo:
17:13:58 <Iceland_jack>     foo = [ x
17:13:58 <Iceland_jack>           | x <- [1..10]
17:13:58 <Iceland_jack>           ]
17:14:03 <Iceland_jack> if you want
17:14:06 <razieliyo> Iceland_jack: thanks!
17:14:20 <danilo2> jfischoff: Ok, but I want to generate this type annotation automatically - using template haskell or any other "magical" tools, because I do not want to force the end-user of my dsl to type such things explicit.
17:14:21 <razieliyo> yes, of course, I was just not getting it
17:14:34 <frxx> razieliyo why do you have let there?
17:14:40 <geekosaur> for starters, you should recognize that ideone.com expects a compilable program, it is not ghci.
17:15:11 <danilo2> jfischoff: But I think I really should go get some sleep now, because I'm not thinking clearly - I'll think about this soulution, you've written Iand I'll be back in touch with you tommorow, if I could :)
17:15:28 <jfischoff> danilo2: alright man, sleep well :)
17:15:43 <danilo2> jfischoff: thank you! bye :)
17:19:57 <stephenmac7> Iceland_jack: optparse seems to be fine
17:20:08 <stephenmac7> I think I've got it now
17:20:14 <stephenmac7> Still uses pattern matching though
17:20:39 <razieliyo> frxx: well, I was mixing stuff in a tutorial about the ghci with scripting I guess
17:22:09 <razieliyo> cant I group constraints?
17:22:34 <monochrom> yes, you can.
17:23:00 <razieliyo> foo = [ x
17:23:00 <razieliyo>  | x <- [1..10], x /= 5
17:23:01 <razieliyo>  | x +2 > 4
17:23:01 <razieliyo> ]
17:23:11 <frxx> missing comma
17:23:18 <monochrom> replace the 2nd | by a comma
17:23:24 <razieliyo> okay, it fails with comma too, I have to be missing something more
17:23:39 <startling> When did data declarations state working in ghci?
17:23:45 <Twey> Haha
17:23:51 <jfischoff> 7.6
17:23:54 <monochrom> > [ x | x <- [1..10], x /= 5, x+2>4 ]
17:23:54 <lambdabot>   [3,4,6,7,8,9,10]
17:23:59 <monochrom> works for me
17:24:03 <startling> jfischoff: dang.
17:24:06 <Twey> startling: I had this revelation too
17:24:57 <startling> Unfortunately the thing I'm working on needs to support 7.4.x, so I don't think adding data declarations to the doctests would be kosher.
17:25:01 <jfischoff> you need to watch shachaf use ghci. you learn many things :)
17:25:13 <monochrom> also 7.4, and probably earlier
17:25:19 <razieliyo> still yelling at me http://ideone.com/aQ9Hjg
17:25:30 <razieliyo> error on |
17:25:31 <jfischoff> monochrom: oh whoops
17:25:36 <razieliyo> I placed the , at the previous line
17:25:44 <geekosaur> why are you using all those |s?
17:25:46 <frxx> razieliyo remove all but the first |
17:25:48 <monochrom> I think maybe 7.2 also does it but I have erased it
17:25:49 <startling> monochrom: so it does work on 7.4?
17:25:53 <startling> great.
17:25:55 <monochrom> yes, I just tried
17:25:57 <stephenmac7> optparser applicative doesn't support multiple short arguments?
17:25:58 <geekosaur> take a look again at what you were shown above. how many |s  in it?
17:26:05 <jfischoff> startling: yeah my bad
17:26:10 <stephenmac7> Like -cr instead of -c -r
17:26:32 <razieliyo> frxx: perfect, thanks!
17:26:33 <monochrom> razieliyo, you need to keep just the first | and delete the rest
17:26:58 <razieliyo> monochrom: thanks too
17:27:04 <geekosaur> razieliyo, the | is not a continuation character. it has a specific meaning in list comprehension syntax
17:27:08 <monochrom> I don't understand from where you learn this syntax. are you translating english to haskell?
17:27:43 <startling> ghci puts them in when you use :{.
17:27:48 <razieliyo> I neither got how could that work, but as I saw the example, I thought it could be that way
17:28:16 <geekosaur> oh, secondary prompt. not part of the code
17:28:36 <monochrom> one more reason to not use ghci
17:30:44 <frxx> monochrom what are the other ones?
17:30:50 <jfischoff> great I just got the compiler to loop
17:31:43 <jfischoff> what are some your code when the compiler loops? I have all my optimizations turned off … so I am surprised.
17:32:02 <monochrom> I don't know how to get the compiler to loop
17:32:36 <jfischoff> how should I debug it?
17:32:59 <jfischoff> it appears to be in the ByteCodeGen phase
17:33:00 <monochrom> I somewhat know how to exhibit exponential-time algorithms in the compiler. but that still doesn't count as loop, pedantically
17:33:17 <jfischoff> perhaps that is what is happening
17:33:38 <monochrom> ah, but I only know exponential-time algorithms in type checking
17:33:44 <jfischoff> the memory is constant and the cpu usage is at 100 so I thought it was looping
17:35:02 <jfischoff> oh my god. it finished and I just got a type error, no idea why it takes so long now ...
17:35:37 <monochrom> like a kid says, "let me think really hard", then thinks really hard, then says "no" :)
17:36:01 <jfischoff> heh pretty much
17:36:13 <stephenmac7> How do I not escape escape characters?
17:36:30 <monochrom> in what context?
17:36:35 <geekosaur> don't use show? or what do you mean?
17:36:40 <monochrom> the solution depends on the problem
17:36:41 <stephenmac7> monochrom: Like this:
17:36:42 <stephenmac7> Prelude> a <- getLine
17:36:42 <stephenmac7> \n
17:36:42 <stephenmac7> Prelude> a
17:36:42 <stephenmac7> "\\n"
17:36:48 <geekosaur> dont paste into channe;
17:36:57 <stephenmac7> It's 4 lines
17:37:00 <monochrom> try "putStrLn a"
17:37:11 <stephenmac7> monochrom: It prints \n literally
17:37:12 <geekosaur> ghci does show by default. use putStrLn directly if you want to avoid the default behaviot
17:37:15 <monochrom> which is, afterall, what geekosaur says
17:37:38 <geekosaur> wait, you actualy entered the characters \ n there?
17:37:42 <stephenmac7> Yes
17:37:55 <monochrom> ok, you input \n literally, and there is a way to output it literally. I count that as success and ticket closed.
17:37:56 <geekosaur> and you were expecting them to be interpreted?
17:38:11 <stephenmac7> geekosaur: That's what I meant
17:38:21 <stephenmac7> I want to see a newline, not \n
17:38:45 <monochrom> then I have a cunning plan
17:38:59 <geekosaur> the easiest way to do it is probably wrap duble quotes around it and use read
17:39:31 <geekosaur> this is not a standard function in any programming language; source format is not what the runtime deals in.
17:39:33 <monochrom> yes, that's the cunning plane
17:39:51 <stephenmac7> All I'm trying to do is allow the user to specify the line ending
17:39:58 <stephenmac7> Through a commandline argument
17:40:39 <monochrom> a <- (\x -> read ("\34" ++ x ++ "\34")) `fmap` getLine
17:40:47 <geekosaur> so you need to do something like what I said, or punt it to bash (e.g. --eol $'\n'
17:41:24 <stephenmac7> monochrom: No need, seems geekosaur's solution worked
17:41:55 <stephenmac7> gekThanks
17:42:00 <stephenmac7> geekosaur:
17:42:07 <stephenmac7> the $'' thing worked
17:44:29 <stephenmac7> Finally, I've made my first command line software! http://lpaste.net/94625
17:45:05 <stephenmac7> Quite useless though :)
17:56:29 <pdxleif> Any simple standalone tools one might recommend for HTML templating?
17:57:42 <pdxleif> Hopefully something that doesn't require interpeting haskell source code / compiling - I just wanna insert some simple string values.
18:01:14 <johnw> how would yo provide those string values?
18:05:55 <pdxleif> Dunno, as function args?  I'm just writing a command-line app, and right now I've got HTML hard-coded into the source - https://github.com/LeifW/yaml2owl/blob/master/src/SchemaScaffold.hs#L58
18:06:24 <pdxleif> Was just thinking it might be nice to have the option of reading from an HTML file for easier customizeability for the end-user
18:09:03 <startling> pdxleif, you might like heist.
18:09:30 <startling> blaze-html requires interpretation, but it's so nice.
18:10:56 <pdxleif> We use Snap at my work, and we had a Snap commiter until recently.
18:11:23 <johnw> it ought to be pretty trivial to whip up such a utility around blaze-html
18:11:38 <startling> ^ that's true.
18:11:53 <pdxleif> I'll take a look.  I heard heist (pre-optimization) worked much like the templating language I'm working on (recursive element traversal to build up page)
18:13:15 <pdxleif> Golly, heist looks a LOT like what I've been working on.
18:14:55 <pdxleif> Maybe I could just write up my own heist / sprintf - like thing real quick
18:15:44 <startling> Do you care about html injection?
18:15:51 <pdxleif> nope
18:16:13 <pdxleif> just a command-line tool to generate scaffold templates
18:16:17 <startling> Then I guess that works fine.
18:16:35 <stephenmac7> I still don't understand >>
18:16:43 <stephenmac7> :t (>>)
18:16:43 <lambdabot> Monad m => m a -> m b -> m b
18:16:50 <stephenmac7> Seems to just discard the first argument
18:16:58 <geekosaur> and that is what it does
18:17:12 <pdxleif> discards the a, merges the first m into the second m, though
18:17:17 <stephenmac7> geekosaur: Then why does it change the return state in the State monad?
18:17:31 <Iceland_jack> stephenmac7: The state is not the return value
18:17:32 <geekosaur> because that's the state and not the result
18:17:37 <geekosaur> the result is ()
18:17:40 <Iceland_jack> @ty modify
18:17:41 <lambdabot> MonadState s m => (s -> s) -> m ()
18:17:42 <stephenmac7> I meant the result
18:17:44 <geekosaur> which you don't care about, so >> discards it
18:18:05 <geekosaur> it doesn;t discard the *state*, it discards the () from the m ()
18:18:06 <Iceland_jack> > runState (modify (+1) >> modify (+1)) 5
18:18:07 <lambdabot>   ((),7)
18:18:27 <Iceland_jack> > runState (modify (+1) >>= \() -> modify (+1)) 5
18:18:28 <lambdabot>   ((),7)
18:18:32 <startling> stephenmac7, expand that m to "State whatever"
18:18:50 <pdxleif> (foo, 5) >> (bar, 10) == (foobar, 10)
18:18:52 <Iceland_jack> You can see that the ‘result’ discarded from ‘modify (+1)’ was simply ()
18:18:52 <pdxleif> or whatever
18:18:59 <startling> stephenmac7, (>>) :: State Whatever a -> State Whatever b -> State Whatever b
18:19:13 <stephenmac7> startling: So, it changes the Whatever?
18:19:21 <Iceland_jack> stephenmac7: Possibly
18:19:24 <startling> stephenmac7, it can, yeah.
18:19:28 <stephenmac7> Not the type but the value
18:19:36 <startling> stephenmac7: if you don't want this, maybe you want Reader.
18:20:15 <stephenmac7> No, I just wanted to know what >> is and does
18:20:32 <stephenmac7> So, it just discards the monadic part of the monad (the state in State)
18:20:38 <geekosaur> let's put it this way: for State, the saved state is part of the m, not part of the a. the a is discarded; the m is combined with the other m-s
18:20:46 <stephenmac7> :t state
18:20:47 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
18:20:50 <geekosaur> the a is almost always () in this case, so you want to discard it
18:21:02 <geekosaur> as with the type of modify, as shown earlier
18:21:05 <geekosaur> :t modify
18:21:06 <lambdabot> MonadState s m => (s -> s) -> m ()
18:21:23 <stephenmac7> I see.
18:21:24 <geekosaur> so we throw out the (), but the m (the state) is carried through
18:21:45 <pdxleif> f >> g is just like f >>= (\_ -> g)
18:21:54 <stephenmac7> pdxleif: I got that part
18:22:04 <geekosaur> likewise with the IO monad, putStrLn returns IO (), we don't care about the () so we use >> to combine it with the next IO action
18:22:17 <stephenmac7> the type class includes the line:
18:22:17 <stephenmac7> x >> y = x >>= \_ -> y
18:22:22 <Iceland_jack> stephenmac7: So this makes sense?
18:22:22 <Iceland_jack> > runState (return "I get THROWN AWAY!" >> return 8) "I'm the state"
18:22:23 <lambdabot>   (8,"I'm the state")
18:22:29 <geekosaur> yep. the _ there is the a, not the m
18:22:56 <geekosaur> the whole point of monadic bind is that the thing on the right receives the a *without* the m around it
18:23:16 <pdxleif> > [] >> [2,3]
18:23:17 <lambdabot>   []
18:23:19 <pdxleif> > [1] >> [2,3]
18:23:20 <lambdabot>   [2,3]
18:23:23 <stephenmac7> Iceland_jack: No, I don't get how it applies to IO
18:23:23 <pdxleif> > [1,1] >> [2,3]
18:23:24 <lambdabot>   [2,3,2,3]
18:23:38 <geekosaur> :t putStrLn
18:23:39 <lambdabot> String -> IO ()
18:23:39 <pdxleif> The values from the first computations aren't used, but the "list context" is
18:23:44 <Iceland_jack> stephenmac7: I was just showing how it applies to the state monad
18:23:54 <Iceland_jack> but the same priciple applies in the IO monad
18:24:06 <geekosaur> Haskell functions must return values. so we use () when we don't care about the value, only the side effect in the monad
18:24:15 <geekosaur> and then >> lets us pretend the () doesn't exist
18:24:21 <stephenmac7> What's return for the State instance?
18:24:54 <johnw> > 2 <$ [1,2,3]
18:24:55 <lambdabot>   [2,2,2]
18:24:58 <Iceland_jack> stephenmac7: return x = State (\state -> (state, x))
18:25:03 <stephenmac7> Thanks
18:25:04 <Iceland_jack> no sorry, other way around
18:25:16 <Iceland_jack>     return x = State (\state -> (x, state))
18:25:17 <stephenmac7> return x = State $ \s -> (x,s)
18:25:39 <geekosaur> which means we copy the state over and replace the value with x
18:25:47 <stephenmac7> geekosaur: Oh, I see how it works with IO
18:25:53 <Iceland_jack> stephenmac7: This is how it is in IO monad:
18:25:53 <Iceland_jack> @ty return "I get THROWN AWAY!" >> return True
18:25:54 <lambdabot> Monad m => m Bool
18:26:01 <Iceland_jack> @ty return "I get THROWN AWAY!" >> return True :: IO Bool
18:26:02 <lambdabot> IO Bool
18:26:19 <lostcause> hi
18:26:39 <stephenmac7> So, the side effect is like the state of the State monad
18:26:48 <stephenmac7> *side effect of the IO monad
18:26:57 <geekosaur> sort of, yes
18:27:10 <tac> > fix (return "a" >>)
18:27:11 <lambdabot>   No instance for (GHC.Show.Show (m0 b0))
18:27:11 <lambdabot>    arising from a use of `M13602075...
18:27:14 <tac> @type fix (return "a" >>)
18:27:15 <lambdabot> Monad m => m b
18:30:27 <stephenmac7> So, the list monad with >>
18:30:33 <stephenmac7> > [1,5] >> [2,3]
18:30:34 <lambdabot>   [2,3,2,3]
18:31:38 <stephenmac7> Repeats the second list the length of the first list
18:31:48 <stephenmac7> > [1] >> [1,1,1]
18:31:49 <lambdabot>   [1,1,1]
18:31:56 <stephenmac7> > [1,1,1] >> [1]
18:31:57 <lambdabot>   [1,1,1]
18:32:02 <Iceland_jack> > [()] >> [1..5]
18:32:03 <lambdabot>   [1,2,3,4,5]
18:32:29 <Iceland_jack> Just to make it clear that they needn't have the same type
18:32:40 <stephenmac7> [Nothing] >> [1..5]
18:32:43 <stephenmac7> > [Nothing] >> [1..5]
18:32:45 <lambdabot>   [1,2,3,4,5]
18:32:59 <stephenmac7> > [Nothing] >> [Just 5]
18:33:01 <lambdabot>   [Just 5]
18:33:08 <stephenmac7> > Nothing >> Just 5
18:33:09 <lambdabot>   Nothing
18:33:12 <OODavo_> So I'm toying with the idea of a concise notation for http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types , and I'm wondering whether this would be theoretically sound: (Num a => a) is the type of a value that may be anything in Num, and hence universally quantified. (Num a ~> a), under my proposal, would denote the type of a value that is *some particular* type in Num, so it's existentially quantified.…
18:33:15 <stephenmac7> Ah, I see
18:33:18 <OODavo_> …[Num a ~> a] would denote a list of numbers, each of which has a type in Num but not necessarily the same type. Behind the scenes, it'd be implemented by having ~> do the existential boxing described on that wiki page.
18:34:00 <stephenmac7> Iceland_jack: Thanks
18:34:12 <Iceland_jack> no prob
18:43:37 * hackagebot hsnock 0.1.4 - Nock 5K interpreter.  http://hackage.haskell.org/package/hsnock-0.1.4 (mrdomino)
18:53:14 <monochrom> https://plus.google.com/101555949501667191720/posts/Armn9rcrK8g
18:53:47 <roconnor> oh man, all this time my haddock wasn't building because of a unicode character.
19:00:22 <sm> man, the pandoc mail list is busy
19:13:56 <sm> stepcut: http://happstack.com/docs/crashcourse/ is some good docs - thanks
19:14:11 <fread2281> is there any function to do IO [IO a] -> IO [a]
19:14:48 <latro`a> :t sequence
19:14:48 <lambdabot> Monad m => [m a] -> m [a]
19:14:58 <latro`a> that probably does what you watn
19:15:05 <latro`a> *want
19:15:15 <fread2281> won't I then have IO IO [a] ?
19:15:28 <dwcook> You'd also want join in that case, I think
19:15:33 <startling> fread2281, the way to avoid that isto avoid getting one in the first place.
19:15:51 <latro`a> oh, I didn't see the first IO
19:15:55 <latro`a> why do you have an IO [IO a]?
19:16:38 <latro`a> the best conversion of that to IO [a] will depend rather fundamentally on what the IO [IO a] does; there's no nice way to figure out how you must do it with just types
19:17:07 <fread2281> map readTextFile $ listDirectory dir
19:17:22 <latro`a> that's not that
19:17:49 <dwcook> :t join . fmap sequence
19:17:50 <lambdabot> (Monad m, Functor m) => m [m a] -> m [a]
19:18:00 <dwcook> :t join . liftM sequence
19:18:01 <lambdabot> Monad m => m [m a] -> m [a]
19:18:08 <latro`a> ^is probably what you mean, but it's less obviously correct
19:18:27 <latro`a> but really, that shouldn't be IO ([IO a])
19:18:31 <latro`a> that should be [IO a]
19:18:35 <dwcook> Though it's notable that (>>=) is implemented in terms of join and liftM in the first place
19:18:46 <dwcook> I mean
19:18:49 <dwcook> implementable
19:18:56 <latro`a> which is a common thing to get, and is reduced by sequence
19:19:06 <latro`a> but yes, join . liftM sequence is (=<<) sequence
19:19:51 <startling> is there a cabal configure flag to avoid building executables, so I can avoid having the executable-only dependencies?
19:22:30 <geekosaur> startling, not as such but I think you can conditionalize the executables on a flag?
19:22:38 <geekosaur> and then use ---flags
19:23:28 <Negatratoron> Is there an identity type function in Haskell?  I'm looking for something like IdType :: * -> * such that IdType a = a
19:24:12 <acowley> Negatratoron: http://hackage.haskell.org/package/transformers-0.3.0.0/docs/Data-Functor-Identity.html
19:25:06 <geekosaur> I don't think that;s the same thing
19:25:12 <latro`a> you can't literally define an IdType, afaik
19:25:15 <geekosaur> anyway, no, there's nothing like type-level id
19:25:29 <dwcook> You mean like type Id a = a?
19:25:39 <geekosaur> unless there's something in all the recent type level hackery
19:25:40 <Iceland_jack> What about (\x -> x)… we can use type-level lambda abstractions right?
19:25:48 <geekosaur> no
19:25:51 <Iceland_jack> (joke)
19:26:37 <dwcook> Negatratoron, ^
19:26:47 <Negatratoron> acowley: I'm trying it
19:26:49 <dwcook> Type functions are written using `type`
19:27:00 <startling> type Id a = a is the way to do it, but you can't partially apply it.
19:27:11 <Negatratoron> yeah, I need to partially apply it
19:27:14 <dwcook> Isn't that more a weakness of the type/kind system?
19:27:53 <geekosaur> ghc doesn't support type level lambdas, and I gather it's unlikely to ever do so
19:28:01 <geekosaur> (this includes partial application)
19:28:05 <dwcook> geekosaur, why not ever?
19:28:41 <geekosaur> I think it complicates type inference too much? (makes it impossible in the presence of a type lambda, even?)
19:28:56 <startling> it's not impossible, just not possible in general.
19:29:07 <dwcook> This is halting problem territory, isn't it?
19:29:20 <startling> dwcook: yeah, but it's more than that.
19:29:38 <Negatratoron> Data.Functor.Identity doesn't seem to help, it looks like Identity a /~ a
19:29:39 <startling> Even with a strongly-normalizing type-level LC you lose inference.
19:30:02 <startling> Negatratoron: correct.
19:30:53 <acowley> ah, I did not read the question very closely
19:30:57 <Negatratoron> Here's what I'm trying to do: https://gist.github.com/jeffersoncarpenter/7094254
19:31:00 <Negatratoron> it's pretty weird
19:31:13 * dwcook had been reading your nick as Negatron
19:31:22 * acowley will continue to do so
19:31:26 <lpsmith> dcoutts, I've got a bit of an issue maybe you could help me with.    I've been talking to Simon about a blaze-builder implementation in terms of the new bytestring builder,  and he suggested including the new builder in the module for older ghcs.
19:32:05 <Negatratoron> trying to build something where you can pass more of whatever you want to functions
19:32:36 <startling> Negatratoron, looks like Data.Proxy.Proxy from "tagged".
19:32:54 <lpsmith> I'd like to use a git submodule so that we don't have to manage two repositories,  but the problem is when I set that up,  and add the subrepo's directory as an hs-source-dir,   then cabal is trying to compile the bytestring modules as well
19:33:10 <lpsmith> So I need a way to hide some of the modules from cabal
19:33:11 <startling> Negatratoron, you can write an ijoin for Identity (or IdType), it's just not "id".
19:33:52 <Negatratoron> oh
19:33:52 <Negatratoron> I actually haven't learned newtypes yet, I'm just learning Haskell all peacemeal
19:34:02 <lpsmith> dcoutts, would you accept a patch to move the bytestring source files into two subdirectories,  one containing the new builder source files and another for everything else?
19:34:28 <startling> Negatratoron: N.B. it'd probably be more idiomatic for Functor to be a superclass of Invisible than to have a separate "imap", unless I'm missing something.
19:35:02 <dwcook> runIdentity . Identity = id
19:35:07 <startling> :t Identity . fmap runIdentity
19:35:08 <lambdabot> Functor f => f (Identity b) -> Identity (f b)
19:35:13 <startling> Negatratoron: ^
19:35:19 <lpsmith> or,  at least a single subdirectory for the new builder source files?
19:35:35 <lol_> this here is Negatratoron, I disconnected
19:36:02 <startling> :t fmap Identity . runIdentity
19:36:03 <lambdabot> Functor f => Identity (f a) -> f (Identity a)
19:36:16 <startling> lol_: ^ there you go
19:36:55 <startling> :t liftM Identity . runIdentity -- if you want the Monad constraint instead.
19:36:56 <lambdabot> Monad m => Identity (m a1) -> m (Identity a1)
19:37:19 <startling> lol_: did you get what I said re: Functor?
19:37:53 <lol_> I need to try it
19:40:17 <fread2281> what am I doing wrong? https://gist.github.com/fread2281/711e0ef7164641b81933
19:41:20 <Iceland_jack> fread2281: What is the type of map?
19:41:27 <ION> @type ?x >>= map ?f
19:41:28 <lambdabot> (?x::[[a]], ?f::a -> b) => [b]
19:41:35 <ION> @type mapM ?f ?x
19:41:35 <lambdabot> (Monad m, ?f::a -> m b, ?x::[a]) => m [b]
19:41:37 <fread2281> oh... s/map/fmap/
19:41:50 <fread2281> I'm using ClassyPrelude
19:42:08 <ION> @type ?x >>= fmap ?f
19:42:08 <lambdabot> (Monad m, Functor m, ?x::m (m a), ?f::a -> b) => m b
19:42:51 <Iceland_jack> fread2281: Maybe you should stick to the normal Prelude until you've gained a firmer grasp of it?
19:43:59 <jle`> hm. is Identity useful as a way to force evaluation ordering?
19:44:11 <jle`> without any extra effects?
19:44:11 <startling> jle`, no.
19:44:16 <startling> it doesn't.
19:44:19 <ION> Identity is just a newtype wrapper.
19:44:21 <dwcook> I think Identity is mostly useful in similar ways id is
19:44:32 <jle`> yeah, i know about its main uses
19:44:32 <startling> > return undefined >> return 2 :: Identity Int
19:44:33 <Iceland_jack> The type signature from ION should provide a hint, you should attach the error message when submitting problems
19:44:36 <lambdabot>   Identity {runIdentity = 2}
19:45:00 <jle`> but i know that things like REPA require everything in a monad to be able to infer some kidn of ordering
19:45:06 <jle`> and sometimes people just use identity
19:45:19 <startling> jle`, it's not a Monad thing, it's certain kinds of monads.
19:45:21 <startling> namely State.
19:45:40 <startling> Lots of monads don't evaluate anything.
19:45:53 <startling> Well, in any particular order.
19:46:10 <jle`> but how come it can be used by REPA for evaluation?
19:46:20 <startling> no idea.
19:46:37 <jle`> maybe it just provides a context for the computation
19:46:46 <jle`> they use it for parallel evaluation
19:46:50 <Iceland_jack> A similar thing is done by the Eval monad
19:46:50 <Iceland_jack> yes
19:47:25 <startling> > Identity undefined >> Identity 2 -- jle`: Identity forces no evaluation order.
19:47:28 <lambdabot>   Identity {runIdentity = 2}
19:47:57 <startling> > runState (return undefined >> return 2) "jle`"
19:47:58 <lambdabot>   (2,"jle`")
19:48:15 <aXqd> hi, all. what's this...user error (Pattern match failure in do expression at libraries/base/GHC/Event/Thread.hs:84:3-10)
19:48:27 <jle`> hm. maybe it just provides REPA with a closed content/boxed for computation to prevent weird locking issues
19:49:00 <jle`> from the marlow text: "The type is almost the same as computeS, except that computeP takes place in a monad. It works with any monad, and it doesn’t matter which monad is used because the purpose of the monad is only to ensure that computeP operations are performed in sequence and not nested."
19:49:10 <Iceland_jack> jle`: http://stackoverflow.com/questions/11831156/how-does-the-bind-operator-for-eval-in-control-parallel-strategies-evaluate-its
19:49:16 <startling> > runState (state undefined >> return 2)
19:49:17 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable s0)
19:49:17 <lambdabot>    arising from a use ...
19:49:22 <startling> > runState (state undefined >> return 2) ":/"
19:49:23 <lambdabot>   (2,"*Exception: Prelude.undefined
19:49:25 <Iceland_jack> You might be interested in that
19:51:17 <jle`> Iceland_jack: thanks
19:55:11 <Negatratoron> this spotty internet connection is irritating
19:55:41 <Negatratoron> startling: I didn't really get what you said actually
19:56:28 <Negatratoron> I need Identity a ~ a or some kind of implicit conversion from a to Identity a
19:58:26 <dwcook> Negatratoron, I don't think what you want is directly possible. I mentioned how type Id a = a is how you'd write such a type function, but that didn't seem to suit your needs.
19:58:57 <startling> Negatratoron, you really don't.
19:59:02 <startling> Negatratoron, you can write ijoin without it.
19:59:17 <startling> :t liftM Identity . runIdentity -- here it is.
19:59:18 <lambdabot> Monad m => Identity (m a1) -> m (Identity a1)
19:59:47 <Negatratoron> :t runIdentity
19:59:48 <lambdabot> Identity a -> a
20:03:01 <joelteon> :t traverse
20:03:31 <joelteon> alright
20:04:26 <NewAtHaskell> Hey guys! I was reading this https://www.fpcomplete.com/user/tel/lenses-from-scratch#functors part of a lens tutorial, and I'm wondering why fmap isn't applied to both components of Store. Can anyone shed some light on it?
20:19:38 <jle`> hm, he left
20:21:16 <jle`> i'll give my stab at an answer though
20:21:31 <jle`> what would the type signature of that fmap be?
20:21:48 <jle`> (it's a rhetorical question)
20:22:37 <startling> is a question rhetorical if no one hears it?
20:28:26 <cschneid> Set doesn't appear to have a way to xor keys between them? ie, show me keys that are in one or other but not both?
20:28:53 <cschneid> merge them and subtract the intersection would do it
20:30:02 <Iceland_jack> cschneid: It's called symmetric difference
20:33:58 * hackagebot ewe 0.1.0.30 - An language using in Programming Languages teaching  http://hackage.haskell.org/package/ewe-0.1.0.30 (JuanFranciscoCardonaMcCormick)
20:42:35 <cschneid> Iceland_jack: ok, but Data.Set doesn't have it built in?
20:42:40 <Iceland_jack> no
20:48:58 <fread2281> what is the syntax for deconstructing and keeping the original arg in scope? It uses @
20:51:16 <Iceland_jack> fread2281: as-patterns you mean?
20:51:25 <arkeet> fread2281: var@pat
20:51:36 <arkeet> e.g. list@(x:xs)
20:51:45 <Iceland_jack> > let list@[a,b,c,d] = "test" in [d,c,b,a]
20:51:46 <lambdabot>   "tset"
20:52:26 <Iceland_jack> > let original@[a,b,c,d] = "test" in printf "'%s' is '%s' in reverse" [d,c,b,a] original
20:52:27 <lambdabot>   No instance for (Text.Printf.PrintfType a0)
20:52:27 <lambdabot>    arising from a use of `e_1'
20:52:27 <lambdabot> ...
20:52:30 <Iceland_jack> > let original@[a,b,c,d] = "test" in printf "'%s' is '%s' in reverse" [d,c,b,a] original :: String
20:52:31 <lambdabot>   "'tset' is 'test' in reverse"
20:53:34 <fread2281> arkeet, Iceland_jack thanks
20:53:36 <arkeet> for the formal definition: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17
20:53:37 <arkeet> :-)
20:54:00 * hackagebot wai-app-file-cgi 0.8.6 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.8.6 (KazuYamamoto)
20:54:02 * hackagebot mighttpd2 2.8.9 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.8.9 (KazuYamamoto)
21:09:01 * hackagebot tdd-util 0.2.0.2 - Test framework wrapper  http://hackage.haskell.org/package/tdd-util-0.2.0.2 (ByronJohnson)
21:14:12 <cbw> Hello folks. Who else is carving the haskell logo into their pumkins this fall?
21:17:15 <Iceland_jack> cbw: They don't give Haskellers shart objects where I live :)
21:17:19 <Iceland_jack> *sharp
21:17:56 <osa1> about the accepted answer here http://stackoverflow.com/questions/6364409/why-does-haskells-head-crash-on-an-empty-list-or-why-doesnt-it-return-an/6364990#6364990 where is this free theorems written?
21:18:45 <Iceland_jack> osa1: Are you asking about the actual paper?
21:18:53 <Iceland_jack> Search for Wadler's “Theorems for Free”
21:18:58 <cbw> Iceland_jack: I will send you a picture of mine then :)
21:19:21 <Iceland_jack> osa1: If you take a look at the comment section you should see a reference to that paper
21:19:27 <Iceland_jack> cbw: how kind!
21:23:48 <amalloy> i have a type like `data T = Foo Int | Bar [String] | Function (Int -> Int)`. i'd like to derive an Eq instance for it, but of course i can't since there's no Eq instance for a->a. is there a way i can derive it and also say "no Function is ever equal to anything", or do i have to do the whole Eq instance by hand?
21:24:08 * hackagebot tdd-util 0.2.0.3 - Test framework wrapper  http://hackage.haskell.org/package/tdd-util-0.2.0.3 (ByronJohnson)
21:24:18 <simpson> amalloy: You'll have to do it by hand.
21:24:26 <Iceland_jack> amalloy: do it yourself
21:24:38 <Iceland_jack> Should be easy enough
21:24:50 <amalloy> okay, thanks. did that already, then thought there might be an easier way
21:26:57 <Iceland_jack> amalloy: Also something you can do to compare (Int → Int) functions is
21:26:57 <Iceland_jack>     instance Eq T where
21:26:57 <Iceland_jack>         …
21:26:57 <Iceland_jack> 	Function f₁ == Function f₂ = and [ f₁ x == f₂ x | x ← [minBound…maxBound] ]
21:27:00 <Iceland_jack> 	…
21:27:03 <Iceland_jack>  
21:27:07 <Iceland_jack> which is of course a joke
21:27:47 <enthropy> @hackage universe
21:27:47 <lambdabot> http://hackage.haskell.org/package/universe
21:28:19 <Ghoul_> is there a way to do transformers without monads
21:28:37 <Ghoul_> Like, say I have some type A and it can have severa different types of annotations
21:28:41 <startling> Ghoul_: sure.
21:28:44 <Ghoul_> Foo and Bar
21:29:11 <Ghoul_> I'd like to be able to have a regular A, or a Foo A or a Bar A or even a Foo Bar A but I'm not sure how.
21:29:17 <Iceland_jack> Ghoul_: Right, you want annotations
21:29:34 <enthropy> what are "annotations"?
21:29:47 <Ghoul_> in the compiler im writing sometimes we carry metadata with expressions
21:29:50 <enthropy> @google ghc ANN pragma
21:29:51 <lambdabot> http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/pragmas.html
21:29:51 <lambdabot> Title: 7.13.�Pragmas
21:30:08 <Iceland_jack> that's not the kind I'm talking about enthropy
21:30:16 <startling> "data Foo m a = Foo m a; data Bar m a = Bar m a;" and then you can have a "Foo (Bar (Foo Identity)) a" or whatever.
21:30:22 <Iceland_jack> For example you have an AST and then you want an AST + type expressions
21:30:36 <Iceland_jack> Ghoul_: Look at compdata, look at datatypes a la carte, ...
21:30:48 <Iceland_jack> and then google AST annotate
21:31:15 <Iceland_jack> http://stackoverflow.com/questions/16204177/how-should-i-represent-an-ast-annotated-with-additional-information, http://stackoverflow.com/questions/18774956/annotated-recursive-data-types-with-different-type-of-annotation-in-ast, http://stackoverflow.com/questions/18774956/annotated-recursive-data-types-with-different-type-of-annotation-in-ast, …
21:31:17 <Ghoul_> startling: the problem there is I  think it modifies the actual type of the thing. Iceland_jack thanks.
21:31:42 <Iceland_jack> http://www.reddit.com/r/haskell/comments/1kzwlg/ideas_for_annotating_an_ast_with_custom_data/ ← last one got messed up
21:31:59 <cbw> Iceland_jack: was my regular expression this I did an annotation? a+b* = And ((One 'a')  (Star (One 'b')))
21:32:27 <Iceland_jack> cbw: What would you be annotating it with?
21:32:36 <Iceland_jack> That's just the AST of the regular expression
21:34:26 <cbw> Oh I was confused
21:34:38 <Ghoul_> Iceland_jack: the last one is super great, thanks again
21:35:06 <Iceland_jack> No problem, you can find further information through searching
21:35:42 <Iceland_jack> Ghoul_: Since you're writing a compiler, one nifty thing you can do is to specify what parts of the AST you're talking about
21:36:18 <Iceland_jack> so you can have:
21:36:18 <Iceland_jack>     desugar ∷ SweetAST → AST
21:36:18 <Iceland_jack> where SweetAST ≔ (AST :+: Sugar)
21:36:28 <johnw> can I quote quasi-quotes?  I want an occurrence of |] to be literally inserted
21:36:34 <Iceland_jack> where Sugar could (for example) be negative numbers
21:36:38 <Iceland_jack> or swap for tuples
21:37:09 <Iceland_jack> and desugar changes:
21:37:09 <Iceland_jack>     -4 ↦ 0 - 4
21:37:09 <Iceland_jack> and
21:37:09 <Iceland_jack>     swap (a, b) ↦ (b, a)
21:37:19 <johnw> ah, I see, it cannot be
21:38:15 <Iceland_jack> But unlike a function (where AST includes swap and negative numbers):
21:38:15 <Iceland_jack>     desugar ∷ AST → AST
21:38:15 <Iceland_jack> you can be certain that the return value does /not/ contain any of the syntactic sugar
21:39:04 <simpson> I do miss that, unlike dynamically typed languages, Haskell forces you to have a new AST type for every AST operation where you wish to enforce an invariant that no certain nodes remain after a pass.
21:39:12 <enthropy> johnw: seems you can't escape it like [q| \|] |], but you could do stuff like  [q| |\]  |]
21:39:18 <Iceland_jack> simpson: It doesn't
21:39:27 <startling> simpson: I've noticed that too. I can't find a nice way to do it.
21:39:37 <Iceland_jack> or well, the compdata solution is nice
21:39:47 <startling> Iceland_jack, the thing about your way is that it really limits the operations you can have on your AST.
21:40:02 <enthropy> simpson: how do you enforce those invariants in dynamically typed languages?
21:40:05 <Iceland_jack> How so?
21:40:07 <startling> In particular, you need Monoid on an annotation to have Monad on your AST.
21:40:24 <Iceland_jack> Right right, but I'm interested in enthropy's question
21:40:39 <startling> I'm sure you know the answer.
21:40:40 <Iceland_jack> since that solution at least enforces the invariants statically
21:40:47 <simpson> enthropy: Personally? Depending on what I'm building, either a membership assertion or a casual proof by enumeration of the pass.
21:41:17 <simpson> Parsers as dataflow tools are pretty great for this kind of membership check during the pass; by definition, if it doesn't "parse", it's got bad nodes in it.
21:45:16 <startling> yeah, I have a bad habit of abusing parser stuff for unbound variables etc
21:47:52 <startling> (when my AST has type-level de brujin thingies, I mean.)
21:48:15 <arkeet> de bruijn!
21:48:53 <startling> de brunij
21:49:17 <arkeet> =(
21:58:57 <joelteon> is it possible to use quickcheck with quasiquoters
22:00:45 <johnw> enthropy: the docs said I'd have to invent an escaped syntax like |~], and then add that syntax to my reader
22:01:01 <johnw> but since it's not my reader, I'll just have to avoid QQ in this one case
22:01:03 <Iceland_jack> joelteon: https://gist.github.com/chreekat/5965830 is something like this useful?
22:02:18 <joelteon> yeah, bit
22:03:34 <enthropy> johnw: you can make a  String -> String function that replaces "|~]" with "|]" before calling quoteExp from the original?
22:03:49 <johnw> i never call quoteExp
22:03:52 <johnw> I'm trying to use this:
22:03:55 <johnw> @hackage here
22:03:55 <lambdabot> http://hackage.haskell.org/package/here
22:03:58 <johnw> the non-interpolated version
22:04:01 <enthropy> I mean you can define a new quasiquoter
22:04:07 <enthropy> in terms of the old one
22:04:07 <johnw> meh
22:08:34 <Ghoul_> hmmm in mechanics of structures looking at all the calculations and seeing big neon lights everywhere in my head screaming out what things are monoids and what things aren't.
22:10:57 <Ghoul_> data.reflection replaces data.monoid.reducer, and its confusing.
22:14:22 <johnw> huh?
22:14:39 <johnw> how is Data.Reflection even related to reducer?
22:16:46 <Ghoul_> well, I looked at the old monoid package and it says its deprecated
22:16:56 <johnw> ok...
22:17:02 <johnw> how does that connect anything to reflection?
22:17:31 <Ghoul_> woops, I made an error somewhere in the breadcrumbing
22:17:58 <Ghoul_> somehow inbetween classes I went from trying to learn the `reducers` package to learning the `reflection` package, sorry ;_;
22:18:14 <johnw> haha, ok, just making sure I wasn't crazy :)
22:19:08 <startling> http://hackage.haskell.org/package/re*
22:21:02 <johnw> i think reducers may be unfortunately named
22:21:21 <johnw> it has a lot of general-use monoid goodness in it, that really has very little to do with the idea of "reduction"
22:21:36 <johnw> plus the fact that all of these monoids are in groups named Data.Semigroup.* doesn't help
22:21:49 <startling> "groups" :)
22:21:55 <johnw> oops, algebraic slip
22:22:08 * johnw just started into Serge Lang
22:23:49 * startling considers Data.Semigroup ^(-1)
22:24:48 <xpika> is there any alias for (map . map) on hackage?
22:25:10 <xpika> >  ((map.map) (+1) [[1,2],[3,4]])
22:25:11 <lambdabot>   [[2,3],[4,5]]
22:25:22 <startling> xpika, what's wrong with map . map?
22:25:26 <xpika> too lazy to type map.map
22:25:35 <startling> let mapmap = map . map in ...
22:25:58 <xpika> i wanted something more idiomatic
22:26:24 <startling> Sometimes fmap . fmap is called (.:)
22:26:24 <ION> (map . map) is just fine.
22:27:07 <xpika> > let (..) = 3 in (..)
22:27:08 <lambdabot>   <hint>:1:6: parse error on input `..'
22:32:06 <Cale> xpika: (..) isn't allowed as an infix name because it's part of the syntax for lists
22:34:15 * hackagebot ifscs 0.2.0.0 - An inductive-form set constraint solver  http://hackage.haskell.org/package/ifscs-0.2.0.0 (TristanRavitch)
22:44:16 * hackagebot tagstream-conduit 0.5.4.1 - streamlined html tag parser  http://hackage.haskell.org/package/tagstream-conduit-0.5.4.1 (MichaelSnoyman)
22:49:16 * hackagebot syntactic 1.7.1 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-1.7.1 (EmilAxelsson)
23:13:54 <pharaun> api/code design is hard :(
23:44:17 <bearclaw> http://www.haskell.org/ghc/download_ghc_7_6_3 <--big warning here telling me that haskell_platform contains ghc, but that does not seem to be the case
23:44:25 <bearclaw> not according to haskell_platform's configure
23:45:50 <startling> it depends how you install it.
23:54:02 <xpika> @startling : thanks for the .: i found it in http://hackage.haskell.org/package/functors-0.1/docs/Data-Functor-Syntax.html
23:54:02 <lambdabot> Unknown command, try @list
23:54:39 <startling> :/
