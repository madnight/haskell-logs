00:00:23 <startling> Ralith, I could always write free and malloc and thereby assume I have no memory leaks.
00:00:33 <Ralith> no, that would be stupid
00:01:03 <Ralith> such an assumption would be unsafe, for starters
00:02:10 <startling> Ralith, why wouldn't I just data Vector = Vector {-# UNPACK #-} !Float {-# UNPACK #-} !Float {-# UNPACK #-} !Float? I don't get how Data.Vector.Whatever gives me anything.
00:02:35 <Ralith> startling: you tell me
00:02:40 <Ralith> your example was parameterized.
00:03:19 <startling> um, ok.
00:03:46 <Ralith> if you express distress that something only works for monomorphic fields, you should not act confused when someone provides a solution that works for polymorphic fields.
00:04:20 <ana_> pl \a b -> a + b
00:04:32 <startlebot> ana_: (+)
00:05:00 <zRecursive> @pl \a b -> a + b
00:05:00 <lambdabot> (+)
00:05:07 <ana_> Thanks.
00:05:51 <ana_> @pl \n (x:xs) ->  map (/ n) $ scanl (+) (n*x) $ zipWith (-) xs $ replicate n x ++ xs
00:05:55 <lambdabot> flip ap tail . (. head) . ap ((.) . (.) . map . flip (/)) (ap (ap . ((.) .) . (id .) . (scanl (+) .) . (*)) ((ap (($) . zipWith (-)) .) . ((++) .) . replicate))
00:05:56 <lambdabot> optimization suspended, use @pl-resume to continue.
00:06:17 <ana_> @pl-resume
00:06:23 <lambdabot> flip ap tail . (. head) . ap ((.) . (.) . map . flip (/)) (ap (ap . ((.) .) . (id .) . (scanl (+) .) . (*)) ((ap (($) . zipWith (-)) .) . ((++) .) . replicate))
00:06:23 <lambdabot> optimization suspended, use @pl-resume to continue.
00:06:33 <ana_> Yuk.
00:06:46 <startling> ana_: the @pl-resume thing is usually a bug expressing itself.
00:07:39 <Hafydd> fix @pl-resume
00:10:45 <Skilz> DCC SEND 00010111001111001010101101000101010001010101010100101101010101011111000011010100101011100010101010100101010010101010010101010101010101010101001010111010010010010101010011010111111000000101011000101010100100100110101010010100010100101000101010011011011000011000101010010111100101001011010101010010101010010101001010100101001001010101010010101111001001100000000101100000001011011001001
00:24:31 <nominolo> Ghoul_: I hacked on it this weekend
00:34:11 <startling> it seems like {-# SPECIALIZE ... #-} pragmata are actually slowing my code down. Why's that?
00:35:30 <bartavelle> cache trashing ? (if SPECIALIZE does actually generate more code)
00:35:37 <leroux> ls
00:36:25 <startling> bartavelle: I guess I don't know what that would mean in this case.
00:37:06 <bartavelle> machine code is cached, if you use more machine code in a tight loop, it might not fit in the cache anymore
00:37:12 <startling> bartavelle: ah.
00:37:40 <startling> oh, I guess I would need to {-# SPECIALIZE ... #-} the function that calls it, too, wouldn't i?
00:38:00 <bartavelle> this was just a wild guess, might be totally inaccurate
00:38:08 <bartavelle> depending on what you do it might be tons of stuff
00:38:23 <bartavelle> such as the branch predictor misbehaving, memory contention ...
00:38:54 <bartavelle> is that a computation intensive application with tight loops ?
00:39:08 <startling> I've got a lot of code on containers that's mostly used on containers of Floats. One of these is a distance function. I've tried specializing it on containers of floats.
00:39:25 <bartavelle> do you use it for other types of containers ?
00:39:34 <bartavelle> hum
00:39:54 <bartavelle> well actually I have no clue on how GHC compiles stuff, and only faint ideas of how a CPU work, not sure I'll be much more help now :)
00:40:46 <startling> but, like I said, I didn't {-# SPECIALIZE ... #-} the (polymorphic) code that calls into it. So maybe it doesn't do anything in that case.
00:41:01 <bartavelle> well, at least it should be easy to test
00:41:13 <startling> Yep. Recompiling as I type.
00:45:34 <startling> well, there was a smaller performance hit. :)
00:49:02 <startling> Does a SPECIALIZE'd function use specialized versions of all the functions it calls?
00:54:05 <shachaf> You mean, even if those aren't marked SPECIALIZE?
00:55:29 <startling> Yeah.
00:56:13 <shachaf> I should hope not.
00:56:22 <shachaf> But you can always look at the generated code and see for yourself.
00:57:35 <startling> Good point.
01:04:03 * hackagebot hsqml 0.2.0.0 - Haskell binding for Qt Quick  http://hackage.haskell.org/package/hsqml-0.2.0.0 (RobinKay)
01:04:05 * hackagebot hsqml-morris 0.2.0.0 - HsQML-based implementation of Nine Men's Morris  http://hackage.haskell.org/package/hsqml-morris-0.2.0.0 (RobinKay)
01:34:06 * hackagebot bytestring 0.10.4.0 - Fast, compact, strict and lazy byte strings with a list interface  http://hackage.haskell.org/package/bytestring-0.10.4.0 (DuncanCoutts)
01:53:04 <Fylwind> is there a way for use cabal to control another build system? or rather, what's a good way to manage a project that's hybrid haskell + C ?
02:02:29 <jro_>   t1 <- getCurrentTime
02:02:30 <jro_>   let cuda = CUDA.run $ integralImage deviceImage
02:02:32 <jro_>   t2 <- getCurrentTime
02:02:41 <jro_> how do I force evaluation of CUDA.run
02:03:00 <jro_> I have tried `deepseq`
02:03:35 <startling> Do any of the Haskell -> JavaScript compilers have nice vectory graphics libraries?
02:05:30 <startling> Also, should I use Mealy from `machines' for my GUI? (Am I FRP yet?)
02:05:42 <fizruk> jro_: maybe, cuda <- return $! CUDA.run $ integralImage deviceImage ?
02:11:02 <bartavelle> jro_ : what's the type of CUDA.run ?
02:11:08 <xupet123> can somebody help me with some haskell?
02:11:10 <xupet123> very new to it
02:11:23 <bartavelle> xupet123: ask away
02:11:32 <jro_> (Array DIM2 Int)
02:11:39 <bartavelle> wow :)
02:12:40 <xupet123> solve :: Sudoku -> Maybe Sudoku solve s | not (isOkay s) = Nothing solve s | isSolved s = Just s solve s = case [solve (update s (blank s) (Just i)) | i <- [1..9]] of           [] -> Nothing           (x:_) -> x
02:12:46 <xupet123> can someone explain this?
02:12:54 <xupet123> what it exactly does
02:14:10 * hackagebot citation-resolve 0.4 - convert document IDs such as DOI, ISBN, arXiv ID to bibliographic reference.  http://hackage.haskell.org/package/citation-resolve-0.4 (TakayukiMuranushi)
02:14:42 <bartavelle> xupet123, you might want to use http://lpaste.net/ to paste code
02:15:33 <xupet123> http://lpaste.net/4131046248490729472 I need help with F1
02:15:41 <xupet123> I dont understand the function
02:16:28 <bartavelle> what do you have trouble grasping ? is that a at the syntactic level or behaviour ?
02:16:49 <bartavelle> I suppose lines 172-174 are clear enough ?
02:18:14 <krakrjak> xupet123: at a high level it's a sudoku solver using pattern matching and guards to build up a recursive definition of a solution.
02:18:44 <xupet123> is there any better and simpler way to write f1?
02:18:56 <krakrjak> xupet123: not given are the helpers update, blank and isSolved, but there meanings are relatively easy to ascertain in context.
02:21:08 <bartavelle> actually blank and update are in the paste
02:21:17 <bartavelle> also isSolved
02:22:14 <xupet123> ya
02:22:34 <xupet123> but i really don't understand what the F1 is doing..
02:22:41 <xupet123> my friend helped me to write it
02:22:47 <xupet123> and he didn't explain so good
02:23:06 <bartavelle> what part don't you understand specifically ?
02:23:15 <bartavelle> I support lines 173/174 are ok ?
02:23:30 <xupet123> 172-177
02:23:38 <xupet123> they are ok. They are working in terminal
02:23:53 <xupet123> but i need to understand them else i will never learn anything
02:23:58 <bartavelle> which lines are giving you trouble ? all of them ?
02:24:03 <xupet123> nop no one
02:24:05 <bartavelle> :)
02:24:06 <xupet123> its working
02:24:24 <bartavelle> which lines do you not understand ?
02:24:32 <xupet123> 172-177
02:24:43 <bartavelle> ok, let's start with 172
02:24:51 <xupet123> ok
02:25:01 <bartavelle> what would you say the type means ?
02:25:36 <xupet123> it take something from suduko and it maybe gives it back?
02:25:40 <xupet123> something like that?
02:25:48 <bartavelle> well, not really
02:25:55 <xupet123> oh..
02:26:05 <bartavelle> it takes a "Sudoku" and might return another
02:26:08 <bartavelle> or nothing
02:26:10 <solarus> does this really work?
02:26:20 <xupet123> ok
02:26:25 <xupet123> ye its work in terminal
02:26:42 <solarus> it seems like you only have to return correct sudokus on line 177
02:26:52 <solarus> but x might be Nothing
02:27:17 <bartavelle> oh that's true :) means you got lucky
02:27:27 <xupet123> so its not working?
02:27:28 <xupet123> :/
02:27:32 <krakrjak> some puzzles can't be solved right?
02:27:42 <gauthier_> trying to use Shelly, how to get out of Sh monad? I try to use test_f :: FilePath -> Sh Bool and want to get that Bool out
02:27:42 <xupet123> nop
02:27:53 <bartavelle> on the other hand, this solver will be really fast
02:28:12 <solarus> :)
02:28:17 <solarus> indeed
02:28:42 <bartavelle> xupet123, do you understand what "Maybe a" denotes ?
02:28:51 <solarus> xupet123: it doesn't work for `allBlankSudoku' for me at least
02:29:05 <xupet123> no i don't understand
02:29:09 <xupet123> I'm really new to this
02:29:14 <bartavelle> ok, there is quite a bit of work then :)
02:29:21 <xupet123> ye i guess
02:29:48 <bartavelle> are you familiar with other languages ?
02:30:02 <mangaba_1eitosa> like Ancient Greek
02:30:19 <xupet123> no i am freshman year and our first language we learn is haskell
02:30:28 <fizruk> gauthier_: shelly or shellyNoDir ?
02:30:33 <nomeata> Hi. Do your feed readers also have problems with planet.haskell.org right now, and keep posting Dominic’s and Neil’s recent posts?
02:31:00 <fizruk> gauthier: they don't actually give you Bool, but rather MonadIO m => m Bool
02:31:32 <fizruk> gauthier_: such an m could be IO, so you can get IO Bool
02:32:34 <bartavelle> ok, so let's say you need a function that parses a string and returns a integer, it might have type "String -> Integer", right ?
02:33:24 <bartavelle> but what happens when you try to parse a string that doesn't represent an integer ?
02:34:18 <bartavelle> a nicer type would be "String -> Maybe Integer", meaning that is could return "Just" an integer, or "Nothing"
02:34:44 <lpaste> tomejaguar pasted “Cabal fail” at http://lpaste.net/94038
02:34:53 <tomejaguar> ^^ anyone have any idea what this means?
02:35:02 <xupet123> ohh
02:35:15 <xupet123> ok i unddertand that now
02:35:23 <brainacid> good morning from est zone
02:35:30 <xupet123> so it could be a integer or Nothing?
02:35:35 <bartavelle> so this function will return "Just sudoku" if there is a solution, and Nothing if there is none
02:35:36 <brainacid> how do i modify this to count characters
02:35:42 <gauthier_> fizruk: it's shelly, I did try isFile <- test_f n, actually I think my issue is that I'm within liftIO
02:35:46 <brainacid>  where chars input = show (length (lines input )) ++ "\n"
02:36:01 <xupet123> Ok!
02:36:31 <bartavelle> I rewrote it here : http://lpaste.net/94040
02:37:01 <gauthier_> fizruk: ok, I do have to put another shelly in there and it works thanks :)
02:37:09 <bartavelle> the pipe thing is a function guard, it is followed by a boolean value and some code. If the boolean value is true, then the code will be run
02:37:18 <xupet123> error.
02:37:20 <xupet123>  Sudoku-3.hs:175:28: Not in scope: `catMaybes' Failed, modules loaded: none. Prelude>
02:37:20 <fizruk> gauthier_: ok) I don't know what you're doing, but probably you don't need Sh code inside of liftIO block :)
02:37:28 <bartavelle> yeah you need to import Data.Maybe
02:37:35 <brainacid> How to modify http://pastie.org/8386145
02:37:42 <brainacid> TO count char
02:37:44 <bartavelle> so line 2 returns nothing if your sudoku is not "Okay" (ie. correct)
02:37:45 <brainacid> Thanks
02:37:46 <Fylwind> what's a good reference site for all the settings that the .cabal file supports?
02:38:02 <bartavelle> line 3 will return "Just s", if the sudoku is solved, the complicated part is line 4
02:38:14 <fizruk> brainacid: length (lines input) ==> length input
02:38:32 <bartavelle> basically it will fill the next blank space in your sudoku with a value from 1 to 9, and will call solve on that recursively
02:38:34 <brainacid> fizruk, interesting...thanks
02:38:43 <xupet123> Sudoku-3.hs:177:40:     Couldn't match expected type `Maybe Sudoku'                 with actual type `Sudoku'     In the expression: x     In a case alternative: (x : _) -> x     In the expression:       case           catMaybes [solve (update s (blank s) (Just i)) | i <- [1 .. 9]]       of {         [] -> Nothing         (x : _) -> x } Failed, modules loaded: none.
02:38:45 <xupet123> error again
02:38:55 <bartavelle> oh my bad
02:38:56 <fizruk> brainacid: String is just a list of Char's
02:39:03 <xupet123> http://lpaste.net/2061026634936352768
02:39:07 <brainacid> fizruk, correct
02:39:08 <bartavelle> line 6 should be (x:_) -> Just x
02:39:20 <brainacid> fizruk, I get error ==> not in scope
02:39:35 <fizruk> brainacid: that was "replace with" =)
02:39:36 <quchen> I've recently been having some problems where I need both fairness and atomicity. How useful do you think is a design pattern where STM does the transactions, and Chans distribute the results (in places where this makes sense)?
02:40:04 <bartavelle> this will result in a list of type [Maybe Sudoku], which will be turned into [Sudoku] by catMaybes. If that list is empty we know there are no valid solutions, if it's not then we just pick the first
02:40:09 <fizruk> brainacid: simply remove 'lines'
02:40:17 <xupet123> ok
02:40:31 <xupet123> but its not working..
02:40:34 <bartavelle> :)
02:40:34 <fizruk> brainacid: chars input = show (length input) ++ "\n"
02:40:39 <xupet123> http://lpaste.net/2061026634936352768
02:40:42 <brainacid> fizruk,  copy that
02:40:56 <brainacid> Sweet
02:41:50 <brainacid> fizruk, reading Real World Haskell...that was an exercise. Thanks
02:41:50 <bartavelle> xupet123, line 6 should be (x:_) -> Just x
02:42:00 <brainacid> Haskell community ROCKS!!
02:42:09 <xupet123> nice
02:42:11 <xupet123> working now
02:43:45 <bartavelle> well, luckily there are quite a few other things left to fix
02:44:00 <xupet123> like?
02:44:17 <xupet123> printSudoku (fromJust (solve allBlankSudoku))
02:44:25 <zomg> Sudoku eh, that might be interesting to do in Haskell... I wrote a solver in JavaScript a few years ago, would be fun to compare the implementations
02:44:31 <xupet123> not working
02:44:32 <eikke> edwardk: you might be interested in http://www.forceflow.be/2013/10/07/morton-encodingdecoding-through-bit-interleaving-implementations/
02:44:46 <xupet123> *** Exception: Maybe.fromJust: Nothing
02:45:47 <bartavelle> well you have this to fix :)
02:45:48 <DanielDiaz> xupet123: that means your solver didn't find any solution. When you apply 'fromJust' to a value of the form 'Just x', it would return 'x'. But, if the value is 'Nothing', it returns that exception.
02:46:44 <xupet123> http://lpaste.net/6577471908193763328
02:46:56 <xupet123> i should get that
02:47:33 <xupet123> *** Exception: Maybe.fromJust: Nothing
02:47:37 <xupet123> i get this instead
02:50:39 <bartavelle> I believe coordinates is wrong too
02:51:08 <xupet123> which line
02:51:34 <bartavelle> the "coordinates" function, just run it in ghci, you'll see how it's wrong
02:54:15 * hackagebot cabal-rpm 0.8.6 - RPM package creator for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.8.6 (JensPetersen)
02:54:34 <xupet123> i think its not working correctly
02:54:38 <bartavelle> :)
02:54:44 <solarus> xupet123: also try `update s (0,0) (Just 1)' and find out what is wrong
02:55:59 <xupet123> Sudoku> blank allBlankSudoku
02:56:02 <xupet123> i get (0,0)
02:56:08 <xupet123> that correct
02:56:20 <solarus> what do you think?
02:56:27 <xupet123> i dont know
02:56:32 <xupet123> Sudoku> blank example
02:56:38 <xupet123> i get wrong i get (2,2)
02:56:43 <xupet123> i should get (0,2)
02:57:03 <solarus> yes
02:57:13 <solarus> so blank should return what?
02:57:54 <xupet123> really don't know
03:00:02 <solarus> xupet123: look here http://www.cse.chalmers.se/edu/course/TDA555/lab3.html
03:00:11 <solarus> assignment E1
03:00:26 <xupet123> ye
03:01:45 <solarus> i.e. it should return a blank cell
03:02:20 <solarus> btw you seem to skip the part of the exercise that tells you to write a property that the implementation is correct :)
03:02:39 <xupet123> ye..
03:02:45 <xupet123> i don't know how to do that
03:02:54 <xupet123> fuck i will never learn haskell
03:03:40 <xupet123> http://lpaste.net/2527544981900492800
03:03:48 <xupet123> so whats wrong in there?
03:03:58 <solarus> xupet123: pm
03:07:40 <person> how can I check if I have a 32 bit or 64 bit GHC?
03:08:29 <fizruk> > maxBound :: Int
03:08:30 <lambdabot>   2147483647
03:09:10 <fizruk> person: I think like that ^
03:09:49 <person> seems like 64 if that is correct
03:10:16 <person> thanks
03:10:21 <fizruk> person: have you tried on your machine?
03:10:33 <person> yes
03:10:39 <fizruk> ok :)
03:19:25 <eikke> actually that's not necessary a correct check
03:20:59 <eikke> you should check the Report, but IIRC a Haskell Int must be 30bits or something, and nothing forces an implementation to use untagged machine ints (e.g. in OCaml a 'native' 'int' is 31 or  63 bits due to pointer tagging)
03:22:47 <fizruk> "The finite-precision integer type Int covers at least the range [-2^29, 2^29 - 1]"
03:25:19 <fizruk> > logBase 2 (fromIntegral (maxBound :: Int))
03:25:19 <lambdabot>   30.999999999328193
03:27:06 <Yuu-chan> eikke: why 30 and not 31?
03:30:34 <fizruk> > fromIntegral (2^32 - 1 :: Integer) :: Int
03:30:36 <lambdabot>   -1
03:30:42 <fizruk> > fromIntegral (2^32 :: Integer) :: Int
03:30:43 <lambdabot>   0
03:30:58 <SpindleApparatus> Is there an easy way in Haskell to handle very high precision? I'd like to implement arithmetic coding as practice.
03:31:48 <Yuu-chan> SpindleApparatus: Data.Ratio :)
03:31:56 <SpindleApparatus> Ty.
03:39:25 <ski> > toRational pi
03:39:26 <lambdabot>   884279719003555 % 281474976710656
03:40:33 <DanielDiaz> ski: therefore, pi is rational. QED.
03:40:42 <SpindleApparatus> heh
03:41:06 <Lethalman> lol
03:41:51 <ocharles> @faq can Haskell prove that pi is rational?
03:41:51 <lambdabot> The answer is: Yes! Haskell can do that.
03:41:55 <ocharles> well there we go
03:45:52 <zomg> @faq can haskell prove that evolution is wrong and creationism is right?
03:45:52 <lambdabot> The answer is: Yes! Haskell can do that.
03:45:54 <zomg> :O
03:48:03 <hpc> @faq can haskell make a boulder so large even it cannot lift it?
03:48:04 <lambdabot> The answer is: Yes! Haskell can do that.
03:48:10 <tomejaguar> @faq Can Haskell implement all programming languages that can't implement themselves?
03:48:11 <lambdabot> The answer is: Yes! Haskell can do that.
03:48:39 <DanielDiaz> Haskell is sort of a God
03:49:14 <fizruk> there's no such thing, I guess Haskell can prove it :p
03:50:10 <DanielDiaz> @faq Is there something Haskell is not able to do?
03:50:10 <lambdabot> The answer is: Yes! Haskell can do that.
03:50:15 <DanielDiaz> gotcha
03:53:19 * brainacid really love Real World Haskell by O'Reilly
03:54:38 <inad922> hello
03:55:14 <inad922> Is there any balanced binary tree implementation in the haskell standard library? Like red black or avl?
03:56:51 <DanielDiaz> inad922: this may be helpful: http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html
03:57:05 <DanielDiaz> maps use balanced trees internally
03:57:48 <inad922> DanielDiaz: Yeah I just need the ordering. Thanks.
04:08:26 <quchen> @Answer "The answer is: Yes! Haskell can do that." iff the Riemann hypothesis holds
04:08:27 <lambdabot> Unknown command, try @list
04:08:34 <quchen> Eh, @faq. Nevermind.
04:08:54 <quchen> I wonder whether this command was put to good use at any point in the last couple of years.
04:09:07 <quchen> It was probably practical for a week before people started using it for jokes.
04:09:32 <zomg> The only "legit" use I've seen it is to answer questions like "can haskell do <some trivial programming task>" :P
04:09:36 <int-e> quchen: Wow, you'd give it a whole week? :)
04:10:36 <quchen> zomg: That produces a correct but unhelpful answer.
04:12:09 <int-e> @faq putStrLn "No, Haskell can't do that."
04:12:10 <lambdabot> The answer is: Yes! Haskell can do that.
04:13:19 <int-e> the commit message was * Add @faq, to answer faqs like "is Haskell good for xyz programming?"
04:13:44 <ciaranm> is haskell good for performance-critical programming?
04:14:01 <osfameron> on embedded devices? ;-)
04:14:12 <ciaranm> on supercomputers
04:14:35 <ski> @ghc
04:14:36 <lambdabot>  This is very gruesome indeed
04:15:27 <fizruk> why is not IdentityT in Control.Monad.Identity (like StateT in Control.Monad.State, etc.)
04:15:56 <Eduard_Munteanu> ciaranm: it can do a lot better than other languages like python, at least
04:16:43 <Eduard_Munteanu> ciaranm: YMMV, if you're running on a supercomputer, you probably want to microoptimize at some point.
04:17:53 <Eduard_Munteanu> Assuming you're just gluing things, not implementing basic algorithms but calling out a lib.
04:18:24 <exicer> Can anyone suggest an algorithm for checking how similar strings are - except the strings are incredibly long, and consist only of two letters (usually one letter repeated a number of times followed by the other etc)?
04:18:27 <ciaranm> Eduard_Munteanu: i wasn't being serious
04:18:34 <Eduard_Munteanu> Oh. :)
04:19:01 <Eduard_Munteanu> exicer: compute the Levenshtein distance?
04:19:03 <ciaranm> there's not much point trying to demonstrate that a 64 core box can run an algorithm 60 times faster using haskell when a sequential implementation in C++ can run 100 times faster...
04:19:07 <int-e> quchen: actually it was added and then forgotten for about 2 months. And then the first question was ... <ihope>@faq Can Haskell solve the halting problem for Turing machines?
04:19:11 <MasseR> exicer: A naive thought, group and then levenshtein
04:19:38 <exicer> MasseR, Eduard_Munteanu  - Yeah that is what I was planning on so far
04:19:53 <Eduard_Munteanu> exicer: actually if there are only two letters you can probably do Hamming distance and pretend they're 0s and 1s.
04:20:06 <exicer> Eduard_Munteanu: Oh, that might be a good idea
04:20:18 <Eduard_Munteanu> Might be worth representing them like that, as well.
04:20:40 <exicer> Well I'll try a whole load of things I suppose
04:21:12 <exicer> Just wanted to make sure there wasn't some obvious best answer that I couldn't think of
04:21:25 <Eduard_Munteanu> exicer: Hamming can be pretty efficient as xor + popcnt
04:23:47 <exicer> Eduard_Munteanu: Actually, looking at the strings they are shorter than I thought they would be
04:23:55 <exicer> aroud 4k characters
04:25:45 <person> in the IO monad, expressions are evaluated in order, right? So all the expressions will be evaluated like in a strict language?
04:26:01 <Eduard_Munteanu> person: no
04:26:33 <Eduard_Munteanu> person: there's nothing special about IO, it's only (>>=) sequencing IO *actions*, not expressions.
04:26:42 <Tinned_Tuna> Eduard_Munteanu: I thought the effectual "stuff" happened in order, but not expressions?
04:27:01 <person> I remember there was an operator for enforcing strictness?
04:27:23 <Eduard_Munteanu> person: yes but strictness doesn't affect IO actions.
04:27:44 <person> ok thanks
04:27:59 <quchen> There are different levels of strictness you can enforce. The simplest one is using `seq` or ($!).
04:28:11 <ski> @src ($!)
04:28:11 <lambdabot> f $! x = x `seq` f x
04:28:13 <quchen> But depending on your application you may want to be stricter.
04:28:28 <Eduard_Munteanu> Tinned_Tuna, person: if you think of IO as building an AST that the RTS executes, then you can see how (>>=) merely puts things together.
04:28:44 <ski> @type Control.DeepSeq.rnf
04:28:45 <lambdabot> Control.DeepSeq.NFData a => a -> ()
04:28:53 <ski> @type Control.Exception.evaluate
04:28:53 <lambdabot> a -> IO a
04:50:05 <nlogax> What happened to http://projects.haskell.org/camp/ ?
04:53:08 <gauthier_> I'm playing with zmq, I'd like to run several subscribers similar to https://github.com/imatix/zguide/blob/master/examples/Haskell/psenvsub.hs, given I put the main code in function with relevant parameters, what map function should I use?
04:53:28 <anakreon> Are there plans in fgl for changing the Node type fron an alias to Int into an arbitrary Eq?
04:55:35 <anakreon> I often need values stored in a graph node to be distinct. With an Int node I need to preserve an isomorphism between nodes and their labels (e.g. when merging two graphs that store the same label type in nodes)
04:58:49 <anakreon> Moreover, if we require node type to be an Enum, one could implement the newNodes function
04:59:43 <mbrock> anakreon: have you seen the Data.Graph.Inductive.NodeMap module?
04:59:54 <mbrock> anakreon: dunno if it's perfect for you but it might help
05:00:37 <anakreon> Thanks, I'll check that
05:19:26 <bartavelle> would someone suggest a nice command line argument parsing package ?
05:19:41 <donri> optparse-applicative
05:19:59 <bartavelle> thanks I'll check it right now
05:24:39 * hackagebot omaketex 0.1.0.0 - A simple tool to generate OMakefile for latex files.  http://hackage.haskell.org/package/omaketex-0.1.0.0 (HiromiIshii)
05:33:15 <Eduard_Munteanu> Hrmpf... Data.Set doesn't have a lookup function. :/
05:33:50 <Eduard_Munteanu> Nor insertWith.
05:34:06 <jmcarthur_mobile> What would their types even be?
05:35:13 <Eduard_Munteanu> jmcarthur_mobile: lookup :: a -> Set a -> Maybe a   -- it would be useful to implement a Map if you have a container that ords on a property of its element
05:35:31 <jmcarthur_mobile> Why not just use a map?
05:35:55 * jmcarthur_mobile is not a fan of instances that do that anyway 
05:36:08 <Eduard_Munteanu> jmcarthur_mobile: I probably should, I wanted to make a different lookup function like   lookup :: a -> Map a -> [a].
05:36:34 <jmcarthur_mobile> Wait... A list of keys?
05:36:41 <Eduard_Munteanu> Err.
05:37:25 <Eduard_Munteanu> lookup :: a -> (a -> k) -> Map k a -> [a]  -- or something
05:38:09 <jmcarthur_mobile> I still don't see where the list comes from. Is it max length 1 or something?
05:38:39 <Eduard_Munteanu> jmcarthur_mobile: no, I'm making setoids. If you add an existing element, it puts it in its respective equivalence class.
05:39:02 <ciaranm> multisets!
05:39:11 <jmcarthur_mobile> Oh, you aren't talking about Map from containers then
05:39:41 <Eduard_Munteanu> jmcarthur_mobile: I can use that to implement mine
05:39:45 <jmcarthur_mobile> Yeah you just want a multiset or multimap I think
05:40:28 <jmcarthur_mobile> Right, both are easy to implement in terms of Map
05:40:36 <ciaranm> otherwise we'll start having to call categories "monoidoids"
05:40:54 <Eduard_Munteanu> jmcarthur_mobile: I initially thought I could use a Set for the implementation, but unfortunately there's no lookup function.
05:41:11 <jmcarthur_mobile> Multimonoids!
05:41:32 <Eduard_Munteanu> ciaranm: mmm... quotients of monoids? :)
05:42:01 <Eduard_Munteanu> Monoidoid is a real term, sadly. :)
05:42:44 <ski> extensions of monoids ?
05:43:17 <sshine> jmcarthur_mobile, what's a multimonoid?
05:43:42 <Eduard_Munteanu> Presumably a monoid on a coset / setoid.
05:43:43 <sshine> Eduard_Munteanu, a monoidoid, I suppose is something like a groupoid?
05:43:50 <Eduard_Munteanu> *on cosets
05:44:08 <Eduard_Munteanu> sshine: if by groupoid you mean category with inverses, yes
05:44:18 <Eduard_Munteanu> sshine: it's just an old term for plain categories.
05:44:34 <jmcarthur_mobile> I'm on the side of the fence that prefers Eq instances to satisfy  x == y  =>  forall f. f x == f y  anyway
05:44:38 <Eduard_Munteanu> Since they have a monoidal structure wrt ids and composition.
05:44:39 <jmcarthur_mobile> So that use of set bothers me
05:44:40 <jmcarthur_mobile> I have actually been bitten by very, very confusing bugs due to this misuse of sets in production code before
05:44:40 <sshine> Eduard_Munteanu, I thought actually that a groupoid was a group with a few elements missing, i.e. "an almost-group".
05:44:57 <sshine> Eduard_Munteanu, i.e. a monoid that is almost a group :P
05:45:01 <jmcarthur_mobile> Not that using sets that way is inherently buggy, but because it makes some bugs hard to find
05:45:13 <jmcarthur_mobile> Such as in the Ord implementation...
05:45:15 <ciaranm> a groupoid is a category where everything has an inverse
05:45:27 <Eduard_Munteanu> sshine: no, there's "groupoid" that's a magma, a set with an operation, no associativity (so not even a semigroup)
05:45:38 <jmcarthur_mobile> ciaranm: same thing no?
05:45:47 <sshine> Eduard_Munteanu, ah.
05:45:53 <ciaranm> jmcarthur_mobile: up to smallness...
05:46:12 <obk> How do I install the json package with MAP_AS_DICT? cabal install json ...what should I put here to add -DMAP_AS_JSON into the compile line?...
05:47:16 <danilo2> Hello! :) I'm using try to convert IO errors to Either a b. Is there any function which will rethrow in IO Monad the error in Left?
05:47:19 <jmcarthur_mobile> I am not well versed enough to understand why some categories are "large" and others are "small"
05:47:24 <obk> Probably --configure-option="...something...", but what?
05:47:50 <Eduard_Munteanu> Some categories never grow up. :P
05:47:50 <dcoutts> danilo2: see the docs for Control.Exception
05:47:58 <dcoutts> danilo2: but the answer is yes, there is.
05:47:59 <ciaranm> large categories are categories that eat themselves, and so become big and fat
05:48:26 <obk> dcoutts: Hi Duncan
05:48:53 <dcoutts> hello!
05:49:10 * obk is still going at it :-)
05:49:36 <dcoutts> obk: the answer to your Q is in http://hackage.haskell.org/package/json-0.7/json.cabal
05:49:42 <augur> soooo
05:49:44 <augur> ICFP videos? :D
05:49:53 <danilo2> dcoutts: There is no function which has Either as input
05:50:11 <dcoutts> danilo2: no, you take the Either apart yourself
05:50:43 <dcoutts> if you didn't want the Either, you wouldn't have used try
05:50:50 <dcoutts> but something like catch, finally etc
05:51:27 <obk> dcoutts: Thanks! Should have looked in the .cabal file... trying now.
05:51:44 <khyperia> If anyone here knows how to use accelerate... how do I do a stencil-with-custom-offset-indices?
05:51:51 * Derbedeu from where i can buy a good shell ?
05:52:15 <dcoutts> obk: then, cabal install --flags=...
05:52:26 <dcoutts> or cabal configure --flags=
05:53:44 * ski . o O ( <http://en.wikipedia.org/wiki/Monoid_ring> )
05:54:51 <interspersion> anyone here familiar with first order logic? can you explain why falsum can be eliminated by admitting any other proposition?
05:55:03 <obk> dcoutts: Yes, it seems to work... rebuild takes time as you recall :-/
05:55:15 <augur> hey interspersion
05:55:22 <interspersion> hi augur
05:55:34 <dcoutts> obk: aye
05:55:35 <Eduard_Munteanu> interspersion: you mean   _|_ -> p, forall p?
05:55:37 <augur> lets take this to #logic or to #haskell-blah
05:55:42 <augur> Eduard_Munteanu: dont worry, i got this :)
05:55:55 <interspersion> augur: sweet, sounds good
05:57:57 <danilo2> dcoutts: Ok, thanks
06:00:21 <safinaskar-i> http://en.wikipedia.org/wiki/Combinatory_logic#Undecidability_of_combinatorial_calculus says that one cannot decide whenever some ski-function (such as s i i) has normal form. but haskell can decide this! see: i can define ski combinators in haskell (let i x = x; let k x y = x; let s x y z = x z (y z)), and then i can type something like "let a = s i i" to haskell console. if that function has normal form, haskell will accept my definition. if has no - w
06:00:51 <Eduard_Munteanu> safinaskar-i: that got cut off at "if has no - w"
06:01:23 <int80_h> is there a way to tell cabal-dev to install all dependecies with profiling flag?
06:01:59 <Eduard_Munteanu> safinaskar-i: your Haskell combinators don't accept all untyped SKI terms.
06:02:06 <safinaskar-i> if has no - will generate an error. so, haskell can decide, right? but some mathematical theorem states this is not possible. so, how haskell does this?
06:02:11 <int80_h> I'm doing things one at a time, and it appears to be the wrong order,. my forced re-installs are breaking things previously installed with the non-profiling libraries
06:02:54 <Eduard_Munteanu> safinaskar-i: e.g. no fixpoint combinators
06:03:33 <Eduard_Munteanu> So something like omega is ruled out.
06:04:39 <Eduard_Munteanu> Same thing if you tried to define the "untyped" lambda calculus like that.
06:05:30 <safinaskar-i> Eduard_Munteanu: yes, not all ski terms are possible in haskell. moreover, it seems haskell accept ski term if and only if it has normal form. i. e. fixed-point combinators have no such form, so haskell rejects them. so, my question is: how haskell can distinguish term which has normal form? we have math theorem that such decision is not possible for Turing machine
06:05:57 <Eduard_Munteanu> safinaskar-i: it doesn't... it rejects some terms which do have a normal form
06:06:02 <int-e> safinaskar-i: k i <anything>  has a normal form, regardless of whether <anything> is typable or not.
06:06:54 <Eduard_Munteanu> safinaskar-i: think of fixed points that do terminate.
06:07:54 <int-e> more simply, s s s  can't be typed.
06:08:06 <ciaranm> you just typed it!
06:08:13 <safinaskar-i> ciaranm: :)
06:08:16 <Eduard_Munteanu> Hah.
06:08:21 <int-e> ciaranm: good one :)
06:08:24 <safinaskar-i> ciaranm: :))))) ahahaha
06:08:53 <applicative> int80_h: i don't know about cabal-dev, but cabal sandbox and cabal in general have a field for building with profiling in the config file
06:09:13 <safinaskar-i> Eduard_Munteanu: what is omega?
06:09:36 <int80_h> applicative: yeah I think it's time I upgrade
06:09:55 <Eduard_Munteanu> safinaskar-i: (\x -> x x) (\x -> x x) in the untyped lambda calculus
06:10:18 <applicative> int80_h: of course you do have to sort of start over once you tick the 'make profiling libraries' box
06:10:22 <Eduard_Munteanu> Now sure, that doesn't have a normal form.
06:10:32 <Andrew> Will a List  Comprehension always return a list, even if there is only one value left?
06:10:37 <Eduard_Munteanu> But some applications of fixed point combinators do have a normal form.
06:10:42 <applicative> Andrew: yes
06:10:46 <applicative> > [1]
06:10:48 <lambdabot>   [1]
06:10:52 <int80_h> apparsec-3.1.2
06:10:52 <int80_h> network-2.3.0.13
06:10:52 <int80_h> cgi-3001.1.8.2
06:11:08 <int80_h> HTTP-4000.2.3plicative: not a problem. I just noticed I'm only using ghc 7.4.2
06:11:13 <int80_h> oosp
06:11:17 <applicative> > [x | x <- [1]]
06:11:19 <lambdabot>   [1]
06:11:30 <applicative> oh i see.
06:12:12 <applicative> i wonder if you can build the newer cabal with it. you end up building a new Cabal library anyway, so maybe?
06:12:32 <applicative> maybe other things get in the way
06:12:59 <cdk> is there a specific name for Kleisli m a a (as opposed to Kleisli m a b)? Endokleisli? a Kleisli endomorphism?
06:13:31 <applicative> int80_h: on the other hand if youre building everything again, maybe a new ghc if there's no subtlety about the platform or something
06:13:47 <safinaskar-i> Eduard_Munteanu: int-e: okey, i understand. (k i (\x -> x x)) has normal form, but haskell rejects this term. so this is why haskell is capable to decide undecidable problem, right?
06:14:03 <ciaranm> you what
06:14:13 <brainacid> Hey
06:14:15 <Eduard_Munteanu> cdk: forall a. Kleisli m a a  is 'id' for (Monad m) => Category (Kleisli m)
06:14:17 <brainacid> I get parse error
06:14:59 <brainacid> http://pastie.org/8386592
06:14:59 <Eduard_Munteanu> safinaskar-i: that's not deciding the same problem
06:15:04 <cdk> Eduard_Munteanu: so I could call it the identity object in the Kleisli category?
06:15:15 <brainacid> Im following the Write yourself in 48 hr Tutorial
06:15:29 <brainacid> I get  a parse error http://pastie.org/8386592 when I compile
06:15:36 <safinaskar-i> Eduard_Munteanu: "fixed points that do terminate" - what is this?
06:15:41 <Eduard_Munteanu> cdk: the identity arrow, if there's that forall there
06:15:45 <brainacid> Thanks
06:15:52 <applicative> brainacid: yes the examples need a tiny bit of updating for language changes
06:16:07 <Eduard_Munteanu> cdk: otherwise it's just an arrow from an object to itself, in the Kleisli m category
06:16:11 <brainacid> applicative, Hey bud
06:16:12 <applicative> this case is simpler brainacid ;)
06:16:20 <brainacid> applicative, Cool
06:16:29 <applicative> brainacid: don't use tabs.
06:16:34 <brainacid> applicative, I just love this approach of coding off the bat
06:16:35 <cdk> Eduard_Munteanu: makes sense, thanks
06:16:40 <applicative> then line the whitespace up by spaces
06:17:12 <brainacid> applicative, huh?
06:17:53 <Eduard_Munteanu> safinaskar-i: I just mean Haskell rejects some terms that do have a normal form.
06:18:03 <applicative> brainacid: http://lpaste.net/704412342061891584
06:18:07 <brainacid> applicative, I lined it up
06:18:17 <brainacid> applicative, I solved it..with your help
06:18:17 <applicative> here the second line only uses spaces, not tabs
06:18:28 <brainacid> Copy that 104
06:18:32 <Eduard_Munteanu> safinaskar-i: so yes, if Haskell accepts it, it does have a normal form, but the other way around isn't true.
06:18:48 <applicative> brainacid: this is an eternal problem. i think it is characteristic of languages that use white space
06:19:15 <safinaskar-i> Eduard_Munteanu: "that's not deciding the same problem" - yes, i mean this. i. e. "has this normal form" is undecible problem, but haskell solves another problem, so all is ok, right?
06:19:16 <Eduard_Munteanu> safinaskar-i: just like you can decide the Halting Problem in *some* cases.
06:20:05 <Andrew> I have a tuple of type (Name,Int,Int,Int) and A function that types to return [Char],Interger,Interger,Interger
06:20:06 <Eduard_Munteanu> safinaskar-i: no, Haskell tells you *some* terms have a normal form.
06:20:18 <Andrew> How can I make it return the "simpler" types
06:20:23 <brainacid> applicative, Ah interesting. It makes it a beautiful thing. Art and Science
06:20:31 <mauke> Andrew: congratulations on consistently misspelling "Integer" three times
06:20:35 <mauke> son, I am impress
06:20:37 <Andrew> mauke, thanks
06:20:38 <Eduard_Munteanu> Hah.
06:20:45 <mauke> Andrew: what's Name?
06:20:51 <Andrew> String
06:20:51 * brainacid lol @ mauke 
06:21:11 <safinaskar-i> mauke: :)
06:21:12 <int-e> mauke: isn't it "empress"? ;)
06:21:23 <mauke> int-e: that's a different word!
06:21:26 <safinaskar-i> mauke: :))) (about integer misspeling)
06:21:29 <safinaskar-i> mauke: rose
06:21:29 <int-e> really!
06:21:29 <applicative> oh I thought there was a new Interger type
06:21:31 <mauke> Andrew: fromIntegral
06:21:43 <mauke> but that may lose precision
06:21:46 <Eduard_Munteanu> safinaskar-i: the problem that's undecidable is telling whether *any* term has a normal form or not.
06:21:52 <mauke> and by "lose precision" I mean "give wrong results"
06:22:00 <brainacid> applicative, Its the pdf that needs updating
06:22:10 <applicative> hah, theres a new lpaste "Paolo's Free Monad Tips"
06:22:12 <brainacid> applicative, I was about to edit the wiki
06:22:14 <int-e> mauke: but it's editing distance to "impress" is smaller than between "impress" and "impressed".
06:22:28 <brainacid> applicative, But the wiki the whitespace is correct
06:22:42 <applicative> brainacid: someone may have updated the source bits somewhere
06:23:30 <int-e> safinaskar-i: of course \x -> x x == s i i  should have been my first example.
06:24:26 <safinaskar-i> Eduard_Munteanu: int-e: thanks, i understand. i have another question: is it true haskell accepts term if and only if the term and all its subterms have normal forms?
06:24:28 <mauke> int-e: but we're snowcloning "I am disappoint"
06:24:56 <safinaskar-i> i. e.
06:25:39 <safinaskar-i> i. e. haskell rejects (k i (\x -> x x)) because this term has subterm (\x -> x x) which has no normal form. so, is this true in general case?
06:26:11 <tromp__>  nothing to do with having normal form
06:26:18 <tromp__> it rejects terms which are not typable
06:26:35 <mauke> I thought (\x -> x x) was in normal form
06:26:42 <int-e> safinaskar-i: \x -> x x  has itself as a normal form.
06:26:43 <Eduard_Munteanu> safinaskar-i: \x -> x x is normal, no?
06:27:08 <tromp__> it's that thing applied to itself wihch doesnt normalize
06:27:13 <chrisdone> someone else tell him, i don't think he got it
06:28:07 <Eduard_Munteanu> Well, we can talk about embedding SKI in Haskell and whether those terms have a normal form in Haskell, and I think the answer is yes.
06:28:42 <Eduard_Munteanu> But then you're talking about function application and so forth, not the original notion of normality in SKI.
06:29:10 <int-e> simply typed lambda calculus (into which the simply typed ski calculus can be embedded) is strongly normalizing.
06:30:36 <int-e> so indeed all the terms you can build out of s,k,i that can be typed (without resorting to higher order types; what happens if you add these?) will have a normal form.
06:30:42 <tromp__> :t let {k x y = x; s x y z = x z (y z)} in s s k
06:30:43 <Eduard_Munteanu> int-e: I guess Haskell is strongly-normalizing at some level as well, e.g. if function application is opaque. Which just means you don't write infinite expressions.
06:30:44 <lambdabot>     Occurs check: cannot construct the infinite type:
06:30:44 <lambdabot>       t1 = t2 -> t1 -> t0
06:30:44 <lambdabot>     Expected type: (t2 -> t1 -> t0) -> t2 -> t1
06:31:26 <applicative> i think the outdatedness of the 'write yourself a scheme' material is a menace to the language
06:31:46 <int-e> Eduard_Munteanu: adding fixed points (as haskell does) breaks strong normalisation.
06:31:46 <applicative> there are a hundred repos on github that stop when the error about Read happens
06:32:28 <Eduard_Munteanu> int-e: yeah, but you can't really write those fixed points just in terms of abstraction and application
06:32:41 <Eduard_Munteanu> Which is what the type system cares about.
06:32:54 <safinaskar-i> int-e: Eduard_Munteanu: okey, okey, now i really understand all. i just used "has normal form" instead of "typed"
06:33:14 <safinaskar-i> so, haskell accepts ski-term if and only if it is typed, yes?
06:33:32 <int-e> Eduard_Munteanu: indeed. that's the point.
06:33:47 <tromp__> :t let {k x y = x; s x y z = x z (y z)} in s k k
06:33:48 <lambdabot> t -> t
06:33:56 <Eduard_Munteanu> safinaskar-i: yes, and furthermore all terms it accepts can be normalized.
06:34:02 <brainacid> applicative, I was thinking the same thing...when I got error, I wanted to find out why but others may just quit
06:34:35 <brainacid> Its the pdf thats outdated
06:34:58 <brainacid> and funny...the text explains the whitespace alignment as well
06:35:03 <kwstas> hi there! I cannot understand how the type of (.).(.) is (b->c) -> (a->a1->a2)-> a1->a2->c...Can anyone explain it to me?
06:35:08 <kwstas> :t (.).(.)
06:35:10 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
06:35:22 <Eduard_Munteanu> safinaskar-i: that's only valid for that particular representation of SKI you chose. Of course, you can make a data type that accepts *all* SKI terms but it will accept non-normalizing terms as well.
06:35:44 <Eduard_Munteanu> :t (.)
06:35:45 <lambdabot> (b -> c) -> (a -> b) -> a -> c
06:37:42 <safinaskar-i> is type decision a simple problem? i. e. is it O(len of formula)? i think it is, right?
06:38:11 <kwstas> Eduard_Munteanu: yes I know that, but how from this type can we infer the type I wrote above?
06:39:20 <Eduard_Munteanu> kwstas: let (a -> b) be the type of (.), what's a and b?
06:39:30 <applicative> the one with reads is pretty simple, it just needs a type signature somewhere so the compiler knows what to do
06:39:35 <applicative> brainacid: ^^^
06:39:39 <applicative> brainacid: unpackNum (String n) = let parsed = reads n :: [(Integer,String)] in
06:40:18 <brainacid> applicative, thanks...Im on the exercises but Im stuck...haha
06:40:24 <Eduard_Munteanu> safinaskar-i: https://en.wikipedia.org/wiki/Hindley–Milner_type_system
06:40:35 <brainacid> applicative, of chapter 1...lets see if I can figure them out
06:40:37 <kwstas> Eduard_Munteanu: a' :: (b->c - (a->b) and b' :: c ?
06:40:57 <kwstas> Eduard_Munteanu: a' :: (b->c) -> (a->b) and b' :: c ?
06:41:48 <int-e> safinaskar-i: O(n log(n)) is possible, n being the length; keep in mind that you have to identify equal names somehow.
06:41:57 <Eduard_Munteanu> kwstas: no, (.) :: (b -> c) -> ((a -> b) -> (a -> c))
06:42:21 <Eduard_Munteanu> kwstas: knowing that a -> b -> c is by definition a -> (b -> c)
06:43:05 <Eduard_Munteanu> kwstas: so if you unify that with a' -> b', you get a' = (b -> c), b' = (a -> b) -> (a -> c)
06:43:12 <kwstas> Eduard_Munteanu: oh! yes your right. I got them the other way round
06:43:37 <khyperia> What is Microsoft's involvement in Haskell? I keep seeing links to research.microsoft.com... or is it just this simonpj person?
06:44:12 <Eduard_Munteanu> kwstas: now you can type the middle dot as (b' -> c') -> (a' -> b') -> (a' -> c')
06:44:42 <Eduard_Munteanu> kwstas: unify (a' -> b') with the right (.) and (b' -> c') with the left (.).
06:45:03 <safinaskar-i> Eduard_Munteanu: "but it will accept non-normalizing terms as well" - how this is possible? please give example. you just said "all terms it accepts can be normalized"
06:45:06 <Eduard_Munteanu> The result is a (a' -> c'), which you can expand.
06:45:12 <int-e> khyperia: microsoft research employs Simon Peyton Jones, and until recently, it also employed Simon Marlow. (Hmm, is there anybody else?)
06:46:27 <khyperia> and those are big haskell people or something? (so it's not really *microsoft* doing things, it's just individual people fiddling about?)
06:46:34 <int-e> khyperia: In any case, that's how most of the papers about ghc and a lot about Haskell's type system (and ghc's extensions) are available from there.
06:46:42 <khyperia> ah
06:47:03 <brainacid> applicative, it says i need to modify to read 2 arguments from console input
06:47:11 <Eduard_Munteanu> safinaskar-i: data Term = FromSKI SKI | App Term Term  data SKI = S | K | I
06:47:27 <brainacid> applicative, Ive tried several things of what I think I know ...lol ...
06:47:42 <kwstas> Eduard_Munteanu: Thanks a lot!!
06:47:53 <brainacid> applicative, failed on all of them
06:48:34 <int-e> khyperia: And yes, Microsoft Research should not be confused with the company that sells Windows and Office :)
06:48:37 <t7> int-e: simon marlow is gone man
06:48:38 <brainacid> applicative, got it
06:48:41 <t7> deserted us
06:48:43 <brainacid> applicative, how simple
06:48:46 <khyperia> haha, alright
06:48:52 <Eduard_Munteanu> safinaskar-i: that is, any string made of S, K and I, associated any way, is a valid SKI term
06:48:53 <int-e> t7: "until recently"
06:49:17 <t7> int-e: and microsoft research is a division of microsoft that sells office and windows
06:49:52 <safinaskar-i> Eduard_Munteanu: ok
06:50:06 <brainacid> :(
06:50:10 <brainacid> Failed...
06:50:22 <brainacid> How do I read two arguments
06:50:36 <ciaranm> what do you expect? they sold out once already!
06:50:45 <Eduard_Munteanu> safinaskar-i: now if you write a function  normalize :: Term -> Term  there are inputs for which it won't terminate.
06:50:47 <brainacid> do = [x,y] <- getArgs
06:51:01 <brainacid> how to print it is my issue now
06:51:31 <mauke> brainacid: putStr
06:51:41 <brainacid> printStrLn ("hello, " ++ [x,y] !! 0)
06:51:57 <brainacid> mauke, I want to print both arguments
06:52:08 <brainacid> it prints only one
06:52:08 <mauke> brainacid: putStr x; putStr y
06:52:20 <mauke> putStr (x ++ y)
06:52:26 <mauke> > [x,y] !! 0
06:52:28 <lambdabot>   x
06:52:31 <mauke> what did you expect to happen?
06:53:12 <brainacid> mauke
06:53:44 <brainacid> pastie.org/8386692
06:54:15 <mauke> brainacid
06:54:51 <applicative> brainacid: https://github.com/michaelt/write-yourself-a-scheme-no-compiler-errors these compile fwiw
06:56:27 <brainacid> applicative, thanks..but Im doing the exercises and it ask me to modify the code to read 2 args and print them both
06:57:43 <brainacid> mauke, Change the program so it reads two arguments from the command line,
06:57:43 <brainacid> and prints out a message using both of them.
06:58:38 <brainacid> mauke, http://pastie.org/8386704
07:01:57 <applicative> brainacid: like this? https://raw.github.com/michaelt/write-yourself-a-scheme-no-compiler-errors/master/listing2a.hs
07:03:13 <brainacid> applicative, thanks... i didn know about case
07:03:56 <applicative> brainacid: it isn't the only way, but makes sense here. note that this way I cover all the cases, so the program does not fail if it gets no arguments or one argument
07:05:42 <brainacid> applicative, so in order to work i need to write all three cases
07:05:47 <brainacid> ?
07:06:13 <brainacid> applicative, cuz I get error when compile
07:06:19 <igalic> Hello happy people o/~
07:06:25 <int80_h> Hiya
07:07:11 <brainacid> applicative, Im going to keep with the basic simple stuff...im getting frustrated...I want to know this shit so bad...ill try the WYAS48 later
07:07:14 <applicative> brainacid: no it should compile but then fail if the user gives it no args
07:07:17 <applicative> https://raw.github.com/michaelt/write-yourself-a-scheme-no-compiler-errors/master/listing2b.hs
07:07:18 <igalic> Does anyone know who's responsible for https://github.com/snoyberg/yackage ? I have an issue with that project.
07:07:38 <donri> presumably snoyman? :P
07:07:45 <int80_h> that would be my guess
07:07:53 <applicative> he's responsible for a lot of things though
07:08:07 <int80_h> his code is everywhere
07:08:13 <applicative> brainacid: which is failing to compile?
07:08:17 <brainacid> applicative, its awesome u know so much
07:08:26 <applicative> ha
07:08:38 <donri> that's because he's not pumping his brain with acid
07:08:43 <igalic> Does anyone (other than snoyman) know how to use snoyman's software?
07:08:52 <brainacid> applicative, http://pastie.org/8386738
07:08:58 <donri> igalic: why not zoidberg
07:08:59 <int80_h> I use Yesod all the time
07:09:01 <applicative> igalic: it is among the most widely used
07:09:05 <int80_h> and his conduit packages
07:09:13 <brainacid> applicative, I didnt write it all the way...thats why I asked
07:09:40 <int80_h> didn't he write attoparsec? I use that
07:09:42 <igalic> applicative: I'd really love to know how to use it. From an admin point of view. From the point of view of someone who knows *nothing* about haskell.
07:09:44 <applicative> brainacid: notice the second one i put up is the same, but doesn't use case.
07:10:01 <applicative> bos wrote attoparsec!!
07:10:08 <int80_h> oooh oops
07:10:13 <int80_h> right
07:10:14 <igalic> Oh, wow. OrangeDuck is in this channel. That explains libCello much better now.
07:10:16 <brainacid> applicative, I like the approach of getting down with coding in order to learn but I get frustrated cuz i dont know..lol...im such a baby
07:10:25 <brainacid> applicative, yes i noticed
07:10:49 <brainacid> applicative, there is a lot to learn...only started 3 days ago....never programmed before
07:10:54 <applicative> but I am still distinguishing cases
07:11:50 <donri> igalic: does this help? http://www.yesodweb.com/blog/2010/12/announcing-yackage
07:12:33 <int80_h> brainacid: stick with it. It's worth it.
07:12:36 <donri> igalic: these days another option is running a hackage-server mirror, but probably overkill for a lot of situations
07:12:54 <int80_h> brainacid: Let me show you what I'm woring on. Wouldn't have bothered if not for haskell
07:12:59 <brainacid> int80_h, I will. I know. I want it. I need it for my sanity
07:13:30 <int80_h> https://github.com/mlitchard/emporos
07:13:31 <applicative> igalic: is the trouble that you can't compile it?
07:13:31 <brainacid> int80_h, Ok, show me.
07:14:10 <igalic> donri: we need an internal hackage server for our own stuff.
07:14:13 <int80_h> I'm learning baout profiling now. It compelled me to upgrade ghc and cabal. I just scrapped haskell-platform and am re-installing everything. whew
07:14:23 <brainacid> int80_h, looks cool. Honestly most of it I dont know what it is.
07:14:42 <igalic> applicative: I have no idea what the problem is -- yet. I just like to complain about lack of official documentation.
07:15:10 <brainacid> int80_h, Nice! I did a fresh install of Ubuntu 2 days ago
07:15:12 <applicative> oh, the blog post is evidently the official documentation
07:16:47 <applicative> hah, remote-repo: yackage:http:localhost:3500/ is a clever non-hack
07:17:29 <brainacid> int80_h, Good luck and hope all works out
07:18:49 <int80_h> brainacid: I've got a good start. weird space problems. That's what I need profiling for
07:21:01 <Sculptor> hello
07:21:07 <int80_h> hiya
07:23:22 <brainacid> int80_h, I will eventually know what that means..lol
07:24:57 * hackagebot hjsmin 0.1.4.2 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.1.4.2 (AlanZimmerman)
07:30:46 <igalic> It's funny how quickly I go from complaining about the lack of documentation to deciding: I need to write a puppet package provider for cabal.
07:35:47 <igalic> apples: to answer your question, yes, there is trouble with compiling: http://apaste.info/6lwv
07:35:52 <igalic> hrm.. no.
07:36:12 <igalic> That was supposed to goto applicative, who left.
07:36:30 <ciaranm> goto requires a monad, not an applicative
07:43:14 <danilo2> Hello! Can I write in cabal configuration to which subdirectory the executable should be put? Lets say the cabal config describes "a" executable. It is normally built to a XXX/dist/bin folder and I want it to be put inside XXX/dist/bin/tools instead?
07:43:50 <dcoutts> danilo2: yes, all the cabal configure flags can be put in a config file
07:43:56 <anothernewhaskel> Why is the type of Nothing Maybe a? I thought the type of Maybe a was Nothing | Just a ?
07:43:56 <brainacid> I quit
07:44:12 <mauke> anothernewhaskel: no, Maybe a doesn't have a type. it is a type.
07:44:36 <brainacid> I have to find another hobby, there is too much to learn and I dont want to wait
07:44:44 <dcoutts> danilo2: see cabal configure --help
07:44:53 <brainacid> sorry if u feel like I wasted ur time
07:44:59 <int80_h> how ca I tell if cabal is installing profiled libraries
07:45:00 <Eduard_Munteanu> anothernewhaskel: Nothing :: Maybe a   Just :: a -> Maybe a
07:45:02 <brainacid> Thanks for all the help
07:45:13 <brainacid> Good luck to all with your projects
07:45:20 <FreeFull> anothernewhaskel: Nothing is like [] but for Maybe
07:45:23 <FreeFull> :t []
07:45:24 <lambdabot> [a]
07:45:37 <igalic> Okay, so compiling yackage fails, and I don't quite see exactly why at first glance: http://apaste.info/6lwv
07:46:26 <anothernewhaskel> :t Just 5
07:46:27 <lambdabot> Num a => Maybe a
07:46:37 <anothernewhaskel> what does that => mean again?
07:46:38 <danilo2> dcoutts: Ok, thank you - I've looked at cabal configure --help and there is an option "--bindir=" but I want to specify a bin SUBdirectory (like --libsubdir), but there is no --binsubdir :(
07:46:52 <Eduard_Munteanu> Uh oh... if we ever get disappointed by yackage, we might start calling it yuckage.
07:47:17 <dcoutts> danilo2: or see the user guide for more info, those path flags can contain vars like $prefix, so it's possible to make them relative
07:47:55 <danilo2> dcoutts: Ok, nice to hear that :) I'm searching for it :) thank you :)
07:48:18 <anothernewhaskel> @Eduard_Munteanu ?
07:48:18 <lambdabot> Unknown command, try @list
07:48:18 <dcoutts> danilo2: e.g. the default is --bindir='$prefix/bin'
07:48:56 <Eduard_Munteanu> anothernewhaskel: => has class constraints to its left and a type to its right. Foo a => <some type involving a>  means 'give any type "a" that's an instance of Foo, this thing has type <something involving a>"
07:49:58 <anothernewhaskel> Oh right, so Just 5 has the type Maybe a constrained by Num?
07:50:13 <Eduard_Munteanu> anothernewhaskel: look at '5' first...
07:50:14 <Eduard_Munteanu> :t 5
07:50:15 <lambdabot> Num a => a
07:50:35 <danilo2> dcoutts: thank you very much for this information! :)
07:50:35 <Eduard_Munteanu> anothernewhaskel: Haskell number literals are polymorphic
07:50:53 <anothernewhaskel> Eh?
07:51:01 <anothernewhaskel> How can 5 be anything other than a subclass of Num
07:51:01 <Eduard_Munteanu> anothernewhaskel: so '5' can be any type as long as it's an instance of Num.
07:51:08 <anothernewhaskel> subtype even
07:51:17 <anothernewhaskel> right ok
07:51:21 <Eduard_Munteanu> anothernewhaskel: it's not a subclass or a subtype, it's an instance of Num
07:51:21 <anothernewhaskel> thats fine
07:51:39 <anothernewhaskel> and being an instance of num it can also be an instance of float
07:52:02 <Eduard_Munteanu> anothernewhaskel: it only needs to be an instance of Num, everything else is irrelevant
07:52:20 <anothernewhaskel> yea
07:52:39 <anothernewhaskel> So the left side constrains a to be an instance of Num
07:52:49 <Eduard_Munteanu> anothernewhaskel: yeah
07:52:50 <anothernewhaskel> So if I had Num Eq a => a
07:52:55 <anothernewhaskel> then it has to be an instance of num and eq
07:53:02 <FreeFull> It'd be (Num a, Eq a) => a
07:53:05 <FreeFull> But yes
07:53:06 <anothernewhaskel> yea sorry
07:53:15 <igalic> I found the issue why yackage doesn't compile: http://apaste.info/15R2
07:53:15 <FreeFull> :t 3 == 3
07:53:18 <lambdabot> Bool
07:53:26 <danharaj> :t \x -> x == 3
07:53:27 <lambdabot> (Eq a, Num a) => a -> Bool
07:53:42 <FreeFull> Hmm
07:53:56 <int80_h> cabal is saying not to use -prof
07:54:25 <int80_h> so is it enough I use executable-profiling, and library-profiling in my cabal config?
07:54:29 <anothernewhaskel> danharaj: so that says that that expression is of type Bool, takes a type a constrained by Eq and Num
07:54:50 <danharaj> I am not sure I understand the assertion.
07:54:52 <Eduard_Munteanu> anothernewhaskel: takes a value of type 'a', where 'a' is a type in Num and Eq.
07:55:01 <anothernewhaskel> yea
07:55:32 <anothernewhaskel> okii
07:55:38 <dcoutts> int80_h: yes. And then for packages where you want cost centers (e.g. the ones you're interested in when profiling) you'll want to build them with --ghc-options=-fauto-all or similar
07:55:41 <anothernewhaskel> im trying to understand kinds and functors atm
07:55:49 <anothernewhaskel> this is getting rather complex
07:56:13 <Eduard_Munteanu> anothernewhaskel: if you turned on ExplicitForall (or other extensions), you can write   forall a. (Eq a, Num a) => a -> Bool  which makes that '=>' more like an arrow at the kind-level
07:56:40 <anothernewhaskel> Eduard_Munteanu: ??????
07:56:41 <anothernewhaskel> wat
07:56:59 <int80_h> dcoutts: where is the data that profiling generates?
07:57:30 <dcoutts> int80_h: take a look at the ghc users guide section on profiling for how to run the program
07:57:47 <dcoutts> the various +RTS flags to select which kind of profiling to do
07:57:47 <int80_h> ah thanks, I was looking at the wiki. seems a bit outdated
07:57:49 <Eduard_Munteanu> anothernewhaskel: I thought the forall would make more sense of '=>' for you.
07:58:05 <anothernewhaskel> Eduard_Munteanu: er..nope
07:58:06 <quchen_> Eduard_Munteanu: Sounds like he's LYAH level, so probably no.
07:58:11 * anothernewhaskel looks up forall
07:58:25 <anothernewhaskel> quchen_: im literally just looking at the types and typeclasses page on lyah
07:58:33 <anothernewhaskel> on functors and kinds bit
07:58:40 <quchen_> Welcome to the rabbit hole. Excep that this one is deeper and richer.
07:58:52 <anothernewhaskel> :p
07:59:39 <Eduard_Munteanu> anothernewhaskel: forall introduces type variables and it's normally implicit (in most places)
08:00:30 <quchen_> I'd keep the "kind" chapter in the back of my head, and remember that to be a Functor your type has to take exactly one type argument. For example `Int` cannot be a Functor because it takes none, `Either` takes two. `Maybe Int` also takes none, therefore it can't be a Functor. `Maybe` on the other hand works. And `Either a` too.
08:00:52 <anothernewhaskel> "forall a."
08:00:58 <anothernewhaskel> that a. is composition?
08:00:58 <anothernewhaskel> or no
08:01:20 <anothernewhaskel> quchen_: so head is a functor
08:01:21 <danilo2> dcoutts: I'm sorry, maybe my question could be unclear - I was asking about cabal package configuratuon. If I'm trying to use "bindir" in package configurtation I'm getting error: Unknown fields: bindir (line 9) Fields allowed in this section ...
08:01:47 <dcoutts> danilo2: take a look at a standard cabal config file for an example
08:01:48 <quchen_> anothernewhaskel: head is a function. That's something different.
08:01:55 <int80_h> dcoutts: I'm getting an error that -fauto-all is an unrecognized flag
08:01:58 <dcoutts> danilo2: those fields live in a sub-section
08:02:06 <anothernewhaskel> quchen_: oh sorry yes
08:02:07 <dcoutts> int80_h: oh my bad memory, see the user guide
08:02:10 <anothernewhaskel> quchen_: functors are about types
08:02:17 <anothernewhaskel> quchen_: functions are just functions
08:02:18 <int80_h> prof-auto I think
08:02:19 <quchen_> anothernewhaskel: "head is a Functor" would mean there exists "instance Functor head where" which doesn't make any sense.
08:02:25 <dcoutts> int80_h: there's a whole chapter on profiling
08:02:27 <Eduard_Munteanu> ExplicitForall + KindSignatures make polymorphism _look_ more functional, e.g. forall (a :: *). Eq a => a -> a -> Bool   means  "for all types 'a' of kind * that are instances of Eq, make the type 'a -> a -> Bool'"
08:02:52 <int80_h> dcoutts: prof-auto was it :)
08:03:32 <anothernewhaskel> what
08:03:39 <anothernewhaskel> how can a type be "a -> a -> Bool"
08:03:43 <anothernewhaskel> thats a function signature no?
08:04:12 <Eduard_Munteanu> anothernewhaskel: hm? Any functions signature has a name followed by '::' then a type.
08:04:32 <danilo2> dcoutts: I was trying almost everything :( I was putting it in "executable" section or trying to add there a "install-dirs user" section, but in the first try it tells the field is not allowed in the second this section is not allowed.
08:04:36 <anothernewhaskel> Eduard_Munteanu: wait wait wait
08:04:37 <Eduard_Munteanu> Any function or value has a type, for that matter.
08:04:55 <danilo2> dcoutts: Of course i'm nat toalking about cabal configuration, but about package configuration
08:05:03 <quchen_> anothernewhaskel: `a -> b` is a type just like `Int` or `Maybe a` are.
08:05:06 <anothernewhaskel> Eduard_Munteanu: so if my type is of type "a -> a -> Bool" that means it's an instance of Bool that takes 2 parameters of a in its constructor?
08:05:25 <dcoutts> danilo2: it's important to keep the distinction clear. blah.cabal files are not cabal config files, those are package descriptions.
08:05:28 <quchen_> Types don't have types, types have kinds.
08:05:31 <Eduard_Munteanu> anothernewhaskel: no, (->) involves only types.
08:05:52 <dcoutts> danilo2: bindir etc live in a cabal config file, like your default one in ~/.cabal/config
08:05:59 <Eduard_Munteanu> @kind (->)
08:05:59 <lambdabot> * -> * -> *
08:06:17 <danilo2> dcoutts: I'm sorry - I'm talkicg about package descriptor - I want to tell there that my executables go to a bin subdirectory - I do not want to change my "home" cabal settings
08:06:26 <anothernewhaskel> that takes 2 concrete types and spits out a concrete type
08:06:28 <anothernewhaskel> right?
08:06:30 <quchen_> I would still say this is way beyond LYAH level.
08:06:35 <Eduard_Munteanu> anothernewhaskel: yes
08:06:40 <dcoutts> danilo2: those settings do not live in the package description.
08:06:42 <anothernewhaskel> quchen_: this stuff is in lyah
08:06:53 <anothernewhaskel> quchen_: i feel this is gonna be useful later on
08:06:54 <dcoutts> danilo2: you cannot set the prefix/bindir etc from the package description.
08:07:35 <t7> @kind (->) (->)
08:07:36 <lambdabot>     Expecting two more arguments to `(->)'
08:07:36 <lambdabot>     In a type in a GHCi command: (->) (->)
08:07:39 <danilo2> dcoutts: Ok, so If I've got for example a sandbox and I'm installing a lot of things in it and there are some packages which provide binaries with the same name, how can I handle it?
08:08:19 <dcoutts> danilo2: depends how you want to handle it, you can easily set the bindir to be different for each package
08:08:19 <t7> @kind (Int -> Int) (->)
08:08:20 <lambdabot>     `Int -> Int' is applied to too many type arguments
08:08:22 <lambdabot>     In a type in a GHCi command: (Int -> Int) (->)
08:08:40 <dcoutts> danilo2: or you can set a prefix/suffix on the exe names
08:08:49 <Eduard_Munteanu> anothernewhaskel: and concrete types are exactly those which have inhabitants (functions or values), so any toplevel or let-bound declaration like   foo :: T   requires  T :: *
08:08:54 <danilo2> dcoutts: You're talking about commandl ine arguments to cabal while installing these packages?
08:09:11 <dcoutts> danilo2: command line args or entries in the cabal config file
08:09:34 <dcoutts> danilo2: remember: you can use an alternate cabal config file. You do not need to use the user's default one.
08:09:44 <Eduard_Munteanu> anothernewhaskel: in other words, you can't make values for a * -> * type.
08:10:16 <anothernewhaskel> let a = Nothing
08:10:18 <anothernewhaskel> :t Nothing
08:10:19 <lambdabot> Maybe a
08:10:21 <anothernewhaskel> :k Maybe
08:10:22 <lambdabot> * -> *
08:10:26 <danilo2> dcoutts: I knwo I can create cabal.config next to my cabal.sandbox.config, but is it possible to write there rules ,which will tell that binaries from packages A and B gos to X and from C and D goes to Y?
08:10:27 <anothernewhaskel> ...
08:10:36 <anothernewhaskel> I just did Eduard_Munteanu
08:11:06 <dcoutts> danilo2: no, if you want fine grained control like that then there isn't a single set of settings that will work for them all.
08:11:25 <ana_> @pl \a p x -> ((1-a)*p) + (a * x)
08:11:27 <quchen_> anothernewhaskel: Nothing has type "Maybe a", and "Maybe a" has kind "*". You cannot make a value with type "Maybe", that's what Eduard_Munteanu meant.
08:11:29 <lambdabot> ap (flip . ((.) .) . ((+) .) . (*) . (-) 1) (*)
08:11:29 <lambdabot> optimization suspended, use @pl-resume to continue.
08:11:43 <dcoutts> danilo2: if you just want to use a bindir that includes the package id, then that's doable. But putting some here and some there, well you just need to invoke it with the settings appropriate for each one.
08:12:14 <anothernewhaskel> quchen_: how do I find the kind of Maybe a?
08:12:29 <anothernewhaskel> quchen_: or is it implicit given that the kind of Maybe is * -> *
08:12:35 <anothernewhaskel> so a takes away one of the *
08:12:48 <danilo2> dcoutts: Ok, thank you :) Do you know if such option in package descriptor will be weveravailable? I think it would be very usefull :)
08:12:59 <quchen_> :k (forall a. Maybe a)
08:13:01 <lambdabot> *
08:13:21 <quchen_> anothernewhaskel: Yes, each parameter takes away a "*".
08:13:23 <dcoutts> danilo2: no. It is deliberate that the person building the package, not the person writing the package gets to decide where the thing will be installed.
08:13:33 <anothernewhaskel> quchen_: How do I do that without forall?
08:13:51 <danilo2> dcoutts: Ok, that makes perfect sense now :)
08:13:57 <dcoutts> danilo2: and note that you can also use local cabal config files with the latest version, so that gives you a similar amount of flexibility.
08:14:09 <quchen_> anothernewhaskel: You'll have to ask for a specific version of `Maybe a`, e.g. by inserting an `Int`.
08:14:12 <quchen_> :k Maybe Int
08:14:13 <lambdabot> *
08:14:24 <quchen_> :k Maybe (Maybe (String, Int))
08:14:25 <lambdabot> *
08:14:34 <anothernewhaskel> :k Maybe Nothing
08:14:35 <lambdabot>     Not in scope: type constructor or class `Nothing'
08:14:35 <lambdabot>     A data constructor of that name is in scope; did you mean -XDataKinds?
08:14:40 <anothernewhaskel> ..?
08:14:44 <danharaj> :k Maybe
08:14:45 <quchen_> Nothing is a value, not a type. Values don't have kinds.
08:14:45 <lambdabot> * -> *
08:14:48 <danharaj> :t Nothing
08:14:48 <lambdabot> Maybe a
08:15:01 <danharaj> :k Maybe Int
08:15:01 <lambdabot> *
08:15:01 * hackagebot hjsmin 0.1.4.3 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.1.4.3 (AlanZimmerman)
08:15:03 * hackagebot mysql-simple-quasi 1.0.0.0 - Quasi-quoter for use with mysql-simple.  http://hackage.haskell.org/package/mysql-simple-quasi-1.0.0.0 (NeilBrown)
08:15:05 <quchen_> data Maybe a = Nothing | Maybe a
08:15:07 <danharaj> :k Maybe (Maybe Int)
08:15:08 <lambdabot> *
08:15:11 <quchen_> Eh sorry
08:15:14 <quchen_> data Maybe a = Nothing | Just a
08:15:25 <danharaj> :k Nothing
08:15:26 <lambdabot>     Not in scope: type constructor or class `Nothing'
08:15:26 <lambdabot>     A data constructor of that name is in scope; did you mean -XDataKinds?
08:15:41 * anothernewhaskel pokes Jeanne-Kamikaze with a wet fish
08:16:27 <Connorcpu> Wouldn't it just be faster to hoogle Maybe than poke the bot for information? :P
08:17:13 <anothernewhaskel> > data Maybe a = Nothing | Maybe a
08:17:14 <lambdabot>   <hint>:1:1: parse error on input `data'
08:17:19 <quchen_> data Maybe a = Nothing | Just a
08:17:21 <anothernewhaskel> > data Maybe a = Nothing | JKust a
08:17:22 <lambdabot>   <hint>:1:1: parse error on input `data'
08:17:25 <anothernewhaskel> > data Maybe a = Nothing | Just a
08:17:26 <lambdabot>   <hint>:1:1: parse error on input `data'
08:17:30 <anothernewhaskel> O.o
08:17:39 <anothernewhaskel> that works on ghci
08:17:43 <anothernewhaskel> why not here
08:17:47 <quchen_> Lambdabot isn't GHCi.
08:17:50 <merijn> anothernewhaskel: lambdabot is not ghci
08:18:00 <quchen_> She's a sentient being. Be kind.
08:18:08 <quchen_> @botsnack
08:18:08 <lambdabot> :)
08:18:08 <Connorcpu> ^
08:18:19 <Iceland_jack> quchen_: That doesn't work in my GHCi!
08:18:30 <Iceland_jack> Prelude> @botsnack
08:18:31 <Iceland_jack> <interactive>:2:1: parse error on input `@'
08:18:40 <quchen_> Upgrade to HEAD ;-)
08:18:51 <mauke> goa
08:18:51 <anothernewhaskel> Iceland_jack: lol
08:19:08 <Iceland_jack> Lack of "@botsnack" is the reason Haskell will never become mainstream
08:19:42 <anothernewhaskel> Iceland_jack: definitely
08:19:51 <mauke> preflex: botsnack
08:19:51 <preflex>  ☺
08:20:00 <anothernewhaskel> O.o
08:20:05 <anothernewhaskel> is preflex a bot?
08:20:23 <donri> preflex: are you a bot?
08:20:23 <preflex>  yes.
08:20:28 <donri> guess so.
08:20:30 <anothernewhaskel> :D
08:20:35 <anothernewhaskel> it could be lying
08:20:37 <Connorcpu> Nah, preflex just has one of those fancy virtual keyboards with an extended emoji section :P
08:20:38 <anothernewhaskel> o:
08:20:41 <quicksilver> @let data Maybe a = Nothing | Just a
08:20:42 <lambdabot>  Defined.
08:20:50 <Iceland_jack> > Nothing
08:20:51 <lambdabot>   Ambiguous occurrence `Nothing'
08:20:51 <lambdabot>  It could refer to either `L.Nothing', defin...
08:20:53 <Iceland_jack> >:|
08:20:59 * quicksilver nods
08:21:10 <anothernewhaskel> Iceland_jack: :S how on earth would that work
08:21:20 <quchen_> @undef
08:21:20 <lambdabot> Undefined.
08:21:23 <Iceland_jack> Would what work?
08:21:23 <quchen_> > Nothing
08:21:24 <lambdabot>   Nothing
08:21:25 <jonkri> How should I "commit" with acid-state (so that a Query that happens after my Update will necessarily reflect the update)? createCheckpoint?
08:21:25 <anothernewhaskel> that's like me putting '5' into a python console
08:21:31 <quchen_> > 5
08:21:32 <lambdabot>   5
08:21:36 <anothernewhaskel> look here
08:21:46 <anothernewhaskel> I didnt ask for smart things
08:21:53 <anothernewhaskel> :p
08:21:58 <anothernewhaskel> in that case
08:22:02 <anothernewhaskel> why does > Nothing error
08:22:07 <quchen_> > Nothing
08:22:08 <lambdabot>   Nothing
08:22:11 <anothernewhaskel> O.O
08:22:12 <Iceland_jack> > Nothing -- it does?
08:22:14 <donri> jonkri: once an update returns it should be durable
08:22:14 <lambdabot>   Nothing
08:22:23 <anothernewhaskel> <Iceland_jack> > Nothing [16:16] <lambdabot>   Ambiguous occurrence `Nothing' [16:16] <lambdabot>  It could refer to either `L.Nothing', defin...
08:22:24 <Iceland_jack> anothernewhaskel: Because quicksilver re-defined it
08:22:27 <anothernewhaskel> oh lol
08:22:35 <quicksilver> anothernewhaskel: it only errored because I was showing how you could define data types in it
08:22:46 <quicksilver> but if you define a data type using the same constructor names as a standard one...
08:22:50 <Connorcpu> jonkri: you should createAndCloseCheckpoint in your bracket operation, as long as you're in some kind of monadio updates will propogate and be saved.
08:22:54 <quchen_> @let data Maybe' a = Nothing' | Just' a
08:22:55 <lambdabot>  Defined.
08:23:01 <quchen_> :t Nothing'
08:23:02 <lambdabot> Maybe' a
08:23:04 <quchen_> :-)
08:23:16 <anothernewhaskel> Quickly, redefine all the standard haskell types
08:23:16 <anothernewhaskel> at 3am
08:23:32 <geekosaur> it will depend on whether extended default rules are active or not; if they are, ghc will infer Maybe () as the type and succeed, if they aren't then it's an ambiguous type per Haskell repiort
08:23:33 <anothernewhaskel> Nobody will be able to use the bot ever again and will never notice what's wrong
08:23:36 <Connorcpu> or whatever
08:23:41 <Connorcpu> I just woke up x3
08:23:41 <quchen_> @undef
08:23:41 <lambdabot> Undefined.
08:23:43 <quchen_> Fixed it.
08:23:49 <anothernewhaskel> nope
08:23:51 <quchen_> :t Nothing'
08:23:52 <lambdabot>     Not in scope: data constructor Nothing'
08:23:53 <lambdabot>     Perhaps you meant `Nothing' (imported from Data.Maybe)
08:23:54 <anothernewhaskel> never be able to fix
08:23:56 <quchen_> Yope
08:23:57 <anothernewhaskel> never ever
08:24:33 <Connorcpu> jonkri: http://puu.sh/4KQ7q.png here's how I do it :P
08:25:34 <Connorcpu> and now I must go
08:26:59 <anothernewhaskel> data Barry t k p = Barry { yabba :: p, dabba :: t k }
08:27:07 <anothernewhaskel> how can we assume k has kind *
08:27:49 <Iceland_jack> because you didn't specify a different kind
08:28:11 <anothernewhaskel> but why isnt k of kind * -> *
08:28:14 <anothernewhaskel> and t of kind *
08:28:33 <Iceland_jack> because of (t k)
08:28:37 <Iceland_jack> where t is applied to k
08:28:51 <anothernewhaskel> ?
08:29:13 <anothernewhaskel> sorry Im confused
08:29:18 <Iceland_jack> If you have a function applicatio (f x) in Haskell, you can assume that (f :: a -> b) and (x :: a) right?
08:29:26 <Iceland_jack> *application
08:29:32 <anothernewhaskel> sure
08:29:57 <donri> not the best analogy though because kinds are not polymorphic by default
08:30:08 <Iceland_jack> so when you have a type (t) applied to another type (k) in 't k' you can assume that (t :: * -> *) and (k :: *)
08:30:27 <quicksilver> anothernewhaskel: when you say "how can you assume" that's a completely reasonable question
08:30:37 <quicksilver> there is no reason why you *should* assume that
08:30:39 <quicksilver> except
08:30:40 <Iceland_jack> anothernewhaskel: http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/kind-polymorphism-and-promotion.html
08:30:41 <quicksilver> that's how haskell works.
08:30:47 <jonkri> donri, Connorcpu: Thanks. I'm glad to hear that it "[update operation] >> [query operation]" should work in like IO. For some reason it doesn't seem to work in ServerPartT IO though.
08:30:52 <quicksilver> kinds are, by default, assumed to be the simplest possible.
08:31:02 <Iceland_jack> what quicksilver said
08:31:03 <quicksilver> I.e. they are assumed to be * unless they are used in a way which makes that impossible.
08:31:05 <donri> jonkri: serverparts are threaded
08:31:06 <anothernewhaskel> Iceland_jack: nope that still doesnt make sense sorry
08:31:16 <Iceland_jack> anothernewhaskel: Do you know what kinds are?
08:31:51 <Iceland_jack> Do you understand why:
08:31:51 <Iceland_jack>     data Foo x = ...
08:31:52 <Iceland_jack> has kind (* -> *)?
08:31:53 <donri> jonkri: is this in a single serverpart, or between requests?
08:31:56 <jonkri> donri: Ah, I guess I can liftIO the operation and have them run that way then.
08:32:00 <jonkri> It's a single one.
08:32:15 <donri> jonkri: wait, what were you doing that wasn't using liftIO?
08:32:23 <jonkri> s/the operation/the operations
08:32:30 <anothernewhaskel> Iceland_jack: because you have a concrete type Foo and will get another concrete type?
08:32:34 <jonkri> donri: I was using query' and update', which I guess are lifted separately.
08:33:05 <donri> jonkri: uh i think it's a law that liftIO a >> liftIO b = liftIO (a >> b)
08:33:23 <Iceland_jack> anothernewhaskel: Foo is not a concrete type
08:33:26 <donri> and it certainly should work with update' >> query'
08:33:40 <Iceland_jack> From LYAH which you are covering:
08:33:41 <Iceland_jack>     When I talk about concrete types I mean like fully applied types like Map Int String or if we're dealin' with one of them polymorphic functions, [a] or (Ord a) => Maybe a and stuff.
08:34:10 <anothernewhaskel> ok
08:34:12 <Iceland_jack> So 'Maybe' is not a type, but a type constructor: 'Maybe Int' is (concrete) type though
08:34:14 <donri> jonkri: you're calling those, during the same request cycle? not separate requests, not scheduleUpdate or so?
08:34:18 <anothernewhaskel> Iceland_jack: yes i get that
08:34:25 <Iceland_jack> So you can how Maybe is like a function right?
08:34:39 <anothernewhaskel> Iceland_jack: yea
08:34:43 <Iceland_jack> But not a function on values, but on the type-level
08:34:53 <anothernewhaskel> right
08:35:10 <Iceland_jack> that's why its kind is (* -> *), because it takes one type and returns a type
08:35:15 <anothernewhaskel> yes
08:35:36 <Iceland_jack> In your case, you're using one of the arguments to Barry as a function
08:36:50 <anothernewhaskel> Iceland_jack: two of the arguments
08:36:51 <anothernewhaskel> right?
08:36:54 <osa1> let's say I wrote a lexer in Parsec and using tokens generated by that in again another Parsec parser. giving that we have lazy evaluation etc. does that mean token generation done lazily and generated only when parser needs?
08:36:56 <anothernewhaskel> t and p
08:37:01 <Iceland_jack> anothernewhaskel: Only one of the arguments is a function
08:37:36 <Iceland_jack> 'p' is just a concrete type
08:37:43 <Iceland_jack> (or Haskell *assumes* that it is anyway!)
08:37:59 <anothernewhaskel> Iceland_jack: ok let me ask you something else
08:38:02 <anothernewhaskel> data Barry t k p = Barry { yabba :: p, dabba :: t k }
08:38:06 <anothernewhaskel> what does yabba :: p mean
08:38:08 <anothernewhaskel> in there
08:38:14 <Iceland_jack> Are you familiar with record syntax?
08:38:19 <anothernewhaskel> er
08:38:28 <Iceland_jack>     data Person = Person { age :: Int, name :: String }
08:38:28 <anothernewhaskel> i dont think so
08:38:32 <Iceland_jack> Does that make sense?
08:38:42 <anothernewhaskel> oh
08:38:48 <anothernewhaskel> yes that makes sense
08:39:07 <Iceland_jack> It's the same as writing:
08:39:07 <Iceland_jack>     data Person = Person Int String
08:39:07 <Iceland_jack>     age  (Person n _  ) = n
08:39:07 <Iceland_jack>     name (Person _ str) = str
08:39:07 <anothernewhaskel> lyah kinda sneakily introduced it whilst im trhying to learn about kinds lol
08:39:18 <jonkri> donri: The codes looks something like this: dir "test" $ update' acid AcidUpdate >>= \mbT -> case mbT of Just t -> query' acid AcidQuery >> (toResponse <$> ...); Nothing -> (toResponse <$> ...)
08:39:23 <Iceland_jack> The cover it earlier in the chapter anothernewhaskel :)
08:39:27 <Iceland_jack> *they
08:39:34 <anothernewhaskel> Iceland_jack: bah my fault then
08:39:38 <anothernewhaskel> uhm
08:40:13 <anothernewhaskel>  data Person = Person { age :: Int, name :: String } is defining a record typeclass?
08:40:17 <Iceland_jack> Not a type class
08:40:20 <Iceland_jack> a record datatype
08:40:25 <Iceland_jack> To be honest you don't need to concern yourself *too* much with kinds, but it's nice to know
08:40:27 <anothernewhaskel> ok
08:40:33 <Iceland_jack> *data type
08:40:45 <anothernewhaskel>  data Person = Person Int String [16:35] <Iceland_jack>     age  (Person n _  ) = n [16:35] <Iceland_jack>     name (Person _ str) = str makes a lot less sense
08:40:53 <Iceland_jack> hm?
08:40:54 <donri> jonkri: that should work, assuming AcidQuery reads something that AcidUpdate wrote
08:40:54 <anothernewhaskel> than the other way
08:41:04 <anothernewhaskel> that 2nd way you wrote it makes less sense
08:41:05 <Iceland_jack> I don't understand what you mean
08:41:10 <toothbrush0> Hi all, quick question: any ideas how to replace UTF8 characters in a string with sensible ASCII substitutions? (i.e. emdash => '-', '“' => '\"')
08:41:49 <merijn> toothbrush0: I don't think there's a default way to do that, other than a manually coded conversion table
08:42:00 <anothernewhaskel> Iceland_jack: in the 2nd version you've got some extra variables str and n
08:42:15 <Iceland_jack> anothernewhaskel: No extra variables
08:42:21 <toothbrush0> merijn: ugh, thanks! I've been looking around, and am afraid you might be right...
08:42:22 <Iceland_jack> just pattern matching on the data type
08:42:41 <Iceland_jack> Creating accessor functions (which records create for you)
08:42:49 <anothernewhaskel> oh#
08:42:52 <anothernewhaskel> oh i see
08:43:14 <anothernewhaskel> so that says if I make a Person(_, "asd") then it will assign "asd" to the name
08:43:18 <anothernewhaskel> and vice versa
08:43:28 <Iceland_jack> eh.. no
08:43:39 <Iceland_jack> I'm not sure where the tuple is coming from
08:43:45 <jonkri> donri: It does read what update wrote. And when I refresh the page and tried a second time it went away (even though the functions would do the exact same things). So... Strange! But thanks!
08:43:45 <anothernewhaskel> er
08:43:50 <anothernewhaskel> it wasnt any sort of syntax
08:43:54 <donri> jonkri: :)
08:43:58 <Iceland_jack> @let data Person = Person { age :: Int, name :: String }
08:44:00 <lambdabot>  Defined.
08:44:09 <HugoDaniel> im trying to do a binding of a c lib to haskell, but i dont know what type to use for a FILE*, anyone knows ?
08:44:12 <Iceland_jack> > let (Person age name) = Person 42 "Sally" in age
08:44:14 <lambdabot>   42
08:44:28 <Iceland_jack> > let pers = Person 42 "Sally" in age pers
08:44:36 <lambdabot>   mueval-core: Time limit exceeded
08:44:44 <anothernewhaskel> O.o
08:44:57 <Iceland_jack> > let pers = Person 42 "Sally" in name pers
08:45:00 <lambdabot>   "Sally"
08:45:19 <geekosaur> HugoDaniel, you can't use stdio filehandles from Haskell anyway, so you would treat the C side as a (void *) and the Haskell side as (Ptr ())
08:45:30 <anothernewhaskel> > let (Person age name) = Person 42 "Sally" in name
08:45:31 <lambdabot>   "Sally"
08:45:37 <Iceland_jack> anothernewhaskel: Do review the chapter on “Record syntax”
08:45:40 <Iceland_jack> or subsection
08:45:49 <anothernewhaskel> i think tahts a good idea
08:45:52 <anothernewhaskel> :D
08:45:53 <Iceland_jack> :)
08:46:10 <solarus> > let (Person { age = age }) = Person 22 "foo" in age
08:46:11 <lambdabot>   22
08:46:30 <solarus> dont write code like that though :)
08:46:47 <anothernewhaskel> wtf
08:46:51 <anothernewhaskel> solarus: wat
08:46:57 <donri> HugoDaniel: there's fdToHandle in unix
08:46:57 <joelteon> > let Person { age = age } = Person 22 "foo" in age
08:46:59 <lambdabot>   22
08:47:04 <joelteon> no parentheses necessary!
08:47:12 <HugoDaniel> donri: thank you
08:47:21 <anothernewhaskel> where does "foo" go
08:47:22 <anothernewhaskel> into the darkness?
08:47:26 <donri> HugoDaniel: http://hackage.haskell.org/package/unix-2.6.0.1/docs/System-Posix-IO-ByteString.html#g:10
08:47:34 <Iceland_jack> anothernewhaskel: Review the book ;)
08:47:46 <Iceland_jack> (Person 23 "foo") creates a value of type Person
08:47:53 <Iceland_jack> :t Person
08:47:53 <lambdabot> Int -> String -> Person
08:47:54 <Iceland_jack> :t Person 23
08:47:55 <lambdabot> String -> Person
08:47:56 <Iceland_jack> :t Person 23 "foo"
08:47:56 <anothernewhaskel> > let Person { age = age } = Person 22 "foo" in name
08:47:57 <lambdabot> Person
08:47:57 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable L.Person)
08:47:58 <lambdabot>    arising from ...
08:48:12 <anothernewhaskel> > let Person { name = name } = Person 22 "foo" in name
08:48:12 <lambdabot>   "foo"
08:48:21 <anothernewhaskel> i er
08:48:41 <Iceland_jack> > let Person a b = Person 22 "foo" in printf "%s is called %d" b a :: String
08:48:44 <geekosaur> donri: but mixing raw I/O and filehandle I/O is risky (whether in C or Haskell or ...) --- and much worse if both sides are using handle abstractions as they don't know about each other and buffering will cause bizarreness
08:48:45 <lambdabot>   "foo is called 22"
08:48:49 <Iceland_jack> oops!
08:48:57 <donri> geekosaur: i bet
08:48:59 <Iceland_jack> > let Person a b = Person 22 "foo" in printf "%s is %d years old" b a :: String -- ;)
08:49:04 <lambdabot>   "foo is 22 years old"
08:49:54 <tac> @type printf
08:49:55 <lambdabot> PrintfType r => String -> r
08:50:58 <anothernewhaskel> when is the let Blah { asd = asd } ... format useful?
08:51:23 <Iceland_jack> anothernewhaskel: When you want to get a single value from your record
08:51:34 <safinaskar-i> what is fixed point combinator? is it "fix f = f (fix f)"? but in this case it doesn't terminate
08:51:35 <Iceland_jack> or more, by specifying the name
08:51:43 <danharaj> why doesn't it terminate?
08:52:10 <safinaskar-i> danharaj: fix f = f (fix f) = f (f (fix f)) ...
08:52:15 <Iceland_jack> you normally wouldn't use the same name for the variable as the field though
08:52:22 <Iceland_jack> shadowing the accessor function
08:53:01 <Iceland_jack> @let data Point = Point { x :: Double, y :: Double }
08:53:02 <lambdabot>  Defined.
08:53:02 <Hafydd> danharaj: because of lazy evaluation, it can terminate.
08:53:07 <Hafydd> > fix $ const "hello"
08:53:08 <lambdabot>   "hello"
08:53:13 <anothernewhaskel> > let {name) = Person 42 "Sally" in name
08:53:15 <lambdabot>   <hint>:1:10: parse error on input `)'
08:53:16 <Iceland_jack> > let Point x y = Point pi (2 * pi) in x * y
08:53:18 <danharaj> Preaching to the choir.
08:53:20 <lambdabot>   19.739208802178716
08:53:20 <anothernewhaskel> > let {name} = Person 42 "Sally" in name
08:53:21 <lambdabot>   <hint>:1:10: parse error on input `}'
08:53:27 <anothernewhaskel> > let (name) = Person 42 "Sally" in name
08:53:28 <lambdabot>   No instance for (GHC.Show.Show L.Person)
08:53:28 <lambdabot>    arising from a use of `M4421459...
08:53:29 <Hafydd> Er... safinaskar-i: ^
08:53:46 <Iceland_jack> anothernewhaskel: You may want to play around using PRIVMSG with lambdabot or in your own ghci
08:53:52 <anothernewhaskel> sorry
08:53:55 <Iceland_jack> No problem
08:54:28 <Hafydd> Or to be strict (heheh), because of non-strict semantics.
08:54:41 <danharaj> > let g = (let fix' f = f (fix' f) in fix' (\f x -> if x == 0 then 1 else x * f (x-1))) in g 6
08:54:42 <lambdabot>   720
08:54:50 <tac> Yes. The trick is to private message lambdabot, get it working, then paste your example -- having it work on the first try -- and coming off as being brilliant in the channel.
08:54:57 <anothernewhaskel> :p
08:54:58 <Iceland_jack> hah
08:55:11 <anothernewhaskel> but I'm already brilliant
08:55:11 <Iceland_jack> > 5 + 10 -- Look I'm brilliant!
08:55:13 <lambdabot>   15
08:55:15 <anothernewhaskel> I don't need to prove that
08:55:43 <donri> > let (+) = (*) in 5 + 10
08:55:44 <lambdabot>   50
08:55:55 <anothernewhaskel> lol
08:56:00 <anothernewhaskel> such a waste
08:56:02 <HugoDaniel> donri: do you know if this works on windows ?
08:56:13 <donri> HugoDaniel: probably not
08:56:21 <donri> also see geekosaur's followup comment
08:56:24 <HugoDaniel> oh :|
08:56:58 <HugoDaniel> yeah, but this is for a raw ffi binding
08:57:09 <anothernewhaskel> Iceland_jack: ok so back to data Barry t k p = Barry { yabba :: p, dabba :: t k }
08:57:15 <anothernewhaskel> p and t are concrete types
08:57:15 <Iceland_jack> sure
08:57:17 <HugoDaniel> this is the C function sig: int ub_ctx_debugout(struct ub_ctx* ctx, FILE* out);
08:57:19 <Iceland_jack> yes
08:57:31 <anothernewhaskel> k is the third argument to the Barry constructor?
08:57:31 <HugoDaniel> Ptr (Fd) comes to mind but :/
08:57:40 <anothernewhaskel> and is a function
08:57:45 <Iceland_jack> anothernewhaskel: k is the second argument?
08:58:00 <anothernewhaskel> er
08:58:05 <Iceland_jack> 'Barry t k p' has 3 arguments, t (first), k (second), p (third)
08:58:23 <anothernewhaskel> ok
08:58:47 <anothernewhaskel> i understand yabba :: p means Barry takes yabba which is of type p
08:58:57 <anothernewhaskel> and if it was dabba :: t it would also take dabba of type t
08:59:13 <anothernewhaskel> but it isnt
08:59:42 <Iceland_jack> maybe the record syntax is in the way, you can write:
08:59:42 <Iceland_jack>     data Barry t k p = Barry { yabba :: p, dabba :: t k }
08:59:42 <Iceland_jack> as
08:59:42 <Iceland_jack>     data Barry t k p = Barry p (t k)
09:00:18 <Iceland_jack> @let data Barry t k p = Barry p (t k)
09:00:19 <Iceland_jack> :kind Barry
09:00:19 <lambdabot>  Defined.
09:00:35 <Iceland_jack> :kind Barry
09:00:49 <Iceland_jack> @kind Barry
09:00:50 <lambdabot> (* -> *) -> * -> * -> *
09:00:53 <Iceland_jack> Right
09:01:05 <Iceland_jack> anothernewhaskel: Can you try to find type arguments that fit?
09:01:16 <Iceland_jack> @kind Barry Int     -- Here is one that *doesn't* fit!
09:01:17 <lambdabot>     Kind mis-match
09:01:17 <lambdabot>     The first argument of `Barry' should have kind `* -> *',
09:01:17 <lambdabot>     but `Int' has kind `*'
09:01:28 <anothernewhaskel> @kind Barry Maybe
09:01:28 <lambdabot> * -> * -> *
09:01:35 <Iceland_jack> Right
09:01:39 <Iceland_jack> two more :)
09:01:45 <anothernewhaskel> @kind Barry Just
09:01:47 <lambdabot>     Not in scope: type constructor or class `Just'
09:01:47 <lambdabot>     A data constructor of that name is in scope; did you mean -XDataKinds?
09:01:50 <anothernewhaskel> er
09:01:54 <Iceland_jack> Just is not a type :)
09:01:56 <anothernewhaskel> doh
09:02:15 <safinaskar-i> Hafydd: okey, and what for non-constant functions?
09:02:16 <anothernewhaskel> @kind Barry Just Int
09:02:16 <lambdabot>     Not in scope: type constructor or class `Just'
09:02:16 <lambdabot>     A data constructor of that name is in scope; did you mean -XDataKinds?
09:02:23 <anothernewhaskel> @kind Barry (Just Int)
09:02:24 <lambdabot>     Not in scope: type constructor or class `Just'
09:02:25 <lambdabot>     A data constructor of that name is in scope; did you mean -XDataKinds?
09:02:29 <Iceland_jack> anothernewhaskel: (same comment as before)
09:02:40 <Iceland_jack> Barry *only* takes types as arguments
09:02:49 <anothernewhaskel> oh
09:02:49 <anothernewhaskel> er
09:02:55 <Iceland_jack> it takes 3 types as arguments ('Just ...' is not a type)
09:03:26 <HugoDaniel> donri: ive seen the Foreign.C.Types has a CFile, im going to use that one for now
09:04:00 <anothernewhaskel> @kind Barry []
09:04:01 <lambdabot> * -> * -> *
09:04:10 <Iceland_jack> Yes! Good, just 2 more /types/ to go ;)
09:04:20 <anothernewhaskel> you said 2 before:(
09:04:24 <Iceland_jack> Yes
09:04:28 <Iceland_jack> 2 more
09:04:32 <anothernewhaskel> that was 1
09:04:36 <Iceland_jack> What?
09:04:37 <anothernewhaskel> so surely 1 more
09:04:39 <anothernewhaskel> O.o
09:04:45 <Iceland_jack> No..
09:04:45 <anothernewhaskel> never mind
09:04:54 <anothernewhaskel> bahahahaa
09:04:57 <anothernewhaskel> @kind {}
09:04:58 <lambdabot> ghc: panic! (the 'impossible' happened)
09:04:58 <lambdabot>   (GHC version 7.6.3 for i386-unknown-linux):
09:04:58 <lambdabot>   tc_hs_type: record
09:05:07 <anothernewhaskel> mwahaha
09:05:09 <Iceland_jack> After saying
09:05:09 <Iceland_jack> <anothernewhaskel> @kind Barry Maybe
09:05:09 <Iceland_jack> I said
09:05:09 <Iceland_jack> <Iceland_jack> Right
09:05:12 * hackagebot mysql-simple-quasi 1.0.0.1 - Quasi-quoter for use with mysql-simple.  http://hackage.haskell.org/package/mysql-simple-quasi-1.0.0.1 (NeilBrown)
09:05:12 <Iceland_jack> <Iceland_jack> two more :)
09:05:15 <Iceland_jack>  
09:05:21 <anothernewhaskel> and i found one more
09:05:21 <anothernewhaskel> []
09:05:27 <anothernewhaskel> so now i need 1 more
09:05:29 <Iceland_jack> ah you're mistaken
09:05:33 <Iceland_jack> I meant *adding* two more to Barry
09:05:39 <Hafydd> > fix ('x':) -- safinaskar-i this computation also terminates, in that it's possible to examine the result and do something useful with it (like printing part of it).
09:05:40 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
09:05:41 <anothernewhaskel> oh
09:05:53 <Iceland_jack> Just like if you have a function (add3numbers 3) you need two more numbers right?
09:06:07 <Iceland_jack> :t (\x y z -> x + y + z) 2
09:06:08 <lambdabot> Num a => a -> a -> a
09:06:26 <Iceland_jack> (\x y z -> x + y + z) takes *3* arguments, I've given it one
09:06:31 <Iceland_jack> so I need to give it two moe
09:06:32 <Iceland_jack> *more
09:06:36 <Iceland_jack> > (\x y z -> x + y + z) 2 10 5
09:06:37 <lambdabot>   17
09:06:47 <Iceland_jack> Same with Barry, Barry requires *3* arguments
09:07:03 <anothernewhaskel> :k Barry Maybe []
09:07:03 <lambdabot>     Expecting one more argument to `[]'
09:07:03 <lambdabot>     In a type in a GHCi command: Barry Maybe []
09:07:03 <Iceland_jack> [] or Maybe require one argument, Either requires 2 arguments, etc.
09:07:08 <anothernewhaskel> right
09:07:20 <Iceland_jack> anothernewhaskel: [] is not a concrete type
09:07:27 <Iceland_jack> :k Barry Maybe
09:07:28 <lambdabot> * -> * -> *
09:07:36 <anothernewhaskel> :k Barry Maybe []
09:07:37 <lambdabot>     Expecting one more argument to `[]'
09:07:37 <lambdabot>     In a type in a GHCi command: Barry Maybe []
09:07:41 <anothernewhaskel> :k Barry Maybe [Int]
09:07:41 <lambdabot> * -> *
09:07:51 <Iceland_jack> Right, just another concrete type
09:07:53 <anothernewhaskel> :k Barry Maybe [Int] [String]
09:07:54 <lambdabot> *
09:07:56 <anothernewhaskel> :p
09:07:57 <Iceland_jack> Good
09:08:13 <anothernewhaskel> :k Barry Maybe [Int] [Barry]
09:08:14 <lambdabot>     Expecting three more arguments to `Barry'
09:08:14 <lambdabot>     In a type in a GHCi command: Barry Maybe [Int] [Barry]
09:08:31 <anothernewhaskel> :k Barry Maybe [Int] [String] [Barry Maybe [Int] [String]]
09:08:32 <lambdabot>     `Barry' is applied to too many type arguments
09:08:32 <lambdabot>     In a type in a GHCi command:
09:08:32 <lambdabot>       Barry Maybe [Int] [String] [Barry Maybe [Int] [String]]
09:08:38 <anothernewhaskel> dawh
09:08:44 <anothernewhaskel> i cant define barry as himself
09:08:47 <anothernewhaskel> boring
09:08:52 <Iceland_jack> You can..
09:09:04 <anothernewhaskel> oh
09:09:06 <Iceland_jack> :k Barry Maybe [Int] [Barry Maybe [Int] [String]]
09:09:07 <lambdabot> *
09:09:10 <anothernewhaskel> :k Barry Maybe [Int] [Barry Maybe [Int] [String]]
09:09:10 <lambdabot> *
09:09:13 <anothernewhaskel> yea
09:09:14 <anothernewhaskel> :P
09:09:32 <Iceland_jack> So what is the type of yabba and dabba now?
09:09:37 <anothernewhaskel> um
09:09:49 <anothernewhaskel> yabba is type Maybe
09:09:56 <Iceland_jack> no
09:10:02 <Iceland_jack> :t yabba
09:10:03 <lambdabot> Not in scope: `yabba'
09:10:05 <Iceland_jack> sigh
09:10:11 <anothernewhaskel> wait
09:10:12 <anothernewhaskel> no
09:10:14 <Iceland_jack> yabba :: Barry t k p -> p
09:10:27 <anothernewhaskel> :k Barry Maybe [Int] [String]
09:10:27 <lambdabot> *
09:10:28 <anothernewhaskel> using that
09:10:30 <Iceland_jack> yes
09:10:32 <anothernewhaskel> yabba is type [String]
09:10:38 <Iceland_jack> well.. close
09:10:41 <Iceland_jack> yabba is a function
09:10:45 <anothernewhaskel> oh
09:10:47 <anothernewhaskel> er
09:10:48 <Iceland_jack> and its input is.....
09:11:02 <anothernewhaskel> [String]
09:11:03 <anothernewhaskel> ?
09:11:05 <Iceland_jack> No
09:11:08 <anothernewhaskel> D:
09:11:17 <Iceland_jack> I just wrote it abote
09:11:18 <Iceland_jack> *above
09:11:31 <Iceland_jack> You just have to specialize it to 'Barry Maybe [Int] [String]'
09:12:05 <anothernewhaskel> :t Barry
09:12:06 <lambdabot> p -> t k -> Barry t k p
09:12:28 <Iceland_jack> @undef
09:12:28 <Iceland_jack> @def data Barry t k p = Barry { yabba :: p, dabba :: t k }
09:12:29 <lambdabot> Undefined.
09:12:30 <lambdabot>  Defined.
09:12:32 <Iceland_jack> :t yabba
09:12:33 <lambdabot> Barry t k p -> p
09:12:34 <Iceland_jack> :t dabba
09:12:35 <lambdabot> Barry t k p -> t k
09:12:43 <Iceland_jack> ↑ those are the general types
09:12:51 <safinaskar-i> danharaj: thanks, i understand
09:12:51 <anothernewhaskel> sure
09:12:56 <Iceland_jack> now try to specialize them to 'Barry Maybe [Int] [String]'
09:13:17 <anothernewhaskel> i have no clue
09:13:21 <anothernewhaskel> =/
09:13:25 <Iceland_jack> It's ok :)
09:13:33 <Iceland_jack> Shall I give you a hint?
09:13:36 <anothernewhaskel> yes
09:13:39 <anothernewhaskel> o:
09:13:57 <Iceland_jack> to unify 'Barry t k p' with 'Barry Maybe [Int] [String]' t needs to be the same as Maybe
09:14:38 <Iceland_jack> So the type of yabba:
09:14:38 <Iceland_jack>     yabba :: Barry t k p -> p
09:14:38 <Iceland_jack> becomes
09:14:38 <Iceland_jack>     yabba :: Barry Maybe ? ?? -> ??
09:14:41 <Iceland_jack>  
09:14:49 <Iceland_jack> it's just a game of search/replace
09:15:55 <anothernewhaskel> yabba :: Barry Maybe [Int] [String] -> [String] ?
09:16:04 <Iceland_jack> Exactly!
09:16:11 <Iceland_jack> now what about dabba:
09:16:12 <Iceland_jack> @ty dabba
09:16:12 <lambdabot> Barry t k p -> t k
09:16:35 <jonkri> donri: I can't seem to track it down. Can I somehow force ServerPartT not to be concurrent or something? (Or use some acid-state-related workaround.)
09:17:04 <anothernewhaskel> dabba :: Barry Maybe [Int] [String] -> Maybe [Int]
09:17:09 <Iceland_jack> right :)
09:17:26 <anothernewhaskel> that doesnt make sense to me
09:17:29 <Iceland_jack> now do you get the kind of Barry and why its first argument must have kind (* -> *)
09:17:32 <Iceland_jack> ?
09:18:58 <anothernewhaskel> no
09:18:58 <anothernewhaskel> =/
09:19:06 <Iceland_jack> ok so
09:19:11 <anothernewhaskel> i feel dumb
09:19:12 <Iceland_jack> Does this make sense as a type: Int Int
09:19:32 <anothernewhaskel> surely Int -> Int
09:19:35 <Iceland_jack> No
09:19:35 <Iceland_jack> Int Int
09:20:07 <Iceland_jack> Int applied to Int
09:20:11 <anothernewhaskel> that makes no sense
09:20:13 * hackagebot mysql-simple-quasi 1.0.0.2 - Quasi-quoter for use with mysql-simple.  http://hackage.haskell.org/package/mysql-simple-quasi-1.0.0.2 (NeilBrown)
09:20:15 <Iceland_jack> exactluy
09:20:16 <anothernewhaskel> why would you do that
09:20:16 <Iceland_jack> *exactly
09:20:17 <anothernewhaskel> :S
09:20:22 <Iceland_jack> You wouldn't and you can't
09:20:27 <anothernewhaskel> right
09:20:30 <Iceland_jack> so you have the intuition
09:20:31 <anothernewhaskel> so how does -> Maybe [Int] make sense
09:20:45 <Iceland_jack> If you're going to do (a b)
09:20:53 <Iceland_jack> and b has kind *
09:20:57 <anothernewhaskel> oh wait
09:20:58 <Iceland_jack> a must have kind * -> *
09:21:02 <anothernewhaskel> Maybe isnt a concrete type
09:21:04 <Iceland_jack> yes
09:21:06 <anothernewhaskel> uhm
09:21:32 <Iceland_jack> Just like it doesn't make sense to say:
09:21:32 <Iceland_jack>     5(10, 5)
09:21:32 <Iceland_jack> because 5 isn't a function
09:21:41 <anothernewhaskel> right
09:21:50 <anothernewhaskel> so t HAS to be of kind * -> *
09:21:56 <anothernewhaskel> otherwise dabba :: t k doenst make sense
09:21:58 <Iceland_jack> Exactly
09:22:00 <jonkri> donri: Oh, I think I found it. I returned the wrong thing in the Update function. :-)
09:22:01 <anothernewhaskel> ok
09:22:10 <anothernewhaskel> why does that mean we assume k is kind *
09:22:15 <anothernewhaskel> why cant k be kind * -> *
09:22:18 <Iceland_jack> That's a different issue
09:22:18 <anothernewhaskel> or * -> * -> *
09:22:22 <anothernewhaskel> or whatever
09:22:29 <Iceland_jack> Haskell assumes the simplest kind
09:22:35 <Iceland_jack> You *can* specify a more complex kind
09:22:37 <anothernewhaskel> i see
09:22:39 <anothernewhaskel> how
09:22:55 <Iceland_jack> KindSignatures
09:23:05 <anothernewhaskel> can you write the syntax
09:23:09 <Iceland_jack> Prelude> :set -XKindSignatures
09:23:09 <Iceland_jack> Prelude> data Foo (x :: *)
09:23:10 <Iceland_jack> Prelude> data Bar (x :: * -> *)
09:23:43 <anothernewhaskel> i see
09:23:45 <anothernewhaskel> ok
09:24:11 <anothernewhaskel> that took me way too long
09:24:11 <anothernewhaskel> :S
09:24:18 <Iceland_jack> heh, that means you're learning!
09:24:28 <Iceland_jack> does this make sense?
09:24:28 <Iceland_jack>     data Point = Point Double Double
09:24:28 <Iceland_jack>  
09:24:38 <donri> jonkri: :)
09:24:39 <Iceland_jack> What about this
09:24:40 <Iceland_jack>     data Point u = Point u u
09:26:51 <anothernewhaskel> the first one is constructing a point with 2 doubles
09:26:54 <anothernewhaskel> ?
09:27:10 <anothernewhaskel> or rather
09:27:11 <Iceland_jack> defining a data type of two Doubles yes
09:27:12 <anothernewhaskel> not constructing
09:27:14 <anothernewhaskel> defining the type
09:27:15 <anothernewhaskel> ye
09:27:20 <Iceland_jack> You construct it with: Point 3.4 0
09:27:23 <anothernewhaskel> yes
09:27:30 <anothernewhaskel> the second
09:28:14 <anothernewhaskel> you define a data type where you pass the type
09:28:26 <anothernewhaskel> as a paraameter
09:28:35 <Iceland_jack> what is the kind of the data type in the first and second case
09:28:41 <Iceland_jack> Kind of Point that is
09:29:04 <anothernewhaskel> in hte first case it's * -> * -> *
09:29:10 <anothernewhaskel> right?
09:29:11 <Iceland_jack> no
09:29:20 <anothernewhaskel> why not
09:29:23 <Iceland_jack> I'm talking about the type constructor, not the data constructor :)
09:29:38 <Iceland_jack> @let data Point = Point Double Double
09:29:38 <lambdabot>  Defined.
09:29:41 <Iceland_jack> @kind Point
09:29:42 <lambdabot> *
09:29:46 <Iceland_jack> :t Point
09:29:46 <lambdabot> Double -> Double -> Point
09:29:58 <anothernewhaskel> oh
09:30:04 <Eduard_Munteanu> What's a coapplicative (if there's such a thing)? copure = extract :: f a -> a, coapply f x = extend f (`fmap` x) :: (a -> b) -> f a -> f b   ?
09:30:04 <anothernewhaskel> the 2nd is * -> * -> *
09:30:08 <Iceland_jack> Why?
09:30:13 <anothernewhaskel> becuase you didnt pass in types
09:30:15 <Iceland_jack> @let data Point u = Point u u
09:30:16 <lambdabot>  .L.hs:144:6:
09:30:17 <lambdabot>      Multiple declarations of `Point'
09:30:17 <lambdabot>      Declared at: .L.hs:1...
09:30:20 <Iceland_jack> @let data Point' u = Point' u u
09:30:22 <lambdabot>  Defined.
09:30:22 <Eduard_Munteanu> Er.
09:30:24 <Iceland_jack> :kind Point'
09:30:30 <Iceland_jack> @kind Point'
09:30:31 <lambdabot> * -> *
09:30:33 <Eduard_Munteanu> That looks a lot like fmap.
09:30:39 <anothernewhaskel> oh damn
09:30:40 <anothernewhaskel> yea
09:30:45 <anothernewhaskel> you already supplied 1 type
09:30:47 <anothernewhaskel> Point
09:30:50 <Iceland_jack> What? No
09:30:55 <Iceland_jack> I didn't supply any types
09:31:07 <Iceland_jack> Point' only has a single type parameter
09:31:07 <anothernewhaskel> @let data Blah u = u u u
09:31:07 <lambdabot>  Parse failed: Illegal data/newtype declaration
09:31:19 <anothernewhaskel> hm
09:31:19 <Iceland_jack> You need a data constructor
09:31:22 <Iceland_jack> :t Point'
09:31:23 <lambdabot> u -> u -> Point' u
09:31:28 <Iceland_jack> Does that make sense?
09:31:49 <bearclaw> It takes a type u and produce a type Point u, so *->* (right?)
09:31:51 <merijn> Iceland_jack: I always like to differentiate data and type constructor in these examples to minimize confusion
09:31:59 <merijn> bearclaw: Yes
09:32:14 <anothernewhaskel> take 2 parameters and produce a Point type though i dont know why the u is at the end
09:32:18 <merijn> i.e. "data PointTypeCon u = PointDataCon u u"
09:32:24 <Iceland_jack> yeah merijn
09:32:29 <anothernewhaskel> what the heck is the type "Point u"
09:32:32 <Iceland_jack> anothernewhaskel: Because it's parameterized by u
09:32:38 <anothernewhaskel> surely Point is a concrete type by itself
09:32:41 <Iceland_jack> Point' pi pi :: Point' Double
09:32:47 <Iceland_jack> Point' 5 20 :: Point' Int
09:32:48 <Iceland_jack> etc.
09:32:58 <Iceland_jack> Ponit' "test" "ing" :: Point' String
09:33:00 <Eduard_Munteanu> Perhaps  coapply :: (w a -> w b) -> a -> b.
09:33:15 <anothernewhaskel> i'm horribly confused
09:33:24 <Iceland_jack> anothernewhaskel: Learn about data types then
09:33:25 <merijn> bearclaw: Similarly, Either :: * -> * -> *, because it takes an 'a' and a 'b'
09:33:29 <bartavelle> is there a deprecation feature on hackage 2 ?
09:33:31 <bearclaw> No, in the case data Point u = Pointctor u u, Point is not a type
09:33:44 <Iceland_jack> You should learn about those before attempting to understand kinds
09:33:44 <bartavelle> ah
09:33:50 <bartavelle> I think I got it
09:33:53 <bearclaw> It is a typefuction that takes a type argument and produces a type
09:34:05 <anothernewhaskel> oh
09:34:06 <anothernewhaskel> wait
09:34:07 <Eduard_Munteanu> anothernewhaskel: in a data declaration the lhs and rhs are totally different things
09:34:09 <merijn> bearclaw: It depends, people are usually not that uptight about whether Point' is a type/type constructor/whatever as it's usually unambiguous
09:34:43 <merijn> bearclaw: It's a type constructor, not type function. The distinction is important because haskell (plus TypeFamilies extension) has type functions too
09:34:54 <anothernewhaskel> is data Point = Point Double Double * -> * because you have two doubles
09:34:58 <Iceland_jack> anothernewhaskel: No
09:34:59 <anothernewhaskel> if I have data Point = Point Double Float
09:35:10 <Eduard_Munteanu> anothernewhaskel: generally it's like  data <type constructor> <type parameters> = <data constructor> <fields> | <another data constructor> <some other fields> | ...
09:35:15 * hackagebot filecache 0.2.1 - A Linux-only cache system associating values to files. The values are discarded when the files are modified.  http://hackage.haskell.org/package/filecache-0.2.1 (SimonMarechal)
09:35:31 <merijn> anothernewhaskel: Let's use this example instead: "data PointType = PointConstructor Double Double"
09:35:33 <Iceland_jack> anothernewhaskel: Go back to data types in LYAH, you need a very firm understanding of them
09:35:33 <Eduard_Munteanu> anothernewhaskel: so the lhs defines a type, and the rhs values of said type
09:35:59 <merijn> anothernewhaskel: PointType has kind * and PointConstructor :: PointType
09:36:02 <merijn> eh
09:36:11 <merijn> PointConstructor :: Double -> Double -> PointType
09:36:19 <anothernewhaskel> yes
09:36:22 <anothernewhaskel> i understand that
09:36:34 * Eduard_Munteanu looks towards Gentle Introduction's little, shady corner
09:36:38 <bearclaw> merijn: Do you mean the distinction is not impportant? can haskell sometimes produce code with a Point u without a clear idea of what that u is?
09:36:46 <Iceland_jack> anothernewhaskel: Do you understand why PointType has kind *?
09:37:08 <bearclaw> :t id 2
09:37:09 <lambdabot> Num a => a
09:37:15 <anothernewhaskel> it's a concrete type
09:37:19 <anothernewhaskel> you defined it
09:37:41 <bearclaw> @let v = id 2
09:37:42 <lambdabot>  Defined.
09:37:44 <bearclaw> :t v
09:37:45 <lambdabot>     Ambiguous occurrence `v'
09:37:45 <lambdabot>     It could refer to either `L.v',
09:37:45 <lambdabot>                              defined at /home/lambdabot/.lambdabot/State/L.hs:145:1
09:37:46 <Iceland_jack> Then what do you find confusing about:
09:37:46 <Iceland_jack>     data Point u = MkPoint u u
09:37:46 <Iceland_jack> where Point has kind: * -> *
09:37:52 <Eduard_Munteanu> Any fully applied type constructor of a datatype is in *.
09:38:01 <bearclaw> o_O
09:38:14 <haasn> > w -- bearclaw
09:38:14 <anothernewhaskel> MkPoint?
09:38:15 <lambdabot>   w
09:38:16 <Iceland_jack> @undef
09:38:16 <Iceland_jack> @def data Point u = MkPoint u u
09:38:16 <Iceland_jack> @kind Point
09:38:16 <lambdabot> Undefined.
09:38:16 <merijn> bearclaw: I mean that "people don't find the distinction important and will mix whatever terminology they fancy" :)
09:38:16 <bearclaw> my point was, v is not a Num a=> a
09:38:17 <lambdabot>  Defined.
09:38:17 <lambdabot> * -> *
09:38:29 <anothernewhaskel> why are we suddenly on MkPoint
09:38:35 <anothernewhaskel> we had data Point u = Point u u before
09:38:36 <Iceland_jack> anothernewhaskel: Because I can call it whatever I like...
09:38:42 <Eduard_Munteanu> They're trying to mk a point. :P
09:38:45 <anothernewhaskel> T_T
09:38:49 <Iceland_jack> (hurr hawr)
09:38:49 <merijn> bearclaw: So sometimes they'll call Point a type and sometimes a type constructor, just what they feel is clearer
09:39:04 <merijn> anothernewhaskel: He's trying to show that the first Point and second Point are completely separate and unrelated
09:39:07 <Iceland_jack> anothernewhaskel: Did you skip parts of the book?
09:39:07 <anothernewhaskel> i see
09:39:11 <anothernewhaskel> Iceland_jack: no
09:39:16 <bearclaw> hmf, sounds confusing, Point cannot be used as a type
09:39:21 <anothernewhaskel> Iceland_jack: I have been reading it over 2 weeks or so though
09:39:30 <bearclaw> or there is some level of unification I do not yet understand
09:39:34 <anothernewhaskel> interspersed with work
09:39:42 <anothernewhaskel> so not the best cohesion
09:39:48 <bartavelle> anybody knowledgeable about hackage2 ? I am getting a "400 Bad Request" when uploading my package
09:39:48 <Iceland_jack> I see
09:39:56 <Eduard_Munteanu> bearclaw: what are you referring to?
09:40:00 <merijn> bearclaw: Naah, it's just that it's usually obvious what it is and "type constructor" is an extra 11 characters to type :)
09:40:10 <Iceland_jack> well you missed the part about record syntax and you sound confused about how data types work
09:40:16 * hackagebot hruby 0.1.0 - Embed Ruby in your Haskell program.  http://hackage.haskell.org/package/hruby-0.1.0 (SimonMarechal)
09:40:34 <bearclaw> Eduard_Munteanu: about the practice of calling the Point in "data Point u = .." a type
09:40:56 <merijn> bearclaw: iow, if you don't worry so much about it, you can infer from context :)
09:40:57 <Eduard_Munteanu> bearclaw: there are a few different notions of "type"
09:41:02 <anothernewhaskel> ooh, embedding ruby in haskell
09:41:07 <anothernewhaskel> <3 ruby
09:41:30 <anothernewhaskel> erm
09:41:37 <anothernewhaskel> :k Either
09:41:38 <lambdabot> * -> * -> *
09:41:45 <Eduard_Munteanu> bearclaw: some call stuff in * "types", so excluding type functions, others call any inhabitant of any kind a type.
09:41:46 <anothernewhaskel> Now, either takes 2 parameters to it
09:41:53 <Iceland_jack> Yes, two types
09:41:54 <anothernewhaskel> :k Point
09:41:55 <lambdabot> * -> *
09:42:00 <anothernewhaskel> ;t Point
09:42:02 <anothernewhaskel> :t Point
09:42:03 <lambdabot> Not in scope: data constructor `Point'
09:42:09 <bearclaw> I see
09:42:10 <solarus> :t MkPoint
09:42:10 <lambdabot> u -> u -> Point u
09:42:12 <anothernewhaskel> oops
09:42:14 <anothernewhaskel> yes
09:42:17 <anothernewhaskel> :t Either
09:42:17 <lambdabot>     Not in scope: data constructor `Either'
09:42:17 <lambdabot>     Perhaps you meant `Other' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
09:42:27 <Iceland_jack> Either is a type, not a value
09:42:34 <anothernewhaskel> bah
09:42:34 <anothernewhaskel> right
09:42:39 <anothernewhaskel> maybe thats where im getting confused
09:42:49 <anothernewhaskel> The way I see it
09:42:51 <Eduard_Munteanu> bearclaw: either way, it is a type _constructor_
09:42:54 <anothernewhaskel> either takes 2 values
09:42:58 <anothernewhaskel> er
09:42:58 <anothernewhaskel> 2 types
09:43:07 <anothernewhaskel> and has kind * -> * -> *
09:43:10 <Iceland_jack> When I defined
09:43:11 <Iceland_jack> <Iceland_jack> @def data Point u = MkPoint u u
09:43:11 <Iceland_jack>     Point is a type constructor (and takes one type)
09:43:11 <Iceland_jack>     MkPoint is a function (data constructor) and takes two (value) arguments
09:43:31 <anothernewhaskel> ah
09:43:31 <kuribas> I liked ruby, but there is way to much magic.  You never know if someone has changed the classes or methods, and your code will break.
09:43:32 <anothernewhaskel> i see
09:43:43 <anothernewhaskel> kuribas: RoR :3
09:43:47 <Eduard_Munteanu> Iceland_jack: hm, is that a cdecl for Haskell? :)
09:44:09 <Eduard_Munteanu> @help @def
09:44:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:44:13 <Eduard_Munteanu> Grr.
09:44:15 <merijn> bearclaw: i.e. when I say "the Point type" I probably mean "Point u" and if I say "the Either type" I mean "Either a b", having to be very explicit rarely comes up when discussing things (i.e. when you're doing something other than explaining things to newbies)
09:44:27 <Eduard_Munteanu> @def type Foo = Int
09:44:28 <lambdabot>  Defined.
09:44:32 <anothernewhaskel> Iceland_jack: I think I was getting confused between providing Point with 2 values and providing it with 1 type
09:44:36 <anothernewhaskel> and between types and kinds
09:44:37 <Eduard_Munteanu> Oh, hah.
09:44:45 <Iceland_jack> Yes I understand why, I assumed you had a solid grasp of data types
09:44:55 <Iceland_jack> no fault of your own
09:44:59 <anothernewhaskel> :p
09:45:12 <anothernewhaskel> I got halfway there
09:45:19 <anothernewhaskel> ^^
09:45:54 <merijn> anothernewhaskel: Hence the switch to MkPoint later, to make the difference clearer :)
09:46:04 <Iceland_jack> Yes, exactly
09:46:25 <anothernewhaskel> I think that did help
09:46:29 <Iceland_jack> Good
09:46:51 <Iceland_jack> So does this make sense?
09:46:51 <Iceland_jack> :t MkPoint pi pi
09:46:52 <lambdabot> Floating u => Point u
09:47:10 <Iceland_jack> Or maybe simpler:
09:47:10 <Iceland_jack> :t MkPoint (5.3 :: Double) pi
09:47:11 <lambdabot> Point Double
09:48:43 <anothernewhaskel> right
09:48:44 <anothernewhaskel> so
09:48:51 <anothernewhaskel> MkPoint is of type Point u
09:48:57 <anothernewhaskel> because it takes a type u
09:49:01 <Iceland_jack> :t MkPoint -- not quite..
09:49:02 <lambdabot> u -> u -> Point u
09:49:02 <anothernewhaskel> and is of type Point
09:49:23 <anothernewhaskel> and u is constrained by being of type Floating
09:49:33 <anothernewhaskel> an instance of
09:49:35 <Iceland_jack> Yes, because that's the type of "pi"
09:49:38 <anothernewhaskel> yes
09:49:39 <Iceland_jack> You *can* hard code the type of your points:
09:49:39 <Iceland_jack>     data PointDouble = MkPointDouble Double Double
09:50:11 <Iceland_jack> And if you need a Point of Int's you'll have do define:
09:50:11 <Iceland_jack>     data PointInt = MkPointInt Int Int
09:50:15 <Iceland_jack> But that's not nice
09:50:38 <Iceland_jack> so you *parameterize* the type Point with a type variable
09:50:56 <anothernewhaskel> ok
09:51:04 <anothernewhaskel> but with data Point u = MkPoint u u
09:51:07 <Iceland_jack> yes
09:51:08 <anothernewhaskel> I can make a Point with strings
09:51:10 <Iceland_jack> yes
09:51:14 <anothernewhaskel> so
09:51:25 <Iceland_jack> it's up to the functions that use Point to constrain the types
09:51:29 <anothernewhaskel> data Point (Num u => u) MkPoint u u
09:51:33 <anothernewhaskel> ?
09:51:37 <Iceland_jack> no you generally wouldn't do that
09:51:39 <anothernewhaskel> oops
09:51:43 <anothernewhaskel> missed an -=
09:51:43 <anothernewhaskel> =
09:51:47 <anothernewhaskel> why not
09:51:55 <anothernewhaskel> why would you want a point that takes strings
09:52:00 <Iceland_jack> Because it doesn't really gain you much
09:52:00 <Iceland_jack>  
09:52:11 <Iceland_jack> You'd rather use
09:52:11 <Iceland_jack>     addPoint :: Num a => Point a -> Point a -> Point
09:52:12 <Iceland_jack> because of some rather annoying reasons	
09:52:22 <anothernewhaskel> it gains me the fact that I know that nobody is gonan play silly buggers with my Point
09:52:57 <anothernewhaskel> what if I define some method to return a Vector using the stuff given to Point
09:53:07 <anothernewhaskel> and I want to use that somewhere else
09:53:13 <anothernewhaskel> Vector of strings seems a bit weird
09:53:48 <supki_> what if someone desides to make a Num instance for Strings?
09:53:57 <anothernewhaskel> then they're insane
09:53:59 <anothernewhaskel> O.o
09:54:22 <anothernewhaskel> why would anyone do thjat
09:54:23 <anothernewhaskel> that
09:54:40 <Eduard_Munteanu> Hm. If Applicatives are described as an endofunctor F and a natural transformation 1 -> F, A |-> F A is the type constructor and pure, f |-> F f is fmap and (eval :: B^A x A -> B) |-> ((<*>) :: F B^A x F A -> F B), maybe I can derive a coapplicative from the monad on the opposite category.
09:54:43 <Iceland_jack> "3" * "hi" => "hihihi" ;)
09:55:03 <Iceland_jack> and if both strings may represent numbers, the multiplicant is chosen randomly
09:55:12 <anothernewhaskel> Iceland_jack: that's ridiculous
09:55:18 <Iceland_jack> Jokes often are
09:55:22 <anothernewhaskel> Iceland_jack: :p
09:55:32 <anothernewhaskel> Iceland_jack: I think I would like to constrain my Point type
09:55:34 <anothernewhaskel> so that it only takes Num
09:55:56 <Eduard_Munteanu> Or an applicative on Hask^op.
09:56:01 <anothernewhaskel> what
09:56:04 <anothernewhaskel> ?
09:56:04 <Iceland_jack> anothernewhaskel: http://www.haskell.org/haskellwiki/Data_declaration_with_constraint look at this then
09:57:22 <Iceland_jack> also note the:
09:57:22 <Iceland_jack> > The designers of Haskell 98 do now think, that it was a bad decision to allow constraints on constructors.
09:57:23 <lambdabot>   <hint>:1:15: parse error on input `of'
09:57:55 <anothernewhaskel> I dont see why
09:58:07 <anothernewhaskel> It allows you to filter out rubbish input
09:58:24 <Iceland_jack> Because it doesn't actually work the way you'd expect
09:58:30 <anothernewhaskel> It's like instead of me using public void foo(Object b) I do public void foo (String b)
09:58:41 <anothernewhaskel> then I only get strings instead of all object types
09:58:43 <anothernewhaskel> in java
09:59:07 <anothernewhaskel> or no?
10:00:37 <Iceland_jack> https://en.wikibooks.org/wiki/Haskell/Classes_and_types#Other_uses look at this, I'm busy atm so I can't go in depth
10:01:01 <Iceland_jack> but basically you don't gain what you might think at first, I don't see how it relates to your Java example either
10:02:14 <anothernewhaskel> Iceland_jack: Im gonna go home and I'll prolly be back on later, you gonna be on in a couple hours?
10:02:29 <Iceland_jack> I guess so yeah
10:02:32 * Twey wonders why the lens getter is called ‘view’ instead of ‘get’.
10:02:34 <anothernewhaskel> ok cool
10:02:47 <anothernewhaskel> I'll discuss later then :D ty all for ur help again
10:02:49 <Iceland_jack> I'm glad to see you sticking with your Haskeling btw :)
10:02:51 <Iceland_jack> no problem
10:02:52 <supki_> Twey: get is taken by Control.Monad.State
10:02:59 <anothernewhaskel> Iceland_jack: haha I like a challenge
10:03:02 <Iceland_jack> anothernewhaskel: you may be interested in http://www.cse.chalmers.se/edu/year/2012/course/TDA452/FPLectures/Vid/
10:03:03 <Twey> Ah
10:03:10 <schell> Twey: would it be because you 'look' at things through lenses?
10:03:14 <Twey> So much hate for qualified imports ☹
10:03:15 <Iceland_jack> I've found it to be an excellent reference to start with
10:03:25 <Twey> schell: ‘set’ already breaks that metaphor, though :þ
10:03:39 <schell> bah, oh well, haha
10:04:18 <anothernewhaskel> Iceland_jack: i'll take a look at home
10:04:19 <edwardk> Twey: because get woud collide with State's get, which is used often with lenses
10:04:19 <anothernewhaskel> ty
10:04:19 <anothernewhaskel> o/
10:04:40 <SwashBuckla> hello!
10:04:42 <Iceland_jack> hey SwashBuckla
10:04:47 <SwashBuckla> hey Iceland_jack
10:05:37 <Iceland_jack> are you ready to Haskell
10:05:38 <Iceland_jack> ??
10:05:53 <ana__> @pl \x -> (f x, g x)
10:05:54 <lambdabot> liftM2 (,) f g
10:06:07 <Iceland_jack> Haskelleamus!
10:06:10 <ana__> @pl \x -> f x - g x
10:06:10 <lambdabot> liftM2 (-) f g
10:06:39 <Iceland_jack> > (liftM2 (||) isSpace isUpper) 'a'
10:06:40 <lambdabot>   False
10:06:43 <Iceland_jack> > (liftM2 (||) isSpace isUpper) ' '
10:06:44 <lambdabot>   True
10:08:10 <Twey> edwardk: I suppose it makes sense.  I'd much rather have them both be called get/set and use qualified imports, though.  In the unlikely scenario that someone decides to go through and change the names of everything ever and needs a tie-breaker vote.  :þ
10:09:04 <Twey> ana__: Also (f &&& g) from Control.Arrow
10:09:11 <Twey> (there's probably a lens too…)
10:09:13 <Eduard_Munteanu> I'd have a cofmap :: (a <- b) -> (f a <- f b), coeval :: (a <- b, a) <- b, copure :: a <- f a, coapply :: f (a <- b) -> (f a <- f b) with the mention cofmap respects coeval: cofmap coeval ~ coapply
10:09:47 <ana__> @pl \x -> map (-) (f x, g, x)
10:09:49 <edwardk> Twey: i'm not willing to make everyone use lens with qualified imports, so renaming the view operation out of the way was the lesser of evils
10:09:50 <lambdabot> map (-) . ap (flip ((,,) . f) g) id
10:09:50 <lambdabot> optimization suspended, use @pl-resume to continue.
10:09:57 <ana__> @pl \x -> map (-) (f x, g x)
10:09:59 <lambdabot> map (-) . liftM2 (,) f g
10:10:00 <lambdabot> optimization suspended, use @pl-resume to continue.
10:10:26 <Twey> edwardk: See previous comment about hate for qualified imports.  :þ  I've always preferred them to trying to find globally unique names — isn't that what they're for, anyway?
10:10:51 <edwardk> Twey: i just keep my thesaurus open ;)
10:10:52 <Twey> (‘L.get’ is actually only one character longer than ‘view’)
10:11:30 <edwardk> but yet, it is still one character longer, and L.&, L.^.  etc. are all hideous =P
10:11:40 <Twey> edwardk: I guess it keeps you on your toes — none of that boring consistency nonsense :þ
10:11:45 <Twey> This is true
10:12:20 <Eduard_Munteanu> Er, I think one of copure or coapply use the wrong arrows, hm.
10:12:31 <Twey> Would be nice to be able to choose which names to prefix when importing a module
10:13:06 <Eduard_Munteanu> edwardk: oh you're here :). Is a coapplicative the same as an applicative? I think I'm getting that above.
10:13:20 <edwardk> no, it just doesn't exist
10:13:41 <Eduard_Munteanu> edwardk: not in Haskell, or not generally? :O
10:13:43 <edwardk> Hask lacks coexponentials.
10:13:49 <Eduard_Munteanu> Ah.
10:13:54 <Twey> There is the ‘import Control.Lens as L’ syntax — then you get .&. *and* L.get (and just get, if you don't need State)
10:14:26 <edwardk> Twey: you're unlikely to convince me on this front. i have lots of State code out there. =)
10:14:44 <Eduard_Munteanu> Doh, the above is a coapplicative on Hask^op, of course I'm getting an applicative on Hask, hah.
10:14:46 <ana__> @pl \(a, b) -> map (-) (a, b)
10:14:46 <lambdabot> uncurry ((map (-) .) . (,))
10:15:58 <Eduard_Munteanu> edwardk: btw, should I use that lax monoidal functor definition? Because it seems to me Applicative is just an exponential-preserving functor.
10:16:33 <haasn> oh, edwardk saying “renaming the view operation” really scared me
10:16:44 <haasn> This is about use vs get?
10:17:31 * haasn .oO( let getting = use )
10:17:38 <edwardk> haasn: that view is view and not named get. i'm not changing it don't worry =P
10:17:46 <haasn> Oh
10:18:08 <Eduard_Munteanu> :t ((<*>), fmap ($))
10:18:09 <lambdabot> (Functor f1, Applicative f) => (f (a -> b) -> f a -> f b, f1 (a1 -> b1) -> f1 (a1 -> b1))
10:18:17 <edwardk> Eduard_Munteanu: sclv has a nice way to characterize it in terms of a closed functor, which describes what you're trying to say
10:18:27 <joelteon> is there a library that provides multidimensional vectors
10:18:31 <edwardk> perhaps invoking his name will be enough to make him appear
10:19:02 <joelteon> that can then be indexed with a tuple :D
10:19:18 <Eduard_Munteanu> I see, thanks.
10:19:37 <Eduard_Munteanu> joelteon: Array?
10:19:44 <Eduard_Munteanu> :t array
10:19:45 <lambdabot> Ix i => (i, i) -> [(i, e)] -> Array i e
10:19:47 <joelteon> oh well maybe
10:20:07 <joelteon> oh, awesome
10:20:08 <Eduard_Munteanu> joelteon: 'i' can be an (a, b)
10:20:19 <joelteon> cool
10:20:40 <Eduard_Munteanu> There's even an instance (Ix a, Ix b) => Ix (a, b)   I think.
10:27:18 <Eduard_Munteanu> Actually uncurry (<*>) :: (f (a -> b), f a) -> f b  is just   fmap (uncurry ($) = eval)  if 'f' is continuous.
10:30:55 <Twey> joelteon: If you want actual vectors you should probably use a linear-algebra library, though — http://www.haskell.org/haskellwiki/Libraries_and_tools/Mathematics#Linear_algebra
10:31:49 <Eduard_Munteanu> joelteon: yeah definitely use something like 'hmatrix'
10:33:02 <carter> Eduard_Munteanu: joelteon i'll be aiming to get numerical arrays preview out later this week
10:33:02 <Twey> joelteon: (that is, if you were talking about mathematical vectors rather than C++/Java ‘vectors’ [resizable arrays])
10:33:17 <carter> i have a lot of philosophical issues with hmatrix
10:33:20 <carter> and technical ones
10:34:42 <carter> ReinH: i have consulting monies coming in, means i can focus on my haskll libs again
10:34:44 <carter> woot
10:37:01 <intrados> Is there a way to restrict the types the type parameter can take on in a phantom type?
10:37:52 <acomar> intrados: you can restrict it to a particular kind
10:37:53 <Twey> intrados: You can use a GADT
10:38:22 <Eduard_Munteanu> intrados: you might want to look at DataKinds.
10:39:06 <carter> GADTs, TypeFamilies, DataKinds, they're all awesome
10:39:20 <intrados> Kinds are generally considered more exotic (and less desirable?) than GADTs, right?
10:39:21 <Eduard_Munteanu> It lets you define stuff like   data Foo = Bar | Baz   data Something :: Foo -> * where Con :: ... -> Something Bar
10:39:34 <jfischoff> intrados: GADTs let you control the types and the kinds.
10:39:36 <Eduard_Munteanu> Making Foo a kind.
10:40:09 <Eduard_Munteanu> intrados: DataKinds are quite new
10:40:31 <donri> you need datakinds for this, gadts aren't enough
10:41:08 <elliott> donri: depends what you mean by restrict
10:41:12 <Eduard_Munteanu> Without DataKinds, you probably want EmptyDataDecls but you can't limit the phantom type.
10:41:14 <donri> i guess
10:41:23 <elliott> you can limit it in gadt constructors
10:41:33 <Eduard_Munteanu> Hm, yeah.
10:41:34 <donri> yeah but that doesn't really limit the phantom type
10:41:35 <elliott> such that after destructing any value the parameter will be part of the closed set you chose
10:41:40 <elliott> s/parameter/index/
10:42:02 <elliott> donri: well you can prove that for any (x :: Foo a) that is not _|_, a is in {Foo,Bar,Baz} or such
10:42:21 <donri> yeah but with datakinds you can get rid of that bottom exception :)
10:42:30 <Eduard_Munteanu> PolyKinds + DataKinds are pretty awesome, actually.
10:42:54 <Eduard_Munteanu> You can use polymorphism to make things more "kindsafe", to say so.
10:47:07 <carter> depends on your goal
10:47:10 <carter> the point is
10:47:12 <carter> we have nice tools :)
10:48:04 <intrados> rYeah. I think I'll try with GADTs. Thanks all
10:51:51 <redscare> i read somewhere that haskell allows circular definitions of the form "x = f(x)", but can't think of an exmaple where this is true. is this a mistake?
10:52:16 <sclv_> > let ones = 1 : ones in take 10 ones
10:52:17 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
10:52:19 <sclv_> boom!
10:52:34 <sclv_> here "f" = (1:)
10:52:50 <tac> > take 10 $ fix (1:)
10:52:52 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
10:53:34 <elliott> redscare: factorial n = if n == 0 then 1 else n * factorial (n-1)
10:53:52 <elliott> i.e., factorial = (\me -> if n == 0 then 1 else n * me (n-1)) factorial
10:53:56 <elliott> er.
10:54:00 <elliott> i.e., factorial = (\me -> \n -> if n == 0 then 1 else n * me (n-1)) factorial
10:54:07 <elliott> it's recursion.
10:55:42 <redscare> ok, but the computation still has to be cut off
10:56:12 <redscare> so nothing like x = 4*x+5 could be allowed
10:57:07 <elliott> redscare: because the standard numeric types are strict
10:57:14 <elliott> > let x = 1 + x in x :: Natural
10:57:15 <lambdabot>   *Exception: stack overflow
10:57:16 <elliott> eh.
10:57:20 <elliott> > let x = 1 + x in (x :: Natural) > 123
10:57:21 <lambdabot>   True
10:57:22 <ClaudiusMaximus> edwardk, copumpkin: been hacking on 'rounded' the last couple of days, finally (maybe) making progress.. i have a simple test program that compiles and runs and doesn't crash and gives correct output (with ghc -prof, without -prof it crashes in GC...)
10:57:23 <elliott> > let x = 1 + x in (x :: Natural) > 1234537478935
10:57:30 <lambdabot>   mueval-core: Time limit exceeded
10:57:31 <elliott> well, that would be True if you ran it for long enough.
10:57:39 <elliott> (you can define this Natural type yourself)
11:03:32 <supki_> > let x = x + 1 in (x :: Natural) > 123
11:03:39 <lambdabot>   mueval-core: Time limit exceeded
11:04:07 <alkabetz_> Huh, that’s kind of weird.
11:05:41 <elliott> well, it's a bad representation.
11:07:48 <tac> > (-1) :: Natural
11:07:49 <lambdabot>   *Exception: Natural: (-)
11:07:50 <osa1> is there a way to give a link in Hackage package description? trying to see something like that in haddock documentation but apparently it doesn't have links to arbitrary webpages(instead of identifiers in same module)
11:08:46 <carter> yup
11:08:50 <carter> people do it
11:09:03 <carter> @hackage llvm-general
11:09:04 <lambdabot> http://hackage.haskell.org/package/llvm-general
11:09:19 <osa1> thanks
11:10:12 <osa1> seems like an undocumented feature
11:14:11 <ReinH> carter: yay moneys!
11:14:17 <carter> osa1: then write a patch to add it to documentation
11:14:18 <carter> ReinH: fact
11:22:25 <majackson> hey, bit of a beginner question: how do I get ghci to immediately execute a function when an .hs file is run with `ghci <file>`?
11:23:13 <carter> ClaudiusMaximus: ooo cool! updated to use 7.8 era c-- ?
11:23:28 <brainacid> I cant quit
11:23:33 <brainacid> I just cant
11:23:58 <brainacid> I thought I could shift my attention to TCP/IP or Networking.
11:24:24 <brainacid> I have the sickness
11:24:32 <ClaudiusMaximus> carter: no
11:24:40 <ClaudiusMaximus> carter: not yet,anyway
11:24:44 <brainacid> I want to learn to code, to think in code
11:24:55 <carter> brainacid: what is your question then
11:25:06 <brainacid> Such yerning, similar to the one where I want to be beefy like Arnold
11:25:58 <pavonia> majackson: Why would you want that?
11:25:59 <carter> brainacid: you should swiltch to #haskell-blah
11:26:08 <carter> ClaudiusMaximus: i think its worth doing
11:26:08 <brainacid> carter, Is there a reference or man page on haskell usage. Or is it pure invention. Defining every function from scratch. Does it mean I should be fluent i advanced math
11:26:25 <carter> brainacid: go read "learn you a haskell"
11:26:28 <carter> @where lyah
11:26:28 <lambdabot> http://www.learnyouahaskell.com/
11:26:35 <carter> its easy
11:26:40 <shergill> ClaudiusMaximus: what is 'rounded'?
11:26:45 <brainacid> lambdabot,I have it. Its disorganized pile of info
11:26:53 <carter> brainacid: please go read it
11:26:59 <carter> ranting won't help learning sadly :)
11:27:14 <carter> shergill: its a lib for doing adaptive precision real computation
11:27:26 <carter> ClaudiusMaximus: the c-- in 7.8 is much less painful to use
11:27:34 <brainacid> carter, I know not to program at all man. Im green. How can I ever understand? Im frustrated
11:27:47 <carter> brainacid: you have to take the time to learn
11:27:51 <carter> @where htdp
11:27:51 <lambdabot> http://www.htdp.org/
11:28:07 <carter> is meant for college freshmen and middle schoolers
11:28:12 <carter> @where htdp2e
11:28:12 <lambdabot> I know nothing about htdp2e.
11:28:30 <carter> http://www.ccs.neu.edu/home/matthias/HtDP2e/ is the more current version
11:28:41 <carter> download.racket-lang.org download that
11:28:47 <carter> work through that book
11:28:49 <carter> problem solved
11:28:50 <carter> go do that
11:28:56 <carter> complaing doesn't help you learn sadly
11:29:04 <carter> doing learning is the best way tolearn
11:29:27 <chrisdone> don't just learn you a haskell
11:29:30 <chrisdone> learn all the haskells!
11:29:34 <carter> that too
11:29:47 <carter> huh, the dudes gone
11:29:49 <carter> o/
11:30:06 <tac> Someone should write a book "Haskell: The Good Parts"
11:30:20 <carter> Idris: the decidable bits
11:30:53 <tac> What bits aren't decidable?
11:31:36 <carter> proving things :)
11:31:43 <shergill> carter: with guarantees and an easy way to enforce numerical accuracy etc?
11:31:59 <carter> shergill: there is no free lunch
11:32:04 <ClaudiusMaximus> carter: that would be nice, but i don't have a ghc-7.8 yet (is it even released?)  anyway, i put my fork here https://gitorious.org/maximus/rounded/source/b7df978e416c393f67fc2c4c102ca0d9594f3485:
11:32:16 <carter> ClaudiusMaximus: cool,
11:32:34 <carter> nope, but we're a few weeks away from an RC
11:36:56 <shergill> carter: sure. i was enquiring regd the scope
11:37:20 <carter> ?
11:37:24 <carter> oh
11:37:39 <carter> shergill: rounded uses mpfr (mfpr ?)
11:37:48 <carter> its just a haskell binding for that
11:38:16 <shergill> ah gotcha
11:39:44 <dropdrive> I have a fuzzy question.  What abstraction do I use if I want to write multiple "computation units" that (1) accepts input values, (2) maintains state (e.g. moving average), (3) can return a computed value on demand, (4) can depend on each other?  I'd want "main" to be something like: (A) provide some data, (B) query values, (C) goto A
11:40:00 <carter> dropdrive: you might like applicatives
11:41:03 <dropdrive> carter: I do like applicatives, but not sure how they're...applicable?
11:41:11 <merijn> carter: Sounds more like he wants threads + channels/mvars?
11:41:37 <merijn> dropdrive: Write one thread per unit and communicate/query them using channels/mvar/tvars?
11:42:03 <carter> dropdrive: or pipes or something similar
11:42:18 <carter> dropdrive: theres a number of different nice appraoches
11:42:21 <merijn> dropdrive: Do you have a more concrete description of the type of work/queries?
11:42:25 <carter> which one makes sense depends on your application domain
11:43:41 <dropdrive> merijn: Threads and channels seem entirely reasonable.  Are you saying that when a unit computes a new value, it puts it into an mvar, and there it's fair game for anyone?
11:44:18 <merijn> dropdrive: That, or use STM
11:44:30 <merijn> dropdrive: And then share the TVar between the main thread/worker threads
11:44:50 <merijn> dropdrive: Then the main thread can inspect the state directly and the STM makes sure things happen atomically
11:46:18 <dropdrive> carter: I guess I'm trying to decide what one of these "units" should look like, and whether there's an interface (?) that works well with "a number of different nice appraoches"
11:46:30 <carter> dropdrive: have you seen pipes?
11:46:38 <carter> i've not yet played with it
11:46:39 <carter> @hackage pipes
11:46:40 <lambdabot> http://hackage.haskell.org/package/pipes
11:46:45 <carter> but the pipes v4 api is pretty nice
11:46:50 <dropdrive> carter: It looks pretty intimidating
11:46:52 <carter> and theres a whole mess of folks writing libs on top
11:46:53 <carter> dropdrive: nope
11:46:55 <carter> go read it
11:46:56 <merijn> dropdrive: STM is nice if you don't have a lot of contention on resources (the way it works is susceptible to thundering herd problem, but very lightweight if there's little contention)
11:47:00 <carter> STM is harder :)
11:47:07 <merijn> carter: Pfft, bollocks
11:47:09 <merijn> STM is easy
11:47:26 <carter> dropdrive: i warmly recommend playing with pipes a teeny bit
11:47:30 <dropdrive> merijn: Is there something I can write that can be glued together with both STM and pipes (not at the same time)?
11:47:33 <carter> its just tubes you can glue together
11:47:34 <merijn> Assuming you have experience in threaded programming in other languages
11:47:41 <carter> @hackage pipes-concurrent
11:47:41 <lambdabot> http://hackage.haskell.org/package/pipes-concurrent
11:47:43 <merijn> carter: It really depends on his problem domain
11:47:51 <merijn> carter: pipes is nice for some, STM for others
11:47:58 <carter> merijn: true
11:48:00 <carter> or both http://hackage.haskell.org/package/pipes-concurrency
11:48:02 <merijn> Since he still hasn't said, it's hard to guess :)
11:48:05 <carter> merijn: agreed
11:48:26 <carter> merijn: ooo, at some point I may be helping add HTM support to ghc :)
11:48:37 <carter> it actually looks like theres a pretty simple type safe way
11:48:52 <krakrjak> HTM support would be really nice.
11:48:53 <carter> basically you'll only be able to run an HTM expression if you provide an STM fallback
11:48:58 <merijn> HTM doesn't look like it'll have a big impact on STM, though. From what I've seen
11:49:03 <carter> true
11:49:07 <carter> but it'd be an easy experiment
11:49:16 <dropdrive> merijn: Mostly it's a stream of log messages from our cluster.  I'd like to analyze them "as they arrive" and be able to be able to ask "how're things looking"?
11:49:17 <jfischoff> Tekmo really knows how to write documentation, and code of course :)
11:49:34 <krakrjak> The only place to play with the HTM stuff is in glibc 2.18 other than Intel's tools.
11:50:07 <merijn> dropdrive: Right, then I personally think STM isn't even a bad idea, you can have a TVar per worker that has the "current" state (which you occasionally update atomically) and then have workers just "read event from (T)Chan, analyze, update state"
11:50:12 <carter> dropdrive: oo, at some point i've been wanting to write a purely haskell version of the client and server for riemann.io
11:50:59 <merijn> dropdrive: If all workers are the same, just have one Chan with incoming log messages and have all workers read from that (Chan, not TChan, because of aforementioned thundering herd problem)
11:51:18 <merijn> dropdrive: Main thread can then, write to Chan, query state of workers, etc.
11:52:19 <dropdrive> merijn: How many workers could this scale to?  I have ~1e4 units in mind
11:59:26 <carter> hahahaha, i'm hitting a pointer in a Gadt code where I either need to use a language like idris, or type classes
11:59:31 <carter> i want to see if i can evade that though
12:00:14 <tac> In time, you will accept dependent types as your savior.
12:00:34 <tac> (The savior saving you from typing errors and limited expressivity)
12:02:11 <carter> tac: yeah
12:02:31 <carter> that or i really need to make this code 7.8 only in the near future :(  //cc ReinH
12:03:39 <scripty> I quit java channel set of morons exist there
12:03:58 * scripty sigh
12:04:42 <merijn> dropdrive: It would scale to however many workers your CPU can handle
12:05:03 <merijn> dropdrive: i.e. 100k+ if they're not doing anything, much, much less when they're all computing a lot
12:05:29 <bearclaw> can I somehow convert  [IO x] into x in a do block?
12:05:36 <bearclaw> err [x]
12:06:49 <tac> sequence_?
12:06:52 <tac> or sequence
12:06:56 <tac> @type sequence
12:06:57 <lambdabot> Monad m => [m a] -> m [a]
12:07:23 <tac> @type liftM head
12:07:23 <lambdabot> Monad m => m [r] -> m r
12:07:31 <bearclaw> aha, thanks, I was using sequence_ and did not think about checking sequence
12:07:47 <jhormuz> what is the best irc channel to discuss gtk2hs (is it here?)
12:11:05 <Cale> Here is probably fine. I don't know if it has a more specific channel
12:12:00 <jhormuz> cale: I already saw that the obvious doesn't exist : #gtk2hs
12:12:18 <bearclaw> fixInt = fromInteger.toInteger <-- voted most useful function ever by a panel of 1 user
12:14:57 <dcoutts> bearclaw: isn't that just fromIntegral?
12:15:12 <dcoutts> which is indeed our standard numeric cast function
12:15:24 <dcoutts> @src fromIntegral
12:15:24 <lambdabot> fromIntegral = fromInteger . toInteger
12:15:34 <dcoutts> bearclaw: ^^ :-)
12:15:51 <tdammers> 'fixInt' is a bit shorter though
12:15:57 <dcoutts> pfft
12:16:02 <tdammers> maybe rename it to 'fi'
12:16:23 <dcoutts> fe if fo fum
12:16:27 <tdammers> that would also open up interesting opportunities for bash/haskell polyglots
12:16:27 <dcoutts> erm
12:16:30 <dcoutts> fe fi fo fum
12:16:38 <dcoutts> tdammers: indeed
12:17:52 <ReinH> carter: I wouldn't mind a nudge to upgrade to 7.8 tbh
12:17:59 <ReinH> although it would reduce your demographic
12:18:13 <carter> ReinH: honestly the core demographic is people who are ok experimenting anyways
12:18:24 <ReinH> carter: ok that's your choice :D
12:18:31 <carter> ReinH: otherwise a lot of type family computations creep in
12:18:34 <carter> i'll play around and see
12:18:36 <ReinH> cool
12:18:58 <ReinH> my experience with new language/compiler versions is that you need library support to push adoption
12:19:18 <ReinH> so it's not necessarily a bad idea for people to start targetting 7.8
12:19:32 <ReinH> although I don't know enough to say if *now* is the time to do it :)
12:19:50 <merijn> Sure it is, wasn't 7.8 supposed to be released already? (i.e. around ICFP)
12:19:58 <ReinH> merijn: *supposed to* ;)
12:19:59 <ana__> @pl \x  -> (x, f x)
12:19:59 <lambdabot> ap (,) f
12:20:15 <ana__> @pl \x -> (f x, x)
12:20:15 <lambdabot> (,) =<< f
12:20:20 <ReinH> (,) <*> f
12:21:46 <carter> ReinH: yuck, the type family approach to making this thing type check requires closed type families :(
12:22:20 <merijn> ReinH: http://memegenerator.net/instance/41967020
12:22:40 <ReinH> merijn: you are speaking my langauge
12:22:59 <ReinH> *language ... I always misspell that :/
12:23:09 <ReinH> pretty sure my fingers are dyslexic
12:23:20 <ReinH> carter: hah, ok, 7.8 it is :p
12:23:24 <merijn> btw, is there a non-sucky memegenerator for spur of the moment things like that? :p
12:23:31 <ReinH> merijn: imgur's isn't terrible
12:23:47 <carter> ReinH: i need  either closed type families, or type nat solvers, or maybe unsafeCoerce
12:24:35 <ReinH> carter: just give up and use unsafeCoerce :p
12:24:39 <ReinH> take the low road
12:24:53 <ReinH> I won't judge you
12:25:27 <carter> ReinH: YESSS
12:25:28 <carter> it works
12:26:14 <lpaste> carter pasted “unsafeCoerce --- the ultimate proof” at http://lpaste.net/94049
12:27:00 <tac> What does {-# UNPACK #-} do again?
12:27:21 <ocharles> tac: means that the field is not boxed
12:27:23 <ocharles> iirc
12:27:31 <carter> yup
12:27:36 <bearclaw> dcoutts: hah! One more stuff I expected to exist but did not find
12:27:44 <carter> bearclaw:?
12:28:06 <bearclaw> carter: I'm lagging by 13 minutes
12:28:11 <carter> ah
12:28:11 <carter> soke
12:28:15 <carter> everyone does sometimes
12:28:16 <ParahSailin> in 7.8, unpack pragmas will be redundant?
12:28:34 <carter> ParahSailin: on small strict fields yeah
12:28:38 <carter> but thats not interesting
12:28:52 <ReinH> carter: hah awesome
12:29:04 <carter> ReinH: do you see why i was just ranting ?
12:29:36 <carter> i need either closed type families or the type nats solver to to a no type class list reverse
12:29:37 <tac> ocharles: is that different from !?
12:29:52 <ReinH> carter: o_O
12:29:53 <carter> tac: you can only unpack strict things
12:30:13 <ocharles> tac: yes, ! means strict
12:30:21 <carter> ReinH: lemme add the sum type i can't use
12:30:22 <ReinH> tac: http://www.haskell.org/haskellwiki/Performance/Data_types#Unpacking_strict_fields
12:30:26 <ocharles> that is, 'anything that goes here must be in weak head normal form'
12:30:56 <ReinH> ocharles: or 'will be evaluated to whnf'
12:30:57 <tac> So, does that mean it's possible to have a boxed strict field then?
12:31:02 <ocharles> ReinH: will be?
12:31:03 <tac> In GHC*
12:31:05 <ReinH> tac: yes
12:31:08 <ocharles> oh, I get what you're saying
12:31:11 <ocharles> 'will be if you store it here'
12:31:23 <tac> Is there ever much advantage to such a thing?
12:31:26 <ReinH> ocharles: well, it isn't saying "you must evaluate it to whnf"
12:31:54 <ReinH> tac: you often want to unpack your strict fields, but iinm there are also some cases where it's better to let the compiler decide
12:31:55 <ocharles> tac: certainly! if you're repeatedly passing something around in recursion for example, by using a strict field you can avoid building up lots of thunks
12:32:09 <ocharles> and not everything can be unpacked
12:32:19 <ReinH> ghc is pretty good at unpacking things when possible
12:32:23 <Ralith> tac: sharing
12:32:31 <tac> ahh
12:32:33 <ReinH> tac: but strictness is a very important thing to consider
12:32:33 <tac> sharing
12:32:42 <lpaste> carter revised “unsafeCoerce --- the ultimate proof”: “No title” at http://lpaste.net/94049
12:33:15 <ReinH> tac: consider the difference between, say, foldl and foldl' (which is strict in its accumulator)
12:33:59 <ReinH> foldl (:) [] [1..100] will build an accumulator that contains 100 unapplied (:) thunks
12:34:18 <ReinH> while foldl' will build an accumulator that evaluates those thunks as it goes
12:34:41 <carter> ReinH: do you see why the PSum type is problem withouth closed families?
12:35:03 <carter> I need to reduce on different parameters dependiong on the case
12:35:10 <ReinH> carter: oh god
12:35:17 <bearclaw> are "pure" and "referentially transparent" synonims?
12:35:25 <carter> not sure :)
12:35:32 <ReinH> bearclaw: near enough, I think
12:36:09 <carter> so when I do "go shap Nil"  i want r = PSum r Z
12:36:22 <ReinH> although referentially transparent is an overloaded term :/
12:36:55 <tac> The important thing is not what you call it. What matters is that equals can be substituted for equals.
12:37:10 <tac> (At least, in the vast, vast majority of cases)
12:37:15 <ReinH> bearclaw: I think it's more accurate to say that purity implies referential transparency but not vice versa
12:37:32 <ReinH> depending on what you mean by purity and referential transparency ;)
12:37:34 <carter> when i do "go Nil stuff- stuff"
12:37:37 <carter> =stuff
12:37:45 <ReinH> carter: right
12:37:46 <ReinH> ok
12:37:49 <carter> i want r=PSum Z r
12:37:56 <bearclaw> my actual question is : is a bound C function "somestruct_t* somestruct_new" pure, in the sence "wrapppable in a unsafePerformIO"?
12:37:59 <tac> The whole point, bearclaw, is that what a snippet of code means does not depend on context.
12:38:03 <carter> and the inductive case i need to do a shuffle around
12:38:36 <carter> with the type nat solver, i could hopefully, do  go :: Shape a -> Shape b -> Shap a +b
12:38:38 <carter> and have it just work
12:38:43 <tac> When you unsafePerformIO, you are taking your life into your own hands, bearclaw.
12:38:50 <fragamus> edwardk: can you tell me what cofunctors are good for
12:39:02 <tac> What is a cofunctor?
12:39:08 <shachaf> everything that functors are good for
12:39:16 <shachaf> since they are the same thing
12:39:50 <ReinH> heh
12:41:19 <fragamus> Better call her mom
12:41:29 <fragamus> Oops
12:41:45 <bearclaw> tac: I'm still struggling with the concept. If that means "same function, same args implies same result", then everything on my c struct can appear pure if I give the illusion in my API that there is no hidden state
12:41:48 <np> I wonder if the following function already is in some library?
12:42:00 <np> foo :: Alternative f => f a -> f b -> f (Either a b)
12:42:06 <np> foo x y = (Left <$> x) <|> (Right <$> y)
12:42:09 <ReinH> A cofunctor is a contravariant functor, which means that it "reverses composition"
12:42:38 <tac> bearclaw: If your code has no side effects, then it's still pure in a sense, but that purity cannot be guaranteed by the type system.
12:43:09 <tac> The sin and cos functions of the Prelude are a good example of C functions that have the IO in their types removed.
12:43:09 <ReinH> it's also covariant on the opposite category (the category with morphisms reversed)
12:43:12 <tac> @type sin
12:43:13 <lambdabot> Floating a => a -> a
12:43:49 <ReinH> (these are two ways of saying the same thing)
12:44:27 <ReinH> bearclaw: The function might be pure, you just won't be able to guarantee it.
12:44:39 <ReinH> tac: heh
12:44:39 <carter> ReinH: honestly what i'll probably do is try deving using HEAD, (since it looks like that will make me happier), and then go back and do some CPP + unsafeCoerce hacks to make it work with 7.6
12:44:43 <carter> *what i should do
12:44:47 <ReinH> carter: seems good
12:44:51 <merijn> bearclaw: btw, you don't even need to wrap C functions in IO if you don't want, the FFI lets you import (non-void) C functions without IO
12:44:53 <ReinH> carter: graceful degradation
12:44:58 <ReinH> carter: fsvo graceful
12:45:02 <carter> fsvo?
12:45:05 <ReinH> for some value of
12:45:11 <merijn> bearclaw: Mind you, if you're *lying* to GHC (i.e. they're not pure) then it's your fault if things break
12:45:23 <carter> well, the types'll be MUCH nicer and cleaner with 7.8 i think
12:45:29 <carter> and someone needs to write code that tests 7.8
12:45:33 <ReinH> carter: that's what I mean :D
12:45:54 <merijn> bearclaw: For example, see: https://github.com/merijn/posix-pty/blob/master/System/Posix/Pty.hs#L240-L241
12:46:07 <ReinH> bearclaw: (this is what puts the unsafe in unsafeCoerce)
12:46:34 <merijn> bearclaw: strerror is pure, in the sense that it has no sideeffects and no state, as a result GHC can just pretend it's a pure haskell function
12:46:43 <bearclaw> (sorry gtk, unexpected or I wouldn't have started that topic right now :) )
12:46:54 <ReinH> bearclaw: it means that you are on your own wrt enforcing purity and type correctness, etc
12:47:50 <carter> ReinH: also that snippet should be a good test of the typenats solver
12:47:54 <merijn> bearclaw: Telling GHC a function is pure, means you are asserting the following things: 1) nothing will go wrong if GHC calls the function multiple times instead of just once, 2) it's fine if GHC replaces two calls with the same arguments with a single call and shares the results with the two locations where it's called
12:48:07 <merijn> bearclaw: As GHC is allowed to make both of those optimisations
12:48:29 <merijn> bearclaw: If either doesn't hold, then it has to be IO to ensure that GHC doesn't break your program
12:48:45 <ReinH> merijn: is that purity or referrential transparency or are they the same here?
12:48:59 <jfischoff> 1) can be circumvented with {-# NOINLINE ... #-}
12:49:11 <jfischoff> not that you should ...
12:49:29 <tac> I think making a distinction between "purity" and "referential transparency" is to argue over fuzz
12:49:34 <merijn> ReinH: Both, either, whatever
12:49:43 <ReinH> merijn: these terms are poorly defined, aren't they...
12:49:50 <ReinH> well, referential transparency specifically
12:50:00 <merijn> ReinH: referential transparency is very rigidly defined, but very loosely used
12:50:07 <tac> pure is too
12:50:27 <merijn> ReinH: referential transparency comes from denotational semantics and has a very precise definition, which no one outside of denotational semantics uses :)
12:50:40 <tac> What matters is Leiniz substitutivity. That you can things for their equals in an equation and retain the same program.
12:50:45 <tac> (up to semantics)
12:50:46 <merijn> ReinH: Pure is...poorer defined, in any case, it's not (usually) arguing about
12:50:59 <merijn> s/arguing/worth arguing
12:51:15 <merijn> bearclaw: Did my comments make sense btw?
12:51:28 <ReinH> merijn: as long as it's understood from context
12:51:43 <merijn> ReinH: In most contexts they mean roughly the same
12:51:48 <ReinH> yep
12:57:57 <epta> How to get first Just a from a [Maybe a] or Nothing if there is no any?
12:59:08 <johnw_> epta: headMay . catMaybes
12:59:10 <shachaf> With lens: preview (traverse . _Just)
12:59:25 <johnw_> ooh, I hadn't seen preview before
12:59:34 <epta> :t headMay
12:59:35 <lambdabot> Not in scope: `headMay'
12:59:36 <shachaf> ??
12:59:41 <shachaf> headMay isn't a real function.
12:59:45 <shachaf> The base name is listToMaybe.
12:59:46 <jfischoff> its in Safe
12:59:47 <johnw_> I think it's in Safe
13:01:46 <epta> How to attach function's argument to the result if it is Just? `(a -> Maybe b) -> (a -> Maybe (a, b))'
13:02:26 <mauke> :t \f x -> ((,) x) <$> f x
13:02:34 <shachaf> @djinn (a -> Maybe b) -> (a -> Maybe (a, b))
13:03:07 <carter> ReinH: also anything that bothers me about 7.8 that isn't a bug, won't be fixable for year if i don't try it out soon
13:03:19 <lambdabot> f a b =
13:03:21 <lambdabot>     case a b of
13:03:23 <lambdabot> Functor f => (a1 -> f a) -> a1 -> f (a1, a)
13:03:23 <carter> I do think we should try to make GHC less broken and buggy between releasese
13:03:25 <lambdabot>     Nothing -> Nothing
13:03:27 <lambdabot>     Just c -> Just (b, c)
13:03:45 <johnw_> liftM2 (<$>) (,)
13:03:48 <epta> @pl \f x -> ((,) x) <$> f x
13:03:51 <lambdabot> liftM2 (<$>) (,)
13:03:52 <lambdabot> optimization suspended, use @pl-resume to continue.
13:04:20 <mauke> :t liftA2 fmap (,)
13:04:21 <lambdabot> Functor f => (a -> f b) -> a -> f (a, b)
13:04:41 <epta> great!
13:05:26 <interspersion> is this valid: [not(P == Q) == (notP == notQ)| ?
13:05:44 <shachaf> Valid haskell?
13:05:47 <interspersion> (where, [P| means that P holds everywhere)
13:05:57 <interspersion> shachaf: no, valid logic
13:06:11 <carter> ReinH: that said… i think thats the only spot where I needed fancy types
13:06:24 <carter> so maybe i shouldn't for now :)
13:06:32 <carter> aside from for testing it
13:06:35 <mauke> @check \p q -> not (p == q) == (not p == not q)
13:06:38 <lambdabot>   *** Failed! Falsifiable (after 1 test and 2 shrinks):
13:06:38 <lambdabot>  False
13:06:39 <lambdabot>  False
13:08:44 <tac> @check \p -> p || not p
13:08:48 <lambdabot>   +++ OK, passed 100 tests.
13:08:52 <tac> I just proved LEM
13:08:56 <Iceland_jack> haha
13:09:06 <Iceland_jack> A classicist! Get them!
13:09:32 <ion> @faq Can Haskell do classical logic?
13:09:33 <lambdabot> The answer is: Yes! Haskell can do that.
13:09:59 <Iceland_jack> Well either Haskell can do classical logic or it can't...
13:10:00 <interspersion> @check \p q -> not(p == q) == (not p == q)
13:10:04 <lambdabot>   +++ OK, passed 100 tests.
13:10:30 <interspersion> @check \p q -> not(p == q) == ((not p) == q)
13:10:33 <lambdabot>   +++ OK, passed 100 tests.
13:12:00 <interspersion> @check p q -> not(p == q) == ((not p) == q)
13:12:00 <lambdabot>  <unknown>.hs: 1: 5:Parse error: ->
13:12:02 <kuznero> Hi All!
13:12:13 <mauke> @check (< 10000)
13:12:16 <lambdabot>   +++ OK, passed 100 tests.
13:12:43 <interspersion> @check (p q -> not(p == q) == ((not p) == q))
13:12:43 <lambdabot>  <unknown>.hs: 1: 38:ViewPatterns is not enabled
13:13:03 <kuribas> Now prove it with types.
13:13:48 <mauke> @djinn Either p (Not p)
13:13:49 <lambdabot> -- f cannot be realized.
13:13:56 <kuznero> How do I figure out that the process I create (with System.Process.createProcess) is really running? Please help.
13:14:21 <interspersion> @check (\kitty cat -> not(kitty == cat) == ((not kitty) == cat))
13:14:24 <lambdabot>   +++ OK, passed 100 tests.
13:14:44 <kuznero> The only thing I'm getting is ProcessHandle (aside from three outs)... but does one check if it has really started or failed...
13:15:00 <interspersion> @check (\dog cat -> not(dog == cat) == ((not dog) == cat))
13:15:01 <oleo> not kitty and not cat, what a bore!
13:15:03 <oleo> omg
13:15:04 <lambdabot>   +++ OK, passed 100 tests.
13:15:09 <oleo> lol
13:15:21 <Iceland_jack> kuznero: getProcessExitCode :: ProcessHandle -> IO (Maybe ExitCode)
13:15:31 <Iceland_jack> Non-blocking, Nothing if it's still running
13:15:33 <interspersion> i can't make sense of it
13:15:50 <interspersion> why is not (P == Q) == (notP == Q)
13:15:51 <interspersion> ugh
13:16:11 <kuznero> Iceland_jack: I cannot wait for the result code...
13:16:20 <ion> interspersion: (==) is xnor.
13:16:24 <Iceland_jack> What do you mean "wait"?
13:16:27 <ion> interspersion: Check the truth table.
13:16:46 <oleo> the truth table is incomplete!
13:16:53 <oleo> there's always the non-sense cat!
13:16:58 <ion> > FileNotFound == False
13:17:00 <lambdabot>   Not in scope: data constructor `FileNotFound'
13:17:00 <oleo> meeep
13:17:01 <oleo> lol
13:17:09 <kuznero> Iceland_jack: I mean I cannot block unless I will get the result code... I want to be sure I fired existing process, otherwise throw warning, etc.
13:17:22 <Vamp> Would his a a good functor instance for my data type? http://lpaste.net/6374016743286767616
13:17:35 <interspersion> ion: (\dog cat -> not(dog == cat) == ((not dog) == cat))...whatever is not a dog, is a cat? that's not true....
13:17:41 <Iceland_jack> kuznero: You won't block, since the function is *non-*blocking
13:17:48 <ion> vamp: …Does that compile?
13:17:56 <Iceland_jack> I'm not sure what else you're looking for
13:18:04 <mauke> interspersion: yes, it is
13:18:17 <johnw_> is nick frisby on?
13:18:18 <mauke> interspersion: since you're implicitly restricting dog, cat to {True, False}
13:18:21 <interspersion> mauke: because there are only dogs and cats in our world?
13:18:28 <kuznero> Iceland_jack: that is rather strange since it claims that it returns exit code :) I guess it is not blocking only if process does not exist, what do you think?
13:18:33 <mauke> no, because you're applying 'not' to dog
13:19:05 <mauke> :t not
13:19:05 <Iceland_jack> kuznero: It claims to return (Maybe ExitCode)
13:19:05 <lambdabot> Bool -> Bool
13:19:22 <geekosaur> kuznero, what? you get back Nothing if it is still running, else Just ExitCode
13:19:24 <Iceland_jack> So it's not strange at all if you read the documentation or what I just wrote earlier
13:19:51 <kuznero> Iceland_jack: geekosaur: now I get the reason :) thanks guys!
13:20:13 <geekosaur> (which is just a Haskelly version of waitpid() with WNOHANG)
13:21:54 <interspersion> @check (\dog cat -> not(dog == cat) == (dog == not(cat))
13:21:55 <lambdabot>  <unknown>.hs: 1: 50:Parse error: EOF
13:21:59 <interspersion> @check (\dog cat -> not(dog == cat) == (dog == not(cat)))
13:22:02 <lambdabot>   +++ OK, passed 100 tests.
13:22:11 <interspersion> ahhhhhhhhhhhhhhhhhhh
13:22:53 <ion> @check \a b -> (a == b) == (not a == not b)
13:22:56 <lambdabot>   +++ OK, passed 100 tests.
13:23:14 <ion> @check \a b -> (not a == b) == (a == not b)
13:23:17 <lambdabot>   +++ OK, passed 100 tests.
13:23:31 <interspersion> ion: yes
13:23:58 <interspersion> :t not
13:23:59 <lambdabot> Bool -> Bool
13:24:08 <mauke> :t (==)
13:24:09 <lambdabot> Eq a => a -> a -> Bool
13:24:23 <interspersion> mauke: yes
13:24:49 <Sculptor> hi
13:24:54 <interspersion> hi
13:26:41 <interspersion> i am not smart, i accept it now.
13:26:55 <interspersion> there is no reason for anyone to love me.
13:28:40 <epta> Data.Foldable.find :: Foldable t => (a -> Bool) -> t a -> Maybe a. How to use it with single value like `find (== 5) 5' and get `Just 5'? And `find (== 5) 4' -> `Nothing'
13:28:42 <Rickasaurus> the most frustraiting thing about haskell is having to learn a pile of big words each which represents a simple idea
13:29:16 <interspersion> Rickasaurus: ja
13:29:45 <supki_> > F.find (== 5) (Identity 5)
13:29:46 <lambdabot>   Just 5
13:29:48 <supki_> > F.find (== 5) (Identity 4)
13:29:50 <lambdabot>   Nothing
13:29:50 <haasn> like “costate comonad coalgebra” :)
13:29:51 <Rickasaurus> but it's the leaning on mathematical jargon that keeps the mission of haskell clear
13:29:58 <haasn> the simple idea being “getters and setters”
13:29:59 <epta> supki_: great!
13:30:22 <haasn> > has (folded.only 5) (Identity 5)
13:30:23 <lambdabot>   True
13:30:34 <haasn> > has (wrapped.only 5) (Identity 5) -- hmm
13:30:35 <lambdabot>   No instance for (Control.Lens.Wrapped.Wrapped
13:30:36 <lambdabot>                     (Data.Fun...
13:30:38 <haasn> aaw
13:31:07 <kuribas> :t has
13:31:08 <lambdabot> Getting Any s a -> s -> Bool
13:31:14 <haasn> > has (wrapping Identity.only 5) (Identity 5) -- hmm2
13:31:16 <lambdabot>   Not in scope: `Identity.only'
13:31:18 <haasn> ...
13:31:23 <supki_> > has (unwrapped.only 5) (Identity 5)
13:31:23 <haasn> > has (wrapping Identity . only 5) (Identity 5) -- ugh
13:31:24 <lambdabot>   can't find file: L.hs
13:31:24 <lambdabot>   No instance for (GHC.Num.Num a0) arising from the literal `5'
13:31:24 <lambdabot>  The type var...
13:31:31 <shachaf> No instance for (GHC.Num.Num a0) arising from the literal `5'
13:31:34 <shachaf> good error
13:31:39 <supki_> > has (unwrapped.only 5) (Identity 5)
13:31:41 <lambdabot>   True
13:31:46 <haasn> oh!!
13:37:20 <brainacid> I get an error main is not defined in module main
13:37:43 <yitz> brainacid: is it?
13:37:53 <brainacid> yitz, http://pastie.org/8387694
13:38:21 <mauke> that's a "no" then
13:38:36 * brainacid reads Learn Haskell Fast and Hard
13:38:59 <yitz> brainacid: do you want this to be a program that you can run, or just a library that provides a Haskell function?
13:39:02 <brainacid> how do I fix it?
13:39:13 <brainacid> yitz, a program I can run
13:39:19 <geekosaur> programs start with main
13:39:21 <mauke> what should it do?
13:39:26 <geekosaur> just as with C and other compiled languages
13:39:37 <brainacid> non-programmer here
13:39:41 <brainacid> 3 days into it
13:40:03 <brainacid> If I get info presented the right way I can learn anything
13:40:06 <brainacid> ;)
13:40:25 <mauke> no, really. what should it do?
13:41:07 <brainacid> mauke, It should run $ ./evenSum [1..10]
13:41:17 <brainacid> mauke, It adds all even numbers together
13:41:32 <brainacid> mauke, Im simply copying the code off the tutorial
13:41:35 <mauke> wtf
13:41:52 <mauke> that's not even valid shell
13:41:52 <yitz> @type let accumSum n [] = n accumSum n (x:xs) = if even x then accumSum (n+x) xs else accumSum n xs in accumSum 0
13:41:52 <lambdabot> parse error on input `='
13:41:53 <brainacid> mauke, Just practicing to learn
13:41:59 <mauke> zsh: no matches found: [1..10]
13:42:06 <yitz> @type let accumSum n [] = n; accumSum n (x:xs) = if even x then accumSum (n+x) xs else accumSum n xs in accumSum 0
13:42:07 <lambdabot> Integral a => [a] -> a
13:42:31 <brainacid> lambdabot, I thought Haskell would auto determine the type
13:42:43 <glguy> brainacid: If you want to type things like "evenSum [1..10]" you can load your Haskell module in GHCi and do that there
13:42:53 <yitz> brainacid: lambdabot is a haskell bot. it auto determined the type.
13:43:05 <brainacid> glguy, I know. I find it easy to compile and run them...
13:43:25 <yitz> > let accumSum n [] = n; accumSum n (x:xs) = if even x then accumSum (n+x) xs else accumSum n xs in accumSum 0
13:43:26 <brainacid> yitz, LMAO...ok
13:43:26 <lambdabot>   <[Integer] -> Integer>
13:43:32 <shachaf> It sounds like you don't find it that easy to run them.
13:43:48 <yitz> > let accumSum n [] = n; accumSum n (x:xs) = if even x then accumSum (n+x) xs else accumSum n xs in accumSum 0 [1..10]
13:43:49 <brainacid> shachaf, :C
13:43:49 <lambdabot>   30
13:43:56 <brainacid> yitz, ok
13:44:25 <brainacid> yitz, I use that in ghci?
13:45:20 <brainacid> yitz, I see u used ; ... could u explain?
13:45:49 <yitz> brainacid: if you change your module slightly (give it a file name AccumSum.hs and change the first line to "module AccumSum where"), then in ghci say :load AccumSum and then say accumSum 0 [1..10]
13:46:06 <brainacid> ok greath
13:46:06 <brainacid> thanks
13:46:19 <yitz> brainacid: it's shorthand for this:
13:46:43 <yitz> > let {accumSum n [] = n; accumSum n (x:xs) = if even x then accumSum (n+x) xs else accumSum n xs} in accumSum 0 [1..10]
13:46:44 <lambdabot>   30
13:47:16 <ReinH> Does a commutative monoid of functions w/ composition have any other special properties?
13:47:22 <ReinH> Is it, e.g., a bicyclic semigroup?
13:47:41 <ReinH> s/special/interesting
13:47:54 <yitz> brainacid: a group of statements is either separated by ; inside {}, or you omit the {} and then you can optionally leave out some or all of the ; and use indentation instead.
13:48:02 <NemesisD> i've got 2 computations that return Either a b, what's a good idiomatic way to return the first one if Right, otherwise do the next one
13:48:10 <NemesisD> monoid?
13:48:24 <yitz> brainacid: in my case i just wanted it on one line without indentation, but i still could leave out the {} and leave in the ;
13:48:48 <ReinH> edwardk: ping
13:49:01 <edwardk>  pong
13:49:06 <NemesisD> oh, there's no monoid (that makes sense), there's no alternative
13:49:54 <mekeor> ReinH: ##math?
13:49:59 <ReinH> mekeor: good call
13:50:06 <ReinH> edwardk: I have a category theory question
13:50:21 <brainacid> yitz, like suchhttp://pastie.org/8387722
13:50:23 <ReinH> Does a commutative monoid of functions w/ composition have any other interesting properties? Is it, e.g., a bicyclic semigroup?
13:50:26 <mekeor> ReinH: ##categorytheory
13:50:28 <mekeor> ? :D
13:50:32 <ReinH> mekeor: is... is that a thing?
13:50:41 <mekeor> a little thing, yeah :)
13:50:41 <mdmkolbe> I need to cite some statistics from Hackage in a paper.  Who should be listed as the author?  "Industrival Haskell Group"? One of the developers (who?)?
13:51:07 <ReinH> mekeor: :)
13:51:29 <mekeor> ReinH: also, i don't think your question related to category theory that much? O.o
13:51:49 <shachaf> ReinH: Commutative monoid of functions? You mean, a set of functions such that you can compose them in any order?
13:51:51 <ReinH> mekeor: well, in as much as algebra does, I guess.
13:51:54 <ReinH> shachaf: yes
13:52:05 <ReinH> a set of functions such that composition commutes
13:52:06 <shachaf> Sounds very restrictive.
13:52:09 <ReinH> shachaf: I'm sure it is.
13:52:26 <Cale> ReinH: uh, isn't there just one bicyclic semigroup/monoid?
13:52:36 <ReinH> Cale: up to isomorphism, yes?
13:52:40 <yitz> ReinH: consider the set of functions that flip a bit in bit vector of fixed cardinality. those form a commutative monoid. doesn't sound very bicyclic to me.
13:52:48 <Cale> Well, there are lots of commutative monoids
13:52:52 <ReinH> Cale: so my question is, really, is it isomorphic to that object?
13:52:54 <NemesisD> best option I've found so far is runEitherR $ EitherR (Left "bang") >> EitherR (Right "yay")
13:53:04 <ReinH> yitz: yeah
13:53:24 <Vamp> Could someone explain me Functor? I get the idea when applied with Maybe and map but I'm confused if I want to apply an instance my own data type data Rose a = a :> [Rose a]
13:53:42 <brainacid> yitz, thanks
13:53:47 <Cale> (also, I don't think the bicyclic monoid is commutative)
13:53:51 <yitz> brainacid: the module name must begin with an uppercase letter
13:53:51 <ReinH> Vamp: do you understand map for lists?
13:54:00 <brainacid> I see
13:54:04 <Vamp> ReinH: I do
13:54:05 <Cale> In particular, pq = 1 is not equal to qp
13:54:26 <Vamp> ReinH: Apply a function (a->b) to each element of the list
13:54:27 <shachaf> How about the set of functions {id}, or {(+n) | n <- [0..]}?
13:54:35 <brainacid> yitz, Parse error: naked expression at top level
13:54:36 <Vamp> ReinH: And return a list of [b]
13:54:41 <shachaf> Those are certainly distinct.
13:54:45 <ReinH> Vamp: and can you implement it?
13:55:08 <brainacid> yitz, dont worry man...im still learning and experimenting. I dont want to take up ur time
13:55:13 <yitz> brainacid: get rid of "let". i needed that for lambdabot here. you don't need it.
13:55:22 <brainacid> yitz, I see
13:55:33 <Cale> instance Functor Rose where fmap f (x :> ts) = ...
13:55:49 <Vamp> ReinH: Yeah
13:55:49 <yitz> brainacid: also delete the last line "in..."
13:55:50 <Cale> You want to apply f to all the elements of the tree (x :> ts)
13:55:56 <ReinH> Vamp: show me pls :)
13:56:05 <ReinH> map (x:xs) = ...
13:56:23 <Cale> In particular, you'll want to apply it to x, so it makes sense that the result will be a tree with (f x) at the root
13:56:28 <Cale> instance Functor Rose where fmap f (x :> ts) = f x :> ...
13:56:35 <brainacid> yitz, Warning: output was redirected with -o, but no output will be generated
13:56:35 <brainacid> because there is no Main module
13:57:00 <brainacid> yitz, http://pastie.org/8387757
13:57:01 <Cale> and then you'll want to apply f to all the elements of the trees in the list of subtrees ts
13:57:04 <yitz> brainacid: don't compile it now. just load it in ghci
13:57:08 <brainacid> oh
13:57:11 <brainacid> ok
13:57:21 <ReinH> Cale: so much for teaching to fish :p
13:57:22 <Cale> So to do that, you'll want to map over that list a function which applies f to all the elements of a tree
13:57:44 <Vamp> ReinH: map f (x:xs) = f x : map f xs
13:58:06 <brainacid> yitz, Prelude AccumSum> [1..10]
13:58:06 <brainacid> [1,2,3,4,5,6,7,8,9,10]
13:58:13 <ReinH> Vamp: now compare that to your rose tree.
13:58:15 <yitz> brainacid: yay!
13:58:17 <brainacid> its supposed to add the even numbers
13:58:21 <ReinH> (fmap for lists is map)
13:58:49 <yitz> brainacid: oh. well, you didn't use your function. but we can already see that your module successfully loaded.
13:58:58 <brainacid> I see
13:59:13 <yitz> now type accumSum 0 [1..10]
13:59:13 <Vamp> map f (x :> xs) = f x : map f xs
13:59:37 <brainacid> Prelude AccumSum> accumSum 0 [1..10]
13:59:37 <brainacid> 30
13:59:40 <brainacid> YAY!
13:59:42 <yitz> woohoo
13:59:43 <Cale> Vamp: The fmap we're trying to implement has type (a -> b) -> Rose a -> Rose b
14:00:02 <Vamp> Cale: Yes
14:00:07 <Cale> Vamp: So  fmap f (x :> ts)  should have type  Rose b
14:00:14 <Cale> and in particular, is not a list
14:00:21 <brainacid> yitz, Its an amazing feeling to see code work. And its not even my code
14:00:22 <Cale> So, constructing it with : doesn't make sense.
14:00:33 <yitz> heh
14:00:36 <brainacid> yitz, I cant imagine when I get to write my own
14:01:21 <brainacid> yitz, what does accumSum n (x:xs) mean
14:01:33 <ReinH> Vamp: but the xs aren't actually [x], they are [Rose x]
14:01:41 <Cale> Vamp: Since it's a tree, and trees only have one constructor, namely :> and presumably we don't have many other ways to construct trees right now, you might want to apply :> to the desired root value and list of subtrees.
14:01:56 <brainacid> yitz, no worries
14:02:13 <xico> is there a nice way to simplify:
14:02:16 <brainacid> yitz, I should keep reading. Will try not to get frustrated
14:02:19 <xico> compare (Factor a) = (compare a) . fromFactor
14:02:34 <elliott> compare = comparing fromFactor
14:02:36 <xico> (appart from uncurry)
14:02:39 <Vamp> Cale:  fmap f (x :> xs ) = f x :> (fmap f xs) like this?
14:02:39 <xico> elliott: thanks!
14:02:51 <Cale> That's again a type error
14:03:03 <shachaf> compare `on` fromFactor -- more generally, not that it matters here
14:03:03 <Cale> xs here is a list of trees
14:03:14 <Cale> f :: a -> b
14:03:23 <Cale> xs :: [Rose a]
14:03:39 <xico> (/me should know his Data.)
14:04:29 <Cale> If you apply fmap to f, depending on which Functor instance you're using, you could get a function [a] -> [b], or a function Rose a -> Rose b
14:04:45 <Cale> but you need to do something more to get a function [Rose a] -> [Rose b]
14:05:01 <Cale> (e.g. apply fmap again)
14:05:19 <Vamp> Cale: I thought I did --> (fmap f xs)
14:05:28 <Cale> You applied fmap once to f
14:06:09 <mekeor> how do i test whether a file (given its path) is a symbolic link?
14:06:22 <aristid> i wish haskell had modules that can take regular (value) parameters.
14:06:54 <mekeor> that'd be cool...
14:07:17 <mekeor> aristid: you certainly know better... doesn't agda support something like that?
14:07:29 <aristid> mekeor: agda does support something like that!
14:07:46 <quchen> aristid: CPP?
14:07:48 * quchen ducks
14:08:09 <aristid> :)
14:08:14 <Cale> xs :: [Rose a]. If it's to make sense as a parameter to fmap here, that means the functor is lists, and f had better accept an argument of type Rose a
14:08:14 <Cale> but it doesn't
14:08:14 <Cale> it wants an argument of type a
14:08:14 <Cale> However, there is a way to turn a function a -> b into a function Rose a -> Rose b
14:08:14 <Cale> namely fmap, using the Functor instance we're writing (recursively)
14:08:29 <Cale> Vamp: Is that making sense?
14:08:37 <Cale> Vamp: So:
14:08:42 <Cale> f :: a -> b
14:08:55 <ReinH> :t fmap . fmap
14:08:56 <Cale> fmap f :: Rose a -> Rose b  (using instance for Rose)
14:08:56 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:09:11 <Cale> fmap (fmap f) :: [Rose a] -> [Rose b]  (using instance for lists)
14:09:25 <ReinH> replacing f and f1 above as appropriate :)
14:10:14 <aristid> quchen: in fact something like c++'s templates would serve me fairly well for this particular purpose, as in c++ you can pass in statically known values of a primitive type to a template class
14:11:39 <Cale> Vamp: Of course, the implementation of fmap for lists strangely enough has another name, specifically map
14:11:46 <Cale> So we could also say  map (fmap f)
14:12:25 <Vamp> Cale: Hmm, hold on I'm trying to understand that second fmap, or map in this case
14:13:11 <sojka> df
14:13:23 <Vamp> Cale: Let me see if  we have map, it takes a function and a list
14:13:38 <Vamp> Cale: We get this then right:  map (fmap f) xs
14:13:39 <sojka> (sorry, just test....)
14:14:26 <aristid> another thing i want is that ByteString finally becomes a small wrapper around storable Vectors. or is there any good reason against that?
14:16:40 <Vamp> Cale: http://lpaste.net/1826654182308839424
14:16:50 <Vamp> Oops
14:17:01 <Vamp> Cale: f x :> []  I meant
14:17:38 <xico> :t (:>)
14:17:39 <lambdabot>     Not in scope: data constructor `:>'
14:17:39 <lambdabot>     Perhaps you meant one of these:
14:17:39 <lambdabot>       `Seq.:>' (imported from Data.Sequence),
14:19:35 <quchen> aristid: Then TH should serve you well, it's pretty much what templates are for C++
14:19:42 <mekeor> ANY way to find out a "file" is a symbolic link?
14:19:49 <quchen> aristid: And like templates it's a solution you only turn to if you absolutely have to
14:20:31 <dmj`> when explaining monads in haskell is a good definition, "A monad in haskell is anything that implements the Monad typeclass and abides by the monad laws"
14:21:58 <leroux> dmj`: But monads in haskell don't *have* to abide the monadic laws.
14:22:06 <Saizan> dmj`: begging the question, but yeah
14:22:10 <lightquake> @pl \_ x y -> f x y
14:22:10 <lambdabot> const f
14:22:13 <lightquake> oh, right
14:22:18 <aristid> quchen: let me explain my usecase... i have code which does things that involve looking at a sliding window of a vector. now the size of this sliding window right now is a constant. that bothers me a bit:)
14:23:03 <acomar> anyone know if it's possible to make cabal work without a LICENSE file in the package?
14:23:03 <dmj`> leroux: Which monads don't abide by left/right identity and associativity
14:23:15 <acomar> I'm working inside of a larger project and I don't want to include an extra license file
14:23:32 <dmj`> acomar: when you do cabal init you have the option of not selecting a license I believe
14:23:46 <acomar> dmj`: nah, this is during cabal install
14:23:50 <acomar> it fails saying no license file
14:23:52 <Saizan> leroux: if they don't your code is bugged
14:24:11 <sipa> afaik
14:24:15 <leroux> Mhm, sure. But the compiler doesn't enforce it.
14:24:16 <Cale> Vamp: You don't need to special case the empty list
14:24:19 <quchen> aristid: Indeed parameters would be nice here
14:24:31 <Vamp> Cale: Was already doubting about that tbh :P
14:24:37 <dobblego> monads in haskell do have to abide by the laws, because if they do not, then they are not monads, regardless of haskell
14:24:49 <Cale> Vamp: (and if you used the empty list in the nonempty case, it would make fmap not obey the Functor law that  fmap id = id)
14:25:01 <dmj`> dobblego: my thinking as well
14:25:15 <Vamp> Cale: Aha I see
14:25:18 <Saizan> yeah, we're basically arguing over "have to"
14:25:30 <dobblego> this kind of precision is important when providing explanation to others
14:25:39 <Saizan> it's not enforced by the language, it's enforced by the spec
14:26:00 <Hrumph> hi
14:26:05 <quchen> dobblego: It's not that easy, "not obeying Monad laws" is a gray area. Reader doesn't obey the laws in the presence of bottom for example, because  bottom >>= return = return bottom = const bottom /= bottom
14:26:23 <Hrumph> when text processing unicode files i find that some of them may have the miscrosoft BOM byte. what is the best practice for dealing with this?
14:26:32 <dobblego> quchen: fast & loose reasoning is morally correct
14:27:46 <quchen> dobblego: Thanks for making me look that term up. I'll put it in my active vocabulary :-)
14:28:02 <dmj`> Saizan: All monads exposed by the standard libraries abide by these laws, despite the fact the language doesn't mandate it, nor the compiler enforce it
14:28:03 <dobblego> quchen: :)
14:28:09 <xico> what does that /r/haskell quote mean?
14:28:10 <xico> Perhaps my biggest pet peave is the fact that all of my bindings disappear when I realize I need to import a new module.
14:28:43 <quchen> xico: Probably that :l discards definitions you made manually?
14:29:08 <quchen> Or maybe it's talking about ghci.conf, local definitions made there vanish when you load modules
14:29:21 <xico> quchen: you're right about :l
14:29:26 <xico> i never used it :)
14:29:30 <Hrumph> should i just look for the bom byte and then ignore it or should i have a checl box that says "file has bom byte"
14:29:46 <geekosaur> "utf8 bom(b)"
14:29:59 <quchen> xico: You never used :l? That's one of the most common GHCi commands
14:30:06 <quchen> Loads a module, ":l test.hs"
14:30:16 <quchen> Like what :m does for installed modules
14:30:27 <xico> well, i never use ghci except for :t
14:30:38 <xico> when lambdabot is not here
14:30:42 <quchen> Wat
14:30:47 <quchen> You should start using GHCi then! :-D
14:31:32 <dmj`> "All instances of the Monad typeclass *should* obey the three monad laws"
14:31:48 <quchen> Is that what the Report says?
14:32:13 <dmj`> quchen: from haskellwiki, http://www.haskell.org/haskellwiki/Monad_laws
14:32:23 <dmj`> quchen: good idea, read the report
14:32:31 <tac> dmj`: Nothing like breaking monad laws as a novel way to write shitty code, eh?
14:32:47 <quchen> I don't know the exact wording, but the Report doesn't enforce the laws
14:33:08 <tac> Reports can't really enforce much of anything, though.
14:33:08 <quchen> "Instances of Functor should satisfy the following laws:"
14:33:45 <danilo2> Hello! I'm plaing with the new cabal sandbox and I've got a problem. If I've got package A and package B, which uses A and I "add-source" them to my sandbox, if I install B, A is rebuild if its sources are changed - this is cool and it indicates, that cabal keep tracks of changes. The question is - If I'm developing lot of pacages and I want to recompile only the changed ones - is it possible?
14:34:54 <dmj`> tac: I agree, outside of the probability monad introduced by LYAH I've never had the need to write my own monads, and thus never had to prove the laws manually. State, IO, Error, etc get the job done
14:35:04 <dmj`> quchen: The Monad class defines the basic operations over a monad, a concept from a branch of mathematics known as category theory. From the perspective of a Haskell programmer, however, it is best to think of a monad as an abstract datatype of actions. Haskell’s do expressions provide a convenient syntax for writing monadic expressions.
14:35:42 <tac> dmj`: Proving the laws yourself or not, you shouldn't release code where the monad laws aren't satisfied.
14:35:54 <quchen> dmj`: … was that a quote?
14:36:01 <quchen> (Or are you explaining Monads to me)
14:36:35 <dmj`> "instances of Monad should satisfy the following laws:"
14:37:10 <Cale> quchen: I don't use :l very often, because I tend to load ghci with a module on the commandline.
14:37:22 <acomar> hmm... cabal's --extra-include-dirs is poorly named... it passes all the directories passed to it with a single -I flag instead of one -I flag per directory
14:37:23 <acomar> :/
14:38:09 <dmj`> quchen: yea, from Haskell Report 2010
14:38:33 <quchen> Ah I see, it's in the IO chapter
14:40:31 <dmj`> quchen: not trying to explain, didn't mean to come across that way
14:40:39 <dmj`> but who had the idea to initially include monads in haskell?
14:44:03 <monochrom> Phil Wadler did
14:44:21 <tac> I think Moggi and Wadler were the two big proponents of "Monads model effects nicely in FP langs"
14:45:46 <monochrom> haskell 1.0 did not have monad. it had a more basic I/O story.
14:46:13 <startling> monochrom: interesting. Do you know where I could find out more about that?
14:46:33 <monochrom> I need to first find haskell 1.0 on the web :)
14:47:52 <startling> Heh. I guess I don't understand: was there a not-(>>=) notion of sequencing things? Or was it "look at this value too hard and it prints a line"?
14:47:53 <dmj`> I'm assuming Wadlers "Monads for functional programming" is where he released the idea?
14:47:56 <dmj`> http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
14:48:16 <startling> dmj`: I don't know if it's the first mention, but it was definitely influential.
14:48:37 <monochrom> you will need a postscript viewer, but old haskells can be found at http://www.haskell.org/haskellwiki/Language_and_library_specification#Historic_development_of_Haskell
14:51:04 <startling> It's sort of surprising how many of the author names aren't familiar to me.
14:51:15 <startling> Wadler is the only one I think I've seen before.
14:52:34 <startling> oh, interesting. Haskell 1.0 used pipes. :)
14:52:50 <sclv_> the lazy with class paper is an excellent reference: http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf
14:53:19 <gauthier_> given an occurrence of Num ( NominalDiffTime) how can I convert it to an Int?
14:53:47 <startling> gauthier_: you need Integral, I think.
14:53:48 <monochrom> well actually, less known but I think more important, Andrew Gordon's PhD thesis on I/O in functional programming. it discusses several popular schemes (none is monads) at that time and shows monadic I/O, and has a tone that praises the monadic scheme.
14:54:47 <monochrom> it's more important because it comes closest to say "monad is better than all other known schemes" and gives technical reasons.
14:54:47 <Clint> auyou could use Enum
14:54:50 <startling> For future reference, in Haskell 1.0, main :: [Response] -> [Request], where Response and Request are giant enumerations.
14:54:52 <Clint> er
14:54:56 <Clint> gauthier_: you could use Enum
14:55:08 <startling> oh, right
14:55:11 <startling> :t fromEnum
14:55:12 <lambdabot> Enum a => a -> Int
14:55:26 * shachaf wrote http://stackoverflow.com/a/13538351 once on this (various approaches to I/O) topic.
14:55:39 <startling> shachaf, interesting, thanks.
14:55:45 * monochrom paid cdn$56 to buy a hardcover copy of that thesis!
14:55:53 <gauthier_> startling/Clint: thanks :)
14:55:56 <ReinH> monochrom: o_O
14:56:18 <startling> monochrom, which? The Haskell 1.0 thing, or Wadler's Monad thing?
14:56:28 <monochrom> Andrew Gordon's thesis!
14:56:40 <ReinH> monochrom: added to my list. Sigh.
14:57:11 <monochrom> Cambridge University Press sometimes picks some good theses and publishes them to sell. Andrew Gordon's is one.
14:57:26 <startling> Oh, I missed that message.
14:57:29 * startling scrolls up.
14:57:32 <monochrom> it is now more expensive and harder to find than when I bought it. I think 10 years ago
14:57:52 <monochrom> Wadler's monad articles never cost money! :)
14:58:05 <startling> monochrom, that was after Wadler's thing, though?
14:58:43 <sclv_> a fair chunk of the thesis "functional programming and input/output" seems available on google books
14:58:53 <sclv_> moggi did the theory
14:58:59 <sclv_> wadler said "let's do this directly in haskell!"
14:58:59 <monochrom> yeah seems so. Gordon's is 1994 or 1993. Wadler's monad tutorial is about 1992? I forgot
14:59:04 <sclv_> then a wave of research followed
14:59:30 <startling> Very cool.
14:59:44 <Vamp> Is WinGhci just a better looking version of GHci in cmdprompt?
14:59:49 <jfischoff> type classes + monads. Pretty nice legacy.
14:59:52 <monochrom> but the thing is Wadler's doesn't directly say "use monad for I/O". it just says "use monad for State, Error, Writer..."
15:00:00 <startling> shachaf: I like this answer a lot. I'm going to bookmark it and hand it to people with the IO/Monad conflation.
15:00:15 <startling> monochrom: oh, that's interesting.
15:00:38 <monochrom> Gordon's is the one focusing on monadic I/O and saying why it is better than other I/O stories
15:01:08 <mangaba_leitosa> "In 1984, he created the Orwell programming language". Hmm
15:01:17 <shachaf> The step from nothing to CPS I/O is much bigger than the step from that to monadic I/O.
15:01:37 <monochrom> (well, except today we also know of Clean's uniqueness type I/O story and it is just as good as monads. but that one wasn't known back then.)
15:01:57 * mangaba_leitosa didn't hea
15:02:10 <monochrom> (and also today we have various very good effect stories)
15:02:13 * mangaba_leitosa hadn't heard about Orwell before checking Wadler's wiki page :-)
15:02:19 <startling> I guess I've never understood uniqueness types. How should I learn about them?
15:02:41 <dmj`> which came first, the State monad, or monadic I/O, and isn't the I/O monad a kind of state monad.
15:02:51 <elliott> probably State and no, respectively
15:02:53 <startling> dmj`, State, apparently, and no
15:02:55 <startling> yeah
15:03:13 <monochrom> I don't know. I only know linear types so far. I think uniqueness type is linear type plus one more restriction? for linear type, I recommend another Wadler's fun paper: "linear types can change the world!"
15:03:21 <startling> dmj`: sometimes people pretend IO is a State EverythingAboutYourMachine, but sometimes people are silly.
15:03:45 <shachaf> (startling is hinting that these times overlap)
15:03:59 <shachaf> IO = State RealWorld is a lie
15:04:17 <mangaba_leitosa> startling: maybe if you learn Clean, you'll learn about them? :-)
15:04:24 <startling> monochrom: yeah, the wikipedia thing seems to say uniqueness types are a lot like linear types. I don't understand how that's anything like Monad for I/O.
15:04:30 <benmachine> shachaf: I think it's either a lie or useless or both
15:04:37 <sclv_> they're only sorta like linear types
15:04:58 <startling> mangaba_leitosa: I guess that's true.
15:05:01 <tac> They feel very linear, since you can only use them at most once.
15:05:12 <tac> if you use the same "state of the world" twice, you get a type error
15:05:17 <startling> "Clean tutorial" seems to find a bunch of youtube videos about learning how to clean, though. :/
15:05:17 <sclv_> i think there's a linear model of them
15:05:18 <monochrom> but very roughly, uniqueness type says you expose the phantom RealWorld# thing, and statically checks that each s :: RealWorld# you receive is used exactly once. and you can say it at the type level. (linear type says at most once)
15:05:20 <tac> because the world has moved on
15:05:22 <sclv_> but the system itself is sorta different
15:05:33 <sclv_> also in the absence of concurrency the state RealWorld model is fine
15:05:45 <startling> monochrom: does that give you purity somehow?
15:05:48 <sclv_> in the presence of concurrency, good luck :-P
15:05:59 <benmachine> sclv_: even in the presence of concurrency you don't learn very much
15:06:04 <monochrom> it is not meant to be "like" monad. it is meant to be "another way to express order of actions"
15:06:05 <dmj`> IO (State# Realworld -> (State# RealWorld, a #)), what is "RealWorld" then? *feeling like I'll never get it unless I work on ghc*
15:06:17 <sclv_> dmj`: its a lie that ghc itself endorses
15:06:19 <benmachine> dmj`: GHC cheats
15:06:23 <startling> dmj`, it's a stupid hack to make sure I/O is strictly sequenced
15:06:26 <startling> aiui
15:06:30 <benmachine> startling: I wouldn't say stupid
15:06:36 <mangaba_leitosa> startling: http://wiki.clean.cs.ru.nl/Documentation ? :-)
15:06:36 <benmachine> it's... not really Haskell
15:06:42 <benmachine> but it's internals, why should it be
15:06:44 <sclv_> you can think of clean's uniqueness types ad just making sure the realworld token (which unlike ghc it doesn't hide) doesn't get duplicated
15:07:05 <sclv_> so if you forget about concurrency and pretend that its safe to just pass around a realworld token
15:07:14 <startling> sclv_, OK, but what does that give me? Only the top-level can do things with RealWorld?
15:07:15 <sclv_> then you can say haskell wraps it in a monad to keep you from duplicating it
15:07:21 <sclv_> and clean just keeps you from duplicating it directly
15:07:47 <startling> So I can ask for a function for a function to run on RealWorld, but I can't pass in RealWorld?
15:07:55 <sclv_> oh no you can
15:07:58 <sclv_> in clean its explicit!
15:08:05 <sclv_> you just can't pass the same realworld into two different places
15:08:16 <sclv_> once you "use" it once, that function returns a "new realworld"
15:08:28 <sclv_> that represents the world as _altered_ by that function
15:08:42 <dmj`> I see, so the State Monad existed before Haskell in languages like Clean/Miranda, but those languages did not have monadic I/O?
15:08:49 <startling> sclv_: oh, I see. so it has the same "strictly sequenced" effect as GHC's thing.
15:09:04 <sclv_> dmj`: not exactly. clean's uniqueness types postdate haskell
15:09:15 <sclv_> it diverged from haskell when haskell went monadic and they went uniqueness
15:09:16 <startling> dmj`, apparently Wadler's "Monads For Functional Programming" talks about State but not I/O
15:09:42 <shachaf> Haskell's "monadic I/O" has nothing to do with RealWorld passing, of course.
15:09:47 <tac> If you're doing theoretical CS, you're not so interested with the amorphous concept of "I/O" in a general sense
15:09:51 <sclv_> miranda also didn't have an explicit RealWorld token, but instead i think did the [Request]->[Response] thing
15:10:06 <startling> http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
15:10:19 <shachaf> [Response]->[Request] :-)
15:10:36 <sclv_> shachaf: yes, except insofar as ghc plays pretend in its internal libs. on the other hand, its a good way to talk about uniqueness types in clean
15:10:39 <startling> shachaf: it is sort of a funny type.
15:10:42 <shachaf> I/O is the devil, anyway.
15:10:57 <shachaf> I wish the GHC token was named something other than RealWorld.
15:10:57 <startling> you'd think it'd need to be, like, (Request, [Response] -> [Request])
15:11:10 <sclv_> its all detailed in the lazy with class paper + reports
15:11:23 <sclv_> you can think of it in the teletype model
15:11:30 <sclv_> [LinesIn] -> [LinesOut]
15:11:32 <sclv_> lazy of course
15:11:34 <shachaf> Yes, I know.
15:11:48 <sclv_> shachaf: I know _you_ know. i'm not just talking to you :-P
15:11:56 <shachaf> Oh.
15:11:58 <sclv_> there are 1000 ppl in this channel
15:12:18 <shachaf> You said "you" and I was the last person you addressed. Never mind.
15:12:26 <sclv_> :-)
15:13:08 <shachaf> Anyway it sounds like a really quite terrible way to write programs.
15:13:27 <shachaf> You have to be careful and force just the right amount from the list, and so on.
15:13:28 <monochrom> rename RealWorld to Neverland!
15:13:47 <geekosaur> Erewhon
15:13:51 <monochrom> and rename unsafePerformIO to captainCook!
15:14:04 <geekosaur> er. I kan spel
15:14:13 <geekosaur> Erehwon
15:14:25 <monochrom> right-kan spel or left-kan spel? :)
15:16:19 <monochrom> speaking of which, I love Hinze's pun in a paper. "can we express [some situation] as an adjunction? yes, we kan!" and the adjunction involves a left or right kan extension
15:16:42 <jfischoff> wahwah
15:17:28 <ocharles> Hum... 20,593,427,256 bytes allocated on the heap for 20 seconds of game play
15:17:31 <ocharles> seem a tad high?
15:17:38 <levi> AFAIK, Linear types enforce usage of each parameter exactly once. Affine types ensure each parameter is used at most once. They are prescriptive types that restrict what can be done in the future. Uniqueness types are descriptive types that claim a reference to be unique; i.e. they describe its history, but not its future. Although they also prohibit future aliasing when captured as part of a higher-order function.
15:17:39 <ocharles> i have no feeling on that number :(
15:17:52 <sm> ocharles: yes :)
15:17:59 <monochrom> 20GB
15:18:09 <ocharles> monochrom: i know what the number *is* :P
15:18:15 <ocharles> i just don't know if that is to be expected
15:18:29 <ocharles> the program doesn't feel like it's 'doing' 20gb worth of work...
15:18:32 <sm> yes, it's too high
15:18:41 <ocharles> alright, time to work out what's going on
15:18:44 <sclv_> the heap's too damn high!
15:18:54 <ocharles> -hc shows a flat graph
15:19:16 <Rickasaurus> Affine types are like tickets to a show, linear types are like getting picked up by the cops
15:19:20 <monochrom> it doesn't say how many of those bytes are deallocated in the same 20 seconds though. if your computer hasn't melt, I bet deallocation must be roughly proceeding at the same rate.
15:19:34 <elliott> ocharles: you can get like a terabyte a minute if you want!
15:19:41 <elliott> haskell programs allocate a lot because they can't do much else
15:20:06 <sclv_> @remember elliott haskell programs allocate a lot because they can't do much else
15:20:06 <lambdabot> Okay.
15:20:11 <ocharles> monochrom: i think that's right - 566,008 bytes maximum residency (48 sample(s))
15:20:34 <ocharles> i wish i was better at using profiling tools :(
15:20:55 <Clint> elliott: what would be involved in setting up an openid provider with your stuff?
15:20:59 <elliott> ocharles: I wouldn't worry about it at all.
15:21:02 * ocharles tries -fprof-auto-top with +RTS -p
15:21:07 <elliott> as long as your latency is OK and the actual resident memory is OK, what's the problem?
15:21:09 <ocharles> i am worrying because i get 2FPS performance
15:21:11 <sm> ocharles: just dig in to reading profiles, there's no avoiding it
15:21:15 <jfischoff> ah
15:21:19 <startling> I went here, clicked on "Syntax" without looking too hard, and was really confused: http://en.wikipedia.org/wiki/Clean_Language
15:21:20 <Rickasaurus> ocharles, you might find this talk helpful https://vimeo.com/69280214
15:21:24 <elliott> Clint: umm, probably not my stuff. are you thinking of Trevor Elliott (elliottt)?
15:21:27 <ocharles> sm: i do, there's just too much information, and the indentation rarely makes any sense to me
15:21:31 <Clint> elliott: i certainly am
15:21:31 <ocharles> (in .prof)
15:21:59 <ocharles> Rickasaurus: awesome, didn't know that was recorded
15:22:03 <sm> ocharles: I use emacs and/or a script to trim/prettify/highlight them
15:22:04 * ocharles bookmarks that
15:22:05 <elliott> /nick elliottttttttttttt
15:22:21 <sclv_> ocharles: we record all our talks
15:22:22 <sm> you can make them foldable in outline mode, eg
15:22:28 <sclv_> and encode them eventually
15:22:30 <Rickasaurus> ocharles, yeah, I found it very informative
15:22:30 <startling> Is lens usable in fay?
15:22:46 <sclv_> startling: i can't imagine it could be
15:22:50 <sclv_> its all typeclasses
15:22:57 <ocharles> what i can never understand is why a cost centre appears in various different positions in the .prof
15:23:02 <startling> Well, I guess I don't understand the typeclasses thing in fay.
15:23:08 <ocharles> meh, i'll plod on
15:23:30 <jfischoff> ocharles: why not hpaste the output?
15:23:32 <startling> I was thinking the resulting javascript just only uses specialized functions.
15:23:34 <sm> ocharles: yes that is weird. Still, just follow the numbers - where are the hot spots
15:23:42 <ocharles> sure
15:24:18 <ocharles> http://lpaste.net/509302826892001280 is my prof
15:24:26 <sm> good idea, I was just going to say
15:24:31 <ocharles> so sure, 'world' is the problem
15:24:39 <ocharles> but then when i -auto-all, it's just noise. i'll get that now
15:25:08 <startling> I guess that's wrong.
15:25:19 <startling> Is lens usable in ghc-js? :)
15:25:35 <sclv_> yes! everything is usable in ghcjs
15:25:38 <sclv_> that's the magic of it
15:25:40 <ocharles> and 'tile' apparently allocates a load, yet has '0 entries'
15:26:18 <sm> ocharles: sometimes you can spot things being called way too many times, for easy improvement. Do the number of entries look reasonable
15:27:26 <ocharles> mm
15:27:35 * sm wonders why all the entries = 0
15:27:38 <ocharles> i'll look more at this tomorrow, should sleep for #haskelleXchange now
15:27:55 <ocharles> thanks for the pointers though!
15:27:59 <startling> So it looks like my idea of turning my gloss graphics demo into a haskell-to-javascript compiler/<canvas> demo is impractical at the moment. Is that right?
15:28:22 <sm> np good luck
15:28:34 <sm> 60 fps soon 8-)
15:30:38 <majackson> hi, I asked this earlier but I had to leave before I got a response, beginner question: how do I get ghci to immediately execute a function when an .hs file is run with `ghci <file>`?
15:30:40 <ubikation> is anybody else learning haskell and working on a small project? I've been working on a personal one but I keep having a lot of trouble and I was hoping I might be able to help someone else
15:31:10 <startling> majackson, you don't.
15:31:16 <startling> majackson: maybe you want runhaskell?
15:31:20 <sm> line 57 looks the hottest spot - world allocating 17G ?
15:31:33 <majackson> startling: so ghci is just for declaring functions?
15:32:04 <startling> majackson: ghci is for playing around with haskell code
15:32:14 <majackson> so how does anyone ever use the command line to trigger some computation in haskell?
15:32:29 <startling> majackson, runhaskell, or compile with ghc and use the executable.
15:32:30 <xico> since it has no jit...
15:32:35 <sm> majackson: ghc -e '...'
15:33:12 <majackson> startling: ok, so if I was using ghc, how would I define the initial function to call when the compiled binary is executed?
15:33:40 <startling> majackson, you write a module named Main and have a main :: IO () in it.
15:34:12 <joelteon> @src concatMap
15:34:12 <lambdabot> concatMap f = foldr ((++) . f) []
15:34:18 <sm> or use -main-is Module.fn
15:34:34 <dmj`> majackson: echo "main = print 3" >> Main.hs && ghc Main.hs && ./Main
15:34:48 <jfischoff> if I have a completely strict data structure that I construct at compile time, will ghc put the data in the data section? Will I pay a construction cost at runtime?
15:35:04 <majackson> so `print` is an example of a built in function which returns IO () ?
15:35:20 <startling> :t print
15:35:21 <lambdabot> Show a => a -> IO ()
15:35:24 <startling> (yes)
15:35:27 <majackson> aha
15:35:32 <majackson> ok, that answers my question, thank you
15:35:36 <startling> majackson: do you know what Show is?
15:35:50 <FreeFull> ghci will execute any IO actions
15:35:58 <majackson> er, some kind of ghci helper thing?
15:36:14 <FreeFull> majackson: Show is a typeclass
15:36:56 <dmj`> @src print
15:36:56 <lambdabot> print x = putStrLn (show x)
15:37:06 <majackson> I see
15:37:30 <sojka> @scr putStr
15:37:30 <lambdabot> Maybe you meant: src rc arr
15:37:41 <sojka> @src putStr
15:37:41 <lambdabot> putStr s  = hPutStr stdout s
15:37:50 <sojka> oh..
15:38:14 <dmj`> majackson: show returns the string representation of an object, putStrLn invokes an IO action that prints to stdout
15:39:43 <startling> majackson: what are you doing to learn Haskell?
15:40:21 <FreeFull> > show (Just 3) ++ show 10 ++ show "Test"
15:40:22 <lambdabot>   "Just 310\"Test\""
15:40:57 <jle`> well ... putStrLn returns an IO object that, when executed, prints to stdout
15:43:01 <majackson> startling: having a crack at project euler problems
15:43:09 <majackson> I studied haskell for a year at uni... years ago
15:43:15 <majackson> so I'm not totally clueless
15:43:23 <majackson> but re-learning a lot of what I studied a while ago
15:48:34 <Iceland_jack> majackson: Don't give up :)
15:55:35 <cem_> why learning haskell is great good ?
15:57:38 <Hrumph> i was looking at the foregoing conversation. among those who have tried both clear and haskell what is better?
15:57:43 <Hrumph> with the uniqueness and the monads
15:58:02 <neeraj> how viable is it to use haskell for random tasks (for which perl/python has been good traditionally)
15:58:17 <Hrumph> neeraj: very viable
15:58:38 <Vamp> Could someone explain me Foldable please? I want to write a Foldable instance for my own data type data Rose a = a :> [Rose a] as fold = undefined. fold    :: Monoid m =>             f m -> m
15:59:25 <Hrumph> i've heard on more thatn one occation that clean doesn't have monoids but no one has said if its better or worse practically
15:59:43 <dmj`> neeraj: what kind of tasks
16:00:15 <Hrumph> for text processing you'll like it better ahn perl for sure
16:00:19 <Hrumph> once you get used to it
16:00:23 <benmachine> it depends
16:00:35 <benmachine> even though I know haskell, there are still a few things I'd prefer perl for
16:00:38 <benmachine> but not many
16:02:11 <jmcarthur> benmachine: i can't think of any case where perl>haskell except for cases where bash>perl
16:02:39 <benmachine> jmcarthur: perhaps I just don't know the right libraries
16:02:54 <jmcarthur> i should say where bash>=perl, but since i really don't like perl...
16:03:02 <neeraj> hmm interesting is real world haskell still a decent resource for learning haskell.. last time i tried there were many differences with ghc on windows
16:03:06 <benmachine> I really don't like bash
16:03:19 <benmachine> I like perl for a little while
16:03:23 <benmachine> about three-quarters of a file
16:03:30 <benmachine> before I remember why I hate it
16:03:46 <elliott> I would take Perl over Haskell for running a few regexps over text any day.
16:04:16 <jmcarthur> yeah i don't really like bash much either, but using bash means i don't have to relearn perl every time. i use bash all day every day anyway, even if i don't always write scripts with it
16:04:21 <yitz> elliott: sed/grep's usually fine for that
16:04:41 <elliott> ok, but sometimes I want to split the text into fields or whatever and join it back up and such.
16:04:45 <jmcarthur> awk
16:04:47 <RichyB> elliott, I'd rather Python for that scale of job, but point taken.
16:04:51 <elliott> yes, awk works
16:04:56 <elliott> but perl is basically awk with more convenient features :P
16:05:05 <jmcarthur> i would not say perl replaces awk
16:05:19 <elliott> python works too. haskell could work fine too, the libraries just IMO aren't quite as convenient yet for quick and dirty text processing
16:05:19 <jmcarthur> awk is more specialized for that particular purpose and works pretty well for it
16:05:44 <yitz> yeah i would use perl once you get to the point that you need awk. but even split/join fields is often fine w/ egrep and sed -E.
16:05:57 <jmcarthur> perl is intended to be much more general, hence putting it into more direct competition with nicer general purpose languages
16:06:07 <gauthier_> is there a package that define an "enum" calendar / time parts? (year, month, week, day, hour, minute)?
16:06:15 <benmachine> awk is better-suited than perl to some of the things I use perl for, but not /so/ much better suited that I'm going to learn another arcane text processing language for it :P
16:06:24 <yitz> gauthier_: the time package
16:06:47 <joelteon> elem is O(n) isn't it?
16:06:50 <elliott> benmachine: have you used a2p? the correspondence is surprisingly direct :)
16:06:57 <benmachine> elliott: I have not
16:07:25 <benmachine> joelteon: yes
16:07:27 <benmachine> well
16:07:33 <benmachine> O(position of element)
16:07:41 <joelteon> right
16:07:43 <joelteon> so not logn
16:07:56 <benmachine> assuming you're talking about Data.List.elem
16:08:00 <joelteon> right
16:08:13 <benmachine> not logn indeed
16:08:16 <gauthier_> yitz: I don't see a data which defines an enum (in the java/c++ sense) whose part would be Year, Month, Week, Day, Hour etc.
16:08:19 <joelteon> but it's not exactly O(n) either
16:09:21 <yitz> gauthier_: toGregorian and fromGregorian for the y.m.d parts, the LocalTime and TimeOfDay types for the day.h.m.s parts.
16:09:48 <yitz> gauthier_: no not in the java/c++ sense which is semantically broken
16:09:55 <neeraj> How is the charting support on haskell for visual data analysis and such?
16:10:57 <gauthier_> yitz: sorry if it's confusing, I'm looking for something like this http://lpaste.net/94056 (incomplete)
16:11:39 <jfischoff> neeraj: there isn't that much as far as I am aware of
16:12:23 <yitz> gauthier_: it's not defined exactly in that way - because that's very awkward semantically - but you can get all of those components easily once you specify all the additional information you need for those to make sense.
16:12:29 <rgrinberg1> I want to parse a json string into [(String, String)], what's an easy way to do that?
16:12:41 <neeraj> ah bummer! i m trying to find an excuse to use haskell for some real use and learn it :)
16:13:03 <Vamp> I'm trying to create a Foldable instance for my own data type data Rose a = a :> [Rose a], but I can't solve it. Getting a type error with what I have now http://lpaste.net/7944430062864957440, probably because I don't really get the idea yet
16:13:15 <jfischoff> neeraj: well there are some things
16:13:30 <jfischoff> neeraj: less than say javascript
16:13:31 <rgrinberg1> I see aeson but all the examples show parsing into a record which is beyond my needs
16:14:06 <sm> neeraj: there's at least http://hackage.haskell.org/packages/search?terms=chart and http://hackage.haskell.org/packages/search?terms=plot
16:14:10 <benmachine> Vamp: foldr takes three arguments, typically
16:14:22 <gauthier_> yitz: it's for representing a conceptual time interval, see http://www.w3schools.com/vbscript/func_datepart.asp interval parameter (sorry for horrible reference!)
16:14:31 <yitz> neeraj: there is the Chart library
16:14:32 <benmachine> Vamp: however you may find it easier to get on with fold, it's simpler
16:14:33 * sm wishes hackage gave more than 10 search results per page
16:15:02 <benmachine> sm: if wishes were patches...
16:15:06 <elliott> you can't implement fold
16:15:08 <elliott> need foldMap
16:15:10 <sm> indeed!
16:15:45 <Vamp> elliott: foldMap :: Monoid m => (a -> m) -> f a -> m this guy?
16:15:50 <elliott> yes
16:15:50 <benmachine> elliott: you can't implement *only* fold
16:15:56 <elliott> benmachine: well, ok.
16:16:10 <Vamp> So what I'm trying to do now is not possible without foldMap?
16:16:30 <yitz> gauthier_: DiffTime represents a time interval.
16:16:31 <benmachine> Vamp: it's possible to define fold without foldMap
16:16:46 <benmachine> Vamp: but you need foldMap in your instance if you want a complete Foldable instance for your type
16:16:50 <elliott> I admit I didn't look at the paste, but if you are trying to write a Foldable instance I recommend writing foldMap.
16:17:07 <yitz> gauthier_: it would be extremely awkward to represent an interval in the way you suggest. libraries that do that are almost always broken.
16:17:16 <elliott> if you're trying to write foldr then it's not as nice. if you're trying to write fold it's insufficient.
16:17:36 <benmachine> but writing foldMap is very close to how you'd write fold anyway
16:17:43 <gauthier_> it's not to represent a time value / instance, but to allow say user to pick how to visualize data
16:17:52 <benmachine> you just apply the function first
16:18:00 <Vamp> elliott: So I'd better first write the function foldMap and use that for creating a Foldable instance of my data type?
16:18:15 <elliott> foldMap is in Foldable.
16:18:35 <yitz> gauthier_: what if there was a clock change in the middle of the interval? a leap year? many other complexities. there are many choices to make.
16:18:36 <gauthier_> yitz: I see what you mean, but I'm after the "interval" parameter, not representing a discrete value but the concept of interval
16:19:00 <glguy> since all the other functions have defaults in terms of foldMap, foldMap practically *is* Foldable
16:19:49 <yitz> gauthier_: ok, that's a DiffTime. it represents an interval of time. you can then break that down into parts easily - but only if you clarify exactly what you mean by "parts", and what you want to do with boundaries.
16:20:48 <dmilith> shame on you!
16:21:32 <dmilith> you're contributing one of best languages I ever seen, but that cabal infrastructure.. and whole that package managment.. is awful
16:21:58 <gauthier_> yitz: see possible values for field here: http://www.postgresql.org/docs/8.1/static/functions-datetime.html#FUNCTIONS-DATETIME-TRUNC, I mean the conceptual interval, not a discrete representation of an instance of it in reference to a point in time
16:24:41 <yitz> gauthier_: so you want to truncate an interval to the nearest u where u is some unit of time?
16:24:49 <mm_freak> vhz_: are you the author and maintainer of the various crypto libraries including cprng-aes?
16:25:54 <yitz> gauthier_: what units do you want? for example, you mention day. do you mean day in clock time, or in absolute chunks of 24 hrs.?
16:26:40 <yitz> gauthier_: the postgresql docs don't specify. so that is either an ill-defined or poorly documented function.
16:26:43 <sm> benmachine: patch away!
16:27:00 <benmachine> sm: ain't me who's wishing :P
16:27:03 * benmachine goes to bed instead
16:27:04 <yitz> gauthier_: the time library is very precise about all those things.
16:27:14 <gauthier_> yitz: I'm more or less looking for something I could pass as the field argument of the above function, I think I can just define this enumeration http://lpaste.net/94056
16:28:01 <gauthier_> yitz: according to pgsql doc, I can call date_trunc(millenia, getdate()) millenia is a symbol but it doesn't have a discrete value
16:28:06 <dmilith> anybody have an idea what might be wrong? http://s.verknowsys.com/02ad6e5eb995ae872b969fa1e96dacbd411c5b3d.jpg
16:28:16 <dmilith> i'm doing cabal install zeromq-haskell --extra-include-dirs=$HOME/Apps/Zeromq/include/ --extra-lib-dirs=$HOME/Apps/Zeromq/lib/
16:28:18 <yitz> gauthier_: but what does that function do? the documentation is vague. i can't tell. in fact, its implementation is likely buggy, as is common with time libraries. so how am i supposed to tell you how to imitate its effect?
16:28:19 <benmachine> gauthier_: to answer your original question, I've never seen an enum like that one you pasted in any standard libraries
16:28:50 <yitz> gauthier_: and the result of that function is? do you know?
16:29:04 <dmilith> the thing is - this is darwin, with latest compiler package without gcc. There's only llvm-gcc available on this system (10.8.5)
16:29:17 <glguy> dmilith: I'd wager you haven't installed zmq or installed it in a way that GHC can find
16:29:19 <dmilith> (and even not by default)
16:29:27 <dmilith> i did
16:29:28 <elliott> dmilith: "shame on you!" is not really a good way to get help :)
16:29:33 <dmilith> I'll do a reinstall anyway
16:29:56 <gauthier_> yitz: I think the pgsql doc is clear, there is similar function in mssql too, I think benmachine got what I meant
16:30:40 <dmilith> elliott: that was just trolling ;]
16:30:42 <benmachine> glguy: wouldn't you expect to get an error on zmq_msg_t itself in that case?
16:30:48 <yitz> gauthier_: yes benmachine is correct. and that is intentional. it makes no sense to have such a tuple defined, unless you explain its semantics.
16:30:58 <dmilith> elliott: don't take it personally :} no offense
16:31:06 <dmilith> it was just a joke
16:31:25 <dmilith> but there's always some part of truth in that jokes ;p
16:31:27 <yitz> gauthier_: you say you think the psql docs are clear, but you haven't explained to me yet what they mean. i've given you several different possible interpretations.
16:31:44 <dmilith> cabal crashes very frequently on osx 10.8.5, I want to help.
16:31:50 <gauthier_> yitz: I intended to reuse one if it exist, I want to map http://kamisama.github.io/cal-heatmap/#domain
16:31:56 <yitz> gauthier_: sorry, i don't mean to be difficult. but sometimes i am.
16:32:26 <gauthier_> yitz: I'm getting it done this way: http://lpaste.net/94057
16:32:57 <dmilith> https://gist.github.com/dmilith/6893594 - here's full dump from what is written to terminal
16:33:06 <benmachine> gauthier_: yitz is right that doing time stuff correctly is a gigantic pain in the arse
16:33:12 <benmachine> yitz: even worse, doing it wrong is easy
16:33:15 <benmachine> er
16:33:25 <benmachine> gauthier_: that ^
16:33:30 <dmilith> there're tons of warnings from linker too
16:33:39 <dmilith> almost one warning for compiled file
16:33:45 <dmilith> so it's something with defaults on that os
16:34:22 <gauthier_> yitz: no offense, it pushes me to think further, I do think it would be useful to express computations over date without having yet a date instance, if I want a DSL for that, but with function composition and expressive power of haskell, maybe it's uneeded as you can compose those functions
16:34:23 <dmilith> and Zeromq is installed, and it's installed properly.
16:35:09 <gauthier_> dmilith: maybe you want zeromq3-haskell?
16:35:25 <ctrl> @pl (.)(.)(.) (foldr (liftM2 (.) (:) (filter . (/=))) []) $ flip $ (.) (=<<) $ flip $ \(a, b) -> (=<<) (\(c, d) -> guard (b == c) >> return (a, d))
16:35:29 <lambdabot> (foldr (liftM2 (.) (:) (filter . (/=))) [] .) . (flip $ ((=<<) .) $ flip $ ap (((=<<) .) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip (flip . ((.) .) . ((>>) .) . (guard .) . (==)) . (
16:35:29 <lambdabot> return .) . (,) . fst) snd)
16:35:29 <lambdabot> optimization suspended, use @pl-resume to continue.
16:35:43 <ctrl> @pl-resume
16:35:49 <lambdabot> (foldr (liftM2 (.) (:) (filter . (/=))) [] .) . (flip $ ((=<<) .) $ flip $ ap (((=<<) .) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip (flip . ((.) .) . ((>>) .) . (guard .) . (==)) . (
16:35:49 <lambdabot> return .) . (,) . fst) snd)
16:35:50 <lambdabot> optimization suspended, use @pl-resume to continue.
16:35:52 <ctrl> @pl-resume
16:35:52 <neeraj> sorry had to step out
16:35:58 <dmilith> gauthier_: I owe you best beer! :} thanks! it works
16:36:02 <benmachine> using @pl-resume almost never leads to anything good
16:36:03 * hackagebot tidal 0.2.4 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.2.4 (AlexMcLean)
16:36:04 <lambdabot> (foldr (liftM2 (.) (:) (filter . (/=))) [] .) . (flip $ ((=<<) .) $ flip $ ap (((=<<) .) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip (flip . ((.) .) . ((>>) .) . (guard .) . (==)) . (
16:36:04 <lambdabot> return .) . (,) . fst) snd)
16:36:04 <lambdabot> optimization suspended, use @pl-resume to continue.
16:36:11 <ctrl> oh my god
16:36:11 <yitz> gauthier_: ok. btw cal heat map uses d3 directly in JS. in haskell, you could use diagrams.
16:36:13 <RichyB> ctrl, what?
16:36:17 <neeraj> thanks for the links to charts and plotting libraries. i will start off that
16:36:23 <ctrl> it hurts my brain
16:36:26 <ctrl> @pl-resume
16:36:36 <gauthier_> dmilith: I don't drink beer, but thanks :)
16:36:38 <RichyB> ctrl, stop the hurting!
16:36:40 <lambdabot> Plugin `pl' failed with: <<timeout>>
16:36:49 <dmilith> gauthier: me neither ;]
16:36:51 <ctrl> How do I get a local lambdabot?
16:37:25 <yitz> gauthier_: it looks like that app is probably talking about calendar days and wall-clock time. but it doesn't say what it does about time zones, and about calendar days that do not have exactly 24 hours.
16:37:55 <jfischoff> ctrl: you can try installing it from hackage your git a more recent branch on github
16:38:09 <gauthier_> yitz: I'm writing a widget wrapper to this lib for yesod
16:38:12 <ctrl> I did cabal install lambdabot on windows. How do I use it?
16:38:26 <gauthier_> yitz: well attempting, I'm all starting with haskell & yesod
16:38:27 <jfischoff> type lambdabot on the command line
16:38:50 <jfischoff> assuming you have your cabal binary location on your path ...
16:39:00 <yitz> gauthier_: oh i see. so you just want to import the JS libraries and pass values to those existing functions?
16:39:04 <jfischoff> err cabal bin directory
16:39:25 <ctrl> well, no, it failed to cabal-install. I suppose I reboot and try it on linux
16:39:47 <gauthier_> dmilith: I'd have good use of some real world example of using zeromq from haskell, as I don't know how to handle different threads or similar if I was to write a server process managing lot of connections
16:40:07 <jfischoff> it might not build from hackage right now
16:40:32 <gauthier_> yitz: yes, a "safe" wrapper around it, do you think http://lpaste.net/94057 would be a good fit to express domain and subdomains?
16:40:39 <dmilith> gauthier_: i'm just playing with my 0mq communication system, by doing simple web worker in haskell (it's my 3rd day of learning process)
16:43:05 <yitz> gauthier_: that's the idea yes. (i haven't checked the details of course)
16:43:21 <yitz> gauthier_: sorry i obviously really misunderstood what you are trying to do.
16:44:09 <gauthier_> yitz: no problem, thanks for challenging my assumptions, I know dealing with dates / computations as discrete values is major pain
16:46:13 <yitz> gauthier_: then it depends on where your data is coming from and how it expresses time. you may then need the time library after all to convert it into something you can use for your cal-heatmap.
16:47:52 <Guest58199> hello
16:48:11 <yitz> hi Guest58199
16:49:20 <Guest58199> has anyone experience in writing graphics applications (or even games) in haskell?
16:50:44 <Guest58199> actually, i am looking for a simple to use 2d library to draw some simple shapes
16:50:54 <jfischoff> Guest58199: diagrams
16:51:14 <Yaniel> #haskell-game seems to do that a lot
16:51:28 <jfischoff> http://hackage.haskell.org/package/diagrams
16:51:29 <yitz> gauthier_: it makes perfect sense to write your own sum type. the whole idea is that you want type safety, so the type should exactly match what you want to allow in cal-heatmap. you would not expect that someone already wrote exactly that type in some other library.
16:52:03 <pavonia> Guest58199: also Cairo
16:52:27 <bgamari> Guest15458, Also gloss
16:52:41 <augur> manuel chakravarty is everything wrong with functional programming :\
16:52:48 <bgamari> Guest15458, and of course there's always just OpenGL
16:53:04 <Guest58199> thank you for your suggestions :)
16:54:31 <Guest58199> i will take a look at the packages
16:54:38 <sm> Guest58199: oh we're not done yet :)
16:55:00 <Guest58199> :)
16:55:14 <sm> http://joyful.com/fungen , http://helm-engine.org , and maybe also check the game dev page on the haskell wiki
16:55:54 <Guest58199> oh, fungen looks nice
16:56:18 <sm> it's the oldest but most complete and portable haskell game lib
16:56:53 <Guest58199> is it also based on reactive programming?
16:57:11 <sm> no, it's straightforward imperative opengl-based
16:57:42 <Guest58199> I see. Maybe I+ll take a closer look at helm
16:57:47 <dmilith> I have one more question. Is there available any kind of linter to be used in Sublime text2?
16:58:02 <dmilith> I mean dynamic error check while typing (linter's job)
16:58:05 <gauthier_> Guest58199: I've dabbled a little bit with gloss, I recommend it as it's very expressive and has basic input handling, but I won't use it for a full fledged application
16:59:04 <sm> Guest58199: go for it, but be prepared for some installation struggle
16:59:06 <Guest58199> thank you gauthier. Ill also try that one out - does not have to be a full fleged application
16:59:07 <gauthier_> yitz: thanks, yes I like sum types and general approach to data construction / deconstruction with haskell
16:59:33 <Guest58199> I just want to practice my very humble haskell skills :)
16:59:47 <sm> (with helm, not gloss)
16:59:48 <Guest58199> thanks for the warning
16:59:57 <gauthier_> Guest58199: I've some naive code using it, my first steps in haskell few days ago: https://bitbucket.org/gauthier/haskell-playground/src/1e1000aa5aebcef89c4433c665f18f983a94c119/Playground/Gloss?at=default
17:00:06 <Guest58199> cool
17:00:59 <PacketStorm> i will be back :) gotta register a nickname to make things easier
17:01:30 <dmilith> ok, there was no question ;]
17:01:35 <PacketStorm> 23
17:04:05 <Solarstorm> now that's better, I guess
17:05:13 <Solarstorm> thanks for sharing your code, gauthier
17:05:19 <dmilith> anyone knows how to enable threads through .cabal file? I can't find it in docs
17:06:06 * hackagebot test-framework 0.8.0.1 - Framework for running and organising tests, with HUnit and QuickCheck support  http://hackage.haskell.org/package/test-framework-0.8.0.1 (BryanOSullivan)
17:06:08 * hackagebot test-framework 0.8.0.2 - Framework for running and organising tests, with HUnit and QuickCheck support  http://hackage.haskell.org/package/test-framework-0.8.0.2 (BryanOSullivan)
17:06:11 <mm_freak> ocharles: are you there?
17:06:16 <Solarstorm> finally some haskell code that I seem to be able to comprehend :)
17:07:24 <pingu> Hi, can onyone tell me what <|> is called?
17:08:33 <Solarstorm> gotta get some sleep. thank you all very much for your help!
17:08:34 <Solarstorm> bye
17:13:02 <jfischoff> pingu: In my head I pronounce "<|>" as "or" , I don't know what other people call it :p
17:14:28 <yitz> dmilith: ghc-options: -threaded
17:14:53 <yitz> dmilith: isn't -threaded the default nowadays though?
17:16:07 <dmilith> yitz: unfortunatelly no
17:16:56 <dmilith> yitz: it works. thanks!
17:18:07 <startling> I'm always surprised when people talk about pronouncing operators in their heads.
17:19:08 <yitz> dmilith: np. i see, you're right, still single-threaded by default.
17:19:24 <dmilith> yup
17:19:54 <acowley> In my head, I pronounce "startling" as <*>
17:20:54 <yitz> acowley: interesting. i would say startling as ! and very startling as !!
17:21:15 <acowley> Good point, I will train myself to pronounce startling as $!
17:21:54 <startling> I prefer ??.
17:21:56 <hpc> guys! perl is a lazy-by-default language!
17:21:58 <elliott> startling is an op now?
17:22:03 <hpc> i can tell because every source file i see says "use strict"
17:22:22 <yitz> hpc: haha
17:22:51 <hpc> yitz: and when i remove the line errors disappear so it's clearly better to be lazy
17:23:45 <startling> hpc, that's how "undefined" works
17:31:08 <Conor__> hi
17:31:08 * hackagebot test-framework 0.8.0.3 - Framework for running and organising tests, with HUnit and QuickCheck support  http://hackage.haskell.org/package/test-framework-0.8.0.3 (BryanOSullivan)
17:31:10 * hackagebot test-framework-quickcheck2 0.3.0.2 - QuickCheck2 support for the test-framework package.  http://hackage.haskell.org/package/test-framework-quickcheck2-0.3.0.2 (BryanOSullivan)
17:31:42 <joelteon> "The package 'SDLTemplate' requires Cabal library version >=1.18.0 && >=0 but no suitable version is installed."
17:31:46 <joelteon> what's up with this?
17:31:52 <joelteon> I have Cabal 1.18.1 installed
17:36:09 * hackagebot test-framework-hunit 0.3.0.1 - HUnit support for the test-framework package.  http://hackage.haskell.org/package/test-framework-hunit-0.3.0.1 (BryanOSullivan)
17:36:45 <joelteon> Actually, I'd like to be able to find config.log
17:36:47 <joelteon> where is that
17:38:51 <lpaste> mdittmer pasted “haskell-platform-2013.2.0.0 build failure” at http://lpaste.net/94058
17:39:31 <mdittmer> Having trouble building the Haskell Platform with GHC 7.6.3 on Arch Linux.
17:39:51 <mdittmer> ( see lpaste: http://lpaste.net/94058 )
17:41:44 <ta479> mdittmer: why not just use the GHC+cabal in the repo
17:42:07 <mdittmer> You mean haskell-platform from AUR?
17:42:23 <ta479> no
17:42:33 <ta479> pacman -Sy ghc
17:42:54 <ta479> pacman -Sy cabal-install
17:43:05 <monochrom> if you can find haskell-platform in AUR, that should be just as good and simpler.
17:44:21 <mdittmer> monochrom: I thought so too, but it was giving me some kind of permission error. It created a "pkg" directory with permissions: "d---------" then complains that it can't create a subdirectory of "pkg" (no surprise). I'm not sure why the PKGBUILD is creating the directory with empty permissions though.
17:45:38 <lispy> I just ran into a really confusing template haskell error
17:45:56 <mdittmer> Anyway, this channel isn't for AUR build errors. I'll try the official cabal-install via packman.
17:46:02 <lispy> I guess the Fedora packaged GHC doesn't (by default) install the TH support and cabal happily downloads and installs a TH for you (which can't work)
17:46:16 <lispy> So you think TH is working until you use it and get weird errors
17:47:06 <elliott> it can work if it picks the right version
17:48:50 <lispy> elliott: good to know
17:49:04 <lispy> one thing that surprised me is that I've requested the haskell platform package
17:49:15 <lispy> that package should probably pull in all the ghc-foo packages
17:49:32 <lispy> at least the ones you would normally get with a ghc install
17:59:00 * brainacid reads Haskell - The Craft of Functional Programming
17:59:19 <brainacid> now here is a presentation of info that I can digest nicely
18:02:01 <logic_prog> i've been thinking reently and wondering -- is the reason that emacs runs on elisp because (1) types + functional programing was not as well developed at the time when eamcs was written or (2) text editors are fundamentally about manipulating state -- and mutable cons cells + dynamic bound vars mimic that perfectly
18:02:43 <Hrumph> logic_prog:  nothing like haskell existed when emacs was first conceived of
18:04:03 <sm> yi is a text editor written in haskell
18:04:21 <ion> @let data family Foo a; instance Functor Foo where { fmap = undefined }
18:04:22 <elliott> Hrumph: ML predates Emacs by a few years. not pure, but still closer to Haskell than Lisp.
18:04:22 <lambdabot>  Parse failed: Illegal data/newtype declaration
18:04:31 <elliott> anyway I don't see why the question was addressed to #haskell
18:06:28 <tac> Statically typed languages also have a lot more difficulty with the kind of reflection that emacs loves.
18:08:36 <BMeph> elliott: I think it's because we're so non-rabid, that folks know they'll get a good answer pretty soon. Even if the answer if "ask your question in #emacs." :)
18:13:21 <lispy> emacs is in lisp mostly because that's what Stallman knew and liked
18:13:43 <lispy> I really don't think it goes any deeper than that.
18:13:57 <ion> Today he would probably have used C# and .NET
18:14:19 <heatsink> Maybe mono
18:14:21 <lispy> Now, they've said they prefer dynamic scope because of the editing environment/plugins but these days there is a lexical scope plugin and most new plugins use it...
18:14:22 <acowley> Is there a Map newtype with a Monoid instance that mappends values at Eq keys?
18:18:19 <heatsink> How do I tell lambdabot to stop notifying me of old messages?
18:18:38 <shachaf> Messages get erased when you view them.
18:18:59 <ion> or change your nick forever.
18:19:13 <heatsink> Lambdabot's notified me of this same message several times...
18:19:32 <heatsink> only once each time I log in
18:19:48 <shachaf> Did you look at the message?
18:19:56 <heatsink> yes
18:20:08 <shachaf> It might be a bug due to lambdabot crashing.
18:20:15 <heatsink> ok then
18:20:23 <acowley> Or maybe lambdabot feels like you're not giving the message the attention it deserves
18:21:11 <heatsink> @help realtalk
18:21:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:22:46 <pavonia> she's fallen in love with you and wants your attention
18:27:57 <f-a> @type Map
18:27:58 <lambdabot> Not in scope: data constructor `Map'
18:28:08 <f-a> @import Data.Map
18:28:08 <lambdabot> Unknown command, try @list
18:30:46 <pavonia> f-a: @type only works with expressions, but Map is a type constructor
18:31:01 <f-a> thanks
18:31:20 <f-a> I was having some dirty talk with lambdabot in private
18:35:14 <Clint> k0ral: around?
18:44:31 <brainacid> Hey
18:45:04 <brainacid> I wanted to know the definitions of the base package. Where do I find that? Is it locally on my *nix box?
18:45:09 <brainacid> applicative, Hey
18:45:45 <brainacid> I mean the standard definitions. Is it Prelude.hs?
18:46:13 <eugenn> :t (>>=)
18:46:13 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:46:55 <pavonia> brainacid: Are you interested in the source code or just the list of functions, data types, etc.?
18:47:03 <erisco> why is there not a standard binary tree?
18:47:11 <brainacid> pavonia, yeah the list of functions
18:47:21 <pavonia> @hackage base
18:47:21 <lambdabot> http://hackage.haskell.org/package/base
18:47:30 <eugenn> :t first
18:47:30 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
18:48:17 <eugenn> :t extract
18:48:18 <lambdabot> Not in scope: `extract'
18:48:54 <eugenn> :t putStrLn
18:48:54 <lambdabot> String -> IO ()
18:49:21 <eugenn> :t liftM2
18:49:22 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:50:07 <pavonia> eugenn: you can also talk to lambdabot in private, /query lambdabot
18:51:59 <brainacid> pavonia, thanks
18:52:06 <t0rus> lol
18:53:56 <lispy> brainacid: Personally, I think the language report is better for learning what's in the Prelude: http://www.haskell.org/onlinereport/haskell2010/
18:54:08 <lispy> brainacid: just search that page for Prelude or look at the extensive module list at the end
18:54:20 <brainacid> lispy, I appreciate it. Thanks
18:55:43 <lispy> when I was learning Haskell our professor told us to go read the prelude and write our own implementations for things in it.
18:55:54 <lispy> It's actually pretty solid advice
18:56:59 <brainacid> lispy, Nice. That is good advice. Im very very new to programming. This is my first language
18:57:39 <brainacid> lispy, been on this computer for 3 days straight over 14 hrs each day. With breaks of course. But Im really passionate about it
18:57:48 <lispy> heh. well, good luck!
18:57:58 <lispy> Haskell is a good place to start
18:58:07 <lispy> Or maybe it's good place to end up?
18:58:20 <brainacid> lispy, I finally found a good book too. The Craft of Functional Programming
18:58:37 <lispy> I haven't read it, but I've always heard good things about it
18:58:41 <tabemann> starting first with haskell... means you don't have to unlearn, well, a lot of "bad habits" from learning imperative first
18:58:47 <Hermit> if you want a brutal learning wall that is... but maybe if it's your first language, it could be nicer, having no preconceptions to unlearn
18:59:11 <brainacid> Talk about a wall
18:59:35 <brainacid> I do very well playing with code rather than reading but then I get frustrated when I modify and I get errors...lol
19:00:26 <brainacid> I got a little project in mind to
19:00:34 <lispy> depending on what your goals are, it's also good to learn a typical scripting language like python, something for the web (so just javascript), something low level like C or assembly, something from logic like prolog, and maybe something OO like smalltalk
19:00:40 <tabemann> haskell may seem more brutal with its errors than some languages... but it also helps you catch a *lot* of errors that you'd have to wait till runtime to find, even if one counts typical "static"-typed languages like C or Java
19:00:41 <Hermit> I'm planning on teaching haskell to a friend that has 0 experience whatsoever with programming. Maybe it'll be overkill, but I'll be there guiding him with whatever I can
19:00:50 <Hermit> it should be a fun experiment
19:01:24 <johnw> actually, I'd think Haskell would make more sense in that context, but it's not as much about how computers operate as it is about what it means to apply functions to types and terms
19:01:30 <johnw>  s/but/because
19:02:16 <tabemann> it's a good idea to know C or assembly, but I would not recommend doing actual work in it except for highly performance-sensitive inner loop-type code and embedded code
19:02:36 <brainacid> Hermit, Hey maybe I could help with a donation and sit in your sessions
19:03:50 <brainacid> lispy, thats a long list. So you recommend I learn those too in order to help my grasp of Haskell
19:03:53 <lispy> tabemann: C has this lingua franca status these days, so it's nice for that reason IMO
19:04:00 <tabemann> yeah
19:04:03 <lispy> brainacid: Well, it all depends on your goals
19:04:16 <tabemann> it's good to know just so you can easily bind libraries others have written that are in it
19:04:24 <brainacid> lispy,  Dont have any. Its more like a hobby
19:04:29 <lispy> brainacid: if you want to be a "programmer" then mastering typical languages from different paradigms is important.
19:05:05 <lispy> brainacid: in that case, I'd just go where your interests take you
19:05:15 <tabemann> yeah; there's a lot of languages that I personally am not fans of, but would still consider it useful to know
19:05:16 <brainacid> lispy, I want to write a program that gives u total length of all video files in a directory. So I know how long to listen to 10 avi's
19:05:32 <tabemann> OO-type languages, both statically and dynamically typed, for instance
19:05:39 <Hermit> brainacid: these sessions would be in person, face to face... Still, I'll be glad to answer your questions from time to time. Don't forget that this very channel is an invaluable resource, as well as hoogle and the web. I've learnt most using these resources (even though I'm not very eager to ask about something...)
19:05:51 <tabemann> brainacid: you do realize what that entails, right?
19:06:15 <brainacid> tabemann, no sir. But that was the only problem I have that would like to use code to solve
19:06:40 <tabemann> what platform are you working on?
19:06:55 <brainacid> Hermit, Hey I agree. This channel rocks. And google and the web is amazingly psychotic
19:07:07 <brainacid> tabemann, Im on Ubuntu 12
19:07:15 <Hermit> brainacid: it was not a typo when I said hoogle
19:07:30 <brainacid> Hermit, oh..lol
19:07:39 <tabemann> okay, you need to find a API someone else has written to parse AVI files, and create bindings to access that API from within Haskell using the Haskell FFI
19:07:54 <tabemann> unless you plan on writing an AVI parser yourself, but that'd probably be more work
19:07:59 <brainacid> tabemann, wow! sounds like a project
19:08:25 <brainacid> I dont know what that means yet
19:08:28 <brainacid> parser
19:09:59 <tabemann> as you're just starting off, I'd probably suggest smaller projects than that, honestly
19:11:33 <tabemann> http://projecteuler.net/ < here is a good source of problems to work on as a beginner
19:11:39 <Hermit> brainacid: you could just go with avinfo for data extraction/formatting (it even has it's own simple scripting language), and parse that with haskell if you need more
19:12:04 * tabemann didn't know about avinfo
19:12:57 <tabemann> yeah, that'd be a lot easier than what I suggested
19:13:15 <Hermit> it'd be in the spirit of shell scripting, call a command, parse/process
19:13:24 <brainacid> Hermit, I guess I will know how to do it when I get proficient...lol
19:13:53 <tabemann> note that there are very good parsing tools out there for haskell, such as parsec
19:14:11 <brainacid> But that is basicly what I want to do. extract and present data
19:14:45 <Hermit> brainacid: it's pretty simple actually, you just need some (simple/one-sided) process interaction + some parsing code (which can be done with primitives or a full blown parser suite)
19:14:45 <brainacid> by the time im ready there will probably b 10 good parsers for haskell ...lol
19:15:16 <brainacid> you guys really inspire me
19:15:43 <brainacid> I wish I was rich so I can stay home and learn to code in all languages...lol
19:16:19 <tabemann> you don't need to know all languages, you just need to be able to *learn* any language if you have to
19:16:45 <Hermit> besides... by the time you learn your own ways, you wouldn't like to mess with all languages anyway....
19:17:02 <tabemann> yeah
19:17:05 <tabemann> a lot of languages suck
19:17:10 <Hermit> agreed
19:17:13 * Hermit stares @ perl
19:17:13 <tabemann> many of us only work with them because we have to for our jobs
19:17:24 * tabemann is a Java programmer at work and hates it
19:17:48 <tabemann> (and I worked a lot with C++ in the past too, also not my most favorite language)
19:18:40 <Hermit> to me, to this day there are only 3 great languages that I know (in no particular order): haskell, lisp, smalltalk
19:19:03 <dmj`> learning haskell will make you hate them more
19:19:15 <augur> does anyone know of a nice justificationist presentation of coinduction? im curious what their take on it is
19:19:20 <tabemann> my two favorite languages to work in the last decade has been OCaml, until I learned Haskell, and found I didn't like OCaml anymore either
19:19:34 <augur> it cant involve intros-and-elims in the usual fashion, because coinductive types just dont work like that
19:19:37 <tabemann> s/two favorite languages/favorite language
19:20:05 <augur> so im curious what the philosophical underpinnings are for what the coinductive rules are doinf
19:20:14 <tabemann> OCaml seems like such a crappy language compared to Haskell, with the only real thing going for it being parameterized modules
19:20:19 * Hermit never liked ocaml from the start, so didn't learn it
19:20:41 <tabemann> I only didn't learn Haskell long ago because I couldn't wrap my brain around monads at the time
19:21:28 <Hermit> once you do, the next thing are monad transformers and making huge stacks. Thank god mtl has typeclasses to avoid manual lifting
19:22:44 <tabemann> but yeah - once you learn Haskell, just about every language seems to suck in comparison, with probably the sole exception of dependently typed languages
19:23:31 <brainacid> Guess Im gonna stick with this then
19:23:33 <tac> yes. Compared to dependently typed languages, Haskell feels like a straightjacket.
19:24:27 <osa1> I think one really great thing about OCaml is js_of_ocaml program, which I don't understand how can be that underrated (people instead invent all kinds of x-to-js compilers that suck)
19:24:32 <tabemann> I have trouble wrapping my brain around things in dependently typed languages though... I mean, I don't get the type signatures of simple functions like function composition in Agda, for instance
19:24:54 * brainacid afk
19:25:18 <johnw> tabemann: i think you'll find that it's dependent function composition which gives you trouble in Agda
19:25:26 <johnw> non-dependent composition looks pretty much the same as the Haskell version
19:25:46 <tabemann> well yeah
19:26:22 <tac> tabemann: in dependently-typed languages, it's best to choose your battles carefully
19:26:59 <tac> tabemann: some type signatures read like mathematical theorems. Is it worth it to understand the meaning of the type? Or will it suffice to know what the thing does when executed?
19:27:42 <tac> But unlike mathematical theorems, you have to be explicit about *every* detail, and you have to forward declare *every* variable.
19:28:18 <tac> You can't just say "n + m = m + n", you have to go through the motions and write "(n m : Nat) -> n + m = m + n", for instance.
19:28:30 <tabemann> I get that
19:28:32 <tac> (Although that part would usually be an implicit parameter)
19:31:30 <tabemann> and then there is the pesky termination checking... yes I know it's important for ensuring that one can prove theorems with functions, but still...
19:31:45 <tac> Yeah.
19:31:53 <tac> There are some really awesome gains you could theoretically get in a total language though.
19:32:10 <tac> And in practice, I think most recursion is pretty tame.
19:32:18 <johnw> and the fact that constructors cannot construct a recursive type in a negative position, so encoding Free monads becomes tricky
19:32:27 <tac> Structurally recursive or "obviously" termination (subject to some decidable tactics)
19:32:31 <tabemann> I've elsewhere made the argument that one cannot ensure a language is *opertionally* total, though, without being able to prove the maximum memory usage a program will use
19:32:38 <johnw> I take Foo m a = m (Foo m a) for granted in Haskell
19:32:45 <tabemann> *operationally
19:32:50 <johnw> err, Foo m (Foo m a)
19:32:50 <tac> True
19:33:06 <tac> I think operational totality is probably best resolved by "stuffing everything into IO"
19:33:18 <tac> If your pure code runs out of memory, it ends up looking like an IO effect
19:33:49 <tabemann> and if you can't be operationally total, what do you get out of totality except neat theorem-proving capabilities?
19:34:09 <johnw> tabemann: well, for one thing you know it's not the code at fault
19:34:15 <tac> I have my own personal conjecture, at least
19:34:23 <johnw> because even if you could show operational totality, there are always async exceptions
19:34:29 <tac> That the issue of strictness and laziness is much easier to deal with in a total language.
19:35:03 <tac> Since total languages tend to have the church-rosser property, it doesn't matter how you evaluate something. As long as you keep reducing, you'll always hit normal form eventually.
19:35:14 <tabemann> and also, even if you theoretically have totality, couldn't you still construct programs that are technically total, but will take an obscenely long time to execute anyways?
19:35:36 <tac> You can therefore delegate strictness to a set of extra-program annotations or even fiddle with evaluation strategies dynamically at runtime.
19:36:23 <tac> Runtime is an extrinsic property of the type system (for virtually all type systems), so well-typed has no bearing on that kind of thing.
19:37:18 <tabemann> I know in turing-complete languages proving runtime is impossible, but total languages aren't turing-complete... so with what restrictions would it become possible to prove the runtime of a program?
19:37:29 <brainacid> SInce I dont know my goals and programming is more of a hobby, are there any benefits to know other languages or stick to haskell
19:37:41 <tac> In something like Agda, you cannot do any runtime performance costs directly
19:37:49 <tac> *however*, you can write a language with a type system that does capture that
19:37:53 <tac> and you could write an interpreter in Agda
19:37:58 <acomar> brainacid: learn one language first, then branch out
19:38:07 * tabemann agrees
19:38:12 <acomar> you'll want to learn a few different languages just to expand your horizons
19:38:16 <brainacid> acomar, ok then...sticking with haskell
19:38:20 <acomar> but it's best to focus at first
19:39:35 <tac> If you have totality, you have a sound logic, and if you can encode the invariants you *really* want in that logic, then you can guarantee those in turn.
19:40:04 <tabemann> I wonder just how restrictive a total language in which one can prove maximum memory usage and maximum execution time in would be
19:40:11 <tabemann> would it be worth it just to gain those characteristics?
19:40:13 <tac> (You can also have a very clean, arbitrarily clever compiler, without having to worry about warts like seq or unsafePerformIO)
19:40:31 <tac> Depends on your use case.
19:40:51 <tac> If you're doing embedded systems stuff for a private space flight corporation, maybe :)
19:41:03 <tabemann> that's the main realistic use case I can see for this, yes
19:41:09 <tabemann> as in embedded both matter
19:41:09 <tac> heh
19:41:30 <augur> ICFP vids? :D
19:41:34 <tac> the hard part is probably in designing a good model for what you mean by "performance"
19:41:55 <tac> Encoding that model in your favorite DTL is easy in comparison.
19:43:09 <tabemann> it seems like it would be easy to do... provided a program is a black box that takes no input
19:43:29 <tac> In an ideal system, perhaps :)
19:43:30 <tabemann> but... would you just be moving the execution into compile-time then, essentially?
19:44:06 <tac> what kinds of programs take no inputs?
19:44:20 <tac> if it's literally a constant, then yes, you can do all the execution at compile time
19:44:26 <tac> as long as you're happy with the size of your output
19:44:40 <tabemann> I figured a way to make memory usage provable without that... but it requires a memory model like that of C but with A) no recursion and B) no heap allocation
19:44:44 <prophile> only if the execution takes finite time
19:45:00 <tabemann> prophile: but it would, of course, as this would be a total language
19:45:01 <prophile> consider a square wave generator on an embedded device
19:45:08 <prophile> point
19:45:21 <tabemann> and there are ways to statically prove that programs are total
19:45:24 <dwcook> I'm trying to explain to someone why filterMap :: (a -> Maybe b) -> [a] -> [b] isn't a more specialized function than map :: (a -> b) -> [a] -> [b] but I don't think I can explain well. I know I can write filterMap in terms of map and vice versa. Can someone help me sort out an argument, or tell me I'm wrong if I am wrong?
19:45:30 <dwcook> (cc: yogurt_truck)
19:45:52 <kentroid> I really hate to ask such a simple question. but i've been working on this for like 2 hours. I have a function: drawSpriteSheet :: SDL.Surface -> SDL.Surface -> Int -> Int -> Int -> IO Bool
19:45:52 <kentroid> drawSpriteSheet screen sprites n x y = SDL.blitSurface
19:46:00 <kentroid> then I define a 2d array let world1 = [[1,1,1,1],[0,0,0,0],[2,2,2,2],[3,3,3,3]]
19:46:13 <kentroid> I can not figure out how to iterate over a 2d array to save my life..
19:46:18 <heatsink> map can't change the list's length, but filterMap can.  Doesn't that make filterMap more general?
19:46:31 <tabemann> the thing is, that memory model I thought of seems *really* restrictive
19:46:45 <tabemann> yes, it's how many people already program embedded systems
19:46:47 <dwcook> heatsink, in that sense, I would agree – map cannot be used to write filter, but filterMap can be.
19:46:56 <kentroid> each of the numbers represents a tile number in the spritesheet, and the x and y position should be calculated based on the x,yth position in the array.
19:47:15 * yogurt_truck fails to see how the type (a -> Maybe b) is not less generic (and therefore more specific) than the type (a -> b) O.o
19:47:42 <kentroid> mapM_ (drawSpriteSheet screen sprites n (n * 32) n) [0..10] for example draws a row of sprites
19:47:45 <startling> yogurt_truck, Maybe a exists for any a.
19:47:47 <johnw> doesn't "not less generic" mean more generic?
19:48:47 <johnw> yeah, Maybe Void has an inhabitant
19:48:59 <jmcarthur> yogurt_truck: i can convert any function (a -> b) to a function (a -> Maybe b), but i can't necessarily go the other way
19:49:45 <yogurt_truck> jmcarthur: that's what I'm saying
19:51:25 <jmcarthur> dwcook: i think that answers your question right there. if filterMap was a specialization of map then it could be implemented in terms of map
19:51:38 <dwcook> jmcarthur, it can be, actually. It goes either way.
19:51:41 <jmcarthur> dwcook: but in fact, it is the other way around
19:51:48 <jmcarthur> dwcook: i disagree
19:51:56 <jmcarthur> dwcook: map cannot change the length of the list, but filterMap can
19:51:57 <dwcook> filterMap f xs = catMaybes $ map f xs
19:52:07 <jmcarthur> dwcook: but you aren't just using map there
19:52:16 <dwcook> Okay, good point
19:52:18 <jmcarthur> you're doing "extra stuff" to the list afterwars
19:52:21 <jmcarthur> *afterwards
19:52:52 <jmcarthur> there are no arguments i can pass to map to get filterMap
19:53:01 <jmcarthur> but there are arguments i can pass to filterMap to get map
19:53:16 <dwcook> I see, so when we talk about which function is more specialized, all that matters is what arguments we pass?
19:53:54 <jmcarthur> i don't have a very formalized notion of this
19:54:01 <dwcook> Neither do I, thus my confusion
19:54:13 <jmcarthur> i would say that for functions this would be a decent rule of thumb
19:54:33 <yogurt_truck> what you pass to a function is the domain of the function. my point is that by making the domain of the function smaller, you are making it less generic, and I'm also assuming "less generic" implies more specialized
19:54:45 <yogurt_truck> but clearly I'm just confused xD
19:55:04 <dwcook> yogurt_truck, actually, I now disagree with the point that you're making the domain smaller.
19:55:11 <dwcook> yogurt_truck, because you can lift any a to a Maybe a.
19:55:24 <yogurt_truck> dwcook: because Maybe a is actually increasing the size of the domain right?
19:55:30 <dwcook> Yes.
19:55:33 <startling> Yep. By exactly 1.
19:55:35 <yogurt_truck> that might be the thing that's throwing me off
19:55:45 <startling> (Disregarding bottom.)
19:55:50 <yogurt_truck> yay!
19:56:03 * yogurt_truck sees the light
19:56:14 * yogurt_truck gives dwcook a cookie
19:56:31 * dwcook shares the cookie with #haskell
19:57:03 <dwcook> (Except those who have Do Not Track enabled, of course)
19:57:08 * zRecursive hope it is delicious cookie :)
19:58:10 <jmcarthur> one man's specialization is another man's generalization
19:58:32 <dwcook> As purely a curiosity, are there any two well known functions that generalize *each other*?
19:58:42 <dwcook> (i.e., they are equally powerful)
19:58:43 <jmcarthur> a more specialized function can do more with its arguments, but the user of the function can do less with the function
19:59:09 <startling> dwcook, foldMap and foldr?
19:59:41 <brainacid> SO i have to define my function types or can i leave it lazy
20:00:09 <startling> dwcook: I guess almost all the Foldable things are equivalent -- e.g. foldMap and toList
20:00:19 <dwcook> brainacid, you can usually leave off the type signature, though including it serves as a useful guide to you, the programmer, of what you meant.
20:00:25 <jmcarthur> brainacid: you usually can get away without writing out your type signatures
20:00:25 <dwcook> startling, hmm, interesting.
20:00:32 <jmcarthur> brainacid: but i recommend writing them anyway
20:00:44 <yogurt_truck> actually I'm not clear on this yet
20:01:14 <yogurt_truck> save me from my ignorance! D:
20:01:25 <startling> dwcook: there's also join + fmap and (>>=) I guess.
20:01:57 <dwcook> Hmm yeah, I actually thought of that a moment ago as well
20:02:23 <dwcook> yogurt_truck, what remains unclear?
20:03:10 <yogurt_truck> dwcook: the fact that you guys say the domain is not reduced when you go from `def foo[A](a: Option[A]) = a` to `def foo2[A](a: A) = a`
20:03:14 <jmcarthur> ap, liftA2, and  blah :: Applicative f => f a -> f b -> f (a, b),  with some combination of pure and fmap
20:03:45 <dwcook> yogurt_truck, if you give me any a -> b, I can give you back an a -> Maybe b simply by applying (Just .) to it.
20:03:48 <dwcook> Err
20:03:51 <yogurt_truck> dwcook: to.. from
20:03:52 <dwcook> okay yeah
20:04:23 <jmcarthur> :t \f -> f . Just
20:04:25 <lambdabot> (Maybe a -> c) -> a -> c
20:04:28 <dwcook> So any function you could've given me for map can be transformed in such a way that filterMap can use it
20:04:31 <jmcarthur> oops
20:04:32 <dwcook> But the reverse is *not* true
20:04:37 <jmcarthur> :t \f -> Just . f
20:04:38 <lambdabot> (a -> b) -> a -> Maybe b
20:04:43 <dwcook> You can't retrieve an a -> b from an a -> Maybe b
20:04:45 <jmcarthur> now write me the inverse ^^
20:05:11 <Connorcpu|Away> :t (Just .)
20:05:12 <lambdabot> (a -> b) -> a -> Maybe b
20:05:14 <startling> :t (fromJust .)
20:05:15 <lambdabot> (a -> Maybe c) -> a -> c
20:05:20 <dwcook> startling, :(
20:05:27 <yogurt_truck> dwcook: my obvservation is that `foo` literally accepts less values than `foo2`, is this not `foo` having a smaller domain than `foo2`?
20:05:31 <Connorcpu|Away> :t (. fromJust)
20:05:32 <lambdabot> (b -> c) -> Maybe b -> c
20:05:45 <dwcook> yogurt_truck, your observation is false; you've augmented b with an additional value, Nothing.
20:05:46 <startling> dwcook: jmcarthur said "inverse" !!
20:06:04 <brainacid> dwcook, jmcarthur copy that. thanks
20:06:06 <startling> a left inverse is a kind of inverse
20:06:14 <dwcook> startling, that's not an inverse, it's a(n even more) partial function (than usual)
20:06:23 <startling> dwcook, it is a left inverse of Just.
20:06:29 <dwcook> Oh, I see
20:06:34 <startling> dwcook, fromJust . Just is always valid.
20:06:42 <jmcarthur> it's a kind of inverse, just not what people normally mean when they don't specify
20:06:48 <yogurt_truck> dwcook: but there's a share of values that it now doesn't work on?
20:07:06 <dwcook> yogurt_truck, fromJust is partial because it's undefined on Nothing
20:07:09 <dwcook> > fromJust Nothing
20:07:10 <lambdabot>   *Exception: Maybe.fromJust: Nothing
20:07:15 <jmcarthur> it's the same as just comparing   a   with   Maybe a
20:07:25 <yogurt_truck> dwcook: and?
20:07:32 <jmcarthur> Maybe a  has more values than  a
20:07:40 <johnw> if you could get a -> b from a -> Maybe b, that would be equivalent to saying that the adjunction Mon -| Set is really an isomorphism
20:07:55 <dwcook> yogurt_truck, there's a mapping from a to Maybe a but there's exactly one value in Maybe a from which you can't retrieve an a
20:08:27 <dwcook> So that you can't turn every possible usage of filterMap into a usage of map
20:08:31 <yogurt_truck> dwcook: that's something else
20:08:36 <yogurt_truck> this is not about the usage
20:08:46 <Connorcpu> Just make sure you don't do it until you're sure it can't be Nothing, or if an error is acceptable if it is.
20:09:03 <startling> it depends if a is actually a Haskell forall a. or a metavariable I guess.
20:09:05 <yogurt_truck> you keep telling me I can turn X function to Y function, but that's not referring to my observation
20:09:11 <jmcarthur> you can even make the same argument taking _|_ into account.  Maybe a -> a  has to map Nothing to _|_, but if you try to then go back the other way you can't tell what kind of _|_ it is, so you can't tell whether to produce Nothing or _|_
20:09:15 <dwcook> Based on the very point of using filterMap, you would probably expect a Nothing in there somewhere
20:09:21 <jmcarthur> so information is necessarily lost going from  Maybe a -> a
20:09:35 <johnw> jmcarthur: yep, that's the adjunction argument in a nutshell
20:09:44 <dwcook> yogurt_truck, I don't see how it's not.
20:09:45 <jmcarthur> right
20:09:53 <dwcook> yogurt_truck, can you explain your thought again?
20:10:19 <jmcarthur> i guess actually there are three things mapping to _|_ in  Maybe a -> a
20:10:23 <dwcook> yogurt_truck, sorry, I might not be connecting my steps well enough.
20:10:25 <jmcarthur> _|_, Nothing, Just _|_
20:10:45 <dwcook> jmcarthur, it's sometimes convenient to pretend functions are total :)
20:11:03 <jmcarthur> dwcook: i'm just pointing out that assuming totality is not necessary
20:11:10 <dwcook> Fair enough
20:11:11 <jmcarthur> dwcook: the same points hold
20:13:24 <yogurt_truck> dwcook: ok. I have a function `def foo[A](a: A) = a`, this function takes all values. 42 is in its domain. Maybe 38 is also in its domain. you can _pass_ those values to it. Now there's `def foo[A](a: Option[A])`. Now cannot pass many many values to it. The question is: What happened to the domain? Is it smaller? Bigger? the same? Is the question nonsensical? Just that. I'm not talking about "can you get map from filterMap" or what
20:13:24 <yogurt_truck> ever.
20:13:56 <dwcook> yogurt_truck, yes, Maybe a is strictly smaller than b.
20:14:07 <dwcook> yogurt_truck, but Maybe a is in fact bigger than a.
20:14:09 <jmcarthur> yogurt_truck: wait, this scala (?) syntax is confusing. what is the domain here?
20:14:41 <startling> I think you guys are mixing definitions.
20:14:50 <yogurt_truck> jmcarthur: http://en.wikipedia.org/wiki/Domain_of_a_function
20:15:02 <jmcarthur> yogurt_truck: i know what a domain is
20:15:07 <jmcarthur> yogurt_truck: i don't know what your syntax means
20:15:25 <yogurt_truck> jmcarthur: so foo is not "defined for 43" once you say it only accepts Option[A] (Maybe a in haskell)
20:15:46 <jmcarthur> yogurt_truck: ... so the domain of your function is Option[A]?
20:15:49 <yogurt_truck> jmcarthur: right. `a` is the identifier. Option[A] is the type of the input
20:15:53 <dwcook> yogurt_truck, sorry, could you write your type signatures in Haskell syntax, if you know it?
20:15:53 <jmcarthur> okay
20:15:55 <yogurt_truck> jmcarthur: yes
20:16:02 <jmcarthur> so in haskell,   Maybe a -> a
20:16:07 <jmcarthur> vs.   a -> a
20:16:10 <jmcarthur> right?
20:16:18 <yogurt_truck> dwcook: foo :: Maybe a => a -> a
20:16:29 <startling> yogurt_truck: that's not right.
20:16:31 <yogurt_truck> dwcook: versus just foo :: a -> a
20:16:33 <jmcarthur> yogurt_truck: that signature is not valid unless you make a Maybe type class
20:16:40 <yogurt_truck> sorry
20:16:48 <yogurt_truck> yeah, make that Maybe a -> a
20:16:59 <brainacid> Im in the path where this is but i get error
20:17:13 <jmcarthur> now, is it important to your argument that  a  be polymorphic?
20:17:18 <brainacid> trying to import Pictures and use invertColor function
20:17:30 <brainacid> Not in scope error
20:18:06 <brainacid> got it
20:18:13 <brainacid> used :l instead
20:18:46 <dwcook> yogurt_truck, are you asking whether a -> a has "more" or "less" values than Maybe a -> a has?
20:20:04 <startling> That's like asking if [1..] is longer than [0..], I think.
20:20:53 <dwcook> I am too confused to answer that question regardless, I think partly because I don't know how to handle partiality well.
20:21:12 <dwcook> Though, perhaps if a were a specific, finite type…
20:21:17 <jmcarthur> if we assume we can instantiate  a  to some  A...   A -> A  has  A^A  inhabitants, but  Maybe A  has  1+A -> A = A^(1+A)  inhabitants.  if  a  has to remain polymorphic, i'm not sure how to count the inhabitants because i am not good at formally thinking about parametricity.
20:21:36 <jmcarthur> i guess i could guess...
20:21:42 <yogurt_truck> startling: I'm not asking that kind of question
20:22:02 <jmcarthur> if we assume totality,  a -> a  has one inhabitant, and  Maybe a -> a  has zero inhabitants
20:22:16 <jmcarthur> but i guess partiality is the interesting case
20:22:22 <startling> is a a metavariable or a forall a.?
20:22:23 <yogurt_truck> startling: I'm just asking what does it mean (domain-wise, and generality-wise) that a function is defined for _all_ values _ever_, and another isn't
20:22:37 <jmcarthur> yeah, this is a crucial detail
20:22:56 <startling> forall a. Maybe a -> a has zero inhabitants.
20:23:11 <startling> Maybe Int -> Int has a lot of inhabitants.
20:23:13 <yogurt_truck> (the former function being the one taking `a`, and the latter being the one constraining the input type to `Maybe a`)
20:23:35 <dwcook> @type maybe
20:23:53 <dwcook> RIP lambdabot
20:24:06 <augur> jmcarthur: proof theoretic approaches to enumerating the inhabitants of parametrically polymorphic types are interesting :)
20:24:30 <jmcarthur> augur: are they actually interesting or just complicated? ;)
20:24:37 <augur> they're interesting!
20:24:39 <dwcook> interesting ~ complicated
20:24:44 <jmcarthur> ah, then i'm interested!
20:24:48 <jmcarthur> dwcook: definitely not
20:25:10 <augur> if you approach it from a verificational perspective, it becomes relatively easy to show that there's exactly one inhabitant of the type forall a. a -> a
20:25:12 <jmcarthur> dwcook: tax codes are complicated
20:25:13 <dwcook> jmcarthur, if they're both fully polymorphic type variables… :)
20:26:04 <startling> yogurt_truck: I don't think "generality" is well-defined.
20:26:25 <startling> "domain-wise", they just have different domains.
20:30:32 <NemesisD> design question: i've got to represent an API call that could succeed or be an error. typically i've been using a sum type for that data Resp = Success .. | Failure ...
20:31:04 <startling> NemesisD, what's wrong with Either?
20:31:20 <NemesisD> i've been thinking recently it would be better to have them be separate types and have newtype Resp = Resp { result :: Either Failure Success} so i can derive monad, applicative and all that fun stuff
20:32:12 <applicative> well for that you would need a parameter on Resp, Resp a
20:32:14 <NemesisD> im not sure but i think using a newtype over a raw either is still preferable to make less problematic instances
20:32:30 <applicative> Either Failure is already a monad ;)
20:32:31 <NemesisD> why would i need a parameter?
20:32:43 <NemesisD> oh, i wouldn't literally be using Failure
20:32:44 <applicative> for the Monad instance
20:32:48 <NemesisD> gonna have a sum type for failures
20:33:17 <applicative> Either MyFailureSumType is already a monad
20:33:26 <NemesisD> data TrackingError = EndOfCheeseError | CosmicRays
20:34:42 <applicative> i was just thinking that the advantage of Either of EitherT or ErrorT or whatever is that there are existing combinators and understanding
20:34:48 <startling> NemesisD, this sounds like you're falling into the "make a type for everything" error.
20:35:17 <NemesisD> startling: is that necessarily bad?
20:36:06 <startling> I don't know. I always get burned out when I try it.
20:36:35 <kentroid> nevermind, figured it out!
20:36:38 <NemesisD> i float around a bit as i'm still developing my haskell habits but i've heard advise towards disambiguating types
20:36:43 <Ralith_> NemesisD: I'd just use ErrorT
20:37:49 <NemesisD> Ralith_: i thought errort was considered harmful
20:37:54 <Ralith_> is it?
20:38:04 <applicative> EitherT is the true path
20:38:23 <Ralith> NemesisD: who told you that?
20:38:29 <prophile> ListT is harmful
20:38:33 * applicative is pretending to wisdom on the matter
20:38:34 <prophile> ErrorT is not
20:38:48 <Ralith> prophile: why's ListT harmful?
20:38:49 <applicative> prophile: ListT is the awesomest type
20:39:05 <applicative> true ListT good; false ListT bad
20:39:11 <prophile> Ralith: it doesn't obey the monad laws unles the underlying monad happens to be commutative
20:39:23 <NemesisD> ah maybe i read into it too much http://hackage.haskell.org/package/either-3.4.1/docs/Control-Monad-Trans-Either.html
20:39:32 <prophile> by ListT I mean mtl ListT
20:39:40 <applicative> okay, yick
20:39:52 <Ralith> prophile: 'happens to be'? Isn't it a documented requirement?
20:40:01 * applicative has been fiddling with pipes-listt
20:40:10 <prophile> Ralith: yes, but it does mean it isn't a real monad transformer
20:40:28 <applicative> ListT proper is a perfectly good monad transformer though
20:41:21 <Ralith> prophile: why hasn't mtl been patched?
20:41:37 <Ralith> edwardk doesn't seem the type to let that lapse for no good reason
20:41:41 <applicative> its not in mtl its in transformers, or am i wrong
20:41:45 <Ralith> ?win 21
20:41:54 <Clint> it's in both
20:41:55 <prophile> http://hackage.haskell.org/package/mtl-2.1.2/docs/Control-Monad-List.html#v:ListT
20:42:12 <NemesisD> i think the objection i had to using a raw Either was that I think its kinda sketchy to write instance SomeTypeclass (Either OneType AnotherType)
20:42:16 <prophile> Ralith: backwards compatibility, I'd presume
20:42:32 <Ralith> prophile: what sort of use might be broken by the change?
20:43:06 <applicative> right it is a re-export of import Control.Monad.Trans.List from transformers
20:43:21 <prophile> Ralith: I'm guessing runListT has  different type
20:43:32 <NemesisD> because it necessarily eliminates context from that instance, you're defining an instance for the pairing of those two values
20:43:43 <NemesisD> a newtype can provide some semantic context
20:44:45 <applicative> i think people, Tekmo in particular, tried to convince Dr Paterson to put a real ListT in transformers but no
20:44:49 <applicative> similarly with FreeT
20:45:10 <Ralith> aw
20:47:16 <NemesisD> i guess i could use a newtype internally and return the either
20:50:13 * applicative proposes a new effectful type String = MonadIO m => ListT m Char to replace those boring old Strings
20:50:21 <applicative> then echo = stdout stdin
20:50:36 <edwardk> ?
20:50:40 <applicative> haha
20:50:51 <Ralith> picked a good time to join
20:50:52 <tommd> It appears cabal-install 1.1
20:51:25 <tommd> It appears cabal-install 1.18.0.2 (w/ Cabal 1.18.1) can not sdist a package with 'custom' as the build-type.
20:51:31 <applicative> stdoutLn :: MonadIO m => ListT m String -> m ()
20:51:34 <tommd> Can anyone confirm this is expected behavior?
20:51:47 <applicative> stdinLn :: MonadIO m => ListT m String
20:51:50 <tommd> It's preventing me from using my normal work-flow to release a package
21:03:18 <applicative> tommd: i seem to have no trouble doing cabal sdist on e.g. https://github.com/basvandijk/lifted-base/blob/master/lifted-base.cabal
21:08:49 <tommd> applicative: Ok, thanks.  This behavior is very odd.
21:16:40 <applicative> edwardk: here is an example of ListT stdout foolishness following something like Tekmo's scheme http://sprunge.us/FDHG?haskell
21:20:26 <shachaf> Maybe libraries@ should be split up.
21:21:41 * hackagebot network 2.4.2.0 - Low-level networking interface  http://hackage.haskell.org/package/network-2.4.2.0 (JohanTibell)
21:24:55 <dmj`> Trying to configure template reloading in snap. Did 'cabal install snap', 'snap init', 'cabal install -fdevelopment', and keep getting "flags: '-static' not recognized" when I run, any ideas?
21:48:26 <joelteon> how do I transform a string into a list of character ranges?
21:50:31 <heatsink> Can you give an example?
21:51:03 <joelteon> "abdefh" -> [('a','b'), ('d','f'), ('h','h')]
21:51:43 <heatsink> Do the characters have to be in order?
21:52:09 <joelteon> Well I'm just trying to convert a list I already have into a more readable format
21:52:14 <joelteon> And they are in order, yeah
21:52:36 <heatsink> It looks like you can process the string in one pass
21:52:52 <heatsink> Keep extending the current range until the next character isn't part of the range
21:52:59 <heatsink> then start a new range
21:54:55 <heatsink> can you write that?
21:57:50 <joelteon> yeah, i can
21:58:19 <heatsink> alright, then I'm going to sleep
21:59:01 <prophile> w 14
22:21:39 <joelteon> hey, for anybody interested, here's a vim regex that matches operators without qualified names: https://gist.github.com/anonymous/4de97508c9362384f19d/raw/0bce8768c75392f9eb123441a648ee7ed70fe85a/vim.txt
22:21:47 * hackagebot lvish 1.0.0.4 - Parallel scheduler, LVar data structures, and infrastructure to build more.  http://hackage.haskell.org/package/lvish-1.0.0.4 (RyanNewton)
22:22:55 <zRecursive> :t (<*)
22:24:18 <nisstyre> joelteon: how did you generate that?
22:24:44 <nisstyre> should I put that monstrosity in my .vimrc?
22:25:10 <joelteon> nisstyre: skill
22:25:21 <joelteon> well, if you put it in your vimrc, it won't really do anything
22:25:24 <joelteon> might cause a syntax error
22:25:30 <joelteon> you'd have to use it in a context that expects a regex
22:25:38 <nisstyre> I mean as a keybinding to search for operators
22:25:40 <nisstyre> or whatever
22:26:16 <joelteon> yeah, go for it
22:26:21 <joelteon> i haven't tested it extensively
22:26:28 <nisstyre> hmm ok
22:30:15 <cmears> > 1
22:30:27 <cmears> ):
22:35:49 <xico> i'd like to define a data structure to have default arguments. yet i would also like default type on them. is there a way to translate this function to have default types (like Double)?   mydata :: Num a => MyData a { myval = const 0 }
22:39:50 <pavonia> xico: In what situation would that default type be used?
22:41:20 * lispy_ thinks someone should build something on top of lvish called quenya
22:41:27 <xico> in case i do not provide a type (like using mydata directly, i would still like to access 'myval' as x -> Double, not just "Num a => x -> a"
22:42:13 <joelteon> okay, I've got a regex that matches qualified module names now, but it's 17,000 characters long
22:43:52 <pavonia> xico: Haskell has a default keyword to set type defaulting for all functions defined in a module. But I'm not sure this is what you really want
22:44:21 <pavonia> xico: Maybe you could explain a bit why you want that behaviour
22:44:24 <xico> pavonia: i randomly tried without luck
22:44:31 <xico> default(Double)
22:44:57 <lispy> that defaulting mechanism is for literals
22:45:02 <lispy> it won't apply to Num a
22:45:23 <lispy> xico: are you familiar with read?
22:45:25 <lispy> :t read
22:45:33 <xico> lispy: absolutely not
22:45:35 <lispy> doh, no lambdabot
22:46:10 <lispy> xico: the idea is that, when you have something of type "Num a => MyData b -> a" the caller gets to pick the instance of Num.
22:46:28 <lispy> xico: so if at the call site, it must be a Double, then everything would work out
22:46:53 <lispy> xico: does that make sense?
22:47:12 <lispy> xico: defaulting it to Double would actually make it so that it only works for Double
22:47:21 <nisstyre> fyi it's called "return type polymorphism"
22:47:21 <lispy> Which is probalby not what you want
22:48:07 <xico> indeed
22:50:10 <latro`a> type inference gives the most general type that checks
22:51:16 <latro`a> this goes both ways, too; if you force it to give Double, that will necessarily be the most general type that will check
22:51:31 <latro`a> (because of an explicit constraint or otherwise)
22:51:51 * hackagebot citation-resolve 0.4.1 - convert document IDs such as DOI, ISBN, arXiv ID to bibliographic reference.  http://hackage.haskell.org/package/citation-resolve-0.4.1 (TakayukiMuranushi)
22:51:53 <latro`a> (this isn't really any different from what lispy said, just a different way of saying it)
22:52:01 <dolio> Except when it doesn't. :)
22:52:20 <latro`a> hm?
22:52:33 <latro`a> afaik without extensions on, you'll get the most general type each time
22:52:38 <dolio> There are certain cases where Haskell's inference will fail to give the most general type.
22:52:49 <latro`a> can you give one without extensions?
22:52:56 <dolio> Yes.
22:53:04 <dolio> @type let g x = g () in g
22:53:15 <latro`a> eh
22:53:29 <latro`a> I've almost stopped thinking of NoMonomorphismRestriction as an extension
22:53:36 <dolio> Well, suffice it to say that the answer there is g :: () -> b
22:53:37 <latro`a> can you give one that doesn't involve the MR?
22:53:46 <dolio> That doesn't involve the monomorphism restriction.
22:53:50 <latro`a> oh?
22:54:03 <dolio> It is a fundamental limitation of Hindley-Milner type inference.
22:54:07 <latro`a> oh, I see
22:54:10 <Saizan> no MR, you just don't allow polymorphic recursion
22:54:18 <latro`a> the maximal answer is a -> b
22:54:19 <Saizan> (without a signature)
22:54:44 <dolio> The problem is that the domain of g gets unified with () before generalization happens.
22:54:49 <latro`a> rght
22:54:50 <latro`a> *right
22:55:08 <dolio> So you have to tell it that it should be more general beforehand, which is an extension of Hindley-Milner.
22:55:42 <dolio> Which adds the name Mycroft, I think?
22:55:53 <lispy> hmm
22:55:57 <lispy> (oh, nice pun!)
22:56:00 <latro`a> are there less pathological examples than that one? that one won't terminate
22:56:41 <dolio> Yes, but it's hard to generate examples that actually type check.
22:56:52 <latro`a> well, that type check with a signature
22:56:53 <dolio> Many will just trigger the occurs check.
22:57:16 <dolio> I guess it's not that hard.
22:57:52 <latro`a> I'm trying to think of a function that is perfectly "well-defined" for certain arguments but which will not let you call it on those arguments without an explicit signature
22:57:55 <dolio> g 0 x = x ; g n _ = g (n-1) ()
22:58:20 <latro`a> uhh...
22:58:31 <dolio> Actually, maybe that doesn't work.
22:58:41 <latro`a> yeah, that doesn't look like it works, or at least it doesn't do what I meant
22:58:49 <dolio> g 0 _ = "hello" ; g n _ = g (n-1) ()
22:59:14 <latro`a> interesting
22:59:41 <latro`a> so for that, g :: Num a => a -> b -> c is the maximal type
22:59:50 <dolio> c = String
22:59:51 <latro`a> erm
22:59:52 <latro`a> yeah
23:00:06 <latro`a> but Num a => a -> () -> String is the inferred type
23:00:11 <dolio> Yes.
23:00:16 <latro`a> I see
23:00:38 <latro`a> and with the signature, you could actually call, say
23:00:40 <latro`a> g 10 4
23:00:44 <latro`a> and get "hello"
23:00:45 <dolio> Yes.
23:01:38 <latro`a> my statement is "morally correct", then :p
23:03:52 <dolio> I wonder if you can do better via some algorithm that involves intersection types.
23:04:32 <dolio> Infer  'a ∪ () -> b' and then simplify to 'a -> b'.
23:04:38 <dolio> Or something.
23:41:32 <techtangents> Hi. I have a question. If Haskell is all pure functional programming, why does the GHC RTS have a heap? Why isn't everything just passed on the stack? In what scenarios does heap allocation arise? I don't need hardcore details, just a basic overview.
23:43:57 <copumpkin> because nothing happens immediately
23:44:01 <copumpkin> stack is not used in the way other languages use it
23:44:08 <copumpkin> when you write something down, what is stored is a description of how to do it
23:44:21 <lispy> techtangents: we use the heap for sharing
23:44:21 <Saizan> also, most stuff is passed by reference
23:44:21 <techtangents> Ok. Makes sense. Thanks!
23:44:30 <Saizan> and you have closures etc.. dataflow is not simply nested
23:44:30 <lispy> yeah, the stack is mostly references to the heap (and, also instructions for the next reduction step, I think?)
23:44:32 <lispy> it's been too long since I reviewed the gmachine details :(
23:44:33 <shachaf> lispy: Just read generated code.
23:45:20 <erisco> trying to implement a kdtree I accidentally made a sort somehow
23:46:29 <erisco> ah because I always choose the higher value to be the root
23:46:49 <adnap> Where is lambdabot?
23:46:50 * hackagebot authoring 0.1.0.0 - A library for writing papers  http://hackage.haskell.org/package/authoring-0.1.0.0 (TakayukiMuranushi)
23:47:32 * hackagebot citation-resolve 0.4.2 - convert document IDs such as DOI, ISBN, arXiv ID to bibliographic reference.  http://hackage.haskell.org/package/citation-resolve-0.4.2 (TakayukiMuranushi)
