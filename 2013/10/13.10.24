00:19:47 <individual> how do I match a non-empty list without ghc saying "Defined but not used: `foo'"
00:20:15 <individual> I've been using (x:_)
00:21:03 <johnw> ?
00:22:24 <sopvop> first match empty list, any other match will be non empty
00:26:13 <notdan> individual: (_:_) perhaps?
00:28:27 <individual> notdan: I was afraid it was too lazy but it works, thanks
00:43:26 <johnw> (_:_) is exactly as lazy as (x:_)
00:44:01 <johnw> the fact that you name the first element does not cause it to be evaulated
00:44:31 <arkeet> _ behaves just like any other variable in a pattern
00:44:35 <arkeet> except it doesn't bind a name to anything
00:51:01 * hackagebot OpenGL 2.9.1.0 - A binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGL-2.9.1.0 (SvenPanne)
00:56:45 <cch> hi, any also find that mongoDB package is too slow, I have two programs that are almost the same, which one dumps document to stdout, the other one insert into mongodb, and the first one is hundreds times faster than the mongodb one.
00:57:09 <cch> any one has ideas to tune the second one ?
00:59:19 <frx> how can I expand "./" to a full path?
00:59:27 <johnw> frx: canonicalizePath
00:59:43 <frx> thanks
01:19:29 <f-a> maybe it was all in my mind, but is there a "haskell teaching ladder" (i.e. a place wher eyou can submit files for code reviews and review code yourself?)
01:21:43 <alexander__b> what on earth do you import to satisfy "Not in scope: data constructor `Color'" (it's gloss)?
01:22:02 <alexander__b> "import Graphics.Gloss.Data.Color (Color)" satisfies "Not in scope: type constructor or class `Color'"
01:22:21 <f-a> constructor, alexander__b
01:22:29 <f-a> Color (..)
01:23:17 <f-a> with Color you can: add type sigs. With Color (..) you import the constructors too (so you can pattern match/construct it). Is it clear?
01:23:43 <alexander__b> right it's in Picture (Color).
01:24:27 <f-a> so Picture is the data type and Color the constructor?
01:24:35 <frx> is there something like nubByM?
01:25:08 <alexander__b> f-a: I think so.
01:25:23 <alexander__b> it builds and works, so it would appear to be correct.
01:25:43 <f-a> what have you put in the import?
01:25:50 <frx> @hoogle (a -> a -> IO Bool) -> [a] -> IO [a]
01:25:51 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
01:26:17 <alexander__b> f-a: "import Graphics.Gloss.Data.Color (Color)" and "import Graphics.Gloss.Data.Picture (Picture (Translate, Color))"
01:26:54 <f-a> very good
01:27:20 <mr-> @src nubBy
01:27:20 <lambdabot> nubBy eq []             =  []
01:27:20 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
01:28:16 <frx> it removes duplicates
01:29:41 <alexander__b> f-a: would you happen to know what's wrong with import Graphics.Gloss.Data.Picture (Picture (Color, Translate) circleSolid)?
01:29:55 <f-a> a missing comma
01:29:59 <alexander__b> hurr
01:30:00 <f-a> after Translate)
01:30:08 <alexander__b> thanks :-)
01:36:50 <peteretep> So at work I've taken the questionable path of teaching Haskell using The Little MLer
01:37:22 <peteretep> When we're finished with the book, people will have a reasonable understanding of types, of solving problems using recursion, and of
01:37:34 <peteretep> pattern matching
01:37:44 <peteretep> But won't have learned very much Haskell syntax
01:37:54 <f-a> why are you using the MLer in the first place
01:38:04 <peteretep> f-a: Because no-one wrote "The Little Haskeller"
01:38:18 <eikke> peteretep: once you grasp the concepts, syntax shouldn't be an issue, right
01:38:20 <notdan> well it's a good book
01:38:30 <peteretep> eikke: I think that's probably true
01:38:37 <peteretep> I am looking for a suitable set of exercises from that point on
01:38:58 <peteretep> that get increasingly difficult, but assume intelligent and well motivated developers with access to Google and a tutor who knows a few pieces of Haskell
01:38:58 <f-a> well, learn you a haskell for greater good?
01:39:02 <notdan> You won't graps things like typeclasses though, unless you read some additional stuff
01:39:07 <peteretep> notdan: agreed
01:39:17 <eikke> although, while I read 'The little MLer' myself a couple of years ago and consider it a fairly good book, I fear it might considered too 'boring' by the current generation of brogrammers, and ergo 'FP must be boring'
01:39:26 <f-a> and haskell is strict, so there is a little hurdle more
01:39:39 <eikke> f-a: uh? I didnt get that memo :)
01:39:41 <notdan> non-strict* you mean?
01:40:01 <f-a> eh
01:40:01 <peteretep> eikke: I dunno, I consider it to be much /less/ boring than anything else I've looked at
01:40:02 <f-a> no
01:40:11 <eikke> peteretep: LYAH?
01:40:17 <peteretep> Learn You A Haskell
01:40:17 <f-a> I meant pure
01:40:24 <peteretep> gah
01:40:25 <peteretep> sorry
01:40:28 <peteretep> I am confusing myself
01:40:36 <peteretep> I was writing that LYAH was more boring to me
01:40:40 <f-a> is it?
01:40:42 <notdan> eikke: it should have been called "The ML ninja" or some bs like that
01:40:43 <peteretep> Because it was a long list of syntax and so on
01:40:45 <f-a> what about real world haskell?
01:41:11 <peteretep> eikke: Then I forgot I hadn't typed that acronym in yet, and assumed you were asking me what it meant. It's early morning here, still.
01:41:31 <eikke> notdan: 'The 5 minute Ninja Guide to Master ML'
01:41:45 <peteretep> Anywho, what we (I) love about The Little MLer is that it's a set of exercises that get harder and harder
01:41:45 <eikke> np
01:41:46 <notdan> eikke: heh
01:42:01 <peteretep> And I would like a similar set I can present to people
01:42:02 <f-a> I don't want to be a jerk, but if you want to learn A, you should learn A
01:42:07 <eikke> peteretep: there's the 99 bottles thing or something as well
01:42:14 <nexx> Early morning? Isn't that in the Atlantic at the moment?
01:42:15 <f-a> unno, you could throw 99 problems at them
01:42:20 <f-a> or euler stuff
01:42:30 <peteretep> f-a: Thankyou. I realized that was your opinion when you stated it at the beginning.
01:42:41 <notdan> LYAH does have excercise too, doesn't it?
01:42:55 <f-a> some
01:42:57 <peteretep> notdan: yes, but ones that bored the pants off me
01:43:26 <f-a> write some exercises yourself?
01:43:34 <peteretep> 99 Questions looks interesting
01:43:36 <eikke> whilst Euler is nice, it can get depressing for some if you dont 'get it', not related to any programming language but from an algorithmic PoV
01:43:47 <f-a> ^--- agree
01:43:51 <bartavelle> I'd even say mathematical PoV ...
01:43:56 <f-a> but 99, most of them I found useful
01:43:59 <peteretep> Yeah, I was going to say Euler is too maths
01:44:05 <bartavelle> tons of questions related to the totient function and stuff like that
01:44:12 <f-a> *and* they have been solved in the wiki
01:44:15 <f-a> like, commented and all
01:44:25 <eikke> and then, some consider 'FP' to be hard, whilst they wouldnt be able to solve the same problem in $bestknownlanguage
01:44:31 <notdan> Hm. I myself most of the Haskell stuff from the lecture notes. Have you checked http://www.seas.upenn.edu/~cis194/lectures.html ?
01:44:47 <notdan> It's Brent Yorgey lectures, they are rather nice actualy
01:47:21 <Cale> Then again, how do you go through life without learning all about the totient function somewhere along the way?
01:48:40 <pharaun> i can't find that "keynote on typeclass by don" i think
01:48:42 <f-a> or you could try that (write you a scheme in x days)
01:48:51 <bartavelle> Cale, well, I have to admit I wouldn't know anything about it if it wasn't for Euler
01:49:02 <peteretep> f-a: That's what The Little Schemer is for
01:49:24 <alexander__b> http://hackage.haskell.org/package/gloss-1.8.0.1/docs/Graphics-Gloss-Interface-Pure-Game.html how do I import KeyUp? it's apparently not at Key (SpecialKey (KeyUp)) heh
01:49:51 <eikke> pharaun: wasnt that keynote by spj?
01:50:03 <pharaun> spj? lemme check
01:51:07 <pharaun> http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-retrospective/ECOOP-July09.pdf
01:51:16 <pharaun> eikke: ^ i think this was the one i was looking for
01:51:24 <eikke> Classes, Jim, But Not as We Know Them
01:51:38 <pharaun> there's another one?
01:51:48 <f-a> peteretep: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours this I meant
01:52:08 <pharaun> eikke: ahh thanks
01:52:14 <pharaun> i'm going to dig up a source of this now
01:52:29 <f-a> alexander__b: KeyUp is a constructor, SpecialKey the data-type. Do you get the difference between the two?
01:53:14 <f-a> import ( DataType (Constructor, Contstructor, ...) ) -- or DataType (..) for them all
01:54:23 <alexander__b> f-a: ohh. yes, the problem was that I needed the constructor for SpecialKey for something else, so I got confused.
01:54:42 <alexander__b> i.e. I needed both Key (SpecialKey) and SpecialKey (KeyUp).
01:55:39 <f-a> I should probably not tell you this, but for testing purposes just go import Some.Module
01:56:00 <f-a> it will import the importable, you can tailor it when you are sure on what you want
01:57:00 <f-a> peteretep: or this https://en.wikibooks.org/wiki/Haskell
01:57:08 <pharaun> eikke: yep that's the one, thanks :)
01:57:20 <pharaun> i knew i heard/saw it years ago but wasn't for sure
01:57:22 <alexander__b> f-a: this is not for testing. I posted my game on reddit and people told me to use explicit imports. the commit is specifically for teaching myself explicit importing.
01:57:48 <f-a> oh
01:58:12 <f-a> well, link to the reddit game, me wants to play :þ
01:58:27 <pharaun> http://www.reddit.com/r/haskell/comments/1p03cw/my_first_haskell_game/ ?
01:58:36 <alexander__b> pharaun: that one, yes.
01:58:47 <pharaun> hah just now saw it, will be reading it soon
01:59:32 <alexander__b> pharaun: couldn't have done it without #haskell, so I'd be honoured.
02:17:15 <pharaun> oh gloss
02:17:21 <pharaun> i haven't sat down and played with that yet
02:20:31 <pharaun> alexander__b: HA troll physics
02:20:40 <alexander__b> pharaun: :-D
02:21:06 <alexander__b> pharaun: every line counts to make haskell look like a popular language on github. ;-)
02:21:23 <pharaun> my repo is mostly haskell by now so... ;p
02:22:15 <pharaun> am not familiar with gloss, but it looks like a start :) I'll dig into it more when i have time. i should pick up on gloss anyway
02:22:43 <pharaun> from my dig through it seemed readable enough for me to poke at :D that's always a win
02:23:43 <pharaun> and with that, nini
02:51:41 <colluphid> hey im having some difficulty getting my sieve to work http://lpaste.net/94729
02:52:18 <colluphid> it just prints the prime seed values 2, 3, 5, 7 then hangs
02:55:20 <f-a> what is minus'?
02:55:35 <absence> when unsafePerformIO is used in a non-IO monadic action, is it somehow possible to access the "outer" monad from the IO action passed to unsafePerformIO?
02:56:06 <colluphid> f-a: http://hackage.haskell.org/package/data-ordlist-0.4.5/docs/Data-List-Ordered.html#v:minus-39-
02:56:46 <Saizan> absence: nothing built-in
02:57:14 <absence> Saizan: is it even possible?
02:58:02 <Saizan> absence: you can usually pass the relevant info to the IO action explicitly
02:59:48 <davd> why does atomically (fmap check (return False)) terminate when atomically (return False >>= check) doesn't?
03:00:31 <absence> Saizan: yes, but what about performing  the non-IO action? e.g. myreader = unsafePerformIO (ask >>= writetofile) -- obviously the types don't allow that directly, but i'm not sure how to work around it, or if it's at all possible
03:00:33 <davd> (atomically and check are operations from Control.Monad.STM)
03:00:38 <Saizan> davd: the former doesn't run the action (check False) it merely returns it as the result
03:01:18 <absence> Saizan: sorry, myreader = return $ unsafe.....
03:01:42 <Saizan> absence: myreader = do x <- ask; return $! unsafePerformIO (writetofile x) -- something like this, maybe
03:01:57 <Saizan> davd: the types should make this clearer
03:02:21 <absence> Saizan: i need to perform the action inside IO, not before
03:02:35 <davd> Saizan: ah, I see. thanks!
03:02:54 <Saizan> absence: oh, so ask :: IO Something here?
03:03:06 <Saizan> absence: and writetofile?
03:04:23 <absence> Saizan: well, ask is :: Reader something, so like i said the types won't allow it directly. for that contrieved example i would want to perform a Reader action inside the unsafe IO action
03:05:58 <f-a> @t union
03:05:58 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
03:08:58 <Saizan> absence: well, you can't perform the action inside
03:09:37 <Saizan> absence: you have to do retrieve the information outside so that you can pass it in
03:10:20 <f-a> colluphid: just a guess -> union has to check for duplicates, right?
03:10:44 <Saizan> ?type mapState
03:10:46 <lambdabot> ((a, s) -> (b, s)) -> State s a -> State s b
03:10:51 <Saizan> ?type mapReader
03:10:53 <lambdabot> (a -> b) -> Reader r a -> Reader r b
03:10:55 <Saizan> ?type mapReaderT
03:10:57 <lambdabot> (m a -> n b) -> ReaderT r m a -> ReaderT r n b
03:11:22 <f-a> so I guess that keeps working and working, endlessly
03:11:38 <Saizan> absence: i guess you could use mapReaderT (unsafePerformIO . Identity), so that you can work in ReaderT IO inside
03:11:48 <colluphid> it doesn't look like it accoding to hackage: 'An element occurs in the output as many times as the maximum number of occurrences in either input.'
03:12:33 <f-a> http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-List.html#v:union <-- are we talking about this?
03:13:08 <f-a> how can you know the maximum in either input with three infinite lists, say?
03:13:30 <f-a> unionBy uses nubBy
03:14:09 <Saizan> absence: (Identity . unsafePerformIO) actually, and i don't guarantee mapReaderT working nice with unsafePerformIO :)
03:14:26 <f-a> and nub is stated to be O(n^2), so I think I am correct
03:14:48 <ion> lambdabot should say :-( every time someone mentions unsafePerformIO.
03:15:16 <Saizan> true.
03:20:24 <absence> Saizan: interesting :) is possible to do this trick in general, or only for specific monads? i used Reader in my contrieved example, but my actual code has a stack of pipe and state and whatnot
03:20:35 <absence> is it*
03:22:49 <Saizan> ?type mapStateT
03:22:50 <lambdabot> (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
03:23:23 <Saizan> absence: it depends on the monad i'd say, StateT should be fine
03:23:36 <absence> Saizan: ah. Proxy is my topmost one :/
03:24:28 <Saizan> well you should be able to nest these, but doesn't pipes have a good story for interacting with IO?
03:25:27 <f-a> in fact, if you substitute union with (++), program won't hang no more colluphid . It would be an incorrect program, but not a hanging one. So union is the culpirit. I tried to work around that, but with that |map parityMultiples| I feel you cornered yourself
03:26:23 <absence> Saizan: sure, but this is for poking inside the internal representation of a ByteString. they're implemented using unsafe IO, so i don't want to require a MonadIO instance
03:27:20 <Saizan> absence: ah, i see
03:34:43 <absence> Saizan: ahh, looking at the lens code for traversing bytestrings, it seems to use a bunch of small IO actions (one per byte) instead of one large for the whole string. bytestring internals has an inlined version of unsafePerformIO, so i guesss performance should be ok :)
03:40:53 <gspr> What would be a reasonable definition of "concatParMap"?
03:42:00 <donri> concat .: parMap  ?
03:42:10 <gspr> or, rather, parConcatMap I guess
03:42:35 <gspr> donri: But that would be like defining concatMap as concat . map, no?
03:42:47 <donri> ?
03:43:09 <Flonk> :t (.:)
03:43:10 <lambdabot>     Not in scope: `.:'
03:43:10 <lambdabot>     Perhaps you meant one of these:
03:43:10 <lambdabot>       `.' (imported from Data.Function),
03:43:30 <gspr> Hmm, wait, nevermind, I'm confusing myself regarding parMap
03:43:35 <gspr> I retract my question :p
03:43:40 <gspr> thanks anyway, donri
03:43:53 <donri> i suppose you can parallelize concat as well
03:45:38 <frx> is there elemBy, that takes a predicate instead of using == ?
03:45:56 <donri> :t find
03:45:57 <lambdabot> (a -> Bool) -> [a] -> Maybe a
03:46:01 <frx> thanks
03:47:26 <donri> actually
03:47:30 <arkeet> @let bool f t b = if b then t else f
03:47:31 <donri> :t any -- frx
03:47:31 <lambdabot>  Defined.
03:47:32 <lambdabot> (a -> Bool) -> [a] -> Bool
03:47:49 <frx> yeah, find is elemIndex equivalent
03:49:21 <arkeet> :t (>>= bool (const Nothing) Just)
03:49:22 <lambdabot> (a -> Bool) -> a -> Maybe a
03:49:46 <arkeet> hmm.
03:50:09 <lpaste> f-a pasted “primes” at http://lpaste.net/94733
03:50:27 <donri> arkeet: not sure you can do that with list monad?
03:50:35 <f-a> colluphid: ^-- here for a naive but working implementation of nonprimes
03:50:37 <arkeet> do what?
03:50:44 <donri> arkeet: find or any
03:50:58 <arkeet> Foldable is enough.
03:51:02 <donri> arkeet: at best you can do filter, and then safeHead or null?
03:52:36 <arkeet> :t \p -> preview (folded . filtered p)
03:52:37 <lambdabot> (Foldable f, MonadReader (f a) m) => (a -> Bool) -> m (Maybe a)
03:52:47 <arkeet> :t \p -> preview (folded . filtered p) `asTypeOf` find
03:52:48 <lambdabot>     Couldn't match type `[a0] -> Maybe a0' with `Maybe Bool'
03:52:49 <lambdabot>     Expected type: (a0 -> Bool) -> Maybe Bool
03:52:49 <lambdabot>       Actual type: (a0 -> Bool) -> [a0] -> Maybe a0
03:52:53 <arkeet> :t (\p -> preview (folded . filtered p)) `asTypeOf` find
03:52:53 <lambdabot> (a -> Bool) -> [a] -> Maybe a
03:54:56 <arkeet> :t \p -> F.foldr ((<|>) . (p >>= bool (const Nothing) Just)) Nothing
03:54:57 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
03:56:20 <frase> hi #haskell ; I have a question about Crypto.HMAC
03:56:48 <arkeet> @let guardA False = empty; guardA true = pure ()
03:56:49 <lambdabot>  Defined.
03:57:00 <arkeet> :t \x b -> guardA b *> pure x
03:57:01 <lambdabot> Alternative f => b -> Bool -> f b
03:57:06 <frase> `hmac (MacKey "foo") "bar" :: SHA256` gives `SHA256 "<a bytestring>"`
03:57:40 <frase> how then do I pull the bytestring out of that result?
03:57:57 <arkeet> :t \p -> F.foldr ((<|>) . (p >>= \x b -> guardA b *> pure x)) empty
03:57:58 <lambdabot> (Foldable t, Alternative f) => (Bool -> a) -> t Bool -> f a
03:58:02 <fizruk_> > getAny . foldMap (Any . even) $ [1, 2,3 , 4]
03:58:03 <lambdabot>   True
03:58:07 <frase> Crypto.Hash's `hmac` returns an instance of Byteable so that works out fine; not the case for Crypto.HMAC tho
04:01:08 <frase> (nevermind folks; Crypto.Classes.encode does the job)
04:02:46 <Flonk> > getAny
04:02:48 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable Data.Monoid.Any)
04:02:48 <lambdabot>    arisin...
04:02:54 <Flonk> :t getAny
04:02:55 <lambdabot> Any -> Bool
04:03:22 <fizruk_> Flonk, Any is just a newtype
04:03:51 <Flonk> fizruk_: Okay I see
04:10:25 <robstewartuk> Has anyone else noticed that the twitter hackage account no longer announces package uploads? https://twitter.com/Hackage
04:11:08 <robstewartuk> dcoutts: was this hackage twitter account left behind in hackage2?
04:11:13 <f-a> and my rss had gone dead
04:11:16 <donri> robstewartuk: the feed url changed with hackage 2
04:11:25 <f-a> so I guess those two are related, robstewartuk
04:11:29 <donri> duno who runs @hackage
04:11:29 <f-a> *has
04:11:35 <donri> sm: you?
04:11:37 <m1dnight> Why is there no strict foldr?
04:11:48 <robstewartuk> cool. Maybe I'll tweet @hackage and ask.
04:12:09 <m1dnight> oh, it's in Data.IntSet i see
04:12:10 <robstewartuk> donri: what is the new feed, please?
04:12:23 <robstewartuk> /s/feed/feed address/
04:12:42 <donri> robstewartuk: looks like http://hackage.haskell.org/recent.rss
04:12:45 <robstewartuk> thanks.
04:13:14 <robstewartuk> https://twitter.com/robstewartUK/status/393331609056714752
04:16:31 <m1dnight> oh it's because it's recursive, and can't be made strict, right?
04:16:55 <dcoutts> robstewartuk: I think the issue is we didn't have a redirect for the url for the old rss feed
04:17:05 <dcoutts> robstewartuk: as it happens I fixed that yesterday
04:17:17 <dcoutts> new code should be live soonish
04:17:40 <robstewartuk> ah, t'rfic.
04:18:40 <robstewartuk> A @hackage twitter annoucement is the only reason the kids upload packages these days. For the Glory.
04:21:08 <dcoutts> robstewartuk: https://github.com/haskell/hackage-server/commit/c20580798ed612ec2dcfd6d8d502c0aa1c1832b6
04:23:09 <robstewartuk> dcoutts: Nice. Do hackage passwords fly through the interwebs as plain text to the hackage server? Or are uploads now via https?
04:23:36 <dcoutts> robstewartuk: it uses http digest auth, so it's not plain text
04:24:17 <robstewartuk> Ah, good. Also, I noticed the Maintainers list yesterday. A welcome feature indeed! Thank you.
04:24:36 <dcoutts> yes, somewhat better but not ideal security
04:24:48 <dcoutts> well, significantly better
04:26:21 <robstewartuk> Significantly better. It is a wonder why nobody uploaded defunct code to the most widely depended on packages. Faith in humanity restored.
04:26:56 <robstewartuk> Great job on hackage2, though. Any TODO of feature wishlist, for others to get stuck in on its development?
04:29:06 <frx> how do I combine two predicates with and?   (<something> even (>10)) should return true if number is even and greater than 10
04:31:18 <Earnestly> &&
04:32:17 <frx> how would I do it without a lambda?
04:33:13 <frx> @pl (\x -> even x && x > 10)
04:33:16 <lambdabot> ap ((&&) . even) (> 10)
04:33:16 <lambdabot> optimization suspended, use @pl-resume to continue.
04:33:29 <Iceland_jack> @pl \x -> even x && x > 10
04:33:32 <lambdabot> ap ((&&) . even) (> 10)
04:33:32 <lambdabot> optimization suspended, use @pl-resume to continue.
04:33:43 <Iceland_jack> You can also use liftM2 (&&)
04:33:53 <Earnestly> filter (liftM2 (&&) even (< 10)) [1..] or something
04:33:54 <Iceland_jack> :t liftM2 (&&) even (> 10)
04:33:55 <lambdabot> Integral a => a -> Bool
04:34:33 <frx> that's it thanks
04:34:54 <Iceland_jack> frx: It's better to just use an anonymous function
04:35:06 <frx> perhaps
04:35:19 <Iceland_jack> But it's OK to be aware of this option
04:35:21 <frx> I am doing it often though, maybe I will write andPred or something (better named)
04:35:38 <Iceland_jack> that sounds reasonable
04:36:29 <Earnestly> Iceland_jack: Why would it be better out of curiosity?
04:37:20 <Iceland_jack> Earnestly: Why would (\x -> even x && x > 10) be better to (liftM2 (&&) even (> 10))?
04:37:31 <Earnestly> Something like that, yeah
04:37:52 <Iceland_jack> Well I'm not going to argue style in here, I find the former clearer.
04:38:45 <Earnestly> Oh, that’s fair enough certainly.  I was wondering if one optimises better than the other since I don’t know very much about Haskell and was curious
04:39:07 <Iceland_jack> Ah no, it was only a stylistic point
04:39:24 <Earnestly> I do tend to agree with you though, the former is clearer to me as well
04:39:55 <KitB> Is there an easy way to get lambdabot to unescape a string?
04:40:21 <frx> > any ($12) [even, (>10), (<20)]
04:40:22 <lambdabot>   True
04:40:55 <frx> how would I turn that into Int -> Bool?
04:41:11 <Iceland_jack> Do you mean:
04:41:12 <Iceland_jack> :t \n -> any ($n) [even, (>10), (<20)]
04:41:14 <lambdabot> Integral a => a -> Bool
04:41:29 <frx> yes
04:41:34 <Iceland_jack> Like that.
04:41:36 <Iceland_jack> (another satisfied customer) :)
04:41:42 <frx> I am not :)
04:41:46 <frx> @pl \n -> any ($n) [even, (>10), (<20)]
04:41:46 <lambdabot> flip any [even, (> 10), (< 20)] . flip id
04:42:03 <Iceland_jack> I didn't ask you frx! :)
04:43:10 <aristid> i think the pointful version is slightly better.
04:43:49 <Iceland_jack> (to avoid misunderstandings that was faceteous)
04:45:30 <frx> Iceland_jack I took it as it was meant
04:45:46 <MattY`> hello. should a newbie start with learn you a haskell or real world haskell?
04:45:55 <Iceland_jack> MattY`: LYAH
04:45:55 <danr> MattY`: I'd go for lyah
04:46:00 <danr> Iceland_jack: :p
04:46:11 <Iceland_jack> hey danr!
04:46:14 <MattY`> thanks
04:46:38 <donri> MattY`: yes probably lyah, unless you're already familiar with some haskell-like languag
04:47:16 <MattY`> I don't think I am
04:48:27 <MattY`> I haven't used a more functional language than say python or C#
04:48:47 <MattY`> which aren't very functional
04:48:50 <Iceland_jack> MattY`: Start with LYAH, it has a very smooth learning curve
04:52:19 <frx> > let pred1 &&& pred2 = liftM2 (&&) pred1 pred2
04:52:20 <lambdabot>   not an expression: `let pred1 &&& pred2 = liftM2 (&&) pred1 pred2'
04:52:37 <frx> giving me filter (even &&& (>10) &&& (<20)) [1..20]  =>  [12,14,16,18]
04:52:40 <frx> what do you think?
04:53:19 <Iceland_jack> (&&&) is already a thing so I guess it depends on the scope and intended usage
04:53:41 <frx> ah
04:53:51 <Iceland_jack> (you can define things here using)
04:53:51 <Iceland_jack> @let (&&&) = liftM2 (&&)
04:53:51 <lambdabot>  .L.hs:149:9:
04:53:52 <lambdabot>      No instance for (Monad m0) arising from a use of `liftM2'
04:53:52 <lambdabot> ...
04:54:05 <aristid> :t filter (\n -> even n && n > 10 && n < 20)
04:54:07 <lambdabot> Integral a => [a] -> [a]
04:54:16 <Iceland_jack> @let (&&&) = liftM2 (&&) :: Monad m => m Bool -> m Bool -> m Bool
04:54:17 <lambdabot>  .L.hs:149:9:
04:54:17 <lambdabot>      No instance for (Monad m0)
04:54:17 <lambdabot>        arising from an expressi...
04:54:41 <aristid> frx: don't worry too much about having a few function parameters.
04:54:57 <Iceland_jack> @let (&&&) = (liftM2 (&&) :: (r -> Bool) -> (r -> Bool) -> r -> Bool)
04:54:58 <lambdabot>  Defined.
04:55:47 <Iceland_jack> so one of the things that makes frx's case seem less savory to me is the comparison secion (< 10)
04:56:00 <Iceland_jack> I try to avoid those
04:56:17 <Earnestly> Not a fan of point-free?
04:56:22 <Iceland_jack> I am sometimes
04:56:48 <Iceland_jack> It's not that they're bad, but I don't find non-commutative sections very legible
04:57:34 <Earnestly> Yeah, Haskell seems like one of those languages you can golf until oblivion, being clear is usually better than being clever
04:57:39 <fizruk> hm... can one write (even <> (> 10) <> (< 20)) using All monoid?
04:57:46 <Iceland_jack> I use them extensively when I'm prototyping in ghci
04:57:51 <frx> Iceland_jack what do you mean by non-commutative sections?
04:57:54 <Iceland_jack> but I think twice before using them in code
04:58:03 <Iceland_jack> frx: so things like (< 10) versus (> 10)
04:58:33 <Iceland_jack> case in point, Earnestly wrote ‘filter (liftM2 (&&) even (< 10)) [1..]’
04:59:35 <danr> @type ((&&) <$> even <*> (<10))
04:59:36 <lambdabot> Integral a => a -> Bool
04:59:41 <danr> I'd go for that
05:02:33 <FireFly> @pl \x -> (f x) `g` (h x)
05:02:34 <lambdabot> liftM2 g f h
05:05:21 <FireFly> I kinda wish I could write  f `(liftM2 g)` h
05:05:46 <FireFly> But I guess that would be horrible to try to parse properly
05:05:47 <udevd> is operator >> useful for something excepting IO ?
05:06:05 <tdammers> "except" or "expecting"?
05:06:10 <frx> it works with any monad
05:06:15 <udevd> except
05:06:20 <udevd> yeah, i know it works
05:06:25 <udevd> but is it useful
05:06:28 <udevd> ?
05:06:40 <udevd> i mean, it just discards left-value
05:06:47 <Iceland_jack> udevd: Yes it is!
05:07:02 <Iceland_jack> :t putChar 'h' >> putChar 'i'
05:07:03 <lambdabot> IO ()
05:07:11 <udevd> Iceland_jack: >except IO
05:07:16 <nh2> jaspervdj: hey Jasper, are you around?
05:07:23 <fizruk> udevd, it doesn't discard side effects
05:07:23 <Iceland_jack> right, udevd state monad?
05:07:28 <Iceland_jack> writer monad
05:07:39 <Iceland_jack> list monad.. yes it's useful
05:07:41 <udevd> and all these are IO (i suppose)
05:07:44 <Iceland_jack> no
05:07:50 <Iceland_jack> nothing IO about state monad
05:07:59 <fizruk> > [1, 2] >> [3, 4]
05:08:00 <lambdabot>   [3,4,3,4]
05:08:09 <udevd> wait, what
05:08:13 <Iceland_jack> > runState (do modify (+1); modify (+1)) 5
05:08:15 <lambdabot>   ((),7)
05:08:15 <udevd> how
05:08:16 <jaspervdj> nh2: heya, yeah
05:08:26 <Iceland_jack> > [undefined, undefined, undefined] >> "hi"
05:08:27 <lambdabot>   "hihihi"
05:08:30 <Iceland_jack> > [undefined, undefined, undefined, undefined] >> "hi"
05:08:30 <udevd> well
05:08:31 <lambdabot>   "hihihihi"
05:08:45 <fizruk> > Nothing >> Just "hi"
05:08:47 <lambdabot>   Nothing
05:09:08 <donri> > replicate 3 undefined >> "hi"
05:09:09 <lambdabot>   "hihihi"
05:09:21 <frx> Iceland_jack I didn't quite get what you find objectionable about filter (liftM2 (&&) even (< 10)) [1..] ?
05:09:36 <fizruk> > Left "error" >> Right 123
05:09:37 <nh2> in websockets 0.8 (thanks for the nicer api btw), if I use `runClient` and "leak" the Connection out, do things break? Probably, right?
05:09:37 <lambdabot>   Left "error"
05:09:55 <Iceland_jack> frx: Like I said earlier, I'm not interested in arguing style: if you prefer it then that's perfectly ok
05:10:21 <nh2> jaspervdj: the docs don't say, but it looks like a `withFile` style function
05:10:29 <jaspervdj> nh2: well it is closed automatically when the ClientApp finishes
05:10:46 <Iceland_jack> udevd: Does that answer your question?
05:10:51 <Iceland_jack> > Nothing >> Just undefined
05:10:56 <lambdabot>   Nothing
05:11:01 <jaspervdj> I guess you'll be fine if you properly catch exceptions in the other threads you're using it in
05:11:31 <udevd> Iceland_jack: yup
05:11:33 <frx> Iceland_jack ok, I thought you meant something other than aesthetics when you mentioned non-commutative sections
05:11:38 <udevd> thanks
05:11:43 <fizruk> > (1, "hi") >> (2, "there")
05:11:44 <lambdabot>   No instance for (GHC.Show.Show t0)
05:11:45 <lambdabot>    arising from a use of `M2093527074.sh...
05:11:46 <frx> I didn't understand how that would apply there
05:12:01 <jaspervdj> nh2: It is mentioned here: http://hackage.haskell.org/package/websockets-0.8.0.0/docs/Network-WebSockets.html#t:ClientApp
05:12:25 <Iceland_jack> frx: Well when you write: '5 > x && even(x)' (as you would in other languages), there is no mistake about what the predicate is
05:12:26 <jaspervdj> I should add that note to `runClient` as well though
05:13:44 <Iceland_jack> if it's something like:
05:13:44 <Iceland_jack>     (&&) <$> isUpper <*> isAscii (≡ isAsciiUpper)
05:13:44 <Iceland_jack> then I'm not as opposed to it
05:14:04 <Iceland_jack> when you add sections (== 5) into the mix it looks a little less legible
05:14:20 <Iceland_jack> but when you add sections whose operators don't commute then I'm not a fan
05:14:22 <frx> ah. I guess it's subjective. to me (>5) reads nicely as "greater than 5". and (5>) as "5 greater than"
05:14:41 <Iceland_jack> I find it cluttering to be honest
05:15:10 <FireFly> Do you find it cluttering with, say,  filter (> 5) xs  too?
05:15:14 <Iceland_jack> No that's fine
05:15:14 <Iceland_jack>  
05:16:49 <m1dnight> guys, I'm implementing a fold for a binary tree
05:17:03 <m1dnight> and I would like to use the minimum value of the type
05:17:04 <Iceland_jack> A lot of it also depends on the context, it's hard to make definitive statements in isolation: several things which are clear by themselves may not be clear together
05:17:38 <m1dnight> is there a way to do this? http://lpaste.net/94735 This is the code
05:17:50 <m1dnight> the last line, I would like to say "minimum value of a" instead of 0
05:17:52 <m1dnight> anyway to do this?
05:18:58 <Iceland_jack> @ty minimum
05:18:59 <lambdabot> Ord a => [a] -> a
05:19:05 <Iceland_jack> @src minimum
05:19:06 <lambdabot> minimum [] = undefined
05:19:06 <lambdabot> minimum xs = foldl1 min xs
05:19:13 <ion> @type minimum . toList
05:19:14 <lambdabot>     Not in scope: `toList'
05:19:14 <lambdabot>     Perhaps you meant one of these:
05:19:14 <lambdabot>       `F.toList' (imported from Data.Foldable),
05:19:14 <Iceland_jack> m1dnight: Are you sure you want it to be the minium value?
05:19:17 <ion> @type minimum . F./toList
05:19:18 <lambdabot> parse error on input `F./'
05:19:23 <ion> @type minimum . F.toList  -- sigh
05:19:24 <lambdabot> (Ord c, Foldable t) => t c -> c
05:19:54 <m1dnight> well yes, since every element of my tree should be bigger
05:20:03 <m1dnight> otherwise verything will be smaller and i'll always return the maximum bound
05:20:07 <m1dnight> boundary*
05:20:12 <Iceland_jack> m1dnight: do what ion posted
05:20:16 <Iceland_jack> using Foldable
05:20:16 <cpa> :t (>=>)
05:20:17 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
05:21:38 <m1dnight> isn't that minimum for the minimum of a list?
05:21:41 <kartoffelbrei> Is there a package that does non-blocking file io on hackage? I'd especially like to have non-blocking versions of hGetLine and hIsEof. Or do i have to implement that myself ontop of hGetBufNonBlocking?
05:22:04 <merijn> kartoffelbrei: Why do you want nonblocking versions?
05:22:14 <Iceland_jack> kartoffelbrei: What do you need non-blcoking IO for? You may want threads
05:22:18 <Iceland_jack> Control.Concurrent.forkIO
05:23:06 <Iceland_jack> *non-blocking
05:23:24 <ion> @let newtype Min a = Min { fromMin :: Maybe a  deriving (Eq, Ord, Show, Read); instance Ord a => Monoid (Min a) where { mempty = Nothing; Min (Just a) `mappend` Min (Just b) = Min (Just (min a b)); Min a `mappend` Min b = Min (a <|> b) }
05:23:24 <lambdabot>  Parse failed: Parse error: deriving
05:23:30 <ion> @let newtype Min a = Min { fromMin :: Maybe a } deriving (Eq, Ord, Show, Read); instance Ord a => Monoid (Min a) where { mempty = Nothing; Min (Just a) `mappend` Min (Just b) = Min (Just (min a b)); Min a `mappend` Min b = Min (a <|> b) }
05:23:30 <lambdabot>  .L.hs:145:18:
05:23:30 <lambdabot>      Couldn't match expected type `Min a' with actual type `Ma...
05:24:07 <ion> @let newtype Min a = Min { fromMin :: Maybe a } deriving (Eq, Ord, Show, Read); instance Ord a => Monoid (Min a) where { mempty = Min Nothing; Min (Just a) `mappend` Min (Just b) = Min (Just (min a b)); Min a `mappend` Min b = Min (a <|> b) }
05:24:08 <lambdabot>  Defined.
05:24:08 <kartoffelbrei> I won't to bind Pipes to ordinary shell commands like "tr". I have a somewhat hacky solution using forkIO, blocking IO and Chans, but i don't like it. It only works properly with -threaded.
05:24:30 <merijn> kartoffelbrei: huh, that should be a bug
05:24:31 <kartoffelbrei> s/won't/want/
05:24:43 <ion> > fromMin . foldMap (Min . Just) $ [1,5,2,6,3,7]
05:24:46 <Iceland_jack> It *only* works with -threaded?
05:24:49 <lambdabot>   Just 1
05:25:03 <kartoffelbrei> merjin: ok then i should look deeper into and make sure that i don't do something stupid.
05:25:08 <Iceland_jack> The Min monoid!
05:25:10 <ion> m1dnight: You can also use a Min monoid and foldMap.
05:25:13 <merijn> kartoffelbrei: Unless you accidentally have a deadlock, there's no reason for code that works with -threaded to not work without it
05:25:26 <merijn> kartoffelbrei: Maybe hpaste the code?
05:25:57 <kartoffelbrei> merjin: It is a deadlock. I'am precisely working around that using concurrency.
05:26:02 <Iceland_jack> kartoffelbrei: Maybe you're interested in the async package?
05:26:09 <Iceland_jack> If you weren't aware of it already
05:26:11 <Iceland_jack> http://hackage.haskell.org/package/async
05:26:30 <ion> > fromMin . foldMap (Min . Just) $ Node "foo" [Node "bar" [Node "baz", Node "quux"], Node "poit" []]
05:26:32 <lambdabot>   Couldn't match expected type `Data.Tree.Tree [GHC.Types.Char]'
05:26:32 <lambdabot>             ...
05:26:52 <ion> > fromMin . foldMap (Min . Just) $ Node "foo" [Node "bar" [Node "baz" [], Node "quux" []], Node "poit" []]
05:26:56 <lambdabot>   Just "bar"
05:27:37 <ion> m1dnight: See above. There’s also a package somewhere on Hackage that provides a Min monoid.
05:28:04 <kartoffelbrei> Iceland_jack: Thanks for the suggestion. I know async already. I want to get rid of this threading entirely because it feels too hacky and wrong in this code. Plus i want it to work without -threaded.
05:28:19 <Iceland_jack> m1dnight: I think it's in the monoids package
05:28:36 <Iceland_jack> kartoffelbrei: The -threaded business is odd
05:29:06 <Iceland_jack> So to see if I understand this correctly, you're calling system commands kartoffelbrei?
05:30:26 <kartoffelbrei> Iceland_jack: I use System.IO on a pipe handle i got from System.Process. I'll clean up, comment and minimize the code for hpasting and put it up later.
05:31:04 <Iceland_jack> I see
05:34:10 <fizruk> Iceland_jack, async looks like monad-parallel
05:34:25 <fizruk> Iceland_jack, async is preferred?
05:34:46 <fizruk> @hackage monad-parallel
05:34:46 <lambdabot> http://hackage.haskell.org/package/monad-parallel
05:36:11 <nh2> jaspervdj: unfortunately it doesn't work: http://lpaste.net/94740
05:36:32 <nh2> "send: invalid argument (Bad file descriptor)"
05:37:10 <fizruk> oh async only works for IO ?
05:37:14 <Iceland_jack> fizruk: Yes
05:37:33 <Iceland_jack> monad-parallel uses par for pure computations
05:37:47 <fizruk> and forkIO for IO
05:38:02 <merijn> nh2: Which OS are you on?
05:38:31 <nh2> merijn: linux - does it matter?
05:38:46 <nh2> jaspervdj: I think that because at the point of `return res`, `finally` has already run and closed the socket, so if I just `return` the Connection out of the function, it breaks
05:39:15 <merijn> nh2: Well, in the past I've been screwed by the fact that sockets are different from files on windows (but on unix they're both just accessible via file descriptors)
05:39:18 <fizruk> Iceland_jack, I find MonadFork instance for ReaderT r IO pretty useful
05:39:26 <nh2> jaspervdj: That's not bad at all, of course, and is guessable, but probably it deserves a bit more explicit mention
05:39:37 <merijn> nh2: So when I see networking + weird file descriptor errors, first check is: verify it's not windows weirdness :)
05:40:11 <nh2> merijn: ah, ok :)
05:41:29 <Iceland_jack> fizruk: I haven't used it but I can imagine :)
05:43:47 <fizruk> Iceland_jack, I think async and monad-parallel share a common interface, can't they be merged?
05:45:25 <fizruk> on a second thought, probably that's not a good idea
05:49:12 <jmcarthur_mobile> fizruk: they are for totally different things
05:50:39 <jmcarthur_mobile> fizruk: async is for creating nonblocking actions out of blocking ones. monad-parallel is for using multiple cores
05:50:58 <jmcarthur_mobile> fizruk: async is also able to use multiple cores, but it is not the point
05:53:05 <fizruk> jmcarthur, sure, but I could possibly gain those async functions for e.g. (ReaderT r IO)
05:53:12 <fizruk> jmcarthur_mobile, ^
05:53:24 <fizruk> jmcarthur_mobile, that was my first thought
05:53:33 <jmcarthur_mobile> fizruk: depends on the transformer. Yes for ReaderT
05:54:24 <jmcarthur_mobile> fizruk: you can't do it for e.g. StateT s IO
05:54:28 <fizruk> jmcarthur_mobile, and for ErrorT, MaybeT
05:54:37 <jmcarthur_mobile> Nor for error or maybe
05:54:52 <jmcarthur_mobile> Oh waot
05:55:00 <fizruk> jmcarthur_mobile, yes, I know for StateT
05:55:22 <jmcarthur_mobile> Nevermind, you can for error and maybe
05:55:38 <fizruk> jmcarthur_mobile, my point is that async's interface could be generalized (perhaps)
05:56:05 <jmcarthur_mobile> It's similar to the situation with bracket
05:56:05 <fizruk> jmcarthur_mobile, perhaps one could have class MonadFork m => MonadAsync m where ...
05:57:58 <jmcarthur_mobile> Unless monad fork requires IO it won't work, at least naively
05:58:30 <jmcarthur_mobile> Since async relies on some GHC concurrency primitives like STM
05:58:48 <jmcarthur_mobile> maybe there could be another way to write it, but I don't know
05:58:57 <fizruk> I meant MonadAsync m implied m uses IO
05:59:50 <jmcarthur_mobile> I see, then I think it's doable albeit possibly a little awkward to design well for the same reasons as all the attempts to generalize bracket
06:05:03 <og01> Hello, why can i not do [1..10,20..30] ??
06:05:40 <Walther> > [1..10] ++ [20..30]
06:05:43 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,20,21,22,23,24,25,26,27,28,29,30]
06:05:49 <ion> Because that hasn’t been specified in the syntactic sugar rules.
06:06:28 <og01> ok, i found it confusing when i saw an example that did [2,4..20]
06:06:44 <og01> but i couldnt mix up things like [4..20,2]
06:06:51 <og01> > [4..20,2]
06:06:53 <lambdabot>   <hint>:1:7: parse error on input `,'
06:07:01 <og01> > [2,4..20]
06:07:03 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
06:07:04 <frx> 2,4 just sets step
06:07:19 <og01> oh i hadnt noticed!
06:07:21 <ion> [2,4..20] is sugar for enumFromThenTo 2 4 20
06:07:26 <ion> > enumFromThenTo 2 4 20
06:07:27 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
06:07:28 <frx> > [0,10..100]
06:07:29 <lambdabot>   [0,10,20,30,40,50,60,70,80,90,100]
06:07:52 <Walther> (these ranges are amazing anyway, one of my favourite details about haskell :P)
06:08:12 <ion> Many languages have that.
06:08:23 <og01> I'm reading learnyouahaskell.com
06:08:25 <Walther> But wit more complicated syntax
06:08:36 <og01> I'm familiar with many imperitive languages
06:08:51 <Walther> python's range(from,to,step) etc
06:09:16 <og01> I find myself making too many asumptions though, some things look so similar but are something so different
06:09:31 <og01> I'm tripping over all the time
06:09:35 <Renze_> Hi all!
06:09:36 <bennofs> @ty return
06:09:38 <lambdabot> Monad m => a -> m a
06:09:58 <ion> og01: Yeah, it will take some effort to unlearn things you used to take for granted in CLispScripts.
06:10:26 <ion> og01: It will be worth it. :-)
06:11:36 * og01 keeps reading
06:11:45 <Renze_> I'm looking for something like this: http://www.haskell.org/haskellwiki/Cookbook/Other_data_structures , a list of fast data structures for different tasks, and they don't necessarily need to be in GHC. Is there a complete list of what I look for? I couldn't find it until now
06:11:47 <funfunctor> Hi, any BNF guns around?
06:12:45 <mm_freak_> BNFG 9000
06:12:47 <MattY> hello
06:13:10 <Renze_> http://www.haskell.org/haskellwiki/Applications_and_libraries/Data_structures something like this would be good as well, but almost all links are dead...
06:13:30 <mm_freak_> hi MattY
06:13:38 <funfunctor> As in Backus Normal Form
06:13:45 <ion> BNFG > 9000
06:14:09 <mm_freak_> sure, the Backus Normal Form Gun 9000
06:14:18 <ion> OVER 9000
06:14:50 <mm_freak_> i don't know what you guys had in mind =P
06:15:23 <colluphid> im a little confused by this list comprehension pattern
06:15:26 <colluphid> [[p*p, p*p+2*p .. ] | p <- tail primes]
06:15:49 <ion> map (\p -> [p*p, p*p+2*p ..]) (tail primes)
06:15:58 <mm_freak_> colluphid: primes = 2:3:5:…
06:16:02 <mm_freak_> tail primes = 3:5:…
06:16:37 <funfunctor> lol
06:16:46 <funfunctor> 1sec byb
06:16:49 <funfunctor> s/brb
06:17:07 <ion> mm_freak: Btw, what’s the etymology of your nick? :-)
06:17:08 <mm_freak_> so it gives you [3:6:9:…, 5:10:15:…, …]
06:17:08 <mm_freak_> oh, almost
06:17:25 <mm_freak_> it gives you [9:15:…, 25:35:…, …]
06:17:35 <int-e> for each p, it gives odd muliples of p from p^2 onwards
06:17:52 <mm_freak_> seems like a utility for prime sieving
06:17:58 <mm_freak_> ion: good question =)
06:18:01 <colluphid> so p*p+3*p would be the next iteration?
06:18:23 <int-e> no, it adds (p*p+2*p) - p*p == 2*p each time
06:18:24 <mm_freak_> ion: mainly because as a non-native english speaker i don't even know what that is =)
06:18:32 <int-e> so p*p+2*p+2*p = p*p+4*p
06:18:56 <ion> [a, b..] results in [a, b, a+2*(b-a), a+3*(b-a), …]
06:18:57 <int-e> > [3,5..] -- each element is larger than the previous one by 5-3 = 2
06:19:00 <lambdabot>   [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,...
06:19:17 <ion> mm_freak: “Where did it come from” :-)
06:19:18 <fizruk> mm_freak_, etymology = origins
06:19:29 <FireFly> "origin of word"
06:19:36 <mm_freak_> ion: oh, in that case…
06:19:39 <mm_freak_> … good question =)
06:19:44 <ion> heh
06:20:06 <ion> I suppose it was an emergent property of this universe.
06:20:09 <mm_freak_> i have it since about 1998 and don't even know what it means anymore =)
06:20:26 <colluphid> ion: is there a name for that algorithm? "[a, b..] results in [a, b, a+2*(b-a), a+3*(b-a), …]"
06:20:45 <ion> “keep incrementing by (b-a)”
06:20:47 <ion> :-P
06:21:00 <fizruk> colluphid, arithmetic progression?
06:21:09 <mm_freak_> colluphid: [a, b ..] = let step = b - a in [a, a + step, a + 2*step, a + 3*step …]
06:21:27 <mm_freak_> > [10, 15 ..]
06:21:29 <lambdabot>   [10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,120,...
06:21:35 <mm_freak_> step =
06:21:35 <mm_freak_> step = 5
06:21:51 <fizruk> > iterate (+5) 10
06:21:52 <lambdabot>   [10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,120,...
06:22:33 <ion> To make the pattern clearer, what i wrote can also be written as [a, b…] = [a+0*(b-a), a+1*(b-a), a+2*(b-a), a+3*(b-a), …]. Also: what mm_freak wrote.
06:22:51 <ion> I mean, [a, b..] = …
06:31:41 * hackagebot Elm 0.10.0.1 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.10.0.1 (EvanCzaplicki)
06:32:03 <funfunctor> mm_freak_: so this is what I have attempted to do so far, https://gist.github.com/victoredwardocallaghan/7137189
06:33:18 <colluphid> ahh got it thank for mm_freak_
06:33:25 <colluphid> *that
06:34:25 <funfunctor> mm_freak_: I am trying to write a paser to interpret this syntax example: https://gist.github.com/victoredwardocallaghan/7137219
06:37:37 <mm_freak_> funfunctor: if you have a question, i recommend asking the channel =)
06:39:53 <dv-_> is there some restriction to blah <- runST $ do ... that I'm not getting?
06:40:21 <ion> Perhaps. What are you trying to do and what is unexpected about the results?
06:41:40 <dv-_> i'm trying to process some stuff and update a record, and it works if runST $ ... is the entire body of a function, but it doesn't work if I do blah' <- runST $ do ... ; return struct { blah = blah' }
06:41:42 <funfunctor> sure, its just BNF is kind of a special thing of its own.. However, my question is more in need of tips here.. That compiles into invaild haskell code. The data types for Exp are empty?
06:43:21 <ion> dv: Oh, “do foo <- bar” expects “bar” to be a monadic action. Would “do { let { blah = runSt $ … }; … }” work?
06:46:00 <dv-_> ion: oh right. that's probably it, thanks
06:46:05 <leino> (sorry but my irc client disconnected, did anyone answer my question about ghci and libraries?)
06:46:25 <alexander__b> is there a more concise way of saying "Foo a => Bar a => Fu a => Bar a -> a"?
06:46:33 <leino> (or indeed, did anyone see my quesion? just a few minutes ago)
06:47:01 <donri> alexander__b: that doesn't make sense
06:47:24 <alexander__b> donri: sorry, => on the last one as well, not ->
06:47:39 <mm_freak_> alexander__b: (Foo a, Bar a, Fu a) => a
06:47:41 <donri> alexander__b: still doesn't make sense :)
06:47:50 <alexander__b> mm_freak_: that's a bit shorter at least, thanks
06:47:52 <mm_freak_> donri: why?
06:48:15 <donri> mm_freak_: repeated Bar?
06:48:24 <alexander__b> oh. that one should be Baz. :-P
06:48:42 <mm_freak_> > (return :: (Monad m, Monad m) => a -> m a) 15 :: Maybe Int
06:48:43 <lambdabot>   mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMs...
06:48:49 <fizruk> > 1 :: Show a => Num a => Show a => a
06:48:50 <lambdabot>   mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMs...
06:48:53 <monoidal> afair Foo a => Bar a => a is not valid haskell 2010, it is accidentally accepted by ghc
06:49:01 <fizruk> > 1 :: Show a => Num a => a
06:49:03 <lambdabot>   1
06:49:11 <donri> yeah i wasn't sure about that repeated => biznaz
06:49:46 <donri> alexander__b: you can make constraint synonyms with extensions if you want
06:50:02 <alexander__b> donri: I prefer staying away from extensions ATM. thanks though.
06:51:21 <leino> I'll just repeat my ghc question: I have a module in my project which uses the FFI to interface with some c code. When I try to load the module into ghci, I get the usual ByteCodeLink error indicating that I did not specify the object code on the command line, when starting ghci. Now here's my question: since I run ghci trough emacs, I'd like to specify the object code file in my .ghci. Is there any way to do this?
06:52:46 <mm_freak_> leino: type :help, read about :set
06:52:54 <mm_freak_> it can set command line arguments
06:53:12 <mm_freak_> not everything though, you'll have to try
06:54:01 <prophile> @djinn (Functor f) => (v -> f v) -> ((k -> v) -> f (k -> v))
06:54:01 <lambdabot> Error: Class not found: Functor
06:54:07 <prophile> :|
06:55:16 <danr> I don't think djinn does higher-rank type variables
06:57:18 <Saizan> they are usually called higher-order
06:57:44 <Saizan> (while higher-rank refers to nesting quantifiers)
06:58:19 <Saizan> but yeah, djinn doesn't really support any
07:00:32 <leino> mm_freak_: it seems that it can set <options> (I already have a bunch of lines like :set -imy/module/path in my .ghci), but I'm not sure if it can add files to the command line, ":set some/path/myobjcode.o" did not work out...
07:01:44 <mm_freak_> then sorry, i can't help further =)
07:02:42 <leino> mm_freak_: ok, thanks anyway!
07:02:47 <fizruk> prophile, \f g -> fmap (const g) (f undefined) ?
07:03:37 <prophile> (Eq k, Functor f) => k -> (v -> f v) -> ((k -> v) -> f (k -> v)) is probably want I actually want here
07:04:06 <mm_freak_> it's not even higher order, it's just a type variable of kind * -> *
07:04:19 <mm_freak_> Functor is higher order:  (* -> *) -> Constraint
07:05:14 <ion> prophile: \k vfv kv -> kv <$ vfv (kv k)
07:05:27 <fizruk> :t (<$)
07:05:28 <lambdabot> Functor f => a -> f b -> f a
07:06:06 <prophile> hoorah
07:06:07 <prophile> thanks
07:06:16 <ion> …is that actually useful?
07:06:27 <prophile> probably not, but it might be quite interesting
07:06:33 <ion> Seems like a bit weird thing to have.
07:10:41 <alexander__b> is there some nice "trick" to do this more neatly? "fromMaybe (fromMaybe (0, 0) (collideRectangle b p2 (vel p2))) (collideRectangle b p1 (vel p1))"
07:11:08 <FireFly> @ty fromMaybe
07:11:09 <lambdabot> a -> Maybe a -> a
07:11:22 <ion> What is the type of collideRectangle?
07:11:50 <ion> Do those nested fromMaybes really typecheck?
07:12:01 <alexander__b> ion: Tangible a => Ball -> a -> Velocity -> Maybe (Normal, Velocity)
07:12:03 <alexander__b> ion: yes.
07:12:06 <alexander__b> it works well.
07:12:24 <ocharles> alexander__b: fromMaybe (0, 0) (collideRectangle b p2 (vel p2) <|> collideRectangle b p1 (vel p1))
07:12:27 <ocharles> or something?
07:12:33 <ocharles> maybe you want to switch those collisions
07:12:47 <alexander__b> ocharles: that was what I was looking for, I guess. thanks.
07:12:47 <ion> @type fromMaybe (fromMaybe (0, 0) ?x)
07:12:48 <lambdabot> (Num t, Num t1, ?x::Maybe (t, t1)) => Maybe (t, t1) -> (t, t1)
07:13:03 <ocharles> Maybe is an instance of MonadPlus and Alternative, so you can run computations "in parallel" and take the "first" that succeeds
07:13:12 <ocharles> parallel might not be the best way to think about this
07:13:14 <ion> Oh, right
07:13:24 <ocharles> For 'Maybe', you run the left computation, and if it fails, you try the right computation
07:13:37 <ocharles> but you remain inside Maybe, so you can escape from that with fromMaybe
07:13:47 <ocharles> (because Nothing <|> Nothing == Nothing)
07:14:32 <FireFly> oh, fromMaybe returns the first thing if it's Nothing
07:14:34 <FireFly> I see
07:14:44 <FireFly> er, if the maybe is Nothing that is
07:15:44 <ocharles> FireFly: indeed
07:16:23 <m1dnight> Guys, sorry to trouble you again, but is it possible to create a partial function application, where you leave out only the penultimate parameter?
07:16:52 <ion> m1dnight: Yes, that’ll work by default.
07:17:26 <FireFly> I think you need a flip for that
07:17:33 <FireFly> penultimate is "second-to-last", no?
07:17:48 <m1dnight> FireFly: yes it is
07:17:51 <m1dnight> I get what you're saying
07:17:56 <m1dnight> that would be pretty cool yeah
07:18:00 <m1dnight> I'm gong to try that
07:18:21 <frx> wasn't there a mapM_ putStrLn function?
07:18:34 <frx> :t mapM_ putStrLn
07:18:35 <lambdabot> [String] -> IO ()
07:18:48 <ocharles> frx: well, print can have that type, but has different semantics
07:19:00 <ocharles> i don't know of a name for mapM_ putStrLn though
07:19:43 <ion> m1dnight: D’oh, i should have read more carefully. flip (f a b) c d = f a b d c, but it might be more readable just to write (\d -> f a b d c).
07:20:18 <ion> frx: Yeah, it’s called mapM_ putStrLn. ;-)
07:20:48 <m1dnight> aha yeah
07:20:55 <m1dnight> that's more readabe yes
07:20:59 <m1dnight> GREAT! :D Thanks guys!
07:22:43 <ion> m1dnight: If the function only takes two parameters, (`f` b) might also be worth considering.
07:23:38 <m1dnight> well the use case here is that I have to create a new binary tree node (Node key value left right) but left is calculated recursively
07:23:45 <m1dnight>     | otherwise = (\newleft -> (Node key value newleft Empty) $ (remove' k left)
07:23:49 <m1dnight> this is what I've done
07:24:07 <ion> = Node key value (remove' k left) Empty
07:24:36 <m1dnight> Myeah, I thought the solution I pasted was more canonical
07:24:40 <m1dnight> So it's not?
07:24:52 <m1dnight> I thoughtt he rule of thumb was: as few parentheses as possible :p
07:24:53 <ion> I’d say what i wrote is easier to read.
07:25:07 <m1dnight> okey, I'll take it that way then
07:25:08 <fizruk> m1dnight, ion's version is better
07:25:09 <m1dnight> thanks ion
07:25:15 <ion> 0) There’s nothing wrong with parens, 1) mine happens to have less than your version.
07:25:26 <m1dnight> hahaha true ion
07:25:28 <m1dnight> didn't notice
07:25:39 <m1dnight> excuse me, my first hours of freestyle haskell :D
07:27:12 <udevd> >freestyle haskell
07:27:15 <udevd> xD
07:27:29 <m1dnight> well I mean I'm not solving any particular assignment
07:27:42 <m1dnight> So I figured I'd implement a BST delete
07:33:37 <Eduard_Munteanu> Is there a zipper library I should be using if I just want a simple list zipper?
07:34:54 <user123abc> cabal install fails to compile the judy and hsjudy packages
07:35:00 <user123abc> sadly
07:41:52 <gasche> hello #haskell, I'd like some quick feedback on a categorypedia question
07:42:20 <gasche> do we have a name for functors f equipped with an isomorphism between f (a -> b) and (a -> f b)?
07:43:06 <gasche> going from (f (a -> b)) to (a -> f b) can be done with Applicative
07:43:23 <gasche> the other direct looks like a strengh, but for the exponential instead of the product
07:43:48 <ciaranm> Applicative is "really" a pointed functor with an iso between f (a, b) and (f a, f b)
07:46:16 <ion> Err, you can convert f (a, b) into (f a, f b) with Applicative?
07:47:10 <ocharles> :t fmap (pure *** pure)
07:47:11 <gasche> ion: pure fst <$> foo ?
07:47:11 <lambdabot> (Functor f, Applicative f1, Applicative f2) => f (a, a1) -> f (f1 a, f2 a1)
07:47:19 <ocharles> oh, fmap isn't going to do
07:47:31 <Eduard_Munteanu> :t fmap (uncurry ($))
07:47:32 <lambdabot> Functor f => f (b1 -> b, b1) -> f b
07:47:33 <quchen> Is there a name for a version of mapMaybe that works on any Foldable?  "XXX :: (Foldable t) => (a -> t b) -> Y a -> Y b"? It seems like Pipes could use such a function, "XXX :: (Monad m, Foldable t) => (a -> t b) -> Pipe a b m r"
07:47:35 <ocharles> ion: that would require eliminating the functor, so I don't think so
07:47:45 <ocharles> but that also looks a bit like strength...
07:48:02 <ocharles> but I think strength is (f a, b) -> f (a, b)
07:48:18 <Eduard_Munteanu> Morally there's a correspondence between (<*>) and fmap (uncurry ($))
07:48:21 <ion> That is, did i misinterpret the “iso between …”?
07:48:24 <ocharles> other way round, but yea, it's not strength
07:48:48 <fizruk> :t fmap fst &&& fmap snd
07:48:49 <lambdabot> Functor f => f (b, b1) -> (f b, f b1)
07:49:08 <Eduard_Munteanu> I interpret Applicative functors as exponential-preserving pointed functors.
07:49:28 <ion> fizruk: That’s not isomorphic.
07:49:39 <fizruk> ion: sure :)
07:49:40 <Eduard_Munteanu> So you get a lifted curry/uncurry/eval, at least morally.
07:50:03 <gasche> any inspiration about (a -> f b) -> f (a -> b)?
07:50:56 <Eduard_Munteanu> That's more like strength.
07:51:05 <gasche> yes, but on the exponential
07:51:56 <fizbin> @djinn (t -> t1 -> t2 -> d) -> (t, (t1, t2)) -> d
07:51:56 <lambdabot> f a (b, (c, d)) = a b c d
07:51:57 <Eduard_Munteanu> Hm, I'm unsure because Hask gets normal strength wrt products because it's a CCC, but dunno about (->) generally.
07:52:35 <fizbin> :t uncurry.uncurry
07:52:37 <lambdabot> (a -> b1 -> b -> c) -> ((a, b1), b) -> c
07:53:32 <fizbin> So I want something that's like (uncurry.uncurry) but that has the types collect towards the right.
07:53:53 <fizbin> And djinn was singularly unhelpful.
07:54:02 <ion> It was?
07:55:02 <fizbin> Well... I suppose I could do it all with pattern matching. Thing is, I also want variants that do the same with four, five, etc. arguments.
07:56:10 <FireFly> @pl \a (b, (c, d)) -> a b c d
07:56:11 <lambdabot> (`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .)
07:56:15 <FireFly> Ok no.
07:56:42 <Eduard_Munteanu> Hm... any suggestions on how you'd implement a function 'spread :: [(a, Integer)] -> [a]' such that the result contains evenly-spread 'a's for each pair (a, n), n >= 1 ?
07:56:51 <Peaker> @type \f -> uncurry (uncurry . f)
07:56:53 <lambdabot> (a -> a1 -> b -> c) -> (a, (a1, b)) -> c
07:57:37 <fizbin> @type \f -> uncurry (uncurry . uncurry f)
07:57:39 <lambdabot> (a1 -> b1 -> a -> b -> c) -> ((a1, b1), (a, b)) -> c
07:57:50 <fizbin> @type \f -> uncurry (uncurry . uncurry . f)
07:57:51 <lambdabot> (a -> a1 -> b1 -> b -> c) -> (a, ((a1, b1), b)) -> c
07:57:58 <bennofs> What does ghc's -B flag do?
07:59:13 <Eduard_Munteanu> For example, given [(a, 2), (b, 1), (c, 1), (d, 1)], the result would be like [a, b, c, a, d], not [a, a, b, c, d]
08:00:01 <Peaker> @type \f -> uncurry ((uncurry .) . f)
08:00:02 <lambdabot> (a -> b -> a1 -> b1 -> c) -> (a, b) -> (a1, b1) -> c
08:00:04 <geekosaur> bennofs, it tells ghc where to find various things like the package database and various internal subprograms like unlit (which extracts the Haskell source from a literate Haskell source). if you look at the ghc that you run on a unixlike, you'll see it's a shell script that uses -B to point to these; that's how the generic Linux binary can be relocated to any install path without having to recompile ghc
08:00:14 <Eduard_Munteanu> I could build an IntMap or Vector and convert to a list, I suppose.
08:01:31 <snyp> @type (>>)
08:01:32 <lambdabot> Monad m => m a -> m b -> m b
08:01:35 <FireFly> Eduard_Munteanu: [(a,3), (b,2), (c,1), (d,2)] would map to [a,b,c,d,a,b,d,a] ?
08:02:08 <snyp> is the action m a being performed due to haskell's laziness as it is throw away by the >> operator?
08:02:09 <FireFly> Hm, maybe not
08:02:19 <Eduard_Munteanu> FireFly: no, I'd prefer it to be consistent if I cycle the list
08:02:56 <ciaranm> snyp: monads don't interfere with laziness like that
08:03:02 <fizbin> @type \f -> uncurry . f
08:03:03 <lambdabot> (a -> a1 -> b -> c) -> a -> (a1, b) -> c
08:03:19 <ion> snyp: Neither. The effect of the “m a” will happen as the effect of the result, but the result value of it is thrown away.
08:03:41 <Peaker> @type :t \f -> uncurry (uncurry . (uncurry .) . f)
08:03:42 <lambdabot> parse error on input `:'
08:03:48 <Peaker> @type \f -> uncurry (uncurry . (uncurry .) . f)
08:03:49 <lambdabot> (a -> a1 -> a2 -> b -> c) -> (a, (a1, (a2, b))) -> c
08:03:56 <ion> snyp: In getLine >> putStrLn "hi", the effect of reading a line will occur but the resulting string is thrown away.
08:04:27 <ion> snyp: In Just 42 >> Just "hi" the effect of “don’t abort the computation” will happen but 42 is thrown away.
08:04:44 <snyp> i see
08:04:57 <snyp> I need to clarify mapM_
08:05:03 <ion> a >> b = a >>= \_ -> b
08:05:20 <snyp> why is the effect of mapM_ immediately shown?
08:05:23 <ion> Or in do notation: do { a; b } = do { _ <- a; b }
08:05:34 <Eduard_Munteanu> Hm, maybe I can apply concatMap repeatedly and insert elements where needed.
08:05:43 <snyp> I thought that's because it returns m () instead of m [b]
08:06:00 <ion> What do you mean by “immediately shown”?
08:06:02 <Iceland_jack> snyp: What do you mean by immediately?
08:06:29 <Iceland_jack> Because if I do:
08:06:29 <Iceland_jack>     mapM_ (const getLine) [1..]
08:06:29 <Iceland_jack> I don't get any immediate value
08:06:41 <Iceland_jack> And in fact I never will
08:06:42 <Eduard_Munteanu> snyp: monads and laziness have nothing in common, except stuff that only happens to fit both topics, but it's not intentional.
08:06:59 <Eduard_Munteanu> Not generally, I mean.
08:07:09 <Iceland_jack> @src mapM_ -- snyp: You can see that mapM_ only gives you () when it reaches the end of the list
08:07:09 <lambdabot> Source not found. Wrong!  You cheating scum!
08:07:15 <Iceland_jack> What?
08:07:19 <snyp> erm..
08:07:21 <snyp> sorry
08:07:26 <snyp> yeah, i get the output
08:07:31 <ion> @src mapM_
08:07:32 <lambdabot> mapM_ f as = sequence_ (map f as)
08:07:48 <Iceland_jack> I thought src supported comments, oh well
08:08:13 <Iceland_jack> You can't see it from sequence_ (map f as), but the [] case is mapM_ _ [] = return ()
08:09:04 <snyp> Iceland_jack: yes. it returns ()
08:09:30 <funfunctor> is there a irc channel for compilers and formal lang?
08:09:42 <Iceland_jack> snyp: Can you elaborate on the problem? :)
08:10:10 <Iceland_jack> > mapM_ undefined [] :: Maybe ()
08:10:11 <lambdabot>   Just ()
08:10:31 <Eduard_Munteanu> funfunctor: there's #workingset for compilers, but not formally-oriented
08:11:07 <Eduard_Munteanu> funfunctor: there are channels for #agda, #coq and other theorem provers
08:14:41 <snyp> Iceland_jack: ok i get it(somewhat). i just had a bit of misconceptions about stuff.
08:15:10 <Iceland_jack> snyp: No problem, it's good to ask
08:15:18 <mangaba_leitosa> All, is haskell any special? What kind of tasks is it best for? What's are its advantages compared to other languages (e. g. Idris or Curry, etc.)?
08:15:38 <Reite> dadadadadadadada haskell!
08:16:00 <Eduard_Munteanu> There should be a FAQ for that, it's rather difficult to answer. :)
08:16:08 <ciaranm> !faq
08:16:09 <Eduard_Munteanu> Really, I don't even know where to start.
08:16:18 <ciaranm> aww, where did it go?
08:16:24 <Eduard_Munteanu> @where faq
08:16:24 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
08:17:22 <mangaba_leitosa> Eduard_Munteanu: this FAQ URL does not mention Idris nor Curry :-)
08:18:38 <Eduard_Munteanu> mangaba_leitosa: as far as Idris and other DT languages are concerned, there are issues like the very small library ecosystem and more generally that DT programming hasn't been explored a lot.
08:19:25 <og01> can i define functions in ghci without loading them from a file?
08:19:30 <Iceland_jack> yes
08:19:33 <Iceland_jack> using let
08:19:37 <Eduard_Munteanu> mangaba_leitosa: if you want to write code and run it nicely, Haskell is your best bet.
08:19:48 <Iceland_jack> Prelude> let double x = x + x
08:19:48 <Iceland_jack> Prelude> double 5
08:19:48 <Iceland_jack> 10
08:20:12 <og01> thanks
08:20:16 <GaveUp> newb question but I've come across several pieces of example code that have something like this "line <- catch (Right <$> UTF8.hGetLine handle) (return . Left)" followed be pattern matching on Left/Right ... I get how that line works (well not the return . Left yet) but what is the logic/reason behind using Left/Right?
08:20:23 <og01> i actually just had a typo :(
08:20:43 <tdammers> Left and Right are the constructors for Either
08:20:53 <tdammers> it's often used as a basic form of error handling
08:20:53 <Iceland_jack> GaveUp: Left = Failure, Right = Value (in this case)
08:21:09 <Eduard_Munteanu> GaveUp: it happens 'Either a b' is isomorphic to 'Success b' + 'Failure a'
08:21:09 <mangaba_leitosa> Eduard_Munteanu: aha, so, those exquisite languages are only good for academis purposes. Then I guess everyone is better off sticking into some mainstream language, such as haskell :-)
08:21:12 <tdammers> you get the "Right" result, or an error on the "Left"
08:21:15 <GaveUp> Iceland_jack: yeah, that I understand
08:21:54 <GaveUp> Eduard_Munteanu: so a bit of convention then?  That was where my reasoning was going...
08:21:55 <FireFly> If you want a mnemonic, "Right" is for when things go right.. or something
08:22:00 <FireFly> "Left" is what's er.. left
08:22:01 <tdammers> it's one step up from Maybe, where you can get "Just" the result, or else "Nothing"
08:22:04 <quchen> I've got a TVar whose contents should be copied to multiple other TVars each time it changes, `forever $ do { x <- readTVar t; mapM_ (...) [t2, t3, ...] }`.  Can I somehow change this so that the block loops only when "t" actually changes?
08:22:38 <tdammers> with Maybe, you can signal *that* something went wrong, but you can't provide more information
08:22:46 <tdammers> with Either, you can add some information to the failure
08:22:50 <Eduard_Munteanu> GaveUp: it's both a convention and a natural thing to do, because you define the Monad (Either a) instance, you can't just flip it.
08:23:16 <quchen> Thinking of it, a TMVar might solve my issue.
08:23:18 <Iceland_jack> GaveUp: It is a convention, but it makes sense due to how the datatype is defined as well as Eduard_Munteanu said
08:23:37 <GaveUp> Iceland_jack: right..ok then my thinking was on track
08:24:19 <Iceland_jack> GaveUp: I'll give you two quick examples where we want to increment a number in the either monad
08:24:21 <mangaba_leitosa> Eduard_Munteanu: and then there are are several special purpose languages such as Fay or Elm for Web... Why not one haskell to rule them all? :-(
08:24:31 <FireFly> Don't forget that it makes mnemonical sense! (in my mind at least)
08:24:32 <snyp> I am trying to write some functions to understand stuff better, like strip IO [a] to [a], but I get a 'Not in scope IO'. this is the function- let f :: (Monad m) => (m [a]) -> a; f (IO x:xs) = x:f(IO xs); f (IO []) = [];
08:24:41 <Iceland_jack> > fmap (+1) (Right 15)
08:24:43 <lambdabot>   Right 16
08:24:46 <Eduard_Munteanu> mangaba_leitosa: isn't Fay a Haskell EDSL?
08:24:49 <Iceland_jack> > fmap (+1) (Left "FAILURE!")
08:24:50 <lambdabot>   Left "FAILURE!"
08:25:04 <startling> mangaba_leitosa: I don't think so.
08:25:06 <mangaba_leitosa> Eduard_Munteanu: the description says that Fay implements a subset of haskell
08:25:06 <Iceland_jack> GaveUp: Notice how we don't touch the value when we have a Left?
08:25:07 <startling> er
08:25:11 <startling> Eduard_Munteanu: I don't think so.
08:25:29 <prophile> > Left "bees" <*> Left "faces"
08:25:30 <lambdabot>   Left "bees"
08:25:35 <prophile> k
08:25:55 <Iceland_jack> What an odd piece of code
08:26:09 <startling> prophile, you might like (<|>) more.
08:26:17 <ion> snyp: It’s not any more possible to convert an IO [a] into an [a] than to convert /bin/ls to a list of files.
08:26:23 <startling> > Left "bees" <|> Right "faces"
08:26:24 <lambdabot>   Right "faces"
08:26:38 <nooodl> snyp: "IO x" is a type, not a value
08:26:45 <prophile> startling: thanks
08:26:46 <snyp> oh
08:26:47 <FireFly> > Right "bees" <|> Left "faces"
08:26:49 <lambdabot>   Right "bees"
08:26:49 <Iceland_jack> snyp: What are you *actually* trying to do?
08:26:54 <snyp> i forget these things
08:27:57 <snyp> since getLine returns a IO String I want to see the string.
08:28:12 <Iceland_jack> snyp: Yes, but you can't do that outside the IO monad
08:28:26 <Iceland_jack> once you're in the IO monad, you (shouldn't) ^W don't get out
08:29:04 <ion> snyp: do { s <- getLine; print s }. That will result in “s” containing the string, but note that the full expression is still in IO.
08:29:18 <prophile> http://hackage.haskell.org/package/acme-realworld
08:29:29 <Iceland_jack> snyp: That should make sense :) You can think of IO as an infectious disease
08:29:54 <Iceland_jack> If you're infected you stay infected, if you touch someone: they get infected as well
08:30:16 <snyp> Iceland_jack: by 'still in IO' you mean the chain of >> and >>= functions?
08:30:31 <startling> snyp: the result is an IO whatever.
08:30:35 <Iceland_jack> Basically
08:30:48 <snyp> I need to clearly understand scopes in haskell
08:30:58 <Iceland_jack> This isn't a matter of scoping
08:31:39 <Iceland_jack> If you want to use the value (∷ String) you get from getLine (∷ IO String):
08:31:39 <Iceland_jack>     do value <- getLine; … value …
08:31:39 <Iceland_jack>  
08:31:42 <mangaba_leitosa> Iceland_jack: so, monads are basically mobile quarantine hospitals rather than burritos?
08:31:59 <Iceland_jack> mangaba_leitosa: Oh god I invented a new analogy!
08:32:02 <ion> snyp: IO String represents an impure computation that can be executed later. Combining an “IO String” and a “String -> IO ()” into an “IO ()” puts two such computations together into a bigger one that can be executed later. You get to have IO computations executed by assigning them into “main”: main = do { s <- getLine; print s }
08:32:13 <startling> Iceland_jack: it's not new.
08:32:42 <Iceland_jack> startling: And here I was thinking I was a genius :)
08:33:12 <startling> snyp: you can think of an IO x as a decision tree that can be executed and in all cases gives an x.
08:33:43 <ion> snyp: As an analogy, you can purely combine "echo hello" and "| grep e" into a string that represents an sh script. It’s still a representation of an sh script and not something that will be executed by evaluating the string. You can then choose to have sh execute it.
08:34:45 <snyp> ion: so monads are blobs of instructions which are pure only because they are of the type InstructionSequence ?
08:34:55 <ciaranm> eww
08:35:16 <snyp> s/monads/IO monads
08:35:23 <startling> snyp, constructing the instructions is pure. running the instructions is impure.
08:35:25 <ciaranm> a monad is not a pony
08:35:30 <ion> s/IO monads/IO values/
08:35:51 <ion> snyp: They themselves are pure values that represent impure computations. You can then do a specific thing to have that impure computation executed.
08:36:25 <Iceland_jack> snyp: I can manipulate IO actions in a pure way:
08:36:26 <Iceland_jack>     let (i, h, newline) = (putChar 'i', putChar 'h', putChar '\n') in do h; i; newline
08:36:37 <snyp> aha
08:37:16 <ion> main = [ print "first", print "second", print "third" ] !! 1
08:37:25 <merijn> snyp: Time to pimp my half-finished explanation of the IO monad again
08:37:56 <Iceland_jack> In C or Python, (putChar 'i', putChar 'h', putChar '\n') might put 'i' first, then 'h' and then '\n'; and then you end up with something like (None, None, None) or what ever
08:38:04 <merijn> If github manages to load so I can look up the gist
08:38:12 <ciaranm> a monad explanation is like a burrito. in that you'll spend the next morning on the toilet.
08:38:36 <snyp> Iceland_jack: you said we can get the String value from IO String only inside the IO monad. I don't understand the 'boundaries' of the IO Monad.
08:38:49 <merijn> ciaranm: It's not a monad explanation, it's explicitly and specifically an explanation of IO and the IO monad
08:38:57 <snyp> ok merijn
08:39:09 <startling> snyp, there's no such thing as "inside the _ Monad". it's just a lazy shorthand.
08:39:10 <Iceland_jack> snyp: If you have a do-block, and use (x ← getLine) within it, then x will be bound until the do-block ends
08:39:24 <geekosaur> lazy in the people sense, not the haskell sense :)
08:39:29 <merijn> snyp: ugh, my network connectivity sucks, try "gist.github.com/merijn" and see if you can find it yourself there's only like 3 or 4 gists there
08:39:40 <merijn> snyp: I can't managed to load the page and look up the exact URL
08:39:48 <merijn> snyp: Oh, there we go: https://gist.github.com/merijn/6478573
08:39:54 <ciaranm> it is acceptable to view monads as boxes only once you understand why a monad is nothing like a box
08:39:55 <mangaba_leitosa> ciaranm: in such a contect, burritos are more similar to quarantine hostpitals where you are suffering from an intestinal infection and spend much of your time in the toilet as well
08:40:13 <startling> Can we stop the stupid monad analogies please?
08:40:18 <snyp> thanks merijn. will take a look
08:40:31 <startling> I mean the deliberately "funny" ones.
08:40:41 <ion> snyp: To understand Haskell IO you can completely ignore the scary word “monad”. The function (>>=) :: IO a -> (a -> IO b) -> IO b that lets you glue together IO actions into bigger ones just happens to follow a common pattern with a number of other things.
08:41:22 * Iceland_jack . o O ( there should be a #haskell-monad )
08:41:54 <startling> snyp: so, looking at that type ^, the only way to get an "a" out of an "IO a" is to apply a function that takes the "a" and gives you an "IO somethingElse"
08:41:57 <snyp> ion: i get that part, the sequencing part. does retrieving the b value from IO b require knowledge of monads?
08:42:05 <Iceland_jack> snyp: no
08:42:06 <og01> whats a monad?
08:42:08 <ciaranm> yes. and you can put conversations into #haskell-monad. and conversations in #haskell-monad can be put into #haskell-monad too. but you can't leave #haskell-monad.
08:42:08 <ion> snyp: You can’t do that.
08:42:19 <snyp> ion: why can't i?
08:42:26 <startling> snyp, IO is special because the Haskell compiler and runtime see the IO action called "main" and execute it.
08:42:49 <snyp> ok..
08:42:58 <byorgey> snyp: A value of type IO b does not contain a b.
08:43:05 <startling> ciaranm, Iceland_jack: stupid metajokes count as stupid jokes.
08:43:09 <ion> snyp: Going back to the analogy to an sh script in a String… How do you convert the Haskell string "ls /" into a list of files in the root directory on your computer?
08:43:44 <Iceland_jack> I don't think snyp is asking for IO String → String but just how to use the result
08:44:04 <ion> snyp: If you want to have “ls /” executed and something done with the result, you can make a bigger string "ls / | while read file; do …; done", though.
08:44:04 <snyp> ion: do {exec "ls /"}  ... probably?
08:44:38 <ion> snyp: That would be “:: IO something”, not “:: something”
08:44:52 <Iceland_jack> snyp: ion's point is that “ls /” doesn't CONTAIN files, it contains how to get files
08:45:28 <og01> can someone tell me how i can do the first example in http://learnyouahaskell.com/syntax-in-functions in ghci?
08:46:07 <Iceland_jack> og01: let { lucky :: (Integral a) => a -> String ; lucky 7 = … ; lucky x = … }
08:46:20 <Entroacceptor> og01: http://stackoverflow.com/questions/2846050/how-to-define-a-function-in-ghci-across-multiple-lines
08:46:25 <og01> Iceland_jack: ok thanks :)
08:46:38 <og01> Entroacceptor: thanks
08:47:19 <ion> snyp: A Haskell value can’t interact with the hard disk to get a list of files. You can only make a value that describes to the computer how to do that (an IO value) and you can then have that executed by the specifically assigning it to “main”.
08:47:59 <GaveUp> Iceland_jack: yeah ... I think this part is making sense ... and if I understand correctly the return . Left is just saying wrap the error in Left
08:48:10 <Iceland_jack> GaveUp: yes
08:48:26 <ion> snyp: “IO a -> a” would mean you converted a description of how to get a list of files into a list of files without assigning the “IO a” value into main.
08:48:39 <snyp> Oh. i get it now. The String in IO String is just a specification of the type of value it returns?
08:48:49 <startling> snyp: yeah.
08:48:50 <ion> yeah
08:48:57 <Iceland_jack> Yes, 'IO a' returns something of a
08:49:00 <Iceland_jack> *of type a
08:49:26 <snyp> I thought there is an ADT like data IO a = IO a ? is there?
08:49:39 <Iceland_jack> You don't think about it
08:49:45 <startling> snyp: sort of. it's not like that.
08:49:48 <snyp> so that would actually have a string value emplaced there
08:49:57 <Iceland_jack> snyp: no
08:50:01 <snyp> which is contracdicting
08:50:02 <ion> snyp: That definition would mean there was an “a” inside it. That is not the case.
08:50:41 <Iceland_jack> What do you actually want to learn snyp, do you want to learn how to use something of type IO? Because that's very simple
08:50:51 <Iceland_jack> *type IO a
08:51:21 <funfunctor> Eduard_Munteanu: thanks..
08:52:00 <dwcook> @quote /bin/ls
08:52:01 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
08:53:19 <snyp> Iceland_jack: i know that's simple to use. I was trying to get how IO fits in with other types.
08:53:51 <snyp> anyway, i will read merijn's post now and stop worrying about it. :) bbl.
08:53:55 <snyp> Thanks
08:54:06 <Eduard_Munteanu> funfunctor: found anything useful?
08:57:44 <ion> @tell snyp One can imagine “data IO a = IO MachineCode” or “data IO a where { Return a :: IO a; Bind :: IO a -> (a -> IO b) -> IO b; GetLine :: IO String; PutStrLn :: String -> IO (); … }”. With the latter, one could imagine an interpreter existing for that ADT which would be invoked against a “main”.
08:57:44 <lambdabot> Consider it noted.
08:58:30 <ion> @tell snyp Err, Return :: a -> IO a
08:58:31 <lambdabot> Consider it noted.
08:58:37 <funfunctor> Eduard_Munteanu: Not really..
08:59:42 <funfunctor> Eduard_Munteanu: this is where I ma at with it https://gist.github.com/victoredwardocallaghan/7137189
09:03:30 <RpR> Did not find in ByteString.Char8 a toLower case.  Is there one somewhere?
09:06:11 <startling> RpR: it's in Data.Char
09:06:22 <startling> RpR, please don't use Data.ByteString.Char8
09:06:42 <ocharles> Data.ByteString.Char8 is fine
09:06:48 <ocharles> just please understand what you're doing
09:06:51 <RpR> startling: I got the ramifications of Unicode, ASCII.
09:07:32 <RpR> found: ctype_lower = listArray (0,255) (map (BI.c2w . toLower) ['\0'..'\255']) :: UArray Word8 Word8
09:07:32 <RpR> toLlower bs = B.map (\x -> ctype_lower!x) bs
09:07:32 <RpR>  
09:07:46 <RpR> Just seems it should be in BS.Char8
09:11:50 * hackagebot polysoup 0.3.0 - Online XML parsing with polyparse and tagsoup  http://hackage.haskell.org/package/polysoup-0.3.0 (JakubWaszczuk)
09:11:52 * hackagebot traverse-with-class 0.1.1.1 - Generic applicative traversals  http://hackage.haskell.org/package/traverse-with-class-0.1.1.1 (RomanCheplyaka)
09:22:38 <Hulahoop> Sorry, if I might disturb you. May I ask a question?+
09:22:50 <Eduard_Munteanu> Hulahoop: sure, don't ask to ask, just ask
09:24:34 <funfunctor> I don't know how people stand to write parsers.. drive me crazy..
09:25:03 <startling> funfunctor: there certainly can be a lot of weird nonlocal action.
09:25:21 * ocharles is parsing the entire PostgreSQL grammar at the moment
09:25:28 <ocharles> not particularly crazy-driving, but pretty boring work
09:25:37 <Hulahoop> Ok, so I am in college, first year. Now I have some trouble using commands as my professor showed on his beamer. He used a hugs compiler and typed qsort in and other commands, which I also tried at home. I got errors instead
09:26:03 <startling> the tricks ime are a) use a decent parser-combinator library, b) have a full test suite, c) put "try" around things that seem to be problems to confirm whether they are problems
09:26:04 <Iceland_jack> Hulahoop: What's the code?
09:26:16 <monoidal> Hulahoop: don't paste it here; use lpaste.org
09:26:25 <Hulahoop> ook. wait a bit
09:26:37 <Iceland_jack> You should in general prefer GHC to Hugs
09:27:04 <monoidal> Hulahoop: probably you need to write in a file, and load the file, instead of typing the declarations in the interactive mode
09:27:20 <ocharles> startling: if you do a you don't need c
09:27:23 <Hulahoop> ok, thank you, gonna try that first.
09:27:25 <ocharles> startling: that is, use uuparsing-lib
09:28:12 <funfunctor> well I am trying to define my lang formally using lbnf
09:28:42 <funfunctor> The tool is fantastic in that it generates pretty much a entire frontend for you plus a LaTeX document to go with !
09:29:13 <funfunctor> I am just trying to get my productions right..
09:32:21 <Guest99131> simple array syntax halp!  array ((0,1),(0,1)) [((i,j),i+10*j)|i<-[0,1],j<-[0,1]]  --> Error in array index??
09:32:52 <danharaj> —>?
09:33:16 <Eduard_Munteanu> Guest99131: i + 10 * j doesn't seem like a valid index.
09:33:37 <Eduard_Munteanu> @hoogle Ix
09:33:37 <lambdabot> Data.Ix module Data.Ix
09:33:37 <lambdabot> Data.Ix class Ord a => Ix a
09:33:37 <lambdabot> package ix-shapable
09:33:41 <supki_> @ty array
09:33:42 <lambdabot> Ix i => (i, i) -> [(i, e)] -> Array i e
09:33:48 <Eduard_Munteanu> @hoogle range
09:33:48 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
09:33:48 <lambdabot> Data.Ix rangeSize :: Ix a => (a, a) -> Int
09:33:48 <lambdabot> Language.Haskell.TH.Syntax data Range
09:34:02 <Eduard_Munteanu> > range ((0, 1), (0, 1))
09:34:03 <supki_> Guest99131: I think you want  array ((0, 0), (1, 1)) ...
09:34:03 <lambdabot>   [(0,1)]
09:34:06 <Guest99131> @Eduard_Munteanu: I thought i+10*j was the _value_
09:34:07 <lambdabot> Unknown command, try @list
09:34:08 <Eduard_Munteanu> Er.
09:34:22 <supki_> > range ((0, 0), (1, 1))
09:34:23 <lambdabot>   [(0,0),(0,1),(1,0),(1,1)]
09:34:29 <Guest99131> ah.
09:35:00 <Eduard_Munteanu> Guest99131: oh, right, misread
09:35:07 <Guest99131> thanks team!
09:35:21 <Rarrikins> > range ((0, 0), (1, 2))
09:35:23 <lambdabot>   [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2)]
09:35:24 <udevd>  > [ x | x<-[1..100] , x<10]
09:35:33 <Guest99131> b
09:35:37 <udevd>  > fadfsdgfsdgdf
09:35:44 <udevd>  > [ x | x<-[1..100]]
09:35:48 <udevd> hm
09:35:53 <Rarrikins> udevd: You seem to have a space in front of >
09:36:05 <monoidal> > [ x | x<-[1..100]]
09:36:07 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:36:39 <udevd> it's funny how [x | x<-[1..], x<10] doesn't stop, but well, quite obvious on the other hand...
09:36:51 * hackagebot ssh 0.2.12.1 - A pure-Haskell SSH server library.  http://hackage.haskell.org/package/ssh-0.2.12.1 (SimonMichael)
09:37:09 <Rarrikins> udevd: You can use takeWhile.
09:37:11 <monoidal> udevd: takeWhile
09:37:20 <udevd> yeah, i know... i don't want to use it, you know
09:37:29 <udevd> i just wanted to see how it behaves
09:37:34 <Rarrikins> Oh
09:39:48 <ocharles> Does anyone have a PDF of "Polish Parsers, Step By Step"?
09:40:01 <ocharles> google only finds something that 404s :(
09:40:20 <udevd> web.archive.org?
09:40:48 <ocharles> aha, as always - I ask the question and the immediately find it myself
09:42:00 <FireFly> ocharles: mind giving a link to it? sounds interesting
09:42:20 <ocharles>  http://www.cs.uu.nl/groups/ST/Software/UU_Parsing/p224-swierstra.pdf
09:43:27 <FireFly> Thanks
10:04:20 <k_89> why are there so many people on this channel ? isn't haskell an exotic lang ? do any of you guys actually use haskell professionally and all ?
10:04:37 <udevd> what do you mean >professionally?
10:04:40 <Eduard_Munteanu> I do.
10:04:42 <zomg> k_89: no we're just here for the lulz
10:04:59 <k_89> usually number of people on a language/technology's irc channel is kinda a measure of how much that specific thing is prevalent
10:05:03 <k_89> in the industry
10:05:11 <benedikt> k_89: Not always
10:05:19 <udevd> Haskell is used. for example in Microsoft and Facebook.
10:05:22 <tac> I'm here as an escapism from what I do professionally
10:05:24 <udevd> (fair enough for me)
10:05:25 <benedikt> Haskell is interesting, there are many interested people here
10:05:36 <k_89> hmm
10:06:02 <Eduard_Munteanu> k_89: not just end products, but a lot of companies / admins etc. use it to solve internal problems.
10:06:13 <zomg> I would use Haskell professionally if any of my coworkers knew the language
10:06:14 <zomg> Ha.
10:06:14 <zomg> =)
10:06:18 <k_89> hehe
10:06:25 <startling> k_89: learning Haskell is really popular, I think.
10:06:29 <Eduard_Munteanu> zomg: that's why I don't have coworkers. :P
10:06:42 <startling> as is adding something to your autojoin list and never removing it.
10:06:46 <zomg> Eduard_Munteanu: yeah well good for you if you've built something that pays the bills =)
10:06:50 <k_89> i don't know haskell, i am just looking into it because scala kind of put me off, and i want to learn some statically typed thing
10:07:03 <udevd> also, I have a question: how does `seq` from Prelude works `internally'? It needs to be somehow programmed first, and given GHC is bootstrapped it must be defined in Haskell
10:07:13 <benedikt> k_89: Check out Learn You A Haskell:
10:07:14 <benedikt> @where lyah
10:07:14 <lambdabot> http://www.learnyouahaskell.com/
10:07:26 <k_89> yup, i have all the sources and stuff
10:07:37 <startling> Prelude> :i seq
10:07:37 <startling> seq :: a -> b -> b 	-- Defined in `GHC.Prim'
10:07:38 <Eduard_Munteanu> udevd: yeah, it's "special". Though there are many ways to come up with a seq yourself.
10:07:39 <k_89> its just the time that i have to put in now
10:07:41 <startling> ^ udevd
10:07:44 <jfischoff> k_89: all the scala programmers I know seem to like Haskell more, for what it's worth
10:07:56 <udevd> Eduard_Munteanu: for example?
10:08:09 <startling> seq !x y = y
10:08:10 <Eduard_Munteanu> udevd: seq !a b = b  with bang patterns
10:08:13 <startling> yeah
10:08:55 <udevd> Eduard_Munteanu: does "!" mean just "do not be lazy and compute fucking a before execution"?
10:09:05 <startling> ish
10:09:09 <udevd> fair enough
10:09:11 <Eduard_Munteanu> Yeah, sort of.
10:09:18 <startling> it makes it strict on x. x may have lazy members.
10:09:51 <startling> you can make it strict on those members, too, though.
10:10:02 <startling> f (Just !x) = ...
10:10:47 <Eduard_Munteanu> data Seq a = Seq !a  -- I forget if you're allowed to do this, or if it only works for concrete types.
10:11:39 <Eduard_Munteanu> It should work though, you're just defining the accessor with a bang pattern, more or less.
10:12:13 <startling> seq (Seq _) b = b, then?
10:12:34 <Eduard_Munteanu> Yeah.
10:13:35 <udevd> some heavy recursive definition over there :D
10:13:48 <skypers> hey
10:14:17 <skypers> https://github.com/skypers/hsFModEx/blob/unstable/Sound/FModEx/Raw/Core/Functions.hsc < do you thing there’s a way to automate such a painful task with c2hs?
10:14:36 <udevd> i also wanted to ask, how fast executable does ghc is making in comparison to similar C code?
10:14:48 <skypers> quite good udevd
10:14:53 <skypers> often as fast
10:14:55 <skypers> sometimes faster
10:15:25 <udevd> how so? gcc is not very best compiler but is developed for years...
10:15:29 <Eduard_Munteanu> udevd: for very CPU-intensive stuff a few times slower is a reasonable expectation
10:15:42 <Eduard_Munteanu> gcc is pretty good.
10:15:43 <benedikt> Eh, let's not oversell it: it depends a lot on the problem domain and whether you're using ‘idiomatic’ Haskell or not
10:16:07 <benedikt> There are optimizations that can be performed in Haskell that can't be performed in a sane way in C though
10:16:19 <skypers> for the same amount of time you spend on writing lines, haskell programs almost all times will be faster imho
10:16:19 <udevd> mhm
10:16:30 <udevd> skypers: depends on the data
10:16:32 <tdammers> and vv., some things are much easier to optimize in C than in Haskell
10:16:46 <skypers> and if you optimize, you can beat C perf with haskell code
10:16:48 <udevd> i will now work on few gigabytes files, welp
10:17:00 <skypers> udevd: haskell perfectly handles such files
10:17:01 <benedikt> Yes, it's nuanced and people don't like nuanced answers…
10:17:03 <Eduard_Munteanu> udevd: do what on them?
10:17:12 <skypers> yeah benedikt
10:17:20 <skypers> nuanced answers are not answers :)
10:17:27 <jfischoff> Haskell is well suited for working with files to large to hold in memory all at once
10:17:42 <klugez> It's hard to say, because typically there's huge variance in performance between programs written in the same language.
10:17:54 <quchen> Is there a way I can make GHCi only emit the first error and not all of them? Got 500 lines of output right now and the scrolling/reloading is annoying :-)
10:18:09 <udevd> Eduard_Munteanu: some kind of Prelude.lookup of each line, reducing sections consisting of few hundred lines to list
10:18:14 <jfischoff> the main issue with making Haskell as fast as C is that it depends on GHC performing certain optimizations, and you have no idea if they are happening or not without looking at the core.
10:18:31 <udevd> actually I'll use IntMap instead od lookup-ing
10:18:35 <udevd> of*
10:18:43 <udevd> but this is how it'll work
10:18:54 <startling> jfischoff: yeah; that gets kind of annoying.
10:19:05 <jfischoff> So the process for microoptimizing Haskell is annoying also because the profiling tools are not as good as say VTune
10:19:42 <jfischoff> startling: I think the approach Repa 4 is taking is the wave of the future
10:19:59 <jfischoff> if the optimizations don't happen you get an error
10:20:07 <jfischoff> that is what I want actually
10:20:58 <startling> I don't know. a warning would be nicer.
10:21:08 <benedikt> The thing is that basic Haskell tutorials use lists which don't cut it when you need speed, for C though you can in general use arrays and rudimentary data structures and you can get pretty good performance
10:21:20 <jfischoff> sure a warning you could set as an error
10:21:42 <udevd> benedikt: what should be used instead of lists then?
10:22:21 <jfischoff> I have lists to suprisingly fast in some cases (compared to Vector)
10:22:25 <benedikt> udevd: You can use Vectors or Repa depending on your application, and ditch lazy IO: but my point is that all those things are something extra you need to learn
10:22:53 <udevd> the Vector from numeric.algebra or?
10:22:55 <simpson> benedikt: C trades safety for performance.
10:23:11 <simpson> benedikt: C also trades simplicity for safety.
10:23:18 <simpson> Er, other way around on that one, derp.
10:23:32 <benedikt> simpson: I didn't comment on the decisions, I was just saying that to make Haskell fast you generally need non-basic things
10:23:36 <udevd> simpson: not even that, i was surpised that haskell code that you write almost always gives result you want ie no debugging
10:23:51 <fizruk> benedikt, in C one has to learn much more not to shoot himself in the foot and get the job done, i think
10:23:59 <udevd> which is not frequently seen in C
10:24:01 <udevd> xD
10:24:13 <simpson> benedikt: Oh. Well, that's more due to the nature of the data structures used rather than the algorithms.
10:24:13 <benedikt> FireFly: But you can do it so much faster! (shooting yourself in the foot that is)
10:24:19 <simpson> benedikt: Scheme, for example, has the same problems.
10:24:27 <FireFly> fizruk*
10:24:31 <startling> lists aren't so bad. they're nice when you want to be lazy.
10:25:05 <benedikt> Not saying lists are bad, lists are excellent building blocks
10:25:14 <klugez> Or use them as stacks. Mostly the problem is not using lists. It's just always defaulting to lists.
10:25:51 <khs> Hi, I'm trying to parse some http headers from a ByteString, anyone know how to do this?
10:25:54 <klugez> In C you tend to always default to arrays. That's not ideal either, because Map or HashMap have their place too.
10:25:59 <klugez> And all the other data structures.
10:26:33 <fizruk> I don't believe C has arrays, actually
10:26:41 <udevd> also, can I use bang inside a definition? i mean, something like >fun a b = let !c = gun a  !d = nun b... in bun c d
10:26:48 <benedikt> fizruk: Let's not get into that :)
10:26:52 <klugez> For a lot of performance requiring stuff arrays are a better default than lists, though, if you only use one data structure.
10:27:01 <fizruk> benedikt, sorry :)
10:28:01 <fizruk> > let Just !x = Just (error "Oops!") in 23
10:28:02 <lambdabot>   23
10:29:20 <udevd> welp
10:29:35 <udevd> now i'm confused
10:29:43 <fizruk> > let Just !x = Just (error "Oops!") in !x
10:29:45 <lambdabot>   <hint>:1:39: parse error on input `!'
10:29:50 <fizruk> > let Just !x = Just (error "Oops!") in x
10:29:51 <lambdabot>   *Exception: Oops!
10:29:56 <fizruk> me too
10:29:58 <benedikt> udevd: Why?
10:29:58 <skypers> 19:03 < skypers> https://github.com/skypers/hsFModEx/blob/unstable/Sound/FModEx/Raw/Core/Functions.hsc < do you thing there’s a way to automate such a painful task with c2hs?
10:30:38 <fizruk> my ghci says "<interactive>:74:25: Not in scope: `x'" for last one :(
10:30:54 <udevd> benedikt: that proves it is valid syntax, but ghci should break when encountering an error, shouldn't it?
10:31:22 <benedikt> udevd: You never use x
10:31:26 <fizruk> let x = undefined in 23
10:31:42 <udevd> benedikt: but you're telling ghci to compute x anyway
10:31:45 <benedikt> > let x = undefined in 23
10:31:46 <lambdabot>   23
10:31:52 <udevd> welp
10:32:10 <fizruk> > let x = undefined in const 23 x
10:32:11 <lambdabot>   23
10:32:47 <udevd> @def const' !a !b = const a b
10:32:47 <lambdabot>  Parse failed: BangPatterns is not enabled
10:32:49 <udevd> welp
10:32:50 <geekosaur> udevd, this is binding, not assignment. binding does nothing unless you refer to the binding
10:32:50 <udevd> xD
10:33:07 <fizruk> > let !x = undefined in const 23 x
10:33:07 <geekosaur> assignment actually does something, and would trigger an exception
10:33:08 <klugez> > let !x = undefined in const 23 x
10:33:08 <lambdabot>   *Exception: Prelude.undefined
10:33:09 <lambdabot>   *Exception: Prelude.undefined
10:33:33 <udevd> okay
10:33:40 <fizruk> > let !x = undefined in 23
10:33:41 <lambdabot>   *Exception: Prelude.undefined
10:33:55 <udevd> are you sure geekosaur?
10:33:55 <geekosaur> a binding is just a name. put another way: if I define a function which throws an exception in some language, but never call it, do you expect simply defining that function to cause an error/exception?
10:34:09 <fizruk> > let Just !x = Nothing in 23
10:34:10 <lambdabot>   23
10:34:20 <fizruk> udevd, ^
10:34:20 <FireFly> What's !x ?
10:34:24 <geekosaur> same thing here, if I never use the thing I bound, it doesn't throw an exception
10:34:42 <bennofs> Whats !? (Interobang)
10:34:45 <bennofs> oops
10:34:55 <udevd> okay, i see
10:35:31 <benedikt> > let f !x = 5 in f undefined
10:35:33 <lambdabot>   *Exception: Prelude.undefined
10:35:33 <bennofs> Would you consider this a bug in cabal: hdevtools-0.1.0.6 (latest: 0.1.0.5) (new package)
10:35:57 <bennofs> latest on hackage is 0.1.0.5, that's right, but still ...
10:36:14 <klugez> FireFly: Bang pattern. It means that the pattern match is evaluated to WHNF (to the outermost constructor).
10:36:37 <dcoutts> bennofs: presumably you have 0.1.0.6 installed (or as local src in the sandbox)
10:36:54 <bennofs> dcoutts: I see. Just a bit confusing :)
10:37:00 <klugez> > let !(Just !x) = Just undefined in 23
10:37:01 <lambdabot>   *Exception: Prelude.undefined
10:37:09 <FireFly> Oh
10:37:45 <dcoutts> bennofs: you mean that it shows you that you're not using the latest on hackage, because you're actually using a later one than what's available
10:37:46 <klugez> FireFly: It's a language extension and not part of Haskell 2010, but a pretty commonly used extension.
10:38:14 <bennofs> dcoutts: Yes
10:42:50 <skypers> aaaaand
10:42:50 <skypers> http://lpaste.net/94754
10:42:59 <skypers> my first victory with my FModEx binding!
10:43:04 <skypers> it runs perfectly! :)
10:43:22 <skypers> is there a function for fromRational . toRational?
10:43:31 <danharaj> :t fromRational . toRational
10:43:31 <lambdabot> (Fractional c, Real a) => a -> c
10:44:02 <skypers> dested: I know that
10:44:12 <fizruk> :t fromRational
10:44:13 <lambdabot> Fractional a => Rational -> a
10:44:20 <skypers> I thought a function like fromReal would exist
10:44:28 <supki_> @src realToFrac
10:44:28 <lambdabot> realToFrac = fromRational . toRational
10:44:30 <skypers> to cast 4 :: Int into a Floating value for instance
10:44:38 <skypers> oh nice
10:44:43 <skypers> thank you supki_
10:44:47 <supki_> :)
10:44:52 <skypers> is there a way to reverse hoogle something ?
10:45:05 <skypers> like @rhoogle fromRational . toRational
10:45:07 <skypers> and hop
10:45:14 <skypers> result: realToFrac
10:45:15 <skypers> ?
10:45:35 <fizruk> skypers you could just ask for its type
10:45:46 <dcoutts> bennofs: https://github.com/haskell/cabal/commit/0f00536c1d47cd394f3547255f68ed54a9016e7b
10:46:22 <skypers> yeah
10:46:25 <skypers> that’s a great idea :)
10:46:26 <skypers> thank you
10:46:33 <supki_> @@ @hoogle @type fromRational . toRational
10:46:35 <lambdabot>  Prelude realToFrac :: (Real a, Fractional b) => a -> b
10:46:35 <lambdabot>  Unsafe.Coerce unsafeCoerce :: a -> b
10:46:35 <lambdabot>  Prelude ($) :: (a -> b) -> a -> b
10:46:55 <fizruk> supki_, wow!
10:47:34 <geekosaur> I like how that finds unsafeCoerce :p
10:47:49 <carter> hey everyone, should we update the subject to point to mavericks + xcode5 joint work around?
10:48:16 <carter> https://gist.github.com/cartazio/7131371 is the current directions i'm giving people that seems to work  // monoidal  monochrom  johnw  lispy  etc
10:51:56 * hackagebot git-annex 4.20131024 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-4.20131024 (JoeyHess)
10:56:40 <monochrom> hehe "horrible edit your settings file thing"
10:57:47 <monochrom> actually GHC's settings file is meant to be edited. it's why they bothered to factor out those settings into that file. some settings there are pretty recent and by popular demand, actually.
10:59:04 <monochrom> the recently demanded one is "what options may I pass to ld" because gnu ld and gold differ.
10:59:21 <joelteon> is there a guide for making RPMs out of cabal packages?
11:00:15 <joelteon> oh, i can check the rpm spec
11:00:33 <joelteon> possibly
11:08:16 <jscoder> Guys how is the reverse function to `fromEnum` called?
11:08:56 <simukis_> :t toEnum
11:08:57 <lambdabot> Enum a => Int -> a
11:09:34 <jfischoff> > toEnum 0 :: Bool
11:09:35 <lambdabot>   False
11:16:16 <carter> monochrom: fair enough
11:16:26 <carter> monochrom: its just something new GHC users shouldn't have to do
11:18:11 <carter> like, it'd be very very easy to change your settings file so GHC just doens't wokr
11:19:19 <monochrom> that is also true
11:22:03 <donri> joelteon: cabal-rpm does it for you
11:40:11 <carter> monochrom: yup! Hence why "this is evil, be careful"
11:40:12 <carter> :)
11:44:36 <lpaste> xico pasted “Num and Enum?” at http://lpaste.net/94759
11:44:42 <xico> can someone explain me that?
11:44:57 <xico> it seems i cannot put the type explicitely for my code to compile
11:45:48 <xico> or more explicitely, it seems that somehow i can use a non-Num instance as a Num one
11:46:23 <xico> (i.e. i do not understand why line 6 works)
11:47:33 <lpaste> xico revised “Num and Enum?”: “No title” at http://lpaste.net/94759
11:48:24 <Eduard_Munteanu> xico: record updates change types
11:49:24 <skypers> ok so to release a new package in hackage
11:49:32 <skypers> we now have to release as “candidates”?
11:49:39 <xico> Eduard_Munteanu: what?!
11:49:47 <xico> Eduard_Munteanu: i could have never figured that out. thanks!
11:50:11 <xico> and in fact, its awesome for my application
11:50:38 <Eduard_Munteanu> xico: aes and the entire 'aes { colour = size }' can have different types, that is.
11:51:12 <Eduard_Munteanu> xico: but you might get an ambiguity error once you fully-define plot
11:51:34 <xico> Eduard_Munteanu: yes, i got other errors, this is just a testcase for the lpaste
11:51:43 <xico> Eduard_Munteanu: but that explains a lot!
11:51:59 * hackagebot steeloverseer 0.5.0.0 - A file watcher.  http://hackage.haskell.org/package/steeloverseer-0.5.0.0 (SchellScivally)
11:52:25 <Eduard_Munteanu> xico: yeah, record update syntax is unusual. Another one to remember is update syntax binds even tighter than function application.
11:53:15 <Eduard_Munteanu> e.g. you can write   f Foo { ... } = ...
11:53:53 <xico> ah yes, hlint gave me some hint on that
11:54:02 <xico> (i could not understood what you said until the example)
11:54:19 <xico> are record updates defined in the 2010 report?
11:55:41 <jim_> I want to flatten a tree....  Normally I would make it Foldable and use (:), but the problem is, the children of a node are only available thorugh IO (getChildren::Widget->IO [Widget])....  Does this make Foldable useless for me?  What should I use instead (other than 'just write a function to flatten it')
11:56:31 <Eduard_Munteanu> @hoogle foldrM
11:56:31 <lambdabot> Data.Foldable foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
11:57:40 <Eduard_Munteanu> jim_: is your tree IO-specific, or do you just get the data from IO?
11:58:07 <jim_> eduard- I don't think that works here, because I can't even write the foldable instance
11:58:24 <jim_> the tree needs to use IO to get the children
11:58:41 <Eduard_Munteanu> jim_: you'd write the instance for a normal n-ary tree
11:58:42 <jim_> it actually is the gtk2hs widget child parent relationship
11:59:52 <jim_> eduard- how....  The only way to get children is using a function Widget->IO [Widget]....  What do I write in the iFoldable instance funciton.
12:00:07 <jim_> sorry, extra i
12:00:11 <jim_> there is no iFoldable
12:01:00 <Eduard_Munteanu> jim_: your tree can be pure, it's just something like   data Tree a = Tree a [Tree a]
12:01:09 <fizruk> jim_, can't you get all Widget's recursively to make Tree Widget and then flatten that pure tree?
12:01:40 <Eduard_Munteanu> jim_: to get an actual tree, you probably want Traversable because that gives you 'sequence'
12:01:51 <Eduard_Munteanu> :t Data.Traversable.sequence
12:01:52 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
12:02:00 * hackagebot steeloverseer 0.5.0.1 - A file watcher.  http://hackage.haskell.org/package/steeloverseer-0.5.0.1 (SchellScivally)
12:02:31 <fizruk> jim_, I mean like getWidgetTree :: Widget -> IO (Tree Widget)
12:03:00 <carter> xico: youer working on a ggplot like too :)
12:03:10 <jim_> eduard and fizruk- I guess you both are saying that I should wrap the tree in another data object which is pure, then let foldl lazily get the items I need?
12:03:50 <Eduard_Munteanu> jim_: no, your tree *is* pure.
12:03:53 <jim_> I think that might make sense
12:04:24 <Eduard_Munteanu> jim_: it's just you get it from IO
12:04:30 <jim_> eduard- how so?  Sorry, I don't understand
12:05:09 <jim_> a wrapped tree could be, but the one gtk2hs gives is definitely not
12:05:18 <Eduard_Munteanu> jim_: what if you had a function getElement :: IO (a, IO [a])?
12:05:41 <jim_> basically that is what I have.
12:05:56 <Eduard_Munteanu> It doesn't mean the lists are IO-specific.
12:06:59 <jim_> eduard- but in that example I still would need a wrapper data item to even make it foldable....
12:07:02 <Eduard_Munteanu> jim_: let's take an easier example... listGetters :: [IO a]. You just get a normal list if you 'sequence' it.
12:07:31 <jim_> yes
12:07:39 <jim_> I get that....
12:07:45 <Eduard_Munteanu> jim_: well, you need Traversable, not Foldable, because you have to pick a traversal order.
12:07:58 <Eduard_Munteanu> jim_: e.g. depth-first vs breadth-first
12:08:06 <fizruk> jim_, I guess you should tell what actual Tree datatype you're talking about
12:08:07 <Eduard_Munteanu> It matters because IO.
12:08:29 <jim_> fizruk- gtk2hs widget tree
12:08:46 <fizruk> jim_, could you please give a link?
12:09:00 <Eduard_Munteanu> jim_: so, to wrap it up, you probably want to write a function that traverses the tree and returns a IO (Tree Widget), using a -> IO [Widget] functions or what you have.
12:09:40 <Eduard_Munteanu> jim_: said function is pretty much an implementation of sequence.
12:10:00 <Eduard_Munteanu> :t Data.Traversable.sequence
12:10:01 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
12:10:41 <Eduard_Munteanu> Tree (IO a) -> IO (Tree a)
12:10:42 <jim_> fizruk- Well, it is spread apart across the whole gtk2hs documentation, but this has a function called containerGetChildren which holds the gist of what I need http://hackage.haskell.org/package/gtk-0.11.2/docs/Graphics-UI-Gtk-Abstract-Container.html
12:11:30 <jim_> eduard- I need to think more about what you are saying (I am still learning), but the main point seems correct to me....
12:11:30 <Eduard_Munteanu> jim_: do you know how to write a depth-first traversal, generally?
12:12:44 <jim_> eduard- Out of haskell definitely, in Haskell, I could do it but not sure if it would be idiomatic
12:12:51 <carter> tahts ok
12:12:52 <carter> :)
12:12:58 <Eduard_Munteanu> jim_: well, it's the most natural thing in Haskell actually :)
12:13:40 <Eduard_Munteanu> You just apply your getChildren recursively and collect results in a list.
12:14:05 <Twey> Eduard_Munteanu: That describes breadth-first pretty well too :þ
12:14:12 <jim_> I would do something like listOfItems x = item x ++ listOfItems (children x)
12:14:34 <Eduard_Munteanu> Twey: yeah but you need a queue, not a stack, so it's more fit for e.g. Seq
12:15:02 <Eduard_Munteanu> jim_: something like that
12:15:12 <xico> carter: indeed. are you writting some ggplot like things?
12:15:20 <Twey> True
12:15:27 <carter> xico: its on the collaboration to do list
12:15:36 <xico> what is that?
12:15:37 <carter> constraint is it has to be Haskelly :)
12:15:42 <carter> i have a todo list
12:15:52 <carter> and things i'm collabing on over time
12:15:56 <carter> and that are happening shortly
12:16:05 <jim_> eduard- That part I can do, but I think I need to go understand some of the classes better (ie- the difference between Foldable Traversable, etc)
12:16:06 <Eduard_Munteanu> jim_: getAllChildren :: ContainerClass self => self -> IO (Tree Widget)
12:16:38 <xico> carter: :) do you have some code?
12:16:42 <carter> xico: wait a while
12:16:49 <carter> i've a bit on my plate
12:16:59 <carter> also we've decided to make it go FULL lensy
12:17:04 <carter> so i need to learn lens a smidge
12:17:11 <carter> xico: what rendring backend are you using?
12:17:15 <xico> seems a good choice
12:17:23 <ij> How do I find out what the "i e" is in CArray's type def? http://hackage.haskell.org/package/carray-0.1.5/docs/Data-Array-CArray.html By the associated typeclasses in instance defs?
12:17:43 <Eduard_Munteanu> jim_: and you have 'data Tree a = Tree a [a]'
12:17:54 <xico> carter: i just tried playing a bit, so i am using cairo and opengl now. diagrams looks nice though.
12:18:00 <carter> diagrams is nice
12:18:09 <carter> xico: you may want to look at chart to get some ideas too
12:18:15 <carter> which does a diagrams plotting backend
12:18:17 <Eduard_Munteanu> jim_: recursion terminates when you have a   Tree a []  since there are no children to recurse on.
12:18:21 <carter> chart is a bit crufty api wise
12:18:24 <xico> carter: yeah, i saw the gsoc code
12:18:25 <carter> xico: hobby hacking for for work?
12:18:38 <xico> carter: hobby. i use ggplot for work
12:18:42 <carter> cool
12:18:49 <carter> R and Python annoy me
12:18:56 <Eduard_Munteanu> jim_: and how do you check children? Well, you have containerGetChildren :: ContainerClass self => self -> IO [Widget]
12:18:58 <carter> i can't read the types and know how to interact with stuff
12:19:12 <jim_> eduard- That is the problem....  I do have a data tree, but I think I did it wrong.  Effectively I have the IO in the tree itself....
12:20:00 <Eduard_Munteanu> jim_: you can do that too, but it's a bit more complex. If you have such a tree, you want to write a 'sequence' (i.e. Traversable) for it.
12:20:05 <xico> carter: yeah, same here. i already translated most of my workflow to haskell though.
12:20:17 <xico> carter: but plots and stats seems lacking a bit
12:21:00 <jim_> eduard- Oh....  Actually after this talk I think I might want the pure tree.
12:21:01 <carter> xico: i'm working on getting numerical tooling sorted
12:21:11 <carter> been figuring out a satisfactory design over the past 1.5 years
12:21:36 <xico> carter: yeah, i guess you told about that before. i cant wait for the release :)
12:21:42 <carter> icant either
12:21:51 <jim_> eduard- Thanks a lot....  I definitely have enough to go forward, after a bit of googling (mostely on traversible)
12:21:56 <Eduard_Munteanu> jim_: anyway, I was saying you can write something like   getAllChildren w = do { ws <- containerGetChildren; <recurse on the list here> }
12:22:08 <Eduard_Munteanu> Er, 'containerGetChildren w'
12:22:36 <jim_> yeah, I think that is the way to go....
12:23:40 <jim_> eduard- Thanks again!
12:25:38 <Eduard_Munteanu> :t (last &&& head) . span ?p
12:25:39 <lambdabot>     Couldn't match type `([a2], [a2])' with `[a0]'
12:25:40 <lambdabot>     Expected type: ([a2], [a2]) -> a0
12:25:40 <lambdabot>       Actual type: [a0] -> a0
12:25:55 <Eduard_Munteanu> Er.
12:26:08 <Eduard_Munteanu> :t (last *** head) . span ?p
12:26:09 <lambdabot> (?p::a -> Bool) => [a] -> (a, a)
12:26:23 <Eduard_Munteanu> Is there something like that around?
12:26:57 <xico> ehat
12:27:04 <xico> (ouch) what is ?p btw?
12:27:21 <Eduard_Munteanu> xico: implicit params, a trick to avoid lambdas
12:27:28 <ion> eduard_munteanu: Is (error "*** Exception: last: empty list", error "*** Exception: head: empty list") a close enough approximation?
12:27:30 <xico> Eduard_Munteanu: thanks
12:27:31 <Eduard_Munteanu> When used with lambdabot, that is.
12:28:01 <Eduard_Munteanu> ion: heh, no, I want a "safe" equivalent.
12:28:35 <udevd> >concat [[]]
12:28:37 <Eduard_Munteanu> Could give me a list.
12:28:44 <udevd> >concat [[1],[2]]
12:28:52 <udevd> > concat [[1],[2]]
12:28:53 <lambdabot>   [1,2]
12:28:56 <udevd> > concat [[]]
12:28:57 <lambdabot>   []
12:28:59 <udevd> > concat []
12:29:00 <lambdabot>   []
12:29:12 <udevd> > concat [[[]]]
12:29:13 <lambdabot>   [[]]
12:30:29 <Twey> Eduard_Munteanu: breadthFirst ts = map rootLabel ts ++ (ts >>= breadthFirst . subForest) — what's wrong with this definition?  No queue required
12:31:35 <foster63> Is there a MOOC which will help me learn Haskell?
12:33:01 <Eduard_Munteanu> Twey: I suppose that works for such trees
12:33:34 <mangaba_leitosa> foster63: only indirectly. You can take an ML/Racket or Scala course, and it might help a little :-)
12:34:01 <Eduard_Munteanu> Twey: but a traversal might visit nodes for purposes other than flattening the tree, in case it's a more complex scenario.
12:35:01 <foster63> I'm doing the PL course at Coursera.  We're learning ML.
12:35:05 <kartoffelbrei> earlier today i asked about non-blocking hGetLine etc. now i made an http://lpaste.net/94761. previously i said it wouldn't work with -threaded. it turns out i was just being an idiot. it does and always did work fine with -threaded. but my main question still stands are there non-blocking hGetLine versions? or do i have to write them myself? because i think the "chan polling" workaround to be really ugly. Any other suggestions for
12:35:06 <kartoffelbrei> getting rid of the chan polling?
12:35:06 <Eduard_Munteanu> Twey: e.g. if traversing the tree has side effects, you'll want a queue because it lets you unfold it in the right order
12:35:38 <foster63> mangaba_leitosa: Thanks for that info
12:35:55 <Twey> Eduard_Munteanu: Isn't that ‘isomorphic’ to using that function and then folding the list?
12:36:22 <Twey> kartoffelbrei: You're not supposed to poll Chans…
12:36:45 <DanielDiaz> how can I close the main thread from a childe? do I have to do it using MVars? or there is another nice way I don't know?
12:37:12 <Eduard_Munteanu> Twey: only if the shape is known beforehand, I think.
12:37:15 <Twey> kartoffelbrei: The idiomatic solution that comes to mind is to produce a new thread for the rest of your operation
12:37:19 <carter> DanielDiaz: theres an api for these things
12:37:50 <foster63> Short of taking a non-existent MOOC and reading all the books, what's the best way to learn?
12:37:57 <Twey> DanielDiaz: You can use throwTo, but I think the nice way would be with an MVar ()
12:38:13 <Twey> foster63: Read books; code stuff :þ
12:38:32 <Eduard_Munteanu> Twey: anyway, DFS/BFS are often described in terms of queues vs stacks outside Haskell.
12:38:34 <Twey> foster63: You can pick up quite a lot from hanging around this channel
12:38:45 <DanielDiaz> Twey: yes, I figured out the MVar method, but maybe there was something more elegant. OK, I will do that.
12:38:57 <foster63> Twey: Ok, I'm hanging, at least for a while...
12:39:00 <DanielDiaz> thank you
12:39:01 <Eduard_Munteanu> (not in that order :D)
12:39:01 <Twey> Eduard_Munteanu: *nod* That's definitely conventional, but I'm not sure it's fundamental
12:39:32 <Twey> Hehe
12:40:09 <kartoffelbrei> Twey: ok i used term "polling" incorrectly. i check in wether otr not the chan is empty and yield the value only when i try write a line in the stdin of the shell pipe. once i know there are no value coming from upstream, i stop interleaving and yield from the chan directly. I'm not "polling" but i don't know what else to call it.
12:41:27 <Twey> foster63: The way I would do it is to move the ‘rest of the function’ into your new thread.  So instead of requesting input then going off to do something else and checking back for the input, you request the input then spawn a new thread that blocks on the input and then does whatever you want with that
12:41:46 <Twey> Er
12:42:06 <Twey> kartoffelbrei: ↑ that's for you, sorry
12:42:32 <mangaba_leitosa> foster63: yes, I was refering to this same course :-)
12:43:16 <Eduard_Munteanu> Twey: oh wait, yours might not work: there are more nodes on a level than just the immediate subforest
12:43:17 <Twey> kartoffelbrei: Non-blocking IO is managed for you by the runtime; the threads are an abstraction over it, so you don't need to do non-blocking IO directly
12:43:30 <Twey> Eduard_Munteanu: Oh, you're right
12:43:32 <kartoffelbrei> Twey: producing a new thread for the rest does not work. i want to return a clean Pipe. in that solution i'd have to put the awaiting part into a different thread than the yielding part. this simply doesn't typecheck (and i'm sure it breaks pipe laws).
12:44:28 <joelteon> donri: awesome
12:44:44 <foster63> mangaba_leitosa: I'm on week 4 :-)  Great fun but very hard, have you taken the course?
12:44:55 <kartoffelbrei> i tired it nonetheless. in the end i had to leave the current pipes "context" one way or the other to make it typecheck. which completely crippled the pipes behavior.
12:47:21 <kartoffelbrei> Twey: about that Non-blocking IO in the runtime: thank you, but i know that already. i just think that having functions like that would allow me to get rid of the rather awkward TChan juggling.
12:49:22 <mangaba_leitosa> foster63: no, I'm taking coursera's 'Principles of functional programming in Scala' now (Week 6)
12:49:46 <foster63> join cousera-pl
12:49:52 <foster63> bollocks :-(
12:49:55 <xico> is there a way to specify that all instances of a given class (Enum) are instance of a specific class (MyClass). this would prevent having to write "instance MyClass AType where" without a where clause, since i use default definitions.
12:50:29 <Eduard_Munteanu> xico: yes, but you should use a newtype wrapper
12:50:40 <mangaba_leitosa> foster63: have a hoard of cases to see how Haskell is better than Scala :-)
12:51:16 <foster63> mangaba_leitosa: So you think Haskell is better?
12:51:36 <mangaba_leitosa> foster63: no doubt :-)
12:51:47 <Eduard_Munteanu> xico: newtype MyClassFromEnum a = MCFE a deriving Enum   instance (Enum a) => MyClass (MyClassFromEnum a) where
12:51:53 <xico> Eduard_Munteanu: i do not think i can. i defined it with "data MyClass = A | B | C deriving Enum". do you mean i should add a "newtype AType' deriving MyClass'?
12:52:09 <xico> Eduard_Munteanu: ok. thanks
12:52:11 <foster63> mangaba_leitosa: Think I will do the Scala course next.  Are you enjoying it?
12:52:26 <xico> Eduard_Munteanu: looks good :)
12:52:34 <Eduard_Munteanu> xico: you can do without the newtype wrapper but you risk overlapping instances
12:53:32 <mangaba_leitosa> foster63: I have mixed feelings. Because when I see how such and such feature is implemented in Scala, I think 'in Haskel it's simpler and takes less code to write'
12:53:41 <Eduard_Munteanu> xico: or consider making Enum a superclass of MyClass if any MyClass has to be an Enum.
12:53:44 <mangaba_leitosa> foster63: that is, the course is great, the language is not that great :-)
12:54:48 <mangaba_leitosa> foster63: but I think it's OK for its 'improved Java' niche
12:54:59 <xico> Eduard_Munteanu: it is already a super class (if you mean "class Enum a => MyClass a"
12:55:28 <foster63> mangaba_leitosa: So Haskell is your favourite language?  I'm really liking ML.
12:55:34 <Eduard_Munteanu> xico: oh, then why are you making a typeclass?
12:55:47 <Eduard_Munteanu> xico: why not   myClassFunction :: Enum a => ...   ?
12:56:29 <xico> Eduard_Munteanu: wait ... :-D
12:56:39 <mangaba_leitosa> foster63: I'm still learning Haskell. But it's the most powerful of all I tried so far. I like ML (in form of ocaml) as well
12:56:53 <xico> Eduard_Munteanu: ah ok. i need several definitions of myClassFunction
12:56:54 <Eduard_Munteanu> xico: you could just use a constraint synonym (ConstraintKinds) if you need to give Enum a more sensible name.
12:56:59 <xico> Eduard_Munteanu: depending on the constraints
12:57:35 <Eduard_Munteanu> xico: like what?
12:57:36 <foster63> mangaba_leitosa: Can you recommend a good tutorial?  I have "Real World Haskell" and "LYAH" already.
12:57:36 <xico> Eduard_Munteanu: that is, i have a "myClassFunc = func1" in general, but "myClassFunc = func2" for some other types
12:57:51 <Eduard_Munteanu> Oh ok.
12:58:50 <mangaba_leitosa> foster63: I learned Haskell using Bird/Wadler's 'Introduction to functional programming', but my old edition is based on Miranda. The new edition is based on Haskell
12:58:55 <Eduard_Munteanu> xico: but are all MyClass instances also instances of Enum?
12:59:05 <xico> Eduard_Munteanu: yes
12:59:46 <FreeFull> foster63: Did you already finish LYAH and now are looking for more
12:59:47 <FreeFull> ?
13:00:53 <mangaba_leitosa> foster63: also, the articles 'Why functional programming matters' by John Hughes and "Can programming be liberated from the von Neumann style?" by John Backus helped me a great deal
13:01:17 <mangaba_leitosa> foster63: but these articles are not Haskell-based :-)
13:03:09 <mangaba_leitosa> foster63: to understand lambda calculus and combinators, I read parts of 'Introduction to Functional Programming' by John Harrison
13:04:55 <fizbin> You know those studies showing that kloc / dev is roughly constant regardless of language? I don't think they were done on HXT picklers.
13:05:26 <fizbin> Either that, or working with HXT has damaged my brain enough that my sense of time is totally off.
13:05:50 <Eduard_Munteanu> If that's true they're probably comparing different languages applied to different problems.
13:06:11 <Eduard_Munteanu> That, or there's a cap on dev productivity. :)
13:06:50 <fizbin> Maybe I'll make it up in less debug time. Once it compiles, it must be correct, right?
13:07:11 <foster63> mangaba_leitosa: These all look like good sources
13:07:49 <foster63> FreeFull: I've "browsed" it several times.  I always come unstuck at Monads.
13:09:06 <FreeFull> foster63: Have you tried simply completely going through from start to the end? You can't really understand monads without understanding functors and typeclasses first
13:09:15 <mangaba_leitosa> foster63: oops, the last book is by Anthony Field and Peter Harrison, not John harrison
13:09:39 <mangaba_leitosa> foster63: it does not consider Haskell, but it has useful theory (lambda calculus)
13:10:42 <Zogatribe> takeMVar/putMVar? pure my arse.
13:11:04 <copumpkin> o.O
13:11:10 <Eduard_Munteanu> ap yours :P
13:11:37 <foster63> FreeFull: What I need to do I think is actually "do some Haskeel"
13:11:54 <Eduard_Munteanu> @keel
13:11:54 <lambdabot> what is the max amount of operands haskell can handle in a single expression?
13:12:48 <foster63> mangaba_leitosa: I'm looking up those books on Amazon
13:13:51 <tac> @keel
13:13:52 <lambdabot>  what have you been smoking? you narrow minded Haskell user?
13:13:56 <tac> What is @keel?
13:14:07 <sclv_> quotes from a former troll on the channel
13:14:23 <Eduard_Munteanu> @help @keal
13:14:23 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:14:38 <fizbin> @keel
13:14:38 <lambdabot> they dumbified you
13:14:47 <fizbin> @help @keel
13:14:47 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:14:57 <fizbin> @help keel
13:14:57 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:15:01 <sclv_> play with the bot on -blah or in privmsg
13:15:12 <fizbin> Yeah, ok.
13:15:45 <tac> @help help
13:15:45 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:16:06 * sclv_ repeats himself
13:17:04 * hackagebot groundhog 0.4.0.2 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-0.4.0.2 (BorisLykah)
13:17:06 * hackagebot groundhog-sqlite 0.4.0.2 - Sqlite3 backend for the groundhog library  http://hackage.haskell.org/package/groundhog-sqlite-0.4.0.2 (BorisLykah)
13:17:08 * hackagebot groundhog-postgresql 0.4.0.2 - PostgreSQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-postgresql-0.4.0.2 (BorisLykah)
13:17:35 <Zogatribe> I think #Haskell is one big April fool. State monad? IORef and MVar? Pure my arse. Waste of fucking time.
13:17:50 <Eduard_Munteanu> Aw.
13:18:03 <elliott> Zogatribe: do you plan to do anything other than troll?
13:18:28 <Eduard_Munteanu> Zogatribe: you didn't expect it to be totally pure, did you? Because totally pure means it does nothing to the outside world. :)
13:18:57 <Zogatribe> except I have seen many haskell advocates scream there is no such thing as mutable state
13:18:59 <Zogatribe> and similar bullshit
13:19:09 --- mode: ChanServ set +o elliott
13:19:10 <Hannibal_Smith> Eduard_Munteanu, it's a good way to make your pc hotter, can be good if outside is cold!
13:19:12 <Eduard_Munteanu> Zogatribe: what's important is isolating impure stuff from pure functions
13:19:14 --- mode: elliott set +q Zogatribe!*@*
13:19:35 <elliott> Zogatribe: I'll take that off in five minutes to give you a chance to cool down and stop yelling at/insulting people.
13:20:09 <elliott> if you'd like to discuss Haskell politely after that, feel free -- how to model state and IO in a pure language is certainly an interesting topic.
13:21:41 <elliott> (no, insulting the entire 1,000+ person channel is not really better than insulting people individually)
13:22:04 * hackagebot groundhog-mysql 0.4.0.2 - MySQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-mysql-0.4.0.2 (BorisLykah)
13:25:35 --- mode: elliott set -q Zogatribe!*@*
13:28:02 <Zogatribe> I think #Haskell is one big April fool. State monad? IORef and MVar? Pure language my arse. Waste of fucking time.
13:28:31 --- mode: elliott set +b *!*Zogatribe@*.skybroadband.com
13:28:31 --- kick: Zogatribe was kicked by elliott (wrong decision)
13:28:32 <carter> huh
13:28:33 <briennetheblue> zzz
13:28:33 --- mode: elliott set -o elliott
13:28:52 <Eduard_Munteanu> Not even a different message.
13:29:00 <travisstaton> He seems sweet
13:29:01 <carter> elliott: i need to learn those commands for if trolls ever hit one of the channels i admit
13:29:14 <carter> i was going to say "i look at the reigster allocation of my haskell code sometimes"
13:29:43 <carter> the pure code sometimes has the register allocation i'd *hope* C does on a good day
13:29:45 <carter> sometimes not
13:30:14 <joelteon> i wonder what makes someone think "i'm going to wake up today and troll #haskell"
13:30:54 <DanielDiaz> joelteon: it's a mistery
13:31:07 <tank441> Hey
13:31:24 <tank441> I was wondering what function I could use to evauluate a list of 2 booleans to see if they equal eachother
13:31:27 <Eduard_Munteanu> To boldly troll where everybody has trolled before.
13:31:40 <tank441> so if True == True = True. and False == False = True
13:31:42 <carter> DanielDiaz: once i get my array / matrix lib out i hope i can get you to switch :)
13:32:09 <carter> *to mine :)
13:32:20 <DanielDiaz> carter: about the matrix packate?
13:32:24 <DanielDiaz> *package
13:32:25 <carter> yes
13:32:28 <Eduard_Munteanu> tank441: what about other lists?
13:32:35 <Eduard_Munteanu> What do you do for []?
13:32:37 <carter> i've strong strong opinons about memory locality and performance :)
13:32:39 <DanielDiaz> carter: that would be awesome, I needed a matrix implementation without LAPLACK and thos things
13:32:41 <tank441> Huh?
13:32:49 <tank441> There's only going to be a list of 2 variables
13:32:49 <carter> DanielDiaz: i'll be providing both :)
13:32:52 <nemesit|znc> anyone using vim for haskell dev?
13:32:55 <mauke> tank441: why are those bools in a list?
13:33:03 <carter> DanielDiaz: one thing i had to figure out was actually making it easy to provide multiple backends
13:33:09 <Eduard_Munteanu> tank441: then you can just pattern-match on it
13:33:11 <FireFly> nemesit|znc: probably plenty of people
13:33:13 <carter> i'll only provide shallow embeddings in the initial release
13:33:28 <tank441> It's a logical function, to test if two propositions are equal to one another
13:33:33 <carter> but i'll be doing initially "fastest thing you can do with only private to the package haskell + c bits"
13:33:35 <mauke> tank441: why are those bools in a list?
13:33:37 <carter> "strictly just haskell"
13:33:41 <carter> and "ffi to all the nice things"
13:33:43 <carter> backends
13:33:44 <nemesit|znc> FireFlyi i'm really new to haskell ;-p wonder what are some nice plugins for error checking etc
13:33:49 <carter> 2 or 3
13:34:04 <FireFly> nemesit|znc: I mostly use it as a text editor, so I dunno
13:34:08 <tank441> Because it evaluates one proposition and then matches it against the other one
13:34:13 <mauke> tank441: what
13:34:21 <tank441> I input 2 propositions, and each one has a true/false value
13:34:23 <mauke> that doesn't even contain "list"
13:34:28 <mauke> explain the list
13:34:35 <DanielDiaz> carter: sounds awesome. and you will have a LaTeX backend to print your matrices for free: http://hackage.haskell.org/package/HaTeX-3.8.0.0/docs/Text-LaTeX-Packages-AMSMath.html#g:17
13:34:48 <carter> DanielDiaz: intersting matrices are too big
13:34:51 <tank441> http://gyazo.com/b571cc2c01cc4788869dc1dc81dcfdbe
13:34:56 <carter> but you'd certainly be able to do that yourself
13:35:02 <tank441> That's the question, it's coursework
13:35:11 <tank441> So just need some pointers, not a direct answer
13:35:15 <mauke> tank441: that doesn't contain "list"
13:35:29 <carter> DanielDiaz: it'd be trivial to write an adapter yourself
13:35:31 <DanielDiaz> carter: well, there are interesting matrices of different sizes. But, yes, most of them are big.
13:35:34 <carter> yes
13:35:45 <tank441> Wouldn't the 2 input propositions each have a true/false value?
13:35:51 <mauke> tank441: hello?
13:35:54 <carter> point being: it'd be trivial to pop out the contents into that data type
13:36:00 <Eduard_Munteanu> tank441: yes, but why use a list?
13:36:01 <carter> i just wont do it in my lib
13:36:14 <carter> because then it'd be perceived as signalling i'm using your stuff for peformance :)
13:36:15 <tank441> Is there an easier way to do it?
13:36:21 <tank441> This questions left me really confused..
13:36:23 <DanielDiaz> carter: the reason to make that package is because I wanted matrix rendering in LaTeX, but didn't want a dependency in hmatrix
13:36:27 <mauke> tank441: I don't see how lists would make any of this easier
13:36:27 <Eduard_Munteanu> tank441: sure, just give 'equivalent' the two parameters
13:36:43 <mauke> the exercise doesn't mention lists
13:36:45 <carter> DanielDiaz: ok
13:36:47 <carter> well
13:36:53 <Eduard_Munteanu> tank441: 'equivalent' isn't [Prop] -> Bool
13:36:56 <mauke> the type signature of 'equivalent' doesn't even allow lists
13:36:58 <carter> once i get my stuff out, i'd love to be a dep
13:37:00 <carter> will be BSD or MIT
13:37:00 <mauke> so how did you come up with lists?
13:37:20 <tank441> :t equivalent
13:37:21 <lambdabot> Not in scope: `equivalent'
13:37:25 <DanielDiaz> carter: thank you!
13:37:28 <tank441> woops
13:37:31 <Eduard_Munteanu> tank441: you're supposed to define it :)
13:37:36 <carter> DanielDiaz: i'm still 1-2 months from release
13:37:41 <tank441> Yeah..
13:37:41 <carter> life + income and all that jazz
13:38:13 <tank441> http://lpaste.net/94764
13:38:19 <tank441> thats what I defined so far
13:38:24 <Eduard_Munteanu> Actually you're not supposed to just compare bools.
13:38:25 <carter> DanielDiaz: think of what i'm doing as kinda like a funny hybrid of the ideas in vector repa and dph and hmatrix, but aiming to be usable and extensible and fast
13:38:30 <carter> DanielDiaz: one thing i want eventually
13:38:31 <mauke> oh, interesting
13:38:34 <carter> and won't be in the initial reslease
13:38:40 <mauke> tank441: what are the types of envs and names?
13:38:43 <carter> will be support for deep embedding backends
13:38:47 <mauke> tank441: and eval
13:38:54 <carter> so you could in theory have a backend that pretty prints code to latex mebe
13:39:02 <tank441> names :: Prop -> Names
13:39:03 <carter> instead of Compiling it in the normal sense
13:39:08 <carter> that'd be kinda interesting....
13:39:12 <tank441> envs :: Names -> [Env]
13:39:13 <carter> has some implications
13:39:14 <carter> though
13:39:19 <DanielDiaz> carter: I see. As long as it is easy to use (and install) and efficient, I am happy
13:39:20 <carter> like you wind up needing to take some ideas from Accelerate
13:39:22 <tank441> eval :: Env -> Prop -> Bool
13:39:31 <carter> DanielDiaz: theres going to be a simple to use layer
13:39:52 <tank441> type Names = [Name]       type Env = [(Name, Bool)]
13:39:56 <carter> DanielDiaz: a good metaphor would be what diagrams does for Vector graphics, but for numerical math
13:39:58 <carter> things
13:40:07 <carter> so there can def be a use friendly layer
13:40:17 <carter> but there'd be some sort of power user substrate that you can extend
13:40:45 <mauke> tank441: this is harder than it looks
13:41:00 * mauke ponders
13:41:05 <tank441> Lol
13:41:37 <mauke> tank441: is there also a function Env -> Env -> Env?
13:41:54 <DanielDiaz> carter: good. I'm looking forward to see it working. will it have a LU decomposition with the properties listed here? http://hackage.haskell.org/package/matrix-0.2.1/docs/Data-Matrix.html#g:13
13:42:19 <tank441> Nope mauke
13:42:36 <carter> DanielDiaz: if i can't give a nice API for the matrix factorizations, there'll be bigger problems :)
13:43:04 <DanielDiaz> carter: I specifically wanted to point to: "L_(i,j) <= 1, for all i,j."
13:43:04 <mauke> tank441: what does eval [] (Var "P") do?
13:43:40 <tank441> An empty list wouldn't work I believe
13:43:44 <carter> DanielDiaz: again, if i can't write all the matrix factorizations, there'll be problems :)
13:43:54 <DanielDiaz> carter: awesome. :)
13:44:08 <mauke> not entirely unrelated: http://www.spoj.com/problems/TAUT/
13:44:09 <carter> you're welcome to help write some of them once i get the core substrate out :)
13:44:27 <Cylta> how do I call funtion 1000 times, and put it into 1000 cells, and later read to console from that 1000 cells? (yes, I think in loops, not in formulas...)
13:44:28 <DanielDiaz> carter: I'll be glad.
13:44:40 <tank441> I implemented a tautology function earlier
13:44:55 <tank441> And I tried to follow on with this one because I believe it would be similar
13:45:11 <carter> DanielDiaz: if by the end of next summer we don't have most of the stuff in the Golub book written, in a shocking succint way thats pseudo functional style and performant, i'll have failed
13:45:14 <carter> or gotten distracted
13:45:40 <DanielDiaz> carter: haha, ok
13:45:46 <carter> life and stuff :0
13:45:48 <carter> :)
13:45:56 <carter> or not the right caffeine dosage
13:52:11 * hackagebot blank-canvas 0.2.3.1 - HTML5 Canvas Graphics Library  http://hackage.haskell.org/package/blank-canvas-0.2.3.1 (AndyGill)
13:52:29 <lpaste> tessier pasted “cabal install process” at http://lpaste.net/94765
13:52:56 <tessier> Anyone know why I am getting that error? If I'm missing a -dev package I don't know which.
13:53:39 <geekosaur> process can't be installed standalone, I think? it's a bootlib
13:54:23 <carter> tessier: what OS
13:57:11 * hackagebot rethinkdb 1.8.0.4 - RethinkDB driver for Haskell  http://hackage.haskell.org/package/rethinkdb-1.8.0.4 (EtienneLaurin)
14:01:02 <DanielDiaz> carter: please, let me know when you are ready for the switch.
14:01:12 <carter> DanielDiaz: you mean launch?
14:01:12 <carter> oh
14:01:16 <carter> i'm not taking the patckage name
14:01:21 <carter> i've my own package names planned :)
14:01:33 <sykora> Did the parsec-parsers package suddenly become obsolete? Its instances became part of parsers as of 0.1.0.
14:01:47 <carter> i just have very strong feelings about linear algebra from thinking / working on it for the past nearly 2 years
14:01:57 <skypers> how much time do I have to wait before my package is not candidate anymore?
14:02:15 <DanielDiaz> carter: You mentioned "switch" before. In any case, "matrix" is a pretty standard name.
14:02:29 <carter> oh yeah
14:02:31 <carter> :)
14:03:06 <DanielDiaz> carter: and I am not paying it as much love as it deserves.
14:03:29 <carter> once i get my stuff out, i'll be wanting to get everyone to dep on / use my stuff
14:03:44 <carter> i'll try to follow PVP well, though i'll be making lots of breaking changes to refine the API over time
14:03:47 <carter> :)
14:03:51 <carter> ok
14:03:53 <carter> bak to work
14:03:54 <carter> ttyl :)
14:04:12 <DanielDiaz> good luck
14:05:34 <carter> i don't need luck, i need focus
14:05:36 <carter> thanks
14:08:11 <henk> Iceland_jack: mystery action (x:xs) = do action x; mystery action xs?
14:08:30 <tessier> carter: CentOS 6.4
14:08:37 <carter> no clue :)
14:08:38 <carter> gl
14:08:46 <carter> i'm hanging my hat on debugging
14:09:00 <carter> i made sure folks can get 10.9  / xcode 5 working with ghc 7.6
14:09:05 <carter> i'm done for the next 6 months
14:09:06 <carter> :)
14:10:04 <tessier> What's odd is that the file it claims to be missing is at /usr/lib64/ghc-7.0.4/process-1.0.1.5/include/runProcess.h
14:11:19 <geekosaur> tessier, yes, it's actually a package internal file and the one for a different version of the process library can't be used
14:12:38 <geekosaur> apparently this *was* fixed once and is broken again: http://ghc.haskell.org/trac/ghc/ticket/5449
14:12:59 <carter> tessier: i'd recommend getting ghc 7.6
14:13:00 <carter> :)
14:14:15 <Iceland_jack> henk: yes
14:15:47 <henk> Iceland_jack: yay
14:16:04 <tessier> carter: There don't seem to be CentOS RPMs for that so I would have to uninstall my current RPMs and install it from source.
14:16:16 <carter> tessier: you can try using the bin dist online
14:16:25 <carter> tessier: or hvr has some debs you could try to use
14:16:50 <carter> tessier: first see if you can get the generic linux bin dist working
14:17:11 <carter> and use that (and or use that to boostrap a native build that works well)
14:21:17 <acowley> I feel like sandboxes should make using multiple GHCs really easy. Does someone have a link to some quick notes on doing so?
14:22:12 * hackagebot FModExRaw 0.1.0.0 - The Haskell FModEx raw API.  http://hackage.haskell.org/package/FModExRaw-0.1.0.0 (DimitriSabadie)
14:22:40 <henk> Iceland_jack: AFAICT from the logs that was supposed to help me understand monads, right?
14:23:23 <Iceland_jack> henk: Focus on understanding individual instances, IO, Maybe, lists, ...
14:23:47 <Iceland_jack> for the time being; I'm busy atm so I can't help much now
14:24:10 <henk> ah ok, will do that. Thanks a lot for your time yesterday, I really appreciate it (:
14:24:21 <colluphid> im trying to understand exactly what happens when i foldr1 (\(x:xs) -> (x:).union xs)
14:25:15 <colluphid> on a list of lists
14:33:36 <carter> acowley: i think you can just have the ghc-path stuff fields int he sanbox
14:33:39 <carter> but haven't tested yet
14:34:06 <carter> acowley: you know the  1.18 config files
14:34:11 <carter> for program path and options?
14:34:13 <acowley> I haven't used them
14:34:15 <carter> ok
14:34:16 <carter> yes
14:34:34 <acowley> Was hoping there was a blog post somewhere with the "Do this: ..."
14:34:42 <carter> i'm telling you the "this"
14:34:51 <carter> you know how when you sandbox init
14:34:59 <carter> they tell you "put your own cabal config file here"
14:35:00 <carter> bit?
14:35:27 <acowley> Yes
14:37:03 <carter> put the https://gist.github.com/cartazio/7145322 there
14:37:14 <carter> then specify the paths you want to change
14:37:22 <carter> like ghc path
14:37:29 <carter> and ghc-pkg etc etc
14:37:52 <carter> https://gist.github.com/cartazio/7145322#file-gistfile1-txt-L8-L9
14:37:55 <carter> i've not tried it
14:38:00 <carter> but just doing that should do the trick
14:38:17 <henk> How can I convert seconds to hh:mm:ss format? Is my own function the easiest way or is there a good package for things like that?
14:38:42 <ta479> http://bartoszmilewski.com/2011/01/09/monads-for-the-curious-programmer-part-1/
14:38:53 <carter> henk: you cant, time doesn't work that way
14:39:00 <carter> :(
14:39:06 <ta479> in fig. 2, above it he says, the diagram must commute
14:39:15 <carter> well you can, but ti'd be wrong
14:39:21 <carter> because of how actual time works
14:39:24 <carter> its kinda crazy
14:39:27 <carter> really neat
14:39:28 <carter> but crazy
14:39:36 <ta479> either from A -> f -> B -> F(B) or A -> F(A) -> F(f) -> F(B)
14:39:44 <ta479> but isn't that associativity?
14:40:01 * glguy suspects henk just want something that uses 60 seconds to a a minute, 60 minutes to an hour and isn't interested in silly leap anythings
14:40:15 <joelteon> can cabal download the tar.gz for a package without unpacking it?
14:40:18 <joelteon> cabal get without unpack, I mean
14:40:35 <ta479> or actually idk, but commutivity means something like B*A is the same as A*B to me
14:40:35 <ReinH> carter: what do you mean?
14:40:45 <jfischoff> joelteon: fetch maybe
14:40:45 <carter> leap seconds and days and stuff
14:40:53 <carter> and time zones
14:40:54 <jfischoff> or wget
14:40:58 <carter> time zones change
14:41:07 <carter> are socio-cultural-historical things
14:41:15 <ReinH> carter: I don't think any of those things apply
14:41:16 <joelteon> damn
14:41:21 <lpaste> henk pasted “time/task tracker” at http://lpaste.net/94767
14:41:24 <carter> i'mt tired let me be silly
14:41:26 <carter> :)
14:41:28 <ReinH> carter: :p
14:42:19 <carter> amusingly: the time zone db is on github and versioned :) https://github.com/eggert/tz
14:42:29 <glguy> > let f :: Int -> String; f sec = printf "%d:%02d:%02d" (sec `div` 3600) (sec `div` 60 `mod` 60) (sec `mod` 60) in map f [0,10,100,1000,10000]
14:42:30 <lambdabot>   ["0:00:00","0:00:10","0:01:40","0:16:40","2:46:40"]
14:42:31 <henk> That’s what it’s about. This program calculates the duration for each task in the logfile and prints it in seconds. I want to make the output nicer to look at by converting e.g. 611 to 10:11 or 00:10:11
14:42:56 <carter> henk: sorry i'm being a bit silly :)
14:43:07 <henk> carter: hehe ok
14:43:54 <henk> glguy: looks good, thanks
14:44:22 <acowley> I'd use thyme if possible
14:47:20 <Hafydd> colluphid: by my reckoning, it will be (almost*) equivalent to \((x : xs) : xss) -> x : (xs `union` (nub . concat) xss). (* it will be undefined if any of the xss is empty).
14:49:17 <carter> acowley: if we could get ryantrinkle to Open source the time conversion lib they have, that'd be cool too :)
14:49:21 <Hafydd> colluphid: that is, it computes the union of all of the given lists, except it keeps any duplicates in the first list, and it doesn't remove any duplicates (in any of the lists) of the first element of the first list. I can't really imagine a use for it, so maybe I'm mistaken.
14:50:59 <acowley> Time is very awkward. I don't know that formatting gets much more compact than formatTime, but it's based on format strings so a little icky. http://www.haskell.org/ghc/docs/latest/html/libraries/time-1.4.0.1/Data-Time-Format.html
14:52:34 <Hafydd> colluphid: wait, that last description was incorrect. It will remove any duplicates of x from the xss, but the end result may still contain duplicates of x.
14:52:42 <carter> acowley: again, ryantrinkle has some stuff for that :)
14:53:58 <thoughtpolice> acowley: oh, btw, i watched your robotics talk the other day, it was quite fantastic.
14:54:14 <acowley> thoughtpolice: Thanks! It was a lot of fun.
14:54:30 <acowley> I wish the audience was mic'd though
14:54:40 * thoughtpolice has to give a talk on Tuesday and is a bit nervous
14:55:20 <acowley> There was a lot of laughter that I think set the right mood
14:55:26 <acowley> I'm always nervous before a talk
14:56:12 <djahandarie> Robotics talk?
14:56:19 <djahandarie> Robotics + Haskell by any chance?
14:56:24 <acowley> djahandarie: Of course!
14:56:34 <djahandarie> Excellent!
14:56:42 <djahandarie> Where do I find it?
14:56:48 <thoughtpolice> djahandarie: of course, acowley only has the highest standards :P
14:56:57 <acowley> djahandarie: http://vimeo.com/77164337
14:57:04 <djahandarie> Great, thanks
14:57:10 <djahandarie> thoughtpolice, of course
14:57:35 <acowley> I'm giving a 12 minute version of it in Tokyo in a little over a week
14:57:43 <acowley> well, maybe not so much Haskell
14:57:46 <djahandarie> Wow, exciting.
14:57:59 <djahandarie> There are some Haskell meetups in Tokyo.
14:58:04 <djahandarie> Maybe you could give the full thing there.
14:58:07 <acowley> Yeah, the crazy thing is that the paper which I'll be presenting has already been cited
14:58:24 <acowley> The publishing apparatus is comically slow
14:58:28 <thoughtpolice> wow such masterful
14:58:30 <thoughtpolice> so skill
14:58:44 <acowley> This is a conference paper that's cited months before it's published
14:59:08 <acowley> Journals are so far out of step, it's hard to put them on the map :/
14:59:21 <colluphid> Hafydd: its part of a primes sieve to `minus` multiples from a list of primes
15:00:20 <Hafydd> colluphid: oh, how is it used?
15:01:07 <colluphid> primes    = 2 : 3 : 5 : 7 : ([9, 11 ..] `minus` nonprimes)
15:01:18 <colluphid> where nonprimes = foldr1 (\(x:xs) -> (x:).union xs) [[p*p, p*p+2*p .. ] | p <- tail primes]
15:01:55 <carter> acowley: does't stephanie have some PL type papers that got 20+ citations before it stoped getting rejected by conferences?
15:02:08 <colluphid> I guess it doesn't matter if there are duplicates in nonprimes, since there never will be any in primes
15:02:45 <Rarrikins> You can rename it nonprimes' and make nonprimes clean it.
15:02:52 <acowley> carter: Ha! I hadn't heard about that, but I believe it.
15:02:58 <Ghoul_> @pl (\x- > let (|>) = flip ($) in [1..x] |> filter (>3) |> Just)
15:02:58 <lambdabot> (line 1, column 4):
15:02:58 <lambdabot> unexpected " "
15:02:58 <lambdabot> expecting "->"
15:03:05 <Ghoul_> @pl (\x -> let (|>) = flip ($) in [1..x] |> filter (>3) |> Just)
15:03:05 <lambdabot> (line 1, column 12):
15:03:05 <lambdabot> unexpected "("
15:03:05 <lambdabot> expecting "()", natural, identifier or "in"
15:03:06 <carter> this was 5+ years ago
15:03:24 <jfischoff> carter: what's the quickest way around the clang preprocessor issue?
15:03:28 <colluphid> Rarrikins: you mean remove the duplicates?
15:03:40 <Ghoul_> is there anything like flip ($) ?
15:04:06 <colluphid> whats the point since duplicate values dont influence the `minus`
15:04:25 <carter> jfischoff: "xcode-select --install ; brew tap homebrew/versions ; brew install apple-gcc42 ; brew link apple-gcc42" then edit the settings file as i describe in this link  https://gist.github.com/cartazio/7131371
15:04:27 <Rarrikins> colluphid: If you're providing it in a library or something.
15:04:36 <acowley> jfischoff: the apple-gcc42 thing worked great for me
15:04:42 <carter> acowley: yay
15:04:52 <carter> acowley: jfischoff  now pay me my hourly rate
15:04:52 <acowley> jfischoff: Though I hadn't made note of the xcode-select --install step
15:04:53 <carter> nowwww
15:05:05 <acowley> So everything was properly busted for a while
15:05:05 <Twey> Ghoul_: Lens has (&)
15:05:06 <carter> acowley: some peopel somehow don't have xcode CLI tools installed
15:05:22 <Ghoul_> > [1..3] & head
15:05:24 <lambdabot>   1
15:05:32 <Ghoul_> > [1..3] & head & (+1) & Just
15:05:34 <lambdabot>   Just 2
15:05:35 <acowley> The whole xcode CLI tools thing is a little janky
15:05:36 <Ghoul_> cool
15:06:02 <Twey> acowley: Does arXiv have a faster publishing rate?
15:06:09 <carter> Twey: once a day
15:06:10 <carter> :)
15:06:10 <acowley> It's a distant second class to Xcode proper
15:06:15 <acowley> Twey: Yes :)
15:06:18 <Twey> carter: One paper per day?
15:06:28 <carter> Twey: no, batch upload of all the new stuff every day
15:06:30 <Twey> Ah, right
15:06:31 <acowley> No, everything per day
15:07:22 <carter> acowley: the CLI tools only happened because 3rd parties were inventing a CLI tools thing of their own for OS X by ripping out those binaries and libs and repackagingit
15:07:33 <acowley> I see
15:07:44 * startling cough kennethreitz cough
15:07:49 <carter> who?
15:07:59 <startling> Oh, he's a pretty high-profile python guy
15:08:01 <acowley> I think he cough-sneeze-coughed
15:08:03 <acowley> oh
15:08:04 <startling> the "for humans" guy
15:08:20 <startling> "http for humans", "command-line for humans", "python for humans" ...
15:08:27 <Hafydd> colluphid: what is minus?
15:08:37 <acowley> I can't believe I missed a "for humans" movement. What does that make me?
15:08:55 <carter> someone who doens't have to do much python :)
15:09:00 <startling> acowley, well, I hear extraterrestrials use functional programming ...
15:09:02 <companion_cube> if you're not for humans, you're against humans
15:09:42 <acowley> So I am alien invader, but at least I am not snake-like.
15:11:14 <carter> hehe
15:11:16 <carter> true
15:11:17 <colluphid> Hafydd: the difference of two ordered lists
15:13:14 <Mdx> Anyone has a minute to spent? I'm running on something bizarre with darcs
15:13:24 <carter> #darcs is for darcs experts :)
15:13:35 <carter> but mebe someoen here knows
15:13:56 <Mdx> well, I think the first part is more cabal related
15:14:25 <Mdx> http://lpaste.net/94768 i get this error message, but downloading from the website and using 7zip to unpack works fine
15:14:43 <Hafydd> colluphid: is the union used there Data.List.union?
15:15:40 <colluphid> Hafydd: Data.List.Ordered
15:16:58 <Hafydd> colluphid: ah. That's the sort of thing you should mention before asking such a question.
15:18:01 <xico> how do i write "toEnum $ fromEnum x `mod` (fromEnum maxBound)
15:18:14 <xico> such that the second fromEnum has the same type as the first?
15:18:38 <acowley> add a type signature
15:18:41 <colluphid> it looks as though there are no duplicates in nonprimes since an element will only occur once in a given list
15:18:47 <colluphid> "An element occurs in the output as many times as the maximum number of occurrences in either input"
15:19:21 <xico> acowley: without scoped types?
15:19:37 <colluphid> Hafydd: in this context they preform the same...
15:19:44 <Twey> xico: Try: toEnum $ on mod fromEnum x maxBound
15:19:53 <Twey> :t on
15:19:56 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
15:20:02 <Twey> on fixes the type
15:20:04 <xico> @where on
15:20:04 <lambdabot> I know nothing about on.
15:20:07 <Twey> Data.Function
15:20:10 <xico> Twey: thanks :)
15:20:12 <xico> looks nice
15:22:16 <acowley> That does look nice!
15:22:33 <acowley> xico: I would have bound it to a name so I could write a type without any funny stuff
15:22:50 <Twey> In the general case, yeah, you want to do that
15:23:51 <xico> acowley: yeah, but i needed it to work on any (Bounded h, Enum h) => x :: h
15:24:18 <xico> (im distypic)
15:24:22 <Twey> Haha
15:24:37 <carter> xico: enum is busted api wise
15:24:55 <acowley> I don't know what (Bounded h, Enum h) => x :: h means
15:24:59 <startling> carter: why do you say that?
15:25:16 <carter> because theres no way to talk about enumeration orders
15:25:30 <acowley> I didn't think you could lift type classes to the kind level like that
15:25:30 <carter> i have a more general thing than Enum, that lets you have different enumeration orders
15:26:00 <startling> You mean "enumerate this type in ascending order"?
15:26:22 <startling> (How do they rise up, rise up ...)
15:26:26 <carter> what order is ascenting for (Int,Int)
15:26:38 <carter> theres a few
15:26:41 <carter> :)
15:26:56 <startling> carter, lexicographical would be the one I'd think. that's a good point though.
15:26:58 <carter> nope
15:27:00 <carter> well yeah
15:27:02 <carter> both
15:27:09 <carter> theres no canonical "one true one"
15:27:11 <xico> i'd love a cantor one
15:27:23 <carter> and theres valid enumable things that need extra info to correctly enumerate them
15:27:43 <carter> like indexes in a matrix / tensor  according to the memory layout
15:27:56 <carter> xico: you mean interleaved? :)
15:27:59 <startling> enumerate :: Enum f => f Ordering -> f a -> [f a] ?
15:28:16 <startling> that's not quite right.
15:28:17 <carter> why would it be a functor?
15:28:25 <startling> I didn't say Functor anywhere.
15:28:33 <carter> Enum takes a *
15:28:35 <carter> not a *->*
15:28:37 <acowley> oh blech, I keep on needing hoist-like things
15:28:41 <Hafydd> colluphid: they do not. Using Data.List.union, that definition would never terminate.
15:28:45 <acowley> I wish everything just worked automatically
15:28:45 <startling> Sure. I'm talking about some other potential Enum-like class.
15:28:54 <carter> startling: soemtime in the next week i'll finish my Layout class
15:29:00 <carter> and i can share it
15:29:03 <startling> carter: what's it do?
15:29:04 <carter> and you'll see what i mean
15:29:10 <carter> lets me index into various matrix layouts
15:29:12 <Ghoul_> hey thats a cool idea.
15:29:12 <carter> and back again
15:29:23 <startling> carter: you mean they're lenses?
15:29:26 <carter> errrm
15:29:27 <carter> not quite
15:29:34 <carter> maybe they fit in the lens framwork
15:29:43 <carter> but that'd just be an accident of good design
15:29:45 <carter> rather than a goal
15:30:05 <startling> > [[0, 1], [1, 0]] ^? ix i . ix i
15:30:07 <lambdabot>   Couldn't match type `GHC.Types.Int'
15:30:07 <lambdabot>                with `Debug.SimpleReflec...
15:30:11 <startling> er
15:30:15 <startling> > [[0, 1], [1, 0]] ^? ix 1 . ix 1
15:30:18 <lambdabot>   Just 0
15:30:19 <carter> nope
15:30:19 <Ghoul_> oh god that looks like shit
15:30:32 <carter> no nested data structures
15:30:41 <Twey> Looks fine to me
15:30:51 <startling> (^?) is a little scary.
15:30:55 <carter> just flat arrays
15:31:00 <Fuuzetsu> Twey: your program compiles with head now
15:31:06 <carter> arrays of arrays makes me angryyyyy
15:31:07 <Twey> Fuuzetsu: Woot
15:31:09 <carter> bad for locality
15:31:09 <Twey> Fuuzetsu: Thanks
15:31:27 <startling> carter: sure. You can make some other type indexable by (Int, Int) or something.
15:31:30 <startling> But anyway.
15:31:31 <Ghoul_> hey who saw that thing on reddit about optimizing the game of life
15:31:36 <Ghoul_> I was really really surprised how well repa did there
15:31:37 <startling> :>
15:31:45 <startling> Ghoul_, the one with the O(2) comment?
15:31:46 <carter> Ghoul_: BUT HE SAYS WRONG THINGS TOO
15:31:54 <carter> like crazy sauce things
15:32:08 <Ghoul_> uh, he once did stuff like this
15:32:08 <copumpkin> O(e)
15:32:15 <Ghoul_> f something x where !x = 2
15:32:19 <Ghoul_> whats the point of that
15:32:33 <merijn_> Ghoul_: BangPattern, makes the pattern match strict in x
15:32:47 <carter> repa  with the local convolution filter stuff , like game of life,  is where it really shines
15:32:56 <Ghoul_> but x :: Int
15:32:58 <carter> i'd be concerned if REPA wasn't amazing for writing a game of life lib
15:33:02 <Ghoul_> so .. what's the deal there
15:33:10 <acowley> Has anyone tried switching to the layers package? How'd it work out?
15:33:11 <carter> Ghoul_: strictness
15:33:16 <carter> @hackage layers
15:33:16 <lambdabot> http://hackage.haskell.org/package/layers
15:33:25 <startling> Ghoul_, I don't think that code would make a difference. Maybe I'm wrong.
15:33:28 <Ghoul_> does ghc ever make thunks for number constants
15:33:30 <carter> acowley:huh, no clue what that is
15:33:32 <luite> although that's not a very efficient way of running game of life :p
15:33:35 <startling> Ghoul_: sure.
15:33:38 <merijn_> Ghoul_: If they're used polymorphically
15:33:45 <carter> luite: 'cause of sparsity?
15:33:46 <carter> yeah
15:33:49 <carter> repa is hosed for sparsity
15:33:50 <acowley> carter: It's an mtl+mmorph+lifted-base alternative
15:33:56 <carter> huh
15:33:57 <carter> wait
15:34:00 <carter> you need all of those otherwise?
15:34:03 <carter> or you just pick one?
15:34:17 <carter> acowley: i've never written transformer  heavy code
15:34:32 <acowley> I never used to
15:34:47 <acowley> But sometimes it's pretty awesome
15:34:55 <startling> Yeah.
15:34:56 <carter> whats the use case for you?
15:35:06 <carter> building an application it seems to shine
15:35:20 <acowley> So this very specific thing I'm doing right now
15:35:33 <acowley> I have a WriterT that accumulates timing measurements
15:35:38 <Ghoul_> layers looks great
15:35:41 <acowley> I peel those off periodically and dump them to CSV
15:35:47 <carter> oo
15:35:49 <luite> carter: also convolutions don't really scale well if you want to advance many generations per step
15:35:52 <acowley> the WriterT is on top of a whole schlep of other stuff
15:35:55 <carter> luite: fact
15:36:00 <carter> luite: it'd blow up right?
15:36:02 <acowley> but right now I want to hoist a morphism on the inner monad
15:36:13 <acowley> so mmorph is the easy answer
15:36:20 <carter> oh
15:36:22 <carter> i know nothing
15:36:22 <acowley> but I appreciate the completeness of layer's offerings
15:36:25 <carter> i should go get dinner
15:36:25 <luite> yeah your kernel gets bigger with the speed of light
15:36:33 <carter> luite: heh
15:36:35 <carter> wat
15:37:03 <joelteon> have you guys used that one package that's like a type-level monad implementation
15:37:22 <bennofs> joelteon: mmorph?
15:37:24 <startling> as opposed to the usual value-level one?
15:37:34 <carter> you mean olegs new paper thing?
15:37:42 <carter> edwardk gave some good reasons against it
15:37:43 <bennofs> http://hackage.haskell.org/package/mmorph
15:37:46 <joelteon> startling: as in, (>>=) and return are data constructors
15:37:47 <Peaker> Monad is a type-class, what is a type-level Monad?
15:37:49 <joelteon> and no, it's not mmorph
15:37:53 <carter> mmorph is tekmos
15:37:56 <luite> carter: speed of light is how fast information can propagate in the automaton
15:38:08 <startling> oh, mmorph looks cool.
15:38:09 <joelteon> more specifically, (:>>=) is a data constructor
15:38:10 <joelteon> it uses GADTs
15:38:42 <startling> joelteon, is that just monads implemented in the dumbest way possible?
15:39:07 <joelteon> startling: it's designed so you can deconstruct the datatype and actually *implement* it using whatever context you like
15:39:08 <startling> data Monad m where Return :: a -> m a; Bind :: m a -> (a -> m b) -> m b; ?
15:39:09 <joelteon> in multiple different ways
15:39:15 <startling> Yeah.
15:39:15 <joelteon> startling: something like that
15:39:17 <joelteon> i'm close to finding it
15:39:53 <elliott> joelteon: operational
15:39:57 <joelteon> operational
15:39:58 <elliott> see also free, free-operational
15:39:59 <joelteon> that's what it was
15:40:32 <startling> I always wonder if something like data Join f a where Join :: Join f (Join f a) -> Join f a; would be useful.
15:40:50 <startling> with instance Applicative f => Monad (Join f) or something
15:42:23 <startling> hmmm, is there something in between ap and (>>=)?
15:42:44 <startling> an x such that you can write (>>=) with (<*>) and x
15:42:57 <startling> I guess join is it.
15:44:20 <Peaker> mmorph is indeed cool. For me the most useful is generalizing the mapReaderT, mapStateT, etc into a lift-like operation
15:44:21 <lpaste> Helgi pasted “tonton” at http://lpaste.net/6261372451330981888
15:44:33 <startling> Peaker: oh, it does that?
15:44:43 <startling> (in a polymorphic way?)
15:44:57 <Peaker> http://hackage.haskell.org/package/mmorph-1.0.0/docs/Control-Monad-Morph.html#v:hoist
15:45:15 <Peaker> @type mapReaderT
15:45:16 <lambdabot> (m a -> n b) -> ReaderT r m a -> ReaderT r n b
15:45:26 <startling> oh. I was thinking the other thing.
15:45:50 <startling> :t withReaderT -- this one
15:45:51 <lambdabot> (r' -> r) -> ReaderT r m a -> ReaderT r' m a
15:46:09 <lpaste> Helgi revised “tonton”: “No title” at http://lpaste.net/6261372451330981888
15:47:07 <Peaker> the example of "embed" in there is silly
15:47:11 <Peaker> I wonder what embed is useful for
15:47:39 <Peaker> the notion of a monad in the category of monads is interesting, so it sounds ilke it ought to be useful somewhere :)
15:47:40 <lpaste> Helgi revised “tonton”: “No title” at http://lpaste.net/6261372451330981888
15:48:43 <startling> Why is "hoist :: Monad m => (forall a. m a -> n a) -> t m b -> t n b" rather than "hoist :: (m a -> n b) -> t m a -> t n b"?
15:49:40 <startling> oh, "lift" is "return"? neat.
15:51:35 <Peaker> startling: I think I had a case where I could implement the former but not the latter
15:51:42 * startling . o O ( Does this make MonadTrans the new Pointed ? )
15:52:03 <startling> Peaker: oh? Do you have an example offhand?
15:53:44 <Peaker> startling: I'm trying to remember what it was.. I vaguely remember that I had to have extra data routed alongside the "a" to the "n b" val, so I had to tuple it up
15:54:09 <Peaker> It wasn't for hoist, it was for a similar typed function
15:54:35 <startling> OK! I'll take your word for it.
15:54:51 <Peaker> maybe it doesn't make sense for hoist, I can't seem to remember what it was exaclty.
15:55:44 <elliott> startling: consider MaybeT
15:55:54 <elliott> startling: consider WriterT
15:56:02 <elliott> WriterT w m a = m (w, a)
15:56:10 <elliott> hoist :: (m a -> n b) -> m (w, a) -> m (w, b)
15:56:18 <elliott> -- can't do properly
15:56:20 <Peaker> elliott: does MaybeT have an issue?
15:56:27 <elliott> hoist :: (forall a. m a -> n a) -> m (w, a) -> m (w, b)
15:56:36 <elliott> -- can do: set a = (w, outer a)
15:56:46 <elliott> uh, s/w, b/w, a/
16:04:09 <stephenmac7_> I'm having an issue... http://lpaste.net/94771
16:04:39 <Hafydd> colluphid: I believe the question you'd want to ask is "Why not just use foldr1 union nonprimes instead"? Well, that wouldn't terminate, because it wouldn't be able to decide which of 3*3, 5*5, 7*7 is smallest; so your foldr1 argument, which is equivalent to \(x:xs) ys -> x : union xs ys, forces 3*3 to be chosen before considering 5*5, and 5*5 before  considering 7*7, etc, to allow the sequence to be lazily computed.
16:04:42 <stephenmac7_> Here's the code http://lpaste.net/94772
16:06:03 <Hafydd> It encodes the fact that 3*3 < 5*5 < 7*7 < ... < p_{n}^2 < p_{n+1}^2 < ... for prime numbers p_{n}, which "foldr1 union" wouldn't be aware of.
16:06:34 <lpaste> Helgi revised “tonton”: “No title” at http://lpaste.net/6261372451330981888
16:06:41 <acowley> iiuc, the extra forall provides naturality. So then you're just fmapping a morphism between functors over t.
16:07:13 <elliott> yes, it's just (m ~> n) -> t m ~> t n
16:08:08 <absence> if i let fp = unsafePerformIO $ I.mallocByteString n, will a new bytestring be created everytime i use fp?
16:09:54 <Peaker> absence: A kitty will die every time you use fp
16:10:19 <acowley> absence: The compiler is free to "run" fp as many times as it sees fit
16:10:26 <stephenmac7> It seems to be some type of mismatch between types
16:13:16 <lpaste> Helgi revised “tonton”: “No title” at http://lpaste.net/6261372451330981888
16:13:46 <lpaste> Helgi revised “tonton”: “No title” at http://lpaste.net/6261372451330981888
16:14:06 <joelteon> how do you provide -devel packages using cabal-rpm?
16:15:25 <absence> acowley: so the only "safe" thing is to use fp only once?
16:15:42 <startling> there is no safe way to use unsafePerformIO.
16:15:45 <acowley> absence: No, the point is the compiler may repeat it out of your control
16:16:10 <acowley> granted, if the identifier "fp" only appeared once in your entire code base, it may be unlikely the compiler would repeat it
16:16:26 <startling> acowley, in the definition? ;)
16:16:36 <startling> absence: why do you think you want this?
16:16:53 <acowley> startling: We must always assume the compiler is a merry prankster
16:17:09 <Ghoul_> unsafePerformIO only exists for things that are REALLY TRULY pure, but the compiler can't be sure
16:17:34 <absence> startling: bytestring is implemented using unsafePerformIO. since bytestrings don't cause random crashes, i assume there's more to the truth than that blanket statement :)
16:17:35 <Ghoul_> ie, you have some FFI interface that is honestly pure, but it has type IO, you would wrap it into purity
16:17:58 <Ghoul_> ofc people use it for gracious performance hacking
16:18:12 <Ghoul_> but that can backfire. Theres a segfault in lazy mmap package until about 3 months ago
16:18:29 <Ghoul_> came down to a hacky problem in a hacky usage of unsafePerformIO
16:18:45 <acowley> sounds hacky
16:19:07 <Ghoul_> unsafePerformIO = map hacks
16:19:19 <absence> startling: i want to pack/unpack bytestrings using non-io monadic actions without creating intermediate lists of bytes
16:19:39 <startling> absence, stream fusion doesn't work for you?
16:23:20 <absence> startling: maybe i should check that :p but how?
16:23:47 <joelteon> anybody here use cabal-rpm?
16:24:44 <startling> absence: it's something the compiler does based on hints provided by the package.
16:25:10 <startling> absence: you can look at GHC's "core" language to see if things are being fused away aiui
16:25:11 <absence> startling: there's a hint for unpack it seems, but not pack
16:25:35 <startling> absence: do you have performance problems, or are you "optimizing" abstractly?
16:27:49 <absence> startling: both :) if i can make it faster (and working..) i figure it might be worth contributing to pipes-bytestring
16:28:41 <Ghoul_> pipes-bytestring uses inplace pointer construction for BS, I already looked into optimizing it w/ k0001
16:29:13 <absence> Ghoul_: pipes-bytestring doesn't have pack or unpack
16:29:16 <Ghoul_> same with pipes-network which I thought was a culprit for copying, but Network.Socket.ByteString has magical optimizations that propagate through
16:32:48 <absence> Ghoul_: i spoke to gabriel about it, and he mentioned the "trivial" implementation is inefficient due to using intermediate lists to generate chunks
16:34:04 <lpaste> Helgi revised “tonton”: “No title” at http://lpaste.net/6261372451330981888
16:34:06 <Ghoul_> yeah actually I was thinking about something els
16:34:15 <Ghoul_> sorry & bye
16:35:10 <absence> no problem, bye
16:37:20 <lpaste> Helgi revised “tonton”: “No title” at http://lpaste.net/6261372451330981888
16:44:24 <lpaste> Helgi revised “tonton”: “No title” at http://lpaste.net/6261372451330981888
16:47:35 <lemao> what would be a good, fast, small library to parse/generate XML into/from a data type in the same way I can do with aeson/JSON?
16:48:15 <lemao> I don't need/want to parse into an XML model but straight into my own data type
16:50:06 <krakrjak> lemao: HaXml
16:52:57 <lemao> krakrjak: that seems too heavy weight for what I need no (I have never used it)? One hard requirement is that I can't generate intermediate data structures specially since my data type will be a 1-to-1 mapping to the XML document
16:53:46 <krakrjak> I don't think there is really anything light weight about xml.  If you need to parse it you need quite a bit of guarantees about correctness.
16:54:17 <krakrjak> This is why the original HaXml authors received an award for their paper on it in 1999.  XML is no JSON.
16:55:25 <krakrjak> I don't understand what "no intermediate data structures" means?  Can you not process your input before spitting the data structure at the algorithm?  Then why use XML at all?
16:56:16 <udevd> http://hastebin.com/judowifihe.rb why this code does not want to compile? it says that on the first (<-) there's parse error.
16:56:46 <Iceland_jack> udevd: There are a lot of issues
16:56:54 <Iceland_jack> no do for the then/else clauses
16:57:06 <Iceland_jack> 'getArgs >>= length' is a type error
16:57:06 <udevd> the indentation is okay.
16:57:24 <udevd> yeah, even without it does not compile
16:57:27 <Iceland_jack> 'getArgs' has type IO … but used in a pure context
16:57:54 <udevd> Iceland_jack: anyway, the problem is with if..then..else
16:57:56 <Iceland_jack> Are obviously not familiar enough with what you intend to do, I suggest starting with a smaller example and working yourself up
16:58:20 <Iceland_jack> udevd: If you want more than one IO action in the branches you need 'do'
16:58:28 <udevd> Iceland_jack: and how actually should I write condition?
16:58:30 <krakrjak> udevd: try do v <- getargs; let len = length v...
16:58:45 <udevd> krakrjak: it works but is not beautiful.
16:58:48 <udevd> xD
16:59:04 <Iceland_jack> :t if True then do print 1; print 2 else do print 1; print 2
16:59:05 <lambdabot> IO ()
16:59:14 <giogadi> howdy everyone. I'm trying to incrementally build a rose tree, where insertions happen at random places in the tree. I'm using Data.Tree.Zipper for this, and it's pretty slow
17:00:01 <krakrjak> udevd: yeah, when you have to jump into IO it can get a little awkward.  Usually though you are already doing getArgs in main so whatevs.  Also this pattern doesn't mean more code gets executed.  If you never use len then length just won't get called anyway so that's nice.
17:00:05 <Iceland_jack> There is also no need for the ($) in 'readFile $ wiringFilePath'
17:00:26 <udevd> ok, looks like it's working, excepting the condition.
17:00:35 <udevd> Iceland_jack: i know, but it's not an issue
17:00:58 <Iceland_jack> udevd: No but it's superfluous
17:01:51 <udevd> krakrjak: but how can I make condition using monadic operators?
17:02:04 <udevd> you know what i want to do here and how it can be done?
17:02:06 <Iceland_jack> udevd: Look up in the log
17:02:20 <krakrjak> lemao: there's probably a way to integrate HaXml that isn't so heavyweight.  There's just a lot the tools can do so finding the subset you need might take a little tinkering and time.
17:02:36 <Ankhers> Anyone using OSX 10.9 been able to update to cabal-install v1.18.0.2?
17:02:43 <udevd> 01:41 < Iceland_jack> Are obviously not familiar enough with what you intend to do, I suggest starting with a smaller example and working yourself up
17:02:45 <krakrjak> udevd: what kind of condition?  like when?
17:02:46 <udevd> you mean this :P?
17:03:07 <Iceland_jack> udevd: No:
17:03:07 <Iceland_jack> <krakrjak> udevd: try do v <- getargs; let len = length v...
17:03:07 <Iceland_jack>  
17:03:14 <krakrjak> @hoogle when
17:03:14 <udevd> krakrjak: condition == whats stands just after if
17:03:14 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
17:03:14 <lambdabot> System.Posix.Terminal WhenDrained :: TerminalState
17:03:14 <lambdabot> System.Posix.Terminal.ByteString WhenDrained :: TerminalState
17:03:26 <udevd> hmm
17:03:37 <Iceland_jack> you can use:
17:03:37 <Iceland_jack>     do cond ← monadicCond; if cond then … else …
17:03:40 <udevd> Iceland_jack: i used it before but it looks shitty
17:03:53 <udevd> <krakrjak> udevd: try do v <- getargs; let len = length v...
17:03:55 <Iceland_jack> shitty > not working
17:03:55 <udevd> this one
17:04:08 <Iceland_jack> If you only have case to branch on you can use when or unless
17:04:14 <udevd> yeah, i want it be either working and nice looking
17:04:24 <Iceland_jack> either and?
17:05:17 <thirsteh_> is there any kind of package with a (3D integer) vector that has a hashable instance?
17:05:26 <krakrjak> I figured he meant and/or, but I don't find those two to be mutually exclusive.
17:05:36 <thirsteh> Data.Vec has packed 3D vectors, but no hashable AFAICT
17:05:49 <udevd> english is not my native tongue, yes
17:05:50 <krakrjak> sometimes it's ugly when the types are fully in my head, but that goes away after some staring blankly in the distance.
17:08:18 <danharaj> edwardk: which repo is your circuits lib?
17:08:39 <edwardk> its not
17:08:39 <edwardk> the closest you'll get on my github is ersatz
17:09:00 <danharaj> ah
17:09:02 <edwardk> my DAE lib is sitting quietly in a private repo at present =)
17:09:06 <danharaj> I see
17:09:23 <danharaj> you see, I have a friend who has an interesting circuit modeling problem and they wanted to learn and use Haskell to solve it ;)
17:10:06 <edwardk> i've yet to go back and fix a violation of kirchhoff's laws in my code
17:10:25 <edwardk> you can probably grab hydra though and play with it
17:10:45 <travisstaton> So foldl defers computation until the fold is completed while Data.List.foldl' does not defer computation. What is the benefit of defering this computation?
17:10:45 <edwardk> https://github.com/giorgidze/Hydra/blob/master/examples/Electronics.hs
17:10:47 <krakrjak> those "laws" are mearly suggestions on the computable highway ;P~
17:10:53 <Twey> Hydra the deployment bot?
17:10:54 <udevd> okay, now it fails on >      else putStrLn "Usage: ./reconstruction (wiring decription file) (detectors description file) (parsed hits file)"
17:10:58 <edwardk> its a fair bit uglier than mine, but it works
17:11:09 <udevd> stating >    Couldn't match expected type `[()]' with actual type `()'
17:11:32 <danharaj> yeesh 2 years old
17:11:37 <danharaj> I wonder if it builds with latest ghc
17:11:38 <edwardk> travisstaton: there are a few highly artificial examples that bottom out with foldl' that don't bottom with foldl
17:11:57 <krakrjak> udevd: looks like you wrapped up a computation into a list....
17:12:11 <edwardk> travisstaton: in general if you reach for a left fold you probably want foldl'
17:12:20 <danharaj> edwardk: Is this the go-to paper on FHM? http://www.cs.nott.ac.uk/~nhn/Publications/padl2003.pdf
17:12:39 <edwardk> danharaj: yeah
17:12:50 <edwardk> i started with that and the modelica manual
17:12:55 <travisstaton> edwardk: Hey! thanks for answering
17:12:58 <udevd> krakrjak: http://hastebin.com/befusiqati.rb whole code
17:13:10 <edwardk> and then read a ton of stuff about (stochastic) DAE solving
17:13:56 <danharaj> hardcore
17:14:14 <edwardk> danharaj: you may also get some mileage out of https://github.com/glutamate 's repos and papers on the topic
17:14:27 <danharaj> oh delightful
17:14:43 <danharaj> I may also hassle Hudak at the NY meetup next wednesday
17:14:57 <udevd> i can't see anything in this code... ;_;
17:15:17 <edwardk> http://www2.le.ac.uk/departments/biology/research/neuroscience/matheson-neurobiology/images/publications/Nielsen_et_al_TFP_2009.pdf
17:15:33 <edwardk> and http://www2.le.ac.uk/departments/biology/research/neuroscience/matheson-neurobiology/images/publications/Nielsen-et-al-RSIF-2011.pdf
17:15:56 <edwardk> the latter especially
17:16:38 <Mokosha> Hi, I'm trying to create a package that has a library and an example, but I only want to build the example if I specify it during configuration? is there a way to do this with cabal?
17:16:39 <danharaj> glorious
17:16:59 <danharaj> It used to be that I was flustered by waves of papers, but now that I have Papers to organize them for reading, I just keep stacking them up.
17:16:59 <edwardk> danharaj: we'll make a neuroscientist out of you yet
17:17:03 <danharaj> haha
17:17:03 <bennofs> noam_: flags
17:17:14 <bennofs> Mokosha: cabal flags
17:17:22 * hackagebot unm-hip 0.3.1.6 - A Library for the manipulation of images  http://hackage.haskell.org/package/unm-hip-0.3.1.6 (JosephCollard)
17:17:22 <danharaj> Well my friend is a grad student at MIT and lives in Cambridge so we may have a discussion of FHM and DAE's and whatnot over beer yet.
17:17:23 <NougatRillettes> Hi guys, I've recently discovered species and can't figure out how to express types within species theory, any idea ?
17:17:24 <krakrjak> udevd: the body of your then statement doesn't seem to have a computation....
17:17:30 <Mokosha> bennofs: Cabal says I can't specify them at the base level
17:17:42 <NougatRillettes> My more general goal is to prove McBRide's results on One Hole COntext using SPecies
17:17:54 <edwardk> danharaj: well, if you're going to hav the discussion over beer in cambridge, let me know and i'll come down and flood you with more papers ;)
17:18:09 <danharaj> That sounds painful :P
17:18:17 <danharaj> also you would be able to do it since you're like 2 feet taller than me.
17:18:25 <danharaj> Raining papers from up above.
17:18:51 <krakrjak> udevd: I'm a little lost with your code give me a minute to play with it and see if I can give you a better pointer.
17:18:57 <udevd> krakrjak: well, actually it does compile. and what do you mean? there's a sequence of [putStrLn elements]
17:19:04 <udevd> okay :3 thanks
17:19:08 <udevd> i mean
17:19:11 <udevd> oh, sorry
17:19:18 <udevd> the part inside then does parse
17:19:38 <udevd> what does not is the inside else
17:19:44 <krakrjak> udevd: the in at the end of the then is giving me fits...  It's an idiomatic thing not a real problem.
17:19:49 <edwardk> is this like the academic version of "making it rain"?
17:19:57 <danharaj> haha
17:20:23 <danharaj> I am intrigued by the idea of non-causal specification languages for reactive systems.
17:20:30 <edwardk> likewise
17:20:42 <edwardk> its still in the back of my brain chewing a hole out
17:20:59 <danharaj> Since I've found that threading causal dependencies through components is the great pain and stumbling block of modularity in every attempt at a reactive system language I've come up with.
17:21:00 <krakrjak> udevd: so the else body has type IO (), the body of the then has a type of [IO ()]
17:21:18 <udevd> hm, i see.
17:21:29 <startling> udevd, have you seen mapM_ ?
17:21:45 <krakrjak> startling: thanks!  I was just about to reach for the wrong version of mapM_
17:21:46 <udevd> > else do {putStrLn "Usage: ./reconstruction (wiring decription file) (detectors description file) (parsed hits file)";}
17:21:47 <lambdabot>   <hint>:1:1: parse error on input `else'
17:21:51 <udevd> does not works as well
17:22:15 <udevd> (and it's not very nice hack, even if it'd work)
17:22:22 <krakrjak> > :t mapM_
17:22:23 <lambdabot>   <hint>:1:1: parse error on input `:'
17:22:33 <udevd> startling: yup, what about it
17:22:46 <krakrjak> booo ..  my lambdabot foo is weak today
17:23:15 <jfischoff> @type mapM_
17:23:16 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
17:24:01 <udevd> krakrjak: erm, wait
17:24:07 <udevd> the >sequence
17:24:20 <udevd> ( in sequence.take 10.map (\x -> p [......] )
17:24:32 <krakrjak> udevd: so like mapM_ putStrLn $ computation producing list of strings
17:24:41 <udevd> makes the then body an IO ()
17:24:47 <udevd> and not [IO ()]
17:25:37 <udevd> yes, it is what my then body is doing right now. but the problem is that else body does not compile.
17:25:41 <krakrjak> so that makes it match the else.
17:27:33 <krakrjak> udevd: I guess I'm lost.  What's the actual type of the function, it's missing in your paste.
17:27:52 <udevd> it is just main function.
17:28:04 <ta479> when they say a monad is a monoid in the category of endofunctors, they mean endofunctors are the objects and monoids define the morphisms?
17:28:05 <krakrjak> ok... hrm...
17:28:10 <krakrjak> take returns a list....
17:29:30 <acowley> danharaj: But do you really want the causality to be entirely implicit?
17:29:56 <danharaj> acowley: I don't know. I just don't know how to think about causality in a modular way.
17:30:04 <udevd> krakrjak: sequence `flattens' it.
17:30:10 <danharaj> btw you should come up to ny more :P
17:30:30 <udevd> sequence m:ms = m>>sequence ms
17:31:06 <krakrjak> @type sequence
17:31:07 <lambdabot> Monad m => [m a] -> m [a]
17:31:28 <krakrjak> that doesn't look like a flattening to me...  you still get a list back in the monad.
17:31:48 <startling> :t sequence_
17:31:49 <lambdabot> Monad m => [m a] -> m ()
17:32:07 <acowley> danharaj: I'd like to!
17:32:07 <krakrjak> now that looks more like what you may want.
17:32:22 <startling> > sequence [[1, 2, 3], [4, 5, 6]]
17:32:24 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
17:32:35 <startling> > sequence_ [[1, 2, 3], [4, 5, 6]]
17:32:37 <lambdabot>   [(),(),(),(),(),(),(),(),()]
17:32:37 <acowley> danharaj: I agree the modularity is a pain, but I keep finding that I want to be explicit about layers of causality.
17:32:42 <udevd> oh, it workds.
17:32:50 <udevd> works*
17:33:01 <udevd> thanks :3
17:33:03 * krakrjak high fives startling
17:34:12 <krakrjak> on that note...  dinner!
17:35:49 <danharaj> acowley: in particular I've had problems reasoning about cascading state transitions, where I hook up one component to another such that a transition in the first causes transitions elsewhere. It's very easy to get stuck in loops.
17:36:01 <danharaj> and it is very cumbersome to write down
17:36:10 <acowley> danharaj: Yes, the writing down tends to get me, too
17:36:19 <acowley> danharaj: I take small solace in types helping
17:37:03 <danharaj> I think the operational semantics are probably already there. What's missing, imo, is the proper syntax.
17:42:23 * hackagebot data-lens 2.10.4 - Haskell 98 Lenses  http://hackage.haskell.org/package/data-lens-2.10.4 (RussellOConnor)
17:43:31 <acowley> danharaj: Are you working on anything to do with this at the moment?
17:49:28 <loadedanvils> is there any way to map the createDirectory command
17:49:56 <loadedanvils> e.g. map createDirectory ["aaa","bbb","etc"]
17:51:18 <tippenein> :t System.Directory.createDictionary
17:51:20 <lambdabot>     Not in scope: `System.Directory.createDictionary'
17:51:28 <tippenein> createDirectory :: FilePath -> IO ()
17:51:31 <peddie> loadedanvils: I'd guess mapM_
17:51:51 <tippenein> if the list contained FilePaths, I think it'd work
17:51:56 <loadedanvils> I think it works
17:52:04 <loadedanvils> I try the file paths individually and it works
17:52:08 <loadedanvils> but not in a list
17:52:16 <tippenein> mapM_ like peddie said
17:52:23 <peddie> :t mapM_
17:52:24 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
17:52:25 <loadedanvils> okeydoke
17:53:07 <tippenein> yup, mapM_ createDirectory ["aaa", "bbb"]
17:53:35 <loadedanvils> what's a Monad?
17:53:46 <peddie> :i Monad
17:53:51 <peddie> aww
17:53:57 <peddie> it's a type class
17:54:04 <loadedanvils> sorry, I should have checked first
17:54:30 <loadedanvils> thanks everyone
17:54:35 <loadedanvils> I'm going to get some food now
17:54:46 <loadedanvils> bye
17:55:36 <danharaj> acowley: not atm but frp is something several of us at the office have taken a shot at
17:55:38 <danharaj> it's a common topic
17:57:40 <ta479> I heard frp has time leaks or something
17:58:58 <udevd> it's funny how checking if k is member of IntMap keys is O(min(n,W)) and notMember function is log(n)
17:59:01 <udevd> xD
17:59:43 <danharaj> Which would you it rather be.
17:59:54 <acowley> the smaller one!
18:00:05 <danharaj> :X
18:00:15 <udevd> the constant one -- member is constant for large enough n
18:00:26 <danharaj> indeed
18:00:33 <udevd> but perhaps each function has its advantages
18:00:34 <danharaj> although so is notMember for large enough n
18:00:46 <udevd> log(n) /= constant
18:00:54 <danharaj> it is when n is bounded from above
18:01:43 <udevd> ...but it isnt? i mean, it is by machine integer
18:01:46 <udevd> but nothing more
18:01:51 <danharaj> that is pretty bounded
18:02:12 <udevd> :D
18:03:59 <acowley> The OpenGL Profiler unsurprisingly does not work particularly well when you have a multithreaded executable sharing objects between OpenGL and OpenCL
18:04:29 <acowley> (it segfaults)
18:04:34 <acowley> (iit's not awesome)
18:04:42 <danharaj> delightful
18:04:58 <danharaj> I didn't even know opengl and cl could share objects?
18:05:11 <danharaj> That sounds a bit too competent for the typical driver.
18:05:24 <acowley> Well, it is kind of funny because you inject a breakpoint in the GL layer, and then an OpenCL thread comes along and locks a GL object. At that point, everyone just calls it a day and opens a cold one.
18:05:36 <acowley> danharaj: I demonstrated just that in my NYHUG talk! :P
18:05:55 <danharaj> I didn't realize you weren't explicitly marshaling the data between the two in cpu land!
18:06:04 <acowley> No. I live in the future now.
18:06:27 <danharaj> The future where we still don't have raw access to our graphics memory on PCs?
18:06:34 <acowley> I've made it much more complicated now though because I have multhreaded machines using OpenCL with a concurrent OpenGL thread providing the visuals
18:07:00 <acowley> Sometimes you can trigger bugs doing this that makes you think you might have too much access to raw memory :(
18:07:11 <acowley> Like desktop image corruption
18:07:24 <danharaj> nice
18:07:25 <acowley> Such things shatter all my illusions
18:10:12 <acowley> I am now attempting to run R concurrently with all that. I look forward to unimaginable horror.
18:10:43 <danharaj> you're a sick man
18:10:50 <danharaj> does Ani know?
18:17:25 * hackagebot cryptocipher 0.6.2 - Symmetrical block and stream ciphers.  http://hackage.haskell.org/package/cryptocipher-0.6.2 (VincentHanquez)
18:34:49 <udevd> how can i force some value to be evaluated? I tried using bang pattern, but it doesn't seem to work... (or my code is so fast, which is rather not true)
18:34:52 <udevd> look: http://hastebin.com/lapamolite.rb
18:34:57 <udevd> i want >must
18:35:03 <udevd> to be evaluated
18:35:29 <Rarrikins> udevd: Do you mean to WHNF or fully evaluated?
18:35:41 <udevd> fully evalueated, whatever WHNF means.
18:35:51 <Rarrikins> udevd: Check out deepseq.
18:36:07 <Rarrikins> udevd: It'll evaluate the whole thing.
18:36:28 <udevd> i'll try... but sounds like hacky implementation as IO monad, isn't it?
18:36:35 <Rarrikins> Nope.
18:36:39 <udevd> okay
18:36:40 <Rarrikins> It just uses seq on everything.
18:38:19 <udevd> hmm no, I'll use just some hack...
18:38:38 <Rarrikins> OK.
18:38:51 <udevd> like foldl1 id 1 must
18:39:34 <udevd> id.const*
18:41:30 <udevd> wow
18:42:32 <udevd> using this hack (the program has very little output) it speeded 20x from original value.
18:42:53 <Rarrikins> Oh, that's cool.
18:47:46 <joelteon> how should I transform my development environment into a bunch of RPMs?
18:47:58 <joelteon> because integration tests are killed on travis after 50 minutes
18:48:04 <joelteon> maybe I should ask #ghc
18:50:16 <Kron> hey guys, if I want to practice networking in haskell how do I do that?
18:50:50 <Kron> I want to make a tiny chess game through a network in haskell because reasons
18:54:59 <dmj`> Kron: What have you tried
18:55:03 <AlainODea> joelteon: dysinger has done some interesting things with Docker to get flyweight pre-provisioned Haskell dev environments. https://github.com/dysinger/docker-images
18:55:09 <Kron> nothing at all at the moment
18:55:17 <Kron> I'm not sure where's the best place to even start
18:55:35 <Rarrikins> Kron: Are you new to Haskell?
18:55:38 <stolaruk> (Lens question) What is meant by "w/ result" when it is said that <+~ is the "w/ result" version of +~ ?
18:55:59 <Kron> I'm kinda new, yeah
18:56:34 <Rarrikins> stolaruk: It probably doesn't just modify something but gives you the result so that you can do something with it, but I haven't used Lenses, so I'm not sure.
18:57:02 <joelteon> oh hey, cloud haskell
18:57:14 <stolaruk> Rarrikins: Yeah that makes sense, thanks.
18:57:36 <Rarrikins> Kron: Real World Haskell has a networking chapter: http://book.realworldhaskell.org/read/sockets-and-syslog.html
18:57:43 <Rarrikins> stolaruk: No problem.
18:58:09 <stolaruk> Rarrikins: You might want to look into Control.Lens, this stuff is really cool.
18:58:21 <Rarrikins> stolaruk: I plan to when I have some free time :)
18:58:34 <stolaruk> Awesome.
18:59:03 <Kron> thanks Rarrikins
18:59:11 <Rarrikins> Kron: No problem.
18:59:19 <Kron> is this up to date? someone told me real world haskell is sort of out of date
18:59:41 <Rarrikins> Yeah, for the basics, it should be up to date.
19:00:15 <Rarrikins> There are more advanced new libraries, but it's better to wait for when you're more familiar with Haskell in general.
19:01:28 <Kron> alright
19:03:29 <dmj`> new != better
19:03:45 <dmj`> Kron, have you done socket programming in other languages?
19:03:56 <Kron> ... issssssh. Terribly.
19:04:06 <Kron> I'm not very good at it and i've forgotten almost everything
19:04:06 <dmj`> Why terribly
19:04:21 <Kron> It involved me squinting at a lot of example code on the net and copying it and hacking it together until it worked
19:04:24 <Kron> mind you, this was C
19:04:33 <Kron> everything was a storm of pointers and opaque system calls
19:04:39 <Kron> I had no idea what was going on but it sorta worked
19:04:42 <Kron> which is terrible
19:08:36 <dmj`> Kron: I recommend Beej's networking guide.
19:08:43 <dmj`> Kron: http://www.beej.us/guide/bgnet/
19:09:24 <Kron> oh god it's huge
19:09:26 <Kron> also in C
19:09:48 <Hodapp> hey, could be worse, could be C++
19:10:23 <dmj`> Sockets in haskell are a type-safe abstraction over C-sockets.
19:10:36 <djahandarie> I've generally been very unhappy with low-level network programming in Haskell.
19:10:42 <dmj`> "The Network.Socket module is for when you want full control over sockets. Essentially the entire C socket API is exposed through this module"
19:10:59 <Rarrikins> Kron: Yeah, networking has tons of details.
19:11:28 <Kron> ;_;
19:11:32 <Rarrikins> Kron: Luckily, most are handled by the library you use.
19:11:39 <Kron> is there any library or tool or system that sort of abstracts this away
19:11:49 <Kron> because mallocing and freeing and all that was something I wanted to avoid when I came to Haskell
19:11:53 <Kron> hmmm
19:11:54 <Kron> okay
19:11:54 <Rarrikins> Kron: Yeah, any networking library should handle a great proportion of them.
19:12:52 <dmj`> Kron: Network is a higher level implementation, protocols are important to learn though.
19:13:04 <Kron> I understand TCP and UDP on a theoretic level
19:13:36 <Kron> spamming packets to the wind or waiting for reception confirmation responses
19:14:11 <prophile> actually spamming packets is one of the things TCP is built to avoid
19:14:14 <prophile> hence the flow control stuff
19:14:20 <Kron> I mean the opposite
19:14:27 <Kron> UDP is packet spam and TCP is the reserved version
19:14:51 <prophile> ah yes, I misinterpreted what you said
19:14:51 <lemao> krakrjak: back to the xml question... I basically don't need all the guarantees and it is not my choice to use xml, but the system I am interfacing with uses XML
19:14:55 <dmj`> Kron: How is a connection established in TCP
19:14:58 <prophile> apologies
19:15:55 <dmj`> Kron: How is TCP the 'reversed version' of UDP
19:15:58 <Rarrikins> UDP is also used for not repeating messages but for when lost messages are acceptable, like in conference calls.
19:16:01 <Kron> reserved
19:16:03 <Kron> not reversed
19:16:10 <Kron> 'reserved' as in more conservative and careful
19:16:11 <dmj`> Oh :)
19:16:13 <dmj`> my bad
19:16:20 <Hodapp> I had a good joke about UDP, but everyone missed it.
19:16:29 <Kron> UDP is just... "This is an FPS and I can't be arsed to wait for you to confirm you got my package" : the protocol
19:16:29 <Rarrikins> TCP will just sit there and try to get outdated data down the line.
19:16:35 <dmj`> Hodapp: lol
19:16:58 <raisdead> How would I use quick check to validate something like pla from http://hackage.haskell.org/package/perceptron using a propert like ''Every training example is correctly identified.''
19:18:17 <dmj`> Kron: have you ever used telnet?
19:18:24 <Kron> yes!
19:18:26 <Kron> like a million years ago
19:18:31 <Kron> then I forgot about how to use it
19:21:12 <dmj`> Kron: http://lpaste.net/94776
19:21:16 <dmj`> Kron: check out that code
19:21:38 <dmj`> Kron: a *very* simple web server in haskell, written by dons
19:21:42 <Kron> o_o
19:21:46 <Kron> hmmmmm
19:22:04 <dmj`> you should run httperf, haskell web servers scream
19:22:40 <Kron> how would you create a UDP server / client thing?
19:23:40 <prophile> there's much less of a difference with UDP
19:24:03 <Kron> oh?
19:24:28 <prophile> well, there's no notion of a connection
19:24:43 <dmj`> Kron: Do you remember the addrinfo struct
19:24:50 <Kron> no!
19:24:54 * Kron is useless
19:25:16 <dmj`> @typ socket
19:25:17 <lambdabot> Not in scope: `socket'
19:25:23 <peddie> raisdead: QuickCheck is more for testing algebraic properties; checking that every training example is correctly identified seems like a pretty unwieldy thing to try to do with it
19:25:23 <dmj`> socket :: Family -> SocketType -> ProtocolNumber -> IO Socket
19:25:33 <dmj`> @info SocketType
19:25:33 <lambdabot> SocketType
19:25:50 <Kron> informative!
19:25:57 <udevd> xD
19:26:13 * Kron pets lambdabot 
19:26:25 <dmj`> data SocketType = NoSocketType ... | Datagram
19:26:33 <dmj`> you specify Datagram, to get UDP
19:26:35 <peddie> raisdead: for example, it's hard to think how you might get quickcheck to reduce a failing MLP classifier to a minimal test case
19:27:15 <dmj`> You should read Beej's networking guide, and do it all in C
19:27:23 <dmj`> Kron: ^
19:27:24 <Kron> ;_;
19:27:29 <Kron> ;___;
19:27:34 <Kron> that is my C programming face
19:27:38 <dmj`> C is fundamental
19:27:44 <Kron> my face is fundamental
19:27:52 <Kron> the fundament of anguish D:
19:28:30 <dmj`> Why do you think Haskell will be any less difficult than C
19:28:35 <peddie> dmj`: it seems pretty reasonable to want to use UDP sockets from the comfort of Haskell; why would it be better to resort to C?
19:28:51 <Kron> I think it will be less low level than C and i'd rather deal with complex function composition and monads than deal with double pointers
19:30:43 <dmj`> peddie: I recommed Kron go through beej's guide first, to get a handle on sockets. The knowledge is transferrable to any other language, including Haskell
19:31:18 <darkf> Kron: double pointers are not difficult, they are just pointers to pointer, like Ptr (Ptr x). low level network programming is not fun (unless you are a masochist), and you can and should use a library to handle it for you
19:31:50 <peddie> dmj`: oh, I see what you meant, sorry
19:32:24 <dmj`> peddie: no apologies necessary. Secondly, he wants to use UDP. Haskells Network module contains higher level functions for dealing with TCP, not UDP. He'll have to use Network.Socket, which is a type-safe layer over C-sockets anywayas.
19:32:47 <Kron> ah
19:32:57 <peddie> dmj`: I'd be pretty excited about type safety if I were about to write a bunch of network code :)
19:33:04 <triliyn> It's funny that C sockets are not considered type safe
19:33:38 <peddie> Kron: you could check out http://hackage.haskell.org/package/network-2.4.2.0/docs/Network-Socket-ByteString.html
19:33:42 <triliyn> I guess C's type system just doesn't do a lot of the things that haskell's does
19:33:51 <dmj`> exactly, but reading hackage docs of the network pkg won't teach you sockets programming. Beej's guide will
19:33:53 <triliyn> It doesn't encode expectation of failure or anything
19:34:02 <startling> triliyn: it totally can though
19:34:07 <Kron> hmmm, thanks peddie...
19:34:12 <peddie> Kron: though as dmj` alluded to, the examples are for TCP
19:34:17 <Kron> ah
19:34:20 <Kron> :(
19:34:23 <Kron> will it work for UDP?
19:34:29 <startling> typedef struct { bool isJust; void *fromJust; } Maybe;
19:34:30 <dmj`> I don't know many games for chess than run over UDP :)
19:34:57 <Rarrikins> If you need to retransmit the data to get it all across, use TCP.
19:35:00 <startling> Speed chess.
19:35:02 <peddie> Kron: sendTo, sendAllTo, recvFrom :)
19:35:09 <darkf> startling: you're missing the value
19:35:13 <triliyn> startling: but then it no longer encodes the result type, does it?
19:35:24 <startling> triliyn: correct.
19:35:26 <Kron> what startling said, except slightly crazier
19:35:44 <startling> Kron: do you know that UDP is liable to drop packets?
19:35:46 <Kron> yes
19:35:51 <startling> OK.
19:35:52 <triliyn> I wonder if there's a way to work around the lack of parameterized types...
19:35:53 <dmj`> Kron: are you familiar with the state monad?
19:35:55 <Kron> but I think TCP is slightly laggy
19:36:00 <Kron> and I'd rather deal with packet loss than lag
19:36:05 <startling> haha
19:36:20 <raisdead> peddie: Thanks for that advice. If someone was crazy enough to test it, would they create a data type that represents the input and make it an instance of Arbirary. In the test the datatype would be decomstructed and fed into the learning algorithm? Is there anyother methods?
19:36:21 <startling> Kron, I don't think you understand what kind of timescales we're talking about.
19:36:22 <Kron> nooo. or wait
19:36:24 <Kron> do you mean ST?
19:36:27 <Kron> or just State like from LYAH?
19:36:30 <Kron> I know State from LYAH
19:36:33 <peddie> Kron: did you try TCP and see if it's fast enough?  it's certainly easier to use . . .
19:36:43 <Kron> hmmm, how fast is it?
19:36:50 <dmj`> Kron: what is the definition of (>>=) for State
19:36:50 <startling> triliyn: you could have a macro that makes Maybe x for some x.
19:37:13 <Kron> I think
19:37:15 <peddie> Kron: probably fast enough :)
19:37:18 <triliyn> startling: hmmm, yeah, that should work... at least for most cases
19:37:21 <Twey> Kron: Packet loss is lag
19:37:24 <Twey> Generally
19:37:24 <Kron> you take a combination of a state and a function call
19:37:29 <triliyn> Maybe for all, but I can't prove that in my head
19:37:29 <Kron> and then you cal lthe function on arguments and the state
19:37:32 <Kron> and return a new state?
19:37:36 <Kron> with a new... something
19:37:39 <startling> triliyn: yeah. You can't really have free type variables in C, though.
19:37:40 <Kron> I forget
19:37:55 <Kron> hmmm
19:38:00 <Kron> okay, altered idea:
19:38:12 <Kron> how easy is it to convert a small program from using TCP to using UDP?
19:38:21 <Kron> I mean if it's all carefully encapsulated then I guess I can just try each version
19:38:27 <dmj`> writing Chess in Haskell will be hard w/o an understanding of the State monad
19:38:44 <Twey> Kron: For both UDP and TCP, you transmit packets that may or may not arrive.  The difference is that if a TCP packet is dropped, the receiver knows and can request retransmission.  UDP provides no way of telling whether you've missed a packet (by default, but you can build such a protocol on top of it).  UDP is used when your program continues working even if you don't get all the packets.
19:38:58 <Kron> I'm pretty sure that barring the IO monad, almost every other simple monad can be replicated by just using more code
19:39:00 <peddie> raisdead: typically with QuickCheck, you make an Arbitrary instance for the structure whose properties you're trying to test
19:39:12 <Twey> Yeah
19:39:27 <geekosaur> STM
19:39:27 <peddie> raisdead: this way, QuickCheck can test your properties against any valid structure
19:39:35 <Twey> And ST is magic too, I think
19:39:42 <Kron> I guess I'll start with TCP if it's reasonably quick
19:39:42 <dmj`> IO is ST
19:39:44 <Twey> But you don't need State, for sure
19:39:58 <triliyn> What exactly is ST? I've heard a lot about it but never actually looked at it
19:40:02 <Kron> do any realtime games use TCP though?
19:40:18 <Twey> Kron: Obviously requesting the packet again and waiting for a resend is potentially slower than shrugging and carrying on
19:40:39 <Twey> (since you can't do whatever action the packet represents until it arrives)
19:40:41 <dmj`> triliyn: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.144.2237
19:40:55 <Twey> Kron: I imagine so, for some value of ‘realtime’
19:40:57 <peddie> raisdead: the problem with e.g. an MLP is that the "structure" (a bunch of matrices) is not the exciting part; the test you proposed relies on the weights between layers being well trained to pass the test
19:41:13 <dmj`> Twey: what do you mean you don't need state
19:41:30 <Twey> FPS games &c. usually transmit game states and absolute locations, so it doesn't really matter if you drop a packet or two (the player just sees a discontinuity)
19:41:44 <peddie> raisdead: I guess you could use QuickCheck to test whether your training algorithm converges, by generating Arbitrary trained MLPs on data that you've somehow conditioned in a way where you can know what it should converge to
19:41:52 <peddie> raisdead: but that still sounds super awkward to me :)
19:41:52 <triliyn> hmj`: hmm, interesting
19:41:58 <Twey> dmj`: It's perfectly possible to program a game of chess without using the State monad
19:42:22 <Kron> dmj`: I don't see the need to use the state monad
19:42:27 <startling> Twey: eh.
19:42:40 <startling> it's certainly nicer than foldr
19:42:40 <Kron> the state monad is ultimately just an expressability tool isn't it?
19:43:09 <jle`> you don't need monads to do anything
19:43:11 <Twey> Kron: Yes.  It's sugar over just passing around an extra parameter between functions (and returning it in a pair).
19:43:12 <jle`> :)
19:43:13 <dmj`> Twey: Impurely sure
19:43:19 <Twey> dmj`: No
19:43:21 <startling> dmj`, foldr.
19:43:31 <Twey> folds, or just plain old recursion
19:43:40 <dwcook> State a doesn't give you anything you couldn't do just by gluing together functions :: s -> (s, a). It's just super convenient in many cases.
19:43:52 <raisdead> peddie: Thanks for your advice. I'll see what I can hack together. If I fail, I will remember you warned me.
19:43:54 <startling> recursion is ultimately just an expressability tool isnt it?
19:43:55 <Twey> The only benefit with State is nicer syntax if you end up doing that a lot
19:44:03 <Kron> hmmmm how does one use the state monad to write a foldr?
19:44:06 <Twey> startling: Heh
19:44:16 <dwcook> startling, are you referring to explicit recursion or recursion as a whole? :)
19:44:22 <peddie> raisdead: ok :) good luck, and let me know if you get something cool working -- maybe I just don't grok quickcheck well enough to understand your plan!
19:44:26 <startling> Twey: I write my chess games as a single unrolled loop.
19:44:36 <dmj`> startling, Twey: Sounds painful
19:44:41 <jle`> i write mine as a lazy list
19:45:46 <Kron> I would do the lazy list thing too
19:45:59 <Kron> mostly cause I find lazy lists sexy
19:46:01 <dmj`> Chess is not trivial to make
19:46:09 <Twey> dmj`: It's not that bad.  I often don't bother with a state monad when I'm only passing things once.
19:46:38 <dmj`> Twey: Have you written a game of chess in Haskell?
19:46:41 <Twey> (as you would for chess: there's only one state change per turn)
19:46:47 <Twey> dmj`: Nope
19:47:04 <Ghoul_> is atan in radians?
19:47:08 <Twey> Ghoul_: Yes
19:47:17 <Ghoul_> damnit
19:47:25 <jle`> is there another system for measuring angles
19:47:27 * Polarina loves radians.
19:47:27 <Kron> to be fair, I doubt many people have written a game of chess in anything
19:47:34 <Twey> It would be a bit daft to pick a unit at random :þ
19:47:40 <Kron> jle`: degrees, gradians
19:47:48 <dmj`> Twey: Ok I see, sure you could do it in one big game loop, inside the IO monad
19:47:56 <Ghoul_> how do I convert from radians to degrees
19:48:05 <jle`> 2 pi radians = 360 degrees
19:48:12 <Ghoul_> nothing built in?
19:48:19 <dmj`> 1 radian = 57.2957795 degrees
19:48:26 <Twey> Ghoul_: ((360 / τ) *)
19:48:38 <Twey> Is built-in enough, I think :þ
19:48:43 <Ghoul_> surely there is a function in a language like haskell
19:48:43 <startling> (* 360) . (/ pi)
19:48:45 <jle`> mathematica implements degree as a literal degree symbol, which is an alias for (2 pi / 360)
19:48:51 <Twey> startling: 180 for π
19:49:01 <peddie> dmj`: check out this stackoverflow post about chess; I think there's a nice answer about writing it in a Haskelly way: http://stackoverflow.com/a/7310373
19:49:08 <jle`> so saying 90 (degrees) is the same as 90 * (degrees) = 90 * (2 pi/360)
19:49:42 <jle`> (useless trivia hour)
19:49:52 <geekosaur> Ghoul_, I think most Haskellers are actually doing m,ath, and radians are more natural
19:49:59 <startling> you could do a postifx operator.
19:50:27 <Ghoul_> bleh, in robotics degrees are pretty standard
19:50:33 <Twey> dmj`: You wouldn't do it in the IO monad (except in the trivial sense in which everything is in the IO monad).  You would have a function like Move → ChessBoard → ChessBoard; read the Move from the player in IO, then perform the corresponding transformation on the board and spit it out again.
19:50:45 <jle`> you probably use degrees for human interface but i don't think anybody actually uses degrees to compute things
19:50:49 <startling> Twey: you made the mistake before I did. :)
19:50:55 <jle`> i could be speaking from naivete
19:51:06 <Kron> oooh this is pretty peddie
19:51:26 <Twey> Ghoul_: A lot of mathematical functions get a lot uglier if you do it in degrees, because you have to carry a factor of (360 / τ) around
19:51:43 <Twey> startling: Didn't :þ
19:51:53 <startling> Twey, ((360 / τ) *)
19:51:54 <peddie> Kron: interleaving that sort of computation with network I/O is certainly trickier . . .
19:52:03 <Twey> startling: τ, not π
19:52:18 <Twey> 360 / τ = 180 / π
19:52:20 * startling 's greek font is too small
19:52:25 <Twey> Heh
19:52:46 <dmj`> Twey: I think something like type Chess = StateT GameState IO () would be nice
19:53:48 <jle`> oh i mixed up my degree/radians conversions.  don't mind me
19:54:05 <Twey> dmj`: I don't think it would be worthwhile.  You jump out of IO as soon as possible anyway; there's only one state-change in IO.
19:55:14 <Twey> You need that outer IO read/print loop, but that's all you want IO for.  The ‘state’ change is just applying the function generated by the move to the current chessboard once per loop (so one call, textually).
19:55:29 <peddie> Kron, dmj`: here are two more posts you might find useful: http://sequence.complete.org/blog/259
19:56:26 <Twey> Complications might arise later if you start adding features, at which point it might become worthwhile to refactor into StateT IO, but the basic game shouldn't require it, I think
19:57:08 <dmj`> From a software eng. perspective, the difference is readability. A state would give you a nicer DSL
19:57:24 <startling> yeah.
19:58:08 <Twey> Yeah, but it's a DSL you'd use for one, maybe two lines ever in your program… hardly worth building a DSL for
19:58:22 <Twey> (as opposed to a one-, maybe two-line recursive call)
20:00:39 <dmj`> Personally, I would make a gamestate for the board, etc. and a grammar for commands to manipulate the board. stdin would get parsed into a ChessCommand, then eval'd in a loop (gamestate updated) and printed to stdout.
20:01:06 <dmj`> Twey: I think you're over simplifying chess
20:01:22 <dmj`> Or maybe I'm over complicating it
20:01:24 <Twey> Hm, though that move function might look nicer in the (pure) State monad: you could write it imperatively like ‘take the piece at the destination, then move the selected piece to the destination, then test whether has occurred…’
20:01:58 <Twey> The chess itself might benefit from the State monad, depending on how it's written… but the REPL doesn't, I think
20:02:23 <Twey> s/whether/whether check/
20:02:33 <dmj`> Do blocks simulate imperative style commands. The REPL is for reading in the next move and printing the newly updated board state.
20:02:33 <startling> REPL?
20:02:51 <Twey> startling: Read/Eval/Print Loop
20:02:53 <startling> StateT works well with e.g. haskeline, if that's what you mean.
20:02:59 <startling> Yeah, OK. I thought it might be something else.
20:03:34 <Twey> startling: What does Haskeline use StateT for?  Adding history items?
20:04:05 <Kron> hmmm
20:04:28 <Kron> first things first: I'm gonna need to figure out basic TCP and basic SDL and then build stuff on top of that
20:04:34 <Kron> the rest is relatively easy in comparison
20:04:38 <Kron> at least, conceptually
20:04:44 <Twey> The downside to the imperative-style move function is that you have to design your type to allow invalid in-between states (or have one type per state)
20:04:59 <startling> Twey: no. It has its own transformer thing, so it's pretty easy to turn StateT code into haskeline code.
20:05:11 <startling> It's kind of poorly-implemented, but ...
20:05:13 <Twey> Oh, right
20:07:07 <udevd> > (sequence$ [Just 9,Just 2])>>=(Just (++[0]))
20:07:08 <lambdabot>   Couldn't match expected type `[a0] -> Data.Maybe.Maybe b0'
20:07:09 <lambdabot>              wit...
20:07:16 <udevd> > (sequence$ [Just 9,Just 2])
20:07:17 <lambdabot>   Just [9,2]
20:07:29 <startling> > sequence [Just 9, Nothing, Just 2]
20:07:31 <lambdabot>   Nothing
20:07:43 <udevd> > (sequence$ [Just 9,Just 2])>>=(\x ->Just (x++[0]))
20:07:44 <lambdabot>   Just [9,2,0]
20:07:46 <udevd> oh ok
20:09:02 <udevd> i don't know if there's any neat way to map over list which elements are monads...
20:09:17 <jle`> you probably want fmap . fmap
20:09:21 <startling> udevd, why would you want to do that?
20:09:42 <udevd> just because i have such list, startling
20:09:43 <startling> Maybe you're talking about Maybe.
20:09:46 <udevd> yup
20:09:53 <startling> > map (fmap (+ 1)) [Just 2, Just 3]
20:09:54 <lambdabot>   [Just 3,Just 4]
20:10:04 <udevd> yes, but it's not >neat
20:10:18 <startling> > (map . fmap) (+ 1) [Just 2, Just 3]
20:10:23 <lambdabot>   [Just 3,Just 4]
20:10:32 <dmj`> StateT rocks, so does RWST
20:11:04 <dmj`> I think Snap uses StateT Iteratee ()
20:11:11 <triliyn> @ty mapM
20:11:12 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
20:11:13 <Twey> To be sure
20:11:13 <jle`> is there some syntax/operator for something like fmap^n
20:11:27 <dmj`> @typ (<$>)
20:11:28 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:11:28 <Twey> That doesn't mean you should rewrite every function ever in terms of it, though :þ
20:11:37 <dmj`> jle`: is that what you want?
20:11:38 <Twey> jle`: No, because fmap can change the type
20:11:52 <startling> triliyn: that isn't what udevd wants
20:11:58 <Twey> :t fmap
20:11:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:12:01 <Twey> :t fmap fmap
20:12:02 <lambdabot> (Functor f, Functor f1) => f (a -> b) -> f (f1 a -> f1 b)
20:12:14 <udevd> no, map.fmap just works
20:12:20 <triliyn> startling: yeah, I wasn't sure
20:12:23 <udevd> but is not eye-candy
20:12:25 <udevd> you know
20:12:26 <startling> :t foldr1 (.) $ replicate 5 fmap
20:12:27 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = f0 a0
20:12:28 <lambdabot>     Expected type: (a0 -> b0) -> a0 -> b0
20:12:28 <lambdabot>       Actual type: (a0 -> b0) -> f0 a0 -> f0 b0
20:12:33 <jle`> Twey: good point
20:12:44 <startling> udevd: It looks fine to me.
20:12:58 <jle`> but you probably meant
20:13:01 <jle`> :t fmap . fmap
20:13:02 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
20:13:11 <dwcook> :t fmap fmap fmap
20:13:12 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
20:13:21 <jle`> what the
20:13:21 <dwcook> ;)
20:13:39 <jle`> does this have to do with the functor instance for functions >>
20:13:42 <startling> jle`: (if you do it at the value level, you don't get a well-formed type)
20:13:44 <startling> jle`: yeah.
20:13:46 <triliyn> It does
20:13:51 <startling> :t fmap . fmap
20:13:52 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
20:13:59 <dmj`> startling: dang it I was gonna do that
20:14:18 <startling> :t fmap `fmap` fmap
20:14:19 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
20:14:35 <startling> fmap = (.) for functions; fmap and fmap are both functions.
20:14:45 <jle`> what about only for functions where their domain is their range.  like T.map or any monomorphic traversible
20:14:55 <jle`> (*)
20:15:14 <startling> jle`: it needs to be unary functions whose domain is their range.
20:15:14 <jle`> (+) etc.
20:15:28 <jle`> ah, yeah, didn't think that through
20:15:39 <startling> :t foldr1 (.) $ replicate 5 (+ 2)
20:15:40 <lambdabot> Num c => c -> c
20:15:44 <jle`> actually the more i think about it the less this makes sense
20:15:45 <dwcook> Isn't "unary function" redundant?
20:16:06 <startling> jle`, yes.
20:16:07 <startling> er
20:16:09 <startling> dwcook: yes.
20:16:21 <startling> jle`, (map's domain isn't its range)
20:16:30 <jle`> hm.  but fmap^4 makes sense to think about
20:16:33 <jle`> even though it doesn't have the same type as fmap
20:16:48 <startling> jle`: you can talk about it, you just can't haskell about it.
20:17:09 <jle`> it's type-inferrable, isn't it?
20:17:15 <jle`> :t fmap . fmap . fmap . fmap
20:17:16 <lambdabot> (Functor f, Functor f1, Functor f2, Functor f3) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
20:17:23 <dwcook> I think there is some confusion here. fmap on functions only requires that the domain remain the same; it's the codomain that gets mapped over.
20:17:38 <startling> sure. fmap ^ n doesn't have the same type for every n, though.
20:17:43 <dwcook> The domain of the thing being "mapped", i.e., the thing you pass after the thing that does the mapping.
20:17:48 <triliyn> jle`: some cases are type inferrable, but something like fmap^(f n) is not
20:17:48 <jle`> startling: ah, that was the key
20:17:58 <jle`> to unraveling my thought
20:18:01 <jle`> thank you
20:18:06 <startling> jle`: so you can't write fmap ^ n, because its type depends on n ...
20:18:15 <triliyn> It could be done as specialized syntax though, couldn't it?
20:18:21 <startling> jle`: (without something called dependent types, which Haskell can sometimes approximate)
20:18:28 <startling> triliyn: you could do it with a macro
20:19:30 <dmj`> is fromJust, dirty?
20:19:37 <startling> dmj`: so so dirty
20:19:56 <dwcook> :t maybe
20:19:57 <lambdabot> b -> (a -> b) -> Maybe a -> b
20:20:01 <dwcook> dmj`, try that instead
20:20:08 <dmj`> startling: Ok then, in snap... emailField <- fromJust <$> getParam "email"
20:20:14 <enthropy> :t fromMaybe
20:20:15 <dmj`> or Just emailField <- getParam "email"
20:20:15 <lambdabot> a -> Maybe a -> a
20:20:16 <Rarrikins> maybe undefined id
20:20:25 <startling> jle`: btw, "\n f -> foldr id (.) $ replicate n f" is just mapping from one encoding of natural numbers to another
20:20:36 <dwcook> Rarrikins, :(
20:21:05 <startling> dmj`, (Just emailField) <- getParam "email" may be preferable
20:21:17 <dwcook> Oh, so you can use fail?
20:21:19 <startling> dmj`, what's your monadic context?
20:21:30 <dmj`> startling: the Snap monad
20:21:39 <startling> dmj`, does it have provisions for failing?
20:22:09 <dmj`> yes, render a 500 error msg
20:22:22 <dmj`> send a 500 Resp
20:22:35 <startling> dmj`: is that OK if the email field is not filled out?
20:23:11 <startling> dmj`: (n.b. the alternative -- fromJust -- would just crash in this case)
20:24:14 <dested> skypers, did you mean to ping me?
20:24:17 <startling> dmj`, "emailField <- getParam "email" >>= maybe empty return" might be good too.
20:24:25 <dmj`> startling: Just emailField <- getParam "email", would crash if the name attribute of the id #email input field was tampered with
20:24:38 <startling> dmj`: eh?
20:24:51 <startling> dmj`, monadic pattern binds don't crash anything.
20:24:56 <startling> they call fail if they don't match.
20:25:14 <dmj`> <input type="text" name="emailField" value="foo" />, now someone makes name="email1Field"
20:25:29 <startling> um, what
20:25:41 <dmj`> when you submit a POST request
20:25:45 <startling> Yes.
20:25:47 <dmj`> from a form
20:26:01 <startling> I understand.
20:26:11 <startling> dmj`, but monadic pattern binds don't crash things.
20:26:21 <startling> dmj`: they call "fail" in the monadic context.
20:27:04 <startling> this is kind of ugly behavior, so "emailField <- getParam "email" >>= maybe empty return" is probably better.
20:27:16 <dmj`> startling: I see, but fromJust would fail still, even inside a monadic pattern binding
20:27:36 <dmj`> > [ x | Just x <- [Nothing, Just 1, Just 2]]
20:27:38 <lambdabot>   [1,2]
20:27:46 <startling> dmj`, fromJust just crashes if it gets a Nothing.
20:27:52 <startling> > fromJust Nothing
20:27:54 <lambdabot>   *Exception: Maybe.fromJust: Nothing
20:28:09 <startling> dmj`, "fail" may do something useful, and apparently does for Snap.
20:28:28 <startling> > do { Just x <- Just Nothing; return x; }
20:28:29 <lambdabot>   Nothing
20:28:52 <startling> > do { 13 <- Just 10; return (); }
20:28:54 <lambdabot>   Nothing
20:29:52 <dmj`> > [1..10] :: [Int]
20:29:53 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
20:30:03 <dmj`> > fail :: [Int]
20:30:04 <lambdabot>   Couldn't match expected type `[GHC.Types.Int]'
20:30:05 <lambdabot>              with actual typ...
20:30:15 <startling> > fail "oops" :: [Int]
20:30:16 <lambdabot>   []
20:30:22 <startling> > fail "oops" :: Just Int
20:30:24 <lambdabot>   Not in scope: type constructor or class `Just'
20:30:24 <lambdabot>  A data constructor of that ...
20:30:24 <dmj`> > do { fail "oh" } :: [Int]
20:30:25 <lambdabot>   []
20:30:31 <startling> er
20:30:35 <startling> > fail "oops" :: Maybe Int
20:30:36 <lambdabot>   Nothing
20:30:48 <startling> > fail "oops" :: Either () ()
20:30:49 <dmj`> I thought fail was evil
20:30:49 <lambdabot>   *Exception: oops
20:31:27 <startling> dmj`: it sometimes is. That's why I said the version using "empty" is more explicit about its behavior.
20:31:53 <dmj`> startling: in which cases
20:32:24 <startling> "empty" is sort of like "fail", but it's not hacked onto Monad -- it's part of a separate typeclass called Alternative which is explicitly for failure.
20:32:44 <startling> dmj`: in the cases when your computational context may not implement "fail".
20:33:05 <triliyn> > fail "oops" :: Either String ()
20:33:06 <lambdabot>   *Exception: oops
20:34:21 <dmj`> Alternative is for Applicatives that act like monoids, right? Parsec uses it (<|>)
20:35:07 <triliyn> startling: is that basically MonadPlus without the Monad type constraint?
20:35:22 <triliyn> (Or at least a subset of MonadPlus?)
20:36:02 <dmj`> triliyn: yes, mplus and mempty, are empty and (<|>)
20:36:35 <startling> triliyn: yeah, it's MonadPlus for Applicative
20:37:07 <triliyn> Alternative probably doesn't have guard, right? Because you can't introduce a new context, only transform the contents of one
20:39:23 <startling> :t guard
20:39:24 <lambdabot> MonadPlus m => Bool -> m ()
20:39:39 <startling> :t \b a -> if b then a else empty
20:39:40 <lambdabot> Alternative f => Bool -> f a -> f a
20:40:12 <startling> :t \b -> if b then pure () else empty
20:40:13 <lambdabot> Alternative f => Bool -> f ()
20:40:25 <startling> triliyn, you're missing a slight distinction I think.
20:40:25 <triliyn> hmmm, I see
20:40:36 <startling> triliyn: if guard :: f Bool -> f (), you couldn't.
20:40:55 <triliyn> Right
20:40:59 <triliyn> Interesting
20:41:40 <startling> triliyn: the difference is that Bool can't be from some action
20:42:53 <monochrom> yeah, in the monad case, you can use Bool -> m () to help you write m Bool -> m ().
20:43:30 <startling> Yeah.
20:45:04 <triliyn> Thanks for pointing that out to me!
20:48:41 <MitchellSalad> getting a "Couldn't match type Maybe Foo with base:Data.Maybe.Maybe a0" when trying to use Fay.Convert.readFromFay. Anyone know why?
20:49:02 <MitchellSalad> I know Fay uses its own version of Maybe, but then shouldn't readFromFay also use this Maybe?
20:49:46 <startling> Fay has its own Maybe? o.o
20:50:02 <Clint> o_O
20:50:16 <MitchellSalad> well, if it doesn't then what does that error message even mean? Maybe /= Data.Maybe.Maybe??
20:51:18 <MitchellSalad> here's some code: http://lpaste.net/94777
20:52:22 <startling> MitchellSalad: it sounds like you're pulling in two versions of base somehow
20:52:50 <startling> I don't know if that's possible. It's not with GHC, but.
20:54:07 <MitchellSalad> hm, you could be right... I have ghc, cabal, happy, alex installed via pacman (package manager), and eveything else installed with cabal
20:54:14 <MitchellSalad> how might i tell if i have two versions of base?
20:54:59 <MitchellSalad> cabal info base says "Versions installed: 4.6.0.1"
20:56:37 <MitchellSalad> friend just tried running the same code on a different OS and saw the same results though
20:59:52 <peddie> MitchellSalad: ghc-pkg list base
21:01:41 <MitchellSalad> only one
21:02:04 <monochrom> which package has Language.Fay.Convert so I can find it?
21:02:43 <MitchellSalad> sorry, it's Fay.Convert
21:02:55 <MitchellSalad> i updated the paste
21:03:26 <MitchellSalad> either fay or fay-base
21:03:51 <monochrom> ok, I had looked at Fay.Convert.readFromFay for minutes before I asked. it's Maybe is clearly base's Maybe.
21:03:58 <MitchellSalad> yeah
21:04:15 <monochrom> maybe I should try it myself in a sandbox
21:04:17 <MitchellSalad> and since fay hides base, how the hell does the author expect me to use this function when compiling with fay? :)
21:08:49 <MitchellSalad> fay has been around a while and readFromFay is definitely not an obscure function in the package so I know the problem is on my end
21:10:22 <monochrom> are you supposed to use readFromFay in a fay program, as opposed to a haskell program?
21:11:57 <udevd> > [1..5] >>= id
21:11:58 <lambdabot>   No instance for (GHC.Show.Show b0)
21:11:58 <lambdabot>    arising from a use of `M514442886.sho...
21:12:02 <udevd> erm
21:12:17 <MitchellSalad> I would assume you are supposed to use it in a fay program
21:12:19 <startling> > [[1..5]] >>= id
21:12:21 <lambdabot>   [1,2,3,4,5]
21:12:41 <udevd> > Just 2 >>= (\x -> Just x+2)
21:12:43 <lambdabot>   No instance for (GHC.Show.Show b0)
21:12:43 <lambdabot>    arising from a use of `M14928318.show...
21:12:50 <udevd> > Just 2 >>= (\x -> Just (x+2))
21:12:52 <lambdabot>   Just 4
21:13:38 <malaclyps> > [1..5]
21:13:40 <lambdabot>   [1,2,3,4,5]
21:14:08 <startling> MitchellSalad: I think there might be a fay channel.
21:15:52 <udevd> > [(a,b) | a<- [1..5],b<-"ab"]
21:15:53 <lambdabot>   [(1,'a'),(1,'b'),(2,'a'),(2,'b'),(3,'a'),(3,'b'),(4,'a'),(4,'b'),(5,'a'),(5...
21:15:58 <udevd> > [(a,b) | a<- [1..3],b<-"ab"]
21:15:59 <lambdabot>   [(1,'a'),(1,'b'),(2,'a'),(2,'b'),(3,'a'),(3,'b')]
21:16:08 <udevd> > lookup 2  [(a,b) | a<- [1..3],b<-"ab"]
21:16:10 <lambdabot>   Just 'a'
21:16:38 <udevd> > lookup 2  [(a,b) | a<- [1..3],b<-"ab"] >>= (\c -> c:"0")
21:16:39 <lambdabot>   Couldn't match type `[]' with `Data.Maybe.Maybe'
21:16:39 <lambdabot>  Expected type: Data.Maybe...
21:16:45 <udevd> > lookup 2  [(a,b) | a<- [1..3],b<-"ab"] >>= (\c -> (c:"0"))
21:16:46 <lambdabot>   Couldn't match type `[]' with `Data.Maybe.Maybe'
21:16:46 <lambdabot>  Expected type: Data.Maybe...
21:16:48 <udevd> > lookup 2  [(a,b) | a<- [1..3],b<-"ab"] >>= (\c -> Just (c:"0"))
21:16:49 <lambdabot>   Just "a0"
21:17:01 <udevd> > lookup 2  [(a,b) | a<- [1..3],b<-"ab"] >>= (\c -> Just (c, "0"))
21:17:02 <lambdabot>   Just ('a',"0")
21:20:07 <udevd> > mapM (\x -> Just 2*x) [Just w| w<-[1..10]]
21:20:08 <lambdabot>   No instance for (GHC.Show.Show b0)
21:20:08 <lambdabot>    arising from a use of `M1602838282.sh...
21:20:30 <udevd> > mapM (\x -> Just 2*x) Just 2
21:20:31 <lambdabot>   Couldn't match expected type `a1 -> t0'
21:20:31 <lambdabot>              with actual type `Data...
21:20:34 <udevd> > mapM (\x -> Just 2*x) $Just 2
21:20:35 <lambdabot>   Couldn't match expected type `[Data.Maybe.Maybe b0]'
21:20:35 <lambdabot>              with actu...
21:20:50 <flebron> Hi. What could this be indicative of? cabal: Couldn't read cabal file "cabal-install/1.18.0/cabal-install.cabal". I do cabal update, then cabal install cabal-install. This is Ubuntu 12.04.3 LTS.
21:20:58 <simpson> :t mapM
21:20:59 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
21:21:36 <simpson> :t \x->Just (2*x)
21:21:37 <lambdabot> Num a => a -> Maybe a
21:21:54 <udevd> @type mapM
21:21:55 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
21:22:12 <udevd> @type mapM_
21:22:13 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
21:22:34 <udevd> @type fmap
21:22:34 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:24:21 <udevd> > map (fmap (*2) ) [Just 2, Nothing, Just -2]
21:24:22 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe b0'
21:24:22 <lambdabot>              with actual...
21:24:32 <udevd> > map (fmap (\x -> 2*x) ) [Just 2, Nothing, Just -2]
21:24:34 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe b0'
21:24:34 <lambdabot>              with actual...
21:24:40 <udevd> what.
21:24:43 <udevd> > map (fmap (\x -> 2*x) ) [Just 2, Nothing]
21:24:44 <lambdabot>   [Just 4,Nothing]
21:24:46 <udevd> ah
21:24:47 <udevd> okay
21:32:36 <udevd> > fst ('a',2)
21:32:37 <lambdabot>   'a'
21:39:04 <udevd> > groupBy (>) [1..4]
21:39:05 <lambdabot>   [[1],[2],[3],[4]]
21:39:05 <flebron> Is there a way to install a package without using cabal-install?
21:39:08 <udevd> > groupBy (>) [4..1]
21:39:09 <lambdabot>   []
21:39:13 <udevd> > groupBy (>) [4,3..1]
21:39:14 <lambdabot>   [[4,3,2,1]]
21:39:39 <udevd> flebron: perhaps you can just download the code and use it. why for?
21:39:41 <flebron> My cabal-install is hosed since it can't read new package files, and upgrading cabal-install manually requires a version of deepseq newer than the one I have, so I can't even install cabal-install myself.
21:39:56 <udevd> welp.
21:39:57 <flebron> Apparently the "LTS" in "Ubuntu LTS" doesn't include making Haskell work :p
21:40:04 <carter> flebron: cabal sandbxoes!
21:40:12 <flebron> carter: I can't upgrade cabal.
21:40:22 <flebron> Every invocation of cabal ends with "cabal: Couldn't read cabal file "Cabal/1.18.0/Cabal.cabal"".
21:40:27 <carter> flebron: one of hvr's new PPA's
21:40:45 <udevd> > groupBy (>) [4,3,2,5,6,7,6,5,1,0,4]
21:40:46 <lambdabot>   [[4,3,2],[5],[6],[7,6,5,1,0,4]]
21:40:59 <flebron> So I should uninstall cabal using apt-get and then add that PPA and install it again?
21:41:29 <carter> flebron: yes, don't let your package manager manage it, they're doing it wrong :)
21:42:22 <flebron> Oh great, removing cabal-install needs to remove haskell-platform.
21:42:48 <carter> yes
21:42:49 <carter> thats oke
21:42:54 <carter> you're hosed anyways
21:42:55 <carter> :)
21:42:59 <carter> time to start again!
21:43:02 <carter> burn it all with fire
21:43:22 <monochrom> time to reconsider why you stick with apt-get
21:43:29 <flebron> I use aptitude.
21:43:51 <monochrom> yes yes, ok I'll correct my sentence
21:44:02 <flebron> But I can't upgrade cabal-install, and the current one can't build packages, so... Ubuntu 12.04.3 LTS has no Haskell, basically.
21:44:03 <monochrom> time to reconsider why you stick with deb files at all
21:44:30 <flebron> monochrom: What's your suggestion?
21:45:20 <carter> flebron: dl the generic linux bin dist
21:45:30 <carter> and manage it yourself :)
21:45:56 <flebron> :p
21:46:38 <flebron> carter: You mean of cabal-install?
21:46:43 <monochrom> "manage" is really easy. "./configure --prefix=/usr/local/ghc-7.6.3" ensures easy erasure when you want to erase
21:46:48 <carter> :)
21:46:51 <carter> yes
21:47:28 <monochrom> http://www.haskell.org/ghc/dist/7.6.3/ghc-7.6.3-x86_64-unknown-linux.tar.bz2
21:47:33 <flebron> Where's the gener -- oh.
21:47:45 <flebron> I could only find the .exe on haskell.org.
21:48:04 <flebron> (What a mess. I can't even compile cabal from source.)
21:48:06 <monochrom> or even http://www.vex.net/~trebla/haskell/I-built-GHC.xhtml
21:48:34 <carter> flebron: let monochrom  tell you what do to :)
21:48:36 <carter> todo
21:48:41 <flebron> I'd be more understanding if it was something I did wrong, but it seems it's just the way life is for everyone who installed cabal's previous versions.
21:48:59 <carter> flebron: no, its the way of pain to less the OS package manager control your software in haskell
21:49:03 <carter> *let
21:49:06 <carter> i don't trust em
21:49:08 <monochrom> oh, you want more? then also http://www.vex.net/~trebla/haskell/haskell-platform.xhtml :)
21:49:43 <flebron> monochrom: That isn't cabal-install though, it's ghc isn't it?
21:50:08 <monochrom> you may as well start with GHC
21:50:21 <flebron> :ssssssssssss
21:50:36 <flebron> So basically I've to nuke everything.
21:50:43 <jedai> I'm getting : "ghc.exe: ..\.cabal-sandbox\i386-windows-ghc-7.6.3\numeric-extras-0.0.3\libHSnumeric-extras-0.0.3.a: unknown symbol `_expm1'"
21:50:43 <jedai> Does someone know of a solution to this problem (apart from installing GHC Head and starting from scratch) ? This used to happen when I used cabal repl but now I get it even for cabal build...
21:50:48 <monochrom> which version of GHC was it in ubuntu 12.04? it has been a long time
21:50:57 <flebron> 7.6.3
21:51:01 <flebron> Err, 7.0.3
21:51:12 <monochrom> are you sure you even want to stick with 7.0?
21:51:30 <flebron> I don't much care. Could uninstalling and reinstalling haskell-platform fix things?
21:51:49 <carter> flebron: 7.6 is MUCH NICER
21:52:10 <monochrom> 7.0 will run you into more incompatibilities soon
21:52:27 <jedai> Except under windows (well ok, even under windows but there are still some strange bugs (see above))
21:54:02 <monochrom> I do not advocate staying newest either. but borrowing ideas from what the haskell-platform people choose is exactly not-too-new and not-too-old. because they actually care.
21:54:15 <monochrom> the current haskell platform chooses ghc 7.6.3
21:54:46 <flebron> Oh, OK, so even haskell-platform on Ubuntu Precise (LTS) is at most GHC 7.0.3, so I either install another OS, or use a PPA (if I want my package manager to keep track of haskell).
21:55:32 <carter> flebron: hvr  has a ppa
21:55:33 <flebron> And since a LTS version only upgrades to another LTS, installing another OS means wiping out this one :p
21:55:37 <flebron> Yeah I'll look into that.
21:55:50 <carter> https://launchpad.net/~hvr/+archive/ghc
21:55:59 <carter> get 7.6.3
21:58:10 <flebron> So it doesn't have haskell-platform.
21:58:38 <flebron> Should I just install ghc-7.6.3 and cabal-install?
21:58:57 <ion> flebron: FWIW, this is what i always do: https://gist.github.com/rmoorman/4130436
21:59:28 <flebron> Right, so everything locally.
22:01:20 <flebron> Should I just do that, and forget about a system-wide Haskell?
22:01:34 <flebron> (This is nightmarish, btw :p)
22:01:47 <monochrom> you can always use --prefix=/usr/local/ghc-7.6.3 and call it system-wide
22:02:17 <flebron> Does everyone have to jump through these hoops?
22:02:42 <monochrom> I don't understand. has apt-get spoiled people so much, they now don't understand "./configure --prefix=/xxx"?
22:03:10 <flebron> I understand that my package manager will no longer manage it, so I may get dependency hell.
22:04:10 <monochrom> I don't, in fact, see any hoops to jump through.
22:04:36 <monochrom> I see, in fact, trying to find a ghc-related deb is a lot of hoops to jump through, as you have demonstrated
22:06:40 <monochrom> it is either a 2 year old version (recall that when they chose a GHC for 12.04, they had to add another -0.5 years, just because they felt like sticking to old), or someone's PPA that may disappear any day. if that is not hoops to jump through, nothing is.
22:08:55 <flebron> ion: Your GitHub links to GHC 7.4.1. Should I change that to be (latest GHC)?
22:10:31 <glguy> Your dependency hell will come when you mix package manager managed packages and hackage installed packages
22:10:57 <flebron> D:::::
22:11:10 * flebron gives up and uses Python :p
22:11:27 <monochrom> yes, http://www.vex.net/~trebla/haskell/sicp.xhtml#unsafeInterleave
22:12:43 <monochrom> I am not the slackware kind of guy who says "build everything yourself from tarballs". I go with ubuntu's znc, ubuntu's xchat, ubuntu's firefox, ubuntu's thunderbird, ubuntu's gnome...
22:13:37 <monochrom> but GHC, that is really not ubuntu's or debian's cup of tea. they are always too much behind.
22:14:19 <glguy> Haskell users can get Haskell programs with static-linking (of the Haskell libraries) without needing libraries installed by the package manager
22:14:40 <glguy> Haskell developers aren't going to be well served by a limited selection of outdated packages
22:14:47 <monochrom> general rule: if you lag behind haskell platform (the real one, not the debian-ubuntu pretense), you're too old, because haskell platform already tries to be old.
22:21:49 <stolaruk> how can I pattern match a non-empty list of list?
22:22:12 <startling> [_]
22:22:17 <startling> or
22:22:19 <startling> er
22:22:24 <glguy> (_:_)
22:22:30 <startling> yeah.
22:22:52 <stolaruk> interesting I was trying [_:_]
22:23:33 <glguy> Do you understand what that pattern would match?
22:23:51 <stolaruk> I guess not. I want to match a list that contains a non-empty list
22:24:28 <ParahSail1n> ((_:_):_)
22:24:38 <stolaruk> ParahSail1n: yeah that is what I want I think
22:24:44 <glguy> Parah's will work if you want to match where the first list is non-empty
22:24:46 <ParahSail1n> butts
22:24:59 <ParahSail1n> oh yeah wait
22:25:25 <stolaruk> woh
22:25:36 <stolaruk> But yeah that should work for me
22:25:37 <glguy> If you want to check if there is SOME non-empty list you can use a predicate: any (not . null)
22:26:21 <glguy> [_:_] matches when there is ONE list and that list is non-empty
22:26:34 <stolaruk> glguy: Yeah that was my problem.
22:26:38 <stolaruk> I didn't want that
22:27:12 <stolaruk> ((_:_):_) looks freaky but it gets the job done
22:27:13 <funfunctor> hi, is it possible to have the option of two data types for a given thing in a GADT?
22:27:19 <stolaruk> thanks
22:27:28 <funfunctor> i.e. nameserver :: IP, String
22:28:23 <monochrom> nameserver :: Either IP String. or replace Either by another type you write
22:28:45 <funfunctor> ah yea, thanks monochrom !
22:28:59 <funfunctor> Haskell's prelude is huge..
22:29:15 <glguy> Are you sure you're 1) using a GADT 2) need a GADT?
22:30:22 <monochrom> you don't have to use the Prelude. you can write your own. even GADT.
22:30:51 <startling> funfunctor, data FunFunctor where WithIP :: IP -> FunFunctor; withString :: String -> FunFunctor;
22:31:07 <glguy> for the record, that's not a GADT
22:31:56 <monochrom> is that in the same sense as "a square is not a rectangle"?
22:33:12 <carter> Its not a gadt
22:33:19 <carter> in any sense of the word
22:33:20 <carter> at all
22:33:22 <carter> none whatsoever
22:33:27 <stolaruk> I am pattern matching against [String] ; why does the lint tell me that I'm not matching [] ? How is [] even a possible value for [String] ? Of course I can see [""] but how [] ?
22:33:30 <funfunctor> I am just trying to write a paser with attoparsec, I gave up with LBNF
22:33:38 <carter> Either is a GADT like Null is the number 7
22:33:52 <funfunctor> I could not define exactly what I was thinking so I figured doing it less formally would be better in this case?
22:34:12 <startling> sure. I assume funfunctor was asking about GADT syntax.
22:34:45 <funfunctor> I was, thanks that little problem is solved.
22:34:59 <startling> funfunctor: you probably don't need GADT syntax.
22:35:14 <monochrom> the type [T] allows the value []. now let T = String.
22:35:24 <funfunctor> https://gist.github.com/victoredwardocallaghan/7137219 I am trying to paser this.
22:36:06 <funfunctor> unless anyone is around that can help me with my prefered way of doing BNF notation.
22:37:01 <funfunctor> I suspect the sematantics are very loose and so it could be diffcult?
22:37:26 <monochrom> this is also related to: "a set that has no string element" vs "a set that has one string element, that string has length 0"
22:37:44 * hackagebot crypto-cipher-types 0.0.9 - Generic cryptography cipher types  http://hackage.haskell.org/package/crypto-cipher-types-0.0.9 (VincentHanquez)
22:38:11 <glguy> In the sense that if you aren't using any of the generalization in GADT that you're just going to make things harder for yourself when you try to figure out what you're doing and you're going to write erroneous bug reports to issue trackers I work on that I'm going to have to deal with :-p
22:38:19 <stolaruk> monochrom: I just don't see how [] can ever be a possible value for [String]
22:38:40 <funfunctor> I figured a design of some polymorphic functions for each block that are terminated with a '!'
22:38:42 <startling> stolaruk, I think you're confusing types and values.
22:38:44 <stolaruk> monochrom: The compiler knows I'm dealing with [String], it's not [T]
22:39:09 <stolaruk> oh
22:39:11 <glguy> stolaruk: Can you see how "0 inches" can be a length in inches?
22:39:11 <startling> funfunctor, data Item = DNS ... | HostName ... | Interface ...
22:39:22 <glguy> [] : [String] is a list of no strings
22:39:23 <monochrom> the compiler also knows that [String] works like [Int], [Bool], and [T]
22:39:58 <stolaruk> This shouldn't be too hard, I guess I'm tired ;)
22:40:03 <funfunctor> startling: well I was going to have hostname, dns, interface parsered as functions terminated with a '!'
22:40:17 <glguy> And I was writing Cryptol today so I decided that types are given with a :
22:40:27 <funfunctor> startling: there sub arguments are then some polymorphic type.
22:40:42 <stolaruk> I started to use Control.Lens today so that's a big step forward
22:41:08 <startling> funfunctor: I think you're confused.
22:41:15 <certainty> in the end it's always Lenses
22:41:19 <funfunctor> startling: likely!
22:41:30 <stolaruk> I also recently really wrapped my head around monad transformers and type StateT MyState IO ()
22:41:31 <carter> Lens shouldn't be used untl you're super comfortable with haskell
22:41:49 <stolaruk> carter: yeah probably not :)
22:41:50 <carter> unless you're skinny dipping in a volcano of nuclear power for fun
22:42:01 <certainty> haha
22:42:04 <startling> funfunctor, I've got some stuff to work on and I need to sleep, too, so I need to leave, but I think the other people in this channel can help.
22:42:05 <funfunctor> lol
22:42:08 <glguy> Just as long as you don't use them for anything, go nuts
22:42:09 <edwardk> carter: we brought johnw into the haskell community using the lens route, so it _can_ be done at least ;)
22:42:18 <carter> edwardk: wait, thats how he got involved?
22:42:24 <carter> he's only been in haskell for the past year?!
22:42:26 <funfunctor> like captin planet
22:42:28 <edwardk> yeah
22:42:31 <carter> really?!!?!
22:42:32 <carter> woah
22:42:47 <funfunctor> thanks man startling
22:42:51 <edwardk> see the power of lens? =)
22:42:51 <monochrom> "volcano of nuclear power" is happily redundant. Earth's volcanos are powered by natural nuclear reactions
22:42:57 <arkeet> lens did it?
22:43:00 <carter> waht, so he was C++ compiler deving and then just got super nerd sniped?!
22:43:04 <stolaruk> Is it really such a bad idea to jump into lenses early? I'm writing a program with nested record data types, seems like it's a good candidate
22:43:13 <carter> stolaruk: go for it!
22:43:17 <glguy> Volcanos are powered by nuclear reactions!?
22:43:20 <carter> its just a lot of machinery to learn :)
22:43:24 <carter> glguy: i think so
22:43:24 <glguy> Why was I not told about this!
22:43:26 <edwardk> stolaruk: its not terrible, but do expect to need some help here and there
22:43:29 <carter> glguy: i just learned tooo
22:43:33 <arkeet> fortunately you don't have to learn all of it to make good use of it!
22:43:38 <startling> A nice thing about lens is that you don't need to understand the machinery very much.
22:43:41 <startling> Yeah.
22:43:41 <carter> i'm going to need help too with lesn
22:43:41 <arkeet> plain old lenses go pretty far.
22:43:49 <carter> i'm just starting to dig in myself
22:44:08 <glguy> We need a rule that you can't use lenses while you're in your point-free phase of learning Haskell
22:44:10 <stolaruk> oh ok, yeah. Been reading a handful of tutorials, and yes the learning curve is steep in top of the already steep learning cure of the core lang
22:44:31 <edwardk> glguy: i'm still in it ;)
22:45:04 <stolaruk> edwardk: Are you the author of the library?
22:45:12 <edwardk> yeah
22:45:14 <stolaruk> oh cool
22:45:20 <glguy> edwardk: Using it at all isn' tthe same as using it at all costs
22:45:22 <stolaruk> I watched your talk at the NY gorup
22:45:24 <stolaruk> group
22:45:56 <carter> the nyc haskell meetup has AMAZING talks
22:45:58 <edwardk> glguy, startling, shachaf, elliott, and a bunch of others here pitch in a lot though, so its now very much a community effort and not so much just me any more
22:46:24 <stolaruk> The Haskell wizardry in your talk was mostly over my head but the wiki has helped a great deal
22:46:25 <stolaruk> :)
22:46:27 <simpson> I should lens more.
22:46:51 <stolaruk> edwardk: I want to get one of the hoodies
22:46:59 <edwardk> stolaruk: a lot of the wizardry was to showcase that it all does have a principled explanation, with the idea that you can get used to it over time
22:47:03 <carter> wait theres hoodies?1
22:47:08 <edwardk> stolaruk: let me get you a url to the design i made for it
22:47:15 <stolaruk> yeah hold on I have the url too I think?
22:47:43 <stolaruk> http://haskellapparel.spreadshirt.com/haskell-lambda-logo-fleece-zip-hoody-A7317063
22:47:46 <stolaruk> Is this not it?
22:47:59 <startling> simpson: I think a reason I got into lenses was you mentioning them to dash on #python way back in the day. Thanks!
22:48:02 <edwardk> no thats not the one
22:48:05 <glguy> carter , monochrom : Got any URLs on this nuclear powered volcano business? I want to know more
22:48:08 <simpson> startling: Heh. I believe it.
22:48:08 <stolaruk> oh!
22:48:16 <carter> glguy: i was just being silly
22:48:27 <carter> but the earth's core has lots of radioactive things
22:48:36 <carter> plus gravity pressure / churn
22:48:52 <glguy> damn it, I wanted to believe to much :)
22:48:59 <monochrom> world-nuclear.org/info/Nuclear-Fuel-Cycle/Uranium-Resources/The-Cosmic-Origins-of-Uranium/#.UlxuGmRDJf4  and I knew of it from last week's http://what-if.xkcd.com/67/
22:50:26 <edwardk> stolaruk: i've found one of the two designs for haskell hoodies i have, let me see if i can share the link
22:50:35 <stolaruk> edwardk: awesome please do
22:55:36 <edwardk> stolaruk: http://www.ooshirts.com/d/75446292
22:56:12 <edwardk> the actual hoodie turned out quite nicely
22:56:33 <edwardk> they adjusted the placement of the logos, etc.
22:56:37 <stolaruk> Thanks! Bookmarking ;)
22:57:04 <ion> flebron: Uh, sorry. I did a gist search and thought it linked to my giest. Instead it linked to someone’s fork. My version points to 7.6.3. https://gist.github.com/ion1/2815423
22:57:09 <stolaruk> Looks like the price is very reasonable
22:58:08 <jle`> a haskell hoodie. literally the one crucial thing that is missing from my life
22:59:08 <edwardk> stolaruk: the sit that has the other design doesn't seem to want to let me share it, but i like it less than the one i shared already anyways, the one i sent has the benefit that it has a zipper in front, the other one has a solid front, which makes it harder to adjust your temperature
22:59:12 <edwardk> er site
22:59:34 <stolaruk> I would prefer a zipper, yeah
22:59:47 <stolaruk> I am very likely gonna order this, thank you !
22:59:55 <edwardk> it gave me a url http://www.streetshirts.com/en-gb/share.aspx?designkey=PFC[yleW7894jd2MS350110GHK8B7d8p26] but that doesn't seem to take me anywhere
23:00:47 <carter> edwardk: metal or plastic zipper
23:01:01 <carter> ?
23:02:14 <adas> Is yesod mature enough to be used for making medium scale production level web apps?
23:02:28 <simpson> adas: Sure.
23:02:46 <edwardk> metal
23:02:57 <edwardk> adas: yes
23:03:16 <jle`> adas: i'd weigh in and say yes, but my opinion is of considerable less weight than the two above me
23:04:12 <carter> adas: all 3 web frameworks are good for medium or even larger
23:04:39 <stolaruk> good night all
23:10:07 <jle`> edwardk: let me know how i can stay subscribed to your hoodie enterprise
23:10:18 <edwardk> jle`: hah
23:10:39 <edwardk> its mostly just that i enjoy showing up to the gsoc mentor summit each year with a different one
23:10:56 <edwardk> it makes it easy for folks to pick me out of a crowd
23:11:14 <startling> @hackage hoodies
23:11:14 <lambdabot> http://hackage.haskell.org/package/hoodies
23:11:32 <adas> carter: when you say all 3.. you mean yesod, happstack and snap?
23:12:24 <edwardk> On multiple occasions now, I've had people stop me in the airport because they recognized Haskell, then when I told them my name, they recognized me. It is very disconcerting.
23:13:11 <jle`> edwardk: i assumed that you were going to order in bulk, right?  it's like $50 for an individual order
23:13:35 <edwardk> i just bought one for me at the time
23:14:18 <jle`> ah i see.
23:14:23 <edwardk> i wasn't sure how it would turn out. i liked it far more than i thought i would, but i'm not in the business of making hoodies =)
23:15:10 <jle`> perhaps not production, but more like distribution and finding suckers to give you money ;)
23:15:16 <jle`> (like me)
23:15:40 <jle`> maybe i'll find my into making one some day.  been meaning to pick up screen printing.
23:16:38 <edwardk> heh, i have enough trouble getting people to take haskell stickers, let along shoving hoodies at them =)
23:16:42 <edwardk> er let alone
23:17:11 <edwardk> i still have roughly 5000 haskell stickers sitting in a box.
23:17:11 * lispy took some haskell stickers, but only after prodding :)
23:17:15 <lispy> heh
23:17:59 <jle`> haha
23:18:09 <ion> Someone should make stickers out of these. http://www.haskell.org/haskellwiki/Haskell_logos/New_logo_ideas
23:18:21 <ion> http://www.haskell.org/wikiupload/7/75/Pure_Devil_Haskell.png
23:18:27 <jle`> any way i can get some stickers without imposing too much on you?
23:19:17 <edwardk> I just want the one with the narwhal
23:19:32 <ion> yeeaaaah!
23:19:42 <edwardk> http://www.haskell.org/haskellwiki/File:NarleyYeeaaahh.jpg
23:19:46 <startling> friends have used https://www.stickerguy.com/priclist.php , and it seems relatively cheap.
23:20:01 <edwardk> i used stickerguy. it was awful
23:20:23 <edwardk> davean gave me endless crap about the quality of the stickers i got
23:20:40 <startling> edwardk: really? dang.
23:21:15 <edwardk> they are cheap, but the black and white vinyl stickers are terrible. rough cut edges, bad stippling for anything not solid, bad resolution for edges, etc.
23:21:52 <startling> Weird. I have a handful of vinyl stickers from there that are pretty nice. I guess it's a quality control thing.
23:22:29 <startling> But knowing that I'll probably stop recommending them. :)
23:23:01 <edwardk> The ones I have now were done by http://www.greyprinting.com/ which are static cling based clear stickers based on the haskell logo svg resized to a something like 2.1" x 2.75"
23:23:18 <edwardk> i don't know the pantones exactly
23:23:55 <edwardk> the vinyl ones look like they were done by a caveman by comparison =)
23:24:09 <funfunctor> they accept bitcoin -> http://www.unixstickers.com/
23:24:34 <edwardk> startling: if you want to distribute them around haskellers in chicago, i can send you a roll ;)
23:24:52 <startling> edwardk: I don't know any Haskellers and I missed the meetup. :(
23:24:57 <edwardk> fair nuff
23:25:08 <jedai> cabal.exe: internal error when reading package index: could not read tar file entry The package index or index cache is probably corrupt. Running cabal update might fix it.
23:25:08 <johnw> there's another one coming up
23:25:16 <johnw> edwardk: if you want to send them to me, I'll take them on the 9th
23:25:18 <edwardk> maybe if i get out there for another lambdajam next year or something
23:25:21 <jedai> Hello, I'm getting the above ^
23:25:28 <edwardk> johnw: sure
23:25:33 <edwardk> johnw: if i forget ask amy.
23:25:49 <jedai> And cabal update isn't fixing it, is there anyone else having this problem ?
23:25:52 <johnw> is amy here on IRC?
23:26:00 <edwardk> johnw: no, but you have her # now =)
23:26:00 <jedai> Or is it coming from my computer ?
23:26:11 <johnw> well, true!
23:26:19 <johnw> i will forget too, btw
23:26:33 <edwardk> sure, but this way i don't feel guilty about it
23:26:47 <edwardk> ok, i'm largely immune to guilt anyways, but still
23:26:50 <startling> johnw: oh, neat, I can probably make this one.
23:26:51 <johnw> haha
23:26:55 <johnw> startling: excellent!
23:26:59 <startling> "(->) is syntax, sadly"
23:27:05 <edwardk> startling: =P
23:27:18 <edwardk> regret is not guilt ;)
23:27:51 <johnw> the Chicago Hackathon is on Nov 9th, in case anyone missing the cafe e-mail
23:28:00 <johnw> at Jeremy Shaw's place (of happstack fame)
23:28:03 <edwardk> the watched youtube video never uploads
23:28:13 <edwardk> johnw: saw the email, but its a bit of a drive =)
23:28:17 <johnw> haha
23:28:19 <johnw> not from Indiana!
23:28:23 <lispy> it's a bit far for me too...
23:28:26 <jedai> Am I the only one with a hackage/cabal problem ? Could someone just test a "cabal update && cabal install threepenny-gui" ?
23:28:31 <edwardk> also i'll be in budapest at the time
23:29:00 <edwardk> putting together a talk on succinct data structures for the 11th
23:29:14 <johnw> I'd settle for a succinct talk on data structures
23:29:35 <edwardk> i'll be doing a couple of talks in michigan early in november though
23:29:41 <edwardk> the 1st and the 5th
23:29:51 <johnw> depending on where in Michigan, that's 4-8 hours drive away
23:29:57 <lispy> jedai: what version of cabal? cabal --version
23:30:07 <jedai> Latest 1.8
23:30:16 <lispy> that's the problem
23:30:16 <edwardk> ypsilanti. kind of overcommitted for the trip though, so probably not worth the haul up there for you.
23:30:21 <jedai> 1.18.0.2
23:30:25 <lispy> ah
23:30:28 <lispy> well, that should work fin
23:30:32 <johnw> i'm setting up GHC and 10.9 in a VM right now, to see if I can still get work done if I were to upgrade
23:30:47 <jedai> Using 1.18.1.1 for Cabal
23:30:49 <lispy> jedai: older cabals would give that error message, but if you have a recent one then I'm not sure
23:30:52 <johnw> edwardk: I should just schedule a talk for you at my house
23:31:00 <edwardk> hah
23:32:07 <jedai> lispy: Are you sure that's not hackage itself ? I just tried nuking the index then regenerating it with the same result
23:32:16 <edwardk> if you snuck it on my calendar when i wasn't looking i'd probably show up unawares wondering why i'm talking about yesod in the enterprise or something ;)
23:32:29 <johnw> haha, I wouldn't do that to you
23:32:37 <johnw> you'd be talking about semilattices and profunctors, of course
23:34:15 <jedai> lispy: If it was Hackage, that would give me a good pretext to wait it out (probably in my bed, I just spent the night modifying my library and fighting cabal and Windows (linker problem))
23:35:05 <lispy> jedai: I'm on a slightly older cabal threepenny-gui is installing for me after an update
23:35:12 <jedai> And I'm pretty sure pretext isn't the right word but I'm just a bit brainfried now and my english isn't fluent at the best of time..
23:35:19 <jedai> Ah... too bad !
23:35:29 <jedai> Well back to the mine I go :)
23:36:04 <johnw> edwardk: I've started in on Lang; already learned a new term: "submonoid"
23:36:18 <edwardk> he's good for that
23:36:33 <johnw> it's a fat book!
23:36:33 <edwardk> does the general shape of the book live up to the promise?
23:36:38 <edwardk> i warned you =)
23:36:47 <johnw> thank goodness for PDFs; I can leave the book all nice and clean on my shelf, and read it page by page on the iPad
23:36:53 <edwardk> hah
23:37:00 <johnw> yeah, it seems like just what I needed
23:37:09 <johnw> i have soooo much background still to catch up on
23:38:29 <jedai> lispy: Apparently that linked to the fact that I'm compiling in a sandbox, outside I'm ok (but I tried nuking the cache of the sandbox too, so that's still a bug...)
23:38:41 <jedai> I'll try creating a new sandbox
23:38:56 <startling> jedai: report it, if it hasn't already been reported.
23:39:02 <xpika> I'm looking for a function "[a] -> Bool" that tests to see if all elements are unique
23:39:22 <johnw> xpika: xs == Set.toList $ Set.fromList xs
23:39:22 <startling> jedai: I found a sandbox bug the other day and it was fixed the next day.
23:39:24 <lispy> jedai: ah, interesting. Yeah, I'm still on cabal-dev on this machine.
23:39:38 <johnw> err, wrong use of $, but you get the idea
23:39:53 <lispy> jedai: I need to upgrade to latest cabal, but I just haven't bothered on this machine yet (I don't do much haskell on it)
23:40:08 <startling> cabal sandboxes are great.
23:40:17 <jedai> I think it may be better to wait a bit
23:40:27 <lispy> startling: indeed
23:40:33 <startling> :t \xs -> xs == nub xs
23:40:34 <lambdabot> Eq a => [a] -> Bool
23:40:43 <lispy> jedai: I'm using cabal sandboxes on my work computer without problems
23:40:46 <johnw> startling++
23:40:47 <startling> there's probably a less complex way to do it.
23:40:54 <jedai> There are small problems (among them the fact that gtk2hs doesn't compile naymore
23:41:11 <lispy> jedai: good luck. Wish I could stick around to help more, but it's my bedtime.
23:41:17 <jedai> Well it works (or at least it worked for me until recently)
23:41:21 <startling> :t (==) <$> id <*> nub -- if you're sadistic
23:41:22 <lambdabot> Eq a => [a] -> Bool
23:41:30 <jedai> but some problems remain
23:41:37 <jedai> lispy: Well good night
23:41:40 <jedai> :)
23:42:50 <johnw> startling: uncurry (==) (id &&& nub)
23:43:33 <jedai> startling: Well I will report it but I don't have the slightest idea how to reproduce it :-/
23:44:40 <startling> jedai: yeah. it's good to have a record, though, and the cabal folks might have an idea.
23:45:19 <jedai> Right, I'll attach the index file (maybe the package db ?)
23:47:21 <startling> It won't hurt.
23:54:08 <chrisdotcode> can someone help me with a sluggify function? this is what I have so far:
23:54:08 <chrisdotcode> sluggify (x:xs)
23:54:08 <chrisdotcode>   | isAlphaNum x = x : sluggify xs
23:54:08 <chrisdotcode>   | isSpace x = '-' : sluggify xs
23:54:08 <chrisdotcode>   | otherwise = sluggify xs
23:54:43 <chrisdotcode> and from that, ghci tells me that I have non-exhaustive patterns
23:55:29 <simpson> chrisdotcode: (x:xs) is only one constructor; you didn't match on [].
23:56:22 <chrisdotcode> simpson: ah, right! thanks :(
23:56:24 <chrisdotcode> * :)
23:56:50 <chrisdotcode> simpson: is there a better way to do it?
23:57:40 <simpson> chrisdotcode: Maybe a filter and map combination?
23:57:48 * hackagebot hoopl 3.9.0.0 - A library to support dataflow analysis and optimization  http://hackage.haskell.org/package/hoopl-3.9.0.0 (HerbertValerioRiedel)
23:58:15 <chrisdotcode> simpson: could you start me off in the right direction?
23:59:43 <simpson> chrisdotcode: Well, filter out the characters you don't want, and then map the ones you want to change.
