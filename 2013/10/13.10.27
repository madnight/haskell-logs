00:00:03 <augur_> how heavy was your hair? lol
00:02:17 <edwardk> mostly the fact that it was going all over the place
00:02:34 <augur_> edwardk: buns!
00:06:48 <sellout> edwardk: I did that a while ago – went from midway down my back to very short w/ electric clippers. I’ll never go back.
00:09:01 <edwardk> i've done it a couple of times. as i get older it doesn't quite have the texture it used to when i was younger and had it mid-back. i cut it off once in my dot-com days after a bad hair-cut rendered it a mullet
00:15:56 * hackagebot iso8601-time 0.1.1 - Convert to/from the ISO 8601 time format  http://hackage.haskell.org/package/iso8601-time-0.1.1 (NiklasHambuechen)
00:15:56 * hackagebot imagemagick 0.0.3 - bindings to imagemagick library  http://hackage.haskell.org/package/imagemagick-0.0.3 (AlexanderVershilov)
00:38:28 <augur_> anyone know of any good intros to constraint logic programming/constraint solving for general data types?
00:40:57 <Ghoul_> how might I get a list of the digits of every number up to 1,000,000?
00:41:15 <augur_> Ghoul_: list of the digits?
00:41:23 <Ghoul_> ie, 1001 = [1,0,0,1]
00:41:32 <augur_> > show 1001
00:41:36 <lambdabot>   "1001"
00:41:50 <Ghoul_> oh, I just need to convert them to numbers
00:41:50 <Ghoul_> derp
00:41:55 <augur_> > map read "1001"
00:41:57 <lambdabot>   Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
00:41:57 <lambdabot>  Expected type...
00:42:01 <augur_> D:
00:42:10 <Ghoul_> map read "1001" :: [Int]
00:42:12 <Ghoul_> > map read "1001" :: [Int]
00:42:14 <lambdabot>   Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
00:42:14 <lambdabot>  Expected type...
00:42:15 <augur_> map (read . (:[])) "1001"
00:42:17 <augur_> > map (read . (:[])) "1001"
00:42:19 <lambdabot>   [*Exception: Prelude.read: no parse
00:42:24 <augur_> :|
00:42:27 <augur_> read "1"
00:42:31 <augur_> > read "1"
00:42:32 <lambdabot>   *Exception: Prelude.read: no parse
00:42:39 <augur_> :t read
00:42:41 <Ghoul_> lol wat
00:42:41 <lambdabot> Read a => String -> a
00:42:44 <Ralith> > read "1" :: Integer
00:42:45 <lambdabot>   1
00:42:55 <augur_> oh i need to specify the type, right
00:43:09 <augur_> > map (read . (:[])) "1001" :: [Int]
00:43:11 <lambdabot>   [1,0,0,1]
00:43:56 <augur_> > let ghoul_ = map (read . (:[]) . show :: Int -> [Int] in ghoul_ 1001
00:43:57 <lambdabot>   <hint>:1:55: parse error on input `in'
00:44:03 <augur_> >_<
00:44:14 <augur_> @let ghoul_ = map (read . (:[]) . show :: Int -> [Int]
00:44:14 <lambdabot>  Parse failed: Parse error: EOF
00:44:18 <augur_> >_<
00:44:21 <Ghoul_> lol, I've got it dw
00:44:25 <augur_> well you get the point. :P
00:44:36 <augur_> oh i was missing a )
00:44:46 <augur_> > let ghoul_ = map (read . (:[])) . show :: Int -> [Int] in ghoul_ 1001
00:44:47 <lambdabot>   [1,0,0,1]
00:44:49 <augur_> \o/
00:44:50 <simpson> > map (\x -> ord x - 48) "1001"
00:44:52 <lambdabot>   [1,0,0,1]
00:44:58 <augur_> shut up simpson >|
00:45:05 <simpson> augur_: Relax.
00:45:13 <augur_> simpson: never!
00:45:22 <augur_> comin' up with better answers
00:45:22 <augur_> feh!
00:45:39 <augur_> > map ((-48) . ord) "1001"
00:45:41 <lambdabot>   No instance for (GHC.Show.Show b0)
00:45:41 <lambdabot>    arising from a use of `M2070739721.sh...
00:45:50 <simpson> I don't know if it's better, but it's certainly simpler.
00:45:52 <augur_> o_O
00:45:54 <augur_> > map ((- 48) . ord) "1001"
00:45:55 <lambdabot>   No instance for (GHC.Show.Show b0)
00:45:55 <lambdabot>    arising from a use of `M1594283772.sh...
00:46:00 <simpson> And it avoids the annoying Read/Show machinery.
00:46:08 <augur_> simpson: indeed
00:46:16 <simpson> @pl \x -> ord x - 48
00:46:19 <lambdabot> flip ((-) . ord) 48
00:46:19 <lambdabot> optimization suspended, use @pl-resume to continue.
00:46:44 <t0rus> o.O
00:46:55 <arkeet> augur_: (- 48) is the literal number -48
00:47:05 <augur_> ugh. stupid -
00:47:10 <simpson> :t (subtract 48)
00:47:11 <lambdabot> Num a => a -> a
00:47:32 * simpson &
00:48:49 <arkeet> :t subtract 48 . ord
00:48:51 <lambdabot> Char -> Int
00:50:46 <chexxor_netbook> I'm new to Haskell. I am trying to use Language.Java.Parser to get a list all MethodInvocations.
00:50:48 <t0rus> weird
00:50:51 <Ghoul_> :t maximum `on` fst
00:50:51 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = [a0] -> c0
00:50:52 <lambdabot>     Expected type: [a0] -> [a0] -> c0
00:50:52 <lambdabot>       Actual type: [a0] -> a0
00:51:18 <chexxor_netbook> I think I want to use Data.Foldable on the Java.Syntax data structure. Am I right? http://hackage.haskell.org/package/language-java-0.1.0/docs/Language-Java-Syntax.html
00:51:29 <Ghoul_> > max `on` fst $ [(1,1)]
00:51:31 <lambdabot>   Precedence parsing error
00:51:31 <lambdabot>      cannot mix `Data.Function.on' [infixl 0] and ...
00:51:37 <Ghoul_> > max `on` fst [(1,1)]
00:51:38 <lambdabot>   Couldn't match expected type `(a0 -> c0, b0)'
00:51:39 <lambdabot>              with actual type...
00:51:51 <Ghoul_> > maximum `on` fst [(1,1)] -- sorry I suck at this. I'll take it into a private chat if this doesn't work.
00:51:53 <lambdabot>   Couldn't match expected type `(a0 -> [a1], b0)'
00:51:53 <lambdabot>              with actual ty...
00:52:05 <copumpkin> :t max `on` fst
00:52:06 <lambdabot> Ord c => (c, b) -> (c, b) -> c
00:52:36 <Ghoul_> :t maximum `on` fst
00:52:37 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = [a0] -> c0
00:52:38 <lambdabot>     Expected type: [a0] -> [a0] -> c0
00:52:38 <lambdabot>       Actual type: [a0] -> a0
00:52:39 <copumpkin> :t maximumBy (comparing fst) [(1,1), (3,6)]
00:52:40 <lambdabot> (Num a, Num b, Ord a) => (a, b)
01:00:51 <dv-_> can I make a record with just lenses? something like undefined & x .~ 1 & y .~ 2 :: Point?
01:05:13 <Saizan> dv-_: it might work, i guess the easiest way is to try
01:07:14 <dv-_> oh, it doesn't work, I was just trying to illustrate what I meant
01:08:10 <Saizan> try C{} & x .~ 1 & y .~ 2 :: Point, replacing C with name of the constructor of Point
01:10:24 <dv-_> that works
01:10:49 <nkhodyunya> Hello, i have installed Haskell Platform 2013.2.0 on Mac OS 10.9, and now need to install some packages. Some of them fail during build with "error: invalid preprocessing directive #-}". Google showed that this is somehow related to clang. Does anyone know how to fix this problem?
01:13:21 * davidfetter hopes he's waving to the right edwardk
01:13:30 <edwardk> thats me
01:13:33 <edwardk> heya david
01:13:45 <Saizan> nkhodyunya: i think you've to tell ghc to use a different implementation of cpp, but i don't know the details
01:13:52 <edwardk> sounds like you made it home okay =)
01:13:53 <davidfetter> thanks for the ride to Amtrak :)
01:14:24 * davidfetter watching that youtube video you posted to twitter
01:14:26 <edwardk> you missed an epic dinner ;)
01:14:43 <edwardk> the slides are linked from it i think
01:14:49 <davidfetter> yeah, sorry. as of this morning, i missed my daughter's first steps. :/
01:14:56 * davidfetter in Moscow
01:14:58 <augur_> how did pre-monadic haskell treat io?
01:15:26 <Ghoul_> how do I get the maximum on 2 predicates?
01:15:33 <augur_> Ghoul_: maximum?
01:15:35 <Ghoul_> ie, I want to sort by fst, and when those are equal, sort by snd
01:15:37 <edwardk> augur_: lazy list of requests linked to a lazy list of responses being careful not to force each list too far
01:15:46 <edwardk> augur_: check the history of haskell paper
01:15:54 <augur_> edwardk: spj?
01:16:09 <edwardk> davidfetter: sorry to here. what sends you to moscow?
01:16:13 <edwardk> augur_: yeah
01:16:17 <edwardk> er hear
01:16:23 * augur_ crosses fingers that davidfetter replies "a plane!"
01:16:31 <davidfetter> i'm privileged to speak at highload++
01:16:36 <edwardk> augur_: =P
01:16:52 <augur_> ive gotten into ZAZ style comedy lately, that would've been perfect for one of their movies?
01:17:12 <davidfetter> oh, and a couple of planes yesterday. if i ever get the urge to be in a country for <2 days again, please hit me upside the head with a tire iron.
01:17:19 <Saizan> nkhodyunya: https://gist.github.com/pyrtsa/6213784 <- look at the comments here
01:17:26 <edwardk> heh, noted
01:17:29 <augur_> A: I'm heading to Moscow ...   B: what sends you there?   A: A plane, but that's not important.
01:17:46 <edwardk> i've got a few "in the country for <2 days' things coming up a couple of weeks from now
01:17:57 <augur_> edwardk: as it happens, i ask about io only because im watching the talk :)
01:18:18 <davidfetter> you coming to dublin?
01:18:38 <edwardk> when is the dublin thing again?
01:18:47 <davidfetter> this coming week
01:19:07 <edwardk> ah no, michigan that week. budapest, vienna, slovenia, and italy the week after
01:19:14 <davidfetter> ouch
01:19:30 <davidfetter> please tell me they're paying for the comfy chairs at least on the transcon flights
01:19:34 <edwardk> total of 6 talks in there
01:19:44 <Saizan> oh, italy where?
01:19:48 <davidfetter> prato
01:20:01 <davidfetter> http://2013.pgday.it/
01:20:06 <edwardk> Saizan: no real definite plans, just heading down to venice for the last day or two before flying out from there
01:20:24 <edwardk> Saizan: would be great to put a face to a name =)
01:20:57 <edwardk> i'll be there probably the 18th-19th i think
01:21:25 <edwardk> not sure how comfy a flight is being arranged yet, haven't seen the details
01:21:42 <edwardk> prezi was nice enough to fly me out there to give a talk to the budapest haskell user group
01:21:53 <edwardk> but the travel details are still going through
01:22:18 <Saizan> ah, venice is a bit far :)
01:22:40 <edwardk> Saizan: well, i'm coming down from slovenia, so i presume i could stop somewhere along the way =)
01:23:29 <Saizan> Ghoul_: use the monoid instance for (->) and Ordering, e.g. comparing fst `mappend` comparing snd
01:24:19 <Ghoul_> Saizan: thanks!
01:24:49 <Saizan> edwardk: tuscany is not along the way though :)
01:26:19 <edwardk> goes to show you what i know of italy ;)
01:26:45 <davidfetter> reports of the italian states' unifying into a country seem premature
01:28:15 <Saizan> heh
01:29:25 * moto9 fighting the urge to rewrite in C by reading http://www.haskell.org/haskellwiki/Performance
01:29:56 <bitemyapp> moto9: what are you working on that is tempting to rewrite in C?
01:30:17 <moto9> i'm toying with image analysis...
01:33:42 <moto9> my first optimizing problem is, -fprof-auto is still instrumenting functions marked INLINE
01:35:52 <Ghoul_> > map (\x -> (x, length [() | x > 5])) [1..10]
01:35:53 <lambdabot>   [(1,0),(2,0),(3,0),(4,0),(5,0),(6,1),(7,1),(8,1),(9,1),(10,1)]
01:37:07 <chexxor_netbook> Can anyone tell me the best way to analyze a Java class using this library? http://hackage.haskell.org/package/language-java-0.1.0/docs/Language-Java-Syntax.html
01:37:16 <Saizan> moto9: yeah, i've found that annoying too
01:37:47 <chexxor_netbook> I'm thinking Foldable, or Lens. But I'm no good at either of those, so, I'd like some direction before I spend lots of time.
01:43:28 <augur_> quickcheck is so beautifully simple, from SPJ's quick and dirty explanation
01:43:29 <augur_> man
01:58:32 <ion> Where is his quick and dirty explanation?
01:59:19 <augur_> A History of Haskell
02:00:13 <augur_> ion: http://www.youtube.com/watch?v=_61OhYbA36w&list=PLUWfjhrIRed8X8CbKbiIab6gfzqfqJmux starting at 9:50 just before the end, continuing to the next video
02:00:17 <augur_> its really beautifully simple tho
02:00:29 <augur_> at least the core idea
02:04:36 <ion> augur: Thanks
02:04:41 <augur_> np!
02:05:02 <ion> Yeah, i know how QuickCheck is made, i’m just interested to see that.
02:09:52 <augur_> ion: lmfao guy steele has a nice joke <3<3<3
02:10:05 <augur_> someone asked at one point, why is it values ~ types ~ type classes
02:10:12 <augur_> where is the fourth level, why no higher?
02:10:44 <augur_> someone else comments that in some fancy language where they use some kind of funky object constructors to get parametricity, he's never seen it go higher than three deep
02:10:55 <augur_> implying something interesting and deep
02:10:56 * hackagebot sized-vector 1.0.0.0 - Size-parameterized vector types and functions.  http://hackage.haskell.org/package/sized-vector-1.0.0.0 (HiromiIshii)
02:11:13 <augur_> so guy steele comes up and says in lisp he's never see more than three nested `s
02:11:14 <augur_> lol
02:11:33 <jdnavarro> is there any direct way to get a list of the constructors of a datatype?
02:12:31 <jdnavarro> I know I can do that with uniplate but wouldn't want to pull another dependency just for one line of usage
02:13:03 <Cale> jdnavarro: You mean from template haskell?
02:13:13 <ion> augur: Err, values : types = types : kinds
02:13:33 <jdnavarro> I need it for an arbitrary instance, BTW
02:13:38 <ion> augur: And there’s an infinite sequence of that.
02:13:58 <augur_> ion: im just telling you what the guy asked :p
02:14:10 <jdnavarro> Cale, is only possible with template haskell?
02:14:19 <wagle> two (2) spaces caused an infinite loop in my program..  bah
02:14:19 <augur_> ion: wadler does make that correction ofcourse, or maybe he misunderstood, i dont know.
02:14:55 <Cale> jdnavarro: Well, it's not entirely clear what you mean by a list of the constructors. The constructors of a datatype needn't have the same type, so you usually wouldn't be able to form a list of them.
02:15:31 <Cale> If they *do* have the same type, you can just make a list of them, I suppose.
02:16:01 <jdnavarro> Cale, oh, I see, in this case they are all the same type
02:16:15 <Cale> and if your type is a simple enumerated type, you can derive Enum and use a list like [A..Z] to get them all (where A is the first defined constructor and Z is the last)
02:17:44 <jdnavarro> Cale, you are right, I can derive a Enum type, that solves my problem, thanks!
02:17:54 <exposure27> xl1: 1
02:22:31 <wagle> should you need to flush stdout after a putStrLn and before an error?  how do you do that?
02:22:37 <skypers> hi
02:23:04 <Cale> wagle: Depends on buffering, I suppose, you can explicitly flush with hFlush stdout
02:23:17 <Cale> (after importing System.IO)
02:23:53 <Cale> If stdout is line buffered, then it should have flushed automatically.
02:24:34 <Cale> You can set the buffering with hSetBuffering stdout LineBuffering
02:24:46 <wagle> its getting an index error 10000 stdout lines before it could possibly do so
02:25:17 <wagle> hmm.. ok, thanks
02:27:13 <wagle> wow..  same with flushing
02:31:12 <Cale> wagle: btw, which 2 spaces? :)
02:31:43 <wagle> I was tail calling from inside a loop instead of outside
02:32:39 <wagle> 100000 iterations of the main loop, 2 iterations of the inner loop, so 200000 calls
02:33:07 <wagle> OOM
02:35:37 <exposure27> dmj`: 1
02:36:21 <jle`> Saizan: monoid instance for functions is cool, thanks for making me aware of it
02:37:03 <ion> Much of what makes Monoid so useful is the Monoid a => Monoid (… a …) instances.
02:38:46 <Cale> exposure27: why are you saying 1 to people?
02:38:50 <Cale> exposure27: are you a bot?
02:39:19 <arkeet> it says it to them after they part
02:39:27 --- mode: ChanServ set +o Cale
02:39:37 <arkeet> I wonder what that's about
02:39:57 <Cale> exposure27: If you're a human with a bad IRC client script or something, message me and I'll unban you.
02:40:01 --- mode: Cale set +b *!*@185.25.84.104
02:40:02 --- kick: exposure27 was kicked by Cale (exposure27)
02:40:09 --- mode: Cale set -o Cale
02:43:48 <linduxed> hey guys i've got a question about how to structure a program
02:44:05 <linduxed> i've got this pile of code
02:44:43 <linduxed> basically it's an application which calculates the optimal moves for a board game
02:44:50 <linduxed> info can be read here https://github.com/linduxed/kalaha-solver
02:44:55 <linduxed> (it's not that long)
02:45:11 <linduxed> i'm currently reimplementing it, since it's sort of ugly and old
02:47:05 <linduxed> i've come to the point that i'm going to reimplement the actual algorithm. previously i did the thing by moving one lap and returning the modified list of pots, how many marbles were left in the hand and an adt defining whether another lap was necessary
02:47:42 <linduxed> that's a lot of stuff and, and it works that way mostly because i didn't know much about various things such as Monoids, Monads and so on
02:48:00 <linduxed> i can't say i know them particularly well now either, but at least i have a general idea about them
02:49:16 <linduxed> so my question is: if you read through the description of the application (and maybe some of the code in kalaha.hs), how do you think it would be best to express the procedure of making one turn?
02:59:25 <FreeFull> Applicative do seems like it'd be really useful for parsers
03:00:13 <arkeet> but you have monadic do for parsers
03:00:29 <skypers> hi
03:00:35 <FreeFull> But monadic parsers aren't necessarily as good as applicative ones
03:00:42 <arkeet> sure
03:00:46 <skypers> is there syntactic sugar to get the current module’s name?
03:03:46 <Ghoul_> skypers: you must use template haskell
03:03:59 <Ghoul_> when your function is compiled to an object, the current module name will always be the same
03:05:39 <FreeFull> Can  (\_ x _ -> String x) <$> char '"' <*> many (noneOf "\"") <*> char '"'   be written as   String <$> char '"' *> many (noneOf "\"") <* char '"'   ?
03:11:08 <skypers> 10:55 < Ghoul_> when your function is compiled to an object, the current module name will always be the same
03:11:11 <skypers> I see
03:11:19 <skypers> I’ll look into template haskell then :)
03:12:17 <dementor> hello
03:12:34 <dementor> I have a qustion:
03:12:42 <dementor> I've got a data: data Relatie a b = Relatie [(a, b)] deriving (Show, Eq)
03:13:02 <dementor> and I want to simulte the Power ( a ^ b)
03:13:12 <dementor> I did this:
03:13:22 <dementor>  class Putere a where 	(^) :: a -> Int -> a
03:13:31 <dementor> instance Putere (Relatie a a) where 	r ^ n = foldl o (Relatie []) $ take n $ repeat r
03:13:42 <dementor> but it gives me an error:
03:13:48 <dementor> Repeated type variable "a" in instance head
03:14:33 <dementor> so the data type is: data Relatie a b = Relatie [(a,b)]
03:14:41 <dementor> and in the instance I can
03:14:50 <FreeFull> In an Applicative, when the order of sequencing matters, do both (*>) and (<*) behave left to right orderwise?
03:15:00 <dementor> can't say instance Putere (Relatie a a)
03:15:39 <skypers> dementor: try with -XFlexibleInstances
03:15:40 <skypers> maybe
03:15:51 <dementor> can i do that with hugs?
03:15:56 <skypers> no idea
03:16:10 <skypers> the thing is, I’m not sure you can do this
03:16:15 <skypers> a ≠ b
03:16:34 <skypers> here you force the constraint to make a = b
03:16:37 <int-e> dementor: you can do  instance (a ~ b) => Putere (Relatie a b)  with enough extensions.
03:17:30 <dementor> so if i do instance (a ~ b) => Putere (Relatie a b) , can i force a to be b, so a = b?
03:17:50 <int-e> a ~ b means that the types are the same
03:18:11 <Cale> dementor: Your code compiles with {-# LANGUAGE FlexibleInstances #-} in GHC
03:18:37 <skypers> yeah, FlexibleInstances might resolve his issue
03:18:51 <int-e> but there's an important difference to  Putere (Relatie a a); the latter would not match  P (R Int Bool). The (a ~ b) => P (R a b) one matches, but then the compiler will complain that Int and Bool are not equal.
03:19:02 <int-e> Cale: wow?
03:19:13 <skypers> (a ~ b) ?
03:19:17 <skypers> what is that?
03:19:27 <Cale> A type equality constraint
03:19:43 <skypers> ok
03:19:44 <skypers> weird
03:19:58 <dementor> with ({-# LANGUAGE FlexibleInstances, OverlappingInstances #-}  it says:
03:20:09 <dementor> *** Expression    : (^)
03:20:12 <Cale> I mean that dementor's original code works
03:20:15 <dementor> ** Expected type : Putere (Relatie a b) => Relatie a b -> Int -> Relatie a b
03:20:19 <dementor>  Inferred type : Putere (Relatie a a) => Relatie a a -> Int -> Relatie a a
03:20:55 <dementor> and the thing is that Relatie a a is correct
03:21:03 <Cale> ghci> :t (Main.^) :: Relatie a a -> Int -> Relatie a a
03:21:03 <Cale> (Main.^) :: Relatie a a -> Int -> Relatie a a
03:21:03 <Cale>   :: Relatie a a -> Int -> Relatie a a
03:21:22 <Cale> stop using hugs?
03:21:29 <dementor> uh... ok :)
03:22:11 <dementor> ill download ghc then :(
03:22:17 <Cale> Hugs hasn't seen a release in over 7 years.
03:23:36 <Cale> (and it was quite a few years before that when it stopped really being comparable to GHC, even)
03:23:59 <dementor> ok
03:24:21 <dementor> does haskell got a minimal package? i'm kinda low on hard drive space :(
03:24:40 <int-e> Cale, thanks, I really expected non-linear instance heads to fail.
03:25:51 <Cale> Well, how low? GHC's probably smaller than one episode of a TV show...
03:28:15 <arkeet> nobody uses hugs anymore
03:28:19 <dementor> ... ghc got ~ 250mb... but i guess that is unpacked... on my lapton Haskell Platform took 1gb of memory
03:28:23 <arkeet> it hasn't been maintained in years
03:28:53 <arkeet> ah, cale said it already.
03:29:23 <dementor> oh... on ghc 7.6.0 of codeforces it says: Couldn't match type `b' with `a'       `b' is a rigid type variable bound by           the instance declaration at program.hs:8:10       `a' is a rigid type variable bound by           the instance declaration at program.hs:8:10
03:29:29 <Cale> I'd expect GHC to install to around 500 MB or something.
03:29:35 <dementor> i didn't give you the definition of o
03:29:44 <dementor> o :: (Eq a, Eq b, Eq c) => Relatie a b -> Relatie b c -> Relatie a c (Relatie r1) `o` (Relatie r2) = Relatie . nub $ [ (a, c) | (a, b1) <- r1, (b2, c) <- r2, b1 == b2 ]
03:29:46 <Cale> dementor: right, I just made  o = undefined
03:30:07 <dementor> (Relatie r1) `o` (Relatie r2) = Relatie . nub $ [ (a, c) | (a, b1) <- r1, (b2, c) <- r2, b1 == b2 ]
03:30:55 <lpaste> Cale pasted “this compiles for me” at http://lpaste.net/94873
03:31:18 <augur_> anyone have any good suggestions on what to read to understand the "spirit" of quickcheck shrink's?
03:31:30 <dementor> its like Function composition on mathematical sets
03:31:42 <Cale> augur_: Are you talking about the particular choices that the library makes, or just the general idea?
03:31:49 <augur_> general
03:32:14 <namor> will a patch which made it into ghc head ~24h ago make it into the next haskell platform?
03:33:02 <Cale> augur_: Well, the idea is just that the shrinks are one-step simplifications that get applied to the first counterexample that QuickCheck finds. It sees whether it can find some shrink which still fails the test, and then shrinks again and again until it can't find a simpler counterexample.
03:33:19 <dementor> ok... ill try compile it on ghc 7.6.3
03:33:20 <augur_> Cale: right but what counts as a sensible sort of simplification?
03:34:12 * wagle wonders how he could make 2000 clones of a mutable 200000 element array without running out of memory yet
03:34:28 <Cale> augur_: Discard half the items, or throw away a single element of your data structure... try applying shrink to individual contained elements, things like that.
03:34:50 <Cale> > shrink [1,2,3,4,5]
03:34:52 <lambdabot>   [[],[3,4,5],[1,2,5],[2,3,4,5],[1,3,4,5],[1,2,4,5],[1,2,3,5],[1,2,3,4],[0,2,...
03:34:55 <Cale> > shrink [1,2,3]
03:34:56 <lambdabot>   [[],[2,3],[1,3],[1,2],[0,2,3],[1,0,3],[1,1,3],[1,2,0],[1,2,2]]
03:35:19 <augur_> Cale: it seems like there's got to be some more things going on tho cause hughes suggests that [1] could shrink to [0]
03:35:22 <augur_> > shrink [1]
03:35:23 <lambdabot>   [[],[0]]
03:35:29 <augur_> yeah, see, why [0]?
03:35:32 <Cale> Yeah, that's the "apply shrink to elements"
03:35:34 <augur_> > shrink [4]
03:35:36 <lambdabot>   [[],[0],[2],[3]]
03:35:39 <Cale> > shrink 4
03:35:41 <lambdabot>   [0,2,3]
03:35:56 <augur_> > shrink 10
03:35:58 <lambdabot>   [0,5,8,9]
03:36:03 <augur_> thats just weird ...
03:36:07 <chrisdone> this is the first time i've ever used ImplicitParams http://www.reddit.com/r/haskell/comments/1pa00v/pattern_for_native_library_initialization/cd0jzzb
03:36:25 <Cale> > shrink (2^16 - 1)
03:36:27 <lambdabot>   [0,32768,49152,57344,61440,63488,64512,65024,65280,65408,65472,65504,65520,...
03:36:38 <namor> > :t shrink
03:36:40 <lambdabot>   <hint>:1:1: parse error on input `:'
03:36:44 <Cale> :t shrink
03:36:45 <lambdabot> Arbitrary a => a -> [a]
03:36:50 <namor> ty Cale :-)
03:38:45 <augur_> i dont get what its doing at all x.x
03:38:58 <augur_> i mean, why its done like that
03:39:43 <Cale> augur_: http://hackage.haskell.org/package/QuickCheck-2.6/docs/src/Test-QuickCheck-Arbitrary.html#shrinkIntegral
03:39:50 <augur_> yeah i saw that
03:39:58 <augur_> the how is fine
03:39:59 <augur_> the why is not
03:40:19 <Cale> There are no specific laws that shrink is required to obey. It's a heuristic.
03:40:24 <namor> augur_, think of it like this: you write a test which should work for ALL lists of ALL integers
03:40:37 <Cale> and keep in mind that shrinking is done *recursively*
03:40:40 <namor> so quickcheck finds a counterexample with SOME list and a BIG interger
03:40:44 <augur_> Cale: yeah but usually heuristics are supposed to make some kind of sense
03:40:53 <namor> so it "shrinks" the example to find another counterexample which is easier
03:40:55 <Cale> So if, for instance, the test still fails when you divide the number by 2
03:41:10 <Cale> then it'll shrink again from there
03:41:57 <Cale> The fact that 0 is there is a shortcut
03:42:06 <namor> most important irc skill: parsing interleaved explanations
03:42:27 <Cale> The rest of the elements are roughly between n/2 and n-1
03:43:18 <Cale> and there will be more attempts if n is large
03:43:38 <Cale> (They're n - n/2^k for various k)
03:45:05 <dementor> cale: thanks, it worked on ghc :)
03:45:11 <Cale> This has a bunch of nice properties. If the property fails for all sufficiently large n, then once it finds an example, it will rapidly converge to the minimum by iterative bisection.
03:46:09 <Cale> dementor: cool :)
03:46:33 <Cale> augur_: do you see how that works?
03:47:51 <Cale> Basically, if the property fails for n, then we're going to try (roughly) n/2. If n/2 still fails, then we're going to retry shrinking from there. Otherwise, we're going to try (roughly) n - n/4 (whi0ch is halfway through the interval on the other side)
03:47:58 <Cale> how'd that 0 get there?
03:48:05 <augur_> Cale: not entirely but i think i get the idea
03:48:35 <wagle> 9923 backtracking pointd, 38G of VM, things are making sense now
03:49:24 <wagle> i think its trying to GC 38G of disk..  8)
03:49:25 <Cale> augur_: well, I said "minimum", but I suppose I should have been more careful.
03:49:27 <int-e> wagle: are those unboxed arrays? in any case, that's 400M elements that have to be stored; for example, with 8 byte ints that makes 3.2GB.
03:49:39 <augur_> Cale: it seems like the idea is to sort of partially order your types with a minimal element
03:49:47 <Cale> augur_: If the property succeeds for all n < k and fails for all n >= k, then it will converge to k rapidly
03:50:04 <augur_> and try to walk down towards the minimum in a smart way
03:50:26 <wagle> int-e: i need to prune the space to do the larger problems..
03:50:26 <Cale> Yeah. It's perfectly acceptable to define shrink x = [] though
03:50:33 <augur_> right
03:50:48 <Cale> (which is actually the default)
03:50:48 <int-e> wagle: unboxed ints. in the boxed case, the figures get worse. (24 bytes per node, and a lot of that will be in the normal heap that you pretty much pay for twice unless you use a compacting gc in the oldest generation)
03:51:01 * hackagebot hi 0.0.6 - Generate scaffold for cabal project  http://hackage.haskell.org/package/hi-0.0.6 (DaisukeFujimura)
03:51:12 <Cale> It's just if you can think of some ways to simplify your data, then that lets you do it.
03:51:48 <augur_> the "obvious", but not so efficient, way is to shrink by just making the minimal change that reduces the size, but a smarter way is to pick a place thats halfway, somehow? and to maybe figure out how to get back up in between if that doesnt cause failure, in a sort of binary search fashion?
03:51:55 <Cale> yeah
03:52:11 <augur_> or something, im not sure quite how that would actually work since shrink is oblivious to re-checking, but
03:52:14 <Cale> Pick something halfway, and then back off until you're removing one thing at a time or something.
03:52:45 <augur_> well thats a sensible thing i think. useless for me, but sensible! :p
03:52:52 <wagle> I'm having trouble pruning the search space, it seems to be ignoring me..  plus I need to sleep, so I'm just thinking about what to try after it maybe solves size 2 of 6 increasing sizes of dataset
03:53:02 <augur_> i was actually looking into this for reasons other than quick check
03:53:25 <augur_> i mean, shrink + the heuristics for designing good shrinks constitutes a kind of epistemic methodology
03:53:34 <Cale> ohgodwhy
03:53:37 <augur_> x3
03:53:58 <augur_> "a technique for finding things out"
03:54:20 <wagle> int-e thanks for pointing out the unbox thing, I had forgotten about that
03:55:00 <namor> Hmm, ghci bug #3333 (ghci doesnt load weak symbols) stops "ghci repl" from loading my project. The project contains an FFI binding to a C wrapper of a C++ library. (C .h file and C++ .cpp file). cabal configure and cabal install work fine, but cabal repl fails due to #3333. Are there any ways to work around this? I would like to use "cabal repl" for emacs interactive mode...
03:55:55 <augur_> Cale: the question i was asking the other day can actually be rephrased as a quickcheck question
03:56:37 <augur_> Cale: basically: what are some good techniques for probing a property   prop :: a -> Bool   to reverse engineer its definition?
03:57:26 <wagle> hey, i got 1G or so of VM back over the past 10 minutes, gc is getting somewhere!
03:58:08 <augur_> and quickcheck's shrink actually sort of is one such technique, in that it produces minimal failure cases that you can use to identify some aspects of the definition
03:58:13 <Cale> augur_: QuickCheck can also be seen as a rephrasing of science. You want to know stuff, so you guess at some property, and then you find out what it entails. If what it entails is wrong, then your guess was wrong.
03:58:32 <augur_> Cale: yes, but scientific methodology in the large tends to be very data-rich
03:59:18 <augur_> take physics: just plotting data on a graph from some simple "obvious" experiments can give you the laws kinematics
04:00:16 <augur_> there's a lot of data to plot, tho. position and time and mass
04:00:36 <Cale> Well, it can give you a guess
04:00:55 <augur_> you have to simplify slightly, ofcourse, but it gives you a lot right off the bat
04:01:06 <Cale> Or strongly suggest something you ought to guess, provided that you notice that the data fits a pattern that you've already seen in mathematics.
04:01:11 <augur_> whereas String -> Bool doesnt give you much at all
04:02:01 <augur_> Cale: the initial guess for the math of kinematics is approximately correct, and there are well understood ways of making it more accurate, and showing that one is an approximation of the other
04:02:13 <augur_> but there's no real generalization of that to pure logic, afaik.
04:02:19 <Cale> Well, "the" initial guess.
04:02:36 <Cale> If you're clever enough to guess correctly.
04:02:37 <augur_> what does it mean for one logical theory (axiom set) to "approximate" another?
04:02:53 <augur_> yeah but guessing correctly for the math of kinematics is almost obvious
04:03:28 <wagle> anyone know how to give a haskell process more than 1G of real memory on a mac?
04:03:43 <Cale> augur_: It's obvious to us now!
04:04:26 <Cale> Hindsight and knowing which experiments to do in order to make things clear makes everything pretty obvious.
04:04:28 <augur_> Cale: eh.. i dont think galileo had much trouble coming up with kinematics
04:04:57 <augur_> knowing the experiments is important, yes. for grammar the experiments are sort of "already done" in that we have only one experiment: judging grammaticality
04:04:58 <Cale> As for ways to compare logical theories, you know about elementary embeddings?
04:05:08 <augur_> so we just pretend we have all the answers to those
04:05:14 <augur_> Cale: no, dunno about elementary embeddings. ref?
04:05:20 <Cale> https://en.wikipedia.org/wiki/Elementary_equivalence
04:06:59 <bennofs> Is there a typeclass with a function of the type (c -> d -> e) -> f c a -> (a -> f d b) -> f e b?
04:07:08 <bennofs> (for some f) ?
04:07:14 <Cale> (You can also get the weaker notion of homomorphisms of structures)
04:07:25 <theorbtwo> augur_: Well, kind of.  One can view all previous sets of grammatical rules as experiments, and as approximations to their descendent, and ancestor, languages.
04:07:28 <augur_> Cale: im not entirely sure i understand whats going on. i'd need to see more examples
04:07:37 <augur_> theorbtwo: yes, thats a reasonable desire to have
04:07:43 <wagle> @hoogle (c -> d -> e) -> f c a -> (a -> f d b) -> f e b
04:07:44 <lambdabot> No results found
04:07:57 <augur_> theorbtwo: except that current grammatical theories are so big and baroque that noone really knows how to relate them at all
04:08:28 <augur_> theorbtwo: at best you get toy fragments that are effectively useless for real theoretical purposes
04:08:47 <Cale> bennofs: I'm going to go out on a limb here and guess that there isn't :)
04:09:08 <theorbtwo> augur_: Ah, talking at slight cross-purposes.  You mean how we theorize about grammar, I was talking about the grammar of an actual human language.
04:09:43 <theorbtwo> If you want to be anglocentric about it, world history is a simulated annealing toward English.
04:09:49 <augur_> theorbtwo: ah yes, within framework obviously we can do what you suggest, at least for the well-specific frameworks. we just find some translation or entailment
04:10:06 <theorbtwo> To be less anglocentric, toward a universal language.
04:10:15 <augur_> but if you want to know what the right framework is (modulo equivalence) its harder.
04:10:43 <dementor> is there a way i can override the normal implementation of ^ (as in 2 ^ 5 = 32) to do the same thing when applied to numbers, but to do other things when applied to other data made by me? (I'd like not to hide the Prelude function in case I would still want to use that 1 too)
04:11:28 <augur_> theorbtwo: in a sense, it becomes nicer to talk about properties of the language itself, not the grammar formalisms in question, but i dont know of any well-studied empirical techniques for probing languages in absence of formalisms
04:11:45 <FreeFull> What's a better way of writing this? escape = toChar <$> (choice $ fmap (try . string) ["\\\"", "\\\\", "\\n", "\\t", "\\r"]) where
04:12:13 <FreeFull> toChar just converts the corresponding strings to chars
04:12:27 <Cale> alt.presumptuous.people.talk.speak.suppose alt.rigorous.grammar.is.exists.requires alt.questionable.supposition.think.regard.consider
04:13:14 <augur_> lolwut
04:13:44 <theorbtwo> I'm not sure there *is* a human-language grammar that is not the same modulo equivalence.  Are there things expressable in English, but not Minoan, or vice-versa, other then a potential lack of vocabulary?
04:14:11 <augur_> theorbtwo: no no, you're thinking too language specific
04:14:15 <theorbtwo> (IMHO, that last bit makes it something other then first-year philosophic navel-gazing.)
04:14:24 <augur_> theorbtwo: i mean more, "do we need CFGs or CSGs" kind of questions
04:14:35 <theorbtwo> Ah.
04:15:12 <augur_> you have a whole class of languages that are capturable by a class of equivalent classes of grammars
04:15:30 <augur_> CFLs are captured by { G : G ~ CFG }
04:16:10 <Cale> Any model we construct for human language will probably only capture some fragment of what is comprehensible to other speakers of that language, and it will also probably admit many constructions which are incomprehensible. It's like a type system. Type systems are still useful, but they don't guarantee everything.
04:16:17 <augur_> but how do you define CFLs without reference to CFGs? and more importantly, given a language L, how do you probe its properties without depending on a particular class of grammars G?
04:16:42 <augur_> Cale: no, they dont, so its nice to have other techniques!
04:16:51 <augur_> hence my quest(ions)!
04:19:48 <Cale> Asking about which sorts of grammar you require is kind of meaningless in that light, I think. You can use whatever tools you have at hand, and if what you construct is somehow useful, then that's good. If the best context free model and the best context sensitive model got into an arm-wrestling match, who would win? Does it matter?
04:20:13 <Cale> (probably this should be in -blah)
04:21:02 * hackagebot language-puppet 0.10.0 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.10.0 (SimonMarechal)
04:21:04 * hackagebot crf-chain1-constrained 0.3.0 - First-order, constrained, linear-chain conditional random fields  http://hackage.haskell.org/package/crf-chain1-constrained-0.3.0 (JakubWaszczuk)
04:21:06 * hackagebot concraft 0.8.0 - Morphological disambiguation based on constrained CRFs  http://hackage.haskell.org/package/concraft-0.8.0 (JakubWaszczuk)
04:21:29 <Cale> FreeFull: well, it might be worth noting that:
04:21:33 <Cale> > show "\n"
04:21:34 <lambdabot>   "\"\\n\""
04:21:41 <Cale> well...
04:21:45 <Cale> that's not terribly useful
04:26:02 * hackagebot concraft-pl 0.3.0 - Morphological tagger for Polish  http://hackage.haskell.org/package/concraft-pl-0.3.0 (JakubWaszczuk)
04:26:08 <EarlGray> Hello all
04:27:25 <EarlGray> I have a little project which has a parser written in Parsec and the latter must transfer its results with SourcePos to other modules (which I don't want to know anything Parsec)
04:28:04 <EarlGray> So I've written my own SourcePos common for all my modules and identical to Parsec one
04:28:31 <EarlGray> but now I'm stuck with converting Text.Parsec.Pos.SourcePos into my SourcePos
04:28:58 <EarlGray> toHasmPos :: PPos.SourcePos -> SourcePos
04:29:17 <EarlGray> with import qualified Text.Parsec.Pos as PPos does not seem to work
04:31:37 <EarlGray> ah, it seems like the culprit is `import Text.Parsec hiding SourcePos`
04:33:00 <EarlGray> no, it still does not compile: Not in scope: data constructor `PPos.SourcePos'
04:36:54 <linduxed> hey guys, i posted a question a bit earlier here, but it was quite long so i wrote a SO-question instead:
04:36:56 <linduxed> http://stackoverflow.com/questions/19617427/what-structure-should-i-use-to-express-a-turn-in-a-board-game
04:37:18 <linduxed> I'd be grateful if someone could help me out, or just give some ideas
04:44:01 <EarlGray> aha, `data SourcePos` is an abstract data type, which does not have its guts exported from `Text.Parsec.Pos`, so I have to use `sourceName/sourceLine` accessors istead.
04:53:08 <Flonk> I'm reading this post on cat theory, and they define a Category like
04:53:09 <Flonk> class Category (~>) where
04:53:37 <Flonk> However, this doesn't compile, because instead of using a normal type variable like a it's using an operator symbol
04:53:53 <Flonk> Can I enable this as a language extension or something?
04:58:26 <Pranz> if (~>) is a defined data type of kind * -> * -> * you can make a category out of it
04:59:18 <Pranz> Flonk, so you need to do something like
04:59:20 <Flonk> so data a ~> b = Cat a b and it should work?
04:59:48 <Pranz> data (~>) a b = a ~> b
04:59:59 <Pranz> or maybe you can't do it infix like that
05:00:09 <Flonk> Pranz: Okay, I see
05:00:12 <Flonk> Thanks!
05:08:26 <donri> Pranz: that won't work
05:08:37 <donri> Flonk: you can with TypeOperators and older ghc
05:08:53 <Pranz> ah
05:09:10 <donri> Flonk: they changed it in 7.6 though so now type operators are considered capitalized
05:09:43 <donri> Flonk: meaning you can use it for types but not type variables
05:10:17 <Flonk> donri: ah
05:10:19 <donri> Pranz: you can't use an operator for a data constructor (term-level), it would be ambiguous
05:10:24 <Flonk> Better resort to just using a letter then
05:11:11 <donri> Pranz: you can use ~> for the type with TypeOperators (with ghc 7.6) but for the term you need to start with an upper case letter or the colon
05:24:37 <absence> cabal rebuilds a dependency for every build because it incorrectly believes a source file "has a modification time that is in the future". is there a workaround for the problem?
05:27:52 <donri> absence: random shot in the dark: are you mounting with noatime or something?
05:33:27 <absence> donri: no, i'm on windows
05:34:02 <donri> absence: anyway #hackage can be better for cabal issues
05:35:49 <absence> donri: i'll try there, thanks
05:42:04 <alexander__b> I just got a patch where this is done: http://lpaste.net/6719154010181337088 -- this strikes me as rather ugly and not intuitive to read. does anyone have any suggestions for a rewrite?
05:42:08 <skypers> hey
05:42:42 <skypers> why do peoply use exceptions in Haskell? I mean, EitherT is quite nice for such errors, isnt’it?
05:42:46 <skypers> isn’t*
05:43:26 <donri> alexander__b: isn't that "maybe" isomorphic to "fmap (,v)" ?
05:43:47 <hpc> skypers: it's easier to deal with exceptions when you know they're going to just kill the program
05:43:53 <hpc> (syntactically)
05:44:25 <hpc> skypers: see, file IO, network IO, many other things that you end up doing fairly regularly without caring what happens when they fail
05:59:00 <Cale> skypers: IO's exception system is also remarkably nice
06:00:44 <Cale> skypers: You can define new types of exception which act as supersets of a bunch of existing types (i.e. trying to catch one will catch any of some set of exceptions), as well as make arbitrary refinements of existing exception types (i.e. trying to catch one will catch some type of exception only if it has some particular value, or its value satisfies some conditions)
06:02:20 <Cale> But our culture is all about being picky about not letting errors through, we tend to just produce results which are sum types (i.e. use Maybe or Either, not even EitherT), and force the errors to be handled immediately.
06:03:22 <Cale> Still, it's a very nice extensible exception system that IO has, and whenever I have a chance to use it effectively, I don't avoid it.
06:05:29 <t4nk569> Have a function that encodes an alphabetic char to another using fixed mapping. it uses a new datatype ive created. wondering how i can get it to return a Char instead of [Char]?
06:06:18 <Cale> t4nk569: hm, don't produce a list in the first place?
06:06:31 <t4nk569> not sure i have any alternatives
06:06:45 <Rembane> t4nk569: head?
06:07:13 <t4nk569> Rembane: not sure that is useful with this particular problem
06:07:43 <Cale> t4nk569: I think you're going to have to be a bit clearer about the situation you're in :)
06:08:51 <t4nk569> okay so i've created a new type which essentially is a list of tuples where first element is a letter of alphabet in order and 2nd is another letter which it is to be mapped to
06:09:23 <t4nk569> my encode function is supposed to take a char and return its substituted char i.e 2nd element in same tuple
06:09:40 <t4nk569> but unable to get it to return a Char instead of [Char]
06:09:55 <Rembane> t4nk569: Can we see some code?
06:10:01 <arkeet> what if the char you put in isn't in the list?
06:10:19 <arkeet> (you might also consider using Data.Map)
06:10:30 <arkeet> :t lookup
06:10:31 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
06:10:36 <arkeet> :t M.lookup
06:10:37 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
06:11:10 <arkeet> (M is Data.Map)
06:11:21 <t4nk569> type Cipher = [(Char,Char)]     cipher :: Cipher     cipher = zip ['A'..'Z'] "BVNMCXDSAZQWEFRTGYHUJIKOLP"
06:11:48 <t4nk569> then I have my encode function which is just a list comprehension
06:12:08 <t4nk569> given a char, returns the encoded char
06:12:30 <FireFly> Why a list comprehension, if you don't want it to return a list?
06:12:33 <arkeet> ok, so think about what your function would do if I gave it something not in your list, say '$'
06:12:50 <t4nk569> I need to work on that later arkeet
06:12:56 <arkeet> this is related!
06:13:19 <t4nk569> not created any error handling for that yet
06:15:02 <t4nk569> so i shouldn't be using a list comprehension
06:16:49 <t4nk569> FireFly: What would be a better way of writing it?
06:18:30 <FireFly> Think of how you could express `encode` recursively
06:19:22 <t4nk569> will need to do that for my encodeMessage function but encode just takes a single char
06:20:08 <FireFly> Yes, I mean for encode (which takes just a char)
06:20:16 <FireFly> You want encode :: Char -> Char, right?
06:20:34 <t4nk569> Well it takes the cipher as a parameter too
06:20:39 <t4nk569> so Char -> Cipher -> Char
06:20:56 <FireFly> All right, yes
06:21:14 <t4nk569> but at the minute I have it as returning [Char] which is no good
06:21:26 <Narvius> Uhm
06:21:32 <Narvius> I haven't been following from the beginning
06:21:46 <Narvius> But wouldn't encode :: Cipher -> Char -> Char and using map the best solution?
06:22:16 <FireFly> Think of what you'd do if the char to encode is the first character of Cipher, and what you'd do if it isn't the first character of Cipher
06:22:59 <t4nk569> Not able to use map, Narvius
06:23:09 <t4nk569> Don't think so anyway. Only have data.list imported
06:23:34 <FireFly> (I guess this is what I get for answering questions in channels about things I don't know as much about as I ought to)
06:24:24 <t4nk569> FireFly: If it were first then it'd be encoded, if not then traverse through the list and extract it and encode it?
06:24:33 <t4nk569> not sure I understand you
06:25:07 <Narvius> `map' is defined per default.
06:25:13 <FreeFull> t4nk569: encode :: Cipher -> Char -> Char is basically the lookup function with a default case
06:25:28 <t4nk569> right
06:25:37 <mux> this type signature makes it impossible to use a block cipher
06:26:09 * hackagebot sqlite-simple 0.4.3.1 - Mid-Level SQLite client library  http://hackage.haskell.org/package/sqlite-simple-0.4.3.1 (JanneHellsten)
06:26:31 <FreeFull> t4nk569: You can use either recursion to traverse the Cipher, or use the lookup and maybe functions
06:26:34 <FireFly> t4nk569: in the first case, you have the character to return already (in the first tuple in your cipher list). In the second case, well, you ought to be able to call `encode` itself recursively on the rest of the list, no?
06:27:06 <FireFly> Assuming the rest of the list isn't empty (but what does it mean if it is? I'll leave that for you :P)
06:27:28 <t4nk569> I see. Cheers, I'll work on that
06:32:02 <augustss> howdy
06:32:51 <chrisdone> ahoy
06:33:28 <augustss> Ahoy will be my shout for the next two weeks, since I'll be on a boat.
06:33:45 <chrisdone> haha. hurrah!
06:35:11 <yoeight> Hi folks ! Does anyone already get a compilation break just by enabling GADTs extension ?
06:36:44 <augustss> Does enabling GADTs turn off local generalisation?  I think it did for a while.
06:39:21 <yoeight> I put on on gist the code triggering that behavior
06:40:38 <yoeight> I can't reduce it more as I don't understand that behavior
06:41:07 <yoeight> here it is: https://gist.github.com/YoEight/7181580
06:41:53 <yoeight> Can it be considered as a bug or a wanted feature ?
06:43:59 <augustss> Try putting type signatures on yielding and awaiting.
06:44:39 <alexander__b> I'm writing a report on haskell, and I want to explain how it being purely functional means that there is no side-effects (and in turn there can be no state), however this is of course not strictly true in practice as you can have both using impure functions and monads and stuff. can anyone help me write this in a way that is understandable but also uses terminology correctly?
06:44:40 <chrisdone> (), {}, "", [], are delimeters that when deleting one or the other, the whole expression is invalid, in haskell
06:44:41 <chrisdone> am i missing any?
06:45:13 <danharaj> {-
06:45:34 <danharaj> [| |]
06:45:38 <chrisdone> hmm, right. comments. good one
06:45:53 <chrisdone> yep, [| |]
06:46:00 <augustss> chrisdone: single quote?
06:46:00 <danharaj> and if we want to be pedantic {-# :P
06:46:16 <chrisdone> single quote, of course
06:46:22 <chrisdone> thanks
06:46:36 <danharaj> maybe there are some unicode ones?
06:47:19 <donri> doesn't look like it http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#unicode-syntax
06:47:20 <geekosaur> for that matter, -- newline
06:47:27 <donri> (# unboxed tuples? #)
06:47:32 <augustss> alexander__b: State isn't banned in Haskell, but it has to be explicit.  The types will show that you're passing state around, either explicitely, or by a monad type.
06:47:33 <chrisdone> i'm working on a paredit-y mode for haskell. so any delimiters i want backspace to glide over, rather than delete, when hitting backspace
06:48:03 <chrisdone> donri: oh, good one
06:48:24 <alexander__b> augustss: so I can say something like that in practice there is state, but it is in an explicitly impure context?
06:48:33 <chrisdone> danharaj: actually i think {-#  #-} is treated as a proper syntactical element, at least in HSE
06:48:39 <chrisdone> danharaj: so that's a good one
06:48:42 <augustss> chrisdone: [| |]
06:48:44 <danharaj> hm
06:49:09 <danharaj> there are also the variations on [| |] for the quasiquoters and stuff
06:49:20 <danharaj> e.g. [d|
06:49:39 <donri> beware that single quotes are tricky though :P
06:49:53 <donri> 'a' is the Name quoted a' identifier right? right?!
06:50:01 <augustss> alexander__b: There are many ways to put it.  When I explain to non-FP people I like to say that you can do anything in Haskell that you can do in other languages, it's just that it will show up in the type if you've used some effects.
06:50:08 <chrisdone> donri: oh god =)
06:50:11 <geekosaur> ''Foo in TH
06:50:36 <donri> 'Foo is the Name quoted promoted data kind uh, wait, whaaat
06:51:08 <augustss> Single quote might be too hard to do right. :)
06:51:31 <donri> chrisdone: also TH $(), duno if you consider these part of ()
06:51:33 <augustss> It's quite overloaded.
06:51:45 <danharaj> single quotes can only be delimeters for single characters right?
06:51:56 <donri> chrisdone: if it's using HSE it's probably separate. similarly tuples are probably not same as () etc
06:52:27 <chrisdone> danharaj: afaik, yes
06:52:49 <donri> danharaj: yes. but knowing when that is the case almost requires a full parser :P
06:52:52 <chrisdone> donri: sure, () is a Unit SpecialCon, (x,y) is a tuple, (x,) a section, etc. in HSE
06:53:54 <donri> well ok it's not *that* hard in this particular case
06:53:55 <chrisdone> technically i have a full parser, so i can handle ' correctly, it's just preferable to get away with a more general solution, but i can special-case it
06:54:47 <donri> chrisdone: on the other hand if you have a full parser, you have to remember to consider every variation as a separate entity. for example, tuple sections
06:56:05 <Hexagenic> Hi, I'm trying to build a "hello world" tcp server, but get "could not find module 'System'". I've installed latest ghc from the arch repos.
06:56:06 <chrisdone> donri: they are. i'm passing the buffer contents to HSE, and returning a list of source spans each of which is tagged with the constructor that HSE used
06:56:20 <chrisdone> donri: (and HSE distinguishes these)
06:56:42 <donri> chrisdone: yeah. i mean *you* have to remember to cover not just the Tuple tag but TupleSection too, etc.
06:56:51 <geekosaur> Hexagenic, you're working from ancient code
06:57:08 <Hexagenic> Ah, yes this article is from 2011 :P
06:57:11 <donri> chrisdone: and there's probably a myriad of corner cases here :) package imports anyone? i bet [x..y] is a separate entity in HSE from list literals?
06:57:12 <chrisdone> donri: i don't -- i'm using Data.Data to generically handle all cases
06:57:13 <geekosaur> you can either force the compiler to run in ancient mode (-XHaskell98) or you can upgrade to newer articles
06:57:21 <Hexagenic> Alright, I'll look for a more recent example.
06:57:25 <geekosaur> and an article from 2011 should not have been using haskell98
06:57:28 <donri> chrisdone: hm but you need to know which are "delimited"?
06:57:36 <donri> isn't that the point of this whole discussion? :)
06:57:44 <geekosaur> since haskell2010 had been out for a year by then :p
06:58:00 <chrisdone> donri: i do because it's an optimization, rather than consulting the parser i want to not bother
06:58:10 <donri> chrisdone: ah
06:58:47 <geekosaur> anyway if you pastebin your code we can help you modernize it
06:58:48 <geekosaur> @lpaste
06:58:49 <lambdabot> Haskell pastebin: http://lpaste.net/
06:59:00 <donri> chrisdone: in that case have fun dealing with things like, [someQQ| hey is (this delimited?) |]
06:59:33 <Hexagenic> geekosaur, this was the code I was working from: http://www.catonmat.net/blog/simple-haskell-tcp-server/
06:59:42 <donri> chrisdone: oh yeah btw (| |) is used by -XArrows
06:59:43 <geekosaur> (I should note that while the current standard was adopted in 2010, hierarchical modules were in use in 2006 when I got started in Haskell. flat modiules like System were just getting too unwieldy)
06:59:44 <chrisdone> donri: you mean anything that HSE can't parse?
06:59:51 <Hexagenic> But seems like Real world haskell has a more up to date example of a tcp server.
07:00:17 <donri> chrisdone: i mean knowing that's a QQ without HSE. or maybe you already know such things, duno how you're doing it exactly :)
07:00:33 <geekosaur> oh, it uses both forms. the `import System (getArgs)` should be `import System.Environment (getArgs)`
07:01:14 <linduxed> hey guys, requesting help again with this topic http://stackoverflow.com/questions/19617427/what-structure-should-i-use-to-express-a-turn-in-a-board-game
07:01:15 <geekosaur> I think that's all you need
07:01:22 <chrisdone> donri: yeah, i already know it's a QQ. i suppose i can already tell for the single quote case, too. it's just the fewer cases i have to special case on is a bonus =)
07:01:37 <linduxed> i just need some general direction for what to look at so i can get going
07:01:47 <linduxed> or specifics, either one
07:04:12 <geekosaur> Hexagenic, unforutnately I see the next installment is exception handling, if that's still haskell98 there will be more issues coming your way...
07:04:19 <skypers> is there a WriterState monad?
07:04:25 <skypers> (I don’t need the Reader)
07:04:32 <skypers> WS?
07:04:57 <Hexagenic> geekosaur, yeah, I'll work with real world haskells tcp example instead :)
07:05:08 <geekosaur> (and RWH was released shortly before the new extensible extensions stuff was proposed, so it's outdated in that regard. I don't know if / when an update is planned)
07:05:19 <Hexagenic> oh
07:05:27 <geekosaur> sometimes the haskell ecosystem changes rather quickly
07:06:14 <skypers> geekosaur: which extensible extensions?
07:06:23 <Hexagenic> Hm, so where can I find a good example of a tcp server?
07:07:02 <Hodapp> geekosaur: what kind of extensible extensions stuff are you talking about?
07:07:11 <geekosaur> dammit
07:07:14 <geekosaur> extensible exceptions
07:07:23 <geekosaur> I knew I should have made coffee first :p
07:07:37 <chrisdone> exceptional extensions
07:08:18 <dv-_> is there a more general lift than liftIO?
07:08:27 <skypers> lift
07:08:31 <skypers> for one-level lift
07:08:42 <skypers> :t lift
07:08:44 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
07:10:15 <skypers> I wannna stack WriterT and StateT over IO
07:10:18 <skypers> how could I do that?
07:10:20 <dv-_> hm that doesn't work
07:10:36 <chrisdone> donri: also there's generally the problem of auto-inserting closing delimiters. it's not the end of the world if you get a parse error, but it's about reducing them from 'often' to 'rare'
07:11:55 <skypers> maybe I can just use RWS without the Reader part
07:11:58 <skypers> but it sounds wrong
07:12:36 <chrisdone> donri: let's G+!
07:13:33 <yoeight> what about WS w s a = forall e. RWS e w s a ?
07:14:41 <skypers> yoeight: e?
07:15:21 <yoeight> or newtype WS w s a = WS { unWS :: forall e. RWSe w s a } deriving (Monad, MonadWriter, MonadState)
07:15:56 <yoeight> skypers: the part on Reader you don't want to care
07:16:01 <skypers> yoeight: isn’t it a waste of space here?
07:16:14 <skypers> I mean, using RWS
07:16:55 <yoeight> what do you mean by waste of space ?
07:16:56 <geekosaur> no? just use () as the e and ignore it
07:17:05 <yoeight> exactly
07:17:17 <skypers> I want something like
07:17:36 <skypers> type WST w s m a = RWST () w s m a
07:17:39 <skypers> is this ok?
07:17:49 <MattY> do you write unit tests for your personal projects? it seems that there's a lot less need for it in haskell than in some other languages
07:18:32 <srhb> chrisdone: I have a question regarding haskell-mode, if you don't mind. Would it be possible to make it so that you could have a certain function load the buffer via either cabal repl or ghci depending on whether there's a sandbox directory present or not?
07:18:43 <yoeight> newtype WS w s a = WS { unWS :: forall e. RWSe w s a } deriving (Monad, MonadWriter, MonadState) seems to be what you want
07:19:32 <skypers> woh
07:19:37 <yoeight> runWS :: WS w s a -> s -> (w, s)
07:19:52 <skypers> I didn’t know it was possible to use MonadWriter and so on in deriving
07:19:54 <skypers> huh yoeight no
07:20:18 <skypers> I want runWS :: WS w s a -> s -> (s,w,a)
07:20:26 <chrisdone> srhb: sure that's easy
07:20:32 <yoeight> runWS (WS inner) s = runRWS() s inner
07:20:41 <srhb> chrisdone: If you say so... :D
07:20:57 <chrisdone> srhb: are you using interactive-mode or inf-haskell?
07:21:01 <yoeight> yep you fix my type signature
07:21:12 <chrisdone> yoeight: you sunk my battleship
07:21:14 <srhb> chrisdone: I am trying to switch to interactive-mode so I think I'd prefer to use that :)
07:21:23 <chrisdone> srhb: "trying" to?
07:21:43 <srhb> chrisdone: I'm a bit confused by how it works with "projects" and such, that's all.
07:22:15 <chrisdone> srhb: what's confusing about it?
07:22:57 <srhb> chrisdone: Well right now what confused me is that if I try to load a file with it and there's no sandbox, it will keep saying over and over that the haskell process has crashed. I assume that's because there is no sandbox though.
07:23:43 <skypers> 15:10 < yoeight> newtype WS w s a = WS { unWS :: forall e. RWS e w s a } deriving (Monad, MonadWriter, MonadState) seems to be what you want
07:23:46 <skypers> with that
07:23:55 <skypers> if I do a unWS ws
07:24:00 <skypers> I get a RWS
07:24:09 <skypers> then I need to do a runRWS
07:24:10 <skypers> right?
07:24:40 <skypers> what if I want the result of runRWS immediately?
07:24:58 <hamster007> howdy
07:25:04 <chrisdone> srhb: what does it say in the *haskell-process-log* buffer?
07:25:14 <nbouscal> I'm noticing the lack of an unlessM function, is there a good way to do the same thing that I'm missing?
07:25:37 <yoeight> skypers: runWS (WS inner) s = runRWS() s inner
07:25:52 <srhb> chrisdone: There's no such thing. Again I think it's because it's trying to cabal repl and there's no sandbox (or cabal project) for that file.
07:25:57 <chrisdone> srhb: actually i think that log is disabled now (thanks hvr), so you have to enable it with the haskell-process-log customization
07:26:00 <srhb> chrisdone: It's just a standalone .hs-file
07:26:03 <chrisdone> srhb: (setq haskell-process-log t)
07:26:06 <srhb> chrisdone: Alright
07:26:16 <yoeight> skypers: correction runWS (WS inner) s = runRWSinner () s
07:26:25 <chrisdone> srhb: then try restarting the process and see what the output is in that buffer
07:26:31 <skypers> quite confusing for me
07:26:34 <hamster007> I am a haskeller who has a job doing scala and im freeking out because I need to do error handling using either and the scala either is not a real monad so theres problems. does anyone know the right thing to do
07:26:57 <chrisdone> hamster007: freeking out is the right thing to do =p
07:27:10 <srhb> chrisdone: Yes, it is trying to start cabal repl and failing, as expected.
07:27:24 <yoeight> hamster007 make yourself a fever and use scalaz.\/ instead
07:27:53 <skypers> I’ll first run into a type
07:27:55 <skypers> not a newtype
07:27:59 <yoeight> oups meant favour :)
07:28:05 <chrisdone> srhb: cool. i haven't pulled recently. maybe someone added cabal repl support
07:28:07 <pantsman> does anybody know the reason why some packages (e.g. contravariant) are listed on hoogle, but none of the functions therein are findable?
07:28:07 * chrisdone pulls
07:29:06 <srhb> chrisdone: I think that is the case. Do you think it would be possible to support both standalone .hs files as well as cabal project (sandboxed) files?
07:29:33 <srhb> chrisdone: Or is that beyond the scope of the interactive mode?
07:30:28 <chrisdone> srhb: well, a session of some kind is a requirement, but not the repl stuff, plain old ghci is an option
07:30:42 <chrisdone> srhb: what does M-x describe-variable haskell-process-type say?
07:30:47 <hamster007> yoeight: is there a code example of using scalaz to do Either-style error handling? The code base I'm working in has staircasing that would make any of you guys puke your guts out.
07:31:29 <srhb> chrisdone: cabal-repl
07:31:50 <srhb> chrisdone: So I suppose I need to make some sort of wrapper that looks for a cabal sandbox and uses ghci if it does not find one?
07:31:52 <chrisdone> srhb: right, so that's why it's trying to use cabal repl
07:32:01 <chrisdone> yeah… perhaps
07:32:15 <hamster007> yoeight: I am thinking of turning to booze
07:32:39 <chrisdone> srhb: maybe it could be patched to prompt for the kind of process whenever it launches a new one
07:32:42 <yoeight> hamster007: like scala.Either except that Left == -\/ and Right == \/-
07:32:46 <chrisdone> srhb: so… in…
07:33:08 <hamster007> uhm really?
07:33:09 <yoeight> hamster007: and a proper monad instance
07:33:16 <yoeight> yes sir
07:33:28 <chrisdone> srhb: in haskell-process-start in haskell-process.el, maybe put something like
07:34:02 <hamster007> And I can use if guards with it?
07:34:30 <adas> In a state, you can access and set the state using 'get' and 'set' respectively. What about the intermediate value 'a'? How do I get and set it?
07:34:47 <yoeight> hamster007: Have a look here https://github.com/scalaz/scalaz/blob/scalaz-seven/core/src/main/scala/scalaz/Either.scala
07:34:55 <hamster007> is there a name for those operators that I could use in google search because -\/ aint gonna cut it
07:35:13 <chrisdone> srhb: try putting this just after the haskell-session-pwd line:
07:35:14 <chrisdone> (setq haskell-process-type
07:35:14 <chrisdone>             (if (y-or-n-p (format "Use process type %S?" haskell-process-type))
07:35:14 <chrisdone>                 haskell-process-type
07:35:17 <chrisdone>               'ghci))
07:35:33 <hamster007> freeking awesome dude
07:35:46 <chrisdone> srhb: run C-M-x to update the whole function, and then try restarting your process again
07:36:01 * chrisdone eats some sushi ^_^
07:36:08 <yoeight> hamster007: you can still use \/.left or \/.right
07:36:18 <srhb> chrisdone: I will try that, thanks!
07:36:43 <MattY> > concatMap show [1..10]
07:36:44 <lambdabot>   "12345678910"
07:36:53 <chrisdone> > [1..10] >>= show
07:36:55 <lambdabot>   "12345678910"
07:37:06 <MattY> huh wat
07:37:09 <hamster007> right biased the way god intended
07:37:16 * chrisdone laughs evily
07:37:38 <yoeight> hamster007: -\/ and \/- are data type contructors
07:37:56 <yoeight> hamter007: and yes it's right biased
07:38:10 <hamster007> yoeight: you helped a tortured soul turn back from the path to booze
07:38:23 <yoeight> :-)
07:39:24 <yoeight> hamster007: there are also Foldable and Traverse instance unlike Haskell. What a shame !
07:39:34 <MattY> how does [1..10] >>= show work?
07:39:34 <adas> In a state, you can access and set the state using 'get' and 'put' respectively. What about the intermediate value 'a'? How do I get and set it?
07:39:39 <hamster007> does it have a handy way to convert back to the regular Either, because that is the standard in our code base
07:39:47 <yoeight> yep
07:39:48 <Redz> what was the name of the function, who do this: f x _ = x  ?
07:39:52 <chrisdone> const
07:40:00 <chrisdone> @src const
07:40:00 <lambdabot> const x _ = x
07:40:13 <yoeight> hamster007 :: \/ has toEither
07:40:17 <Redz> thanks. :)
07:40:21 <nbouscal> MattY: think of the list monad as nondeterminism and it might make more sense
07:40:33 <nbouscal> MattY: or it might make less :)
07:40:38 <frx> Redz hoogle is useful for this
07:40:41 <frx> @hoogle a -> b -> a
07:40:42 <lambdabot> Prelude const :: a -> b -> a
07:40:42 <lambdabot> Data.Function const :: a -> b -> a
07:40:42 <lambdabot> Prelude seq :: a -> b -> b
07:41:04 <frx> http://www.haskell.org/hoogle/?hoogle=a+-%3E+b+-%3E+a
07:41:19 <yoeight> hamster007: and also fromEither
07:42:08 <Redz> i tried hoogle, but i used a wrong discription. ^^
07:42:26 <hamster007> awesome dude... my regular handle is fragamus... im at a girl's house and i had to log in using web because i don't have admin priv to install irc here
07:43:12 <chrisdone> installing irc can be dangerous
07:43:21 <chrisdone> never install irc in a girl's house
07:43:51 <hamster007> lol
07:43:58 <sipa> yes, there's a reason the word 'girl' ends in 'IRL'
07:43:58 <sipa> it's not a girc
07:44:06 <MattY> she did not give you her admin password?
07:44:13 <hamster007> no
07:44:18 <hamster007> she's a slut
07:44:21 <sipa> smart girl
07:44:24 <sipa> oh.
07:45:48 <chrisdone> hamster007: alright, let's keep it on good taste
07:49:04 <MattY> do you write unit tests for your personal projects in haskell?
07:49:23 <srhb> MattY: I just quickcheck things.
07:50:37 <Rembane> MattY: QuickCheck rocks. Use it. :)
07:51:01 <MattY> first time i hear about it. it seems to sort of be a more automated version of unit tests?
07:51:16 <srhb> MattY: You're testing invariants rather than specific parameters/return values
07:51:31 <srhb> Eck, return values sounds iffy in this context.
07:52:08 <nbouscal> Testing properties rather than instances of those properties
07:52:11 <srhb> I am sure there are cases to be made for unit testing, but so far quickcheck has been more than sufficient for me (and has probably caught a few cases I hadn't thought of had I just written unit tests)
07:52:29 <MattY> sounds very interesting, i will try it
07:52:49 <enthropy> your problem becomes specifying a good Arbitrary instance instead of picking parameters
07:53:25 <MattY> the end result in practice is a lot less code for testing?
07:53:34 <srhb> Yes.
07:53:51 <benmachine> srhb: the main use for unit testing that QC doesn't cover is IO
07:53:58 <benmachine> and similar such things
07:54:03 <srhb> benmachine: I could imagine that would be the case.
07:54:17 <jmcarthur> MattY: less code and more exhaustive tests, too
07:54:24 <MattY> nice
07:54:40 <jmcarthur> or at least more likely to find a corner case you didn't think of
07:55:20 <srhb> It would be nice to see an example of a quickchecked property that is insufficient where unit tests would have caught it, in pure code. Can anyone think one up?
07:55:28 <srhb> (I guess that means having a BAD Arbitrary instance)
07:55:41 <enthropy> srhb: lets say you have an interpreter you want to test
07:55:59 <benmachine> you can test booleans with QC, so any pure unit test can kinda be done that way
07:56:03 <enthropy> how do you write   instance Arbitrary ValidProgramAndResultValue
07:56:39 <srhb> enthropy: Right. :)
07:56:59 <pyr> hi haskellers
07:57:01 <benmachine> but using QC to check booleans is a bit pointles
07:57:11 <pyr> I've got a the first part of my FFI project down
07:57:22 <enthropy> maybe you can generate an arbitrary AST, then generate the result by calling some other implementation
07:57:34 <pyr> I'm writing a pure function that given a list of things will execute an ast and return a modified (longer or shorter) list of things
07:57:55 <pyr> I'm able to input the list correctly with help from hsc2hs and peekArray
07:57:58 <enthropy> but chances are that many valid ASTs are not valid programs (say referencing variables that aren't in scope)
07:58:04 <srhb> enthropy: Yeah.
07:58:08 <srhb> enthropy: I see the problem.
07:58:35 <benmachine> enthropy: that's a surmountable problem, actually
07:58:36 <pyr> I'm getting a bit stuck when think about ways to return the output list to C
07:58:38 <khyperia> I just came in here, but what about valid semantic tree?
07:58:53 <pyr> s,think,thinking
07:58:54 <srhb> benmachine: Oh?
07:59:32 <benmachine> well, at least insofar as I once wrote a thing for testing my lambda calculus interpreter
07:59:43 <benmachine> that had a QC thing that generated closed terms only
07:59:52 <srhb> benmachine: That's pretty nifty.
08:00:10 <MattY> is there something intrinsic in haskell (type system, etc)  that makes QuickCheck possible? or could it be done in other languages, including dynamically typed ones?
08:00:17 <benmachine> srhb: it works along similar lines to the existing Positive/NonEmpty newtypes that come packaged with QC
08:00:31 <benmachine> MattY: type classes make QC substantially more convenient
08:01:35 <benmachine> I think if you wanted quickcheck without typeclasses you'd have to come up with some other clever idea to make properties really convenient to express
08:02:07 <enthropy> quickcheck has been done in other languages
08:04:52 <countoren> hi
08:06:30 <countoren> im trying to create a FindConvaxHall method this is my code:
08:06:38 <countoren> getTurn :: LinePoint -> LinePoint -> Point -> Turn getTurn lp lp2 p  	| (detOfVectors vectors) > 0 = LeftTurn 	| (detOfVectors vectors) < 0 = RightTurn 	| otherwise = Straight 		where 			moveAxisToPoint (x,y) ps = map (\(p1,p2) -> (p1-x, p2-y)) ps 			detOfVectors [(a,b),(c,d)] = (a*d) - (c*b) 			vectors = moveAxisToPoint lp [lp2,p]    getHall :: [Point] -> [Point] getHall xs = drawConvaxHall xs []  	where  	   drawConvaxHall [] [
08:07:00 <srhb> countoren: Might want to pastebin that at lpaste.net
08:07:13 <countoren> when im trying to compile i get this error :
08:07:14 <countoren>   Couldn't match type `[a0]' with `(Int, Int)'     Expected type: Point       Actual type: [a0]     In the first argument of `isAllOneSide', namely `p1'     In the expression: isAllOneSide p1 p2 xs     In a stmt of a pattern guard for                    an equation for `drawConvaxHall':       isAllOneSide p1 p2 xs
08:07:17 <dv-_> if I have newtype M a = M (StateT S Curses a), how do I use Curses functions in M?
08:07:20 <countoren> i dont understand why
08:08:06 <geekosaur> dv-_, lift . lift
08:08:20 <pyr> ok, I guess I should narrow down my question
08:08:28 <srhb> countoren: Your pastes are illegible for most people here, and it was also cut off before we got all of it. Put it on lpaste.net instead.
08:08:46 <geekosaur> countoren, please use a pastebin instead of pasting into channel, that code is unreadable
08:08:47 <countoren> ok
08:08:47 <geekosaur> @lpaste
08:08:48 <lambdabot> Haskell pastebin: http://lpaste.net/
08:09:20 <udevd> @type $
08:09:21 <lambdabot> parse error on input `$'
08:09:23 <udevd> @type ($)
08:09:24 <lambdabot> (a -> b) -> a -> b
08:10:02 <pyr> I have a type M { field1 :: String, field2:: Double }, and a C representation : MPtr Ptr (N field1p :: CString, field2 :: Double)
08:10:04 <dv-_> geekosaur: that gives me a t0 (t1 Curses) a type not M a
08:10:16 <lpaste> countoren pasted “Find Convax Hall” at http://lpaste.net/94876
08:10:45 <pyr> given that newCString yields and IO CString and not CString how would you go from M to N, and then from N to MPtr (i.e: which type of allocatio to send out)
08:11:00 <geekosaur> oh, you probably need to deriving (MonadTrans)
08:11:15 <countoren> ?
08:11:27 <geekosaur> that was for dv-)
08:11:30 <geekosaur> er dv-_
08:13:05 <geekosaur> countoren, also the full error message would have been nice
08:13:19 <countoren> yes sure
08:13:24 <countoren> give me a sec
08:13:42 <geekosaur> but, without even looking, you have a list where soemthing is expecting a Point
08:14:45 <lpaste> countoren pasted “error to find ConvaxHall” at http://lpaste.net/94877
08:15:16 <countoren> i dont understand why
08:15:28 <countoren> if i get it what from the where
08:15:39 <countoren> mmm
08:15:41 <countoren> nvm
08:16:58 <countoren> has i understand p1 p2 should be points not lists
08:17:47 <MattY> for an irc client would you use [Char] or Text (or something else ?
08:18:08 <chrisdone> depends
08:18:14 <chrisdone> if you want to assume UTF-8, i'd use Text
08:18:28 <chrisdone> if you want to handle arbitrary encodings, i'd use ByteString for the transport layer
08:18:33 <geekosaur> countoren, if I add a type signature to drawConvaxHall then it points me to 	   drawConvaxHall [p1] [] = p1  on line 21
08:18:42 <geekosaur> where you return Point instead of [Point]
08:18:46 <chrisdone> and then depending on configuration, re-ecode with text-icu into a Text
08:18:54 <MattY> why not String?
08:19:06 <geekosaur> String is convenient but slow and inefficient
08:19:10 <chrisdone> String isn't for grown up programs
08:19:15 <countoren> ooo
08:19:22 <MattY> geekosaur but that isn't likely to matter for irc client
08:19:37 <countoren> wow
08:19:39 <MattY> we are not processing GBs of data
08:19:40 <countoren> imbersing
08:19:43 <countoren> yes
08:19:45 <countoren> it was that
08:19:47 <dv-_> geekosaur: it won't let me derive MonadTrans
08:19:56 <chrisdone> MattY: it doesn't need to be gigabytes
08:20:04 <countoren> btw what do u guy think on the method??
08:20:13 <countoren> guys*
08:21:24 <MattY> chrisdone sure, but we are talking about irc traffic.
08:22:01 <chrisdone> MattY: dude if you can't be bothered using the proper type then just don't
08:22:02 <MattY> since I asked the question we had maybe a couple of KB of data
08:22:29 <MattY> chrisdone you did a poor job proving String isn't the proper type
08:23:18 <chrisdone> dealing with text -> use Text
08:23:19 <chrisdone> dealing with binary data -> use ByteString
08:23:19 <chrisdone> learning haskell/making toy language -> use String
08:23:52 <countoren> well its wrong... need to work on it still
08:24:39 <chrisdone> MattY: why do you want to use String?
08:25:36 <MattY> chrisdone if String is only for toying around, does that mean all the libraries using it are toy libraries?
08:25:52 <MattY> because String is convenient
08:26:15 * hackagebot sized-vector 1.1.0.0 - Size-parameterized vector types and functions.  http://hackage.haskell.org/package/sized-vector-1.1.0.0 (HiromiIshii)
08:26:24 <MattY> what is the reason to not use it when it is not the bottle neck? or are you claiming it will be a bottle neck when dealing with irc protocol?
08:26:39 <chrisdone> n/m, don't care about having this discussion
08:26:52 <chrisdone> srhb: did it work?
08:27:50 <nbouscal> MattY: You can do what's convenient, or you can do what's performant. If you choose the latter you will not be using String
08:28:54 <nbouscal> MattY: And in reality, String isn't much more convenient
08:30:52 <MattY> nbouscal, sure, I know String has poor performance, and shouldn't be used in cases where it matters. seems like chrisdone took it a step further and said that it's just for toying around. I thought String is prefered unless it becomes too slow. what is your opinion?
08:31:00 <lingxiao> hey are there any programs written in Core that I can read?
08:31:01 <benmachine> nbouscal: it's about correctness, too, there are weird corner cases where [Char] just isn't right
08:31:29 <lingxiao> or just like samples of Core in any capacity
08:31:39 <ryanakca> What's the haddock option to include links to source like is done for XMonad's documentation? (See "Source" links on right of, e.g., http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Actions-BluetileCommands.html )
08:31:48 <nbouscal> MattY: Well generally either you're writing something for fun or you're writing something serious, and if you're writing something serious you're going to care about performance enough to use a proper type
08:31:56 <MattY> benmachine what corner cases?
08:32:11 <nbouscal> MattY: The whole point of having all these nice abstractions is that you can easily sub in a more performant type and keep doing most things the same way
08:32:14 <benmachine> MattY: e.g. there are some cases in (I believe) Turkish where changing the case of a string changes its length
08:32:16 <MattY> nbouscal why would I care about performance of String when it isn't the bottle neck?
08:32:19 <benmachine> so map toUpper is just wrong
08:33:11 <nbouscal> MattY: Because it's an easy win
08:33:33 <nbouscal> MattY: I think you're overestimating the difficulty of using Text or ByteString
08:33:33 <benmachine> nbouscal: I think MattY's right about performance but Text is still great
08:33:57 <benmachine> Text is, well, designed as a text type
08:34:18 <benmachine> whereas [Char] is two existing types that more or less nearly always do roughly the same thing
08:34:26 <ryanakca> Nevermind, I misunderstood thu documentation, and figured it out :)
08:34:40 <benmachine> but collation and stuff will stab you in the eyes if you're not careful
08:34:46 <MattY> nbouscal I am not overestimating it, I just find Text. or BS. cluttered all over the place less pleasing aesthetically
08:35:40 <benmachine> MattY: yes, that is a problem, but it's really a cultural/libraries problem
08:35:41 <jmcarthur> lingxiao: i recommend just writing some simple haskell code and compiling it down to core to see what it looks like
08:35:52 <benmachine> rather than an essential one
08:36:06 <lingxiao> jmcarthur: how do I access the compiled core code?
08:36:17 <nbouscal> MattY: You can avoid a lot of that by using more general functions.
08:36:34 <jmcarthur> lingxiao: you can either pass -ddump-simpl to ghc or build and use ghc-core, which provides some syntax highlighting and convenient
08:36:39 <jmcarthur> *convenience
08:37:38 <lingxiao> ok great thanks!
08:37:44 <jmcarthur> lingxiao: also if you use emacs there is an option under the haskell menu in haskell-mode to generate core
08:38:05 <jmcarthur> i forget the keyboard shortcut, if there even is one by default
08:38:08 <lingxiao> oh no unfortnately I dont :( but i'll keep that in mind though
08:39:38 <geekosaur> lingxiao, ghc-core package
08:40:08 <geekosaur> also note that external core is (or at least used to be) subtly different from core generated by ghc, and isn't often used
08:41:28 <lingxiao> geekosaur: ok will take a look at that too!
08:42:02 <geekosaur> (in fact, for a long time external core was apparently broken and nobody noticed...)
08:47:46 <lingxiao> hey man I'm sorry but how do I pass ddump-simpl to ghc?
08:48:27 <geekosaur> lingxiao, if you install the ghc-core package it has a utility that does it automaticaly
08:48:35 <geekosaur> but, the option is -ddump-simpl
08:48:48 <geekosaur> (did you drop the leading - for some reason?)
08:49:26 <lingxiao> yeah i tried to to install ghc-core but I'm getting ExitFailure 1
08:49:53 <geekosaur> use -v3 and pastebin full log?
08:50:02 <hpc> lingxiao: you can also install ghc-man-completion
08:50:09 <hpc> and it will build a bash complete file from your ghc manpage
08:53:21 <lingxiao> ah thanks hpc I installed that
08:53:33 <dv-_> geekosaur: I fixed the problem by doing newtype MT m a = MT (StateT S m a) deriving (..., MonadTrans) and then type M = M Curses, now I can lift Curses types to M
08:53:36 <lingxiao> and thanks geekosaur I'll poke around a bit more
08:55:41 <lingxiao> and yes I did drop the '-' from ddump thanks for the catch!
09:01:19 * hackagebot feed 0.3.9.2 - Interfacing with RSS (v 0.9x, 2.x, 1.0) + Atom feeds.  http://hackage.haskell.org/package/feed-0.3.9.2 (SigbjornFinne)
09:10:37 <merijn> dv-_: Semi-unrelated: Are you using haskell curses bindings?
09:11:11 <merijn> dv-_: Might want to check out vty and vty-ui if you are, they're rather nice alternatives for building terminal UIs
09:31:21 * hackagebot cabal2nix 1.55 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.55 (PeterSimons)
09:35:42 <chrisdone> https://plus.google.com/101555949501667191720/posts/MN9ykUMte1Z
09:35:58 <Flonk> The function `fmap' is applied to two arguments, but its type `...' has only two
09:36:01 <Flonk> ಠ_ಠ
09:36:06 <copumpkin> I see google fully appreciates the value of usable URLs
09:36:42 <jrmithdobbs> copumpkin: 10 years later nowfinally ;p
09:39:36 <jrmithdobbs> so, I'm really confused ... I'm trying to use hs-geoip (yes, the c lib wrapper one, the other on hackage doens't build on current stable ghc for me ..)
09:39:46 <sbidin> Let's say I need to evaluate a definition from an untrusted Haskell module I just received. What steps should I take to eliminate the possibility of this code doing something malicious?
09:40:02 <jrmithdobbs> how the hell do I take so data in IO use it to transform/resolve something different without lifting the latter into IO?
09:40:14 <jrmithdobbs> I don't even know if those are the right words at this point i've confused myself so much ;p
09:41:25 <sbidin> I can have a custom Prelude that removes IO. I can only allow certain imports (i.e. no unsafe functions). Disable TemplateHaskell? Kill the process if it takes too much time/memory. Anything else?
09:46:08 <merijn> jrmithdobbs: Why do you not want to lift the operation into IO?
09:46:43 <merijn> sbidin: On FreeBSD you could use a jail, on any other system you might want to just run it in a virtual machine and not bother securing anything?
09:46:54 <jmcarthur> jrmithdobbs: think of IO as the shell around a purely functional core. you take some input in the IO shell, run it through your purely functional core, and then the out has to be lifted back into IO again to be output.
09:46:57 <jrmithdobbs> merijn: because it's returning a simple string and only impure part of the code
09:47:02 <jmcarthur> jrmithdobbs: so there's no avoiding the IO on both sides
09:47:10 <merijn> sbidin: Also, Safe Haskell: http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/safe-haskell.html
09:47:16 <jmcarthur> jrmithdobbs: what you want to do is just maximize the amount of time in pure code
09:47:43 <jrmithdobbs> i think i'm just going to parse their stupid .dat file into a Map and be done with it
09:47:50 <jmcarthur> or rather maximize the amount of code that is pure
09:48:02 <jrmithdobbs> instead of using the bindings =/
09:48:23 <jrmithdobbs> I guess that's the other approach
09:49:22 <jmcarthur> jrmithdobbs: so a program will often have things like this:   do { x <- getInput; writeOutput (f x) }  -- where `f` is the bulk of your computation
09:49:25 <lpaste> ryanakca pasted “How to make ambiguous type variables equal?” at http://lpaste.net/94879
09:49:38 <sbidin> merijn: Thanks! I'll have a look at Safe Haskell.
09:50:13 <merijn> ryanakca: You want 'a' and 'b' in the helper function to be the same as in the top level function's signature?
09:50:21 <ryanakca> merijn: Yes
09:50:26 <ryanakca> I'm not sure how to do that though
09:50:43 <merijn> ryanakca: By default the scope of type variables is only a single signature. You can use the ScopedTypeVariables extension to change that behaviour, though
09:50:47 <jrmithdobbs> jmcarthur: ya, I'm starting to 'get' it I think
09:50:51 <merijn> ryanakca: The GHC manual should explain how to use it
09:52:00 <ryanakca> merijn: And if I wanted to accomplish it without using a language extension? Shouldn't the (Assigneable a b) in the helper function quantify over all possible a, b, and thus accept the ones passed to it from the calling function?
09:53:00 <merijn> ryanakca: You can't write the type signature for this without the extension
09:53:35 <merijn> ryanakca: GHC might be able to infer the correct type without extension, but the type signature definitely can't be written without extension
09:54:00 <geekosaur> mrrr. isn't there a problem because bUnit doesn't mention a?
09:54:06 <jmcarthur> well, there are tricks with dummy arguments you can use instead of ScopedTypeVariables
09:54:14 <jmcarthur> but ScopedTypeVariables is usually more straightforward
09:54:55 <merijn> geekosaur: Oh, bit of both
09:55:06 <jmcarthur> well, Tagged and Proxy can be of help to avoid ScopedTypeVariables too, i guess. Proxy would just be a stand-in for the dummy argument. Tagged would eliminate it, but require you to wrap and unwrap something
09:55:36 <merijn> ryanakca, geekosaur: Because "bUnit" doesn't mention a it can't infer that the a used for bUnit (i.e. the outer 'a') matches the one in the helper, I think
09:55:41 <jmcarthur> again, ScopedTypeVariables is probably the easiest to read and write
09:56:03 <merijn> Yeah
09:56:26 <ryanakca> merijn: Ah, I understand what's going on now. Thanks :)
09:56:40 <merijn> Potentially you could solve it using FunDeps?
09:56:43 <merijn> Not sure about that
09:56:58 <merijn> But that's 1) also an extension and 2) probably more complex to read :)
09:58:30 <merijn> ryanakca: Semi-relatedly, there's no real reason to worry overly much about using extensions as you progress in Haskell. In theory it'll make your code less portable, in practice there's not a lot of production compilers to be portable for
10:00:12 <merijn> Most of them are safe (in the sense that they can't magically break correct code or allow you to write "wrong" code) and the majority has been around for ages and is well tested (Although admittedly there may not be a lot of documentation on what is what outside the GHC manual)
10:01:22 * hackagebot hsnock 0.5.0 - Nock 5K interpreter.  http://hackage.haskell.org/package/hsnock-0.5.0 (mrdomino)
10:02:53 <tomejaguar> Does anyone know a good explanation of relational parametricity?  I've read Wadler, but I don't understand where the idea for a relational semantics comes from.  It seems like magic.
10:15:57 <osa1> I got this warning message when I upload my package to hackage "Exposed modules use unallocated top-level names: Scripting" what generates this warning message?
10:16:12 <osa1> I want to use that tool in my system
10:16:23 * hackagebot hslua 0.3.8 - A Lua language interpreter embedding in Haskell  http://hackage.haskell.org/package/hslua-0.3.8 (OmerAgacan)
10:34:04 <Ieni0> Hello, is it possible to have non homogenous list? I want list of different records each of which should be applicable to specific set of functions.
10:34:41 <Ieni0> something like record tpye class?
10:36:09 <mauke> ew
10:38:31 <Ieni0> mauke: what?
10:42:19 <monochrom> no
10:48:26 <geekosaur> it is possible to have a non-homogeneous list. it's usually the wrong solution
11:01:25 * hackagebot language-puppet 0.10.1 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.10.1 (SimonMarechal)
11:02:13 <no7hing> good evening
11:02:37 <no7hing> i'am doing the scheme-in-48-hours and am wondering what i'am doing wrong here: https://gist.github.com/mhaemmerle/3784e3adc55f567030bd
11:04:39 <no7hing> the second file at the bottom of the gist contains the string used to test it and the error; i'am on ghc 7.6.3
11:13:24 <enthropy> no7hing: why do you have spaces in symbol?
11:14:26 <enthropy> if you try to   `parseTest parseExpr "(a b c)"`
11:14:45 <enthropy> it doesn't separate the a b c
11:14:57 <enthropy> because you're allowing spaces in symbols
11:15:51 <no7hing> oh f, that was the line i copy/pasted
11:16:47 <enthropy> so that's the tricky bit with parsec
11:17:19 <no7hing> the pdf-version (http://upload.wikimedia.org/wikipedia/commons/a/aa/Write_Yourself_a_Scheme_in_48_Hours.pdf) contains spaces
11:17:20 <enthropy> if you were using a parser generator, those kinds of conflicts happen when you compile
11:17:41 <no7hing> it doesn't solve the error though
11:17:53 <enthropy> it doesn't?
11:17:56 <enthropy> it does for me
11:18:45 <no7hing> it does for me too now ;)
11:18:58 <no7hing> thanks for catching this dumb error
11:19:12 <enthropy> no problem
11:19:28 <enthropy> I would complain to whoever generated that pdf
11:19:46 <enthropy> or maybe it's an intentional exercise to find that bug :p
11:22:41 <pavonia> I'ts a known problem with the (latex) listings library
11:22:46 <pavonia> *It's
11:23:21 <joelteon> I feel like an operator for flip (.) would be useful
11:24:07 <no7hing> that's .. unexpected behaviour for a code library
11:24:07 <elliott> joelteon: Control.Category has an ugly one.
11:24:11 <joelteon> what is it?
11:24:35 <enthropy> :t (>>>)
11:24:35 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
11:24:39 <joelteon> oh, that's no good
11:24:45 <enthropy> no it's perfect
11:24:52 <joelteon> well, it would break convention anyway
11:24:58 <joelteon> everyone uses (.), nobody uses (>>>)
11:26:26 * hackagebot pipes-parse 2.0.1 - Parsing infrastructure for the pipes ecosystem  http://hackage.haskell.org/package/pipes-parse-2.0.1 (GabrielGonzalez)
11:29:37 <monochrom> I use >>> and <<< when writing arrows
11:29:52 <monochrom> call me a nobody
11:30:12 <monochrom> hire someone to kill me to make your statement true
11:30:43 <Clint> arr murder
11:30:49 <FireFly> I like >>> and <<<
11:30:53 <monochrom> haha
11:31:27 * hackagebot cookbook 1.3.0.0 - A delicious set of interdependant libraries.  http://hackage.haskell.org/package/cookbook-1.3.0.0 (NatePisarski)
11:35:23 <_jgr> apples, where u at bb?
11:35:41 <elliott> _jgr: ?
11:38:00 <_jgr> elliott: hello
11:45:23 <bluesky> is there a way i can override the normal implementation of ^ (as in 2 ^ 5 = 32) to do the same thing when applied to numbers, but to do other things when applied to other data made by me? (I'd like not to hide the Prelude function in case I would still want to use that 1 too)
11:46:22 <dwcook> bluesky, not easily. You can of course define an operator of the same name ((^) is just a function) in another module and qualify it, though.
11:46:30 <Tekmo> Sort of
11:46:35 <Tekmo> So here's the issue
11:46:44 <Tekmo> In order to overload it you would need to type class it
11:46:47 <Tekmo> Normally that's not a problem
11:46:51 <geekosaur> :t (^)
11:46:52 <lambdabot> (Integral b, Num a) => a -> b -> a
11:47:22 <Tekmo> However, if you want it to work for all its old instances of `Integral` and `Num`, you would have a problem
11:47:44 <Tekmo> If you write an instance like: instance (Integral b, Num a) => Power a b where ...
11:47:51 <Tekmo> Then you'd have OverlappingInstances
11:48:09 <Tekmo> The only way around that would be to wrap one or the other arguments in a newtype to prevent overlap
11:49:11 <Tekmo> I think the least messy solution is to just define your own operator that looks similar to it
11:49:19 <bluesky> oh... so it would be best just to name it in otherway, thanks :)
11:49:19 <Tekmo> i.e. "^^" or something like that
11:49:30 <Tekmo> You're welcome :)
11:50:34 <geekosaur> ^^ exists too
11:50:38 <geekosaur> :t (^^)
11:50:39 <lambdabot> (Fractional a, Integral b) => a -> b -> a
11:50:44 <Tekmo> Oh yeah :(
11:55:22 <Tekmo> I'm really surprised no library has taken `(?)`, yet
11:56:40 <dwcook> I suppose the most obvious use of that would be for a Maybe, maybe for fromMaybe
11:56:44 <dwcook> @type fromMaybe
11:56:46 <lambdabot> a -> Maybe a -> a
11:56:51 <dwcook> Albeit reversed
11:57:09 <dwcook> Obvious to me anyhow. :P
11:58:10 <Tekmo> I've always thought it would be funny to use `(???)` as a substitute for `undefined`
11:58:46 <dwcook> Why infix?
11:58:53 <Tekmo> Not infix
11:58:59 <Tekmo> I just put Haskell code in backticks, like markdown
11:59:01 <joelteon> Bare ??? would be better
11:59:28 <dwcook> I mean how ??? would be infix
11:59:36 <Tekmo> Oh, I would put it in parentheses
11:59:42 <Tekmo> difficultCode = (???)
11:59:54 <dwcook> :D
11:59:56 <Tekmo> :)
11:59:58 <mauke> perl uses ... for that :-)
12:00:05 <Tekmo> Oh, that's even more clever
12:00:10 <mauke> sub not_implemented_yet { ... }
12:00:15 <joelteon> yea I was thinking about perl
12:00:19 <mauke> if ($error) { ... }
12:00:35 <dwcook> Racket also has ..., and will give you a special error if you try to use something defined that way
12:00:44 <mauke> yeah
12:01:16 <mauke> todo = error "Not implemented"
12:01:48 <jrmithdobbs> this is rude but seriously, why is like every haskell related piece of documentation/tutorial something like this instead of "here is how you start your event loop, here is how you tie a wire to a socket, here is how you do a tcp echo server" ... i mean if I didn't already understand the basic concept I wouldn't be looking at the damned library most likely ...
12:01:53 <jrmithdobbs> http://www.haskell.org/haskellwiki/Netwire
12:02:46 <Ralith> I don't think every haskell related piece of documentation concerns event loops or sockets.
12:03:14 <jrmithdobbs> Ralith: right, but every piece of haskell documentation seems to intentionally be obtuse about practical applications ...
12:03:24 <jrmithdobbs> which is what i was getting at
12:03:35 <Tekmo> So, one thing I noticed is that libraries like these usually do this because they have an `example/` directory in their Github repo
12:03:43 <mauke> jrmithdobbs: http://hackage.haskell.org/package/netwire-4.0.7/docs/Control-Wire.html has examples
12:03:45 <Tekmo> But that's not obvious from looking at the Hackage page
12:05:11 <Tekmo> I also agree that most Haskell libraries don't provide enough practical examples in their documentation
12:05:29 * copumpkin grins
12:05:34 <jrmithdobbs> mauke: oh hey there :)
12:05:45 <copumpkin> jrmithdobbs: omg I know you from #bitcoin-dev
12:05:56 <mauke> hmm?
12:06:54 * davidfetter waves to copumpkin
12:07:26 * copumpkin jumps up and hugs davidfetter, picks him up, swings him around three times, and puts him back down
12:07:46 <davidfetter> goodness!
12:07:57 <davidfetter> such enthusiasm :)
12:08:06 <copumpkin> I'm way too enthusiastic
12:08:21 <davidfetter> seldom a problem
12:08:48 * davidfetter trying to recall when we met last
12:08:58 <davidfetter> i think it was a pg conference in seattle
12:09:07 <copumpkin> hmm, I haven't been to seattle
12:09:24 <davidfetter> d'oh
12:09:26 <davidfetter> guess not
12:09:27 <mauke> oh, maybe that hasn't happened yet
12:10:03 <davidfetter> um, ixnay on the alkingtay about ime-traveltay
12:10:47 <davidfetter> you wouldn't *believe* how much trouble i'll get in
12:11:29 * hackagebot pretty 1.1.1.1 - Pretty-printing library  http://hackage.haskell.org/package/pretty-1.1.1.1 (DavidTerei)
12:14:30 <tick> @djinn Not (Not (Either p (Not p))) <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
12:14:30 <lambdabot> Cannot parse command
12:15:48 <kess> hi all
12:16:22 <kess> is there any documentation for how compare behaves with tuples? (i.e. does it compare the first, then the second, etc., element of each tuple)
12:17:13 <mauke> probably not
12:17:32 <Tekmo> That's the correct behavior
12:17:42 <kess> Tekmo: do you have a source? I need to cite it
12:17:45 <Tekmo> It compares the first element, then the second if the first elements were equal, and so fourth
12:17:56 <Tekmo> The instance declaration for `Ord` for tuples
12:18:05 <Tekmo> Let me find the exact source code
12:18:09 <kess> cheers :)
12:18:21 <mauke> oh, does the source code count?
12:18:41 <kess> well I'd rather find it in the haskell98 standard or something but the source code is probably fine
12:19:21 <elliott> H98 has source code :)
12:19:42 <Tekmo> Oh
12:19:50 <Tekmo> It should be in the standard
12:20:00 <Tekmo> Because it's the same behavior as `deriving (Ord)`
12:20:04 <Tekmo> Let me see if I can find it
12:20:08 <kess> I think I've just found it
12:20:11 <kess> but thanks
12:20:31 <Tekmo> You're welcome
12:20:46 <mauke> I don't actually see it in the report
12:20:58 <kess> http://www.haskell.org/onlinereport/derived.html Derived comparisons always traverse constructors from left to right. These examples illustrate this property:
12:21:03 <kess> section 10.1
12:21:28 <mauke> where does it say the tuple instance is derived?
12:21:35 <Tekmo> That'si n the standard prelude
12:21:49 <kess> yeah
12:22:04 <mauke> bug in the report, I guess
12:22:26 <Tekmo> data  (a,b)   =  (a,b)    deriving (Eq, Ord, Bounded)
12:22:50 <Tekmo> Why is it a bug?
12:23:04 <mauke> because it doesn't define how the Ord instance for tuples works
12:23:12 <mauke> it just says that it exists
12:23:25 <Tekmo> But it defines how `deriving` should work, which should be sufficient, I think
12:23:27 <elliott> mauke: presumably it's derived as if that was a valid data declaration
12:23:42 <elliott> it desugars to data (,) a b = (,) a b and then you apply the usual rules
12:23:50 <mauke> elliott: I don't want to presume
12:23:53 <Tekmo> :)
12:24:03 <copumpkin> sounds unpresumptious
12:24:08 <Tekmo> Ok, then you need to make a recommendation to the Haskell committee to fix that
12:24:13 <elliott> mauke: then by that argument it doesn't even define tuple types at all, I guess :)
12:24:58 <mauke> I mean, what if I wrote a Prelude with: instance (Ord a, Ord b) => Ord (a, b) where { compare (a1, b1) (a2, b2) = compare b1 b2 <> compare a2 a1 } in it?
12:25:29 <Tekmo> Well, then that would conflict with the `deriving` clause
12:25:36 <mauke> what deriving clause?
12:25:48 <Tekmo> data (a, b) = (a, b) deriving (Eq, Ord, Bounded)
12:25:51 <Tekmo> That's from the Prelude
12:25:54 <mauke> that's not valid syntax
12:26:17 <Tekmo> Then fix the Haskell report
12:26:22 <FreeFull> Let's assume that it's the same as    data Foo a b = Foo a b deriving (Eq, Ord, Bounded)
12:26:31 <mauke> FreeFull: why?
12:26:47 <mauke> Tekmo: what do you mean by "that's from the prelude"?
12:27:08 <Tekmo> The report comes with a standard prelude
12:27:12 <FreeFull> Because Foo and (,) should have the same behaviour other than the special (a,b) syntax
12:27:15 <Tekmo> http://www.haskell.org/onlinereport/standard-prelude.html
12:28:11 <elliott> http://www.haskell.org/onlinereport/ is out of date
12:28:27 <mauke> I'm looking at http://www.haskell.org/onlinereport/haskell2010/haskellch9.html#x16-1710009 anyway :-)
12:28:38 <geekosaur> why is that still pointing at h98 :(
12:29:43 <mauke> ok, I'll accept http://www.haskell.org/onlinereport/haskell2010/haskellch9.html#verbatim-230
12:30:57 <Tekmo> I mean, it really only matters what `kess` needs
12:31:09 <mauke> kess left long ago
12:33:32 <khyperia> I'm using Parsec, and I'd like to use Applicative instead of do-notation, since people tend to suggest that, but I'm very unfamiliar with it. I have "do x <- p1; y <- p2; p3; return (x : y)", how would that look in applicative notation?
12:33:51 <Tekmo> (:) <$> p1 <*> p3
12:33:57 <Tekmo> Oops
12:34:00 <Tekmo> Sorry, my mistake
12:34:13 <Tekmo> ((:) <$> p1 <*> p2) <* p3
12:34:20 <khyperia> Thanks!
12:34:26 <Tekmo> You're welcome!
12:34:29 <mauke> liftA2 (:) p1 p2 <* p3
12:34:32 <Tekmo> Oh yeah
12:34:35 <Tekmo> I like that even better
12:35:14 <khyperia> my original guess was "liftA2 (:) letter (many alphaNum <* spaces)", which translating into my p1, p2, p3, it's... "liftA2 (:) p1 (p2 <* p3)"
12:35:22 <elliott> (:) <$> p1 <*> p2 <* p3 should work fine
12:35:25 <elliott> afaik
12:35:41 <Tekmo> khyperia: I believe those are equivalent
12:35:47 <khyperia> alright, awesome
12:42:15 <Narvius> So I'm writing a bunch of pure functions that will later be used in a State or IO monad for "mutating" state
12:42:29 <Narvius> Never really did that before, bo
12:42:30 <Narvius> so*
12:42:57 <Tekmo> You can always convert a function that mutates state into a `State` action using `modify`
12:42:58 <Narvius> Just a quick confirmation: I should aim for a signature of a -> b -> b instead of b -> a -> b, right?
12:43:07 <Tekmo> Both will work
12:43:16 <Narvius> Yeah, but which will make more concise code?
12:43:16 <Tekmo> Oh wait
12:43:20 <Tekmo> Sorry, now I'm confused
12:43:30 <Tekmo> Why those signatures?
12:43:49 <Narvius> (MyStateThing a, WhateverElse b) => a -> b -> a"
12:43:58 <Narvius> b -> a -> a
12:44:05 <Narvius> Pseudo-Type Signatures!
12:44:09 <Tekmo> Then prefer the version with the state as the second argument
12:44:28 <Narvius> That's what I thought.
12:44:29 <Narvius> Thanks.
12:44:32 <Tekmo> The reason why is that if you partially apply it to the non-state thing then you get `s -> s`
12:44:41 <Tekmo> That is then a suitable argument for `modify`
12:46:53 <begriffs> @pl \x -> fst $ readOct x !! 0
12:46:56 <lambdabot> id fst . (!! 0) . readOct
12:46:57 <lambdabot> optimization suspended, use @pl-resume to continue.
12:47:01 <Narvius> Okay. And now if I had information retrieval functions (like, say, getting the neighbors of a field on a grid), should I take the State as last argument as well?
12:47:38 <Tekmo> So you mean something like: arg -> state -> ret?
12:47:44 <Narvius> yea.
12:47:52 <Tekmo> Yes, then you want the `state` to be the second argument
12:48:03 <Tekmo> So that if you partially apply it to the `arg` you get `state -> ret`
12:48:07 <Tekmo> That you can then pass to `gets`
12:48:10 <Narvius> Fair enough.
12:48:21 <Narvius> Thanks.
12:48:40 <Tekmo> You're welcome
12:53:54 <Narvius> On another note; How much of the actual theory behind Haskell would be good to understand in order to use it effectively? I have a somewhat solid grasp on Functors, Applicatives and Monads, recently learned that Monoids are pretty simple things actually (and the reasoning behind the "Sum" and "Product" wrapper things). But I still cringe when I hear the word "comonad" or things like that.
12:54:50 <begriffs> @pl-resume
12:54:57 <lambdabot> id fst . (!! 0) . readOct
12:54:57 <lambdabot> optimization suspended, use @pl-resume to continue.
12:55:00 <Tekmo> Do you tend to write more applications or libraries?
12:55:46 <begriffs> @pl \f -> id fst . (!! 0) . f
12:55:49 <lambdabot> (id fst .) . ((!! 0) .)
12:55:50 <lambdabot> optimization suspended, use @pl-resume to continue.
12:55:55 <identity> Narvius: Well, a lot of the cool libraries for haskell make use of these structures to make the code more elegant.
12:56:14 <identity> I can't help but think of jaspervdj's stuff and obviously edwardk's code, like lens
12:56:46 <identity> and edwardkmett has written a bunch of articles on solving various problems using all of those magical structures
12:57:16 <Tekmo> My rule of thumb is that if you are an application writer you don't need to know too much theory.  Just use as much as you need to use whatever libraries you encounter
12:57:27 <Tekmo> If you are a library writer, the theory helps a lot more for designing an easy-to-use API
12:57:51 <Narvius> Okay.
12:58:38 <Narvius> And yeah, lens are pretty darn cool.
12:58:41 <Narvius> Am using 'em.
13:03:36 <carter> also the type checker is your friend
13:03:43 <carter> try stuff and let the type checker give you feedback
13:04:33 <Tekmo> Also, read type error messages carefully
13:04:37 <Tekmo> They are actually useful
13:06:32 * hackagebot sqlite-simple 0.4.4.0 - Mid-Level SQLite client library  http://hackage.haskell.org/package/sqlite-simple-0.4.4.0 (JanneHellsten)
13:07:16 <carter> yes
13:07:21 <carter> when confused aske people :)
13:07:33 <carter> theres been a lot of engineering to make the error messages helpful
13:07:50 <carter> though theres always room for better error emssages
13:07:59 <Tekmo> Also, if it's not a lot of trouble, try asking on Stack Overflow so that others can benefit from an easily searchable solution
13:09:43 <carter> that too
13:11:32 * hackagebot quickcheck-instances 0.3.3 - Common quickcheck instances  http://hackage.haskell.org/package/quickcheck-instances-0.3.3 (AntoineLatter)
13:17:23 <willem> hello, does anybody know if there is some way to run ghci in a cabal sandbox?
13:17:34 <carter> cabal repl
13:18:22 <willem> cheers carter!
13:21:49 <khyperia> Could someone help me install Harpy on windows? (or an alternative backend api?)
13:22:13 <Tekmo> What issue are you having?
13:22:29 <khyperia> "ghc.exe: dist\build\Harpy\CodeGenMonad.o: unknown symbol `_mprotect'"
13:23:09 <willem> now that i know how to run ghci in a cabal sandbox (cabal repl), im wondering if theres any support in emacs' haskell-mode for this inferior 'cabal repl' process, does anyone know? ^^
13:24:04 <Tekmo> khyperia: So `mprotect` is an FFI call to an external library.  It looks like you need to have that library installed to run your program
13:25:16 <geekosaur> does windows even have mprotect? it's a POSIX API
13:26:16 <geekosaur> actually not even POSIX, it's BSD
13:27:17 <geekosaur> oh, os x manpage lies, it is POSIX2001
13:28:09 <khyperia> If that's not going to work, could someone point me at a library that will actually install? I'd rather not have to dig in and learn/debug the generation of a raw binary by hand.
13:29:01 <khyperia> I'm just looking for any level of code generation, whether it's super high level and abstract, or just raw assembly codes.
13:29:25 <Tekmo> Maybe you can try LLVM
13:30:22 <khyperia> LLVM appears to be only build-from-source, and that never fails to blow up in some form or another for me.
13:31:18 <Tekmo> Side note: A lot of things are much easier if you use a linux distribution with a package manager
13:31:30 <Tekmo> It makes it a lot easier to install these sorts of things without compiling from source
13:31:34 <khyperia> yeah, linux is really nice, but I'm restricted to windows.
13:31:36 <carter> khyperia: what OS are you on?
13:31:37 <carter> ahh
13:31:44 <carter> khyperia: just use GHC
13:31:56 <khyperia> what?
13:31:57 <carter> whats the goal?
13:32:12 <khyperia> My goal is to write a compiler. I'm stuck on the code gen part.
13:32:23 <carter> khyperia: why are you stuck on windows?
13:32:35 <carter> you can have a linux image on a windows box
13:33:03 <identity> virtualization etc
13:33:07 <carter> khyperia: you can use the GHCi api's to do code gen also
13:33:16 <carter> what kinda language do you want to compile to?
13:33:26 <carter> x86 or x86_64?
13:33:27 <khyperia> I really don't care what language, as long as it compiles.
13:33:31 <carter> umm
13:33:32 <identity> why not c--?
13:33:42 <khyperia> c-- seems a bit dead, but that might work
13:33:43 <carter> identity: you mean write a c-- compiler
13:33:55 <carter> you can use ghc to compile some restrictec c--
13:33:58 <identity> carter: I'm not sure i understand his equest in this case
13:34:08 <carter> identity: i think he wants to write a compiler
13:34:12 <khyperia> yes
13:34:17 <identity> yes, to some intermediate language?
13:34:18 <carter> khyperia: what sort of interpreters have you written so far?
13:34:25 <identity> or just some language to machine code?
13:34:32 <carter> khyperia:  use llvm-general hackage.haskell.org/package/llvm-general
13:34:37 <carter> idris uses it too
13:34:42 <identity> @hackage llvm-general
13:34:42 <lambdabot> http://hackage.haskell.org/package/llvm-general
13:34:49 <carter> its very very nice
13:34:53 <khyperia> doesn't llvm-general require llvm to be installed?
13:34:55 <countoren> hey guys just finshed  find convax hall method will love to here some opinion about the code (efficency , foramted , logic...)
13:34:56 <carter> khyperia: yes
13:35:01 <lpaste> countoren revised “Find Convax Hall”: “Find Convax Hall” at http://lpaste.net/94876
13:35:13 <carter> khyperia: but it works on windows
13:35:20 <Tekmo> *ConvexHull
13:35:21 <carter> its been tested
13:35:26 <countoren> :/ sry
13:35:28 <Tekmo> :)
13:35:33 <Tekmo> I don't mind
13:35:51 <khyperia> Well... like I said, whenever I try to install from source, it blows up. I really, really don't want to do so. Even if I get it working, switching dev computers would be a huge hassle.
13:36:05 <Tekmo> What do you mean when you say it blows up?
13:36:09 <carter> yes
13:36:10 <carter> explain
13:36:16 <carter> because "blows up" == we can't help you
13:36:20 <carter> "it doesn't work"
13:36:26 <carter> "oh, the computer wasn't plugged it"
13:36:40 <khyperia> Not specifically llvm, but "in general" whenever I install anything from source, there's about a 75% chance that it won't work.
13:36:43 <carter> khyperia: you need mingw or the like
13:36:48 <carter> khyperia: then report bugs
13:36:51 <identity> I *just* read a thread bout some guy who tried to install a library from source and broke his ubuntu installation
13:36:55 <identity> maybe that's what he means
13:36:58 <identity> but i'm not sure how that happens
13:37:07 <carter> identity: thats why package managers shouldn't have sudo powers by default
13:37:11 <Tekmo> khyperia: A valuable skill to learn is to be methodical in the face of errors
13:37:19 <identity> carter: aye
13:37:27 <khyperia> It's much nicer to just not have errors in the first place.
13:37:29 <carter> agree with Tekmo
13:37:33 <carter> khyperia: the fix the
13:37:54 <identity> 99% of the time, the error you run into is something someone else has also run into before. so google will help
13:38:06 <carter> khyperia: i really don't care about your complaints, you're complaining to one of the 3 people who helped make sure the OS X mavericks upgrade wouldn't totally break GHC
13:38:18 <identity> ./configure tells you about the dependencies that are missing, then you install those, and then make will almost always Just Work.
13:38:20 <Tekmo> khyperia: That is why when you solve your problem you contribute a patch so that the next person who comes along doesn't have the same problem
13:38:28 <khyperia> Look, what I'm complaining about is saying "could you give me something *other* than llvm-general"
13:38:32 <carter> nope
13:38:33 <carter> try it
13:38:37 <carter> if you hit errors
13:38:38 <carter> report it
13:38:44 <carter> llvm-general is teh BEST tool
13:39:01 <carter> your arm chair objections about it possibly having a bug you'd need to report don't sway me
13:39:02 <carter> :)
13:39:11 <carter> llvm-general is the best possible tool
13:39:13 <carter> for your goal
13:39:27 <Tekmo> khyperia: If you want the easy way out, you can use c--
13:39:39 <carter> Tekmo: the GHC API c--?
13:39:41 <khyperia> are there haskell bindings for c--?
13:39:55 <carter> khyperia: nope
13:40:06 <carter> Tekmo: theres no maintained c-- compiler
13:40:10 <Tekmo> Oh :(
13:40:17 <carter> unless you count the subset that GHC can compile
13:40:32 <carter> Tekmo: llvm is equiv to c-- mostly
13:40:40 <carter> if he want to write a compiler that actually does anything
13:40:46 <carter> *anything intersting
13:40:52 <carter> he should go get llvm-general working
13:41:15 <carter> khyperia: please try out llvm-general
13:41:25 <khyperia> Fine, fine, I'll try it.
13:41:32 <carter> khyperia: and report any bugs you hit
13:41:41 <carter> and #haskell-llvm has many folks who'd be happy to help
13:42:34 <chrisdone> carter: he's not swayed by armchair objections … but what of desk chairs?
13:42:52 <carter> chrisdone: hehe me or him?
13:43:07 <carter> well, deck / desk chairs are often uncomfortable
13:43:13 <carter> i prefer a standing desk
13:43:26 <carter> chrisdone: hello!
13:44:49 <Tekmo> countoren: So the first recommendation I would have for the `getTurn` function is to not use a list as an intermediate
13:45:06 <Tekmo> countoren: It's a very minor thing, but if I statically know the number of elements I prefer to use a tuple
13:45:32 <countoren> ok
13:45:51 <Tekmo> countoren: It's a good habit to avoid partial functions unless absolutely necessary
13:46:11 <countoren> partial functions like?
13:46:23 <Tekmo> `detOfVector`, which assumes that its argument is a two-element list
13:46:32 * carter Tekmo: chrisdone  speaking of compilers, I made an intervention to make the HN thread on C-- more fact based https://news.ycombinator.com/item?id=6621679
13:46:34 <carter> Tekmo: chrisdone  speaking of compilers, I made an intervention to make the HN thread on C-- more fact based https://news.ycombinator.com/item?id=6621679
13:46:56 <Tekmo> I don't read HN, yet
13:47:06 <carter> Tekmo: healthy that
13:47:07 <carter> i should stop
13:47:21 <Tekmo> Haha
13:47:32 <Tekmo> I know that if I start reading it I will get obsessed with forming a startup
13:48:15 <countoren> y tuple instead of lists?
13:48:18 <carter> Tekmo: a webapp for moms to share pictures of kittens
13:48:39 <Tekmo> countoren: What I mean is something like:
13:49:06 <Tekmo> countoren: vectors = let f = moveAxisToPoint lp in (f lp2, f p)
13:49:18 <Tekmo> countoren: detOfVectors ((a, b), (c, d)) = ...
13:49:40 <countoren> ok , there is a reason for that?
13:49:48 <Tekmo> countoren: Purely good habit
13:50:05 <Tekmo> countoren: If you practice eliminating partial functions for easy cases like that, you will get better at doing it in harder cases
13:50:32 <Tekmo> countoren: Part of programming in Haskell is learning how to encode more information in the types
13:50:46 <Tekmo> countoren: When you store the points in a list, you lost some information from the types, specifically that the list had two elements
13:50:47 <carter> yes
13:51:01 <carter> though theres a limit of whats feasible vs say in somethign like diris
13:51:02 <carter> *idris
13:51:14 <Tekmo> countoren: An even better solution would be to use a list type that stores the length of the list in the type
13:51:24 <Tekmo> countoren: However, this is not as mainstream in Haskell just yet
13:52:33 <carter> Tekmo: theres also a power weight tradeoff because certain things needed to make the engineering nice aren't possible in haskell
13:52:35 <carter> unlike idris
13:52:52 <Tekmo> Right
13:53:36 <carter> eg: the current singletons stuff people can do is really really not intuitive / easy to explain
13:53:59 <countoren> sorry that im asking too mach.. :) but what do you mean by losing information form a type ? well i can type the list like this  type PointList = [Point]
13:54:14 <Tekmo> There are some list types where the type can actually store the length of the list
13:54:25 <countoren> o
13:54:26 <Tekmo> In the literature these are usually called "vectors"
13:54:32 <Tekmo> So it would look something like:
13:54:40 <Tekmo> [1, 2] :: Vector 2 Int
13:54:41 <countoren> monad list with length something like this
13:55:04 <Tekmo> This requires the type system having nice facilities for type level arithmetic and constraints
13:55:18 <watermind> Tekmo: while I do hope type system continues to improve, I'm more hopeful of advances in "static contract checking" for haskell then dependent types to be honest
13:55:32 <Tekmo> watermind: Yeah, I am a big fan of Liquid Haskell
13:56:15 <watermind> Tekmo: indeed, I've seen it, and now there's also another approach by Simon PJ et al.
13:56:19 <countoren> but doesnt it make it more complicated and harder to manipulate?
13:56:29 <carter> Tekmo: nope
13:56:33 <carter> you need full dependent types
13:56:37 <carter> or liquid haskell
13:56:48 <carter> theres some deep problems with the type level solver tooling
13:56:55 <carter> for nats
13:56:55 <Tekmo> I didn't know Simon was working on this.  Is there a paper?
13:57:00 <watermind> Tekmo: yes
13:57:09 <carter> watermind: wat?
13:57:11 <carter> where
13:57:21 <watermind> Tekmo: carter:  "Static contract checking for Haskell"
13:57:25 <carter> oh
13:57:31 <jrmithdobbs> http://research.microsoft.com/en-us/um/people/simonpj/papers/verify/
13:57:38 <watermind> http://research.microsoft.com/en-us/um/people/simonpj/papers/verify/
13:57:40 <carter> watermind: Tekmo  i think ranjit has sold  spj on liquid haskell or something like it
13:57:40 <watermind> yes that
13:57:53 <watermind> I hope he did
13:57:53 <Tekmo> So wait.  That is back in 2009.  Whatever became of it?
13:57:57 <carter> nothing
13:58:45 <watermind> HALO: Haskell to Logic through Denotational Semantics <- that's 2013
13:59:02 <carter> yes
13:59:09 <carter> but its not part of a working system you can use
13:59:11 <carter> liquid haskell is
13:59:15 <carter> and its got neat demos
13:59:16 <carter> and works
13:59:53 <watermind> I've read this quite some time ago, but my impression was that the HALO approach would make it easier to e.g. translate to tools liek WHY3
14:00:11 <watermind> which interface with all sorts of ATP's
14:00:20 <carter> ATP =?
14:00:29 <carter> watermind: maybe so…  but someone has to do that work :)
14:00:46 <watermind> I know :L
14:01:22 <monochrom> hmm, a novel translation of haskell and contracts to FOL? that's interesting.
14:01:33 <carter> watermind: wanna do it? :)
14:01:44 <watermind> carter: wouldn't mind... busy now though
14:01:50 <carter> soke
14:01:58 <carter> nothing new is afoot for ghc till after 7.8 lands
14:02:04 <monochrom> in fact, FIRST order?! no higher order needed?! that's impressive :)
14:02:11 <watermind> monochrom: exactly
14:02:24 <carter> FOL is a lot easier to check :)
14:02:34 <watermind> monochrom: do you know why3 and whyML?
14:02:38 <Tekmo> countoren: I think there's a much simpler way to write `isAllOneSide`
14:02:40 <monochrom> no
14:03:15 <countoren> like?
14:03:25 <Tekmo> countoren: Give me juuust a second.  My daughter is distracting me
14:03:36 <countoren> i tried to be as efficent as i can(know)
14:03:47 <countoren> np
14:03:54 <Tekmo> Are you familiar with the `all` function?
14:04:01 <watermind> monochrom: it's a deductive program verification system, provides a specification language, an ML like programming language, and interfaces with a bunch os theorem provers
14:04:12 <countoren> i guess not
14:04:37 <watermind> monochrom: it may be feasible to make a translation to that platform
14:04:46 <Tekmo> countoren: What you need to do is factor it into two functions
14:05:15 <Tekmo> countoren: The first function just checks if two points are on the same side of a line
14:05:32 <Tekmo> countoren: i.e. sameSide :: LinePoint -> LinePoint -> Point -> Point -> Bool
14:05:50 <countoren> ok
14:05:50 <Tekmo> Once you have that function, the definition of `isAllOneSide` becomes very easy
14:05:58 <Tekmo> isAllOneSide [] = True
14:06:10 <Tekmo> Oops, one second
14:06:17 <Tekmo> isAllOneSide lp1 lp2 [] = True
14:06:34 <Tekmo> isAllOneSide lp1 lp2 (p:ps) = all (sameSide lp1 lp2 p) ps
14:07:02 <Tekmo> Ignore the first one.  Just use the last two lines
14:07:31 <Tekmo> The reason it works is because of the `all` function, which has the following type:
14:07:34 <Tekmo> :t all
14:07:35 <lambdabot> (a -> Bool) -> [a] -> Bool
14:07:46 <Tekmo> You give it a predicate and it tests if all elements of the list satisfy that predicate
14:08:52 <countoren> less efficent
14:08:56 <countoren> i think
14:08:59 <Tekmo> Why less efficient?
14:09:24 <countoren> mine will stop if spot false
14:09:27 <Tekmo> So will `all`
14:09:34 <Tekmo> > all even [1..]
14:09:36 <lambdabot>   False
14:09:49 <countoren> mm
14:10:32 <Tekmo> Also `all` is more efficient in another way: it is defined in terms of `foldr` so it will trigger `build/foldr` fusion and fuse away the intermediate list if possible
14:10:47 <evancz> hi, does anyone know about the server requirements for something like lpaste?
14:11:36 <countoren> sounds nice
14:11:41 <countoren> i should try it
14:12:32 <countoren> but its more or less the same idea.. only done by framework method
14:13:05 <Tekmo> It makes your code easier for others (i.e. me) to read
14:13:21 <countoren> might be
14:13:23 <countoren> yes
14:14:11 <carter> foldr also has that early terminatin niceness
14:14:34 <khyperia> carter, I'm in the middle of building llvm... how long does it take?
14:14:41 <khyperia> I can't find a general guess anywhere.
14:14:45 <carter> khyperia: compilers are hard
14:14:46 <carter> wait
14:14:47 <carter> and learn
14:14:48 <countoren> what do u think on the general preforamce of the code?
14:15:00 <Tekmo> khyperia: Stare at the build output and pretend that you are a hacker :)
14:15:07 <Flonk> > do Nothing
14:15:11 <carter> the most accurate answer is "depends on how nice your computer is"
14:15:19 <carter> does it have 32 cores? or 1?
14:15:23 <Tekmo> countoren: I'm still studying `getHall`
14:15:30 <countoren> ok
14:15:39 <khyperia> I mean somewhere in the guess of an order of magnitude. 10 minutes? 10 hours?
14:15:46 <carter> < 1 hour probably
14:15:49 <Tekmo> My guess is less than an hour
14:15:53 <khyperia> alright, thanks
14:16:02 <chrisdone> ghc used to take hours, these days takes 15 mins on my machine
14:16:10 <carter> chrisdone: i remember that sorta
14:16:13 <carter> was that with the old build system?
14:16:20 <carter> or are computers just that much nicer?
14:16:28 <chrisdone> not sure. maybe a combination?
14:16:34 <carter> hehe
14:17:07 <monochrom> my data point is http://www.vex.net/~trebla/haskell/I-built-GHC.xhtml
14:17:24 <chrisdone> i've got 4x more memory, 4x more cores and SSDs now than what i had 5~ years ago
14:18:47 <chrisdone> monochrom: huh, interesting. have you built ghc 7.8 on ubuntu? i had some trouble and gave up without putting up a fight
14:18:50 <carter>  chrisdone  i remember having to build all my packages at once
14:18:58 <monochrom> I haven't
14:19:23 <chrisdone> (i say 7.8, i mean HEAD)
14:19:23 <chrisdone> monochrom: what're the specs of that laptop?
14:19:38 <chrisdone> 4GB, 2.3GHz qual core, hard disk drive, something like that?
14:19:44 <Tekmo> countoren: Are you sure this convex hull algorithm is correct?
14:20:05 <countoren> i tried on couple of example all got me correct answer
14:20:22 <countoren> it should be
14:20:24 <monochrom> two-core pentium T3200 2GHz, 3GB RAM, rotating disk
14:20:29 <countoren> but i might be wrong
14:21:10 <chrisdone> monochrom: hehe, my spec-sense tingled fairly accurately
14:21:27 <chrisdone> my 3-4ish year old macbook is similarly spec'd
14:21:30 <countoren> *Main> let xs = [(-3,1),(-4,1),(-1,4),(0,0),(2,2),(-1,3),(-1,2),(1,0),(3,-1),(-1,-1)] *Main> getHall xs [(-1,-1),(3,-1),(2,2),(-1,4),(-4,1)]
14:21:45 <monochrom> um, 4-core and 2-core are apart by an order of magnitude!
14:22:04 <chrisdone> monochrom: huh, weird. i ment to write dual core and wrote "qual" core
14:22:13 <monochrom> ok, then better
14:22:42 <chrisdone> hehe, the edit distance for either are the same
14:25:46 <Tekmo> countoren: Here's the counterexample I found
14:25:53 <Tekmo> > getHall [(3, 3), (3, 0), (2, 1), (1, 1), (0, 0), (0, 3)]
14:25:53 <Tekmo> [(3,3),(3,0),(0,3),(0,0),(1,1)]
14:26:35 * hackagebot xmobar 0.19 - A Minimalistic Text Based Status Bar  http://hackage.haskell.org/package/xmobar-0.19 (JoseAntonioOrtegaRuiz)
14:26:49 <countoren> im getting [(3,3),(3,0),(0,0),(0,3)]
14:27:45 <Tekmo> I'm using the code from your paste, with one minor edit to get it to type-check, which was to modify the second case of `drawConvaxHall` to return `[p1]` to type-check
14:28:27 <countoren> no this was wrong
14:28:31 <countoren> i changed it
14:28:37 <Tekmo> Send me the updated version
14:28:38 <countoren> the first one?
14:28:43 <Tekmo> I only saw one
14:28:48 <countoren> w8
14:29:22 <lpaste> countoren revised “Find Convax Hall”: “Find ConvEx hall ” at http://lpaste.net/94876
14:29:54 <countoren> the same one?
14:30:06 <Tekmo> I see the difference now
14:30:15 <donri> monochrom: isn't an order of magnitude of dual-core 20-core?
14:30:31 <donri> honestly i never quite learn what magnitude is :p
14:30:54 <monochrom> use base-2. 2^n vs 2^(n+1), where n=1 :)
14:31:25 <countoren> yes the diffrance says : when u find one sided line drop all the rotate
14:32:00 <countoren> i think it was that change anyway
14:32:01 <monochrom> normally, people use base-10, "an order of magnitude" means 10^n vs 10^(n+1)
14:32:59 <donri> chrisdone: i have Inf more SSDs than five years ago!
14:34:53 <countoren> im trying to figure out the O of the algorithem
14:35:12 <sipa> donri: is that an absolute or a relative statement?
14:35:48 <donri> no clue
14:45:57 <Tekmo> countoren: Yeah, it looks correct to me now
14:46:09 <Tekmo> countoren: However, it could probably be more efficient
14:46:24 <countoren> where?
14:47:19 <Tekmo> countoren: Well, there's one property you can take advantage of
14:47:30 <Tekmo> countoren: Every point on the convex hull belongs to two lines along the hull
14:47:47 <Tekmo> countoren: So what you can do is just keep moving clockwise along the hull until you return back where you started
14:47:53 <Tekmo> countoren: Then you can eliminate all other points
14:48:27 <countoren> how do u know where to move?
14:48:48 <Tekmo> countoren: So, let's say that you find your first line on the outer hull, made from points p1 and p2
14:49:16 <Tekmo> Then you keep p1 and then begin your search from p2 for its neighbor on the convex hull
14:49:18 <khyperia> carter, fun times. https://dl.dropboxusercontent.com/u/18830644/log.txt
14:49:19 <Tekmo> Let's call that point p3
14:49:28 <Tekmo> Then once you find p3, look for its neighbor, p4
14:49:38 <Tekmo> You keep doing this until you get back to p1
14:49:52 <countoren> yes this what im doing
14:50:23 <countoren> im strating on p1 and p2
14:50:51 <countoren> Tekmo: trying to see if they outer line
14:50:53 <Tekmo> Oh right, I missed that
14:51:07 <countoren> but
14:51:13 <countoren> if i get
14:51:16 <countoren> mistaked
14:51:18 <countoren> i delete
14:51:25 <countoren> the points that are in the moddle
14:51:32 <countoren> which improve my search
14:52:01 <Flonk> What happened to lambdabot?
14:52:15 <countoren> if i strated on middle point
14:52:24 <countoren> all lines
14:52:26 <countoren> should be
14:52:32 <countoren> not outer
14:52:35 <countoren> then
14:52:50 <countoren> then when i get to the last element i drop it
14:52:54 <countoren> and try again
14:53:24 <Tekmo> countoren: I just thought of another way you might be able to do it, although I don't know if it's more efficient
14:53:46 <Tekmo> countoren: You could begin from a single point and keep adding points one at a time
14:53:53 <carter> @hackage llvm-general
14:54:00 <Tekmo> Each time you add a point you check if it is in the interior of the current hull
14:54:01 <lambdabot> http://hackage.haskell.org/package/llvm-general
14:54:21 <Tekmo> If it's in the interior, discard it.  If it's in the exterior, add it to the hull and see if it obsoletes any previous points
14:55:02 <countoren> im doing the dropping of the inner points as well
14:55:04 <countoren> in here
15:00:53 <countoren> i started drawConvaxHall method with iterating on 2 points at a time
15:01:00 <Tekmo> I was doing some quick searching on convex hull algorithms and found an interesting one here: http://en.wikipedia.org/wiki/Ultimate_convex_hull_algorithm
15:01:03 <countoren> which solve oly part of the sultion
15:01:21 <countoren> but it will be 2 time more faster
15:02:59 <lpaste> Locke1689 pasted “expression problem” at http://lpaste.net/94895
15:03:33 <Locke1689> Hey. I'm trying to express an idea in the Haskell type system and have fallen over a little. It's somewhat similar to the expression problem
15:03:56 <Locke1689> Basically, I'd like to express the idea that their exists a set of types called "resources"
15:04:26 <Locke1689> And then there exists a set of types called compilations, which are actually just mappings between resources
15:04:50 <Locke1689> also probably expressible more simply using category theory, but im rusty
15:05:14 <Tekmo> Does it have to use type classes?
15:05:36 <Locke1689> Tekmo: probably, as it should be possible to add instances without recompiling
15:05:51 <Locke1689> Hence the expression problem
15:06:05 <jmcarthur> you can add instances in different modules from the type class
15:06:14 <Tekmo> If you write any code you will have to recompile regardless
15:06:37 <Tekmo> What I was going to suggest was:
15:06:42 <Tekmo> type Resource a = a -> IO Text
15:06:49 <Tekmo> type Compilation a b = Resource a -> Resource b
15:07:09 <Locke1689> hmm
15:07:46 <Tekmo> Or perhaps you might prefer `a` and `b` reversed in `Compilation`
15:07:53 <Tekmo> type Compilation a b = Resource b -> Resource a
15:08:27 <monochrom> Locke1689: the way you define Compilation, the type of compile is: forall b c. (Resource b, Resource c) => a -> b -> IO c. "a" you can choose, "b" and "c" you can't
15:08:34 <Locke1689> maybe, im thinking of the consequences..
15:08:55 <Tekmo> For example:
15:09:01 <Tekmo> readFile :: Resource String
15:09:06 <monochrom> therefore, you cannot pin b=FileSource, c=FileSource
15:09:29 <Tekmo> Technically:
15:09:33 <Tekmo> readFile :: Resource FilePath
15:09:36 <Locke1689> monochrom: this does make sense, and I was wondering if multiparameter type classes would solve this problem
15:09:52 <Locke1689> but I am intrigued by Tekmo's suggestion that I am massively overthinking this
15:09:56 <monochrom> multiparameter type class is an option
15:10:15 <monochrom> but premature generality is evil
15:10:34 <monochrom> until you have two concrete examples, do not invent a generalization
15:10:39 <countoren> Tekmo: correct me if i wrong but i think best time : O(n) wrost : still thinking might be O(n log n)
15:11:06 <Tekmo> countoren: Best case is definitely O(n)
15:11:22 <Tekmo> countoren: I'm not sure about the worst case, though
15:11:51 <Tekmo> Locke1689: Let's say that you ahd a web resource that converted a URL to a FilePath (just for giggles)
15:12:08 <Tekmo> convert :: URL -> IO FilePath
15:12:13 <Tekmo> Then you can convert that into a compilation
15:12:42 <Tekmo> convert' :: Compilation FilePath URL -- or the other way around, depending on which type variable order you prefer
15:12:47 <twiceler> I have a quick question: Say I am often using constraints that look like this: (Class1 a, Class2 a, Class3 a) => ...
15:13:13 <twiceler> But I'd like to essentially make a "synonym" where (Class1 a, Class2 a, Class3 a) => NewClass a
15:13:24 <twiceler> with minimal weird haskell language extensions...
15:13:34 <Tekmo> convert' k url = convert url >>= readFile
15:13:38 <Tekmo> Oops
15:13:41 <twiceler> Is there a best way to do that?
15:13:44 <Tekmo> convert' k url = convert url >>= k
15:14:25 <Tekmo> twiceler: class (Class1 a, Class2 a, Class3 a) => NewClass a where {- blank -}
15:14:53 <twiceler> oh, silly me! Thanks!
15:14:57 <Tekmo> You're welcome! :)
15:14:59 <twiceler> (I forgot the "where")
15:15:08 <Locke1689> Tekmo: Interesting. Let me actually try this (the pasted code is actually a segment of a library, I have a motivating example that I'm building the library from). If the solution falls out naturally that would be great.
15:15:12 <twiceler> (and assumed such things were much more difficult)
15:15:37 <arkeet> and then also write instance (Class1 a, Class2 a, Class3 a) => NewClass a
15:16:10 <arkeet> alternatively, you can turn on ConstraintKinds and just do
15:16:16 <arkeet> type NewClass a = (Class1 a, Class2 a, Class3 a)
15:17:51 <twiceler> arkeet: Thanks!
15:19:00 <twiceler> Tekmo: Wait, it does seem like the Instance declaration makes me require undecideable instances, correct?
15:19:25 <Tekmo> twiceler: I'm not sure.  I'd have to know the specifics of the instance declaration
15:19:41 <twiceler> It's
15:19:42 <twiceler> (Class1 a, Class2 a, Class3 a) => NewClass a
15:19:48 <twiceler> instance
15:20:47 <Tekmo> I tested this out with `Ord` and `Eq` and it worked fine form e
15:21:20 <Rylee> @src ++
15:21:20 <lambdabot> []     ++ ys = ys
15:21:20 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
15:21:20 <lambdabot> -- OR
15:21:20 <lambdabot> xs ++ ys = foldr (:) ys xs
15:21:49 <Tekmo> twiceler: The way you write the instance should be: instance (NewClass a) => SomeOtherClass a where ...
15:23:05 <twiceler> Tekmo: When I try to do:
15:23:16 <twiceler> class (Eq a, Ord a) => NewClass a
15:23:17 <twiceler>  instance (Eq a, Ord a) => NewClass a
15:23:37 <twiceler> GHCi tells me I need to use UndecideableInstances. Which sounds correct.
15:23:46 <elliott> type Newclass a = (Eq a, Ord a) with constraintkinds
15:23:49 <Tekmo> You don't need that instance
15:23:55 <Tekmo> Just remove it
15:23:55 <elliott> undecidableinstances is fine to use here, of course
15:24:06 <elliott> Tekmo: huh?
15:24:13 <twiceler> eliott: Right, I think constraint kinds is the way to go
15:24:16 <monochrom> delete "instance  (Eq a, Ord a) => NewClass a". please just delete it.
15:24:19 <elliott> then you'll need to give NewClass instances for every Eq, Ord
15:24:32 <elliott> (the identical class + instance trick works about as well as ConstraintKinds though, but the latter is cleaner)
15:24:49 <Tekmo> Ooooh, sorry, I misunderstood
15:24:50 <chrisdone> monochrom: check this WIP http://chrisdone.com/structured-haskell-mode.ogv
15:24:53 <Tekmo> Yeah, `elliot` is right
15:25:02 <monochrom> oh, it's meant to be an alias? then ok.
15:25:03 <twiceler> Thanks, elliott.
15:25:32 <chrisdone> Tekmo: let x `elliot` y = right
15:27:24 <chrisdone> monochrom: 'case it wasn't obvious, the red backround means the current node doesn't parse
15:28:09 <countoren> Tekmo: Thanks man.
15:28:14 <chrisdone> monochrom: the light background indicates the current node, and you use that to copy/cut that node, or to indent off of it
15:28:15 <Tekmo> countoren: You're welcome!
15:29:17 <tomejaguar> How do I export all names from my module, plus one name from an imported module?
15:29:29 <countoren> Tekmo: only one question what did u meant with partial functions?
15:29:42 <Tekmo> countoren: A partial function is a function that is not defined for all possible inputs
15:29:53 <Tekmo> countoren: A simple example is the `head` function which is not defined for the empty list
15:30:05 <countoren> had it in the code?
15:30:05 <chrisdone> tomejaguar: export the module itself
15:30:19 <Tekmo> tomejaguar: You need an explicit re-export list
15:30:32 <chrisdone> module X (module X ,Y.y) where
15:31:26 <tomejaguar> Ah yes "module Foo where ( module Foo, bar, baz )"
15:31:36 <tomejaguar> thanks chrisdone and Tekmo
15:31:38 <chrisdone> Tekmo: you can re-export the module name. it's neat trick i discovered recently
15:31:45 <Tekmo> I never knew that
15:31:50 <chrisdone> me neither! :D
15:31:58 <oldthird_> hey guys, i've keep getting dependency issues when i try to install yesod. I've been at it for 3 hours but with no success.  Can someone help me out?
15:32:24 <Tekmo> oldthird_: Have you installed the Haskell platform first?
15:32:25 <tomejaguar> Tekmo, chrisdone: See 5.32 item 5 on http://www.haskell.org/onlinereport/modules.html
15:32:32 <tomejaguar> *5.2 item 5
15:32:46 <oldthird_> yes i've installed the haskell platform
15:32:49 <monochrom> chrisdone: the adjustment of indentation is the most impressive!
15:33:14 <countoren> Tekmo: if u have time, i will really appreciate  if u could send me more organised version of my code.
15:33:29 <Tekmo> countoren: Alright, one second
15:34:52 <Tekmo> countoren: One other thing: you should really use spaces instead of tabs
15:35:18 <carter> or an editor that replaces tabs with space
15:35:37 <countoren> ye heard this b4 , i guess i need to configure my vim to handle spaces instead of tabs
15:35:43 <monochrom> if you insist on using tabs, there is still a way. begin by not trusting your editor.
15:35:43 <chrisdone> monochrom: yeah, i especially like that feature. oddly, for a 90% solution, you don't even need a parser
15:35:44 <arkeet> :set expandtab
15:36:00 <carter> chrisdone: looks need
15:36:11 <carter> neat
15:36:20 <lpaste> chrisdone pasted “simple indentation adjustment” at http://lpaste.net/94896
15:36:23 <arkeet> also 'listchars' is a good vim setting
15:36:44 <chrisdone> monochrom: do you know any elisp? i can make some trivial code to get you off the ground with auto-adjustment
15:36:57 <monochrom> I don't know any elisp
15:37:16 <Peaker> monochrom: by virtue of (probably?) knowing Scheme/CL, you probably know a lot of elisp
15:37:35 <chrisdone> monochrom: that's cool, hold up
15:37:40 <monochrom> yes. it means I don't know any of the free variables
15:38:13 <monochrom> I don't even know who are macros and who are not macros. (my biggest gripe with all you fanciful macro systems)
15:38:58 <monochrom> what Babara Liskov says. extensible syntax ==> I don't know how to read it
15:40:24 <lpaste> chrisdone annotated “simple indentation adjustment” with “how to use” at http://lpaste.net/94896#a94897
15:41:30 <chrisdone> monochrom: i extracted out hopefully a minimal case that you should be able to try. the trick is that it rebinds the self-insert command. so hitting any self-insert key like letters, space, etc. will first adjust any "dependent" code below forwards. and you also rebind your backspace key (DEL) to adjust backwards
15:42:40 <chrisdone> monochrom: if you want to reset it, you can just remap self-insert-command back to 'self-insert-command and DEL to delete-backward-char. if it doesn't work i'll try it on emacs -Q
15:43:35 <monochrom> I can't try it now. I'll try it later.
15:44:01 <chrisdone> k =)
15:44:37 <FreeFull> Is there a channel for parsec/parser combinators?
15:44:47 <monochrom> this one
15:44:51 <Fuuzetsu> Not that I know of and I'm sure I'd have heard about it before.
15:44:59 <chrisdone> monochrom: if it's acceptable for you (it *is* a 90% solution -- it has 10% where it's insufficient), i can add it to haskell-mode vanilla
15:46:15 <chrisdone> (it can be a bit cleverer with ast info)
15:46:42 <chrisdone> Peaker: you wanna try that?
15:47:12 <FreeFull> " If <character> in #\<character> is alphabetic, then the character following <character> must be a delimiter character such as a space or parenthesis."   Is there a way of parsing the delimiter without consuming it?
15:47:13 * Fuuzetsu wishes for haskell-mode that's not extremely slow on few hundred line files
15:47:48 <ryanakca> merijn: Alright, thanks for the advice re: extensions
15:48:13 <monochrom> you may like lookAhead
15:48:28 <Peaker> chrisdone: I wasn't following the whole discussion, what is the topic?
15:49:16 <FreeFull> Thanks
15:49:19 <t4nk584> Can someone help me?
15:49:23 <t4nk584> with some haskell
15:49:33 <simpson> Presumably, yeah.
15:49:35 <Fuuzetsu> @justask
15:49:35 <lambdabot> Unknown command, try @list
15:49:38 <Fuuzetsu> hmm
15:49:43 <geekosaur> @where justask
15:49:43 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
15:49:44 <Fuuzetsu> Well whatever, just ask your question.
15:49:46 <chrisdone> Fuuzetsu: what about haskell-mode has to be fast?
15:50:02 <monochrom> Peaker: http://chrisdone.com/structured-haskell-mode.ogv
15:50:03 <chrisdone> Peaker: the auto-indentation-adjusting script i pasted
15:50:32 <Fuuzetsu> chrisdone: Syntax highlighting makes editing large-ish Haskell files absolutely unbearable: you have to wait seconds every time you press return or tab.
15:50:54 <Fuuzetsu> (1.8Ghz Core 2 Duo)
15:50:54 <monochrom> I am slow. I don't notice waiting.
15:51:16 <chrisdone> huh? really?
15:51:23 <Peaker> chrisdone: how do you do the online parsing?
15:51:24 <chrisdone> Fuuzetsu: that's really, really weird
15:52:01 <carter> Fuuzetsu: what editor / syntax highligher?
15:52:03 <Peaker> chrisdone: video looks awesome :)
15:52:04 <Fuuzetsu> Really? I thought everyone just like, lived with it.
15:52:25 <Fuuzetsu> carter: emacs, haskell-mode's own highlighting (the large pile of regex)
15:52:28 <monochrom> perhaps you are really really fast
15:52:44 <carter> Fuuzetsu: patch it and give them a pull request :)
15:53:19 <Fuuzetsu> I was actually at point few weeks ago where I was going to just scrap that highlighting and write one something along the lines of Agda-mode's which uses the compiler. At least it'd be correct and wouldn't crap out on extensions.
15:53:41 <Fuuzetsu> carter: I think it's beyond patchable at this point…
15:53:51 <t4nk584> need help to build a graphical user interface
15:53:52 <carter> Fuuzetsu: ok then do that
15:53:57 <chrisdone> Peaker: it parses with HSE the whole declaration on the first go, makes a bunch of emacs markers for all the node boundaries along with the associated node types (and constructor). subsequently any edits are re-parsed local to the node's span, delimited by the markers. this lets you have invalid parses littered about your decl but structural operations still working otherwise
15:53:57 <monochrom> calling up ghc to help you highlight is going to be slower
15:53:57 <chrisdone> Peaker: it's a rewrite / newer approach to my old version which only parsed the whole declaration and didn't use markers, so, despite being usable full time, would break often
15:54:01 <t4nk584> no idea how..
15:54:34 <Peaker> chrisdone: sounds great
15:54:40 <Tekmo> countoren: Here you go: data Turn = LeftTurn | RightTurn | Straight deriving (Show, Eq)
15:54:41 <Fuuzetsu> monochrom: Yes, slower, but not painfully unusable for anything >400 lines or so.
15:54:43 <Tekmo> type Point = (Integer, Integer)
15:54:45 <Tekmo> type LinePoint = Point
15:54:48 <Tekmo> getTurn :: LinePoint -> LinePoint -> Point -> Turn
15:54:50 <Fuuzetsu> And correct which is nice.
15:54:50 <Tekmo> getTurn lp lp2 p
15:54:53 <Tekmo> 	| detOfVectors vectors > 0 = LeftTurn
15:54:55 <Tekmo> 	| detOfVectors vectors < 0 = RightTurn
15:54:58 <Tekmo> 	| otherwise = Straight
15:55:00 <Tekmo> 		where
15:55:03 <Tekmo> 			moveAxisToPoint (x,y) = map (\(p1,p2) -> (p1-x, p2-y))
15:55:05 <Tekmo> 			detOfVectors [(a,b),(c,d)] = (a*d) - (c*b)
15:55:07 <Peaker> chrisdone: any chance you'll be around here about 17 hours from now?
15:55:08 <Tekmo> 			vectors = moveAxisToPoint lp [lp2,p]
15:55:10 <Tekmo> getHall :: [Point] -> [Point]
15:55:13 <Tekmo> getHall xs = drawConvaxHall xs []
15:55:13 <geekosaur> why are ypu pasting in channel
15:55:15 <Tekmo> 	where
15:55:15 <Fuuzetsu> I was quite literally turning off haskell-mode every time I went into the test-suite file I was working with.
15:55:18 <Tekmo> 	   drawConvaxHall [] [] = []
15:55:20 <Tekmo> 	   drawConvaxHall [p1] [] = [p1]
15:55:22 <Fuuzetsu> @where lpaste
15:55:22 <lambdabot> http://lpaste.net/new/haskell
15:55:23 <Tekmo> 	   drawConvaxHall [p1] rotate  = drawConvaxHall rotate []
15:55:23 --- mode: ChanServ set +o geekosaur
15:55:25 <Tekmo> 	   drawConvaxHall (p1:p2:ps) rotate
15:55:28 <Tekmo> 			| isAllOneSide p1 p2 xs = p1 : drawConvaxHall (p2:ps) []
15:55:28 <Peaker> chrisdone: I'd love to try this and give feedback!  But I need to go to sleep soon
15:55:29 --- kick: Tekmo was kicked by geekosaur (Tekmo)
15:55:42 <t4nk584> http://lpaste.net/8738516288365658112
15:55:51 <t4nk584> is this a graphical interface?
15:56:09 --- mode: geekosaur set -o geekosaur
15:56:11 <Tekmo> Sorry about that
15:56:15 <Tekmo> I meant to paste an lpaste link
15:56:28 <chrisdone> Peaker: i added you as contributor to the (private) project in case you want to look at it. it's a from-scratch rewrite of my private version, only spend a couple days on it, so don't expect much to work or for it to be usable
15:56:41 <jophish> Yo yo yo
15:56:43 <Peaker> Tekmo: hmm.. xchat paste will show me what I'm about to paste (including newlines)
15:56:50 <chrisdone> Peaker: yeah, i'm heading to bed soon, too =)
15:56:52 <Fuuzetsu> How do I specialise type signatures in lambdabot again? some function
15:57:01 <Peaker> chrisdone: cool, thanks!! :) good night
15:57:04 <Tekmo> irssi just asked me "Do you really want to paste?".  I didn't understand that was a warning that the paste was too big
15:57:09 <Fuuzetsu> like, asTypeIn or something
15:57:19 <jophish> I can do: liftM2 (||) a b, to get the function f x = a x || b x
15:57:22 <Tekmo> Technically teh error was more opaque
15:57:30 <jophish> how can I get a x || b x || c x in a nice way?
15:57:30 <Tekmo> It was like "Press Ctrl-K to paste or Ctrl-C to abort"
15:57:37 <bennofs> @ty asTypeOf
15:57:39 <lambdabot> a -> a -> a
15:57:41 <Tekmo> And I thought "Why would I want to abort?"
15:57:45 <bennofs> @ty asAppliedTo
15:57:46 <lambdabot> (a -> b) -> a -> a -> b
15:57:47 <geekosaur> liftM3?
15:58:09 <Fuuzetsu> I want to specialise map to mapping over a String
15:58:10 <bennofs> Fuuzetsu: ^^ that?
15:58:15 <Fuuzetsu> :t map
15:58:15 <Tekmo> Anyway, I forgot the name of the guy who requested the cleaned up code
15:58:16 <lambdabot> (a -> b) -> [a] -> [b]
15:58:20 <Tekmo> But the lpaste is here: http://lpaste.net/94898
15:58:21 <Fuuzetsu> where a becomes Char
15:58:22 <carter> Tekmo: lpaste.org is a think
15:58:24 <countoren> me
15:58:26 <carter> *thing :)
15:58:28 <countoren> sry
15:58:35 <Tekmo> carter: I'm aware of that
15:58:39 <carter> :)
15:58:40 <Tekmo> carter: I was trying to paste an lpaste link
15:58:44 <bennofs> :t map `asAppliedTo` (id `asAppliedTo` 'c')
15:58:45 <lambdabot> (Char -> Char) -> [Char] -> [Char]
15:58:53 <Fuuzetsu> thank you
15:58:58 <Tekmo> carter: But I still had the file contents in my clipboard and didn't correctly copy the lpaste link
15:58:59 <countoren> thanks
15:59:02 <carter> hhe
15:59:04 <Tekmo> countoren: You're welcome
15:59:09 <Fuuzetsu> aww my local lambdabot doesn't have these
15:59:12 <geekosaur> jophish, liftM3?
15:59:15 <bennofs> :t map `asAppliedTo` (undefined :: Char -> Char)
15:59:17 <lambdabot> (Char -> Char) -> [Char] -> [Char]
15:59:29 <chrisdone> Peaker: welcome! g'night!
15:59:33 <Fuuzetsu> what was asAppliedTo? const?
15:59:37 <bennofs> :t \f -> map (f :: Char -> Char)
15:59:38 <lambdabot> (Char -> Char) -> [Char] -> [Char]
15:59:42 <geekosaur> Fuuzetsu, yes
15:59:51 <jophish> geekosaur, but (||) only takes two arguments
15:59:58 <geekosaur> nn, point
16:00:01 <jophish> and or takes a list
16:00:01 <geekosaur> mm, point
16:00:06 <geekosaur> not thinking right...
16:00:22 <bennofs> Fuuzetsu: But why not just write "map :: (Char -> Char) -> [Char] -> [Char]" ? (Or map (f :: Char -> Char))
16:00:23 <jophish> @pl f x = a x `or` b x `or` c x
16:00:23 <lambdabot> f = ap (or . liftM2 or a b) c
16:00:30 <jophish> @pl f x = or [a x, b x, c x]
16:00:33 <lambdabot> f = fix (const (or . ap ((:) . a) (ap ((:) . b) ((: []) . c))))
16:00:34 <lambdabot> optimization suspended, use @pl-resume to continue.
16:01:00 <FreeFull> $ doesn't really save you from parentheses when you are using infix operators
16:01:26 <bennofs> jophish: that is or $ map ($ x) $ [a,b,c]
16:02:02 <Tekmo> Are a, b, and c lists?
16:02:14 <bennofs> @ty \x -> or $ sequence [a,b,c] x
16:02:15 <lambdabot>     Couldn't match expected type `t0 -> Bool' with actual type `Expr'
16:02:15 <lambdabot>     In the expression: a
16:02:15 <lambdabot>     In the first argument of `sequence', namely `[a, b, c]'
16:02:23 <Tekmo> Oh wait, why are you using `or` as an infix operator?
16:02:53 <jophish> Tekmo, a b and c are functions :: a -> Bool
16:02:58 <FreeFull> Fuuzetsu: asAppliedTo is just flipped const with a constrained type signature
16:03:09 <jophish> ah, I meant ||
16:03:10 <FreeFull> Actually, it's not flipped
16:03:24 <FreeFull> @src asAppliedTo
16:03:24 <lambdabot> Source not found.
16:03:25 <Tekmo> jophish: any ($ x) [a, b, c]
16:04:00 <jophish> Tekmo, ah, of course!
16:04:01 <jophish> Thanks
16:04:05 <Tekmo> You're welcome! :)
16:04:07 <FreeFull> :t let applied :: a -> a -> a; applied a b = a; in map `applied` (undefined :: Char -> Char)
16:04:08 <lambdabot>     Couldn't match type `Char' with `a0 -> b0'
16:04:09 <lambdabot>     Expected type: (a0 -> b0) -> [a0] -> [b0]
16:04:09 <lambdabot>       Actual type: Char -> Char
16:04:24 <FreeFull> Oh, right
16:04:26 <bennofs> applied :: (a -> b) -> a -> a
16:04:32 <bennofs> -> b
16:05:08 <FreeFull> :t asAppliedTo
16:05:09 <lambdabot> (a -> b) -> a -> a -> b
16:05:43 <FreeFull> :t let applied :: (a -> b) -> a -> a -> b; applied f a b = f a; in map `applied` (undefined :: Char -> Char)
16:05:44 <lambdabot> (Char -> Char) -> [Char] -> [Char]
16:05:51 <FreeFull> That works
16:06:36 <FreeFull> Might not have the same semantics
16:06:39 <bennofs> FreeFull: but applied f a b = f a is wrong. IIRC it should be applied f a b = f b or applied f a = f
16:06:49 <FreeFull> Yeah
16:07:00 <FreeFull> So it is flipped const with function application
16:07:03 <bennofs> applied = const
16:07:27 <FreeFull> @pl \f a b -> f b
16:07:27 <lambdabot> const
16:07:32 <FreeFull> Huh
16:07:36 <bennofs> @ty const `asAppliedTo` (undefined :: a -> b)
16:07:37 <lambdabot> (a -> b1) -> b -> a -> b1
16:07:50 <FreeFull> So if you flapply const you get const
16:08:48 <FreeFull> Same how $ is infix id
16:11:54 <khyperia> Strange question: Is there a simple way to interpret haskell from python? Basically, in some other channel I'm in, theres a python-based bot, and I'd like to submit a command that lets one eval haskell stuff.
16:12:24 <hpc> khyperia: do you want real embedded haskell, or would mueval work?
16:13:03 <khyperia> I'm not sure what the difference is, but basically just lambdabot's ">" thing.
16:13:20 <tomejaguar> khyperia: Why not just use lambdabot?
16:13:21 <hpc> that's mueval
16:13:50 <hpc> it's pretty simple to use, just a system call with some params
16:14:15 <khyperia> right, thanks!
16:14:55 <khyperia> tomejaguar, because (wild guessing here) lambdabot might not be so easy to hook into as an api. I'm guessing it's oriented around being a bot itself.
16:15:16 * geekosaur points to goa
16:18:16 <hpc> lambdabot's not so easy even when you do use it as intended
16:19:26 <geekosaur> true. I don't particularly miss nursemaiding a customized lambdabot
16:21:10 * FireFly wrote a kinda evil thing for his bot that simply /msg's another bot with a command and awaits its reply, and then relays the reply to the channel where it was run from
16:21:40 <FireFly> thus borrowing lambdabot's Haskell eval without much work on my part
16:21:41 <srhb> FireFly: "kinda" evil... :P
16:22:04 <FireFly> Haha, but it's a small and private channel, so there's no bot abuse
16:22:16 <FireFly> and also there's a whitelist, so it can't just msg anyone
16:24:08 <jophish> Is there a way to read a file into lines (or words) in one line?
16:24:40 <tomejaguar> Maybe there should just be LBaaS (lambdabot as a service) over HTTP with a RESTful API.
16:25:37 <khyperia> jophish, possibly "readFile file >>= return . lines"... there's probably a better way, but...
16:25:47 <geekosaur> fmap
16:26:09 <khyperia> fmap lines (readFile file)?
16:26:30 <geekosaur> or <*>
16:26:32 <jophish> awww yiss
16:26:44 <jophish> I love this channel so much, thanks guys
16:27:04 <srhb> geekosaur: <$> right?
16:27:14 <khyperia> Yeah, I think <$>
16:27:19 <geekosaur> khyperia, any time you have monadic_action >>= return . f, you can fmap f over the action instead
16:27:27 <geekosaur> yes, sorry
16:27:32 <mauke> that's because >>= return . is liftM and liftM is fmap
16:27:39 <elliott> geekosaur: fsvo "any" :(
16:27:56 <Peaker> (or any "any" if you're from the future)
16:28:38 <khyperia> @pl \file -> lines <$> readFile file
16:28:38 <lambdabot> (lines <$>) . readFile
16:28:43 <srhb> I hear it will only take about a month to time travel to that point.
16:29:20 <khyperia> eh, pointless is pointless.
16:30:11 <srhb> khyperia: lines <$> readFile -- just fine?
16:30:20 <srhb> erh, missing an "f" there
16:30:28 <khyperia> I... don't think so
16:30:37 <khyperia> but I'm not sure
16:30:58 <khyperia> :t lines <$> readFile
16:30:59 <lambdabot>     Couldn't match type `IO String' with `String'
16:30:59 <lambdabot>     Expected type: FilePath -> String
16:30:59 <lambdabot>       Actual type: FilePath -> IO String
16:31:12 <khyperia> :t \file -> lines <$> readFile file
16:31:13 <lambdabot> FilePath -> IO [String]
16:31:34 <khyperia> since the right side is "in parentheses", function application happens before <$>
16:32:06 <srhb> khyperia: Sorry, I didn't realize what you were getting at.
16:32:24 <srhb> khyperia: It doesn't get nicer than fmap lines . readFile then, no
16:32:43 <khyperia> yep... but still, that's pretty dang nice :P
16:32:48 <srhb> Yeah, sure. :)
16:33:01 <josh`> I was looking at the FP Complete conduit tutorial (https://www.fpcomplete.com/user/snoyberg/library-documentation/conduit-overview#monadic-chaining). Should the recursive call follow the case? Or does no upstream data is available imply that it will never become available?
16:33:55 <khyperia> Heh, I heard people say "<$> is just infix fmap", but I thought it was more abstract and not *literally* "f <$> a = fmap f a"
16:34:35 <srhb> khyperia: Much the same as with peoples' confusion with $ at first :-)
16:34:49 <srhb> "But it's just function application! No, really!"
16:34:51 <lpaste> argiopetech pasted “Lens build failure -- 7.7-20131025” at http://lpaste.net/94899
16:35:09 <edwardk> lens and GHC HEAD aren't currently compatible
16:35:49 <khyperia> While we're on the topic of simple things that are difficult to understand... arrows? I saw this somewhere - "do [...] x <- foo -< bar; [...]", what does that mean? Or, alternatively, link a good tutorial for that?
16:36:03 <srhb> khyperia: The wikibook is ok for the very basics
16:36:06 <argiopetech> edwardk: Answered that question.
16:36:07 <argiopetech> Thanks
16:37:15 <srhb> khyperia: But you'll only really ever see (&&&) in my experience. Unless you're into some arcane stuff.
16:37:18 <argiopetech> edwardk: Do you intend for that to be remedied by the time 7.8 is released?
16:37:33 <edwardk> hoping to, yes =)
16:37:48 <monochrom> khyperia: don't learn arrows now. it's advanced, and less used.
16:37:55 <jophish> What's the preferred data type to store values with the range [0..0xff]
16:38:00 <jophish> Word8?
16:38:09 <khyperia> right.
16:38:13 <simpson> jophish: I'd use Word8.
16:38:21 <argiopetech> jophish: Seems reasonable.
16:38:22 <carter> jophish: word8 is kinda designed for that
16:41:02 <lpaste> irene-knapp pasted “Fidgicky conduits problem” at http://lpaste.net/94900
16:41:13 <irene-knapp> Assistance appreciated in advance :)
16:41:42 <irene-knapp> So what I'm trying to do is turn this complicated thing into a conduit
16:42:13 <irene-knapp> using a primitive (also written by me, so I could modify it if I could figure out how) which takes a function from a network socket to a monadic action
16:42:36 <jophish> How can I generate the list of all possible Word8s: [0..0xff]::[Word8]
16:42:38 <irene-knapp> and runs that function multiple times, representing multiple sessions, retrying forever (but with exponential backoff and stuff)
16:42:47 <irene-knapp> @hoogle Ix
16:42:48 <lambdabot> Data.Ix module Data.Ix
16:42:48 <lambdabot> Data.Ix class Ord a => Ix a
16:42:48 <lambdabot> package ix-shapable
16:42:55 * FireFly secretly replaces Arrow a => a b c with b -> c in his mind when reading Arrowy type signatures
16:42:55 <irene-knapp> jophish: look at Data.Ix
16:43:40 <carter> jophish: [0..0xff]::[Word8] should work
16:44:01 <irene-knapp> oh yeah.  or that :)
16:44:11 <redscare> I am having trouble seeing when i could /not/ use an applicative/alternative style instead of a monadic style
16:44:36 <jophish> ah, that actually workd
16:44:39 <jophish> works*
16:44:49 <carter> redscare: when you write a context sensitive parse
16:44:50 <carter> *parse
16:44:51 <carter> r
16:45:00 <carter> or "context sensitive action thingy"
16:45:04 <jophish> Hoogle's first suggestion for Word8->Char is unsafeCoerce...
16:45:18 <carter> jophish: fromIntegeral may work too
16:45:24 <redscare> carter: i've looked into that, and it seems possible. I was thinking there'd be a simple example with something like "IO", but i haven't found it
16:45:52 <jophish>  carter no instance for Num Char
16:45:53 <carter> redscare: its like "i will do an arbitary Eval before the next step, using the given moandic value"
16:46:06 <carter> jophish: what does Data.Char have/
16:46:07 <redscare> my intuition is that since bind has "a -> m b" and <*> only has "m (a->b)" I shouldn't be able to do anything that "modifies" the monad, but that isn't accurate
16:46:08 <carter> ?
16:46:31 <elliott> redscare: do { s <- getLine; putStrLn s }
16:46:42 <carter> redscare: bind :: M a -> (a-> M b)-> M b
16:47:08 <edwardk> redscare: you can't 'pick what is going to happen next' in an applicative if that is what you mean
16:47:08 <jophish> carter, chr . fromIntegral works
16:47:10 <carter> "evaluate an AST M that results in a term of type a, then use a to build a new AS thingy"
16:47:15 <carter> jophish: woot
16:47:27 <carter> jophish: what character encoding? :P
16:47:28 <edwardk> redscare: in a monad you can change the 'shape' of future calculations, in an applicative you can't
16:47:32 <carter> yes
16:47:39 <carter> which means applicatives let you do some reallynice things
16:47:45 <carter> like have paralleism
16:47:55 <jophish> carter, I don't know and I don't care :)
16:48:14 <carter> applicatives were only "discovered" in the past 5 years I think
16:48:26 <carter> so thats why theres few applicative tutorials than monad tutorials :P
16:48:58 <monochrom> (chr :: Int -> Char) . (fromIntegral :: Word8 -> Int)
16:49:00 <redscare> edwardk: this is the sort of answer I was kind of looking for and thought I understood, but this is confusing me since i do not understand how we can do parsing with applicatives since we still need to modify the parsing state as we go?
16:49:40 <edwardk> redscare: the trick there is Alternative gives you a little bit of 'this or that' control flow
16:49:49 <carter> yeha
16:49:55 <carter> *yeah
16:49:59 <edwardk> redscare: with a monad you can do anything with _any_ function from a -> m b    with Alternative you can simply provide a fallback path.
16:50:38 <edwardk> technically for input 'alphabets' that are finite you can parse a full context sensitive grammar with an Alternative.
16:51:16 <FreeFull> I like making the constraints as general as possible, to minimise what the code can do
16:51:22 <edwardk> this was shown by nils anders danielsson in http://www.cse.chalmers.se/~nad/publications/danielsson-parser-combinators.html
16:51:36 <edwardk> video here: https://vimeo.com/16541551
16:51:52 <edwardk> FreeFull: thats pretty much the only way i work these days =)
16:52:07 <edwardk> FreeFull: e.g. its easier to write indexed monads than normal ones, because you can't screw up
16:52:28 <edwardk> FreeFull: generally all the alternative definitions that almost work or seem like they could won't typecheck
16:52:35 <redscare> edwardk, carter: so is there some kind of intuition that says "this is what you CAN'T do with applicatives"? because it seems like simply MODIFYING the computational context is possible
16:52:43 <obliviousnesss04> irene-knapp: 1
16:52:56 <redscare> it just seems to me like the things you can do with monads are few and far between, relatively speaking, but i know this is wrong
16:52:56 <carter> redscare: then it'd probably break the applicative laws
16:53:01 <FreeFull> edwardk: Also lets your code work with more inputs than it would otherwise
16:53:17 <redscare> carter: so my example is that in parsing, you consume the input, and by doing so "modify" the context
16:53:52 <FreeFull> There probably are more Alternatives than MonadPluses (because there are more Applicatives than Monads)
16:53:56 <edwardk> redscare: if you stick to finite 'trees' of terms with applicatives then you can only parse context-free grammars, if you allow infinite trees then you can do context sensitivity, but only by splitting the input up by a series of predicates. this requires effectively the abilty to partition the input domain, if you have an uncountable alphabet you can't do this
16:54:10 <edwardk> redscare: the monadic code can also be much clearer in that case
16:54:31 <FreeFull> I don't know of any Alternative that isn't a MonadPlus, but everything with a MonadPlus instance will have a valid Alternative instance
16:54:46 <edwardk> redscare: note that 'modifying the context' required alternative, not just applicative.
16:55:02 <edwardk> redscare: while with a monad you can make different decisions without monadplus
16:55:22 <redscare> edwardk: do you /need/ alternative?
16:55:37 <edwardk> a straight line chunk of applicative code is just that, basically its a tree with a sort of annotation.
16:55:59 <edwardk> sure
16:56:07 <FreeFull> You can use Alternative or Monad, Alternative is better when it fits though
16:56:43 <redscare> maybe an example will make my confusion clearer: if i write "endOfLine *> rational", i don't use anything besides applicative, but i modify the "context" since endOfLine must consume input to give me a rational, which is then also consumed
16:56:55 <redscare> so it seems like I am modifying context but don't need a monad
16:57:12 <FreeFull> > [3,4] *> [5,6,7]
16:57:13 <lambdabot>   [5,6,7,5,6,7]
16:57:15 <edwardk> you can parse endOfLine *> rational with a context-free parser
16:57:47 <edwardk> capturing an identifier and then using it later on the other hand is harder
16:58:11 <jophish> I've written a small program to break a code. It would be really nice to tidy it up a little bit.
16:58:25 <jophish> Would someone be able to make sure I'm writing idiomatic Haskell here: http://lpaste.net/94901
16:58:31 <arkeet> redscare: the difference between Applicative and Monad, intuitively, is that
16:58:39 <jophish> Or say if there's anything which can be made a little neater
16:58:42 <arkeet> redscare: Monad lets actions depend on results of other actions.
16:58:45 <arkeet> Applicative does not.
16:59:08 <redscare> edwardk: but it's doable, isn't it? since I can do something like (\x -> if x == a then Just a else Nothing) <$> parseA <|> parseB
16:59:19 <edwardk> that requires <|> which is in alternative.
16:59:19 <redscare> this is making a decision, is it not?
16:59:38 <edwardk> you can 'stop' but you can't restart down another path with applicative alone
16:59:56 <redscare> edwardk: but not monad :) I know i'm being frustrating, thanks for staying with me
16:59:58 <edwardk> my point above was that for a finite alphabet they are equivalent in power.
17:00:06 <edwardk> for a larger alphabet they are not
17:00:28 <edwardk> the benefit of the applicative approach is you can introspect on the entire tree, because the shape of it is determined in advance
17:00:39 <edwardk> the benefit of the monadic approach is it is often vastly simpler to write
17:01:25 <redscare> edwardk: so could you give an example of something that could only be written monadically?
17:01:48 <redscare> I saw your IO example above, perhaps another one like that or maybe something from another monad
17:02:29 <edwardk> do x <- getLine; readFile x
17:03:00 <redscare> this seems very similar to your previous one :)
17:03:09 <razieliyo> may this become somehow unsafe? data Type1 = Type1C | Nil, data Type2 = Type2C | Nil
17:03:18 <razieliyo> I mean because both Nil's
17:03:29 <elliott> redscare: consider parsing a heredoc
17:03:34 <elliott> you read a string to use as a delimiter
17:03:40 <edwardk> do x <- identifier; symbol '*'; keyword x  -- parse any identifier, then a *, then the same identifier
17:03:42 <elliott> and then slurp up all the text until the next occurrence
17:03:45 <elliott> yeah, like what edwardk said
17:04:09 <monochrom> razieliyo: that name clash is a syntax error.
17:04:10 <FreeFull> getLine <*> readFile  will work for the first one I think
17:04:20 <edwardk> FreeFull: nope
17:04:24 <edwardk> :t getLine <*> readFile
17:04:25 <lambdabot>     Couldn't match type `[Char]' with `a0 -> b0'
17:04:25 <lambdabot>     Expected type: IO (a0 -> b0)
17:04:25 <lambdabot>       Actual type: IO String
17:04:30 <FreeFull> Actually, wrong way around
17:04:48 <edwardk> FreeFull: if you can write it with applicative alone i'll buy you a beer
17:04:56 <FreeFull> Ah, you're right
17:04:57 <razieliyo> monochrom: hm, fine, so I have to diferentiate between both
17:05:11 <edwardk> you would have also fundamentally changed my world view
17:05:48 <FreeFull> I could do IO (IO String)  but that doesn't help
17:06:04 <monochrom> a beer from edwardk is like a cheque from Knuth. you don't spend it. you keep it. except that beer is harder to keep. :)
17:06:20 <edwardk> Monad is fundamentally about the ability to reduce m (m a) to m a is kinda what the Monad is for ;)
17:06:33 <FreeFull> Yeah
17:06:37 <zugz> is there a way to make this kind of lazy use of 'forever' work: take 5 $ forever $ getStdRandom $ random
17:06:43 <FreeFull> fmap, join, return
17:07:13 <FreeFull> I can see why people like bind but some monads are easier to implement in terms of fmap and join
17:07:39 <monochrom> @type getStdRandom random
17:07:39 <lambdabot> Random a => IO a
17:07:47 <edwardk> i often write the join first, then go back and fuse in the definition of fmap when i'm not smart enough to derive it in one go
17:08:25 <FreeFull> Reader is probably easier to write in terms of fmap and join than in terms of bind
17:08:25 <obliviousnesss04> frivol: 1
17:08:57 <FreeFull> join f x = f x x
17:09:16 <FreeFull> fmap = (.)
17:09:26 <geekosaur> obliviousnesss04, fix your bot
17:09:27 <monochrom> zugz: I suggest instead (take 5 . randoms) <$> newStdGen
17:10:08 <geekosaur> actually I have evidence from other channels that it is just a bot, but I'm being nice
17:10:26 <FreeFull> return = const
17:10:52 <FireFly> Weren't there something earlier today in here going "nick: 1" like that?
17:10:57 <geekosaur> yes
17:11:09 <geekosaur> same source subnet. also in some other channels I'm in
17:11:17 <FireFly> Ah
17:11:32 <geekosaur> shortly after the nick it echoes joins or parts, no obvious other relationship
17:11:49 <arkeet> it seems to always say that after a part
17:11:51 <arkeet> also
17:11:53 <arkeet> @where ops
17:11:53 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver
17:11:53 <lambdabot>  roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
17:11:58 <geekosaur> yep
17:12:05 <geekosaur> that'd be why I am tracking it :)
17:12:23 <arkeet> dpesm
17:12:26 <arkeet> doesn't respond to CTCPs
17:13:16 <zugz> monochrom: yeah, that wasn't a real problem... but I'm just curious how to have a list of monadic values which get evaluated (with side-effects happening) only on-demand... lazy file IO does it, is where the "unsafe interleaved IO" comes in?
17:13:17 <geekosaur> wait, subnet owned by the owner of hidemyass?
17:13:23 --- mode: ChanServ set +o geekosaur
17:13:33 <Tekmo> zugz: ListT
17:13:33 --- mode: geekosaur set +b *!*@185.25.84.*
17:13:38 <Tekmo> zugz: `pipes` provides this
17:13:39 <elliott> geekosaur: 1
17:13:53 <zugz> Tekmo: ta, I'll look into it
17:13:57 --- kick: obliviousnesss04 was kicked by geekosaur (obliviousnesss04)
17:14:03 <monochrom> yes, that needs unsafeInterleaveIO
17:15:04 --- mode: geekosaur set -o geekosaur
17:15:19 <monochrom> @type forever
17:15:20 <lambdabot> Monad m => m a -> m b
17:15:29 <monochrom> but forever is useless for this
17:15:46 <Tekmo> zugz: If you tell me the exact problem I can write up the code for you
17:16:23 <arkeet> oh I forgot geekosaur was an op.
17:17:44 <zugz> Tekmo: well I was actually writing a cheap dirty shuffle function: though I'm sure there are better ways of going about it, nubbing an infinite list of randomly generated indices was the first thing that came to mind
17:18:11 <Tekmo> zugz: I have a Fisher-Yates shuffle sitting around that you can use
17:18:12 <zugz> Tekmo: but I'm not sure how to get such an infinite list (while  advancing the state of the RNG appropriately)
17:18:41 <Tekmo> https://github.com/Gabriel439/suns-search/blob/master/src/Shuffle.hs
17:19:04 <zugz> Tekmo: ta, but I'm still interested in the question... would ListT help?
17:19:56 <Tekmo> zugz: I think `monochrom`'s solution was pretty good
17:20:18 <Tekmo> zugz: He recommended: (take 5 . randoms) <$> newStdGen
17:20:40 <Tekmo> The reason that works is that only one action actually needs to be in `IO`, which is the generation of the seed
17:20:49 <Tekmo> The generation of the subsequent randoms can be done purely
17:21:00 <zugz> oh right, I misunderstood it
17:22:32 <zugz> yes, nice
17:22:33 <monochrom> if you want to know how lazy I/O is done, using getStdRandom instead of I/O, it goes like this: loop = unsafeInterleaveIO (do { r <- getStdRandom random; rs <- loop; return (r:rs) })
17:23:15 <zugz> I see
17:23:23 <zugz> not too painful!
17:23:30 <Tekmo> With `pipes` it is even easier
17:23:35 <monochrom> as a first-order approximation, getContents is like that, using getChar instead of getStdRandom random. the real code adds buffering and other optimizations
17:23:57 <Tekmo> zugz: lift getStdRandom >~ cat :: Producer Int IO r
17:24:00 <zugz> thanks both, my curiosity is sated for the now ;)
17:24:26 <zugz> Tekmo: what package is that?
17:24:30 <Tekmo> zugz: `pipes`
17:24:50 <zugz> found it, yes
17:24:51 <zugz> ta
17:26:22 <Tekmo> Oops, and it should have been `getStdRandom random`
17:27:22 <monochrom> I think getStdRandom random = randomIO
17:27:30 <danbst> hello. I have type error http://lpaste.net/94910 . I do understand the problem, but I don't know what module imports bad instance (Num a, Num b). How can I debug it?
17:27:41 <Tekmo> monochrom: Oh yeah, you're right
17:28:33 <Tekmo> danbst: That instance should be from `base`.  What is the `Num` instance that you defined?
17:28:45 <adas> What is a good  intuition for the state monad?
17:28:52 <geekosaur> NumInstances :(
17:29:00 <monochrom> I see "-- Defined in `NumInstances-1.3:Data.NumInstances.Tuple'"
17:29:18 <danbst> tekmo: Graphics.Gloss.Data.Point has correct version
17:29:57 <monochrom> a good intuition for the state monad is s->(s,a)
17:30:02 <Tekmo> adas: I like to think of it in terms of Kleisli arrows of the form: a -> State s b
17:30:05 <monochrom> or is it s->(a,s)?
17:30:16 <dolio> The latter.
17:30:16 <danbst> monochrom: I see too, but I don't know WHO've used NumInstances - I have not imported it
17:30:26 <Tekmo> adas: If you expand out `State`, it is essentially the same thing as:
17:30:35 <Tekmo> adas: State s a = s -> (a, s)
17:31:07 <Tekmo> adas: So a computation of type `a -> State s b` is equivalent to: `a -> s -> (b, s)`
17:31:22 <Tekmo> adas: If you uncurry that computation, you get: `(a, s) -> (b, s)`
17:31:41 <Tekmo> So in other words, it is like a function from `a` to `b`, except you are threading around some `s` alongside it
17:32:02 <monochrom> I see. but I have no access to your source code. I cannot chase it.
17:32:24 <Tekmo> danbst: What is the code for your `Num` instance that you wrote
17:32:38 <geekosaur> Tekmo, they didn't write one
17:32:40 <adas> Tekmo: thanks for the definition. but i understand that quite well. my issue here is that, intuitively, when using the state monad I view the 'a' as something to put and get values..when infact 's' is what supports it..
17:32:44 <geekosaur> one is from Gloss, one is from NumInstances
17:33:15 <Tekmo> adas: `a` is just what you compute.  It may have no relation to the state at all
17:34:11 <adas> Tekmo: so i can set `a` using return a. but how do i get `a` like I can `s <- get`.. or is it not supposed to work like that..?
17:34:20 <monochrom> I will be cheesy and say "'a' stands for 'answer'"
17:34:21 <geekosaur> it doesn't
17:34:25 <Tekmo> adas: You get `a` using the bind for the monad
17:34:48 <Tekmo> adas: For example, let's say that I have a computation of type `comp :: State Int Double`
17:35:05 <Tekmo> adas: If I want to get that `Double`, I bind the value using `(>>=)`
17:35:18 <Tekmo> adas: comp >>= \thatDouble -> ...
17:35:24 <Tekmo> adas: Or using `do` notation:
17:35:33 <Tekmo> adas: do { thatDouble <- comp; ... }
17:35:44 <danbst> tekmo, monochrom:, geekosaur: here are my imports http://lpaste.net/94911 . Who imported NumInstances - I can't figure. Neither I know of a way to figure it out
17:36:22 <geekosaur> the fact that it prefixed a package name makes me think ghc's not sure where it came in either, to be honest
17:37:25 <Tekmo> danbst: I found the problem
17:37:33 <Tekmo> danbst: So the offending `Num` instance is here: http://hackage.haskell.org/package/gloss-1.2.0.0/docs/src/Graphics-Gloss-Data-Point.html
17:37:50 <geekosaur> they said that's the one they *want*
17:37:58 <monochrom> I would do this, if I had nothing better to do: for each import, for example Control.Wire: at ghci prompt, ":m Control.Wire", then ":info Num", then look for "instance ... => Num (a,b)"
17:37:58 <geekosaur> it's the NumInstances one that is offending
17:38:09 <Tekmo> danbst: Theo ther one is fromt he `NumInstances` package
17:38:09 <danbst> yes
17:38:25 <geekosaur> but I'm not sure Tekmo is even listening...
17:38:26 <adas> Tekmo: I thought `state <- (xxx :: State s a)` assigns `s` to `state` and not the other way around. Because isn't that what `get` does? And the type of `get` is `State s a`
17:38:28 <Tekmo> Here: http://hackage.haskell.org/package/NumInstances-1.3/docs/src/Data-NumInstances-Tuple.html
17:38:52 <Tekmo> danbst: You have to modify one of the two packages if you want to import both of those modules
17:39:14 <geekosaur> Tekmo, Tekmo, do you read? the problem is that NumInstances is not apparently being imported anywhere
17:39:15 <monochrom> since I don't have half of your imports, I cannot do it for you
17:39:24 <danbst> the only way I see - is commenting all the code out except my instance usage and commenting imports one by one
17:39:30 <Tekmo> adas: No, it assigns `a`.  In fact, the way that `get` works is precisely because it duplicates the `s` to the second type parameter
17:39:34 <Tekmo> adas: get :: State s s
17:39:48 <Tekmo> adas: The bind takes whatever is in the second type variable
17:40:11 <Tekmo> geekosaur: Alright, then let's chase down the trail of imports
17:40:27 <Tekmo> geekosaur: My bet is the `netwire` package
17:40:51 <Tekmo> Yeah
17:41:04 <Tekmo> It's `NumInstances => vector-space => netwire`
17:41:10 <Tekmo> That's where that is coming from
17:41:10 <monochrom> oh, so I blindly guessed Control.Wire right?!
17:41:32 <monochrom> well, it is not like I would guess Control.Arrow, haha
17:41:44 * hackagebot rethinkdb 1.8.0.5 - RethinkDB driver for Haskell  http://hackage.haskell.org/package/rethinkdb-1.8.0.5 (EtienneLaurin)
17:41:55 <Tekmo> danbst: For future reference, the way you can discover these things quickly is to use the nifty reverse-dependencies tool here: http://packdeps.haskellers.com/reverse
17:42:02 <monochrom> where do I claim my Nobel prize? :)
17:42:07 <lingxiao> Hey all I have a question about how to express a type
17:42:14 <adas> Tekmo: dingbat...that is soo true. all along i thought it was the other way around. This explains a few doubts I had... Thanks for your clarification.
17:42:15 <Tekmo> danbst: I just used that to find reverse dependencies of `NumInstances` and there were only three, so it made it easy
17:42:29 <lingxiao> I'm wondering if someone wants to take a crack at it
17:42:31 <Tekmo> adas: You're welcome!
17:42:44 <Tekmo> lingxiao: Shoot!  I'll try it
17:43:03 <lingxiao> sweet, thanks tekmo you also answer all my questions on SO btw so thanks for that haha
17:43:04 <danbst> Tekmo: thanks, that was exactly what I wanted!
17:43:09 <Tekmo> danbst: You're welcome!
17:43:43 <lingxiao> anyways I want to express a function signature of abitrary arity taking ony number of types
17:44:01 <lingxiao> so like 'a', 'a -> b' 'a -> a', 'a -> a', 'b -> b', 'a -> a -> a', ect
17:44:09 <lingxiao> so it's recursive by nature that I can see
17:44:28 <Tekmo> lingxiao: So this is not my specialty, but you have you already consulted existing solutions like `printf`?
17:44:29 <monochrom> there requires a type class
17:44:54 <monochrom> yes, steal from Text.Printf. comes with GHC. doc is somewhere on your disk.
17:45:08 <monochrom> well, I guess you want to read the source code too
17:45:23 <lingxiao> ok cool I'll start with that thanks monochrom and Tekmo
17:45:29 <Tekmo> lingxiao: You're welcome
17:45:54 <lingxiao> hey man Tekmo can I ask you how long you've been writing Haskell ? it's ok if you don't want to answer here or something
17:46:02 <Tekmo> That's fine :)
17:46:13 <lingxiao> but you're like really good and I've got a target on you / you inspire me
17:46:14 <zq> ping
17:46:28 <Tekmo> One second, because I just answered this for somebody else and I'm digging up my notes
17:46:36 <lingxiao> oh ok cools
17:47:04 <zq> so i just implemented fib nth using Data.Matrix
17:47:11 <Tekmo> I'll keep it brief to avoid boring everybody else here, but if you want to know more we can continue in haskell-overflow
17:47:29 <Tekmo> The first time I heard about Haskell was 2007 when I read this post: http://thraxil.org/users/anders/posts/2007/10/30/A-Simple-Programming-Puzzle-Seen-Through-Three-Different-Lenses/
17:47:50 <Tekmo> I started doing it "for real" in 2011 after dabbling in it for the previous four years
17:48:03 <zq> any hints on why fib 1-gazillion works well with Data.Matrix but terrribly with "fib nth = (0:1:zipWith (+) fib (tail fib)) !! nth"?
17:48:59 <monochrom> perhaps the matrix lib is eager. laziness hurts for this.
17:49:14 <Tekmo> zq: That's because the latter solution is O(n), where `n` is the nth fibonacci number that you are computing
17:49:32 <Tekmo> zq: The ideal matrix version can be O(log n)
17:49:35 <srhb> I don't even understand how the latter solution can work. :P
17:49:50 <Tekmo> srhb: Magic!
17:50:03 <srhb> Tekmo: As always!
17:50:15 <Tekmo> srhb: Yeah, that one blew my mind for a long time, too
17:50:33 <monochrom> the second solution has a few "you know what I mean"
17:50:44 <srhb> Indeed :P
17:50:54 <srhb> conflating the name fib is what made me go "herp"
17:50:59 <zq> Tekmo: i don't think so
17:51:02 <srhb> fibth!
17:51:19 <zq> Tekmo: the matrix version that i'm using simply raises [1, 1; 1, 0] to the nth power
17:51:22 <monochrom> fib nth = list !! nth where list = 0 : 1 : zipWith (+) list (tail list)
17:51:32 <srhb> Yep, that makes more sense. :-)
17:51:37 <Tekmo> zq: Oh, hmmm.  Then I'm not sure
17:51:57 <monochrom> zq, how do you raise power? multiply n times? square log(n) times?
17:52:00 <zq> Tekmo: i should rephrase -- the canonical take/zipWith implementation exhausts all memory, but Data.Matrix doesn't
17:52:13 <Tekmo> zq: Oh yeah, listen to `monochrom`
17:52:23 <Tekmo> zq: So exponentiation is not necessarily O(n)
17:52:29 <zq> hm
17:52:34 <zq> even so
17:52:47 <monochrom> if you see a lot of memory used for this, then it's laziness
17:52:51 <zq> i would like to knwo why the memory usage is drastically different
17:53:22 <zq> monochrom: haskell doesn't knwo to only keep the two most recent elements of the fib list?
17:53:35 <zq> monochrom: in the take/zip impl, i mean
17:53:49 <lingxiao> ok thanks Tekmo. I added #haskell-overflow to my channels and maybe I'll ask you more questions about learning it sometime?
17:53:50 <Tekmo> zq: Are you compiling with optimizations on?
17:53:54 <monochrom> that is not the problem. do you know how foldr (+) uses a lot of memory? and foldl (+) too?
17:53:58 <Tekmo> lingxiao: Yeah, of course
17:54:02 <Tekmo> Let me give you my e-mail address
17:54:22 <monochrom> see my http://www.vex.net/~trebla/haskell/lazy.xhtml
17:55:04 <monochrom> zipWith (+) list (tail list)  is the same deal on steroid. even if you just !! nth it.
17:55:11 <zq> Tekmo: -O3
17:55:17 <zq> Tekmo: ghc -O3 bigfib.hs
17:55:20 <Tekmo> zq: I don't know, then
17:55:27 <Tekmo> Also, -O2 is the maximum optimization level
17:55:29 <srhb> There's an -O3? O_o
17:55:29 <carter> yes
17:55:30 <monochrom> guess what! "print list" uses constant memory
17:55:31 <srhb> Oh
17:55:32 <Tekmo> -O3 gets translated to -O2
17:55:35 <carter> yeah
17:55:47 <carter> and in 7.6 theres some bugs so that O1 is better by default
17:56:10 <zq> lolwat
17:56:25 <Tekmo> carter: Like what?
17:56:26 <zq> carter: have a bug report link?
17:56:39 <monochrom> "main = print list" uses constant memory. "main = print (list !! n)" uses n memory. yes.
17:56:51 <carter> i only found out about it because i had my ~/.cabal/config file set to O2
17:57:15 <monochrom> hrm! that's bad
17:57:42 <carter>  http://ghc.haskell.org/trac/ghc/ticket/7944#comment:2   http://ghc.haskell.org/trac/ghc/ticket/5550 in the context of me trying to build lambdabot and getting stuck at randomfu https://github.com/mokus0/random-fu/issues/13
17:57:47 <monochrom> well, I am at -O1 and have been that way for years
17:58:04 <carter> monochrom: i mess with my config file :)
17:58:36 <carter> zq: Tekmo  monochrom  enjoy :)
17:58:50 <Tekmo> Thanks!
17:59:13 <spaceships> jeff erickson says that even though the matrix fib is O(log n) writing down the nth fib number is at least sigma(n) since the nth fib number is aprox n/5 digits long ... (from dynamic programming secion of http://www.cs.uiuc.edu/~jeffe/teaching/algorithms/)
17:59:28 <carter> what function is sigma?
17:59:45 <carter> you mean \Omega(number of digits)
17:59:46 <carter> ?
17:59:48 <spaceships> er yeah
17:59:53 * spaceships coughs
17:59:56 <carter> soke
18:00:07 <monochrom> true, I'm being sloppy at it
18:00:09 <c_wraith> and number of digits is proportional to n
18:00:49 <c_wraith> People always ignore that when they talk about fibs.  It's an exponential series. It gets outside of any fixed-width numeric pretty quickly.
18:01:15 <carter> indeed
18:01:20 <carter> for a number n
18:01:30 <carter> it has O (log n) bits
18:01:57 <carter> :)
18:02:08 <carter> spaceships: ohh
18:02:12 <carter>  you mean \Theta(log n)
18:02:19 <carter> not yeah
18:02:39 <jrmithdobbs> i'm confused, where did System.Event go between 4.3.1.0 and 4.6.0.1?
18:02:47 <spaceships> i need to visit a greek alphabet
18:03:22 <carter> spaceships: or use http://detexify.kirelabs.org/classify.html (writteni n haskell)
18:03:32 <carter> huh, link seems to be slow
18:03:33 <monochrom> carter beats me to it
18:03:51 <monochrom> oh wait, it's written in haskell?! that's new to me
18:03:54 <loadedanvils> this may be a bad question, but how do I develop a style for writing in haskell?
18:04:28 <Tekmo> loadedanvils: What do you mean by style?
18:04:37 <carter> monochrom: i thought it was
18:04:38 <monochrom> by reading other people's code, but still forming your own opinion and judgement
18:04:42 <carter> loadedanvils: read and write a lot
18:04:50 <carter> just like in normal writign and reading
18:04:53 <spaceships> carter: omega
18:05:00 <carter> omeg is a lower bound
18:05:01 <loadedanvils> when I'm porting a script, I want to figure out how to write it in haskell
18:05:03 <carter> but its both
18:05:04 <spaceships> yes
18:05:09 <carter> so THETA
18:05:14 <carter> loadedanvils: write it
18:05:14 <spaceships> aha
18:05:20 <monochrom> hire someone
18:05:23 <loadedanvils> carter: I read different things but it looks like everything does it differently
18:05:27 <Tekmo> loadedanvils: What language are you porting it from?
18:05:28 <carter> and thats ok
18:05:37 <loadedanvils> Tekmo: py
18:05:39 <carter> loadedanvils: have you seen only one good way to write a letter tos omeone?
18:05:53 <loadedanvils> carter: no, but I don't know what I'm doing
18:06:00 <carter> loadedanvils: try stuff and see what happens
18:06:01 <carter> :)
18:06:04 <Tekmo> loadedanvils: If it's a simple script, then the typical style is something like:
18:06:16 <loadedanvils> I don't mean to be a whiny baby, but it's something I'm getting anxiety over
18:06:20 <carter> main = putStrLn "hello world"
18:06:23 <Tekmo> loadedanvils: (READ IN ALL INPUT) => (TRANSFORM USING PURE FUNCTION) => (WRITE ALL OUTPUT)
18:06:30 <carter> loadedanvils: everyone does
18:06:35 <carter> just do the stupid wrong thing
18:06:38 <carter> and ask for feedback
18:06:40 <carter> its ok
18:06:46 <carter> i'm bad at it
18:06:48 <monochrom> I think I asked you yesterday, why you're still asking peripheral questions and not reading and experimenting already
18:06:51 <carter> but tis teh best we
18:06:56 <carter> just do
18:06:59 <carter> then ask for feedback
18:07:01 <carter> don't worry about it
18:07:15 <carter> we don't care about your feelings, just helping you code :P
18:07:23 <monochrom> you are coming across as someone who wants to finish learning haskell before starting to learn haskell
18:07:43 <carter> you never finish learning haskell
18:07:50 <Tekmo> It's an honest question
18:07:51 <carter> everrrrrrrrrrrrrrrrrrrrrrrrrr
18:08:10 <carter> idk
18:08:19 <carter> for basic stuff there is a pretty clear way
18:08:22 <Tekmo> Some people learn from studying the code of others, but Haskell code tends to be all over the place
18:08:29 <loadedanvils> when I have a where statement called twice (say, in a tuple) is it calculated once or twice?
18:08:44 <monochrom> Tekmo, I have his/her previous questions yesterday and before in context. you are perfectly right that this one single question out of the blue is fine. but nothing ever stands without context.
18:08:47 <carter> loadedanvils: the correct answer is it doesnt matter
18:09:01 <Tekmo> loadedanvils: "(x, x) where x = ..." will only compute `x` once, I think
18:09:20 <carter> Tekmo: not true
18:09:26 <carter> there could be inlinging
18:09:42 <carter> the correct answer is it doesn't matter :)
18:09:46 <carter> and either way it'll be fast
18:09:56 <loadedanvils> it feels like it matters
18:09:58 <carter> nope
18:10:04 <Tekmo> ghc is smart
18:10:06 <carter> loadedanvils: i write really really peformance sensitive code
18:10:09 <carter> it doesn't amtter
18:10:19 <Tekmo> If it changes the inlining it will havev a good reason
18:10:33 <carter> loadedanvils: ignor peformance
18:10:37 <carter> you can learn that later
18:10:39 <carter> just start doing
18:10:40 <carter> now
18:10:47 <loadedanvils> fine
18:11:01 <srhb> s/\\n\./
18:11:10 <arkeet> and then when you need performance, don't just guess, use profiling
18:11:11 <arkeet> :c
18:11:34 <carter> main = do   putStrLn "whats your name"  ; a <- getStrLn ; putStrLn ( "hello " ++a)
18:11:38 <carter> arkeet: yes
18:11:49 <carter> arkeet: and/or criterion
18:11:55 <monochrom> I seldom profile. but I read core for real
18:12:08 <carter> it depends on the context
18:12:13 <carter> profiling can be great for applications
18:12:27 <carter> not always right for libs
18:12:39 <srhb> Core hurts my brain. I want {-# STRICT #-} or something.
18:12:50 <carter> srhb: theres progress on that
18:12:53 <carter> will likely land by 7.10
18:12:56 <srhb> carter: Oh, that's comforting.
18:13:10 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/104783/  true story. do not even think about guessing. you must guess wrong. you must.
18:13:31 <carter> indeed, as monochrom  says. But also, performance is complicated
18:13:36 <monochrom> "you are always wrong" is right 99.9% of the time
18:13:40 <carter> true
18:13:45 <carter> except when its not
18:14:20 <monochrom> I care about efficiency too. but use the scientific method, not the opinionative method such as popular among programmers
18:15:16 <srhb> monochrom: That link is cute. :-)
18:15:51 <monochrom> many years ago, I tried profiling but got inaccurate results. it was as though -O and -prof had conflicts, so how could I trust -prof to represent -O? but maybe it has been fixed
18:16:25 <carter> hrm
18:16:29 <carter> theress still some issues there
18:16:30 <AshyIsMe> ah awesome, yesod supports packaging up webkit as a faux desktop application
18:16:30 <srhb> Ah yes. The
18:16:35 <AshyIsMe> similar to node-webkit
18:16:45 <carter> monochrom: BUT, stack tracing will be a thing for 7.10 i think
18:16:50 <carter> so you could do a sampling profile
18:16:54 <carter> that doesn't hinder optimizatin
18:17:07 <monochrom> also, I didn't run into that problem too often. I'm just paranoid
18:17:26 <carter> heh
18:17:38 <carter> monochrom: i need a vacation from crazy debugging
18:17:44 <carter> or i need to make crazy debugging my job
18:17:45 <carter> not sure which
18:17:57 <monochrom> vacation
18:18:16 <carter> monochrom: yeah
18:18:39 <monochrom> you want to avoid burning out
18:19:14 <monochrom> go play Civ V or something. it will be a 2-week vacation :)
18:20:18 <carter> monochrom: i'm doing a weird blend of consulting + slightly interviewing around right now
18:21:26 <carter> monochrom: i do have civ 5
18:21:30 <carter> i should play with that
18:28:10 <carter> night all
18:28:15 <srhb> carter: o/
18:34:35 <JoeyA> > zip [] undefined
18:34:36 <lambdabot>   []
18:34:40 <JoeyA> > zip undefined []
18:34:41 <lambdabot>   *Exception: Prelude.undefined
18:46:23 --- mode: ChanServ set +o elliott
18:46:29 --- mode: elliott set +b Halite*!*@*
18:46:31 --- kick: Halite was kicked by elliott (ban evasion)
18:46:33 --- mode: elliott set -o elliott
18:51:51 <frx> : <$>
18:51:53 <frx> :t <$>
18:51:54 <lambdabot> parse error on input `<$>'
18:52:01 <frx> :t (<$>)
18:52:02 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:52:17 <frx> (2^) <$> [0..]
18:52:19 <frx> > (2^) <$> [0..]
18:52:20 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
18:53:22 <redscare> is there something built-in analogous to a "multi-level" map? i.e. something so that if i have [[a]] and a function a->b i get back [[a]] with the same structure?
18:53:32 <redscare> sorry, get back [[b]]
18:53:56 <dibblego> redscare: there is TypeCompose to give you (fmap . fmap) and there is Control.Lens
18:54:10 <dibblego> I think there is also (:.) somewhere
18:54:18 <edwardk> map.map works surprisingly well
18:54:31 <edwardk> :t map.map
18:54:32 <lambdabot> (a -> b) -> [[a]] -> [[b]]
18:54:36 <edwardk> :t map.map.map
18:54:36 <lambdabot> (a -> b) -> [[[a]]] -> [[[b]]]
18:56:20 <brainacid> hello channel
18:56:36 <Tekmo> Hi!
18:56:43 <brainacid> still trying to learn programming using python so I can come into Haskell with some type of understandings
18:57:01 <dibblego> brainacid: why not skip the python step?
18:57:18 <Tekmo> Yeah, Python won't prepare you very well for Haskell
18:57:29 <brainacid> dibblego, Cant seem to cuz all the Haskell material assumes previous programming knowledge
18:57:46 <Tekmo> brainacid: Have you tried "Learn you a Haskell for Great Good"?
18:57:48 <brainacid> Im on Xmonad right now and its amazing...
18:58:18 <brainacid> Tekmo, the bible of haskell....yup I have a lot of books with me...just patiently waiting
18:58:18 <redscare> is there a way to do
18:58:29 <redscare> 'n' compositions of the samef unction?
18:58:37 <redscare> like map . map . map . ...
18:58:43 <Iceland_jack> redscare: iterate and (!!)?
18:58:45 <Tekmo> brainacid: The best way to learn Haskell is to just start writing code, no matter how bad it is
18:59:20 <sm> http://tryhaskell.org is a great starting point
18:59:20 <redscare> Iceland_jack: without generating all theprecursors?
18:59:26 <brainacid> Tekmo, I agree with you but Im intimidated and also get stuck so easily that I get frustrated and quit
18:59:29 <frx> "Learn you a haskell for greater good" is a pretty gentle introduction
18:59:35 <enthropy> Iceland_jack: that makes an infinite type it would seem
18:59:42 <brainacid> some guys here know me...i come in and out
18:59:47 <enthropy> @type iterate (map .)
18:59:48 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = [a0]
18:59:48 <lambdabot>     Expected type: (a0 -> b0) -> a0 -> b0
18:59:48 <lambdabot>       Actual type: (a0 -> b0) -> [a0] -> [b0]
18:59:54 <Tekmo> brainacid: What parts do you get stuck on?
18:59:55 <Iceland_jack> > iterate (++"!") "hi" !! 5
18:59:56 <lambdabot>   "hi!!!!!"
19:00:28 <brainacid> thanks sm
19:00:30 <sm> chrisdone: tryhaskell.org is currently showing Terminated for simple expressions
19:00:42 <Iceland_jack> > (++ "!") . (++ "!") . (++ "!") . (++ "!") . (++ "!") $ "hi"
19:00:43 <lambdabot>   "hi!!!!!"
19:01:10 <johntromp> :t replicate
19:01:11 <lambdabot> Int -> a -> [a]
19:01:19 <Iceland_jack> johntromp: Doesn't solve the same problem
19:01:47 <brainacid> Tekmo, its not a specific part its more like understading how to do things with it
19:02:07 <brainacid> The prerequisite for this series of tutorials is some knowledge of imperative programming, whether C++, Java, Pascal, you name it.
19:02:16 <brainacid> https://www.fpcomplete.com/school/basics-of-haskell
19:02:30 <johntromp> :t foldr
19:02:30 <lambdabot> (a -> b -> b) -> b -> [a] -> b
19:02:38 <brainacid> I run into that all the time...so my reason of doing python first
19:02:52 <Tekmo> brainacid: What is it that you want to do?
19:03:09 <brainacid> Tekmo, lol...dont know...im just a looney dude
19:03:10 <johntromp> > foldr ($) "hi" (replicate 5 (++"!"))
19:03:11 <lambdabot>   "hi!!!!!"
19:03:49 <Tekmo> brainacid: What got you interested in programming?
19:03:54 <brainacid> Tekmo, anything...print to screen, extract stuff from a text file and write it to another....dunno bro.. the basic stuff...I see Xmonad and I get intimidated
19:03:55 <johntromp> not as neat as iterate though:(
19:04:07 <Tekmo> brainacid: Use `putStrLn` to print something to the screen
19:04:20 <brainacid> Tekmo, the analyticals, the code itself....the communities of geniuses
19:04:21 <redscare> still doesn't do `n' compositions, does it?
19:04:26 <Tekmo> brainacid: Use `readFile` to read from a file and `writeFile` to write to a file
19:07:08 <brainacid> haskell is interpreted...? or compiled?
19:07:30 <redscare> also, is there something analogous (i know there can't be something too similar because of types) that takes a function of `n' arguments and a list of `n' elements and applies the function to those elements?
19:07:31 <brainacid> does it begin at line 1 all the way thru executing
19:07:44 <sm> runhaskell prog.hs runs it interpreted, ghc prog.hs; ./prog runs it compiled
19:07:50 <Tekmo> brainacid: It can be interpreted or compiled
19:07:55 <mm_freak> vty-ui is really awkward to work with =/
19:07:56 <Tekmo> brainacid: But both ways it does not go line by line
19:08:05 <Tekmo> brainacid: The entire file is understood as a unit
19:08:25 <brainacid> Tekmo, maybe thats my issue...Im thinking of it as line by line
19:09:04 <enthropy> redscare: it doesn't. You can write type classes that will do such things
19:09:05 <hpc> brainacid: a haskell program is the execution of the IO action bound to the name "main"
19:09:07 <Iceland_jack> brainacid: Why is that an issue though?
19:09:14 <hpc> it can be interpreted or compiled
19:09:35 <hpc> ghc compiles haskell to binaries, and ghci compiles to bytecode and then interprets that
19:09:59 <mm_freak> redscare: when asking a question like this you can often answer it yourself:  try to write the type of the function
19:10:37 <redscare> mm_freak: that is why i figured there could be no such function, but i still ended up just with two unsolved problems :)
19:10:46 <brainacid> cuz it might hinder the way I learn by thinking of a script type execution
19:10:51 <redscare> the first is how to do `n' compositions of the same function (doesn't seem easy to write a type like that)
19:11:07 <brainacid> the real dilema is not knowing what to code
19:11:27 <mm_freak> redscare: that one is actually easy:  foldl (.) id (replicate n f)
19:11:55 <Tekmo> brainacid: So, for example, if I define `x = y + 5`, followed by `y = 3`, it will work
19:12:08 <Tekmo> brainacid: The definition of `x` will know to consult the definition of `y` following it
19:12:14 <redscare> mm_freak: thank you.
19:12:21 <redscare> should have thought about that more
19:12:24 <Tekmo> brainacid: On the other hand, it means you can't define the same value twice
19:12:28 <brainacid> applying what I learn into my programs...which is my downfall...knowing what to create
19:12:34 <mm_freak> redscare: multiApp :: Int -> (a -> a) -> (a -> a)
19:12:41 <Iceland_jack> brainacid: #haskell can't really tell you /what/ to create
19:12:43 <Tekmo> brainacid: You can't define `x = 5` followed by `x = 7`.  The compiler will throw an error saying that you have conflicting definitions
19:12:48 <sm> brainacid: how about http://projecteuler.net/problem=1
19:12:48 <Iceland_jack> I'm not sure what kind of help you're looking for
19:12:53 <brainacid> Iceland_jack, I understand that bro
19:12:54 <mm_freak> redscare: multiApp n = foldl (.) id . replicate n
19:13:05 <brainacid> im just chatting with yall
19:13:07 <redscare> the second problem is i have a list of two lists, and would like to apply zipWith f to the lists inside
19:13:19 <Tekmo> brainacid: In Haskell, when you define `x = 5`, you are basically declaring that `x` is synonymous with 5
19:13:31 <Tekmo> You can't change the value of `x` any more than you can change the value of the number 5
19:13:38 <redscare> mm_freak: but thanks a lot for that example, i'm just not as comfortable playing around with functions as I should be for haskell
19:13:55 <mm_freak> redscare: that one isn't well-typed
19:14:03 <Tekmo> brainacid: That's why the compiler complains when you try to set `x` to both 5 and 7; it can't be synonymous with both
19:14:24 <mm_freak> redscare: however, with a slight change it becomes well-typed
19:14:41 <brainacid> Tekmo, i see...hence the purity of haskell correct?
19:14:47 <Tekmo> brainacid: That's right
19:15:00 <mm_freak> redscare: i assume that you have a list like ["abc", "def"], and you would like to get [f 'a' 'd', f 'b' 'e', f 'c' 'f'], correct?
19:15:09 <redscare> mm_freak: yep, perfect
19:15:34 <Tekmo> brainacid: The key is to understand the distinction between setting something equal to another thing (using `=`) and binding an action's value (using `<-`)
19:15:37 <mm_freak> redscare: if you would be happy with f :: [a] -> b, then you can easily construct [f "ad", f "be", f "cf"]
19:15:44 <brainacid> sm, ugh math...its nice and all but I want to come up with my own stuff. thats where im stuck...lol
19:15:51 <mm_freak> redscare: the 'transpose' function will help you, but i'll leave writing that function to you =)
19:15:56 <Tekmo> brainacid: When you use the `=` sign you are basically saying "These two must always be the same thing, now and forever"
19:16:00 <mm_freak> > transpose ["abc", "def"]
19:16:01 <lambdabot>   ["ad","be","cf"]
19:16:05 <sm> brainacid: no problem. What's your own stuff ? a game ?
19:16:20 <Tekmo> brainacid: Maybe this will help you: http://www.haskellforall.com/2013/01/introduction-to-haskell-io.html
19:17:40 <loadedanvils> how to do map function reversing data?
19:17:50 <mm_freak> loadedanvils: example?
19:18:02 <Rembane> loadedanvils: reverse?
19:18:06 <loadedanvils> it seems like for large lists, map will have to construct the list backwards (from cons notation)
19:18:16 <mm_freak> loadedanvils: correct
19:18:19 <brainacid> thanks Tekmo
19:18:27 <Tekmo> brainacid: You're welcome!
19:18:36 <loadedanvils> if I don't care about the order too much, it would be easier in reverse
19:18:41 <loadedanvils> is there a function for that
19:18:43 <brainacid> sm,  dunno man...just fumble each day with life is my deal now
19:18:55 <mm_freak> loadedanvils: what do you mean?  when reversing a list you obviously do care about the order
19:19:08 <Tekmo> brainacid: So you're new to programming in general?
19:19:19 <brainacid> on new meds and trying to deal with the embarrasement
19:19:20 <loadedanvils> mm_freak: sometimes I use a list because it's the most convenient
19:19:25 <redscare> mm_freak: i have a transpose but it looks very inefficiet. don't tell me the answer, but is there an efficient solution using folds?
19:19:27 <brainacid> Tekmo, yes yes very
19:19:27 <Tekmo> brainacid: Sorry to hear that :(
19:19:34 <loadedanvils> the actual front to back order isn't as important
19:19:50 <mm_freak> redscare: oh, i didn't actually suggest writing 'transpose' itself =)
19:19:59 <brainacid> yeah its a life long situation I must deal with and its taking a toll on my creativity and mind
19:20:01 <mm_freak> redscare: you can write the function you want in terms of the predefined 'transpose'
19:20:18 <mm_freak> loadedanvils: i'm not sure i understand what you mean…  can you give an example?
19:20:21 <Tekmo> brainacid: The trick with programming is to be really methodical, both when you're programming and when you're learning how to program
19:20:22 <brainacid> mood disorders suck and so those brain chemistry...ugh
19:20:28 <monochrom> "map f (x:xs) = f x : map f xs" this builds the new list forward, not backward
19:20:41 <brainacid> Tekmo, first time I hear that...interesting.
19:20:45 <redscare> mm_freak: oh, i thought you were making it tricky :)
19:20:52 <Tekmo> brainacid: Any time you encounter a problem, ask a new question and try to answer it
19:20:59 <mm_freak> redscare: well, writing 'transpose' is a good exercise =)
19:21:06 <Tekmo> brainacid: If that fails, ask another question and try to answer that until you finally start making progress
19:21:30 <Tekmo> brainacid: Programming requires understanding lots of concepts simultaneously "in one go", so don't get dispirited if everything doesn't click yet
19:21:50 <brainacid> one prob one question until solved or failed then next question for same prob and loop... :)
19:21:57 <Tekmo> brainacid: Exactly :)
19:22:19 <mm_freak> brainacid: if haskell is your first programming language, it may actually work to your advantage…  haskell is a very natural language =)
19:22:21 <brainacid> Tekmo, thanks... u have been very awesome today helping me
19:22:24 <Tekmo> brainacid: The one thing that's nice about Haskell is that you get feedback instantly
19:22:28 <loadedanvils> mm_freak: if I want to map a function over a thousand elements in a list [1..1000], then it would have to map heads and do snoc on the list
19:22:32 <Tekmo> brainacid: If you make a mistake you get an immediate type error
19:22:42 <loadedanvils> mm_freak: so it would be in order
19:22:42 <mm_freak> loadedanvils: no, as monochrom noted, it works forwards
19:22:42 <monochrom> the real only prerequisite of haskell is part of highschool math skill. and just part, not all. (clearly, you don't need to know log.)
19:22:47 <Tekmo> brainacid: Then it's just a matter of asking others to help you interpret the type error so you can learn how to fix your mistake
19:22:57 <Tekmo> brainacid: After doing that long enough you will begin to understand the type errors yourself
19:22:57 <brainacid> something called me into Haskell...and I cant wait to unleash my potential on it
19:23:02 <Tekmo> :)
19:23:12 <mm_freak> loadedanvils: asking for the first element of 'xs' is about as expensive as asking for the first element of 'map f xs'
19:23:21 <jrmithdobbs> *usually
19:23:36 <monochrom> here is the exact list of highschool math skill relevant: 1. to work with variables; 2. to plug in; 3. unification.
19:23:54 <brainacid> yeah thats my fall...the "one go" approach...understanding all these concepts at the same time
19:24:02 <sm> well, tryhaskell.org seems to be working again
19:24:05 <Tekmo> brainacid: Yeah, a lot of concepts are defined in terms of each other
19:24:18 <Tekmo> brainacid: So you end up going in loops until you can start fitting large chunks of them in your head at one time
19:24:20 <monochrom> unification means: you know the law "x+y=y+x", you can apply it to "3*4+z = z+3*4" because you can instantiate x to 3*4, y to z.
19:24:25 <JoeyA> Did anyone learn unification in high school?  I didn't, at least not explicitly.
19:24:38 <brainacid> I want to so badly
19:24:43 <xexonixxexillion> This may sound a bit stupid, but if I have an Int16 and an Int8 and I want to .|. them, (i.e set the lower 8 bits on the Int16), how do I do it?
19:24:43 <mm_freak> brainacid: in most cases it boils down to understanding the type you're looking at and answering questions like:  "what do i get when i ask for X?"
19:24:46 <monochrom> that's it. that's all the prerequisite of haskell.
19:24:48 <brainacid> to sit and code for hours
19:24:57 <brainacid> just wacking the board into fire
19:24:59 <JoeyA> xexonixxexillion: signed or unsigned?
19:25:12 <JoeyA> If you're working with bits, and don't want weird sign extension, stick to Word*
19:25:14 <brainacid> love the sound of the keyboard
19:25:17 <JoeyA> i.e. Word16 and Word8.
19:25:18 <mm_freak> xexonixxexillion: x .|. fromIntegral y
19:25:21 <monochrom> no, JoeyA, it is not taught explicitly. but if you didn't flunk highschool math, you have that skill
19:25:23 <mm_freak> xexonixxexillion: where x is the Int16
19:25:27 <brainacid> especially a laptop board. so soft...lol
19:25:34 <xexonixxexillion> JoeyA signed; I want the value of the Int8 in two's complement form to be the lower 8 bits of my Int16
19:26:10 <johntromp> that makes no sense
19:26:27 <johntromp> the lower 8 bits of Int16 cannot be in 2s complement
19:26:36 <JoeyA> > fromIntegral (-128 :: Int8) :: Int16
19:26:37 <lambdabot>   -128
19:26:43 <monochrom> if you think I'm making it sound too easy, you're right. unification takes exponential time and possibly memory for the computer. therefore it is even harder for humans.
19:26:49 <mm_freak> xexonixxexillion: you get the same result for Word8 and Word16, it's just that the high bit is interpreted differently
19:27:06 <JoeyA> > fromIntegral (fromIntegral (-128 :: Int8) :: Int16) :: Word16
19:27:08 <lambdabot>   65408
19:27:34 <mm_freak> > ((-1) .|. (-2) :: Word8, fromIntegral ((-1) .|. (-2) :: Int8) :: Word8)
19:27:35 <lambdabot>   (255,255)
19:27:37 <JoeyA> xexonixxexillion: fromIntegral :: Int8 -> Int16 fills with ones instead of zeros when the input number is negative.  Be aware of that.
19:28:00 <brainacid> another issue I deal with is my background record....a felony in america is having your nuts cut off...even if it was proven a medical cause
19:28:07 <xexonixxexillion> JoeyA: That's why I thought it'd be an issue
19:28:30 <Tekmo> brainacid: Well, the nice thing about programming is that one person can do a whole lot by themselves, especially if they are a web developer
19:28:39 <brainacid> off meds ... get arrested...on meds get better ... yet have no life cuz of millions of people without a background can get the job
19:28:40 <Tekmo> brainacid: You don't need permission from anybody to program
19:28:41 <brainacid> ugh!!!
19:28:57 <brainacid> true
19:29:16 <brainacid> web developing...making web pages and stuff or apps???
19:29:42 <Tekmo> brainacid: Web pages is what I meant.  Apps are different and more challenging
19:29:49 <xexonixxexillion> > (0x0600  :: Word16) .|. (fromIntegral (-3 :: Int8)
19:29:50 <lambdabot>   <hint>:1:51:
19:29:50 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
19:30:40 <xexonixxexillion> > (0x0600 :: Word16) .|. (fromIntegral ((-3) :: Int8 ))
19:30:42 <lambdabot>   65533
19:31:06 <mm_freak> apps are more challenging mainly because it's challenging to use haskell for them =)
19:31:12 <xexonixxexillion> that's not 0x6252...
19:31:34 <mm_freak> xexonixxexillion: convert to Word8, then to Word16, then to Int16
19:31:38 <JoeyA> > fromIntegral (-3 :: Int8) :: Word16
19:31:39 <Tekmo> Yeah, Haskell has poor bindings to UI toolkits
19:31:39 <lambdabot>   65533
19:32:16 <mm_freak> Tekmo: it's not about toolkits, but about actually targetting android/iOS…  it's possible today, but far from easy
19:32:28 <JoeyA> xexonixxexillion: you're getting a sign extension in the Int8 -> Word16 conversion.  IIRC you'd get that in C, too.
19:32:45 <JoeyA> > fromIntegral (fromIntegral (-3 :: Int8) :: Word8) :: Word16
19:32:46 <lambdabot>   253
19:32:56 <mm_freak> Tekmo: the toolkit bindings are poor mainly because the toolkit APIs themselves are rather poor and the haskell bindings are pretty straightforward mappings
19:33:06 <JoeyA> > (0x0600 :: Word16) .|. (fromIntegral (fromIntegral (-3 :: Int8) :: Word8))
19:33:08 <lambdabot>   1789
19:33:57 <Tekmo> mm_freak: My first reference to apps was referring to them in the mobile sense, but then I though you were talking about desktop applications, so I changed topic to that
19:34:07 <Tekmo> mm_freak: Either way I 100% agree with you
19:34:27 <Tekmo> mm_freak: Also, there is the problem of compiling bindings for toolkits
19:34:34 <Tekmo> mm_freak: These regularly fail on Windows and Mac
19:34:35 <mm_freak> indeed
19:35:04 <mm_freak> that raises the question whether it would be such a bad idea to make a native haskell toolkit, but it's a lot of work
19:35:38 <Tekmo> I know that Jonathan Fischoff wants to do this
19:35:43 <sm> it's gotta be done sooner or later
19:35:43 <mm_freak> and if you do it, do it properly from the very beginning:  if you have 'createButton' you're already doing it wrong
19:35:48 <Tekmo> He wants to make an OpenGL-based native Haskell UI toolkit
19:36:06 <mm_freak> nice
19:36:21 <mm_freak> which FRP library is he building on?
19:36:28 <Tekmo> None yet
19:36:47 <Tekmo> So the reason why not is that he asked me to come up with an FRP-like framework that was pure and Quickcheckable
19:36:59 <Tekmo> I actually just did recently, but I'm not totally satisfied with it just yet
19:37:16 <mm_freak> netwire is both pure and quickcheckable
19:37:20 <Tekmo> You can see my latest progress in this answer: http://stackoverflow.com/questions/19201901/in-functional-reactive-programming-how-do-you-share-state-between-two-parts-of/19204253#19204253
19:37:50 <Tekmo> There are some reason I'm not satisfied with either my solution nor netwire
19:37:56 <brainacid> see what I mean...u guys are genius! :>
19:38:12 <mm_freak> Tekmo: talk to me…  i'm about to release netwire 5 =)
19:38:19 <Tekmo> mm_freak: Oh, you are ertes!?!?!
19:38:24 <mm_freak> yeah
19:38:25 <Tekmo> :)
19:38:34 <Tekmo> I want to say that netwire has inspired my `foldl` library a lot
19:39:01 <Tekmo> Speaking of which, I was going to tell you that you can make netwire much more efficient
19:39:18 <chrisdotcode> does anybody know where the toJSON instances of pandoc's types went? I can't seem the find them in 1.12
19:39:19 <mm_freak> nice…  i haven't noticed that library
19:39:39 <Tekmo> So the basic idea is that you can make your wire type much more efficient if you don't encode it recursively
19:39:43 <mm_freak> Tekmo: how?  the new version is a very thin layer around regular functions
19:39:55 <Tekmo> I'll try to explain what I mean
19:39:58 <mm_freak> Tekmo: you mean using an existential for local state?
19:40:02 <Tekmo> Have you ever studied how stream fusion works?
19:40:09 <Tekmo> Yeah, similar to that
19:40:14 <Tekmo> In other words:
19:40:26 <redscare> mm_freak: i noticed that the standard "transpose" is implemented in a verbose way, when i could simply say "transpose = foldr (zipWith (:)) (repeat [])". is there an obvious reason my code is slow or inefficient (i have checked that it at least works)
19:40:28 <mm_freak> Tekmo: just spell out the simplified type…  chances are i've already tried it =)
19:40:34 <Tekmo> forall x . Wire x (Time -> a -> m (Either e b, x))
19:40:35 <zq> hm
19:40:52 <mm_freak> Tekmo: you need another x there, but yes, i've already tried that
19:40:54 <Tekmo> Oops, there should be another `x` there
19:40:54 <jmcarthur> i would assume there is an x argument in that function
19:40:55 <Tekmo> Yeah
19:40:58 <mm_freak> Tekmo: turned out to be less efficient in general
19:41:06 <Tekmo> That's because of the `Either`
19:41:10 <Tekmo> If you remove the `Either` it is very fast
19:41:10 <zq> instance Num FancyData requires that i define (*), right? and that automatically gets me (^), also, right?
19:41:16 <Tekmo> I noticed this with `pipes`, too
19:41:24 <mm_freak> Tekmo: no, the reason is more fundamental
19:41:27 <loadedanvils> :t lines
19:41:28 <lambdabot> String -> [String]
19:41:34 <jmcarthur> that will be generally fast until you use it in a context-sensitive (monadic) way
19:41:51 <mm_freak> Tekmo: it doesn't apply to pipes…  let me show you why it works for pipes, but not for netwire
19:41:59 <Tekmo> I already tried on `pipes`, and it doesn't work
19:42:10 <mm_freak> Tekmo: http://hub.darcs.net/ertes/netwire/browse/Control/Wire/Core.hs
19:42:16 <mm_freak> look at the Wire GADT
19:42:18 <Tekmo> The moment you compose 4 or more `pipes` it gets even slower than the naive implementation
19:42:43 <Tekmo> Oh yeah, it won't work for that GADT
19:42:59 <Tekmo> What I mean is that if your encoding is super-simple, then it works because GHC doesn't give up on case simplification
19:43:14 <Tekmo> ... or whatever the name for it is
19:43:15 <mm_freak> the problem with the existential-state variant is that it cannot switch from the general to a special constructor, so the moment you go into WGen you will stay there forever
19:43:40 <mm_freak> then the wire combinators will fail to simplify wires at run-time
19:43:55 <Tekmo> Oh, ok
19:44:24 <Tekmo> Anyway, the main issue I had even with  my own implementation is that you can only encode streams this way
19:44:38 <Tekmo> But I was specifically interested in encoding what I call "heterogeneous" behavior
19:44:53 <Tekmo> My vocabulary for this sort of thing is very limited, but I will try to explain
19:45:09 <Rembane> redscare: Profile it and see where it is slow!
19:45:09 <mm_freak> Tekmo: if you CPS-transform Proxy, then it could work, but it would make pipes a lot more awkward to implement
19:45:42 <Tekmo> So for example, let's say that my input stream is like the following "regex"
19:46:03 <Tekmo> A(B|C)*(D|E)*
19:46:19 <Tekmo> In other words, an `A` followed by a list of `B`'s or `C`'s, followed by a list of `D`'s or `E`'s
19:46:48 <Tekmo> If I want to operate with any streaming library (my own included), I am forced with the problem that I have to lose information by "linearizing"(?) that type
19:47:02 <Tekmo> In other words, I can't enforce that there is only one A at the beginning and nowhere else
19:47:36 <mm_freak> i see
19:47:42 <Tekmo> In other words, to interface with a streaming library, I have to pretend like my input is: (A|B|C|D|E)*, even though it's not
19:48:15 <mm_freak> i think something can be done about that by using polymorphic recursion and type-level fixed points
19:48:30 <Tekmo> So the solution I've been using is more banal
19:48:33 <jmcarthur> i think for your regex this should be doable somehow. however, if it had backreferences then you would run into big trouble
19:48:51 <mm_freak> jmcarthur: backreferences aren't "regular" anyway
19:49:00 <Tekmo> So you can get some idea of where I'm going with this if you've read this post of mine: http://www.haskellforall.com/2013/09/perfect-streaming-using-pipes-bytestring.html
19:49:33 <mm_freak> Tekmo: i've read that one
19:49:35 <Tekmo> The basic idea is that you model your input in such a way that each element of the input returns the next element
19:49:36 <jmcarthur> right. i'm just remarking that i think for this case there should in principle be a way to optimize it very well, and i think it should be possible with ghc as it exists today.
19:49:56 <Tekmo> So, for example, that type would be modeled as
19:50:00 <Tekmo> (using pipes notation)
19:50:23 <Tekmo> m (a, Producer (Either B C) m (Producer (Either D E) m ()))
19:50:34 <Tekmo> Ugly, I know
19:51:00 <mm_freak> Tekmo: let me try something
19:51:05 <Tekmo> And instead using an approach similar to what Oleg and SPJ recommended in their pretty printing paper
19:51:16 <Tekmo> ... where you define functions between these representations
19:51:30 <Tekmo> You obviously lose something when you do this, which is a monadic way to build the stream transformation
19:52:26 <lightquake> there's a page somewhere documenting how haskell's IO system worked before monads
19:52:36 <lightquake> does anybody have a link?
19:52:42 <Tekmo> Yeah, the [Request] -> [Response]
19:53:13 <lightquake> [Response] -> [Request]
19:53:14 <Tekmo> This is a nice summary: http://r6.ca/blog/20110520T220201Z.html
19:53:50 <zq> holy shit, Num defines (^) logarithmically
19:53:57 <Tekmo> So the `pipes` equivalent would be something like: Producer Response IO r -> Producer Request IO r
19:54:10 <zq> haskell is so smart :')
19:54:17 <Tekmo> zq: That's why it has an `Integral` constraint on the exponent
19:54:28 <mm_freak> Tekmo: do you want to encode the pattern of the input stream on the type level?
19:54:41 <Tekmo> mm_freak: Yeah, that's what I was trying to do
19:55:00 <Tekmo> mm_freak: That's why I've been experimenting with functions between `Producer`s and `FreeT`s
19:55:29 <jmcarthur> zq: would be even nicer if for small exponents the thing would be unrolled
19:56:25 <mm_freak> Tekmo: i think i have an interesting idea…  let me try it
19:56:46 <Tekmo> mm_freak: Ok :)
19:58:41 <jle`> @src (^)
19:58:41 <lambdabot> x ^ 0            =  1
19:58:41 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
19:58:41 <lambdabot>   where f _ 0 y = y
19:58:41 <lambdabot>         f x n y = g x n
19:58:41 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
19:58:43 <lambdabot>                       | otherwise = f x (n-1) (x*y)
19:58:45 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
19:59:33 <glguy> jmcarthur: They are
20:00:00 <glguy> jmcarthur: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Real.html and search for "^2/Int"
20:00:19 <jmcarthur> ah, rewrite rules
20:00:27 <Tekmo> Woah, that's neat
20:01:16 <jmcarthur> i was rather remarking on the general lack of unrolling in ghc (although i understand with all the other inlining it is difficult to tell when it would be a win), but it's nice to see that for this common case it's handled reasonably
20:01:19 <arkeet> hm, why isn't it something like x^4 = let u = x; v = u*u in v*v
20:01:22 <pdxleif> carter: I didn't need a 'brew install apple-gcc42' on a fresh mavericks vm, RE: https://gist.github.com/cartazio/7131371
20:01:32 <glguy> arkeet: read up
20:01:43 <arkeet> ah
20:01:43 <pdxleif> Just installed xcode & haskell platform and stuff and everything seems to wokr
20:01:45 <arkeet> heh
20:01:51 * hackagebot afis 0.1.2 - Anti-forensic Information Splitter  http://hackage.haskell.org/package/afis-0.1.2 (VincentHanquez)
20:01:59 <jmcarthur> arkeet: there's a note about that
20:02:01 * arkeet thinks about what it looks like in the generated code
20:03:19 <mm_freak> arkeet: that's what x^4 becomes…  (^) uses square-and-multiply
20:03:20 <jle`> is there a @src equiv for ghci?
20:03:30 <arkeet> mm_freak: no, I'm talking about the rewrite rule.
20:03:39 <mm_freak> ah, sorry
20:04:23 <mm_freak> Tekmo: it's difficult to encode the idea without dependent types =/
20:04:25 <arkeet> ok I can't imagine why one would be faster than the other.
20:04:30 <Tekmo> mm_freak: Yeah, I know
20:05:00 <lightquake> Hask is a monoidal category, right?
20:05:16 <zq> mmmmmmmmmmmmmmmmmmmmmmmmmmm
20:05:40 <mm_freak> Tekmo_afk: here is a terribly verbose draft of the idea: http://lpaste.net/94912
20:06:04 <mm_freak> Tekmo_afk: that's where dependent types come in:  if you could encode on the type level that one character has to follow another, then by unification you can enforce the regular pattern
20:06:23 <mm_freak> that's why RegChar has two arguments
20:06:33 <mm_freak> RegChar a b -> RegChar b c -> …
20:06:41 <zq> okay now how do i do peg grammars in haskell
20:06:51 <funfunctor> random question.. is there a english word that means "a state of war"..
20:07:09 <mm_freak> funfunctor: perl
20:07:15 <funfunctor> one of those days I forgot my own name
20:07:17 <funfunctor> LOL!
20:07:29 <funfunctor> I was going to say pointer arithmatic..
20:07:34 <monochrom> "at war"
20:07:43 <arkeet> lightquake: there are a few monoidal structures that could make Hask a monoidal category.
20:07:46 <sm> conflict
20:07:55 <arkeet> lightquake: at least, assuming it was a category at all.
20:08:01 <jle`> funfunctor: mobilized?
20:08:23 <funfunctor> nar.. I should look up some latin
20:08:25 <lightquake> arkeet: the one i can think of is (,) as product and () as identity; are there others?
20:08:30 <redscare> is there a better/cleaner way to write "foldl (-) (head l) (tail l)" to take the differences of the elements of a list?
20:08:36 <arkeet> lightquake: yeah, that's the most obvious one.
20:08:48 <arkeet> lightquake: there's also Either and Void
20:08:52 <monochrom> foldl1 (-) l
20:08:53 <arkeet> there are probably a bunch.
20:09:09 <arkeet> well, there are at least those two.
20:09:18 <arkeet> only (,) and () makes it closed monoidal though.
20:09:24 <lightquake> closed monoidal?
20:09:36 <arkeet> look it up, I guess
20:09:57 <arkeet> (a,b) -> c  ~  a -> (b -> c)
20:10:10 <Rembane> redscare: What's the differences of the element of a list?
20:10:19 <funfunctor> hawkism is a word O_o
20:10:30 <jle`> redscare: maybe something like zipWith (-) l (tail l)
20:10:35 <arkeet> lightquake: then there's the issue of whether Hask is a category at all. :p
20:10:43 <arkeet> (it isn't. at least not under (.) and id)
20:10:50 <lightquake> arkeet: why isn't it?
20:10:58 <arkeet> undefined . id  /=  undefined
20:10:59 <jle`> but i think there might be some prelude function to make it even simpler
20:11:07 <lightquake> ah, yeah
20:11:11 <funfunctor> belligerence is what I was thinking of
20:11:33 <jle`> > let l = [2,8,4,9] in zipWith (-) l (tail l)
20:11:34 <lambdabot>   [-6,4,-5]
20:11:43 <arkeet> lightquake: it might be under a strict version of (.) but that's ugly.
20:12:09 <jle`> redscare: actually i'm not sure that that's what you want ... might have misinterpreted your description
20:12:15 <lightquake> it's easier just to ignore undefined and friends when considering Hask :P
20:12:31 <arkeet> it's easiest to pretend Hask is strict and total, yes :p
20:12:38 <redscare> foldl1 (-) was exactly what i wanted, but thanks for the other laternatives
20:12:42 <arkeet> er,
20:12:46 <arkeet> haskell.
20:12:51 <mm_freak> that reminds me of a question:  is there an interesting difference between the categories Set and Type?
20:12:51 <mm_freak> (i'm just inventing the name "Type" for the category of types and functions)
20:13:11 <arkeet> types in e.g. haskell?
20:13:37 <arkeet> because that doesn't have pullbacks, for instance.
20:13:43 <arkeet> while Set does.
20:14:23 <mm_freak> arkeet: are you answering my question?
20:14:27 <arkeet> (we can't make a type of "things of type A satisfying a predicate p")
20:14:27 <arkeet> yes
20:14:39 <mm_freak> arkeet: "type" as in intuitionistic type theory
20:14:45 <arkeet> I don't know what that is =(
20:16:29 <arkeet> I expect the answer to be "yes", anyway.
20:17:14 <lightquake> arkeet: pullbacks?
20:17:18 <arkeet> yes
20:17:26 <mm_freak> types are basically sets with structure, like: data Nat = Z | S Nat
20:18:22 <arkeet> mm_freak: well, what about my parenthesized statement
20:19:10 <mm_freak> arkeet: oh, of course we can make such a type
20:19:15 <arkeet> I also don't know about dependent types.
20:19:39 <arkeet> there's maybe some excluded middle/axiom of choice type thing that your thing doesn't satisfy.
20:19:54 <jle`> redscare: if you ever do foldl with the head and the tail of a list, you could just use foldl1
20:20:03 <jle`> redscare: foldl1 (-) l
20:20:19 <mm_freak> arkeet: intuitionistic type theory rejects the LEM and there is no need for an axiom of choice
20:20:43 <Tekmo> mm_freak: Yeah, I tried something like that before.  The problem is that then you need an indexed monad and then the types get hairy
20:21:04 <arkeet> I would say that is an interesting difference, then!
20:21:54 <frx> mmm hairy
20:22:29 <mm_freak> Tekmo: exactly…  i think it's not worth the trouble
20:22:31 <lightquake> ah ok i think i get it. given a set S you can form the restriction '{x \in s : p(x)}' by taking the pullback S x2 1 where p : S -> 2 and T : 1 -> 2 is just True, but you can't do that in, say, Hask
20:23:36 <mm_freak> Tekmo: my conjecture is that in about 2030 haskell will get full dependent types in order to reclaim the territory that idris has conquered, so you could try again then =)
20:24:41 <lightquake> i still don't understand what pullbacks *are* but at least i think i get why Hask doesn't have them
20:28:21 <mm_freak> lightquake: this video series introduced them nicely: http://www.youtube.com/watch?v=eu0rj5C2Otg&list=PLE4CC57A4C08EEF2F
20:28:28 <mm_freak> it's a good introduction in general
20:33:44 <f-a> good morning. I have just finished to read a paper on arrows and wanted to write a small toy project to get acquainted with them. A question, is there a standard way to "mix" arrow functionalities (as there is for monads, i.e. monads transformers?)
20:34:39 <adek> Is there some way to make cabal work on Mac? Now I got a bunch of errors like error: stdint.h: no such file or directory :( I got gcc-4.8 installed but problem definitely looks like libraries are not in compiler path
20:35:27 <mm_freak> f-a: sure, there are arrow transformers
20:35:43 <mm_freak> f-a: here is the non-transformer automaton:  newtype Auto a b = Auto (a -> (b, Auto a b))
20:36:06 <mm_freak> f-a: and the transformer variant:  newtype AutoT cat a b = AutoT (a `cat` (b, AutoT cat a b))
20:36:34 <f-a> thanks mm_freak
20:37:04 <mm_freak> f-a: however, arrow transformers are a lot more awkward to implement and work with than monad transformers and the need for them is so rare that you would rather want to transform to a monad instead
20:37:15 <mm_freak> f-a: newtype AutoT m a b = AutoT (a -> m (b, AutoT m a b))
20:37:39 <enthropy> the issue might just be that arrows are not popular
20:37:41 <mm_freak> i've worked with arrows for years now, and i've never needed arrow transformers
20:38:07 <mm_freak> enthropy: the issue is that not many arrows are "proper" (i.e. non-monad) arrows
20:38:36 <mm_freak> the probability that you may actually need to combine two of them is almost zero
20:38:59 <mm_freak> and even if you do, you're likely better off just writing the combined arrow right away
20:39:23 <mm_freak> arrow transformers are /really/ awkward
20:39:25 <f-a> mm_freak: that's interesting. So when you need something more (like, to add computations that can fail to an arrow which handles state) you just glue a monad in, am I wrong?
20:39:39 <mm_freak> f-a: correct
20:40:29 <mm_freak> f-a: with an arrow transformer you would have to reinvent Maybe/Either as an arrow variant or lift them using Kleisli
20:40:41 <mm_freak> both are ugly solutions
20:42:36 <f-a> theoretically I could just decide what things I do need (state, 'failable' computations, log, etc.) and write my arrow. That would be a lot of boilerplate indeed.
20:43:14 <mm_freak> f-a: if that's your entire arrow, then there is really no reason to use an arrow in the first place
20:45:28 <f-a> well... I guess to make that useful I would need something meaningful which is done at bind time and not at evaluation time (pardon my jargon, I am not literate in the matter)
20:45:48 <funfunctor> Has anyone written a pure HTML only web browser in haskell before?
20:46:14 <funfunctor> I figured it would not be too hard to write a HTML parser with attoparsec at all..
20:46:52 <f-a> there is a xmlish parser which parses tag soups too, iirc
20:46:53 * hackagebot postgresql-simple 0.3.9.0 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.3.9.0 (LeonSmith)
20:48:56 <mm_freak> f-a: i always suggest to implement this "monad":  data State' s a = State { usesPut :: Bool, runState :: s -> (s, a) }
20:49:06 <mm_freak> i'm quoting "monad", because it's not a monad
20:49:28 <mm_freak> f-a: you will notice two things:  1. you can't implement (>>=), 2. you can implement Applicative
20:49:55 <dwcook> mm_freak, is it because you'd need to invent a Bool?
20:50:09 <dwcook> Or wait, I think I thought through that wrong
20:51:07 <f-a> that'd be an instructive exercies mm_freak , thanks for the tip
20:59:11 <mm_freak> dwcook: well, it's not far from the truth =)
20:59:30 <f-a> mm_freak: of course it's impossible because a -> m b. Does that mean that arrows do not have control structures (like Applicative)?
21:00:01 <mm_freak> f-a: they do, but the structure of the computation cannot depend on an individual computation's outcome
21:00:48 <mm_freak> with ArrowChoice you can select the path a signal follows, but the choice of paths will be fixed
21:01:43 <mm_freak> to use the original parser example for which arrows were introduced:  to parse a CSV file with a header first i'd parse the header line to determine the individual column parsers
21:01:51 <mm_freak> header :: Parser [Parser Field]
21:02:03 <mm_freak> then i'd parse the fields using the resulting parsers
21:02:11 <mm_freak> this approach is impossible with arrows
21:02:13 <lpaste> DiegoNolan pasted “Random Monad ” at http://lpaste.net/94913
21:02:24 <DiegoNolan> why is this code wrong?
21:02:45 <f-a> what's the error, DiegoNolan
21:03:13 <DiegoNolan> Could not deduce (g ~ ([a],g)) from the context (RandomGen g)
21:03:42 <mm_freak> DiegoNolan: check the second argument to foldl
21:04:31 <DiegoNolan> do i have to explicitly declare it as a stdGen or something
21:04:32 <DiegoNolan> ?
21:04:52 <mm_freak> DiegoNolan: inner (os, lg) …
21:04:58 <mm_freak> that suggests that you want a tuple
21:05:10 <DiegoNolan> i do
21:05:16 <mm_freak> here is another hint:  what if the toRun list is empty?
21:05:19 <DiegoNolan> first is the list of objects
21:05:37 <f-a> I have learned more about arrows in this bried chat than with the tutorials out there mm_freak . If you will ever feel bored, consider writing one :P
21:05:41 <DiegoNolan> toRun isn't a list
21:05:47 <DiegoNolan> it is a single element
21:05:59 <mm_freak> f-a: i've actually written an incomplete arrow tutorial =)
21:05:59 <DiegoNolan> ahh shit
21:06:07 <mm_freak> f-a: but it's currently offline
21:06:12 <DiegoNolan> ty
21:06:14 <DiegoNolan> ([],gen)
21:06:21 <mm_freak> DiegoNolan: there you go =)
21:06:22 <f-a> :c
21:06:34 <mm_freak> f-a: wait, i'll upload it somewhere
21:07:47 <f-a> please do so for the haskellers out there
21:10:37 <mm_freak> f-a: http://lpaste.net/94914
21:10:43 <mm_freak> i suggest feeding that through pandoc -S
21:11:45 <f-a> thanks
21:12:01 <donny_> @pl \i -> use loopStack >>=  \ a->fromMaybe (throwError $ "Loopstack is empty.") (fmap (return)(a ^? ix i))
21:12:04 <lambdabot> (use loopStack >>=) . (fromMaybe (throwError "Loopstack is empty.") .) . (fmap return .) . flip (^?) . ix
21:12:04 <lambdabot> optimization suspended, use @pl-resume to continue.
21:12:11 <mm_freak> f-a: also it's literate haskell, so save it as .lhs instead of .txt =)
21:52:11 <chrisdotcode> hey guys, I'm trying to write some json to a file with aeson, and it's not working:
21:52:11 <chrisdotcode> writeFile "test.json" (encode $ toJSON meta) gives me:
21:52:11 <chrisdotcode> Couldn't match type `Data.ByteString.Lazy.Internal.ByteString' with `[Char]'
21:55:17 <ClaudiusMaximus> chrisdotcode: maybe you need to use Data.ByteString.Lazy.writeFile
21:55:20 <geekosaur> chrisdotcode, you're getting the wrong writeFile. I think you want to import Data.ByteString.Lazy as BS and use BS.writeFile
21:56:10 <chrisdotcode> geekosaur, ClaudiusMaximus: yeah, that worked, thanks guys :)
21:56:25 <chrisdotcode> I was trying to import Data.ByteString.Lazy.Internal.ByteString, but that didn't work
21:58:34 <chrisdotcode> is there any reason why I using "Internal.bytestring" part work?
21:58:37 <geekosaur> yeh, the extra stuff was shown because you didn't have Data.ByteString.Lazy imported; the actual ByteString type is defined in an internal hidden modul
21:58:55 <geekosaur> which is hidden because you can't and shouldn't be able to get at the actual implementation
21:59:16 <geekosaur> (which is moderately hairy ghc internals hacking)
22:00:19 <geekosaur> the convention is such hidden internals are in a module whose name ends with ".Internals" and you therefore know not to touch it
22:00:27 <chrisdotcode> ah, well now I know that :)
22:00:40 <chrisdotcode> so if I get that error again, remove the interals part, and it should generally work?
22:01:03 <geekosaur> (usually it *can* be imported, for external stuff that really does need to get at the internals for some reason, but you have to read internals docs to know how to use it correctly)
22:01:12 <geekosaur> but yes, usually you drop the .Internal part
22:01:56 * hackagebot constraints 0.3.4.2 - Constraint manipulation  http://hackage.haskell.org/package/constraints-0.3.4.2 (EdwardKmett)
22:02:00 <chrisdotcode> sweet, thanks again geekosaur :)
22:03:40 <geekosaur> you may be seeing this come up a little more often in the future because it has been requested that Data.Map get an Internals module for those cases when something really does need to see the implementation of Map
22:06:41 <norfen> So i've been looking into writing some kind of chat server
22:07:03 <norfen> But I can't get around the idea of a global variable for all the users
22:07:32 <simpson> norfen: I struggled with this problem a couple weeks ago.
22:07:51 <zomg> you could certainly use that, or carry a value along in a reader monad or such
22:07:59 <simpson> norfen: Maybe this will interest you: http://community.haskell.org/~simonmar/slides/cadarache2012/5 - server apps.pdf
22:08:06 <argiopetech> State. Have to be able to change as users appear/leave.
22:09:04 <mm_freak> a chat server certainly has to have something application-global
22:09:10 <mm_freak> but it doesn't have to be the state itself
22:09:17 <mm_freak> because that one can be managed by, say, a separate thread
22:09:28 <mm_freak> the the only global thing is the channel to communicate with that thread, i.e. an MVar
22:10:07 <mm_freak> a more advanced approach is to use a reactive framework like sodium
22:10:26 <mm_freak> cleaner, more modular code, but has a learning curve
22:11:07 <norfen> Something event based does sound like it would be cleaner
22:11:50 <norfen> simpson: thanks for the pdf, its right on target
22:11:59 <simpson> norfen: Excellent.
22:21:57 * hackagebot zasni-gerna 0.0.1 - lojban parser (zasni gerna)  http://hackage.haskell.org/package/zasni-gerna-0.0.1 (YoshikuniJujo)
22:26:57 * hackagebot gloss 1.8.1.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.8.1.1 (BenLippmeier)
22:26:59 * hackagebot papillon 0.0.88 - packrat parser  http://hackage.haskell.org/package/papillon-0.0.88 (YoshikuniJujo)
22:40:02 <hsimplex> hi, I'm really new to haskell. I want to search a string for a substring and return a list of indices where it appears
22:40:29 <hsimplex> now, data.bytestring has findSubstrings and that sounds perfect, but I cant figure out how to pass it my strings
22:40:52 <mzero> well, hsimplex -- if your strings are String data, then you can't
22:41:17 <hsimplex> I see
22:41:21 <joelteon> how do I tell if my compiler is profiled?
22:41:52 <mzero> hsimplex: have you looked through the functions available in Data.List?
22:42:15 <mzero> remember that all of those are applicable to String -- and really your desired function is about lists generally
22:43:24 <mzero> that said, I don't see the function you want specifically, you'll have to write it
22:43:36 <hsimplex> yeah, some of them are close
22:43:37 <mzero> but given the function isPrefixOf -- it should be pretty easy
22:43:52 <mzero> I assume you want    String -> String -> [Int]
22:43:56 <hsimplex> yes
22:44:15 <mzero> question, though - why do you want the indicies? Do you intend to use them to go back into the String and extract info?
22:45:10 <hsimplex> my naive way of imagining a solution is filter against isPrefix on a list of pattern sized slices thats zipped with the indices or something
22:45:40 <mzero> well good! that's close to what I'd do
22:45:49 <hsimplex> mzero: I'm doing some exersizes
22:46:04 <mzero> okay - so you want directions here, not solutions
22:46:46 <mzero> your way of imagning is good --- look at the function   tails   and consider that when testing for isPrefixOf - there is no reason for the second string to be trimmed to the first
22:46:48 <hsimplex> yup :)
22:47:17 <hsimplex> oh right, cool
22:49:53 <flebron> Is there a way to see, given a haskell expression, how it is being interpreted as fully parenthesized?
22:50:09 <flebron> i.e. in something like a^(n-1) `mod` n == 1 && f n as, I'd like to see how precedence is working.
22:50:20 <mzero> I don't know of one
22:50:31 <mzero> that might make an interesting ghci command
22:51:48 <mzero> but as a rule of thumb - function application via adjecency binds tightest, then comes those `op` operators, and then finall all the rest in normal mathematical order....
22:52:07 <mzero> mind you, that doesn't help knowing how <$> <*> >>= and other stuff relate...
22:56:58 * hackagebot gloss-raster 1.8.1.1 - Parallel rendering of raster images.  http://hackage.haskell.org/package/gloss-raster-1.8.1.1 (BenLippmeier)
22:58:48 <lpaste> edwardk pasted “Steppable ST” at http://lpaste.net/94915
23:00:38 <pdxleif> aeson can "bind" the jason data to a bunch of types; is there anything similar for XML?
23:03:13 <dv-_> is there a way to see the instances generated by GeneralizedNewtypeDeriving so I can just paste them in?
23:03:43 <mzero> pdxleif: do you want to parse XML into some general XML tree data types, or do you want to define your data types and class instances for how these map to/from XML?
23:04:37 <mzero> dv-_: I don't know of one, but they are all just simple mechanical defintions based on the types of the typeclass methods
23:04:59 <Ralith> mzero: I think he's talking about how with aeson there's a bunch of generic instances so you can just take arbitrary JSON and decode it inside Maybe
23:05:51 <flebron> mzero: Thanks :)
23:05:53 <mzero> so, the first? or do you mean predefined instances for into pairs, lists, etc...
23:07:42 <Ralith> the latter
23:07:49 <Ralith> I presume
23:07:55 <mzero> in any event, dv-_ , there are several packages: xml is simple, HaXml is very full features,
23:08:28 <Ralith> mzero: pdxleif asked that question.
23:09:09 <mzero> whoops
23:09:14 <mzero> :-)
23:11:26 <pdxleif> mzero: I want to define my domain-specific data types and class instances to map to those.
23:11:51 <mzero> ah
23:13:01 <pdxleif> I guess I could define some similiar FromXML typeless for simple-xml or whatever?
23:13:05 <pdxleif> *typeclass
23:13:09 <mzero> look at hxt and related packages
23:14:29 <mzero> but I'm not sure that takes the same approach as aeson (which is admittedly a very sweet approach - but might be too simple for XML)
23:27:35 <hsimplex> so I've got a list of Bools, and I want a [Bool] -> [Int] where the ints are just the indices or the Trues
23:28:11 <hsimplex> based on the Data.List filter documentation, I tried
23:28:13 <hsimplex> findIndices prefixes = [ y | (x, y) <- zip(prefixes, [0..]), x == True]
23:28:28 <hsimplex> but I'm just guessing what <- means here
23:28:39 <Iceland_jack> It means ‘draw from’
23:28:56 <Iceland_jack> > [ i | (True, i) <- zip [True, True, False, True] [0..] ]
23:28:58 <lambdabot>   [0,1,3]
23:29:01 <liyang> hsimplex: forget monad/list comprehensions. Just use the usual list functions and compose them.
23:29:08 <Cale> Also, you want to apply zip to two arguments, not a pair
23:29:47 <mzero> we could re-write your list comprehension as
23:30:03 <liyang> > fmap fst . filter snd . zip [0..] $ [True, False, False, True]
23:30:04 <lambdabot>   [0,3]
23:30:18 <mzero> > filter ((== True).fst) $ zip [True, True, False, True] [0..]
23:30:20 <lambdabot>   [(True,0),(True,1),(True,3)]
23:30:21 <mzero> or just
23:30:33 <hsimplex> whats the $ mean?
23:30:36 <mzero> > map snd $ filter ((== True).fst) $ zip [True, True, False, True] [0..]
23:30:37 <lambdabot>   [0,1,3]
23:30:45 <liyang> hsimplex: without the $ :
23:30:47 <mzero> Oh     a  $  b    is just   a b
23:30:48 <Iceland_jack> What ever you think adds clarity…
23:30:51 <Cale> hsimplex: f $ x = f x, but $ has very low precedence
23:30:52 <liyang> > (fmap fst . filter snd . zip [0..]) [True, False, False, True]
23:30:53 <lambdabot>   [0,3]
23:31:09 <mzero> so think of $ as "parenthesize everything to the right"
23:31:25 <mzero> or "make everything to the right the argument to the stuff on the left"
23:31:27 <hsimplex> ah
23:31:29 <Cale> (It also unfortunately associates to the right instead of to the left how it should)
23:31:31 <mzero> also
23:31:38 <hsimplex> then what does the . mean?
23:31:45 <Cale> (.) is function composition
23:31:47 * mzero disagress with Cale
23:31:50 <Cale> (f . g) x = f (g x)
23:31:51 <hsimplex> oh its composing I see
23:32:13 <Iceland_jack> hsimplex: Most of this information is well explained in LYAH:
23:32:13 <Iceland_jack> @where lyah
23:32:13 <lambdabot> http://www.learnyouahaskell.com/
23:32:25 <mzero> notice that (== True) can eb dropped, as llyang did
23:32:51 <Cale> Whenever you see something like  f $ g $ h $ x  you can always replace that with  f . g . h $ x  because of the right associativity of $ so having it associate to the right doesn't add much.
23:33:20 <hsimplex> ok cool
23:34:50 <Cale> (Moreover, you probably should, because it's easier to manipulate expressions with function composition in them, because function composition is properly associative, which means that the expressions have more effective subexpressions than they otherwise would. For instance, g . h is a meaningful thing on its own in the above, while g $ h on its own will likely be a type error.)
23:34:51 <Iceland_jack> There is of course also:
23:34:51 <Iceland_jack> > elemIndices True [True, True, False, True] -- hsimplex
23:34:52 <lambdabot>   [0,1,3]
23:35:35 <Iceland_jack> > findIndices (== True) [True, True, False, True]
23:35:37 <lambdabot>   [0,1,3]
23:37:08 <hsimplex> oh that works, thanks
23:41:56 <hsimplex> I've been trying to search text for a substring and return the indices, and I have that now with elemIndices and findPrefixes pattern text = isPrefixOf pattern text : findPrefixes pattern (tail text)
23:42:03 <hsimplex> but is there a better way?
23:42:19 <mzero> yes
23:42:55 <mzero> > let spots a = map fst . filter (isPrefixOf a . snd) . zip [0..] . tails   in   spots "dog" "any dog can write doggeral"
23:42:56 <lambdabot>   [4,18]
23:43:25 <mzero> so you use the pattern (reading spots from right to left):
23:44:24 <mzero> 1) generate all possible things (tails), 2) number them (zip [0..]),  3) filter out the ones you want (filter (someTextHere . snd)) - filtering the snd of the pair, 4) take the fst of the pair to get the indicies of the matches
23:45:23 <mzero> This pattern - pair 'em up... filter by testing on one side of the pair... map to take the other side...    is very common
23:45:26 <mzero> and very useful
23:48:18 <mzero> if you are not used to the partial "point free" style I used...
23:48:59 <mzero> > let spots a xs = map fst $ filter (isPrefixOf a . snd) $ zip [0..] $ tails xs  in   spots "cat" "catenate the catwalling"
23:49:01 <lambdabot>   [0,13]
23:49:50 <hsimplex> oh thats nice
23:50:21 <mzero> it is just a straight forward expression of the idea you had at the start
23:50:27 <hsimplex> what would that look like with list comprehension, back there I tried something like (x, y) <- [(Bool, Int)]
23:51:14 <hsimplex> it was a guess at haskell sytax but what would be right?
23:51:48 <mzero> > let spots a xs = [ i | (i, ys) <- zip [0..] (tails xs), a `isPrefixOf` ys ]
23:51:49 <lambdabot>   not an expression: `let spots a xs = [ i | (i, ys) <- zip [0..] (tails xs),...
23:52:26 <mzero> > let spots a xs = [ i | (i, ys) <- zip [0..] (tails xs), a `isPrefixOf` ys ] in spots "dog" "dog it all, doggonit"
23:52:28 <lambdabot>   [0,12]
23:52:56 <mzero> but, frankly, I don't think the list comprehension version is at all as clear as the original   spots a = .... version
23:53:11 <hsimplex> sure, O
23:53:26 <hsimplex> I'm just curious now
23:53:37 <mzero> Notice that since you need the indicies and the test cases in parallel, you can't avoid the zip, even with list comprehension
