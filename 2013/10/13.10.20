00:00:05 <Makoryu> zzo38: I mean that values can't directly be used as types
00:00:17 <Makoryu> Though you *can* construct types from values in certain clever ways
00:00:29 <zzo38> Makoryu: Yes I know; I mean how to fake it somehow in order to do something like how I specified.
00:00:59 <Makoryu> http://hackage.haskell.org/package/reflection
00:01:32 <zzo38> Another example is that a directed graph might be defined as something like (N : enum, E : set (N, N)). Is there a way using Rank-N types or whatever?
00:12:18 <arkeet> > iterate (\x -> zipWith (+) ([0] ++ x) (x ++ [0])) [1]
00:12:20 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
00:12:49 <zzo38> I don't know how Data.Reflection can be used for such thing as I mentioned, if it can be used for that at all.
00:12:54 <zzo38> Is there the way?
00:16:54 <zzo38> Also, that program seems to be using undefined features of unsafeCoerce, which might happen to work in the given implementation but isn't how it should be in use.
00:17:21 <arkeet> reflection relies on magic.
00:17:44 <arkeet> it is documented as non-portable, after all.
00:21:57 <arkeet> but all it relies on is the fact that
00:22:24 <zzo38> But, I wanted to know how to do something like I have mentioned above, in Haskell. The reflection package doesn't look like to do that and I don't like their kind of unsafeCoerce use.
00:22:29 <arkeet> class constraints are implemented as function arguments given by dictionary passing.
00:22:52 <arkeet> it seems you are looking for dependent types.
00:23:01 <arkeet> haskell does not do dependent types.
00:23:18 <zzo38> O, is that what dependent types are?
00:23:50 <zzo38> I could see that it expects class constraints are implemented as function arguments given by dictionary passing, but I still don't like that it has to depend on such feature.
00:24:10 <arkeet> like it or not, it works ;)
00:24:40 <arkeet> and (in GHC at least) is perfectly safe
00:25:06 <zzo38> arkeet: Even in later versions of GHC that don't exist yet, and if some strange optimizations are being done too?
00:26:28 <arkeet> well, I can't say anything about that.
00:26:34 <arkeet> it seems unlikely to change, though.
00:26:50 <zzo38> Well, whatever.
00:26:50 <arkeet> and I don't know what sort of optimizations you mean.
00:27:08 <zzo38> Do you know if there is a way to fake the kind of types I specified?
00:27:17 <arkeet> I don't know.
00:29:47 <zzo38> Using GADTs and Rank N types and associated type families and whatever?
00:41:28 <funfunctor> Hi
00:42:24 <funfunctor> I know how to run shell commands in Haskell and I am doing a parser with Attoparsec.. What I wanted to know is how to put the two things together..?
00:43:35 <funfunctor> ah nm, I worked it out :)
01:15:09 <codygman> Can you pass stdin into System.command?
01:17:17 <funfunctor> codygman: I think you just do it with the Handle type in System.Process
01:17:34 <funfunctor> There are stdin,stdout and stderr defined..
01:17:49 <funfunctor> So should be possible to create pipes and things..
01:18:05 <ezrios> Can anyone recommend a good resource for working with the Writer monad
01:18:08 <funfunctor> I am trying to work out how to do something cleanly..
01:18:24 <funfunctor> ezrios: I think the wiki has one?
01:18:25 <ezrios> Apparently LYAH and RWH are out of date on this topic, and I am having trouble getting http://stackoverflow.com/questions/11684321/how-to-play-with-control-monad-writer-in-haskell to work
01:18:48 <funfunctor> codygman: I am doing readProcess "git" ["rev-parse", "HEAD"] "" as a test.
01:18:59 <wagle> is there a shorthand for \x -> (x, len x)
01:19:07 <funfunctor> However I want to define all the sub commands in a GADT
01:19:08 <wagle> pointless if it were?
01:19:24 <wagle> @pl \x -> (x, len x)
01:19:24 <lambdabot> ap (,) len
01:19:40 <wagle> neat
01:19:44 <wagle> i think
01:20:12 <funfunctor> anyone got a example on how to use a GADT to describe some subcommands of for example git?
01:21:03 <funfunctor> I was thinking of a main function that has a switch on the type and then runs the IO functions that actually run the subcommands however the main function is pure..
01:21:52 <dpwright> Where should I look for information on treating a type as unboxed? (/ is it even worth it?)
01:22:14 <funfunctor> for example, gitExec .. = .. gitStatus and then we have a gitStatus :: IO String function that gets called.
01:22:28 <simpson> dpwright: "magic hash" is a good phrase to look for, for explaining GHC's unboxed magic.
01:23:30 <dpwright> simpson: Thanks, will take a look
01:24:59 <ezrios> funfunctor: Do you know of any other resources? The examples in the wiki are quite hard to follow
01:25:42 <dpwright> I'm not sure whether I actually need it for what I'm doing, really... I have a grid for a board game (2d, but could potentially be multidimensional too), where each point is of type data Point = Empty | Played Player and player is Player = Black | White... so it's very simple, it could basically be in one of three states
01:26:07 <dpwright> I'm toying with repa to manage this grid, but obviously not performing mathematical operations on its contents
01:26:24 <kryft> Go?-)
01:26:37 <dpwright> but everything I've read says repa is faster with unboxed data
01:27:55 <dpwright> kryft: ;-) gave the game away (literally)... but I might experiment a bit with more than just the traditional 19x19
01:28:22 <funfunctor> ezrios: not really, I just randomly google :p
01:28:27 <lpaste> bitemyapp pasted “No title” at http://lpaste.net/94520
01:28:44 <bitemyapp> so how do I go about improving this?
01:29:34 <dpwright> at any rate, I could represent each of these states as a number if I wanted, which would allow me to use an unboxed int
01:30:02 <dpwright> but the question is: is there any point? and, is there a typeclass I can use to perform the conversion?
01:31:54 <bitemyapp> It feels kind of silly to be doing a pattern match for a dispatch operation like that. Ordinarily I'd have a Map of [String] to [[String] -> a]
01:36:12 <funfunctor> dumb question, need to convert between monadic and non-monadic values in a case statement.. little confused by arrows everywhere..
01:36:43 <funfunctor> I have a function that returns IO String type and want a String type. How do I do that in a case?
01:37:42 <funfunctor> I thought it would be like: Status -> zpoolStatus =>>
01:37:49 <funfunctor> clearly that is wrong..
01:38:31 <arkeet> funfunctor: you don't.
01:38:53 <arkeet> funfunctor: you should read http://www.haskell.org/haskellwiki/Introduction_to_IO
01:39:21 <arkeet> or http://www.haskell.org/haskellwiki/How_to_get_rid_of_IO
01:40:09 <Sgeo> What should I call a function of type (Monad m) => m a -> a?
01:40:35 <arkeet> that doesn't exist.
01:40:39 <Sgeo> (I know that can't exist in Haskell, but I made a function in another language that behaves like that in a dynamic scope)
01:40:52 <arkeet> I don't think you did.
01:41:05 <Sgeo> http://pasterack.org/pastes/1950
01:41:21 <mikeplus64> Sgeo: extract?
01:41:25 <mikeplus64> @hackage comonad
01:41:25 <lambdabot> http://hackage.haskell.org/package/comonad
01:41:30 <Hermit> run?
01:41:31 <Sgeo> The val you see on line 19 is a first-class function
01:41:33 <arkeet> comonads aren't monads.
01:41:52 <arkeet> Sgeo: it looks like you just wrote liftM2 (+)
01:41:54 <Sgeo> Defined in the lexical+dynamic scope of with-monad
01:43:08 <Sgeo> arkeet: hmm? But I'm not wrapping + in any way. I'm just having val bind to the delimited continuation
01:43:33 <Sgeo> Sort of like turning the <- that do exposes into a first-class function
01:43:54 <arkeet> I don't know what's going on in that code.
01:43:54 <Sgeo> (Which still only works in the scope of something similar to do)
01:44:04 <funfunctor> I think I half get why you should generatly not do that..
01:44:13 <arkeet> but the Cont monad is general enough to cover any other monad.
01:44:28 <arkeet> sort of.
01:44:57 <Sgeo> arkeet: yes, and I'm effectively using the fact that Schemes have a "nicer syntax" for Cont to make a "nicer syntax" for monads in general
01:45:16 <Sgeo> That nicer syntax being making <- into a first-class sort of thing
01:45:59 <arkeet> well I can't say, since I never managed to figure out how to look past all the parentheses everywhere. =(
01:46:23 <Sgeo> I tend to rely on indentation
01:46:28 <Sgeo> And I think that's the proper behavior
01:46:52 <bitemyapp> You don't really see the parens if you're used to Scheme or Lisp. It's just indentation and names.
01:46:59 <wagle> lambdabot fibbed!  zOMGBBQ!!1  etc etc
01:52:05 <amalloy> Sgeo: why don't you just call it <-?
01:54:17 <funfunctor> arkeet: this is what I am basically trying to do https://gist.github.com/victoredwardocallaghan/7066633
01:54:59 <arkeet> funfunctor: you probably need zpoolExec :: ZpoolCMD -> IO String
01:55:15 <arkeet> likewise for zpoolClear
01:55:39 <arkeet> @quote /bin/ls
01:55:39 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
01:56:11 <funfunctor> arkeet: right.. because I basically have the design idea that zpoolExec will be called and the right sub command will be run, its result will use a call back to a parser function and that will return the correctly typed/formatted data..
01:56:17 <wagle> @pl \x -> (head x, len x)
01:56:20 <lambdabot> liftM2 (,) head len
01:56:20 <lambdabot> optimization suspended, use @pl-resume to continue.
01:56:30 <codygman> How do I create an StdStream out of a Handle inside of a do block to use with createProcess?
01:56:35 <funfunctor> arkeet: do you know what I mean?
01:56:40 <arkeet> not really
01:56:45 <wagle>  @pl-resume
01:56:59 <arkeet> wagle: @pl is kind of broken
01:57:18 <codygman> Unsure of how to create StdStream out of handle inside of do block (repost of above, but adding a paste): http://dpaste.com/1423226/
01:57:22 <wagle> yeah, thought i'd not leave it more borken
01:57:26 <funfunctor> arkeet: oh so I mean, each sub command is going to have different output right. So its going to return some data that will need to be parserd.
01:57:51 <ezrios> ooh, I think I get the Writer monad now
01:58:06 <ezrios> I forgot that runWriter was a thing
01:58:30 <funfunctor> so basically zpoolExec -> invokes command -> returns data -> parser function -> return to zpoolExec with typed/parsered data.
02:00:21 <arkeet> and?
02:01:11 <funfunctor> well the idea being that by the time we return to zpoolExec all the IO is completely abstracted away..
02:01:29 <arkeet> your parser function can be pure.
02:01:35 <arkeet> but anything that invokes your command has to be in IO
02:02:06 <funfunctor> hmm, yea I guess that would be right.
02:04:15 <Sgeo> It occurs to me that I can't really name it, it's up to the user of with-monad to name it
02:04:33 <Sgeo> Does that make it not really a function, since I can't define it at the top level?
02:06:05 <Sgeo> Actually... I could, I think. If I make it accept the monad as an argument
02:06:09 <ezrios> if the Writer constructor is not exported by Control.Monad.Writer can I not pattern match against the value "inside" the monad?
02:07:00 <ezrios> I want to pattern match against an empty list inside a Writer
02:10:35 <funfunctor> arkeet: so how to lift a string to IO string?
02:10:43 <arkeet> :t return
02:10:44 <lambdabot> Monad m => a -> m a
02:11:54 <danr> ezrios: maybe you want to use the state monad instead?
02:12:36 <frxx> what do you prefer (flip elem x) or (`elem` x)?
02:12:38 <danr> or this:
02:12:44 <danr> @hoogle listen +mtl
02:12:44 <lambdabot> Control.Monad.Writer.Class listen :: MonadWriter w m => m a -> m (a, w)
02:12:45 <lambdabot> Control.Monad.Writer.Lazy listen :: MonadWriter w m => m a -> m (a, w)
02:12:45 <lambdabot> Control.Monad.Writer.Strict listen :: MonadWriter w m => m a -> m (a, w)
02:12:46 <cbw> Hello, I am having trouble with a Regular Expressions parser I am trying to write. If you compile and run this program it runs forever. I can see where this might be happening but I don't know how to solve it. https://gist.github.com/cameronbwhite/7066806
02:12:54 <ezrios> danr: Well I am trying to recurse through a list and log the manipulations I make at every iteration
02:12:56 <danr> frxx: (`elem` x)
02:13:09 <funfunctor> Ah ofcourse
02:13:14 <danr> ezrios: why do you want to pattern match on if the log is empty?
02:13:30 <ezrios> danr: I am trying to pattern match on the value, not the log
02:14:07 <danr> cbw: parseExpr calls try parseCat which immediately calls parseExpr again
02:14:35 <danr> ezrios: ok, but you argument is not in the writer monad is it? you should be able to pattern match on it as usual
02:14:54 <cbw> danr: Yes, but do I do instead
02:14:55 <ezrios> danr: It is in the writer monad
02:15:25 <funfunctor> thanks for the hand arkeet
02:15:28 <cbw> I am very new to haskell BTW
02:15:52 <funfunctor> I always leave working on haskell before I completely remember things and come back a blank slate each time :/
02:16:03 <danr> cbw: I don't know how your parser  should work, but maybe you want x <- parseOne in parseCat
02:16:35 <danr> ezrios: then I cannot quite imagine what your code looks like. can you post it?
02:16:39 <danr> @where lpaste
02:16:39 <lambdabot> http://lpaste.net/new/haskell
02:17:22 <ezrios> danr: I don't really have code, I am sort of stumbling around in the dark right now
02:17:53 * hackagebot yampa-glut 0.1.1 - Connects Yampa and GLUT  http://hackage.haskell.org/package/yampa-glut-0.1.1 (NikolayOrlyuk)
02:18:27 <danr> cbw: also, you might want to check out the functions many and many1 in parsec
02:18:43 <cbw> danr: You fixed it
02:18:55 <Hermit> ezrios: grab your editor and you may see the light
02:20:18 <ezrios> I think I see what Greenspun was talking about now when he said that he spends more time thinking in Haskell than typing
02:20:19 <ezrios> ;_;
02:20:23 <cbw> danr: Change the first one to ```x <- parseOne``` and the second to ```try parseCat <|> parseOne``` https://gist.github.com/cameronbwhite/7066806
02:20:53 <danr> ezrios: ok. maybe this part of All About Monads could help you: http://www.haskell.org/haskellwiki/All_About_Monads#The_Writer_monad
02:26:51 <ezrios> danr: I don't understand the firewall example
02:27:13 <ezrios> it seems to me that the function produces a Maybe Packet, not a Writer [Entry] (Maybe Packet)
02:27:37 <Rand_McNally> Hi, I need help making a custom concat function
02:28:01 <Rand_McNally> It's for a class exercise and I'm a Haskell noob, so I don't really know what to do
02:28:29 <ezrios> danr: it looks like we have logMsg (..snip..) >> return Nothing
02:28:47 <cbw> [1,2,3] ++ [2,3,4]
02:28:50 <danr> ezrios: yes, so return here is :: Maybe Packet -> Writer [Entry] (Mabye Packet)
02:28:53 <Rand_McNally> I tried using a double list comprehension, but it returns a list of lists, and not the expected concatenated list
02:29:08 <Rand_McNally> Nope, I'm not allowed to do that, I have to define my own concat' function
02:29:17 <cbw> Rand_McNally: Recursion
02:29:23 <danr> Rand_McNally: do you want to define append :: [a] -> [a] -> [a] or concat :: [[a]] -> [a] ?
02:29:32 <Rand_McNally> concat' :: [[a]] -> [a]
02:29:38 <cbw> Rand_McNally: Base case and recursive step
02:29:49 <cbw> Rand_McNally: So you will need two rules.
02:30:26 <Rand_McNally> There's a suggested method, involving something like this: concat' xss = [y | y<-[ys | ys<-xss]]
02:30:26 <cbw> Rand_McNally: I don't want to give you the answer so think on that.
02:30:31 <ezrios> danr: I don't really follow
02:31:06 <ezrios> oooh
02:31:13 <Rand_McNally> I've already solved it by using foldr, but I'm not allowed to do that... ._.
02:31:41 <ezrios> Rand_McNally: If you can solve it using foldr you should be able to solve it using explicit recursion
02:31:44 <danr> Rand_McNally: your list comprehension is almost right (well, and also completely wrong)
02:31:56 <cbw> Rand_McNally: They like to teach you how things are inductivly defined in math so I bet the recursive solution is what they want
02:32:11 <Rand_McNally> I'm sorry if I didn't explain this right, but I'm supposed to solve it by list comprehensions
02:32:24 <cbw> Oh nevermind then
02:32:27 <ezrios> danr: Okay I think I get this example now
02:32:31 <Rand_McNally> I like and love recursion too :3
02:32:32 <danr> ezrios: good
02:32:45 <danr> Rand_McNally: did you see that you can iterate over many lists in a list comprehension?
02:32:56 <ezrios> thanks for the help
02:32:58 <danr> > [ (x,y) | x <- [1..3], y <- "ab" ]
02:32:59 <lambdabot>   [(1,'a'),(1,'b'),(2,'a'),(2,'b'),(3,'a'),(3,'b')]
02:33:10 <cbw> ^ Cross product
02:33:29 <cbw> go team
02:33:46 <Rand_McNally> My attempt at that it's apparently an identity function
02:33:58 <danr> Rand_McNally: play around with that and then revisit your problem
02:34:31 <Rand_McNally> Let's see if I'm able to get something out of this
02:34:52 <Rand_McNally> I've been stuck on this for hours...
02:35:11 <Rand_McNally> Thank you all :)
02:36:07 <cbw> Rand_McNally: Is a programming or Math class?
02:36:29 <Rand_McNally> Programming class, but I'm a Math undergraduate
02:37:35 <Rand_McNally> We're being taught Haskell because it's supposed to be math-like, and I like it, but it's really alien to me
02:38:06 <Rand_McNally> I've been already programming in C for years, and with Haskell it's like I don't know how to program anymore
02:38:15 <frxx> is it even possible to write concat just with list comprehensions?  with foldr it is easy. concat' = foldr (++) []
02:38:21 <frxx> Rand_McNally I know the feeling
02:39:13 <frxx> (Rand_McNally probably doesn't want a solution so just a "yes" will do)
02:39:55 <danr> frxx: yes, you can
02:40:04 <Rand_McNally> :D
02:40:09 <Cale> concat xss = [x | xs <- xss, x <- xs]
02:40:16 <Rand_McNally> My previous concat' is exactly defined like that
02:40:28 <danr> Cale: bah, giving away answers
02:40:30 <Rand_McNally> Ow...
02:40:47 <Cale> Oh, is it a spoiler?
02:40:50 <Rand_McNally> That's quite a spoiler
02:40:51 <Rand_McNally> Yep
02:40:53 <Cale> Sorry, I didn't read the context carefully
02:41:02 <Rand_McNally> Anyway, thank you
02:41:08 <Rand_McNally> I need this for Monday
02:41:43 <cbw> How would to implement RegEx *
02:42:17 <cbw> a* = ["", "a"]
02:42:29 <cbw> a* = ["", "a", "aa", "aaa", ...]
02:42:33 <Rand_McNally> Why I am allowed to "throw away" that extra xs?
02:42:48 <Cale> > iterate ('a':) []
02:42:49 <lambdabot>   ["","a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa"...
02:43:01 <Cale> Rand_McNally: Throw away?
02:43:17 <Cale> Rand_McNally: you're using it in the very next bit!
02:43:36 <Cale> xs is selected from xss in all possible ways, and then x is selected from xs in all possible ways
02:43:40 <Rand_McNally> I played with some similar comprehensions...
02:44:11 <Rand_McNally> And apparently Haskell didn't allow me to "make up" variables in the comprehension part
02:44:28 <Cale> > inits (repeat 'a')
02:44:29 <lambdabot>   ["","a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa"...
02:44:49 <Rand_McNally> Oh, nevermind, I get it now
02:45:07 <Cale> Rand_McNally: The variables you "make up" are on the left of each <-
02:45:23 <Rand_McNally> Yeah, it's like defining sets
02:45:42 <ion> FWIW, iterate ('a':) [] can employ more sharing.
02:45:55 <Cale> Indeed
02:45:56 <Rand_McNally> But Haskell is a computer language, so you need to define xs<-xss first...
02:46:11 <Cale> Rand_McNally: The list comprehension syntax can be defined in terms of concatMap
02:46:41 <cbw> you need to get the first n elements
02:46:49 <danr> Rand_McNally: xss is the argument of the function
02:46:56 <danr> it's free in that list comprehension
02:47:04 <Cale> http://www.haskell.org/onlinereport/exps.html#list-comprehensions -- look in the box
02:47:15 <Rand_McNally> But xs isn't, so it needs to be defined before you use x<-xs...
02:47:15 <Cale> (the one headed "Translation:")
02:47:30 <cbw> take 3 $ iterate  ('a':) []
02:47:38 <cbw> > take 10 $ iterate  ('a':) []
02:47:39 <lambdabot>   ["","a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa"]
02:47:40 <Rand_McNally> My previous attempt was x<-xs, xs<-xss
02:47:47 <Cale> right
02:47:48 <Rand_McNally> Haha...
02:47:51 <Cale> The order matters
02:48:02 <Rand_McNally> I got it =)
02:48:06 <Cale> Even if you don't need reference to the earlier bound things
02:48:16 <Rand_McNally> Thank you all
02:48:19 <Cale> It can affect the order in which the resulting list is produced
02:48:30 <Cale> > [(x,y) | x <- [1,2,3], y <- [4,5,6]]
02:48:32 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
02:48:39 <Cale> > [(x,y) | y <- [4,5,6], x <- [1,2,3]]
02:48:40 <lambdabot>   [(1,4),(2,4),(3,4),(1,5),(2,5),(3,5),(1,6),(2,6),(3,6)]
02:49:04 <Rand_McNally> ._.
02:49:06 <ion> rand_mcnally: Since you’re familiar with C, there’s an analogy to nested for loops in the same order as the <-s.
02:49:11 * Rand_McNally is left speechless
02:49:43 <Rand_McNally> I miss my old for loops
02:49:58 <Cale> Well, lists are the same thing as loops if you think about it the right way
02:50:08 <codygman> My program is failing to pattern match and I'm not sure why: http://dpaste.com/1423266/
02:50:24 <Rand_McNally> Thanks a lot, really
02:50:28 <mauke> > do { x <- [1,2,3]; y <- [4,5,6]; return (x,y) }
02:50:29 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
02:50:31 <ion> for (int y = 4; y <= 6; ++y) for (int x = 1; x <= 3; ++x) emit_pair(x,y);  (but without IO effects, this is just an analogy)
02:50:33 <alllex229> hello
02:50:38 <Cale> Just as a loop either doesn't run at all (because its condition isn't met), or it consists of one iteration followed by another loop, a list is either empty, or consists of a single element followed by another list.
02:51:06 <Cale> Loops can be infinite, and in Haskell, so can lists.
02:51:14 <Cale> > [1..]
02:51:15 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
02:51:41 <mauke> codygman: what?
02:51:58 <Rand_McNally> Won't that crash ghci?
02:52:02 <Cale> nope!
02:52:27 <Cale> It'll just go on forever printing numbers until you Ctrl-C to get it to stop.
02:52:35 <cbw> Lazyness
02:52:36 <ion> rand_mcnally: Will for (int i = 1; ; ++i) { printf ("%d\n", i); } crash something?
02:52:49 <mauke> Cale: it will run out of memory eventually
02:53:05 <Rand_McNally> It'll surely hang my terminal
02:53:06 <Cale> Well, sure, but only because integers are eventually very large.
02:53:17 <Cale> It *shouldn't* hang your terminal.
02:53:26 <Cale> If it does, you have a bad terminal.
02:53:31 <mauke> when in doubt, ctrl-z, kill %1
02:53:38 <Rand_McNally> Haha
02:53:55 <Cale> Only one element of the list need be in memory at a time
02:53:59 <Cale> as it's printed
02:54:13 <Cale> and after that, it becomes garbage (maybe not in ghci, because of 'it')
02:54:19 <ion> when in doubt, alt-sysrq-o
02:54:47 <danr> when in doubt, juggle?
02:54:51 <Rand_McNally> So... like index sets, then
02:55:29 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
02:55:31 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
02:55:38 <Cale> There's the infinite list of prime numbers
02:56:01 <Cale> This isn't a particularly fast implementation, but it's short, and I rather like the mutual recursion.
02:56:26 <alllex229> yeah and the fact you can use infinite lists in every function
02:56:42 <Cale> (also, there are much slower versions you could write -- this one does have the nice property that it only does trial division against primes :)
02:57:16 <frxx> @src iterate
02:57:16 <lambdabot> iterate f x =  x : iterate f (f x)
02:57:19 <Rand_McNally> I'm still trying to understand what it does
02:57:42 <Cale> In English, that says, the list of primes starts with 2, and then is followed by the elements of [3,5..] for which isPrime n gives True
02:57:47 <Cale> > [3,5..]
02:57:48 <lambdabot>   [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,...
02:57:55 <Rand_McNally> That's a filter, I know about those
02:57:57 <Cale> (that's just the odd numbers larger than 3)
02:58:07 <Rand_McNally> But I don't understand isPrime
02:58:26 <Cale> and then isPrime n checks to see that for all primes p in a given list, whether n divided by p gives a nonzero result
02:58:29 <mauke> :t all
02:58:31 <lambdabot> (a -> Bool) -> [a] -> Bool
02:58:57 <alllex229> all is in prelude?
02:59:02 <Cale> and the list it uses is a prefix of the list of primes p where every element in that prefix satisfies p*p <= n
02:59:19 <Rand_McNally> Infixed mod...
02:59:32 <Cale> Since we know that if a number n is composite, there must be some prime p less than or equal to its square root which divides it
03:00:01 <codygman> mauke: Exception: user error (Pattern match failure in do expression at /home/cody/programming/haskell/videostills/ffmpeg.hs:13:3-45)
03:00:51 <Rand_McNally> Hmm...
03:01:03 <Rand_McNally> :t takeWhile
03:01:04 <lambdabot> (a -> Bool) -> [a] -> [a]
03:01:40 <Rand_McNally> > takeWhile (\p -> p*p <= n) [3..]
03:01:41 <lambdabot>   [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,...
03:01:43 <Cale> > takeWhile isUpper "HEREaresomeLetters"
03:01:44 <lambdabot>   "HERE"
03:01:58 <mauke> > 0 < n
03:01:59 <lambdabot>   True
03:02:00 <Rand_McNally> ?
03:02:02 <mauke> pfft
03:02:08 <Cale> > takeWhile isAlpha "hello328abcd"
03:02:10 <lambdabot>   "hello"
03:02:30 <Rand_McNally> takeWhile stops at the first False it finds
03:02:34 <Rand_McNally> Right?
03:02:51 <mcstar> depends on what you mean by stop
03:03:05 <Lethalman> Rand_McNally, yes
03:03:07 <ion> > 0 > n
03:03:08 <lambdabot>   False
03:03:11 <Cale> Rand_McNally: Lambdabot has one-letter things in scope which are "Expr" values, and the comparison operations are implemented in a silly way for those.
03:03:20 <mauke> codygman: makes sense to me. what's your question?
03:03:34 <Cale> Rand_McNally: The n in your code wasn't really meant to be in scope, but happened to be in lambdabot
03:03:48 <Cale> > let n = 5 in takeWhile (\p -> p*p <= n) [3..]
03:03:49 <lambdabot>   []
03:03:57 <Cale> > let n = 50 in takeWhile (\p -> p*p <= n) [3..]
03:03:58 <lambdabot>   [3,4,5,6,7]
03:04:21 <Rand_McNally> takeWhile (\c -> c <= 'p') ['a'...]
03:04:24 <Rand_McNally> > takeWhile (\c -> c <= 'p') ['a'...]
03:04:25 <lambdabot>   A section must be enclosed in parentheses thus: ('a' ...)Not in scope: `......
03:04:27 <Cale> So, when n is 50, we'll only need the primes 2, 3, 5, and 7
03:04:42 <frx> Rand_McNally .. instead of ...
03:04:46 <Rand_McNally> > takeWhile (\c -> c <= 'p') ['a'..]
03:04:47 <lambdabot>   "abcdefghijklmnop"
03:04:51 <ion> (and 11)
03:04:58 <Cale> and that's all that will be tested when trying to decide if 50 is prime (of course, 2 will be checked and the test will be over)
03:05:03 <Lethalman> > takeWhile (<= 'p') ['a'..]
03:05:04 <lambdabot>   "abcdefghijklmnop"
03:06:14 <Rand_McNally> So the \var makes a dummy variable used to define explicit conditions
03:06:27 <Rand_McNally> That's quite clever ._.
03:06:32 <Cale> Rand_McNally: So the computation of primes and isPrime support each other, and because primes is a constant which remains in scope the whole time, as primes get computed, they don't get thrown away, and instead they're used to compute future primes
03:06:36 <ion> “\foo -> bar” is a function with parameters “foo” and body “bar”./
03:06:39 <mauke> Rand_McNally: \x -> y is the syntax to define a function
03:06:50 <Cale> > (\x -> x*x) 5
03:06:51 <lambdabot>   25
03:06:59 <Cale> > map (\x -> x*x) [1..10]
03:07:00 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
03:07:23 <Rand_McNally> Wow
03:07:27 <cbw> How would you * over a union?
03:07:48 <Rand_McNally> One more question, this one about QuickCheck...
03:07:49 <Cale> cbw: Not sure what you mean, but if you mean a list, perhaps you're looking for product
03:07:54 <Cale> > product [1..10]
03:07:55 <lambdabot>   3628800
03:08:29 <Cale> cbw: Oh, or do you mean form all words on a particular alphabet?
03:08:42 <cbw> (a+b)*
03:08:52 <cbw> regular expressions still
03:08:54 <Rand_McNally> > :t quickCheck
03:08:55 <lambdabot>   <hint>:1:1: parse error on input `:'
03:09:02 <Rand_McNally> :t quickCheck
03:09:03 <lambdabot> Testable prop => prop -> IO ()
03:09:20 <Cale> > let wordsOn xs = [] : [x:ys | x <- xs, ys <- wordsOn xs] in wordsOn "01"
03:09:21 <lambdabot>   ["","0","00","000","0000","00000","000000","0000000","00000000","000000000"...
03:09:34 <Cale> > let wordsOn xs = [] : [x:ys | ys <- wordsOn xs, x <- xs] in wordsOn "01"
03:09:35 <lambdabot>   ["","0","1","00","10","01","11","000","100","010","110","001","101","011","...
03:09:40 <Cale> ^^ the order matters!
03:10:07 <mauke> (a+b)*** is fun
03:10:12 <codygman> mauke: My questions is why is it happening? How can I fix it?
03:10:31 <Cale> cbw: Is that what you're looking for?
03:10:34 <Rand_McNally> > let p_ordered xs = and [ x<=y | (x,y) <- zip xs (tail xs)]; quickCheck p_ordered
03:10:35 <lambdabot>   <hint>:1:81:
03:10:35 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
03:10:35 <Cale> > let wordsOn xs = [] : [x:ys | ys <- wordsOn xs, x <- xs] in wordsOn "ab"
03:10:36 <lambdabot>   ["","a","b","aa","ba","ab","bb","aaa","baa","aba","bba","aab","bab","abb","...
03:10:48 <Rand_McNally> > let p_ordered xs = and [ x<=y | (x,y) <- zip xs (tail xs)] in quickCheck p_ordered
03:10:50 <lambdabot>   <IO ()>
03:10:56 <mauke> codygman: do you know any haskell?
03:11:18 <Cale> @check let p_ordered xs = and [ x<=y | (x,y) <- zip xs (tail xs)] in p_ordered
03:11:24 <lambdabot>   +++ OK, passed 100 tests.
03:11:40 <Rand_McNally> It works here, but it doesn't on a script
03:11:46 <Cale> Rand_McNally: Because quickCheck gives an IO action, lambdabot won't run it, but we have a special command for it.
03:11:49 <codygman> mauke: I would like to think so, I've spent a couple weeks reading through Real World Haskell and Learn you a haskell (reverse that order).
03:12:03 <mauke> codygman: do you know what patterns are?
03:12:08 <Cale> Rand_McNally: What do you mean by "a script"?
03:12:44 <Cale> Rand_McNally: If you put a bunch of applications of quickCheck into the main action of your program, they'll get run in a compiled program.
03:12:47 <codygman> mauke: Yes, but I don't know how to find out... wait... checking to see what type that returns
03:12:49 <cbw> > let wordsOn xs = take 5 $ [] : [x:ys | ys <- wordsOn xs, x <- xs] in wordsOn ["a", "b"]
03:12:51 <lambdabot>   [[],["a"],["b"],["a","a"],["b","a"]]
03:12:52 <Rand_McNally> A .hs file meant to be interpreted/compiled instead of just loading its definitions
03:13:04 <cbw> > let wordsOn xs = take 5 $ [] : [x:ys | ys <- wordsOn xs, x <- xs] in wordsOn ["a", "b"]
03:13:05 <lambdabot>   [[],["a"],["b"],["a","a"],["b","a"]]
03:13:14 <Cale> Rand_McNally: e.g. main = do quickCheck propFoo; quickCheck propBar; quickCheck propQuux
03:13:17 <Rand_McNally> My property works in ghci, but it doesn't in my aux.hs
03:13:35 <Cale> Rand_McNally: What error do you get?
03:13:41 <cbw> yeah that works
03:13:45 <mauke> codygman: "ffmpeg -i - -r 3 -f image2 DSCF2022.AVI-%03d.jpg" is nonsense, btw. you don't have a program called "ffmpeg -i - -r 3 -f image2 DSCF2022.AVI-%03d.jpg" anywhere in your path
03:14:09 <cbw> wait I need to concat each sublist together
03:14:28 <Cale> cbw: then use characters in place of strings
03:14:28 <cbw> s/:/++/g
03:14:31 <Rand_McNally> Ambiguous type variable `a0' in the constraints:
03:14:31 <Rand_McNally>       (Ord a0) arising from a use of `p1_ordena' at Rel2aux.hs:32:14-22
03:14:31 <Rand_McNally>       (Show a0) arising from a use of `quickCheck' at Rel2aux.hs:32:3-12
03:14:31 <Rand_McNally>       (Arbitrary a0)
03:14:31 <Rand_McNally>         arising from a use of `quickCheck' at Rel2aux.hs:32:3-12
03:14:42 <cbw> > let wordsOn xs = take 5 $ [] : [x++ys | ys <- wordsOn xs, x <- xs] in wordsOn ["a", "b"]
03:14:43 <lambdabot>   ["","a","b","aa","ba"]
03:15:04 <Cale> Rand_McNally: Ah, your property is working because ghci defaults types more aggressively.
03:15:04 <Rand_McNally> p1_ordena it's the former property
03:15:14 <Cale> Rand_McNally: If you give your property a type signature, it will probably work.
03:15:28 <Rand_McNally> Which type signature should I use?
03:15:30 <codygman> mauke: So it does use the list for arguments then... alright
03:15:51 <cbw> Rand_McNally: Type it into the terminal and ask it
03:15:51 <Cale> p_ordered :: [Integer] -> Bool
03:15:58 <Cale> perhaps something like that?
03:16:16 <mauke> http://hackage.haskell.org/package/process-1.1.0.2/docs/System-Process.html#v:proc
03:16:25 <Cale> @check let p_ordered xs = and [ x<=y | (x,y) <- zip (xs :: Integer) (tail xs)] in p_ordered
03:16:27 <lambdabot>   Couldn't match expected type `[a0]'
03:16:27 <lambdabot>              with actual type `GHC.Inte...
03:16:33 <Cale> @check let p_ordered xs = and [ x<=y | (x,y) <- zip (xs :: [Integer]) (tail xs)] in p_ordered
03:16:36 <lambdabot>   *** Failed! Falsifiable (after 3 tests and 3 shrinks):
03:16:36 <lambdabot>  [0,-1]
03:16:58 <Cale> GHCi would probably have defaulted the unknown type of the elements of the list to ()
03:17:04 <Cale> which would make the test succeed
03:17:11 <Cale> because () only has one defined value
03:17:32 <Cale> (and so all your comparisons would succeed)
03:17:37 <Cale> It's better to specify the types somehow
03:17:38 <codygman> Thanks mauke
03:17:57 <Rand_McNally> Well... it's not my property
03:18:18 <Rand_McNally> It's a property I'm supposed to check, and it's supposed to be OK
03:18:55 <Cale> The problem is that the type is unspecified
03:19:02 <Cale> and it can't be inferred properly
03:19:07 <Rand_McNally> I was thinking Ord, but...
03:19:11 <Cale> (because it's ambiguous)
03:19:35 <Cale> If you pick a concrete type like Integer, then quickCheck will know which type of values to generate
03:20:05 <Cale> (by which I mean, your property will likely have a type like [Integer] -> Bool)
03:20:26 <Cale> You could specify the type when passing the prop to quickCheck:
03:20:43 <Cale> quickCheck (prop_ordered :: [Integer] -> Bool)
03:21:05 <Rand_McNally> I don't even know if I am supposed to know how to specify property types
03:21:44 <Cale> Well, it's not likely to work without an additional type signature somewhere
03:22:22 <Cale> You could turn on extended default rules, but those actually do something you don't want
03:22:53 <Cale> ghci is misleadingly accepting, it aggressively defaults the type of the elements of the lists to () in order to try to get things to work
03:23:08 <Cale> but that makes the property succeed, where with almost any other type it would fail
03:23:09 <mcstar> whats are 'shrinks' that quickcheck mentions above?
03:23:21 <mcstar> -s
03:23:39 <Rand_McNally> It... it should work
03:23:40 <Cale> mcstar: Once it finds a counterexample, it does a bunch of ad-hoc type-specific things to try to make a simpler counterexample
03:23:41 <Rand_McNally> I mean
03:23:48 <Rand_McNally> I have a function to order lists
03:24:19 <Cale> Rand_McNally: The property you wrote just says that an arbitrary list will already be in order.
03:24:26 <Cale> (you didn't use sort or anything)
03:24:46 <Rand_McNally> I know, I'm trying to "copy" the functions from my file
03:25:31 <Cale> Perhaps put your file on lpaste.net and I could give suggestions for how to clear up the ambiguous type
03:26:16 <Rand_McNally> http://lpaste.net/7200869201274208256
03:26:24 <Cale> mcstar: The Arbitrary typeclass has a method shrink which specifies how to do that, by producing a list of what ought to be somehow simpler things from a given input.
03:26:34 <Cale> > shrink [1,2,3,4,5]
03:26:35 <lambdabot>   [[],[3,4,5],[1,2,5],[2,3,4,5],[1,3,4,5],[1,2,4,5],[1,2,3,5],[1,2,3,4],[0,2,...
03:26:47 <Cale> > shrink [1,2,3]
03:26:49 <lambdabot>   [[],[2,3],[1,3],[1,2],[0,2,3],[1,0,3],[1,1,3],[1,2,0],[1,2,2]]
03:26:53 <mauke> > shrink "hello"
03:26:54 <lambdabot>   ["","llo","heo","ello","hllo","helo","helo","hell","aello","bello","cello",...
03:27:02 <mcstar> i just wanted to do that ^
03:27:27 <mauke> > shrink (words "up the hill")
03:27:28 <lambdabot>   [[],["the","hill"],["up","hill"],["up","the"],["","the","hill"],["p","the",...
03:27:35 <frx> @src shrink
03:27:35 <lambdabot> Source not found. The more you drive -- the dumber you get.
03:27:47 <Cale> Rand_McNally: add the type signature  p1_ordena :: [Integer] -> Bool
03:27:47 <Rand_McNally> > shrink (words "I like cake")
03:27:49 <lambdabot>   [[],["like","cake"],["I","cake"],["I","like"],["","like","cake"],["a","like...
03:27:51 <mcstar> > shrink [True, False]
03:27:52 * mauke rolls eyes at frx 
03:27:52 <lambdabot>   [[],[False],[True],[False,False]]
03:27:58 <frx> ^_^
03:28:11 <mauke> > shrink cake
03:28:12 <lambdabot>   Not in scope: `cake'
03:28:12 <lambdabot>  Perhaps you meant one of these:
03:28:12 <lambdabot>    `take' (imported f...
03:28:16 <Cale> Rand_McNally: and  p1_inserta :: Integer -> [Integer] -> Bool
03:28:17 <mauke> !
03:28:23 <mauke> what happened to cake?
03:28:24 <Cale> or maybe in that case Property
03:28:32 <Cale> :t (==>)
03:28:32 <lambdabot> Testable prop => Bool -> prop -> Property
03:28:35 <Cale> right
03:28:44 <Cale> Rand_McNally: p1_inserta :: Integer -> [Integer] -> Property
03:28:48 * mcstar thinks it was lie in the first place
03:29:18 <Rand_McNally> It works now ^^
03:29:21 <Cale> mauke: It went away when I handed lambdabot off to elliott
03:29:29 * mauke cries a last TOOTOOT, ASCIICAT
03:30:03 <Rand_McNally> > shrink "embiggen"
03:30:04 <lambdabot>   ["","ggen","embi","biggen","emggen","embien","embigg","mbiggen","ebiggen","...
03:30:32 <Cale> It's pretty clever about the order of the shrinks that it tries
03:31:10 <Rand_McNally> I think I got what shrink does
03:31:26 <Cale> Once it finds one shrink that the property still fails for, it shrinks that too, until it can't shrink anymore (or there might be some limit on how much it tries to shrink, but generally this converges rapidly)
03:31:46 <mauke> > sort (shrink "abc")
03:31:48 <lambdabot>   ["","aac","ab","aba","abb","ac","bc"]
03:32:07 <Rand_McNally> Great
03:32:29 <mauke> > iterate (maximum . shrink) "embiggen"
03:32:30 <lambdabot>   ["embiggen","mbiggen","miggen","miggn","min","mn","n","c","b","a","","*Exce...
03:32:40 <Rand_McNally> Now I have a working (at least!) module, and a working script for testing my module
03:32:47 <Rand_McNally> "*Excellent"?
03:32:50 <mauke> > shrink ""
03:32:51 <lambdabot>   []
03:32:59 <Cale> > maximum []
03:33:00 <lambdabot>   *Exception: Prelude.maximum: empty list
03:33:03 <simukis_> *Exception.
03:33:09 <mauke> > fix error
03:33:11 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
03:33:59 <cbw> YEAH!! My Regular Expressions program works!!!!! https://github.com/cameronbwhite/HsSymMath/blob/master/RegularExpressions.hs
03:34:19 <SLDR> cbw: Congrats!
03:35:26 <Cale> > iterate (maximum . filter (not . null) . shrink) "embiggen"
03:35:27 <lambdabot>   ["embiggen","mbiggen","miggen","miggn","min","mn","n","c","b","a","*Excepti...
03:35:50 <Cale> er
03:35:52 <mcstar> are you tim sheard also?
03:35:54 <Cale> duh
03:36:08 <alexander__b> if I have foo=(1, 2) and bar=3, how do I make (1,2,3)?
03:36:17 <Cale> yeah, that's not going to work :)
03:36:25 <Rand_McNally> I don't even know why
03:36:47 <Cale> alexander__b: case foo of (x,y) -> (x,y,bar)
03:37:01 <mcstar> > make3tuplefromone2tupleandavalue (a,b) c = (a,b,c) in make3tuplefromone2tupleandavalue (1,2) 3
03:37:02 <lambdabot>   <hint>:1:42: parse error on input `='
03:37:02 <cbw> mcstar: No that is my professor. He wrote program that does this but he did not show the whole thing. So I took what he showed use and recreated it
03:37:04 <shelf> since (>>) gets inlined by the compiler, is it fair for me to call it 'sugar'?
03:37:10 <SLDR> alexander__b: \(a,b) c -> (a,b,c)
03:37:10 <mcstar> > let make3tuplefromone2tupleandavalue (a,b) c = (a,b,c) in make3tuplefromone2tupleandavalue (1,2) 3
03:37:11 <lambdabot>   (1,2,3)
03:37:19 <mauke> shelf: no
03:37:30 <Cale> shelf: (>>) is defined separately for each monad
03:37:44 <Cale> shelf: and might not always get inlined (though typically it will)
03:37:46 <shelf> really now! i thought i saw something in GHC.Base
03:38:02 * hackagebot buildwrapper 0.7.6 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.7.6 (JeanPhilippeMoresmau)
03:38:04 * hackagebot scion-browser 0.2.19 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.2.19 (JeanPhilippeMoresmau)
03:38:14 <alexander__b> SLDR: nice. thanks!
03:38:26 <shelf> ah that's opt-in
03:38:28 <SLDR> alexander__b: Cheers.
03:38:33 <Cale> It's technically a method of the Monad class, though it would be a crime to define x >> y in a way which was semantically inequivalent to x >>= const y
03:38:46 * mcstar thinks his solution is equally elegant
03:39:16 <shelf> i was a little addled by {-# INLINE (>>) #-} in GHC.Base
03:39:50 <Cale> shelf: Lots of stuff gets inlined. Small functions will be inlined automatically even without an annotation like that.
03:40:10 <skypers> hey
03:40:17 <SLDR> Hm. If a function fails when given the return of another function but not when I hardcode in the same data, what's wrong?
03:40:24 <Rand_McNally> Well, it works :)
03:40:34 <Rand_McNally> Thank you, Cale, you helped me a lot
03:40:35 <skypers> is hsc2hs a tool we have to explicitely call? or is it part of the compiling process of ghc?
03:40:38 <mcstar> the 'data' is not the same?
03:40:40 <Cale> SLDR: Perhaps the types are being inferred differently?
03:41:13 <Rand_McNally> g2g now, I have some Discrete Math exercises left to do
03:41:19 <Cale> Rand_McNally: See you around!
03:41:20 <Rand_McNally> Thanks ^^
03:42:04 <SLDR> I doubt it. It gives no errors at compile time. Inference may be to blame, though.
03:42:55 <cbw> Time to take a break from regular expression and to start a Logic parser
03:42:56 <Cale> SLDR: Generally, function applications are referentially transparent, and the only way for this kind of thing to happen is for the data to be different or the function to be different (even if not textually, type inference and typeclasses can mean that if types get inferred and defaulted differently, then different values result)
03:43:07 <SLDR> I'm certain the data itself is identical, though.
03:43:11 <pyr> hi
03:43:16 <Cale> hello!
03:43:19 <shelf> you say it would be a 'crime' to define (>>) differently to its inlined version - but wouldn't it break stuff outright to do so, if it gets unpredictably inlined?
03:43:23 <mcstar> SLDR: then, time to paste?
03:43:50 <Cale> shelf: You're confusing inlining with definitions?
03:43:54 <shelf> perhaps
03:43:56 <pyr> I have data type, which designates actions and which can be any type of action
03:43:57 <shelf> i'll hit the books
03:44:01 <Cale> shelf: There's a *default* definition of (>>) in the Monad class
03:44:15 <pyr> I'm handling them with a  pattern matching recursive function
03:44:20 <Cale> shelf: If you write an instance of Monad without explicitly defining (>>) (as is common), that's the one you'll get
03:44:44 <Cale> However, sometimes you'd like to be able to provide a more efficient version of (>>) which nonetheless does the same thing
03:44:47 <pyr> for easier reading I'd like to be able to say:
03:44:57 <shelf> and the two never shall meet
03:44:57 <Cale> and for that reason, it lets you write your own (>>)
03:44:59 <shelf> i getcha~
03:45:14 <SLDR> Cale: I see what you're saying, but I don't see how it could happen in this situation. There shouldn't even be any inference occuring since the types are explicitly defined.
03:45:16 <Cale> None of this has anything to do with whether that definition gets inlined into code which uses (>>) or not.
03:45:24 <SLDR> mcstar: One moment
03:45:43 <shelf> yeah, i had some erroneous idea about inlining
03:45:46 <Cale> SLDR: Well, it's just a guess. It's really hard for me to tell without being able to see your code
03:46:07 <mcstar> Cale: but thats the challenge!
03:46:24 <shelf> was thinking more like macro expansion / desugaring. but i understand now! thanks Cale
03:46:36 <SLDR> Cale: I'm aware. Fixing a code paste now.
03:46:49 <lpaste> SLDR pasted “lab4” at http://lpaste.net/94525
03:47:47 <SLDR> Alright, so the code isn't pretty (and I'm not using Haste by choice), but there it is.
03:47:57 <mauke> missed opportunity to use 'case' :-/
03:48:26 <mcstar> i hope the problem is with the pure function part
03:48:57 <Cale> SLDR: Yeah, as a policy, never write  "... == Nothing"
03:49:03 <Cale> or "... == []"
03:49:46 <mcstar> as far as correctness goes, it shouldnt matter
03:49:56 <SLDR> mcstar: Sadly, I doubt that it is. Line 31 is causing the issues. It won't work when given "pts", but if I hardcode in the result from the points function, it runs.
03:50:04 <Cale> There are isNothing and null for testing those conditions without the Eq instance requirement, but more importantly than that, it's usually an indication that you should be using pattern matching
03:50:16 <SLDR> Cale: Noted. Fixing.
03:50:19 <mauke> "won't work" is not a problem description
03:50:56 <merijn> mauke: Technically, it is. Just not one that motivates people to help you :p
03:51:01 <Cale> case readExpr exp' of Nothing -> render canvas $ text (0,300) "Invalid"; Just expr -> let ...
03:51:12 <mauke> merijn: I don't see how it is
03:51:18 <SLDR> mauke: Specifically: produces no result as far as I can tell. It either crashes or does something it shouldn't.
03:51:34 <mcstar> mauke: he is/was about to detail the problem
03:51:34 <mauke> >implying crashing is something it should do
03:52:05 <Cale> heh
03:52:15 <Cale> Okay, so I can't even attempt to run this
03:52:19 <Cale> What's Expr?
03:52:26 <mcstar> yeah, my question too
03:53:04 <mcstar> something related to Haste, cause you can call eval on it
03:53:27 <SLDR> It's another module that sits behind everything and parses expressions. I'm certain it is working as intended, however. And no, it's not Haste.
03:53:57 <mcstar> oh, silly me, 'hiding'
03:54:14 <SLDR> This code is supposed to retrieve an expression from a text input box on a website, parse it as an expression, evaluate the expression, and then plot the resultant graph in a <canvas>
03:54:24 <mcstar> yeah, i figured so
03:54:57 <SLDR> I've gotten as far as it evaluating expressions, but I cannot get them to plot (unless I hardcode in the data, as mentioned)
03:55:05 <Cale> Oh, this code runs in a web browser?
03:55:25 <danilo2> Cale: Hi! Could I have one question tou you, according to our yesterdays talk? You've shown me, that we can use RankNTypes to mae my code work. I want to ask you if is it possible to replace "X (a -> a -> (a,a))" in the function signature by class constrain " F_method1 m (a -> a -> (a,a))" somehow? code : http://lpaste.net/94526 lines: 22-23
03:55:44 <SLDR> Cale: Not exactly. The Haste compiler takes Haskell code and makes JS code, which then runs in a browser. Apparently my course-lead thought that would be a good exercise...
03:55:46 <mcstar> SLDR: so, you explicitely give `points` a `Var`, and still does not work? what should Var evaluate to?
03:56:14 <Cale> SLDR: Well, of course.
03:56:34 <SLDR> mcstar: Var is the variable, meaning it evaluates the function f(x) = x. It should just give a line, but it does bugger all.
03:56:37 <Cale> SLDR: (I'm not asking whether browsers have suddenly got native Haskell support! :)
03:56:51 <SLDR> Cale: Although that would be pretty cool...
03:57:11 <Cale> SLDR: Javascript is the new assembly
03:57:47 <mcstar> SLDR: 'evaluates to' you wanted to say right?
03:58:13 <SLDR> mcstar: Yes, sorry about that.
03:58:52 <mcstar> ok, so just to be clear, the pasted to is which does not work, but when you supply points explicitely, it does display the line
03:58:55 <mcstar> ?
03:59:01 <mcstar> to->code
03:59:47 <mcstar> SLDR: ^
03:59:59 <Cale> danilo2: I won't say it's impossible, but I couldn't see an easy way to express that when I tried yesterday
04:00:12 <Cale> danilo2: So I just ended up giving the one thing which I did find that worked.
04:00:13 <SLDR> mcstar: Precisely. If I replace "render canvas $ stroke $ path pts" with "render canvas $ stroke $ path [The longest list ever], it runs.
04:01:14 <SLDR> mcstar: Even though the list itself is the copy-pasted result from running points with the exact same inputs.
04:01:48 * Cale begins to suspect the Haste compiler.
04:02:04 <danilo2> Cale: I was trying to do it, but also without success :) By the way - do you tink that exitential datatypes or anything connected to "existential" could help me with my (yesterdays) problem? Maybe this is a "blind shot", but I feel, that maybe I would be able to tell the compiler not to infer type of f as "forall a.", but it could be infered "there exist such a., that .. ?
04:02:24 <mcstar> the nested if/then/else and lets look a bit unusual, but seems to be correct
04:02:31 <SLDR> Cale: I wouldn't be surprised, to be honest... I'm going to try and fix the errors lpaste and you guys pointed out and see if it runs, then.
04:02:46 <Cale> danilo2: The compiler won't infer existentials for you either, and you'll have to construct explicit datatypes for each one you want.
04:03:07 <SLDR> mcstar: My syntax isn't pretty, I know. Still getting used to this language. It's being replaced with a case statement
04:03:23 <Cale> case expression* :)
04:03:50 <danilo2> Cale: Ok, and do you think, using GHC API could bring a solution to it?
04:03:52 <Cale> (that's being super-picky about terminology)
04:04:13 <Cale> danilo2: Well, I have a very hazy idea of what you're trying to do
04:04:22 <SLDR> Cale: Proper use of language never was my strong suit ;)
04:05:20 <danilo2> Cale: The idea is very simple - I want to mimic in Haskell "classes with methods". So you can translate to haskell a function like (using pythonic pseudocode) "def f(x): x.test()"
04:05:47 <mcstar> SLDR: could you just first write `render....` after the do in the lambda? and inline pts
04:06:55 <Cale> danilo2: Well, if the source language is statically typed, I would *probably* choose a representation which allowed me to record those methods as fields of a record type.
04:07:21 <Kaidelong> so a lens is a function in the form (Functor f) => (a -> f b) -> (c -> f d)
04:07:23 <SLDR> mcstar: Testing...
04:07:30 <mcstar> SLDR: just a note, _ can stand for (_,_) too
04:07:38 <Kaidelong> and this allows both getting and setting?
04:07:58 <Cale> Kaidelong: that's right
04:08:16 <mcstar> also, i dont see the point in Just something <- getCanvas... or the alike
04:08:18 <Cale> Kaidelong: It might be helpful to specialise to (a -> f a) -> (b -> f b) at first
04:08:48 <danilo2> Cale: yes it is. The representation, you;ve talked aboutyesterday is ok. The problem apperas if I want to use type inferencer and user defines function like this "def f(x): x.test()" - then "x" could be of any type, which "has method test" - and here we are facing the RankNTypes problem
04:09:06 <Cale> Kaidelong: when f is the identity functor, this (roughly) becomes (a -> a) -> (b -> b), which looks like a function for modifying a field of type a in a structure of type b.
04:09:07 <mcstar> arent you supposed to provide handling for the alternate case of Nothing?
04:09:11 <lpaste> SLDR revised “lab4”: “No title” at http://lpaste.net/94525
04:09:15 <Cale> Kaidelong: Applying that to a constant function gets you a setter.
04:09:43 <danilo2> Cale: Cannot we ask GHC t type a function when it is used? This could fix this problem
04:10:18 <Cale> Kaidelong: When f is the constant functor at type a, then this specialises to (a -> a) -> (b -> a), which can then be applied to the identity function to get a function (b -> a) for extracting the field of type a from the structure of type b
04:10:46 <SLDR> mcstar: Under the circumstances (as in, the framework given by the assignment), the "Just canvas <- get..." can't fail. I probably should have something to handle a fail, but alas.
04:10:47 <Cale> danilo2: no, functions need to have specific single types
04:11:10 <mcstar> SLDR: ok, so the new paste still fails?
04:11:16 <alexander__b> followup from before: if I have foo=Just (1, 2) and bar=3, how do I make just (1,2,3)?
04:11:23 <alexander__b> s/just/Just
04:11:26 <Cale> danilo2: But since you're compiling this language, you can mangle the names anyway?
04:11:32 <SLDR> mcstar: It does. Removing the second do to see if that helps.
04:11:41 <mcstar> alexander__b: pls, read up on pattern matching in one of the popular books
04:11:50 <mcstar> SLDR: shouldnt...
04:11:50 <quchen> Also fmap.
04:12:09 <Cale> or, I don't even really know what we're talking about anymore
04:12:35 <Cale> I'm not altogether sure why you want this...
04:13:02 <Cale> danilo2: It might help you to know that you can use unsafeCoerce to just avoid the Haskell type system altogether, but good luck with the segfaults.
04:13:20 <SLDR> mcstar: Didn't
04:14:30 <Cale> danilo2: You're almost, but not quite guaranteed to get a segfault or crazy behaviour from anything you unsafeCoerce :: a -> b when a and b aren't actually the same type at runtime.
04:14:33 <SLDR> mcstar: Appreciating the help a great deal. brb for a few; real life calls.
04:15:35 <Cale> (this can result in jumping into random code, so...)
04:16:44 <Cale> There was an obfuscated Haskell contest entry which used unsafeCoerce with some very specially constructed ByteStrings to jump into code represented by the ByteString and print out Hello World
04:17:44 <danilo2> Cale: Oh, that could be funny :D Ok, but seriously, I do not see how could it help me. In my example function (sorry, I write it once again): "def f(x): x.test()" - I do not know what is the type of "x", so I cannot usee UnsafeCoerce here - or am I wrong? Anyway I'll look into Unsafecoerce - not to use it, but to know more about it, because I like such "hacking" tools ;)
04:18:07 * hackagebot FTPLine 1.4.0.0 - A command-line FTP client.  http://hackage.haskell.org/package/FTPLine-1.4.0.0 (DanielDiaz)
04:18:36 <Cale> Well, it's just a function with the signature I gave:  unsafeCoerce :: a -> b  and rather than being something like  const undefined  it instead keeps the runtime representation for its parameter in its result.
04:18:36 <danilo2> Cale: btw I came to an idea how to solve it - I'm teying right now to make an sample code and werify if it works :)
04:19:04 <Cale> So it's like a reinterpret cast, but in a language where all values are code pointers, that can be quite a crazy thing to do :)
04:19:50 <Cale> I suspect that your compiler will just be able to generate something a lot simpler.
04:20:37 <Cale> x could just be represented by a record with (minimally) a single field for the implementation of the 'test' method.
04:20:58 <Cale> If your language is typed, and the object type of x doesn't have any other methods, that is.
04:21:20 <danilo2> hmm :) Yes and it owuld make my compiler very very error prone. Anyway I came to an idea, that we can make an TypeClass for "each method" of a "class". Then we can make an existential datatype with constrains of all these typeclasses (I have a parser so I can easly see what methods are used in a funion). And then I can maybe use that type with a vareiable in a function
04:21:50 <Cale> I'm not sure typeclasses actually help you in any way
04:22:13 <SLDR> mcstar: Right then.
04:22:14 <Cale> If you're generating code, you can just generate the typeclass dictionaries as data structures by hand, generally.
04:22:51 <Cale> and you're going to know better than the Haskell compiler which methods are the appropriate ones to use
04:22:57 <danilo2> Cale: Ok, but if a "class" will be represented by a recor with single field being a test method (like in the code: http://lpaste.net/94526), how can I sue this UnsafeCoerce to make "f" function working ?
04:23:32 <Cale> (I don't think you need unsafeCoerce, but I mentioned it because it sounded like you wanted to turn off the type system for some reason)
04:23:55 <Cale> (but if you do that, why are you using Haskell as your target language)
04:25:56 <danilo2> Cale: So the idea is to generate "dictionaries" by hand, which will give me methods, when I ask them for it? Just to check - it will be a lot slower than calling Haskell mehods, wont it?
04:26:05 <Cale> no
04:26:11 <Cale> It won't be slower
04:26:19 <Cale> You're doing a record extraction
04:26:24 <Cale> Which is constant time
04:27:15 <Cale> Maybe there will be one more pointer indirection than otherwise, but conceptually, you have to pay that price anyway.
04:27:34 <Cale> (because you're trying to represent a form of polymorphism, so you expect that indirection to be there)
04:29:04 <Cale> danilo2: Does that make sense?
04:29:56 <Cale> danilo2: For each object type in your source language, you create a Haskell data type with fields matching the methods of that type of object. For each actual object of that type, you create a value of the record type with the implementations of the methods as the fields of the value.
04:29:57 <danilo2> Cale: It makes sense and it sounds very interesting to me, there is only one problem : I do not see exactly how can I implement it, to make it working when I do not know the type of a variable, which method i'm calling (like in the example with "x.test()"
04:30:17 <mcstar> SLDR: you could try printing the list `points` generates, before calling render, or something... maybe there is some lazyness involved, idk, with ghc it should work
04:31:06 <SLDR> mcstar: Forgot about print. Let's see if that works...
04:31:14 <danilo2> Cale: Ahh I see what youre talking about. Ok, Ok, Ok
04:31:18 <Cale> danilo2: When you first talked to me, you mentioned that you didn't want to bother with inheritance. This means that from the name 'test', we can determine precisely the complete set of methods which x can respond to, yes?
04:32:13 <Cale> (or subtyping, I suppose)
04:32:56 <Cale> I guess you might want to do subtyping but not inheritance, in which case, you need to do something more to handle that
04:33:22 <mcstar> SLDR: do \n let pts = points... \n print pts \n render.. something like that
04:33:35 <danilo2> Cale: We cannot determine the set of methds, because we do not know "what is x". "x" can be instance of **any** class user can define in other file etc. So in the example "def f(x): x.test()" we can know what is "test" only knowing what is x, but compiling the file, we cannot determinae all possible "x", because user cna define other classes with methods named "x" and use it in this function
04:34:20 <Cale> danilo2: My idea here is that because you're using the method 'test', you can determine which *type* of object x is
04:34:22 <danilo2> Cale: But I have one idea - thank you for all the help and ideas! I'll try to check something and I'll write you back if I managed to do it
04:34:44 <Cale> danilo2: Maybe not which *object* it is, you might not know which implementation of the test method is being used.
04:35:12 <Cale> But you'll know which methods x can respond to because you can look up its type (let's ignore subtyping)
04:35:39 <danilo2> Cale: Hmm, if I'm using "test" method I do not know wich *type* of object x is ? Do I ?
04:35:54 <danilo2> Cale: Wait, I have to rad again what youve written, maybe I missread something
04:36:05 <Cale> Well, it depends heavily on your language, but if *I* were designing an OO language today, that's how I'd do it.
04:36:23 <Cale> This isn't strictly true of most typed OO languages because of subtyping.
04:37:02 <Cale> You'd be able to say "oh, it has to be some subtype of this object class X which defines the test method"
04:37:09 <danilo2> Cale: Ok, but if more than one type provide method "test" than I cannot detemrine which type it is ?
04:37:21 <Cale> Right
04:37:35 <Cale> But I would be cruel and force all methods to be distinct between object types :)
04:37:49 <Cale> disjoint, even
04:37:56 <danilo2> Cale: ahhh :D then it indeed works
04:38:12 <Cale> That makes things *much* simpler
04:38:31 <Cale> and if you allow people to define new objects with the same method types, but different implementations
04:38:40 <Cale> then in practice, you don't really need subtyping all that much anyway
04:38:47 <Cale> and you can do very strong type inference
04:39:32 <Cale> But suppose you're not going about it like that
04:39:48 <Cale> then you're likely to require the user to specify the type of x at the point where it's bound
04:40:16 <Cale> The languages which do neither tend to be dynamically typed, and they pay for it
04:40:40 <danilo2> Cale: ok, I have to think about it, but
04:41:25 <Cale> You might leave in the implementation of every object type, a "hole" to put records of methods of subtypes
04:41:34 <ker2x_> friendly greetings \o/
04:41:40 <danilo2> Cale: the type of x will be defined always where is is bound, becasue if I use "f", I haveto pass there an argument, which will be typed. I can for example pass there "f(Vector 0 0 0)" - so the type will be known
04:41:55 <SLDR> mcstar: Tried that implementation. Still does bugger all.
04:42:41 <Cale> danilo2: By "where it's bound", I mean in the parameter list to f, not the argument list.
04:42:52 <danilo2> Cale: ah, ok
04:42:53 <Cale> (i.e. not at a call site)
04:42:59 <danilo2> Cale: Ok, that are interesting ideas. I'll have one idea I want to check now and I'll write back to you (if you dont mind to) :)
04:43:44 <Cale> Okay, play around with it. There are lots of possible ways to do this, and I'm being a little bit blunt about what I consider to be major options.
04:44:00 <Cale> Hello ker2x_
04:44:17 <ker2x_> hello :)
04:47:22 <ker2x_> i'm learning haskell using leksah, on windows. is there a channel related o leksah ? i think i messed up something.
04:47:46 <Kaidelong> #leksah
04:47:52 <ker2x_> heh
04:48:00 <ker2x_> i go check there, thx
04:49:35 * mcstar wonders whether #lleksah is populated
04:49:52 <ker2x_> not really
04:49:58 <ker2x_> but i asked anyway
04:50:57 <mcstar> ker2x_: i must ask, have you tried reading leksah backwards?
04:51:25 <ker2x_> yes
04:51:48 <ker2x_> well i didn't try but it was obvious that a l is missing :)
04:51:51 <mcstar> ok, wasnt sure, i was wondering about #ll..
04:53:14 <ker2x_> i didn't try the channel with 2 ll
04:53:24 <ker2x_> i tought you did a typo :)
04:53:30 <mcstar> it was a joke
04:53:34 <ker2x_> k :)
04:53:34 <mcstar> kind of
04:55:04 <ker2x_> well, no answer, i'll assume that the warnings are harmless
05:00:28 <ker2x_> Mmmm. "import Complex" should work, isn't it ?
05:02:04 <mcstar> i dont think so
05:02:11 <mcstar> maybe, Data.Complex?
05:02:37 <donri> It is a member of the hidden package `haskell98-2.0.0.2'.
05:02:43 <donri> you probably don't want haskell98
05:02:56 <donri> (so yes, Data.Complex)
05:03:01 <ker2x_> ha
05:03:03 <ker2x_> testing :)
05:03:40 <ker2x_> \o/
05:03:45 <ker2x_> thank you
05:04:31 <ker2x_> when i googled i found this http://www.haskell.org/onlinereport/complex.html
05:04:46 <mcstar> thats great, but not up to date
05:05:00 <mcstar> it says, The Haskell 98 Report
05:05:03 <ker2x_> yes
05:05:17 <ker2x_> and the current version is ?
05:05:32 <mcstar> im not sure if that particular report is updated
05:08:57 <benmachine> http://www.haskell.org/onlinereport/haskell2010/ this is *almost* the current version
05:09:25 <benmachine> haskell2011 exists, which is that + a few very minor other extensions
05:09:33 <benmachine> my understanding is that a haskell2011 report was never published
05:09:40 <ker2x_> ok :)
05:10:06 <ker2x_> as long as it's not Haskell0x :)
05:10:29 <donri> however, the sad state of affairs is that ghc isn't fully standards compliant (either standard) and most things use the "base" package which is incompatible too
05:10:55 <benmachine> donri: so, the situation with the haskell-standard libraries I don't fully understand
05:11:06 <donri> me either
05:11:30 <benmachine> I have this vague idea that the haskell2010 package *is* the standard, sort of
05:11:41 <ker2x_> :)
05:11:45 <donri> it's just weird how the haskellX packages depend on base rather than the other way around
05:12:28 <donri> haskell2010 exports the standard modules, but it depends on non-standard packages
05:13:07 <donri> ie. the interface is standard, but not the implementation :P
05:13:14 * hackagebot snaplet-rest 0.1.0 - REST resources for the Snap web framework  http://hackage.haskell.org/package/snaplet-rest-0.1.0 (TimothyJones)
05:13:42 <ker2x_> same problem with every langage, isn't it ?
05:13:47 <donri> also funny is all the talk of slimming down base. why do we even have base? :P
05:14:15 <benmachine> donri: well, a lot of the basic stuff all depends on each other, so it's hard to get a sensible dependency DAG out of it
05:14:24 <donri> (i think the answer is "circular import dependencies" issues)
05:14:27 <donri> yeah
05:14:31 <benmachine> donri: e.g. anything that defines a type probably wants to depend on Typeable
05:14:48 <benmachine> so anything *in* Typeable has to be pretty near the bottom of the tree
05:15:13 <mcstar> everything is Typeable, isnt it?
05:15:18 <mcstar> in 7.8
05:18:17 <donri> mcstar: the way i understood it, no. there's a new extension for making "deriving Typeable" implicit though, affecting just the module(s) compiled with that extension
05:18:19 <donri> IIUC
05:18:29 <donri> https://github.com/ghc/ghc/blob/master/docs/users_guide/7.8.1-notes.xml#L182
05:22:52 <ker2x_> i go back reading my haskell book. see you later, have fun =^_^=
05:24:39 <ker2x_> or perhaps i'll learn some more vhsl... well, i'll see that. bbl :)
05:24:48 <ker2x_> vhdl*
05:25:32 <absence> what is the reason for writing f g a = \b -> g a b instead of f g a b = g a b? i see it sometimes and since it looks unnecessarily complex, i figure there's more than meets the eye
05:26:10 <donri> absence: inlining, mostly, i think
05:26:52 <donri> "GHC will only inline the function if it is fully applied, where "fully applied" means applied to as many arguments as appear (syntactically) on the LHS of the function definition."
05:27:15 <absence> aah
05:27:22 <donri> so your "f" could be inlined, given only "g" and "a"
05:27:45 <absence> i see, thanks
05:35:30 <donri> absence: subjectively, it can also help readability in cases like, instances for (->)
05:36:15 <donri> for example http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Text-Printf.html#PrintfType
05:37:34 <DanielDiaz> has anyone implemented the LZMA compression algorithm in Haskell?
05:39:08 <Ghoul_> woah
05:39:43 <Ghoul_> http://research.microsoft.com/en-us/people/smcdirm/liveprogramming.aspx?iedz00 -- is very cool.
05:39:44 <henk> I have a string like "Sun Oct 20 14:28:28 CEST 2013;foobar" and would like to split that to get ("Sun Oct 20 14:28:28 CEST 2013", "foobar"), i.e. the ';' should be dropped. »span (/= ';') "Sun Oct 20 14:28:28 CEST 2013;foobar"« almost does what I need, but the ';' is still part of the second string. Any hints on how to do that?
05:54:50 <alllex229> henk: maybe splitWith?
05:55:26 <haasn> > "Sun Oct 20 14:28:28 CEST 2013;foobar" ^.. splittingOn ";" folded
05:55:29 <lambdabot>   ["Sun Oct 20 14:28:28 CEST 2013","foobar"]
05:55:35 <haasn> :t splitOn -- do we have this?
05:55:36 <lambdabot> Eq a => [a] -> [a] -> [[a]]
05:55:41 <haasn> well there you go
05:55:47 <haasn> > splitOn ";" "foo;bar;bat"
05:55:48 <lambdabot>   ["foo","bar","bat"]
05:56:05 <lpaste> derdon pasted “cabal fun” at http://lpaste.net/94530
05:56:29 <derdon> can anyone tell me why cabal cannot find the version of happy after having installed it?
05:57:00 <derdon> because of this issue I cannot install haskell-src-exts
06:00:07 <dcoutts_> derdon: make sure it's on your $PATH
06:00:10 <henk> alllex229, haasn: thanks
06:00:52 <derdon> dcoutts: ~/.cabal/bin *is* in my path. otherwise, line 1 would have caused an empty line as output
06:01:12 <derdon> dcoutts: do I have to configure ~/.cabal/lib or something as well?
06:02:34 <dcoutts_> derdon: ok, if it's on the $PATH then cabal should find it
06:02:47 <derdon> indeed
06:03:26 <dcoutts_> derdon: oh you're asking why cabal list doesn't show it
06:03:34 <dcoutts_> derdon: don't worry about that, it'll find it
06:03:53 <derdon> I ask why the version is "unknown" in the output of "cabal list"
06:04:08 <derdon> although happy --version can tell me the version
06:04:10 <dcoutts_> derdon: it's because it doesn't keep track of programs being installed
06:04:32 <dcoutts_> derdon: because cabal is just using ghc-pkg to see what's installed, and that only covers libs.
06:04:45 <derdon> oh dear
06:05:06 <dcoutts_> derdon: so it'll find it if it's on the $PATH
06:05:14 <dcoutts_> when you build something else
06:05:32 <henk> alllex229, haasn: But both ways seem to mean that I will have to import special packages, which are not even available on debian as a package it seems. That’s not really acceptable for such a basic task ):
06:06:10 <dcoutts_> derdon: that's why it says unknown rather than not installed
06:06:17 <haasn> henk: sounds like a defect of debian to me
06:06:32 <derdon> I attempt to install haskell-src-exts now again and paste the output if I can't go on
06:06:34 <haasn> besides, you should have ‘lens’ installed either way :)
06:06:58 <dcoutts_> derdon: sure
06:08:59 <mcstar> Data.Text has splitOn, and that package is preferable for text manipulation afaik
06:09:07 <mcstar> (instead of String)
06:09:09 <henk> haasn: hehe, needing to import an exotic package (i.e. not popular enough to have found a packager for debian) to split a string might some people see as a defect in haskell (; I don’t know lens, what is that?
06:09:25 <mcstar> you are splitting a LIST
06:09:26 <henk> mcstar: Yes, that’s what haasn pointed me to, but AFAICT that’s not available in debian, is it?
06:09:46 <mcstar> no, that splitOn is from some list processing package
06:10:13 <mcstar> and the text package should be pretty popular
06:10:21 <derdon> dcoutts_: ooops, seems like adjusting $PATH already fixes it. now error message so far, installing takes some time
06:10:41 <derdon> I was so confused by the output of cabal list that I thought something was wrong
06:10:45 <donri> henk: there's the split package, which ships with haskell-platform
06:11:04 <henk> mcstar: oh … I was looking at the splitOn from Data.Text anyway (:
06:11:12 <bennofs> henk: splitOn is available in the split package, which is in the platform
06:12:21 <chrisdone> henk: if you're processing text then you should be using the text package anyway =)
06:13:59 <henk> hm, AFAICT Data.Text is not available on Debian, but I’m not sure how to properly tell if it is … Could anyone explain how to tell?
06:14:19 <derdon> yay, finally got omni completion working \o/
06:14:24 <donri> i would be very surprised if text is not packaged for debian
06:14:32 <chrisdone> man it's so annoying that GHCi doesn't print an error when you have a missing Show instance on the return value
06:14:37 <mcstar> debianpackagemanager search text | grep -i haskell
06:14:38 <donri> henk: http://packages.debian.org/source/squeeze/haskell-text
06:15:31 <chrisdone> no-show-on-IO worst use-case ever
06:15:32 <donri> chrisdone: also fun how that happens if you have an IO (IO ..) :P
06:15:41 <henk> donri: ah, thanks
06:16:22 <mcstar> but isnt cabal preferable even on debian?
06:16:39 <chrisdone> i use cabal exclusively on ubuntu
06:16:41 <donri> cabal is a build tool
06:16:45 <mcstar> (j/k with the 'even')
06:17:04 <mcstar> well, cabal as an infrastructure, cabal-install the command
06:17:13 <mcstar> or whatsitcalled
06:17:19 <mcstar> nope, cabal
06:17:53 <donri> Cabal is a build infrastructure; cabal-install is a build tool  :P
06:18:17 <ker2x_> what would you suggest for a simple GUI ?
06:18:36 <mcstar> a calculator, thats simple and useful
06:18:36 <chrisdone> ker2x_: what's the UI's purpose and what platform?
06:19:02 <danilo2> hello! :) Could somebody please tell me why I'm getting an erro in this simple code? (http://lpaste.net/94531) The problem is in line 10, where I'm trying to type a function. The code without this type works good. But why this type causes an error and what does this error mean ?
06:19:35 <ker2x_> I'm on windows right so : windows (linux would be nice too). It's for a fractal generation program. drawing pixel, capturing mouse event
06:19:46 <derdon> donri: wouldn't a full package manager be better?
06:19:53 <ker2x_> SDL would work too
06:20:06 <donri> derdon: cabal would be better if it tried less to be a package manager :)
06:20:16 <derdon> donri: why do you think so?
06:20:28 <Iceland_jack> danilo2: Well you're using do-notation on something that's not a monad?
06:20:30 <donri> most of the problems with cabal stem from trying to be both a build tool and a package manager
06:20:41 <Benzi-Junior> ker2x_: gtk2hs
06:21:04 <ker2x_> ok, why not.
06:21:06 <ker2x_> thank you
06:21:11 <danilo2> Iceland_jack: No, the do notation is used on IO monad.
06:21:23 <Iceland_jack> never mind
06:21:32 <derdon> donri: ah, okay. so cabal should less be a package manager and in addition, there should be something that is only a pkg manager and not a build tool at all
06:22:01 <donri> derdon: i don't think there is a need for a specialized package manager, no
06:22:03 <derdon> like go seperates the "go build" command from "go get"
06:22:31 <ker2x_> tons of error 404 on the project page
06:22:33 <ker2x_> pfft
06:23:07 <Benzi-Junior> What is needed is a package manager that utilises Cabal as the build tool (not a nessesary factor but why would you make another build tool)
06:23:30 <donri> Benzi-Junior: that's how most linux distros package haskell stuff
06:23:42 <chrisdone> nice. my attoparsec-based grep wrapper handles 300 colored results in 17ms (71ms in total, 54s waiting for grep)
06:23:53 <ker2x_> Could not find module 'Graphics.UI.Gtk'
06:23:54 <chrisdone> 54ms*
06:23:55 <ker2x_> meh
06:24:16 <donri> chrisdone: what is that parsing?
06:24:44 <pyr> i'm confused with group. shouldn't group ["a", "b", "b", "a] yield [["a", "a"], ["b", "b"]] ?
06:24:45 <chrisdone> donri: lines, and source spans of matches within the results into [Either Text Text]
06:24:50 <Benzi-Junior> I have a problem where if there are a lot of dependencies for a package Cabal usually just breaks the build
06:24:52 <pyr> since "a" == "a" yields true ?
06:25:06 <stbuehler> @hoogle (a -> m b) -> m (a -> b)
06:25:07 <lambdabot> No results found
06:25:40 <stephenmac7> IO isn't a functor?
06:25:42 <hpc> stbuehler: assuming Monad m, that can't be implemented
06:25:46 <merijn> pyr: No, group doesn't change the order
06:25:55 <merijn> pyr: If you want that, sort first, then group
06:26:00 <hpc> :t fmap
06:26:01 <chrisdone> donri: λ> fmap (take 1) (grep ["/home/chris/Projects/structured-haskell-mode/"] def { qRegex = Regex "TODO: .*" })
06:26:01 <chrisdone> donri: [(SourceSpan {spanFile = "/home/chris/Projects/structured-haskell-mode/elisp/structured-haskell-mode.el", spanLine = 131, spanColFrom = 6, spanColTo = 51},[Left "  ;; ",Right "TODO: Delete all the markers from the buffer.",Left ""])]
06:26:01 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:26:01 <merijn> stephenmac7: IO is a Functor
06:26:03 <chrisdone> donri: :D
06:26:05 <stephenmac7> Okay
06:26:08 <pyr> merijn: ah, I see
06:26:09 <hpc> :t fmap ?f getLine
06:26:10 <lambdabot> (?f::String -> b) => IO b
06:26:11 <danilo2> Does enubody know, why this code does not compile? :(  http://lpaste.net/94531
06:26:26 <merijn> pyr: i.e. it groups consecutive equal elements, no all
06:26:36 <donri> chrisdone: ah. but what is the "colored results" then?
06:26:48 <stbuehler> hpc: working with Data.Tagged
06:26:51 <Benzi-Junior> I am not familiar enough with the program infrastructure of a package manager to say what exactly Cabal needs in adition to become one
06:26:55 <mcstar> Could not deduce (t ~ X (a1 -> b1 -> (a1, b1))) thats why
06:27:00 <pyr> merijn: thanks
06:27:11 <merijn> Benzi-Junior: It would need to track installed files so it can delete them
06:27:12 <chrisdone> donri: the colored results is how you get what part of the text actually matched
06:27:20 <donri> chrisdone: aah
06:27:25 <Iceland_jack> danilo2: _method1 has type ∷ X a → a
06:27:45 <danilo2> mcstar - ok, but why this happens? If I do not write explicit type in line 10 it compiles
06:28:03 <Benzi-Junior> merijn: Is that all it lacks feels like that should be trivial to add
06:28:41 <danilo2> Iceland_jack: yes, so _method1 x has type a, whcih can be b->c->(b,c) (like constructor function in line 5 says) ?
06:28:45 <merijn> Benzi-Junior: I'm not sure what else it should do, I'm not sure what package managers all do
06:29:31 <henk> hm, seems like I want to split a list. No need converting it to the Text type yet …
06:29:36 <merijn> danilo2: oh, I think you hit an entirely unrelated issue
06:29:51 <Iceland_jack> danilo2: it works if you give the type to the argument
06:30:22 <Iceland_jack> :t \(x :: X (a -> b -> (a, b))) -> ((_method1 x) :: a -> b -> (a, b))
06:30:23 <lambdabot> Not in scope: type constructor or class `X'
06:30:23 <lambdabot> Not in scope: `_method1'
06:30:25 <chrisdone> is there a thing to print a "depends" output for your cabal file?
06:30:45 <merijn> danilo2: Try adding "f :: X (a -> b -> (a, b)) -> a -> b -> (a,b)" and removing the signature on line 10
06:30:46 <hpc> chrisdone: you mean "given these modules, guess what packages are needed"?
06:30:48 <chrisdone> like, just print out all the current version i'm using with an upper pound
06:30:49 <hpc> i doubt it
06:30:52 <donri> chrisdone: if it's installed, ghc-pkg field pkg build-depends
06:31:16 <donri> nope
06:31:17 <chrisdone> hpc: actually cabal already knows because the packages are installed, i'm just doing that whole thing of "Could not find module, it is a member of the hidden package blah blah blah"
06:31:18 <merijn> eh
06:31:19 <chrisdone> and manually adding it
06:31:26 <Benzi-Junior> merijn: Same here I don't know enough about what constitutes a package manager to say whats missing  but if tracking installed packages in order to be able to remove them is something that should be a easy DB setup built into it
06:31:39 <merijn> danilo2: Obviously I meant "Monad m => X (a -> b -> (a,b)) -> m ()"
06:31:40 <chrisdone> donri: nah i'm /writing/ a package
06:31:52 <chrisdone> i'm going through a pointless manual process of writing out all my project's dependencies
06:31:54 <donri> looks like it's "depends" in ghc-pkg anyway
06:31:56 <merijn> Benzi-Junior: Not just installed packages, also the files they create, etc.
06:32:01 <chrisdone> donri: i'll try it
06:32:06 <donri> chrisdone: cabal init does that for you
06:32:22 <henk> split package works fine it seems, thanks to everyone for the pointers and help (:
06:32:28 <chrisdone> donri: what if i already have a cabal file?
06:32:32 <donri> chrisdone: also, ghc-pkg find-module
06:32:35 <danilo2> merijn: yes it of course works. It even works if I do not write any types, but why the type on line 10 does not ? It should, am I wrong?
06:32:46 <mcstar> anyway i look at that code, that type sig does not work out for me
06:33:13 <danilo2> Iceland_jack: I know. I want though to understeand why it happens like that
06:33:42 <dcoutts_> chrisdone: see https://github.com/haskell/cabal/pull/1455 , it could be extended to report what you need.
06:33:52 <dcoutts_> chrisdone: if you'd like to work on a patch
06:34:17 <merijn> danilo2: It's unrelated to the type on line 10
06:34:34 <merijn> danilo2: Which GHC version is this?
06:34:59 <danilo2> merijn: 7.6.3
06:35:11 <mcstar> i dont see how Monad has to do with this, the requested type just doesnt work out
06:35:24 <donri> chrisdone: yeah it would be neat if you could use cabal init with existing project more easily. for example, writing to a different file that you can copy from or diff against, etc
06:35:47 <mcstar> data X a = X { meth :: a }; then :t let meth :: a -> b -> (a,b) doesnt work
06:36:01 <merijn> mcstar: mcstar That's not what he wrote, though
06:36:12 <mcstar> but pretty close, isnt it?
06:36:18 <merijn> mcstar: He wrote "_method1 x" where x is the argument to f
06:36:27 <mcstar> yeah, but the type sig would be the same
06:36:41 <mcstar> `x` has type `a` in that code
06:36:45 <merijn> mcstar: So logically it should infer that if the result of that is "a -> b -> (a, b)" then "x :: X (a -> b -> (a,b))"
06:37:00 <merijn> mcstar: Because "_method1 :: X a -> a"
06:37:09 <mcstar> thats correct
06:37:09 <merijn> mcstar: wut
06:37:13 <danilo2> merijn, mcstar: I've added a type annotation there: http://lpaste.net/94531 and it still does nto work
06:37:21 <merijn> mcstar: Why would x have type 'a' in that code?
06:38:36 <mcstar> merijn: probably im wrong then, but i read that, _methodl has type a->b->(a,b), which means, the first argument has type `a` which `x` is
06:38:42 <merijn> danilo2: The problem is that the inference is propagating back to the type of 'f', I dunno why, though
06:38:44 <danilo2> mcstar: But it does not work even if tou explicitly say that "x :: X (a -> b -> (a,b))" (see the updated code)
06:38:49 <merijn> mcstar: That's not how it works...
06:38:55 <mcstar> ok
06:39:16 <merijn> mcstar: Type annotation bind least tight of all, it's saying that the type of "_method1 x" (i.e. _method1 applied to x) is "a -> b -> (a, b)"
06:39:49 <merijn> :t (+) 1 :: Int -> Int -- not Int -> Int -> Int
06:39:49 <lambdabot> Int -> Int
06:39:54 <mcstar> that sounds pretty unusual to me, but im sure you are right
06:40:11 <danilo2> merijn: Ok, so this is a bug in GHC?
06:40:20 <merijn> mcstar: Why would that be unusual?
06:40:35 <merijn> danilo2: I have no clue, that code is pretty weird. I'm not sure how it's supposed to be inferred
06:40:51 <mcstar> merijn: well, in that example you partially applied (+) to 1, you didnt define (+) on that line
06:41:20 <mcstar> but yeah, i see it now
06:41:24 <merijn> mcstar: So? He isn't defining _method1 or x on that line either?
06:41:38 <danilo2> merijn: Ok, but if you look at the updated code: http://lpaste.net/94531 I even ecplict typed the "x" and it still does not compile. I tink it should ... :(
06:41:44 <mcstar> merijn: ok, i got it now, been away too long from haskell
06:41:46 <merijn> :t let (+) = (*) in (+) 1 :: Int -> Int
06:41:46 <lambdabot> Int -> Int
06:42:46 <merijn> :t let (+) :: Num a => a -> a -> a; (+) = (*) in (+) 1 :: Int -> Int
06:42:47 <lambdabot> Int -> Int
06:43:00 <mcstar> merijn: i got confused with a top level function definition, since you can specify the full type sig, and still explicitely provide names for the arguments
06:44:46 <mcstar> <nothaskell> f a b :: Int -> Int -> Int = .... </nothaskell>
06:45:23 <danilo2> merijn, mcstar: Ok, I've updated the code - it is even funnier than the previous one: http://lpaste.net/94533 . Ifyou throw away the type signature in line 11 it works. But the signature in line 11 is good imo ... :(
06:45:42 <mcstar> danilo2: talk to merijn, im a noob
06:46:32 <hpc> danilo2: add {-# LANGUAGE ScopedTypeVariables #-} to the top of the file, see if that makes it work
06:47:06 <danilo2> hpc: the error is still the same
06:47:32 <hpc> hmm
06:48:01 <mcstar> merijn: believe me, ive fixed the types of partially applied expressions before...
06:51:06 <danilo2> merijn, hpc: I've added an annotation here: http://lpaste.net/94533 . If we type wrong the line 11, ghc tell us , there should be type of "(a -> b -> (a, b))", but if we use it (like in my original cde), it does not work :(
06:51:59 <hpc> danilo2: ...
06:52:50 <danilo2> merijn, hpc: Ok, is this GHC bug? Should i report it?
06:53:17 <hpc> oh, here we go
06:53:23 <hpc> http://lpaste.net/94534
06:53:31 <hpc> it's just being really picky about having the forall in there
06:53:45 <hpc> that works on my 7.4.1
06:54:44 <mcstar> why isnt that forall implied?
06:54:47 <danilo2> hpc: It works, but it still does not work if we do not proivde explicit type signature to function f. Why GHC cannotr simply infer it ?
06:55:08 <danilo2> and additional - mcstar's question is very interesting also
06:55:17 <mcstar> i mean, usually you dont have to write forall explicitely
06:56:11 <hpc> danilo2: i expect your question is going to be answered with "it infers the type signature without an explicit forall, and then mcstar's question"
06:56:26 <hpc> and yeah, i have no clue what's up with that
06:57:51 <danilo2> hpc: where should I ask about it ? I would really need the feature of "not typing explicit f signature". And I do not understeand why it does not work - and I think nobody here understeands also :/
06:58:02 <hpc> #ghc perhaps
06:58:14 <danilo2> ok :) I'm asking there right now :)
06:58:21 <hpc> or if you reduce that code to a simpler test case, add it to the trac
06:59:09 <mcstar> i still think you could reproduce the whole thing without monads there
06:59:31 <mcstar> or, you should try, maybe you will learn something
07:00:28 <mcstar> danilo2: also, whats the application? are you trying to build heterogeneous lists or something?
07:01:06 <Vamp> How should I implement get :: m s and put :: s   -> m () in terms of modify :: (s->s) ->  m s ?
07:01:23 <hpc> get = modify id
07:01:35 <hpc> put s = modify (\_ -> s) >> return ()
07:01:44 <Iceland_jack> maybe Vamp wanted to learn how to figure it out themselves
07:01:50 <hpc> oh
07:01:54 <danilo2> mcstar, merijn, hpc: here is simplier version of the code, as mcstar requested: http://lpaste.net/94536
07:01:56 <merijn> hpc, danilo2: ScopedTypeVariables always needs forall to bring variables in scope
07:02:03 <Vamp> Yeah, wanted some hints tbh :P
07:02:16 <hpc> it's been a morning :(
07:02:29 <Iceland_jack> Vamp: Do you understand hpc's solutions?
07:02:49 <danilo2> merijn: this code does not use ScopedTypeVariables an it does not work: http://lpaste.net/94536 . I do not think it needs ScopedTypeVariables
07:03:27 * hackagebot uuid 1.3.1 - For creating, comparing, parsing and printing Universally Unique Identifiers  http://hackage.haskell.org/package/uuid-1.3.1 (AntoineLatter)
07:03:46 <Hodapp> for some reason, I hate UUIDs.
07:04:00 <Vamp> Iceland_jack: I do get the get one, but the put is a bit unclear
07:04:24 <Iceland_jack> The get one isn't quite right since it doesn't get the element
07:04:34 <Iceland_jack> but ok, what does modify do?
07:04:46 <hpc> Iceland_jack: my get is correct
07:04:49 <hpc> you're thinking of gets
07:04:56 <Iceland_jack> :t get
07:04:56 <Iceland_jack> :t modify id
07:04:57 <lambdabot> MonadState s m => m s
07:04:57 <lambdabot> MonadState s m => m ()
07:05:00 <Iceland_jack> Am I?
07:05:17 <hpc> Iceland_jack: he gave a specific type for modify, (s -> s) -> m s
07:05:37 <Iceland_jack> ah ok, so it's not the standard modify
07:06:17 <hpc> Vamp: so for put
07:06:43 <hpc> Vamp: (modify f) is essentially, "get the state, apply f to it, then put it"
07:07:06 <hpc> Vamp: f is "ignore what we get, put this instead"
07:07:50 <chrisdone> aww yeah
07:07:55 <Vamp> hpc: I see
07:08:02 <chrisdone> project TODOs/FIXMEs in org-mode format: http://chrisdone.com/todo.png
07:08:50 <mcstar> 2,880px × 1,800px ooooh
07:09:26 <chrisdone> =p
07:09:28 <hpc> what's the point of all that pixel space if you're just going to fill it up with 20pt font?
07:09:31 <hpc> ;)
07:09:53 <mcstar> thats a goot pt!
07:09:58 <mcstar> j/k
07:10:13 <hpc> enyway
07:10:53 <chrisdone> hpc: the point is that text is crisp as hell
07:11:24 <merijn> hpc: You're one of those 10pt courier "I hated my eyes anyway" people? :p
07:11:29 <hpc> nope
07:11:31 <mcstar> or, the monitor is 13"
07:11:40 <hpc> 6pt droid sans
07:11:43 <chrisdone> the text is physically more like 10-11pt on a normal screen, but twice as crisp
07:11:57 <chrisdone> my screen's 15"
07:12:23 <hpc> my 3-year-old phone can render a 200-wide terminal with the font still readable using droid sans mono :D
07:13:05 <chrisdone> there's readable and there's comfortable
07:13:50 <hpc> yeah, i keep it larger, but it's still comfortable at very small sizes
07:13:55 <chrisdone> yup
07:14:18 <hpc> (fwiw i use a laptop as my daily machine so screenspace is fairly important)
07:14:19 <chrisdone> especially ubuntu mono
07:15:01 <chrisdone> i find ubuntu mono scales extraordinarily well
07:15:17 <hpc> it's all in the hinting ;)
07:15:23 <chrisdone> i have no hinting on
07:15:28 <chrisdone> =) dat retina
07:15:37 <mcstar> im a bitstream vera sans/lucida console guy myself
07:16:00 <hpc> also, quick way to make any font look horrible is to install it on a mac
07:16:24 <hpc> everything becomes blurry and fat
07:16:37 <Iceland_jack> terminus!
07:17:24 <chrisdone> hpc: hinting isn't needed when your resolution is so large, you just double the size of the font and it looks like a normal size text, but you literally cannot see any rendering artifacts in the text. it's like looking at text on paper
07:18:11 <mcstar> chrisdone: well, what is hinting? you still cant say, that a binary font looks nice on that resolution
07:18:12 <donri> i want fast-refresh color e-ink to code on
07:18:23 <chrisdone> mcstar: what's a binary font?
07:18:29 <mcstar> when i say binary, i mean, vector font rasterized to a bitmap
07:18:38 <hpc> donri: i want large eink picture frames
07:18:44 <mcstar> (which is necessary for hardware reasons)
07:18:45 <hpc> like, 50"
07:18:46 <mcstar> :)
07:18:51 <chrisdone> mcstar: you mean one with no beizer curves, just straight lines?
07:19:01 <mcstar> nope, lines and everything
07:19:09 <mcstar> curves*
07:19:30 <donri> actually gray scale is probably fine for syntax highlighting on eink
07:19:34 <chrisdone> i think it would look fine. i have no antialiasing enabled
07:19:38 <mcstar> if you were to rasterize it in a stupid way, the font would still look horrible
07:20:12 <donri> and it doesn't have to have gaming level refresh rates. vi originally was designed for printing to paper? :P
07:20:16 <mcstar> i just dont know where the terminology starts/ends... hinting
07:20:57 <merijn> donri: fast refresh eink already exists, color was in the works, last I heard
07:21:16 <hpc> merijn: at the price of ghosting, though
07:21:20 <merijn> donri: The biggest reason for kindle screens being so slow is the ridiculously underpowered chip behind it
07:21:30 <Vamp> hpc: http://lpaste.net/3351841285806751744 would this statisfy?
07:21:49 <merijn> hpc: Ghosting is hardly an issue for *text*
07:21:50 <hpc> yes
07:22:10 <chrisdone> mcstar: well consider this. if you draw a glyph SVG onto a 10x10 bitmap then you only have 100 pixels in which to represent the glyph
07:22:31 <chrisdone> mcstar: the higher the resolution, the more pixels you have to represent the glyph. but would you say increasing the resolution is doing "hinting"?
07:22:36 <merijn> I think donri (like me) just wants a decent-ish refresh rate and coloured e-ink to have a laptop that you can code on in the sun on a terrace :p
07:22:44 <donri> merijn: color already exists in consumer readers. kinda shitty though, i hear
07:22:54 <chrisdone> me too
07:22:57 <chrisdone> eink is amazing
07:23:09 <mcstar> chrisdone: what im saying is, that if you look at the screenshot, you can see a ridiculous amount of shading, and color variation, so as to the final result(watched on a hi res display) look  as good as it does
07:23:12 <donri> i don't need to be in the sun to appreciate e-ink :)
07:23:15 <merijn> donri: "in the works" == "shitty consumer versions exist, waiting for quality versions" in my world ;)
07:23:20 <donri> :)
07:23:41 <merijn> donri: True, but seeing how my last uni had a bar/cafe with a sunny terrace I would've loved to work on in summer it wouldn't hurt ;)
07:23:44 <mcstar> chrisdone: or on a low-res display, but viewed from a distance
07:24:21 <pyr> merijn: yup got it working, thank you, a bit off putting coming from clojure, I'll read the doc better next time
07:26:13 <chrisdone> mcstar: sorry, you're right. there is antialiasing, but no hinting
07:26:24 <mcstar> ok :)
07:26:55 <chrisdone> antialiasing gives shape. hinting gives the illusion of higher resolution/pixel density
07:27:16 <merijn> pyr: I made the exact same mistakes a few weeks back ;)
07:27:30 <Earnestly> I’ll just leave this here: http://www.rastertragedy.com/
07:27:31 <chrisdone> donri: i still haven't bought a new reader yet. still stuck with my crappy sony reader
07:27:54 <merijn> chrisdone: eh, isn't "giving an illusion of higher resolution/pixel density" pretty much the definition of antialiasing?
07:28:07 <hpc> no
07:28:10 <Earnestly> merijn: See link above
07:28:14 <hpc> AA's purpose is to remove jaggies
07:28:24 <Earnestly> It explains all of this in detail
07:28:35 <merijn> hpc: And jaggies are the result...too low a resolution
07:28:43 <Earnestly> “The Raster Tragedy at Low-Resolution Revisited: Opportunities and Challenges beyond “Delta-Hinting”
07:28:50 <merijn> hpc: In other words, it's trying to give the illusion of a higher resolution :p
07:29:49 <mcstar> what's the term which describes correct color variation, for colored antialiasing?
07:30:30 <hpc> mcstar: subpixel hinting?
07:30:31 <chrisdone> merijn: RGBa?
07:30:31 <mcstar> maybe it is subpixel antialiasing?
07:30:45 <chrisdone> er, mcstar
07:32:23 <mcstar> so, wiki says hinting is more important on low res screen
07:32:24 <donri> merijn: the way i understood it, hinting exploits how LCD displays are built, whereas anti-aliasing is just pixel shading
07:33:16 <chrisdone> hmm. subpixel rendering, hinting and anti-aliasing are three orthogonal concepts
07:33:23 <mcstar> i think antialiasing is to remove the aliasing effect of the display matrix
07:33:35 <mcstar> so it is always applicable
07:33:43 <mcstar> (for matrix displays)
07:33:55 <donri> chrisdone: right, i'm mixing up terms
07:34:04 <merijn> donri: You are thinking of subpixel antialiasing
07:34:14 <donri> yep
07:34:15 <merijn> donri: Which is completely orthogoanl to both concepts
07:34:23 <donri> \o/
07:35:04 <mcstar> hinting is done on a font per font, even character per character basis
07:35:32 <merijn> donri: Well, not completely orthogonal, more of an extra qualifier. Hinting is just changing the rasterisation based on font-size (to get letters to fit the raster nicer)
07:35:58 <merijn> donri: antialiasing is, well, anti-aliasing. And subpixel antialiasing is just an additional tool that can be used to antialias a font
07:35:58 <chrisdone> right, but unlike antialiasing, hinting often changes the shape of the glyph
07:36:09 <merijn> chrisdone: Right
07:36:09 <chrisdone> which makes them look kinda crappy, depending on the hint style
07:36:15 <chrisdone> or fuzzy, like on OS X
07:36:28 <merijn> chrisdone: OSX fuzzines has nothing to do with hinting
07:36:47 <chrisdone> well, hinting on Ubuntu can be made to look like OS X
07:36:51 <mcstar> hinting doesnt cause fuzziness
07:36:52 <merijn> chrisdone: The usuall complaint about fuzziness on OSX is that it antialiases differently than windows
07:36:53 <mcstar> just the opposite
07:37:04 <mcstar> too much aa causes fuzziness
07:37:15 <merijn> chrisdone: hinting is supposed to make fonts *less* crappy by improving rasterisation
07:37:36 <merijn> chrisdone: Fuzziness is caused by too much AA, windows by default disables AA for small point sizes, OSX doesn't.
07:37:50 <chrisdone> true, os x is pure antialiasing, lack of hinting
07:37:51 <mcstar> echo
07:37:58 <mcstar> :)
07:38:03 <merijn> chrisdone: This leads to people (in the past, when resolutions were low and thus point size high) thinking OSX fonts are fuzzy
07:38:07 <chrisdone> ubuntu's default hinting makes fonts lose their shape and look too thin
07:38:11 <merijn> chrisdone: At bigger font sizes there' no difference
07:38:35 <chrisdone> well, os x *rendered text* is certainly fuzzy
07:38:39 <merijn> chrisdone: That just means that Ubuntu uses fonts whose designers suck at hinting
07:38:48 <hpc> tbh, font rendering is one place where windows gets it exactly right
07:38:58 * mcstar always loved how they used/displayed lucida grande for their gui, it is just beautiful
07:39:06 <hpc> things keep as much shape as they can while still being readable
07:39:08 * merijn has never had issues with font rendering OSX
07:39:10 <chrisdone> merijn: i don't think it's the font. the hinting setting is just too high
07:39:20 <merijn> Ya'll motherfuckers need bigger displays/font sizes
07:39:47 <chrisdone> actually, text on retina OS X has no fuzziness at all. so that whole thing is gone these days
07:39:48 <hpc> merijn: don't tell us, tell the companies that keep shipping goddamn 1366x768 laptops
07:39:52 <kenkku> or better dpi
07:40:05 <merijn> chrisdone: What font size do you usually use?
07:40:19 <kenkku> hpc: I've never had a company ship me a 1366x768 laptop against my will :P
07:40:31 <chrisdone> merijn: on what platform?
07:40:45 <merijn> chrisdone: Whatever desktop OS you use
07:41:02 <derdon> is it really safe to remove ~/.ghc and ~/.cabal like this page says: http://hub.darcs.net/simon/cabal-install-tutorial#the-easy-solution-reset-your-packages?
07:41:20 <merijn> derdon: If you don't mind reinstalling any libraries you have installed, yeah
07:41:23 <mcstar> yes, in the sense that god wont punish you
07:41:38 <chrisdone> merijn: on ubuntu here i have my gnome settings to be 200% larger than normal. my emacs is 10pt, but that's doubled up, so it's more like 20pt~
07:41:54 <derdon> mcstar: merijn: good, that's what I wanted to hear
07:42:17 <chrisdone> merijn: ah, the exact scale i settled on was 1.5. so it's 1.5x larger, so 15pt~
07:42:24 <merijn> chrisdone: I'm using 14-15pt for my terminal atm on OSX and I don't have any blurriness
07:43:04 <chrisdone> merijn: so?
07:43:05 <merijn> Although I guess it also depends on the font you use (Monaco <3)
07:43:08 <mcstar> merijn: chrisdone do you guys use tiling window managers on osx? i would be interested to know
07:43:29 <merijn> chrisdone: I was just wondering whether you weren't just one of those silly people using a 10pt and then complaining about blurriness :)
07:43:31 <chrisdone> i used monaco on my previous os x macbook and with antialiasing enabled it was blurry. with it disabled it looked like a bitmap font from the 90's
07:43:48 <merijn> chrisdone: oh, you mean the silly anemic look?
07:43:50 <chrisdone> merijn: i don't think it's silly to want a 10pt font to look good
07:44:00 * mcstar worries that osx will make him crazy after getting very much used to i3
07:44:05 <chrisdone> that's bordering on no true scotsman fallacy
07:44:12 <merijn> chrisdone: It looks good at 10pt, but using a different criterium of good
07:44:35 <merijn> chrisdone: They switched a rendering toggle recently that might Monaco ugly and anemic, was just wondering whether that was it
07:44:42 <chrisdone> "all fonts on os x look good!"  "but at 10pt it looks bad" "no *true* font size looks bad"
07:45:00 <merijn> chrisdone: OSX is optimised for different definition of "looks good"
07:45:21 <merijn> chrisdone: Graphics/design people care about accurate representation of what print looks like, which is traditionally what OSX has followed
07:45:22 <chrisdone> my general definition is "i don't see artifacts"
07:45:39 <merijn> chrisdone: Windows has traditionally followed "on screen legibility over anything"
07:45:54 <chrisdone> so?
07:45:54 <hpc> "this font looks so great!" "i can't read it" "who cares!"
07:46:02 <chrisdone> hpc: =)
07:46:20 <chrisdone> don't get me wrong, i kind liked the fuziness on OS X. it had a certain warm charm to it
07:46:31 <merijn> mcstar: I use OSX full screen mode (which has easy switching between full screen programs) with browser and terminal full screen and things like IM on the desktop
07:46:42 <chrisdone> but nevertheless i could *see* it
07:46:59 <mcstar> merijn: ok, no tiling then, how about multi monitor support?
07:47:18 <Hodapp> hmm, I never had any complaints on the graphical aspects of OS X
07:47:26 <nexx> full screen terminal?
07:47:38 <mcstar> he probably splits it with tmux or screen
07:47:41 <merijn> mcstar: I use tmux inside terminal
07:47:44 <mcstar> or vi or emacs
07:47:48 <nexx> kay
07:48:01 <merijn> tmux, left half vim, right half ghci ;)
07:48:08 <Hodapp> vim? oh, you poor soul.
07:48:10 * Hodapp runs away
07:48:13 <Rylee> vim <3
07:49:05 <chrisdone> but DPG is where it's all at
07:49:13 <merijn> chrisdone: THis is what it ends up like on my screen: http://fau5tln.home.xs4all.nl/screenshot.png
07:49:14 <identity> vim is the bee's knees
07:49:22 <identity> vim + xmonad
07:49:25 <identity> no need for tmux
07:49:26 <Hodapp> pffffffft
07:49:38 <identity> vim + ghcmod et al
07:49:43 <chrisdone> merijn: awww, ickle screenshot =p
07:49:56 <merijn> ickle?
07:50:03 <chrisdone> tiny =p
07:50:12 <chrisdone> merijn: yeah, i can see the artifacts in the font rendering on that
07:50:21 <merijn> chrisdone: I don't have a huge screen at home, sadly :(
07:50:23 <chrisdone> e.g. the < and > characters are perfect examples
07:50:28 <chrisdone> they're kinda jagged
07:50:51 <nexx> I think it looks kind of fuzzy
07:50:54 <merijn> chrisdone: Oh, I only see that when I lean forward by like half a meter
07:50:58 <chrisdone> whereas on my screen, my eyes are incapable of discerning it
07:51:06 <merijn> Maybe I need new glasses again :p
07:51:07 <mcstar> merijn: how do you differentiate nicks without coloring? o.O
07:51:16 <merijn> mcstar: Mad skillz?
07:51:20 <mcstar> :D
07:51:25 <identity> merijn: what font is that?
07:51:31 <merijn> identity: Monaco
07:51:38 <identity> huh. looks pretty good
07:51:38 <mcstar> monaco all bod
07:51:42 <mcstar> bold
07:52:01 <merijn> I like nice bold letters for terminal, nice and readable
07:52:02 <identity> I use Inconsolata
07:52:14 <merijn> identity: Adobe released an open source font kinda similar to it
07:52:21 <chrisdone> yeah monaco looks good on os x
07:52:25 <donri> that's what i use, source code pro
07:52:32 <donri> don't think it's like inconsolata though
07:52:35 <chrisdone> i used it on ubuntu for a while but the one i got only supported one size
07:52:39 <identity> for terminal - Mono One for gvim, some font some dude on r/programming made
07:52:46 <merijn> https://blogs.adobe.com/typblography/2012/09/source-code-pro.html
07:52:56 <identity> I did take a look at source code pro
07:52:58 <identity> not sure tbh
07:53:10 <merijn> chrisdone: I meant kinda similar to Monaco, not Inconsolata :)
07:53:15 <identity> oh
07:53:22 <derdon> Menlo is also a nice font
07:53:26 <chrisdone> merijn: huh? i didn't say Inconsolata
07:53:30 <donri> that was for me
07:53:51 <identity> So many nice fonts really, it's hard to decide
07:54:03 <merijn> chrisdone: oh, whoops, I fail at paying attention :)
07:54:22 <donri> merijn: you need colored nicks, duh
07:54:39 <mcstar> 10,11 pt for me is ok http://i.imgur.com/uI3hFoC.png
07:54:44 <mauke> for nick coloring you really want more than 16 colors
07:55:14 <chrisdone> merijn: the 'm' in your 'Vim-' at the bottom has visible distortion
07:55:24 <identity> donri: colored nicks? care to elaborate?
07:55:47 <chrisdone> merijn: and the dots in : look fluffy
07:55:53 <chrisdone> like two * *
07:56:12 <mauke> ：
07:56:21 <donri> identity: the irc client using different colors for different nicks
07:56:28 <mcstar> identity: for example weechat colors everyones nicks, possibly similar names have different colors, and keeps the same coloring for a given nick
07:56:59 <chrisdone> merijn: but yeah, otherwise it's usable
07:57:06 <mcstar> so for example, i refer to ppl as the blue guy, the red guy the white guy... in my head
07:57:16 <identity> I see. Do you know if irssi is capable of such arcane magic?
07:57:31 <mauke> in theory yes, in practice it sucks because 16 colors
07:57:37 <chrisdone> here are your colors on ircbrowse =p http://ircbrowse.net/browse/haskell?events_page=476522
07:58:28 <chrisdone> but they are pre-chosen from color palettes like zenburn and tomorrow and solarize, rather than generated numerically
07:58:48 <frx> @pl (\acc _ -> acc + 1)
07:58:48 <lambdabot> const . (1 +)
07:59:34 <mauke> liftA pure succ
08:00:15 <chrisdone> mcstar: ye gods! that's hideous =p
08:00:28 <danilo2> Saizan: According to the last question: do you know how can the type signature for "f" be expressed using "F_method1" predicate instead of "X (a -> a -> (a,a)))" ?   http://lpaste.net/94539
08:00:43 <chrisdone> it's fun how looking at another programmer's workspace always looks hideous, and your own always looks emaculate
08:00:55 <donri> everyone's setup is always hideous. including mine if you're not me.
08:01:00 <mauke> immaculate
08:01:03 <mcstar> chrisdone: oh! i thought you meants the fonts, cause they look really nice
08:01:07 <mcstar> -s
08:02:56 <merijn> chrisdone: I only have 1920x1050 or whatever display at like a meter away, so I suspect the number of artifacts visible there is just lost by distance for me. Or maybe it's just that my eyes suck :p
08:03:38 <mcstar> 1680*
08:03:55 <mcstar> thats much less than fullhd, would be hard to work on that
08:04:01 <chrisdone> merijn: a meter away?
08:04:15 <chrisdone> that's pretty far away
08:04:58 <merijn> You're not supposed to sit much closer than 70cm to your screen anyway
08:05:03 <chrisdone> merijn:  but yeah, that's PPD. a low res is countered but a larger screen moved further away
08:05:05 <merijn> It's ergonomically bad :p
08:05:19 <Saizan> danilo2: f :: (forall a. (Show a, F_method1 x (a -> a -> (a,a)) => x) -> IO ()
08:05:29 <chrisdone> merijn: ergonomically bad? =p
08:06:59 <mcstar> ^ this was probably the longest OT i observed so far :)
08:07:22 <donri> don't say the O word, I bet some ops highlight on it
08:09:11 <merijn> mcstar: Meh, I've seen much, much longer ones that were far further off topic :p
08:10:06 <chrisdone> you can lengthen the life of off-topics by giving passing mentions/tenuous links to haskell
08:11:08 <danilo2> Saizan: There is a missmathced bracked in thew type you've provided. I've tried to insert it in any reasonable position, but it does not compile (the error is like without using any type - cannot match String to Int)
08:12:21 <danilo2> Saizan: I suspect you meant "f :: (forall a. (Show a, F_method1 x (a -> a -> (a,a))) => x) -> IO ()" but it still gives compilation errors
08:14:17 <Saizan> danilo2: oh, right, the functional dependencie
08:16:05 <Saizan> danilo2: oh, also it's wrong because we want to provide the context?
08:16:35 <Saizan> danilo2: tbf i'm not sure i understand well enough how you want the code to work
08:17:57 <danilo2> Saizan: excuse me, i do not understand the sentece "it's wrong because we want to provide the context". I simply trying to make "f" working with all datatypes, whcih are instances of F_method1
08:18:12 <danilo2> Saizan: not only X
08:18:48 <pyr> I'm looking for example code that is fed lists from C
08:19:20 <pyr> I know have a pure function that inputs a list of a user defined data type and outputs a list of that data type
08:19:26 <Saizan> danilo2: can you write me the equivalent in e.g. Java?
08:19:30 <pyr> and I'm looking at interacting with it from see
08:20:24 <Saizan> danilo2: so i get an idea of what the class you're trying to encode would look like
08:20:30 <danilo2> Saizan: I havent programmed in Java for ages but I can write you an equivalent ocde in python or C++
08:21:19 <Saizan> danilo2: something typed would be best
08:21:20 <mcstar> i asked before, what are you trying to accomplish with that code too
08:21:45 <danilo2> Saizan: ok wait a second
08:22:00 <mcstar> danilo2: im just curious, could you tell me?
08:22:09 <danilo2> mcstar: I've answered it :) I'm generating this code from my custom language compiler and it shoudl mimic some OO behaviours
08:22:20 <mcstar> sry, i missed it then
08:22:41 <danilo2> mcstar: no problem :) I've probably misstyped your nick and you didnt get notification
08:23:04 <danilo2> In python code, function f would be written as: "def f(x): print (x.method1(1,2)); print (x.method("hello", "world"))
08:23:10 <danilo2> Saizan: ^
08:23:19 <danilo2> Saizan: I'm writing it in pseudo C
08:23:23 <danilo2> Saizan: brb
08:24:19 <Saizan> i'm mostly interested in the type of x
08:24:24 <Vamp> How should I write this mappend correctly? http://lpaste.net/1982616994721038336
08:24:28 <fizruk_> danilo2, oh, is that a continuation on that example? did you get my "fix"?
08:26:15 <Saizan> Vamp: you need backticks: Numerator n1 n2 n3 n4 `mappend` Numerator n1' n2' n3' n4' = ..
08:26:22 <fizruk_> Vamp, not sure, but can you derive a Num and simply write mappend = (+)?
08:26:58 <Vamp> Saizan: You're right, it's infix forgot about that, thanks
08:27:36 <danilo2> fizruk_: which fix? :)
08:28:06 <fizruk_> danilo2, this one: http://lpaste.net/94511
08:28:42 <monoidal> danilo2: ping
08:28:51 <danilo2> Saizan: here is C++ pseudo code: http://lpaste.net/94540
08:29:16 <danilo2> fizruk_: no I havent seen it! thank you!
08:29:20 <monoidal> danilo2: in the GHC trac code you submitted, you are missing scoped type variables
08:29:48 <fizruk_> danilo2, hmm... I sent it yesterday, seemed you were online :)
08:29:51 <danilo2> monoidal: Yes, it was before Saizan explained to me GHC simply cannot infer this types
08:30:25 <danilo2> fizruk_: Ah sorry for that. I probably overlooked it
08:31:04 <Saizan> danilo2: that C++ code typechecks? what does class C have to do with method1 ?
08:31:55 <monoidal> danilo2: is the ticket OK to close?
08:32:17 <mcstar> well, you have to write f somewhere in the code, and its argument type instantiates the template, and it will figure out if that class has method methodl
08:32:22 <monoidal> danilo2: in case it was not spelled explicitly, f :: forall a b. X (a -> b -> (a, b)) -> (a -> b -> (a, b)); f x = method1 x :: a -> b -> (a, b)
08:32:31 <danilo2> monoidal: I think yes. If this behaviour is supposed to be so, thjen of courseyes :)
08:32:45 <_xero_> quick question, does anybody know of a way to access the arguments to a function as a list?
08:33:21 <danilo2> Saizan: "class C" is another form of "typename C" in C++. this is a template function
08:33:29 <mcstar> _xero_: lists are homogeneous, arguments are not (type-wise) so that is not possible, generally
08:33:41 <fizruk_> danilo2, are you discussing now the same problem?
08:33:41 <danilo2> Saizan: It should typecheck - I've updated slighty the code.
08:34:38 <Saizan> danilo2: man, C++ allows some crazy stuff
08:34:53 <Saizan> danilo2: it looks almost untyped to me
08:35:10 <danilo2> fizruk_: I was asking about something connected to the one I was tlaking with you about. I was looking for a way to automatically infer these rank-N-Types. Saizan asked me to write C++ code of waht I'm trying to do in Haskell, so I've written it :)
08:35:32 <Saizan> anyhow fizruk_ seems to have some ideas :)
08:36:05 <danilo2> Saizan, fizruk_ : Right now I'm reading your fix. hank you for it! :)
08:36:09 <mcstar> Saizan: as i said, the code misses a call to f, so yes, that code is really untypes in a sense
08:36:12 <mcstar> it is incomplete
08:36:20 <mcstar> d
08:36:52 <fizruk_> Saizan, this is a slightly modified danilo2's code that does typecheck (and work): http://lpaste.net/94511
08:37:19 <fizruk_> Saizan, I guess he also wants to eliminate those things in lines 22-23
08:38:10 <fizruk_> I think those can be simplified a bit, but not removed
08:38:36 <danilo2> fizruk_: Do you have any idea if is it possible to automatically generate such function signature, as in your fix? I'm talking especially about the return types of functions, because when I'm generating code I can easly tell what are the input parameters of these functions (like Int -> Int) or (String -> String), but I 'll love the output to be infered
08:38:42 <_xero_> mcstar: ah, right... makes sense
08:38:52 <_xero_> mcstar: no luck turning them into a sequence either, I guess?
08:39:43 <danilo2> mcstar: youre right, but it showed the idea
08:39:51 <mcstar> _xero_: if you were tricky you could probably make that work to some extent...
08:41:12 <mcstar> _xero_: what i mean, is write a function that turns its aruments into a list (for a general number for arguments, or the number of arguments provided as a first argument...)
08:41:44 <Saizan> mcstar: it's still pretty ugly that such things get checked at each use site of f rather than at the definition, but i know about C++'s opportunism, i just don't want to be anywhere near it
08:42:05 <mcstar> but i would consider that an exercise in haskell typing, not something for production code
08:42:28 <_xero_> mcstar: I was hoping there was some shortcut, as I thought I could use this as a trick for code golfing :D
08:42:39 <mcstar> Saizan: well, couple years from now, rust will rule the world c++ occupied previously, so all will be good :)
08:42:54 <donri> "couple"
08:44:13 <Saizan> mcstar: afaik rust is not that great either on sane typing, maybe better though
08:44:41 <chrisdone> it takes like 10 years for a language to gain traction
08:44:50 <mcstar> well, it doesnt implicitely cast, it has sane pointers, and has typeclasses...
08:45:13 <fizruk_> danilo2, I don't think so. Consider this micro problem: http://lpaste.net/94542
08:45:57 <mcstar> chrisdone: by that measure haskell should have already gained traction :)
08:46:45 <danilo2> fizruk_: hmmm, ok
08:46:50 <danilo2> fizruk_: Thank you :)
08:47:01 <mcstar> i not sure which point is 'has gained traction' in the language lifetime cycles graph
08:47:04 <donri> mcstar: no, haskell *started* to gain traction only a few years ago :P
08:47:08 <fizruk_> danilo2, this is not straightly equivallent to your problem though
08:47:18 <Iceland_jack> Once we make applicative a superclass of monad, surely Haskell will become mainstream!
08:47:31 <chrisdone> mcstar: no, i mean any language that has traction now took at least ten years
08:47:34 <Vamp> Shouldn't this be correct? http://lpaste.net/8978184843691032576 my observed result gives (1,1) though it should be (0,1) I can't see the test input though
08:47:44 <fizruk_> danilo2, you could try and make class Test m a where ... to get the equivallent case
08:48:15 <danilo2> fizruk_: brb
08:48:22 <chrisdone> mcstar: C++, Java. even Python and Ruby, appeared in the 90's, nobody heard of them until the 2000's
08:48:46 <mcstar> c++ appeared in the 80's afaik
08:49:19 <chrisdone> mcstar: yeah, i didn't say it did
08:49:40 <chrisdone> c++ already had traction in the 90's
08:49:51 <mcstar> chrisdone: but that is not simply a reason of language, it is a reason of application too
08:50:23 <mcstar> the internet revolution probably helped scripting languages spread, didnt it?
08:50:23 <fizruk_> danilo2, like this: http://lpaste.net/94543
08:50:24 <chrisdone> java - 1995, javascript - 1995, ruby -  1995, python - 1991
08:50:55 <mcstar> well, java probably isnt a scripting language...
08:50:59 <Hannibal_Smith> <mcstar> the internet revolution probably helped scripting languages spread, didnt it? <-First scripts were in Perl...so yes
08:51:04 <Connorcpu> The internet definitely helped the scripting languages
08:51:35 <fizruk_> danilo2, this while in first micro problem you can specify the return type and get what you need, the second problem can't be eliminated like that
08:51:36 <chrisdone> mcstar: i'm not sure the language has much to do with it
08:52:16 <chrisdone> mcstar: it seems like a general rule that it takes at least 10 years
08:52:30 <quchen> Maybe we should move the language discussion elsewhere? #haskell-language-discussion for example.
08:52:34 <mcstar> chrisdone: well, if i understand you correctly, you stated that any language needs 10 years to reach some kind of awareness in the population from its creation
08:52:52 * derdon entered cabal hell
08:53:05 <Connorcpu> ah, cabal hell. Lovely place, isn't it? ^.^
08:53:22 <derdon> let's say it's a matter of taste
08:53:22 <chrisdone> mcstar: by traction i include people using it as a legitimate language for business and whathave you
08:53:27 <hpc> better than dell hell
08:53:48 <Connorcpu> I find myself clearing out all my cabal packages every 3-4 weeks >.<
08:53:56 <chrisdone> quchen: so *you're* the reason #haskell activity decreases every year ;)
08:54:00 <Connorcpu> and just reinstalling the ones I 'need'
08:54:01 <donri> Connorcpu: latest cabal does sandboxes
08:54:20 <Connorcpu> ooh, I'll have to look into those then :3
08:54:20 <quchen> chrisdone: I'm not here long enough for that claim to be reasonable :-P
08:54:21 <chrisdone> any time conversation gets going "we don't want any conversation here, please take it to another channel"
08:54:30 <mcstar> anyway, im just arguing, that there are external and internal driving forces for gaining traction.. and im not sure about the 10 years, but if you really looked into it, and it holds, then i accept it
08:54:34 <mcstar> chrisdone: ^
08:54:35 <hpc> chrisdone: it's a tragedy; just a few short years ago we had 900 people, now we have only 1200
08:54:52 <derdon> donri: you mean the cabal I get after infinite calls of "cabal update && cabal install cabal-install"?
08:55:03 <chrisdone> hpc: despite the number of idlers, traffic is going down
08:55:08 <derdon> because every single time I run cabal update, there is a new version of cabal-install
08:55:32 <chrisdone> hpc: http://chart.apis.google.com/chart?chxl=0:|2000|2001|2002|2003|2004|2005|2006|2007|2008|2009|2010|2011|2012|2013&chxt=x,y&chd=t:1,19,30,38,49,69,79,98,100,99,90,74,78,56&chs=450x200&cht=bvs&chbh=a&chxr=0|1,0,1898588.0
08:55:35 <Saizan> derdon: that's a $PATH problem
08:55:52 <danilo2> fizruk_: ok, thank you very very much for all your help! :) I have to mess around with it right now :) thank you once again :)
08:55:53 <donri> derdon: only takes one
08:56:03 <Saizan> derdon: you must have the old cabal-install somewhere that's higher in your $PATH then where the new one gets installed
08:56:06 <chrisdone> mcstar: i haven't looked into it. it's just a hunch
08:56:37 <derdon> ah, I should move .cabal/bin more to the beginning of PATH
08:56:41 <enthropy> chrisdone: maybe you'll see the same trend in other channels? Might be related to the unemployment rate?
08:56:45 <derdon> i.e. before /usr/bin
08:56:50 <donri> derdon: yes
08:56:54 <derdon> thanks
08:57:06 <danilo2> fizruk_: Btw, the last code you';ve pasted does not compile :(
08:57:06 <Saizan> or delete the cabal in /usr/bing
08:57:31 <Vamp> Is there a way to write this Monad instance for Dtree in another way, using a do-notation?  http://lpaste.net/23818801996890112 , because my version doesn't work, though it is type correct
08:57:32 <fizruk_> danilo2, yes that's demonstration of your problem
08:57:57 <danilo2> fizruk_: ok,ok :)
08:57:59 <fizruk_> danilo2, to make it compile you need to prepend "Test m Int =>" to f's type signature
08:58:42 * hackagebot standalone-haddock 1.1.4.1 - Generate standalone haddock documentation for a set of packages  http://hackage.haskell.org/package/standalone-haddock-1.1.4.1 (RomanCheplyaka)
08:58:53 <danilo2> fizruk_: Of course, sorry for that :)
08:59:18 <merijn> Saizan: "/usr/bing", must be Microsoft's version of "locate" ;)
08:59:42 <donri> chrisdone: wasn't RWH being written/released about that time
09:01:48 <merijn> chrisdone: Part of that may be that since the release of RWH and LYAH I've seen a drastic decrease in repeated explanations of boring newbie topics
09:02:48 <mcstar> i just wanted to complain about exactly that ^
09:03:26 <hpc> especially Monad, which LYAH didn't initially have
09:03:38 <mcstar> tragically i havent been around when those questions were still more plentiful
09:03:42 * hackagebot nanomsg 0.1.0 - nanomsg - scalability protocols library  http://hackage.haskell.org/package/nanomsg-0.1.0 (DavidHimmelstrup)
09:05:22 <merijn> mcstar: What's tragic about that?
09:06:22 <derdon> you could have answered questions more often and feel clever
09:06:35 <chrisdone> merijn: it was kinda fun in 2008 with the newbie questions interspersed with prolific lambdabot abuse =p
09:07:01 <merijn> chrisdone: Sure, but I consider it a good sign of the ecosystem maturing that there's books that obsolete these questions
09:07:02 <mcstar> merijn: because i could feel better, since i could remember a times when there were more :)
09:07:09 <mcstar> -s
09:07:37 <chrisdone> merijn: yeah, that's good
09:08:05 <hpc> also wasn't 2008 the height of monad tutorials?
09:08:24 <merijn> hpc: Probably?
09:08:28 <chrisdone> 2008 was the blow up period, i think
09:08:31 <chrisdone> 2007 kicked it off
09:08:43 * hackagebot nanomsg 0.1.1 - nanomsg - scalability protocols library  http://hackage.haskell.org/package/nanomsg-0.1.1 (DavidHimmelstrup)
09:09:01 <Lemmih> nanomsg ftw!
09:09:09 <chrisdone> like http://blip.tv/oreilly-open-source-convention/oscon-2007-simon-peyton-jones-a-taste-of-haskell-part-i-329701
09:11:43 <mcstar> great, my right earphone broke again
09:14:53 <mcstar> when SPJ said strongly typed, i honestly heard 'jolly typed'
09:15:10 <donri> Lemmih: whatcha usin' it for?
09:19:01 <Vamp> Is there a way to get only the leaves of a tree and put these in a list?
09:19:46 <donri> Vamp: what tree type?
09:19:58 <mcstar> fold over a tree with (:)
09:20:08 <Vamp> data DTree a     = Result a     | Decision [DTree a]
09:21:02 <simpson> Does it have a Traversable instance? That'd be the easy way.
09:21:26 <donri> Foldable, surely?
09:22:11 <simpson> Oh yeah, forgot about Foldable.
09:23:52 <mcstar> factoring in, that SPJ is a windows guy, he is doing well with xmonad
09:24:14 <mcstar> (and the rest...)
09:26:10 <jmcarthur> Vamp: put {-# LANGUAGE DeriveFunctor, DeriveFoldable #-} at the top of the file containing the data type definition, import Data.Foldable, add "deriving (Functor, Foldable)" to your type definition, and now you have a toList function available from Data.Foldable
09:26:27 <Lemmih> donri: Will use it in acid-state for state replication.
09:31:41 <madjestic> Vamp yes, you can achieve that by checking if your current tree has children.  If there are no children - then it's a leaf
09:32:06 <madjestic> (in which case you add that to your list)
09:32:25 <JoeyA> Has anyone made a database library in Haskell that generates the data types and accessors by ingesting the schema from the database?
09:32:51 <JoeyA> Rather than defining the schema and having that turned to SQL.
09:33:22 <derdon> fixing $PATH didn't change the behaviour: running cabal update tells me again every time there's a new cabal-install
09:34:21 <visi0n> derdon: you set your path to something alont the lines of PATH=~/.cabal/bin:$PATH
09:34:38 <derdon> visi0n: yes, I did
09:35:10 <mauke> visi0n: that's wrong
09:35:25 <mauke> derdon: what's your PATH set to?
09:36:06 <visi0n> mauke: mine is set to PATH=$HOME/.cabal/bin/:$PATH and I have no problems now
09:36:10 <lpaste> derdon pasted “.zshenv” at http://lpaste.net/94544
09:36:25 <derdon> this is my .zshenv where PATH is defined and exported
09:36:27 <mauke> visi0n: correct
09:37:36 <mauke> derdon: what does '~/.cabal/bin/cabal --version' say?
09:38:14 <derdon> cabal-install version 1.18.0.2
09:38:14 <derdon> using version 1.18.1.1 of the Cabal library
09:38:27 <mauke> derdon: what does 'type -a cabal' say?
09:38:45 <donri> Lemmih: cool, that's what i was thinking of :)
09:38:45 <madjestic> Vamp: also, you could take a look at some standard libraries, dedicated to tree data structures - they contain some good examples of standard functions for such structures, including flattening trees and counting leaves
09:39:07 <derdon> mauke: cabal is /home/derdon/.cabal/bin/cabal
09:39:08 <derdon> cabal is /usr/bin/cabal
09:39:12 <zielwasserjunki> Does anybody know theres a ghci command for getting the associativity and preference of an operator?
09:39:30 <quchen> :i
09:39:31 <zielwasserjunki> *if theres a
09:39:40 <madjestic> Vamp: e.g. Data.Tree
09:39:47 <quchen> :i will tell you about its fixity zielwasserjunki
09:39:54 <zielwasserjunki> Thank you very much quchen!!
09:40:15 <donri> Lemmih: although i'm vaguely wondering if the network-transport package couldn't be utilized in some way...
09:41:03 <Vamp> madjestic: I see, I made a function earlier that counts the leaves in a rose tree, but don't think I can use that one here now
09:45:19 <madjestic> you should be able to adjust it or create a similar function, unless your tree's specific data structure somehow forbids that, but why would tha be the case?
09:45:25 <mauke> derdon: I can't reproduce the problem. I also have 1.18.0.2, and it doesn't say anything about a newer version when I 'cabal update'
09:45:46 <mauke> I did have the PATH issue, though :-)
09:45:47 <derdon> mauke: hm, that's bad :(
09:46:39 <madjestic> Vamp: besides, your tree type signature does look alot like a Rose Tree
09:46:48 <mauke> derdon: http://paste.scsys.co.uk/272626
09:48:57 <derdon> mauke: I'd like to reproduce that :/
09:50:52 <visi0n> derdon: does it work if you run ~/.cabal/bin/cabal update
09:52:01 <visi0n> derdon: if everything works with an absolute path then you know for sure it's just something weird with your PATH variable
09:52:57 <merijn> zielwasserjunki: btw, if :i doesn't print the fixity, that means it's the default (i.e. infixl 9)
09:53:26 <derdon> visi0n: that was a good idea! it works with an absolute path, so it really must be some $PATH issue I can't understand
09:53:53 <visi0n> derdon: run `echo $PATH` and see what that spits out
09:53:54 <merijn> zielwasserjunki: And relatedly you can specify fixity for infix use of prefix functions too (i.e. when you do "1 `elem` [1..10]" you can specify fixity for `elem`)
09:53:54 <derdon> because if I print the value of $PATH, it is as expected and as it should be
09:54:05 <derdon> visi0n: already did. I paste it now
09:54:11 <merijn> derdon: Which shell?
09:54:21 <derdon> zsh
09:54:38 <lpaste> derdon pasted “No title” at http://lpaste.net/94545
09:55:38 <mauke> this confuses me
09:55:53 <mauke> 'type' should tell you exactly what a command means to the shell
09:56:45 <Vamp> madjestic: I think this should count the leaves then http://lpaste.net/3456547194004307968
09:56:52 <derdon> you're not the only one who's confused, mauke
09:57:34 <visi0n> derdon: which executable does `which cabal` give you
09:58:02 <derdon> it gives me /usr/bin/cabal?! whaaaaat
09:58:11 <zielwasserjunki> merijn, do infix and infixl mean the same?
09:58:13 <derdon> I don't understand anything at all now
09:58:40 <visi0n> derdon: hah some something's off with the path, not sure what yet though
09:58:58 <derdon> it totally contradicts the value of $PATH
09:59:09 <mauke> derdon: what does 'which type' say?
09:59:15 <monochrom> exit this shell, start a new shell, try again
10:00:15 <geekosaur> hash -r
10:00:23 <merijn> zielwasserjunki: I think infix means it doesn't specify an associativity
10:00:31 <derdon> monochrom: thank you. now that's embarrassing
10:00:44 <derdon> I did it so often that I forgot to start a new shell again
10:01:11 <visi0n> derdon: so it works?
10:01:20 <geekosaur> you don't need to start a new shell; hash -r
10:01:23 <derdon> yes, I think so
10:01:32 <visi0n> geekosaur: hash -r is new to me. Thanks!
10:01:45 <derdon> gonna install some packages with the real cabal now
10:02:49 <stephenmac7> How do I read the result of getLine?
10:02:56 <derdon> but it's weird anyway that the value I got with printing $PATH is not the actual value of $PATH apparently
10:03:12 <derdon> stephenmac7: take it out of the box ;)
10:03:23 <stephenmac7> ... in a better way than this: a <- getLine; let r = read a
10:03:30 <mauke> stephenmac7: readLn
10:03:36 <stephenmac7> :t readLn
10:03:37 <lambdabot> Read a => IO a
10:03:46 <merijn> If I have a record with one field that I don't want users to set, is there a way to accomplish that or should I just make a nested structure (i.e. wrap the user supplied bits with another record that has the non-settable field)?
10:03:52 <zielwasserjunki> merijn, i just tried to evaluate an expression like 1 +++ 2 *** 3 where +++ has infixl 1 and *** has infix 1, unfortunately it doesnt work
10:03:52 <qzr> Quick question: I'm trying to do Haskell bindings for Transmission RPC (Torrent client). The communication is over JSON RPC. I began encoding all the different rpc methods & arguments into haskell types. Some subset here: http://lpaste.net/94546. Does somebody know a way to translate all these time into json strings like "set-torrent" that's "least boilerplatey"?
10:04:36 <stephenmac7> mauke: Thanks
10:04:49 <merijn> qzr: Maybe TH?
10:05:49 <donri> or even Generic
10:05:50 <kenkku> are the time functions (like getCurrentTime) strict by default?
10:06:13 <mauke> :t getCurrentTime
10:06:14 <lambdabot> Not in scope: `getCurrentTime'
10:06:18 <donri> kenkku: they're in IO so yes, unless unsafeInterleaveIO which i highly doubt
10:06:18 <merijn> kenkku: getCurrentTime is not a function
10:06:29 <mauke> donri: wat
10:06:43 <donri> mauke: ?
10:06:52 <merijn> Also, what do you mean by strict in this context?
10:06:54 <mauke> donri: how can it be strict if it's not a function?
10:06:56 <kenkku> merijn: oh, mind telling me what it is then?
10:06:57 <qzr> merijn: Ok I'll have a look at it. thanks
10:07:09 <donri> mauke: it can be strict in the sense of not using lazy IO
10:07:12 <merijn> kenkku: It's an IO action
10:07:20 <mauke> o_O
10:07:30 <merijn> kenkku: "getCurrentTime :: IO UTCTime"
10:07:54 <zielwasserjunki> So does "infix" represent a third fixity type, with no extra information about evaluation order?
10:07:58 <kenkku> well, your approach is not very helpful for teaching
10:08:01 <kenkku> I can tell you that
10:08:21 <mauke> kenkku: your approach is not very helpful for learning
10:08:26 <mauke> I can tell you that
10:08:36 <merijn> kenkku: Might wanna read this (unfinished) explanation of IO: https://gist.github.com/merijn/6478573
10:08:55 <kenkku> that's what I was hoping for
10:09:07 <kenkku> much better, thanks
10:09:23 <merijn> Which may also clarify why the question "is getCurrentTime strict?" is a hard question to answer, unless you specify what exactly you mean by strict
10:09:39 <kenkku> probably because I don't understand enough yet
10:09:51 <kenkku> I thought that was obvious
10:09:52 <kenkku> :P
10:10:05 <skypers> hey
10:10:09 <mauke> a function is strict if it returns _|_ when applied to _|_
10:10:10 <skypers> I have some .hsc files
10:10:13 <enthropy> zielwasserjunki: yes, you aren't supposed to mix infix and infixl/infixr
10:10:19 <enthropy> when they are at the same level
10:10:21 <skypers> how to tell cabal to run hsc2hs on them?
10:10:38 <mauke> skypers: doesn't it do that automatically?
10:10:44 <enthropy> skypers: just list the module name as usual
10:10:45 <skypers> nope, cabal build fails
10:10:49 <dcoutts_> skypers: nothing special, just make sure you list all the modules
10:10:50 <skypers> ah
10:10:51 <mauke> skypers: fails how?
10:10:58 <skypers> in the exposed modules
10:11:03 <skypers> I’ve put the .hsc
10:11:09 <skypers> should I use the .hs instead?
10:11:12 <mauke> no
10:11:13 <dcoutts_> skypers: all modules must be listed in exposed-modules or other-modules
10:11:18 <mauke> you should use the module names
10:11:28 <monochrom> I thought you write neither .hsc nor .hs
10:11:32 <Vamp> I know have a function that puts all nodes of my dtree in a list, but how should I extract the leaves from this version?
10:11:39 <skypers> mauke: yeah that’s what I do
10:11:42 <lpaste> donri pasted “mauke, kenkku” at http://lpaste.net/94547
10:11:51 <skypers> the error is it fails to find the module
10:11:54 <dcoutts_> skypers: right, exposed-modules and other-modules are for the *module* names, not file names
10:12:02 <skypers> yeah I know
10:12:15 <mauke> skypers: what's the actual error message?
10:12:15 <skypers> here it is
10:12:16 <skypers> https://github.com/skypers/hsFModEx/blob/master/FModEx.cabal
10:12:23 <skypers>     Could not find module `FModEx.Types'
10:12:23 <skypers>     Use -v to see a list of the files searched for.
10:12:24 <monochrom> ok, time to show your actual .cabal file plus ls -R
10:12:47 <kenkku> yeah I understand now, obviously you need to execute the io action to <- the time out of it
10:13:04 <dcoutts_> skypers: your .cabal file does not list FModEx.Types
10:13:08 <skypers> monochrom: http://lpaste.net/661353040061661184
10:13:11 <Vamp> Here is that function btw: http://lpaste.net/7050800797684072448
10:13:17 <donri> kenkku: see my paste; getCurrentTime is "strict"
10:13:18 <mauke> skypers: module Sound.FModEx.Types where
10:13:24 <skypers> oh
10:13:25 <skypers> shit
10:13:30 <skypers> I forgot to update the module names
10:13:35 <skypers> I added the Sound. prefix
10:13:36 <skypers> :D
10:13:43 <skypers> I’m an idiot.
10:13:43 <dcoutts_> np :-)
10:13:47 <skypers> thank you
10:13:53 <dcoutts_> we all do that kind of thing sometimes :-)
10:14:04 <monochrom> see how much is accomplished by showing actual code
10:14:17 <skypers> huh
10:14:19 <skypers> actually
10:14:20 <monochrom> and how little by talking intuitively
10:14:24 <skypers> I already did
10:14:25 <kenkku> donri: okay, thanks. would make sense, since if you want the current time, you usually want... well, the CURRENT time :P
10:14:27 <skypers> so hm
10:14:30 <skypers> still an issue
10:14:34 <donri> kenkku: quite
10:14:44 <stephenmac7> Any better way to do this?
10:14:44 <stephenmac7> 2 -> multiPlayerMatch >>= (\x -> main)
10:14:57 <stephenmac7> Er... multiPlayerMatch >>= (\x -> main)
10:15:03 <skypers> yeah got it
10:15:08 <skypers> it’s in an import statement
10:15:12 <mauke> skypers: https://github.com/skypers/hsFModEx/blob/master/Sound/FModEx/Functions.hsc#L21
10:15:41 <skypers> yeah
10:15:45 <skypers> and FModEx.hs as well
10:15:47 <skypers> fixed
10:15:50 <skypers> and built
10:15:51 <skypers> :)
10:15:53 <nstdloop> Dumb question, how do I specify that both a and b have to be part of Ord in a type signature?
10:16:05 <skypers> (Ord a, Ord b) => a -> b
10:16:09 <nstdloop> thanks
10:16:11 <skypers> np
10:16:28 <ReinH> Guess who has two thumbs and just recorded a Haskell Cast episode
10:16:34 <skypers> some people tend to omit parenthesis sometimes
10:16:40 <skypers> I do not advise such a way to do
10:16:57 <skypers> (Ord a) => a -> ()
10:17:01 <donri> ReinH: nice! when's it out?
10:17:02 <klugez> ReinH: How soon can we listen to it?
10:17:06 <skypers> it’s clearer to read i
10:17:08 <skypers> imho*
10:17:10 <ReinH> As soon as I can edit it
10:17:14 <ReinH> This week, definitely
10:17:31 <ReinH> I also managed to shut up more this time
10:17:37 <ReinH> So that's good
10:17:49 <donri> ReinH: this week eh, meaning today? :) (it's sunday!)
10:18:01 <ReinH> donri: fine. Next week.
10:18:11 <ReinH> :p
10:18:12 <monochrom> no, meaning the coming Saturday
10:18:26 <zielwasserjunki> merijn, seems like infix operators (not infixr, nor infixl ones) dont have any associativity
10:18:30 <donri> ReinH: ;)
10:18:32 <zielwasserjunki> @r 1 == 1 == True
10:18:32 <lambdabot> Maybe you meant: rc reconnect remember repoint roll run v @ ? .
10:18:32 <Vamp> I changed http://lpaste.net/7050800797684072448 (counting nodes) into http://lpaste.net/4484201497772425216 (counting leaves) , is the counting leaves function correct?
10:19:25 <jmcarthur> Vamp: by "counting" you mean "collecting"?
10:19:40 <Vamp> jmcarthur: Ah yes sorry, extracting indeed
10:19:40 <zielwasserjunki> > 1 == 2 == True
10:19:41 <lambdabot>   Precedence parsing error
10:19:41 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
10:20:30 <jmcarthur> Vamp: i don't see a difference between those two functions
10:21:18 <skypers> ok, gonna try my fmodex lib :)
10:21:19 <Vamp> jmcarthur: Hmm yeah I'm trying to extract the leaves only, extracting the nodes works now
10:21:31 <jmcarthur> Vamp: what does it mean to extract the nodes?
10:21:51 <Vamp> jmcarthur: Put all the nodes of a tree into a list
10:22:06 <jmcarthur> Vamp: so what type do you expect such a function to have?
10:22:20 <skypers> how do we pass ghc args in .cabal?
10:22:23 <skypers> ghc-opts
10:22:26 <skypers> or something like that?
10:22:30 <Vamp> jmcarthur: myTree a -> [a]
10:22:44 <monochrom> zielwasserjunki: it's (1 == 2) == True
10:22:45 <jmcarthur> Vamp: is [a] really a list of nodes? it looks like a list of leaves to me
10:23:01 <jmcarthur> Vamp: i would expect a list of nodes to have type [Tree a]
10:23:16 <Vamp> jmcarthur: Hmm, then that would be okay for me because I actually only need the leaves
10:23:22 <ReinH> Inner nodes don't have values
10:23:40 <ReinH> So that necessarily accumulates the values from just the leaves
10:23:53 * hackagebot pipes-websockets 0.0.0.0 - Library for using websockets ontop of pipes-network.  http://hackage.haskell.org/package/pipes-websockets-0.0.0.0 (ParnellSpringmeyer)
10:24:07 <Vamp> ReinH: Aha I see
10:24:34 <ReinH> The only values to be had are in the leaves
10:24:43 <ReinH> as branches do not contain values
10:24:52 <skypers> no one knows?
10:24:52 <Vamp> ReinH: You are right yeah
10:25:01 <ReinH> (they just contain a forest)
10:25:17 <skypers> ghc-options maybe
10:25:50 <stephenmac7> I have these lines in my code:
10:25:51 <stephenmac7> data Piece = X | O deriving (Show, Eq)
10:25:51 <stephenmac7> type Row = [Piece, Piece, Piece]
10:25:51 <stephenmac7> type Board = [Row, Row, Row]
10:26:06 <stephenmac7> However, it says it's an illegal type
10:26:15 <dwcook> [a, b, c] isn't a type
10:26:22 <dwcook> Maybe you mean (Piece, Piece, Piece)
10:26:27 <stephenmac7> Ah
10:26:52 <stephenmac7> Thanks
10:27:05 <monochrom> skypers: have you seen the cabal user guide? http://www.haskell.org/cabal/users-guide/
10:28:05 <ReinH> stephenmac7: I would probably use type Row = [Piece]; type Board = [Row]
10:28:13 <derdon> now I cannot install uniplate: http://lpaste.net/94548 :(
10:28:20 <stephenmac7> ReinH: Ah, I thought about doing that
10:28:21 <stephenmac7> Thanks
10:28:35 <skypers> monochrom: yeah found what I was looking for
10:28:36 <ReinH> stephenmac7: then you get a useful functor, etc
10:28:38 <skypers> extra-libraries :)
10:28:47 <stephenmac7> Thank you :)
10:28:55 <skypers> btw, if I have a C function that takes a pointer and fills it with whatever
10:29:08 <skypers> if the pointer points to an opaque structure
10:29:16 <skypers> how should I write the Storable instance?
10:29:28 <skypers> (I use hsc2hc)
10:30:04 <stephenmac7> One thing I don't like about GHC: The error messages are terrible
10:30:35 <monochrom> I agree
10:30:51 <derdon> LaTeX is also good at bad error messages :)
10:31:07 <haasn> It gets even more confusing when you start enabling the cool extensions
10:31:23 <haasn> because then stephenmac7's code compiles, but you get kind-mismatches once you start using it
10:31:56 <stephenmac7> haasn: Which is why it's probably not a good idea to use the "cool extensions"
10:32:11 <monochrom> use hot extensions instead
10:32:21 * geekosaur recently ranted to a coworker that he gets better error messages from ghc than for certain typoes in git...
10:32:29 <haasn> I'll admit, it's a good argument against having RankN/DataKinds/PolyKinds etc. by default
10:32:53 <skypers>     No instance for (Storable FModSystem) arising from a use of `with'
10:32:55 <skypers> dammit…
10:33:02 <skypers> I have no idea how to write the instance
10:37:02 <skypers> can I write something like
10:37:12 <skypers> sizeOf _ = #type C_TYPE
10:37:12 <skypers> ?
10:37:18 <skypers> or do I need that instead:
10:37:24 <skypers> sizeOf _ = #{type C_TYPE}
10:37:25 <skypers> ?
10:37:35 <skypers> I’m not sure about the syntax yet
10:37:43 <skypers> I’m quite new into the FFI world :)
10:37:52 <skypers> #size
10:37:53 <skypers> btw
10:37:55 <skypers> not #type
10:39:20 <merijn> If I have a record with one field that I don't want users to set, is there a way to accomplish that or should I just make a nested structure (i.e. wrap the user supplied bits with another record that has the non-settable field)?
10:40:26 <elliott> just write an accessor function and export that
10:41:50 <merijn> elliott: How does that stop them from setting said field?
10:42:12 <elliott> because you don't export the field/constructor
10:42:19 <merijn> Ah, that works?
10:42:39 <merijn> They don't even need to read the field, if they're unaware of it's existence, that'd be fine.
10:42:46 <rofer> I'm writing a program which accepts socket connections and I'd like it to exit cleanly when I sent it ctrl-c. That is, I want it to stop accepting connections, finish processing any existing ones, and then exit, but I'm having some trouble doing this. Specifically, how to properly deal with connections that are partially accepted.
10:43:04 <cschneid> is there a shorter way to write this: keysOfLength n = map LBS.concat $ replicateM n allHexBytes  --- basically replicateM uses list monad to find all combos, then I have to map concat over it. Is there a one-func version of that?
10:43:16 <cinimod`> I have a simple counting program which reads a CSV file with cassava and counts the number of rows: with -O2 it runs in 6M(!) but without -O2 it leaks badly
10:43:34 <merijn> rofer: Can you be more specific about what "some trouble" means?
10:43:39 <skypers> hey seriously folks, how to write the alignment method for a Storable opaque C structure? :(
10:44:26 <merijn> skypers: If you have a simple C struct you could use johnw's lovely c2hsc to autogenerate the Storable code for you :)
10:44:39 <donri> merijn: i don't think not exporting the field is enough, you have to hide the constructor too
10:45:03 <donri> and not derive Read, etc etc
10:45:07 <MitchellSalad> Fay question, is it possible to change the names of haskell records that get compiled to javascript objects? say a callback in a library function expects an object with an "options" field -- is it possible to create a record like Foo { fooOptions :: Options } and have "fooOptions" become "options" in JS?
10:45:18 <skypers> merijn: woh
10:45:19 <merijn> Ah, but then it'd be impossible for users to create values of the type without some special function to create it
10:45:21 <skypers> how does it work?
10:45:30 <merijn> Which would rather ruin the purpose of this record
10:45:40 <merijn> skypers: It parses C and generates haskell code for the parsed C
10:46:15 <donri> merijn: you still get record update syntax for fields in scope
10:46:17 <skypers> merijn: ok, that’s nice
10:46:19 <skypers> but I said
10:46:19 <rofer> merijn: Right now I have a function running in it's thread that's accepting connections and putting them into an MVar where another thread grabs them and then starts processing them. When I recieve a signal to shutdown right now the best thing I can think to do is kill the accepting thread, but I'm worried that might cause problems is accept is in the middle of accepting a connection (or has accepted it, but
10:46:21 <rofer> hasn't put it in the MVar yet)
10:46:24 <skypers> it’s an opaque struct
10:46:29 <merijn> donri: Except the fields are write-once anyway
10:46:30 <skypers> the only line of C it parsed will be
10:46:44 <skypers> typedef struct ShitStruct;
10:46:52 <skypers> or something like that
10:46:57 <merijn> donri: I just need a convenient way to pass a set of input parameters to a function with some nice things like defaults, etc.
10:47:24 <merijn> rofer: Ah, take a look at things like bracket in Control.Exception
10:47:40 <rofer> merijn: Thanks, will do
10:47:52 <donri> merijn: well either this (records with hidden constructor and some hidden fields) or something like the Endo monoid is an alternative
10:48:12 <merijn> donri: Right, then I think just passing 6 arguments would be better
10:48:18 <donri> :)
10:48:31 <merijn> That or the nested structure thing
10:48:43 <donri> merijn: you can construct a partial record and update it with record notation
10:49:47 <merijn> donri: Yeah, but I actually wanted to set the hidden field later (specifically, I want a record for ZMQ socket settings and need to later add the socket type)
10:50:14 <donri> merijn: use Maybe? :P
10:50:33 <merijn> donri: So maybe nesting is just easier, having like "data Settings = Settings { type :: SockType, config :: SocketSettings }" and only expose the SocketSettings
10:50:46 <merijn> donri: How does that stop people from setting anything?
10:50:48 <donri> sure, that's probably the best option
10:50:54 <skypers> merijn: so, without anything else than a forward declarion
10:51:08 <skypers> do you agree I can’t write the alignment function?
10:51:12 <skypers> or I set it to 0?
10:51:25 <skypers> yeah it doesn’t make any sense
10:51:27 <donri> merijn: i meant for the hidden field, to track whether you set it already. but nested types give you that information statically
10:51:32 <merijn> skypers: oh, you don't have the type of the struct?
10:51:45 <merijn> skypers: Then you can only work with pointers to it anyway, so why bother with Storable?
10:52:15 <merijn> skypers: You only need Storable to manipulate structs from Haskell
10:52:21 <skypers> merijn: well
10:52:28 <merijn> skypers: i.e. change the value of a field from inside Haskell
10:52:29 <skypers> I can’t alloca anything then?
10:52:48 <merijn> skypers: You can't malloc a struct of unknown size in C either
10:52:53 <skypers> I have function in C that takes a pointer on that struct
10:52:56 <skypers> modifies it
10:53:03 <skypers> and returns void (then nothing actually)
10:53:12 <skypers> yeah so in C
10:53:15 <skypers> I
10:53:17 <skypers> hm
10:53:20 <skypers> I think I got it
10:53:21 <skypers> :D
10:53:38 <skypers> so I just use Ptr What?
10:53:46 <skypers> data Opaque = Opaque
10:53:49 <skypers> this is what I have
10:53:52 <skypers> so Ptr Opaque?
10:54:42 <Vamp> http://lpaste.net/5778623813797281792 hmm can someone see what's wrong with my modify function?
10:55:39 <merijn> skypers: I usually use "Ptr ()" for void pointers
10:55:48 <skypers> yeah
10:55:55 <skypers> but here it’s not void
10:55:58 <skypers> it’s typed
10:56:04 <skypers> well
10:56:07 <skypers> I can simply do
10:56:15 <skypers> let p = nullPtr :: Ptr TheCStruct
10:56:21 <skypers> and pass it to the function?
10:56:30 <skypers> that sounds suscpicious
10:56:43 <merijn> Vamp: What makes you think there's anything wrong with it?
10:59:07 <Vamp> merijn: My result compared to what it should be : observed result is (1,1) and expected result is (0,1) (Can't see the test input though)
10:59:26 <MitchellSalad> Vamp: shouldn't it be m () ?
10:59:38 <MitchellSalad> get >>= put . f
11:03:22 <Vamp> MitchellSalad: modify :: (s -> s) -> m s should be the type
11:03:52 <merijn> Vamp: oh
11:04:01 <supki_> Vamp: perhaps modify should return modified state?
11:04:07 * hackagebot nettle 0.1.0 - safe nettle binding  http://hackage.haskell.org/package/nettle-0.1.0 (stbuehler)
11:04:08 <merijn> Vamp: You're returning the old s, instead of the new one
11:09:23 <Vamp> merijn:     modify :: (s -> s) -> m s     modify f = do          s <- get          return (f s) like that
11:09:42 <merijn> Vamp: That doesn't replace the old state
11:11:55 <Vamp> Hmm
11:21:34 <merijn> argh
11:21:48 <merijn> I hate the lack of recursive imports with a fiery passion :(
11:23:24 <blorbab> i'm trying to use a maybe monad, instead of doing cases on the value, but i'm finding that eventually i'll have to escape from the monadic context because caller-functions don't want it there...
11:24:17 <blorbab> how does one "unwrap" a monad when it's use is served? it seems you have to write precisely the code which the monad was preventing you from writing (for me, that means "case x of Just..... or Nothing ... etc)
11:24:32 <merijn> blorbab: fromMaybe/maybe or case-of
11:24:54 <merijn> blorbab: You can't "unwrap" a monad in general, but you can unwrap Maybe
11:25:05 <merijn> :t fromMaybe
11:25:05 <lambdabot> a -> Maybe a -> a
11:25:09 <merijn> :t maybe
11:25:10 <lambdabot> b -> (a -> b) -> Maybe a -> b
11:25:28 <blorbab> merijn: ah, ok...
11:25:33 <blorbab> merijn: thanks!
11:25:56 <meow45> How do I catch error and undefined?
11:26:25 <merijn> blorbab: For some examples, you can unwrap lists (list monad) or tuples (tuple monad), but not IO and things like State/Writer have special "run" functions to unwrap them
11:26:35 <Vamp> Hmm return put (f s)  doesn't work either
11:26:55 <merijn> Vamp: "let s' = f s; put s'; return s'"
11:27:43 <blorbab> merijn: yeah, i've gotten the hang of IO and i understand the State/Writer monads use their newtype accessor function ... i guess maybe/either are special
11:28:15 <Vamp> merijn: Ah that works, ty
11:28:34 <merijn> blorbab: Not really, special as much as their just ordinary ADTs
11:29:02 <blorbab> merijn: i mean, their use case is a little different
11:29:24 <merijn> blorbab: The Maybe monad is not so much because pattern matching using case is bad, it's just that repetitive pattern matching results in a bunch of deeply nested case-of that march to the right of the screen
11:29:35 <merijn> I accidentally a few words
11:30:12 <blorbab> merijn: that makes sense.. so the Maybe monad lets you write those pattern matching bits just once..
11:30:14 <blorbab> thanks!
11:30:16 <merijn> blorbab: There's nothing inherently bad about using case of Just/Nothing. It's just that if you have 10 in a row, the monad syntax is more convenient than repeatedly matching.
11:31:14 <supki_> meow45: they both throw ErrorCall exception, so you catch that
11:35:18 <blorbab> whats the haskell-way to wrap a computation with a "set up" and "tear down" operation, similarly to python's "with"
11:35:48 <blorbab> is that just a monad?
11:36:14 <supki_> blorbab: Control.Exception.bracket
11:36:15 <zomg> blorbab: `bracket` iirc
11:36:20 <geekosaur> it can be, yes. see for example Control.Exception.bracket
11:36:22 <geekosaur> heh
11:37:15 <blorbab> supki_ zomg geekosaur : bracket is in the IO monad..? i'm writing pure code.
11:37:48 <geekosaur> pure code doesn't normally have a need for bracketing?
11:38:00 <geekosaur> what are you actually doing?
11:38:03 <blorbab> geekosaur: true, but i'm looking to avoid writing a pater if it exists
11:38:19 <meow45> supki_: Thanks!
11:38:22 <blorbab> geekosaur: i'm applying a matrix to a 3d mesh, and then applying its inverse later
11:38:56 <blorbab> geekosaur: just wondering if there was a pattern for this sort of before-after thing
11:39:04 <geekosaur> if it's pure, it's just composition
11:39:15 <blorbab> geekosaur: ah, yeah
11:39:16 <geekosaur> unF . process . doF
11:39:46 <geekosaur> you could wrap it, but it's simple enough to generally not be wrth wasting a combinator on
11:39:51 <blorbab> geekosaur: i totally did this earlier ... and yesterday
11:39:56 <blorbab> geekosaur: thanks for reminding me!
11:42:27 <DanielDiaz> I am trying to write my first C bindings, and I get syntax errors from the C code. I think the code should be correct. Is it possible that I am doing something wrong?
11:43:22 <klugez> blorbab: In IO you make your own withWhatever using bracket. withWhatever = bracket setup teardown. So there's no with statement, but it's easy to make your own. :)
11:52:39 <blorbab> how would one use a non-monadic function with a maybe? .. is there some way to string a maybe through a non-monadic function?
11:52:48 <blorbab> is that called lifting?
11:55:26 <Apocalisp> .map
11:55:43 <klugez> > fmap (+1) (Just 1)
11:55:45 <lambdabot>   Just 2
11:55:54 <klugez> You mean like that?
11:55:59 <Apocalisp> yeah sorry, fmap
11:56:26 <lpaste> bitemyapp pasted “No title” at http://lpaste.net/94550
11:56:35 <bitemyapp> still looking for a better way to do this
11:56:45 <thebnq> just see what Maybe is an instance of :3
11:56:49 <bitemyapp> in another language I might've just made a map with keys that are sets and values that are functions
11:57:17 <blorbab> klugez: Apocalisp: oh yeah..
12:00:57 <Vamp> What's wrong with return x = State' (\s -> (x,s)) given newtype State' s a = State' { runState' :: (s, Counts) -> (a, s, Counts) }
12:01:28 <Iceland_jack> Vamp: Well, it takes a tuple and returns a tripple?
12:01:52 <Iceland_jack> In your example it takes a tuple and returns a tuple whose second value is a tuple
12:02:05 <Vamp> I tried to remove the inner tuple, but then the lambda didn't work
12:02:13 <Iceland_jack> What inner tuple?
12:02:26 <Iceland_jack> Why not: (\(state, count) -> (x, state, count))
12:04:00 <Vamp> Hmm that's idd better yes
12:05:56 <skypers> hm
12:07:11 <skypers> I have a C function that takes a pointer on a pointer, dereferences it in order to fill some memory, then I need to use that pointer in other functions
12:07:14 <skypers> how should I do that?
12:07:22 <skypers> cFunction ptr
12:07:32 <skypers> let ptr = nullPtr :: Ptr (Ptr OpaqueStruct)
12:07:34 <skypers> if I do that
12:07:36 <skypers> of course
12:07:40 <skypers> after cFunction
12:07:45 <skypers> I still get a nullPtr
12:07:49 <skypers> so what should I use?
12:08:25 <skypers> with nullPtr $ \ptr -> cFunction ptr >> return ptr
12:08:26 <skypers> ?
12:08:55 <benmachine> yes that sounds about right
12:09:05 <benmachine> although it's been a while since I did that sort of stuff
12:09:23 <chrisdotcode_> hello everyone :)
12:13:19 <unequation> what's your preferred editor for Haskell?
12:13:31 <unequation> is emacs really worth the pain?
12:14:19 <nstdloop> I keep getting type errors on this
12:14:22 <nstdloop> and I'm not sure why
12:14:23 <nstdloop> rating n = (depth (ctree [1 .. n])) / (logBase 2 n)
12:14:29 <nstdloop> depth just gets the max depth of a tree
12:14:35 <nstdloop> ctree makes a binary tree out of a list
12:14:40 <intrados> I'm using tables which is based on lens. Is there a lensier way to do: select t = map (\x -> (x^.a, x^.b)) (t ^.. folded)
12:14:46 <scshunt> nstdloop: what error?
12:15:03 <nstdloop> No instance for 'Floating Int' arising from use of /
12:15:13 <simpson> :t div
12:15:13 <lambdabot> Integral a => a -> a -> a
12:15:20 <simpson> ^^ You probably wanted this.
12:15:29 <intrados> Maybe one that's Table a -> Table b rather than Table c -> [(a, b)]
12:16:01 <nstdloop> simpson: nope, same error.
12:16:34 <nstdloop> If I divide an int by a float, shouldn't I just get a float?
12:17:05 <spaceships> nstdloop: no you need to call fromIntegral on the int
12:18:32 <lpaste> chrisdone pasted “shm-ast-documentation lulz” at http://lpaste.net/94551
12:19:12 <kuznero> Hi All!
12:19:19 <chrisdotcode_> kuznero: hello
12:19:24 <lpaste> kuznero pasted “How to run in context of my state” at http://lpaste.net/94552
12:19:31 <nstdloop> Ok. Got it
12:19:35 <nstdloop> thanks
12:19:39 <kuznero> Sorry for a lame question, but please help!
12:20:27 <kuznero> liftIO(s) are all ugly, but meanwhile I just need to understand how to be able to run in a different context...
12:20:35 <benmachine> kuznero: what's OAuthApp?
12:20:40 <kuznero> Sec
12:20:55 <elifrey> nstdloop: too see why this is, try writing a typeclass for Num without this forcing (+) to expect the same type on both sides.
12:20:56 <kuznero> type OAuthApp a = StateT Application IO a
12:21:06 <benmachine> kuznero: aha
12:21:50 <nstdloop> elifrey: hmm...
12:22:02 <benmachine> kuznero: runStateT onAuthButtonClick :: Application -> IO ((), Application)
12:22:31 <kuznero> benmachine: so, I just need to unwrap it into just IO, right?
12:22:37 <benmachine> kuznero: this is a little tricky. I'm guessing onClicked lets onAuthButtonClick potentially run later in the program, asynchronously, right?
12:23:30 <kuznero> benmachine: not sure about that, but that is like: onClicked :: ButtonClass b => b -> IO () -> IO (ConnectId b)
12:23:52 <benmachine> kuznero: right, so, the problem is that onAuthButtonClick might change the state
12:24:02 <kuznero> benmachine: but I will guess it is synchronous, not async
12:24:20 <kuznero> benmachine: yes, in fact it does
12:24:35 <benmachine> kuznero: right, so the question is when does it change it with respect to the other state changes in the program
12:25:30 <kuznero> benmachine: that is generally the very first step - authorizing on OAuth auth server
12:25:37 <benmachine> kuznero: was it your decision to use StateT s IO?
12:25:45 <benmachine> or is that some library you're using?
12:26:23 <kuznero> benmachine: yes, this was my decision. But this is a subject for change, since I consider myself novice in Haskell
12:27:07 <benmachine> kuznero: the thing about StateT s IO is that StateT sort of adds a changeable state to whatever you're doing at the time, but IO already has mutable state
12:27:19 <benmachine> kuznero: so I tend not to bother with StateT over IO personally
12:27:25 <benmachine> you might as well just use IORefs
12:27:49 <donri> well StateT is immutable state
12:28:06 <benmachine> donri: it amounts to the same thing in practice
12:28:37 <donri> can you have data races with StateT?
12:28:50 <benmachine> I don't think so
12:28:55 <donri> deadlocks? :)
12:28:57 <benmachine> but you can't have them with IO unless you use concurrency
12:29:08 <kuznero> benmachine: ... and IORefs will give me advantage in controlling when should things be changed?
12:29:21 <benmachine> and the reason why StateT doesn't have problems with concurrency is because it doesn't handle concurrency at all :P
12:29:25 * hackagebot laborantin-hs 0.1.1.0 - an experiment management framework  http://hackage.haskell.org/package/laborantin-hs-0.1.1.0 (LucasDiCioccio)
12:29:27 * hackagebot laborantin-hs 0.1.1.1 - an experiment management framework  http://hackage.haskell.org/package/laborantin-hs-0.1.1.1 (LucasDiCioccio)
12:29:32 <kuznero> :)
12:29:44 <donri> also, with StateT you could write your code such that you could run it without IO, if you abstract the IO stuff sufficiently
12:29:54 <kuznero> benmachine: apparently, that was a lame choice of mine :)
12:30:15 <benmachine> kuznero: I wouldn't say the issue is clear-cut
12:30:22 <benmachine> kuznero: as you can see, not everyone agrees with me :P
12:30:41 <benmachine> kuznero: but, I was just about to propose a solution to your problem using IORefs, and then I thought, well, why didn't I just use these in the first place
12:31:24 <kuznero> benmachine: I see, can I ask you to elaborate slightly more on IORef solution? Maybe a few hints?
12:31:31 <donri> i didn't actually follow the discussion though. mutable state surely has its place too.
12:31:54 <benmachine> kuznero: I'm thinking about it, will let you know when I'm done
12:31:57 <donri> i was just disagreeing with StateT IO being useless. not that that's what anyone said.
12:32:04 <kuznero> benmachine: sure, thanks!
12:32:10 <cschneid> what's the package that wraps up all the error handlers?  For instance, I have a Maybe, but really want an Either. (ie, attach note on a Nothing return value). There was one big package which did that
12:32:19 <donri> cschneid: errors?
12:32:23 <donri> cschneid: failure?
12:32:25 <cschneid> ... is it that simple :-/
12:32:28 <benmachine> donri: StateT IO isn't really much use
12:32:55 <kuznero> donri: so, StateT IO a is immutable whether IORef is mutable state, am I getting it right?
12:33:06 <benmachine> donri: there are definitely problems with mutable state but they're pretty much problems that you already have if you're using IO
12:33:16 <donri> kuznero: yes
12:33:18 <benmachine> kuznero: it's a bit subtle
12:33:19 <simpson> StateT s m is useful; StateT s IO is just a specialization of that.
12:33:44 <benmachine> simpson: that argument seems suspect to me
12:34:03 <benmachine> e.g. composition is useful, and id . id is just a specialisation of that
12:34:33 <simpson> Well, I was talking in terms of types. You can write algorithms that use StateT s m, and then happen to use them in StateT s IO without any loss of functionality.
12:34:46 <simpson> Admittedly I'm a big fan of lens combinators for state.
12:34:48 <donri> benmachine: well if all you need is immutable state, you can be confident you're avoiding problems with mutable state if you don't use it :P
12:35:25 <benmachine> simpson: that's a good point
12:35:37 <benmachine> donri: that's true
12:35:59 <benmachine> donri: but I feel like whether you're using StateT or IORefs is neither here nor there for that argument
12:36:07 <benmachine> it all depends on what else is going on
12:37:25 <donri> it's just, to me, saying "you're already in IO" is like arguing against purity all-together because everything is in IO at some point, if it is to run at all. :)
12:38:17 <hpc> it is a bit
12:38:39 <lpaste> benmachine annotated “How to run in context of my state” with “How to run in context of my state (annotation)” at http://lpaste.net/94552#a94554
12:38:45 <donri> I can reason about StateT, and IO being the base monad doesn't change anything
12:38:55 <donri> i can't really reason about IORefs
12:39:08 <benmachine> donri: what reasoning can you do about StateT that you can't about IORefs?
12:39:26 * hackagebot laborantin-hs 0.1.1.2 - an experiment management framework  http://hackage.haskell.org/package/laborantin-hs-0.1.1.2 (LucasDiCioccio)
12:40:18 <benmachine> kuznero: have a look at http://lpaste.net/94552#a94554
12:40:39 <kuznero> benmachine: thanks, going through it atm...
12:41:42 <donri> benmachine: to be totally honest, IORef is "reasonable" compared to other languages since you need explicit de-ref and, i assume, you get an immutable copy when you readIORef?
12:41:53 <benmachine> donri: yes indeed
12:42:05 <benmachine> donri: remember that Haskell is the world's finest imperative language :)
12:42:09 <donri> :)
12:42:11 <donri> truth
12:43:05 <donri> so yeah perhaps in this case it's mainly that the type enforces single-threaded state
12:43:06 <kuznero> benmachine: ok, I think I got what you meant! I record current state, then perform operation, then update state to how it was changed during this operation. Right?
12:43:23 <benmachine> kuznero: yes
12:43:56 <kuznero> benmachine: ok, how will this behave in case of concurrency, I mean race with another block modifying the state in the same time?
12:45:25 <alllex220> hello, what means lists are homogeneous in Haskell?
12:45:48 <benmachine> alllex220: every element of a Haskell list has the same type
12:46:03 <NihilistDandy> Is the lambdabot here a standard build? I notice it knows about lenses and such, and I'd like to build one like that, myself
12:46:04 <benmachine> alllex220: you can have a list of integers or a list of strings, but not a list containing an integer and a string
12:46:23 <benmachine> alllex220: however you can have a list containing an Either Integer String, so it's not so bad
12:46:43 <alllex220> ah thanks now the term homogeneous makes sense to me
12:46:45 <benmachine> kuznero: so, I don't think there will be any problems, because the ioref I store the state in isn't given to any other threads
12:47:09 <edvo> can anyone give me a hint how to implement an indexed state monad with the type classes from index-core?
12:47:20 <benmachine> kuznero: if onAuthButtonClick does something crazy like forking then, uh, you're on your own P
12:47:23 <benmachine> *:P
12:48:19 <benmachine> kuznero: (I mean, forkProcess forking, not forkIO)
12:48:51 <kuznero> benmachine: I see one potential issue here... Let's assume there is another thread modifying the state and committing it before this code will commit its version). Then state committed by another thread will get lost, am I right?
12:49:32 <benmachine> kuznero: it depends what you mean by "the state"
12:49:39 <benmachine> kuznero: but the answer is, probably not
12:50:03 <benmachine> kuznero: the important thing to understand about StateT is that (unlike IO) it involves no magic at all
12:50:11 <kuznero> benmachine: I mean the state I get and put in StateT
12:50:21 <benmachine> kuznero: it's just ordinary functions that take the extra state as an argument and return it as a result
12:50:35 <benmachine> (in a pair with whatever other thing they return)
12:50:52 <Vamp> Would someone know another version of the monad instance for my dtree, something with a do-notation? http://lpaste.net/23818801996890112 includes my version now and the undefined one
12:50:54 <kuznero> benmachine: I see. Do you think STM might be more useful in this case?
12:51:02 <benmachine> kuznero: it depends what you want
12:51:40 <benmachine> kuznero: do you actually make use of concurrency?
12:51:50 <benmachine> do you want state shared between threads and updated by each of them?
12:52:49 <kuznero> benmachine: I see this possible, maybe not in the current context. I just used to think about this in advance when I'm coding C#.
12:53:14 <skypers> hey is there a way to dereference a Ptr ?
12:53:15 <skypers> unPtr ?
12:53:28 <benmachine> skypers: peek from the Storable typeclass, iirc
12:53:42 <skypers> oh yes
12:53:53 <skypers> I’m might be tired… :D
12:54:11 <benmachine> kuznero: so, I'd say, use STM only for those things that you specifically want to be shared between threads and updated by multiple threads
12:54:21 <benmachine> kuznero: and even then, IORefs are sometimes sufficient
12:54:40 <benmachine> kuznero: don't worry about threading until you need threading
12:54:57 <kuznero> benmachine: got your point. Thanks for your help!
12:54:59 <benmachine> kuznero: this is a valid strategy with Haskell because Haskell threads are generally much easier to deal with and most Haskell code is thread-safe by default
12:55:11 <chrisdone> donri: hehe, this is neat. i can run M-x shm-describe-node and it gives me a brief description of the current syntactical node
12:55:50 <chrisdone> e.g. on "<-" i get:
12:55:51 <chrisdone> Node type: “Stmt”: A statement, representing both a stmt in a do-expression, an ordinary qual in a list comprehension, as well as a stmt in a pattern guard, case: “Generator”: A generator: pat <- exp
12:56:48 <chrisdone> donri: not particularly useful if you already know haskell, but neat for newbies. i thought about also showing "other things you could type here"
12:58:33 <benmachine> chrisdone: sounds pretty cool
13:09:51 <donri> chrisdone: oh cool. also for non-newbies and obscure extensions / weird confusing syntax style
13:09:58 <chrisdone> aye
13:10:03 <donri> chrisdone: where does it get the info from?
13:10:11 <kuznero> benmachine: thanks again, everything works as I wanted!
13:10:27 <benmachine> kuznero: no problem, glad to hear it :)
13:10:29 <benmachine> kuznero: btw
13:10:51 <benmachine> kuznero: if you have something like liftIO $ x; liftIO $ y you can change that into liftIO $ do x; y
13:11:16 <benmachine> kuznero: likewise liftIO $ x; z <- liftIO $ y becomes z <- liftIO $ do x; y
13:11:26 <chrisdone> donri: presently it parses the declaration once. for each node in the tree, Emacs has info about its location, the type of node (e.g. Exp), and the constructor of the node (e.g. Literal). i scraped HSE's documentation from *.Syntax and converted it to an Elisp tree that i can query
13:11:26 <kuznero> benmachine: was about to do that :) thanks
13:11:43 <donri> chrisdone: oh, hse haddocks :)
13:11:47 <chrisdone> donri: (i also cleaned up some of the formatting)
13:16:45 <lpaste> tomejaguar pasted “What's a nice, idiomatic way to write this?” at http://lpaste.net/94555
13:17:56 <tomejaguar> ^^ anyone have a suggestion?
13:20:41 <arkeet> let's give it a go.
13:21:07 <arkeet> well, there are two things wrong with that
13:21:22 <arkeet> one minor thing is that you should use  null line  instead of  line == ""
13:21:30 <arkeet> the bad thing is that you're appending to the end of names a lot.
13:23:08 <luis> Hi. I hope this is the right channel for this question: I'm using brew on MacOS 10.7.5 and I just installed the haskell-platform package that way. Unfortunately, cabal always yields errors like this: cabal: Couldn't read cabal file "bytestring/0.10.4.0/bytestring.cabal"
13:23:19 <luis> How should I fix this?
13:23:52 <lpaste> arkeet annotated “What's a nice, idiomatic way to write this?” with “What's a nice, idiomatic way to write this? (annotation)” at http://lpaste.net/94555#a94556
13:23:53 <arkeet> tomejaguar: ^
13:25:35 <arguser> hello, im trying to install postgresql-simple on windows with haskell-platform
13:25:40 <arkeet> (also a minor quibble: the name "getFirstNames" makes it sound more specific than it really is. "getLines" maybe?)
13:25:51 <arguser> it seems to be a problem with a c library pq
13:26:09 <arguser> ive set the paths for libs/include but nothing changes
13:26:11 <donri> or abuse the evils of lazy io and takeWhile (not . null) . lines <$> getContents -- or something
13:26:19 <arkeet> evil!
13:26:23 <donri> \o/
13:26:59 <arkeet> one should really make a pipe out of it.
13:27:04 <chrisdone> donri: benmachine: i started implementing a fresh public version yesterday https://github.com/chrisdone/structured-haskell-mode
13:27:33 <dcoutts_> luis: what does cabal --version say?
13:27:45 <donri> arkeet: takeWhile (not . null) <-< stdinLn
13:28:06 <arkeet> :-)
13:28:57 <arkeet> but lazy IO is evil, and pipes are probably not quite for beginners
13:29:12 <arkeet> and it's worth knowing how to do it by hand I guess
13:29:47 <arkeet> I guess there isn't really much wrong with  line == ""
13:30:00 <arkeet> it's better than  length line == 0
13:30:03 <arkeet> ;)
13:30:15 <arkeet> but  null line  is the idiomatic thing to write.
13:31:47 <dcoutts_> lazy IO is not evil!
13:32:10 <arkeet> =(
13:32:22 <chrisdone> unintentional lazy IO is, which it almost always is
13:32:35 <dcoutts_> but using withFile etc is a good idea
13:32:43 <donri> lazy IO is elegant. unfortunately I/O is not
13:33:10 <dcoutts_> bracket style resource management covers almost all cases
13:33:14 <absence> the recent discussion on pipes vs conduit seems to have died down. any news on that, or are the respective authors hard at work? :)
13:34:32 * hackagebot th-desugar 1.2.0 - Functions to desugar Template Haskell  http://hackage.haskell.org/package/th-desugar-1.2.0 (RichardEisenberg)
13:43:25 <scrambledeggs2> ?
13:45:02 <luis> dcoutts_: 0.10.2
13:46:10 <luis> should I install a newer one myself or something?
13:46:46 <dcoutts_> luis: ahh, ok, found the problem
13:47:22 <dcoutts_> luis: yes, the workaround is to use a later cabal, or indeed the same cabal-install built against a version of the Cabal lib without the particular bug
13:48:28 <dcoutts_> luis: but if you just installed the haskell-platform then you should have a much newer cabal anyway, check you're not accidentally using an old one from a previous install
13:49:11 <dcoutts_> luis: cabal-install-0.10.x is about 2.5 years old
13:49:58 <luis> It's just a baby! :)
13:50:32 <luis> I tried compiling Cabal 1.18.1 but got 66 warnings and 8 errors generated on Setup.hs :-/
13:51:02 <luis> Is ghc 7.0.3 too old as well?
13:51:11 <tomejaguar> arkeet: avoiding the accumulator is much better, thanks.
13:51:44 <quchen> luis: In general I'd suggest using a version of GHC that's not older than 2 major releases. That's typically what GHC itself relies on.
13:53:03 <luis> meh. brew's haskell-platform is too old!
13:53:31 <luis> or maybe I'm doping something wrong. anybody using brew?
13:53:39 <DoritosMan> I am
13:53:54 <dcoutts_> luis: well, you can use that old version, but you'll need to rebuild cabal-install using Cabal-1.10.2.0
13:54:01 <dcoutts_> using/against
13:55:58 <luis> DoritosMan: are your cabal and ghc this old as well?
13:57:42 <DoritosMan> My cabal on brew is 1.18.0.2
13:58:16 <DoritosMan> ghc is 7.6.3
14:01:14 <DanielDiaz> how do I cast a 'Ptr CUChar' to a 'Ptr CChar' (i.e. CString)?
14:04:11 <nstdloop> If I want to export a data type in a module I just list its name right?
14:04:26 <chrisdone> DanielDiaz: Foreign.Ptr.castPtr
14:05:11 <chrisdone> nstdloop: sure. but that exports *only* the name. if you also want to export the constructors, you need to specify that too
14:05:20 <DanielDiaz> chrisdone: is that the right way? as far as I know, they are different types.
14:05:20 <nstdloop> Thanks
14:06:04 <chrisdone> DanielDiaz: http://stackoverflow.com/questions/4337217/difference-between-signed-unsigned-char
14:06:34 <snyp> Where can I read about Haskell's indentation rules?
14:06:45 <DanielDiaz> thank you, chrisdone
14:07:29 <snyp> Also, I think I need to set "use spaces for indents" right?
14:07:40 <codygman> I need to create a temporary directory for an external commands output. It seems that withSystemTempFile (http://hackage.haskell.org/package/temporary-1.1/docs/System-IO-Temp.html#v:withSystemTempFile) doesn't actually create the directory unless you use it with openTempFile. Is this correct? Should I just now use a command to create the directory and error out after? New to haskell and trying to figure out the best course of action
14:07:40 <codygman> here.
14:08:40 <chrisdone> snyp: the haskell 2010 report explains the indentation rules
14:09:32 <chrisdone> snyp: http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
14:09:32 <snyp> i see. thanks
14:09:32 <DiegoNolan> what's up with postgresql-simple on hackage 2.0
14:11:03 <kuznero> benmachine: sorry for disturbing, but can I get back to the question I asked before about working with state in gtk2hs?
14:11:27 <benmachine> kuznero: yes
14:11:34 <tomejaguar> DiegoNolan: What do you mean what's up with it?
14:12:04 <DiegoNolan> tomejaguar: Nothing on the page
14:12:10 <DiegoNolan> tomejaguar: doc is gone
14:12:28 <kuznero> benmachine: I suspect that "put currentState" will happen before user will press a button and onClicked will call its callback to change the state. Thus, state will never be persisted back...
14:12:42 <kuznero> http://lpaste.net/94552
14:12:56 <benmachine> kuznero: ah, well, this is what I meant when I asked you about async-ness
14:13:30 <kuznero> benmachine: I see now :) then answer is yes :) sorry, it takes some time for me :)
14:13:33 <tomejaguar> DiegoNolan: What about this: http://hackage.haskell.org/package/postgresql-simple-0.3.8.0
14:13:35 <chrisdone> codygman: why not using withSystemTempDirectory?
14:14:00 <benmachine> kuznero: ok, if you're dealing with async code, you may find it necessary to use IORefs or MVars
14:14:04 <benmachine> or STM, indeed
14:14:27 <benmachine> I don't know which is most appropriate because I don't know how gtk2hs works because I've never used it
14:14:39 <benmachine> has anyone else used it and wants to volunteer how its async stuff works?
14:14:55 <benmachine> (e.g. is it pre-emptive or co-operative or what)
14:15:23 <DiegoNolan> tomejaguar: click on one of the modules
14:15:45 <monochrom> benmachine: my http://www.vex.net/~trebla/haskell/gtk-interact.xhtml may help
14:17:04 <benmachine> monochrom: ah, you use STM
14:18:07 <monochrom> gtk2hs does not know STM. the STM is just for myself
14:18:34 <monochrom> postGUIAsync is what gtk2hs knows. there is also postGUISync
14:19:38 <monochrom> the only reason I use STM is orElse. I would simplify to MVar otherwise
14:19:50 <tomejaguar> DiegoNolan: I guess it hasn't been generated yet.  Don't know if that's a Hackage bug.  Earlier ones work fine: http://hackage.haskell.org/package/postgresql-simple-0.3.7.1
14:20:17 <kuznero> monochrom: could you please suggest the way to solve http://lpaste.net/94552 ?
14:20:24 <DiegoNolan> tomejaguar: thanks
14:21:50 <monochrom> I don't know OAuthApp
14:22:13 <kuznero> Sorry, that is StateT Application IO
14:22:21 <monochrom> I don't know Application
14:22:44 <kuznero> It is record data for keeping some details about my state
14:22:46 <kuznero> custom
14:23:03 <monochrom> what should I know?
14:25:02 <kuznero> monochrom: I'm trying to find a way to bridge between the state I have in StateT ... and gtk2hs IO () callbacks. So, I want to change state from within those callbacks I set in onClicked or onActivated event in Gtk.
14:27:04 <geekosaur> the way I do it is put the state in an IORef and pass that in a Reader
14:27:34 <geekosaur> modifyIORef to update the state
14:28:12 <codygman> chrisdone: I am using withSystemTempDirectory but it doesn't actually create the directory
14:28:12 <araujo> gtk2hs can be even more fun without those monads though ....
14:28:16 <araujo> :)
14:28:20 <monochrom> I think you should use an IORef (but confine to readIORef and atomicModifyIORef) or TVar. StateT is not designed for concurrency or call-back.
14:28:45 <kuznero> monochrom: ok, thanks
14:32:34 <codygman> chrisdone: Apparently the directory does created... so I have a bug somewhere else: http://dpaste.com/1423811/
14:34:28 <lpaste> chrisdone pasted “codygman” at http://lpaste.net/94559
14:35:56 <chrisdone> codygman: what's the bug?
14:36:11 <stephenmac7> Anyone know of a good resource for the console-program library?
14:37:38 <codygman> chrisdone: The ffmpeg command is failing, but doesn't fail when I use it on my command line. Was actually just figuring out syntax to do error checking on the createProcess and display stderr... so that might show me what's wrong ;)
14:38:06 <geekosaur> you have code there to dump stdout (hout)... try it with herr instead
14:41:14 <codygman> geekosaur: I did, I just noticed an error before that: ffmpeg: (Pattern match failure in do expression at ffmpeg.hs:24:5-32) This seems to happen when there is an error. I thought that createProcess always returns those 4 things even in the case of an error and should pattern match. How would I match in the case of an error?
14:42:39 <geekosaur> hm, you're misunderstanding that, you did not tell it what to do with stdout or stderr so those will be Nothing and they should be going to your program's stdout/stderr
14:43:47 <geekosaur> if you want to capture them, you need to tell it to create pipes (std_out = CreatePipe, std_err = CreatePipe)
14:45:39 <geekosaur> those go next to your std_in spec in the createProcess call
14:46:34 <codygman> geekosaur: Alright, I think I understand. Give me a moment.
14:50:11 <geekosaur> and the reason they're not automatically created is (a) that would waste filehandles if you don't want to capture the output; (b) if you don't read them, and there's more output than the OS is willing to buffer, your spawned program will block.
14:52:13 <codygman> geekosaur: Thanks for that. It's very good to know. I now have a different problem: *** Exception: fd:8: hGetLine: end of file (http://dpaste.com/1423822/)
14:53:41 <codygman> Is it because nothing is being written to stdout?
14:54:33 <geekosaur> I would also note you're still doing questionable things; reading from the handles should be done in separate threads, and you should waitForProcess in the main thread.
14:54:59 <geekosaur> but yes, if there's no stdout then hGetLine will throw that exception
14:56:18 <codygman> geekosaur: I'm sure I am doing questionable things, since this is my first non tutorial haskell code so all advice is greatly appreciated. Cool so now I'll just figure out how to catch it since I believe I've done that before.
14:56:25 <NihilistDandy> Does `import safe` still work? I'm trying to import Control.Lens under -XSafe without it complaining, but I get a parse error using `import safe`
14:57:08 <donri> NihilistDandy: it should parse if in deed you're using -XSafe
14:57:21 <NihilistDandy> Hmm. I wonder what the issue is, then
14:57:27 <donri> NihilistDandy: is it also qualified?
14:57:31 <donri> keyword order matters
14:57:34 <NihilistDandy> It is not
14:57:37 <donri> safe comes first IIRC
14:57:43 <NihilistDandy> I have `import safe Control.Lens`
14:57:52 <donri> how are you compiling
14:58:09 <NihilistDandy> It's actually for lambdabot's L.hs, so it's interpreted
14:58:11 <geekosaur> honestly, the System.Process haddock doesn't have enough information to know how to use it properly unless you are already familiar with the POSIX process model.
14:59:02 <donri> NihilistDandy: in that case you probably need to pass -XSafe or include Safe in some extensions list, to whatever runs the interpreter
14:59:11 <hpc> geekosaur: i was able to figure it out just fine
14:59:16 <hpc> without knowing POSIX
14:59:17 <donri> NihilistDandy: compiling the interpreter with -XSafe shouldn't make a difference
14:59:38 <NihilistDandy> Hmm, that might be the case. I just went and grabbed source to add lens to trustedPkgs just in case that's the issue, as well
15:00:46 <geekosaur> hpc: including the possibility of deadlock between reading from created pipes and waiting for the process?
15:01:11 <geekosaur> that catches just about everybody the first time
15:03:29 <hpc> geekosaur: that part's obvious
15:04:01 <hpc> you mean the deadlock of "process wants input" vs "i want output"
15:04:15 <geekosaur> no, although that one also exists
15:04:43 <geekosaur> but you get people doing: create process with stdout to pipe, wait for process to exit, read its stdout
15:05:03 <hpc> oh i see
15:05:04 <geekosaur> and if you get more than PIPE_BUF bytes on the stdout pipe, it blocks and the wait for process never returns
15:09:40 <NihilistDandy> @info Data.Random.Distribution.Ziggurat
15:09:40 <lambdabot> Data.Random.Distribution.Ziggurat
15:25:21 <pharaun> <3 criterion
15:26:25 <NihilistDandy> @type (^..)
15:26:26 <lambdabot> s -> Getting (Endo [a]) s a -> [a]
15:27:29 <stephenmac7> I'm having an issue with option parsing: http://pastebin.com/TcFuzJUK
15:27:37 <stephenmac7> Here's the code: import System.Console.Command
15:27:37 <stephenmac7> import System.Console.Program
15:27:37 <stephenmac7> import System.Console.Argument
15:27:37 <stephenmac7> commands :: Commands
15:27:37 <stephenmac7> commands = Node runCommand [Node helloCommand [], Node byeCommand []]
15:27:37 <stephenmac7>     where runCommand = Command "run" "Default Action" . io $ sayHello False
15:27:37 <mauke> The paste TcFuzJUK has been copied to http://lpaste.net/94561
15:27:39 <stephenmac7>           helloCapsOption = option "c" ["caps"] boolean False "Show in Caps"
15:27:42 <stephenmac7>           helloCommand = Command "hello" "Say Hello" . withOption helloCapsOption (\x -> io $ sayHello x)
15:27:45 <stephenmac7>           byeCommand = Command "bye" "Say Goodbye" $ io sayBye
15:27:47 <stephenmac7> sayHello :: Bool -> IO ()
15:27:48 <stephenmac7> sayHello caps = putStrLn $ if caps then "HELLO" else "Hello"
15:27:50 <stephenmac7> sayBye :: IO ()
15:27:52 <stephenmac7> sayBye = putStrLn "Goodbye"
15:27:54 <stephenmac7> main = do
15:27:56 <stephenmac7>     interactive commands
15:27:58 <stephenmac7> Sorry
15:27:59 <geekosaur> don't paste into the channel
15:28:01 * stephenmac7 hits himself in the head
15:28:01 --- mode: ChanServ set +o geekosaur
15:28:05 --- mode: geekosaur set -o geekosaur
15:28:13 <stephenmac7> Stupid thing didn't copy the url
15:29:20 <stephenmac7> Here it is: http://lpaste.net/94563
15:30:44 <danilo2> Hi! :) What is the difference (how should we read it) between "(forall a. a -> a) -> (forall b. b -> b)" and "(forall a b. a -> a -> b -> b)" ? I understeand the first like "for all possible a and for all posible b the functions outputs a result", but going this way, I do not see the difference with the later.
15:31:50 <geekosaur> for one, they aren't even the same thing because they're differently parenthesized (maybe you meant the second to be (forall a b. (a -> a) -> (b -> b))?)
15:32:28 <geekosaur> the (b -> b) can be left unparenthesized, the (a -> a) can't
15:33:26 <geekosaur> as to the actual question... I'm not that good with foralls but I think there's an implication about a and b being different in the second, but nothing whatsoever can be said about their relationship in the first?
15:34:00 <elliott> you could pass (+1) to the second and not the first
15:34:12 <elliott> also, the first can be implemented and the second cannot
15:34:15 <elliott> (assuming geekosaur's parens fix)
15:34:48 <danilo2> geekosaur: You're right - I meant "(forall a. a -> a) -> (forall b. b -> b)" and "forall a b. (a -> a) -> (b -> b)"
15:35:42 <geekosaur> stephenmac7, since hayoo's down I have no idea where you got withOption from. what package is that?
15:35:51 <NihilistDandy> Oh, I just had to compile lens with -fsafe, I think
15:35:54 <danilo2> elliott: Ok, why is that? Where can I read more about "foralls" nd understeand what they really mean ?
15:35:56 <geekosaur> (why yes, yet another weekend with hayoo down :/ )
15:39:41 <NihilistDandy> Nope, that wasn't it :/
15:40:40 <danilo2> fizruk_: Can Ihave one question to the code, you've helped me with?
15:42:06 <geekosaur> http://www.haskell.org/haskellwiki/Existential_type and links therefrom
15:44:50 * hackagebot pandoc 1.12.1 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.12.1 (JohnMacFarlane)
15:45:44 <lpaste> gabemc pasted “Crypto.Random Troublee” at http://lpaste.net/94564
15:45:51 <gabemc> Need a bit of help with the Cypto.Random API.
15:46:20 <gabemc> I'm very confused by the output of the compiler -- I tried adding a type annotation, and it did the opposite of what I expected.
15:50:17 <geekosaur> stephenmac7, ok, I think this is console-program? Your error is using (.) to combine the withOption in, since that expects to apply what you passed it to something.
15:50:22 <NihilistDandy> mokus: You around?
15:51:25 <lpaste> geekosaur annotated “No title” with “for stephenmac7 (untested)” at http://lpaste.net/94563#a94566
15:52:06 <luite> is there a way to run shell scripts directly with shelly under msys?
15:53:18 <danilo2> I do not feel the forall and rank-N-types stuff yet, but I'm trying to leanr it. Here is a code (which works), which firzuk_, merijn and some other persons helped me a lot with. I want to ask you if is it possible to modify the type signature in lines 23-25, so, that could be used not only with X instance, but also Y instance? (in other words: to make line 34 working) ?
15:53:22 <luite> (run "name" []) gives a createProcess invalid argument error, (run "sh" ["name"]) does not work because the script uses its own name for some version info
15:53:45 <danilo2> http://lpaste.net/94565
15:53:54 <stephenmac7> geekosaur: Let me try that
15:54:19 <gabemc> Ignore me, I figured it out!
15:54:56 <stephenmac7> geekosaur: Yup this works
15:55:05 <stephenmac7> helloCommand = Command "hello" "Say Hello" $ withOption helloCapsOption $ io . sayHello
15:55:16 <trampel> idiot_newbie looking for a clue interpreting type signatures:  given ":type all  ...all :: (a -> Bool) -> [a] -> Bool"  why does "a" precede "Bool"?  since: "all odd [1, 3, 5] ...True"  the Boolean seems to come first?  thanks!
15:55:57 <geekosaur> trampel: (a -> Bool) means a function which, when given an a, produces a Bool
15:55:58 <NihilistDandy> odd is a function from a -> Bool
15:56:05 <geekosaur> that function, in your example, is `odd`
15:56:11 <Iceland_jack> @ty all
15:56:11 <Iceland_jack> @ty odd
15:56:12 <lambdabot> (a -> Bool) -> [a] -> Bool
15:56:12 <lambdabot> Integral a => a -> Bool
15:56:35 <Iceland_jack> @ty all odd
15:56:35 <lambdabot> Integral a => [a] -> Bool
15:56:53 <trampel> geekosaur: thank you!  that will probably lead me to a dawning.
15:58:23 <geekosaur> haskell's type notation does take some getting used to. (and how it's reflected in actual function calls takes even more getting used to, once you get into partial application and functions that return functions and such)
15:58:57 <trampel> well i'm sure it's much more logical (?) than C declaration syntax.
15:59:37 <trampel> but yes...  "((->)->(->))->->))"
16:01:55 <benmachine> it's very logical
16:03:23 <monochrom> this is why I don't translate type expressions into natural language. but it is not so much special about type expressions.
16:04:29 <monochrom> sqrt(x^2 + sin(2x - 1)) * tan(x - sqrt(x)) you do not translate that into natural language either.
16:04:52 * hackagebot cabal-debian 3.8.3 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-3.8.3 (DavidFox)
16:12:59 <stephenmac7> Having yet another issue: http://lpaste.net/94568
16:13:03 <stephenmac7> ^ code
16:13:30 <stephenmac7> Error: http://lpaste.net/94569
16:14:24 <stephenmac7> How can I string together arguments/options?
16:15:30 <geekosaur> you keep trying to use (.) inappropriately
16:15:53 <geekosaur> do you actually understand what (.) does? and how it differs from ($)? and from parenthesized expressions?
16:16:34 <stephenmac7> Yes, it takes a two functions and creates a new function which passes the value through both
16:16:56 <stephenmac7> $ just applies a function to some value after evaluating the right side
16:17:16 <geekosaur> but you're using . when it doesn't make any sense
16:17:48 <elliott> (f $ x) does not necessarily evaluate x.
16:17:54 <derdon> hi KingOfKarlsruhe :)
16:18:01 <stephenmac7> :t ($)
16:18:02 <lambdabot> (a -> b) -> a -> b
16:18:48 <stephenmac7> Here's the issue: it requires an action
16:18:57 <stephenmac7> But I don't have all the parameters filled up
16:19:02 <stephenmac7> So, I can't use io
16:20:50 <stephenmac7> geekosaur: So, what could I do
16:21:09 <stephenmac7> I know (.) shouldn't go there but I'm just doing that to show some sample code so the issue is obvious
16:23:57 <joelteon> ($) is infix id
16:24:54 * hackagebot pdf-toolbox-core 0.0.2.0 - A collection of tools for processing PDF files.  http://hackage.haskell.org/package/pdf-toolbox-core-0.0.2.0 (YurasShumovich)
16:24:56 * hackagebot pdf-toolbox-content 0.0.2.0 - A collection of tools for processing PDF files  http://hackage.haskell.org/package/pdf-toolbox-content-0.0.2.0 (YurasShumovich)
16:28:45 <Eduard_Munteanu> Is there a way to wrap a class involving a fundep, like 'class Foondep p q | p -> q', to get a 'k -> Constraint' where (p :: k)? Effectively hiding the 'q', that is.
16:29:05 <Eduard_Munteanu> I got something like that but it's rather flaky and I'm unsure whether it's a GHC bug allowing it.
16:29:31 <sipa> sounds like you just want an associated type?
16:29:55 * hackagebot pdf-toolbox-document 0.0.2.0 - A collection of tools for processing PDF files.  http://hackage.haskell.org/package/pdf-toolbox-document-0.0.2.0 (YurasShumovich)
16:30:07 <Eduard_Munteanu> sipa: I just want to apply that constraint and let 'q' be inferred, as in a type family. I don't want to redefine it.
16:30:16 <Eduard_Munteanu> "inferred"
16:31:06 <Eduard_Munteanu> What I had was   data Hide
16:31:22 <Eduard_Munteanu> Er... data Hide :: Constraint -> * where <nothing>
16:31:55 <Eduard_Munteanu> type family Unhide (t :: *) :: Constraint   type instance Unhide (Hide c) = c
16:32:50 <Eduard_Munteanu> Then you wrap constraints like   type Foomily p = Hide (forall q. (<something involving q>))
16:33:13 <Eduard_Munteanu> And it happens sometimes, not sure when, you can unwrap it with Unhide and GHC won't complain.
16:33:39 <Eduard_Munteanu> Sure, it involves a ton of ImpredicativeTypes and other menacing incantations.
16:35:02 <Eduard_Munteanu> sipa: for some context, I was deriving lenses with makeFields and I wanted to had the pesky field type in Has* classes.
16:35:15 <Eduard_Munteanu> But more generally, I'm considering some sort of existential wrapper.
16:35:22 <Ghoul_> flattenSCCs $ stronglyConnCompR [(1, 1, [2, 3, 0]), (2, 2, []), (3, 3, [2]), (4, 4, [2, 0]), (5, 5, [3, 4]), (0, 0, [])]
16:35:30 <Ghoul_> > flattenSCCs $ stronglyConnCompR [(1, 1, [2, 3, 0]), (2, 2, []), (3, 3, [2]), (4, 4, [2, 0]), (5, 5, [3, 4]), (0, 0, [])]
16:35:31 <lambdabot>   [(2,2,[]),(3,3,[2]),(0,0,[]),(1,1,[2,3,0]),(4,4,[2,0]),(5,5,[3,4])]
16:35:38 <hmmh> Anyone know how ocaml compares with haskell in terms of speed for numerical computing tasks?
16:35:41 <Eduard_Munteanu> s/to had/to hide/
16:35:58 <Ghoul_> hmmh: haskell is faster than ocaml prettymuch always.
16:36:33 <Ghoul_> In fact, I remember reading somewhere on the wiki that a program in haskell which performs worse in ocaml should be reported on the trac as a regression...
16:36:56 <Eduard_Munteanu> hmmh: it shouldn't matter much if you're just gluing stuff (that usually calls out to "Real" numeric libs)
16:39:02 <hmmh> Ok thanks
16:40:10 <Eduard_Munteanu> hmmh: nevertheless, implementing basic operations yourself is quite tricky if you care at all about performance.
16:41:56 <hmmh> Eduard_Munteanu: Yea, to be honest I'm more and more on the fence about investing my time with haskell for that reason
16:43:33 <Eduard_Munteanu> hmmh: if you're doing that, it's probably for (self-)educational purposes. If you want to get something done, sure, there are a few pretty fine numeric Haskell libs out there.
16:47:41 <hmmh> Eduard_Munteanu: Yea, but limited support for machine-learning related tasks. Something that I'd like to see expanded, since haskell is quick
16:51:41 <alpounet> hmmh, check this out (and the associated paper) https://github.com/mikeizbicki/HLearn
16:53:52 <alpounet> i've done a couple of numerical stuffs in haskell too (more than a couple actually), it's really fine, when you know some tricks and use the right libraries. OCaml is more predictable because that's one of their selling point, the compiler doesn't really do any voodoo, it really compiles quite straightforwardly to machine code, whereas in Haskell the compiler has to do much more work to get efficient machine code, but GHC is doing qu
16:53:52 <alpounet> ite well, although like I said that requires some knowledge
16:54:04 <Infandum> Are there any sparse matrix libraries in haskell that support sparse matrix multiplication and sparse SVD?
16:58:10 <DanielDiaz> Infandum: maybe this http://hackage.haskell.org/package/sparse-lin-alg-0.4 can help you
16:58:41 <Infandum> DanielDiaz: Unfortunately it does not support sparse SVD
17:02:09 <hmmh> alpounet: thanks. I looked at that lib briefly, and want to take a closer peek
17:02:18 <hmmh> tbc
17:19:35 <Infandum> I guess there needs to be more work here.
17:20:08 <satc> Given (a,b), I have partial order on this. ie. (a,b) >= (c,d) iff a>c and b >d, otherwise I can not say anything about it. Given a structure of these values and an element (x,y) I want to efficiently compute if there is an element in the structure which is smaller than (x,y)?
17:20:25 <Infandum> If I'm not good at C, barely know it, how hard would it be for a FFI to a C library when I just need to bind an input and output matrix (svdlibc)?
17:22:31 <malvarez> satc: excuse me, what do you mean by 'a structure of these values'? Is it finite?
17:23:16 <andrew_> I've been learning haskell from learnyouahaskell and im wondering what the ":" in this function means "take' n (x:xs) = x : take' (n-1) xs "
17:23:19 <satc> malvarez: I will be computing this from values and then performing that query. Also all the elements in the structure are incomparable (if that helps).
17:23:35 <andrew_> I know x:xs splits the input(List?) in to a head and tail
17:24:09 <andrew_> can x:xs only be used on lists also if so why do they use the "(" ")" type brackets and not [x:xs]
17:24:19 <malvarez> andrew_: in an expression context (as opposed to a pattern context), (a:as) means "the list with a as first element and b as rest
17:24:50 <malvarez> andrew_: In a pattern context, it means "destructure the argument (which must be a list) as a first element a and rest as"
17:25:13 <malvarez> andrew_: The parentheses are just there for precedence and aren't always necessary
17:25:37 <andrew_> I mean the second ":"
17:25:44 <andrew_> ohh because n is there i never spoted that
17:26:05 <satc> malvarez: I essentially need a datastructure to do that which I am not sure about. So for example my structure is {(0,2),(-1,5)} and query comes for (2,4) then I output yes as (2,4) >= (0,2) (I can not say anything about comparing (-1,5) and (2,4)).
17:26:22 <malvarez> satc: can I assume you have a finite set of pairs (a, b)?
17:26:50 <malvarez> satc: Or a list, or sequence, or Traversable...
17:26:51 <satc> malvarez: Yes.
17:27:17 <satc> malvarez: I still havn't thought about from where I will get that value. But I need something better that O(n).
17:28:19 <malvarez> satc: you should be able to do better than that, I think
17:28:25 <malvarez> satc: not exactly sure how
17:28:28 <satc> malvarez: My question is not very related to haskell. But I always get good answers to challenging problems here.
17:29:12 <malvarez> satc: I get that (a, b) is a partial order. Can we assume a total ordering on both components separately?
17:29:59 <satc> malvarez: Yes. But will that help. Storing two list sorted one on first and other on second?
17:30:30 <malvarez> satc: Worst case would still be O(n)
17:30:49 <malvarez> satc: But your average case would probably get faster
17:35:11 * hackagebot putlenses 0.1.1 - Put-based lens library  http://hackage.haskell.org/package/putlenses-0.1.1 (HugoPacheco)
17:39:11 <malvarez> andrew_: are you still having problems with (:)?
17:40:15 <andrew_> Yeah but I found some stuff to read online
17:40:41 <malvarez> You might find helpful to think about (:) as just syntactic sugar
17:41:13 <malvarez> If you defined 'data List t = Nil | Cons t (List t)', you can think of (:) as syntactic sugar for Cons
17:41:34 <andrew_> I'm just wondering with a:as = (exp) : (exp) call
17:41:41 <andrew_> each time he funcion is called
17:41:48 <andrew_> it'll move one element up the list right?
17:42:29 <malvarez> I'm not sure what you mean with that
17:43:29 <andrew_> ill keep playing with it
17:44:00 <startling> You can actually define "data List t = Nil | t : List t"
17:45:09 <malvarez> Isn't rebinding built-in syntax illegal?
17:45:24 <malvarez> Ghc 7.6.3 complains (at least without extensions on)
17:45:34 <khyperia> yes, andrew_, if you mean "up the list" as in "one element more to the end of the list" (assuming "(exp) call" does a recursive call with "as")
17:46:06 <andrew_> and this creates a new list in the process with my output?
17:46:13 <khyperia> yep
17:46:16 <andrew_> recursion hurts my brain
17:46:38 <khyperia> so, as an example...
17:47:19 <khyperia> "clone (x:xs) = x : clone xs" - a completely pointless operation, but it's the basics of list operation. Don't forget you also have to define "clone [] = []"
17:47:28 <mm_freak> will the reflection package provide Reifies instances for GHC.TypeLits?  if no, is there a library?
17:48:13 <khyperia> Of course, it's usually better to use functions like map and fold, but it's good to know how those are defined.
17:48:40 <mm_freak> khyperia: most list functions are folds or unfolds
17:48:48 <andrew_> I see thanks khyperia and malvarez
17:48:48 <mm_freak> khyperia: exercise: define 'map' in terms of foldr
17:48:59 <mm_freak> or rather @ andrew_
17:49:07 <malvarez> Come on, that's an easy one
17:50:37 <mm_freak> malvarez: rebinding syntax is illegal in standard haskell
17:50:45 <mm_freak> malvarez: but GHC has an extension for that
17:51:20 <malvarez> mm_freak: either way, doing it doesn't seem like a very good idea
17:51:34 <mm_freak> malvarez: it is a good idea in certain cases like indexed monads
17:51:35 <Mdx> hi #haskell, can someone give me some pointers on arrow do-rec notation ?
17:51:49 <mm_freak> Mdx: what's your question?
17:52:02 <satc> malvarez: Can I sort partially ordered list in O(n log n) time?
17:52:28 <Mdx> mm_freak: I'm rewriting a feedback loop as do notation, but I can't figure out how to use delay
17:52:39 <khyperia> mm_freak, I'm also a kind of haskell beginner, so I just tried to do that on my own. Could I PM you and see if it's right?
17:52:43 <mm_freak> Mdx: netwire?  yampa?
17:52:47 <Mdx> yampa
17:53:44 <mm_freak> Mdx: to understand that you have to ask yourself how the output of this instant depends on the input
17:53:48 <malvarez> satc: I might be wrong, but can't you extend your partial order to a total order (perhaps by comparing only the first component of your pair) and then just use Quick/Merge/Heap/Shellsort?
17:54:08 <Mdx> mm_freak: http://lpaste.net/94575
17:54:17 <Mdx> mm_freak: hmmm
17:54:46 <mm_freak> Mdx: example: the current instant output of the integration SF (integral/integrate or something) depends on the input of the /previous/ instant
17:54:57 <mm_freak> Mdx: so the integral SF supports feedback directly
17:55:07 <mm_freak> Mdx: (as in: without delay)
17:55:20 <Mdx> hmmmm
17:56:38 <mm_freak> Mdx: 'arr id' on the other hand is what i would call now-strict:  the output at 'now' depends on the input at 'now'
17:56:54 <mm_freak> so if you use 'loop' with 'arr id' you'll get <<loop>>
17:57:02 <mm_freak> that's when you have to use 'delay'
17:57:07 <Mdx> ok, i think i can picture that
17:57:32 <mm_freak> Mdx: unfortunately yampa is poorly documented in general and completely undocumented about time-strictness
17:57:43 <mm_freak> so it involves some guesswork =)
17:58:55 <malvarez> satc: I think you can do what you asked for in O(Log n)
17:59:30 <Mdx> Yeah, this kinda was the root of the problem to a SO question that I answered
17:59:39 <Mdx> but that was a lucky guess
18:00:30 <Mdx> but right now my problem seems to be of syntax/semantics
18:01:23 <mm_freak> semantics is actually quite simple, but yampa requires you to give up continuous time semantics temporarily and look at individual instants
18:02:20 <mm_freak> loop :: SF (a, c) (b, c) -> SF a b
18:02:55 <mm_freak> in many cases feedback knots don't actually depend on input themselves…  this gives rise to a simpler, but less general combinator
18:03:05 <Mdx> do i need to worry about yampa if I want to write something on arrow notation?
18:03:12 <mm_freak> fixW :: SF c (b, c) -> SF a b
18:03:23 <mm_freak> not really
18:04:09 <Mdx> hmmm
18:04:52 <mm_freak> arrow-notation translates to Category and Arrow combinators
18:05:18 <mm_freak> for some constructs you will need ArrowChoice or ArrowLoop
18:05:18 <mm_freak> yampa only gives you ArrowLoop though
18:06:00 <Mdx> AFAIU, arrowloop is what I need for recursive bindings
18:06:22 <mm_freak> yes, feedback requires ArrowLoop, which has the 'loop' combinator
18:06:27 <mm_freak> :t loop
18:06:27 <lambdabot> ArrowLoop a => a (b, d) (c, d) -> a b c
18:07:17 <Mdx> so in yampa, a= SF
18:07:19 <Mdx> ok
18:07:23 <mm_freak> yeah
18:09:31 <mm_freak> Mdx: the netwire introduction mostly applies to yampa as well, so you may want to give it a shot:  http://hub.darcs.net/ertes/netwire
18:09:58 <mm_freak> Mdx: the only difference is that you will have to translate applicative stuff to arrow style in your mind
18:13:33 <relrod> Does anyone know where to find the source for this page? I see a few issues/typos on it. http://www.haskell.org/platform/linux.html
18:14:07 <stephenmac7> Okay, how do I use multiple options and arguments with console-program?
18:14:21 <startling> stephenmac7, optparse-applicative is nice
18:14:55 <stephenmac7> startling: I guess I'll try it
18:15:00 <relrod> nevermind, found it. https://github.com/haskell/haskell-platform/blob/master/download-website/linux.html
18:15:11 <stephenmac7> console-program just seemed to make things easiest
18:15:28 <Mdx> mm_freak: shoot, I think I understood my mistake. The delay I was using was yampa delay and not arrow delay, wrong import
18:17:04 <mm_freak> Mdx: what is arrow delay?
18:17:28 <stephenmac7> Is there any software using console-program that I can take a look at
18:17:31 <Mdx> http://hackage.haskell.org/package/arrows-0.4.4.1/docs/Control-Arrow-Operations.html
18:17:51 <mm_freak> Mdx: it's the same thing, except that yampa doesn't provide an ArrowCircuit instance =)
18:18:07 <mm_freak> but you can write an ArrowCircuit instance with delay = Yampa.delay
18:18:09 <Mdx> but yampa expect 2 inputs, doesn't it?
18:18:45 <mm_freak> Mdx: indeed
18:18:57 <mm_freak> Mdx: i don't actually know what the Time argument is for
18:18:59 <Mdx> it expect Time and an a
18:19:16 <mm_freak> apparently they noticed that 'delay' exposes discrete time
18:19:40 <startling> is there an IO (ByteString -> String) somewhere that does things based on the user's locale?
18:20:19 <mm_freak> startling: well, there is hgettext
18:20:24 <mm_freak> @hackage hgettext
18:20:24 <lambdabot> http://hackage.haskell.org/package/hgettext
18:20:35 <startling> mm_freak: that might work. Thanks!
18:20:58 <startling> Well, I guess not.
18:21:41 <mm_freak> startling: you can implement IO (String -> String) based on getText
18:21:54 <mm_freak> hmm
18:21:56 <mm_freak> no, you can't
18:22:14 <mm_freak> it's an ugly interface, but that's mainly because gettext itself is ugly =/
18:22:32 <startling> IO (String -> String) is kind of, uh
18:23:01 <copumpkin> IO (forall a. a -> a)
18:23:07 <copumpkin> that can be useful!
18:23:17 <copumpkin> I think it was kmc that came up with something like that
18:23:27 <startling> copumpkin, is it "return id"?
18:23:39 <Mdx> fixed my problem
18:23:42 <copumpkin> startling: nope!
18:23:48 <malvarez> Nah, that's (forall a. IO (a->a))
18:23:58 <startling> copumpkin, return unsafeCoerce?
18:24:06 <malvarez> return undefined :D
18:24:08 <copumpkin> throttle :: Int -> IO (forall a. a -> a)
18:24:21 <copumpkin> or something like that
18:24:28 <startling> heh.
18:24:30 <mm_freak> an impredicative type as return type…  my brain just exploded
18:24:59 <copumpkin> a -> IO a perhaps
18:25:08 <copumpkin> who knows
18:25:08 <mm_freak> bottom aside, can it be anything other than id?
18:25:21 <copumpkin> the idea is to make it throttle calls to it
18:25:31 <copumpkin> let me see if I can find the original
18:25:49 <mm_freak> or some other function that behaves like id
18:26:12 <copumpkin> actually I had it wrong :)
18:26:20 <copumpkin>  Int -> IO (forall a. IO a -> IO a)
18:26:35 <malvarez> Oh, that makes a bit more sense
18:26:43 <mm_freak> withThrottle :: Int -> ((forall a. a -> a) -> IO a) -> IO a
18:26:46 <mm_freak> i'd prefer this one =)
18:26:53 <copumpkin> I was thinking of one that could be written but isn't particularly pure
18:27:04 <copumpkin> well, it is
18:27:06 <copumpkin> but meh :)
18:27:15 <Mdx> mm_freak:  thanks for the attention, got it working!
18:27:37 <mm_freak> Mdx: my pleasure =)
18:28:13 <copumpkin> you could easily just wrap mine in a newtype to use it
18:28:19 <mm_freak> Mdx: in return make a great application to support FRP adoption =)
18:29:28 <Mdx> mm_freak: I'll look how mixing linear systems and FRP goes D:
18:29:33 <stephenmac7> startling: This Applicative thing is complicated...
18:30:31 <mm_freak> Mdx: in most cases when you write a "main loop" sort of thing, you really want FRP =)
18:31:25 <mm_freak> (in the remaining cases you want a stream processing abstraction)
18:31:55 <mm_freak> (in other words: you never want to write a "main loop" in haskell) =)
18:32:07 <sordina> Hey. Is there a way to customise cabal init to create a .gitignore file?
18:32:13 <Mdx> mm_freak:  FRP really seems interesting, but the documentation seems to be scarce
18:32:30 <khyperia> I should learn FRP... seems like a good thing to know
18:32:39 <mm_freak> sordina: i highly doubt it…  i'm using mrbob to create a template package
18:33:12 <mm_freak> Mdx: Animas is a fork of yampa with better documentation;  and netwire is yampa on steroids with full documentation =)
18:33:13 <Mdx> khyperia: so many good things to learn, lens, pipes, arrows
18:33:28 <khyperia> And I know none of those!
18:33:32 <Mdx> there's always something else hiding
18:33:32 <sordina> mm_freak: I'll check it out. I'd say it would be pretty useful to be ablebleto customise your cabal templates... I might see if I can tweak it.
18:34:10 <Mdx> mm_freak: ohhh great, I better go to netwire
18:34:29 <mm_freak> Mdx: if you decide to use netwire, i recommend using netwire 5, which is not yet on hackage
18:34:40 <mm_freak> Mdx: http://hub.darcs.net/ertes/netwire
18:35:03 <mm_freak> netwire 4 will be obsoleted in the near future
18:35:19 <malvarez> Excuse the dumb question, but aren't impredicative types equivalent to higher-rank types?
18:35:21 <Mdx> mm_freak:  I look into yampa because of a reddit/so questio
18:35:38 <Mdx> mm_freak:  so I have no idea which libraries where around
18:35:46 <Mdx> mm_freak:  okk, thank you for the tip
18:35:54 <khyperia> Is there a consensus with "best FRP library" or is that a very huge opinionated question (If so, which one would you recommend for someone who hasn't used FRP yet)?
18:35:58 <mm_freak> Mdx: in the AFRP realm basically two:  yampa and netwire
18:36:11 <mm_freak> khyperia: that's very subjective
18:36:26 <mm_freak> khyperia: the big two are netwire and reactive-banana
18:36:34 <Mdx> mm_freak:  what's the A stands for? Arrow?
18:36:39 <mm_freak> Mdx: yeah
18:36:45 <mm_freak> Arrowized
18:37:23 <Mdx> reactive banana would be what kind of FRP?
18:38:05 <mm_freak> Mdx: let's call it "traditional" FRP
18:38:10 <Mdx> ok haha
18:38:42 <mm_freak> that doesn't make it less powerful in any way, it's just a different paradigm =)
18:38:44 <acowley> What about Sodium?
18:38:49 <acowley> It's also actively developed
18:39:50 <mm_freak> indeed…  seems like the author is trying to make monadic FRP practical
18:40:51 <cschneid> I'm sure arrow has something, but I'm not too familiar with arrow.  I want to take [1,2,3] and run a function and get back [(1,f 1), (2, f 2), (3, f 3)].
18:41:00 <Mdx> but, are all FRP equivalent, just the paradigm diferent?
18:41:07 <cschneid> map <some combinator> [1,2,3] -- but what am I looking for?
18:41:12 <mm_freak> cschneid: map (id &&& f)
18:41:26 <mm_freak> Mdx: no, the use cases differ
18:41:37 <Mdx> ok
18:41:50 <andrew_> what can we use in place of (n+k) patterns
18:42:01 <mm_freak> Mdx: reactive-banana (and apparently sodium) are useful for widget-style applications like GUIs
18:42:24 <mm_freak> Mdx: netwire is more for continuous applications like games/simulations
18:42:30 <andrew_> fib (n+1) = fib n + fib (n-1)
18:42:32 <andrew_> how would i do this
18:42:34 <mm_freak> netwire and yampa that is
18:42:50 <Mdx> mm_freak:  yeah, I remember that, that's why I got surprised on yampa being FRP doing linear systems
18:43:37 <Mdx> mm_freak: curious how broad FRP is
18:44:10 <malvarez> andrew_: Well, n-plus-k patterns were dropped, so my best guess would be 'fib n = fib (n-1) + fib (n-2);
18:44:10 <acowley> I think sodium was specifically developed in the context of game development
18:44:20 <malvarez> andrew_: without the semicolon
18:44:43 <andrew_> I have a old function using them and i tried that
18:44:52 <andrew_> perhaps its a semantics problem with the function
18:44:56 <mm_freak> Mdx: well, almost all systems that consist of one or more big application loops can be expressed in terms of FRP
18:46:01 <malvarez> andrew_: Do you also have definitions for fib 0 and fib 1?
18:47:48 <mm_freak> acowley: can't confirm that; sodium seems to use push semantics
18:48:15 <mm_freak> but then most games aren't continuous =)
18:48:30 <malvarez> andrew_: I can confirm this definition works on GHC 7.6 http://pastebin.com/h0VHRJVs
18:48:35 <mauke> The paste h0VHRJVs has been copied to http://lpaste.net/94577
18:48:57 <shelf> anyone got a moment to explain the `unIO` function in GHC.Base to me?
18:49:53 <gamegoblin> Hi all. On this page (http://www.haskell.org/haskellwiki/Simple_Servers#Epoll-based_event_callbacks) it says " there are still traditional calls to accept and sendAll, going via the Haskell concurrent IO layer, which are have redundant threading calls, so a fair bit of additional performance may be untapped."
18:49:53 <gamegoblin> What would they be replaced with?
18:50:05 <shelf> is it the hidden run function for IO monad? internal `safePerformIO`?
18:51:19 <ion> shelf: It just unwraps the magical value from an IO container. The magical value will almost certainly be of no use to you.
18:51:51 <DiegoNolan> is there an example of executing a query using left joins for postgresql-simple anywhere?
18:52:05 <wagle> anyne have a good example of code that uses the Maybe monad in the IO monad..  my code is tremendously ugly at the moment
18:52:19 <ion> wagle: Please paste your code.
18:52:41 <shelf> i'm just getting my head around the implementation of IO, as in, how stuff called from the 'main' will differ from something unsafePerformIO'd
18:53:05 <wagle> its not written completely yet
18:53:16 <ion> wagle: Paste it anyway. You’ll get the best hints that way.
18:54:34 <lpaste> wagle pasted “IO code wants the Maybe Monad” at http://lpaste.net/94578
18:54:36 <ion> shelf: Combining IO actions with (>>=) et al. will generate a bigger IO action that can be executed later to have the effects take place. Just evaluating the value will have no side effects. unsafePerformIO will add such effects as side effects to evaluation.
18:54:55 <shelf> i know unsafePIO makes a new world token and breaks sequentiality, and can be tossed around by the compiler. i'm more interested in what is applied to the IO action in 'main' to evaluate it
18:55:20 <shelf> i.e. we build an action with IO, we have a discouraged way to run it, what's the official run
18:55:21 <mm_freak> shelf: magic
18:55:32 <shelf> yes! i want to know the magic
18:55:54 <ion> wagle: You might benefit from using MaybeT IO.
18:56:06 <mm_freak> shelf: internally IO is indeed implemented by passing world values around, so the magic may look like this:  main ()
18:56:24 <mm_freak> or replace () by some World value:  data World = World
18:56:48 <ion> shelf: Note that this is just one possible implementation of IO in Haskell.
18:56:54 <wagle> ion how do I do that?  (wanted to see it done somewhere so I could wrap my brain around it)
18:57:04 <shelf> other implementations seem to use continuations?
18:57:15 <mm_freak> shelf: or even a GADT-like thing
18:57:27 <mm_freak> data IO :: * -> * where GetLine :: IO String; …
18:58:21 <shelf> i have a small school presentation, and i'm trying to emphasise the separation of composition and execution. but the simplest example of execution i can get is runST
18:59:13 <mm_freak> shelf: that's because IO is indeed a description type…  it's never meant to be executed within haskell
18:59:21 <mm_freak> shelf: i'd present IO using the GADT idea
18:59:31 <shelf> yeah, i know. i just wanted to anecdotally explain the way GHC runs an IO action
18:59:46 <shelf> but it's murky enough, i'll stay away from it
18:59:47 <wagle> ion: oh there I go: http://hackage.haskell.org/package/MaybeT-0.1.2/docs/Control-Monad-Maybe.html (at the end)
18:59:49 <malvarez> shelf: Why don't you write your own toy implementation of the IO monad?
19:00:01 <mm_freak> shelf: if you explain it exactly as GHC does it, people will be more confused at the end
19:01:04 <shelf> a single sentence is all the time i have for this anecdote, i was just curious if unIO was the magic hidden solution
19:01:29 <shelf> i'll leave it out, too far above my knowledge level
19:01:30 <mm_freak> shelf: just explain what "IO String" means
19:01:46 <mm_freak> this may help:  type ProgramThatProduces = IO
19:01:50 <shelf> these guys are very accustomed to using the IO monad, but aren't really familiar with wider monad utility
19:01:53 <mm_freak> getLine :: ProgramThatProduces String
19:02:26 <shelf> actual presentation topic is Andy Gill's paper on shoehorning Sets and other monad-like structures into acceptable instances of Monad class
19:02:56 <mm_freak> it also helps explaining the utilities of having first class IO actions:  mapM :: (a -> Program b) -> [a] -> Program [b]
19:03:30 <shelf> that does sound like a good way to explain it!
19:03:39 <mm_freak> or something more fancy like:  MVar (Program String)
19:04:15 <malvarez> Except that you can also reify IO actions in OCaml/Scala, can't you?
19:04:30 <ion> wagle: “do a <- Just 42; b <- Nothing; return (a + b)” – let’s say you want the 42 to be generated by the IO action “actA :: IO Integer”. “runMaybeT $ do a <- liftIO actA; b <- mzero; return (a + b)”. If you instead want the “Just 42” to be generated by the IO action “actB :: IO (Maybe Integer)”: “runMaybeT $ do a <- MaybeT actB; b <- mzero; return (a + b)”.
19:04:31 <malvarez> You just need to encode IO t as unit -> t
19:04:59 <shelf> ahh, this explains what i was wondering! http://web.archiveorange.com/archive/v/2B0uXmXDAWsNGBydzA8o
19:05:49 <mm_freak> shelf: here is a nice example:  you have a thread that HTTP-GETs a web-page and reports the result to other threads
19:05:51 <wagle> ion: ok, thanks!
19:06:27 <mm_freak> shelf: of course you could use something complicated to allow other threads to communicate to this thread
19:06:34 <ion> wagle: mzero = MaybeT (return Nothing)
19:06:44 <mm_freak> shelf: but here is a much nicer interface:  MVar (PageContent -> IO ())
19:07:28 <mm_freak> functional style combined with first class actions =)
19:07:42 <malvarez> mm_freak: can't you do that in any functional language as well?
19:07:54 <mm_freak> malvarez: not without side effects
19:08:03 <ana_> @ok \x -> (f x, x)
19:08:03 <lambdabot> Maybe you meant: yow wn v rc pl id do bf ask @ ? .
19:08:09 <ana_> @pl \x -> (f x, x)
19:08:09 <lambdabot> (,) =<< f
19:08:20 <mm_freak> ana_: f &&& id
19:08:24 <malvarez> mm_freak: So Haskell allows you to make side effects explicit, but still, the basic pattern remains feasible
19:08:24 <ion> first f
19:08:43 <mm_freak> :t first
19:08:44 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
19:08:47 <Ghoul_> > (+3) >>= (,) $ 4
19:08:48 <lambdabot>   (7,4)
19:08:49 <mm_freak> :t (&&& id)
19:08:51 <lambdabot> (a -> c) -> a -> (c, a)
19:09:03 <mm_freak> @ ion
19:09:14 <ion> Ah, sorry.
19:09:56 <ion> I was confused by (f *** id)
19:10:03 <mm_freak> yeah =)
19:10:14 <pavonia> :t (***)
19:10:15 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
19:12:37 <mm_freak> :t liftA2 (liftA2 (,) snd fst) id
19:12:38 <lambdabot>     Couldn't match type `(b1, a0)' with `b0 -> c0'
19:12:38 <lambdabot>     Expected type: (a0, b1) -> b0 -> c0
19:12:38 <lambdabot>       Actual type: (a0, b1) -> (b1, a0)
19:12:52 <mm_freak> :t liftA2 (flip (,)) id
19:12:53 <lambdabot> (a -> b) -> a -> (b, a)
19:12:55 <mm_freak> d'oh
19:13:28 <mm_freak> arrows confuse me to such an extent that i try to use tuples with applicative style and wonder why it doesn't work
19:14:48 <ion> :-)
19:14:55 <malvarez> I still don't get one thing
19:15:10 <malvarez> Is there any fundamental difference between higher-ranked types and impredicative types?
19:15:26 * hackagebot hmatrix-gsl-stats 0.2 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.2 (VivianMcPhail)
19:15:46 <mm_freak> malvarez: yes, logic is fine with higher-rank types, but usually rejects impredicative types =)
19:16:16 <malvarez> mm_freak: but can't you express any type as a function type?
19:16:21 <carter> whenever i see a math lib posted to hackage that has GPL deps i get grumpy
19:16:35 <mm_freak> malvarez: impredicative types add expressivity in that you can get rid of some auxiliary types
19:16:53 <malvarez> mm_freak: Sure, but are they fundamentally more expressive?
19:17:04 <mm_freak> yes
19:17:41 <carter> but they're also unsound
19:17:42 <carter> ish
19:18:03 <mm_freak> that's related to their expressivity =)
19:18:06 <carter> jah
19:18:15 <elliott> they're only unsound because GHC has a broken version.
19:18:20 <carter> you can get some impredicative operations with the right polymorphic data type
19:18:22 <carter> elliott: nope
19:18:27 <carter> coq used to be impredicative by default
19:18:35 <carter> they switched to predicative for soundness reasons
19:18:51 <elliott> uh
19:18:52 <carter> impredicativity + soundness is very very very subtle
19:18:55 <elliott> that's a different kind of predicativity entirely.
19:19:01 <carter> nope
19:19:01 <elliott> well.
19:19:07 <carter> same kinda of thing
19:19:15 <elliott> okay, it's related. but in predicative Coq you can still say foo (forall x, ...) for some foo.
19:19:21 <carter> yes
19:19:22 <carter> haskell too
19:19:23 <malvarez> I still don't get why can't you just rewrite any impredicative type as just a higher-ranked function
19:19:28 <elliott> anyway, it's more "consistency with LEM" than soundness, afaik.
19:19:32 <carter> ghc + higher rank types is predicative
19:19:38 <carter> by default
19:20:12 <copumpkin> malvarez: you can just wrap any "impredicative type" in a newtype if you want, and it'll work
19:20:19 <carter> yup
19:20:22 <carter> that works
19:20:27 <mm_freak> malvarez: consider this:  blah :: Maybe (forall a. a -> a)
19:20:39 <mm_freak> malvarez: you need an auxiliary type without impredicative types
19:20:40 <carter> copumpkin: howdy!
19:20:51 <copumpkin> hi :)
19:20:52 <mm_freak> usually you would prefer the auxiliary type though
19:21:08 <malvarez> Like, say you have [(forall t. t -> t)], and that's equivalent to (forall c. c -> ((forall t . t -> t) -> c -> c) -> c), right?
19:21:15 <malvarez> And so on for any other type
19:21:46 <cadabra`> Is it possible to write a Parsec parser without tying it to a specific string type? I want my client code to be able to use String/BS/Text, etc. I just get type errors if I try to use the type `ParsecT s u m a` instead of `Parser a`
19:23:32 <mm_freak> cadabra`: most predefined parsers are not stream-polymorphic, for example anyChar is defined separately for each of those
19:24:34 <mm_freak> oh
19:24:38 <mm_freak> anyChar actually is
19:25:14 <cadabra`> It looks like parseFromFile is the only thing defined separately..?
19:25:35 <mm_freak> indeed…  seems like i haven't used parsec for a long time
19:25:52 <mm_freak> cadabra`: could you paste your code?
19:29:48 <cadabra`> import Text.Parsec; myParse = char 'x'
19:33:23 <rs1> how does one desugar the ST monad example program here? http://en.wikipedia.org/wiki/Haskell_features#ST_monad
19:33:38 <rs1> i ran it through lambdabot's @undo but the output had the wrong type signature
19:34:43 <andrew_> http://lpaste.net/94579 <--- This makes my computer lockup
19:34:48 <andrew_> I guess it must be recursing forever
19:35:29 <malvarez> andrew_: it is, are you sure you don't mean 'where l = altenkirch (n-1)'?
19:37:55 <andrew_> ohhh
19:38:02 <andrew_> Missed a edge case aswell
19:41:34 <rs1> > let xs = [1..100] in runST $ do { summed <- newSTRef 0; forM_ xs $ \x -> do { modifySTRef summed (+x) }; readSTRef summed }
19:41:35 <lambdabot>   5050
19:41:42 <rs1> @undo runST $ do { summed <- newSTRef 0; forM_ xs $ \x -> do { modifySTRef summed (+x) }; readSTRef summed }
19:41:42 <lambdabot> runST $ newSTRef 0 >>= \ summed -> forM_ xs $ \ x -> modifySTRef summed (+ x) >> readSTRef summed
19:41:50 <rs1> > let xs = [1..100] in runST $ newSTRef 0 >>= \ summed -> forM_ xs $ \ x -> modifySTRef summed (+ x) >> readSTRef summed
19:41:51 <lambdabot>   ()
19:41:54 <rs1> what gives?
19:42:35 <copumpkin> hm?
19:42:49 <copumpkin> forM_ is providing your return value isn't it?
19:43:12 <rs1> my point is that the unsugared version appears to be incorrect
19:43:13 <copumpkin> did you intend for the forM_ lambda to end after the modifySTRef?
19:43:21 <copumpkin> oh
19:43:36 <copumpkin> true
19:43:47 <copumpkin> to the lambdabot-bugpatch maching!
19:44:03 <copumpkin> machine, even
19:54:29 <andrew_> http://lpaste.net/94579
19:54:37 <andrew_> can anyone tell me why i get the 0s
19:54:39 <andrew_> and minus numbers
19:54:49 <andrew_> im i just running out of bits in the "int"
19:55:50 <copumpkin> use Integer
19:56:25 <copumpkin> it looks like it'll get impossibly large pretty quickly though
19:56:42 <carter> Int has only 32 or 64 bits
19:56:47 <andrew_> Yeah its from an example paper
19:56:53 <andrew_> i dont think anyone was ever ment to run it
19:57:03 <andrew_> its been fucking my laptop up for hours trying to run it
19:57:08 <DiegoNolan> is there an example of postgres-simple query with left joins?
19:57:21 <DiegoNolan> i'm getting type conversion type errors
20:00:25 <stephenmac7> Anyone have an example of using optparse-applicative with the command feature?
20:00:33 <carter> whats teh command feature?
20:00:39 <carter> i'm pretty happy with opt parse btw
20:01:06 <Hodapp> optparse-applicative? I thought I was in #python for a moment.
20:01:10 <carter> yes
20:01:11 <carter> that one
20:01:14 <carter> the haskell one
20:02:03 <stephenmac7> carter: https://github.com/pcapriotti/optparse-applicative#commands
20:02:24 <carter> stephenmac7: nope
20:02:29 <carter> but looks easy
20:02:32 <carter> try stuff and see what happens :)
20:02:38 <stephenmac7> I've tried many things
20:02:39 <carter> i actully should try it out myself
20:02:41 <carter> oh
20:02:47 <stephenmac7> If only they had examples...
20:03:00 <carter> stephenmac7: they do!
20:03:07 <carter> you needd a different options record per command
20:03:08 <stephenmac7> No, full examples
20:03:14 <stephenmac7> I have that
20:03:28 <stephenmac7> Error: http://lpaste.net/94581
20:03:29 <carter> ok
20:03:36 <carter> stephenmac7: no
20:03:38 <carter> share the code
20:03:41 <stephenmac7> Code http://lpaste.net/94582
20:03:56 <carter> stephenmac7: tada https://github.com/pcapriotti/optparse-applicative/blob/master/tests/Examples/Commands.hs
20:04:41 <stephenmac7> carter: Seems to be similar
20:04:49 <stephenmac7> Still can't tell what's wrong with my code though
20:07:10 <stephenmac7> Hm. Think I got it to work
20:09:38 <carter> congrats
20:12:49 <stephenmac7> I hate cmd arguments
20:12:57 <stephenmac7> So rediculously complicated to setup
20:13:15 <johnw> send --type agreement --to stephenmac7
20:13:22 <stephenmac7> :D
20:13:37 <carter> applicatives are weird the first time you use them
20:13:37 <stephenmac7> That's one thing I miss from python
20:13:41 <stephenmac7> docopt
20:13:56 <stephenmac7> carter: It's not the applicatives as much as it is the library
20:13:56 <carter> oh?
20:14:03 <carter> stephenmac7: write a nicer one :)
20:14:04 <carter> please
20:14:07 <carter> if you see the path
20:14:10 <carter> make it so
20:14:11 <stephenmac7> carter: http://docopt.org/
20:14:40 <stephenmac7> I don't think something similar is possible in haskell though
20:15:54 <carter> why not?
20:15:57 <carter> stephenmac7: template haskell!
20:18:31 <carter> seriously
20:18:39 <carter> totally somethign template haskel could do
20:19:03 <geekosaur> aren't there already a couple TH-based arg parsers on hackage?
20:19:17 <carter> no clue
20:19:18 <carter> are there?
20:19:46 <twoolie> carter: a parsercombinator generating parser built inside a templatehaskell parsercombinator?
20:19:46 <carter> http://www.haskell.org/haskellwiki/Command_line_option_parsers
20:21:11 <carter> twoolie: we like well defined recursion right?
20:21:47 <geekosaur> I spot http://hackage.haskell.org/package/options and http://hackage.haskell.org/package/parse-help just from a quick search for "options"
20:22:03 <carter> geekosaur: see the link i linked
20:22:28 <geekosaur> yeh, I saw it, but I don't know how maintained that page is (the problem with wiki pages is they bitrot...)
20:25:36 <stephenmac7> carter: I'm new to haskell
20:25:54 <stephenmac7> Currently incapable of even writing regular haskell, much less template
20:26:03 <carter> well, sounds like your learning!
20:26:06 <stevejb> stephenmac7: carter is an amazing resource :)
20:26:16 <carter> stevejb: shhh, i'm also less productive than most folks
20:26:21 <stephenmac7> :D
20:26:45 <stevejb> carter: productivity is hard to measure. In terms of LOC/hour, we would all be better off switching to Java
20:27:10 <carter> stevejb: yes
20:30:50 <stephenmac7> Well, it's getting late, got to go
20:30:52 <stephenmac7> Bye!
20:31:40 <carter> stevejb: i sometimes worry i'm more productive at coordinating than coding though
20:32:14 <stevejb> carter: well both are useful things.
20:32:21 <carter> stevejb: shhhhh
20:32:38 <carter> stevejb: no one who manages gets to hack on cool stuff
20:33:04 <stevejb> yeah I can see that being a potential problem
20:33:33 <carter> the real secret is i can't manage, only pester and coordinate
20:34:08 <tomberek> is the new cabal 1.18 incompatible with haskell platform 2013.2?  because my cabal fails to install everything.
20:34:11 <stevejb> :) I think you are under-selling yourself
20:35:37 <carter> tomberek: nope, install it
20:35:55 <carter> tomberek: lpaste your error messages or we can't help
20:35:58 <tomberek> carter: yeah, i cleaned out my entire system (or at least I think i did)
20:36:02 <carter> tomberek: are you on  a mac with xcode 5?
20:36:18 <tomberek> carter: windows 7   (my arch box works no problem)
20:36:22 <carter> ok
20:36:32 <carter> is cabal's install dir on your path?
20:36:45 <carter> stevejb: look at your dm tab
20:37:21 <tomberek> carter: do you mean cabal itself? yeah, cabal --version gives me cabal version 1.18.0.2  using version 1.18.1.1 of Cabal library
20:37:27 <carter> ok
20:37:28 <wagle> how do you do a loop that can be "break"'d
20:37:31 <carter> whats the erro message?
20:37:38 <carter> wagle: tail calls!
20:37:47 <carter> and then just return :)
20:37:48 <tomberek> the errors for each package look like this: Failed to install utf8-light-0.4.2 Last 10 lines of the build log ( C:\Haskell\elm-lang.org\.cabal-sandbox\logs\utf 8-light-0.4.2.log ): Waiting for install task to finish...
20:38:05 <carter> tomberek: paste the full test to lpaste.net/new/haskell
20:38:24 <carter> stevejb: all i do is market, remains to see who's buying
20:38:31 <wagle> carter: yeah, then i have to roll my own recursion instead of using something like fold etc
20:38:48 <carter> wagle: depends on your foold
20:38:52 <carter> *fold
20:39:11 <carter> eg, you can return early with foldr, but not foldl
20:39:24 <carter> i think
20:39:53 <tomberek> carter: here is me trying to install lens into a sandbox, essentially the same error messages without sandboxes and any other package, the "logs" that are referenced are empty.
20:39:54 <tomberek> http://lpaste.net/94583
20:40:33 <tomberek> my build.log looks like this:
20:40:39 <carter> have you tried to install the libs they depend on in isolation to see what happens?
20:40:39 <tomberek> package: extensible-exceptions-0.1.1.4 os: windows arch: i386 compiler: ghc-7.6.3 client: cabal-install-1.18.0.2 flags: dependencies: base-4.6.0.1 install-outcome: ConfigureFailed docs-outcome: NotTried tests-outcome: NotTried
20:40:52 <carter> tomberek: ok
20:40:57 <carter> now try doing a NEW sanbox
20:41:02 <carter> and installing that one package
20:41:08 <carter> new directory
20:41:11 <carter> new sandbox init
20:41:11 <carter> etc
20:41:35 <tomberek> carter: same
20:41:43 <carter> report that to someone
20:41:52 <carter> tomberek: did you do a cabal update recently?
20:41:58 <tomberek> yeah
20:42:02 <carter> umm
20:42:02 <carter> no clue
20:42:07 <tomberek> i'll do it again
20:42:08 <carter> report bugs!
20:42:19 <carter> what ghc version?
20:42:33 <tomberek> C:\Haskell\hi>ghc --version The Glorious Glasgow Haskell Compilation System, version 7.6.3
20:42:38 <carter> i have no clue
20:42:44 <carter> tomberek: actually, ask leroux  for help !
20:42:46 <carter> (if he's around)
20:43:27 <carter> or ask Ghoul_
20:43:40 <carter> both of them have been testing ghc on windows a lot
20:43:50 <carter> i've not touched windows since 2007 i think
20:43:53 <pdxleif> Could anyone point me at how to make a Debian (Ubuntu) package of a Haskell program (Idris, specifically)?
20:44:06 <carter> pdxleif: probably the same way you make any other debian package
20:44:26 <pdxleif> I'm clueless about debian.
20:44:33 <pdxleif> I maintain idris packages for Arch linux.
20:44:54 <pdxleif> Just wish I knew where to put the equiv of "./configure && make && make install"
20:45:11 <pdxleif> I've installed cabal-debian, which purports to translate .cabal to .deb
20:45:31 <wagle> aeeeeii.  i wish my haskell indenter wasn't half insane
20:49:09 <linduxed> hey guys, i've got some tests in my /spec/ directory
20:49:15 <linduxed> while my actual code is in /src
20:49:43 <linduxed> i want to be able to write "import SomeModule", but right now it doesn't get found
20:50:07 <linduxed> to i have to reference the module with a relative path or can i tweak the load path somehow?
20:54:17 <carter> linduxed: look at a large project like lens
20:54:21 <carter> and how htey do it
20:54:36 <linduxed> carter: good idea, thx
21:05:59 <gamegoblin> Hi all. Getting error "Could not find module `System.Event'". Google is little help. Ideas?
21:06:38 <ion> It seems to be in base. You might have too old version of GHC.
21:06:50 <carter> anything older than 7.4 is painfully old
21:07:00 <carter> imnsho
21:07:01 <carter> :)
21:07:03 <gamegoblin> I have 7.6.2
21:07:09 <carter> huh
21:07:12 <ion> What’s the full error message?
21:07:17 <carter> does you cabal file have base?
21:07:35 <carter> that too
21:07:47 <gamegoblin> server.hs:17:8:
21:07:47 <gamegoblin>     Could not find module `System.Event'
21:07:47 <gamegoblin>     Perhaps you meant
21:07:47 <gamegoblin>       System.Exit (from base)
21:07:47 <gamegoblin>       System.Exit (needs flag -package haskell2010-1.1.1.0)
21:07:47 <gamegoblin>     Use -v to see a list of the files searched for.
21:08:02 <gamegoblin> I am just trying to run this code:
21:08:03 <gamegoblin> http://www.haskell.org/haskellwiki/Simple_Servers#Epoll-based_event_callbacks
21:08:47 <carter> do you have the two libs listed installeD?
21:09:04 <ion> Ok, looking closer, it seems it *used to* exist in base. You have a too new version of GHC. :-P
21:09:08 <gamegoblin> I read that event got merged into haskell main
21:09:11 <gamegoblin> Whaaaaa
21:09:24 <carter> gamegoblin: try installing the deps
21:09:24 <gamegoblin> Craziness
21:09:29 <ion> I see it in 4.3.1.0. http://hackage.haskell.org/package/base-4.3.1.0/docs/System-Event.html
21:09:39 <ion> But not 4.4.0.0
21:09:58 <gamegoblin> Any reason why they'd do that? And any way I can get it back?
21:11:10 <ion> http://ghc.haskell.org/trac/ghc/ticket/635 “closed task (fixed)”, i guess IO uses epoll by default now.
21:11:23 <gamegoblin> huh...
21:13:39 <chrisdotcode> what's the easiest way to convert something like "sum [1..10]" to a double? is it: fromIntegral (sum [1..10]):: Double?
21:13:59 <latro`a> by not converting
21:14:07 <latro`a> :t sum [1..10]
21:14:07 <lambdabot> (Enum a, Num a) => a
21:14:21 <ion> > sum [1..10] :: Double
21:14:22 <lambdabot>   55.0
21:14:52 <ion> Enum for Double is nasty, thoughj.
21:15:21 <chrisdotcode> well that works; but in actuality, I'm using a fold to do it. my code is summing a list of reviews, and then later it averages them: "foldr ((+) . reviewRating) 0 reviews"
21:15:57 <ion> sum . map reviewRating
21:16:18 <chrisdotcode> why didn't I think of that? -_-
21:18:44 <carter> learning :)
21:20:04 <chrisdotcode> carter: my favorite part about haskell :)
21:20:12 <chrisdotcode> it's insane how much I can refactory
21:20:19 <chrisdotcode> s/refactory/refactor
21:20:30 <arkeet> if it's a long list, then I hope you're not doing something like
21:20:34 <carter> abstractRefactoringBeansFactory
21:20:35 <arkeet> sum list / length list
21:20:59 <carter> multipass or folds or tekmo has a thing
21:21:08 <carter> all let you do fuse multiple 1 pass algs into a single pass
21:21:12 <carter> so you don't blow up space
21:21:14 <chrisdotcode> arkeet: er, I was doing that. what's the proper way?
21:21:40 <carter> http://hackage.haskell.org/package/folds ?
21:21:45 <arkeet> well, the point is that doing that makes it hold onto the entire list.
21:21:52 <arkeet> you can compute the sum and the length in a single fold.
21:22:12 <chrisdotcode> would you know how that would look offhand?
21:22:22 <carter> (count,sum)
21:22:38 <carter> would be your fold state
21:22:43 <carter> if you're doing it directly
21:22:45 <arkeet> > foldr (\a ~(sum,len) -> (sum + a, len + 1)) (0,0) [1..10]
21:22:46 <lambdabot>   (55,10)
21:22:59 <arkeet> hm, use foldl' instead.
21:23:10 <tomberek> does anyone know of a way to remove all traces of haskell/ghc/cabal/etc from windows in order to do a complete refresh? I thought there was a page that outlined it, but couldn't find it, maybe it's too late
21:23:38 <chrisdotcode> oh,that's really cool! and then when you're done, you just divide
21:23:38 <carter> kill ~/.ghc ?
21:23:44 <carter> chrisdotcode: yup
21:23:45 <latro`a> :t let sumLength = foldl' (\(n,s) x -> (n+1,s+x)) 0
21:23:46 <lambdabot> <no location info>:
21:23:46 <lambdabot>     not an expression: `let sumLength = foldl' (\(n,s) x -> (n+1,s+x)) 0'
21:24:23 <carter> :t  let sumLength = foldl' (\(n,s) x -> (n+1,s+x)) 0 in sumLength
21:24:23 <lambdabot> (Num t, Num t1, Num (t, t1)) => [t1] -> (t, t1)
21:24:32 <carter> :)
21:24:41 <carter> huh
21:24:43 <latro`a> hrm, it seems to want the tuple to be Num
21:24:44 <Michael_> I'm sorry, I'm really having trouble interpreting what should be a simple type error, can anyone help me figure out what is wrong with this code? https://gist.github.com/mfine15/7078591
21:24:47 <latro`a> did I make an error?
21:25:06 <carter> :t foldl'
21:25:07 <lambdabot> (a -> b -> a) -> a -> [b] -> a
21:25:22 <carter> you need ti give it (0,0)
21:25:26 <latro`a> oh, duh
21:25:28 <latro`a> silly
21:25:34 <carter> :t  let sumLength = foldl' (\(n,s) x -> (n+1,s+x)) (0,0) in sumLength
21:25:35 <lambdabot> (Num t, Num t1) => [t1] -> (t, t1)
21:25:50 <carter> nah, wanting to lift num ops onto tuples is sane
21:25:52 <carter> not siilly
21:26:00 <latro`a> sure, it's just the error that is silly
21:26:48 <carter> idk, 0 lifted to tuples should be a thing :)
21:28:58 <carter> hrmmm
21:28:59 <carter> hehe
21:33:06 <Michael_> How would I split a string like "MnHrB" into ["Mn","Hr",B"]?
21:34:42 <carter> Michael_: look at Data.List :)
21:35:58 <carter> theres probably a bunch of splitting utils there
21:36:18 <carter> http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-List.html#v:splitAt is one
21:36:42 <Cale> > split (dropInitBlank . keepDelimsL $ whenElt isUpper) "MnHrB" -- do we have Data.List.Split?
21:36:43 <lambdabot>   ["Mn","Hr","B"]
21:36:46 <Cale> we do
21:37:06 <Cale> I'm not entirely sure what kind of splitting you want to do from that one example... there are obviously other ways to get that result
21:37:28 <Cale> > map (take 2) . takeWhile (not . null) . iterate (drop 2) $ "MnHrB"
21:37:29 <lambdabot>   ["Mn","Hr","B"]
21:37:57 <carter> hey Cale !
21:38:02 <Cale> > split (dropInitBlank . keepDelimsL $ whenElt isUpper) "HereIsSomeCamelCaseStuff"
21:38:03 <lambdabot>   ["Here","Is","Some","Camel","Case","Stuff"]
21:38:12 <Cale> > split (dropInitBlank . keepDelimsL $ whenElt isUpper) "hereIsSomeCamelCaseStuff"
21:38:13 <lambdabot>   ["here","Is","Some","Camel","Case","Stuff"]
21:40:01 <harovali1> hi
21:40:21 <Cale> hi carter
21:40:30 <Cale> and hi harovali1
21:41:25 <harovali1> for the people that has dove into the grammars world, how do you call the inverse of the parsing problem ? generation of code or generative grammar?
21:41:36 <carter>  pretty printing :)
21:42:01 <carter> on direction is easier
21:42:05 <harovali1> carter: that's right , it's more or less that
21:42:06 <carter> just like derivatives and integrals
21:42:11 <carter> *one
21:42:25 <harovali1> carter: sure, like them
21:42:26 <latro`a> (that's actually a bit deceptive; analytically speaking, integrals are easier)
21:42:39 <carter> latro`a: no
21:42:42 <Cale> Well, there's pretty printing, yeah, and then there's generative stuff, where you construct random strings or all strings belonging to a given language.
21:42:52 <latro`a> or are you referring to constant-of-integration issues?
21:43:13 <carter> latro`a: for any analytic expression over the elementary functions, we can take the derivative
21:43:20 <latro`a> that's not saying very much
21:43:22 <carter> and get back an analytic expression of elementary fucntions
21:43:26 <latro`a> from other standpoints
21:43:34 <carter> can't integgrate and get that closure
21:43:35 <Cale> carter: The derivative is a horribly discontinuous function though, while the integral acts on functions continuously.
21:43:39 <carter> true
21:43:54 <carter> pretty printing has layout problems ;)
21:44:04 <Cale> In the sense that if the maximum difference between two functions is small then their integrals are close together
21:44:14 <Cale> while this says nothing about their derivatives
21:44:14 <latro`a> in numerous senses, actually
21:44:37 <carter> so basically the answer is "depends"
21:44:47 <harovali1> think about the following image; you have a grammar, and you want to write correct code for the grammar using some data, that plays the role of "data driven program writing" (to supersede the pretty printing solution). How do you call that ? Is that something well known? are there libraries for that ?
21:44:55 <latro`a> it comes down to how you look at it, but I don't think it's usually useful to look at it the other way
21:45:49 <Cale> Consider something like f_n(x) = 1/n sin(n^2 x), which gives a sequence of functions converging to 0, but whose derivatives don't get close to the derivative of the zero function at all.
21:46:14 <carter> Cale: latro`a  oh i'll agree that integrals are better behaved than derivatives
21:46:23 <carter> i just meant in terms of mechanical computations on them
21:46:35 <latro`a> fair enough then
21:46:48 <carter> we have pretty awesome tools in haskell for numerical integration
21:46:52 <carter> i need to play with them sometime
21:48:46 <Cale> harovali1: I *think* you're leaning on the side of pretty printing.
21:50:34 <harovali1> Cale: hmmm. I'd like some formalization of the pretty printer, based on a list of data that "drive" tha path of the chosen grammar, and outputs the keyworkds of the grammars, and the variable strings of the data
21:52:41 <carter> harovali1: theres libs the let you specify the parser and pretty printer in one go
21:52:41 <chrisdotcode> is there anyway I can turn this into a one-liner?
21:52:42 <chrisdotcode> diffFromNow :: MonadIO m => UTCTime -> m String
21:52:42 <chrisdotcode> diffFromNow t = do
21:52:42 <chrisdotcode>   now <- liftIO getCurrentTime
21:52:42 <chrisdotcode>   return $ humanReadableTimeDiff now t
21:53:07 <NihilistDandy> >>=?
21:53:32 <NihilistDandy> :t liftIO getCurrentTime >>= return $ humanReadableTimeDiff now t
21:53:33 <lambdabot> Not in scope: `getCurrentTime'
21:53:33 <lambdabot> Not in scope: `humanReadableTimeDiff'
21:53:33 <lambdabot>     Not in scope: `now'
21:53:34 <harovali1> carter: should I google for them ?
21:53:43 <carter> theres a few
21:53:50 <Cale> fmap (\now -> humanReadableTimeDiff now t) (liftIO getCurrentTime)
21:53:50 <carter> uuparse is one i tink
21:53:52 <carter> theres another
21:53:56 <harovali1> carter: any pointer are more than welcome
21:54:20 <carter> uuparse is one
21:54:23 <chrisdotcode> Cale: that's like something that I was looking for. but is it better to do it like that, or to use do notation?
21:54:23 <carter> theres some others
21:54:27 <carter> or at least papers of suh
21:54:28 <carter> such
21:54:32 <carter> invertible parsing etc
21:54:35 <Cale> chrisdotcode: It's equivalent
21:54:43 <chrisdotcode> Cale: better, stylewise
21:54:48 <carter> you wind up need to only allow applaticative grammars
21:54:53 <carter> no monads
21:54:53 <Cale> That's a matter of taste
21:55:07 <Cale> I use either one, depending on my mood
21:55:34 <chrisdotcode> okay, cool. I was trying to see if there was a better stylistic way it should be written, and then follow that in my code
21:55:39 <Cale> If you're planning to extend the do-block with more stuff later, maybe rewriting it to an fmap isn't going to be convenient
21:55:55 <Cale> But otherwise, it might be a little nicer as fmap
21:56:21 <harovali1> carter: you seem to know more than I on the issue !  you even mentioned sci papers  and a name for the approach, invertible parsers. It's the first time I come across such data !!! Thanks a lot, any other information I'd thank a lot really
21:56:37 <chrisdotcode> yeah, it's probably not going to need extension. thanks :)
21:56:38 <carter> thats all i remember without googling myself
21:56:39 <harovali1> carter: uuparse seems very interesting
21:56:43 <carter> its one approach
21:56:49 <harovali1> carter: sure
21:56:49 <carter> googling around should show you others
21:57:19 <harovali1> carter:  I'll do. Would you mind if I inisist on the issue after I do my googling?
21:57:31 <carter> insist on what?
21:57:37 <harovali1> carter: ask more
21:57:54 <carter> i know nothing
21:57:55 <carter> literall
21:58:00 <carter> i've enver used em
21:58:07 <harovali1> carter: you know more than I expected
21:58:10 <harovali1> thanks
22:00:49 * hackagebot karakuri 0.1.1 - Good stateful automata  http://hackage.haskell.org/package/karakuri-0.1.1 (FumiakiKinoshita)
22:29:24 <the_last> Hey guys, I'm thinking about creating the worlds first REAL AI. In haskell. Can anyone give me some pointers?
22:30:34 <xico> null
22:30:50 <cbw> Ain't Real AI kinda a Oxymoron
22:30:51 <Enigmagic> the_last: i'd start by watching Terminator 1
22:31:01 <the_last> Enigmagic: Yeah, that's where I got my inspiration.
22:31:26 <Cale> See Foreign.Ptr
22:31:40 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Ptr.html
22:31:57 <the_last> Thanks Cale, that's what I was looking for.
22:32:26 <cbw> the_last: http://omegataupodcast.net/2013/04/122-artificial-intelligence/
22:32:48 <the_last> ooo
22:32:55 <the_last> This looks cool
22:33:00 <zRecursive> @where xmonad
22:33:00 <lambdabot> #xmonad | http://xmonad.org/
22:34:04 <xico> the_last: if you go to machine learning or natural language processing you're on the total opposite side of any plausible artificial intelligence
22:34:20 <xico> on the other hand, you fall totally in the 70's
22:34:42 <the_last> xico: isn't machine learning AI?
22:35:15 <xico> i thought machine learning was crappy bayesian stuff
22:35:33 <the_last> Ah yeah, you're probably right
22:35:38 <Cale> How do you know that the brain isn't just doing crappy bayesian stuff? :)
22:35:53 <xico> because i'm a brain scientist?
22:36:00 <Cale> well then
22:36:04 <the_last> rebelscience.blogspot.com.au - that guy seems to think the bayesian approach is bs.
22:36:13 <xico> (acutally that does not prove anything but my own pov)
22:37:07 <Cale> I'm not an expert, but I have the impression that it's quite possible that the cortex functions largely in a very uniform way
22:37:39 <the_last> http://rebelscience.blogspot.com.au/2012/08/the-myth-of-bayesian-brain-part-i.html
22:38:04 <cbw> the_last: From what I learned from the podcast there are two main ways that AI is made. Truth tables or Neural network
22:38:39 <elliott> the_last: hah, if you put stock in that quack you might want to read http://rebelscience.blogspot.co.uk/2007/09/why-i-think-functional-programming.html then
22:39:00 <Cale> and that the similarity between people in how the cortex is split into functional regions is perhaps mostly due to how it's connected to sensory input
22:39:08 <the_last> I don't put stock in it, I was more curious what other people thought :-)
22:39:28 <elliott> well, that guy also goes on about disproving Einstein and how the Bible teaches him how to make AI or whatever, so, yaknow.
22:39:29 <cbw> A Truth tables is a logic structure Some thing that like Prolog is good at. A neural network is a Graph of nodes connected by probibilies
22:39:31 <the_last> He seems like a nutter, but it's hard to tell if he's onto something or not because I lack the experience.
22:39:51 <the_last> elliott: yeah, doesn't help his cause.
22:39:53 <elliott> not claiming any opinion on bayesianism myself
22:40:10 <Cale> I don't know whether it's *Bayesian* in any meaningful sense though :)
22:40:25 <xico> the_last: that last url you gave is bs also. bayesian neural models ooften assume that the uncertainity comes from the senses, not from the world.
22:40:54 <Cale> In fact, I don't even *really* understand why people see the need to make such a big deal about the Bayesian vs. frequentist understanding of probability theory.
22:41:17 <the_last> xico: ah okay, so best to ignore his opinion then? Haha.
22:41:52 <xico> the_last: dunno.
22:50:03 <xico> the_last: i guess, as for useful pointers, i would start by considering a simple subsystem of your ai, like a sensor
22:50:47 <xico> the_last: such as vision, audition, or any other
22:51:35 <xico> the_last: then i would look for some biological data, that could help understand how it works
22:51:37 <zRecursive> maybe Lisp/Prolog are much practical langauges for AI ?
22:51:55 <xico> the_last: finally, i would select/define/ameliorate a model, and implement it in haskell
22:54:00 <ReinH> Cale: Bayes is overrated.
22:54:26 <xico> the_last: (as a possible selection, i would say, go for vision, well studied, read a bit about the retina and the primary visual cortex, and use an existing family of modelling such as wilson-cowan neural fields or something high level like this)
23:01:15 <wagle> how do I find out where my <<loop>> is?  google ignores the << and >>
23:02:25 <the_last> Thanks xico, I shall heed your advice.
23:05:04 <Cale> wagle: Sometimes compiling with profiling and running the program with +RTS -xc can help
23:05:16 <Cale> wagle: You'll get a cost centre stack trace
23:05:30 <wagle> ok, thanks Cale
23:06:11 <Cale> wagle: But mostly, it comes down to thinking about why your recursion is bad. Look for variables which are shadowed accidentally.
23:07:18 <wagle> big program, but I actually figured this one out..  thought i;d thank you for the next time
23:07:38 <Cale> cool
23:07:46 <wagle> let bottom = bottom - 1
23:07:55 <wagle> aptly named var
23:08:01 <kqr> when it comes to pretty-printing your data, i know you are not supposed to use Show for that, but is there any other convention?
23:08:01 <Cale> haha
23:08:03 <Cale> really?
23:08:27 <wagle> yeah..
23:09:48 <Cale> kqr: If you're working with multiple types, it can help to make your own typeclass for it. Also, look at pretty printer libraries like wl-pprint
23:12:45 <kqr> Cale, although my kind of data is far from a real "document", wl-pprint looks very useful. thanks!
23:13:28 <Cale> kqr: Well, it's more intended for "documents" like source code than anything else.
23:13:42 <Cale> But I can imagine that it would be useful for lots of plaintext things
23:13:47 <kqr> yeah, i think it is
23:14:12 <kqr> but i realised that plaintext isn't enough for my purposes (mathematical expressions) so i think i'll rather just convert to latex and print that out
23:18:51 <wagle> hey, no fair!  my program typechecks, it should be correct now!
23:20:44 <user123abc> I have code that maintains a mutable vector and derives an intermediate value from it at certain points
23:21:31 <user123abc> the function which computes the intermediate value doesn't modify the vector and in fact has to operate on the immutable version since it used a function not defined for MVector (findIndex)
23:22:15 <user123abc> I've been using MV.freeze to generate the Vector for this function to use, but that does seem to be copying it and wasting memory
23:22:48 <user123abc> do I have any options to avoid this? I have to continue using the immutable vector afterwards
23:23:06 <user123abc> rather, "using the MUTABLE vector"
23:43:49 <lpaste> wagle pasted “whats wrong with the final return?” at http://lpaste.net/2757209188298915840
23:44:27 <scshunt> wagle: hard to say without knowing more
23:44:31 <scshunt> what is everything?
23:44:34 <scshunt> what error do you get?
23:44:50 <wagle> soln.hs:115:3: parse error on input `return'
23:45:16 <scshunt> wagle: oh wait, you're using 'where' there
23:45:29 <scshunt> wagle: you can't do that; 'where' only applies at the top level
23:46:23 <wagle> i've done it elsewhere, but...
23:46:52 <scshunt> wagle: hmm... maybe there are other cases
23:46:58 <scshunt> but in any case, the problem is your where
23:47:08 <scshunt> I don't know the syntax that well; I thought where was top-level only
23:48:27 <arkeet> where is something that works with any declaration.
23:48:55 <arkeet> er
23:49:00 <arkeet> if declaration is the right word.
23:49:08 <arkeet> I don't think it is.
23:49:23 <scshunt> arkeet: binding?
23:49:49 <arkeet> not quite.
23:49:58 <arkeet> maybe declaration is the word.
23:59:13 <jle`> i've done nested where's before
